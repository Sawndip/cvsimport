head	1.523;
access;
symbols
	binutils-2_24-branch:1.521.0.2
	binutils-2_24-branchpoint:1.521
	binutils-2_21_1:1.452.2.2
	binutils-2_23_2:1.497.2.2
	binutils-2_23_1:1.497.2.2
	binutils-2_23:1.497.2.1
	binutils-2_23-branch:1.497.0.2
	binutils-2_23-branchpoint:1.497
	binutils-2_22_branch:1.478.0.4
	binutils-2_22:1.478
	binutils-2_22-branch:1.478.0.2
	binutils-2_22-branchpoint:1.478
	binutils-2_21:1.452
	binutils-2_21-branch:1.452.0.2
	binutils-2_21-branchpoint:1.452
	binutils-2_20_1:1.391.2.2
	binutils-2_20:1.391.2.2
	binutils-arc-20081103-branch:1.354.0.4
	binutils-arc-20081103-branchpoint:1.354
	binutils-2_20-branch:1.391.0.2
	binutils-2_20-branchpoint:1.391
	dje-cgen-play1-branch:1.378.0.2
	dje-cgen-play1-branchpoint:1.378
	arc-20081103-branch:1.354.0.2
	arc-20081103-branchpoint:1.354
	binutils-2_19_1:1.352.2.1
	binutils-2_19:1.352.2.1
	binutils-2_19-branch:1.352.0.2
	binutils-2_19-branchpoint:1.352
	binutils-2_18:1.271.2.2
	binutils-2_18-branch:1.271.0.2
	binutils-2_18-branchpoint:1.271
	binutils-csl-coldfire-4_1-32:1.207.2.1
	binutils-csl-sourcerygxx-4_1-32:1.207.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.207.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.167.2.1
	binutils-csl-coldfire-4_1-30:1.207.2.1
	binutils-csl-sourcerygxx-4_1-30:1.207.2.1
	binutils-csl-coldfire-4_1-28:1.207.2.1
	binutils-csl-sourcerygxx-4_1-29:1.207.2.1
	binutils-csl-sourcerygxx-4_1-28:1.207.2.1
	binutils-csl-arm-2006q3-27:1.207.2.1
	binutils-csl-sourcerygxx-4_1-27:1.207.2.1
	binutils-csl-arm-2006q3-26:1.207.2.1
	binutils-csl-sourcerygxx-4_1-26:1.207.2.1
	binutils-csl-sourcerygxx-4_1-25:1.207.2.1
	binutils-csl-sourcerygxx-4_1-24:1.207.2.1
	binutils-csl-sourcerygxx-4_1-23:1.207.2.1
	binutils-csl-sourcerygxx-4_1-21:1.207.2.1
	binutils-csl-arm-2006q3-21:1.207.2.1
	binutils-csl-sourcerygxx-4_1-22:1.207.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.207.2.1
	binutils-csl-sourcerygxx-4_1-20:1.207.2.1
	binutils-csl-arm-2006q3-19:1.207.2.1
	binutils-csl-sourcerygxx-4_1-19:1.207.2.1
	binutils-csl-sourcerygxx-4_1-18:1.207.2.1
	binutils-csl-renesas-4_1-9:1.207.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.167.2.1
	binutils-csl-renesas-4_1-8:1.207
	binutils-csl-renesas-4_1-7:1.207
	binutils-csl-renesas-4_1-6:1.207
	binutils-csl-sourcerygxx-4_1-17:1.207
	binutils-csl-sourcerygxx-4_1-14:1.207
	binutils-csl-sourcerygxx-4_1-15:1.207
	binutils-csl-sourcerygxx-4_1-13:1.207
	binutils-2_17:1.209
	binutils-csl-sourcerygxx-4_1-12:1.207
	binutils-csl-sourcerygxx-3_4_4-21:1.207
	binutils-csl-wrs-linux-3_4_4-24:1.167
	binutils-csl-wrs-linux-3_4_4-23:1.167
	binutils-csl-sourcerygxx-4_1-9:1.207
	binutils-csl-sourcerygxx-4_1-8:1.207
	binutils-csl-sourcerygxx-4_1-7:1.207
	binutils-csl-arm-2006q1-6:1.207
	binutils-csl-sourcerygxx-4_1-6:1.207
	binutils-csl-wrs-linux-3_4_4-22:1.167
	binutils-csl-coldfire-4_1-11:1.207
	binutils-csl-sourcerygxx-3_4_4-19:1.207
	binutils-csl-coldfire-4_1-10:1.207
	binutils-csl-sourcerygxx-4_1-5:1.207
	binutils-csl-sourcerygxx-4_1-4:1.207
	binutils-csl-wrs-linux-3_4_4-21:1.167
	binutils-csl-morpho-4_1-4:1.207
	binutils-csl-sourcerygxx-3_4_4-17:1.207
	binutils-csl-wrs-linux-3_4_4-20:1.167
	binutils-2_17-branch:1.209.0.2
	binutils-2_17-branchpoint:1.209
	binutils-csl-2_17-branch:1.207.0.2
	binutils-csl-2_17-branchpoint:1.207
	binutils-csl-gxxpro-3_4-branch:1.167.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.167.2.1
	binutils-2_16_1:1.167.2.1
	binutils-csl-arm-2005q1b:1.167
	binutils-2_16:1.167.2.1
	binutils-csl-arm-2005q1a:1.167
	binutils-csl-arm-2005q1-branch:1.167.0.4
	binutils-csl-arm-2005q1-branchpoint:1.167
	binutils-2_16-branch:1.167.0.2
	binutils-2_16-branchpoint:1.167
	csl-arm-2004-q3d:1.159
	csl-arm-2004-q3:1.156
	binutils-2_15:1.149.6.1
	binutils-2_15-branchpoint:1.149
	csl-arm-2004-q1a:1.151
	csl-arm-2004-q1:1.150
	binutils-2_15-branch:1.149.0.6
	cagney_bfdfile-20040213-branch:1.149.0.4
	cagney_bfdfile-20040213-branchpoint:1.149
	cagney_bigcore-20040122-branch:1.149.0.2
	cagney_bigcore-20040122-branchpoint:1.149
	csl-arm-2003-q4:1.149
	binutils-2_14:1.138
	binutils-2_14-branch:1.138.0.2
	binutils-2_14-branchpoint:1.138
	binutils-2_13_2_1:1.123.2.3
	binutils-2_13_2:1.123.2.3
	binutils-2_13_1:1.123.2.3
	binutils-2_13:1.123
	binutils-2_13-branchpoint:1.123
	binutils-2_13-branch:1.123.0.2
	binutils-2_12_1:1.108.2.7
	binutils-2_12:1.108.2.2
	binutils-2_12-branch:1.108.0.2
	binutils-2_12-branchpoint:1.108
	cygnus_cvs_20020108_pre:1.107
	binutils-2_11_2:1.83.2.7
	binutils-2_11_1:1.83.2.7
	binutils-2_11:1.83.2.5
	x86_64versiong3:1.87
	binutils-2_11-branch:1.83.0.2
	binutils-2_10_1:1.41.2.3
	binutils-2_10:1.41.2.3
	binutils-2_10-branch:1.41.0.2
	binutils-2_10-branchpoint:1.41
	binutils_latest_snapshot:1.523
	repo-unification-2000-02-06:1.33
	binu_ss_19990721:1.10
	binu_ss_19990602:1.5
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.523
date	2013.10.08.15.21.58;	author jbeulich;	state Exp;
branches;
next	1.522;

1.522
date	2013.09.30.17.02.06;	author sekanath;	state Exp;
branches;
next	1.521;

1.521
date	2013.07.26.17.20.21;	author hjl;	state Exp;
branches;
next	1.520;

1.520
date	2013.07.25.16.16.34;	author hjl;	state Exp;
branches;
next	1.519;

1.519
date	2013.07.24.15.47.24;	author hjl;	state Exp;
branches;
next	1.518;

1.518
date	2013.05.31.17.27.27;	author hjl;	state Exp;
branches;
next	1.517;

1.517
date	2013.03.07.21.40.06;	author hjl;	state Exp;
branches;
next	1.516;

1.516
date	2013.02.28.21.08.04;	author hjl;	state Exp;
branches;
next	1.515;

1.515
date	2013.02.28.20.50.18;	author hjl;	state Exp;
branches;
next	1.514;

1.514
date	2013.02.19.19.10.26;	author hjl;	state Exp;
branches;
next	1.513;

1.513
date	2013.01.18.16.37.08;	author hjl;	state Exp;
branches;
next	1.512;

1.512
date	2013.01.17.04.28.42;	author hjl;	state Exp;
branches;
next	1.511;

1.511
date	2013.01.15.20.34.10;	author hjl;	state Exp;
branches;
next	1.510;

1.510
date	2013.01.10.19.51.55;	author hjl;	state Exp;
branches;
next	1.509;

1.509
date	2013.01.09.18.31.21;	author sje;	state Exp;
branches;
next	1.508;

1.508
date	2012.10.09.08.42.58;	author neggone;	state Exp;
branches;
next	1.507;

1.507
date	2012.09.20.11.53.31;	author hjl;	state Exp;
branches;
next	1.506;

1.506
date	2012.08.17.17.12.28;	author hjl;	state Exp;
branches;
next	1.505;

1.505
date	2012.08.14.17.01.44;	author hjl;	state Exp;
branches;
next	1.504;

1.504
date	2012.08.07.16.57.48;	author jbeulich;	state Exp;
branches;
next	1.503;

1.503
date	2012.08.07.16.55.00;	author jbeulich;	state Exp;
branches;
next	1.502;

1.502
date	2012.08.07.16.51.32;	author jbeulich;	state Exp;
branches;
next	1.501;

1.501
date	2012.08.07.13.47.18;	author nickc;	state Exp;
branches;
next	1.500;

1.500
date	2012.07.31.07.45.48;	author jbeulich;	state Exp;
branches;
next	1.499;

1.499
date	2012.07.31.07.43.38;	author jbeulich;	state Exp;
branches;
next	1.498;

1.498
date	2012.07.31.07.41.39;	author jbeulich;	state Exp;
branches;
next	1.497;

1.497
date	2012.07.16.12.58.27;	author hjl;	state Exp;
branches
	1.497.2.1;
next	1.496;

1.496
date	2012.06.22.16.42.01;	author roland;	state Exp;
branches;
next	1.495;

1.495
date	2012.06.13.21.41.06;	author hjl;	state Exp;
branches;
next	1.494;

1.494
date	2012.05.12.12.34.33;	author hjl;	state Exp;
branches;
next	1.493;

1.493
date	2012.05.11.00.50.43;	author hjl;	state Exp;
branches;
next	1.492;

1.492
date	2012.05.10.20.46.31;	author hjl;	state Exp;
branches;
next	1.491;

1.491
date	2012.05.10.03.48.33;	author hjl;	state Exp;
branches;
next	1.490;

1.490
date	2012.05.10.03.25.15;	author hjl;	state Exp;
branches;
next	1.489;

1.489
date	2012.05.04.19.18.02;	author hjl;	state Exp;
branches;
next	1.488;

1.488
date	2012.05.04.19.11.04;	author hjl;	state Exp;
branches;
next	1.487;

1.487
date	2012.05.04.18.06.38;	author hjl;	state Exp;
branches;
next	1.486;

1.486
date	2012.05.04.17.55.38;	author hjl;	state Exp;
branches;
next	1.485;

1.485
date	2012.03.13.16.59.55;	author roland;	state Exp;
branches;
next	1.484;

1.484
date	2012.02.21.18.09.46;	author hjl;	state Exp;
branches;
next	1.483;

1.483
date	2012.02.08.18.20.36;	author hjl;	state Exp;
branches;
next	1.482;

1.482
date	2012.01.23.21.42.04;	author roland;	state Exp;
branches;
next	1.481;

1.481
date	2012.01.20.20.53.49;	author hjl;	state Exp;
branches;
next	1.480;

1.480
date	2012.01.13.22.19.31;	author hjl;	state Exp;
branches;
next	1.479;

1.479
date	2012.01.06.16.23.39;	author gingold;	state Exp;
branches;
next	1.478;

1.478
date	2011.08.01.23.04.22;	author hjl;	state Exp;
branches;
next	1.477;

1.477
date	2011.07.22.20.22.35;	author hjl;	state Exp;
branches;
next	1.476;

1.476
date	2011.06.29.11.12.25;	author gingold;	state Exp;
branches;
next	1.475;

1.475
date	2011.06.10.21.27.37;	author hjl;	state Exp;
branches;
next	1.474;

1.474
date	2011.05.12.22.29.06;	author qneill;	state Exp;
branches;
next	1.473;

1.473
date	2011.05.10.22.02.25;	author qneill;	state Exp;
branches;
next	1.472;

1.472
date	2011.04.12.13.57.50;	author hjl;	state Exp;
branches;
next	1.471;

1.471
date	2011.04.11.18.45.12;	author ktietz;	state Exp;
branches;
next	1.470;

1.470
date	2011.04.11.08.27.46;	author nickc;	state Exp;
branches;
next	1.469;

1.469
date	2011.03.29.12.40.50;	author hjl;	state Exp;
branches;
next	1.468;

1.468
date	2011.03.28.22.47.59;	author hjl;	state Exp;
branches;
next	1.467;

1.467
date	2011.03.28.11.18.23;	author nickc;	state Exp;
branches;
next	1.466;

1.466
date	2011.03.05.04.31.40;	author hjl;	state Exp;
branches;
next	1.465;

1.465
date	2011.03.05.02.16.36;	author hjl;	state Exp;
branches;
next	1.464;

1.464
date	2011.02.25.19.19.45;	author hjl;	state Exp;
branches;
next	1.463;

1.463
date	2011.02.08.20.21.25;	author hjl;	state Exp;
branches;
next	1.462;

1.462
date	2011.02.08.18.12.23;	author hjl;	state Exp;
branches;
next	1.461;

1.461
date	2011.01.26.10.16.12;	author ktietz;	state Exp;
branches;
next	1.460;

1.460
date	2011.01.17.18.40.29;	author qneill;	state Exp;
branches;
next	1.459;

1.459
date	2011.01.16.17.06.12;	author hjl;	state Exp;
branches;
next	1.458;

1.458
date	2011.01.15.15.48.01;	author hjl;	state Exp;
branches;
next	1.457;

1.457
date	2011.01.14.23.07.08;	author hjl;	state Exp;
branches;
next	1.456;

1.456
date	2011.01.10.10.10.06;	author nickc;	state Exp;
branches;
next	1.455;

1.455
date	2011.01.07.17.44.28;	author qneill;	state Exp;
branches;
next	1.454;

1.454
date	2011.01.05.00.16.51;	author hjl;	state Exp;
branches;
next	1.453;

1.453
date	2010.12.31.00.33.34;	author hjl;	state Exp;
branches;
next	1.452;

1.452
date	2010.10.14.18.45.08;	author hjl;	state Exp;
branches
	1.452.2.1;
next	1.451;

1.451
date	2010.10.14.13.31.12;	author hjl;	state Exp;
branches;
next	1.450;

1.450
date	2010.09.16.23.55.10;	author amodra;	state Exp;
branches;
next	1.449;

1.449
date	2010.09.09.21.12.37;	author hjl;	state Exp;
branches;
next	1.448;

1.448
date	2010.09.03.17.38.37;	author hjl;	state Exp;
branches;
next	1.447;

1.447
date	2010.08.19.21.04.36;	author hjl;	state Exp;
branches;
next	1.446;

1.446
date	2010.08.18.19.36.41;	author hjl;	state Exp;
branches;
next	1.445;

1.445
date	2010.08.06.19.47.00;	author hjl;	state Exp;
branches;
next	1.444;

1.444
date	2010.08.06.18.22.48;	author hjl;	state Exp;
branches;
next	1.443;

1.443
date	2010.08.04.20.52.20;	author hjl;	state Exp;
branches;
next	1.442;

1.442
date	2010.07.03.22.15.58;	author hjl;	state Exp;
branches;
next	1.441;

1.441
date	2010.07.01.21.55.00;	author hjl;	state Exp;
branches;
next	1.440;

1.440
date	2010.06.11.15.07.53;	author jbeulich;	state Exp;
branches;
next	1.439;

1.439
date	2010.06.10.16.38.17;	author hjl;	state Exp;
branches;
next	1.438;

1.438
date	2010.06.10.07.10.04;	author jbeulich;	state Exp;
branches;
next	1.437;

1.437
date	2010.06.08.15.42.29;	author spop;	state Exp;
branches;
next	1.436;

1.436
date	2010.06.03.17.00.30;	author spop;	state Exp;
branches;
next	1.435;

1.435
date	2010.04.22.03.10.48;	author hjl;	state Exp;
branches;
next	1.434;

1.434
date	2010.04.22.01.01.34;	author hjl;	state Exp;
branches;
next	1.433;

1.433
date	2010.04.22.00.43.38;	author hjl;	state Exp;
branches;
next	1.432;

1.432
date	2010.04.21.18.09.51;	author hjl;	state Exp;
branches;
next	1.431;

1.431
date	2010.03.22.13.49.50;	author hjl;	state Exp;
branches;
next	1.430;

1.430
date	2010.03.22.03.29.47;	author hjl;	state Exp;
branches;
next	1.429;

1.429
date	2010.03.22.02.20.58;	author hjl;	state Exp;
branches;
next	1.428;

1.428
date	2010.02.25.21.47.27;	author hjl;	state Exp;
branches;
next	1.427;

1.427
date	2010.02.25.17.59.52;	author hjl;	state Exp;
branches;
next	1.426;

1.426
date	2010.02.11.14.02.50;	author hjl;	state Exp;
branches;
next	1.425;

1.425
date	2010.02.11.13.41.18;	author hjl;	state Exp;
branches;
next	1.424;

1.424
date	2010.02.11.05.06.12;	author spop;	state Exp;
branches;
next	1.423;

1.423
date	2010.02.03.20.36.13;	author spop;	state Exp;
branches;
next	1.422;

1.422
date	2010.01.27.14.34.39;	author hjl;	state Exp;
branches;
next	1.421;

1.421
date	2010.01.24.15.44.05;	author hjl;	state Exp;
branches;
next	1.420;

1.420
date	2010.01.15.21.24.12;	author spop;	state Exp;
branches;
next	1.419;

1.419
date	2010.01.06.22.52.46;	author spop;	state Exp;
branches;
next	1.418;

1.418
date	2009.12.19.18.36.27;	author hjl;	state Exp;
branches;
next	1.417;

1.417
date	2009.12.16.20.08.32;	author hjl;	state Exp;
branches;
next	1.416;

1.416
date	2009.12.16.15.43.16;	author hjl;	state Exp;
branches;
next	1.415;

1.415
date	2009.12.16.05.18.11;	author hjl;	state Exp;
branches;
next	1.414;

1.414
date	2009.12.16.04.00.34;	author hjl;	state Exp;
branches;
next	1.413;

1.413
date	2009.12.16.02.10.44;	author hjl;	state Exp;
branches;
next	1.412;

1.412
date	2009.12.15.16.36.59;	author hjl;	state Exp;
branches;
next	1.411;

1.411
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.410;

1.410
date	2009.12.10.02.51.39;	author hjl;	state Exp;
branches;
next	1.409;

1.409
date	2009.11.18.20.28.57;	author spop;	state Exp;
branches;
next	1.408;

1.408
date	2009.11.18.04.04.16;	author spop;	state Exp;
branches;
next	1.407;

1.407
date	2009.11.14.06.04.34;	author hjl;	state Exp;
branches;
next	1.406;

1.406
date	2009.11.14.01.46.28;	author hjl;	state Exp;
branches;
next	1.405;

1.405
date	2009.11.12.18.57.13;	author hjl;	state Exp;
branches;
next	1.404;

1.404
date	2009.11.12.02.21.46;	author hjl;	state Exp;
branches;
next	1.403;

1.403
date	2009.11.05.23.40.03;	author spop;	state Exp;
branches;
next	1.402;

1.402
date	2009.10.29.22.22.58;	author hjl;	state Exp;
branches;
next	1.401;

1.401
date	2009.10.13.16.42.40;	author hjl;	state Exp;
branches;
next	1.400;

1.400
date	2009.10.13.16.23.24;	author hjl;	state Exp;
branches;
next	1.399;

1.399
date	2009.10.01.14.31.43;	author hjl;	state Exp;
branches;
next	1.398;

1.398
date	2009.09.24.16.37.09;	author hjl;	state Exp;
branches;
next	1.397;

1.397
date	2009.09.21.21.50.19;	author hjl;	state Exp;
branches;
next	1.396;

1.396
date	2009.09.15.18.51.53;	author hjl;	state Exp;
branches;
next	1.395;

1.395
date	2009.09.15.17.47.26;	author hjl;	state Exp;
branches;
next	1.394;

1.394
date	2009.09.14.13.57.44;	author hjl;	state Exp;
branches;
next	1.393;

1.393
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.392;

1.392
date	2009.09.09.09.31.16;	author amodra;	state Exp;
branches;
next	1.391;

1.391
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches
	1.391.2.1;
next	1.390;

1.390
date	2009.08.28.21.42.16;	author hjl;	state Exp;
branches;
next	1.389;

1.389
date	2009.08.10.21.32.25;	author jkratoch;	state Exp;
branches;
next	1.388;

1.388
date	2009.07.29.06.22.12;	author amodra;	state Exp;
branches;
next	1.387;

1.387
date	2009.07.25.14.58.54;	author hjl;	state Exp;
branches;
next	1.386;

1.386
date	2009.07.24.15.41.19;	author jbeulich;	state Exp;
branches;
next	1.385;

1.385
date	2009.07.21.17.50.21;	author hjl;	state Exp;
branches;
next	1.384;

1.384
date	2009.07.17.17.54.51;	author hjl;	state Exp;
branches;
next	1.383;

1.383
date	2009.07.17.17.08.34;	author hjl;	state Exp;
branches;
next	1.382;

1.382
date	2009.07.16.17.37.26;	author hjl;	state Exp;
branches;
next	1.381;

1.381
date	2009.07.06.19.34.29;	author dwarak;	state Exp;
branches;
next	1.380;

1.380
date	2009.07.02.08.09.35;	author gingold;	state Exp;
branches;
next	1.379;

1.379
date	2009.06.29.17.44.37;	author hjl;	state Exp;
branches;
next	1.378;

1.378
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.377;

1.377
date	2009.06.14.01.39.46;	author hjl;	state Exp;
branches;
next	1.376;

1.376
date	2009.06.08.16.06.23;	author davek;	state Exp;
branches;
next	1.375;

1.375
date	2009.05.22.15.57.23;	author dwarak;	state Exp;
branches;
next	1.374;

1.374
date	2009.05.20.13.48.15;	author hjl;	state Exp;
branches;
next	1.373;

1.373
date	2009.04.30.15.47.12;	author nickc;	state Exp;
branches;
next	1.372;

1.372
date	2009.04.20.06.31.49;	author jbeulich;	state Exp;
branches;
next	1.371;

1.371
date	2009.04.15.13.33.02;	author jbeulich;	state Exp;
branches;
next	1.370;

1.370
date	2009.03.26.02.41.12;	author amodra;	state Exp;
branches;
next	1.369;

1.369
date	2009.03.25.19.49.25;	author hjl;	state Exp;
branches;
next	1.368;

1.368
date	2009.02.25.18.59.52;	author hjl;	state Exp;
branches;
next	1.367;

1.367
date	2009.02.23.23.05.21;	author hjl;	state Exp;
branches;
next	1.366;

1.366
date	2009.02.23.22.28.45;	author hjl;	state Exp;
branches;
next	1.365;

1.365
date	2009.02.23.20.41.45;	author hjl;	state Exp;
branches;
next	1.364;

1.364
date	2009.02.04.16.03.29;	author hjl;	state Exp;
branches;
next	1.363;

1.363
date	2009.01.15.12.42.52;	author nickc;	state Exp;
branches;
next	1.362;

1.362
date	2009.01.10.17.25.51;	author hjl;	state Exp;
branches;
next	1.361;

1.361
date	2009.01.09.20.32.18;	author hjl;	state Exp;
branches;
next	1.360;

1.360
date	2009.01.06.01.03.26;	author hjl;	state Exp;
branches;
next	1.359;

1.359
date	2008.12.23.15.14.14;	author hjl;	state Exp;
branches;
next	1.358;

1.358
date	2008.12.20.18.20.16;	author hjl;	state Exp;
branches;
next	1.357;

1.357
date	2008.12.20.17.40.50;	author hjl;	state Exp;
branches;
next	1.356;

1.356
date	2008.12.08.17.59.00;	author hjl;	state Exp;
branches;
next	1.355;

1.355
date	2008.11.29.09.35.52;	author ktietz;	state Exp;
branches;
next	1.354;

1.354
date	2008.10.12.12.37.09;	author hjl;	state Exp;
branches;
next	1.353;

1.353
date	2008.10.09.17.31.43;	author ebotcazou;	state Exp;
branches;
next	1.352;

1.352
date	2008.09.03.15.44.33;	author nickc;	state Exp;
branches
	1.352.2.1;
next	1.351;

1.351
date	2008.09.03.14.02.29;	author nickc;	state Exp;
branches;
next	1.350;

1.350
date	2008.08.28.09.42.11;	author jbeulich;	state Exp;
branches;
next	1.349;

1.349
date	2008.08.27.16.24.32;	author jbeulich;	state Exp;
branches;
next	1.348;

1.348
date	2008.08.20.18.38.39;	author hjl;	state Exp;
branches;
next	1.347;

1.347
date	2008.08.18.18.21.15;	author hjl;	state Exp;
branches;
next	1.346;

1.346
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.345;

1.345
date	2008.07.28.06.48.00;	author amodra;	state Exp;
branches;
next	1.344;

1.344
date	2008.06.03.17.31.52;	author hjl;	state Exp;
branches;
next	1.343;

1.343
date	2008.05.23.13.55.36;	author hjl;	state Exp;
branches;
next	1.342;

1.342
date	2008.05.02.16.53.39;	author hjl;	state Exp;
branches;
next	1.341;

1.341
date	2008.04.22.22.27.13;	author hjl;	state Exp;
branches;
next	1.340;

1.340
date	2008.04.18.18.22.37;	author hjl;	state Exp;
branches;
next	1.339;

1.339
date	2008.04.18.13.10.32;	author hjl;	state Exp;
branches;
next	1.338;

1.338
date	2008.04.10.17.53.40;	author hjl;	state Exp;
branches;
next	1.337;

1.337
date	2008.04.07.13.07.15;	author hjl;	state Exp;
branches;
next	1.336;

1.336
date	2008.04.04.16.34.23;	author hjl;	state Exp;
branches;
next	1.335;

1.335
date	2008.04.03.14.03.18;	author hjl;	state Exp;
branches;
next	1.334;

1.334
date	2008.02.18.08.44.38;	author jbeulich;	state Exp;
branches;
next	1.333;

1.333
date	2008.02.17.00.26.19;	author hjl;	state Exp;
branches;
next	1.332;

1.332
date	2008.02.16.16.16.48;	author hjl;	state Exp;
branches;
next	1.331;

1.331
date	2008.02.14.22.54.02;	author hjl;	state Exp;
branches;
next	1.330;

1.330
date	2008.02.13.13.41.25;	author jbeulich;	state Exp;
branches;
next	1.329;

1.329
date	2008.02.13.13.29.30;	author jbeulich;	state Exp;
branches;
next	1.328;

1.328
date	2008.02.13.10.14.38;	author jbeulich;	state Exp;
branches;
next	1.327;

1.327
date	2008.02.12.05.35.36;	author hjl;	state Exp;
branches;
next	1.326;

1.326
date	2008.02.07.08.40.29;	author amodra;	state Exp;
branches;
next	1.325;

1.325
date	2008.01.23.19.05.11;	author hjl;	state Exp;
branches;
next	1.324;

1.324
date	2008.01.23.14.13.08;	author hjl;	state Exp;
branches;
next	1.323;

1.323
date	2008.01.22.19.57.29;	author hjl;	state Exp;
branches;
next	1.322;

1.322
date	2008.01.22.19.16.43;	author hjl;	state Exp;
branches;
next	1.321;

1.321
date	2008.01.15.18.50.43;	author hjl;	state Exp;
branches;
next	1.320;

1.320
date	2008.01.15.01.37.55;	author hjl;	state Exp;
branches;
next	1.319;

1.319
date	2008.01.12.16.05.41;	author hjl;	state Exp;
branches;
next	1.318;

1.318
date	2008.01.10.21.59.46;	author hjl;	state Exp;
branches;
next	1.317;

1.317
date	2008.01.10.20.53.27;	author hjl;	state Exp;
branches;
next	1.316;

1.316
date	2008.01.09.16.55.14;	author hjl;	state Exp;
branches;
next	1.315;

1.315
date	2008.01.08.19.51.24;	author hjl;	state Exp;
branches;
next	1.314;

1.314
date	2008.01.05.17.07.24;	author hjl;	state Exp;
branches;
next	1.313;

1.313
date	2008.01.04.01.27.01;	author hjl;	state Exp;
branches;
next	1.312;

1.312
date	2008.01.04.01.05.43;	author hjl;	state Exp;
branches;
next	1.311;

1.311
date	2008.01.03.20.19.29;	author jakub;	state Exp;
branches;
next	1.310;

1.310
date	2008.01.03.20.09.38;	author hjl;	state Exp;
branches;
next	1.309;

1.309
date	2008.01.02.23.55.45;	author hjl;	state Exp;
branches;
next	1.308;

1.308
date	2008.01.02.21.43.33;	author hjl;	state Exp;
branches;
next	1.307;

1.307
date	2007.12.29.14.15.20;	author hjl;	state Exp;
branches;
next	1.306;

1.306
date	2007.12.24.06.10.17;	author hjl;	state Exp;
branches;
next	1.305;

1.305
date	2007.12.24.05.27.38;	author hjl;	state Exp;
branches;
next	1.304;

1.304
date	2007.12.17.19.41.57;	author hjl;	state Exp;
branches;
next	1.303;

1.303
date	2007.12.17.18.53.06;	author hjl;	state Exp;
branches;
next	1.302;

1.302
date	2007.11.09.13.53.13;	author hjl;	state Exp;
branches;
next	1.301;

1.301
date	2007.11.01.19.06.54;	author hjl;	state Exp;
branches;
next	1.300;

1.300
date	2007.11.01.16.27.06;	author hjl;	state Exp;
branches;
next	1.299;

1.299
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.298;

1.298
date	2007.10.12.22.26.55;	author hjl;	state Exp;
branches;
next	1.297;

1.297
date	2007.10.12.21.40.38;	author hjl;	state Exp;
branches;
next	1.296;

1.296
date	2007.10.05.17.50.47;	author hjl;	state Exp;
branches;
next	1.295;

1.295
date	2007.10.04.18.29.29;	author hjl;	state Exp;
branches;
next	1.294;

1.294
date	2007.09.30.21.27.16;	author hjl;	state Exp;
branches;
next	1.293;

1.293
date	2007.09.26.13.40.57;	author jbeulich;	state Exp;
branches;
next	1.292;

1.292
date	2007.09.26.06.55.57;	author jbeulich;	state Exp;
branches;
next	1.291;

1.291
date	2007.09.26.04.42.47;	author hjl;	state Exp;
branches;
next	1.290;

1.290
date	2007.09.20.17.38.37;	author hjl;	state Exp;
branches;
next	1.289;

1.289
date	2007.09.18.00.56.54;	author hjl;	state Exp;
branches;
next	1.288;

1.288
date	2007.09.17.14.46.12;	author hjl;	state Exp;
branches;
next	1.287;

1.287
date	2007.09.15.22.06.41;	author hjl;	state Exp;
branches;
next	1.286;

1.286
date	2007.09.15.01.57.57;	author hjl;	state Exp;
branches;
next	1.285;

1.285
date	2007.09.14.20.05.28;	author hjl;	state Exp;
branches;
next	1.284;

1.284
date	2007.09.14.19.57.47;	author hjl;	state Exp;
branches;
next	1.283;

1.283
date	2007.09.14.18.21.08;	author meissner;	state Exp;
branches;
next	1.282;

1.282
date	2007.09.12.07.31.38;	author jbeulich;	state Exp;
branches;
next	1.281;

1.281
date	2007.09.09.16.38.39;	author hjl;	state Exp;
branches;
next	1.280;

1.280
date	2007.09.09.02.49.25;	author hjl;	state Exp;
branches;
next	1.279;

1.279
date	2007.09.09.01.22.57;	author hjl;	state Exp;
branches;
next	1.278;

1.278
date	2007.09.06.12.28.11;	author hjl;	state Exp;
branches;
next	1.277;

1.277
date	2007.09.05.13.36.14;	author hjl;	state Exp;
branches;
next	1.276;

1.276
date	2007.09.04.14.44.35;	author hjl;	state Exp;
branches;
next	1.275;

1.275
date	2007.08.28.17.36.34;	author hjl;	state Exp;
branches;
next	1.274;

1.274
date	2007.08.24.04.18.37;	author amodra;	state Exp;
branches;
next	1.273;

1.273
date	2007.08.17.14.12.43;	author amodra;	state Exp;
branches;
next	1.272;

1.272
date	2007.08.09.13.50.51;	author hjl;	state Exp;
branches;
next	1.271;

1.271
date	2007.07.29.18.27.59;	author hjl;	state Exp;
branches
	1.271.2.1;
next	1.270;

1.270
date	2007.07.23.20.03.23;	author hjl;	state Exp;
branches;
next	1.269;

1.269
date	2007.07.04.15.32.45;	author hjl;	state Exp;
branches;
next	1.268;

1.268
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.267;

1.267
date	2007.06.25.21.20.20;	author hjl;	state Exp;
branches;
next	1.266;

1.266
date	2007.06.22.14.15.51;	author hjl;	state Exp;
branches;
next	1.265;

1.265
date	2007.05.04.00.02.47;	author amodra;	state Exp;
branches;
next	1.264;

1.264
date	2007.05.03.21.07.15;	author hjl;	state Exp;
branches;
next	1.263;

1.263
date	2007.05.01.12.59.23;	author hjl;	state Exp;
branches;
next	1.262;

1.262
date	2007.04.30.13.42.40;	author hjl;	state Exp;
branches;
next	1.261;

1.261
date	2007.04.21.06.54.56;	author amodra;	state Exp;
branches;
next	1.260;

1.260
date	2007.04.18.16.15.55;	author hjl;	state Exp;
branches;
next	1.259;

1.259
date	2007.04.18.16.13.13;	author hjl;	state Exp;
branches;
next	1.258;

1.258
date	2007.03.30.16.28.33;	author hjl;	state Exp;
branches;
next	1.257;

1.257
date	2007.03.29.04.27.54;	author hjl;	state Exp;
branches;
next	1.256;

1.256
date	2007.03.23.16.17.21;	author hjl;	state Exp;
branches;
next	1.255;

1.255
date	2007.03.22.00.27.14;	author hjl;	state Exp;
branches;
next	1.254;

1.254
date	2007.03.21.21.23.43;	author hjl;	state Exp;
branches;
next	1.253;

1.253
date	2007.03.21.20.45.13;	author hjl;	state Exp;
branches;
next	1.252;

1.252
date	2007.03.21.15.37.20;	author hjl;	state Exp;
branches;
next	1.251;

1.251
date	2007.03.15.17.30.31;	author hjl;	state Exp;
branches;
next	1.250;

1.250
date	2007.03.15.14.31.24;	author hjl;	state Exp;
branches;
next	1.249;

1.249
date	2007.03.12.21.36.23;	author hjl;	state Exp;
branches;
next	1.248;

1.248
date	2007.02.13.23.23.54;	author amodra;	state Exp;
branches;
next	1.247;

1.247
date	2007.01.28.16.14.33;	author hjl;	state Exp;
branches;
next	1.246;

1.246
date	2007.01.13.16.48.00;	author hjl;	state Exp;
branches;
next	1.245;

1.245
date	2007.01.05.14.55.44;	author hjl;	state Exp;
branches;
next	1.244;

1.244
date	2007.01.04.18.03.31;	author hjl;	state Exp;
branches;
next	1.243;

1.243
date	2007.01.04.05.35.52;	author hjl;	state Exp;
branches;
next	1.242;

1.242
date	2007.01.03.22.54.45;	author hjl;	state Exp;
branches;
next	1.241;

1.241
date	2007.01.03.22.48.52;	author hjl;	state Exp;
branches;
next	1.240;

1.240
date	2007.01.03.22.36.19;	author hjl;	state Exp;
branches;
next	1.239;

1.239
date	2006.12.30.18.37.29;	author hjl;	state Exp;
branches;
next	1.238;

1.238
date	2006.12.29.21.48.48;	author hjl;	state Exp;
branches;
next	1.237;

1.237
date	2006.12.29.06.02.04;	author hjl;	state Exp;
branches;
next	1.236;

1.236
date	2006.12.28.07.09.16;	author hjl;	state Exp;
branches;
next	1.235;

1.235
date	2006.12.27.18.34.08;	author hjl;	state Exp;
branches;
next	1.234;

1.234
date	2006.12.26.23.42.11;	author hjl;	state Exp;
branches;
next	1.233;

1.233
date	2006.12.15.19.43.59;	author hjl;	state Exp;
branches;
next	1.232;

1.232
date	2006.12.15.14.09.22;	author hjl;	state Exp;
branches;
next	1.231;

1.231
date	2006.12.14.13.28.24;	author hjl;	state Exp;
branches;
next	1.230;

1.230
date	2006.12.13.19.39.12;	author hjl;	state Exp;
branches;
next	1.229;

1.229
date	2006.12.13.18.26.30;	author hjl;	state Exp;
branches;
next	1.228;

1.228
date	2006.12.13.18.00.00;	author hjl;	state Exp;
branches;
next	1.227;

1.227
date	2006.11.08.19.56.02;	author hjl;	state Exp;
branches;
next	1.226;

1.226
date	2006.10.20.00.32.43;	author vapier;	state Exp;
branches;
next	1.225;

1.225
date	2006.09.28.14.06.36;	author hjl;	state Exp;
branches;
next	1.224;

1.224
date	2006.09.23.23.10.13;	author hjl;	state Exp;
branches;
next	1.223;

1.223
date	2006.09.20.11.35.11;	author nickc;	state Exp;
branches;
next	1.222;

1.222
date	2006.08.02.16.25.14;	author nickc;	state Exp;
branches;
next	1.221;

1.221
date	2006.08.01.17.54.28;	author hjl;	state Exp;
branches;
next	1.220;

1.220
date	2006.07.15.16.32.48;	author hjl;	state Exp;
branches;
next	1.219;

1.219
date	2006.07.13.22.25.44;	author meissner;	state Exp;
branches;
next	1.218;

1.218
date	2006.06.23.21.47.36;	author hjl;	state Exp;
branches;
next	1.217;

1.217
date	2006.06.16.15.46.11;	author hjl;	state Exp;
branches;
next	1.216;

1.216
date	2006.06.12.18.55.38;	author hjl;	state Exp;
branches;
next	1.215;

1.215
date	2006.05.19.11.26.11;	author ths;	state Exp;
branches;
next	1.214;

1.214
date	2006.05.02.14.24.03;	author hjl;	state Exp;
branches;
next	1.213;

1.213
date	2006.05.02.13.34.25;	author hjl;	state Exp;
branches;
next	1.212;

1.212
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.211;

1.211
date	2006.04.18.17.52.37;	author hjl;	state Exp;
branches;
next	1.210;

1.210
date	2006.04.18.10.11.09;	author amodra;	state Exp;
branches;
next	1.209;

1.209
date	2006.04.07.06.40.57;	author amodra;	state Exp;
branches;
next	1.208;

1.208
date	2006.03.23.08.23.09;	author aj;	state Exp;
branches;
next	1.207;

1.207
date	2006.02.27.15.35.37;	author hjl;	state Exp;
branches
	1.207.2.1;
next	1.206;

1.206
date	2006.01.18.21.07.49;	author aoliva;	state Exp;
branches;
next	1.205;

1.205
date	2005.12.14.08.57.05;	author jbeulich;	state Exp;
branches;
next	1.204;

1.204
date	2005.12.06.12.40.57;	author hjl;	state Exp;
branches;
next	1.203;

1.203
date	2005.11.16.03.44.10;	author amodra;	state Exp;
branches;
next	1.202;

1.202
date	2005.11.10.16.06.27;	author jbeulich;	state Exp;
branches;
next	1.201;

1.201
date	2005.11.07.06.01.18;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2005.10.26.12.29.43;	author jbeulich;	state Exp;
branches;
next	1.199;

1.199
date	2005.09.28.15.31.21;	author jbeulich;	state Exp;
branches;
next	1.198;

1.198
date	2005.09.28.14.44.21;	author jbeulich;	state Exp;
branches;
next	1.197;

1.197
date	2005.09.20.18.24.47;	author rth;	state Exp;
branches;
next	1.196;

1.196
date	2005.09.14.06.33.25;	author jbeulich;	state Exp;
branches;
next	1.195;

1.195
date	2005.08.26.15.51.13;	author jbeulich;	state Exp;
branches;
next	1.194;

1.194
date	2005.08.22.12.37.35;	author jbeulich;	state Exp;
branches;
next	1.193;

1.193
date	2005.08.11.01.25.25;	author amodra;	state Exp;
branches;
next	1.192;

1.192
date	2005.07.27.14.08.08;	author hjl;	state Exp;
branches;
next	1.191;

1.191
date	2005.07.26.15.34.10;	author jbeulich;	state Exp;
branches;
next	1.190;

1.190
date	2005.07.25.15.41.07;	author hjl;	state Exp;
branches;
next	1.189;

1.189
date	2005.07.18.15.24.40;	author jbeulich;	state Exp;
branches;
next	1.188;

1.188
date	2005.07.18.06.27.23;	author jbeulich;	state Exp;
branches;
next	1.187;

1.187
date	2005.07.18.06.13.00;	author jbeulich;	state Exp;
branches;
next	1.186;

1.186
date	2005.07.10.16.54.00;	author hjl;	state Exp;
branches;
next	1.185;

1.185
date	2005.07.06.19.10.59;	author hjl;	state Exp;
branches;
next	1.184;

1.184
date	2005.07.05.07.16.49;	author jbeulich;	state Exp;
branches;
next	1.183;

1.183
date	2005.06.20.23.18.38;	author hjl;	state Exp;
branches;
next	1.182;

1.182
date	2005.06.17.08.03.55;	author jbeulich;	state Exp;
branches;
next	1.181;

1.181
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.180;

1.180
date	2005.05.09.15.41.46;	author jbeulich;	state Exp;
branches;
next	1.179;

1.179
date	2005.05.09.06.49.01;	author jbeulich;	state Exp;
branches;
next	1.178;

1.178
date	2005.05.09.06.44.51;	author jbeulich;	state Exp;
branches;
next	1.177;

1.177
date	2005.05.09.06.38.45;	author jbeulich;	state Exp;
branches;
next	1.176;

1.176
date	2005.05.05.09.12.56;	author nickc;	state Exp;
branches;
next	1.175;

1.175
date	2005.04.29.00.22.29;	author bje;	state Exp;
branches;
next	1.174;

1.174
date	2005.04.18.20.59.18;	author kettenis;	state Exp;
branches;
next	1.173;

1.173
date	2005.04.12.17.12.33;	author kettenis;	state Exp;
branches;
next	1.172;

1.172
date	2005.04.07.00.53.19;	author hjl;	state Exp;
branches;
next	1.171;

1.171
date	2005.04.01.15.58.31;	author jbeulich;	state Exp;
branches;
next	1.170;

1.170
date	2005.04.01.07.50.23;	author jbeulich;	state Exp;
branches;
next	1.169;

1.169
date	2005.04.01.07.46.06;	author jbeulich;	state Exp;
branches;
next	1.168;

1.168
date	2005.03.17.12.05.22;	author jbeulich;	state Exp;
branches;
next	1.167;

1.167
date	2005.03.03.11.47.50;	author amodra;	state Exp;
branches
	1.167.2.1;
next	1.166;

1.166
date	2005.03.02.08.01.24;	author jbeulich;	state Exp;
branches;
next	1.165;

1.165
date	2005.03.02.07.55.00;	author jbeulich;	state Exp;
branches;
next	1.164;

1.164
date	2005.01.31.23.18.28;	author bje;	state Exp;
branches;
next	1.163;

1.163
date	2005.01.14.22.10.55;	author hjl;	state Exp;
branches;
next	1.162;

1.162
date	2004.11.25.08.42.50;	author jbeulich;	state Exp;
branches;
next	1.161;

1.161
date	2004.11.23.07.55.11;	author jbeulich;	state Exp;
branches;
next	1.160;

1.160
date	2004.11.08.08.12.45;	author nickc;	state Exp;
branches;
next	1.159;

1.159
date	2004.11.04.09.16.03;	author jbeulich;	state Exp;
branches;
next	1.158;

1.158
date	2004.10.18.12.32.13;	author amodra;	state Exp;
branches;
next	1.157;

1.157
date	2004.10.08.13.55.04;	author drow;	state Exp;
branches;
next	1.156;

1.156
date	2004.07.21.18.18.02;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2004.07.21.16.09.42;	author nickc;	state Exp;
branches;
next	1.154;

1.154
date	2004.07.13.17.31.13;	author nickc;	state Exp;
branches;
next	1.153;

1.153
date	2004.07.03.16.07.49;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2004.06.18.14.09.40;	author nickc;	state Exp;
branches;
next	1.151;

1.151
date	2004.04.20.12.17.14;	author nickc;	state Exp;
branches;
next	1.150;

1.150
date	2004.03.12.10.14.29;	author mludvig;	state Exp;
branches;
next	1.149;

1.149
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches
	1.149.6.1;
next	1.148;

1.148
date	2003.11.21.14.38.06;	author kazu;	state Exp;
branches;
next	1.147;

1.147
date	2003.11.11.09.30.48;	author aj;	state Exp;
branches;
next	1.146;

1.146
date	2003.08.14.08.05.44;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2003.08.04.12.03.49;	author amodra;	state Exp;
branches;
next	1.144;

1.144
date	2003.07.04.10.46.35;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	2003.06.26.17.50.41;	author hjl;	state Exp;
branches;
next	1.142;

1.142
date	2003.06.23.20.15.32;	author hjl;	state Exp;
branches;
next	1.141;

1.141
date	2003.06.10.06.46.33;	author hjl;	state Exp;
branches;
next	1.140;

1.140
date	2003.05.27.16.52.47;	author rth;	state Exp;
branches;
next	1.139;

1.139
date	2003.05.20.07.58.06;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2003.01.29.10.05.52;	author nickc;	state Exp;
branches;
next	1.137;

1.137
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2002.11.28.14.15.51;	author jakub;	state Exp;
branches;
next	1.134;

1.134
date	2002.10.11.00.25.32;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2002.09.27.19.29.16;	author jakub;	state Exp;
branches;
next	1.132;

1.132
date	2002.09.24.01.46.42;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2002.09.21.10.39.16;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2002.09.19.19.01.12;	author jakub;	state Exp;
branches;
next	1.129;

1.129
date	2002.09.17.02.24.37;	author obrien;	state Exp;
branches;
next	1.128;

1.128
date	2002.09.11.09.51.58;	author jakub;	state Exp;
branches;
next	1.127;

1.127
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2002.08.10.14.49.48;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2002.08.09.00.09.51;	author jakub;	state Exp;
branches;
next	1.124;

1.124
date	2002.07.16.22.31.19;	author hubicka;	state Exp;
branches;
next	1.123;

1.123
date	2002.07.12.03.47.36;	author amodra;	state Exp;
branches
	1.123.2.1;
next	1.122;

1.122
date	2002.07.09.09.46.18;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2002.07.08.10.03.10;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2002.05.23.13.12.48;	author jakub;	state Exp;
branches;
next	1.119;

1.119
date	2002.05.09.06.35.22;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2002.05.01.00.53.55;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2002.04.28.12.19.46;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2002.04.24.14.56.07;	author schwab;	state Exp;
branches;
next	1.115;

1.115
date	2002.04.10.13.00.02;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2002.03.27.16.22.04;	author schwab;	state Exp;
branches;
next	1.113;

1.113
date	2002.03.09.05.36.51;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2002.03.06.04.59.36;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2002.02.13.11.19.07;	author schwab;	state Exp;
branches;
next	1.110;

1.110
date	2002.02.13.11.17.48;	author schwab;	state Exp;
branches;
next	1.109;

1.109
date	2002.02.11.12.00.54;	author hubicka;	state Exp;
branches;
next	1.108;

1.108
date	2002.01.29.17.07.57;	author drow;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2001.11.15.21.28.55;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2001.11.15.13.19.46;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2001.10.04.18.01.46;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2001.09.19.05.33.24;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2001.09.09.14.01.17;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2001.08.01.02.27.11;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2001.07.23.13.03.39;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2001.07.17.09.57.52;	author mrg;	state Exp;
branches;
next	1.99;

1.99
date	2001.06.21.06.12.10;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2001.06.10.14.07.11;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2001.06.06.10.23.39;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2001.05.24.23.52.22;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2001.05.16.01.08.21;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2001.05.03.01.08.44;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2001.03.30.00.06.10;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2001.03.25.05.57.09;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2001.03.19.11.28.20;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2001.03.13.04.37.12;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2001.03.07.02.52.26;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2001.02.28.12.49.40;	author aj;	state Exp;
branches;
next	1.86;

1.86
date	2001.02.20.09.48.43;	author aj;	state Exp;
branches;
next	1.85;

1.85
date	2001.02.13.12.44.19;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2001.02.12.16.47.15;	author hubicka;	state Exp;
branches;
next	1.83;

1.83
date	2001.01.17.23.41.35;	author kazu;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches;
next	1.81;

1.81
date	2001.01.13.23.37.57;	author hubicka;	state Exp;
branches;
next	1.80;

1.80
date	2001.01.13.09.05.55;	author hubicka;	state Exp;
branches;
next	1.79;

1.79
date	2001.01.12.03.34.48;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2001.01.08.09.37.43;	author aj;	state Exp;
branches;
next	1.77;

1.77
date	2001.01.06.12.36.03;	author hubicka;	state Exp;
branches;
next	1.76;

1.76
date	2001.01.05.12.30.11;	author hubicka;	state Exp;
branches;
next	1.75;

1.75
date	2001.01.04.21.27.56;	author hubicka;	state Exp;
branches;
next	1.74;

1.74
date	2001.01.03.16.27.41;	author hubicka;	state Exp;
branches;
next	1.73;

1.73
date	2000.12.22.20.53.35;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2000.12.20.13.24.12;	author hubicka;	state Exp;
branches;
next	1.71;

1.71
date	2000.12.16.05.45.08;	author dnovillo;	state Exp;
branches;
next	1.70;

1.70
date	2000.12.11.14.01.46;	author hubicka;	state Exp;
branches;
next	1.69;

1.69
date	2000.12.06.02.40.55;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.67;

1.67
date	2000.12.01.03.08.32;	author dnovillo;	state Exp;
branches;
next	1.66;

1.66
date	2000.11.17.18.15.53;	author rth;	state Exp;
branches;
next	1.65;

1.65
date	2000.11.17.09.28.04;	author rth;	state Exp;
branches;
next	1.64;

1.64
date	2000.11.14.20.57.30;	author kazu;	state Exp;
branches;
next	1.63;

1.63
date	2000.10.25.11.42.51;	author dnovillo;	state Exp;
branches;
next	1.62;

1.62
date	2000.10.25.01.39.11;	author dnovillo;	state Exp;
branches;
next	1.61;

1.61
date	2000.10.15.06.17.36;	author dnovillo;	state Exp;
branches;
next	1.60;

1.60
date	2000.10.05.01.49.36;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2000.08.14.21.12.47;	author dnovillo;	state Exp;
branches;
next	1.58;

1.58
date	2000.08.04.18.43.45;	author kazu;	state Exp;
branches;
next	1.57;

1.57
date	2000.06.25.01.33.31;	author dj;	state Exp;
branches;
next	1.56;

1.56
date	2000.06.22.10.49.13;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2000.06.21.02.18.17;	author dj;	state Exp;
branches;
next	1.54;

1.54
date	2000.06.19.01.22.40;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2000.06.09.00.00.02;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2000.06.03.13.06.33;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2000.05.23.04.48.21;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2000.05.22.11.38.43;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2000.05.13.12.49.55;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2000.05.13.09.26.22;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2000.04.25.22.55.19;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2000.04.25.08.55.01;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2000.04.18.17.46.31;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2000.04.17.03.18.36;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2000.04.10.12.36.06;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2000.04.03.11.19.51;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2000.03.26.14.13.02;	author amodra;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2000.02.26.04.00.13;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2000.02.25.11.41.12;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.24.15.26.57;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.24.12.40.44;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2000.02.24.08.18.20;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2000.02.24.00.43.29;	author rth;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.21.12.01.26;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2000.01.26.22.48.31;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.15.12.06.02;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	99.12.27.16.10.30;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	99.11.16.12.27.25;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	99.10.12.11.07.34;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	99.09.19.23.03.56;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	99.09.13.06.45.15;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	99.09.13.03.44.49;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	99.09.12.05.09.50;	author ian;	state Exp;
branches;
next	1.24;

1.24
date	99.09.12.05.06.09;	author ian;	state Exp;
branches;
next	1.23;

1.23
date	99.09.12.03.50.42;	author ian;	state Exp;
branches;
next	1.22;

1.22
date	99.09.12.03.18.54;	author ian;	state Exp;
branches;
next	1.21;

1.21
date	99.09.12.02.27.31;	author ian;	state Exp;
branches;
next	1.20;

1.20
date	99.09.12.02.12.38;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	99.08.30.13.12.54;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	99.08.29.23.44.27;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	99.08.20.11.59.17;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	99.08.11.14.10.07;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	99.08.04.10.07.40;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	99.08.03.15.29.04;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	99.08.03.14.30.05;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	99.08.03.05.47.26;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	99.07.28.23.19.26;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	99.07.16.11.09.15;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	99.07.11.20.20.04;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.06.11.21.07.03;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.10.21.47.35;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.03.00.29.28;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.24.18.25.27;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	99.05.17.03.21.50;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	99.05.13.06.00.13;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.05.06.23.16.36;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.497.2.1
date	2012.09.18.12.21.51;	author gingold;	state Exp;
branches;
next	1.497.2.2;

1.497.2.2
date	2012.11.09.14.41.30;	author gingold;	state Exp;
branches;
next	;

1.452.2.1
date	2011.03.23.16.00.17;	author gingold;	state Exp;
branches;
next	1.452.2.2;

1.452.2.2
date	2011.04.01.12.04.26;	author gingold;	state Exp;
branches;
next	;

1.391.2.1
date	2009.09.09.09.31.33;	author amodra;	state Exp;
branches;
next	1.391.2.2;

1.391.2.2
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.352.2.1
date	2008.10.09.17.32.29;	author ebotcazou;	state Exp;
branches;
next	;

1.271.2.1
date	2007.08.13.00.30.22;	author drow;	state Exp;
branches;
next	1.271.2.2;

1.271.2.2
date	2007.08.24.04.27.51;	author amodra;	state Exp;
branches;
next	;

1.207.2.1
date	2006.08.22.15.08.35;	author jsm28;	state Exp;
branches;
next	;

1.167.2.1
date	2005.04.13.13.47.06;	author jbeulich;	state Exp;
branches;
next	;

1.149.6.1
date	2004.03.12.10.41.20;	author mludvig;	state Exp;
branches;
next	;

1.123.2.1
date	2002.09.23.22.14.22;	author drow;	state Exp;
branches;
next	1.123.2.2;

1.123.2.2
date	2002.09.24.01.47.49;	author amodra;	state Exp;
branches;
next	1.123.2.3;

1.123.2.3
date	2002.10.11.00.33.01;	author amodra;	state Exp;
branches;
next	;

1.108.2.1
date	2002.02.13.11.20.35;	author schwab;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2002.02.15.14.21.07;	author hubicka;	state Exp;
branches;
next	1.108.2.3;

1.108.2.3
date	2002.03.27.16.20.41;	author schwab;	state Exp;
branches;
next	1.108.2.4;

1.108.2.4
date	2002.03.28.06.25.03;	author amodra;	state Exp;
branches;
next	1.108.2.5;

1.108.2.5
date	2002.04.10.13.23.48;	author amodra;	state Exp;
branches;
next	1.108.2.6;

1.108.2.6
date	2002.04.24.14.55.31;	author schwab;	state Exp;
branches;
next	1.108.2.7;

1.108.2.7
date	2002.05.09.11.54.10;	author amodra;	state Exp;
branches;
next	;

1.83.2.1
date	2001.02.12.16.45.23;	author hubicka;	state Exp;
branches;
next	1.83.2.2;

1.83.2.2
date	2001.02.20.09.50.48;	author aj;	state Exp;
branches;
next	1.83.2.3;

1.83.2.3
date	2001.02.28.12.51.15;	author aj;	state Exp;
branches;
next	1.83.2.4;

1.83.2.4
date	2001.03.19.11.34.55;	author amodra;	state Exp;
branches;
next	1.83.2.5;

1.83.2.5
date	2001.03.30.03.11.28;	author amodra;	state Exp;
branches;
next	1.83.2.6;

1.83.2.6
date	2001.05.23.03.41.10;	author amodra;	state Exp;
branches;
next	1.83.2.7;

1.83.2.7
date	2001.06.11.10.04.47;	author amodra;	state Exp;
branches;
next	1.83.2.8;

1.83.2.8
date	2001.10.04.18.06.41;	author amodra;	state Exp;
branches;
next	;

1.41.2.1
date	2000.04.04.11.28.47;	author amodra;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2000.05.15.00.12.34;	author amodra;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2000.05.23.05.04.30;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.523
log
@gas/
2013-10-08  Jan Beulich <jbeulich@@suse.com>

	* tc-i386.c (check_word_reg): Remove misplaced "else".
	(check_long_reg): Restore symmetry with check_word_reg.
@
text
@/* tc-i386.c -- Assemble code for the Intel 80386
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
   2012
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Intel 80386 machine specific gas.
   Written by Eliot Dresselhaus (eliot@@mgm.mit.edu).
   x86_64 support by Jan Hubicka (jh@@suse.cz)
   VIA PadLock support by Michal Ludvig (mludvig@@suse.cz)
   Bugs & suggestions are completely welcome.  This is free software.
   Please help us make it better.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"
#include "elf/x86-64.h"
#include "opcodes/i386-init.h"

#ifndef REGISTER_WARNINGS
#define REGISTER_WARNINGS 1
#endif

#ifndef INFER_ADDR_PREFIX
#define INFER_ADDR_PREFIX 1
#endif

#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "i386"
#endif

#ifndef INLINE
#if __GNUC__ >= 2
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

/* Prefixes will be emitted in the order defined below.
   WAIT_PREFIX must be the first prefix since FWAIT is really is an
   instruction, and so must come before any prefixes.
   The preferred prefix order is SEG_PREFIX, ADDR_PREFIX, DATA_PREFIX,
   REP_PREFIX/HLE_PREFIX, LOCK_PREFIX.  */
#define WAIT_PREFIX	0
#define SEG_PREFIX	1
#define ADDR_PREFIX	2
#define DATA_PREFIX	3
#define REP_PREFIX	4
#define HLE_PREFIX	REP_PREFIX
#define BND_PREFIX	REP_PREFIX
#define LOCK_PREFIX	5
#define REX_PREFIX	6       /* must come last.  */
#define MAX_PREFIXES	7	/* max prefixes per opcode */

/* we define the syntax here (modulo base,index,scale syntax) */
#define REGISTER_PREFIX '%'
#define IMMEDIATE_PREFIX '$'
#define ABSOLUTE_PREFIX '*'

/* these are the instruction mnemonic suffixes in AT&T syntax or
   memory operand size in Intel syntax.  */
#define WORD_MNEM_SUFFIX  'w'
#define BYTE_MNEM_SUFFIX  'b'
#define SHORT_MNEM_SUFFIX 's'
#define LONG_MNEM_SUFFIX  'l'
#define QWORD_MNEM_SUFFIX  'q'
#define XMMWORD_MNEM_SUFFIX  'x'
#define YMMWORD_MNEM_SUFFIX 'y'
#define ZMMWORD_MNEM_SUFFIX 'z'
/* Intel Syntax.  Use a non-ascii letter since since it never appears
   in instructions.  */
#define LONG_DOUBLE_MNEM_SUFFIX '\1'

#define END_OF_INSN '\0'

/*
  'templates' is for grouping together 'template' structures for opcodes
  of the same name.  This is only used for storing the insns in the grand
  ole hash table of insns.
  The templates themselves start at START and range up to (but not including)
  END.
  */
typedef struct
{
  const insn_template *start;
  const insn_template *end;
}
templates;

/* 386 operand encoding bytes:  see 386 book for details of this.  */
typedef struct
{
  unsigned int regmem;	/* codes register or memory operand */
  unsigned int reg;	/* codes register operand (or extended opcode) */
  unsigned int mode;	/* how to interpret regmem & reg */
}
modrm_byte;

/* x86-64 extension prefix.  */
typedef int rex_byte;

/* 386 opcode byte to code indirect addressing.  */
typedef struct
{
  unsigned base;
  unsigned index;
  unsigned scale;
}
sib_byte;

/* x86 arch names, types and features */
typedef struct
{
  const char *name;		/* arch name */
  unsigned int len;		/* arch string length */
  enum processor_type type;	/* arch type */
  i386_cpu_flags flags;		/* cpu feature flags */
  unsigned int skip;		/* show_arch should skip this. */
  unsigned int negated;		/* turn off indicated flags.  */
}
arch_entry;

static void update_code_flag (int, int);
static void set_code_flag (int);
static void set_16bit_gcc_code_flag (int);
static void set_intel_syntax (int);
static void set_intel_mnemonic (int);
static void set_allow_index_reg (int);
static void set_check (int);
static void set_cpu_arch (int);
#ifdef TE_PE
static void pe_directive_secrel (int);
#endif
static void signed_cons (int);
static char *output_invalid (int c);
static int i386_finalize_immediate (segT, expressionS *, i386_operand_type,
				    const char *);
static int i386_finalize_displacement (segT, expressionS *, i386_operand_type,
				       const char *);
static int i386_att_operand (char *);
static int i386_intel_operand (char *, int);
static int i386_intel_simplify (expressionS *);
static int i386_intel_parse_name (const char *, expressionS *);
static const reg_entry *parse_register (char *, char **);
static char *parse_insn (char *, char *);
static char *parse_operands (char *, const char *);
static void swap_operands (void);
static void swap_2_operands (int, int);
static void optimize_imm (void);
static void optimize_disp (void);
static const insn_template *match_template (void);
static int check_string (void);
static int process_suffix (void);
static int check_byte_reg (void);
static int check_long_reg (void);
static int check_qword_reg (void);
static int check_word_reg (void);
static int finalize_imm (void);
static int process_operands (void);
static const seg_entry *build_modrm_byte (void);
static void output_insn (void);
static void output_imm (fragS *, offsetT);
static void output_disp (fragS *, offsetT);
#ifndef I386COFF
static void s_bss (int);
#endif
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
static void handle_large_common (int small ATTRIBUTE_UNUSED);
#endif

static const char *default_arch = DEFAULT_ARCH;

/* This struct describes rounding control and SAE in the instruction.  */
struct RC_Operation
{
  enum rc_type
    {
      rne = 0,
      rd,
      ru,
      rz,
      saeonly
    } type;
  int operand;
};

static struct RC_Operation rc_op;

/* The struct describes masking, applied to OPERAND in the instruction.
   MASK is a pointer to the corresponding mask register.  ZEROING tells
   whether merging or zeroing mask is used.  */
struct Mask_Operation
{
  const reg_entry *mask;
  unsigned int zeroing;
  /* The operand where this operation is associated.  */
  int operand;
};

static struct Mask_Operation mask_op;

/* The struct describes broadcasting, applied to OPERAND.  FACTOR is
   broadcast factor.  */
struct Broadcast_Operation
{
  /* Type of broadcast: no broadcast, {1to8}, or {1to16}.  */
  int type;

  /* Index of broadcasted operand.  */
  int operand;
};

static struct Broadcast_Operation broadcast_op;

/* VEX prefix.  */
typedef struct
{
  /* VEX prefix is either 2 byte or 3 byte.  EVEX is 4 byte.  */
  unsigned char bytes[4];
  unsigned int length;
  /* Destination or source register specifier.  */
  const reg_entry *register_specifier;
} vex_prefix;

/* 'md_assemble ()' gathers together information and puts it into a
   i386_insn.  */

union i386_op
  {
    expressionS *disps;
    expressionS *imms;
    const reg_entry *regs;
  };

enum i386_error
  {
    operand_size_mismatch,
    operand_type_mismatch,
    register_type_mismatch,
    number_of_operands_mismatch,
    invalid_instruction_suffix,
    bad_imm4,
    old_gcc_only,
    unsupported_with_intel_mnemonic,
    unsupported_syntax,
    unsupported,
    invalid_vsib_address,
    invalid_vector_register_set,
    unsupported_vector_index_register,
    unsupported_broadcast,
    broadcast_not_on_src_operand,
    broadcast_needed,
    unsupported_masking,
    mask_not_on_destination,
    no_default_mask,
    unsupported_rc_sae,
    rc_sae_operand_not_last_imm,
    invalid_register_operand,
    try_vector_disp8
  };

struct _i386_insn
  {
    /* TM holds the template for the insn were currently assembling.  */
    insn_template tm;

    /* SUFFIX holds the instruction size suffix for byte, word, dword
       or qword, if given.  */
    char suffix;

    /* OPERANDS gives the number of given operands.  */
    unsigned int operands;

    /* REG_OPERANDS, DISP_OPERANDS, MEM_OPERANDS, IMM_OPERANDS give the number
       of given register, displacement, memory operands and immediate
       operands.  */
    unsigned int reg_operands, disp_operands, mem_operands, imm_operands;

    /* TYPES [i] is the type (see above #defines) which tells us how to
       use OP[i] for the corresponding operand.  */
    i386_operand_type types[MAX_OPERANDS];

    /* Displacement expression, immediate expression, or register for each
       operand.  */
    union i386_op op[MAX_OPERANDS];

    /* Flags for operands.  */
    unsigned int flags[MAX_OPERANDS];
#define Operand_PCrel 1

    /* Relocation type for operand */
    enum bfd_reloc_code_real reloc[MAX_OPERANDS];

    /* BASE_REG, INDEX_REG, and LOG2_SCALE_FACTOR are used to encode
       the base index byte below.  */
    const reg_entry *base_reg;
    const reg_entry *index_reg;
    unsigned int log2_scale_factor;

    /* SEG gives the seg_entries of this insn.  They are zero unless
       explicit segment overrides are given.  */
    const seg_entry *seg[2];

    /* PREFIX holds all the given prefix opcodes (usually null).
       PREFIXES is the number of prefix opcodes.  */
    unsigned int prefixes;
    unsigned char prefix[MAX_PREFIXES];

    /* RM and SIB are the modrm byte and the sib byte where the
       addressing modes of this insn are encoded.  */
    modrm_byte rm;
    rex_byte rex;
    rex_byte vrex;
    sib_byte sib;
    vex_prefix vex;

    /* Masking attributes.  */
    struct Mask_Operation *mask;

    /* Rounding control and SAE attributes.  */
    struct RC_Operation *rounding;

    /* Broadcasting attributes.  */
    struct Broadcast_Operation *broadcast;

    /* Compressed disp8*N attribute.  */
    unsigned int memshift;

    /* Swap operand in encoding.  */
    unsigned int swap_operand;

    /* Prefer 8bit or 32bit displacement in encoding.  */
    enum
      {
	disp_encoding_default = 0,
	disp_encoding_8bit,
	disp_encoding_32bit
      } disp_encoding;

    /* REP prefix.  */
    const char *rep_prefix;

    /* HLE prefix.  */
    const char *hle_prefix;

    /* Have BND prefix.  */
    const char *bnd_prefix;

    /* Need VREX to support upper 16 registers.  */
    int need_vrex;

    /* Error message.  */
    enum i386_error error;
  };

typedef struct _i386_insn i386_insn;

/* Link RC type with corresponding string, that'll be looked for in
   asm.  */
struct RC_name
{
  enum rc_type type;
  const char *name;
  unsigned int len;
};

static const struct RC_name RC_NamesTable[] =
{
  {  rne, STRING_COMMA_LEN ("rn-sae") },
  {  rd,  STRING_COMMA_LEN ("rd-sae") },
  {  ru,  STRING_COMMA_LEN ("ru-sae") },
  {  rz,  STRING_COMMA_LEN ("rz-sae") },
  {  saeonly,  STRING_COMMA_LEN ("sae") },
};

/* List of chars besides those in app.c:symbol_chars that can start an
   operand.  Used to prevent the scrubber eating vital white-space.  */
const char extra_symbol_chars[] = "*%-([{"
#ifdef LEX_AT
	"@@"
#endif
#ifdef LEX_QM
	"?"
#endif
	;

#if (defined (TE_I386AIX)				\
     || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))	\
	 && !defined (TE_GNU)				\
	 && !defined (TE_LINUX)				\
	 && !defined (TE_NACL)				\
	 && !defined (TE_NETWARE)			\
	 && !defined (TE_FreeBSD)			\
	 && !defined (TE_DragonFly)			\
	 && !defined (TE_NetBSD)))
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  The option
   --divide will remove '/' from this list.  */
const char *i386_comment_chars = "#/";
#define SVR4_COMMENT_CHARS 1
#define PREFIX_SEPARATOR '\\'

#else
const char *i386_comment_chars = "#";
#define PREFIX_SEPARATOR '/'
#endif

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.
   Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.
   Also note that comments started like this one will always work if
   '/' isn't otherwise defined.  */
const char line_comment_chars[] = "#/";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point
   nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "fFdDxX";

/* Tables for lexical analysis.  */
static char mnemonic_chars[256];
static char register_chars[256];
static char operand_chars[256];
static char identifier_chars[256];
static char digit_chars[256];

/* Lexical macros.  */
#define is_mnemonic_char(x) (mnemonic_chars[(unsigned char) x])
#define is_operand_char(x) (operand_chars[(unsigned char) x])
#define is_register_char(x) (register_chars[(unsigned char) x])
#define is_space_char(x) ((x) == ' ')
#define is_identifier_char(x) (identifier_chars[(unsigned char) x])
#define is_digit_char(x) (digit_chars[(unsigned char) x])

/* All non-digit non-letter characters that may occur in an operand.  */
static char operand_special_chars[] = "%$-+(,)*._~/<>|&^!:[@@]";

/* md_assemble() always leaves the strings it's passed unaltered.  To
   effect this we maintain a stack of saved characters that we've smashed
   with '\0's (indicating end of strings for various sub-fields of the
   assembler instruction).  */
static char save_stack[32];
static char *save_stack_p;
#define END_STRING_AND_SAVE(s) \
	do { *save_stack_p++ = *(s); *(s) = '\0'; } while (0)
#define RESTORE_END_STRING(s) \
	do { *(s) = *--save_stack_p; } while (0)

/* The instruction we're assembling.  */
static i386_insn i;

/* Possible templates for current insn.  */
static const templates *current_templates;

/* Per instruction expressionS buffers: max displacements & immediates.  */
static expressionS disp_expressions[MAX_MEMORY_OPERANDS];
static expressionS im_expressions[MAX_IMMEDIATE_OPERANDS];

/* Current operand we are working on.  */
static int this_operand = -1;

/* We support four different modes.  FLAG_CODE variable is used to distinguish
   these.  */

enum flag_code {
	CODE_32BIT,
	CODE_16BIT,
	CODE_64BIT };

static enum flag_code flag_code;
static unsigned int object_64bit;
static unsigned int disallow_64bit_reloc;
static int use_rela_relocations = 0;

#if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \
     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) \
     || defined (TE_PE) || defined (TE_PEP) || defined (OBJ_MACH_O))

/* The ELF ABI to use.  */
enum x86_elf_abi
{
  I386_ABI,
  X86_64_ABI,
  X86_64_X32_ABI
};

static enum x86_elf_abi x86_elf_abi = I386_ABI;
#endif

/* 1 for intel syntax,
   0 if att syntax.  */
static int intel_syntax = 0;

/* 1 for intel mnemonic,
   0 if att mnemonic.  */
static int intel_mnemonic = !SYSV386_COMPAT;

/* 1 if support old (<= 2.8.1) versions of gcc.  */
static int old_gcc = OLDGCC_COMPAT;

/* 1 if pseudo registers are permitted.  */
static int allow_pseudo_reg = 0;

/* 1 if register prefix % not required.  */
static int allow_naked_reg = 0;

/* 1 if the assembler should add BND prefix for all control-tranferring
   instructions supporting it, even if this prefix wasn't specified
   explicitly.  */
static int add_bnd_prefix = 0;

/* 1 if pseudo index register, eiz/riz, is allowed .  */
static int allow_index_reg = 0;

static enum check_kind
  {
    check_none = 0,
    check_warning,
    check_error
  }
sse_check, operand_check = check_warning;

/* Register prefix used for error message.  */
static const char *register_prefix = "%";

/* Used in 16 bit gcc mode to add an l suffix to call, ret, enter,
   leave, push, and pop instructions so that gcc has the same stack
   frame as in 32 bit mode.  */
static char stackop_size = '\0';

/* Non-zero to optimize code alignment.  */
int optimize_align_code = 1;

/* Non-zero to quieten some warnings.  */
static int quiet_warnings = 0;

/* CPU name.  */
static const char *cpu_arch_name = NULL;
static char *cpu_sub_arch_name = NULL;

/* CPU feature flags.  */
static i386_cpu_flags cpu_arch_flags = CPU_UNKNOWN_FLAGS;

/* If we have selected a cpu we are generating instructions for.  */
static int cpu_arch_tune_set = 0;

/* Cpu we are generating instructions for.  */
enum processor_type cpu_arch_tune = PROCESSOR_UNKNOWN;

/* CPU feature flags of cpu we are generating instructions for.  */
static i386_cpu_flags cpu_arch_tune_flags;

/* CPU instruction set architecture used.  */
enum processor_type cpu_arch_isa = PROCESSOR_UNKNOWN;

/* CPU feature flags of instruction set architecture used.  */
i386_cpu_flags cpu_arch_isa_flags;

/* If set, conditional jumps are not automatically promoted to handle
   larger than a byte offset.  */
static unsigned int no_cond_jump_promotion = 0;

/* Encode SSE instructions with VEX prefix.  */
static unsigned int sse2avx;

/* Encode scalar AVX instructions with specific vector length.  */
static enum
  {
    vex128 = 0,
    vex256
  } avxscalar;

/* Encode scalar EVEX LIG instructions with specific vector length.  */
static enum
  {
    evexl128 = 0,
    evexl256,
    evexl512
  } evexlig;

/* Encode EVEX WIG instructions with specific evex.w.  */
static enum
  {
    evexw0 = 0,
    evexw1
  } evexwig;

/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
static symbolS *GOT_symbol;

/* The dwarf2 return column, adjusted for 32 or 64 bit.  */
unsigned int x86_dwarf2_return_column;

/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int x86_cie_data_alignment;

/* Interface to relax_segment.
   There are 3 major relax states for 386 jump insns because the
   different types of jumps add different sizes to frags when we're
   figuring out what sort of jump to choose to reach a given label.  */

/* Types.  */
#define UNCOND_JUMP 0
#define COND_JUMP 1
#define COND_JUMP86 2

/* Sizes.  */
#define CODE16	1
#define SMALL	0
#define SMALL16 (SMALL | CODE16)
#define BIG	2
#define BIG16	(BIG | CODE16)

#ifndef INLINE
#ifdef __GNUC__
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

#define ENCODE_RELAX_STATE(type, size) \
  ((relax_substateT) (((type) << 2) | (size)))
#define TYPE_FROM_RELAX_STATE(s) \
  ((s) >> 2)
#define DISP_SIZE_FROM_RELAX_STATE(s) \
    ((((s) & 3) == BIG ? 4 : (((s) & 3) == BIG16 ? 2 : 1)))

/* This table is used by relax_frag to promote short jumps to long
   ones where necessary.  SMALL (short) jumps may be promoted to BIG
   (32 bit long) ones, and SMALL16 jumps to BIG16 (16 bit long).  We
   don't allow a short jump in a 32 bit code segment to be promoted to
   a 16 bit offset jump because it's slower (requires data size
   prefix), and doesn't work, unless the destination is in the bottom
   64k of the code segment (The top 16 bits of eip are zeroed).  */

const relax_typeS md_relax_table[] =
{
  /* The fields are:
     1) most positive reach of this state,
     2) most negative reach of this state,
     3) how many bytes this mode will have in the variable part of the frag
     4) which index into the table to try if we can't fit into this one.  */

  /* UNCOND_JUMP states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
  /* dword jmp adds 4 bytes to frag:
     0 extra opcode bytes, 4 displacement bytes.  */
  {0, 0, 4, 0},
  /* word jmp adds 2 byte2 to frag:
     0 extra opcode bytes, 2 displacement bytes.  */
  {0, 0, 2, 0},

  /* COND_JUMP states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG16)},
  /* dword conditionals adds 5 bytes to frag:
     1 extra opcode byte, 4 displacement bytes.  */
  {0, 0, 5, 0},
  /* word conditionals add 3 bytes to frag:
     1 extra opcode byte, 2 displacement bytes.  */
  {0, 0, 3, 0},

  /* COND_JUMP86 states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG16)},
  /* dword conditionals adds 5 bytes to frag:
     1 extra opcode byte, 4 displacement bytes.  */
  {0, 0, 5, 0},
  /* word conditionals add 4 bytes to frag:
     1 displacement byte and a 3 byte long branch insn.  */
  {0, 0, 4, 0}
};

static const arch_entry cpu_arch[] =
{
  /* Do not replace the first two entries - i386_target_format()
     relies on them being there in this order.  */
  { STRING_COMMA_LEN ("generic32"), PROCESSOR_GENERIC32,
    CPU_GENERIC32_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("generic64"), PROCESSOR_GENERIC64,
    CPU_GENERIC64_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("i8086"), PROCESSOR_UNKNOWN,
    CPU_NONE_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("i186"), PROCESSOR_UNKNOWN,
    CPU_I186_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("i286"), PROCESSOR_UNKNOWN,
    CPU_I286_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("i386"), PROCESSOR_I386,
    CPU_I386_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("i486"), PROCESSOR_I486,
    CPU_I486_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("i586"), PROCESSOR_PENTIUM,
    CPU_I586_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("i686"), PROCESSOR_PENTIUMPRO,
    CPU_I686_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("pentium"), PROCESSOR_PENTIUM,
    CPU_I586_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("pentiumpro"), PROCESSOR_PENTIUMPRO,
    CPU_PENTIUMPRO_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("pentiumii"), PROCESSOR_PENTIUMPRO,
    CPU_P2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("pentiumiii"),PROCESSOR_PENTIUMPRO,
    CPU_P3_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("pentium4"), PROCESSOR_PENTIUM4,
    CPU_P4_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("prescott"), PROCESSOR_NOCONA,
    CPU_CORE_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("nocona"), PROCESSOR_NOCONA,
    CPU_NOCONA_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("yonah"), PROCESSOR_CORE,
    CPU_CORE_FLAGS, 1, 0 },
  { STRING_COMMA_LEN ("core"), PROCESSOR_CORE,
    CPU_CORE_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("merom"), PROCESSOR_CORE2,
    CPU_CORE2_FLAGS, 1, 0 },
  { STRING_COMMA_LEN ("core2"), PROCESSOR_CORE2,
    CPU_CORE2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("corei7"), PROCESSOR_COREI7,
    CPU_COREI7_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("l1om"), PROCESSOR_L1OM,
    CPU_L1OM_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("k1om"), PROCESSOR_K1OM,
    CPU_K1OM_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("k6"), PROCESSOR_K6,
    CPU_K6_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("k6_2"), PROCESSOR_K6,
    CPU_K6_2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("athlon"), PROCESSOR_ATHLON,
    CPU_ATHLON_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("sledgehammer"), PROCESSOR_K8,
    CPU_K8_FLAGS, 1, 0 },
  { STRING_COMMA_LEN ("opteron"), PROCESSOR_K8,
    CPU_K8_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("k8"), PROCESSOR_K8,
    CPU_K8_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("amdfam10"), PROCESSOR_AMDFAM10,
    CPU_AMDFAM10_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("bdver1"), PROCESSOR_BD,
    CPU_BDVER1_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("bdver2"), PROCESSOR_BD,
    CPU_BDVER2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("bdver3"), PROCESSOR_BD,
    CPU_BDVER3_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("bdver4"), PROCESSOR_BD,
    CPU_BDVER4_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("btver1"), PROCESSOR_BT,
    CPU_BTVER1_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("btver2"), PROCESSOR_BT,
    CPU_BTVER2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".8087"), PROCESSOR_UNKNOWN,
    CPU_8087_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".287"), PROCESSOR_UNKNOWN,
    CPU_287_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".387"), PROCESSOR_UNKNOWN,
    CPU_387_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".no87"), PROCESSOR_UNKNOWN,
    CPU_ANY87_FLAGS, 0, 1 },
  { STRING_COMMA_LEN (".mmx"), PROCESSOR_UNKNOWN,
    CPU_MMX_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".nommx"), PROCESSOR_UNKNOWN,
    CPU_3DNOWA_FLAGS, 0, 1 },
  { STRING_COMMA_LEN (".sse"), PROCESSOR_UNKNOWN,
    CPU_SSE_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".sse2"), PROCESSOR_UNKNOWN,
    CPU_SSE2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".sse3"), PROCESSOR_UNKNOWN,
    CPU_SSE3_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".ssse3"), PROCESSOR_UNKNOWN,
    CPU_SSSE3_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".sse4.1"), PROCESSOR_UNKNOWN,
    CPU_SSE4_1_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".sse4.2"), PROCESSOR_UNKNOWN,
    CPU_SSE4_2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".sse4"), PROCESSOR_UNKNOWN,
    CPU_SSE4_2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".nosse"), PROCESSOR_UNKNOWN,
    CPU_ANY_SSE_FLAGS, 0, 1 },
  { STRING_COMMA_LEN (".avx"), PROCESSOR_UNKNOWN,
    CPU_AVX_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".avx2"), PROCESSOR_UNKNOWN,
    CPU_AVX2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".avx512f"), PROCESSOR_UNKNOWN,
    CPU_AVX512F_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".avx512cd"), PROCESSOR_UNKNOWN,
    CPU_AVX512CD_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".avx512er"), PROCESSOR_UNKNOWN,
    CPU_AVX512ER_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".avx512pf"), PROCESSOR_UNKNOWN,
    CPU_AVX512PF_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".noavx"), PROCESSOR_UNKNOWN,
    CPU_ANY_AVX_FLAGS, 0, 1 },
  { STRING_COMMA_LEN (".vmx"), PROCESSOR_UNKNOWN,
    CPU_VMX_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".vmfunc"), PROCESSOR_UNKNOWN,
    CPU_VMFUNC_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".smx"), PROCESSOR_UNKNOWN,
    CPU_SMX_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".xsave"), PROCESSOR_UNKNOWN,
    CPU_XSAVE_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".xsaveopt"), PROCESSOR_UNKNOWN,
    CPU_XSAVEOPT_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".aes"), PROCESSOR_UNKNOWN,
    CPU_AES_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".pclmul"), PROCESSOR_UNKNOWN,
    CPU_PCLMUL_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".clmul"), PROCESSOR_UNKNOWN,
    CPU_PCLMUL_FLAGS, 1, 0 },
  { STRING_COMMA_LEN (".fsgsbase"), PROCESSOR_UNKNOWN,
    CPU_FSGSBASE_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".rdrnd"), PROCESSOR_UNKNOWN,
    CPU_RDRND_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".f16c"), PROCESSOR_UNKNOWN,
    CPU_F16C_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".bmi2"), PROCESSOR_UNKNOWN,
    CPU_BMI2_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".fma"), PROCESSOR_UNKNOWN,
    CPU_FMA_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".fma4"), PROCESSOR_UNKNOWN,
    CPU_FMA4_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".xop"), PROCESSOR_UNKNOWN,
    CPU_XOP_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".lwp"), PROCESSOR_UNKNOWN,
    CPU_LWP_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".movbe"), PROCESSOR_UNKNOWN,
    CPU_MOVBE_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".cx16"), PROCESSOR_UNKNOWN,
    CPU_CX16_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".ept"), PROCESSOR_UNKNOWN,
    CPU_EPT_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".lzcnt"), PROCESSOR_UNKNOWN,
    CPU_LZCNT_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".hle"), PROCESSOR_UNKNOWN,
    CPU_HLE_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".rtm"), PROCESSOR_UNKNOWN,
    CPU_RTM_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".invpcid"), PROCESSOR_UNKNOWN,
    CPU_INVPCID_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".clflush"), PROCESSOR_UNKNOWN,
    CPU_CLFLUSH_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".nop"), PROCESSOR_UNKNOWN,
    CPU_NOP_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".syscall"), PROCESSOR_UNKNOWN,
    CPU_SYSCALL_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".rdtscp"), PROCESSOR_UNKNOWN,
    CPU_RDTSCP_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".3dnow"), PROCESSOR_UNKNOWN,
    CPU_3DNOW_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".3dnowa"), PROCESSOR_UNKNOWN,
    CPU_3DNOWA_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".padlock"), PROCESSOR_UNKNOWN,
    CPU_PADLOCK_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".pacifica"), PROCESSOR_UNKNOWN,
    CPU_SVME_FLAGS, 1, 0 },
  { STRING_COMMA_LEN (".svme"), PROCESSOR_UNKNOWN,
    CPU_SVME_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".sse4a"), PROCESSOR_UNKNOWN,
    CPU_SSE4A_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".abm"), PROCESSOR_UNKNOWN,
    CPU_ABM_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".bmi"), PROCESSOR_UNKNOWN,
    CPU_BMI_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".tbm"), PROCESSOR_UNKNOWN,
    CPU_TBM_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".adx"), PROCESSOR_UNKNOWN,
    CPU_ADX_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".rdseed"), PROCESSOR_UNKNOWN,
    CPU_RDSEED_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".prfchw"), PROCESSOR_UNKNOWN,
    CPU_PRFCHW_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".smap"), PROCESSOR_UNKNOWN,
    CPU_SMAP_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".mpx"), PROCESSOR_UNKNOWN,
    CPU_MPX_FLAGS, 0, 0 },
  { STRING_COMMA_LEN (".sha"), PROCESSOR_UNKNOWN,
    CPU_SHA_FLAGS, 0, 0 },
};

#ifdef I386COFF
/* Like s_lcomm_internal in gas/read.c but the alignment string
   is allowed to be optional.  */

static symbolS *
pe_lcomm_internal (int needs_align, symbolS *symbolP, addressT size)
{
  addressT align = 0;

  SKIP_WHITESPACE ();

  if (needs_align
      && *input_line_pointer == ',')
    {
      align = parse_align (needs_align - 1);

      if (align == (addressT) -1)
	return NULL;
    }
  else
    {
      if (size >= 8)
	align = 3;
      else if (size >= 4)
	align = 2;
      else if (size >= 2)
	align = 1;
      else
	align = 0;
    }

  bss_alloc (symbolP, size, align);
  return symbolP;
}

static void
pe_lcomm (int needs_align)
{
  s_comm_internal (needs_align * 2, pe_lcomm_internal);
}
#endif

const pseudo_typeS md_pseudo_table[] =
{
#if !defined(OBJ_AOUT) && !defined(USE_ALIGN_PTWO)
  {"align", s_align_bytes, 0},
#else
  {"align", s_align_ptwo, 0},
#endif
  {"arch", set_cpu_arch, 0},
#ifndef I386COFF
  {"bss", s_bss, 0},
#else
  {"lcomm", pe_lcomm, 1},
#endif
  {"ffloat", float_cons, 'f'},
  {"dfloat", float_cons, 'd'},
  {"tfloat", float_cons, 'x'},
  {"value", cons, 2},
  {"slong", signed_cons, 4},
  {"noopt", s_ignore, 0},
  {"optim", s_ignore, 0},
  {"code16gcc", set_16bit_gcc_code_flag, CODE_16BIT},
  {"code16", set_code_flag, CODE_16BIT},
  {"code32", set_code_flag, CODE_32BIT},
  {"code64", set_code_flag, CODE_64BIT},
  {"intel_syntax", set_intel_syntax, 1},
  {"att_syntax", set_intel_syntax, 0},
  {"intel_mnemonic", set_intel_mnemonic, 1},
  {"att_mnemonic", set_intel_mnemonic, 0},
  {"allow_index_reg", set_allow_index_reg, 1},
  {"disallow_index_reg", set_allow_index_reg, 0},
  {"sse_check", set_check, 0},
  {"operand_check", set_check, 1},
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  {"largecomm", handle_large_common, 0},
#else
  {"file", (void (*) (int)) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
  {"loc_mark_labels", dwarf2_directive_loc_mark_labels, 0},
#endif
#ifdef TE_PE
  {"secrel32", pe_directive_secrel, 0},
#endif
  {0, 0, 0}
};

/* For interface with expression ().  */
extern char *input_line_pointer;

/* Hash table for instruction mnemonic lookup.  */
static struct hash_control *op_hash;

/* Hash table for register lookup.  */
static struct hash_control *reg_hash;

void
i386_align_code (fragS *fragP, int count)
{
  /* Various efficient no-op patterns for aligning code labels.
     Note: Don't try to assemble the instructions in the comments.
     0L and 0w are not legal.  */
  static const char f32_1[] =
    {0x90};					/* nop			*/
  static const char f32_2[] =
    {0x66,0x90};				/* xchg %ax,%ax */
  static const char f32_3[] =
    {0x8d,0x76,0x00};				/* leal 0(%esi),%esi	*/
  static const char f32_4[] =
    {0x8d,0x74,0x26,0x00};			/* leal 0(%esi,1),%esi	*/
  static const char f32_5[] =
    {0x90,					/* nop			*/
     0x8d,0x74,0x26,0x00};			/* leal 0(%esi,1),%esi	*/
  static const char f32_6[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00};		/* leal 0L(%esi),%esi	*/
  static const char f32_7[] =
    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};	/* leal 0L(%esi,1),%esi */
  static const char f32_8[] =
    {0x90,					/* nop			*/
     0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};	/* leal 0L(%esi,1),%esi */
  static const char f32_9[] =
    {0x89,0xf6,					/* movl %esi,%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_10[] =
    {0x8d,0x76,0x00,				/* leal 0(%esi),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_11[] =
    {0x8d,0x74,0x26,0x00,			/* leal 0(%esi,1),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_12[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00,		/* leal 0L(%esi),%esi	*/
     0x8d,0xbf,0x00,0x00,0x00,0x00};		/* leal 0L(%edi),%edi	*/
  static const char f32_13[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00,		/* leal 0L(%esi),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_14[] =
    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00,	/* leal 0L(%esi,1),%esi */
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f16_3[] =
    {0x8d,0x74,0x00};				/* lea 0(%esi),%esi	*/
  static const char f16_4[] =
    {0x8d,0xb4,0x00,0x00};			/* lea 0w(%si),%si	*/
  static const char f16_5[] =
    {0x90,					/* nop			*/
     0x8d,0xb4,0x00,0x00};			/* lea 0w(%si),%si	*/
  static const char f16_6[] =
    {0x89,0xf6,					/* mov %si,%si		*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
  static const char f16_7[] =
    {0x8d,0x74,0x00,				/* lea 0(%si),%si	*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
  static const char f16_8[] =
    {0x8d,0xb4,0x00,0x00,			/* lea 0w(%si),%si	*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
  static const char jump_31[] =
    {0xeb,0x1d,0x90,0x90,0x90,0x90,0x90,	/* jmp .+31; lotsa nops	*/
     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};
  static const char *const f32_patt[] = {
    f32_1, f32_2, f32_3, f32_4, f32_5, f32_6, f32_7, f32_8,
    f32_9, f32_10, f32_11, f32_12, f32_13, f32_14
  };
  static const char *const f16_patt[] = {
    f32_1, f32_2, f16_3, f16_4, f16_5, f16_6, f16_7, f16_8
  };
  /* nopl (%[re]ax) */
  static const char alt_3[] =
    {0x0f,0x1f,0x00};
  /* nopl 0(%[re]ax) */
  static const char alt_4[] =
    {0x0f,0x1f,0x40,0x00};
  /* nopl 0(%[re]ax,%[re]ax,1) */
  static const char alt_5[] =
    {0x0f,0x1f,0x44,0x00,0x00};
  /* nopw 0(%[re]ax,%[re]ax,1) */
  static const char alt_6[] =
    {0x66,0x0f,0x1f,0x44,0x00,0x00};
  /* nopl 0L(%[re]ax) */
  static const char alt_7[] =
    {0x0f,0x1f,0x80,0x00,0x00,0x00,0x00};
  /* nopl 0L(%[re]ax,%[re]ax,1) */
  static const char alt_8[] =
    {0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  /* nopw 0L(%[re]ax,%[re]ax,1) */
  static const char alt_9[] =
    {0x66,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  /* nopw %cs:0L(%[re]ax,%[re]ax,1) */
  static const char alt_10[] =
    {0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  /* data16
     nopw %cs:0L(%[re]ax,%[re]ax,1) */
  static const char alt_long_11[] =
    {0x66,
     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  /* data16
     data16
     nopw %cs:0L(%[re]ax,%[re]ax,1) */
  static const char alt_long_12[] =
    {0x66,
     0x66,
     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  /* data16
     data16
     data16
     nopw %cs:0L(%[re]ax,%[re]ax,1) */
  static const char alt_long_13[] =
    {0x66,
     0x66,
     0x66,
     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  /* data16
     data16
     data16
     data16
     nopw %cs:0L(%[re]ax,%[re]ax,1) */
  static const char alt_long_14[] =
    {0x66,
     0x66,
     0x66,
     0x66,
     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  /* data16
     data16
     data16
     data16
     data16
     nopw %cs:0L(%[re]ax,%[re]ax,1) */
  static const char alt_long_15[] =
    {0x66,
     0x66,
     0x66,
     0x66,
     0x66,
     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  /* nopl 0(%[re]ax,%[re]ax,1)
     nopw 0(%[re]ax,%[re]ax,1) */
  static const char alt_short_11[] =
    {0x0f,0x1f,0x44,0x00,0x00,
     0x66,0x0f,0x1f,0x44,0x00,0x00};
  /* nopw 0(%[re]ax,%[re]ax,1)
     nopw 0(%[re]ax,%[re]ax,1) */
  static const char alt_short_12[] =
    {0x66,0x0f,0x1f,0x44,0x00,0x00,
     0x66,0x0f,0x1f,0x44,0x00,0x00};
  /* nopw 0(%[re]ax,%[re]ax,1)
     nopl 0L(%[re]ax) */
  static const char alt_short_13[] =
    {0x66,0x0f,0x1f,0x44,0x00,0x00,
     0x0f,0x1f,0x80,0x00,0x00,0x00,0x00};
  /* nopl 0L(%[re]ax)
     nopl 0L(%[re]ax) */
  static const char alt_short_14[] =
    {0x0f,0x1f,0x80,0x00,0x00,0x00,0x00,
     0x0f,0x1f,0x80,0x00,0x00,0x00,0x00};
  /* nopl 0L(%[re]ax)
     nopl 0L(%[re]ax,%[re]ax,1) */
  static const char alt_short_15[] =
    {0x0f,0x1f,0x80,0x00,0x00,0x00,0x00,
     0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
  static const char *const alt_short_patt[] = {
    f32_1, f32_2, alt_3, alt_4, alt_5, alt_6, alt_7, alt_8,
    alt_9, alt_10, alt_short_11, alt_short_12, alt_short_13,
    alt_short_14, alt_short_15
  };
  static const char *const alt_long_patt[] = {
    f32_1, f32_2, alt_3, alt_4, alt_5, alt_6, alt_7, alt_8,
    alt_9, alt_10, alt_long_11, alt_long_12, alt_long_13,
    alt_long_14, alt_long_15
  };

  /* Only align for at least a positive non-zero boundary. */
  if (count <= 0 || count > MAX_MEM_FOR_RS_ALIGN_CODE)
    return;

  /* We need to decide which NOP sequence to use for 32bit and
     64bit. When -mtune= is used:

     1. For PROCESSOR_I386, PROCESSOR_I486, PROCESSOR_PENTIUM and
     PROCESSOR_GENERIC32, f32_patt will be used.
     2. For PROCESSOR_PENTIUMPRO, PROCESSOR_PENTIUM4, PROCESSOR_NOCONA,
     PROCESSOR_CORE, PROCESSOR_CORE2, PROCESSOR_COREI7, and
     PROCESSOR_GENERIC64, alt_long_patt will be used.
     3. For PROCESSOR_ATHLON, PROCESSOR_K6, PROCESSOR_K8 and
     PROCESSOR_AMDFAM10, PROCESSOR_BD and PROCESSOR_BT, alt_short_patt
     will be used.

     When -mtune= isn't used, alt_long_patt will be used if
     cpu_arch_isa_flags has CpuNop.  Otherwise, f32_patt will
     be used.

     When -march= or .arch is used, we can't use anything beyond
     cpu_arch_isa_flags.   */

  if (flag_code == CODE_16BIT)
    {
      if (count > 8)
	{
	  memcpy (fragP->fr_literal + fragP->fr_fix,
		  jump_31, count);
	  /* Adjust jump offset.  */
	  fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
	}
      else
	memcpy (fragP->fr_literal + fragP->fr_fix,
		f16_patt[count - 1], count);
    }
  else
    {
      const char *const *patt = NULL;

      if (fragP->tc_frag_data.isa == PROCESSOR_UNKNOWN)
	{
	  /* PROCESSOR_UNKNOWN means that all ISAs may be used.  */
	  switch (cpu_arch_tune)
	    {
	    case PROCESSOR_UNKNOWN:
	      /* We use cpu_arch_isa_flags to check if we SHOULD
		 optimize with nops.  */
	      if (fragP->tc_frag_data.isa_flags.bitfield.cpunop)
		patt = alt_long_patt;
	      else
		patt = f32_patt;
	      break;
	    case PROCESSOR_PENTIUM4:
	    case PROCESSOR_NOCONA:
	    case PROCESSOR_CORE:
	    case PROCESSOR_CORE2:
	    case PROCESSOR_COREI7:
	    case PROCESSOR_L1OM:
	    case PROCESSOR_K1OM:
	    case PROCESSOR_GENERIC64:
	      patt = alt_long_patt;
	      break;
	    case PROCESSOR_K6:
	    case PROCESSOR_ATHLON:
	    case PROCESSOR_K8:
	    case PROCESSOR_AMDFAM10:
	    case PROCESSOR_BD:
	    case PROCESSOR_BT:
	      patt = alt_short_patt;
	      break;
	    case PROCESSOR_I386:
	    case PROCESSOR_I486:
	    case PROCESSOR_PENTIUM:
	    case PROCESSOR_PENTIUMPRO:
	    case PROCESSOR_GENERIC32:
	      patt = f32_patt;
	      break;
	    }
	}
      else
	{
	  switch (fragP->tc_frag_data.tune)
	    {
	    case PROCESSOR_UNKNOWN:
	      /* When cpu_arch_isa is set, cpu_arch_tune shouldn't be
		 PROCESSOR_UNKNOWN.  */
	      abort ();
	      break;

	    case PROCESSOR_I386:
	    case PROCESSOR_I486:
	    case PROCESSOR_PENTIUM:
	    case PROCESSOR_K6:
	    case PROCESSOR_ATHLON:
	    case PROCESSOR_K8:
	    case PROCESSOR_AMDFAM10:
	    case PROCESSOR_BD:
	    case PROCESSOR_BT:
	    case PROCESSOR_GENERIC32:
	      /* We use cpu_arch_isa_flags to check if we CAN optimize
		 with nops.  */
	      if (fragP->tc_frag_data.isa_flags.bitfield.cpunop)
		patt = alt_short_patt;
	      else
		patt = f32_patt;
	      break;
	    case PROCESSOR_PENTIUMPRO:
	    case PROCESSOR_PENTIUM4:
	    case PROCESSOR_NOCONA:
	    case PROCESSOR_CORE:
	    case PROCESSOR_CORE2:
	    case PROCESSOR_COREI7:
	    case PROCESSOR_L1OM:
	    case PROCESSOR_K1OM:
	      if (fragP->tc_frag_data.isa_flags.bitfield.cpunop)
		patt = alt_long_patt;
	      else
		patt = f32_patt;
	      break;
	    case PROCESSOR_GENERIC64:
	      patt = alt_long_patt;
	      break;
	    }
	}

      if (patt == f32_patt)
	{
	  /* If the padding is less than 15 bytes, we use the normal
	     ones.  Otherwise, we use a jump instruction and adjust
	     its offset.   */
	  int limit;

	  /* For 64bit, the limit is 3 bytes.  */
	  if (flag_code == CODE_64BIT
	      && fragP->tc_frag_data.isa_flags.bitfield.cpulm)
	    limit = 3;
	  else
	    limit = 15;
	  if (count < limit)
	    memcpy (fragP->fr_literal + fragP->fr_fix,
		    patt[count - 1], count);
	  else
	    {
	      memcpy (fragP->fr_literal + fragP->fr_fix,
		      jump_31, count);
	      /* Adjust jump offset.  */
	      fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
	    }
	}
      else
	{
	  /* Maximum length of an instruction is 15 byte.  If the
	     padding is greater than 15 bytes and we don't use jump,
	     we have to break it into smaller pieces.  */
	  int padding = count;
	  while (padding > 15)
	    {
	      padding -= 15;
	      memcpy (fragP->fr_literal + fragP->fr_fix + padding,
		      patt [14], 15);
	    }

	  if (padding)
	    memcpy (fragP->fr_literal + fragP->fr_fix,
		    patt [padding - 1], padding);
	}
    }
  fragP->fr_var = count;
}

static INLINE int
operand_type_all_zero (const union i386_operand_type *x)
{
  switch (ARRAY_SIZE(x->array))
    {
    case 3:
      if (x->array[2])
	return 0;
    case 2:
      if (x->array[1])
	return 0;
    case 1:
      return !x->array[0];
    default:
      abort ();
    }
}

static INLINE void
operand_type_set (union i386_operand_type *x, unsigned int v)
{
  switch (ARRAY_SIZE(x->array))
    {
    case 3:
      x->array[2] = v;
    case 2:
      x->array[1] = v;
    case 1:
      x->array[0] = v;
      break;
    default:
      abort ();
    }
}

static INLINE int
operand_type_equal (const union i386_operand_type *x,
		    const union i386_operand_type *y)
{
  switch (ARRAY_SIZE(x->array))
    {
    case 3:
      if (x->array[2] != y->array[2])
	return 0;
    case 2:
      if (x->array[1] != y->array[1])
	return 0;
    case 1:
      return x->array[0] == y->array[0];
      break;
    default:
      abort ();
    }
}

static INLINE int
cpu_flags_all_zero (const union i386_cpu_flags *x)
{
  switch (ARRAY_SIZE(x->array))
    {
    case 3:
      if (x->array[2])
	return 0;
    case 2:
      if (x->array[1])
	return 0;
    case 1:
      return !x->array[0];
    default:
      abort ();
    }
}

static INLINE void
cpu_flags_set (union i386_cpu_flags *x, unsigned int v)
{
  switch (ARRAY_SIZE(x->array))
    {
    case 3:
      x->array[2] = v;
    case 2:
      x->array[1] = v;
    case 1:
      x->array[0] = v;
      break;
    default:
      abort ();
    }
}

static INLINE int
cpu_flags_equal (const union i386_cpu_flags *x,
		 const union i386_cpu_flags *y)
{
  switch (ARRAY_SIZE(x->array))
    {
    case 3:
      if (x->array[2] != y->array[2])
	return 0;
    case 2:
      if (x->array[1] != y->array[1])
	return 0;
    case 1:
      return x->array[0] == y->array[0];
      break;
    default:
      abort ();
    }
}

static INLINE int
cpu_flags_check_cpu64 (i386_cpu_flags f)
{
  return !((flag_code == CODE_64BIT && f.bitfield.cpuno64)
	   || (flag_code != CODE_64BIT && f.bitfield.cpu64));
}

static INLINE i386_cpu_flags
cpu_flags_and (i386_cpu_flags x, i386_cpu_flags y)
{
  switch (ARRAY_SIZE (x.array))
    {
    case 3:
      x.array [2] &= y.array [2];
    case 2:
      x.array [1] &= y.array [1];
    case 1:
      x.array [0] &= y.array [0];
      break;
    default:
      abort ();
    }
  return x;
}

static INLINE i386_cpu_flags
cpu_flags_or (i386_cpu_flags x, i386_cpu_flags y)
{
  switch (ARRAY_SIZE (x.array))
    {
    case 3:
      x.array [2] |= y.array [2];
    case 2:
      x.array [1] |= y.array [1];
    case 1:
      x.array [0] |= y.array [0];
      break;
    default:
      abort ();
    }
  return x;
}

static INLINE i386_cpu_flags
cpu_flags_and_not (i386_cpu_flags x, i386_cpu_flags y)
{
  switch (ARRAY_SIZE (x.array))
    {
    case 3:
      x.array [2] &= ~y.array [2];
    case 2:
      x.array [1] &= ~y.array [1];
    case 1:
      x.array [0] &= ~y.array [0];
      break;
    default:
      abort ();
    }
  return x;
}

#define CPU_FLAGS_ARCH_MATCH		0x1
#define CPU_FLAGS_64BIT_MATCH		0x2
#define CPU_FLAGS_AES_MATCH		0x4
#define CPU_FLAGS_PCLMUL_MATCH		0x8
#define CPU_FLAGS_AVX_MATCH	       0x10

#define CPU_FLAGS_32BIT_MATCH \
  (CPU_FLAGS_ARCH_MATCH | CPU_FLAGS_AES_MATCH \
   | CPU_FLAGS_PCLMUL_MATCH | CPU_FLAGS_AVX_MATCH)
#define CPU_FLAGS_PERFECT_MATCH \
  (CPU_FLAGS_32BIT_MATCH | CPU_FLAGS_64BIT_MATCH)

/* Return CPU flags match bits. */

static int
cpu_flags_match (const insn_template *t)
{
  i386_cpu_flags x = t->cpu_flags;
  int match = cpu_flags_check_cpu64 (x) ? CPU_FLAGS_64BIT_MATCH : 0;

  x.bitfield.cpu64 = 0;
  x.bitfield.cpuno64 = 0;

  if (cpu_flags_all_zero (&x))
    {
      /* This instruction is available on all archs.  */
      match |= CPU_FLAGS_32BIT_MATCH;
    }
  else
    {
      /* This instruction is available only on some archs.  */
      i386_cpu_flags cpu = cpu_arch_flags;

      cpu.bitfield.cpu64 = 0;
      cpu.bitfield.cpuno64 = 0;
      cpu = cpu_flags_and (x, cpu);
      if (!cpu_flags_all_zero (&cpu))
	{
	  if (x.bitfield.cpuavx)
	    {
	      /* We only need to check AES/PCLMUL/SSE2AVX with AVX.  */
	      if (cpu.bitfield.cpuavx)
		{
		  /* Check SSE2AVX.  */
		  if (!t->opcode_modifier.sse2avx|| sse2avx)
		    {
		      match |= (CPU_FLAGS_ARCH_MATCH
				| CPU_FLAGS_AVX_MATCH);
		      /* Check AES.  */
		      if (!x.bitfield.cpuaes || cpu.bitfield.cpuaes)
			match |= CPU_FLAGS_AES_MATCH;
		      /* Check PCLMUL.  */
		      if (!x.bitfield.cpupclmul
			  || cpu.bitfield.cpupclmul)
			match |= CPU_FLAGS_PCLMUL_MATCH;
		    }
		}
	      else
		match |= CPU_FLAGS_ARCH_MATCH;
	    }
	  else
	    match |= CPU_FLAGS_32BIT_MATCH;
	}
    }
  return match;
}

static INLINE i386_operand_type
operand_type_and (i386_operand_type x, i386_operand_type y)
{
  switch (ARRAY_SIZE (x.array))
    {
    case 3:
      x.array [2] &= y.array [2];
    case 2:
      x.array [1] &= y.array [1];
    case 1:
      x.array [0] &= y.array [0];
      break;
    default:
      abort ();
    }
  return x;
}

static INLINE i386_operand_type
operand_type_or (i386_operand_type x, i386_operand_type y)
{
  switch (ARRAY_SIZE (x.array))
    {
    case 3:
      x.array [2] |= y.array [2];
    case 2:
      x.array [1] |= y.array [1];
    case 1:
      x.array [0] |= y.array [0];
      break;
    default:
      abort ();
    }
  return x;
}

static INLINE i386_operand_type
operand_type_xor (i386_operand_type x, i386_operand_type y)
{
  switch (ARRAY_SIZE (x.array))
    {
    case 3:
      x.array [2] ^= y.array [2];
    case 2:
      x.array [1] ^= y.array [1];
    case 1:
      x.array [0] ^= y.array [0];
      break;
    default:
      abort ();
    }
  return x;
}

static const i386_operand_type acc32 = OPERAND_TYPE_ACC32;
static const i386_operand_type acc64 = OPERAND_TYPE_ACC64;
static const i386_operand_type control = OPERAND_TYPE_CONTROL;
static const i386_operand_type inoutportreg
  = OPERAND_TYPE_INOUTPORTREG;
static const i386_operand_type reg16_inoutportreg
  = OPERAND_TYPE_REG16_INOUTPORTREG;
static const i386_operand_type disp16 = OPERAND_TYPE_DISP16;
static const i386_operand_type disp32 = OPERAND_TYPE_DISP32;
static const i386_operand_type disp32s = OPERAND_TYPE_DISP32S;
static const i386_operand_type disp16_32 = OPERAND_TYPE_DISP16_32;
static const i386_operand_type anydisp
  = OPERAND_TYPE_ANYDISP;
static const i386_operand_type regxmm = OPERAND_TYPE_REGXMM;
static const i386_operand_type regymm = OPERAND_TYPE_REGYMM;
static const i386_operand_type regzmm = OPERAND_TYPE_REGZMM;
static const i386_operand_type regmask = OPERAND_TYPE_REGMASK;
static const i386_operand_type imm8 = OPERAND_TYPE_IMM8;
static const i386_operand_type imm8s = OPERAND_TYPE_IMM8S;
static const i386_operand_type imm16 = OPERAND_TYPE_IMM16;
static const i386_operand_type imm32 = OPERAND_TYPE_IMM32;
static const i386_operand_type imm32s = OPERAND_TYPE_IMM32S;
static const i386_operand_type imm64 = OPERAND_TYPE_IMM64;
static const i386_operand_type imm16_32 = OPERAND_TYPE_IMM16_32;
static const i386_operand_type imm16_32s = OPERAND_TYPE_IMM16_32S;
static const i386_operand_type imm16_32_32s = OPERAND_TYPE_IMM16_32_32S;
static const i386_operand_type vec_imm4 = OPERAND_TYPE_VEC_IMM4;
static const i386_operand_type regbnd = OPERAND_TYPE_REGBND;
static const i386_operand_type vec_disp8 = OPERAND_TYPE_VEC_DISP8;

enum operand_type
{
  reg,
  imm,
  disp,
  anymem
};

static INLINE int
operand_type_check (i386_operand_type t, enum operand_type c)
{
  switch (c)
    {
    case reg:
      return (t.bitfield.reg8
	      || t.bitfield.reg16
	      || t.bitfield.reg32
	      || t.bitfield.reg64);

    case imm:
      return (t.bitfield.imm8
	      || t.bitfield.imm8s
	      || t.bitfield.imm16
	      || t.bitfield.imm32
	      || t.bitfield.imm32s
	      || t.bitfield.imm64);

    case disp:
      return (t.bitfield.disp8
	      || t.bitfield.disp16
	      || t.bitfield.disp32
	      || t.bitfield.disp32s
	      || t.bitfield.disp64);

    case anymem:
      return (t.bitfield.disp8
	      || t.bitfield.disp16
	      || t.bitfield.disp32
	      || t.bitfield.disp32s
	      || t.bitfield.disp64
	      || t.bitfield.baseindex);

    default:
      abort ();
    }

  return 0;
}

/* Return 1 if there is no conflict in 8bit/16bit/32bit/64bit on
   operand J for instruction template T.  */

static INLINE int
match_reg_size (const insn_template *t, unsigned int j)
{
  return !((i.types[j].bitfield.byte
	    && !t->operand_types[j].bitfield.byte)
	   || (i.types[j].bitfield.word
	       && !t->operand_types[j].bitfield.word)
	   || (i.types[j].bitfield.dword
	       && !t->operand_types[j].bitfield.dword)
	   || (i.types[j].bitfield.qword
	       && !t->operand_types[j].bitfield.qword));
}

/* Return 1 if there is no conflict in any size on operand J for
   instruction template T.  */

static INLINE int
match_mem_size (const insn_template *t, unsigned int j)
{
  return (match_reg_size (t, j)
	  && !((i.types[j].bitfield.unspecified
		&& !t->operand_types[j].bitfield.unspecified)
	       || (i.types[j].bitfield.fword
		   && !t->operand_types[j].bitfield.fword)
	       || (i.types[j].bitfield.tbyte
		   && !t->operand_types[j].bitfield.tbyte)
	       || (i.types[j].bitfield.xmmword
		   && !t->operand_types[j].bitfield.xmmword)
	       || (i.types[j].bitfield.ymmword
		   && !t->operand_types[j].bitfield.ymmword)
	       || (i.types[j].bitfield.zmmword
		   && !t->operand_types[j].bitfield.zmmword)));
}

/* Return 1 if there is no size conflict on any operands for
   instruction template T.  */

static INLINE int
operand_size_match (const insn_template *t)
{
  unsigned int j;
  int match = 1;

  /* Don't check jump instructions.  */
  if (t->opcode_modifier.jump
      || t->opcode_modifier.jumpbyte
      || t->opcode_modifier.jumpdword
      || t->opcode_modifier.jumpintersegment)
    return match;

  /* Check memory and accumulator operand size.  */
  for (j = 0; j < i.operands; j++)
    {
      if (t->operand_types[j].bitfield.anysize)
	continue;

      if (t->operand_types[j].bitfield.acc && !match_reg_size (t, j))
	{
	  match = 0;
	  break;
	}

      if (i.types[j].bitfield.mem && !match_mem_size (t, j))
	{
	  match = 0;
	  break;
	}
    }

  if (match)
    return match;
  else if (!t->opcode_modifier.d && !t->opcode_modifier.floatd)
    {
mismatch:
      i.error = operand_size_mismatch;
      return 0;
    }

  /* Check reverse.  */
  gas_assert (i.operands == 2);

  match = 1;
  for (j = 0; j < 2; j++)
    {
      if (t->operand_types[j].bitfield.acc
	  && !match_reg_size (t, j ? 0 : 1))
	goto mismatch;

      if (i.types[j].bitfield.mem
	  && !match_mem_size (t, j ? 0 : 1))
	goto mismatch;
    }

  return match;
}

static INLINE int
operand_type_match (i386_operand_type overlap,
		    i386_operand_type given)
{
  i386_operand_type temp = overlap;

  temp.bitfield.jumpabsolute = 0;
  temp.bitfield.unspecified = 0;
  temp.bitfield.byte = 0;
  temp.bitfield.word = 0;
  temp.bitfield.dword = 0;
  temp.bitfield.fword = 0;
  temp.bitfield.qword = 0;
  temp.bitfield.tbyte = 0;
  temp.bitfield.xmmword = 0;
  temp.bitfield.ymmword = 0;
  temp.bitfield.zmmword = 0;
  if (operand_type_all_zero (&temp))
    goto mismatch;

  if (given.bitfield.baseindex == overlap.bitfield.baseindex
      && given.bitfield.jumpabsolute == overlap.bitfield.jumpabsolute)
    return 1;

mismatch:
  i.error = operand_type_mismatch;
  return 0;
}

/* If given types g0 and g1 are registers they must be of the same type
   unless the expected operand type register overlap is null.
   Note that Acc in a template matches every size of reg.  */

static INLINE int
operand_type_register_match (i386_operand_type m0,
			     i386_operand_type g0,
			     i386_operand_type t0,
			     i386_operand_type m1,
			     i386_operand_type g1,
			     i386_operand_type t1)
{
  if (!operand_type_check (g0, reg))
    return 1;

  if (!operand_type_check (g1, reg))
    return 1;

  if (g0.bitfield.reg8 == g1.bitfield.reg8
      && g0.bitfield.reg16 == g1.bitfield.reg16
      && g0.bitfield.reg32 == g1.bitfield.reg32
      && g0.bitfield.reg64 == g1.bitfield.reg64)
    return 1;

  if (m0.bitfield.acc)
    {
      t0.bitfield.reg8 = 1;
      t0.bitfield.reg16 = 1;
      t0.bitfield.reg32 = 1;
      t0.bitfield.reg64 = 1;
    }

  if (m1.bitfield.acc)
    {
      t1.bitfield.reg8 = 1;
      t1.bitfield.reg16 = 1;
      t1.bitfield.reg32 = 1;
      t1.bitfield.reg64 = 1;
    }

  if (!(t0.bitfield.reg8 & t1.bitfield.reg8)
      && !(t0.bitfield.reg16 & t1.bitfield.reg16)
      && !(t0.bitfield.reg32 & t1.bitfield.reg32)
      && !(t0.bitfield.reg64 & t1.bitfield.reg64))
    return 1;

  i.error = register_type_mismatch;

  return 0;
}

static INLINE unsigned int
register_number (const reg_entry *r)
{
  unsigned int nr = r->reg_num;

  if (r->reg_flags & RegRex)
    nr += 8;

  return nr;
}

static INLINE unsigned int
mode_from_disp_size (i386_operand_type t)
{
  if (t.bitfield.disp8 || t.bitfield.vec_disp8)
    return 1;
  else if (t.bitfield.disp16
	   || t.bitfield.disp32
	   || t.bitfield.disp32s)
    return 2;
  else
    return 0;
}

static INLINE int
fits_in_signed_byte (offsetT num)
{
  return (num >= -128) && (num <= 127);
}

static INLINE int
fits_in_unsigned_byte (offsetT num)
{
  return (num & 0xff) == num;
}

static INLINE int
fits_in_unsigned_word (offsetT num)
{
  return (num & 0xffff) == num;
}

static INLINE int
fits_in_signed_word (offsetT num)
{
  return (-32768 <= num) && (num <= 32767);
}

static INLINE int
fits_in_signed_long (offsetT num ATTRIBUTE_UNUSED)
{
#ifndef BFD64
  return 1;
#else
  return (!(((offsetT) -1 << 31) & num)
	  || (((offsetT) -1 << 31) & num) == ((offsetT) -1 << 31));
#endif
}				/* fits_in_signed_long() */

static INLINE int
fits_in_unsigned_long (offsetT num ATTRIBUTE_UNUSED)
{
#ifndef BFD64
  return 1;
#else
  return (num & (((offsetT) 2 << 31) - 1)) == num;
#endif
}				/* fits_in_unsigned_long() */

static INLINE int
fits_in_vec_disp8 (offsetT num)
{
  int shift = i.memshift;
  unsigned int mask;

  if (shift == -1)
    abort ();

  mask = (1 << shift) - 1;

  /* Return 0 if NUM isn't properly aligned.  */
  if ((num & mask))
    return 0;

  /* Check if NUM will fit in 8bit after shift.  */
  return fits_in_signed_byte (num >> shift);
}

static INLINE int
fits_in_imm4 (offsetT num)
{
  return (num & 0xf) == num;
}

static i386_operand_type
smallest_imm_type (offsetT num)
{
  i386_operand_type t;

  operand_type_set (&t, 0);
  t.bitfield.imm64 = 1;

  if (cpu_arch_tune != PROCESSOR_I486 && num == 1)
    {
      /* This code is disabled on the 486 because all the Imm1 forms
	 in the opcode table are slower on the i486.  They're the
	 versions with the implicitly specified single-position
	 displacement, which has another syntax if you really want to
	 use that form.  */
      t.bitfield.imm1 = 1;
      t.bitfield.imm8 = 1;
      t.bitfield.imm8s = 1;
      t.bitfield.imm16 = 1;
      t.bitfield.imm32 = 1;
      t.bitfield.imm32s = 1;
    }
  else if (fits_in_signed_byte (num))
    {
      t.bitfield.imm8 = 1;
      t.bitfield.imm8s = 1;
      t.bitfield.imm16 = 1;
      t.bitfield.imm32 = 1;
      t.bitfield.imm32s = 1;
    }
  else if (fits_in_unsigned_byte (num))
    {
      t.bitfield.imm8 = 1;
      t.bitfield.imm16 = 1;
      t.bitfield.imm32 = 1;
      t.bitfield.imm32s = 1;
    }
  else if (fits_in_signed_word (num) || fits_in_unsigned_word (num))
    {
      t.bitfield.imm16 = 1;
      t.bitfield.imm32 = 1;
      t.bitfield.imm32s = 1;
    }
  else if (fits_in_signed_long (num))
    {
      t.bitfield.imm32 = 1;
      t.bitfield.imm32s = 1;
    }
  else if (fits_in_unsigned_long (num))
    t.bitfield.imm32 = 1;

  return t;
}

static offsetT
offset_in_range (offsetT val, int size)
{
  addressT mask;

  switch (size)
    {
    case 1: mask = ((addressT) 1 <<  8) - 1; break;
    case 2: mask = ((addressT) 1 << 16) - 1; break;
    case 4: mask = ((addressT) 2 << 31) - 1; break;
#ifdef BFD64
    case 8: mask = ((addressT) 2 << 63) - 1; break;
#endif
    default: abort ();
    }

#ifdef BFD64
  /* If BFD64, sign extend val for 32bit address mode.  */
  if (flag_code != CODE_64BIT
      || i.prefix[ADDR_PREFIX])
    if ((val & ~(((addressT) 2 << 31) - 1)) == 0)
      val = (val ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);
#endif

  if ((val & ~mask) != 0 && (val & ~mask) != ~mask)
    {
      char buf1[40], buf2[40];

      sprint_value (buf1, val);
      sprint_value (buf2, val & mask);
      as_warn (_("%s shortened to %s"), buf1, buf2);
    }
  return val & mask;
}

enum PREFIX_GROUP
{
  PREFIX_EXIST = 0,
  PREFIX_LOCK,
  PREFIX_REP,
  PREFIX_OTHER
};

/* Returns
   a. PREFIX_EXIST if attempting to add a prefix where one from the
   same class already exists.
   b. PREFIX_LOCK if lock prefix is added.
   c. PREFIX_REP if rep/repne prefix is added.
   d. PREFIX_OTHER if other prefix is added.
 */

static enum PREFIX_GROUP
add_prefix (unsigned int prefix)
{
  enum PREFIX_GROUP ret = PREFIX_OTHER;
  unsigned int q;

  if (prefix >= REX_OPCODE && prefix < REX_OPCODE + 16
      && flag_code == CODE_64BIT)
    {
      if ((i.prefix[REX_PREFIX] & prefix & REX_W)
	  || ((i.prefix[REX_PREFIX] & (REX_R | REX_X | REX_B))
	      && (prefix & (REX_R | REX_X | REX_B))))
	ret = PREFIX_EXIST;
      q = REX_PREFIX;
    }
  else
    {
      switch (prefix)
	{
	default:
	  abort ();

	case CS_PREFIX_OPCODE:
	case DS_PREFIX_OPCODE:
	case ES_PREFIX_OPCODE:
	case FS_PREFIX_OPCODE:
	case GS_PREFIX_OPCODE:
	case SS_PREFIX_OPCODE:
	  q = SEG_PREFIX;
	  break;

	case REPNE_PREFIX_OPCODE:
	case REPE_PREFIX_OPCODE:
	  q = REP_PREFIX;
	  ret = PREFIX_REP;
	  break;

	case LOCK_PREFIX_OPCODE:
	  q = LOCK_PREFIX;
	  ret = PREFIX_LOCK;
	  break;

	case FWAIT_OPCODE:
	  q = WAIT_PREFIX;
	  break;

	case ADDR_PREFIX_OPCODE:
	  q = ADDR_PREFIX;
	  break;

	case DATA_PREFIX_OPCODE:
	  q = DATA_PREFIX;
	  break;
	}
      if (i.prefix[q] != 0)
	ret = PREFIX_EXIST;
    }

  if (ret)
    {
      if (!i.prefix[q])
	++i.prefixes;
      i.prefix[q] |= prefix;
    }
  else
    as_bad (_("same type of prefix used twice"));

  return ret;
}

static void
update_code_flag (int value, int check)
{
  PRINTF_LIKE ((*as_error));

  flag_code = (enum flag_code) value;
  if (flag_code == CODE_64BIT)
    {
      cpu_arch_flags.bitfield.cpu64 = 1;
      cpu_arch_flags.bitfield.cpuno64 = 0;
    }
  else
    {
      cpu_arch_flags.bitfield.cpu64 = 0;
      cpu_arch_flags.bitfield.cpuno64 = 1;
    }
  if (value == CODE_64BIT && !cpu_arch_flags.bitfield.cpulm )
    {
      if (check)
	as_error = as_fatal;
      else
	as_error = as_bad;
      (*as_error) (_("64bit mode not supported on `%s'."),
		   cpu_arch_name ? cpu_arch_name : default_arch);
    }
  if (value == CODE_32BIT && !cpu_arch_flags.bitfield.cpui386)
    {
      if (check)
	as_error = as_fatal;
      else
	as_error = as_bad;
      (*as_error) (_("32bit mode not supported on `%s'."),
		   cpu_arch_name ? cpu_arch_name : default_arch);
    }
  stackop_size = '\0';
}

static void
set_code_flag (int value)
{
  update_code_flag (value, 0);
}

static void
set_16bit_gcc_code_flag (int new_code_flag)
{
  flag_code = (enum flag_code) new_code_flag;
  if (flag_code != CODE_16BIT)
    abort ();
  cpu_arch_flags.bitfield.cpu64 = 0;
  cpu_arch_flags.bitfield.cpuno64 = 1;
  stackop_size = LONG_MNEM_SUFFIX;
}

static void
set_intel_syntax (int syntax_flag)
{
  /* Find out if register prefixing is specified.  */
  int ask_naked_reg = 0;

  SKIP_WHITESPACE ();
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *string = input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp (string, "prefix") == 0)
	ask_naked_reg = 1;
      else if (strcmp (string, "noprefix") == 0)
	ask_naked_reg = -1;
      else
	as_bad (_("bad argument to syntax directive."));
      *input_line_pointer = e;
    }
  demand_empty_rest_of_line ();

  intel_syntax = syntax_flag;

  if (ask_naked_reg == 0)
    allow_naked_reg = (intel_syntax
		       && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
  else
    allow_naked_reg = (ask_naked_reg < 0);

  expr_set_rank (O_full_ptr, syntax_flag ? 10 : 0);

  identifier_chars['%'] = intel_syntax && allow_naked_reg ? '%' : 0;
  identifier_chars['$'] = intel_syntax ? '$' : 0;
  register_prefix = allow_naked_reg ? "" : "%";
}

static void
set_intel_mnemonic (int mnemonic_flag)
{
  intel_mnemonic = mnemonic_flag;
}

static void
set_allow_index_reg (int flag)
{
  allow_index_reg = flag;
}

static void
set_check (int what)
{
  enum check_kind *kind;
  const char *str;

  if (what)
    {
      kind = &operand_check;
      str = "operand";
    }
  else
    {
      kind = &sse_check;
      str = "sse";
    }

  SKIP_WHITESPACE ();

  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *string = input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp (string, "none") == 0)
	*kind = check_none;
      else if (strcmp (string, "warning") == 0)
	*kind = check_warning;
      else if (strcmp (string, "error") == 0)
	*kind = check_error;
      else
	as_bad (_("bad argument to %s_check directive."), str);
      *input_line_pointer = e;
    }
  else
    as_bad (_("missing argument for %s_check directive"), str);

  demand_empty_rest_of_line ();
}

static void
check_cpu_arch_compatible (const char *name ATTRIBUTE_UNUSED,
			   i386_cpu_flags new_flag ATTRIBUTE_UNUSED)
{
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  static const char *arch;

  /* Intel LIOM is only supported on ELF.  */
  if (!IS_ELF)
    return;

  if (!arch)
    {
      /* Use cpu_arch_name if it is set in md_parse_option.  Otherwise
	 use default_arch.  */
      arch = cpu_arch_name;
      if (!arch)
	arch = default_arch;
    }

  /* If we are targeting Intel L1OM, we must enable it.  */
  if (get_elf_backend_data (stdoutput)->elf_machine_code != EM_L1OM
      || new_flag.bitfield.cpul1om)
    return;

  /* If we are targeting Intel K1OM, we must enable it.  */
  if (get_elf_backend_data (stdoutput)->elf_machine_code != EM_K1OM
      || new_flag.bitfield.cpuk1om)
    return;

  as_bad (_("`%s' is not supported on `%s'"), name, arch);
#endif
}

static void
set_cpu_arch (int dummy ATTRIBUTE_UNUSED)
{
  SKIP_WHITESPACE ();

  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *string = input_line_pointer;
      int e = get_symbol_end ();
      unsigned int j;
      i386_cpu_flags flags;

      for (j = 0; j < ARRAY_SIZE (cpu_arch); j++)
	{
	  if (strcmp (string, cpu_arch[j].name) == 0)
	    {
	      check_cpu_arch_compatible (string, cpu_arch[j].flags);

	      if (*string != '.')
		{
		  cpu_arch_name = cpu_arch[j].name;
		  cpu_sub_arch_name = NULL;
		  cpu_arch_flags = cpu_arch[j].flags;
		  if (flag_code == CODE_64BIT)
		    {
		      cpu_arch_flags.bitfield.cpu64 = 1;
		      cpu_arch_flags.bitfield.cpuno64 = 0;
		    }
		  else
		    {
		      cpu_arch_flags.bitfield.cpu64 = 0;
		      cpu_arch_flags.bitfield.cpuno64 = 1;
		    }
		  cpu_arch_isa = cpu_arch[j].type;
		  cpu_arch_isa_flags = cpu_arch[j].flags;
		  if (!cpu_arch_tune_set)
		    {
		      cpu_arch_tune = cpu_arch_isa;
		      cpu_arch_tune_flags = cpu_arch_isa_flags;
		    }
		  break;
		}

	      if (!cpu_arch[j].negated)
		flags = cpu_flags_or (cpu_arch_flags,
				      cpu_arch[j].flags);
	      else
		flags = cpu_flags_and_not (cpu_arch_flags,
					   cpu_arch[j].flags);
	      if (!cpu_flags_equal (&flags, &cpu_arch_flags))
		{
		  if (cpu_sub_arch_name)
		    {
		      char *name = cpu_sub_arch_name;
		      cpu_sub_arch_name = concat (name,
						  cpu_arch[j].name,
						  (const char *) NULL);
		      free (name);
		    }
		  else
		    cpu_sub_arch_name = xstrdup (cpu_arch[j].name);
		  cpu_arch_flags = flags;
		  cpu_arch_isa_flags = flags;
		}
	      *input_line_pointer = e;
	      demand_empty_rest_of_line ();
	      return;
	    }
	}
      if (j >= ARRAY_SIZE (cpu_arch))
	as_bad (_("no such architecture: `%s'"), string);

      *input_line_pointer = e;
    }
  else
    as_bad (_("missing cpu architecture"));

  no_cond_jump_promotion = 0;
  if (*input_line_pointer == ','
      && !is_end_of_line[(unsigned char) input_line_pointer[1]])
    {
      char *string = ++input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp (string, "nojumps") == 0)
	no_cond_jump_promotion = 1;
      else if (strcmp (string, "jumps") == 0)
	;
      else
	as_bad (_("no such architecture modifier: `%s'"), string);

      *input_line_pointer = e;
    }

  demand_empty_rest_of_line ();
}

enum bfd_architecture
i386_arch (void)
{
  if (cpu_arch_isa == PROCESSOR_L1OM)
    {
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour
	  || flag_code != CODE_64BIT)
	as_fatal (_("Intel L1OM is 64bit ELF only"));
      return bfd_arch_l1om;
    }
  else if (cpu_arch_isa == PROCESSOR_K1OM)
    {
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour
	  || flag_code != CODE_64BIT)
	as_fatal (_("Intel K1OM is 64bit ELF only"));
      return bfd_arch_k1om;
    }
  else
    return bfd_arch_i386;
}

unsigned long
i386_mach (void)
{
  if (!strncmp (default_arch, "x86_64", 6))
    {
      if (cpu_arch_isa == PROCESSOR_L1OM)
	{
	  if (OUTPUT_FLAVOR != bfd_target_elf_flavour
	      || default_arch[6] != '\0')
	    as_fatal (_("Intel L1OM is 64bit ELF only"));
	  return bfd_mach_l1om;
	}
      else if (cpu_arch_isa == PROCESSOR_K1OM)
	{
	  if (OUTPUT_FLAVOR != bfd_target_elf_flavour
	      || default_arch[6] != '\0')
	    as_fatal (_("Intel K1OM is 64bit ELF only"));
	  return bfd_mach_k1om;
	}
      else if (default_arch[6] == '\0')
	return bfd_mach_x86_64;
      else
	return bfd_mach_x64_32;
    }
  else if (!strcmp (default_arch, "i386"))
    return bfd_mach_i386_i386;
  else
    as_fatal (_("unknown architecture"));
}

void
md_begin (void)
{
  const char *hash_err;

  /* Initialize op_hash hash table.  */
  op_hash = hash_new ();

  {
    const insn_template *optab;
    templates *core_optab;

    /* Setup for loop.  */
    optab = i386_optab;
    core_optab = (templates *) xmalloc (sizeof (templates));
    core_optab->start = optab;

    while (1)
      {
	++optab;
	if (optab->name == NULL
	    || strcmp (optab->name, (optab - 1)->name) != 0)
	  {
	    /* different name --> ship out current template list;
	       add to hash table; & begin anew.  */
	    core_optab->end = optab;
	    hash_err = hash_insert (op_hash,
				    (optab - 1)->name,
				    (void *) core_optab);
	    if (hash_err)
	      {
		as_fatal (_("can't hash %s: %s"),
			  (optab - 1)->name,
			  hash_err);
	      }
	    if (optab->name == NULL)
	      break;
	    core_optab = (templates *) xmalloc (sizeof (templates));
	    core_optab->start = optab;
	  }
      }
  }

  /* Initialize reg_hash hash table.  */
  reg_hash = hash_new ();
  {
    const reg_entry *regtab;
    unsigned int regtab_size = i386_regtab_size;

    for (regtab = i386_regtab; regtab_size--; regtab++)
      {
	hash_err = hash_insert (reg_hash, regtab->reg_name, (void *) regtab);
	if (hash_err)
	  as_fatal (_("can't hash %s: %s"),
		    regtab->reg_name,
		    hash_err);
      }
  }

  /* Fill in lexical tables:  mnemonic_chars, operand_chars.  */
  {
    int c;
    char *p;

    for (c = 0; c < 256; c++)
      {
	if (ISDIGIT (c))
	  {
	    digit_chars[c] = c;
	    mnemonic_chars[c] = c;
	    register_chars[c] = c;
	    operand_chars[c] = c;
	  }
	else if (ISLOWER (c))
	  {
	    mnemonic_chars[c] = c;
	    register_chars[c] = c;
	    operand_chars[c] = c;
	  }
	else if (ISUPPER (c))
	  {
	    mnemonic_chars[c] = TOLOWER (c);
	    register_chars[c] = mnemonic_chars[c];
	    operand_chars[c] = c;
	  }
	else if (c == '{' || c == '}')
	  operand_chars[c] = c;

	if (ISALPHA (c) || ISDIGIT (c))
	  identifier_chars[c] = c;
	else if (c >= 128)
	  {
	    identifier_chars[c] = c;
	    operand_chars[c] = c;
	  }
      }

#ifdef LEX_AT
    identifier_chars['@@'] = '@@';
#endif
#ifdef LEX_QM
    identifier_chars['?'] = '?';
    operand_chars['?'] = '?';
#endif
    digit_chars['-'] = '-';
    mnemonic_chars['_'] = '_';
    mnemonic_chars['-'] = '-';
    mnemonic_chars['.'] = '.';
    identifier_chars['_'] = '_';
    identifier_chars['.'] = '.';

    for (p = operand_special_chars; *p != '\0'; p++)
      operand_chars[(unsigned char) *p] = *p;
  }

  if (flag_code == CODE_64BIT)
    {
#if defined (OBJ_COFF) && defined (TE_PE)
      x86_dwarf2_return_column = (OUTPUT_FLAVOR == bfd_target_coff_flavour
				  ? 32 : 16);
#else
      x86_dwarf2_return_column = 16;
#endif
      x86_cie_data_alignment = -8;
    }
  else
    {
      x86_dwarf2_return_column = 8;
      x86_cie_data_alignment = -4;
    }
}

void
i386_print_statistics (FILE *file)
{
  hash_print_statistics (file, "i386 opcode", op_hash);
  hash_print_statistics (file, "i386 register", reg_hash);
}

#ifdef DEBUG386

/* Debugging routines for md_assemble.  */
static void pte (insn_template *);
static void pt (i386_operand_type);
static void pe (expressionS *);
static void ps (symbolS *);

static void
pi (char *line, i386_insn *x)
{
  unsigned int j;

  fprintf (stdout, "%s: template ", line);
  pte (&x->tm);
  fprintf (stdout, "  address: base %s  index %s  scale %x\n",
	   x->base_reg ? x->base_reg->reg_name : "none",
	   x->index_reg ? x->index_reg->reg_name : "none",
	   x->log2_scale_factor);
  fprintf (stdout, "  modrm:  mode %x  reg %x  reg/mem %x\n",
	   x->rm.mode, x->rm.reg, x->rm.regmem);
  fprintf (stdout, "  sib:  base %x  index %x  scale %x\n",
	   x->sib.base, x->sib.index, x->sib.scale);
  fprintf (stdout, "  rex: 64bit %x  extX %x  extY %x  extZ %x\n",
	   (x->rex & REX_W) != 0,
	   (x->rex & REX_R) != 0,
	   (x->rex & REX_X) != 0,
	   (x->rex & REX_B) != 0);
  for (j = 0; j < x->operands; j++)
    {
      fprintf (stdout, "    #%d:  ", j + 1);
      pt (x->types[j]);
      fprintf (stdout, "\n");
      if (x->types[j].bitfield.reg8
	  || x->types[j].bitfield.reg16
	  || x->types[j].bitfield.reg32
	  || x->types[j].bitfield.reg64
	  || x->types[j].bitfield.regmmx
	  || x->types[j].bitfield.regxmm
	  || x->types[j].bitfield.regymm
	  || x->types[j].bitfield.regzmm
	  || x->types[j].bitfield.sreg2
	  || x->types[j].bitfield.sreg3
	  || x->types[j].bitfield.control
	  || x->types[j].bitfield.debug
	  || x->types[j].bitfield.test)
	fprintf (stdout, "%s\n", x->op[j].regs->reg_name);
      if (operand_type_check (x->types[j], imm))
	pe (x->op[j].imms);
      if (operand_type_check (x->types[j], disp))
	pe (x->op[j].disps);
    }
}

static void
pte (insn_template *t)
{
  unsigned int j;
  fprintf (stdout, " %d operands ", t->operands);
  fprintf (stdout, "opcode %x ", t->base_opcode);
  if (t->extension_opcode != None)
    fprintf (stdout, "ext %x ", t->extension_opcode);
  if (t->opcode_modifier.d)
    fprintf (stdout, "D");
  if (t->opcode_modifier.w)
    fprintf (stdout, "W");
  fprintf (stdout, "\n");
  for (j = 0; j < t->operands; j++)
    {
      fprintf (stdout, "    #%d type ", j + 1);
      pt (t->operand_types[j]);
      fprintf (stdout, "\n");
    }
}

static void
pe (expressionS *e)
{
  fprintf (stdout, "    operation     %d\n", e->X_op);
  fprintf (stdout, "    add_number    %ld (%lx)\n",
	   (long) e->X_add_number, (long) e->X_add_number);
  if (e->X_add_symbol)
    {
      fprintf (stdout, "    add_symbol    ");
      ps (e->X_add_symbol);
      fprintf (stdout, "\n");
    }
  if (e->X_op_symbol)
    {
      fprintf (stdout, "    op_symbol    ");
      ps (e->X_op_symbol);
      fprintf (stdout, "\n");
    }
}

static void
ps (symbolS *s)
{
  fprintf (stdout, "%s type %s%s",
	   S_GET_NAME (s),
	   S_IS_EXTERNAL (s) ? "EXTERNAL " : "",
	   segment_name (S_GET_SEGMENT (s)));
}

static struct type_name
  {
    i386_operand_type mask;
    const char *name;
  }
const type_names[] =
{
  { OPERAND_TYPE_REG8, "r8" },
  { OPERAND_TYPE_REG16, "r16" },
  { OPERAND_TYPE_REG32, "r32" },
  { OPERAND_TYPE_REG64, "r64" },
  { OPERAND_TYPE_IMM8, "i8" },
  { OPERAND_TYPE_IMM8, "i8s" },
  { OPERAND_TYPE_IMM16, "i16" },
  { OPERAND_TYPE_IMM32, "i32" },
  { OPERAND_TYPE_IMM32S, "i32s" },
  { OPERAND_TYPE_IMM64, "i64" },
  { OPERAND_TYPE_IMM1, "i1" },
  { OPERAND_TYPE_BASEINDEX, "BaseIndex" },
  { OPERAND_TYPE_DISP8, "d8" },
  { OPERAND_TYPE_DISP16, "d16" },
  { OPERAND_TYPE_DISP32, "d32" },
  { OPERAND_TYPE_DISP32S, "d32s" },
  { OPERAND_TYPE_DISP64, "d64" },
  { OPERAND_TYPE_VEC_DISP8, "Vector d8" },
  { OPERAND_TYPE_INOUTPORTREG, "InOutPortReg" },
  { OPERAND_TYPE_SHIFTCOUNT, "ShiftCount" },
  { OPERAND_TYPE_CONTROL, "control reg" },
  { OPERAND_TYPE_TEST, "test reg" },
  { OPERAND_TYPE_DEBUG, "debug reg" },
  { OPERAND_TYPE_FLOATREG, "FReg" },
  { OPERAND_TYPE_FLOATACC, "FAcc" },
  { OPERAND_TYPE_SREG2, "SReg2" },
  { OPERAND_TYPE_SREG3, "SReg3" },
  { OPERAND_TYPE_ACC, "Acc" },
  { OPERAND_TYPE_JUMPABSOLUTE, "Jump Absolute" },
  { OPERAND_TYPE_REGMMX, "rMMX" },
  { OPERAND_TYPE_REGXMM, "rXMM" },
  { OPERAND_TYPE_REGYMM, "rYMM" },
  { OPERAND_TYPE_REGZMM, "rZMM" },
  { OPERAND_TYPE_REGMASK, "Mask reg" },
  { OPERAND_TYPE_ESSEG, "es" },
};

static void
pt (i386_operand_type t)
{
  unsigned int j;
  i386_operand_type a;

  for (j = 0; j < ARRAY_SIZE (type_names); j++)
    {
      a = operand_type_and (t, type_names[j].mask);
      if (!operand_type_all_zero (&a))
	fprintf (stdout, "%s, ",  type_names[j].name);
    }
  fflush (stdout);
}

#endif /* DEBUG386 */

static bfd_reloc_code_real_type
reloc (unsigned int size,
       int pcrel,
       int sign,
       bfd_reloc_code_real_type other)
{
  if (other != NO_RELOC)
    {
      reloc_howto_type *rel;

      if (size == 8)
	switch (other)
	  {
	  case BFD_RELOC_X86_64_GOT32:
	    return BFD_RELOC_X86_64_GOT64;
	    break;
	  case BFD_RELOC_X86_64_PLTOFF64:
	    return BFD_RELOC_X86_64_PLTOFF64;
	    break;
	  case BFD_RELOC_X86_64_GOTPC32:
	    other = BFD_RELOC_X86_64_GOTPC64;
	    break;
	  case BFD_RELOC_X86_64_GOTPCREL:
	    other = BFD_RELOC_X86_64_GOTPCREL64;
	    break;
	  case BFD_RELOC_X86_64_TPOFF32:
	    other = BFD_RELOC_X86_64_TPOFF64;
	    break;
	  case BFD_RELOC_X86_64_DTPOFF32:
	    other = BFD_RELOC_X86_64_DTPOFF64;
	    break;
	  default:
	    break;
	  }

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      if (other == BFD_RELOC_SIZE32)
	{
	  if (size == 8)
	    return BFD_RELOC_SIZE64;
	  if (pcrel)
	    as_bad (_("there are no pc-relative size relocations"));
	}
#endif

      /* Sign-checking 4-byte relocations in 16-/32-bit code is pointless.  */
      if (size == 4 && (flag_code != CODE_64BIT || disallow_64bit_reloc))
	sign = -1;

      rel = bfd_reloc_type_lookup (stdoutput, other);
      if (!rel)
	as_bad (_("unknown relocation (%u)"), other);
      else if (size != bfd_get_reloc_size (rel))
	as_bad (_("%u-byte relocation cannot be applied to %u-byte field"),
		bfd_get_reloc_size (rel),
		size);
      else if (pcrel && !rel->pc_relative)
	as_bad (_("non-pc-relative relocation for pc-relative field"));
      else if ((rel->complain_on_overflow == complain_overflow_signed
		&& !sign)
	       || (rel->complain_on_overflow == complain_overflow_unsigned
		   && sign > 0))
	as_bad (_("relocated field and relocation type differ in signedness"));
      else
	return other;
      return NO_RELOC;
    }

  if (pcrel)
    {
      if (!sign)
	as_bad (_("there are no unsigned pc-relative relocations"));
      switch (size)
	{
	case 1: return BFD_RELOC_8_PCREL;
	case 2: return BFD_RELOC_16_PCREL;
	case 4: return BFD_RELOC_32_PCREL;
	case 8: return BFD_RELOC_64_PCREL;
	}
      as_bad (_("cannot do %u byte pc-relative relocation"), size);
    }
  else
    {
      if (sign > 0)
	switch (size)
	  {
	  case 4: return BFD_RELOC_X86_64_32S;
	  }
      else
	switch (size)
	  {
	  case 1: return BFD_RELOC_8;
	  case 2: return BFD_RELOC_16;
	  case 4: return BFD_RELOC_32;
	  case 8: return BFD_RELOC_64;
	  }
      as_bad (_("cannot do %s %u byte relocation"),
	      sign > 0 ? "signed" : "unsigned", size);
    }

  return NO_RELOC;
}

/* Here we decide which fixups can be adjusted to make them relative to
   the beginning of the section instead of the symbol.  Basically we need
   to make sure that the dynamic relocations are done correctly, so in
   some cases we force the original symbol to be used.  */

int
tc_i386_fix_adjustable (fixS *fixP ATTRIBUTE_UNUSED)
{
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (!IS_ELF)
    return 1;

  /* Don't adjust pc-relative references to merge sections in 64-bit
     mode.  */
  if (use_rela_relocations
      && (S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0
      && fixP->fx_pcrel)
    return 0;

  /* The x86_64 GOTPCREL are represented as 32bit PCrel relocations
     and changed later by validate_fix.  */
  if (GOT_symbol && fixP->fx_subsy == GOT_symbol
      && fixP->fx_r_type == BFD_RELOC_32_PCREL)
    return 0;

  /* Adjust_reloc_syms doesn't know about the GOT.  Need to keep symbol
     for size relocations.  */
  if (fixP->fx_r_type == BFD_RELOC_SIZE32
      || fixP->fx_r_type == BFD_RELOC_SIZE64
      || fixP->fx_r_type == BFD_RELOC_386_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_386_PLT32
      || fixP->fx_r_type == BFD_RELOC_386_GOT32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_GD
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LDM
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LDO_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE
      || fixP->fx_r_type == BFD_RELOC_386_TLS_GOTIE
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LE_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LE
      || fixP->fx_r_type == BFD_RELOC_386_TLS_GOTDESC
      || fixP->fx_r_type == BFD_RELOC_386_TLS_DESC_CALL
      || fixP->fx_r_type == BFD_RELOC_X86_64_PLT32
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOT32
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPCREL
      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSGD
      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSLD
      || fixP->fx_r_type == BFD_RELOC_X86_64_DTPOFF32
      || fixP->fx_r_type == BFD_RELOC_X86_64_DTPOFF64
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTTPOFF
      || fixP->fx_r_type == BFD_RELOC_X86_64_TPOFF32
      || fixP->fx_r_type == BFD_RELOC_X86_64_TPOFF64
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTOFF64
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPC32_TLSDESC
      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSDESC_CALL
      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;
#endif
  return 1;
}

static int
intel_float_operand (const char *mnemonic)
{
  /* Note that the value returned is meaningful only for opcodes with (memory)
     operands, hence the code here is free to improperly handle opcodes that
     have no operands (for better performance and smaller code). */

  if (mnemonic[0] != 'f')
    return 0; /* non-math */

  switch (mnemonic[1])
    {
    /* fclex, fdecstp, fdisi, femms, feni, fincstp, finit, fsetpm, and
       the fs segment override prefix not currently handled because no
       call path can make opcodes without operands get here */
    case 'i':
      return 2 /* integer op */;
    case 'l':
      if (mnemonic[2] == 'd' && (mnemonic[3] == 'c' || mnemonic[3] == 'e'))
	return 3; /* fldcw/fldenv */
      break;
    case 'n':
      if (mnemonic[2] != 'o' /* fnop */)
	return 3; /* non-waiting control op */
      break;
    case 'r':
      if (mnemonic[2] == 's')
	return 3; /* frstor/frstpm */
      break;
    case 's':
      if (mnemonic[2] == 'a')
	return 3; /* fsave */
      if (mnemonic[2] == 't')
	{
	  switch (mnemonic[3])
	    {
	    case 'c': /* fstcw */
	    case 'd': /* fstdw */
	    case 'e': /* fstenv */
	    case 's': /* fsts[gw] */
	      return 3;
	    }
	}
      break;
    case 'x':
      if (mnemonic[2] == 'r' || mnemonic[2] == 's')
	return 0; /* fxsave/fxrstor are not really math ops */
      break;
    }

  return 1;
}

/* Build the VEX prefix.  */

static void
build_vex_prefix (const insn_template *t)
{
  unsigned int register_specifier;
  unsigned int implied_prefix;
  unsigned int vector_length;

  /* Check register specifier.  */
  if (i.vex.register_specifier)
    {
      register_specifier =
	~register_number (i.vex.register_specifier) & 0xf;
      gas_assert ((i.vex.register_specifier->reg_flags & RegVRex) == 0);
    }
  else
    register_specifier = 0xf;

  /* Use 2-byte VEX prefix by swappping destination and source
     operand.  */
  if (!i.swap_operand
      && i.operands == i.reg_operands
      && i.tm.opcode_modifier.vexopcode == VEX0F
      && i.tm.opcode_modifier.s
      && i.rex == REX_B)
    {
      unsigned int xchg = i.operands - 1;
      union i386_op temp_op;
      i386_operand_type temp_type;

      temp_type = i.types[xchg];
      i.types[xchg] = i.types[0];
      i.types[0] = temp_type;
      temp_op = i.op[xchg];
      i.op[xchg] = i.op[0];
      i.op[0] = temp_op;

      gas_assert (i.rm.mode == 3);

      i.rex = REX_R;
      xchg = i.rm.regmem;
      i.rm.regmem = i.rm.reg;
      i.rm.reg = xchg;

      /* Use the next insn.  */
      i.tm = t[1];
    }

  if (i.tm.opcode_modifier.vex == VEXScalar)
    vector_length = avxscalar;
  else
    vector_length = i.tm.opcode_modifier.vex == VEX256 ? 1 : 0;

  switch ((i.tm.base_opcode >> 8) & 0xff)
    {
    case 0:
      implied_prefix = 0;
      break;
    case DATA_PREFIX_OPCODE:
      implied_prefix = 1;
      break;
    case REPE_PREFIX_OPCODE:
      implied_prefix = 2;
      break;
    case REPNE_PREFIX_OPCODE:
      implied_prefix = 3;
      break;
    default:
      abort ();
    }

  /* Use 2-byte VEX prefix if possible.  */
  if (i.tm.opcode_modifier.vexopcode == VEX0F
      && i.tm.opcode_modifier.vexw != VEXW1
      && (i.rex & (REX_W | REX_X | REX_B)) == 0)
    {
      /* 2-byte VEX prefix.  */
      unsigned int r;

      i.vex.length = 2;
      i.vex.bytes[0] = 0xc5;

      /* Check the REX.R bit.  */
      r = (i.rex & REX_R) ? 0 : 1;
      i.vex.bytes[1] = (r << 7
			| register_specifier << 3
			| vector_length << 2
			| implied_prefix);
    }
  else
    {
      /* 3-byte VEX prefix.  */
      unsigned int m, w;

      i.vex.length = 3;

      switch (i.tm.opcode_modifier.vexopcode)
	{
	case VEX0F:
	  m = 0x1;
	  i.vex.bytes[0] = 0xc4;
	  break;
	case VEX0F38:
	  m = 0x2;
	  i.vex.bytes[0] = 0xc4;
	  break;
	case VEX0F3A:
	  m = 0x3;
	  i.vex.bytes[0] = 0xc4;
	  break;
	case XOP08:
	  m = 0x8;
	  i.vex.bytes[0] = 0x8f;
	  break;
	case XOP09:
	  m = 0x9;
	  i.vex.bytes[0] = 0x8f;
	  break;
	case XOP0A:
	  m = 0xa;
	  i.vex.bytes[0] = 0x8f;
	  break;
	default:
	  abort ();
	}

      /* The high 3 bits of the second VEX byte are 1's compliment
	 of RXB bits from REX.  */
      i.vex.bytes[1] = (~i.rex & 0x7) << 5 | m;

      /* Check the REX.W bit.  */
      w = (i.rex & REX_W) ? 1 : 0;
      if (i.tm.opcode_modifier.vexw)
	{
	  if (w)
	    abort ();

	  if (i.tm.opcode_modifier.vexw == VEXW1)
	    w = 1;
	}

      i.vex.bytes[2] = (w << 7
			| register_specifier << 3
			| vector_length << 2
			| implied_prefix);
    }
}

/* Build the EVEX prefix.  */

static void
build_evex_prefix (void)
{
  unsigned int register_specifier;
  unsigned int implied_prefix;
  unsigned int m, w;
  rex_byte vrex_used = 0;

  /* Check register specifier.  */
  if (i.vex.register_specifier)
    {
      gas_assert ((i.vrex & REX_X) == 0);

      register_specifier = i.vex.register_specifier->reg_num;
      if ((i.vex.register_specifier->reg_flags & RegRex))
	register_specifier += 8;
      /* The upper 16 registers are encoded in the fourth byte of the
	 EVEX prefix.  */
      if (!(i.vex.register_specifier->reg_flags & RegVRex))
	i.vex.bytes[3] = 0x8;
      register_specifier = ~register_specifier & 0xf;
    }
  else
    {
      register_specifier = 0xf;

      /* Encode upper 16 vector index register in the fourth byte of
	 the EVEX prefix.  */
      if (!(i.vrex & REX_X))
	i.vex.bytes[3] = 0x8;
      else
	vrex_used |= REX_X;
    }

  switch ((i.tm.base_opcode >> 8) & 0xff)
    {
    case 0:
      implied_prefix = 0;
      break;
    case DATA_PREFIX_OPCODE:
      implied_prefix = 1;
      break;
    case REPE_PREFIX_OPCODE:
      implied_prefix = 2;
      break;
    case REPNE_PREFIX_OPCODE:
      implied_prefix = 3;
      break;
    default:
      abort ();
    }

  /* 4 byte EVEX prefix.  */
  i.vex.length = 4;
  i.vex.bytes[0] = 0x62;

  /* mmmm bits.  */
  switch (i.tm.opcode_modifier.vexopcode)
    {
    case VEX0F:
      m = 1;
      break;
    case VEX0F38:
      m = 2;
      break;
    case VEX0F3A:
      m = 3;
      break;
    default:
      abort ();
      break;
    }

  /* The high 3 bits of the second EVEX byte are 1's compliment of RXB
     bits from REX.  */
  i.vex.bytes[1] = (~i.rex & 0x7) << 5 | m;

  /* The fifth bit of the second EVEX byte is 1's compliment of the
     REX_R bit in VREX.  */
  if (!(i.vrex & REX_R))
    i.vex.bytes[1] |= 0x10;
  else
    vrex_used |= REX_R;

  if ((i.reg_operands + i.imm_operands) == i.operands)
    {
      /* When all operands are registers, the REX_X bit in REX is not
	 used.  We reuse it to encode the upper 16 registers, which is
	 indicated by the REX_B bit in VREX.  The REX_X bit is encoded
	 as 1's compliment.  */
      if ((i.vrex & REX_B))
	{
	  vrex_used |= REX_B;
	  i.vex.bytes[1] &= ~0x40;
	}
    }

  /* EVEX instructions shouldn't need the REX prefix.  */
  i.vrex &= ~vrex_used;
  gas_assert (i.vrex == 0);

  /* Check the REX.W bit.  */
  w = (i.rex & REX_W) ? 1 : 0;
  if (i.tm.opcode_modifier.vexw)
    {
      if (i.tm.opcode_modifier.vexw == VEXW1)
	w = 1;
    }
  /* If w is not set it means we are dealing with WIG instruction.  */
  else if (!w)
    {
      if (evexwig == evexw1)
        w = 1;
    }

  /* Encode the U bit.  */
  implied_prefix |= 0x4;

  /* The third byte of the EVEX prefix.  */
  i.vex.bytes[2] = (w << 7 | register_specifier << 3 | implied_prefix);

  /* The fourth byte of the EVEX prefix.  */
  /* The zeroing-masking bit.  */
  if (i.mask && i.mask->zeroing)
    i.vex.bytes[3] |= 0x80;

  /* Don't always set the broadcast bit if there is no RC.  */
  if (!i.rounding)
    {
      /* Encode the vector length.  */
      unsigned int vec_length;

      switch (i.tm.opcode_modifier.evex)
	{
	case EVEXLIG: /* LL' is ignored */
	  vec_length = evexlig << 5;
	  break;
	case EVEX128:
	  vec_length = 0 << 5;
	  break;
	case EVEX256:
	  vec_length = 1 << 5;
	  break;
	case EVEX512:
	  vec_length = 2 << 5;
	  break;
	default:
	  abort ();
	  break;
	}
      i.vex.bytes[3] |= vec_length;
      /* Encode the broadcast bit.  */
      if (i.broadcast)
	i.vex.bytes[3] |= 0x10;
    }
  else
    {
      if (i.rounding->type != saeonly)
	i.vex.bytes[3] |= 0x10 | (i.rounding->type << 5);
      else
	i.vex.bytes[3] |= 0x10;
    }

  if (i.mask && i.mask->mask)
    i.vex.bytes[3] |= i.mask->mask->reg_num;
}

static void
process_immext (void)
{
  expressionS *exp;

  if ((i.tm.cpu_flags.bitfield.cpusse3 || i.tm.cpu_flags.bitfield.cpusvme)
      && i.operands > 0)
    {
      /* MONITOR/MWAIT as well as SVME instructions have fixed operands
	 with an opcode suffix which is coded in the same place as an
	 8-bit immediate field would be.
	 Here we check those operands and remove them afterwards.  */
      unsigned int x;

      for (x = 0; x < i.operands; x++)
	if (register_number (i.op[x].regs) != x)
	  as_bad (_("can't use register '%s%s' as operand %d in '%s'."),
		  register_prefix, i.op[x].regs->reg_name, x + 1,
		  i.tm.name);

      i.operands = 0;
    }

  /* These AMD 3DNow! and SSE2 instructions have an opcode suffix
     which is coded in the same place as an 8-bit immediate field
     would be.  Here we fake an 8-bit immediate operand from the
     opcode suffix stored in tm.extension_opcode.

     AVX instructions also use this encoding, for some of
     3 argument instructions.  */

  gas_assert (i.imm_operands <= 1
	      && (i.operands <= 2
		  || ((i.tm.opcode_modifier.vex
		       || i.tm.opcode_modifier.evex)
		      && i.operands <= 4)));

  exp = &im_expressions[i.imm_operands++];
  i.op[i.operands].imms = exp;
  i.types[i.operands] = imm8;
  i.operands++;
  exp->X_op = O_constant;
  exp->X_add_number = i.tm.extension_opcode;
  i.tm.extension_opcode = None;
}


static int
check_hle (void)
{
  switch (i.tm.opcode_modifier.hleprefixok)
    {
    default:
      abort ();
    case HLEPrefixNone:
      as_bad (_("invalid instruction `%s' after `%s'"),
	      i.tm.name, i.hle_prefix);
      return 0;
    case HLEPrefixLock:
      if (i.prefix[LOCK_PREFIX])
	return 1;
      as_bad (_("missing `lock' with `%s'"), i.hle_prefix);
      return 0;
    case HLEPrefixAny:
      return 1;
    case HLEPrefixRelease:
      if (i.prefix[HLE_PREFIX] != XRELEASE_PREFIX_OPCODE)
	{
	  as_bad (_("instruction `%s' after `xacquire' not allowed"),
		  i.tm.name);
	  return 0;
	}
      if (i.mem_operands == 0
	  || !operand_type_check (i.types[i.operands - 1], anymem))
	{
	  as_bad (_("memory destination needed for instruction `%s'"
		    " after `xrelease'"), i.tm.name);
	  return 0;
	}
      return 1;
    }
}

/* This is the guts of the machine-dependent assembler.  LINE points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char *line)
{
  unsigned int j;
  char mnemonic[MAX_MNEM_SIZE];
  const insn_template *t;

  /* Initialize globals.  */
  memset (&i, '\0', sizeof (i));
  for (j = 0; j < MAX_OPERANDS; j++)
    i.reloc[j] = NO_RELOC;
  memset (disp_expressions, '\0', sizeof (disp_expressions));
  memset (im_expressions, '\0', sizeof (im_expressions));
  save_stack_p = save_stack;

  /* First parse an instruction mnemonic & call i386_operand for the operands.
     We assume that the scrubber has arranged it so that line[0] is the valid
     start of a (possibly prefixed) mnemonic.  */

  line = parse_insn (line, mnemonic);
  if (line == NULL)
    return;

  line = parse_operands (line, mnemonic);
  this_operand = -1;
  if (line == NULL)
    return;

  /* Now we've parsed the mnemonic into a set of templates, and have the
     operands at hand.  */

  /* All intel opcodes have reversed operands except for "bound" and
     "enter".  We also don't reverse intersegment "jmp" and "call"
     instructions with 2 immediate operands so that the immediate segment
     precedes the offset, as it does when in AT&T mode. */
  if (intel_syntax
      && i.operands > 1
      && (strcmp (mnemonic, "bound") != 0)
      && (strcmp (mnemonic, "invlpga") != 0)
      && !(operand_type_check (i.types[0], imm)
	   && operand_type_check (i.types[1], imm)))
    swap_operands ();

  /* The order of the immediates should be reversed
     for 2 immediates extrq and insertq instructions */
  if (i.imm_operands == 2
      && (strcmp (mnemonic, "extrq") == 0
	  || strcmp (mnemonic, "insertq") == 0))
      swap_2_operands (0, 1);

  if (i.imm_operands)
    optimize_imm ();

  /* Don't optimize displacement for movabs since it only takes 64bit
     displacement.  */
  if (i.disp_operands
      && i.disp_encoding != disp_encoding_32bit
      && (flag_code != CODE_64BIT
	  || strcmp (mnemonic, "movabs") != 0))
    optimize_disp ();

  /* Next, we find a template that matches the given insn,
     making sure the overlap of the given operands types is consistent
     with the template operand types.  */

  if (!(t = match_template ()))
    return;

  if (sse_check != check_none
      && !i.tm.opcode_modifier.noavx
      && (i.tm.cpu_flags.bitfield.cpusse
	  || i.tm.cpu_flags.bitfield.cpusse2
	  || i.tm.cpu_flags.bitfield.cpusse3
	  || i.tm.cpu_flags.bitfield.cpussse3
	  || i.tm.cpu_flags.bitfield.cpusse4_1
	  || i.tm.cpu_flags.bitfield.cpusse4_2))
    {
      (sse_check == check_warning
       ? as_warn
       : as_bad) (_("SSE instruction `%s' is used"), i.tm.name);
    }

  /* Zap movzx and movsx suffix.  The suffix has been set from
     "word ptr" or "byte ptr" on the source operand in Intel syntax
     or extracted from mnemonic in AT&T syntax.  But we'll use
     the destination register to choose the suffix for encoding.  */
  if ((i.tm.base_opcode & ~9) == 0x0fb6)
    {
      /* In Intel syntax, there must be a suffix.  In AT&T syntax, if
	 there is no suffix, the default will be byte extension.  */
      if (i.reg_operands != 2
	  && !i.suffix
	  && intel_syntax)
	as_bad (_("ambiguous operand size for `%s'"), i.tm.name);

      i.suffix = 0;
    }

  if (i.tm.opcode_modifier.fwait)
    if (!add_prefix (FWAIT_OPCODE))
      return;

  /* Check if REP prefix is OK.  */
  if (i.rep_prefix && !i.tm.opcode_modifier.repprefixok)
    {
      as_bad (_("invalid instruction `%s' after `%s'"),
		i.tm.name, i.rep_prefix);
      return;
    }

  /* Check for lock without a lockable instruction.  Destination operand
     must be memory unless it is xchg (0x86).  */
  if (i.prefix[LOCK_PREFIX]
      && (!i.tm.opcode_modifier.islockable
	  || i.mem_operands == 0
	  || (i.tm.base_opcode != 0x86
	      && !operand_type_check (i.types[i.operands - 1], anymem))))
    {
      as_bad (_("expecting lockable instruction after `lock'"));
      return;
    }

  /* Check if HLE prefix is OK.  */
  if (i.hle_prefix && !check_hle ())
    return;

  /* Check BND prefix.  */
  if (i.bnd_prefix && !i.tm.opcode_modifier.bndprefixok)
    as_bad (_("expecting valid branch instruction after `bnd'"));

  if (i.tm.cpu_flags.bitfield.cpumpx
      && flag_code == CODE_64BIT
      && i.prefix[ADDR_PREFIX])
    as_bad (_("32-bit address isn't allowed in 64-bit MPX instructions."));

  /* Insert BND prefix.  */
  if (add_bnd_prefix
      && i.tm.opcode_modifier.bndprefixok
      && !i.prefix[BND_PREFIX])
    add_prefix (BND_PREFIX_OPCODE);

  /* Check string instruction segment overrides.  */
  if (i.tm.opcode_modifier.isstring && i.mem_operands != 0)
    {
      if (!check_string ())
	return;
      i.disp_operands = 0;
    }

  if (!process_suffix ())
    return;

  /* Update operand types.  */
  for (j = 0; j < i.operands; j++)
    i.types[j] = operand_type_and (i.types[j], i.tm.operand_types[j]);

  /* Make still unresolved immediate matches conform to size of immediate
     given in i.suffix.  */
  if (!finalize_imm ())
    return;

  if (i.types[0].bitfield.imm1)
    i.imm_operands = 0;	/* kludge for shift insns.  */

  /* We only need to check those implicit registers for instructions
     with 3 operands or less.  */
  if (i.operands <= 3)
    for (j = 0; j < i.operands; j++)
      if (i.types[j].bitfield.inoutportreg
	  || i.types[j].bitfield.shiftcount
	  || i.types[j].bitfield.acc
	  || i.types[j].bitfield.floatacc)
	i.reg_operands--;

  /* ImmExt should be processed after SSE2AVX.  */
  if (!i.tm.opcode_modifier.sse2avx
      && i.tm.opcode_modifier.immext)
    process_immext ();

  /* For insns with operands there are more diddles to do to the opcode.  */
  if (i.operands)
    {
      if (!process_operands ())
	return;
    }
  else if (!quiet_warnings && i.tm.opcode_modifier.ugh)
    {
      /* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
      as_warn (_("translating to `%sp'"), i.tm.name);
    }

  if (i.tm.opcode_modifier.vex)
    build_vex_prefix (t);

  if (i.tm.opcode_modifier.evex)
    build_evex_prefix ();

  /* Handle conversion of 'int $3' --> special int3 insn.  XOP or FMA4
     instructions may define INT_OPCODE as well, so avoid this corner
     case for those instructions that use MODRM.  */
  if (i.tm.base_opcode == INT_OPCODE
      && !i.tm.opcode_modifier.modrm
      && i.op[0].imms->X_add_number == 3)
    {
      i.tm.base_opcode = INT3_OPCODE;
      i.imm_operands = 0;
    }

  if ((i.tm.opcode_modifier.jump
       || i.tm.opcode_modifier.jumpbyte
       || i.tm.opcode_modifier.jumpdword)
      && i.op[0].disps->X_op == O_constant)
    {
      /* Convert "jmp constant" (and "call constant") to a jump (call) to
	 the absolute address given by the constant.  Since ix86 jumps and
	 calls are pc relative, we need to generate a reloc.  */
      i.op[0].disps->X_add_symbol = &abs_symbol;
      i.op[0].disps->X_op = O_symbol;
    }

  if (i.tm.opcode_modifier.rex64)
    i.rex |= REX_W;

  /* For 8 bit registers we need an empty rex prefix.  Also if the
     instruction already has a prefix, we need to convert old
     registers to new ones.  */

  if ((i.types[0].bitfield.reg8
       && (i.op[0].regs->reg_flags & RegRex64) != 0)
      || (i.types[1].bitfield.reg8
	  && (i.op[1].regs->reg_flags & RegRex64) != 0)
      || ((i.types[0].bitfield.reg8
	   || i.types[1].bitfield.reg8)
	  && i.rex != 0))
    {
      int x;

      i.rex |= REX_OPCODE;
      for (x = 0; x < 2; x++)
	{
	  /* Look for 8 bit operand that uses old registers.  */
	  if (i.types[x].bitfield.reg8
	      && (i.op[x].regs->reg_flags & RegRex64) == 0)
	    {
	      /* In case it is "hi" register, give up.  */
	      if (i.op[x].regs->reg_num > 3)
		as_bad (_("can't encode register '%s%s' in an "
			  "instruction requiring REX prefix."),
			register_prefix, i.op[x].regs->reg_name);

	      /* Otherwise it is equivalent to the extended register.
		 Since the encoding doesn't change this is merely
		 cosmetic cleanup for debug output.  */

	      i.op[x].regs = i.op[x].regs + 8;
	    }
	}
    }

  if (i.rex != 0)
    add_prefix (REX_OPCODE | i.rex);

  /* We are ready to output the insn.  */
  output_insn ();
}

static char *
parse_insn (char *line, char *mnemonic)
{
  char *l = line;
  char *token_start = l;
  char *mnem_p;
  int supported;
  const insn_template *t;
  char *dot_p = NULL;

  while (1)
    {
      mnem_p = mnemonic;
      while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)
	{
	  if (*mnem_p == '.')
	    dot_p = mnem_p;
	  mnem_p++;
	  if (mnem_p >= mnemonic + MAX_MNEM_SIZE)
	    {
	      as_bad (_("no such instruction: `%s'"), token_start);
	      return NULL;
	    }
	  l++;
	}
      if (!is_space_char (*l)
	  && *l != END_OF_INSN
	  && (intel_syntax
	      || (*l != PREFIX_SEPARATOR
		  && *l != ',')))
	{
	  as_bad (_("invalid character %s in mnemonic"),
		  output_invalid (*l));
	  return NULL;
	}
      if (token_start == l)
	{
	  if (!intel_syntax && *l == PREFIX_SEPARATOR)
	    as_bad (_("expecting prefix; got nothing"));
	  else
	    as_bad (_("expecting mnemonic; got nothing"));
	  return NULL;
	}

      /* Look up instruction (or prefix) via hash table.  */
      current_templates = (const templates *) hash_find (op_hash, mnemonic);

      if (*l != END_OF_INSN
	  && (!is_space_char (*l) || l[1] != END_OF_INSN)
	  && current_templates
	  && current_templates->start->opcode_modifier.isprefix)
	{
	  if (!cpu_flags_check_cpu64 (current_templates->start->cpu_flags))
	    {
	      as_bad ((flag_code != CODE_64BIT
		       ? _("`%s' is only supported in 64-bit mode")
		       : _("`%s' is not supported in 64-bit mode")),
		      current_templates->start->name);
	      return NULL;
	    }
	  /* If we are in 16-bit mode, do not allow addr16 or data16.
	     Similarly, in 32-bit mode, do not allow addr32 or data32.  */
	  if ((current_templates->start->opcode_modifier.size16
	       || current_templates->start->opcode_modifier.size32)
	      && flag_code != CODE_64BIT
	      && (current_templates->start->opcode_modifier.size32
		  ^ (flag_code == CODE_16BIT)))
	    {
	      as_bad (_("redundant %s prefix"),
		      current_templates->start->name);
	      return NULL;
	    }
	  /* Add prefix, checking for repeated prefixes.  */
	  switch (add_prefix (current_templates->start->base_opcode))
	    {
	    case PREFIX_EXIST:
	      return NULL;
	    case PREFIX_REP:
	      if (current_templates->start->cpu_flags.bitfield.cpuhle)
		i.hle_prefix = current_templates->start->name;
	      else if (current_templates->start->cpu_flags.bitfield.cpumpx)
		i.bnd_prefix = current_templates->start->name;
	      else
		i.rep_prefix = current_templates->start->name;
	      break;
	    default:
	      break;
	    }
	  /* Skip past PREFIX_SEPARATOR and reset token_start.  */
	  token_start = ++l;
	}
      else
	break;
    }

  if (!current_templates)
    {
      /* Check if we should swap operand or force 32bit displacement in
	 encoding.  */
      if (mnem_p - 2 == dot_p && dot_p[1] == 's')
	i.swap_operand = 1;
      else if (mnem_p - 3 == dot_p
	       && dot_p[1] == 'd'
	       && dot_p[2] == '8')
	i.disp_encoding = disp_encoding_8bit;
      else if (mnem_p - 4 == dot_p
	       && dot_p[1] == 'd'
	       && dot_p[2] == '3'
	       && dot_p[3] == '2')
	i.disp_encoding = disp_encoding_32bit;
      else
	goto check_suffix;
      mnem_p = dot_p;
      *dot_p = '\0';
      current_templates = (const templates *) hash_find (op_hash, mnemonic);
    }

  if (!current_templates)
    {
check_suffix:
      /* See if we can get a match by trimming off a suffix.  */
      switch (mnem_p[-1])
	{
	case WORD_MNEM_SUFFIX:
	  if (intel_syntax && (intel_float_operand (mnemonic) & 2))
	    i.suffix = SHORT_MNEM_SUFFIX;
	  else
	case BYTE_MNEM_SUFFIX:
	case QWORD_MNEM_SUFFIX:
	  i.suffix = mnem_p[-1];
	  mnem_p[-1] = '\0';
	  current_templates = (const templates *) hash_find (op_hash,
                                                             mnemonic);
	  break;
	case SHORT_MNEM_SUFFIX:
	case LONG_MNEM_SUFFIX:
	  if (!intel_syntax)
	    {
	      i.suffix = mnem_p[-1];
	      mnem_p[-1] = '\0';
	      current_templates = (const templates *) hash_find (op_hash,
                                                                 mnemonic);
	    }
	  break;

	  /* Intel Syntax.  */
	case 'd':
	  if (intel_syntax)
	    {
	      if (intel_float_operand (mnemonic) == 1)
		i.suffix = SHORT_MNEM_SUFFIX;
	      else
		i.suffix = LONG_MNEM_SUFFIX;
	      mnem_p[-1] = '\0';
	      current_templates = (const templates *) hash_find (op_hash,
                                                                 mnemonic);
	    }
	  break;
	}
      if (!current_templates)
	{
	  as_bad (_("no such instruction: `%s'"), token_start);
	  return NULL;
	}
    }

  if (current_templates->start->opcode_modifier.jump
      || current_templates->start->opcode_modifier.jumpbyte)
    {
      /* Check for a branch hint.  We allow ",pt" and ",pn" for
	 predict taken and predict not taken respectively.
	 I'm not sure that branch hints actually do anything on loop
	 and jcxz insns (JumpByte) for current Pentium4 chips.  They
	 may work in the future and it doesn't hurt to accept them
	 now.  */
      if (l[0] == ',' && l[1] == 'p')
	{
	  if (l[2] == 't')
	    {
	      if (!add_prefix (DS_PREFIX_OPCODE))
		return NULL;
	      l += 3;
	    }
	  else if (l[2] == 'n')
	    {
	      if (!add_prefix (CS_PREFIX_OPCODE))
		return NULL;
	      l += 3;
	    }
	}
    }
  /* Any other comma loses.  */
  if (*l == ',')
    {
      as_bad (_("invalid character %s in mnemonic"),
	      output_invalid (*l));
      return NULL;
    }

  /* Check if instruction is supported on specified architecture.  */
  supported = 0;
  for (t = current_templates->start; t < current_templates->end; ++t)
    {
      supported |= cpu_flags_match (t);
      if (supported == CPU_FLAGS_PERFECT_MATCH)
	goto skip;
    }

  if (!(supported & CPU_FLAGS_64BIT_MATCH))
    {
      as_bad (flag_code == CODE_64BIT
	      ? _("`%s' is not supported in 64-bit mode")
	      : _("`%s' is only supported in 64-bit mode"),
	      current_templates->start->name);
      return NULL;
    }
  if (supported != CPU_FLAGS_PERFECT_MATCH)
    {
      as_bad (_("`%s' is not supported on `%s%s'"),
	      current_templates->start->name,
	      cpu_arch_name ? cpu_arch_name : default_arch,
	      cpu_sub_arch_name ? cpu_sub_arch_name : "");
      return NULL;
    }

skip:
  if (!cpu_arch_flags.bitfield.cpui386
	   && (flag_code != CODE_16BIT))
    {
      as_warn (_("use .code16 to ensure correct addressing mode"));
    }

  return l;
}

static char *
parse_operands (char *l, const char *mnemonic)
{
  char *token_start;

  /* 1 if operand is pending after ','.  */
  unsigned int expecting_operand = 0;

  /* Non-zero if operand parens not balanced.  */
  unsigned int paren_not_balanced;

  while (*l != END_OF_INSN)
    {
      /* Skip optional white space before operand.  */
      if (is_space_char (*l))
	++l;
      if (!is_operand_char (*l) && *l != END_OF_INSN)
	{
	  as_bad (_("invalid character %s before operand %d"),
		  output_invalid (*l),
		  i.operands + 1);
	  return NULL;
	}
      token_start = l;	/* after white space */
      paren_not_balanced = 0;
      while (paren_not_balanced || *l != ',')
	{
	  if (*l == END_OF_INSN)
	    {
	      if (paren_not_balanced)
		{
		  if (!intel_syntax)
		    as_bad (_("unbalanced parenthesis in operand %d."),
			    i.operands + 1);
		  else
		    as_bad (_("unbalanced brackets in operand %d."),
			    i.operands + 1);
		  return NULL;
		}
	      else
		break;	/* we are done */
	    }
	  else if (!is_operand_char (*l) && !is_space_char (*l))
	    {
	      as_bad (_("invalid character %s in operand %d"),
		      output_invalid (*l),
		      i.operands + 1);
	      return NULL;
	    }
	  if (!intel_syntax)
	    {
	      if (*l == '(')
		++paren_not_balanced;
	      if (*l == ')')
		--paren_not_balanced;
	    }
	  else
	    {
	      if (*l == '[')
		++paren_not_balanced;
	      if (*l == ']')
		--paren_not_balanced;
	    }
	  l++;
	}
      if (l != token_start)
	{			/* Yes, we've read in another operand.  */
	  unsigned int operand_ok;
	  this_operand = i.operands++;
	  i.types[this_operand].bitfield.unspecified = 1;
	  if (i.operands > MAX_OPERANDS)
	    {
	      as_bad (_("spurious operands; (%d operands/instruction max)"),
		      MAX_OPERANDS);
	      return NULL;
	    }
	  /* Now parse operand adding info to 'i' as we go along.  */
	  END_STRING_AND_SAVE (l);

	  if (intel_syntax)
	    operand_ok =
	      i386_intel_operand (token_start,
				  intel_float_operand (mnemonic));
	  else
	    operand_ok = i386_att_operand (token_start);

	  RESTORE_END_STRING (l);
	  if (!operand_ok)
	    return NULL;
	}
      else
	{
	  if (expecting_operand)
	    {
	    expecting_operand_after_comma:
	      as_bad (_("expecting operand after ','; got nothing"));
	      return NULL;
	    }
	  if (*l == ',')
	    {
	      as_bad (_("expecting operand before ','; got nothing"));
	      return NULL;
	    }
	}

      /* Now *l must be either ',' or END_OF_INSN.  */
      if (*l == ',')
	{
	  if (*++l == END_OF_INSN)
	    {
	      /* Just skip it, if it's \n complain.  */
	      goto expecting_operand_after_comma;
	    }
	  expecting_operand = 1;
	}
    }
  return l;
}

static void
swap_2_operands (int xchg1, int xchg2)
{
  union i386_op temp_op;
  i386_operand_type temp_type;
  enum bfd_reloc_code_real temp_reloc;

  temp_type = i.types[xchg2];
  i.types[xchg2] = i.types[xchg1];
  i.types[xchg1] = temp_type;
  temp_op = i.op[xchg2];
  i.op[xchg2] = i.op[xchg1];
  i.op[xchg1] = temp_op;
  temp_reloc = i.reloc[xchg2];
  i.reloc[xchg2] = i.reloc[xchg1];
  i.reloc[xchg1] = temp_reloc;

  if (i.mask)
    {
      if (i.mask->operand == xchg1)
	i.mask->operand = xchg2;
      else if (i.mask->operand == xchg2)
	i.mask->operand = xchg1;
    }
  if (i.broadcast)
    {
      if (i.broadcast->operand == xchg1)
	i.broadcast->operand = xchg2;
      else if (i.broadcast->operand == xchg2)
	i.broadcast->operand = xchg1;
    }
  if (i.rounding)
    {
      if (i.rounding->operand == xchg1)
	i.rounding->operand = xchg2;
      else if (i.rounding->operand == xchg2)
	i.rounding->operand = xchg1;
    }
}

static void
swap_operands (void)
{
  switch (i.operands)
    {
    case 5:
    case 4:
      swap_2_operands (1, i.operands - 2);
    case 3:
    case 2:
      swap_2_operands (0, i.operands - 1);
      break;
    default:
      abort ();
    }

  if (i.mem_operands == 2)
    {
      const seg_entry *temp_seg;
      temp_seg = i.seg[0];
      i.seg[0] = i.seg[1];
      i.seg[1] = temp_seg;
    }
}

/* Try to ensure constant immediates are represented in the smallest
   opcode possible.  */
static void
optimize_imm (void)
{
  char guess_suffix = 0;
  int op;

  if (i.suffix)
    guess_suffix = i.suffix;
  else if (i.reg_operands)
    {
      /* Figure out a suffix from the last register operand specified.
	 We can't do this properly yet, ie. excluding InOutPortReg,
	 but the following works for instructions with immediates.
	 In any case, we can't set i.suffix yet.  */
      for (op = i.operands; --op >= 0;)
	if (i.types[op].bitfield.reg8)
	  {
	    guess_suffix = BYTE_MNEM_SUFFIX;
	    break;
	  }
	else if (i.types[op].bitfield.reg16)
	  {
	    guess_suffix = WORD_MNEM_SUFFIX;
	    break;
	  }
	else if (i.types[op].bitfield.reg32)
	  {
	    guess_suffix = LONG_MNEM_SUFFIX;
	    break;
	  }
	else if (i.types[op].bitfield.reg64)
	  {
	    guess_suffix = QWORD_MNEM_SUFFIX;
	    break;
	  }
    }
  else if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
    guess_suffix = WORD_MNEM_SUFFIX;

  for (op = i.operands; --op >= 0;)
    if (operand_type_check (i.types[op], imm))
      {
	switch (i.op[op].imms->X_op)
	  {
	  case O_constant:
	    /* If a suffix is given, this operand may be shortened.  */
	    switch (guess_suffix)
	      {
	      case LONG_MNEM_SUFFIX:
		i.types[op].bitfield.imm32 = 1;
		i.types[op].bitfield.imm64 = 1;
		break;
	      case WORD_MNEM_SUFFIX:
		i.types[op].bitfield.imm16 = 1;
		i.types[op].bitfield.imm32 = 1;
		i.types[op].bitfield.imm32s = 1;
		i.types[op].bitfield.imm64 = 1;
		break;
	      case BYTE_MNEM_SUFFIX:
		i.types[op].bitfield.imm8 = 1;
		i.types[op].bitfield.imm8s = 1;
		i.types[op].bitfield.imm16 = 1;
		i.types[op].bitfield.imm32 = 1;
		i.types[op].bitfield.imm32s = 1;
		i.types[op].bitfield.imm64 = 1;
		break;
	      }

	    /* If this operand is at most 16 bits, convert it
	       to a signed 16 bit number before trying to see
	       whether it will fit in an even smaller size.
	       This allows a 16-bit operand such as $0xffe0 to
	       be recognised as within Imm8S range.  */
	    if ((i.types[op].bitfield.imm16)
		&& (i.op[op].imms->X_add_number & ~(offsetT) 0xffff) == 0)
	      {
		i.op[op].imms->X_add_number =
		  (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
	      }
	    if ((i.types[op].bitfield.imm32)
		&& ((i.op[op].imms->X_add_number & ~(((offsetT) 2 << 31) - 1))
		    == 0))
	      {
		i.op[op].imms->X_add_number = ((i.op[op].imms->X_add_number
						^ ((offsetT) 1 << 31))
					       - ((offsetT) 1 << 31));
	      }
	    i.types[op]
	      = operand_type_or (i.types[op],
				 smallest_imm_type (i.op[op].imms->X_add_number));

	    /* We must avoid matching of Imm32 templates when 64bit
	       only immediate is available.  */
	    if (guess_suffix == QWORD_MNEM_SUFFIX)
	      i.types[op].bitfield.imm32 = 0;
	    break;

	  case O_absent:
	  case O_register:
	    abort ();

	    /* Symbols and expressions.  */
	  default:
	    /* Convert symbolic operand to proper sizes for matching, but don't
	       prevent matching a set of insns that only supports sizes other
	       than those matching the insn suffix.  */
	    {
	      i386_operand_type mask, allowed;
	      const insn_template *t;

	      operand_type_set (&mask, 0);
	      operand_type_set (&allowed, 0);

	      for (t = current_templates->start;
		   t < current_templates->end;
		   ++t)
		allowed = operand_type_or (allowed,
					   t->operand_types[op]);
	      switch (guess_suffix)
		{
		case QWORD_MNEM_SUFFIX:
		  mask.bitfield.imm64 = 1;
		  mask.bitfield.imm32s = 1;
		  break;
		case LONG_MNEM_SUFFIX:
		  mask.bitfield.imm32 = 1;
		  break;
		case WORD_MNEM_SUFFIX:
		  mask.bitfield.imm16 = 1;
		  break;
		case BYTE_MNEM_SUFFIX:
		  mask.bitfield.imm8 = 1;
		  break;
		default:
		  break;
		}
	      allowed = operand_type_and (mask, allowed);
	      if (!operand_type_all_zero (&allowed))
		i.types[op] = operand_type_and (i.types[op], mask);
	    }
	    break;
	  }
      }
}

/* Try to use the smallest displacement type too.  */
static void
optimize_disp (void)
{
  int op;

  for (op = i.operands; --op >= 0;)
    if (operand_type_check (i.types[op], disp))
      {
	if (i.op[op].disps->X_op == O_constant)
	  {
	    offsetT op_disp = i.op[op].disps->X_add_number;

	    if (i.types[op].bitfield.disp16
		&& (op_disp & ~(offsetT) 0xffff) == 0)
	      {
		/* If this operand is at most 16 bits, convert
		   to a signed 16 bit number and don't use 64bit
		   displacement.  */
		op_disp = (((op_disp & 0xffff) ^ 0x8000) - 0x8000);
		i.types[op].bitfield.disp64 = 0;
	      }
	    if (i.types[op].bitfield.disp32
		&& (op_disp & ~(((offsetT) 2 << 31) - 1)) == 0)
	      {
		/* If this operand is at most 32 bits, convert
		   to a signed 32 bit number and don't use 64bit
		   displacement.  */
		op_disp &= (((offsetT) 2 << 31) - 1);
		op_disp = (op_disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
		i.types[op].bitfield.disp64 = 0;
	      }
	    if (!op_disp && i.types[op].bitfield.baseindex)
	      {
		i.types[op].bitfield.disp8 = 0;
		i.types[op].bitfield.disp16 = 0;
		i.types[op].bitfield.disp32 = 0;
		i.types[op].bitfield.disp32s = 0;
		i.types[op].bitfield.disp64 = 0;
		i.op[op].disps = 0;
		i.disp_operands--;
	      }
	    else if (flag_code == CODE_64BIT)
	      {
		if (fits_in_signed_long (op_disp))
		  {
		    i.types[op].bitfield.disp64 = 0;
		    i.types[op].bitfield.disp32s = 1;
		  }
		if (i.prefix[ADDR_PREFIX]
		    && fits_in_unsigned_long (op_disp))
		  i.types[op].bitfield.disp32 = 1;
	      }
	    if ((i.types[op].bitfield.disp32
		 || i.types[op].bitfield.disp32s
		 || i.types[op].bitfield.disp16)
		&& fits_in_signed_byte (op_disp))
	      i.types[op].bitfield.disp8 = 1;
	  }
	else if (i.reloc[op] == BFD_RELOC_386_TLS_DESC_CALL
		 || i.reloc[op] == BFD_RELOC_X86_64_TLSDESC_CALL)
	  {
	    fix_new_exp (frag_now, frag_more (0) - frag_now->fr_literal, 0,
			 i.op[op].disps, 0, i.reloc[op]);
	    i.types[op].bitfield.disp8 = 0;
	    i.types[op].bitfield.disp16 = 0;
	    i.types[op].bitfield.disp32 = 0;
	    i.types[op].bitfield.disp32s = 0;
	    i.types[op].bitfield.disp64 = 0;
	  }
 	else
	  /* We only support 64bit displacement on constants.  */
	  i.types[op].bitfield.disp64 = 0;
      }
}

/* Check if operands are valid for the instruction.  */

static int
check_VecOperands (const insn_template *t)
{
  unsigned int op;

  /* Without VSIB byte, we can't have a vector register for index.  */
  if (!t->opcode_modifier.vecsib
      && i.index_reg
      && (i.index_reg->reg_type.bitfield.regxmm
	  || i.index_reg->reg_type.bitfield.regymm
	  || i.index_reg->reg_type.bitfield.regzmm))
    {
      i.error = unsupported_vector_index_register;
      return 1;
    }

  /* For VSIB byte, we need a vector register for index, and all vector
     registers must be distinct.  */
  if (t->opcode_modifier.vecsib)
    {
      if (!i.index_reg
	  || !((t->opcode_modifier.vecsib == VecSIB128
		&& i.index_reg->reg_type.bitfield.regxmm)
	       || (t->opcode_modifier.vecsib == VecSIB256
		   && i.index_reg->reg_type.bitfield.regymm)
	       || (t->opcode_modifier.vecsib == VecSIB512
		   && i.index_reg->reg_type.bitfield.regzmm)))
      {
	i.error = invalid_vsib_address;
	return 1;
      }

      gas_assert (i.reg_operands == 2 || i.mask);
      if (i.reg_operands == 2 && !i.mask)
	{
	  gas_assert (i.types[0].bitfield.regxmm
		      || i.types[0].bitfield.regymm
		      || i.types[0].bitfield.regzmm);
	  gas_assert (i.types[2].bitfield.regxmm
		      || i.types[2].bitfield.regymm
		      || i.types[2].bitfield.regzmm);
	  if (operand_check == check_none)
	    return 0;
	  if (register_number (i.op[0].regs)
	      != register_number (i.index_reg)
	      && register_number (i.op[2].regs)
		 != register_number (i.index_reg)
	      && register_number (i.op[0].regs)
		 != register_number (i.op[2].regs))
	    return 0;
	  if (operand_check == check_error)
	    {
	      i.error = invalid_vector_register_set;
	      return 1;
	    }
	  as_warn (_("mask, index, and destination registers should be distinct"));
	}
    }

  /* Check if broadcast is supported by the instruction and is applied
     to the memory operand.  */
  if (i.broadcast)
    {
      int broadcasted_opnd_size;

      /* Check if specified broadcast is supported in this instruction,
	 and it's applied to memory operand of DWORD or QWORD type,
	 depending on VecESize.  */
      if (i.broadcast->type != t->opcode_modifier.broadcast
	  || !i.types[i.broadcast->operand].bitfield.mem
	  || (t->opcode_modifier.vecesize == 0
	      && !i.types[i.broadcast->operand].bitfield.dword
	      && !i.types[i.broadcast->operand].bitfield.unspecified)
	  || (t->opcode_modifier.vecesize == 1
	      && !i.types[i.broadcast->operand].bitfield.qword
	      && !i.types[i.broadcast->operand].bitfield.unspecified))
	goto bad_broadcast;

      broadcasted_opnd_size = t->opcode_modifier.vecesize ? 64 : 32;
      if (i.broadcast->type == BROADCAST_1TO16)
	broadcasted_opnd_size <<= 4; /* Broadcast 1to16.  */
      else if (i.broadcast->type == BROADCAST_1TO8)
	broadcasted_opnd_size <<= 3; /* Broadcast 1to8.  */
      else
	goto bad_broadcast;

      if ((broadcasted_opnd_size == 256
	   && !t->operand_types[i.broadcast->operand].bitfield.ymmword)
	  || (broadcasted_opnd_size == 512
	      && !t->operand_types[i.broadcast->operand].bitfield.zmmword))
	{
	bad_broadcast:
	  i.error = unsupported_broadcast;
	  return 1;
	}
    }
  /* If broadcast is supported in this instruction, we need to check if
     operand of one-element size isn't specified without broadcast.  */
  else if (t->opcode_modifier.broadcast && i.mem_operands)
    {
      /* Find memory operand.  */
      for (op = 0; op < i.operands; op++)
	if (operand_type_check (i.types[op], anymem))
	  break;
      gas_assert (op < i.operands);
      /* Check size of the memory operand.  */
      if ((t->opcode_modifier.vecesize == 0
	   && i.types[op].bitfield.dword)
	  || (t->opcode_modifier.vecesize == 1
	      && i.types[op].bitfield.qword))
	{
	  i.error = broadcast_needed;
	  return 1;
	}
    }

  /* Check if requested masking is supported.  */
  if (i.mask
      && (!t->opcode_modifier.masking
	  || (i.mask->zeroing
	      && t->opcode_modifier.masking == MERGING_MASKING)))
    {
      i.error = unsupported_masking;
      return 1;
    }

  /* Check if masking is applied to dest operand.  */
  if (i.mask && (i.mask->operand != (int) (i.operands - 1)))
    {
      i.error = mask_not_on_destination;
      return 1;
    }

  /* Check if default mask is allowed.  */
  if (t->opcode_modifier.nodefmask
      && (!i.mask || i.mask->mask->reg_num == 0))
    {
      i.error = no_default_mask;
      return 1;
    }

  /* Check RC/SAE.  */
  if (i.rounding)
    {
      if ((i.rounding->type != saeonly
	   && !t->opcode_modifier.staticrounding)
	  || (i.rounding->type == saeonly
	      && (t->opcode_modifier.staticrounding
		  || !t->opcode_modifier.sae)))
	{
	  i.error = unsupported_rc_sae;
	  return 1;
	}
      /* If the instruction has several immediate operands and one of
	 them is rounding, the rounding operand should be the last
	 immediate operand.  */
      if (i.imm_operands > 1
	  && i.rounding->operand != (int) (i.imm_operands - 1))
	{
	  i.error = rc_sae_operand_not_last_imm;
	  return 1;
	}
    }

  /* Check vector Disp8 operand.  */
  if (t->opcode_modifier.disp8memshift)
    {
      if (i.broadcast)
	i.memshift = t->opcode_modifier.vecesize ? 3 : 2;
      else
	i.memshift = t->opcode_modifier.disp8memshift;

      for (op = 0; op < i.operands; op++)
	if (operand_type_check (i.types[op], disp)
	    && i.op[op].disps->X_op == O_constant)
	  {
	    offsetT value = i.op[op].disps->X_add_number;
	    int vec_disp8_ok = fits_in_vec_disp8 (value);
	    if (t->operand_types [op].bitfield.vec_disp8)
	      {
		if (vec_disp8_ok)
		  i.types[op].bitfield.vec_disp8 = 1;
		else
		  {
		    /* Vector insn can only have Vec_Disp8/Disp32 in
		       32/64bit modes, and Vec_Disp8/Disp16 in 16bit
		       mode.  */
		    i.types[op].bitfield.disp8 = 0;
		    if (flag_code != CODE_16BIT)
		      i.types[op].bitfield.disp16 = 0;
		  }
	      }
	    else if (flag_code != CODE_16BIT)
	      {
		/* One form of this instruction supports vector Disp8.
		   Try vector Disp8 if we need to use Disp32.  */
		if (vec_disp8_ok && !fits_in_signed_byte (value))
		  {
		    i.error = try_vector_disp8;
		    return 1;
		  }
	      }
	  }
    }
  else
    i.memshift = -1;

  return 0;
}

/* Check if operands are valid for the instruction.  Update VEX
   operand types.  */

static int
VEX_check_operands (const insn_template *t)
{
  /* VREX is only valid with EVEX prefix.  */
  if (i.need_vrex && !t->opcode_modifier.evex)
    {
      i.error = invalid_register_operand;
      return 1;
    }

  if (!t->opcode_modifier.vex)
    return 0;

  /* Only check VEX_Imm4, which must be the first operand.  */
  if (t->operand_types[0].bitfield.vec_imm4)
    {
      if (i.op[0].imms->X_op != O_constant
	  || !fits_in_imm4 (i.op[0].imms->X_add_number))
	{
	  i.error = bad_imm4;
	  return 1;
	}

      /* Turn off Imm8 so that update_imm won't complain.  */
      i.types[0] = vec_imm4;
    }

  return 0;
}

static const insn_template *
match_template (void)
{
  /* Points to template once we've found it.  */
  const insn_template *t;
  i386_operand_type overlap0, overlap1, overlap2, overlap3;
  i386_operand_type overlap4;
  unsigned int found_reverse_match;
  i386_opcode_modifier suffix_check;
  i386_operand_type operand_types [MAX_OPERANDS];
  int addr_prefix_disp;
  unsigned int j;
  unsigned int found_cpu_match;
  unsigned int check_register;
  enum i386_error specific_error = 0;

#if MAX_OPERANDS != 5
# error "MAX_OPERANDS must be 5."
#endif

  found_reverse_match = 0;
  addr_prefix_disp = -1;

  memset (&suffix_check, 0, sizeof (suffix_check));
  if (i.suffix == BYTE_MNEM_SUFFIX)
    suffix_check.no_bsuf = 1;
  else if (i.suffix == WORD_MNEM_SUFFIX)
    suffix_check.no_wsuf = 1;
  else if (i.suffix == SHORT_MNEM_SUFFIX)
    suffix_check.no_ssuf = 1;
  else if (i.suffix == LONG_MNEM_SUFFIX)
    suffix_check.no_lsuf = 1;
  else if (i.suffix == QWORD_MNEM_SUFFIX)
    suffix_check.no_qsuf = 1;
  else if (i.suffix == LONG_DOUBLE_MNEM_SUFFIX)
    suffix_check.no_ldsuf = 1;

  /* Must have right number of operands.  */
  i.error = number_of_operands_mismatch;

  for (t = current_templates->start; t < current_templates->end; t++)
    {
      addr_prefix_disp = -1;

      if (i.operands != t->operands)
	continue;

      /* Check processor support.  */
      i.error = unsupported;
      found_cpu_match = (cpu_flags_match (t)
			 == CPU_FLAGS_PERFECT_MATCH);
      if (!found_cpu_match)
	continue;

      /* Check old gcc support. */
      i.error = old_gcc_only;
      if (!old_gcc && t->opcode_modifier.oldgcc)
	continue;

      /* Check AT&T mnemonic.   */
      i.error = unsupported_with_intel_mnemonic;
      if (intel_mnemonic && t->opcode_modifier.attmnemonic)
	continue;

      /* Check AT&T/Intel syntax.   */
      i.error = unsupported_syntax;
      if ((intel_syntax && t->opcode_modifier.attsyntax)
	  || (!intel_syntax && t->opcode_modifier.intelsyntax))
	continue;

      /* Check the suffix, except for some instructions in intel mode.  */
      i.error = invalid_instruction_suffix;
      if ((!intel_syntax || !t->opcode_modifier.ignoresize)
	  && ((t->opcode_modifier.no_bsuf && suffix_check.no_bsuf)
	      || (t->opcode_modifier.no_wsuf && suffix_check.no_wsuf)
	      || (t->opcode_modifier.no_lsuf && suffix_check.no_lsuf)
	      || (t->opcode_modifier.no_ssuf && suffix_check.no_ssuf)
	      || (t->opcode_modifier.no_qsuf && suffix_check.no_qsuf)
	      || (t->opcode_modifier.no_ldsuf && suffix_check.no_ldsuf)))
	continue;

      if (!operand_size_match (t))
	continue;

      for (j = 0; j < MAX_OPERANDS; j++)
	operand_types[j] = t->operand_types[j];

      /* In general, don't allow 64-bit operands in 32-bit mode.  */
      if (i.suffix == QWORD_MNEM_SUFFIX
	  && flag_code != CODE_64BIT
	  && (intel_syntax
	      ? (!t->opcode_modifier.ignoresize
		 && !intel_float_operand (t->name))
	      : intel_float_operand (t->name) != 2)
	  && ((!operand_types[0].bitfield.regmmx
	       && !operand_types[0].bitfield.regxmm
	       && !operand_types[0].bitfield.regymm
	       && !operand_types[0].bitfield.regzmm)
	      || (!operand_types[t->operands > 1].bitfield.regmmx
		  && !!operand_types[t->operands > 1].bitfield.regxmm
		  && !!operand_types[t->operands > 1].bitfield.regymm
		  && !!operand_types[t->operands > 1].bitfield.regzmm))
	  && (t->base_opcode != 0x0fc7
	      || t->extension_opcode != 1 /* cmpxchg8b */))
	continue;

      /* In general, don't allow 32-bit operands on pre-386.  */
      else if (i.suffix == LONG_MNEM_SUFFIX
	       && !cpu_arch_flags.bitfield.cpui386
	       && (intel_syntax
		   ? (!t->opcode_modifier.ignoresize
		      && !intel_float_operand (t->name))
		   : intel_float_operand (t->name) != 2)
	       && ((!operand_types[0].bitfield.regmmx
		    && !operand_types[0].bitfield.regxmm)
		   || (!operand_types[t->operands > 1].bitfield.regmmx
		       && !!operand_types[t->operands > 1].bitfield.regxmm)))
	continue;

      /* Do not verify operands when there are none.  */
      else
	{
	  if (!t->operands)
	    /* We've found a match; break out of loop.  */
	    break;
	}

      /* Address size prefix will turn Disp64/Disp32/Disp16 operand
	 into Disp32/Disp16/Disp32 operand.  */
      if (i.prefix[ADDR_PREFIX] != 0)
	  {
	    /* There should be only one Disp operand.  */
	    switch (flag_code)
	    {
	    case CODE_16BIT:
	      for (j = 0; j < MAX_OPERANDS; j++)
		{
		  if (operand_types[j].bitfield.disp16)
		    {
		      addr_prefix_disp = j;
		      operand_types[j].bitfield.disp32 = 1;
		      operand_types[j].bitfield.disp16 = 0;
		      break;
		    }
		}
	      break;
	    case CODE_32BIT:
	      for (j = 0; j < MAX_OPERANDS; j++)
		{
		  if (operand_types[j].bitfield.disp32)
		    {
		      addr_prefix_disp = j;
		      operand_types[j].bitfield.disp32 = 0;
		      operand_types[j].bitfield.disp16 = 1;
		      break;
		    }
		}
	      break;
	    case CODE_64BIT:
	      for (j = 0; j < MAX_OPERANDS; j++)
		{
		  if (operand_types[j].bitfield.disp64)
		    {
		      addr_prefix_disp = j;
		      operand_types[j].bitfield.disp64 = 0;
		      operand_types[j].bitfield.disp32 = 1;
		      break;
		    }
		}
	      break;
	    }
	  }

      /* We check register size if needed.  */
      check_register = t->opcode_modifier.checkregsize;
      overlap0 = operand_type_and (i.types[0], operand_types[0]);
      switch (t->operands)
	{
	case 1:
	  if (!operand_type_match (overlap0, i.types[0]))
	    continue;
	  break;
	case 2:
	  /* xchg %eax, %eax is a special case. It is an aliase for nop
	     only in 32bit mode and we can use opcode 0x90.  In 64bit
	     mode, we can't use 0x90 for xchg %eax, %eax since it should
	     zero-extend %eax to %rax.  */
	  if (flag_code == CODE_64BIT
	      && t->base_opcode == 0x90
	      && operand_type_equal (&i.types [0], &acc32)
	      && operand_type_equal (&i.types [1], &acc32))
	    continue;
	  if (i.swap_operand)
	    {
	      /* If we swap operand in encoding, we either match
		 the next one or reverse direction of operands.  */
	      if (t->opcode_modifier.s)
		continue;
	      else if (t->opcode_modifier.d)
		goto check_reverse;
	    }

	case 3:
	  /* If we swap operand in encoding, we match the next one.  */
	  if (i.swap_operand && t->opcode_modifier.s)
	    continue;
	case 4:
	case 5:
	  overlap1 = operand_type_and (i.types[1], operand_types[1]);
	  if (!operand_type_match (overlap0, i.types[0])
	      || !operand_type_match (overlap1, i.types[1])
	      || (check_register
		  && !operand_type_register_match (overlap0, i.types[0],
						   operand_types[0],
						   overlap1, i.types[1],
						   operand_types[1])))
	    {
	      /* Check if other direction is valid ...  */
	      if (!t->opcode_modifier.d && !t->opcode_modifier.floatd)
		continue;

check_reverse:
	      /* Try reversing direction of operands.  */
	      overlap0 = operand_type_and (i.types[0], operand_types[1]);
	      overlap1 = operand_type_and (i.types[1], operand_types[0]);
	      if (!operand_type_match (overlap0, i.types[0])
		  || !operand_type_match (overlap1, i.types[1])
		  || (check_register
		      && !operand_type_register_match (overlap0,
						       i.types[0],
						       operand_types[1],
						       overlap1,
						       i.types[1],
						       operand_types[0])))
		{
		  /* Does not match either direction.  */
		  continue;
		}
	      /* found_reverse_match holds which of D or FloatDR
		 we've found.  */
	      if (t->opcode_modifier.d)
		found_reverse_match = Opcode_D;
	      else if (t->opcode_modifier.floatd)
		found_reverse_match = Opcode_FloatD;
	      else
		found_reverse_match = 0;
	      if (t->opcode_modifier.floatr)
		found_reverse_match |= Opcode_FloatR;
	    }
	  else
	    {
	      /* Found a forward 2 operand match here.  */
	      switch (t->operands)
		{
		case 5:
		  overlap4 = operand_type_and (i.types[4],
					       operand_types[4]);
		case 4:
		  overlap3 = operand_type_and (i.types[3],
					       operand_types[3]);
		case 3:
		  overlap2 = operand_type_and (i.types[2],
					       operand_types[2]);
		  break;
		}

	      switch (t->operands)
		{
		case 5:
		  if (!operand_type_match (overlap4, i.types[4])
		      || !operand_type_register_match (overlap3,
						       i.types[3],
						       operand_types[3],
						       overlap4,
						       i.types[4],
						       operand_types[4]))
		    continue;
		case 4:
		  if (!operand_type_match (overlap3, i.types[3])
		      || (check_register
			  && !operand_type_register_match (overlap2,
							   i.types[2],
							   operand_types[2],
							   overlap3,
							   i.types[3],
							   operand_types[3])))
		    continue;
		case 3:
		  /* Here we make use of the fact that there are no
		     reverse match 3 operand instructions, and all 3
		     operand instructions only need to be checked for
		     register consistency between operands 2 and 3.  */
		  if (!operand_type_match (overlap2, i.types[2])
		      || (check_register
			  && !operand_type_register_match (overlap1,
							   i.types[1],
							   operand_types[1],
							   overlap2,
							   i.types[2],
							   operand_types[2])))
		    continue;
		  break;
		}
	    }
	  /* Found either forward/reverse 2, 3 or 4 operand match here:
	     slip through to break.  */
	}
      if (!found_cpu_match)
	{
	  found_reverse_match = 0;
	  continue;
	}

      /* Check if vector and VEX operands are valid.  */
      if (check_VecOperands (t) || VEX_check_operands (t))
	{
	  specific_error = i.error;
	  continue;
	}

      /* We've found a match; break out of loop.  */
      break;
    }

  if (t == current_templates->end)
    {
      /* We found no match.  */
      const char *err_msg;
      switch (specific_error ? specific_error : i.error)
	{
	default:
	  abort ();
	case operand_size_mismatch:
	  err_msg = _("operand size mismatch");
	  break;
	case operand_type_mismatch:
	  err_msg = _("operand type mismatch");
	  break;
	case register_type_mismatch:
	  err_msg = _("register type mismatch");
	  break;
	case number_of_operands_mismatch:
	  err_msg = _("number of operands mismatch");
	  break;
	case invalid_instruction_suffix:
	  err_msg = _("invalid instruction suffix");
	  break;
	case bad_imm4:
	  err_msg = _("constant doesn't fit in 4 bits");
	  break;
	case old_gcc_only:
	  err_msg = _("only supported with old gcc");
	  break;
	case unsupported_with_intel_mnemonic:
	  err_msg = _("unsupported with Intel mnemonic");
	  break;
	case unsupported_syntax:
	  err_msg = _("unsupported syntax");
	  break;
	case unsupported:
	  as_bad (_("unsupported instruction `%s'"),
		  current_templates->start->name);
	  return NULL;
	case invalid_vsib_address:
	  err_msg = _("invalid VSIB address");
	  break;
	case invalid_vector_register_set:
	  err_msg = _("mask, index, and destination registers must be distinct");
	  break;
	case unsupported_vector_index_register:
	  err_msg = _("unsupported vector index register");
	  break;
	case unsupported_broadcast:
	  err_msg = _("unsupported broadcast");
	  break;
	case broadcast_not_on_src_operand:
	  err_msg = _("broadcast not on source memory operand");
	  break;
	case broadcast_needed:
	  err_msg = _("broadcast is needed for operand of such type");
	  break;
	case unsupported_masking:
	  err_msg = _("unsupported masking");
	  break;
	case mask_not_on_destination:
	  err_msg = _("mask not on destination operand");
	  break;
	case no_default_mask:
	  err_msg = _("default mask isn't allowed");
	  break;
	case unsupported_rc_sae:
	  err_msg = _("unsupported static rounding/sae");
	  break;
	case rc_sae_operand_not_last_imm:
	  if (intel_syntax)
	    err_msg = _("RC/SAE operand must precede immediate operands");
	  else
	    err_msg = _("RC/SAE operand must follow immediate operands");
	  break;
	case invalid_register_operand:
	  err_msg = _("invalid register operand");
	  break;
	}
      as_bad (_("%s for `%s'"), err_msg,
	      current_templates->start->name);
      return NULL;
    }

  if (!quiet_warnings)
    {
      if (!intel_syntax
	  && (i.types[0].bitfield.jumpabsolute
	      != operand_types[0].bitfield.jumpabsolute))
	{
	  as_warn (_("indirect %s without `*'"), t->name);
	}

      if (t->opcode_modifier.isprefix
	  && t->opcode_modifier.ignoresize)
	{
	  /* Warn them that a data or address size prefix doesn't
	     affect assembly of the next line of code.  */
	  as_warn (_("stand-alone `%s' prefix"), t->name);
	}
    }

  /* Copy the template we found.  */
  i.tm = *t;

  if (addr_prefix_disp != -1)
    i.tm.operand_types[addr_prefix_disp]
      = operand_types[addr_prefix_disp];

  if (found_reverse_match)
    {
      /* If we found a reverse match we must alter the opcode
	 direction bit.  found_reverse_match holds bits to change
	 (different for int & float insns).  */

      i.tm.base_opcode ^= found_reverse_match;

      i.tm.operand_types[0] = operand_types[1];
      i.tm.operand_types[1] = operand_types[0];
    }

  return t;
}

static int
check_string (void)
{
  int mem_op = operand_type_check (i.types[0], anymem) ? 0 : 1;
  if (i.tm.operand_types[mem_op].bitfield.esseg)
    {
      if (i.seg[0] != NULL && i.seg[0] != &es)
	{
	  as_bad (_("`%s' operand %d must use `%ses' segment"),
		  i.tm.name,
		  mem_op + 1,
		  register_prefix);
	  return 0;
	}
      /* There's only ever one segment override allowed per instruction.
	 This instruction possibly has a legal segment override on the
	 second operand, so copy the segment to where non-string
	 instructions store it, allowing common code.  */
      i.seg[0] = i.seg[1];
    }
  else if (i.tm.operand_types[mem_op + 1].bitfield.esseg)
    {
      if (i.seg[1] != NULL && i.seg[1] != &es)
	{
	  as_bad (_("`%s' operand %d must use `%ses' segment"),
		  i.tm.name,
		  mem_op + 2,
		  register_prefix);
	  return 0;
	}
    }
  return 1;
}

static int
process_suffix (void)
{
  /* If matched instruction specifies an explicit instruction mnemonic
     suffix, use it.  */
  if (i.tm.opcode_modifier.size16)
    i.suffix = WORD_MNEM_SUFFIX;
  else if (i.tm.opcode_modifier.size32)
    i.suffix = LONG_MNEM_SUFFIX;
  else if (i.tm.opcode_modifier.size64)
    i.suffix = QWORD_MNEM_SUFFIX;
  else if (i.reg_operands)
    {
      /* If there's no instruction mnemonic suffix we try to invent one
	 based on register operands.  */
      if (!i.suffix)
	{
	  /* We take i.suffix from the last register operand specified,
	     Destination register type is more significant than source
	     register type.  crc32 in SSE4.2 prefers source register
	     type. */
	  if (i.tm.base_opcode == 0xf20f38f1)
	    {
	      if (i.types[0].bitfield.reg16)
		i.suffix = WORD_MNEM_SUFFIX;
	      else if (i.types[0].bitfield.reg32)
		i.suffix = LONG_MNEM_SUFFIX;
	      else if (i.types[0].bitfield.reg64)
		i.suffix = QWORD_MNEM_SUFFIX;
	    }
	  else if (i.tm.base_opcode == 0xf20f38f0)
	    {
	      if (i.types[0].bitfield.reg8)
		i.suffix = BYTE_MNEM_SUFFIX;
	    }

	  if (!i.suffix)
	    {
	      int op;

	      if (i.tm.base_opcode == 0xf20f38f1
		  || i.tm.base_opcode == 0xf20f38f0)
		{
		  /* We have to know the operand size for crc32.  */
		  as_bad (_("ambiguous memory operand size for `%s`"),
			  i.tm.name);
		  return 0;
		}

	      for (op = i.operands; --op >= 0;)
		if (!i.tm.operand_types[op].bitfield.inoutportreg)
		  {
		    if (i.types[op].bitfield.reg8)
		      {
			i.suffix = BYTE_MNEM_SUFFIX;
			break;
		      }
		    else if (i.types[op].bitfield.reg16)
		      {
			i.suffix = WORD_MNEM_SUFFIX;
			break;
		      }
		    else if (i.types[op].bitfield.reg32)
		      {
			i.suffix = LONG_MNEM_SUFFIX;
			break;
		      }
		    else if (i.types[op].bitfield.reg64)
		      {
			i.suffix = QWORD_MNEM_SUFFIX;
			break;
		      }
		  }
	    }
	}
      else if (i.suffix == BYTE_MNEM_SUFFIX)
	{
	  if (intel_syntax
	      && i.tm.opcode_modifier.ignoresize
	      && i.tm.opcode_modifier.no_bsuf)
	    i.suffix = 0;
	  else if (!check_byte_reg ())
	    return 0;
	}
      else if (i.suffix == LONG_MNEM_SUFFIX)
	{
	  if (intel_syntax
	      && i.tm.opcode_modifier.ignoresize
	      && i.tm.opcode_modifier.no_lsuf)
	    i.suffix = 0;
	  else if (!check_long_reg ())
	    return 0;
	}
      else if (i.suffix == QWORD_MNEM_SUFFIX)
	{
	  if (intel_syntax
	      && i.tm.opcode_modifier.ignoresize
	      && i.tm.opcode_modifier.no_qsuf)
	    i.suffix = 0;
	  else if (!check_qword_reg ())
	    return 0;
	}
      else if (i.suffix == WORD_MNEM_SUFFIX)
	{
	  if (intel_syntax
	      && i.tm.opcode_modifier.ignoresize
	      && i.tm.opcode_modifier.no_wsuf)
	    i.suffix = 0;
	  else if (!check_word_reg ())
	    return 0;
	}
      else if (i.suffix == XMMWORD_MNEM_SUFFIX
	       || i.suffix == YMMWORD_MNEM_SUFFIX
	       || i.suffix == ZMMWORD_MNEM_SUFFIX)
	{
	  /* Skip if the instruction has x/y/z suffix.  match_template
	     should check if it is a valid suffix.  */
	}
      else if (intel_syntax && i.tm.opcode_modifier.ignoresize)
	/* Do nothing if the instruction is going to ignore the prefix.  */
	;
      else
	abort ();
    }
  else if (i.tm.opcode_modifier.defaultsize
	   && !i.suffix
	   /* exclude fldenv/frstor/fsave/fstenv */
	   && i.tm.opcode_modifier.no_ssuf)
    {
      i.suffix = stackop_size;
    }
  else if (intel_syntax
	   && !i.suffix
	   && (i.tm.operand_types[0].bitfield.jumpabsolute
	       || i.tm.opcode_modifier.jumpbyte
	       || i.tm.opcode_modifier.jumpintersegment
	       || (i.tm.base_opcode == 0x0f01 /* [ls][gi]dt */
		   && i.tm.extension_opcode <= 3)))
    {
      switch (flag_code)
	{
	case CODE_64BIT:
	  if (!i.tm.opcode_modifier.no_qsuf)
	    {
	      i.suffix = QWORD_MNEM_SUFFIX;
	      break;
	    }
	case CODE_32BIT:
	  if (!i.tm.opcode_modifier.no_lsuf)
	    i.suffix = LONG_MNEM_SUFFIX;
	  break;
	case CODE_16BIT:
	  if (!i.tm.opcode_modifier.no_wsuf)
	    i.suffix = WORD_MNEM_SUFFIX;
	  break;
	}
    }

  if (!i.suffix)
    {
      if (!intel_syntax)
	{
	  if (i.tm.opcode_modifier.w)
	    {
	      as_bad (_("no instruction mnemonic suffix given and "
			"no register operands; can't size instruction"));
	      return 0;
	    }
	}
      else
	{
	  unsigned int suffixes;

	  suffixes = !i.tm.opcode_modifier.no_bsuf;
	  if (!i.tm.opcode_modifier.no_wsuf)
	    suffixes |= 1 << 1;
	  if (!i.tm.opcode_modifier.no_lsuf)
	    suffixes |= 1 << 2;
	  if (!i.tm.opcode_modifier.no_ldsuf)
	    suffixes |= 1 << 3;
	  if (!i.tm.opcode_modifier.no_ssuf)
	    suffixes |= 1 << 4;
	  if (!i.tm.opcode_modifier.no_qsuf)
	    suffixes |= 1 << 5;

	  /* There are more than suffix matches.  */
	  if (i.tm.opcode_modifier.w
	      || ((suffixes & (suffixes - 1))
		  && !i.tm.opcode_modifier.defaultsize
		  && !i.tm.opcode_modifier.ignoresize))
	    {
	      as_bad (_("ambiguous operand size for `%s'"), i.tm.name);
	      return 0;
	    }
	}
    }

  /* Change the opcode based on the operand size given by i.suffix;
     We don't need to change things for byte insns.  */

  if (i.suffix
      && i.suffix != BYTE_MNEM_SUFFIX
      && i.suffix != XMMWORD_MNEM_SUFFIX
      && i.suffix != YMMWORD_MNEM_SUFFIX
      && i.suffix != ZMMWORD_MNEM_SUFFIX)
    {
      /* It's not a byte, select word/dword operation.  */
      if (i.tm.opcode_modifier.w)
	{
	  if (i.tm.opcode_modifier.shortform)
	    i.tm.base_opcode |= 8;
	  else
	    i.tm.base_opcode |= 1;
	}

      /* Now select between word & dword operations via the operand
	 size prefix, except for instructions that will ignore this
	 prefix anyway.  */
      if (i.tm.opcode_modifier.addrprefixop0)
	{
	  /* The address size override prefix changes the size of the
	     first operand.  */
	  if ((flag_code == CODE_32BIT
	       && i.op->regs[0].reg_type.bitfield.reg16)
	      || (flag_code != CODE_32BIT
		  && i.op->regs[0].reg_type.bitfield.reg32))
	    if (!add_prefix (ADDR_PREFIX_OPCODE))
	      return 0;
	}
      else if (i.suffix != QWORD_MNEM_SUFFIX
	       && i.suffix != LONG_DOUBLE_MNEM_SUFFIX
	       && !i.tm.opcode_modifier.ignoresize
	       && !i.tm.opcode_modifier.floatmf
	       && ((i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
		   || (flag_code == CODE_64BIT
		       && i.tm.opcode_modifier.jumpbyte)))
	{
	  unsigned int prefix = DATA_PREFIX_OPCODE;

	  if (i.tm.opcode_modifier.jumpbyte) /* jcxz, loop */
	    prefix = ADDR_PREFIX_OPCODE;

	  if (!add_prefix (prefix))
	    return 0;
	}

      /* Set mode64 for an operand.  */
      if (i.suffix == QWORD_MNEM_SUFFIX
	  && flag_code == CODE_64BIT
	  && !i.tm.opcode_modifier.norex64)
	{
	  /* Special case for xchg %rax,%rax.  It is NOP and doesn't
	     need rex64.  cmpxchg8b is also a special case. */
	  if (! (i.operands == 2
		 && i.tm.base_opcode == 0x90
		 && i.tm.extension_opcode == None
		 && operand_type_equal (&i.types [0], &acc64)
		 && operand_type_equal (&i.types [1], &acc64))
	      && ! (i.operands == 1
		    && i.tm.base_opcode == 0xfc7
		    && i.tm.extension_opcode == 1
		    && !operand_type_check (i.types [0], reg)
		    && operand_type_check (i.types [0], anymem)))
	    i.rex |= REX_W;
	}

      /* Size floating point instruction.  */
      if (i.suffix == LONG_MNEM_SUFFIX)
	if (i.tm.opcode_modifier.floatmf)
	  i.tm.base_opcode ^= 4;
    }

  return 1;
}

static int
check_byte_reg (void)
{
  int op;

  for (op = i.operands; --op >= 0;)
    {
      /* If this is an eight bit register, it's OK.  If it's the 16 or
	 32 bit version of an eight bit register, we will just use the
	 low portion, and that's OK too.  */
      if (i.types[op].bitfield.reg8)
	continue;

      /* I/O port address operands are OK too.  */
      if (i.tm.operand_types[op].bitfield.inoutportreg)
	continue;

      /* crc32 doesn't generate this warning.  */
      if (i.tm.base_opcode == 0xf20f38f0)
	continue;

      if ((i.types[op].bitfield.reg16
	   || i.types[op].bitfield.reg32
	   || i.types[op].bitfield.reg64)
	  && i.op[op].regs->reg_num < 4
	  /* Prohibit these changes in 64bit mode, since the lowering
	     would be more complicated.  */
	  && flag_code != CODE_64BIT)
	{
#if REGISTER_WARNINGS
	  if (!quiet_warnings)
	    as_warn (_("using `%s%s' instead of `%s%s' due to `%c' suffix"),
		     register_prefix,
		     (i.op[op].regs + (i.types[op].bitfield.reg16
				       ? REGNAM_AL - REGNAM_AX
				       : REGNAM_AL - REGNAM_EAX))->reg_name,
		     register_prefix,
		     i.op[op].regs->reg_name,
		     i.suffix);
#endif
	  continue;
	}
      /* Any other register is bad.  */
      if (i.types[op].bitfield.reg16
	  || i.types[op].bitfield.reg32
	  || i.types[op].bitfield.reg64
	  || i.types[op].bitfield.regmmx
	  || i.types[op].bitfield.regxmm
	  || i.types[op].bitfield.regymm
	  || i.types[op].bitfield.regzmm
	  || i.types[op].bitfield.sreg2
	  || i.types[op].bitfield.sreg3
	  || i.types[op].bitfield.control
	  || i.types[op].bitfield.debug
	  || i.types[op].bitfield.test
	  || i.types[op].bitfield.floatreg
	  || i.types[op].bitfield.floatacc)
	{
	  as_bad (_("`%s%s' not allowed with `%s%c'"),
		  register_prefix,
		  i.op[op].regs->reg_name,
		  i.tm.name,
		  i.suffix);
	  return 0;
	}
    }
  return 1;
}

static int
check_long_reg (void)
{
  int op;

  for (op = i.operands; --op >= 0;)
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if (i.types[op].bitfield.reg8
	&& (i.tm.operand_types[op].bitfield.reg16
	    || i.tm.operand_types[op].bitfield.reg32
	    || i.tm.operand_types[op].bitfield.acc))
      {
	as_bad (_("`%s%s' not allowed with `%s%c'"),
		register_prefix,
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is missing.  */
    else if ((!quiet_warnings || flag_code == CODE_64BIT)
	     && i.types[op].bitfield.reg16
	     && (i.tm.operand_types[op].bitfield.reg32
		 || i.tm.operand_types[op].bitfield.acc))
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (flag_code == CODE_64BIT)
	  {
	    as_bad (_("incorrect register `%s%s' used with `%c' suffix"),
		    register_prefix, i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
	  }
#if REGISTER_WARNINGS
	as_warn (_("using `%s%s' instead of `%s%s' due to `%c' suffix"),
		 register_prefix,
		 (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
		 register_prefix, i.op[op].regs->reg_name, i.suffix);
#endif
      }
  /* Warn if the r prefix on a general reg is missing.  */
    else if (i.types[op].bitfield.reg64
	     && (i.tm.operand_types[op].bitfield.reg32
		 || i.tm.operand_types[op].bitfield.acc))
      {
	if (intel_syntax
	    && i.tm.opcode_modifier.toqword
	    && !i.types[0].bitfield.regxmm)
	  {
	    /* Convert to QWORD.  We want REX byte. */
	    i.suffix = QWORD_MNEM_SUFFIX;
	  }
	else
	  {
	    as_bad (_("incorrect register `%s%s' used with `%c' suffix"),
		    register_prefix, i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
	  }
      }
  return 1;
}

static int
check_qword_reg (void)
{
  int op;

  for (op = i.operands; --op >= 0; )
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if (i.types[op].bitfield.reg8
	&& (i.tm.operand_types[op].bitfield.reg16
	    || i.tm.operand_types[op].bitfield.reg32
	    || i.tm.operand_types[op].bitfield.acc))
      {
	as_bad (_("`%s%s' not allowed with `%s%c'"),
		register_prefix,
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is missing.  */
    else if ((i.types[op].bitfield.reg16
	      || i.types[op].bitfield.reg32)
	     && (i.tm.operand_types[op].bitfield.reg32
		 || i.tm.operand_types[op].bitfield.acc))
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (intel_syntax
	    && i.tm.opcode_modifier.todword
	    && !i.types[0].bitfield.regxmm)
	  {
	    /* Convert to DWORD.  We don't want REX byte. */
	    i.suffix = LONG_MNEM_SUFFIX;
	  }
	else
	  {
	    as_bad (_("incorrect register `%s%s' used with `%c' suffix"),
		    register_prefix, i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
	  }
      }
  return 1;
}

static int
check_word_reg (void)
{
  int op;
  for (op = i.operands; --op >= 0;)
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if (i.types[op].bitfield.reg8
	&& (i.tm.operand_types[op].bitfield.reg16
	    || i.tm.operand_types[op].bitfield.reg32
	    || i.tm.operand_types[op].bitfield.acc))
      {
	as_bad (_("`%s%s' not allowed with `%s%c'"),
		register_prefix,
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is present.  */
    else if ((!quiet_warnings || flag_code == CODE_64BIT)
	     && i.types[op].bitfield.reg32
	     && (i.tm.operand_types[op].bitfield.reg16
		 || i.tm.operand_types[op].bitfield.acc))
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (flag_code == CODE_64BIT)
	  {
	    as_bad (_("incorrect register `%s%s' used with `%c' suffix"),
		    register_prefix, i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
	  }
#if REGISTER_WARNINGS
	as_warn (_("using `%s%s' instead of `%s%s' due to `%c' suffix"),
		 register_prefix,
		 (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
		 register_prefix, i.op[op].regs->reg_name, i.suffix);
#endif
      }
  return 1;
}

static int
update_imm (unsigned int j)
{
  i386_operand_type overlap = i.types[j];
  if ((overlap.bitfield.imm8
       || overlap.bitfield.imm8s
       || overlap.bitfield.imm16
       || overlap.bitfield.imm32
       || overlap.bitfield.imm32s
       || overlap.bitfield.imm64)
      && !operand_type_equal (&overlap, &imm8)
      && !operand_type_equal (&overlap, &imm8s)
      && !operand_type_equal (&overlap, &imm16)
      && !operand_type_equal (&overlap, &imm32)
      && !operand_type_equal (&overlap, &imm32s)
      && !operand_type_equal (&overlap, &imm64))
    {
      if (i.suffix)
	{
	  i386_operand_type temp;

	  operand_type_set (&temp, 0);
	  if (i.suffix == BYTE_MNEM_SUFFIX)
	    {
	      temp.bitfield.imm8 = overlap.bitfield.imm8;
	      temp.bitfield.imm8s = overlap.bitfield.imm8s;
	    }
	  else if (i.suffix == WORD_MNEM_SUFFIX)
	    temp.bitfield.imm16 = overlap.bitfield.imm16;
	  else if (i.suffix == QWORD_MNEM_SUFFIX)
	    {
	      temp.bitfield.imm64 = overlap.bitfield.imm64;
	      temp.bitfield.imm32s = overlap.bitfield.imm32s;
	    }
	  else
	    temp.bitfield.imm32 = overlap.bitfield.imm32;
	  overlap = temp;
	}
      else if (operand_type_equal (&overlap, &imm16_32_32s)
	       || operand_type_equal (&overlap, &imm16_32)
	       || operand_type_equal (&overlap, &imm16_32s))
	{
	  if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
	    overlap = imm16;
	  else
	    overlap = imm32s;
	}
      if (!operand_type_equal (&overlap, &imm8)
	  && !operand_type_equal (&overlap, &imm8s)
	  && !operand_type_equal (&overlap, &imm16)
	  && !operand_type_equal (&overlap, &imm32)
	  && !operand_type_equal (&overlap, &imm32s)
	  && !operand_type_equal (&overlap, &imm64))
	{
	  as_bad (_("no instruction mnemonic suffix given; "
		    "can't determine immediate size"));
	  return 0;
	}
    }
  i.types[j] = overlap;

  return 1;
}

static int
finalize_imm (void)
{
  unsigned int j, n;

  /* Update the first 2 immediate operands.  */
  n = i.operands > 2 ? 2 : i.operands;
  if (n)
    {
      for (j = 0; j < n; j++)
	if (update_imm (j) == 0)
	  return 0;

      /* The 3rd operand can't be immediate operand.  */
      gas_assert (operand_type_check (i.types[2], imm) == 0);
    }

  return 1;
}

static int
bad_implicit_operand (int xmm)
{
  const char *ireg = xmm ? "xmm0" : "ymm0";

  if (intel_syntax)
    as_bad (_("the last operand of `%s' must be `%s%s'"),
	    i.tm.name, register_prefix, ireg);
  else
    as_bad (_("the first operand of `%s' must be `%s%s'"),
	    i.tm.name, register_prefix, ireg);
  return 0;
}

static int
process_operands (void)
{
  /* Default segment register this instruction will use for memory
     accesses.  0 means unknown.  This is only for optimizing out
     unnecessary segment overrides.  */
  const seg_entry *default_seg = 0;

  if (i.tm.opcode_modifier.sse2avx && i.tm.opcode_modifier.vexvvvv)
    {
      unsigned int dupl = i.operands;
      unsigned int dest = dupl - 1;
      unsigned int j;

      /* The destination must be an xmm register.  */
      gas_assert (i.reg_operands
		  && MAX_OPERANDS > dupl
		  && operand_type_equal (&i.types[dest], &regxmm));

      if (i.tm.opcode_modifier.firstxmm0)
	{
	  /* The first operand is implicit and must be xmm0.  */
	  gas_assert (operand_type_equal (&i.types[0], &regxmm));
	  if (register_number (i.op[0].regs) != 0)
	    return bad_implicit_operand (1);

	  if (i.tm.opcode_modifier.vexsources == VEX3SOURCES)
	    {
	      /* Keep xmm0 for instructions with VEX prefix and 3
		 sources.  */
	      goto duplicate;
	    }
	  else
	    {
	      /* We remove the first xmm0 and keep the number of
		 operands unchanged, which in fact duplicates the
		 destination.  */
	      for (j = 1; j < i.operands; j++)
		{
		  i.op[j - 1] = i.op[j];
		  i.types[j - 1] = i.types[j];
		  i.tm.operand_types[j - 1] = i.tm.operand_types[j];
		}
	    }
	}
      else if (i.tm.opcode_modifier.implicit1stxmm0)
	{
	  gas_assert ((MAX_OPERANDS - 1) > dupl
		      && (i.tm.opcode_modifier.vexsources
			  == VEX3SOURCES));

	  /* Add the implicit xmm0 for instructions with VEX prefix
	     and 3 sources.  */
	  for (j = i.operands; j > 0; j--)
	    {
	      i.op[j] = i.op[j - 1];
	      i.types[j] = i.types[j - 1];
	      i.tm.operand_types[j] = i.tm.operand_types[j - 1];
	    }
	  i.op[0].regs
	    = (const reg_entry *) hash_find (reg_hash, "xmm0");
	  i.types[0] = regxmm;
	  i.tm.operand_types[0] = regxmm;

	  i.operands += 2;
	  i.reg_operands += 2;
	  i.tm.operands += 2;

	  dupl++;
	  dest++;
	  i.op[dupl] = i.op[dest];
	  i.types[dupl] = i.types[dest];
	  i.tm.operand_types[dupl] = i.tm.operand_types[dest];
	}
      else
	{
duplicate:
	  i.operands++;
	  i.reg_operands++;
	  i.tm.operands++;

	  i.op[dupl] = i.op[dest];
	  i.types[dupl] = i.types[dest];
	  i.tm.operand_types[dupl] = i.tm.operand_types[dest];
	}

       if (i.tm.opcode_modifier.immext)
	 process_immext ();
    }
  else if (i.tm.opcode_modifier.firstxmm0)
    {
      unsigned int j;

      /* The first operand is implicit and must be xmm0/ymm0/zmm0.  */
      gas_assert (i.reg_operands
		  && (operand_type_equal (&i.types[0], &regxmm)
		      || operand_type_equal (&i.types[0], &regymm)
		      || operand_type_equal (&i.types[0], &regzmm)));
      if (register_number (i.op[0].regs) != 0)
	return bad_implicit_operand (i.types[0].bitfield.regxmm);

      for (j = 1; j < i.operands; j++)
	{
	  i.op[j - 1] = i.op[j];
	  i.types[j - 1] = i.types[j];

	  /* We need to adjust fields in i.tm since they are used by
	     build_modrm_byte.  */
	  i.tm.operand_types [j - 1] = i.tm.operand_types [j];
	}

      i.operands--;
      i.reg_operands--;
      i.tm.operands--;
    }
  else if (i.tm.opcode_modifier.regkludge)
    {
      /* The imul $imm, %reg instruction is converted into
	 imul $imm, %reg, %reg, and the clr %reg instruction
	 is converted into xor %reg, %reg.  */

      unsigned int first_reg_op;

      if (operand_type_check (i.types[0], reg))
	first_reg_op = 0;
      else
	first_reg_op = 1;
      /* Pretend we saw the extra register operand.  */
      gas_assert (i.reg_operands == 1
		  && i.op[first_reg_op + 1].regs == 0);
      i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
      i.types[first_reg_op + 1] = i.types[first_reg_op];
      i.operands++;
      i.reg_operands++;
    }

  if (i.tm.opcode_modifier.shortform)
    {
      if (i.types[0].bitfield.sreg2
	  || i.types[0].bitfield.sreg3)
	{
	  if (i.tm.base_opcode == POP_SEG_SHORT
	      && i.op[0].regs->reg_num == 1)
	    {
	      as_bad (_("you can't `pop %scs'"), register_prefix);
	      return 0;
	    }
	  i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
	  if ((i.op[0].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_B;
	}
      else
	{
	  /* The register or float register operand is in operand
	     0 or 1.  */
	  unsigned int op;

	  if (i.types[0].bitfield.floatreg
	      || operand_type_check (i.types[0], reg))
	    op = 0;
	  else
	    op = 1;
	  /* Register goes in low 3 bits of opcode.  */
	  i.tm.base_opcode |= i.op[op].regs->reg_num;
	  if ((i.op[op].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_B;
	  if (!quiet_warnings && i.tm.opcode_modifier.ugh)
	    {
	      /* Warn about some common errors, but press on regardless.
		 The first case can be generated by gcc (<= 2.8.1).  */
	      if (i.operands == 2)
		{
		  /* Reversed arguments on faddp, fsubp, etc.  */
		  as_warn (_("translating to `%s %s%s,%s%s'"), i.tm.name,
			   register_prefix, i.op[!intel_syntax].regs->reg_name,
			   register_prefix, i.op[intel_syntax].regs->reg_name);
		}
	      else
		{
		  /* Extraneous `l' suffix on fp insn.  */
		  as_warn (_("translating to `%s %s%s'"), i.tm.name,
			   register_prefix, i.op[0].regs->reg_name);
		}
	    }
	}
    }
  else if (i.tm.opcode_modifier.modrm)
    {
      /* The opcode is completed (modulo i.tm.extension_opcode which
	 must be put into the modrm byte).  Now, we make the modrm and
	 index base bytes based on all the info we've collected.  */

      default_seg = build_modrm_byte ();
    }
  else if ((i.tm.base_opcode & ~0x3) == MOV_AX_DISP32)
    {
      default_seg = &ds;
    }
  else if (i.tm.opcode_modifier.isstring)
    {
      /* For the string instructions that allow a segment override
	 on one of their operands, the default segment is ds.  */
      default_seg = &ds;
    }

  if (i.tm.base_opcode == 0x8d /* lea */
      && i.seg[0]
      && !quiet_warnings)
    as_warn (_("segment override on `%s' is ineffectual"), i.tm.name);

  /* If a segment was explicitly specified, and the specified segment
     is not the default, use an opcode prefix to select it.  If we
     never figured out what the default segment is, then default_seg
     will be zero at this point, and the specified segment prefix will
     always be used.  */
  if ((i.seg[0]) && (i.seg[0] != default_seg))
    {
      if (!add_prefix (i.seg[0]->seg_prefix))
	return 0;
    }
  return 1;
}

static const seg_entry *
build_modrm_byte (void)
{
  const seg_entry *default_seg = 0;
  unsigned int source, dest;
  int vex_3_sources;

  /* The first operand of instructions with VEX prefix and 3 sources
     must be VEX_Imm4.  */
  vex_3_sources = i.tm.opcode_modifier.vexsources == VEX3SOURCES;
  if (vex_3_sources)
    {
      unsigned int nds, reg_slot;
      expressionS *exp;

      if (i.tm.opcode_modifier.veximmext
          && i.tm.opcode_modifier.immext)
        {
          dest = i.operands - 2;
          gas_assert (dest == 3);
        }
      else
        dest = i.operands - 1;
      nds = dest - 1;

      /* There are 2 kinds of instructions:
         1. 5 operands: 4 register operands or 3 register operands
         plus 1 memory operand plus one Vec_Imm4 operand, VexXDS, and
         VexW0 or VexW1.  The destination must be either XMM, YMM or
	 ZMM register.
         2. 4 operands: 4 register operands or 3 register operands
         plus 1 memory operand, VexXDS, and VexImmExt  */
      gas_assert ((i.reg_operands == 4
                   || (i.reg_operands == 3 && i.mem_operands == 1))
                  && i.tm.opcode_modifier.vexvvvv == VEXXDS
                  && (i.tm.opcode_modifier.veximmext
                      || (i.imm_operands == 1
                          && i.types[0].bitfield.vec_imm4
                          && (i.tm.opcode_modifier.vexw == VEXW0
                              || i.tm.opcode_modifier.vexw == VEXW1)
                          && (operand_type_equal (&i.tm.operand_types[dest], &regxmm)
                              || operand_type_equal (&i.tm.operand_types[dest], &regymm)
                              || operand_type_equal (&i.tm.operand_types[dest], &regzmm)))));

      if (i.imm_operands == 0)
        {
          /* When there is no immediate operand, generate an 8bit
             immediate operand to encode the first operand.  */
          exp = &im_expressions[i.imm_operands++];
          i.op[i.operands].imms = exp;
          i.types[i.operands] = imm8;
          i.operands++;
          /* If VexW1 is set, the first operand is the source and
             the second operand is encoded in the immediate operand.  */
          if (i.tm.opcode_modifier.vexw == VEXW1)
            {
              source = 0;
              reg_slot = 1;
            }
          else
            {
              source = 1;
              reg_slot = 0;
            }

          /* FMA swaps REG and NDS.  */
          if (i.tm.cpu_flags.bitfield.cpufma)
            {
              unsigned int tmp;
              tmp = reg_slot;
              reg_slot = nds;
              nds = tmp;
            }

          gas_assert (operand_type_equal (&i.tm.operand_types[reg_slot],
					  &regxmm)
                      || operand_type_equal (&i.tm.operand_types[reg_slot],
                                             &regymm)
                      || operand_type_equal (&i.tm.operand_types[reg_slot],
                                             &regzmm));
          exp->X_op = O_constant;
          exp->X_add_number = register_number (i.op[reg_slot].regs) << 4;
	  gas_assert ((i.op[reg_slot].regs->reg_flags & RegVRex) == 0);
	}
      else
        {
          unsigned int imm_slot;

          if (i.tm.opcode_modifier.vexw == VEXW0)
            {
              /* If VexW0 is set, the third operand is the source and
                 the second operand is encoded in the immediate
                 operand.  */
              source = 2;
              reg_slot = 1;
            }
          else
            {
              /* VexW1 is set, the second operand is the source and
                 the third operand is encoded in the immediate
                 operand.  */
              source = 1;
              reg_slot = 2;
            }

          if (i.tm.opcode_modifier.immext)
            {
              /* When ImmExt is set, the immdiate byte is the last
                 operand.  */
              imm_slot = i.operands - 1;
              source--;
              reg_slot--;
            }
          else
            {
              imm_slot = 0;

              /* Turn on Imm8 so that output_imm will generate it.  */
              i.types[imm_slot].bitfield.imm8 = 1;
            }

          gas_assert (operand_type_equal (&i.tm.operand_types[reg_slot],
					  &regxmm)
		      || operand_type_equal (&i.tm.operand_types[reg_slot],
					     &regymm)
		      || operand_type_equal (&i.tm.operand_types[reg_slot],
					     &regzmm));
          i.op[imm_slot].imms->X_add_number
              |= register_number (i.op[reg_slot].regs) << 4;
	  gas_assert ((i.op[reg_slot].regs->reg_flags & RegVRex) == 0);
        }

      gas_assert (operand_type_equal (&i.tm.operand_types[nds], &regxmm)
                  || operand_type_equal (&i.tm.operand_types[nds],
                                         &regymm)
                  || operand_type_equal (&i.tm.operand_types[nds],
                                         &regzmm));
      i.vex.register_specifier = i.op[nds].regs;
    }
  else
    source = dest = 0;

  /* i.reg_operands MUST be the number of real register operands;
     implicit registers do not count.  If there are 3 register
     operands, it must be a instruction with VexNDS.  For a
     instruction with VexNDD, the destination register is encoded
     in VEX prefix.  If there are 4 register operands, it must be
     a instruction with VEX prefix and 3 sources.  */
  if (i.mem_operands == 0
      && ((i.reg_operands == 2
	   && i.tm.opcode_modifier.vexvvvv <= VEXXDS)
	  || (i.reg_operands == 3
	      && i.tm.opcode_modifier.vexvvvv == VEXXDS)
	  || (i.reg_operands == 4 && vex_3_sources)))
    {
      switch (i.operands)
	{
	case 2:
	  source = 0;
	  break;
	case 3:
	  /* When there are 3 operands, one of them may be immediate,
	     which may be the first or the last operand.  Otherwise,
	     the first operand must be shift count register (cl) or it
	     is an instruction with VexNDS. */
	  gas_assert (i.imm_operands == 1
		      || (i.imm_operands == 0
			  && (i.tm.opcode_modifier.vexvvvv == VEXXDS
			      || i.types[0].bitfield.shiftcount)));
	  if (operand_type_check (i.types[0], imm)
	      || i.types[0].bitfield.shiftcount)
	    source = 1;
	  else
	    source = 0;
	  break;
	case 4:
	  /* When there are 4 operands, the first two must be 8bit
	     immediate operands. The source operand will be the 3rd
	     one.

	     For instructions with VexNDS, if the first operand
	     an imm8, the source operand is the 2nd one.  If the last
	     operand is imm8, the source operand is the first one.  */
	  gas_assert ((i.imm_operands == 2
		       && i.types[0].bitfield.imm8
		       && i.types[1].bitfield.imm8)
		      || (i.tm.opcode_modifier.vexvvvv == VEXXDS
			  && i.imm_operands == 1
			  && (i.types[0].bitfield.imm8
			      || i.types[i.operands - 1].bitfield.imm8
			      || i.rounding)));
	  if (i.imm_operands == 2)
	    source = 2;
	  else
	    {
	      if (i.types[0].bitfield.imm8)
		source = 1;
	      else
		source = 0;
	    }
	  break;
	case 5:
	  if (i.tm.opcode_modifier.evex)
	    {
	      /* For EVEX instructions, when there are 5 operands, the
		 first one must be immediate operand.  If the second one
		 is immediate operand, the source operand is the 3th
		 one.  If the last one is immediate operand, the source
		 operand is the 2nd one.  */
	      gas_assert (i.imm_operands == 2
			  && i.tm.opcode_modifier.sae
			  && operand_type_check (i.types[0], imm));
	      if (operand_type_check (i.types[1], imm))
		source = 2;
	      else if (operand_type_check (i.types[4], imm))
		source = 1;
	      else
		abort ();
	    }
	  break;
	default:
	  abort ();
	}

      if (!vex_3_sources)
	{
	  dest = source + 1;

	  /* RC/SAE operand could be between DEST and SRC.  That happens
	     when one operand is GPR and the other one is XMM/YMM/ZMM
	     register.  */
	  if (i.rounding && i.rounding->operand == (int) dest)
	    dest++;

	  if (i.tm.opcode_modifier.vexvvvv == VEXXDS)
	    {
	      /* For instructions with VexNDS, the register-only source
		 operand must be 32/64bit integer, XMM, YMM or ZMM
		 register.  It is encoded in VEX prefix.  We need to
		 clear RegMem bit before calling operand_type_equal.  */

	      i386_operand_type op;
	      unsigned int vvvv;

	      /* Check register-only source operand when two source
		 operands are swapped.  */
	      if (!i.tm.operand_types[source].bitfield.baseindex
		  && i.tm.operand_types[dest].bitfield.baseindex)
		{
		  vvvv = source;
		  source = dest;
		}
	      else
		vvvv = dest;

	      op = i.tm.operand_types[vvvv];
	      op.bitfield.regmem = 0;
	      if ((dest + 1) >= i.operands
		  || (op.bitfield.reg32 != 1
		      && !op.bitfield.reg64 != 1
		      && !operand_type_equal (&op, &regxmm)
		      && !operand_type_equal (&op, &regymm)
		      && !operand_type_equal (&op, &regzmm)
		      && !operand_type_equal (&op, &regmask)))
		abort ();
	      i.vex.register_specifier = i.op[vvvv].regs;
	      dest++;
	    }
	}

      i.rm.mode = 3;
      /* One of the register operands will be encoded in the i.tm.reg
	 field, the other in the combined i.tm.mode and i.tm.regmem
	 fields.  If no form of this instruction supports a memory
	 destination operand, then we assume the source operand may
	 sometimes be a memory operand and so we need to store the
	 destination in the i.rm.reg field.  */
      if (!i.tm.operand_types[dest].bitfield.regmem
	  && operand_type_check (i.tm.operand_types[dest], anymem) == 0)
	{
	  i.rm.reg = i.op[dest].regs->reg_num;
	  i.rm.regmem = i.op[source].regs->reg_num;
	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_R;
	  if ((i.op[dest].regs->reg_flags & RegVRex) != 0)
	    i.vrex |= REX_R;
	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_B;
	  if ((i.op[source].regs->reg_flags & RegVRex) != 0)
	    i.vrex |= REX_B;
	}
      else
	{
	  i.rm.reg = i.op[source].regs->reg_num;
	  i.rm.regmem = i.op[dest].regs->reg_num;
	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_B;
	  if ((i.op[dest].regs->reg_flags & RegVRex) != 0)
	    i.vrex |= REX_B;
	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_R;
	  if ((i.op[source].regs->reg_flags & RegVRex) != 0)
	    i.vrex |= REX_R;
	}
      if (flag_code != CODE_64BIT && (i.rex & (REX_R | REX_B)))
	{
	  if (!i.types[0].bitfield.control
	      && !i.types[1].bitfield.control)
	    abort ();
	  i.rex &= ~(REX_R | REX_B);
	  add_prefix (LOCK_PREFIX_OPCODE);
	}
    }
  else
    {			/* If it's not 2 reg operands...  */
      unsigned int mem;

      if (i.mem_operands)
	{
	  unsigned int fake_zero_displacement = 0;
	  unsigned int op;

	  for (op = 0; op < i.operands; op++)
	    if (operand_type_check (i.types[op], anymem))
	      break;
	  gas_assert (op < i.operands);

	  if (i.tm.opcode_modifier.vecsib)
	    {
	      if (i.index_reg->reg_num == RegEiz
		  || i.index_reg->reg_num == RegRiz)
		abort ();

	      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
	      if (!i.base_reg)
		{
		  i.sib.base = NO_BASE_REGISTER;
		  i.sib.scale = i.log2_scale_factor;
		  /* No Vec_Disp8 if there is no base.  */
		  i.types[op].bitfield.vec_disp8 = 0;
		  i.types[op].bitfield.disp8 = 0;
		  i.types[op].bitfield.disp16 = 0;
		  i.types[op].bitfield.disp64 = 0;
		  if (flag_code != CODE_64BIT)
		    {
		      /* Must be 32 bit */
		      i.types[op].bitfield.disp32 = 1;
		      i.types[op].bitfield.disp32s = 0;
		    }
		  else
		    {
		      i.types[op].bitfield.disp32 = 0;
		      i.types[op].bitfield.disp32s = 1;
		    }
		}
	      i.sib.index = i.index_reg->reg_num;
	      if ((i.index_reg->reg_flags & RegRex) != 0)
		i.rex |= REX_X;
	      if ((i.index_reg->reg_flags & RegVRex) != 0)
		i.vrex |= REX_X;
	    }

	  default_seg = &ds;

	  if (i.base_reg == 0)
	    {
	      i.rm.mode = 0;
	      if (!i.disp_operands)
		{
		  fake_zero_displacement = 1;
		  /* Instructions with VSIB byte need 32bit displacement
		     if there is no base register.  */
		  if (i.tm.opcode_modifier.vecsib)
		    i.types[op].bitfield.disp32 = 1;
		}
	      if (i.index_reg == 0)
		{
		  gas_assert (!i.tm.opcode_modifier.vecsib);
		  /* Operand is just <disp>  */
		  if (flag_code == CODE_64BIT)
		    {
		      /* 64bit mode overwrites the 32bit absolute
			 addressing by RIP relative addressing and
			 absolute addressing is encoded by one of the
			 redundant SIB forms.  */
		      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		      i.sib.base = NO_BASE_REGISTER;
		      i.sib.index = NO_INDEX_REGISTER;
		      i.types[op] = ((i.prefix[ADDR_PREFIX] == 0)
				     ? disp32s : disp32);
		    }
		  else if ((flag_code == CODE_16BIT)
			   ^ (i.prefix[ADDR_PREFIX] != 0))
		    {
		      i.rm.regmem = NO_BASE_REGISTER_16;
		      i.types[op] = disp16;
		    }
		  else
		    {
		      i.rm.regmem = NO_BASE_REGISTER;
		      i.types[op] = disp32;
		    }
		}
	      else if (!i.tm.opcode_modifier.vecsib)
		{
		  /* !i.base_reg && i.index_reg  */
		  if (i.index_reg->reg_num == RegEiz
		      || i.index_reg->reg_num == RegRiz)
		    i.sib.index = NO_INDEX_REGISTER;
		  else
		    i.sib.index = i.index_reg->reg_num;
		  i.sib.base = NO_BASE_REGISTER;
		  i.sib.scale = i.log2_scale_factor;
		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		  /* No Vec_Disp8 if there is no base.  */
		  i.types[op].bitfield.vec_disp8 = 0;
		  i.types[op].bitfield.disp8 = 0;
		  i.types[op].bitfield.disp16 = 0;
		  i.types[op].bitfield.disp64 = 0;
		  if (flag_code != CODE_64BIT)
		    {
		      /* Must be 32 bit */
		      i.types[op].bitfield.disp32 = 1;
		      i.types[op].bitfield.disp32s = 0;
		    }
		  else
		    {
		      i.types[op].bitfield.disp32 = 0;
		      i.types[op].bitfield.disp32s = 1;
		    }
		  if ((i.index_reg->reg_flags & RegRex) != 0)
		    i.rex |= REX_X;
		}
	    }
	  /* RIP addressing for 64bit mode.  */
	  else if (i.base_reg->reg_num == RegRip ||
		   i.base_reg->reg_num == RegEip)
	    {
	      gas_assert (!i.tm.opcode_modifier.vecsib);
	      i.rm.regmem = NO_BASE_REGISTER;
	      i.types[op].bitfield.disp8 = 0;
	      i.types[op].bitfield.disp16 = 0;
	      i.types[op].bitfield.disp32 = 0;
	      i.types[op].bitfield.disp32s = 1;
	      i.types[op].bitfield.disp64 = 0;
	      i.types[op].bitfield.vec_disp8 = 0;
	      i.flags[op] |= Operand_PCrel;
	      if (! i.disp_operands)
		fake_zero_displacement = 1;
	    }
	  else if (i.base_reg->reg_type.bitfield.reg16)
	    {
	      gas_assert (!i.tm.opcode_modifier.vecsib);
	      switch (i.base_reg->reg_num)
		{
		case 3: /* (%bx)  */
		  if (i.index_reg == 0)
		    i.rm.regmem = 7;
		  else /* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
		    i.rm.regmem = i.index_reg->reg_num - 6;
		  break;
		case 5: /* (%bp)  */
		  default_seg = &ss;
		  if (i.index_reg == 0)
		    {
		      i.rm.regmem = 6;
		      if (operand_type_check (i.types[op], disp) == 0)
			{
			  /* fake (%bp) into 0(%bp)  */
			  if (i.tm.operand_types[op].bitfield.vec_disp8)
			    i.types[op].bitfield.vec_disp8 = 1;
			  else
			    i.types[op].bitfield.disp8 = 1;
			  fake_zero_displacement = 1;
			}
		    }
		  else /* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
		    i.rm.regmem = i.index_reg->reg_num - 6 + 2;
		  break;
		default: /* (%si) -> 4 or (%di) -> 5  */
		  i.rm.regmem = i.base_reg->reg_num - 6 + 4;
		}
	      i.rm.mode = mode_from_disp_size (i.types[op]);
	    }
	  else /* i.base_reg and 32/64 bit mode  */
	    {
	      if (flag_code == CODE_64BIT
		  && operand_type_check (i.types[op], disp))
		{
		  i386_operand_type temp;
		  operand_type_set (&temp, 0);
		  temp.bitfield.disp8 = i.types[op].bitfield.disp8;
		  temp.bitfield.vec_disp8
		    = i.types[op].bitfield.vec_disp8;
		  i.types[op] = temp;
		  if (i.prefix[ADDR_PREFIX] == 0)
		    i.types[op].bitfield.disp32s = 1;
		  else
		    i.types[op].bitfield.disp32 = 1;
		}

	      if (!i.tm.opcode_modifier.vecsib)
		i.rm.regmem = i.base_reg->reg_num;
	      if ((i.base_reg->reg_flags & RegRex) != 0)
		i.rex |= REX_B;
	      i.sib.base = i.base_reg->reg_num;
	      /* x86-64 ignores REX prefix bit here to avoid decoder
		 complications.  */
	      if (!(i.base_reg->reg_flags & RegRex)
		  && (i.base_reg->reg_num == EBP_REG_NUM
		   || i.base_reg->reg_num == ESP_REG_NUM))
		  default_seg = &ss;
	      if (i.base_reg->reg_num == 5 && i.disp_operands == 0)
		{
		  fake_zero_displacement = 1;
		  if (i.tm.operand_types [op].bitfield.vec_disp8)
		    i.types[op].bitfield.vec_disp8 = 1;
		  else
		    i.types[op].bitfield.disp8 = 1;
		}
	      i.sib.scale = i.log2_scale_factor;
	      if (i.index_reg == 0)
		{
		  gas_assert (!i.tm.opcode_modifier.vecsib);
		  /* <disp>(%esp) becomes two byte modrm with no index
		     register.  We've already stored the code for esp
		     in i.rm.regmem ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.
		     Any base register besides %esp will not use the
		     extra modrm byte.  */
		  i.sib.index = NO_INDEX_REGISTER;
		}
	      else if (!i.tm.opcode_modifier.vecsib)
		{
		  if (i.index_reg->reg_num == RegEiz
		      || i.index_reg->reg_num == RegRiz)
		    i.sib.index = NO_INDEX_REGISTER;
		  else
		    i.sib.index = i.index_reg->reg_num;
		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		  if ((i.index_reg->reg_flags & RegRex) != 0)
		    i.rex |= REX_X;
		}

	      if (i.disp_operands
		  && (i.reloc[op] == BFD_RELOC_386_TLS_DESC_CALL
		      || i.reloc[op] == BFD_RELOC_X86_64_TLSDESC_CALL))
		i.rm.mode = 0;
	      else
		{
		  if (!fake_zero_displacement
		      && !i.disp_operands
		      && i.disp_encoding)
		    {
		      fake_zero_displacement = 1;
		      if (i.disp_encoding == disp_encoding_8bit)
			i.types[op].bitfield.disp8 = 1;
		      else
			i.types[op].bitfield.disp32 = 1;
		    }
		  i.rm.mode = mode_from_disp_size (i.types[op]);
		}
	    }

	  if (fake_zero_displacement)
	    {
	      /* Fakes a zero displacement assuming that i.types[op]
		 holds the correct displacement size.  */
	      expressionS *exp;

	      gas_assert (i.op[op].disps == 0);
	      exp = &disp_expressions[i.disp_operands++];
	      i.op[op].disps = exp;
	      exp->X_op = O_constant;
	      exp->X_add_number = 0;
	      exp->X_add_symbol = (symbolS *) 0;
	      exp->X_op_symbol = (symbolS *) 0;
	    }

	  mem = op;
	}
      else
	mem = ~0;

      if (i.tm.opcode_modifier.vexsources == XOP2SOURCES)
	{
	  if (operand_type_check (i.types[0], imm))
	    i.vex.register_specifier = NULL;
	  else
	    {
	      /* VEX.vvvv encodes one of the sources when the first
		 operand is not an immediate.  */
	      if (i.tm.opcode_modifier.vexw == VEXW0)
		i.vex.register_specifier = i.op[0].regs;
	      else
		i.vex.register_specifier = i.op[1].regs;
	    }

	  /* Destination is a XMM register encoded in the ModRM.reg
	     and VEX.R bit.  */
	  i.rm.reg = i.op[2].regs->reg_num;
	  if ((i.op[2].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_R;

	  /* ModRM.rm and VEX.B encodes the other source.  */
	  if (!i.mem_operands)
	    {
	      i.rm.mode = 3;

	      if (i.tm.opcode_modifier.vexw == VEXW0)
		i.rm.regmem = i.op[1].regs->reg_num;
	      else
		i.rm.regmem = i.op[0].regs->reg_num;

	      if ((i.op[1].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_B;
	    }
	}
      else if (i.tm.opcode_modifier.vexvvvv == VEXLWP)
	{
	  i.vex.register_specifier = i.op[2].regs;
	  if (!i.mem_operands)
	    {
	      i.rm.mode = 3;
	      i.rm.regmem = i.op[1].regs->reg_num;
	      if ((i.op[1].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_B;
	    }
	}
      /* Fill in i.rm.reg or i.rm.regmem field with register operand
	 (if any) based on i.tm.extension_opcode.  Again, we must be
	 careful to make sure that segment/control/debug/test/MMX
	 registers are coded into the i.rm.reg field.  */
      else if (i.reg_operands)
	{
	  unsigned int op;
	  unsigned int vex_reg = ~0;

	  for (op = 0; op < i.operands; op++)
	    if (i.types[op].bitfield.reg8
		|| i.types[op].bitfield.reg16
		|| i.types[op].bitfield.reg32
		|| i.types[op].bitfield.reg64
		|| i.types[op].bitfield.regmmx
		|| i.types[op].bitfield.regxmm
		|| i.types[op].bitfield.regymm
		|| i.types[op].bitfield.regbnd
		|| i.types[op].bitfield.regzmm
		|| i.types[op].bitfield.regmask
		|| i.types[op].bitfield.sreg2
		|| i.types[op].bitfield.sreg3
		|| i.types[op].bitfield.control
		|| i.types[op].bitfield.debug
		|| i.types[op].bitfield.test)
	      break;

	  if (vex_3_sources)
	    op = dest;
	  else if (i.tm.opcode_modifier.vexvvvv == VEXXDS)
	    {
	      /* For instructions with VexNDS, the register-only
		 source operand is encoded in VEX prefix. */
	      gas_assert (mem != (unsigned int) ~0);

	      if (op > mem)
		{
		  vex_reg = op++;
		  gas_assert (op < i.operands);
		}
	      else
		{
		  /* Check register-only source operand when two source
		     operands are swapped.  */
		  if (!i.tm.operand_types[op].bitfield.baseindex
		      && i.tm.operand_types[op + 1].bitfield.baseindex)
		    {
		      vex_reg = op;
		      op += 2;
		      gas_assert (mem == (vex_reg + 1)
				  && op < i.operands);
		    }
		  else
		    {
		      vex_reg = op + 1;
		      gas_assert (vex_reg < i.operands);
		    }
		}
	    }
	  else if (i.tm.opcode_modifier.vexvvvv == VEXNDD)
	    {
	      /* For instructions with VexNDD, the register destination
		 is encoded in VEX prefix.  */
	      if (i.mem_operands == 0)
		{
		  /* There is no memory operand.  */
		  gas_assert ((op + 2) == i.operands);
		  vex_reg = op + 1;
		}
	      else
		{
		  /* There are only 2 operands.  */
		  gas_assert (op < 2 && i.operands == 2);
		  vex_reg = 1;
		}
	    }
	  else
	    gas_assert (op < i.operands);

	  if (vex_reg != (unsigned int) ~0)
	    {
	      i386_operand_type *type = &i.tm.operand_types[vex_reg];

	      if (type->bitfield.reg32 != 1
		  && type->bitfield.reg64 != 1
		  && !operand_type_equal (type, &regxmm)
		  && !operand_type_equal (type, &regymm)
		  && !operand_type_equal (type, &regzmm)
		  && !operand_type_equal (type, &regmask))
		abort ();

	      i.vex.register_specifier = i.op[vex_reg].regs;
	    }

	  /* Don't set OP operand twice.  */
	  if (vex_reg != op)
	    {
	      /* If there is an extension opcode to put here, the
		 register number must be put into the regmem field.  */
	      if (i.tm.extension_opcode != None)
		{
		  i.rm.regmem = i.op[op].regs->reg_num;
		  if ((i.op[op].regs->reg_flags & RegRex) != 0)
		    i.rex |= REX_B;
		  if ((i.op[op].regs->reg_flags & RegVRex) != 0)
		    i.vrex |= REX_B;
		}
	      else
		{
		  i.rm.reg = i.op[op].regs->reg_num;
		  if ((i.op[op].regs->reg_flags & RegRex) != 0)
		    i.rex |= REX_R;
		  if ((i.op[op].regs->reg_flags & RegVRex) != 0)
		    i.vrex |= REX_R;
		}
	    }

	  /* Now, if no memory operand has set i.rm.mode = 0, 1, 2 we
	     must set it to 3 to indicate this is a register operand
	     in the regmem field.  */
	  if (!i.mem_operands)
	    i.rm.mode = 3;
	}

      /* Fill in i.rm.reg field with extension opcode (if any).  */
      if (i.tm.extension_opcode != None)
	i.rm.reg = i.tm.extension_opcode;
    }
  return default_seg;
}

static void
output_branch (void)
{
  char *p;
  int size;
  int code16;
  int prefix;
  relax_substateT subtype;
  symbolS *sym;
  offsetT off;

  code16 = flag_code == CODE_16BIT ? CODE16 : 0;
  size = i.disp_encoding == disp_encoding_32bit ? BIG : SMALL;

  prefix = 0;
  if (i.prefix[DATA_PREFIX] != 0)
    {
      prefix = 1;
      i.prefixes -= 1;
      code16 ^= CODE16;
    }
  /* Pentium4 branch hints.  */
  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
    {
      prefix++;
      i.prefixes--;
    }
  if (i.prefix[REX_PREFIX] != 0)
    {
      prefix++;
      i.prefixes--;
    }

  /* BND prefixed jump.  */
  if (i.prefix[BND_PREFIX] != 0)
    {
      FRAG_APPEND_1_CHAR (i.prefix[BND_PREFIX]);
      i.prefixes -= 1;
    }

  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));

  /* It's always a symbol;  End frag & setup for relax.
     Make sure there is enough room in this frag for the largest
     instruction we may generate in md_convert_frag.  This is 2
     bytes for the opcode and room for the prefix and largest
     displacement.  */
  frag_grow (prefix + 2 + 4);
  /* Prefix and 1 opcode byte go in fr_fix.  */
  p = frag_more (prefix + 1);
  if (i.prefix[DATA_PREFIX] != 0)
    *p++ = DATA_PREFIX_OPCODE;
  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
    *p++ = i.prefix[SEG_PREFIX];
  if (i.prefix[REX_PREFIX] != 0)
    *p++ = i.prefix[REX_PREFIX];
  *p = i.tm.base_opcode;

  if ((unsigned char) *p == JUMP_PC_RELATIVE)
    subtype = ENCODE_RELAX_STATE (UNCOND_JUMP, size);
  else if (cpu_arch_flags.bitfield.cpui386)
    subtype = ENCODE_RELAX_STATE (COND_JUMP, size);
  else
    subtype = ENCODE_RELAX_STATE (COND_JUMP86, size);
  subtype |= code16;

  sym = i.op[0].disps->X_add_symbol;
  off = i.op[0].disps->X_add_number;

  if (i.op[0].disps->X_op != O_constant
      && i.op[0].disps->X_op != O_symbol)
    {
      /* Handle complex expressions.  */
      sym = make_expr_symbol (i.op[0].disps);
      off = 0;
    }

  /* 1 possible extra opcode + 4 byte displacement go in var part.
     Pass reloc in fr_var.  */
  frag_var (rs_machine_dependent, 5, i.reloc[0], subtype, sym, off, p);
}

static void
output_jump (void)
{
  char *p;
  int size;
  fixS *fixP;

  if (i.tm.opcode_modifier.jumpbyte)
    {
      /* This is a loop or jecxz type instruction.  */
      size = 1;
      if (i.prefix[ADDR_PREFIX] != 0)
	{
	  FRAG_APPEND_1_CHAR (ADDR_PREFIX_OPCODE);
	  i.prefixes -= 1;
	}
      /* Pentium4 branch hints.  */
      if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
	  || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	{
	  FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
	  i.prefixes--;
	}
    }
  else
    {
      int code16;

      code16 = 0;
      if (flag_code == CODE_16BIT)
	code16 = CODE16;

      if (i.prefix[DATA_PREFIX] != 0)
	{
	  FRAG_APPEND_1_CHAR (DATA_PREFIX_OPCODE);
	  i.prefixes -= 1;
	  code16 ^= CODE16;
	}

      size = 4;
      if (code16)
	size = 2;
    }

  if (i.prefix[REX_PREFIX] != 0)
    {
      FRAG_APPEND_1_CHAR (i.prefix[REX_PREFIX]);
      i.prefixes -= 1;
    }

  /* BND prefixed jump.  */
  if (i.prefix[BND_PREFIX] != 0)
    {
      FRAG_APPEND_1_CHAR (i.prefix[BND_PREFIX]);
      i.prefixes -= 1;
    }

  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));

  p = frag_more (i.tm.opcode_length + size);
  switch (i.tm.opcode_length)
    {
    case 2:
      *p++ = i.tm.base_opcode >> 8;
    case 1:
      *p++ = i.tm.base_opcode;
      break;
    default:
      abort ();
    }

  fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));

  /* All jumps handled here are signed, but don't use a signed limit
     check for 32 and 16 bit jumps as we want to allow wrap around at
     4G and 64k respectively.  */
  if (size == 1)
    fixP->fx_signed = 1;
}

static void
output_interseg_jump (void)
{
  char *p;
  int size;
  int prefix;
  int code16;

  code16 = 0;
  if (flag_code == CODE_16BIT)
    code16 = CODE16;

  prefix = 0;
  if (i.prefix[DATA_PREFIX] != 0)
    {
      prefix = 1;
      i.prefixes -= 1;
      code16 ^= CODE16;
    }
  if (i.prefix[REX_PREFIX] != 0)
    {
      prefix++;
      i.prefixes -= 1;
    }

  size = 4;
  if (code16)
    size = 2;

  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));

  /* 1 opcode; 2 segment; offset  */
  p = frag_more (prefix + 1 + 2 + size);

  if (i.prefix[DATA_PREFIX] != 0)
    *p++ = DATA_PREFIX_OPCODE;

  if (i.prefix[REX_PREFIX] != 0)
    *p++ = i.prefix[REX_PREFIX];

  *p++ = i.tm.base_opcode;
  if (i.op[1].imms->X_op == O_constant)
    {
      offsetT n = i.op[1].imms->X_add_number;

      if (size == 2
	  && !fits_in_unsigned_word (n)
	  && !fits_in_signed_word (n))
	{
	  as_bad (_("16-bit jump out of range"));
	  return;
	}
      md_number_to_chars (p, n, size);
    }
  else
    fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		 i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
  if (i.op[0].imms->X_op != O_constant)
    as_bad (_("can't handle non absolute segment in `%s'"),
	    i.tm.name);
  md_number_to_chars (p + size, (valueT) i.op[0].imms->X_add_number, 2);
}

static void
output_insn (void)
{
  fragS *insn_start_frag;
  offsetT insn_start_off;

  /* Tie dwarf2 debug info to the address at the start of the insn.
     We can't do this after the insn has been output as the current
     frag may have been closed off.  eg. by frag_var.  */
  dwarf2_emit_insn (0);

  insn_start_frag = frag_now;
  insn_start_off = frag_now_fix ();

  /* Output jumps.  */
  if (i.tm.opcode_modifier.jump)
    output_branch ();
  else if (i.tm.opcode_modifier.jumpbyte
	   || i.tm.opcode_modifier.jumpdword)
    output_jump ();
  else if (i.tm.opcode_modifier.jumpintersegment)
    output_interseg_jump ();
  else
    {
      /* Output normal instructions here.  */
      char *p;
      unsigned char *q;
      unsigned int j;
      unsigned int prefix;

      /* Since the VEX/EVEX prefix contains the implicit prefix, we
	 don't need the explicit prefix.  */
      if (!i.tm.opcode_modifier.vex && !i.tm.opcode_modifier.evex)
	{
	  switch (i.tm.opcode_length)
	    {
	    case 3:
	      if (i.tm.base_opcode & 0xff000000)
		{
		  prefix = (i.tm.base_opcode >> 24) & 0xff;
		  goto check_prefix;
		}
	      break;
	    case 2:
	      if ((i.tm.base_opcode & 0xff0000) != 0)
		{
		  prefix = (i.tm.base_opcode >> 16) & 0xff;
		  if (i.tm.cpu_flags.bitfield.cpupadlock)
		    {
check_prefix:
		      if (prefix != REPE_PREFIX_OPCODE
			  || (i.prefix[REP_PREFIX]
			      != REPE_PREFIX_OPCODE))
			add_prefix (prefix);
		    }
		  else
		    add_prefix (prefix);
		}
	      break;
	    case 1:
	      break;
	    default:
	      abort ();
	    }

	  /* The prefix bytes.  */
	  for (j = ARRAY_SIZE (i.prefix), q = i.prefix; j > 0; j--, q++)
	    if (*q)
	      FRAG_APPEND_1_CHAR (*q);
	}
      else
	{
	  for (j = 0, q = i.prefix; j < ARRAY_SIZE (i.prefix); j++, q++)
	    if (*q)
	      switch (j)
		{
		case REX_PREFIX:
		  /* REX byte is encoded in VEX prefix.  */
		  break;
		case SEG_PREFIX:
		case ADDR_PREFIX:
		  FRAG_APPEND_1_CHAR (*q);
		  break;
		default:
		  /* There should be no other prefixes for instructions
		     with VEX prefix.  */
		  abort ();
		}

	  /* For EVEX instructions i.vrex should become 0 after
	     build_evex_prefix.  For VEX instructions upper 16 registers
	     aren't available, so VREX should be 0.  */
	  if (i.vrex)
	    abort ();
	  /* Now the VEX prefix.  */
	  p = frag_more (i.vex.length);
	  for (j = 0; j < i.vex.length; j++)
	    p[j] = i.vex.bytes[j];
	}

      /* Now the opcode; be careful about word order here!  */
      if (i.tm.opcode_length == 1)
	{
	  FRAG_APPEND_1_CHAR (i.tm.base_opcode);
	}
      else
	{
	  switch (i.tm.opcode_length)
	    {
	    case 4:
	      p = frag_more (4);
	      *p++ = (i.tm.base_opcode >> 24) & 0xff;
	      *p++ = (i.tm.base_opcode >> 16) & 0xff;
	      break;
	    case 3:
	      p = frag_more (3);
	      *p++ = (i.tm.base_opcode >> 16) & 0xff;
	      break;
	    case 2:
	      p = frag_more (2);
	      break;
	    default:
	      abort ();
	      break;
	    }

	  /* Put out high byte first: can't use md_number_to_chars!  */
	  *p++ = (i.tm.base_opcode >> 8) & 0xff;
	  *p = i.tm.base_opcode & 0xff;
	}

      /* Now the modrm byte and sib byte (if present).  */
      if (i.tm.opcode_modifier.modrm)
	{
	  FRAG_APPEND_1_CHAR ((i.rm.regmem << 0
			       | i.rm.reg << 3
			       | i.rm.mode << 6));
	  /* If i.rm.regmem == ESP (4)
	     && i.rm.mode != (Register mode)
	     && not 16 bit
	     ==> need second modrm byte.  */
	  if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
	      && i.rm.mode != 3
	      && !(i.base_reg && i.base_reg->reg_type.bitfield.reg16))
	    FRAG_APPEND_1_CHAR ((i.sib.base << 0
				 | i.sib.index << 3
				 | i.sib.scale << 6));
	}

      if (i.disp_operands)
	output_disp (insn_start_frag, insn_start_off);

      if (i.imm_operands)
	output_imm (insn_start_frag, insn_start_off);
    }

#ifdef DEBUG386
  if (flag_debug)
    {
      pi ("" /*line*/, &i);
    }
#endif /* DEBUG386  */
}

/* Return the size of the displacement operand N.  */

static int
disp_size (unsigned int n)
{
  int size = 4;

  /* Vec_Disp8 has to be 8bit.  */
  if (i.types[n].bitfield.vec_disp8)
    size = 1;
  else if (i.types[n].bitfield.disp64)
    size = 8;
  else if (i.types[n].bitfield.disp8)
    size = 1;
  else if (i.types[n].bitfield.disp16)
    size = 2;
  return size;
}

/* Return the size of the immediate operand N.  */

static int
imm_size (unsigned int n)
{
  int size = 4;
  if (i.types[n].bitfield.imm64)
    size = 8;
  else if (i.types[n].bitfield.imm8 || i.types[n].bitfield.imm8s)
    size = 1;
  else if (i.types[n].bitfield.imm16)
    size = 2;
  return size;
}

static void
output_disp (fragS *insn_start_frag, offsetT insn_start_off)
{
  char *p;
  unsigned int n;

  for (n = 0; n < i.operands; n++)
    {
      if (i.types[n].bitfield.vec_disp8
	  || operand_type_check (i.types[n], disp))
	{
	  if (i.op[n].disps->X_op == O_constant)
	    {
	      int size = disp_size (n);
	      offsetT val = i.op[n].disps->X_add_number;

	      if (i.types[n].bitfield.vec_disp8)
		val >>= i.memshift;
	      val = offset_in_range (val, size);
	      p = frag_more (size);
	      md_number_to_chars (p, val, size);
	    }
	  else
	    {
	      enum bfd_reloc_code_real reloc_type;
	      int size = disp_size (n);
	      int sign = i.types[n].bitfield.disp32s;
	      int pcrel = (i.flags[n] & Operand_PCrel) != 0;

	      /* We can't have 8 bit displacement here.  */
	      gas_assert (!i.types[n].bitfield.disp8);

	      /* The PC relative address is computed relative
		 to the instruction boundary, so in case immediate
		 fields follows, we need to adjust the value.  */
	      if (pcrel && i.imm_operands)
		{
		  unsigned int n1;
		  int sz = 0;

		  for (n1 = 0; n1 < i.operands; n1++)
		    if (operand_type_check (i.types[n1], imm))
		      {
			/* Only one immediate is allowed for PC
			   relative address.  */
			gas_assert (sz == 0);
			sz = imm_size (n1);
			i.op[n].disps->X_add_number -= sz;
		      }
		  /* We should find the immediate.  */
		  gas_assert (sz != 0);
		}

	      p = frag_more (size);
	      reloc_type = reloc (size, pcrel, sign, i.reloc[n]);
	      if (GOT_symbol
		  && GOT_symbol == i.op[n].disps->X_add_symbol
		  && (((reloc_type == BFD_RELOC_32
			|| reloc_type == BFD_RELOC_X86_64_32S
			|| (reloc_type == BFD_RELOC_64
			    && object_64bit))
		       && (i.op[n].disps->X_op == O_symbol
			   || (i.op[n].disps->X_op == O_add
			       && ((symbol_get_value_expression
				    (i.op[n].disps->X_op_symbol)->X_op)
				   == O_subtract))))
		      || reloc_type == BFD_RELOC_32_PCREL))
		{
		  offsetT add;

		  if (insn_start_frag == frag_now)
		    add = (p - frag_now->fr_literal) - insn_start_off;
		  else
		    {
		      fragS *fr;

		      add = insn_start_frag->fr_fix - insn_start_off;
		      for (fr = insn_start_frag->fr_next;
			   fr && fr != frag_now; fr = fr->fr_next)
			add += fr->fr_fix;
		      add += p - frag_now->fr_literal;
		    }

		  if (!object_64bit)
		    {
		      reloc_type = BFD_RELOC_386_GOTPC;
		      i.op[n].imms->X_add_number += add;
		    }
		  else if (reloc_type == BFD_RELOC_64)
		    reloc_type = BFD_RELOC_X86_64_GOTPC64;
		  else
		    /* Don't do the adjustment for x86-64, as there
		       the pcrel addressing is relative to the _next_
		       insn, and that is taken care of in other code.  */
		    reloc_type = BFD_RELOC_X86_64_GOTPC32;
		}
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].disps, pcrel, reloc_type);
	    }
	}
    }
}

static void
output_imm (fragS *insn_start_frag, offsetT insn_start_off)
{
  char *p;
  unsigned int n;

  for (n = 0; n < i.operands; n++)
    {
      /* Skip SAE/RC Imm operand in EVEX.  They are already handled.  */
      if (i.rounding && (int) n == i.rounding->operand)
	continue;

      if (operand_type_check (i.types[n], imm))
	{
	  if (i.op[n].imms->X_op == O_constant)
	    {
	      int size = imm_size (n);
	      offsetT val;

	      val = offset_in_range (i.op[n].imms->X_add_number,
				     size);
	      p = frag_more (size);
	      md_number_to_chars (p, val, size);
	    }
	  else
	    {
	      /* Not absolute_section.
		 Need a 32-bit fixup (don't support 8bit
		 non-absolute imms).  Try to support other
		 sizes ...  */
	      enum bfd_reloc_code_real reloc_type;
	      int size = imm_size (n);
	      int sign;

	      if (i.types[n].bitfield.imm32s
		  && (i.suffix == QWORD_MNEM_SUFFIX
		      || (!i.suffix && i.tm.opcode_modifier.no_lsuf)))
		sign = 1;
	      else
		sign = 0;

	      p = frag_more (size);
	      reloc_type = reloc (size, 0, sign, i.reloc[n]);

	      /*   This is tough to explain.  We end up with this one if we
	       * have operands that look like
	       * "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal here is to
	       * obtain the absolute address of the GOT, and it is strongly
	       * preferable from a performance point of view to avoid using
	       * a runtime relocation for this.  The actual sequence of
	       * instructions often look something like:
	       *
	       *	call	.L66
	       * .L66:
	       *	popl	%ebx
	       *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
	       *
	       *   The call and pop essentially return the absolute address
	       * of the label .L66 and store it in %ebx.  The linker itself
	       * will ultimately change the first operand of the addl so
	       * that %ebx points to the GOT, but to keep things simple, the
	       * .o file must have this operand set so that it generates not
	       * the absolute address of .L66, but the absolute address of
	       * itself.  This allows the linker itself simply treat a GOTPC
	       * relocation as asking for a pcrel offset to the GOT to be
	       * added in, and the addend of the relocation is stored in the
	       * operand field for the instruction itself.
	       *
	       *   Our job here is to fix the operand so that it would add
	       * the correct offset so that %ebx would point to itself.  The
	       * thing that is tricky is that .-.L66 will point to the
	       * beginning of the instruction, so we need to further modify
	       * the operand so that it will point to itself.  There are
	       * other cases where you have something like:
	       *
	       *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
	       *
	       * and here no correction would be required.  Internally in
	       * the assembler we treat operands of this form as not being
	       * pcrel since the '.' is explicitly mentioned, and I wonder
	       * whether it would simplify matters to do it this way.  Who
	       * knows.  In earlier versions of the PIC patches, the
	       * pcrel_adjust field was used to store the correction, but
	       * since the expression is not pcrel, I felt it would be
	       * confusing to do it this way.  */

	      if ((reloc_type == BFD_RELOC_32
		   || reloc_type == BFD_RELOC_X86_64_32S
		   || reloc_type == BFD_RELOC_64)
		  && GOT_symbol
		  && GOT_symbol == i.op[n].imms->X_add_symbol
		  && (i.op[n].imms->X_op == O_symbol
		      || (i.op[n].imms->X_op == O_add
			  && ((symbol_get_value_expression
			       (i.op[n].imms->X_op_symbol)->X_op)
			      == O_subtract))))
		{
		  offsetT add;

		  if (insn_start_frag == frag_now)
		    add = (p - frag_now->fr_literal) - insn_start_off;
		  else
		    {
		      fragS *fr;

		      add = insn_start_frag->fr_fix - insn_start_off;
		      for (fr = insn_start_frag->fr_next;
			   fr && fr != frag_now; fr = fr->fr_next)
			add += fr->fr_fix;
		      add += p - frag_now->fr_literal;
		    }

		  if (!object_64bit)
		    reloc_type = BFD_RELOC_386_GOTPC;
		  else if (size == 4)
		    reloc_type = BFD_RELOC_X86_64_GOTPC32;
		  else if (size == 8)
		    reloc_type = BFD_RELOC_X86_64_GOTPC64;
		  i.op[n].imms->X_add_number += add;
		}
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].imms, 0, reloc_type);
	    }
	}
    }
}

/* x86_cons_fix_new is called via the expression parsing code when a
   reloc is needed.  We use this hook to get the correct .got reloc.  */
static enum bfd_reloc_code_real got_reloc = NO_RELOC;
static int cons_sign = -1;

void
x86_cons_fix_new (fragS *frag, unsigned int off, unsigned int len,
		  expressionS *exp)
{
  enum bfd_reloc_code_real r = reloc (len, 0, cons_sign, got_reloc);

  got_reloc = NO_RELOC;

#ifdef TE_PE
  if (exp->X_op == O_secrel)
    {
      exp->X_op = O_symbol;
      r = BFD_RELOC_32_SECREL;
    }
#endif

  fix_new_exp (frag, off, len, exp, 0, r);
}

/* Export the ABI address size for use by TC_ADDRESS_BYTES for the
   purpose of the `.dc.a' internal pseudo-op.  */

int
x86_address_bytes (void)
{
  if ((stdoutput->arch_info->mach & bfd_mach_x64_32))
    return 4;
  return stdoutput->arch_info->bits_per_address / 8;
}

#if !(defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (OBJ_MACH_O)) \
    || defined (LEX_AT)
# define lex_got(reloc, adjust, types) NULL
#else
/* Parse operands of the form
   <symbol>@@GOTOFF+<nnn>
   and similar .plt or .got references.

   If we find one, set up the correct relocation in RELOC and copy the
   input string, minus the `@@GOTOFF' into a malloc'd buffer for
   parsing by the calling routine.  Return this buffer, and if ADJUST
   is non-null set it to the length of the string we removed from the
   input line.  Otherwise return NULL.  */
static char *
lex_got (enum bfd_reloc_code_real *rel,
	 int *adjust,
	 i386_operand_type *types)
{
  /* Some of the relocations depend on the size of what field is to
     be relocated.  But in our callers i386_immediate and i386_displacement
     we don't yet know the operand size (this will be set by insn
     matching).  Hence we record the word32 relocation here,
     and adjust the reloc according to the real size in reloc().  */
  static const struct {
    const char *str;
    int len;
    const enum bfd_reloc_code_real rel[2];
    const i386_operand_type types64;
  } gotrel[] = {
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
    { STRING_COMMA_LEN ("SIZE"),      { BFD_RELOC_SIZE32,
					BFD_RELOC_SIZE32 },
      OPERAND_TYPE_IMM32_64 },
#endif
    { STRING_COMMA_LEN ("PLTOFF"),   { _dummy_first_bfd_reloc_code_real,
				       BFD_RELOC_X86_64_PLTOFF64 },
      OPERAND_TYPE_IMM64 },
    { STRING_COMMA_LEN ("PLT"),      { BFD_RELOC_386_PLT32,
				       BFD_RELOC_X86_64_PLT32    },
      OPERAND_TYPE_IMM32_32S_DISP32 },
    { STRING_COMMA_LEN ("GOTPLT"),   { _dummy_first_bfd_reloc_code_real,
				       BFD_RELOC_X86_64_GOTPLT64 },
      OPERAND_TYPE_IMM64_DISP64 },
    { STRING_COMMA_LEN ("GOTOFF"),   { BFD_RELOC_386_GOTOFF,
				       BFD_RELOC_X86_64_GOTOFF64 },
      OPERAND_TYPE_IMM64_DISP64 },
    { STRING_COMMA_LEN ("GOTPCREL"), { _dummy_first_bfd_reloc_code_real,
				       BFD_RELOC_X86_64_GOTPCREL },
      OPERAND_TYPE_IMM32_32S_DISP32 },
    { STRING_COMMA_LEN ("TLSGD"),    { BFD_RELOC_386_TLS_GD,
				       BFD_RELOC_X86_64_TLSGD    },
      OPERAND_TYPE_IMM32_32S_DISP32 },
    { STRING_COMMA_LEN ("TLSLDM"),   { BFD_RELOC_386_TLS_LDM,
				       _dummy_first_bfd_reloc_code_real },
      OPERAND_TYPE_NONE },
    { STRING_COMMA_LEN ("TLSLD"),    { _dummy_first_bfd_reloc_code_real,
				       BFD_RELOC_X86_64_TLSLD    },
      OPERAND_TYPE_IMM32_32S_DISP32 },
    { STRING_COMMA_LEN ("GOTTPOFF"), { BFD_RELOC_386_TLS_IE_32,
				       BFD_RELOC_X86_64_GOTTPOFF },
      OPERAND_TYPE_IMM32_32S_DISP32 },
    { STRING_COMMA_LEN ("TPOFF"),    { BFD_RELOC_386_TLS_LE_32,
				       BFD_RELOC_X86_64_TPOFF32  },
      OPERAND_TYPE_IMM32_32S_64_DISP32_64 },
    { STRING_COMMA_LEN ("NTPOFF"),   { BFD_RELOC_386_TLS_LE,
				       _dummy_first_bfd_reloc_code_real },
      OPERAND_TYPE_NONE },
    { STRING_COMMA_LEN ("DTPOFF"),   { BFD_RELOC_386_TLS_LDO_32,
				       BFD_RELOC_X86_64_DTPOFF32 },
      OPERAND_TYPE_IMM32_32S_64_DISP32_64 },
    { STRING_COMMA_LEN ("GOTNTPOFF"),{ BFD_RELOC_386_TLS_GOTIE,
				       _dummy_first_bfd_reloc_code_real },
      OPERAND_TYPE_NONE },
    { STRING_COMMA_LEN ("INDNTPOFF"),{ BFD_RELOC_386_TLS_IE,
				       _dummy_first_bfd_reloc_code_real },
      OPERAND_TYPE_NONE },
    { STRING_COMMA_LEN ("GOT"),      { BFD_RELOC_386_GOT32,
				       BFD_RELOC_X86_64_GOT32    },
      OPERAND_TYPE_IMM32_32S_64_DISP32 },
    { STRING_COMMA_LEN ("TLSDESC"),  { BFD_RELOC_386_TLS_GOTDESC,
				       BFD_RELOC_X86_64_GOTPC32_TLSDESC },
      OPERAND_TYPE_IMM32_32S_DISP32 },
    { STRING_COMMA_LEN ("TLSCALL"),  { BFD_RELOC_386_TLS_DESC_CALL,
				       BFD_RELOC_X86_64_TLSDESC_CALL },
      OPERAND_TYPE_IMM32_32S_DISP32 },
  };
  char *cp;
  unsigned int j;

#if defined (OBJ_MAYBE_ELF)
  if (!IS_ELF)
    return NULL;
#endif

  for (cp = input_line_pointer; *cp != '@@'; cp++)
    if (is_end_of_line[(unsigned char) *cp] || *cp == ',')
      return NULL;

  for (j = 0; j < ARRAY_SIZE (gotrel); j++)
    {
      int len = gotrel[j].len;
      if (strncasecmp (cp + 1, gotrel[j].str, len) == 0)
	{
	  if (gotrel[j].rel[object_64bit] != 0)
	    {
	      int first, second;
	      char *tmpbuf, *past_reloc;

	      *rel = gotrel[j].rel[object_64bit];

	      if (types)
		{
		  if (flag_code != CODE_64BIT)
		    {
		      types->bitfield.imm32 = 1;
		      types->bitfield.disp32 = 1;
		    }
		  else
		    *types = gotrel[j].types64;
		}

	      if (j != 0 && GOT_symbol == NULL)
		GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	      /* The length of the first part of our input line.  */
	      first = cp - input_line_pointer;

	      /* The second part goes from after the reloc token until
		 (and including) an end_of_line char or comma.  */
	      past_reloc = cp + 1 + len;
	      cp = past_reloc;
	      while (!is_end_of_line[(unsigned char) *cp] && *cp != ',')
		++cp;
	      second = cp + 1 - past_reloc;

	      /* Allocate and copy string.  The trailing NUL shouldn't
		 be necessary, but be safe.  */
	      tmpbuf = (char *) xmalloc (first + second + 2);
	      memcpy (tmpbuf, input_line_pointer, first);
	      if (second != 0 && *past_reloc != ' ')
		/* Replace the relocation token with ' ', so that
		   errors like foo@@GOTOFF1 will be detected.  */
		tmpbuf[first++] = ' ';
	      else
		/* Increment length by 1 if the relocation token is
		   removed.  */
		len++;
	      if (adjust)
		*adjust = len;
	      memcpy (tmpbuf + first, past_reloc, second);
	      tmpbuf[first + second] = '\0';
	      return tmpbuf;
	    }

	  as_bad (_("@@%s reloc is not supported with %d-bit output format"),
		  gotrel[j].str, 1 << (5 + object_64bit));
	  return NULL;
	}
    }

  /* Might be a symbol version string.  Don't as_bad here.  */
  return NULL;
}
#endif

#ifdef TE_PE
#ifdef lex_got
#undef lex_got
#endif
/* Parse operands of the form
   <symbol>@@SECREL32+<nnn>

   If we find one, set up the correct relocation in RELOC and copy the
   input string, minus the `@@SECREL32' into a malloc'd buffer for
   parsing by the calling routine.  Return this buffer, and if ADJUST
   is non-null set it to the length of the string we removed from the
   input line.  Otherwise return NULL.

   This function is copied from the ELF version above adjusted for PE targets.  */

static char *
lex_got (enum bfd_reloc_code_real *rel ATTRIBUTE_UNUSED,
	 int *adjust ATTRIBUTE_UNUSED,
	 i386_operand_type *types ATTRIBUTE_UNUSED)
{
  static const struct
  {
    const char *str;
    int len;
    const enum bfd_reloc_code_real rel[2];
    const i386_operand_type types64;
  }
  gotrel[] =
  {
    { STRING_COMMA_LEN ("SECREL32"),    { BFD_RELOC_32_SECREL,
					  BFD_RELOC_32_SECREL },
      OPERAND_TYPE_IMM32_32S_64_DISP32_64 },
  };

  char *cp;
  unsigned j;

  for (cp = input_line_pointer; *cp != '@@'; cp++)
    if (is_end_of_line[(unsigned char) *cp] || *cp == ',')
      return NULL;

  for (j = 0; j < ARRAY_SIZE (gotrel); j++)
    {
      int len = gotrel[j].len;

      if (strncasecmp (cp + 1, gotrel[j].str, len) == 0)
	{
	  if (gotrel[j].rel[object_64bit] != 0)
	    {
	      int first, second;
	      char *tmpbuf, *past_reloc;

	      *rel = gotrel[j].rel[object_64bit];
	      if (adjust)
		*adjust = len;

	      if (types)
		{
		  if (flag_code != CODE_64BIT)
		    {
		      types->bitfield.imm32 = 1;
		      types->bitfield.disp32 = 1;
		    }
		  else
		    *types = gotrel[j].types64;
		}

	      /* The length of the first part of our input line.  */
	      first = cp - input_line_pointer;

	      /* The second part goes from after the reloc token until
		 (and including) an end_of_line char or comma.  */
	      past_reloc = cp + 1 + len;
	      cp = past_reloc;
	      while (!is_end_of_line[(unsigned char) *cp] && *cp != ',')
		++cp;
	      second = cp + 1 - past_reloc;

	      /* Allocate and copy string.  The trailing NUL shouldn't
		 be necessary, but be safe.  */
	      tmpbuf = (char *) xmalloc (first + second + 2);
	      memcpy (tmpbuf, input_line_pointer, first);
	      if (second != 0 && *past_reloc != ' ')
		/* Replace the relocation token with ' ', so that
		   errors like foo@@SECLREL321 will be detected.  */
		tmpbuf[first++] = ' ';
	      memcpy (tmpbuf + first, past_reloc, second);
	      tmpbuf[first + second] = '\0';
	      return tmpbuf;
	    }

	  as_bad (_("@@%s reloc is not supported with %d-bit output format"),
		  gotrel[j].str, 1 << (5 + object_64bit));
	  return NULL;
	}
    }

  /* Might be a symbol version string.  Don't as_bad here.  */
  return NULL;
}

#endif /* TE_PE */

void
x86_cons (expressionS *exp, int size)
{
  intel_syntax = -intel_syntax;

  exp->X_md = 0;
  if (size == 4 || (object_64bit && size == 8))
    {
      /* Handle @@GOTOFF and the like in an expression.  */
      char *save;
      char *gotfree_input_line;
      int adjust = 0;

      save = input_line_pointer;
      gotfree_input_line = lex_got (&got_reloc, &adjust, NULL);
      if (gotfree_input_line)
	input_line_pointer = gotfree_input_line;

      expression (exp);

      if (gotfree_input_line)
	{
	  /* expression () has merrily parsed up to the end of line,
	     or a comma - in the wrong buffer.  Transfer how far
	     input_line_pointer has moved to the right buffer.  */
	  input_line_pointer = (save
				+ (input_line_pointer - gotfree_input_line)
				+ adjust);
	  free (gotfree_input_line);
	  if (exp->X_op == O_constant
	      || exp->X_op == O_absent
	      || exp->X_op == O_illegal
	      || exp->X_op == O_register
	      || exp->X_op == O_big)
	    {
	      char c = *input_line_pointer;
	      *input_line_pointer = 0;
	      as_bad (_("missing or invalid expression `%s'"), save);
	      *input_line_pointer = c;
	    }
	}
    }
  else
    expression (exp);

  intel_syntax = -intel_syntax;

  if (intel_syntax)
    i386_intel_simplify (exp);
}

static void
signed_cons (int size)
{
  if (flag_code == CODE_64BIT)
    cons_sign = 1;
  cons (size);
  cons_sign = -1;
}

#ifdef TE_PE
static void
pe_directive_secrel (int dummy ATTRIBUTE_UNUSED)
{
  expressionS exp;

  do
    {
      expression (&exp);
      if (exp.X_op == O_symbol)
	exp.X_op = O_secrel;

      emit_expr (&exp, 4);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;
  demand_empty_rest_of_line ();
}
#endif

/* Handle Vector operations.  */

static char *
check_VecOperations (char *op_string, char *op_end)
{
  const reg_entry *mask;
  const char *saved;
  char *end_op;

  while (*op_string
	 && (op_end == NULL || op_string < op_end))
    {
      saved = op_string;
      if (*op_string == '{')
	{
	  op_string++;

	  /* Check broadcasts.  */
	  if (strncmp (op_string, "1to", 3) == 0)
	    {
	      int bcst_type;

	      if (i.broadcast)
		goto duplicated_vec_op;

	      op_string += 3;
	      if (*op_string == '8')
		bcst_type = BROADCAST_1TO8;
	      else if (*op_string == '1'
		       && *(op_string+1) == '6')
		{
		  bcst_type = BROADCAST_1TO16;
		  op_string++;
		}
	      else
		{
		  as_bad (_("Unsupported broadcast: `%s'"), saved);
		  return NULL;
		}
	      op_string++;

	      broadcast_op.type = bcst_type;
	      broadcast_op.operand = this_operand;
	      i.broadcast = &broadcast_op;
	    }
	  /* Check masking operation.  */
	  else if ((mask = parse_register (op_string, &end_op)) != NULL)
	    {
	      /* k0 can't be used for write mask.  */
	      if (mask->reg_num == 0)
		{
		  as_bad (_("`%s' can't be used for write mask"),
			  op_string);
		  return NULL;
		}

	      if (!i.mask)
		{
		  mask_op.mask = mask;
		  mask_op.zeroing = 0;
		  mask_op.operand = this_operand;
		  i.mask = &mask_op;
		}
	      else
		{
		  if (i.mask->mask)
		    goto duplicated_vec_op;

		  i.mask->mask = mask;

		  /* Only "{z}" is allowed here.  No need to check
		     zeroing mask explicitly.  */
		  if (i.mask->operand != this_operand)
		    {
		      as_bad (_("invalid write mask `%s'"), saved);
		      return NULL;
		    }
		}

	      op_string = end_op;
	    }
	  /* Check zeroing-flag for masking operation.  */
	  else if (*op_string == 'z')
	    {
	      if (!i.mask)
		{
		  mask_op.mask = NULL;
		  mask_op.zeroing = 1;
		  mask_op.operand = this_operand;
		  i.mask = &mask_op;
		}
	      else
		{
		  if (i.mask->zeroing)
		    {
		    duplicated_vec_op:
		      as_bad (_("duplicated `%s'"), saved);
		      return NULL;
		    }

		  i.mask->zeroing = 1;

		  /* Only "{%k}" is allowed here.  No need to check mask
		     register explicitly.  */
		  if (i.mask->operand != this_operand)
		    {
		      as_bad (_("invalid zeroing-masking `%s'"),
			      saved);
		      return NULL;
		    }
		}

	      op_string++;
	    }
	  else
	    goto unknown_vec_op;

	  if (*op_string != '}')
	    {
	      as_bad (_("missing `}' in `%s'"), saved);
	      return NULL;
	    }
	  op_string++;
	  continue;
	}
    unknown_vec_op:
      /* We don't know this one.  */
      as_bad (_("unknown vector operation: `%s'"), saved);
      return NULL;
    }

  return op_string;
}

static int
i386_immediate (char *imm_start)
{
  char *save_input_line_pointer;
  char *gotfree_input_line;
  segT exp_seg = 0;
  expressionS *exp;
  i386_operand_type types;

  operand_type_set (&types, ~0);

  if (i.imm_operands == MAX_IMMEDIATE_OPERANDS)
    {
      as_bad (_("at most %d immediate operands are allowed"),
	      MAX_IMMEDIATE_OPERANDS);
      return 0;
    }

  exp = &im_expressions[i.imm_operands++];
  i.op[this_operand].imms = exp;

  if (is_space_char (*imm_start))
    ++imm_start;

  save_input_line_pointer = input_line_pointer;
  input_line_pointer = imm_start;

  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL, &types);
  if (gotfree_input_line)
    input_line_pointer = gotfree_input_line;

  exp_seg = expression (exp);

  SKIP_WHITESPACE ();

  /* Handle vector operations.  */
  if (*input_line_pointer == '{')
    {
      input_line_pointer = check_VecOperations (input_line_pointer,
						NULL);
      if (input_line_pointer == NULL)
	return 0;
    }

  if (*input_line_pointer)
    as_bad (_("junk `%s' after expression"), input_line_pointer);

  input_line_pointer = save_input_line_pointer;
  if (gotfree_input_line)
    {
      free (gotfree_input_line);

      if (exp->X_op == O_constant || exp->X_op == O_register)
	exp->X_op = O_illegal;
    }

  return i386_finalize_immediate (exp_seg, exp, types, imm_start);
}

static int
i386_finalize_immediate (segT exp_seg ATTRIBUTE_UNUSED, expressionS *exp,
			 i386_operand_type types, const char *imm_start)
{
  if (exp->X_op == O_absent || exp->X_op == O_illegal || exp->X_op == O_big)
    {
      if (imm_start)
	as_bad (_("missing or invalid immediate expression `%s'"),
		imm_start);
      return 0;
    }
  else if (exp->X_op == O_constant)
    {
      /* Size it properly later.  */
      i.types[this_operand].bitfield.imm64 = 1;
      /* If not 64bit, sign extend val.  */
      if (flag_code != CODE_64BIT
	  && (exp->X_add_number & ~(((addressT) 2 << 31) - 1)) == 0)
	exp->X_add_number
	  = (exp->X_add_number ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);
    }
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  else if (OUTPUT_FLAVOR == bfd_target_aout_flavour
	   && exp_seg != absolute_section
	   && exp_seg != text_section
	   && exp_seg != data_section
	   && exp_seg != bss_section
	   && exp_seg != undefined_section
	   && !bfd_is_com_section (exp_seg))
    {
      as_bad (_("unimplemented segment %s in operand"), exp_seg->name);
      return 0;
    }
#endif
  else if (!intel_syntax && exp->X_op == O_register)
    {
      if (imm_start)
	as_bad (_("illegal immediate register operand %s"), imm_start);
      return 0;
    }
  else
    {
      /* This is an address.  The size of the address will be
	 determined later, depending on destination register,
	 suffix, or the default for the section.  */
      i.types[this_operand].bitfield.imm8 = 1;
      i.types[this_operand].bitfield.imm16 = 1;
      i.types[this_operand].bitfield.imm32 = 1;
      i.types[this_operand].bitfield.imm32s = 1;
      i.types[this_operand].bitfield.imm64 = 1;
      i.types[this_operand] = operand_type_and (i.types[this_operand],
						types);
    }

  return 1;
}

static char *
i386_scale (char *scale)
{
  offsetT val;
  char *save = input_line_pointer;

  input_line_pointer = scale;
  val = get_absolute_expression ();

  switch (val)
    {
    case 1:
      i.log2_scale_factor = 0;
      break;
    case 2:
      i.log2_scale_factor = 1;
      break;
    case 4:
      i.log2_scale_factor = 2;
      break;
    case 8:
      i.log2_scale_factor = 3;
      break;
    default:
      {
	char sep = *input_line_pointer;

	*input_line_pointer = '\0';
	as_bad (_("expecting scale factor of 1, 2, 4, or 8: got `%s'"),
		scale);
	*input_line_pointer = sep;
	input_line_pointer = save;
	return NULL;
      }
    }
  if (i.log2_scale_factor != 0 && i.index_reg == 0)
    {
      as_warn (_("scale factor of %d without an index register"),
	       1 << i.log2_scale_factor);
      i.log2_scale_factor = 0;
    }
  scale = input_line_pointer;
  input_line_pointer = save;
  return scale;
}

static int
i386_displacement (char *disp_start, char *disp_end)
{
  expressionS *exp;
  segT exp_seg = 0;
  char *save_input_line_pointer;
  char *gotfree_input_line;
  int override;
  i386_operand_type bigdisp, types = anydisp;
  int ret;

  if (i.disp_operands == MAX_MEMORY_OPERANDS)
    {
      as_bad (_("at most %d displacement operands are allowed"),
	      MAX_MEMORY_OPERANDS);
      return 0;
    }

  operand_type_set (&bigdisp, 0);
  if ((i.types[this_operand].bitfield.jumpabsolute)
      || (!current_templates->start->opcode_modifier.jump
	  && !current_templates->start->opcode_modifier.jumpdword))
    {
      bigdisp.bitfield.disp32 = 1;
      override = (i.prefix[ADDR_PREFIX] != 0);
      if (flag_code == CODE_64BIT)
	{
	  if (!override)
	    {
	      bigdisp.bitfield.disp32s = 1;
	      bigdisp.bitfield.disp64 = 1;
	    }
	}
      else if ((flag_code == CODE_16BIT) ^ override)
	{
	  bigdisp.bitfield.disp32 = 0;
	  bigdisp.bitfield.disp16 = 1;
	}
    }
  else
    {
      /* For PC-relative branches, the width of the displacement
	 is dependent upon data size, not address size.  */
      override = (i.prefix[DATA_PREFIX] != 0);
      if (flag_code == CODE_64BIT)
	{
	  if (override || i.suffix == WORD_MNEM_SUFFIX)
	    bigdisp.bitfield.disp16 = 1;
	  else
	    {
	      bigdisp.bitfield.disp32 = 1;
	      bigdisp.bitfield.disp32s = 1;
	    }
	}
      else
	{
	  if (!override)
	    override = (i.suffix == (flag_code != CODE_16BIT
				     ? WORD_MNEM_SUFFIX
				     : LONG_MNEM_SUFFIX));
	  bigdisp.bitfield.disp32 = 1;
	  if ((flag_code == CODE_16BIT) ^ override)
	    {
	      bigdisp.bitfield.disp32 = 0;
	      bigdisp.bitfield.disp16 = 1;
	    }
	}
    }
  i.types[this_operand] = operand_type_or (i.types[this_operand],
					   bigdisp);

  exp = &disp_expressions[i.disp_operands];
  i.op[this_operand].disps = exp;
  i.disp_operands++;
  save_input_line_pointer = input_line_pointer;
  input_line_pointer = disp_start;
  END_STRING_AND_SAVE (disp_end);

#ifndef GCC_ASM_O_HACK
#define GCC_ASM_O_HACK 0
#endif
#if GCC_ASM_O_HACK
  END_STRING_AND_SAVE (disp_end + 1);
  if (i.types[this_operand].bitfield.baseIndex
      && displacement_string_end[-1] == '+')
    {
      /* This hack is to avoid a warning when using the "o"
	 constraint within gcc asm statements.
	 For instance:

	 #define _set_tssldt_desc(n,addr,limit,type) \
	 __asm__ __volatile__ ( \
	 "movw %w2,%0\n\t" \
	 "movw %w1,2+%0\n\t" \
	 "rorl $16,%1\n\t" \
	 "movb %b1,4+%0\n\t" \
	 "movb %4,5+%0\n\t" \
	 "movb $0,6+%0\n\t" \
	 "movb %h1,7+%0\n\t" \
	 "rorl $16,%1" \
	 : "=o"(*(n)) : "q" (addr), "ri"(limit), "i"(type))

	 This works great except that the output assembler ends
	 up looking a bit weird if it turns out that there is
	 no offset.  You end up producing code that looks like:

	 #APP
	 movw $235,(%eax)
	 movw %dx,2+(%eax)
	 rorl $16,%edx
	 movb %dl,4+(%eax)
	 movb $137,5+(%eax)
	 movb $0,6+(%eax)
	 movb %dh,7+(%eax)
	 rorl $16,%edx
	 #NO_APP

	 So here we provide the missing zero.  */

      *displacement_string_end = '0';
    }
#endif
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL, &types);
  if (gotfree_input_line)
    input_line_pointer = gotfree_input_line;

  exp_seg = expression (exp);

  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("junk `%s' after expression"), input_line_pointer);
#if GCC_ASM_O_HACK
  RESTORE_END_STRING (disp_end + 1);
#endif
  input_line_pointer = save_input_line_pointer;
  if (gotfree_input_line)
    {
      free (gotfree_input_line);

      if (exp->X_op == O_constant || exp->X_op == O_register)
	exp->X_op = O_illegal;
    }

  ret = i386_finalize_displacement (exp_seg, exp, types, disp_start);

  RESTORE_END_STRING (disp_end);

  return ret;
}

static int
i386_finalize_displacement (segT exp_seg ATTRIBUTE_UNUSED, expressionS *exp,
			    i386_operand_type types, const char *disp_start)
{
  i386_operand_type bigdisp;
  int ret = 1;

  /* We do this to make sure that the section symbol is in
     the symbol table.  We will ultimately change the relocation
     to be relative to the beginning of the section.  */
  if (i.reloc[this_operand] == BFD_RELOC_386_GOTOFF
      || i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL
      || i.reloc[this_operand] == BFD_RELOC_X86_64_GOTOFF64)
    {
      if (exp->X_op != O_symbol)
	goto inv_disp;

      if (S_IS_LOCAL (exp->X_add_symbol)
	  && S_GET_SEGMENT (exp->X_add_symbol) != undefined_section
	  && S_GET_SEGMENT (exp->X_add_symbol) != expr_section)
	section_symbol (S_GET_SEGMENT (exp->X_add_symbol));
      exp->X_op = O_subtract;
      exp->X_op_symbol = GOT_symbol;
      if (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
	i.reloc[this_operand] = BFD_RELOC_32_PCREL;
      else if (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTOFF64)
	i.reloc[this_operand] = BFD_RELOC_64;
      else
	i.reloc[this_operand] = BFD_RELOC_32;
    }

  else if (exp->X_op == O_absent
	   || exp->X_op == O_illegal
	   || exp->X_op == O_big)
    {
    inv_disp:
      as_bad (_("missing or invalid displacement expression `%s'"),
	      disp_start);
      ret = 0;
    }

  else if (flag_code == CODE_64BIT
	   && !i.prefix[ADDR_PREFIX]
	   && exp->X_op == O_constant)
    {
      /* Since displacement is signed extended to 64bit, don't allow
	 disp32 and turn off disp32s if they are out of range.  */
      i.types[this_operand].bitfield.disp32 = 0;
      if (!fits_in_signed_long (exp->X_add_number))
	{
	  i.types[this_operand].bitfield.disp32s = 0;
	  if (i.types[this_operand].bitfield.baseindex)
	    {
	      as_bad (_("0x%lx out range of signed 32bit displacement"),
		      (long) exp->X_add_number);
	      ret = 0;
	    }
	}
    }

#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  else if (exp->X_op != O_constant
	   && OUTPUT_FLAVOR == bfd_target_aout_flavour
	   && exp_seg != absolute_section
	   && exp_seg != text_section
	   && exp_seg != data_section
	   && exp_seg != bss_section
	   && exp_seg != undefined_section
	   && !bfd_is_com_section (exp_seg))
    {
      as_bad (_("unimplemented segment %s in operand"), exp_seg->name);
      ret = 0;
    }
#endif

  /* Check if this is a displacement only operand.  */
  bigdisp = i.types[this_operand];
  bigdisp.bitfield.disp8 = 0;
  bigdisp.bitfield.disp16 = 0;
  bigdisp.bitfield.disp32 = 0;
  bigdisp.bitfield.disp32s = 0;
  bigdisp.bitfield.disp64 = 0;
  if (operand_type_all_zero (&bigdisp))
    i.types[this_operand] = operand_type_and (i.types[this_operand],
					      types);

  return ret;
}

/* Make sure the memory operand we've been dealt is valid.
   Return 1 on success, 0 on a failure.  */

static int
i386_index_check (const char *operand_string)
{
  const char *kind = "base/index";
  enum flag_code addr_mode;

  if (i.prefix[ADDR_PREFIX])
    addr_mode = flag_code == CODE_32BIT ? CODE_16BIT : CODE_32BIT;
  else
    {
      addr_mode = flag_code;

#if INFER_ADDR_PREFIX
      if (i.mem_operands == 0)
	{
	  /* Infer address prefix from the first memory operand.  */
	  const reg_entry *addr_reg = i.base_reg;

	  if (addr_reg == NULL)
	    addr_reg = i.index_reg;

	  if (addr_reg)
	    {
	      if (addr_reg->reg_num == RegEip
		  || addr_reg->reg_num == RegEiz
		  || addr_reg->reg_type.bitfield.reg32)
		addr_mode = CODE_32BIT;
	      else if (flag_code != CODE_64BIT
		       && addr_reg->reg_type.bitfield.reg16)
		addr_mode = CODE_16BIT;

	      if (addr_mode != flag_code)
		{
		  i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
		  i.prefixes += 1;
		  /* Change the size of any displacement too.  At most one
		     of Disp16 or Disp32 is set.
		     FIXME.  There doesn't seem to be any real need for
		     separate Disp16 and Disp32 flags.  The same goes for
		     Imm16 and Imm32.  Removing them would probably clean
		     up the code quite a lot.  */
		  if (flag_code != CODE_64BIT
		      && (i.types[this_operand].bitfield.disp16
			  || i.types[this_operand].bitfield.disp32))
		    i.types[this_operand]
		      = operand_type_xor (i.types[this_operand], disp16_32);
		}
	    }
	}
#endif
    }

  if (current_templates->start->opcode_modifier.isstring
      && !current_templates->start->opcode_modifier.immext
      && (current_templates->end[-1].opcode_modifier.isstring
	  || i.mem_operands))
    {
      /* Memory operands of string insns are special in that they only allow
	 a single register (rDI, rSI, or rBX) as their memory address.  */
      const reg_entry *expected_reg;
      static const char *di_si[][2] =
	{
	  { "esi", "edi" },
	  { "si", "di" },
	  { "rsi", "rdi" }
	};
      static const char *bx[] = { "ebx", "bx", "rbx" };

      kind = "string address";

      if (current_templates->start->opcode_modifier.w)
	{
	  i386_operand_type type = current_templates->end[-1].operand_types[0];

	  if (!type.bitfield.baseindex
	      || ((!i.mem_operands != !intel_syntax)
		  && current_templates->end[-1].operand_types[1]
		     .bitfield.baseindex))
	    type = current_templates->end[-1].operand_types[1];
	  expected_reg = hash_find (reg_hash,
				    di_si[addr_mode][type.bitfield.esseg]);

	}
      else
	expected_reg = hash_find (reg_hash, bx[addr_mode]);

      if (i.base_reg != expected_reg
	  || i.index_reg
	  || operand_type_check (i.types[this_operand], disp))
	{
	  /* The second memory operand must have the same size as
	     the first one.  */
	  if (i.mem_operands
	      && i.base_reg
	      && !((addr_mode == CODE_64BIT
		    && i.base_reg->reg_type.bitfield.reg64)
		   || (addr_mode == CODE_32BIT
		       ? i.base_reg->reg_type.bitfield.reg32
		       : i.base_reg->reg_type.bitfield.reg16)))
	    goto bad_address;

	  as_warn (_("`%s' is not valid here (expected `%c%s%s%c')"),
		   operand_string,
		   intel_syntax ? '[' : '(',
		   register_prefix,
		   expected_reg->reg_name,
		   intel_syntax ? ']' : ')');
	  return 1;
	}
      else
	return 1;

bad_address:
      as_bad (_("`%s' is not a valid %s expression"),
	      operand_string, kind);
      return 0;
    }
  else
    {
      if (addr_mode != CODE_16BIT)
	{
	  /* 32-bit/64-bit checks.  */
	  if ((i.base_reg
	       && (addr_mode == CODE_64BIT
		   ? !i.base_reg->reg_type.bitfield.reg64
		   : !i.base_reg->reg_type.bitfield.reg32)
	       && (i.index_reg
		   || (i.base_reg->reg_num
		       != (addr_mode == CODE_64BIT ? RegRip : RegEip))))
	      || (i.index_reg
		  && !i.index_reg->reg_type.bitfield.regxmm
		  && !i.index_reg->reg_type.bitfield.regymm
		  && !i.index_reg->reg_type.bitfield.regzmm
		  && ((addr_mode == CODE_64BIT
		       ? !(i.index_reg->reg_type.bitfield.reg64
			   || i.index_reg->reg_num == RegRiz)
		       : !(i.index_reg->reg_type.bitfield.reg32
			   || i.index_reg->reg_num == RegEiz))
		      || !i.index_reg->reg_type.bitfield.baseindex)))
	    goto bad_address;
	}
      else
	{
	  /* 16-bit checks.  */
	  if ((i.base_reg
	       && (!i.base_reg->reg_type.bitfield.reg16
		   || !i.base_reg->reg_type.bitfield.baseindex))
	      || (i.index_reg
		  && (!i.index_reg->reg_type.bitfield.reg16
		      || !i.index_reg->reg_type.bitfield.baseindex
		      || !(i.base_reg
			   && i.base_reg->reg_num < 6
			   && i.index_reg->reg_num >= 6
			   && i.log2_scale_factor == 0))))
	    goto bad_address;
	}
    }
  return 1;
}

/* Handle vector immediates.  */

static int
RC_SAE_immediate (const char *imm_start)
{
  unsigned int match_found, j;
  const char *pstr = imm_start;
  expressionS *exp;

  if (*pstr != '{')
    return 0;

  pstr++;
  match_found = 0;
  for (j = 0; j < ARRAY_SIZE (RC_NamesTable); j++)
    {
      if (!strncmp (pstr, RC_NamesTable[j].name, RC_NamesTable[j].len))
	{
	  if (!i.rounding)
	    {
	      rc_op.type = RC_NamesTable[j].type;
	      rc_op.operand = this_operand;
	      i.rounding = &rc_op;
	    }
	  else
	    {
	      as_bad (_("duplicated `%s'"), imm_start);
	      return 0;
	    }
	  pstr += RC_NamesTable[j].len;
	  match_found = 1;
	  break;
	}
    }
  if (!match_found)
    return 0;

  if (*pstr++ != '}')
    {
      as_bad (_("Missing '}': '%s'"), imm_start);
      return 0;
    }
  /* RC/SAE immediate string should contain nothing more.  */;
  if (*pstr != 0)
    {
      as_bad (_("Junk after '}': '%s'"), imm_start);
      return 0;
    }

  exp = &im_expressions[i.imm_operands++];
  i.op[this_operand].imms = exp;

  exp->X_op = O_constant;
  exp->X_add_number = 0;
  exp->X_add_symbol = (symbolS *) 0;
  exp->X_op_symbol = (symbolS *) 0;

  i.types[this_operand].bitfield.imm8 = 1;
  return 1;
}

/* Parse OPERAND_STRING into the i386_insn structure I.  Returns zero
   on error.  */

static int
i386_att_operand (char *operand_string)
{
  const reg_entry *r;
  char *end_op;
  char *op_string = operand_string;

  if (is_space_char (*op_string))
    ++op_string;

  /* We check for an absolute prefix (differentiating,
     for example, 'jmp pc_relative_label' from 'jmp *absolute_label'.  */
  if (*op_string == ABSOLUTE_PREFIX)
    {
      ++op_string;
      if (is_space_char (*op_string))
	++op_string;
      i.types[this_operand].bitfield.jumpabsolute = 1;
    }

  /* Check if operand is a register.  */
  if ((r = parse_register (op_string, &end_op)) != NULL)
    {
      i386_operand_type temp;

      /* Check for a segment override by searching for ':' after a
	 segment register.  */
      op_string = end_op;
      if (is_space_char (*op_string))
	++op_string;
      if (*op_string == ':'
	  && (r->reg_type.bitfield.sreg2
	      || r->reg_type.bitfield.sreg3))
	{
	  switch (r->reg_num)
	    {
	    case 0:
	      i.seg[i.mem_operands] = &es;
	      break;
	    case 1:
	      i.seg[i.mem_operands] = &cs;
	      break;
	    case 2:
	      i.seg[i.mem_operands] = &ss;
	      break;
	    case 3:
	      i.seg[i.mem_operands] = &ds;
	      break;
	    case 4:
	      i.seg[i.mem_operands] = &fs;
	      break;
	    case 5:
	      i.seg[i.mem_operands] = &gs;
	      break;
	    }

	  /* Skip the ':' and whitespace.  */
	  ++op_string;
	  if (is_space_char (*op_string))
	    ++op_string;

	  if (!is_digit_char (*op_string)
	      && !is_identifier_char (*op_string)
	      && *op_string != '('
	      && *op_string != ABSOLUTE_PREFIX)
	    {
	      as_bad (_("bad memory operand `%s'"), op_string);
	      return 0;
	    }
	  /* Handle case of %es:*foo.  */
	  if (*op_string == ABSOLUTE_PREFIX)
	    {
	      ++op_string;
	      if (is_space_char (*op_string))
		++op_string;
	      i.types[this_operand].bitfield.jumpabsolute = 1;
	    }
	  goto do_memory_reference;
	}

      /* Handle vector operations.  */
      if (*op_string == '{')
	{
	  op_string = check_VecOperations (op_string, NULL);
	  if (op_string == NULL)
	    return 0;
	}

      if (*op_string)
	{
	  as_bad (_("junk `%s' after register"), op_string);
	  return 0;
	}
      temp = r->reg_type;
      temp.bitfield.baseindex = 0;
      i.types[this_operand] = operand_type_or (i.types[this_operand],
					       temp);
      i.types[this_operand].bitfield.unspecified = 0;
      i.op[this_operand].regs = r;
      i.reg_operands++;
    }
  else if (*op_string == REGISTER_PREFIX)
    {
      as_bad (_("bad register name `%s'"), op_string);
      return 0;
    }
  else if (*op_string == IMMEDIATE_PREFIX)
    {
      ++op_string;
      if (i.types[this_operand].bitfield.jumpabsolute)
	{
	  as_bad (_("immediate operand illegal with absolute jump"));
	  return 0;
	}
      if (!i386_immediate (op_string))
	return 0;
    }
  else if (RC_SAE_immediate (operand_string))
    {
      /* If it is a RC or SAE immediate, do nothing.  */
      ;
    }
  else if (is_digit_char (*op_string)
	   || is_identifier_char (*op_string)
	   || *op_string == '(')
    {
      /* This is a memory reference of some sort.  */
      char *base_string;

      /* Start and end of displacement string expression (if found).  */
      char *displacement_string_start;
      char *displacement_string_end;
      char *vop_start;

    do_memory_reference:
      if ((i.mem_operands == 1
	   && !current_templates->start->opcode_modifier.isstring)
	  || i.mem_operands == 2)
	{
	  as_bad (_("too many memory references for `%s'"),
		  current_templates->start->name);
	  return 0;
	}

      /* Check for base index form.  We detect the base index form by
	 looking for an ')' at the end of the operand, searching
	 for the '(' matching it, and finding a REGISTER_PREFIX or ','
	 after the '('.  */
      base_string = op_string + strlen (op_string);

      /* Handle vector operations.  */
      vop_start = strchr (op_string, '{');
      if (vop_start && vop_start < base_string)
	{
	  if (check_VecOperations (vop_start, base_string) == NULL)
	    return 0;
	  base_string = vop_start;
	}

      --base_string;
      if (is_space_char (*base_string))
	--base_string;

      /* If we only have a displacement, set-up for it to be parsed later.  */
      displacement_string_start = op_string;
      displacement_string_end = base_string + 1;

      if (*base_string == ')')
	{
	  char *temp_string;
	  unsigned int parens_balanced = 1;
	  /* We've already checked that the number of left & right ()'s are
	     equal, so this loop will not be infinite.  */
	  do
	    {
	      base_string--;
	      if (*base_string == ')')
		parens_balanced++;
	      if (*base_string == '(')
		parens_balanced--;
	    }
	  while (parens_balanced);

	  temp_string = base_string;

	  /* Skip past '(' and whitespace.  */
	  ++base_string;
	  if (is_space_char (*base_string))
	    ++base_string;

	  if (*base_string == ','
	      || ((i.base_reg = parse_register (base_string, &end_op))
		  != NULL))
	    {
	      displacement_string_end = temp_string;

	      i.types[this_operand].bitfield.baseindex = 1;

	      if (i.base_reg)
		{
		  base_string = end_op;
		  if (is_space_char (*base_string))
		    ++base_string;
		}

	      /* There may be an index reg or scale factor here.  */
	      if (*base_string == ',')
		{
		  ++base_string;
		  if (is_space_char (*base_string))
		    ++base_string;

		  if ((i.index_reg = parse_register (base_string, &end_op))
		      != NULL)
		    {
		      base_string = end_op;
		      if (is_space_char (*base_string))
			++base_string;
		      if (*base_string == ',')
			{
			  ++base_string;
			  if (is_space_char (*base_string))
			    ++base_string;
			}
		      else if (*base_string != ')')
			{
			  as_bad (_("expecting `,' or `)' "
				    "after index register in `%s'"),
				  operand_string);
			  return 0;
			}
		    }
		  else if (*base_string == REGISTER_PREFIX)
		    {
		      end_op = strchr (base_string, ',');
		      if (end_op)
			*end_op = '\0';
		      as_bad (_("bad register name `%s'"), base_string);
		      return 0;
		    }

		  /* Check for scale factor.  */
		  if (*base_string != ')')
		    {
		      char *end_scale = i386_scale (base_string);

		      if (!end_scale)
			return 0;

		      base_string = end_scale;
		      if (is_space_char (*base_string))
			++base_string;
		      if (*base_string != ')')
			{
			  as_bad (_("expecting `)' "
				    "after scale factor in `%s'"),
				  operand_string);
			  return 0;
			}
		    }
		  else if (!i.index_reg)
		    {
		      as_bad (_("expecting index register or scale factor "
				"after `,'; got '%c'"),
			      *base_string);
		      return 0;
		    }
		}
	      else if (*base_string != ')')
		{
		  as_bad (_("expecting `,' or `)' "
			    "after base register in `%s'"),
			  operand_string);
		  return 0;
		}
	    }
	  else if (*base_string == REGISTER_PREFIX)
	    {
	      end_op = strchr (base_string, ',');
	      if (end_op)
		*end_op = '\0';
	      as_bad (_("bad register name `%s'"), base_string);
	      return 0;
	    }
	}

      /* If there's an expression beginning the operand, parse it,
	 assuming displacement_string_start and
	 displacement_string_end are meaningful.  */
      if (displacement_string_start != displacement_string_end)
	{
	  if (!i386_displacement (displacement_string_start,
				  displacement_string_end))
	    return 0;
	}

      /* Special case for (%dx) while doing input/output op.  */
      if (i.base_reg
	  && operand_type_equal (&i.base_reg->reg_type,
				 &reg16_inoutportreg)
	  && i.index_reg == 0
	  && i.log2_scale_factor == 0
	  && i.seg[i.mem_operands] == 0
	  && !operand_type_check (i.types[this_operand], disp))
	{
	  i.types[this_operand] = inoutportreg;
	  return 1;
	}

      if (i386_index_check (operand_string) == 0)
	return 0;
      i.types[this_operand].bitfield.mem = 1;
      i.mem_operands++;
    }
  else
    {
      /* It's not a memory operand; argh!  */
      as_bad (_("invalid char %s beginning operand %d `%s'"),
	      output_invalid (*op_string),
	      this_operand + 1,
	      op_string);
      return 0;
    }
  return 1;			/* Normal return.  */
}

/* Calculate the maximum variable size (i.e., excluding fr_fix)
   that an rs_machine_dependent frag may reach.  */

unsigned int
i386_frag_max_var (fragS *frag)
{
  /* The only relaxable frags are for jumps.
     Unconditional jumps can grow by 4 bytes and others by 5 bytes.  */
  gas_assert (frag->fr_type == rs_machine_dependent);
  return TYPE_FROM_RELAX_STATE (frag->fr_subtype) == UNCOND_JUMP ? 4 : 5;
}

/* md_estimate_size_before_relax()

   Called just before relax() for rs_machine_dependent frags.  The x86
   assembler uses these frags to handle variable size jump
   instructions.

   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag.
   Return the initial "guess for variable size of frag" to caller.
   The guess is actually the growth beyond the fixed part.  Whatever
   we do to grow the fixed or variable part contributes to our
   returned value.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment)
{
  /* We've already got fragP->fr_subtype right;  all we have to do is
     check for un-relaxable symbols.  On an ELF system, we can't relax
     an externally visible symbol, because it may be overridden by a
     shared library.  */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      || (IS_ELF
	  && (S_IS_EXTERNAL (fragP->fr_symbol)
	      || S_IS_WEAK (fragP->fr_symbol)
	      || ((symbol_get_bfdsym (fragP->fr_symbol)->flags
		   & BSF_GNU_INDIRECT_FUNCTION))))
#endif
#if defined (OBJ_COFF) && defined (TE_PE)
      || (OUTPUT_FLAVOR == bfd_target_coff_flavour
	  && S_IS_WEAK (fragP->fr_symbol))
#endif
      )
    {
      /* Symbol is undefined in this segment, or we need to keep a
	 reloc so that weak symbols can be overridden.  */
      int size = (fragP->fr_subtype & CODE16) ? 2 : 4;
      enum bfd_reloc_code_real reloc_type;
      unsigned char *opcode;
      int old_fr_fix;

      if (fragP->fr_var != NO_RELOC)
	reloc_type = (enum bfd_reloc_code_real) fragP->fr_var;
      else if (size == 2)
	reloc_type = BFD_RELOC_16_PCREL;
      else
	reloc_type = BFD_RELOC_32_PCREL;

      old_fr_fix = fragP->fr_fix;
      opcode = (unsigned char *) fragP->fr_opcode;

      switch (TYPE_FROM_RELAX_STATE (fragP->fr_subtype))
	{
	case UNCOND_JUMP:
	  /* Make jmp (0xeb) a (d)word displacement jump.  */
	  opcode[0] = 0xe9;
	  fragP->fr_fix += size;
	  fix_new (fragP, old_fr_fix, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
	  break;

	case COND_JUMP86:
	  if (size == 2
	      && (!no_cond_jump_promotion || fragP->fr_var != NO_RELOC))
	    {
	      /* Negate the condition, and branch past an
		 unconditional jump.  */
	      opcode[0] ^= 1;
	      opcode[1] = 3;
	      /* Insert an unconditional jump.  */
	      opcode[2] = 0xe9;
	      /* We added two extra opcode bytes, and have a two byte
		 offset.  */
	      fragP->fr_fix += 2 + 2;
	      fix_new (fragP, old_fr_fix + 2, 2,
		       fragP->fr_symbol,
		       fragP->fr_offset, 1,
		       reloc_type);
	      break;
	    }
	  /* Fall through.  */

	case COND_JUMP:
	  if (no_cond_jump_promotion && fragP->fr_var == NO_RELOC)
	    {
	      fixS *fixP;

	      fragP->fr_fix += 1;
	      fixP = fix_new (fragP, old_fr_fix, 1,
			      fragP->fr_symbol,
			      fragP->fr_offset, 1,
			      BFD_RELOC_8_PCREL);
	      fixP->fx_signed = 1;
	      break;
	    }

	  /* This changes the byte-displacement jump 0x7N
	     to the (d)word-displacement jump 0x0f,0x8N.  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  /* We've added an opcode byte.  */
	  fragP->fr_fix += 1 + size;
	  fix_new (fragP, old_fr_fix + 1, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
	  break;

	default:
	  BAD_CASE (fragP->fr_subtype);
	  break;
	}
      frag_wane (fragP);
      return fragP->fr_fix - old_fr_fix;
    }

  /* Guess size depending on current relax state.  Initially the relax
     state will correspond to a short jump and we return 1, because
     the variable part of the frag (the branch offset) is one byte
     long.  However, we can relax a section more than once and in that
     case we must either set fr_subtype back to the unrelaxed state,
     or return the value for the appropriate branch.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Called after relax() is finished.

   In:	Address of frag.
	fr_type == rs_machine_dependent.
	fr_subtype is what the address relaxed to.

   Out:	Any fixSs and constants are set up.
	Caller will turn frag into a ".space 0".  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
                 fragS *fragP)
{
  unsigned char *opcode;
  unsigned char *where_to_put_displacement = NULL;
  offsetT target_address;
  offsetT opcode_address;
  unsigned int extension = 0;
  offsetT displacement_from_opcode_start;

  opcode = (unsigned char *) fragP->fr_opcode;

  /* Address we want to reach in file space.  */
  target_address = S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset;

  /* Address opcode resides at in file space.  */
  opcode_address = fragP->fr_address + fragP->fr_fix;

  /* Displacement from opcode start to fill into instruction.  */
  displacement_from_opcode_start = target_address - opcode_address;

  if ((fragP->fr_subtype & BIG) == 0)
    {
      /* Don't have to change opcode.  */
      extension = 1;		/* 1 opcode + 1 displacement  */
      where_to_put_displacement = &opcode[1];
    }
  else
    {
      if (no_cond_jump_promotion
	  && TYPE_FROM_RELAX_STATE (fragP->fr_subtype) != UNCOND_JUMP)
	as_warn_where (fragP->fr_file, fragP->fr_line,
		       _("long jump required"));

      switch (fragP->fr_subtype)
	{
	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG):
	  extension = 4;		/* 1 opcode + 4 displacement  */
	  opcode[0] = 0xe9;
	  where_to_put_displacement = &opcode[1];
	  break;

	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16):
	  extension = 2;		/* 1 opcode + 2 displacement  */
	  opcode[0] = 0xe9;
	  where_to_put_displacement = &opcode[1];
	  break;

	case ENCODE_RELAX_STATE (COND_JUMP, BIG):
	case ENCODE_RELAX_STATE (COND_JUMP86, BIG):
	  extension = 5;		/* 2 opcode + 4 displacement  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  where_to_put_displacement = &opcode[2];
	  break;

	case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
	  extension = 3;		/* 2 opcode + 2 displacement  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  where_to_put_displacement = &opcode[2];
	  break;

	case ENCODE_RELAX_STATE (COND_JUMP86, BIG16):
	  extension = 4;
	  opcode[0] ^= 1;
	  opcode[1] = 3;
	  opcode[2] = 0xe9;
	  where_to_put_displacement = &opcode[3];
	  break;

	default:
	  BAD_CASE (fragP->fr_subtype);
	  break;
	}
    }

  /* If size if less then four we are sure that the operand fits,
     but if it's 4, then it could be that the displacement is larger
     then -/+ 2GB.  */
  if (DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype) == 4
      && object_64bit
      && ((addressT) (displacement_from_opcode_start - extension
		      + ((addressT) 1 << 31))
	  > (((addressT) 2 << 31) - 1)))
    {
      as_bad_where (fragP->fr_file, fragP->fr_line,
		    _("jump target out of range"));
      /* Make us emit 0.  */
      displacement_from_opcode_start = extension;
    }
  /* Now put displacement after opcode.  */
  md_number_to_chars ((char *) where_to_put_displacement,
		      (valueT) (displacement_from_opcode_start - extension),
		      DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
  fragP->fr_fix += extension;
}

/* Apply a fixup (fixP) to segment data, once it has been determined
   by our caller that we have all the info we need to fix it up.

   Parameter valP is the pointer to the value of the bits.

   On the 386, immediates, displacements, and data pointers are all in
   the same (little-endian) format, so we don't need to care about which
   we are handling.  */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *p = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT value = *valP;

#if !defined (TE_Mach)
  if (fixP->fx_pcrel)
    {
      switch (fixP->fx_r_type)
	{
	default:
	  break;

	case BFD_RELOC_64:
	  fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  break;
	case BFD_RELOC_32:
	case BFD_RELOC_X86_64_32S:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  break;
	case BFD_RELOC_16:
	  fixP->fx_r_type = BFD_RELOC_16_PCREL;
	  break;
	case BFD_RELOC_8:
	  fixP->fx_r_type = BFD_RELOC_8_PCREL;
	  break;
	}
    }

  if (fixP->fx_addsy != NULL
      && (fixP->fx_r_type == BFD_RELOC_32_PCREL
	  || fixP->fx_r_type == BFD_RELOC_64_PCREL
	  || fixP->fx_r_type == BFD_RELOC_16_PCREL
	  || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && !use_rela_relocations)
    {
      /* This is a hack.  There should be a better way to handle this.
	 This covers for the fact that bfd_install_relocation will
	 subtract the current location (for partial_inplace, PC relative
	 relocations); see more below.  */
#ifndef OBJ_AOUT
      if (IS_ELF
#ifdef TE_PE
	  || OUTPUT_FLAVOR == bfd_target_coff_flavour
#endif
	  )
	value += fixP->fx_where + fixP->fx_frag->fr_address;
#endif
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      if (IS_ELF)
	{
	  segT sym_seg = S_GET_SEGMENT (fixP->fx_addsy);

	  if ((sym_seg == seg
	       || (symbol_section_p (fixP->fx_addsy)
		   && sym_seg != absolute_section))
	      && !generic_force_reloc (fixP))
	    {
	      /* Yes, we add the values in twice.  This is because
		 bfd_install_relocation subtracts them out again.  I think
		 bfd_install_relocation is broken, but I don't dare change
		 it.  FIXME.  */
	      value += fixP->fx_where + fixP->fx_frag->fr_address;
	    }
	}
#endif
#if defined (OBJ_COFF) && defined (TE_PE)
      /* For some reason, the PE format does not store a
	 section address offset for a PC relative symbol.  */
      if (S_GET_SEGMENT (fixP->fx_addsy) != seg
	  || S_IS_WEAK (fixP->fx_addsy))
	value += md_pcrel_from (fixP);
#endif
    }
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixP->fx_addsy != NULL && S_IS_WEAK (fixP->fx_addsy))
    {
      value -= S_GET_VALUE (fixP->fx_addsy);
    }
#endif

  /* Fix a few things - the dynamic linker expects certain values here,
     and we must not disappoint it.  */
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (IS_ELF && fixP->fx_addsy)
    switch (fixP->fx_r_type)
      {
      case BFD_RELOC_386_PLT32:
      case BFD_RELOC_X86_64_PLT32:
	/* Make the jump instruction point to the address of the operand.  At
	   runtime we merely add the offset to the actual PLT entry.  */
	value = -4;
	break;

      case BFD_RELOC_386_TLS_GD:
      case BFD_RELOC_386_TLS_LDM:
      case BFD_RELOC_386_TLS_IE_32:
      case BFD_RELOC_386_TLS_IE:
      case BFD_RELOC_386_TLS_GOTIE:
      case BFD_RELOC_386_TLS_GOTDESC:
      case BFD_RELOC_X86_64_TLSGD:
      case BFD_RELOC_X86_64_TLSLD:
      case BFD_RELOC_X86_64_GOTTPOFF:
      case BFD_RELOC_X86_64_GOTPC32_TLSDESC:
	value = 0; /* Fully resolved at runtime.  No addend.  */
	/* Fallthrough */
      case BFD_RELOC_386_TLS_LE:
      case BFD_RELOC_386_TLS_LDO_32:
      case BFD_RELOC_386_TLS_LE_32:
      case BFD_RELOC_X86_64_DTPOFF32:
      case BFD_RELOC_X86_64_DTPOFF64:
      case BFD_RELOC_X86_64_TPOFF32:
      case BFD_RELOC_X86_64_TPOFF64:
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
	break;

      case BFD_RELOC_386_TLS_DESC_CALL:
      case BFD_RELOC_X86_64_TLSDESC_CALL:
	value = 0; /* Fully resolved at runtime.  No addend.  */
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
	fixP->fx_done = 0;
	return;

      case BFD_RELOC_386_GOT32:
      case BFD_RELOC_X86_64_GOT32:
	value = 0; /* Fully resolved at runtime.  No addend.  */
	break;

      case BFD_RELOC_VTABLE_INHERIT:
      case BFD_RELOC_VTABLE_ENTRY:
	fixP->fx_done = 0;
	return;

      default:
	break;
      }
#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)  */
  *valP = value;
#endif /* !defined (TE_Mach)  */

  /* Are we finished with this relocation now?  */
  if (fixP->fx_addsy == NULL)
    fixP->fx_done = 1;
#if defined (OBJ_COFF) && defined (TE_PE)
  else if (fixP->fx_addsy != NULL && S_IS_WEAK (fixP->fx_addsy))
    {
      fixP->fx_done = 0;
      /* Remember value for tc_gen_reloc.  */
      fixP->fx_addnumber = value;
      /* Clear out the frag for now.  */
      value = 0;
    }
#endif
  else if (use_rela_relocations)
    {
      fixP->fx_no_overflow = 1;
      /* Remember value for tc_gen_reloc.  */
      fixP->fx_addnumber = value;
      value = 0;
    }

  md_number_to_chars (p, value, fixP->fx_size);
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  /* This outputs the LITTLENUMs in REVERSE order;
     in accord with the bigendian 386.  */
  return ieee_md_atof (type, litP, sizeP, FALSE);
}

static char output_invalid_buf[sizeof (unsigned char) * 2 + 6];

static char *
output_invalid (int c)
{
  if (ISPRINT (c))
    snprintf (output_invalid_buf, sizeof (output_invalid_buf),
	      "'%c'", c);
  else
    snprintf (output_invalid_buf, sizeof (output_invalid_buf),
	      "(0x%x)", (unsigned char) c);
  return output_invalid_buf;
}

/* REG_STRING starts *before* REGISTER_PREFIX.  */

static const reg_entry *
parse_real_register (char *reg_string, char **end_op)
{
  char *s = reg_string;
  char *p;
  char reg_name_given[MAX_REG_NAME_SIZE + 1];
  const reg_entry *r;

  /* Skip possible REGISTER_PREFIX and possible whitespace.  */
  if (*s == REGISTER_PREFIX)
    ++s;

  if (is_space_char (*s))
    ++s;

  p = reg_name_given;
  while ((*p++ = register_chars[(unsigned char) *s]) != '\0')
    {
      if (p >= reg_name_given + MAX_REG_NAME_SIZE)
	return (const reg_entry *) NULL;
      s++;
    }

  /* For naked regs, make sure that we are not dealing with an identifier.
     This prevents confusing an identifier like `eax_var' with register
     `eax'.  */
  if (allow_naked_reg && identifier_chars[(unsigned char) *s])
    return (const reg_entry *) NULL;

  *end_op = s;

  r = (const reg_entry *) hash_find (reg_hash, reg_name_given);

  /* Handle floating point regs, allowing spaces in the (i) part.  */
  if (r == i386_regtab /* %st is first entry of table  */)
    {
      if (is_space_char (*s))
	++s;
      if (*s == '(')
	{
	  ++s;
	  if (is_space_char (*s))
	    ++s;
	  if (*s >= '0' && *s <= '7')
	    {
	      int fpr = *s - '0';
	      ++s;
	      if (is_space_char (*s))
		++s;
	      if (*s == ')')
		{
		  *end_op = s + 1;
		  r = (const reg_entry *) hash_find (reg_hash, "st(0)");
		  know (r);
		  return r + fpr;
		}
	    }
	  /* We have "%st(" then garbage.  */
	  return (const reg_entry *) NULL;
	}
    }

  if (r == NULL || allow_pseudo_reg)
    return r;

  if (operand_type_all_zero (&r->reg_type))
    return (const reg_entry *) NULL;

  if ((r->reg_type.bitfield.reg32
       || r->reg_type.bitfield.sreg3
       || r->reg_type.bitfield.control
       || r->reg_type.bitfield.debug
       || r->reg_type.bitfield.test)
      && !cpu_arch_flags.bitfield.cpui386)
    return (const reg_entry *) NULL;

  if (r->reg_type.bitfield.floatreg
      && !cpu_arch_flags.bitfield.cpu8087
      && !cpu_arch_flags.bitfield.cpu287
      && !cpu_arch_flags.bitfield.cpu387)
    return (const reg_entry *) NULL;

  if (r->reg_type.bitfield.regmmx && !cpu_arch_flags.bitfield.cpummx)
    return (const reg_entry *) NULL;

  if (r->reg_type.bitfield.regxmm && !cpu_arch_flags.bitfield.cpusse)
    return (const reg_entry *) NULL;

  if (r->reg_type.bitfield.regymm && !cpu_arch_flags.bitfield.cpuavx)
    return (const reg_entry *) NULL;

  if ((r->reg_type.bitfield.regzmm || r->reg_type.bitfield.regmask)
       && !cpu_arch_flags.bitfield.cpuavx512f)
    return (const reg_entry *) NULL;

  /* Don't allow fake index register unless allow_index_reg isn't 0. */
  if (!allow_index_reg
      && (r->reg_num == RegEiz || r->reg_num == RegRiz))
    return (const reg_entry *) NULL;

  /* Upper 16 vector register is only available with VREX in 64bit
     mode.  */
  if ((r->reg_flags & RegVRex))
    {
      if (!cpu_arch_flags.bitfield.cpuvrex
	  || flag_code != CODE_64BIT)
	return (const reg_entry *) NULL;

      i.need_vrex = 1;
    }

  if (((r->reg_flags & (RegRex64 | RegRex))
       || r->reg_type.bitfield.reg64)
      && (!cpu_arch_flags.bitfield.cpulm
	  || !operand_type_equal (&r->reg_type, &control))
      && flag_code != CODE_64BIT)
    return (const reg_entry *) NULL;

  if (r->reg_type.bitfield.sreg3 && r->reg_num == RegFlat && !intel_syntax)
    return (const reg_entry *) NULL;

  return r;
}

/* REG_STRING starts *before* REGISTER_PREFIX.  */

static const reg_entry *
parse_register (char *reg_string, char **end_op)
{
  const reg_entry *r;

  if (*reg_string == REGISTER_PREFIX || allow_naked_reg)
    r = parse_real_register (reg_string, end_op);
  else
    r = NULL;
  if (!r)
    {
      char *save = input_line_pointer;
      char c;
      symbolS *symbolP;

      input_line_pointer = reg_string;
      c = get_symbol_end ();
      symbolP = symbol_find (reg_string);
      if (symbolP && S_GET_SEGMENT (symbolP) == reg_section)
	{
	  const expressionS *e = symbol_get_value_expression (symbolP);

	  know (e->X_op == O_register);
	  know (e->X_add_number >= 0
		&& (valueT) e->X_add_number < i386_regtab_size);
	  r = i386_regtab + e->X_add_number;
	  *end_op = input_line_pointer;
	}
      *input_line_pointer = c;
      input_line_pointer = save;
    }
  return r;
}

int
i386_parse_name (char *name, expressionS *e, char *nextcharP)
{
  const reg_entry *r;
  char *end = input_line_pointer;

  *end = *nextcharP;
  r = parse_register (name, &input_line_pointer);
  if (r && end <= input_line_pointer)
    {
      *nextcharP = *input_line_pointer;
      *input_line_pointer = 0;
      e->X_op = O_register;
      e->X_add_number = r - i386_regtab;
      return 1;
    }
  input_line_pointer = end;
  *end = 0;
  return intel_syntax ? i386_intel_parse_name (name, e) : 0;
}

void
md_operand (expressionS *e)
{
  char *end;
  const reg_entry *r;

  switch (*input_line_pointer)
    {
    case REGISTER_PREFIX:
      r = parse_real_register (input_line_pointer, &end);
      if (r)
	{
	  e->X_op = O_register;
	  e->X_add_number = r - i386_regtab;
	  input_line_pointer = end;
	}
      break;

    case '[':
      gas_assert (intel_syntax);
      end = input_line_pointer++;
      expression (e);
      if (*input_line_pointer == ']')
	{
	  ++input_line_pointer;
	  e->X_op_symbol = make_expr_symbol (e);
	  e->X_add_symbol = NULL;
	  e->X_add_number = 0;
	  e->X_op = O_index;
	}
      else
	{
	  e->X_op = O_absent;
	  input_line_pointer = end;
	}
      break;
    }
}


#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
const char *md_shortopts = "kVQ:sqn";
#else
const char *md_shortopts = "qn";
#endif

#define OPTION_32 (OPTION_MD_BASE + 0)
#define OPTION_64 (OPTION_MD_BASE + 1)
#define OPTION_DIVIDE (OPTION_MD_BASE + 2)
#define OPTION_MARCH (OPTION_MD_BASE + 3)
#define OPTION_MTUNE (OPTION_MD_BASE + 4)
#define OPTION_MMNEMONIC (OPTION_MD_BASE + 5)
#define OPTION_MSYNTAX (OPTION_MD_BASE + 6)
#define OPTION_MINDEX_REG (OPTION_MD_BASE + 7)
#define OPTION_MNAKED_REG (OPTION_MD_BASE + 8)
#define OPTION_MOLD_GCC (OPTION_MD_BASE + 9)
#define OPTION_MSSE2AVX (OPTION_MD_BASE + 10)
#define OPTION_MSSE_CHECK (OPTION_MD_BASE + 11)
#define OPTION_MOPERAND_CHECK (OPTION_MD_BASE + 12)
#define OPTION_MAVXSCALAR (OPTION_MD_BASE + 13)
#define OPTION_X32 (OPTION_MD_BASE + 14)
#define OPTION_MADD_BND_PREFIX (OPTION_MD_BASE + 15)
#define OPTION_MEVEXLIG (OPTION_MD_BASE + 16)
#define OPTION_MEVEXWIG (OPTION_MD_BASE + 17)

struct option md_longopts[] =
{
  {"32", no_argument, NULL, OPTION_32},
#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) \
     || defined (TE_PE) || defined (TE_PEP) || defined (OBJ_MACH_O))
  {"64", no_argument, NULL, OPTION_64},
#endif
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  {"x32", no_argument, NULL, OPTION_X32},
#endif
  {"divide", no_argument, NULL, OPTION_DIVIDE},
  {"march", required_argument, NULL, OPTION_MARCH},
  {"mtune", required_argument, NULL, OPTION_MTUNE},
  {"mmnemonic", required_argument, NULL, OPTION_MMNEMONIC},
  {"msyntax", required_argument, NULL, OPTION_MSYNTAX},
  {"mindex-reg", no_argument, NULL, OPTION_MINDEX_REG},
  {"mnaked-reg", no_argument, NULL, OPTION_MNAKED_REG},
  {"mold-gcc", no_argument, NULL, OPTION_MOLD_GCC},
  {"msse2avx", no_argument, NULL, OPTION_MSSE2AVX},
  {"msse-check", required_argument, NULL, OPTION_MSSE_CHECK},
  {"moperand-check", required_argument, NULL, OPTION_MOPERAND_CHECK},
  {"mavxscalar", required_argument, NULL, OPTION_MAVXSCALAR},
  {"madd-bnd-prefix", no_argument, NULL, OPTION_MADD_BND_PREFIX},
  {"mevexlig", required_argument, NULL, OPTION_MEVEXLIG},
  {"mevexwig", required_argument, NULL, OPTION_MEVEXWIG},
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  unsigned int j;
  char *arch, *next;

  switch (c)
    {
    case 'n':
      optimize_align_code = 0;
      break;

    case 'q':
      quiet_warnings = 1;
      break;

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;

      /* -k: Ignore for FreeBSD compatibility.  */
    case 'k':
      break;

    case 's':
      /* -s: On i386 Solaris, this tells the native assembler to use
	 .stab instead of .stab.excl.  We always use .stab anyhow.  */
      break;
#endif
#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) \
     || defined (TE_PE) || defined (TE_PEP) || defined (OBJ_MACH_O))
    case OPTION_64:
      {
	const char **list, **l;

	list = bfd_target_list ();
	for (l = list; *l != NULL; l++)
	  if (CONST_STRNEQ (*l, "elf64-x86-64")
	      || strcmp (*l, "coff-x86-64") == 0
	      || strcmp (*l, "pe-x86-64") == 0
	      || strcmp (*l, "pei-x86-64") == 0
	      || strcmp (*l, "mach-o-x86-64") == 0)
	    {
	      default_arch = "x86_64";
	      break;
	    }
	if (*l == NULL)
	  as_fatal (_("no compiled in support for x86_64"));
	free (list);
      }
      break;
#endif

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
    case OPTION_X32:
      if (IS_ELF)
	{
	  const char **list, **l;

	  list = bfd_target_list ();
	  for (l = list; *l != NULL; l++)
	    if (CONST_STRNEQ (*l, "elf32-x86-64"))
	      {
		default_arch = "x86_64:32";
		break;
	      }
	  if (*l == NULL)
	    as_fatal (_("no compiled in support for 32bit x86_64"));
	  free (list);
	}
      else
	as_fatal (_("32bit x86_64 is only supported for ELF"));
      break;
#endif

    case OPTION_32:
      default_arch = "i386";
      break;

    case OPTION_DIVIDE:
#ifdef SVR4_COMMENT_CHARS
      {
	char *n, *t;
	const char *s;

	n = (char *) xmalloc (strlen (i386_comment_chars) + 1);
	t = n;
	for (s = i386_comment_chars; *s != '\0'; s++)
	  if (*s != '/')
	    *t++ = *s;
	*t = '\0';
	i386_comment_chars = n;
      }
#endif
      break;

    case OPTION_MARCH:
      arch = xstrdup (arg);
      do
	{
	  if (*arch == '.')
	    as_fatal (_("invalid -march= option: `%s'"), arg);
	  next = strchr (arch, '+');
	  if (next)
	    *next++ = '\0';
	  for (j = 0; j < ARRAY_SIZE (cpu_arch); j++)
	    {
	      if (strcmp (arch, cpu_arch [j].name) == 0)
		{
		  /* Processor.  */
		  if (! cpu_arch[j].flags.bitfield.cpui386)
		    continue;

		  cpu_arch_name = cpu_arch[j].name;
		  cpu_sub_arch_name = NULL;
		  cpu_arch_flags = cpu_arch[j].flags;
		  cpu_arch_isa = cpu_arch[j].type;
		  cpu_arch_isa_flags = cpu_arch[j].flags;
		  if (!cpu_arch_tune_set)
		    {
		      cpu_arch_tune = cpu_arch_isa;
		      cpu_arch_tune_flags = cpu_arch_isa_flags;
		    }
		  break;
		}
	      else if (*cpu_arch [j].name == '.'
		       && strcmp (arch, cpu_arch [j].name + 1) == 0)
		{
		  /* ISA entension.  */
		  i386_cpu_flags flags;

		  if (!cpu_arch[j].negated)
		    flags = cpu_flags_or (cpu_arch_flags,
					  cpu_arch[j].flags);
		  else
		    flags = cpu_flags_and_not (cpu_arch_flags,
					       cpu_arch[j].flags);
		  if (!cpu_flags_equal (&flags, &cpu_arch_flags))
		    {
		      if (cpu_sub_arch_name)
			{
			  char *name = cpu_sub_arch_name;
			  cpu_sub_arch_name = concat (name,
						      cpu_arch[j].name,
						      (const char *) NULL);
			  free (name);
			}
		      else
			cpu_sub_arch_name = xstrdup (cpu_arch[j].name);
		      cpu_arch_flags = flags;
		      cpu_arch_isa_flags = flags;
		    }
		  break;
		}
	    }

	  if (j >= ARRAY_SIZE (cpu_arch))
	    as_fatal (_("invalid -march= option: `%s'"), arg);

	  arch = next;
	}
      while (next != NULL );
      break;

    case OPTION_MTUNE:
      if (*arg == '.')
	as_fatal (_("invalid -mtune= option: `%s'"), arg);
      for (j = 0; j < ARRAY_SIZE (cpu_arch); j++)
	{
	  if (strcmp (arg, cpu_arch [j].name) == 0)
	    {
	      cpu_arch_tune_set = 1;
	      cpu_arch_tune = cpu_arch [j].type;
	      cpu_arch_tune_flags = cpu_arch[j].flags;
	      break;
	    }
	}
      if (j >= ARRAY_SIZE (cpu_arch))
	as_fatal (_("invalid -mtune= option: `%s'"), arg);
      break;

    case OPTION_MMNEMONIC:
      if (strcasecmp (arg, "att") == 0)
	intel_mnemonic = 0;
      else if (strcasecmp (arg, "intel") == 0)
	intel_mnemonic = 1;
      else
	as_fatal (_("invalid -mmnemonic= option: `%s'"), arg);
      break;

    case OPTION_MSYNTAX:
      if (strcasecmp (arg, "att") == 0)
	intel_syntax = 0;
      else if (strcasecmp (arg, "intel") == 0)
	intel_syntax = 1;
      else
	as_fatal (_("invalid -msyntax= option: `%s'"), arg);
      break;

    case OPTION_MINDEX_REG:
      allow_index_reg = 1;
      break;

    case OPTION_MNAKED_REG:
      allow_naked_reg = 1;
      break;

    case OPTION_MOLD_GCC:
      old_gcc = 1;
      break;

    case OPTION_MSSE2AVX:
      sse2avx = 1;
      break;

    case OPTION_MSSE_CHECK:
      if (strcasecmp (arg, "error") == 0)
	sse_check = check_error;
      else if (strcasecmp (arg, "warning") == 0)
	sse_check = check_warning;
      else if (strcasecmp (arg, "none") == 0)
	sse_check = check_none;
      else
	as_fatal (_("invalid -msse-check= option: `%s'"), arg);
      break;

    case OPTION_MOPERAND_CHECK:
      if (strcasecmp (arg, "error") == 0)
	operand_check = check_error;
      else if (strcasecmp (arg, "warning") == 0)
	operand_check = check_warning;
      else if (strcasecmp (arg, "none") == 0)
	operand_check = check_none;
      else
	as_fatal (_("invalid -moperand-check= option: `%s'"), arg);
      break;

    case OPTION_MAVXSCALAR:
      if (strcasecmp (arg, "128") == 0)
	avxscalar = vex128;
      else if (strcasecmp (arg, "256") == 0)
	avxscalar = vex256;
      else
	as_fatal (_("invalid -mavxscalar= option: `%s'"), arg);
      break;

    case OPTION_MADD_BND_PREFIX:
      add_bnd_prefix = 1;
      break;

    case OPTION_MEVEXLIG:
      if (strcmp (arg, "128") == 0)
	evexlig = evexl128;
      else if (strcmp (arg, "256") == 0)
	evexlig = evexl256;
      else  if (strcmp (arg, "512") == 0)
	evexlig = evexl512;
      else
	as_fatal (_("invalid -mevexlig= option: `%s'"), arg);
      break;

    case OPTION_MEVEXWIG:
      if (strcmp (arg, "0") == 0)
	evexwig = evexw0;
      else if (strcmp (arg, "1") == 0)
	evexwig = evexw1;
      else
	as_fatal (_("invalid -mevexwig= option: `%s'"), arg);
      break;

    default:
      return 0;
    }
  return 1;
}

#define MESSAGE_TEMPLATE \
"                                                                                "

static void
show_arch (FILE *stream, int ext, int check)
{
  static char message[] = MESSAGE_TEMPLATE;
  char *start = message + 27;
  char *p;
  int size = sizeof (MESSAGE_TEMPLATE);
  int left;
  const char *name;
  int len;
  unsigned int j;

  p = start;
  left = size - (start - message);
  for (j = 0; j < ARRAY_SIZE (cpu_arch); j++)
    {
      /* Should it be skipped?  */
      if (cpu_arch [j].skip)
	continue;

      name = cpu_arch [j].name;
      len = cpu_arch [j].len;
      if (*name == '.')
	{
	  /* It is an extension.  Skip if we aren't asked to show it.  */
	  if (ext)
	    {
	      name++;
	      len--;
	    }
	  else
	    continue;
	}
      else if (ext)
	{
	  /* It is an processor.  Skip if we show only extension.  */
	  continue;
	}
      else if (check && ! cpu_arch[j].flags.bitfield.cpui386)
	{
	  /* It is an impossible processor - skip.  */
	  continue;
	}

      /* Reserve 2 spaces for ", " or ",\0" */
      left -= len + 2;

      /* Check if there is any room.  */
      if (left >= 0)
	{
	  if (p != start)
	    {
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  p = mempcpy (p, name, len);
	}
      else
	{
	  /* Output the current message now and start a new one.  */
	  *p++ = ',';
	  *p = '\0';
	  fprintf (stream, "%s\n", message);
	  p = start;
	  left = size - (start - message) - len - 2;

	  gas_assert (left >= 0);

	  p = mempcpy (p, name, len);
	}
    }

  *p = '\0';
  fprintf (stream, "%s\n", message);
}

void
md_show_usage (FILE *stream)
{
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  fprintf (stream, _("\
  -Q                      ignored\n\
  -V                      print assembler version number\n\
  -k                      ignored\n"));
#endif
  fprintf (stream, _("\
  -n                      Do not optimize code alignment\n\
  -q                      quieten some warnings\n"));
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  fprintf (stream, _("\
  -s                      ignored\n"));
#endif
#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) \
     || defined (TE_PE) || defined (TE_PEP))
  fprintf (stream, _("\
  --32/--64/--x32         generate 32bit/64bit/x32 code\n"));
#endif
#ifdef SVR4_COMMENT_CHARS
  fprintf (stream, _("\
  --divide                do not treat `/' as a comment character\n"));
#else
  fprintf (stream, _("\
  --divide                ignored\n"));
#endif
  fprintf (stream, _("\
  -march=CPU[,+EXTENSION...]\n\
                          generate code for CPU and EXTENSION, CPU is one of:\n"));
  show_arch (stream, 0, 1);
  fprintf (stream, _("\
                          EXTENSION is combination of:\n"));
  show_arch (stream, 1, 0);
  fprintf (stream, _("\
  -mtune=CPU              optimize for CPU, CPU is one of:\n"));
  show_arch (stream, 0, 0);
  fprintf (stream, _("\
  -msse2avx               encode SSE instructions with VEX prefix\n"));
  fprintf (stream, _("\
  -msse-check=[none|error|warning]\n\
                          check SSE instructions\n"));
  fprintf (stream, _("\
  -moperand-check=[none|error|warning]\n\
                          check operand combinations for validity\n"));
  fprintf (stream, _("\
  -mavxscalar=[128|256]   encode scalar AVX instructions with specific vector\n\
                           length\n"));
  fprintf (stream, _("\
  -mevexlig=[128|256|512] encode scalar EVEX instructions with specific vector\n\
                           length\n"));
  fprintf (stream, _("\
  -mevexwig=[0|1]         encode EVEX instructions with specific EVEX.W value\n\
                           for EVEX.W bit ignored instructions\n"));
  fprintf (stream, _("\
  -mmnemonic=[att|intel]  use AT&T/Intel mnemonic\n"));
  fprintf (stream, _("\
  -msyntax=[att|intel]    use AT&T/Intel syntax\n"));
  fprintf (stream, _("\
  -mindex-reg             support pseudo index registers\n"));
  fprintf (stream, _("\
  -mnaked-reg             don't require `%%' prefix for registers\n"));
  fprintf (stream, _("\
  -mold-gcc               support old (<= 2.8.1) versions of gcc\n"));
  fprintf (stream, _("\
  -madd-bnd-prefix        add BND prefix for all valid branches\n"));
}

#if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \
     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) \
     || defined (TE_PE) || defined (TE_PEP) || defined (OBJ_MACH_O))

/* Pick the target format to use.  */

const char *
i386_target_format (void)
{
  if (!strncmp (default_arch, "x86_64", 6))
    {
      update_code_flag (CODE_64BIT, 1);
      if (default_arch[6] == '\0')
	x86_elf_abi = X86_64_ABI;
      else
	x86_elf_abi = X86_64_X32_ABI;
    }
  else if (!strcmp (default_arch, "i386"))
    update_code_flag (CODE_32BIT, 1);
  else
    as_fatal (_("unknown architecture"));

  if (cpu_flags_all_zero (&cpu_arch_isa_flags))
    cpu_arch_isa_flags = cpu_arch[flag_code == CODE_64BIT].flags;
  if (cpu_flags_all_zero (&cpu_arch_tune_flags))
    cpu_arch_tune_flags = cpu_arch[flag_code == CODE_64BIT].flags;

  switch (OUTPUT_FLAVOR)
    {
#if defined (OBJ_MAYBE_AOUT) || defined (OBJ_AOUT)
    case bfd_target_aout_flavour:
      return AOUT_TARGET_FORMAT;
#endif
#if defined (OBJ_MAYBE_COFF) || defined (OBJ_COFF)
# if defined (TE_PE) || defined (TE_PEP)
    case bfd_target_coff_flavour:
      return flag_code == CODE_64BIT ? "pe-x86-64" : "pe-i386";
# elif defined (TE_GO32)
    case bfd_target_coff_flavour:
      return "coff-go32";
# else
    case bfd_target_coff_flavour:
      return "coff-i386";
# endif
#endif
#if defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF)
    case bfd_target_elf_flavour:
      {
	const char *format;

	switch (x86_elf_abi)
	  {
	  default:
	    format = ELF_TARGET_FORMAT;
	    break;
	  case X86_64_ABI:
	    use_rela_relocations = 1;
	    object_64bit = 1;
	    format = ELF_TARGET_FORMAT64;
	    break;
	  case X86_64_X32_ABI:
	    use_rela_relocations = 1;
	    object_64bit = 1;
	    disallow_64bit_reloc = 1;
	    format = ELF_TARGET_FORMAT32;
	    break;
	  }
	if (cpu_arch_isa == PROCESSOR_L1OM)
	  {
	    if (x86_elf_abi != X86_64_ABI)
	      as_fatal (_("Intel L1OM is 64bit only"));
	    return ELF_TARGET_L1OM_FORMAT;
	  }
	if (cpu_arch_isa == PROCESSOR_K1OM)
	  {
	    if (x86_elf_abi != X86_64_ABI)
	      as_fatal (_("Intel K1OM is 64bit only"));
	    return ELF_TARGET_K1OM_FORMAT;
	  }
	else
	  return format;
      }
#endif
#if defined (OBJ_MACH_O)
    case bfd_target_mach_o_flavour:
      if (flag_code == CODE_64BIT)
	{
	  use_rela_relocations = 1;
	  object_64bit = 1;
	  return "mach-o-x86-64";
	}
      else
	return "mach-o-i386";
#endif
    default:
      abort ();
      return NULL;
    }
}

#endif /* OBJ_MAYBE_ more than one  */

#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
void
i386_elf_emit_arch_note (void)
{
  if (IS_ELF && cpu_arch_name != NULL)
    {
      char *p;
      asection *seg = now_seg;
      subsegT subseg = now_subseg;
      Elf_Internal_Note i_note;
      Elf_External_Note e_note;
      asection *note_secp;
      int len;

      /* Create the .note section.  */
      note_secp = subseg_new (".note", 0);
      bfd_set_section_flags (stdoutput,
			     note_secp,
			     SEC_HAS_CONTENTS | SEC_READONLY);

      /* Process the arch string.  */
      len = strlen (cpu_arch_name);

      i_note.namesz = len + 1;
      i_note.descsz = 0;
      i_note.type = NT_ARCH;
      p = frag_more (sizeof (e_note.namesz));
      md_number_to_chars (p, (valueT) i_note.namesz, sizeof (e_note.namesz));
      p = frag_more (sizeof (e_note.descsz));
      md_number_to_chars (p, (valueT) i_note.descsz, sizeof (e_note.descsz));
      p = frag_more (sizeof (e_note.type));
      md_number_to_chars (p, (valueT) i_note.type, sizeof (e_note.type));
      p = frag_more (len + 1);
      strcpy (p, cpu_arch_name);

      frag_align (2, 0, 0);

      subseg_set (seg, subseg);
    }
}
#endif

symbolS *
md_undefined_symbol (char *name)
{
  if (name[0] == GLOBAL_OFFSET_TABLE_NAME[0]
      && name[1] == GLOBAL_OFFSET_TABLE_NAME[1]
      && name[2] == GLOBAL_OFFSET_TABLE_NAME[2]
      && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad (_("GOT already in symbol table"));
	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, &zero_address_frag);
	};
      return GOT_symbol;
    }
  return 0;
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
    {
      /* For a.out, force the section size to be aligned.  If we don't do
	 this, BFD will align it for us, but it will not write out the
	 final bytes of the section.  This may be a bug in BFD, but it is
	 easier to fix it here since that is how the other a.out targets
	 work.  */
      int align;

      align = bfd_get_section_alignment (stdoutput, segment);
      size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
    }
#endif

  return size;
}

/* On the i386, PC-relative offsets are relative to the start of the
   next instruction.  That is, the address of the offset, plus its
   size, since the offset is always the last part of the insn.  */

long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

#ifndef I386COFF

static void
s_bss (int ignore ATTRIBUTE_UNUSED)
{
  int temp;

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (IS_ELF)
    obj_elf_section_change_hook ();
#endif
  temp = get_absolute_expression ();
  subseg_set (bss_section, (subsegT) temp);
  demand_empty_rest_of_line ();
}

#endif

void
i386_validate_fix (fixS *fixp)
{
  if (fixp->fx_subsy && fixp->fx_subsy == GOT_symbol)
    {
      if (fixp->fx_r_type == BFD_RELOC_32_PCREL)
	{
	  if (!object_64bit)
	    abort ();
	  fixp->fx_r_type = BFD_RELOC_X86_64_GOTPCREL;
	}
      else
	{
	  if (!object_64bit)
	    fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
	  else
	    fixp->fx_r_type = BFD_RELOC_X86_64_GOTOFF64;
	}
      fixp->fx_subsy = 0;
    }
}

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *rel;
  bfd_reloc_code_real_type code;

  switch (fixp->fx_r_type)
    {
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
    case BFD_RELOC_SIZE32:
    case BFD_RELOC_SIZE64:
      if (S_IS_DEFINED (fixp->fx_addsy)
	  && !S_IS_EXTERNAL (fixp->fx_addsy))
	{
	  /* Resolve size relocation against local symbol to size of
	     the symbol plus addend.  */
	  valueT value = S_GET_SIZE (fixp->fx_addsy) + fixp->fx_offset;
	  if (fixp->fx_r_type == BFD_RELOC_SIZE32
	      && !fits_in_unsigned_long (value))
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("symbol size computation overflow"));
	  fixp->fx_addsy = NULL;
	  fixp->fx_subsy = NULL;
	  md_apply_fix (fixp, (valueT *) &value, NULL);
	  return NULL;
	}
#endif

    case BFD_RELOC_X86_64_PLT32:
    case BFD_RELOC_X86_64_GOT32:
    case BFD_RELOC_X86_64_GOTPCREL:
    case BFD_RELOC_386_PLT32:
    case BFD_RELOC_386_GOT32:
    case BFD_RELOC_386_GOTOFF:
    case BFD_RELOC_386_GOTPC:
    case BFD_RELOC_386_TLS_GD:
    case BFD_RELOC_386_TLS_LDM:
    case BFD_RELOC_386_TLS_LDO_32:
    case BFD_RELOC_386_TLS_IE_32:
    case BFD_RELOC_386_TLS_IE:
    case BFD_RELOC_386_TLS_GOTIE:
    case BFD_RELOC_386_TLS_LE_32:
    case BFD_RELOC_386_TLS_LE:
    case BFD_RELOC_386_TLS_GOTDESC:
    case BFD_RELOC_386_TLS_DESC_CALL:
    case BFD_RELOC_X86_64_TLSGD:
    case BFD_RELOC_X86_64_TLSLD:
    case BFD_RELOC_X86_64_DTPOFF32:
    case BFD_RELOC_X86_64_DTPOFF64:
    case BFD_RELOC_X86_64_GOTTPOFF:
    case BFD_RELOC_X86_64_TPOFF32:
    case BFD_RELOC_X86_64_TPOFF64:
    case BFD_RELOC_X86_64_GOTOFF64:
    case BFD_RELOC_X86_64_GOTPC32:
    case BFD_RELOC_X86_64_GOT64:
    case BFD_RELOC_X86_64_GOTPCREL64:
    case BFD_RELOC_X86_64_GOTPC64:
    case BFD_RELOC_X86_64_GOTPLT64:
    case BFD_RELOC_X86_64_PLTOFF64:
    case BFD_RELOC_X86_64_GOTPC32_TLSDESC:
    case BFD_RELOC_X86_64_TLSDESC_CALL:
    case BFD_RELOC_RVA:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
#ifdef TE_PE
    case BFD_RELOC_32_SECREL:
#endif
      code = fixp->fx_r_type;
      break;
    case BFD_RELOC_X86_64_32S:
      if (!fixp->fx_pcrel)
	{
	  /* Don't turn BFD_RELOC_X86_64_32S into BFD_RELOC_32.  */
	  code = fixp->fx_r_type;
	  break;
	}
    default:
      if (fixp->fx_pcrel)
	{
	  switch (fixp->fx_size)
	    {
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("can not do %d byte pc-relative relocation"),
			    fixp->fx_size);
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case 1: code = BFD_RELOC_8_PCREL;  break;
	    case 2: code = BFD_RELOC_16_PCREL; break;
	    case 4: code = BFD_RELOC_32_PCREL; break;
#ifdef BFD64
	    case 8: code = BFD_RELOC_64_PCREL; break;
#endif
	    }
	}
      else
	{
	  switch (fixp->fx_size)
	    {
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("can not do %d byte relocation"),
			    fixp->fx_size);
	      code = BFD_RELOC_32;
	      break;
	    case 1: code = BFD_RELOC_8;  break;
	    case 2: code = BFD_RELOC_16; break;
	    case 4: code = BFD_RELOC_32; break;
#ifdef BFD64
	    case 8: code = BFD_RELOC_64; break;
#endif
	    }
	}
      break;
    }

  if ((code == BFD_RELOC_32
       || code == BFD_RELOC_32_PCREL
       || code == BFD_RELOC_X86_64_32S)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      if (!object_64bit)
	code = BFD_RELOC_386_GOTPC;
      else
	code = BFD_RELOC_X86_64_GOTPC32;
    }
  if ((code == BFD_RELOC_64 || code == BFD_RELOC_64_PCREL)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_X86_64_GOTPC64;
    }

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);

  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;

  if (!use_rela_relocations)
    {
      /* HACK: Since i386 ELF uses Rel instead of Rela, encode the
	 vtable entry to be used in the relocation's section offset.  */
      if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
	rel->address = fixp->fx_offset;
#if defined (OBJ_COFF) && defined (TE_PE)
      else if (fixp->fx_addsy && S_IS_WEAK (fixp->fx_addsy))
	rel->addend = fixp->fx_addnumber - (S_GET_VALUE (fixp->fx_addsy) * 2);
      else
#endif
      rel->addend = 0;
    }
  /* Use the rela in 64bit mode.  */
  else
    {
      if (disallow_64bit_reloc)
	switch (code)
	  {
	  case BFD_RELOC_X86_64_DTPOFF64:
	  case BFD_RELOC_X86_64_TPOFF64:
	  case BFD_RELOC_64_PCREL:
	  case BFD_RELOC_X86_64_GOTOFF64:
	  case BFD_RELOC_X86_64_GOT64:
	  case BFD_RELOC_X86_64_GOTPCREL64:
	  case BFD_RELOC_X86_64_GOTPC64:
	  case BFD_RELOC_X86_64_GOTPLT64:
	  case BFD_RELOC_X86_64_PLTOFF64:
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("cannot represent relocation type %s in x32 mode"),
			  bfd_get_reloc_code_name (code));
	    break;
	  default:
	    break;
	  }

      if (!fixp->fx_pcrel)
	rel->addend = fixp->fx_offset;
      else
	switch (code)
	  {
	  case BFD_RELOC_X86_64_PLT32:
	  case BFD_RELOC_X86_64_GOT32:
	  case BFD_RELOC_X86_64_GOTPCREL:
	  case BFD_RELOC_X86_64_TLSGD:
	  case BFD_RELOC_X86_64_TLSLD:
	  case BFD_RELOC_X86_64_GOTTPOFF:
	  case BFD_RELOC_X86_64_GOTPC32_TLSDESC:
	  case BFD_RELOC_X86_64_TLSDESC_CALL:
	    rel->addend = fixp->fx_offset - fixp->fx_size;
	    break;
	  default:
	    rel->addend = (section->vma
			   - fixp->fx_size
			   + fixp->fx_addnumber
			   + md_pcrel_from (fixp));
	    break;
	  }
    }

  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (code));
      /* Set howto to a garbage value so that we can keep going.  */
      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      gas_assert (rel->howto != NULL);
    }

  return rel;
}

#include "tc-i386-intel.c"

void
tc_x86_parse_to_dw2regnum (expressionS *exp)
{
  int saved_naked_reg;
  char saved_register_dot;

  saved_naked_reg = allow_naked_reg;
  allow_naked_reg = 1;
  saved_register_dot = register_chars['.'];
  register_chars['.'] = '.';
  allow_pseudo_reg = 1;
  expression_and_evaluate (exp);
  allow_pseudo_reg = 0;
  register_chars['.'] = saved_register_dot;
  allow_naked_reg = saved_naked_reg;

  if (exp->X_op == O_register && exp->X_add_number >= 0)
    {
      if ((addressT) exp->X_add_number < i386_regtab_size)
	{
	  exp->X_op = O_constant;
	  exp->X_add_number = i386_regtab[exp->X_add_number]
			      .dw2_regnum[flag_code >> 1];
	}
      else
	exp->X_op = O_illegal;
    }
}

void
tc_x86_frame_initial_instructions (void)
{
  static unsigned int sp_regno[2];

  if (!sp_regno[flag_code >> 1])
    {
      char *saved_input = input_line_pointer;
      char sp[][4] = {"esp", "rsp"};
      expressionS exp;

      input_line_pointer = sp[flag_code >> 1];
      tc_x86_parse_to_dw2regnum (&exp);
      gas_assert (exp.X_op == O_constant);
      sp_regno[flag_code >> 1] = exp.X_add_number;
      input_line_pointer = saved_input;
    }

  cfi_add_CFA_def_cfa (sp_regno[flag_code >> 1], -x86_cie_data_alignment);
  cfi_add_CFA_offset (x86_dwarf2_return_column, x86_cie_data_alignment);
}

int
x86_dwarf2_addr_size (void)
{
#if defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF)
  if (x86_elf_abi == X86_64_X32_ABI)
    return 4;
#endif
  return bfd_arch_bits_per_address (stdoutput) / 8;
}

int
i386_elf_section_type (const char *str, size_t len)
{
  if (flag_code == CODE_64BIT
      && len == sizeof ("unwind") - 1
      && strncmp (str, "unwind", 6) == 0)
    return SHT_X86_64_UNWIND;

  return -1;
}

#ifdef TE_SOLARIS
void
i386_solaris_fix_up_eh_frame (segT sec)
{
  if (flag_code == CODE_64BIT)
    elf_section_type (sec) = SHT_X86_64_UNWIND;
}
#endif

#ifdef TE_PE
void
tc_pe_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
{
  expressionS exp;

  exp.X_op = O_secrel;
  exp.X_add_symbol = symbol;
  exp.X_add_number = 0;
  emit_expr (&exp, size);
}
#endif

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
/* For ELF on x86-64, add support for SHF_X86_64_LARGE.  */

bfd_vma
x86_64_section_letter (int letter, char **ptr_msg)
{
  if (flag_code == CODE_64BIT)
    {
      if (letter == 'l')
	return SHF_X86_64_LARGE;

      *ptr_msg = _("bad .section directive: want a,l,w,x,M,S,G,T in string");
    }
  else
    *ptr_msg = _("bad .section directive: want a,w,x,M,S,G,T in string");
  return -1;
}

bfd_vma
x86_64_section_word (char *str, size_t len)
{
  if (len == 5 && flag_code == CODE_64BIT && CONST_STRNEQ (str, "large"))
    return SHF_X86_64_LARGE;

  return -1;
}

static void
handle_large_common (int small ATTRIBUTE_UNUSED)
{
  if (flag_code != CODE_64BIT)
    {
      s_comm_internal (0, elf_common_parse);
      as_warn (_(".largecomm supported only in 64bit mode, producing .comm"));
    }
  else
    {
      static segT lbss_section;
      asection *saved_com_section_ptr = elf_com_section_ptr;
      asection *saved_bss_section = bss_section;

      if (lbss_section == NULL)
	{
	  flagword applicable;
	  segT seg = now_seg;
	  subsegT subseg = now_subseg;

	  /* The .lbss section is for local .largecomm symbols.  */
	  lbss_section = subseg_new (".lbss", 0);
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, lbss_section,
				 applicable & SEC_ALLOC);
	  seg_info (lbss_section)->bss = 1;

	  subseg_set (seg, subseg);
	}

      elf_com_section_ptr = &_bfd_elf_large_com_section;
      bss_section = lbss_section;

      s_comm_internal (0, elf_common_parse);

      elf_com_section_ptr = saved_com_section_ptr;
      bss_section = saved_bss_section;
    }
}
#endif /* OBJ_ELF || OBJ_MAYBE_ELF */
@


1.522
log
@Add AMD bdver4 support.

gas/
	* config/tc-i386.c (cpu_arch): Add CPU_BDVER4_FLAGS.
	* doc/c-i386.texi: Add -march=bdver4 option.

gas/testsuite/
	* gas/i386/i386.exp: Run bdver4 test cases.
	* gas/i386/nops-1-bdver4.d: New.
	* gas/i386/arch-10-bdver4.d: New.
	* gas/i386/x86-64-nops-1-bdver4.d: New.
	* gas/i386/x86-64-arch-2-bdver4.d: New.

opcodes/
	* i386-gen.c (cpu_flag_init): Add CPU_BDVER4_FLAGS.
	* i386-init.h: Regenerated.
@
text
@d5437 4
a5440 7
	else
	  as_warn (_("using `%s%s' instead of `%s%s' due to `%c' suffix"),
		   register_prefix,
		   (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
		   register_prefix,
		   i.op[op].regs->reg_name,
		   i.suffix);
a5545 1
	else
d5547 4
a5550 6
	  as_warn (_("using `%s%s' instead of `%s%s' due to `%c' suffix"),
		   register_prefix,
		   (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
		   register_prefix,
		   i.op[op].regs->reg_name,
		   i.suffix);
@


1.521
log
@Add Intel AVX-512 support

binutils/

2013-07-26  Sergey Guriev  <sergey.s.guriev@@intel.com>
	    Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Maxim Kuznetsov  <maxim.kuznetsov@@intel.com>
	    Sergey Lega  <sergey.s.lega@@intel.com>
	    Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Ilya Tocar  <ilya.tocar@@intel.com>
	    Andrey Turetskiy  <andrey.turetskiy@@intel.com>
	    Ilya Verbin  <ilya.verbin@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* dwarf.c (dwarf_regnames_i386): Add k0-k7 registers and
	numeration in comments.
	(dwarf_regnames_x86_64): Add xmm16-31 and k0-k7 registers to
	dwarf table.

gas/

2013-07-26  Sergey Guriev  <sergey.s.guriev@@intel.com>
	    Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Maxim Kuznetsov  <maxim.kuznetsov@@intel.com>
	    Sergey Lega  <sergey.s.lega@@intel.com>
	    Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Ilya Tocar  <ilya.tocar@@intel.com>
	    Andrey Turetskiy  <andrey.turetskiy@@intel.com>
	    Ilya Verbin  <ilya.verbin@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* config/tc-i386-intel.c (O_zmmword_ptr): New.
	(i386_types): Add zmmword.
	(i386_intel_simplify_register): Allow regzmm.
	(i386_intel_simplify): Handle zmmwords.
	(i386_intel_operand): Handle RC/SAE, vector operations and
	zmmwords.
	* config/tc-i386.c (ZMMWORD_MNEM_SUFFIX): New.
	(struct RC_Operation): New.
	(struct Mask_Operation): New.
	(struct Broadcast_Operation): New.
	(vex_prefix): Size of bytes increased to 4 to support EVEX
	encoding.
	(enum i386_error): Add new error codes: unsupported_broadcast,
	broadcast_not_on_src_operand, broadcast_needed,
	unsupported_masking, mask_not_on_destination, no_default_mask,
	unsupported_rc_sae, rc_sae_operand_not_last_imm,
	invalid_register_operand, try_vector_disp8.
	(struct _i386_insn): Add new fields vrex, need_vrex, mask,
	rounding, broadcast, memshift.
	(struct RC_name): New.
	(RC_NamesTable): New.
	(evexlig): New.
	(evexwig): New.
	(extra_symbol_chars): Add '{'.
	(cpu_arch): Add AVX512F, AVX512CD, AVX512ER and AVX512PF.
	(i386_operand_type): Add regzmm, regmask and vec_disp8.
	(match_mem_size): Handle zmmwords.
	(operand_type_match): Handle zmm-registers.
	(mode_from_disp_size): Handle vec_disp8.
	(fits_in_vec_disp8): New.
	(md_begin): Handle {} properly.
	(type_names): Add "rZMM", "Mask reg" and "Vector d8".
	(build_vex_prefix): Handle vrex.
	(build_evex_prefix): New.
	(process_immext): Adjust to properly handle EVEX.
	(md_assemble): Add EVEX encoding support.
	(swap_2_operands): Correctly handle operands with masking,
	broadcasting or RC/SAE.
	(check_VecOperands): Support EVEX features.
	(VEX_check_operands): Properly handle 16 upper [xyz]mm registers.
	(match_template): Support regzmm and handle new error codes.
	(process_suffix): Handle zmmwords and zmm-registers.
	(check_byte_reg): Extend to zmm-registers.
	(process_operands): Extend to zmm-registers.
	(build_modrm_byte): Handle EVEX.
	(output_insn): Adjust to properly handle EVEX case.
	(disp_size): Handle vec_disp8.
	(output_disp): Support compressed disp8*N evex feature.
	(output_imm): Handle RC/SAE immediates properly.
	(check_VecOperations): New.
	(i386_immediate): Handle EVEX features.
	(i386_index_check): Handle zmmwords and zmm-registers.
	(RC_SAE_immediate): New.
	(i386_att_operand): Handle EVEX features.
	(parse_real_register): Add a check for ZMM/Mask registers.
	(OPTION_MEVEXLIG): New.
	(OPTION_MEVEXWIG): New.
	(md_longopts): Add mevexlig and mevexwig.
	(md_parse_option): Handle mevexlig and mevexwig options.
	(md_show_usage): Add description for mevexlig and mevexwig.
	* doc/c-i386.texi: Document avx512f/.avx512f, avx512cd/.avx512cd,
	avx512er/.avx512er, avx512pf/.avx512pf, mevexlig and mevexwig.

gas/testsuite/

2013-07-26  Sergey Guriev  <sergey.s.guriev@@intel.com>
	    Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Maxim Kuznetsov  <maxim.kuznetsov@@intel.com>
	    Sergey Lega  <sergey.s.lega@@intel.com>
	    Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Ilya Tocar  <ilya.tocar@@intel.com>
	    Andrey Turetskiy  <andrey.turetskiy@@intel.com>
	    Ilya Verbin  <ilya.verbin@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* gas/cfi/cfi-i386.s: Add tests for k0-k7.
	* gas/cfi/cfi-i386.d: Change to reflect above mentioned changes.
	* gas/cfi/cfi-x86_64.s: Add tests for xmm16-31, k0-7.
	* gas/cfi/cfi-x86_64.d: Change to reflect above mentioned changes.
	* gas/i386/ilp32/cfi/cfi-x86_64.d: Ditto.
	* gas/i386/intel-regs.s: Add tests for zmm0 and xmm16 registers.
	* gas/i386/intel-regs.d: Change correspondingly.
	* gas/i386/prefetch-intel.d: Reflect implementation of prefetchwt1.
	* gas/i386/prefetch.d: Ditto.
	* gas/i386/x86-64-prefetch-intel.d: Ditto.
	* gas/i386/x86-64-prefetch.d: Ditto.
	* gas/i386/avx512f-intel.d: New.
	* gas/i386/avx512f-nondef.d: New.
	* gas/i386/avx512f-nondef.s: New.
	* gas/i386/avx512f-opts-intel.d: New.
	* gas/i386/avx512f-opts.d: New.
	* gas/i386/avx512f-opts.s: New.
	* gas/i386/avx512f.d: New.
	* gas/i386/avx512f.s: New.
	* gas/i386/avx512cd-intel.d: New.
	* gas/i386/avx512cd.d: New.
	* gas/i386/avx512cd.s: New.
	* gas/i386/avx512er-intel.d: New.
	* gas/i386/avx512er.d: New.
	* gas/i386/avx512er.s: New.
	* gas/i386/avx512pf-intel.d: New.
	* gas/i386/avx512pf.d: New.
	* gas/i386/avx512pf.s: New.
	* gas/i386/evex-lig.s: New.
	* gas/i386/evex-lig256-intel.d: New.
	* gas/i386/evex-lig256.d: New.
	* gas/i386/evex-lig512-intel.d: New.
	* gas/i386/evex-lig512.d: New.
	* gas/i386/evex-wig.s: New.
	* gas/i386/evex-wig1-intel.d: New.
	* gas/i386/evex-wig1.d: New.
	* gas/i386/inval-avx512f.l: New.
	* gas/i386/inval-avx512f.s: New.
	* gas/i386/x86-64-avx512f-intel.d: New.
	* gas/i386/x86-64-avx512f-nondef.d: New.
	* gas/i386/x86-64-avx512f-nondef.s: New.
	* gas/i386/x86-64-avx512f-opts-intel.d: New.
	* gas/i386/x86-64-avx512f-opts.d: New.
	* gas/i386/x86-64-avx512f-opts.s: New.
	* gas/i386/x86-64-avx512f.d: New.
	* gas/i386/x86-64-avx512f.s: New.
	* gas/i386/x86-64-avx512cd-intel.d: New.
	* gas/i386/x86-64-avx512cd.d: New.
	* gas/i386/x86-64-avx512cd.s: New.
	* gas/i386/x86-64-avx512er-intel.d: New.
	* gas/i386/x86-64-avx512er.d: New.
	* gas/i386/x86-64-avx512er.s: New.
	* gas/i386/x86-64-avx512pf-intel.d: New.
	* gas/i386/x86-64-avx512pf.d: New.
	* gas/i386/x86-64-avx512pf.s: New.
	* gas/i386/x86-64-evex-lig.s: New.
	* gas/i386/x86-64-evex-lig256-intel.d: New.
	* gas/i386/x86-64-evex-lig256.d: New.
	* gas/i386/x86-64-evex-lig512-intel.d: New.
	* gas/i386/x86-64-evex-lig512.d: New.
	* gas/i386/x86-64-evex-wig.s: New.
	* gas/i386/x86-64-evex-wig1-intel.d: New.
	* gas/i386/x86-64-evex-wig1.d: New.
	* gas/i386/x86-64-inval-avx512f.l: New.
	* gas/i386/x86-64-inval-avx512f.s: New.
	* gas/i386/i386.exp: Run new AVX-512 tests.

opcodes/

2013-07-26  Sergey Guriev  <sergey.s.guriev@@intel.com>
	    Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Maxim Kuznetsov  <maxim.kuznetsov@@intel.com>
	    Sergey Lega  <sergey.s.lega@@intel.com>
	    Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Ilya Tocar  <ilya.tocar@@intel.com>
	    Andrey Turetskiy  <andrey.turetskiy@@intel.com>
	    Ilya Verbin  <ilya.verbin@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* i386-dis-evex.h: New.
	* i386-dis.c (OP_Rounding): New.
	(VPCMP_Fixup): New.
	(OP_Mask): New.
	(Rdq): New.
	(XMxmmq): New.
	(EXdScalarS): New.
	(EXymm): New.
	(EXEvexHalfBcstXmmq): New.
	(EXxmm_mdq): New.
	(EXEvexXGscat): New.
	(EXEvexXNoBcst): New.
	(VPCMP): New.
	(EXxEVexR): New.
	(EXxEVexS): New.
	(XMask): New.
	(MaskG): New.
	(MaskE): New.
	(MaskR): New.
	(MaskVex): New.
	(modes enum): Add evex_x_gscat_mode, evex_x_nobcst_mode,
	evex_half_bcst_xmmq_mode, xmm_mdq_mode, ymm_mode,
	evex_rounding_mode, evex_sae_mode, mask_mode.
	(USE_EVEX_TABLE): New.
	(EVEX_TABLE): New.
	(EVEX enum): New.
	(REG enum): Add REG_EVEX_0F72, REG_EVEX_0F73, REG_EVEX_0F38C6,
	REG_EVEX_0F38C7.
	(MOD enum): Add MOD_EVEX_0F10_PREFIX_1, MOD_EVEX_0F10_PREFIX_3,
	MOD_EVEX_0F11_PREFIX_1, MOD_EVEX_0F11_PREFIX_3,
	MOD_EVEX_0F12_PREFIX_0, MOD_EVEX_0F16_PREFIX_0, MOD_EVEX_0F38C6_REG_1,
	MOD_EVEX_0F38C6_REG_2, MOD_EVEX_0F38C6_REG_5, MOD_EVEX_0F38C6_REG_6,
	MOD_EVEX_0F38C7_REG_1, MOD_EVEX_0F38C7_REG_2,  MOD_EVEX_0F38C7_REG_5,
	MOD_EVEX_0F38C7_REG_6.
	(PREFIX enum): Add PREFIX_VEX_0F41, PREFIX_VEX_0F42, PREFIX_VEX_0F44,
	PREFIX_VEX_0F45, PREFIX_VEX_0F46, PREFIX_VEX_0F47, PREFIX_VEX_0F4B,
	PREFIX_VEX_0F90, PREFIX_VEX_0F91, PREFIX_VEX_0F92, PREFIX_VEX_0F93,
	PREFIX_VEX_0F98, PREFIX_VEX_0F3A30, PREFIX_VEX_0F3A32,
	PREFIX_VEX_0F3AF0, PREFIX_EVEX_0F10, PREFIX_EVEX_0F11,
	PREFIX_EVEX_0F12, PREFIX_EVEX_0F13, PREFIX_EVEX_0F14,
	PREFIX_EVEX_0F15, PREFIX_EVEX_0F16, PREFIX_EVEX_0F17,
	PREFIX_EVEX_0F28, PREFIX_EVEX_0F29, PREFIX_EVEX_0F2A,
	PREFIX_EVEX_0F2B, PREFIX_EVEX_0F2C, PREFIX_EVEX_0F2D,
	PREFIX_EVEX_0F2E, PREFIX_EVEX_0F2F, PREFIX_EVEX_0F51,
	PREFIX_EVEX_0F58, PREFIX_EVEX_0F59, PREFIX_EVEX_0F5A,
	PREFIX_EVEX_0F5B, PREFIX_EVEX_0F5C, PREFIX_EVEX_0F5D,
	PREFIX_EVEX_0F5E, PREFIX_EVEX_0F5F, PREFIX_EVEX_0F62,
	PREFIX_EVEX_0F66, PREFIX_EVEX_0F6A, PREFIX_EVEX_0F6C,
	PREFIX_EVEX_0F6D, PREFIX_EVEX_0F6E, PREFIX_EVEX_0F6F,
	PREFIX_EVEX_0F70, PREFIX_EVEX_0F72_REG_0, PREFIX_EVEX_0F72_REG_1,
	PREFIX_EVEX_0F72_REG_2, PREFIX_EVEX_0F72_REG_4,
	PREFIX_EVEX_0F72_REG_6, PREFIX_EVEX_0F73_REG_2,
	PREFIX_EVEX_0F73_REG_6, PREFIX_EVEX_0F76, PREFIX_EVEX_0F78,
	PREFIX_EVEX_0F79, PREFIX_EVEX_0F7A, PREFIX_EVEX_0F7B,
	PREFIX_EVEX_0F7E, PREFIX_EVEX_0F7F, PREFIX_EVEX_0FC2,
	PREFIX_EVEX_0FC6, PREFIX_EVEX_0FD2, PREFIX_EVEX_0FD3,
	PREFIX_EVEX_0FD4, PREFIX_EVEX_0FD6, PREFIX_EVEX_0FDB,
	PREFIX_EVEX_0FDF, PREFIX_EVEX_0FE2, PREFIX_EVEX_0FE6 PREFIX_EVEX_0FE7,
	PREFIX_EVEX_0FEB, PREFIX_EVEX_0FEF, PREFIX_EVEX_0FF2,
	PREFIX_EVEX_0FF3, PREFIX_EVEX_0FF4, PREFIX_EVEX_0FFA, PREFIX_EVEX_0FFB,
	PREFIX_EVEX_0FFE, PREFIX_EVEX_0F380C, PREFIX_EVEX_0F380D,
	PREFIX_EVEX_0F3811, PREFIX_EVEX_0F3812, PREFIX_EVEX_0F3813,
	PREFIX_EVEX_0F3814, PREFIX_EVEX_0F3815, PREFIX_EVEX_0F3816,
	PREFIX_EVEX_0F3818, PREFIX_EVEX_0F3819, PREFIX_EVEX_0F381A,
	PREFIX_EVEX_0F381B, PREFIX_EVEX_0F381E, PREFIX_EVEX_0F381F,
	PREFIX_EVEX_0F3821, PREFIX_EVEX_0F3822, PREFIX_EVEX_0F3823,
	PREFIX_EVEX_0F3824, PREFIX_EVEX_0F3825, PREFIX_EVEX_0F3827,
	PREFIX_EVEX_0F3828, PREFIX_EVEX_0F3829, PREFIX_EVEX_0F382A,
	PREFIX_EVEX_0F382C, PREFIX_EVEX_0F382D, PREFIX_EVEX_0F3831,
	PREFIX_EVEX_0F3832, PREFIX_EVEX_0F3833, PREFIX_EVEX_0F3834,
	PREFIX_EVEX_0F3835, PREFIX_EVEX_0F3836, PREFIX_EVEX_0F3837,
	PREFIX_EVEX_0F3839, PREFIX_EVEX_0F383A, PREFIX_EVEX_0F383B,
	PREFIX_EVEX_0F383D, PREFIX_EVEX_0F383F, PREFIX_EVEX_0F3840,
	PREFIX_EVEX_0F3842, PREFIX_EVEX_0F3843, PREFIX_EVEX_0F3844,
	PREFIX_EVEX_0F3845, PREFIX_EVEX_0F3846, PREFIX_EVEX_0F3847,
	PREFIX_EVEX_0F384C, PREFIX_EVEX_0F384D, PREFIX_EVEX_0F384E,
	PREFIX_EVEX_0F384F, PREFIX_EVEX_0F3858, PREFIX_EVEX_0F3859,
	PREFIX_EVEX_0F385A, PREFIX_EVEX_0F385B, PREFIX_EVEX_0F3864,
	PREFIX_EVEX_0F3865, PREFIX_EVEX_0F3876, PREFIX_EVEX_0F3877,
	PREFIX_EVEX_0F387C, PREFIX_EVEX_0F387E, PREFIX_EVEX_0F387F,
	PREFIX_EVEX_0F3888, PREFIX_EVEX_0F3889, PREFIX_EVEX_0F388A,
	PREFIX_EVEX_0F388B, PREFIX_EVEX_0F3890, PREFIX_EVEX_0F3891,
	PREFIX_EVEX_0F3892, PREFIX_EVEX_0F3893, PREFIX_EVEX_0F3896,
	PREFIX_EVEX_0F3897, PREFIX_EVEX_0F3898, PREFIX_EVEX_0F3899,
	PREFIX_EVEX_0F389A, PREFIX_EVEX_0F389B, PREFIX_EVEX_0F389C,
	PREFIX_EVEX_0F389D, PREFIX_EVEX_0F389E, PREFIX_EVEX_0F389F,
	PREFIX_EVEX_0F38A0, PREFIX_EVEX_0F38A1, PREFIX_EVEX_0F38A2,
	PREFIX_EVEX_0F38A3, PREFIX_EVEX_0F38A6, PREFIX_EVEX_0F38A7,
	PREFIX_EVEX_0F38A8, PREFIX_EVEX_0F38A9, PREFIX_EVEX_0F38AA,
	PREFIX_EVEX_0F38AB, PREFIX_EVEX_0F38AC, PREFIX_EVEX_0F38AD,
	PREFIX_EVEX_0F38AE, PREFIX_EVEX_0F38AF, PREFIX_EVEX_0F38B6,
	PREFIX_EVEX_0F38B7, PREFIX_EVEX_0F38B8, PREFIX_EVEX_0F38B9,
	PREFIX_EVEX_0F38BA, PREFIX_EVEX_0F38BB, PREFIX_EVEX_0F38BC,
	PREFIX_EVEX_0F38BD, PREFIX_EVEX_0F38BE, PREFIX_EVEX_0F38BF,
	PREFIX_EVEX_0F38C4, PREFIX_EVEX_0F38C6_REG_1,
	PREFIX_EVEX_0F38C6_REG_2, PREFIX_EVEX_0F38C6_REG_5,
	PREFIX_EVEX_0F38C6_REG_6, PREFIX_EVEX_0F38C7_REG_1,
	PREFIX_EVEX_0F38C7_REG_2, PREFIX_EVEX_0F38C7_REG_5,
	PREFIX_EVEX_0F38C7_REG_6, PREFIX_EVEX_0F38C8, PREFIX_EVEX_0F38CA,
	PREFIX_EVEX_0F38CB, PREFIX_EVEX_0F38CC, PREFIX_EVEX_0F38CD,
	PREFIX_EVEX_0F3A00,  PREFIX_EVEX_0F3A01, PREFIX_EVEX_0F3A03,
	PREFIX_EVEX_0F3A04, PREFIX_EVEX_0F3A05, PREFIX_EVEX_0F3A08,
	PREFIX_EVEX_0F3A09, PREFIX_EVEX_0F3A0A, PREFIX_EVEX_0F3A0B,
	PREFIX_EVEX_0F3A17, PREFIX_EVEX_0F3A18, PREFIX_EVEX_0F3A19,
	PREFIX_EVEX_0F3A1A, PREFIX_EVEX_0F3A1B, PREFIX_EVEX_0F3A1D,
	PREFIX_EVEX_0F3A1E, PREFIX_EVEX_0F3A1F, PREFIX_EVEX_0F3A21,
	PREFIX_EVEX_0F3A23, PREFIX_EVEX_0F3A25, PREFIX_EVEX_0F3A26,
	PREFIX_EVEX_0F3A27, PREFIX_EVEX_0F3A38, PREFIX_EVEX_0F3A39,
	PREFIX_EVEX_0F3A3A, PREFIX_EVEX_0F3A3B, PREFIX_EVEX_0F3A3E,
	PREFIX_EVEX_0F3A3F, PREFIX_EVEX_0F3A43, PREFIX_EVEX_0F3A54,
	PREFIX_EVEX_0F3A55.
	(VEX_LEN enum): Add VEX_LEN_0F41_P_0, VEX_LEN_0F42_P_0, VEX_LEN_0F44_P_0,
	VEX_LEN_0F45_P_0, VEX_LEN_0F46_P_0, VEX_LEN_0F47_P_0,
	VEX_LEN_0F4B_P_2, VEX_LEN_0F90_P_0, VEX_LEN_0F91_P_0,
	VEX_LEN_0F92_P_0, VEX_LEN_0F93_P_0, VEX_LEN_0F98_P_0,
	VEX_LEN_0F3A30_P_2, VEX_LEN_0F3A32_P_2, VEX_W_0F41_P_0_LEN_1,
	VEX_W_0F42_P_0_LEN_1, VEX_W_0F44_P_0_LEN_0, VEX_W_0F45_P_0_LEN_1,
	VEX_W_0F46_P_0_LEN_1, VEX_W_0F47_P_0_LEN_1, VEX_W_0F4B_P_2_LEN_1,
	VEX_W_0F90_P_0_LEN_0, VEX_W_0F91_P_0_LEN_0, VEX_W_0F92_P_0_LEN_0,
	VEX_W_0F93_P_0_LEN_0, VEX_W_0F98_P_0_LEN_0, VEX_W_0F3A30_P_2_LEN_0,
	VEX_W_0F3A32_P_2_LEN_0.
	(VEX_W enum): Add EVEX_W_0F10_P_0, EVEX_W_0F10_P_1_M_0,
	EVEX_W_0F10_P_1_M_1, EVEX_W_0F10_P_2, EVEX_W_0F10_P_3_M_0,
	EVEX_W_0F10_P_3_M_1, EVEX_W_0F11_P_0, EVEX_W_0F11_P_1_M_0,
	EVEX_W_0F11_P_1_M_1, EVEX_W_0F11_P_2, EVEX_W_0F11_P_3_M_0,
	EVEX_W_0F11_P_3_M_1, EVEX_W_0F12_P_0_M_0, EVEX_W_0F12_P_0_M_1,
	EVEX_W_0F12_P_1, EVEX_W_0F12_P_2, EVEX_W_0F12_P_3, EVEX_W_0F13_P_0,
	EVEX_W_0F13_P_2, EVEX_W_0F14_P_0, EVEX_W_0F14_P_2, EVEX_W_0F15_P_0,
	EVEX_W_0F15_P_2, EVEX_W_0F16_P_0_M_0, EVEX_W_0F16_P_0_M_1,
	EVEX_W_0F16_P_1, EVEX_W_0F16_P_2, EVEX_W_0F17_P_0, EVEX_W_0F17_P_2,
	EVEX_W_0F28_P_0, EVEX_W_0F28_P_2, EVEX_W_0F29_P_0, EVEX_W_0F29_P_2,
	EVEX_W_0F2A_P_1, EVEX_W_0F2A_P_3, EVEX_W_0F2B_P_0, EVEX_W_0F2B_P_2,
	EVEX_W_0F2E_P_0, EVEX_W_0F2E_P_2, EVEX_W_0F2F_P_0, EVEX_W_0F2F_P_2,
	EVEX_W_0F51_P_0, EVEX_W_0F51_P_1, EVEX_W_0F51_P_2, EVEX_W_0F51_P_3,
	EVEX_W_0F58_P_0, EVEX_W_0F58_P_1, EVEX_W_0F58_P_2, EVEX_W_0F58_P_3,
	EVEX_W_0F59_P_0, EVEX_W_0F59_P_1, EVEX_W_0F59_P_2, EVEX_W_0F59_P_3,
	EVEX_W_0F5A_P_0, EVEX_W_0F5A_P_1, EVEX_W_0F5A_P_2, EVEX_W_0F5A_P_3,
	EVEX_W_0F5B_P_0, EVEX_W_0F5B_P_1, EVEX_W_0F5B_P_2, EVEX_W_0F5C_P_0,
	EVEX_W_0F5C_P_1, EVEX_W_0F5C_P_2, EVEX_W_0F5C_P_3, EVEX_W_0F5D_P_0,
	EVEX_W_0F5D_P_1, EVEX_W_0F5D_P_2, EVEX_W_0F5D_P_3, EVEX_W_0F5E_P_0,
	EVEX_W_0F5E_P_1, EVEX_W_0F5E_P_2, EVEX_W_0F5E_P_3, EVEX_W_0F5F_P_0,
	EVEX_W_0F5F_P_1, EVEX_W_0F5F_P_2, EVEX_W_0F5F_P_3, EVEX_W_0F62_P_2,
	EVEX_W_0F66_P_2, EVEX_W_0F6A_P_2, EVEX_W_0F6C_P_2, EVEX_W_0F6D_P_2,
	EVEX_W_0F6E_P_2, EVEX_W_0F6F_P_1, EVEX_W_0F6F_P_2, EVEX_W_0F70_P_2,
	EVEX_W_0F72_R_2_P_2, EVEX_W_0F72_R_6_P_2, EVEX_W_0F73_R_2_P_2,
	EVEX_W_0F73_R_6_P_2, EVEX_W_0F76_P_2, EVEX_W_0F78_P_0,
	EVEX_W_0F79_P_0, EVEX_W_0F7A_P_1, EVEX_W_0F7A_P_3, EVEX_W_0F7B_P_1,
	EVEX_W_0F7B_P_3, EVEX_W_0F7E_P_1, EVEX_W_0F7E_P_2, EVEX_W_0F7F_P_1,
	EVEX_W_0F7F_P_2, EVEX_W_0FC2_P_0, EVEX_W_0FC2_P_1, EVEX_W_0FC2_P_2,
	EVEX_W_0FC2_P_3, EVEX_W_0FC6_P_0, EVEX_W_0FC6_P_2, EVEX_W_0FD2_P_2,
	EVEX_W_0FD3_P_2, EVEX_W_0FD4_P_2, EVEX_W_0FD6_P_2, EVEX_W_0FE6_P_1,
	EVEX_W_0FE6_P_2, EVEX_W_0FE6_P_3, EVEX_W_0FE7_P_2, EVEX_W_0FF2_P_2,
	EVEX_W_0FF3_P_2, EVEX_W_0FF4_P_2, EVEX_W_0FFA_P_2, EVEX_W_0FFB_P_2,
	EVEX_W_0FFE_P_2, EVEX_W_0F380C_P_2, EVEX_W_0F380D_P_2,
	EVEX_W_0F3811_P_1, EVEX_W_0F3812_P_1, EVEX_W_0F3813_P_1,
	EVEX_W_0F3813_P_2, EVEX_W_0F3814_P_1, EVEX_W_0F3815_P_1,
	EVEX_W_0F3818_P_2, EVEX_W_0F3819_P_2, EVEX_W_0F381A_P_2,
	EVEX_W_0F381B_P_2, EVEX_W_0F381E_P_2, EVEX_W_0F381F_P_2,
	EVEX_W_0F3821_P_1, EVEX_W_0F3822_P_1, EVEX_W_0F3823_P_1,
	EVEX_W_0F3824_P_1, EVEX_W_0F3825_P_1, EVEX_W_0F3825_P_2,
	EVEX_W_0F3828_P_2, EVEX_W_0F3829_P_2, EVEX_W_0F382A_P_1,
	EVEX_W_0F382A_P_2, EVEX_W_0F3831_P_1, EVEX_W_0F3832_P_1,
	EVEX_W_0F3833_P_1, EVEX_W_0F3834_P_1, EVEX_W_0F3835_P_1,
	EVEX_W_0F3835_P_2, EVEX_W_0F3837_P_2, EVEX_W_0F383A_P_1,
	EVEX_W_0F3840_P_2, EVEX_W_0F3858_P_2, EVEX_W_0F3859_P_2,
	EVEX_W_0F385A_P_2, EVEX_W_0F385B_P_2, EVEX_W_0F3891_P_2,
	EVEX_W_0F3893_P_2, EVEX_W_0F38A1_P_2, EVEX_W_0F38A3_P_2,
	EVEX_W_0F38C7_R_1_P_2, EVEX_W_0F38C7_R_2_P_2, EVEX_W_0F38C7_R_5_P_2,
	EVEX_W_0F38C7_R_6_P_2, EVEX_W_0F3A00_P_2, EVEX_W_0F3A01_P_2,
	EVEX_W_0F3A04_P_2, EVEX_W_0F3A05_P_2, EVEX_W_0F3A08_P_2,
	EVEX_W_0F3A09_P_2, EVEX_W_0F3A0A_P_2, EVEX_W_0F3A0B_P_2,
	EVEX_W_0F3A18_P_2, EVEX_W_0F3A19_P_2, EVEX_W_0F3A1A_P_2,
	EVEX_W_0F3A1B_P_2, EVEX_W_0F3A1D_P_2, EVEX_W_0F3A21_P_2,
	EVEX_W_0F3A23_P_2, EVEX_W_0F3A38_P_2, EVEX_W_0F3A39_P_2,
	EVEX_W_0F3A3A_P_2, EVEX_W_0F3A3B_P_2, EVEX_W_0F3A43_P_2.
	(struct vex): Add fields evex, r, v, mask_register_specifier,
	zeroing, ll, b.
	(intel_names_xmm): Add upper 16 registers.
	(att_names_xmm): Ditto.
	(intel_names_ymm): Ditto.
	(att_names_ymm): Ditto.
	(names_zmm): New.
	(intel_names_zmm): Ditto.
	(att_names_zmm): Ditto.
	(names_mask): Ditto.
	(intel_names_mask): Ditto.
	(att_names_mask): Ditto.
	(names_rounding): Ditto.
	(names_broadcast): Ditto.
	(x86_64_table): Add escape to evex-table.
	(reg_table): Include reg_table evex-entries from
	i386-dis-evex.h.  Fix prefetchwt1 instruction.
	(prefix_table): Add entries for new instructions.
	(vex_table): Ditto.
	(vex_len_table): Ditto.
	(vex_w_table): Ditto.
	(mod_table): Ditto.
	(get_valid_dis386): Properly handle new instructions.
	(print_insn): Handle zmm and mask registers, print mask operand.
	(intel_operand_size): Support EVEX, new modes and sizes.
	(OP_E_register): Handle new modes.
	(OP_E_memory): Ditto.
	(OP_G): Ditto.
	(OP_XMM): Ditto.
	(OP_EX): Ditto.
	(OP_VEX): Ditto.
	* i386-gen.c (cpu_flag_init): Update CPU_ANY_SSE_FLAGS and
	CPU_ANY_AVX_FLAGS.  Add CPU_AVX512F_FLAGS, CPU_AVX512CD_FLAGS,
	CPU_AVX512ER_FLAGS and CPU_AVX512PF_FLAGS.
	(cpu_flags): Add CpuAVX512F, CpuAVX512CD, CpuAVX512ER,
	CpuAVX512PF and CpuVREX.
	(operand_type_init): Add OPERAND_TYPE_REGZMM,
	OPERAND_TYPE_REGMASK and OPERAND_TYPE_VEC_DISP8.
	(opcode_modifiers): Add EVex, Masking, VecESize, Broadcast,
	StaticRounding, SAE, Disp8MemShift, NoDefMask.
	(operand_types): Add RegZMM, RegMask, Vec_Disp8, Zmmword.
	* i386-init.h: Regenerate.
	* i386-opc.h (CpuAVX512F): New.
	(CpuAVX512CD): New.
	(CpuAVX512ER): New.
	(CpuAVX512PF): New.
	(CpuVREX): New.
	(i386_cpu_flags): Add cpuavx512f, cpuavx512cd, cpuavx512er,
	cpuavx512pf and cpuvrex fields.
	(VecSIB): Add VecSIB512.
	(EVex): New.
	(Masking): New.
	(VecESize): New.
	(Broadcast): New.
	(StaticRounding): New.
	(SAE): New.
	(Disp8MemShift): New.
	(NoDefMask): New.
	(i386_opcode_modifier): Add evex, masking, vecesize, broadcast,
	staticrounding, sae, disp8memshift and nodefmask.
	(RegZMM): New.
	(Zmmword): Ditto.
	(Vec_Disp8): Ditto.
	(i386_operand_type): Add regzmm, regmask, zmmword and vec_disp8
	fields.
	(RegVRex): New.
	* i386-opc.tbl: Add AVX512 instructions.
	* i386-reg.tbl: Add 16 upper XMM and YMM registers, 32 new ZMM
	registers, mask registers.
	* i386-tbl.h: Regenerate.
@
text
@d775 2
@


1.520
log
@Support Intel SHA

gas/

2013-07-25  Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* config/tc-i386.c (cpu_arch): Add .sha.
	* doc/c-i386.texi: Document sha/.sha.

gas/testsuite/

2013-07-25  Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* gas/i386/sha.d: New.
	* gas/i386/sha.s: New.
	* gas/i386/x86-64-sha.d: New.
	* gas/i386/x86-64-sha.s: New.
	* gas/i386/i386.exp: Run new SHA tests.

opcodes/

2013-07-25  Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* i386-dis.c (PREFIX enum): Add PREFIX_0F38C8, PREFIX_0F38C9,
	PREFIX_0F38CA, PREFIX_0F38CB, PREFIX_0F38CC, PREFIX_0F38CD,
	PREFIX_0F3ACC.
	(prefix_table): Updated.
	(three_byte_table): Likewise.
	* i386-gen.c (cpu_flag_init): Add CPU_SHA_FLAGS.
	(cpu_flags): Add CpuSHA.
	(i386_cpu_flags): Add cpusha.
	* i386-init.h: Regenerate.
	* i386-opc.h (CpuSHA): New.
	(CpuUnused): Restored.
	(i386_cpu_flags): Add cpusha.
	* i386-opc.tbl: Add SHA instructions.
	* i386-tbl.h: Regenerate.
@
text
@d89 1
d193 42
d238 2
a239 2
  /* VEX prefix is either 2 byte or 3 byte.  */
  unsigned char bytes[3];
d269 11
a279 1
    unsupported_vector_index_register
d333 1
d337 12
d369 3
d378 18
d398 1
a398 1
const char extra_symbol_chars[] = "*%-(["
d602 15
d811 8
d1656 2
d1669 1
d1752 3
a1754 1
		   && !t->operand_types[j].bitfield.ymmword)));
d1835 1
d1913 1
a1913 1
  if (t.bitfield.disp8)
d1969 19
d2578 2
d2672 1
d2760 1
d2775 2
d3026 5
a3030 1
    register_specifier = ~register_number (i.vex.register_specifier) & 0xf;
d3164 169
d3364 1
a3364 1
  gas_assert (i.imm_operands == 0
d3366 2
a3367 1
		  || (i.tm.opcode_modifier.vex
d3614 3
d4056 22
d4333 2
d4339 2
a4340 1
	  || i.index_reg->reg_type.bitfield.regymm))
d4354 3
a4356 1
		   && i.index_reg->reg_type.bitfield.regymm)))
d4362 93
a4454 5
      gas_assert (i.reg_operands == 2);
      gas_assert (i.types[0].bitfield.regxmm
		  || i.types[0].bitfield.regymm);
      gas_assert (i.types[2].bitfield.regxmm
		  || i.types[2].bitfield.regymm);
d4456 32
a4487 7
      if (operand_check == check_none)
	return 0;
      if (register_number (i.op[0].regs) != register_number (i.index_reg)
	  && register_number (i.op[2].regs) != register_number (i.index_reg)
	  && register_number (i.op[0].regs) != register_number (i.op[2].regs))
	return 0;
      if (operand_check == check_error)
d4489 1
a4489 1
	  i.error = invalid_vector_register_set;
a4491 1
      as_warn (_("mask, index, and destination registers should be distinct"));
d4494 43
d4546 7
d4669 2
a4670 1
	       && !operand_types[0].bitfield.regymm)
d4673 2
a4674 1
		  && !!operand_types[t->operands > 1].bitfield.regymm))
d4945 30
d5167 2
a5168 1
	       || i.suffix == YMMWORD_MNEM_SUFFIX)
d5170 1
a5170 1
	  /* Skip if the instruction has x/y suffix.  match_template
d5258 2
a5259 1
      && i.suffix != YMMWORD_MNEM_SUFFIX)
d5379 1
d5751 1
a5751 1
      /* The first operand is implicit and must be xmm0/ymm0.  */
d5754 2
a5755 1
		      || operand_type_equal (&i.types[0], &regymm)));
d5909 2
a5910 2
         VexW0 or VexW1.  The destination must be either XMM or YMM
         register.
d5922 2
a5923 1
                              || operand_type_equal (&i.tm.operand_types[dest], &regymm)))));
d5958 3
a5960 1
                                             &regymm));
d5963 2
a5964 1
        }
d6005 3
a6007 1
					     &regymm));
d6010 1
d6015 3
a6017 1
                                         &regymm));
d6070 2
a6071 1
			      || i.types[i.operands - 1].bitfield.imm8)));
d6083 17
d6109 6
d6117 4
a6120 5
	      /* For instructions with VexNDS, the register-only
		 source operand must be 32/64bit integer, XMM or
		 YMM register.  It is encoded in VEX prefix.  We
		 need to clear RegMem bit before calling
		 operand_type_equal.  */
d6142 3
a6144 1
		      && !operand_type_equal (&op, &regymm)))
d6165 2
d6169 2
d6178 2
d6182 2
d6219 2
d6239 2
d6295 2
d6326 1
d6350 4
a6353 1
			  i.types[op].bitfield.disp8 = 1;
d6373 2
d6396 4
a6399 1
		  i.types[op].bitfield.disp8 = 1;
d6527 2
d6595 3
a6597 1
		  && !operand_type_equal (type, &regymm))
d6613 2
d6621 2
d6901 3
a6903 3
      /* Since the VEX prefix contains the implicit prefix, we don't
	 need the explicit prefix.  */
      if (!i.tm.opcode_modifier.vex)
d6960 5
d6980 5
d7041 5
a7045 1
  if (i.types[n].bitfield.disp64)
d7077 2
a7078 1
      if (operand_type_check (i.types[n], disp))
d7083 1
a7083 1
	      offsetT val;
d7085 3
a7087 2
	      val = offset_in_range (i.op[n].disps->X_add_number,
				     size);
d7180 4
d7683 134
d7851 10
d8353 1
d8381 61
d8524 9
d8562 5
d8577 1
d8595 9
d9307 4
d9316 11
d9459 2
d9485 2
d9748 20
d9903 6
@


1.519
log
@Support Intel MPX

gas/

2013-07-24  Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* config/tc-i386.c (BND_PREFIX): New.
	(struct _i386_insn): Add new field bnd_prefix.
	(add_bnd_prefix): New.
	(cpu_arch): Add MPX.
	(i386_operand_type): Add regbnd.
	(md_assemble): Handle BND prefixes.
	(parse_insn): Likewise.
	(output_branch): Likewise.
	(output_jump): Likewise.
	(build_modrm_byte): Handle regbnd.
	(OPTION_MADD_BND_PREFIX): New.
	(md_longopts): Add entry for 'madd-bnd-prefix'.
	(md_parse_option): Handle madd-bnd-prefix option.
	(md_show_usage): Add description for madd-bnd-prefix
	option.
	* doc/c-i386.texi: Document mpx/.mpx and -madd-bnd-prefix.

gas/testsuite/

2013-07-24  Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* gas/i386/mpx-add-bnd-prefix.s: New.
	* gas/i386/mpx-add-bnd-prefix.d: New.
	* gas/i386/mpx-inval-1.l: New.
	* gas/i386/mpx-inval-1.s: New.
	* gas/i386/mpx.d: New.
	* gas/i386/mpx.s: New.
	* gas/i386/x86-64-mpx-add-bnd-prefix.d: New.
	* gas/i386/x86-64-mpx-add-bnd-prefix.s: New.
	* gas/i386/x86-64-mpx-addr32.d: New.
	* gas/i386/x86-64-mpx-addr32.s: New.
	* gas/i386/x86-64-mpx-inval-1.l: New.
	* gas/i386/x86-64-mpx-inval-1.s: New.
	* gas/i386/x86-64-mpx-inval-2.l: New.
	* gas/i386/x86-64-mpx-inval-2.s: New.
	* gas/i386/x86-64-mpx.d: New.
	* gas/i386/x86-64-mpx.s: New.
	* gas/i386/nops.d: Adjust to MPX changes.
	* gas/i386/nops.s: Likewise.
	* gas/i386/x86-64-nops.d: Likewise.
	* gas/i386/x86-64-nops.s: Likewise.
	* gas/i386/ilp32/x86-64-nops.d: Likewise.
	* gas/i386/i386.exp: Run new MPX tests.

include/opcode/

2013-07-24  Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* i386.h (BND_PREFIX_OPCODE): New.

opcodes/

2013-07-24  Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* i386-dis.c (BND_Fixup): New.
	(Ebnd): New.
	(Ev_bnd): New.
	(Gbnd): New.
	(BND): New.
	(v_bnd_mode): New.
	(bnd_mode): New.
	(MOD enum): Add new entries.
	(PREFIX enum): Likewise.
	(dis tables): Replace XX with BND for near branch and call
	instructions.
	(prefix_table): Add new entries.
	(mod_table): Likewise.
	(names_bnd): New.
	(intel_names_bnd): New.
	(att_names_bnd): New.
	(BND_PREFIX): New.
	(prefix_name): Handle BND_PREFIX.
	(print_insn): Initialize names_bnd.
	(intel_operand_size): Handle new modes.
	(OP_E_register): Likewise.
	(OP_E_memory): Likewise.
	(OP_G): Likewise.
	* i386-gen.c (cpu_flag_init): Add CpuMPX.
	(cpu_flags): Add CpuMPX.
	(operand_type_init): Add RegBND.
	(opcode_modifiers): Add BNDPrefixOk.
	(operand_types): Add RegBND.
	* i386-init.h: Regenerate.
	* i386-opc.h (CpuMPX): New.
	(CpuUnused): Comment out.
	(i386_cpu_flags): Add cpumpx.
	(BNDPrefixOk): New.
	(i386_opcode_modifier): Add bndprefixok.
	(RegBND): New.
	(i386_operand_type): Add regbnd.
	* i386-opc.tbl: Add BNDPrefixOk to near jumps, calls and rets.
	Add MPX instructions and bnd prefix.
	* i386-reg.tbl: Add bnd0-bnd3 registers.
	* i386-tbl.h: Regenerate.
@
text
@d793 2
@


1.518
log
@Don't align text/data/bss sections for ELF

binutils/testsuite/

	* binutils-all/i386/compressed-1b.d: Updated for text/data/bss
	section alignment change.
	* binutils-all/i386/compressed-1c.d: Likewise.
	* binutils-all/x86-64/compressed-1b.d: Likewise.
	* binutils-all/x86-64/compressed-1c.d: Likewise.

gas/

	* config/tc-i386.c (md_begin): Don't align text/data/bss sections
	for ELF.

gas/testsuite/

	* gas/i386/size-3.d: Updated for text/data/bss section alignment
	change.
	* gas/i386/x86-64-size-1.d: Likewise.
	* gas/i386/x86-64-unwind.d: Likewise.
	* gas/i386/ilp32/x86-64-size-1.d: Likewise.
	* gas/i386/ilp32/x86-64-size-5.d: Likewise.
	* gas/i386/ilp32/x86-64-unwind.d: Likewise.

ld/testsuite/

	* ld-i386/pr12718.d: Updated for text/data/bss section alignment
	change.
	* ld-i386/tlsbindesc.dd: Likewise.
	* ld-i386/tlsbindesc.rd: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlspic.dd: Likewise.
	* ld-x86-64/ilp32-4.d: Likewise.
	* ld-x86-64/pr12718.d: Likewise.
	* ld-x86-64/split-by-file.rd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlsbindesc.rd: Likewise.
	* ld-x86-64/tlsdesc.dd: Likewise.
	* ld-x86-64/tlsdesc.rd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
@
text
@d70 1
d300 3
d449 5
d791 2
d1554 1
d3229 15
d3446 2
d5924 1
d6064 7
d6165 7
d8583 1
d8607 1
d8865 4
d9013 2
@


1.517
log
@Rewrote i386_index_check

	* config/tc-i386.c (flag_code_names): Removed.
	(i386_index_check): Rewrote.
@
text
@a2456 9
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (IS_ELF)
    {
      record_alignment (text_section, 2);
      record_alignment (data_section, 2);
      record_alignment (bss_section, 2);
    }
#endif

@


1.516
log
@Replace have_hle with hle_prefix

	* config/tc-i386.c (_i386_insn): Replace have_hle with hle_prefix.
	(check_hle): Updated.
	(md_assemble): Likewise.
	(parse_insn): Likewise.
@
text
@a427 8
/* The names used to print error messages.  */
static const char *flag_code_names[] =
  {
    "32",
    "16",
    "64"
  };

a7414 1
  int ok;
d7416 8
d7425 7
a7431 1
  int fudged = 0;
d7433 28
a7460 1
 tryprefix:
d7462 2
a7463 1
  ok = 1;
d7471 8
a7478 1
      unsigned int expected;
d7491 3
a7493 1
	  expected = type.bitfield.esseg ? 7 /* rDI */ : 6 /* rSI */;
d7496 1
a7496 1
	expected = 3 /* rBX */;
d7498 2
a7499 1
      if (!i.base_reg || i.index_reg
d7501 12
a7512 27
	ok = -1;
      else if (!(flag_code == CODE_64BIT
		 ? i.prefix[ADDR_PREFIX]
		   ? i.base_reg->reg_type.bitfield.reg32
		   : i.base_reg->reg_type.bitfield.reg64
		 : (flag_code == CODE_16BIT) ^ !i.prefix[ADDR_PREFIX]
		   ? i.base_reg->reg_type.bitfield.reg32
		   : i.base_reg->reg_type.bitfield.reg16))
	ok = 0;
      else if (register_number (i.base_reg) != expected)
	ok = -1;

      if (ok < 0)
	{
	  unsigned int j;

	  for (j = 0; j < i386_regtab_size; ++j)
	    if ((flag_code == CODE_64BIT
		 ? i.prefix[ADDR_PREFIX]
		   ? i386_regtab[j].reg_type.bitfield.reg32
		   : i386_regtab[j].reg_type.bitfield.reg64
		 : (flag_code == CODE_16BIT) ^ !i.prefix[ADDR_PREFIX]
		   ? i386_regtab[j].reg_type.bitfield.reg32
		   : i386_regtab[j].reg_type.bitfield.reg16)
		&& register_number(i386_regtab + j) == expected)
	      break;
	  gas_assert (j < i386_regtab_size);
d7517 1
a7517 1
		   i386_regtab[j].reg_name,
d7519 1
a7519 1
	  ok = 1;
d7521 7
a7527 23
    }
  else if (flag_code == CODE_64BIT)
    {
      if ((i.base_reg
	   && ((i.prefix[ADDR_PREFIX] == 0
		&& !i.base_reg->reg_type.bitfield.reg64)
	       || (i.prefix[ADDR_PREFIX]
		   && !i.base_reg->reg_type.bitfield.reg32))
	   && (i.index_reg
	       || i.base_reg->reg_num !=
		  (i.prefix[ADDR_PREFIX] == 0 ? RegRip : RegEip)))
	  || (i.index_reg
	      && !(i.index_reg->reg_type.bitfield.regxmm
		   || i.index_reg->reg_type.bitfield.regymm)
	      && (!i.index_reg->reg_type.bitfield.baseindex
		  || (i.prefix[ADDR_PREFIX] == 0
		      && i.index_reg->reg_num != RegRiz
		      && !i.index_reg->reg_type.bitfield.reg64
		      )
		  || (i.prefix[ADDR_PREFIX]
		      && i.index_reg->reg_num != RegEiz
		      && !i.index_reg->reg_type.bitfield.reg32))))
	ok = 0;
d7531 22
a7552 1
      if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
d7554 1
a7554 1
	  /* 16bit checks.  */
d7565 1
a7565 14
	    ok = 0;
	}
      else
	{
	  /* 32bit checks.  */
	  if ((i.base_reg
	       && !i.base_reg->reg_type.bitfield.reg32)
	      || (i.index_reg
		  && !i.index_reg->reg_type.bitfield.regxmm
		  && !i.index_reg->reg_type.bitfield.regymm
		  && ((!i.index_reg->reg_type.bitfield.reg32
		       && i.index_reg->reg_num != RegEiz)
		      || !i.index_reg->reg_type.bitfield.baseindex)))
	    ok = 0;
d7568 1
a7568 36
  if (!ok)
    {
#if INFER_ADDR_PREFIX
      if (!i.mem_operands && !i.prefix[ADDR_PREFIX])
	{
	  i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
	  i.prefixes += 1;
	  /* Change the size of any displacement too.  At most one of
	     Disp16 or Disp32 is set.
	     FIXME.  There doesn't seem to be any real need for separate
	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32.
	     Removing them would probably clean up the code quite a lot.  */
	  if (flag_code != CODE_64BIT
	      && (i.types[this_operand].bitfield.disp16
		  || i.types[this_operand].bitfield.disp32))
	    i.types[this_operand]
	      = operand_type_xor (i.types[this_operand], disp16_32);
	  fudged = 1;
	  goto tryprefix;
	}
      if (fudged)
	as_bad (_("`%s' is not a valid %s expression"),
		operand_string,
		kind);
      else
#endif
	as_bad (_("`%s' is not a valid %s-bit %s expression"),
		operand_string,
		flag_code_names[i.prefix[ADDR_PREFIX]
					 ? flag_code == CODE_32BIT
					   ? CODE_16BIT
					   : CODE_32BIT
					 : flag_code],
		kind);
    }
  return ok;
@


1.515
log
@Optimize REP prefix check

gas/

	* config/tc-i386.c (_i386_insn): Add rep_prefix.
	(md_assemble): Check if REP prefix is OK.
	(parse_insn): Remove expecting_string_instruction.  Set
	i.rep_prefix.

gas/testsuite/

	* gas/i386/i386.exp: Run inval-rep and x86-64-inval-rep.

	* gas/i386/inval-rep.l: New file.
	* gas/i386/inval-rep.s: Likewise.
	* gas/i386/x86-64-inval-rep.l: Likewise.
	* gas/i386/x86-64-inval-rep.s: Likewise.
@
text
@d296 2
a297 2
    /* Have HLE prefix.  */
    unsigned int have_hle;
d3076 2
a3077 6
      if (i.prefix[HLE_PREFIX] == XACQUIRE_PREFIX_OPCODE)
	as_bad (_("invalid instruction `%s' after `xacquire'"),
		i.tm.name);
      else
	as_bad (_("invalid instruction `%s' after `xrelease'"),
		i.tm.name);
d3082 1
a3082 4
      if (i.prefix[HLE_PREFIX] == XACQUIRE_PREFIX_OPCODE)
	as_bad (_("missing `lock' with `xacquire'"));
      else
	as_bad (_("missing `lock' with `xrelease'"));
d3231 1
a3231 1
  if (i.have_hle && !check_hle ())
d3435 1
a3435 1
		i.have_hle = 1;
@


1.514
log
@Implement Intel SMAP instructions

gas/

	PR gas/15159
	* config/tc-i386.c (cpu_arch): Add ".smap".

	* doc/c-i386.texi: Document smap.

gas/testsuite/

	PR gas/15159
	* gas/i386/i386.exp: Run smap and x86-64-smap.

	* gas/i386/smap.d: New file.
	* gas/i386/smap.s: likewise.
	* gas/i386/x86-64-smap.d: likewise.

opcodes/

	PR gas/15159
	* i386-dis.c (rm_table): Add clac and stac to RM_0F01_REG_1.

	* i386-gen.c (cpu_flag_init): Add CPU_SMAP_FLAGS.
	(cpu_flags): Add CpuSMAP.

	* i386-opc.h (CpuSMAP): New.
	(i386_cpu_flags): Add cpusmap.

	* i386-opc.tbl: Add clac and stac.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d293 3
d3217 8
a3372 3
  /* Non-zero if we found a prefix only acceptable with string insns.  */
  const char *expecting_string_instruction = NULL;

d3444 1
a3444 1
		expecting_string_instruction = current_templates->start->name;
a3592 21
  /* Check for rep/repne without a string (or other allowed) instruction.  */
  if (expecting_string_instruction)
    {
      static templates override;

      for (t = current_templates->start; t < current_templates->end; ++t)
	if (t->opcode_modifier.repprefixok)
	  break;
      if (t >= current_templates->end)
	{
	  as_bad (_("expecting string instruction after `%s'"),
		  expecting_string_instruction);
	  return NULL;
	}
      for (override.start = t; t < current_templates->end; ++t)
	if (!t->opcode_modifier.repprefixok)
	  break;
      override.end = t;
      current_templates = &override;
    }

@


1.513
log
@Support size relocation only for ELF

	* config/tc-i386.c (reloc): Support size relocation only for ELF.
	(tc_i386_fix_adjustable): Likewise.
	(lex_got): Likewise.
	(tc_gen_reloc): Likewise.
@
text
@d785 2
@


1.512
log
@Add x86 size relocation support to gas

gas/

	* config/tc-i386.c (reloc): Support BFD_RELOC_SIZE32.
	(tc_i386_fix_adjustable): Keep symbol for BFD_RELOC_32_SIZE and
	BFD_RELOC_64_SIZE relocations.
	(lex_got): Support "symbol@@SIZE" and don't create GOT symbol
	for it.
	(tc_gen_reloc): Resolve BFD_RELOC_SIZE32 and BFD_RELOC_SIZE64
	relocations against local symbols.

gas/testsuite/

	* gas/i386/i386.exp: Run size-1, size-2, size-3, size-4,
	x86-64-size-1, x86-64-size-2, x86-64-size-3, x86-64-size-4,
	x86-64-size-5 and x86-64-size-inval-1.

	* gas/i386/size-1.d: New file.
	* gas/i386/size-1.s: Likewise.
	* gas/i386/size-2.d: Likewise.
	* gas/i386/size-2.s: Likewise.
	* gas/i386/size-3.d: Likewise.
	* gas/i386/size-3.s: Likewise.
	* gas/i386/size-4.d: Likewise.
	* gas/i386/size-4.s: Likewise.
	* gas/i386/x86-64-size-1.d: Likewise.
	* gas/i386/x86-64-size-2.d: Likewise.
	* gas/i386/x86-64-size-3.d: Likewise.
	* gas/i386/x86-64-size-4.d: Likewise.
	* gas/i386/x86-64-size-5.d: Likewise.
	* gas/i386/x86-64-size-5.s: Likewise.
	* gas/i386/x86-64-size-inval-1.l: Likewise.
	* gas/i386/x86-64-size-inval-1.s: Likewise.
	* gas/i386/ilp32/x86-64-size-1.d: Likewise.
	* gas/i386/ilp32/x86-64-size-2.d: Likewise.
	* gas/i386/ilp32/x86-64-size-3.d: Likewise.
	* gas/i386/ilp32/x86-64-size-4.d: Likewise.
	* gas/i386/ilp32/x86-64-size-5.d: Likewise.

ld/testsuite/

	* ld-size/size.exp: New file.
	* ld-size/size32-1-i386.d: Likewise.
	* ld-size/size32-1-x32.d: Likewise.
	* ld-size/size32-1-x86-64.d: Likewise.
	* ld-size/size32-1.s: Likewise.
	* ld-size/size32-2-i386.d: Likewise.
	* ld-size/size32-2-x32.d: Likewise.
	* ld-size/size32-2-x86-64.d: Likewise.
	* ld-size/size32-2.s: Likewise.
	* ld-size/size64-1-x32.d: Likewise.
	* ld-size/size64-1-x86-64.d: Likewise.
	* ld-size/size64-1.s: Likewise.
	* ld-size/size64-2-x32.d: Likewise.
	* ld-size/size64-2-x86-64.d: Likewise.
	* ld-size/size64-2.s: Likewise.
	* ld-size/size-3.c: Likewise.
	* ld-size/size-3.out: Likewise.
	* ld-size/size-3a.c: Likewise.
	* ld-size/size-3b.c: Likewise.
	* ld-size/size-3c.c: Likewise.
	* ld-size/size-4.out: Likewise.
	* ld-size/size-4a.c: Likewise.
	* ld-size/size-4b.c: Likewise.
	* ld-size/size-5.out: Likewise.
	* ld-size/size-5a.c: Likewise.
	* ld-size/size-5b.c: Likewise.
	* ld-size/size-6.out: Likewise.
	* ld-size/size-6a.c: Likewise.
	* ld-size/size-6b.c: Likewise.
	* ld-size/size-7.rd: Likewise.
	* ld-size/size-7a.c: Likewise.
	* ld-size/size-7b.c: Likewise.
	* ld-size/size-8.rd: Likewise.
	* ld-size/size-8a.c: Likewise.
	* ld-size/size-8b.c: Likewise.
@
text
@d2689 1
d2697 1
d6724 1
d6728 1
d9252 1
d9270 1
@


1.511
log
@Increment length by 1 if the relocation token is removed

gas/

	PR gas/15019
	* config/tc-i386.c (lex_got): Increment length by 1 if the
	relocation token is removed.

gas/testsuite/

	PR gas/15019
	* gas/i386/reloc32.s: Add tests for "xtrn@@got -/+ 4".
	* gas/i386/reloc64.s: Likewise.
	* gas/i386/ilp32/reloc64.s: Likewise.

	* gas/i386/reloc32.d: Updated.
	* gas/i386/reloc64.d: Likewise.
	* gas/i386/ilp32/reloc64.d: Likewise.
@
text
@d2689 8
d2780 5
a2784 2
  /* adjust_reloc_syms doesn't know about the GOT.  */
  if (fixP->fx_r_type == BFD_RELOC_386_GOTOFF
d6722 3
d6812 1
a6812 1
	      if (GOT_symbol == NULL)
d9248 18
@


1.510
log
@Remove trailing white spaces on gas

	* app.c: Remove trailing white spaces.
	* as.c: Likewise.
	* as.h: Likewise.
	* cond.c: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* input-file.c: Likewise.
	* itbl-lex.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* subsegs.c: Likewise.
	* symbols.c: Likewise.
	* write.c: Likewise.
	* config/tc-i386.c: Likewise.
	* doc/Makefile.am: Likewise.
	* doc/Makefile.in: Likewise.
	* doc/c-aarch64.texi: Likewise.
	* doc/c-alpha.texi: Likewise.
	* doc/c-arc.texi: Likewise.
	* doc/c-arm.texi: Likewise.
	* doc/c-avr.texi: Likewise.
	* doc/c-bfin.texi: Likewise.
	* doc/c-cr16.texi: Likewise.
	* doc/c-d10v.texi: Likewise.
	* doc/c-d30v.texi: Likewise.
	* doc/c-h8300.texi: Likewise.
	* doc/c-hppa.texi: Likewise.
	* doc/c-i370.texi: Likewise.
	* doc/c-i386.texi: Likewise.
	* doc/c-i860.texi: Likewise.
	* doc/c-m32c.texi: Likewise.
	* doc/c-m32r.texi: Likewise.
	* doc/c-m68hc11.texi: Likewise.
	* doc/c-m68k.texi: Likewise.
	* doc/c-microblaze.texi: Likewise.
	* doc/c-mips.texi: Likewise.
	* doc/c-msp430.texi: Likewise.
	* doc/c-mt.texi: Likewise.
	* doc/c-s390.texi: Likewise.
	* doc/c-score.texi: Likewise.
	* doc/c-sh.texi: Likewise.
	* doc/c-sh64.texi: Likewise.
	* doc/c-tic54x.texi: Likewise.
	* doc/c-tic6x.texi: Likewise.
	* doc/c-v850.texi: Likewise.
	* doc/c-xc16x.texi: Likewise.
	* doc/c-xgate.texi: Likewise.
	* doc/c-xtensa.texi: Likewise.
	* doc/c-z80.texi: Likewise.
	* doc/internals.texi: Likewise.
@
text
@a6785 2
	      if (adjust)
		*adjust = len;
d6820 6
@


1.509
log
@2013-01-09  Steve Ellcey  <sellcey@@mips.com>

	* config/tc-i386.c (md_begin): Remove 'internal Error' from as_fatal
	calls.
	* config/tc-mips.c (internalError): Remove, replace with abort.
@
text
@d6849 2
a6850 2
   input line.  Otherwise return NULL.  
   
@


1.508
log
@Add AMD bdver3 support.

gas/

	* config/tc-i386.c (cpu_arch): Add CPU_BDVER3_FLAGS.
	* doc/c-i386.texi: Add -march=bdver3 option.

gas/testsuite/

	* gas/i386/i386.exp: Run bdver3 test cases.
	* gas/i386/nops-1-bdver3.d: New.
	* gas/i386/arch-10-bdver3.d: New.
	* gas/i386/x86-64-nops-1-bdver3.d: New.
	* gas/i386/x86-64-arch-2-bdver3.d: New.

opcodes/

	* i386-gen.c (cpu_flag_init): Add CPU_BDVER3_FLAGS.
	* i386-init.h: Regenerated.
@
text
@d2378 1
a2378 1
		as_fatal (_("internal Error:  Can't hash %s: %s"),
d2400 1
a2400 1
	  as_fatal (_("internal Error:  Can't hash %s: %s"),
@


1.507
log
@Replace CpuSSE3 with CpuCX16 for cmpxchg16b

gas/

	* config/tc-i386.c (cpu_arch): Add .cx16.
	* doc/c-i386.texi: Document .cx16.

gas/testsuite/

	* gas/i386/x86-64-arch-2.s: Add test for cmpxchg16b.
	* gas/i386/x86-64-arch-2.d: Update correspondingly.
	* gas/i386/x86-64-arch-2-bdver2.d: Likewise.
	* gas/i386/x86-64-arch-2-btver1.d: Likewise.
	* gas/i386/x86-64-arch-2-btver2.d: Likewise.
	* gas/i386/x86-64-arch-2-lzcnt.d: Likewise.
	* gas/i386/x86-64-arch-2-prefetchw.d: Likewise.
	* gas/i386/ilp32/x86-64-arch-2.d: Likewise.

opcodes/

	* i386-gen.c (cpu_flag_init): Add CpuCX16 to CPU_NOCONA_FLAGS,
	CPU_CORE_FLAGS, CPU_CORE2_FLAGS, CPU_COREI7_FLAGS,
	CPU_BDVER1_FLAGS, CPU_BDVER2_FLAGS, CPU_BTVER1_FLAGS,
	CPU_BTVER2_FLAGS.  Add CPU_CX16_FLAGS.
	(cpu_flags): Add CpuCX16.
	* i386-opc.h (CpuCX16): New.
	(i386_cpu_flags): Add cpucx16.
	* i386-opc.tbl: Replace CpuSSE3 with CpuCX16 for cmpxchg16b.
	* i386-tbl.h: Regenerate.
	* i386-init.h: Likewise.
@
text
@d667 2
@


1.506
log
@Add AMD btver1 and btver2 support

gas/

2012-08-17  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* config/tc-i386.c (cpu_arch): Add CPU_BTVER1_FLAGS and
	CPU_BTVER2_FLAGS.
	(i386_align_code): Add case for PROCESSOR_BT.

	* config/tc-i386.h (enum processor_type): Add PROCESSOR_BT.

	* doc/c-i386.texi: Add -march={btver1, btver2} options.

gas/testsuite/

2012-08-17  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* gas/i386/i386.exp: Run btver1 and btver2 test cases.

	* gas/i386/nops-1-btver1.d: New.
	* gas/i386/nops-1-btver2.d: New.
	* gas/i386/arch-10-btver1.d: New.
	* gas/i386/arch-10-btver2.d: New.
	* gas/i386/x86-64-nops-1-btver1.d: New.
	* gas/i386/x86-64-nops-1-btver2.d: New.
	* gas/i386/x86-64-arch-2-btver1.d: New.
	* gas/i386/x86-64-arch-2-btver2.d: New.

opcodes/

2012-08-17  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* i386-gen.c (cpu_flag_init): Add CPU_BTVER1_FLAGS and
	CPU_BTVER2_FLAGS.

	* i386-opc.h: Update CpuPRFCHW comment.

	* i386-opc.tbl: Enable prefetch instruction for CpuPRFCHW.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d739 2
@


1.505
log
@Terminate register name when reporting bad register

gas/

	PR gas/14457
	* config/tc-i386.c (i386_att_operand): Terminate register name
	when reporting bad register.

gas/testsuite/

	PR gas/14457
	* gas/i386/i386.exp: Run reg-bad.

	* gas/i386/reg-bad.l: New.
	* gas/i386/reg-bad.s: Likewise.
@
text
@d667 4
d1067 1
a1067 1
     PROCESSOR_AMDFAM10, and PROCESSOR_BD, alt_short_patt
d1122 1
d1152 1
@


1.504
log
@Despite them being ignored by the CPU, gas issues segment override
prefixes for other than FS/GS in 64-bit mode. If doing so at all, it
should clearly do this correctly. Determining the default segment,
however, requires to take into consideration RegRex (so far, RSP, RBP,
R12, and R13 were all treated equally here).

gas/
2012-08-07  Jan Beulich <jbeulich@@suse.com>

	* config/tc-i386-intel.c (build_modrm_byte): Split determining
	default segment from figuring out encoding. Honor RegRex for
	the former.

gas/testsuite/
2012-08-07  Jan Beulich <jbeulich@@suse.com>

	* gas/i386/x86-64-segovr.{s,l}: New.
	* gas/i386/i386.exp: Run new test.
@
text
@d7785 3
d7829 3
@


1.503
log
@The VGATHER group of instructions requires that all three involved
xmm/ymm registers are distinct. This patch adds code to check for this,
and at once eliminates a superfluous check for not using PC-relative
addressing for these instructions (the fact that an index register is
required here already excludes valid PC-relative addresses). The
severity of the resulting diagnostics can be controlled via command
line option or directive.

gas/
2012-08-07  Jan Beulich <jbeulich@@suse.com>

	* config/tc-i386.c (set_check): Renamed from set_sse_check.
	Generalize to also handle operand checking option.
	(enum i386_error): New enumerator 'invalid_vector_register_set'.
	(match_template): Handle it.
	(enum check_kind): Give it a tag. Drop sse_ prefixes from
	enumerators.
	(operand_check): New.
	(md_pseudo_table): Add "operand_check".
	(check_VecOperands): Don't special case RIP addressing. Check
	that vSIB operands use distinct vector registers unless no
	checking was requested.
	(OPTION_MOPERAND_CHECK): New.
	(md_parse_option): Handle it.
	(OPTION_MAVXSCALAR, OPTION_X32): Adjust.
	(md_longopts): Add "moperand-check".
	(md_show_usage): Add help text for it.

gas/testsuite/
2012-08-07  Jan Beulich <jbeulich@@suse.com>

	* gas/i386/vgather-check-error.{s,l}: New.
	* gas/i386/vgather-check-none.{s,d}: New.
	* gas/i386/vgather-check-warn.{d,e}: New.
	* gas/i386/vgather-check.{s,d}: New.
	* gas/i386/x86-64-vgather-check-error.{s,l}: New.
	* gas/i386/x86-64-vgather-check-none.{s,d}: New.
	* gas/i386/x86-64-vgather-check-warn.{d,e}: New.
	* gas/i386/x86-64-vgather-check.{s,d}: New.
	* gas/i386/i386.exp: Run new tests.
@
text
@d5773 3
a5775 2
	      if ((i.base_reg->reg_num & 7) == EBP_REG_NUM)
		{
d5777 1
a5777 7
		  if (i.disp_operands == 0)
		    {
		      fake_zero_displacement = 1;
		      i.types[op].bitfield.disp8 = 1;
		    }
		}
	      else if (i.base_reg->reg_num == ESP_REG_NUM)
d5779 2
a5780 1
		  default_seg = &ss;
@


1.502
log
@There were several cases where the registers in the REX encoded range
got treated identically to the ones in the base range, due to not
paying attention to the fact that reg_entry's reg_num field doesn't
fully specify the register number (reg_flags also needs to be checked
for RegRex). This patch introduces and uses a new (inline) function to
obtain the full register number, and uses it to fix all those cases.

It additionally adds the missing operand checks for SVME instructions
(which match the monitor/mwait ones).

gas/
2012-08-07  Jan Beulich <jbeulich@@suse.com>

	* config/tc-i386.c (register_number): New function.
	(build_vex_prefix, process_immext, process_operands,
	build_modrm_byte, i386_index_check): Use it.

gas/testsuite/
2012-08-07  Jan Beulich <jbeulich@@suse.com>

	* gas/i386/x86-64-specific-reg.{s,l}: New.
	* gas/i386/i386.exp: Run new test.

opcodes/
2012-08-07  Jan Beulich <jbeulich@@suse.com>

	* i386-opc.tbl: Remove "FIXME" comments from SVME instructions.
@
text
@d147 1
a147 1
static void set_sse_check (int);
d224 1
d453 1
a453 1
static enum
d455 3
a457 3
    sse_check_none = 0,
    sse_check_warning,
    sse_check_error
d459 1
a459 1
sse_check;
d851 2
a852 1
  {"sse_check", set_sse_check, 0},
d2116 1
a2116 1
set_sse_check (int dummy ATTRIBUTE_UNUSED)
d2118 14
d2140 1
a2140 1
	sse_check = sse_check_none;
d2142 1
a2142 1
	sse_check = sse_check_warning;
d2144 1
a2144 1
	sse_check = sse_check_error;
d2146 1
a2146 1
	as_bad (_("bad argument to sse_check directive."));
d2150 1
a2150 1
    as_bad (_("missing argument for sse_check directive"));
d3155 1
a3155 1
  if (sse_check != sse_check_none
d3164 1
a3164 1
      (sse_check == sse_check_warning
d3984 5
a3988 4
  /* For VSIB byte, we need a vector register for index and no PC
     relative addressing is allowed.  */
  if (t->opcode_modifier.vecsib
      && (!i.index_reg
d3992 24
a4015 5
		   && i.index_reg->reg_type.bitfield.regymm))
	  || (i.base_reg && i.base_reg->reg_num == RegRip)))
    {
      i.error = invalid_vsib_address;
      return 1;
d4411 3
d8544 3
a8546 2
#define OPTION_MAVXSCALAR (OPTION_MD_BASE + 12)
#define OPTION_X32 (OPTION_MD_BASE + 13)
d8568 1
d8798 1
a8798 1
	sse_check = sse_check_error;
d8800 1
a8800 1
	sse_check = sse_check_warning;
d8802 1
a8802 1
	sse_check = sse_check_none;
d8807 11
d8956 3
@


1.501
log
@	* config/tc-i386.c (lex_got): Provide implementation for PE
	format.

	* gas/i386/secrel.s: Add test of <symbol>@@SECREL32.
	* gas/i386/secrel.d: Add expected disassembly.

	* scripttempl/pe.sc (R_TLS): Add .tls$AAA and .tls$ZZZ.
	* scripttempl/pep.sc (R_TLS): Add .tls$AAA and .tls$ZZZ.

	* archive.c (_bfd_delete_archive_data): New function.
	* libbfd-in.h (_bfd_delete_archive_data): Declare.
	* libbfd.h: Rebuild.
	* opncls.c (_bfd_delete_bfd): Call _bfd_delete_archive_data.
@
text
@d1761 11
d2844 1
a2844 6
    {
      register_specifier = i.vex.register_specifier->reg_num;
      if ((i.vex.register_specifier->reg_flags & RegRex))
	register_specifier += 8;
      register_specifier = ~register_specifier & 0xf;
    }
d2983 2
a2984 1
  if (i.tm.cpu_flags.bitfield.cpusse3 && i.operands > 0)
d2986 4
a2989 4
      /* SSE3 Instructions have the fixed operands with an opcode
	 suffix which is coded in the same place as an 8-bit immediate
	 field would be.  Here we check those operands and remove them
	 afterwards.  */
d2993 1
a2993 1
	if (i.op[x].regs->reg_num != x)
d5081 1
a5081 1
	  if (i.op[0].regs->reg_num != 0)
d5155 1
a5155 1
      if (i.op[0].regs->reg_num != 0)
d5358 1
a5358 4
          exp->X_add_number
              = ((i.op[reg_slot].regs->reg_num
                  + ((i.op[reg_slot].regs->reg_flags & RegRex) ? 8 : 0))
		 << 4);
d5402 1
a5402 3
              |= ((i.op[reg_slot].regs->reg_num
                   + ((i.op[reg_slot].regs->reg_flags & RegRex) ? 8 : 0))
		  << 4);
d7418 1
a7418 1
      else if (i.base_reg->reg_num != expected)
d7433 1
a7433 1
		&& i386_regtab[j].reg_num == expected)
@


1.500
log
@The current error message for bad imm4 operands wasn't really helpful,
and was pointing at the wrong operand in Intel mode. Since non-constant
operands are being taken care of by other means anyway, adjust it to
simply state that the constant doesn't fit.

2012-07-31  Jan Beulich <jbeulich@@suse.com>

	* config/tc-i386.c (match_template): Adjust error message
	for 'bad_imm4' case.
@
text
@d6791 103
@


1.499
log
@Since the word to byte register conversion isn't active for x86-64
anyway, there's also no need to issue a separate, inconsistent
diagnostic in some of the cases - non-matching operands will be
complained about anyway.

2012-07-31  Jan Beulich <jbeulich@@suse.com>

	* config/tc-i386.c (check_byte_reg): Check for I/O port
	register earlier, and just once. Drop diagnostic that got
	issued only for some registers.
@
text
@d4350 1
a4350 1
	  err_msg = _("Imm4 isn't the first operand");
@


1.498
log
@At the point where check_VecOperands()/VEX_check_operands() get run,
all other instruction attributes already matched, so any mismatch here
will tell the user more precisely what is wrong than using an eventual
(and very likely to occur) more generic error encountered on a
subsequent iteration through the template matching loop.

2012-07-31  Jan Beulich <jbeulich@@suse.com>

	* config/tc-i386.c (match_template): New local variable
	'specific_error'. Set it from i.error after failed
	check_VecOperands or VEX_check_operands. Use it if set in
	preference to i.error when actually issuing disagnostic.
@
text
@d4737 4
d4748 4
a4751 1
	  && i.op[op].regs->reg_num < 4)
a4752 10
	  /* Prohibit these changes in the 64bit mode, since the
	     lowering is more complicated.  */
	  if (flag_code == CODE_64BIT
	      && !i.tm.operand_types[op].bitfield.inoutportreg)
	    {
	      as_bad (_("incorrect register `%s%s' used with `%c' suffix"),
		      register_prefix, i.op[op].regs->reg_name,
		      i.suffix);
	      return 0;
	    }
d4754 1
a4754 2
	  if (!quiet_warnings
	      && !i.tm.operand_types[op].bitfield.inoutportreg)
@


1.497
log
@Implement RDRSEED, ADX and PRFCHW instructions

gas/

	* config/tc-i386.c: Add ADX, RDSEED and PRFCHW asm directives.
	* doc/c-i386.texi: Document the new directives.

gas/testsuite/

	* gas/i386/i386.exp: Run adx, rdseed and prefetchw tests.
	* gas/i386/x86-64-arch-2.s: Use prefetchw as 3dnow and Prfchw tests.
	* gas/i386/arch-10.s: Likewise.
	* gas/i386/arch-10-1.l: Changed correspondingly.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/arch-10.d: Likewise.
	* gas/i386/arch-10-lzcnt.d: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.
	* gas/i386/x86-64-arch-2-lzcnt.d: Likewise.
	* gas/i386/ilp32/x86-64-arch-2.d: Likewise.
	* gas/i386/arch-10-prefetchw.d: New file.
	* gas/i386/x86-64-arch-2-prefetchw.d: Likewise.
	* gas/i386/rdseed.s: Likewise.
	* gas/i386/rdseed.d: Likewise.
	* gas/i386/rdseed-intel.d: Likewise.
	* gas/i386/adx.s: Likewise.
	* gas/i386/adx.d: Likewise.
	* gas/i386/adx-intel.d: Likewise.
	* gas/i386/x86-64-rdseed.s: Likewise.
	* gas/i386/x86-64-rdseed.d: Likewise.
	* gas/i386/x86-64-rdseed-intel.d: Likewise.
	* gas/i386/x86-64-adx.s: Likewise.
	* gas/i386/x86-64-adx.d: Likewise.
	* gas/i386/x86-64-adx-intel.d: Likewise.

opcodes/

	* i386-dis.c (PREFIX_0F38F6): New.
	(prefix_table): Add adcx, adox instructions.
	(three_byte_table): Use PREFIX_0F38F6.
	(mod_table): Add rdseed instruction.
	* i386-gen.c (cpu_flag_init): Add CpuADX, CpuRDSEED, CpuPRFCHW.
	(cpu_flags): Likewise.
	* i386-opc.h: Add CpuADX, CpuRDSEED, CpuPRFCHW.
	(i386_cpu_flags): Add fields cpurdseed, cpuadx, cpuprfchw.
	* i386-opc.tbl: Add instrcutions adcx, adox, rdseed. Extend
	prefetchw.
	* i386-tbl.h: Regenerate.
	* i386-init.h: Likewise.
@
text
@d4018 1
d4315 6
a4320 7
      /* Check if vector operands are valid.  */
      if (check_VecOperands (t))
	continue;

      /* Check if VEX operands are valid.  */
      if (VEX_check_operands (t))
	continue;
d4330 1
a4330 1
      switch (i.error)
@


1.497.2.1
log
@gas/
2012-08-17  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* config/tc-i386.c (cpu_arch): Add CPU_BTVER1_FLAGS and
	CPU_BTVER2_FLAGS.
	(i386_align_code): Add case for PROCESSOR_BT.

	* config/tc-i386.h (enum processor_type): Add PROCESSOR_BT.

	* doc/c-i386.texi: Add -march={btver1, btver2} options.

gas/testsuite/
2012-08-17  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* gas/i386/i386.exp: Run btver1 and btver2 test cases.

	* gas/i386/nops-1-btver1.d: New.
	* gas/i386/nops-1-btver2.d: New.
	* gas/i386/arch-10-btver1.d: New.
	* gas/i386/arch-10-btver2.d: New.
	* gas/i386/x86-64-nops-1-btver1.d: New.
	* gas/i386/x86-64-nops-1-btver2.d: New.
	* gas/i386/x86-64-arch-2-btver1.d: New.
	* gas/i386/x86-64-arch-2-btver2.d: New.

opcodes/
2012-08-17  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* i386-gen.c (cpu_flag_init): Add CPU_BTVER1_FLAGS and
	CPU_BTVER2_FLAGS.

	* i386-opc.h: Update CpuPRFCHW comment.

	* i386-opc.tbl: Enable prefetch instruction for CpuPRFCHW.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@a665 4
  { STRING_COMMA_LEN ("btver1"), PROCESSOR_BT,
    CPU_BTVER1_FLAGS, 0, 0 },
  { STRING_COMMA_LEN ("btver2"), PROCESSOR_BT,
    CPU_BTVER2_FLAGS, 0, 0 },
d1061 1
a1061 1
     PROCESSOR_AMDFAM10, PROCESSOR_BD and PROCESSOR_BT, alt_short_patt
a1115 1
	    case PROCESSOR_BT:
a1144 1
	    case PROCESSOR_BT:
@


1.497.2.2
log
@gas/
2012-10-09  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* config/tc-i386.c (cpu_arch): Add CPU_BDVER3_FLAGS.
	* doc/c-i386.texi: Add -march=bdver3 option.

gas/testsuite/
2012-10-09  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* gas/i386/i386.exp: Run bdver3 test cases.
	* gas/i386/nops-1-bdver3.d: New.
	* gas/i386/arch-10-bdver3.d: New.
	* gas/i386/x86-64-nops-1-bdver3.d: New.
	* gas/i386/x86-64-arch-2-bdver3.d: New.

opcodes/
2012-10-09  Nagajyothi Eggone  <nagajyothi.eggone@@amd.com>

	* i386-gen.c (cpu_flag_init): Add CPU_BDVER3_FLAGS.
	* i386-init.h: Regenerated.
@
text
@a665 2
  { STRING_COMMA_LEN ("bdver3"), PROCESSOR_BD,
    CPU_BDVER3_FLAGS, 0, 0 },
@


1.496
log
@gas/
	* config/tc-i386.c (parse_insn): Don't complain about REP prefix
	when the template has opcode_modifier.repprefixok set.
	* NEWS: Mention the change.

gas/testsuite/
	* gas/i386/rep-bsf.d: New file.
	* gas/i386/rep-bsf.s: New file.
	* gas/i386/i386.exp: Add the new test.

opcodes/
	* i386-opc.h (RepPrefixOk): New enum constant.
	(i386_opcode_modifier): New bitfield 'repprefixok'.
	* i386-gen.c (opcode_modifiers): Add RepPrefixOk.
	* i386-opc.tbl: Add RepPrefixOk to bsf, bsr, and to all
	instructions that have IsString.
	* i386-tbl.h: Regenerate.
@
text
@d770 6
@


1.495
log
@Fix .dc.a for x32

gas/

	* config/tc-i386.c (x86_address_bytes): New.
	* config/tc-i386.h (TC_ADDRESS_BYTES): Likewise.
	(x86_address_bytes): Likewise.

gas/testsuite/

	* gas/i386/ilp32/x86-64-dc_a.d: New.
	* gas/i386/ilp32/x86-64-dc_a.s: Likewise.
@
text
@d3531 1
a3531 1
  /* Check for rep/repne without a string instruction.  */
d3537 1
a3537 1
	if (t->opcode_modifier.isstring)
d3546 1
a3546 1
	if (!t->opcode_modifier.isstring)
@


1.494
log
@Remove x32 addend overflow for BFD_RELOC_64

gas/

	* config/tc-i386.c (tc_gen_reloc): Remove x32 addend overflow
	for BFD_RELOC_64.

gas/testsuite/

	* gas/i386/ilp32/ilp32.exp: Don't run reloc64-inval.

	* gas/i386/ilp32/reloc64.s: Add test for -4294967295 addend.
	* gas/i386/ilp32/reloc64.d: Updated.

	* gas/i386/ilp32/reloc64-inval.l: Removed.
	* gas/i386/ilp32/reloc64-inval.s: Likewise.
@
text
@d6622 11
@


1.493
log
@Use int and bfd_signed_vma in x32 addend overflow check

bfd/

	* elf64-x86-64.c (elf_x86_64_relocate_section): Use int in x32
	addend overflow check.

gas/

	* config/tc-i386.c (tc_gen_reloc): Use bfd_signed_vma in x32
	addend overflow check.
@
text
@a9175 19
	  case BFD_RELOC_64:
	    /* Check addend overflow.  */
	    if (!fits_in_signed_long (fixp->fx_offset))
	      {
		bfd_signed_vma addend = fixp->fx_offset;
		if (addend < 0)
		  as_bad_where (fixp->fx_file, fixp->fx_line,
				_("cannot represent relocation %s with "
				  "addend -0x%" BFD_VMA_FMT "x in x32 "
				  "mode"),
				bfd_get_reloc_code_name (code), -addend);
		else
		  as_bad_where (fixp->fx_file, fixp->fx_line,
				_("cannot represent relocation %s with "
				  "addend 0x%" BFD_VMA_FMT "x in x32 "
				  "mode"),
				bfd_get_reloc_code_name (code), addend);
	      }
	    break;
@


1.492
log
@Display signed hex number in x32 addend overflow check

bfd/

	* elf64-x86-64.c (elf_x86_64_relocate_section): Display signed
	hex number in x32 addend overflow check.

gas/

	* config/tc-i386.c (tc_gen_reloc): Display signed hex number in
	x32 addend overflow check.

ld/testsuite/

	* ld-x86-64/ilp32-11.d: Updated.
@
text
@d9180 1
a9180 1
		long long addend = fixp->fx_offset;
d9184 2
a9185 1
				  "addend -0x%llx in x32 mode"),
d9190 2
a9191 1
				  "addend 0x%llx in x32 mode"),
@


1.491
log
@Use fits_in_signed_long to check x32 addend overflow

	* config/tc-i386.c (tc_gen_reloc): Use fits_in_signed_long.
@
text
@d9180 11
a9190 4
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("cannot represent relocation %s with addend %lld in x32 mode"),
			      bfd_get_reloc_code_name (code),
			      (long long) fixp->fx_offset);
@


1.490
log
@Check 64-bit relocation addend overflow for x32

bfd/

	* elf64-x86-64.c (elf_x86_64_relocate_section): Check addend
	overflow for R_X86_64_RELATIVE64.

gas/

	* config/tc-i386.c (tc_gen_reloc): Check x32 addend overflow
	for BFD_RELOC_64.

gas/testsuite/

	* gas/i386/ilp32/ilp32.exp: Run reloc64-inval.

	* gas/i386/ilp32/reloc64.s: Add tests for ".quad".
	* gas/i386/ilp32/reloc64.d: Updated.

	* gas/i386/ilp32/reloc64-inval.l: New file.
	* gas/i386/ilp32/reloc64-inval.s: Likewise.

ld/testsuite/

	* ld-x86-64/ilp32-11.d: New file.
	* ld-x86-64/ilp32-11.s: Likewise.

	* ld-x86-64/x86-64.exp: Run ilp32-11.
@
text
@d9178 1
a9178 2
	    if ((long long) fixp->fx_offset > 0x7fffffffLL
		|| (long long) fixp->fx_offset < -0x80000000LL)
@


1.489
log
@Add `instruction' to unsupported error message

	* config/tc-i386.c (match_template): Add `instruction' to
	unsupported error message.
@
text
@d9176 11
@


1.488
log
@Reformat output_insn

	* config/tc-i386.c (output_insn): Reformat.
@
text
@d4356 1
a4356 1
	  as_bad (_("unsupported `%s'"),
@


1.487
log
@Remove the extra VEX check

	* config/tc-i386.c (output_insn): Remove the extra VEX check.
@
text
@d6221 1
a6221 1
	  need the explicit prefix.  */
@


1.486
log
@Improve unsupported error message

	* config/tc-i386.c (match_template): Improve unsupported error
	message.
@
text
@d6260 1
a6260 2

      if (i.tm.opcode_modifier.vex)
@


1.485
log
@gas/
2012-03-12  Roland McGrath  <mcgrathr@@google.com>

	* config/tc-arm.c (arm_frag_max_var): New function.
	* config/tc-arm.h: Declare it.
	(md_frag_max_var): New macro.

	* config/tc-i386.c (i386_frag_max_var): New function.
	* config/tc-i386.h: Declare it.
	(md_frag_max_var): New macro.

	* doc/as.texinfo (Bundle directives): New node.
	(Pseudo Ops): Add it to the menu.
	* NEWS: Mention new feature.
	* read.c [md_frag_max_var] (HANDLE_BUNDLE): New macro.
	[HANDLE_BUNDLE] (bundle_align_p2): New variable.
	[HANDLE_BUNDLE] (bundle_lock_frchain, bundle_lock_frag): New variables.
	[HANDLE_BUNDLE] (start_bundle, pending_bundle_size, finish_bundle):
	New functions.
	(assemble_one): New function if [HANDLE_BUNDLE], #define directly
	to md_assembly if not.
	(read_a_source_file): Call assemble_one in place of md_assemble.
	(read_a_source_file) [HANDLE_BUNDLE]: Check for unterminated
	.bundle_lock at end of processing.
	[HANDLE_BUNDLE] (s_bundle_align_mode, s_bundle_lock, s_bundle_unlock):
	New functions.
	[HANDLE_BUNDLE] (potable): Add their entries.
	* read.h: Declare new functions.

gas/testsuite/
2012-03-12  Roland McGrath  <mcgrathr@@google.com>

	* gas/i386/bundle-bad.s: New file.
	* gas/i386/bundle-bad.d: New file.
	* gas/i386/bundle-bad.l: New file.
	* gas/i386/i386.exp: Run it.

	* gas/arm/bundle.s: New file.
	* gas/arm/bundle.d: New file.
	* gas/arm/bundle-lock.s: New file.
	* gas/arm/bundle-lock.d: New file.

	* gas/i386/bundle.s: New file.
	* gas/i386/bundle.d: New file.
	* gas/i386/x86-64-bundle.s: New file.
	* gas/i386/x86-64-bundle.d: New file.
	* gas/i386/bundle-lock.s: New file.
	* gas/i386/bundle-lock.d: New file.
	* gas/i386/i386.exp: Run them.
@
text
@d4356 3
a4358 2
	  err_msg = _("unsupported");
	  break;
@


1.484
log
@Add HLEPrefixNone/HLEPrefixLock/HLEPrefixAny/HLEPrefixRelease

gas/

2012-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (check_hle): Use HLEPrefixNone, HLEPrefixLock,
	HLEPrefixAny and HLEPrefixRelease.

opcodes/

2012-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.h (HLEPrefixNone): New.
	(HLEPrefixLock): Likewise.
	(HLEPrefixAny): Likewise.
	(HLEPrefixRelease): Likewise.
@
text
@d7718 12
@


1.483
log
@Implement Intel Transactional Synchronization Extensions

gas/

2012-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (HLE_PREFIX): New.
	(check_hle): Likewise.
	(_i386_insn): Add have_hle.
	(cpu_arch): Add .hle and .rtm.
	(md_assemble): Call check_hle if i.have_hle isn't zero.
	(parse_insn): Set i.have_hle to 1 for HLE prefix.
	(output_jump): Support up to 2 byte opcode.

	* doc/c-i386.texi: Document hle/.hle and rtm/.rtm.

gas/testsuite/

2012-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/hle-intel.d: New.
	* gas/i386/hle.d: Likewise.
	* gas/i386/hle.s: Likewise.
	* gas/i386/hlebad.l: Likewise.
	* gas/i386/hlebad.s: Likewise.
	* gas/i386/rtm-intel.d: Likewise.
	* gas/i386/rtm.d: Likewise.
	* gas/i386/rtm.s: Likewise.
	* gas/i386/x86-64-hle-intel.d: Likewise.
	* gas/i386/x86-64-hle.d: Likewise.
	* gas/i386/x86-64-hle.s: Likewise.
	* gas/i386/x86-64-hlebad.l: Likewise.
	* gas/i386/x86-64-hlebad.s: Likewise.
	* gas/i386/x86-64-rtm-intel.d: Likewise.
	* gas/i386/x86-64-rtm.d: Likewise.
	* gas/i386/x86-64-rtm.s: Likewise.

	* gas/i386/i386.exp: Run hle, hle-intel, hlebad x86-64-hle, rtm,
	rtm-intel, x86-64-hle-intel, x86-64-hlebad, x86-64-rtm and
	x86-64-rtm-intel.

include/opcode/

2012-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386.h (XACQUIRE_PREFIX_OPCODE): New.
	(XRELEASE_PREFIX_OPCODE): Likewise.

opcodes/

2012-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (HLE_Fixup1): New.
	(HLE_Fixup2): Likewise.
	(HLE_Fixup3): Likewise.
	(Ebh1): Likewise.
	(Evh1): Likewise.
	(Ebh2): Likewise.
	(Evh2): Likewise.
	(Ebh3): Likewise.
	(Evh3): Likewise.
	(MOD_C6_REG_7): Likewise.
	(MOD_C7_REG_7): Likewise.
	(RM_C6_REG_7): Likewise.
	(RM_C7_REG_7): Likewise.
	(XACQUIRE_PREFIX): Likewise.
	(XRELEASE_PREFIX): Likewise.
	(dis386): Use Ebh1/Evh1 on add, adc, and, btc, btr, bts,
	cmpxchg, dec, inc, neg, not, or, sbb, sub, xor and xadd. Use
	Ebh2/Evh2 on xchg.  Use Ebh3/Evh3 on mov.
	(reg_table): Use Ebh1/Evh1 on add, adc, and, dec, inc, neg,
	not, or, sbb, sub and xor.  Use Ebh3/Evh3 on mov.  Use
	MOD_C6_REG_7 and MOD_C7_REG_7.
	(mod_table): Add MOD_C6_REG_7 and MOD_C7_REG_7.
	(rm_table): Add RM_C6_REG_7 and RM_C7_REG_7.  Add xend and
	xtest.
	(prefix_name): Handle XACQUIRE_PREFIX and XRELEASE_PREFIX.
	(CMPXCHG8B_Fixup): Handle HLE prefix on cmpxchg8b.

	* i386-gen.c (cpu_flag_init): Add CPU_HLE_FLAGS and
	CPU_RTM_FLAGS.
	(cpu_flags): Add CpuHLE and CpuRTM.
	(opcode_modifiers): Add HLEPrefixOk.

	* i386-opc.h (CpuHLE): New.
	(CpuRTM): Likewise.
	(HLEPrefixOk): Likewise.
	(i386_cpu_flags): Add cpuhle and cpurtm.
	(i386_opcode_modifier): Add hleprefixok.

	* i386-opc.tbl: Add HLEPrefixOk=3 to mov.  Add HLEPrefixOk to
	add, adc, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or,
	sbb, sub, xor and xadd.  Add HLEPrefixOk=2 to xchg with memory
	operand.  Add xacquire, xrelease, xabort, xbegin, xend and
	xtest.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d3018 1
a3018 1
    case 0:
d3026 1
a3026 1
    case 1:
d3034 1
a3034 1
    case 2:
d3036 1
a3036 1
    case 3:
@


1.482
log
@* configure.tgt (i386-*-nacl*): Match it.
* config/te-nacl.h: New file.
* config/tc-i386.h [TE_NACL] (ELF_TARGET_FORMAT): Define for this case.
* config/tc-i386.c [TE_NACL] (i386_comment_chars, PREFIX_SEPARATOR):
Use TE_GNU et al case for TE_NACL too.
@
text
@d63 1
a63 1
   REP_PREFIX, LOCK_PREFIX.  */
d69 1
d292 3
d738 4
d3010 44
d3172 4
d3379 4
a3382 1
	      expecting_string_instruction = current_templates->start->name;
d6103 11
a6113 2
  p = frag_more (1 + size);
  *p++ = i.tm.base_opcode;
@


1.481
log
@Add .d8 suffix support to x86 assembler

gas/

2012-01-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (_i386_insn): Replace disp32_encoding with
	disp_encoding.
	(md_assemble): Updated.
	(output_branch): Likewise.
	(parse_insn): Support .d8 suffix.
	(build_modrm_byte): Fake zero displacement for .d8 and .d32
	suffixes.

	* doc/c-i386.texi: Document .d8 suffix.

gas/testsuite/

2012-01-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/disp32.s: Add tests for .d8 suffix.
	* gas/i386/x86-64-disp32.s: Likewise.

	* gas/i386/disp32.d: Updated.
	* gas/i386/x86-64-disp32.d: Likewise.
@
text
@d312 2
a313 1
 	 && !defined (TE_NETWARE)			\
d3341 1
a3341 1
      else if (mnem_p - 3 == dot_p 
d3345 1
a3345 1
      else if (mnem_p - 4 == dot_p 
d5858 1
a5858 1
		{ 
d8651 1
a8651 1
	  
@


1.480
log
@Add vmfunc

gas/

2012-01-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add ".vmfunc".

	* doc/c-i386.texi: Document vmfunc.

gas/testsuite/

2012-01-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run vmfunc and x86-64-vmfunc.

	* gas/i386/vmfunc.d: New.
	* gas/i386/vmfunc.s: Likewise.
	* gas/i386/x86-64-vmfunc.d: Likewise.

opcodes/

2012-01-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (mod_table): Add vmfunc.

	* i386-gen.c (cpu_flag_init): Add CPU_VMFUNC_FLAGS.
	(cpu_flags): CpuVMFUNC.

	* i386-opc.h (CpuVMFUNC): New.
	(i386_cpu_flags): Add cpuvmfunc.

	* i386-opc.tbl: Add vmfunc.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d283 7
a289 2
    /* Force 32bit displacement in encoding.  */
    unsigned int disp32_encoding;
d3061 1
a3061 1
      && !i.disp32_encoding
d3340 4
d3348 1
a3348 1
	i.disp32_encoding = 1;
d5710 13
a5722 1
		i.rm.mode = mode_from_disp_size (i.types[op]);
d5924 1
a5924 1
  size = i.disp32_encoding ? BIG : SMALL;
@


1.479
log
@2012-01-06  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-i386.c: Update copyright year.
	(lex_got): Also defined for Mach-O.
	Add a guard for non-ELF configuration.
	(md_longopts): Also handle -64 for Mach-O.
	(md_parse_option): Likewise.
	(i386_target_format): Adjust for x86_64-darwin.
@
text
@d692 2
@


1.478
log
@Check R_X86_64_32 overflow and allow R_X86_64_64 for x32.

bfd/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* archures.c (bfd_mach_i386_intel_syntax): New.
	(bfd_mach_i386_i8086): Updated.
	(bfd_mach_i386_i386): Likewise.
	(bfd_mach_x86_64): Likewise.
	(bfd_mach_x64_32): Likewise.
	(bfd_mach_i386_i386_intel_syntax): Likewise.
	(bfd_mach_x86_64_intel_syntax): Likewise.
	(bfd_mach_x64_32_intel_syntax): Likewise.
	(bfd_mach_l1om): Likewise.
	(bfd_mach_l1om_intel_syntax): Likewise.
	(bfd_mach_k1om): Likewise.
	(bfd_mach_k1om_intel_syntax): Likewise.

	* bfd-in2.h: Regenerated.

	* cpu-i386.c (bfd_i386_compatible): Check mach instead of
	bits_per_address.
	(bfd_x64_32_arch_intel_syntax): Set bits_per_address to 64.
	(bfd_x64_32_arch): Likewise.

	* elf64-x86-64.c: Include "libiberty.h".
	(x86_64_elf_howto_table): Append x32 R_X86_64_32.
	(elf_x86_64_rtype_to_howto): Support x32 R_X86_64_32.
	(elf_x86_64_reloc_type_lookup): Likewise.
	(elf_x86_64_reloc_name_lookup): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_check_relocs): Allow R_X86_64_64 relocations for x32.

gas/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* config/tc-i386.c (handle_quad): Removed.
	(md_pseudo_table): Remove "quad".
	(tc_gen_reloc): Don't check BFD_RELOC_64 for disallow_64bit_reloc.
	(x86_dwarf2_addr_size): New.

	* config/tc-i386.h (x86_dwarf2_addr_size): New.
	(DWARF2_ADDR_SIZE): Likewise.

gas/testsuite/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* gas/i386/ilp32/ilp32.exp: Don't run inval.

	* gas/i386/ilp32/inval.l: Removed.
	* gas/i386/ilp32/inval.s: Likewise.

	* gas/i386/ilp32/quad.d: Expect R_X86_64_64 instead of
	R_X86_64_32.

	* gas/i386/ilp32/x86-64-pcrel.s: Add tests for movabs.
	* gas/i386/ilp32/x86-64-pcrel.d: Updated.

ld/testsuite/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* ld-x86-64/ilp32-6.d: New.
	* ld-x86-64/ilp32-6.s: Likewise.
	* ld-x86-64/ilp32-7.d: Likewise.
	* ld-x86-64/ilp32-7.s: Likewise.
	* ld-x86-64/ilp32-8.d: Likewise.
	* ld-x86-64/ilp32-8.s: Likewise.
	* ld-x86-64/ilp32-9.d: Likewise.
	* ld-x86-64/ilp32-9.s: Likewise.

	* ld-x86-64/x86-64.exp: Run ilp32-6, ilp32-7, ilp32-8 and ilp32-9.

opcodes/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* i386-dis.c (print_insn): Optimize info->mach check.
@
text
@d3 2
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d6530 2
a6531 1
#if (!defined (OBJ_ELF) && !defined (OBJ_MAYBE_ELF)) || defined (LEX_AT)
d6614 1
d6617 1
d8290 1
a8290 1
     || defined (TE_PE) || defined (TE_PEP))
d8348 1
a8348 1
     || defined (TE_PE) || defined (TE_PEP))
d8358 2
a8359 1
	      || strcmp (*l, "pei-x86-64") == 0)
d8781 8
a8788 1
      return flag_code == CODE_64BIT ? "mach-o-x86-64" : "mach-o-i386";
@


1.477
log
@Add initial Intel K1OM support.

bfd/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_MACHINES): Add cpu-k1om.lo.
	(ALL_MACHINES_CFILES): Add cpu-k1om.c.
	* Makefile.in: Regenerated.

	* archures.c (bfd_architecture): Add bfd_arch_k1om.
	(bfd_k1om_arch): New.
	(bfd_archures_list): Add &bfd_k1om_arch.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf64_k1om_vec if
	bfd_elf64_x86_64_vec is supported.  Add bfd_elf64_k1om_freebsd_vec
	if bfd_elf64_x86_64_freebsd_vec is supported.
	(targ_selvecs): Likewise.

	* configure.in: Support bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.
	* configure: Regenerated.

	* cpu-k1om.c: New.

	* elf64-x86-64.c (elf64_k1om_elf_object_p): New.
	(bfd_elf64_k1om_vec): Likewise.
	(bfd_elf64_k1om_freebsd_vec): Likewise.

	* targets.c (bfd_elf64_k1om_vec): New.
	(bfd_elf64_k1om_freebsd_vec): Likewise.
	(_bfd_target_vector): Add bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.

binutils/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (init_dwarf_regnames): Handle EM_K1OM.

	* elfedit.c (elf_machine): Support EM_K1OM.
	(elf_class): Likewise.

	* readelf.c (guess_is_rela): Handle EM_K1OM.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(get_section_type_name): Likewise.
	(get_elf_section_flags): Likewise.
	(process_section_headers): Likewise.
	(get_symbol_index_type): Likewise.
	(is_32bit_abs_reloc): Likewise.
	(is_32bit_pcrel_reloc): Likewise.
	(is_64bit_abs_reloc): Likewise.
	(is_64bit_pcrel_reloc): Likewise.
	(is_none_reloc): Likewise.

	* doc/binutils.texi: Mention K1OM for elfedit.

binutils/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/elfedit.exp: Run elfedit-4.

	* binutils-all/elfedit-4.d: New.

gas/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add k1om.
	(i386_align_code): Handle PROCESSOR_K1OM.
	(check_cpu_arch_compatible): Check EM_K1OM.
	(i386_arch): Handle Intel K1OM.
	(i386_mach): Return bfd_mach_k1om for Intel K1OM.
	(i386_target_format): Return ELF_TARGET_K1OM_FORMAT for Intel
	K1OM.

	* config/tc-i386.h (ELF_TARGET_K1OM_FORMAT): New.
	(processor_type): Add PROCESSOR_K1OM.

	* doc/c-i386.texi: Document k1om.

gas/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/k1om.d: New.
	* gas/i386/k1om-inval.l: Likewise.
	* gas/i386/k1om-inval.s: Likewise.

	* gas/i386/i386.exp: Run k1om-inval and k1om.

include/elf/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (EM_K1OM): New.

ld/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_64_EMULATIONS): Add eelf_k1om.o and
	eelf_k1om_fbsd.o
	(eelf_k1om.c): New.
	(eelf_k1om_fbsd.c): Likewise.
	* Makefile.in: Regenerated.

	* configure.tgt (targ64_extra_emuls): Add elf_k1om if elf_x86_64
	is supported.  Add elf_k1om_fbsd if elf_x86_64_fbsd is supported.
	(targ_extra_emuls): Likewise.

	* emulparams/elf_k1om.sh: New.
	* emulparams/elf_k1om_fbsd.sh: Likewise.

ld/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/abs-k1om.d: New.
	* ld-x86-64/protected2-k1om.d: Likewise.
	* ld-x86-64/protected3-k1om.d: Likewise.

	* ld-x86-64/x86-64.exp: Run abs-k1om, protected2-k1om and
	protected3-k1om.

opcodes/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in: Handle bfd_k1om_arch.
	* configure: Regenerated.

	* disassemble.c (disassembler): Handle bfd_k1om_arch.

	* i386-dis.c (print_insn): Handle bfd_mach_k1om and
	bfd_mach_k1om_intel_syntax.

	* i386-gen.c (cpu_flag_init): Set CPU_UNKNOWN_FLAGS to
	~(CpuL1OM|CpuK1OM).  Add CPU_K1OM_FLAGS.
	(cpu_flags): Add CpuK1OM.

	* i386-opc.h (CpuK1OM): New.
	(i386_cpu_flags): Add cpuk1om.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@a184 1
static void handle_quad (int);
a829 1
  {"quad", handle_quad, 8},
a9059 1
	  case BFD_RELOC_64:
d9169 10
a9276 46

static void
handle_quad (int nbytes)
{
  expressionS exp;

  if (x86_elf_abi != X86_64_X32_ABI)
    {
      cons (nbytes);
      return;
    }

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      if (*input_line_pointer == '"')
	{
	  as_bad (_("unexpected `\"' in expression"));
	  ignore_rest_of_line ();
	  return;
	}
      x86_cons (&exp, nbytes);
      /* Output 4 bytes if not constant.  */
      if (exp.X_op != O_constant)
	nbytes = 4;
      emit_expr (&exp, (unsigned int) nbytes);
      /* Zero-extends to 8 bytes if not constant.  */
      if (nbytes == 4)
	{
	  memset (&exp, '\0', sizeof (exp));
	  exp.X_op = O_constant;
	  emit_expr (&exp, nbytes);
	}
      nbytes = 8;
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */

  demand_empty_rest_of_line ();
}
@


1.476
log
@2011-06-29  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-i386.c (i386_mach): Convert to ISO-C.
	(md_begin, pe_directive_secrel, md_estimate_size_before_relax): Ditto.
	(md_convert_frag, md_apply_fix, md_undefined_symbol): Ditto.
	(md_section_align, tc_gen_reloc): Ditto.
@
text
@d636 2
d1086 1
d1139 1
d2132 5
d2248 7
d2271 7
d8766 6
@


1.475
log
@Support AVX Programming Reference (June, 2011).

gas/

2011-06-10  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (June, 2011)
	* config/tc-i386.c (i386_error): Add invalid_vsib_address and
	unsupported_vector_index_register.
	(cpu_arch): Add .avx2, .bmi2, .lzcnt and .invpcid.
	(check_VecOperands): New.
	(match_template): Call check_VecOperands.  Handle
	invalid_vsib_address and unsupported_vector_index_register.
	(build_modrm_byte): Support VecSIB.  Check register-only source
	operand when two source operands are swapped.
	(i386_index_check): Allow Xmm/Ymm index registers.

	* doc/c-i386.texi: Document avx2/.avx2, bmi2/.bmi2, lzcnt/.lzcnt
	and invpcid./invpcid.

gas/testsuite/

2011-06-10  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (June, 2011)
	* gas/i386/arch-10-1.l: Updated.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.

	* gas/i386/arch-10.s: Add LZCNT to comments.
	* gas/i386/x86-64-arch-2.s: Likewise.

	* gas/i386/arch-10-lzcnt.d: New.
	* gas/i386/avx-gather-intel.d: Likewise.
	* gas/i386/avx-gather.d: Likewise.
	* gas/i386/avx-gather.s: Likewise.
	* gas/i386/avx2-intel.d: Likewise.
	* gas/i386/avx2.d: Likewise.
	* gas/i386/avx2.s: Likewise
	* gas/i386/avx256int-intel.d: Likewise.
	* gas/i386/avx256int.d: Likewise.
	* gas/i386/avx256int.s: Likewise.
	* gas/i386/bmi2-intel.d: Likewise.
	* gas/i386/bmi2.d: Likewise.
	* gas/i386/bmi2.s: Likewise.
	* gas/i386/inval-invpcid.l:Likewise.
	* gas/i386/inval-invpcid.s: Likewise.
	* gas/i386/invpcid-intel.d: Likewise.
	* gas/i386/invpcid.d: Likewise.
	* gas/i386/invpcid.s: Likewise.
	* gas/i386/x86-64-arch-2-lzcnt.d: Likewise.
	* gas/i386/x86-64-avx-gather-intel.d: Likewise.
	* gas/i386/x86-64-avx-gather.d: Likewise.
	* gas/i386/x86-64-avx-gather.s: Likewise.
	* gas/i386/x86-64-avx2-intel.d: Likewise.
	* gas/i386/x86-64-avx2.d: Likewise.
	* gas/i386/x86-64-avx2.s: Likewise.
	* gas/i386/x86-64-avx256int-intel.d: Likewise.
	* gas/i386/x86-64-avx256int.d: Likewise.
	* gas/i386/x86-64-avx256int.s: Likewise.
	* gas/i386/x86-64-bmi2-intel.d: Likewise.
	* gas/i386/x86-64-bmi2.d: Likewise.
	* gas/i386/x86-64-bmi2.s: Likewise.
	* gas/i386/x86-64-inval-invpcid.l: Likewise.
	* gas/i386/x86-64-inval-invpcid.s: Likewise.
	* gas/i386/x86-64-invpcid-intel.d: Likewise.
	* gas/i386/x86-64-invpcid.d: Likewise.
	* gas/i386/x86-64-invpcid.s: Likewise.

opcodes/

2011-06-10  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (June, 2011)
	* i386-dis.c (XMGatherQ): New.
	* i386-dis.c (EXxmm_mb): New.
	(EXxmm_mb): Likewise.
	(EXxmm_mw): Likewise.
	(EXxmm_md): Likewise.
	(EXxmm_mq): Likewise.
	(EXxmmdw): Likewise.
	(EXxmmqd): Likewise.
	(VexGatherQ): Likewise.
	(MVexVSIBDWpX): Likewise.
	(MVexVSIBQWpX): Likewise.
	(xmm_mb_mode): Likewise.
	(xmm_mw_mode): Likewise.
	(xmm_md_mode): Likewise.
	(xmm_mq_mode): Likewise.
	(xmmdw_mode): Likewise.
	(xmmqd_mode): Likewise.
	(ymmxmm_mode): Likewise.
	(vex_vsib_d_w_dq_mode): Likewise.
	(vex_vsib_q_w_dq_mode): Likewise.
	(MOD_VEX_0F385A_PREFIX_2): Likewise.
	(MOD_VEX_0F388C_PREFIX_2): Likewise.
	(MOD_VEX_0F388E_PREFIX_2): Likewise.
	(PREFIX_0F3882): Likewise.
	(PREFIX_VEX_0F3816): Likewise.
	(PREFIX_VEX_0F3836): Likewise.
	(PREFIX_VEX_0F3845): Likewise.
	(PREFIX_VEX_0F3846): Likewise.
	(PREFIX_VEX_0F3847): Likewise.
	(PREFIX_VEX_0F3858): Likewise.
	(PREFIX_VEX_0F3859): Likewise.
	(PREFIX_VEX_0F385A): Likewise.
	(PREFIX_VEX_0F3878): Likewise.
	(PREFIX_VEX_0F3879): Likewise.
	(PREFIX_VEX_0F388C): Likewise.
	(PREFIX_VEX_0F388E): Likewise.
	(PREFIX_VEX_0F3890..PREFIX_VEX_0F3893): Likewise.
	(PREFIX_VEX_0F38F5): Likewise.
	(PREFIX_VEX_0F38F6): Likewise.
	(PREFIX_VEX_0F3A00): Likewise.
	(PREFIX_VEX_0F3A01): Likewise.
	(PREFIX_VEX_0F3A02): Likewise.
	(PREFIX_VEX_0F3A38): Likewise.
	(PREFIX_VEX_0F3A39): Likewise.
	(PREFIX_VEX_0F3A46): Likewise.
	(PREFIX_VEX_0F3AF0): Likewise.
	(VEX_LEN_0F3816_P_2): Likewise.
	(VEX_LEN_0F3819_P_2): Likewise.
	(VEX_LEN_0F3836_P_2): Likewise.
	(VEX_LEN_0F385A_P_2_M_0): Likewise.
	(VEX_LEN_0F38F5_P_0): Likewise.
	(VEX_LEN_0F38F5_P_1): Likewise.
	(VEX_LEN_0F38F5_P_3): Likewise.
	(VEX_LEN_0F38F6_P_3): Likewise.
	(VEX_LEN_0F38F7_P_1): Likewise.
	(VEX_LEN_0F38F7_P_2): Likewise.
	(VEX_LEN_0F38F7_P_3): Likewise.
	(VEX_LEN_0F3A00_P_2): Likewise.
	(VEX_LEN_0F3A01_P_2): Likewise.
	(VEX_LEN_0F3A38_P_2): Likewise.
	(VEX_LEN_0F3A39_P_2): Likewise.
	(VEX_LEN_0F3A46_P_2): Likewise.
	(VEX_LEN_0F3AF0_P_3): Likewise.
	(VEX_W_0F3816_P_2): Likewise.
	(VEX_W_0F3818_P_2): Likewise.
	(VEX_W_0F3819_P_2): Likewise.
	(VEX_W_0F3836_P_2): Likewise.
	(VEX_W_0F3846_P_2): Likewise.
	(VEX_W_0F3858_P_2): Likewise.
	(VEX_W_0F3859_P_2): Likewise.
	(VEX_W_0F385A_P_2_M_0): Likewise.
	(VEX_W_0F3878_P_2): Likewise.
	(VEX_W_0F3879_P_2): Likewise.
	(VEX_W_0F3A00_P_2): Likewise.
	(VEX_W_0F3A01_P_2): Likewise.
	(VEX_W_0F3A02_P_2): Likewise.
	(VEX_W_0F3A38_P_2): Likewise.
	(VEX_W_0F3A39_P_2): Likewise.
	(VEX_W_0F3A46_P_2): Likewise.
	(MOD_VEX_0F3818_PREFIX_2): Removed.
	(MOD_VEX_0F3819_PREFIX_2): Likewise.
	(VEX_LEN_0F60_P_2..VEX_LEN_0F6D_P_2): Likewise.
	(VEX_LEN_0F70_P_1..VEX_LEN_0F76_P_2): Likewise.
	(VEX_LEN_0FD1_P_2..VEX_LEN_0FD5_P_2): Likewise.
	(VEX_LEN_0FD7_P_2_M_1..VEX_LEN_0F3819_P_2_M_0): Likewise.
	(VEX_LEN_0F381C_P_2..VEX_LEN_0F3840_P_2): Likewise.
	(VEX_LEN_0F3A0E_P_2): Likewise.
	(VEX_LEN_0F3A0F_P_2): Likewise.
	(VEX_LEN_0F3A42_P_2): Likewise.
	(VEX_LEN_0F3A4C_P_2): Likewise.
	(VEX_W_0F3818_P_2_M_0): Likewise.
	(VEX_W_0F3819_P_2_M_0): Likewise.
	(prefix_table): Updated.
	(three_byte_table): Likewise.
	(vex_table): Likewise.
	(vex_len_table): Likewise.
	(vex_w_table): Likewise.
	(mod_table): Likewise.
	(putop): Handle "LW".
	(intel_operand_size): Handle xmm_mb_mode, xmm_mw_mode,
	xmm_md_mode, xmm_mq_mode, xmmdw_mode, xmmqd_mode, ymmxmm_mode,
	vex_vsib_d_w_dq_mode, vex_vsib_q_w_dq_mode.
	(OP_EX): Likewise.
	(OP_E_memory): Handle vex_vsib_d_w_dq_mode and
	vex_vsib_q_w_dq_mode.
	(OP_XMM): Handle vex_vsib_q_w_dq_mode.
	(OP_VEX): Likewise.

	* i386-gen.c (cpu_flag_init): Add CpuAVX2 to CPU_ANY_SSE_FLAGS
	and CPU_ANY_AVX_FLAGS.  Add CPU_BMI2_FLAGS, CPU_LZCNT_FLAGS,
	CPU_INVPCID_FLAGS and CPU_AVX2_FLAGS.
	(cpu_flags): Add CpuAVX2, CpuBMI2, CpuLZCNT and CpuINVPCID.
	(opcode_modifiers): Add VecSIB.

	* i386-opc.h (CpuAVX2): New.
	(CpuBMI2): Likewise.
	(CpuLZCNT): Likewise.
	(CpuINVPCID): Likewise.
	(VecSIB128): Likewise.
	(VecSIB256): Likewise.
	(VecSIB): Likewise.
	(i386_cpu_flags): Add cpuavx2, cpubmi2, cpulzcnt and cpuinvpcid.
	(i386_opcode_modifier): Add vecsib.

	* i386-opc.tbl: Add invpcid, AVX2 and BMI2 instructions.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d2244 1
a2244 1
i386_mach ()
d2267 1
a2267 1
md_begin ()
d6723 1
a6723 2
pe_directive_secrel (dummy)
     int dummy ATTRIBUTE_UNUSED;
d7615 1
a7615 3
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP;
     segT segment;
d7738 2
a7739 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
d7836 1
a7836 1
/* Apply a fixup (fixS) to segment data, once it has been determined
d7839 2
d7846 1
a7846 7
md_apply_fix (fixP, valP, seg)
     /* The fix we're to put in.  */
     fixS *fixP;
     /* Pointer to the value of the bits.  */
     valueT *valP;
     /* Segment fix is from.  */
     segT seg ATTRIBUTE_UNUSED;
d8802 1
a8802 2
md_undefined_symbol (name)
     char *name;
d8824 1
a8824 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d8895 1
a8895 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
@


1.474
log
@2011-05-12  Quentin Neill  <quentin.neill@@amd.com>

      * config/tc-i386.c (cpu_arch): Rename PROCESSOR_BDVER1 to PROCESSOR_BD.
      (i386_align_code): Ditto
@
text
@d221 3
a223 1
    unsupported
d684 2
d708 2
d722 4
d3847 32
d4215 4
d4265 6
d5467 31
d5504 7
a5510 1
		fake_zero_displacement = 1;
d5513 1
d5539 1
a5539 1
	      else /* !i.base_reg && i.index_reg  */
d5541 1
d5572 1
d5585 1
d5629 2
a5630 1
	      i.rm.regmem = i.base_reg->reg_num;
d5652 1
d5660 1
a5660 1
	      else
d7222 2
d7257 2
@


1.473
log
@2011-05-10  Quentin Neill  <quentin.neill@@amd.com>

gas/
	* config/tc-i386.c (cpu_arch): Add bdver2 and rename
	PROCESSOR_BDVER1 to PROCESSOR_BDVER.
	(i386_align_code): Rename PROCESSOR_BDVER1.
	(processor_type): Ditto.
	* doc/c-i386.texi: Add bdver2.

opcodes/
	* i386-gen.c (cpu_flag_init): Add new CPU_BDVER2_FLAGS.
	* i386-init.h: Regenerated.

gas/testsuite/
	* gas/i386/i386.exp: Add new bdver2 test cases.
	* gas/i386/nops-1-bdver2.d: New.
	* gas/i386/x86-64-nops-1-bdver2.d: New.
@
text
@d648 1
a648 1
  { STRING_COMMA_LEN ("bdver1"), PROCESSOR_BDVER,
d650 1
a650 1
  { STRING_COMMA_LEN ("bdver2"), PROCESSOR_BDVER,
d1028 1
a1028 1
     PROCESSOR_AMDFAM10, and PROCESSOR_BDVER, alt_short_patt
d1081 1
a1081 1
	    case PROCESSOR_BDVER:
d1110 1
a1110 1
	    case PROCESSOR_BDVER:
@


1.472
log
@Start error message with lower case.

2011-04-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_mach): Start error message with lower
	case.
	(md_begin): Likewise.
	(md_parse_option): Likewise.
	(i386_target_format): Likewise.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
@
text
@d648 1
a648 1
  { STRING_COMMA_LEN ("bdver1"), PROCESSOR_BDVER1,
d650 2
d1028 1
a1028 1
     PROCESSOR_AMDFAM10, and PROCESSOR_BDVER1, alt_short_patt
d1081 1
a1081 1
	    case PROCESSOR_BDVER1:
d1110 1
a1110 1
	    case PROCESSOR_BDVER1:
@


1.471
log
@2011-04-11  Kai Tietz  <ktietz@@redhat.com>

        * config/tc-i386.c (x86_cons): Initialize adjust with zero.
@
text
@d2251 1
a2251 1
    as_fatal (_("Unknown architecture"));
d2285 1
a2285 1
		as_fatal (_("Internal Error:  Can't hash %s: %s"),
d2307 1
a2307 1
	  as_fatal (_("Internal Error:  Can't hash %s: %s"),
d4597 1
a4597 1
	      as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
d4672 1
a4672 1
	    as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
d4701 1
a4701 1
	    as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
d4747 1
a4747 1
	    as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
d4785 1
a4785 1
	    as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
d8247 1
a8247 1
	  as_fatal (_("No compiled in support for x86_64"));
d8267 1
a8267 1
	    as_fatal (_("No compiled in support for 32bit x86_64"));
d8301 1
a8301 1
	    as_fatal (_("Invalid -march= option: `%s'"), arg);
d8357 1
a8357 1
	    as_fatal (_("Invalid -march= option: `%s'"), arg);
d8366 1
a8366 1
	as_fatal (_("Invalid -mtune= option: `%s'"), arg);
d8378 1
a8378 1
	as_fatal (_("Invalid -mtune= option: `%s'"), arg);
d8387 1
a8387 1
	as_fatal (_("Invalid -mmnemonic= option: `%s'"), arg);
d8396 1
a8396 1
	as_fatal (_("Invalid -msyntax= option: `%s'"), arg);
d8423 1
a8423 1
	as_fatal (_("Invalid -msse-check= option: `%s'"), arg);
d8432 1
a8432 1
	as_fatal (_("Invalid -mavxscalar= option: `%s'"), arg);
d8598 1
a8598 1
    as_fatal (_("Unknown architecture"));
@


1.470
log
@	* config/tc-i386.c (x86_cons): Define even for non-ELF targets.
	* config/tc-i386.h (x86_cons): Always prototype.
@
text
@d6575 1
a6575 1
      int adjust;
@


1.469
log
@Properly handle multiple operands for x32 quad.

gas/

2011-03-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (handle_quad): Properly handle multiple
	operands.

gas/testsuite/

2011-03-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/quad.d: Add tests for multiple operands.
	* gas/i386/ilp32/quad.s: Likewise.
@
text
@d6562 1
a6613 1
#endif
@


1.468
log
@Support .quad for x32.

gas/

2011-03-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (handle_quad): New.
	(md_pseudo_table): Add "quad".

gas/testsuite/

2011-03-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/inval.s: Remove .quad.
	* gas/i386/ilp32/inval.l: Updated.

	* gas/i386/ilp32/quad.d: New.
	* gas/i386/ilp32/quad.s: Likewise.
@
text
@d9185 8
a9198 8

  /* Zero-extends to 8 bytes if not constant.  */
  if (nbytes == 4)
    {
      memset (&exp, '\0', sizeof (exp));
      exp.X_op = O_constant;
      emit_expr (&exp, nbytes);
    }
@


1.467
log
@Add support for DragonFlyBSD target.
@
text
@d185 1
d817 1
d9154 46
@


1.466
log
@Revert the last change.
@
text
@d306 1
@


1.465
log
@Set x86_cie_data_alignment to -4 for x32.

gas/

2011-03-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (x86_cie_stack_alignment): New.
	(md_begin): Set x86_cie_data_alignment if it isn't set.  Set
	x86_cie_stack_alignment.
	(i386_target_format): Set x86_cie_data_alignment to -4 for x32.
	(tc_x86_frame_initial_instructions): Use x86_cie_stack_alignment
	instead of x86_cie_data_alignment on SP and RA.

gas/testsuite/

2011-03-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/cfi/cfi-x86_64.d: Updated.
@
text
@a504 3
/* The dwarf2 stack alignment, adjusted for 32 or 64 bit.  */
static int x86_cie_stack_alignment;

d2381 1
a2381 3
      if (!x86_cie_data_alignment)
	x86_cie_data_alignment = -8;
      x86_cie_stack_alignment = -8;
a2386 1
      x86_cie_stack_alignment = -4;
a8638 1
	    x86_cie_data_alignment = -4;
d9048 2
a9049 2
  cfi_add_CFA_def_cfa (sp_regno[flag_code >> 1], -x86_cie_stack_alignment);
  cfi_add_CFA_offset (x86_dwarf2_return_column, x86_cie_stack_alignment);
@


1.464
log
@Don't sign-checking 4-byte relocations for x32.

gas/

2011-02-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (reloc): Don't sign-checking 4-byte
	relocations if 64bit relocations aren't allowed.

gas/testsuite/

2011-02-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/ilp32.exp: Run reloc64.

	* gas/i386/ilp32/reloc64.s: Allow TLS relocations with 32bit
	register destinations.
	* gas/i386/ilp32/reloc64.d: Updated.

	* gas/i386/ilp32/reloc64.l: New.
@
text
@d505 3
d2384 3
a2386 1
      x86_cie_data_alignment = -8;
d2392 1
d8645 1
d9055 2
a9056 2
  cfi_add_CFA_def_cfa (sp_regno[flag_code >> 1], -x86_cie_data_alignment);
  cfi_add_CFA_offset (x86_dwarf2_return_column, x86_cie_data_alignment);
@


1.463
log
@Use f32_patt in i386_align_code  when tuning for i686.

gas/

2011-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/6957
	* config/tc-i386.c (i386_align_code): Use f32_patt when tuning
	for i686.

gas/testsuite/

2011-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/6957
	* gas/i386/nops-1-i686.d: Updated.
	* gas/i386/nops-3-i686.d: Likewise.
	* gas/i386/nops-4-i686.d: Likewise.
@
text
@d2594 1
a2594 1
      if (size == 4 && flag_code != CODE_64BIT)
@


1.462
log
@Also update cpu_arch_isa_flags for ISA extensions.

gas/

2011-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (set_cpu_arch): Also update cpu_arch_isa_flags
	for ISA extensions.
	(md_parse_option): Likewise.

gas/testsuite/

2011-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run nops-4a-i686 and nops-6.

	* gas/i386/nops-4a-i686.d: New.
	* gas/i386/nops-6.d: Likewise.
	* gas/i386/nops-6.s: Likewise.
@
text
@a1062 1
	    case PROCESSOR_PENTIUMPRO:
d1082 1
@


1.461
log
@2011-01-26  Kai Tietz  <kai.tietz@@onevision.com>

        * config/tc-i386.c (md_begin): Set for x64 windows COFF target
        x86_dwarf2_return_column to 32.
@
text
@d2179 1
d8347 1
@


1.460
log
@Add support for TBM instructions.

gas/

2011-01-17  Quentin Neill  <quentin.neill@@amd.com>

	* config/tc-i386.c (cpu_arch): Add CPU_TBM_FLAGS.

	* doc/c-i386.texi (i386-TBM): New section.

opcodes/

2011-01-17  Quentin Neill  <quentin.neill@@amd.com>

	* i386-dis.c (REG_XOP_TBM_01): New.
	(REG_XOP_TBM_02): New.
	(reg_table): Add REG_XOP_TBM_01 and REG_XOP_TBM_02 tables.
	(xop_table): Redirect to REG_XOP_TBM_01 and REG_XOP_TBM_02
	entries, and add bextr instruction.

	* i386-gen.c (cpu_flag_init): Add CPU_TBM_FLAGS, CpuTBM.
	(cpu_flags): Add CpuTBM.

	* i386-opc.h (CpuTBM) New.
	(i386_cpu_flags): Add bit cputbm.

	* i386-opc.tbl: Add bextr, blcfill, blci, blcic, blcmsk,
	blcs, blsfill, blsic, t1mskc, and tzmsk.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Regenerated

gas/testsuite

2011-01-17  Quentin Neill  <quentin.neill@@amd.com>

	* gas/i386/tbm.s: New.
	* gas/i386/tbm.d: New.
	* gas/i386/tbm-intel.d: New.
	* gas/i386/x86-64-tbm.s: New.
	* gas/i386/x86-64-tbm.d: New.
	* gas/i386/x86-64-tbm-intel.d: New.
	* gas/i386/arch-10.d: Add tbm flag and TBM instruction pattern.
	* gas/i386/arch-10.s: Add a TBM instruction.
	* gas/i386/arch-10-1.l: Add TBM instruction pattern.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/x86-64-arch-2.s: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.
@
text
@d2374 4
d2379 1
@


1.459
log
@Disallow 64bit relocations in x32 mode.

gas/

2011-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (disallow_64bit_disp): Renamed to ...
	(disallow_64bit_reloc): This.
	(md_assemble): Don't check movabs for x32 mode here.
	(i386_target_format): Updated.
	(tc_gen_reloc): Check if 64bit relocations are allowed.

gas/testsuite/

2011-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/immed64.s: New.
	* gas/i386/ilp32/reloc64.s: Likewise.
	* gas/i386/ilp32/x86-64-pcrel.s: Likewise.

	* gas/i386/ilp32/inval.s: Add more tests.

	* gas/i386/ilp32/immed64.d: Updated.
	* gas/i386/ilp32/inval.l: Likewise.
	* gas/i386/ilp32/reloc64.d: Likewise.
	* gas/i386/ilp32/x86-64-pcrel.d: Likewise.
@
text
@d736 2
@


1.458
log
@Don't allow movabs with relocation in x32 mode.

gas/

2011-01-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (disallow_64bit_disp): New.
	(x86_elf_abi): Replace X86_64_LP64_ABI/X86_64_ILP32_ABI with
	X86_64_ABI/X86_64_X32_ABI.
	(md_assemble): Don't allow movabs with relocation in x32 mode.
	(i386_target_format): Updated.

gas/testsuite/

2011-01-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/ilp32.exp: Run inval.

	* gas/i386/ilp32/inval.l: New.
	* gas/i386/ilp32/inval.s: Likewise.
	* gas/i386/ilp32/x86-64.s: Likewise.

	* gas/i386/ilp32/x86-64.d: Don't use ../x86_64.s.  Updated.
@
text
@d392 1
a392 1
static unsigned int disallow_64bit_disp;
d3009 4
a3012 15
      && !i.disp32_encoding)
    {
      if (flag_code == CODE_64BIT)
	{
	  if (strcmp (mnemonic, "movabs") == 0)
	    {
	      if (disallow_64bit_disp)
		as_bad (_("'movabs' isn't supported in x32 mode"));
	    }
	  else
	    optimize_disp ();
	}
      else
	optimize_disp ();
    }
d8629 1
a8629 1
	    disallow_64bit_disp = 1;
d8931 21
@


1.457
log
@Rename --n32 to --x32.

gas/

2011-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (OPTION_N32): Renamed to ...
	(OPTION_X32): This.
	(md_longopts): Replace n32 with x32.
	(md_parse_option): Updated.
	(md_show_usage): Likewise.

	* doc/c-i386.texi: Replace n32 with x32.

gas/testsuite/

2011-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/cfi/ilp32.exp: Replace --n32 with --x32.
	* gas/i386/ilp32/elf/ilp32.exp: Likewise.
	* gas/i386/ilp32/ilp32.exp: Likewise.
	* gas/i386/ilp32/lns/ilp32.exp: Likewise.

ld/testsuite/

2011-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/ilp32-1.d: Replace --n32 with --x32.
	* ld-x86-64/ilp32-2.d: Likewise.
	* ld-x86-64/ilp32-3.d: Likewise.
	* ld-x86-64/ilp32-4.d: Likewise.
	* ld-x86-64/ilp32-5.d: Likewise.
	* ld-x86-64/x86-64.exp: Likewise.
@
text
@d392 1
d403 2
a404 2
  X86_64_LP64_ABI,
  X86_64_ILP32_ABI
d3009 15
a3023 4
      && !i.disp32_encoding
      && (flag_code != CODE_64BIT
	  || strcmp (mnemonic, "movabs") != 0))
    optimize_disp ();
d8590 1
a8590 1
	x86_elf_abi = X86_64_LP64_ABI;
d8592 1
a8592 1
	x86_elf_abi = X86_64_ILP32_ABI;
d8632 1
a8632 1
	  case X86_64_LP64_ABI:
d8637 1
a8637 1
	  case X86_64_ILP32_ABI:
d8640 1
d8646 1
a8646 1
	    if (x86_elf_abi != X86_64_LP64_ABI)
@


1.456
log
@* config/tc-i386.c (x86_elf_abi): Only define for targets that use
	it.
@
text
@d8155 1
a8155 1
#define OPTION_N32 (OPTION_MD_BASE + 13)
d8165 1
a8165 1
  {"n32", no_argument, NULL, OPTION_N32},
d8242 1
a8242 1
    case OPTION_N32:
d8526 1
a8526 1
  --32/--64/--n32         generate 32bit/64bit/n32bit code\n"));
@


1.455
log
@Add docs and arch tests to BMI.

gas/
2011-01-07  Quentin Neill  <quentin.neill@@amd.com>

	* config/tc-i386.c (cpu_arch): Add CPU_BMI_FLAGS.

	* doc/c-i386.texi (i386-BMI): New section.

gas/testsuite/
2011-01-07  Quentin Neill  <quentin.neill@@amd.com>

	* gas/i386/arch-10.s: Add a BMI instruction.
	* gas/i386/x86-64-arch-2.s: Likewise.
	* gas/i386/arch-10.d: Add bmi flag and BMI instruction pattern.
	* gas/i386/x86-64-arch-2.d: Likewise.
	* gas/i386/arch-10-1.l: Add BMI instruction pattern.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
@
text
@d394 4
d407 1
@


1.454
log
@Implement BMI instructions.
@
text
@d728 2
@


1.453
log
@Add x86-64 ILP32 support.

bfd/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* archures.c (bfd_mach_x64_32): New.
	(bfd_mach_x64_32_intel_syntax): Likewise.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf32_x86_64_vec for
	i[3-7]86-*-linux-*.
	(targ_selvecs): Add bfd_elf32_x86_64_vec for x86_64-*-linux-*.

	* configure.in: Support bfd_elf32_x86_64_vec.
	* configure: Regenerated.

	* cpu-i386.c (bfd_x64_32_arch_intel_syntax): New.
	(bfd_x64_32_arch): Likewise.

	* elf-bfd.h (elf_append_rela): New prototype.
	(elf_append_rel): Likewise.
	(elf64_r_info): Likewise.
	(elf32_r_info): Likewise.
	(elf64_r_sym): Likewise.
	(elf32_r_sym): Likewise.

	* elf64-x86-64.c (ABI_64_P): New.
	(elf_x86_64_info_to_howto): Replace ELF64_R_TYPE with
	ELF32_R_TYPE.  Replace ELF64_ST_TYPE with ELF_ST_TYPE.
	(elf_x86_64_check_tls_transition):Likewise.
	(elf_x86_64_check_relocs): Likewise.
	(elf_x86_64_gc_mark_hook):Likewise.
	(elf_x86_64_gc_sweep_hook): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_reloc_type_class): Likewise.
	(ELF_DYNAMIC_INTERPRETER): Renamed to ...
	(ELF64_DYNAMIC_INTERPRETER): This.
	(ELF32_DYNAMIC_INTERPRETER): New.
	(elf_x86_64_link_hash_table): Add r_info, r_sym, swap_reloca_out,
	dynamic_interpreter and dynamic_interpreter_size.
	(elf_x86_64_get_local_sym_hash): Replace ELF64_R_SYM with
	htab->r_sym.  Replace ELF64_R_INFO with htab->r_info.
	(elf_x86_64_get_local_sym_hash): Likewise.
	(elf_x86_64_check_tls_transition):Likewise.
	(elf_x86_64_check_relocs): Likewise.
	(elf_x86_64_gc_mark_hook):Likewise.
	(elf_x86_64_gc_sweep_hook): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_finish_dynamic_symbol): Likewise.
	(elf_x86_64_finish_local_dynamic_symbol): Likewise.
	(elf_x86_64_link_hash_table_create): Initialize r_info, r_sym,
	swap_reloca_out, dynamic_interpreter and dynamic_interpreter_size.
	(elf_x86_64_check_relocs): Check ABI_64_P when requesting for
	PIC.
	(elf_x86_64_relocate_section): Likewise.
	(elf64_x86_64_adjust_dynamic_symbol): Replace sizeof
	(Elf64_External_Rela) with bed->s->sizeof_rela.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_finish_dynamic_symbol): Likewise.
	(elf64_x86_64_append_rela): Removed.
	(elf32_x86_64_elf_object_p): New.
	Add bfd_elf32_x86_64_vec.

	* elf64-x86-64.c (elf64_x86_64_xxx): Renamed to ...
	(elf_x86_64_xxx): This.

	* elflink.c (bfd_elf_final_link): Check ELF file class on error.
	(elf_append_rela): New.
	(elf_append_rel): Likewise.
	(elf64_r_info): Likewise.
	(elf32_r_info): Likewise.
	(elf64_r_sym): Likewise.
	(elf32_r_sym): Likewise.

	* targets.c (bfd_elf32_x86_64_vec): New.
	(_bfd_target_vector): Add bfd_elf32_x86_64_vec.

gas/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (x86_elf_abi): New.
	(i386_mach): Return bfd_mach_x64_32 for ILP32.
	(OPTION_N32): Likewise.
	(md_longopts): Add "n32" for ELF.
	(md_parse_option): Handle OPTION_N32.
	(md_show_usage): Add --n32.
	(i386_target_format): Update and check x86_elf_abi.

	* config/tc-i386.h (ELF_TARGET_FORMAT32): New.

	* doc/as.texinfo: Document --n32.
	* doc/c-i386.texi: Likewise.

gas/testsuite/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/lns/ilp32.exp: New.
	* gas/i386/ilp32/lns/lns-common-1.d: Likewise.
	* gas/i386/ilp32/lns/lns-duplicate.d: Likewise.

	* gas/i386/ilp32/cfi/cfi-common-1.d: New.
	* gas/i386/ilp32/cfi/cfi-common-2.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-3.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-4.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-5.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-6.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-7.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-x86_64.d: Likewise.
	* gas/i386/ilp32/cfi/ilp32.exp: Likewise.
	* gas/i386/ilp32/elf/ehopt0.d: Likewise.
	* gas/i386/ilp32/elf/equ-reloc.d: Likewise.
	* gas/i386/ilp32/elf/file.d: Likewise.
	* gas/i386/ilp32/elf/group0a.d: Likewise.
	* gas/i386/ilp32/elf/group0b.d: Likewise.
	* gas/i386/ilp32/elf/group1a.d: Likewise.
	* gas/i386/ilp32/elf/group1b.d: Likewise.
	* gas/i386/ilp32/elf/ifunc-1.d: Likewise.
	* gas/i386/ilp32/elf/ilp32.exp: Likewise.
	* gas/i386/ilp32/elf/redef.d: Likewise.
	* gas/i386/ilp32/elf/section0.d: Likewise.
	* gas/i386/ilp32/elf/section1.d: Likewise.
	* gas/i386/ilp32/elf/section3.d: Likewise.
	* gas/i386/ilp32/elf/section4.d: Likewise.
	* gas/i386/ilp32/elf/section6.d: Likewise.
	* gas/i386/ilp32/elf/section7.d: Likewise.
	* gas/i386/ilp32/elf/struct.d: Likewise.
	* gas/i386/ilp32/elf/symtab.d: Likewise.
	* gas/i386/ilp32/elf/symver.d: Likewise.

	* gas/i386/ilp32/ilp32.exp: New.
	* gas/i386/ilp32/immed64.d: Likewise.
	* gas/i386/ilp32/mixed-mode-reloc64.d: Likewise.
	* gas/i386/ilp32/reloc64.d: Likewise.
	* gas/i386/ilp32/rex.d: Likewise.
	* gas/i386/ilp32/rexw.d: Likewise.
	* gas/i386/ilp32/svme64.d: Likewise.
	* gas/i386/ilp32/x86-64-addr32.d: Likewise.
	* gas/i386/ilp32/x86-64-addr32-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-aes.d: Likewise.
	* gas/i386/ilp32/x86-64-aes-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-amdfam10.d: Likewise.
	* gas/i386/ilp32/x86-64-arch-1.d: Likewise.
	* gas/i386/ilp32/x86-64-arch-2.d: Likewise.
	* gas/i386/ilp32/x86-64-avx.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-swap.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-swap-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-branch.d: Likewise.
	* gas/i386/ilp32/x86-64-cbw.d: Likewise.
	* gas/i386/ilp32/x86-64-cbw-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-clmul.d: Likewise.
	* gas/i386/ilp32/x86-64-clmul-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-crc32.d: Likewise.
	* gas/i386/ilp32/x86-64-crc32-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-crx.d: Likewise.
	* gas/i386/ilp32/x86-64-crx-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64.d: Likewise.
	* gas/i386/ilp32/x86-64-disp.d: Likewise.
	* gas/i386/ilp32/x86-64-disp-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-drx.d: Likewise.
	* gas/i386/ilp32/x86-64-drx-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-ept.d: Likewise.
	* gas/i386/ilp32/x86-64-ept-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-fma4.d: Likewise.
	* gas/i386/ilp32/x86-64-fma.d: Likewise.
	* gas/i386/ilp32/x86-64-fma-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-gidt.d: Likewise.
	* gas/i386/ilp32/x86-64-ifunc.d: Likewise.
	* gas/i386/ilp32/x86-64-intel64.d: Likewise.
	* gas/i386/ilp32/x86-64-io.d: Likewise.
	* gas/i386/ilp32/x86-64-io-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-io-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-localpic.d: Likewise.
	* gas/i386/ilp32/x86-64-mem.d: Likewise.
	* gas/i386/ilp32/x86-64-mem-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-movbe.d: Likewise.
	* gas/i386/ilp32/x86-64-movbe-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-core2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-nocona.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-pentium.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-3.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4-core2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-5.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-5-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode-inval.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode-inval-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-opts.d: Likewise.
	* gas/i386/ilp32/x86-64-opts-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-pcrel.d: Likewise.
	* gas/i386/ilp32/x86-64-reg.d: Likewise.
	* gas/i386/ilp32/x86-64-reg-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-rep.d: Likewise.
	* gas/i386/ilp32/x86-64-rep-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-rip.d: Likewise.
	* gas/i386/ilp32/x86-64-rip-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sib.d: Likewise.
	* gas/i386/ilp32/x86-64-sib-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-simd.d: Likewise.
	* gas/i386/ilp32/x86-64-simd-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-simd-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx-opts.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx-opts-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse3.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_1.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_1-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_2.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_2-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check-none.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check-warn.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-noavx.d: Likewise.
	* gas/i386/ilp32/x86-64-ssse3.d: Likewise.
	* gas/i386/ilp32/x86-64-stack.d: Likewise.
	* gas/i386/ilp32/x86-64-stack-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-stack-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-unwind.d: Likewise.
	* gas/i386/ilp32/x86-64-vmx.d: Likewise.
	* gas/i386/ilp32/x86-64-xsave.d: Likewise.
	* gas/i386/ilp32/x86-64-xsave-intel.d: Likewise.

ld/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf32_x86_64.sh: New.

	* configure.tgt (targ64_extra_emuls): Add elf32_x86_64 for
	i[3-7]86-*-linux-*.
	(targ_extra_libpath): Likewise.
	(targ_extra_emuls): Add elf32_x86_64 for x86_64-*-linux-*.
	(targ_extra_libpath): Likewise.

	* Makefile.am (ALL_64_EMULATION_SOURCES): Add eelf32_x86_64.c.
	(eelf32_x86_64.c): New.
	* Makefile.in: Regenerated.

opcodes/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (print_insn): Support bfd_mach_x64_32 and
	bfd_mach_x64_32_intel_syntax.
@
text
@d5313 20
a5332 4
		 source operand must be XMM or YMM register. It is
		 encoded in VEX prefix.  We need to clear RegMem bit
		 before calling operand_type_equal.  */
	      i386_operand_type op = i.tm.operand_types[dest];
d5335 3
a5337 1
		  || (!operand_type_equal (&op, &regxmm)
d5340 1
a5340 1
	      i.vex.register_specifier = i.op[dest].regs;
d5668 15
a5682 2
		  vex_reg = op + 1;
		  gas_assert (vex_reg < i.operands);
d5687 1
a5687 2
	      /* For instructions with VexNDD, there should be
		 no memory operand and the register destination
d5689 12
a5700 3
	      gas_assert (i.mem_operands == 0
			  && (op + 2) == i.operands);
	      vex_reg = op + 1;
d5707 1
a5707 1
	      gas_assert (i.reg_operands == 2);
d5709 4
a5712 4
	      if (!operand_type_equal (&i.tm.operand_types[vex_reg],
				       &regxmm)
		  && !operand_type_equal (&i.tm.operand_types[vex_reg],
					  &regymm))
@


1.452
log
@Add CheckRegSize to instructions which require register size check.

gas/

2010-10-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Check checkregsize
	instead of w for register size check.

gas/testsuite/

2010-10-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run inval-reg.

	* gas/i386/inval-reg.l: New.
	* gas/i386/inval-reg.s: Likewise.

opcodes/

2010-10-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Add CheckRegSize.

	* i386-opc.h (CheckRegSize): New.
	(i386_opcode_modifier): Add checkregsize.

	* i386-opc.tbl: Add CheckRegSize to instructions which
	require register size check.
	* i386-tbl.h: Regenerated.
@
text
@d394 10
d2220 1
a2220 1
  if (!strcmp (default_arch, "x86_64"))
d2224 2
a2225 1
	  if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d2229 2
d2232 1
a2232 1
	return bfd_mach_x86_64;
d8109 1
d8118 3
d8195 22
d8480 1
a8480 1
  --32/--64               generate 32bit/64bit code\n"));
d8528 8
a8535 2
  if (!strcmp (default_arch, "x86_64"))
    update_code_flag (CODE_64BIT, 1);
d8567 3
a8569 1
	if (flag_code == CODE_64BIT)
d8571 5
d8577 3
d8581 3
d8587 1
a8587 1
	    if (flag_code != CODE_64BIT)
d8592 1
a8592 2
	  return (flag_code == CODE_64BIT
		  ? ELF_TARGET_FORMAT64 : ELF_TARGET_FORMAT);
@


1.452.2.1
log
@Backport of:
Changes by:	hjl@@sourceware.org	2011-02-08 20:21:26

Modified files:
	gas            : ChangeLog
	gas/config     : tc-i386.c
	gas/testsuite  : ChangeLog
	gas/testsuite/gas/i386: nops-1-i686.d nops-3-i686.d
	                        nops-4-i686.d

Log message:
	Use f32_patt in i386_align_code  when tuning for i686.

	gas/

	2011-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/6957
	* config/tc-i386.c (i386_align_code): Use f32_patt when tuning
	for i686.

	gas/testsuite/

	2011-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/6957
	* gas/i386/nops-1-i686.d: Updated.
	* gas/i386/nops-3-i686.d: Likewise.
	* gas/i386/nops-4-i686.d: Likewise.
@
text
@d1043 1
a1062 1
	    case PROCESSOR_PENTIUMPRO:
@


1.452.2.2
log
@Backport.

Modified files:
	gas            : ChangeLog configure.tgt
	gas/config     : tc-i386.c
	bfd            : ChangeLog config.bfd configure configure.in
	                 libbfd.h
	ld             : ChangeLog configure.host configure.tgt ldlex.l
Added files:
	gas/config     : te-dragonfly.h

Log message:
	Add support for DragonFlyBSD target.
@
text
@a305 1
	 && !defined (TE_DragonFly)			\
@


1.451
log
@Add .d32 encoding suffix.

gas/

2010-10-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (_i386_insn): Add disp32_encoding.
	(md_assemble): Don't call optimize_disp if disp32_encoding is
	set.
	(parse_insn): Support .d32 to force 32bit displacement.
	(output_branch): Use BIG if disp32_encoding is set.

	* doc/c-i386.texi: Document .d32 encoding suffix.

gas/testsuite/

2010-10-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/disp32.d: New.
	* gas/i386/disp32.s: Likewise.
	* gas/i386/x86-64-disp32.d: Likewise.
	* gas/i386/x86-64-disp32.s: Likewise.

	* gas/i386/i386.exp: Run disp32 and x86-64-disp32.
@
text
@d3999 2
a4000 3
      /* We check register size only if size of operands can be
	 encoded the canonical way.  */
      check_register = t->opcode_modifier.w;
@


1.450
log
@	PR gas/12011
	* config/obj-elf.c (obj_elf_parse_section_letters): Correct test
	for error return from md_elf_section_letter.
	* config/tc-alpha.c (alpha_elf_section_letter): Correct error message.
	* config/tc-i386.c (x86_64_section_letter): Likewise.
	* config/tc-ia64.c (ia64_elf_section_letter): Likewise.
	* config/tc-mep.c (mep_elf_section_letter): Likewise.
	* gas/elf/bad-section-flag.d, * gas/elf/bad-section-flag.err,
	* gas/elf/bad-section-flag.s: New test.
	* gas/elf/elf.exp: Run it.
@
text
@d280 3
d2988 1
d3263 2
a3264 1
      /* Check if we should swap operand in encoding.  */
d3267 5
d5704 1
d5711 2
a5712 3
  code16 = 0;
  if (flag_code == CODE_16BIT)
    code16 = CODE16;
d5755 1
a5755 1
    subtype = ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL);
d5757 1
a5757 1
    subtype = ENCODE_RELAX_STATE (COND_JUMP, SMALL);
d5759 1
a5759 1
    subtype = ENCODE_RELAX_STATE (COND_JUMP86, SMALL);
@


1.449
log
@Check VEXW1 for 2-byte VEX prefix.

2010-09-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_vex_prefix): Check VEXW1 for 2-byte
	VEX prefix.
@
text
@d8952 1
a8952 1
      *ptr_msg = _("Bad .section directive: want a,l,w,x,M,S,G,T in string");
d8955 1
a8955 1
    *ptr_msg = _("Bad .section directive: want a,w,x,M,S,G,T in string");
@


1.448
log
@Check flag_code instead of use_rela_relocations for 64bit.

gas/

2010-09-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11974
	* config/tc-i386.c (i386_finalize_immediate): Check flag_code
	instead of use_rela_relocations for 64bit.

gas/testsuite/

2010-09-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11974
	* gas/i386/immed64.s: Add more movabs tests.
	* gas/i386/immed64.d: Updated.
@
text
@d2806 1
@


1.447
log
@Fix a typo in comments.

2010-08-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (VEX_check_operands): Fix a typo in comments.
@
text
@d6629 2
a6630 2
      /* If BFD64, sign extend val.  */
      if (!use_rela_relocations
@


1.446
log
@Check i.imm_operands VEXXDS.

2010-08-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Check i.imm_operands
	instead of VEXXDS.
@
text
@d3792 1
a3792 1
/* Check if operands are valid for the instrucrtion.  Update VEX
@


1.445
log
@Re-indent config/tc-i386.c.

2010-08-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (set_cpu_arch): Re-indent.
	(md_parse_option): Likewise.
@
text
@d5267 3
a5269 1
	  if (i.tm.opcode_modifier.vexvvvv == VEXXDS)
a5275 2
	  else
	    source = 2;
@


1.444
log
@Don't generate multi-byte NOPs for i686.

gas/

2010-08-06  Quentin Neill <quentin.neill@@amd.com>

	* config/tc-i386.c (arch_entry): Add negated bit to
	  disambiguate flag names starting with "no".
	  (cpu_arch): Add negated bit definitions.  Add
	  ".nop" CPU extension.
	  (i386_align_code): Use new .cpunop bit to decide
	  when to generate alignment using nops.
	  (set_cpu_arch): Use negated bit instead to decide
	  when to use cpu_flags or vs. cpu_flags_and_not.
	  (md_parse_option): Likewise.

gas/testsuite/

2010-08-06  Quentin Neill <quentin.neill@@amd.com>

	* gas/i386/arch-10-1.l: Add nopl instruction.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/arch-10.s: Likewise.
	* gas/i386/arch-10.d: Add nopl instruction, and +nopl extension
	flag to as flags.
	* gas/i386/nops-5-i686.d: Change alignment code generated for
	-mtune=i686.
	* gas/i386/nops-5.d: Change alignment code generated for
	.arch i686.
	* gas/i386/x86-64-nops-5-k8.d: Likewise.
	* gas/i386/x86-64-nops-5.d: Likewise.

opcodes/

2010-08-06  Quentin Neill <quentin.neill@@amd.com>

	* i386-gen.c (cpu_flag_init): Define CpuNop extension flag, add
	to processor flags for PENTIUMPRO processors and later.
	* i386-opc.h (enum): Add CpuNop.
	(i386_cpu_flags): Add cpunop bit.
	* i386-opc.tbl: Change nop cpu_flags.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d2142 1
a2142 1
				      cpu_arch[j].flags);
d8224 1
a8224 1
                  if (!cpu_arch[j].negated)
d8229 1
a8229 1
					  cpu_arch[j].flags);
@


1.443
log
@Move the first i.error out of the loop.

2010-08-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Move the first i.error
	out of the loop.
@
text
@d135 1
d570 1
a570 1
    CPU_GENERIC32_FLAGS, 0 },
d572 1
a572 1
    CPU_GENERIC64_FLAGS, 0 },
d574 1
a574 1
    CPU_NONE_FLAGS, 0 },
d576 1
a576 1
    CPU_I186_FLAGS, 0 },
d578 1
a578 1
    CPU_I286_FLAGS, 0 },
d580 1
a580 1
    CPU_I386_FLAGS, 0 },
d582 1
a582 1
    CPU_I486_FLAGS, 0 },
d584 1
a584 1
    CPU_I586_FLAGS, 0 },
d586 1
a586 1
    CPU_I686_FLAGS, 0 },
d588 1
a588 1
    CPU_I586_FLAGS, 0 },
d590 1
a590 1
    CPU_I686_FLAGS, 0 },
d592 1
a592 1
    CPU_P2_FLAGS, 0 },
d594 1
a594 1
    CPU_P3_FLAGS, 0 },
d596 1
a596 1
    CPU_P4_FLAGS, 0 },
d598 1
a598 1
    CPU_CORE_FLAGS, 0 },
d600 1
a600 1
    CPU_NOCONA_FLAGS, 0 },
d602 1
a602 1
    CPU_CORE_FLAGS, 1 },
d604 1
a604 1
    CPU_CORE_FLAGS, 0 },
d606 1
a606 1
    CPU_CORE2_FLAGS, 1 },
d608 1
a608 1
    CPU_CORE2_FLAGS, 0 },
d610 1
a610 1
    CPU_COREI7_FLAGS, 0 },
d612 1
a612 1
    CPU_L1OM_FLAGS, 0 },
d614 1
a614 1
    CPU_K6_FLAGS, 0 },
d616 1
a616 1
    CPU_K6_2_FLAGS, 0 },
d618 1
a618 1
    CPU_ATHLON_FLAGS, 0 },
d620 1
a620 1
    CPU_K8_FLAGS, 1 },
d622 1
a622 1
    CPU_K8_FLAGS, 0 },
d624 1
a624 1
    CPU_K8_FLAGS, 0 },
d626 1
a626 1
    CPU_AMDFAM10_FLAGS, 0 },
d628 1
a628 1
    CPU_BDVER1_FLAGS, 0 },
d630 1
a630 1
    CPU_8087_FLAGS, 0 },
d632 1
a632 1
    CPU_287_FLAGS, 0 },
d634 1
a634 1
    CPU_387_FLAGS, 0 },
d636 1
a636 1
    CPU_ANY87_FLAGS, 0 },
d638 1
a638 1
    CPU_MMX_FLAGS, 0 },
d640 1
a640 1
    CPU_3DNOWA_FLAGS, 0 },
d642 1
a642 1
    CPU_SSE_FLAGS, 0 },
d644 1
a644 1
    CPU_SSE2_FLAGS, 0 },
d646 1
a646 1
    CPU_SSE3_FLAGS, 0 },
d648 1
a648 1
    CPU_SSSE3_FLAGS, 0 },
d650 1
a650 1
    CPU_SSE4_1_FLAGS, 0 },
d652 1
a652 1
    CPU_SSE4_2_FLAGS, 0 },
d654 1
a654 1
    CPU_SSE4_2_FLAGS, 0 },
d656 1
a656 1
    CPU_ANY_SSE_FLAGS, 0 },
d658 1
a658 1
    CPU_AVX_FLAGS, 0 },
d660 1
a660 1
    CPU_ANY_AVX_FLAGS, 0 },
d662 1
a662 1
    CPU_VMX_FLAGS, 0 },
d664 1
a664 1
    CPU_SMX_FLAGS, 0 },
d666 1
a666 1
    CPU_XSAVE_FLAGS, 0 },
d668 1
a668 1
    CPU_XSAVEOPT_FLAGS, 0 },
d670 1
a670 1
    CPU_AES_FLAGS, 0 },
d672 1
a672 1
    CPU_PCLMUL_FLAGS, 0 },
d674 1
a674 1
    CPU_PCLMUL_FLAGS, 1 },
d676 1
a676 1
    CPU_FSGSBASE_FLAGS, 0 },
d678 1
a678 1
    CPU_RDRND_FLAGS, 0 },
d680 1
a680 1
    CPU_F16C_FLAGS, 0 },
d682 1
a682 1
    CPU_FMA_FLAGS, 0 },
d684 1
a684 1
    CPU_FMA4_FLAGS, 0 },
d686 1
a686 1
    CPU_XOP_FLAGS, 0 },
d688 1
a688 1
    CPU_LWP_FLAGS, 0 },
d690 1
a690 1
    CPU_MOVBE_FLAGS, 0 },
d692 1
a692 1
    CPU_EPT_FLAGS, 0 },
d694 3
a696 1
    CPU_CLFLUSH_FLAGS, 0 },
d698 1
a698 1
    CPU_SYSCALL_FLAGS, 0 },
d700 1
a700 1
    CPU_RDTSCP_FLAGS, 0 },
d702 1
a702 1
    CPU_3DNOW_FLAGS, 0 },
d704 1
a704 1
    CPU_3DNOWA_FLAGS, 0 },
d706 1
a706 1
    CPU_PADLOCK_FLAGS, 0 },
d708 1
a708 1
    CPU_SVME_FLAGS, 1 },
d710 1
a710 1
    CPU_SVME_FLAGS, 0 },
d712 1
a712 1
    CPU_SSE4A_FLAGS, 0 },
d714 1
a714 1
    CPU_ABM_FLAGS, 0 },
d1004 1
a1004 1
     cpu_arch_isa_flags has Cpu686. Otherwise, f32_patt will
d1034 2
a1035 2
		 optimize for Cpu686.  */
	      if (fragP->tc_frag_data.isa_flags.bitfield.cpui686)
d1085 2
a1086 2
		 for Cpu686.  */
	      if (fragP->tc_frag_data.isa_flags.bitfield.cpui686)
d1098 1
a1098 1
	      if (fragP->tc_frag_data.isa_flags.bitfield.cpui686)
d2137 1
a2137 1
	      if (strncmp (string + 1, "no", 2))
d2142 1
a2142 1
					   cpu_arch[j].flags);
d8224 1
a8224 1
		  if (strncmp (arch, "no", 2))
d8229 1
a8229 1
					       cpu_arch[j].flags);
@


1.442
log
@Don't call section_symbol() with expr_section.

gas/

2010-07-03  Jan Beulich  <jbeulich@@novell.com>

	PR gas/11732
	* config/tc-i386.c (i386_finalize_displacement): Don't call
	section_symbol() with expr_section.

gas/testsuite/

2010-07-03  Jan Beulich  <jbeulich@@novell.com>

	PR gas/11732
	* gas/i386/i386.exp: Run new tests.
	* gas/i386/intel-got{32,64}.{s,d}: New.
@
text
@d3851 3
a3857 2
      /* Must have right number of operands.  */
      i.error = number_of_operands_mismatch;
@


1.441
log
@Support AVX Programming Reference (June, 2010)

gas/

2010-07-01  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (June, 2010)
	* config/tc-i386.c (cpu_arch): Add .xsaveopt, .fsgsbase, .rdrnd
	and .f16c.

	* doc/c-i386.texi: Document xsaveopt, fsgsbase, rdrnd and f16c.

gas/testsuite/

2010-07-01  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (June, 2010)
	* gas/i386/arch-10.s: Add xsaveopt.
	* gas/i386/x86-64-arch-2.s: Likwise.

	* gas/i386/arch-10.d: Updated.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.

	* gas/i386/f16c-intel.d: New.
	* gas/i386/f16c.d: Likewise.
	* gas/i386/f16c.s: Likewise.
	* gas/i386/fsgs-intel.d: Likewise.
	* gas/i386/fsgs.d: Likewise.
	* gas/i386/fsgs.s: Likewise.
	* gas/i386/rdrnd-intel.d: Likewise.
	* gas/i386/rdrnd.d: Likewise.
	* gas/i386/rdrnd.s: Likewise.
	* gas/i386/x86-64-f16c-intel.d: Likewise.
	* gas/i386/x86-64-f16c.d: Likewise.
	* gas/i386/x86-64-f16c.s: Likewise.
	* gas/i386/x86-64-fsgs-intel.d: Likewise.
	* gas/i386/x86-64-fsgs.d: Likewise.
	* gas/i386/x86-64-fsgs.s: Likewise.
	* gas/i386/x86-64-rdrnd-intel.d: Likewise.
	* gas/i386/x86-64-rdrnd.d: Likewise.
	* gas/i386/x86-64-rdrnd.s: Likewise.

	* gas/i386/i386.exp: Run f16c, f16c-intel, fsgs, fsgs-intel,
	rdrnd, rdrnd-intel, x86-64-f16c, x86-64-f16c-intel, x86-64-fsgs,
	x86-64-fsgs-intel, x86-64-rdrnd, x86-64-rdrnd-intel.

	* gas/i386/x86-64-xsave.s: Add tests for xsaveopt64.

	* gas/i386/x86-64-xsave-intel.d: Updated.
	* gas/i386/x86-64-xsave.d: Likewise.

opcodes/

2010-07-01  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (June, 2010)
	* i386-dis.c (PREFIX_0FAE_REG_0): New.
	(PREFIX_0FAE_REG_1): Likewise.
	(PREFIX_0FAE_REG_2): Likewise.
	(PREFIX_0FAE_REG_3): Likewise.
	(PREFIX_VEX_3813): Likewise.
	(PREFIX_VEX_3A1D): Likewise.
	(prefix_table): Add PREFIX_0FAE_REG_0, PREFIX_0FAE_REG_1,
	PREFIX_0FAE_REG_2, PREFIX_0FAE_REG_3, PREFIX_VEX_3813 and
	PREFIX_VEX_3A1D.
	(vex_table): Add PREFIX_VEX_3813 and PREFIX_VEX_3A1D.
	(mod_table): Add PREFIX_0FAE_REG_0, PREFIX_0FAE_REG_1,
	PREFIX_0FAE_REG_2, PREFIX_0FAE_REG_3 xsaveopt and rdrnd.

	* i386-gen.c (cpu_flag_init): Add CPU_XSAVEOPT_FLAGS,
	CPU_FSGSBASE_FLAGS, CPU_RDRND_FLAGS and CPU_F16C_FLAGS.
	(cpu_flags): Add CpuXsaveopt, CpuFSGSBase, CpuRdRnd and CpuF16C.

	* i386-opc.h (CpuXsaveopt): New.
	(CpuFSGSBase):Likewise.
	(CpuRdRnd): Likewise.
	(CpuF16C): Likewise.
	(i386_cpu_flags): Add cpuxsaveopt, cpufsgsbase, cpurdrnd and
	cpuf16c.

	* i386-opc.tbl: Add xsaveopt, rdfsbase, rdgsbase, rdrnd,
	wrfsbase, wrgsbase, vcvtph2ps and vcvtps2ph.
@
text
@d6881 2
a6882 1
	  && S_GET_SEGMENT (exp->X_add_symbol) != undefined_section)
@


1.440
log
@gas/
2010-06-11  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (md_parse_option): Ignore impossible processor
	types.
	(show_arch): New parameter 'check'.
	(md_show_usage): Adjust calls to show_arch().
@
text
@d666 2
d674 6
@


1.439
log
@Stop if -march=XXX is invalid.

2010-06-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (update_code_flag): New.
	(set_code_flag): Use it.
	(i386_target_format): Replace set_code_flag with update_code_flag.
@
text
@d8190 3
d8324 1
a8324 1
show_arch (FILE *stream, int ext)
d8361 5
d8430 1
a8430 1
  show_arch (stream, 0);
d8433 1
a8433 1
  show_arch (stream, 1);
d8436 1
a8436 1
  show_arch (stream, 0);
@


1.438
log
@gas/
2010-06-10  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (cpu_arch): Add comment.
	(i386_target_format): Set cpu_arch_isa_flags and cpu_arch_tune_flags
	from the generic entries of cpu_arch[].
@
text
@d138 1
d1926 1
a1926 1
set_code_flag (int value)
d1928 2
d1943 6
a1948 1
      as_bad (_("64bit mode not supported on this CPU."));
d1952 6
a1957 1
      as_bad (_("32bit mode not supported on this CPU."));
d1963 6
d8459 1
a8459 1
    set_code_flag (CODE_64BIT);
d8461 1
a8461 1
    set_code_flag (CODE_32BIT);
@


1.437
log
@2010-06-08  Quentin Neill  <quentin.neill@@amd.com>

	* config/tc-i386.c (pi): Rename local loop counter
	variable i that shadows global static i386_insn i
	when DEBUG386 is defined.
	(pte) Ditto.
@
text
@d565 2
d8440 1
a8440 30
    {
      set_code_flag (CODE_64BIT);
      if (cpu_flags_all_zero (&cpu_arch_isa_flags))
	{
	  cpu_arch_isa_flags.bitfield.cpui186 = 1;
	  cpu_arch_isa_flags.bitfield.cpui286 = 1;
	  cpu_arch_isa_flags.bitfield.cpui386 = 1;
	  cpu_arch_isa_flags.bitfield.cpui486 = 1;
	  cpu_arch_isa_flags.bitfield.cpui586 = 1;
	  cpu_arch_isa_flags.bitfield.cpui686 = 1;
	  cpu_arch_isa_flags.bitfield.cpuclflush = 1;
	  cpu_arch_isa_flags.bitfield.cpummx= 1;
	  cpu_arch_isa_flags.bitfield.cpusse = 1;
	  cpu_arch_isa_flags.bitfield.cpusse2 = 1;
	  cpu_arch_isa_flags.bitfield.cpulm = 1;
	}
      if (cpu_flags_all_zero (&cpu_arch_tune_flags))
	{
	  cpu_arch_tune_flags.bitfield.cpui186 = 1;
	  cpu_arch_tune_flags.bitfield.cpui286 = 1;
	  cpu_arch_tune_flags.bitfield.cpui386 = 1;
	  cpu_arch_tune_flags.bitfield.cpui486 = 1;
	  cpu_arch_tune_flags.bitfield.cpui586 = 1;
	  cpu_arch_tune_flags.bitfield.cpui686 = 1;
	  cpu_arch_tune_flags.bitfield.cpuclflush = 1;
	  cpu_arch_tune_flags.bitfield.cpummx= 1;
	  cpu_arch_tune_flags.bitfield.cpusse = 1;
	  cpu_arch_tune_flags.bitfield.cpusse2 = 1;
	}
    }
d8442 1
a8442 15
    {
      set_code_flag (CODE_32BIT);
      if (cpu_flags_all_zero (&cpu_arch_isa_flags))
	{
	  cpu_arch_isa_flags.bitfield.cpui186 = 1;
	  cpu_arch_isa_flags.bitfield.cpui286 = 1;
	  cpu_arch_isa_flags.bitfield.cpui386 = 1;
	}
      if (cpu_flags_all_zero (&cpu_arch_tune_flags))
	{
	  cpu_arch_tune_flags.bitfield.cpui186 = 1;
	  cpu_arch_tune_flags.bitfield.cpui286 = 1;
	  cpu_arch_tune_flags.bitfield.cpui386 = 1;
	}
    }
d8445 6
@


1.436
log
@2010-06-02  Quentin Neill  <quentin.neill@@amd.com>

	* config/tc-i386.c (OPTION_MAVXSCALAR): Fix define.
@
text
@d2344 1
a2344 1
  unsigned int i;
d2361 1
a2361 1
  for (i = 0; i < x->operands; i++)
d2363 2
a2364 2
      fprintf (stdout, "    #%d:  ", i + 1);
      pt (x->types[i]);
d2366 17
a2382 17
      if (x->types[i].bitfield.reg8
	  || x->types[i].bitfield.reg16
	  || x->types[i].bitfield.reg32
	  || x->types[i].bitfield.reg64
	  || x->types[i].bitfield.regmmx
	  || x->types[i].bitfield.regxmm
	  || x->types[i].bitfield.regymm
	  || x->types[i].bitfield.sreg2
	  || x->types[i].bitfield.sreg3
	  || x->types[i].bitfield.control
	  || x->types[i].bitfield.debug
	  || x->types[i].bitfield.test)
	fprintf (stdout, "%s\n", x->op[i].regs->reg_name);
      if (operand_type_check (x->types[i], imm))
	pe (x->op[i].imms);
      if (operand_type_check (x->types[i], disp))
	pe (x->op[i].disps);
d2389 1
a2389 1
  unsigned int i;
d2399 1
a2399 1
  for (i = 0; i < t->operands; i++)
d2401 2
a2402 2
      fprintf (stdout, "    #%d type ", i + 1);
      pt (t->operand_types[i]);
@


1.435
log
@Remove i386_is_register.

2010-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_is_register): Removed.
	(x86_cons): Don't use i386_is_register.
	(parse_register): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	(i386_intel_operand): Likewise.
@
text
@d8051 1
a8051 1
#define OPTION_MAVXSCALAR (OPTION_MSSE_CHECK + 11)
@


1.434
log
@Don't use i386_is_register in tc_x86_parse_to_dw2regnum.

2010-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (tc_x86_parse_to_dw2regnum): Don't use
	i386_is_register.
@
text
@a3536 8
/* The X_md field is set to register number plus 1 to indicate register
   expression in Intel syntax.  */
static int
i386_is_register (const expressionS *e)
{
  return e->X_op == O_register || e->X_md;
}

d6481 1
a6481 1
	      || i386_is_register (exp)
d7960 1
a7960 1
	  know (i386_is_register (e));
@


1.433
log
@Remove is_intel_syntax from i386_is_register.

2010-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_is_register): Remove is_intel_syntax.
	(x86_cons): Updated.
	(parse_register): Likewise.
	(tc_x86_parse_to_dw2regnum): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	(i386_intel_operand): Likewise.
@
text
@d8875 1
a8875 1
  if (i386_is_register (exp) && exp->X_add_number >= 0)
@


1.432
log
@Properly handle ".equ symbol, reg + NUM" in x86 Intel syntax.

gas/

2010-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11509
	* config/tc-i386-intel.c (i386_intel_simplify_register): New.
	(i386_intel_simplify): Use i386_is_register and
	i386_intel_simplify_register. Set X_md for O_register and
	check X_md for O_constant.
	(i386_intel_operand): Use i386_is_register.

	* config/tc-i386.c (i386_is_register): New.
	(x86_cons): Initialize the X_md field.  Use i386_is_register.
	(parse_register): Use i386_is_register.
	(tc_x86_parse_to_dw2regnum): Likewise.

gas/testsuite/

2010-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11509
	* gas/i386/equ.s: Add tests for ".equ symbol, reg + NUM".
	* gas/i386/equ.d: Updated.
@
text
@d3537 2
d3540 1
a3540 1
i386_is_register (const expressionS *e, int is_intel_syntax)
d3542 1
a3542 4
  return (e->X_op == O_register
	  || (is_intel_syntax
	      && e->X_op == O_constant
	      && e->X_md));
d6489 1
a6489 1
	      || i386_is_register (exp, intel_syntax)
d7968 1
a7968 1
	  know (i386_is_register (e, intel_syntax));
d8875 1
a8875 1
  if (i386_is_register (exp, intel_syntax) && exp->X_add_number >= 0)
@


1.431
log
@Use STRING_COMMA_LEN to avoid strlen.

2010-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (lex_got): Use STRING_COMMA_LEN on gotrel.
@
text
@d3537 9
d6463 1
d6490 1
a6490 1
	      || exp->X_op == O_register
d7969 1
a7969 1
	  know (e->X_op == O_register);
d8876 1
a8876 1
  if (exp->X_op == O_register && exp->X_add_number >= 0)
@


1.430
log
@Replace oprand_size_mismatch with operand_size_mismatch.

2010-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_error): Replace oprand_size_mismatch
	with operand_size_mismatch.
	(operand_size_match): Updated.
	(match_template): Likewise.
@
text
@d6321 1
d6325 2
a6326 2
    { "PLTOFF",   { _dummy_first_bfd_reloc_code_real,
		    BFD_RELOC_X86_64_PLTOFF64 },
d6328 2
a6329 2
    { "PLT",      { BFD_RELOC_386_PLT32,
		    BFD_RELOC_X86_64_PLT32    },
d6331 2
a6332 2
    { "GOTPLT",   { _dummy_first_bfd_reloc_code_real,
		    BFD_RELOC_X86_64_GOTPLT64 },
d6334 2
a6335 2
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF,
		    BFD_RELOC_X86_64_GOTOFF64 },
d6337 2
a6338 2
    { "GOTPCREL", { _dummy_first_bfd_reloc_code_real,
		    BFD_RELOC_X86_64_GOTPCREL },
d6340 2
a6341 2
    { "TLSGD",    { BFD_RELOC_386_TLS_GD,
		    BFD_RELOC_X86_64_TLSGD    },
d6343 2
a6344 2
    { "TLSLDM",   { BFD_RELOC_386_TLS_LDM,
		    _dummy_first_bfd_reloc_code_real },
d6346 2
a6347 2
    { "TLSLD",    { _dummy_first_bfd_reloc_code_real,
		    BFD_RELOC_X86_64_TLSLD    },
d6349 2
a6350 2
    { "GOTTPOFF", { BFD_RELOC_386_TLS_IE_32,
		    BFD_RELOC_X86_64_GOTTPOFF },
d6352 2
a6353 2
    { "TPOFF",    { BFD_RELOC_386_TLS_LE_32,
		    BFD_RELOC_X86_64_TPOFF32  },
d6355 2
a6356 2
    { "NTPOFF",   { BFD_RELOC_386_TLS_LE,
		    _dummy_first_bfd_reloc_code_real },
d6358 2
a6359 3
    { "DTPOFF",   { BFD_RELOC_386_TLS_LDO_32,
		    BFD_RELOC_X86_64_DTPOFF32 },

d6361 2
a6362 2
    { "GOTNTPOFF",{ BFD_RELOC_386_TLS_GOTIE,
		    _dummy_first_bfd_reloc_code_real },
d6364 2
a6365 2
    { "INDNTPOFF",{ BFD_RELOC_386_TLS_IE,
		    _dummy_first_bfd_reloc_code_real },
d6367 2
a6368 2
    { "GOT",      { BFD_RELOC_386_GOT32,
		    BFD_RELOC_X86_64_GOT32    },
d6370 2
a6371 2
    { "TLSDESC",  { BFD_RELOC_386_TLS_GOTDESC,
		    BFD_RELOC_X86_64_GOTPC32_TLSDESC },
d6373 2
a6374 2
    { "TLSCALL",  { BFD_RELOC_386_TLS_DESC_CALL,
		    BFD_RELOC_X86_64_TLSDESC_CALL },
d6389 1
a6389 3
      int len;

      len = strlen (gotrel[j].str);
@


1.429
log
@Set error instead of err_msg on failure.

2010-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_error): New.
	(_i386_insn): Replace err_msg with error.
	(operand_size_match): Set error instead of err_msg on failure.
	(operand_type_match): Likewise.
	(operand_type_register_match): Likewise.
	(VEX_check_operands): Likewise.
	(match_template): Likewise.  Use error instead of err_msg with
	as_bad.
@
text
@d209 1
a209 1
    oprand_size_mismatch,
d1582 1
a1582 1
      i.error = oprand_size_mismatch;
d4112 1
a4112 1
	case oprand_size_mismatch:
@


1.428
log
@Update x86 assembler error messages.

2010-02-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Update error messages.
@
text
@d207 14
d279 1
a279 1
    const char *err_msg;
d1582 1
a1582 1
      i.err_msg = _("operand size mismatch");
d1628 1
a1628 1
  i.err_msg = _("operand type mismatch");
d1678 1
a1678 1
  i.err_msg = _("register type mismatch");
d3775 1
a3775 1
	  i.err_msg = _("Imm4 isn't the first operand");
d3827 1
a3827 1
      i.err_msg = _("number of operands mismatch");
d3832 1
a3832 1
      i.err_msg = _("unsupported");
d3839 1
a3839 1
      i.err_msg = _("only supported with old gcc");
d3844 1
a3844 1
      i.err_msg = _("unsupported with Intel mnemonic");
d3849 1
a3849 1
      i.err_msg = _("unsupported syntax");
d3855 1
a3855 1
      i.err_msg = _("invalid instruction suffix");
d4107 37
a4143 1
      as_bad (_("%s for `%s'"), i.err_msg,
@


1.427
log
@Improve x86 assembler error message.

2010-02-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (_i386_insn): Add err_msg.
	(operand_size_match): Set err_msg on failure.
	(operand_type_match): Likewise.
	(operand_type_register_match): Likewise.
	(VEX_check_operands): Likewise.
	(match_template): Likewise.  Use i.err_msg with as_bad.
@
text
@d3818 1
a3818 1
      i.err_msg = _("instruction not supported");
d3830 1
a3830 1
      i.err_msg = _("not supported with Intel mnemonic");
@


1.426
log
@Reformat build_modrm_byte.

2010-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Reformat.
@
text
@d263 3
d1563 1
a1563 2
  if (match
      || (!t->opcode_modifier.d && !t->opcode_modifier.floatd))
d1565 6
d1580 1
a1580 4
	{
	  match = 0;
	  break;
	}
d1584 1
a1584 4
	{
	  match = 0;
	  break;
	}
d1607 5
a1611 1
    return 0;
d1613 3
a1615 2
  return (given.bitfield.baseindex == overlap.bitfield.baseindex
	  && given.bitfield.jumpabsolute == overlap.bitfield.jumpabsolute);
d1658 9
a1666 4
  return (!(t0.bitfield.reg8 & t1.bitfield.reg8)
	  && !(t0.bitfield.reg16 & t1.bitfield.reg16)
	  && !(t0.bitfield.reg32 & t1.bitfield.reg32)
	  && !(t0.bitfield.reg64 & t1.bitfield.reg64));
d3760 4
a3763 1
	return 1;
d3813 1
d3818 1
d3825 1
d3830 1
d3834 2
a3835 1
      /* Check AT&T syntax Intel syntax.   */
d3841 1
d4093 2
a4094 6
      if (intel_syntax)
	as_bad (_("ambiguous operand size or operands invalid for `%s'"),
		current_templates->start->name);
      else
	as_bad (_("suffix or operands invalid for `%s'"),
		current_templates->start->name);
@


1.425
log
@Update copyright.

gas/

2010-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c: Update copyright.

opcodes/

2010-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c: Update copyright.
	* i386-gen.c: Likewise.
	* i386-opc.h: Likewise.
	* i386-opc.tbl: Likewise.
@
text
@d5054 2
a5055 1
          gas_assert (operand_type_equal (&i.tm.operand_types[reg_slot], &regxmm)
d5061 2
a5062 1
                  + ((i.op[reg_slot].regs->reg_flags & RegRex) ? 8 : 0)) << 4);
d5101 4
a5104 3
          gas_assert (operand_type_equal (&i.tm.operand_types[reg_slot], &regxmm)
                  || operand_type_equal (&i.tm.operand_types[reg_slot],
                                         &regymm));
d5107 2
a5108 1
                   + ((i.op[reg_slot].regs->reg_flags & RegRex) ? 8 : 0)) << 4);
@


1.424
log
@2010-02-10  Quentin Neill  <quentin.neill@@amd.com>
            Sebastian Pop  <sebastian.pop@@amd.com>

gas:
        * config/tc-i386.c (vec_imm4) New operand type.
        (fits_in_imm4): New.
        (VEX_check_operands): New.
        (check_reverse): Call VEX_check_operands.
        (build_modrm_byte): Reintroduce code for 5
        operand insns.  Fix whitespace.

gas/testsuite:
        * gas/i386/x86-64-xop.d: Add vpermil2p[sd] tests.
        * gas/i386/x86-64-xop.s: Likewise.
        * gas/i386/xop.d: Likewise.
        * gas/i386/xop.s: Likewise.

opcodes:
        * i386-dis.c (OP_EX_VexImmW): Reintroduced
        function to handle 5th imm8 operand.
        (PREFIX_VEX_3A48): Added.
        (PREFIX_VEX_3A49): Added.
        (VEX_W_3A48_P_2): Added.
        (VEX_W_3A49_P_2): Added.
        (prefix table): Added entries for PREFIX_VEX_3A48
        and PREFIX_VEX_3A49.
        (vex table): Added entries for VEX_W_3A48_P_2 and
        and VEX_W_3A49_P_2.
        * i386-gen.c (operand_type_init): Added OPERAND_TYPE_VEC_IMM4
        for Vec_Imm4 operands.
        * i386-opc.h (enum): Added Vec_Imm4.
        (i386_operand_type): Added vec_imm4.
        * i386-opc.tbl: Add entries for vpermilp[ds].
        * i386-init.h: Regenerated.
        * i386-tbl.h: Regenerated.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.423
log
@2010-02-03  Quentin Neill  <quentin.neill@@amd.com>

gas/
	* config/tc-i386.c (cpu_arch): Change amdfam15 to bdver1.
	(i386_align_code): Rename  PROCESSOR_AMDFAM15 to PROCESSOR_BDVER1.
	* config/tc-i386.h (processor_type): Same.
	* doc/c-i386.texi: Change amdfam15 to bdver1.

opcodes/
	* i386-gen.c (cpu_flag_init): Rename CPU_AMDFAM15_FLAGS
	to CPU_BDVER1_FLAGS
	* i386-init.h: Regenerated.

testsuite/
	* gas/i386/i386.exp: Rename amdfam15 test cases to bdver1.
	* gas/i386/x86-64-nops-1-amdfam15.d: Renamed test case to
	gas/i386/x86-64-nops-1-bdver1.d.
	* gas/i386/nops-1-amdfam15.d: Renamed test case to
	gas/i386/nops-1-bdver1.d.
@
text
@d1439 1
d1715 6
d3734 23
d4061 4
d4997 5
a5001 5
	  && i.tm.opcode_modifier.immext)
	{
	  dest = i.operands - 2;
	  gas_assert (dest == 3);
	}
d5003 1
a5003 1
	dest = i.operands - 1;
d5006 7
a5012 3
      /* This instruction must have 4 register operands
	 or 3 register operands plus 1 memory operand.
	 It must have VexNDS and VexImmExt.  */
d5014 48
a5061 19
		      || (i.reg_operands == 3 && i.mem_operands == 1))
		  && i.tm.opcode_modifier.vexvvvv == VEXXDS
		  && i.tm.opcode_modifier.veximmext
	    && (operand_type_equal (&i.tm.operand_types[dest], &regxmm)
		|| operand_type_equal (&i.tm.operand_types[dest], &regymm)));

      /* Generate an 8bit immediate operand to encode the register
	 operand.  */
      exp = &im_expressions[i.imm_operands++];
      i.op[i.operands].imms = exp;
      i.types[i.operands] = imm8;
      i.operands++;
      /* If VexW1 is set, the first operand is the source and
	 the second operand is encoded in the immediate operand.  */
      if (i.tm.opcode_modifier.vexw == VEXW1)
	{
	  source = 0;
	  reg_slot = 1;
	}
d5063 47
a5109 14
	{
	  source = 1;
	  reg_slot = 0;
	}
      gas_assert ((operand_type_equal (&i.tm.operand_types[reg_slot], &regxmm)
		   || operand_type_equal (&i.tm.operand_types[reg_slot],
					  &regymm))
		  && (operand_type_equal (&i.tm.operand_types[nds], &regxmm)
		      || operand_type_equal (&i.tm.operand_types[nds],
					     &regymm)));
      exp->X_op = O_constant;
      exp->X_add_number
	= ((i.op[reg_slot].regs->reg_num
	    + ((i.op[reg_slot].regs->reg_flags & RegRex) ? 8 : 0)) << 4);
@


1.422
log
@Allow VL=1 on AVX scalar instructions.

gas/

2010-01-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (avxscalar): New.
	(OPTION_MAVXSCALAR): Likewise.
	(build_vex_prefix): Select vector_length for scalar instructions
	based on avxscalar.
	(md_longopts): Add OPTION_MAVXSCALAR.
	(md_parse_option): Handle OPTION_MAVXSCALAR.
	(md_show_usage): Add -mavxscalar=.

	* doc/c-i386.texi: Document -mavxscalar=.

gas/testsuite/

2010-01-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/avx-scalar-intel.d: New.
	* gas/i386/avx-scalar.d: Likewise.
	* gas/i386/avx-scalar.s: Likewise.
	* gas/i386/x86-64-avx-scalar-intel.d: Likewise.
	* gas/i386/x86-64-avx-scalar.d: Likewise.
	* gas/i386/x86-64-avx-scalar.s: Likewise.

	* gas/i386/i386.exp: Run avx-scalar, avx-scalar-intel,
	x86-64-avx-scalar and x86-64-avx-scalar-intel.

opcodes/

2010-01-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (XMScalar): New.
	(EXdScalar): Likewise.
	(EXqScalar): Likewise.
	(EXqScalarS): Likewise.
	(VexScalar): Likewise.
	(EXdVexScalarS): Likewise.
	(EXqVexScalarS): Likewise.
	(XMVexScalar): Likewise.
	(scalar_mode): Likewise.
	(d_scalar_mode): Likewise.
	(d_scalar_swap_mode): Likewise.
	(q_scalar_mode): Likewise.
	(q_scalar_swap_mode): Likewise.
	(vex_scalar_mode): Likewise.
	(vex_len_table): Duplcate entries for VEX_LEN_10_P_1,
	VEX_LEN_10_P_3, VEX_LEN_11_P_1, VEX_LEN_11_P_3, VEX_LEN_2A_P_1,
	VEX_LEN_2A_P_3, VEX_LEN_2C_P_3, VEX_LEN_2D_P_1, VEX_LEN_2E_P_0,
	VEX_LEN_2E_P_2, VEX_LEN_2F_P_2, VEX_LEN_51_P_1, VEX_LEN_51_P_3,
	VEX_LEN_52_P_1, VEX_LEN_53_P_1, VEX_LEN_58_P_1, VEX_LEN_58_P_3,
	VEX_LEN_59_P_1, VEX_LEN_5A_P_1, VEX_LEN_5A_P_3, VEX_LEN_5C_P_1,
	VEX_LEN_5C_P_3, VEX_LEN_5D_P_1, VEX_LEN_5D_P_3, VEX_LEN_5E_P_1,
	VEX_LEN_5E_P_3, VEX_LEN_5F_P_1, VEX_LEN_5F_P_3, VEX_LEN_6E_P_2,
	VEX_LEN_7E_P_1, VEX_LEN_7E_P_2, VEX_LEN_D6_P_2, VEX_LEN_C2_P_1,
	VEX_LEN_C2_P_3, VEX_LEN_3A0A_P_2 and VEX_LEN_3A0B_P_2.
	(vex_w_table): Update entries for VEX_W_10_P_1, VEX_W_10_P_3,
	VEX_W_11_P_1, VEX_W_11_P_3, VEX_W_2E_P_0, VEX_W_2E_P_2,
	VEX_W_2F_P_0, VEX_W_2F_P_2, VEX_W_51_P_1, VEX_W_51_P_3,
	VEX_W_52_P_1, VEX_W_53_P_1, VEX_W_58_P_1, VEX_W_58_P_3,
	VEX_W_59_P_1, VEX_W_59_P_3, VEX_W_5A_P_1, VEX_W_5A_P_3,
	VEX_W_5C_P_1, VEX_W_5C_P_3, VEX_W_5D_P_1, VEX_W_5D_P_3,
	VEX_W_5E_P_1, VEX_W_5E_P_3, VEX_W_5F_P_1, VEX_W_5F_P_3,
	VEX_W_7E_P_1, VEX_W_D6_P_2  VEX_W_C2_P_1, VEX_W_C2_P_3,
	VEX_W_3A0A_P_2 and VEX_W_3A0B_P_2.
	(intel_operand_size): Handle d_scalar_mode, d_scalar_swap_mode,
	q_scalar_mode, q_scalar_swap_mode.
	(OP_XMM): Handle scalar_mode.
	(OP_EX): Handle d_scalar_mode, d_scalar_swap_mode, q_scalar_mode
	and q_scalar_swap_mode.
	(OP_VEX): Handle vex_scalar_mode.
@
text
@d606 2
a607 2
  { STRING_COMMA_LEN ("amdfam15"), PROCESSOR_AMDFAM15,
    CPU_AMDFAM15_FLAGS, 0 },
d969 1
a969 1
     PROCESSOR_AMDFAM10, and PROCESSOR_AMDFAM15, alt_short_patt
d1023 1
a1023 1
	    case PROCESSOR_AMDFAM15:
d1051 1
a1051 1
	    case PROCESSOR_AMDFAM15:
@


1.421
log
@Set the first 3byte VEX prefix individually.

2010-01-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_vex_prefix): Set i.vex.bytes[0] to
	0xc4 individually.
@
text
@d451 7
d2716 4
a2719 1
  vector_length = i.tm.opcode_modifier.vex == VEX256 ? 1 : 0;
d7881 1
d7900 1
d8111 9
d8244 3
@


1.420
log
@2010-01-15  Sebastian Pop  <sebastian.pop@@amd.com>

gas/
	* config/tc-i386.c (md_assemble): Before accessing the IMM field
	check that it's not an XOP insn.

gas/testsuite/
	* gas/i386/x86-64-xop.d: Add missing patterns.
	* gas/i386/x86-64-xop.s: Same.
	* gas/i386/xop.d: Same.
	* gas/i386/xop.s: Same.

opcodes/
	* i386-opc.tbl: Support all the possible aliases for VPCOM* insns.
	* i386-tbl.h: Regenerated.
@
text
@a2751 1
      i.vex.bytes[0] = 0xc4;
d2757 1
d2761 1
d2765 1
@


1.419
log
@2010-01-06  Quentin Neill  <quentin.neill@@amd.com>

gas/
       * config/tc-i386.c (cpu_arch): Add amdfam15.
         (i386_align_code): Add PROCESSOR_AMDFAM15 cases.
       * config/tc-i386.h (processor_type): Add PROCESSOR_AMDFAM15.
       * doc/c-i386.texi: Add amdfam15.

opcodes/
       * i386-gen.c (cpu_flag_init): Add new CPU_AMDFAM15_FLAGS.
       * i386-init.h: Regenerated.

testsuite/
       * gas/i386/i386.exp: Add new amdfam15 test cases.
       * gas/i386/nops-1-amdfam15.d: New.
@
text
@d3021 2
a3022 2
      && i.op[0].imms->X_add_number == 3
      && !i.tm.opcode_modifier.modrm)
@


1.418
log
@Replace VexNDS, VexNDD and VexLWP with VexVVVV.

gas/

2009-12-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_operands): Check vexvvvv instead
	of vexnds and vexndd.
	(build_modrm_byte): Check vexvvvv instead of vexnds, vexndd
	and vexlwp.

opcodes/

2009-12-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Remove VexNDS, VexNDD and
	VexLWP.  Add VexVVVV.

	* i386-opc.h (VexNDS): Removed.
	(VexNDD): Likewise.
	(VexLWP): Likewise.
	(VEXXDS): New.
	(VEXNDD): Likewise.
	(VEXLWP): Likewise.
	(VexVVVV): Likewise.
	(i386_opcode_modifier): Remove vexnds, vexndd and vexlwp.
	Add vexvvvv.

	* i386-opc.tbl: Replace VexNDS with VexVVVV=1, VexNDD with
	VexVVVV=2 and VexLWP with VexVVVV=3.
	* i386-tbl.h: Regenerated.
@
text
@d599 2
d962 2
a963 1
     PROCESSOR_AMDFAM10, alt_short_patt will be used.
d1016 1
d1044 1
@


1.417
log
@Remove ByteOkIntel.

gas/

2009-12-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_suffix): Set i.suffix to 0 in
	Intel syntax if size is ignored and b/l/w suffixes are
	illegal.
	(check_byte_reg): Remove byteokintel check.

opcodes/

2009-12-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Remove ByteOkIntel.

	* i386-opc.h (ByteOkIntel): Removed.
	(i386_opcode_modifier): Remove byteokintel.

	* i386-opc.tbl: Remove ByteOkIntel.
	* i386-tbl.h: Regenerated.
@
text
@d4716 1
a4716 3
  if (i.tm.opcode_modifier.sse2avx
      && (i.tm.opcode_modifier.vexnds
	  || i.tm.opcode_modifier.vexndd))
d4960 1
a4960 1
		  && i.tm.opcode_modifier.vexnds
d5006 1
a5006 2
	   && !i.tm.opcode_modifier.vexndd
	   && !i.tm.opcode_modifier.vexlwp)
d5008 1
a5008 1
	      && i.tm.opcode_modifier.vexnds)
d5023 1
a5023 1
			  && (i.tm.opcode_modifier.vexnds
d5042 1
a5042 1
		      || (i.tm.opcode_modifier.vexnds
d5046 1
a5046 1
	  if (i.tm.opcode_modifier.vexnds)
d5066 1
a5066 1
	  if (i.tm.opcode_modifier.vexnds)
d5356 1
a5356 1
      else if (i.tm.opcode_modifier.vexlwp)
d5393 1
a5393 1
	  else if (i.tm.opcode_modifier.vexnds)
d5410 1
a5410 1
	  else if (i.tm.opcode_modifier.vexndd)
@


1.416
log
@Replace Vex0F, Vex0F38, Vex0F3A, XOP08, XOP09 and XOP0A with VexOpcode.

gas/

2009-12-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_vex_prefix): Replace vex0f, vex0f38,
	vex0f3a, xop08, xop09 and xop0a with vexopcode.

opcodes/

2009-12-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Remove Vex0F, Vex0F38,
	Vex0F3A, XOP08, XOP09 and XOP0A.  Add VexOpcode.

	* i386-opc.h (Vex0F): Removed.
	(Vex0F38): Likewise.
	(Vex0F3A): Likewise.
	(VexOpcode): New.
	(VEX0F): Likewise.
	(VEX0F38): Likewise.
	(VEX0F3A): Likewise.
	(XOP08): Defined as a macro.
	(XOP09): Likewise.
	(XOP0A): Likewise.
	(i386_opcode_modifier): Remove vex0f, vex0f38, vex0f3a, xop08,
	xop09 and xop0a.  Add vexopcode.

	* i386-opc.tbl: Replace Vex0F with VexOpcode=0, Vex0F38 with
	VexOpcode=1, Vex0F3A with VexOpcode=2, XOP08 with VexOpcode=3,
	XOP09 with VexOpcode=4 and XOP0A with VexOpcode=5.
	* i386-tbl.h: Regenerated.
@
text
@d4181 5
a4185 1
	  if (!check_byte_reg ())
d4190 5
a4194 1
	  if (!check_long_reg ())
d4208 5
a4212 1
	  if (!check_word_reg ())
a4389 4
      /* Don't generate this warning if not needed.  */
      if (intel_syntax && i.tm.opcode_modifier.byteokintel)
	continue;

@


1.415
log
@Replace VEX2SOURCES with XOP2SOURCES.

gas/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Check XOP2SOURCES
	instead VEX2SOURCES.

opcodes/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.h (VEX2SOURCES): Renamed to ...
	(XOP2SOURCES): This.
@
text
@d2678 1
a2678 1
      && i.tm.opcode_modifier.vex0f
d2725 1
a2725 1
  if (i.tm.opcode_modifier.vex0f
d2749 1
a2749 7
      if (i.tm.opcode_modifier.vex0f)
	m = 0x1;
      else if (i.tm.opcode_modifier.vex0f38)
	m = 0x2;
      else if (i.tm.opcode_modifier.vex0f3a)
	m = 0x3;
      else if (i.tm.opcode_modifier.xop08)
d2751 10
d2763 2
a2764 3
	}
      else if (i.tm.opcode_modifier.xop09)
	{
d2767 2
a2768 3
	}
      else if (i.tm.opcode_modifier.xop0a)
	{
d2771 3
a2774 2
      else
	abort ();
@


1.414
log
@Replace Vex2Sources and Vex3Sources with VexSources.

gas/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_operands): Check vexsources
	instead of vex3sources.
	(build_modrm_byte): Check vexsources instead of vex2sources
	and vex3sources.

opcodes/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Remove Vex3Sources and
	Vex2Sources.  Add VexSources.

	* i386-opc.h ()Vex2Sources: Removed.
	(Vex3Sources): Likewise.
	(VEX2SOURCES): New.
	(VEX3SOURCES): Likewise.
	(VexSources): Likewise.
	(i386_opcode_modifier): Remove vex2sources and vex3sources.
	Add vexsources.

	* i386-opc.tbl: Replace Vex2Sources with VexSources=1 and
	Vex3Sourceswith VexSources=2.
	* i386-tbl.h: Regenerated.
@
text
@d5314 1
a5314 1
      if (i.tm.opcode_modifier.vexsources == VEX2SOURCES)
@


1.413
log
@Remove VexW0 and VexW1.  Add VexW.

gas/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_vex_prefix): Replace vexw0/vexw1
	with vexw.
	(build_modrm_byte): Likewise.

opcodes/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Remove VexW0 and VexW1.  Add
	VexW.

	* i386-opc.h (VexW0): Removed.
	(VexW1): Likewise.
	(VEXW0): New.
	(VEXW1): Likewise.
	(VexW): Likewise.
	(i386_opcode_modifier): Remove vexw0 and vexw1.  Add vexw.

	* i386-opc.tbl: Replace VexW0 with VexW=1 and VexW1 with
	Vex=2.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d4725 1
a4725 1
	  if (i.tm.opcode_modifier.vex3sources)
d4747 2
a4748 1
		      && i.tm.opcode_modifier.vex3sources);
d4926 1
a4926 1
  int vex_3_sources, vex_2_sources;
d4930 1
a4930 2
  vex_3_sources = i.tm.opcode_modifier.vex3sources;
  vex_2_sources = i.tm.opcode_modifier.vex2sources;
d5314 1
a5314 1
      if (vex_2_sources)
@


1.412
log
@Define VEX128 and VEX256.

gas/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_vex_prefix): Use VEX256.

opcodes/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.h (VEX128): New.
	(VEX256): Likewise.
@
text
@d2779 1
a2779 1
      if (i.tm.opcode_modifier.vexw0 || i.tm.opcode_modifier.vexw1)
d2784 1
a2784 1
	  if (i.tm.opcode_modifier.vexw1)
d4964 1
a4964 1
      if (i.tm.opcode_modifier.vexw1)
d5322 1
a5322 1
	      if (i.tm.opcode_modifier.vexw0)
d5339 1
a5339 1
	      if (i.tm.opcode_modifier.vexw0)
@


1.411
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2704 1
a2704 1
  vector_length = i.tm.opcode_modifier.vex == 2 ? 1 : 0;
@


1.410
log
@2009-12-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (arch_entry): Add len and skip.
	(cpu_arch): Use STRING_COMMA_LEN.
	(MESSAGE_TEMPLATE): New.
	(show_arch): Likewise.
	(md_show_usage): Use show_arch.
@
text
@d2026 1
a2026 1
      unsigned int i;
d2029 1
a2029 1
      for (i = 0; i < ARRAY_SIZE (cpu_arch); i++)
d2031 1
a2031 1
	  if (strcmp (string, cpu_arch[i].name) == 0)
d2033 1
a2033 1
	      check_cpu_arch_compatible (string, cpu_arch[i].flags);
d2037 1
a2037 1
		  cpu_arch_name = cpu_arch[i].name;
d2039 1
a2039 1
		  cpu_arch_flags = cpu_arch[i].flags;
d2050 2
a2051 2
		  cpu_arch_isa = cpu_arch[i].type;
		  cpu_arch_isa_flags = cpu_arch[i].flags;
d2062 1
a2062 1
				      cpu_arch[i].flags);
d2065 1
a2065 1
					   cpu_arch[i].flags);
d2072 1
a2072 1
						  cpu_arch[i].name,
d2077 1
a2077 1
		    cpu_sub_arch_name = xstrdup (cpu_arch[i].name);
d2085 1
a2085 1
      if (i >= ARRAY_SIZE (cpu_arch))
d2457 1
a2457 1
      reloc_howto_type *reloc;
d2488 2
a2489 2
      reloc = bfd_reloc_type_lookup (stdoutput, other);
      if (!reloc)
d2491 1
a2491 1
      else if (size != bfd_get_reloc_size (reloc))
d2493 1
a2493 1
		bfd_get_reloc_size (reloc),
d2495 1
a2495 1
      else if (pcrel && !reloc->pc_relative)
d2497 1
a2497 1
      else if ((reloc->complain_on_overflow == complain_overflow_signed
d2499 1
a2499 1
	       || (reloc->complain_on_overflow == complain_overflow_unsigned
d3642 1
a3642 1
	    offsetT disp = i.op[op].disps->X_add_number;
d3645 1
a3645 1
		&& (disp & ~(offsetT) 0xffff) == 0)
d3650 1
a3650 1
		disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
d3654 1
a3654 1
		&& (disp & ~(((offsetT) 2 << 31) - 1)) == 0)
d3659 2
a3660 2
		disp &= (((offsetT) 2 << 31) - 1);
		disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
d3663 1
a3663 1
	    if (!disp && i.types[op].bitfield.baseindex)
d3675 1
a3675 1
		if (fits_in_signed_long (disp))
d3681 1
a3681 1
		    && fits_in_unsigned_long (disp))
d3687 1
a3687 1
		&& fits_in_signed_byte (disp))
d4686 2
a4687 1
  const char *reg = xmm ? "xmm0" : "ymm0";
d4690 1
a4690 1
	    i.tm.name, register_prefix, reg);
d4693 1
a4693 1
	    i.tm.name, register_prefix, reg);
d4709 2
a4710 2
      unsigned int dup = i.operands;
      unsigned int dest = dup - 1;
d4715 1
a4715 1
		  && MAX_OPERANDS > dup
d4746 1
a4746 1
	  gas_assert ((MAX_OPERANDS - 1) > dup
d4766 1
a4766 1
	  dup++;
d4768 3
a4770 3
	  i.op[dup] = i.op[dest];
	  i.types[dup] = i.types[dest];
	  i.tm.operand_types[dup] = i.tm.operand_types[dest];
d4779 3
a4781 3
	  i.op[dup] = i.op[dest];
	  i.types[dup] = i.types[dest];
	  i.tm.operand_types[dup] = i.tm.operand_types[dest];
d4933 1
a4933 1
      unsigned int nds, reg;
d4943 1
a4943 1
      dest = i.operands - 1;
d4967 1
a4967 1
	  reg = 1;
d4972 1
a4972 1
	  reg = 0;
d4974 2
a4975 2
      gas_assert ((operand_type_equal (&i.tm.operand_types[reg], &regxmm)
		   || operand_type_equal (&i.tm.operand_types[reg],
d4982 2
a4983 2
	= ((i.op[reg].regs->reg_num
	    + ((i.op[reg].regs->reg_flags & RegRex) ? 8 : 0)) << 4);
d6114 1
a6114 1
lex_got (enum bfd_reloc_code_real *reloc,
d6203 1
a6203 1
	      *reloc = gotrel[j].rel[object_64bit];
d7881 1
a7881 1
  unsigned int i;
d7967 1
a7967 1
	  for (i = 0; i < ARRAY_SIZE (cpu_arch); i++)
d7969 1
a7969 1
	      if (strcmp (arch, cpu_arch [i].name) == 0)
d7972 1
a7972 1
		  cpu_arch_name = cpu_arch[i].name;
d7974 3
a7976 3
		  cpu_arch_flags = cpu_arch[i].flags;
		  cpu_arch_isa = cpu_arch[i].type;
		  cpu_arch_isa_flags = cpu_arch[i].flags;
d7984 2
a7985 2
	      else if (*cpu_arch [i].name == '.'
		       && strcmp (arch, cpu_arch [i].name + 1) == 0)
d7992 1
a7992 1
					  cpu_arch[i].flags);
d7995 1
a7995 1
					       cpu_arch[i].flags);
d8002 1
a8002 1
						      cpu_arch[i].name,
d8007 1
a8007 1
			cpu_sub_arch_name = xstrdup (cpu_arch[i].name);
d8014 1
a8014 1
	  if (i >= ARRAY_SIZE (cpu_arch))
d8025 1
a8025 1
      for (i = 0; i < ARRAY_SIZE (cpu_arch); i++)
d8027 1
a8027 1
	  if (strcmp (arg, cpu_arch [i].name) == 0)
d8030 2
a8031 2
	      cpu_arch_tune = cpu_arch [i].type;
	      cpu_arch_tune_flags = cpu_arch[i].flags;
d8035 1
a8035 1
      if (i >= ARRAY_SIZE (cpu_arch))
d8717 1
a8717 1
  expressionS expr;
d8719 4
a8722 4
  expr.X_op = O_secrel;
  expr.X_add_symbol = symbol;
  expr.X_add_number = 0;
  emit_expr (&expr, size);
@


1.409
log
@2009-11-18  Sebastian Pop  <sebastian.pop@@amd.com>

	gas/
	* config/tc-i386.c (cpu_arch): Remove cvt16.
	(md_show_usage): Same.
	* doc/c-i386.texi: Same.

	gas/testsuite/
	* gas/i386/cvt16.d: Removed.
	* gas/i386/cvt16.s: Removed.
	* gas/i386/x86-64-cvt16.d: Removed.
	* gas/i386/x86-64-cvt16.s: Removed.
	* gas/i386/i386.exp: Remove cvt16 and x86-64-cvt16 tests.

	opcodes/
	* i386-dis.c (VEX_LEN_XOP_08_A0): Removed.
	(VEX_LEN_XOP_08_A1): Removed.
	(xop_table): Remove entries for VEX_LEN_XOP_08_A0 and
	VEX_LEN_XOP_08_A1.
	(vex_len_table): Same.
	* i386-gen.c (CPU_CVT16_FLAGS): Removed.
	(cpu_flags): Remove field for CpuCVT16.
	* i386-opc.h (CpuCVT16): Removed.
	(i386_cpu_flags): Remove bitfield cpucvt16.
	(i386-opc.tbl): Remove CVT16 instructions.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Regenerated.
@
text
@d131 1
d134 1
d541 134
a674 134
  { "generic32", PROCESSOR_GENERIC32,
    CPU_GENERIC32_FLAGS },
  { "generic64", PROCESSOR_GENERIC64,
    CPU_GENERIC64_FLAGS },
  { "i8086", PROCESSOR_UNKNOWN,
    CPU_NONE_FLAGS },
  { "i186", PROCESSOR_UNKNOWN,
    CPU_I186_FLAGS },
  { "i286", PROCESSOR_UNKNOWN,
    CPU_I286_FLAGS },
  { "i386", PROCESSOR_I386,
    CPU_I386_FLAGS },
  { "i486", PROCESSOR_I486,
    CPU_I486_FLAGS },
  { "i586", PROCESSOR_PENTIUM,
    CPU_I586_FLAGS },
  { "i686", PROCESSOR_PENTIUMPRO,
    CPU_I686_FLAGS },
  { "pentium", PROCESSOR_PENTIUM,
    CPU_I586_FLAGS },
  { "pentiumpro", PROCESSOR_PENTIUMPRO,
    CPU_I686_FLAGS },
  { "pentiumii", PROCESSOR_PENTIUMPRO,
    CPU_P2_FLAGS },
  { "pentiumiii",PROCESSOR_PENTIUMPRO,
    CPU_P3_FLAGS },
  { "pentium4", PROCESSOR_PENTIUM4,
    CPU_P4_FLAGS },
  { "prescott", PROCESSOR_NOCONA,
    CPU_CORE_FLAGS },
  { "nocona", PROCESSOR_NOCONA,
    CPU_NOCONA_FLAGS },
  { "yonah", PROCESSOR_CORE,
    CPU_CORE_FLAGS },
  { "core", PROCESSOR_CORE,
    CPU_CORE_FLAGS },
  { "merom", PROCESSOR_CORE2,
    CPU_CORE2_FLAGS },
  { "core2", PROCESSOR_CORE2,
    CPU_CORE2_FLAGS },
  { "corei7", PROCESSOR_COREI7,
    CPU_COREI7_FLAGS },
  { "l1om", PROCESSOR_L1OM,
    CPU_L1OM_FLAGS },
  { "k6", PROCESSOR_K6,
    CPU_K6_FLAGS },
  { "k6_2", PROCESSOR_K6,
    CPU_K6_2_FLAGS },
  { "athlon", PROCESSOR_ATHLON,
    CPU_ATHLON_FLAGS },
  { "sledgehammer", PROCESSOR_K8,
    CPU_K8_FLAGS },
  { "opteron", PROCESSOR_K8,
    CPU_K8_FLAGS },
  { "k8", PROCESSOR_K8,
    CPU_K8_FLAGS },
  { "amdfam10", PROCESSOR_AMDFAM10,
    CPU_AMDFAM10_FLAGS },
  { ".8087", PROCESSOR_UNKNOWN,
    CPU_8087_FLAGS },
  { ".287", PROCESSOR_UNKNOWN,
    CPU_287_FLAGS },
  { ".387", PROCESSOR_UNKNOWN,
    CPU_387_FLAGS },
  { ".no87", PROCESSOR_UNKNOWN,
    CPU_ANY87_FLAGS },
  { ".mmx", PROCESSOR_UNKNOWN,
    CPU_MMX_FLAGS },
  { ".nommx", PROCESSOR_UNKNOWN,
    CPU_3DNOWA_FLAGS },
  { ".sse", PROCESSOR_UNKNOWN,
    CPU_SSE_FLAGS },
  { ".sse2", PROCESSOR_UNKNOWN,
    CPU_SSE2_FLAGS },
  { ".sse3", PROCESSOR_UNKNOWN,
    CPU_SSE3_FLAGS },
  { ".ssse3", PROCESSOR_UNKNOWN,
    CPU_SSSE3_FLAGS },
  { ".sse4.1", PROCESSOR_UNKNOWN,
    CPU_SSE4_1_FLAGS },
  { ".sse4.2", PROCESSOR_UNKNOWN,
    CPU_SSE4_2_FLAGS },
  { ".sse4", PROCESSOR_UNKNOWN,
    CPU_SSE4_2_FLAGS },
  { ".nosse", PROCESSOR_UNKNOWN,
    CPU_ANY_SSE_FLAGS },
  { ".avx", PROCESSOR_UNKNOWN,
    CPU_AVX_FLAGS },
  { ".noavx", PROCESSOR_UNKNOWN,
    CPU_ANY_AVX_FLAGS },
  { ".vmx", PROCESSOR_UNKNOWN,
    CPU_VMX_FLAGS },
  { ".smx", PROCESSOR_UNKNOWN,
    CPU_SMX_FLAGS },
  { ".xsave", PROCESSOR_UNKNOWN,
    CPU_XSAVE_FLAGS },
  { ".aes", PROCESSOR_UNKNOWN,
    CPU_AES_FLAGS },
  { ".pclmul", PROCESSOR_UNKNOWN,
    CPU_PCLMUL_FLAGS },
  { ".clmul", PROCESSOR_UNKNOWN,
    CPU_PCLMUL_FLAGS },
  { ".fma", PROCESSOR_UNKNOWN,
    CPU_FMA_FLAGS },
  { ".fma4", PROCESSOR_UNKNOWN,
    CPU_FMA4_FLAGS },
  { ".xop", PROCESSOR_UNKNOWN,
    CPU_XOP_FLAGS },
  { ".lwp", PROCESSOR_UNKNOWN,
    CPU_LWP_FLAGS },
  { ".movbe", PROCESSOR_UNKNOWN,
    CPU_MOVBE_FLAGS },
  { ".ept", PROCESSOR_UNKNOWN,
    CPU_EPT_FLAGS },
  { ".clflush", PROCESSOR_UNKNOWN,
    CPU_CLFLUSH_FLAGS },
  { ".syscall", PROCESSOR_UNKNOWN,
    CPU_SYSCALL_FLAGS },
  { ".rdtscp", PROCESSOR_UNKNOWN,
    CPU_RDTSCP_FLAGS },
  { ".3dnow", PROCESSOR_UNKNOWN,
    CPU_3DNOW_FLAGS },
  { ".3dnowa", PROCESSOR_UNKNOWN,
    CPU_3DNOWA_FLAGS },
  { ".padlock", PROCESSOR_UNKNOWN,
    CPU_PADLOCK_FLAGS },
  { ".pacifica", PROCESSOR_UNKNOWN,
    CPU_SVME_FLAGS },
  { ".svme", PROCESSOR_UNKNOWN,
    CPU_SVME_FLAGS },
  { ".sse4a", PROCESSOR_UNKNOWN,
    CPU_SSE4A_FLAGS },
  { ".abm", PROCESSOR_UNKNOWN,
    CPU_ABM_FLAGS },
d8089 74
d8164 1
a8164 2
md_show_usage (stream)
     FILE *stream;
d8193 5
a8197 11
                          generate code for CPU and EXTENSION, CPU is one of:\n\
                           i8086, i186, i286, i386, i486, pentium, pentiumpro,\n\
                           pentiumii, pentiumiii, pentium4, prescott, nocona,\n\
                           core, core2, corei7, l1om, k6, k6_2, athlon, k8,\n\
                           amdfam10, generic32, generic64\n\
                          EXTENSION is combination of:\n\
                           8087, 287, 387, no87, mmx, nommx, sse, sse2, sse3,\n\
                           ssse3, sse4.1, sse4.2, sse4, nosse, avx, noavx,\n\
                           vmx, smx, xsave, movbe, ept, aes, pclmul, fma,\n\
                           clflush, syscall, rdtscp, 3dnow, 3dnowa, sse4a,\n\
                           svme, abm, padlock, fma4, xop, lwp\n"));
d8199 2
a8200 5
  -mtune=CPU              optimize for CPU, CPU is one of:\n\
                           i8086, i186, i286, i386, i486, pentium, pentiumpro,\n\
                           pentiumii, pentiumiii, pentium4, prescott, nocona,\n\
                           core, core2, corei7, l1om, k6, k6_2, athlon, k8,\n\
                           amdfam10, generic32, generic64\n"));
@


1.408
log
@2009-11-17  Sebastian Pop  <sebastian.pop@@amd.com>
	    Quentin Neill  <quentin.neill@@amd.com>

	gas/
	* config/tc-i386.c (cpu_arch): Added .xop and .cvt16.
	(build_vex_prefix): Handle xop08.
	(md_assemble): Don't special case the constant 3 for insns using MODRM.
	(build_modrm_byte): Handle vex2sources.
	(md_show_usage): Add xop and cvt16.
	* doc/c-i386.texi: Document fma4, xop, and cvt16.

	gas/testsuite/
	* gas/i386/i386.exp: Run xop and cvt16 in 32-bit mode.
	Run x86-64-xop and x86-64-cvt16 in 64-bit mode.
	* gas/i386/lwp.d: Update name of the testcase.
	* gas/i386/x86-64-xop.d: New.
	* gas/i386/x86-64-xop.s: New.
	* gas/i386/xop.d: New.
	* gas/i386/xop.s: New.
	* gas/i386/cvt16.d: New.
	* gas/i386/cvt16.s: New.

	opcodes/
	* i386-dis.c (OP_Vex_2src_1): New.
	(OP_Vex_2src_2): New.
	(Vex_2src_1): New.
	(Vex_2src_2): New.
	(XOP_08): Added.
	(VEX_LEN_XOP_08_A0): Added.
	(VEX_LEN_XOP_08_A1): Added.
	(VEX_LEN_XOP_09_80): Added.
	(VEX_LEN_XOP_09_81): Added.
	(xop_table): Added an entry for XOP_08.  Handle xop instructions.
	(vex_len_table): Added entries for VEX_LEN_XOP_08_A0,
	VEX_LEN_XOP_08_A1, VEX_LEN_XOP_09_80, VEX_LEN_XOP_09_81.
	(get_valid_dis386): Handle XOP_08.
	(OP_Vex_2src): New.
	* i386-gen.c (cpu_flag_init): Add CPU_XOP_FLAGS and CPU_CVT16_FLAGS.
	(cpu_flags): Add CpuXOP and CpuCVT16.
	(opcode_modifiers): Add XOP08, Vex2Sources.
	* i386-opc.h (CpuXOP): Added.
	(CpuCVT16): Added.
	(i386_cpu_flags): Add cpuxop and cpucvt16.
	(XOP08): Added.
	(Vex2Sources): Added.
	(i386_opcode_modifier): Add xop08, vex2sources.
	* i386-opc.tbl: Add entries for XOP and CVT16 instructions.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Regenerated.
@
text
@a646 2
  { ".cvt16", PROCESSOR_UNKNOWN,
    CPU_CVT16_FLAGS },
d8128 1
a8128 1
                           svme, abm, padlock, fma4, xop, cvt16, lwp\n"));
@


1.407
log
@Check destination operand for lockable instructions.

gas/

2009-11-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Check destination operand
	for lockable instructions.

gas/testsuite/

2009-11-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/lock-1-intel.d: Updated.
	* gas/i386/lock-1.d: Likewise.
	* gas/i386/lock-1.s: Likewise.
	* gas/i386/lockbad-1.l: Likewise.
	* gas/i386/lockbad-1.s: Likewise.
	* gas/i386/x86-64-lock-1-intel.d: Likewise.
	* gas/i386/x86-64-lock-1.d: Likewise.
	* gas/i386/x86-64-lock-1.s: Likewise.
	* gas/i386/x86-64-lockbad-1.l: Likewise.
	* gas/i386/x86-64-lockbad-1.s: Likewise.
@
text
@d645 4
d2755 5
d3009 6
a3014 2
  /* Handle conversion of 'int $3' --> special int3 insn.  */
  if (i.tm.base_opcode == INT_OPCODE && i.op[0].imms->X_add_number == 3)
d4924 1
a4924 1
  int vex_3_sources;
d4929 1
d5313 35
a5347 1
      if (i.tm.opcode_modifier.vexlwp)
d8130 1
a8130 1
                           svme, abm, padlock, fma4, lwp\n"));
@


1.406
log
@2009-11-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (_i386_insn): Don't use bit field on
	swap_operand.
@
text
@d2935 2
a2936 1
  /* Check for lock without a lockable instruction.  */
d2939 3
a2941 1
	  || i.mem_operands == 0))
@


1.405
log
@gas/

2009-11-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (LOCKREP_PREFIX): Removed.
	(REP_PREFIX): New.
	(LOCK_PREFIX): Likewise.
	(PREFIX_GROUP): Likewise.
	(REX_PREFIX): Updated.
	(MAX_PREFIXES): Likewise.
	(add_prefix): Updated.  Return enum PREFIX_GROUP.
	(md_assemble): Check for lock without a lockable instruction.
	(parse_insn): Updated.
	(output_insn): Likewise.

gas/testsuite/

2009-11-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run lock-1, lock-1-intel, lockbad-1,
	x86-64-lock-1, x86-64-lock-1-intel and x86-64-lockbad-1.

	* gas/i386/lock-1-intel.d: New.
	* gas/i386/lock-1.d: Likewise.
	* gas/i386/lock-1.s: Likewise.
	* gas/i386/lockbad-1.l: Likewise.
	* gas/i386/lockbad-1.s: Likewise.
	* gas/i386/x86-64-lock-1-intel.d: Likewise.
	* gas/i386/x86-64-lock-1.d: Likewise.
	* gas/i386/x86-64-lock-1.s: Likewise.
	* gas/i386/x86-64-lockbad-1.l: Likewise.
	* gas/i386/x86-64-lockbad-1.s: Likewise.

opcodes/

2009-11-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Add IsLockable.

	* i386-opc.h (IsLockable): New.
	(i386_opcode_modifier): Add islockable.

	* i386-opc.tbl: Add IsLockable to add, adc, and, btc, btr,
	bts, cmpxchg, cmpxch8b, dec, inc, neg, not, or, sbb, sub,
	xor, xadd and xchg.
	* i386-tbl.h: Regenerated.
@
text
@d260 1
a260 1
    unsigned int swap_operand : 1;
@


1.404
log
@2009-11-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Don't set register
	operand twice.
@
text
@d62 1
a62 1
   LOCKREP_PREFIX.  */
d67 4
a70 3
#define LOCKREP_PREFIX	4
#define REX_PREFIX	5       /* must come last.  */
#define MAX_PREFIXES	6	/* max prefixes per opcode */
d1787 17
a1803 4
/* Returns 0 if attempting to add a prefix where one from the same
   class already exists, 1 if non rep/repne added, 2 if rep/repne
   added.  */
static int
d1806 1
a1806 1
  int ret = 1;
d1815 1
a1815 1
	ret = 0;
d1836 4
a1839 2
	  ret = 2;
	  /* fall thru */
d1841 2
a1842 1
	  q = LOCKREP_PREFIX;
d1858 1
a1858 1
	ret = 0;
d2935 9
d3140 1
a3140 1
	    case 0:
d3142 1
a3142 1
	    case 2:
d3145 2
d5667 1
a5667 1
			  || (i.prefix[LOCKREP_PREFIX]
@


1.403
log
@2009-11-05  Sebastian Pop  <sebastian.pop@@amd.com>
	    Quentin Neill  <quentin.neill@@amd.com>

	* gas/config/tc-i386.c (cpu_arch): Add CPU_LWP_FLAGS.
	(build_vex_prefix): Handle xop09 and xop0a.
	(build_modrm_byte): Handle vexlwp.
	(md_show_usage): Add lwp.
	* gas/doc/c-i386.texi (i386-LWP): New section.

	* gas/testsuite/gas/i386/i386.exp: Run x86-64-lwp in 64-bit mode,
	run lwp in 32-bit mode.
	* gas/testsuite/gas/i386/x86-64-lwp.d: New.
	* gas/testsuite/gas/i386/x86-64-lwp.s: New.
	* gas/testsuite/gas/i386/lwp.d: New.
	* gas/testsuite/gas/i386/lwp.s: New.

	* opcodes/i386-dis.c (OP_LWPCB_E): New.
	(OP_LWP_E): New.
	(OP_LWP_I): New.
	(USE_XOP_8F_TABLE): New.
	(XOP_8F_TABLE): New.
	(REG_XOP_LWPCB): New.
	(REG_XOP_LWP): New.
	(XOP_09): New.
	(XOP_0A): New.
	(reg_table): Redirect REG_8F to XOP_8F_TABLE.
	Add entries for REG_XOP_LWPCB and REG_XOP_LWP.
	(xop_table): New.
	(get_valid_dis386): Handle USE_XOP_8F_TABLE.
	Use the offsets VEX_0F, VEX_0F38, and VEX_0F3A instead of their values
	to access to the vex_table.
	(OP_LWPCB_E): New.
	(OP_LWP_E): New.
	(OP_LWP_I): New.
	* opcodes/i386-gen.c (cpu_flag_init): Add CPU_LWP_FLAGS, CpuLWP.
	(cpu_flags): Add CpuLWP.
	(opcode_modifiers): Add VexLWP, XOP09, and XOP0A.
	* opcodes/i386-opc.h (CpuLWP): New.
	(i386_cpu_flags): Add bit cpulwp.
	(VexLWP): New.
	(XOP09): New.
	(XOP0A): New.
	(i386_opcode_modifier): Add vexlwp, xop09, and xop0a.
	* opcodes/i386-opc.tbl (llwpcb): Added.
	(lwpval): Added.
	(lwpins): Added.
@
text
@d5347 2
a5348 9
	  /* If there is an extension opcode to put here, the
	     register number must be put into the regmem field.  */
	  if (i.tm.extension_opcode != None)
	    {
	      i.rm.regmem = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_B;
	    }
	  else
d5350 14
a5363 3
	      i.rm.reg = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_R;
@


1.402
log
@gas/

2009-10-29  Sebastian Pop  <sebastian.pop@@amd.com>

	* config/tc-i386.c (build_modrm_byte): Do not swap REG and
	NDS operands for FMA4.

gas/testsuite/

2009-10-29  Sebastian Pop  <sebastian.pop@@amd.com>

	* gas/i386/fma4.d: Updated patterns.
	* gas/i386/x86-64-fma4.d: Same.

opcodes/

2009-10-29  Sebastian Pop  <sebastian.pop@@amd.com>

	* i386-dis.c (OP_VEX_FMA): Removed.
	(VexFMA): Removed.
	(Vex128FMA): Removed.
	(prefix_table): First source operand of FMA4 insns is decoded
	with Vex not with VexFMA.
	(OP_EX_VexW): Second source operand is decoded with get_vex_imm8
	when vex.w is set.  Third source operand is decoded with
	get_vex_imm8 when vex.w is cleared.
	(OP_VEX_FMA): Removed.
@
text
@d644 2
d2725 3
d2734 10
a2746 3
      i.vex.length = 3;
      i.vex.bytes[0] = 0xc4;

d4951 2
a4952 1
	   && !i.tm.opcode_modifier.vexndd)
d5268 11
d5283 1
a5283 1
      if (i.reg_operands)
d5343 1
d8047 1
a8047 1
                           svme, abm, padlock, fma4\n"));
@


1.401
log
@2009-10-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10766
	* config/tc-i386.c (build_modrm_byte): Declare exp earlier.
@
text
@a4915 8
      /* FMA4 swaps REG and NDS.  */
      if (i.tm.cpu_flags.bitfield.cpufma4)
	{
	  unsigned int tmp;
	  tmp = reg;
	  reg = nds;
	  nds = tmp;
	}
@


1.400
log
@gas/

2009-10-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10740
	* config/tc-i386-intel.c (i386_intel_operand): Handle call
	and jump with 2 immediate operands.

	* config/tc-i386.c (i386_finalize_immediate): Don't generate
	error message if operand string is NULL.

gas/testsuite/

2009-10-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10740
	* gas/i386/jump.s: Add new tests.
	* gas/i386/jump16.s: Likewise.

	* gas/i386/jump.d: Updated.
	* gas/i386/jump16.d: Likewise.
@
text
@d4876 1
d4900 1
a4900 1
      expressionS *exp = &im_expressions[i.imm_operands++];
@


1.399
log
@2009-10-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (x86_cons): Reformat.
@
text
@d6290 3
a6292 2
      as_bad (_("missing or invalid immediate expression `%s'"),
	      imm_start);
d6320 2
a6321 1
      as_bad (_("illegal immediate register operand %s"), imm_start);
@


1.398
log
@gas/

2009-09-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_vex_prefix): Check vex == 2 instead
	of vex256.

opcodes/

2009-09-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Remove Vex256.
	(set_bitfield): Handle XXX=V.

	* i386-opc.h (Vex): Update comments.
	(Vex256): Removed.
	(VexNDS): Updated.
	(i386_opcode_modifier): Change vex to 2 bits.  Remove vex256.

	* i386-opc.tbl: Replace "Vex|Vex256" with Vex=2.
	* i386-tbl.h: Regenerated.
@
text
@d6204 2
a6205 1
static void signed_cons (int size)
@


1.397
log
@2009-09-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c: Remove white spaces.
@
text
@d2681 1
a2681 1
  vector_length = i.tm.opcode_modifier.vex256 ? 1 : 0;
@


1.396
log
@2009-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (offset_in_range): Sign extend offset only
	if BFD64 is defined.
@
text
@d1065 1
a1065 1
	  
d1989 1
a1989 1
  
d4887 2
a4888 2
      /* This instruction must have 4 register operands 
	 or 3 register operands plus 1 memory operand.  
d4914 1
a4914 1
	}      
d4922 1
a4922 1
	}      
d4925 1
a4925 1
					  &regymm)) 
d4927 1
a4927 1
		      || operand_type_equal (&i.tm.operand_types[nds], 
d4932 1
a4932 1
	    + ((i.op[reg].regs->reg_flags & RegRex) ? 8 : 0)) << 4);      
d5322 1
a5322 1
				       & regxmm)
@


1.395
log
@2009-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (offset_in_range): Sign extend offset only
	for 32bit address mode.
@
text
@a1768 1
#endif
d1771 1
@


1.394
log
@gas/

2009-09-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10636
	* config/tc-i386.c (optimize_disp): Set disp32 for 64bit only
	if there is an ADDR_PREFIX.
	(i386_finalize_displacement): Repor error if signed 32bit
	displacement is out of range.

gas/testsuite/

2009-09-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10636
	* gas/i386/disp.d: New.
	* gas/i386/disp.s: Likewise.
	* gas/i386/x86-64-disp.d: Likewise.
	* gas/i386/x86-64-disp.s: Likewise.

	* gas/i386/i386.exp: Run disp and x86-64-disp.

	* gas/i386/x86-64-addr32.s: Add high 32bit displacement tests.

	* gas/i386/x86-64-addr32.d: Updated.
	* gas/i386/x86-64-addr32-intel.d: Likewise.
	* gas/i386/x86-64-inval.l: Likewise.
	* gas/i386/x86-64-prescott.d: Likewise.

	* gas/i386/x86-64-inval.s: Add invalid displacement tests.

	* gas/i386/x86-64-prescott.s: Replace 0x90909090 displacement
	with 0x909090.
@
text
@d1765 5
a1769 2
  /* If BFD64, sign extend val.  */
  if (!use_rela_relocations)
@


1.393
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d3621 2
a3622 1
		if (fits_in_unsigned_long (disp))
d6571 19
@


1.392
log
@	* config/tc-i386.c (i386_target_format): Avoid duplicate case label.
@
text
@d1854 1
a1854 1
  flag_code = value;
d1879 1
a1879 1
  flag_code = new_code_flag;
d1964 1
a1964 1
			   i386_cpu_flags new ATTRIBUTE_UNUSED)
d1984 1
a1984 1
      || new.bitfield.cpul1om)
d6022 1
a6022 1
    { "PLTOFF",   { 0,
d6028 1
a6028 1
    { "GOTPLT",   { 0,
d6034 1
a6034 1
    { "GOTPCREL", { 0,
d6041 1
a6041 1
		    0                         },
d6043 1
a6043 1
    { "TLSLD",    { 0,
d6053 1
a6053 1
		    0                         },
d6060 1
a6060 1
		    0                         },
d6063 1
a6063 1
		    0                         },
d6128 1
a6128 1
	      tmpbuf = xmalloc (first + second + 2);
d7107 1
a7107 1
	reloc_type = fragP->fr_var;
d7556 1
a7556 1
		  r = hash_find (reg_hash, "st(0)");
@


1.391
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d8087 1
a8087 5
#if defined (TE_PE) || defined (TE_PEP)
    case bfd_target_coff_flavour:
      return flag_code == CODE_64BIT ? "pe-x86-64" : "pe-i386";
#endif
#ifdef OBJ_MAYBE_AOUT
d8091 5
a8095 1
#ifdef TE_GO32
d8098 1
a8098 1
#elif defined (OBJ_MAYBE_COFF)
d8101 1
@


1.391.2.1
log
@	* config/tc-i386.c (i386_target_format): Avoid duplicate case label.
@
text
@d8087 5
a8091 1
#if defined (OBJ_MAYBE_AOUT) || defined (OBJ_AOUT)
d8095 1
a8095 5
#if defined (OBJ_MAYBE_COFF) || defined (OBJ_COFF)
# if defined (TE_PE) || defined (TE_PEP)
    case bfd_target_coff_flavour:
      return flag_code == CODE_64BIT ? "pe-x86-64" : "pe-i386";
# elif defined (TE_GO32)
d8098 1
a8098 1
# else
a8100 1
# endif
@


1.391.2.2
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d1854 1
a1854 1
  flag_code = (enum flag_code) value;
d1879 1
a1879 1
  flag_code = (enum flag_code) new_code_flag;
d1964 1
a1964 1
			   i386_cpu_flags new_flag ATTRIBUTE_UNUSED)
d1984 1
a1984 1
      || new_flag.bitfield.cpul1om)
d6022 1
a6022 1
    { "PLTOFF",   { _dummy_first_bfd_reloc_code_real,
d6028 1
a6028 1
    { "GOTPLT",   { _dummy_first_bfd_reloc_code_real,
d6034 1
a6034 1
    { "GOTPCREL", { _dummy_first_bfd_reloc_code_real,
d6041 1
a6041 1
		    _dummy_first_bfd_reloc_code_real },
d6043 1
a6043 1
    { "TLSLD",    { _dummy_first_bfd_reloc_code_real,
d6053 1
a6053 1
		    _dummy_first_bfd_reloc_code_real },
d6060 1
a6060 1
		    _dummy_first_bfd_reloc_code_real },
d6063 1
a6063 1
		    _dummy_first_bfd_reloc_code_real },
d6128 1
a6128 1
	      tmpbuf = (char *) xmalloc (first + second + 2);
d7107 1
a7107 1
	reloc_type = (enum bfd_reloc_code_real) fragP->fr_var;
d7556 1
a7556 1
		  r = (const reg_entry *) hash_find (reg_hash, "st(0)");
@


1.390
log
@gas/

2009-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Use PROCESSOR_L1OM on "l1om".
	(i386_align_code): Handle PROCESSOR_L1OM.
	(check_cpu_arch_compatible): Fix a typo in comments.
	(set_cpu_arch): Check cpu_arch_isa instead of
	cpu_arch_isa_flags.bitfield.cpul1om.
	(i386_mach): Likewise.
	(i386_target_format): Likewise.

	* config/tc-i386.h (processor_type): Add PROCESSOR_L1OM.

gas/testsuite/

2009-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/l1om.d: Check elf64-l1om format.
@
text
@d100 2
a101 2
  const template *start;
  const template *end;
d162 1
a162 1
static const template *match_template (void);
d207 1
a207 1
    template tm;
d1290 1
a1290 1
cpu_flags_match (const template *t)
d1474 1
a1474 1
match_reg_size (const template *t, unsigned int j)
d1490 1
a1490 1
match_mem_size (const template *t, unsigned int j)
d1509 1
a1509 1
operand_size_match (const template *t)
d2130 1
a2130 1
    const template *optab;
d2265 1
a2265 1
static void pte (template *);
d2316 1
a2316 1
pte (template *t)
d2631 1
a2631 1
build_vex_prefix (const template *t)
d2807 1
a2807 1
  const template *t;
d3028 1
a3028 1
  const template *t;
d3069 1
a3069 1
      current_templates = hash_find (op_hash, mnemonic);
d3121 1
a3121 1
      current_templates = hash_find (op_hash, mnemonic);
d3138 2
a3139 1
	  current_templates = hash_find (op_hash, mnemonic);
d3147 2
a3148 1
	      current_templates = hash_find (op_hash, mnemonic);
d3161 2
a3162 1
	      current_templates = hash_find (op_hash, mnemonic);
d3535 1
a3535 1
	      const template *t;
d3647 1
a3647 1
static const template *
d3651 1
a3651 1
  const template *t;
@


1.389
log
@gas/
	Fix compilation of i386-*-go32.
	* config/tc-i386.c (i386_target_format <TE_GO32>): New.
	(i386_target_format <OBJ_MAYBE_COFF>): Compile only if !TE_GO32.
	* config/te-go32.h (TARGET_FORMAT): Move the definition ...
	* config/tc-i386.h <!i386_target_format>: ... here.
@
text
@d580 1
a580 1
  { "l1om", PROCESSOR_GENERIC64,
d998 1
d1047 1
d1982 1
a1982 1
  /* If we are targeting Intel L1OM, wm must enable it.  */
d2090 1
a2090 1
  if (cpu_arch_isa_flags.bitfield.cpul1om)
d2106 1
a2106 1
      if (cpu_arch_isa_flags.bitfield.cpul1om)
d8107 1
a8107 1
	if (cpu_arch_isa_flags.bitfield.cpul1om)
@


1.388
log
@	PR ld/10269
	* symbols.c (S_FORCE_RELOC): True for BSF_GNU_INDIRECT_FUNCTION.
	* config/tc-i386.c: Revert 2009-06-13 change.
	* config/tc-i386.h: Likewise.
@
text
@d8090 4
a8093 1
#ifdef OBJ_MAYBE_COFF
@


1.387
log
@bfd/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* archures.c (bfd_architecture): Add bfd_arch_l1om.
	(bfd_l1om_arch): New.
	(bfd_archures_list): Add &bfd_l1om_arch.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf64_l1om_vec if
	bfd_elf64_x86_64_vec is supported.  Add bfd_elf64_l1om_freebsd_vec
	if bfd_elf64_x86_64_freebsd_vec is supported.
	(targ_selvecs): Likewise.

	* configure.in: Support bfd_elf64_l1om_vec and
	bfd_elf64_l1om_freebsd_vec.
	* configure: Regenerated.

	* cpu-l1om.c: New.

	* elf64-x86-64.c (elf64_l1om_elf_object_p): New.
	(bfd_elf64_l1om_vec): Likewise.
	(bfd_elf64_l1om_freebsd_vec): Likewise.

	* Makefile.am (ALL_MACHINES): Add cpu-l1om.lo.
	(ALL_MACHINES_CFILES): Add cpu-l1om.c.
	* Makefile.in: Regenerated.

	* targets.c (bfd_elf64_l1om_vec): New.
	(bfd_elf64_l1om_freebsd_vec): Likewise.
	(_bfd_target_vector): Add bfd_elf64_l1om_vec and
	bfd_elf64_l1om_freebsd_vec.

binutils/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (guess_is_rela): Handle EM_L1OM.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(get_section_type_name): Likewise.
	(get_elf_section_flags): Likewise.
	(get_symbol_index_type): Likewise.
	(is_32bit_abs_reloc): Likewise.
	(is_32bit_pcrel_reloc): Likewise.
	(is_64bit_abs_reloc): Likewise.
	(is_64bit_pcrel_reloc): Likewise.
	(is_none_reloc): Likewise.

gas/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add l1om.
	(check_cpu_arch_compatible): New.
	(set_cpu_arch): Use it.
	(i386_arch): New.
	(i386_mach): Return bfd_mach_l1om for Intel L1OM.
	(md_show_usage): Display l1om.
	(i386_target_format): Return ELF_TARGET_L1OM_FORMAT if
	cpu_arch_isa_flags.bitfield.cpul1om is set.

	* config/tc-i386.h (TARGET_ARCH): Use (i386_arch ()).
	(i386_arch): New.
	(ELF_TARGET_L1OM_FORMAT): Likewise.

	* doc/c-i386.texi: Document l1om.

gas/testsuite/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/l1om.d: New.
	* gas/i386/l1om-inval.l: Likewise.
	* gas/i386/l1om-inval.s: Likewise.

	* gas/i386/i386.exp: Run l1om-inval and l1om.

include/elf/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (EM_L1OM): New.

ld/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.tgt (targ64_extra_emuls): Add elf_l1om if elf_x86_64
	is supported.  Add elf_l1om_fbsd if elf_x86_64_fbsd is supported.
	(targ_extra_emuls): Likewise.

	* Makefile.am (ALL_64_EMULATIONS): Add eelf_l1om.o and
	eelf_l1om_fbsd.o
	(eelf_l1om.c): New.
	(eelf_l1om_fbsd.c): Likewise.
	* Makefile.in: Regenerated.

	* emulparams/elf_l1om.sh: New.
	* emulparams/elf_l1om_fbsd.sh: Likewise.

ld/testsuite/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/abs-l1om.d: New.
	* ld-x86-64/protected2-l1om.d: Likewise.
	* ld-x86-64/protected3-l1om.d: Likewise.

	* ld-x86-64/x86-64.exp: Run abs-l1om, protected2-l1om and
	protected3-l1om.

opcodes/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in: Handle bfd_l1om_arch.
	* disassemble.c (disassembler): Likewise.

	* configure: Regenerated.

	* i386-dis.c (print_insn): Handle bfd_mach_l1om and
	bfd_mach_l1om_intel_syntax.  Use 8 bytes per line for Intel L1OM.

	* i386-gen.c (cpu_flag_init): Set CPU_UNKNOWN_FLAGS to ~CpuL1OM.
	Add CPU_L1OM_FLAGS.
	(cpu_flags): Add CpuL1OM.
	(set_bitfield): Take an argument to set the value field.
	(process_i386_cpu_flag): Support ~CpuXXX and ~(CpuXXX|CpuYYY).
	(process_i386_opcode_modifier): Updated.
	(process_i386_operand_type): Likewise.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.

	* i386-opc.h (CpuL1OM): New.
	(CpuXsave): Updated.
	(i386_cpu_flags): Add cpul1om.
@
text
@a2568 4

  if (fixP->fx_addsy != NULL
      && symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_GNU_INDIRECT_FUNCTION)
    return 0;
d7367 1
a7367 1
	      && !TC_FORCE_RELOCATION (fixP))
@


1.386
log
@gas/
2009-07-24  Jan Beulich  <jbeulich@@novell.com>

	* tc-i386.c (cpu_arch): Add .8087, .287, .387, .no87, .nommx,
	.nosse, and .noavx.
	(cpu_flags_and_not): New.
	(set_cpu_arch): Check whether sub-architecture specified is a
	feature disable.
	(md_parse_option): Likewise.
	(parse_real_register): Don't return floating point register
	when x87 functionality is disabled.
	(md_show_usage): Add new sub-options.
	* doc/c-i386.texi: Update with new command line sub-options.

gas/testsuite/
2009-07-24  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/8087.[ds]: New.
	* gas/i386/287.[ds]: New.
	* gas/i386/387.[ds]: New.
	* gas/i386/no87.[ls]: New.
	* gas/i386/no87-2.[ls]: New.
	* gas/i386/i386.exp: Run new tests.
	* gas/i386/att-regs.s: Also check FPU register access.
	* gas/i386/intel-regs.s: Likewise.
	* gas/i386/att-regs.d: Adjust expectations.
	* gas/i386/intel-regs.d: Likewise.

opcodes/
2009-07-24  Jan Beulich  <jbeulich@@novell.com>

	* i386-dis.c (fgrps): Correct annotation for feni/fdisi. Add
	frstpm.
	* i386-gen.c (cpu_flag_init): Add FP enabling flags where needed.
	(cpu_flags): Add Cpu8087, Cpu287, Cpu387, Cpu687, and CpuFISTTP.
	(set_bitfield): Expand CpuFP to Cpu8087|Cpu287|Cpu387.
	* i386-opc.h (Cpu8087, Cpu287, Cpu387, Cpu687, CpuFISTTP):
	Define.
	(union i386_cpu_flags): Add cpu8087, cpu287, cpu387, cpu687,
	and cpufisttp.
	* i386-opc.tbl: Qualify floating point instructions by their
	respective CpuXXX flag. Fix fucom{,p,pp}, fprem1, fsin, fcos,
	and fsincos to be avilable only on 387. Fix fstsw ax to be
	available only on 287+. Add f{,n}eni, f{,n}disi, f{,n}setpm,
	and frstpm.
	* i386-init.h, i386-tbl.h: Regenerate.
@
text
@d580 2
d1961 29
d2005 2
d2085 14
d2103 10
a2112 1
    return bfd_mach_x86_64;
d7995 2
a7996 2
                           core, core2, corei7, k6, k6_2, athlon, k8, amdfam10,\n\
                           generic32, generic64\n\
d8007 2
a8008 2
                           core, core2, corei7, k6, k6_2, athlon, k8, amdfam10,\n\
                           generic32, generic64\n"));
d8106 9
a8114 1
	return flag_code == CODE_64BIT ? ELF_TARGET_FORMAT64 : ELF_TARGET_FORMAT;
@


1.385
log
@gas/

2009-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10420
	* config/tc-i386.c (i386_align_code): Tune for 32bit nops in
	64bit.
	(i386_target_format): Set cpu_arch_isa_flags.bitfield.cpulm
	for 64bit.

gas/testsuite/

2009-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10420
	* gas/i386/i386.exp: Run x86-64-nops-1-pentium.

	* gas/i386/x86-64-nops-1-pentium.d: New.
@
text
@d594 8
d604 2
d620 2
d624 2
d1253 18
d1999 6
a2004 2
	      flags = cpu_flags_or (cpu_arch_flags,
				    cpu_arch[i].flags);
d7523 6
d7804 7
a7810 2
		  flags = cpu_flags_or (cpu_arch_flags,
					cpu_arch[i].flags);
d7942 3
a7944 2
                           mmx, sse, sse2, sse3, ssse3, sse4.1, sse4.2, sse4,\n\
                           avx, vmx, smx, xsave, movbe, ept, aes, pclmul, fma,\n\
@


1.384
log
@2009-07-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Update operand types.
	(update_imm): Updated.
	(finalize_imm): Update the first 2 immediate operands only
	for instructions with 2 operands or more.
@
text
@d1045 10
a1054 2
	     its offset.  */
	  if (count < 15)
d7946 1
@


1.383
log
@2009-07-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Check implicit registers
	only for instructions with 3 operands or less.
@
text
@d2816 4
d4441 1
a4441 3
  i386_operand_type overlap;

  overlap = operand_type_and (i.types[j], i.tm.operand_types[j]);
d4505 1
a4505 1
  unsigned int j;
d4507 7
a4513 3
  for (j = 0; j < 2; j++)
    if (update_imm (j) == 0)
      return 0;
d4515 3
a4517 2
  i.types[2] = operand_type_and (i.types[2], i.tm.operand_types[2]);
  gas_assert (operand_type_check (i.types[2], imm) == 0);
@


1.382
log
@gas/

2009-07-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Only check i.operands for AX.
	(md_estimate_size_before_relax): Don't relax IFUNC symbols.

gas/testsuite/

2009-07-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run ifunc and x86-64-ifunc.

	* gas/i386/ifunc.d: New,
	* gas/i386/ifunc.s: Likewise.
	* gas/i386/x86-64-ifunc.d: Likewise.
@
text
@d2824 9
a2832 6
  for (j = 0; j < i.operands; j++)
    if (i.types[j].bitfield.inoutportreg
	|| i.types[j].bitfield.shiftcount
	|| i.types[j].bitfield.acc
	|| i.types[j].bitfield.floatacc)
      i.reg_operands--;
@


1.381
log
@<gas changes>
2009-07-06  Dwarakanath Rajagopal  <dwarak.rajagopal@@amd.com>

	* config/tc-i386.c (cpu_arch): Add .fma4 and CPU_FMA4_FLAGS.
	(build_modrm_byte): Add support to handle FMA4 instructions.
	(md_show_usage): Add fma4.

<gas/testsuite changes>
2009-07-06  Dwarakanath Rajagopal  <dwarak.rajagopal@@amd.com>

	* gas/i386/i386.exp: Add FMA4 tests.
	* gas/i386/x86-64-fma4.d: Ditto.
	* gas/i386/fma4.d: Ditto.
	* gas/i386/x86-64-fma4.s: Ditto.
	* gas/i386/fma4.s: Ditto.

<opcodes changes>
2009-07-06  Dwarakanath Rajagopal  <dwarak.rajagopal@@amd.com>

	* i386-opc.h (CpuFMA4): Add CpuFMA4.
	(i386_cpu_flags): New.
	* i386-gen.c: Add CPU_FMA4_FLAGS.
	* i386-opc.tbl: Add FMA4 instructions.
	* i386-tbl.h: Regenerate.
	* i386-init.h: Regenerate.
	* i386-dis.c (OP_VEX_FMA): New. Handle FMA4.
	(OP_XMM_VexW): Ditto.
	(OP_EX_VexW): Ditto.
	(VEXI4_Fixup): Ditto.
	(VexI4, VexFMA, Vex128FMA, EXVexW, EXdVexW, XMVexW): New Macros.
	(PREFIX_VEX_3A5C, PREFIX_VEX_3A5D, PREFIX_VEX_3A5E): New.
	(PREFIX_VEX_3A5F, PREFIX_VEX_3A60): New.
	(PREFIX_VEX_3A68, PREFIX_VEX_3A69, PREFIX_VEX_3A6A): New.
	(PREFIX_VEX_3A6B, PREFIX_VEX_3A6C, PREFIX_VEX_3A6D): New.
	(PREFIX_VEX_3A6E, PREFIX_VEX_3A6F, PREFIX_VEX_3A7A): New.
	(PREFIX_VEX_3A7B, PREFIX_VEX_3A7C, PREFIX_VEX_3A7D): New.
	(PREFIX_VEX_3A7E, PREFIX_VEX_3A7F): New.
	(VEX_LEN_3A6A_P_2,VEX_LEN_3A6B_P_2, VEX_LEN_3A6E_P_2): New.
	(VEX_LEN_3A6F_P_2,VEX_LEN_3A7A_P_2, VEX_LEN_3A7B_P_2): New.
	(VEX_LEN_3A7E_P_2,VEX_LEN_3A7F_P_2): New.
	(get_vex_imm8): New. handle FMA4.
	(OP_EX_VexReg): Ditto.
@
text
@d2824 1
a2824 1
  for (j = 0; j < 3; j++)
d6978 3
a6980 1
	      || S_IS_WEAK (fragP->fr_symbol)))
@


1.380
log
@2009-07-02  Tristan Gingold  <gingold@@adacore.com>

	* Makefile.am (OBJ_FORMATS): Add macho.
	(CPU_OBJ_VALID): Ditto.
	(OBJ_FORMAT_CFILES): Add config/obj-macho.c
	(OBJ_FORMAT_HFILES): Add config/obj-macho.h
	(obj-macho.o): New rule.
	* Makefile.in: Regenerated.
	* configure.tgt (generic_target): Add i386-*-darwin*.
	* config/tc-i386.h: Use i386_target_format for Mach-O.
	* config/tc-i386.c (i386_target_format): Define it for Mach-O.
	(i386_target_format): Add a case for bfd_target_mach_o_flavour.
	* config/obj-macho.h: New file.
	* config/obj-macho.c: New file.
@
text
@d626 2
d4762 7
a4770 2
      source = 1;
      reg = 0;
d4772 4
a4775 5
      /* This instruction must have 4 operands: 4 register operands
	 or 3 register operands plus 1 memory operand.  It must have
	 VexNDS and VexImmExt.  */
      gas_assert (i.operands == 4
		  && (i.reg_operands == 4
d4779 2
a4780 12
		  && (operand_type_equal (&i.tm.operand_types[dest],
					  &regxmm)
		      || operand_type_equal (&i.tm.operand_types[dest],
					     &regymm))
		  && (operand_type_equal (&i.tm.operand_types[nds],
					  &regxmm)
		      || operand_type_equal (&i.tm.operand_types[nds],
					     &regymm))
		  && (operand_type_equal (&i.tm.operand_types[reg],
					  &regxmm)
		      || operand_type_equal (&i.tm.operand_types[reg],
					     &regymm)));
d4788 26
d4816 2
a4817 3
	= ((i.op[0].regs->reg_num
	    + ((i.op[0].regs->reg_flags & RegRex) ? 8 : 0)) << 4);

a4954 1

d7878 1
a7878 1
                           svme, abm, padlock\n"));
@


1.379
log
@2009-06-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c: Reformat.
@
text
@d7884 1
a7884 1
     || defined (TE_PE) || defined (TE_PEP))
d7964 4
@


1.378
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d663 1
a663 1
  if (needs_align 
d667 1
a667 1
      
d1653 1
a1653 1
 
d1872 1
a1872 1
  
d2685 3
a2687 3
	  && (i.operands <= 2
	      || (i.tm.opcode_modifier.vex
		  && i.operands <= 4)));
d2793 1
a2793 1
	  && intel_syntax) 
d2907 1
a2907 1
if (i.rex != 0)
d3116 1
a3116 1
	      current_templates->start->name, 
d3333 1
a3333 1
	  { 
d4090 1
a4090 1
	  
d4453 1
a4453 1
	  if (i.suffix == BYTE_MNEM_SUFFIX) 
d4541 2
a4542 2
	      && MAX_OPERANDS > dup
	      && operand_type_equal (&i.types[dest], &regxmm));
d4571 1
a4571 1
	{ 
d4573 1
a4573 1
		  && i.tm.opcode_modifier.vex3sources);
d4585 1
a4585 1
	  i.types[0] = regxmm; 
d4619 2
a4620 2
	      && (operand_type_equal (&i.types[0], &regxmm)
		  || operand_type_equal (&i.types[0], &regymm)));
d4652 1
a4652 1
	      && i.op[first_reg_op + 1].regs == 0);
d4676 1
a4676 1
	  /* The register or float register operand is in operand 
d4679 6
a4684 6
	  
	   if (i.types[0].bitfield.floatreg
	       || operand_type_check (i.types[0], reg))
	     op = 0;
	   else
	     op = 1;
d4751 1
a4751 1
  int vex_3_sources; 
d4769 16
a4784 16
	      && (i.reg_operands == 4
		  || (i.reg_operands == 3 && i.mem_operands == 1))
	      && i.tm.opcode_modifier.vexnds
	      && i.tm.opcode_modifier.veximmext
	      && (operand_type_equal (&i.tm.operand_types[dest],
				      &regxmm)
		  || operand_type_equal (&i.tm.operand_types[dest],
					 &regymm))
	      && (operand_type_equal (&i.tm.operand_types[nds],
				      &regxmm)
		  || operand_type_equal (&i.tm.operand_types[nds],
					 &regymm))
	      && (operand_type_equal (&i.tm.operand_types[reg],
				      &regxmm)
		  || operand_type_equal (&i.tm.operand_types[reg],
					 &regymm)));
d4808 6
a4813 6
    if (i.mem_operands == 0
	   && ((i.reg_operands == 2
		&& !i.tm.opcode_modifier.vexndd)
	       || (i.reg_operands == 3
		   && i.tm.opcode_modifier.vexnds)
	       || (i.reg_operands == 4 && vex_3_sources)))
d4826 3
a4828 3
		  || (i.imm_operands == 0
		      && (i.tm.opcode_modifier.vexnds
			  || i.types[0].bitfield.shiftcount)));
d4844 6
a4849 6
		   && i.types[0].bitfield.imm8
		   && i.types[1].bitfield.imm8)
		  || (i.tm.opcode_modifier.vexnds
		      && i.imm_operands == 1
		      && (i.types[0].bitfield.imm8
			  || i.types[i.operands - 1].bitfield.imm8)));
d4931 5
a4935 4
	      for (op = 0; op < i.operands; op++)
		if (operand_type_check (i.types[op], anymem))
		  break;
	      gas_assert (op < i.operands);
d5134 24
a5157 16
	      unsigned int vex_reg = ~0;
	      
	      for (op = 0; op < i.operands; op++)
		if (i.types[op].bitfield.reg8
		    || i.types[op].bitfield.reg16
		    || i.types[op].bitfield.reg32
		    || i.types[op].bitfield.reg64
		    || i.types[op].bitfield.regmmx
		    || i.types[op].bitfield.regxmm
		    || i.types[op].bitfield.regymm
		    || i.types[op].bitfield.sreg2
		    || i.types[op].bitfield.sreg3
		    || i.types[op].bitfield.control
		    || i.types[op].bitfield.debug
		    || i.types[op].bitfield.test)
		  break;
d5159 1
a5159 3
	      if (vex_3_sources)
		op = dest;
	      else if (i.tm.opcode_modifier.vexnds)
d5161 2
a5162 14
		  /* For instructions with VexNDS, the register-only
		     source operand is encoded in VEX prefix. */
		  gas_assert (mem != (unsigned int) ~0);

		  if (op > mem)
		    {
		      vex_reg = op++;
		      gas_assert (op < i.operands);
		    }
		  else
		    {
		      vex_reg = op + 1;
		      gas_assert (vex_reg < i.operands);
		    }
d5164 1
a5164 1
	      else if (i.tm.opcode_modifier.vexndd)
a5165 5
		  /* For instructions with VexNDD, there should be
		     no memory operand and the register destination
		     is encoded in VEX prefix.  */
		  gas_assert (i.mem_operands == 0
			  && (op + 2) == i.operands);
d5167 1
d5169 12
a5180 2
	      else
		gas_assert (op < i.operands);
d5182 3
a5184 3
	      if (vex_reg != (unsigned int) ~0)
		{
		  gas_assert (i.reg_operands == 2);
d5186 7
a5192 7
		  if (!operand_type_equal (&i.tm.operand_types[vex_reg],
					   & regxmm)
		      && !operand_type_equal (&i.tm.operand_types[vex_reg],
					      &regymm))
		    abort ();
		  i.vex.register_specifier = i.op[vex_reg].regs;
		}
d5194 14
a5207 14
	      /* If there is an extension opcode to put here, the 
		 register number must be put into the regmem field.  */
	      if (i.tm.extension_opcode != None)
		{
		  i.rm.regmem = i.op[op].regs->reg_num;
		  if ((i.op[op].regs->reg_flags & RegRex) != 0)
		    i.rex |= REX_B;
		}
	      else
		{
		  i.rm.reg = i.op[op].regs->reg_num;
		  if ((i.op[op].regs->reg_flags & RegRex) != 0)
		    i.rex |= REX_R;
		}
d5926 1
a5926 1
      
d6961 1
a6961 1
      || (OUTPUT_FLAVOR == bfd_target_coff_flavour 
@


1.377
log
@bfd/

2009-06-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10269
	* elf32-i386.c: Include "objalloc.h" and "hashtab.h".
	(elf_i386_link_hash_table): Add loc_hash_table and
	loc_hash_memory.
	(elf_i386_local_hash): New.
	(elf_i386_local_htab_hash): Likewise.
	(elf_i386_local_htab_eq): Likewise.
	(elf_i386_get_local_sym_hash): Likewise.
	(elf_i386_link_hash_table_free): Likewise.
	(elf_i386_allocate_local_dynrelocs): Likewise.
	(elf_i386_finish_local_dynamic_symbol): Likewise.
	(bfd_elf64_bfd_link_hash_table_free): Likewise.
	(elf_i386_link_hash_table_create): Create loc_hash_table and
	loc_hash_memory.
	(elf_i386_check_relocs): Handle local STT_GNU_IFUNC symbols.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_sections): Likewise.
	(elf_i386_finish_dynamic_symbol): Check _DYNAMIC only if sym
	isn't NULL.

	* elf64-x86-64.c: Include "objalloc.h" and "hashtab.h".
	(elf64_x86_64_link_hash_table): Add loc_hash_table and
	loc_hash_memory.
	(elf64_x86_64_local_hash): New.
	(elf64_x86_64_local_htab_hash): Likewise.
	(elf64_x86_64_local_htab_eq): Likewise.
	(elf64_x86_64_get_local_sym_hash): Likewise.
	(elf64_x86_64_link_hash_table_free): Likewise.
	(elf64_x86_64_allocate_local_dynrelocs): Likewise.
	(elf64_x86_64_finish_local_dynamic_symbol): Likewise.
	(bfd_elf64_bfd_link_hash_table_free): Likewise.
	(elf64_x86_64_link_hash_table_create): Create loc_hash_table
	and loc_hash_memory.
	(elf64_x86_64_check_relocs): Handle local STT_GNU_IFUNC
	symbols.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_finish_dynamic_sections): Likewise.
	(elf64_x86_64_finish_dynamic_symbol): Check _DYNAMIC only if
	sym isn't NULL.

gas/

2009-06-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10269
	* config/tc-i386.c (md_apply_fix): Use TC_FORCE_RELOCATION
	instead of generic_force_reloc.

	* config/tc-i386.h (TC_FORCE_RELOCATION): New.

ld/testsuite/

2009-06-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10269
	*: ld-ifunc/ifunc-1-local-x86.d: New.
	*: ld-ifunc/ifunc-1-local-x86.s: Likewise.
	*: ld-ifunc/ifunc-2-local-i386.d: Likewise.
	*: ld-ifunc/ifunc-2-local-i386.s: Likewise.
	*: ld-ifunc/ifunc-2-local-x86-64.d: Likewise.
	*: ld-ifunc/ifunc-2-local-x86-64.s: Likewise.
	*: ld-ifunc/ifunc-4-local-x86.d: Likewise.
	*: ld-ifunc/ifunc-4-local-x86.s: Likewise.
	*: ld-ifunc/ifunc-5-local-i386.s: Likewise.
	*: ld-ifunc/ifunc-5-local-x86-64.s: Likewise.
	*: ld-ifunc/ifunc-5a-local-i386.d: Likewise.
	*: ld-ifunc/ifunc-5a-local-x86-64.d: Likewise.
	*: ld-ifunc/ifunc-5b-local-i386.d: Likewise.
	*: ld-ifunc/ifunc-5b-local-x86-64.d: Likewise.
@
text
@d1499 1
a1499 1
  assert (i.operands == 2);
d2567 1
a2567 1
      assert (i.rm.mode == 3);
d2684 1
a2684 1
  assert (i.imm_operands == 0
d4505 1
a4505 1
  assert (operand_type_check (i.types[2], imm) == 0);
d4540 1
a4540 1
      assert (i.reg_operands
d4547 1
a4547 1
	  assert (operand_type_equal (&i.types[0], &regxmm));
d4572 1
a4572 1
	  assert ((MAX_OPERANDS - 1) > dup
d4618 1
a4618 1
      assert (i.reg_operands
d4651 1
a4651 1
      assert (i.reg_operands == 1
d4768 1
a4768 1
      assert (i.operands == 4
d4825 1
a4825 1
	  assert (i.imm_operands == 1
d4843 1
a4843 1
	  assert ((i.imm_operands == 2
d4934 1
a4934 1
	      assert (op < i.operands);
d5112 1
a5112 1
	      assert (i.op[op].disps == 0);
d5156 1
a5156 1
		  assert (mem != (unsigned int) ~0);
d5161 1
a5161 1
		      assert (op < i.operands);
d5166 1
a5166 1
		      assert (vex_reg < i.operands);
d5174 1
a5174 1
		  assert (i.mem_operands == 0
d5179 1
a5179 1
		assert (op < i.operands);
d5183 1
a5183 1
		  assert (i.reg_operands == 2);
d5643 1
a5643 1
	      assert (!i.types[n].bitfield.disp8);
d5658 1
a5658 1
			assert (sz == 0);
d5663 1
a5663 1
		  assert (sz != 0);
d6534 1
a6534 1
	  assert (j < i386_regtab_size);
d7549 1
a7549 1
      assert (intel_syntax);
d8279 1
a8279 1
      assert (rel->howto != NULL);
d8329 1
a8329 1
      assert (exp.X_op == O_constant);
@


1.376
log
@	PR gas/977
	* config/tc-i386.c (md_estimate_size_before_relax):  Don't relax
	branches to weak symbols.
	(md_apply_fix):  Don't convert fixes against weak symbols to
	section-relative offsets, but save addend for later reloc emission.
	(tc_gen_reloc):  When emitting reloc against weak symbol, adjust
	addend to pre-compensate for bfd_install_relocation.
@
text
@d7238 1
a7238 1
	      && !generic_force_reloc (fixP))
@


1.375
log
@<gas changes>
2009-05-22  Dwarakanath Rajagopal  <dwarak.rajagopal@@amd.com>

	* config/tc-i386.c (process_drex): Delete. Remove SSE5 support.
	(build_modrm_byte): Remove DREX handling support.
	(DREX_*): Delete.
	(drex_byte): Delete.
	(md_assemble): Remove DREX handling support.
	(process_operands): Remove DREX, SSE5 support.
	(i386_insn): Remove DREX.

<gas/testsuite changes>
2009-05-22  Dwarakanath Rajagopal  <dwarak.rajagopal@@amd.com>

	* gas/i386/i386.exp: Remove SSE5 tests.
	* gas/i386/x86-64-sse5.s: Delete. Remove SSE5 tests.
	* gas/i386/x86-64-sse5.d: Ditto.
	* gas/i386/arch-10-1.l: Remove SSE5 tests.
	* gas/i386/arch-10-2.l: Ditto.
	* gas/i386/arch-10-3.l: Ditto.
	* gas/i386/arch-10-4.l: Ditto.
	* gas/i386/arch-10.d: Ditto.
	* gas/i386/arch-10.s: Ditto.
	* gas/i386/arch-4.s: Delete. Remove SSE5 tests.
	* gas/i386/arch-4.d: Ditto.
	* gas/i386/arch-8.s: Ditto.
	* gas/i386/arch-8.d: Ditto.
	* gas/i386/arch-2.s: Remove SSE5 tests.
	* gas/i386/arch-2.d: Remove SSE5 tests.
	* gas/i386/x86-64-arch-2.s: Ditto.

<opcodes changes>
2009-05-22  Dwarakanath Rajagopal  <dwarak.rajagopal@@amd.com>

	* i386-opc.h (Cpusse5): Delete.
	(i386_cpu_flags): Delete.
	* i386-gen.c: Remove CpuSSE5, Drex, Drexv and Drexc.
	* i386-opc.tbl: Remove SSE5 instructions.
	* i386-tbl.h: Regenerate.
	* i386-init.h: Regenerate.
	* i386-dis.c (OP_E_memeory, OP_E_extended): Remove drex handling.
	(print_drex_arg): Delete.
	(OP_DREX4): Delete.
	(OP_DREX3): Delete.
	(OP_DREX_ICMP): Delete.
	(OP_DREX_FCMP): Delete.
	(DREX_*): Delete.
	(THREE_BYTE_0F24, THREE_BYTE_0F25, THREE_BYTE_0f7B): Delete.
@
text
@d6959 4
d7256 6
d7325 10
d8237 5
a8241 1

@


1.374
log
@2009-05-20  Kai Tietz  <kai.tietz@@onevision.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-coff.h: Include "coff/x86_64.h" for x86 pe-coff.
	(TARGET_FORMAT): Removed for x86 pe-coff.
	(COFF_TARGET_FORMAT): Likewise.

	* config/tc-i386.c (md_longopts): Allow --64 for x86 pe-coff.
	(md_parse_option): Likewise.
	(md_show_usage): Show option --32/--64 for x86 pe-coff.
	(i386_target_format): Use also for x86 pe-coff.

	* config/tc-i386.h (TARGET_FORMAT): Defined as i386_target_format
	for x86 pe-coff.
@
text
@a116 27
/* The SSE5 instructions have a two bit instruction modifier (OC) that 
   is stored in two separate bytes in the instruction.  Pick apart OC 
   into the 2 separate bits for instruction.  */
#define DREX_OC0(x)	(((x) & 1) != 0)
#define DREX_OC1(x)	(((x) & 2) != 0)

#define DREX_OC0_MASK	(1 << 3)	/* set OC0 in byte 4 */
#define DREX_OC1_MASK	(1 << 2)	/* set OC1 in byte 3 */

/* OC mappings */
#define DREX_XMEM_X1_X2_X2 0	/* 4 op insn, dest = src3, src1 = reg/mem */
#define DREX_X1_XMEM_X2_X2 1	/* 4 op insn, dest = src3, src2 = reg/mem */
#define DREX_X1_XMEM_X2_X1 2	/* 4 op insn, dest = src1, src2 = reg/mem */
#define DREX_X1_X2_XMEM_X1 3	/* 4 op insn, dest = src1, src3 = reg/mem */

#define DREX_XMEM_X1_X2	   0	/* 3 op insn, src1 = reg/mem */
#define DREX_X1_XMEM_X2	   1	/* 3 op insn, src1 = reg/mem */

/* Information needed to create the DREX byte in SSE5 instructions.  */
typedef struct
{
  unsigned int reg;		/* register */
  unsigned int rex;		/* REX flags */
  unsigned int modrm_reg;	/* which arg goes in the modrm.reg field */
  unsigned int modrm_regmem;	/* which arg goes in the modrm.regmem field */
} drex_byte;

a169 1
static void process_drex (void);
d252 1
a252 3
       addressing modes of this insn are encoded.  DREX is the byte
       added by the SSE5 instructions.  */

a255 1
    drex_byte drex;
a649 2
  { ".sse5", PROCESSOR_UNKNOWN,
    CPU_SSE5_FLAGS },
a2185 2
  fprintf (stdout, "  drex:  reg %d rex 0x%x\n", 
	   x->drex.reg, x->drex.rex);
d2681 1
a2681 1
     SSE5 and AVX instructions also use this encoding, for some of
a2685 2
	      || (i.tm.cpu_flags.bitfield.cpusse5
		  && i.operands <= 3)
d2907 1
a2907 8
  /* If the instruction has the DREX attribute (aka SSE5), don't emit a
     REX prefix.  */
  if (i.tm.opcode_modifier.drex || i.tm.opcode_modifier.drexc)
    {
      i.drex.rex = i.rex;
      i.rex = 0;
    }
  else if (i.rex != 0)
a4509 330
static void
process_drex (void)
{
  i.drex.modrm_reg = 0;
  i.drex.modrm_regmem = 0;

  /* SSE5 4 operand instructions must have the destination the same as 
     one of the inputs.  Figure out the destination register and cache
     it away in the drex field, and remember which fields to use for 
     the modrm byte.  */
  if (i.tm.opcode_modifier.drex 
      && i.tm.opcode_modifier.drexv 
      && i.operands == 4)
    {
      i.tm.extension_opcode = None;

      /* Case 1: 4 operand insn, dest = src1, src3 = register.  */
      if (i.types[0].bitfield.regxmm != 0
	  && i.types[1].bitfield.regxmm != 0
	  && i.types[2].bitfield.regxmm != 0
	  && i.types[3].bitfield.regxmm != 0
	  && i.op[0].regs->reg_num == i.op[3].regs->reg_num
	  && i.op[0].regs->reg_flags == i.op[3].regs->reg_flags)
	{
	  /* Clear the arguments that are stored in drex.  */
	  operand_type_set (&i.types[0], 0); 
	  operand_type_set (&i.types[3], 0);
	  i.reg_operands -= 2;

	  /* There are two different ways to encode a 4 operand 
	     instruction with all registers that uses OC1 set to 
	     0 or 1.  Favor setting OC1 to 0 since this mimics the 
	     actions of other SSE5 assemblers.  Use modrm encoding 2 
	     for register/register.  Include the high order bit that 
	     is normally stored in the REX byte in the register
	     field.  */
	  i.tm.extension_opcode = DREX_X1_XMEM_X2_X1;
	  i.drex.modrm_reg = 2;
	  i.drex.modrm_regmem = 1;
	  i.drex.reg = (i.op[3].regs->reg_num
			+ ((i.op[3].regs->reg_flags & RegRex) ? 8 : 0));
	}

      /* Case 2: 4 operand insn, dest = src1, src3 = memory.  */
      else if (i.types[0].bitfield.regxmm != 0
	       && i.types[1].bitfield.regxmm != 0
	       && (i.types[2].bitfield.regxmm 
		   || operand_type_check (i.types[2], anymem))
	       && i.types[3].bitfield.regxmm != 0
	       && i.op[0].regs->reg_num == i.op[3].regs->reg_num
	       && i.op[0].regs->reg_flags == i.op[3].regs->reg_flags)
	{
	  /* clear the arguments that are stored in drex */
	  operand_type_set (&i.types[0], 0); 
	  operand_type_set (&i.types[3], 0);
	  i.reg_operands -= 2;

	  /* Specify the modrm encoding for memory addressing.  Include 
	     the high order bit that is normally stored in the REX byte
	     in the register field.  */
	  i.tm.extension_opcode = DREX_X1_X2_XMEM_X1;
	  i.drex.modrm_reg = 1;
	  i.drex.modrm_regmem = 2;
	  i.drex.reg = (i.op[3].regs->reg_num
			+ ((i.op[3].regs->reg_flags & RegRex) ? 8 : 0));
	}

      /* Case 3: 4 operand insn, dest = src1, src2 = memory.  */
      else if (i.types[0].bitfield.regxmm != 0
	       && operand_type_check (i.types[1], anymem) != 0
	       && i.types[2].bitfield.regxmm != 0
	       && i.types[3].bitfield.regxmm != 0
	       && i.op[0].regs->reg_num == i.op[3].regs->reg_num
	       && i.op[0].regs->reg_flags == i.op[3].regs->reg_flags)
	{
	  /* Clear the arguments that are stored in drex.  */
	  operand_type_set (&i.types[0], 0); 
	  operand_type_set (&i.types[3], 0);
	  i.reg_operands -= 2;

	  /* Specify the modrm encoding for memory addressing.  Include
	     the high order bit that is normally stored in the REX byte 
	     in the register field.  */
	  i.tm.extension_opcode = DREX_X1_XMEM_X2_X1;
	  i.drex.modrm_reg = 2;
	  i.drex.modrm_regmem = 1;
	  i.drex.reg = (i.op[3].regs->reg_num
			+ ((i.op[3].regs->reg_flags & RegRex) ? 8 : 0));
	}

      /* Case 4: 4 operand insn, dest = src3, src2 = register. */
      else if (i.types[0].bitfield.regxmm != 0
	       && i.types[1].bitfield.regxmm != 0
	       && i.types[2].bitfield.regxmm != 0
	       && i.types[3].bitfield.regxmm != 0
	       && i.op[2].regs->reg_num == i.op[3].regs->reg_num
	       && i.op[2].regs->reg_flags == i.op[3].regs->reg_flags)
	{
	  /* clear the arguments that are stored in drex */
	  operand_type_set (&i.types[2], 0); 
	  operand_type_set (&i.types[3], 0);
	  i.reg_operands -= 2;

	  /* There are two different ways to encode a 4 operand 
	     instruction with all registers that uses OC1 set to 
	     0 or 1.  Favor setting OC1 to 0 since this mimics the 
	     actions of other SSE5 assemblers.  Use modrm encoding 
	     2 for register/register.  Include the high order bit that 
	     is normally stored in the REX byte in the register 
	     field.  */
	  i.tm.extension_opcode = DREX_XMEM_X1_X2_X2;
	  i.drex.modrm_reg = 1;
	  i.drex.modrm_regmem = 0;

	  /* Remember the register, including the upper bits */
	  i.drex.reg = (i.op[3].regs->reg_num
			+ ((i.op[3].regs->reg_flags & RegRex) ? 8 : 0));
	}

      /* Case 5: 4 operand insn, dest = src3, src2 = memory.  */
      else if (i.types[0].bitfield.regxmm != 0
	       && (i.types[1].bitfield.regxmm 
		   || operand_type_check (i.types[1], anymem)) 
	       && i.types[2].bitfield.regxmm != 0
	       && i.types[3].bitfield.regxmm != 0
	       && i.op[2].regs->reg_num == i.op[3].regs->reg_num
	       && i.op[2].regs->reg_flags == i.op[3].regs->reg_flags)
	{
	  /* Clear the arguments that are stored in drex.  */
	  operand_type_set (&i.types[2], 0); 
	  operand_type_set (&i.types[3], 0);
	  i.reg_operands -= 2;

	  /* Specify the modrm encoding and remember the register 
	     including the bits normally stored in the REX byte. */
	  i.tm.extension_opcode = DREX_X1_XMEM_X2_X2;
	  i.drex.modrm_reg = 0;
	  i.drex.modrm_regmem = 1;
	  i.drex.reg = (i.op[3].regs->reg_num
			+ ((i.op[3].regs->reg_flags & RegRex) ? 8 : 0));
	}

      /* Case 6: 4 operand insn, dest = src3, src1 = memory.  */
      else if (operand_type_check (i.types[0], anymem) != 0
	       && i.types[1].bitfield.regxmm != 0
	       && i.types[2].bitfield.regxmm != 0
	       && i.types[3].bitfield.regxmm != 0
	       && i.op[2].regs->reg_num == i.op[3].regs->reg_num
	       && i.op[2].regs->reg_flags == i.op[3].regs->reg_flags)
	{
	  /* clear the arguments that are stored in drex */
	  operand_type_set (&i.types[2], 0); 
	  operand_type_set (&i.types[3], 0);
	  i.reg_operands -= 2;

	  /* Specify the modrm encoding and remember the register 
	     including the bits normally stored in the REX byte. */
	  i.tm.extension_opcode = DREX_XMEM_X1_X2_X2;
	  i.drex.modrm_reg = 1;
	  i.drex.modrm_regmem = 0;
	  i.drex.reg = (i.op[3].regs->reg_num
			+ ((i.op[3].regs->reg_flags & RegRex) ? 8 : 0));
	}

      else
	as_bad (_("Incorrect operands for the '%s' instruction"), 
		i.tm.name);
    }

  /* SSE5 instructions with the DREX byte where the only memory operand 
     is in the 2nd argument, and the first and last xmm register must 
     match, and is encoded in the DREX byte. */
  else if (i.tm.opcode_modifier.drex 
	   && !i.tm.opcode_modifier.drexv 
	   && i.operands == 4)
    {
      /* Case 1: 4 operand insn, dest = src1, src3 = reg/mem.  */
      if (i.types[0].bitfield.regxmm != 0
	  && (i.types[1].bitfield.regxmm 
	      || operand_type_check(i.types[1], anymem)) 
	  && i.types[2].bitfield.regxmm != 0
	  && i.types[3].bitfield.regxmm != 0
	  && i.op[0].regs->reg_num == i.op[3].regs->reg_num
	  && i.op[0].regs->reg_flags == i.op[3].regs->reg_flags)
	{
	  /* clear the arguments that are stored in drex */
	  operand_type_set (&i.types[0], 0); 
	  operand_type_set (&i.types[3], 0);
	  i.reg_operands -= 2;

	  /* Specify the modrm encoding and remember the register 
	     including the high bit normally stored in the REX 
	     byte.  */
	  i.drex.modrm_reg = 2;
	  i.drex.modrm_regmem = 1;
	  i.drex.reg = (i.op[3].regs->reg_num
			+ ((i.op[3].regs->reg_flags & RegRex) ? 8 : 0));
	}

      else
	as_bad (_("Incorrect operands for the '%s' instruction"), 
		i.tm.name);
    }

  /* SSE5 3 operand instructions that the result is a register, being 
     either operand can be a memory operand, using OC0 to note which 
     one is the memory.  */
  else if (i.tm.opcode_modifier.drex 
	   && i.tm.opcode_modifier.drexv
	   && i.operands == 3)
    {
      i.tm.extension_opcode = None;

      /* Case 1: 3 operand insn, src1 = register.  */
      if (i.types[0].bitfield.regxmm != 0
	  && i.types[1].bitfield.regxmm != 0
	  && i.types[2].bitfield.regxmm != 0)
	{
	  /* Clear the arguments that are stored in drex.  */
	  operand_type_set (&i.types[2], 0);
	  i.reg_operands--;

	  /* Specify the modrm encoding and remember the register 
	     including the high bit normally stored in the REX byte.  */
	  i.tm.extension_opcode = DREX_XMEM_X1_X2;
	  i.drex.modrm_reg = 1;
	  i.drex.modrm_regmem = 0;
	  i.drex.reg = (i.op[2].regs->reg_num
			+ ((i.op[2].regs->reg_flags & RegRex) ? 8 : 0));
	}

      /* Case 2: 3 operand insn, src1 = memory.  */
      else if (operand_type_check (i.types[0], anymem) != 0
	       && i.types[1].bitfield.regxmm != 0
	       && i.types[2].bitfield.regxmm != 0)
	{
	  /* Clear the arguments that are stored in drex.  */
	  operand_type_set (&i.types[2], 0);
	  i.reg_operands--;

	  /* Specify the modrm encoding and remember the register 
	     including the high bit normally stored in the REX 
	     byte.  */
	  i.tm.extension_opcode = DREX_XMEM_X1_X2;
	  i.drex.modrm_reg = 1;
	  i.drex.modrm_regmem = 0;
	  i.drex.reg = (i.op[2].regs->reg_num
			+ ((i.op[2].regs->reg_flags & RegRex) ? 8 : 0));
	}

      /* Case 3: 3 operand insn, src2 = memory.  */
      else if (i.types[0].bitfield.regxmm != 0
	       && operand_type_check (i.types[1], anymem) != 0
	       && i.types[2].bitfield.regxmm != 0)
	{
	  /* Clear the arguments that are stored in drex.  */
	  operand_type_set (&i.types[2], 0);
	  i.reg_operands--;

	  /* Specify the modrm encoding and remember the register 
	     including the high bit normally stored in the REX byte.  */
	  i.tm.extension_opcode = DREX_X1_XMEM_X2;
	  i.drex.modrm_reg = 0;
	  i.drex.modrm_regmem = 1;
	  i.drex.reg = (i.op[2].regs->reg_num
			+ ((i.op[2].regs->reg_flags & RegRex) ? 8 : 0));
	}

      else
	as_bad (_("Incorrect operands for the '%s' instruction"), 
		i.tm.name);
    }

  /* SSE5 4 operand instructions that are the comparison instructions 
     where the first operand is the immediate value of the comparison 
     to be done.  */
  else if (i.tm.opcode_modifier.drexc != 0 && i.operands == 4)
    {
      /* Case 1: 4 operand insn, src1 = reg/memory. */
      if (operand_type_check (i.types[0], imm) != 0
	  && (i.types[1].bitfield.regxmm 
	      || operand_type_check (i.types[1], anymem)) 
	  && i.types[2].bitfield.regxmm != 0
	  && i.types[3].bitfield.regxmm != 0)
	{
	  /* clear the arguments that are stored in drex */
	  operand_type_set (&i.types[3], 0);
	  i.reg_operands--;

	  /* Specify the modrm encoding and remember the register 
	     including the high bit normally stored in the REX byte.  */
	  i.drex.modrm_reg = 2;
	  i.drex.modrm_regmem = 1;
	  i.drex.reg = (i.op[3].regs->reg_num
			+ ((i.op[3].regs->reg_flags & RegRex) ? 8 : 0));
	}

      /* Case 2: 3 operand insn with ImmExt that places the 
	 opcode_extension as an immediate argument.  This is used for 
	 all of the varients of comparison that supplies the appropriate
	 value as part of the instruction.  */
      else if ((i.types[0].bitfield.regxmm
		|| operand_type_check (i.types[0], anymem)) 
	       && i.types[1].bitfield.regxmm != 0
	       && i.types[2].bitfield.regxmm != 0
	       && operand_type_check (i.types[3], imm) != 0)
	{
	  /* clear the arguments that are stored in drex */
	  operand_type_set (&i.types[2], 0);
	  i.reg_operands--;

	  /* Specify the modrm encoding and remember the register 
	     including the high bit normally stored in the REX byte.  */
	  i.drex.modrm_reg = 1;
	  i.drex.modrm_regmem = 0;
	  i.drex.reg = (i.op[2].regs->reg_num
			+ ((i.op[2].regs->reg_flags & RegRex) ? 8 : 0));
	}

      else
	as_bad (_("Incorrect operands for the '%s' instruction"), 
		i.tm.name);
    }

  else if (i.tm.opcode_modifier.drex 
	   || i.tm.opcode_modifier.drexv 
	   || i.tm.opcode_modifier.drexc)
    as_bad (_("Internal error for the '%s' instruction"), i.tm.name);
}

a4530 6
  /* Handle all of the DREX munging that SSE5 needs.  */
  if (i.tm.opcode_modifier.drex 
      || i.tm.opcode_modifier.drexv 
      || i.tm.opcode_modifier.drexc)
    process_drex ();

a4801 21
  /* SSE5 4 operand instructions are encoded in such a way that one of 
     the inputs must match the destination register.  Process_drex hides
     the 3rd argument in the drex field, so that by the time we get 
     here, it looks to GAS as if this is a 2 operand instruction.  */
  if ((i.tm.opcode_modifier.drex 
       || i.tm.opcode_modifier.drexv 
       || i.tm.opcode_modifier.drexc)
      && i.reg_operands == 2)
    {
      const reg_entry *reg = i.op[i.drex.modrm_reg].regs;
      const reg_entry *regmem = i.op[i.drex.modrm_regmem].regs;

      i.rm.reg = reg->reg_num;
      i.rm.regmem = regmem->reg_num;
      i.rm.mode = 3;
      if ((reg->reg_flags & RegRex) != 0)
	i.rex |= REX_R;
      if ((regmem->reg_flags & RegRex) != 0)
	i.rex |= REX_B;
    }

d4808 1
a4808 1
  else if (i.mem_operands == 0
a4930 8
 	  /* This has been precalculated for SSE5 instructions 
	     that have a DREX field earlier in process_drex.  */
 	  if (i.tm.opcode_modifier.drex 
	      || i.tm.opcode_modifier.drexv 
	      || i.tm.opcode_modifier.drexc)
 	    op = i.drex.modrm_regmem;
 	  else
 	    {
a4934 1
	    }
a5132 14

	  /* This has been precalculated for SSE5 instructions 
	     that have a DREX field earlier in process_drex.  */
	  if (i.tm.opcode_modifier.drex 
	      || i.tm.opcode_modifier.drexv 
	      || i.tm.opcode_modifier.drexc)
	    {
	      op = i.drex.modrm_reg;
	      i.rm.reg = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_R;
	    }
	  else
	    {
a5206 1
	    }
d5216 1
a5216 4
      if (i.tm.extension_opcode != None
	  && !(i.tm.opcode_modifier.drex 
	      || i.tm.opcode_modifier.drexv 
	      || i.tm.opcode_modifier.drexc))
a5549 7

	  /* On SSE5, encode the OC1 bit in the DREX field if this 
	     encoding has multiple formats.  */
	  if (i.tm.opcode_modifier.drex 
	      && i.tm.opcode_modifier.drexv 
	      && DREX_OC1 (i.tm.extension_opcode))
	    *p |= DREX_OC1_MASK;
a5569 14
      /* Write the DREX byte if needed.  */
      if (i.tm.opcode_modifier.drex || i.tm.opcode_modifier.drexc)
	{
	  p = frag_more (1);
	  *p = (((i.drex.reg & 0xf) << 4) | (i.drex.rex & 0x7));

	  /* Encode the OC0 bit if this encoding has multiple 
	     formats.  */
	  if ((i.tm.opcode_modifier.drex 
	       || i.tm.opcode_modifier.drexv) 
	      && DREX_OC0 (i.tm.extension_opcode))
	    *p |= DREX_OC0_MASK;
	}

d7837 1
a7837 1
                           sse5, svme, abm, padlock\n"));
@


1.373
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@d8021 2
a8022 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined(TE_PEP)
d8075 2
a8076 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined(TE_PEP)
d8263 2
a8264 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined(TE_PEP)
d8311 2
a8312 1
     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PEP))
d8369 1
a8369 1
#ifdef TE_PEP
d8371 1
a8371 2
      return flag_code == CODE_64BIT ? COFF_TARGET_FORMAT : "pe-i386";
      break;
@


1.372
log
@gas/
2009-04-20  Jan Beulich  <jbeulich@@novell.com>

	* Makefile.am: Add explicit dependency of tc-i386.o on
	tc-i386-intel.c.
	* Makefile.in: Likewise.
	* config/tc-i386.c (i386_finalize_immediate): Declare, broken
	out from i386_immediate.
	(i386_immediate): Slightly re-arrange, call
	i386_finalize_immediate.
	(i386_finalize_displacement): Declare, broken out from
	i386_displacement.
	(i386_displacement): Slightly re-arrange, call
	i386_finalize_displacement.
	(i386_intel_simplify, i386_intel_parse_name): Declare.
	(this_operand): Initialize to -1.
	(set_intel_syntax): Set expression rank for O_full_ptr.
	(md_assemble): Set this_operand back to -1 after parsing
	operands.
	(x86_cons): Negate intel_syntax to indicate state. Call
	i386_intel_simplify.
	(md_operand): Convert if to switch. Handle '[' for Intel
	syntax.
	(i386_intel_operand): Delete, including all helper functions
	and data.
	* config/tc-i386-intel.c: New file, all new code.
	* config/tc-i386.h (i386_operator): Declare.
	(md_operator): Define to i386_operator.
	(i386_need_index_operator): Declare.
	(md_need_index_operator): Define to i386_need_index_operator.
	(O_full_ptr): Define.

gas/testsuite/
2009-04-20  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/equ.s: Adjust.
	* gas/i386/equ.d: Remove reference to equ.e.
	* gas/i386/equ.e: Delete.
	* gas/i386/intel-expr.s: New.
	* gas/i386/intel-expr.d: New.
	* gas/i386/i386.exp: Run new test.
	* gas/i386/intel.s: Adjust.
	* gas/i386/intel.e: Remove no longer valid warning messages.
	* gas/i386/intel16.s: Adjust.
	* gas/i386/intel16.d: Remove reference to intel16.e.
	* gas/i386/intel16.e: Delete.
	* gas/i386/intelbad.s: Add more tests.
	* gas/i386/intelbad.l: Adjust.
	* gas/i386/intelok.s: Remove now unneeded equates. Add more
	tests.
	* gas/i386/intelok.d: Remove reference to intelok.e. Adjust.
	* gas/i386/intelok.e: Delete.
	* gas/i386/x86_64.s: Adjust.
	* gas/i386/x86_64.d: Remove reference to x86_64.e.
	* gas/i386/x86_64.e: Delete.
@
text
@d2502 4
@


1.371
log
@gas/
2009-04-15  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (process_operands): Print operands in
	correct order depending on intel_syntax.

gas/testsuite/
2009-04-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/intel.e: Adjust expectations.
@
text
@d174 4
d180 2
d386 1
a386 1
static int this_operand;
d1904 2
d2759 1
d6465 2
d6505 5
d6582 6
a6587 1
    free (gotfree_input_line);
d6589 8
a6596 6
  if (exp->X_op == O_absent
      || exp->X_op == O_illegal
      || exp->X_op == O_big
      || (gotfree_input_line
	  && (exp->X_op == O_constant
	      || exp->X_op == O_register)))
d6829 20
a6848 2
    free (gotfree_input_line);
  ret = 1;
d6875 1
a6875 4
	   || exp->X_op == O_big
	   || (gotfree_input_line
	       && (exp->X_op == O_constant
		   || exp->X_op == O_register)))
a6897 2
  RESTORE_END_STRING (disp_end);

d7952 1
a7952 1
  return 0;
d7958 4
a7961 1
  if (*input_line_pointer == REGISTER_PREFIX)
d7963 2
a7964 3
      char *end;
      const reg_entry *r = parse_real_register (input_line_pointer, &end);

d7971 20
d8703 1
a8703 1346

/* Parse operands using Intel syntax. This implements a recursive descent
   parser based on the BNF grammar published in Appendix B of the MASM 6.1
   Programmer's Guide.

   FIXME: We do not recognize the full operand grammar defined in the MASM
	  documentation.  In particular, all the structure/union and
	  high-level macro operands are missing.

   Uppercase words are terminals, lower case words are non-terminals.
   Objects surrounded by double brackets '[[' ']]' are optional. Vertical
   bars '|' denote choices. Most grammar productions are implemented in
   functions called 'intel_<production>'.

   Initial production is 'expr'.

    addOp		+ | -

    alpha		[a-zA-Z]

    binOp		& | AND | \| | OR | ^ | XOR

    byteRegister	AL | AH | BL | BH | CL | CH | DL | DH

    constant		digits [[ radixOverride ]]

    dataType		BYTE | WORD | DWORD | FWORD | QWORD | TBYTE | OWORD | XMMWORD | YMMWORD

    digits		decdigit
			| digits decdigit
			| digits hexdigit

    decdigit		[0-9]

    e04			e04 addOp e05
			| e05

    e05			e05 binOp e06
			| e06

    e06			e06 mulOp e09
			| e09

    e09			OFFSET e10
			| SHORT e10
			| + e10
			| - e10
			| ~ e10
			| NOT e10
			| e09 PTR e10
			| e09 : e10
			| e10

    e10			e10 [ expr ]
			| e11

    e11			( expr )
			| [ expr ]
			| constant
			| dataType
			| id
			| $
			| register

 => expr		expr cmpOp e04
			| e04

    gpRegister		AX | EAX | BX | EBX | CX | ECX | DX | EDX
			| BP | EBP | SP | ESP | DI | EDI | SI | ESI

    hexdigit		a | b | c | d | e | f
			| A | B | C | D | E | F

    id			alpha
			| id alpha
			| id decdigit

    mulOp		* | / | % | MOD | << | SHL | >> | SHR

    quote		" | '

    register		specialRegister
			| gpRegister
			| byteRegister

    segmentRegister	CS | DS | ES | FS | GS | SS

    specialRegister	CR0 | CR2 | CR3 | CR4
			| DR0 | DR1 | DR2 | DR3 | DR6 | DR7
			| TR3 | TR4 | TR5 | TR6 | TR7

    We simplify the grammar in obvious places (e.g., register parsing is
    done by calling parse_register) and eliminate immediate left recursion
    to implement a recursive-descent parser.

    expr	e04 expr'

    expr'	cmpOp e04 expr'
		| Empty

    e04		e05 e04'

    e04'	addOp e05 e04'
		| Empty

    e05		e06 e05'

    e05'	binOp e06 e05'
		| Empty

    e06		e09 e06'

    e06'	mulOp e09 e06'
		| Empty

    e09		OFFSET e10 e09'
		| SHORT e10'
		| + e10'
		| - e10'
		| ~ e10'
		| NOT e10'
		| e10 e09'

    e09'	PTR e10 e09'
		| : e10 e09'
		| Empty

    e10		e11 e10'

    e10'	[ expr ] e10'
		| Empty

    e11		( expr )
		| [ expr ]
		| BYTE
		| WORD
		| DWORD
		| FWORD
		| QWORD
		| TBYTE
		| OWORD
		| XMMWORD
		| YMMWORD
		| .
		| $
		| register
		| id
		| constant  */

/* Parsing structure for the intel syntax parser. Used to implement the
   semantic actions for the operand grammar.  */
struct intel_parser_s
  {
    char *op_string;		/* The string being parsed.  */
    int got_a_float;		/* Whether the operand is a float.  */
    int op_modifier;		/* Operand modifier.  */
    int is_mem;			/* 1 if operand is memory reference.  */
    int in_offset;		/* >=1 if parsing operand of offset.  */
    int in_bracket;		/* >=1 if parsing operand in brackets.  */
    const reg_entry *reg;	/* Last register reference found.  */
    char *disp;			/* Displacement string being built.  */
    char *next_operand;		/* Resume point when splitting operands.  */
  };

static struct intel_parser_s intel_parser;

/* Token structure for parsing intel syntax.  */
struct intel_token
  {
    int code;			/* Token code.  */
    const reg_entry *reg;	/* Register entry for register tokens.  */
    char *str;			/* String representation.  */
  };

static struct intel_token cur_token, prev_token;

/* Token codes for the intel parser. Since T_SHORT is already used
   by COFF, undefine it first to prevent a warning.  */
#define T_NIL		-1
#define T_CONST		1
#define T_REG		2
#define T_BYTE		3
#define T_WORD		4
#define T_DWORD		5
#define T_FWORD		6
#define T_QWORD		7
#define T_TBYTE		8
#define T_XMMWORD	9
#undef  T_SHORT
#define T_SHORT		10
#define T_OFFSET	11
#define T_PTR		12
#define T_ID		13
#define T_SHL		14
#define T_SHR		15
#define T_YMMWORD	16

/* Prototypes for intel parser functions.  */
static int intel_match_token (int);
static void intel_putback_token	(void);
static void intel_get_token (void);
static int intel_expr (void);
static int intel_e04 (void);
static int intel_e05 (void);
static int intel_e06 (void);
static int intel_e09 (void);
static int intel_e10 (void);
static int intel_e11 (void);

static int
i386_intel_operand (char *operand_string, int got_a_float)
{
  int ret;
  char *p;
  const reg_entry *final_base = i.base_reg;
  const reg_entry *final_index = i.index_reg;

  p = intel_parser.op_string = xstrdup (operand_string);
  intel_parser.disp = (char *) xmalloc (strlen (operand_string) + 1);

  for (;;)
    {
      /* Initialize token holders.  */
      cur_token.code = prev_token.code = T_NIL;
      cur_token.reg = prev_token.reg = NULL;
      cur_token.str = prev_token.str = NULL;

      /* Initialize parser structure.  */
      intel_parser.got_a_float = got_a_float;
      intel_parser.op_modifier = 0;
      intel_parser.is_mem = 0;
      intel_parser.in_offset = 0;
      intel_parser.in_bracket = 0;
      intel_parser.reg = NULL;
      intel_parser.disp[0] = '\0';
      intel_parser.next_operand = NULL;

      i.base_reg = NULL;
      i.index_reg = NULL;

      /* Read the first token and start the parser.  */
      intel_get_token ();
      ret = intel_expr ();

      if (!ret)
	break;

      if (cur_token.code != T_NIL)
	{
	  as_bad (_("invalid operand for '%s' ('%s' unexpected)"),
		  current_templates->start->name, cur_token.str);
	  ret = 0;
	}
      /* If we found a memory reference, hand it over to i386_displacement
	 to fill in the rest of the operand fields.  */
      else if (intel_parser.is_mem)
	{
	  if ((i.mem_operands == 1
	       && !current_templates->start->opcode_modifier.isstring)
	      || i.mem_operands == 2)
	    {
	      as_bad (_("too many memory references for '%s'"),
		      current_templates->start->name);
	      ret = 0;
	    }
	  else
	    {
	      char *s = intel_parser.disp;

	      if (!quiet_warnings && intel_parser.is_mem < 0)
		/* See the comments in intel_bracket_expr.  */
		as_warn (_("Treating `%s' as memory reference"), operand_string);

	      /* Add the displacement expression.  */
	      if (*s != '\0')
		ret = i386_displacement (s, s + strlen (s));
	      if (ret)
		{
		  /* Swap base and index in 16-bit memory operands like
		     [si+bx]. Since i386_index_check is also used in AT&T
		     mode we have to do that here.  */
		  if (i.base_reg
		      && i.index_reg
		      && i.base_reg->reg_type.bitfield.reg16
		      && i.index_reg->reg_type.bitfield.reg16
		      && i.base_reg->reg_num >= 6
		      && i.index_reg->reg_num < 6)
		    {
		      const reg_entry *base = i.index_reg;

		      i.index_reg = i.base_reg;
		      i.base_reg = base;
		    }
		  ret = i386_index_check (operand_string);
		}
	      if (ret)
		{
		  i.types[this_operand].bitfield.mem = 1;
		  i.mem_operands++;
		}
	    }
	}

      /* Constant and OFFSET expressions are handled by i386_immediate.  */
      else if ((intel_parser.op_modifier & (1 << T_OFFSET))
	       || intel_parser.reg == NULL)
	{
	  if (i.mem_operands < 2 && i.seg[i.mem_operands])
	    {
	      if (!(intel_parser.op_modifier & (1 << T_OFFSET)))
		as_warn (_("Segment override ignored"));
	      i.seg[i.mem_operands] = NULL;
	    }
	  ret = i386_immediate (intel_parser.disp);
	}

      if (!final_base && !final_index)
  	{
	  final_base = i.base_reg;
	  final_index = i.index_reg;
  	}

      if (intel_parser.next_operand && this_operand >= MAX_OPERANDS - 1)
	ret = 0;
      if (!ret || !intel_parser.next_operand)
	break;
      intel_parser.op_string = intel_parser.next_operand;
      this_operand = i.operands++;
      i.types[this_operand].bitfield.unspecified = 1;
    }

  free (p);
  free (intel_parser.disp);

  if (final_base || final_index)
    {
      i.base_reg = final_base;
      i.index_reg = final_index;
    }

  return ret;
}

#define NUM_ADDRESS_REGS (!!i.base_reg + !!i.index_reg)

/* expr	e04 expr'

   expr'  cmpOp e04 expr'
	| Empty  */
static int
intel_expr (void)
{
  /* XXX Implement the comparison operators.  */
  return intel_e04 ();
}

/* e04	e05 e04'

   e04'	addOp e05 e04'
	| Empty  */
static int
intel_e04 (void)
{
  int nregs = -1;

  for (;;)
    {
      if (!intel_e05())
	return 0;

      if (nregs >= 0 && NUM_ADDRESS_REGS > nregs)
	i.base_reg = i386_regtab + REGNAM_AL; /* al is invalid as base */

      if (cur_token.code == '+')
	nregs = -1;
      else if (cur_token.code == '-')
	nregs = NUM_ADDRESS_REGS;
      else
	return 1;

      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (cur_token.code);
    }
}

/* e05	e06 e05'

   e05'	binOp e06 e05'
	| Empty  */
static int
intel_e05 (void)
{
  int nregs = ~NUM_ADDRESS_REGS;

  for (;;)
    {
      if (!intel_e06())
	return 0;

      if (cur_token.code == '&'
	  || cur_token.code == '|'
	  || cur_token.code == '^')
	{
	  char str[2];

	  str[0] = cur_token.code;
	  str[1] = 0;
	  strcat (intel_parser.disp, str);
	}
      else
	break;

      intel_match_token (cur_token.code);

      if (nregs < 0)
	nregs = ~nregs;
    }
  if (nregs >= 0 && NUM_ADDRESS_REGS > nregs)
    i.base_reg = i386_regtab + REGNAM_AL + 1; /* cl is invalid as base */
  return 1;
}

/* e06	e09 e06'

   e06'	mulOp e09 e06'
	| Empty  */
static int
intel_e06 (void)
{
  int nregs = ~NUM_ADDRESS_REGS;

  for (;;)
    {
      if (!intel_e09())
	return 0;

      if (cur_token.code == '*'
	  || cur_token.code == '/'
	  || cur_token.code == '%')
	{
	  char str[2];

	  str[0] = cur_token.code;
	  str[1] = 0;
	  strcat (intel_parser.disp, str);
	}
      else if (cur_token.code == T_SHL)
	strcat (intel_parser.disp, "<<");
      else if (cur_token.code == T_SHR)
	strcat (intel_parser.disp, ">>");
      else
	break;

      intel_match_token (cur_token.code);

      if (nregs < 0)
	nregs = ~nregs;
    }
  if (nregs >= 0 && NUM_ADDRESS_REGS > nregs)
    i.base_reg = i386_regtab + REGNAM_AL + 2; /* dl is invalid as base */
  return 1;
}

/* e09	OFFSET e09
	| SHORT e09
	| + e09
	| - e09
	| ~ e09
	| NOT e09
	| e10 e09'

   e09'	PTR e10 e09'
	| : e10 e09'
	| Empty */
static int
intel_e09 (void)
{
  int nregs = ~NUM_ADDRESS_REGS;
  int in_offset = 0;

  for (;;)
    {
      /* Don't consume constants here.  */
      if (cur_token.code == '+' || cur_token.code == '-')
	{
	  /* Need to look one token ahead - if the next token
	     is a constant, the current token is its sign.  */
	  int next_code;

	  intel_match_token (cur_token.code);
	  next_code = cur_token.code;
	  intel_putback_token ();
	  if (next_code == T_CONST)
	    break;
	}

      /* e09  OFFSET e09  */
      if (cur_token.code == T_OFFSET)
	{
	  if (!in_offset++)
	    ++intel_parser.in_offset;
	}

      /* e09  SHORT e09  */
      else if (cur_token.code == T_SHORT)
	intel_parser.op_modifier |= 1 << T_SHORT;

      /* e09  + e09  */
      else if (cur_token.code == '+')
	strcat (intel_parser.disp, "+");

      /* e09  - e09
	      | ~ e09
	      | NOT e09  */
      else if (cur_token.code == '-' || cur_token.code == '~')
	{
	  char str[2];

	  if (nregs < 0)
	    nregs = ~nregs;
	  str[0] = cur_token.code;
	  str[1] = 0;
	  strcat (intel_parser.disp, str);
	}

      /* e09  e10 e09'  */
      else
	break;

      intel_match_token (cur_token.code);
    }

  for (;;)
    {
      if (!intel_e10 ())
	return 0;

      /* e09'  PTR e10 e09' */
      if (cur_token.code == T_PTR)
	{
	  char suffix;

	  if (prev_token.code == T_BYTE)
	    {
	      suffix = BYTE_MNEM_SUFFIX;
	      i.types[this_operand].bitfield.byte = 1;
	    }

	  else if (prev_token.code == T_WORD)
	    {
	      if ((current_templates->start->name[0] == 'l'
		   && current_templates->start->name[2] == 's'
		   && current_templates->start->name[3] == 0)
		  || current_templates->start->base_opcode == 0x62 /* bound */)
		suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
	      else if (intel_parser.got_a_float == 2)	/* "fi..." */
		suffix = SHORT_MNEM_SUFFIX;
	      else
		suffix = WORD_MNEM_SUFFIX;
	      i.types[this_operand].bitfield.word = 1;
	    }

	  else if (prev_token.code == T_DWORD)
	    {
	      if ((current_templates->start->name[0] == 'l'
		   && current_templates->start->name[2] == 's'
		   && current_templates->start->name[3] == 0)
		  || current_templates->start->base_opcode == 0x62 /* bound */)
		suffix = WORD_MNEM_SUFFIX;
	      else if (flag_code == CODE_16BIT
		       && (current_templates->start->opcode_modifier.jump
			   || current_templates->start->opcode_modifier.jumpdword))
		suffix = LONG_DOUBLE_MNEM_SUFFIX;
	      else if (intel_parser.got_a_float == 1)	/* "f..." */
		suffix = SHORT_MNEM_SUFFIX;
	      else
		suffix = LONG_MNEM_SUFFIX;
	      i.types[this_operand].bitfield.dword = 1;
	    }

	  else if (prev_token.code == T_FWORD)
	    {
	      if (current_templates->start->name[0] == 'l'
		  && current_templates->start->name[2] == 's'
		  && current_templates->start->name[3] == 0)
		suffix = LONG_MNEM_SUFFIX;
	      else if (!intel_parser.got_a_float)
		{
		  if (flag_code == CODE_16BIT)
		    add_prefix (DATA_PREFIX_OPCODE);
		  suffix = LONG_DOUBLE_MNEM_SUFFIX;
		}
	      else
		suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
	      i.types[this_operand].bitfield.fword = 1;
	    }

	  else if (prev_token.code == T_QWORD)
	    {
	      if (current_templates->start->base_opcode == 0x62 /* bound */
		  || intel_parser.got_a_float == 1)	/* "f..." */
		suffix = LONG_MNEM_SUFFIX;
	      else
		suffix = QWORD_MNEM_SUFFIX;
	      i.types[this_operand].bitfield.qword = 1;
	    }

	  else if (prev_token.code == T_TBYTE)
	    {
	      if (intel_parser.got_a_float == 1)
		suffix = LONG_DOUBLE_MNEM_SUFFIX;
	      else
		suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
	    }

	  else if (prev_token.code == T_XMMWORD)
	    {
	      suffix = XMMWORD_MNEM_SUFFIX;
	      i.types[this_operand].bitfield.xmmword = 1;
	    }

	  else if (prev_token.code == T_YMMWORD)
	    {
	      suffix = YMMWORD_MNEM_SUFFIX;
	      i.types[this_operand].bitfield.ymmword = 1;
	    }

	  else
	    {
	      as_bad (_("Unknown operand modifier `%s'"), prev_token.str);
	      return 0;
	    }

	  i.types[this_operand].bitfield.unspecified = 0;

	  /* Operands for jump/call using 'ptr' notation denote absolute
	     addresses.  */
	  if (current_templates->start->opcode_modifier.jump
	      || current_templates->start->opcode_modifier.jumpdword)
	    i.types[this_operand].bitfield.jumpabsolute = 1;

	  if (current_templates->start->base_opcode == 0x8d /* lea */)
	    ;
	  else if (!i.suffix)
	    i.suffix = suffix;
	  else if (i.suffix != suffix)
	    {
	      as_bad (_("Conflicting operand modifiers"));
	      return 0;
	    }

	}

      /* e09'  : e10 e09'  */
      else if (cur_token.code == ':')
	{
	  if (prev_token.code != T_REG)
	    {
	      /* While {call,jmp} SSSS:OOOO is MASM syntax only when SSSS is a
		 segment/group identifier (which we don't have), using comma
		 as the operand separator there is even less consistent, since
		 there all branches only have a single operand.  */
	      if (this_operand != 0
		  || intel_parser.in_offset
		  || intel_parser.in_bracket
		  || (!current_templates->start->opcode_modifier.jump
		      && !current_templates->start->opcode_modifier.jumpdword
		      && !current_templates->start->opcode_modifier.jumpintersegment
		      && !current_templates->start->operand_types[0].bitfield.jumpabsolute))
		return intel_match_token (T_NIL);
	      /* Remember the start of the 2nd operand and terminate 1st
		 operand here.
		 XXX This isn't right, yet (when SSSS:OOOO is right operand of
		 another expression), but it gets at least the simplest case
		 (a plain number or symbol on the left side) right.  */
	      intel_parser.next_operand = intel_parser.op_string;
	      *--intel_parser.op_string = '\0';
	      return intel_match_token (':');
	    }
	}

      /* e09'  Empty  */
      else
	break;

      intel_match_token (cur_token.code);

    }

  if (in_offset)
    {
      --intel_parser.in_offset;
      if (nregs < 0)
	nregs = ~nregs;
      if (NUM_ADDRESS_REGS > nregs)
	{
	  as_bad (_("Invalid operand to `OFFSET'"));
	  return 0;
	}
      intel_parser.op_modifier |= 1 << T_OFFSET;
    }

  if (nregs >= 0 && NUM_ADDRESS_REGS > nregs)
    i.base_reg = i386_regtab + REGNAM_AL + 3; /* bl is invalid as base */
  return 1;
}

static int
intel_bracket_expr (void)
{
  int was_offset = intel_parser.op_modifier & (1 << T_OFFSET);
  const char *start = intel_parser.op_string;
  int len;

  if (i.op[this_operand].regs)
    return intel_match_token (T_NIL);

  intel_match_token ('[');

  /* Mark as a memory operand only if it's not already known to be an
     offset expression.  If it's an offset expression, we need to keep
     the brace in.  */
  if (!intel_parser.in_offset)
    {
      ++intel_parser.in_bracket;

      /* Operands for jump/call inside brackets denote absolute addresses.  */
      if (current_templates->start->opcode_modifier.jump
	  || current_templates->start->opcode_modifier.jumpdword)
	i.types[this_operand].bitfield.jumpabsolute = 1;

      /* Unfortunately gas always diverged from MASM in a respect that can't
	 be easily fixed without risking to break code sequences likely to be
	 encountered (the testsuite even check for this): MASM doesn't consider
	 an expression inside brackets unconditionally as a memory reference.
	 When that is e.g. a constant, an offset expression, or the sum of the
	 two, this is still taken as a constant load. gas, however, always
	 treated these as memory references. As a compromise, we'll try to make
	 offset expressions inside brackets work the MASM way (since that's
	 less likely to be found in real world code), but make constants alone
	 continue to work the traditional gas way. In either case, issue a
	 warning.  */
      intel_parser.op_modifier &= ~was_offset;
    }
  else
    strcat (intel_parser.disp, "[");

  /* Add a '+' to the displacement string if necessary.  */
  if (*intel_parser.disp != '\0'
      && *(intel_parser.disp + strlen (intel_parser.disp) - 1) != '+')
    strcat (intel_parser.disp, "+");

  if (intel_expr ()
      && (len = intel_parser.op_string - start - 1,
	  intel_match_token (']')))
    {
      /* Preserve brackets when the operand is an offset expression.  */
      if (intel_parser.in_offset)
	strcat (intel_parser.disp, "]");
      else
	{
	  --intel_parser.in_bracket;
	  if (i.base_reg || i.index_reg)
	    intel_parser.is_mem = 1;
	  if (!intel_parser.is_mem)
	    {
	      if (!(intel_parser.op_modifier & (1 << T_OFFSET)))
		/* Defer the warning until all of the operand was parsed.  */
		intel_parser.is_mem = -1;
	      else if (!quiet_warnings)
		as_warn (_("`[%.*s]' taken to mean just `%.*s'"),
			 len, start, len, start);
	    }
	}
      intel_parser.op_modifier |= was_offset;

      return 1;
    }
  return 0;
}

/* e10	e11 e10'

   e10'	[ expr ] e10'
	| Empty  */
static int
intel_e10 (void)
{
  if (!intel_e11 ())
    return 0;

  while (cur_token.code == '[')
    {
      if (!intel_bracket_expr ())
	return 0;
    }

  return 1;
}

/* e11	( expr )
	| [ expr ]
	| BYTE
	| WORD
	| DWORD
	| FWORD
	| QWORD
	| TBYTE
	| OWORD
	| XMMWORD
	| YMMWORD
	| $
	| .
	| register
	| id
	| constant  */
static int
intel_e11 (void)
{
  switch (cur_token.code)
    {
    /* e11  ( expr ) */
    case '(':
      intel_match_token ('(');
      strcat (intel_parser.disp, "(");

      if (intel_expr () && intel_match_token (')'))
	{
	  strcat (intel_parser.disp, ")");
	  return 1;
	}
      return 0;

    /* e11  [ expr ] */
    case '[':
      return intel_bracket_expr ();

    /* e11  $
	    | .  */
    case '.':
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (cur_token.code);

      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  */
      if (!intel_parser.in_offset)
	intel_parser.is_mem = 1;

      return 1;

    /* e11  register  */
    case T_REG:
      {
	const reg_entry *reg = intel_parser.reg = cur_token.reg;

	intel_match_token (T_REG);

	/* Check for segment change.  */
	if (cur_token.code == ':')
	  {
	    if (!reg->reg_type.bitfield.sreg2
		&& !reg->reg_type.bitfield.sreg3)
	      {
		as_bad (_("`%s' is not a valid segment register"),
			reg->reg_name);
		return 0;
	      }
	    else if (i.mem_operands >= 2)
	      as_warn (_("Segment override ignored"));
	    else if (i.seg[i.mem_operands])
	      as_warn (_("Extra segment override ignored"));
	    else
	      {
		if (!intel_parser.in_offset)
		  intel_parser.is_mem = 1;
		switch (reg->reg_num)
		  {
		  case 0:
		    i.seg[i.mem_operands] = &es;
		    break;
		  case 1:
		    i.seg[i.mem_operands] = &cs;
		    break;
		  case 2:
		    i.seg[i.mem_operands] = &ss;
		    break;
		  case 3:
		    i.seg[i.mem_operands] = &ds;
		    break;
		  case 4:
		    i.seg[i.mem_operands] = &fs;
		    break;
		  case 5:
		    i.seg[i.mem_operands] = &gs;
		    break;
		  }
	      }
	  }

	else if (reg->reg_type.bitfield.sreg3 && reg->reg_num == RegFlat)
	  {
	    as_bad (_("cannot use `FLAT' here"));
	    return 0;
	  }

	/* Not a segment register. Check for register scaling.  */
	else if (cur_token.code == '*')
	  {
	    if (!intel_parser.in_bracket)
	      {
		as_bad (_("Register scaling only allowed in memory operands"));
		return 0;
	      }

	    if (reg->reg_type.bitfield.reg16) /* Disallow things like [si*1]. */
	      reg = i386_regtab + REGNAM_AX + 4; /* sp is invalid as index */
	    else if (i.index_reg)
	      reg = i386_regtab + REGNAM_EAX + 4; /* esp is invalid as index */

	    /* What follows must be a valid scale.  */
	    intel_match_token ('*');
	    i.index_reg = reg;
	    i.types[this_operand].bitfield.baseindex = 1;

	    /* Set the scale after setting the register (otherwise,
	       i386_scale will complain)  */
	    if (cur_token.code == '+' || cur_token.code == '-')
	      {
		char *str, sign = cur_token.code;
		intel_match_token (cur_token.code);
		if (cur_token.code != T_CONST)
		  {
		    as_bad (_("Syntax error: Expecting a constant, got `%s'"),
			    cur_token.str);
		    return 0;
		  }
		str = (char *) xmalloc (strlen (cur_token.str) + 2);
		strcpy (str + 1, cur_token.str);
		*str = sign;
		if (!i386_scale (str))
		  return 0;
		free (str);
	      }
	    else if (!i386_scale (cur_token.str))
	      return 0;
	    intel_match_token (cur_token.code);
	  }

	/* No scaling. If this is a memory operand, the register is either a
	   base register (first occurrence) or an index register (second
	   occurrence).  */
	else if (intel_parser.in_bracket)
	  {

	    if (!i.base_reg)
	      i.base_reg = reg;
	    else if (!i.index_reg)
	      i.index_reg = reg;
	    else
	      {
		as_bad (_("Too many register references in memory operand"));
		return 0;
	      }

	    i.types[this_operand].bitfield.baseindex = 1;
	  }

	/* It's neither base nor index.  */
	else if (!intel_parser.in_offset && !intel_parser.is_mem)
	  {
	    i386_operand_type temp = reg->reg_type;
	    temp.bitfield.baseindex = 0;
	    i.types[this_operand] = operand_type_or (i.types[this_operand],
						     temp);
	    i.types[this_operand].bitfield.unspecified = 0;
	    i.op[this_operand].regs = reg;
	    i.reg_operands++;
	  }
	else
	  {
	    as_bad (_("Invalid use of register"));
	    return 0;
	  }

	/* Since registers are not part of the displacement string (except
	   when we're parsing offset operands), we may need to remove any
	   preceding '+' from the displacement string.  */
	if (*intel_parser.disp != '\0'
	    && !intel_parser.in_offset)
	  {
	    char *s = intel_parser.disp;
	    s += strlen (s) - 1;
	    if (*s == '+')
	      *s = '\0';
	  }

	return 1;
      }

    /* e11  BYTE
	    | WORD
	    | DWORD
	    | FWORD
	    | QWORD
	    | TBYTE
	    | OWORD
	    | XMMWORD
	    | YMMWORD  */
    case T_BYTE:
    case T_WORD:
    case T_DWORD:
    case T_FWORD:
    case T_QWORD:
    case T_TBYTE:
    case T_XMMWORD:
    case T_YMMWORD:
      intel_match_token (cur_token.code);

      if (cur_token.code == T_PTR)
	return 1;

      /* It must have been an identifier.  */
      intel_putback_token ();
      cur_token.code = T_ID;
      /* FALLTHRU */

    /* e11  id
	    | constant  */
    case T_ID:
      if (!intel_parser.in_offset && intel_parser.is_mem <= 0)
	{
	  symbolS *symbolP;

	  /* The identifier represents a memory reference only if it's not
	     preceded by an offset modifier and if it's not an equate.  */
	  symbolP = symbol_find(cur_token.str);
	  if (!symbolP || S_GET_SEGMENT(symbolP) != absolute_section)
	    intel_parser.is_mem = 1;
	}
	/* FALLTHRU */

    case T_CONST:
    case '-':
    case '+':
      {
	char *save_str, sign = 0;

	/* Allow constants that start with `+' or `-'.  */
	if (cur_token.code == '-' || cur_token.code == '+')
	  {
	    sign = cur_token.code;
	    intel_match_token (cur_token.code);
	    if (cur_token.code != T_CONST)
	      {
		as_bad (_("Syntax error: Expecting a constant, got `%s'"),
			cur_token.str);
		return 0;
	      }
	  }

	save_str = (char *) xmalloc (strlen (cur_token.str) + 2);
	strcpy (save_str + !!sign, cur_token.str);
	if (sign)
	  *save_str = sign;

	/* Get the next token to check for register scaling.  */
	intel_match_token (cur_token.code);

	/* Check if this constant is a scaling factor for an
	   index register.  */
	if (cur_token.code == '*')
	  {
	    if (intel_match_token ('*') && cur_token.code == T_REG)
	      {
		const reg_entry *reg = cur_token.reg;

		if (!intel_parser.in_bracket)
		  {
		    as_bad (_("Register scaling only allowed "
			      "in memory operands"));
		    return 0;
		  }

		 /* Disallow things like [1*si].
		    sp and esp are invalid as index.  */
		if (reg->reg_type.bitfield.reg16)
		  reg = i386_regtab + REGNAM_AX + 4;
		else if (i.index_reg)
		  reg = i386_regtab + REGNAM_EAX + 4;

		/* The constant is followed by `* reg', so it must be
		   a valid scale.  */
		i.index_reg = reg;
		i.types[this_operand].bitfield.baseindex = 1;

		/* Set the scale after setting the register (otherwise,
		   i386_scale will complain)  */
		if (!i386_scale (save_str))
		  return 0;
		intel_match_token (T_REG);

		/* Since registers are not part of the displacement
		   string, we may need to remove any preceding '+' from
		   the displacement string.  */
		if (*intel_parser.disp != '\0')
		  {
		    char *s = intel_parser.disp;
		    s += strlen (s) - 1;
		    if (*s == '+')
		      *s = '\0';
		  }

		free (save_str);

		return 1;
	      }

	    /* The constant was not used for register scaling. Since we have
	       already consumed the token following `*' we now need to put it
	       back in the stream.  */
	    intel_putback_token ();
	  }

	/* Add the constant to the displacement string.  */
	strcat (intel_parser.disp, save_str);
	free (save_str);

	return 1;
      }
    }

  as_bad (_("Unrecognized token '%s'"), cur_token.str);
  return 0;
}

/* Match the given token against cur_token. If they match, read the next
   token from the operand string.  */
static int
intel_match_token (int code)
{
  if (cur_token.code == code)
    {
      intel_get_token ();
      return 1;
    }
  else
    {
      as_bad (_("Unexpected token `%s'"), cur_token.str);
      return 0;
    }
}

/* Read a new token from intel_parser.op_string and store it in cur_token.  */
static void
intel_get_token (void)
{
  char *end_op;
  const reg_entry *reg;
  struct intel_token new_token;

  new_token.code = T_NIL;
  new_token.reg = NULL;
  new_token.str = NULL;

  /* Free the memory allocated to the previous token and move
     cur_token to prev_token.  */
  if (prev_token.str)
    free (prev_token.str);

  prev_token = cur_token;

  /* Skip whitespace.  */
  while (is_space_char (*intel_parser.op_string))
    intel_parser.op_string++;

  /* Return an empty token if we find nothing else on the line.  */
  if (*intel_parser.op_string == '\0')
    {
      cur_token = new_token;
      return;
    }

  /* The new token cannot be larger than the remainder of the operand
     string.  */
  new_token.str = (char *) xmalloc (strlen (intel_parser.op_string) + 1);
  new_token.str[0] = '\0';

  if (strchr ("0123456789", *intel_parser.op_string))
    {
      char *p = new_token.str;
      char *q = intel_parser.op_string;
      new_token.code = T_CONST;

      /* Allow any kind of identifier char to encompass floating point and
	 hexadecimal numbers.  */
      while (is_identifier_char (*q))
	*p++ = *q++;
      *p = '\0';

      /* Recognize special symbol names [0-9][bf].  */
      if (strlen (intel_parser.op_string) == 2
	  && (intel_parser.op_string[1] == 'b'
	      || intel_parser.op_string[1] == 'f'))
	new_token.code = T_ID;
    }

  else if ((reg = parse_register (intel_parser.op_string, &end_op)) != NULL)
    {
      size_t len = end_op - intel_parser.op_string;

      new_token.code = T_REG;
      new_token.reg = reg;

      memcpy (new_token.str, intel_parser.op_string, len);
      new_token.str[len] = '\0';
    }

  else if (is_identifier_char (*intel_parser.op_string))
    {
      char *p = new_token.str;
      char *q = intel_parser.op_string;

      /* A '.' or '$' followed by an identifier char is an identifier.
	 Otherwise, it's operator '.' followed by an expression.  */
      if ((*q == '.' || *q == '$') && !is_identifier_char (*(q + 1)))
	{
	  new_token.code = '.';
	  new_token.str[0] = '.';
	  new_token.str[1] = '\0';
	}
      else
	{
	  while (is_identifier_char (*q) || *q == '@@')
	    *p++ = *q++;
	  *p = '\0';

	  if (strcasecmp (new_token.str, "NOT") == 0)
	    new_token.code = '~';

	  else if (strcasecmp (new_token.str, "MOD") == 0)
	    new_token.code = '%';

	  else if (strcasecmp (new_token.str, "AND") == 0)
	    new_token.code = '&';

	  else if (strcasecmp (new_token.str, "OR") == 0)
	    new_token.code = '|';

	  else if (strcasecmp (new_token.str, "XOR") == 0)
	    new_token.code = '^';

	  else if (strcasecmp (new_token.str, "SHL") == 0)
	    new_token.code = T_SHL;

	  else if (strcasecmp (new_token.str, "SHR") == 0)
	    new_token.code = T_SHR;

	  else if (strcasecmp (new_token.str, "BYTE") == 0)
	    new_token.code = T_BYTE;

	  else if (strcasecmp (new_token.str, "WORD") == 0)
	    new_token.code = T_WORD;

	  else if (strcasecmp (new_token.str, "DWORD") == 0)
	    new_token.code = T_DWORD;

	  else if (strcasecmp (new_token.str, "FWORD") == 0)
	    new_token.code = T_FWORD;

	  else if (strcasecmp (new_token.str, "QWORD") == 0)
	    new_token.code = T_QWORD;

	  else if (strcasecmp (new_token.str, "TBYTE") == 0
		   /* XXX remove (gcc still uses it) */
		   || strcasecmp (new_token.str, "XWORD") == 0)
	    new_token.code = T_TBYTE;

	  else if (strcasecmp (new_token.str, "XMMWORD") == 0
		   || strcasecmp (new_token.str, "OWORD") == 0)
	    new_token.code = T_XMMWORD;

	  else if (strcasecmp (new_token.str, "YMMWORD") == 0)
	    new_token.code = T_YMMWORD;

	  else if (strcasecmp (new_token.str, "PTR") == 0)
	    new_token.code = T_PTR;

	  else if (strcasecmp (new_token.str, "SHORT") == 0)
	    new_token.code = T_SHORT;

	  else if (strcasecmp (new_token.str, "OFFSET") == 0)
	    {
	      new_token.code = T_OFFSET;

	      /* ??? This is not mentioned in the MASM grammar but gcc
		     makes use of it with -mintel-syntax.  OFFSET may be
		     followed by FLAT:  */
	      if (strncasecmp (q, " FLAT:", 6) == 0)
		strcat (new_token.str, " FLAT:");
	    }

	  else
	    new_token.code = T_ID;
	}
    }

  else if (strchr ("+-/*%|&^:[]()~", *intel_parser.op_string))
    {
      new_token.code = *intel_parser.op_string;
      new_token.str[0] = *intel_parser.op_string;
      new_token.str[1] = '\0';
    }

  else if (strchr ("<>", *intel_parser.op_string)
	   && *intel_parser.op_string == *(intel_parser.op_string + 1))
    {
      new_token.code = *intel_parser.op_string == '<' ? T_SHL : T_SHR;
      new_token.str[0] = *intel_parser.op_string;
      new_token.str[1] = *intel_parser.op_string;
      new_token.str[2] = '\0';
    }

  else
    as_bad (_("Unrecognized token `%s'"), intel_parser.op_string);

  intel_parser.op_string += strlen (new_token.str);
  cur_token = new_token;
}

/* Put cur_token back into the token stream and make cur_token point to
   prev_token.  */
static void
intel_putback_token (void)
{
  if (cur_token.code != T_NIL)
    {
      intel_parser.op_string -= strlen (cur_token.str);
      free (cur_token.str);
    }
  cur_token = prev_token;

  /* Forget prev_token.  */
  prev_token.code = T_NIL;
  prev_token.reg = NULL;
  prev_token.str = NULL;
}
@


1.370
log
@	PR 10005
	* config/tc-i386.c (reloc): Don't abort on lack of required
	reloc type.
@
text
@d5064 2
a5065 2
			   register_prefix, i.op[1].regs->reg_name,
			   register_prefix, i.op[0].regs->reg_name);
@


1.369
log
@2009-03-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (parse_insn): Use default_arch on unsupported
	arch.
@
text
@d2436 1
a2436 2
  abort ();
  return BFD_RELOC_NONE;
@


1.368
log
@2009-02-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (fits_in_imm4): Removed.
@
text
@d3148 2
a3149 1
	      current_templates->start->name, cpu_arch_name,
@


1.367
log
@2009-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (type_names): Add OPERAND_TYPE_REGYMM.
	(pt): Replace UINTS_ALL_ZERO with operand_type_all_zero.
@
text
@a1675 6
static INLINE int
fits_in_imm4 (offsetT num)
{
  return (num & 0xf) == num;
}

@


1.366
log
@2009-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (type_names): Remove OPERAND_TYPE_VEX_IMM4.
@
text
@d2331 1
d2344 1
a2344 1
      if (!UINTS_ALL_ZERO (a))
@


1.365
log
@gas/

2009-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (vex_imm4): Removed.
	(VEX_check_operands): Likewise.
	(match_template): Updated.

opcodes/

2009-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (operand_type_init): Remove OPERAND_TYPE_VEX_IMM4.
	(operand_types): Remove Vex_Imm4.

	* i386-opc.h (Vex_Imm4): Removed.
	(OTMax): Updated.
	(i386_operand_type): Remove vex_imm4.

	* i386-opc.tbl: Remove Vex_Imm4 comments.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@a2331 1
  { OPERAND_TYPE_VEX_IMM4, "VEX i4" },
@


1.364
log
@gas/

2009-02-04  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (January, 2009)
	* config/tc-i386.c (CPU_FLAGS_PCLMUL_MATCH): New.
	(CPU_FLAGS_AVX_MATCH): Updated.
	(CPU_FLAGS_32BIT_MATCH): Likewise.
	(cpu_flags_match): Likewise.

gas/testsuite/

2009-02-04  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (January, 2009)
	* gas/i386/arch-avx-1-3.l: New.
	* gas/i386/arch-avx-1-3.s: Likewise.
	* gas/i386/arch-avx-1-4.l: Likewise.
	* gas/i386/arch-avx-1-4.s: Likewise.
	* gas/i386/arch-avx-1-5.l: Likewise.
	* gas/i386/arch-avx-1-5.s: Likewise.
	* gas/i386/arch-avx-1-6.l: Likewise.
	* gas/i386/arch-avx-1-6.s: Likewise.

	* gas/i386/arch-10.s: Add vpclmul instructions.
	* gas/i386/arch-avx-1.s: Likewise.
	* gas/i386/avx.s: Likewise.
	* gas/i386/x86-64-arch-2.s: Likewise.
	* gas/i386/x86-64-avx.s: Likewise.

	* gas/i386/sse2avx.s: Add pclmul instructions.
	* gas/i386/x86-64-sse2avx.s: Likewise.

	* gas/i386/arch-10.d: Updated.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/arch-avx-1.d: Likewise.
	* gas/i386/arch-avx-1-1.l: Likewise.
	* gas/i386/arch-avx-1-2.l: Likewise.
	* gas/i386/avx.d: Likewise.
	* gas/i386/avx-intel.d: Likewise.
	* gas/i386/sse2avx.d: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.
	* gas/i386/x86-64-avx.d: Likewise.
	* gas/i386/x86-64-avx-intel.d: Likewise.
	* gas/i386/x86-64-sse2avx.d: Likewise.

	* gas/i386/i386.exp: Run arch-avx-1-3, arch-avx-1-4,
	arch-avx-1-5 and arch-avx-1-6.

opcodes/

2009-02-04  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (January, 2009)
	* i386-dis.c (PREFIX_VEX_3A44): New.
	(VEX_LEN_3A44_P_2): Likewise.
	(PREFIX_VEX_3A48): Updated.
	(VEX_LEN_3A4C_P_2): Likewise.
	(prefix_table): Add PREFIX_VEX_3A44.
	(vex_table): Likewise.
	(vex_len_table): Add VEX_LEN_3A44_P_2.

	* i386-opc.tbl: Add PCLMUL + AVX instructions.
	* i386-tbl.h: Regenerated.
@
text
@a1400 1
static const i386_operand_type vex_imm4 = OPERAND_TYPE_VEX_IMM4;
a3573 23
/* Check if operands are valid for the instrucrtion.  Update VEX
   operand types.  */

static int
VEX_check_operands (const template *t)
{
  if (!t->opcode_modifier.vex)
    return 0;

  /* Only check VEX_Imm4, which must be the first operand.  */
  if (t->operand_types[0].bitfield.vex_imm4)
    {
      if (i.op[0].imms->X_op != O_constant
	  || !fits_in_imm4 (i.op[0].imms->X_add_number))
	return 1;

      /* Turn off Imm8 so that update_imm won't complain.  */
      i.types[0] = vex_imm4;
    }

  return 0;
}

a3877 4
      /* Check if VEX operands are valid.  */
      if (VEX_check_operands (t))
	continue;

@


1.363
log
@        * include/elf/ia64.h (SHT_IA_64_VMS_DISPLAY_NAME_INFO,
        EF_IA_64_ARCHVER_1): New macros. Minor reformatting.

        * bfd/Makefile.am (BFD32_BACKENDS): Add new object vmsutil.lo
        (BFD32_BACKENDS_CFILES): Add new file vmsutil.c
        (vmsutil.lo): Add dependency rule
        * bfd/Makefile.in: Regenerate
        * bfd/config.bfd (ia64*-*-*vms*): Add case.
        * bfd/configure.in (bfd_elf64_ia64_vms_vec): Add case.
        * bfd/configure: Regenerate
        * bfd/vmsutil.[ch]: New files
        * bfd/elf-bfd.h (struct bfd_elf_special_section): Change type of
        attr to bfd_vma.
        * bfd/elfxx-ia64.c (elfNN_vms_post_process_headers,
        elfNN_vms_section_processing, elfNN_vms_final_write_processing,
        elfNN_vms_close_and_cleanup, elfNN_vms_section_from_shdr,
        elfNN_vms_object_p): New functions
        * bfd/targets.c (bfd_elf64_ia64_vms_vec): New target.

        * gas/configure.tgt(ia64-*-*vms*): New target.
        * gas/dwarf2dbg.h (dwarf2_loc_mark_labels): Make extern.
        * gas/tc.h (md_number_to_chars): Declare iff undefined.
        * gas/config/obj-elf.c (obj_elf_change_section): Change type of
        arg attr to bfd_vma.
        (obj_elf_parse_section_letters): Return a bfd_vma. Change type of
        variables attr, md_attr to bfd_vma.
        (obj_elf_section_word): Likewise.
        (obj_elf_section): Change type of variable attr to bfd_vma
        * gas/config/obj-elf.h (obj_elf_change_section): Change type of
        arg attr to bfd_vma
        * gas/config/tc-ia64.c (bfdver.h,time.h): Include.
        (ia64_elf_section_letter): Now returns a bfd_vma.
        Handle VMS specific attributes.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (ia64_init): Don't turn on dependency checking for VMS.
        (ia64_target_format): Check for VMS flag bit.
        (do_alias): Hande decc$ functions.
        (get_vms_time): New function.
        (ia64_vms_note): New function.
        * gas/config/tc-ia64.h (ia64_elf_section_letter): Now returns a bfd_vma.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (tc_init_after_args): Define for VMS.
        * gas/config/tc-alpha.c (alpha_elf_section_letter): Return a bfd_vma.
        (alpha_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-alpha.h: Likewise.
        * gas/config/tc-i386.c (x86_64_section_letter): Return a bfd_vma.
        (x86_64_section_word): Return a bfd_vma.
        * gas/config/tc-i386.h: Likewise.
        * gas/config/tc-ip2k.c (ip2k_elf_section_flags): Change type of arg
        attr to bfd_vma.
        * gas/config/tc-ip2k.h: Likewise.
        * gas/config/tc-mep.c (mep_elf_section_letter): Return a bfd_vma.
        (mep_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-mep.h: Likewise.
        * gas/config/tc-ppc.c  (ppc_section_letter): Return a bfd_vma.
        (ppc_section_word): Return a bfd_vma.
        (ppc_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-ppc.h: Likewise.
        * gas/config/te-vms.h (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,
        DWAR2_FILE_TIME_NAME, DWARF2_FILE_SIZE_NAME, DWARF2_FILEN_NAME):
        New file with new macros
        * gas/dwarf2dbg.c (get_filenum, out_file_list): Default and call new
        macros.
@
text
@d1259 2
a1260 1
#define CPU_FLAGS_AVX_MATCH		0x8
d1263 2
a1264 1
  (CPU_FLAGS_ARCH_MATCH | CPU_FLAGS_AES_MATCH | CPU_FLAGS_AVX_MATCH)
d1296 1
a1296 1
	      /* We only need to check AES/SSE2AVX with AVX.  */
d1307 4
@


1.362
log
@gas/

2009-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/config/tc-i386.c (cpu_arch): Add corei7, .clflush and
	.syscall.
	(i386_align_code): Handle PROCESSOR_COREI7.
	(md_show_usage): Add corei7, clflush and syscall.
	(i386_target_format): Replace cpup4 with cpuclflush.

	* gas/config/tc-i386.h (processor_type): Add PROCESSOR_COREI7.

	* doc/c-i386.texi: Document corei7, clflush and syscall.

gas/testsuite/

2009-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/arch-10.s: Add clflush and syscall.
	* gas/i386/x86-64-arch-2.s: Likewise.

	* gas/i386/arch-10.d: Updated.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.

opcodes/

2009-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (cpu_flag_init): Replace CpuP4 and CpuK6 with
	CpuClflush and CpuSYSCALL, respectively. Remove CpuK8.  Add
	CPU_COREI7_FLAGS, CPU_CLFLUSH_FLAGS and CPU_SYSCALL_FLAGS.
	(cpu_flags): Remove CpuP4, CpuK6 and CpuK8.  Add CpuClflush
	and CpuSYSCALL.
	(lineno): Removed.
	(set_bitfield): Take an argument, lineno.  Don't report lineno
	on error if it is -1.
	(process_i386_cpu_flag): Take an argument, lineno.
	(process_i386_opcode_modifier): Likewise.
	(process_i386_operand_type): Likewise.
	(output_i386_opcode): Likewise.
	(opcode_hash_entry): Add lineno.
	(process_i386_opcodes): Updated.
	(process_i386_registers): Likewise.
	(process_i386_initializers): Likewise.

	* i386-opc.h (CpuP4): Removed.
	(CpuK6): Likewise.
	(CpuK8): Likewise.
	(CpuClflush): New.
	(CpuSYSCALL): Likewise.
	(CpuMMX): Updated.
	(i386_cpu_flags): Remove cpup4, cpuk6 and cpuk8.  Add
	cpuclflush and cpusyscall.

	* i386-opc.tbl: Update movnti, clflush, lfence, mfence, pause,
	syscall and sysret.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d10107 1
a10107 1
int
d10122 1
a10122 1
int
@


1.361
log
@gas/

2009-01-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add .rdtscp.
	(md_show_usage): Display rdtscp.

	* doc/c-i386.texi: Document rdtscp.

gas/testsuite/

2009-01-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/arch-10.s: Add rdtscp.
	* gas/i386/x86-64-arch-2.s: Likewise.

	* gas/i386/arch-10.d: Updated.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.

opcodes/

2009-01-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (cpu_flag_init): Add CpuRdtscp to CPU_K8_FLAGS
	and CPU_AMDFAM10_FLAGS.  Add CPU_RDTSCP_FLAGS.
	(cpu_flags): Add CpuRdtscp.
	(set_bitfield): Remove CpuSledgehammer check.

	* i386-opc.h (CpuRdtscp): New.
	(CpuLM): Updated.
	(i386_cpu_flags): Add cpurdtscp.

	* i386-opc.tbl: Replace CpuSledgehammer with CpuRdtscp.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d603 2
d655 4
d959 2
a960 2
     PROCESSOR_CORE, PROCESSOR_CORE2, and PROCESSOR_GENERIC64,
     alt_long_patt will be used.
d1006 1
d1054 1
d8243 1
a8243 1
                           core, core2, k6, k6_2, athlon, k8, amdfam10,\n\
d8248 2
a8249 2
                           rdtscp, 3dnow, 3dnowa, sse4a, sse5, svme, abm,\n\
                           padlock\n"));
d8254 1
a8254 1
                           core, core2, k6, k6_2, athlon, k8, amdfam10,\n\
d8292 1
a8292 1
	  cpu_arch_isa_flags.bitfield.cpup4 = 1;
d8305 1
a8305 1
	  cpu_arch_tune_flags.bitfield.cpup4 = 1;
@


1.360
log
@gas/

2009-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (December, 2008)
	* config/tc-i386.c (build_modrm_byte): Remove 5 operand instruction
	support.  Don't swap REG and NDS for FMA.

gas/testsuite/

2009-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (December, 2008)
	* gas/i386/arch-10.s: Replace vfmaddpd with vfmadd132pd.
	* gas/i386/x86-64-arch-2.s: Likewise.

	* gas/i386/arch-10.d: Updated.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/avx.d: Likewise.
	* gas/i386/avx-intel.d: Likewise.
	* gas/i386/inval-avx.l: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.
	* gas/i386/x86-64-avx.d: Likewise.
	* gas/i386/x86-64-avx-intel.d: Likewise.
	* gas/i386/x86-64-inval-avx.l: Likewise.

	* gas/i386/avx.s: Remove vpermil2ps/vpermil2pd and FMA
	instructions.  Update tests.
	* gas/i386/inval-avx.s: Likewise.
	* gas/i386/x86-64-avx.s: Likewise.
	* gas/i386/x86-64-inval-avx.s: Likewise.

	* gas/i386/fma.d: New.
	* gas/i386/fma.s: Likewise.
	* gas/i386/fma-intel.d: Likewise.
	* gas/i386/x86-64-fma.d: Likewise.
	* gas/i386/x86-64-fma.s: Likewise.
	* gas/i386/x86-64-fma-intel.d: Likewise.

	* gas/i386/i386.exp: Run fma, fma-intel, x86-64-fma and
	x86-64-fma-intel.

opcodes/

2009-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (December, 2008)
	* i386-dis.c (OP_VEX_FMA): Removed.
	(OP_EX_VexW): Likewise.
	(OP_EX_VexImmW): Likewise.
	(OP_XMM_VexW): Likewise.
	(VEXI4_Fixup): Likewise.
	(VPERMIL2_Fixup): Likewise.
	(VexI4): Likewise.
	(VexFMA): Likewise.
	(Vex128FMA): Likewise.
	(EXVexW): Likewise.
	(EXdVexW): Likewise.
	(EXqVexW): Likewise.
	(EXVexImmW): Likewise.
	(XMVexW): Likewise.
	(VPERMIL2): Likewise.
	(PREFIX_VEX_3A48...PREFIX_VEX_3A4A): Likewise.
	(PREFIX_VEX_3A5C...PREFIX_VEX_3A5F): Likewise.
	(PREFIX_VEX_3A68...PREFIX_VEX_3A6F): Likewise.
	(PREFIX_VEX_3A78...PREFIX_VEX_3A7F): Likewise.
	(VEX_LEN_3A6A_P_2...VEX_LEN_3A6F_P_2): Likewise.
	(VEX_LEN_3A7A_P_2...VEX_LEN_3A7F_P_2): Likewise.
	(get_vex_imm8): Likewise.
	(OP_EX_VexReg): Likewise.
	vpermil2_op): Likewise.
	(EXVexWdq): New.
	(vex_w_dq_mode): Likewise.
	(PREFIX_VEX_3896...PREFIX_VEX_389F): Likewise.
	(PREFIX_VEX_38A6...PREFIX_VEX_38AF): Likewise.
	(PREFIX_VEX_38B6...PREFIX_VEX_38BF): Likewise.
	(es_reg): Updated.
	(PREFIX_VEX_38DB): Likewise.
	(PREFIX_VEX_3A4A): Likewise.
	(PREFIX_VEX_3A60): Likewise.
	(PREFIX_VEX_3ADF): Likewise.
	(VEX_LEN_3ADF_P_2): Likewise.
	(prefix_table): Remove PREFIX_VEX_3A48...PREFIX_VEX_3A4A,
	PREFIX_VEX_3A5C...PREFIX_VEX_3A5F,
	PREFIX_VEX_3A68...PREFIX_VEX_3A6F and
	PREFIX_VEX_3A78...PREFIX_VEX_3A7F.  Add
	PREFIX_VEX_3896...PREFIX_VEX_389F,
	PREFIX_VEX_38A6...PREFIX_VEX_38AF and
	PREFIX_VEX_38B6...PREFIX_VEX_38BF.
	(vex_table): Likewise.
	(vex_len_table): Remove VEX_LEN_3A6A_P_2...VEX_LEN_3A6F_P_2
	and VEX_LEN_3A7A_P_2...VEX_LEN_3A7F_P_2.
	(putop): Support "%XW".
	(intel_operand_size): Handle vex_w_dq_mode.

	* i386-opc.h (VexNDS): Add a comment for VEX NDS and VEX DDS.

	* i386-opc.tbl: Remove vpermil2pd/vpermil2ps and old FMA
	instructions.  Add new FMA instructions.
	* i386-tbl.h: Regenerated.
@
text
@d653 2
d8240 2
a8241 1
                           3dnow, 3dnowa, sse4a, sse5, svme, abm, padlock\n"));
@


1.359
log
@gas/

2008-12-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Changed to return
	 const template *.  Handle i.swap_operand for 3 operands.
	 (build_vex_prefix): Take const template *.  Swap operand for
	 2-byte VEX prefix if possible.
	 (md_assemble): Updated.
	 (build_modrm_byte): Handle RegMem bit for SSE2AVX.

gas/testsuite/

2008-12-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run x86-64-avx-swap and x86-64-avx-swap-intel.

	* gas/i386/opts.s: Add tests for movsd, movss, vmovsd and
	vmovss.
	* gas/i386/x86-64-opts.s: Likewise.

	* gas/i386/opts.d: Updated.
	* gas/i386/opts-intel.d: Likewise.
	* gas/i386/sse2avx-opts.d: Likewise.
	* gas/i386/sse2avx-opts-intel.d: Likewise.
	* gas/i386/x86-64-opts.d: Likewise.
	* gas/i386/x86-64-opts-intel.d: Likewise.
	* gas/i386/x86-64-sse2avx-opts.d: Likewise.
	* gas/i386/x86-64-sse2avx-opts-intel.d: Likewise.

	* gas/i386/x86-64-avx-swap.d: New.
	* gas/i386/x86-64-avx-swap.s: Likewise.
	* gas/i386/x86-64-avx-swap-intel.d: Likewise.

opcodes/

2008-12-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (EXdS): New.
	(EXdVexS): Likewise.
	(EXqVexS): Likewise.
	(d_swap_mode): Likewise.
	(q_mode): Updated.
	(prefix_table): Use EXdS on movss and EXqS on movsd.
	(vex_len_table): Use EXdVexS on vmovss and EXqVexS on vmovsd.
	(intel_operand_size): Handle d_swap_mode.
	(OP_EX): Likewise.

	* i386-opc.h (S): Update comments.

	* i386-opc.tbl: Add S to movss, movsd, vmovss and vmovsd.
	* i386-tbl.h: Regenerated.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d5145 1
a5145 8
      if (i.tm.opcode_modifier.veximmext
	  && i.tm.opcode_modifier.immext)
	{
	  dest = i.operands - 2;
	  assert (dest == 3);
	}
      else
	dest = i.operands - 1;
d5147 2
d5150 18
a5167 55
      /* There are 2 kinds of instructions:
	    1. 5 operands: one immediate operand and 4 register
	    operands or 3 register operands plus 1 memory operand.
	    It must have VexNDS and VexW0 or VexW1.  The destination
	    must be either XMM or YMM register.
	    2. 4 operands: 4 register operands or 3 register operands
	    plus 1 memory operand.  It must have VexNDS and VexImmExt.  */
      if (!((i.reg_operands == 4
	     || (i.reg_operands == 3 && i.mem_operands == 1))
	    && i.tm.opcode_modifier.vexnds
	    && (operand_type_equal (&i.tm.operand_types[dest], &regxmm)
		|| operand_type_equal (&i.tm.operand_types[dest], &regymm))
	    && ((dest == 4
		 && i.imm_operands == 1
		 && i.types[0].bitfield.vex_imm4
		 && (i.tm.opcode_modifier.vexw0
		     || i.tm.opcode_modifier.vexw1))
		|| (dest == 3
		    && (i.imm_operands == 0
			|| (i.imm_operands == 1
			    && i.tm.opcode_modifier.immext))
		    && i.tm.opcode_modifier.veximmext))))
	abort ();

      if (i.imm_operands == 0)
	{
	  /* When there is no immediate operand, generate an 8bit
	     immediate operand to encode the first operand.  */
	  expressionS *exp = &im_expressions[i.imm_operands++];
	  i.op[i.operands].imms = exp;
	  i.types[i.operands] = imm8;
	  i.operands++;
	  /* If VexW1 is set, the first operand is the source and
	     the second operand is encoded in the immediate operand.  */
	  if (i.tm.opcode_modifier.vexw1)
	    {
	      source = 0;
	      reg = 1;
	    }
	  else
	    {
	      source = 1;
	      reg = 0;
	    }

	  /* FMA swaps REG and NDS.  */
	  if (i.tm.cpu_flags.bitfield.cpufma)
	    {
	      unsigned int tmp;
	      tmp = reg;
	      reg = nds;
	      nds = tmp;
	    }

	  assert (operand_type_equal (&i.tm.operand_types[reg], &regxmm)
d5169 1
a5169 9
					 &regymm));
	  exp->X_op = O_constant;
	  exp->X_add_number
	    = ((i.op[reg].regs->reg_num
		+ ((i.op[reg].regs->reg_flags & RegRex) ? 8 : 0)) << 4);
	}
      else
	{
	  unsigned int imm;
d5171 10
a5180 40
	  if (i.tm.opcode_modifier.vexw0)
	    {
	      /* If VexW0 is set, the third operand is the source and
		 the second operand is encoded in the immediate
		 operand.  */
	      source = 2;
	      reg = 1;
	    }
	  else
	    {
	      /* VexW1 is set, the second operand is the source and
		 the third operand is encoded in the immediate
		 operand.  */
	      source = 1;
	      reg = 2;
	    }

	  if (i.tm.opcode_modifier.immext)
	    {
	      /* When ImmExt is set, the immdiate byte is the last
		 operand.  */
	      imm = i.operands - 1;
	      source--;
	      reg--;
	    }
	  else
	    {
	      imm = 0;

	      /* Turn on Imm8 so that output_imm will generate it.  */
	      i.types[imm].bitfield.imm8 = 1;
	    }

	  assert (operand_type_equal (&i.tm.operand_types[reg], &regxmm)
		  || operand_type_equal (&i.tm.operand_types[reg],
					 &regymm));
	  i.op[imm].imms->X_add_number
	    |= ((i.op[reg].regs->reg_num
		 + ((i.op[reg].regs->reg_flags & RegRex) ? 8 : 0)) << 4);
	}
a5181 2
      assert (operand_type_equal (&i.tm.operand_types[nds], &regxmm)
	      || operand_type_equal (&i.tm.operand_types[nds], &regymm));
@


1.358
log
@2008-12-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (parse_insn): Optimize ".s" handling.
@
text
@d183 1
a183 1
static int match_template (void);
d2546 1
a2546 1
build_vex_prefix (void)
d2563 30
d2724 1
d2782 1
a2782 1
  if (!match_template ())
d2863 1
a2863 1
    build_vex_prefix ();
d3582 1
a3582 1
static int
d3776 3
d3903 1
a3903 1
      return 0;
d3943 1
a3943 1
  return 1;
d5362 4
a5365 1
		 encoded in VEX prefix.  */
d5367 2
a5368 4
		  || (!operand_type_equal (&i.tm.operand_types[dest],
					   &regxmm)
		      && !operand_type_equal (&i.tm.operand_types[dest],
					      &regymm)))
@


1.357
log
@gas/

2008-12-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (_i386_insn): Add swap_operand.
	(parse_insn): Handle ".s".
	(match_template): Handle swap_operand.

	* doc/c-i386.texi: Document .s suffix.

gas/testsuite/

2008-12-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run opts, opts-intel, sse2avx-opts,
	sse2avx-opts-intel, x86-64-opts, x86-64-opts-intel,
	x86-64-sse2avx-opts and x86-64-sse2avx-opts-intel.

	* gas/i386/opts.d: New.
	* gas/i386/opts-intel.d: Likewise.
	* gas/i386/opts.s: Likewise.
	* gas/i386/sse2avx-opts.d: Likewise.
	* gas/i386/sse2avx-opts-intel.d: Likewise.
	* gas/i386/x86-64-opts.d: Likewise.
	* gas/i386/x86-64-opts-intel.d: Likewise.
	* gas/i386/x86-64-opts.s: Likewise.
	* gas/i386/x86-64-sse2avx-opts.d: Likewise.
	* gas/i386/x86-64-sse2avx-opts-intel.d: Likewise.

opcodes/

2008-12-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (EbS): New.
	(EvS): Likewise.
	(EMS): Likewise.
	(EXqS): Likewise.
	(EXxS): Likewise.
	(b_swap_mode): Likewise.
	(v_swap_mode): Likewise.
	(q_swap_mode): Likewise.
	(x_swap_mode): Likewise.
	(v_mode): Updated.
	(w_mode): Likewise.
	(t_mode): Likewise.
	(xmm_mode): Likewise.
	(swap_operand): Likewise.
	(dis386): Use EbS on movB.  Use EvS on moveS.
	(dis386_twobyte): Use EXxS on movapX.
	(prefix_table): Use EXxS on movups, movupd, movdqu, movdqa,
	vmovups, vmovdqu, vmovdqa. Use EMS and EXqS on movq.
	(vex_table): Use EXxS on vmovapX.
	(vex_len_table): Use EXqS on vmovq.
	(intel_operand_size): Handle b_swap_mode, v_swap_mode,
	q_swap_mode and x_swap_mode.
	(OP_E_register): Handle b_swap_mode and v_swap_mode.
	(OP_EM): Handle v_swap_mode.
	(OP_EX): x_swap_mode and q_swap_mode.

	* i386-gen.c (opcode_modifiers): Add S.

	* i386-opc.h (S): New.
	(Modrm): Updated.
	(i386_opcode_modifier): Add s.

	* i386-opc.tbl: Add S to movapd, movaps, movdqa, movdqu, movq,
	movupd, movups, vmovapd, vmovaps, vmovdqa, vmovdqu and vmovq.
	* i386-tbl.h: Regenerated.
@
text
@d2997 1
a2997 1
  if (!current_templates && dot_p)
d2999 8
a3006 11
      if (mnem_p - 2 == dot_p)
	{
	  /* Check if we should swap operand in encoding.  */
	  if (dot_p[1] == 's')
	    i.swap_operand = 1;
	  else
	    goto check_suffix;
	  mnem_p = dot_p;
	  *dot_p = '\0';
	  current_templates = hash_find (op_hash, mnemonic);
	}
@


1.356
log
@2008-12-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Remove an extra blank
	line.
@
text
@d282 3
d2914 1
d2924 2
d2997 15
d3014 1
d3737 10
d3763 1
@


1.355
log
@2008-11-29  Kai Tietz  <kai.tietz@@onevision.com>

	* config/tc-i386.c (i386_target_format): For coff flavour in TE_PEP
	use "pe-i386" for 32-bit.
@
text
@a5200 1

@


1.354
log
@gas/

2008-10-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (processor_type): Moved to tc-i386.h.
	(cpu_arch_tune): Make it global.
	(cpu_arch_isa): Likewise.
	(cpu_arch_isa_flags): Likewise.
	(i386_align_code): Check fragP->tc_frag_data.isa,
	fragP->tc_frag_data.isa_flags and cpu_arch_tune instead of
	cpu_arch_isa, cpu_arch_isa_flags and cpu_arch_tune,
	respectively.

	* config/tc-i386.h (processor_type): Moved from tc-i386.c.
	(cpu_arch_tune): New.
	(cpu_arch_isa): Likewise.
	(cpu_arch_isa_flags): Likewise.
	(i386_tc_frag_data): Likewise.
	(TC_FRAG_TYPE): Likewise.
	(TC_FRAG_INIT): Likewise.

gas/testsuite/

2008-10-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run nops-5, nops-5-i686, x86-64-nops-5 and
	x86-64-nops-5-k8.

	* gas/i386/nops-5.d: New.
	* gas/i386/nops-5.s: Likewise.
	* gas/i386/nops-5-i686.d: Likewise.
	* gas/i386/x86-64-nops-5.d: Likewise.
	* gas/i386/x86-64-nops-5-k8.d: Likewise.
@
text
@d8340 1
a8340 1
      return flag_code == CODE_64BIT ? COFF_TARGET_FORMAT : "coff-i386";
@


1.353
log
@	* dw2gencfi.c (cfi_finish): Deal with md_fix_up_eh_frame.
	* config/tc-i386.h (md_fix_up_eh_frame): Define on Solaris.
	(i386_solaris_fix_up_eh_frame): Declare.
	* config/tc-i386.c (i386_solaris_fix_up_eh_frame): New function.
@
text
@a152 19
enum processor_type
{
  PROCESSOR_UNKNOWN,
  PROCESSOR_I386,
  PROCESSOR_I486,
  PROCESSOR_PENTIUM,
  PROCESSOR_PENTIUMPRO,
  PROCESSOR_PENTIUM4,
  PROCESSOR_NOCONA,
  PROCESSOR_CORE,
  PROCESSOR_CORE2,
  PROCESSOR_K6,
  PROCESSOR_ATHLON,
  PROCESSOR_K8,
  PROCESSOR_GENERIC32,
  PROCESSOR_GENERIC64,
  PROCESSOR_AMDFAM10
};

d452 1
a452 1
static enum processor_type cpu_arch_tune = PROCESSOR_UNKNOWN;
d458 1
a458 1
static enum processor_type cpu_arch_isa = PROCESSOR_UNKNOWN;
d461 1
a461 1
static i386_cpu_flags cpu_arch_isa_flags;
d977 1
a977 1
      if (cpu_arch_isa == PROCESSOR_UNKNOWN)
d985 1
a985 1
	      if (cpu_arch_isa_flags.bitfield.cpui686)
d1014 1
a1014 1
	  switch (cpu_arch_tune)
d1032 1
a1032 1
	      if (cpu_arch_isa_flags.bitfield.cpui686)
d1042 1
a1042 1
	      if (cpu_arch_isa_flags.bitfield.cpui686)
@


1.352
log
@Make new functions static.
Rearrange wording of documentation.
@
text
@d10108 9
@


1.352.2.1
log
@	* dw2gencfi.c (cfi_finish): Deal with md_fix_up_eh_frame.
	* config/tc-i386.h (md_fix_up_eh_frame): Define on Solaris.
	(i386_solaris_fix_up_eh_frame): Declare.
	* config/tc-i386.c (i386_solaris_fix_up_eh_frame): New function.
@
text
@a10107 9
#ifdef TE_SOLARIS
void
i386_solaris_fix_up_eh_frame (segT sec)
{
  if (flag_code == CODE_64BIT)
    elf_section_type (sec) = SHT_X86_64_UNWIND;
}
#endif

@


1.351
log
@* config/tc-i386.c (pe_lcomm_internal): New function.  Allows the
  alignment field of the .lcomm directive to be optional.
  (pe_lcomm): New function.  Pass pe_lcomm_internal to
  s_comm_internal.
  (md_pseudo_table): Implement .lcomm directive for COFF based
  targets.
  * doc/c-i386.texi (i386-Directives): New node.  Used to document
  the .lcomm directive.
@
text
@d687 1
d722 1
a722 3
void pe_lcomm (int);

void
d727 1
@


1.350
log
@gas/
2008-08-28  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (md_assemble): Force number of displacement
	operands to zero when processing string instruction.
	(i386_index_check): Special-case string instruction operands. Don't
	fudge address prefix if there already was a memory operand. Fix
	error message to correctly reflect the addressing mode used.
	(i386_att_operand): Fix comment.
	(i386_intel_operand): Snapshot, clear, and restore base and index
	reg for each operand processed. Increment count of memory operands
	later.

gas/testsuite/
2008-08-28  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/string-bad.{l,s}, gas/i386/string-ok.{d,e,s}: New.
	* gas/i386/i386.exp: Run new tests.
@
text
@d687 42
d739 2
@


1.349
log
@gas/
2008-08-27  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (check_string): Use register_prefix for error
	message.
	(process_operands): Likewise.
@
text
@d2765 1
d6894 1
d6901 64
a6964 1
  if (flag_code == CODE_64BIT)
d7017 1
a7017 1
      if (i.prefix[ADDR_PREFIX] == 0)
d7035 3
a7037 2
	as_bad (_("`%s' is not a valid base/index expression"),
		operand_string);
d7040 1
a7040 1
	as_bad (_("`%s' is not a valid %s bit base/index expression"),
d7042 6
a7047 1
		flag_code_names[flag_code]);
d7052 1
a7052 1
/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero
d8869 2
d8892 3
a8922 2
	      i.types[this_operand].bitfield.mem = 1;
	      i.mem_operands++;
d8950 5
d8971 6
d8989 6
@


1.348
log
@gas/

2008-08-20  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (August, 2008)
	* config/tc-i386.c (CPU_FLAGS_AES_MATCH): New.
	(CPU_FLAGS_AVX_MATCH): Likewise.
	(CPU_FLAGS_32BIT_MATCH): Updated.
	(cpu_flags_match): Likewise.

gas/testsuite/

2008-08-20  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (August, 2008)
	* gas/i386/avx.s: Add AES + AVX tests.
	* gas/i386/arch-10.s: Likewise.
	* gas/i386/sse2avx.s: Likewise.
	* gas/i386/x86-64-arch-2.s: Likewise.
	* gas/i386/x86-64-avx.s: Likewise.
	* gas/i386/x86-64-sse2avx.s: Likewise.

	* gas/i386/arch-10.d: Updated.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/avx.d: Likewise.
	* gas/i386/avx-intel.d: Likewise.
	* gas/i386/sse2avx.d: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.
	* gas/i386/x86-64-avx.d: Likewise.
	* gas/i386/x86-64-avx-intel.d: Likewise.
	* gas/i386/x86-64-sse2avx.d: Likewise.

	* gas/i386/i386.exp: Run arch-avx-1, arch-avx-1-1 and
	arch-avx-1-2.

	* gas/i386/arch-avx-1.d: New.
	* gas/i386/arch-avx-1.s: Likewise.
	* gas/i386/arch-avx-1-1.l: Likewise.
	* gas/i386/arch-avx-1-1.s: Likewise.
	* gas/i386/arch-avx-1-2.l: Likewise.
	* gas/i386/arch-avx-1-2.s: Likewise.

opcodes/

2008-08-20  H.J. Lu  <hongjiu.lu@@intel.com>

	AVX Programming Reference (August, 2008)
	* i386-dis.c (PREFIX_VEX_38DB): New.
	(PREFIX_VEX_38DC): Likewise.
	(PREFIX_VEX_38DD): Likewise.
	(PREFIX_VEX_38DE): Likewise.
	(PREFIX_VEX_38DF): Likewise.
	(PREFIX_VEX_3ADF): Likewise.
	(VEX_LEN_38DB_P_2): Likewise.
	(VEX_LEN_38DC_P_2): Likewise.
	(VEX_LEN_38DD_P_2): Likewise.
	(VEX_LEN_38DE_P_2): Likewise.
	(VEX_LEN_38DF_P_2): Likewise.
	(VEX_LEN_3ADF_P_2): Likewise.
	(PREFIX_VEX_3A04): Updated.
	(VEX_LEN_3A06_P_2): Likewise.
	(prefix_table): Add PREFIX_VEX_38DB, PREFIX_VEX_38DC,
	PREFIX_VEX_38DD, PREFIX_VEX_38DE and PREFIX_VEX_3ADF.
	(x86_64_table): Likewise.
	(vex_len_table): Add VEX_LEN_38DB_P_2, VEX_LEN_38DC_P_2,
	VEX_LEN_38DD_P_2, VEX_LEN_38DE_P_2, VEX_LEN_38DF_P_2 and
	VEX_LEN_3ADF_P_2.

	* i386-opc.tbl: Add AES + AVX instructions.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d3864 1
a3864 1
	  as_bad (_("`%s' operand %d must use `%%es' segment"),
d3866 2
a3867 1
		  mem_op + 1);
d3880 1
a3880 1
	  as_bad (_("`%s' operand %d must use `%%es' segment"),
d3882 2
a3883 1
		  mem_op + 2);
d4962 1
a4962 1
	      as_bad (_("you can't `pop %%cs'"));
@


1.347
log
@2008-08-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_align_code): Fix a comment typo.
@
text
@d1220 2
d1223 2
a1224 1
#define CPU_FLAGS_32BIT_MATCH		CPU_FLAGS_ARCH_MATCH 
d1254 19
a1272 2
	  /* Check SSE2AVX  */
	  if (!t->opcode_modifier.sse2avx || sse2avx)
@


1.346
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d992 1
a992 1
	      /* When cpu_arch_isa is net, cpu_arch_tune shouldn't be
@


1.345
log
@warning fix
@
text
@d2013 1
a2013 1
				    (PTR) core_optab);
d2036 1
a2036 1
	hash_err = hash_insert (reg_hash, regtab->reg_name, (PTR) regtab);
@


1.344
log
@gas/

2008-06-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (set_sse_check): New.
	(md_pseudo_table): Add "sse_check".

gas/testsuite/

2008-06-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run sse-check-none and
	x86-64-sse-check-none.

	* gas/i386/sse-check-none.d: New.
	* gas/i386/sse-check-none.s: Likewise.
	* gas/i386/x86-64-sse-check-none.d: Likewise.
@
text
@d1384 2
@


1.343
log
@2008-05-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/6518
	* config/tc-i386.c (match_template): Report ambiguous operand
	size, not invalid suffix when there is no match in Intel
	syntax.
@
text
@d186 1
d715 1
d1857 26
@


1.342
log
@gas/

2008-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention XSAVE, EPT and MOVBE.

	* config/tc-i386.c (cpu_arch): Add .movbe and .ept.
	(md_show_usage): Add .movbe and .ept.

	* doc/c-i386.texi: Add movbe and ept to -march=.  Document
	.movbe and .ept.

gas/testsuite/

2008-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run movbe, movbe-intel, inval-movbe, ept,
	ept-intel, inval-ept, x86-64-movbe, x86-64-movbe-intel,
	x86-64-inval-movbe.  x86-64-ept, x86-64-ept-intel and
	x86-64-inval-ept.

	* gas/i386/arch-10.s: Add movbe and invept.
	* gas/i386/x86-64-arch-2.s: Likewise.

	* gas/i386/ept.d: New file
	* gas/i386/ept-intel.d: Likewise.
	* gas/i386/ept.s: Likewise.
	* gas/i386/inval-ept.l: Likewise.
	* gas/i386/inval-ept.s: Likewise.
	* gas/i386/inval-movbe.l: Likewise.
	* gas/i386/inval-movbe.s: Likewise.
	* gas/i386/movbe.d: Likewise.
	* gas/i386/movbe-intel.d: Likewise.
	* gas/i386/movbe.s: Likewise.
	* gas/i386/x86-64-inval-ept.l: Likewise.
	* gas/i386/x86-64-inval-ept.s: Likewise.
	* gas/i386/x86-64-inval-movbe.l: Likewise.
	* gas/i386/x86-64-inval-movbe.s: Likewise.
	* gas/i386/x86-64-ept.d: Likewise.
	* gas/i386/x86-64-ept-intel.d: Likewise.
	* gas/i386/x86-64-ept.s: Likewise.
	* gas/i386/x86-64-movbe.d: Likewise.
	* gas/i386/x86-64-movbe-intel.d: Likewise.
	* gas/i386/x86-64-movbe.s: Likewise.

	* gas/i386/arch-10.d: Updated.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.

opcodes/

2008-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (MOVBE_Fixup): New.
	(Mo): Likewise.
	(PREFIX_0F3880): Likewise.
	(PREFIX_0F3881): Likewise.
	(PREFIX_0F38F0): Updated.
	(prefix_table): Add PREFIX_0F3880 and PREFIX_0F3881.  Update
	PREFIX_0F38F0 and PREFIX_0F38F1 for movbe.
	(three_byte_table): Use PREFIX_0F3880 and PREFIX_0F3881.

	* i386-gen.c (cpu_flag_init): Add CPU_MOVBE_FLAGS and
	CPU_EPT_FLAGS.
	(cpu_flags): Add CpuMovbe and CpuEPT.

	* i386-opc.h (CpuMovbe): New.
	(CpuEPT): Likewise.
	(CpuLM): Updated.
	(i386_cpu_flags): Add cpumovbe and cpuept.

	* i386-opc.tbl: Add entries for movbe and EPT instructions.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d3757 6
a3762 2
      as_bad (_("suffix or operands invalid for `%s'"),
	      current_templates->start->name);
@


1.341
log
@gas/

2008-04-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Don't check SSE instructions
	if noavx is 0.

opcodes/

2008-04-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Add NoAVX.

	* i386-opc.h (NoAVX): New.
	(OldGcc): Updated.
	(i386_opcode_modifier): Add noavx.

	* i386-opc.tbl: Add NoAVX to SSE, SSE2, SSE3 and SSSE3
	instructions which don't have AVX equivalent.
	* i386-tbl.h: Regenerated.
@
text
@d664 4
d8103 2
a8104 2
                           avx, vmx, smx, xsave, aes, pclmul, fma, 3dnow,\n\
			   3dnowa, sse4a, sse5, svme, abm, padlock\n"));
@


1.340
log
@2008-04-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Don't check FMA to swap
	REG and NDS for instructions with immediate operand.
@
text
@d2673 1
@


1.339
log
@gas/

2008-04-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Swap REG and NDS for
	FMA.

gas/testsuite/

2008-04-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/arch-10.d: Updated.
	* gas/i386/avx.d: Likewise.
	* gas/i386/avx-intel.d: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.
	* gas/i386/x86-64-avx.d: Likewise.
	* gas/i386/x86-64-avx-intel.d: Likewise.

opcodes/

2008-04-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (OP_VEX_FMA): New.
	(OP_EX_VexImmW): Likewise.
	(VexFMA): Likewise.
	(Vex128FMA): Likewise.
	(EXVexImmW): Likewise.
	(get_vex_imm8): Likewise.
	(OP_EX_VexReg): Likewise.
	(vex_i4_done): Renamed to ...
	(vex_w_done): This.
	(prefix_table): Replace EXVexW with EXVexImmW on vpermil2ps
	and vpermil2pd.  Replace Vex/Vex128 with VexFMA/Vex128FMA on
	FMA instructions.
	(print_insn): Updated.
	(OP_EX_VexW): Rewrite to swap register in VEX with EX.
	(OP_REG_VexI4): Check invalid high registers.
@
text
@a5102 9
	  /* FMA swaps REG and NDS.  */
	  if (i.tm.cpu_flags.bitfield.cpufma)
	    {
	      unsigned int tmp;
	      tmp = reg;
	      reg = nds;
	      nds = tmp;
	    }

@


1.338
log
@gas/

2008-04-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention -msse-check=[none|error|warning].

	* config/tc-i386.c (sse_check): New.
	(OPTION_MSSE_CHECK): Likewise.
	(md_assemble): Check SSE instructions if needed.
	(md_longopts): Add -msse-check.
	(md_parse_option): Handle OPTION_MSSE_CHECK.
	(md_show_usage): Show -msse-check=[none|error|warning].

	* doc/c-i386.texi: Document -msse-check=[none|error|warning].

gas/testsuite/

2008-04-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run sse-check, sse-check-warn,
	sse-check-error, x86-64-sse-check, x86-64-sse-check-warn and
	x86-64-sse-check-error.

	* gas/i386/sse-check.d: New.
	* gas/i386/sse-check.s: Likewise.
	* gas/i386/sse-check-error.l: Likewise.
	* gas/i386/sse-check-error.s: Likewise.
	* gas/i386/sse-check-warn.d: Likewise.
	* gas/i386/sse-check-warn.e: Likewise.
	* gas/i386/x86-64-sse-check.d: Likewise.
	* gas/i386/x86-64-sse-check-error.l: Likewise.
	* gas/i386/x86-64-sse-check-error.s: Likewise.
	* gas/i386/x86-64-sse-check-warn.d: Likewise.
@
text
@d5005 1
a5005 1
	    1. 5 operands:  one immediate operand and 4 register
a5015 2
	    && (operand_type_equal (&i.tm.operand_types[nds], &regxmm)
		|| operand_type_equal (&i.tm.operand_types[nds], &regymm))
a5027 2
      i.vex.register_specifier = i.op[nds].regs;

d5048 10
d5103 9
d5119 5
@


1.337
log
@gas/

2008-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (parse_real_register): Return AVX register
	only if AVX is enabled.

gas/testsuite/

2008-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/att-regs.s: Add AVX register test.
	* gas/i386/intel-regs.s: Likewise.

	* gas/i386/att-regs.d: Updated.
	* gas/i386/intel-regs.d: Likewise.
@
text
@d437 8
d2672 13
d7822 1
d7839 1
d8033 11
d8098 3
@


1.336
log
@gas/

2008-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention XSAVE.  Change CLMUL to PCLMUL.

	* config/tc-i386.c (cpu_arch): Add .pclmul.
	(md_show_usage): Replace clmul with pclmul.
	* doc/c-i386.texi: Likewise.

gas/testsuite/

2008-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/arch-10-1.l: Replace CLMUL with PCLMUL.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/arch-10.s: Likewise.
	* gas/i386/clmul-intel.d: Likewise.
	* gas/i386/clmul.d: Likewise.
	* gas/i386/clmul.s: Likewise.
	* gas/i386/x86-64-arch-2.s: Likewise.
	* gas/i386/x86-64-clmul-intel.d: Likewise.
	* gas/i386/x86-64-clmul.d: Likewise.
	* gas/i386/x86-64-clmul.s: Likewise.

	* gas/i386/arch-10.d: Replace clmul with pclmul.
	* gas/i386/x86-64-arch-2.d: Likewise.

opcodes/

2008-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (cpu_flag_init): Replace CPU_CLMUL_FLAGS/CpuCLMUL
	with CPU_PCLMUL_FLAGS/CpuPCLMUL.
	(cpu_flags): Replace CpuCLMUL with CpuPCLMUL.
	* i386-opc.tbl: Likewise.

	* i386-opc.h (CpuCLMUL): Renamed to ...
	(CpuPCLMUL): This.
	(CpuFMA): Updated.
	(i386_cpu_flags): Replace cpuclmul with cpupclmul.

	* i386-init.h: Regenerated.
@
text
@d7688 3
@


1.335
log
@binutils/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (dwarf_regnames_i386): Add AVX registers.
	(dwarf_regnames_x86_64): Likewise.

gas/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention AES, CLMUL, AVX/FMA and -msse2avx.

	* doc/c-i386.texi: Add avx, aes, clmul and fma to -march=.
	Document -msse2avx, .avx, .aes, .clmul and .fma.

	* config/tc-i386.c (YMMWORD_MNEM_SUFFIX): New.
	(vex_prefix): Likewise.
	(sse2avx): Likewise.
	(CPU_FLAGS_ARCH_MATCH): Likewise.
	(CPU_FLAGS_64BIT_MATCH): Likewise.
	(CPU_FLAGS_32BIT_MATCH): Likewise.
	(CPU_FLAGS_PERFECT_MATCH): Likewise.
	(regymm): Likewise.
	(vex_imm4): Likewise.
	(fits_in_imm4): Likewise.
	(build_vex_prefix): Likewise.
	(VEX_check_operands): Likewise.
	(bad_implicit_operand): Likewise.
	(OPTION_MSSE2AVX): Likewise.
	(T_YMMWORD): Likewise.
	(_i386_insn): Add vex.
	(cpu_arch): Add .avx, .aes, .clmul and .fma.
	(cpu_flags_match): Changed to take a pointer to const template.
	Enable encoding SSE instructions with VEX prefix for -msse2avx.
	(match_mem_size): Also check ymmword.
	(operand_type_match): Clear ymmword.
	(md_begin): Allow '_' in mnemonic.
	(type_names): Add OPERAND_TYPE_VEX_IMM4.
	(process_immext): Update assert.
	(md_assemble): Don't call process_immext if sse2avx and immext
	are true.  Call build_vex_prefix if vex is true.
	(parse_insn): Updated for cpu_flags_match.
	(swap_operands): Handle 5 operands.
	(match_template): Handle 5 operands. Updated for cpu_flags_match.
	Check regymm.  Call VEX_check_operands. Handle YMMWORD_MNEM_SUFFIX.
	(process_suffix): Handle YMMWORD_MNEM_SUFFIX.
	(check_byte_reg): Check regymm.
	(process_operands): Duplicate the destination register for
	-msse2avx if needed.
	(build_modrm_byte): Updated for instructions with VEX encoding.
	(output_insn): Output VEX prefix if needed.
	(md_longopts): Add msse2avx.
	(md_parse_option): Handle OPTION_MSSE2AVX.
	(md_show_usage): Add avx, aes, clmul, fma and -msse2avx.
	(intel_e09): Support YMMWORD.
	(intel_e11): Likewise.
	(intel_get_token): Likewise.

gas/testsuite/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run aes, aes-intel, x86-64-aes,
	x86-64-aes-intel, avx, avx-intel, inval-avx, x86-64-avx,
	x86-64-avx-intel and x86-64-inval-avx.

	* gas/cfi/cfi-i386.s: Add tests for AVX register maps.
	* gas/cfi/cfi-x86_64.s: Likewise.

	* gas/i386/aes.d: New.
	* gas/i386/aes.s: Likewise.
	* gas/i386/aes-intel.d: Likewise.
	* gas/i386/avx.d: Likewise.
	* gas/i386/avx.s: Likewise.
	* gas/i386/avx-intel.d: Likewise.
	* gas/i386/clmul.d: Likewise.
	* gas/i386/clmul-intel.d: Likewise.
	* gas/i386/clmul.s: Likewise.
	* gas/i386/i386.exp: Likewise.
	* gas/i386/inval-avx.l: Likewise.
	* gas/i386/inval-avx.s: Likewise.
	* gas/i386/sse2avx.d: Likewise.
	* gas/i386/sse2avx.s: Likewise.
	* gas/i386/x86-64-aes.d: Likewise.
	* gas/i386/x86-64-aes.s: Likewise.
	* gas/i386/x86-64-aes-intel.d: Likewise.
	* gas/i386/x86-64-avx.d: Likewise.
	* gas/i386/x86-64-avx.s: Likewise.
	* gas/i386/x86-64-avx-intel.d: Likewise.
	* gas/i386/x86-64-clmul.d: Likewise.
	* gas/i386/x86-64-clmul-intel.d: Likewise.
	* gas/i386/x86-64-clmul.s: Likewise.
	* gas/i386/x86-64-inval-avx.l: Likewise.
	* gas/i386/x86-64-inval-avx.s: Likewise.
	* gas/i386/x86-64-sse2avx.d: Likewise.
	* gas/i386/x86-64-sse2avx.s: Likewise.

	* gas/i386/arch-10.s: Add tests for AVX, AES, CLMUL and FMA.
	* gas/i386/x86-64-arch-2.s: Likewise.

	* gas/i386/rexw.s: Add AVX tests.

	* gas/i386/x86-64-opcode-inval.s: Remove lds/les test.

	* gas/cfi/cfi-i386.d: Updated.
	* gas/cfi/cfi-x86_64.d: Likewise.
	* gas/i386/arch-10.d:  Likewise.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/rexw.d: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.
	* gas/i386/x86-64-opcode-inval.d: Likewise.
	* gas/i386/x86-64-opcode-inval-intel.d: Likewise.

include/opcode/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386.h (MAX_OPERANDS): Set to 5.
	(MAX_MNEM_SIZE): Changed to 20.

opcodes/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (OP_E_register): New.
	(OP_E_memory): Likewise.
	(OP_VEX): Likewise.
	(OP_EX_Vex): Likewise.
	(OP_EX_VexW): Likewise.
	(OP_XMM_Vex): Likewise.
	(OP_XMM_VexW): Likewise.
	(OP_REG_VexI4): Likewise.
	(PCLMUL_Fixup): Likewise.
	(VEXI4_Fixup): Likewise.
	(VZERO_Fixup): Likewise.
	(VCMP_Fixup): Likewise.
	(VPERMIL2_Fixup): Likewise.
	(rex_original): Likewise.
	(rex_ignored): Likewise.
	(Mxmm): Likewise.
	(XMM): Likewise.
	(EXxmm): Likewise.
	(EXxmmq): Likewise.
	(EXymmq): Likewise.
	(Vex): Likewise.
	(Vex128): Likewise.
	(Vex256): Likewise.
	(VexI4): Likewise.
	(EXdVex): Likewise.
	(EXqVex): Likewise.
	(EXVexW): Likewise.
	(EXdVexW): Likewise.
	(EXqVexW): Likewise.
	(XMVex): Likewise.
	(XMVexW): Likewise.
	(XMVexI4): Likewise.
	(PCLMUL): Likewise.
	(VZERO): Likewise.
	(VCMP): Likewise.
	(VPERMIL2): Likewise.
	(xmm_mode): Likewise.
	(xmmq_mode): Likewise.
	(ymmq_mode): Likewise.
	(vex_mode): Likewise.
	(vex128_mode): Likewise.
	(vex256_mode): Likewise.
	(USE_VEX_C4_TABLE): Likewise.
	(USE_VEX_C5_TABLE): Likewise.
	(USE_VEX_LEN_TABLE): Likewise.
	(VEX_C4_TABLE): Likewise.
	(VEX_C5_TABLE): Likewise.
	(VEX_LEN_TABLE): Likewise.
	(REG_VEX_XX): Likewise.
	(MOD_VEX_XXX): Likewise.
	(PREFIX_0F38DB..PREFIX_0F38DF): Likewise.
	(PREFIX_0F3A44): Likewise.
	(PREFIX_0F3ADF): Likewise.
	(PREFIX_VEX_XXX): Likewise.
	(VEX_OF): Likewise.
	(VEX_OF38): Likewise.
	(VEX_OF3A): Likewise.
	(VEX_LEN_XXX): Likewise.
	(vex): Likewise.
	(need_vex): Likewise.
	(need_vex_reg): Likewise.
	(vex_i4_done): Likewise.
	(vex_table): Likewise.
	(vex_len_table): Likewise.
	(OP_REG_VexI4): Likewise.
	(vex_cmp_op): Likewise.
	(pclmul_op): Likewise.
	(vpermil2_op): Likewise.
	(m_mode): Updated.
	(es_reg): Likewise.
	(PREFIX_0F38F0): Likewise.
	(PREFIX_0F3A60): Likewise.
	(reg_table): Add REG_VEX_71...REG_VEX_73 and REG_VEX_AE.
	(prefix_table): Add PREFIX_0F38DB..PREFIX_0F38DF, PREFIX_0F3ADF
	and PREFIX_VEX_XXX entries.
	(x86_64_table): Use VEX_C4_TABLE and VEX_C5_TABLE.
	(three_byte_table): Use PREFIX_0F38DB..PREFIX_0F38DF and
	PREFIX_0F3ADF.
	(mod_table): Use VEX_C4_TABLE, VEX_C5_TABLE and VEX_LEN_TABLE.
	Add MOD_VEX_XXX entries.
	(ckprefix): Initialize rex_original and rex_ignored.  Store the
	REX byte in rex_original.
	(get_valid_dis386): Handle the implicit prefix in VEX prefix
	bytes and USE_VEX_LEN_TABLE/USE_VEX_C4_TABLE/USE_VEX_C5_TABLE.
	(print_insn): Set need_vex/need_vex_reg/vex_i4_done to 0 before
	calling get_valid_dis386.  Use rex_original and rex_ignored when
	printing out REX.
	(putop): Handle "XY".
	(intel_operand_size): Handle VEX, xmm_mode, xmmq_mode and
	ymmq_mode.
	(OP_E_extended): Updated to use OP_E_register and
	OP_E_memory.
	(OP_XMM): Handle VEX.
	(OP_EX): Likewise.
	(XMM_Fixup): Likewise.
	(CMP_Fixup): Use ARRAY_SIZE.

	* i386-gen.c (cpu_flag_init): Add CpuAES, CPU_CLMUL_FLAGS,
	CPU_FMA_FLAGS and CPU_AVX_FLAGS.
	(operand_type_init): Add OPERAND_TYPE_REGYMM and
	OPERAND_TYPE_VEX_IMM4.
	(cpu_flags): Add CpuAVX, CpuAES, CpuCLMUL and CpuFMA.
	(opcode_modifiers): Add Implicit1stXmm0, Vex, Vex256, VexNDD,
	VexNDS, VexW0, VexW1, Vex0F, Vex0F38, Vex0F3A, Vex3Sources,
	VexImmExt and SSE2AVX.
	(operand_types): Add RegYMM, Ymmword and Vex_Imm4.

	* i386-opc.h (CpuAVX): New.
	(CpuAES): Likewise.
	(CpuCLMUL): Likewise.
	(CpuFMA): Likewise.
	(Vex): Likewise.
	(Vex256): Likewise.
	(VexNDS): Likewise.
	(VexNDD): Likewise.
	(VexW0): Likewise.
	(VexW1): Likewise.
	(Vex0F): Likewise.
	(Vex0F38): Likewise.
	(Vex0F3A): Likewise.
	(Vex3Sources): Likewise.
	(VexImmExt): Likewise.
	(SSE2AVX): Likewise.
	(RegYMM): Likewise.
	(Ymmword): Likewise.
	(Vex_Imm4): Likewise.
	(Implicit1stXmm0): Likewise.
	(CpuXsave): Updated.
	(CpuLM): Likewise.
	(ByteOkIntel): Likewise.
	(OldGcc): Likewise.
	(Control): Likewise.
	(Unspecified): Likewise.
	(OTMax): Likewise.
	(i386_cpu_flags): Add cpuavx, cpuaes, cpuclmul and cpufma.
	(i386_opcode_modifier): Add implicit1stxmm0, vex, vex256,
	vexnds, vexndd, vexw0, vexw1, vex0f, vex0f38, vex0f3a,
	vex3sources, veximmext and sse2avx.
	(i386_operand_type): Add regymm, ymmword and vex_imm4.

	* i386-opc.tbl: Add AES, CLMUL, AVX and FMA new instructions.

	* i386-reg.tbl: Add AVX registers, ymm0..ymm15.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d650 2
d653 1
a653 1
    CPU_CLMUL_FLAGS },
d8050 1
a8050 1
                           avx, vmx, smx, xsave, aes, clmul, fma, 3dnow,\n\
@


1.334
log
@gas/
2008-02-18  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (match_template): Disallow 'l' suffix when
	currently selected CPU has no 32-bit support.
	(parse_real_register): Do not return registers not available on
	currently selected CPU.

gas/testsuite/
2008-02-18  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/att-regs.s, gas/i386/att-regs.d,
	gas/i386/intel-regs.s, gas/i386/intel-regs.d: New.
	* gas/i386/i386.exp: Run new tests.
@
text
@d84 1
d224 10
d299 1
d477 3
d640 2
d648 6
d1202 8
a1209 2
/* Return 3 if there is a perfect match, 2 if compatible with 64bit,
   1 if compatible with arch, 0 if there is no match.  */
d1212 1
a1212 1
cpu_flags_match (i386_cpu_flags x)
d1214 2
a1215 1
  int overlap = cpu_flags_check_cpu64 (x) ? 2 : 0;
d1221 4
a1224 1
    overlap |= 1;
d1227 1
d1233 6
a1238 1
      overlap |= cpu_flags_all_zero (&cpu) ? 0 : 1;
d1240 1
a1240 1
  return overlap;
d1311 1
d1321 1
d1400 3
a1402 1
		   && !t->operand_types[j].bitfield.xmmword)));
d1483 1
d1595 6
d2044 1
d2123 1
d2225 1
d2451 96
d2569 1
a2569 1
  /* These AMD 3DNow! and SSE2 Instructions have an opcode suffix
d2574 2
a2575 2
     SSE5 also uses this encoding, for some of its 3 argument
     instructions.  */
d2580 3
a2582 1
		  && i.operands <= 3)));
d2707 3
a2709 1
  if (i.tm.opcode_modifier.immext)
d2724 3
d2969 2
a2970 2
      supported |= cpu_flags_match (t->cpu_flags);
      if (supported == 3)
d2974 1
a2974 1
  if (!(supported & 2))
d2982 1
a2982 1
  if (!(supported & 1))
d3163 1
d3405 23
d3434 1
d3443 2
a3444 2
#if MAX_OPERANDS != 4
# error "MAX_OPERANDS must be 4."
d3473 2
a3474 1
      found_cpu_match = cpu_flags_match (t->cpu_flags) == 3;
d3515 2
a3516 1
	       && !operand_types[0].bitfield.regxmm)
d3518 2
a3519 1
		  && !!operand_types[t->operands > 1].bitfield.regxmm))
d3613 1
d3659 3
d3673 9
d3717 5
d3905 2
a3906 1
      else if (i.suffix == XMMWORD_MNEM_SUFFIX)
d3908 1
a3908 1
	  /* Skip if the instruction has x suffix.  match_template
d3995 2
a3996 1
      && i.suffix != XMMWORD_MNEM_SUFFIX)
d4123 1
d4716 13
d4742 3
a4744 1
  if (i.tm.opcode_modifier.firstxmm0)
d4746 2
d4750 1
a4750 1
      /* The first operand is implicit and must be xmm0.  */
d4752 4
a4755 2
	      && operand_type_equal (&i.types[0], &regxmm));
      if (i.op[0].regs->reg_num != 0)
d4757 11
a4767 3
	  if (intel_syntax)
	    as_bad (_("the last operand of `%s' must be `%sxmm0'"),
		    i.tm.name, register_prefix);
d4769 50
a4818 3
	    as_bad (_("the first operand of `%s' must be `%sxmm0'"),
		    i.tm.name, register_prefix);
	  return 0;
d4821 14
d4961 123
d5107 11
a5117 2
     implicit registers do not count.  */
  else if (i.reg_operands == 2)
a5118 2
      unsigned int source, dest;

d5127 2
a5128 1
	     the first operand must be shift count register (cl). */
d5131 2
a5132 1
		      && i.types[0].bitfield.shiftcount));
d5142 23
a5164 5
	     one.  */
	  assert (i.imm_operands == 2
		  && i.types[0].bitfield.imm8
		  && i.types[1].bitfield.imm8);
	  source = 2;
d5170 19
a5188 1
      dest = source + 1;
d5227 2
d5432 2
d5435 2
d5459 2
d5468 1
d5476 42
a5517 1
	      assert (op < i.operands);
d5790 3
a5792 1
      switch (i.tm.opcode_length)
d5794 1
a5794 2
	case 3:
	  if (i.tm.base_opcode & 0xff000000)
d5796 9
a5804 9
	      prefix = (i.tm.base_opcode >> 24) & 0xff;
	      goto check_prefix;
	    }
	  break;
	case 2:
	  if ((i.tm.base_opcode & 0xff0000) != 0)
	    {
	      prefix = (i.tm.base_opcode >> 16) & 0xff;
	      if (i.tm.cpu_flags.bitfield.cpupadlock)
d5806 3
d5810 6
a5815 2
		  if (prefix != REPE_PREFIX_OPCODE
		      || i.prefix[LOCKREP_PREFIX] != REPE_PREFIX_OPCODE)
d5818 5
a5822 2
	      else
		add_prefix (prefix);
d5824 5
a5828 5
	  break;
	case 1:
	  break;
	default:
	  abort ();
d5831 24
a5854 4
      /* The prefix bytes.  */
      for (j = ARRAY_SIZE (i.prefix), q = i.prefix; j > 0; j--, q++)
	if (*q)
	  FRAG_APPEND_1_CHAR (*q);
d7795 1
d7811 1
d8001 4
d8048 2
a8049 2
                           vmx, smx, xsave, 3dnow, 3dnowa, sse4a, sse5, svme,\n\
			   abm, padlock\n"));
d8057 2
d8496 1
a8496 1
    dataType		BYTE | WORD | DWORD | FWORD | QWORD | TBYTE | OWORD | XMMWORD
d8612 1
d8665 1
d9071 6
d9260 1
d9456 2
a9457 1
	    | XMMWORD  */
d9465 1
d9731 3
@


1.333
log
@2008-02-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_immext): Fix format.
@
text
@d3340 13
d7130 14
@


1.332
log
@gas/

2008-02-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (inoutportreg): New.
	(process_immext): New.
	(md_assemble): Use it.
	(update_imm): Use imm16 and imm32s.
	(i386_att_operand): Use inoutportreg.

opcodes/

2008-02-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c  (operand_type_init): Add OPERAND_TYPE_INOUTPORTREG.
	* i386-init.h: Regenerated.
@
text
@d2405 4
a2408 4
       /* SSE3 Instructions have the fixed operands with an opcode
	  suffix which is coded in the same place as an 8-bit immediate
	  field would be. Here we check those operands and remove them
	  afterwards.  */
d2414 4
a2417 5
		  register_prefix,
		  i.op[x].regs->reg_name,
		  x + 1,
		  
		  i.tm.name); i.operands = 0;
@


1.331
log
@2008-02-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (operand_type_all_zero): New.
	(operand_type_set): Likewise.
	(operand_type_equal): Likewise.
	(cpu_flags_all_zero): Likewise.
	(cpu_flags_set): Likewise.
	(cpu_flags_equal): Likewise.
	(UINTS_ALL_ZERO): Removed.
	(UINTS_SET): Likewise.
	(UINTS_CLEAR): Likewise.
	(UINTS_EQUAL): Likewise.
	(cpu_flags_match): Updated.
	(smallest_imm_type): Likewise.
	(set_cpu_arch): Likewise.
	(md_assemble): Likewise.
	(optimize_imm): Likewise.
	(match_template): Likewise.
	(process_suffix): Likewise.
	(update_imm): Likewise.
	(process_drex): Likewise.
	(process_operands): Likewise.
	(build_modrm_byte): Likewise.
	(i386_immediate): Likewise.
	(i386_displacement): Likewise.
	(i386_att_operand): Likewise.
	(parse_real_register): Likewise.
	(md_parse_option): Likewise.
	(i386_target_format): Likewise.
@
text
@d1261 2
d2398 45
d2448 1
a2448 2
md_assemble (line)
     char *line;
d2558 1
a2558 42
    {
      expressionS *exp;

      if (i.tm.cpu_flags.bitfield.cpusse3 && i.operands > 0)
	{
	  /* Streaming SIMD extensions 3 Instructions have the fixed
	     operands with an opcode suffix which is coded in the same
	     place as an 8-bit immediate field would be. Here we check
	     those operands and remove them afterwards.  */
	  unsigned int x;

	  for (x = 0; x < i.operands; x++)
	    if (i.op[x].regs->reg_num != x)
	      as_bad (_("can't use register '%s%s' as operand %d in '%s'."),
		      register_prefix,
		      i.op[x].regs->reg_name,
		      x + 1,
		      i.tm.name);
	  i.operands = 0;
 	}

      /* These AMD 3DNow! and Intel Katmai New Instructions have an
	 opcode suffix which is coded in the same place as an 8-bit
	 immediate field would be.  Here we fake an 8-bit immediate
	 operand from the opcode suffix stored in tm.extension_opcode.
	 SSE5 also uses this encoding, for some of its 3 argument
	 instructions.  */

      assert (i.imm_operands == 0
	      && (i.operands <= 2
		  || (i.tm.cpu_flags.bitfield.cpusse5
		      && i.operands <= 3)));

      exp = &im_expressions[i.imm_operands++];
      i.op[i.operands].imms = exp;
      operand_type_set (&i.types[i.operands], 0);
      i.types[i.operands].bitfield.imm8 = 1;
      i.operands++;
      exp->X_op = O_constant;
      exp->X_add_number = i.tm.extension_opcode;
      i.tm.extension_opcode = None;
    }
a4130 1
	  operand_type_set (&overlap, 0);
d4132 1
a4132 1
	    overlap.bitfield.imm16 = 1;
d4134 1
a4134 1
	    overlap.bitfield.imm32s = 1;
d6610 1
a6610 2
	  operand_type_set (&i.types[this_operand], 0);
	  i.types[this_operand].bitfield.inoutportreg = 1;
@


1.330
log
@gas/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (parse_real_register): Don't return 'FLAT'
	if not in Intel mode.
	(i386_intel_operand): Ignore segment overrides in immediate and
	offset operands.
	(intel_e11): Range-check i.mem_operands before use as array
	index. Filter out FLAT for uses other than as segment override.
	(intel_get_token): Remove broken promotion of "FLAT:" to mean
	"offset FLAT:".

gas/testsuite/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/intelok.s: Replace invalid offset expression with
	valid ones.
	* gas/i386/x86_64.s: Likewise.

opcodes/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* i386-opc.h (RegFlat): New.
	* i386-reg.tbl (flat): Add.
	* i386-tbl.h: Re-generate.
@
text
@d1027 1
a1027 1
uints_all_zero (const unsigned int *x, unsigned int size)
d1029 1
a1029 1
  switch (size)
d1032 1
a1032 1
      if (x[2])
d1035 1
a1035 1
      if (x[1])
d1038 1
a1038 1
      return !x[0];
d1045 1
a1045 1
uints_set (unsigned int *x, unsigned int v, unsigned int size)
d1047 1
a1047 1
  switch (size)
d1050 1
a1050 1
      x[2] = v;
d1052 1
a1052 1
      x[1] = v;
d1054 1
a1054 1
      x[0] = v;
d1062 2
a1063 2
uints_equal (const unsigned int *x, const unsigned int *y,
	     unsigned int size)
d1065 1
a1065 1
  switch (size)
d1068 1
a1068 1
      if (x[2] != y [2])
d1071 1
a1071 1
      if (x[1] != y [1])
d1074 1
a1074 1
      return x[0] == y [0];
d1081 54
a1134 8
#define UINTS_ALL_ZERO(x) \
  uints_all_zero ((x).array, ARRAY_SIZE ((x).array))
#define UINTS_SET(x, v) \
  uints_set ((x).array, v, ARRAY_SIZE ((x).array))
#define UINTS_CLEAR(x) \
  uints_set ((x).array, 0, ARRAY_SIZE ((x).array))
#define UINTS_EQUAL(x, y) \
  uints_equal ((x).array, (y).array, ARRAY_SIZE ((x).array))
d1190 1
a1190 1
  if (UINTS_ALL_ZERO (x))
d1199 1
a1199 1
      overlap |= UINTS_ALL_ZERO (cpu) ? 0 : 1;
d1438 1
a1438 1
  if (UINTS_ALL_ZERO (temp))
d1554 1
a1554 1
  UINTS_CLEAR (t);
d1831 1
a1831 1
	      if (!UINTS_EQUAL (flags, cpu_arch_flags))
d2547 1
a2547 1
      UINTS_CLEAR (i.types[i.operands]);
d3134 2
a3135 2
	      UINTS_CLEAR (mask);
	      UINTS_CLEAR (allowed);
d3161 1
a3161 1
	      if (!UINTS_ALL_ZERO (allowed))
d3407 2
a3408 2
	      && UINTS_EQUAL (i.types [0], acc32)
	      && UINTS_EQUAL (i.types [1], acc32))
d3827 2
a3828 2
		 && UINTS_EQUAL (i.types [0], acc64)
		 && UINTS_EQUAL (i.types [1], acc64))
d4094 6
a4099 6
      && !UINTS_EQUAL (overlap, imm8)
      && !UINTS_EQUAL (overlap, imm8s)
      && !UINTS_EQUAL (overlap, imm16)
      && !UINTS_EQUAL (overlap, imm32)
      && !UINTS_EQUAL (overlap, imm32s)
      && !UINTS_EQUAL (overlap, imm64))
d4105 1
a4105 1
	  UINTS_CLEAR (temp);
d4122 3
a4124 3
      else if (UINTS_EQUAL (overlap, imm16_32_32s)
	       || UINTS_EQUAL (overlap, imm16_32)
	       || UINTS_EQUAL (overlap, imm16_32s))
d4126 1
a4126 1
	  UINTS_CLEAR (overlap);
d4132 6
a4137 6
      if (!UINTS_EQUAL (overlap, imm8)
	  && !UINTS_EQUAL (overlap, imm8s)
	  && !UINTS_EQUAL (overlap, imm16)
	  && !UINTS_EQUAL (overlap, imm32)
	  && !UINTS_EQUAL (overlap, imm32s)
	  && !UINTS_EQUAL (overlap, imm64))
d4189 2
a4190 2
	  UINTS_CLEAR (i.types[0]); 
	  UINTS_CLEAR (i.types[3]);
d4217 2
a4218 2
	  UINTS_CLEAR (i.types[0]);
	  UINTS_CLEAR (i.types[3]);
d4240 2
a4241 2
	  UINTS_CLEAR (i.types[0]);
	  UINTS_CLEAR (i.types[3]);
d4263 2
a4264 2
	  UINTS_CLEAR (i.types[2]);
	  UINTS_CLEAR (i.types[3]);
d4293 2
a4294 2
	  UINTS_CLEAR (i.types[2]);
	  UINTS_CLEAR (i.types[3]);
d4315 2
a4316 2
	  UINTS_CLEAR (i.types[2]);
	  UINTS_CLEAR (i.types[3]);
d4350 2
a4351 2
	  UINTS_CLEAR (i.types[0]);
	  UINTS_CLEAR (i.types[3]);
d4383 1
a4383 1
	  UINTS_CLEAR (i.types[2]);
d4401 1
a4401 1
	  UINTS_CLEAR (i.types[2]);
d4420 1
a4420 1
	  UINTS_CLEAR (i.types[2]);
d4450 1
a4450 1
	  UINTS_CLEAR (i.types[3]);
d4472 1
a4472 1
	  UINTS_CLEAR (i.types[2]);
d4513 2
a4514 1
      assert (i.reg_operands && UINTS_EQUAL (i.types[0], regxmm));
d4881 1
a4881 1
		  UINTS_CLEAR (temp);
d5893 1
a5893 1
  UINTS_SET (types, ~0);
d6045 1
a6045 1
  UINTS_CLEAR (bigdisp);
d6226 1
a6226 1
  if (UINTS_ALL_ZERO (bigdisp))
d6599 2
a6600 1
	  && UINTS_EQUAL (i.base_reg->reg_type, reg16_inoutportreg)
d6606 1
a6606 1
	  UINTS_CLEAR (i.types[this_operand]);
d7112 1
a7112 1
  if (UINTS_ALL_ZERO (r->reg_type))
d7123 1
a7123 1
	  || !UINTS_EQUAL (r->reg_type, control))
d7355 1
a7355 1
		  if (!UINTS_EQUAL (flags, cpu_arch_flags))
d7502 1
a7502 1
      if (UINTS_ALL_ZERO (cpu_arch_isa_flags))
d7515 1
a7515 1
      if (UINTS_ALL_ZERO (cpu_arch_tune_flags))
d7532 1
a7532 1
      if (UINTS_ALL_ZERO (cpu_arch_isa_flags))
d7538 1
a7538 1
      if (UINTS_ALL_ZERO (cpu_arch_tune_flags))
@


1.329
log
@gas/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (intel_e09): Also special-case 'bound'.

gas/testsuite/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/intelbad.s, gas/i386/intelok.s: Add 'bound' tests.
	* gas/i386/intelbad.l, gas/i386/intelok.l, gas/i386/intelok.e,
	gas/i386/opcode-intel.d: Adjust.

opcodes/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* i386-dis.c (a_mode): New.
	(cond_jump_mode): Adjust.
	(Ma): Change to a_mode.
	(intel_operand_size): Handle a_mode.
	* i386-opc.tbl: Allow Dword and Qword for bound.
	* i386-tbl.h: Re-generate.
@
text
@d7079 3
d8139 9
a8147 1
	ret = i386_immediate (intel_parser.disp);
d8681 2
d8713 6
a9109 10
	  /* ??? This is not mentioned in the MASM grammar.  */
	  else if (strcasecmp (new_token.str, "FLAT") == 0)
	    {
	      new_token.code = T_OFFSET;
	      if (*q == ':')
		strcat (new_token.str, ":");
	      else
		as_bad (_("`:' expected"));
	    }

@


1.328
log
@gas/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (allow_pseudo_reg): New.
	(parse_real_register): Check for NULL just once. Allow all
	register table entries when allow_pseudo_reg is non-zero.
	Don't allow any registers without type when allow_pseudo_reg
	is zero.
	(tc_x86_regname_to_dw2regnum): Replace with ...
	(tc_x86_parse_to_dw2regnum): ... this.
	(tc_x86_frame_initial_instructions): Adjust for above change.
	* config/tc-i386.h (tc_regname_to_dw2regnum): Remove.
	(tc_parse_to_dw2regnum): New.
	(tc_x86_regname_to_dw2regnum): Replace with ...
	(tc_x86_parse_to_dw2regnum): ... this.
	* dw2gencfi.c (tc_parse_to_dw2regnum): New, broken out of ...
	(cfi_parse_reg): ... this. Use tc_parse_to_dw2regnum. Adjust
	error handling.

gas/testsuite/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* gas/cfi/cfi-i386.s: Add code testing use of all registers.
	Fix a few comments.
	* gas/cfi/cfi-x86_64.s: Likewise.
	* gas/cfi/cfi-i386.d, gas/cfi/cfi-x86_64.d: Adjust.

opcodes/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* i386-gen.c (process_i386_registers): Process new fields.
	* i386-opc.h (reg_entry): Shrink reg_flags and reg_num to
	unsigned char. Add dw2_regnum and Dw2Inval.
	* i386-reg.tbl: Provide initializers for dw2_regnum. Add pseudo
	register names.
	* i386-tbl.h: Re-generate.
@
text
@d8360 4
a8363 3
	      if (current_templates->start->name[0] == 'l'
		  && current_templates->start->name[2] == 's'
		  && current_templates->start->name[3] == 0)
d8374 4
a8377 3
	      if (current_templates->start->name[0] == 'l'
		  && current_templates->start->name[2] == 's'
		  && current_templates->start->name[3] == 0)
d8409 2
a8410 1
	      if (intel_parser.got_a_float == 1)	/* "f..." */
d8413 1
a8413 1
		  suffix = QWORD_MNEM_SUFFIX;
@


1.327
log
@gas/

2008-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add .xsave.
	(md_show_usage): Add .xsave.

	* doc/c-i386.texi: Add xsave to -march=.

gas/testsuite/

2008-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/arch-10.s: Add xgetbv.

	* gas/i386/arch-10.d: Updated.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/x86-64-arch-10.d: Likewise.

opcodes/

2008-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c  (cpu_flag_init): Add CPU_XSAVE_FLAGS.
	* i386-init.h: Updated.
@
text
@d416 3
d7061 6
d7068 1
a7068 2
  if (r != NULL
      && !allow_index_reg
d7072 2
a7073 3
  if (r != NULL
      && ((r->reg_flags & (RegRex64 | RegRex))
	  || r->reg_type.bitfield.reg64)
d9144 2
a9145 2
int
tc_x86_regname_to_dw2regnum (char *regname)
d9147 2
a9148 40
  unsigned int regnum;
  unsigned int regnames_count;
  static const char *const regnames_32[] =
    {
      "eax", "ecx", "edx", "ebx",
      "esp", "ebp", "esi", "edi",
      "eip", "eflags", NULL,
      "st0", "st1", "st2", "st3",
      "st4", "st5", "st6", "st7",
      NULL, NULL,
      "xmm0", "xmm1", "xmm2", "xmm3",
      "xmm4", "xmm5", "xmm6", "xmm7",
      "mm0", "mm1", "mm2", "mm3",
      "mm4", "mm5", "mm6", "mm7",
      "fcw", "fsw", "mxcsr",
      "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL,
      "tr", "ldtr"
    };
  static const char *const regnames_64[] =
    {
      "rax", "rdx", "rcx", "rbx",
      "rsi", "rdi", "rbp", "rsp",
      "r8",  "r9",  "r10", "r11",
      "r12", "r13", "r14", "r15",
      "rip",
      "xmm0",  "xmm1",  "xmm2",  "xmm3",
      "xmm4",  "xmm5",  "xmm6",  "xmm7",
      "xmm8",  "xmm9",  "xmm10", "xmm11",
      "xmm12", "xmm13", "xmm14", "xmm15",
      "st0", "st1", "st2", "st3",
      "st4", "st5", "st6", "st7",
      "mm0", "mm1", "mm2", "mm3",
      "mm4", "mm5", "mm6", "mm7",
      "rflags",
      "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL,
      "fs.base", "gs.base", NULL, NULL,
      "tr", "ldtr",
      "mxcsr", "fcw", "fsw"
    };
  const char *const *regnames;
d9150 20
a9169 4
  if (flag_code == CODE_64BIT)
    {
      regnames = regnames_64;
      regnames_count = ARRAY_SIZE (regnames_64);
a9170 12
  else
    {
      regnames = regnames_32;
      regnames_count = ARRAY_SIZE (regnames_32);
    }

  for (regnum = 0; regnum < regnames_count; regnum++)
    if (regnames[regnum] != NULL
	&& strcmp (regname, regnames[regnum]) == 0)
      return regnum;

  return -1;
d9176 7
a9182 1
  static unsigned int sp_regno;
d9184 6
a9189 3
  if (!sp_regno)
    sp_regno = tc_x86_regname_to_dw2regnum (flag_code == CODE_64BIT
					    ? "rsp" : "esp");
d9191 1
a9191 1
  cfi_add_CFA_def_cfa (sp_regno, -x86_cie_data_alignment);
@


1.326
log
@	* read.c (s_weakref): Don't pass unadorned NULL to concat.
	* config/tc-i386.c (set_cpu_arch, md_parse_option): Likewise.
@
text
@d626 2
d7413 2
a7414 2
                           vmx, smx, 3dnow, 3dnowa, sse4a, sse5, svme, abm,\n\
                           padlock\n"));
@


1.325
log
@gas/

2008-01-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_show_usage): Replace tabs with spaces.

gas/testsuite/

2008-01-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp : Run x86-64-arch-1 and x86-64-arch-10.

	* gas/i386/x86-64-arch-1.d: New.
	* gas/i386/x86-64-arch-1.s: Likewise.
	* gas/i386/x86-64-arch-10.d: Likewise.

opcodes/

2008-01-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (cpu_flag_init): Add CpuLM to CPU_GENERIC64_FLAGS.
	* i386-init.h: Regenerated.
@
text
@d1787 1
a1787 1
						  NULL);
d7302 1
a7302 1
						      NULL);
@


1.324
log
@2008-01-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_show_usage): Show more processors for
	-march=/-mtune=.
@
text
@d7409 4
a7412 4
			  EXTENSION is combination of:\n\
			   mmx, sse, sse2, sse3, ssse3, sse4.1, sse4.2, sse4,\n\
			   vmx, smx, 3dnow, 3dnowa, sse4a, sse5, svme, abm,\n\
			   padlock\n"));
@


1.323
log
@gas/

2008-01-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_target_format): Remove cpummx2.

gas/testsuite/

2008-01-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/arch-10.d: New.
	* gas/i386/arch-11.s: Likewise.
	* gas/i386/arch-12.d: Likewise.
	* gas/i386/arch-12.s: Likewise.

	* gas/i386/i386.exp: Run arch-11 and arch-12.

opcodes/

2008-01-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (cpu_flag_init): Remove CpuMMX2.
	(cpu_flags): Likewise.

	* i386-opc.h (CpuMMX2): Removed.
	(CpuSSE): Updated.

	* i386-opc.tbl: Replace CpuMMX2 with CpuSSE|Cpu3dnowA.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d7405 4
a7408 2
                           i386, i486, pentium, pentiumpro, pentium4, nocona,\n\
                           core, core2, k6, athlon, k8, generic32, generic64\n\
d7414 5
a7418 3
  -mtune=CPU              optimize for CPU, where CPU is one of:\n\
                           i386, i486, pentium, pentiumpro, pentium4, nocona,\n\
                           core, core2, k6, athlon, k8, generic32, generic64\n"));
@


1.322
log
@gas/

2008-01-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (XXX_PREFIX): Moved from tc-i386.h.
	(XXX_MNEM_SUFFIX): Likewise.
	(END_OF_INSN): Likewise.
	(templates): Likewise.
	(modrm_byte): Likewise.
	(rex_byte): Likewise.
	(DREX_XXX): Likewise.
	(drex_byte): Likewise.
	(sib_byte): Likewise.
	(processor_type): Likewise.
	(arch_entry): Likewise.
	(cpu_sub_arch_name): Remove const.
	(cpu_arch): Add .vmx and .smx.
	(set_cpu_arch): Append cpu_sub_arch_name.
	(md_parse_option): Support -march=CPU[,+EXTENSION...].
	(md_show_usage): Updated.

	* config/tc-i386.h (XXX_PREFIX): Moved to tc-i386.c.
	(XXX_MNEM_SUFFIX): Likewise.
	(END_OF_INSN): Likewise.
	(templates): Likewise.
	(modrm_byte): Likewise.
	(rex_byte): Likewise.
	(DREX_XXX): Likewise.
	(drex_byte): Likewise.
	(sib_byte): Likewise.
	(processor_type): Likewise.
	(arch_entry): Likewise.

	* doc/as.texinfo: Update i386 -march option.

	* doc/c-i386.texi: Update -march= for ISA.

gas/testsuite/

2008-01-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/arch-10-1.l: New.
	* gas/i386/arch-10-1.s: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-2.s: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-3.s: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/arch-10-4.s: Likewise.
	* gas/i386/arch-10.d: Likewise.
	* gas/i386/arch-10.s: Likewise.

	* gas/i386/i386.exp: Run arch-10, arch-10-1, arch-10-2,
	arch-10-3 and arch-10-4.

	* gas/i386/nops-2.s: Use movsbl instead of cmove.
	* gas/i386/nops-2-i386.d: Updated.
	* gas/i386/nops-2-merom.d: Likewise.
	* gas/i386/nops-2.d: Likewise.
	* gas/i386/x86-64-nops-2.d: Likewise.

opcodes/

2008-01-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (cpu_flag_init): Add CPU_VMX_FLAGS and
	CPU_SMX_FLAGS.
	* i386-init.h: Regenerated.
@
text
@a7447 1
	  cpu_arch_isa_flags.bitfield.cpummx2 = 1;
a7460 1
	  cpu_arch_tune_flags.bitfield.cpummx2 = 1;
@


1.321
log
@gas/

2008-01-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Also zap movzx and movsx
	suffix for AT&T syntax.

gas/testsuite/

2008-01-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.s: Add more tests for movsx and movzx.
	* gas/i386/x86_64.s: Likewise.

	* gas/i386/inval.s: Remove tests for movsxw and movzxw.

	* gas/i386/x86-64-inval.s: Remove tests for movsxb, movsxw,
	movsxl, movzxb and movzxw.

	* gas/i386/i386.d: Updated.
	* gas/i386/inval.l: Likewise.
	* gas/i386/x86_64.d: Likewise.
	* gas/i386/x86-64-inval.l: Likewise.

opcodes/

2008-01-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.tbl: Put back 16bit movsx/movzx for AT&T syntax.
	* i386-tbl.h: Regenerated.
@
text
@d58 122
d438 1
a438 1
static const char *cpu_sub_arch_name = NULL;
d552 90
a641 86
  {"generic32", PROCESSOR_GENERIC32,
   CPU_GENERIC32_FLAGS },
  {"generic64", PROCESSOR_GENERIC64,
   CPU_GENERIC64_FLAGS },
  {"i8086", PROCESSOR_UNKNOWN,
   CPU_NONE_FLAGS },
  {"i186", PROCESSOR_UNKNOWN,
   CPU_I186_FLAGS },
  {"i286", PROCESSOR_UNKNOWN,
   CPU_I286_FLAGS },
  {"i386", PROCESSOR_I386,
   CPU_I386_FLAGS },
  {"i486", PROCESSOR_I486,
   CPU_I486_FLAGS },
  {"i586", PROCESSOR_PENTIUM,
   CPU_I586_FLAGS },
  {"i686", PROCESSOR_PENTIUMPRO,
   CPU_I686_FLAGS },
  {"pentium", PROCESSOR_PENTIUM,
   CPU_I586_FLAGS },
  {"pentiumpro",PROCESSOR_PENTIUMPRO,
   CPU_I686_FLAGS },
  {"pentiumii",	PROCESSOR_PENTIUMPRO,
   CPU_P2_FLAGS },
  {"pentiumiii",PROCESSOR_PENTIUMPRO,
   CPU_P3_FLAGS },
  {"pentium4", PROCESSOR_PENTIUM4,
   CPU_P4_FLAGS },
  {"prescott", PROCESSOR_NOCONA,
   CPU_CORE_FLAGS },
  {"nocona", PROCESSOR_NOCONA,
   CPU_NOCONA_FLAGS },
  {"yonah", PROCESSOR_CORE,
   CPU_CORE_FLAGS },
  {"core", PROCESSOR_CORE,
   CPU_CORE_FLAGS },
  {"merom", PROCESSOR_CORE2,
   CPU_CORE2_FLAGS },
  {"core2", PROCESSOR_CORE2,
   CPU_CORE2_FLAGS },
  {"k6", PROCESSOR_K6,
   CPU_K6_FLAGS },
  {"k6_2", PROCESSOR_K6,
   CPU_K6_2_FLAGS },
  {"athlon", PROCESSOR_ATHLON,
   CPU_ATHLON_FLAGS },
  {"sledgehammer", PROCESSOR_K8,
   CPU_K8_FLAGS },
  {"opteron", PROCESSOR_K8,
   CPU_K8_FLAGS },
  {"k8", PROCESSOR_K8,
   CPU_K8_FLAGS },
  {"amdfam10", PROCESSOR_AMDFAM10,
   CPU_AMDFAM10_FLAGS },
  {".mmx", PROCESSOR_UNKNOWN,
   CPU_MMX_FLAGS },
  {".sse", PROCESSOR_UNKNOWN,
   CPU_SSE_FLAGS },
  {".sse2", PROCESSOR_UNKNOWN,
   CPU_SSE2_FLAGS },
  {".sse3", PROCESSOR_UNKNOWN,
   CPU_SSE3_FLAGS },
  {".ssse3", PROCESSOR_UNKNOWN,
   CPU_SSSE3_FLAGS },
  {".sse4.1", PROCESSOR_UNKNOWN,
   CPU_SSE4_1_FLAGS },
  {".sse4.2", PROCESSOR_UNKNOWN,
   CPU_SSE4_2_FLAGS },
  {".sse4", PROCESSOR_UNKNOWN,
   CPU_SSE4_2_FLAGS },
  {".3dnow", PROCESSOR_UNKNOWN,
   CPU_3DNOW_FLAGS },
  {".3dnowa", PROCESSOR_UNKNOWN,
   CPU_3DNOWA_FLAGS },
  {".padlock", PROCESSOR_UNKNOWN,
   CPU_PADLOCK_FLAGS },
  {".pacifica", PROCESSOR_UNKNOWN,
   CPU_SVME_FLAGS },
  {".svme", PROCESSOR_UNKNOWN,
   CPU_SVME_FLAGS },
  {".sse4a", PROCESSOR_UNKNOWN,
   CPU_SSE4A_FLAGS },
  {".abm", PROCESSOR_UNKNOWN,
   CPU_ABM_FLAGS },
  {".sse5", PROCESSOR_UNKNOWN,
   CPU_SSE5_FLAGS },
d1782 10
a1791 1
		  cpu_sub_arch_name = cpu_arch[i].name;
d7187 1
d7263 2
a7264 3
      if (*arg == '.')
	as_fatal (_("Invalid -march= option: `%s'"), arg);
      for (i = 0; i < ARRAY_SIZE (cpu_arch); i++)
d7266 6
a7271 1
	  if (strcmp (arg, cpu_arch [i].name) == 0)
d7273 1
a7273 3
	      cpu_arch_isa = cpu_arch[i].type;
	      cpu_arch_isa_flags = cpu_arch[i].flags;
	      if (!cpu_arch_tune_set)
d7275 35
a7309 2
		  cpu_arch_tune = cpu_arch_isa;
		  cpu_arch_tune_flags = cpu_arch_isa_flags;
a7310 1
	      break;
d7312 5
d7318 1
a7318 2
      if (i >= ARRAY_SIZE (cpu_arch))
	as_fatal (_("Invalid -march= option: `%s'"), arg);
d7403 10
a7412 1
  -march=CPU/-mtune=CPU   generate code/optimize for CPU, where CPU is one of:\n\
@


1.320
log
@gas/

2008-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_reg_size): New.
	(match_mem_size): Likewise.
	(operand_size_match): Likewise.
	(operand_type_match): Also clear all size fields.
	(match_template): Skip Intel syntax when in AT&T syntax.
	Call operand_size_match to check operand size.
	(i386_att_operand): Set the mem field to 1 for memory
	operand.
	(i386_intel_operand): Likewise.

gas/testsuite/

2008-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.s: Add tests for movsx, movzx and movnti.
	* gas/i386/inval.s: Likewise.
	* gas/i386/x86_64.s: Likewise.
	* gas/i386/x86-64-inval.s: Likewise.

	* gas/i386/i386.d: Updated.
	* gas/i386/inval.l: Likewise.
	* gas/i386/x86_64.d: Likewise.
	* gas/i386/x86-64-inval.l: Likewise.

opcodes/

2008-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Add IntelSyntax.
	(operand_types): Add Mem.

	* i386-opc.h (IntelSyntax): New.
	* i386-opc.h (Mem): New.
	(Byte): Updated.
	(Opcode_Modifier_Max): Updated.
	(i386_opcode_modifier): Add intelsyntax.
	(i386_operand_type): Add mem.

	* i386-opc.tbl: Remove Reg16 from movnti.  Add sizes to more
	instructions.

	* i386-reg.tbl: Add size for accumulator.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d2280 12
a2291 16
  if (intel_syntax)
    {
      /* Zap movzx and movsx suffix.  The suffix may have been set from
	 "word ptr" or "byte ptr" on the source operand, but we'll use
	 the suffix later to choose the destination register.  */
      if ((i.tm.base_opcode & ~9) == 0x0fb6)
	{
	  if (i.reg_operands < 2
	      && !i.suffix
	      && (!i.tm.opcode_modifier.no_bsuf
		  || !i.tm.opcode_modifier.no_wsuf
		  || !i.tm.opcode_modifier.no_lsuf
		  || !i.tm.opcode_modifier.no_ssuf
		  || !i.tm.opcode_modifier.no_ldsuf
		  || !i.tm.opcode_modifier.no_qsuf))
	    as_bad (_("ambiguous operand size for `%s'"), i.tm.name);
d2293 1
a2293 2
	  i.suffix = 0;
	}
@


1.319
log
@gas/testsuite/

2008-01-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5534
	* gas/i386/i386.s: Add tests for fnstsw and fstsw.
	* gas/i386/inval.s: Likewise.
	* gas/i386/x86_64.s: Likewise.

	* gas/i386/intel.s: Use word instead of dword on ss.

	* gas/i386/x86-64-inval.s: Add tests for fnstsw, fstsw, in
	and out.

	* gas/i386/prefix.s: Remove invalid fstsw.

	* gas/i386/inval.l: Updated.
	* gas/i386/intelbad.l: Likewise.
	* gas/i386/i386.d: Likewise.
	* gas/i386/x86_64.d: Likewise.
	* gas/i386/x86-64-inval.l: Likewise.
	* gas/i386/prefix.d: Updated.

gas/

2008-01-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5534
	* config/tc-i386.c (_i386_insn): Update comment.
	(operand_type_match): Also clear unspecified.
	(operand_type_register_match): Likewise.
	(parse_operands): Initialize unspecified.
	(i386_intel_operand): Likewise.
	(match_template): Check memory and accumulator operand size.
	(i386_att_operand): Clear unspecified on register operand.
	(intel_e11): Likewise.
	(intel_e09): Set operand size and clean unspecified for
	"XXX PTR".

opcodes/

2008-01-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5534
	* i386-gen.c (operand_type_init): Add Dword to
	OPERAND_TYPE_ACC32.  Add Qword to OPERAND_TYPE_ACC64.
	(opcode_modifiers): Remove CheckSize, Byte, Word, Dword,
	Qword and Xmmword.
	(operand_types): Add Byte, Word, Dword, Fword, Qword, Tbyte,
	Xmmword, Unspecified and Anysize.
	(set_bitfield): Make Mmword an alias of Qword.  Make Oword
	an alias of Xmmword.

	* i386-opc.h (CheckSize): Removed.
	(Byte): Updated.
	(Word): Likewise.
	(Dword): Likewise.
	(Qword): Likewise.
	(Xmmword): Likewise.
	(FWait): Updated.
	(OTMax): Likewise.
	(i386_opcode_modifier): Remove checksize, byte, word, dword,
	qword and xmmword.
	(Fword): New.
	(TBYTE): Likewise.
	(Unspecified): Likewise.
	(Anysize): Likewise.
	(i386_operand_type): Add byte, word, dword, fword, qword,
	tbyte xmmword, unspecified and anysize.

	* i386-opc.tbl: Updated to use Byte, Word, Dword, Fword, Qword,
	Tbyte, Xmmword, Unspecified and Anysize.

	* i386-reg.tbl: Add size for accumulator.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d1150 96
d1254 7
a3075 1
  unsigned int size_match;
d3119 3
a3121 2
      /* Check Intel syntax.   */
      if (intel_syntax && t->opcode_modifier.attsyntax)
d3134 3
a3136 1
      size_match = 1;
d3138 1
a3138 43
	{
	  operand_types[j] = t->operand_types[j];

	  /* Check memory and accumulator operand size.  We check
	     operand_types for accumulator, and both operand_types
	     and i.types for memory.  */
	  if (j < i.operands
	      && !operand_types[j].bitfield.anysize
	      && ((operand_types[j].bitfield.acc
		   && ((i.types[j].bitfield.byte
			&& !operand_types[j].bitfield.byte)
		       || (i.types[j].bitfield.word
			   && !operand_types[j].bitfield.word)
		       || (i.types[j].bitfield.dword
			   && !operand_types[j].bitfield.dword)
		       || (i.types[j].bitfield.qword
			   && !operand_types[j].bitfield.qword)))
		  || (operand_types[j].bitfield.baseindex
		      && i.types[j].bitfield.baseindex
		      && ((i.types[j].bitfield.unspecified
			   && !operand_types[j].bitfield.unspecified)
			  || (i.types[j].bitfield.byte
			      && !operand_types[j].bitfield.byte)
			  || (i.types[j].bitfield.word
			      && !operand_types[j].bitfield.word)
			  || (i.types[j].bitfield.dword
			      && !operand_types[j].bitfield.dword)
			  || (i.types[j].bitfield.fword
			      && !operand_types[j].bitfield.fword)
			  || (i.types[j].bitfield.qword
			      && !operand_types[j].bitfield.qword)
			  || (i.types[j].bitfield.tbyte
			      && !operand_types[j].bitfield.tbyte)
			  || (i.types[j].bitfield.xmmword
			      && !operand_types[j].bitfield.xmmword)))))
	    {
	      size_match = 0;
	      break;
	    }
	}

      if (!size_match)
	continue;
d6430 1
d7912 1
@


1.318
log
@2008-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Check processor support
	first.
@
text
@d116 2
a117 2
    /* SUFFIX holds the instruction mnemonic suffix if given.
       (e.g. 'l' for 'movl')  */
d1157 1
d1165 1
a1165 1
/* If given types r0 and r1 are registers they must be of the same type
d2646 1
d2973 1
a2994 2
  else if (i.suffix == XMMWORD_MNEM_SUFFIX)
    suffix_check.xmmword = 1;
d3031 44
a3074 10
      /* Check the memory size in Intel mode when it is provided if
	 needed.  */
      if (intel_syntax
	  && i.suffix
	  && t->opcode_modifier.checksize
	  && (!t->opcode_modifier.byte || !suffix_check.no_bsuf)
	  && (!t->opcode_modifier.word || !suffix_check.no_wsuf)
	  && (!t->opcode_modifier.dword || !suffix_check.no_lsuf)
	  && (!t->opcode_modifier.qword || !suffix_check.no_qsuf)
	  && (!t->opcode_modifier.xmmword || !suffix_check.xmmword))
a3076 3
      for (j = 0; j < MAX_OPERANDS; j++)
	operand_types [j] = t->operand_types [j];

d6174 1
d7890 1
d8099 4
a8102 1
	    suffix = BYTE_MNEM_SUFFIX;
d8114 1
d8131 1
d8148 1
d8156 2
a8157 1
		suffix = QWORD_MNEM_SUFFIX;
d8171 1
d8180 2
d8512 1
@


1.317
log
@2008-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Continue if processor
	doesn't match.
@
text
@d3003 5
d3061 1
a3061 1
      else 
a3062 3
	  found_cpu_match = cpu_flags_match (t->cpu_flags) == 3;
	  if (!found_cpu_match)
	    continue;
@


1.316
log
@2008-01-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Check register size
	only when size of operands can be encoded the canonical way.
@
text
@d3059 2
d3062 2
a3063 6
	    {
	      if (!found_cpu_match)
		continue;
	      /* We've found a match; break out of loop.  */
	      break;
	    }
@


1.315
log
@2008-01-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_operand): Renamed to ...
	(i386_att_operand): This.
	(parse_operands): Updated.
@
text
@d2970 1
d3114 3
d3139 2
a3140 13
	      /* monitor in SSE3 is a very special case.  The first
		 register and the second register may have different
		 sizes.  The same applies to crc32 in SSE4.2.  It is
		 also true for invlpga, vmload, vmrun and vmsave in
		 SVME.  */
	      || !((t->base_opcode == 0x0f01
		    && (t->extension_opcode == 0xc8
			|| t->extension_opcode == 0xd8
			|| t->extension_opcode == 0xda
			|| t->extension_opcode == 0xdb
			|| t->extension_opcode == 0xdf))
		   || t->base_opcode == 0xf20f38f1
		   || operand_type_register_match (overlap0, i.types[0],
d3154 7
a3160 4
		  || !operand_type_register_match (overlap0, i.types[0],
						   operand_types[1],
						   overlap1, i.types[1],
						   operand_types[0]))
d3194 7
a3200 6
		      || !operand_type_register_match (overlap2,
						       i.types[2],
						       operand_types[2],
						       overlap3,
						       i.types[3],
						       operand_types[3]))
d3208 7
a3214 6
		      || !operand_type_register_match (overlap1,
						       i.types[1],
						       operand_types[1],
						       overlap2,
						       i.types[2],
						       operand_types[2]))
@


1.314
log
@gas/

2008-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* doc/c-i386.texi: Update .att_mnemonic and .intel_mnemonic.

	* config/tc-i386.c (set_intel_mnemonic): Set intel_mnemonic
	only.
	(md_assemble): Remove Intel mode workaround.
	(match_template): Check support for old gcc, AT&T mnemonic
	and Intel Syntax.
	(md_parse_option): Don't set intel_mnemonic to 0 for
	OPTION_MOLD_GCC.

gas/testsuite/

2008-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/intel.s: Add tests for fadd, faddp, fdiv, fdivp,
	fdivr, fdivrp, fmul, fmulp, fsub, fsubp, fsubr and fsubrp.

	* gas/i386/intel.d: Updated.
	* gas/i386/intel.e: Likewise.

opcodes/

2008-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Rename IntelMnemonic to
	ATTSyntax.

	* i386-opc.h (IntelMnemonic): Renamed to ..
	(ATTSyntax): This
	(Opcode_Modifier_Max): Updated.
	(i386_opcode_modifier): Remove intelmnemonic. Add attsyntax
	and intelsyntax.

	* i386-opc.tbl: Remove IntelMnemonic and update with ATTSyntax
	on fsub, fubp, fsubr, fsubrp, div, fdivp, fdivr and fdivrp.
	* i386-tbl.h: Regenerated.
@
text
@d69 1
a69 1
static int i386_operand (char *);
d2659 1
a2659 1
	    operand_ok = i386_operand (token_start);
d6057 1
a6057 1
i386_operand (char *operand_string)
@


1.313
log
@2008-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Use !intel_mnemonic instead
	of SYSV386_COMPAT.
@
text
@d1498 1
a1498 31
  /* Find out if register prefixing is specified.  */
  int ask_naked_reg = 0;

  SKIP_WHITESPACE ();
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *string = input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp (string, "prefix") == 0)
	ask_naked_reg = 1;
      else if (strcmp (string, "noprefix") == 0)
	ask_naked_reg = -1;
      else
	as_bad (_("bad argument to syntax directive."));
      *input_line_pointer = e;
    }
  demand_empty_rest_of_line ();

  /* intel_mnemonic implies intel_syntax.  */
  intel_mnemonic = intel_syntax = mnemonic_flag;

  if (ask_naked_reg == 0)
    allow_naked_reg = (intel_mnemonic
		       && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
  else
    allow_naked_reg = (ask_naked_reg < 0);

  identifier_chars['%'] = intel_mnemonic && allow_naked_reg ? '%' : 0;
  identifier_chars['$'] = intel_mnemonic ? '$' : 0;
  register_prefix = allow_naked_reg ? "" : "%";
a2177 6
      /* Undo AT&T Mnemonic brokenness when in Intel mode.  See
	 i386-opc.tbl.  */
      if (!intel_mnemonic
	  && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
	i.tm.base_opcode ^= Opcode_FloatR;

d3002 6
a3007 5
      /* Check AT&T mnemonic and old gcc support. */
      if (t->opcode_modifier.attmnemonic
	  && (intel_mnemonic
	      || (!old_gcc
		  && t->opcode_modifier.oldgcc)))
d3010 2
a3011 2
      /* Check Intel mnemonic. */
      if (!intel_mnemonic && t->opcode_modifier.intelmnemonic)
a7101 1
      intel_mnemonic = 0;
@


1.312
log
@gas/

2008-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/config/tc-i386.c (cpu_arch_flags_not): Removed.
	(cpu_flags_not): Likewise.
	(cpu_flags_match): Updated to check 64bit and arch.
	(set_code_flag): Remove cpu_arch_flags_not.
	(set_16bit_gcc_code_flag): Likewise.
	(set_cpu_arch): Likewise.
	(md_begin): Likewise.
	(parse_insn): Call cpu_flags_match to check 64bit and arch.
	(match_template): Likewise.

gas/testsuite/

2008-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/arch-9.d: New file.
	* gas/i386/arch-9.s: Likewise.

	* gas/i386/i386.exp: Run arch-9.

opcodes/

2008-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (cpu_flag_init): Remove CpuSSE4_1_Or_5 and
	CpuSSE4_2_Or_ABM.
	(cpu_flags): Likewise.

	* i386-opc.h (CpuSSE4_1_Or_5): Removed.
	(CpuSSE4_2_Or_ABM): Likewise.
	(CpuLM): Updated.
	(i386_cpu_flags): Remove cpusse4_1_or_5 and cpusse4_2_or_abm.

	* i386-opc.tbl: Replace CpuSSE4_1_Or_5, CpuSSE4_2_Or_ABM and
	Cpu686|CpuPadLock with CpuSSE4_1|CpuSSE5, CpuABM|CpuSSE4_2
	and CpuPadLock, respectively.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d2208 3
a2210 2
      /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
      if (SYSV386_COMPAT
@


1.311
log
@	* config/tc-i386.c (process_drex): Initialize modrm_reg and
	modrm_regmem to 0 instead of None.
@
text
@a320 3
/* Bitwise NOT of cpu_arch_flags.  */
static i386_cpu_flags cpu_arch_flags_not;

a966 23
cpu_flags_not (i386_cpu_flags x)
{
  switch (ARRAY_SIZE (x.array))
    {
    case 3:
      x.array [2] = ~x.array [2];
    case 2:
      x.array [1] = ~x.array [1];
    case 1:
      x.array [0] = ~x.array [0];
      break;
    default:
      abort ();
    }

#ifdef CpuUnused
  x.bitfield.unused = 0;
#endif

  return x;
}

static INLINE i386_cpu_flags
d1002 3
d1008 1
a1008 4
  i386_cpu_flags not = cpu_arch_flags_not;

  not.bitfield.cpu64 = 1;
  not.bitfield.cpuno64 = 1;
d1013 12
a1024 2
  not = cpu_flags_and (x, not);
  return UINTS_ALL_ZERO (not);
a1431 2
      cpu_arch_flags_not.bitfield.cpu64 = 0;
      cpu_arch_flags_not.bitfield.cpuno64 = 1;
a1436 2
      cpu_arch_flags_not.bitfield.cpu64 = 1;
      cpu_arch_flags_not.bitfield.cpuno64 = 0;
a1456 2
  cpu_arch_flags_not.bitfield.cpu64 = 1;
  cpu_arch_flags_not.bitfield.cpuno64 = 0;
a1567 1
		  cpu_arch_flags_not = cpu_flags_not (cpu_arch_flags);
a1583 1
		  cpu_arch_flags_not = cpu_flags_not (cpu_arch_flags);
a1633 2
  cpu_arch_flags_not = cpu_flags_not (cpu_arch_flags);

d2559 3
a2561 4
      if (cpu_flags_match (t->cpu_flags))
	supported |= 1;
      if (cpu_flags_check_cpu64 (t->cpu_flags))
	supported |= 2;
d2563 1
d2574 4
a2577 4
      as_warn (_("`%s' is not supported on `%s%s'"),
	       current_templates->start->name,
	       cpu_arch_name,
	       cpu_sub_arch_name ? cpu_sub_arch_name : "");
d2579 3
a2581 1
  else if (!cpu_arch_flags.bitfield.cpui386
d3004 1
a3004 1
  i386_cpu_flags overlap;
d3091 1
a3091 1
	  overlap = cpu_flags_and (t->cpu_flags, cpu_arch_flags_not);
d3094 1
a3094 1
	      if (!UINTS_ALL_ZERO (overlap))
d3258 1
a3258 1
      if (!UINTS_ALL_ZERO (overlap))
@


1.310
log
@gas/

2008-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Use the xmmword field
	instead of no_xsuf.

opcodes/

2008-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Remove No_xSuf.

	* i386-opc.h (No_xSuf): Removed.
	(CheckSize): Updated.

	* i386-tbl.h: Regenerated.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d3951 2
a3952 2
  i.drex.modrm_reg = None;
  i.drex.modrm_regmem = None;
@


1.309
log
@2008-01-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_suffix): Fix a typo.
@
text
@d3051 1
a3051 1
    suffix_check.no_xsuf = 1;
d3091 1
a3091 1
	  && (!t->opcode_modifier.xmmword || !suffix_check.no_xsuf))
@


1.308
log
@gas/

2008-01-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5534
	* config/tc-i386.c (match_template): Handle XMMWORD_MNEM_SUFFIX.
	Check memory size in Intel mode.
	(process_suffix): Handle XMMWORD_MNEM_SUFFIX.
	(intel_e09): Likewise.

	* config/tc-i386.h (XMMWORD_MNEM_SUFFIX): New.

gas/testsuite/

2008-01-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5534
	* gas/i386/intel.s: Use QWORD on movq instead of DWORD.

	* gas/i386/inval.s: Add tests for movq.
	* gas/i386/x86-64-inval.s: Likewise.

	* gas/i386/inval.l: Updated.
	* gas/i386/x86-64-inval.l: Likewise.

opcodes/

2008-01-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5534
	* i386-gen.c (opcode_modifiers): Add No_xSuf, CheckSize,
	Byte, Word, Dword, QWord and Xmmword.

	* i386-opc.h (No_xSuf): New.
	(CheckSize): Likewise.
	(Byte): Likewise.
	(Word): Likewise.
	(Dword): Likewise.
	(QWord): Likewise.
	(Xmmword): Likewise.
	(FWait): Updated.
	(i386_opcode_modifier): Add No_xSuf, CheckSize, Byte, Word,
	Dword, QWord and Xmmword.

	* i386-opc.tbl: Add CheckSize|QWord to movq if IgnoreSize is
	used.
	* i386-tbl.h: Regenerated.
@
text
@d3535 1
a3535 1
	  if (!i.tm.opcode_modifier.no_lsuf)
@


1.307
log
@2007-12-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_show_usage): Add -mmnemonic, -msyntax,
	-mindex-reg, -mnaked-reg and -mold-gcc.
@
text
@d3050 2
d3082 12
d3470 5
d3557 3
a3559 1
  if (i.suffix && i.suffix != BYTE_MNEM_SUFFIX)
d8190 1
a8190 2
	      /* XXX ignored for now, but accepted since gcc uses it */
	      suffix = 0;
@


1.306
log
@Fix a typo in comment.
@
text
@d297 1
a297 1
/* 1 if fake index register, eiz/riz, is allowed .  */
d7180 10
a7189 1

@


1.305
log
@gas/

2007-12-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (set_intel_mnemonic): New.
	(intel_mnemonic): Likewise.
	(old_gcc): Likewise.
	(OPTION_MMNEMONIC): Likewise.
	(OPTION_MSYNTAX): Likewise.
	(OPTION_MINDEX_REG): Likewise.
	(OPTION_MNAKED_REG): Likewise.
	(OPTION_MOLD_GCC): Likewise.
	(md_pseudo_table): Add .intel_mnemonic and .att_mnemonic.
	(match_template): Don't allow AT&T/Intel mnemonic if Intel/AT&T
	mnemonic is specified.  Don't allow old gcc support if old_gcc
	is 0.
	(md_longopts): Add -mmnemonic, -msyntax, -mindex-reg,
	-mmnaked-reg and -mold-gcc.
	(md_parse_option): Handle OPTION_MMNEMONIC, OPTION_MSYNTAX,
	OPTION_MINDEX_REG, OPTION_MNAKED_REG and OPTION_MOLD_GCC.

	* doc/c-i386.texi: Docoument -mmnemonic, -msyntax, --mnaked-reg
	and AT&T mnemonic vs. Intel mnemonic.

gas/testsuite/

2007-12-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/compat-intel.d: Pass -mmnemonic=att to assembler.
	* gas/i386/compat.d: Likewise.

	* gas/i386/i386.exp: Pass -mmnemonic=att to assembler for
	"float".  Pass -mold-gcc to assembler for  "general".

opcodes/

2007-12-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Add OldGcc, ATTMnemonic and
	IntelMnemonic.

	* i386-opc.h (OldGcc): New.
	(ATTMnemonic): Likewise.
	(IntelMnemonic): Likewise.
	(Opcode_Modifier_Max): Updated.
	(i386_opcode_modifier): Add oldgcc, attmnemonic and
	intelmnemonic.

	* i386-opc.tbl: Update fadd, fdiv, fdivp, fdivr, fdivrp, fmul,
	fsub, fsubp, fsubr and fsubrp with OldGcc, ATTMnemonic and
	IntelMnemonic.
	* i386-tbl.h: Regeneratd.
@
text
@d291 1
a291 1
/* 1 ti support old (<= 2.8.1) versions of gcc.  */
@


1.304
log
@2007-12-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (output_insn): Use ARRAY_SIZE.
	(lex_got): Likewise.
@
text
@d61 1
d287 7
d545 2
d1518 36
d3059 11
d6971 5
d6986 5
d7111 31
@


1.303
log
@2007-12-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (output_insn): Use FRAG_APPEND_1_CHAR
	instead of frag_more/md_number_to_chars.
	(md_short_jump_size): Removed.
	(md_long_jump_size): Likewise.
	(md_create_short_jump): Likewise.
	(md_create_long_jump): Likewise.
@
text
@d4965 1
d4999 3
a5001 7
      for (q = i.prefix;
	   q < i.prefix + sizeof (i.prefix) / sizeof (i.prefix[0]);
	   q++)
	{
	  if (*q)
	    FRAG_APPEND_1_CHAR (*q);
	}
d5451 1
a5451 1
  for (j = 0; j < sizeof (gotrel) / sizeof (gotrel[0]); j++)
@


1.302
log
@2007-11-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Re-order suffix check.
@
text
@d5003 1
a5003 4
	    {
	      p = frag_more (1);
	      md_number_to_chars (p, (valueT) *q, 1);
	    }
d5042 3
a5044 6
	  p = frag_more (1);
	  md_number_to_chars (p,
			      (valueT) (i.rm.regmem << 0
					| i.rm.reg << 3
					| i.rm.mode << 6),
			      1);
d5052 3
a5054 8
	    {
	      p = frag_more (1);
	      md_number_to_chars (p,
				  (valueT) (i.sib.base << 0
					    | i.sib.index << 3
					    | i.sib.scale << 6),
				  1);
	    }
a6565 35
/* Size of byte displacement jmp.  */
int md_short_jump_size = 2;

/* Size of dword displacement jmp.  */
int md_long_jump_size = 5;

void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  offsetT offset;

  offset = to_addr - (from_addr + 2);
  /* Opcode for byte-disp jump.  */
  md_number_to_chars (ptr, (valueT) 0xeb, 1);
  md_number_to_chars (ptr + 1, (valueT) offset, 1);
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  offsetT offset;

  offset = to_addr - (from_addr + 5);
  md_number_to_chars (ptr, (valueT) 0xe9, 1);
  md_number_to_chars (ptr + 1, (valueT) offset, 4);
}

@


1.301
log
@gas/

2007-11-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Replace no_xsuf with
	no_ldsuf.
	(match_template): Likewise.

opcodes/

2007-11-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Replace No_xSuf with
	No_ldSuf.
	* i386-opc.tbl: Likewise.

	* i386-opc.h (No_xSuf): Renamed to ...
	(No_ldSuf): This.
	(FWait): Updated.
@
text
@d3014 7
a3020 7
      if (((t->opcode_modifier.no_bsuf & suffix_check.no_bsuf)
	   || (t->opcode_modifier.no_wsuf & suffix_check.no_wsuf)
	   || (t->opcode_modifier.no_lsuf & suffix_check.no_lsuf)
	   || (t->opcode_modifier.no_ssuf & suffix_check.no_ssuf)
	   || (t->opcode_modifier.no_qsuf & suffix_check.no_qsuf)
	   || (t->opcode_modifier.no_ldsuf & suffix_check.no_ldsuf))
	  && !(intel_syntax && t->opcode_modifier.ignoresize))
@


1.300
log
@gas/

2007-11-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_suffix): Check addrprefixop0 to
	see if the address size override prefix changes the size of the
	first operand.
	(check_byte_reg): Don't warn if byteokintel is set.
	(check_long_reg): Set i.suffix to QWORD_MNEM_SUFFIX if toqword
	is set.
	(check_qword_reg): Set i.suffix to LONG_MNEM_SUFFIX if todword
	is set.

gas/testsuite/

2007-11-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.d: New.
	* gas/i386/i386.s: Likewise.

	* gas/i386/i386.exp: Run i386.

	* gas/i386/x86_64.s: Add tests for movsx, movsbl, movsbq,
	movsbw, movswl, movswq, movzx, movzb, movzbl, movzbq,
	movzbw, movzwl and movzwq.
	* gas/i386/x86_64.d: Updated.

opcodes/

2007-11-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Add ByteOkIntel, ToDword,
	ToQword and AddrPrefixOp0.

	* i386-opc.h (ByteOkIntel): New.
	(ToDword): Likewise.
	(ToQword): Likewise.
	(AddrPrefixOp0): Likewise.
	(IsPrefix): Updated.
	(i386_opcode_modifier): Add byteokintel, todword, toqword
	and addrprefixop0.

	* i386-opc.tbl (cvtss2si): Add ToQword.
	(cvttss2si): Likewise.
	(cvtsd2si): Add ToDword.
	(cvttsd2si): Likewise.
	(monitor): Add AddrPrefixOp0.
	(invlpga): Likewise.
	(vmload): Likewise.
	(vmrun): Likewise.
	(vmsave): Likewise.
	(pextrb): Add ByteOkIntel.
	(pinsrb): Likewise.
	* i386-tbl.h: Regenerated.
@
text
@d2204 1
a2204 1
		  || !i.tm.opcode_modifier.no_xsuf
d3003 1
a3003 1
    suffix_check.no_xsuf = 1;
d3019 1
a3019 1
	   || (t->opcode_modifier.no_xsuf & suffix_check.no_xsuf))
@


1.299
log
@Remove duplicate definitions of the md_atof() function
@
text
@d3495 4
a3498 11
      if (i.tm.base_opcode == 0x0f01
	   && (i.tm.extension_opcode == 0xc8
	       || i.tm.extension_opcode == 0xd8
	       || i.tm.extension_opcode == 0xda
	       || i.tm.extension_opcode == 0xdb
	       || i.tm.extension_opcode == 0xdf))
	{
	  /* monitor in SSE3 is a very special case. The default size
	     of AX is the size of mode. The address size override
	     prefix will change the size of AX.  It is also true for
	     invlpga, vmload, vmrun and vmsave in SVME.  */
d3565 2
a3566 10
      /* movzx, movsx, pextrb and pinsrb should not generate this
	 warning.  */
      if (intel_syntax
	  && (i.tm.base_opcode == 0xfb7
	      || i.tm.base_opcode == 0xfb6
	      || i.tm.base_opcode == 0x63
	      || i.tm.base_opcode == 0xfbe
	      || i.tm.base_opcode == 0xfbf
	      || i.tm.base_opcode == 0x660f3a14
	      || i.tm.base_opcode == 0x660f3a20))
d3678 1
a3678 2
	    && (i.tm.base_opcode == 0xf30f2d
		|| i.tm.base_opcode == 0xf30f2c)
d3681 1
a3681 2
	    /* cvtss2si/cvttss2si convert DWORD memory to Reg64.  We
	       want REX byte. */
d3724 1
a3724 2
	    && (i.tm.base_opcode == 0xf20f2d
		|| i.tm.base_opcode == 0xf20f2c)
d3727 1
a3727 2
	    /* cvtsd2si/cvttsd2si convert QWORD memory to Reg32.  We
	       don't want REX byte. */
@


1.298
log
@2007-10-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_operands): Simplify implicit xmm0
	handling.
@
text
@a6792 7
#define MAX_LITTLENUMS 6

/* Turn the string pointed to by litP into a floating point constant
   of type TYPE, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d6794 5
a6798 44
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
      prec = 2;
      break;

    case 'd':
    case 'D':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 5;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to md_atof ()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  /* This loops outputs the LITTLENUMs in REVERSE order; in accord with
     the bigendian 386.  */
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
@


1.297
log
@gas/

2007-10-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_operands): Check the firstxmm0
	field in opcode_modifier for instruction with a implicit
	xmm0 as the first operand.

opcodes/

2007-10-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (opcode_modifiers): Add FirstXmm0.

	* i386-opc.h (FirstXmm0): New.
	(IsPrefix): Updated.
	(i386_opcode_modifier): Add firstxmm0.

	* i386-opc.tbl (blendvpd): Replace RegKludge with FirstXmm0.
	(blendvps): Likewise.
	(pblendvb): Likewise.
	* i386-tbl.h: Regenerated.
@
text
@d4235 2
d4249 11
a4259 4
      i.op[0] = i.op[1];
      i.op[1] = i.op[2];
      i.types[0] = i.types[1];
      i.types[1] = i.types[2];
a4261 5

      /* We need to adjust fields in i.tm since they are used by
	 build_modrm_byte.  */
      i.tm.operand_types [0] = i.tm.operand_types [1];
      i.tm.operand_types [1] = i.tm.operand_types [2];
@


1.296
log
@2007-10-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Check the first 2 8bit
	immediate operands directly for instructions with 4 operands.
@
text
@d4233 46
a4278 51
  /* The imul $imm, %reg instruction is converted into
     imul $imm, %reg, %reg, and the clr %reg instruction
     is converted into xor %reg, %reg.  */
  if (i.tm.opcode_modifier.regkludge)
    {
       if (i.tm.cpu_flags.bitfield.cpusse4_1)
	 {
	   /* The first operand in instruction blendvpd, blendvps and
	      pblendvb in SSE4.1 is implicit and must be xmm0.  */
	   assert (i.operands == 3
		   && i.reg_operands >= 2
		   && UINTS_EQUAL (i.types[0], regxmm));
	   if (i.op[0].regs->reg_num != 0)
	     {
	       if (intel_syntax)
		 as_bad (_("the last operand of `%s' must be `%sxmm0'"),
			 i.tm.name, register_prefix);
	       else
		 as_bad (_("the first operand of `%s' must be `%sxmm0'"),
			 i.tm.name, register_prefix);
	       return 0;
	     }
	   i.op[0] = i.op[1];
	   i.op[1] = i.op[2];
	   i.types[0] = i.types[1];
	   i.types[1] = i.types[2];
	   i.operands--;
	   i.reg_operands--;

	   /* We need to adjust fields in i.tm since they are used by
	      build_modrm_byte.  */
	   i.tm.operand_types [0] = i.tm.operand_types [1];
	   i.tm.operand_types [1] = i.tm.operand_types [2];
	   i.tm.operands--;
	 }
       else
	 {
	   unsigned int first_reg_op;
	   
	   if (operand_type_check (i.types[0], reg))
	     first_reg_op = 0;
	   else
	     first_reg_op = 1;
	   /* Pretend we saw the extra register operand.  */
	   assert (i.reg_operands == 1
		   && i.op[first_reg_op + 1].regs == 0);
	   i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
	   i.types[first_reg_op + 1] = i.types[first_reg_op];
	   i.operands++;
	   i.reg_operands++;
	 }
@


1.295
log
@gas/

2007-10-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5109
	* config/tc-i386.c (process_suffix): Clear QWORD suffix if it
	is ignored in Intel mode.

gas/testsuite/

2007-10-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5109
	* gas/i386/simd-intel.d: Updated.
	* gas/i386/simd.d: Likewise.
	* gas/i386/x86-64-simd-intel.d: Likewise.
	* gas/i386/x86-64-simd.d: Likewise.

	* gas/i386/simd.s: Add more tests.
	* gas/i386/x86-64-simd.s: Likewise.
@
text
@d4424 3
a4426 2
	  /* When there are 4 operands, the first two must be immediate
	     operands. The source operand will be the 3rd one.  */
d4428 2
a4429 2
		  && operand_type_check (i.types[0], imm)
		  && operand_type_check (i.types[1], imm));
@


1.294
log
@gas/

2007-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5080
	* config/tc-i386.c (check_long_reg): Also handle cvttss2si.
	(check_qword_reg): Also handle cvttsd2si.

gas/testsuite/

2007-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5080
	* gas/i386/simd-intel.d: Updated.
	* gas/i386/simd.d: Likewise.
	* gas/i386/x86-64-simd-intel.d: Likewise.
	* gas/i386/x86-64-simd.d: Likewise.

	* gas/i386/simd.s: Add new tests for cvttsd2si and cvttss2si.
	* gas/i386/x86-64-simd.s: Likewise.
@
text
@d3387 5
a3391 1
	  if (!check_qword_reg ())
@


1.293
log
@gas/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (build_modrm_byte): Also check for RegEip
	when considering IP-relative addressing.

gas/testsuite/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/reloc64.s: Adjust for %eip-relative addressing no
	longer generating errors.
	* gas/i386/reloc64.d, gas/i386/reloc64.l: Update.
	* gas/i386/x86-64-addr32.s: Remove explicit addr32 prefix
	for %eip-realtive addressing case.

opcodes/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* i386-opc.h (RegEip): Define.
	(RegEiz): Adjust.
	* i386-reg.tbl: Add eip. Mark rip and eip with RegRex64.
	* i386-tbl.h: Re-generate.
@
text
@d3689 2
a3690 1
	    && i.tm.base_opcode == 0xf30f2d
d3693 2
a3694 2
	    /* cvtss2si converts DWORD memory to Reg64.  We want
	       REX byte. */
d3737 2
a3738 1
	    && i.tm.base_opcode == 0xf20f2d
d3741 2
a3742 2
	    /* cvtsd2si converts QWORD memory to Reg32.  We don't want
	       REX byte. */
@


1.292
log
@gas/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (NUM_FLAG_CODE): Remove.
@
text
@d4550 2
a4551 1
	  else if (i.base_reg->reg_num == RegRip)
d5986 2
a5987 1
	       || i.base_reg->reg_num != RegRip))
@


1.291
log
@gas/

2007-09-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (output_insn): Use i.tm.opcode_length to
	check opcode length.

opcodes/

2007-09-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-gen.c (process_i386_opcodes): Process opcode_length.

	* i386-opc.h (template): Add opcode_length.
	* 386-opc.tbl: Likewise.
	* i386-tbl.h: Regenerated.
@
text
@a268 1
#define NUM_FLAG_CODE ((int) CODE_64BIT + 1)
@


1.290
log
@gas/

2007-09-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 658
	* config/tc-i386.c (SCALE1_WHEN_NO_INDEX): Removed.
	(set_allow_index_reg): New.
	(allow_index_reg): Likewise.
	(md_pseudo_table): Add "allow_index_reg" and
	"disallow_index_reg".
	(build_modrm_byte): Set i.sib.index to NO_INDEX_REGISTER for
	fake index registers.
	(i386_scale): Updated.
	(i386_index_check): Support fake index registers.
	(parse_real_register): Return NULL on eiz/riz if fake index
	registers aren't allowed.

gas/testsuite/

2007-09-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 658
	* gas/i386/i386.exp: Run sib-intel, x86-64-sib and
	x86-64-sib-intel.

	* gas/i386/nops-1-i386-i686.d: Updated.
	* gas/i386/nops-1-i386.d: Likewise.
	* gas/i386/nops-1.d: Likewise.
	* gas/i386/nops-2-i386.d: Likewise.
	* gas/i386/nops-2-merom.d: Likewise.
	* gas/i386/nops-2.d: Likewise.
	* gas/i386/nops-3-i386.d: Likewise.
	* gas/i386/nops-3.d : Likewise.
	* gas/i386/sib.d: Likewise.

	* gas/i386/sib.s: Use %eiz in testcases.

	* gas/i386/sib-intel.d: New.
	* gas/i386/x86-64-sib-intel.d: Likewise.
	* gas/i386/x86-64-sib.d: Likewise.
	* gas/i386/x86-64-sib.s: Likewise.

ld/testsuite/

2007-09-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 658
	* ld-i386/tlsbin.dd: Updated.
	* ld-i386/tlsld1.dd: Likewise.

opcodes/

2007-09-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 658
	* 386-dis.c (index64): New.
	(index32): Likewise.
	(intel_index64): Likewise.
	(intel_index32): Likewise.
	(att_index64): Likewise.
	(att_index32): Likewise.
	(print_insn): Set index64 and index32.
	(OP_E_extended): Use index64/index32 for index register for
	SIB with INDEX == 4.

	* i386-opc.h (RegEiz): New.
	(RegRiz): Likewise.

	* i386-reg.tbl: Add eiz and riz.
	* i386-tbl.h: Regenerated.
@
text
@a4978 1
      int opc_3b;
d4980 1
a4980 11
      /* All opcodes on i386 have either 1 or 2 bytes.  SSSE3 and
	 SSE4 and SSE5 instructions have 3 bytes.  We may use one 
	 more higher byte to specify a prefix the instruction 
	 requires. Exclude instructions which are in both SSE4.2 
	 and ABM.  */
      opc_3b = (i.tm.cpu_flags.bitfield.cpussse3
		|| i.tm.cpu_flags.bitfield.cpusse5
		|| i.tm.cpu_flags.bitfield.cpusse4_1
		|| (i.tm.cpu_flags.bitfield.cpusse4_2
		    && !i.tm.cpu_flags.bitfield.cpuabm));
      if (opc_3b)
d4982 1
d4988 3
a4990 5
	}
      else if ((i.tm.base_opcode & 0xff0000) != 0)
	{
	  prefix = (i.tm.base_opcode >> 16) & 0xff;
	  if (i.tm.cpu_flags.bitfield.cpupadlock)
d4992 9
a5000 3
	    check_prefix:
	      if (prefix != REPE_PREFIX_OPCODE
		  || i.prefix[LOCKREP_PREFIX] != REPE_PREFIX_OPCODE)
d5003 5
a5007 2
	  else
	    add_prefix (prefix);
d5023 1
a5023 1
      if (fits_in_unsigned_byte (i.tm.base_opcode))
d5029 1
a5029 1
	  if (opc_3b)
d5031 1
d5034 7
a5041 2
	  else
	    p = frag_more (2);
@


1.289
log
@gas/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (baseindex): Removed.
	(build_modrm_byte): Check reg_num for RIP register instead of
	reg_type.
	(i386_index_check): Likewise.

opcodes/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.h (RegRip): New.

	* i386-reg.tbl (rip): Use RegRip for reg_num.
	* i386-tbl.h: Regenerated.
@
text
@a45 8
#ifndef SCALE1_WHEN_NO_INDEX
/* Specifying a scale factor besides 1 when there is no index is
   futile.  eg. `mov (%ebx,2),%al' does exactly the same as
   `mov (%ebx),%al'.  To slavishly follow what the programmer
   specified, set SCALE1_WHEN_NO_INDEX to 0.  */
#define SCALE1_WHEN_NO_INDEX 1
#endif

d61 1
d290 3
d538 2
d1509 6
d4524 5
a4528 1
		  i.sib.index = i.index_reg->reg_num;
a4635 6
#if !SCALE1_WHEN_NO_INDEX
		  /* Another case where we force the second modrm
		     byte.  */
		  if (i.log2_scale_factor)
		    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
#endif
d4639 5
a4643 1
		  i.sib.index = i.index_reg->reg_num;
a5748 1
#if SCALE1_WHEN_NO_INDEX
a5749 1
#endif
d5987 3
a5989 1
		      && !i.index_reg->reg_type.bitfield.reg64)
d5991 1
d6018 2
a6019 1
		  && (!i.index_reg->reg_type.bitfield.reg32
d6915 6
@


1.288
log
@gas/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (intel_e04): Revert the last change.

gas/testsuite/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/x86-64-rip.s: Revert the last change.
	* gas/i386/x86-64-rip-intel.d: Likewise.
	* gas/i386/x86-64-rip.d: Likewise.
@
text
@a1100 1
static const i386_operand_type baseindex = OPERAND_TYPE_BASEINDEX;
d4543 1
a4543 1
	  else if (UINTS_EQUAL (i.base_reg->reg_type, baseindex))
d5979 1
a5979 1
	       || !UINTS_EQUAL (i.base_reg->reg_type, baseindex)))
@


1.287
log
@gas/

2007-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5034
	* config/tc-i386.c (intel_e04): Return 1 if cur_token.code is
	T_NIL.

gas/testsuite/

2007-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5034
	* gas/i386/x86-64-rip.s: Add Intel mode testcases.
	* gas/i386/x86-64-rip-intel.d: Updated.
	* gas/i386/x86-64-rip.d: Likewise.
@
text
@a7915 3
      if (cur_token.code == T_NIL)
	return 1;

@


1.286
log
@2007-09-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Adjust comment line
	wrap.
@
text
@d7916 3
@


1.285
log
@2007-09-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Use (A || B) instead
	of (A || B) != 0.
@
text
@d4630 2
a4631 2
		  /* Another case where we force the second 
		     modrm byte.  */
@


1.284
log
@2007-09-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Adjust indentation.
@
text
@d4376 1
a4376 1
       || i.tm.opcode_modifier.drexc) != 0 
d4473 3
a4475 3
 	  if ((i.tm.opcode_modifier.drex 
	       || i.tm.opcode_modifier.drexv 
	       || i.tm.opcode_modifier.drexc) != 0)
d4678 3
a4680 3
	  if ((i.tm.opcode_modifier.drex 
	       || i.tm.opcode_modifier.drexv 
	       || i.tm.opcode_modifier.drexc) != 0)
@


1.283
log
@Add AMD SSE5 support
@
text
@d4479 4
a4482 4
	  for (op = 0; op < i.operands; op++)
	    if (operand_type_check (i.types[op], anymem))
	      break;
	  assert (op < i.operands);
d4689 15
a4703 14
	  for (op = 0; op < i.operands; op++)
	    if (i.types[op].bitfield.reg8
		|| i.types[op].bitfield.reg16
		|| i.types[op].bitfield.reg32
		|| i.types[op].bitfield.reg64
		|| i.types[op].bitfield.regmmx
		|| i.types[op].bitfield.regxmm
		|| i.types[op].bitfield.sreg2
		|| i.types[op].bitfield.sreg3
		|| i.types[op].bitfield.control
		|| i.types[op].bitfield.debug
		|| i.types[op].bitfield.test)
	      break;
	  assert (op < i.operands);
d4707 12
a4718 12
	  if (i.tm.extension_opcode != None)
	    {
	      i.rm.regmem = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_B;
	    }
	  else
	    {
	      i.rm.reg = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_R;
	    }
@


1.282
log
@gas/
2007-09-12  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (md_assemble): Move handling of extrq/insertq
	after generic operand swapping, and swap only the immediate operands.

gas/testsuite/
2007-09-12  Jan Beulich  <jbeulich@@novell.com>
	* gas/i386/amdfam10.s, gas/i386/x86-64-amdfam10.s: Add Intel syntax
	code.
	* gas/i386/amdfam10.d, gas/i386/x86-64-amdfam10.d: Adjust.
@
text
@d92 1
d165 2
a166 1
       addressing modes of this insn are encoded.  */
d171 1
d514 2
d1775 2
d2264 8
a2271 3
	 operand from the opcode suffix stored in tm.extension_opcode.  */

      assert (i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);
d2353 8
a2360 1
  if (i.rex != 0)
d3881 330
d4219 6
d4295 2
a4296 1
	  /* The register or float register operand is in operand 0 or 1.  */
d4370 21
d4393 1
a4393 1
  if (i.reg_operands == 2)
d4471 8
d4483 1
d4630 2
a4631 1
		  /* Another case where we force the second modrm byte.  */
d4676 13
d4704 2
a4705 2
	  /* If there is an extension opcode to put here, the register
	     number must be put into the regmem field.  */
d4718 1
d4728 4
a4731 1
      if (i.tm.extension_opcode != None)
d4976 4
a4979 3
	 SSE4 instructions have 3 bytes.  We may use one more higher
	 byte to specify a prefix the instruction requires.  Exclude
	 instructions which are in both SSE4.2 and ABM.  */
d4981 1
d5037 7
d5072 14
@


1.281
log
@2007-09-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* tc-i386.c (output_insn): Only check SSE4.2 and ABM for 3
	byte opcode.
@
text
@a2137 14
  /* The order of the immediates should be reversed
     for 2 immediates extrq and insertq instructions */
  if ((i.imm_operands == 2)
      && ((strcmp (mnemonic, "extrq") == 0)
	  || (strcmp (mnemonic, "insertq") == 0)))
    {
      swap_2_operands (0, 1);
      /* "extrq" and insertq" are the only two instructions whose operands
	 have to be reversed even though they have two immediate operands.
      */
      if (intel_syntax)
	swap_operands ();
    }

d2153 7
@


1.280
log
@2007-09-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_flags_check_x64): Renamed to ...
	(cpu_flags_check_cpu64): This. Inline.
	(uints_all_zero): New.
	(uints_set): Likewise
	(uints_equal): Likewise
	(UINTS_ALL_ZERO): Likewise
	(UINTS_SET): Likewise
	(UINTS_CLEAR): Likewise
	(UINTS_EQUAL): Likewise
	(cpu_flags_and): Likewise.
	(cpu_flags_or): Likewise.
	(operand_type_and): Likewise.
	(operand_type_or): Likewise.
	(operand_type_xor): Likewise.
	(cpu_flags_not): Inline and use switch instead of loop.
	(cpu_flags_match): Updated.
	(operand_type_match): Likewise.
	(smallest_imm_type): Likewise.
	(set_cpu_arch): Likewise.
	(pt): Likewise.
	(md_assemble): Likewise.
	(parse_insn): Likewise.
	(optimize_imm): Likewise.
	(match_template): Likewise.
	(process_suffix): Likewise.
	(update_imm): Likewise.
	(finalize_imm): Likewise.
	(process_operands): Likewise.
	(build_modrm_byte): Likewise.
	(i386_immediate): Likewise.
	(i386_displacement): Likewise.
	(i386_index_check): Likewise.
	(i386_operand): Likewise.
	(i386_target_format): Likewise.
	(intel_e11): Likewise.
	(operand_type): Remove implicitregister.
	(operand_type_check): Updated. Inline.
	(cpu_flags_all_zero): Removed.
	(operand_type_all_zero): Likewise.
	(i386_array_biop): Likewise.
	(cpu_flags_biop): Likewise.
	(operand_type_biop): Likewise.
@
text
@d4581 5
a4585 5
	 instructions which are in both SSE4 and ABM.  */
      opc_3b = ((i.tm.cpu_flags.bitfield.cpussse3
		 || i.tm.cpu_flags.bitfield.cpusse4_1
		 || i.tm.cpu_flags.bitfield.cpusse4_2)
		&& !i.tm.cpu_flags.bitfield.cpuabm);
@


1.279
log
@gas/

2007-09-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in (AC_CHECK_HEADERS): Add limits.h.
	* configure: Regenerated.
	* config.in: Likewise.

	* config/tc-i386.c: Include "opcodes/i386-init.h".
	(_i386_insn): Use i386_operand_type for types.
	(cpu_arch_flags): Updated to new types with bitfield.
	(cpu_arch_tune_flags): Likewise.
	(cpu_arch_isa_flags): Likewise.
	(cpu_arch): Likewise.
	(i386_align_code): Likewise.
	(set_code_flag): Likewise.
	(set_16bit_gcc_code_flag): Likewise.
	(set_cpu_arch): Likewise.
	(md_assemble): Likewise.
	(parse_insn): Likewise.
	(process_operands): Likewise.
	(output_branch): Likewise.
	(output_jump): Likewise.
	(parse_real_register): Likewise.
	(mode_from_disp_size): Likewise.
	(smallest_imm_type): Likewise.
	(pi): Likewise.
	(type_names): Likewise.
	(pt): Likewise.
	(pte): Likewise.
	(swap_2_operands): Likewise.
	(optimize_imm): Likewise.
	(optimize_disp): Likewise.
	(match_template): Likewise.
	(check_string): Likewise.
	(process_suffix): Likewise.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
	(finalize_imm): Likewise.
	(build_modrm_byte): Likewise.
	(output_insn): Likewise.
	(disp_size): Likewise.
	(imm_size): Likewise.
	(output_disp): Likewise.
	(output_imm): Likewise.
	(gotrel): Likewise.
	(i386_immediate): Likewise.
	(i386_displacement): Likewise.
	(i386_index_check): Likewise.
	(i386_operand): Likewise.
	(parse_real_register): Likewise.
	(i386_intel_operand): Likewise.
	(intel_e09): Likewise.
	(intel_bracket_expr): Likewise.
	(intel_e11): Likewise.
	(cpu_arch_flags_not): New.
	(cpu_flags_check_x64): Likewise.
	(cpu_flags_all_zero): Likewise.
	(cpu_flags_not): Likewise.
	(i386_cpu_flags_biop): Likewise.
	(cpu_flags_biop): Likewise.
	(cpu_flags_match); Likewise.
	(acc32): New.
	(acc64): Likewise.
	(control): Likewise.
	(reg16_inoutportreg): Likewise.
	(disp16): Likewise.
	(disp32): Likewise.
	(disp32s): Likewise.
	(disp16_32): Likewise.
	(anydisp): Likewise.
	(baseindex): Likewise.
	(regxmm): Likewise.
	(imm8): Likewise.
	(imm8s): Likewise.
	(imm16): Likewise.
	(imm32): Likewise.
	(imm32s): Likewise.
	(imm64): Likewise.
	(imm16_32): Likewise.
	(imm16_32s): Likewise.
	(imm16_32_32s): Likewise.
	(operand_type): Likewise.
	(operand_type_check): Likewise.
	(operand_type_match): Likewise.
	(operand_type_register_match): Likewise.
	(update_imm): Likewise.
	(set_code_flag): Also update cpu_arch_flags_not.
	(set_16bit_gcc_code_flag): Likewise.
	(md_begin): Likewise.
	(parse_insn): Use cpu_flags_check_x64 to check 64bit support.
	Use cpu_flags_match to match instructions.
	(i386_target_format): Update cpu_arch_isa_flags and
	cpu_arch_tune_flags to i386_cpu_flags type with bitfield.
	(smallest_imm_type): Check cpu_arch_tune to tune for i486.
	(match_template): Don't initialize overlap0, overlap1,
	overlap2, overlap3 and operand_types.
	(process_suffix): Handle crc32 with 64bit register.
	(MATCH): Removed.
	(CONSISTENT_REGISTER_MATCH): Likewise.

	* config/tc-i386.h (arch_entry): Updated to i386_cpu_flags
	type.

opcodes/

2007-09-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in (AC_CHECK_HEADERS): Add limits.h.
	* configure: Regenerated.
	* config.in: Likewise.

	* i386-gen.c: Include "sysdep.h" instead of <stdlib.h> and
	<string.h>.  Use xstrerror instead of strerror.
	(initializer): New.
	(cpu_flag_init): Likewise.
	(bitfield): Likewise.
	(BITFIELD): New.
	(cpu_flags): Likewise.
	(opcode_modifiers): Likewise.
	(operand_types): Likewise.
	(compare): Likewise.
	(set_cpu_flags): Likewise.
	(output_cpu_flags): Likewise.
	(process_i386_cpu_flags): Likewise.
	(output_opcode_modifier): Likewise.
	(process_i386_opcode_modifier): Likewise.
	(output_operand_type): Likewise.
	(process_i386_operand_type): Likewise.
	(set_bitfield): Likewise.
	(operand_type_init): Likewise.
	(process_i386_initializers): Likewise.
	(process_i386_opcodes): Call process_i386_opcode_modifier to
	process opcode_modifier.  Call process_i386_operand_type to
	process operand_types.
	(process_i386_registers): Call process_i386_operand_type to
	process reg_type.
	(main): Check unused bits in i386_cpu_flags and i386_operand_type.
	Sort cpu_flags, opcode_modifiers and operand_types.  Call
	process_i386_initializers.

	* i386-init.h: New.
	* i386-tbl.h: Regenerated.

	* i386-opc.h: Include <limits.h>.
	(CHAR_BIT): Define as 8 if not defined.
	(Cpu186): Changed to position of bitfiled.
	(Cpu286): Likewise.
	(Cpu386): Likewise.
	(Cpu486): Likewise.
	(Cpu586): Likewise.
	(Cpu686): Likewise.
	(CpuP4): Likewise.
	(CpuK6): Likewise.
	(CpuK8): Likewise.
	(CpuMMX): Likewise.
	(CpuMMX2): Likewise.
	(CpuSSE): Likewise.
	(CpuSSE2): Likewise.
	(Cpu3dnow): Likewise.
	(Cpu3dnowA): Likewise.
	(CpuSSE3): Likewise.
	(CpuPadLock): Likewise.
	(CpuSVME): Likewise.
	(CpuVMX): Likewise.
	(CpuSSSE3): Likewise.
	(CpuSSE4a): Likewise.
	(CpuABM): Likewise.
	(CpuSSE4_1): Likewise.
	(CpuSSE4_2): Likewise.
	(Cpu64): Likewise.
	(CpuNo64): Likewise.
	(D): Likewise.
	(W): Likewise.
	(Modrm): Likewise.
	(ShortForm): Likewise.
	(Jump): Likewise.
	(JumpDword): Likewise.
	(JumpByte): Likewise.
	(JumpInterSegment): Likewise.
	(FloatMF): Likewise.
	(FloatR): Likewise.
	(FloatD): Likewise.
	(Size16): Likewise.
	(Size32): Likewise.
	(Size64): Likewise.
	(IgnoreSize): Likewise.
	(DefaultSize): Likewise.
	(No_bSuf): Likewise.
	(No_wSuf): Likewise.
	(No_lSuf): Likewise.
	(No_sSuf): Likewise.
	(No_qSuf): Likewise.
	(No_xSuf): Likewise.
	(FWait): Likewise.
	(IsString): Likewise.
	(RegKludge): Likewise.
	(IsPrefix): Likewise.
	(ImmExt): Likewise.
	(NoRex64): Likewise.
	(Rex64): Likewise.
	(Ugh): Likewise.
	(Reg8): Likewise.
	(Reg16): Likewise.
	(Reg32): Likewise.
	(Reg64): Likewise.
	(FloatReg): Likewise.
	(RegMMX): Likewise.
	(RegXMM): Likewise.
	(Imm8): Likewise.
	(Imm8S): Likewise.
	(Imm16): Likewise.
	(Imm32): Likewise.
	(Imm32S): Likewise.
	(Imm64): Likewise.
	(Imm1): Likewise.
	(BaseIndex): Likewise.
	(Disp8): Likewise.
	(Disp16): Likewise.
	(Disp32): Likewise.
	(Disp32S): Likewise.
	(Disp64): Likewise.
	(InOutPortReg): Likewise.
	(ShiftCount): Likewise.
	(Control): Likewise.
	(Debug): Likewise.
	(Test): Likewise.
	(SReg2): Likewise.
	(SReg3): Likewise.
	(Acc): Likewise.
	(FloatAcc): Likewise.
	(JumpAbsolute): Likewise.
	(EsSeg): Likewise.
	(RegMem): Likewise.
	(OTMax): Likewise.
	(Reg): Commented out.
	(WordReg): Likewise.
	(ImplicitRegister): Likewise.
	(Imm): Likewise.
	(EncImm): Likewise.
	(Disp): Likewise.
	(AnyMem): Likewise.
	(LLongMem): Likewise.
	(LongMem): Likewise.
	(ShortMem): Likewise.
	(WordMem): Likewise.
	(ByteMem): Likewise.
	(CpuMax): New
	(CpuLM): Likewise.
	(CpuNumOfUints): Likewise.
	(CpuNumOfBits): Likewise.
	(CpuUnused): Likewise.
	(OTNumOfUints): Likewise.
	(OTNumOfBits): Likewise.
	(OTUnused): Likewise.
	(i386_cpu_flags): New type.
	(i386_operand_type): Likewise.
	(i386_opcode_modifier): Likewise.
	(CpuSledgehammer): Removed.
	(CpuSSE4): Likewise.
	(CpuUnknownFlags): Likewise.
	(Reg): Likewise.
	(WordReg): Likewise.
	(ImplicitRegister): Likewise.
	(Imm): Likewise.
	(EncImm): Likewise.
	(Disp): Likewise.
	(AnyMem): Likewise.
	(LLongMem): Likewise.
	(LongMem): Likewise.
	(ShortMem): Likewise.
	(WordMem): Likewise.
	(ByteMem): Likewise.
	(template): Use i386_cpu_flags for cpu_flags, use
	i386_opcode_modifier for opcode_modifier, use
	i386_operand_type for operand_types.
	(reg_entry): Use i386_operand_type for reg_type.

	* Makefile.am (HFILES): Add i386-init.h.
	($(srcdir)/i386-init.h): New rule.
	($(srcdir)/i386-tbl.h): Depend on $(srcdir)/i386-init.h
	instead.
	* Makefile.in: Regenerated.
@
text
@d886 20
a905 2
static int
cpu_flags_check_x64 (i386_cpu_flags f)
d907 12
a918 2
  return !((flag_code == CODE_64BIT && f.bitfield.cpuno64)
	   || (flag_code != CODE_64BIT && f.bitfield.cpu64));
d921 3
a923 2
static int
cpu_flags_all_zero (i386_cpu_flags f)
d925 15
a939 1
  unsigned int j;
d941 8
a948 3
  for (j = 0; j < ARRAY_SIZE (f.array); j++)
    if (f.array [j])
      return 0;
d950 5
a954 1
  return 1;
d957 1
a957 1
static i386_cpu_flags
d960 12
a971 4
  unsigned int j;

  for (j = 0; j < ARRAY_SIZE (x.array); j++)
    x.array [j] = ~x.array [j];
d980 2
a981 1
enum i386_array_biop
d983 14
a996 4
  and,
  or,
  xor
};
d998 2
a999 3
static i386_cpu_flags
cpu_flags_biop (i386_cpu_flags x, i386_cpu_flags y,
		enum i386_array_biop op)
d1001 1
a1001 3
  unsigned int j;

  switch (op)
d1003 6
a1008 11
    case and:
      for (j = 0; j < ARRAY_SIZE (x.array); j++)
	x.array [j] &= y.array [j];
      break;
    case or:
      for (j = 0; j < ARRAY_SIZE (x.array); j++)
	x.array [j] |= y.array [j];
      break;
    case xor:
      for (j = 0; j < ARRAY_SIZE (x.array); j++)
	x.array [j] ^= y.array [j];
a1012 1

d1027 2
a1028 1
  return cpu_flags_all_zero (cpu_flags_biop (x, not, and));
d1031 2
a1032 2
static int
operand_type_all_zero (i386_operand_type t)
d1034 14
a1047 1
  unsigned int j;
d1049 16
a1064 5
  for (j = 0; j < ARRAY_SIZE (t.array); j++)
    if (t.array [j])
      return 0;

  return 1;
d1067 2
a1068 3
static i386_operand_type
operand_type_biop (i386_operand_type x, i386_operand_type y,
		   enum i386_array_biop op)
d1070 1
a1070 3
  unsigned int j;

  switch (op)
d1072 6
a1077 11
    case and:
      for (j = 0; j < ARRAY_SIZE (x.array); j++)
	x.array [j] &= y.array [j];
      break;
    case or:
      for (j = 0; j < ARRAY_SIZE (x.array); j++)
	x.array [j] |= y.array [j];
      break;
    case xor:
      for (j = 0; j < ARRAY_SIZE (x.array); j++)
	x.array [j] ^= y.array [j];
a1081 1

a1110 1
  implicitregister,
d1116 1
a1116 1
static int
a1126 6
    case implicitregister:
      return (t.bitfield.inoutportreg
	      || t.bitfield.shiftcount
	      || t.bitfield.acc
	      || t.bitfield.floatacc);

d1155 1
a1155 1
static int
d1162 1
a1162 1
  if (operand_type_all_zero (temp))
d1173 1
a1173 1
static int
d1278 1
a1278 1
  memset (&t, 0, sizeof (t));
d1548 3
a1550 3
	      flags = cpu_flags_biop (cpu_arch_flags,
				      cpu_arch[i].flags, or);
	      if (memcmp (&flags, &cpu_arch_flags, sizeof (flags)))
d1888 1
d1891 5
a1895 4
    if (!operand_type_all_zero (operand_type_biop (t,
						   type_names[j].mask,
						   and)))
      fprintf (stdout, "%s, ",  type_names[j].name);
d2233 4
a2236 1
    if (operand_type_check (i.types[j], implicitregister))
d2270 1
a2270 1
      memset (&i.types[i.operands], 0, sizeof (i.types[i.operands]));
d2407 1
a2407 1
	  if (!cpu_flags_check_x64 (current_templates->start->cpu_flags))
d2527 1
a2527 1
      if (cpu_flags_check_x64 (t->cpu_flags))
d2825 2
a2826 3
	      = operand_type_biop (i.types[op],
				   smallest_imm_type (i.op[op].imms->X_add_number),
				   or);
d2847 2
a2848 2
	      memset (&mask, 0, sizeof (mask));
	      memset (&allowed, 0, sizeof (allowed));
d2853 2
a2854 2
		allowed = operand_type_biop (allowed,
					     t->operand_types[op], or);
d2873 3
a2875 5
	      if (!operand_type_all_zero (operand_type_biop (mask,
							     allowed,
							     and)))
		i.types[op] = operand_type_biop (i.types[op],
						 mask, and);
d2968 1
d3028 1
a3028 1
      else if (!t->operands)
d3030 8
a3037 6
	  if (!cpu_flags_all_zero (cpu_flags_biop (t->cpu_flags,
						   cpu_arch_flags_not,
						   and)))
	    continue;
	  /* We've found a match; break out of loop.  */
	  break;
d3086 1
a3086 2
      overlap0 = operand_type_biop (i.types[0], operand_types[0],
				    and);
d3100 2
a3101 2
	      && memcmp (&i.types [0], &acc32, sizeof (acc32)) == 0
	      && memcmp (&i.types [1], &acc32, sizeof (acc32)) == 0)
d3105 1
a3105 2
	  overlap1 = operand_type_biop (i.types[1], operand_types[1],
					and);
d3130 2
a3131 4
	      overlap0 = operand_type_biop (i.types[0], operand_types[1],
					    and);
	      overlap1 = operand_type_biop (i.types[1], operand_types[0],
					    and);
d3159 2
a3160 2
		  overlap3 = operand_type_biop (i.types[3],
						operand_types[3], and);
d3162 2
a3163 2
		  overlap2 = operand_type_biop (i.types[2],
						operand_types[2], and);
d3197 1
a3197 3
      if (!cpu_flags_all_zero (cpu_flags_biop (t->cpu_flags,
					       cpu_arch_flags_not,
					       and)))
d3522 2
a3523 2
		 && memcmp (&i.types [0], &acc64, sizeof (acc64)) == 0
		 && memcmp (&i.types [1], &acc64, sizeof (acc64)) == 0)
d3792 1
a3792 2
  overlap = operand_type_biop (i.types[j], i.tm.operand_types[j],
			       and);
d3799 6
a3804 6
      && memcmp (&overlap, &imm8, sizeof (overlap))
      && memcmp (&overlap, &imm8s, sizeof (overlap))
      && memcmp (&overlap, &imm16, sizeof (overlap))
      && memcmp (&overlap, &imm32, sizeof (overlap))
      && memcmp (&overlap, &imm32s, sizeof (overlap))
      && memcmp (&overlap, &imm64, sizeof (overlap)))
d3810 1
a3810 1
	  memset (&temp, 0, sizeof (temp));
d3827 3
a3829 3
      else if (memcmp (&overlap, &imm16_32_32s, sizeof (overlap)) == 0
	       || memcmp (&overlap, &imm16_32, sizeof (overlap)) == 0
	       || memcmp (&overlap, &imm16_32s, sizeof (overlap)) == 0)
d3831 1
a3831 1
	  memset (&overlap, 0, sizeof (overlap));
d3837 6
a3842 6
      if (memcmp (&overlap, &imm8, sizeof (overlap))
	  && memcmp (&overlap, &imm8s, sizeof (overlap))
	  && memcmp (&overlap, &imm16, sizeof (overlap))
	  && memcmp (&overlap, &imm32, sizeof (overlap))
	  && memcmp (&overlap, &imm32s, sizeof (overlap))
	  && memcmp (&overlap, &imm64, sizeof (overlap)))
d3863 1
a3863 2
  i.types[2] = operand_type_biop (i.types[2], i.tm.operand_types[2],
				  and);
d3888 1
a3888 1
		   && memcmp (&i.types[0], &regxmm, sizeof (regxmm)) == 0);
d4165 1
a4165 2
	  else if (memcmp (&i.base_reg->reg_type, &baseindex,
			   sizeof (baseindex)) == 0)
d4213 1
a4213 2

		  memset (&temp, 0, sizeof (temp));
d5196 1
a5196 1
  memset (&types, ~0, sizeof (types));
d5277 2
a5278 2
      i.types[this_operand] = operand_type_biop (i.types[this_operand],
						 types, and);
d5350 1
a5350 1
  memset (&bigdisp, 0, sizeof (bigdisp));
d5400 2
a5401 2
  i.types[this_operand] = operand_type_biop (i.types[this_operand],
					     bigdisp, or);
d5531 3
a5533 3
  if (operand_type_all_zero (bigdisp))
    i.types[this_operand] = operand_type_biop (i.types[this_operand],
					       types, and);
d5559 1
a5559 2
	       || memcmp (&i.base_reg->reg_type, &baseindex,
			  sizeof (baseindex))))
d5612 1
a5612 2
	      = operand_type_biop (i.types[this_operand], disp16_32,
				   xor);
d5717 2
a5718 2
      i.types[this_operand] = operand_type_biop (i.types[this_operand],
						 temp, or);
d5898 1
a5898 2
	  && memcmp (&i.base_reg->reg_type, &reg16_inoutportreg,
		     sizeof (reg16_inoutportreg)) == 0
d5904 1
a5904 2
	  memset (&i.types[this_operand], 0,
		  sizeof (i.types[this_operand]));
d6491 1
a6491 1
	  || memcmp (&r->reg_type, &control, sizeof (control)))
d6766 1
a6766 1
      if (cpu_flags_all_zero (cpu_arch_isa_flags))
d6780 1
a6780 1
      if (cpu_flags_all_zero (cpu_arch_tune_flags))
d6798 1
a6798 1
      if (cpu_flags_all_zero (cpu_arch_isa_flags))
d6804 1
a6804 1
      if (cpu_flags_all_zero (cpu_arch_tune_flags))
d8070 2
a8071 2
	    i.types[this_operand] = operand_type_biop (i.types[this_operand],
						       temp, or);
@


1.278
log
@gas/

2007-09-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Handle invlpga, vmload,
	vmrun and vmsave in SVME.
	(process_suffix): Likewise.

gas/testsuite/

2007-09-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/svme.s: Updated to allow eax in 64bit.
	* gas/i386/svme.d: Updated.
	* gas/i386/svme64.d: Likewise.

opcodes/

2007-09-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.tbl: Correct SVME instructions to allow 32bit register
	operand in 64bit mode.
	* i386-tbl.h: Regenerated.
@
text
@d36 1
d135 1
a135 1
    unsigned int types[MAX_OPERANDS];
d313 4
a316 1
static unsigned int cpu_arch_flags = CpuUnknownFlags | CpuNo64;
d325 1
a325 1
static unsigned int cpu_arch_tune_flags = 0;
d331 1
a331 1
static unsigned int cpu_arch_isa_flags = 0;
d428 1
a428 1
   Cpu186|Cpu286|Cpu386},
d430 1
a430 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
   |CpuMMX2|CpuSSE|CpuSSE2},
d432 1
a432 1
   0},
d434 1
a434 1
   Cpu186},
d436 1
a436 1
   Cpu186|Cpu286},
d438 1
a438 1
   Cpu186|Cpu286|Cpu386},
d440 1
a440 1
   Cpu186|Cpu286|Cpu386|Cpu486},
d442 1
a442 1
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586},
d444 1
a444 1
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686},
d446 1
a446 1
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586},
d448 1
a448 1
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686},
d450 1
a450 1
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX},
d452 1
a452 1
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuMMX2|CpuSSE},
d454 1
a454 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
   |CpuMMX2|CpuSSE|CpuSSE2},
d456 1
a456 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
d458 1
a458 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
d460 1
a460 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
d462 1
a462 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
d464 1
a464 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3},
d466 1
a466 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3},
d468 1
a468 1
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX},
d470 1
a470 1
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX|Cpu3dnow},
d472 1
a472 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6
   |CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA},
d474 1
a474 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6
   |CpuSledgehammer|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2},
d476 1
a476 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6
   |CpuSledgehammer|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2},
d478 1
a478 2
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6
   |CpuSledgehammer|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2},
d480 1
a480 3
   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuSledgehammer
   |CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2|CpuSSE3|CpuSSE4a
   |CpuABM},
d482 1
a482 1
   CpuMMX},
d484 1
a484 1
   CpuMMX|CpuMMX2|CpuSSE},
d486 1
a486 1
   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2},
d488 1
a488 1
   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
d490 1
a490 1
   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3},
d492 1
a492 1
   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3|CpuSSE4_1},
d494 1
a494 1
   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3|CpuSSE4},
d496 1
a496 1
   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3|CpuSSE4},
d498 1
a498 1
   CpuMMX|Cpu3dnow},
d500 1
a500 1
   CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA},
d502 1
a502 1
   CpuPadLock},
d504 1
a504 1
   CpuSVME},
d506 1
a506 1
   CpuSVME},
d508 1
a508 1
   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSE4a},
d510 1
a510 1
   CpuABM}
d781 1
a781 1
	      if ((cpu_arch_isa_flags & Cpu686) != 0)
d828 1
a828 1
	      if ((cpu_arch_isa_flags & Cpu686) != 0)
d838 1
a838 1
	      if ((cpu_arch_isa_flags & Cpu686) != 0)
d886 258
d1145 1
a1145 1
mode_from_disp_size (unsigned int t)
d1147 8
a1154 1
  return (t & Disp8) ? 1 : (t & (Disp16 | Disp32 | Disp32S)) ? 2 : 0;
d1202 1
a1202 1
static unsigned int
d1205 6
a1210 1
  if (cpu_arch_flags != (Cpu186 | Cpu286 | Cpu386 | Cpu486 | CpuNo64))
d1217 21
a1237 2
      if (num == 1)
	return Imm1 | Imm8 | Imm8S | Imm16 | Imm32 | Imm32S | Imm64;
d1239 15
a1253 11
  return (fits_in_signed_byte (num)
	  ? (Imm8S | Imm8 | Imm16 | Imm32 | Imm32S | Imm64)
	  : fits_in_unsigned_byte (num)
	  ? (Imm8 | Imm16 | Imm32 | Imm32S | Imm64)
	  : (fits_in_signed_word (num) || fits_in_unsigned_word (num))
	  ? (Imm16 | Imm32 | Imm32S | Imm64)
	  : fits_in_signed_long (num)
	  ? (Imm32 | Imm32S | Imm64)
	  : fits_in_unsigned_long (num)
	  ? (Imm32 | Imm64)
	  : Imm64);
d1362 15
a1376 3
  cpu_arch_flags &= ~(Cpu64 | CpuNo64);
  cpu_arch_flags |= (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
  if (value == CODE_64BIT && !(cpu_arch_flags & CpuSledgehammer))
d1380 1
a1380 1
  if (value == CODE_32BIT && !(cpu_arch_flags & Cpu386))
d1391 6
a1396 2
  cpu_arch_flags &= ~(Cpu64 | CpuNo64);
  cpu_arch_flags |= (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
d1445 1
d1455 12
a1466 3
		  cpu_arch_flags = (cpu_arch[i].flags
				    | (flag_code == CODE_64BIT
				       ? Cpu64 : CpuNo64));
d1476 4
a1479 1
	      if ((cpu_arch_flags | cpu_arch[i].flags) != cpu_arch_flags)
d1482 2
a1483 1
		  cpu_arch_flags |= cpu_arch[i].flags;
d1534 2
d1675 1
a1675 1
static void pt (unsigned int);
d1704 11
a1714 2
      if (x->types[i]
	  & (Reg | SReg2 | SReg3 | Control | Debug | Test | RegMMX | RegXMM))
d1716 1
a1716 1
      if (x->types[i] & Imm)
d1718 1
a1718 1
      if (x->types[i] & Disp)
d1731 1
a1731 1
  if (t->opcode_modifier & D)
d1733 1
a1733 1
  if (t->opcode_modifier & W)
d1775 2
a1776 2
    unsigned int mask;
    char *tname;
d1780 31
a1810 32
  { Reg8, "r8" },
  { Reg16, "r16" },
  { Reg32, "r32" },
  { Reg64, "r64" },
  { Imm8, "i8" },
  { Imm8S, "i8s" },
  { Imm16, "i16" },
  { Imm32, "i32" },
  { Imm32S, "i32s" },
  { Imm64, "i64" },
  { Imm1, "i1" },
  { BaseIndex, "BaseIndex" },
  { Disp8, "d8" },
  { Disp16, "d16" },
  { Disp32, "d32" },
  { Disp32S, "d32s" },
  { Disp64, "d64" },
  { InOutPortReg, "InOutPortReg" },
  { ShiftCount, "ShiftCount" },
  { Control, "control reg" },
  { Test, "test reg" },
  { Debug, "debug reg" },
  { FloatReg, "FReg" },
  { FloatAcc, "FAcc" },
  { SReg2, "SReg2" },
  { SReg3, "SReg3" },
  { Acc, "Acc" },
  { JumpAbsolute, "Jump Absolute" },
  { RegMMX, "rMMX" },
  { RegXMM, "rXMM" },
  { EsSeg, "es" },
  { 0, "" }
d1814 1
a1814 2
pt (t)
     unsigned int t;
d1816 1
a1816 1
  const struct type_name *ty;
d1818 5
a1822 3
  for (ty = type_names; ty->mask; ty++)
    if (t & ty->mask)
      fprintf (stdout, "%s, ", ty->tname);
d2042 1
a2042 1
  int j;
d2090 2
a2091 1
      && !((i.types[0] & Imm) && (i.types[1] & Imm)))
d2125 6
a2130 7
	      && (~i.tm.opcode_modifier
		  & (No_bSuf
		     | No_wSuf
		     | No_lSuf
		     | No_sSuf
		     | No_xSuf
		     | No_qSuf)))
d2137 1
a2137 1
  if (i.tm.opcode_modifier & FWait)
d2142 1
a2142 1
  if ((i.tm.opcode_modifier & IsString) != 0 && i.mem_operands != 0)
d2156 1
a2156 1
  if (i.types[0] & Imm1)
a2157 6
  if (i.types[0] & ImplicitRegister)
    i.reg_operands--;
  if (i.types[1] & ImplicitRegister)
    i.reg_operands--;
  if (i.types[2] & ImplicitRegister)
    i.reg_operands--;
d2159 5
a2163 1
  if (i.tm.opcode_modifier & ImmExt)
d2167 1
a2167 1
      if ((i.tm.cpu_flags & CpuSSE3) && i.operands > 0)
d2194 3
a2196 1
      i.types[i.operands++] = Imm8;
d2208 1
a2208 1
  else if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
d2221 3
a2223 1
  if ((i.tm.opcode_modifier & (Jump | JumpByte | JumpDword))
d2233 1
a2233 1
  if ((i.tm.opcode_modifier & Rex64) != 0)
d2240 1
a2240 1
  if (((i.types[0] & Reg8) != 0
d2242 1
a2242 1
      || ((i.types[1] & Reg8) != 0
d2244 2
a2245 1
      || (((i.types[0] & Reg8) != 0 || (i.types[1] & Reg8) != 0)
d2254 1
a2254 1
	  if ((i.types[x] & Reg8) != 0
d2329 1
a2329 1
	  && (current_templates->start->opcode_modifier & IsPrefix))
d2331 1
a2331 2
	  if (current_templates->start->cpu_flags
	      & (flag_code != CODE_64BIT ? Cpu64 : CpuNo64))
d2341 2
a2342 1
	  if ((current_templates->start->opcode_modifier & (Size16 | Size32))
d2344 1
a2344 1
	      && (((current_templates->start->opcode_modifier & Size32) != 0)
d2412 2
a2413 1
  if (current_templates->start->opcode_modifier & (Jump | JumpByte))
d2449 1
a2449 2
      if (!((t->cpu_flags & ~(Cpu64 | CpuNo64))
	    & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64))))
d2451 1
a2451 1
      if (!(t->cpu_flags & (flag_code == CODE_64BIT ? CpuNo64 : Cpu64)))
d2469 2
a2470 1
  else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
d2481 1
a2481 1
	if (t->opcode_modifier & IsString)
d2490 1
a2490 1
	if (!(t->opcode_modifier & IsString))
d2621 1
a2621 1
  unsigned int temp_type;
d2676 11
a2686 1
	if (i.types[op] & Reg)
d2688 6
a2693 8
	    if (i.types[op] & Reg8)
	      guess_suffix = BYTE_MNEM_SUFFIX;
	    else if (i.types[op] & Reg16)
	      guess_suffix = WORD_MNEM_SUFFIX;
	    else if (i.types[op] & Reg32)
	      guess_suffix = LONG_MNEM_SUFFIX;
	    else if (i.types[op] & Reg64)
	      guess_suffix = QWORD_MNEM_SUFFIX;
d2701 1
a2701 1
    if (i.types[op] & Imm)
d2710 2
a2711 1
		i.types[op] |= Imm32 | Imm64;
d2714 4
a2717 1
		i.types[op] |= Imm16 | Imm32S | Imm32 | Imm64;
d2720 6
a2725 1
		i.types[op] |= Imm16 | Imm8 | Imm8S | Imm32S | Imm32 | Imm64;
d2734 1
a2734 1
	    if ((i.types[op] & Imm16)
d2740 1
a2740 1
	    if ((i.types[op] & Imm32)
d2748 4
a2751 1
	    i.types[op] |= smallest_imm_type (i.op[op].imms->X_add_number);
d2756 1
a2756 1
	      i.types[op] &= ~Imm32;
d2769 1
a2769 1
	      unsigned int mask, allowed = 0;
d2772 3
d2778 2
a2779 1
		allowed |= t->operand_types[op];
d2783 2
a2784 1
		  mask = Imm64 | Imm32S;
d2787 1
a2787 1
		  mask = Imm32;
d2790 1
a2790 1
		  mask = Imm16;
d2793 1
a2793 1
		  mask = Imm8;
a2795 1
		  mask = 0;
d2798 5
a2802 2
	      if (mask & allowed)
		i.types[op] &= mask;
d2816 1
a2816 1
    if (i.types[op] & Disp)
d2822 1
a2822 1
	    if ((i.types[op] & Disp16)
d2829 1
a2829 1
		i.types[op] &= ~Disp64;
d2831 1
a2831 1
	    if ((i.types[op] & Disp32)
d2839 1
a2839 1
		i.types[op] &= ~Disp64;
d2841 1
a2841 1
	    if (!disp && (i.types[op] & BaseIndex))
d2843 5
a2847 1
		i.types[op] &= ~Disp;
d2855 2
a2856 2
		    i.types[op] &= ~Disp64;
		    i.types[op] |= Disp32S;
d2859 1
a2859 1
		  i.types[op] |= Disp32;
d2861 3
a2863 1
	    if ((i.types[op] & (Disp32 | Disp32S | Disp16))
d2865 1
a2865 1
	      i.types[op] |= Disp8;
d2872 5
a2876 1
	    i.types[op] &= ~Disp;
d2880 1
a2880 1
	  i.types[op] &= ~Disp64;
d2889 1
a2889 1
  unsigned int overlap0, overlap1, overlap2, overlap3;
d2891 2
a2892 2
  int suffix_check;
  unsigned int operand_types [MAX_OPERANDS];
a2899 17
#define MATCH(overlap, given, template)				\
  ((overlap & ~JumpAbsolute)					\
   && (((given) & (BaseIndex | JumpAbsolute))			\
       == ((overlap) & (BaseIndex | JumpAbsolute))))

  /* If given types r0 and r1 are registers they must be of the same type
     unless the expected operand type register overlap is null.
     Note that Acc in a template matches every size of reg.  */
#define CONSISTENT_REGISTER_MATCH(m0, g0, t0, m1, g1, t1)	\
  (((g0) & Reg) == 0 || ((g1) & Reg) == 0			\
   || ((g0) & Reg) == ((g1) & Reg)				\
   || ((((m0) & Acc) ? Reg : (t0)) & (((m1) & Acc) ? Reg : (t1)) & Reg) == 0 )

  overlap0 = 0;
  overlap1 = 0;
  overlap2 = 0;
  overlap3 = 0;
a2900 2
  for (j = 0; j < MAX_OPERANDS; j++)
    operand_types [j] = 0;
d2902 14
a2915 12
  suffix_check = (i.suffix == BYTE_MNEM_SUFFIX
		  ? No_bSuf
		  : (i.suffix == WORD_MNEM_SUFFIX
		     ? No_wSuf
		     : (i.suffix == SHORT_MNEM_SUFFIX
			? No_sSuf
			: (i.suffix == LONG_MNEM_SUFFIX
			   ? No_lSuf
			   : (i.suffix == QWORD_MNEM_SUFFIX
			      ? No_qSuf
			      : (i.suffix == LONG_DOUBLE_MNEM_SUFFIX
				 ? No_xSuf : 0))))));
d2926 7
a2932 3
      if ((t->opcode_modifier & suffix_check)
	  && !(intel_syntax
	       && (t->opcode_modifier & IgnoreSize)))
d2942 1
a2942 1
	      ? (!(t->opcode_modifier & IgnoreSize)
d2945 4
a2948 2
	  && (!(operand_types[0] & (RegMMX | RegXMM))
	      || !(operand_types[t->operands > 1] & (RegMMX | RegXMM)))
d2956 3
a2958 1
	  if (t->cpu_flags & ~cpu_arch_flags)
d2968 1
a2968 2
	    unsigned int DispOn = 0, DispOff = 0;

d2972 10
a2981 2
	      DispOn = Disp32;
	      DispOff = Disp16;
d2984 10
a2993 2
	      DispOn = Disp16;
	      DispOff = Disp32;
d2996 10
a3005 2
	      DispOn = Disp32;
	      DispOff = Disp64;
a3007 12

	    for (j = 0; j < MAX_OPERANDS; j++)
	      {
		/* There should be only one Disp operand.  */
		if ((operand_types[j] & DispOff))
		  {
		    addr_prefix_disp = j;
		    operand_types[j] |= DispOn;
		    operand_types[j] &= ~DispOff;
		    break;
		  }
	      }
d3010 2
a3011 1
      overlap0 = i.types[0] & operand_types[0];
d3015 1
a3015 1
	  if (!MATCH (overlap0, i.types[0], operand_types[0]))
d3025 2
a3026 2
	      && i.types [0] == (Acc | Reg32)
	      && i.types [1] == (Acc | Reg32))
d3030 4
a3033 3
	  overlap1 = i.types[1] & operand_types[1];
	  if (!MATCH (overlap0, i.types[0], operand_types[0])
	      || !MATCH (overlap1, i.types[1], operand_types[1])
d3046 4
a3049 4
		   || CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
						 operand_types[0],
						 overlap1, i.types[1],
						 operand_types[1])))
d3052 1
a3052 1
	      if ((t->opcode_modifier & (D | FloatD)) == 0)
d3056 10
a3065 8
	      overlap0 = i.types[0] & operand_types[1];
	      overlap1 = i.types[1] & operand_types[0];
	      if (!MATCH (overlap0, i.types[0], operand_types[1])
		  || !MATCH (overlap1, i.types[1], operand_types[0])
		  || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
						 operand_types[1],
						 overlap1, i.types[1],
						 operand_types[0]))
d3072 1
a3072 1
	      if ((t->opcode_modifier & D))
d3074 1
a3074 1
	      else if ((t->opcode_modifier & FloatD))
d3078 1
a3078 1
	      if ((t->opcode_modifier & FloatR))
d3087 2
a3088 1
		  overlap3 = i.types[3] & operand_types[3];
d3090 2
a3091 1
		  overlap2 = i.types[2] & operand_types[2];
d3098 7
a3104 7
		  if (!MATCH (overlap3, i.types[3], operand_types[3])
		      || !CONSISTENT_REGISTER_MATCH (overlap2,
						     i.types[2],
						     operand_types[2],
						     overlap3,
						     i.types[3],
						     operand_types[3]))
d3111 7
a3117 7
		  if (!MATCH (overlap2, i.types[2], operand_types[2])
		      || !CONSISTENT_REGISTER_MATCH (overlap1,
						     i.types[1],
						     operand_types[1],
						     overlap2,
						     i.types[2],
						     operand_types[2]))
d3125 3
a3127 1
      if (t->cpu_flags & ~cpu_arch_flags)
d3147 2
a3148 2
	  && ((i.types[0] & JumpAbsolute)
	      != (operand_types[0] & JumpAbsolute)))
d3153 2
a3154 2
      if ((t->opcode_modifier & (IsPrefix | IgnoreSize))
	  == (IsPrefix | IgnoreSize))
d3187 2
a3188 2
  int mem_op = (i.types[0] & AnyMem) ? 0 : 1;
  if ((i.tm.operand_types[mem_op] & EsSeg) != 0)
d3203 1
a3203 1
  else if ((i.tm.operand_types[mem_op + 1] & EsSeg) != 0)
d3221 6
a3226 9
  if (i.tm.opcode_modifier & (Size16 | Size32 | Size64))
    {
      if (i.tm.opcode_modifier & Size16)
	i.suffix = WORD_MNEM_SUFFIX;
      else if (i.tm.opcode_modifier & Size64)
	i.suffix = QWORD_MNEM_SUFFIX;
      else
	i.suffix = LONG_MNEM_SUFFIX;
    }
d3239 6
a3244 3
	      if ((i.types[0] & Reg))
		i.suffix = ((i.types[0] & Reg16) ? WORD_MNEM_SUFFIX :
			    LONG_MNEM_SUFFIX);
d3248 1
a3248 1
	      if ((i.types[0] & Reg8))
d3266 1
a3266 2
		if ((i.types[op] & Reg)
		    && !(i.tm.operand_types[op] & InOutPortReg))
d3268 20
a3287 5
		    i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
				(i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
				(i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
				LONG_MNEM_SUFFIX);
		    break;
d3311 1
a3311 1
      else if (intel_syntax && (i.tm.opcode_modifier & IgnoreSize))
d3317 1
a3317 1
  else if ((i.tm.opcode_modifier & DefaultSize)
d3320 1
a3320 1
	   && (i.tm.opcode_modifier & No_sSuf))
d3326 3
a3328 2
	   && ((i.tm.operand_types[0] & JumpAbsolute)
	       || (i.tm.opcode_modifier & (JumpByte|JumpInterSegment))
d3335 1
a3335 1
	  if (!(i.tm.opcode_modifier & No_qSuf))
d3341 1
a3341 1
	  if (!(i.tm.opcode_modifier & No_lSuf))
d3345 1
a3345 1
	  if (!(i.tm.opcode_modifier & No_wSuf))
d3355 1
a3355 1
	  if (i.tm.opcode_modifier & W)
d3364 13
a3376 7
	  unsigned int suffixes = (~i.tm.opcode_modifier
				   & (No_bSuf
				      | No_wSuf
				      | No_lSuf
				      | No_sSuf
				      | No_xSuf
				      | No_qSuf));
d3378 2
a3379 1
	  if ((i.tm.opcode_modifier & W)
d3381 2
a3382 1
		  && !(i.tm.opcode_modifier & (DefaultSize | IgnoreSize))))
d3396 1
a3396 1
      if (i.tm.opcode_modifier & W)
d3398 1
a3398 1
	  if (i.tm.opcode_modifier & ShortForm)
d3418 4
a3421 2
	  if (i.op->regs[0].reg_type &
	      (flag_code == CODE_32BIT ? Reg16 : Reg32))
d3427 2
a3428 1
	       && !(i.tm.opcode_modifier & (IgnoreSize | FloatMF))
d3431 1
a3431 1
		       && (i.tm.opcode_modifier & JumpByte))))
d3435 1
a3435 1
	  if (i.tm.opcode_modifier & JumpByte) /* jcxz, loop */
d3445 1
a3445 1
	  && (i.tm.opcode_modifier & NoRex64) == 0)
d3452 2
a3453 2
		 && i.types [0] == (Acc | Reg64)
		 && i.types [1] == (Acc | Reg64))
d3457 2
a3458 2
		    && (i.types [0] & Reg) == 0
		    && (i.types [0] & AnyMem) != 0))
d3464 1
a3464 1
	if (i.tm.opcode_modifier & FloatMF)
d3481 1
a3481 1
      if (i.types[op] & Reg8)
d3500 4
a3503 1
      if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4)
d3508 1
a3508 1
	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
d3517 1
a3517 1
	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
d3520 1
a3520 1
		     (i.op[op].regs + (i.types[op] & Reg16
d3530 12
a3541 4
      if (i.types[op] & (Reg | RegMMX | RegXMM
			 | SReg2 | SReg3
			 | Control | Debug | Test
			 | FloatReg | FloatAcc))
d3562 4
a3565 2
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
d3576 3
a3578 2
	     && (i.types[op] & Reg16) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
d3600 3
a3602 2
    else if ((i.types[op] & Reg64) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
d3606 1
a3606 1
	    && (i.types[0] & RegXMM) == 0)
d3631 4
a3634 2
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
d3644 4
a3647 2
    else if ((i.types[op] & (Reg16 | Reg32)) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
d3653 1
a3653 1
	    && (i.types[0] & RegXMM) == 0)
d3677 4
a3680 2
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
d3691 3
a3693 2
	     && (i.types[op] & Reg32) != 0
	     && (i.tm.operand_types[op] & (Reg16 | Acc)) != 0)
d3718 1
a3718 1
finalize_imm (void)
d3720 1
a3720 1
  unsigned int overlap0, overlap1, overlap2;
d3722 14
a3735 5
  overlap0 = i.types[0] & i.tm.operand_types[0];
  if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S | Imm64))
      && overlap0 != Imm8 && overlap0 != Imm8S
      && overlap0 != Imm16 && overlap0 != Imm32S
      && overlap0 != Imm32 && overlap0 != Imm64)
d3739 35
a3773 18
	  overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX
		       ? Imm8 | Imm8S
		       : (i.suffix == WORD_MNEM_SUFFIX
			  ? Imm16
			  : (i.suffix == QWORD_MNEM_SUFFIX
			     ? Imm64 | Imm32S
			     : Imm32)));
	}
      else if (overlap0 == (Imm16 | Imm32S | Imm32)
	       || overlap0 == (Imm16 | Imm32)
	       || overlap0 == (Imm16 | Imm32S))
	{
	  overlap0 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
		      ? Imm16 : Imm32S);
	}
      if (overlap0 != Imm8 && overlap0 != Imm8S
	  && overlap0 != Imm16 && overlap0 != Imm32S
	  && overlap0 != Imm32 && overlap0 != Imm64)
d3780 4
a3783 1
  i.types[0] = overlap0;
d3785 8
a3792 34
  overlap1 = i.types[1] & i.tm.operand_types[1];
  if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32 | Imm64))
      && overlap1 != Imm8 && overlap1 != Imm8S
      && overlap1 != Imm16 && overlap1 != Imm32S
      && overlap1 != Imm32 && overlap1 != Imm64)
    {
      if (i.suffix)
	{
	  overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX
		       ? Imm8 | Imm8S
		       : (i.suffix == WORD_MNEM_SUFFIX
			  ? Imm16
			  : (i.suffix == QWORD_MNEM_SUFFIX
			     ? Imm64 | Imm32S
			     : Imm32)));
	}
      else if (overlap1 == (Imm16 | Imm32 | Imm32S)
	       || overlap1 == (Imm16 | Imm32)
	       || overlap1 == (Imm16 | Imm32S))
	{
	  overlap1 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
		      ? Imm16 : Imm32S);
	}
      if (overlap1 != Imm8 && overlap1 != Imm8S
	  && overlap1 != Imm16 && overlap1 != Imm32S
	  && overlap1 != Imm32 && overlap1 != Imm64)
	{
	  as_bad (_("no instruction mnemonic suffix given; "
		    "can't determine immediate size %x %c"),
		  overlap1, i.suffix);
	  return 0;
	}
    }
  i.types[1] = overlap1;
d3794 3
a3796 3
  overlap2 = i.types[2] & i.tm.operand_types[2];
  assert ((overlap2 & Imm) == 0);
  i.types[2] = overlap2;
d3812 1
a3812 1
  if (i.tm.opcode_modifier & RegKludge)
d3814 1
a3814 1
       if ((i.tm.cpu_flags & CpuSSE4_1))
d3820 1
a3820 1
		   && i.types[0] == RegXMM);
d3846 6
a3851 1
	   unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
d3862 1
a3862 1
  if (i.tm.opcode_modifier & ShortForm)
d3864 2
a3865 1
      if (i.types[0] & (SReg2 | SReg3))
d3880 7
a3886 1
	  unsigned int op = (i.types[0] & (Reg | FloatReg)) ? 0 : 1;
d3891 1
a3891 1
	  if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
d3911 1
a3911 1
  else if (i.tm.opcode_modifier & Modrm)
d3923 1
a3923 1
  else if ((i.tm.opcode_modifier & IsString) != 0)
d3970 6
a3975 2
		      && (i.types[0] & ShiftCount)));
	  source = (i.types[0] & (Imm | ShiftCount)) ? 1 : 0;
d3981 2
a3982 2
		  && (i.types[0] & Imm)
		  && (i.types[1] & Imm));
d3998 2
a3999 1
      if ((i.tm.operand_types[dest] & (AnyMem | RegMem)) == 0)
d4019 2
a4020 1
	  if (!((i.types[0] | i.types[1]) & Control))
d4034 1
a4034 1
	    if ((i.types[op] & AnyMem))
d4058 1
a4058 1
				     ? Disp32S : Disp32);
d4064 1
a4064 1
		      i.types[op] = Disp16;
d4069 1
a4069 1
		      i.types[op] = Disp32;
d4078 3
a4080 1
		  i.types[op] &= ~Disp;
d4082 5
a4086 1
		    i.types[op] |= Disp32;	/* Must be 32 bit */
d4088 4
a4091 1
		    i.types[op] |= Disp32S;
d4097 2
a4098 1
	  else if (i.base_reg->reg_type == BaseIndex)
d4101 5
a4105 2
	      i.types[op] &= ~ Disp;
	      i.types[op] |= Disp32S;
d4110 1
a4110 1
	  else if (i.base_reg->reg_type & Reg16)
d4125 1
a4125 1
		      if ((i.types[op] & Disp) == 0)
d4128 1
a4128 1
			  i.types[op] |= Disp8;
d4143 12
a4154 4
		  && (i.types[op] & Disp))
		i.types[op] = ((i.types[op] & Disp8)
			       | (i.prefix[ADDR_PREFIX] == 0
				  ? Disp32S : Disp32));
d4168 1
a4168 1
		      i.types[op] |= Disp8;
d4231 11
a4241 3
	    if ((i.types[op] & (Reg | RegMMX | RegXMM
				| SReg2 | SReg3
				| Control | Debug | Test)))
d4330 1
a4330 1
  else if ((cpu_arch_flags & Cpu386) != 0)
d4359 1
a4359 1
  if (i.tm.opcode_modifier & JumpByte)
d4497 1
a4497 1
  if (i.tm.opcode_modifier & Jump)
d4499 2
a4500 1
  else if (i.tm.opcode_modifier & (JumpByte | JumpDword))
d4502 1
a4502 1
  else if (i.tm.opcode_modifier & JumpInterSegment)
d4510 1
d4516 5
a4520 2
      if ((i.tm.cpu_flags & (CpuSSSE3 | CpuSSE4)) != 0
	  && (i.tm.cpu_flags & CpuABM) == 0)
d4531 1
a4531 1
	  if ((i.tm.cpu_flags & CpuPadLock) != 0)
d4561 1
a4561 2
	  if ((i.tm.cpu_flags & (CpuSSSE3 | CpuSSE4)) != 0
	      && (i.tm.cpu_flags & CpuABM) == 0)
d4575 1
a4575 1
      if (i.tm.opcode_modifier & Modrm)
d4589 1
a4589 1
	      && !(i.base_reg && (i.base_reg->reg_type & Reg16) != 0))
d4621 6
a4626 8
  if (i.types[n] & (Disp8 | Disp16 | Disp64))
    {
      size = 2;
      if (i.types[n] & Disp8)
	size = 1;
      if (i.types[n] & Disp64)
	size = 8;
    }
d4636 6
a4641 8
  if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
    {
      size = 2;
      if (i.types[n] & (Imm8 | Imm8S))
	size = 1;
      if (i.types[n] & Imm64)
	size = 8;
    }
d4653 1
a4653 1
      if (i.types[n] & Disp)
d4669 1
a4669 1
	      int sign = (i.types[n] & Disp32S) != 0;
d4673 1
a4673 1
	      assert ((i.types[n] & Disp8) == 0);
d4684 1
a4684 1
		    if (i.types[n1] & Imm)
d4754 1
a4754 1
      if (i.types[n] & Imm)
d4776 1
a4776 1
	      if ((i.types[n] & (Imm32S))
d4778 1
a4778 1
		      || (!i.suffix && (i.tm.opcode_modifier & No_lSuf))))
d4908 1
a4908 1
	 unsigned int *types)
d4918 1
a4918 1
    const unsigned int types64;
d4922 1
a4922 1
      Imm64 },
d4925 1
a4925 1
      Imm32 | Imm32S | Disp32 },
d4928 1
a4928 1
      Imm64 | Disp64 },
d4931 1
a4931 1
      Imm64 | Disp64 },
d4934 1
a4934 1
      Imm32 | Imm32S | Disp32 },
d4937 1
a4937 1
      Imm32 | Imm32S | Disp32 },
d4940 1
a4940 1
      0 },
d4943 1
a4943 1
      Imm32 | Imm32S | Disp32 },
d4946 1
a4946 1
      Imm32 | Imm32S | Disp32 },
d4949 1
a4949 1
      Imm32 | Imm32S | Imm64 | Disp32 | Disp64 },
d4952 1
a4952 1
      0 },
d4955 2
a4956 1
      Imm32 | Imm32S | Imm64 | Disp32 | Disp64 },
d4959 1
a4959 1
      0 },
d4962 1
a4962 1
      0 },
d4965 1
a4965 1
      Imm32 | Imm32S | Disp32 | Imm64 },
d4968 1
a4968 1
      Imm32 | Imm32S | Disp32 },
d4971 1
a4971 1
      Imm32 | Imm32S | Disp32 }
d5002 4
a5005 1
		    *types = Imm32 | Disp32;
d5128 3
a5130 1
  unsigned int types = ~0U;
d5176 1
a5176 1
      i.types[this_operand] |= Imm64;
d5206 7
a5212 2
      i.types[this_operand] |= Imm8 | Imm16 | Imm32 | Imm32S | Imm64;
      i.types[this_operand] &= types;
d5273 2
a5274 2
  int bigdisp, override;
  unsigned int types = Disp;
d5284 4
a5287 2
  if ((i.types[this_operand] & JumpAbsolute)
      || !(current_templates->start->opcode_modifier & (Jump | JumpDword)))
d5289 1
a5289 1
      bigdisp = Disp32;
d5291 13
a5308 1
      bigdisp = 0;
d5310 11
a5320 13
    }
  if (flag_code == CODE_64BIT)
    {
      if (!bigdisp)
	bigdisp = ((override || i.suffix == WORD_MNEM_SUFFIX)
		   ? Disp16
		   : Disp32S | Disp32);
      else if (!override)
	bigdisp = Disp64 | Disp32S | Disp32;
    }
  else
    {
      if (!bigdisp)
d5326 6
a5331 1
	  bigdisp = Disp32;
a5332 2
      if ((flag_code == CODE_16BIT) ^ override)
	bigdisp = Disp16;
d5334 2
a5335 1
  i.types[this_operand] |= bigdisp;
d5349 1
a5349 1
  if ((i.types[this_operand] & BaseIndex) != 0
d5458 10
a5467 2
  if (!(i.types[this_operand] & ~Disp))
    i.types[this_operand] &= types;
a5486 2
      unsigned RegXX = (i.prefix[ADDR_PREFIX] == 0 ? Reg64 : Reg32);

d5488 7
a5494 3
	   && ((i.base_reg->reg_type & RegXX) == 0)
	   && (i.base_reg->reg_type != BaseIndex
	       || i.index_reg))
d5496 5
a5500 2
	      && ((i.index_reg->reg_type & (RegXX | BaseIndex))
		  != (RegXX | BaseIndex))))
d5509 2
a5510 2
	       && ((i.base_reg->reg_type & (Reg16 | BaseIndex))
		   != (Reg16 | BaseIndex)))
d5512 2
a5513 2
		  && (((i.index_reg->reg_type & (Reg16 | BaseIndex))
		       != (Reg16 | BaseIndex))
d5524 1
a5524 1
	       && (i.base_reg->reg_type & Reg32) != Reg32)
d5526 2
a5527 2
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex))
		      != (Reg32 | BaseIndex))))
d5544 5
a5548 2
	      && (i.types[this_operand] & (Disp16 | Disp32)))
	    i.types[this_operand] ^= (Disp16 | Disp32);
d5584 1
a5584 1
      i.types[this_operand] |= JumpAbsolute;
d5590 2
d5597 3
a5599 1
      if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
d5642 1
a5642 1
	      i.types[this_operand] |= JumpAbsolute;
d5651 4
a5654 1
      i.types[this_operand] |= r->reg_type & ~BaseIndex;
d5666 1
a5666 1
      if (i.types[this_operand] & JumpAbsolute)
d5687 1
a5687 1
	   && (current_templates->start->opcode_modifier & IsString) == 0)
d5738 1
a5738 1
	      i.types[this_operand] |= BaseIndex;
d5834 2
a5835 1
	  && i.base_reg->reg_type == (Reg16 | InOutPortReg)
d5839 1
a5839 1
	  && (i.types[this_operand] & Disp) == 0)
d5841 3
a5843 1
	  i.types[this_operand] = InOutPortReg;
d6427 3
a6429 2
	  || (r->reg_type & Reg64))
      && (r->reg_type != Control || !(cpu_arch_flags & CpuSledgehammer))
d6704 28
a6731 8
      if (cpu_arch_isa_flags == 0)
	cpu_arch_isa_flags = Cpu186|Cpu286|Cpu386|Cpu486
			     |Cpu586|Cpu686|CpuP4|CpuMMX|CpuMMX2
			     |CpuSSE|CpuSSE2;
      if (cpu_arch_tune_flags == 0)
	cpu_arch_tune_flags = Cpu186|Cpu286|Cpu386|Cpu486
			      |Cpu586|Cpu686|CpuP4|CpuMMX|CpuMMX2
			      |CpuSSE|CpuSSE2;
d6736 12
a6747 4
      if (cpu_arch_isa_flags == 0)
	cpu_arch_isa_flags = Cpu186|Cpu286|Cpu386;
      if (cpu_arch_tune_flags == 0)
	cpu_arch_tune_flags = Cpu186|Cpu286|Cpu386;
d7346 1
a7346 1
	       && (current_templates->start->opcode_modifier & IsString) == 0)
d7372 2
a7373 2
		      && (i.base_reg->reg_type & Reg16)
		      && (i.index_reg->reg_type & Reg16)
d7627 2
a7628 2
		       && (current_templates->start->opcode_modifier
			   & (Jump | JumpDword)))
d7682 3
a7684 2
	  if (current_templates->start->opcode_modifier & (Jump | JumpDword))
	    i.types[this_operand] |= JumpAbsolute;
d7710 4
a7713 4
		  || (!(current_templates->start->opcode_modifier
			& (Jump|JumpDword|JumpInterSegment))
		      && !(current_templates->start->operand_types[0]
			   & JumpAbsolute)))
d7772 3
a7774 2
      if (current_templates->start->opcode_modifier & (Jump | JumpDword))
	i.types[this_operand] |= JumpAbsolute;
d7904 2
a7905 1
	    if (!(reg->reg_type & (SReg2 | SReg3)))
d7950 1
a7950 1
	    if (reg->reg_type & Reg16) /* Disallow things like [si*1]. */
d7958 1
a7958 1
	    i.types[this_operand] |= BaseIndex;
d8000 1
a8000 1
	    i.types[this_operand] |= BaseIndex;
d8006 4
a8009 1
	    i.types[this_operand] |= reg->reg_type & ~BaseIndex;
d8118 1
a8118 1
		if (reg->reg_type & Reg16)
d8126 1
a8126 1
		i.types[this_operand] |= BaseIndex;
@


1.277
log
@2007-09-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_index_check): Don't use RegRex
	on the reg_type field.
	(parse_real_register): Use `||' instead of `|'.
@
text
@d2667 3
a2669 1
		 sizes.  The same applies to crc32 in SSE4.2.  */
d2671 5
a2675 1
		    && t->extension_opcode == 0xc8)
d3009 6
a3014 1
      if (i.tm.base_opcode == 0x0f01 && i.tm.extension_opcode == 0xc8)
d3018 2
a3019 1
	     prefix will change the size of AX.  */
@


1.276
log
@2007-09-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_operands): Remove segment override
	check on SVME instructions.
	(i386_index_check): Remove memory operand check on  SVME
	instructions.
@
text
@d4984 1
a4984 1
	       && ((i.base_reg->reg_type & (Reg16 | BaseIndex | RegRex))
d4999 1
a4999 1
	       && (i.base_reg->reg_type & (Reg32 | RegRex)) != Reg32)
d5001 1
a5001 1
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
d5888 2
a5889 1
      && ((r->reg_flags & (RegRex64 | RegRex)) | (r->reg_type & Reg64)) != 0
@


1.275
log
@gas/

2007-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_suffix): Handle cmpxchg8b in
	Intel mode.

gas/testsuite/

2007-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/mem.s: New. Add tests for instructions with one
	memory operand.
	* gas/i386/x86-64-mem.s: Likewise.

	* gas/i386/mem-intel.d: Updated.
	* gas/i386/mem.d: Likewise.
	* gas/i386/x86-64-mem-intel.d: Likewise.
	* gas/i386/x86-64-mem.d: Likewise.

opcodes/

2007-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (Md): New.
	(grps): Use 0 on invlpg.  Use M on fxsave and fxrstor.  Use
	Md on ldmxcsr and stmxcsr.  Use b_mode on clflush.
	(OP_0fae): Clear bytemode for sfence.
@
text
@d3480 3
a3482 3
  if ((i.tm.base_opcode == 0x8d /* lea */
       || (i.tm.cpu_flags & CpuSVME))
      && i.seg[0] && !quiet_warnings)
d4965 1
a4965 24
  if ((current_templates->start->cpu_flags & CpuSVME)
      && current_templates->end[-1].operand_types[0] == AnyMem)
    {
      /* Memory operands of SVME insns are special in that they only allow
	 rAX as their memory address and ignore any segment override.  */
      unsigned RegXX;

      /* SKINIT is even more restrictive: it always requires EAX.  */
      if (strcmp (current_templates->start->name, "skinit") == 0)
	RegXX = Reg32;
      else if (flag_code == CODE_64BIT)
	RegXX = i.prefix[ADDR_PREFIX] == 0 ? Reg64 : Reg32;
      else
	RegXX = ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
		 ? Reg16
		 : Reg32);
      if (!i.base_reg
	  || !(i.base_reg->reg_type & Acc)
	  || !(i.base_reg->reg_type & RegXX)
	  || i.index_reg
	  || (i.types[0] & Disp))
	ok = 0;
    }
  else if (flag_code == CODE_64BIT)
@


1.274
log
@	* config/tc-i386.c (lex_got): Don't scan past a comma.
@
text
@d3035 11
a3045 5
	     need rex64.  */
	  if (i.operands != 2
	      || i.types [0] != (Acc | Reg64)
	      || i.types [1] != (Acc | Reg64)
	      || i.tm.base_opcode != 0x90)
@


1.273
log
@	PR gas/4079
	* config/tc-i386.c (x86_cons): Complain about invalid @@got etc.
	expressions.
	(i386_immediate): Detect and complain about more cases of
	invalid immediate expressions.  Return failure rather than
	converting them to zero.
	(i386_displacement): Likewise.
@
text
@d4488 1
a4488 1
    if (is_end_of_line[(unsigned char) *cp])
d4522 1
a4522 2
		 (and including) an end_of_line char.  Don't use strlen
		 here as the end_of_line char may not be a NUL.  */
d4524 4
a4527 3
	      for (cp = past_reloc; !is_end_of_line[(unsigned char) *cp++]; )
		;
	      second = cp - past_reloc;
@


1.272
log
@gas/

2007-08-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (check_byte_reg): Support pextrb and pinsrb.

gas/testsuite/

2007-08-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run sse4_1-intel, sse4_2-intel,
	x86-64-sse4_1-intel and x86-64-sse4_2-intel.

	* gas/i386/sse4_1-intel.d: New file.
	* gas/i386/sse4_2-intel.d: Likewise.
	* gas/i386/x86-64-sse4_1-intel.d: Likewise.
	* gas/i386/x86-64-sse4_2-intel.d: Likewise.

	* gas/i386/sse4_1.s: Add tests for Intel syntax.
	* gas/i386/sse4_2.s: Likewise.
	* gas/i386/x86-64-sse4_1.s: Likewise.
	* gas/i386/x86-64-sse4_2.s: Likewise.

	* gas/i386/sse4_1.d: Updated.
	* gas/i386/sse4_2.d: Likewise.
	* gas/i386/x86-64-sse4_1.d: Likewise.
	* gas/i386/x86-64-sse4_2.d: Likewise.

opcodes/

2007-08-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.tbl: Add NoRex64 to pmovsxbw, pmovsxwd, pmovsxdq,
	pmovzxbw, pmovzxwd, pmovzxdq and roundsd.
	* i386-tbl.h: Regenerated.
@
text
@d4578 11
d4665 6
a4670 1
  if (exp->X_op == O_absent || exp->X_op == O_big)
d4672 1
a4672 2
      /* Missing or bad expr becomes absolute 0.  */
      as_bad (_("missing or invalid immediate expression `%s' taken as 0"),
d4674 1
a4674 4
      exp->X_op = O_constant;
      exp->X_add_number = 0;
      exp->X_add_symbol = (symbolS *) 0;
      exp->X_op_symbol = (symbolS *) 0;
d4773 1
a4881 1
  RESTORE_END_STRING (disp_end);
d4885 1
d4895 1
a4895 7
	{
	  as_bad (_("bad expression used with @@%s"),
		  (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL
		   ? "GOTPCREL"
		   : "GOTOFF"));
	  return 0;
	}
d4910 6
a4915 1
  if (exp->X_op == O_absent || exp->X_op == O_big)
d4917 2
a4918 2
      /* Missing or bad expr becomes absolute 0.  */
      as_bad (_("missing or invalid displacement expression `%s' taken as 0"),
d4920 1
a4920 4
      exp->X_op = O_constant;
      exp->X_add_number = 0;
      exp->X_add_symbol = (symbolS *) 0;
      exp->X_op_symbol = (symbolS *) 0;
d4924 8
a4931 8
  if (exp->X_op != O_constant
      && OUTPUT_FLAVOR == bfd_target_aout_flavour
      && exp_seg != absolute_section
      && exp_seg != text_section
      && exp_seg != data_section
      && exp_seg != bss_section
      && exp_seg != undefined_section
      && !bfd_is_com_section (exp_seg))
d4934 1
a4934 1
      return 0;
d4938 2
d4943 1
a4943 1
  return 1;
@


1.271
log
@gas/

2007-07-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (check_long_reg): Allow cvtss2si to convert
	DWORD memory to Reg64 in Intel synax.
	(check_qword_reg): Allow cvtsd2si to convert QWORD memory to
	Reg32 in Intel syntax.

gas/testsuite/

2007-07-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/simd.s: Add tests for cvtss2si/cvtsd2si in Intel
	mode.
	* gas/i386/x86-64-simd.s: Likewise.

	* gas/i386/simd-intel.d: Updated.
	* gas/i386/simd.d: Likewise.
	* gas/i386/x86-64-simd-intel.d: Likewise.
	* gas/i386/x86-64-simd.d: Likewise.
@
text
@d3065 2
a3066 1
      /* movzx and movsx should not generate this warning.  */
d3072 3
a3074 1
	      || i.tm.base_opcode == 0xfbf))
@


1.271.2.1
log
@2007-08-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (check_byte_reg): Support pextrb and pinsrb.

	* gas/i386/i386.exp: Run sse4_1-intel, sse4_2-intel,
	x86-64-sse4_1-intel and x86-64-sse4_2-intel.

	* gas/i386/sse4_1-intel.d: New file.
	* gas/i386/sse4_2-intel.d: Likewise.
	* gas/i386/x86-64-sse4_1-intel.d: Likewise.
	* gas/i386/x86-64-sse4_2-intel.d: Likewise.

	* gas/i386/sse4_1.s: Add tests for Intel syntax.
	* gas/i386/sse4_2.s: Likewise.
	* gas/i386/x86-64-sse4_1.s: Likewise.
	* gas/i386/x86-64-sse4_2.s: Likewise.

	* gas/i386/sse4_1.d: Updated.
	* gas/i386/sse4_2.d: Likewise.
	* gas/i386/x86-64-sse4_1.d: Likewise.
	* gas/i386/x86-64-sse4_2.d: Likewise.

	* i386-opc.tbl: Add NoRex64 to pmovsxbw, pmovsxwd, pmovsxdq,
	pmovzxbw, pmovzxwd, pmovzxdq and roundsd.
	* i386-tbl.h: Regenerated.
@
text
@d3065 1
a3065 2
      /* movzx, movsx, pextrb and pinsrb should not generate this
	 warning.  */
d3071 1
a3071 3
	      || i.tm.base_opcode == 0xfbf
	      || i.tm.base_opcode == 0x660f3a14
	      || i.tm.base_opcode == 0x660f3a20))
@


1.271.2.2
log
@	* config/tc-i386.c (lex_got): Don't scan past a comma.
@
text
@d4488 1
a4488 1
    if (is_end_of_line[(unsigned char) *cp] || *cp == ',')
d4522 2
a4523 1
		 (and including) an end_of_line char or comma.  */
d4525 3
a4527 4
	      cp = past_reloc;
	      while (!is_end_of_line[(unsigned char) *cp] && *cp != ',')
		++cp;
	      second = cp + 1 - past_reloc;
@


1.270
log
@gas/

2007-07-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Change i386 to PROCESSOR_I386.
	(f32_15): Removed.
	(jump_31): New.
	(f32_patt): Remove f32_15.
	(f16_patt): Likewise.
	(i386_align_code): Updated to alt_long_patt for 64bit by
	default.

	* config/tc-i386.h (processor_type): Add PROCESSOR_I386.

2007-07-23  Evandro Menezes  <evandro.menezes@@amd.com>

	* config/tc-i386.c (i386_align_code): Enable alignment up to
	MAX_MEM_FOR_RS_ALIGN_CODE bytes.  Remove special treatment
	for K8.

	* config/tc-i386.h (MAX_MEM_FOR_RS_ALIGN_CODE): Changed to
	31.

gas/testsuite/

2007-07-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run nops16-1, nops-1-i386-i686, nops-1-k8,
	nops-3-i386, nops-4, nops-4-i386, x86-64-nops-2, x86-64-nops-3,
	x86-64-nops-4, x86-64-nops-4-core2 and x86-64-nops-4-k8.

	* gas/i386/nops-1-i386-i686.d: New.
	* gas/i386/nops-1-k8.d: Likewise.
	* gas/i386/nops-3-i386.d : Likewise.
	* gas/i386/nops-3-i686.d: Likewise.
	* gas/i386/nops-4-i386.d: Likewise.
	* gas/i386/nops-4.d: Likewise.
	* gas/i386/nops16-1.d: Likewise.
	* gas/i386/nops16-1.s: Likewise.
	* gas/i386/x86-64-nops-1-k8.d: Likewise.
	* gas/i386/x86-64-nops-2.d: Likewise.
	* gas/i386/x86-64-nops-3.d: Likewise.
	* gas/i386/x86-64-nops-4-core2.d: Likewise.
	* gas/i386/x86-64-nops-4-k8.d: Likewise.
	* gas/i386/x86-64-nops-4.d: Likewise.

	* gas/i386/nops-1-i386.d: Updated.
	* gas/i386/nops-1-i686.d: Likewise.
	* gas/i386/nops-1.d: Likewise.
	* gas/i386/nops-2-i386.d: Likewise.
	* gas/i386/nops-2-merom.d : Likewise.
	* gas/i386/nops-2.d: Likewise.
	* gas/i386/nops-3.d: Likewise.
	* gas/i386/x86-64-nops-1-merom.d: Likewise.
	* gas/i386/x86-64-nops-1-nocona.d: Likewise.
	* gas/i386/x86-64-nops-1.d: Likewise.

	* gas/i386/x86-64-nops-1.s: Removed.

2007-07-23  Evandro Menezes  <evandro.menezes@@amd.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Don't run x86-64-nops-1-k8. Run
	nops-3-i686 and nops-4-i686.

	* gas/i386/nops-3-i686.d: New.
	* gas/i386/nops-4-i686.d: Likewise.
	* gas/i386/nops-4.s: Likewise.

	* gas/i386/x86-64-nops-1-k8.d: Removed.
@
text
@d3167 15
a3181 4
	as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
		register_prefix, i.op[op].regs->reg_name,
		i.suffix);
	return 0;
d3205 1
a3205 2
    else if (((i.types[op] & Reg16) != 0
	      || (i.types[op] & Reg32) != 0)
d3210 15
a3224 4
	as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
		register_prefix, i.op[op].regs->reg_name,
		i.suffix);
	return 0;
@


1.269
log
@gas/

2007-07-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-coff.h (x86_64_target_format): Renamed to ...
	(i386_target_format): This
	(TARGET_FORMAT): Use i386_target_format.

	* config/tc-i386.c (x86_64_target_format): Removed.
	(i386_target_format): Handle PE formats.

gas/testsuite/

2007-07-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run x86-64-nops-1 for x86_64-*-mingw*.
@
text
@d434 1
a434 1
  {"i386", PROCESSOR_GENERIC32,
a610 3
  static const char f32_15[] =
    {0xeb,0x0d,0x90,0x90,0x90,0x90,0x90,	/* jmp .+15; lotsa nops	*/
     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};
d627 5
d634 1
a634 1
    f32_9, f32_10, f32_11, f32_12, f32_13, f32_14, f32_15
d637 1
a637 2
    f32_1, f32_2, f16_3, f16_4, f16_5, f16_6, f16_7, f16_8,
    f32_15, f32_15, f32_15, f32_15, f32_15, f32_15, f32_15
d744 2
a745 1
  if (count <= 0 || count > 15)
d751 11
a761 11
     1. For PROCESSOR_I486, PROCESSOR_PENTIUM and PROCESSOR_GENERIC32,
     f32_patt will be used.
     2. For PROCESSOR_K8 and PROCESSOR_AMDFAM10 in 64bit, NOPs with
     0x66 prefix will be used.
     3. For PROCESSOR_CORE2, alt_long_patt will be used.
     4. For PROCESSOR_PENTIUMPRO, PROCESSOR_PENTIUM4, PROCESSOR_NOCONA,
     PROCESSOR_CORE, PROCESSOR_CORE2, PROCESSOR_K6, PROCESSOR_ATHLON
     and PROCESSOR_GENERIC64, alt_short_patt will be used.

     When -mtune= isn't used, alt_short_patt will be used if
     cpu_arch_isa_flags has Cpu686. Otherwise, f32_patt will be used.
a767 2
      memcpy (fragP->fr_literal + fragP->fr_fix,
	      f16_patt[count - 1], count);
d769 5
a773 24
	/* Adjust jump offset.  */
	fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
    }
  else if (flag_code == CODE_64BIT && cpu_arch_tune == PROCESSOR_K8)
    {
      int i;
      int nnops = (count + 3) / 4;
      int len = count / nnops;
      int remains = count - nnops * len;
      int pos = 0;

      /* The recommended way to pad 64bit code is to use NOPs preceded
	 by maximally four 0x66 prefixes.  Balance the size of nops.  */
      for (i = 0; i < remains; i++)
	{
	  memset (fragP->fr_literal + fragP->fr_fix + pos, 0x66, len);
	  fragP->fr_literal[fragP->fr_fix + pos + len] = 0x90;
	  pos += len + 1;
	}
      for (; i < nnops; i++)
	{
	  memset (fragP->fr_literal + fragP->fr_fix + pos, 0x66, len - 1);
	  fragP->fr_literal[fragP->fr_fix + pos + len - 1] = 0x90;
	  pos += len;
d775 3
d792 1
a792 1
		patt = alt_short_patt;
a795 3
	    case PROCESSOR_CORE2:
	      patt = alt_long_patt;
	      break;
d800 4
a806 1
	    case PROCESSOR_GENERIC64:
d810 1
d828 1
a830 4
	    case PROCESSOR_PENTIUMPRO:
	    case PROCESSOR_PENTIUM4:
	    case PROCESSOR_NOCONA:
	    case PROCESSOR_CORE:
d843 4
d854 1
a854 1
	      patt = alt_short_patt;
d859 33
a891 2
      memcpy (fragP->fr_literal + fragP->fr_fix,
	      patt[count - 1], count);
@


1.268
log
@Switch to GPLv3
@
text
@a6117 20
#if defined(TE_PEP)
const char *
x86_64_target_format (void)
{
  if (strcmp (default_arch, "x86_64") == 0)
    {
      set_code_flag (CODE_64BIT);
      return COFF_TARGET_FORMAT;
    }
  else if (strcmp (default_arch, "i386") == 0)
    {
      set_code_flag (CODE_32BIT);
      return "coff-i386";
    }

  as_fatal (_("Unknown architecture"));
  return NULL;
}
#endif

d6119 1
a6119 1
     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
d6150 5
@


1.267
log
@gas/

2007-06-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_operands): Replace regKludge
	with RegKludge.

opcodes/

2007-06-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.h (regKludge): Renamed to ...
	(RegKludge): This.

	* i386-opc.c (i386_optab): Replace regKludge with RegKludge.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.266
log
@2007-06-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (disp_size): New.
	(imm_size): Likewise.
	(output_disp): Use disp_size and imm_size.
	(output_imm): Use imm_size.
@
text
@d3327 1
a3327 1
  if (i.tm.opcode_modifier & regKludge)
@


1.265
log
@	PR gas/4460
	* config/tc-i386.c (lex_got): Don't replace the reloc token with
	a space if we already have a space.
@
text
@d4079 34
d4125 1
a4125 1
	      int size;
a4127 9
	      size = 4;
	      if (i.types[n] & (Disp8 | Disp16 | Disp64))
		{
		  size = 2;
		  if (i.types[n] & Disp8)
		    size = 1;
		  if (i.types[n] & Disp64)
		    size = 8;
		}
d4136 2
a4137 2
	      int size = 4;
	      int sign = 0;
d4140 3
a4147 1
		  int imm_size = 4;
d4149 1
d4154 5
a4158 9
			if (i.types[n1] & (Imm8 | Imm8S | Imm16 | Imm64))
			  {
			    imm_size = 2;
			    if (i.types[n1] & (Imm8 | Imm8S))
			      imm_size = 1;
			    if (i.types[n1] & Imm64)
			      imm_size = 8;
			  }
			break;
d4161 1
a4161 13
		  if (n1 == i.operands)
		    abort ();
		  i.op[n].disps->X_add_number -= imm_size;
		}

	      if (i.types[n] & Disp32S)
		sign = 1;

	      if (i.types[n] & (Disp16 | Disp64))
		{
		  size = 2;
		  if (i.types[n] & Disp64)
		    size = 8;
d4226 1
a4226 1
	      int size;
a4228 9
	      size = 4;
	      if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
		{
		  size = 2;
		  if (i.types[n] & (Imm8 | Imm8S))
		    size = 1;
		  else if (i.types[n] & Imm64)
		    size = 8;
		}
d4241 2
a4242 2
	      int size = 4;
	      int sign = 0;
d4248 2
a4249 8
	      if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
		{
		  size = 2;
		  if (i.types[n] & (Imm8 | Imm8S))
		    size = 1;
		  if (i.types[n] & Imm64)
		    size = 8;
		}
@


1.264
log
@gas/

2007-05-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Don't explicitly check
	suffix for crc32 in Intel mode.
	(process_suffix): Issue an error for crc32 if the operand size
	is ambiguous.

gas/testsuite/

2007-05-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/crc32-intel.d: Updated.
	* gas/i386/crc32.d: Likewise.
	* gas/i386/sse4_2.d: Likewise.
	* gas/i386/x86-64-crc32-intel.d: Likewise.
	* gas/i386/x86-64-crc32.d: Likewise.
	* gas/i386/x86-64-sse4_2.d: Likewise.

	* gas/i386/crc32.s: Remove crc32 instructions with ambiguous
	operand size and suffix in crc32 instructions in Intel mode.
	* gas/i386/x86-64-crc32.s: Likewise.

	* gas/i386/sse4_2.s: Remove crc32 instructions with ambiguous
	operand size.
	* gas/i386/x86-64-sse4_2.s: Likewise.

	* gas/i386/i386.exp: Run inval-crc32 and x86-64-inval-crc32.

	* gas/i386/inval-crc32.l: New.
	* gas/i386/inval-crc32.s: Likewise.
	* gas/i386/x86-64-inval-crc32.l: Likewise.
	* gas/i386/x86-64-inval-crc32.s: Likewise.

opcodes/

2007-05-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (CRC32_Fixup): Don't print suffix in Intel mode.

	* i386-opc.c (i386_optab): Remove IgnoreSize and correct operand
	type for crc32.
@
text
@a4479 3
	      /* Replace the relocation token with ' ', so that
		 errors like foo@@GOTOFF1 will be detected.  */

d4495 6
a4500 3
	      tmpbuf[first] = ' ';
	      memcpy (tmpbuf + first + 1, past_reloc, second);
	      tmpbuf[first + second + 1] = '\0';
@


1.263
log
@gas/config/

2007-05-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Check suffix for crc32 in
	Intel mdoe.
	(process_suffix): Default the suffix of 8bit crc32 to
	BYTE_MNEM_SUFFIX.
	(check_byte_reg): Skip check for 8bit crc32.

gas/testsuite/

2007-05-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/crc32-intel.d: New file.
	* gas/i386/crc32.d:Likewise.
	* gas/i386/crc32.s:Likewise.
	* gas/i386/x86-64-crc32-intel.d:Likewise.
	* gas/i386/x86-64-crc32.d:Likewise.
	* gas/i386/x86-64-crc32.s:Likewise.

	* gas/i386/i386.exp: Run crc32, crc32-intel, x86-64-crc32
	and x86-64-crc32-intel.

opcodes/

2007-05-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (CRC32_Fixup): Properly handle Intel mode and
	check data size prefix in 16bit mode.

	* i386-opc.c (i386_optab): Default crc32 to non-8bit and
	support Intel mode.
@
text
@d2560 1
a2560 2
      /* Check the suffix, except for some instructions in intel mode.
	 We do want to check suffix for crc32 even in intel mode.  */
a2562 1
	       && t->base_opcode != 0xf20f38f1
d2849 4
a2852 1
	    i.suffix = BYTE_MNEM_SUFFIX;
d2858 9
@


1.262
log
@2007-04-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Use register_prefix in
	error/warning message.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
	(process_operands): Likewise.
@
text
@d2560 2
a2561 1
      /* Check the suffix, except for some instructions in intel mode.  */
d2564 1
d2850 2
d3047 4
@


1.261
log
@gas/
	* expr.c (expr): Assert on rankarg, not rank which can be unsigned.
	* read.c (read_a_source_file): Remove buffer_limit[-1] assertion.
	Don't skip over NUL char.
	(pseudo_set): Set X_op for registers to O_register.
	* symbols.c (symbol_clone): Remove assertion that sym is defined.
	(resolve_symbol_value): Resolve O_register symbols.
	* config/tc-i386.c (parse_real_register): Don't use i386_float_regtab.
	Instead find st(0) by hash lookup.
	* config/tc-ppc.c (ppc_macro): Warning fix.
opcodes/
	* i386-opc.c (i386_float_regtab, i386_float_regtab_size): Delete.
	Move contents to..
	(i386_regtab): ..here.
	* i386-opc.h (i386_float_regtab, i386_float_regtab_size): Delete.
@
text
@d1838 5
a1842 2
	      as_bad (_("can't use register '%%%s' as operand %d in '%s'."),
		      i.op[x].regs->reg_name, x + 1, i.tm.name);
d1915 1
a1915 1
		as_bad (_("can't encode register '%%%s' in an "
d1917 1
a1917 1
			i.op[x].regs->reg_name);
d3058 2
a3059 1
	    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
d3063 1
d3075 2
a3076 1
	  as_bad (_("`%%%s' not allowed with `%s%c'"),
d3097 2
a3098 1
	as_bad (_("`%%%s' not allowed with `%s%c'"),
d3120 2
a3121 1
	  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
d3123 1
d3151 2
a3152 1
	as_bad (_("`%%%s' not allowed with `%s%c'"),
d3183 2
a3184 1
	as_bad (_("`%%%s' not allowed with `%s%c'"),
d3206 2
a3207 1
	  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
d3209 1
d3383 3
a3385 3
		  as_warn (_("translating to `%s %%%s,%%%s'"), i.tm.name,
			   i.op[1].regs->reg_name,
			   i.op[0].regs->reg_name);
d3390 2
a3391 2
		  as_warn (_("translating to `%s %%%s'"), i.tm.name,
			   i.op[0].regs->reg_name);
@


1.260
log
@gas/

2007-04-18  H.J. Lu <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add .sse4.2 and .sse4.
	(match_template): Handle operand size for crc32 in SSE4.2.
	(process_suffix): Handle operand type for crc32 in SSE4.2.
	(output_insn): Support SSE4.2.

gas/testsuite/

2007-04-18  H.J. Lu <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Add sse4.2 and x86-64-sse4.2.

	* gas/i386/sse4_2.d: New file.
	* gas/i386/sse4_2.s: Likewise.
	* gas/i386/x86-64-sse4_2.d: Likewise.
	* gas/i386/x86-64-sse4_2.s: Likewise.

opcodes/

2007-04-18  H.J. Lu <hongjiu.lu@@intel.com>

	* i386-dis.c (CRC32_Fixup): New.
	(PREGRP85, PREGRP86, PREGRP87, PREGRP88, PREGRP89, PREGRP90,
	 PREGRP91): New.
	(threebyte_0x38_uses_DATA_prefix): Updated for SSE4.2.
	(threebyte_0x3a_uses_DATA_prefix): Likewise.
	(prefix_user_table): Add PREGRP85, PREGRP86, PREGRP87,
	PREGRP88, PREGRP89, PREGRP90 and PREGRP91.
	(three_byte_table): Likewise.

	* i386-opc.c (i386_optab): Add SSE4.2 opcodes.

	* gas/config/tc-i386.h (CpuSSE4_2): New.
	(CpuSSE4): Likewise.
	(CpuUnknownFlags): Add CpuSSE4_2.
@
text
@d5807 1
a5807 1
	      r = &i386_float_regtab[*s - '0'];
d5814 3
a5816 1
		  return r;
@


1.259
log
@gas/

2007-04-18  H.J. Lu <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add .sse4.1.
	(process_operands): Adjust implicit operand for blendvpd,
	blendvps and pblendvb in SSE4.1.
	(output_insn): Support SSE4.1.

gas/testsuite/

2007-04-18  H.J. Lu <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Add sse4.1 and x86-64-sse4.1.

	* gas/i386/sse4_1.d: New file.
	* gas/i386/sse4_1.s: Likewise.
	* gas/i386/x86-64-sse4_1.d: Likewise.
	* gas/i386/x86-64-sse4_1.s: Likewise.

opcodes/

2007-04-18  H.J. Lu <hongjiu.lu@@intel.com>

	* i386-dis.c (XMM_Fixup): New.
	(Edqb): New.
	(Edqd): New.
	(XMM0): New.
	(dqb_mode): New.
	(dqd_mode): New.
	(PREGRP39 ... PREGRP85): New.
	(threebyte_0x38_uses_DATA_prefix): Updated for SSE4.
	(threebyte_0x3a_uses_DATA_prefix): Likewise.
	(prefix_user_table): Add PREGRP39 ... PREGRP85.
	(three_byte_table): Likewise.
	(putop): Handle 'K'.
	(intel_operand_size): Handle dqb_mode, dqd_mode):
	(OP_E): Likewise.
	(OP_G): Likewise.

	* i386-opc.c (i386_optab): Add SSE4.1 opcodes.

	* i386-opc.h (CpuSSE4_1): New.
	(CpuUnknownFlags): Add CpuSSE4_1.
	(regKludge): Update comment.
@
text
@d503 4
d2647 1
a2647 1
		 sizes.  */
d2650 1
d2837 8
a2844 2
	     register type.  */
	  int op;
d2846 15
a2860 10
	  for (op = i.operands; --op >= 0;)
	    if ((i.types[op] & Reg)
		&& !(i.tm.operand_types[op] & InOutPortReg))
	      {
		i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
			    (i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
			    (i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
			    LONG_MNEM_SUFFIX);
		break;
	      }
d3948 5
a3952 3
	 SSE4.1 instructions have 3 bytes.  We may use one more higher
	 byte to specify a prefix the instruction requires.  */
      if ((i.tm.cpu_flags & (CpuSSSE3 | CpuSSE4_1)) != 0)
d3993 2
a3994 1
	  if ((i.tm.cpu_flags & (CpuSSSE3 | CpuSSE4_1)) != 0)
@


1.258
log
@2007-03-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_suffix): Reindent a bit.
@
text
@d501 2
d3282 41
a3322 8
      unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
      /* Pretend we saw the extra register operand.  */
      assert (i.reg_operands == 1
	      && i.op[first_reg_op + 1].regs == 0);
      i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
      i.types[first_reg_op + 1] = i.types[first_reg_op];
      i.operands++;
      i.reg_operands++;
d3931 4
a3934 5
      /* All opcodes on i386 have either 1 or 2 bytes.  Supplemental
	 Streaming SIMD extensions 3 Instructions have 3 bytes.  We may
	 use one more higher byte to specify a prefix the instruction
	 requires.  */
      if ((i.tm.cpu_flags & CpuSSSE3) != 0)
d3975 1
a3975 1
	  if ((i.tm.cpu_flags & CpuSSSE3) != 0)
@


1.257
log
@gas/

2007-03-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): For instructions with 2
	register operands, encode destination in i.rm.regmem if its
	RegMem bit is set.

opcodes/

2007-03-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.c (i386_optab): Change InvMem to RegMem for mov and
	movq.  Remove InvMem from sldt, smsw and str.

	* i386-opc.h (InvMem): Renamed to ...
	(RegMem): Update comments.
	(AnyMem): Remove InvMem.
@
text
@d2988 1
a2988 1
	  i.rex |= REX_W;
@


1.256
log
@gas/

2003-03-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_begin): Allow '.' in mnemonic.

gas/testsuite/

2003-03-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/rex.s: Add tests for rex.WRXB.
	* gas/i386/rex.d: Updated.

	* gas/i386/rex.d: Replace rex64XYZ with rex.WRXB.
	* gas/i386/x86-64-io-intel.d : Likewise.
	* gas/i386/x86-64-io-suffix.d: Likewise.
	* gas/i386/x86-64-io.d: Likewise.
	* gas/i386/x86-64-opcode.d: Likewise.

opcodes/

2003-03-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (prefix_name): Replace rex64XYZ with rex.WRXB.

	* i386-opc.c (i386_optab): Add rex.wrxb.
@
text
@d3415 1
a3415 1
      if ((i.tm.operand_types[dest] & AnyMem) == 0)
@


1.255
log
@2003-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_suffix): Check 0x90 instead of
	xchg for xchg %rax,%rax.
@
text
@d1297 1
@


1.254
log
@gas/

2003-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c: Replace REX_MODE64, REX_EXTX, REX_EXTY
	and REX_EXTZ with REX_W, REX_R, REX_X and REX_B respectively.

include/opcode/

2003-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386.h (REX_MODE64): Renamed to ...
	(REX_W): This.
	(REX_EXTX): Renamed to ...
	(REX_R): This.
	(REX_EXTY): Renamed to ...
	(REX_X): This.
	(REX_EXTZ): Renamed to ...
	(REX_B): This.

opcodes/

2003-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (REX_MODE64): Remove definition.
	(REX_EXTX): Likewise.
	(REX_EXTY): Likewise.
	(REX_EXTZ): Likewise.
	(USED_REX): Use REX_OPCODE instead of 0x40.
	Replace REX_MODE64, REX_EXTX, REX_EXTY and REX_EXTZ with REX_W,
	REX_R, REX_X and REX_B respectively.
@
text
@d2986 1
a2986 1
	      || strcmp (i.tm.name, "xchg") != 0)
@


1.253
log
@gas/

2003-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/4218
	* config/tc-i386.c (match_template): Properly handle 64bit mode
	"xchg %eax, %eax".

gas/testsuite/

2003-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/4218
	* gas/i386/nops.s: Add testcases for nop r/m.
	* gas/i386/x86-64-nops.s: Likewise.

	* gas/i386/x86-64-opcode.s: Add testcases for xchg with %ax,
	%eax and %rax.

	* gas/i386/nops.d: Updated.
	* gas/i386/x86-64-nops.d: Likewise.
	* gas/i386/x86-64-opcode.d: Likewise.

opcodes/

2003-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/4218
	* i386-dis.c (PREGRP38): New.
	(dis386): Use PREGRP38 for 0x90.
	(prefix_user_table): Add PREGRP38.
	(print_insn): Set uses_REPZ_prefix to 1 for pause.
	(NOP_Fixup1): Properly handle REX bits.
	(NOP_Fixup2): Likewise.

	* i386-opc.c (i386_optab): Allow %eax with xchg in 64bit.
	Allow register with nop.
@
text
@d994 3
a996 3
      if ((i.prefix[REX_PREFIX] & prefix & REX_MODE64)
	  || ((i.prefix[REX_PREFIX] & (REX_EXTX | REX_EXTY | REX_EXTZ))
	      && (prefix & (REX_EXTX | REX_EXTY | REX_EXTZ))))
d1356 4
a1359 4
	   (x->rex & REX_MODE64) != 0,
	   (x->rex & REX_EXTX) != 0,
	   (x->rex & REX_EXTY) != 0,
	   (x->rex & REX_EXTZ) != 0);
d1881 1
a1881 1
    i.rex |= REX_MODE64;
d2987 1
a2987 1
	  i.rex |= REX_MODE64;
d3301 1
a3301 1
	    i.rex |= REX_EXTZ;
d3310 1
a3310 1
	    i.rex |= REX_EXTZ;
d3419 1
a3419 1
	    i.rex |= REX_EXTX;
d3421 1
a3421 1
	    i.rex |= REX_EXTZ;
d3428 1
a3428 1
	    i.rex |= REX_EXTZ;
d3430 1
a3430 1
	    i.rex |= REX_EXTX;
d3432 1
a3432 1
      if (flag_code != CODE_64BIT && (i.rex & (REX_EXTX | REX_EXTZ)))
d3436 1
a3436 1
	  i.rex &= ~(REX_EXTX | REX_EXTZ);
d3498 1
a3498 1
		    i.rex |= REX_EXTY;
d3551 1
a3551 1
		i.rex |= REX_EXTZ;
d3588 1
a3588 1
		    i.rex |= REX_EXTY;
d3636 1
a3636 1
		i.rex |= REX_EXTZ;
d3642 1
a3642 1
		i.rex |= REX_EXTX;
@


1.252
log
@2007-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am: Run dep-am.
	* Makefile.in: Regenerated.

	* config/tc-i386.c: Don't include "opcodes/i386-opc.h".

	* config/tc-i386.h: Include "opcodes/i386-opc.h".
	(NOP_OPCODE): Removed.
	(template): Likewise.
@
text
@d2624 9
@


1.251
log
@gas/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_begin): Use i386_regtab_size to scan
	i386_regtab.
	(parse_register): Use i386_regtab_size instead of ARRAY_SIZE
	on i386_regtab.

opcodes/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-opc.c: Include "libiberty.h".
	(i386_regtab): Remove the last entry.
	(i386_regtab_size): New.
	(i386_float_regtab_size): Likewise.

	* i386-opc.h (i386_regtab_size): New.
	(i386_float_regtab_size): Likewise.
@
text
@a34 1
#include "opcodes/i386-opc.h"
@


1.250
log
@gas/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerated.

	* config/tc-i386.c: Include "opcodes/i386-opc.h" instead of
	"opcode/i386.h".
	(md_begin): Check reg_name != NULL for the last entry in
	i386_regtab.

	* config/tc-i386.h: Move many entries to opcode/i386.h and
	opcodes/i386-opc.h.

	* configure.in (need_opcodes): Set true for i386.
	* configure: Regenerated.

include/opcode/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386.h: Add entries from config/tc-i386.h and move tables
	to opcodes/i386-opc.h.

opcodes/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (CFILES): Add i386-opc.c.
	(ALL_MACHINES): Add i386-opc.lo.
	Run "make dep-am".
	* Makefile.in: Regenerated.

	* configure.in: Add i386-opc.lo for bfd_i386_arch.
	* configure: Regenerated.

	* i386-dis.c: Include "opcode/i386.h".
	(MAXLEN): Renamed to MAX_MNEM_SIZE. Remove definition.
	(FWAIT_OPCODE): Remove definition.
	(UNIXWARE_COMPAT): Renamed to SYSV386_COMPAT. Remove definition.
	(MAX_OPERANDS): Remove definition.

	* i386-opc.c: New file.
	* i386-opc.h: Likewise.
@
text
@d1241 1
d1243 1
a1243 1
    for (regtab = i386_regtab; regtab->reg_name != NULL; regtab++)
d5795 1
a5795 1
		&& (valueT) e->X_add_number < ARRAY_SIZE (i386_regtab));
@


1.249
log
@2007-03-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Use Opcode_XXX instead of XXX
	on i.tm.base_opcode.
	(match_template): Likewise.
	(process_operands): Use ~0x3 mask to match MOV_AX_DISP32.

	* config/tc-i386.h (Opcode_D): New.
	(Opcode_FloatR): Likewise.
	(Opcode_FloatD): Likewise.
	(D): Redefined.
	(W): Likewise.
	(FloatMF): Likewise.
	(FloatR): Likewise.
	(FloatD): Likewise.
@
text
@d35 1
a35 1
#include "opcode/i386.h"
d1242 1
a1242 3
    for (regtab = i386_regtab;
	 regtab < i386_regtab + sizeof (i386_regtab) / sizeof (i386_regtab[0]);
	 regtab++)
@


1.248
log
@gas/
	* config/tc-i386.h (Seg2ShortForm, Seg3ShortForm): Delete.
	* config/tc-i386.c: Wrap overly long lines, whitespace fixes.
	(process_operands): Move old Seg2ShortForm and Seg3ShortForm
	code, and test for these insns using a combination of
	opcode_modifier and operand_types.
include/opcode/
	* i386.h (i386_optab): Replace all occurrences of Seg2ShortForm
	and Seg3ShortFrom with Shortform.
@
text
@d1769 1
a1769 1
	i.tm.base_opcode ^= FloatR;
d2660 8
a2667 1
	      found_reverse_match = t->opcode_modifier & (D | FloatDR);
d3332 1
a3332 1
  else if ((i.tm.base_opcode & ~(D | W)) == MOV_AX_DISP32)
@


1.247
log
@2076-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (swap_imm_operands): Renamed to ...
	(swap_2_operands): This.  Take 2 ints.
	(md_assemble): Updated.
	(swap_operands): Call swap_2_operands to swap 2 operands.
@
text
@d743 1
a743 1
  
d746 2
a747 1
     2. For PROCESSOR_K8 and PROCESSOR_AMDFAM10 in 64bit, NOPs with 0x66 prefix will be used.
d776 1
a776 1
         by maximally four 0x66 prefixes.  Balance the size of nops.  */
d818 1
a818 1
	    case PROCESSOR_AMDFAM10:  
d826 1
a826 1
	    } 
d847 1
a847 1
            case PROCESSOR_AMDFAM10:
d865 1
a865 1
	    } 
d1134 2
a1135 1
				    | (flag_code == CODE_64BIT ? Cpu64 : CpuNo64));
d1719 1
a1719 1
  /* The order of the immediates should be reversed 
d1725 2
a1726 2
      swap_2_operands (0, 1);  
      /* "extrq" and insertq" are the only two instructions whose operands 
d1907 2
a1908 1
		as_bad (_("can't encode register '%%%s' in an instruction requiring REX prefix."),
d2270 1
a2270 1
  
d2399 4
a2402 2
	      for (t = current_templates->start; t < current_templates->end; ++t)
	        allowed |= t->operand_types[op];
d2894 2
a2895 1
	      as_bad (_("no instruction mnemonic suffix given and no register operands; can't size instruction"));
d3203 2
a3204 1
	  as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
d3237 3
a3239 1
	  as_bad (_("no instruction mnemonic suffix given; can't determine immediate size %x %c"),overlap1, i.suffix);
d3277 7
a3283 16
      /* The register or float register operand is in operand 0 or 1.  */
      unsigned int op = (i.types[0] & (Reg | FloatReg)) ? 0 : 1;
      /* Register goes in low 3 bits of opcode.  */
      i.tm.base_opcode |= i.op[op].regs->reg_num;
      if ((i.op[op].regs->reg_flags & RegRex) != 0)
	i.rex |= REX_EXTZ;
      if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
	{
	  /* Warn about some common errors, but press on regardless.
	     The first case can be generated by gcc (<= 2.8.1).  */
	  if (i.operands == 2)
	    {
	      /* Reversed arguments on faddp, fsubp, etc.  */
	      as_warn (_("translating to `%s %%%s,%%%s'"), i.tm.name,
		       i.op[1].regs->reg_name,
		       i.op[0].regs->reg_name);
d3285 13
a3297 1
	  else
d3299 15
a3313 3
	      /* Extraneous `l' suffix on fp insn.  */
	      as_warn (_("translating to `%s %%%s'"), i.tm.name,
		       i.op[0].regs->reg_name);
a3324 12
  else if (i.tm.opcode_modifier & (Seg2ShortForm | Seg3ShortForm))
    {
      if (i.tm.base_opcode == POP_SEG_SHORT
	  && i.op[0].regs->reg_num == 1)
	{
	  as_bad (_("you can't `pop %%cs'"));
	  return 0;
	}
      i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
      if ((i.op[0].regs->reg_flags & RegRex) != 0)
	i.rex |= REX_EXTZ;
    }
d3432 1
a3432 1
	  
d4292 51
a4342 17
    { "PLTOFF",   { 0,                        BFD_RELOC_X86_64_PLTOFF64 }, Imm64 },
    { "PLT",      { BFD_RELOC_386_PLT32,      BFD_RELOC_X86_64_PLT32    }, Imm32|Imm32S|Disp32 },
    { "GOTPLT",   { 0,                        BFD_RELOC_X86_64_GOTPLT64 }, Imm64|Disp64 },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF,     BFD_RELOC_X86_64_GOTOFF64 }, Imm64|Disp64 },
    { "GOTPCREL", { 0,                        BFD_RELOC_X86_64_GOTPCREL }, Imm32|Imm32S|Disp32 },
    { "TLSGD",    { BFD_RELOC_386_TLS_GD,     BFD_RELOC_X86_64_TLSGD    }, Imm32|Imm32S|Disp32 },
    { "TLSLDM",   { BFD_RELOC_386_TLS_LDM,    0                         }, 0 },
    { "TLSLD",    { 0,                        BFD_RELOC_X86_64_TLSLD    }, Imm32|Imm32S|Disp32 },
    { "GOTTPOFF", { BFD_RELOC_386_TLS_IE_32,  BFD_RELOC_X86_64_GOTTPOFF }, Imm32|Imm32S|Disp32 },
    { "TPOFF",    { BFD_RELOC_386_TLS_LE_32,  BFD_RELOC_X86_64_TPOFF32  }, Imm32|Imm32S|Imm64|Disp32|Disp64 },
    { "NTPOFF",   { BFD_RELOC_386_TLS_LE,     0                         }, 0 },
    { "DTPOFF",   { BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_X86_64_DTPOFF32 }, Imm32|Imm32S|Imm64|Disp32|Disp64 },
    { "GOTNTPOFF",{ BFD_RELOC_386_TLS_GOTIE,  0                         }, 0 },
    { "INDNTPOFF",{ BFD_RELOC_386_TLS_IE,     0                         }, 0 },
    { "GOT",      { BFD_RELOC_386_GOT32,      BFD_RELOC_X86_64_GOT32    }, Imm32|Imm32S|Disp32|Imm64 },
    { "TLSDESC",  { BFD_RELOC_386_TLS_GOTDESC, BFD_RELOC_X86_64_GOTPC32_TLSDESC }, Imm32|Imm32S|Disp32 },
    { "TLSCALL",  { BFD_RELOC_386_TLS_DESC_CALL, BFD_RELOC_X86_64_TLSDESC_CALL }, Imm32|Imm32S|Disp32 }
d4373 1
a4373 1
		    *types = Imm32|Disp32;
d4532 4
a4535 3
      if (!use_rela_relocations)
	if ((exp->X_add_number & ~(((addressT) 2 << 31) - 1)) == 0)
	  exp->X_add_number = (exp->X_add_number ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);
d4887 2
a4888 1
	  if (flag_code != CODE_64BIT && (i.types[this_operand] & (Disp16 | Disp32)))
d5067 2
a5068 1
	      || ((i.base_reg = parse_register (base_string, &end_op)) != NULL))
d5088 2
a5089 1
		  if ((i.index_reg = parse_register (base_string, &end_op)) != NULL)
d5102 2
a5103 1
			  as_bad (_("expecting `,' or `)' after index register in `%s'"),
d5127 2
a5128 1
			  as_bad (_("expecting `)' after scale factor in `%s'"),
d5135 2
a5136 1
		      as_bad (_("expecting index register or scale factor after `,'; got '%c'"),
d5143 2
a5144 1
		  as_bad (_("expecting `,' or `)' after base register in `%s'"),
d5360 2
a5361 1
	as_warn_where (fragP->fr_file, fragP->fr_line, _("long jump required"));
d5412 2
a5413 2
                      + ((addressT) 1 << 31))
          > (((addressT) 2 << 31) - 1)))
d5788 2
a5789 1
	  know (e->X_add_number >= 0 && (valueT) e->X_add_number < ARRAY_SIZE (i386_regtab));
d6016 1
a6016 1
			   core, core2, k6, athlon, k8, generic32, generic64\n"));
d6565 2
a6566 2
    int in_offset;			/* >=1 if parsing operand of offset.  */
    int in_bracket;			/* >=1 if parsing operand in brackets.  */
d6707 1
a6707 1
        ret = 0;
d6776 3
a6778 1
      if (cur_token.code == '&' || cur_token.code == '|' || cur_token.code == '^')
d6813 3
a6815 1
      if (cur_token.code == '*' || cur_token.code == '/' || cur_token.code == '%')
d7127 2
a7128 1
		as_warn (_("`[%.*s]' taken to mean just `%.*s'"), len, start, len, start);
d7218 2
a7219 1
		as_bad (_("`%s' is not a valid segment register"), reg->reg_name);
d7409 2
a7410 1
	/* Check if this constant is a scaling factor for an index register.  */
d7419 2
a7420 1
		    as_bad (_("Register scaling only allowed in memory operands"));
d7424 4
a7427 2
		if (reg->reg_type & Reg16) /* Disallow things like [1*si]. */
		  reg = i386_regtab + REGNAM_AX + 4; /* sp is invalid as index */
d7429 1
a7429 1
		  reg = i386_regtab + REGNAM_EAX + 4; /* esp is invalid as index */
@


1.246
log
@2007-01-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Check number of operands
	when procssing memory/register operand.
@
text
@d81 1
a81 1
static void swap_imm_operands (void);
d1719 3
a1721 3
  if ((i.imm_operands == 2) && 
      ((strcmp (mnemonic, "extrq") == 0) 
       || (strcmp (mnemonic, "insertq") == 0)))
d1723 1
a1723 1
      swap_imm_operands ();  
d1738 2
a1739 1
  if (intel_syntax && i.operands > 1
d2262 1
a2262 1
swap_imm_operands (void)
a2266 2
  int xchg1 = 0;
  int xchg2 = 1;
a2278 1

a2281 5
  union i386_op temp_op;
  unsigned int temp_type;
  enum bfd_reloc_code_real temp_reloc;
  int xchg1, xchg2;

d2285 1
a2285 11
      xchg1 = 1;
      xchg2 = i.operands - 2;
      temp_type = i.types[xchg2];
      i.types[xchg2] = i.types[xchg1];
      i.types[xchg1] = temp_type;
      temp_op = i.op[xchg2];
      i.op[xchg2] = i.op[xchg1];
      i.op[xchg1] = temp_op;
      temp_reloc = i.reloc[xchg2];
      i.reloc[xchg2] = i.reloc[xchg1];
      i.reloc[xchg1] = temp_reloc;
d2288 1
a2288 11
      xchg1 = 0;
      xchg2 = i.operands - 1;
      temp_type = i.types[xchg2];
      i.types[xchg2] = i.types[xchg1];
      i.types[xchg1] = temp_type;
      temp_op = i.op[xchg2];
      i.op[xchg2] = i.op[xchg1];
      i.op[xchg1] = temp_op;
      temp_reloc = i.reloc[xchg2];
      i.reloc[xchg2] = i.reloc[xchg1];
      i.reloc[xchg1] = temp_reloc;
@


1.245
log
@2007-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (set_intel_syntax): Update set_intel_syntax
	depending on allow_naked_reg.
@
text
@d3446 6
a3451 3
	  unsigned int op = ((i.types[0] & AnyMem)
			     ? 0
			     : (i.types[1] & AnyMem) ? 1 : 2);
d3622 9
a3630 12
	  unsigned int op =
	    ((i.types[0]
	      & (Reg | RegMMX | RegXMM
		 | SReg2 | SReg3
		 | Control | Debug | Test))
	     ? 0
	     : ((i.types[1]
		 & (Reg | RegMMX | RegXMM
		    | SReg2 | SReg3
		    | Control | Debug | Test))
		? 1
		: 2));
@


1.244
log
@2007-01-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/3826
	* config/tc-i386.c (register_prefix): New.
	(set_intel_syntax): Set set_intel_syntax to "" if register
	prefix is needed.
	(check_byte_reg): Use register_prefix for error message.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
@
text
@d1108 1
a1108 7
  if (intel_syntax && allow_naked_reg)
    {
      identifier_chars['%'] = '%';
      register_prefix = "";
    }
  else
    identifier_chars['%'] = 0;
d1110 1
@


1.243
log
@2007-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (swap_operands): Remove branches.
@
text
@d294 3
d1108 7
a1114 1
  identifier_chars['%'] = intel_syntax && allow_naked_reg ? '%' : 0;
d3040 2
a3041 2
	      as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		      i.op[op].regs->reg_name,
d3099 2
a3100 2
	    as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		    i.op[op].regs->reg_name,
d3116 2
a3117 2
	as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		i.op[op].regs->reg_name,
d3148 2
a3149 2
	as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		i.op[op].regs->reg_name,
d3181 2
a3182 2
	    as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		    i.op[op].regs->reg_name,
@


1.242
log
@2007-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c: Update copyright year.
	* config/tc-i386.h: Likewise.
@
text
@d2283 1
a2283 2
  int xchg1 = 0;
  int xchg2 = 0;
d2285 1
a2285 4
  if (i.operands == 4)
    /* There will be two exchanges in a 4 operand instruction.
       First exchange is the done inside this block.(1st and 4rth operand) 
       The next exchange is done outside this block.(2nd and 3rd operand) */
d2287 14
d2302 1
a2302 1
      xchg2 = 3;
d2312 3
a2314 13
      xchg1 = 1;
      xchg2 = 2;
    }

  if (i.operands == 2)
    {
      xchg1 = 0;
      xchg2 = 1;
    }
  else if (i.operands == 3)
    {
      xchg1 = 0;
      xchg2 = 2;
a2315 9
  temp_type = i.types[xchg2];
  i.types[xchg2] = i.types[xchg1];
  i.types[xchg1] = temp_type;
  temp_op = i.op[xchg2];
  i.op[xchg2] = i.op[xchg1];
  i.op[xchg1] = temp_op;
  temp_reloc = i.reloc[xchg2];
  i.reloc[xchg2] = i.reloc[xchg1];
  i.reloc[xchg1] = temp_reloc;
@


1.241
log
@2007-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (smallest_imm_type): Return unsigned int
	instead of int.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.240
log
@2007-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c: Convert to ISO C90 formatting
	* config/tc-i386.h: Likewise.
@
text
@d921 1
a921 1
static int
@


1.239
log
@2006-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_show_usage): Mention --32/--64.
@
text
@d66 4
a69 14
static INLINE unsigned int mode_from_disp_size PARAMS ((unsigned int));
static INLINE int fits_in_signed_byte PARAMS ((offsetT));
static INLINE int fits_in_unsigned_byte PARAMS ((offsetT));
static INLINE int fits_in_unsigned_word PARAMS ((offsetT));
static INLINE int fits_in_signed_word PARAMS ((offsetT));
static INLINE int fits_in_unsigned_long PARAMS ((offsetT));
static INLINE int fits_in_signed_long PARAMS ((offsetT));
static int smallest_imm_type PARAMS ((offsetT));
static offsetT offset_in_range PARAMS ((offsetT, int));
static int add_prefix PARAMS ((unsigned int));
static void set_code_flag PARAMS ((int));
static void set_16bit_gcc_code_flag PARAMS ((int));
static void set_intel_syntax PARAMS ((int));
static void set_cpu_arch PARAMS ((int));
d71 1
a71 1
static void pe_directive_secrel PARAMS ((int));
d73 24
a96 30
static void signed_cons PARAMS ((int));
static char *output_invalid PARAMS ((int c));
static int i386_operand PARAMS ((char *operand_string));
static int i386_intel_operand PARAMS ((char *operand_string, int got_a_float));
static const reg_entry *parse_register PARAMS ((char *reg_string,
						char **end_op));
static char *parse_insn PARAMS ((char *, char *));
static char *parse_operands PARAMS ((char *, const char *));
static void swap_operands PARAMS ((void));
static void swap_imm_operands PARAMS ((void));
static void optimize_imm PARAMS ((void));
static void optimize_disp PARAMS ((void));
static int match_template PARAMS ((void));
static int check_string PARAMS ((void));
static int process_suffix PARAMS ((void));
static int check_byte_reg PARAMS ((void));
static int check_long_reg PARAMS ((void));
static int check_qword_reg PARAMS ((void));
static int check_word_reg PARAMS ((void));
static int finalize_imm PARAMS ((void));
static int process_operands PARAMS ((void));
static const seg_entry *build_modrm_byte PARAMS ((void));
static void output_insn PARAMS ((void));
static void output_branch PARAMS ((void));
static void output_jump PARAMS ((void));
static void output_interseg_jump PARAMS ((void));
static void output_imm PARAMS ((fragS *insn_start_frag,
				offsetT insn_start_off));
static void output_disp PARAMS ((fragS *insn_start_frag,
				 offsetT insn_start_off));
d98 1
a98 1
static void s_bss PARAMS ((int));
d542 1
a542 1
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
d562 1
a562 3
i386_align_code (fragP, count)
     fragS *fragP;
     int count;
d871 1
a871 2
mode_from_disp_size (t)
     unsigned int t;
d877 1
a877 2
fits_in_signed_byte (num)
     offsetT num;
d883 1
a883 2
fits_in_unsigned_byte (num)
     offsetT num;
d889 1
a889 2
fits_in_unsigned_word (num)
     offsetT num;
d895 1
a895 2
fits_in_signed_word (num)
     offsetT num;
d901 1
a901 2
fits_in_signed_long (num)
     offsetT num ATTRIBUTE_UNUSED;
d912 1
a912 2
fits_in_unsigned_long (num)
     offsetT num ATTRIBUTE_UNUSED;
d922 1
a922 2
smallest_imm_type (num)
     offsetT num;
d948 1
a948 3
offset_in_range (val, size)
     offsetT val;
     int size;
d983 1
a983 2
add_prefix (prefix)
     unsigned int prefix;
d1050 1
a1050 2
set_code_flag (value)
     int value;
d1067 1
a1067 2
set_16bit_gcc_code_flag (new_code_flag)
     int new_code_flag;
d1076 1
a1076 2
set_intel_syntax (syntax_flag)
     int syntax_flag;
d1110 1
a1110 2
set_cpu_arch (dummy)
     int dummy ATTRIBUTE_UNUSED;
d1322 1
a1322 2
i386_print_statistics (file)
     FILE *file;
d1331 4
a1334 5
static void pi PARAMS ((char *, i386_insn *));
static void pte PARAMS ((template *));
static void pt PARAMS ((unsigned int));
static void pe PARAMS ((expressionS *));
static void ps PARAMS ((symbolS *));
d1337 1
a1337 3
pi (line, x)
     char *line;
     i386_insn *x;
d1372 1
a1372 2
pte (t)
     template *t;
d1393 1
a1393 2
pe (e)
     expressionS *e;
d1413 1
a1413 2
ps (s)
     symbolS *s;
d1576 1
a1576 2
tc_i386_fix_adjustable (fixP)
     fixS *fixP ATTRIBUTE_UNUSED;
a1628 2
static int intel_float_operand PARAMS ((const char *mnemonic));

d1630 1
a1630 2
intel_float_operand (mnemonic)
     const char *mnemonic;
d1920 1
a1920 3
parse_insn (line, mnemonic)
     char *line;
     char *mnemonic;
d2139 1
a2139 3
parse_operands (l, mnemonic)
     char *l;
     const char *mnemonic;
d2257 1
a2257 1
swap_imm_operands ()
d2278 1
a2278 1
swap_operands ()
d2338 1
a2338 1
optimize_imm ()
d2458 1
a2458 1
optimize_disp ()
d2522 1
a2522 1
match_template ()
d2789 1
a2789 1
check_string ()
d3074 1
a3074 1
check_long_reg ()
d3125 1
a3125 1
check_qword_reg ()
d3157 1
a3157 1
check_word_reg ()
d3198 1
a3198 1
finalize_imm ()
d3276 1
a3276 1
process_operands ()
d3375 1
a3375 1
build_modrm_byte ()
d3666 1
a3666 1
output_branch ()
d3744 1
a3744 1
output_jump ()
d3810 1
a3810 1
output_interseg_jump ()
d3874 1
a3874 1
output_insn ()
d4267 1
a4267 3
x86_cons_fix_new (fragS *frag,
		  unsigned int off,
		  unsigned int len,
d4402 1
a4402 3
x86_cons (exp, size)
     expressionS *exp;
     int size;
a4551 2
static char *i386_scale PARAMS ((char *));

d4553 1
a4553 2
i386_scale (scale)
     char *scale;
a4599 2
static int i386_displacement PARAMS ((char *, char *));

d4601 1
a4601 3
i386_displacement (disp_start, disp_end)
     char *disp_start;
     char *disp_end;
a4782 2
static int i386_index_check PARAMS ((const char *));

d4787 1
a4787 2
i386_index_check (operand_string)
     const char *operand_string;
d4893 1
a4893 2
i386_operand (operand_string)
     char *operand_string;
d5658 1
a5658 2
output_invalid (c)
     int c;
d6022 1
a6022 1
i386_target_format ()
d6076 2
a6077 1
void i386_elf_emit_arch_note ()
d6168 1
a6168 2
md_pcrel_from (fixP)
     fixS *fixP;
d6176 1
a6176 2
s_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
d6192 1
a6192 2
i386_validate_fix (fixp)
     fixS *fixp;
d6581 10
a6590 11
static int intel_match_token	PARAMS ((int code));
static void intel_get_token	PARAMS ((void));
static void intel_putback_token	PARAMS ((void));
static int intel_expr		PARAMS ((void));
static int intel_e04		PARAMS ((void));
static int intel_e05		PARAMS ((void));
static int intel_e06		PARAMS ((void));
static int intel_e09		PARAMS ((void));
static int intel_bracket_expr	PARAMS ((void));
static int intel_e10		PARAMS ((void));
static int intel_e11		PARAMS ((void));
d6593 1
a6593 3
i386_intel_operand (operand_string, got_a_float)
     char *operand_string;
     int got_a_float;
d6703 1
a6703 1
intel_expr ()
d6714 1
a6714 1
intel_e04 ()
d6743 1
a6743 1
intel_e05 ()
d6778 1
a6778 1
intel_e06 ()
d6824 1
a6824 1
intel_e09 ()
d7038 1
a7038 1
intel_bracket_expr ()
d7114 1
a7114 1
intel_e10 ()
d7144 1
a7144 1
intel_e11 ()
d7445 1
a7445 2
intel_match_token (code)
     int code;
d7461 1
a7461 1
intel_get_token ()
d7646 1
a7646 1
intel_putback_token ()
@


1.238
log
@gas/

2006-12-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Handle shift count
	register with 3 operands.

gas/testsuite/

2006-12-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/intel.s: Add tests for "shrd %cl,%edx,%eax" and
	"shld %cl,%edx,%eax".
	* gas/i386/opcode.s: Likewise.

	* gas/i386/intel.d: Updated.
	* gas/i386/opcode-intel.d: Likewise.
	* gas/i386/opcode-suffix.d: Likewise.
	* gas/i386/opcode.d: Likewise.
@
text
@d6042 4
@


1.237
log
@2006-12-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_operands): Check i.reg_operands
	and increment i.operands when adding a register operand.
	(build_modrm_byte): Fix 4 operand instruction handling.
@
text
@d3439 7
a3445 4
	  /* When there are 3 operands, one of them must be immediate,
	     which may be the first or the last operand.  */
	  assert (i.imm_operands == 1);
	  source = (i.types[0] & Imm) ? 1 : 0;
@


1.236
log
@2006-12-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (disp_expressions): Use MAX_MEMORY_OPERANDS
	for array size instead of 2.
	(im_expressions): Use MAX_IMMEDIATE_OPERANDS for for array size
	instead of 2.
	(i386_immediate): Update immediate operand overflow error
	message.
	(i386_displacement): Check displacement operand overflow.
@
text
@d3338 2
a3339 1
      assert (i.op[first_reg_op + 1].regs == 0);
d3342 2
a3343 1
      i.reg_operands = 2;
a3431 5
      source = ((i.types[0]
		 & (Reg | RegMMX | RegXMM
		    | SReg2 | SReg3
		    | Control | Debug | Test))
		? 0 : 1);
d3433 23
a3455 4
      /* In 4 operands instructions with 2 immediate operands, the first
         two are immediate bytes and hence source operand will be in the
	 next byte after the immediates */
      if ((i.operands == 4)&&(i.imm_operands=2)) source++; 
@


1.235
log
@2006-12-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c: Document tc-i386.c, not i386.c.
@
text
@d275 3
a277 2
/* Per instruction expressionS buffers: 2 displacements & 2 immediate max.  */
static expressionS disp_expressions[2], im_expressions[2];
d4508 2
a4509 1
      as_bad (_("only 1 or 2 immediate operands are allowed"));
d4650 7
@


1.234
log
@2006-12-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (i386_immediate): Remove prototype.
@
text
@d1 1
a1 1
/* i386.c -- Assemble code for the Intel 80386
@


1.233
log
@2006-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c: Add a blank line bewteen function bodies.
@
text
@a4495 2
static int i386_immediate PARAMS ((char *));

d4497 1
a4497 2
i386_immediate (imm_start)
     char *imm_start;
@


1.232
log
@2006-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Reformat to 72 columns.
@
text
@d921 1
d933 1
@


1.231
log
@2006-12-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Simplify 3 and 4 operand
	match.
@
text
@d3433 3
a3435 2
      /* In 4 operands instructions with 2 immediate operands, the first two are immediate
	 bytes and hence source operand will be in the next byte after the immediates */
d3500 2
a3501 1
		      i.types[op] = ((i.prefix[ADDR_PREFIX] == 0) ? Disp32S : Disp32);
d3503 2
a3504 1
		  else if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
d3574 3
a3576 1
		i.types[op] = (i.types[op] & Disp8) | (i.prefix[ADDR_PREFIX] == 0 ? Disp32S : Disp32);
@


1.230
log
@2006-12-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (build_modrm_byte): Set the Operand_PCrel
	bit only.
@
text
@d2737 8
a2744 4
	      if (t->operands > 2)
		overlap2 = i.types[2] & operand_types[2];
	      if (t->operands > 3)
		overlap3 = i.types[3] & operand_types[3];
@


1.229
log
@2006-12-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (match_template): Use a for loop to set
	operand_types array.
@
text
@d3529 1
a3529 1
	      i.flags[op] = Operand_PCrel;
@


1.228
log
@gas/

2006-12-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/3712
	* config/tc-i386.c (match_template): Use MAX_OPERANDS for the
	number of operands. Issue an error if MAX_OPERANDS != 4. Add
	the 4th operand check.

gas/testsuite/

2006-12-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/3712
	* gas/i386/inval.s: Add invalid insertq.
	* gas/i386/x86-64-inval.s: Likewise.

	* gas/i386/inval.l: Updated.
	* gas/i386/x86-64-inval.l: Likewise.
@
text
@d2576 1
d2600 2
a2601 4
  operand_types [0] = 0;
  operand_types [1] = 0;
  operand_types [2] = 0;
  operand_types [3] = 0;
d2630 2
a2631 4
      operand_types [0] = t->operand_types [0];
      operand_types [1] = t->operand_types [1];
      operand_types [2] = t->operand_types [2];
      operand_types [3] = t->operand_types [3];
d2659 1
a2659 1
	    unsigned int j, DispOn = 0, DispOff = 0;
@


1.227
log
@gas/

2006-11-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.h (CpuPNI): Removed.
	(CpuUnknownFlags): Replace CpuPNI with CpuSSE3.
	* config/tc-i386.c (md_assemble): Likewise.

include/opcode/

2006-11-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386.h (i386_optab): Replace CpuPNI with CpuSSE3.
@
text
@d2571 1
a2571 1
  unsigned int overlap0, overlap1, overlap2;
d2574 1
a2574 1
  unsigned int operand_types [3];
d2577 4
d2597 1
d2602 1
d2634 1
d2680 1
a2680 1
	    for (j = 0; j < 3; j++)
d2702 1
d2737 1
a2737 2
	  /* Found a forward 2 operand match here.  */
	  else if (t->operands == 3)
d2739 5
a2743 10
	      /* Here we make use of the fact that there are no
		 reverse match 3 operand instructions, and all 3
		 operand instructions only need to be checked for
		 register consistency between operands 2 and 3.  */
	      overlap2 = i.types[2] & operand_types[2];
	      if (!MATCH (overlap2, i.types[2], operand_types[2])
		  || !CONSISTENT_REGISTER_MATCH (overlap1, i.types[1],
						 operand_types[1],
						 overlap2, i.types[2],
						 operand_types[2]))
d2745 26
a2770 1
		continue;
d2772 1
a2772 1
	  /* Found either forward/reverse 2 or 3 operand match here:
@


1.226
log
@* config/tc-i386.c (md_parse_option): Use CONST_STRNEQ.
(x86_64_section_letter): Likewise.
@
text
@d1857 1
a1857 1
      if ((i.tm.cpu_flags & CpuPNI) && i.operands > 0)
d1859 1
a1859 1
	  /* These Intel Prescott New Instructions have the fixed
@


1.225
log
@gas/

2006-09-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.h (CpuMNI): Renamed to ...
	(CpuSSSE3): This.
	(CpuUnknownFlags): Updated.
	(processor_type): Replace PROCESSOR_YONAH with PROCESSOR_CORE
	and PROCESSOR_MEROM with PROCESSOR_CORE2.
	* config/tc-i386.c: Updated.
	* doc/c-i386.texi: Likewise.

	* config/tc-i386.c (cpu_arch): Add ".ssse3", "core" and "core2".

include/opcode/

2006-09-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386.h: Replace CpuMNI with CpuSSSE3.
@
text
@d5885 1
a5885 1
	  if (   strncmp (*l, "elf64-x86-64", 12) == 0
d7788 1
a7788 1
  if (len == 5 && flag_code == CODE_64BIT && strncmp (str, "large", 5) == 0)
@


1.224
log
@gas/

2006-09-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3235
	* config/tc-i386.c (match_template): Check address size prefix
	to turn Disp64/Disp32/Disp16 operand into Disp32/Disp16/Disp32
	operand.

gas/testsuite/

2006-09-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3235
	* gas/i386/addr16.d: New file.
	* gas/i386/addr16.s: Likewise.
	* gas/i386/addr32.d: Likewise.
	* gas/i386/addr32.s: Likewise.

	* gas/i386/i386.exp: Add "addr16" and "addr32".

	* gas/i386/x86-64-addr32.s: Add tests for "add32 mov".
	* gas/i386/x86-64-addr32.d: Updated.

opcodes/

2006-09-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3235
	* i386-dis.c (OP_OFF64): Get 32bit offset if there is an
	address size prefix.
@
text
@d472 1
a472 1
  {"yonah", PROCESSOR_YONAH,
d475 1
a475 1
  {"merom", PROCESSOR_MEROM,
d477 7
a483 1
   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuMNI},
d512 2
d761 1
a761 1
     3. For PROCESSOR_MEROM, alt_long_patt will be used.
d763 1
a763 1
     PROCESSOR_YONAH, PROCESSOR_MEROM, PROCESSOR_K6, PROCESSOR_ATHLON
d820 1
a820 1
	    case PROCESSOR_MEROM:
d826 1
a826 1
	    case PROCESSOR_YONAH:
d856 1
a856 1
	    case PROCESSOR_YONAH:
d869 1
a869 1
	    case PROCESSOR_MEROM:
d3894 5
a3898 4
      /* All opcodes on i386 have either 1 or 2 bytes.  Merom New
	 Instructions have 3 bytes.  We may use one more higher byte
	 to specify a prefix the instruction requires.  */
      if ((i.tm.cpu_flags & CpuMNI) != 0)
d3939 1
a3939 1
	  if ((i.tm.cpu_flags & CpuMNI) != 0)
d5992 1
a5992 1
			   yonah, merom, k6, athlon, k8, generic32, generic64\n"));
@


1.223
log
@Add x86_64-mingw64 target
@
text
@d2566 2
d2586 4
d2605 2
d2617 4
d2628 2
a2629 2
	  && (!(t->operand_types[0] & (RegMMX | RegXMM))
	      || !(t->operand_types[t->operands > 1] & (RegMMX | RegXMM)))
d2643 36
a2678 1
      overlap0 = i.types[0] & t->operand_types[0];
d2682 1
a2682 1
	  if (!MATCH (overlap0, i.types[0], t->operand_types[0]))
d2687 3
a2689 3
	  overlap1 = i.types[1] & t->operand_types[1];
	  if (!MATCH (overlap0, i.types[0], t->operand_types[0])
	      || !MATCH (overlap1, i.types[1], t->operand_types[1])
d2696 1
a2696 1
						 t->operand_types[0],
d2698 1
a2698 1
						 t->operand_types[1])))
d2705 4
a2708 4
	      overlap0 = i.types[0] & t->operand_types[1];
	      overlap1 = i.types[1] & t->operand_types[0];
	      if (!MATCH (overlap0, i.types[0], t->operand_types[1])
		  || !MATCH (overlap1, i.types[1], t->operand_types[0])
d2710 1
a2710 1
						 t->operand_types[1],
d2712 1
a2712 1
						 t->operand_types[0]))
d2728 2
a2729 2
	      overlap2 = i.types[2] & t->operand_types[2];
	      if (!MATCH (overlap2, i.types[2], t->operand_types[2])
d2731 1
a2731 1
						 t->operand_types[1],
d2733 1
a2733 1
						 t->operand_types[2]))
d2761 1
a2761 1
	      != (t->operand_types[0] & JumpAbsolute)))
d2777 5
d2790 2
a2791 2
      i.tm.operand_types[0] = t->operand_types[1];
      i.tm.operand_types[1] = t->operand_types[0];
@


1.222
log
@PR binutils/2983
* bfd/elf64-x86-64.c: Add FreeBSD support.
  (elf64_x86_64_fbsd_post_process_headers): New function.
* bfd/targets.c (_bfd_target_vector): Add bfd_elf64_x86_64_freebsd_vec.
* bfd/config.bfd (x64_64-*-freebsd*): Add bfd_elf64_x86_64_freebsd_vec to the targ_selvecs.
* bfd/configure.in: Add entry for bfd_elf64_x86_64_freebsd_vec.
* bfd/configure: Regenerate.
* gas/config/tc-i386.c (md_parse_option): Treat any target starting with elf64_x86_64 as a viable target for the -64 switch.
  (i386_target_format): For 64-bit ELF flavoured output use ELF_TARGET_FORMAT64.
* gas/config/tc-i386.h (ELF_TARGET_FORMAT64): Define.
* ld/emulparams/elf_x86_64_fbsd.sh (OUTPUT_FORMAT): Define as elf64-x86-64-freebsd.
@
text
@d5769 2
a5770 1
struct option md_longopts[] = {
d5772 1
a5772 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
d5816 2
a5817 1

d5824 4
a5827 1
	  if (strncmp (*l, "elf64-x86-64", 12) == 0)
d5935 20
@


1.221
log
@gas/

2006-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Don't update
	cpu_arch_isa_flags.

gas/testsuite/

2006-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/nops-2-i386.d: Updated.
	* gas/i386/nops-2-merom.d: Likewise.
	* gas/i386/nops-2.d: Likewise.
@
text
@d5822 1
a5822 1
	  if (strcmp (*l, "elf64-x86-64") == 0)
d5978 1
a5978 1
	return flag_code == CODE_64BIT ? "elf64-x86-64" : ELF_TARGET_FORMAT;
@


1.220
log
@2006-07-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Remove Cpu086, CpuAthlon and
	CpuAmdFam10.
	(smallest_imm_type): Remove Cpu086.
	(i386_target_format): Likewise.

	* config/tc-i386.h: Remove Cpu086, CpuAthlon and CpuAmdFam10.
	Update CpuXXX.
@
text
@a1947 3
  /* Record what ISA we have generated so far.  */
  cpu_arch_isa_flags |= i.tm.cpu_flags;

@


1.219
log
@Add amdfam10 instructions
@
text
@d437 1
a437 1
   Cpu086|Cpu186|Cpu286|Cpu386},
d439 1
a439 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
d442 1
a442 1
   Cpu086},
d444 1
a444 1
   Cpu086|Cpu186},
d446 1
a446 1
   Cpu086|Cpu186|Cpu286},
d448 1
a448 1
   Cpu086|Cpu186|Cpu286|Cpu386},
d450 1
a450 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486},
d452 1
a452 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586},
d454 1
a454 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686},
d456 1
a456 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586},
d458 1
a458 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686},
d460 1
a460 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX},
d462 1
a462 2
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuMMX2
   |CpuSSE},
d464 1
a464 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
d467 1
a467 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
d470 1
a470 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
d473 1
a473 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
d476 1
a476 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
d479 1
a479 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX},
d481 1
a481 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX|Cpu3dnow},
d483 1
a483 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon
d486 1
a486 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon
d489 1
a489 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon
d492 1
a492 1
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon
d495 3
a497 2
   Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon
   |CpuSledgehammer|CpuAmdFam10|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2|CpuSSE3|CpuSSE4a|CpuABM},
d939 1
a939 1
  if (cpu_arch_flags != (Cpu086 | Cpu186 | Cpu286 | Cpu386 | Cpu486 | CpuNo64))
d5945 1
a5945 1
	cpu_arch_isa_flags = Cpu086|Cpu186|Cpu286|Cpu386|Cpu486
d5949 1
a5949 1
	cpu_arch_tune_flags = Cpu086|Cpu186|Cpu286|Cpu386|Cpu486
d5957 1
a5957 1
	cpu_arch_isa_flags = Cpu086|Cpu186|Cpu286|Cpu386;
d5959 1
a5959 1
	cpu_arch_tune_flags = Cpu086|Cpu186|Cpu286|Cpu386;
@


1.218
log
@gas/

2006-06-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch_tune_set): New.
	(cpu_arch_isa): Likewise.
	(i386_align_code): Use xchg %ax,%ax for 2 byte nop. Optimize
	nops with short or long nop sequences based on -march=/.arch
	and -mtune=.
	(set_cpu_arch): Set cpu_arch_isa.  If cpu_arch_tune_set is 0,
	set cpu_arch_tune and cpu_arch_tune_flags.
	(md_parse_option): For -march=, set cpu_arch_isa and set
	cpu_arch_tune and cpu_arch_tune_flags if cpu_arch_tune_set is
	0.  Set cpu_arch_tune_set to 1 for -mtune=.
	(i386_target_format): Don't set cpu_arch_tune.

gas/testsuite/

2006-06-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run nops-1, nops-1-i386, nops-1-i686,
	nops-1-merom, nops-2, nops-2-i386, nops-2-merom, x86-64-nops-1,
	x86-64-nops-1-k8, x86-64-nops-1-nocona and x86-64-nops-1-merom.

	* gas/i386/nops-1.s: New file.
	* gas/i386/nops-2.s: Likewise.
	* gas/i386/nops-1-i386.d: Likewise.
	* gas/i386/nops-1-i686.d: Likewise.
	* gas/i386/nops-1-merom.d: Likewise.
	* gas/i386/nops-1.d: Likewise.
	* gas/i386/nops-2-i386.d: Likewise.
	* gas/i386/nops-2-merom.d: Likewise.
	* gas/i386/nops-2.d: Likewise.
	* gas/i386/x86-64-nops-1.s: Likewise.
	* gas/i386/x86-64-nops-1-k8.d: Likewise.
	* gas/i386/x86-64-nops-1-merom.d: Likewise.
	* gas/i386/x86-64-nops-1-nocona.d: Likewise.
	* gas/i386/x86-64-nops-1.d: Likewise.

	* gas/i386/sse2.d: Updated to expect xchg %ax,%ax as 2 byte
	nop.
@
text
@d92 1
d495 3
d515 5
a519 1
   CpuSVME}
d752 1
a752 1
     2. For PROCESSOR_K8 in 64bit, NOPs with 0x66 prefixe will be used.
d823 1
d852 1
d1746 14
d1766 1
a1766 3
     precedes the offset, as it does when in AT&T mode.  "enter" and the
     intersegment "jmp" and "call" instructions are the only ones that
     have two immediate operands.  */
d2297 21
d2326 20
d3347 4
@


1.217
log
@2006-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.h (processor_type): New.
	(arch_entry): Add type.

	* config/tc-i386.c (cpu_arch_tune): New.
	(cpu_arch_tune_flags): Likewise.
	(cpu_arch_isa_flags): Likewise.
	(cpu_arch): Updated.
	(set_cpu_arch): Also update cpu_arch_isa_flags.
	(md_assemble): Update cpu_arch_isa_flags.
	(OPTION_MARCH): New.
	(OPTION_MTUNE): Likewise.
	(md_longopts): Add -march= and -mtune=.
	(md_parse_option): Support -march= and -mtune=.
	(md_show_usage): Add -march=CPU/-mtune=CPU.
	(i386_target_format): Also update cpu_arch_isa_flags,
	cpu_arch_tune and cpu_arch_tune_flags.

	* doc/as.texinfo: Add -march=CPU/-mtune=CPU.

	* doc/c-i386.texi: Document -march=CPU/-mtune=CPU.
@
text
@d326 3
d335 3
d571 1
a571 1
    {0x89,0xf6};				/* movl %esi,%esi	*/
d631 104
d739 26
a764 3
  /* The recommended way to pad 64bit code is to use NOPs preceded by
     maximally four 0x66 prefixes.  Balance the size of nops.  */
  if (flag_code == CODE_64BIT)
d772 2
d788 75
a862 9
    if (flag_code == CODE_16BIT)
      {
	memcpy (fragP->fr_literal + fragP->fr_fix,
		f16_patt[count - 1], count);
	if (count > 8)
	  /* Adjust jump offset.  */
	  fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
      }
    else
d864 2
a865 1
	      f32_patt[count - 1], count);
d1142 1
d1144 5
d5798 1
d5800 5
d5819 1
d5881 4
a5884 7
      if (cpu_arch_tune == PROCESSOR_UNKNOWN)
	{
	  cpu_arch_tune = PROCESSOR_GENERIC64;
	  cpu_arch_tune_flags = Cpu086|Cpu186|Cpu286|Cpu386|Cpu486
				|Cpu586|Cpu686|CpuP4|CpuMMX|CpuMMX2
				|CpuSSE|CpuSSE2;
	}
d5891 2
a5892 5
      if (cpu_arch_tune == PROCESSOR_UNKNOWN)
	{
	  cpu_arch_tune = PROCESSOR_GENERIC32;
	  cpu_arch_tune_flags = Cpu086|Cpu186|Cpu286|Cpu386;
	}
@


1.216
log
@gas/

2006-06-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (process_suffix): Don't add rex64 for
	"xchg %rax,%rax".

gas/testsuite/

2006-06-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/opcode.s: Add "xchg %ax,%ax".
	* gas/i386/opcode.d: Updated.

	* gas/i386/x86-64-opcode.s: Add xchg %ax,%ax, xchg %eax,%eax,
	xchg %rax,%rax, rex64 xchg %rax,%rax and xchg %rax,%r8.
	* gas/i386/x86-64-opcode.d: Updated.

include/opcode/

2006-06-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386.h (i386_optab): Update comment for 64bit NOP.

opcodes/

2006-06-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (NOP_Fixup): Removed.
	(NOP_Fixup1): New.
	(NOP_Fixup2): Likewise.
	(dis386): Use NOP_Fixup1 and NOP_Fixup2 on 0x90.
@
text
@d326 9
d427 79
a505 29
static const arch_entry cpu_arch[] = {
  {"i8086",	Cpu086 },
  {"i186",	Cpu086|Cpu186 },
  {"i286",	Cpu086|Cpu186|Cpu286 },
  {"i386",	Cpu086|Cpu186|Cpu286|Cpu386 },
  {"i486",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486 },
  {"i586",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586 },
  {"i686",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686 },
  {"pentium",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586 },
  {"pentiumpro",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686 },
  {"pentiumii",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX },
  {"pentiumiii",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuMMX2|CpuSSE },
  {"pentium4",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX|CpuMMX2|CpuSSE|CpuSSE2 },
  {"prescott",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuPNI },
  {"k6",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX },
  {"k6_2",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX|Cpu3dnow },
  {"athlon",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA },
  {"sledgehammer",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuSledgehammer|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2 },
  {"opteron",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuSledgehammer|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2 },
  {".mmx",	CpuMMX },
  {".sse",	CpuMMX|CpuMMX2|CpuSSE },
  {".sse2",	CpuMMX|CpuMMX2|CpuSSE|CpuSSE2 },
  {".sse3",	CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3 },
  {".3dnow",	CpuMMX|Cpu3dnow },
  {".3dnowa",	CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA },
  {".padlock",	CpuPadLock },
  {".pacifica",	CpuSVME },
  {".svme",	CpuSVME },
  {NULL, 0 }
d928 1
a928 1
      int i;
d930 1
a930 1
      for (i = 0; cpu_arch[i].name; i++)
d940 1
d953 1
a953 1
      if (!cpu_arch[i].name)
d1718 3
d5494 2
d5503 2
d5510 1
a5510 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d5512 2
d5583 31
d5644 5
d5660 14
a5673 1
    set_code_flag (CODE_64BIT);
d5675 10
a5684 1
    set_code_flag (CODE_32BIT);
@


1.215
log
@	* config/tc-arm.c, config/tc-arm.h (tc_arm_regname_to_dw2regnum):
	Un-constify string argument.
	* config/tc-i386.c, config/tc-i386.h (tc_x86_regname_to_dw2regnum):
	Likewise.
	* config/tc-m68k.c, config/tc-m68k.h (tc_m68k_regname_to_dw2regnum):
	Likewise.
	* config/tc-ppc.c, config/tc-ppc.h (tc_ppc_regname_to_dw2regnum):
	Likewise.
	* config/tc-s390.c, config/tc-s390.h (tc_s390_regname_to_dw2regnum):
	Likewise.
	* config/tc-sh.c, config/tc-sh.h (sh_regname_to_dw2regnum):
	Likewise.
	* config/tc-sparc.c, config/tc-sparc.h (sparc_regname_to_dw2regnum):
	Likewise.
-------------------------------------------------------------------
@
text
@d2618 9
a2626 1
	i.rex |= REX_MODE64;
@


1.214
log
@2006-05-02  H.J. Lu  <hongjiu.lu@@intel.com>
	    Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (output_invalid_buf): Change size for
	unsigned char.
	* config/tc-tic30.c (output_invalid_buf): Likewise.

	* config/tc-i386.c (output_invalid): Cast none-ascii char to
	unsigned char.
	* config/tc-tic30.c (output_invalid): Likewise.
@
text
@d7176 1
a7176 1
tc_x86_regname_to_dw2regnum (const char *regname)
@


1.213
log
@2006-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (output_invalid_buf): Change size to 16.
	* config/tc-tic30.c (output_invalid_buf): Likewise.

	* config/tc-i386.c (output_invalid): Use snprintf instead of
	sprintf.
	* config/tc-ia64.c (declare_register_set): Likewise.
	(emit_one_bundle): Likewise.
	(check_dependencies): Likewise.
	* config/tc-tic30.c (output_invalid): Likewise.
@
text
@d5254 1
a5254 1
static char output_invalid_buf[16];
d5265 1
a5265 1
	      "(0x%x)", (unsigned) c);
@


1.212
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d5254 1
a5254 1
static char output_invalid_buf[8];
d5261 2
a5262 1
    sprintf (output_invalid_buf, "'%c'", c);
d5264 2
a5265 1
    sprintf (output_invalid_buf, "(0x%x)", (unsigned) c);
@


1.211
log
@gas/

2006-04-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/2533
	* config/tc-i386.c (i386_immediate): Check illegal immediate
	register operand.

gas/testsuite/

2006-04-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/2533
	* gas/i386/inval.s: Add test for illegal immediate register
	operand.
	* gas/i386/inval.l: Updated.
@
text
@d2313 1
a2313 1
		 register and the second register may have differnet
@


1.210
log
@	* config/tc-i386.c: Formatting.
	(output_disp, output_imm): ISO C90 params.
@
text
@d4130 5
@


1.209
log
@	PR 2512.
	* config/tc-i386.c (match_template): Move 64-bit operand tests
	inside loop.
@
text
@d1229 3
a1231 3
     int pcrel,
     int sign,
     bfd_reloc_code_real_type other)
d1240 20
a1259 20
	    case BFD_RELOC_X86_64_GOT32:
	      return BFD_RELOC_X86_64_GOT64;
	      break;
	    case BFD_RELOC_X86_64_PLTOFF64:
	      return BFD_RELOC_X86_64_PLTOFF64;
	      break;
	    case BFD_RELOC_X86_64_GOTPC32:
	      other = BFD_RELOC_X86_64_GOTPC64;
	      break;
	    case BFD_RELOC_X86_64_GOTPCREL:
	      other = BFD_RELOC_X86_64_GOTPCREL64;
	      break;
	    case BFD_RELOC_X86_64_TPOFF32:
	      other = BFD_RELOC_X86_64_TPOFF64;
	      break;
	    case BFD_RELOC_X86_64_DTPOFF32:
	      other = BFD_RELOC_X86_64_DTPOFF64;
	      break;
	    default:
	      break;
d1278 1
a1278 1
		&& sign > 0))
d1570 1
a1570 1
			i.op[x].regs->reg_name, x + 1, i.tm.name);
d1835 1
a1835 1
	  supported |= 1;
d1837 1
a1837 1
	  supported |= 2;
d1870 1
a1870 1
	        expecting_string_instruction);
d2154 2
a2155 2
		if (mask & allowed)
		  i.types[op] &= mask;
d2518 3
a2520 3
	    || (i.tm.opcode_modifier & (JumpByte|JumpInterSegment))
	    || (i.tm.base_opcode == 0x0f01 /* [ls][gi]dt */
		&& i.tm.extension_opcode <= 3)))
d2553 7
a2559 7
	  unsigned int suffixes = ~i.tm.opcode_modifier
				  & (No_bSuf
				     | No_wSuf
				     | No_lSuf
				     | No_sSuf
				     | No_xSuf
				     | No_qSuf);
d3507 1
a3507 1
check_prefix:
d3590 1
a3590 3
output_disp (insn_start_frag, insn_start_off)
    fragS *insn_start_frag;
    offsetT insn_start_off;
d3713 1
a3713 3
output_imm (insn_start_frag, insn_start_off)
    fragS *insn_start_frag;
    offsetT insn_start_off;
d3857 3
a3859 3
     unsigned int off,
     unsigned int len,
     expressionS *exp)
d3890 2
a3891 2
     int *adjust,
     unsigned int *types)
d4223 3
a4225 3
	bigdisp = (override || i.suffix == WORD_MNEM_SUFFIX)
		  ? Disp16
		  : Disp32S | Disp32;
d4402 3
a4404 3
	RegXX = (flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
		? Reg16
		: Reg32;
d4413 2
a4414 2
     {
       unsigned RegXX = (i.prefix[ADDR_PREFIX] == 0 ? Reg64 : Reg32);
d4416 8
a4423 8
       if ((i.base_reg
	    && ((i.base_reg->reg_type & RegXX) == 0)
	    && (i.base_reg->reg_type != BaseIndex
		|| i.index_reg))
	   || (i.index_reg
	       && ((i.index_reg->reg_type & (RegXX | BaseIndex))
		   != (RegXX | BaseIndex))))
	 ok = 0;
d4466 1
a4466 1
	     i.types[this_operand] ^= (Disp16 | Disp32);
d6308 1
a6308 1
     intel_match_token (cur_token.code);
d6580 1
a6580 1
      strcat (intel_parser.disp, "[");
d7280 1
a7280 1
     }
d7282 1
a7282 1
   *ptr_msg = _("Bad .section directive: want a,w,x,M,S,G,T in string");
@


1.208
log
@Patch by matz@@suse.de:
bfd/ChangeLog:
	* reloc.c: Add BFD_RELOC_X86_64_GOT64, BFD_RELOC_X86_64_GOTPCREL64,
	BFD_RELOC_X86_64_GOTPC64, BFD_RELOC_X86_64_GOTPLT64,
	BFD_RELOC_X86_64_PLTOFF64.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
	* elf64-x86-64.c (x86_64_elf_howto_table): Correct comment.
	Add howtos for above relocs.
	(x86_64_reloc_map): Add mappings for new relocs.
	(elf64_x86_64_check_relocs): R_X86_64_GOT64, R_X86_64_GOTPCREL64,
	R_X86_64_GOTPLT64 need a got entry.  R_X86_64_GOTPLT64 also a PLT
	entry.  R_X86_64_GOTPC64 needs a .got section.  R_X86_64_PLTOFF64
	needs a PLT entry.
	(elf64_x86_64_gc_sweep_hook): Reflect changes from
	elf64_x86_64_check_relocs for the new relocs.
	(elf64_x86_64_relocate_section): Handle new relocs.

gas/ChangeLog:
	* config/tc-i386.c (type_names): Correct placement of 'static'.
	(reloc): Map some more relocs to their 64 bit counterpart when
	size is 8.
	(output_insn): Work around breakage if DEBUG386 is defined.
	(output_disp): A BFD_RELOC_64 with GOT_symbol as operand also
	needs to be mapped to BFD_RELOC_X86_64_GOTPC64 or
	BFD_RELOC_X86_64_GOTPC32.  Also x86-64 handles pcrel addressing
	different from i386.
	(output_imm): Ditto.
	(lex_got): Recognize @@PLTOFF and @@GOTPLT.  Make @@GOT accept also
	Imm64.
	(md_convert_frag): Jumps can now be larger than 2GB away, error
	out in that case.
	(tc_gen_reloc): New relocs are passed through.  BFD_RELOC_64
	and BFD_RELOC_64_PCREL are mapped to BFD_RELOC_X86_64_GOTPC64.

gas/testsuite/ChangeLog:
	* gas/i386/reloc64.s: Accept 64-bit forms.
	* gas/i386/reloc64.d: Adjust.
	* gas/i386/reloc64.l: Adjust.

include/ChangeLog:
	* elf/x86-64.h: Add the new relocations with their official
	numbers.
@
text
@d2266 1
a2266 13
  t = current_templates->start;
  if (i.suffix == QWORD_MNEM_SUFFIX
      && flag_code != CODE_64BIT
      && (intel_syntax
	  ? !(t->opcode_modifier & IgnoreSize)
	    && !intel_float_operand (t->name)
	  : intel_float_operand (t->name) != 2)
      && (!(t->operand_types[0] & (RegMMX | RegXMM))
	  || !(t->operand_types[t->operands > 1] & (RegMMX | RegXMM)))
      && (t->base_opcode != 0x0fc7
	  || t->extension_opcode != 1 /* cmpxchg8b */))
    t = current_templates->end;
  for (; t < current_templates->end; t++)
d2278 13
@


1.207
log
@gas/

2006-02-27  H.J. Lu <hongjiu.lu@@intel.com>

	* gas/config/tc-i386.c (output_insn): Support Intel Merom New
	Instructions.

	* gas/config/tc-i386.h (CpuMNI): New.
	(CpuUnknownFlags): Add CpuMNI.

gas/testsuite/

2006-02-27  H.J. Lu <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Add merom and x86-64-merom.

	* gas/i386/merom.d: New file.
	* gas/i386/merom.s: Likewise.
	* gas/i386/x86-64-merom.d: Likewise.
	* gas/i386/x86-64-merom.s: Likewise.

include/opcode/

2006-02-27  H.J. Lu <hongjiu.lu@@intel.com>

	* i386.h (i386_optab): Support Intel Merom New Instructions.

opcodes/

2006-02-27  H.J. Lu <hongjiu.lu@@intel.com>

	* i386-dis.c (IS_3BYTE_OPCODE): New for 3-byte opcodes used by
	Intel Merom New Instructions.
	(THREE_BYTE_0): Likewise.
	(THREE_BYTE_1): Likewise.
	(three_byte_table): Likewise.
	(dis386_twobyte): Use THREE_BYTE_0 for entry 0x38. Use
	THREE_BYTE_1 for entry 0x3a.
	(twobyte_has_modrm): Updated.
	(twobyte_uses_SSE_prefix): Likewise.
	(print_insn): Handle 3-byte opcodes used by Intel Merom New
	Instructions.
@
text
@d1172 1
a1172 1
struct type_name
d1177 1
a1177 2

static const type_names[] =
d1240 12
d3583 1
a3583 1
      pi (line, &i);
d3668 3
a3670 1
			|| reloc_type == BFD_RELOC_X86_64_32S)
d3694 6
a3699 1
		    reloc_type = BFD_RELOC_386_GOTPC;
d3701 3
a3704 1
		  i.op[n].disps->X_add_number += add;
d3813 2
a3814 1
		   || reloc_type == BFD_RELOC_X86_64_32S)
d3840 1
a3840 1
		  else
d3842 2
d3896 5
d3906 1
d3908 1
d3920 1
a3920 1
    { "GOT",      { BFD_RELOC_386_GOT32,      BFD_RELOC_X86_64_GOT32    }, Imm32|Imm32S|Disp32 },
d4980 14
d5755 5
d5828 6
@


1.207.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d1172 1
a1172 1
static struct type_name
d1177 2
a1178 1
const type_names[] =
a1240 12
	    case BFD_RELOC_X86_64_GOT32:
	      return BFD_RELOC_X86_64_GOT64;
	      break;
	    case BFD_RELOC_X86_64_PLTOFF64:
	      return BFD_RELOC_X86_64_PLTOFF64;
	      break;
	    case BFD_RELOC_X86_64_GOTPC32:
	      other = BFD_RELOC_X86_64_GOTPC64;
	      break;
	    case BFD_RELOC_X86_64_GOTPCREL:
	      other = BFD_RELOC_X86_64_GOTPCREL64;
	      break;
d2255 13
a2267 1
  for (t = current_templates->start; t < current_templates->end; t++)
a2278 13
      /* In general, don't allow 64-bit operands in 32-bit mode.  */
      if (i.suffix == QWORD_MNEM_SUFFIX
	  && flag_code != CODE_64BIT
	  && (intel_syntax
	      ? (!(t->opcode_modifier & IgnoreSize)
		 && !intel_float_operand (t->name))
	      : intel_float_operand (t->name) != 2)
	  && (!(t->operand_types[0] & (RegMMX | RegXMM))
	      || !(t->operand_types[t->operands > 1] & (RegMMX | RegXMM)))
	  && (t->base_opcode != 0x0fc7
	      || t->extension_opcode != 1 /* cmpxchg8b */))
	continue;

d3572 1
a3572 1
      pi ("" /*line*/, &i);
d3657 1
a3657 3
			|| reloc_type == BFD_RELOC_X86_64_32S
			|| (reloc_type == BFD_RELOC_64
			    && object_64bit))
d3681 1
a3681 6
		    {
		      reloc_type = BFD_RELOC_386_GOTPC;
		      i.op[n].imms->X_add_number += add;
		    }
		  else if (reloc_type == BFD_RELOC_64)
		    reloc_type = BFD_RELOC_X86_64_GOTPC64;
a3682 3
		    /* Don't do the adjustment for x86-64, as there
		       the pcrel addressing is relative to the _next_
		       insn, and that is taken care of in other code.  */
d3684 1
d3793 1
a3793 2
		   || reloc_type == BFD_RELOC_X86_64_32S
		   || reloc_type == BFD_RELOC_64)
d3819 1
a3819 1
		  else if (size == 4)
a3820 2
		  else if (size == 8)
		    reloc_type = BFD_RELOC_X86_64_GOTPC64;
a3872 5
  /* Some of the relocations depend on the size of what field is to
     be relocated.  But in our callers i386_immediate and i386_displacement
     we don't yet know the operand size (this will be set by insn
     matching).  Hence we record the word32 relocation here,
     and adjust the reloc according to the real size in reloc().  */
a3877 1
    { "PLTOFF",   { 0,                        BFD_RELOC_X86_64_PLTOFF64 }, Imm64 },
a3878 1
    { "GOTPLT",   { 0,                        BFD_RELOC_X86_64_GOTPLT64 }, Imm64|Disp64 },
d3890 1
a3890 1
    { "GOT",      { BFD_RELOC_386_GOT32,      BFD_RELOC_X86_64_GOT32    }, Imm32|Imm32S|Disp32|Imm64 },
a4949 14
  /* If size if less then four we are sure that the operand fits,
     but if it's 4, then it could be that the displacement is larger
     then -/+ 2GB.  */
  if (DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype) == 4
      && object_64bit
      && ((addressT) (displacement_from_opcode_start - extension
                      + ((addressT) 1 << 31))
          > (((addressT) 2 << 31) - 1)))
    {
      as_bad_where (fragP->fr_file, fragP->fr_line,
		    _("jump target out of range"));
      /* Make us emit 0.  */
      displacement_from_opcode_start = extension;
    }
a5710 5
    case BFD_RELOC_X86_64_GOT64:
    case BFD_RELOC_X86_64_GOTPCREL64:
    case BFD_RELOC_X86_64_GOTPC64:
    case BFD_RELOC_X86_64_GOTPLT64:
    case BFD_RELOC_X86_64_PLTOFF64:
a5778 6
  if ((code == BFD_RELOC_64 || code == BFD_RELOC_64_PCREL)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_X86_64_GOTPC64;
    }
@


1.206
log
@include/elf/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* common.h (DT_TLSDESC_GOT, DT_TLSDESC_PLT): New.
* i386.h (R_386_TLS_GOTDESC, R_386_TLS_DESC_CALL, R_386_TLS_DESC):
New.
* x86-64.h (R_X86_64_GOTPC32_TLSDESC, R_X86_64_TLSDESC_CALL,
R_X86_64_TLSDESC): New.
bfd/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* reloc.c (BFD_RELOC_386_TLS_GOTDESC, BFD_RELOC_386_TLS_DESC,
BFD_RELOC_386_TLS_DESC_CALL, BFD_RELOC_X86_64_GOTPC32_TLSDESC,
BFD_RELOC_X86_64_TLSDESC, BFD_RELOC_X86_64_TLSDESC_CALL): New.
* libbfd.h, bfd-in2.h: Rebuilt.
* elf32-i386.c (elf_howto_table): New relocations.
(R_386_tls): Adjust.
(elf_i386_reloc_type_lookup): Map new relocations.
(GOT_TLS_GDESC, GOT_TLS_GD_BOTH_P): New macros.
(GOT_TLS_GD_P, GOT_TLS_GDESC_P, GOT_TLS_GD_ANY_P): New macros.
(struct elf_i386_link_hash_entry): Add tlsdesc_got field.
(struct elf_i386_obj_tdata): Add local_tlsdesc_gotent field.
(elf_i386_local_tlsdesc_gotent): New macro.
(struct elf_i386_link_hash_table): Add sgotplt_jump_table_size.
(elf_i386_compute_jump_table_size): New macro.
(link_hash_newfunc): Initialize tlsdesc_got.
(elf_i386_link_hash_table_create): Set sgotplt_jump_table_size.
(elf_i386_tls_transition): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf_i386_check_relocs): Likewise.  Allocate space for
local_tlsdesc_gotent.
(elf_i386_gc_sweep_hook): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(allocate_dynrelocs): Count function PLT relocations.  Reserve
space for TLS descriptors and relocations.
(elf_i386_size_dynamic_sections): Reserve space for TLS
descriptors and relocations.  Set up sgotplt_jump_table_size.
Don't zero reloc_count in srelplt.
(elf_i386_always_size_sections): New.  Set up _TLS_MODULE_BASE_.
(elf_i386_relocate_section): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf_i386_finish_dynamic_symbol): Use GOT_TLS_GD_ANY_P.
(elf_backend_always_size_sections): Define.
* elf64-x86-64.c (x86_64_elf_howto): Add R_X86_64_GOTPC32_TLSDESC,
R_X86_64_TLSDESC, R_X86_64_TLSDESC_CALL.
(R_X86_64_standard): Adjust.
(x86_64_reloc_map): Map new relocs.
(elf64_x86_64_rtype_to_howto): New, split out of...
(elf64_x86_64_info_to_howto): ... this function, and...
(elf64_x86_64_reloc_type_lookup): ... use it to map elf_reloc_val.
(GOT_TLS_GDESC, GOT_TLS_GD_BOTH_P): New macros.
(GOT_TLS_GD_P, GOT_TLS_GDESC_P, GOT_TLS_GD_ANY_P): New macros.
(struct elf64_x86_64_link_hash_entry): Add tlsdesc_got field.
(struct elf64_x86_64_obj_tdata): Add local_tlsdesc_gotent field.
(elf64_x86_64_local_tlsdesc_gotent): New macro.
(struct elf64_x86_64_link_hash_table): Add tlsdesc_plt,
tlsdesc_got and sgotplt_jump_table_size fields.
(elf64_x86_64_compute_jump_table_size): New macro.
(link_hash_newfunc): Initialize tlsdesc_got.
(elf64_x86_64_link_hash_table_create): Initialize new fields.
(elf64_x86_64_tls_transition): Handle R_X86_64_GOTPC32_TLSDESC and
R_X86_64_TLSDESC_CALL.
(elf64_x86_64_check_relocs): Likewise.  Allocate space for
local_tlsdesc_gotent.
(elf64_x86_64_gc_sweep_hook): Handle R_X86_64_GOTPC32_TLSDESC and
R_X86_64_TLSDESC_CALL.
(allocate_dynrelocs): Count function PLT relocations.  Reserve
space for TLS descriptors and relocations.
(elf64_x86_64_size_dynamic_sections): Reserve space for TLS
descriptors and relocations.  Set up sgotplt_jump_table_size,
tlsdesc_plt and tlsdesc_got.  Make room for them.  Don't zero
reloc_count in srelplt.  Add dynamic entries for DT_TLSDESC_PLT
and DT_TLSDESC_GOT.
(elf64_x86_64_always_size_sections): New.  Set up
_TLS_MODULE_BASE_.
(elf64_x86_64_relocate_section): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf64_x86_64_finish_dynamic_symbol): Use GOT_TLS_GD_ANY_P.
(elf64_x86_64_finish_dynamic_sections): Set DT_TLSDESC_PLT and
DT_TLSDESC_GOT.  Set up TLS descriptor lazy resolver PLT entry.
(elf_backend_always_size_sections): Define.
binutils/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* readelf.c (get_dynamic_type): Handle DT_TLSDESC_GOT and
DT_TLSDESC_PLT.
gas/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* config/tc-i386.c (tc_i386_fix_adjustable): Handle
BFD_RELOC_386_TLS_GOTDESC, BFD_RELOC_386_TLS_DESC_CALL,
BFD_RELOC_X86_64_GOTPC32_TLSDESC, BFD_RELOC_X86_64_TLSDESC_CALL.
(optimize_disp): Emit fix up for BFD_RELOC_386_TLS_DESC_CALL and
BFD_RELOC_X86_64_TLSDESC_CALL immediately, and clear the
displacement bits.
(build_modrm_byte): Set up zero modrm for TLS desc calls.
(lex_got): Handle @@tlsdesc and @@tlscall.
(md_apply_fix, tc_gen_reloc): Handle the new relocations.
ld/testsuite/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* ld-i386/i386.exp: Run on x86_64-*-linux* and amd64-*-linux*.
Add new tests.
* ld-i386/pcrel16.d: Add -melf_i386.
* ld-i386/pcrel8.d: Likewise.
* ld-i386/tlsbindesc.dd: New.
* ld-i386/tlsbindesc.rd: New.
* ld-i386/tlsbindesc.s: New.
* ld-i386/tlsbindesc.sd: New.
* ld-i386/tlsbindesc.td: New.
* ld-i386/tlsdesc.dd: New.
* ld-i386/tlsdesc.rd: New.
* ld-i386/tlsdesc.s: New.
* ld-i386/tlsdesc.sd: New.
* ld-i386/tlsdesc.td: New.
* ld-i386/tlsgdesc.dd: New.
* ld-i386/tlsgdesc.rd: New.
* ld-i386/tlsgdesc.s: New.
* ld-x86-64/x86-64.exp: Run new tests.
* ld-x86-64/tlsbindesc.dd: New.
* ld-x86-64/tlsbindesc.rd: New.
* ld-x86-64/tlsbindesc.s: New.
* ld-x86-64/tlsbindesc.sd: New.
* ld-x86-64/tlsbindesc.td: New.
* ld-x86-64/tlsdesc.dd: New.
* ld-x86-64/tlsdesc.pd: New.
* ld-x86-64/tlsdesc.rd: New.
* ld-x86-64/tlsdesc.s: New.
* ld-x86-64/tlsdesc.sd: New.
* ld-x86-64/tlsdesc.td: New.
* ld-x86-64/tlsgdesc.dd: New.
* ld-x86-64/tlsgdesc.rd: New.
* ld-x86-64/tlsgdesc.s: New.
@
text
@d3477 1
d3479 4
a3482 4
      /* All opcodes on i386 have either 1 or 2 bytes.  We may use one
	 more higher byte to specify a prefix the instruction
	 requires.  */
      if ((i.tm.base_opcode & 0xff0000) != 0)
d3484 9
d3495 1
a3495 3
	      unsigned int prefix;
	      prefix = (i.tm.base_opcode >> 16) & 0xff;

d3501 1
a3501 1
	    add_prefix ((i.tm.base_opcode >> 16) & 0xff);
d3523 7
a3529 1
	  p = frag_more (2);
@


1.205
log
@gas/
2005-12-14  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (add_prefix): More fine-grained handling of
	REX prefixes. Or new prefix value into i.prefix instead of
	assigning.

gas/testsuite/
2005-12-14  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/rex.[sd]: New.
	* gas/i386/i386.exp: Run new test.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
d1348 2
d1361 2
d2203 8
a2210 1
	else
d3171 7
a3177 1
	      i.rm.mode = mode_from_disp_size (i.types[op]);
d3876 3
a3878 1
    { "GOT",      { BFD_RELOC_386_GOT32,      BFD_RELOC_X86_64_GOT32    }, Imm32|Imm32S|Disp32 }
d5085 1
d5089 1
d5102 7
d5686 2
d5697 2
d5795 2
@


1.204
log
@gas/

2005-12-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/1874
	* config/tc-i386.c (match_template): Handle monitor.
	(process_suffix): Likewise.

gas/testsuite/

2005-12-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/1874
	* gas/i386/i386.exp: Add x86-64-prescott for 64bit.

	* gas/i386/prescott.s: Test address size override for monitor.
	* gas/i386/prescott.d: Updated.

	* gas/i386/x86-64-prescott.d: New file.
	* gas/i386/x86-64-prescott.s: Likewise.

include/opcode/

2005-12-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/1874
	* i386.h (i386_optab): Add 64bit support for monitor and mwait.

opcodes/

2005-12-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/1874
	* i386-dis.c (address_mode): New enum type.
	(address_mode): New variable.
	(mode_64bit): Removed.
	(ckprefix): Updated to check address_mode instead of mode_64bit.
	(prefix_name): Likewise.
	(print_insn): Likewise.
	(putop): Likewise.
	(print_operand_value): Likewise.
	(intel_operand_size): Likewise.
	(OP_E): Likewise.
	(OP_G): Likewise.
	(set_op): Likewise.
	(OP_REG): Likewise.
	(OP_I): Likewise.
	(OP_I64): Likewise.
	(OP_OFF): Likewise.
	(OP_OFF64): Likewise.
	(ptr_reg): Likewise.
	(OP_C): Likewise.
	(SVME_Fixup): Likewise.
	(print_insn): Set address_mode.
	(PNI_Fixup): Add 64bit and address size override support for
	monitor and mwait.
@
text
@d733 1
a733 1
  int q;
d737 7
a743 1
    q = REX_PREFIX;
d745 5
a749 4
    switch (prefix)
      {
      default:
	abort ();
d751 8
a758 8
      case CS_PREFIX_OPCODE:
      case DS_PREFIX_OPCODE:
      case ES_PREFIX_OPCODE:
      case FS_PREFIX_OPCODE:
      case GS_PREFIX_OPCODE:
      case SS_PREFIX_OPCODE:
	q = SEG_PREFIX;
	break;
d760 7
a766 7
      case REPNE_PREFIX_OPCODE:
      case REPE_PREFIX_OPCODE:
	ret = 2;
	/* fall thru */
      case LOCK_PREFIX_OPCODE:
	q = LOCKREP_PREFIX;
	break;
d768 3
a770 3
      case FWAIT_OPCODE:
	q = WAIT_PREFIX;
	break;
d772 3
a774 3
      case ADDR_PREFIX_OPCODE:
	q = ADDR_PREFIX;
	break;
d776 7
a782 4
      case DATA_PREFIX_OPCODE:
	q = DATA_PREFIX;
	break;
      }
d784 1
a784 1
  if (i.prefix[q] != 0)
d786 3
a788 2
      as_bad (_("same type of prefix used twice"));
      return 0;
d790 2
a792 2
  i.prefixes += 1;
  i.prefix[q] = prefix;
@


1.203
log
@	* configure.tgt (i386-*-gnu*): Set em=gnu.
	* config/te-gnu.h: New file.
	* config/tc-i386.c: Don't use '/' as comment char for TE_GNU.
@
text
@d2278 9
a2286 4
	      || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
					     t->operand_types[0],
					     overlap1, i.types[1],
					     t->operand_types[1]))
d2554 16
a2569 6
      if (i.suffix != QWORD_MNEM_SUFFIX
	  && i.suffix != LONG_DOUBLE_MNEM_SUFFIX
	  && !(i.tm.opcode_modifier & (IgnoreSize | FloatMF))
	  && ((i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
	      || (flag_code == CODE_64BIT
		  && (i.tm.opcode_modifier & JumpByte))))
@


1.202
log
@gas/
2005-11-10  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (intel_e11): Don't special-case segment
	registers in brackets.

gas/testsuite/
2005-11-10  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/intelbad.d: Add tests for ill registers in brackets.
	* gas/i386/intelbad.l: Adjust.
@
text
@d201 1
@


1.201
log
@	* config/tc-i386.h (tc_comment_chars): Define.
	* config/tc-i386.c (line_comment_chars): Use '/' unconditionally.
	(i386_comment_chars): Add.
	(md_parse_options): Process OPTION_DIVIDE.
	(md_show_usage): Describe --divide option.
	* doc/c-i386.texi: Document --divide option.
@
text
@d6647 1
a6647 1
	else if (intel_parser.in_bracket && !(reg->reg_type & (SReg2 | SReg3)))
@


1.200
log
@gas/
2005-10-26  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (i386_operand): Don't check register prefix here.
	(parse_real_register): Rename from parse_register.
	(parse_register): New.
	(i386_parse_name): New.
	(md_operand): New.
	(intel_e11): Don't tolerate registers in offset expressions anymore.
	(intel_get_token): Don't check register prefix here. Copy the actual
	register token, not the canonical register name.
	* config/tc-i386.h (md_operand): Delete.
	(i386_parse_name): Declare.
	(md_parse_name): Define.

gas/testsuite/
2005-10-26  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/intel.s: Replace register used in offset expression.
	* gas/i386/intel.e: Adjust.
	* gas/i386/intelbad.l: Adjust.
	* gas/i386/equ.[sed]: New.
	* gas/i386/i386.exp: Run new test.
@
text
@d206 4
a209 2
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "#/";
d212 5
d225 1
a225 10
const char line_comment_chars[] = "#";

#else
/* Putting '/' here makes it impossible to use the divide operator.
   However, we need it for compatibility with SVR4 systems.  */
const char comment_chars[] = "#";
#define PREFIX_SEPARATOR '/'

const char line_comment_chars[] = "/#";
#endif
d5303 4
a5307 1
#define OPTION_32 (OPTION_MD_BASE + 0)
a5309 1
#define OPTION_64 (OPTION_MD_BASE + 1)
d5312 1
d5374 17
d5405 3
a5407 1
  -k                      ignored\n\
d5409 3
a5411 1
  -q                      quieten some warnings\n\
d5413 4
d5419 1
a5419 2
  -n                      Do not optimize code alignment\n\
  -q                      quieten some warnings\n"));
@


1.199
log
@gas/
2005-09-28  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (reloc): Disable signedness check for 4-byte
	relocations in 16- and 32-bit modes.
	(i386_displacement): Make pc-relative branch handling dependent
	upon operand (rather than address) size.

gas/testsuite/
2005-09-28  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/mixed-mode-reloc.s: Enable all insns.
	* gas/i386/mixed-mode-reloc32.d: Adjust.
	* gas/i386/mixed-mode-reloc64.d: Adjust.
@
text
@d4422 1
a4422 2
  if ((*op_string == REGISTER_PREFIX || allow_naked_reg)
      && (r = parse_register (op_string, &end_op)) != NULL)
d4560 1
a4560 2
	      || ((*base_string == REGISTER_PREFIX || allow_naked_reg)
		  && (i.base_reg = parse_register (base_string, &end_op)) != NULL))
d4580 1
a4580 2
		  if ((*base_string == REGISTER_PREFIX || allow_naked_reg)
		      && (i.index_reg = parse_register (base_string, &end_op)) != NULL)
d5157 1
a5157 3
parse_register (reg_string, end_op)
     char *reg_string;
     char **end_op;
d5224 74
d6638 2
a6639 10
	/* Offset modifier. Add the register to the displacement string to be
	   parsed as an immediate expression after we're done.  */
	else if (intel_parser.in_offset)
	  {
	    as_warn (_("Using register names in OFFSET expressions is deprecated"));
	    strcat (intel_parser.disp, reg->reg_name);
	  }

	/* It's neither base nor index nor offset.  */
	else if (!intel_parser.is_mem)
d6868 1
a6868 2
  else if ((*intel_parser.op_string == REGISTER_PREFIX || allow_naked_reg)
	   && ((reg = parse_register (intel_parser.op_string, &end_op)) != NULL))
d6870 2
d6875 2
a6876 7
      if (*intel_parser.op_string == REGISTER_PREFIX)
	{
	  new_token.str[0] = REGISTER_PREFIX;
	  new_token.str[1] = '\0';
	}

      strcat (new_token.str, reg->reg_name);
@


1.198
log
@gas/
2005-09-28  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.h (x86_cons_fix_new): Declare unconditionally.
	(TC_CONS_FIX_NEW): Define unconditionally.
	(x86_pe_cons_fix_new): Remove.
	* config/tc-i386.c (signed_cons): New.
	(md_pseudo_table): Add slong.
	(x86_cons_fix_new): Declare unconditionally.
	(x86_pe_cons_fix_new): Merge into x86_cons_fix_new.
	(tc_gen_reloc): Also consider BFD_RELOC_X86_64_32S for gotpc
	conversion.

gas/testsuite/
2005-09-28  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/reloc64.s: Also test .slong.
	* gas/i386/reloc64.l: Adjust.
	* gas/i386/reloc64.d: Adjust.
@
text
@d1240 5
d4119 1
a4119 1
  int bigdisp = Disp32;
d4122 13
d4137 5
a4141 1
      if (i.prefix[ADDR_PREFIX] == 0)
d4144 13
a4156 2
  else if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
    bigdisp = Disp16;
@


1.197
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d83 1
d465 1
d3769 26
a3901 16
/* x86_cons_fix_new is called via the expression parsing code when a
   reloc is needed.  We use this hook to get the correct .got reloc.  */
static enum bfd_reloc_code_real got_reloc = NO_RELOC;

void
x86_cons_fix_new (frag, off, len, exp)
     fragS *frag;
     unsigned int off;
     unsigned int len;
     expressionS *exp;
{
  enum bfd_reloc_code_real r = reloc (len, 0, -1, got_reloc);
  got_reloc = NO_RELOC;
  fix_new_exp (frag, off, len, exp, 0, r);
}

d3937 1
a3937 8
#ifdef TE_PE

void
x86_pe_cons_fix_new (frag, off, len, exp)
     fragS *frag;
     unsigned int off;
     unsigned int len;
     expressionS *exp;
d3939 4
a3942 9
  enum bfd_reloc_code_real r = reloc (len, 0, -1, NO_RELOC);

  if (exp->X_op == O_secrel)
    {
      exp->X_op = O_symbol;
      r = BFD_RELOC_32_SECREL;
    }

  fix_new_exp (frag, off, len, exp, 0, r);
d3945 1
a3964 1

d5568 3
a5570 1
  if ((code == BFD_RELOC_32 || code == BFD_RELOC_32_PCREL)
@


1.196
log
@gas/
2005-09-14  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (tc_x86_regname_to_dw2regnum): Add selector
	registers, floating point control and status words, and mxcsr as
	well as (for 64-bit code) segment base registers and rflags.
@
text
@d472 3
d477 1
a477 2
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  {"largecomm", handle_large_common, 0},
@


1.195
log
@gas/
2005-08-26  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (intel_e09): Set JumpAbsolute when seeing a PTR-
	qualified operand of a branch.
	(intel_bracket_expr): Set JumpAbsolute here...
	(intel_e11): ... rather than here.

gas/testsuite/
2005-08-26  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/intel.s: Adjust.
	* gas/i386/intelok.s: Add two more insns.
	* gas/i386/intelok.d: Adjust.
@
text
@d6938 4
a6941 1
      "mm4", "mm5", "mm6", "mm7"
d6957 6
a6962 1
      "mm4", "mm5", "mm6", "mm7"
@


1.194
log
@gas/
2005-08-22  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (object_64bit): New.
	(i386_target_format): Initialize it.
	(output_disp): Use object_64bit for relocation type determination.
	(output_imm): Likewise.
	(i386_validate_fix): Likewise.
	(tc_gen_reloc): Likewise.
	(lex_got): Likewise. Remove static mode_name. Change array size
	of gotrel's rel field, and adjust its initializer. Adjust diagnostic.
	(x86_cons): Use object_64bit for deciding whether quad fields can
	have relocations.

gas/testsuite/
2005-08-22  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/mixed-mode-reloc.s, gas/i386/mixed-mode-reloc32.d,
	gas/i386/mixed-mode-reloc64.d: New.
	* gas/i386/i386.exp: Run new tests.
@
text
@d6162 1
a6162 1
			   & (Jump|JumpDword|JumpInterSegment)))
d6214 5
d6303 5
a6409 7
      /* Operands for jump/call inside brackets denote absolute addresses.
	 XXX This shouldn't be needed anymore (or if it should rather live
	 in intel_bracket_expr).  */
      if (current_templates->start->opcode_modifier
	  & (Jump|JumpDword|JumpByte|JumpInterSegment))
	i.types[this_operand] |= JumpAbsolute;

@


1.193
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d290 1
d3615 1
a3615 1
		  if (flag_code != CODE_64BIT)
d3752 1
a3752 1
		  if (flag_code != CODE_64BIT)
a3781 1
  static const char * const mode_name[NUM_FLAG_CODE] = { "32", "16", "64" };
d3784 1
a3784 1
    const enum bfd_reloc_code_real rel[NUM_FLAG_CODE];
d3787 13
a3799 13
    { "PLT",      { BFD_RELOC_386_PLT32,      0, BFD_RELOC_X86_64_PLT32    }, Imm32|Imm32S|Disp32 },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF,     0, BFD_RELOC_X86_64_GOTOFF64 }, Imm64|Disp64 },
    { "GOTPCREL", { 0,                        0, BFD_RELOC_X86_64_GOTPCREL }, Imm32|Imm32S|Disp32 },
    { "TLSGD",    { BFD_RELOC_386_TLS_GD,     0, BFD_RELOC_X86_64_TLSGD    }, Imm32|Imm32S|Disp32 },
    { "TLSLDM",   { BFD_RELOC_386_TLS_LDM,    0, 0                         }, 0 },
    { "TLSLD",    { 0,                        0, BFD_RELOC_X86_64_TLSLD    }, Imm32|Imm32S|Disp32 },
    { "GOTTPOFF", { BFD_RELOC_386_TLS_IE_32,  0, BFD_RELOC_X86_64_GOTTPOFF }, Imm32|Imm32S|Disp32 },
    { "TPOFF",    { BFD_RELOC_386_TLS_LE_32,  0, BFD_RELOC_X86_64_TPOFF32  }, Imm32|Imm32S|Imm64|Disp32|Disp64 },
    { "NTPOFF",   { BFD_RELOC_386_TLS_LE,     0, 0                         }, 0 },
    { "DTPOFF",   { BFD_RELOC_386_TLS_LDO_32, 0, BFD_RELOC_X86_64_DTPOFF32 }, Imm32|Imm32S|Imm64|Disp32|Disp64 },
    { "GOTNTPOFF",{ BFD_RELOC_386_TLS_GOTIE,  0, 0                         }, 0 },
    { "INDNTPOFF",{ BFD_RELOC_386_TLS_IE,     0, 0                         }, 0 },
    { "GOT",      { BFD_RELOC_386_GOT32,      0, BFD_RELOC_X86_64_GOT32    }, Imm32|Imm32S|Disp32 }
d3818 1
a3818 1
	  if (gotrel[j].rel[(unsigned int) flag_code] != 0)
d3823 1
a3823 1
	      *reloc = gotrel[j].rel[(unsigned int) flag_code];
d3862 2
a3863 2
	  as_bad (_("@@%s reloc is not supported in %s bit mode"),
		  gotrel[j].str, mode_name[(unsigned int) flag_code]);
d3893 1
a3893 1
  if (size == 4 || (flag_code == CODE_64BIT && size == 8))
d5322 4
a5325 1
	  use_rela_relocations = 1;
d5462 1
a5462 1
	  if (flag_code != CODE_64BIT)
d5468 1
a5468 1
	  if (flag_code != CODE_64BIT)
d5570 1
a5570 1
      if (flag_code != CODE_64BIT)
@


1.192
log
@2007-07-27  H.J. Lu <hongjiu.lu@@intel.com>

	* config/tc-i386.c (handle_large_common): Declare only for ELF.
@
text
@a4872 3
/* Size of relocation record.  */
const int md_reloc_size = 8;

d4986 1
a4986 4
#if defined(BFD_ASSEMBLER) || defined(S_IS_WEAK)
	  || S_IS_WEAK (fixP->fx_addsy)
#endif
	  )
@


1.191
log
@gas/
2005-07-26  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (optimize_imm): Calculate candidate immediates
	mask from guessed suffix, but mask out other immediate types only
	if at least on candidate is valid for the insn.

gas/testsuite/
2005-07-26  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/immed32.[sd]: New.
	* gas/i386/immed64.[sd]: New.
	* gas/i386/i386.exp: Run new tests.
@
text
@d114 3
a310 1
static void handle_large_common (int small ATTRIBUTE_UNUSED);
@


1.190
log
@bfd/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_large_com_section): New.
	* elf.c (_bfd_elf_large_com_section): New. Defined.

	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): New.
	(elf64_x86_64_elf_section_from_bfd_section): New.
	(elf64_x86_64_symbol_processing): New.
	(elf64_x86_64_common_definition): New.
	(elf64_x86_64_common_section_index): New.
	(elf64_x86_64_common_section): New.
	(elf64_x86_64_merge_symbol): New.
	(elf64_x86_64_additional_program_headers): New.
	(elf64_x86_64_special_sections): New.
	(elf_backend_section_from_bfd_section): New. Defined.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_common_section_index): Likewise.
	(elf_backend_common_section): Likewise.
	(elf_backend_common_definition): Likewise.
	(elf_backend_merge_symbol): Likewise.
	(elf_backend_special_sections): Likewise.
	(elf_backend_additional_program_headers): Likewise.

binutils/

2005-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (dump_relocations): Handle SHN_X86_64_LCOMMON.
	(get_symbol_index_type): Likewise.
	(get_elf_section_flags): Handle SHF_X86_64_LARGE.

gas/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c: Include "elf/x86-64.h" if TC_I386 is
	defined.
	(elf_com_section_ptr): New.
	(elf_begin): Set elf_com_section_ptr to bfd_com_section_ptr.
	(elf_common_parse): Make it global. Use elf_com_section_ptr
	instead of bfd_com_section_ptr.
	(obj_elf_change_section): Handle x86-64 large bss sections.

	* config/obj-elf.h (elf_com_section_ptr): New.
	(elf_common_parse): New.

	* config/tc-i386.c (handle_large_common): New.
	(md_pseudo_table): Add "largecomm".
	(x86_64_section_letter): New.
	(x86_64_section_word): New.

	* config/tc-i386.h (x86_64_section_word): New.
	(x86_64_section_letter): New.
	(md_elf_section_letter): New. Defined.
	(md_elf_section_word): Likewise.

include/elf/

2005-07-25  Jan Hubicka  <jh@@suse.cz>

	* x86-64.h (SHN_X86_64_LCOMMON): New.
	(SHF_X86_64_LARGE): New.

ld/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf_x86_64.sh (LARGE_SECTIONS): New.

	* scripttempl/elf.sc: Updated for large section support.
@
text
@d2090 30
a2119 16
	    /* Convert symbolic operand to proper sizes for matching.  */
	    switch (guess_suffix)
	      {
	      case QWORD_MNEM_SUFFIX:
		i.types[op] &= Imm64 | Imm32S;
		break;
	      case LONG_MNEM_SUFFIX:
		i.types[op] &= Imm32;
		break;
	      case WORD_MNEM_SUFFIX:
		i.types[op] &= Imm16;
		break;
	      case BYTE_MNEM_SUFFIX:
		i.types[op] &= Imm8 | Imm8S;
		break;
	      }
@


1.189
log
@gas/
2005-07-18  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (md_begin): Use IS_ELF.
	(tc_i386_fix_adjustable): Likewise.
	(md_estimate_size_before_relax): Likewise.
	(md_apply_fix): Likewise.
	(i386_target_format): Likewise.
	(lex_got): Define to NULL when not ELF or when LEX_AT. Check IS_ELF.
	(i386_immediate): Remove #ifdef LEX_AT.
	(i386_displacement): Likewise.
	* config/tc-i386.h (x86_cons): Prototype only when ELF and when not
	LEX_AT.
@
text
@d308 1
d471 3
d6997 68
@


1.188
log
@gas/
2005-07-18  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (reloc): Convert to ISO C90. Change first
	parameter to unsigned. Parameter sign now is tristate - zero/
	positive mean unsigned/signed, negative means signedness doesn't
	matter. Check field size,
	signedness, and pcrel-ness are in agreement between relocated field
	and relocation type. Adjust diagnostics.
	(optimize_imm): And type mask of operand instead of overwriting it.
	(lex_got): Convert to ISO C90. Add third parameter. Add new field to
	local structure and initialize gotrel accordingly. Pass caller as
	mask of types that the operator can match.
	(x86_cons_fix_new): Let reloc know that signedness of relocation
	doesn't matter.
	(x86_pe_cons_fix_new): Likewise.
	(x86_cons): Pass additional argument to lex_got.
	(i386_immediate): New local variable 'types'. Pass its address as
	additional argument to lex_got. Mask out operand types not supported
	befoe returning.
	(i386_displacement): Likewise. Set bigdisp to all types supported in
	64-bit mode, combining the previously split initialization.

gas/testsuite/
2005-07-18  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/reloc32.[sdl]: New.
	* gas/i386/reloc64.[sdl]: New.
	* gas/i386/i386.exp: Run new tests.
@
text
@d1024 1
a1024 1
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d1294 1
a1294 1
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d3744 3
a3746 1
#ifndef LEX_AT
d3784 3
a3951 1
#ifndef LEX_AT
a3952 1
#endif
a3971 1
#ifndef LEX_AT
a3974 1
#endif
a3982 1
#ifndef LEX_AT
a3984 1
#endif
a4090 1
#ifndef LEX_AT
a4091 1
#endif
a4154 1
#ifndef LEX_AT
a4157 1
#endif
a4168 1
#ifndef LEX_AT
a4170 1
#endif
d4653 1
a4653 1
      || (OUTPUT_FLAVOR == bfd_target_elf_flavour
d4940 1
a4940 1
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour
d4948 1
a4948 1
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d4980 1
a4980 2
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && fixP->fx_addsy)
d5323 1
a5323 2
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && cpu_arch_name != NULL)
@


1.187
log
@gas/
2005-07-18  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (parse_insn): Reject prefix if unavailable in
	current mode.
@
text
@a1206 3
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, int, bfd_reloc_code_real_type));

d1208 4
a1211 5
reloc (size, pcrel, sign, other)
     int size;
     int pcrel;
     int sign;
     bfd_reloc_code_real_type other;
d1214 33
a1246 1
    return other;
d1251 1
a1251 1
	as_bad (_("There are no unsigned pc-relative relocations"));
d1259 1
a1259 1
      as_bad (_("can not do %d byte pc-relative relocation"), size);
d1263 1
a1263 1
      if (sign)
d1276 2
a1277 2
      as_bad (_("can not do %s %d byte relocation"),
	      sign ? "signed" : "unsigned", size);
d2090 1
a2090 1
		i.types[op] = Imm64 | Imm32S;
d2093 1
a2093 1
		i.types[op] = Imm32;
d2096 1
a2096 1
		i.types[op] = Imm16;
d2099 1
a2099 1
		i.types[op] = Imm8 | Imm8S;
a3744 2
static char *lex_got PARAMS ((enum bfd_reloc_code_real *, int *));

d3755 3
a3757 3
lex_got (reloc, adjust)
     enum bfd_reloc_code_real *reloc;
     int *adjust;
d3763 1
d3765 13
a3777 13
    { "PLT",      { BFD_RELOC_386_PLT32,      0, BFD_RELOC_X86_64_PLT32    } },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF,     0, BFD_RELOC_X86_64_GOTOFF64 } },
    { "GOTPCREL", { 0,                        0, BFD_RELOC_X86_64_GOTPCREL } },
    { "TLSGD",    { BFD_RELOC_386_TLS_GD,     0, BFD_RELOC_X86_64_TLSGD    } },
    { "TLSLDM",   { BFD_RELOC_386_TLS_LDM,    0, 0                         } },
    { "TLSLD",    { 0,                        0, BFD_RELOC_X86_64_TLSLD    } },
    { "GOTTPOFF", { BFD_RELOC_386_TLS_IE_32,  0, BFD_RELOC_X86_64_GOTTPOFF } },
    { "TPOFF",    { BFD_RELOC_386_TLS_LE_32,  0, BFD_RELOC_X86_64_TPOFF32  } },
    { "NTPOFF",   { BFD_RELOC_386_TLS_LE,     0, 0                         } },
    { "DTPOFF",   { BFD_RELOC_386_TLS_LDO_32, 0, BFD_RELOC_X86_64_DTPOFF32 } },
    { "GOTNTPOFF",{ BFD_RELOC_386_TLS_GOTIE,  0, 0                         } },
    { "INDNTPOFF",{ BFD_RELOC_386_TLS_IE,     0, 0                         } },
    { "GOT",      { BFD_RELOC_386_GOT32,      0, BFD_RELOC_X86_64_GOT32    } }
d3802 8
d3858 1
a3858 1
  enum bfd_reloc_code_real r = reloc (len, 0, 0, got_reloc);
d3876 1
a3876 1
      gotfree_input_line = lex_got (&got_reloc, &adjust);
d3907 1
a3907 1
  enum bfd_reloc_code_real r = reloc (len, 0, 0, NO_RELOC);
d3952 1
d3970 1
a3970 1
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL);
d4025 1
d4096 1
d4101 1
a4101 1
	bigdisp = Disp64;
d4159 1
a4159 1
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL);
d4233 4
a4236 2
  else if (flag_code == CODE_64BIT)
    i.types[this_operand] |= Disp32S | Disp32;
@


1.186
log
@gas/

2005-07-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (optimize_disp): Optimize signed 32bit
	displacements.

testsuite/gas/

2005-07-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386/x86_64.s: Add absolute siged 32bit addressing tests for
	mov.
	* i386/x86_64.d: Updated.
@
text
@d1647 9
@


1.185
log
@2005-07-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add sse3.

	* config/tc-i386.h (CpuSSE3): Renamed from ...
	(CpuPNI): This. Defined as CpuSSE3.

	* doc/c-i386.texi: Document .sse3.
@
text
@d2111 4
a2114 1
		  i.types[op] |= Disp32S;
@


1.184
log
@gas/
2005-07-05  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.h (CpuSVME): New.
	(CpuUnknownFlags): Include CpuSVME.
	* config/tc-i386.c (cpu_arch): Add .pacifica and .svme. Add opteron
	as alias of sledgehammer.
	(md_assemble): Include invlpga in the check for insns with two source
	operands.
	(process_operands): Include SVME insns in the check for ignored
	segment overrides. Adjust diagnostic.
	(i386_index_check): Special-case SVME insns with memory operands.

gas/testsuite/
2005-07-05  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/svme.d: New.
	* gas/i386/svme.s: New.
	* gas/i386/svme64.d: New.
	* gas/i386/i386.exp: Run new tests.

include/opcode/
2005-07-05  Jan Beulich  <jbeulich@@novell.com>

	* i386.h (i386_optab): Add new insns.

opcodes/
2005-07-05  Jan Beulich  <jbeulich@@novell.com>

	* i386-dis.c (SVME_Fixup): New.
	(grps): Use it for the lidt entry.
	(PNI_Fixup): Call OP_M rather than OP_E.
	(INVLPG_Fixup): Likewise.
@
text
@d436 1
@


1.183
log
@gas/

2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1013
	* config/tc-i386.c (md_assemble): Don't call optimize_disp on
	movabs.
	(optimize_disp): Optimize only if possible. Don't use 64bit
	displacement on non-constants and do same on constants if
	possible.

gas/testsuite/

2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1013
	* i386/x86_64.s: Add absolute 64bit addressing tests for mov.
	* i386/x86_64.s: Updated.

include/opcode/

2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1013
	* i386.h (i386_optab): Update comments for 64bit addressing on
	mov. Allow 64bit addressing for mov and movq.
@
text
@d432 1
d439 2
d1409 1
d2853 4
a2856 2
  if (i.tm.base_opcode == 0x8d /* lea */ && i.seg[0] && !quiet_warnings)
    as_warn (_("segment override on `lea' is ineffectual"));
d4203 24
a4226 1
   if (flag_code == CODE_64BIT)
@


1.182
log
@bfd/
2005-06-17  Jan Beulich  <jbeulich@@novell.com>

	* bfd-in2.h (elf_x86_64_reloc_type): Add BFD_RELOC_X86_64_GOTOFF64
	and BFD_RELOC_X86_64_GOTPC32.
	* libbfd.h (bfd_reloc_code_real_names): Likewise.
	* elf64-x86-64.c (x86_64_elf_howto_table): Add entries for
	R_X86_64_PC64, R_X86_64_GOTOFF64, and R_X86_64_GOTPC32.
	(x86_64_reloc_map): Add entries for R_X86_64_PC64, R_X86_64_GOTOFF64,
	and R_X86_64_GOTPC32.
	(elf64_x86_64_info_to_howto): Adjust bounding relocation type.
	(elf64_x86_64_check_relocs): Also handle R_X86_64_PC64,
	R_X86_64_GOTOFF64, and R_X86_64_GOTPC32.
	(elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_gc_sweep_hook): Also handle R_X86_64_PC64.

gas/
2005-06-17  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (reloc): Also handle BFD_RELOC_64_PCREL.
	(tc_i386_fix_adjustable): Include BFD_RELOC_X86_64_GOTOFF64,
	BFD_RELOC_X86_64_DTPOFF64, and BFD_RELOC_X86_64_TPOFF64.
	(output_disp): Do GOTPC conversion also for BFD_RELOC_X86_64_32S
	and BFD_RELOC_32_PCREL. Use BFD_RELOC_X86_64_GOTPC32 instead of
	aborting.
	(output_imm): Do GOTPC conversion also for BFD_RELOC_X86_64_32S.
	Use BFD_RELOC_X86_64_GOTPC32 instead of aborting.
	(tc_gen_reloc): Do GOTPC conversion also for BFD_RELOC_32_PCREL.
	Use BFD_RELOC_X86_64_GOTPC32 instead of aborting. Also handle
	BFD_RELOC_X86_64_GOTOFF64, BFD_RELOC_X86_64_GOTPC32,
	BFD_RELOC_X86_64_DTPOFF64, and BFD_RELOC_X86_64_TPOFF64. Also
	convert 8-byte pc-relative relocations.
	(lex_got): Use BFD_RELOC_X86_64_GOTOFF64 for 64-bit @@gotoff.
	(i386_validate_fix): Likewise.
	(x86_cons): Also handle quad values in 64-bit mode.
	(i386_displacement): Also handle BFD_RELOC_X86_64_GOTOFF64.
	(md_apply_fix): Include BFD_RELOC_X86_64_DTPOFF64 and
	BFD_RELOC_X86_64_TPOFF64 in the TLS check. Also convert BFD_RELOC_64
	to pc-relative variant. Also check for BFD_RELOC_64_PCREL.

gas/testsuite/
2005-06-17  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/x86-64-pcrel.s: Add insn requiring 64-bit pc-relative
	relocation. Add insns for all widths of non-pc-relative relocations.
	* gas/i386/x86-64-pcrel.d: Adjust.

include/elf/
2005-06-17  Jan Beulich  <jbeulich@@novell.com>

	* x86-64.h (elf_x86_64_reloc_type): Adjust comment for
	R_X86_64_GOTPCREL. Add R_X86_64_PC64, R_X86_64_GOTOFF64, and
	R_X86_64_GOTPC32.
@
text
@d1412 5
a1416 1
  if (i.disp_operands)
d2072 1
a2072 1
    if ((i.types[op] & Disp) && i.op[op].disps->X_op == O_constant)
d2074 1
a2074 3
	offsetT disp = i.op[op].disps->X_add_number;

	if (i.types[op] & Disp16)
d2076 1
a2076 4
	    /* We know this operand is at most 16 bits, so
	       convert to a signed 16 bit number before trying
	       to see whether it will fit in an even smaller
	       size.  */
d2078 35
a2112 1
	    disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
d2114 3
a2116 24
	else if (i.types[op] & Disp32)
	  {
	    /* We know this operand is at most 32 bits, so convert to a
	       signed 32 bit number before trying to see whether it will
	       fit in an even smaller size.  */
	    disp &= (((offsetT) 2 << 31) - 1);
	    disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
	  }
	if (!disp && (i.types[op] & BaseIndex))
	  {
	    i.types[op] &= ~Disp;
	    i.op[op].disps = 0;
	    i.disp_operands--;
	  }
	else if (flag_code == CODE_64BIT)
	  {
	    if (fits_in_signed_long (disp))
	      i.types[op] |= Disp32S;
	    if (fits_in_unsigned_long (disp))
	      i.types[op] |= Disp32;
	  }
	if ((i.types[op] & (Disp32 | Disp32S | Disp16))
	    && fits_in_signed_byte (disp))
	  i.types[op] |= Disp8;
@


1.181
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d1225 1
d1296 1
d1299 2
d3509 1
a3509 2
	      if (reloc_type == BFD_RELOC_32
		  && GOT_symbol
d3511 8
a3518 5
		  && (i.op[n].disps->X_op == O_symbol
		      || (i.op[n].disps->X_op == O_add
			  && ((symbol_get_value_expression
			       (i.op[n].disps->X_op_symbol)->X_op)
			      == O_subtract))))
d3535 4
a3538 4
		  /* We don't support dynamic linking on x86-64 yet.  */
		  if (flag_code == CODE_64BIT)
		    abort ();
		  reloc_type = BFD_RELOC_386_GOTPC;
d3647 2
a3648 1
	      if (reloc_type == BFD_RELOC_32
d3672 4
a3675 4
		  /* We don't support dynamic linking on x86-64 yet.  */
		  if (flag_code == CODE_64BIT)
		    abort ();
		  reloc_type = BFD_RELOC_386_GOTPC;
d3708 1
a3708 1
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF,     0, 0                         } },
d3802 1
a3802 1
  if (size == 4)
d4114 2
a4115 1
      || i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
d4133 2
d4825 3
d4843 1
d4918 1
d4920 1
a5357 1
      /* GOTOFF relocation are nonsense in 64bit mode.  */
d5366 4
a5369 3
	  if (flag_code == CODE_64BIT)
	    abort ();
	  fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
d5403 1
d5406 3
d5438 3
d5464 1
a5464 1
  if (code == BFD_RELOC_32
d5468 4
a5471 4
      /* We don't support GOTPC on 64bit targets.  */
      if (flag_code == CODE_64BIT)
	abort ();
      code = BFD_RELOC_386_GOTPC;
@


1.180
log
@gas/
2005-05-09  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (optimize_disp): Discard displacement entirely when zero and
	not required by encoding constraints.

gas/testsuite/
2005-05-09  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/tlsd.[sd]: Adjust to not assume zero displacement will
	actually be present in memory addressing.
	* gas/i386/tlspic.[sd]: Likewise.
@
text
@d4796 1
a4796 1
md_apply_fix3 (fixP, valP, seg)
@


1.179
log
@gas/
2005-05-09  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (parse_insn): Disallow use of prefix separator
	and comma in Intel mode.

include/opcode/
2005-05-09  Jan Beulich  <jbeulich@@novell.com>

	* i386.h (i386_optab): Add ht and hnt.
@
text
@d2085 7
a2091 1
	if (flag_code == CODE_64BIT)
@


1.178
log
@gas/
2005-05-09  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (tc_x86_regname_to_dw2regnum): Correct 64-bit mode
	names to match ABI. Add more registers for 32-bit and 64-bit modes.
	Make name array static and const. Adjust lookup to account for NULL
	entries (standing for unused register numbers).
@
text
@d1609 3
a1611 2
	  && *l != PREFIX_SEPARATOR
	  && *l != ',')
d1619 1
a1619 1
	  if (*l == PREFIX_SEPARATOR)
@


1.177
log
@gas/
2005-05-09  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (parse_insn): Consider all matching instructions
	when checking for string instruction after string-only prefix.
@
text
@d6792 1
a6792 1
  char *regnames_32[] =
d6796 8
a6803 1
      "eip"
d6805 1
a6805 1
  char *regnames_64[] =
d6807 3
a6809 3
      "rax", "rbx", "rcx", "rdx",
      "rdi", "rsi", "rbp", "rsp",
      "r8", "r9", "r10", "r11",
d6811 9
a6819 1
      "rip"
d6821 1
a6821 1
  char **regnames;
d6835 2
a6836 1
    if (strcmp (regname, regnames[regnum]) == 0)
@


1.176
log
@Update the address and phone number of the FSF
@
text
@d1768 1
a1768 2
  if (expecting_string_instruction
      && !(current_templates->start->opcode_modifier & IsString))
d1770 16
a1785 3
      as_bad (_("expecting string instruction after `%s'"),
	      expecting_string_instruction);
      return NULL;
@


1.175
log
@	* Makefile.am (GAS_CFILES): Remove bignum-copy.c.
	(GENERIC_OBJS): Likewise, remove bignum-copy.o.
	(bignum-copy.o): Remove.
	* Makefile.in: Regenerate.
	* makefile.vms (OBJS): Remove bignum-copy.obj.
	* symbols.h (local_symbol_make): Remove declaration.
	(verify_symbol_chain_2): Likewise.
	* symbols.c (local_symbol_make): Make static.
	(max_indent_level): Likewise.
	(verify_symbol_chain_2): Remove.
	* macro.c (macro_hash): Make static.
	* messages.c (fprint_value): Remove.
	* read.h (get_absolute_expr): Remove.
	(emit_leb128_expr): Likewise.
	(do_s_func): Likewise.
	* read.c (do_s_func): Make static.
	(emit_leb128_expr): Likewise.
	(get_absolute_expr): Likewise.
	* as.h (as_howmuch): Remove declaration.
	(fprint_value): Likewise.
	* as.c (myname): Make static.
	* input-scrub.c (as_howmuch): Remove.
	(as_1_char): Likewise.
	* input-file.h (input_file_is_open): Remove.
	* input-file.c (input_file_is_open): Likewise.
	* expr.h (expr_build_unary): Remove declaration.
	(expr_build_binary): Likewise.
	* expr.c (expr_build_unary): Remove.
	(expr_build_binary): Likewise.
	* hash.h (hash_replace): Remove declaration.
	(hash_delete): Likewise.
	* hash.c (hash_replace): Remove.
	(hash_delete): Likewise.
	* bignum-copy.c (bignum_copy): Move from here ..
	* config/tc-vax.c (bignum_copy): .. to here.
	* bignum.h (LOG_TO_BASE_2_OF_10): Remove.
	(bignum_copy): Remove extern declaration.
	* sb.h (string_count): Remove extern declaration.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* sb.c (dsize): Replace preprocessor macro with static int.
	(string_count): Make static.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* config/obj-coff.c (dim_index): Make static.
	* config/tc-i386.c (GOT_symbol): Likewise.
	(output_invalid_buf): Likewise.
	* doc/internals.texi (Warning and error messages): Remove the
	prototype for fprint_value.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.174
log
@gas/ChangeLog:
* config/tc-i386.c (md_begin): Allow hyphens in mnemonics.
include/opcode/ChangeLog:
* i386.h: Insert hyphens into selected VIA PadLock extensions.
Add xcrypt-ctr.  Provide aliases without hyphens.
opcodes/ChangeLog:
* i386-dis.c: Insert hyphens into selected VIA PadLock extensions.
Add xcrypt-ctr.
@
text
@d327 1
a327 1
symbolS *GOT_symbol;
d4974 1
a4974 1
char output_invalid_buf[8];
@


1.173
log
@include/opcode/ChangeLog:
* i386.h (i386_optab): Mark VIA PadLock instructions as ImmExt and
adjust them accordingly.
gas/ChangeLog:
* config/tc-i386.c (output_insn): Handle VIA PadLock instructions
similar to other instructions now that they're marked as ImmExt.
@
text
@d1011 1
@


1.172
log
@gas/

2005-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (tc_gen_reloc): Don't turn
	BFD_RELOC_X86_64_32S into BFD_RELOC_32.

gas/testsuite/

2005-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/x86-64-pcrel.s: Test R_X86_64_32S.
	* gas/i386/x86-64-pcrel.d: Updated.
@
text
@d3323 16
a3338 12
      /* All opcodes on i386 have either 1 or 2 bytes, PadLock instructions
	 have 3 bytes.  We may use one more higher byte to specify a prefix
	 the instruction requires.  */
      if ((i.tm.cpu_flags & CpuPadLock) != 0
	  && (i.tm.base_opcode & 0xff000000) != 0)
        {
	  unsigned int prefix;
	  prefix = (i.tm.base_opcode >> 24) & 0xff;

	  if (prefix != REPE_PREFIX_OPCODE
	      || i.prefix[LOCKREP_PREFIX] != REPE_PREFIX_OPCODE)
	    add_prefix (prefix);
a3339 4
      else
	if ((i.tm.cpu_flags & CpuPadLock) == 0
	    && (i.tm.base_opcode & 0xff0000) != 0)
	  add_prefix ((i.tm.base_opcode >> 16) & 0xff);
d3360 1
a3360 7
	  if ((i.tm.cpu_flags & CpuPadLock) != 0)
	    {
	      p = frag_more (3);
	      *p++ = (i.tm.base_opcode >> 16) & 0xff;
	    }
	  else
	    p = frag_more (2);
@


1.171
log
@gas/
2005-04-01  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (output_imm): Also set sign flag for 64-bit push
	immediates.
@
text
@d5383 7
@


1.170
log
@gas/
2005-04-01  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (s_bss): Call obj_elf_section_change_hook.

gas/testsuite/
2005-04-01  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/bss.[sd]: New.
	* gas/i386/i386.exp: Run new test.
@
text
@d3570 2
a3571 1
		  && i.suffix == QWORD_MNEM_SUFFIX)
@


1.169
log
@gas/
2005-04-01  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (md_apply_fix3): Also handle BFD_RELOC_X86_64_32S.
	(tc_gen_reloc): Handle BFD_RELOC_X86_64_32S in the default case.

gas/testsuite/
2005-04-01  Jan Beulich  <jbeulich@@novell.com>
	* gas/i386/x86-64-pcrel.[sd]: New.
	* gas/i386/i386.exp: Run new test.
@
text
@d5310 4
@


1.168
log
@gas/
2005-03-17  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (i386_scale): Beautify error message.
	(Intel syntax comments): Update.
	(struct intel_parser_s): Add fields in_offset, in_bracket, and
	next_operand.
	(intel_e04_1, intel_e05_1, intel_e05_1, intel_e09_1, intel_e10_1):
	Remove declarations.
	(intel_bracket_expr): Declare.
	(i386_intel_operand): Initialize new intel_parser fields. Wrap most
	of the function body in a loop allowing to split an operand into two.
	Replace calls to malloc and checks of it returning non-NULL with
	calls to xmalloc/xstrdup.
	(intel_expr): SHORT no longer handled here. Add comment indicating
	comparison ops need implementation.
	(intel_e04, intel_e04_1): Combine, replace recursion with loop.
	Check right operand of - does not specify a register when parsing
	the address of a memory reference.
	(intel_e05, intel_e05_1): Combine, replace recursion with loop.
	Check operands do not specify a register when parsing the address of
	a memory reference.
	(intel_e06, intel_e06_1): Likewise.
	(intel_e09, intel_e09_1): Combine, replace recursion with loop. Also
	handle SHORT as well as unary + and -. Don't accept : except for
	segment overrides or in direct far jump/call insns.
	(intel_brack_expr): New.
	(intel_e10, intel_e10_1): Combine, replace recursion with loop. Use
	intel_brack_expr.
	(intel_e11): Replace chain of if/else-if by switch, alloing fall-
	through in certain cases. Use intel_brack_expr. Add new diagnostics.
	Allow symbolic constants as register scale value.
	(intel_get_token): Replace call to malloc and check of return value
	with call to xmalloc. Change handling for FLAT to match MASM's.
	(intel_putback_token): Don't try to back up/free current token if
	that is T_NIL.

gas/testsuite/
2005-03-17  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/intel.d: Add stderr directive.
	* gas/i386/intel.e: New.
	* gas/i386/intel16.d: Add stderr directive. Adjust for changed
	source.
	* gas/i386/intel16.e: New.
	* gas/i386/intel16.s: Add instances of addressing forms with base
	and index specified in reverse order.
	* gas/i386/intelbad.l: Adjust for changed source.
	* gas/i386/intelbad.s: Add more operand forms to check.
	* gas/i386/intelok.d: Remove -r from objdump options. Add stderr
	directive. Adjust for changed source.
	* gas/i386/intelok.e: New.
	* gas/i386/intelok.s: Define MASM constants byte, word, etc. Add
	more operand forms to check.
	* gas/i386/x86_64.d: Add stderr directive.
	* gas/i386/x86_64.e: New.
	* gas/i386/x86_64.s: Adjust for parser changes.
@
text
@d4801 1
a5364 1
    case BFD_RELOC_X86_64_32S:
@


1.167
log
@update copyright dates
@
text
@d3968 10
a3977 4
      as_bad (_("expecting scale factor of 1, 2, 4, or 8: got `%s'"),
	      scale);
      input_line_pointer = save;
      return NULL;
d5523 3
d5543 1
a5543 1
 => expr		SHORT e04
d5574 4
a5577 2
    expr	SHORT e04
		| e04
d5595 5
a5599 2
		| ~ e10
		| NOT e10
d5635 2
d5639 1
a5679 1
static int intel_e04_1		PARAMS ((void));
a5680 1
static int intel_e05_1		PARAMS ((void));
a5681 1
static int intel_e06_1		PARAMS ((void));
d5683 1
a5683 1
static int intel_e09_1		PARAMS ((void));
a5684 1
static int intel_e10_1		PARAMS ((void));
d5695 2
a5696 22
  /* Initialize token holders.  */
  cur_token.code = prev_token.code = T_NIL;
  cur_token.reg = prev_token.reg = NULL;
  cur_token.str = prev_token.str = NULL;

  /* Initialize parser structure.  */
  p = intel_parser.op_string = (char *) malloc (strlen (operand_string) + 1);
  if (p == NULL)
    abort ();
  strcpy (intel_parser.op_string, operand_string);
  intel_parser.got_a_float = got_a_float;
  intel_parser.op_modifier = -1;
  intel_parser.is_mem = 0;
  intel_parser.reg = NULL;
  intel_parser.disp = (char *) malloc (strlen (operand_string) + 1);
  if (intel_parser.disp == NULL)
    abort ();
  intel_parser.disp[0] = '\0';

  /* Read the first token and start the parser.  */
  intel_get_token ();
  ret = intel_expr ();
d5698 1
a5698 1
  if (ret)
d5700 22
d5745 4
d5753 18
a5770 1
		ret = i386_index_check (operand_string);
d5775 1
a5775 1
      else if (intel_parser.op_modifier == T_OFFSET
d5778 7
d5793 6
a5798 2
/* expr	SHORT e04
	| e04  */
d5802 2
a5803 12
  /* expr  SHORT e04  */
  if (cur_token.code == T_SHORT)
    {
      intel_parser.op_modifier = T_SHORT;
      intel_match_token (T_SHORT);

      return (intel_e04 ());
    }

  /* expr  e04  */
  else
    return intel_e04 ();
d5806 1
a5806 1
/* e04	e06 e04'
d5808 1
a5808 1
   e04'	addOp e06 e04'
d5813 1
a5813 2
  return (intel_e05 () && intel_e04_1 ());
}
d5815 1
a5815 5
static int
intel_e04_1 ()
{
  /* e04'  addOp e05 e04'  */
  if (cur_token.code == '+' || cur_token.code == '-')
d5817 2
a5818 1
      char str[2];
d5820 11
a5830 3
      str[0] = cur_token.code;
      str[1] = 0;
      strcat (intel_parser.disp, str);
a5831 2

      return (intel_e05 () && intel_e04_1 ());
a5832 4

  /* e04'  Empty  */
  else
    return 1;
d5842 1
a5842 2
  return (intel_e06 () && intel_e05_1 ());
}
d5844 1
a5844 5
static int
intel_e05_1 ()
{
  /* e05'  binOp e06 e05'  */
  if (cur_token.code == '&' || cur_token.code == '|' || cur_token.code == '^')
d5846 13
a5858 1
      char str[2];
a5859 3
      str[0] = cur_token.code;
      str[1] = 0;
      strcat (intel_parser.disp, str);
d5862 2
a5863 1
      return (intel_e06 () && intel_e05_1 ());
d5865 3
a5867 4

  /* e05'  Empty  */
  else
    return 1;
d5877 1
a5877 2
  return (intel_e09 () && intel_e06_1 ());
}
d5879 1
a5879 5
static int
intel_e06_1 ()
{
  /* e06'  mulOp e09 e06'  */
  if (cur_token.code == '*' || cur_token.code == '/' || cur_token.code == '%')
d5881 2
a5882 1
      char str[2];
d5884 3
a5886 4
      str[0] = cur_token.code;
      str[1] = 0;
      strcat (intel_parser.disp, str);
      intel_match_token (cur_token.code);
d5888 10
a5897 6
      return (intel_e09 () && intel_e06_1 ());
    }
  else if (cur_token.code == T_SHL)
    {
      strcat (intel_parser.disp, "<<");
      intel_match_token (cur_token.code);
d5899 1
a5899 6
      return (intel_e09 () && intel_e06_1 ());
    }
  else if (cur_token.code == T_SHR)
    {
      strcat (intel_parser.disp, ">>");
      intel_match_token (cur_token.code);
d5901 2
a5902 1
      return (intel_e09 () && intel_e06_1 ());
d5904 3
a5906 4

  /* e06'  Empty  */
  else
    return 1;
d5909 6
a5914 5
/* e09	OFFSET e10 e09'
	| e10 e09'

   e09	~ e10 e09'
	| NOT e10 e09'
d5923 4
a5926 2
  /* e09  OFFSET e10 e09'  */
  if (cur_token.code == T_OFFSET)
d5928 46
a5973 3
      intel_parser.is_mem = 0;
      intel_parser.op_modifier = T_OFFSET;
      intel_match_token (T_OFFSET);
d5975 1
a5975 1
      return (intel_e10 () && intel_e09_1 ());
d5978 1
a5978 2
  /* e09  NOT e10 e09'  */
  else if (cur_token.code == '~')
d5980 2
a5981 1
      char str[2];
d5983 4
a5986 4
      str[0] = cur_token.code;
      str[1] = 0;
      strcat (intel_parser.disp, str);
      intel_match_token (cur_token.code);
d5988 2
a5989 2
      return (intel_e10 () && intel_e09_1 ());
    }
d5991 11
a6001 4
  /* e09  e10 e09'  */
  else
    return (intel_e10 () && intel_e09_1 ());
}
d6003 15
a6017 7
static int
intel_e09_1 ()
{
  /* e09'  PTR e10 e09' */
  if (cur_token.code == T_PTR)
    {
      char suffix;
d6019 15
a6033 2
      if (prev_token.code == T_BYTE)
	suffix = BYTE_MNEM_SUFFIX;
d6035 7
a6041 11
      else if (prev_token.code == T_WORD)
	{
	  if (current_templates->start->name[0] == 'l'
	      && current_templates->start->name[2] == 's'
	      && current_templates->start->name[3] == 0)
	    suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
	  else if (intel_parser.got_a_float == 2)	/* "fi..." */
	    suffix = SHORT_MNEM_SUFFIX;
	  else
	    suffix = WORD_MNEM_SUFFIX;
	}
d6043 7
a6049 15
      else if (prev_token.code == T_DWORD)
	{
	  if (current_templates->start->name[0] == 'l'
	      && current_templates->start->name[2] == 's'
	      && current_templates->start->name[3] == 0)
	    suffix = WORD_MNEM_SUFFIX;
	  else if (flag_code == CODE_16BIT
		   && (current_templates->start->opcode_modifier
		       & (Jump|JumpDword|JumpInterSegment)))
	    suffix = LONG_DOUBLE_MNEM_SUFFIX;
	  else if (intel_parser.got_a_float == 1)	/* "f..." */
	    suffix = SHORT_MNEM_SUFFIX;
	  else
	    suffix = LONG_MNEM_SUFFIX;
	}
d6051 1
a6051 7
      else if (prev_token.code == T_FWORD)
	{
	  if (current_templates->start->name[0] == 'l'
	      && current_templates->start->name[2] == 's'
	      && current_templates->start->name[3] == 0)
	    suffix = LONG_MNEM_SUFFIX;
	  else if (!intel_parser.got_a_float)
d6053 2
a6054 3
	      if (flag_code == CODE_16BIT)
		add_prefix (DATA_PREFIX_OPCODE);
	      suffix = LONG_DOUBLE_MNEM_SUFFIX;
d6056 1
d6058 4
a6061 2
	    suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
	}
d6063 9
a6071 7
      else if (prev_token.code == T_QWORD)
	{
	  if (intel_parser.got_a_float == 1)	/* "f..." */
	    suffix = LONG_MNEM_SUFFIX;
	  else
	    suffix = QWORD_MNEM_SUFFIX;
	}
a6072 6
      else if (prev_token.code == T_TBYTE)
	{
	  if (intel_parser.got_a_float == 1)
	    suffix = LONG_DOUBLE_MNEM_SUFFIX;
	  else
	    suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
d6075 2
a6076 1
      else if (prev_token.code == T_XMMWORD)
d6078 23
a6100 2
	  /* XXX ignored for now, but accepted since gcc uses it */
	  suffix = 0;
d6103 1
d6105 5
a6109 4
	{
	  as_bad (_("Unknown operand modifier `%s'"), prev_token.str);
	  return 0;
	}
d6111 6
a6116 5
      if (current_templates->start->base_opcode == 0x8d /* lea */)
	;
      else if (!i.suffix)
	i.suffix = suffix;
      else if (i.suffix != suffix)
d6118 1
a6118 1
	  as_bad (_("Conflicting operand modifiers"));
d6121 2
d6124 4
a6127 1
      intel_match_token (T_PTR);
d6129 30
a6158 1
      return (intel_e10 () && intel_e09_1 ());
d6160 2
d6163 27
a6189 7
  /* e09  : e10 e09'  */
  else if (cur_token.code == ':')
    {
      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  */
      if (intel_parser.op_modifier != T_OFFSET)
	intel_parser.is_mem = 1;
d6191 1
a6191 1
      return (intel_match_token (':') && intel_e10 () && intel_e09_1 ());
d6193 1
a6193 4

  /* e09'  Empty  */
  else
    return 1;
d6203 2
a6204 2
  return (intel_e11 () && intel_e10_1 ());
}
d6206 1
a6206 5
static int
intel_e10_1 ()
{
  /* e10'  [ expr ]  e10'  */
  if (cur_token.code == '[')
d6208 1
a6208 24
      intel_match_token ('[');

      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  If it's an offset expression, we need to keep
	 the brace in.  */
      if (intel_parser.op_modifier != T_OFFSET)
	intel_parser.is_mem = 1;
      else
	strcat (intel_parser.disp, "[");

      /* Add a '+' to the displacement string if necessary.  */
      if (*intel_parser.disp != '\0'
	  && *(intel_parser.disp + strlen (intel_parser.disp) - 1) != '+')
	strcat (intel_parser.disp, "+");

      if (intel_expr () && intel_match_token (']'))
	{
	  /* Preserve brackets when the operand is an offset expression.  */
	  if (intel_parser.op_modifier == T_OFFSET)
	    strcat (intel_parser.disp, "]");

	  return intel_e10_1 ();
	}
      else
d6212 1
a6212 3
  /* e10'  Empty  */
  else
    return 1;
d6233 1
a6233 2
  /* e11  ( expr ) */
  if (cur_token.code == '(')
d6235 2
d6245 1
a6245 8
      else
	return 0;
    }

  /* e11  [ expr ] */
  else if (cur_token.code == '[')
    {
      intel_match_token ('[');
d6247 5
a6251 9
      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  If it's an offset expression, we need to keep
	 the brace in.  */
      if (intel_parser.op_modifier != T_OFFSET)
	intel_parser.is_mem = 1;
      else
	strcat (intel_parser.disp, "[");

      /* Operands for jump/call inside brackets denote absolute addresses.  */
d6256 1
a6256 10
      /* Add a '+' to the displacement string if necessary.  */
      if (*intel_parser.disp != '\0'
	  && *(intel_parser.disp + strlen (intel_parser.disp) - 1) != '+')
	strcat (intel_parser.disp, "+");

      if (intel_expr () && intel_match_token (']'))
	{
	  /* Preserve brackets when the operand is an offset expression.  */
	  if (intel_parser.op_modifier == T_OFFSET)
	    strcat (intel_parser.disp, "]");
d6258 3
a6260 48
	  return 1;
	}
      else
	return 0;
    }

  /* e11  BYTE
	  | WORD
	  | DWORD
	  | FWORD
	  | QWORD
	  | TBYTE
	  | OWORD
	  | XMMWORD  */
  else if (cur_token.code == T_BYTE
	   || cur_token.code == T_WORD
	   || cur_token.code == T_DWORD
	   || cur_token.code == T_FWORD
	   || cur_token.code == T_QWORD
	   || cur_token.code == T_TBYTE
	   || cur_token.code == T_XMMWORD)
    {
      intel_match_token (cur_token.code);

      if (cur_token.code != T_PTR)
	{
	  /* It must have been an identifier; add it to the displacement string.  */
	  strcat (intel_parser.disp, prev_token.str);

	  /* The identifier represents a memory reference only if it's not
	     preceded by an offset modifier and if it's not an equate.  */
	  if (intel_parser.op_modifier != T_OFFSET)
	    {
	      symbolS *symbolP;

	      symbolP = symbol_find(prev_token.str);
	      if (!symbolP || S_GET_SEGMENT(symbolP) != absolute_section)
		intel_parser.is_mem = 1;
	    }
	}

      return 1;
    }

  /* e11  $
	  | .  */
  else if (cur_token.code == '.')
    {
d6266 1
a6266 1
      if (intel_parser.op_modifier != T_OFFSET)
a6269 1
    }
d6271 6
a6276 4
  /* e11  register  */
  else if (cur_token.code == T_REG)
    {
      const reg_entry *reg = intel_parser.reg = cur_token.reg;
d6278 37
a6314 1
      intel_match_token (T_REG);
d6316 8
a6323 33
      /* Check for segment change.  */
      if (cur_token.code == ':')
	{
	  if (reg->reg_type & (SReg2 | SReg3))
	    {
	      switch (reg->reg_num)
		{
		case 0:
		  i.seg[i.mem_operands] = &es;
		  break;
		case 1:
		  i.seg[i.mem_operands] = &cs;
		  break;
		case 2:
		  i.seg[i.mem_operands] = &ss;
		  break;
		case 3:
		  i.seg[i.mem_operands] = &ds;
		  break;
		case 4:
		  i.seg[i.mem_operands] = &fs;
		  break;
		case 5:
		  i.seg[i.mem_operands] = &gs;
		  break;
		}
	    }
	  else
	    {
	      as_bad (_("`%s' is not a valid segment register"), reg->reg_name);
	      return 0;
	    }
	}
d6325 4
a6328 8
      /* Not a segment register. Check for register scaling.  */
      else if (cur_token.code == '*')
	{
	  if (!intel_parser.is_mem)
	    {
	      as_bad (_("Register scaling only allowed in memory operands."));
	      return 0;
	    }
d6330 4
a6333 6
	  /* What follows must be a valid scale.  */
	  if (intel_match_token ('*')
	      && strchr ("01248", *cur_token.str))
	    {
	      i.index_reg = reg;
	      i.types[this_operand] |= BaseIndex;
d6335 20
a6354 9
	      /* Set the scale after setting the register (otherwise,
		 i386_scale will complain)  */
	      i386_scale (cur_token.str);
	      intel_match_token (T_CONST);
	    }
	  else
	    {
	      as_bad (_("expecting scale factor of 1, 2, 4, or 8: got `%s'"),
		      cur_token.str);
d6356 2
a6357 2
	    }
	}
d6359 5
a6363 10
      /* No scaling. If this is a memory operand, the register is either a
	 base register (first occurrence) or an index register (second
	 occurrence).  */
      else if (intel_parser.is_mem && !(reg->reg_type & (SReg2 | SReg3)))
	{
	  if (i.base_reg && i.index_reg)
	    {
	      as_bad (_("Too many register references in memory operand."));
	      return 0;
	    }
d6365 9
a6373 4
	  if (i.base_reg == NULL)
	    i.base_reg = reg;
	  else
	    i.index_reg = reg;
d6375 2
a6376 2
	  i.types[this_operand] |= BaseIndex;
	}
d6378 7
a6384 4
      /* Offset modifier. Add the register to the displacement string to be
	 parsed as an immediate expression after we're done.  */
      else if (intel_parser.op_modifier == T_OFFSET)
	strcat (intel_parser.disp, reg->reg_name);
d6386 24
a6409 7
      /* It's neither base nor index nor offset.  */
      else
	{
	  i.types[this_operand] |= reg->reg_type & ~BaseIndex;
	  i.op[this_operand].regs = reg;
	  i.reg_operands++;
	}
d6411 2
a6412 11
      /* Since registers are not part of the displacement string (except
	 when we're parsing offset operands), we may need to remove any
	 preceding '+' from the displacement string.  */
      if (*intel_parser.disp != '\0'
	  && intel_parser.op_modifier != T_OFFSET)
	{
	  char *s = intel_parser.disp;
	  s += strlen (s) - 1;
	  if (*s == '+')
	    *s = '\0';
	}
d6414 16
a6429 2
      return 1;
    }
d6431 2
a6432 5
  /* e11  id  */
  else if (cur_token.code == T_ID)
    {
      /* Add the identifier to the displacement string.  */
      strcat (intel_parser.disp, cur_token.str);
d6434 9
a6442 3
      /* The identifier represents a memory reference only if it's not
	 preceded by an offset modifier and if it's not an equate.  */
      if (intel_parser.op_modifier != T_OFFSET)
d6446 2
d6452 1
d6454 5
a6458 3
      intel_match_token (T_ID);
      return 1;
    }
d6460 12
a6471 6
  /* e11  constant  */
  else if (cur_token.code == T_CONST
	   || cur_token.code == '-'
	   || cur_token.code == '+')
    {
      char *save_str;
d6473 4
a6476 12
      /* Allow constants that start with `+' or `-'.  */
      if (cur_token.code == '-' || cur_token.code == '+')
	{
	  strcat (intel_parser.disp, cur_token.str);
	  intel_match_token (cur_token.code);
	  if (cur_token.code != T_CONST)
	    {
	      as_bad (_("Syntax error. Expecting a constant. Got `%s'."),
		      cur_token.str);
	      return 0;
	    }
	}
d6478 2
a6479 4
      save_str = (char *) malloc (strlen (cur_token.str) + 1);
      if (save_str == NULL)
	abort ();
      strcpy (save_str, cur_token.str);
d6481 26
a6506 11
      /* Get the next token to check for register scaling.  */
      intel_match_token (cur_token.code);

      /* Check if this constant is a scaling factor for an index register.  */
      if (cur_token.code == '*')
	{
	  if (intel_match_token ('*') && cur_token.code == T_REG)
	    {
	      if (!intel_parser.is_mem)
		{
		  as_bad (_("Register scaling only allowed in memory operands."));
d6508 1
a6508 8
		}

	      /* The constant is followed by `* reg', so it must be
		 a valid scale.  */
	      if (strchr ("01248", *save_str))
		{
		  i.index_reg = cur_token.reg;
		  i.types[this_operand] |= BaseIndex;
d6510 19
a6528 28
		  /* Set the scale after setting the register (otherwise,
		     i386_scale will complain)  */
		  i386_scale (save_str);
		  intel_match_token (T_REG);

		  /* Since registers are not part of the displacement
		     string, we may need to remove any preceding '+' from
		     the displacement string.  */
		  if (*intel_parser.disp != '\0')
		    {
		      char *s = intel_parser.disp;
		      s += strlen (s) - 1;
		      if (*s == '+')
			*s = '\0';
		    }

		  free (save_str);

		  return 1;
		}
	      else
		return 0;
	    }

	  /* The constant was not used for register scaling. Since we have
	     already consumed the token following `*' we now need to put it
	     back in the stream.  */
	  else
d6530 1
a6530 1
	}
d6532 3
a6534 3
      /* Add the constant to the displacement string.  */
      strcat (intel_parser.disp, save_str);
      free (save_str);
d6536 2
a6537 1
      return 1;
d6594 1
a6594 3
  new_token.str = (char *) malloc (strlen (intel_parser.op_string) + 1);
  if (new_token.str == NULL)
    abort ();
d6714 7
a6720 1
	    new_token.code = T_OFFSET;
d6755 5
a6759 2
  intel_parser.op_string -= strlen (cur_token.str);
  free (cur_token.str);
@


1.167.2.1
log
@gas/
2005-04-13  Jan Beulich  <jbeulich@@novell.com>
            H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_apply_fix3): Also handle BFD_RELOC_X86_64_32S.
	(tc_gen_reloc): Handle BFD_RELOC_X86_64_32S specially.

gas/testsuite/
2005-04-13  Jan Beulich  <jbeulich@@novell.com>
            H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/x86-64-pcrel.[sd]: New.
	* gas/i386/i386.exp: Run new test.
@
text
@a4794 1
	case BFD_RELOC_X86_64_32S:
d5358 1
a5371 7
    case BFD_RELOC_X86_64_32S:
      if (!fixp->fx_pcrel)
	{
	  /* Don't turn BFD_RELOC_X86_64_32S into BFD_RELOC_32.  */
	  code = fixp->fx_r_type;
	  break;
	}
@


1.166
log
@gas/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (build_modrm_byte): Add lock prefix for cr8...15
	accesses.
	(parse_register): Allow cr8...15 in all modes.

gas/testsuite/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/cr-err.[ls]: New.
	* gas/i386/crx.[ds]: New.
	* gas/i386/i386.exp: Run new tests.

opcodes/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* i386-dis.c (print_insn): Suppress lock prefix printing for cr8...15
	accesses.
	(OP_C): Consider lock prefix in non-64-bit modes.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
@


1.165
log
@gas/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (intel_e11): If not followed by T_PTR, treat T_BYTE
	etc. like normal symbol references (T_ID).

gas/testsuite/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/intelok.d: Add -r to objdump options. Adjust expectations.
	* gas/i386/intelok.s: Add checks for various special memory operands.
@
text
@d2871 7
d5050 1
@


1.164
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d6157 17
@


1.163
log
@2005-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 659
	* config/tc-i386.c (i386_scale): Disallow 0 scale.
@
text
@d2492 1
a2492 8
      if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4
#if 0
	  /* Check that the template allows eight bit regs.  This
	     kills insns such as `orb $1,%edx', which maybe should be
	     allowed.  */
	  && (i.tm.operand_types[op] & (Reg8 | InOutPortReg))
#endif
	  )
@


1.162
log
@gas/
2004-11-25 Jan Beulich <jbeulich@@novell.com>

	* config/tc-i386.c (optimize_imm): Adjust immediates to only those
	permissible for the selected instruction suffix.
	(process_suffix): For DefaultSize instructions, suppressing the
	guessing of a 'q' suffix if the instruction doesn't support it is
	pointless, because only an 'l' suffix can be guessed in this place.

gas/testsuite/
2004-11-25 Jan Beulich <jbeulich@@novell.com>
	* gas/i386/x86-64-inval.[sl]: Remove sahf/lahf.

include/opcode/
2004-11-25 Jan Beulich <jbeulich@@novell.com>

	* i386.h: CpuNo64 mov can't reasonably have a 'q' suffix. Moves
	to/from test registers are illegal in 64-bit mode. Add missing
	NoRex64 to sidt. fxsave/fxrstor now allow for a 'q' suffix
	(previously one had to explicitly encode a rex64 prefix). Re-enable
	lahf/sahf in 64-bit mode as at least some Athlon64/Opteron steppings
	support it there. Add cmpxchg16b as per Intel's 64-bit documentation.
@
text
@a3954 1
    case 0:
@


1.161
log
@gas/
2004-11-23 Jan Beulich <jbeulich@@novell.com>

	* config/tc-i386.h (CpuMMX2): Declare. Artificial classifier to
	indicate the MMX extensions added by both SSE and 3DNow!A.
	(Cpu3dnowA): Declare.
	(CpuUnknownFlags): Update.
	* config/tc-i386.c (cpu_sub_arch_name): Declare.
	(cpu_arch): i586 and pentium do not imply MMX. i686 and pentiumpro do
	neither imply SSE nor MMX. k6 implies MMX. k6_2 additionally implies
	3DNow!. Athlon additionally implies 3DNow!A. Several new
	entries (those starting with a dot are for sub-arch specification).
	(set_cpu_arch): Handle sub-arch specifications.
	(parse_insn): Distinguish between instructions not supported because
	of insufficient CPU features and because of 64-bit mode.
	* doc/c-i386.texi: Describe enhanced .arch directive.

include/opcode/
2004-11-23 Jan Beulich <jbeulich@@novell.com>

	* i386.h (i386_optab): paddq and psubq, even in their MMX form, are
	available only with SSE2. Change the MMX additions introduced by SSE
	and 3DNow!A to CpuMMX2 (rather than CpuMMX). Indicate the 3DNow!A
	instructions by their now designated identifier (since combining i686
	and 3DNow! does not really imply 3DNow!A).
@
text
@a2364 3
      if (i.suffix == QWORD_MNEM_SUFFIX
	  && (i.tm.opcode_modifier & No_qSuf))
	i.suffix = LONG_MNEM_SUFFIX;
d2702 1
a2702 1
  if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32))
@


1.160
log
@Fix support for PECOFF weak symbols
@
text
@d317 1
d420 18
a437 8
  {"i586",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX },
  {"i686",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuSSE },
  {"pentium",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX },
  {"pentiumpro",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuSSE },
  {"pentium4",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX|CpuSSE|CpuSSE2 },
  {"k6",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX|Cpu3dnow },
  {"athlon",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuMMX|Cpu3dnow },
  {"sledgehammer",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuSledgehammer|CpuMMX|Cpu3dnow|CpuSSE|CpuSSE2 },
d850 16
a865 4
	      cpu_arch_name = cpu_arch[i].name;
	      cpu_arch_flags = (cpu_arch[i].flags
				| (flag_code == CODE_64BIT ? Cpu64 : CpuNo64));
	      break;
d1587 2
d1737 18
a1754 2
  if ((current_templates->start->cpu_flags & ~(Cpu64 | CpuNo64))
      & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64)))
d1756 4
a1759 2
      as_warn (_("`%s' is not supported on `%s'"),
	       current_templates->start->name, cpu_arch_name);
@


1.159
log
@gas/
2004-11-04 Jan Beulich <jbeulich@@novell.com>

	* config/tc-i386.c (set_intel_syntax): Allow % in symbol names when
	intel syntax and no register prefix, allow $ in symbol names when
	intel syntax.
	(set_16bit_gcc_code_flag): Replace literal 'l' by LONG_MNEM_SUFFIX.
	(intel_float_operand): Add fourth return value indicating math control
	operations. Make classification more precise.
	(md_assemble): Complain if memory operand of mov[sz]x has no size
	specified.
	(parse_insn): Translate word operands to floating point instructions
	operating on integers as well as control instructions to short ones
	as expected by AT&T syntax. Translate 'd' suffix to short one only for
	floating point instructions operating on non-integer operands.
	(match_template): Remove fldcw special case. Adjust q-suffix handling
	to permit it on fild/fistp/fisttp in AT&T mode.
	(process_suffix): Don't guess DefaultSize insns' suffix from
	stackop_size for certain floating point control instructions. Guess
	suffix for branch and [ls][gi]dt based on flag_code. Split error
	messages for Intel and AT&T syntax, and make the condition more strict
	for the former. Adjust suppressing of generation of operand size
	overrides.
	(intel parser): Allow the full set of MASM operators. Add FWORD, TBYTE,
	OWORD, and XMMWORD operand size specifiers (TBYTE replaces XWORD). Add
	more error checking.
	* config/tc-i386.h (BYTE_PTR WORD_PTR DWORD_PTR QWORD_PTR XWORD_PTR
	SHORT OFFSET_FLAT FLAT NONE_FOUND): Remove unused defines.

gas/testsuite/
2004-11-04 Jan Beulich <jbeulich@@novell.com>
	* gas/i386/i386.exp: Execute new tests intelbad and intelok.
	* gas/i386/intelbad.[sl]: New test to check for various things not
	permitted in Intel mode.
	* gas/i386/intel.d, gas/i386/opcode.d, gas/i386/x86-64-opcode.d:
	Adjust for change to segment register store.
	* gas/i386/intelok.[sd]: New test to check various Intel mode specific
	things get handled correctly.
	* gas/i386/x86_64.[sd]: Remove unsupported constructs referring to
	'high' and 'low' parts of an operand, which the parser previously
	accepted while neither telling that it's not supported nor that it
	ignored the remainder of the line following these supposed keywords.

include/opcode/
2004-11-04 Jan Beulich <jbeulich@@novell.com>

	* i386.h (sldx_Suf): Remove.
	(FP, l_FP, sl_FP, x_FP): Don't imply IgnoreSize.
	(q_FP): Define, implying no REX64.
	(x_FP, sl_FP): Imply FloatMF.
	(i386_optab): Split reg and mem forms of moving from segment registers
	so that the memory forms can ignore the 16-/32-bit operand size
	distinction. Adjust a few others for Intel mode. Remove *FP uses from
	all non-floating-point instructions. Unite 32- and 64-bit forms of
	movsx, movzx, and movd. Adjust floating point operations for the above
	changes to the *FP macros. Add DefaultSize to floating point control
	insns operating on larger memory ranges. Remove left over comments
	hinting at certain insns being Intel-syntax ones where the ones
	actually meant are already gone.

opcodes/
2004-11-04 Jan Beulich <jbeulich@@novell.com>

	* i386-dis.c (Eq, Edqw, indirEp, Gdq, I1): Define.
	(indirEb): Remove.
	(Mp): Use f_mode rather than none at all.
	(t_mode, dq_mode, dqw_mode, f_mode, const_1_mode): Define. t_mode
	replaces what previously was x_mode; x_mode now means 128-bit SSE
	operands.
	(dis386): Make far jumps and calls have an 'l' prefix only in AT&T
	mode. movmskpX's, pextrw's, and pmovmskb's first operands are Gdq.
	pinsrw's second operand is Edqw.
	(grps): 1-bit shifts' and rotates' second operands are I1. cmpxchg8b's
	operand is Eq. movntq's and movntdq's first operands are EM. s[gi]dt,
	fldenv, frstor, fsave, fstenv all should also have suffixes in Intel
	mode when an operand size override is present or always suffixing.
	More instructions will need to be added to this group.
	(putop): Handle new macro chars 'C' (short/long suffix selector),
	'I' (Intel mode override for following macro char), and 'J' (for
	adding the 'l' prefix to far branches in AT&T mode). When an
	alternative was specified in the template, honor macro character when
	specified for Intel mode.
	(OP_E): Handle new *_mode values. Correct pointer specifications for
	memory operands. Consolidate output of index register.
	(OP_G): Handle new *_mode values.
	(OP_I): Handle const_1_mode.
	(OP_ESreg, OP_DSreg): Generate pointer specifications. Indicate
	respective opcode prefix bits have been consumed.
	(OP_EM, OP_EX): Provide some default handling for generating pointer
	specifications.
@
text
@d4804 7
a4810 3
      /* For some reason, the PE format does not store a section
	 address offset for a PC relative symbol.  */
      if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
a5384 5
#ifdef TE_PE
  if (S_IS_WEAK (fixp->fx_addsy))
    rel->addend = rel->address - (*rel->sym_ptr_ptr)->value + 4;
  else
#endif
@


1.158
log
@	* config/tc-i386.c (O_secrel): Delete.
	(tc_pe_dwarf2_emit_offset): New function.
	* config/tc-i386.h (O_secrel): Define as O_md1.
	(TC_DWARF2_EMIT_OFFSET): Define.
@
text
@d785 1
a785 1
  stackop_size = 'l';
d818 3
d1286 46
a1331 2
  if (mnemonic[0] == 'f' && mnemonic[1] == 'i')
    return 2;
d1333 1
a1333 4
  if (mnemonic[0] == 'f')
    return 1;

  return 0;
d1405 14
a1418 1
	i.suffix = 0;
d1640 3
d1663 1
a1663 1
	      if (intel_float_operand (mnemonic))
d2083 4
a2086 3
      && (!intel_syntax
	  || (!(t->opcode_modifier & IgnoreSize)
	      && ! intel_float_operand (t->name)))
d2101 1
a2101 5
	       && (t->opcode_modifier & IgnoreSize))
	  && !(intel_syntax
	       && t->base_opcode == 0xd9
	       && (t->extension_opcode == 5	     /* 0xd9,5 "fldcw"  */
		   || t->extension_opcode == 7)))  /* 0xd9,7 "f{n}stcw"  */
d2316 4
a2319 1
  else if ((i.tm.opcode_modifier & DefaultSize) && !i.suffix)
d2326 25
d2352 1
a2352 3
  /* Change the opcode based on the operand size given by i.suffix;
     We need not change things for byte insns.  */
  if (!i.suffix && (i.tm.opcode_modifier & W))
d2354 26
a2379 2
      as_bad (_("no instruction mnemonic suffix given and no register operands; can't size instruction"));
      return 0;
d2382 3
d2400 2
a2401 1
	  && !(i.tm.opcode_modifier & IgnoreSize)
d5450 1
a5450 1
    addOp		+ | - | & | \| | << | >>
d5454 2
d5460 1
a5460 1
    dataType		BYTE | WORD | DWORD | QWORD | XWORD
d5468 4
a5471 1
    e05			e05 addOp e06
d5478 2
a5493 1
			| ~
d5495 2
a5496 2
 => expr		SHORT e05
			| e05
d5508 1
a5508 1
    mulOp		* | / | MOD
d5518 1
a5518 1
    specialRegister	CR0 | CR2 | CR3
d5526 7
a5532 2
    expr	SHORT e05
		| e05
d5536 1
a5536 1
    e05'	addOp e06 e05'
d5545 2
d5563 1
d5565 3
a5567 1
		| XWORD
a5571 1
		| ~
d5605 5
a5609 3
#define	T_DWORD		5
#define T_QWORD		6
#define T_XWORD		7
d5611 6
a5616 5
#define T_SHORT		8
#define T_OFFSET	9
#define T_PTR		10
#define T_ID		11
#define T_SHIFTOP	12
d5623 2
d5668 6
d5676 1
a5676 1
      if (intel_parser.is_mem)
d5700 1
a5700 1
      else if (intel_parser.op_modifier == OFFSET_FLAT
d5711 2
a5712 2
/* expr	SHORT e05
	| e05  */
d5716 1
a5716 1
  /* expr  SHORT e05  */
d5719 1
a5719 1
      intel_parser.op_modifier = SHORT;
d5722 32
a5753 1
      return (intel_e05 ());
d5756 1
a5756 1
  /* expr  e05  */
d5758 1
a5758 1
    return intel_e05 ();
d5763 1
a5763 1
   e05'	addOp e06 e05'
d5774 2
a5775 4
  /* e05'  addOp e06 e05'  */
  if (cur_token.code == '+' || cur_token.code == '-'
      || cur_token.code == '&' || cur_token.code == '|'
      || cur_token.code == T_SHIFTOP)
d5777 5
a5781 1
      strcat (intel_parser.disp, cur_token.str);
d5806 19
a5824 1
  if (cur_token.code == '*' || cur_token.code == '/')
d5826 1
a5826 1
      strcat (intel_parser.disp, cur_token.str);
d5840 4
d5854 1
a5854 1
      intel_parser.op_modifier = OFFSET_FLAT;
d5860 13
d5884 2
d5887 1
a5887 1
	i.suffix = BYTE_MNEM_SUFFIX;
d5891 6
a5896 2
	  if (intel_parser.got_a_float == 2)	/* "fi..." */
	    i.suffix = SHORT_MNEM_SUFFIX;
d5898 1
a5898 1
	    i.suffix = WORD_MNEM_SUFFIX;
d5903 26
a5928 2
	  if (intel_parser.got_a_float == 1)	/* "f..." */
	    i.suffix = SHORT_MNEM_SUFFIX;
d5930 1
a5930 1
	    i.suffix = LONG_MNEM_SUFFIX;
d5936 1
a5936 1
	    i.suffix = LONG_MNEM_SUFFIX;
d5938 1
a5938 1
	    i.suffix = QWORD_MNEM_SUFFIX;
d5941 13
a5953 2
      else if (prev_token.code == T_XWORD)
	i.suffix = LONG_DOUBLE_MNEM_SUFFIX;
d5961 10
d5981 1
a5981 1
      if (intel_parser.op_modifier != OFFSET_FLAT)
d6013 1
a6013 1
      if (intel_parser.op_modifier != OFFSET_FLAT)
d6026 1
a6026 1
	  if (intel_parser.op_modifier == OFFSET_FLAT)
d6045 1
d6047 3
a6049 1
	| XWORD
a6053 1
	| ~
a6072 9
  /* e11 ~ expr */
  else if (cur_token.code == '~')
   {
     strcat (intel_parser.disp, "~");
     intel_match_token ('~');

     return (intel_e11 ());
   }

d6081 1
a6081 1
      if (intel_parser.op_modifier != OFFSET_FLAT)
d6087 2
a6088 4
      if (current_templates->start->opcode_modifier & Jump
	  || current_templates->start->opcode_modifier & JumpDword
	  || current_templates->start->opcode_modifier & JumpByte
	  || current_templates->start->opcode_modifier & JumpInterSegment)
d6099 1
a6099 1
	  if (intel_parser.op_modifier == OFFSET_FLAT)
d6111 1
d6113 3
a6115 1
	  | XWORD  */
d6119 1
d6121 2
a6122 1
	   || cur_token.code == T_XWORD)
d6131 1
a6131 1
  else if (cur_token.code == '$' || cur_token.code == '.')
d6138 1
a6138 1
      if (intel_parser.op_modifier != OFFSET_FLAT)
d6235 1
a6235 1
      else if (intel_parser.op_modifier == OFFSET_FLAT)
d6250 1
a6250 1
	  && intel_parser.op_modifier != OFFSET_FLAT)
a6265 1
      intel_match_token (T_ID);
d6268 9
a6276 3
	 preceded by an offset modifier.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;
d6278 1
a6443 16
  else if (strchr ("<>", *intel_parser.op_string)
	   && *intel_parser.op_string == *(intel_parser.op_string + 1))
    {
      new_token.code = T_SHIFTOP;
      new_token.str[0] = *intel_parser.op_string;
      new_token.str[1] = *intel_parser.op_string;
      new_token.str[2] = '\0';
    }

  else if (strchr ("+-/*&|:[]()~", *intel_parser.op_string))
    {
      new_token.code = *intel_parser.op_string;
      new_token.str[0] = *intel_parser.op_string;
      new_token.str[1] = '\0';
    }

d6468 2
a6469 2
	  new_token.code = *q;
	  new_token.str[0] = *q;
d6478 22
a6499 1
	  if (strcasecmp (new_token.str, "BYTE") == 0)
d6508 3
d6514 8
a6521 2
	  else if (strcasecmp (new_token.str, "XWORD") == 0)
	    new_token.code = T_XWORD;
d6549 16
@


1.157
log
@bfd/
	* config.bfd: Include 64-bit support for i[3-7]86-*-solaris2*.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): New function.
	(elf_backend_section_from_shdr): Define.
binutils/
	* readelf.c (get_x86_64_section_type_name): New function.
	(get_section_type_name): Use it.
gas/
	* config/tc-i386.c: Include "elf/x86-64.h".
	(i386_elf_section_type): New function.
	* config/tc-i386.h (md_elf_section_type): Define.
	(i386_elf_section_type): New prototype.
gas/testsuite/
	* gas/i386/i386.exp: Don't run divide test for targets where '/'
	is a comment.  Run x86-64-unwind for 64-bit ELF targets.
	* gas/i386/x86-64-unwind.d, gas/i386/x86-64-unwind.s: New.
include/
	* elf/common.h (PT_SUNW_EH_FRAME): Define.
	* elf/x86-64.h (SHT_X86_64_UNWIND): Define.
ld/
	* configure.tgt: Include elf_x86_64 for i[3-7]86-*-solaris2*.
@
text
@a3660 2
#define O_secrel (O_max + 1)

d6361 13
@


1.156
log
@For DefaultSize instructions, don't guess a 'q'	suffix if the instruction
doesn't support it.
@
text
@d36 1
d6352 11
@


1.155
log
@Corrections for x86_64 assembly.
@
text
@d2197 1
a2197 1
process_suffix ()
d2220 1
d2261 3
a2267 1

d2295 1
d2311 2
a2312 4
	{
	  if (i.tm.opcode_modifier & FloatMF)
	    i.tm.base_opcode ^= 4;
	}
d2319 1
a2319 1
check_byte_reg ()
d2322 1
@


1.154
log
@Add support for  & | << >> ~  arithmetic operators in Intel mode
@
text
@d1925 1
a1925 1
		i.types[op] = Imm32 | Imm64;
d1928 1
a1928 2
		i.types[op] = Imm16 | Imm32 | Imm64;
		break;
d1931 1
a1931 2
		i.types[op] = Imm8 | Imm8S | Imm16 | Imm32S | Imm32;
		break;
d2019 12
a2030 3
  for (t = current_templates->start;
       t < current_templates->end;
       t++)
d2514 1
a2514 1
  if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S))
d2743 1
a2743 15
		  if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
		      && (flag_code != CODE_64BIT))
		    {
		      i.rm.regmem = NO_BASE_REGISTER_16;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp16;
		    }
		  else if (flag_code != CODE_64BIT
			   || (i.prefix[ADDR_PREFIX] != 0))
		    {
		      i.rm.regmem = NO_BASE_REGISTER;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp32;
		    }
		  else
d2752 11
a2762 2
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp32S;
d2784 1
a2784 1
	      i.types[op] &= ~Disp;
d2787 2
d2824 2
a2825 6
		{
		  if (i.types[op] & Disp8)
		    i.types[op] = Disp8 | Disp32S;
		  else
		    i.types[op] = Disp32S;
		}
d4002 12
a4013 24
  if (flag_code == CODE_64BIT)
    {
      if (i.prefix[ADDR_PREFIX] == 0)
	{
	  /* 64bit checks.  */
	  if ((i.base_reg
	       && ((i.base_reg->reg_type & Reg64) == 0)
		   && (i.base_reg->reg_type != BaseIndex
		       || i.index_reg))
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg64 | BaseIndex))
		      != (Reg64 | BaseIndex))))
	    ok = 0;
	}
      else
	{
	  /* 32bit checks.  */
	  if ((i.base_reg
	       && (i.base_reg->reg_type & (Reg32 | RegRex)) != Reg32)
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
		      != (Reg32 | BaseIndex))))
	    ok = 0;
	}
d4046 1
a4046 2
      if (flag_code != CODE_64BIT
	  && i.prefix[ADDR_PREFIX] == 0 && stackop_size != '\0')
d4055 1
a4055 1
	  if (i.types[this_operand] & (Disp16 | Disp32))
a4067 1
      return 0;
d4069 1
a4069 1
  return 1;
d4893 1
a4893 1
      && (r->reg_flags & (RegRex64 | RegRex)) != 0
d4895 1
a4895 3
    {
      return (const reg_entry *) NULL;
    }
@


1.153
log
@2004-07-04  Aaron W. LaFramboise <aaron98wiridge9@@aaronwl.com>

* bfd/cofflink.c (_bfd_coff_generic_relocate_section): Resolve PE weak
externals properly.
* src/gas/config/obj-coff.c (obj_coff_weak): New .weak syntax for PE weak
externals.
* binutils/doc/binutils.texi (nm): Clarify weak symbol description.
* gas/config/tc-i386.c (tc_gen_reloc): Use addend for weak symbols in TE_PE.
* gas/doc/as.texinfo (Weak): Document PE weak symbols.
* ld/ld.texinfo (WIN32): Document PE weak symbols.
@
text
@d1479 1
a1479 1
		as_bad (_("can't encode register '%%%s' in an instruction requiring REX prefix.\n"),
d5353 1
a5353 1
    addOp		+ | -
d5390 1
d5459 1
d5501 1
d5621 3
a5623 1
  if (cur_token.code == '+' || cur_token.code == '-')
d5725 1
a5725 1
	  as_bad (_("Unknown operand modifier `%s'\n"), prev_token.str);
d5809 1
d5829 9
d5983 1
a5983 1
	      as_bad (_("Too many register references in memory operand.\n"));
d6052 1
a6052 1
	      as_bad (_("Syntax error. Expecting a constant. Got `%s'.\n"),
d6139 1
a6139 1
      as_bad (_("Unexpected token `%s'\n"), cur_token.str);
d6200 10
a6209 1
  else if (strchr ("+-/*:[]()", *intel_parser.op_string))
d6292 1
a6292 1
    as_bad (_("Unrecognized token `%s'\n"), intel_parser.op_string);
@


1.152
log
@* config/tc-i386.c: Deal with LEX_QM the same way as with LEX_AT.
* config/te-netware.h: New file.
* config/te-ppcnw.h: Delete: Obsolete.
* configure.in: Eliminate ill NetWare targets. Make generic
  NetWare target use proper emulation.
* Makefile.am: Eliminate reference to obsolete te-ppcnw.h, add
  reference to new te-netware.h.
* configure: Regenerate.
* Makefile.in: Regenerate.
@
text
@d5283 6
@


1.151
log
@Add support for a .secrel32 x86 reloc to allow DWARF" debug information to used
with COFF based x86 ports.
@
text
@d185 1
d187 4
a190 3
const char extra_symbol_chars[] = "*%-(@@[";
#else
const char extra_symbol_chars[] = "*%-([";
d192 1
d197 1
d979 4
@


1.150
log
@2004-03-12  Michal Ludvig  <mludvig@@suse.cz>

	* gas/config/tc-i386.c (output_insn): Handle PadLock instructions.
	* gas/config/tc-i386.h (CpuPadLock): New define.
	(CpuUnknownFlags): Added CpuPadLock.
	* include/opcode/i386.h (i386_optab): Added xstore/xcrypt insns.
	* opcodes/i386-dis.c (PADLOCK_SPECIAL, PADLOCK_0): New defines.
	(dis386_twobyte): Opcode 0xa7 is PADLOCK_0.
	(padlock_table): New struct with PadLock instructions.
	(print_insn): Handle PADLOCK_SPECIAL.
@
text
@d79 3
d450 3
d3647 44
d5218 3
@


1.149
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d26 1
a3126 1

d3154 17
a3170 4
      /* All opcodes on i386 have either 1 or 2 bytes.  We may use third
	 byte for the SSE instructions to specify a prefix they require.  */
      if (i.tm.base_opcode & 0xff0000)
	add_prefix ((i.tm.base_opcode >> 16) & 0xff);
d3191 8
a3198 1
	  p = frag_more (2);
@


1.149.6.1
log
@2004-03-12  Michal Ludvig  <mludvig@@suse.cz>

	* gas/config/tc-i386.c (output_insn): Handle PadLock instructions.
	* gas/config/tc-i386.h (CpuPadLock): New define.
	(CpuUnknownFlags): Added CpuPadLock.
	* include/opcode/i386.h (i386_optab): Added xstore/xcrypt insns.
	* opcodes/i386-dis.c (PADLOCK_SPECIAL, PADLOCK_0): New defines.
	(dis386_twobyte): Opcode 0xa7 is PADLOCK_0.
	(padlock_table): New struct with PadLock instructions.
	(print_insn): Handle PADLOCK_SPECIAL.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
a25 1
   VIA PadLock support by Michal Ludvig (mludvig@@suse.cz)
d3126 1
d3154 4
a3157 17
      /* All opcodes on i386 have either 1 or 2 bytes, PadLock instructions
	 have 3 bytes.  We may use one more higher byte to specify a prefix
	 the instruction requires.  */
      if ((i.tm.cpu_flags & CpuPadLock) != 0
	  && (i.tm.base_opcode & 0xff000000) != 0)
        {
	  unsigned int prefix;
	  prefix = (i.tm.base_opcode >> 24) & 0xff;

	  if (prefix != REPE_PREFIX_OPCODE
	      || i.prefix[LOCKREP_PREFIX] != REPE_PREFIX_OPCODE)
	    add_prefix (prefix);
	}
      else
	if ((i.tm.cpu_flags & CpuPadLock) == 0
	    && (i.tm.base_opcode & 0xff0000) != 0)
	  add_prefix ((i.tm.base_opcode >> 16) & 0xff);
d3178 1
a3178 8
	  if ((i.tm.cpu_flags & CpuPadLock) != 0)
	    {
	      p = frag_more (3);
	      *p++ = (i.tm.base_opcode >> 16) & 0xff;
	    }
	  else
	    p = frag_more (2);

@


1.148
log
@	* config/tc-hppa.c: Fix comment typos.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-iq2000.h: Likewise.
@
text
@d1382 1
a1382 1
	  /* These Intel Precott New Instructions have the fixed
@


1.147
log
@2003-11-11  Jan Hubicka  <jh@@suse.cz>

	* config/tc-i386.c (tc_i386_fix_adjustable):
@
text
@d242 1
a242 1
/* All non-digit non-letter charcters that may occur in an operand.  */
d4635 1
a4635 1
     and we must not dissappoint it.  */
@


1.146
log
@	* config/tc-i386.h: Remove BFD_ASSEMBLER tests and all !BFD_ASSEMBLER
	code.
	* config/tc-i386.c: Likewise.
	(RELOC_ENUM): Don't define.  Replace throughout with enum.
@
text
@d1228 6
@


1.145
log
@	* config/tc-i386.c (i386_intel_operand): Always call i386_index_check
	for memory operands.  Pass the full operand_string to i386_index_check.
@
text
@a51 6
#ifdef BFD_ASSEMBLER
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
#endif

d152 1
a152 1
    RELOC_ENUM reloc[MAX_OPERANDS];
d802 2
a803 9
    {
#ifdef BFD_ASSEMBLER
      allow_naked_reg = (intel_syntax
			 && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
#else
      /* Conservative default.  */
      allow_naked_reg = 0;
#endif
    }
a857 1
#ifdef BFD_ASSEMBLER
a867 1
#endif
a1159 1
#ifdef BFD_ASSEMBLER
a1253 28
#else
#define reloc(SIZE,PCREL,SIGN,OTHER)	0
#define BFD_RELOC_8			0
#define BFD_RELOC_16			0
#define BFD_RELOC_32			0
#define BFD_RELOC_8_PCREL		0
#define BFD_RELOC_16_PCREL		0
#define BFD_RELOC_32_PCREL		0
#define BFD_RELOC_386_PLT32		0
#define BFD_RELOC_386_GOT32		0
#define BFD_RELOC_386_GOTOFF		0
#define BFD_RELOC_386_TLS_GD		0
#define BFD_RELOC_386_TLS_LDM		0
#define BFD_RELOC_386_TLS_LDO_32	0
#define BFD_RELOC_386_TLS_IE_32		0
#define BFD_RELOC_386_TLS_IE		0
#define BFD_RELOC_386_TLS_GOTIE		0
#define BFD_RELOC_386_TLS_LE_32		0
#define BFD_RELOC_386_TLS_LE		0
#define BFD_RELOC_X86_64_PLT32		0
#define BFD_RELOC_X86_64_GOT32		0
#define BFD_RELOC_X86_64_GOTPCREL	0
#define BFD_RELOC_X86_64_TLSGD		0
#define BFD_RELOC_X86_64_TLSLD		0
#define BFD_RELOC_X86_64_DTPOFF32	0
#define BFD_RELOC_X86_64_GOTTPOFF	0
#define BFD_RELOC_X86_64_TPOFF32	0
#endif
d1778 1
a1778 1
  RELOC_ENUM temp_reloc;
d3252 1
a3252 1
	      RELOC_ENUM reloc_type;
a3295 1
#ifdef BFD_ASSEMBLER
a3325 1
#endif
d3370 1
a3370 1
	      RELOC_ENUM reloc_type;
d3388 1
a3388 1
#ifdef BFD_ASSEMBLER
a3460 1
#endif
d3469 1
a3469 1
static char *lex_got PARAMS ((RELOC_ENUM *, int *));
d3482 1
a3482 1
     RELOC_ENUM *reloc;
d3488 1
a3488 1
    const RELOC_ENUM rel[NUM_FLAG_CODE];
d3566 1
a3566 1
static RELOC_ENUM got_reloc = NO_RELOC;
d3575 1
a3575 1
  RELOC_ENUM r = reloc (len, 0, 0, got_reloc);
d3681 1
a3681 4
  else if (1
#ifdef BFD_ASSEMBLER
	   && OUTPUT_FLAVOR == bfd_target_aout_flavour
#endif
d3687 1
a3687 4
#ifdef BFD_ASSEMBLER
	   && !bfd_is_com_section (exp_seg)
#endif
	   )
a3688 1
#ifdef BFD_ASSEMBLER
a3689 3
#else
      as_bad (_("unimplemented segment type %d in operand"), exp_seg);
#endif
a3845 1
#ifdef BFD_ASSEMBLER
a3870 1
#endif
a3884 1
#ifdef BFD_ASSEMBLER
a3885 1
#endif
d3891 1
a3891 4
#ifdef BFD_ASSEMBLER
      && !bfd_is_com_section (exp_seg)
#endif
      )
a3892 1
#ifdef BFD_ASSEMBLER
a3893 3
#else
      as_bad (_("unimplemented segment type %d in operand"), exp_seg);
#endif
d4322 1
a4322 1
      RELOC_ENUM reloc_type;
a4420 7
#ifndef BFD_ASSEMBLER
void
md_convert_frag (headers, sec, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
#else
a4425 1
#endif
d4564 1
a4564 1
#if defined (BFD_ASSEMBLER) && !defined (TE_Mach)
d4675 1
a4675 1
#endif /* defined (BFD_ASSEMBLER) && !defined (TE_Mach)  */
a4679 1
#ifdef BFD_ASSEMBLER
d4687 1
a4687 1
#endif
a4930 1
#ifdef BFD_ASSEMBLER
a5011 1
#endif /* BFD_ASSEMBLER  */
a5040 1
#ifdef BFD_ASSEMBLER
a5054 1
#endif
a5084 2
#ifdef BFD_ASSEMBLER

a5243 67
#else /* !BFD_ASSEMBLER  */

#if (defined(OBJ_AOUT) | defined(OBJ_BOUT))
void
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  /* In:  length of relocation (or of address) in chars: 1, 2 or 4.
     Out: GNU LD relocation length code: 0, 1, or 2.  */

  static const unsigned char nbytes_r_length[] = { 42, 0, 1, 42, 2 };
  long r_symbolnum;

  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
		      (valueT) (fixP->fx_frag->fr_address
				+ fixP->fx_where - segment_address_in_file),
		      4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  where[6] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[4] = r_symbolnum & 0x0ff;
  where[7] = ((((!S_IS_DEFINED (fixP->fx_addsy)) << 3) & 0x08)
	      | ((nbytes_r_length[fixP->fx_size] << 1) & 0x06)
	      | (((fixP->fx_pcrel << 0) & 0x01) & 0x0f));
}

#endif /* OBJ_AOUT or OBJ_BOUT.  */

#if defined (I386COFF)

short
tc_coff_fix2rtype (fixP)
     fixS *fixP;
{
  if (fixP->fx_r_type == R_IMAGEBASE)
    return R_IMAGEBASE;

  return (fixP->fx_pcrel ?
	  (fixP->fx_size == 1 ? R_PCRBYTE :
	   fixP->fx_size == 2 ? R_PCRWORD :
	   R_PCRLONG) :
	  (fixP->fx_size == 1 ? R_RELBYTE :
	   fixP->fx_size == 2 ? R_RELWORD :
	   R_DIR32));
}

int
tc_coff_sizemachdep (frag)
     fragS *frag;
{
  if (frag->fr_next)
    return (frag->fr_next->fr_address - frag->fr_address);
  else
    return 0;
}

#endif /* I386COFF  */

#endif /* !BFD_ASSEMBLER  */
@


1.144
log
@* config/tc-i386.c (tc_x86_regname_to_dw2regnum): Use ARRAY_SIZE
  macro to compute size of selected register name array.
@
text
@d1420 1
a1420 1
          /* These Intel Precott New Instructions have the fixed
d1426 1
a1426 1
	  for (x = 0; x < i.operands; x++) 
d5624 3
a5626 2
		ret = i386_displacement (s, s + strlen (s))
		      && i386_index_check (s);
@


1.143
log
@2003-06-26  H.J. Lu <hongjiu.lu@@intel.com>

	* config/tc-i386.c (md_assemble): Declare "exp" before "if".
@
text
@d6369 1
a6369 1
      regnames_count = sizeof (regnames_64);
d6374 1
a6374 1
      regnames_count = sizeof (regnames_32);
@


1.142
log
@gas/

2003-06-23  H.J. Lu <hongjiu.lu@@intel.com>

	* gas/config/tc-i386.c (md_assemble): Support Intel Precott New
	Instructions.

	* gas/config/tc-i386.h (CpuPNI): New.
	(CpuUnknownFlags): Add CpuPNI.

gas/testsuite/

2003-06-23  H.J. Lu <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Add prescott.

	* gas/i386/prescott.d: New file.
	* gas/i386/prescott.s: Likewise.

include/opcode/

2003-06-23  H.J. Lu <hongjiu.lu@@intel.com>

	* i386.h (i386_optab): Support Intel Precott New Instructions.

opcodes/

2003-06-23  H.J. Lu <hongjiu.lu@@intel.com>

	* i386-dis.c (PNI_Fixup): New. Fix up "mwait" and "monitor" in
	Intel Precott New Instructions.
	(PREGRP27): New. Added for "addsubpd" and "addsubps".
	(PREGRP28): New. Added for "haddpd" and "haddps".
	(PREGRP29): New. Added for "hsubpd" and "hsubps".
	(PREGRP30): New. Added for "movsldup" and "movddup".
	(PREGRP31): New. Added for "movshdup" and "movhpd".
	(PREGRP32): New. Added for "lddqu".
	(dis386_twobyte): Use PREGRP30 to replace the "movlpX" entry.
	Use PREGRP31 to replace the "movhpX" entry. Use PREGRP28 for
	entry 0x7c. Use PREGRP29 for entry 0x7d. Use PREGRP27 for
	entry 0xd0. Use PREGRP32 for entry 0xf0.
	(twobyte_has_modrm): Updated.
	(twobyte_uses_SSE_prefix): Likewise.
	(grps): Use PNI_Fixup in the "sidtQ" entry.
	(prefix_user_table): Add PREGRP27, PREGRP28, PREGRP29, PREGRP30,
	PREGRP31 and PREGRP32.
	(float_mem): Use "fisttp{l||l|}" in entry 1 in opcode 0xdb.
	Use "fisttpll" in entry 1 in opcode 0xdd.
	Use "fisttp" in entry 1 in opcode 0xdf.
@
text
@d1416 2
a1436 2

      expressionS *exp;
@


1.141
log
@2003-06-09  H.J. Lu <hongjiu.lu@@intel.com>

	* NEWS: Updated for the new -n option for the i386 assembler.

	* config/tc-i386.c (optimize_align_code): New.
	(md_shortopts): Add 'n'.
	(md_parse_option): Handle 'n'.
	(md_show_usage): Add '-n'.

	* config/tc-i386.h (optimize_align_code): Declared.
	(md_do_align): Optimize code alignment only if optimize_align_code
	is not 0.

	* doc/as.texinfo: Add the new -n option.

	* doc/c-i386.texi: Document the new -n option.
@
text
@d1416 15
@


1.140
log
@        * dw2gencfi.c, dw2gencfi.h: Rewrite from scratch.
        * as.c (main): Always call cfi_finish.
        * config/tc-i386.c (x86_dwarf2_return_column): New.
        (x86_cie_data_alignment): New.
        (md_begin): Set them.
        (tc_x86_cfi_init): Remove.
        (tc_x86_regname_to_dw2regnum): Fix 32-bit register numbers;
        return int, not unsigned long; don't as_bad here.
        (tc_x86_frame_initial_instructions): Streamline; use
        updated api.
        * config/tc-i386.h (tc_cfi_init): Remove.
        (DWARF2_DEFAULT_RETURN_COLUMN): New.
        (DWARF2_CIE_DATA_ALIGNMENT): New.

        * gas/cfi/cfi-i386.d: Update for dw2gencfi rewrite.
        * gas/cfi/cfi-x86_64.d: Likewise.
        * gas/cfi/cfi-i386-2.d: New.
        * gas/cfi/cfi-i386-2.s: New.
@
text
@d306 3
d4895 1
a4895 1
const char *md_shortopts = "kVQ:sq";
d4897 1
a4897 1
const char *md_shortopts = "q";
d4918 4
d4983 1
d4988 1
@


1.139
log
@	* dw2gencfi.c, dw2gencfi.h: New files.
	* config/tc-i386.c (tc_x86_cfi_init): New function.
	* config/tc-i386.h (TARGET_USE_CFIPOP, tc_cfi_init): New defines.
	* as.c (parse_args): Set verbose flag on --verbose.
	(main): Call tc_cfi_init()/cfi_finish().
	* as.h (verbose): New external variable.
	* read.c (pobegin): Insert CFI pops to the list.
	* symbols.c (local_symbol_make): Make symbol external.
	* symbols.h (local_symbol_make): New prototype.
	* Makefile.am: Add dw2gencfi.[ch] files.  Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/as.texinfo: Added node "CFI directives" with description of
	all implemented .cfi_* directives.
	* doc/Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d322 6
d996 11
d6321 1
a6321 28
void
tc_x86_cfi_init (void)
{
  struct cfi_config cfi_config;

  if (flag_code == CODE_64BIT)
    {
      cfi_config.addr_length = 8;
      cfi_config.eh_align = 8;
      cfi_config.code_align = 1;
      cfi_config.data_align = -8;
      cfi_config.ra_column = 0x10;
      cfi_config.reloc_type = BFD_RELOC_64;
    }
  else
    {
      cfi_config.addr_length = 4;
      cfi_config.eh_align = 4;
      cfi_config.code_align = 1;
      cfi_config.data_align = -4;
      cfi_config.ra_column = 0x08;
      cfi_config.reloc_type = BFD_RELOC_32;
    }

  cfi_set_config (&cfi_config);
}

unsigned long
d6328 2
a6329 2
      "eax", "ebx", "ecx", "edx",
      "edi", "esi", "ebp", "esp",
a6356 1
  as_bad (_("unknown register name '%s'"), regname);
d6363 8
a6370 10
  if (flag_code == CODE_64BIT)
    {
      cfi_add_insn (CFA_def_cfa, tc_x86_regname_to_dw2regnum ("rsp"), 8);
      cfi_add_insn (CFA_offset, tc_x86_regname_to_dw2regnum ("rip"), -8);
    }
  else
    {
      cfi_add_insn (CFA_def_cfa, tc_x86_regname_to_dw2regnum ("esp"), 4);
      cfi_add_insn (CFA_offset, tc_x86_regname_to_dw2regnum ("eip"), -4);
    }
@


1.138
log
@line_comment_chars: Add '#'.  This makes the assembler's handling of
# <linenum> "<filename>" directives work.
@
text
@d33 1
d6302 82
@


1.137
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d210 1
a210 1
const char line_comment_chars[] = "";
d218 1
a218 1
const char line_comment_chars[] = "/";
@


1.136
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d4650 1
a4650 1
	      && !S_FORCE_RELOC (fixP->fx_addsy))
a5146 11
}

bfd_boolean
i386_force_relocation (fixp)
     fixS *fixp;
{
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  return S_FORCE_RELOC (fixp->fx_addsy);
@


1.135
log
@	* symbols.c (S_SET_THREAD_LOCAL): New function.
	* symbols.h (S_SET_THREAD_LOCAL): New prototype.
	* config/tc-i386.c (md_apply_fix3): Call S_SET_THREAD_LOCAL
	for TLS relocations.
	* config/tc-ia64.c (md_apply_fix3): Likewise.
	* config/tc-alpha.c (md_apply_fix3): Likewise.

	* ld-i386/tlsnopic.rd: Change NOTYPE to TLS for UND sg* symbols.
@
text
@d5149 1
a5149 1
boolean
@


1.134
log
@	* config/tc-i386.c (output_jump): Set fx_signed for loop/jcxz.
	(md_estimate_size_before_relax): Likewise for 8 bit branches.
@
text
@a4681 1
      case BFD_RELOC_386_GOT32:
a4686 1
      case BFD_RELOC_X86_64_GOT32:
d4690 12
@


1.133
log
@bfd/
	* reloc.c: Add x86-64 TLS relocs.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf64-x86-64.c (x86_64_elf_howto): Fix size fields for 32-bit
	relocs.  Add TLS relocs.
	(x86_64_reloc_map): Add TLS relocs.
	(elf64_x86_64_info_to_howto): Adjust for added TLS relocs.
	(struct elf64_x86_64_link_hash_entry): Add tls_type field.
	(GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE): Define.
	(elf64_x86_64_hash_entry): Define.
	(struct elf64_x86_64_obj_tdata): New.
	(elf64_x86_64_tdata, elf64_x86_64_local_got_tls_type): Define.
	(struct elf64_x86_64_link_hash_table): Add tls_ld_got.
	(link_hash_newfunc): Initialize tls_type.
	(elf64_x86_64_link_hash_table_create): Initialize tls_ld_got.
	(elf64_x86_64_copy_indirect_symbol): Swap tls_type if necessary.
	(elf64_x86_64_mkobject): New.
	(elf64_x86_64_elf_object_p): Allocate struct elf64_x86_64_obj_tdata.
	(elf64_x86_64_tls_transition): New.
	(elf64_x86_64_check_relocs): Add r_type variable and use it.
	Handle TLS relocs.
	(elf64_x86_64_gc_sweep_hook): Handle TLS relocs.
	(allocate_dynrelocs): Allocate GOT space for TLS relocs.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(dtpoff_base, tpoff): New.
	(elf64_x86_64_relocate_section): Handle TLS relocs.
	(elf64_x86_64_finish_dynamic_symbol): Only handle non-TLS GOT
	entries.
	(bfd_elf64_mkobject): Define.

	* elf32-i386.c (elf_i386_check_relocs) [R_386_TLS_LE]: Set
	DF_STATIC_TLS if shared.
gas/
	* config/tc-i386.c (tc_i386_fix_adjustable): Add x86-64 TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Handle @@tlsgd, @@dtpoff and @@tpoff in 64-bit mode, add
	@@tlsld.
	(md_apply_fix3): No addend for BFD_RELOC_X86_64_TLSGD,
	BFD_RELOC_X86_64_TLSLD and BFD_RELOC_X86_64_GOTTPOFF.
	(tc_gen_reloc): Handle x86-64 TLS relocs.
include/
	* elf/x86-64.h: Add TLS relocs.
ld/testsuite/
	* lib/ld-lib.exp (run_ld_link_tests): Add.
	* ld-sh/sh64/sh64.exp (run_ld_link_tests, regexp_diff,
	file_contents): Remove.
	(sh64tests): Add 6th field to the tests array.
	* ld-i386/i386.exp (run_ld_link_tests): Remove.
	* ld-x86-64/x86-64.exp: New.
	* ld-x86-64/tlsbin.dd: New test.
	* ld-x86-64/tlsbinpic.s: New test.
	* ld-x86-64/tlsbin.rd: New test.
	* ld-x86-64/tlsbin.s: New test.
	* ld-x86-64/tlsbin.sd: New test.
	* ld-x86-64/tlsbin.td: New test.
	* ld-x86-64/tlslib.s: New test.
	* ld-x86-64/tlspic1.s: New test.
	* ld-x86-64/tlspic2.s: New test.
	* ld-x86-64/tlspic.dd: New test.
	* ld-x86-64/tlspic.rd: New test.
	* ld-x86-64/tlspic.sd: New test.
	* ld-x86-64/tlspic.td: New test.
@
text
@d3003 1
d3054 8
a3061 2
  fix_new_exp (frag_now, p - frag_now->fr_literal, size,
	       i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
d4404 2
d4407 5
a4411 4
	      fix_new (fragP, old_fr_fix, 1,
		       fragP->fr_symbol,
		       fragP->fr_offset, 1,
		       BFD_RELOC_8_PCREL);
@


1.132
log
@	* config/tc-i386.c (process_operands): Warn about "lea" segment
	overrides.
@
text
@d1238 5
d1271 5
d3497 1
a3497 1
    { "TLSGD",    { BFD_RELOC_386_TLS_GD,     0, 0                         } },
d3499 3
a3501 2
    { "GOTTPOFF", { BFD_RELOC_386_TLS_IE_32,  0, 0                         } },
    { "TPOFF",    { BFD_RELOC_386_TLS_LE_32,  0, 0                         } },
d3503 1
a3503 1
    { "DTPOFF",   { BFD_RELOC_386_TLS_LDO_32, 0, 0                         } },
d4679 3
d5166 5
d5248 3
@


1.131
log
@	* config/tc-i386.c (md_apply_fix3): Replace S_IS_EXTERNAL,
	S_IS_WEAK etc. with S_FORCE_RELOC call.  Correct comment.
	Rename "fseg" to "sym_seg".
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
@
text
@d2607 2
a2608 3
	 must be put into the modrm byte).
	 Now, we make the modrm & index base bytes based on all the
	 info we've collected.  */
d2635 8
a2642 6
  /* If a segment was explicitly specified,
     and the specified segment is not the default,
     use an opcode prefix to select it.
     If we never figured out what the default segment is,
     then default_seg will be zero at this point,
     and the specified segment prefix will always be used.  */
@


1.130
log
@bfd/
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.
gas/
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.
gas/testsuite/
	* gas/i386/tlspic.s: Add tests.
	* gas/i386/tlspic.d: Regenerated.
	* gas/i386/tlsnopic.s: Add tests.
	* gas/i386/tlsnopic.d: Regenerated.
include/
	* elf/i386.h (R_386_TLS_TPOFF, R_386_TLS_IE, R_386_TLS_GOTIE):
	Define.
ld/testsuite/
	* ld-i386/i386.exp: New.
	* ld-i386/tlsbin.dd: New test.
	* ld-i386/tlsbinpic.s: New test.
	* ld-i386/tlsbin.rd: New test.
	* ld-i386/tlsbin.s: New test.
	* ld-i386/tlsbin.sd: New test.
	* ld-i386/tlsbin.td: New test.
	* ld-i386/tlslib.s: New test.
	* ld-i386/tlsnopic1.s: New test.
	* ld-i386/tlsnopic2.s: New test.
	* ld-i386/tlsnopic.dd: New test.
	* ld-i386/tlsnopic.rd: New test.
	* ld-i386/tlsnopic.sd: New test.
	* ld-i386/tlspic1.s: New test.
	* ld-i386/tlspic2.s: New test.
	* ld-i386/tlspic.dd: New test.
	* ld-i386/tlspic.rd: New test.
	* ld-i386/tlspic.sd: New test.
	* ld-i386/tlspic.td: New test.
@
text
@d4623 1
a4623 1
	  segT fseg = S_GET_SEGMENT (fixP->fx_addsy);
d4625 1
a4625 1
	  if ((fseg == seg
d4627 2
a4628 5
		   && fseg != absolute_section))
	      && !S_IS_EXTERNAL (fixP->fx_addsy)
	      && !S_IS_WEAK (fixP->fx_addsy)
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && !S_IS_COMMON (fixP->fx_addsy))
d4631 2
a4632 2
		 bfd_perform_relocation subtracts them out again.  I think
		 bfd_perform_relocation is broken, but I don't dare change
@


1.129
log
@2002-09-16  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.

	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".

	* emulparams/elf_i386_fbsd.sh: Set OUTPUT_FORMAT to
	elf32-i386-freebsd.
	* emulparams/elf64alpha_fbsd.sh: Set OUTPUT_FORMAT to
	elf64-alpha-freebsd.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20020715021113.GJ30362@@bubble.sa.bigpond.net.au>
@
text
@d1231 2
d1259 2
d3492 2
d4667 2
d5149 2
@


1.128
log
@	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.
@
text
@d4956 1
a4956 1
	return flag_code == CODE_64BIT ? "elf64-x86-64" : "elf32-i386";
@


1.127
log
@gas reloc rewrite.
@
text
@a4659 1
      case BFD_RELOC_386_TLS_LDO_32:
a4660 2
      case BFD_RELOC_386_TLS_LE_32:
      case BFD_RELOC_386_TLS_LE:
@


1.126
log
@	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.
@
text
@d1216 5
a1220 9
  /* Prevent all adjustments to global symbols, or else dynamic
     linking will not work correctly.  */
  if (S_IS_EXTERNAL (fixP->fx_addsy)
      || S_IS_WEAK (fixP->fx_addsy)
      /* Don't adjust pc-relative references to merge sections in 64-bit
	 mode.  */
      || (use_rela_relocations
	  && (S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0
	  && fixP->fx_pcrel))
d4596 1
a4596 1
  if (fixP->fx_pcrel
d5110 11
@


1.125
log
@	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.
	* testsuite/gas/i386/gotpc.s: New.
	* testsuite/gas/i386/gotpc.d: New.
	* testsuite/gas/i386/i386.exp: Add gotpc test.
@
text
@d1210 1
a1210 1
     fixS *fixP;
d1213 3
d1226 1
a1226 1
#endif
d1243 1
d3675 1
d3890 1
d3894 5
a3898 1
      && exp_seg != undefined_section)
d4324 3
a4326 2
      || S_IS_EXTERNAL (fragP->fr_symbol)
      || S_IS_WEAK (fragP->fr_symbol)
d4600 10
a4609 9
  /* This is a hack.  There should be a better way to handle this.
     This covers for the fact that bfd_install_relocation will
     subtract the current location (for partial_inplace, PC relative
     relocations); see more below.  */
  if ((fixP->fx_r_type == BFD_RELOC_32_PCREL
       || fixP->fx_r_type == BFD_RELOC_16_PCREL
       || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && fixP->fx_addsy && !use_rela_relocations)
    {
d4660 1
a4669 3
	break;
      case BFD_RELOC_386_GOTOFF:
      case BFD_RELOC_X86_64_GOTPCREL:
@


1.124
log
@
	* tc-i386.c (i386_align_code): Implement x86_64 neutral code fillers.
@
text
@d107 4
a110 2
static void output_imm PARAMS ((void));
static void output_disp PARAMS ((void));
d3106 1
d3110 3
d3118 3
d3191 1
a3191 1
	output_disp ();
d3194 1
a3194 1
	output_imm ();
d3206 3
a3208 1
output_disp ()
d3238 1
d3281 33
d3315 1
a3315 2
			   i.op[n].disps, pcrel,
			   reloc (size, pcrel, sign, i.reloc[n]));
d3322 3
a3324 1
output_imm ()
d3377 42
d3428 15
d3447 1
a3447 1
		  i.op[n].imms->X_add_number += 3;
a4646 42
	break;
      case BFD_RELOC_386_GOTPC:

/*   This is tough to explain.  We end up with this one if we have
 * operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal
 * here is to obtain the absolute address of the GOT, and it is strongly
 * preferable from a performance point of view to avoid using a runtime
 * relocation for this.  The actual sequence of instructions often look
 * something like:
 *
 *	call	.L66
 * .L66:
 *	popl	%ebx
 *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
 *
 *   The call and pop essentially return the absolute address of
 * the label .L66 and store it in %ebx.  The linker itself will
 * ultimately change the first operand of the addl so that %ebx points to
 * the GOT, but to keep things simple, the .o file must have this operand
 * set so that it generates not the absolute address of .L66, but the
 * absolute address of itself.  This allows the linker itself simply
 * treat a GOTPC relocation as asking for a pcrel offset to the GOT to be
 * added in, and the addend of the relocation is stored in the operand
 * field for the instruction itself.
 *
 *   Our job here is to fix the operand so that it would add the correct
 * offset so that %ebx would point to itself.  The thing that is tricky is
 * that .-.L66 will point to the beginning of the instruction, so we need
 * to further modify the operand so that it will point to itself.
 * There are other cases where you have something like:
 *
 *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
 *
 * and here no correction would be required.  Internally in the assembler
 * we treat operands of this form as not being pcrel since the '.' is
 * explicitly mentioned, and I wonder whether it would simplify matters
 * to do it this way.  Who knows.  In earlier versions of the PIC patches,
 * the pcrel_adjust field was used to store the correction, but since the
 * expression is not pcrel, I felt it would be confusing to do it this
 * way.  */

	value -= 1;
@


1.123
log
@	* config/tc-i386.c (process_suffix): Merge CODE_64BIT JumpByte
	case with non CODE_64BIT case.  Don't warn on "qword ptr" if
	not CODE_64BIT.
@
text
@d524 5
a528 2
  /* ??? We can't use these fillers for x86_64, since they often kills the
     upper halves.  Solve later.  */
d530 6
a535 1
    count = 1;
d537 7
a543 3
  if (count > 0 && count <= 15)
    {
      if (flag_code == CODE_16BIT)
d545 3
a547 5
	  memcpy (fragP->fr_literal + fragP->fr_fix,
		  f16_patt[count - 1], count);
	  if (count > 8)
	    /* Adjust jump offset.  */
	    fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
d549 4
a552 1
      else
d554 9
a562 3
		f32_patt[count - 1], count);
      fragP->fr_var = count;
    }
@


1.123.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* write.c: Delete set_segment_vma and prototype. Update all callers.

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.

	2002-09-16  Chris Demetriou  <cgd@@broadcom.com>
	* config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
	(IS_SEXT_16BIT_NUM): New macro.
	(macro_build_ldst_constoffset): New function, to build a set of
	instructions to do a load or store from a constant offset relative
	to a given register.
	(macro, s_cprestore): Use macro_build_ldst_constoffset to implement
	.cprestore pseudo-op.

	2002-09-16  Elias Athanasopoulos  <eathan@@otenet.gr>
	* dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
	(out_debug_info): Likewise.

	2002-09-13  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_assemble): Do not count FAKE operands
	when deciding if any operands have been skipped.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-09-04  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_begin): Do not insert non-BookE32
	instructions into the hash table if the target cpu is the BookE32.

	2002-08-20  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
	by zero.

	2002-08-15  Alexandre Oliva  <aoliva@@redhat.com>
	* config/tc-mips.c (macro_build_jalr): Make sure we generate
	the fix-up against on the right frag.
	(s_cpsetup): Likewise.  Parse third argument as expression, to
	handle global symbols and forward/backward labels correctly.

	2002-08-14  Nick Clifton  <nickc@@redhat.com>
	* read.c (stringer): Catch attempts to create strings in the abs
	section.

	2002-08-12  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

	2002-08-10  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.

	2002-08-06  George France <france@@handhelds.org>
	* config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
	and m21264b processor names and cpu types.
	* doc/c-alpha.texi: Documented new types.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.

	2002-08-03  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.

	2002-07-31  Momchil Velikov  <velco@@fadata.bg>
	* config/tc-v850.c (md_assemble): Fix range check for immediate
	operand.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".
@
text
@d107 2
a108 4
static void output_imm PARAMS ((fragS *insn_start_frag,
				offsetT insn_start_off));
static void output_disp PARAMS ((fragS *insn_start_frag,
				 offsetT insn_start_off));
d1189 1
a1189 1
     fixS *fixP ATTRIBUTE_UNUSED;
a1191 3
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
    return 1;

d1202 1
a1202 1

a1210 2
      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE
      || fixP->fx_r_type == BFD_RELOC_386_TLS_GOTIE
a1218 1
#endif
a1235 2
#define BFD_RELOC_386_TLS_IE		0
#define BFD_RELOC_386_TLS_GOTIE		0
a3084 1

a3087 3
  fragS *insn_start_frag;
  offsetT insn_start_off;

a3092 3
  insn_start_frag = frag_now;
  insn_start_off = frag_now_fix ();

d3163 1
a3163 1
	output_disp (insn_start_frag, insn_start_off);
d3166 1
a3166 1
	output_imm (insn_start_frag, insn_start_off);
d3178 1
a3178 3
output_disp (insn_start_frag, insn_start_off)
    fragS *insn_start_frag;
    offsetT insn_start_off;
a3207 1
	      RELOC_ENUM reloc_type;
a3249 33
	      reloc_type = reloc (size, pcrel, sign, i.reloc[n]);
#ifdef BFD_ASSEMBLER
	      if (reloc_type == BFD_RELOC_32
		  && GOT_symbol
		  && GOT_symbol == i.op[n].disps->X_add_symbol
		  && (i.op[n].disps->X_op == O_symbol
		      || (i.op[n].disps->X_op == O_add
			  && ((symbol_get_value_expression
			       (i.op[n].disps->X_op_symbol)->X_op)
			      == O_subtract))))
		{
		  offsetT add;

		  if (insn_start_frag == frag_now)
		    add = (p - frag_now->fr_literal) - insn_start_off;
		  else
		    {
		      fragS *fr;

		      add = insn_start_frag->fr_fix - insn_start_off;
		      for (fr = insn_start_frag->fr_next;
			   fr && fr != frag_now; fr = fr->fr_next)
			add += fr->fr_fix;
		      add += p - frag_now->fr_literal;
		    }

		  /* We don't support dynamic linking on x86-64 yet.  */
		  if (flag_code == CODE_64BIT)
		    abort ();
		  reloc_type = BFD_RELOC_386_GOTPC;
		  i.op[n].disps->X_add_number += add;
		}
#endif
d3251 2
a3252 1
			   i.op[n].disps, pcrel, reloc_type);
d3259 1
a3259 3
output_imm (insn_start_frag, insn_start_off)
    fragS *insn_start_frag;
    offsetT insn_start_off;
a3311 42
	      /*   This is tough to explain.  We end up with this one if we
	       * have operands that look like
	       * "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal here is to
	       * obtain the absolute address of the GOT, and it is strongly
	       * preferable from a performance point of view to avoid using
	       * a runtime relocation for this.  The actual sequence of
	       * instructions often look something like:
	       *
	       *	call	.L66
	       * .L66:
	       *	popl	%ebx
	       *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
	       *
	       *   The call and pop essentially return the absolute address
	       * of the label .L66 and store it in %ebx.  The linker itself
	       * will ultimately change the first operand of the addl so
	       * that %ebx points to the GOT, but to keep things simple, the
	       * .o file must have this operand set so that it generates not
	       * the absolute address of .L66, but the absolute address of
	       * itself.  This allows the linker itself simply treat a GOTPC
	       * relocation as asking for a pcrel offset to the GOT to be
	       * added in, and the addend of the relocation is stored in the
	       * operand field for the instruction itself.
	       *
	       *   Our job here is to fix the operand so that it would add
	       * the correct offset so that %ebx would point to itself.  The
	       * thing that is tricky is that .-.L66 will point to the
	       * beginning of the instruction, so we need to further modify
	       * the operand so that it will point to itself.  There are
	       * other cases where you have something like:
	       *
	       *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
	       *
	       * and here no correction would be required.  Internally in
	       * the assembler we treat operands of this form as not being
	       * pcrel since the '.' is explicitly mentioned, and I wonder
	       * whether it would simplify matters to do it this way.  Who
	       * knows.  In earlier versions of the PIC patches, the
	       * pcrel_adjust field was used to store the correction, but
	       * since the expression is not pcrel, I felt it would be
	       * confusing to do it this way.  */

a3320 15
		  offsetT add;

		  if (insn_start_frag == frag_now)
		    add = (p - frag_now->fr_literal) - insn_start_off;
		  else
		    {
		      fragS *fr;

		      add = insn_start_frag->fr_fix - insn_start_off;
		      for (fr = insn_start_frag->fr_next;
			   fr && fr != frag_now; fr = fr->fr_next)
			add += fr->fr_fix;
		      add += p - frag_now->fr_literal;
		    }

d3325 1
a3325 1
		  i.op[n].imms->X_add_number += add;
a3365 2
    { "GOTNTPOFF",{ BFD_RELOC_386_TLS_GOTIE,  0, 0                         } },
    { "INDNTPOFF",{ BFD_RELOC_386_TLS_IE,     0, 0                         } },
a3548 1
	   && exp_seg != absolute_section
a3762 1
      && exp_seg != absolute_section
d3766 1
a3766 5
      && exp_seg != undefined_section
#ifdef BFD_ASSEMBLER
      && !bfd_is_com_section (exp_seg)
#endif
      )
d4192 2
a4193 3
      || (OUTPUT_FLAVOR == bfd_target_elf_flavour
	  && (S_IS_EXTERNAL (fragP->fr_symbol)
	      || S_IS_WEAK (fragP->fr_symbol)))
d4467 9
a4475 10
  if (fixP->fx_pcrel
      && (fixP->fx_r_type == BFD_RELOC_32_PCREL
	  || fixP->fx_r_type == BFD_RELOC_16_PCREL
	  || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && !use_rela_relocations)
    {
      /* This is a hack.  There should be a better way to handle this.
	 This covers for the fact that bfd_install_relocation will
	 subtract the current location (for partial_inplace, PC relative
	 relocations); see more below.  */
d4526 39
d4566 2
d4571 1
d4573 2
a4574 2
      case BFD_RELOC_386_TLS_IE:
      case BFD_RELOC_386_TLS_GOTIE:
d4578 3
d4873 1
a4873 1
	return flag_code == CODE_64BIT ? "elf64-x86-64" : ELF_TARGET_FORMAT;
a5046 2
    case BFD_RELOC_386_TLS_IE:
    case BFD_RELOC_386_TLS_GOTIE:
@


1.123.2.2
log
@	* config/tc-i386.c (process_operands): Warn about "lea" segment
	overrides.
@
text
@d2592 3
a2594 2
	 must be put into the modrm byte).  Now, we make the modrm and
	 index base bytes based on all the info we've collected.  */
d2621 6
a2626 8
  if (i.tm.base_opcode == 0x8d /* lea */ && i.seg[0])
    as_warn (_("segment override on `lea' is ineffectual"));

  /* If a segment was explicitly specified, and the specified segment
     is not the default, use an opcode prefix to select it.  If we
     never figured out what the default segment is, then default_seg
     will be zero at this point, and the specified segment prefix will
     always be used.  */
@


1.123.2.3
log
@	* config/tc-i386.c (output_jump): Set fx_signed for loop/jcxz.
	(md_estimate_size_before_relax): Likewise for 8 bit branches.
@
text
@d2620 1
a2620 1
  if (i.tm.base_opcode == 0x8d /* lea */ && i.seg[0] && !quiet_warnings)
a2977 1
  fixS *fixP;
d3028 2
a3029 8
  fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));

  /* All jumps handled here are signed, but don't use a signed limit
     check for 32 and 16 bit jumps as we want to allow wrap around at
     4G and 64k respectively.  */
  if (size == 1)
    fixP->fx_signed = 1;
a4370 2
	      fixS *fixP;

d4372 4
a4375 5
	      fixP = fix_new (fragP, old_fr_fix, 1,
			      fragP->fr_symbol,
			      fragP->fr_offset, 1,
			      BFD_RELOC_8_PCREL);
	      fixP->fx_signed = 1;
@


1.122
log
@	* config/tc-i386.c (md_pseudo_table <file>): Warning fix.
	(BFD_RELOC_8, BFD_RELOC_8_PCREL): Define for non-BFD.
	(md_apply_fix3): Formatting.  Remove redundant test.
	(tc_gen_reloc): Remove redundant code.
	(tc_i386_force_relocation): Delete.  Movy body of function to..
	* config/tc-i386.h (TC_FORCE_RELOCATION): .. here.
@
text
@d2231 4
a2234 2
	  && (i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
	  && !(i.tm.opcode_modifier & IgnoreSize))
a2243 8
      if (i.suffix != QWORD_MNEM_SUFFIX && (flag_code == CODE_64BIT)
	  && !(i.tm.opcode_modifier & IgnoreSize)
	  && (i.tm.opcode_modifier & JumpByte))
	{
	  if (!add_prefix (ADDR_PREFIX_OPCODE))
	    return 0;
	}

d2246 1
d2248 1
a2248 8
	{
	  i.rex |= REX_MODE64;
	  if (flag_code < CODE_64BIT)
	    {
	      as_bad (_("64bit operations available only in 64bit modes."));
	      return 0;
	    }
	}
@


1.121
log
@gas/ChangeLog
	* config/tc-i386.c (process_suffix): Remove intel mode movsx and
	movzx fudges.
	(md_assemble): Instead, zap the suffix here.

include/opcode/ChangeLog
	* i386.h: Remove IgnoreSize from movsx and movzx.
@
text
@d438 1
a438 1
  {"file", dwarf2_directive_file, 0},
a1132 15
int
tc_i386_force_relocation (fixp)
     struct fix *fixp;
{
#ifdef BFD_ASSEMBLER
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;
  return 0;
#else
  /* For COFF.  */
  return fixp->fx_r_type == 7;
#endif
}

d1223 1
d1226 1
d4452 1
a4452 1
     valueT * valP;
d4457 1
a4457 1
  valueT value = * valP;
d4603 1
a4603 1
  * valP = value;
d4607 1
a4607 1
  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
d5126 1
a5126 4
      if (fixp->fx_pcrel)
	rel->addend = fixp->fx_addnumber;
      else
	rel->addend = 0;
@


1.120
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d1329 13
a1341 5
  /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
  if (SYSV386_COMPAT
      && intel_syntax
      && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
    i.tm.base_opcode ^= FloatR;
a2226 12
    }

  /* For movzx and movsx, need to check the register type.  */
  if (intel_syntax
      && (i.tm.base_opcode == 0xfb6 || i.tm.base_opcode == 0xfbe)
      && i.suffix == BYTE_MNEM_SUFFIX)
    {
      unsigned int prefix = DATA_PREFIX_OPCODE;

      if ((i.op[1].regs->reg_type & Reg16) != 0)
	if (!add_prefix (prefix))
	  return 0;
@


1.119
log
@	* config/tc-i386.c (md_estimate_size_before_relax) Don't lose
	reloc when no_cond_jump_promotion.
@
text
@d1222 6
d1245 6
d3386 10
a3395 4
    { "PLT",      { BFD_RELOC_386_PLT32,  0, BFD_RELOC_X86_64_PLT32    } },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF, 0, 0                         } },
    { "GOTPCREL", { 0,                    0, BFD_RELOC_X86_64_GOTPCREL } },
    { "GOT",      { BFD_RELOC_386_GOT32,  0, BFD_RELOC_X86_64_GOT32    } }
d4598 6
d5072 6
@


1.118
log
@	* config/tc-i386.c (extra_symbol_chars): Add '[' to the list.
@
text
@d4238 2
a4239 4
	  if (no_cond_jump_promotion)
	    goto relax_guess;

	  if (size == 2)
d4259 9
a4267 2
	  if (no_cond_jump_promotion)
	    goto relax_guess;
a4288 1
 relax_guess:
@


1.117
log
@	* config/tc-i386.c: Formatting fixes, add missing space in error
	message.
@
text
@d185 1
a185 1
const char extra_symbol_chars[] = "*%-(@@";
d187 1
a187 1
const char extra_symbol_chars[] = "*%-(";
@


1.116
log
@	* config/tc-i386.c (output_jump, output_disp)
	(md_estimate_size_before_relax): Don't set fx_pcrel_adjust any
	more.
	(md_apply_fix3): Remember addend value for rela relocations.
	(tc_gen_reloc): Correctly compute pc-relative relocation addend.
@
text
@d2211 4
a2214 4
      && (i.tm.base_opcode == 0xfb6 || i.tm.base_opcode == 0xfbe))
    if (i.suffix && i.suffix == BYTE_MNEM_SUFFIX)
      {
	unsigned int prefix = DATA_PREFIX_OPCODE;
d2216 4
a2219 4
	if ((i.op[1].regs->reg_type & Reg16) != 0)
	  if (!add_prefix (prefix))
	    return 0;
      }
d2231 1
d2313 1
a2313 1
	      as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
d2372 1
a2372 1
	    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
d2389 1
a2389 1
	as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
d2421 1
a2421 1
	as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
d2454 1
a2454 1
	    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
@


1.115
log
@	* as.c (parse_args <OPTION_VERSION>): Use VERSION is
	BFD_VERSION_STRING unavailable.
	* config/tc-i386.c (INLINE): Define (for non-BFD assembler).
@
text
@a2982 1
  fixS *fixP;
d3033 2
a3034 3
  fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
  fixP->fx_pcrel_adjust = size;
a3226 1
	      fixS *fixP;
d3266 3
a3268 5
	      fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
				  i.op[n].disps, pcrel,
				  reloc (size, pcrel, sign, i.reloc[n]));
	      if (pcrel)
		fixP->fx_pcrel_adjust = size;
a4212 1
      fixS *fixP;
d4230 4
a4233 5
	  fixP = fix_new (fragP, old_fr_fix, size,
			  fragP->fr_symbol,
			  fragP->fr_offset, 1,
			  reloc_type);
	  fixP->fx_pcrel_adjust = size;
d4251 4
a4254 5
	      fixP = fix_new (fragP, old_fr_fix + 2, 2,
			      fragP->fr_symbol,
			      fragP->fr_offset, 1,
			      reloc_type);
	      fixP->fx_pcrel_adjust = size;
d4269 4
a4272 5
	  fixP = fix_new (fragP, old_fr_fix + 1, size,
			  fragP->fr_symbol,
			  fragP->fr_offset, 1,
			  reloc_type);
	  fixP->fx_pcrel_adjust = size;
d4601 2
d5116 17
a5132 3
      rel->addend = fixp->fx_offset;
      if (fixp->fx_pcrel)
	rel->addend -= fixp->fx_pcrel_adjust;
@


1.114
log
@	* config/tc-i386.c (output_jump): Set fx_pcrel_adjust to size of
	field for pc-relative fixups.
	(output_disp): Likewise.
	(md_estimate_size_before_relax): Likewise.
	(tc_gen_reloc): Subtract fx_pcrel_adjust instead of fx_size for
	pc-relative fixups in 64bit mode.
@
text
@d61 8
@


1.113
log
@	* config/tc-i386.h (REX_OPCODE): Define.
	(REX_MODE64, REX_EXTX, REX_EXTY, REX_EXTZ): Define.
	(rex_byte): typedef to int.
	* config/tc-i386.c: Group prototypes and vars together.
	Formatting fixes.  Remove occurrences of "register" keyword.
	(true): Delete.
	(false): Delete.
	(mode_from_disp_size): Add INLINE keyword to prototype.
	(fits_in_signed_byte): Likewise.
	(fits_in_unsigned_byte): Likewise.
	(fits_in_unsigned_word): Likewise.
	(fits_in_signed_word): Likewise.
	(fits_in_unsigned_long): Likewise.
	(fits_in_signed_long): Likewise.
	(type_names): Constify.
	(intel_float_operand): Constify param.
	(add_prefix): Use REX_OPCODE.
	(md_assemble): Likewise.  Modify for changed rex_byte.
	(parse_insn): Split out of md_assemble.
	(parse_operands): Likewise.
	(swap_operands): Likewise.
	(optimize_imm): Likewise.
	(optimize_disp): Likewise.
	(match_template): Likewise.
	(check_string): Likewise.
	(process_suffix): Likewise.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
	(finalize_imm): Likewise.
	(process_operands): Likewise.
	(build_modrm_byte): Likewise.
	(output_insn): Likewise.
	(output_branch): Likewise.
	(output_jump): Likewise.
	(output_interseg_jump): Likewise.
	(output_disp): Likewise.
	(output_imm): Likewise.
@
text
@d2975 1
d3026 3
a3028 2
  fix_new_exp (frag_now, p - frag_now->fr_literal, size,
	       i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
d3221 1
d3261 5
a3265 3
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].disps, pcrel,
			   reloc (size, pcrel, sign, i.reloc[n]));
d4210 1
d4228 5
a4232 4
	  fix_new (fragP, old_fr_fix, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
d4250 5
a4254 4
	      fix_new (fragP, old_fr_fix + 2, 2,
		       fragP->fr_symbol,
		       fragP->fr_offset, 1,
		       reloc_type);
d4269 5
a4273 4
	  fix_new (fragP, old_fr_fix + 1, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
d5117 1
a5117 1
	rel->addend -= fixp->fx_size;
@


1.112
log
@	* config/tc-i386.c (tc_gen_reloc): Don't attempt to handle 8 byte
	relocs except when BFD64.

	* write.c (number_to_chars_bigendian): Don't abort when N is
	larger than sizeof (VAL).
	(number_to_chars_littleendian): Likewise.
@
text
@d51 4
a54 2
#ifndef true
#define true 1
d56 3
a58 2
#ifndef false
#define false 0
d61 7
a67 7
static unsigned int mode_from_disp_size PARAMS ((unsigned int));
static int fits_in_signed_byte PARAMS ((offsetT));
static int fits_in_unsigned_byte PARAMS ((offsetT));
static int fits_in_unsigned_word PARAMS ((offsetT));
static int fits_in_signed_word PARAMS ((offsetT));
static int fits_in_unsigned_long PARAMS ((offsetT));
static int fits_in_signed_long PARAMS ((offsetT));
d75 28
a102 7

#ifdef BFD_ASSEMBLER
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, int, bfd_reloc_code_real_type));
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
a104 3
#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "i386"
#endif
d182 5
a188 3
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD) && !defined(TE_NetBSD))
/* Putting '/' here makes it impossible to use the divide operator.
   However, we need it for compatibility with SVR4 systems.  */
a190 4
#else
const char comment_chars[] = "#";
#define PREFIX_SEPARATOR '/'
#endif
a199 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD) && !defined(TE_NetBSD))
d201 1
d203 5
d302 1
a302 1
static unsigned int cpu_arch_flags = CpuUnknownFlags|CpuNo64;
d308 3
d324 1
a324 1
#define SMALL16 (SMALL|CODE16)
d326 1
a326 1
#define BIG16	(BIG|CODE16)
d407 37
a537 12
static char *output_invalid PARAMS ((int c));
static int i386_operand PARAMS ((char *operand_string));
static int i386_intel_operand PARAMS ((char *operand_string, int got_a_float));
static const reg_entry *parse_register PARAMS ((char *reg_string,
						char **end_op));

#ifndef I386COFF
static void s_bss PARAMS ((int));
#endif

symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */

d665 2
a666 1
  if (prefix >= 0x40 && prefix < 0x50 && flag_code == CODE_64BIT)
d704 1
a704 1
  if (i.prefix[q])
d751 1
a751 1
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
d788 1
a788 1
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
d814 1
a814 1
      && ! is_end_of_line[(unsigned char) input_line_pointer[1]])
a831 37
const pseudo_typeS md_pseudo_table[] =
{
#if !defined(OBJ_AOUT) && !defined(USE_ALIGN_PTWO)
  {"align", s_align_bytes, 0},
#else
  {"align", s_align_ptwo, 0},
#endif
  {"arch", set_cpu_arch, 0},
#ifndef I386COFF
  {"bss", s_bss, 0},
#endif
  {"ffloat", float_cons, 'f'},
  {"dfloat", float_cons, 'd'},
  {"tfloat", float_cons, 'x'},
  {"value", cons, 2},
  {"noopt", s_ignore, 0},
  {"optim", s_ignore, 0},
  {"code16gcc", set_16bit_gcc_code_flag, CODE_16BIT},
  {"code16", set_code_flag, CODE_16BIT},
  {"code32", set_code_flag, CODE_32BIT},
  {"code64", set_code_flag, CODE_64BIT},
  {"intel_syntax", set_intel_syntax, 1},
  {"att_syntax", set_intel_syntax, 0},
  {"file", dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
  {0, 0, 0}
};

/* For interface with expression ().  */
extern char *input_line_pointer;

/* Hash table for instruction mnemonic lookup.  */
static struct hash_control *op_hash;

/* Hash table for register lookup.  */
static struct hash_control *reg_hash;

d854 2
a855 2
    register const template *optab;
    register templates *core_optab;
d891 1
a891 1
    register const reg_entry *regtab;
d907 2
a908 2
    register int c;
    register char *p;
d997 4
a1000 1
	   x->rex.mode64, x->rex.extX, x->rex.extY, x->rex.extZ);
d1075 1
a1075 1
type_names[] =
d1115 1
a1115 1
  register struct type_name *ty;
d1141 2
d1236 1
a1236 1
static int intel_float_operand PARAMS ((char *mnemonic));
d1240 1
a1240 1
     char *mnemonic;
a1258 3
  /* Points to template once we've found it.  */
  const template *t;

a1259 1

a1272 4
  {
    char *l = line;
    char *token_start = l;
    char *mnem_p;
d1274 7
a1280 2
    /* Non-zero if we found a prefix only acceptable with string insns.  */
    const char *expecting_string_instruction = NULL;
d1282 2
a1283 30
    while (1)
      {
	mnem_p = mnemonic;
	while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)
	  {
	    mnem_p++;
	    if (mnem_p >= mnemonic + sizeof (mnemonic))
	      {
		as_bad (_("no such instruction: `%s'"), token_start);
		return;
	      }
	    l++;
	  }
	if (!is_space_char (*l)
	    && *l != END_OF_INSN
	    && *l != PREFIX_SEPARATOR
	    && *l != ',')
	  {
	    as_bad (_("invalid character %s in mnemonic"),
		    output_invalid (*l));
	    return;
	  }
	if (token_start == l)
	  {
	    if (*l == PREFIX_SEPARATOR)
	      as_bad (_("expecting prefix; got nothing"));
	    else
	      as_bad (_("expecting mnemonic; got nothing"));
	    return;
	  }
d1285 10
a1294 2
	/* Look up instruction (or prefix) via hash table.  */
	current_templates = hash_find (op_hash, mnemonic);
d1296 2
a1297 31
	if (*l != END_OF_INSN
	    && (! is_space_char (*l) || l[1] != END_OF_INSN)
	    && current_templates
	    && (current_templates->start->opcode_modifier & IsPrefix))
	  {
	    /* If we are in 16-bit mode, do not allow addr16 or data16.
	       Similarly, in 32-bit mode, do not allow addr32 or data32.  */
	    if ((current_templates->start->opcode_modifier & (Size16 | Size32))
		&& flag_code != CODE_64BIT
		&& (((current_templates->start->opcode_modifier & Size32) != 0)
		    ^ (flag_code == CODE_16BIT)))
	      {
		as_bad (_("redundant %s prefix"),
			current_templates->start->name);
		return;
	      }
	    /* Add prefix, checking for repeated prefixes.  */
	    switch (add_prefix (current_templates->start->base_opcode))
	      {
	      case 0:
		return;
	      case 2:
		expecting_string_instruction = current_templates->start->name;
		break;
	      }
	    /* Skip past PREFIX_SEPARATOR and reset token_start.  */
	    token_start = ++l;
	  }
	else
	  break;
      }
d1299 2
a1300 21
    if (!current_templates)
      {
	/* See if we can get a match by trimming off a suffix.  */
	switch (mnem_p[-1])
	  {
	  case WORD_MNEM_SUFFIX:
	  case BYTE_MNEM_SUFFIX:
	  case QWORD_MNEM_SUFFIX:
	    i.suffix = mnem_p[-1];
	    mnem_p[-1] = '\0';
	    current_templates = hash_find (op_hash, mnemonic);
	    break;
	  case SHORT_MNEM_SUFFIX:
	  case LONG_MNEM_SUFFIX:
	    if (!intel_syntax)
	      {
		i.suffix = mnem_p[-1];
		mnem_p[-1] = '\0';
		current_templates = hash_find (op_hash, mnemonic);
	      }
	    break;
d1302 3
a1304 19
	  /* Intel Syntax.  */
	  case 'd':
	    if (intel_syntax)
	      {
		if (intel_float_operand (mnemonic))
		  i.suffix = SHORT_MNEM_SUFFIX;
		else
		  i.suffix = LONG_MNEM_SUFFIX;
		mnem_p[-1] = '\0';
		current_templates = hash_find (op_hash, mnemonic);
	      }
	    break;
	  }
	if (!current_templates)
	  {
	    as_bad (_("no such instruction: `%s'"), token_start);
	    return;
	  }
      }
d1306 2
a1307 31
    if (current_templates->start->opcode_modifier & (Jump | JumpByte))
      {
	/* Check for a branch hint.  We allow ",pt" and ",pn" for
	   predict taken and predict not taken respectively.
	   I'm not sure that branch hints actually do anything on loop
	   and jcxz insns (JumpByte) for current Pentium4 chips.  They
	   may work in the future and it doesn't hurt to accept them
	   now.  */
	if (l[0] == ',' && l[1] == 'p')
	  {
	    if (l[2] == 't')
	      {
		if (! add_prefix (DS_PREFIX_OPCODE))
		  return;
		l += 3;
	      }
	    else if (l[2] == 'n')
	      {
		if (! add_prefix (CS_PREFIX_OPCODE))
		  return;
		l += 3;
	      }
	  }
      }
    /* Any other comma loses.  */
    if (*l == ',')
      {
	as_bad (_("invalid character %s in mnemonic"),
		output_invalid (*l));
	return;
      }
d1309 9
a1317 11
    /* Check if instruction is supported on specified architecture.  */
    if ((current_templates->start->cpu_flags & ~(Cpu64 | CpuNo64))
	& ~(cpu_arch_flags & ~(Cpu64 | CpuNo64)))
      {
	as_warn (_("`%s' is not supported on `%s'"),
		 current_templates->start->name, cpu_arch_name);
      }
    else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
      {
	as_warn (_("use .code16 to ensure correct addressing mode"));
      }
d1319 4
a1322 6
    /* Check for rep/repne without a string instruction.  */
    if (expecting_string_instruction
	&& !(current_templates->start->opcode_modifier & IsString))
      {
	as_bad (_("expecting string instruction after `%s'"),
		expecting_string_instruction);
d1324 4
a1327 1
      }
d1329 32
a1360 5
    /* There may be operands to parse.  */
    if (*l != END_OF_INSN)
      {
	/* 1 if operand is pending after ','.  */
	unsigned int expecting_operand = 0;
d1362 11
a1372 2
	/* Non-zero if operand parens not balanced.  */
	unsigned int paren_not_balanced;
d1374 6
a1379 92
	do
	  {
	    /* Skip optional white space before operand.  */
	    if (is_space_char (*l))
	      ++l;
	    if (!is_operand_char (*l) && *l != END_OF_INSN)
	      {
		as_bad (_("invalid character %s before operand %d"),
			output_invalid (*l),
			i.operands + 1);
		return;
	      }
	    token_start = l;	/* after white space */
	    paren_not_balanced = 0;
	    while (paren_not_balanced || *l != ',')
	      {
		if (*l == END_OF_INSN)
		  {
		    if (paren_not_balanced)
		      {
			if (!intel_syntax)
			  as_bad (_("unbalanced parenthesis in operand %d."),
				  i.operands + 1);
			else
			  as_bad (_("unbalanced brackets in operand %d."),
				  i.operands + 1);
			return;
		      }
		    else
		      break;	/* we are done */
		  }
		else if (!is_operand_char (*l) && !is_space_char (*l))
		  {
		    as_bad (_("invalid character %s in operand %d"),
			    output_invalid (*l),
			    i.operands + 1);
		    return;
		  }
		if (!intel_syntax)
		  {
		    if (*l == '(')
		      ++paren_not_balanced;
		    if (*l == ')')
		      --paren_not_balanced;
		  }
		else
		  {
		    if (*l == '[')
		      ++paren_not_balanced;
		    if (*l == ']')
		      --paren_not_balanced;
		  }
		l++;
	      }
	    if (l != token_start)
	      {			/* Yes, we've read in another operand.  */
		unsigned int operand_ok;
		this_operand = i.operands++;
		if (i.operands > MAX_OPERANDS)
		  {
		    as_bad (_("spurious operands; (%d operands/instruction max)"),
			    MAX_OPERANDS);
		    return;
		  }
		/* Now parse operand adding info to 'i' as we go along.  */
		END_STRING_AND_SAVE (l);

		if (intel_syntax)
		  operand_ok =
		    i386_intel_operand (token_start,
					intel_float_operand (mnemonic));
		else
		  operand_ok = i386_operand (token_start);

		RESTORE_END_STRING (l);
		if (!operand_ok)
		  return;
	      }
	    else
	      {
		if (expecting_operand)
		  {
		  expecting_operand_after_comma:
		    as_bad (_("expecting operand after ','; got nothing"));
		    return;
		  }
		if (*l == ',')
		  {
		    as_bad (_("expecting operand before ','; got nothing"));
		    return;
		  }
	      }
d1381 9
a1389 14
	    /* Now *l must be either ',' or END_OF_INSN.  */
	    if (*l == ',')
	      {
		if (*++l == END_OF_INSN)
		  {
		    /* Just skip it, if it's \n complain.  */
		    goto expecting_operand_after_comma;
		  }
		expecting_operand = 1;
	      }
	  }
	while (*l != END_OF_INSN);
      }
  }
d1391 2
a1392 2
  /* Now we've parsed the mnemonic into a set of templates, and have the
     operands at hand.
d1394 12
a1405 3
     Next, we find a template that matches the given insn,
     making sure the overlap of the given operands types is consistent
     with the template operand types.  */
d1407 11
a1417 3
#define MATCH(overlap, given, template) \
  ((overlap & ~JumpAbsolute) \
   && ((given) & (BaseIndex|JumpAbsolute)) == ((overlap) & (BaseIndex|JumpAbsolute)))
d1419 3
a1421 7
  /* If given types r0 and r1 are registers they must be of the same type
     unless the expected operand type register overlap is null.
     Note that Acc in a template matches every size of reg.  */
#define CONSISTENT_REGISTER_MATCH(m0, g0, t0, m1, g1, t1) \
  ( ((g0) & Reg) == 0 || ((g1) & Reg) == 0 || \
    ((g0) & Reg) == ((g1) & Reg) || \
    ((((m0) & Acc) ? Reg : (t0)) & (((m1) & Acc) ? Reg : (t1)) & Reg) == 0 )
d1423 4
a1426 21
  {
    register unsigned int overlap0, overlap1;
    unsigned int overlap2;
    unsigned int found_reverse_match;
    int suffix_check;

    /* All intel opcodes have reversed operands except for "bound" and
       "enter".  We also don't reverse intersegment "jmp" and "call"
       instructions with 2 immediate operands so that the immediate segment
       precedes the offset, as it does when in AT&T mode.  "enter" and the
       intersegment "jmp" and "call" instructions are the only ones that
       have two immediate operands.  */
    if (intel_syntax && i.operands > 1
	&& (strcmp (mnemonic, "bound") != 0)
	&& !((i.types[0] & Imm) && (i.types[1] & Imm)))
      {
	union i386_op temp_op;
	unsigned int temp_type;
	RELOC_ENUM temp_reloc;
	int xchg1 = 0;
	int xchg2 = 0;
d1428 2
a1429 19
	if (i.operands == 2)
	  {
	    xchg1 = 0;
	    xchg2 = 1;
	  }
	else if (i.operands == 3)
	  {
	    xchg1 = 0;
	    xchg2 = 2;
	  }
	temp_type = i.types[xchg2];
	i.types[xchg2] = i.types[xchg1];
	i.types[xchg1] = temp_type;
	temp_op = i.op[xchg2];
	i.op[xchg2] = i.op[xchg1];
	i.op[xchg1] = temp_op;
	temp_reloc = i.reloc[xchg2];
	i.reloc[xchg2] = i.reloc[xchg1];
	i.reloc[xchg1] = temp_reloc;
d1431 3
a1433 8
	if (i.mem_operands == 2)
	  {
	    const seg_entry *temp_seg;
	    temp_seg = i.seg[0];
	    i.seg[0] = i.seg[1];
	    i.seg[1] = temp_seg;
	  }
      }
d1435 45
a1479 31
    if (i.imm_operands)
      {
	/* Try to ensure constant immediates are represented in the smallest
	   opcode possible.  */
	char guess_suffix = 0;
	int op;

	if (i.suffix)
	  guess_suffix = i.suffix;
	else if (i.reg_operands)
	  {
	    /* Figure out a suffix from the last register operand specified.
	       We can't do this properly yet, ie. excluding InOutPortReg,
	       but the following works for instructions with immediates.
	       In any case, we can't set i.suffix yet.  */
	    for (op = i.operands; --op >= 0;)
	      if (i.types[op] & Reg)
		{
		  if (i.types[op] & Reg8)
		    guess_suffix = BYTE_MNEM_SUFFIX;
		  else if (i.types[op] & Reg16)
		    guess_suffix = WORD_MNEM_SUFFIX;
		  else if (i.types[op] & Reg32)
		    guess_suffix = LONG_MNEM_SUFFIX;
		  else if (i.types[op] & Reg64)
		    guess_suffix = QWORD_MNEM_SUFFIX;
		  break;
		}
	  }
	else if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
	  guess_suffix = WORD_MNEM_SUFFIX;
d1481 18
a1498 2
	for (op = i.operands; --op >= 0;)
	  if (i.types[op] & Imm)
d1500 12
a1511 16
	      switch (i.op[op].imms->X_op)
		{
		  case O_constant:
		    /* If a suffix is given, this operand may be shortened.  */
		    switch (guess_suffix)
		      {
		      case LONG_MNEM_SUFFIX:
			i.types[op] |= Imm32 | Imm64;
			break;
		      case WORD_MNEM_SUFFIX:
			i.types[op] |= Imm16 | Imm32S | Imm32 | Imm64;
			break;
		      case BYTE_MNEM_SUFFIX:
			i.types[op] |= Imm16 | Imm8 | Imm8S | Imm32S | Imm32 | Imm64;
			break;
		      }
d1513 19
a1531 47
		    /* If this operand is at most 16 bits, convert it
		       to a signed 16 bit number before trying to see
		       whether it will fit in an even smaller size.
		       This allows a 16-bit operand such as $0xffe0 to
		       be recognised as within Imm8S range.  */
		    if ((i.types[op] & Imm16)
			&& (i.op[op].imms->X_add_number & ~(offsetT) 0xffff) == 0)
		      {
			i.op[op].imms->X_add_number =
			  (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
		      }
		    if ((i.types[op] & Imm32)
			&& (i.op[op].imms->X_add_number & ~(((offsetT) 2 << 31) - 1)) == 0)
		      {
			i.op[op].imms->X_add_number =
			  (i.op[op].imms->X_add_number ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
		      }
		    i.types[op] |= smallest_imm_type (i.op[op].imms->X_add_number);
		    /* We must avoid matching of Imm32 templates when 64bit only immediate is available.  */
		    if (guess_suffix == QWORD_MNEM_SUFFIX)
		      i.types[op] &= ~Imm32;
		    break;
		  case O_absent:
		  case O_register:
		    abort ();
		  /* Symbols and expressions.  */
		  default:
		    /* Convert symbolic operand to proper sizes for matching.  */
		    switch (guess_suffix)
		      {
		        case QWORD_MNEM_SUFFIX:
			  i.types[op] = Imm64 | Imm32S;
			  break;
		        case LONG_MNEM_SUFFIX:
			  i.types[op] = Imm32 | Imm64;
			  break;
		        case WORD_MNEM_SUFFIX:
			  i.types[op] = Imm16 | Imm32 | Imm64;
			  break;
			  break;
		        case BYTE_MNEM_SUFFIX:
			  i.types[op] = Imm8 | Imm8S | Imm16 | Imm32S | Imm32;
				break;
			  break;
		      }
		    break;
		}
d1533 1
a1533 1
      }
d1535 19
a1553 4
    if (i.disp_operands)
      {
	/* Try to use the smallest displacement type too.  */
	int op;
d1555 17
a1571 3
	for (op = i.operands; --op >= 0;)
	  if ((i.types[op] & Disp)
	      && i.op[op].disps->X_op == O_constant)
d1573 25
a1597 1
	      offsetT disp = i.op[op].disps->X_add_number;
d1599 24
a1622 6
	      if (i.types[op] & Disp16)
		{
		  /* We know this operand is at most 16 bits, so
		     convert to a signed 16 bit number before trying
		     to see whether it will fit in an even smaller
		     size.  */
d1624 19
a1642 3
		  disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
		}
	      else if (i.types[op] & Disp32)
d1644 7
a1650 5
		  /* We know this operand is at most 32 bits, so convert to a
		     signed 32 bit number before trying to see whether it will
		     fit in an even smaller size.  */
		  disp &= (((offsetT) 2 << 31) - 1);
		  disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
d1652 72
a1723 10
	      if (flag_code == CODE_64BIT)
		{
		  if (fits_in_signed_long (disp))
		    i.types[op] |= Disp32S;
		  if (fits_in_unsigned_long (disp))
		    i.types[op] |= Disp32;
		}
	      if ((i.types[op] & (Disp32 | Disp32S | Disp16))
		  && fits_in_signed_byte (disp))
		i.types[op] |= Disp8;
d1725 34
a1758 1
      }
d1760 8
a1767 23
    overlap0 = 0;
    overlap1 = 0;
    overlap2 = 0;
    found_reverse_match = 0;
    suffix_check = (i.suffix == BYTE_MNEM_SUFFIX
		    ? No_bSuf
		    : (i.suffix == WORD_MNEM_SUFFIX
		       ? No_wSuf
		       : (i.suffix == SHORT_MNEM_SUFFIX
			  ? No_sSuf
			  : (i.suffix == LONG_MNEM_SUFFIX
			     ? No_lSuf
			     : (i.suffix == QWORD_MNEM_SUFFIX
				? No_qSuf
				: (i.suffix == LONG_DOUBLE_MNEM_SUFFIX ? No_xSuf : 0))))));

    for (t = current_templates->start;
	 t < current_templates->end;
	 t++)
      {
	/* Must have right number of operands.  */
	if (i.operands != t->operands)
	  continue;
d1769 7
a1775 9
	/* Check the suffix, except for some instructions in intel mode.  */
	if ((t->opcode_modifier & suffix_check)
	    && !(intel_syntax
		 && (t->opcode_modifier & IgnoreSize))
	    && !(intel_syntax
		 && t->base_opcode == 0xd9
		 && (t->extension_opcode == 5	     /* 0xd9,5 "fldcw"  */
		     || t->extension_opcode == 7)))  /* 0xd9,7 "f{n}stcw"  */
	  continue;
d1777 19
a1795 6
	/* Do not verify operands when there are none.  */
	else if (!t->operands)
	  {
	    if (t->cpu_flags & ~cpu_arch_flags)
	      continue;
	    /* We've found a match; break out of loop.  */
d1798 3
d1802 4
a1805 2
	overlap0 = i.types[0] & t->operand_types[0];
	switch (t->operands)
d1807 3
a1809 13
	  case 1:
	    if (!MATCH (overlap0, i.types[0], t->operand_types[0]))
	      continue;
	    break;
	  case 2:
	  case 3:
	    overlap1 = i.types[1] & t->operand_types[1];
	    if (!MATCH (overlap0, i.types[0], t->operand_types[0])
		|| !MATCH (overlap1, i.types[1], t->operand_types[1])
		|| !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
					       t->operand_types[0],
					       overlap1, i.types[1],
					       t->operand_types[1]))
d1811 10
a1820 3
		/* Check if other direction is valid ...  */
		if ((t->opcode_modifier & (D|FloatD)) == 0)
		  continue;
d1822 10
a1831 16
		/* Try reversing direction of operands.  */
		overlap0 = i.types[0] & t->operand_types[1];
		overlap1 = i.types[1] & t->operand_types[0];
		if (!MATCH (overlap0, i.types[0], t->operand_types[1])
		    || !MATCH (overlap1, i.types[1], t->operand_types[0])
		    || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
						   t->operand_types[1],
						   overlap1, i.types[1],
						   t->operand_types[0]))
		  {
		    /* Does not match either direction.  */
		    continue;
		  }
		/* found_reverse_match holds which of D or FloatDR
		   we've found.  */
		found_reverse_match = t->opcode_modifier & (D|FloatDR);
d1833 3
a1835 2
	    /* Found a forward 2 operand match here.  */
	    else if (t->operands == 3)
d1837 15
a1851 10
		/* Here we make use of the fact that there are no
		   reverse match 3 operand instructions, and all 3
		   operand instructions only need to be checked for
		   register consistency between operands 2 and 3.  */
		overlap2 = i.types[2] & t->operand_types[2];
		if (!MATCH (overlap2, i.types[2], t->operand_types[2])
		    || !CONSISTENT_REGISTER_MATCH (overlap1, i.types[1],
						   t->operand_types[1],
						   overlap2, i.types[2],
						   t->operand_types[2]))
d1853 19
a1871 1
		  continue;
d1873 1
a1873 7
	    /* Found either forward/reverse 2 or 3 operand match here:
	       slip through to break.  */
	  }
	if (t->cpu_flags & ~cpu_arch_flags)
	  {
	    found_reverse_match = 0;
	    continue;
a1874 2
	/* We've found a match; break out of loop.  */
	break;
d1876 10
a1885 1
    if (t == current_templates->end)
d1887 1
a1887 5
	/* We found no match.  */
	as_bad (_("suffix or operands invalid for `%s'"),
		current_templates->start->name);
	return;
      }
d1889 1
a1889 5
    if (!quiet_warnings)
      {
	if (!intel_syntax
	    && ((i.types[0] & JumpAbsolute)
		!= (t->operand_types[0] & JumpAbsolute)))
d1891 6
a1896 1
	    as_warn (_("indirect %s without `*'"), t->name);
d1898 1
a1898 3

	if ((t->opcode_modifier & (IsPrefix|IgnoreSize))
	    == (IsPrefix|IgnoreSize))
d1900 5
a1904 3
	    /* Warn them that a data or address size prefix doesn't
	       affect assembly of the next line of code.  */
	    as_warn (_("stand-alone `%s' prefix"), t->name);
d1906 10
d1917 15
d1933 42
a1974 7
    /* Copy the template we found.  */
    i.tm = *t;
    if (found_reverse_match)
      {
	/* If we found a reverse match we must alter the opcode
	   direction bit.  found_reverse_match holds bits to change
	   (different for int & float insns).  */
d1976 8
a1983 1
	i.tm.base_opcode ^= found_reverse_match;
d1985 51
a2035 3
	i.tm.operand_types[0] = t->operand_types[1];
	i.tm.operand_types[1] = t->operand_types[0];
      }
d2037 13
a2049 5
    /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
    if (SYSV386_COMPAT
	&& intel_syntax
	&& (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
      i.tm.base_opcode ^= FloatR;
d2051 7
a2057 3
    if (i.tm.opcode_modifier & FWait)
      if (! add_prefix (FWAIT_OPCODE))
	return;
d2059 8
a2066 30
    /* Check string instruction segment overrides.  */
    if ((i.tm.opcode_modifier & IsString) != 0 && i.mem_operands != 0)
      {
	int mem_op = (i.types[0] & AnyMem) ? 0 : 1;
	if ((i.tm.operand_types[mem_op] & EsSeg) != 0)
	  {
	    if (i.seg[0] != NULL && i.seg[0] != &es)
	      {
		as_bad (_("`%s' operand %d must use `%%es' segment"),
			i.tm.name,
			mem_op + 1);
		return;
	      }
	    /* There's only ever one segment override allowed per instruction.
	       This instruction possibly has a legal segment override on the
	       second operand, so copy the segment to where non-string
	       instructions store it, allowing common code.  */
	    i.seg[0] = i.seg[1];
	  }
	else if ((i.tm.operand_types[mem_op + 1] & EsSeg) != 0)
	  {
	    if (i.seg[1] != NULL && i.seg[1] != &es)
	      {
		as_bad (_("`%s' operand %d must use `%%es' segment"),
			i.tm.name,
			mem_op + 2);
		return;
	      }
	  }
      }
d2068 8
a2075 42
    /* If matched instruction specifies an explicit instruction mnemonic
       suffix, use it.  */
    if (i.tm.opcode_modifier & (Size16 | Size32 | Size64))
      {
	if (i.tm.opcode_modifier & Size16)
	  i.suffix = WORD_MNEM_SUFFIX;
	else if (i.tm.opcode_modifier & Size64)
	  i.suffix = QWORD_MNEM_SUFFIX;
	else
	  i.suffix = LONG_MNEM_SUFFIX;
      }
    else if (i.reg_operands)
      {
	/* If there's no instruction mnemonic suffix we try to invent one
	   based on register operands.  */
	if (!i.suffix)
	  {
	    /* We take i.suffix from the last register operand specified,
	       Destination register type is more significant than source
	       register type.  */
	    int op;
	    for (op = i.operands; --op >= 0;)
	      if ((i.types[op] & Reg)
		  && !(i.tm.operand_types[op] & InOutPortReg))
		{
		  i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
			      (i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
			      (i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
			      LONG_MNEM_SUFFIX);
		  break;
		}
	  }
	else if (i.suffix == BYTE_MNEM_SUFFIX)
	  {
	    int op;
	    for (op = i.operands; --op >= 0;)
	      {
		/* If this is an eight bit register, it's OK.  If it's
		   the 16 or 32 bit version of an eight bit register,
		   we will just use the low portion, and that's OK too.  */
		if (i.types[op] & Reg8)
		  continue;
d2077 7
a2083 8
		/* movzx and movsx should not generate this warning.  */
		if (intel_syntax
		    && (i.tm.base_opcode == 0xfb7
			|| i.tm.base_opcode == 0xfb6
			|| i.tm.base_opcode == 0x63
			|| i.tm.base_opcode == 0xfbe
			|| i.tm.base_opcode == 0xfbf))
		  continue;
d2085 1
a2085 46
		if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4
#if 0
		    /* Check that the template allows eight bit regs
		       This kills insns such as `orb $1,%edx', which
		       maybe should be allowed.  */
		    && (i.tm.operand_types[op] & (Reg8|InOutPortReg))
#endif
		    )
		  {
		    /* Prohibit these changes in the 64bit mode, since
		       the lowering is more complicated.  */
		    if (flag_code == CODE_64BIT
			&& (i.tm.operand_types[op] & InOutPortReg) == 0)
		      as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			      i.op[op].regs->reg_name,
			      i.suffix);
#if REGISTER_WARNINGS
		    if (!quiet_warnings
			&& (i.tm.operand_types[op] & InOutPortReg) == 0)
		      as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			       (i.op[op].regs
				+ (i.types[op] & Reg16
				   ? REGNAM_AL - REGNAM_AX
				   : REGNAM_AL - REGNAM_EAX))->reg_name,
			       i.op[op].regs->reg_name,
			       i.suffix);
#endif
		    continue;
		  }
		/* Any other register is bad.  */
		if (i.types[op] & (Reg | RegMMX | RegXMM
				   | SReg2 | SReg3
				   | Control | Debug | Test
				   | FloatReg | FloatAcc))
		  {
		    as_bad (_("`%%%s' not allowed with `%s%c'"),
			    i.op[op].regs->reg_name,
			    i.tm.name,
			    i.suffix);
		    return;
		  }
	      }
	  }
	else if (i.suffix == LONG_MNEM_SUFFIX)
	  {
	    int op;
d2087 222
a2308 23
	    for (op = i.operands; --op >= 0;)
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
	      /* Warn if the e prefix on a general reg is missing.  */
	      else if ((!quiet_warnings || flag_code == CODE_64BIT)
		       && (i.types[op] & Reg16) != 0
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  if (flag_code == CODE_64BIT)
		    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			    i.op[op].regs->reg_name,
			    i.suffix);
d2310 8
a2317 5
		  else
		    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			     (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
			     i.op[op].regs->reg_name,
			     i.suffix);
d2319 43
a2361 11
		}
	      /* Warn if the r prefix on a general reg is missing.  */
	      else if ((i.types[op] & Reg64) != 0
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			  i.op[op].regs->reg_name,
			  i.suffix);
		}
	  }
	else if (i.suffix == QWORD_MNEM_SUFFIX)
d2363 4
a2366 25
	    int op;

	    for (op = i.operands; --op >= 0; )
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16|Reg32|Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
	      /* Warn if the e prefix on a general reg is missing.  */
	      else if (((i.types[op] & Reg16) != 0
		        || (i.types[op] & Reg32) != 0)
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			  i.op[op].regs->reg_name,
			  i.suffix);
		}
a2367 27
	else if (i.suffix == WORD_MNEM_SUFFIX)
	  {
	    int op;
	    for (op = i.operands; --op >= 0;)
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16|Reg32|Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
	      /* Warn if the e prefix on a general reg is present.  */
	      else if ((!quiet_warnings || flag_code == CODE_64BIT)
		       && (i.types[op] & Reg32) != 0
		       && (i.tm.operand_types[op] & (Reg16|Acc)) != 0)
		{
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  if (flag_code == CODE_64BIT)
		    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			    i.op[op].regs->reg_name,
			    i.suffix);
		  else
d2369 5
a2373 4
		    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			     (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
			     i.op[op].regs->reg_name,
			     i.suffix);
a2374 7
		}
	  }
	else if (intel_syntax && (i.tm.opcode_modifier & IgnoreSize))
	  /* Do nothing if the instruction is going to ignore the prefix.  */
	  ;
	else
	  abort ();
d2376 33
a2408 1
    else if ((i.tm.opcode_modifier & DefaultSize) && !i.suffix)
d2410 6
a2415 1
	i.suffix = stackop_size;
d2417 12
a2428 6
    /* Make still unresolved immediate matches conform to size of immediate
       given in i.suffix.  Note: overlap2 cannot be an immediate!  */
    if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S))
	&& overlap0 != Imm8 && overlap0 != Imm8S
	&& overlap0 != Imm16 && overlap0 != Imm32S
	&& overlap0 != Imm32 && overlap0 != Imm64)
d2430 5
a2434 20
	if (i.suffix)
	  {
	    overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX ? (Imm8 | Imm8S) :
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 :
			(i.suffix == QWORD_MNEM_SUFFIX ? Imm64 | Imm32S : Imm32)));
	  }
	else if (overlap0 == (Imm16 | Imm32S | Imm32)
		 || overlap0 == (Imm16 | Imm32)
		 || overlap0 == (Imm16 | Imm32S))
	  {
	    overlap0 =
	      ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32S;
	  }
	if (overlap0 != Imm8 && overlap0 != Imm8S
	    && overlap0 != Imm16 && overlap0 != Imm32S
	    && overlap0 != Imm32 && overlap0 != Imm64)
	  {
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
	    return;
	  }
d2436 4
a2439 4
    if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32))
	&& overlap1 != Imm8 && overlap1 != Imm8S
	&& overlap1 != Imm16 && overlap1 != Imm32S
	&& overlap1 != Imm32 && overlap1 != Imm64)
d2441 3
a2443 1
	if (i.suffix)
d2445 4
a2448 17
	    overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX ? (Imm8 | Imm8S) :
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 :
			(i.suffix == QWORD_MNEM_SUFFIX ? Imm64 | Imm32S : Imm32)));
	  }
	else if (overlap1 == (Imm16 | Imm32 | Imm32S)
		 || overlap1 == (Imm16 | Imm32)
		 || overlap1 == (Imm16 | Imm32S))
	  {
	    overlap1 =
	      ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32S;
	  }
	if (overlap1 != Imm8 && overlap1 != Imm8S
	    && overlap1 != Imm16 && overlap1 != Imm32S
	    && overlap1 != Imm32 && overlap1 != Imm64)
	  {
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size %x %c"),overlap1, i.suffix);
	    return;
d2450 7
d2458 2
a2459 1
    assert ((overlap2 & Imm) == 0);
d2461 4
a2464 13
    i.types[0] = overlap0;
    if (overlap0 & ImplicitRegister)
      i.reg_operands--;
    if (overlap0 & Imm1)
      i.imm_operands = 0;	/* kludge for shift insns.  */

    i.types[1] = overlap1;
    if (overlap1 & ImplicitRegister)
      i.reg_operands--;

    i.types[2] = overlap2;
    if (overlap2 & ImplicitRegister)
      i.reg_operands--;
d2466 32
a2497 2
    /* Finalize opcode.  First, we change the opcode based on the operand
       size given by i.suffix:  We need not change things for byte insns.  */
d2499 26
a2524 10
    if (!i.suffix && (i.tm.opcode_modifier & W))
      {
	as_bad (_("no instruction mnemonic suffix given and no register operands; can't size instruction"));
	return;
      }

    /* For movzx and movsx, need to check the register type.  */
    if (intel_syntax
	&& (i.tm.base_opcode == 0xfb6 || i.tm.base_opcode == 0xfbe))
      if (i.suffix && i.suffix == BYTE_MNEM_SUFFIX)
d2526 2
a2527 5
	  unsigned int prefix = DATA_PREFIX_OPCODE;

	  if ((i.op[1].regs->reg_type & Reg16) != 0)
	    if (!add_prefix (prefix))
	      return;
d2529 2
d2532 3
a2534 20
    if (i.suffix && i.suffix != BYTE_MNEM_SUFFIX)
      {
	/* It's not a byte, select word/dword operation.  */
	if (i.tm.opcode_modifier & W)
	  {
	    if (i.tm.opcode_modifier & ShortForm)
	      i.tm.base_opcode |= 8;
	    else
	      i.tm.base_opcode |= 1;
	  }
	/* Now select between word & dword operations via the operand
	   size prefix, except for instructions that will ignore this
	   prefix anyway.  */
	if (i.suffix != QWORD_MNEM_SUFFIX
	    && (i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
	    && !(i.tm.opcode_modifier & IgnoreSize))
	  {
	    unsigned int prefix = DATA_PREFIX_OPCODE;
	    if (i.tm.opcode_modifier & JumpByte) /* jcxz, loop */
	      prefix = ADDR_PREFIX_OPCODE;
d2536 2
a2537 3
	    if (! add_prefix (prefix))
	      return;
	  }
d2539 54
a2592 7
	if (i.suffix != QWORD_MNEM_SUFFIX && (flag_code == CODE_64BIT)
	    && !(i.tm.opcode_modifier & IgnoreSize)
	    && (i.tm.opcode_modifier & JumpByte))
	  {
	    if (! add_prefix (ADDR_PREFIX_OPCODE))
	      return;
	  }
d2594 24
a2617 11
	/* Set mode64 for an operand.  */
	if (i.suffix == QWORD_MNEM_SUFFIX
	    && !(i.tm.opcode_modifier & NoRex64))
	  {
	    i.rex.mode64 = 1;
	    if (flag_code < CODE_64BIT)
	      {
		as_bad (_("64bit operations available only in 64bit modes."));
		return;
	      }
	  }
d2619 13
a2631 7
	/* Size floating point instruction.  */
	if (i.suffix == LONG_MNEM_SUFFIX)
	  {
	    if (i.tm.opcode_modifier & FloatMF)
	      i.tm.base_opcode ^= 4;
	  }
      }
d2633 4
a2636 18
    if (i.tm.opcode_modifier & ImmExt)
      {
	/* These AMD 3DNow! and Intel Katmai New Instructions have an
	   opcode suffix which is coded in the same place as an 8-bit
	   immediate field would be.  Here we fake an 8-bit immediate
	   operand from the opcode suffix stored in tm.extension_opcode.  */

	expressionS *exp;

	assert (i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);

	exp = &im_expressions[i.imm_operands++];
	i.op[i.operands].imms = exp;
	i.types[i.operands++] = Imm8;
	exp->X_op = O_constant;
	exp->X_add_number = i.tm.extension_opcode;
	i.tm.extension_opcode = None;
      }
d2638 46
a2683 20
    /* For insns with operands there are more diddles to do to the opcode.  */
    if (i.operands)
      {
	/* Default segment register this instruction will use
	   for memory accesses.  0 means unknown.
	   This is only for optimizing out unnecessary segment overrides.  */
	const seg_entry *default_seg = 0;

	/* The imul $imm, %reg instruction is converted into
	   imul $imm, %reg, %reg, and the clr %reg instruction
	   is converted into xor %reg, %reg.  */
	if (i.tm.opcode_modifier & regKludge)
	  {
	    unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
	    /* Pretend we saw the extra register operand.  */
	    assert (i.op[first_reg_op + 1].regs == 0);
	    i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
	    i.types[first_reg_op + 1] = i.types[first_reg_op];
	    i.reg_operands = 2;
	  }
d2685 1
a2685 81
	if (i.tm.opcode_modifier & ShortForm)
	  {
	    /* The register or float register operand is in operand 0 or 1.  */
	    unsigned int op = (i.types[0] & (Reg | FloatReg)) ? 0 : 1;
	    /* Register goes in low 3 bits of opcode.  */
	    i.tm.base_opcode |= i.op[op].regs->reg_num;
	    if (i.op[op].regs->reg_flags & RegRex)
	      i.rex.extZ = 1;
	    if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
	      {
		/* Warn about some common errors, but press on regardless.
		   The first case can be generated by gcc (<= 2.8.1).  */
		if (i.operands == 2)
		  {
		    /* Reversed arguments on faddp, fsubp, etc.  */
		    as_warn (_("translating to `%s %%%s,%%%s'"), i.tm.name,
			     i.op[1].regs->reg_name,
			     i.op[0].regs->reg_name);
		  }
		else
		  {
		    /* Extraneous `l' suffix on fp insn.  */
		    as_warn (_("translating to `%s %%%s'"), i.tm.name,
			     i.op[0].regs->reg_name);
		  }
	      }
	  }
	else if (i.tm.opcode_modifier & Modrm)
	  {
	    /* The opcode is completed (modulo i.tm.extension_opcode which
	       must be put into the modrm byte).
	       Now, we make the modrm & index base bytes based on all the
	       info we've collected.  */

	    /* i.reg_operands MUST be the number of real register operands;
	       implicit registers do not count.  */
	    if (i.reg_operands == 2)
	      {
		unsigned int source, dest;
		source = ((i.types[0]
			   & (Reg | RegMMX | RegXMM
			      | SReg2 | SReg3
			      | Control | Debug | Test))
			  ? 0 : 1);
		dest = source + 1;

		i.rm.mode = 3;
		/* One of the register operands will be encoded in the
		   i.tm.reg field, the other in the combined i.tm.mode
		   and i.tm.regmem fields.  If no form of this
		   instruction supports a memory destination operand,
		   then we assume the source operand may sometimes be
		   a memory operand and so we need to store the
		   destination in the i.rm.reg field.  */
		if ((i.tm.operand_types[dest] & AnyMem) == 0)
		  {
		    i.rm.reg = i.op[dest].regs->reg_num;
		    i.rm.regmem = i.op[source].regs->reg_num;
		    if (i.op[dest].regs->reg_flags & RegRex)
		      i.rex.extX = 1;
		    if (i.op[source].regs->reg_flags & RegRex)
		      i.rex.extZ = 1;
		  }
		else
		  {
		    i.rm.reg = i.op[source].regs->reg_num;
		    i.rm.regmem = i.op[dest].regs->reg_num;
		    if (i.op[dest].regs->reg_flags & RegRex)
		      i.rex.extZ = 1;
		    if (i.op[source].regs->reg_flags & RegRex)
		      i.rex.extX = 1;
		  }
	      }
	    else
	      {			/* If it's not 2 reg operands...  */
		if (i.mem_operands)
		  {
		    unsigned int fake_zero_displacement = 0;
		    unsigned int op = ((i.types[0] & AnyMem)
				       ? 0
				       : (i.types[1] & AnyMem) ? 1 : 2);
d2687 77
a2763 6
		    default_seg = &ds;

		    if (! i.base_reg)
		      {
			i.rm.mode = 0;
			if (! i.disp_operands)
d2765 52
a2816 129
			if (! i.index_reg)
			  {
			    /* Operand is just <disp>  */
			    if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
				&& (flag_code != CODE_64BIT))
			      {
				i.rm.regmem = NO_BASE_REGISTER_16;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp16;
			      }
			    else if (flag_code != CODE_64BIT
				     || (i.prefix[ADDR_PREFIX] != 0))
			      {
				i.rm.regmem = NO_BASE_REGISTER;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp32;
			      }
			    else
			      {
			        /* 64bit mode overwrites the 32bit
				   absolute addressing by RIP relative
				   addressing and absolute addressing
				   is encoded by one of the redundant
				   SIB forms.  */

				i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
				i.sib.base = NO_BASE_REGISTER;
				i.sib.index = NO_INDEX_REGISTER;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp32S;
			      }
			  }
			else /* ! i.base_reg && i.index_reg  */
			  {
			    i.sib.index = i.index_reg->reg_num;
			    i.sib.base = NO_BASE_REGISTER;
			    i.sib.scale = i.log2_scale_factor;
			    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
			    i.types[op] &= ~Disp;
			    if (flag_code != CODE_64BIT)
			      i.types[op] |= Disp32;	/* Must be 32 bit */
			    else
			      i.types[op] |= Disp32S;
			    if (i.index_reg->reg_flags & RegRex)
			      i.rex.extY = 1;
			  }
		      }
		    /* RIP addressing for 64bit mode.  */
		    else if (i.base_reg->reg_type == BaseIndex)
		      {
			i.rm.regmem = NO_BASE_REGISTER;
			i.types[op] &= ~Disp;
			i.types[op] |= Disp32S;
			i.flags[op] = Operand_PCrel;
		      }
		    else if (i.base_reg->reg_type & Reg16)
		      {
			switch (i.base_reg->reg_num)
			  {
			  case 3: /* (%bx)  */
			    if (! i.index_reg)
			      i.rm.regmem = 7;
			    else /* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
			      i.rm.regmem = i.index_reg->reg_num - 6;
			    break;
			  case 5: /* (%bp)  */
			    default_seg = &ss;
			    if (! i.index_reg)
			      {
				i.rm.regmem = 6;
				if ((i.types[op] & Disp) == 0)
				  {
				    /* fake (%bp) into 0(%bp)  */
				    i.types[op] |= Disp8;
				    fake_zero_displacement = 1;
				  }
			      }
			    else /* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
			      i.rm.regmem = i.index_reg->reg_num - 6 + 2;
			    break;
			  default: /* (%si) -> 4 or (%di) -> 5  */
			    i.rm.regmem = i.base_reg->reg_num - 6 + 4;
			  }
			i.rm.mode = mode_from_disp_size (i.types[op]);
		      }
		    else /* i.base_reg and 32/64 bit mode  */
		      {
			if (flag_code == CODE_64BIT
			    && (i.types[op] & Disp))
			  {
			    if (i.types[op] & Disp8)
			      i.types[op] = Disp8 | Disp32S;
			    else
			      i.types[op] = Disp32S;
			  }
			i.rm.regmem = i.base_reg->reg_num;
			if (i.base_reg->reg_flags & RegRex)
			  i.rex.extZ = 1;
			i.sib.base = i.base_reg->reg_num;
			/* x86-64 ignores REX prefix bit here to avoid
			   decoder complications.  */
			if ((i.base_reg->reg_num & 7) == EBP_REG_NUM)
			  {
			    default_seg = &ss;
			    if (i.disp_operands == 0)
			      {
				fake_zero_displacement = 1;
				i.types[op] |= Disp8;
			      }
			  }
			else if (i.base_reg->reg_num == ESP_REG_NUM)
			  {
			    default_seg = &ss;
			  }
			i.sib.scale = i.log2_scale_factor;
			if (! i.index_reg)
			  {
			    /* <disp>(%esp) becomes two byte modrm
			       with no index register.  We've already
			       stored the code for esp in i.rm.regmem
			       ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.  Any
			       base register besides %esp will not use
			       the extra modrm byte.  */
			    i.sib.index = NO_INDEX_REGISTER;
#if ! SCALE1_WHEN_NO_INDEX
			    /* Another case where we force the second
			       modrm byte.  */
			    if (i.log2_scale_factor)
			      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
d2818 59
a2876 10
			  }
			else
			  {
			    i.sib.index = i.index_reg->reg_num;
			    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
			    if (i.index_reg->reg_flags & RegRex)
			      i.rex.extY = 1;
			  }
			i.rm.mode = mode_from_disp_size (i.types[op]);
		      }
d2878 6
a2883 15
		    if (fake_zero_displacement)
		      {
			/* Fakes a zero displacement assuming that i.types[op]
			   holds the correct displacement size.  */
			expressionS *exp;

			assert (i.op[op].disps == 0);
			exp = &disp_expressions[i.disp_operands++];
			i.op[op].disps = exp;
			exp->X_op = O_constant;
			exp->X_add_number = 0;
			exp->X_add_symbol = (symbolS *) 0;
			exp->X_op_symbol = (symbolS *) 0;
		      }
		  }
d2885 6
a2890 33
		/* Fill in i.rm.reg or i.rm.regmem field with register
		   operand (if any) based on i.tm.extension_opcode.
		   Again, we must be careful to make sure that
		   segment/control/debug/test/MMX registers are coded
		   into the i.rm.reg field.  */
		if (i.reg_operands)
		  {
		    unsigned int op =
		      ((i.types[0]
			& (Reg | RegMMX | RegXMM
			   | SReg2 | SReg3
			   | Control | Debug | Test))
		       ? 0
		       : ((i.types[1]
			   & (Reg | RegMMX | RegXMM
			      | SReg2 | SReg3
			      | Control | Debug | Test))
			  ? 1
			  : 2));
		    /* If there is an extension opcode to put here, the
		       register number must be put into the regmem field.  */
		    if (i.tm.extension_opcode != None)
		      {
			i.rm.regmem = i.op[op].regs->reg_num;
			if (i.op[op].regs->reg_flags & RegRex)
			  i.rex.extZ = 1;
		      }
		    else
		      {
			i.rm.reg = i.op[op].regs->reg_num;
			if (i.op[op].regs->reg_flags & RegRex)
			  i.rex.extX = 1;
		      }
d2892 61
a2952 34
		    /* Now, if no memory operand has set i.rm.mode = 0, 1, 2
		       we must set it to 3 to indicate this is a register
		       operand in the regmem field.  */
		    if (!i.mem_operands)
		      i.rm.mode = 3;
		  }

		/* Fill in i.rm.reg field with extension opcode (if any).  */
		if (i.tm.extension_opcode != None)
		  i.rm.reg = i.tm.extension_opcode;
	      }
	  }
	else if (i.tm.opcode_modifier & (Seg2ShortForm | Seg3ShortForm))
	  {
	    if (i.tm.base_opcode == POP_SEG_SHORT
		&& i.op[0].regs->reg_num == 1)
	      {
		as_bad (_("you can't `pop %%cs'"));
		return;
	      }
	    i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
	    if (i.op[0].regs->reg_flags & RegRex)
	      i.rex.extZ = 1;
	  }
	else if ((i.tm.base_opcode & ~(D|W)) == MOV_AX_DISP32)
	  {
	    default_seg = &ds;
	  }
	else if ((i.tm.opcode_modifier & IsString) != 0)
	  {
	    /* For the string instructions that allow a segment override
	       on one of their operands, the default segment is ds.  */
	    default_seg = &ds;
	  }
d2954 2
a2955 18
	/* If a segment was explicitly specified,
	   and the specified segment is not the default,
	   use an opcode prefix to select it.
	   If we never figured out what the default segment is,
	   then default_seg will be zero at this point,
	   and the specified segment prefix will always be used.  */
	if ((i.seg[0]) && (i.seg[0] != default_seg))
	  {
	    if (! add_prefix (i.seg[0]->seg_prefix))
	      return;
	  }
      }
    else if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
      {
	/* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
	as_warn (_("translating to `%sp'"), i.tm.name);
      }
  }
d2957 2
a2958 2
  /* Handle conversion of 'int $3' --> special int3 insn.  */
  if (i.tm.base_opcode == INT_OPCODE && i.op[0].imms->X_add_number == 3)
d2960 3
a2962 2
      i.tm.base_opcode = INT3_OPCODE;
      i.imm_operands = 0;
d2965 4
a2968 9
  if ((i.tm.opcode_modifier & (Jump | JumpByte | JumpDword))
      && i.op[0].disps->X_op == O_constant)
    {
      /* Convert "jmp constant" (and "call constant") to a jump (call) to
	 the absolute address given by the constant.  Since ix86 jumps and
	 calls are pc relative, we need to generate a reloc.  */
      i.op[0].disps->X_add_symbol = &abs_symbol;
      i.op[0].disps->X_op = O_symbol;
    }
d2970 5
a2974 2
  if (i.tm.opcode_modifier & Rex64)
    i.rex.mode64 = 1;
d2976 1
a2976 8
  /* For 8bit registers we would need an empty rex prefix.
     Also in the case instruction is already having prefix,
     we need to convert old registers to new ones.  */

  if (((i.types[0] & Reg8) && (i.op[0].regs->reg_flags & RegRex64))
      || ((i.types[1] & Reg8) && (i.op[1].regs->reg_flags & RegRex64))
      || ((i.rex.mode64 || i.rex.extX || i.rex.extY || i.rex.extZ || i.rex.empty)
	  && ((i.types[0] & Reg8) || (i.types[1] & Reg8))))
d2978 10
a2987 3
      int x;
      i.rex.empty = 1;
      for (x = 0; x < 2; x++)
d2989 2
a2990 15
	  /* Look for 8bit operand that does use old registers.  */
	  if (i.types[x] & Reg8
	      && !(i.op[x].regs->reg_flags & RegRex64))
	    {
	      /* In case it is "hi" register, give up.  */
	      if (i.op[x].regs->reg_num > 3)
		as_bad (_("Can't encode registers '%%%s' in the instruction requiring REX prefix.\n"),
			i.op[x].regs->reg_name);

	      /* Otherwise it is equivalent to the extended register.
	         Since the encoding don't change this is merely cosmetical
	         cleanup for debug output.  */

	      i.op[x].regs = i.op[x].regs + 8;
	    }
d2993 3
d2997 3
a2999 6
  if (i.rex.mode64 || i.rex.extX || i.rex.extY || i.rex.extZ || i.rex.empty)
    add_prefix (0x40
		| (i.rex.mode64 ? 8 : 0)
		| (i.rex.extX ? 4 : 0)
		| (i.rex.extY ? 2 : 0)
		| (i.rex.extZ ? 1 : 0));
d3001 6
a3006 3
  /* We are ready to output the insn.  */
  {
    register char *p;
d3008 4
a3011 4
    /* Tie dwarf2 debug info to the address at the start of the insn.
       We can't do this after the insn has been output as the current
       frag may have been closed off.  eg. by frag_var.  */
    dwarf2_emit_insn (0);
d3013 5
a3017 12
    /* Output jumps.  */
    if (i.tm.opcode_modifier & Jump)
      {
	int code16;
	int prefix;
	relax_substateT subtype;
	symbolS *sym;
	offsetT off;

	code16 = 0;
	if (flag_code == CODE_16BIT)
	  code16 = CODE16;
d3019 2
a3020 19
	prefix = 0;
	if (i.prefix[DATA_PREFIX])
	  {
	    prefix = 1;
	    i.prefixes -= 1;
	    code16 ^= CODE16;
	  }
	/* Pentium4 branch hints.  */
	if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
	    || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	  {
	    prefix++;
	    i.prefixes--;
	  }
	if (i.prefix[REX_PREFIX])
	  {
	    prefix++;
	    i.prefixes--;
	  }
d3022 2
a3023 2
	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));
d3025 3
a3027 24
	/* It's always a symbol;  End frag & setup for relax.
	   Make sure there is enough room in this frag for the largest
	   instruction we may generate in md_convert_frag.  This is 2
	   bytes for the opcode and room for the prefix and largest
	   displacement.  */
	frag_grow (prefix + 2 + 4);
	/* Prefix and 1 opcode byte go in fr_fix.  */
	p = frag_more (prefix + 1);
	if (i.prefix[DATA_PREFIX])
	  *p++ = DATA_PREFIX_OPCODE;
	if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
	    || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
	  *p++ = i.prefix[SEG_PREFIX];
	if (i.prefix[REX_PREFIX])
	  *p++ = i.prefix[REX_PREFIX];
	*p = i.tm.base_opcode;

	if ((unsigned char) *p == JUMP_PC_RELATIVE)
	  subtype = ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL);
	else if ((cpu_arch_flags & Cpu386) != 0)
	  subtype = ENCODE_RELAX_STATE (COND_JUMP, SMALL);
	else
	  subtype = ENCODE_RELAX_STATE (COND_JUMP86, SMALL);
	subtype |= code16;
d3029 7
a3035 2
	sym = i.op[0].disps->X_add_symbol;
	off = i.op[0].disps->X_add_number;
d3037 3
a3039 7
	if (i.op[0].disps->X_op != O_constant
	    && i.op[0].disps->X_op != O_symbol)
	  {
	    /* Handle complex expressions.  */
	    sym = make_expr_symbol (i.op[0].disps);
	    off = 0;
	  }
d3041 12
a3052 7
	/* 1 possible extra opcode + 4 byte displacement go in var part.
	   Pass reloc in fr_var.  */
	frag_var (rs_machine_dependent, 5, i.reloc[0], subtype, sym, off, p);
      }
    else if (i.tm.opcode_modifier & (JumpByte | JumpDword))
      {
	int size;
d3054 3
a3056 20
	if (i.tm.opcode_modifier & JumpByte)
	  {
	    /* This is a loop or jecxz type instruction.  */
	    size = 1;
	    if (i.prefix[ADDR_PREFIX])
	      {
		FRAG_APPEND_1_CHAR (ADDR_PREFIX_OPCODE);
		i.prefixes -= 1;
	      }
	    /* Pentium4 branch hints.  */
	    if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
		|| i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	      {
		FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
		i.prefixes--;
	      }
	  }
	else
	  {
	    int code16;
d3058 2
a3059 3
	    code16 = 0;
	    if (flag_code == CODE_16BIT)
	      code16 = CODE16;
d3061 2
a3062 6
	    if (i.prefix[DATA_PREFIX])
	      {
		FRAG_APPEND_1_CHAR (DATA_PREFIX_OPCODE);
		i.prefixes -= 1;
		code16 ^= CODE16;
	      }
d3064 2
a3065 4
	    size = 4;
	    if (code16)
	      size = 2;
	  }
d3067 2
a3068 5
	if (i.prefix[REX_PREFIX])
	  {
	    FRAG_APPEND_1_CHAR (i.prefix[REX_PREFIX]);
	    i.prefixes -= 1;
	  }
d3070 4
a3073 2
	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));
d3075 17
a3091 2
	p = frag_more (1 + size);
	*p++ = i.tm.base_opcode;
d3093 20
a3112 12
	fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		     i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
      }
    else if (i.tm.opcode_modifier & JumpInterSegment)
      {
	int size;
	int prefix;
	int code16;

	code16 = 0;
	if (flag_code == CODE_16BIT)
	  code16 = CODE16;
d3114 16
a3129 12
	prefix = 0;
	if (i.prefix[DATA_PREFIX])
	  {
	    prefix = 1;
	    i.prefixes -= 1;
	    code16 ^= CODE16;
	  }
	if (i.prefix[REX_PREFIX])
	  {
	    prefix++;
	    i.prefixes -= 1;
	  }
d3131 12
a3142 3
	size = 4;
	if (code16)
	  size = 2;
d3144 25
a3168 2
	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));
d3170 2
a3171 2
	/* 1 opcode; 2 segment; offset  */
	p = frag_more (prefix + 1 + 2 + size);
d3173 3
a3175 2
	if (i.prefix[DATA_PREFIX])
	  *p++ = DATA_PREFIX_OPCODE;
d3177 7
a3183 2
	if (i.prefix[REX_PREFIX])
	  *p++ = i.prefix[REX_PREFIX];
d3185 5
a3189 4
	*p++ = i.tm.base_opcode;
	if (i.op[1].imms->X_op == O_constant)
	  {
	    offsetT n = i.op[1].imms->X_add_number;
d3191 8
a3198 21
	    if (size == 2
		&& !fits_in_unsigned_word (n)
		&& !fits_in_signed_word (n))
	      {
		as_bad (_("16-bit jump out of range"));
		return;
	      }
	    md_number_to_chars (p, n, size);
	  }
	else
	  fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		       i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
	if (i.op[0].imms->X_op != O_constant)
	  as_bad (_("can't handle non absolute segment in `%s'"),
		  i.tm.name);
	md_number_to_chars (p + size, (valueT) i.op[0].imms->X_add_number, 2);
      }
    else
      {
	/* Output normal instructions here.  */
	unsigned char *q;
d3200 27
a3226 29
	/* All opcodes on i386 have eighter 1 or 2 bytes.  We may use third
	   byte for the SSE instructions to specify prefix they require.  */
	if (i.tm.base_opcode & 0xff0000)
	  add_prefix ((i.tm.base_opcode >> 16) & 0xff);

	/* The prefix bytes.  */
	for (q = i.prefix;
	     q < i.prefix + sizeof (i.prefix) / sizeof (i.prefix[0]);
	     q++)
	  {
	    if (*q)
	      {
		p = frag_more (1);
		md_number_to_chars (p, (valueT) *q, 1);
	      }
	  }

	/* Now the opcode; be careful about word order here!  */
	if (fits_in_unsigned_byte (i.tm.base_opcode))
	  {
	    FRAG_APPEND_1_CHAR (i.tm.base_opcode);
	  }
	else
	  {
	    p = frag_more (2);
	    /* Put out high byte first: can't use md_number_to_chars!  */
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
	    *p = i.tm.base_opcode & 0xff;
	  }
d3228 2
a3229 35
	/* Now the modrm byte and sib byte (if present).  */
	if (i.tm.opcode_modifier & Modrm)
	  {
	    p = frag_more (1);
	    md_number_to_chars (p,
				(valueT) (i.rm.regmem << 0
					  | i.rm.reg << 3
					  | i.rm.mode << 6),
				1);
	    /* If i.rm.regmem == ESP (4)
	       && i.rm.mode != (Register mode)
	       && not 16 bit
	       ==> need second modrm byte.  */
	    if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
		&& i.rm.mode != 3
		&& !(i.base_reg && (i.base_reg->reg_type & Reg16) != 0))
	      {
		p = frag_more (1);
		md_number_to_chars (p,
				    (valueT) (i.sib.base << 0
					      | i.sib.index << 3
					      | i.sib.scale << 6),
				    1);
	      }
	  }

	if (i.disp_operands)
	  {
	    register unsigned int n;

	    for (n = 0; n < i.operands; n++)
	      {
		if (i.types[n] & Disp)
		  {
		    if (i.op[n].disps->X_op == O_constant)
d3231 1
a3231 5
			int size;
			offsetT val;

			size = 4;
			if (i.types[n] & (Disp8 | Disp16 | Disp64))
d3233 5
a3237 5
			    size = 2;
			    if (i.types[n] & Disp8)
			      size = 1;
			    if (i.types[n] & Disp64)
			      size = 8;
d3239 1
a3239 4
			val = offset_in_range (i.op[n].disps->X_add_number,
					       size);
			p = frag_more (size);
			md_number_to_chars (p, val, size);
d3241 5
a3245 13
		    else
		      {
			int size = 4;
			int sign = 0;
			int pcrel = (i.flags[n] & Operand_PCrel) != 0;

			/* The PC relative address is computed relative
			   to the instruction boundary, so in case immediate
			   fields follows, we need to adjust the value.  */
			if (pcrel && i.imm_operands)
			  {
			    int imm_size = 4;
			    register unsigned int n1;
d3247 2
a3248 18
			    for (n1 = 0; n1 < i.operands; n1++)
			      if (i.types[n1] & Imm)
				{
				  if (i.types[n1] & (Imm8 | Imm8S | Imm16 | Imm64))
				    {
				      imm_size = 2;
				      if (i.types[n1] & (Imm8 | Imm8S))
					imm_size = 1;
				      if (i.types[n1] & Imm64)
					imm_size = 8;
				    }
				  break;
				}
			    /* We should find the immediate.  */
			    if (n1 == i.operands)
			      abort ();
			    i.op[n].disps->X_add_number -= imm_size;
			  }
d3250 6
a3255 2
			if (i.types[n] & Disp32S)
			  sign = 1;
d3257 8
a3264 6
			if (i.types[n] & (Disp16 | Disp64))
			  {
			    size = 2;
			    if (i.types[n] & Disp64)
			      size = 8;
			  }
d3266 5
a3270 8
			p = frag_more (size);
			fix_new_exp (frag_now, p - frag_now->fr_literal, size,
				     i.op[n].disps, pcrel,
				     reloc (size, pcrel, sign, i.reloc[n]));
		      }
		  }
	      }
	  }
d3272 8
a3279 4
	/* Output immediate.  */
	if (i.imm_operands)
	  {
	    register unsigned int n;
d3281 35
a3315 44
	    for (n = 0; n < i.operands; n++)
	      {
		if (i.types[n] & Imm)
		  {
		    if (i.op[n].imms->X_op == O_constant)
		      {
			int size;
			offsetT val;

			size = 4;
			if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
			  {
			    size = 2;
			    if (i.types[n] & (Imm8 | Imm8S))
			      size = 1;
			    else if (i.types[n] & Imm64)
			      size = 8;
			  }
			val = offset_in_range (i.op[n].imms->X_add_number,
					       size);
			p = frag_more (size);
			md_number_to_chars (p, val, size);
		      }
		    else
		      {
			/* Not absolute_section.
			   Need a 32-bit fixup (don't support 8bit
			   non-absolute imms).  Try to support other
			   sizes ...  */
			RELOC_ENUM reloc_type;
			int size = 4;
			int sign = 0;

			if ((i.types[n] & (Imm32S))
			    && i.suffix == QWORD_MNEM_SUFFIX)
			  sign = 1;
			if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
			  {
			    size = 2;
			    if (i.types[n] & (Imm8 | Imm8S))
			      size = 1;
			    if (i.types[n] & Imm64)
			      size = 8;
			  }
d3317 2
a3318 2
			p = frag_more (size);
			reloc_type = reloc (size, 0, sign, i.reloc[n]);
d3320 15
a3334 15
			if (reloc_type == BFD_RELOC_32
			    && GOT_symbol
			    && GOT_symbol == i.op[n].imms->X_add_symbol
			    && (i.op[n].imms->X_op == O_symbol
				|| (i.op[n].imms->X_op == O_add
				    && ((symbol_get_value_expression
					 (i.op[n].imms->X_op_symbol)->X_op)
					== O_subtract))))
			  {
			    /* We don't support dynamic linking on x86-64 yet.  */
			    if (flag_code == CODE_64BIT)
			      abort ();
			    reloc_type = BFD_RELOC_386_GOTPC;
			    i.op[n].imms->X_add_number += 3;
			  }
d3336 5
a3340 15
			fix_new_exp (frag_now, p - frag_now->fr_literal, size,
				     i.op[n].imms, 0, reloc_type);
		      }
		  }
	      }
	  }
      }

#ifdef DEBUG386
    if (flag_debug)
      {
	pi (line, &i);
      }
#endif /* DEBUG386  */
  }
d3612 1
a3612 1
  if (i.log2_scale_factor != 0 && ! i.index_reg)
d3632 1
a3632 1
  register expressionS *exp;
d3642 2
a3643 2
      if (!i.prefix[ADDR_PREFIX])
        bigdisp = Disp64;
d3743 1
a3743 1
        i.reloc[this_operand] = BFD_RELOC_32_PCREL;
d3745 1
a3745 1
        i.reloc[this_operand] = BFD_RELOC_32;
d3809 2
a3810 2
		  && ((i.index_reg->reg_type & (Reg64|BaseIndex))
		      != (Reg64|BaseIndex))))
d3819 2
a3820 2
		  && ((i.index_reg->reg_type & (Reg32|BaseIndex|RegRex))
		      != (Reg32|BaseIndex))))
d3830 2
a3831 2
	       && ((i.base_reg->reg_type & (Reg16|BaseIndex|RegRex))
		   != (Reg16|BaseIndex)))
d3833 6
a3838 6
		  && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		       != (Reg16|BaseIndex))
		      || ! (i.base_reg
			    && i.base_reg->reg_num < 6
			    && i.index_reg->reg_num >= 6
			    && i.log2_scale_factor == 0))))
d3847 2
a3848 2
		  && ((i.index_reg->reg_type & (Reg32|BaseIndex|RegRex))
		      != (Reg32|BaseIndex))))
d3865 2
a3866 2
	  if (i.types[this_operand] & (Disp16|Disp32))
	     i.types[this_operand] ^= (Disp16|Disp32);
d4185 2
a4186 2
     register fragS *fragP;
     register segT segment;
d4299 1
a4299 1
     register fragS *fragP;
d4305 1
a4305 1
     register fragS *fragP;
d4308 1
a4308 1
  register unsigned char *opcode;
d4490 2
a4491 2
	      && ! S_IS_EXTERNAL (fixP->fx_addsy)
	      && ! S_IS_WEAK (fixP->fx_addsy)
d4493 1
a4493 1
	      && ! S_IS_COMMON (fixP->fx_addsy))
d4731 1
a4731 1
      && r->reg_flags & (RegRex64|RegRex)
d4785 1
a4785 1
         .stab instead of .stab.excl.  We always use .stab anyhow.  */
d4982 1
a4982 1
  register int temp;
d5125 1
a5125 1
#else /* ! BFD_ASSEMBLER  */
d5191 1
a5191 1
#endif /* ! BFD_ASSEMBLER  */
@


1.111
log
@Update copyright.
@
text
@d4885 1
d4887 1
@


1.110
log
@	* config/tc-i386.c (tc_i386_fix_adjustable): Don't adjust
	pc-relative relocations to merge sections in 64-bit mode.
@
text
@d3 1
a3 1
   2000, 2001
@


1.109
log
@	* i386.c (md_assemble): Support 32bit address prefix.
	(i386_displacement): Likewise.
	(i386_index_check): Accept 32bit addressing in 64bit mode.
@
text
@d1181 6
a1186 1
      || S_IS_WEAK (fixP->fx_addsy))
@


1.108
log
@2002-01-29  Daniel Jacobowitz  <drow@@mvista.com>

        * config/tc-i386.c: Protect definitions of true and false
        from redefinition.
@
text
@d1301 1
d2267 8
d2427 2
a2428 1
			    if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
d2434 2
a2435 1
			    else if (flag_code != CODE_64BIT)
d3452 6
a3457 1
  if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
a3458 2
  if (flag_code == CODE_64BIT)
    bigdisp = Disp64;
d3613 22
a3634 9
      /* 64bit checks.  */
      if ((i.base_reg
	   && ((i.base_reg->reg_type & Reg64) == 0)
	       && (i.base_reg->reg_type != BaseIndex
		   || i.index_reg))
	  || (i.index_reg
	      && ((i.index_reg->reg_type & (Reg64|BaseIndex))
		  != (Reg64|BaseIndex))))
	ok = 0;
@


1.108.2.1
log
@	* config/tc-i386.c (tc_i386_fix_adjustable): Don't adjust
	pc-relative relocations to merge sections in 64-bit mode.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d1181 1
a1181 6
      || S_IS_WEAK (fixP->fx_addsy)
      /* Don't adjust pc-relative references to merge sections in 64-bit
	 mode.  */
      || (use_rela_relocations
	  && (S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0
	  && fixP->fx_pcrel))
@


1.108.2.2
log
@      * i386.c (md_assemble): Support 32bit address prefix.
      (i386_displacement): Likewise.
      (i386_index_check): Accept 32bit addressing in 64bit mode.
@
text
@a1305 1
		&& flag_code != CODE_64BIT
a2270 8
	if (i.suffix != QWORD_MNEM_SUFFIX && (flag_code == CODE_64BIT)
	    && !(i.tm.opcode_modifier & IgnoreSize)
	    && (i.tm.opcode_modifier & JumpByte))
	  {
	    if (! add_prefix (ADDR_PREFIX_OPCODE))
	      return;
	  }

d2423 1
a2423 2
			    if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
				&& (flag_code != CODE_64BIT))
d2429 1
a2429 2
			    else if (flag_code != CODE_64BIT
				     || (i.prefix[ADDR_PREFIX] != 0))
d3446 2
d3449 1
a3449 6
    {
      if (!i.prefix[ADDR_PREFIX])
        bigdisp = Disp64;
    }
  else if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
    bigdisp = Disp16;
d3604 9
a3612 22
      if (i.prefix[ADDR_PREFIX] == 0)
	{
	  /* 64bit checks.  */
	  if ((i.base_reg
	       && ((i.base_reg->reg_type & Reg64) == 0)
		   && (i.base_reg->reg_type != BaseIndex
		       || i.index_reg))
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg64|BaseIndex))
		      != (Reg64|BaseIndex))))
	    ok = 0;
	}
      else
	{
	  /* 32bit checks.  */
	  if ((i.base_reg
	       && (i.base_reg->reg_type & (Reg32 | RegRex)) != Reg32)
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg32|BaseIndex|RegRex))
		      != (Reg32|BaseIndex))))
	    ok = 0;
	}
@


1.108.2.3
log
@	* config/tc-i386.c (md_assemble): Set fx_pcrel_adjust to size of
	field for pc-relative fixups.
	(md_estimate_size_before_relax): Likewise.
	(tc_gen_reloc): Subtract fx_pcrel_adjust instead of fx_size for
	pc-relative fixups in 64bit mode.
@
text
@a2819 1
	fixS *fixP;
d2870 2
a2871 3
	fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			    i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
	fixP->fx_pcrel_adjust = size;
a3026 1
			fixS *fixP;
d3066 3
a3068 5
			fixP = fix_new_exp (frag_now, p - frag_now->fr_literal,
					    size, i.op[n].disps, pcrel,
					    reloc (size, pcrel, sign, i.reloc[n]));
			if (pcrel)
			  fixP->fx_pcrel_adjust = size;
a4021 1
      fixS *fixP;
d4039 4
a4042 5
	  fixP = fix_new (fragP, old_fr_fix, size,
			  fragP->fr_symbol,
			  fragP->fr_offset, 1,
			  reloc_type);
	  fixP->fx_pcrel_adjust = size;
d4060 4
a4063 5
	      fixP = fix_new (fragP, old_fr_fix + 2, 2,
			      fragP->fr_symbol,
			      fragP->fr_offset, 1,
			      reloc_type);
	      fixP->fx_pcrel_adjust = size;
d4078 4
a4081 5
	  fixP = fix_new (fragP, old_fr_fix + 1, size,
			  fragP->fr_symbol,
			  fragP->fr_offset, 1,
			  reloc_type);
	  fixP->fx_pcrel_adjust = size;
d4923 1
a4923 1
	rel->addend -= fixp->fx_pcrel_adjust;
@


1.108.2.4
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.

	Merge from mainline.
	2002-03-12  Andreas Schwab  <schwab@@suse.de>
	* config/tc-ia64.c (fixup_unw_records): Clear region when seeing a
	body record so that an error is given for misplaced .save
	pseudo-ops.

	2002-03-09  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.h (REX_OPCODE): Define.
	(REX_MODE64, REX_EXTX, REX_EXTY, REX_EXTZ): Define.
	(rex_byte): typedef to int.
	* config/tc-i386.c: Group prototypes and vars together.
	Formatting fixes.  Remove occurrences of "register" keyword.
	(true): Delete.
	(false): Delete.
	(mode_from_disp_size): Add INLINE keyword to prototype.
	(fits_in_signed_byte): Likewise.
	(fits_in_unsigned_byte): Likewise.
	(fits_in_unsigned_word): Likewise.
	(fits_in_signed_word): Likewise.
	(fits_in_unsigned_long): Likewise.
	(fits_in_signed_long): Likewise.
	(type_names): Constify.
	(intel_float_operand): Constify param.
	(add_prefix): Use REX_OPCODE.
	(md_assemble): Likewise.  Modify for changed rex_byte.
	(parse_insn): Split out of md_assemble.
	(parse_operands): Likewise.
	(swap_operands): Likewise.
	(optimize_imm): Likewise.
	(optimize_disp): Likewise.
	(match_template): Likewise.
	(check_string): Likewise.
	(process_suffix): Likewise.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
	(finalize_imm): Likewise.
	(process_operands): Likewise.
	(build_modrm_byte): Likewise.
	(output_insn): Likewise.
	(output_branch): Likewise.
	(output_jump): Likewise.
	(output_interseg_jump): Likewise.
	(output_disp): Likewise.
	(output_imm): Likewise.

	2002-03-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_gen_reloc): Don't attempt to handle 8 byte
	relocs except when BFD64.
	* write.c (number_to_chars_bigendian): Don't abort when N is
	larger than sizeof (VAL).
	(number_to_chars_littleendian): Likewise.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* config/tc-hppa.c (md_apply_fix3): Add cast.
	(hppa_fix_adjustable): Adjust list of selectors using e_lrsel and
	e_rrsel.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* config/obj-elf.c (special_section): Add .init_array,
	.fini_array and .preinit_array.
	* config/tc-ia64.h (ELF_TC_SPECIAL_SECTIONS): Remove
	.init_array and .fini_array.

	2002-03-01  Jakub Jelinek  <jakub@@redhat.com>
	* config/obj-elf.c (elf_copy_symbol_attributes): Don't copy
	visibility.
	(obj_frob_symbol): Copy visibility.
@
text
@d51 2
a52 4
#ifdef BFD_ASSEMBLER
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
d54 2
a55 3

#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "i386"
d58 7
a64 7
static INLINE unsigned int mode_from_disp_size PARAMS ((unsigned int));
static INLINE int fits_in_signed_byte PARAMS ((offsetT));
static INLINE int fits_in_unsigned_byte PARAMS ((offsetT));
static INLINE int fits_in_unsigned_word PARAMS ((offsetT));
static INLINE int fits_in_signed_word PARAMS ((offsetT));
static INLINE int fits_in_unsigned_long PARAMS ((offsetT));
static INLINE int fits_in_signed_long PARAMS ((offsetT));
d72 7
a78 28
static char *output_invalid PARAMS ((int c));
static int i386_operand PARAMS ((char *operand_string));
static int i386_intel_operand PARAMS ((char *operand_string, int got_a_float));
static const reg_entry *parse_register PARAMS ((char *reg_string,
						char **end_op));
static char *parse_insn PARAMS ((char *, char *));
static char *parse_operands PARAMS ((char *, const char *));
static void swap_operands PARAMS ((void));
static void optimize_imm PARAMS ((void));
static void optimize_disp PARAMS ((void));
static int match_template PARAMS ((void));
static int check_string PARAMS ((void));
static int process_suffix PARAMS ((void));
static int check_byte_reg PARAMS ((void));
static int check_long_reg PARAMS ((void));
static int check_qword_reg PARAMS ((void));
static int check_word_reg PARAMS ((void));
static int finalize_imm PARAMS ((void));
static int process_operands PARAMS ((void));
static const seg_entry *build_modrm_byte PARAMS ((void));
static void output_insn PARAMS ((void));
static void output_branch PARAMS ((void));
static void output_jump PARAMS ((void));
static void output_interseg_jump PARAMS ((void));
static void output_imm PARAMS ((void));
static void output_disp PARAMS ((void));
#ifndef I386COFF
static void s_bss PARAMS ((int));
d81 3
a160 5
#if (defined (TE_I386AIX)				\
     || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))	\
	 && !defined (TE_LINUX)				\
	 && !defined (TE_FreeBSD)			\
	 && !defined (TE_NetBSD)))
d163 3
d168 4
d181 1
a182 1

a183 5
/* Putting '/' here makes it impossible to use the divide operator.
   However, we need it for compatibility with SVR4 systems.  */
const char comment_chars[] = "#";
#define PREFIX_SEPARATOR '/'

d278 1
a278 1
static unsigned int cpu_arch_flags = CpuUnknownFlags | CpuNo64;
a283 3
/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
symbolS *GOT_symbol;

d297 1
a297 1
#define SMALL16 (SMALL | CODE16)
d299 1
a299 1
#define BIG16	(BIG | CODE16)
a379 37
const pseudo_typeS md_pseudo_table[] =
{
#if !defined(OBJ_AOUT) && !defined(USE_ALIGN_PTWO)
  {"align", s_align_bytes, 0},
#else
  {"align", s_align_ptwo, 0},
#endif
  {"arch", set_cpu_arch, 0},
#ifndef I386COFF
  {"bss", s_bss, 0},
#endif
  {"ffloat", float_cons, 'f'},
  {"dfloat", float_cons, 'd'},
  {"tfloat", float_cons, 'x'},
  {"value", cons, 2},
  {"noopt", s_ignore, 0},
  {"optim", s_ignore, 0},
  {"code16gcc", set_16bit_gcc_code_flag, CODE_16BIT},
  {"code16", set_code_flag, CODE_16BIT},
  {"code32", set_code_flag, CODE_32BIT},
  {"code64", set_code_flag, CODE_64BIT},
  {"intel_syntax", set_intel_syntax, 1},
  {"att_syntax", set_intel_syntax, 0},
  {"file", dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
  {0, 0, 0}
};

/* For interface with expression ().  */
extern char *input_line_pointer;

/* Hash table for instruction mnemonic lookup.  */
static struct hash_control *op_hash;

/* Hash table for register lookup.  */
static struct hash_control *reg_hash;

d474 12
d613 1
a613 2
  if (prefix >= REX_OPCODE && prefix < REX_OPCODE + 16
      && flag_code == CODE_64BIT)
d651 1
a651 1
  if (i.prefix[q] != 0)
d698 1
a698 1
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
d735 1
a735 1
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
d761 1
a761 1
      && !is_end_of_line[(unsigned char) input_line_pointer[1]])
d779 37
d838 2
a839 2
    const template *optab;
    templates *core_optab;
d875 1
a875 1
    const reg_entry *regtab;
d891 2
a892 2
    int c;
    char *p;
d981 1
a981 4
	   (x->rex & REX_MODE64) != 0,
	   (x->rex & REX_EXTX) != 0,
	   (x->rex & REX_EXTY) != 0,
	   (x->rex & REX_EXTZ) != 0);
d1056 1
a1056 1
static const type_names[] =
d1096 1
a1096 1
  const struct type_name *ty;
a1121 2
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, int, bfd_reloc_code_real_type));
d1215 1
a1215 1
static int intel_float_operand PARAMS ((const char *mnemonic));
d1219 1
a1219 1
     const char *mnemonic;
d1238 3
d1242 1
d1256 4
d1261 2
a1262 7
  line = parse_insn (line, mnemonic);
  if (line == NULL)
    return;

  line = parse_operands (line, mnemonic);
  if (line == NULL)
    return;
d1264 30
a1293 2
  /* Now we've parsed the mnemonic into a set of templates, and have the
     operands at hand.  */
d1295 2
a1296 10
  /* All intel opcodes have reversed operands except for "bound" and
     "enter".  We also don't reverse intersegment "jmp" and "call"
     instructions with 2 immediate operands so that the immediate segment
     precedes the offset, as it does when in AT&T mode.  "enter" and the
     intersegment "jmp" and "call" instructions are the only ones that
     have two immediate operands.  */
  if (intel_syntax && i.operands > 1
      && (strcmp (mnemonic, "bound") != 0)
      && !((i.types[0] & Imm) && (i.types[1] & Imm)))
    swap_operands ();
d1298 31
a1328 2
  if (i.imm_operands)
    optimize_imm ();
d1330 21
a1350 2
  if (i.disp_operands)
    optimize_disp ();
d1352 19
a1370 3
  /* Next, we find a template that matches the given insn,
     making sure the overlap of the given operands types is consistent
     with the template operand types.  */
d1372 31
a1402 2
  if (!match_template ())
    return;
d1404 11
a1414 9
  /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
  if (SYSV386_COMPAT
      && intel_syntax
      && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
    i.tm.base_opcode ^= FloatR;

  if (i.tm.opcode_modifier & FWait)
    if (!add_prefix (FWAIT_OPCODE))
      return;
d1416 6
a1421 4
  /* Check string instruction segment overrides.  */
  if ((i.tm.opcode_modifier & IsString) != 0 && i.mem_operands != 0)
    {
      if (!check_string ())
d1423 1
a1423 1
    }
d1425 5
a1429 2
  if (!process_suffix ())
    return;
d1431 2
a1432 32
  /* Make still unresolved immediate matches conform to size of immediate
     given in i.suffix.  */
  if (!finalize_imm ())
    return;

  if (i.types[0] & Imm1)
    i.imm_operands = 0;	/* kludge for shift insns.  */
  if (i.types[0] & ImplicitRegister)
    i.reg_operands--;
  if (i.types[1] & ImplicitRegister)
    i.reg_operands--;
  if (i.types[2] & ImplicitRegister)
    i.reg_operands--;

  if (i.tm.opcode_modifier & ImmExt)
    {
      /* These AMD 3DNow! and Intel Katmai New Instructions have an
	 opcode suffix which is coded in the same place as an 8-bit
	 immediate field would be.  Here we fake an 8-bit immediate
	 operand from the opcode suffix stored in tm.extension_opcode.  */

      expressionS *exp;

      assert (i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);

      exp = &im_expressions[i.imm_operands++];
      i.op[i.operands].imms = exp;
      i.types[i.operands++] = Imm8;
      exp->X_op = O_constant;
      exp->X_add_number = i.tm.extension_opcode;
      i.tm.extension_opcode = None;
    }
d1434 92
a1525 11
  /* For insns with operands there are more diddles to do to the opcode.  */
  if (i.operands)
    {
      if (!process_operands ())
	return;
    }
  else if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
    {
      /* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
      as_warn (_("translating to `%sp'"), i.tm.name);
    }
d1527 14
a1540 6
  /* Handle conversion of 'int $3' --> special int3 insn.  */
  if (i.tm.base_opcode == INT_OPCODE && i.op[0].imms->X_add_number == 3)
    {
      i.tm.base_opcode = INT3_OPCODE;
      i.imm_operands = 0;
    }
d1542 2
a1543 9
  if ((i.tm.opcode_modifier & (Jump | JumpByte | JumpDword))
      && i.op[0].disps->X_op == O_constant)
    {
      /* Convert "jmp constant" (and "call constant") to a jump (call) to
	 the absolute address given by the constant.  Since ix86 jumps and
	 calls are pc relative, we need to generate a reloc.  */
      i.op[0].disps->X_add_symbol = &abs_symbol;
      i.op[0].disps->X_op = O_symbol;
    }
d1545 3
a1547 2
  if ((i.tm.opcode_modifier & Rex64) != 0)
    i.rex |= REX_MODE64;
d1549 3
a1551 12
  /* For 8 bit registers we need an empty rex prefix.  Also if the
     instruction already has a prefix, we need to convert old
     registers to new ones.  */

  if (((i.types[0] & Reg8) != 0
       && (i.op[0].regs->reg_flags & RegRex64) != 0)
      || ((i.types[1] & Reg8) != 0
	  && (i.op[1].regs->reg_flags & RegRex64) != 0)
      || (((i.types[0] & Reg8) != 0 || (i.types[1] & Reg8) != 0)
	  && i.rex != 0))
    {
      int x;
d1553 7
a1559 11
      i.rex |= REX_OPCODE;
      for (x = 0; x < 2; x++)
	{
	  /* Look for 8 bit operand that uses old registers.  */
	  if ((i.types[x] & Reg8) != 0
	      && (i.op[x].regs->reg_flags & RegRex64) == 0)
	    {
	      /* In case it is "hi" register, give up.  */
	      if (i.op[x].regs->reg_num > 3)
		as_bad (_("can't encode register '%%%s' in an instruction requiring REX prefix.\n"),
			i.op[x].regs->reg_name);
d1561 21
a1581 3
	      /* Otherwise it is equivalent to the extended register.
		 Since the encoding doesn't change this is merely
		 cosmetic cleanup for debug output.  */
d1583 19
a1601 4
	      i.op[x].regs = i.op[x].regs + 8;
	    }
	}
    }
d1603 8
a1610 2
  if (i.rex != 0)
    add_prefix (REX_OPCODE | i.rex);
d1612 31
a1642 12
  /* We are ready to output the insn.  */
  output_insn ();
}

static char *
parse_insn (line, mnemonic)
     char *line;
     char *mnemonic;
{
  char *l = line;
  char *token_start = l;
  char *mnem_p;
d1644 2
a1645 10
  /* Non-zero if we found a prefix only acceptable with string insns.  */
  const char *expecting_string_instruction = NULL;

  while (1)
    {
      mnem_p = mnemonic;
      while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)
	{
	  mnem_p++;
	  if (mnem_p >= mnemonic + MAX_MNEM_SIZE)
d1647 16
a1662 22
	      as_bad (_("no such instruction: `%s'"), token_start);
	      return NULL;
	    }
	  l++;
	}
      if (!is_space_char (*l)
	  && *l != END_OF_INSN
	  && *l != PREFIX_SEPARATOR
	  && *l != ',')
	{
	  as_bad (_("invalid character %s in mnemonic"),
		  output_invalid (*l));
	  return NULL;
	}
      if (token_start == l)
	{
	  if (*l == PREFIX_SEPARATOR)
	    as_bad (_("expecting prefix; got nothing"));
	  else
	    as_bad (_("expecting mnemonic; got nothing"));
	  return NULL;
	}
d1664 47
a1710 18
      /* Look up instruction (or prefix) via hash table.  */
      current_templates = hash_find (op_hash, mnemonic);

      if (*l != END_OF_INSN
	  && (!is_space_char (*l) || l[1] != END_OF_INSN)
	  && current_templates
	  && (current_templates->start->opcode_modifier & IsPrefix))
	{
	  /* If we are in 16-bit mode, do not allow addr16 or data16.
	     Similarly, in 32-bit mode, do not allow addr32 or data32.  */
	  if ((current_templates->start->opcode_modifier & (Size16 | Size32))
	      && flag_code != CODE_64BIT
	      && (((current_templates->start->opcode_modifier & Size32) != 0)
		  ^ (flag_code == CODE_16BIT)))
	    {
	      as_bad (_("redundant %s prefix"),
		      current_templates->start->name);
	      return NULL;
d1712 1
a1712 15
	  /* Add prefix, checking for repeated prefixes.  */
	  switch (add_prefix (current_templates->start->base_opcode))
	    {
	    case 0:
	      return NULL;
	    case 2:
	      expecting_string_instruction = current_templates->start->name;
	      break;
	    }
	  /* Skip past PREFIX_SEPARATOR and reset token_start.  */
	  token_start = ++l;
	}
      else
	break;
    }
d1714 4
a1717 21
  if (!current_templates)
    {
      /* See if we can get a match by trimming off a suffix.  */
      switch (mnem_p[-1])
	{
	case WORD_MNEM_SUFFIX:
	case BYTE_MNEM_SUFFIX:
	case QWORD_MNEM_SUFFIX:
	  i.suffix = mnem_p[-1];
	  mnem_p[-1] = '\0';
	  current_templates = hash_find (op_hash, mnemonic);
	  break;
	case SHORT_MNEM_SUFFIX:
	case LONG_MNEM_SUFFIX:
	  if (!intel_syntax)
	    {
	      i.suffix = mnem_p[-1];
	      mnem_p[-1] = '\0';
	      current_templates = hash_find (op_hash, mnemonic);
	    }
	  break;
d1719 3
a1721 3
	  /* Intel Syntax.  */
	case 'd':
	  if (intel_syntax)
d1723 1
a1723 15
	      if (intel_float_operand (mnemonic))
		i.suffix = SHORT_MNEM_SUFFIX;
	      else
		i.suffix = LONG_MNEM_SUFFIX;
	      mnem_p[-1] = '\0';
	      current_templates = hash_find (op_hash, mnemonic);
	    }
	  break;
	}
      if (!current_templates)
	{
	  as_bad (_("no such instruction: `%s'"), token_start);
	  return NULL;
	}
    }
d1725 6
a1730 31
  if (current_templates->start->opcode_modifier & (Jump | JumpByte))
    {
      /* Check for a branch hint.  We allow ",pt" and ",pn" for
	 predict taken and predict not taken respectively.
	 I'm not sure that branch hints actually do anything on loop
	 and jcxz insns (JumpByte) for current Pentium4 chips.  They
	 may work in the future and it doesn't hurt to accept them
	 now.  */
      if (l[0] == ',' && l[1] == 'p')
	{
	  if (l[2] == 't')
	    {
	      if (!add_prefix (DS_PREFIX_OPCODE))
		return NULL;
	      l += 3;
	    }
	  else if (l[2] == 'n')
	    {
	      if (!add_prefix (CS_PREFIX_OPCODE))
		return NULL;
	      l += 3;
	    }
	}
    }
  /* Any other comma loses.  */
  if (*l == ',')
    {
      as_bad (_("invalid character %s in mnemonic"),
	      output_invalid (*l));
      return NULL;
    }
d1732 11
a1742 56
  /* Check if instruction is supported on specified architecture.  */
  if ((current_templates->start->cpu_flags & ~(Cpu64 | CpuNo64))
      & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64)))
    {
      as_warn (_("`%s' is not supported on `%s'"),
	       current_templates->start->name, cpu_arch_name);
    }
  else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
    {
      as_warn (_("use .code16 to ensure correct addressing mode"));
    }

  /* Check for rep/repne without a string instruction.  */
  if (expecting_string_instruction
      && !(current_templates->start->opcode_modifier & IsString))
    {
      as_bad (_("expecting string instruction after `%s'"),
	      expecting_string_instruction);
      return NULL;
    }

  return l;
}

static char *
parse_operands (l, mnemonic)
     char *l;
     const char *mnemonic;
{
  char *token_start;

  /* 1 if operand is pending after ','.  */
  unsigned int expecting_operand = 0;

  /* Non-zero if operand parens not balanced.  */
  unsigned int paren_not_balanced;

  while (*l != END_OF_INSN)
    {
      /* Skip optional white space before operand.  */
      if (is_space_char (*l))
	++l;
      if (!is_operand_char (*l) && *l != END_OF_INSN)
	{
	  as_bad (_("invalid character %s before operand %d"),
		  output_invalid (*l),
		  i.operands + 1);
	  return NULL;
	}
      token_start = l;	/* after white space */
      paren_not_balanced = 0;
      while (paren_not_balanced || *l != ',')
	{
	  if (*l == END_OF_INSN)
	    {
	      if (paren_not_balanced)
d1744 4
a1747 7
		  if (!intel_syntax)
		    as_bad (_("unbalanced parenthesis in operand %d."),
			    i.operands + 1);
		  else
		    as_bad (_("unbalanced brackets in operand %d."),
			    i.operands + 1);
		  return NULL;
d1749 3
a1751 2
	      else
		break;	/* we are done */
d1753 1
a1753 35
	  else if (!is_operand_char (*l) && !is_space_char (*l))
	    {
	      as_bad (_("invalid character %s in operand %d"),
		      output_invalid (*l),
		      i.operands + 1);
	      return NULL;
	    }
	  if (!intel_syntax)
	    {
	      if (*l == '(')
		++paren_not_balanced;
	      if (*l == ')')
		--paren_not_balanced;
	    }
	  else
	    {
	      if (*l == '[')
		++paren_not_balanced;
	      if (*l == ']')
		--paren_not_balanced;
	    }
	  l++;
	}
      if (l != token_start)
	{			/* Yes, we've read in another operand.  */
	  unsigned int operand_ok;
	  this_operand = i.operands++;
	  if (i.operands > MAX_OPERANDS)
	    {
	      as_bad (_("spurious operands; (%d operands/instruction max)"),
		      MAX_OPERANDS);
	      return NULL;
	    }
	  /* Now parse operand adding info to 'i' as we go along.  */
	  END_STRING_AND_SAVE (l);
d1755 23
a1777 25
	  if (intel_syntax)
	    operand_ok =
	      i386_intel_operand (token_start,
				  intel_float_operand (mnemonic));
	  else
	    operand_ok = i386_operand (token_start);

	  RESTORE_END_STRING (l);
	  if (!operand_ok)
	    return NULL;
	}
      else
	{
	  if (expecting_operand)
	    {
	    expecting_operand_after_comma:
	      as_bad (_("expecting operand after ','; got nothing"));
	      return NULL;
	    }
	  if (*l == ',')
	    {
	      as_bad (_("expecting operand before ','; got nothing"));
	      return NULL;
	    }
	}
d1779 9
a1787 13
      /* Now *l must be either ',' or END_OF_INSN.  */
      if (*l == ',')
	{
	  if (*++l == END_OF_INSN)
	    {
	      /* Just skip it, if it's \n complain.  */
	      goto expecting_operand_after_comma;
	    }
	  expecting_operand = 1;
	}
    }
  return l;
}
d1789 6
a1794 65
static void
swap_operands ()
{
  union i386_op temp_op;
  unsigned int temp_type;
  RELOC_ENUM temp_reloc;
  int xchg1 = 0;
  int xchg2 = 0;

  if (i.operands == 2)
    {
      xchg1 = 0;
      xchg2 = 1;
    }
  else if (i.operands == 3)
    {
      xchg1 = 0;
      xchg2 = 2;
    }
  temp_type = i.types[xchg2];
  i.types[xchg2] = i.types[xchg1];
  i.types[xchg1] = temp_type;
  temp_op = i.op[xchg2];
  i.op[xchg2] = i.op[xchg1];
  i.op[xchg1] = temp_op;
  temp_reloc = i.reloc[xchg2];
  i.reloc[xchg2] = i.reloc[xchg1];
  i.reloc[xchg1] = temp_reloc;

  if (i.mem_operands == 2)
    {
      const seg_entry *temp_seg;
      temp_seg = i.seg[0];
      i.seg[0] = i.seg[1];
      i.seg[1] = temp_seg;
    }
}

/* Try to ensure constant immediates are represented in the smallest
   opcode possible.  */
static void
optimize_imm ()
{
  char guess_suffix = 0;
  int op;

  if (i.suffix)
    guess_suffix = i.suffix;
  else if (i.reg_operands)
    {
      /* Figure out a suffix from the last register operand specified.
	 We can't do this properly yet, ie. excluding InOutPortReg,
	 but the following works for instructions with immediates.
	 In any case, we can't set i.suffix yet.  */
      for (op = i.operands; --op >= 0;)
	if (i.types[op] & Reg)
	  {
	    if (i.types[op] & Reg8)
	      guess_suffix = BYTE_MNEM_SUFFIX;
	    else if (i.types[op] & Reg16)
	      guess_suffix = WORD_MNEM_SUFFIX;
	    else if (i.types[op] & Reg32)
	      guess_suffix = LONG_MNEM_SUFFIX;
	    else if (i.types[op] & Reg64)
	      guess_suffix = QWORD_MNEM_SUFFIX;
a1796 3
    }
  else if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
    guess_suffix = WORD_MNEM_SUFFIX;
d1798 2
a1799 4
  for (op = i.operands; --op >= 0;)
    if (i.types[op] & Imm)
      {
	switch (i.op[op].imms->X_op)
d1801 13
a1813 3
	  case O_constant:
	    /* If a suffix is given, this operand may be shortened.  */
	    switch (guess_suffix)
d1815 3
a1817 10
	      case LONG_MNEM_SUFFIX:
		i.types[op] |= Imm32 | Imm64;
		break;
	      case WORD_MNEM_SUFFIX:
		i.types[op] |= Imm16 | Imm32S | Imm32 | Imm64;
		break;
	      case BYTE_MNEM_SUFFIX:
		i.types[op] |= Imm16 | Imm8 | Imm8S | Imm32S | Imm32 | Imm64;
		break;
	      }
d1819 16
a1834 10
	    /* If this operand is at most 16 bits, convert it
	       to a signed 16 bit number before trying to see
	       whether it will fit in an even smaller size.
	       This allows a 16-bit operand such as $0xffe0 to
	       be recognised as within Imm8S range.  */
	    if ((i.types[op] & Imm16)
		&& (i.op[op].imms->X_add_number & ~(offsetT) 0xffff) == 0)
	      {
		i.op[op].imms->X_add_number =
		  (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
d1836 2
a1837 3
	    if ((i.types[op] & Imm32)
		&& ((i.op[op].imms->X_add_number & ~(((offsetT) 2 << 31) - 1))
		    == 0))
d1839 10
a1848 5
		i.op[op].imms->X_add_number = ((i.op[op].imms->X_add_number
						^ ((offsetT) 1 << 31))
					       - ((offsetT) 1 << 31));
	      }
	    i.types[op] |= smallest_imm_type (i.op[op].imms->X_add_number);
d1850 1
a1850 29
	    /* We must avoid matching of Imm32 templates when 64bit
	       only immediate is available.  */
	    if (guess_suffix == QWORD_MNEM_SUFFIX)
	      i.types[op] &= ~Imm32;
	    break;

	  case O_absent:
	  case O_register:
	    abort ();

	    /* Symbols and expressions.  */
	  default:
	    /* Convert symbolic operand to proper sizes for matching.  */
	    switch (guess_suffix)
	      {
	      case QWORD_MNEM_SUFFIX:
		i.types[op] = Imm64 | Imm32S;
		break;
	      case LONG_MNEM_SUFFIX:
		i.types[op] = Imm32 | Imm64;
		break;
	      case WORD_MNEM_SUFFIX:
		i.types[op] = Imm16 | Imm32 | Imm64;
		break;
		break;
	      case BYTE_MNEM_SUFFIX:
		i.types[op] = Imm8 | Imm8S | Imm16 | Imm32S | Imm32;
		break;
		break;
d1852 7
a1858 1
	    break;
d1860 9
a1869 7
}

/* Try to use the smallest displacement type too.  */
static void
optimize_disp ()
{
  int op;
d1871 1
a1871 2
  for (op = i.operands; --op >= 0;)
    if ((i.types[op] & Disp) && i.op[op].disps->X_op == O_constant)
d1873 3
a1875 3
	offsetT disp = i.op[op].disps->X_add_number;

	if (i.types[op] & Disp16)
d1877 2
a1878 4
	    /* We know this operand is at most 16 bits, so
	       convert to a signed 16 bit number before trying
	       to see whether it will fit in an even smaller
	       size.  */
d1880 2
a1881 3
	    disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
	  }
	else if (i.types[op] & Disp32)
d1883 3
a1885 5
	    /* We know this operand is at most 32 bits, so convert to a
	       signed 32 bit number before trying to see whether it will
	       fit in an even smaller size.  */
	    disp &= (((offsetT) 2 << 31) - 1);
	    disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
a1886 10
	if (flag_code == CODE_64BIT)
	  {
	    if (fits_in_signed_long (disp))
	      i.types[op] |= Disp32S;
	    if (fits_in_unsigned_long (disp))
	      i.types[op] |= Disp32;
	  }
	if ((i.types[op] & (Disp32 | Disp32S | Disp16))
	    && fits_in_signed_byte (disp))
	  i.types[op] |= Disp8;
a1887 1
}
d1889 7
a1895 13
static int
match_template ()
{
  /* Points to template once we've found it.  */
  const template *t;
  unsigned int overlap0, overlap1, overlap2;
  unsigned int found_reverse_match;
  int suffix_check;

#define MATCH(overlap, given, template)				\
  ((overlap & ~JumpAbsolute)					\
   && (((given) & (BaseIndex | JumpAbsolute))			\
       == ((overlap) & (BaseIndex | JumpAbsolute))))
d1897 1
a1897 42
  /* If given types r0 and r1 are registers they must be of the same type
     unless the expected operand type register overlap is null.
     Note that Acc in a template matches every size of reg.  */
#define CONSISTENT_REGISTER_MATCH(m0, g0, t0, m1, g1, t1)	\
  (((g0) & Reg) == 0 || ((g1) & Reg) == 0			\
   || ((g0) & Reg) == ((g1) & Reg)				\
   || ((((m0) & Acc) ? Reg : (t0)) & (((m1) & Acc) ? Reg : (t1)) & Reg) == 0 )

  overlap0 = 0;
  overlap1 = 0;
  overlap2 = 0;
  found_reverse_match = 0;
  suffix_check = (i.suffix == BYTE_MNEM_SUFFIX
		  ? No_bSuf
		  : (i.suffix == WORD_MNEM_SUFFIX
		     ? No_wSuf
		     : (i.suffix == SHORT_MNEM_SUFFIX
			? No_sSuf
			: (i.suffix == LONG_MNEM_SUFFIX
			   ? No_lSuf
			   : (i.suffix == QWORD_MNEM_SUFFIX
			      ? No_qSuf
			      : (i.suffix == LONG_DOUBLE_MNEM_SUFFIX
				 ? No_xSuf : 0))))));

  for (t = current_templates->start;
       t < current_templates->end;
       t++)
    {
      /* Must have right number of operands.  */
      if (i.operands != t->operands)
	continue;

      /* Check the suffix, except for some instructions in intel mode.  */
      if ((t->opcode_modifier & suffix_check)
	  && !(intel_syntax
	       && (t->opcode_modifier & IgnoreSize))
	  && !(intel_syntax
	       && t->base_opcode == 0xd9
	       && (t->extension_opcode == 5	     /* 0xd9,5 "fldcw"  */
		   || t->extension_opcode == 7)))  /* 0xd9,7 "f{n}stcw"  */
	continue;
d1899 3
a1901 8
      /* Do not verify operands when there are none.  */
      else if (!t->operands)
	{
	  if (t->cpu_flags & ~cpu_arch_flags)
	    continue;
	  /* We've found a match; break out of loop.  */
	  break;
	}
d1903 5
a1907 51
      overlap0 = i.types[0] & t->operand_types[0];
      switch (t->operands)
	{
	case 1:
	  if (!MATCH (overlap0, i.types[0], t->operand_types[0]))
	    continue;
	  break;
	case 2:
	case 3:
	  overlap1 = i.types[1] & t->operand_types[1];
	  if (!MATCH (overlap0, i.types[0], t->operand_types[0])
	      || !MATCH (overlap1, i.types[1], t->operand_types[1])
	      || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
					     t->operand_types[0],
					     overlap1, i.types[1],
					     t->operand_types[1]))
	    {
	      /* Check if other direction is valid ...  */
	      if ((t->opcode_modifier & (D | FloatD)) == 0)
		continue;

	      /* Try reversing direction of operands.  */
	      overlap0 = i.types[0] & t->operand_types[1];
	      overlap1 = i.types[1] & t->operand_types[0];
	      if (!MATCH (overlap0, i.types[0], t->operand_types[1])
		  || !MATCH (overlap1, i.types[1], t->operand_types[0])
		  || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
						 t->operand_types[1],
						 overlap1, i.types[1],
						 t->operand_types[0]))
		{
		  /* Does not match either direction.  */
		  continue;
		}
	      /* found_reverse_match holds which of D or FloatDR
		 we've found.  */
	      found_reverse_match = t->opcode_modifier & (D | FloatDR);
	    }
	  /* Found a forward 2 operand match here.  */
	  else if (t->operands == 3)
	    {
	      /* Here we make use of the fact that there are no
		 reverse match 3 operand instructions, and all 3
		 operand instructions only need to be checked for
		 register consistency between operands 2 and 3.  */
	      overlap2 = i.types[2] & t->operand_types[2];
	      if (!MATCH (overlap2, i.types[2], t->operand_types[2])
		  || !CONSISTENT_REGISTER_MATCH (overlap1, i.types[1],
						 t->operand_types[1],
						 overlap2, i.types[2],
						 t->operand_types[2]))
d1909 3
a1911 13
		continue;
	    }
	  /* Found either forward/reverse 2 or 3 operand match here:
	     slip through to break.  */
	}
      if (t->cpu_flags & ~cpu_arch_flags)
	{
	  found_reverse_match = 0;
	  continue;
	}
      /* We've found a match; break out of loop.  */
      break;
    }
d1913 30
a1942 7
  if (t == current_templates->end)
    {
      /* We found no match.  */
      as_bad (_("suffix or operands invalid for `%s'"),
	      current_templates->start->name);
      return 0;
    }
d1944 42
a1985 8
  if (!quiet_warnings)
    {
      if (!intel_syntax
	  && ((i.types[0] & JumpAbsolute)
	      != (t->operand_types[0] & JumpAbsolute)))
	{
	  as_warn (_("indirect %s without `*'"), t->name);
	}
d1987 8
a1994 8
      if ((t->opcode_modifier & (IsPrefix | IgnoreSize))
	  == (IsPrefix | IgnoreSize))
	{
	  /* Warn them that a data or address size prefix doesn't
	     affect assembly of the next line of code.  */
	  as_warn (_("stand-alone `%s' prefix"), t->name);
	}
    }
d1996 46
a2041 7
  /* Copy the template we found.  */
  i.tm = *t;
  if (found_reverse_match)
    {
      /* If we found a reverse match we must alter the opcode
	 direction bit.  found_reverse_match holds bits to change
	 (different for int & float insns).  */
d2043 43
a2085 1
      i.tm.base_opcode ^= found_reverse_match;
d2087 124
a2210 3
      i.tm.operand_types[0] = t->operand_types[1];
      i.tm.operand_types[1] = t->operand_types[0];
    }
d2212 13
a2224 2
  return 1;
}
d2226 2
a2227 31
static int
check_string ()
{
  int mem_op = (i.types[0] & AnyMem) ? 0 : 1;
  if ((i.tm.operand_types[mem_op] & EsSeg) != 0)
    {
      if (i.seg[0] != NULL && i.seg[0] != &es)
	{
	  as_bad (_("`%s' operand %d must use `%%es' segment"),
		  i.tm.name,
		  mem_op + 1);
	  return 0;
	}
      /* There's only ever one segment override allowed per instruction.
	 This instruction possibly has a legal segment override on the
	 second operand, so copy the segment to where non-string
	 instructions store it, allowing common code.  */
      i.seg[0] = i.seg[1];
    }
  else if ((i.tm.operand_types[mem_op + 1] & EsSeg) != 0)
    {
      if (i.seg[1] != NULL && i.seg[1] != &es)
	{
	  as_bad (_("`%s' operand %d must use `%%es' segment"),
		  i.tm.name,
		  mem_op + 2);
	  return 0;
	}
    }
  return 1;
}
d2229 1
a2229 79
static int
process_suffix ()
{
  /* If matched instruction specifies an explicit instruction mnemonic
     suffix, use it.  */
  if (i.tm.opcode_modifier & (Size16 | Size32 | Size64))
    {
      if (i.tm.opcode_modifier & Size16)
	i.suffix = WORD_MNEM_SUFFIX;
      else if (i.tm.opcode_modifier & Size64)
	i.suffix = QWORD_MNEM_SUFFIX;
      else
	i.suffix = LONG_MNEM_SUFFIX;
    }
  else if (i.reg_operands)
    {
      /* If there's no instruction mnemonic suffix we try to invent one
	 based on register operands.  */
      if (!i.suffix)
	{
	  /* We take i.suffix from the last register operand specified,
	     Destination register type is more significant than source
	     register type.  */
	  int op;
	  for (op = i.operands; --op >= 0;)
	    if ((i.types[op] & Reg)
		&& !(i.tm.operand_types[op] & InOutPortReg))
	      {
		i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
			    (i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
			    (i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
			    LONG_MNEM_SUFFIX);
		break;
	      }
	}
      else if (i.suffix == BYTE_MNEM_SUFFIX)
	{
	  if (!check_byte_reg ())
	    return 0;
	}
      else if (i.suffix == LONG_MNEM_SUFFIX)
	{
	  if (!check_long_reg ())
	    return 0;
	}
      else if (i.suffix == QWORD_MNEM_SUFFIX)
	{
	  if (!check_qword_reg ())
	    return 0;
	}
      else if (i.suffix == WORD_MNEM_SUFFIX)
	{
	  if (!check_word_reg ())
	    return 0;
	}
      else if (intel_syntax && (i.tm.opcode_modifier & IgnoreSize))
	/* Do nothing if the instruction is going to ignore the prefix.  */
	;
      else
	abort ();
    }
  else if ((i.tm.opcode_modifier & DefaultSize) && !i.suffix)
    {
      i.suffix = stackop_size;
    }

  /* Change the opcode based on the operand size given by i.suffix;
     We need not change things for byte insns.  */

  if (!i.suffix && (i.tm.opcode_modifier & W))
    {
      as_bad (_("no instruction mnemonic suffix given and no register operands; can't size instruction"));
      return 0;
    }

  /* For movzx and movsx, need to check the register type.  */
  if (intel_syntax
      && (i.tm.base_opcode == 0xfb6 || i.tm.base_opcode == 0xfbe))
    if (i.suffix && i.suffix == BYTE_MNEM_SUFFIX)
d2231 2
a2232 5
	unsigned int prefix = DATA_PREFIX_OPCODE;

	if ((i.op[1].regs->reg_type & Reg16) != 0)
	  if (!add_prefix (prefix))
	    return 0;
d2235 4
a2238 16
  if (i.suffix && i.suffix != BYTE_MNEM_SUFFIX)
    {
      /* It's not a byte, select word/dword operation.  */
      if (i.tm.opcode_modifier & W)
	{
	  if (i.tm.opcode_modifier & ShortForm)
	    i.tm.base_opcode |= 8;
	  else
	    i.tm.base_opcode |= 1;
	}
      /* Now select between word & dword operations via the operand
	 size prefix, except for instructions that will ignore this
	 prefix anyway.  */
      if (i.suffix != QWORD_MNEM_SUFFIX
	  && (i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
	  && !(i.tm.opcode_modifier & IgnoreSize))
a2240 2
	  if (i.tm.opcode_modifier & JumpByte) /* jcxz, loop */
	    prefix = ADDR_PREFIX_OPCODE;
d2242 3
a2244 2
	  if (!add_prefix (prefix))
	    return 0;
d2247 20
a2266 7
      if (i.suffix != QWORD_MNEM_SUFFIX && (flag_code == CODE_64BIT)
	  && !(i.tm.opcode_modifier & IgnoreSize)
	  && (i.tm.opcode_modifier & JumpByte))
	{
	  if (!add_prefix (ADDR_PREFIX_OPCODE))
	    return 0;
	}
d2268 3
a2270 11
      /* Set mode64 for an operand.  */
      if (i.suffix == QWORD_MNEM_SUFFIX
	  && (i.tm.opcode_modifier & NoRex64) == 0)
	{
	  i.rex |= REX_MODE64;
	  if (flag_code < CODE_64BIT)
	    {
	      as_bad (_("64bit operations available only in 64bit modes."));
	      return 0;
	    }
	}
d2272 7
a2278 7
      /* Size floating point instruction.  */
      if (i.suffix == LONG_MNEM_SUFFIX)
	{
	  if (i.tm.opcode_modifier & FloatMF)
	    i.tm.base_opcode ^= 4;
	}
    }
d2280 11
a2290 75
  return 1;
}

static int
check_byte_reg ()
{
  int op;
  for (op = i.operands; --op >= 0;)
    {
      /* If this is an eight bit register, it's OK.  If it's the 16 or
	 32 bit version of an eight bit register, we will just use the
	 low portion, and that's OK too.  */
      if (i.types[op] & Reg8)
	continue;

      /* movzx and movsx should not generate this warning.  */
      if (intel_syntax
	  && (i.tm.base_opcode == 0xfb7
	      || i.tm.base_opcode == 0xfb6
	      || i.tm.base_opcode == 0x63
	      || i.tm.base_opcode == 0xfbe
	      || i.tm.base_opcode == 0xfbf))
	continue;

      if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4
#if 0
	  /* Check that the template allows eight bit regs.  This
	     kills insns such as `orb $1,%edx', which maybe should be
	     allowed.  */
	  && (i.tm.operand_types[op] & (Reg8 | InOutPortReg))
#endif
	  )
	{
	  /* Prohibit these changes in the 64bit mode, since the
	     lowering is more complicated.  */
	  if (flag_code == CODE_64BIT
	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
	    {
	      as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
		      i.op[op].regs->reg_name,
		      i.suffix);
	      return 0;
	    }
#if REGISTER_WARNINGS
	  if (!quiet_warnings
	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
	    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		     (i.op[op].regs + (i.types[op] & Reg16
				       ? REGNAM_AL - REGNAM_AX
				       : REGNAM_AL - REGNAM_EAX))->reg_name,
		     i.op[op].regs->reg_name,
		     i.suffix);
#endif
	  continue;
	}
      /* Any other register is bad.  */
      if (i.types[op] & (Reg | RegMMX | RegXMM
			 | SReg2 | SReg3
			 | Control | Debug | Test
			 | FloatReg | FloatAcc))
	{
	  as_bad (_("`%%%s' not allowed with `%s%c'"),
		  i.op[op].regs->reg_name,
		  i.tm.name,
		  i.suffix);
	  return 0;
	}
    }
  return 1;
}

static int
check_long_reg ()
{
  int op;
d2292 2
a2293 20
  for (op = i.operands; --op >= 0;)
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
      {
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is missing.  */
    else if ((!quiet_warnings || flag_code == CODE_64BIT)
	     && (i.types[op] & Reg16) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (flag_code == CODE_64BIT)
d2295 2
a2296 4
	    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
		    i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
a2297 7
#if REGISTER_WARNINGS
	else
	  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		   (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
		   i.op[op].regs->reg_name,
		   i.suffix);
#endif
a2298 11
  /* Warn if the r prefix on a general reg is missing.  */
    else if ((i.types[op] & Reg64) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
      {
	as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
		i.op[op].regs->reg_name,
		i.suffix);
	return 0;
      }
  return 1;
}
d2300 1
a2300 10
static int
check_qword_reg ()
{
  int op;

  for (op = i.operands; --op >= 0; )
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
d2302 15
a2316 5
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
a2317 14
  /* Warn if the e prefix on a general reg is missing.  */
    else if (((i.types[op] & Reg16) != 0
	      || (i.types[op] & Reg32) != 0)
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
		i.op[op].regs->reg_name,
		i.suffix);
	return 0;
      }
  return 1;
}
d2319 2
a2320 9
static int
check_word_reg ()
{
  int op;
  for (op = i.operands; --op >= 0;)
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
d2322 9
a2330 14
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is present.  */
    else if ((!quiet_warnings || flag_code == CODE_64BIT)
	     && (i.types[op] & Reg32) != 0
	     && (i.tm.operand_types[op] & (Reg16 | Acc)) != 0)
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (flag_code == CODE_64BIT)
d2332 6
a2337 4
	    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
		    i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
a2338 10
	else
#if REGISTER_WARNINGS
	  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		   (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
		   i.op[op].regs->reg_name,
		   i.suffix);
#endif
      }
  return 1;
}
d2340 81
a2420 4
static int
finalize_imm ()
{
  unsigned int overlap0, overlap1, overlap2;
d2422 1
a2422 32
  overlap0 = i.types[0] & i.tm.operand_types[0];
  if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S))
      && overlap0 != Imm8 && overlap0 != Imm8S
      && overlap0 != Imm16 && overlap0 != Imm32S
      && overlap0 != Imm32 && overlap0 != Imm64)
    {
      if (i.suffix)
	{
	  overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX
		       ? Imm8 | Imm8S
		       : (i.suffix == WORD_MNEM_SUFFIX
			  ? Imm16
			  : (i.suffix == QWORD_MNEM_SUFFIX
			     ? Imm64 | Imm32S
			     : Imm32)));
	}
      else if (overlap0 == (Imm16 | Imm32S | Imm32)
	       || overlap0 == (Imm16 | Imm32)
	       || overlap0 == (Imm16 | Imm32S))
	{
	  overlap0 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
		      ? Imm16 : Imm32S);
	}
      if (overlap0 != Imm8 && overlap0 != Imm8S
	  && overlap0 != Imm16 && overlap0 != Imm32S
	  && overlap0 != Imm32 && overlap0 != Imm64)
	{
	  as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
	  return 0;
	}
    }
  i.types[0] = overlap0;
d2424 145
a2568 32
  overlap1 = i.types[1] & i.tm.operand_types[1];
  if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32))
      && overlap1 != Imm8 && overlap1 != Imm8S
      && overlap1 != Imm16 && overlap1 != Imm32S
      && overlap1 != Imm32 && overlap1 != Imm64)
    {
      if (i.suffix)
	{
	  overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX
		       ? Imm8 | Imm8S
		       : (i.suffix == WORD_MNEM_SUFFIX
			  ? Imm16
			  : (i.suffix == QWORD_MNEM_SUFFIX
			     ? Imm64 | Imm32S
			     : Imm32)));
	}
      else if (overlap1 == (Imm16 | Imm32 | Imm32S)
	       || overlap1 == (Imm16 | Imm32)
	       || overlap1 == (Imm16 | Imm32S))
	{
	  overlap1 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
		      ? Imm16 : Imm32S);
	}
      if (overlap1 != Imm8 && overlap1 != Imm8S
	  && overlap1 != Imm16 && overlap1 != Imm32S
	  && overlap1 != Imm32 && overlap1 != Imm64)
	{
	  as_bad (_("no instruction mnemonic suffix given; can't determine immediate size %x %c"),overlap1, i.suffix);
	  return 0;
	}
    }
  i.types[1] = overlap1;
d2570 15
a2584 296
  overlap2 = i.types[2] & i.tm.operand_types[2];
  assert ((overlap2 & Imm) == 0);
  i.types[2] = overlap2;

  return 1;
}

static int
process_operands ()
{
  /* Default segment register this instruction will use for memory
     accesses.  0 means unknown.  This is only for optimizing out
     unnecessary segment overrides.  */
  const seg_entry *default_seg = 0;

  /* The imul $imm, %reg instruction is converted into
     imul $imm, %reg, %reg, and the clr %reg instruction
     is converted into xor %reg, %reg.  */
  if (i.tm.opcode_modifier & regKludge)
    {
      unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
      /* Pretend we saw the extra register operand.  */
      assert (i.op[first_reg_op + 1].regs == 0);
      i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
      i.types[first_reg_op + 1] = i.types[first_reg_op];
      i.reg_operands = 2;
    }

  if (i.tm.opcode_modifier & ShortForm)
    {
      /* The register or float register operand is in operand 0 or 1.  */
      unsigned int op = (i.types[0] & (Reg | FloatReg)) ? 0 : 1;
      /* Register goes in low 3 bits of opcode.  */
      i.tm.base_opcode |= i.op[op].regs->reg_num;
      if ((i.op[op].regs->reg_flags & RegRex) != 0)
	i.rex |= REX_EXTZ;
      if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
	{
	  /* Warn about some common errors, but press on regardless.
	     The first case can be generated by gcc (<= 2.8.1).  */
	  if (i.operands == 2)
	    {
	      /* Reversed arguments on faddp, fsubp, etc.  */
	      as_warn (_("translating to `%s %%%s,%%%s'"), i.tm.name,
		       i.op[1].regs->reg_name,
		       i.op[0].regs->reg_name);
	    }
	  else
	    {
	      /* Extraneous `l' suffix on fp insn.  */
	      as_warn (_("translating to `%s %%%s'"), i.tm.name,
		       i.op[0].regs->reg_name);
	    }
	}
    }
  else if (i.tm.opcode_modifier & Modrm)
    {
      /* The opcode is completed (modulo i.tm.extension_opcode which
	 must be put into the modrm byte).
	 Now, we make the modrm & index base bytes based on all the
	 info we've collected.  */

      default_seg = build_modrm_byte ();
    }
  else if (i.tm.opcode_modifier & (Seg2ShortForm | Seg3ShortForm))
    {
      if (i.tm.base_opcode == POP_SEG_SHORT
	  && i.op[0].regs->reg_num == 1)
	{
	  as_bad (_("you can't `pop %%cs'"));
	  return 0;
	}
      i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
      if ((i.op[0].regs->reg_flags & RegRex) != 0)
	i.rex |= REX_EXTZ;
    }
  else if ((i.tm.base_opcode & ~(D | W)) == MOV_AX_DISP32)
    {
      default_seg = &ds;
    }
  else if ((i.tm.opcode_modifier & IsString) != 0)
    {
      /* For the string instructions that allow a segment override
	 on one of their operands, the default segment is ds.  */
      default_seg = &ds;
    }

  /* If a segment was explicitly specified,
     and the specified segment is not the default,
     use an opcode prefix to select it.
     If we never figured out what the default segment is,
     then default_seg will be zero at this point,
     and the specified segment prefix will always be used.  */
  if ((i.seg[0]) && (i.seg[0] != default_seg))
    {
      if (!add_prefix (i.seg[0]->seg_prefix))
	return 0;
    }
  return 1;
}

static const seg_entry *
build_modrm_byte ()
{
  const seg_entry *default_seg = 0;

  /* i.reg_operands MUST be the number of real register operands;
     implicit registers do not count.  */
  if (i.reg_operands == 2)
    {
      unsigned int source, dest;
      source = ((i.types[0]
		 & (Reg | RegMMX | RegXMM
		    | SReg2 | SReg3
		    | Control | Debug | Test))
		? 0 : 1);
      dest = source + 1;

      i.rm.mode = 3;
      /* One of the register operands will be encoded in the i.tm.reg
	 field, the other in the combined i.tm.mode and i.tm.regmem
	 fields.  If no form of this instruction supports a memory
	 destination operand, then we assume the source operand may
	 sometimes be a memory operand and so we need to store the
	 destination in the i.rm.reg field.  */
      if ((i.tm.operand_types[dest] & AnyMem) == 0)
	{
	  i.rm.reg = i.op[dest].regs->reg_num;
	  i.rm.regmem = i.op[source].regs->reg_num;
	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTX;
	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTZ;
	}
      else
	{
	  i.rm.reg = i.op[source].regs->reg_num;
	  i.rm.regmem = i.op[dest].regs->reg_num;
	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTZ;
	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTX;
	}
    }
  else
    {			/* If it's not 2 reg operands...  */
      if (i.mem_operands)
	{
	  unsigned int fake_zero_displacement = 0;
	  unsigned int op = ((i.types[0] & AnyMem)
			     ? 0
			     : (i.types[1] & AnyMem) ? 1 : 2);

	  default_seg = &ds;

	  if (i.base_reg == 0)
	    {
	      i.rm.mode = 0;
	      if (!i.disp_operands)
		fake_zero_displacement = 1;
	      if (i.index_reg == 0)
		{
		  /* Operand is just <disp>  */
		  if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
		      && (flag_code != CODE_64BIT))
		    {
		      i.rm.regmem = NO_BASE_REGISTER_16;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp16;
		    }
		  else if (flag_code != CODE_64BIT
			   || (i.prefix[ADDR_PREFIX] != 0))
		    {
		      i.rm.regmem = NO_BASE_REGISTER;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp32;
		    }
		  else
		    {
		      /* 64bit mode overwrites the 32bit absolute
			 addressing by RIP relative addressing and
			 absolute addressing is encoded by one of the
			 redundant SIB forms.  */
		      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		      i.sib.base = NO_BASE_REGISTER;
		      i.sib.index = NO_INDEX_REGISTER;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp32S;
		    }
		}
	      else /* !i.base_reg && i.index_reg  */
		{
		  i.sib.index = i.index_reg->reg_num;
		  i.sib.base = NO_BASE_REGISTER;
		  i.sib.scale = i.log2_scale_factor;
		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		  i.types[op] &= ~Disp;
		  if (flag_code != CODE_64BIT)
		    i.types[op] |= Disp32;	/* Must be 32 bit */
		  else
		    i.types[op] |= Disp32S;
		  if ((i.index_reg->reg_flags & RegRex) != 0)
		    i.rex |= REX_EXTY;
		}
	    }
	  /* RIP addressing for 64bit mode.  */
	  else if (i.base_reg->reg_type == BaseIndex)
	    {
	      i.rm.regmem = NO_BASE_REGISTER;
	      i.types[op] &= ~Disp;
	      i.types[op] |= Disp32S;
	      i.flags[op] = Operand_PCrel;
	    }
	  else if (i.base_reg->reg_type & Reg16)
	    {
	      switch (i.base_reg->reg_num)
		{
		case 3: /* (%bx)  */
		  if (i.index_reg == 0)
		    i.rm.regmem = 7;
		  else /* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
		    i.rm.regmem = i.index_reg->reg_num - 6;
		  break;
		case 5: /* (%bp)  */
		  default_seg = &ss;
		  if (i.index_reg == 0)
		    {
		      i.rm.regmem = 6;
		      if ((i.types[op] & Disp) == 0)
			{
			  /* fake (%bp) into 0(%bp)  */
			  i.types[op] |= Disp8;
			  fake_zero_displacement = 1;
			}
		    }
		  else /* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
		    i.rm.regmem = i.index_reg->reg_num - 6 + 2;
		  break;
		default: /* (%si) -> 4 or (%di) -> 5  */
		  i.rm.regmem = i.base_reg->reg_num - 6 + 4;
		}
	      i.rm.mode = mode_from_disp_size (i.types[op]);
	    }
	  else /* i.base_reg and 32/64 bit mode  */
	    {
	      if (flag_code == CODE_64BIT
		  && (i.types[op] & Disp))
		{
		  if (i.types[op] & Disp8)
		    i.types[op] = Disp8 | Disp32S;
		  else
		    i.types[op] = Disp32S;
		}
	      i.rm.regmem = i.base_reg->reg_num;
	      if ((i.base_reg->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTZ;
	      i.sib.base = i.base_reg->reg_num;
	      /* x86-64 ignores REX prefix bit here to avoid decoder
		 complications.  */
	      if ((i.base_reg->reg_num & 7) == EBP_REG_NUM)
		{
		  default_seg = &ss;
		  if (i.disp_operands == 0)
		    {
		      fake_zero_displacement = 1;
		      i.types[op] |= Disp8;
		    }
		}
	      else if (i.base_reg->reg_num == ESP_REG_NUM)
		{
		  default_seg = &ss;
		}
	      i.sib.scale = i.log2_scale_factor;
	      if (i.index_reg == 0)
		{
		  /* <disp>(%esp) becomes two byte modrm with no index
		     register.  We've already stored the code for esp
		     in i.rm.regmem ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.
		     Any base register besides %esp will not use the
		     extra modrm byte.  */
		  i.sib.index = NO_INDEX_REGISTER;
#if !SCALE1_WHEN_NO_INDEX
		  /* Another case where we force the second modrm byte.  */
		  if (i.log2_scale_factor)
		    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
#endif
		}
	      else
		{
		  i.sib.index = i.index_reg->reg_num;
		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		  if ((i.index_reg->reg_flags & RegRex) != 0)
		    i.rex |= REX_EXTY;
		}
	      i.rm.mode = mode_from_disp_size (i.types[op]);
	    }
d2586 33
a2618 15
	  if (fake_zero_displacement)
	    {
	      /* Fakes a zero displacement assuming that i.types[op]
		 holds the correct displacement size.  */
	      expressionS *exp;

	      assert (i.op[op].disps == 0);
	      exp = &disp_expressions[i.disp_operands++];
	      i.op[op].disps = exp;
	      exp->X_op = O_constant;
	      exp->X_add_number = 0;
	      exp->X_add_symbol = (symbolS *) 0;
	      exp->X_op_symbol = (symbolS *) 0;
	    }
	}
d2620 34
a2653 32
      /* Fill in i.rm.reg or i.rm.regmem field with register operand
	 (if any) based on i.tm.extension_opcode.  Again, we must be
	 careful to make sure that segment/control/debug/test/MMX
	 registers are coded into the i.rm.reg field.  */
      if (i.reg_operands)
	{
	  unsigned int op =
	    ((i.types[0]
	      & (Reg | RegMMX | RegXMM
		 | SReg2 | SReg3
		 | Control | Debug | Test))
	     ? 0
	     : ((i.types[1]
		 & (Reg | RegMMX | RegXMM
		    | SReg2 | SReg3
		    | Control | Debug | Test))
		? 1
		: 2));
	  /* If there is an extension opcode to put here, the register
	     number must be put into the regmem field.  */
	  if (i.tm.extension_opcode != None)
	    {
	      i.rm.regmem = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTZ;
	    }
	  else
	    {
	      i.rm.reg = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTX;
	    }
d2655 18
a2672 6
	  /* Now, if no memory operand has set i.rm.mode = 0, 1, 2 we
	     must set it to 3 to indicate this is a register operand
	     in the regmem field.  */
	  if (!i.mem_operands)
	    i.rm.mode = 3;
	}
d2674 5
a2678 3
      /* Fill in i.rm.reg field with extension opcode (if any).  */
      if (i.tm.extension_opcode != None)
	i.rm.reg = i.tm.extension_opcode;
a2679 2
  return default_seg;
}
d2681 2
a2682 67
static void
output_branch ()
{
  char *p;
  int code16;
  int prefix;
  relax_substateT subtype;
  symbolS *sym;
  offsetT off;

  code16 = 0;
  if (flag_code == CODE_16BIT)
    code16 = CODE16;

  prefix = 0;
  if (i.prefix[DATA_PREFIX] != 0)
    {
      prefix = 1;
      i.prefixes -= 1;
      code16 ^= CODE16;
    }
  /* Pentium4 branch hints.  */
  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
    {
      prefix++;
      i.prefixes--;
    }
  if (i.prefix[REX_PREFIX] != 0)
    {
      prefix++;
      i.prefixes--;
    }

  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));

  /* It's always a symbol;  End frag & setup for relax.
     Make sure there is enough room in this frag for the largest
     instruction we may generate in md_convert_frag.  This is 2
     bytes for the opcode and room for the prefix and largest
     displacement.  */
  frag_grow (prefix + 2 + 4);
  /* Prefix and 1 opcode byte go in fr_fix.  */
  p = frag_more (prefix + 1);
  if (i.prefix[DATA_PREFIX] != 0)
    *p++ = DATA_PREFIX_OPCODE;
  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
    *p++ = i.prefix[SEG_PREFIX];
  if (i.prefix[REX_PREFIX] != 0)
    *p++ = i.prefix[REX_PREFIX];
  *p = i.tm.base_opcode;

  if ((unsigned char) *p == JUMP_PC_RELATIVE)
    subtype = ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL);
  else if ((cpu_arch_flags & Cpu386) != 0)
    subtype = ENCODE_RELAX_STATE (COND_JUMP, SMALL);
  else
    subtype = ENCODE_RELAX_STATE (COND_JUMP86, SMALL);
  subtype |= code16;

  sym = i.op[0].disps->X_add_symbol;
  off = i.op[0].disps->X_add_number;

  if (i.op[0].disps->X_op != O_constant
      && i.op[0].disps->X_op != O_symbol)
d2684 5
a2688 3
      /* Handle complex expressions.  */
      sym = make_expr_symbol (i.op[0].disps);
      off = 0;
d2691 2
a2692 11
  /* 1 possible extra opcode + 4 byte displacement go in var part.
     Pass reloc in fr_var.  */
  frag_var (rs_machine_dependent, 5, i.reloc[0], subtype, sym, off, p);
}

static void
output_jump ()
{
  char *p;
  int size;
  fixS *fixP;
d2694 8
a2701 1
  if (i.tm.opcode_modifier & JumpByte)
d2703 3
a2705 3
      /* This is a loop or jecxz type instruction.  */
      size = 1;
      if (i.prefix[ADDR_PREFIX] != 0)
d2707 15
a2721 9
	  FRAG_APPEND_1_CHAR (ADDR_PREFIX_OPCODE);
	  i.prefixes -= 1;
	}
      /* Pentium4 branch hints.  */
      if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
	  || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	{
	  FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
	  i.prefixes--;
a2723 3
  else
    {
      int code16;
d2725 28
a2752 3
      code16 = 0;
      if (flag_code == CODE_16BIT)
	code16 = CODE16;
d2754 19
a2772 6
      if (i.prefix[DATA_PREFIX] != 0)
	{
	  FRAG_APPEND_1_CHAR (DATA_PREFIX_OPCODE);
	  i.prefixes -= 1;
	  code16 ^= CODE16;
	}
d2774 2
a2775 4
      size = 4;
      if (code16)
	size = 2;
    }
d2777 24
a2800 5
  if (i.prefix[REX_PREFIX] != 0)
    {
      FRAG_APPEND_1_CHAR (i.prefix[REX_PREFIX]);
      i.prefixes -= 1;
    }
d2802 2
a2803 2
  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));
d2805 7
a2811 2
  p = frag_more (1 + size);
  *p++ = i.tm.base_opcode;
d2813 8
a2820 4
  fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
  fixP->fx_pcrel_adjust = size;
}
d2822 20
a2841 7
static void
output_interseg_jump ()
{
  char *p;
  int size;
  int prefix;
  int code16;
d2843 3
a2845 3
  code16 = 0;
  if (flag_code == CODE_16BIT)
    code16 = CODE16;
d2847 6
a2852 12
  prefix = 0;
  if (i.prefix[DATA_PREFIX] != 0)
    {
      prefix = 1;
      i.prefixes -= 1;
      code16 ^= CODE16;
    }
  if (i.prefix[REX_PREFIX] != 0)
    {
      prefix++;
      i.prefixes -= 1;
    }
d2854 4
a2857 3
  size = 4;
  if (code16)
    size = 2;
d2859 5
a2863 2
  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));
d2865 2
a2866 2
  /* 1 opcode; 2 segment; offset  */
  p = frag_more (prefix + 1 + 2 + size);
d2868 2
a2869 2
  if (i.prefix[DATA_PREFIX] != 0)
    *p++ = DATA_PREFIX_OPCODE;
d2871 13
a2883 2
  if (i.prefix[REX_PREFIX] != 0)
    *p++ = i.prefix[REX_PREFIX];
d2885 12
a2896 4
  *p++ = i.tm.base_opcode;
  if (i.op[1].imms->X_op == O_constant)
    {
      offsetT n = i.op[1].imms->X_add_number;
d2898 3
a2900 17
      if (size == 2
	  && !fits_in_unsigned_word (n)
	  && !fits_in_signed_word (n))
	{
	  as_bad (_("16-bit jump out of range"));
	  return;
	}
      md_number_to_chars (p, n, size);
    }
  else
    fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		 i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
  if (i.op[0].imms->X_op != O_constant)
    as_bad (_("can't handle non absolute segment in `%s'"),
	    i.tm.name);
  md_number_to_chars (p + size, (valueT) i.op[0].imms->X_add_number, 2);
}
d2902 2
a2903 20
static void
output_insn ()
{
  /* Tie dwarf2 debug info to the address at the start of the insn.
     We can't do this after the insn has been output as the current
     frag may have been closed off.  eg. by frag_var.  */
  dwarf2_emit_insn (0);

  /* Output jumps.  */
  if (i.tm.opcode_modifier & Jump)
    output_branch ();
  else if (i.tm.opcode_modifier & (JumpByte | JumpDword))
    output_jump ();
  else if (i.tm.opcode_modifier & JumpInterSegment)
    output_interseg_jump ();
  else
    {
      /* Output normal instructions here.  */
      char *p;
      unsigned char *q;
d2905 2
a2906 16
      /* All opcodes on i386 have either 1 or 2 bytes.  We may use third
	 byte for the SSE instructions to specify a prefix they require.  */
      if (i.tm.base_opcode & 0xff0000)
	add_prefix ((i.tm.base_opcode >> 16) & 0xff);

      /* The prefix bytes.  */
      for (q = i.prefix;
	   q < i.prefix + sizeof (i.prefix) / sizeof (i.prefix[0]);
	   q++)
	{
	  if (*q)
	    {
	      p = frag_more (1);
	      md_number_to_chars (p, (valueT) *q, 1);
	    }
	}
d2908 2
a2909 12
      /* Now the opcode; be careful about word order here!  */
      if (fits_in_unsigned_byte (i.tm.base_opcode))
	{
	  FRAG_APPEND_1_CHAR (i.tm.base_opcode);
	}
      else
	{
	  p = frag_more (2);
	  /* Put out high byte first: can't use md_number_to_chars!  */
	  *p++ = (i.tm.base_opcode >> 8) & 0xff;
	  *p = i.tm.base_opcode & 0xff;
	}
d2911 2
a2912 25
      /* Now the modrm byte and sib byte (if present).  */
      if (i.tm.opcode_modifier & Modrm)
	{
	  p = frag_more (1);
	  md_number_to_chars (p,
			      (valueT) (i.rm.regmem << 0
					| i.rm.reg << 3
					| i.rm.mode << 6),
			      1);
	  /* If i.rm.regmem == ESP (4)
	     && i.rm.mode != (Register mode)
	     && not 16 bit
	     ==> need second modrm byte.  */
	  if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
	      && i.rm.mode != 3
	      && !(i.base_reg && (i.base_reg->reg_type & Reg16) != 0))
	    {
	      p = frag_more (1);
	      md_number_to_chars (p,
				  (valueT) (i.sib.base << 0
					    | i.sib.index << 3
					    | i.sib.scale << 6),
				  1);
	    }
	}
d2914 4
a2917 2
      if (i.disp_operands)
	output_disp ();
d2919 21
a2939 3
      if (i.imm_operands)
	output_imm ();
    }
d2941 16
a2956 7
#ifdef DEBUG386
  if (flag_debug)
    {
      pi (line, &i);
    }
#endif /* DEBUG386  */
}
d2958 12
a2969 5
static void
output_disp ()
{
  char *p;
  unsigned int n;
d2971 25
a2995 8
  for (n = 0; n < i.operands; n++)
    {
      if (i.types[n] & Disp)
	{
	  if (i.op[n].disps->X_op == O_constant)
	    {
	      int size;
	      offsetT val;
d2997 3
a2999 28
	      size = 4;
	      if (i.types[n] & (Disp8 | Disp16 | Disp64))
		{
		  size = 2;
		  if (i.types[n] & Disp8)
		    size = 1;
		  if (i.types[n] & Disp64)
		    size = 8;
		}
	      val = offset_in_range (i.op[n].disps->X_add_number,
				     size);
	      p = frag_more (size);
	      md_number_to_chars (p, val, size);
	    }
	  else
	    {
	      int size = 4;
	      int sign = 0;
	      int pcrel = (i.flags[n] & Operand_PCrel) != 0;
	      fixS *fixP;

	      /* The PC relative address is computed relative
		 to the instruction boundary, so in case immediate
		 fields follows, we need to adjust the value.  */
	      if (pcrel && i.imm_operands)
		{
		  int imm_size = 4;
		  unsigned int n1;
d3001 5
a3005 2
		  for (n1 = 0; n1 < i.operands; n1++)
		    if (i.types[n1] & Imm)
d3007 5
a3011 1
			if (i.types[n1] & (Imm8 | Imm8S | Imm16 | Imm64))
d3013 5
a3017 5
			    imm_size = 2;
			    if (i.types[n1] & (Imm8 | Imm8S))
			      imm_size = 1;
			    if (i.types[n1] & Imm64)
			      imm_size = 8;
d3019 4
a3022 1
			break;
d3024 33
a3056 5
		  /* We should find the immediate.  */
		  if (n1 == i.operands)
		    abort ();
		  i.op[n].disps->X_add_number -= imm_size;
		}
d3058 2
a3059 2
	      if (i.types[n] & Disp32S)
		sign = 1;
d3061 6
a3066 6
	      if (i.types[n] & (Disp16 | Disp64))
		{
		  size = 2;
		  if (i.types[n] & Disp64)
		    size = 8;
		}
d3068 10
a3077 10
	      p = frag_more (size);
	      fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
				  i.op[n].disps, pcrel,
				  reloc (size, pcrel, sign, i.reloc[n]));
	      if (pcrel)
		fixP->fx_pcrel_adjust = size;
	    }
	}
    }
}
d3079 4
a3082 5
static void
output_imm ()
{
  char *p;
  unsigned int n;
d3084 8
a3091 8
  for (n = 0; n < i.operands; n++)
    {
      if (i.types[n] & Imm)
	{
	  if (i.op[n].imms->X_op == O_constant)
	    {
	      int size;
	      offsetT val;
d3093 35
a3127 35
	      size = 4;
	      if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
		{
		  size = 2;
		  if (i.types[n] & (Imm8 | Imm8S))
		    size = 1;
		  else if (i.types[n] & Imm64)
		    size = 8;
		}
	      val = offset_in_range (i.op[n].imms->X_add_number,
				     size);
	      p = frag_more (size);
	      md_number_to_chars (p, val, size);
	    }
	  else
	    {
	      /* Not absolute_section.
		 Need a 32-bit fixup (don't support 8bit
		 non-absolute imms).  Try to support other
		 sizes ...  */
	      RELOC_ENUM reloc_type;
	      int size = 4;
	      int sign = 0;

	      if ((i.types[n] & (Imm32S))
		  && i.suffix == QWORD_MNEM_SUFFIX)
		sign = 1;
	      if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
		{
		  size = 2;
		  if (i.types[n] & (Imm8 | Imm8S))
		    size = 1;
		  if (i.types[n] & Imm64)
		    size = 8;
		}
d3129 2
a3130 2
	      p = frag_more (size);
	      reloc_type = reloc (size, 0, sign, i.reloc[n]);
d3132 15
a3146 15
	      if (reloc_type == BFD_RELOC_32
		  && GOT_symbol
		  && GOT_symbol == i.op[n].imms->X_add_symbol
		  && (i.op[n].imms->X_op == O_symbol
		      || (i.op[n].imms->X_op == O_add
			  && ((symbol_get_value_expression
			       (i.op[n].imms->X_op_symbol)->X_op)
			      == O_subtract))))
		{
		  /* We don't support dynamic linking on x86-64 yet.  */
		  if (flag_code == CODE_64BIT)
		    abort ();
		  reloc_type = BFD_RELOC_386_GOTPC;
		  i.op[n].imms->X_add_number += 3;
		}
d3148 15
a3162 5
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].imms, 0, reloc_type);
	    }
	}
    }
d3434 1
a3434 1
  if (i.log2_scale_factor != 0 && i.index_reg == 0)
d3454 1
a3454 1
  expressionS *exp;
d3464 2
a3465 2
      if (i.prefix[ADDR_PREFIX] == 0)
	bigdisp = Disp64;
d3565 1
a3565 1
	i.reloc[this_operand] = BFD_RELOC_32_PCREL;
d3567 1
a3567 1
	i.reloc[this_operand] = BFD_RELOC_32;
d3631 2
a3632 2
		  && ((i.index_reg->reg_type & (Reg64 | BaseIndex))
		      != (Reg64 | BaseIndex))))
d3641 2
a3642 2
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
		      != (Reg32 | BaseIndex))))
d3652 2
a3653 2
	       && ((i.base_reg->reg_type & (Reg16 | BaseIndex | RegRex))
		   != (Reg16 | BaseIndex)))
d3655 6
a3660 6
		  && (((i.index_reg->reg_type & (Reg16 | BaseIndex))
		       != (Reg16 | BaseIndex))
		      || !(i.base_reg
			   && i.base_reg->reg_num < 6
			   && i.index_reg->reg_num >= 6
			   && i.log2_scale_factor == 0))))
d3669 2
a3670 2
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
		      != (Reg32 | BaseIndex))))
d3687 2
a3688 2
	  if (i.types[this_operand] & (Disp16 | Disp32))
	     i.types[this_operand] ^= (Disp16 | Disp32);
d4007 2
a4008 2
     fragS *fragP;
     segT segment;
d4125 1
a4125 1
     fragS *fragP;
d4131 1
a4131 1
     fragS *fragP;
d4134 1
a4134 1
  unsigned char *opcode;
d4316 2
a4317 2
	      && !S_IS_EXTERNAL (fixP->fx_addsy)
	      && !S_IS_WEAK (fixP->fx_addsy)
d4319 1
a4319 1
	      && !S_IS_COMMON (fixP->fx_addsy))
d4557 1
a4557 1
      && (r->reg_flags & (RegRex64 | RegRex)) != 0
d4611 1
a4611 1
	 .stab instead of .stab.excl.  We always use .stab anyhow.  */
d4808 1
a4808 1
  int temp;
a4893 1
#ifdef BFD64
a4894 1
#endif
d4949 1
a4949 1
#else /* !BFD_ASSEMBLER  */
d5015 1
a5015 1
#endif /* !BFD_ASSEMBLER  */
@


1.108.2.5
log
@	* as.c (parse_args <OPTION_VERSION>): Use VERSION is
	BFD_VERSION_STRING unavailable.
	* config/tc-i386.c (INLINE): Define (for non-BFD assembler).
@
text
@a60 8
#ifndef INLINE
#if __GNUC__ >= 2
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

@


1.108.2.6
log
@	* config/tc-i386.c (output_jump, output_disp)
	(md_estimate_size_before_relax): Don't set fx_pcrel_adjust any
	more.
	(md_apply_fix3): Remember addend value for rela relocations.
	(tc_gen_reloc): Correctly compute pc-relative relocation addend.
@
text
@d2983 1
d3034 3
a3036 2
  fix_new_exp (frag_now, p - frag_now->fr_literal, size,
	       i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
d3229 1
d3269 5
a3273 3
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].disps, pcrel,
			   reloc (size, pcrel, sign, i.reloc[n]));
d4218 1
d4236 5
a4240 4
	  fix_new (fragP, old_fr_fix, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
d4258 5
a4262 4
	      fix_new (fragP, old_fr_fix + 2, 2,
		       fragP->fr_symbol,
		       fragP->fr_offset, 1,
		       reloc_type);
d4277 5
a4281 4
	  fix_new (fragP, old_fr_fix + 1, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
a4609 2
      /* Remember value for tc_gen_reloc.  */
      fixP->fx_addnumber = value;
d5123 3
a5125 17
      if (!fixp->fx_pcrel)
	rel->addend = fixp->fx_offset;
      else
	switch (code)
	  {
	  case BFD_RELOC_X86_64_PLT32:
	  case BFD_RELOC_X86_64_GOT32:
	  case BFD_RELOC_X86_64_GOTPCREL:
	    rel->addend = fixp->fx_offset - fixp->fx_size;
	    break;
	  default:
	    rel->addend = (section->vma
			   - fixp->fx_size
			   + fixp->fx_addnumber
			   + md_pcrel_from (fixp));
	    break;
	  }
@


1.108.2.7
log
@Merge from mainline
@
text
@d185 1
a185 1
const char extra_symbol_chars[] = "*%-(@@[";
d187 1
a187 1
const char extra_symbol_chars[] = "*%-([";
d2211 4
a2214 4
      && (i.tm.base_opcode == 0xfb6 || i.tm.base_opcode == 0xfbe)
      && i.suffix == BYTE_MNEM_SUFFIX)
    {
      unsigned int prefix = DATA_PREFIX_OPCODE;
d2216 4
a2219 4
      if ((i.op[1].regs->reg_type & Reg16) != 0)
	if (!add_prefix (prefix))
	  return 0;
    }
a2230 1

d2312 1
a2312 1
	      as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
d2371 1
a2371 1
	    as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
d2388 1
a2388 1
	as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
d2420 1
a2420 1
	as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
d2453 1
a2453 1
	    as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
d4237 4
a4240 2
	  if (size == 2
	      && (!no_cond_jump_promotion || fragP->fr_var != NO_RELOC))
d4260 2
a4261 9
	  if (no_cond_jump_promotion && fragP->fr_var == NO_RELOC)
	    {
	      fragP->fr_fix += 1;
	      fix_new (fragP, old_fr_fix, 1,
		       fragP->fr_symbol,
		       fragP->fr_offset, 1,
		       BFD_RELOC_8_PCREL);
	      break;
	    }
d4283 1
@


1.107
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d51 1
d53 2
d56 1
@


1.106
log
@	* config/tc-i386.h (md_end): Define.
	(i386_elf_emit_arch_note): Declare.
	(CpuUnknown): Delete.
	* config/tc-i386.c (default_arch): Constify.
	(smallest_imm_type): Remove CpuUnknown test.
	(md_assemble): Don't bother checking cpu_arch_flags non-zero.
	(i386_elf_emit_arch_note): New function.
@
text
@d4214 2
a4215 2
int
md_apply_fix3 (fixP, valp, seg)
a4217 1

d4219 1
a4219 2
     valueT *valp;

d4223 2
a4224 2
  register char *p = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT value = *valp;
d4358 1
a4358 1
	return 1;
d4364 1
a4364 1
  *valp = value;
a4366 3
#ifndef BFD_ASSEMBLER
  md_number_to_chars (p, value, fixP->fx_size);
#else
d4368 1
a4368 1
  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
d4370 1
d4376 1
a4377 3
#endif

  return 1;
@


1.105
log
@	* config/tc-i386.c (parse_register): If not producing code for
	x86_64, reject x86_64 register name matches.
	(md_assemble): Remove now redundant check for x86_64 regs.
@
text
@d80 1
a80 1
static char *default_arch = DEFAULT_ARCH;
d542 1
a542 2
  if (cpu_arch_flags != (Cpu086 | Cpu186 | Cpu286 | Cpu386 | Cpu486 | CpuNo64)
      && !(cpu_arch_flags & (CpuUnknown)))
d1395 2
a1396 1
    if (cpu_arch_flags != 0)
d1398 6
a1403 10
	if ((current_templates->start->cpu_flags & ~(Cpu64 | CpuNo64))
	    & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64)))
	  {
	    as_warn (_("`%s' is not supported on `%s'"),
		     current_templates->start->name, cpu_arch_name);
	  }
	else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
	  {
	    as_warn (_("use .code16 to ensure correct addressing mode"));
	  }
d4660 42
@


1.104
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a1937 13
    if (i.reg_operands && flag_code < CODE_64BIT)
      {
	int op;
	for (op = i.operands; --op >= 0;)
	  if ((i.types[op] & Reg)
	      && (i.op[op].regs->reg_flags & (RegRex64|RegRex)))
	    {
	      as_bad (_("Extended register `%%%s' available only in 64bit mode."),
		      i.op[op].regs->reg_name);
	      return;
	    }
      }

d4519 7
@


1.103
log
@	* expr.c (expr): Move code setting "retval" to the end of the loop,
	and rearrange for efficiency.  For "PIC code" subtraction, use
	"rightseg" rather than recalculating.  For "symbol OP symbol"
	subtract, set "retval" to absolute_section if symbols in same
	section.
	* symbols.c (resolve_symbol_value): Resolve "sym +/- expr" to an
	O_symbol.  Simplify a +/- b code.  Allow equality and non-equality
	comparisons on symbols from any section.  Allow other comparison
	operators as for subtraction.
	(symbol_equated_reloc_p): New predicate function.
	* symbols.h (symbol_equated_reloc_p): Declare.
	* write.c (adjust_reloc_syms): Use symbol_equated_reloc_p.
	(write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_segment <rs_machine_dependent>): Ensure segment for
	expression syms is set correctly.
	* config/tc-mips.c (md_estimate_size_before_relax): Likewise.
	* config/tc-i386.c (md_assemble <Output jumps>): Don't lose part
	of a complex expression when setting up frag_var.
@
text
@a28 2
#include <ctype.h>

d30 1
d893 1
a893 1
	if (isdigit (c))
d900 1
a900 1
	else if (islower (c))
d906 1
a906 1
	else if (isupper (c))
d908 1
a908 1
	    mnemonic_chars[c] = tolower (c);
d913 1
a913 1
	if (isalpha (c) || isdigit (c))
d4463 1
a4463 1
  if (isprint (c))
@


1.102
log
@	* config/tc-i386.c (lex_got): Match lower case relocation tokens.
	Don't allocate more space than necessary for the input line copy.
@
text
@d2744 3
d2791 21
a2811 1
	/* 1 possible extra opcode + displacement go in var part.
d2813 1
a2813 11
	frag_var (rs_machine_dependent,
		  1 + 4,
		  i.reloc[0],
		  ((unsigned char) *p == JUMP_PC_RELATIVE
		   ? ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL) | code16
		   : ((cpu_arch_flags & Cpu386) != 0
		      ? ENCODE_RELAX_STATE (COND_JUMP, SMALL) | code16
		      : ENCODE_RELAX_STATE (COND_JUMP86, SMALL) | code16)),
		  i.op[0].disps->X_add_symbol,
		  i.op[0].disps->X_add_number,
		  p);
@


1.101
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d3184 1
a3184 1
      if (strncmp (cp + 1, gotrel[j].str, len) == 0)
d3188 2
a3189 2
	      int first;
	      char *tmpbuf;
d3192 2
d3200 2
d3203 12
a3214 1
	      tmpbuf = xmalloc (strlen (input_line_pointer));
d3217 2
a3218 3
	      strcpy (tmpbuf + first + 1, cp + 1 + len);
	      if (adjust)
		*adjust = len;
@


1.100
log
@	* config/tc-i386.c (comment_chars): Don't use '/' as comment start if
	TE_NetBSD.
	(line_comment_chars): Set to '/' if TE_NetBSD.
@
text
@a4090 9
#ifdef BFD_ASSEMBLER
  /* Not needed otherwise?  */
  {
    /* Local symbols which have already been resolved have a NULL frag.  */
    fragS *sym_frag = symbol_get_frag (fragP->fr_symbol);
    if (sym_frag)
      target_address += sym_frag->fr_address;
  }
#endif
@


1.99
log
@	* config/tc-hppa.c (CHECK_FIELD_WHERE): Define.
	(md_apply_fix): Use it here.  Replace printf with equivalent
	as_bad_where.
	(tc_gen_reloc): Use as_bad_where instead of as_bad.
	(md_apply_fix): Here too.
	* config/tc-i386.c (tc_gen_reloc): Use as_bad_where instead of as_bad.
	* config/tc-m68k.c (tc_gen_reloc): Likewise.
	(md_convert_frag_1): Likewise.
@
text
@d160 1
a160 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD))
d178 1
a178 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD))
@


1.98
log
@Branch hints for Pentium4 as insn modifiers, and some minor tweaks
to formatting.
@
text
@d4783 3
a4785 2
	      as_bad (_("can not do %d byte pc-relative relocation"),
		      fixp->fx_size);
d4798 3
a4800 1
	      as_bad (_("can not do %d byte relocation"), fixp->fx_size);
@


1.97
log
@	* config/tc-i386.c (md_assemble): Handle Pentium4 branch hints.
	<JumpByte, JumpDword insn output>: Remove dead code.
@
text
@d1272 2
a1273 1
	    && *l != PREFIX_SEPARATOR)
d1362 32
@


1.96
log
@	From 2.11 branch 2001-03-30  Richard Henderson  <rth@@redhat.com>
	* config/tc-i386.c (md_convert_frag): Don't die on local symbols
	that have been finalized.
@
text
@d2723 7
d2749 3
d2782 7
d2819 2
a2820 11
	if (fits_in_unsigned_byte (i.tm.base_opcode))
	  {
	    p = frag_more (1 + size);
	  }
	else
	  {
	    /* Opcode can be at most two bytes.  */
	    p = frag_more (2 + size);
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
	  }
	*p++ = i.tm.base_opcode & 0xff;
@


1.95
log
@Fix dwarf2_emit_insn calls when frag_var breaks things.
Put back an old entry in ChangeLog-9899, deleted when ChangeLog split.
@
text
@d4052 6
a4057 1
  target_address += symbol_get_frag (fragP->fr_symbol)->fr_address;
@


1.94
log
@	* config/tc-i386.c (i386_displacement): Call as_bad for bad GOTOFF
	expressions rather than triggering an assert.
@
text
@a1233 4
  /* Count the size of the instruction generated.  Does not include
     variable part of jump insns before relax.  */
  int insn_size = 0;

d2701 5
a2737 1
	insn_size += prefix + 1;
a2768 1
		insn_size += 1;
a2782 1
		insn_size += 1;
a2795 1
	    insn_size++;
a2803 1
	    insn_size += 1 + size;
a2808 1
	    insn_size += 2 + size;
a2847 1
	insn_size += prefix + 1 + 2 + size;
a2894 1
		insn_size += 1;
a2902 1
	    insn_size += 1;
a2906 1
	    insn_size += 2;
a2915 1
	    insn_size += 1;
a2929 1
		insn_size += 1;
a2962 1
			insn_size += size;
a3008 1
			insn_size += size;
a3042 1
			insn_size += size;
a3067 1
			insn_size += size;
a3093 2

    dwarf2_emit_insn (insn_size);
@


1.93
log
@Prepare for multi-pass relaxation.
@
text
@d3469 13
d3489 9
a3500 1
      assert (exp->X_op == O_symbol);
a3507 13
#endif

  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("junk `%s' after expression"), input_line_pointer);
#if GCC_ASM_O_HACK
  RESTORE_END_STRING (disp_end + 1);
#endif
  RESTORE_END_STRING (disp_end);
  input_line_pointer = save_input_line_pointer;
#ifndef LEX_AT
  if (gotfree_input_line)
    free (gotfree_input_line);
@


1.92
log
@Accept an absolute expression for index scale factor.
@
text
@d287 3
a289 3
#define UNCOND_JUMP 1
#define COND_JUMP 2
#define COND_JUMP86 3
d326 1
a326 1
     3) how many bytes this mode will add to the size of the current frag
a327 4
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},
d330 8
a337 8
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
  /* dword jmp adds 3 bytes to frag:
     0 extra opcode bytes, 3 extra displacement bytes.  */
  {0, 0, 3, 0},
  /* word jmp adds 1 byte to frag:
     0 extra opcode bytes, 1 extra displacement byte.  */
  {0, 0, 1, 0},
d340 8
a347 8
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP, BIG)},
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP, BIG16)},
  /* dword conditionals adds 4 bytes to frag:
     1 extra opcode byte, 3 extra displacement bytes.  */
  {0, 0, 4, 0},
  /* word conditionals add 2 bytes to frag:
     1 extra opcode byte, 1 extra displacement byte.  */
  {0, 0, 2, 0},
d350 8
a357 8
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP86, BIG)},
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP86, BIG16)},
  /* dword conditionals adds 4 bytes to frag:
     1 extra opcode byte, 3 extra displacement bytes.  */
  {0, 0, 4, 0},
  /* word conditionals add 3 bytes to frag:
     1 extra opcode byte, 2 extra displacement bytes.  */
  {0, 0, 3, 0}
d3970 2
a3971 1
	    return 1;
d3993 2
a3994 1
	    return 1;
d4014 9
a4022 2
  /* Guess a short jump.  */
  return 1;
@


1.91
log
@Fix register name printed in warning message.
@
text
@d3347 1
a3347 1
static int i386_scale PARAMS ((char *));
d3349 1
a3349 1
static int
d3353 5
a3357 2
  if (!isdigit (*scale))
    goto bad_scale;
d3359 1
a3359 1
  switch (*scale)
d3361 2
a3362 2
    case '0':
    case '1':
d3365 1
a3365 1
    case '2':
d3368 1
a3368 1
    case '4':
d3371 1
a3371 1
    case '8':
a3374 1
    bad_scale:
d3377 2
a3378 1
      return 0;
d3388 3
a3390 1
  return 1;
d3838 1
a3838 1
		  if (isdigit ((unsigned char) *base_string))
d3840 3
a3842 1
		      if (!i386_scale (base_string))
d3845 1
a3845 1
		      ++base_string;
@


1.90
log
@Support for @@GOTOFF in .long expressions.
@
text
@d1999 4
a2002 1
			       (i.op[op].regs - (i.types[op] & Reg16 ? 8 : 16))->reg_name,
d2052 1
a2052 1
			     (i.op[op].regs + 8)->reg_name,
d2123 1
a2123 1
			     (i.op[op].regs - 8)->reg_name,
@


1.89
log
@Fix copyright notices
@
text
@d73 3
d123 1
a123 5
#ifdef BFD_ASSEMBLER
    enum bfd_reloc_code_real reloc[MAX_OPERANDS];
#else
    int reloc[MAX_OPERANDS];
#endif
d243 1
d1549 1
a1549 5
#ifdef BFD_ASSEMBLER
	enum bfd_reloc_code_real temp_reloc;
#else
	int temp_reloc;
#endif
d3067 1
a3067 5
#ifdef BFD_ASSEMBLER
			enum bfd_reloc_code_real reloc_type;
#else
			int reloc_type;
#endif
d3122 124
d3253 3
d3275 3
a3277 65
  {
    /* We can have operands of the form
         <symbol>@@GOTOFF+<nnn>
       Take the easy way out here and copy everything
       into a temporary buffer...  */
    register char *cp;

    cp = strchr (input_line_pointer, '@@');
    if (cp != NULL)
      {
	char *tmpbuf;
	int len = 0;
	int first;

	/* GOT relocations are not supported in 16 bit mode.  */
	if (flag_code == CODE_16BIT)
	  as_bad (_("GOT relocations not supported in 16 bit mode"));

	if (GOT_symbol == NULL)
	  GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	if (strncmp (cp + 1, "PLT", 3) == 0)
	  {
	    if (flag_code == CODE_64BIT)
	      i.reloc[this_operand] = BFD_RELOC_X86_64_PLT32;
	    else
	      i.reloc[this_operand] = BFD_RELOC_386_PLT32;
	    len = 3;
	  }
	else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
	  {
	    if (flag_code == CODE_64BIT)
	      as_bad ("GOTOFF relocations are unsupported in 64bit mode.");
	    i.reloc[this_operand] = BFD_RELOC_386_GOTOFF;
	    len = 6;
	  }
	else if (strncmp (cp + 1, "GOTPCREL", 8) == 0)
	  {
	    if (flag_code == CODE_64BIT)
	      i.reloc[this_operand] = BFD_RELOC_X86_64_GOTPCREL;
	    else
	      as_bad ("GOTPCREL relocations are supported only in 64bit mode.");
	    len = 8;
	  }
	else if (strncmp (cp + 1, "GOT", 3) == 0)
	  {
	    if (flag_code == CODE_64BIT)
	      i.reloc[this_operand] = BFD_RELOC_X86_64_GOT32;
	    else
	      i.reloc[this_operand] = BFD_RELOC_386_GOT32;
	    len = 3;
	  }
	else
	  as_bad (_("bad reloc specifier in expression"));

	/* Replace the relocation token with ' ', so that errors like
	   foo@@GOTOFF1 will be detected.  */
	first = cp - input_line_pointer;
	tmpbuf = (char *) alloca (strlen (input_line_pointer));
	memcpy (tmpbuf, input_line_pointer, first);
	tmpbuf[first] = ' ';
	strcpy (tmpbuf + first + 1, cp + 1 + len);
	input_line_pointer = tmpbuf;
      }
  }
d3284 1
a3284 1
    as_bad (_("ignoring junk `%s' after expression"), input_line_pointer);
d3287 4
d3395 3
d3458 3
a3460 64
  {
    /* We can have operands of the form
         <symbol>@@GOTOFF+<nnn>
       Take the easy way out here and copy everything
       into a temporary buffer...  */
    register char *cp;

    cp = strchr (input_line_pointer, '@@');
    if (cp != NULL)
      {
	char *tmpbuf;
	int len = 0;
	int first;

	/* GOT relocations are not supported in 16 bit mode.  */
	if (flag_code == CODE_16BIT)
	  as_bad (_("GOT relocations not supported in 16 bit mode"));

	if (GOT_symbol == NULL)
	  GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	if (strncmp (cp + 1, "PLT", 3) == 0)
	  {
	    if (flag_code == CODE_64BIT)
	      i.reloc[this_operand] = BFD_RELOC_X86_64_PLT32;
	    else
	      i.reloc[this_operand] = BFD_RELOC_386_PLT32;
	    len = 3;
	  }
	else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
	  {
	    if (flag_code == CODE_64BIT)
	      as_bad ("GOTOFF relocation is not supported in 64bit mode.");
	    i.reloc[this_operand] = BFD_RELOC_386_GOTOFF;
	    len = 6;
	  }
	else if (strncmp (cp + 1, "GOTPCREL", 8) == 0)
	  {
	    if (flag_code != CODE_64BIT)
	      as_bad ("GOTPCREL relocation is supported only in 64bit mode.");
	    i.reloc[this_operand] = BFD_RELOC_X86_64_GOTPCREL;
	    len = 8;
	  }
	else if (strncmp (cp + 1, "GOT", 3) == 0)
	  {
	    if (flag_code == CODE_64BIT)
	      i.reloc[this_operand] = BFD_RELOC_X86_64_GOT32;
	    else
	      i.reloc[this_operand] = BFD_RELOC_386_GOT32;
	    len = 3;
	  }
	else
	  as_bad (_("bad reloc specifier in expression"));

	/* Replace the relocation token with ' ', so that errors like
	   foo@@GOTOFF1 will be detected.  */
	first = cp - input_line_pointer;
	tmpbuf = (char *) alloca (strlen (input_line_pointer));
	memcpy (tmpbuf, input_line_pointer, first);
	tmpbuf[first] = ' ';
	strcpy (tmpbuf + first + 1, cp + 1 + len);
	input_line_pointer = tmpbuf;
      }
  }
d3487 1
a3487 2
    as_bad (_("ignoring junk `%s' after expression"),
	    input_line_pointer);
d3493 4
d3936 1
a3936 5
#ifdef BFD_ASSEMBLER
      enum bfd_reloc_code_real reloc_type;
#else
      int reloc_type;
#endif
@


1.88
log
@* config/tc-i386.c (struct _i386_insn): Rename disp_reloc to reloc.
(md_assemble [smallest displacement]): Use correct field of i.op[] union.
(md_assemble [JumpInterSegment output]): Use correct i.disp_reloc[].
(md_assemble [immediate output]): Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.87
log
@2001-02-28  Andreas Jaeger  <aj@@suse.de>, Bo Thorsen  <bo@@suse.de>

	* config/tc-i386.c (tc_gen_reloc): Remove ugly hack which is not needed
	anymore since we use bfd_elf_generic_reloc now.
	(md_apply_fix3): Only apply hack for partial_inplace if not using RELA.
@
text
@d120 1
a120 1
    enum bfd_reloc_code_real disp_reloc[MAX_OPERANDS];
d122 1
a122 1
    int disp_reloc[MAX_OPERANDS];
d1248 1
a1248 1
    i.disp_reloc[j] = NO_RELOC;
d1572 3
a1574 3
	temp_reloc = i.disp_reloc[xchg2];
	i.disp_reloc[xchg2] = i.disp_reloc[xchg1];
	i.disp_reloc[xchg1] = temp_reloc;
d1694 1
a1694 1
	      && i.op[op].imms->X_op == O_constant)
d2753 1
a2753 1
		  i.disp_reloc[0],
d2824 1
a2824 1
		     i.op[0].disps, 1, reloc (size, 1, 1, i.disp_reloc[0]));
d2882 1
a2882 1
		       i.op[1].imms, 0, reloc (size, 0, 0, i.disp_reloc[0]));
d3029 1
a3029 1
				     reloc (size, pcrel, sign, i.disp_reloc[n]));
d3092 1
a3092 1
			reloc_type = reloc (size, 0, sign, i.disp_reloc[0]);
d3179 1
a3179 1
	      i.disp_reloc[this_operand] = BFD_RELOC_X86_64_PLT32;
d3181 1
a3181 1
	      i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
d3188 1
a3188 1
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
d3194 1
a3194 1
	      i.disp_reloc[this_operand] = BFD_RELOC_X86_64_GOTPCREL;
d3202 1
a3202 1
	      i.disp_reloc[this_operand] = BFD_RELOC_X86_64_GOT32;
d3204 1
a3204 1
	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
d3417 1
a3417 1
	      i.disp_reloc[this_operand] = BFD_RELOC_X86_64_PLT32;
d3419 1
a3419 1
	      i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
d3426 1
a3426 1
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
d3433 1
a3433 1
	    i.disp_reloc[this_operand] = BFD_RELOC_X86_64_GOTPCREL;
d3439 1
a3439 1
	      i.disp_reloc[this_operand] = BFD_RELOC_X86_64_GOT32;
d3441 1
a3441 1
	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
d3465 2
a3466 2
  if (i.disp_reloc[this_operand] == BFD_RELOC_386_GOTOFF
      || i.disp_reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
d3474 2
a3475 2
      if (i.disp_reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
        i.disp_reloc[this_operand] = BFD_RELOC_32_PCREL;
d3477 1
a3477 1
        i.disp_reloc[this_operand] = BFD_RELOC_32;
@


1.86
log
@2001-02-20  Bo Thorsen  <bo@@suse.de>

	* config/tc-i386.c (tc_i386_fix_adjustable): Fix GOTPCREL GOT
	  entry.
@
text
@d4200 1
a4200 1
      && fixP->fx_addsy)
a4784 9
#ifdef OBJ_ELF
      /* Ohhh, this is ugly.  The problem is that if this is a local global
         symbol, the relocation will entirely be performed at link time, not
         at assembly time.  bfd_perform_reloc doesn't know about this sort
         of thing, and as a result we need to fake it out here.  */
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
	  && !S_IS_COMMON (fixp->fx_addsy))
	rel->addend -= symbol_get_bfdsym (fixp->fx_addsy)->value;
#endif
@


1.85
log
@Handle long jumps for .code16 and .arch < 386 by using a two
instruction sequence consisting of a conditional jump of the
opposite sense around an unconditional jump to the target.
Add jumps/nojumps .arch modifier.
@
text
@d1191 1
@


1.84
log
@
	* elf64-x86-64.c (x86_64_elf_howto): Fix name of R_X86_64_GOTPCREL.
	* tc-i386.c (i386_displacement): Fix handling of
	BFD_RELOC_X86_64_GOTPCREL.
	(i386_validate_fix): Likewise.
@
text
@d276 4
d281 3
a283 4
   There are 2 relax states for 386 jump insns: one for conditional &
   one for unconditional jumps.  This is because these two types of
   jumps add different sizes to frags when we're figuring out what
   sort of jump to choose to reach a given label.  */
d286 4
a289 2
#define COND_JUMP 1
#define UNCOND_JUMP 2
d305 6
a310 4
#define ENCODE_RELAX_STATE(type,size) \
  ((relax_substateT) ((type<<2) | (size)))
#define SIZE_FROM_RELAX_STATE(s) \
    ( (((s) & 0x3) == BIG ? 4 : (((s) & 0x3) == BIG16 ? 2 : 1)) )
d332 11
d352 9
a360 9
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
  /* dword jmp adds 3 bytes to frag:
     0 extra opcode bytes, 3 extra displacement bytes.  */
  {0, 0, 3, 0},
  /* word jmp adds 1 byte to frag:
     0 extra opcode bytes, 1 extra displacement byte.  */
  {0, 0, 1, 0}

d747 2
a748 1
	      cpu_arch_flags = cpu_arch[i].flags | (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
d760 17
d1236 2
a1237 1
  /* Count the size of the instruction generated.  */
a2710 1
	int size;
a2730 4
	size = 4;
	if (code16)
	  size = 2;

d2739 1
a2739 1
	frag_grow (prefix + 2 + size);
d2751 1
a2751 1
		  1 + size,
d2755 3
a2757 1
		   : ENCODE_RELAX_STATE (COND_JUMP, SMALL) | code16),
d3946 1
a3946 1
      switch (opcode[0])
d3948 2
a3949 2
	case JUMP_PC_RELATIVE:
	  /* Make jmp (0xeb) a dword displacement jump.  */
d3958 25
a3982 1
	default:
d3984 1
a3984 1
	     to the dword-displacement jump 0x0f,0x8N.  */
d3994 4
d4051 1
a4051 1
  switch (fragP->fr_subtype)
a4052 4
    case ENCODE_RELAX_STATE (COND_JUMP, SMALL):
    case ENCODE_RELAX_STATE (COND_JUMP, SMALL16):
    case ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL):
    case ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL16):
d4056 14
a4069 1
      break;
d4071 5
a4075 6
    case ENCODE_RELAX_STATE (COND_JUMP, BIG):
      extension = 5;		/* 2 opcode + 4 displacement  */
      opcode[1] = opcode[0] + 0x10;
      opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
      where_to_put_displacement = &opcode[2];
      break;
d4077 7
a4083 5
    case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG):
      extension = 4;		/* 1 opcode + 4 displacement  */
      opcode[0] = 0xe9;
      where_to_put_displacement = &opcode[1];
      break;
d4085 6
a4090 6
    case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
      extension = 3;		/* 2 opcode + 2 displacement  */
      opcode[1] = opcode[0] + 0x10;
      opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
      where_to_put_displacement = &opcode[2];
      break;
d4092 7
a4098 5
    case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16):
      extension = 2;		/* 1 opcode + 2 displacement  */
      opcode[0] = 0xe9;
      where_to_put_displacement = &opcode[1];
      break;
d4100 4
a4103 3
    default:
      BAD_CASE (fragP->fr_subtype);
      break;
d4105 1
d4109 1
a4109 1
		      SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
@


1.83
log
@2001-01-16  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-i386.c: Fix formatting.
@
text
@d3439 4
a3442 1
      i.disp_reloc[this_operand] = BFD_RELOC_32;
d4606 12
a4617 3
      if (flag_code == CODE_64BIT)
	abort ();
      fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
@


1.83.2.1
log
@
	* elf64-x86-64.c (x86_64_elf_howto): Fix name of R_X86_64_GOTPCREL.
	* tc-i386.c (i386_displacement): Fix handling of
	BFD_RELOC_X86_64_GOTPCREL.
	(i386_validate_fix): Likewise.
@
text
@d3439 1
a3439 4
      if (i.disp_reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
        i.disp_reloc[this_operand] = BFD_RELOC_32_PCREL;
      else
        i.disp_reloc[this_operand] = BFD_RELOC_32;
d4603 3
a4605 12
      if (fixp->fx_r_type == BFD_RELOC_32_PCREL)
	{
	  if (flag_code != CODE_64BIT)
	    abort ();
	  fixp->fx_r_type = BFD_RELOC_X86_64_GOTPCREL;
	}
      else
	{
	  if (flag_code == CODE_64BIT)
	    abort ();
	  fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
	}
@


1.83.2.2
log
@2001-02-20  Bo Thorsen  <bo@@suse.de>

	* config/tc-i386.c (tc_i386_fix_adjustable): Fix GOTPCREL GOT
	  entry.
@
text
@a1154 1
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPCREL
@


1.83.2.3
log
@2001-02-28  Andreas Jaeger  <aj@@suse.de>, Bo Thorsen  <bo@@suse.de>

	* config/tc-i386.c (tc_gen_reloc): Remove ugly hack which is not needed
	anymore since we use bfd_elf_generic_reloc now.
	(md_apply_fix3): Only apply hack for partial_inplace if not using RELA.
@
text
@d4124 1
a4124 1
      && fixP->fx_addsy && !use_rela_relocations)
d4709 9
@


1.83.2.4
log
@Fix register name printed in warning message.
@
text
@d1965 1
a1965 4
			       (i.op[op].regs
				+ (i.types[op] & Reg16
				   ? REGNAM_AL - REGNAM_AX
				   : REGNAM_AL - REGNAM_EAX))->reg_name,
d2015 1
a2015 1
			     (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
d2086 1
a2086 1
			     (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
@


1.83.2.5
log
@rth's fix for relaxation ordering problem.
@
text
@d3984 1
a3984 6
  {
    /* Local symbols which have already been resolved have a NULL frags.  */
    fragS *sym_frag = symbol_get_frag (fragP->fr_symbol);
    if (sym_frag)
      target_address += sym_frag->fr_address;
  }
@


1.83.2.6
log
@Merge from mainline.
@
text
@d2 1
a2 2
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
a71 3
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
d119 5
a123 1
    RELOC_ENUM reloc[MAX_OPERANDS];
a242 1
#define NUM_FLAG_CODE ((int) CODE_64BIT + 1)
a275 4
/* If set, conditional jumps are not automatically promoted to handle
   larger than a byte offset.  */
static unsigned int no_cond_jump_promotion = 0;

d277 4
a280 3
   There are 3 major relax states for 386 jump insns because the
   different types of jumps add different sizes to frags when we're
   figuring out what sort of jump to choose to reach a given label.  */
a282 1
#define UNCOND_JUMP 0
d284 1
a284 2
#define COND_JUMP86 2

d300 4
a303 6
#define ENCODE_RELAX_STATE(type, size) \
  ((relax_substateT) (((type) << 2) | (size)))
#define TYPE_FROM_RELAX_STATE(s) \
  ((s) >> 2)
#define DISP_SIZE_FROM_RELAX_STATE(s) \
    ((((s) & 3) == BIG ? 4 : (((s) & 3) == BIG16 ? 2 : 1)))
d318 1
a318 1
     3) how many bytes this mode will have in the variable part of the frag
d320 9
a328 6

  /* UNCOND_JUMP states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
  /* dword jmp adds 4 bytes to frag:
     0 extra opcode bytes, 4 displacement bytes.  */
d330 2
a331 2
  /* word jmp adds 2 byte2 to frag:
     0 extra opcode bytes, 2 displacement bytes.  */
d334 4
a337 8
  /* COND_JUMP states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG16)},
  /* dword conditionals adds 5 bytes to frag:
     1 extra opcode byte, 4 displacement bytes.  */
  {0, 0, 5, 0},
  /* word conditionals add 3 bytes to frag:
     1 extra opcode byte, 2 displacement bytes.  */
d339 3
a342 9
  /* COND_JUMP86 states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG16)},
  /* dword conditionals adds 5 bytes to frag:
     1 extra opcode byte, 4 displacement bytes.  */
  {0, 0, 5, 0},
  /* word conditionals add 4 bytes to frag:
     1 displacement byte and a 3 byte long branch insn.  */
  {0, 0, 4, 0}
d729 1
a729 2
	      cpu_arch_flags = (cpu_arch[i].flags
				| (flag_code == CODE_64BIT ? Cpu64 : CpuNo64));
a740 17
  no_cond_jump_promotion = 0;
  if (*input_line_pointer == ','
      && ! is_end_of_line[(unsigned char) input_line_pointer[1]])
    {
      char *string = ++input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp (string, "nojumps") == 0)
	no_cond_jump_promotion = 1;
      else if (strcmp (string, "jumps") == 0)
	;
      else
	as_bad (_("no such architecture modifier: `%s'"), string);

      *input_line_pointer = e;
    }

d1201 3
d1211 1
a1211 1
    i.reloc[j] = NO_RELOC;
d1511 5
a1515 1
	RELOC_ENUM temp_reloc;
d1535 3
a1537 3
	temp_reloc = i.reloc[xchg2];
	i.reloc[xchg2] = i.reloc[xchg1];
	i.reloc[xchg1] = temp_reloc;
d1657 1
a1657 1
	      && i.op[op].disps->X_op == O_constant)
a2674 5
    /* Tie dwarf2 debug info to the address at the start of the insn.
       We can't do this after the insn has been output as the current
       frag may have been closed off.  eg. by frag_var.  */
    dwarf2_emit_insn (0);

d2678 1
d2699 4
d2711 2
a2712 1
	frag_grow (prefix + 2 + 4);
d2723 2
a2724 2
		  1 + 4,
		  i.reloc[0],
d2727 1
a2727 3
		   : ((cpu_arch_flags & Cpu386) != 0
		      ? ENCODE_RELAX_STATE (COND_JUMP, SMALL) | code16
		      : ENCODE_RELAX_STATE (COND_JUMP86, SMALL) | code16)),
d2742 1
d2757 1
d2771 1
d2780 1
d2786 1
d2793 1
a2793 1
		     i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
d2826 1
d2851 1
a2851 1
		       i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
d2874 1
d2883 1
d2888 1
d2898 1
d2913 1
d2947 1
d2994 1
d2998 1
a2998 1
				     reloc (size, pcrel, sign, i.reloc[n]));
d3029 1
d3039 5
a3043 1
			RELOC_ENUM reloc_type;
d3059 1
d3061 1
a3061 1
			reloc_type = reloc (size, 0, sign, i.reloc[n]);
d3087 2
a3097 124
#ifndef LEX_AT
static char *lex_got PARAMS ((RELOC_ENUM *, int *));

/* Parse operands of the form
   <symbol>@@GOTOFF+<nnn>
   and similar .plt or .got references.

   If we find one, set up the correct relocation in RELOC and copy the
   input string, minus the `@@GOTOFF' into a malloc'd buffer for
   parsing by the calling routine.  Return this buffer, and if ADJUST
   is non-null set it to the length of the string we removed from the
   input line.  Otherwise return NULL.  */
static char *
lex_got (reloc, adjust)
     RELOC_ENUM *reloc;
     int *adjust;
{
  static const char * const mode_name[NUM_FLAG_CODE] = { "32", "16", "64" };
  static const struct {
    const char *str;
    const RELOC_ENUM rel[NUM_FLAG_CODE];
  } gotrel[] = {
    { "PLT",      { BFD_RELOC_386_PLT32,  0, BFD_RELOC_X86_64_PLT32    } },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF, 0, 0                         } },
    { "GOTPCREL", { 0,                    0, BFD_RELOC_X86_64_GOTPCREL } },
    { "GOT",      { BFD_RELOC_386_GOT32,  0, BFD_RELOC_X86_64_GOT32    } }
  };
  char *cp;
  unsigned int j;

  for (cp = input_line_pointer; *cp != '@@'; cp++)
    if (is_end_of_line[(unsigned char) *cp])
      return NULL;

  for (j = 0; j < sizeof (gotrel) / sizeof (gotrel[0]); j++)
    {
      int len;

      len = strlen (gotrel[j].str);
      if (strncmp (cp + 1, gotrel[j].str, len) == 0)
	{
	  if (gotrel[j].rel[(unsigned int) flag_code] != 0)
	    {
	      int first;
	      char *tmpbuf;

	      *reloc = gotrel[j].rel[(unsigned int) flag_code];

	      if (GOT_symbol == NULL)
		GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	      /* Replace the relocation token with ' ', so that
		 errors like foo@@GOTOFF1 will be detected.  */
	      first = cp - input_line_pointer;
	      tmpbuf = xmalloc (strlen (input_line_pointer));
	      memcpy (tmpbuf, input_line_pointer, first);
	      tmpbuf[first] = ' ';
	      strcpy (tmpbuf + first + 1, cp + 1 + len);
	      if (adjust)
		*adjust = len;
	      return tmpbuf;
	    }

	  as_bad (_("@@%s reloc is not supported in %s bit mode"),
		  gotrel[j].str, mode_name[(unsigned int) flag_code]);
	  return NULL;
	}
    }

  /* Might be a symbol version string.  Don't as_bad here.  */
  return NULL;
}

/* x86_cons_fix_new is called via the expression parsing code when a
   reloc is needed.  We use this hook to get the correct .got reloc.  */
static RELOC_ENUM got_reloc = NO_RELOC;

void
x86_cons_fix_new (frag, off, len, exp)
     fragS *frag;
     unsigned int off;
     unsigned int len;
     expressionS *exp;
{
  RELOC_ENUM r = reloc (len, 0, 0, got_reloc);
  got_reloc = NO_RELOC;
  fix_new_exp (frag, off, len, exp, 0, r);
}

void
x86_cons (exp, size)
     expressionS *exp;
     int size;
{
  if (size == 4)
    {
      /* Handle @@GOTOFF and the like in an expression.  */
      char *save;
      char *gotfree_input_line;
      int adjust;

      save = input_line_pointer;
      gotfree_input_line = lex_got (&got_reloc, &adjust);
      if (gotfree_input_line)
	input_line_pointer = gotfree_input_line;

      expression (exp);

      if (gotfree_input_line)
	{
	  /* expression () has merrily parsed up to the end of line,
	     or a comma - in the wrong buffer.  Transfer how far
	     input_line_pointer has moved to the right buffer.  */
	  input_line_pointer = (save
				+ (input_line_pointer - gotfree_input_line)
				+ adjust);
	  free (gotfree_input_line);
	}
    }
  else
    expression (exp);
}
#endif

a3104 3
#ifndef LEX_AT
  char *gotfree_input_line;
#endif
d3124 65
a3188 3
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL);
  if (gotfree_input_line)
    input_line_pointer = gotfree_input_line;
d3195 1
a3195 1
    as_bad (_("junk `%s' after expression"), input_line_pointer);
a3197 4
#ifndef LEX_AT
  if (gotfree_input_line)
    free (gotfree_input_line);
#endif
d3251 1
a3251 1
static char *i386_scale PARAMS ((char *));
d3253 1
a3253 1
static char *
d3257 2
a3258 5
  offsetT val;
  char *save = input_line_pointer;

  input_line_pointer = scale;
  val = get_absolute_expression ();
d3260 1
a3260 1
  switch (val)
d3262 2
a3263 2
    case 0:
    case 1:
d3266 1
a3266 1
    case 2:
d3269 1
a3269 1
    case 4:
d3272 1
a3272 1
    case 8:
d3276 1
d3279 1
a3279 2
      input_line_pointer = save;
      return NULL;
d3289 1
a3289 3
  scale = input_line_pointer;
  input_line_pointer = save;
  return scale;
a3301 3
#ifndef LEX_AT
  char *gotfree_input_line;
#endif
d3362 64
a3425 3
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL);
  if (gotfree_input_line)
    input_line_pointer = gotfree_input_line;
a3429 13
  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("junk `%s' after expression"), input_line_pointer);
#if GCC_ASM_O_HACK
  RESTORE_END_STRING (disp_end + 1);
#endif
  RESTORE_END_STRING (disp_end);
  input_line_pointer = save_input_line_pointer;
#ifndef LEX_AT
  if (gotfree_input_line)
    free (gotfree_input_line);
#endif

d3434 2
a3435 2
  if (i.reloc[this_operand] == BFD_RELOC_386_GOTOFF
      || i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
a3436 9
      if (exp->X_op != O_symbol)
	{
	  as_bad (_("bad expression used with @@%s"),
		  (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL
		   ? "GOTPCREL"
		   : "GOTOFF"));
	  return 0;
	}

d3440 1
d3443 2
a3444 2
      if (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
        i.reloc[this_operand] = BFD_RELOC_32_PCREL;
d3446 1
a3446 1
        i.reloc[this_operand] = BFD_RELOC_32;
d3450 10
d3792 1
a3792 1
		  if (*base_string != ')')
d3794 1
a3794 3
		      char *end_scale = i386_scale (base_string);

		      if (!end_scale)
d3797 1
a3797 1
		      base_string = end_scale;
d3898 5
a3902 1
      RELOC_ENUM reloc_type;
d3916 1
a3916 1
      switch (TYPE_FROM_RELAX_STATE (fragP->fr_subtype))
d3918 2
a3919 2
	case UNCOND_JUMP:
	  /* Make jmp (0xeb) a (d)word displacement jump.  */
d3928 1
a3928 27
	case COND_JUMP86:
	  if (no_cond_jump_promotion)
	    goto relax_guess;

	  if (size == 2)
	    {
	      /* Negate the condition, and branch past an
		 unconditional jump.  */
	      opcode[0] ^= 1;
	      opcode[1] = 3;
	      /* Insert an unconditional jump.  */
	      opcode[2] = 0xe9;
	      /* We added two extra opcode bytes, and have a two byte
		 offset.  */
	      fragP->fr_fix += 2 + 2;
	      fix_new (fragP, old_fr_fix + 2, 2,
		       fragP->fr_symbol,
		       fragP->fr_offset, 1,
		       reloc_type);
	      break;
	    }
	  /* Fall through.  */

	case COND_JUMP:
	  if (no_cond_jump_promotion)
	    goto relax_guess;

d3930 1
a3930 1
	     to the (d)word-displacement jump 0x0f,0x8N.  */
a3939 4

	default:
	  BAD_CASE (fragP->fr_subtype);
	  break;
d3944 2
a3945 9

 relax_guess:
  /* Guess size depending on current relax state.  Initially the relax
     state will correspond to a short jump and we return 1, because
     the variable part of the frag (the branch offset) is one byte
     long.  However, we can relax a section more than once and in that
     case we must either set fr_subtype back to the unrelaxed state,
     or return the value for the appropriate branch.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
d3985 1
a3985 1
    /* Local symbols which have already been resolved have a NULL frag.  */
d3998 1
a3998 1
  if ((fragP->fr_subtype & BIG) == 0)
d4000 4
d4007 1
a4007 6
    }
  else
    {
      if (no_cond_jump_promotion
	  && TYPE_FROM_RELAX_STATE (fragP->fr_subtype) != UNCOND_JUMP)
	as_warn_where (fragP->fr_file, fragP->fr_line, _("long jump required"));
d4009 6
a4014 7
      switch (fragP->fr_subtype)
	{
	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG):
	  extension = 4;		/* 1 opcode + 4 displacement  */
	  opcode[0] = 0xe9;
	  where_to_put_displacement = &opcode[1];
	  break;
d4016 5
a4020 5
	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16):
	  extension = 2;		/* 1 opcode + 2 displacement  */
	  opcode[0] = 0xe9;
	  where_to_put_displacement = &opcode[1];
	  break;
d4022 6
a4027 7
	case ENCODE_RELAX_STATE (COND_JUMP, BIG):
	case ENCODE_RELAX_STATE (COND_JUMP86, BIG):
	  extension = 5;		/* 2 opcode + 4 displacement  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  where_to_put_displacement = &opcode[2];
	  break;
d4029 5
a4033 6
	case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
	  extension = 3;		/* 2 opcode + 2 displacement  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  where_to_put_displacement = &opcode[2];
	  break;
d4035 3
a4037 12
	case ENCODE_RELAX_STATE (COND_JUMP86, BIG16):
	  extension = 4;
	  opcode[0] ^= 1;
	  opcode[1] = 3;
	  opcode[2] = 0xe9;
	  where_to_put_displacement = &opcode[3];
	  break;

	default:
	  BAD_CASE (fragP->fr_subtype);
	  break;
	}
a4038 1

d4042 1
a4042 1
		      DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
@


1.83.2.7
log
@Merge from mainline.
@
text
@a2722 7
	/* Pentium4 branch hints.  */
	if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
	    || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	  {
	    prefix++;
	    i.prefixes--;
	  }
a2741 3
	if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
	    || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
	  *p++ = i.prefix[SEG_PREFIX];
a2771 7
	    /* Pentium4 branch hints.  */
	    if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
		|| i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	      {
		FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
		i.prefixes--;
	      }
d2802 11
a2812 2
	p = frag_more (1 + size);
	*p++ = i.tm.base_opcode;
@


1.83.2.8
log
@	* config/tc-i386.c (parse_register): If not producing code for
	x86_64, reject x86_64 register name matches.
	(md_assemble): Remove now redundant check for x86_64 regs.
@
text
@d1906 13
a4481 7
    }

  if (r != NULL
      && r->reg_flags & (RegRex64|RegRex)
      && flag_code != CODE_64BIT)
    {
      return (const reg_entry *) NULL;
@


1.82
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d647 1
a647 1
     int  value;
d1101 1
a1101 1
	as_bad(_("There are no unsigned pc-relative relocations"));
d1113 1
a1113 1
        switch (size)
d1583 1
a1583 1
	        {
d1599 5
a1603 4
		    /* If this operand is at most 16 bits, convert it to a
		       signed 16 bit number before trying to see whether it will
		       fit in an even smaller size.  This allows a 16-bit operand
		       such as $0xffe0 to be recognised as within Imm8S range.  */
d1605 1
a1605 1
			&& (i.op[op].imms->X_add_number & ~(offsetT)0xffff) == 0)
d1731 1
a1731 1
          }
d1839 4
a1842 4
     if (SYSV386_COMPAT
	 && intel_syntax
	 && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
       i.tm.base_opcode ^= FloatR;
d1882 1
a1882 1
	for (op = i.operands; --op >= 0; )
d2105 1
a2105 1
        && overlap0 != Imm16 && overlap0 != Imm32S
d2131 1
a2131 1
        && overlap1 != Imm16 && overlap1 != Imm32S
d2224 2
a2225 2
		 as_bad (_("64bit operations available only in 64bit modes."));
		 return;
d2284 1
a2284 1
	      i.rex.extZ=1;
d2336 1
a2336 1
		      i.rex.extX=1;
d2338 1
a2338 1
		      i.rex.extZ=1;
d2345 1
a2345 1
		      i.rex.extZ=1;
d2347 1
a2347 1
		      i.rex.extX=1;
d2383 5
a2387 3
			        /* 64bit mode overwrites the 32bit absolute addressing
				   by RIP relative addressing and absolute addressing
				   is encoded by one of the redundant SIB forms.  */
d2408 1
a2408 1
			      i.rex.extY=1;
d2461 1
a2461 1
			  i.rex.extZ=1;
d2500 1
a2500 1
			      i.rex.extY=1;
d2546 1
a2546 1
			  i.rex.extZ=1;
d2552 1
a2552 1
			  i.rex.extX=1;
d2639 1
a2639 1
      i.rex.empty=1;
d2692 1
a2692 1
	    i.prefixes --;
d2983 1
a2983 1
		        if (i.types[n] & (Disp16 | Disp64))
d3433 1
a3433 1
      if (S_IS_LOCAL(exp->X_add_symbol)
d3487 1
a3487 1
static int i386_index_check PARAMS((const char *));
d3533 1
a3533 1
        {
d3540 1
a3540 1
	   ok = 0;
d3681 1
a3681 1
	   || *op_string == '(' )
d3771 1
a3771 1
		      else if (*base_string != ')' )
d4506 3
a4508 3
	 if (flag_code == CODE_64BIT)
	   use_rela_relocations = 1;
         return flag_code == CODE_64BIT ? "elf64-x86-64" : "elf32-i386";
d4702 1
a4702 1
	  && !S_IS_COMMON(fixp->fx_addsy))
d4982 1
a4982 1
  p = intel_parser.op_string = (char *)malloc (strlen (operand_string) + 1);
d4990 1
a4990 1
  intel_parser.disp = (char *)malloc (strlen (operand_string) + 1);
d5267 4
a5270 4
	  {
	    strcat (intel_parser.disp, ")");
	    return 1;
	  }
d5477 1
a5477 1
           || cur_token.code == '-'
d5495 1
a5495 1
      save_str = (char *)malloc (strlen (cur_token.str) + 1);
d5567 1
a5567 1
    int code;
d5613 1
a5613 1
  new_token.str = (char *)malloc (strlen (intel_parser.op_string) + 1);
@


1.81
log
@
	* tc-i386.h (TARGET_MACH): New macro.
	(i386_mach): Declare.
	* tc-i386.c (i386_mach): New function.
@
text
@d1129 1
a1129 1
  abort();
d1622 1
a1622 1
		    abort();
d2973 1
a2973 1
			      abort();
d3067 1
a3067 1
			      abort();
d4601 1
a4601 1
	abort();
d4668 1
a4668 1
	abort();
a4705 1

a4932 1

@


1.80
log
@
	* i386.c (md_assemble): Check cpu_flags even for nullary instructions.

	* i386.h (i386_optab): Fix pusha and ret templates.

	* i386-dis.c (dis386_att, disx86_64_att): Fix ret, lret and iret
	templates.
@
text
@d781 13
@


1.79
log
@Cure recent x86 warts.
@
text
@d1710 1
d1712 6
a1717 2
	  /* 0 operands always matches.  */
	  break;
@


1.78
log
@2001-01-08  Bo Thorsen  <bo@@suse.de>

        * config/tc-i386.c (i386_immediate, i386_displacement):
        GOTPCREL check fix.
@
text
@d4369 1
d4373 1
d4376 1
d4411 1
a4411 3
#endif
#ifdef OBJ_ELF
    case OPTION_32:
a4415 1
	default_arch = c == OPTION_32 ? "i386" : "x86_64";
d4418 5
a4422 12
	  {
	    if (c == OPTION_32)
	      {
		if (strcmp (*l, "elf32-i386") == 0)
		  break;
	      }
	    else
	      {
		if (strcmp (*l, "elf64-x86-64") == 0)
		  break;
	      }
	  }
d4424 1
a4424 2
	  as_fatal (_("No compiled in support for %d bit object file format"),
		    c == OPTION_32 ? 32 : 64);
d4429 4
@


1.77
log
@	* configure.in: Define DEFAULT_ARCH for i386.
	* tc-i386.c (md_assemble): Return after the error message;
	move testing for 64bit operands to proper place.

	* i386.exp: Add tests for presence of 32bit versus 64bit output
	format; run both 64bit and 32bit tests when format is available;
	add x86_64 test.
	* x86_64.s: New file.
	* x86_64.d: New file.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d248 1
a248 1
static const char *flag_code_names[] = 
d2087 1
a2087 1
 	&& overlap0 != Imm32 && overlap0 != Imm64)
d2092 1
a2092 1
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 : 
d2113 1
a2113 1
 	&& overlap1 != Imm32 && overlap1 != Imm64)
d2118 2
a2119 2
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 : 
	 		(i.suffix == QWORD_MNEM_SUFFIX ? Imm64 | Imm32S : Imm32)));
d3135 1
a3135 1
	else if (strncmp (cp + 1, "GOT", 3) == 0)
d3138 1
a3138 1
	      i.disp_reloc[this_operand] = BFD_RELOC_X86_64_GOT32;
d3140 2
a3141 2
	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
	    len = 3;
d3143 1
a3143 1
	else if (strncmp (cp + 1, "GOTPCREL", 3) == 0)
d3146 1
a3146 1
	      i.disp_reloc[this_operand] = BFD_RELOC_X86_64_GOTPCREL;
d3148 1
a3148 1
	      as_bad ("GOTPCREL relocations are supported only in 64bit mode.");
d3373 7
a3387 7
	else if (strncmp (cp + 1, "GOTPCREL", 3) == 0)
	  {
	    if (flag_code != CODE_64BIT)
	      as_bad ("GOTPCREL relocation is supported only in 64bit mode.");
	    i.disp_reloc[this_operand] = BFD_RELOC_X86_64_GOTPCREL;
	    len = 3;
	  }
d4801 2
a4802 2
    			| digits decdigit
       			| digits hexdigit
d4807 1
a4807 1
    			| e06
d4810 1
a4810 1
    			| e09
d4818 1
a4818 1
    			| e11
d4821 1
a4821 1
     			| [ expr ]
d4829 1
a4829 1
    			| e05
d4832 1
a4832 1
    			| BP | EBP | SP | ESP | DI | EDI | SI | ESI
d4835 1
a4835 1
    			| A | B | C | D | E | F
d4838 1
a4838 1
    			| id alpha
d4846 1
a4846 1
    			| gpRegister
d4852 1
a4852 1
    			| DR0 | DR1 | DR2 | DR3 | DR6 | DR7
d4860 1
a4860 1
    		| e05
d4865 1
a4865 1
    		| Empty
d4870 1
a4870 1
    		| Empty
d4873 1
a4873 1
   		| e10 e09'
d4876 1
a4876 1
   		| : e10 e09'
d4882 1
a4882 1
    		| Empty
d4885 1
a4885 1
   		| [ expr ]
d5023 1
a5023 1
   	| e05  */
d5071 1
a5071 1
   	| Empty  */
d5096 1
a5096 1
   	| e10 e09'
d5099 1
a5099 1
   	| : e10 e09'
d5185 1
a5185 1
   	| Empty  */
d5231 1
a5231 1
   	| [ expr ]
@


1.76
log
@	* tc-i386.c (md_assemble): Handle third byte of the opcode as prefix.
	* i386.h (i386_optab): Make [sml]fence template to use immext field.
@
text
@d1866 5
a1870 2
	    as_bad (_("Extended register `%%%s' available only in 64bit mode."),
		    i.op[op].regs->reg_name);
a2011 2
	    if (flag_code < CODE_64BIT)
	      as_bad (_("64bit operations available only in 64bit modes."));
d2201 1
d2203 6
@


1.75
log
@
	* tc-i386.c (cpu_arch): Add Pentium4 and modify sledgehammer entry.
	* NEWS: Add note about Pentium4 support.
@
text
@d2829 5
d2853 1
a2853 1
	else if (fits_in_unsigned_word (i.tm.base_opcode))
a2859 17
	  }
	else
	  {			/* Opcode is either 3 or 4 bytes.  */
	    if (i.tm.base_opcode & 0xff000000)
	      {
		insn_size += 4;
		p = frag_more (4);
		*p++ = (i.tm.base_opcode >> 24) & 0xff;
	      }
	    else
	      {
		insn_size += 3;
		p = frag_more (3);
	      }
	    *p++ = (i.tm.base_opcode >> 16) & 0xff;
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
	    *p = (i.tm.base_opcode) & 0xff;
@


1.74
log
@
	* tc-i387.c (pi, pte, pt): Update.
	(type_names): Add new types.
@
text
@d355 1
d358 1
a358 1
  {"sledgehammer",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuSledgehammer|CpuMMX|Cpu3dnow|CpuSSE },
@


1.73
log
@2000-12-22  H.J. Lu  <hjl@@gnu.org>

	* config/tc-i386.c (reloc): Update the macro for non-bfd
	assembler.
	(BFD_RELOC_X86_64_GOTPCREL): Set to 0 for non-bfd assembler.
@
text
@d919 1
a919 2
  register template *p;
  int i;
d923 5
a927 1
  fprintf (stdout, "  modrm:  mode %x  reg %x  reg/mem %x",
d929 4
a932 2
  fprintf (stdout, " base %x  index %x  scale %x\n",
	   x->bi.base, x->bi.index, x->bi.scale);
d952 1
a952 1
  int i;
d1012 1
d1017 2
d1024 2
d1049 3
a1051 10
  if (t == Unknown)
    {
      fprintf (stdout, _("Unknown"));
    }
  else
    {
      for (ty = type_names; ty->mask; ty++)
	if (t & ty->mask)
	  fprintf (stdout, "%s, ", ty->tname);
    }
@


1.72
log
@
	* tc-i386.h (i386_target_format): Define even for ELFs.
	(QWORD_MNEM_SUFFIX): New macro.
	(CpuK6,CpuAthlon,CpuSledgehammer, Cpu64, CpuNo64, CpuUnknownFlags):
	New macros
	(CpuMMX,CpuSSE,Cpu3dnow, CpuUnknown): Renumber.
	(IgnoreSize, DefaultSize, No_?Suf, FWait, IsString, regKludge, IsPrefix,
	ImmExt): Renumber.
	(Size64, No_qSuf, NoRex64, Rex64): New macros.
	(Reg64, Imm32S, Imm64, Disp32S, Disp64): New macros.
	(Imm8, Imm8S, Imm16, Imm32, Imm1, BaseIndex, Disp8, Disp16, Disp32,
	InOutPortReg,ShiftCount, Control, Debug, Test, FloatReg, FloatAcc,
	SReg2, SReg3, Acc, JumpAbsolute, RegMMX, RegXMM, EsSeg, InvMem): Renumber.
	(Reg, WordReg): Add Reg64.
	(Imm): Add Imm32S and Imm64.
	(EncImm): New.
	(Disp): Add Disp64 and Disp32S.
	(AnyMem): Add Disp32S.
	(RegRex, RegRex64): New macros.
	(rex_byte): New type.
	* tc-i386.c (set_16bit_code_flag): Kill.
	(fits_in_unsigned_long, fits_in_signed_long): New functions.
	(reloc): New parameter "signed"; support x86_64.
	(set_code_flag): New.
	(DEFAULT_ARCH): New macro; default to "i386".
	(default_arch): New static variable.
	(struct _i386_insn): New fields Operand_PCrel; rex.
	(flag_16bit_code): Kill; All tests replaced to "flag_code == CODE_64BIT";
	(flag_code): New enum and static variable.
	(use_rela_relocations): New static variable.
	(flag_code_names): New static variable.
	(cpu_arch_flags): Default to CpuUnknownFlags|CpuNo64.
	(cpu_arch): Add "sledgehammer"; Add CPUAthlon to Athlon and CpuK6 to
	K6 and Athlon.
	(i386_align_code): Return plain "nop" for x86_64.
	(mode_from_disp_size): Support Disp32S.
	(smallest_imm_type): Support Imm32S and Imm64.
	(offset_in_range): Support size of 8.
	(set_cpu_arch): Do not clobber to Cpu64/CpuNo64.
	(md_pseudo_table): Add "code64"; use set_code_flat.
	(md_begin): Emit sane error message on hash failure.
	(tc_i386_fix_adjustable): Support x86_64 relocations.
	(md_assemble): Support QWORD_MNEM_SUFFIX, REX registers,
	instructions supported on particular arch just partially,
	output of 64bit immediates, handling of Imm32S and Disp32S type.
	(i386_immedaite): Support x86_64 relocations; support 64bit constants.
	(i386_displacement): Likewise.
	(i386_index_check): Cleanup; support 64bit addresses.
	(md_apply_fix3): Support x86_64 relocation and rela.
	(md_longopts): Add "32" and "64".
	(md_parse_option): Add OPTION_32 and OPTION_64.
	(i386_target_format): Call even for ELFs; choose between
	elf64-x86-64 and elf32-i386.
	(i386_validate_fix): Refuse GOTOFF in 64bit mode.
	(tc_gen_reloc): Support rela relocations and x86_64.
	(intel_e09_1): Support QWORD.

	* i386.h (i386_optab): Replace "Imm" with "EncImm".
	(i386_regtab): Add flags field.
@
text
@d1144 11
a1154 10
#define reloc(SIZE,PCREL,OTHER)	0
#define BFD_RELOC_16		0
#define BFD_RELOC_32		0
#define BFD_RELOC_16_PCREL	0
#define BFD_RELOC_32_PCREL	0
#define BFD_RELOC_386_PLT32	0
#define BFD_RELOC_386_GOT32	0
#define BFD_RELOC_386_GOTOFF	0
#define BFD_RELOC_X86_64_PLT32	0
#define BFD_RELOC_X86_64_GOT32	0
@


1.71
log
@2000-12-15  Diego Novillo  <dnovillo@@redhat.com>

	* config/tc-i386.c (intel_e09_1): Only flag as a memory operand if
	it's not an offset expression.
	(intel_e10_1): Ditto. Also, if the operand is an offset expression,
	keep the braces '[' and ']' in the output string.
	(intel_e11): Ditto. Also remove comparison intel_parser.op_modifier
	!= FLAT. There is no such op_modifier.
@
text
@d24 1
d59 2
d64 1
a64 1
static void set_16bit_code_flag PARAMS ((int));
d71 1
a71 1
  PARAMS ((int, int, bfd_reloc_code_real_type));
d74 5
d114 4
d144 1
d236 18
a253 3
/* 1 if we're writing 16-bit code,
   0 if 32-bit.  */
static int flag_16bit_code;
d274 1
a274 1
static unsigned int cpu_arch_flags = 0;
d355 3
a357 2
  {"k6",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX|Cpu3dnow },
  {"athlon",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|Cpu3dnow },
d433 5
d440 1
a440 1
      if (flag_16bit_code)
d471 1
a471 1
  return (t & Disp8) ? 1 : (t & (Disp16 | Disp32)) ? 2 : 0;
d501 21
d527 2
a528 2
  if (cpu_arch_flags != 0
      && cpu_arch_flags != (Cpu086 | Cpu186 | Cpu286 | Cpu386 | Cpu486))
d536 1
a536 1
	return Imm1 | Imm8 | Imm8S | Imm16 | Imm32;
d539 1
a539 1
	  ? (Imm8S | Imm8 | Imm16 | Imm32)
d541 1
a541 1
	  ? (Imm8 | Imm16 | Imm32)
d543 6
a548 2
	  ? (Imm16 | Imm32)
	  : (Imm32));
d563 3
d570 3
a572 2
  if ((val & ~(((addressT) 2 << 31) - 1)) == 0)
    val = (val ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);
d595 7
a601 4
  switch (prefix)
    {
    default:
      abort ();
d603 8
a610 8
    case CS_PREFIX_OPCODE:
    case DS_PREFIX_OPCODE:
    case ES_PREFIX_OPCODE:
    case FS_PREFIX_OPCODE:
    case GS_PREFIX_OPCODE:
    case SS_PREFIX_OPCODE:
      q = SEG_PREFIX;
      break;
d612 7
a618 7
    case REPNE_PREFIX_OPCODE:
    case REPE_PREFIX_OPCODE:
      ret = 2;
      /* fall thru */
    case LOCK_PREFIX_OPCODE:
      q = LOCKREP_PREFIX;
      break;
d620 3
a622 3
    case FWAIT_OPCODE:
      q = WAIT_PREFIX;
      break;
d624 3
a626 3
    case ADDR_PREFIX_OPCODE:
      q = ADDR_PREFIX;
      break;
d628 4
a631 4
    case DATA_PREFIX_OPCODE:
      q = DATA_PREFIX;
      break;
    }
d645 2
a646 2
set_16bit_code_flag (new_16bit_code_flag)
     int new_16bit_code_flag;
d648 11
a658 1
  flag_16bit_code = new_16bit_code_flag;
d663 2
a664 2
set_16bit_gcc_code_flag (new_16bit_code_flag)
     int new_16bit_code_flag;
d666 4
a669 2
  flag_16bit_code = new_16bit_code_flag;
  stackop_size = new_16bit_code_flag ? 'l' : '\0';
d728 1
a728 1
	      cpu_arch_flags = cpu_arch[i].flags;
d760 4
a763 3
  {"code16gcc", set_16bit_gcc_code_flag, 1},
  {"code16", set_16bit_code_flag, 1},
  {"code32", set_16bit_code_flag, 0},
a810 1
	      hash_error:
d834 3
a836 1
	  goto hash_error;
a1069 2
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, bfd_reloc_code_real_type));
d1072 1
a1072 1
reloc (size, pcrel, other)
d1075 1
d1083 2
d1095 15
a1109 7
      switch (size)
	{
	case 1: return BFD_RELOC_8;
	case 2: return BFD_RELOC_16;
	case 4: return BFD_RELOC_32;
	}
      as_bad (_("can not do %d byte relocation"), size);
d1112 1
d1136 2
d1152 2
d1250 1
a1250 1
		    ^ flag_16bit_code))
d1279 1
d1317 2
a1318 1
	if (current_templates->start->cpu_flags & ~cpu_arch_flags)
d1323 1
a1323 1
	else if ((Cpu386 & ~cpu_arch_flags) && !flag_16bit_code)
d1493 1
a1493 1
	enum bfd_reloc_code_real temp_disp_reloc;
d1495 1
a1495 1
	int temp_disp_reloc;
d1516 1
a1516 1
	temp_disp_reloc = i.disp_reloc[xchg2];
d1518 1
a1518 1
	i.disp_reloc[xchg1] = temp_disp_reloc;
d1551 4
d1558 1
a1558 1
	else if (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0))
d1562 1
a1562 2
	  if ((i.types[op] & Imm)
	      && i.op[op].imms->X_op == O_constant)
d1564 16
a1579 10
	      /* If a suffix is given, this operand may be shortened.  */
	      switch (guess_suffix)
		{
		case WORD_MNEM_SUFFIX:
		  i.types[op] |= Imm16;
		  break;
		case BYTE_MNEM_SUFFIX:
		  i.types[op] |= Imm16 | Imm8 | Imm8S;
		  break;
		}
d1581 45
a1625 9
	      /* If this operand is at most 16 bits, convert it to a
		 signed 16 bit number before trying to see whether it will
		 fit in an even smaller size.  This allows a 16-bit operand
		 such as $0xffe0 to be recognised as within Imm8S range.  */
	      if ((i.types[op] & Imm16)
		  && (i.op[op].imms->X_add_number & ~(offsetT)0xffff) == 0)
		{
		  i.op[op].imms->X_add_number =
		    (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
a1626 1
	      i.types[op] |= smallest_imm_type ((long) i.op[op].imms->X_add_number);
d1650 17
a1666 1
	      if (fits_in_signed_byte (disp))
d1683 3
a1685 1
			     : (i.suffix == LONG_DOUBLE_MNEM_SUFFIX ? No_xSuf : 0)))));
a1745 1
		break;
d1748 1
a1748 1
	    if (t->operands == 3)
d1766 5
d1855 10
d1867 1
a1867 1
    if (i.tm.opcode_modifier & (Size16 | Size32))
d1871 2
d1892 1
d1912 1
d1926 7
d1973 11
d1985 34
d2020 2
a2021 2
	      else if (!quiet_warnings
		       && (i.types[op] & Reg16) != 0
d2024 5
a2028 4
		  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			   (i.op[op].regs + 8)->reg_name,
			   i.op[op].regs->reg_name,
			   i.suffix);
a2029 1
#endif
a2045 1
#if REGISTER_WARNINGS
d2047 1
a2047 1
	      else if (!quiet_warnings
d2051 13
a2063 4
		  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			   (i.op[op].regs - 8)->reg_name,
			   i.op[op].regs->reg_name,
			   i.suffix);
a2064 1
#endif
a2075 1

d2078 1
a2078 1
    if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32))
d2080 2
a2081 1
	&& overlap0 != Imm16 && overlap0 != Imm32)
d2086 2
a2087 1
			 (i.suffix == WORD_MNEM_SUFFIX ? Imm16 : Imm32));
d2089 3
a2091 1
	else if (overlap0 == (Imm16 | Imm32))
d2094 1
a2094 1
	      (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32;
d2096 3
a2098 1
	else
d2104 1
a2104 1
    if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32))
d2106 2
a2107 1
	&& overlap1 != Imm16 && overlap1 != Imm32)
d2112 2
a2113 1
			 (i.suffix == WORD_MNEM_SUFFIX ? Imm16 : Imm32));
d2115 3
a2117 1
	else if (overlap1 == (Imm16 | Imm32))
d2120 1
a2120 1
	      (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32;
d2122 3
a2124 1
	else
d2126 1
a2126 1
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
d2180 2
a2181 1
	if ((i.suffix == LONG_MNEM_SUFFIX) == flag_16bit_code
d2191 6
d2251 2
d2303 4
d2312 4
d2337 1
a2337 1
			    if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
d2343 1
a2343 1
			    else
d2349 12
d2369 6
a2374 1
			    i.types[op] |= Disp32;	/* Must be 32 bit.  */
d2377 8
d2415 1
a2415 1
		    else /* i.base_reg and 32 bit mode  */
d2417 8
d2426 2
d2429 3
a2431 1
			if (i.base_reg->reg_num == EBP_REG_NUM)
d2465 2
d2509 5
a2513 1
		      i.rm.regmem = i.op[op].regs->reg_num;
d2515 5
a2519 1
		      i.rm.reg = i.op[op].regs->reg_num;
d2542 2
d2592 41
d2645 1
a2645 1
	if (flag_16bit_code)
d2655 5
d2677 1
a2677 1
	if (prefix)
d2679 2
d2714 1
a2714 1
	    if (flag_16bit_code)
d2730 7
d2755 1
a2755 1
		     i.op[0].disps, 1, reloc (size, 1, i.disp_reloc[0]));
d2764 1
a2764 1
	if (flag_16bit_code)
d2774 5
d2790 2
a2791 1
	if (prefix)
d2793 4
d2813 1
a2813 1
		       i.op[1].imms, 0, reloc (size, 0, i.disp_reloc[0]));
d2911 1
a2911 1
			if (i.types[n] & (Disp8 | Disp16))
d2916 2
d2928 2
d2931 36
a2966 2
			if (i.types[n] & Disp16)
			  size = 2;
d2971 2
a2972 2
				     i.op[n].disps, 0,
				     reloc (size, 0, i.disp_reloc[n]));
d2993 1
a2993 1
			if (i.types[n] & (Imm8 | Imm8S | Imm16))
d2998 2
d3019 1
d3021 11
a3031 4
			if (i.types[n] & Imm16)
			  size = 2;
			else if (i.types[n] & (Imm8 | Imm8S))
			  size = 1;
d3035 1
a3035 1
			reloc_type = reloc (size, 0, i.disp_reloc[0]);
d3046 3
d3113 1
a3113 1
	if (flag_16bit_code)
d3121 4
a3124 1
	    i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
d3129 2
d3136 12
a3147 1
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
d3183 1
a3183 2

  if (exp->X_op == O_constant)
d3186 5
a3190 1
      i.types[this_operand] |= Imm32;
d3218 2
a3219 4
	 suffix, or the default for the section.  We exclude
	 Imm8S here so that `push $foo' and other instructions
	 with an Imm8S form will use Imm16 or Imm32.  */
      i.types[this_operand] |= (Imm8 | Imm16 | Imm32);
d3278 1
a3278 1
  if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
d3280 2
d3351 1
a3351 1
	if (flag_16bit_code)
d3359 4
a3362 1
	    i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
d3367 2
d3374 11
a3384 1
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
d3408 2
a3409 1
  if (i.disp_reloc[this_operand] == BFD_RELOC_386_GOTOFF)
d3460 2
d3474 1
d3480 42
a3521 18
  if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0)
      /* 16 bit mode checks.  */
      ? ((i.base_reg
	  && ((i.base_reg->reg_type & (Reg16|BaseIndex))
	      != (Reg16|BaseIndex)))
	 || (i.index_reg
	     && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		  != (Reg16|BaseIndex))
		 || ! (i.base_reg
		       && i.base_reg->reg_num < 6
		       && i.index_reg->reg_num >= 6
		       && i.log2_scale_factor == 0))))
      /* 32 bit mode checks.  */
      : ((i.base_reg
	  && (i.base_reg->reg_type & Reg32) == 0)
	 || (i.index_reg
	     && ((i.index_reg->reg_type & (Reg32|BaseIndex))
		 != (Reg32|BaseIndex)))))
d3524 2
a3525 1
      if (i.prefix[ADDR_PREFIX] == 0 && stackop_size != '\0')
d3546 1
a3546 1
		flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0) ? "16" : "32");
d4145 1
d4193 1
d4197 1
d4211 12
d4224 1
d4369 4
d4408 28
d4461 2
a4462 3
#if ((defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_COFF)) \
     || (defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_AOUT)) \
     || (defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)))
d4469 6
d4485 1
a4485 1
#ifdef OBJ_MAYBE_ELF
d4487 5
a4491 1
      return "elf32-i386";
d4584 3
d4602 3
d4609 1
d4641 1
d4650 6
a4655 1
    code = BFD_RELOC_386_GOTPC;
d4662 6
a4667 4
  /* HACK: Since i386 ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    rel->address = fixp->fx_offset;
d4669 6
a4674 2
  if (fixp->fx_pcrel)
    rel->addend = fixp->fx_addnumber;
d4676 15
a4690 1
    rel->addend = 0;
d5148 1
a5148 5
	    {
	      as_bad (_("operand modifier `%s' supported only for i387 operations\n"),
		      prev_token.str);
	      return 0;
	    }
@


1.70
log
@	* tc-i386.c (md_assemble): Refuse 's' and 'l' suffixes in the intel
	mode; convert 'd' suffix to 's' or 'l'; remove all DWORD_MNEM_SUFFIX
	references.
	(intel_e09_1): Convert QWORD to 'l' suffix for FP operations; refuse
	otherwise.
	* tc-i386.h (DWORD_MNEM_SUFFIX): Kill.
	(No_dSuf): Kill.

	* i386.h (*_Suf): Remove No_dSuf.
	(d_suf, wld_Suf,sld_Suf, sldx_Suf, bwld_Suf, d_FP, sld_FP, sldx_FP)
	Remove.
	(i386_optab): Remove 'd' in the suffixes.
@
text
@d4591 4
a4594 1
      intel_parser.is_mem = 1;
d4621 8
a4628 1
      intel_parser.is_mem = 1;
d4631 2
a4632 1
      if (*intel_parser.disp != '\0')
d4635 10
a4644 1
      return (intel_expr () && intel_match_token (']') && intel_e10_1 ());
d4686 8
a4693 1
      intel_parser.is_mem = 1;
d4703 2
a4704 1
      if (*intel_parser.disp != '\0')
d4707 10
a4716 1
      return (intel_expr () && intel_match_token (']'));
d4741 5
a4745 1
      intel_parser.is_mem = 1;
d4876 1
a4876 2
      if (intel_parser.op_modifier != OFFSET_FLAT
	  && intel_parser.op_modifier != FLAT)
@


1.69
log
@Fix T_SHORT macro conflict.
@
text
@a1184 2
	  case SHORT_MNEM_SUFFIX:
	  case LONG_MNEM_SUFFIX:
d1189 9
d1200 1
a1200 1
	  case DWORD_MNEM_SUFFIX:
d1203 4
a1206 1
		i.suffix = mnem_p[-1];
a1208 1
		break;
d1210 1
d1527 1
a1527 3
			     : (i.suffix == DWORD_MNEM_SUFFIX
				? No_dSuf
				: (i.suffix == LONG_DOUBLE_MNEM_SUFFIX ? No_xSuf : 0))))));
d1934 1
a1934 2
	if (((intel_syntax && (i.suffix == DWORD_MNEM_SUFFIX))
	     || i.suffix == LONG_MNEM_SUFFIX) == flag_16bit_code
d1945 1
a1945 2
	if (i.suffix == LONG_MNEM_SUFFIX
	    || (intel_syntax && i.suffix == DWORD_MNEM_SUFFIX))
d4563 10
a4572 1
	i.suffix = DWORD_MNEM_SUFFIX;
@


1.68
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d4333 3
a4335 1
/* Token codes for the intel parser.  */
d4344 1
@


1.67
log
@2000-11-30  Diego Novillo  <dnovillo@@redhat.com>

	* tc-i386.c (md_assemble): Swap i.disp_relocs when using intel
	syntax.

2000-11-30  Diego Novillo  <dnovillo@@redhat.com>

	* intel.s, intel.d: New test for @@GOT references.
@
text
@d273 1
a273 1
  ((relax_substateT)((type<<2) | (size)))
d4846 1
a4846 1
	abort();
d4964 1
a4964 1
    abort();
@


1.66
log
@        * config/tc-i386.c (md_pseudo_table): Add .file and .loc.
@
text
@d1386 5
d1410 3
@


1.65
log
@        * config/tc-i386.c (md_assemble): Call dwarf2_emit_insn.
@
text
@d31 1
d687 2
@


1.64
log
@2000-11-14  Kazu Hirata  <kazu@@hxi.com>

	* config/aout_gnu.h: Fix formatting.
	* config/atof-vax.c: Likewise.
	* config/m68k-parse.h: Likewise.
	* config/m88k-opcode.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/te-386bsd.h: Likewise.
	* config/te-hppa.h: Likewise.
	* config/te-nbsd.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-sparcaout.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/vax-inst.h: Likewise.
	* config/vms-conf.h: Likewise.
@
text
@d2616 2
@


1.63
log
@2000-10-25  Diego Novillo  <dnovillo@@cygnus.com>

	* tc-i386.c: Fix prototype declarations for functions taking no
	arguments.
@
text
@a4188 1

a4253 1

d4302 1
a4302 1
    int op_modifier;		/* Operand modifier. */
a4348 1

a4417 1

a4436 1

d4439 1
a4439 1
   e05'	addOp e06 e05' 
d4462 1
a4462 2
} 

d4485 1
a4485 1
  
d4487 1
a4487 1
  else 
a4490 1

d4588 1
a4588 1
      
a4600 1

d4608 1
a4608 1
	| $ 
d4636 1
a4636 1
      
d4651 1
a4651 1
  /* e11  BYTE 
d4728 1
a4728 1
	  /* What follows must be a valid scale. */
d4771 1
a4771 1
	
d4794 1
a4794 1
    
d4850 1
a4850 1
	      /* The constant is followed by `* reg', so it must be 
a4894 1

a4898 1

a4916 1

d4929 1
a4929 1
  /* Free the memory allocated to the previous token and move 
d4968 1
a4968 1
	  && (intel_parser.op_string[1] == 'b' 
a5061 1

d5070 1
a5070 1
  
@


1.62
log
@2000-10-24  Diego Novillo  <dnovillo@@cygnus.com>

	* tc-i386.c (i386_operand_modifier): Remove.
	(build_displacement_string): Remove.
	(i386_parse_seg): Remove.
	(i386_intel_memory_operand): Remove.
	(i386_intel_operand): Re-write using recursive descent parser based
	on MASM documentation.
	(struct intel_parser_s): New structure.
	(intel_parser): New static variable.
	(struct intel_token): New structure.
	(cur_token, prev_token): New static variables.
	(T_NIL): Define.
	(T_CONST): Define.
	(T_REG): Define.
	(T_BYTE): Define.
	(T_WORD): Define.
	(T_DWORD): Define.
	(T_QWORD): Define.
	(T_XWORD): Define.
	(T_SHORT): Define.
	(T_OFFSET): Define.
	(T_PTR): Define.
	(T_ID): Define.
	(intel_match_token): New function.
	(intel_get_token): New function.
	(intel_putback_token): New function.
	(intel_expr): New function.
	(intel_e05): New function.
	(intel_e05_1): New function.
	(intel_e06): New function.
	(intel_e06_1): New function.
	(intel_e09): New function.
	(intel_e09_1): New function.
	(intel_e10): New function.
	(intel_e10_1): New function.
	(intel_e11): New function.

2000-10-24  Diego Novillo  <dnovillo@@cygnus.com>

	* intel.s, intel.d: Add new tests for intel syntax.
@
text
@d4338 12
a4349 12
static void intel_get_token	PARAMS (());
static void intel_putback_token	PARAMS (());
static int intel_expr		PARAMS (());
static int intel_e05		PARAMS (());
static int intel_e05_1		PARAMS (());
static int intel_e06		PARAMS (());
static int intel_e06_1		PARAMS (());
static int intel_e09		PARAMS (());
static int intel_e09_1		PARAMS (());
static int intel_e10		PARAMS (());
static int intel_e10_1		PARAMS (());
static int intel_e11		PARAMS (());
@


1.61
log
@gas:

2000-10-15  Diego Novillo  <dnovillo@@cygnus.com>

	* config/tc-i386.c (i386_operand_modifier): Only match
	modifiers SHORT and FLAT if they are followed by a space.
	(parse_register): When `allow_naked_reg' is set, do not confuse
	identifiers that start with a register name with a register.

gas/testsuite:

2000-10-15  Diego Novillo  <dnovillo@@cygnus.com>

	* intel.s, intel.d: Add new tests for naked registers using intel
	syntax.
@
text
@a2980 199
static int i386_operand_modifier PARAMS ((char **, int));

static int
i386_operand_modifier (op_string, got_a_float)
     char **op_string;
     int got_a_float;
{
  if (!strncasecmp (*op_string, "BYTE PTR", 8))
    {
      i.suffix = BYTE_MNEM_SUFFIX;
      *op_string += 8;
      return BYTE_PTR;

    }
  else if (!strncasecmp (*op_string, "WORD PTR", 8))
    {
      if (got_a_float == 2)	/* "fi..."  */
	i.suffix = SHORT_MNEM_SUFFIX;
      else
	i.suffix = WORD_MNEM_SUFFIX;
      *op_string += 8;
      return WORD_PTR;
    }

  else if (!strncasecmp (*op_string, "DWORD PTR", 9))
    {
      if (got_a_float == 1)	/* "f..."  */
	i.suffix = SHORT_MNEM_SUFFIX;
      else
	i.suffix = LONG_MNEM_SUFFIX;
      *op_string += 9;
      return DWORD_PTR;
    }

  else if (!strncasecmp (*op_string, "QWORD PTR", 9))
    {
      i.suffix = DWORD_MNEM_SUFFIX;
      *op_string += 9;
      return QWORD_PTR;
    }

  else if (!strncasecmp (*op_string, "XWORD PTR", 9))
    {
      i.suffix = LONG_DOUBLE_MNEM_SUFFIX;
      *op_string += 9;
      return XWORD_PTR;
    }

  /* Compare with space separator to avoid confusing identifier `short_var'
     with attribute `short'.  */
  else if (!strncasecmp (*op_string, "SHORT ", 6))
    {
      *op_string += 5;
      return SHORT;
    }

  else if (!strncasecmp (*op_string, "OFFSET FLAT:", 12))
    {
      *op_string += 12;
      return OFFSET_FLAT;
    }

  /* Compare with space separator to avoid confusing identifier `flat_var'
     with attribute `flat'.  */
  else if (!strncasecmp (*op_string, "FLAT ", 5))
    {
      *op_string += 4;
      return FLAT;
    }

  else return NONE_FOUND;
}

static char * build_displacement_string PARAMS ((int, char *));

static char *
build_displacement_string (initial_disp, op_string)
     int initial_disp;
     char *op_string;
{
  char *temp_string = (char *) malloc (strlen (op_string) + 1);
  char *end_of_operand_string;
  char *tc;
  char *temp_disp;

  temp_string[0] = '\0';
  tc = end_of_operand_string = strchr (op_string, '[');
  if (initial_disp && !end_of_operand_string)
    {
      strcpy (temp_string, op_string);
      return temp_string;
    }

  /* Build the whole displacement string.  */
  if (initial_disp)
    {
      strncpy (temp_string, op_string, end_of_operand_string - op_string);
      temp_string[end_of_operand_string - op_string] = '\0';
      temp_disp = tc;
    }
  else
    temp_disp = op_string;

  while (*temp_disp != '\0')
    {
      char *end_op;
      int add_minus = (*temp_disp == '-');

      if (*temp_disp == '+' || *temp_disp == '-' || *temp_disp == '[')
	temp_disp++;

      if (is_space_char (*temp_disp))
	temp_disp++;

      /* Don't consider registers.  */
      if ( !((*temp_disp == REGISTER_PREFIX || allow_naked_reg)
	     && parse_register (temp_disp, &end_op)) )
	{
	  char *string_start = temp_disp;

	  while (*temp_disp != ']'
		 && *temp_disp != '+'
		 && *temp_disp != '-'
		 && *temp_disp != '*')
	    ++temp_disp;

	  if (add_minus)
	    strcat (temp_string, "-");
	  else
	    strcat (temp_string, "+");

	  strncat (temp_string, string_start, temp_disp - string_start);
	  if (*temp_disp == '+' || *temp_disp == '-')
	    --temp_disp;
	}

      while (*temp_disp != '\0'
	     && *temp_disp != '+'
	     && *temp_disp != '-')
	++temp_disp;
    }

  return temp_string;
}

static int i386_parse_seg PARAMS ((char *));

static int
i386_parse_seg (op_string)
     char *op_string;
{
  if (is_space_char (*op_string))
    ++op_string;

  /* Should be one of es, cs, ss, ds fs or gs.  */
  switch (*op_string++)
    {
    case 'e':
      i.seg[i.mem_operands] = &es;
      break;
    case 'c':
      i.seg[i.mem_operands] = &cs;
      break;
    case 's':
      i.seg[i.mem_operands] = &ss;
      break;
    case 'd':
      i.seg[i.mem_operands] = &ds;
      break;
    case 'f':
      i.seg[i.mem_operands] = &fs;
      break;
    case 'g':
      i.seg[i.mem_operands] = &gs;
      break;
    default:
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  if (*op_string++ != 's')
    {
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  if (is_space_char (*op_string))
    ++op_string;

  if (*op_string != ':')
    {
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  return 1;

}

a3041 246
static int i386_intel_memory_operand PARAMS ((char *));

static int
i386_intel_memory_operand (operand_string)
     char *operand_string;
{
  char *op_string = operand_string;
  char *end_of_operand_string;

  if ((i.mem_operands == 1
       && (current_templates->start->opcode_modifier & IsString) == 0)
      || i.mem_operands == 2)
    {
      as_bad (_("too many memory references for `%s'"),
	      current_templates->start->name);
      return 0;
    }

  /* First check for a segment override.  */
  if (*op_string != '[')
    {
      char *end_seg;

      end_seg = strchr (op_string, ':');
      if (end_seg)
	{
	  if (!i386_parse_seg (op_string))
	    return 0;
	  op_string = end_seg + 1;
	}
    }

  /* Look for displacement preceding open bracket.  */
  if (*op_string != '[')
    {
      char *temp_string;

      if (i.disp_operands)
	return 0;

      temp_string = build_displacement_string (true, op_string);

      if (!i386_displacement (temp_string, temp_string + strlen (temp_string)))
	{
	  free (temp_string);
	  return 0;
	}
      free (temp_string);

      end_of_operand_string = strchr (op_string, '[');
      if (!end_of_operand_string)
	end_of_operand_string = op_string + strlen (op_string);

      if (is_space_char (*end_of_operand_string))
	--end_of_operand_string;

      op_string = end_of_operand_string;
    }

  if (*op_string == '[')
    {
      ++op_string;

      /* Pick off each component and figure out where it belongs.  */

      end_of_operand_string = op_string;

      while (*op_string != ']')
	{
	  const reg_entry *temp_reg;
	  char *end_op;
	  char *temp_string;

	  while (*end_of_operand_string != '+'
		 && *end_of_operand_string != '-'
		 && *end_of_operand_string != '*'
		 && *end_of_operand_string != ']')
	    end_of_operand_string++;

	  temp_string = op_string;
	  if (*temp_string == '+')
	    {
	      ++temp_string;
	      if (is_space_char (*temp_string))
		++temp_string;
	    }

	  if ((*temp_string == REGISTER_PREFIX || allow_naked_reg)
	      && (temp_reg = parse_register (temp_string, &end_op)) != NULL)
	    {
	      if (i.base_reg == NULL)
		i.base_reg = temp_reg;
	      else
		i.index_reg = temp_reg;

	      i.types[this_operand] |= BaseIndex;
	    }
	  else if (*temp_string == REGISTER_PREFIX)
	    {
	      as_bad (_("bad register name `%s'"), temp_string);
	      return 0;
	    }
	  else if (is_digit_char (*op_string)
		   || *op_string == '+' || *op_string == '-')
	    {
	      char *temp_str;

	      if (i.disp_operands != 0)
		return 0;

	      temp_string = build_displacement_string (false, op_string);

	      temp_str = temp_string;
	      if (*temp_str == '+')
		++temp_str;

	      if (!i386_displacement (temp_str, temp_str + strlen (temp_str)))
		{
		  free (temp_string);
		  return 0;
		}
	      free (temp_string);

	      ++op_string;
	      end_of_operand_string = op_string;
	      while (*end_of_operand_string != ']'
		     && *end_of_operand_string != '+'
		     && *end_of_operand_string != '-'
		     && *end_of_operand_string != '*')
		++end_of_operand_string;
	    }
	  else if (*op_string == '*')
	    {
	      ++op_string;

	      if (i.base_reg && !i.index_reg)
		{
		  i.index_reg = i.base_reg;
		  i.base_reg = 0;
		}

	      if (!i386_scale (op_string))
		return 0;
	    }
	  op_string = end_of_operand_string;
	  ++end_of_operand_string;
	}
    }

  if (i386_index_check (operand_string) == 0)
    return 0;

  i.mem_operands++;
  return 1;
}

static int
i386_intel_operand (operand_string, got_a_float)
     char *operand_string;
     int got_a_float;
{
  const reg_entry *r;
  char *end_op;
  char *op_string = operand_string;

  int operand_modifier = i386_operand_modifier (&op_string, got_a_float);
  if (is_space_char (*op_string))
    ++op_string;

  switch (operand_modifier)
    {
    case BYTE_PTR:
    case WORD_PTR:
    case DWORD_PTR:
    case QWORD_PTR:
    case XWORD_PTR:
      if (!i386_intel_memory_operand (op_string))
	return 0;
      break;

    case FLAT:
    case OFFSET_FLAT:
      if (!i386_immediate (op_string))
	return 0;
      break;

    case SHORT:
    case NONE_FOUND:
      /* Should be register or immediate.  */
      if (is_digit_char (*op_string)
	  && strchr (op_string, '[') == 0)
	{
	  if (!i386_immediate (op_string))
	    return 0;
	}
      else if ((*op_string == REGISTER_PREFIX || allow_naked_reg)
	       && (r = parse_register (op_string, &end_op)) != NULL)
	{
	  /* Check for a segment override by searching for ':' after a
	     segment register.  */
	  op_string = end_op;
	  if (is_space_char (*op_string))
	    ++op_string;
	  if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
	    {
	      switch (r->reg_num)
		{
		case 0:
		  i.seg[i.mem_operands] = &es;
		  break;
		case 1:
		  i.seg[i.mem_operands] = &cs;
		  break;
		case 2:
		  i.seg[i.mem_operands] = &ss;
		  break;
		case 3:
		  i.seg[i.mem_operands] = &ds;
		  break;
		case 4:
		  i.seg[i.mem_operands] = &fs;
		  break;
		case 5:
		  i.seg[i.mem_operands] = &gs;
		  break;
		}

	    }
	  i.types[this_operand] |= r->reg_type & ~BaseIndex;
	  i.op[this_operand].regs = r;
	  i.reg_operands++;
	}
      else if (*op_string == REGISTER_PREFIX)
	{
	  as_bad (_("bad register name `%s'"), op_string);
	  return 0;
	}
      else if (!i386_intel_memory_operand (op_string))
	return 0;

      break;
    }

  return 1;
}

d4173 915
@


1.60
log
@Correct handling of non-global syms in linkonce sections.
Tidy a few comments.
@
text
@d3029 3
a3031 1
  else if (!strncasecmp (*op_string, "SHORT", 5))
d3043 3
a3045 1
  else if (!strncasecmp (*op_string, "FLAT", 4))
d4241 6
@


1.59
log
@	* tc-i386.c (md_assemble): Skip suffix check if the opcode modifier
	has the IgnoreSize bit set.
@
text
@d120 1
a120 1
    const seg_entry *seg[2];	/* segments for memory operands (if given) */
d145 1
a145 1
   pre-processor is disabled, these aren't very useful */
d158 2
a159 2
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
d161 2
a162 2
   #NO_APP at the beginning of its output.  */
/* Also note that comments started like this one will always work if
d172 2
a173 1
/* Chars that can be used to separate mant from exp in floating point nums */
d176 3
a178 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d181 1
a181 1
/* tables for lexical analysis */
d188 1
a188 1
/* lexical macros */
d196 1
a196 1
/* put here all non-digit non-letter charcters that may occur in an operand */
d204 1
a204 1
static char *save_stack_p;	/* stack pointer */
d254 2
a255 2
#define COND_JUMP 1		/* Conditional jump.  */
#define UNCOND_JUMP 2		/* Unconditional jump.  */
d290 1
a290 2
     4) which index into the table to try if we can't fit into this one.
  */
d336 3
a338 3
  /* Various efficient no-op patterns for aligning code labels.  */
  /* Note: Don't try to assemble the instructions in the comments.  */
  /*       0L and 0w are not legal */
d430 1
a430 1
symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
d824 1
a824 1
/* debugging routines for md_assemble */
d981 1
a981 1
  /* For COFF */
d1039 1
a1039 1
  /* adjust_reloc_syms doesn't know about the GOT */
d1098 1
a1098 1
  save_stack_p = save_stack;	/* reset stack pointer */
d1189 1
a1189 1
	  /* Intel Syntax */
d1220 1
a1220 1
    /* check for rep/repne without a string instruction */
a1231 2
	/* parse operands */

d1240 1
a1240 1
	    /* skip optional white space before operand */
d1312 1
a1312 1
		RESTORE_END_STRING (l);	/* restore old contents */
d1331 1
a1331 1
	    /* now *l must be either ',' or END_OF_INSN */
d1335 2
a1336 1
		  {		/* just skip it, if it's \n complain */
d1342 1
a1342 1
	while (*l != END_OF_INSN);	/* until we get end of insn */
d1524 2
a1525 2
		 && (t->extension_opcode == 5	/* 0xd9,5 "fldcw"  */
		     || t->extension_opcode == 7))) /* 0xd9,7 "f{n}stcw"  */
d1588 1
a1588 1
	       slip through to break */
d1592 1
a1592 1
      }				/* for (t = ...  */
d1643 1
a1643 1
    /* Check string instruction segment overrides */
d1741 1
a1741 1
		/* Any other register is bad */
d1871 1
a1871 1
      i.imm_operands = 0;	/* kludge for shift insns */
d1890 1
a1890 1
    /* For movzx and movsx, need to check the register type */
d2544 1
a2544 1
	  }			/* End displacement output.  */
d2574 3
a2576 2
		      {		/* Not absolute_section.  */
			/* Need a 32-bit fixup (don't support 8bit
d2613 1
a2613 1
	  }			/* end immediate output  */
d3300 1
a3300 1
      /* Pick off each component and figure out where it belongs */
d3425 1
a3425 1
      /* Should be register or immediate */
d3478 1
a3478 1
    }  /* end switch */
d3578 1
a3578 1
    {				/* ... or an immediate  */
d3757 2
a3758 1
    {				/* It's not a memory operand; argh!  */
a3821 1
	  /* dword disp jmp  */
@


1.58
log
@2000-08-05  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-cris.c: Fix formatting.
	* config/tc-i386.c: Likewise.
	* config/tc-sparc.c (sparc_ip): Simplify the code.
@
text
@d1522 2
d1813 3
@


1.57
log
@386.c (md_estimate_size_before_relax): Revert
more changes from Sept 1999
(tc_i386_fix_adjustable): ditto
(md_apply_fix3): ditto
@
text
@d3 1
a3 1
   Free Software Foundation.
d22 4
a25 6
/*
  Intel 80386 machine specific gas.
  Written by Eliot Dresselhaus (eliot@@mgm.mit.edu).
  Bugs & suggestions are completely welcome.  This is free software.
  Please help us make it better.
  */
d61 1
a61 1
static void set_16bit_gcc_code_flag PARAMS((int));
d71 1
a71 1
   i386_insn. */
d82 1
a82 1
    /* TM holds the template for the insn were currently assembling. */
d89 1
a89 1
    /* OPERANDS gives the number of given operands. */
d94 1
a94 1
       operands. */
d119 1
a119 1
       explicit segment overrides are given. */
d161 1
a161 1
   #NO_APP at the beginning of its output. */
d201 1
a201 1
   assembler instruction). */
d209 1
a209 1
/* The instruction we're assembling. */
d215 1
a215 1
/* Per instruction expressionS buffers: 2 displacements & 2 immediate max. */
d218 2
a219 1
static int this_operand;	  /* Current operand we are working on.  */
d221 3
a223 2
static int flag_16bit_code;	  /* 1 if we're writing 16-bit code,
				     0 if 32-bit.  */
d225 3
a227 1
static int intel_syntax = 0;	  /* 1 for intel syntax, 0 if att syntax.  */
d229 2
a230 1
static int allow_naked_reg = 0;   /* 1 if register prefix % not required  */
d232 4
a235 4
static char stackop_size = '\0';  /* Used in 16 bit gcc mode to add an l
				     suffix to call, ret, enter, leave, push,
				     and pop instructions so that gcc has the
				     same stack frame as in 32 bit mode.  */
d237 2
a238 1
static int quiet_warnings = 0;	  /* Non-zero to quieten some warnings. */
d240 2
a241 1
static const char *cpu_arch_name = NULL; /* cpu name  */
d243 2
a244 1
static unsigned int cpu_arch_flags = 0;  /* cpu feature flags  */
d252 4
a255 4
/* types */
#define COND_JUMP 1		/* conditional jump */
#define UNCOND_JUMP 2		/* unconditional jump */
/* sizes */
a330 1

d337 1
a337 1
  /* Note: Don't try to assemble the instructions in the comments. */
d407 4
a410 3
	  memcpy(fragP->fr_literal + fragP->fr_fix,
		 f16_patt[count - 1], count);
	  if (count > 8) /* adjust jump offset */
d414 2
a415 2
	memcpy(fragP->fr_literal + fragP->fr_fix,
	       f32_patt[count - 1], count);
d436 1
a436 1
  return (t & Disp8) ? 1 : (t & (Disp16|Disp32)) ? 2 : 0;
d444 1
a444 1
}				/* fits_in_signed_byte() */
d451 1
a451 1
}				/* fits_in_unsigned_byte() */
d458 1
a458 1
}				/* fits_in_unsigned_word() */
d465 1
a465 1
}				/* fits_in_signed_word() */
d472 1
a472 1
      && cpu_arch_flags != (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486))
d489 1
a489 1
}				/* smallest_imm_type() */
d503 1
a503 1
    default: abort();
d507 1
a507 1
  if ((val & ~ (((addressT) 2 << 31) - 1)) == 0)
d510 1
a510 1
  if ((val & ~ mask) != 0 && (val & ~ mask) != ~ mask)
d606 1
a606 1
      if (strcmp(string, "prefix") == 0)
d608 1
a608 1
      else if (strcmp(string, "noprefix") == 0)
d624 2
a625 1
      allow_naked_reg = 0; /* conservative default */
d634 1
a634 1
    int dummy ATTRIBUTE_UNUSED;
d636 1
a636 1
  SKIP_WHITESPACE();
d689 1
a689 1
/* for interface with expression () */
d692 1
a692 1
/* hash table for instruction mnemonic lookup */
d694 2
a695 1
/* hash table for register lookup */
a697 1

d703 1
a703 1
  /* initialize op_hash hash table */
d710 2
a711 1
    optab = i386_optab;		/* setup for loop */
d722 1
a722 1
	       add to hash table; & begin anew */
d742 1
a742 1
  /* initialize reg_hash hash table */
d757 1
a757 1
  /* fill in lexical tables:  mnemonic_chars, operand_chars.  */
a821 1

d866 1
a866 2
  fprintf (stdout, "opcode %x ",
	   t->base_opcode);
d996 2
a997 1
  if (other != NO_RELOC) return other;
d1023 5
a1027 6
/*
 * Here we decide which fixups can be adjusted to make them relative to
 * the beginning of the section instead of the symbol.  Basically we need
 * to make sure that the dynamic relocations are done correctly, so in
 * some cases we force the original symbol to be used.
 */
d1030 1
a1030 1
     fixS * fixP;
d1059 1
a1059 2
static int
intel_float_operand PARAMS ((char *mnemonic));
d1065 1
a1065 1
  if (mnemonic[0] == 'f' && mnemonic[1] =='i')
d1082 1
a1082 1
  /* Points to template once we've found it. */
d1092 1
a1092 1
  /* Initialize globals. */
d1102 1
a1102 1
     start of a (possibly prefixed) mnemonic. */
d1108 1
a1108 1
    /* Non-zero if we found a prefix only acceptable with string insns. */
d1165 1
a1165 2
		expecting_string_instruction =
		  current_templates->start->name;
d1209 1
a1209 1
	if (current_templates->start->cpu_flags & ~ cpu_arch_flags)
d1214 1
a1214 1
	else if ((Cpu386 & ~ cpu_arch_flags) && !flag_16bit_code)
d1229 1
a1229 1
    /* There may be operands to parse. */
d1234 1
a1234 1
	/* 1 if operand is pending after ','. */
d1237 1
a1237 1
	/* Non-zero if operand parens not balanced. */
d1295 1
a1295 1
	      {			/* yes, we've read in another operand */
d1304 1
a1304 1
		/* now parse operand adding info to 'i' as we go along */
d1308 3
a1310 1
		  operand_ok = i386_intel_operand (token_start, intel_float_operand (mnemonic));
d1352 1
a1352 1
     with the template operand types. */
d1428 1
a1428 1
	    for (op = i.operands; --op >= 0; )
d1441 1
a1441 1
	for (op = i.operands; --op >= 0; )
d1475 1
a1475 1
	for (op = i.operands; --op >= 0; )
d1487 1
a1487 1
		  
d1515 1
a1515 1
	/* Must have right number of operands. */
d1528 2
a1529 1
	  break;		/* 0 operands always matches */
d1548 1
a1548 2

		/* check if other direction is valid ... */
d1552 1
a1552 1
		/* try reversing direction of operands */
d1562 1
a1562 1
		    /* does not match either direction */
d1570 1
a1570 1
	    /* found a forward 2 operand match here */
d1586 1
a1586 1
	    /* found either forward/reverse 2 or 3 operand match here:
d1589 3
a1591 2
	break;			/* we've found a match; break out of loop */
      }				/* for (t = ... */
d1593 2
a1594 1
      {				/* we found no match */
d1685 1
a1685 1
	   based on register operands. */
d1692 1
a1692 1
	    for (op = i.operands; --op >= 0; )
d1705 1
a1705 1
	    for (op = i.operands; --op >= 0; )
d1709 1
a1709 1
		   we will just use the low portion, and that's OK too. */
d1713 1
a1713 1
		/* movzx and movsx should not generate this warning. */
d1757 2
a1758 1
	    for (op = i.operands; --op >= 0; )
d1762 1
a1762 1
		  && (i.tm.operand_types[op] & (Reg16|Reg32|Acc)) != 0)
d1786 1
a1786 1
	    for (op = i.operands; --op >= 0; )
d1812 1
a1812 1
	  abort();
d1940 1
a1940 1
	assert(i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);
d1950 1
a1950 1
    /* For insns with operands there are more diddles to do to the opcode. */
d1964 4
a1967 4
	    /* Pretend we saw the extra register operand. */
	    assert (i.op[first_reg_op+1].regs == 0);
	    i.op[first_reg_op+1].regs = i.op[first_reg_op].regs;
	    i.types[first_reg_op+1] = i.types[first_reg_op];
d1973 1
a1973 1
	    /* The register or float register operand is in operand 0 or 1. */
d1975 1
a1975 1
	    /* Register goes in low 3 bits of opcode. */
d1983 1
a1983 1
		    /* reversed arguments on faddp, fsubp, etc. */
d1990 1
a1990 1
		    /* extraneous `l' suffix on fp insn */
d2001 1
a2001 1
	       info we've collected. */
d2004 1
a2004 1
	       implicit registers do not count. */
d2035 1
a2035 1
	      {			/* if it's not 2 reg operands... */
d2052 1
a2052 1
			    /* Operand is just <disp> */
d2066 1
a2066 1
			else /* ! i.base_reg && i.index_reg */
d2073 1
a2073 1
			    i.types[op] |= Disp32;	/* Must be 32 bit */
d2080 1
a2080 1
			  case 3: /* (%bx) */
d2083 1
a2083 1
			    else /* (%bx,%si) -> 0, or (%bx,%di) -> 1 */
d2086 1
a2086 1
			  case 5: /* (%bp) */
d2093 1
a2093 1
				    /* fake (%bp) into 0(%bp) */
d2098 1
a2098 1
			    else /* (%bp,%si) -> 2, or (%bp,%di) -> 3 */
d2101 1
a2101 1
			  default: /* (%si) -> 4 or (%di) -> 5 */
d2106 1
a2106 1
		    else /* i.base_reg and 32 bit mode */
d2151 1
a2151 1
			   holds the correct displacement size. */
d2168 1
a2168 1
		   into the i.rm.reg field. */
d2184 1
a2184 1
		       register number must be put into the regmem field. */
d2197 1
a2197 1
		/* Fill in i.rm.reg field with extension opcode (if any). */
d2204 2
a2205 1
	    if (i.tm.base_opcode == POP_SEG_SHORT && i.op[0].regs->reg_num == 1)
d2242 1
a2242 1
  /* Handle conversion of 'int $3' --> special int3 insn. */
d2259 1
a2259 1
  /* We are ready to output the insn. */
d2263 1
a2263 1
    /* Output jumps. */
d2359 1
a2359 1
	    /* opcode can be at most two bytes */
d2394 2
a2395 1
	insn_size += prefix + 1 + 2 + size;  /* 1 opcode; 2 segment; offset */
d2423 1
a2423 1
	/* Output normal instructions here. */
d2426 1
a2426 1
	/* The prefix bytes. */
d2439 1
a2439 1
	/* Now the opcode; be careful about word order here! */
d2449 1
a2449 1
	    /* put out high byte first: can't use md_number_to_chars! */
d2454 1
a2454 1
	  {			/* opcode is either 3 or 4 bytes */
d2540 1
a2540 1
	  }			/* end displacement output */
d2542 1
a2542 1
	/* output immediate */
d2570 1
a2570 1
		      {		/* not absolute_section */
d2573 1
a2573 1
			   sizes ... */
d2608 1
a2608 1
	  }			/* end immediate output */
d2616 1
a2616 1
#endif /* DEBUG386 */
d2628 1
a2628 1
  expressionS * exp;
d2647 4
a2650 6
    /*
     * We can have operands of the form
     *   <symbol>@@GOTOFF+<nnn>
     * Take the easy way out here and copy everything
     * into a temporary buffer...
     */
d2660 1
a2660 1
	/* GOT relocations are not supported in 16 bit mode */
d2688 1
a2688 1
	tmpbuf = (char *) alloca (strlen(input_line_pointer));
d2707 1
a2707 1
      /* missing or bad expr becomes absolute 0 */
d2718 2
a2719 1
      i.types[this_operand] |= Imm32;	/* Size it properly later.  */
d2722 1
a2722 1
  else if (
d2724 1
a2724 1
	   OUTPUT_FLAVOR == bfd_target_aout_flavour &&
d2726 1
a2726 1
	   exp_seg != text_section
d2859 1
a2859 2
	 So here we provide the missing zero.
      */
d2866 4
a2869 6
    /*
     * We can have operands of the form
     *   <symbol>@@GOTOFF+<nnn>
     * Take the easy way out here and copy everything
     * into a temporary buffer...
     */
d2879 1
a2879 1
	/* GOT relocations are not supported in 16 bit mode */
d2907 1
a2907 1
	tmpbuf = (char *) alloca (strlen(input_line_pointer));
d2921 1
a2921 1
     to be relative to the beginning of the section */
d2946 1
a2946 1
      /* missing or bad expr becomes absolute 0 */
d2992 1
a2992 1
      if (got_a_float == 2)	/* "fi..." */
d3002 1
a3002 1
      if (got_a_float == 1)	/* "f..." */
d3065 1
a3065 1
  /* Build the whole displacement string */
d3086 1
a3086 1
      /* Don't consider registers */
d3126 1
a3126 1
  /* Should be one of es, cs, ss, ds fs or gs */
d3174 2
a3175 2
   Returns 1 on success, 0 on a failure.
*/
d3186 1
a3186 1
      /* 16 bit mode checks */
d3197 1
a3197 1
      /* 32 bit mode checks */
d3213 1
a3213 2
	     Removing them would probably clean up the code quite a lot.
	  */
d3264 1
a3264 1
  /* Look for displacement preceding open bracket */
d3393 1
a3393 1
  const reg_entry * r;
d3479 1
a3479 1
   on error. */
d3493 1
a3493 1
     for example, 'jmp pc_relative_label' from 'jmp *absolute_label'. */
d3502 1
a3502 1
  /* Check if operand is a register. */
d3548 1
a3548 1
	  /* Handle case of %es:*foo. */
d3573 1
a3573 1
    {				/* ... or an immediate */
d3587 1
a3587 1
      /* This is a memory reference of some sort. */
d3590 1
a3590 1
      /* Start and end of displacement string expression (if found). */
d3614 1
a3614 1
      /* If we only have a displacement, set-up for it to be parsed later. */
d3623 1
a3623 1
	     equal, so this loop will not be infinite. */
d3688 1
a3688 1
		  /* Check for scale factor. */
d3752 1
a3752 1
    {				/* it's not a memory operand; argh! */
d3759 1
a3759 1
  return 1;			/* normal return */
d3814 4
a3817 2
	case JUMP_PC_RELATIVE:	/* make jmp (0xeb) a dword displacement jump */
	  opcode[0] = 0xe9;	/* dword disp jmp */
d3830 2
a3831 1
	  fragP->fr_fix += 1 + size;	/* we've added an opcode byte */
d3841 2
a3842 1
  return 1; /* Guess a short jump.  */
d3845 9
a3853 11
/*
 *			md_convert_frag();
 *
 * Called after relax() is finished.
 * In:	Address of frag.
 *	fr_type == rs_machine_dependent.
 *	fr_subtype is what the address relaxed to.
 *
 * Out:	Any fixSs and constants are set up.
 *	Caller will turn frag into a ".space 0".
 */
d3877 1
a3877 1
  /* Address we want to reach in file space. */
d3879 2
a3880 1
#ifdef BFD_ASSEMBLER /* not needed otherwise? */
d3884 1
a3884 1
  /* Address opcode resides at in file space. */
d3887 1
a3887 1
  /* Displacement from opcode start to fill into instruction. */
d3896 2
a3897 2
      /* don't have to change opcode */
      extension = 1;		/* 1 opcode + 1 displacement */
d3902 1
a3902 1
      extension = 5;		/* 2 opcode + 4 displacement */
d3909 1
a3909 1
      extension = 4;		/* 1 opcode + 4 displacement */
d3915 1
a3915 1
      extension = 3;		/* 2 opcode + 2 displacement */
d3922 1
a3922 1
      extension = 2;		/* 1 opcode + 2 displacement */
d3931 1
a3931 1
  /* now put displacement after opcode */
d3938 2
d3941 5
a3945 3
int md_short_jump_size = 2;	/* size of byte displacement jmp */
int md_long_jump_size = 5;	/* size of dword displacement jmp */
const int md_reloc_size = 8;	/* Size of relocation record */
d3957 2
a3958 1
  md_number_to_chars (ptr, (valueT) 0xeb, 1);	/* opcode for byte-disp jump */
d3985 8
a3992 3
     fixS *fixP;		/* The fix we're to put in.  */
     valueT *valp;		/* Pointer to the value of the bits.  */
     segT seg ATTRIBUTE_UNUSED;	/* Segment fix is from.  */
d4064 1
a4064 1
     and we must not dissappoint it. */
d4068 10
a4077 9
    switch (fixP->fx_r_type) {
    case BFD_RELOC_386_PLT32:
      /* Make the jump instruction point to the address of the operand.  At
	 runtime we merely add the offset to the actual PLT entry. */
      value = -4;
      break;
    case BFD_RELOC_386_GOTPC:
/*
 *   This is tough to explain.  We end up with this one if we have
d4112 2
a4113 9
 * expression is not pcrel, I felt it would be confusing to do it this way.
 */
      value -= 1;
      break;
    case BFD_RELOC_386_GOT32:
      value = 0; /* Fully resolved at runtime.  No addend.  */
      break;
    case BFD_RELOC_386_GOTOFF:
      break;
d4115 12
a4126 4
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return 1;
d4128 4
a4131 4
    default:
      break;
    }
#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) */
d4133 1
a4133 1
#endif /* defined (BFD_ASSEMBLER) && !defined (TE_Mach) */
d4139 1
d4141 4
a4144 1
#define MAX_LITTLENUMS 6
a4145 3
/* Turn the string pointed to by litP into a floating point constant of type
   type, and emit the appropriate bytes.  The number of LITTLENUMS emitted
   is stored in *sizeP .  An error message is returned, or NULL on OK.  */
a4205 1

d4238 1
a4238 1
  if (r == i386_regtab /* %st is first entry of table */)
d4259 1
a4259 1
	  /* We have "%st(" then garbage */
d4339 1
a4339 1
const char  *
d4346 1
a4346 1
     return AOUT_TARGET_FORMAT;
d4362 2
a4363 2
#endif /* OBJ_MAYBE_ more than one */
#endif /* BFD_ASSEMBLER */
d4387 1
a4438 1

d4536 1
a4536 1
#else /* ! BFD_ASSEMBLER */
d4545 2
a4546 4
  /*
   * In: length of relocation (or of address) in chars: 1, 2 or 4.
   * Out: GNU LD relocation length code: 0, 1, or 2.
   */
d4548 1
a4548 1
  static const unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
d4570 1
a4570 1
#endif /* OBJ_AOUT or OBJ_BOUT */
d4600 1
a4600 1
#endif /* I386COFF */
d4602 1
a4602 3
#endif /* ! BFD_ASSEMBLER */

/* end of tc-i386.c */
@


1.56
log
@Fix a problem with 32-bit displacements in .code16gcc mode.
@
text
@d1026 1
a1026 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
d3779 1
a3779 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
a4040 13
      else if (S_IS_EXTERNAL (fixP->fx_addsy)
	       || S_IS_WEAK (fixP->fx_addsy))
	{
	  /* We are generating an external relocation for this defined
             symbol.  We add the address, because
             bfd_install_relocation will subtract it.  VALUE already
             holds the symbol value, because fixup_segment added it
             in.  We subtract it out, and then we subtract it out
             again because bfd_install_relocation will add it in
             again.  */
	  value += md_pcrel_from (fixP);
	  value -= 2 * S_GET_VALUE (fixP->fx_addsy);
	}
a4042 13
#ifdef TE_PE
  else if (fixP->fx_addsy != NULL
	   && S_IS_DEFINED (fixP->fx_addsy)
	   && (S_IS_EXTERNAL (fixP->fx_addsy)
	       || S_IS_WEAK (fixP->fx_addsy)))
    {
      /* We are generating an external relocation for this defined
         symbol.  VALUE already holds the symbol value, and
         bfd_install_relocation will add it in again.  We don't want
         either addition.  */
      value -= 2 * S_GET_VALUE (fixP->fx_addsy);
    }
#endif
@


1.55
log
@* config/tc-i386.c (tc_i386_fix_adjustable): Revert change from
Sept 1999; RVA relocs need to be treated more like DIR32 relocs
for cygwin import libraries to work properly.
@
text
@d1464 25
a2947 13
  if (exp->X_op == O_constant)
    {
      if (i.types[this_operand] & Disp16)
	{
	  /* We know this operand is at most 16 bits, so convert to a
	     signed 16 bit number before trying to see whether it will
	     fit in an even smaller size.  */
	  exp->X_add_number =
	    (((exp->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
	}
      if (fits_in_signed_byte (exp->X_add_number))
	i.types[this_operand] |= Disp8;
    }
d2949 1
a2949 1
  else if (
d2951 1
a2951 1
	   OUTPUT_FLAVOR == bfd_target_aout_flavour &&
d2953 4
a2956 4
	   exp_seg != text_section
	   && exp_seg != data_section
	   && exp_seg != bss_section
	   && exp_seg != undefined_section)
@


1.54
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@a1036 1
      || fixP->fx_r_type == BFD_RELOC_RVA
@


1.53
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d148 1
a148 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (TE_LINUX) && !defined(TE_FreeBSD))
d166 1
a166 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (TE_LINUX) && !defined(TE_FreeBSD))
d1024 1
a1024 1
     fixS *fixP;
@


1.52
log
@Update md_shortopts to what we actually handle.
@
text
@d172 1
a172 1
const char line_separator_chars[] = "";
@


1.51
log
@Pass jump reloc in fr_var so it can be used in
md_estimate_size_before_relax, replacing old kludge.
@
text
@d4262 1
a4262 1
CONST char *md_shortopts = "kmVQ:sq";
d4264 1
a4264 1
CONST char *md_shortopts = "m";
@


1.50
log
@Keep a reloc for jumps to weak and external symbols.
@
text
@d2267 2
a2268 1
	/* 1 possible extra opcode + displacement go in fr_var.  */
d2271 1
a2271 1
		  1,
d3745 13
a3757 12
/*
 * md_estimate_size_before_relax()
 *
 * Called just before relax().
 * Any symbol that is now undefined will not become defined.
 * Return the correct fr_subtype in the frag.
 * Return the initial "guess for fr_var" to caller.
 * The guess for fr_var is ACTUALLY the growth beyond fr_fix.
 * Whatever we do to grow fr_fix or fr_var contributes to our returned value.
 * Although it may not be explicit in the frag, pretend fr_var starts with a
 * 0 value.
 */
a3762 5
  register unsigned char *opcode;
  register int old_fr_fix;

  old_fr_fix = fragP->fr_fix;
  opcode = (unsigned char *) fragP->fr_opcode;
d3782 2
d3785 2
a3786 8
      if (GOT_symbol /* Not quite right - we should switch on presence of
			@@PLT, but I cannot see how to get to that from
			here.  We should have done this in md_assemble to
			really get it right all of the time, but I think it
			does not matter that much, as this will be right
			most of the time. ERY  */
	  && S_GET_SEGMENT(fragP->fr_symbol) == undefined_section)
	reloc_type = BFD_RELOC_386_PLT32;
d3792 3
d3819 1
d3821 3
a3823 3
  return (fragP->fr_var + fragP->fr_fix - old_fr_fix);
}				/* md_estimate_size_before_relax() */

@


1.49
log
@Add x86 gas -q option to quiet some x86 gas warnings.
Remove useless -m flag_do_long_jump from x86 gas.
If BFD_ASSEMBLER, store --defsym value in a bfd_vma, and use scan_bfd_vma.
@
text
@d1026 1
a1026 1
#if defined (OBJ_ELF) || defined (TE_PE)
d1029 2
a1030 3
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;
  if (S_IS_WEAK (fixP->fx_addsy))
d3767 13
a3779 6
     check for un-relaxable symbols.  */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
    {
      /* symbol is undefined in this segment */
      int code16 = fragP->fr_subtype & CODE16;
      int size = code16 ? 2 : 4;
d3794 1
a3794 1
      else if (code16)
@


1.48
log
@`.arch cpu_type' pseudo for x86.
@
text
@a221 2
static int flag_do_long_jump;	  /* FIXME what does this do?  */

a226 4
static const char *cpu_arch_name = NULL; /* cpu name  */

static unsigned int cpu_arch_flags = 0;  /* cpu feature flags  */

d234 6
d1569 1
a1569 2
    if (!intel_syntax
	&& (i.types[0] & JumpAbsolute) != (t->operand_types[0] & JumpAbsolute))
d1571 6
a1576 2
	as_warn (_("indirect %s without `*'"), t->name);
      }
d1578 7
a1584 5
    if ((t->opcode_modifier & (IsPrefix|IgnoreSize)) == (IsPrefix|IgnoreSize))
      {
	/* Warn them that a data or address size prefix doesn't affect
	   assembly of the next line of code.  */
	as_warn (_("stand-alone `%s' prefix"), t->name);
d1700 2
a1701 1
		    if ((i.tm.operand_types[op] & InOutPortReg) == 0)
d1740 2
a1741 1
	      else if ((i.types[op] & Reg16) != 0
d1768 2
a1769 1
	      else if ((i.types[op] & Reg32) != 0
d1945 1
a1945 1
	    if ((i.tm.opcode_modifier & Ugh) != 0)
d2202 1
a2202 1
    else if ((i.tm.opcode_modifier & Ugh) != 0)
d3938 2
a3939 2
     fragS *frag;
     symbolS *to_symbol;
d3943 3
a3945 14
  if (flag_do_long_jump)
    {
      offset = to_addr - S_GET_VALUE (to_symbol);
      md_number_to_chars (ptr, (valueT) 0xe9, 1);/* opcode for long jmp */
      md_number_to_chars (ptr + 1, (valueT) offset, 4);
      fix_new (frag, (ptr + 1) - frag->fr_literal, 4,
	       to_symbol, (offsetT) 0, 0, BFD_RELOC_32);
    }
  else
    {
      offset = to_addr - (from_addr + 5);
      md_number_to_chars (ptr, (valueT) 0xe9, 1);
      md_number_to_chars (ptr + 1, (valueT) offset, 4);
    }
d4275 2
a4276 2
    case 'm':
      flag_do_long_jump = 1;
d4280 3
a4282 2
      /* -k: Ignore for FreeBSD compatibility.  */
    case 'k':
d4290 2
a4291 3
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
a4297 5

    case 'q':
      /* -q: On i386 Solaris, this tells the native assembler to do
         fewer checks.  */
      break;
d4310 1
d4312 6
a4317 2
  -m			  do long jump\n"));
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
d4319 1
a4319 5
  -V			  print assembler version number\n\
  -k			  ignored\n\
  -Qy, -Qn		  ignored\n\
  -q			  ignored\n\
  -s			  ignored\n"));
@


1.47
log
@Remove '/' from comment_chars for FreeBSD so divide operator works.
Fix as.1 typo.
@
text
@d65 1
d220 1
a220 1
static int this_operand;	/* current operand we are working on */
d222 1
a222 1
static int flag_do_long_jump;	/* FIXME what does this do? */
d224 2
a225 1
static int flag_16bit_code;	/* 1 if we're writing 16-bit code, 0 if 32-bit */
d227 1
a227 1
static int intel_syntax = 0;	/* 1 for intel syntax, 0 if att syntax */
d229 5
a233 1
static int allow_naked_reg = 0;  /* 1 if register prefix % not required */
d310 15
d465 11
a475 10
#if 0
  /* This code is disabled because all the Imm1 forms in the opcode table
     are slower on the i486, and they're the versions with the implicitly
     specified single-position displacement, which has another syntax if
     you really want to use that form.  If you really prefer to have the
     one-byte-shorter Imm1 form despite these problems, re-enable this
     code.  */
  if (num == 1)
    return Imm1 | Imm8 | Imm8S | Imm16 | Imm32;
#endif
d625 32
a658 3
#ifndef I386COFF
  {"bss", s_bss, 0},
#endif
d664 4
d1116 1
a1116 1
		as_bad (_("no such 386 instruction: `%s'"), token_start);
d1199 1
a1199 1
	    as_bad (_("no such 386 instruction: `%s'"), token_start);
d1201 14
@


1.46
log
@Keep shift count smaller than 32.
@
text
@d147 1
a147 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX))
d165 1
a165 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX))
d4234 1
a4234 1
      /* -q: On i386 Solaris, this tells the native assembler does
@


1.45
log
@2000-04-18  H.J. Lu  (hjl@@gnu.org)

	* config/tc-i386.c (offset_in_range): Use addressT instead of
	bfd_vma for none bfd assemblers.
@
text
@d474 1
a474 1
    case 4: mask = ((addressT) 1 << 32) - 1; break;
d479 1
a479 1
  if ((val & ~ (((addressT) 1 << 32) - 1)) == 0)
@


1.44
log
@64 bit bfd fix.
@
text
@d468 1
a468 1
  bfd_vma mask;
d472 3
a474 3
    case 1: mask = ((bfd_vma) 1 <<  8) - 1; break;
    case 2: mask = ((bfd_vma) 1 << 16) - 1; break;
    case 4: mask = ((bfd_vma) 1 << 32) - 1; break;
d479 2
a480 2
  if ((val & ~ (((bfd_vma) 1 << 32) - 1)) == 0)
    val = (val ^ ((bfd_vma) 1 << 31)) - ((bfd_vma) 1 << 31);
@


1.43
log
@Fix 64-bit nits.
@
text
@d468 2
a469 1
  offsetT mask;
d472 3
a474 3
    case 1: mask = ((offsetT) 1 <<  8) - 1; break;
    case 2: mask = ((offsetT) 1 << 16) - 1; break;
    case 4: mask = ((offsetT) 1 << 32) - 1; break;
d477 4
@


1.42
log
@Correct 2000-02-26 change.
@
text
@d55 6
a60 5
static int fits_in_signed_byte PARAMS ((long));
static int fits_in_unsigned_byte PARAMS ((long));
static int fits_in_unsigned_word PARAMS ((long));
static int fits_in_signed_word PARAMS ((long));
static int smallest_imm_type PARAMS ((long));
d414 1
a414 1
     long num;
d421 1
a421 1
     long num;
d428 1
a428 1
     long num;
d435 1
a435 1
     long num;
d442 1
a442 1
     long num;
d463 25
d2285 1
a2285 1
	    long n = (long) i.op[1].imms->X_add_number;
d2294 1
a2294 1
	    md_number_to_chars (p, (valueT) n, size);
d2392 2
a2393 2
			int size = 4;
			long val = (long) i.op[n].disps->X_add_number;
d2395 1
a2397 2
			    long mask;

a2398 1
			    mask = ~ (long) 0xffff;
d2400 1
a2400 8
			      {
				size = 1;
				mask = ~ (long) 0xff;
			      }

			    if ((val & mask) != 0 && (val & mask) != mask)
			      as_warn (_("%ld shortened to %ld"),
				       val, val & ~mask);
d2402 2
d2406 1
a2406 1
			md_number_to_chars (p, (valueT) val, size);
d2436 2
a2437 2
			int size = 4;
			long val = (long) i.op[n].imms->X_add_number;
d2439 1
a2441 2
			    long mask;

a2442 1
			    mask = ~ (long) 0xffff;
d2444 1
a2444 7
			      {
				size = 1;
				mask = ~ (long) 0xff;
			      }
			    if ((val & mask) != 0 && (val & mask) != mask)
			      as_warn (_("%ld shortened to %ld"),
				       val, val & ~mask);
d2446 2
d2450 1
a2450 1
			md_number_to_chars (p, (valueT) val, size);
d3766 2
a3767 2
  unsigned int target_address;
  unsigned int opcode_address;
d3769 1
a3769 1
  int displacement_from_opcode_start;
d3845 1
a3845 1
  long offset;
d3859 1
a3859 1
  long offset;
d3994 1
a3994 1
      value = 0xfffffffc;
a4057 17

#if 0
/* This is never used.  */
long				/* Knows about the byte order in a word. */
md_chars_to_number (con, nbytes)
     unsigned char con[];	/* Low order byte 1st. */
     int nbytes;		/* Number of bytes in the input. */
{
  long retval;
  for (retval = 0, con += nbytes - 1; nbytes--; con--)
    {
      retval <<= BITS_PER_CHAR;
      retval |= *con;
    }
  return retval;
}
#endif /* 0 */
a4112 2

static char * output_invalid PARAMS ((int));
@


1.41
log
@Mostly cosmetic.  Fixes to comments.  Don't start as_bad and as_warn
messages with capital.  Don't malign Unixware, malign SysV386 instead.
@
text
@d1334 3
d2590 1
a2590 4
      int bigimm = Imm32;
      if (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0))
	bigimm = Imm16;
      i.types[this_operand] |= bigimm;
@


1.41.2.1
log
@Correct 2000-02-26 change.
@
text
@a1333 3
	else if (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0))
	  guess_suffix = WORD_MNEM_SUFFIX;

d2587 4
a2590 1
      i.types[this_operand] |= Imm32;	/* Size it properly later.  */
@


1.41.2.2
log
@FreeBSD changes.
@
text
@d146 1
a146 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (TE_LINUX) && !defined(TE_FreeBSD))
d164 1
a164 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (TE_LINUX) && !defined(TE_FreeBSD))
@


1.41.2.3
log
@Pass jump reloc in fr_var so it can be used in
md_estimate_size_before_relax, replacing old kludge.
@
text
@d940 1
a940 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
d943 3
a945 2
  if (S_IS_EXTERNAL (fixP->fx_addsy)
      || S_IS_WEAK (fixP->fx_addsy))
d2160 1
a2160 2
	/* 1 possible extra opcode + displacement go in var part.
	   Pass reloc in fr_var.  */
d2163 1
a2163 1
		  i.disp_reloc[0],
d3650 12
a3661 13
/* md_estimate_size_before_relax()

   Called just before relax() for rs_machine_dependent frags.  The x86
   assembler uses these frags to handle variable size jump
   instructions.

   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag.
   Return the initial "guess for variable size of frag" to caller.
   The guess is actually the growth beyond the fixed part.  Whatever
   we do to grow the fixed or variable part contributes to our
   returned value.  */

d3667 5
d3673 6
a3678 13
     check for un-relaxable symbols.  On an ELF system, we can't relax
     an externally visible symbol, because it may be overridden by a
     shared library.  */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
      || S_IS_EXTERNAL (fragP->fr_symbol)
      || S_IS_WEAK (fragP->fr_symbol)
#endif
      )
    {
      /* Symbol is undefined in this segment, or we need to keep a
	 reloc so that weak symbols can be overridden.  */
      int size = (fragP->fr_subtype & CODE16) ? 2 : 4;
a3683 2
      unsigned char *opcode;
      int old_fr_fix;
d3685 9
a3693 3
      if (fragP->fr_var != NO_RELOC)
	reloc_type = fragP->fr_var;
      else if (size == 2)
a3697 3
      old_fr_fix = fragP->fr_fix;
      opcode = (unsigned char *) fragP->fr_opcode;

a3721 1
      return fragP->fr_fix - old_fr_fix;
d3723 3
a3725 3
  return 1; /* Guess a short jump.  */
}

@


1.40
log
@Catch some more cases where we can represent a 16 bit immediate operand as
8 bit sign extended.
@
text
@d552 1
a552 1
	as_bad (_("Bad argument to syntax directive."));
d914 1
a914 1
      as_bad (_("Can not do %d byte pc-relative relocation"), size);
d924 1
a924 1
      as_bad (_("Can not do %d byte relocation"), size);
d1469 1
a1469 1
	as_warn (_("Indirect %s without `*'"), t->name);
d1493 2
a1494 2
    /* Undo UNIXWARE_COMPAT brokenness when in Intel mode.  See i386.h  */
     if (UNIXWARE_COMPAT
d2499 1
a2499 1
      as_bad (_("Only 1 or 2 immediate operands are allowed"));
d2552 1
a2552 1
	  as_bad (_("Bad reloc specifier in expression"));
d2570 1
a2570 1
    as_bad (_("Ignoring junk `%s' after expression"), input_line_pointer);
d2577 1
a2577 1
      as_bad (_("Missing or invalid immediate expression `%s' taken as 0"),
d2607 1
a2607 1
      as_bad (_("Unimplemented segment %s in operand"), exp_seg->name);
d2609 1
a2609 1
      as_bad (_("Unimplemented segment type %d in operand"), exp_seg);
d2776 1
a2776 1
	  as_bad (_("Bad reloc specifier in expression"));
d2810 1
a2810 1
    as_bad (_("Ignoring junk `%s' after expression"),
d2821 1
a2821 1
      as_bad (_("Missing or invalid displacement expression `%s' taken as 0"),
d2853 1
a2853 1
      as_bad (_("Unimplemented segment %s in operand"), exp_seg->name);
d2855 1
a2855 1
      as_bad (_("Unimplemented segment type %d in operand"), exp_seg);
d3072 1
a3072 1
  if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0) ?
d3074 10
a3083 10
      ((i.base_reg
	&& ((i.base_reg->reg_type & (Reg16|BaseIndex))
	    != (Reg16|BaseIndex)))
       || (i.index_reg
	   && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		!= (Reg16|BaseIndex))
	       || ! (i.base_reg
		     && i.base_reg->reg_num < 6
		     && i.index_reg->reg_num >= 6
		     && i.log2_scale_factor == 0)))) :
d3085 5
a3089 5
      ((i.base_reg
	&& (i.base_reg->reg_type & Reg32) == 0)
       || (i.index_reg
	   && ((i.index_reg->reg_type & (Reg32|BaseIndex))
	       != (Reg32|BaseIndex)))))
d3448 1
a3448 1
	  as_bad (_("Junk `%s' after register"), op_string);
d3465 1
a3465 1
	  as_bad (_("Immediate operand illegal with absolute jump"));
d4407 1
a4407 1
	      as_bad (_("Can not do %d byte pc-relative relocation"),
d4421 1
a4421 1
	      as_bad (_("Can not do %d byte relocation"), fixp->fx_size);
d4456 1
a4456 1
		    _("Cannot represent relocation type %s"),
@


1.39
log
@Extend the i386 gas testsuite to do some tests for intel_syntax.  Fix all
the errors exposed by this addition.  These were intel mode
"fi... word ptr", "fi... dword ptr", "jmp Imm seg, Imm offset", "out dx,al".
The failure with intel "out dx,al" was also present in att "out al,dx".
Extend testsuite to catch this case too.
@
text
@d1308 55
d2258 3
a2260 1
	    if (size == 2 && !fits_in_unsigned_word (n))
d2590 1
a2590 14

      i.types[this_operand] |=
	(bigimm | smallest_imm_type ((long) exp->X_add_number));

      /* If a suffix is given, this operand may be shortened.  */
      switch (i.suffix)
	{
	case WORD_MNEM_SUFFIX:
	  i.types[this_operand] |= Imm16;
	  break;
	case BYTE_MNEM_SUFFIX:
	  i.types[this_operand] |= Imm16 | Imm8 | Imm8S;
	  break;
	}
d2831 8
@


1.38
log
@Yet more .intel_syntax fixes.
@
text
@d977 1
a977 1
    return 0;
d1268 6
a1273 1
    /* All intel opcodes have reversed operands except for BOUND and ENTER */
d1275 2
a1276 2
	&& (strcmp (mnemonic, "enter") != 0)
	&& (strcmp (mnemonic, "bound") != 0))
d1499 2
a1500 1
	      if (i.types[op] & Reg)
d2827 4
a2830 1
      i.suffix = WORD_MNEM_SUFFIX;
d2837 1
a2837 1
      if (got_a_float)
a2860 1
      i.suffix = WORD_MNEM_SUFFIX;
@


1.37
log
@Correct intel_syntax fsub* and fdiv* handling.  Oh, how I'd like to be rid
of UNIXWARE_COMPAT.
@
text
@d1294 8
d2852 1
d2886 1
a2886 1
  if ( initial_disp && !end_of_operand_string)
d2889 1
a2889 1
      return (temp_string);
d3078 1
a3078 1
  /* Look for displacement preceding open bracket */
a3081 1
      char *temp_string;
d3090 9
d3102 6
a3107 3
      if (i.disp_operands == 0 &&
	  !i386_displacement (temp_string, temp_string + strlen (temp_string)))
	return 0;
d3165 5
d3172 3
a3174 2
	      if (*temp_string == '+')
		++temp_string;
d3176 6
a3181 3
	      if (i.disp_operands == 0 &&
		  !i386_displacement (temp_string, temp_string + strlen (temp_string)))
		return 0;
@


1.36
log
@config/tc-i386.c (struct _i386_insn): Combine disps, imms, regs into
a union.  Use throughout file.  Delete TC_RELOC macro.
@
text
@d1271 1
a1271 3
	&& (strcmp (mnemonic, "bound") != 0)
	&& (strncmp (mnemonic, "fsub", 4) !=0)
	&& (strncmp (mnemonic, "fdiv", 4) !=0))
d1319 6
a1324 10
	/* For some opcodes, don't check the suffix */
	if (intel_syntax)
	  {
	    if (strcmp (t->name, "fnstcw")
		&& strcmp (t->name, "fldcw")
		&& (t->opcode_modifier & suffix_check))
	      continue;
	  }
	/* Must not have disallowed suffix. */
	else if ((t->opcode_modifier & suffix_check))
d1415 6
d1425 5
a1744 6

	/* If we found a reverse match we must alter the opcode
	   direction bit.  found_reverse_match holds bits to change
	   (different for int & float insns).  */

	i.tm.base_opcode ^= found_reverse_match;
@


1.35
log
@        * config/tc-i386.c (md_assemble): When swapping operands for
        intel_syntax, assume everything that's not Imm or Disp is a
        register.
@
text
@a34 4
#ifndef TC_RELOC
#define TC_RELOC(X,Y) (Y)
#endif

d73 7
a88 2
    /* Operands are coded with OPERANDS, TYPES, DISPS, IMMS, and REGS. */

d98 1
a98 2
       search through DISPS [i] & IMMS [i] & REGS [i] for the required
       operand.  */
d101 3
a103 2
    /* Displacements (if given) for each operand. */
    expressionS *disps[MAX_OPERANDS];
a111 6
    /* Immediate operands (if given) for each operand. */
    expressionS *imms[MAX_OPERANDS];

    /* Register operands (if given) for each operand. */
    const reg_entry *regs[MAX_OPERANDS];

d759 1
a759 1
	fprintf (stdout, "%s\n", x->regs[i]->reg_name);
d761 1
a761 1
	pe (x->imms[i]);
d763 1
a763 1
	pe (x->disps[i]);
d1269 1
a1269 1
    if (intel_syntax
d1275 1
a1275 3
	const reg_entry *temp_reg = NULL;
	expressionS *temp_disp = NULL;
	expressionS *temp_imm = NULL;
d1290 6
a1295 50

	if (i.operands > 1)
	  {
	    temp_type = i.types[xchg2];
	    if (temp_type & Imm)
	      temp_imm = i.imms[xchg2];
	    else if (temp_type & Disp)
	      temp_disp = i.disps[xchg2];
	    else
	      temp_reg = i.regs[xchg2];

	    i.types[xchg2] = i.types[xchg1];

	    if (i.types[xchg2] & Imm)
	      {
		i.imms[xchg2] = i.imms[xchg1];
		i.imms[xchg1] = NULL;
	      }
	    else if (i.types[xchg2] & Disp)
	      {
		i.disps[xchg2] = i.disps[xchg1];
		i.disps[xchg1] = NULL;
	      }
	    else
	      {
		i.regs[xchg2] = i.regs[xchg1];
		i.regs[xchg1] = NULL;
	      }

	    if (temp_type & Imm)
	      {
		i.imms[xchg1] = temp_imm;
		if (! (i.types[xchg1] & Imm))
		  i.imms[xchg2] = NULL;
	      }
	    else if (temp_type & Disp)
	      {
		i.disps[xchg1] = temp_disp;
		if (! (i.types[xchg1] & Disp))
		  i.disps[xchg2] = NULL;
	      }
	    else
	      {
		i.regs[xchg1] = temp_reg;
		if (i.types[xchg1] & (Imm | Disp))
		  i.regs[xchg2] = NULL;
	      }

	    i.types[xchg1] = temp_type;
	  }
d1508 1
a1508 1
		if ((i.types[op] & WordReg) && i.regs[op]->reg_num < 4
d1520 2
a1521 2
			       (i.regs[op] - (i.types[op] & Reg16 ? 8 : 16))->reg_name,
			       i.regs[op]->reg_name,
d1533 1
a1533 1
			    i.regs[op]->reg_name,
d1550 1
a1550 1
			  i.regs[op]->reg_name,
d1561 2
a1562 2
			   (i.regs[op] + 8)->reg_name,
			   i.regs[op]->reg_name,
d1577 1
a1577 1
			  i.regs[op]->reg_name,
d1588 2
a1589 2
			   (i.regs[op] - 8)->reg_name,
			   i.regs[op]->reg_name,
d1676 1
a1676 1
	  if ((i.regs[1]->reg_type & Reg16) != 0)
d1723 1
a1723 1
	assert(i.imm_operands == 0 && i.operands <= 2);
d1726 1
a1726 1
	i.imms[i.operands] = exp;
d1754 3
a1756 1
	    i.regs[first_reg_op+1] = i.regs[first_reg_op];
d1765 1
a1765 1
	    i.tm.base_opcode |= i.regs[op]->reg_num;
d1774 2
a1775 2
			     i.regs[1]->reg_name,
			     i.regs[0]->reg_name);
d1781 1
a1781 1
			     i.regs[0]->reg_name);
d1814 2
a1815 2
		    i.rm.reg = i.regs[dest]->reg_num;
		    i.rm.regmem = i.regs[source]->reg_num;
d1819 2
a1820 2
		    i.rm.reg = i.regs[source]->reg_num;
		    i.rm.regmem = i.regs[dest]->reg_num;
d1943 1
d1945 1
a1945 1
			i.disps[op] = exp;
d1975 1
a1975 1
		      i.rm.regmem = i.regs[op]->reg_num;
d1977 1
a1977 1
		      i.rm.reg = i.regs[op]->reg_num;
d1993 1
a1993 1
	    if (i.tm.base_opcode == POP_SEG_SHORT && i.regs[0]->reg_num == 1)
d1998 1
a1998 1
	    i.tm.base_opcode |= (i.regs[0]->reg_num << 3);
d2031 1
a2031 1
  if (i.tm.base_opcode == INT_OPCODE && i.imms[0]->X_add_number == 3)
d2038 1
a2038 1
      && i.disps[0]->X_op == O_constant)
d2043 2
a2044 2
      i.disps[0]->X_add_symbol = &abs_symbol;
      i.disps[0]->X_op = O_symbol;
d2096 2
a2097 2
		  i.disps[0]->X_add_symbol,
		  i.disps[0]->X_add_number,
d2154 1
a2154 1
		     i.disps[0], 1, reloc (size, 1, i.disp_reloc[0]));
d2186 1
a2186 1
	if (i.imms[1]->X_op == O_constant)
d2188 1
a2188 1
	    long n = (long) i.imms[1]->X_add_number;
d2199 2
a2200 2
		       i.imms[1], 0, reloc (size, 0, i.disp_reloc[0]));
	if (i.imms[0]->X_op != O_constant)
d2203 1
a2203 1
	md_number_to_chars (p + size, (valueT) i.imms[0]->X_add_number, 2);
d2289 1
a2289 1
		if (i.disps[n])
d2291 1
a2291 1
		    if (i.disps[n]->X_op == O_constant)
d2294 1
a2294 1
			long val = (long) i.disps[n]->X_add_number;
d2316 1
a2316 1
		    else if (i.types[n] & Disp32)
d2318 10
a2327 13
			insn_size += 4;
			p = frag_more (4);
			fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
				     i.disps[n], 0,
				     TC_RELOC (i.disp_reloc[n], BFD_RELOC_32));
		      }
		    else
		      { /* must be Disp16 */
			insn_size += 2;
			p = frag_more (2);
			fix_new_exp (frag_now, p - frag_now->fr_literal, 2,
				     i.disps[n], 0,
				     TC_RELOC (i.disp_reloc[n], BFD_RELOC_16));
d2340 1
a2340 1
		if (i.imms[n])
d2342 1
a2342 1
		    if (i.imms[n]->X_op == O_constant)
d2345 1
a2345 1
			long val = (long) i.imms[n]->X_add_number;
d2369 1
a2369 1
			   non-absolute ims).  Try to support other
d2376 1
a2376 2
			int size;
			int pcrel = 0;
d2378 3
a2380 1
			if (i.types[n] & (Imm8 | Imm8S))
d2382 1
a2382 4
			else if (i.types[n] & Imm16)
			  size = 2;
			else
			  size = 4;
d2389 3
a2391 3
			    && GOT_symbol == i.imms[n]->X_add_symbol
			    && (i.imms[n]->X_op == O_symbol
				|| (i.imms[n]->X_op == O_add
d2393 1
a2393 1
					 (i.imms[n]->X_op_symbol)->X_op)
d2397 1
a2397 1
			    i.imms[n]->X_add_number += 3;
d2401 1
a2401 1
				     i.imms[n], pcrel, reloc_type);
d2434 1
a2434 1
  i.imms[this_operand] = exp;
d2628 1
a2628 2
  i.disps[this_operand] = exp;
  i.disp_reloc[this_operand] = NO_RELOC;
d3261 1
a3261 1
	  i.regs[this_operand] = r;
d3364 1
a3364 1
      i.regs[this_operand] = r;
@


1.34
log
@This lot mainly cleans up `comparison between signed and unsigned' gcc
warnings.  One usused var, and a macro parenthesis fix too.  Also check
input sections are elf when doing gc in elflink.h.
@
text
@d1301 1
a1301 3
	    if (temp_type & (Reg | FloatReg))
	      temp_reg = i.regs[xchg2];
	    else if (temp_type & Imm)
d1305 2
d1310 1
a1310 6
	    if (i.types[xchg1] & (Reg | FloatReg))
	      {
		i.regs[xchg2] = i.regs[xchg1];
		i.regs[xchg1] = NULL;
	      }
	    else if (i.types[xchg2] & Imm)
d1320 1
a1320 2

	    if (temp_type & (Reg | FloatReg))
d1322 2
a1323 3
		i.regs[xchg1] = temp_reg;
		if (! (i.types[xchg1] & (Reg | FloatReg)))
		  i.regs[xchg2] = NULL;
d1325 2
a1326 1
	    else if (temp_type & Imm)
d1337 6
@


1.33
log
@This set of patches add support for aout emulation on the x86
assembler.  ie. You will be able to do "as --em=i386aout" on an x86
linux-elf assembler to generate aout format object files, rather than
using a separate assembler.  The aout emulation is enabled by giving
"--enable-targets=i386-linuxaout" to configure.
Oh yeah, there's a couple of fixes too.  Error messages shouldn't be
passed to printf in the format arg just in case someone puts a `%' in
the message.
@
text
@d895 1
a895 1
  return fixp->fx_r_type==7;
a2206 1
	int reloc_type;
a2222 1
	reloc_type = BFD_RELOC_32;
d2224 1
a2224 4
	  {
	    size = 2;
	    reloc_type = BFD_RELOC_16;
	  }
d2247 1
a2247 1
		       i.imms[1], 0, reloc_type);
d2422 5
a2426 1
			int r_type;
d2438 1
a2438 1
			r_type = reloc (size, 0, i.disp_reloc[0]);
d2440 1
a2440 1
			if (r_type == BFD_RELOC_32
d2449 1
a2449 1
			    r_type = BFD_RELOC_386_GOTPC;
d2454 1
a2454 1
				     i.imms[n], pcrel, r_type);
d3645 18
a3662 1
      int pcrel_reloc = code16 ? BFD_RELOC_16_PCREL : BFD_RELOC_32_PCREL;
d3672 1
a3672 9
		   (GOT_symbol && /* Not quite right - we should switch on
				     presence of @@PLT, but I cannot see how
				     to get to that from here.  We should have
				     done this in md_assemble to really
				     get it right all of the time, but I
				     think it does not matter that much, as
				     this will be right most of the time. ERY*/
		    S_GET_SEGMENT(fragP->fr_symbol) == undefined_section)
		   ? BFD_RELOC_386_PLT32 : pcrel_reloc);
d3677 1
a3677 1
	     to the dword-displacement jump 0x0f8N.  */
d3679 1
a3679 1
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;	/* two-byte escape */
d3684 1
a3684 5
		   (GOT_symbol &&  /* Not quite right - we should switch on
				      presence of @@PLT, but I cannot see how
				      to get to that from here.  ERY */
		    S_GET_SEGMENT(fragP->fr_symbol) == undefined_section)
		   ? BFD_RELOC_386_PLT32 : pcrel_reloc);
@


1.32
log
@Cosmetic changes to tc-i386.[ch] + extend x86 gas testsuite jmp and
call tests + tweak intel mode far call and jmp.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d2589 6
a2594 2
#ifdef OBJ_AOUT
  else if (exp_seg != text_section
d2603 3
d2607 1
d2832 6
a2837 2
#ifdef OBJ_AOUT
  else if (exp_seg != text_section
d2842 5
a2846 1
      as_bad (_ ("Unimplemented segment type %d in operand"), exp_seg);
d4225 3
a4227 2
#ifdef OBJ_MAYBE_ELF
#ifdef OBJ_MAYBE_COFF
d4236 5
d4243 2
d4247 1
d4254 1
a4254 2
#endif /* OBJ_MAYBE_COFF */
#endif /* OBJ_MAYBE_ELF */
a4283 1
#ifdef OBJ_AOUT
d4285 9
a4293 6
  /* For a.out, force the section size to be aligned.  If we don't do
     this, BFD will align it for us, but it will not write out the
     final bytes of the section.  This may be a bug in BFD, but it is
     easier to fix it here since that is how the other a.out targets
     work.  */
  int align;
d4295 3
a4297 2
  align = bfd_get_section_alignment (stdoutput, segment);
  size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
@


1.31
log
@x86 indirect jump/call syntax fixes.  Disassembly fix for lcall.
@
text
@d235 2
a236 1
				     and pop instructions.  */
a1096 1
	  case DWORD_MNEM_SUFFIX:
a1099 1
#if LONG_MNEM_SUFFIX != DWORD_MNEM_SUFFIX
a1100 1
#endif
d1107 1
a1107 1
	  case INTEL_DWORD_MNEM_SUFFIX:
d1360 1
a1360 1
			     : (i.suffix == INTEL_DWORD_MNEM_SUFFIX
d1519 1
a1519 1
	  i.suffix = DWORD_MNEM_SUFFIX;
d1536 1
a1536 1
			      DWORD_MNEM_SUFFIX);
d1591 1
a1591 1
	else if (i.suffix == DWORD_MNEM_SUFFIX)
d1745 1
a1745 2
	if (((intel_syntax && (i.suffix == INTEL_DWORD_MNEM_SUFFIX))
	     || i.suffix == DWORD_MNEM_SUFFIX
d1758 1
a1758 1
	    || (intel_syntax && i.suffix == INTEL_DWORD_MNEM_SUFFIX))
d2578 1
a2578 1
      /* If a suffix is given, this operand may be shortended. */
d2863 1
a2863 1
	i.suffix = DWORD_MNEM_SUFFIX;
d2870 1
a2870 1
      i.suffix = INTEL_DWORD_MNEM_SUFFIX;
@


1.30
log
@* config/tc-i386.c (i386_immediate): Disallow O_big immediates.
(i386_displacement): Disallow O_big displacements.
@
text
@d1258 2
a1259 3
  ((overlap) \
   && ((given) & BaseIndex) == ((overlap) & BaseIndex) \
   && ((given) & JumpAbsolute) == ((template) & JumpAbsolute))
a1348 5
	if (!strcmp(mnemonic,"jmp")
	    || !strcmp (mnemonic, "call"))
	  if ((i.types[0] & Reg) || i.types[0] & BaseIndex)
	    i.types[0] |= JumpAbsolute;

d1455 6
@


1.29
log
@
Nit fix.
@
text
@d2561 1
a2561 1
  if (exp->X_op == O_absent)
a2569 1
      i.types[this_operand] |= Imm;
d2571 2
a2572 1
  else if (exp->X_op == O_constant)
d2810 11
@


1.28
log
@1999-09-19  Alexandre Oliva  <oliva@@lsd.ic.unicamp.br>

	* config/tc-i386.c (md_shortopts): Check OBJ_MAYBE_ELF as well as
	OBJ_ELF.  If ELF, add "sq".
	(md_parse_option): If ELF, ignore -s and -q.
	(md_show_usage): Mention ELF options.
@
text
@a3069 1
#endif
d3074 1
@


1.27
log
@
Hackery to handle ix86 "jmp constant" as a pc-relative jump to the given
absolute address.
@
text
@d4131 2
a4132 2
#ifdef OBJ_ELF
CONST char *md_shortopts = "kmVQ:";
d4166 10
d4189 9
a4197 1
-m			do long jump\n"));
@


1.26
log
@
Tidy jump handling code and comments.
@
text
@d2088 10
d2128 22
a2149 71
	if (i.disps[0]->X_op == O_constant)
	  {
	    long n = (long) i.disps[0]->X_add_number;

	    if (fits_in_signed_byte (n))
	      {
		insn_size += 2;
		p = frag_more (2);
		p[0] = i.tm.base_opcode;
		p[1] = n;
	      }
	    else
	      {
		/* Use 16-bit jumps only for 16-bit code,
		   because text segments are limited to 64K anyway;
		   Use 32-bit jumps for 32-bit code, because they're faster,
		   and a 16-bit jump will clear the top 16 bits of %eip.  */
		if (code16 && !fits_in_signed_word (n))
		  {
		    as_bad (_("16-bit jump out of range"));
		    return;
		  }

		if (i.tm.base_opcode == JUMP_PC_RELATIVE)
		  {		/* pace */
		    /* unconditional jump */
		    insn_size += prefix + 1 + size;
		    p = frag_more (prefix + 1 + size);
		    if (prefix)
		      *p++ = DATA_PREFIX_OPCODE;
		    *p++ = (char) 0xe9;
		    md_number_to_chars (p, (valueT) n, size);
		  }
		else
		  {
		    /* conditional jump */
		    insn_size += prefix + 2 + size;
		    p = frag_more (prefix + 2 + size);
		    if (prefix)
		      *p++ = DATA_PREFIX_OPCODE;
		    *p++ = TWO_BYTE_OPCODE_ESCAPE;
		    *p++ = i.tm.base_opcode + 0x10;
		    md_number_to_chars (p, (valueT) n, size);
		  }
	      }
	  }
	else
	  {
	    /* It's a symbol;  End frag & setup for relax.
	       Make sure there is enough room in this frag for the largest
	       instruction we may generate in md_convert_frag.  This is 2
	       bytes for the opcode and room for the prefix and largest
	       displacement.  */
	    frag_grow (prefix + 2 + size);
	    insn_size += prefix + 1;
	    /* Prefix and 1 opcode byte go in fr_fix.  */
	    p = frag_more (prefix + 1);
	    if (prefix)
	      *p++ = DATA_PREFIX_OPCODE;
	    *p = i.tm.base_opcode;
	    /* 1 possible extra opcode + displacement go in fr_var */
	    frag_var (rs_machine_dependent,
		      1 + size,
		      1,
		      ((unsigned char) *p == JUMP_PC_RELATIVE
		       ? ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL) | code16
		       : ENCODE_RELAX_STATE (COND_JUMP, SMALL) | code16),
		      i.disps[0]->X_add_symbol,
		      i.disps[0]->X_add_number,
		      p);
	  }
d2204 2
a2205 22
	if (i.disps[0]->X_op == O_constant)
	  {
	    long n = (long) i.disps[0]->X_add_number;

	    if (size == 1 && !fits_in_signed_byte (n))
	      {
		as_bad (_("`%s' only takes byte displacement; %ld shortened to %d"),
			i.tm.name, n, *p);
	      }
	    else if (size == 2 && !fits_in_signed_word (n))
	      {
		as_bad (_("16-bit jump out of range"));
		return;
	      }
	    md_number_to_chars (p, (valueT) n, size);
	  }
	else
	  {
	    fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			 i.disps[0], 1, reloc (size, 1, i.disp_reloc[0]));

	  }
d3856 1
a3856 7
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg
	      || symbol_section_p (fixP->fx_addsy))
	  && ! S_IS_EXTERNAL (fixP->fx_addsy)
	  && ! S_IS_WEAK (fixP->fx_addsy)
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && ! S_IS_COMMON (fixP->fx_addsy))
d3858 16
a3873 5
	  /* Yes, we add the values in twice.  This is because
	     bfd_perform_relocation subtracts them out again.  I think
	     bfd_perform_relocation is broken, but I don't dare change
	     it.  FIXME.  */
	  value += fixP->fx_where + fixP->fx_frag->fr_address;
@


1.25
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/tc-i386.c (tc_i386_fix_adjustable): Don't adjust
	BFD_RELOC_RVA relocations.
@
text
@d239 2
a240 2
   one for unconditional jumps.  This is because the these two types
   of jumps add different sizes to frags when we're figuring out what
d2095 7
a2101 3
	long n = (long) i.disps[0]->X_add_number;
	int prefix = (i.prefix[DATA_PREFIX] != 0);
	int code16 = 0;
d2103 2
a2104 1
	if (prefix)
d2106 1
d2108 1
a2108 1
	    code16 = CODE16;
a2109 2
	if (flag_16bit_code)
	  code16 ^= CODE16;
d2111 5
a2115 1
	if (!intel_syntax && (i.prefixes != 0))
d2120 2
a2134 1
		int jmp_size = code16 ? 2 : 4;
d2144 2
a2145 2
		    insn_size += prefix + 1 + jmp_size;
		    p = frag_more (prefix + 1 + jmp_size);
d2149 1
a2149 1
		    md_number_to_chars (p, (valueT) n, jmp_size);
d2154 2
a2155 2
		    insn_size += prefix + 2 + jmp_size;
		    p = frag_more (prefix + 2 + jmp_size);
d2160 1
a2160 1
		    md_number_to_chars (p, (valueT) n, jmp_size);
d2166 9
a2174 8
	    int size = code16 ? 2 : 4;

	    /* It's a symbol; end frag & setup for relax.
	       Make sure there are more than 6 chars left in the current frag;
	       if not we'll have to start a new one. */
	    frag_grow (prefix + 1 + 2 + size);
	    insn_size += 1 + prefix;
	    p = frag_more (1 + prefix);
d2178 1
d2180 1
a2180 1
		      prefix + 2 + size, /* 2 opcode/prefix + displacement */
d2186 2
a2187 1
		      (offsetT) n, p);
d2192 1
a2192 2
	int size = (i.tm.opcode_modifier & JumpByte) ? 1 : 4;
	long n = (long) i.disps[0]->X_add_number;
d2194 1
a2194 1
	if (size == 1) /* then this is a loop or jecxz type instruction */
d2196 2
d2207 5
a2211 1
	    int code16 = 0;
d2218 1
a2218 1
		code16 = CODE16;
a2219 2
	    if (flag_16bit_code)
	      code16 ^= CODE16;
d2221 1
d2226 1
a2226 1
	if (!intel_syntax && (i.prefixes != 0))
d2236 2
a2237 1
	    insn_size += 2 + size;	/* opcode can be at most two bytes */
d2245 2
d2270 2
a2271 2
	int prefix = i.prefix[DATA_PREFIX] != 0;
	int code16 = 0;
d2273 6
a2278 1
	if (prefix)
d2280 1
a2280 1
	    code16 = CODE16;
d2282 1
a2283 2
	if (flag_16bit_code)
	  code16 ^= CODE16;
d2293 1
a2293 1
	if (!intel_syntax && (i.prefixes != 0))
a4260 1
/* ARGSUSED */
@


1.24
log
@	* config/tc-i386.c (md_apply_fix3): Add horrible adjustments to
	the value if TE_PE and a global defined symbol.
@
text
@d956 1
@


1.23
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/tc-i386.c (md_undefined_symbol): Compare the name against
	the macro GLOBAL_OFFSET_TABLE_NAME, rather than assuming that it
	starts with "_G".
@
text
@d941 2
a942 2
tc_i386_fix_adjustable(fixP)
     fixS * fixP;
d3911 13
d3926 13
@


1.22
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/tc-i386.c (tc_i386_fix_adjustable): Don't adjust
	relocations against global symbols if TE_PE.
@
text
@d4216 4
a4219 2
  if (*name == '_' && *(name+1) == 'G'
      && strcmp(name, GLOBAL_OFFSET_TABLE_NAME) == 0)
@


1.21
log
@comment change
@
text
@d944 3
a946 2
#ifdef OBJ_ELF
  /* Prevent all adjustments to global symbols. */
@


1.20
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/atof-ieee.c (atof_ieee): Change what_kind to int.
	* config/atof-vax.c (flonum_gen2vax): Change format_letter to
	int.
	(md_atof): Return NULL rather than 0.
	* config/tc-i386.c (md_atof): Change type to int.
@
text
@d3872 4
a3875 4
  /*
   * This is a hack.  There should be a better way to
   * handle this.
   */
@


1.19
log
@
i386 gas code cleanups: combine i386_is_reg and parse_register.
@
text
@d4012 1
a4012 1
     char type;
@


1.18
log
@
Allow spaces in i386 FP reg names, eg. %st ( 1 ).
@
text
@a2507 24
static int i386_is_reg PARAMS ((char *));

static int
i386_is_reg (reg_string)
     char *reg_string;
{
  register char *s = reg_string;
  register char *p;
  char reg_name_given[MAX_REG_NAME_SIZE + 1];

  if (is_space_char (*s))
    ++s;

  p = reg_name_given;
  while ((*p++ = register_chars[(unsigned char) *s++]) != '\0')
    if (p >= reg_name_given + MAX_REG_NAME_SIZE)
      return 0;

  if (!hash_find (reg_hash, reg_name_given))
    return 0;
  else
    return 1;
}

d2961 1
d2971 2
a2972 2
      if (*temp_disp != REGISTER_PREFIX
	  && !(allow_naked_reg && i386_is_reg (temp_disp)))
d3175 3
d3185 2
a3186 1
	  if (*op_string == '+')
d3188 1
a3188 1
	      char *temp_string = op_string + 1;
a3190 3
	      if (*temp_string == REGISTER_PREFIX
		  || (allow_naked_reg && i386_is_reg (temp_string)))
		++op_string;
d3193 2
a3194 2
	  if (*op_string == REGISTER_PREFIX
	      || (allow_naked_reg && i386_is_reg (op_string)))
a3195 10
	      const reg_entry *temp_reg;
	      char *end_op;

	      END_STRING_AND_SAVE (end_of_operand_string);
	      temp_reg = parse_register (op_string, &end_op);
	      RESTORE_END_STRING (end_of_operand_string);

	      if (temp_reg == NULL)
		return 0;

a3201 1

d3203 7
a3209 1
	  else if (is_digit_char (*op_string) || *op_string == '+' || *op_string == '-')
d3211 1
a3211 2

	      char *temp_string = build_displacement_string (false, op_string);
d3258 2
d3292 2
a3293 3
      else if (*op_string == REGISTER_PREFIX
	       || (allow_naked_reg
		   && i386_is_reg (op_string)))
a3294 7
	  register const reg_entry * r;
	  char *end_op;

	  r = parse_register (op_string, &end_op);
	  if (r == NULL)
	    return 0;

d3329 1
a3329 1
      else
d3331 2
a3332 2
	  if (!i386_intel_memory_operand (op_string))
	    return 0;
d3334 3
d3350 2
d3368 2
a3369 2
  if (*op_string == REGISTER_PREFIX
      || (allow_naked_reg && i386_is_reg (op_string)))
a3370 7
      register const reg_entry *r;
      char *end_op;

      r = parse_register (op_string, &end_op);
      if (r == NULL)
	return 0;

d3432 5
d3453 1
a3453 3
      char *end_of_operand_string;
      register char *base_string;
      int found_base_index_form;
a3459 3
      displacement_string_start = NULL;
      displacement_string_end = NULL;

d3473 1
a3473 6
      found_base_index_form = 0;
      end_of_operand_string = op_string + strlen (op_string);

      --end_of_operand_string;
      if (is_space_char (*end_of_operand_string))
	--end_of_operand_string;
d3475 7
a3481 1
      base_string = end_of_operand_string;
d3485 1
d3499 1
a3499 3
	  /* If there is a displacement set-up for it to be parsed later. */
	  displacement_string_start = op_string;
	  displacement_string_end = base_string;
d3506 3
a3508 20
	  if (*base_string == REGISTER_PREFIX
	      || (allow_naked_reg && i386_is_reg (base_string))
	      || *base_string == ',')
	    found_base_index_form = 1;
	}

      /* If we can't parse a base index register expression, we've found
	 a pure displacement expression.  We set up displacement_string_start
	 and displacement_string_end for the code below. */
      if (!found_base_index_form)
	{
	  displacement_string_start = op_string;
	  displacement_string_end = end_of_operand_string + 1;
	}
      else
	{
	  i.types[this_operand] |= BaseIndex;

	  /* Find base register (if any). */
	  if (*base_string != ',')
d3510 1
a3510 1
	      char *end_op;
d3512 1
a3512 5
	      /* Trim off the closing ')' so that parse_register won't
		 see it.  */
	      END_STRING_AND_SAVE (end_of_operand_string);
	      i.base_reg = parse_register (base_string, &end_op);
	      RESTORE_END_STRING (end_of_operand_string);
d3514 6
a3519 14
	      if (i.base_reg == NULL)
		return 0;

	      base_string = end_op;
	      if (is_space_char (*base_string))
		++base_string;
	    }

	  /* There may be an index reg or scale factor here.  */
	  if (*base_string == ',')
	    {
	      ++base_string;
	      if (is_space_char (*base_string))
		++base_string;
d3521 2
a3522 2
	      if (*base_string == REGISTER_PREFIX
		  || (allow_naked_reg && i386_is_reg (base_string)))
d3524 1
a3524 10
		  char *end_op;

		  END_STRING_AND_SAVE (end_of_operand_string);
		  i.index_reg = parse_register (base_string, &end_op);
		  RESTORE_END_STRING (end_of_operand_string);

		  if (i.index_reg == NULL)
		    return 0;

		  base_string = end_op;
d3527 3
a3529 1
		  if (*base_string == ',')
d3531 1
a3531 1
		      ++base_string;
d3534 12
d3547 1
a3547 1
		  else if (*base_string != ')' )
d3549 1
a3549 2
		      as_bad (_("expecting `,' or `)' after index register in `%s'"),
			      operand_string);
a3551 1
		}
d3553 5
a3557 5
	      /* Check for scale factor. */
	      if (isdigit ((unsigned char) *base_string))
		{
		  if (!i386_scale (base_string))
		    return 0;
d3559 11
a3569 4
		  ++base_string;
		  if (is_space_char (*base_string))
		    ++base_string;
		  if (*base_string != ')')
d3571 2
a3572 2
		      as_bad (_("expecting `)' after scale factor in `%s'"),
			      operand_string);
d3576 1
a3576 1
	      else if (!i.index_reg)
d3578 2
a3579 2
		  as_bad (_("expecting index register or scale factor after `,'; got '%c'"),
			  *base_string);
d3583 1
a3583 1
	  else if (*base_string != ')')
d3585 1
a3585 2
	      as_bad (_("expecting `,' or `)' after base register in `%s'"),
		      operand_string);
d4072 1
a4074 2
static const reg_entry * parse_register PARAMS ((char *, char **));

d4080 2
a4081 2
  register char *s = reg_string;
  register char *p;
d4093 1
a4093 1
  while ((*p++ = register_chars[(unsigned char) *s++]) != '\0')
d4096 2
a4097 8
	{
	  if (!allow_naked_reg)
	    {
	      *p = '\0';
	      as_bad (_("bad register name `%s'"), reg_name_given);
	    }
	  return (const reg_entry *) NULL;
	}
d4100 1
a4100 1
  *end_op = s - 1;
a4106 1
      --s;
d4111 1
a4111 1
	  *p++ = *s++;
d4117 1
a4117 1
	      *p++ = *s++;
a4124 6
	      *p++ = *s;
	    }
	  if (!allow_naked_reg)
	    {
	      *p = '\0';
	      as_bad (_("bad register name `%s'"), reg_name_given);
d4126 1
a4128 7
    }

  if (r == NULL)
    {
      if (!allow_naked_reg)
	as_bad (_("bad register name `%s'"), reg_name_given);
      return (const reg_entry *) NULL;
@


1.17
log
@
*gas/config/tc-i386.c: Fix errors in displacement size when
automatically inferring an address prefex.
@
text
@a705 2
    register_chars[')'] = ')';
    register_chars['('] = '(';
d4166 33
@


1.16
log
@
config/tc-i386.c: Remove dead code
@
text
@d3118 8
@


1.15
log
@
Support for gcc to generate 16-bit i386 code. (.code16gcc)
@
text
@a1765 6

	if (intel_syntax && i.suffix == LONG_DOUBLE_MNEM_SUFFIX)
	  {
	    if (i.tm.opcode_modifier & FloatMF)
	      i.tm.base_opcode ^= 2;
	  }
@


1.14
log
@	* config/obj-coff.c (coff_frob_symbol): Always update set_end with
	next_set_end even if the end symbol is being discarded.

	* gasp.c: Add ATTRIBUTE_UNUSED as needed for non-BFD_ASSEMBLER.
	* output-file.c, symbols.c, config/tc-i386.c: Likewise.
	* config/obj-coff.c: Likewise.
	(seg_info_type): Remove.
	(seg_info_off_by_4): Change to array of segT.
	(s_get_segment): Adjust accordingly.
	(obj_pseudo_table): Fully initialize sentinel entry.
@
text
@d44 1
a44 1
#define INFER_ADDR_PREFIX 0
d66 1
d233 4
d524 9
a532 1
	int new_16bit_code_flag;
d535 1
d540 1
a540 1
	int syntax_flag;
d592 1
d1650 4
d3086 1
a3086 1
static int i386_index_check PARAMS((void));
d3088 3
d3092 2
a3093 1
i386_index_check ()
a3094 1
  /* Make sure the memory operand we've been dealt is valid.  */
d3096 2
d3120 1
a3120 1
      if (i.prefix[ADDR_PREFIX] == 0)
d3124 1
d3127 4
d3132 4
a3135 2
#endif
	return 0;
d3274 2
a3275 6
  if (i386_index_check () == 0)
    {
      as_bad (_("`%s' is not a valid base/index expression"),
	      operand_string);
      return 0;
    }
a3440 2
	  /* Pretend given string starts here.  */
	  operand_string = op_string;
d3489 2
a3490 2
      char *displacement_string_start = NULL;
      char *displacement_string_end = NULL;
d3493 2
d3668 2
a3669 6
      if (i386_index_check () == 0)
	{
	  as_bad (_("`%s' is not a valid base/index expression"),
		  operand_string);
	  return 0;
	}
@


1.13
log
@
Rationalize some of the i386 intel mode code.
Indentation and white space changes.
@
text
@d3745 2
a3746 2
     object_headers *headers;
     segT sec;
d3880 1
a3880 1
     segT seg;			/* Segment fix is from.  */
@


1.12
log
@
* config/tc-i386.c: Add INFER_ADDR_PREFIX code. Fix 16 bit mode nop.
@
text
@d271 6
a276 6
/* The fields are:
   1) most positive reach of this state,
   2) most negative reach of this state,
   3) how many bytes this mode will add to the size of the current frag
   4) which index into the table to try if we can't fit into this one.
   */
d553 1
a553 1
                         && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
d785 1
a785 1
  fprintf (stdout, "    operation       %d\n", e->X_op);
d1078 1
a1078 1
	/* See if we can get a match by trimming off a suffix.	*/
d1091 1
a1091 1
            break;
d1093 9
a1101 9
          /* Intel Syntax */
          case INTEL_DWORD_MNEM_SUFFIX:
            if (intel_syntax)
              {
                i.suffix = mnem_p[-1];
                mnem_p[-1] = '\0';
                current_templates = hash_find (op_hash, mnemonic);
                break;
              }
d1150 1
a1150 1
                        if (!intel_syntax)
d1153 1
a1153 1
                        else
d1168 2
a1169 2
                if (!intel_syntax)
                  {
d1174 3
a1176 3
                  }
                else
                  {
d1181 1
a1181 1
                  }
d1197 4
a1200 4
                if (intel_syntax)
                  operand_ok = i386_intel_operand (token_start, intel_float_operand (mnemonic));
                else
                  operand_ok = i386_operand (token_start);
d1263 10
a1272 10
        && (strcmp (mnemonic, "enter") != 0)
        && (strcmp (mnemonic, "bound") != 0)
        && (strncmp (mnemonic, "fsub", 4) !=0)
        && (strncmp (mnemonic, "fdiv", 4) !=0))
      {
        const reg_entry *temp_reg = NULL;
        expressionS *temp_disp = NULL;
        expressionS *temp_imm = NULL;
        unsigned int temp_type;
        int xchg1 = 0;
d1275 22
a1296 64
        if (i.operands == 2)
          {
            xchg1 = 0;
            xchg2 = 1;
          }
        else if (i.operands == 3)
          {
            xchg1 = 0;
            xchg2 = 2;
          }

        if (i.operands > 1)
          {
            temp_type = i.types[xchg2];
            if (temp_type & (Reg | FloatReg))
              temp_reg = i.regs[xchg2];
            else if (temp_type & Imm)
              temp_imm = i.imms[xchg2];
            else if (temp_type & Disp)
              temp_disp = i.disps[xchg2];

            i.types[xchg2] = i.types[xchg1];

            if (i.types[xchg1] & (Reg | FloatReg))
              {
                i.regs[xchg2] = i.regs[xchg1];
                i.regs[xchg1] = NULL;
              }
            else if (i.types[xchg2] & Imm)
              {
                i.imms[xchg2] = i.imms[xchg1];
                i.imms[xchg1] = NULL;
              }
            else if (i.types[xchg2] & Disp)
              {
                i.disps[xchg2] = i.disps[xchg1];
                i.disps[xchg1] = NULL;
              }

            if (temp_type & (Reg | FloatReg))
              {
                i.regs[xchg1] = temp_reg;
                if (! (i.types[xchg1] & (Reg | FloatReg)))
                  i.regs[xchg2] = NULL;
              }
            else if (temp_type & Imm)
              {
                i.imms[xchg1] = temp_imm;
                if (! (i.types[xchg1] & Imm))
                  i.imms[xchg2] = NULL;
              }
            else if (temp_type & Disp)
              {
                i.disps[xchg1] = temp_disp;
                if (! (i.types[xchg1] & Disp))
                  i.disps[xchg2] = NULL;
              }

           i.types[xchg1] = temp_type;
           }
       if (!strcmp(mnemonic,"jmp")
           || !strcmp (mnemonic, "call"))
         if ((i.types[0] & Reg) || i.types[0] & BaseIndex)
           i.types[0] |= JumpAbsolute;
d1298 43
a1340 1
       }
d1352 4
a1355 4
                             ? No_lSuf
                             : (i.suffix == INTEL_DWORD_MNEM_SUFFIX
                                ? No_dSuf
                                : (i.suffix == LONG_DOUBLE_MNEM_SUFFIX ? No_xSuf : 0))))));
d1365 11
a1375 11
        /* For some opcodes, don't check the suffix */
        if (intel_syntax)
          {
            if (strcmp (t->name, "fnstcw")
                && strcmp (t->name, "fldcw")
                && (t->opcode_modifier & suffix_check))
              continue;
          }
        /* Must not have disallowed suffix. */
        else if ((t->opcode_modifier & suffix_check))
            continue;
d1432 1
a1432 1
	                                           t->operand_types[2]))
d1434 1
a1434 1
                  continue;
d1538 7
a1544 7
                /* movzx and movsx should not generate this warning. */
                if (intel_syntax
                    && (i.tm.base_opcode == 0xfb7
                        || i.tm.base_opcode == 0xfb6
                        || i.tm.base_opcode == 0xfbe
                        || i.tm.base_opcode == 0xfbf))
                  continue;
d1644 2
a1645 2
	   overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX ? (Imm8 | Imm8S) :
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 : Imm32));
d1649 1
a1649 1
	   overlap0 =
d1664 2
a1665 2
	   overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX ? (Imm8 | Imm8S) :
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 : Imm32));
d1669 1
a1669 1
	   overlap1 =
d1705 1
a1705 1
        && (i.tm.base_opcode == 0xfb6 || i.tm.base_opcode == 0xfbe))
d1707 2
a1708 2
        {
          unsigned int prefix = DATA_PREFIX_OPCODE;
d1710 4
a1713 4
          if ((i.regs[1]->reg_type & Reg16) != 0)
            if (!add_prefix (prefix))
              return;
        }
d1729 1
a1729 1
             || i.suffix == DWORD_MNEM_SUFFIX
d1742 1
a1742 1
            || (intel_syntax && i.suffix == INTEL_DWORD_MNEM_SUFFIX))
d1748 5
a1752 5
        if (intel_syntax && i.suffix == LONG_DOUBLE_MNEM_SUFFIX)
          {
            if (i.tm.opcode_modifier & FloatMF)
              i.tm.base_opcode ^= 2;
          }
d1777 1
a1777 1
        /* Default segment register this instruction will use
d2063 2
a2064 2
       /* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc */
       as_warn (_("translating to `%sp'"), i.tm.name);
d2108 1
a2108 1
	        /* Use 16-bit jumps only for 16-bit code,
d2110 1
a2110 1
	           Use 32-bit jumps for 32-bit code, because they're faster,
d2113 1
a2113 1
	      	if (code16 && !fits_in_signed_word (n))
d2388 2
a2389 2
				as_warn (_("%ld shortened to %ld"),
					 val, val & ~mask);
d2441 2
a2442 2
				as_warn (_("%ld shortened to %ld"),
					 val, val & ~mask);
d2547 19
a2565 19
    {
      /*
       * We can have operands of the form
       *   <symbol>@@GOTOFF+<nnn>
       * Take the easy way out here and copy everything
       * into a temporary buffer...
       */
      register char *cp;

      cp = strchr (input_line_pointer, '@@');
      if (cp != NULL)
        {
	  char *tmpbuf;
	  int len = 0;
	  int first;

	  /* GOT relocations are not supported in 16 bit mode */
	  if (flag_16bit_code)
	    as_bad (_("GOT relocations not supported in 16 bit mode"));
d2567 2
a2568 2
	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);
d2570 17
a2586 17
	  if (strncmp (cp + 1, "PLT", 3) == 0)
	    {
	      i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
	      len = 3;
	    }
	  else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
	    {
	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
	      len = 6;
	    }
	  else if (strncmp (cp + 1, "GOT", 3) == 0)
	    {
	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
	      len = 3;
	    }
	  else
	    as_bad (_("Bad reloc specifier in expression"));
d2588 10
a2597 10
	  /* Replace the relocation token with ' ', so that errors like
	     foo@@GOTOFF1 will be detected.  */
	  first = cp - input_line_pointer;
	  tmpbuf = (char *) alloca (strlen(input_line_pointer));
	  memcpy (tmpbuf, input_line_pointer, first);
	  tmpbuf[first] = ' ';
	  strcpy (tmpbuf + first + 1, cp + 1 + len);
	  input_line_pointer = tmpbuf;
	}
    }
d2612 1
a2612 1
              imm_start);
d2630 8
a2637 8
        {
        case WORD_MNEM_SUFFIX:
          i.types[this_operand] |= Imm16;
          break;
        case BYTE_MNEM_SUFFIX:
          i.types[this_operand] |= Imm16 | Imm8 | Imm8S;
          break;
        }
d2641 3
a2643 3
           && exp_seg != data_section
           && exp_seg != bss_section
           && exp_seg != undefined_section
d2645 1
a2645 1
           && !bfd_is_com_section (exp_seg)
d2647 1
a2647 1
          )
d2656 4
a2659 4
         determined later, depending on destination register,
         suffix, or the default for the section.  We exclude
         Imm8S here so that `push $foo' and other instructions
         with an Imm8S form will use Imm16 or Imm32.  */
d2693 1
a2693 1
              scale);
d2699 1
a2699 1
               1 << i.log2_scale_factor);
a2718 4
  /*  All of the pieces of the displacement expression are handled together. */
  if (intel_syntax && i.disp_operands != 0)
    return 1;

d2737 1
a2737 1
       && displacement_string_end[-1] == '+')
d2740 2
a2741 2
         constraint within gcc asm statements.
         For instance:
d2743 26
a2768 26
        #define _set_tssldt_desc(n,addr,limit,type) \
        __asm__ __volatile__ ( \
        "movw %w2,%0\n\t" \
        "movw %w1,2+%0\n\t" \
        "rorl $16,%1\n\t" \
        "movb %b1,4+%0\n\t" \
        "movb %4,5+%0\n\t" \
        "movb $0,6+%0\n\t" \
        "movb %h1,7+%0\n\t" \
        "rorl $16,%1" \
        : "=o"(*(n)) : "q" (addr), "ri"(limit), "i"(type))

        This works great except that the output assembler ends
        up looking a bit weird if it turns out that there is
        no offset.  You end up producing code that looks like:

        #APP
               movw $235,(%eax)
               movw %dx,2+(%eax)
               rorl $16,%edx
               movb %dl,4+(%eax)
               movb $137,5+(%eax)
               movb $0,6+(%eax)
               movb %dh,7+(%eax)
               rorl $16,%edx
        #NO_APP
d2770 2
a2771 2
        So here we provide the missing zero.
    */
d2773 1
a2773 1
    *displacement_string_end = '0';
d2777 19
a2795 19
    {
      /*
       * We can have operands of the form
       *   <symbol>@@GOTOFF+<nnn>
       * Take the easy way out here and copy everything
       * into a temporary buffer...
       */
      register char *cp;

      cp = strchr (input_line_pointer, '@@');
      if (cp != NULL)
        {
	  char *tmpbuf;
	  int len = 0;
	  int first;

	 /* GOT relocations are not supported in 16 bit mode */
	 if (flag_16bit_code)
	   as_bad (_("GOT relocations not supported in 16 bit mode"));
d2797 2
a2798 2
	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);
d2800 17
a2816 17
	  if (strncmp (cp + 1, "PLT", 3) == 0)
	    {
	      i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
	      len = 3;
	    }
	  else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
	    {
	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
	      len = 6;
	    }
	  else if (strncmp (cp + 1, "GOT", 3) == 0)
	    {
	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
	      len = 3;
	    }
	  else
	    as_bad (_("Bad reloc specifier in expression"));
d2818 10
a2827 10
	  /* Replace the relocation token with ' ', so that errors like
	     foo@@GOTOFF1 will be detected.  */
	  first = cp - input_line_pointer;
	  tmpbuf = (char *) alloca (strlen(input_line_pointer));
	  memcpy (tmpbuf, input_line_pointer, first);
	  tmpbuf[first] = ' ';
	  strcpy (tmpbuf + first + 1, cp + 1 + len);
	  input_line_pointer = tmpbuf;
	}
    }
d2830 1
a2830 1
    exp_seg = expression (exp);
d2833 13
a2845 13
    /* We do this to make sure that the section symbol is in
       the symbol table.  We will ultimately change the relocation
       to be relative to the beginning of the section */
    if (i.disp_reloc[this_operand] == BFD_RELOC_386_GOTOFF)
      {
        if (S_IS_LOCAL(exp->X_add_symbol)
            && S_GET_SEGMENT (exp->X_add_symbol) != undefined_section)
          section_symbol (S_GET_SEGMENT (exp->X_add_symbol));
        assert (exp->X_op == O_symbol);
        exp->X_op = O_subtract;
        exp->X_op_symbol = GOT_symbol;
        i.disp_reloc[this_operand] = BFD_RELOC_32;
      }
d2848 4
a2851 4
     SKIP_WHITESPACE ();
     if (*input_line_pointer)
       as_bad (_("Ignoring junk `%s' after expression"),
               input_line_pointer);
d2853 1
a2853 1
     RESTORE_END_STRING (disp_end + 1);
d2855 2
a2856 2
     RESTORE_END_STRING (disp_end);
     input_line_pointer = save_input_line_pointer;
d2858 5
a2862 5
     if (exp->X_op == O_constant)
       {
         if (fits_in_signed_byte (exp->X_add_number))
           i.types[this_operand] |= Disp8;
       }
d2864 8
a2871 8
     else if (exp_seg != text_section
              && exp_seg != data_section
              && exp_seg != bss_section
              && exp_seg != undefined_section)
            {
              as_bad (_ ("Unimplemented segment type %d in operand"), exp_seg);
              return 0;
            }
d2883 5
a2887 5
    if (!strncasecmp (*op_string, "BYTE PTR", 8))
      {
        i.suffix = BYTE_MNEM_SUFFIX;
        *op_string += 8;
        return BYTE_PTR;
d2889 7
a2895 7
      }
    else if (!strncasecmp (*op_string, "WORD PTR", 8))
      {
        i.suffix = WORD_MNEM_SUFFIX;
        *op_string += 8;
        return WORD_PTR;
      }
d2897 9
a2905 9
    else if (!strncasecmp (*op_string, "DWORD PTR", 9))
      {
        if (got_a_float)
          i.suffix = SHORT_MNEM_SUFFIX;
        else
          i.suffix = DWORD_MNEM_SUFFIX;
        *op_string += 9;
        return DWORD_PTR;
      }
d2907 6
a2912 6
    else if (!strncasecmp (*op_string, "QWORD PTR", 9))
      {
        i.suffix = INTEL_DWORD_MNEM_SUFFIX;
        *op_string += 9;
        return QWORD_PTR;
      }
d2914 6
a2919 6
    else if (!strncasecmp (*op_string, "XWORD PTR", 9))
      {
        i.suffix = LONG_DOUBLE_MNEM_SUFFIX;
        *op_string += 9;
        return XWORD_PTR;
      }
d2921 5
a2925 5
    else if (!strncasecmp (*op_string, "SHORT", 5))
      {
        *op_string += 5;
        return SHORT;
      }
d2927 5
a2931 5
    else if (!strncasecmp (*op_string, "OFFSET FLAT:", 12))
      {
        *op_string += 12;
        return OFFSET_FLAT;
      }
d2933 5
a2937 5
    else if (!strncasecmp (*op_string, "FLAT", 4))
      {
        *op_string += 4;
        return FLAT;
      }
d2939 1
a2939 1
    else return NONE_FOUND;
d2977 1
a2977 1
        temp_disp++;
d2980 1
a2980 1
        temp_disp++;
d2984 19
a3002 19
          && !(allow_naked_reg && i386_is_reg (temp_disp)))
        {
          char *string_start = temp_disp;

          while (*temp_disp != ']'
                 && *temp_disp != '+'
                 && *temp_disp != '-'
                 && *temp_disp != '*')
            ++temp_disp;

          if (add_minus)
            strcat (temp_string, "-");
          else
            strcat (temp_string, "+");

          strncat (temp_string, string_start, temp_disp - string_start);
          if (*temp_disp == '+' || *temp_disp == '-')
            --temp_disp;
        }
d3005 3
a3007 3
             && *temp_disp != '+'
             && *temp_disp != '-')
        ++temp_disp;
d3050 2
a3051 2
       as_bad (_("bad segment name `%s'"), op_string);
       return 0;
d3059 2
a3060 2
       as_bad (_("bad segment name `%s'"), op_string);
       return 0;
d3067 42
d3112 2
a3113 2
i386_intel_memory_operand (op_string)
     char *op_string;
d3115 1
a3115 1

d3118 3
a3120 2
  if (is_digit_char (*op_string)
      && strchr (op_string, '[') == 0)
d3122 3
a3124 4
      if (!i386_immediate (op_string))
        return 0;
      else
        return 1;
d3135 5
a3139 5
        {
           if (!i386_parse_seg (op_string))
             return 0;
           op_string = end_seg + 1;
        }
d3142 4
a3145 2
      if (!i386_displacement (temp_string, temp_string + strlen (temp_string)))
        return 0;
d3149 1
a3149 1
        end_of_operand_string = op_string + strlen (op_string);
d3152 1
a3152 1
        --end_of_operand_string;
d3155 1
a3155 1
     }
d3166 27
a3192 1
        {
d3194 54
a3247 72
          while (*end_of_operand_string != '+'
                 && *end_of_operand_string != '-'
                 && *end_of_operand_string != '*'
                 && *end_of_operand_string != ']')
            end_of_operand_string++;

          if (*op_string == '+')
            {
              char *temp_string = op_string + 1;
              if (is_space_char (*temp_string))
                ++temp_string;
              if (*temp_string == REGISTER_PREFIX
                  || (allow_naked_reg && i386_is_reg (temp_string)))
                ++op_string;
            }

          if (*op_string == REGISTER_PREFIX
              || (allow_naked_reg && i386_is_reg (op_string)))
            {
              const reg_entry *temp_reg;
              char *end_op;

              END_STRING_AND_SAVE (end_of_operand_string);
              temp_reg = parse_register (op_string, &end_op);
              RESTORE_END_STRING (end_of_operand_string);

              if (temp_reg == NULL)
                return 0;

              if (i.base_reg == NULL)
                i.base_reg = temp_reg;
              else
                i.index_reg = temp_reg;

              i.types[this_operand] |= BaseIndex;

            }
          else if (is_digit_char (*op_string) || *op_string == '+' || *op_string == '-')
            {

              char *temp_string = build_displacement_string (false, op_string);

              if (*temp_string == '+')
                ++temp_string;

              if (!i386_displacement (temp_string, temp_string + strlen (temp_string)))
                return 0;

              ++op_string;
              end_of_operand_string = op_string;
              while (*end_of_operand_string != ']'
                     && *end_of_operand_string != '+'
                     && *end_of_operand_string != '-'
                     && *end_of_operand_string != '*')
               ++end_of_operand_string;
            }
          else if (*op_string == '*')
            {
              ++op_string;

              if (i.base_reg && !i.index_reg)
                {
                  i.index_reg = i.base_reg;
                  i.base_reg = 0;
                }

              if (!i386_scale (op_string))
                return 0;
            }
          op_string = end_of_operand_string;
          ++end_of_operand_string;
        }
d3250 1
a3253 2
static int i386_intel_operand PARAMS ((char *, int));

a3271 9
      if ((i.mem_operands == 1
           && (current_templates->start->opcode_modifier & IsString) == 0)
          || i.mem_operands == 2)
        {
          as_bad (_("too many memory references for `%s'"),
                  current_templates->start->name);
          return 0;
        }

d3273 1
a3273 3
        return 0;

      i.mem_operands++;
a3276 1

d3279 1
a3279 1
        return 0;
a3282 1

a3294 1

a3335 1

a3337 1

a3339 2

	  i.mem_operands++;
d3342 1
a3343 44
    }  /* end switch */
  /* Special case for (%dx) while doing input/output op.  */
  if (i.base_reg
      && i.base_reg->reg_type == (Reg16 | InOutPortReg)
      && i.index_reg == 0
      && i.log2_scale_factor == 0
      && i.seg[i.mem_operands] == 0
      && (i.types[this_operand] & Disp) == 0)
    {
      i.types[this_operand] = InOutPortReg;
      return 1;
    }
  /* Make sure the memory operand we've been dealt is valid.  */
  if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
    {
      if ((i.base_reg
	   && ((i.base_reg->reg_type & (Reg16|BaseIndex))
	       != (Reg16|BaseIndex)))
	  || (i.index_reg
	      && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		   != (Reg16|BaseIndex))
		  || ! (i.base_reg
			&& i.base_reg->reg_num < 6
			&& i.index_reg->reg_num >= 6
			&& i.log2_scale_factor == 0))))
	{
	 as_bad (_("`%s' is not a valid %s bit base/index expression"),
		 operand_string, "16");
	 return 0;
	}
    }
  else
    {
      if ((i.base_reg
	   && (i.base_reg->reg_type & Reg32) == 0)
	  || (i.index_reg
	      && ((i.index_reg->reg_type & (Reg32|BaseIndex))
		  != (Reg32|BaseIndex))))
	{
	 as_bad (_("`%s' is not a valid %s bit base/index expression"),
		 operand_string, "32");
	 return 0;
	}
    }
a3349 2
static int i386_operand PARAMS ((char *));

d3354 1
a3354 1
 char *op_string = operand_string;
d3356 1
a3356 1
 if (is_space_char (*op_string))
d3359 49
a3407 49
 /* We check for an absolute prefix (differentiating,
    for example, 'jmp pc_relative_label' from 'jmp *absolute_label'. */
 if (*op_string == ABSOLUTE_PREFIX)
   {
    ++op_string;
    if (is_space_char (*op_string))
       ++op_string;
    i.types[this_operand] |= JumpAbsolute;
   }

 /* Check if operand is a register. */
 if (*op_string == REGISTER_PREFIX
     || (allow_naked_reg && i386_is_reg (op_string)))
   {
    register const reg_entry *r;
    char *end_op;

    r = parse_register (op_string, &end_op);
    if (r == NULL)
       return 0;

    /* Check for a segment override by searching for ':' after a
       segment register.  */
    op_string = end_op;
    if (is_space_char (*op_string))
       ++op_string;
    if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
      {
       switch (r->reg_num)
	 {
	 case 0:
	  i.seg[i.mem_operands] = &es;
	  break;
	 case 1:
	  i.seg[i.mem_operands] = &cs;
	  break;
	 case 2:
	  i.seg[i.mem_operands] = &ss;
	  break;
	 case 3:
	  i.seg[i.mem_operands] = &ds;
	  break;
	 case 4:
	  i.seg[i.mem_operands] = &fs;
	  break;
	 case 5:
	  i.seg[i.mem_operands] = &gs;
	  break;
	 }
d3409 1
a3409 3
       /* Skip the ':' and whitespace.  */
       ++op_string;
       if (is_space_char (*op_string))
d3411 2
d3414 35
a3448 8
       /* Pretend given string starts here. */
       operand_string = op_string;
       if (!is_digit_char (*op_string)
	   && !is_identifier_char (*op_string)
	   && *op_string != '('
	   && *op_string != ABSOLUTE_PREFIX)
	 {
	  as_bad (_("bad memory operand `%s'"), op_string);
d3450 18
a3467 91
	 }
       /* Handle case of %es:*foo. */
       if (*op_string == ABSOLUTE_PREFIX)
	 {
	  ++op_string;
	  if (is_space_char (*op_string))
	     ++op_string;
	  i.types[this_operand] |= JumpAbsolute;
	 }
       goto do_memory_reference;
      }
    if (*op_string)
      {
       as_bad (_("Junk `%s' after register"), op_string);
       return 0;
      }
    i.types[this_operand] |= r->reg_type & ~BaseIndex;
    i.regs[this_operand] = r;
    i.reg_operands++;
   }
 else if (*op_string == IMMEDIATE_PREFIX)
   {				/* ... or an immediate */
    ++op_string;
    if (i.types[this_operand] & JumpAbsolute)
      {
       as_bad (_("Immediate operand illegal with absolute jump"));
       return 0;
      }
    if (!i386_immediate (op_string))
       return 0;
   }
 else if (is_digit_char (*op_string)
	  || is_identifier_char (*op_string)
	  || *op_string == '(' )
   {
    /* This is a memory reference of some sort. */
    char *end_of_operand_string;
    register char *base_string;
    int found_base_index_form;

    /* Start and end of displacement string expression (if found). */
    char *displacement_string_start = NULL;
    char *displacement_string_end = NULL;

   do_memory_reference:

    if ((i.mem_operands == 1
	 && (current_templates->start->opcode_modifier & IsString) == 0)
	|| i.mem_operands == 2)
      {
       as_bad (_("too many memory references for `%s'"),
	       current_templates->start->name);
       return 0;
      }

    /* Check for base index form.  We detect the base index form by
       looking for an ')' at the end of the operand, searching
       for the '(' matching it, and finding a REGISTER_PREFIX or ','
       after the '('.  */
    found_base_index_form = 0;
    end_of_operand_string = op_string + strlen (op_string);

    --end_of_operand_string;
    if (is_space_char (*end_of_operand_string))
       --end_of_operand_string;

    base_string = end_of_operand_string;

    if (*base_string == ')')
      {
       unsigned int parens_balanced = 1;
       /* We've already checked that the number of left & right ()'s are
	  equal, so this loop will not be infinite. */
       do
	 {
	  base_string--;
	  if (*base_string == ')')
	     parens_balanced++;
	  if (*base_string == '(')
	     parens_balanced--;
	 }
       while (parens_balanced);

       /* If there is a displacement set-up for it to be parsed later. */
       displacement_string_start = op_string;
       displacement_string_end = base_string;

       /* Skip past '(' and whitespace.  */
       ++base_string;
       if (is_space_char (*base_string))
	  ++base_string;
d3469 8
a3476 5
       if (*base_string == REGISTER_PREFIX
	   || (allow_naked_reg && i386_is_reg (base_string))
	   || *base_string == ',')
	  found_base_index_form = 1;
      }
d3478 6
a3483 11
    /* If we can't parse a base index register expression, we've found
       a pure displacement expression.  We set up displacement_string_start
       and displacement_string_end for the code below. */
    if (!found_base_index_form)
      {
       displacement_string_start = op_string;
       displacement_string_end = end_of_operand_string + 1;
      }
    else
      {
       i.types[this_operand] |= BaseIndex;
d3485 3
a3487 4
       /* Find base register (if any). */
       if (*base_string != ',')
	 {
	  char *end_op;
d3489 1
a3489 5
	  /* Trim off the closing ')' so that parse_register won't
	     see it.  */
	  END_STRING_AND_SAVE (end_of_operand_string);
	  i.base_reg = parse_register (base_string, &end_op);
	  RESTORE_END_STRING (end_of_operand_string);
d3491 14
a3504 2
	  if (i.base_reg == NULL)
	     return 0;
d3506 3
a3508 4
	  base_string = end_op;
	  if (is_space_char (*base_string))
	     ++base_string;
	 }
d3510 1
a3510 3
       /* There may be an index reg or scale factor here.  */
       if (*base_string == ',')
	 {
d3513 1
a3513 1
	     ++base_string;
d3516 19
a3534 1
	      || (allow_naked_reg && i386_is_reg (base_string)))
d3536 1
a3536 1
	     char *end_op;
d3538 5
a3542 3
	     END_STRING_AND_SAVE (end_of_operand_string);
	     i.index_reg = parse_register (base_string, &end_op);
	     RESTORE_END_STRING (end_of_operand_string);
d3544 1
a3544 1
	     if (i.index_reg == NULL)
d3547 2
a3548 2
	     base_string = end_op;
	     if (is_space_char (*base_string))
a3549 12
	     if (*base_string == ',')
	       {
		++base_string;
		if (is_space_char (*base_string))
		   ++base_string;
	       }
	     else if (*base_string != ')' )
	       {
		as_bad (_("expecting `,' or `)' after index register in `%s'"),
			operand_string);
		return 0;
	       }
d3552 2
a3553 2
	  /* Check for scale factor. */
	  if (isdigit ((unsigned char) *base_string))
d3555 38
a3592 2
	     if (!i386_scale (base_string))
		return 0;
d3594 16
a3609 9
	     ++base_string;
	     if (is_space_char (*base_string))
		++base_string;
	     if (*base_string != ')')
	       {
		as_bad (_("expecting `)' after scale factor in `%s'"),
			operand_string);
		return 0;
	       }
d3611 1
a3611 1
	  else if (!i.index_reg)
d3613 3
a3615 3
	     as_bad (_("expecting index register or scale factor after `,'; got '%c'"),
		     *base_string);
	     return 0;
d3617 27
a3643 4
	 }
       else if (*base_string != ')')
	 {
	  as_bad (_("expecting `,' or `)' after base register in `%s'"),
d3646 12
a3657 93
	 }
      }

    /* If there's an expression beginning the operand, parse it,
       assuming displacement_string_start and
       displacement_string_end are meaningful.  */
    if (displacement_string_start != displacement_string_end)
      {
       if (!i386_displacement (displacement_string_start,
			       displacement_string_end))
	  return 0;
      }

    /* Special case for (%dx) while doing input/output op.  */
    if (i.base_reg
	&& i.base_reg->reg_type == (Reg16 | InOutPortReg)
	&& i.index_reg == 0
	&& i.log2_scale_factor == 0
	&& i.seg[i.mem_operands] == 0
	&& (i.types[this_operand] & Disp) == 0)
      {
       i.types[this_operand] = InOutPortReg;
       return 1;
      }
    /* Make sure the memory operand we've been dealt is valid.  */
    if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
      {
#if INFER_ADDR_PREFIX
      try16:
#endif
       if ((i.base_reg
	    && ((i.base_reg->reg_type & (Reg16|BaseIndex))
		!= (Reg16|BaseIndex)))
	   || (i.index_reg
	       && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		    != (Reg16|BaseIndex))
		   || ! (i.base_reg
			 && i.base_reg->reg_num < 6
			 && i.index_reg->reg_num >= 6
			 && i.log2_scale_factor == 0))))
	 {
#if INFER_ADDR_PREFIX
	  if (i.prefix[ADDR_PREFIX] == 0)
	    {
	     i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
	     goto try32;
	    }
	  else
#endif
	    {
	     as_bad (_("`%s' is not a valid %s bit base/index expression"),
		     operand_string, "16");
	     return 0;
	    }
	 }
      }
    else
      {
#if INFER_ADDR_PREFIX
      try32:
#endif
       if ((i.base_reg
	    && (i.base_reg->reg_type & Reg32) == 0)
	   || (i.index_reg
	       && ((i.index_reg->reg_type & (Reg32|BaseIndex))
		   != (Reg32|BaseIndex))))
	 {
#if INFER_ADDR_PREFIX
	  if (i.prefix[ADDR_PREFIX] == 0)
	    {
	     i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
	     goto try16;
	    }
	  else
#endif
	    {
	     as_bad (_("`%s' is not a valid %s bit base/index expression"),
		     operand_string, "32");
	     return 0;
	    }
	 }
      }
    i.mem_operands++;
   }
 else
   {				/* it's not a memory operand; argh! */
    as_bad (_("invalid char %s beginning operand %d `%s'"),
	    output_invalid (*op_string),
	    this_operand + 1,
	    op_string);
    return 0;
   }
 return 1;			/* normal return */
d3661 1
a3661 1
 *			md_estimate_size_before_relax()
d3711 2
a3712 2
	  /* This changes the byte-displacement jump 0x7N -->
			   the dword-displacement jump 0x0f8N */
d3720 2
a3721 2
				     presence of @@PLT, but I cannot see how
				     to get to that from here.  ERY */
d3940 1
a3940 1
         address offset for a PC relative symbol.  */
d3959 1
a3959 1
 *  This is tough to explain.  We end up with this one if we have
d3966 1
a3966 1
 * 	call	.L66
d3968 2
a3969 2
 * 	popl	%ebx
 * 	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
d3971 1
a3971 1
 * 	The call and pop essentially return the absolute address of
d3981 1
a3981 1
 * 	Our job here is to fix the operand so that it would add the correct
d3987 1
a3987 1
 * 	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
d3999 1
a3999 1
      value = 0; /* Fully resolved at runtime.  No addend. */
d4131 2
a4132 2
          if (!allow_naked_reg)
            {
d4135 1
a4135 1
            }
d4147 1
a4147 1
        as_bad (_("bad register name `%s'"), reg_name_given);
d4235 12
a4246 12
	if (*name == '_' && *(name+1) == 'G'
	    && strcmp(name, GLOBAL_OFFSET_TABLE_NAME) == 0)
	  {
	    if (!GOT_symbol)
	      {
		if (symbol_find (name))
		  as_bad (_("GOT already in symbol table"));
		GOT_symbol = symbol_new (name, undefined_section,
					 (valueT) 0, &zero_address_frag);
	      };
	    return GOT_symbol;
	  }
@


1.11
log
@
Fix an overflow checking bug uncovered when a 32 bit target is compiled
with a 64 bit bfd.
@
text
@d43 4
d350 2
d371 1
a371 1
    f32_1, f32_2, f32_3, f16_4, f16_5, f16_6, f16_7, f16_8,
d546 1
a546 1
  
d553 1
a553 1
                         && (bfd_get_symbol_leading_char (stdoutput) != '\0')); 
d1295 1
a1295 1
           
d1339 1
a1339 1
         
d1352 3
a1354 3
                             ? No_lSuf 
                             : (i.suffix == INTEL_DWORD_MNEM_SUFFIX 
                                ? No_dSuf 
d1373 1
a1373 1
        /* Must not have disallowed suffix. */ 
d2520 1
a2520 1
 
d2944 1
a2944 1
} 
d2973 1
a2973 1
  else 
d3067 2
a3068 2
  return 1; 
  
d3175 1
a3175 1
             
d3250 11
a3260 11
    /* Should be register or immediate */
    if (is_digit_char (*op_string)
        && strchr (op_string, '[') == 0)
      {
      if (!i386_immediate (op_string))
        return 0;
      }
    else if (*op_string == REGISTER_PREFIX
             || (allow_naked_reg
	         && i386_is_reg (op_string)))
      {
d3262 2
a3263 2
        register const reg_entry * r;
        char *end_op;
d3265 32
a3296 3
        r = parse_register (op_string, &end_op);
        if (r == NULL)
          return 0;
d3298 5
a3302 28
        /* Check for a segment override by searching for ':' after a
           segment register.  */
        op_string = end_op;
        if (is_space_char (*op_string))
          ++op_string;
        if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
          {
            switch (r->reg_num)
              {
              case 0:
                i.seg[i.mem_operands] = &es;
                break;
              case 1:
                i.seg[i.mem_operands] = &cs;
                break;
              case 2:
                i.seg[i.mem_operands] = &ss;
                break;
              case 3:
                i.seg[i.mem_operands] = &ds;
                break;
              case 4:
                i.seg[i.mem_operands] = &fs;
                break;
              case 5:
                i.seg[i.mem_operands] = &gs;
                break;
              }
d3304 2
a3305 5
          }
        i.types[this_operand] |= r->reg_type & ~BaseIndex;
        i.regs[this_operand] = r;
        i.reg_operands++;
      }
d3307 2
a3308 2
    else 
      {
d3310 3
a3312 2
        if (!i386_intel_memory_operand (op_string))
          return 0;
d3314 1
a3314 5
        i.mem_operands++;
      }
    break;

  }  /* end switch */
d3322 4
a3325 4
     {
       i.types[this_operand] = InOutPortReg;
       return 1;
     }
d3331 13
a3343 13
		!= (Reg16|BaseIndex)))
	      || (i.index_reg
		  && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		       != (Reg16|BaseIndex))
		      || ! (i.base_reg
			    && i.base_reg->reg_num < 6
			    && i.index_reg->reg_num >= 6
			    && i.log2_scale_factor == 0))))
	 {
	   as_bad (_("`%s' is not a valid %s bit base/index expression"),
                   operand_string, "16");
           return 0;
	 }
d3345 7
a3351 1
      else
d3353 3
a3355 10
	  if ((i.base_reg
	       && (i.base_reg->reg_type & Reg32) == 0)
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg32|BaseIndex))
		      != (Reg32|BaseIndex))))
	    {
	      as_bad (_("`%s' is not a valid %s bit base/index expression"),
		      operand_string, "32");
	      return 0;
	    }
d3357 1
d3370 1
a3370 1
  char *op_string = operand_string;
d3372 1
a3372 1
  if (is_space_char (*op_string))
d3375 16
a3390 9
  /* We check for an absolute prefix (differentiating,
     for example, 'jmp pc_relative_label' from 'jmp *absolute_label'. */
  if (*op_string == ABSOLUTE_PREFIX)
    {
      ++op_string;
      if (is_space_char (*op_string))
        ++op_string;
      i.types[this_operand] |= JumpAbsolute;
    }
d3392 3
a3394 6
  /* Check if operand is a register. */
  if (*op_string == REGISTER_PREFIX
      || (allow_naked_reg && i386_is_reg (op_string)))
    {
      register const reg_entry *r;
      char *end_op;
d3396 28
a3423 3
      r = parse_register (op_string, &end_op);
      if (r == NULL)
        return 0;
d3425 4
a3428 28
      /* Check for a segment override by searching for ':' after a
	 segment register.  */
      op_string = end_op;
      if (is_space_char (*op_string))
        ++op_string;
      if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
        {
          switch (r->reg_num)
            {
            case 0:
	      i.seg[i.mem_operands] = &es;
	      break;
	    case 1:
	      i.seg[i.mem_operands] = &cs;
	      break;
	    case 2:
	      i.seg[i.mem_operands] = &ss;
	      break;
	    case 3:
	      i.seg[i.mem_operands] = &ds;
	      break;
	    case 4:
	      i.seg[i.mem_operands] = &fs;
	      break;
	    case 5:
	      i.seg[i.mem_operands] = &gs;
	      break;
	    }
d3430 13
a3442 1
	  /* Skip the ':' and whitespace.  */
d3445 48
a3492 1
	    ++op_string;
d3494 27
a3520 52
	  /* Pretend given string starts here. */
	  operand_string = op_string;
	  if (!is_digit_char (*op_string)
	      && !is_identifier_char (*op_string)
	      && *op_string != '('
	      && *op_string != ABSOLUTE_PREFIX)
	    {
	      as_bad (_("bad memory operand `%s'"), op_string);
	      return 0;
	    }
	  /* Handle case of %es:*foo. */
	  if (*op_string == ABSOLUTE_PREFIX)
	    {
	      ++op_string;
	      if (is_space_char (*op_string))
		++op_string;
	      i.types[this_operand] |= JumpAbsolute;
	    }
	  goto do_memory_reference;
	}
      if (*op_string)
	{
	  as_bad (_("Junk `%s' after register"), op_string);
	  return 0;
	}
      i.types[this_operand] |= r->reg_type & ~BaseIndex;
      i.regs[this_operand] = r;
      i.reg_operands++;
    }
  else if (*op_string == IMMEDIATE_PREFIX)
    {				/* ... or an immediate */
      ++op_string;
      if (i.types[this_operand] & JumpAbsolute)
	{
	  as_bad (_("Immediate operand illegal with absolute jump"));
	  return 0;
	}
      if (!i386_immediate (op_string))
        return 0;
    }
  else if (is_digit_char (*op_string) 
           || is_identifier_char (*op_string)
	   || *op_string == '(' )
    {
      /* This is a memory reference of some sort. */
      char *end_of_operand_string;
      register char *base_string;
      int found_base_index_form;

      /* Start and end of displacement string expression (if found). */
      char *displacement_string_start = NULL;
      char *displacement_string_end = NULL;
d3522 8
a3529 1
    do_memory_reference:
d3531 5
a3535 8
      if ((i.mem_operands == 1
	   && (current_templates->start->opcode_modifier & IsString) == 0)
	  || i.mem_operands == 2)
	{
	  as_bad (_("too many memory references for `%s'"),
		  current_templates->start->name);
	  return 0;
	}
d3537 11
a3547 6
      /* Check for base index form.  We detect the base index form by
	 looking for an ')' at the end of the operand, searching
	 for the '(' matching it, and finding a REGISTER_PREFIX or ','
	 after the '('.  */
      found_base_index_form = 0;
      end_of_operand_string = op_string + strlen (op_string);
d3549 4
a3552 3
      --end_of_operand_string;
      if (is_space_char (*end_of_operand_string))
	--end_of_operand_string;
d3554 5
a3558 1
      base_string = end_of_operand_string;
d3560 2
a3561 14
      if (*base_string == ')')
	{
	  unsigned int parens_balanced = 1;
	  /* We've already checked that the number of left & right ()'s are
	     equal, so this loop will not be infinite. */
	  do
	    {
	      base_string--;
	      if (*base_string == ')')
		parens_balanced++;
	      if (*base_string == '(')
		parens_balanced--;
	    }
	  while (parens_balanced);
d3563 4
a3566 3
	  /* If there is a displacement set-up for it to be parsed later. */
	  displacement_string_start = op_string;
	  displacement_string_end = base_string;
d3568 3
a3570 1
	  /* Skip past '(' and whitespace.  */
d3573 1
a3573 1
	    ++base_string;
d3576 1
a3576 19
	      || (allow_naked_reg && i386_is_reg (base_string))
	      || *base_string == ',')
	    found_base_index_form = 1;
	}

      /* If we can't parse a base index register expression, we've found
	 a pure displacement expression.  We set up displacement_string_start
	 and displacement_string_end for the code below. */
      if (!found_base_index_form)
	{
	  displacement_string_start = op_string;
	  displacement_string_end = end_of_operand_string + 1;
	}
      else
	{
	  i.types[this_operand] |= BaseIndex;

	  /* Find base register (if any). */
	  if (*base_string != ',')
d3578 1
a3578 1
	      char *end_op;
d3580 3
a3582 5
	      /* Trim off the closing ')' so that parse_register won't
		 see it.  */
	      END_STRING_AND_SAVE (end_of_operand_string);
	      i.base_reg = parse_register (base_string, &end_op);
	      RESTORE_END_STRING (end_of_operand_string);
d3584 1
a3584 1
	      if (i.base_reg == NULL)
d3587 2
a3588 2
	      base_string = end_op;
	      if (is_space_char (*base_string))
d3590 12
d3604 2
a3605 2
	  /* There may be an index reg or scale factor here.  */
	  if (*base_string == ',')
d3607 5
a3611 2
	      ++base_string;
	      if (is_space_char (*base_string))
d3613 21
d3635 9
a3643 4
	      if (*base_string == REGISTER_PREFIX
		  || (allow_naked_reg && i386_is_reg (base_string)))
		{
		  char *end_op;
d3645 33
a3677 46
		  END_STRING_AND_SAVE (end_of_operand_string);
		  i.index_reg = parse_register (base_string, &end_op);
		  RESTORE_END_STRING (end_of_operand_string);

		  if (i.index_reg == NULL)
		    return 0;

		  base_string = end_op;
		  if (is_space_char (*base_string))
		    ++base_string;
		  if (*base_string == ',')
		    {
		      ++base_string;
		      if (is_space_char (*base_string))
			++base_string;
		    }
		  else if (*base_string != ')' )
		    {
		      as_bad (_("expecting `,' or `)' after index register in `%s'"),
			      operand_string);
		      return 0;
		    }
		}

	      /* Check for scale factor. */
	      if (isdigit ((unsigned char) *base_string))
		{
                  if (!i386_scale (base_string))
                    return 0;

		  ++base_string;
		  if (is_space_char (*base_string))
		    ++base_string;
		  if (*base_string != ')')
		    {
		      as_bad (_("expecting `)' after scale factor in `%s'"),
			      operand_string);
		      return 0;
		    }
		}
	      else if (!i.index_reg)
		{
		  as_bad (_("expecting index register or scale factor after `,'; got '%c'"),
			  *base_string);
		  return 0;
		}
d3679 2
a3680 1
	  else if (*base_string != ')')
d3682 3
a3684 3
	      as_bad (_("expecting `,' or `)' after base register in `%s'"),
		      operand_string);
	      return 0;
d3686 15
a3700 36
	}

      /* If there's an expression beginning the operand, parse it,
	 assuming displacement_string_start and
	 displacement_string_end are meaningful.  */
      if (displacement_string_start != displacement_string_end)
	{
          if (!i386_displacement (displacement_string_start, 
                                  displacement_string_end))
            return 0;
	}

      /* Special case for (%dx) while doing input/output op.  */
      if (i.base_reg
	  && i.base_reg->reg_type == (Reg16 | InOutPortReg)
	  && i.index_reg == 0
	  && i.log2_scale_factor == 0
	  && i.seg[i.mem_operands] == 0
	  && (i.types[this_operand] & Disp) == 0)
	{
	  i.types[this_operand] = InOutPortReg;
	  return 1;
	}
      /* Make sure the memory operand we've been dealt is valid.  */
      if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
	{
	  if ((i.base_reg
	       && ((i.base_reg->reg_type & (Reg16|BaseIndex))
		   != (Reg16|BaseIndex)))
	      || (i.index_reg
		  && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		       != (Reg16|BaseIndex))
		      || ! (i.base_reg
			    && i.base_reg->reg_num < 6
			    && i.index_reg->reg_num >= 6
			    && i.log2_scale_factor == 0))))
d3702 2
a3703 3
	      as_bad (_("`%s' is not a valid %s bit base/index expression"),
		      operand_string, "16");
	      return 0;
d3705 2
a3706 8
	}
      else
	{
	  if ((i.base_reg
	       && (i.base_reg->reg_type & Reg32) == 0)
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg32|BaseIndex))
		      != (Reg32|BaseIndex))))
d3708 3
a3710 3
	      as_bad (_("`%s' is not a valid %s bit base/index expression"),
		      operand_string, "32");
	      return 0;
d3712 13
a3724 12
	}
      i.mem_operands++;
    }
  else
    {				/* it's not a memory operand; argh! */
      as_bad (_("invalid char %s beginning operand %d `%s'"),
	      output_invalid (*op_string),
	      this_operand + 1,
	      op_string);
      return 0;
    }
  return 1;			/* normal return */
d4030 1
a4030 1
 * relocation for this.  The actual sequence of instructions often look 
d4032 1
a4032 1
 * 
d4037 1
a4037 1
 * 
d4047 1
a4047 1
 * 
d4053 1
a4053 1
 * 
d4055 1
a4055 1
 * 
d4057 1
a4057 1
 * we treat operands of this form as not being pcrel since the '.' is 
@


1.10
log
@
* gas/config/tc-i386.c: Fix for immediates and displacements in 16-bit
mode when no insn suffix present, eg. push $0x12345678.  Fix some
compiler warnings.  Disallow immediate jump absolute.
@
text
@d780 2
a781 2
  fprintf (stdout, "    add_number    %d (%x)\n",
	   e->X_add_number, e->X_add_number);
@


1.9
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d952 4
a955 1
int
a1250 1
    expressionS *exp;
d1974 2
d2366 4
a2369 1
			if (i.types[n] & Disp8)
d2371 13
a2383 21
			    insn_size += 1;
			    p = frag_more (1);
			    md_number_to_chars (p,
						(valueT) i.disps[n]->X_add_number,
						1);
			  }
			else if (i.types[n] & Disp16)
			  {
			    insn_size += 2;
			    p = frag_more (2);
			    md_number_to_chars (p,
						(valueT) i.disps[n]->X_add_number,
						2);
			  }
			else
			  {	/* Disp32 */
			    insn_size += 4;
			    p = frag_more (4);
			    md_number_to_chars (p,
						(valueT) i.disps[n]->X_add_number,
						4);
d2385 3
d2420 4
a2423 1
			if (i.types[n] & (Imm8 | Imm8S))
d2425 12
a2436 21
			    insn_size += 1;
			    p = frag_more (1);
			    md_number_to_chars (p,
						(valueT) i.imms[n]->X_add_number,
						1);
			  }
			else if (i.types[n] & Imm16)
			  {
			    insn_size += 2;
			    p = frag_more (2);
			    md_number_to_chars (p,
						(valueT) i.imms[n]->X_add_number,
						2);
			  }
			else
			  {
			    insn_size += 4;
			    p = frag_more (4);
			    md_number_to_chars (p,
						(valueT) i.imms[n]->X_add_number,
						4);
d2438 3
d2615 4
d2620 2
a2621 2
	smallest_imm_type ((long) exp->X_add_number);
  
d3456 5
@


1.8
log
@	* config/tc-i386.c (i386_immediate): Remove unused label
	seg_unimplemented.
@
text
@d1260 3
a1262 3
        const reg_entry *temp_reg;
        expressionS *temp_disp;
        expressionS *temp_imm;
d1264 2
a1265 1
        int xchg1, xchg2;
d2555 2
a2556 1
	  int len, first;
d2785 2
a2786 1
	  int len, first;
d3466 2
a3467 2
      char *displacement_string_start;
      char *displacement_string_end;
d3778 2
a3779 2
     bfd *abfd;
     segT sec;
d3861 2
a3862 2
     fragS *frag;
     symbolS *to_symbol;
d4194 1
a4194 1
     char *arg;
d4280 1
a4280 1
     segT segment;
d4315 1
a4315 1
     int ignore;
d4342 1
a4342 1
     asection *section;
@


1.7
log
@	* config/tc-i386.c (md_apply_fix3): Add default case to switch.
@
text
@a2637 1
    seg_unimplemented:
@


1.6
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d3915 3
@


1.5
log
@
Fiz i386-iaout breakage introduced by last patch.
@
text
@d2466 2
a2467 1
				    && (i.imms[n]->X_op_symbol->sy_value.X_op
d2833 1
a2833 1
          section_symbol(exp->X_add_symbol->bsym->section);
d3793 1
a3793 1
  target_address += fragP->fr_symbol->sy_frag->fr_address;
d3947 1
a3947 1
	      || (fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
d4391 2
a4392 1
  rel->sym_ptr_ptr = &fixp->fx_addsy->bsym;
@


1.4
log
@n
Move bitfield overflow checks to after the md_apply_fix call in
fixup_segment so that md_apply_fix has a chance to modify value.
Handle 8 and 16-bit pcrel relocs for i386.
Prototypes and other minor code cleanups.
@
text
@d3909 1
a3925 1
#if defined (BFD_ASSEMBLER) && !defined (TE_Mach)
@


1.3
log
@
i386 PIII SIMD support, remove ReverseRegRegmem kludge
tidy a few things in i386 intel mode disassembly
@
text
@d3909 15
a3923 2
  if (fixP->fx_r_type == BFD_RELOC_32 && fixP->fx_pcrel)
     fixP->fx_r_type = BFD_RELOC_32_PCREL;
d3930 4
a3933 1
  if (fixP->fx_r_type == BFD_RELOC_32_PCREL && fixP->fx_addsy)
d4033 3
a4035 3
#endif

#endif
a4333 3
#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
#define MAP(SZ,PCREL,TYPE)	case F(SZ,PCREL): code = (TYPE); break

d4354 1
a4354 1
      switch (F (fixp->fx_size, fixp->fx_pcrel))
d4356 24
a4379 14
	  MAP (1, 0, BFD_RELOC_8);
	  MAP (2, 0, BFD_RELOC_16);
	  MAP (4, 0, BFD_RELOC_32);
	  MAP (1, 1, BFD_RELOC_8_PCREL);
	  MAP (2, 1, BFD_RELOC_16_PCREL);
	  MAP (4, 1, BFD_RELOC_32_PCREL);
	default:
	  if (fixp->fx_pcrel)
	    as_bad (_("Can not do %d byte pc-relative relocation"),
		    fixp->fx_size);
	  else
	    as_bad (_("Can not do %d byte relocation"), fixp->fx_size);
	  code = BFD_RELOC_32;
	  break;
a4382 2
#undef MAP
#undef F
d4485 1
a4485 1
#endif /* BFD_ASSEMBLER? */
@


1.2
log
@        * config/tc-i386.c (i386_immediate): Skip whitespace before
        complaining about junk after expression.
        (i386_displacement): Likewise.
@
text
@d743 1
a743 1
	  & (Reg | SReg2 | SReg3 | Control | Debug | Test | RegMMX))
d838 1
d1556 4
a1559 2
		if (i.types[op] & (Reg | RegMMX | Control | Debug | Test
				   | FloatReg | FloatAcc | SReg2 | SReg3))
d1746 1
a1746 1
    if (i.tm.base_opcode == AMD_3DNOW_OPCODE)
d1748 4
a1751 4
	/* These AMD specific instructions have an opcode suffix which
	   is coded in the same place as an 8-bit immediate field
	   would be.  Here we fake an 8-bit immediate operand from the
	   opcode suffix stored in tm.extension_opcode.  */
d1828 3
a1830 7
			   & (Reg
			      | SReg2
			      | SReg3
			      | Control
			      | Debug
			      | Test
			      | RegMMX))
a1833 14
		/* Certain instructions expect the destination to be
		   in the i.rm.reg field.  This is by far the
		   exceptional case.  For these instructions, if the
		   source operand is a register, we must reverse the
		   i.rm.reg and i.rm.regmem fields.  We accomplish
		   this by pretending that the two register operands
		   were given in the reverse order.  */
		if (i.tm.opcode_modifier & ReverseRegRegmem)
		  {
		    const reg_entry *tmp = i.regs[source];
		    i.regs[source] = i.regs[dest];
		    i.regs[dest] = tmp;
		  }

d1835 8
a1842 6
		/* We must be careful to make sure that all
		   segment/control/test/debug/MMX registers go into
		   the i.rm.reg field (despite whether they are
		   source or destination operands). */
		if (i.regs[dest]->reg_type
		    & (SReg2 | SReg3 | Control | Debug | Test | RegMMX))
d1989 3
a1991 2
			& (Reg | SReg2 | SReg3 | Control | Debug
			   | Test | RegMMX))
d1994 3
a1996 2
			   & (Reg | SReg2 | SReg3 | Control | Debug
			      | Test | RegMMX))
@


1.1
log
@Initial revision
@
text
@d2605 1
d2851 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

