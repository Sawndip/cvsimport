head	1.13;
access;
symbols
	binutils-csl-coldfire-4_1-32:1.12
	binutils-csl-sourcerygxx-4_1-32:1.12
	binutils-csl-innovasic-fido-3_4_4-33:1.12
	binutils-csl-sourcerygxx-3_4_4-32:1.11
	binutils-csl-coldfire-4_1-30:1.12
	binutils-csl-sourcerygxx-4_1-30:1.12
	binutils-csl-coldfire-4_1-28:1.12
	binutils-csl-sourcerygxx-4_1-29:1.12
	binutils-csl-sourcerygxx-4_1-28:1.12
	binutils-csl-arm-2006q3-27:1.12
	binutils-csl-sourcerygxx-4_1-27:1.12
	binutils-csl-arm-2006q3-26:1.12
	binutils-csl-sourcerygxx-4_1-26:1.12
	binutils-csl-sourcerygxx-4_1-25:1.12
	binutils-csl-sourcerygxx-4_1-24:1.12
	binutils-csl-sourcerygxx-4_1-23:1.12
	binutils-csl-sourcerygxx-4_1-21:1.12
	binutils-csl-arm-2006q3-21:1.12
	binutils-csl-sourcerygxx-4_1-22:1.12
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.12
	binutils-csl-sourcerygxx-4_1-20:1.12
	binutils-csl-arm-2006q3-19:1.12
	binutils-csl-sourcerygxx-4_1-19:1.12
	binutils-csl-sourcerygxx-4_1-18:1.12
	binutils-csl-renesas-4_1-9:1.12
	binutils-csl-sourcerygxx-3_4_4-25:1.11
	binutils-csl-renesas-4_1-8:1.12
	binutils-csl-renesas-4_1-7:1.12
	binutils-csl-renesas-4_1-6:1.12
	binutils-csl-sourcerygxx-4_1-17:1.12
	binutils-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-15:1.12
	binutils-csl-sourcerygxx-4_1-13:1.12
	binutils-2_17:1.12
	binutils-csl-sourcerygxx-4_1-12:1.12
	binutils-csl-sourcerygxx-3_4_4-21:1.12
	binutils-csl-wrs-linux-3_4_4-24:1.11
	binutils-csl-wrs-linux-3_4_4-23:1.11
	binutils-csl-sourcerygxx-4_1-9:1.12
	binutils-csl-sourcerygxx-4_1-8:1.12
	binutils-csl-sourcerygxx-4_1-7:1.12
	binutils-csl-arm-2006q1-6:1.12
	binutils-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-wrs-linux-3_4_4-22:1.11
	binutils-csl-coldfire-4_1-11:1.12
	binutils-csl-sourcerygxx-3_4_4-19:1.12
	binutils-csl-coldfire-4_1-10:1.12
	binutils-csl-sourcerygxx-4_1-5:1.12
	binutils-csl-sourcerygxx-4_1-4:1.12
	binutils-csl-wrs-linux-3_4_4-21:1.11
	binutils-csl-morpho-4_1-4:1.12
	binutils-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-wrs-linux-3_4_4-20:1.11
	binutils-2_17-branch:1.12.0.4
	binutils-2_17-branchpoint:1.12
	binutils-csl-2_17-branch:1.12.0.2
	binutils-csl-2_17-branchpoint:1.12
	binutils-csl-gxxpro-3_4-branch:1.11.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.11
	binutils-2_16_1:1.11
	binutils-csl-arm-2005q1b:1.11
	binutils-2_16:1.11
	binutils-csl-arm-2005q1a:1.11
	binutils-csl-arm-2005q1-branch:1.11.0.4
	binutils-csl-arm-2005q1-branchpoint:1.11
	binutils-2_16-branch:1.11.0.2
	binutils-2_16-branchpoint:1.11
	csl-arm-2004-q3d:1.9
	csl-arm-2004-q3:1.9
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	binutils-2_15-branch:1.9.0.6
	cagney_bfdfile-20040213-branch:1.9.0.4
	cagney_bfdfile-20040213-branchpoint:1.9
	cagney_bigcore-20040122-branch:1.9.0.2
	cagney_bigcore-20040122-branchpoint:1.9
	csl-arm-2003-q4:1.9
	binutils-2_14:1.7
	binutils-2_14-branch:1.7.0.4
	binutils-2_14-branchpoint:1.7
	binutils-2_13_2_1:1.7
	binutils-2_13_2:1.7
	binutils-2_13_1:1.7
	binutils-2_13:1.7
	binutils-2_13-branchpoint:1.7
	binutils-2_13-branch:1.7.0.2
	binutils-2_12_1:1.6
	binutils-2_12:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.12
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2006.06.01.12.21.05;	author amodra;	state dead;
branches;
next	1.12;

1.12
date	2005.05.05.09.12.53;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.03.11.47.48;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.31.23.18.24;	author bje;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.20.04.12.19;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.20.00.01.55;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.23.08.08.47;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.23.13.03.39;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.25.09.40.12;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.01.19.02.49;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.06.25.17.59.21;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.15.27;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.13
log
@	* config/obj-ieee.c: Delete.
	* config/obj-ieee.h: Delete.
	* Makefile.am (OBJ_FORMATS): Remove ieee.
	(OBJ_FORMAT_CFILES, OBJ_FORMAT_HFILES): Similarly.
	(obj-ieee.o): Remove rule.
	* Makefile.in: Regenerate.
	* configure.in (atof): Remove tahoe.
	(OBJ_MAYBE_IEEE): Don't define.
	* configure: Regenerate.
	* config.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* obj-format for ieee-695 records.
   Copyright 1991, 1992, 1993, 1994, 1997, 2000, 2001, 2002, 2003, 2005
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Created by Steve Chamberlain <steve@@cygnus.com>.  */

/* This will hopefully become the port through which bfd and gas talk,
   for the moment, only ieee is known to work well.  */

#include "bfd.h"
#include "as.h"
#include "subsegs.h"
#include "output-file.h"
#include "frags.h"

bfd *abfd;

/* How many addresses does the .align take?  */

static relax_addressT
relax_align (address, alignment)
     /* Address now.  */
     register relax_addressT address;

     /* Alignment (binary).  */
     register long alignment;
{
  relax_addressT mask;
  relax_addressT new_address;

  mask = ~((~0) << alignment);
  new_address = (address + mask) & (~mask);
  return (new_address - address);
}

/* Calculate the size of the frag chain
   and create a bfd section to contain all of it.  */

static void
size_section (abfd, idx)
     bfd *abfd;
     unsigned int idx;
{
  asection *sec;
  unsigned int size = 0;
  fragS *frag = segment_info[idx].frag_root;

  while (frag)
    {
      if (frag->fr_address != size)
	{
	  printf (_("Out of step\n"));
	  size = frag->fr_address;
	}
      size += frag->fr_fix;
      switch (frag->fr_type)
	{
	case rs_fill:
	case rs_org:
	  size += frag->fr_offset * frag->fr_var;
	  break;
	case rs_align:
	case rs_align_code:
	  {
	    addressT off;

	    off = relax_align (size, frag->fr_offset);
	    if (frag->fr_subtype != 0 && off > frag->fr_subtype)
	      off = 0;
	    size += off;
	  }
	}
      frag = frag->fr_next;
    }
  if (size)
    {
      char *name = segment_info[idx].name;

      if (name == (char *) NULL)
	name = ".data";

      segment_info[idx].user_stuff =
	(char *) (sec = bfd_make_section (abfd, name));
      /* Make it output through itself.  */
      sec->output_section = sec;
      sec->flags |= SEC_HAS_CONTENTS;
      bfd_set_section_size (abfd, sec, size);
    }
}

/* Run through a frag chain and write out the data to go with it.  */

static void
fill_section (abfd, idx)
     bfd *abfd;
     unsigned int idx;
{
  asection *sec = segment_info[idx].user_stuff;

  if (sec)
    {
      fragS *frag = segment_info[idx].frag_root;
      unsigned int offset = 0;
      while (frag)
	{
	  unsigned int fill_size;
	  unsigned int count;
	  switch (frag->fr_type)
	    {
	    case rs_fill:
	    case rs_align:
	    case rs_org:
	      if (frag->fr_fix)
		{
		  bfd_set_section_contents (abfd,
					    sec,
					    frag->fr_literal,
					    frag->fr_address,
					    frag->fr_fix);
		}
	      offset += frag->fr_fix;
	      fill_size = frag->fr_var;
	      if (fill_size)
		{
		  unsigned int off = frag->fr_fix;
		  for (count = frag->fr_offset; count; count--)
		    {
		      bfd_set_section_contents (abfd, sec,
						frag->fr_literal +
						frag->fr_fix,
						frag->fr_address + off,
						fill_size);
		      off += fill_size;
		    }
		}
	      break;
	    default:
	      abort ();
	    }
	  frag = frag->fr_next;
	}
    }
}

/* Count the relocations in a chain.  */

static unsigned int
count_entries_in_chain (idx)
     unsigned int idx;
{
  unsigned int nrelocs;
  fixS *fixup_ptr;

  /* Count the relocations.  */
  fixup_ptr = segment_info[idx].fix_root;
  nrelocs = 0;
  while (fixup_ptr != (fixS *) NULL)
    {
      fixup_ptr = fixup_ptr->fx_next;
      nrelocs++;
    }
  return nrelocs;
}

/* Output all the relocations for a section.  */

void
do_relocs_for (idx)
     unsigned int idx;
{
  unsigned int nrelocs;
  arelent **reloc_ptr_vector;
  arelent *reloc_vector;
  asymbol **ptrs;
  asection *section = (asection *) (segment_info[idx].user_stuff);
  unsigned int i;
  fixS *from;

  if (section)
    {
      nrelocs = count_entries_in_chain (idx);

      reloc_ptr_vector =
	(arelent **) malloc ((nrelocs + 1) * sizeof (arelent *));
      reloc_vector = (arelent *) malloc (nrelocs * sizeof (arelent));
      ptrs = (asymbol **) malloc (nrelocs * sizeof (asymbol *));
      from = segment_info[idx].fix_root;
      for (i = 0; i < nrelocs; i++)
	{
	  arelent *to = reloc_vector + i;
	  asymbol *s;
	  reloc_ptr_vector[i] = to;
	  to->howto = (reloc_howto_type *) (from->fx_r_type);

	  s = &(from->fx_addsy->sy_symbol.sy);
	  to->address = ((char *) (from->fx_frag->fr_address +
				   from->fx_where))
	    - ((char *) (&(from->fx_frag->fr_literal)));
	  to->addend = from->fx_offset;
	  /* If we know the symbol which we want to relocate to, turn
	     this reloaction into a section relative.

	     If this relocation is pcrelative, and we know the
	     destination, we still want to keep the relocation - since
	     the linker might relax some of the bytes, but it stops
	     being pc relative and turns into an absolute relocation.  */
	  if (s)
	    {
	      if ((s->flags & BSF_UNDEFINED) == 0)
		{
		  to->section = s->section;

		  /* We can refer directly to the value field here,
		     rather than using S_GET_VALUE, because this is
		     only called after do_symbols, which sets up the
		     value field.  */
		  to->addend += s->value;

		  to->sym_ptr_ptr = 0;
		  if (to->howto->pcrel_offset)
		    /* This is a pcrel relocation, the addend should
		       be adjusted.  */
		    to->addend -= to->address + 1;
		}
	      else
		{
		  to->section = 0;
		  *ptrs = &(from->fx_addsy->sy_symbol.sy);
		  to->sym_ptr_ptr = ptrs;

		  if (to->howto->pcrel_offset)
		    /* This is a pcrel relocation, the addend should
		       be adjusted.  */
		    to->addend -= to->address - 1;
		}
	    }
	  else
	    to->section = 0;

	  ptrs++;
	  from = from->fx_next;
	}

      /* Attach to the section.  */
      section->orelocation = reloc_ptr_vector;
      section->reloc_count = nrelocs;
      section->flags |= SEC_LOAD;
    }
}

/* Do the symbols.  */

static void
do_symbols (abfd)
     bfd *abfd;
{
  extern symbolS *symbol_rootP;
  symbolS *ptr;
  asymbol **symbol_ptr_vec;
  asymbol *symbol_vec;
  unsigned int count = 0;
  unsigned int index;

  for (ptr = symbol_rootP;
       ptr != (symbolS *) NULL;
       ptr = ptr->sy_next)
    {
      if (SEG_NORMAL (ptr->sy_symbol.seg))
	{
	  ptr->sy_symbol.sy.section =
	    (asection *) (segment_info[ptr->sy_symbol.seg].user_stuff);
	  S_SET_VALUE (ptr, S_GET_VALUE (ptr));
	  if (ptr->sy_symbol.sy.flags == 0)
	    ptr->sy_symbol.sy.flags = BSF_LOCAL;
	}
      else
	{
	  switch (ptr->sy_symbol.seg)
	    {
	    case SEG_ABSOLUTE:
	      ptr->sy_symbol.sy.flags |= BSF_ABSOLUTE;
	      ptr->sy_symbol.sy.section = 0;
	      break;
	    case SEG_UNKNOWN:
	      ptr->sy_symbol.sy.flags = BSF_UNDEFINED;
	      ptr->sy_symbol.sy.section = 0;
	      break;
	    default:
	      abort ();
	    }
	}
      ptr->sy_symbol.sy.value = S_GET_VALUE (ptr);
      count++;
    }
  symbol_ptr_vec = (asymbol **) malloc ((count + 1) * sizeof (asymbol *));

  index = 0;
  for (ptr = symbol_rootP;
       ptr != (symbolS *) NULL;
       ptr = ptr->sy_next)
    {
      symbol_ptr_vec[index] = &(ptr->sy_symbol.sy);
      index++;
    }
  symbol_ptr_vec[index] = 0;
  abfd->outsymbols = symbol_ptr_vec;
  abfd->symcount = count;
}

/* The generic as->bfd converter. Other backends may have special case
   code.  */

void
bfd_as_write_hook ()
{
  int i;

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    size_section (abfd, i);

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    fill_section (abfd, i);

  do_symbols (abfd);

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    do_relocs_for (i);
}

S_SET_SEGMENT (x, y)
     symbolS *x;
     int y;
{
  x->sy_symbol.seg = y;
}

S_IS_DEFINED (x)
     symbolS *x;
{
  if (SEG_NORMAL (x->sy_symbol.seg))
    {
      return 1;
    }
  switch (x->sy_symbol.seg)
    {
    case SEG_UNKNOWN:
      return 0;
    default:
      abort ();
    }
}

S_IS_EXTERNAL (x)
{
  abort ();
}

S_GET_DESC (x)
{
  abort ();
}

S_GET_SEGMENT (x)
     symbolS *x;
{
  return x->sy_symbol.seg;
}

S_SET_EXTERNAL (x)
     symbolS *x;
{
  x->sy_symbol.sy.flags |= BSF_GLOBAL | BSF_EXPORT;
}

S_SET_NAME (x, y)
     symbolS *x;
     char *y;
{
  x->sy_symbol.sy.name = y;
}

S_GET_OTHER (x)
{
  abort ();
}

S_IS_DEBUG (x)
{
  abort ();
}

#ifndef segment_name
char *
segment_name ()
{
  abort ();
}
#endif

void
obj_read_begin_hook ()
{
}

static void
obj_ieee_section (ignore)
     int ignore;
{
  extern char *input_line_pointer;
  extern char is_end_of_line[];
  char *p = input_line_pointer;
  char *s = p;
  int i;

  /* Look up the name, if it doesn't exist, make it.  */
  while (*p && *p != ' ' && *p != ',' && !is_end_of_line[*p])
    {
      p++;
    }
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      if (segment_info[i].hadone)
	{
	  if (strncmp (segment_info[i].name, s, p - s) == 0)
	    goto ok;
	}
      else
	break;
    }
  if (i == SEG_UNKNOWN)
    {
      as_bad (_("too many sections"));
      return;
    }

  segment_info[i].hadone = 1;
  segment_info[i].name = malloc (p - s + 1);
  memcpy (segment_info[i].name, s, p - s);
  segment_info[i].name[p - s] = 0;
ok:
  subseg_set (i, 0);
  while (!is_end_of_line[*p])
    p++;
  input_line_pointer = p;
}

const pseudo_typeS obj_pseudo_table[] =
{
  {"section", obj_ieee_section, 0},
  {"data.b" , cons            , 1},
  {"data.w" , cons            , 2},
  {"data.l" , cons            , 4},
  {"export" , s_globl         , 0},
  {"option" , s_ignore        , 0},
  {"end"    , s_ignore        , 0},
  {"import" , s_ignore        , 0},
  {"sdata"  , stringer        , 0},
  0,
};

void
obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
{
  symbolP->sy_symbol.sy.the_bfd = abfd;
}

#if 1

#ifndef SUB_SEGMENT_ALIGN
#ifdef HANDLE_ALIGN
/* The last subsegment gets an alignment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 2
#endif
#endif

extern void
write_object_file ()
{
  int i;
  struct frchain *frchain_ptr;
  struct frag *frag_ptr;

  abfd = bfd_openw (out_file_name, "ieee");

  if (abfd == 0)
    {
      as_perror (_("FATAL: Can't create %s"), out_file_name);
      exit (EXIT_FAILURE);
    }
  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_h8300, 0);
  subseg_set (1, 0);
  subseg_set (2, 0);
  subseg_set (3, 0);

  /* Run through all the sub-segments and align them up.  Also
     close any open frags.  We tack a .fill onto the end of the
     frag chain so that any .align's size can be worked by looking
     at the next frag.  */
  for (frchain_ptr = frchain_root;
       frchain_ptr != (struct frchain *) NULL;
       frchain_ptr = frchain_ptr->frch_next)
    {
      int alignment;

      subseg_set (frchain_ptr->frch_seg, frchain_ptr->frch_subseg);

      alignment = SUB_SEGMENT_ALIGN (now_seg, frchain_ptr)

#ifdef md_do_align
      md_do_align (alignment, (char *) NULL, 0, 0, alignment_done);
#endif
      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
      else
	frag_align (alignment, 0, 0);

#ifdef md_do_align
    alignment_done:
#endif

      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
    }

  /* Now build one big frag chain for each segment, linked through
     fr_next.  */
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      fragS **prev_frag_ptr_ptr;
      struct frchain *next_frchain_ptr;

      segment_info[i].frag_root = segment_info[i].frchainP->frch_root;
    }

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    relax_segment (segment_info[i].frag_root, i);

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;

  /* Now the addresses of the frags are correct within the segment.  */

  bfd_as_write_hook ();
  bfd_close (abfd);
}

#endif

H_SET_TEXT_SIZE (a, b)
{
  abort ();
}

H_GET_TEXT_SIZE ()
{
  abort ();
}

H_SET_BSS_SIZE ()
{
  abort ();
}

H_SET_STRING_SIZE ()
{
  abort ();
}

H_SET_RELOCATION_SIZE ()
{
  abort ();
}

H_SET_MAGIC_NUMBER ()
{
  abort ();
}

H_GET_FILE_SIZE ()
{
  abort ();
}

H_GET_TEXT_RELOCATION_SIZE ()
{
  abort ();
}
@


1.12
log
@Update the address and phone number of the FSF
@
text
@@


1.11
log
@update copyright dates
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.10
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1997, 2000
@


1.9
log
@	* config/obj-ieee.c: Remove duplicate prototypes.
	* config/tc-h8300.c: Likewise.
@
text
@a211 6
#if 0
	  /* We can't represent complicated things in a reloc yet.  */
	  if (from->fx_addsy == 0 || from->fx_subsy != 0)
	    abort ();
#endif

a557 4
#if 0
      struct frag **head_ptr = segment_info[i].frag_root;
#endif

a558 10
#if 0
      /* I'm not sure what this is for.  */
      for (frchain_ptr = segment_info[i].frchainP->frch_root;
	   frchain_ptr != (struct frchain *) NULL;
	   frchain_ptr = frchain_ptr->frch_next)
	{
	  *head_ptr = frchain_ptr;
	  head_ptr = &frchain_ptr->next;
	}
#endif
@


1.8
log
@	* config/obj-aout.h: Fix comment typos.
	* config/obj-bout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/obj-ieee.c: Likewise.
	* config/obj-som.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/obj-vms.h: Likewise.
@
text
@a469 4
void cons ();
void s_ignore ();

void s_globl ();
@


1.7
log
@	* write.c (size_seg): Check adjustment to last frag.
	(SUB_SEGMENT_ALIGN): If HANDLE_ALIGN defined, pad out last frag to
	section alignment.
	* config/obj-coff.c (SUB_SEGMENT_ALIGN): Likewise.
	* config/obj-ieee.c (SUB_SEGMENT_ALIGN): Likewise.
	(write_object_file): Invoke md_do_align if available, and use
	frag_align_code on text sections.
	* config/obj-vms.h (SUB_SEGMENT_ALIGN): Now two args.
	* config/tc-m88k.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-ppc.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-sh.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-i386.h (SUB_SEGMENT_ALIGN): Likewise.  Define for
	BFD_ASSEMBLER too.
@
text
@d267 1
a267 1
      /* Attatch to the section.  */
d499 1
a499 1
/* The last subsegment gets an aligment corresponding to the alignment
@


1.6
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d496 14
d529 5
d538 1
a538 4
      /* Run through all the sub-segments and align them up.  Also
	 close any open frags.  We tack a .fill onto the end of the
	 frag chain so that any .align's size can be worked by looking
	 at the next frag.  */
d541 13
a553 2
#ifndef SUB_SEGMENT_ALIGN
#define SUB_SEGMENT_ALIGN(SEG) 2
d555 1
a555 1
      frag_align (SUB_SEGMENT_ALIGN (now_seg), 0, 0);
@


1.5
log
@	* config/obj-ieee.c (write_object_file): Set finalize_syms.
	* config/obj-coff.c (write_object_file): Likewise.
	* (size_section): Remove rs_space assert as fr_symbol is no longer
	removed.
	(fill_section): Likewise.
@
text
@d295 1
a295 1
	  S_SET_VALUE (ptr, S_GET_VALUE (ptr) + ptr->sy_frag->fr_address);
@


1.4
log
@Fix copyright notices
@
text
@d561 3
@


1.3
log
@2000-08-01  Kazu Hirata  <kazu@@hxi.com>

	* config/obj-som.c: Fix formatting.
	* config/obj-ieee.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 97, 98, 2000
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1997, 2000
@


1.2
log
@Fix spelling typos.
Remove use of DEFUN().
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 1997, 1998 Free Software Foundation, Inc.
d20 1
a20 1
   02111-1307, USA. */
d22 1
d24 2
a25 10
/*
  created by

  steve chamberlain steve@@cygnus.com
  */

/*
  this will hopefully become the port through which bfd and gas talk,
  for the moment, only ieee is known to work well.
  */
d35 2
a36 1
/* How many addresses does the .align take? */
d39 5
a43 2
     register relax_addressT address;	/* Address now. */
     register long alignment;	/* Alignment (binary). */
d51 4
a54 1
}				/* relax_align() */
a55 2
/* calculate the size of the frag chain and create a bfd section
   to contain all of it */
d58 1
a58 1
     bfd * abfd;
d64 1
d95 1
d97 5
a101 5
	{
	  name = ".data";
	}
      segment_info[idx].user_stuff = (char *) (sec = bfd_make_section (abfd, name));
      /* Make it output through itself */
d108 2
a109 1
/* run through a frag chain and write out the data to go with it */
d112 1
a112 1
     bfd * abfd;
d116 1
d162 1
a162 1
/* Count the relocations in a chain */
d171 1
a171 1
  /* Count the relocations */
d182 2
a183 1
/* output all the relocations for a section */
d195 1
d200 2
a201 1
      reloc_ptr_vector = (arelent **) malloc ((nrelocs + 1) * sizeof (arelent *));
d212 4
a215 2
#if 0	  /* We can't represent complicated things in a reloc yet */
	  if (from->fx_addsy == 0 || from->fx_subsy != 0) abort();
d229 1
a229 1
	     being pc relative and turns into an absolute relocation. */
d244 3
a246 4
		    {
		      /* This is a pcrel relocation, the addend should be adjusted */
		      to->addend -= to->address + 1;
		    }
d255 3
a257 4
		    {
		      /* This is a pcrel relocation, the addend should be adjusted */
		      to->addend -= to->address - 1;
		    }
a258 1

d261 1
a261 3
	    {
	      to->section = 0;
	    }
d267 1
a267 1
      /* attatch to the section */
d274 2
a275 1
/* do the symbols.. */
d278 1
a278 1
     bfd * abfd;
a286 1

d297 1
a297 3
	    {
	      ptr->sy_symbol.sy.flags = BSF_LOCAL;
	    }
d334 1
a334 1
   code */
d342 1
a342 4
    {
      size_section (abfd, i);
    }

a350 1

d437 2
a438 1
  /* Look up the name, if it doesn't exist, make it */
d448 1
a448 4
	    {
	      goto ok;

	    }
a467 1

a469 1

a472 1

d477 8
a484 8
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"export", s_globl, 0},
  {"option", s_ignore, 0},
  {"end", s_ignore, 0},
  {"import", s_ignore, 0},
  {"sdata", stringer, 0},
a485 1

a487 2


a494 4




d519 4
a522 4
      /* Run through all the sub-segments and align them up. Also close any
	 open frags. We tack a .fill onto the end of the frag chain so
	 that any .align's size can be worked by looking at the next
	 frag.  */
d535 1
a535 1
	   fr_next. */
a537 1

d541 3
a543 1
      /*	struct frag **head_ptr = segment_info[i].frag_root;*/
d547 1
a547 1
      /* Im not sure what this is for */
a554 2


d559 1
a559 3
    {
      relax_segment (segment_info[i].frag_root, i);
    }
d561 1
a561 1
  /* Now the addresses of the frags are correct within the segment */
a607 2

/* end of obj-ieee.c */
@


1.1
log
@Initial revision
@
text
@d58 3
a60 3
DEFUN (size_section, (abfd, idx),
       bfd * abfd AND
       unsigned int idx)
d109 3
a111 3
DEFUN (fill_section, (abfd, idx),
       bfd * abfd AND
       unsigned int idx)
d162 2
a163 2
DEFUN (count_entries_in_chain, (idx),
       unsigned int idx)
d181 2
a182 2
DEFUN (do_relocs_for, (idx),
       unsigned int idx)
d273 2
a274 2
DEFUN (do_symbols, (abfd),
       bfd * abfd)
d336 1
a336 1
DEFUN_VOID (bfd_as_write_hook)
d512 1
a512 1
DEFUN_VOID (write_object_file)
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

