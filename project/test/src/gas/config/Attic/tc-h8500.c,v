head	1.22;
access;
symbols
	binutils-csl-sourcerygxx-3_4_4-32:1.18
	binutils-csl-sourcerygxx-3_4_4-25:1.18
	binutils-csl-wrs-linux-3_4_4-24:1.18
	binutils-csl-wrs-linux-3_4_4-23:1.18
	binutils-csl-wrs-linux-3_4_4-22:1.18
	binutils-csl-wrs-linux-3_4_4-21:1.18
	binutils-csl-wrs-linux-3_4_4-20:1.18
	binutils-csl-gxxpro-3_4-branch:1.18.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.18
	binutils-2_16_1:1.18
	binutils-csl-arm-2005q1b:1.18
	binutils-2_16:1.18
	binutils-csl-arm-2005q1a:1.18
	binutils-csl-arm-2005q1-branch:1.18.0.4
	binutils-csl-arm-2005q1-branchpoint:1.18
	binutils-2_16-branch:1.18.0.2
	binutils-2_16-branchpoint:1.18
	csl-arm-2004-q3d:1.16
	csl-arm-2004-q3:1.16
	binutils-2_15:1.16
	binutils-2_15-branchpoint:1.16
	csl-arm-2004-q1a:1.16
	csl-arm-2004-q1:1.16
	binutils-2_15-branch:1.16.0.8
	cagney_bfdfile-20040213-branch:1.16.0.6
	cagney_bfdfile-20040213-branchpoint:1.16
	cagney_bigcore-20040122-branch:1.16.0.4
	cagney_bigcore-20040122-branchpoint:1.16
	csl-arm-2003-q4:1.16
	binutils-2_14:1.16
	binutils-2_14-branch:1.16.0.2
	binutils-2_14-branchpoint:1.16
	binutils-2_13_2_1:1.14
	binutils-2_13_2:1.14
	binutils-2_13_1:1.14
	binutils-2_13:1.14
	binutils-2_13-branchpoint:1.14
	binutils-2_13-branch:1.14.0.2
	binutils-2_12_1:1.13
	binutils-2_12:1.13
	binutils-2_12-branch:1.13.0.2
	binutils-2_12-branchpoint:1.13
	cygnus_cvs_20020108_pre:1.13
	binutils-2_11_2:1.7.2.2
	binutils-2_11_1:1.7.2.2
	binutils-2_11:1.7
	x86_64versiong3:1.7
	binutils-2_11-branch:1.7.0.2
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.21
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2005.08.11.01.25.23;	author amodra;	state dead;
branches;
next	1.21;

1.21
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.05.09.12.56;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.24.20.40.26;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.31.23.18.27;	author bje;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.15.08.51.53;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.12.22.34.05;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.15.21.28.55;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.19.05.33.22;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.10.11.32.51;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.05.04.21.36;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.30.00.06.10;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.16.00.56.47;	author kazu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.07.10.18.59.26;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.24.11.51.53;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.24.08.07.01;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.02.02.52.10;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;

1.7.2.1
date	2001.06.07.03.15.28;	author amodra;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.06.11.10.04.47;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.22
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* tc-h8500.c -- Assemble code for the Renesas H8/500
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003, 2005
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#include <stdio.h>
#include "as.h"
#include "bfd.h"
#include "subsegs.h"
#define DEFINE_TABLE
#define ASSEMBLER_TABLE
#include "opcodes/h8500-opc.h"
#include "safe-ctype.h"

const char comment_chars[]        = "!";
const char line_separator_chars[] = ";";
const char line_comment_chars[]   = "!#";

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  {"int", cons, 2},
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"form", listing_psize, 0},
  {"heading", listing_title, 0},
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
  {"program", s_ignore, 0},
  {0, 0, 0}
};

const int md_reloc_size;

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

#define C(a,b)                     ENCODE_RELAX(a, b)
#define ENCODE_RELAX(what, length) (((what) << 2) + (length))

#define GET_WHAT(x) ((x >> 2))

#define BYTE_DISP       1
#define WORD_DISP       2
#define UNDEF_BYTE_DISP 0
#define UNDEF_WORD_DISP 3

#define BRANCH          1
#define SCB_F           2
#define SCB_TST         3
#define END             4

#define BYTE_F        127
#define BYTE_B       -126
#define WORD_F      32767
#define WORD_B      32768

relax_typeS md_relax_table[C (END, 0)] =
{
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },

  /* BRANCH */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  2, C (BRANCH, WORD_DISP) },
  { WORD_F, WORD_B,  3, 0 },
  { 0,      0,       3, 0 },

  /* SCB_F */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  3, C (SCB_F, WORD_DISP) },
  { WORD_F, WORD_B,  8, 0 },
  { 0,      0,       8, 0 },

  /* SCB_TST */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  3, C (SCB_TST, WORD_DISP) },
  { WORD_F, WORD_B, 10, 0 },
  { 0,      0,      10, 0 }

};

static struct hash_control *opcode_hash_control;	/* Opcode mnemonics.  */

/* This function is called once, at assembler startup time.  This should
   set up all the tables, etc. that the MD part of the assembler needs.  */

void
md_begin (void)
{
  const h8500_opcode_info *opcode;
  char prev_buffer[100];
  int idx = 0;

  opcode_hash_control = hash_new ();
  prev_buffer[0] = 0;

  /* Insert unique names into hash table.  */
  for (opcode = h8500_table; opcode->name; opcode++)
    {
      if (idx != opcode->idx)
	{
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	  idx++;
	}
    }
}

static int rn;			/* Register number used by RN.  */
static int rs;			/* Register number used by RS.  */
static int rd;			/* Register number used by RD.  */
static int crb;			/* Byte size cr.  */
static int crw;			/* Word sized cr.  */
static int cr;			/* Unknown size cr.  */

static expressionS displacement;/* Displacement expression.  */
static int immediate_inpage;
static expressionS immediate;	/* Immediate expression.  */
static expressionS absolute;	/* Absolute expression.  */

typedef struct
{
  int type;
  unsigned int reg;
  expressionS exp;
  int page;
}

h8500_operand_info;

/* Try to parse a reg name.  Return the number of chars consumed.  */

static int parse_reg (char *, int *, unsigned int *);

static int
parse_reg (char *src, int *mode, unsigned int *reg)
{
  char *end;
  int len;

  /* Cribbed from get_symbol_end().  */
  if (!is_name_beginner (*src) || *src == '\001')
    return 0;
  end = src + 1;
  while (is_part_of_name (*end) || *end == '\001')
    end++;
  len = end - src;

  if (len == 2 && src[0] == 'r')
    {
      if (src[1] >= '0' && src[1] <= '7')
	{
	  *mode = RN;
	  *reg = (src[1] - '0');
	  return len;
	}
    }
  if (len == 2 && src[0] == 's' && src[1] == 'p')
    {
      *mode = RN;
      *reg = 7;
      return len;
    }
  if (len == 3 && src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
    {
      *mode = CRB;
      *reg = 1;
      return len;
    }
  if (len == 2 && src[0] == 's' && src[1] == 'r')
    {
      *mode = CRW;
      *reg = 0;
      return len;
    }
  if (len == 2 && src[0] == 'b' && src[1] == 'r')
    {
      *mode = CRB;
      *reg = 3;
      return len;
    }
  if (len == 2 && src[0] == 'e' && src[1] == 'p')
    {
      *mode = CRB;
      *reg = 4;
      return len;
    }
  if (len == 2 && src[0] == 'd' && src[1] == 'p')
    {
      *mode = CRB;
      *reg = 5;
      return len;
    }
  if (len == 2 && src[0] == 't' && src[1] == 'p')
    {
      *mode = CRB;
      *reg = 7;
      return len;
    }
  if (len == 2 && src[0] == 'f' && src[1] == 'p')
    {
      *mode = RN;
      *reg = 6;
      return len;
    }
  return 0;
}

static char *
parse_exp (char *s, expressionS *op, int *page)
{
  char *save;
  char *new;

  save = input_line_pointer;

  *page = 0;
  if (s[0] == '%')
    {
      if (s[1] == 'p' && s[2] == 'a' && s[3] == 'g' && s[4] == 'e')
	{
	  s += 5;
	  *page = 'p';
	}
      if (s[1] == 'h' && s[2] == 'i' && s[3] == '1' && s[4] == '6')
	{
	  s += 5;
	  *page = 'h';
	}
      else if (s[1] == 'o' && s[2] == 'f' && s[3] == 'f')
	{
	  s += 4;
	  *page = 'o';
	}
    }

  input_line_pointer = s;

  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

typedef enum
{
  exp_signed, exp_unsigned, exp_sandu
} sign_type;

static char *
skip_colonthing (sign_type sign,
		 char *ptr,
		 h8500_operand_info *exp,
		 int def,
		 int size8,
		 int size16,
		 int size24)
{
  ptr = parse_exp (ptr, &exp->exp, &exp->page);
  if (*ptr == ':')
    {
      ptr++;
      if (*ptr == '8')
	{
	  ptr++;
	  exp->type = size8;
	}
      else if (ptr[0] == '1' && ptr[1] == '6')
	{
	  ptr += 2;
	  exp->type = size16;
	}
      else if (ptr[0] == '2' && ptr[1] == '4')
	{
	  if (!size24)
	    {
	      as_bad (_(":24 not valid for this opcode"));
	    }
	  ptr += 2;
	  exp->type = size24;
	}
      else
	{
	  as_bad (_("expect :8,:16 or :24"));
	  exp->type = size16;
	}
    }
  else
    {
      if (exp->page == 'p')
	exp->type = IMM8;
      else if (exp->page == 'h')
	exp->type = IMM16;
      else
	{
	  /* Let's work out the size from the context.  */
	  int n = exp->exp.X_add_number;

	  if (size8
	      && exp->exp.X_op == O_constant
	      && ((sign == exp_signed && (n >= -128 && n <= 127))
		  || (sign == exp_unsigned && (n >= 0 && (n <= 255)))
		  || (sign == exp_sandu && (n >= -128 && (n <= 255)))))
	    exp->type = size8;
	  else
	    exp->type = def;
	}
    }
  return ptr;
}

static int
parse_reglist (char *src, h8500_operand_info *op)
{
  int mode;
  unsigned int rn;
  int mask = 0;
  unsigned int rm;
  int idx = 1;

  /* Skip (.  */  
  while (src[idx] && src[idx] != ')')
    {
      int done = parse_reg (src + idx, &mode, &rn);

      if (done)
	{
	  idx += done;
	  mask |= 1 << rn;
	}
      else
	{
	  as_bad (_("syntax error in reg list"));
	  return 0;
	}

      if (src[idx] == '-')
	{
	  idx++;
	  done = parse_reg (src + idx, &mode, &rm);
	  if (done)
	    {
	      idx += done;
	      while (rn <= rm)
		{
		  mask |= 1 << rn;
		  rn++;
		}
	    }
	  else
	    as_bad (_("missing final register in range"));
	}

      if (src[idx] == ',')
	idx++;
    }
  idx++;
  op->exp.X_add_symbol = 0;
  op->exp.X_op_symbol = 0;
  op->exp.X_add_number = mask;
  op->exp.X_op = O_constant;
  op->exp.X_unsigned = 1;
  op->type = IMM8;
  return idx;
}

/* The many forms of operand:

   Rn			Register direct
   @@Rn			Register indirect
   @@(disp[:size], Rn)	Register indirect with displacement
   @@Rn+
   @@-Rn
   @@aa[:size]		absolute
   #xx[:size]		immediate data.  */

static void
get_operand (char **ptr,
	     h8500_operand_info *op,
	     char ispage)
{
  char *src = *ptr;
  int mode;
  unsigned int num;
  unsigned int len;

  op->page = 0;
  if (src[0] == '(' && src[1] == 'r')
    {
      /* This is a register list */
      *ptr = src + parse_reglist (src, op);
      return;
    }

  len = parse_reg (src, &op->type, &op->reg);

  if (len)
    {
      *ptr = src + len;
      return;
    }

  if (*src == '@@')
    {
      src++;
      if (*src == '-')
	{
	  src++;
	  len = parse_reg (src, &mode, &num);
	  if (len == 0)
	    {
	      /* Oops, not a reg after all, must be ordinary exp */
	      src--;
	      /* must be a symbol */
	      *ptr = skip_colonthing (exp_unsigned, src,
				      op, ABS16, ABS8, ABS16, ABS24);
	      return;
	    }

	  op->type = RNDEC;
	  op->reg = num;
	  *ptr = src + len;
	  return;
	}
      if (*src == '(')
	{
	  /* Disp */
	  src++;

	  src = skip_colonthing (exp_signed, src,
				 op, RNIND_D16, RNIND_D8, RNIND_D16, 0);

	  if (*src != ',')
	    {
	      as_bad (_("expected @@(exp, Rn)"));
	      return;
	    }
	  src++;
	  len = parse_reg (src, &mode, &op->reg);
	  if (len == 0 || mode != RN)
	    {
	      as_bad (_("expected @@(exp, Rn)"));
	      return;
	    }
	  src += len;
	  if (*src != ')')
	    {
	      as_bad (_("expected @@(exp, Rn)"));
	      return;
	    }
	  *ptr = src + 1;
	  return;
	}
      len = parse_reg (src, &mode, &num);

      if (len)
	{
	  src += len;
	  if (*src == '+')
	    {
	      src++;
	      if (mode != RN)
		{
		  as_bad (_("@@Rn+ needs word register"));
		  return;
		}
	      op->type = RNINC;
	      op->reg = num;
	      *ptr = src;
	      return;
	    }
	  if (mode != RN)
	    {
	      as_bad (_("@@Rn needs word register"));
	      return;
	    }
	  op->type = RNIND;
	  op->reg = num;
	  *ptr = src;
	  return;
	}
      else
	{
	  /* must be a symbol */
	  *ptr =
	    skip_colonthing (exp_unsigned, src, op,
			     ispage ? ABS24 : ABS16, ABS8, ABS16, ABS24);
	  return;
	}
    }

  if (*src == '#')
    {
      src++;
      *ptr = skip_colonthing (exp_sandu, src, op, IMM16, IMM8, IMM16, ABS24);
      return;
    }
  else
    *ptr = skip_colonthing (exp_signed, src, op,
			    ispage ? ABS24 : PCREL8, PCREL8, PCREL16, ABS24);
}

static char *
get_operands (h8500_opcode_info *info,
	      char *args,
	      h8500_operand_info *operand)
{
  char *ptr = args;

  switch (info->nargs)
    {
    case 0:
      operand[0].type = 0;
      operand[1].type = 0;
      break;

    case 1:
      ptr++;
      get_operand (&ptr, operand + 0, info->name[0] == 'p');
      operand[1].type = 0;
      break;

    case 2:
      ptr++;
      get_operand (&ptr, operand + 0, 0);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 0);
      break;

    default:
      abort ();
    }

  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

int pcrel8;			/* Set when we've seen a pcrel operand.  */

static h8500_opcode_info *
get_specific (h8500_opcode_info *opcode,
	      h8500_operand_info *operands)
{
  h8500_opcode_info *this_try = opcode;
  int found = 0;
  unsigned int noperands = opcode->nargs;
  int this_index = opcode->idx;

  while (this_index == opcode->idx && !found)
    {
      unsigned int i;

      this_try = opcode++;

      /* Look at both operands needed by the opcodes and provided by
	 the user.  */
      for (i = 0; i < noperands; i++)
	{
	  h8500_operand_info *user = operands + i;

	  switch (this_try->arg_type[i])
	    {
	    case FPIND_D8:
	      /* Opcode needs (disp:8,fp).  */
	      if (user->type == RNIND_D8 && user->reg == 6)
		{
		  displacement = user->exp;
		  continue;
		}
	      break;
	    case RDIND_D16:
	      if (user->type == RNIND_D16)
		{
		  displacement = user->exp;
		  rd = user->reg;
		  continue;
		}
	      break;
	    case RDIND_D8:
	      if (user->type == RNIND_D8)
		{
		  displacement = user->exp;
		  rd = user->reg;
		  continue;
		}
	      break;
	    case RNIND_D16:
	    case RNIND_D8:
	      if (user->type == this_try->arg_type[i])
		{
		  displacement = user->exp;
		  rn = user->reg;
		  continue;
		}
	      break;

	    case SPDEC:
	      if (user->type == RNDEC && user->reg == 7)
		continue;
	      break;

	    case SPINC:
	      if (user->type == RNINC && user->reg == 7)
		continue;
	      break;

	    case ABS16:
	      if (user->type == ABS16)
		{
		  absolute = user->exp;
		  continue;
		}
	      break;
	    case ABS8:
	      if (user->type == ABS8)
		{
		  absolute = user->exp;
		  continue;
		}
	      break;
	    case ABS24:
	      if (user->type == ABS24)
		{
		  absolute = user->exp;
		  continue;
		}
	      break;

	    case CRB:
	      if ((user->type == CRB || user->type == CR) && user->reg != 0)
		{
		  crb = user->reg;
		  continue;
		}
	      break;
	    case CRW:
	      if ((user->type == CRW || user->type == CR) && user->reg == 0)
		{
		  crw = user->reg;
		  continue;
		}
	      break;
	    case DISP16:
	      if (user->type == DISP16)
		{
		  displacement = user->exp;
		  continue;
		}
	      break;
	    case DISP8:
	      if (user->type == DISP8)
		{
		  displacement = user->exp;
		  continue;
		}
	      break;
	    case FP:
	      if (user->type == RN && user->reg == 6)
		continue;
	      break;

	    case PCREL16:
	      if (user->type == PCREL16)
		{
		  displacement = user->exp;
		  continue;
		}
	      break;
	    case PCREL8:
	      if (user->type == PCREL8)
		{
		  displacement = user->exp;
		  pcrel8 = 1;
		  continue;
		}
	      break;

	    case IMM16:
	      if (user->type == IMM16
		  || user->type == IMM8)
		{
		  immediate_inpage = user->page;
		  immediate = user->exp;
		  continue;
		}
	      break;
	    case RLIST:
	    case IMM8:
	      if (user->type == IMM8)
		{
		  immediate_inpage = user->page;
		  immediate = user->exp;
		  continue;
		}
	      break;
	    case IMM4:
	      if (user->type == IMM8)
		{
		  immediate_inpage = user->page;
		  immediate = user->exp;
		  continue;
		}
	      break;
	    case QIM:
	      if (user->type == IMM8
		  && user->exp.X_op == O_constant
		  && (user->exp.X_add_number == -2
		   || user->exp.X_add_number == -1
		   || user->exp.X_add_number == 1
		   || user->exp.X_add_number == 2))
		{
		  immediate_inpage = user->page;
		  immediate = user->exp;
		  continue;
		}
	      break;
	    case RD:
	      if (user->type == RN)
		{
		  rd = user->reg;
		  continue;
		}
	      break;
	    case RS:
	      if (user->type == RN)
		{
		  rs = user->reg;
		  continue;
		}
	      break;
	    case RDIND:
	      if (user->type == RNIND)
		{
		  rd = user->reg;
		  continue;

		}
	      break;
	    case RNINC:
	    case RNIND:
	    case RNDEC:
	    case RN:
	      if (user->type == this_try->arg_type[i])
		{
		  rn = user->reg;
		  continue;
		}
	      break;
	    case SP:
	      if (user->type == RN && user->reg == 7)
		continue;
	      break;
	    default:
	      printf (_("unhandled %d\n"), this_try->arg_type[i]);
	      break;
	    }

	  /* If we get here this didn't work out.  */
	  goto fail;
	}
      found = 1;
    fail:;

    }

  if (found)
    return this_try;
  else
    return 0;
}

static int
check (expressionS *operand,
       int low,
       int high)
{
  if (operand->X_op != O_constant
      || operand->X_add_number < low
      || operand->X_add_number > high)
    as_bad (_("operand must be absolute in range %d..%d"), low, high);

  return operand->X_add_number;
}
       
static void
insert (char *output, int index, expressionS *exp, int reloc, int pcrel)
{
  fix_new_exp (frag_now,
	       output - frag_now->fr_literal + index,
	       4,	       	/* Always say size is 4, but we know better.  */
	       exp, pcrel, reloc);
}

static void
build_relaxable_instruction (h8500_opcode_info *opcode,
			     h8500_operand_info *operand ATTRIBUTE_UNUSED)
{
  /* All relaxable instructions start life as two bytes but can become
     three bytes long if a lonely branch and up to 9 bytes if long
     scb.  */
  char *p;
  int len;
  int type;

  if (opcode->bytes[0].contents == 0x01)
    type = SCB_F;
  else if (opcode->bytes[0].contents == 0x06
	   || opcode->bytes[0].contents == 0x07)
    type = SCB_TST;
  else
    type = BRANCH;

  p = frag_var (rs_machine_dependent,
		md_relax_table[C (type, WORD_DISP)].rlx_length,
		len = md_relax_table[C (type, BYTE_DISP)].rlx_length,
		C (type, UNDEF_BYTE_DISP),
		displacement.X_add_symbol,
		displacement.X_add_number,
		0);

  p[0] = opcode->bytes[0].contents;
  if (type != BRANCH)
    p[1] = opcode->bytes[1].contents | rs;
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static void
build_bytes (h8500_opcode_info *opcode, h8500_operand_info *operand)
{
  int index;

  if (pcrel8)
    {
      pcrel8 = 0;
      build_relaxable_instruction (opcode, operand);
    }
  else
    {
      char *output = frag_more (opcode->length);

      memset (output, 0, opcode->length);
      for (index = 0; index < opcode->length; index++)
	{
	  output[index] = opcode->bytes[index].contents;

	  switch (opcode->bytes[index].insert)
	    {
	    default:
	      printf (_("failed for %d\n"), opcode->bytes[index].insert);
	      break;
	    case 0:
	      break;
	    case RN:
	      output[index] |= rn;
	      break;
	    case RD:
	    case RDIND:
	      output[index] |= rd;
	      break;
	    case RS:
	      output[index] |= rs;
	      break;
	    case DISP16:
	      insert (output, index, &displacement, R_H8500_IMM16, 0);
	      index++;
	      break;
	    case DISP8:
	    case FPIND_D8:
	      insert (output, index, &displacement, R_H8500_IMM8, 0);
	      break;
	    case IMM16:
	      {
		int p;

		switch (immediate_inpage)
		  {
		  case 'p':
		    p = R_H8500_HIGH16;
		    break;
		  case 'h':
		    p = R_H8500_HIGH16;
		    break;
		  default:
		    p = R_H8500_IMM16;
		    break;
		  }
		insert (output, index, &immediate, p, 0);
	      }
	      index++;
	      break;
	    case RLIST:
	    case IMM8:
	      if (immediate_inpage)
		insert (output, index, &immediate, R_H8500_HIGH8, 0);
	      else
		insert (output, index, &immediate, R_H8500_IMM8, 0);
	      break;
	    case PCREL16:
	      insert (output, index, &displacement, R_H8500_PCREL16, 1);
	      index++;
	      break;
	    case PCREL8:
	      insert (output, index, &displacement, R_H8500_PCREL8, 1);
	      break;
	    case IMM4:
	      output[index] |= check (&immediate, 0, 15);
	      break;
	    case CR:
	      output[index] |= cr;
	      if (cr == 0)
		output[0] |= 0x8;
	      else
		output[0] &= ~0x8;
	      break;
	    case CRB:
	      output[index] |= crb;
	      output[0] &= ~0x8;
	      break;
	    case CRW:
	      output[index] |= crw;
	      output[0] |= 0x8;
	      break;
	    case ABS24:
	      insert (output, index, &absolute, R_H8500_IMM24, 0);
	      index += 2;
	      break;
	    case ABS16:
	      insert (output, index, &absolute, R_H8500_IMM16, 0);
	      index++;
	      break;
	    case ABS8:
	      insert (output, index, &absolute, R_H8500_IMM8, 0);
	      break;
	    case QIM:
	      switch (immediate.X_add_number)
		{
		case -2:
		  output[index] |= 0x5;
		  break;
		case -1:
		  output[index] |= 0x4;
		  break;
		case 1:
		  output[index] |= 0;
		  break;
		case 2:
		  output[index] |= 1;
		  break;
		}
	      break;
	    }
	}
    }
}

/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char *str)
{
  char *op_start;
  char *op_end;
  h8500_operand_info operand[2];
  h8500_opcode_info *opcode;
  h8500_opcode_info *prev_opcode;
  char name[11];

  int nlen = 0;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.  */
  for (op_start = op_end = str;
       !is_end_of_line[(unsigned char) *op_end] && *op_end != ' ';
       op_end++)
    if (nlen < 10)
      name[nlen++] = *op_end;

  name[nlen] = 0;

  if (op_end == op_start)
    as_bad (_("can't find opcode "));

  opcode = (h8500_opcode_info *) hash_find (opcode_hash_control, name);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  get_operands (opcode, op_end, operand);
  prev_opcode = opcode;

  opcode = get_specific (opcode, operand);

  if (opcode == 0)
    {
      /* Couldn't find an opcode which matched the operands.  */
      char *where = frag_more (2);

      where[0] = 0x0;
      where[1] = 0x0;
      as_bad (_("invalid operands for opcode"));
      return;
    }

  build_bytes (opcode, operand);
}

void
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}

void
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_headers_hook \n"));
}

/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

const char *md_shortopts = "";
struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
}

static void
wordify_scb (char *buffer, int *disp_size, int *inst_size)
{
  int rn = buffer[1] & 0x7;

  switch (buffer[0])
    {
    case 0x0e:			/* BSR */
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2a:
    case 0x2b:
    case 0x2c:
    case 0x2d:
    case 0x2e:
    case 0x2f:
      buffer[0] |= 0x10;
      buffer[1] = 0;
      buffer[2] = 0;
      *disp_size = 2;
      *inst_size = 1;
      return;
    default:
      abort ();

    case 0x01:
      *inst_size = 6;
      *disp_size = 2;
      break;
    case 0x06:
      *inst_size = 8;
      *disp_size = 2;

      *buffer++ = 0x26;		/* bne + 8 */
      *buffer++ = 0x08;
      break;
    case 0x07:
      *inst_size = 8;
      *disp_size = 2;
      *buffer++ = 0x27;		/* bne + 8 */
      *buffer++ = 0x08;
      break;

    }
  *buffer++ = 0xa8 | rn;	/* addq -1,rn */
  *buffer++ = 0x0c;
  *buffer++ = 0x04;		/* cmp #0xff:8, rn */
  *buffer++ = 0xff;
  *buffer++ = 0x70 | rn;
  *buffer++ = 0x36;		/* bne ...  */
  *buffer++ = 0;
  *buffer++ = 0;
}

/* Called after relaxing, change the frags so they know how big they
   are.  */

void
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED,
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  int disp_size = 0;
  int inst_size = 0;
  char *buffer = fragP->fr_fix + fragP->fr_literal;

  switch (fragP->fr_subtype)
    {
    case C (BRANCH, BYTE_DISP):
      disp_size = 1;
      inst_size = 1;
      break;

    case C (SCB_F, BYTE_DISP):
    case C (SCB_TST, BYTE_DISP):
      disp_size = 1;
      inst_size = 2;
      break;

      /* Branches to a known 16 bit displacement.  */

      /* Turn on the 16bit bit.  */
    case C (BRANCH, WORD_DISP):
    case C (SCB_F, WORD_DISP):
    case C (SCB_TST, WORD_DISP):
      wordify_scb (buffer, &disp_size, &inst_size);
      break;

    case C (BRANCH, UNDEF_WORD_DISP):
    case C (SCB_F, UNDEF_WORD_DISP):
    case C (SCB_TST, UNDEF_WORD_DISP):
      /* This tried to be relaxed, but didn't manage it, it now needs
	 a fix.  */
      wordify_scb (buffer, &disp_size, &inst_size);

      /* Make a reloc */
      fix_new (fragP,
	       fragP->fr_fix + inst_size,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       R_H8500_PCREL16);

      fragP->fr_fix += disp_size + inst_size;
      return;
      break;
    default:
      abort ();
    }
  if (inst_size)
    {
      /* Get the address of the end of the instruction.  */
      int next_inst = fragP->fr_fix + fragP->fr_address + disp_size + inst_size;
      int targ_addr = (S_GET_VALUE (fragP->fr_symbol) +
		       fragP->fr_offset);
      int disp = targ_addr - next_inst;

      md_number_to_chars (buffer + inst_size, disp, disp_size);
      fragP->fr_fix += disp_size + inst_size;
    }
}

valueT
md_section_align (segT seg, valueT size)
{
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
}

void
md_apply_fix (fixS *fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
{
  long val = * (long *) valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  if (fixP->fx_r_type == 0)
    fixP->fx_r_type = fixP->fx_size == 4 ? R_H8500_IMM32 : R_H8500_IMM16;

  switch (fixP->fx_r_type)
    {
    case R_H8500_IMM8:
    case R_H8500_PCREL8:
      *buf++ = val;
      break;
    case R_H8500_IMM16:
    case R_H8500_LOW16:
    case R_H8500_PCREL16:
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    case R_H8500_HIGH8:
      *buf++ = val >> 16;
      break;
    case R_H8500_HIGH16:
      *buf++ = val >> 24;
      *buf++ = val >> 16;
      break;
    case R_H8500_IMM24:
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    case R_H8500_IMM32:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Called just before address relaxation, return the length
   by which a fragment must grow to reach it's destination.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment_type)
{
  int what;

  switch (fragP->fr_subtype)
    {
    default:
      abort ();

    case C (BRANCH, UNDEF_BYTE_DISP):
    case C (SCB_F, UNDEF_BYTE_DISP):
    case C (SCB_TST, UNDEF_BYTE_DISP):
      what = GET_WHAT (fragP->fr_subtype);
      /* Used to be a branch to somewhere which was unknown.  */
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  /* Got a symbol and it's defined in this segment, become byte
	     sized - maybe it will fix up.  */
	  fragP->fr_subtype = C (what, BYTE_DISP);
	}
      else
	/* Its got a segment, but its not ours, so it will always be
	   long.  */
	fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
      break;

    case C (BRANCH, BYTE_DISP):
    case C (BRANCH, WORD_DISP):
    case C (BRANCH, UNDEF_WORD_DISP):
    case C (SCB_F, BYTE_DISP):
    case C (SCB_F, WORD_DISP):
    case C (SCB_F, UNDEF_WORD_DISP):
    case C (SCB_TST, BYTE_DISP):
    case C (SCB_TST, WORD_DISP):
    case C (SCB_TST, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
    }

  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Put number into target byte order.  */

void
md_number_to_chars (char *ptr, valueT use, int nbytes)
{
  number_to_chars_bigendian (ptr, use, nbytes);
}

long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

void
tc_coff_symbol_emit_hook (symbolS *ignore ATTRIBUTE_UNUSED)
{
}

short
tc_coff_fix2rtype (fixS *fix_ptr)
{
  if (fix_ptr->fx_r_type == RELOC_32)
    {
      /* Cons likes to create reloc32's whatever the size of the reloc.  */
      switch (fix_ptr->fx_size)
	{
	case 2:
	  return R_H8500_IMM16;
	  break;
	case 1:
	  return R_H8500_IMM8;
	  break;
	default:
	  abort ();
	}
    }
  return fix_ptr->fx_r_type;
}

void
tc_reloc_mangle (fixS *fix_ptr,
		 struct internal_reloc *intr,
		 bfd_vma base)
{
  symbolS *symbol_ptr;

  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it */
  if (fix_ptr->fx_r_type == RELOC_32)
    {
      /* Cons likes to create reloc32's whatever the size of the reloc.  */
      switch (fix_ptr->fx_size)
	{
	case 2:
	  intr->r_type = R_IMM16;
	  break;
	case 1:
	  intr->r_type = R_IMM8;
	  break;
	default:
	  abort ();
	}
    }
  else
    intr->r_type = fix_ptr->fx_r_type;

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  /* Turn the segment of the symbol into an offset.  */
  if (symbol_ptr)
    {
      symbolS *dot;

      dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
      if (dot)
	{
	  intr->r_offset += S_GET_VALUE (symbol_ptr);
	  intr->r_symndx = dot->sy_number;
	}
      else
	intr->r_symndx = symbol_ptr->sy_number;
    }
  else
    intr->r_symndx = -1;
}

int
start_label (char *ptr)
{
  /* Check for :s.w */
  if (ISALPHA (ptr[1]) && ptr[2] == '.')
    return 0;
  /* Check for :s */
  if (ISALPHA (ptr[1]) && !ISALPHA (ptr[2]))
    return 0;
  return 1;
}

int
tc_coff_sizemachdep (fragS *frag)
{
  return md_relax_table[frag->fr_subtype].rlx_length;
}
@


1.21
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@@


1.20
log
@Update the address and phone number of the FSF
@
text
@d1287 1
a1287 1
md_apply_fix3 (fixS *fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
@


1.19
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.18
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d33 1
a33 1
const char comment_chars[] = "!";
d35 1
a35 1
const char line_comment_chars[] = "!#";
d41 1
a41 2
   Integer arg to pass to the function
   */
d61 3
a63 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d66 2
a67 2
#define C(a,b) ENCODE_RELAX(a,b)
#define ENCODE_RELAX(what,length) (((what) << 2) + (length))
d69 1
a69 1
#define GET_WHAT(x) ((x>>2))
d71 2
a72 2
#define BYTE_DISP 1
#define WORD_DISP 2
d76 9
a84 9
#define BRANCH  1
#define SCB_F   2
#define SCB_TST 3
#define END 4

#define BYTE_F 127
#define BYTE_B -126
#define WORD_F 32767
#define WORD_B 32768
d86 2
a87 1
relax_typeS md_relax_table[C (END, 0)] = {
d113 1
a113 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
d115 2
a116 4
/*
  This function is called once, at assembler startup time.  This should
  set up all the tables, etc. that the MD part of the assembler needs
  */
d119 1
a119 1
md_begin ()
d128 1
a128 1
  /* Insert unique names into hash table */
d139 6
a144 8
static int rn;			/* register number used by RN */
static int rs;			/* register number used by RS */
static int rd;			/* register number used by RD */
static int crb;			/* byte size cr */
static int crw;			/* word sized cr */
static int cr;			/* unknown size cr */

static expressionS displacement;/* displacement expression */
d146 1
d148 2
a149 3
static expressionS immediate;	/* immediate expression */

static expressionS absolute;	/* absolute expression */
d163 1
a163 1
static int parse_reg PARAMS ((char *, int *, unsigned int *));
d166 1
a166 4
parse_reg (src, mode, reg)
     char *src;
     int *mode;
     unsigned int *reg;
a238 2
static char *parse_exp PARAMS ((char *, expressionS *, int *));

d240 1
a240 4
parse_exp (s, op, page)
     char *s;
     expressionS *op;
     int *page;
d278 3
a280 6
  {
    exp_signed, exp_unsigned, exp_sandu
  } sign_type;

static char *skip_colonthing
  PARAMS ((sign_type, char *, h8500_operand_info *, int, int, int, int));
d283 7
a289 8
skip_colonthing (sign, ptr, exp, def, size8, size16, size24)
     sign_type sign;
     char *ptr;
     h8500_operand_info *exp;
     int def;
     int size8;
     int size16;
     int size24;
d323 1
a323 3
	{
	  exp->type = IMM8;
	}
d325 1
a325 3
	{
	  exp->type = IMM16;
	}
d328 1
a328 1
	  /* Let's work out the size from the context */
d330 1
d336 1
a336 3
	    {
	      exp->type = size8;
	    }
d338 1
a338 3
	    {
	      exp->type = def;
	    }
a343 2
static int parse_reglist PARAMS ((char *, h8500_operand_info *));

d345 1
a345 3
parse_reglist (src, op)
     char *src;
     h8500_operand_info *op;
d351 1
a351 1
  int idx = 1;			/* skip ( */
d353 1
d368 1
d383 1
a383 3
	    {
	      as_bad (_("missing final register in range"));
	    }
d385 1
a396 1

d407 1
a407 5
   #xx[:size]		immediate data

   */

static void get_operand PARAMS ((char **, h8500_operand_info *, char));
d410 3
a412 4
get_operand (ptr, op, ispage)
     char **ptr;
     h8500_operand_info *op;
     char ispage;
d418 1
d531 2
a532 4
    {
      *ptr = skip_colonthing (exp_signed, src, op,
			      ispage ? ABS24 : PCREL8, PCREL8, PCREL16, ABS24);
    }
a534 3
static char *get_operands
  PARAMS ((h8500_opcode_info *, char *, h8500_operand_info *));

d536 3
a538 4
get_operands (info, args, operand)
     h8500_opcode_info *info;
     char *args;
     h8500_operand_info *operand;
d574 1
a574 4
int pcrel8;			/* Set when we've seen a pcrel operand */

static h8500_opcode_info *get_specific
  PARAMS ((h8500_opcode_info *, h8500_operand_info *));
d577 2
a578 3
get_specific (opcode, operands)
     h8500_opcode_info *opcode;
     h8500_operand_info *operands;
d591 2
a592 2
      /* look at both operands needed by the opcodes and provided by
       the user*/
d600 1
a600 1
	      /* Opcode needs (disp:8,fp) */
d635 1
a635 3
		{
		  continue;
		}
d637 1
d640 1
a640 3
		{
		  continue;
		}
d642 1
d695 1
a695 3
		{
		  continue;
		}
d697 1
d743 1
a743 2
		  &&
		  (user->exp.X_add_number == -2
a778 1

d787 1
a787 3
		{
		  continue;
		}
d794 1
a794 1
	  /* If we get here this didn't work out */
a807 2
static int check PARAMS ((expressionS *, int, int));

d809 3
a811 4
check (operand, low, high)
     expressionS *operand;
     int low;
     int high;
d816 2
a817 3
    {
      as_bad (_("operand must be absolute in range %d..%d"), low, high);
    }
d820 1
a820 3

static void insert PARAMS ((char *, int, expressionS *, int, int));

d822 1
a822 6
insert (output, index, exp, reloc, pcrel)
     char *output;
     int index;
     expressionS *exp;
     int reloc;
     int pcrel;
d826 2
a827 4
	       4,	       	/* always say size is 4, but we know better */
	       exp,
	       pcrel,
	       reloc);
a829 3
static void build_relaxable_instruction
  PARAMS ((h8500_opcode_info *, h8500_operand_info *));

d831 2
a832 3
build_relaxable_instruction (opcode, operand)
     h8500_opcode_info *opcode;
     h8500_operand_info *operand ATTRIBUTE_UNUSED;
d842 1
a842 3
    {
      type = SCB_F;
    }
d845 1
a845 3
    {
      type = SCB_TST;
    }
d847 1
a847 3
    {
      type = BRANCH;
    }
d859 1
a859 3
    {
      p[1] = opcode->bytes[1].contents | rs;
    }
a863 2
static void build_bytes PARAMS ((h8500_opcode_info *, h8500_operand_info *));

d865 1
a865 3
build_bytes (opcode, operand)
     h8500_opcode_info *opcode;
     h8500_operand_info *operand;
d998 1
a998 2
md_assemble (str)
     char *str;
d1017 3
a1019 8
    {
      if (			/**op_end != '.'
	  && *op_end != ':'
	   	   	   	  && */ nlen < 10)
	{
	  name[nlen++] = *op_end;
	}
    }
d1040 1
a1040 1
      /* Couldn't find an opcode which matched the operands */
d1053 1
a1053 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d1059 1
a1059 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1061 1
a1061 1
  return 0;
d1065 1
a1065 2
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d1080 1
a1080 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d1131 2
a1132 1
struct option md_longopts[] = {
d1138 1
a1138 3
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d1144 1
a1144 2
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
a1147 2
static void wordify_scb PARAMS ((char *, int *, int *));

d1149 1
a1149 4
wordify_scb (buffer, disp_size, inst_size)
     char *buffer;
     int *disp_size;
     int *inst_size;
d1214 3
a1216 4
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP;
d1268 1
a1268 1
      /* Get the address of the end of the instruction */
d1280 1
a1280 3
md_section_align (seg, size)
     segT seg ;
     valueT size;
a1283 1

d1287 1
a1287 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d1337 1
a1337 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP;
     register segT segment_type;
d1350 1
a1350 1
      /* used to be a branch to somewhere which was unknown */
d1358 3
a1360 5
	{
	  /* Its got a segment, but its not ours, so it will always be
             long.  */
	  fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
	}
d1383 1
a1383 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
d1389 1
a1389 2
md_pcrel_from (fixP)
     fixS *fixP;
d1395 1
a1395 2
tc_coff_symbol_emit_hook (ignore)
     symbolS *ignore ATTRIBUTE_UNUSED;
d1400 1
a1400 2
tc_coff_fix2rtype (fix_ptr)
     fixS *fix_ptr;
d1404 1
a1404 2
      /* cons likes to create reloc32's whatever the size of the reloc..
     */
d1421 3
a1423 5
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;

d1433 1
a1433 2
      /* cons likes to create reloc32's whatever the size of the reloc..
       */
d1447 1
a1447 3
    {
      intr->r_type = fix_ptr->fx_r_type;
    }
d1464 1
a1464 4
	{
	  intr->r_symndx = symbol_ptr->sy_number;
	}

d1467 1
a1467 4
    {
      intr->r_symndx = -1;
    }

d1471 1
a1471 2
start_label (ptr)
     char *ptr;
d1483 1
a1483 2
tc_coff_sizemachdep (frag)
     fragS *frag;
@


1.17
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d158 1
a158 1
  int reg;
d167 1
a167 1
static int parse_reg PARAMS ((char *, int *, int *));
d173 1
a173 1
     int *reg;
d375 1
a375 1
  int rn;
d377 1
a377 1
  int rm;
@


1.16
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@a1578 4
#if 0
	  intr->r_offset -=
	    segment_info[S_GET_SEGMENT (symbol_ptr)].scnhdr.s_paddr;
#endif
@


1.15
log
@	* h8500-opc.h (h8500_table): Add missing initializers to quiet
	warnings.

	* config/tc-h8500.c (cons): Delete declaration.
	(md_begin <opcode>): Constify.
	(displacement_size, immediate_size, absolute_size): Remove.
	(build_relaxable_instruction <operand>): Add ATTRIBUTE_UNUSED.
	(tc_crawl_symbol_chain <headers>): Likewise.
	(md_undefined_symbol <name>): Likewise.
	(tc_headers_hook <headers>): Likewise.
	(md_parse_option <c,arg>): Likewise.
	(md_show_usage <stream>): Likewise.
	(md_convert_frag <headers, seg>): Likewise.
	(tc_coff_symbol_emit_hook <ignore>): Likewise.
	(md_atof): Remove declaration of atof_ieee.
	(tc_aout_fix_to_chars): Remove unused function.
	(parse_reg): Prototype.
	(parse_exp): Prototype.
	(skip_colonthing): Prototype.  Use &&, not & in logical expressions.
	(parse_reglist): Prototype.
	(get_operand): Prototype.
	(get_operands): Prototype.
	(get_specific): Prototype.  Make "this_index" signed.
	(check): Prototype, make static.
	(insert): Prototype
	(build_relaxable_instruction): Prototype, make static.
	(build_bytes): Prototype.
	(wordify_scb): Prototype.
	* config/tc-h8500.h (start_label): Declare.
	(tc_coff_sizemachdep): Declare.
@
text
@d1 2
a2 2
/* tc-h8500.c -- Assemble code for the Hitachi H8/500
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002
@


1.14
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@a43 2
void cons ();

d123 1
a123 1
  h8500_opcode_info *opcode;
a148 1
static int displacement_size;	/* and size if given */
a151 1
static int immediate_size;	/* and size if given */
a153 1
static int absolute_size;	/* and size if given */
d167 2
d246 2
d294 3
d316 1
a316 1
      else if (ptr[0] == '1' & ptr[1] == '6')
d321 1
a321 1
      else if (ptr[0] == '2' & ptr[1] == '4')
d367 2
d438 2
d568 3
a575 1

d613 3
d624 1
a624 2

  unsigned int this_index = opcode->idx;
d856 3
a858 1
int
d873 2
d891 4
a894 1
void
d897 1
a897 1
     h8500_operand_info *operand;
d937 2
a942 1

d1137 1
a1137 1
     object_headers *headers;
d1144 1
a1144 1
     char *name;
d1151 1
a1151 1
     object_headers *headers;
a1174 1
  char *atof_ieee ();
d1227 2
a1228 2
     int c;
     char *arg;
d1235 1
a1235 1
     FILE *stream;
d1239 1
a1239 6
void
tc_aout_fix_to_chars ()
{
  printf (_("call to tc_aout_fix_to_chars \n"));
  abort ();
}
d1311 2
a1312 2
     object_headers *headers;
     segT seg;
d1507 1
a1507 1
     symbolS *ignore;
@


1.13
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001
d1202 1
a1202 1
CONST char *md_shortopts = "";
@


1.12
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1375 1
a1375 1
md_apply_fix (fixP, val)
d1377 2
a1378 1
     long val;
d1380 1
d1384 1
a1384 3
    {
      fixP->fx_r_type = fixP->fx_size == 4 ? R_H8500_IMM32 : R_H8500_IMM16;
    }
a1387 1

d1418 1
d1420 2
a1421 1
    }
d1424 3
a1426 4
/*
called just before address relaxation, return the length
by which a fragment must grow to reach it's destination
*/
@


1.11
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@d31 1
a31 1
#include <ctype.h>
d1592 1
a1592 1
  if (isalpha (ptr[1]) && ptr[2] == '.')
d1595 1
a1595 1
  if (isalpha (ptr[1]) && !isalpha (ptr[2]))
@


1.10
log
@Fix more breakages from the multiple relax pass patch.
@
text
@a1345 1
      fragP->fr_var = 0;
a1360 1
      fragP->fr_var = 0;
d1472 1
a1472 2
  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
  return fragP->fr_var;
@


1.9
log
@Prepare for multi-pass relaxation.
@
text
@d89 25
a113 1
relax_typeS md_relax_table[C (END, 0)];
a127 1
  register relax_typeS *table;
a140 34

  /* Initialize the relax table.  We use a local variable to avoid
     warnings about modifying a supposedly const data structure.  */
  table = (relax_typeS *) md_relax_table;
  table[C (BRANCH, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (BRANCH, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (BRANCH, BYTE_DISP)].rlx_length = 2;
  table[C (BRANCH, BYTE_DISP)].rlx_more = C (BRANCH, WORD_DISP);

  table[C (BRANCH, WORD_DISP)].rlx_forward = WORD_F;
  table[C (BRANCH, WORD_DISP)].rlx_backward = WORD_B;
  table[C (BRANCH, WORD_DISP)].rlx_length = 3;
  table[C (BRANCH, WORD_DISP)].rlx_more = 0;

  table[C (SCB_F, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (SCB_F, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (SCB_F, BYTE_DISP)].rlx_length = 3;
  table[C (SCB_F, BYTE_DISP)].rlx_more = C (SCB_F, WORD_DISP);

  table[C (SCB_F, WORD_DISP)].rlx_forward = WORD_F;
  table[C (SCB_F, WORD_DISP)].rlx_backward = WORD_B;
  table[C (SCB_F, WORD_DISP)].rlx_length = 8;
  table[C (SCB_F, WORD_DISP)].rlx_more = 0;

  table[C (SCB_TST, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (SCB_TST, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (SCB_TST, BYTE_DISP)].rlx_length = 3;
  table[C (SCB_TST, BYTE_DISP)].rlx_more = C (SCB_TST, WORD_DISP);

  table[C (SCB_TST, WORD_DISP)].rlx_forward = WORD_F;
  table[C (SCB_TST, WORD_DISP)].rlx_backward = WORD_B;
  table[C (SCB_TST, WORD_DISP)].rlx_length = 10;
  table[C (SCB_TST, WORD_DISP)].rlx_more = 0;

d1434 1
a1434 1
  int what = GET_WHAT (fragP->fr_subtype);
d1444 1
a1450 1
	  fragP->fr_var = md_relax_table[C (what, BYTE_DISP)].rlx_length;
a1456 1
	  fragP->fr_var = md_relax_table[C (what, WORD_DISP)].rlx_length;
d1461 1
d1464 1
d1467 1
d1470 1
a1470 1
	 do anything.  */
d1473 2
@


1.8
log
@Fix copyright notices
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 1995, 1998, 2000 Free Software Foundation, Inc.
d1451 1
a1468 1
	  return md_relax_table[C (what, WORD_DISP)].rlx_length;
d1470 11
@


1.7
log
@2000-09-15  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-h8300.h: Fix formatting.
	* config/tc-h8500.c: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 98, 2000 Free Software Foundation.
@


1.7.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1998, 2000, 2001
   Free Software Foundation, Inc.
@


1.7.2.2
log
@Merge from mainline.
@
text
@d89 1
a89 25
relax_typeS md_relax_table[C (END, 0)] = {
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },

  /* BRANCH */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  2, C (BRANCH, WORD_DISP) },
  { WORD_F, WORD_B,  3, 0 },
  { 0,      0,       3, 0 },

  /* SCB_F */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  3, C (SCB_F, WORD_DISP) },
  { WORD_F, WORD_B,  8, 0 },
  { 0,      0,       8, 0 },

  /* SCB_TST */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  3, C (SCB_TST, WORD_DISP) },
  { WORD_F, WORD_B, 10, 0 },
  { 0,      0,      10, 0 }

};
d104 1
d118 34
d1357 1
d1373 1
d1445 1
a1445 1
  int what;
a1450 1

a1453 1
      what = GET_WHAT (fragP->fr_subtype);
d1460 1
d1467 2
a1469 14
      break;

    case C (BRANCH, BYTE_DISP):
    case C (BRANCH, WORD_DISP):
    case C (BRANCH, UNDEF_WORD_DISP):
    case C (SCB_F, BYTE_DISP):
    case C (SCB_F, WORD_DISP):
    case C (SCB_F, UNDEF_WORD_DISP):
    case C (SCB_TST, BYTE_DISP):
    case C (SCB_TST, WORD_DISP):
    case C (SCB_TST, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
d1471 1
a1471 2

  return md_relax_table[fragP->fr_subtype].rlx_length;
@


1.6
log
@ Fix formatting.
@
text
@d21 1
a21 4
/*
  Written By Steve Chamberlain
  sac@@cygnus.com
  */
a304 1

d1299 1
a1299 1
  *buffer++ = 0x36;		/* bne ... */
@


1.5
log
@Fix comments.
@
text
@d197 1
a197 1
  end = src+1;
d262 1
a262 2
static
char *
d501 1
a501 1
	  src = skip_colonthing (exp_signed, src, 
d576 1
a576 2
static
char *
d615 1
a615 2
   provided
   */
d619 1
a619 2
static
h8500_opcode_info *
d875 1
a875 2
static
void
d897 2
a898 2
     three bytes long if a lonely branch and up to 9 bytes if long scb
     */
d932 2
a933 2
/* Now we know what sort of opcodes it is, let's build the bytes -
 */
a967 1
	      
a980 1

d984 14
a997 13
		switch (immediate_inpage) {
		case 'p':
		  p = R_H8500_HIGH16;
		  break;
		case 'h':		
		  p = R_H8500_HIGH16;
		  break;
		default:
		  p = R_H8500_IMM16;
		  break;
		}
		
		insert (output, index, &immediate,p, 0);
a998 1
		
d1004 1
a1004 3
		{
		  insert (output, index, &immediate, R_H8500_HIGH8, 0);
		}
d1006 1
a1006 3
		{
		  insert (output, index, &immediate, R_H8500_IMM8, 0);
		}
a1018 1

d1021 1
a1021 3
		{
		  output[0] |= 0x8;
		}
d1023 1
a1023 4
		{
		  output[0] &= ~0x8;
		}

a1024 1

d1066 3
a1068 4
/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.
   */
d1083 1
a1083 1
  /* Drop leading whitespace */
d1087 1
a1087 1
  /* find the op code end */
d1102 1
a1102 3
    {
      as_bad (_("can't find opcode "));
    }
a1128 1

d1152 2
a1153 2
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
d1220 1
a1220 1
size_t md_longopts_size = sizeof(md_longopts);
d1243 1
a1243 2
static
void
d1308 3
a1310 3
/*
called after relaxing, change the frags so they know how big they are
*/
d1334 1
a1334 1
      /* Branches to a known 16 bit displacement */
d1336 1
a1336 1
      /* Turn on the 16bit bit */
d1346 2
a1347 2
      /* This tried to be relaxed, but didn't manage it, it now needs a
	 fix */
d1385 1
a1385 1
  return ((size + (1 << section_alignment[(int) seg]) - 1) 
d1461 1
a1461 1
	 sized - maybe it will fix up */
d1467 2
a1468 1
	  /* Its got a segment, but its not ours, so it will always be long */
d1477 1
a1477 1
/* Put number into target byte order */
a1494 1
/*ARGSUSED*/
d1569 4
a1572 2
	  /*	  intr->r_offset -=
	    segment_info[S_GET_SEGMENT(symbol_ptr)].scnhdr.s_paddr;*/
a1588 2


a1601 1

a1607 3

/* end of tc-h8500.c */

@


1.4
log
@Blow away DEFUN.
@
text
@d183 2
a184 1
/* try and parse a reg name, returns number of chars consumed */
d1178 5
a1182 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *LITP.  The number of LITTLENUMS
   emitted is stored in *SIZEP .  An error message is returned, or NULL on OK.
   */
@


1.3
log
@Fix comment typos.
@
text
@d1089 2
a1090 2
DEFUN (md_assemble, (str),
       char *str)
d1153 2
a1154 2
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
d1160 2
a1161 2
DEFUN (md_undefined_symbol, (name),
       char *name)
d1167 2
a1168 2
DEFUN (tc_headers_hook, (headers),
       object_headers * headers)
@


1.2
log
@is_end_of_line fixes.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1998 Free Software Foundation.
d97 1
a97 1
  set up all the tables, etc that the MD part of the assembler needs
d936 1
a936 1
/* Now we know what sort of opcodes it is, lets build the bytes -
d1084 1
a1084 1
   machine dependent instruction.  This funciton is supposed to emit
d1178 2
a1179 2
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
@


1.1
log
@Initial revision
@
text
@d1107 1
a1107 2
       *op_end &&
       !is_end_of_line[*op_end] && *op_end != ' ';
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

