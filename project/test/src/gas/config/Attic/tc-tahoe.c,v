head	1.19;
access;
symbols
	binutils-csl-sourcerygxx-3_4_4-32:1.15
	binutils-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	binutils-csl-wrs-linux-3_4_4-22:1.15
	binutils-csl-wrs-linux-3_4_4-21:1.15
	binutils-csl-wrs-linux-3_4_4-20:1.15
	binutils-csl-gxxpro-3_4-branch:1.15.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	binutils-csl-arm-2005q1a:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.14
	csl-arm-2004-q3:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	csl-arm-2003-q4:1.13
	binutils-2_14:1.12
	binutils-2_14-branch:1.12.0.4
	binutils-2_14-branchpoint:1.12
	binutils-2_13_2_1:1.12
	binutils-2_13_2:1.12
	binutils-2_13_1:1.12
	binutils-2_13:1.12
	binutils-2_13-branchpoint:1.12
	binutils-2_13-branch:1.12.0.2
	binutils-2_12_1:1.11
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.11
	binutils-2_11_2:1.6.2.2
	binutils-2_11_1:1.6.2.2
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.18
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2005.08.11.01.25.24;	author amodra;	state dead;
branches;
next	1.18;

1.18
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.05.09.13.03;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.24.20.40.27;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.03.11.47.54;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.03.01.54.25;	author hp;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.22.15.32.28;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.08.07.37.16;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.15.21.28.59;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.05.33.29;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.10.11.32.52;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.12.03.06.49.23;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.20.13.14.47;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.25.17.59.21;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.45;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.15.33;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.06.11.10.04.51;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.19
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* This file is tc-tahoe.c

   Copyright 1987, 1988, 1989, 1990, 1991, 1992, 1995, 2000, 2001, 2002,
   2003, 2004, 2005 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"

/* This bit glommed from tahoe-inst.h.  */

typedef unsigned char byte;
typedef byte tahoe_opcodeT;

/* This is part of tahoe-ins-parse.c & friends.
   We want to parse a tahoe instruction text into a tree defined here.  */

#define TIT_MAX_OPERANDS  4 	/* Maximum number of operands in one
				   single tahoe instruction.  */

struct top			/* Tahoe instruction operand.  */
  {
    int top_ndx;		/* -1, or index register. eg 7=[R7].  */
    int top_reg;		/* -1, or register number. eg 7 = R7 or (R7).  */
    byte top_mode;		/* Addressing mode byte. This byte, defines
				   which of the 11 modes opcode is.  */

    char top_access;		/* Access type wanted for this operand
				   'b'branch ' 'no-instruction 'amrvw'.  */
    char top_width;		/* Operand width expected, one of "bwlq?-:!".  */

    char * top_error;		/* Say if operand is inappropriate.  */

    segT seg_of_operand;	/* Segment as returned by expression().  */

    expressionS exp_of_operand;	/* The expression as parsed by expression().  */

    byte top_dispsize;		/* Number of bytes in the displacement if we
				   can figure it out.  */
  };

/* The addressing modes for an operand. These numbers are the actual values
   for certain modes, so be careful if you screw with them.  */
#define TAHOE_DIRECT_REG 		0x50
#define TAHOE_REG_DEFERRED 		0x60

#define TAHOE_REG_DISP 			0xE0
#define TAHOE_REG_DISP_DEFERRED 	0xF0

#define TAHOE_IMMEDIATE 		0x8F
#define TAHOE_IMMEDIATE_BYTE 		0x88
#define TAHOE_IMMEDIATE_WORD 		0x89
#define TAHOE_IMMEDIATE_LONGWORD 	0x8F
#define TAHOE_ABSOLUTE_ADDR 		0x9F

#define TAHOE_DISPLACED_RELATIVE 	0xEF
#define TAHOE_DISP_REL_DEFERRED 	0xFF

#define TAHOE_AUTO_DEC 			0x7E
#define TAHOE_AUTO_INC 			0x8E
#define TAHOE_AUTO_INC_DEFERRED 	0x9E
/* INDEXED_REG is decided by the existence or lack of a [reg].  */

/* These are encoded into top_width when top_access=='b'
   and it's a psuedo op.  */
#define TAHOE_WIDTH_ALWAYS_JUMP      '-'
#define TAHOE_WIDTH_CONDITIONAL_JUMP '?'
#define TAHOE_WIDTH_BIG_REV_JUMP     '!'
#define TAHOE_WIDTH_BIG_NON_REV_JUMP ':'

/* The hex code for certain tahoe commands and modes.
   This is just for readability.  */
#define TAHOE_JMP 		0x71
#define TAHOE_PC_REL_LONG 	0xEF
#define TAHOE_BRB 		0x11
#define TAHOE_BRW 		0x13
/* These, when 'ored' with, or added to, a register number,
   set up the number for the displacement mode.  */
#define TAHOE_PC_OR_BYTE	0xA0
#define TAHOE_PC_OR_WORD	0xC0
#define TAHOE_PC_OR_LONG	0xE0

struct tit			/* Get it out of the sewer, it stands for
				   tahoe instruction tree (Geeze!).  */
{
  tahoe_opcodeT tit_opcode;	/* The opcode.  */
  byte tit_operands;		/* How many operands are here.  */
  struct top tit_operand[TIT_MAX_OPERANDS];	/* Operands.  */
  char *tit_error;		/* "" or fatal error text.  */
};

/* end: tahoe-inst.h */

/* tahoe.c - tahoe-specific -
   Not part of gas yet.   */

#include "opcode/tahoe.h"

/* This is the number to put at the beginning of the a.out file.  */
long omagic = OMAGIC;

/* These chars start a comment anywhere in a source file (except inside
   another comment or a quoted string.  */
const char comment_chars[] = "#;";

/* These chars only start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
   as in 0f123.456
   or    0d1.234E-12 (see exp chars above)
   Note: The Tahoe port doesn't support floating point constants. This is
         consistent with 'as' If it's needed, I can always add it later.  */
const char FLT_CHARS[] = "df";

/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c .  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.
   (The tahoe has plenty of room, so the change currently isn't needed.)  */

static struct tit t;		/* A tahoe instruction after decoding.  */

void float_cons ();
/* A table of pseudo ops (sans .), the function called, and an integer op
   that the function is called with.  */

const pseudo_typeS md_pseudo_table[] =
{
  {"dfloat", float_cons, 'd'},
  {"ffloat", float_cons, 'f'},
  {0}
};

/* For Tahoe, relative addresses of "just the right length" are pretty easy.
   The branch displacement is always the last operand, even in
   synthetic instructions.
   For Tahoe, we encode the relax_substateTs (in e.g. fr_substate) as:

  		    4       3       2       1       0	     bit number
  	---/ /--+-------+-------+-------+-------+-------+
  		|     what state ?	|  how long ?	|
  	---/ /--+-------+-------+-------+-------+-------+

   The "how long" bits are 00=byte, 01=word, 10=long.
   This is a Un*x convention.
   Not all lengths are legit for a given value of (what state).
   The four states are listed below.
   The "how long" refers merely to the displacement length.
   The address usually has some constant bytes in it as well.

   States for Tahoe address relaxing.
   1.	TAHOE_WIDTH_ALWAYS_JUMP (-)
	Format: "b-"
	Tahoe opcodes are:	(Hex)
		jr		11
		jbr		11
	Simple branch.
	Always, 1 byte opcode, then displacement/absolute.
	If word or longword, change opcode to brw or jmp.

   2.	TAHOE_WIDTH_CONDITIONAL_JUMP (?)
	J<cond> where <cond> is a simple flag test.
	Format: "b?"
	Tahoe opcodes are:	(Hex)
		jneq/jnequ	21
		jeql/jeqlu	31
		jgtr		41
		jleq		51
		jgeq		81
		jlss		91
		jgtru		a1
		jlequ		b1
		jvc		c1
		jvs		d1
		jlssu/jcs	e1
		jgequ/jcc	f1
	Always, you complement 4th bit to reverse the condition.
	Always, 1-byte opcode, then 1-byte displacement.

   3.	TAHOE_WIDTH_BIG_REV_JUMP (!)
	Jbc/Jbs where cond tests a memory bit.
	Format: "rlvlb!"
	Tahoe opcodes are:	(Hex)
		jbs		0e
		jbc		1e
	Always, you complement 4th bit to reverse the condition.
	Always, 1-byte opcde, longword, longword-address, 1-word-displacement

   4.	TAHOE_WIDTH_BIG_NON_REV_JUMP (:)
	JaoblXX/Jbssi
	Format: "rlmlb:"
	Tahoe opcodes are:	(Hex)
		aojlss		2f
		jaoblss		2f
		aojleq		3f
		jaobleq		3f
		jbssi		5f
	Always, we cannot reverse the sense of the branch; we have a word
	displacement.

   We need to modify the opcode is for class 1, 2 and 3 instructions.
   After relax() we may complement the 4th bit of 2 or 3 to reverse sense of
   branch.

   We sometimes store context in the operand literal. This way we can figure out
   after relax() what the original addressing mode was. (Was is pc_rel, or
   pc_rel_disp? That sort of thing.)  */

/* These displacements are relative to the START address of the
   displacement which is at the start of the displacement, not the end of
   the instruction. The hardware pc_rel is at the end of the instructions.
   That's why all the displacements have the length of the displacement added
   to them. (WF + length(word))

   The first letter is Byte, Word.
   2nd letter is Forward, Backward.  */
#define BF (1 +    127)
#define BB (1 +   -128)
#define WF (2 +  32767)
#define WB (2 + -32768)
/* Dont need LF, LB because they always reach. [They are coded as 0.] */

#define C(a,b)                    ENCODE_RELAX(a, b)
/* This macro has no side-effects.  */
#define ENCODE_RELAX(what,length) (((what) << 2) + (length))
#define RELAX_STATE(s)            ((s) >> 2)
#define RELAX_LENGTH(s)           ((s) & 3)

#define STATE_ALWAYS_BRANCH             1
#define STATE_CONDITIONAL_BRANCH        2
#define STATE_BIG_REV_BRANCH            3
#define STATE_BIG_NON_REV_BRANCH        4
#define STATE_PC_RELATIVE		5

#define STATE_BYTE                      0
#define STATE_WORD                      1
#define STATE_LONG                      2
#define STATE_UNDF                      3	/* Symbol undefined in pass1.  */

/* This is the table used by gas to figure out relaxing modes. The fields are
   forward_branch reach, backward_branch reach, number of bytes it would take,
   where the next biggest branch is.  */
const relax_typeS md_relax_table[] =
{
  {
    1, 1, 0, 0
  },				/* Error sentinel   0,0	*/
  {
    1, 1, 0, 0
  },				/* Unused	    0,1	*/
  {
    1, 1, 0, 0
  },				/* Unused	    0,2	*/
  {
    1, 1, 0, 0
  },				/* Unused	    0,3	*/
/* Unconditional branch cases "jrb"
     The relax part is the actual displacement */
  {
    BF, BB, 1, C (1, 1)
  },				/* Brb B`foo	    1,0 */
  {
    WF, WB, 2, C (1, 2)
  },				/* Brw W`foo	    1,1 */
  {
    0, 0, 5, 0
  },				/* Jmp L`foo	    1,2 */
  {
    1, 1, 0, 0
  },				/* Unused	    1,3 */
/* Reversible Conditional Branch. If the branch won't reach, reverse
     it, and jump over a brw or a jmp that will reach. The relax part is the
     actual address.  */
  {
    BF, BB, 1, C (2, 1)
  },				/* b<cond> B`foo    2,0 */
  {
    WF + 2, WB + 2, 4, C (2, 2)
  },				/* brev over, brw W`foo, over: 2,1 */
  {
    0, 0, 7, 0
  },				/* brev over, jmp L`foo, over: 2,2 */
  {
    1, 1, 0, 0
  },				/* Unused	    2,3 */
/* Another type of reversible branch. But this only has a word
     displacement.  */
  {
    1, 1, 0, 0
  },				/* Unused	    3,0 */
  {
    WF, WB, 2, C (3, 2)
  },				/* jbX W`foo	    3,1 */
  {
    0, 0, 8, 0
  },				/* jrevX over, jmp L`foo, over:  3,2 */
  {
    1, 1, 0, 0
  },				/* Unused	    3,3 */
/* These are the non reversible branches, all of which have a word
     displacement. If I can't reach, branch over a byte branch, to a
     jump that will reach. The jumped branch jumps over the reaching
     branch, to continue with the flow of the program. It's like playing
     leap frog.  */
  {
    1, 1, 0, 0
  },				/* Unused	    4,0 */
  {
    WF, WB, 2, C (4, 2)
  },				/* aobl_ W`foo	    4,1 */
  {
    0, 0, 10, 0
  },				/*aobl_ W`hop,br over,hop: jmp L^foo,over 4,2*/
  {
    1, 1, 0, 0
  },				/* Unused	    4,3 */
/* Normal displacement mode, no jumping or anything like that.
     The relax points to one byte before the address, thats why all
     the numbers are up by one.  */
  {
    BF + 1, BB + 1, 2, C (5, 1)
  },				/* B^"foo"	    5,0 */
  {
    WF + 1, WB + 1, 3, C (5, 2)
  },				/* W^"foo"	    5,1 */
  {
    0, 0, 5, 0
  },				/* L^"foo"	    5,2 */
  {
    1, 1, 0, 0
  },				/* Unused	    5,3 */
};

#undef C
#undef BF
#undef BB
#undef WF
#undef WB
/* End relax stuff.  */

/* Handle of the OPCODE hash table.  NULL means any use before
   md_begin() will crash.  */
static struct hash_control *op_hash;

/* Init function. Build the hash table.  */

void
md_begin (void)
{
  struct tot *tP;
  char *errorval = 0;
  int synthetic_too = 1;	/* If 0, just use real opcodes.  */

  op_hash = hash_new ();

  for (tP = totstrs; *tP->name && !errorval; tP++)
    errorval = hash_insert (op_hash, tP->name, &tP->detail);

  if (synthetic_too)
    for (tP = synthetic_totstrs; *tP->name && !errorval; tP++)
      errorval = hash_insert (op_hash, tP->name, &tP->detail);

  if (errorval)
    as_fatal (errorval);
}

const char *md_shortopts = "ad:STt:V";

struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case 'a':
      as_warn (_("The -a option doesn't exist. (Despite what the man page says!"));
      break;

    case 'd':
      as_warn (_("Displacement length %s ignored!"), arg);
      break;

    case 'S':
      as_warn (_("SYMBOL TABLE not implemented"));
      break;

    case 'T':
      as_warn (_("TOKEN TRACE not implemented"));
      break;

    case 't':
      as_warn (_("I don't need or use temp. file \"%s\"."), arg);
      break;

    case 'V':
      as_warn (_("I don't use an interpass file! -V ignored"));
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
Tahoe options:\n\
-a			ignored\n\
-d LENGTH		ignored\n\
-J			ignored\n\
-S			ignored\n\
-t FILE			ignored\n\
-T			ignored\n\
-V			ignored\n"));
}

/* The functions in this section take numbers in the machine format, and
   munges them into Tahoe byte order.
   They exist primarily for cross assembly purpose.
   Knows about order of bytes in address.  */

void
md_number_to_chars (char con[],		/* Return 'nbytes' of chars here.  */
		    valueT value,	/* The value of the bits.  */
		    int nbytes)		/* Number of bytes in the output.  */
{
  number_to_chars_bigendian (con, value, nbytes);
}

void
md_apply_fix (fixS *fixP ATTRIBUTE_UNUSED,
	       valueT * valP ATTRIBUTE_UNUSED,
	       segT seg ATTRIBUTE_UNUSED)
{
  /* Should never be called.  */
  know (0);
}

void
md_number_to_disp (char con[]m		/* Return 'nbytes' of chars here.  */
		   long int value,	/* The value of the bits.  */
		   int nbytes)		/* Number of bytes in the output.  */
{
  md_number_to_chars (con, value, nbytes);
}

void
md_number_to_field (char con[],		/* Return 'nbytes' of chars here.  */
		    long int value,	/* The value of the bits.  */
		    int nbytes)		/* Number of bytes in the output.  */
{
  md_number_to_chars (con, value, nbytes);
}

/* Put the bits in an order that a tahoe will understand, despite the ordering
   of the native machine.
   On Tahoe: first 4 bytes are normal unsigned big endian long,
   next three bytes are symbolnum, in kind of 3 byte big endian (least sig. byte last).
   The last byte is broken up with bit 7 as pcrel,
   	bits 6 & 5 as length,
	bit 4 as extern and the last nibble as 'undefined'.  */

void
tc_aout_fix_to_chars (char *where,
		      fixS *fixP,
		      relax_addressT segment_address_in_file)
{
  long r_symbolnum;

  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
       fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  where[4] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[6] = r_symbolnum & 0x0ff;
  where[7] = (((is_pcrel (fixP) << 7) & 0x80)
	      | ((((fixP->fx_type == FX_8 || fixP->fx_type == FX_PCREL8
		    ? 0
		    : (fixP->fx_type == FX_16 || fixP->fx_type == FX_PCREL16
		       ? 1
		    : (fixP->fx_type == FX_32 || fixP->fx_type == FX_PCREL32
		       ? 2
		       : 42)))) << 5) & 0x60)
	      | ((!S_IS_DEFINED (fixP->fx_addsy) << 4) & 0x10));
}

/* Relocate byte stuff.  */

/* This is for broken word.  */
int md_short_jump_size = 3;

void
md_create_short_jump (char *ptr,
		      addressT from_addr,
		      addressT to_addr,
		      fragS *frag,
		      symbolS *to_symbol)
{
  valueT offset;

  offset = to_addr - (from_addr + 1);
  *ptr++ = TAHOE_BRW;
  md_number_to_chars (ptr, offset, 2);
}

int md_long_jump_size = 6;
const int md_reloc_size = 8;	/* Size of relocation record.  */

void
md_create_long_jump (char *ptr,
		     addressT from_addr,
		     addressT to_addr,
		     fragS *frag,
		     symbolS *to_symbol)
{
  valueT offset;

  offset = to_addr - (from_addr + 4);
  *ptr++ = TAHOE_JMP;
  *ptr++ = TAHOE_PC_REL_LONG;
  md_number_to_chars (ptr, offset, 4);
}

/* md_estimate_size_before_relax(), called just before relax().
   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag and the growth beyond
   fr_fix.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment_type)
{
  if (RELAX_LENGTH (fragP->fr_subtype) == STATE_UNDF)
    {
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
	{
	  /* Non-relaxable cases.  */
	  char *p;
	  int old_fr_fix;

	  old_fr_fix = fragP->fr_fix;
	  p = fragP->fr_literal + old_fr_fix;
	  switch (RELAX_STATE (fragP->fr_subtype))
	    {
	    case STATE_PC_RELATIVE:
	      *p |= TAHOE_PC_OR_LONG;
	      /* We now know how big it will be, one long word.  */
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    case STATE_CONDITIONAL_BRANCH:
	      *fragP->fr_opcode ^= 0x10;	/* Reverse sense of branch.  */
	      *p++ = 6;
	      *p++ = TAHOE_JMP;
	      *p++ = TAHOE_PC_REL_LONG;
	      fragP->fr_fix += 1 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 3, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    case STATE_BIG_REV_BRANCH:
	      *fragP->fr_opcode ^= 0x10;	/* Reverse sense of branch.  */
	      *p++ = 0;
	      *p++ = 6;
	      *p++ = TAHOE_JMP;
	      *p++ = TAHOE_PC_REL_LONG;
	      fragP->fr_fix += 2 + 2 + 4;
	      fix_new (fragP, old_fr_fix + 4, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    case STATE_BIG_NON_REV_BRANCH:
	      *p++ = 2;
	      *p++ = 0;
	      *p++ = TAHOE_BRB;
	      *p++ = 6;
	      *p++ = TAHOE_JMP;
	      *p++ = TAHOE_PC_REL_LONG;
	      fragP->fr_fix += 2 + 2 + 2 + 4;
	      fix_new (fragP, old_fr_fix + 6, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    case STATE_ALWAYS_BRANCH:
	      *fragP->fr_opcode = TAHOE_JMP;
	      *p++ = TAHOE_PC_REL_LONG;
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    default:
	      abort ();
	    }
	  frag_wane (fragP);

	  /* Return the growth in the fixed part of the frag.  */
	  return fragP->fr_fix - old_fr_fix;
	}

      /* Relaxable cases.  Set up the initial guess for the variable
	 part of the frag.  */
      switch (RELAX_STATE (fragP->fr_subtype))
	{
	case STATE_PC_RELATIVE:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	  break;
	case STATE_CONDITIONAL_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE);
	  break;
	case STATE_BIG_REV_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_BIG_REV_BRANCH, STATE_WORD);
	  break;
	case STATE_BIG_NON_REV_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_BIG_NON_REV_BRANCH, STATE_WORD);
	  break;
	case STATE_ALWAYS_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_BYTE);
	  break;
	}
    }

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Called after relax() is finished.
   In:	Address of frag.
  	fr_type == rs_machine_dependent.
  	fr_subtype is what the address relaxed to.

   Out:	Any fixSs and constants are set up.
  	Caller will turn frag into a ".space 0".  */

void
md_convert_frag (object_headers *headers, segT seg, fragS *fragP)
{
  char *addressP;	/* -> _var to change.  */
  char *opcodeP;	/* -> opcode char(s) to change.  */
  short int extension = 0;	/* Size of relaxed address.
  			   Added to fr_fix: incl. ALL var chars.  */
  symbolS *symbolP;
  long int where;
  long int address_of_var;
  /* Where, in file space, is _var of *fragP?  */
  long int target_address;
  /* Where, in file space, does addr point?  */

  know (fragP->fr_type == rs_machine_dependent);
  where = fragP->fr_fix;
  addressP = fragP->fr_literal + where;
  opcodeP = fragP->fr_opcode;
  symbolP = fragP->fr_symbol;
  know (symbolP);
  target_address = S_GET_VALUE (symbolP) + fragP->fr_offset;
  address_of_var = fragP->fr_address + where;

  switch (fragP->fr_subtype)
    {
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE):
      /* *addressP holds the registers number, plus 0x10, if it's deferred
	 mode. To set up the right mode, just OR the size of this displacement.  */
      /* Byte displacement.  */
      *addressP++ |= TAHOE_PC_OR_BYTE;
      *addressP = target_address - (address_of_var + 2);
      extension = 2;
      break;

    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_WORD):
      /* Word displacement.  */
      *addressP++ |= TAHOE_PC_OR_WORD;
      md_number_to_chars (addressP, target_address - (address_of_var + 3), 2);
      extension = 3;
      break;

    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_LONG):
      /* Long word displacement.  */
      *addressP++ |= TAHOE_PC_OR_LONG;
      md_number_to_chars (addressP, target_address - (address_of_var + 5), 4);
      extension = 5;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE):
      *addressP = target_address - (address_of_var + 1);
      extension = 1;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_WORD):
      *opcodeP ^= 0x10;		/* Reverse sense of test.  */
      *addressP++ = 3;		/* Jump over word branch.  */
      *addressP++ = TAHOE_BRW;
      md_number_to_chars (addressP, target_address - (address_of_var + 4), 2);
      extension = 4;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_LONG):
      *opcodeP ^= 0x10;		/* Reverse sense of test.  */
      *addressP++ = 6;
      *addressP++ = TAHOE_JMP;
      *addressP++ = TAHOE_PC_REL_LONG;
      md_number_to_chars (addressP, target_address, 4);
      extension = 7;
      break;

    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_BYTE):
      *addressP = target_address - (address_of_var + 1);
      extension = 1;
      break;

    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_WORD):
      *opcodeP = TAHOE_BRW;
      md_number_to_chars (addressP, target_address - (address_of_var + 2), 2);
      extension = 2;
      break;

    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_LONG):
      *opcodeP = TAHOE_JMP;
      *addressP++ = TAHOE_PC_REL_LONG;
      md_number_to_chars (addressP, target_address - (address_of_var + 5), 4);
      extension = 5;
      break;

    case ENCODE_RELAX (STATE_BIG_REV_BRANCH, STATE_WORD):
      md_number_to_chars (addressP, target_address - (address_of_var + 2), 2);
      extension = 2;
      break;

    case ENCODE_RELAX (STATE_BIG_REV_BRANCH, STATE_LONG):
      *opcodeP ^= 0x10;
      *addressP++ = 0;
      *addressP++ = 6;
      *addressP++ = TAHOE_JMP;
      *addressP++ = TAHOE_PC_REL_LONG;
      md_number_to_chars (addressP, target_address, 4);
      extension = 8;
      break;

    case ENCODE_RELAX (STATE_BIG_NON_REV_BRANCH, STATE_WORD):
      md_number_to_chars (addressP, target_address - (address_of_var + 2), 2);
      extension = 2;
      break;

    case ENCODE_RELAX (STATE_BIG_NON_REV_BRANCH, STATE_LONG):
      *addressP++ = 0;
      *addressP++ = 2;
      *addressP++ = TAHOE_BRB;
      *addressP++ = 6;
      *addressP++ = TAHOE_JMP;
      *addressP++ = TAHOE_PC_REL_LONG;
      md_number_to_chars (addressP, target_address, 4);
      extension = 10;
      break;

    default:
      BAD_CASE (fragP->fr_subtype);
      break;
    }
  fragP->fr_fix += extension;
}


/* This is the stuff for md_assemble.  */
#define FP_REG 13
#define SP_REG 14
#define PC_REG 15
#define BIGGESTREG PC_REG

/* Parse the string pointed to by START
   If it represents a valid register, point START to the character after
   the last valid register char, and return the register number (0-15).
   If invalid, leave START alone, return -1.
   The format has to be exact. I don't do things like eat leading zeros
   or the like.
   Note: This doesn't check for the next character in the string making
   this invalid. Ex: R123 would return 12, it's the callers job to check
   what start is point to apon return.

   Valid registers are R1-R15, %1-%15, FP (13), SP (14), PC (15)
   Case doesn't matter.  */

int
tahoe_reg_parse (char **start)		/* A pointer to the string to parse.  */
{
  char *regpoint = *start;
  int regnum = -1;

  switch (*regpoint++)
    {
    case '%':			/* Registers can start with a %,
				   R or r, and then a number.  */
    case 'R':
    case 'r':
      if (ISDIGIT (*regpoint))
	{
	  /* Got the first digit.  */
	  regnum = *regpoint++ - '0';
	  if ((regnum == 1) && ISDIGIT (*regpoint))
	    {
	      /* Its a two digit number.  */
	      regnum = 10 + (*regpoint++ - '0');
	      if (regnum > BIGGESTREG)
		regnum = -1;
	    }
	}
      break;
    case 'F':			/* Is it the FP.  */
    case 'f':
      switch (*regpoint++)
	{
	case 'p':
	case 'P':
	  regnum = FP_REG;
	}
      break;
    case 's':			/* How about the SP.  */
    case 'S':
      switch (*regpoint++)
	{
	case 'p':
	case 'P':
	  regnum = SP_REG;
	}
      break;
    case 'p':			/* Or the PC even.  */
    case 'P':
      switch (*regpoint++)
	{
	case 'c':
	case 'C':
	  regnum = PC_REG;
	}
      break;
    }

  if (regnum != -1)
    /* No error, so move string pointer.  */
    *start = regpoint;

  return regnum;
}

/* This chops up an operand and figures out its modes and stuff.
   It's a little touchy about extra characters.
   Optex to start with one extra character so it can be overwritten for
   the backward part of the parsing.
   You can't put a bunch of extra characters in side to
   make the command look cute. ie: * foo ( r1 ) [  r0 ]
   If you like doing a lot of typing, try COBOL!
   Actually, this parser is a little weak all around. It's designed to be
   used with compliers, so I emphasize correct decoding of valid code quickly
   rather that catching every possible error.
   Note: This uses the expression function, so save input_line_pointer before
   calling.

   Sperry defines the semantics of address modes (and values)
   by a two-letter code, explained here.

     letter 1:   access type

       a         address calculation - no data access, registers forbidden
       b         branch displacement
       m         read - let go of bus - write back "modify"
       r         read
       w         write
       v         bit field address: like 'a' but registers are OK

     letter 2:   data type (i.e. width, alignment)

       b         byte
       w         word
       l         longword
       q         quadword (Even regs < 14 allowed) (if 12, you get a warning)
       -	 unconditional synthetic jbr operand
       ?	 simple synthetic reversible branch operand
       !	 complex synthetic reversible branch operand
       :	 complex synthetic non-reversible branch operand

   The '-?!:' letter 2's are not for external consumption. They are used
   by GAS for psuedo ops relaxing code.

   After parsing topP has:

     top_ndx:        -1, or the index register. eg 7=[R7]
     top_reg:        -1, or register number. eg 7 = R7 or (R7)
     top_mode:       The addressing mode byte. This byte, defines which of
                     the 11 modes opcode is.
     top_access:     Access type wanted for this operand 'b'branch ' '
                     no-instruction 'amrvw'
     top_width:      Operand width expected, one of "bwlq?-:!"
     exp_of_operand: The expression as parsed by expression()
     top_dispsize:   Number of bytes in the displacement if we can figure it
                     out and it's relevant.

   Need syntax checks built.  */

void
tip_op (char *optex,		/* The users text input, with one leading character.  */
	struct top *topP)	/* The tahoe instruction with some fields already set:
				   in: access, width
				   out: ndx, reg, mode, error, dispsize.  */
{
  int mode = 0;			/* This operand's mode.  */
  char segfault = *optex;	/* To keep the back parsing from freaking.  */
  char *point = optex + 1;	/* Parsing from front to back.  */
  char *end;			/* Parsing from back to front.  */
  int reg = -1;			/* major register, -1 means absent.  */
  int imreg = -1;		/* Major register in immediate mode.  */
  int ndx = -1;			/* index register number, -1 means absent.  */
  char dec_inc = ' ';		/* Is the SP auto-incremented '+' or
				   auto-decremented '-' or neither ' '.  */
  int immediate = 0;		/* 1 if '$' immediate mode.  */
  int call_width = 0;		/* If the caller casts the displacement.  */
  int abs_width = 0;		/* The width of the absolute displacement.  */
  int com_width = 0;		/* Displacement width required by branch.  */
  int deferred = 0;		/* 1 if '*' deferral is used.  */
  byte disp_size = 0;		/* How big is this operand. 0 == don't know.  */
  char *op_bad = "";		/* Bad operand error.  */
  char *tp, *temp, c;		/* Temporary holders.  */
  char access = topP->top_access;/* Save on a deref.  */
  char width = topP->top_width;
  int really_none = 0;		/* Empty expressions evaluate to 0
				   but I need to know if it's there or not.  */
  expressionS *expP;		/* -> expression values for this operand.  */

  /* Does this command restrict the displacement size.  */
  if (access == 'b')
    com_width = (width == 'b' ? 1 :
		 (width == 'w' ? 2 :
		  (width == 'l' ? 4 : 0)));

  *optex = '\0';		/* This is kind of a back stop for all
				   the searches to fail on if needed.  */
  if (*point == '*')
    {
      /* A dereference?  */
      deferred = 1;
      point++;
    }

  /* Force words into a certain mode.  */
  /* Using the ^ operator is ambiguous. If I have an absolute label
     called 'w' set to, say 2, and I have the expression 'w^1', do I get
     1, forced to be in word displacement mode, or do I get the value of
     'w' or'ed with 1 (3 in this case).
     The default is 'w' as an offset, so that's what I use.
     Stick with `, it does the same, and isn't ambig.  */

  if (*point != '\0' && ((point[1] == '^') || (point[1] == '`')))
    switch (*point)
      {
      case 'b':
      case 'B':
      case 'w':
      case 'W':
      case 'l':
      case 'L':
	if (com_width)
	  as_warn (_("Casting a branch displacement is bad form, and is ignored."));
	else
	  {
	    c = TOLOWER (*point);
	    call_width = ((c == 'b') ? 1 :
			  ((c == 'w') ? 2 : 4));
	  }
	point += 2;
	break;
      }

  /* Setting immediate mode.  */
  if (*point == '$')
    {
      immediate = 1;
      point++;
    }

  /* I've pulled off all the easy stuff off the front, move to the end and
     yank.  */

  for (end = point; *end != '\0'; end++)	/* Move to the end.  */
    ;

  if (end != point)		/* Null string?  */
    end--;

  if (end > point && *end == ' ' && end[-1] != '\'')
    end--;			/* Hop white space.  */

  /* Is this an index reg.  */
  if ((*end == ']') && (end[-1] != '\''))
    {
      temp = end;

      /* Find opening brace.  */
      for (--end; (*end != '[' && end != point); end--)
	;

      /* If I found the opening brace, get the index register number.  */
      if (*end == '[')
	{
	  tp = end + 1;		/* tp should point to the start of a reg.  */
	  ndx = tahoe_reg_parse (&tp);
	  if (tp != temp)
	    /* Reg. parse error.  */
	    ndx = -1;
	  else
	    /* Found it, move past brace.  */
	    end--;

	  if (ndx == -1)
	    {
	      op_bad = _("Couldn't parse the [index] in this operand.");
	      end = point;	/* Force all the rest of the tests to fail.  */
	    }
	}
      else
	{
	  op_bad = _("Couldn't find the opening '[' for the index of this operand.");
	  end = point;		/* Force all the rest of the tests to fail.  */
	}
    }

  /* Post increment? */
  if (*end == '+')
    {
      dec_inc = '+';
      /* was:    *end--; */
      end--;
    }

  /* Register in parens?  */
  if ((*end == ')') && (end[-1] != '\''))
    {
      temp = end;

      /* Find opening paren.  */
      for (--end; (*end != '(' && end != point); end--)
	;

      /* If I found the opening paren, get the register number.  */
      if (*end == '(')
	{
	  tp = end + 1;
	  reg = tahoe_reg_parse (&tp);
	  if (tp != temp)
	    {
	      /* Not a register, but could be part of the expression.  */
	      reg = -1;
	      /* Rest the pointer back.  */
	      end = temp;
	    }
	  else
	    /* Found the reg. move before opening paren.  */
	    end--;
	}
      else
	{
	  op_bad = _("Couldn't find the opening '(' for the deref of this operand.");
	  /* Force all the rest of the tests to fail.  */
	  end = point;
	}
    }

  /* Pre decrement?  */
  if (*end == '-')
    {
      if (dec_inc != ' ')
	{
	  op_bad = _("Operand can't be both pre-inc and post-dec.");
	  end = point;
	}
      else
	{
	  dec_inc = '-';
	  end--;
	}
    }

  /* Everything between point and end is the 'expression', unless it's
     a register name.  */
  c = end[1];
  end[1] = '\0';

  tp = point;
  /* Get the immediate register if it is there.  */
  imreg = tahoe_reg_parse (&point);
  if (*point != '\0')
    {
      /* If there is junk after point, then the it's not immediate reg.  */
      point = tp;
      imreg = -1;
    }

  if (imreg != -1 && reg != -1)
    op_bad = _("I parsed 2 registers in this operand.");

  /* Evaluate whats left of the expression to see if it's valid.
     Note again: This assumes that the calling expression has saved
     input_line_pointer. (Nag, nag, nag!).  */
  if (*op_bad == '\0')
    {
      /* Statement has no syntax goofs yet: let's sniff the expression.  */
      input_line_pointer = point;
      expP = &(topP->exp_of_operand);
      topP->seg_of_operand = expression (expP);
      switch (expP->X_op)
	{
	case O_absent:
	  /* No expression. For BSD4.2 compatibility, missing expression is
	     absolute 0.  */
	  expP->X_op = O_constant;
	  expP->X_add_number = 0;
	  really_none = 1;
	case O_constant:
	  /* For SEG_ABSOLUTE, we shouldn't need to set X_op_symbol,
	     X_add_symbol to any particular value.  */
	  /* But, we will program defensively. Since this situation occurs
	     rarely so it costs us little to do so.  */
	  expP->X_add_symbol = NULL;
	  expP->X_op_symbol = NULL;
	  /* How many bytes are needed to express this abs value?  */
	  abs_width =
	    ((((expP->X_add_number & 0xFFFFFF80) == 0)
	      || ((expP->X_add_number & 0xFFFFFF80) == 0xFFFFFF80)) ? 1 :
	     (((expP->X_add_number & 0xFFFF8000) == 0)
	      || ((expP->X_add_number & 0xFFFF8000) == 0xFFFF8000)) ? 2 : 4);

	case O_symbol:
	  break;

	default:
	  /* Major bug. We can't handle the case of an operator
	     expression in a synthetic opcode variable-length
	     instruction.  We don't have a frag type that is smart
	     enough to relax an operator, and so we just force all
	     operators to behave like SEG_PASS1s.  Clearly, if there is
	     a demand we can invent a new or modified frag type and
	     then coding up a frag for this case will be easy.  */
	  need_pass_2 = 1;
	  op_bad = _("Can't relocate expression error.");
	  break;

	case O_big:
	  /* This is an error. Tahoe doesn't allow any expressions
	     bigger that a 32 bit long word. Any bigger has to be referenced
	     by address.  */
	  op_bad = _("Expression is too large for a 32 bits.");
	  break;
	}

      if (*input_line_pointer != '\0')
	op_bad = _("Junk at end of expression.");
    }

  end[1] = c;

  /* I'm done, so restore optex.  */
  *optex = segfault;

  /* At this point in the game, we (in theory) have all the components of
     the operand at least parsed. Now it's time to check for syntax/semantic
     errors, and build the mode.
     This is what I have:
       deferred = 1 if '*'
       call_width = 0,1,2,4
       abs_width = 0,1,2,4
       com_width = 0,1,2,4
       immediate = 1 if '$'
       ndx = -1 or reg num
       dec_inc = '-' or '+' or ' '
       reg = -1 or reg num
       imreg = -1 or reg num
       topP->exp_of_operand
       really_none.  */
  /* Is there a displacement size?  */
  disp_size = (call_width ? call_width :
	       (com_width ? com_width :
		abs_width ? abs_width : 0));

  if (*op_bad == '\0')
    {
      if (imreg != -1)
	{
	  /* Rn */
	  mode = TAHOE_DIRECT_REG;
	  if (deferred
	      || immediate
	      || (dec_inc != ' ')
	      || (reg != -1)
	      || !really_none)
	    op_bad = _("Syntax error in direct register mode.");
	  else if (ndx != -1)
	    op_bad = _("You can't index a register in direct register mode.");
	  else if (imreg == SP_REG && access == 'r')
	    op_bad =
	      _("SP can't be the source operand with direct register addressing.");
	  else if (access == 'a')
	    op_bad = _("Can't take the address of a register.");
	  else if (access == 'b')
	    op_bad = _("Direct Register can't be used in a branch.");
	  else if (width == 'q' && ((imreg % 2) || (imreg > 13)))
	    op_bad = _("For quad access, the register must be even and < 14.");
	  else if (call_width)
	    op_bad = _("You can't cast a direct register.");

	  if (*op_bad == '\0')
	    {
	      /* No errors, check for warnings.  */
	      if (width == 'q' && imreg == 12)
		as_warn (_("Using reg 14 for quadwords can tromp the FP register."));

	      reg = imreg;
	    }

	  /* We know: imm = -1.  */
	}
      else if (dec_inc == '-')
	{
	  /* -(SP) */
	  mode = TAHOE_AUTO_DEC;
	  if (deferred || immediate || !really_none)
	    op_bad = _("Syntax error in auto-dec mode.");
	  else if (ndx != -1)
	    op_bad = _("You can't have an index auto dec mode.");
	  else if (access == 'r')
	    op_bad = _("Auto dec mode cant be used for reading.");
	  else if (reg != SP_REG)
	    op_bad = _("Auto dec only works of the SP register.");
	  else if (access == 'b')
	    op_bad = _("Auto dec can't be used in a branch.");
	  else if (width == 'q')
	    op_bad = _("Auto dec won't work with quadwords.");

	  /* We know: imm = -1, dec_inc != '-'.  */
	}
      else if (dec_inc == '+')
	{
	  if (immediate || !really_none)
	    op_bad = _("Syntax error in one of the auto-inc modes.");
	  else if (deferred)
	    {
	      /* *(SP)+ */
	      mode = TAHOE_AUTO_INC_DEFERRED;
	      if (reg != SP_REG)
		op_bad = _("Auto inc deferred only works of the SP register.");
	      else if (ndx != -1)
		op_bad = _("You can't have an index auto inc deferred mode.");
	      else if (access == 'b')
		op_bad = _("Auto inc can't be used in a branch.");
	    }
	  else
	    {
	      /* (SP)+ */
	      mode = TAHOE_AUTO_INC;
	      if (access == 'm' || access == 'w')
		op_bad = _("You can't write to an auto inc register.");
	      else if (reg != SP_REG)
		op_bad = _("Auto inc only works of the SP register.");
	      else if (access == 'b')
		op_bad = _("Auto inc can't be used in a branch.");
	      else if (width == 'q')
		op_bad = _("Auto inc won't work with quadwords.");
	      else if (ndx != -1)
		op_bad = _("You can't have an index in auto inc mode.");
	    }

	  /* We know: imm = -1, dec_inc == ' '.  */
	}
      else if (reg != -1)
	{
	  if ((ndx != -1) && (reg == SP_REG))
	    op_bad = _("You can't index the sp register.");
	  if (deferred)
	    {
	      /* *<disp>(Rn) */
	      mode = TAHOE_REG_DISP_DEFERRED;
	      if (immediate)
		op_bad = _("Syntax error in register displaced mode.");
	    }
	  else if (really_none)
	    /* (Rn) */
	    mode = TAHOE_REG_DEFERRED;
	  else
	    /* <disp>(Rn) */
	    mode = TAHOE_REG_DISP;

	  /* We know: imm = -1, dec_inc == ' ', Reg = -1 */
	}
      else
	{
	  if (really_none)
	    op_bad = _("An offest is needed for this operand.");
	  if (deferred && immediate)
	    {
	      /* *$<ADDR> */
	      mode = TAHOE_ABSOLUTE_ADDR;
	      disp_size = 4;
	    }
	  else if (immediate)
	    {
	      /* $<disp> */
	      mode = TAHOE_IMMEDIATE;
	      if (ndx != -1)
		op_bad = _("You can't index a register in immediate mode.");
	      if (access == 'a')
		op_bad = _("Immediate access can't be used as an address.");
	      /* ponder the wisdom of a cast because it doesn't do any good.  */
	    }
	  else if (deferred)
	    /* *<disp> */
	    mode = TAHOE_DISP_REL_DEFERRED;
	  else
	    /* <disp> */
	    mode = TAHOE_DISPLACED_RELATIVE;
	}
    }

  /* At this point, all the errors we can do have be checked for.
     We can build the 'top'.  */
  topP->top_ndx = ndx;
  topP->top_reg = reg;
  topP->top_mode = mode;
  topP->top_error = op_bad;
  topP->top_dispsize = disp_size;
}

/* This converts a string into a tahoe instruction.
   The string must be a bare single instruction in tahoe (with BSD4 frobs)
   format.
   It provides at most one fatal error message (which stops the scan)
   some warning messages as it finds them.
   The tahoe instruction is returned in exploded form.

   The exploded instruction is returned to a struct tit of your choice.
   #include "tahoe-inst.h" to know what a struct tit is.  */

static void
tip (struct tit *titP,		/* We build an exploded instruction here.  */
     char *instring)		/* Text of a vax instruction: we modify.  */
{
  struct tot_wot *twP = NULL;	/* How to bit-encode this opcode.  */
  char *p;			/* 1/skip whitespace.2/scan vot_how.  */
  char *q;
  unsigned char count;		/* Counts number of operands seen.  */
  struct top *operandp;		/* Scan operands in struct tit.  */
  char *alloperr = "";		/* Error over all operands.  */
  char c;			/* Remember char, (we clobber it with '\0' temporarily).  */
  char *save_input_line_pointer;

  if (*instring == ' ')
    ++instring;			/* Skip leading whitespace.  */
  for (p = instring; *p && *p != ' '; p++)
    ;

  /* Scanned up to end of operation-code.  */
  /* Operation-code is ended with whitespace.  */
  if (p == instring)
    {
      titP->tit_error = _("No operator");
      count = 0;
      titP->tit_opcode = 0;
    }
  else
    {
      c = *p;
      *p = '\0';

      /* Here with instring pointing to what better be an op-name, and p
         pointing to character just past that.
	 We trust instring points to an op-name, with no whitespace.  */
      twP = (struct tot_wot *) hash_find (op_hash, instring);
      /* Restore char after op-code.  */
      *p = c;
      if (twP == 0)
	{
	  titP->tit_error = _("Unknown operator");
	  count = 0;
	  titP->tit_opcode = 0;
	}
      else
	{
	  /* We found a match! So let's pick up as many operands as the
	     instruction wants, and even gripe if there are too many.
	     We expect comma to separate each operand.
	     We let instring track the text, while p tracks a part of the
	     struct tot.  */

	  /* No operands seen yet.  */
	  count = 0;
	  /* Point past the operation code.  */
	  instring = p + (*p != '\0');
	  /* tip_op() screws with the input_line_pointer, so save it before
	     I jump in.  */
	  save_input_line_pointer = input_line_pointer;

	  for (p = twP->args, operandp = titP->tit_operand;
	       !*alloperr && *p;
	       operandp++, p += 2)
	    {
	      /* Here to parse one operand. Leave instring pointing just
	         past any one ',' that marks the end of this operand.  */
	      if (!p[1])
		as_fatal (_("Compiler bug: ODD number of bytes in arg structure %s."),
			  twP->args);
	      else if (*instring)
		{
		  for (q = instring; (*q != ',' && *q != '\0'); q++)
		    /* Jump quoted characters.  */
		    if (*q == '\'' && q[1] != '\0')
		      q++;

		  c = *q;
		  /* Q points to ',' or '\0' that ends argument. C is that
		     character.  */
		  *q = '\0';
		  operandp->top_access = p[0];
		  operandp->top_width = p[1];
		  tip_op (instring - 1, operandp);
		  /* Restore input text.  */
		  *q = c;

		  if (*(operandp->top_error))
		    alloperr = operandp->top_error;

		  /* Next operand (if any).  */
		  instring = q + (c ? 1 : 0);
		  /*  Won another argument, may have an operr.  */
		  count++;
		}
	      else
		alloperr = _("Not enough operands");
	    }
	  /* Restore the pointer.  */
	  input_line_pointer = save_input_line_pointer;

	  if (!*alloperr)
	    {
	      /* Skip whitespace.  */
	      if (*instring == ' ')
		instring ++;

	      if (*instring)
		alloperr = _("Too many operands");
	    }

	  titP->tit_error = alloperr;
	}
    }

  titP->tit_opcode = twP->code;
  titP->tit_operands = count;
}

void
md_assemble (char *instruction_string)
{
  char *p;
  struct top *operandP;		/* An operand. Scans all operands.  */
  expressionS *expP;		/* -> expression values for this operand.  */
  /* These refer to an instruction operand expression.  */
  segT to_seg;			/* Target segment of the address.	 */
  valueT this_add_number;
  symbolS *this_add_symbol;	/* +ve (minuend) symbol.  */
  char *opcodeP;		/* Where it is in a frag.  */
  int dispsize;			/* From top_dispsize: tahoe_operand_width (in bytes).  */
  int is_undefined;		/* 1 if operand expression's segment not known yet.  */
  int pc_rel;			/* Is this operand pc relative?  */

  /* Decode the operand.  */
  tip (&t, instruction_string);

  /* Check to see if this operand decode properly.
     Notice that we haven't made any frags yet.
     If it goofed, then this instruction will wedge in any pass,
     and we can safely flush it, without causing interpass symbol phase
     errors. That is, without changing label values in different passes.  */

  if (*t.tit_error)
    as_warn (_("Ignoring statement due to \"%s\""), t.tit_error);
  else
    {
      /* We saw no errors in any operands - try to make frag(s).  */
      /* Emit op-code.  */
      /* Remember where it is, in case we want to modify the op-code later.  */
      opcodeP = frag_more (1);
      *opcodeP = t.tit_opcode;
      /* Now do each operand.  */
      for (operandP = t.tit_operand;
	   operandP < t.tit_operand + t.tit_operands;
	   operandP++)
	{			/* for each operand */
	  expP = &(operandP->exp_of_operand);
	  if (operandP->top_ndx >= 0)
	    {
	      /* Indexed addressing byte
		 Legality of indexed mode already checked: it is OK.  */
	      FRAG_APPEND_1_CHAR (0x40 + operandP->top_ndx);
	    }			/* if(top_ndx>=0) */

	  /* Here to make main operand frag(s).  */
	  this_add_number = expP->X_add_number;
	  this_add_symbol = expP->X_add_symbol;
	  to_seg = operandP->seg_of_operand;
	  know (to_seg == SEG_UNKNOWN \
		|| to_seg == SEG_ABSOLUTE \
		|| to_seg == SEG_DATA \
		|| to_seg == SEG_TEXT \
		|| to_seg == SEG_BSS);
	  is_undefined = (to_seg == SEG_UNKNOWN);
	  /* Do we know how big this operand is?  */
	  dispsize = operandP->top_dispsize;
	  pc_rel = 0;
	  /* Deal with the branch possibilities. (Note, this doesn't include jumps.)  */
	  if (operandP->top_access == 'b')
	    {
	      /* Branches must be expressions. A psuedo branch can also jump to
		 an absolute address.  */
	      if (to_seg == now_seg || is_undefined)
		{
		  /* If is_undefined, then it might BECOME now_seg by relax time.  */
		  if (dispsize)
		    {
		      /* I know how big the branch is supposed to be (it's a normal
			 branch), so I set up the frag, and let GAS do the rest.  */
		      p = frag_more (dispsize);
		      fix_new (frag_now, p - frag_now->fr_literal,
			       this_add_symbol, this_add_number,
			       size_to_fx (dispsize, 1),
			       NULL);
		    }
		  else
		    {
		      /* If we don't know how big it is, then its a synthetic branch,
			 so we set up a simple relax state.  */
		      switch (operandP->top_width)
			{
			case TAHOE_WIDTH_CONDITIONAL_JUMP:
			  /* Simple (conditional) jump. I may have to reverse the
			     condition of opcodeP, and then jump to my destination.
			     I set 1 byte aside for the branch off set, and could need 6
			     more bytes for the pc_rel jump.  */
			  frag_var (rs_machine_dependent, 7, 1,
				    ENCODE_RELAX (STATE_CONDITIONAL_BRANCH,
				    is_undefined ? STATE_UNDF : STATE_BYTE),
				 this_add_symbol, this_add_number, opcodeP);
			  break;
			case TAHOE_WIDTH_ALWAYS_JUMP:
			  /* Simple (unconditional) jump. I may have to convert this to
			     a word branch, or an absolute jump.  */
			  frag_var (rs_machine_dependent, 5, 1,
				    ENCODE_RELAX (STATE_ALWAYS_BRANCH,
				    is_undefined ? STATE_UNDF : STATE_BYTE),
				 this_add_symbol, this_add_number, opcodeP);
			  break;
			  /* The smallest size for the next 2 cases is word.  */
			case TAHOE_WIDTH_BIG_REV_JUMP:
			  frag_var (rs_machine_dependent, 8, 2,
				    ENCODE_RELAX (STATE_BIG_REV_BRANCH,
				    is_undefined ? STATE_UNDF : STATE_WORD),
				    this_add_symbol, this_add_number,
				    opcodeP);
			  break;
			case TAHOE_WIDTH_BIG_NON_REV_JUMP:
			  frag_var (rs_machine_dependent, 10, 2,
				    ENCODE_RELAX (STATE_BIG_NON_REV_BRANCH,
				    is_undefined ? STATE_UNDF : STATE_WORD),
				    this_add_symbol, this_add_number,
				    opcodeP);
			  break;
			default:
			  as_fatal (_("Compliler bug: Got a case (%d) I wasn't expecting."),
				    operandP->top_width);
			}
		    }
		}
	      else
		{
		  /* to_seg != now_seg && to_seg != seg_unknown (still in branch)
		     In other words, I'm jumping out of my segment so extend the
		     branches to jumps, and let GAS fix them.  */

		  /* These are "branches" what will always be branches around a jump
		     to the correct address in real life.
		     If to_seg is SEG_ABSOLUTE, just encode the branch in,
		     else let GAS fix the address.  */

		  switch (operandP->top_width)
		    {
		      /* The theory:
			 For SEG_ABSOLUTE, then mode is ABSOLUTE_ADDR, jump
			 to that address (not pc_rel).
			 For other segs, address is a long word PC rel jump.  */
		    case TAHOE_WIDTH_CONDITIONAL_JUMP:
		      /* b<cond> */
		      /* To reverse the condition in a TAHOE branch,
			 complement bit 4 */
		      *opcodeP ^= 0x10;
		      p = frag_more (7);
		      *p++ = 6;
		      *p++ = TAHOE_JMP;
		      *p++ = (operandP->top_mode ==
			      TAHOE_ABSOLUTE_ADDR ? TAHOE_ABSOLUTE_ADDR :
			      TAHOE_PC_REL_LONG);
		      fix_new (frag_now, p - frag_now->fr_literal,
			       this_add_symbol, this_add_number,
		       (to_seg != SEG_ABSOLUTE) ? FX_PCREL32 : FX_32, NULL);

		      /* Now (eg)	BLEQ	1f
		                        JMP	foo
			 	1:    */
		      break;

		    case TAHOE_WIDTH_ALWAYS_JUMP:
		      /* Br, just turn it into a jump.  */
		      *opcodeP = TAHOE_JMP;
		      p = frag_more (5);
		      *p++ = (operandP->top_mode ==
			      TAHOE_ABSOLUTE_ADDR ? TAHOE_ABSOLUTE_ADDR :
			      TAHOE_PC_REL_LONG);
		      fix_new (frag_now, p - frag_now->fr_literal,
			       this_add_symbol, this_add_number,
		       (to_seg != SEG_ABSOLUTE) ? FX_PCREL32 : FX_32, NULL);
		      /* Now (eg) JMP foo.  */
		      break;

		    case TAHOE_WIDTH_BIG_REV_JUMP:
		      p = frag_more (8);
		      *opcodeP ^= 0x10;
		      *p++ = 0;
		      *p++ = 6;
		      *p++ = TAHOE_JMP;
		      *p++ = (operandP->top_mode ==
			      TAHOE_ABSOLUTE_ADDR ? TAHOE_ABSOLUTE_ADDR :
			      TAHOE_PC_REL_LONG);
		      fix_new (frag_now, p - frag_now->fr_literal,
			       this_add_symbol, this_add_number,
		       (to_seg != SEG_ABSOLUTE) ? FX_PCREL32 : FX_32, NULL);
		      /* Now (eg)	ACBx	1f
		        		JMP     foo
		        	1:  */
		      break;

		    case TAHOE_WIDTH_BIG_NON_REV_JUMP:
		      p = frag_more (10);
		      *p++ = 0;
		      *p++ = 2;
		      *p++ = TAHOE_BRB;
		      *p++ = 6;
		      *p++ = TAHOE_JMP;
		      *p++ = (operandP->top_mode ==
			      TAHOE_ABSOLUTE_ADDR ? TAHOE_ABSOLUTE_ADDR :
			      TAHOE_PC_REL_LONG);
		      fix_new (frag_now, p - frag_now->fr_literal,
			       this_add_symbol, this_add_number,
		       (to_seg != SEG_ABSOLUTE) ? FX_PCREL32 : FX_32, NULL);
		      /* Now (eg)	xOBxxx	1f
		        		BRB	2f
		        	1:	JMP	@@#foo
		        	2:       */
		      break;
		    case 'b':
		    case 'w':
		      as_warn (_("Real branch displacements must be expressions."));
		      break;
		    default:
		      as_fatal (_("Complier error: I got an unknown synthetic branch :%c"),
				operandP->top_width);
		      break;
		    }
		}
	    }
	  else
	    {
	      /* It ain't a branch operand.  */
	      switch (operandP->top_mode)
		{
		  /* Auto-foo access, only works for one reg (SP)
		     so the only thing needed is the mode.  */
		case TAHOE_AUTO_DEC:
		case TAHOE_AUTO_INC:
		case TAHOE_AUTO_INC_DEFERRED:
		  FRAG_APPEND_1_CHAR (operandP->top_mode);
		  break;

		  /* Numbered Register only access. Only thing needed is the
		     mode + Register number.  */
		case TAHOE_DIRECT_REG:
		case TAHOE_REG_DEFERRED:
		  FRAG_APPEND_1_CHAR (operandP->top_mode + operandP->top_reg);
		  break;

		  /* An absolute address. It's size is always 5 bytes.
		     (mode_type + 4 byte address).  */
		case TAHOE_ABSOLUTE_ADDR:
		  know ((this_add_symbol == NULL));
		  p = frag_more (5);
		  *p = TAHOE_ABSOLUTE_ADDR;
		  md_number_to_chars (p + 1, this_add_number, 4);
		  break;

		  /* Immediate data. If the size isn't known, then it's an address
		     + and offset, which is 4 bytes big.  */
		case TAHOE_IMMEDIATE:
		  if (this_add_symbol != NULL)
		    {
		      p = frag_more (5);
		      *p++ = TAHOE_IMMEDIATE_LONGWORD;
		      fix_new (frag_now, p - frag_now->fr_literal,
			       this_add_symbol, this_add_number,
			       FX_32, NULL);
		    }
		  else
		    {
		      /* It's an integer, and I know it's size.  */
		      if ((unsigned) this_add_number < 0x40)
			/* Will it fit in a literal?  */
			FRAG_APPEND_1_CHAR ((byte) this_add_number);
		      else
			{
			  p = frag_more (dispsize + 1);
			  switch (dispsize)
			    {
			    case 1:
			      *p++ = TAHOE_IMMEDIATE_BYTE;
			      *p = (byte) this_add_number;
			      break;
			    case 2:
			      *p++ = TAHOE_IMMEDIATE_WORD;
			      md_number_to_chars (p, this_add_number, 2);
			      break;
			    case 4:
			      *p++ = TAHOE_IMMEDIATE_LONGWORD;
			      md_number_to_chars (p, this_add_number, 4);
			      break;
			    }
			}
		    }
		  break;

		  /* Distance from the PC. If the size isn't known, we have to relax
		     into it. The difference between this and disp(sp) is that
		     this offset is pc_rel, and disp(sp) isn't.
		     Note the drop through code.  */

		case TAHOE_DISPLACED_RELATIVE:
		case TAHOE_DISP_REL_DEFERRED:
		  operandP->top_reg = PC_REG;
		  pc_rel = 1;

		  /* Register, plus a displacement mode. Save the register number,
		     and weather its deffered or not, and relax the size if it isn't
		     known.  */
		case TAHOE_REG_DISP:
		case TAHOE_REG_DISP_DEFERRED:
		  if (operandP->top_mode == TAHOE_DISP_REL_DEFERRED
		      || operandP->top_mode == TAHOE_REG_DISP_DEFERRED)
		    /* Deffered mode is always 0x10 higher than it's non-deffered sibling.  */
		    operandP->top_reg += 0x10;

		  /* Is this a value out of this segment?
		     The first part of this conditional is a cludge to make gas
		     produce the same output as 'as' when there is a lable, in
		     the current segment, displacing a register. It's strange,
		     and no one in their right mind would do it, but it's easy
		     to cludge.  */
		  if ((dispsize == 0 && !pc_rel)
		      || (to_seg != now_seg && !is_undefined && to_seg != SEG_ABSOLUTE))
		    dispsize = 4;

		  if (dispsize == 0)
		    {
		      /* We have a SEG_UNKNOWN symbol, or the size isn't cast.
		         It might turn out to be in the same segment as
		         the instruction, permitting relaxation.  */
		      p = frag_var (rs_machine_dependent, 5, 2,
				    ENCODE_RELAX (STATE_PC_RELATIVE,
				    is_undefined ? STATE_UNDF : STATE_BYTE),
				    this_add_symbol, this_add_number, 0);
		      *p = operandP->top_reg;
		    }
		  else
		    {
		      /* Either this is an abs, or a cast.  */
		      p = frag_more (dispsize + 1);
		      switch (dispsize)
			{
			case 1:
			  *p = TAHOE_PC_OR_BYTE + operandP->top_reg;
			  break;
			case 2:
			  *p = TAHOE_PC_OR_WORD + operandP->top_reg;
			  break;
			case 4:
			  *p = TAHOE_PC_OR_LONG + operandP->top_reg;
			  break;
			};
		      fix_new (frag_now, p + 1 - frag_now->fr_literal,
			       this_add_symbol, this_add_number,
			       size_to_fx (dispsize, pc_rel), NULL);
		    }
		  break;
		default:
		  as_fatal (_("Barf, bad mode %x\n"), operandP->top_mode);
		}
	    }
	}
    }
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name)
{
  return 0;
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment, valueT size)
{
  /* Round all sects to multiple of 8.  */
  return ((size + 7) & ~7);
}

/* Exactly what point is a PC-relative offset relative TO?
   On the sparc, they're relative to the address of the offset, plus
   its size.  This gets us to the following instruction.
   (??? Is this right?  FIXME-SOON) */

long
md_pcrel_from (fixS *fixP)
{
  return (((fixP->fx_type == FX_8
	    || fixP->fx_type == FX_PCREL8)
	   ? 1
	   : ((fixP->fx_type == FX_16
	       || fixP->fx_type == FX_PCREL16)
	      ? 2
	      : ((fixP->fx_type == FX_32
		  || fixP->fx_type == FX_PCREL32)
		 ? 4
		 : 0))) + fixP->fx_where + fixP->fx_frag->fr_address);
}

int
tc_is_pcrel (fixS *fixP)
{
  /* Should never be called.  */
  know (0);
  return 0;
}
@


1.18
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@@


1.17
log
@Update the address and phone number of the FSF
@
text
@d460 1
a460 1
md_apply_fix3 (fixS *fixP ATTRIBUTE_UNUSED,
@


1.16
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.15
log
@update copyright dates
@
text
@d4 1
a4 1
   2003, 2004 Free Software Foundation, Inc.
d22 1
d35 2
a36 2
#define TIT_MAX_OPERANDS (4)	/* maximum number of operands in one
				   single tahoe instruction */
d38 1
a38 1
struct top			/* tahoe instruction operand */
d40 2
a41 2
    int top_ndx;		/* -1, or index register. eg 7=[R7] */
    int top_reg;		/* -1, or register number. eg 7 = R7 or (R7) */
d46 2
a47 2
				   'b'branch ' 'no-instruction 'amrvw' */
    char top_width;		/* Operand width expected, one of "bwlq?-:!" */
d49 1
a49 1
    char * top_error;		/* Say if operand is inappropriate         */
d51 1
a51 1
    segT seg_of_operand;	/* segment as returned by expression()*/
d53 1
a53 1
    expressionS exp_of_operand;	/* The expression as parsed by expression()*/
d56 1
a56 1
				   can figure it out */
d61 2
a62 2
#define TAHOE_DIRECT_REG (0x50)
#define TAHOE_REG_DEFERRED (0x60)
d64 2
a65 2
#define TAHOE_REG_DISP (0xE0)
#define TAHOE_REG_DISP_DEFERRED (0xF0)
d67 12
a78 12
#define TAHOE_IMMEDIATE (0x8F)
#define TAHOE_IMMEDIATE_BYTE (0x88)
#define TAHOE_IMMEDIATE_WORD (0x89)
#define TAHOE_IMMEDIATE_LONGWORD (0x8F)
#define TAHOE_ABSOLUTE_ADDR (0x9F)

#define TAHOE_DISPLACED_RELATIVE (0xEF)
#define TAHOE_DISP_REL_DEFERRED (0xFF)

#define TAHOE_AUTO_DEC (0x7E)
#define TAHOE_AUTO_INC (0x8E)
#define TAHOE_AUTO_INC_DEFERRED (0x9E)
d90 4
a93 4
#define TAHOE_JMP (0x71)
#define TAHOE_PC_REL_LONG (0xEF)
#define TAHOE_BRB (0x11)
#define TAHOE_BRW (0x13)
d96 3
a98 3
#define TAHOE_PC_OR_BYTE (0xA0)
#define TAHOE_PC_OR_WORD (0xC0)
#define TAHOE_PC_OR_LONG (0xE0)
d105 2
a106 2
  struct top tit_operand[TIT_MAX_OPERANDS];	/* Operands */
  char *tit_error;		/* "" or fatal error text */
d112 1
a112 2
   Not part of gas yet.
   */
d116 1
a116 1
/* This is the number to put at the beginning of the a.out file */
d126 1
a126 1
/* Chars that can be used to separate mant from exp in floating point nums */
d139 1
a139 2
   (The tahoe has plenty of room, so the change currently isn't needed.)
   */
d154 16
a169 18
/*
 * For Tahoe, relative addresses of "just the right length" are pretty easy.
 * The branch displacement is always the last operand, even in
 * synthetic instructions.
 * For Tahoe, we encode the relax_substateTs (in e.g. fr_substate) as:
 *
 *		    4       3       2       1       0	     bit number
 *	---/ /--+-------+-------+-------+-------+-------+
 *		|     what state ?	|  how long ?	|
 *	---/ /--+-------+-------+-------+-------+-------+
 *
 * The "how long" bits are 00=byte, 01=word, 10=long.
 * This is a Un*x convention.
 * Not all lengths are legit for a given value of (what state).
 * The four states are listed below.
 * The "how long" refers merely to the displacement length.
 * The address usually has some constant bytes in it as well.
 *
d171 2
a172 2
States for Tahoe address relaxing.
1.	TAHOE_WIDTH_ALWAYS_JUMP (-)
d181 1
a181 1
2.	TAHOE_WIDTH_CONDITIONAL_JUMP (?)
d200 1
a200 1
3.	TAHOE_WIDTH_BIG_REV_JUMP (!)
d209 1
a209 1
4.	TAHOE_WIDTH_BIG_NON_REV_JUMP (:)
d221 7
a227 7
We need to modify the opcode is for class 1, 2 and 3 instructions.
After relax() we may complement the 4th bit of 2 or 3 to reverse sense of
branch.

We sometimes store context in the operand literal. This way we can figure out
after relax() what the original addressing mode was. (Was is pc_rel, or
pc_rel_disp? That sort of thing.) */
d237 4
a240 4
#define BF (1+ 127)
#define BB (1+-128)
#define WF (2+ 32767)
#define WB (2+-32768)
d243 1
a243 1
#define C(a,b) ENCODE_RELAX(a,b)
d246 2
a247 2
#define RELAX_STATE(s) ((s) >> 2)
#define RELAX_LENGTH(s) ((s) & 3)
d249 10
a258 10
#define STATE_ALWAYS_BRANCH             (1)
#define STATE_CONDITIONAL_BRANCH        (2)
#define STATE_BIG_REV_BRANCH            (3)
#define STATE_BIG_NON_REV_BRANCH        (4)
#define STATE_PC_RELATIVE		(5)

#define STATE_BYTE                      (0)
#define STATE_WORD                      (1)
#define STATE_LONG                      (2)
#define STATE_UNDF                      (3)	/* Symbol undefined in pass1 */
d267 1
a267 1
  },				/* error sentinel   0,0	*/
d270 1
a270 1
  },				/* unused	    0,1	*/
d273 1
a273 1
  },				/* unused	    0,2	*/
d276 1
a276 1
  },				/* unused	    0,3	*/
d281 1
a281 1
  },				/* brb B`foo	    1,0 */
d284 1
a284 1
  },				/* brw W`foo	    1,1 */
d290 1
a290 1
  },				/* unused	    1,3 */
d305 1
a305 1
  },				/* unused	    2,3 */
d310 1
a310 1
  },				/* unused	    3,0 */
d319 1
a319 1
  },				/* unused	    3,3 */
d327 1
a327 1
  },				/* unused	    4,0 */
d336 1
a336 1
  },				/* unused	    4,3 */
d351 1
a351 1
  },				/* unused	    5,3 */
d359 1
a359 1
/* End relax stuff */
d366 1
d368 1
a368 1
md_begin ()
d388 3
a390 1
struct option md_longopts[] = {
d393 1
d397 1
a397 3
md_parse_option (c, arg)
     int c;
     char *arg;
d433 1
a433 2
md_show_usage (stream)
     FILE *stream;
d448 7
a454 6
   They exist primarily for cross assembly purpose.  */
void				/* Knows about order of bytes in address.  */
md_number_to_chars (con, value, nbytes)
     char con[];		/* Return 'nbytes' of chars here.  */
     valueT value;		/* The value of the bits.  */
     int nbytes;		/* Number of bytes in the output.  */
a458 12
#ifdef comment
void				/* Knows about order of bytes in address.  */
md_number_to_imm (con, value, nbytes)
     char con[];		/* Return 'nbytes' of chars here.  */
     long int value;		/* The value of the bits.  */
     int nbytes;		/* Number of bytes in the output.  */
{
  md_number_to_chars (con, value, nbytes);
}

#endif /* comment */

d460 3
a462 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP ATTRIBUTE_UNUSED;
     valueT * valP ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED:
d468 4
a471 5
void				/* Knows about order of bytes in address.  */
md_number_to_disp (con, value, nbytes)
     char con[];		/* Return 'nbytes' of chars here.  */
     long int value;		/* The value of the bits.  */
     int nbytes;		/* Number of bytes in the output.  */
d476 4
a479 5
void				/* Knows about order of bytes in address.  */
md_number_to_field (con, value, nbytes)
     char con[];		/* Return 'nbytes' of chars here.  */
     long int value;		/* The value of the bits.  */
     int nbytes;		/* Number of bytes in the output.  */
a491 32
#if comment
void
md_ri_to_chars (ri_p, ri)
     struct relocation_info *ri_p, ri;
{
  byte the_bytes[sizeof (struct relocation_info)];
  /* The reason I can't just encode these directly into ri_p is that
     ri_p may point to ri.  */

  /* This is easy */
  md_number_to_chars (the_bytes, ri.r_address, sizeof (ri.r_address));

  /* now the fun stuff */
  the_bytes[4] = (ri.r_symbolnum >> 16) & 0x0ff;
  the_bytes[5] = (ri.r_symbolnum >> 8) & 0x0ff;
  the_bytes[6] = ri.r_symbolnum & 0x0ff;
  the_bytes[7] = (((ri.r_extern << 4) & 0x10) | ((ri.r_length << 5) & 0x60) |
		  ((ri.r_pcrel << 7) & 0x80)) & 0xf0;

  bcopy (the_bytes, (char *) ri_p, sizeof (struct relocation_info));
}

#endif /* comment */

/* Put the bits in an order that a tahoe will understand, despite the ordering
   of the native machine.
   On Tahoe: first 4 bytes are normal unsigned big endian long,
   next three bytes are symbolnum, in kind of 3 byte big endian (least sig. byte last).
   The last byte is broken up with bit 7 as pcrel,
   	bits 6 & 5 as length,
	bit 4 as extern and the last nibble as 'undefined'.  */

d493 3
a495 4
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
d523 1
a523 1
/* Relocate byte stuff */
d529 5
a533 5
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
d543 1
a543 1
const int md_reloc_size = 8;	/* Size of relocation record */
d546 5
a550 5
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
d564 1
d566 1
a566 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP;
     segT segment_type;		/* N_DATA or N_TEXT.  */
d667 8
a674 11
/*
 *			md_convert_frag();
 *
 * Called after relax() is finished.
 * In:	Address of frag.
 *	fr_type == rs_machine_dependent.
 *	fr_subtype is what the address relaxed to.
 *
 * Out:	Any fixSs and constants are set up.
 *	Caller will turn frag into a ".space 0".
 */
d676 12
a687 15
md_convert_frag (headers, seg, fragP)
     object_headers *headers;
     segT seg;
     register fragS *fragP;
{
  register char *addressP;	/* -> _var to change.  */
  register char *opcodeP;	/* -> opcode char(s) to change.  */
  register short int extension = 0;	/* Size of relaxed address.
				   Added to fr_fix: incl. ALL var chars.  */
  register symbolS *symbolP;
  register long int where;
  register long int address_of_var;
  /* Where, in file space, is _var of *fragP? */
  register long int target_address;
  /* Where, in file space, does addr point? */
d697 1
d702 1
a702 1
       mode. To set up the right mode, just OR the size of this displacement */
d730 1
a730 1
      *addressP++ = 3;		/* Jump over word branch */
d799 1
a799 1
}				/* md_convert_frag */
d808 13
a820 14
/*
 * Parse the string pointed to by START
 * If it represents a valid register, point START to the character after
 * the last valid register char, and return the register number (0-15).
 * If invalid, leave START alone, return -1.
 * The format has to be exact. I don't do things like eat leading zeros
 * or the like.
 * Note: This doesn't check for the next character in the string making
 * this invalid. Ex: R123 would return 12, it's the callers job to check
 * what start is point to apon return.
 *
 * Valid registers are R1-R15, %1-%15, FP (13), SP (14), PC (15)
 * Case doesn't matter.
 */
d822 1
a822 2
tahoe_reg_parse (start)
     char **start;		/* A pointer to the string to parse.  */
d824 2
a825 2
  register char *regpoint = *start;
  register int regnum = -1;
d842 1
a842 3
		{		/* Number too big? */
		  regnum = -1;
		}
d846 1
a846 1
    case 'F':			/* Is it the FP */
d855 1
a855 1
    case 's':			/* How about the SP */
d864 1
a864 1
    case 'p':			/* OR the PC even */
d876 5
a880 5
    {				/* No error, so move string pointer */
      *start = regpoint;
    }
  return regnum;		/* Return results */
}				/* tahoe_reg_parse */
d882 53
a934 55
/*
 * This chops up an operand and figures out its modes and stuff.
 * It's a little touchy about extra characters.
 * Optex to start with one extra character so it can be overwritten for
 * the backward part of the parsing.
 * You can't put a bunch of extra characters in side to
 * make the command look cute. ie: * foo ( r1 ) [  r0 ]
 * If you like doing a lot of typing, try COBOL!
 * Actually, this parser is a little weak all around. It's designed to be
 * used with compliers, so I emphasize correct decoding of valid code quickly
 * rather that catching every possible error.
 * Note: This uses the expression function, so save input_line_pointer before
 * calling.
 *
 * Sperry defines the semantics of address modes (and values)
 * by a two-letter code, explained here.
 *
 *   letter 1:   access type
 *
 *     a         address calculation - no data access, registers forbidden
 *     b         branch displacement
 *     m         read - let go of bus - write back "modify"
 *     r         read
 *     w         write
 *     v         bit field address: like 'a' but registers are OK
 *
 *   letter 2:   data type (i.e. width, alignment)
 *
 *     b         byte
 *     w         word
 *     l         longword
 *     q         quadword (Even regs < 14 allowed) (if 12, you get a warning)
 *     -	 unconditional synthetic jbr operand
 *     ?	 simple synthetic reversible branch operand
 *     !	 complex synthetic reversible branch operand
 *     :	 complex synthetic non-reversible branch operand
 *
 * The '-?!:' letter 2's are not for external consumption. They are used
 * by GAS for psuedo ops relaxing code.
 *
 * After parsing topP has:
 *
 *   top_ndx:        -1, or the index register. eg 7=[R7]
 *   top_reg:        -1, or register number. eg 7 = R7 or (R7)
 *   top_mode:       The addressing mode byte. This byte, defines which of
 *                   the 11 modes opcode is.
 *   top_access:     Access type wanted for this operand 'b'branch ' '
 *                   no-instruction 'amrvw'
 *   top_width:      Operand width expected, one of "bwlq?-:!"
 *   exp_of_operand: The expression as parsed by expression()
 *   top_dispsize:   Number of bytes in the displacement if we can figure it
 *                   out and it's relevant.
 *
 * Need syntax checks built.
 */
d937 4
a940 6
tip_op (optex, topP)
     char *optex;		/* The users text input, with one leading character */
     struct top *topP;		/* The tahoe instruction with some fields already set:
			 in: access, width
			 out: ndx, reg, mode, error, dispsize */

d946 3
a948 3
  int reg = -1;			/* major register, -1 means absent */
  int imreg = -1;		/* Major register in immediate mode */
  int ndx = -1;			/* index register number, -1 means absent */
d951 9
a959 11
  int immediate = 0;		/* 1 if '$' immediate mode */
  int call_width = 0;		/* If the caller casts the displacement */
  int abs_width = 0;		/* The width of the absolute displacement */
  int com_width = 0;		/* Displacement width required by branch */
  int deferred = 0;		/* 1 if '*' deferral is used */
  byte disp_size = 0;		/* How big is this operand. 0 == don't know */
  char *op_bad = "";		/* Bad operand error */

  char *tp, *temp, c;		/* Temporary holders */

  char access = topP->top_access;	/* Save on a deref.  */
a960 1

d962 2
a963 2
				   but I need to know if it's there or not */
  expressionS *expP;		/* -> expression values for this operand */
d972 1
a972 1
				   the searches to fail on if needed.*/
d974 2
a975 1
    {				/* A dereference? */
d980 7
a986 10
  /* Force words into a certain mode */
  /* Bitch, Bitch, Bitch! */
  /*
   * Using the ^ operator is ambiguous. If I have an absolute label
   * called 'w' set to, say 2, and I have the expression 'w^1', do I get
   * 1, forced to be in word displacement mode, or do I get the value of
   * 'w' or'ed with 1 (3 in this case).
   * The default is 'w' as an offset, so that's what I use.
   * Stick with `, it does the same, and isn't ambig.
   */
d1009 1
a1009 1
  /* Setting immediate mode */
d1016 2
a1017 4
  /*
   * I've pulled off all the easy stuff off the front, move to the end and
   * yank.
   */
d1022 1
a1022 1
  if (end != point)		/* Null string? */
d1026 1
a1026 1
    end--;			/* Hop white space */
d1043 2
a1044 3
	    {			/* Reg. parse error.  */
	      ndx = -1;
	    }
d1046 3
a1048 3
	    {
	      end--;		/* Found it, move past brace.  */
	    }
d1070 1
a1070 1
  /* register in parens? */
d1088 2
a1089 1
	      end = temp;	/* Rest the pointer back */
d1092 2
a1093 3
	    {
	      end--;		/* Found the reg. move before opening paren.  */
	    }
d1098 2
a1099 1
	  end = point;		/* Force all the rest of the tests to fail.  */
d1103 1
a1103 1
  /* Pre decrement? */
a1113 1
	  /* was:      *end--; */
d1118 2
a1119 5
  /*
   * Everything between point and end is the 'expression', unless it's
   * a register name.
   */

d1124 2
a1125 2
  imreg = tahoe_reg_parse (&point);	/* Get the immediate register
				      if it is there.*/
d1136 3
a1138 6
  /*
   * Evaluate whats left of the expression to see if it's valid.
   * Note again: This assumes that the calling expression has saved
   * input_line_pointer. (Nag, nag, nag!)
   */

d1149 1
a1149 1
	     absolute 0 */
d1154 1
a1154 1
	  /* for SEG_ABSOLUTE, we shouldn't need to set X_op_symbol,
d1160 1
a1160 1
	  /* How many bytes are needed to express this abs value? */
d1162 4
a1165 4
	    ((((expP->X_add_number & 0xFFFFFF80) == 0) ||
	      ((expP->X_add_number & 0xFFFFFF80) == 0xFFFFFF80)) ? 1 :
	     (((expP->X_add_number & 0xFFFF8000) == 0) ||
	      ((expP->X_add_number & 0xFFFF8000) == 0xFFFF8000)) ? 2 : 4);
d1171 7
a1177 9
	  /*
	   * Major bug. We can't handle the case of an operator
	   * expression in a synthetic opcode variable-length
	   * instruction.  We don't have a frag type that is smart
	   * enough to relax an operator, and so we just force all
	   * operators to behave like SEG_PASS1s.  Clearly, if there is
	   * a demand we can invent a new or modified frag type and
	   * then coding up a frag for this case will be easy.
	   */
d1189 1
d1191 1
a1191 3
	{
	  op_bad = _("Junk at end of expression.");
	}
d1196 1
a1196 1
  /* I'm done, so restore optex */
d1199 16
a1214 18
  /*
   * At this point in the game, we (in theory) have all the components of
   * the operand at least parsed. Now it's time to check for syntax/semantic
   * errors, and build the mode.
   * This is what I have:
   *   deferred = 1 if '*'
   *   call_width = 0,1,2,4
   *   abs_width = 0,1,2,4
   *   com_width = 0,1,2,4
   *   immediate = 1 if '$'
   *   ndx = -1 or reg num
   *   dec_inc = '-' or '+' or ' '
   *   reg = -1 or reg num
   *   imreg = -1 or reg num
   *   topP->exp_of_operand
   *   really_none
   */
  /* Is there a displacement size? */
d1225 5
a1229 2
	  if (deferred || immediate || (dec_inc != ' ') ||
	      (reg != -1) || !really_none)
d1247 1
a1247 1
	      /* No errors, check for warnings */
d1254 1
a1254 1
	  /* We know: imm = -1 */
d1273 1
a1273 1
	  /* We know: imm = -1, dec_inc != '-' */
d1306 1
a1306 1
	  /* We know: imm = -1, dec_inc == ' ' */
d1320 2
a1321 5
	    {
	      /* (Rn) */
	      mode = TAHOE_REG_DEFERRED;
	      /* if reg = SP then cant be indexed */
	    }
d1323 2
a1324 4
	    {
	      /* <disp>(Rn) */
	      mode = TAHOE_REG_DISP;
	    }
d1349 2
a1350 4
	    {
	      /* *<disp> */
	      mode = TAHOE_DISP_REL_DEFERRED;
	    }
d1352 2
a1353 4
	    {
	      /* <disp> */
	      mode = TAHOE_DISPLACED_RELATIVE;
	    }
d1357 2
a1358 4
  /*
   * At this point, all the errors we can do have be checked for.
   * We can build the 'top'.  */

d1364 1
a1364 1
}				/* tip_op */
d1366 9
a1374 14
/*
 *                  t i p ( )
 *
 * This converts a string into a tahoe instruction.
 * The string must be a bare single instruction in tahoe (with BSD4 frobs)
 * format.
 * It provides at most one fatal error message (which stops the scan)
 * some warning messages as it finds them.
 * The tahoe instruction is returned in exploded form.
 *
 * The exploded instruction is returned to a struct tit of your choice.
 * #include "tahoe-inst.h" to know what a struct tit is.
 *
 */
d1377 10
a1386 12
tip (titP, instring)
     struct tit *titP;		/* We build an exploded instruction here.  */
     char *instring;		/* Text of a vax instruction: we modify.  */
{
  register struct tot_wot *twP = NULL;	/* How to bit-encode this opcode.  */
  register char *p;		/* 1/skip whitespace.2/scan vot_how */
  register char *q;		/*  */
  register unsigned char count;	/* counts number of operands seen */
  register struct top *operandp;/* scan operands in struct tit */
  register char *alloperr = "";	/* error over all operands */
  register char c;		/* Remember char, (we clobber it
				   with '\0' temporarily).  */
d1392 2
a1393 2
    ;				/* MUST end in end-of-string or
				   exactly 1 space.  */
d1406 4
a1409 5
      /*
     * Here with instring pointing to what better be an op-name, and p
     * pointing to character just past that.
     * We trust instring points to an op-name, with no whitespace.
     */
d1411 2
a1412 1
      *p = c;			/* Restore char after op-code.  */
d1421 5
a1425 7
	  /*
       * We found a match! So let's pick up as many operands as the
       * instruction wants, and even gripe if there are too many.
       * We expect comma to separate each operand.
       * We let instring track the text, while p tracks a part of the
       * struct tot.
       */
d1427 4
a1430 2
	  count = 0;		/* no operands seen yet */
	  instring = p + (*p != '\0');	/* point past the operation code */
d1432 1
a1432 1
	 I jump in */
d1434 1
d1439 2
a1440 4
	      /*
	 * Here to parse one operand. Leave instring pointing just
	 * past any one ',' that marks the end of this operand.
	 */
d1447 4
a1450 4
		    {
		      if (*q == '\'' && q[1] != '\0')	/* Jump quoted characters */
			q++;
		    }
d1452 2
a1453 4
		  /*
	   * Q points to ',' or '\0' that ends argument. C is that
	   * character.
	   */
d1458 3
a1460 1
		  *q = c;	/* Restore input text.  */
d1462 6
a1467 5
		    {
		      alloperr = operandp->top_error;
		    }
		  instring = q + (c ? 1 : 0);	/* next operand (if any) */
		  count++;	/*  won another argument, may have an operr */
d1477 1
d1479 2
a1480 1
		instring++;	/* Skip whitespace.  */
d1484 1
d1489 1
a1489 1
  titP->tit_opcode = twP->code;	/* The op-code.  */
d1491 1
a1491 1
}				/* tip */
a1492 1
/* md_assemble() emit frags for 1 instruction */
d1494 1
a1494 2
md_assemble (instruction_string)
     char *instruction_string;	/* A string: assemble 1 instruction.  */
d1497 2
a1498 7
  register struct top *operandP;/* An operand. Scans all operands.  */
  /*  char c_save;	fixme: remove this line *//* What used to live after an expression.  */
  /*  struct frag *fragP;	fixme: remove this line *//* Fragment of code we just made.  */
  /*  register struct top *end_operandP; fixme: remove this line *//* -> slot just after last operand
					Limit of the for (each operand).  */
  register expressionS *expP;	/* -> expression values for this operand */

d1501 2
a1502 5

  register valueT this_add_number;
  register symbolS *this_add_symbol;	/* +ve (minuend) symbol.  */

  /*  tahoe_opcodeT opcode_as_number; fixme: remove this line *//* The opcode as a number.  */
d1504 3
a1506 7
  /*  char *opmodeP;	fixme: remove this line *//* Where opcode type is, in a frag.  */

  int dispsize;			/* From top_dispsize: tahoe_operand_width
				   (in bytes) */
  int is_undefined;		/* 1 if operand expression's
				   segment not known yet.  */
  int pc_rel;			/* Is this operand pc relative? */
d1511 6
a1516 7
  /*
   * Check to see if this operand decode properly.
   * Notice that we haven't made any frags yet.
   * If it goofed, then this instruction will wedge in any pass,
   * and we can safely flush it, without causing interpass symbol phase
   * errors. That is, without changing label values in different passes.
   */
d1518 1
a1518 3
    {
      as_warn (_("Ignoring statement due to \"%s\""), t.tit_error);
    }
d1521 1
a1521 1
      /* We saw no errors in any operands - try to make frag(s) */
d1535 1
a1535 1
	   Legality of indexed mode already checked: it is OK */
d1543 5
a1547 5
	  know (to_seg == SEG_UNKNOWN || \
		to_seg == SEG_ABSOLUTE || \
		to_seg == SEG_DATA || \
		to_seg == SEG_TEXT || \
		to_seg == SEG_BSS);
d1549 1
a1549 1
	  /* Do we know how big this operand is? */
d1552 1
a1552 2
	  /* Deal with the branch possibilities. (Note, this doesn't include
	 jumps.)*/
d1556 1
a1556 1
	   an absolute address.  */
d1563 1
a1563 1
	       branch), so I set up the frag, and let GAS do the rest.  */
a1571 1
		      /* (to_seg==now_seg || to_seg == SEG_UNKNOWN) && dispsize==0 */
d1573 1
a1573 1
	       so we set up a simple relax state.  */
d1578 3
a1580 3
		 condition of opcodeP, and then jump to my destination.
		 I set 1 byte aside for the branch off set, and could need 6
		 more bytes for the pc_rel jump */
d1588 1
a1588 1
		 a word branch, or an absolute jump.  */
d1618 2
a1619 2
	     In other words, I'm jumping out of my segment so extend the
	     branches to jumps, and let GAS fix them.  */
d1622 3
a1624 3
	     to the correct address in real life.
	     If to_seg is SEG_ABSOLUTE, just encode the branch in,
	     else let GAS fix the address.  */
d1629 3
a1631 3
	       For SEG_ABSOLUTE, then mode is ABSOLUTE_ADDR, jump
	       to that address (not pc_rel).
	       For other segs, address is a long word PC rel jump.  */
d1635 1
a1635 1
	       complement bit 4 */
d1646 4
a1649 5
		      /*
	     * Now (eg)	BLEQ	1f
	     *		JMP	foo
	     *	1:
	     */
d1651 1
d1653 1
a1653 1
		      /* br, just turn it into a jump */
d1662 1
a1662 1
		      /* Now (eg) JMP foo */
d1664 1
d1677 3
a1679 5
		      /*
	     * Now (eg)	ACBx	1f
	     *		JMP     foo
	     *	1:
	     */
d1681 1
d1695 4
a1698 6
		      /*
	     * Now (eg)	xOBxxx	1f
	     *		BRB	2f
	     *	1:	JMP	@@#foo
	     *	2:
	     */
d1717 1
a1717 1
	     so the only thing needed is the mode.  */
d1725 1
a1725 1
	     mode + Register number */
d1732 1
a1732 1
	     (mode_type + 4 byte address).  */
d1741 1
a1741 1
	     + and offset, which is 4 bytes big.  */
d1755 2
a1756 4
			{
			  /* Will it fit in a literal? */
			  FRAG_APPEND_1_CHAR ((byte) this_add_number);
			}
d1780 3
a1782 3
	     into it. The difference between this and disp(sp) is that
	     this offset is pc_rel, and disp(sp) isn't.
	     Note the drop through code.  */
d1790 2
a1791 2
	     and weather its deffered or not, and relax the size if it isn't
	     known.  */
d1794 4
a1797 4
		  if (operandP->top_mode == TAHOE_DISP_REL_DEFERRED ||
		      operandP->top_mode == TAHOE_REG_DISP_DEFERRED)
		    operandP->top_reg += 0x10;	/* deffered mode is always 0x10 higher
					  than it's non-deffered sibling.  */
d1800 7
a1806 7
	     The first part of this conditional is a cludge to make gas
	     produce the same output as 'as' when there is a lable, in
	     the current segment, displacing a register. It's strange,
	     and no one in their right mind would do it, but it's easy
	     to cludge.  */
		  if ((dispsize == 0 && !pc_rel) ||
		      (to_seg != now_seg && !is_undefined && to_seg != SEG_ABSOLUTE))
d1811 3
a1813 5
		      /*
	     * We have a SEG_UNKNOWN symbol, or the size isn't cast.
	     * It might turn out to be in the same segment as
	     * the instruction, permitting relaxation.
	     */
d1845 3
a1847 3
	}			/* for(operandP) */
    }				/* if(!need_pass_2 && !goofed) */
}				/* tahoe_assemble() */
d1852 1
a1852 2
md_undefined_symbol (name)
     char *name;
d1855 1
a1855 1
}				/* md_undefined_symbol() */
d1858 1
d1860 1
a1860 3
md_section_align (segment, size)
     segT segment;
     valueT size;
d1862 3
a1864 2
  return ((size + 7) & ~7);	/* Round all sects to multiple of 8 */
}				/* md_section_align() */
d1870 1
d1872 1
a1872 2
md_pcrel_from (fixP)
     fixS *fixP;
d1884 1
a1884 1
}				/* md_pcrel_from() */
d1887 1
a1887 2
tc_is_pcrel (fixP)
     fixS *fixP;
d1889 1
a1889 1
  /* should never be called */
d1891 2
a1892 2
  return (0);
}				/* tc_is_pcrel() */
@


1.14
log
@	* symbols.c (colon) [!WORKING_DOT_WORD]: Don't declare
	md_short_jump_size, md_long_jump_size.
	* write.c [!WORKING_DOT_WORD]: Ditto.
	* tc.h [!WORKING_DOT_WORD]: Declare them here.  Drop const
	qualifier.
	* config/tc-cris.h (md_short_jump_size, md_long_jump_size): Don't
	declare.
	* config/tc-cris.c (md_short_jump_size, md_long_jump_size): Drop
	const qualifier in these definitions.
	* config/tc-i370.c, config/tc-m68k.c, config/tc-pdp11.c,
	config/tc-s390.c, config/tc-tahoe.c, config/tc-vax.c: Ditto.
@
text
@d3 2
a4 2
   Copyright 1987, 1988, 1989, 1990, 1991, 1992, 1995, 2000, 2001, 2002
   Free Software Foundation, Inc.
@


1.13
log
@	* config/atof-tahoe.c: Fix comment typos.
	* config/m68k-parse.y: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-bout.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/te-delt88.h: Likewise.
	* config/te-delta.h: Likewise.
	* config/te-generic.h: Likewise.
	* config/te-macos.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-psos.h: Likewise.
	* config/te-sun3.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/xtensa-relax.c: Likewise.
@
text
@d575 1
a575 1
const int md_short_jump_size = 3;
d591 1
a591 1
const int md_long_jump_size = 6;
@


1.12
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d44 1
a44 1
    char top_access;		/* Access type wanted for this opperand
d58 2
a59 2
/* The addressing modes for an operand. These numbers are the acutal values
   for certain modes, so be carefull if you screw with them.  */
d78 1
a78 1
/* INDEXED_REG is decided by the existance or lack of a [reg].  */
d133 1
a133 1
         consistant with 'as' If it's needed, I can always add it later.  */
d309 1
a309 1
/* Another type of reversable branch. But this only has a word
d323 1
a323 1
/* These are the non reversable branches, all of which have a word
d950 2
a951 2
 * used with compliers, so I emphisise correct decoding of valid code quickly
 * rather that catching every possable error.
d974 3
a976 3
 *     ?	 simple synthetic reversable branch operand
 *     !	 complex synthetic reversable branch operand
 *     :	 complex synthetic non-reversable branch operand
d987 1
a987 1
 *   top_access:     Access type wanted for this opperand 'b'branch ' '
d992 1
a992 1
 *                   out and it's relavent.
d1016 1
a1016 1
  int abs_width = 0;		/* The width of the absolute displacment */
d1048 1
a1048 1
   * Using the ^ operator is ambigous. If I have an absolute label
d1231 1
a1231 1
	  /* for SEG_ABSOLUTE, we shouldnt need to set X_op_symbol,
d1521 1
a1521 1
       * We expect comma to seperate each operand.
d1660 1
a1660 1
	  /* Do we know how big this opperand is? */
d1663 1
a1663 1
	  /* Deal with the branch possabilities. (Note, this doesn't include
d1735 1
a1735 1
	     to the correct addresss in real life.
d1743 1
a1743 1
	       to that addresss (not pc_rel).
d1919 1
a1919 1
	     the current segment, displaceing a register. It's strange,
@


1.11
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d3 1
a3 1
   Copyright 1987, 1988, 1989, 1990, 1991, 1992, 1995, 2000, 2001
d389 1
a389 1
CONST char *md_shortopts = "ad:STt:V";
@


1.10
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d473 4
a476 3
tc_apply_fix (fixP, val)
     fixS *fixP;
     long val;
d478 1
a478 1
  /* should never be called */
@


1.9
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1248 1
a1248 1
	   * Major bug. We can't handle the case of a operator
d1251 1
a1251 1
	   * enough to relax a operator, and so we just force all
d1867 1
a1867 1
		      /* It's a integer, and I know it's size.  */
@


1.8
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@d3 1
a3 1
   Copyright 1987, 1988, 1989, 1990, 1991, 1992, 1995, 2000
d23 1
d889 1
a889 1
      if (isdigit (*regpoint))
d893 1
a893 1
	  if ((regnum == 1) && isdigit (*regpoint))
d1068 1
a1068 1
	    c = (isupper (*point) ? tolower (*point) : *point);
@


1.7
log
@Fix copyright notices
@
text
@d248 2
a249 2
#define RELAX_STATE(what) ((what) >> 2)
#define RELAX_LENGTH(length) ((length) && 3)
d607 4
a610 14
/*
 *			md_estimate_size_before_relax()
 *
 * Called just before relax().
 * Any symbol that is now undefined will not become defined, so we assumed
 * that it will be resolved by the linker.
 * Return the correct fr_subtype in the frag, for relax()
 * Return the initial "guess for fr_var" to caller. (How big I think this
 * will be.)
 * The guess for fr_var is ACTUALLY the growth beyond fr_fix.
 * Whatever we do to grow fr_fix or fr_var contributes to our returned value.
 * Although it may not be explicit in the frag, pretend fr_var starts with a
 * 0 value.
 */
d616 1
a616 6
  register char *p;
  register int old_fr_fix;
  /*  int pc_rel; FIXME: remove this */

  old_fr_fix = fragP->fr_fix;
  switch (fragP->fr_subtype)
d618 1
a618 2
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
d620 3
a622 17
	  /* The symbol was in the same segment as the opcode, and it's
	 a real pc_rel case so it's a relaxable case.  */
	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	}
      else
	{
	  /* This case is still undefined, so asume it's a long word for the
	 linker to fix.  */
	  p = fragP->fr_literal + old_fr_fix;
	  *p |= TAHOE_PC_OR_LONG;
	  /* We now know how big it will be, one long word.  */
	  fragP->fr_fix += 1 + 4;
	  fix_new (fragP, old_fr_fix + 1, fragP->fr_symbol,
		   fragP->fr_offset, FX_PCREL32, NULL);
	  frag_wane (fragP);
	}
      break;
d624 1
a624 7
    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  fragP->fr_subtype = ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE);
	}
      else
	{
d626 54
a679 7
	  *fragP->fr_opcode ^= 0x10;	/* Reverse sense of branch.  */
	  *p++ = 6;
	  *p++ = TAHOE_JMP;
	  *p++ = TAHOE_PC_REL_LONG;
	  fragP->fr_fix += 1 + 1 + 1 + 4;
	  fix_new (fragP, old_fr_fix + 3, fragP->fr_symbol,
		   fragP->fr_offset, FX_PCREL32, NULL);
a680 2
	}
      break;
d682 2
a683 18
    case ENCODE_RELAX (STATE_BIG_REV_BRANCH, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  fragP->fr_subtype =
	    ENCODE_RELAX (STATE_BIG_REV_BRANCH, STATE_WORD);
	}
      else
	{
	  p = fragP->fr_literal + old_fr_fix;
	  *fragP->fr_opcode ^= 0x10;	/* Reverse sense of branch.  */
	  *p++ = 0;
	  *p++ = 6;
	  *p++ = TAHOE_JMP;
	  *p++ = TAHOE_PC_REL_LONG;
	  fragP->fr_fix += 2 + 2 + 4;
	  fix_new (fragP, old_fr_fix + 4, fragP->fr_symbol,
		   fragP->fr_offset, FX_PCREL32, NULL);
	  frag_wane (fragP);
a684 1
      break;
d686 3
a688 2
    case ENCODE_RELAX (STATE_BIG_NON_REV_BRANCH, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
d690 10
d701 4
d706 1
a706 15
      else
	{
	  p = fragP->fr_literal + old_fr_fix;
	  *p++ = 2;
	  *p++ = 0;
	  *p++ = TAHOE_BRB;
	  *p++ = 6;
	  *p++ = TAHOE_JMP;
	  *p++ = TAHOE_PC_REL_LONG;
	  fragP->fr_fix += 2 + 2 + 2 + 4;
	  fix_new (fragP, old_fr_fix + 6, fragP->fr_symbol,
		   fragP->fr_offset, FX_PCREL32, NULL);
	  frag_wane (fragP);
	}
      break;
d708 2
a709 16
    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  fragP->fr_subtype = ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_BYTE);
	}
      else
	{
	  p = fragP->fr_literal + old_fr_fix;
	  *fragP->fr_opcode = TAHOE_JMP;
	  *p++ = TAHOE_PC_REL_LONG;
	  fragP->fr_fix += 1 + 4;
	  fix_new (fragP, old_fr_fix + 1, fragP->fr_symbol,
		   fragP->fr_offset, FX_PCREL32, NULL);
	  frag_wane (fragP);
	}
      break;
d711 3
a713 5
    default:
      break;
    }
  return (fragP->fr_var + fragP->fr_fix - old_fr_fix);
}				/* md_estimate_size_before_relax() */
a733 1
  register short int length_code;	/* 2=long 1=word 0=byte */
a743 2
  length_code = RELAX_LENGTH (fragP->fr_subtype);
  know (length_code >= 0 && length_code < 3);
@


1.6
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d1 1
a1 2
/* tc-tahoe.c
   Not part of GAS yet.  */
d3 19
d25 1
a25 1
/* this bit glommed from tahoe-inst.h */
d30 2
a31 4
/*
 * This is part of tahoe-ins-parse.c & friends.
 * We want to parse a tahoe instruction text into a tree defined here.
 */
d37 4
a40 4
{
  int top_ndx;			/* -1, or index register. eg 7=[R7] */
  int top_reg;			/* -1, or register number. eg 7 = R7 or (R7) */
  byte top_mode;		/* Addressing mode byte. This byte, defines
d43 1
a43 1
  char top_access;		/* Access type wanted for this opperand
d45 1
a45 1
  char top_width;		/* Operand width expected, one of "bwlq?-:!" */
d47 1
a47 1
  char *top_error;		/* Say if operand is inappropriate         */
d49 1
a49 1
  segT seg_of_operand;		/* segment as returned by expression()*/
d51 1
a51 1
  expressionS exp_of_operand;	/* The expression as parsed by expression()*/
d53 1
a53 1
  byte top_dispsize;		/* Number of bytes in the displacement if we
d55 1
a55 1
};
d77 1
a77 1
/* INDEXED_REG is decided by the existance or lack of a [reg] */
d80 1
a80 1
   and it's a psuedo op.*/
d98 2
a99 2
struct tit			/* get it out of the sewer, it stands for
				   tahoe instruction tree (Geeze!) */
@


1.6.2.1
log
@Update copyright notices.
@
text
@d1 2
a2 1
/* This file is tc-tahoe.c
a3 19
   Copyright 1987, 1988, 1989, 1990, 1991, 1992, 1995, 2000
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.6.2.2
log
@Merge from mainline.
@
text
@d25 1
a25 1
/* This bit glommed from tahoe-inst.h.  */
d30 4
a33 2
/* This is part of tahoe-ins-parse.c & friends.
   We want to parse a tahoe instruction text into a tree defined here.  */
d39 4
a42 4
  {
    int top_ndx;		/* -1, or index register. eg 7=[R7] */
    int top_reg;		/* -1, or register number. eg 7 = R7 or (R7) */
    byte top_mode;		/* Addressing mode byte. This byte, defines
d45 1
a45 1
    char top_access;		/* Access type wanted for this opperand
d47 1
a47 1
    char top_width;		/* Operand width expected, one of "bwlq?-:!" */
d49 1
a49 1
    char * top_error;		/* Say if operand is inappropriate         */
d51 1
a51 1
    segT seg_of_operand;	/* segment as returned by expression()*/
d53 1
a53 1
    expressionS exp_of_operand;	/* The expression as parsed by expression()*/
d55 1
a55 1
    byte top_dispsize;		/* Number of bytes in the displacement if we
d57 1
a57 1
  };
d79 1
a79 1
/* INDEXED_REG is decided by the existance or lack of a [reg].  */
d82 1
a82 1
   and it's a psuedo op.  */
d100 2
a101 2
struct tit			/* Get it out of the sewer, it stands for
				   tahoe instruction tree (Geeze!).  */
d250 2
a251 2
#define RELAX_STATE(s) ((s) >> 2)
#define RELAX_LENGTH(s) ((s) & 3)
d609 14
a622 4
/* md_estimate_size_before_relax(), called just before relax().
   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag and the growth beyond
   fr_fix.  */
d628 6
a633 1
  if (RELAX_LENGTH (fragP->fr_subtype) == STATE_UNDF)
d635 8
a642 1
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
d644 11
a654 3
	  /* Non-relaxable cases.  */
	  char *p;
	  int old_fr_fix;
d656 7
a662 1
	  old_fr_fix = fragP->fr_fix;
d664 7
a670 54
	  switch (RELAX_STATE (fragP->fr_subtype))
	    {
	    case STATE_PC_RELATIVE:
	      *p |= TAHOE_PC_OR_LONG;
	      /* We now know how big it will be, one long word.  */
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    case STATE_CONDITIONAL_BRANCH:
	      *fragP->fr_opcode ^= 0x10;	/* Reverse sense of branch.  */
	      *p++ = 6;
	      *p++ = TAHOE_JMP;
	      *p++ = TAHOE_PC_REL_LONG;
	      fragP->fr_fix += 1 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 3, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    case STATE_BIG_REV_BRANCH:
	      *fragP->fr_opcode ^= 0x10;	/* Reverse sense of branch.  */
	      *p++ = 0;
	      *p++ = 6;
	      *p++ = TAHOE_JMP;
	      *p++ = TAHOE_PC_REL_LONG;
	      fragP->fr_fix += 2 + 2 + 4;
	      fix_new (fragP, old_fr_fix + 4, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    case STATE_BIG_NON_REV_BRANCH:
	      *p++ = 2;
	      *p++ = 0;
	      *p++ = TAHOE_BRB;
	      *p++ = 6;
	      *p++ = TAHOE_JMP;
	      *p++ = TAHOE_PC_REL_LONG;
	      fragP->fr_fix += 2 + 2 + 2 + 4;
	      fix_new (fragP, old_fr_fix + 6, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    case STATE_ALWAYS_BRANCH:
	      *fragP->fr_opcode = TAHOE_JMP;
	      *p++ = TAHOE_PC_REL_LONG;
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, fragP->fr_symbol,
		       fragP->fr_offset, FX_PCREL32, NULL);
	      break;

	    default:
	      abort ();
	    }
d672 2
d675 5
a679 2
	  /* Return the growth in the fixed part of the frag.  */
	  return fragP->fr_fix - old_fr_fix;
d681 14
d696 2
a697 3
      /* Relaxable cases.  Set up the initial guess for the variable
	 part of the frag.  */
      switch (RELAX_STATE (fragP->fr_subtype))
a698 10
	case STATE_PC_RELATIVE:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	  break;
	case STATE_CONDITIONAL_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE);
	  break;
	case STATE_BIG_REV_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_BIG_REV_BRANCH, STATE_WORD);
	  break;
	case STATE_BIG_NON_REV_BRANCH:
d700 20
a719 2
	  break;
	case STATE_ALWAYS_BRANCH:
a720 1
	  break;
d722 14
d737 2
a738 7

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}
d759 1
d770 2
@


1.5
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@a1977 1
/* ARGSUSED */
@


1.4
log
@2000-09-20  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-tahoe.c: Fix formatting.
	* config/tc-tahoe.h: Likewise.
@
text
@d376 1
a376 1
size_t md_longopts_size = sizeof(md_longopts);
d420 1
a420 1
  fprintf(stream, _("\
@


1.3
log
@Fix spelling typos.
Remove use of DEFUN().
@
text
@d2 1
a2 1
   Not part of GAS yet. */
d25 1
a25 1
				   which of the 11 modes opcode is. */
d42 1
a42 1
   for certain modes, so be carefull if you screw with them. */
d71 1
a71 1
   This is just for readability. */
d77 1
a77 1
   set up the number for the displacement mode. */
d85 2
a86 2
  tahoe_opcodeT tit_opcode;	/* The opcode. */
  byte tit_operands;		/* How many operands are here. */
d103 1
a103 1
   another comment or a quoted string. */
d106 1
a106 1
/* These chars only start a comment at the beginning of a line. */
d116 1
a116 1
         consistant with 'as' If it's needed, I can always add it later. */
d125 1
a125 1
static struct tit t;		/* A tahoe instruction after decoding. */
d129 1
a129 1
   that the function is called with. */
a166 1
	
d222 1
a222 1
   2nd letter is Forward, Backward. */
d230 1
a230 1
/* This macro has no side-effects. */
d248 1
a248 1
   where the next biggest branch is. */
d279 1
a279 1
     actual address. */
d293 1
a293 1
     displacement. */
d310 1
a310 1
     leap frog. */
d325 1
a325 1
     the numbers are up by one. */
d351 1
a351 1
/* Init function. Build the hash table. */
d357 1
a357 1
  int synthetic_too = 1;	/* If 0, just use real opcodes. */
d433 2
a434 2
   They exist primarily for cross assembly purpose. */
void				/* Knows about order of bytes in address. */
d436 3
a438 3
     char con[];		/* Return 'nbytes' of chars here. */
     valueT value;		/* The value of the bits. */
     int nbytes;		/* Number of bytes in the output. */
d444 1
a444 1
void				/* Knows about order of bytes in address. */
d446 3
a448 3
     char con[];		/* Return 'nbytes' of chars here. */
     long int value;		/* The value of the bits. */
     int nbytes;		/* Number of bytes in the output. */
d464 1
a464 1
void				/* Knows about order of bytes in address. */
d466 3
a468 3
     char con[];		/* Return 'nbytes' of chars here. */
     long int value;		/* The value of the bits. */
     int nbytes;		/* Number of bytes in the output. */
d473 1
a473 1
void				/* Knows about order of bytes in address. */
d475 3
a477 3
     char con[];		/* Return 'nbytes' of chars here. */
     long int value;		/* The value of the bits. */
     int nbytes;		/* Number of bytes in the output. */
d488 1
a488 1
	bit 4 as extern and the last nibble as 'undefined'. */
d497 1
a497 1
     ri_p may point to ri. */
d520 1
a520 1
	bit 4 as extern and the last nibble as 'undefined'. */
d522 1
a522 1
void 
d556 1
a556 1
/* This is for broken word. */
d608 1
a608 1
     segT segment_type;		/* N_DATA or N_TEXT. */
d621 1
a621 1
	 a real pc_rel case so it's a relaxable case. */
d627 1
a627 1
	 linker to fix. */
d630 1
a630 1
	  /* We now know how big it will be, one long word. */
d646 1
a646 1
	  *fragP->fr_opcode ^= 0x10;	/* Reverse sense of branch. */
d666 1
a666 1
	  *fragP->fr_opcode ^= 0x10;	/* Reverse sense of branch. */
d739 2
a740 2
  register char *addressP;	/* -> _var to change. */
  register char *opcodeP;	/* -> opcode char(s) to change. */
d743 1
a743 1
				   Added to fr_fix: incl. ALL var chars. */
d766 1
a766 1
      /* Byte displacement. */
d773 1
a773 1
      /* Word displacement. */
d780 1
a780 1
      /* Long word displacement. */
d792 1
a792 1
      *opcodeP ^= 0x10;		/* Reverse sense of test. */
d800 1
a800 1
      *opcodeP ^= 0x10;		/* Reverse sense of test. */
d865 1
a865 1
/* This is the stuff for md_assemble. */
d887 1
a887 1
     char **start;		/* A pointer to the string to parse. */
d895 1
a895 1
				   R or r, and then a number. */
d900 1
a900 1
	  /* Got the first digit. */
d904 1
a904 1
	      /* Its a two digit number. */
d1013 4
a1016 4
  int mode = 0;			/* This operand's mode. */
  char segfault = *optex;	/* To keep the back parsing from freaking. */
  char *point = optex + 1;	/* Parsing from front to back. */
  char *end;			/* Parsing from back to front. */
d1021 1
a1021 1
				   auto-decremented '-' or neither ' '. */
d1032 1
a1032 1
  char access = topP->top_access;	/* Save on a deref. */
d1039 1
a1039 1
  /* Does this command restrict the displacement size. */
d1097 1
a1097 1
  for (end = point; *end != '\0'; end++)	/* Move to the end. */
d1106 1
a1106 1
  /* Is this an index reg. */
d1111 1
a1111 1
      /* Find opening brace. */
d1115 1
a1115 1
      /* If I found the opening brace, get the index register number. */
d1118 1
a1118 1
	  tp = end + 1;		/* tp should point to the start of a reg. */
d1121 1
a1121 1
	    {			/* Reg. parse error. */
d1126 1
a1126 1
	      end--;		/* Found it, move past brace. */
d1131 1
a1131 1
	      end = point;	/* Force all the rest of the tests to fail. */
d1137 1
a1137 1
	  end = point;		/* Force all the rest of the tests to fail. */
d1154 1
a1154 1
      /* Find opening paren. */
d1158 1
a1158 1
      /* If I found the opening paren, get the register number. */
d1165 1
a1165 1
	      /* Not a register, but could be part of the expression. */
d1171 1
a1171 1
	      end--;		/* Found the reg. move before opening paren. */
d1177 1
a1177 1
	  end = point;		/* Force all the rest of the tests to fail. */
d1210 1
a1210 1
      /* If there is junk after point, then the it's not immediate reg. */
d1240 1
a1240 1
	     X_add_symbol to any particular value. */
d1242 1
a1242 1
	     rarely so it costs us little to do so. */
d1272 1
a1272 1
	     by address. */
a1286 1

d1438 1
a1438 1
	      /* ponder the wisdom of a cast because it doesn't do any good. */
d1455 1
a1455 1
   * We can build the 'top'. */
d1481 2
a1482 2
     struct tit *titP;		/* We build an exploded instruction here. */
     char *instring;		/* Text of a vax instruction: we modify. */
d1484 1
a1484 1
  register struct tot_wot *twP = NULL;	/* How to bit-encode this opcode. */
d1491 1
a1491 1
				   with '\0' temporarily). */
d1495 1
a1495 1
    ++instring;			/* Skip leading whitespace. */
d1498 3
a1500 3
				   exactly 1 space. */
  /* Scanned up to end of operation-code. */
  /* Operation-code is ended with whitespace. */
d1517 1
a1517 1
      *p = c;			/* Restore char after op-code. */
d1566 1
a1566 1
		  *q = c;	/* Restore input text. */
d1577 1
a1577 1
	  /* Restore the pointer. */
d1583 1
a1583 1
		instring++;	/* Skip whitespace. */
d1591 1
a1591 1
  titP->tit_opcode = twP->code;	/* The op-code. */
d1598 1
a1598 1
     char *instruction_string;	/* A string: assemble 1 instruction. */
d1601 3
a1603 3
  register struct top *operandP;/* An operand. Scans all operands. */
  /*  char c_save;	fixme: remove this line *//* What used to live after an expression. */
  /*  struct frag *fragP;	fixme: remove this line *//* Fragment of code we just made. */
d1605 1
a1605 1
					Limit of the for (each operand). */
d1608 1
a1608 1
  /* These refer to an instruction operand expression. */
d1612 1
a1612 1
  register symbolS *this_add_symbol;	/* +ve (minuend) symbol. */
d1614 3
a1616 3
  /*  tahoe_opcodeT opcode_as_number; fixme: remove this line *//* The opcode as a number. */
  char *opcodeP;		/* Where it is in a frag. */
  /*  char *opmodeP;	fixme: remove this line *//* Where opcode type is, in a frag. */
d1621 1
a1621 1
				   segment not known yet. */
d1624 1
a1624 1
  /* Decode the operand. */
d1641 2
a1642 2
      /* Emit op-code. */
      /* Remember where it is, in case we want to modify the op-code later. */
d1645 1
a1645 1
      /* Now do each operand. */
d1658 1
a1658 1
	  /* Here to make main operand frag(s). */
d1676 1
a1676 1
	   an absolute address. */
d1679 1
a1679 1
		  /* If is_undefined, then it might BECOME now_seg by relax time. */
d1683 1
a1683 1
	       branch), so I set up the frag, and let GAS do the rest. */
d1694 1
a1694 1
	       so we set up a simple relax state. */
d1709 1
a1709 1
		 a word branch, or an absolute jump. */
d1715 1
a1715 1
			  /* The smallest size for the next 2 cases is word. */
d1740 1
a1740 1
	     branches to jumps, and let GAS fix them. */
d1745 1
a1745 1
	     else let GAS fix the address. */
d1752 1
a1752 1
	       For other segs, address is a long word PC rel jump. */
d1836 1
a1836 1
	      /* It ain't a branch operand. */
d1840 1
a1840 1
	     so the only thing needed is the mode. */
d1855 1
a1855 1
	     (mode_type + 4 byte address). */
d1864 1
a1864 1
	     + and offset, which is 4 bytes big. */
d1876 1
a1876 1
		      /* It's a integer, and I know it's size. */
d1907 1
a1907 1
	     Note the drop through code. */
d1916 1
a1916 1
	     known. */
d1922 1
a1922 1
					  than it's non-deffered sibling. */
d1929 1
a1929 1
	     to cludge. */
d1949 1
a1949 1
		      /* Either this is an abs, or a cast. */
d1976 1
a1976 2

/* We have no need to default values of symbols. */
d1986 1
a1986 1
/* Round up a section size to the appropriate boundary. */
d1999 1
a1999 1
long 
d2015 1
a2015 1
int 
a2022 2

/* end of tc-tahoe.c */
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d1227 1
a1227 1
      /* statement has no syntax goofs yet: lets sniff the expression */
d1529 1
a1529 1
       * We found a match! So lets pick up as many operands as the
@


1.1
log
@Initial revision
@
text
@d1614 1
a1614 1
  register struct symbol *this_add_symbol;	/* +ve (minuend) symbol. */
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

