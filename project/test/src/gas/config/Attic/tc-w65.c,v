head	1.20;
access;
symbols
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	binutils-csl-wrs-linux-3_4_4-22:1.16
	binutils-csl-wrs-linux-3_4_4-21:1.16
	binutils-csl-wrs-linux-3_4_4-20:1.16
	binutils-csl-gxxpro-3_4-branch:1.16.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	binutils-csl-arm-2005q1a:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.4
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.2
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.14
	csl-arm-2004-q3:1.14
	binutils-2_15:1.14
	binutils-2_15-branchpoint:1.14
	csl-arm-2004-q1a:1.14
	csl-arm-2004-q1:1.14
	binutils-2_15-branch:1.14.0.8
	cagney_bfdfile-20040213-branch:1.14.0.6
	cagney_bfdfile-20040213-branchpoint:1.14
	cagney_bigcore-20040122-branch:1.14.0.4
	cagney_bigcore-20040122-branchpoint:1.14
	csl-arm-2003-q4:1.14
	binutils-2_14:1.14
	binutils-2_14-branch:1.14.0.2
	binutils-2_14-branchpoint:1.14
	binutils-2_13_2_1:1.12.2.1
	binutils-2_13_2:1.12.2.1
	binutils-2_13_1:1.12.2.1
	binutils-2_13:1.12
	binutils-2_13-branchpoint:1.12
	binutils-2_13-branch:1.12.0.2
	binutils-2_12_1:1.11
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.11
	binutils-2_11_2:1.6.2.2
	binutils-2_11_1:1.6.2.2
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.19
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2005.08.11.01.25.24;	author amodra;	state dead;
branches;
next	1.19;

1.19
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.05.09.13.04;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.24.20.40.28;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.23.12.28.06;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.31.23.18.34;	author bje;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.03.12.01.44;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.26.08.55.33;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.08.07.37.16;	author amodra;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.15.21.28.59;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.19.05.33.30;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.05.04.21.36;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.30.00.06.10;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.16.00.59.49;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.07.17.20.59.47;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.25.17.59.21;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.24.11.51.53;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.47;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.15.34;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.06.11.10.04.51;	author amodra;	state Exp;
branches;
next	;

1.12.2.1
date	2002.08.26.08.57.17;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.20
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* tc-w65.c -- Assemble code for the W65816
   Copyright 1995, 1998, 2000, 2001, 2002, 2005
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#include <stdio.h>
#include "as.h"
#include "bfd.h"
#include "subsegs.h"
#define DEFINE_TABLE
#include "../opcodes/w65-opc.h"

const char comment_chars[]        = "!";
const char line_separator_chars[] = ";";
const char line_comment_chars[]   = "!#";

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:

   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

#define OP_BCC	0x90
#define OP_BCS	0xB0
#define OP_BEQ	0xF0
#define OP_BMI	0x30
#define OP_BNE	0xD0
#define OP_BPL	0x10
#define OP_BRA	0x80
#define OP_BRL	0x82
#define OP_BVC	0x50
#define OP_BVS	0x70

static int M;				/* M flag.  */
static int X;				/* X flag.  */

/* This function is called once, at assembler startup time.  This
   should set up all the tables, etc that the MD part of the assembler
   needs.  */

static void
s_longa (int xmode)
{
  int *p = xmode ? &X : &M;

  while (*input_line_pointer == ' ')
    input_line_pointer++;
  if (strncmp (input_line_pointer, "on", 2) == 0)
    {
      input_line_pointer += 2;
      *p = 0;
    }
  else if (strncmp (input_line_pointer, "off", 3) == 0)
    {
      *p = 1;
      input_line_pointer += 3;
    }
  else
    as_bad (_("need on or off."));
  demand_empty_rest_of_line ();
}

const pseudo_typeS md_pseudo_table[] =
{
  {"int", cons, 2},
  {"word", cons, 2},
  {"longa", s_longa, 0},
  {"longi", s_longa, 1},
  {0, 0, 0}
};

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Opcode mnemonics */
static struct hash_control *opcode_hash_control;

#define C(a, b)                    ENCODE_RELAX(a,b)
#define ENCODE_RELAX(what, length) (((what) << 2) + (length))

#define GET_WHAT(x) (((x) >> 2))

#define BYTE_DISP       1
#define WORD_DISP       2
#define UNDEF_BYTE_DISP 0
#define UNDEF_WORD_DISP 3
#define COND_BRANCH 	1
#define UNCOND_BRANCH   2
#define END 	        3

#define BYTE_F 127	/* How far we can branch forwards.  */
#define BYTE_B -126	/* How far we can branch backwards.  */
#define WORD_F 32767
#define WORD_B 32768

relax_typeS md_relax_table[C (END, 0)] =
{
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },

  /* COND_BRANCH */
  { 0,       0,       0,  0 },				/* UNDEF_BYTE_DISP */
  { BYTE_F,  BYTE_B,  2,  C (COND_BRANCH, WORD_DISP) },	/* BYTE_DISP */
  { WORD_F,  WORD_B,  5,  0 },				/* WORD_DISP */
  { 0,       0,       5,  0 },				/* UNDEF_WORD_DISP */

  /* UNCOND_BRANCH */
  { 0,       0,       0,  0 },				  /* UNDEF_BYTE_DISP */
  { BYTE_F,  BYTE_B,  2,  C (UNCOND_BRANCH, WORD_DISP) }, /* BYTE_DISP */
  { WORD_F,  WORD_B,  3,  0 },				  /* WORD_DISP */
  { 0,       0,       3,  0 }				  /* UNDEF_WORD_DISP */
};

void
md_begin (void)
{
  const struct opinfo *opcode;
  char *prev_name = "";

  opcode_hash_control = hash_new ();

  /* Insert unique names into hash table.  */
  for (opcode = optable; opcode->name; opcode++)
    {
      if (strcmp (prev_name, opcode->name))
	{
	  prev_name = opcode->name;
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	}
    }

  flag_signed_overflow_ok = 1;
}

static expressionS immediate;	/* Absolute expression.  */
static expressionS immediate1;	/* Absolute expression.  */
int expr_size;
int expr_shift;
int tc_cons_reloc;

void
w65_expression (expressionS *dest)
{
  expr_size = 0;
  expr_shift = 0;
  tc_cons_reloc = 0;
  while (*input_line_pointer == ' ')
    input_line_pointer++;

  if (*input_line_pointer == '<')
    {
      expr_size = 1;
      input_line_pointer++;
    }
  else if (*input_line_pointer == '>')
    {
      expr_shift = 1;
      input_line_pointer++;
    }
  else if (*input_line_pointer == '^')
    {
      expr_shift = 2;
      input_line_pointer++;
    }

  expr (0, dest);
}

int amode;

static char *
parse_exp (char *s)
{
  char *save;
  char *new;

  save = input_line_pointer;
  input_line_pointer = s;
  w65_expression (&immediate);
  if (immediate.X_op == O_absent)
    as_bad (_("missing operand"));
  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

static char *
get_operands (const struct opinfo *info, char *ptr)
{
  int override_len = 0;
  int bytes = 0;

  while (*ptr == ' ')
    ptr++;

  if (ptr[0] == '#')
    {
      ptr++;
      switch (info->amode)
	{
	case ADDR_IMMTOI:
	  bytes = X ? 1 : 2;
	  amode = ADDR_IMMTOI;
	  break;
	case ADDR_IMMTOA:
	  bytes = M ? 1 : 2;
	  amode = ADDR_IMMTOA;
	  break;
	case ADDR_IMMCOP:
	  bytes = 1;
	  amode = ADDR_IMMCOP;
	  break;
	case ADDR_DIR:
	  bytes = 2;
	  amode = ADDR_ABS;
	  break;
	default:
	  abort ();
	  break;
	}
      ptr = parse_exp (ptr);
    }
  else if (ptr[0] == '!')
    {
      ptr = parse_exp (ptr + 1);
      if (ptr[0] == ',')
	{
	  if (ptr[1] == 'y')
	    {
	      amode = ADDR_ABS_IDX_Y;
	      bytes = 2;
	      ptr += 2;
	    }
	  else if (ptr[1] == 'x')
	    {
	      amode = ADDR_ABS_IDX_X;
	      bytes = 2;
	      ptr += 2;
	    }
	  else
	    as_bad (_("syntax error after <exp"));
	}
      else
	{
	  amode = ADDR_ABS;
	  bytes = 2;
	}
    }
  else if (ptr[0] == '>')
    {
      ptr = parse_exp (ptr + 1);
      if (ptr[0] == ',' && ptr[1] == 'x')
	{
	  amode = ADDR_ABS_LONG_IDX_X;
	  bytes = 3;
	  ptr += 2;
	}
      else
	{
	  amode = ADDR_ABS_LONG;
	  bytes = 3;
	}
    }
  else if (ptr[0] == '<')
    {
      ptr = parse_exp (ptr + 1);
      if (ptr[0] == ',')
	{
	  if (ptr[1] == 'y')
	    {
	      amode = ADDR_DIR_IDX_Y;
	      ptr += 2;
	      bytes = 2;
	    }
	  else if (ptr[1] == 'x')
	    {
	      amode = ADDR_DIR_IDX_X;
	      ptr += 2;
	      bytes = 2;
	    }
	  else
	    as_bad (_("syntax error after <exp"));
	}
      else
	{
	  amode = ADDR_DIR;
	  bytes = 1;
	}
    }
  else if (ptr[0] == 'a')
    amode = ADDR_ACC;
  else if (ptr[0] == '(')
    {
      /* Look for (exp),y
	 (<exp),y
	 (exp,x)
	 (<exp,x)
	 (exp)
	 (!exp)
	 (exp)
	 (<exp)
	 (exp,x)
	 (!exp,x)
	 (exp,s)
	 (exp,s),y */

      ptr++;
      if (ptr[0] == '<')
	{
	  override_len = 1;
	  ptr++;
	}
      else if (ptr[0] == '!')
	{
	  override_len = 2;
	  ptr++;
	}
      else if (ptr[0] == '>')
	{
	  override_len = 3;
	  ptr++;
	}
      else
	override_len = 0;

      ptr = parse_exp (ptr);

      if (ptr[0] == ',')
	{
	  ptr++;
	  if (ptr[0] == 'x' && ptr[1] == ')')
	    {
	      ptr += 2;

	      if (override_len == 1)
		{
		  amode = ADDR_DIR_IDX_IND_X;
		  bytes = 2;
		}
	      else
		{
		  amode = ADDR_ABS_IND_IDX;
		  bytes = 2;
		}
	    }
	  else if (ptr[0] == 's' && ptr[1] == ')'
		   && ptr[2] == ',' && ptr[3] == 'y')
	    {
	      amode = ADDR_STACK_REL_INDX_IDX;
	      bytes = 1;
	      ptr += 4;
	    }
	}
      else if (ptr[0] == ')')
	{
	  if (ptr[1] == ',' && ptr[2] == 'y')
	    {
	      amode = ADDR_DIR_IND_IDX_Y;
	      ptr += 3;
	      bytes = 2;
	    }
	  else
	    {
	      if (override_len == 1)
		{
		  amode = ADDR_DIR_IND;
		  bytes = 1;
		}
	      else
		{
		  amode = ADDR_ABS_IND;
		  bytes = 2;
		}
	      ptr++;
	    }
	}
    }
  else if (ptr[0] == '[')
    {
      ptr = parse_exp (ptr + 1);

      if (ptr[0] == ']')
	{
	  ptr++;
	  if (ptr[0] == ',' && ptr[1] == 'y')
	    {
	      bytes = 1;
	      amode = ADDR_DIR_IND_IDX_Y_LONG;
	      ptr += 2;
	    }
	  else
	    {
	      if (info->code == O_jmp)
		{
		  bytes = 2;
		  amode = ADDR_ABS_IND_LONG;
		}
	      else
		{
		  bytes = 1;
		  amode = ADDR_DIR_IND_LONG;
		}
	    }
	}
    }
  else
    {
      ptr = parse_exp (ptr);
      if (ptr[0] == ',')
	{
	  if (ptr[1] == 'y')
	    {
	      if (override_len == 1)
		{
		  bytes = 1;
		  amode = ADDR_DIR_IDX_Y;
		}
	      else
		{
		  amode = ADDR_ABS_IDX_Y;
		  bytes = 2;
		}
	      ptr += 2;
	    }
	  else if (ptr[1] == 'x')
	    {
	      if (override_len == 1)
		{
		  amode = ADDR_DIR_IDX_X;
		  bytes = 1;
		}
	      else
		{
		  amode = ADDR_ABS_IDX_X;
		  bytes = 2;
		}
	      ptr += 2;
	    }
	  else if (ptr[1] == 's')
	    {
	      bytes = 1;
	      amode = ADDR_STACK_REL;
	      ptr += 2;
	    }
	  else
	    {
	      bytes = 1;
	      immediate1 = immediate;
	      ptr = parse_exp (ptr + 1);
	      amode = ADDR_BLOCK_MOVE;
	    }
	}
      else
	{
	  switch (info->amode)
	    {
	    case ADDR_PC_REL:
	      amode = ADDR_PC_REL;
	      bytes = 1;
	      break;
	    case ADDR_PC_REL_LONG:
	      amode = ADDR_PC_REL_LONG;
	      bytes = 2;
	      break;
	    default:
	      if (override_len == 1)
		{
		  amode = ADDR_DIR;
		  bytes = 1;
		}
	      else if (override_len == 3)
		{
		  bytes = 3;
		  amode = ADDR_ABS_LONG;
		}
	      else
		{
		  amode = ADDR_ABS;
		  bytes = 2;
		}
	    }
	}
    }

  switch (bytes)
    {
    case 1:
      switch (expr_shift)
	{
	case 0:
	  if (amode == ADDR_DIR)
	    tc_cons_reloc = R_W65_DP;
	  else
	    tc_cons_reloc = R_W65_ABS8;
	  break;
	case 1:
	  tc_cons_reloc = R_W65_ABS8S8;
	  break;
	case 2:
	  tc_cons_reloc = R_W65_ABS8S16;
	  break;
	}
      break;
    case 2:
      switch (expr_shift)
	{
	case 0:
	  tc_cons_reloc = R_W65_ABS16;
	  break;
	case 1:
	  tc_cons_reloc = R_W65_ABS16S8;
	  break;
	case 2:
	  tc_cons_reloc = R_W65_ABS16S16;
	  break;
	}
    }
  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

static const struct opinfo *
get_specific (const struct opinfo *opcode)
{
  int ocode = opcode->code;

  for (; opcode->code == ocode; opcode++)
    if (opcode->amode == amode)
      return opcode;

  return 0;
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static void
build_Mytes (const struct opinfo *opcode)
{
  int size;
  int type;
  int pcrel;
  char *output;

  if (opcode->amode == ADDR_IMPLIED)
    output = frag_more (1);

  else if (opcode->amode == ADDR_PC_REL)
    {
      int type;

      /* This is a relaxable insn, so we do some special handling.  */
      type = opcode->val == OP_BRA ? UNCOND_BRANCH : COND_BRANCH;
      output = frag_var (rs_machine_dependent,
			 md_relax_table[C (type, WORD_DISP)].rlx_length,
			 md_relax_table[C (type, BYTE_DISP)].rlx_length,
			 C (type, UNDEF_BYTE_DISP),
			 immediate.X_add_symbol,
			 immediate.X_add_number,
			 0);
    }
  else
    {
      switch (opcode->amode)
	{
	  GETINFO (size, type, pcrel);
	default:
	  abort ();
	}

      /* If something special was done in the expression modify the
	 reloc type.  */
      if (tc_cons_reloc)
	type = tc_cons_reloc;

      /* 1 byte for the opcode + the bytes for the addrmode.  */
      output = frag_more (size + 1);

      if (opcode->amode == ADDR_BLOCK_MOVE)
	{
	  /* Two relocs for this one.  */
	  fix_new_exp (frag_now,
		       output + 1 - frag_now->fr_literal,
		       1,
		       &immediate,
		       0,
		       R_W65_ABS8S16);

	  fix_new_exp (frag_now,
		       output + 2 - frag_now->fr_literal,
		       1,
		       &immediate1,
		       0,
		       R_W65_ABS8S16);
	}
      else if (type >= 0
	       && opcode->amode != ADDR_IMPLIED
	       && opcode->amode != ADDR_ACC
	       && opcode->amode != ADDR_STACK)
	{
	  fix_new_exp (frag_now,
		       output + 1 - frag_now->fr_literal,
		       size,
		       &immediate,
		       pcrel,
		       type);
	}
    }
  output[0] = opcode->val;
}

/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char *str)
{
  const struct opinfo *opcode;
  char name[20];

  /* Drop leading whitespace */
  while (*str == ' ')
    str++;

  /* All opcodes are three letters.  */
  name[0] = str[0];
  name[1] = str[1];
  name[2] = str[2];
  name[3] = 0;

  tc_cons_reloc = 0;
  str += 3;
  opcode = (struct opinfo *) hash_find (opcode_hash_control, name);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  if (opcode->amode != ADDR_IMPLIED
      && opcode->amode != ADDR_STACK)
    {
      get_operands (opcode, str);
      opcode = get_specific (opcode);
    }

  if (opcode == 0)
    {
      /* Couldn't find an opcode which matched the operands.  */

      char *where = frag_more (1);

      where[0] = 0x0;
      where[1] = 0x0;
      as_bad (_("invalid operands for opcode"));
      return;
    }

  build_Mytes (opcode);
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_NTOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

int
md_parse_option (int c ATTRIBUTE_UNUSED, char *a ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Called after relaxing, change the frags so they know how big they
   are.  */

void
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED,
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  int disp_size = 0;
  int inst_size = 0;
  unsigned char *buffer =
    (unsigned char *) (fragP->fr_fix + fragP->fr_literal);

  switch (fragP->fr_subtype)
    {
    case C (COND_BRANCH, BYTE_DISP):
    case C (UNCOND_BRANCH, BYTE_DISP):
      disp_size = 1;
      inst_size = 1;
      break;

      /* Conditional branches to a known 16 bit displacement.  */
    case C (COND_BRANCH, WORD_DISP):
      switch (buffer[0])
	{
	case OP_BCC:
	case OP_BCS:
	case OP_BEQ:
	case OP_BMI:
	case OP_BNE:
	case OP_BPL:
	case OP_BVS:
	case OP_BVC:
	  /* Invert the sense of the test.  */
	  buffer[0] ^= 0x20;
	  buffer[1] = 3;	/* Jump over following brl.  */
	  buffer[2] = OP_BRL;
	  buffer[3] = 0;
	  buffer[4] = 0;
	  disp_size = 2;
	  inst_size = 3;
	  break;
	default:
	  abort ();
	}
      break;
    case C (UNCOND_BRANCH, WORD_DISP):
      /* Unconditional branches to a known 16 bit displacement.  */

      switch (buffer[0])
	{
	case OP_BRA:
	  buffer[0] = OP_BRL;
	  disp_size = 2;
	  inst_size = 1;
	  break;
	default:
	  abort ();
	}
      break;
      /* Got to create a branch over a reloc here.  */
    case C (COND_BRANCH, UNDEF_WORD_DISP):
      buffer[0] ^= 0x20;	/* Invert test.  */
      buffer[1] = 3;
      buffer[2] = OP_BRL;
      buffer[3] = 0;
      buffer[4] = 0;
      fix_new (fragP,
	       fragP->fr_fix + 3,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       R_W65_PCR16);

      fragP->fr_fix += disp_size + inst_size;
      fragP->fr_var = 0;
      break;
    case C (UNCOND_BRANCH, UNDEF_WORD_DISP):
      buffer[0] = OP_BRL;
      buffer[1] = 0;
      buffer[2] = 0;
      fix_new (fragP,
	       fragP->fr_fix + 1,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       R_W65_PCR16);

      fragP->fr_fix += disp_size + inst_size;
      fragP->fr_var = 0;
      break;
    default:
      abort ();
    }
  if (inst_size)
    {
      /* Get the address of the end of the instruction.  */
      int next_inst = (fragP->fr_fix + fragP->fr_address
		       + disp_size + inst_size);
      int targ_addr = (S_GET_VALUE (fragP->fr_symbol) +
		       fragP->fr_offset);
      int disp = targ_addr - next_inst;

      md_number_to_chars ((char *) buffer + inst_size, disp, disp_size);
      fragP->fr_fix += disp_size + inst_size;
      fragP->fr_var = 0;
    }
}

valueT
md_section_align (segT seg, valueT size)
{
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
}

void
md_apply_fix (fixS *fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
{
  long val = * (long *) valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  int addr = fixP->fx_frag->fr_address + fixP->fx_where;

  if (fixP->fx_r_type == 0)
    {
      if (fixP->fx_size == 1)
	fixP->fx_r_type = R_W65_ABS8;
      else
	fixP->fx_r_type = R_W65_ABS16;
    }

  switch (fixP->fx_r_type)
    {
    case R_W65_ABS8S16:
      val >>= 8;
    case R_W65_ABS8S8:
      val >>= 8;
    case R_W65_ABS8:
      *buf++ = val;
      break;
    case R_W65_ABS16S16:
      val >>= 8;
    case R_W65_ABS16S8:
      val >>= 8;
    case R_W65_ABS16:
      *buf++ = val >> 0;
      *buf++ = val >> 8;
      break;
    case R_W65_ABS24:
      *buf++ = val >> 0;
      *buf++ = val >> 8;
      *buf++ = val >> 16;
      break;
    case R_W65_PCR8:
      *buf++ = val - addr - 1;
      break;
    case R_W65_PCR16:
      val = val - addr - 1;
      *buf++ = val;
      *buf++ = val >> 8;
      break;
    case R_W65_DP:
      *buf++ = val;
      break;

    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Put number into target byte order.  */

void
md_number_to_chars (char *ptr, valueT use, int nbytes)
{
  number_to_chars_littleendian (ptr, use, nbytes);
}

long
md_pcrel_from (fixS *fixP)
{
  int gap = fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address - 1;
  return gap;
}

void
tc_coff_symbol_emit_hook (symbolS *x ATTRIBUTE_UNUSED)
{
}

short
tc_coff_fix2rtype (fixS *fix_ptr)
{
  return fix_ptr->fx_r_type;
}

void
tc_reloc_mangle (fixS *fix_ptr,
		 struct internal_reloc *intr,
		 bfd_vma base)

{
  symbolS *symbol_ptr;

  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it */
  if (fix_ptr->fx_r_type == RELOC_32)
    {
      /* Cons likes to create reloc32's whatever the size of the reloc.  */
      switch (fix_ptr->fx_size)
	{
	case 2:
	  intr->r_type = R_IMM16;
	  break;
	case 1:
	  intr->r_type = R_IMM8;
	  break;
	default:
	  abort ();
	}
    }
  else
    {
      if (fix_ptr->fx_size == 4)
	intr->r_type = R_W65_ABS24;
      else
	intr->r_type = fix_ptr->fx_r_type;
    }

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  /* Turn the segment of the symbol into an offset.  */
  if (symbol_ptr)
    {
      symbolS *dot;

      dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
      if (dot)
	{
	  intr->r_offset += S_GET_VALUE (symbol_ptr);
	  intr->r_symndx = dot->sy_number;
	}
      else
	intr->r_symndx = symbol_ptr->sy_number;
    }
  else
    intr->r_symndx = -1;
}

int
tc_coff_sizemachdep (fragS *frag)
{
  return md_relax_table[frag->fr_subtype].rlx_length;
}

/* Called just before address relaxation, return the length by which a
   fragment must grow to reach it's destination.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment_type)
{
  int what;

  switch (fragP->fr_subtype)
    {
    default:
      abort ();

    case C (COND_BRANCH, UNDEF_BYTE_DISP):
    case C (UNCOND_BRANCH, UNDEF_BYTE_DISP):
      what = GET_WHAT (fragP->fr_subtype);
      /* Used to be a branch to somewhere which was unknown.  */
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	/* Got a symbol and it's defined in this segment, become byte
	   sized - maybe it will fix up.  */
	fragP->fr_subtype = C (what, BYTE_DISP);
      else
	/* Its got a segment, but its not ours, so it will always be
	   long.  */
	fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
      break;

    case C (COND_BRANCH, BYTE_DISP):
    case C (COND_BRANCH, WORD_DISP):
    case C (COND_BRANCH, UNDEF_WORD_DISP):
    case C (UNCOND_BRANCH, BYTE_DISP):
    case C (UNCOND_BRANCH, WORD_DISP):
    case C (UNCOND_BRANCH, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
    }

  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
  return fragP->fr_var;
}

const char *md_shortopts = "";
struct option md_longopts[] =
{
#define OPTION_RELAX (OPTION_MD_BASE)
  {NULL, no_argument, NULL, 0}
};

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
}

size_t md_longopts_size = sizeof (md_longopts);
@


1.19
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@@


1.18
log
@Update the address and phone number of the FSF
@
text
@d882 1
a882 1
md_apply_fix3 (fixS *fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
@


1.17
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.16
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d31 1
a31 1
const char comment_chars[] = "!";
d33 1
a33 1
const char line_comment_chars[] = "!#";
d40 1
a40 1
   Integer arg to pass to the function  */
d53 2
a54 5
static void s_longa PARAMS ((int));
static char *parse_exp PARAMS ((char *));
static char *get_operands PARAMS ((const struct opinfo *, char *));
static const struct opinfo *get_specific PARAMS ((const struct opinfo *));
static void build_Mytes PARAMS ((const struct opinfo *));
d56 25
d82 2
a83 1
const pseudo_typeS md_pseudo_table[] = {
d101 2
a102 2
int M;				/* M flag */
int X;				/* X flag */
d104 1
a104 2
#define C(a,b) ENCODE_RELAX(a,b)
#define ENCODE_RELAX(what,length) (((what) << 2) + (length))
d106 2
a107 4
#define GET_WHAT(x) ((x>>2))

#define BYTE_DISP 1
#define WORD_DISP 2
a109 1

d112 1
a112 1
#define END 	3
d114 2
a115 2
#define BYTE_F 127		/* How far we can branch forwards */
#define BYTE_B -126		/* How far we can branch backwards */
d119 2
a120 1
relax_typeS md_relax_table[C (END, 0)] = {
a136 1

a138 26
/* This function is called once, at assembler startup time.  This
   should set up all the tables, etc that the MD part of the assembler
   needs.  */

static void
s_longa (xmode)
     int xmode;
{
  int *p = xmode ? &X : &M;
  while (*input_line_pointer == ' ')
    input_line_pointer++;
  if (strncmp (input_line_pointer, "on", 2) == 0)
    {
      input_line_pointer += 2;
      *p = 0;
    }
  else if (strncmp (input_line_pointer, "off", 3) == 0)
    {
      *p = 1;
      input_line_pointer += 3;
    }
  else
    as_bad (_("need on or off."));
  demand_empty_rest_of_line ();
}

d140 1
a140 1
md_begin ()
d160 2
a161 2
static expressionS immediate;	/* absolute expression */
static expressionS immediate1;	/* absolute expression */
d167 1
a167 2
w65_expression (dest)
     expressionS *dest;
d197 1
a197 2
parse_exp (s)
     char *s;
d213 1
a213 3
get_operands (info, ptr)
     const struct opinfo *info;
     char *ptr;
d215 2
a216 2
  register int override_len = 0;
  register int bytes = 0;
d266 1
a266 3
	    {
	      as_bad (_("syntax error after <exp"));
	    }
d307 1
a307 3
	    {
	      as_bad (_("syntax error after <exp"));
	    }
d316 1
a316 3
    {
      amode = ADDR_ACC;
    }
d349 2
a350 3
	{
	  override_len = 0;
	}
a399 1

d406 1
d551 1
a551 2
get_specific (opcode)
     const struct opinfo *opcode;
d556 3
a558 4
    {
      if (opcode->amode == amode)
	return opcode;
    }
d565 1
a565 2
build_Mytes (opcode)
     const struct opinfo *opcode;
d573 2
a574 3
    {
      output = frag_more (1);
    }
d644 1
a644 2
md_assemble (str)
     char *str;
d653 1
a653 1
  /* all opcodes are three letters */
d692 1
a692 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d707 1
a707 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d758 1
a758 3
md_parse_option (c, a)
     int c ATTRIBUTE_UNUSED;
     char *a ATTRIBUTE_UNUSED;
d767 3
a769 4
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP;
d796 1
a796 1
	  /* Invert the sense of the test */
d798 1
a798 1
	  buffer[1] = 3;	/* Jump over following brl */
d825 1
a825 1
      buffer[0] ^= 0x20;	/* invert test */
d875 1
a875 3
md_section_align (seg, size)
     segT seg;
     valueT size;
d882 1
a882 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d941 1
a941 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
d947 1
a947 2
md_pcrel_from (fixP)
     fixS *fixP;
d954 1
a954 2
tc_coff_symbol_emit_hook (x)
     symbolS *x ATTRIBUTE_UNUSED;
d959 1
a959 2
tc_coff_fix2rtype (fix_ptr)
     fixS *fix_ptr;
d965 3
a967 4
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;
d978 1
a978 2
      /* cons likes to create reloc32's whatever the size of the reloc..
       */
d1014 1
a1014 3
	{
	  intr->r_symndx = symbol_ptr->sy_number;
	}
d1017 1
a1017 3
    {
      intr->r_symndx = -1;
    }
d1021 1
a1021 2
tc_coff_sizemachdep (frag)
     fragS *frag;
d1030 1
a1030 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP;
     register segT segment_type;
d1044 3
a1046 5
	{
	  /* Got a symbol and it's defined in this segment, become byte
	     sized - maybe it will fix up.  */
	  fragP->fr_subtype = C (what, BYTE_DISP);
	}
d1048 3
a1050 5
	{
	  /* Its got a segment, but its not ours, so it will always be
             long.  */
	  fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
	}
d1069 2
a1070 1
struct option md_longopts[] = {
d1076 1
a1076 2
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
@


1.15
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 2
a3 1
   Copyright 1995, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
d898 1
a898 1
      md_number_to_chars (buffer + inst_size, disp, disp_size);
@


1.14
log
@	* config/tc-w65.c (s_longa): Prototype.  Make static, specify int arg.
	(cons, s_align_bytes): Delete declaration.
	(relax): Delete.
	(md_begin): Constify "struct opinfo *" var.  Don't try to make "name"
	strings common.
	(dot): Delete unused function.
	(w65_expression): Remove unused arg.
	(parse_exp): Prototype.  Remove unused arg.  Adjust w65_expression
	call.
	(get_operands): Prototype.  Constify "struct opinfo *" arg.  Fix
	parse_exp call.
	(get_specific): Prototype.  Constify "struct opinfo *" arg and return
	value.
	(check): Remove unused function.
	(build_Mytes): Prototype.  Constify "struct opinfo *" arg.  Abort
	on unhandled switch case.
	(md_assemble): Remove unused op_start, op_end, nlen, p vars.  Constify
	"opcode".
	(tc_crawl_symbol_chain): Delete unused function.
	(tc_headers_hook): Likewise.
	(tc_Nout_fix_to_chars): Likewise.
	(md_undefined_symbol): Add ATTRIBUTE_UNUSED.
	(md_parse_option): Likewise.
	(md_convert_frag): Likewise.
	(tc_coff_symbol_emit_hook): Likewise.
	(md_show_usage): Likewise.
	* config/tc-w65.h (tc_coff_sizemachdep): Declare.
	(TC_PARSE_CONS_EXPRESSION): w65_expression takes one arg.
	(w65_expression): Declare.

	* po/POTFILES.in: Regenerate.
@
text
@a66 4
#if 0
int md_reloc_size;
#endif

@


1.13
log
@	* config/tc-w65.c (md_section_align): Fix typo.
	(md_parse_option): Return 0, not 1.
@
text
@d52 6
a57 1
void s_longa ();
a66 3
void cons ();
void s_align_bytes ();

a70 2
static int relax;		/* set if -relax seen */

d127 1
a127 1
void
d129 1
d152 1
a152 1
  struct opinfo *opcode;
a164 6
      else
	{
	  /* Make all the opcodes with the same name point to the same
	     string.  */
	  opcode->name = prev_name;
	}
a171 16

static symbolS *
dot ()
{
  const char *fake;

  /* JF: '.' is pseudo symbol with value of current location
     in current segment.  */
  fake = FAKE_LABEL_NAME;
  return symbol_new (fake,
		     now_seg,
		     (valueT) frag_now_fix (),
		     frag_now);

}

d177 1
a177 1
w65_expression (dest, bytes)
a178 1
     unsigned int bytes;
d208 1
a208 1
parse_exp (s, bytes)
a209 1
     int bytes;
d216 1
a216 1
  w65_expression (&immediate, bytes);
d226 1
a226 1
     struct opinfo *info;
d454 1
a454 1
      ptr = parse_exp (ptr, 2);
d571 1
a571 1
static struct opinfo *
d573 1
a573 1
     struct opinfo *opcode;
a584 17
int
check (operand, low, high)
     expressionS *operand;
     int low;
     int high;
{
  if (operand->X_op != O_constant
      || operand->X_add_number < low
      || operand->X_add_number > high)
    {
      as_bad ("operand must be absolute in range %d..%d", low, high);
    }
  return operand->X_add_number;
}

static int log2[] = { 0, 0, 1, 0, 2 };

d589 1
a589 1
     struct opinfo *opcode;
d619 2
d672 1
a672 3
  unsigned char *op_start;
  unsigned char *op_end;
  struct opinfo *opcode;
a673 2
  int nlen = 0;
  char *p;
a716 7
void
tc_crawl_symbol_chain (headers)
     object_headers *headers;
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}

d719 1
a719 1
     char *name;
a723 7
void
tc_headers_hook (headers)
     object_headers *headers;
{
  printf (_("call to tc_headers_hook \n"));
}

a742 1
  char *atof_ieee ();
d789 2
a790 2
     int c;
     char *a;
a794 7
void
tc_Nout_fix_to_chars ()
{
  printf (_("call to tc_Nout_fix_to_chars \n"));
  abort ();
}

d800 2
a801 2
     object_headers *headers;
     segT seg;
d997 1
a997 1
     symbolS *x;
d1133 1
a1133 1
     FILE *stream;
@


1.12
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d849 1
a849 1
  return 1;
d983 1
a983 1
     vauleT * valP;
@


1.12.2.1
log
@	* config/tc-w65.c (md_section_align): Fix typo.
	(md_parse_option): Return 0, not 1.
@
text
@d849 1
a849 1
  return 0;
d983 1
a983 1
     valueT * valP;
@


1.11
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001 Free Software Foundation, Inc.
d31 1
a31 1
CONST char line_separator_chars[] = ";";
d1189 1
a1189 1
CONST char *md_shortopts = "";
@


1.10
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d981 1
a981 1
md_apply_fix (fixP, val)
d983 2
a984 1
     long val;
d986 1
d1035 3
d1040 1
a1040 1
/* Put number into target byte order */
@


1.9
log
@Fix more breakages from the multiple relax pass patch.
@
text
@a28 1
#include <ctype.h>
@


1.8
log
@Prepare for multi-pass relaxation.
@
text
@d104 19
a122 1
relax_typeS md_relax_table[C (END, 0)];
a151 1
  relax_typeS *table;
a172 23
  /* Initialize the relax table.  We use a local variable to avoid
     warnings about modifying a supposedly const data structure.  */
  table = (relax_typeS *) md_relax_table;
  table[C (COND_BRANCH, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (COND_BRANCH, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (COND_BRANCH, BYTE_DISP)].rlx_length = 2;
  table[C (COND_BRANCH, BYTE_DISP)].rlx_more = C (COND_BRANCH, WORD_DISP);

  table[C (COND_BRANCH, WORD_DISP)].rlx_forward = WORD_F;
  table[C (COND_BRANCH, WORD_DISP)].rlx_backward = WORD_B;
  table[C (COND_BRANCH, WORD_DISP)].rlx_length = 5;
  table[C (COND_BRANCH, WORD_DISP)].rlx_more = 0;

  table[C (UNCOND_BRANCH, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (UNCOND_BRANCH, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (UNCOND_BRANCH, BYTE_DISP)].rlx_length = 2;
  table[C (UNCOND_BRANCH, BYTE_DISP)].rlx_more = C (UNCOND_BRANCH, WORD_DISP);

  table[C (UNCOND_BRANCH, WORD_DISP)].rlx_forward = WORD_F;
  table[C (UNCOND_BRANCH, WORD_DISP)].rlx_backward = WORD_B;
  table[C (UNCOND_BRANCH, WORD_DISP)].rlx_length = 3;
  table[C (UNCOND_BRANCH, WORD_DISP)].rlx_more = 0;

d1145 1
a1145 1
  int what = GET_WHAT (fragP->fr_subtype);
d1154 1
a1160 1
	  fragP->fr_var = md_relax_table[C (what, BYTE_DISP)].rlx_length;
a1166 1
	  fragP->fr_var = md_relax_table[C (what, WORD_DISP)].rlx_length;
d1172 1
d1175 1
d1177 1
a1177 1
	 do anything.  */
d1180 2
@


1.7
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000 Free Software Foundation, Inc.
d1157 1
a1173 1
	  return md_relax_table[C (what, WORD_DISP)].rlx_length;
d1175 9
@


1.6
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-tic30.c: Fix formatting.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1998, 2000 Free Software Foundation.
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001 Free Software Foundation, Inc.
@


1.6.2.2
log
@Merge from mainline.
@
text
@d104 1
a104 19
relax_typeS md_relax_table[C (END, 0)] = {
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },

  /* COND_BRANCH */
  { 0,       0,       0,  0 },				/* UNDEF_BYTE_DISP */
  { BYTE_F,  BYTE_B,  2,  C (COND_BRANCH, WORD_DISP) },	/* BYTE_DISP */
  { WORD_F,  WORD_B,  5,  0 },				/* WORD_DISP */
  { 0,       0,       5,  0 },				/* UNDEF_WORD_DISP */

  /* UNCOND_BRANCH */
  { 0,       0,       0,  0 },				  /* UNDEF_BYTE_DISP */
  { BYTE_F,  BYTE_B,  2,  C (UNCOND_BRANCH, WORD_DISP) }, /* BYTE_DISP */
  { WORD_F,  WORD_B,  3,  0 },				  /* WORD_DISP */
  { 0,       0,       3,  0 }				  /* UNDEF_WORD_DISP */

};
d134 1
d156 23
d1151 1
a1151 1
  int what;
a1156 1

a1158 1
      what = GET_WHAT (fragP->fr_subtype);
d1165 1
d1172 2
a1174 11
      break;

    case C (COND_BRANCH, BYTE_DISP):
    case C (COND_BRANCH, WORD_DISP):
    case C (COND_BRANCH, UNDEF_WORD_DISP):
    case C (UNCOND_BRANCH, BYTE_DISP):
    case C (UNCOND_BRANCH, WORD_DISP):
    case C (UNCOND_BRANCH, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
a1175 2

  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
@


1.5
log
@Fix formatting
@
text
@d54 2
a55 2
const pseudo_typeS md_pseudo_table[] =
{
d74 1
a74 1
/* Chars that mean this number is a floating point constant */
d79 2
a80 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
@


1.4
log
@Fix spelling typos.
Remove use of DEFUN().
@
text
@d21 1
a21 4
/*
   Written By Steve Chamberlain
   sac@@cygnus.com
 */
d37 1
d40 1
a40 2
   Integer arg to pass to the function
 */
a62 1

d66 3
a68 2

/*int md_reloc_size; */
a78 2


a83 3



d105 3
a107 5
/*
   This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs
 */

d129 1
d139 1
a139 1
  /* Insert unique names into hash table */
d150 1
a150 1
	     string */
a154 1

a183 1

d202 1
d234 2
a235 2
static
char *
d253 1
a253 3

static
char *
d260 1
d421 2
a422 1
	  else if (ptr[0] == 's' && ptr[1] == ')' && ptr[2] == ',' && ptr[3] == 'y')
a452 1

d468 6
a473 1
	      if (info->code == O_jmp) 
d475 3
a477 9
		bytes = 2;
		amode = ADDR_ABS_IND_LONG;
	      } 
	      else 
{
		bytes = 1;
	      
		amode = ADDR_DIR_IND_LONG;
	      }
d567 1
a567 1
	tc_cons_reloc = R_W65_DP;
d569 1
a569 1
tc_cons_reloc = R_W65_ABS8;
d598 1
a598 2
   provided
 */
d600 1
a600 2
static
struct opinfo *
d629 1
d631 1
a631 2
static int log2[] =
{0, 0, 1, 0, 2};
a632 1
/* Now we know what sort of opcodes it is, let's build the bytes.  */
d649 2
a650 1
      /* This is a relaxable insn, so we do some special handling */
d667 2
a668 2
      /* If something special was done in the
	 expression modify the reloc type */
d670 1
a670 5
	{
	  type = tc_cons_reloc;
	}


d672 1
a672 1
      /* 1 byte for the opcode + the bytes for the addrmode */
d677 1
a677 1
	  /* Two relocs for this one */
d708 3
a710 4
/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.
 */
d752 1
a752 2
      /* Couldn't find an opcode which matched the operands */

a764 1

d786 2
a787 2
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
d790 5
a794 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
d851 3
a853 4
md_parse_option (c,a)
    int c;
    char *a;

d865 3
a867 3
/*
called after relaxing, change the frags so they know how big they are
*/
d876 2
a877 1
  unsigned char *buffer = (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
d887 1
a887 1
      /* cond branches to a known 16 bit displacement */
d913 1
a913 1
      /* Unconditional branches to a known 16 bit displacement */
d926 1
a926 1
      /* got to create a branch over a reloc here */
d964 3
a966 2
      /* Get the address of the end of the instruction */
      int next_inst = fragP->fr_fix + fragP->fr_address + disp_size + inst_size;
a976 1

a983 1

d1062 1
a1062 1
    symbolS *x;
d1142 2
a1144 7



/*
called just before address relaxation, return the length
by which a fragment must grow to reach it's destination
*/
d1158 1
a1158 1
      /* used to be a branch to somewhere which was unknown */
d1162 1
a1162 1
	 sized - maybe it will fix up */
d1168 2
a1169 1
	  /* Its got a segment, but its not ours, so it will always be long */
a1177 2


a1187 1

d1190 1
a1190 1
size_t md_longopts_size = sizeof(md_longopts);
@


1.3
log
@Blow away DEFUN.
@
text
@d647 1
a647 2
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1998 Free Software Foundation.
d788 2
a789 2
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
d795 2
a796 2
DEFUN (md_undefined_symbol, (name),
       char *name)
d802 2
a803 2
DEFUN (tc_headers_hook, (headers),
       object_headers * headers)
d999 3
a1001 3
DEFUN (md_section_align, (seg, size),
       segT seg AND
       valueT size)
@


1.1
log
@Initial revision
@
text
@d1084 1
a1084 1
    struct symbol *x;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

