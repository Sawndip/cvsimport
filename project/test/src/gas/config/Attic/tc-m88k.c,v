head	1.24;
access;
symbols
	binutils-csl-sourcerygxx-3_4_4-32:1.20
	binutils-csl-sourcerygxx-3_4_4-25:1.20
	binutils-csl-wrs-linux-3_4_4-24:1.20
	binutils-csl-wrs-linux-3_4_4-23:1.20
	binutils-csl-wrs-linux-3_4_4-22:1.20
	binutils-csl-wrs-linux-3_4_4-21:1.20
	binutils-csl-wrs-linux-3_4_4-20:1.20
	binutils-csl-gxxpro-3_4-branch:1.20.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.20
	binutils-2_16_1:1.20
	binutils-csl-arm-2005q1b:1.20
	binutils-2_16:1.20
	binutils-csl-arm-2005q1a:1.20
	binutils-csl-arm-2005q1-branch:1.20.0.4
	binutils-csl-arm-2005q1-branchpoint:1.20
	binutils-2_16-branch:1.20.0.2
	binutils-2_16-branchpoint:1.20
	csl-arm-2004-q3d:1.19
	csl-arm-2004-q3:1.19
	binutils-2_15:1.19
	binutils-2_15-branchpoint:1.19
	csl-arm-2004-q1a:1.19
	csl-arm-2004-q1:1.19
	binutils-2_15-branch:1.19.0.6
	cagney_bfdfile-20040213-branch:1.19.0.4
	cagney_bfdfile-20040213-branchpoint:1.19
	cagney_bigcore-20040122-branch:1.19.0.2
	cagney_bigcore-20040122-branchpoint:1.19
	csl-arm-2003-q4:1.19
	binutils-2_14:1.18
	binutils-2_14-branch:1.18.0.2
	binutils-2_14-branchpoint:1.18
	binutils-2_13_2_1:1.17
	binutils-2_13_2:1.17
	binutils-2_13_1:1.17
	binutils-2_13:1.17
	binutils-2_13-branchpoint:1.17
	binutils-2_13-branch:1.17.0.2
	binutils-2_12_1:1.16
	binutils-2_12:1.16
	binutils-2_12-branch:1.16.0.2
	binutils-2_12-branchpoint:1.16
	cygnus_cvs_20020108_pre:1.16
	binutils-2_11_2:1.6.2.1
	binutils-2_11_1:1.6.2.1
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.23
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2005.08.11.01.25.23;	author amodra;	state dead;
branches;
next	1.23;

1.23
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.05.09.12.59;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.24.20.40.27;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.03.11.47.53;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.12.22.14.13;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.20.03.33.30;	author bje;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.15.21.28.56;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.19.05.33.26;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.23.14.02.12;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.05.07.28.06;	author bje;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.01.06.36.43;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.24.06.01.49;	author bje;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.24.01.56.48;	author bje;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.23.23.02.57;	author bje;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.28.10.07.56;	author rth;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.20.22.05.08;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.02.02.52.10;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.06.22.14.52.56;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.15.31;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.24
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* m88k.c -- Assembler for the Motorola 88000
   Contributed by Devon Bowen of Buffalo University
   and Torbjorn Granlund of the Swedish Institute of Computer Science.
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
   2000, 2001, 2002, 2003, 2005
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "m88k-opcode.h"

struct field_val_assoc
{
  char *name;
  unsigned val;
};

struct field_val_assoc cr_regs[] =
{
  {"PID", 0},
  {"PSR", 1},
  {"EPSR", 2},
  {"SSBR", 3},
  {"SXIP", 4},
  {"SNIP", 5},
  {"SFIP", 6},
  {"VBR", 7},
  {"DMT0", 8},
  {"DMD0", 9},
  {"DMA0", 10},
  {"DMT1", 11},
  {"DMD1", 12},
  {"DMA1", 13},
  {"DMT2", 14},
  {"DMD2", 15},
  {"DMA2", 16},
  {"SR0", 17},
  {"SR1", 18},
  {"SR2", 19},
  {"SR3", 20},

  {NULL, 0},
};

struct field_val_assoc fcr_regs[] =
{
  {"FPECR", 0},
  {"FPHS1", 1},
  {"FPLS1", 2},
  {"FPHS2", 3},
  {"FPLS2", 4},
  {"FPPT", 5},
  {"FPRH", 6},
  {"FPRL", 7},
  {"FPIT", 8},

  {"FPSR", 62},
  {"FPCR", 63},

  {NULL, 0},
};

struct field_val_assoc cmpslot[] =
{
/* Integer	Floating point.  */
  {"nc", 0},
  {"cp", 1},
  {"eq", 2},
  {"ne", 3},
  {"gt", 4},
  {"le", 5},
  {"lt", 6},
  {"ge", 7},
  {"hi", 8},	{"ou", 8},
  {"ls", 9},	{"ib", 9},
  {"lo", 10},	{"in", 10},
  {"hs", 11},	{"ob", 11},
  {"be", 12},	{"ue", 12},
  {"nb", 13},	{"lg", 13},
  {"he", 14},	{"ug", 14},
  {"nh", 15},	{"ule", 15},
		{"ul", 16},
		{"uge", 17},

  {NULL, 0},
};

struct field_val_assoc cndmsk[] =
{
  {"gt0", 1},
  {"eq0", 2},
  {"ge0", 3},
  {"lt0", 12},
  {"ne0", 13},
  {"le0", 14},

  {NULL, 0},
};

struct m88k_insn
{
  unsigned long opcode;
  expressionS exp;
  enum reloc_type reloc;
};

extern char *myname;
static struct hash_control *op_hash = NULL;

/* These bits should be turned off in the first address of every segment.  */
int md_seg_align = 7;

/* These chars start a comment anywhere in a source file (except inside
   another comment.  */
const char comment_chars[] = ";";

/* These chars only start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = "";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   as in 0f123.456
   or    0H1.234E-12 (see exp chars above).  */
const char FLT_CHARS[] = "dDfF";

void
md_begin (void)
{
  const char *retval = NULL;
  unsigned int i = 0;

  /* Initialize hash table.  */
  op_hash = hash_new ();

  while (*m88k_opcodes[i].name)
    {
      char *name = m88k_opcodes[i].name;

      /* Hash each mnemonic and record its position.  */
      retval = hash_insert (op_hash, name, &m88k_opcodes[i]);

      if (retval != NULL)
	as_fatal (_("Can't hash instruction '%s':%s"),
		  m88k_opcodes[i].name, retval);

      /* Skip to next unique mnemonic or end of list.  */
      for (i++; !strcmp (m88k_opcodes[i].name, name); i++)
	;
    }
}

const char *md_shortopts = "";
struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
}

static char *
get_o6 (char *param, unsigned *valp)
{
  unsigned val;
  char *save_ptr;

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  val = get_absolute_expression ();
  param = input_line_pointer;
  input_line_pointer = save_ptr;

  if (val & 0x3)
    as_warn (_("Removed lower 2 bits of expression"));

  *valp = val;

  return (param);
}

static char *
get_vec9 (char *param, unsigned *valp)
{
  unsigned val;
  char *save_ptr;

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  val = get_absolute_expression ();
  param = input_line_pointer;
  input_line_pointer = save_ptr;

  if (val >= 1 << 9)
    as_warn (_("Expression truncated to 9 bits"));

  *valp = val % (1 << 9);

  return param;
}

static char *
get_bf2 (char *param, int bc)
{
  int depth = 0;
  int c;

  for (;;)
    {
      c = *param;
      if (c == 0)
	return param;
      else if (c == '(')
	depth++;
      else if (c == ')')
	depth--;
      else if (c == bc && depth <= 0)
	return param;
      param++;
    }
}

static char *
match_name (char *param,
	    struct field_val_assoc *assoc_tab,
	    unsigned *valp)
{
  int i;
  char *name;
  int name_len;

  for (i = 0;; i++)
    {
      name = assoc_tab[i].name;
      if (name == NULL)
	return NULL;
      name_len = strlen (name);
      if (!strncmp (param, name, name_len))
	{
	  *valp = assoc_tab[i].val;
	  return param + name_len;
	}
    }
}

static char *
get_bf_offset_expression (char *param, unsigned *offsetp)
{
  unsigned offset;

  if (ISALPHA (param[0]))
    {
      param[0] = TOLOWER (param[0]);
      param[1] = TOLOWER (param[1]);

      param = match_name (param, cmpslot, offsetp);

      return param;
    }
  else
    {
      input_line_pointer = param;
      offset = get_absolute_expression ();
      param = input_line_pointer;
    }

  *offsetp = offset;
  return param;
}

static char *
get_bf (char *param, unsigned *valp)
{
  unsigned offset = 0;
  unsigned width = 0;
  char *xp;
  char *save_ptr;

  xp = get_bf2 (param, '<');

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  if (*xp == 0)
    {
      /* We did not find '<'.  We have an offset (width implicitly 32).  */
      param = get_bf_offset_expression (param, &offset);
      input_line_pointer = save_ptr;
      if (param == NULL)
	return NULL;
    }
  else
    {
      *xp++ = 0;		/* Overwrite the '<'.  */
      param = get_bf2 (xp, '>');
      if (*param == 0)
	return NULL;
      *param++ = 0;		/* Overwrite the '>'.  */

      width = get_absolute_expression ();
      xp = get_bf_offset_expression (xp, &offset);
      input_line_pointer = save_ptr;

      if (xp + 1 != param)
	return NULL;
    }

  *valp = ((width % 32) << 5) | (offset % 32);

  return param;
}

static char *
get_cr (char *param, unsigned *regnop)
{
  unsigned regno;
  unsigned c;

  if (!strncmp (param, "cr", 2))
    {
      param += 2;

      regno = *param++ - '0';
      if (regno < 10)
	{
	  if (regno == 0)
	    {
	      *regnop = 0;
	      return param;
	    }
	  c = *param - '0';
	  if (c < 10)
	    {
	      regno = regno * 10 + c;
	      if (c < 64)
		{
		  *regnop = regno;
		  return param + 1;
		}
	    }
	  else
	    {
	      *regnop = regno;
	      return param;
	    }
	}
      return NULL;
    }

  param = match_name (param, cr_regs, regnop);

  return param;
}

static char *
get_fcr (char *param, unsigned *regnop)
{
  unsigned regno;
  unsigned c;

  if (!strncmp (param, "fcr", 3))
    {
      param += 3;

      regno = *param++ - '0';
      if (regno < 10)
	{
	  if (regno == 0)
	    {
	      *regnop = 0;
	      return param;
	    }
	  c = *param - '0';
	  if (c < 10)
	    {
	      regno = regno * 10 + c;
	      if (c < 64)
		{
		  *regnop = regno;
		  return param + 1;
		}
	    }
	  else
	    {
	      *regnop = regno;
	      return param;
	    }
	}
      return NULL;
    }

  param = match_name (param, fcr_regs, regnop);

  return param;
}

#define hexval(z) \
  (ISDIGIT (z) ? (z) - '0' :						\
   ISLOWER (z) ? (z) - 'a' + 10 : 					\
   ISUPPER (z) ? (z) - 'A' + 10 : (unsigned) -1)

static char *
getval (char *param, unsigned int *valp)
{
  unsigned int val = 0;
  unsigned int c;

  c = *param++;
  if (c == '0')
    {
      c = *param++;
      if (c == 'x' || c == 'X')
	{
	  c = *param++;
	  c = hexval (c);
	  while (c < 16)
	    {
	      val = val * 16 + c;
	      c = *param++;
	      c = hexval (c);
	    }
	}
      else
	{
	  c -= '0';
	  while (c < 8)
	    {
	      val = val * 8 + c;
	      c = *param++ - '0';
	    }
	}
    }
  else
    {
      c -= '0';
      while (c < 10)
	{
	  val = val * 10 + c;
	  c = *param++ - '0';
	}
    }

  *valp = val;
  return param - 1;
}

static char *
get_cnd (char *param, unsigned *valp)
{
  unsigned int val;

  if (ISDIGIT (*param))
    {
      param = getval (param, &val);

      if (val >= 32)
	{
	  as_warn (_("Expression truncated to 5 bits"));
	  val %= 32;
	}
    }
  else
    {
      param[0] = TOLOWER (param[0]);
      param[1] = TOLOWER (param[1]);

      param = match_name (param, cndmsk, valp);

      if (param == NULL)
	return NULL;

      val = *valp;
    }

  *valp = val << 21;
  return param;
}

static char *
get_reg (char *param, unsigned *regnop, unsigned int reg_prefix)
{
  unsigned c;
  unsigned regno;

  c = *param++;
  if (c == reg_prefix)
    {
      regno = *param++ - '0';
      if (regno < 10)
	{
	  if (regno == 0)
	    {
	      *regnop = 0;
	      return param;
	    }
	  c = *param - '0';
	  if (c < 10)
	    {
	      regno = regno * 10 + c;
	      if (c < 32)
		{
		  *regnop = regno;
		  return param + 1;
		}
	    }
	  else
	    {
	      *regnop = regno;
	      return param;
	    }
	}
      return NULL;
    }
  else if (c == 's' && param[0] == 'p')
    {
      *regnop = 31;
      return param + 1;
    }

  return 0;
}

static char *
get_imm16 (char *param, struct m88k_insn *insn)
{
  enum reloc_type reloc = NO_RELOC;
  unsigned int val;
  char *save_ptr;

  if (!strncmp (param, "hi16", 4) && !ISALNUM (param[4]))
    {
      reloc = RELOC_HI16;
      param += 4;
    }
  else if (!strncmp (param, "lo16", 4) && !ISALNUM (param[4]))
    {
      reloc = RELOC_LO16;
      param += 4;
    }
  else if (!strncmp (param, "iw16", 4) && !ISALNUM (param[4]))
    {
      reloc = RELOC_IW16;
      param += 4;
    }

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  expression (&insn->exp);
  param = input_line_pointer;
  input_line_pointer = save_ptr;

  val = insn->exp.X_add_number;

  if (insn->exp.X_op == O_constant)
    {
      /* Insert the value now, and reset reloc to NO_RELOC.  */
      if (reloc == NO_RELOC)
	{
	  /* Warn about too big expressions if not surrounded by xx16.  */
	  if (val > 0xffff)
	    as_warn (_("Expression truncated to 16 bits"));
	}

      if (reloc == RELOC_HI16)
	val >>= 16;

      insn->opcode |= val & 0xffff;
      reloc = NO_RELOC;
    }
  else if (reloc == NO_RELOC)
    /* We accept a symbol even without lo16, hi16, etc, and assume
       lo16 was intended.  */
    reloc = RELOC_LO16;

  insn->reloc = reloc;

  return param;
}

static char *
get_pcr (char *param, struct m88k_insn *insn, enum reloc_type reloc)
{
  char *saveptr, *saveparam;

  saveptr = input_line_pointer;
  input_line_pointer = param;

  expression (&insn->exp);

  saveparam = input_line_pointer;
  input_line_pointer = saveptr;

  /* Botch: We should relocate now if O_constant.  */
  insn->reloc = reloc;

  return saveparam;
}

static char *
get_cmp (char *param, unsigned *valp)
{
  unsigned int val;
  char *save_ptr;

  save_ptr = param;

  param = match_name (param, cmpslot, valp);
  val = *valp;

  if (param == NULL)
    {
      param = save_ptr;

      save_ptr = input_line_pointer;
      input_line_pointer = param;
      val = get_absolute_expression ();
      param = input_line_pointer;
      input_line_pointer = save_ptr;

      if (val >= 32)
	{
	  as_warn (_("Expression truncated to 5 bits"));
	  val %= 32;
	}
    }

  *valp = val << 21;
  return param;
}

static int
calcop (struct m88k_opcode *format,
	char *param,
	struct m88k_insn *insn)
{
  char *fmt = format->op_spec;
  int f;
  unsigned val;
  unsigned opcode;
  unsigned int reg_prefix = 'r';

  insn->opcode = format->opcode;
  opcode = 0;

  for (;;)
    {
      if (param == 0)
	return 0;
      f = *fmt++;
      switch (f)
	{
	case 0:
	  insn->opcode |= opcode;
	  return (*param == 0 || *param == '\n');

	default:
	  if (f != *param++)
	    return 0;
	  break;

	case 'd':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val << 21;
	  break;

	case 'o':
	  param = get_o6 (param, &val);
	  opcode |= ((val >> 2) << 7);
	  break;

	case 'x':
	  reg_prefix = 'x';
	  break;

	case '1':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val << 16;
	  break;

	case '2':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val;
	  break;

	case '3':
	  param = get_reg (param, &val, 'r');
	  opcode |= (val << 16) | val;
	  break;

	case 'I':
	  param = get_imm16 (param, insn);
	  break;

	case 'b':
	  param = get_bf (param, &val);
	  opcode |= val;
	  break;

	case 'p':
	  param = get_pcr (param, insn, RELOC_PC16);
	  break;

	case 'P':
	  param = get_pcr (param, insn, RELOC_PC26);
	  break;

	case 'B':
	  param = get_cmp (param, &val);
	  opcode |= val;
	  break;

	case 'M':
	  param = get_cnd (param, &val);
	  opcode |= val;
	  break;

	case 'c':
	  param = get_cr (param, &val);
	  opcode |= val << 5;
	  break;

	case 'f':
	  param = get_fcr (param, &val);
	  opcode |= val << 5;
	  break;

	case 'V':
	  param = get_vec9 (param, &val);
	  opcode |= val;
	  break;

	case '?':
	  /* Having this here repeats the warning somtimes.
	   But can't we stand that?  */
	  as_warn (_("Use of obsolete instruction"));
	  break;
	}
    }
}

void
md_assemble (char *op)
{
  char *param, *thisfrag;
  char c;
  struct m88k_opcode *format;
  struct m88k_insn insn;

  assert (op);

  /* Skip over instruction to find parameters.  */
  for (param = op; *param != 0 && !ISSPACE (*param); param++)
    ;
  c = *param;
  *param++ = '\0';

  /* Try to find the instruction in the hash table.  */
  if ((format = (struct m88k_opcode *) hash_find (op_hash, op)) == NULL)
    {
      as_bad (_("Invalid mnemonic '%s'"), op);
      return;
    }

  /* Try parsing this instruction into insn.  */
  insn.exp.X_add_symbol = 0;
  insn.exp.X_op_symbol = 0;
  insn.exp.X_add_number = 0;
  insn.exp.X_op = O_illegal;
  insn.reloc = NO_RELOC;

  while (!calcop (format, param, &insn))
    {
      /* If it doesn't parse try the next instruction.  */
      if (!strcmp (format[0].name, format[1].name))
	format++;
      else
	{
	  as_fatal (_("Parameter syntax error"));
	  return;
	}
    }

  /* Grow the current frag and plop in the opcode.  */
  thisfrag = frag_more (4);
  md_number_to_chars (thisfrag, insn.opcode, 4);

  /* If this instruction requires labels mark it for later.  */
  switch (insn.reloc)
    {
    case NO_RELOC:
      break;

    case RELOC_LO16:
    case RELOC_HI16:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal + 2,
		   2,
		   &insn.exp,
		   0,
		   insn.reloc);
      break;

    case RELOC_IW16:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal,
		   4,
		   &insn.exp,
		   0,
		   insn.reloc);
      break;

    case RELOC_PC16:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal + 2,
		   2,
		   &insn.exp,
		   1,
		   insn.reloc);
      break;

    case RELOC_PC26:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal,
		   4,
		   &insn.exp,
		   1,
		   insn.reloc);
      break;

    default:
      as_fatal (_("Unknown relocation type"));
      break;
    }
}

void
md_number_to_chars (char *buf, valueT val, int nbytes)
{
  number_to_chars_bigendian (buf, val, nbytes);
}

#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

int md_short_jump_size = 4;

void
md_create_short_jump (char *ptr,
		      addressT from_addr ATTRIBUTE_UNUSED,
		      addressT to_addr ATTRIBUTE_UNUSED,
		      fragS *frag,
		      symbolS *to_symbol)
{
  ptr[0] = (char) 0xc0;
  ptr[1] = 0x00;
  ptr[2] = 0x00;
  ptr[3] = 0x00;
  fix_new (frag,
	   ptr - frag->fr_literal,
	   4,
	   to_symbol,
	   (offsetT) 0,
	   0,
	   RELOC_PC26);		/* Botch: Shouldn't this be RELOC_PC16? */
}

int md_long_jump_size = 4;

void
md_create_long_jump (char *ptr,
		     addressT from_addr ATTRIBUTE_UNUSED,
		     addressT to_addr ATTRIBUTE_UNUSED,
		     fragS *frag,
		     symbolS *to_symbol)
{
  ptr[0] = (char) 0xc0;
  ptr[1] = 0x00;
  ptr[2] = 0x00;
  ptr[3] = 0x00;
  fix_new (frag,
	   ptr - frag->fr_literal,
	   4,
	   to_symbol,
	   (offsetT) 0,
	   0,
	   RELOC_PC26);
}

int
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
			       segT segment_type ATTRIBUTE_UNUSED)
{
  as_fatal (_("Relaxation should never occur"));
  return -1;
}

#ifdef M88KCOFF

/* These functions are needed if we are linking with obj-coffbfd.c.
   That file may be replaced by a more BFD oriented version at some
   point.  If that happens, these functions should be reexamined.

   Ian Lance Taylor, Cygnus Support, 13 July 1993.  */

/* Given a fixS structure (created by a call to fix_new, above),
   return the BFD relocation type to use for it.  */

short
tc_coff_fix2rtype (fixS *fixp)
{
  switch (fixp->fx_r_type)
    {
    case RELOC_LO16:
      return R_LVRT16;
    case RELOC_HI16:
      return R_HVRT16;
    case RELOC_PC16:
      return R_PCR16L;
    case RELOC_PC26:
      return R_PCR26L;
    case RELOC_32:
      return R_VRT32;
    case RELOC_IW16:
      return R_VRT16;
    default:
      abort ();
    }
}

/* Apply a fixS to the object file.  Since COFF does not use addends
   in relocs, the addend is actually stored directly in the object
   file itself.  */

void
md_apply_fix (fixS *fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
{
  long val = * (long *) valP;
  char *buf;

  buf = fixP->fx_frag->fr_literal + fixP->fx_where;
  fixP->fx_offset = 0;

  switch (fixP->fx_r_type)
    {
    case RELOC_IW16:
      fixP->fx_offset = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_LO16:
      fixP->fx_offset = val >> 16;
      buf[0] = val >> 8;
      buf[1] = val;
      break;

    case RELOC_HI16:
      fixP->fx_offset = val >> 16;
      buf[0] = val >> 8;
      buf[1] = val;
      break;

    case RELOC_PC16:
      buf[0] = val >> 10;
      buf[1] = val >> 2;
      break;

    case RELOC_PC26:
      buf[0] |= (val >> 26) & 0x03;
      buf[1] = val >> 18;
      buf[2] = val >> 10;
      buf[3] = val >> 2;
      break;

    case RELOC_32:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Where a PC relative offset is calculated from.  On the m88k they
   are calculated from just after the instruction.  */

long
md_pcrel_from (fixS *fixp)
{
  switch (fixp->fx_r_type)
    {
    case RELOC_PC16:
      return fixp->fx_frag->fr_address + fixp->fx_where - 2;
    case RELOC_PC26:
      return fixp->fx_frag->fr_address + fixp->fx_where;
    default:
      abort ();
    }
}

/* Fill in rs_align_code fragments.  */

void
m88k_handle_align (fragS *fragp)
{
  static const unsigned char nop_pattern[] = { 0xf4, 0x00, 0x58, 0x00 };

  int bytes;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;

  if (bytes & 3)
    {
      int fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
      fragp->fr_fix += fix;
    }

  memcpy (p, nop_pattern, 4);
  fragp->fr_var = 4;
}

#endif /* M88KCOFF */

const pseudo_typeS md_pseudo_table[] =
{
  {"align", s_align_bytes, 4},
  {"def", s_set, 0},
  {"dfloat", float_cons, 'd'},
  {"ffloat", float_cons, 'f'},
  {"half", cons, 2},
  {"bss", s_lcomm, 1},
  {"string", stringer, 0},
  {"word", cons, 4},
  /* Force set to be treated as an instruction.  */
  {"set", NULL, 0},
  {".set", s_set, 0},
  {NULL, NULL, 0}
};
@


1.23
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@@


1.22
log
@Update the address and phone number of the FSF
@
text
@d1021 1
a1021 1
md_apply_fix3 (fixS *fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
@


1.21
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d22 2
a23 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.20
log
@update copyright dates
@
text
@d5 1
a5 1
   2000, 2001, 2002, 2003
d8 1
a8 1
This file is part of GAS, the GNU Assembler.
d10 14
a23 14
GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d83 1
a83 1
/* Integer	Floating point */
a124 20
static char *get_bf PARAMS ((char *param, unsigned *valp));
static char *get_cmp PARAMS ((char *param, unsigned *valp));
static char *get_cnd PARAMS ((char *param, unsigned *valp));
static char *get_bf2 PARAMS ((char *param, int bc));
static char *get_bf_offset_expression PARAMS ((char *param, unsigned *offsetp));
static char *get_cr PARAMS ((char *param, unsigned *regnop));
static char *get_fcr PARAMS ((char *param, unsigned *regnop));
static char *get_imm16 PARAMS ((char *param, struct m88k_insn *insn));
static char *get_o6 PARAMS ((char *param, unsigned *valp));
static char *match_name PARAMS ((char *, struct field_val_assoc *, unsigned *));
static char *get_reg PARAMS ((char *param, unsigned *regnop, unsigned int reg_prefix));
static char *get_vec9 PARAMS ((char *param, unsigned *valp));
static char *getval PARAMS ((char *param, unsigned int *valp));

static char *get_pcr PARAMS ((char *param, struct m88k_insn *insn,
		      enum reloc_type reloc));

static int calcop PARAMS ((struct m88k_opcode *format,
			   char *param, struct m88k_insn *insn));

d128 1
a128 1
/* These bits should be turned off in the first address of every segment */
d140 1
a140 1
/* Chars that can be used to separate mant from exp in floating point nums */
d143 3
a145 3
/* Chars that mean this number is a floating point constant */
/* as in 0f123.456 */
/* or    0H1.234E-12 (see exp chars above) */
a147 16
const pseudo_typeS md_pseudo_table[] =
{
  {"align", s_align_bytes, 4},
  {"def", s_set, 0},
  {"dfloat", float_cons, 'd'},
  {"ffloat", float_cons, 'f'},
  {"half", cons, 2},
  {"bss", s_lcomm, 1},
  {"string", stringer, 0},
  {"word", cons, 4},
  /* Force set to be treated as an instruction.  */
  {"set", NULL, 0},
  {".set", s_set, 0},
  {NULL, NULL, 0}
};

d149 1
a149 1
md_begin ()
d175 2
a176 1
struct option md_longopts[] = {
d182 1
a182 3
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d188 1
a188 2
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
d192 22
a213 3
void
md_assemble (op)
     char *op;
d215 13
a227 4
  char *param, *thisfrag;
  char c;
  struct m88k_opcode *format;
  struct m88k_insn insn;
d229 2
a230 1
  assert (op);
d232 5
a236 5
  /* Skip over instruction to find parameters.  */
  for (param = op; *param != 0 && !ISSPACE (*param); param++)
    ;
  c = *param;
  *param++ = '\0';
d238 1
a238 2
  /* Try to find the instruction in the hash table.  */
  if ((format = (struct m88k_opcode *) hash_find (op_hash, op)) == NULL)
d240 10
a249 2
      as_bad (_("Invalid mnemonic '%s'"), op);
      return;
d251 1
d253 8
a260 6
  /* Try parsing this instruction into insn.  */
  insn.exp.X_add_symbol = 0;
  insn.exp.X_op_symbol = 0;
  insn.exp.X_add_number = 0;
  insn.exp.X_op = O_illegal;
  insn.reloc = NO_RELOC;
d262 1
a262 1
  while (!calcop (format, param, &insn))
d264 5
a268 4
      /* If it doesn't parse try the next instruction.  */
      if (!strcmp (format[0].name, format[1].name))
	format++;
      else
d270 2
a271 2
	  as_fatal (_("Parameter syntax error"));
	  return;
d274 1
d276 4
a279 3
  /* Grow the current frag and plop in the opcode.  */
  thisfrag = frag_more (4);
  md_number_to_chars (thisfrag, insn.opcode, 4);
d281 1
a281 2
  /* If this instruction requires labels mark it for later.  */
  switch (insn.reloc)
d283 2
a284 2
    case NO_RELOC:
      break;
d286 1
a286 9
    case RELOC_LO16:
    case RELOC_HI16:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal + 2,
		   2,
		   &insn.exp,
		   0,
		   insn.reloc);
      break;
d288 8
a295 8
    case RELOC_IW16:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal,
		   4,
		   &insn.exp,
		   0,
		   insn.reloc);
      break;
d297 2
a298 22
    case RELOC_PC16:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal + 2,
		   2,
		   &insn.exp,
		   1,
		   insn.reloc);
      break;

    case RELOC_PC26:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal,
		   4,
		   &insn.exp,
		   1,
		   insn.reloc);
      break;

    default:
      as_fatal (_("Unknown relocation type"));
      break;
    }
d301 2
a302 5
static int
calcop (format, param, insn)
     struct m88k_opcode *format;
     char *param;
     struct m88k_insn *insn;
d304 4
a307 5
  char *fmt = format->op_spec;
  int f;
  unsigned val;
  unsigned opcode;
  unsigned int reg_prefix = 'r';
d309 1
a309 2
  insn->opcode = format->opcode;
  opcode = 0;
d311 11
a321 1
  for (;;)
d323 9
a331 8
      if (param == 0)
	return 0;
      f = *fmt++;
      switch (f)
	{
	case 0:
	  insn->opcode |= opcode;
	  return (*param == 0 || *param == '\n');
d333 3
a335 4
	default:
	  if (f != *param++)
	    return 0;
	  break;
d337 1
a337 5
	case 'd':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val << 21;
	  break;
d339 2
a340 4
	case 'o':
	  param = get_o6 (param, &val);
	  opcode |= ((val >> 2) << 7);
	  break;
d342 5
a346 3
	case 'x':
	  reg_prefix = 'x';
	  break;
d348 3
a350 5
	case '1':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val << 16;
	  break;
d352 26
a377 5
	case '2':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val;
	  break;
d379 1
a379 4
	case '3':
	  param = get_reg (param, &val, 'r');
	  opcode |= (val << 16) | val;
	  break;
d381 2
a382 3
	case 'I':
	  param = get_imm16 (param, insn);
	  break;
d384 5
a388 4
	case 'b':
	  param = get_bf (param, &val);
	  opcode |= val;
	  break;
d390 3
a392 3
	case 'p':
	  param = get_pcr (param, insn, RELOC_PC16);
	  break;
d394 26
a419 3
	case 'P':
	  param = get_pcr (param, insn, RELOC_PC26);
	  break;
d421 1
a421 4
	case 'B':
	  param = get_cmp (param, &val);
	  opcode |= val;
	  break;
d423 2
a424 4
	case 'M':
	  param = get_cnd (param, &val);
	  opcode |= val;
	  break;
d426 4
a429 4
	case 'c':
	  param = get_cr (param, &val);
	  opcode |= val << 5;
	  break;
d431 5
a435 4
	case 'f':
	  param = get_fcr (param, &val);
	  opcode |= val << 5;
	  break;
d437 32
a468 10
	case 'V':
	  param = get_vec9 (param, &val);
	  opcode |= val;
	  break;

	case '?':
	  /* Having this here repeats the warning somtimes.
	   But can't we stand that?  */
	  as_warn (_("Use of obsolete instruction"));
	  break;
d471 3
d477 1
a477 4
match_name (param, assoc_tab, valp)
     char *param;
     struct field_val_assoc *assoc_tab;
     unsigned *valp;
d479 1
a479 3
  int i;
  char *name;
  int name_len;
d481 1
a481 1
  for (i = 0;; i++)
d483 3
a485 5
      name = assoc_tab[i].name;
      if (name == NULL)
	return NULL;
      name_len = strlen (name);
      if (!strncmp (param, name, name_len))
d487 2
a488 2
	  *valp = assoc_tab[i].val;
	  return param + name_len;
d491 15
d509 1
a509 4
get_reg (param, regnop, reg_prefix)
     char *param;
     unsigned *regnop;
     unsigned int reg_prefix;
d553 1
a553 3
get_imm16 (param, insn)
     char *param;
     struct m88k_insn *insn;
d610 1
a610 4
get_pcr (param, insn, reloc)
     char *param;
     struct m88k_insn *insn;
     enum reloc_type reloc;
d629 1
a629 3
get_cmp (param, valp)
     char *param;
     unsigned *valp;
d660 4
a663 4
static char *
get_cnd (param, valp)
     char *param;
     unsigned *valp;
d665 5
a669 1
  unsigned int val;
d671 2
a672 34
  if (ISDIGIT (*param))
    {
      param = getval (param, &val);

      if (val >= 32)
	{
	  as_warn (_("Expression truncated to 5 bits"));
	  val %= 32;
	}
    }
  else
    {
      param[0] = TOLOWER (param[0]);
      param[1] = TOLOWER (param[1]);

      param = match_name (param, cndmsk, valp);

      if (param == NULL)
	return NULL;

      val = *valp;
    }

  *valp = val << 21;
  return param;
}

static char *
get_bf2 (param, bc)
     char *param;
     int bc;
{
  int depth = 0;
  int c;
d676 8
a683 12
      c = *param;
      if (c == 0)
	return param;
      else if (c == '(')
	depth++;
      else if (c == ')')
	depth--;
      else if (c == bc && depth <= 0)
	return param;
      param++;
    }
}
d685 4
a688 6
static char *
get_bf_offset_expression (param, offsetp)
     char *param;
     unsigned *offsetp;
{
  unsigned offset;
d690 5
a694 4
  if (ISALPHA (param[0]))
    {
      param[0] = TOLOWER (param[0]);
      param[1] = TOLOWER (param[1]);
d696 4
a699 1
      param = match_name (param, cmpslot, offsetp);
d701 3
a703 8
      return param;
    }
  else
    {
      input_line_pointer = param;
      offset = get_absolute_expression ();
      param = input_line_pointer;
    }
d705 5
a709 85
  *offsetp = offset;
  return param;
}

static char *
get_bf (param, valp)
     char *param;
     unsigned *valp;
{
  unsigned offset = 0;
  unsigned width = 0;
  char *xp;
  char *save_ptr;

  xp = get_bf2 (param, '<');

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  if (*xp == 0)
    {
      /* We did not find '<'.  We have an offset (width implicitly 32).  */
      param = get_bf_offset_expression (param, &offset);
      input_line_pointer = save_ptr;
      if (param == NULL)
	return NULL;
    }
  else
    {
      *xp++ = 0;		/* Overwrite the '<' */
      param = get_bf2 (xp, '>');
      if (*param == 0)
	return NULL;
      *param++ = 0;		/* Overwrite the '>' */

      width = get_absolute_expression ();
      xp = get_bf_offset_expression (xp, &offset);
      input_line_pointer = save_ptr;

      if (xp + 1 != param)
	return NULL;
    }

  *valp = ((width % 32) << 5) | (offset % 32);

  return param;
}

static char *
get_cr (param, regnop)
     char *param;
     unsigned *regnop;
{
  unsigned regno;
  unsigned c;

  if (!strncmp (param, "cr", 2))
    {
      param += 2;

      regno = *param++ - '0';
      if (regno < 10)
	{
	  if (regno == 0)
	    {
	      *regnop = 0;
	      return param;
	    }
	  c = *param - '0';
	  if (c < 10)
	    {
	      regno = regno * 10 + c;
	      if (c < 64)
		{
		  *regnop = regno;
		  return param + 1;
		}
	    }
	  else
	    {
	      *regnop = regno;
	      return param;
	    }
	}
      return NULL;
    }
d711 5
a715 1
  param = match_name (param, cr_regs, regnop);
d717 4
a720 2
  return param;
}
d722 3
a724 7
static char *
get_fcr (param, regnop)
     char *param;
     unsigned *regnop;
{
  unsigned regno;
  unsigned c;
d726 4
a729 3
  if (!strncmp (param, "fcr", 3))
    {
      param += 3;
d731 3
a733 26
      regno = *param++ - '0';
      if (regno < 10)
	{
	  if (regno == 0)
	    {
	      *regnop = 0;
	      return param;
	    }
	  c = *param - '0';
	  if (c < 10)
	    {
	      regno = regno * 10 + c;
	      if (c < 64)
		{
		  *regnop = regno;
		  return param + 1;
		}
	    }
	  else
	    {
	      *regnop = regno;
	      return param;
	    }
	}
      return NULL;
    }
d735 3
a737 1
  param = match_name (param, fcr_regs, regnop);
d739 4
a742 2
  return param;
}
d744 4
a747 7
static char *
get_vec9 (param, valp)
     char *param;
     unsigned *valp;
{
  unsigned val;
  char *save_ptr;
d749 4
a752 5
  save_ptr = input_line_pointer;
  input_line_pointer = param;
  val = get_absolute_expression ();
  param = input_line_pointer;
  input_line_pointer = save_ptr;
d754 4
a757 2
  if (val >= 1 << 9)
    as_warn (_("Expression truncated to 9 bits"));
d759 4
a762 1
  *valp = val % (1 << 9);
d764 7
a770 1
  return param;
d773 2
a774 4
static char *
get_o6 (param, valp)
     char *param;
     unsigned *valp;
d776 4
a779 2
  unsigned val;
  char *save_ptr;
d781 1
a781 5
  save_ptr = input_line_pointer;
  input_line_pointer = param;
  val = get_absolute_expression ();
  param = input_line_pointer;
  input_line_pointer = save_ptr;
d783 5
a787 2
  if (val & 0x3)
    as_warn (_("Removed lower 2 bits of expression"));
d789 6
a794 1
  *valp = val;
d796 6
a801 2
  return (param);
}
d803 1
a803 15
#define hexval(z) \
  (ISDIGIT (z) ? (z) - '0' :						\
   ISLOWER (z) ? (z) - 'a' + 10 : 					\
   ISUPPER (z) ? (z) - 'A' + 10 : (unsigned) -1)

static char *
getval (param, valp)
     char *param;
     unsigned int *valp;
{
  unsigned int val = 0;
  unsigned int c;

  c = *param++;
  if (c == '0')
d805 3
a807 12
      c = *param++;
      if (c == 'x' || c == 'X')
	{
	  c = *param++;
	  c = hexval (c);
	  while (c < 16)
	    {
	      val = val * 16 + c;
	      c = *param++;
	      c = hexval (c);
	    }
	}
d810 2
a811 6
	  c -= '0';
	  while (c < 8)
	    {
	      val = val * 8 + c;
	      c = *param++ - '0';
	    }
d814 7
a820 1
  else
d822 43
a864 6
      c -= '0';
      while (c < 10)
	{
	  val = val * 10 + c;
	  c = *param++ - '0';
	}
a865 3

  *valp = val;
  return param - 1;
d869 1
a869 4
md_number_to_chars (buf, val, nbytes)
     char *buf;
     valueT val;
     int nbytes;
d878 2
a879 2
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
d881 1
a881 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d934 5
a938 6
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag;
     symbolS *to_symbol;
d956 5
a960 6
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag;
     symbolS *to_symbol;
d976 2
a977 3
md_estimate_size_before_relax (fragP, segment_type)
     fragS *fragP ATTRIBUTE_UNUSED;
     segT segment_type ATTRIBUTE_UNUSED;
d980 1
a980 1
  return (-1);
d995 1
a995 2
tc_coff_fix2rtype (fixp)
     fixS *fixp;
d1021 1
a1021 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d1080 1
a1080 2
md_pcrel_from (fixp)
     fixS *fixp;
a1090 1
  /*NOTREACHED*/
d1096 1
a1096 2
m88k_handle_align (fragp)
     fragS *fragp;
d1123 16
@


1.19
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d5 1
a5 1
   2000, 2001, 2002
@


1.18
log
@	* config/tc-m88k.c (get_reg): Make reg_prefix param unsigned.
	(calcop): Ditto for reg_prefix var.
	(hexval): Add cast to fix signed/unsigned warning.
	(md_number_to_disp): Delete unused function.
	(md_number_to_field): Likewise.
	(float_cons, cons, s_globl, s_space, s_set, s_lcomm): Remove decl.
	(match_name): Prototype.
	(get_bf2): Prototype.
	(get_bf_offset_expression): Prototype.
@
text
@d1065 1
a1065 1
   point.  If that happens, these functions should be rexamined.
@


1.17
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d128 2
d134 2
a135 1
static char *get_reg PARAMS ((char *param, unsigned *regnop, int reg_prefix));
a167 3
extern void float_cons (), cons (), s_globl (), s_space (),
  s_set (), s_lcomm ();

d336 1
a336 1
  int reg_prefix = 'r';
d468 1
a468 1
     int reg_prefix;
d888 1
a888 1
   ISUPPER (z) ? (z) - 'A' + 10 : -1)
a943 20
}

void
md_number_to_disp (buf, val, nbytes)
     char *buf;
     int val;
     int nbytes;
{
  as_fatal (_("md_number_to_disp not defined"));
  md_number_to_chars (buf, val, nbytes);
}

void
md_number_to_field (buf, val, nbytes)
     char *buf;
     int val;
     int nbytes;
{
  as_fatal (_("md_number_to_field not defined"));
  md_number_to_chars (buf, val, nbytes);
@


1.16
log
@2001-11-20  Ben Elliston  <bje@@redhat.com>

	* config/tc-m88k.c (md_apply_fix3): Match local variable `val' to
	 usage after md_apply_fix3 cleanups.
@
text
@d5 1
a5 1
   2000, 2001
d210 1
a210 1
CONST char *md_shortopts = "";
@


1.15
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d1125 1
a1125 1
  long value = * (long *) valP;
@


1.14
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1120 4
a1123 3
md_apply_fix (fixp, val)
     fixS *fixp;
     long val;
d1125 1
d1128 2
a1129 2
  buf = fixp->fx_frag->fr_literal + fixp->fx_where;
  fixp->fx_offset = 0;
d1131 1
a1131 1
  switch (fixp->fx_r_type)
d1134 1
a1134 1
      fixp->fx_offset = val >> 16;
d1140 1
a1140 1
      fixp->fx_offset = val >> 16;
d1146 1
a1146 1
      fixp->fx_offset = val >> 16;
d1173 3
@


1.13
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@d5 1
a5 1
   2000
a24 1
#include <ctype.h>
d26 1
d242 1
a242 1
  for (param = op; *param != 0 && !isspace (*param); param++)
d520 1
a520 1
  if (!strncmp (param, "hi16", 4) && !isalnum (param[4]))
d525 1
a525 1
  else if (!strncmp (param, "lo16", 4) && !isalnum (param[4]))
d530 1
a530 1
  else if (!strncmp (param, "iw16", 4) && !isalnum (param[4]))
d633 1
a633 1
  if (isdigit (*param))
d645 2
a646 5
      if (isupper (*param))
	*param = tolower (*param);

      if (isupper (param[1]))
	param[1] = tolower (param[1]);
d690 1
a690 1
  if (isalpha (param[0]))
d692 2
a693 4
      if (isupper (param[0]))
	param[0] = tolower (param[0]);
      if (isupper (param[1]))
	param[1] = tolower (param[1]);
d886 3
a888 3
  (isdigit (z) ? (z) - '0' :						\
   islower (z) ? (z) - 'a' + 10 : 					\
   isupper (z) ? (z) - 'A' + 10 : -1)
@


1.12
log
@2001-07-05  Ben Elliston  <bje@@redhat.com>

	* config/tc-m88k.c (md_pseudo_table): Remove redundant "global".
@
text
@d887 1
a887 1
  return(param);
@


1.11
log
@2001-07-01  Ben Elliston  <bje@@redhat.com>

	* config/tc-m88k.c: Back out warning fixes from 2001-06-24, as
	they cause some subtle breakage.  Will fix them again later.
@
text
@a173 1
  {"global", s_globl, 0},
@


1.10
log
@2001-06-24  Ben Elliston  <bje@@redhat.com>

	* config/tc-m88k.c (md_number_to_imm): Remove; unused since 1993.
	(emit_relocations): Ditto.
	(s_bss): Ditto.
	(md_begin): Reformat comments to conform to the GNU standards.
	(md_assemble): Ditto.
@
text
@d132 1
a132 1
static char *get_reg PARAMS ((char *param, unsigned *regnop, char reg_prefix));
d337 1
a337 1
  char reg_prefix = 'r';
d469 1
a469 1
     char reg_prefix;
d471 1
a471 1
  char c;
d902 1
a902 1
  char c;
@


1.9
log
@* fixes to silence all compiler warnings.

2001-06-24  Ben Elliston  <bje@@redhat.com>

	* config/tc-m88k.c (get_reg): Adjust type of `reg_prefix' to char.
	(md_parse_option): Mark parameters as unused.
	(md_show_usage): Ditto.
	(calcop): Adjust type of `reg_prefix' to char.
	(get_reg): Ditto.
	(getval): Adjust type of local `c' to char.
	(md_create_short_jump): Mark from_addr, to_addr params as unused.
	(md_create_long_jump): Ditto.
	(md_estimate_size_before_relax): Mark parameters as unused.
@
text
@d149 1
a149 1
   another comment */
d191 1
a191 2
  /* initialize hash table */

a193 2
  /* loop until you see the end of the list */

d198 1
a198 2
      /* hash each mnemonic and record its position */

d205 1
a205 2
      /* skip to next unique mnemonic or end of list */

d242 1
a242 2
  /* skip over instruction to find parameters */

d248 1
a248 2
  /* try to find the instruction in the hash table */

d255 1
a255 2
  /* try parsing this instruction into insn */

d264 1
a264 2
      /* if it doesn't parse try the next instruction */

d274 1
a274 2
  /* grow the current frag and plop in the opcode */

d278 1
a278 2
  /* if this instruction requires labels mark it for later */

a951 78
#if 0

/* This routine is never called.  What is it for?
   Ian Taylor, Cygnus Support 13 Jul 1993 */

void
md_number_to_imm (buf, val, nbytes, fixP, seg_type)
     unsigned char *buf;
     unsigned int val;
     int nbytes;
     fixS *fixP;
     int seg_type;
{
  if (seg_type != N_TEXT || fixP->fx_r_type == NO_RELOC)
    {
      switch (nbytes)
	{
	case 4:
	  *buf++ = val >> 24;
	  *buf++ = val >> 16;
	case 2:
	  *buf++ = val >> 8;
	case 1:
	  *buf = val;
	  break;

	default:
	  abort ();
	}
      return;
    }

  switch (fixP->fx_r_type)
    {
    case RELOC_IW16:
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_LO16:
      buf[0] = val >> 8;
      buf[1] = val;
      break;

    case RELOC_HI16:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      break;

    case RELOC_PC16:
      val += 4;
      buf[0] = val >> 10;
      buf[1] = val >> 2;
      break;

    case RELOC_PC26:
      val += 4;
      buf[0] |= (val >> 26) & 0x03;
      buf[1] = val >> 18;
      buf[2] = val >> 10;
      buf[3] = val >> 2;
      break;

    case RELOC_32:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    default:
      as_fatal (_("Bad relocation type"));
      break;
    }
}

#endif /* 0 */

a1085 146

#if 0

/* As far as I can tell, this routine is never called.  What is it
   doing here?
   Ian Taylor, Cygnus Support 13 Jul 1993 */

/*
 * Risc relocations are completely different, so it needs
 * this machine dependent routine to emit them.
 */
void
emit_relocations (fixP, segment_address_in_file)
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  struct reloc_info_m88k ri;
  symbolS *symbolP;
  extern char *next_object_file_charP;

  bzero ((char *) &ri, sizeof (ri));
  for (; fixP; fixP = fixP->fx_next)
    {
      if (fixP->fx_r_type >= NO_RELOC)
	{
	  fprintf (stderr, "fixP->fx_r_type = %d\n", fixP->fx_r_type);
	  abort ();
	}

      if ((symbolP = fixP->fx_addsy) != NULL)
	{
	  ri.r_address = fixP->fx_frag->fr_address +
	    fixP->fx_where - segment_address_in_file;
	  if ((symbolP->sy_type & N_TYPE) == N_UNDF)
	    {
	      ri.r_extern = 1;
	      ri.r_symbolnum = symbolP->sy_number;
	    }
	  else
	    {
	      ri.r_extern = 0;
	      ri.r_symbolnum = symbolP->sy_type & N_TYPE;
	    }
	  if (symbolP && symbol_get_frag (symbolP))
	    {
	      ri.r_addend = symbol_get_frag (symbolP)->fr_address;
	    }
	  ri.r_type = fixP->fx_r_type;
	  if (fixP->fx_pcrel)
	    {
	      ri.r_addend -= ri.r_address;
	    }
	  else
	    {
	      ri.r_addend = fixP->fx_addnumber;
	    }

	  append (&next_object_file_charP, (char *) &ri, sizeof (ri));
	}
    }
}

#endif /* 0 */

#if 0

/* This routine can be subsumed by s_lcomm in read.c.
   Ian Taylor, Cygnus Support 13 Jul 1993 */

static void
s_bss ()
{
  char *name;
  char c;
  char *p;
  int temp, bss_align;
  symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_warn (_("Expected comma after name"));
      ignore_rest_of_line ();
      return;
    }
  input_line_pointer++;
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_("BSS length (%d.) <0! Ignored."), temp);
      ignore_rest_of_line ();
      return;
    }
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      bss_align = get_absolute_expression ();
    }
  else
    bss_align = 0;

  if (!S_IS_DEFINED(symbolP)
      || S_GET_SEGMENT(symbolP) == SEG_BSS)
    {
      if (! need_pass_2)
	{
	  char *p;
	  segT current_seg = now_seg;
	  subsegT current_subseg = now_subseg;

	  subseg_set (SEG_BSS, 1); /* switch to bss	*/

	  if (bss_align)
	    frag_align (bss_align, 0, 0);

	  /* detach from old frag */
	  if (symbolP->sy_type == N_BSS && symbol_get_frag (symbolP) != NULL)
	    symbol_get_frag (symbolP)->fr_symbol = NULL;

	  symbol_set_frag (symbolP, frag_now);
	  p = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
			(offsetT) temp, (char *)0);
	  *p = 0;
	  S_SET_SEGMENT (symbolP, SEG_BSS);

	  subseg_set (current_seg, current_subseg);
	}
    }
  else
    {
      as_warn (_("Ignoring attempt to re-define symbol %s."), name);
    }

  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      input_line_pointer++;
    }
}

#endif /* 0 */
@


1.8
log
@2001-06-24  Ben Elliston  <bje@@redhat.com>

	* config/tc-m88k.c (md_pseudo_table): Properly terminate the table
	to allay a possible compiler warning.
@
text
@d132 1
a132 1
static char *get_reg PARAMS ((char *param, unsigned *regnop, int reg_prefix));
d224 2
a225 2
     int c;
     char *arg;
d232 1
a232 1
     FILE *stream;
d348 1
a348 1
  int reg_prefix = 'r';
d480 1
a480 1
     int reg_prefix;
d482 1
a482 1
  unsigned c;
d913 1
a913 1
  unsigned int c;
d1126 2
a1127 1
     addressT from_addr, to_addr;
d1149 2
a1150 1
     addressT from_addr, to_addr;
d1169 2
a1170 2
     fragS *fragP;
     segT segment_type;
@


1.7
log
@Fix copyright notices
@
text
@d182 1
a182 1
  {0}
@


1.6
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d4 2
a5 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
@


1.6.2.1
log
@Update copyright notices.
@
text
@d4 1
a4 2
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
   2000
@


1.5
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d1430 1
a1430 1
/* When we align the .init section, insert the correct NOP pattern.  */
d1432 3
a1434 6
int
m88k_do_align (n, fill, max, len)
     int n;
     const char *fill;
     int len;
     int max;
d1436 12
a1447 2
  if (fill == NULL
      && strcmp (obj_segment_name (now_seg), ".init") == 0)
d1449 5
a1453 3
      static const unsigned char nop_pattern[] = { 0xf4, 0x00, 0x58, 0x00 };
      frag_align_pattern (n, nop_pattern, sizeof (nop_pattern), max);
      return 1;
d1455 3
a1457 1
  return 0;
@


1.4
log
@2000-09-20  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-m32r.c: Fix formatting.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68851.h: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.h: Likewise.
@
text
@d219 1
a219 1
size_t md_longopts_size = sizeof(md_longopts);
@


1.3
log
@is_end_of_line fixes.
@
text
@a140 1

d151 1
a151 1
/* These chars only start a comment at the beginning of a line. */
a1178 1

a1239 1

@


1.2
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d1314 1
a1314 1
  while (!is_end_of_line[*input_line_pointer])
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 1997
d1217 1
a1217 1
	  if (symbolP && symbolP->sy_frag)
d1219 1
a1219 1
	      ri.r_addend = symbolP->sy_frag->fr_address;
d1297 2
a1298 2
	  if (symbolP->sy_type == N_BSS && symbolP->sy_frag != NULL)
	    symbolP->sy_frag->fr_symbol = NULL;
d1300 1
a1300 1
	  symbolP->sy_frag  = frag_now;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

