head	1.15;
access;
symbols
	binutils-csl-sourcerygxx-3_4_4-32:1.11
	binutils-csl-sourcerygxx-3_4_4-25:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.11
	binutils-csl-wrs-linux-3_4_4-23:1.11
	binutils-csl-wrs-linux-3_4_4-22:1.11
	binutils-csl-wrs-linux-3_4_4-21:1.11
	binutils-csl-wrs-linux-3_4_4-20:1.11
	binutils-csl-gxxpro-3_4-branch:1.11.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.11
	binutils-2_16_1:1.11
	binutils-csl-arm-2005q1b:1.11
	binutils-2_16:1.11
	binutils-csl-arm-2005q1a:1.11
	binutils-csl-arm-2005q1-branch:1.11.0.4
	binutils-csl-arm-2005q1-branchpoint:1.11
	binutils-2_16-branch:1.11.0.2
	binutils-2_16-branchpoint:1.11
	csl-arm-2004-q3d:1.9
	csl-arm-2004-q3:1.9
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	binutils-2_15-branch:1.9.0.8
	cagney_bfdfile-20040213-branch:1.9.0.6
	cagney_bfdfile-20040213-branchpoint:1.9
	cagney_bigcore-20040122-branch:1.9.0.4
	cagney_bigcore-20040122-branchpoint:1.9
	csl-arm-2003-q4:1.9
	binutils-2_14:1.9
	binutils-2_14-branch:1.9.0.2
	binutils-2_14-branchpoint:1.9
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	binutils-2_13_1:1.8
	binutils-2_13:1.8
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.2
	binutils-2_12_1:1.7
	binutils-2_12:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.7
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.14
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2005.08.11.01.25.23;	author amodra;	state dead;
branches;
next	1.14;

1.14
date	2005.06.07.17.54.15;	author zack;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.05.09.12.53;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.24.20.40.25;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.17.13.46.03;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.31.23.18.25;	author bje;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.12.22.43.45;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.15.21.28.54;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.05.33.21;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.03.06.49.21;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.09.15.01.06.52;	author kazu;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.15.27;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.15
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* tc-a29k.c -- Assemble for the AMD 29000.
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001,
   2002, 2005
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* John Gilmore has reorganized this module somewhat, to make it easier
   to convert it to new machines' assemblers as desired.  There was too
   much bloody rewriting required before.  There still probably is.  */

#include "as.h"
#include "safe-ctype.h"

#include "opcode/a29k.h"

/* Make it easier to clone this machine desc into another one.  */
#define	machine_opcode	a29k_opcode
#define	machine_opcodes	a29k_opcodes
#define	machine_ip	a29k_ip
#define	machine_it	a29k_it

#define	IMMEDIATE_BIT	0x01000000	/* Turns RB into Immediate.  */
#define	ABSOLUTE_BIT	0x01000000	/* Turns PC-relative to Absolute.  */
#define	CE_BIT		0x00800000	/* Coprocessor enable in LOAD.  */
#define	UI_BIT		0x00000080	/* Unsigned integer in CONVERT.  */

/* handle of the OPCODE hash table.  */
static struct hash_control *op_hash = NULL;

struct machine_it
{
  char *error;
  unsigned long opcode;
  struct nlist *nlistp;
  expressionS exp;
  int pcrel;
  int reloc_offset;		/* Offset of reloc within insn.  */
  int reloc;
}
the_insn;

#if defined(BFD_HEADERS)
#ifdef RELSZ
const int md_reloc_size = RELSZ;	/* Coff headers.  */
#else
const int md_reloc_size = 12;		/* Something else headers.  */
#endif
#else
const int md_reloc_size = 12;		/* Not bfdized.  */
#endif

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = ";";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.  */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";

/* We needed an unused char for line separation to work around the
   lack of macros, using sed and such.  */
const char line_separator_chars[] = "@@";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c.  Ideally it shouldn't have to know about it at
   all, but nothing is ideal around here.  */

/* anull bit - causes the branch delay slot instructions to not be executed.  */
#define ANNUL       (1 << 29)

#ifndef OBJ_COFF

static void
s_use (int ignore)
{
  if (strncmp (input_line_pointer, ".text", 5) == 0)
    {
      input_line_pointer += 5;
      s_text (0);
      return;
    }
  if (strncmp (input_line_pointer, ".data", 5) == 0)
    {
      input_line_pointer += 5;
      s_data (0);
      return;
    }
  if (strncmp (input_line_pointer, ".data1", 6) == 0)
    {
      input_line_pointer += 6;
      s_data1 ();
      return;
    }
  /* Literals can't go in the text segment because you can't read from
     instruction memory on some 29k's.  So, into initialized data.  */
  if (strncmp (input_line_pointer, ".lit", 4) == 0)
    {
      input_line_pointer += 4;
      subseg_set (SEG_DATA, 200);
      demand_empty_rest_of_line ();
      return;
    }

  as_bad (_("Unknown segment type"));
  demand_empty_rest_of_line ();
}

static void
s_data1 (void)
{
  subseg_set (SEG_DATA, 1);
  demand_empty_rest_of_line ();
}

#endif /* OBJ_COFF */

/* Install symbol definition that maps REGNAME to REGNO.
   FIXME-SOON:  These are not recognized in mixed case.  */

static void
insert_sreg (char *regname, int regnum)
{
  /* FIXME-SOON, put something in these syms so they won't be output
     to the symbol table of the resulting object file.  */

  /* Must be large enough to hold the names of the special registers.  */
  char buf[80];
  int i;

  symbol_table_insert (symbol_new (regname, SEG_REGISTER, (valueT) regnum,
				   &zero_address_frag));
  for (i = 0; regname[i]; i++)
    buf[i] = TOUPPER (regname[i]);
  buf[i] = '\0';

  symbol_table_insert (symbol_new (buf, SEG_REGISTER, (valueT) regnum,
				   &zero_address_frag));
}

/* Install symbol definitions for assorted special registers.
   See ASM29K Ref page 2-9.  */

static void
define_some_regs (void)
{
#define SREG	256

  /* Protected special-purpose register names.  */
  insert_sreg ("vab", SREG + 0);
  insert_sreg ("ops", SREG + 1);
  insert_sreg ("cps", SREG + 2);
  insert_sreg ("cfg", SREG + 3);
  insert_sreg ("cha", SREG + 4);
  insert_sreg ("chd", SREG + 5);
  insert_sreg ("chc", SREG + 6);
  insert_sreg ("rbp", SREG + 7);
  insert_sreg ("tmc", SREG + 8);
  insert_sreg ("tmr", SREG + 9);
  insert_sreg ("pc0", SREG + 10);
  insert_sreg ("pc1", SREG + 11);
  insert_sreg ("pc2", SREG + 12);
  insert_sreg ("mmu", SREG + 13);
  insert_sreg ("lru", SREG + 14);

  /* Additional protected special-purpose registers for the 29050.  */
  insert_sreg ("rsn",  SREG + 15);
  insert_sreg ("rma0", SREG + 16);
  insert_sreg ("rmc0", SREG + 17);
  insert_sreg ("rma1", SREG + 18);
  insert_sreg ("rmc1", SREG + 19);
  insert_sreg ("spc0", SREG + 20);
  insert_sreg ("spc1", SREG + 21);
  insert_sreg ("spc2", SREG + 22);
  insert_sreg ("iba0", SREG + 23);
  insert_sreg ("ibc0", SREG + 24);
  insert_sreg ("iba1", SREG + 25);
  insert_sreg ("ibc1", SREG + 26);

  /* Additional registers for the 29040.  */
  insert_sreg ("dba", SREG + 27);
  insert_sreg ("dbc", SREG + 28);
  insert_sreg ("cir", SREG + 29);
  insert_sreg ("cdr", SREG + 30);

  /* Unprotected special-purpose register names.  */
  insert_sreg ("ipc", SREG + 128);
  insert_sreg ("ipa", SREG + 129);
  insert_sreg ("ipb", SREG + 130);
  insert_sreg ("q", SREG + 131);
  insert_sreg ("alu", SREG + 132);
  insert_sreg ("bp", SREG + 133);
  insert_sreg ("fc", SREG + 134);
  insert_sreg ("cr", SREG + 135);
  insert_sreg ("fpe", SREG + 160);
  insert_sreg ("inte", SREG + 161);
  insert_sreg ("fps", SREG + 162);
  /*  "",    SREG+163);	  Reserved */
  insert_sreg ("exop", SREG + 164);
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc., that the MD part of the assembler will
   need.  */

void
md_begin (void)
{
  const char *retval = NULL;
  int lose = 0;
  int skipnext = 0;
  unsigned int i;
  char *strend, *strend2;

  /* Hash up all the opcodes for fast use later.  */

  op_hash = hash_new ();

  for (i = 0; i < num_opcodes; i++)
    {
      const char *name = machine_opcodes[i].name;

      if (skipnext)
	{
	  skipnext = 0;
	  continue;
	}

      /* Hack to avoid multiple opcode entries.  We pre-locate all the
	 variations (b/i field and P/A field) and handle them.  */
      if (!strcmp (name, machine_opcodes[i + 1].name))
	{
	  if ((machine_opcodes[i].opcode & 0x01000000) != 0
	      || (machine_opcodes[i + 1].opcode & 0x01000000) == 0
	      || ((machine_opcodes[i].opcode | 0x01000000)
		  != machine_opcodes[i + 1].opcode))
	    goto bad_table;

	  strend = machine_opcodes[i].args + strlen (machine_opcodes[i].args) - 1;
	  strend2 = machine_opcodes[i + 1].args + strlen (machine_opcodes[i + 1].args) - 1;

	  switch (*strend)
	    {
	    case 'b':
	      if (*strend2 != 'i')
		goto bad_table;
	      break;

	    case 'P':
	      if (*strend2 != 'A')
		goto bad_table;
	      break;

	    default:
	    bad_table:
	      fprintf (stderr, "internal error: can't handle opcode %s\n",
		       name);
	      lose = 1;
	    }

	  /* OK, this is an i/b or A/P pair.  We skip the
	     higher-valued one, and let the code for operand checking
	     handle OR-ing in the bit.  */
	  skipnext = 1;
	}

      retval = hash_insert (op_hash, name, (void *) &machine_opcodes[i]);
      if (retval != NULL)
	{
	  fprintf (stderr, "internal error: can't hash `%s': %s\n",
		   machine_opcodes[i].name, retval);
	  lose = 1;
	}
    }

  if (lose)
    as_fatal (_("Broken assembler.  No assembly attempted."));

  define_some_regs ();
}

static char *
parse_operand (char *s, expressionS *operandp, int opt)
{
  char *save = input_line_pointer;
  char *new;

  input_line_pointer = s;
  expression (operandp);
  if (operandp->X_op == O_absent && ! opt)
    as_bad (_("missing operand"));
  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

/* Instruction parsing.  Takes a string containing the opcode.
   Operands are at input_line_pointer.  Output is in the_insn.
   Warnings or errors are generated.  */

static void
machine_ip (char *str)
{
  char *s;
  const char *args;
  struct machine_opcode *insn;
  char *argsStart;
  unsigned long opcode;
  expressionS the_operand;
  expressionS *operand = &the_operand;
  unsigned int reg;

  /* Must handle `div0' opcode.  */
  s = str;
  if (ISALPHA (*s))
    for (; ISALNUM (*s); ++s)
      *s = TOLOWER (*s);

  switch (*s)
    {
    case '\0':
      break;

    case ' ':			/* FIXME-SOMEDAY more whitespace.  */
      *s++ = '\0';
      break;

    default:
      as_bad (_("Unknown opcode: `%s'"), str);
      return;
    }
  if ((insn = (struct machine_opcode *) hash_find (op_hash, str)) == NULL)
    {
      as_bad (_("Unknown opcode `%s'."), str);
      return;
    }
  argsStart = s;
  opcode = insn->opcode;
  memset (&the_insn, '\0', sizeof (the_insn));
  the_insn.reloc = NO_RELOC;

  /* Build the opcode, checking as we go to make sure that the
     operands match.

     If an operand matches, we modify the_insn or opcode appropriately,
     and do a "continue".  If an operand fails to match, we "break".  */
  if (insn->args[0] != '\0')
    /* Prime the pump.  */
    s = parse_operand (s, operand, insn->args[0] == 'I');

  for (args = insn->args;; ++args)
    {
      switch (*args)
	{
	case '\0':
	  if (*s == '\0')
	    {
	      /* We are truly done.  */
	      the_insn.opcode = opcode;
	      return;
	    }
	  as_bad (_("Too many operands: %s"), s);
	  break;

	case ',':
	  if (*s++ == ',')
	    {
	      /* Parse next operand.  */
	      s = parse_operand (s, operand, args[1] == 'I');
	      continue;
	    }
	  break;

	case 'v':
	  /* Trap numbers (immediate field).  */
	  if (operand->X_op == O_constant)
	    {
	      if (operand->X_add_number < 256)
		opcode |= (operand->X_add_number << 16);
	      else
		as_bad (_("Immediate value of %ld is too large"),
			(long) operand->X_add_number);
	      continue;
	    }
	  the_insn.reloc = RELOC_8;
	  /* BIG-ENDIAN Byte 1 of insn.  */
	  the_insn.reloc_offset = 1;
	  the_insn.exp = *operand;
	  continue;

	case 'b': /* A general register or 8-bit immediate.  */
	case 'i':
	  /* We treat the two cases identically since we mashed
	     them together in the opcode table.  */
	  if (operand->X_op == O_register)
	    goto general_reg;

	  /* Make sure the 'i' case really exists.  */
	  if ((insn->opcode | IMMEDIATE_BIT) != (insn + 1)->opcode)
	    break;

	  opcode |= IMMEDIATE_BIT;
	  if (operand->X_op == O_constant)
	    {
	      if (operand->X_add_number < 256)
		opcode |= operand->X_add_number;
	      else
		as_bad (_("Immediate value of %ld is too large"),
			(long) operand->X_add_number);
	      continue;
	    }
	  the_insn.reloc = RELOC_8;
	  the_insn.reloc_offset = 3;	/* BIG-ENDIAN Byte 3 of insn.  */
	  the_insn.exp = *operand;
	  continue;

	case 'a': /* Next operand must be a register.  */
	case 'c':
	general_reg:
	  /* lrNNN or grNNN or %%expr or a user-def register name.  */
	  if (operand->X_op != O_register)
	    break;
	  know (operand->X_add_symbol == 0);
	  know (operand->X_op_symbol == 0);
	  reg = operand->X_add_number;
	  if (reg >= SREG)
	    break;

	  /* Got the register, now figure out where it goes in the
	     opcode.  */
	  switch (*args)
	    {
	    case 'a':
	      opcode |= reg << 8;
	      continue;

	    case 'b':
	    case 'i':
	      opcode |= reg;
	      continue;

	    case 'c':
	      opcode |= reg << 16;
	      continue;
	    }
	  as_fatal (_("failed sanity check."));
	  break;

	case 'x':	/* 16 bit constant, zero-extended.  */
	case 'X':	/* 16 bit constant, one-extended.  */
	  if (operand->X_op == O_constant)
	    {
	      opcode |= (operand->X_add_number & 0xFF) << 0
		| ((operand->X_add_number & 0xFF00) << 8);
	      continue;
	    }
	  the_insn.reloc = RELOC_CONST;
	  the_insn.exp = *operand;
	  continue;

	case 'h':
	  if (operand->X_op == O_constant)
	    {
	      opcode |= (operand->X_add_number & 0x00FF0000) >> 16
		| (((unsigned long) operand->X_add_number
		    /* Avoid sign ext.  */  & 0xFF000000) >> 8);
	      continue;
	    }
	  the_insn.reloc = RELOC_CONSTH;
	  the_insn.exp = *operand;
	  continue;

	case 'P':		/* PC-relative jump address.  */
	case 'A':		/* Absolute jump address.  */
	  /* These two are treated together since we folded the
	     opcode table entries together.  */
	  if (operand->X_op == O_constant)
	    {
	      /* Make sure the 'A' case really exists.  */
	      if ((insn->opcode | ABSOLUTE_BIT) != (insn + 1)->opcode)
		break;

	      {
		bfd_vma v, mask;

		mask = 0x1ffff;
		v = operand->X_add_number & ~ mask;
		if (v)
		  as_bad ("call/jmp target out of range");
	      }

	      opcode |= ABSOLUTE_BIT
		| (operand->X_add_number & 0x0003FC00) << 6
		| ((operand->X_add_number & 0x000003FC) >> 2);
	      continue;
	    }

	  the_insn.reloc = RELOC_JUMPTARG;
	  the_insn.exp = *operand;
	  the_insn.pcrel = 1;	/* Assume PC-relative jump.  */
	  /* FIXME-SOON, Do we figure out whether abs later, after
             know sym val?  */
	  continue;

	case 'e':	/* Coprocessor enable bit for LOAD/STORE insn.  */
	  if (operand->X_op == O_constant)
	    {
	      if (operand->X_add_number == 0)
		continue;
	      if (operand->X_add_number == 1)
		{
		  opcode |= CE_BIT;
		  continue;
		}
	    }
	  break;

	case 'n':	/* Control bits for LOAD/STORE instructions.  */
	  if (operand->X_op == O_constant
	      && operand->X_add_number < 128)
	    {
	      opcode |= (operand->X_add_number << 16);
	      continue;
	    }
	  break;

	case 's':	/* Special register number.  */
	  if (operand->X_op != O_register)
	    break;
	  if (operand->X_add_number < SREG)
	    break;
	  opcode |= (operand->X_add_number & 0xFF) << 8;
	  continue;

	case 'u':	/* UI bit of CONVERT.  */
	  if (operand->X_op == O_constant)
	    {
	      if (operand->X_add_number == 0)
		continue;
	      if (operand->X_add_number == 1)
		{
		  opcode |= UI_BIT;
		  continue;
		}
	    }
	  break;

	case 'r':	/* RND bits of CONVERT.  */
	  if (operand->X_op == O_constant
	      && operand->X_add_number < 8)
	    {
	      opcode |= operand->X_add_number << 4;
	      continue;
	    }
	  break;

	case 'I':	/* ID bits of INV and IRETINV.  */
	  /* This operand is optional.  */
	  if (operand->X_op == O_absent)
	    continue;
	  else if (operand->X_op == O_constant
		   && operand->X_add_number < 4)
	    {
	      opcode |= operand->X_add_number << 16;
	      continue;
	    }
	  break;

	case 'd':	/* FD bits of CONVERT.  */
	  if (operand->X_op == O_constant
	      && operand->X_add_number < 4)
	    {
	      opcode |= operand->X_add_number << 2;
	      continue;
	    }
	  break;

	case 'f':	/* FS bits of CONVERT.  */
	  if (operand->X_op == O_constant
	      && operand->X_add_number < 4)
	    {
	      opcode |= operand->X_add_number << 0;
	      continue;
	    }
	  break;

	case 'C':
	  if (operand->X_op == O_constant
	      && operand->X_add_number < 4)
	    {
	      opcode |= operand->X_add_number << 16;
	      continue;
	    }
	  break;

	case 'F':
	  if (operand->X_op == O_constant
	      && operand->X_add_number < 16)
	    {
	      opcode |= operand->X_add_number << 18;
	      continue;
	    }
	  break;

	default:
	  BAD_CASE (*args);
	}
      /* Types or values of args don't match.  */
      as_bad ("Invalid operands");
      return;
    }
}

/* Assemble a single instruction.  Its label has already been handled
   by the generic front end.  We just parse opcode and operands, and
   produce the bytes of data and relocation.  */

void
md_assemble (char *str)
{
  char *toP;

  know (str);
  machine_ip (str);
  toP = frag_more (4);
  /* Put out the opcode.  */
  md_number_to_chars (toP, the_insn.opcode, 4);

  /* Put out the symbol-dependent stuff.  */
  if (the_insn.reloc != NO_RELOC)
    fix_new_exp (frag_now,
		 (toP - frag_now->fr_literal + the_insn.reloc_offset),
		 4, & the_insn.exp, the_insn.pcrel, the_insn.reloc);
}

/* This is identical to the md_atof in m68k.c.  I think this is right,
   but I'm not sure.

   Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {

    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return "Bad call to MD_ATOF()";
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

/* Write out big-endian.  */

void
md_number_to_chars (char *buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  valueT val = *valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */

  know (fixP->fx_size == 4);
  know (fixP->fx_r_type < NO_RELOC);

  /* This is a hack.  There should be a better way to handle this.  */
  if (fixP->fx_r_type == RELOC_WDISP30 && fixP->fx_addsy)
    val += fixP->fx_where + fixP->fx_frag->fr_address;

  switch (fixP->fx_r_type)
    {
    case RELOC_32:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_8:
      buf[0] = val;
      break;

    case RELOC_WDISP30:
      val = (val >> 2) + 1;
      buf[0] |= (val >> 24) & 0x3f;
      buf[1] = (val >> 16);
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_HI22:
      buf[1] |= (val >> 26) & 0x3f;
      buf[2] = val >> 18;
      buf[3] = val >> 10;
      break;

    case RELOC_LO10:
      buf[2] |= (val >> 8) & 0x03;
      buf[3] = val;
      break;

    case RELOC_BASE13:
      buf[2] |= (val >> 8) & 0x1f;
      buf[3] = val;
      break;

    case RELOC_WDISP22:
      val = (val >> 2) + 1;
      /* FALLTHROUGH */
    case RELOC_BASE22:
      buf[1] |= (val >> 16) & 0x3f;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_JUMPTARG:	/* 00XX00XX pattern in a word.  */
      if (!fixP->fx_done)
	{
	  /* The linker tries to support both AMD and old GNU style
             R_IREL relocs.  That means that if the addend is exactly
             the negative of the address within the section, the
             linker will not handle it correctly.  */
	  if (fixP->fx_pcrel
	      && val != 0
	      && val == - (fixP->fx_frag->fr_address + fixP->fx_where))
	    as_bad_where
	      (fixP->fx_file, fixP->fx_line,
	       "the linker will not handle this relocation correctly");
	}
      else if (fixP->fx_pcrel)
	{
	  if (val + 0x20000 > 0x3ffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  "call/jmp target out of range");
	}
      else
	/* This case was supposed to be handled in machine_ip.  */
	abort ();

      buf[1] = val >> 10;	/* Holds bits 0003FFFC of address.  */
      buf[3] = val >> 2;
      break;

    case RELOC_CONST:		/* 00XX00XX pattern in a word.  */
      buf[1] = val >> 8;	/* Holds bits 0000XXXX.  */
      buf[3] = val;
      break;

    case RELOC_CONSTH:		/* 00XX00XX pattern in a word.  */
      buf[1] = val >> 24;	/* Holds bits XXXX0000.  */
      buf[3] = val >> 16;
      break;

    case NO_RELOC:
    default:
      as_bad (_("bad relocation type: 0x%02x"), fixP->fx_r_type);
      break;
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

#ifdef OBJ_COFF
short
tc_coff_fix2rtype (fixS *fixP)
{
  switch (fixP->fx_r_type)
    {
    case RELOC_32:        return R_WORD;
    case RELOC_8:         return R_BYTE;
    case RELOC_CONST:     return R_ILOHALF;
    case RELOC_CONSTH:    return R_IHIHALF;
    case RELOC_JUMPTARG:  return R_IREL;
    default:
      printf (_("need %o3\n"), fixP->fx_r_type);
      abort ();
    }

  return 0;
}

#endif /* OBJ_COFF */

/* Should never be called for 29k.  */

void
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED,
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
  as_fatal (_("a29k_convert_frag\n"));
}

/* Should never be called for a29k.  */

int
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
			       segT segtype ATTRIBUTE_UNUSED)
{
  as_fatal (_("a29k_estimate_size_before_relax\n"));
  return 0;
}

/* Translate internal representation of relocation info to target format.

   On sparc/29k: first 4 bytes are normal unsigned long address, next three
   bytes are index, most sig. byte first.  Byte 7 is broken up with
   bit 7 as external, bits 6 & 5 unused, and the lower
   five bits as relocation type.  Next 4 bytes are long addend.  */

/* Thanx and a tip of the hat to Michael Bloom, mb@@ttidca.tti.com.  */

#ifdef OBJ_AOUT

void
tc_aout_fix_to_chars (char *where,
		      fixS *fixP,
		      relax_addressT segment_address_in_file)
{
  long r_symbolnum;

  know (fixP->fx_r_type < NO_RELOC);
  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
       fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  where[4] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[6] = r_symbolnum & 0x0ff;
  where[7] = (((!S_IS_DEFINED (fixP->fx_addsy)) << 7) & 0x80) | (0 & 0x60) | (fixP->fx_r_type & 0x1F);

  /* Also easy.  */
  md_number_to_chars (&where[8], fixP->fx_addnumber, 4);
}

#endif /* OBJ_AOUT */

const char *md_shortopts = "";

struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
}

/* This is called when a line is unrecognized.  This is used to handle
   definitions of a29k style local labels.  */

int
a29k_unrecognized_line (int c)
{
  int lab;
  char *s;

  if (c != '$'
      || ! ISDIGIT (input_line_pointer[0]))
    return 0;

  s = input_line_pointer;

  lab = 0;
  while (ISDIGIT (*s))
    {
      lab = lab * 10 + *s - '0';
      ++s;
    }

  if (*s != ':')
    {
      /* Not a label definition.  */
      return 0;
    }

  if (dollar_label_defined (lab))
    {
      as_bad (_("label \"$%d\" redefined"), lab);
      return 0;
    }

  define_dollar_label (lab);
  colon (dollar_label_name (lab, 0));
  input_line_pointer = s + 1;

  return 1;
}

/* Default the values of symbols known that should be "predefined".  We
   don't bother to predefine them unless you actually use one, since there
   are a lot of them.  */

symbolS *
md_undefined_symbol (char *name)
{
  long regnum;
  char testbuf[5 + /*SLOP*/ 5];

  if (name[0] == 'g' || name[0] == 'G'
      || name[0] == 'l' || name[0] == 'L'
      || name[0] == 's' || name[0] == 'S')
    {
      /* Perhaps a global or local register name.  */
      if (name[1] == 'r' || name[1] == 'R')
	{
	  long maxreg;

	  /* Parse the number, make sure it has no extra zeroes or
	     trailing chars.  */
	  regnum = atol (&name[2]);

	  if (name[0] == 's' || name[0] == 'S')
	    maxreg = 255;
	  else
	    maxreg = 127;
	  if (regnum > maxreg)
	    return NULL;

	  sprintf (testbuf, "%ld", regnum);
	  if (strcmp (testbuf, &name[2]) != 0)
	    return NULL;	/* gr007 or lr7foo or whatever.  */

	  /* We have a wiener!  Define and return a new symbol for it.  */
	  if (name[0] == 'l' || name[0] == 'L')
	    regnum += 128;
	  else if (name[0] == 's' || name[0] == 'S')
	    regnum += SREG;
	  return (symbol_new (name, SEG_REGISTER, (valueT) regnum,
			      &zero_address_frag));
	}
    }

  return NULL;
}

/* Parse an operand that is machine-specific.  */

void
md_operand (expressionS *expressionP)
{
  if (input_line_pointer[0] == '%' && input_line_pointer[1] == '%')
    {
      /* We have a numeric register expression.  No biggy.  */
      input_line_pointer += 2;	/* Skip %% */
      (void) expression (expressionP);
      if (expressionP->X_op != O_constant
	  || expressionP->X_add_number > 255)
	as_bad (_("Invalid expression after %%%%\n"));
      expressionP->X_op = O_register;
    }
  else if (input_line_pointer[0] == '&')
    {
      /* We are taking the 'address' of a register...this one is not
	 in the manual, but it *is* in traps/fpsymbol.h!  What they
	 seem to want is the register number, as an absolute number.  */
      input_line_pointer++;	/* Skip & */
      (void) expression (expressionP);
      if (expressionP->X_op != O_register)
	as_bad (_("Invalid register in & expression"));
      else
	expressionP->X_op = O_constant;
    }
  else if (input_line_pointer[0] == '$'
	   && ISDIGIT (input_line_pointer[1]))
    {
      long lab;
      char *name;
      symbolS *sym;

      /* This is a local label.  */
      ++input_line_pointer;
      lab = (long) get_absolute_expression ();
      if (dollar_label_defined (lab))
	{
	  name = dollar_label_name (lab, 0);
	  sym = symbol_find (name);
	}
      else
	{
	  name = dollar_label_name (lab, 1);
	  sym = symbol_find_or_make (name);
	}

      expressionP->X_op = O_symbol;
      expressionP->X_add_symbol = sym;
      expressionP->X_add_number = 0;
    }
  else if (input_line_pointer[0] == '$')
    {
      char *s;
      char type;
      int fieldnum, fieldlimit;
      LITTLENUM_TYPE floatbuf[8];

      /* $float(), $doubleN(), or $extendN() convert floating values
	 to integers.  */

      s = input_line_pointer;

      ++s;

      fieldnum = 0;
      if (strncmp (s, "double", sizeof "double" - 1) == 0)
	{
	  s += sizeof "double" - 1;
	  type = 'd';
	  fieldlimit = 2;
	}
      else if (strncmp (s, "float", sizeof "float" - 1) == 0)
	{
	  s += sizeof "float" - 1;
	  type = 'f';
	  fieldlimit = 1;
	}
      else if (strncmp (s, "extend", sizeof "extend" - 1) == 0)
	{
	  s += sizeof "extend" - 1;
	  type = 'x';
	  fieldlimit = 4;
	}
      else
	return;

      if (ISDIGIT (*s))
	{
	  fieldnum = *s - '0';
	  ++s;
	}

      if (fieldnum >= fieldlimit)
	return;

      SKIP_WHITESPACE ();
      if (*s != '(')
	return;
      ++s;
      SKIP_WHITESPACE ();

      s = atof_ieee (s, type, floatbuf);
      if (s == NULL)
	return;
      s = s;

      SKIP_WHITESPACE ();
      if (*s != ')')
	return;
      ++s;
      SKIP_WHITESPACE ();

      input_line_pointer = s;
      expressionP->X_op = O_constant;
      expressionP->X_unsigned = 1;
      expressionP->X_add_number = ((floatbuf[fieldnum * 2]
				    << LITTLENUM_NUMBER_OF_BITS)
				   + floatbuf[fieldnum * 2 + 1]);
    }
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
  return size;			/* Byte alignment is fine.  */
}

/* Exactly what point is a PC-relative offset relative TO?
   On the 29000, they're relative to the address of the instruction,
   which we have set up as the address of the fixup too.  */

long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_where + fixP->fx_frag->fr_address;
}

const pseudo_typeS
md_pseudo_table[] =
{
  {"align", s_align_bytes, 4},
  {"block", s_space, 0},
  {"cputype", s_ignore, 0},	/* CPU as 29000 or 29050.  */
  {"reg", s_lsym, 0},		/* Register equate, same as equ.  */
  {"space", s_ignore, 0},	/* Listing control.  */
  {"sect", s_ignore, 0},	/* Creation of coff sections.  */
#ifndef OBJ_COFF
  {"use", s_use, 0},  		/* We can do this right with coff.  */
#endif
  {"word", cons, 4},
  {NULL, 0, 0},
};
@


1.14
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@@


1.13
log
@Update the address and phone number of the FSF
@
text
@d735 1
a735 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.12
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.11
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d38 4
a41 4
#define	IMMEDIATE_BIT	0x01000000	/* Turns RB into Immediate */
#define	ABSOLUTE_BIT	0x01000000	/* Turns PC-relative to Absolute */
#define	CE_BIT		0x00800000	/* Coprocessor enable in LOAD */
#define	UI_BIT		0x00000080	/* Unsigned integer in CONVERT */
d43 1
a43 1
/* handle of the OPCODE hash table */
d47 9
a55 10
  {
    char *error;
    unsigned long opcode;
    struct nlist *nlistp;
    expressionS exp;
    int pcrel;
    int reloc_offset;		/* Offset of reloc within insn */

    int reloc;
  }
a57 27
static void machine_ip PARAMS ((char *str));
/* static void print_insn PARAMS ((struct machine_it *insn)); */
#ifndef OBJ_COFF
static void s_data1 PARAMS ((void));
static void s_use PARAMS ((int));
#endif
static void insert_sreg PARAMS ((char *, int));
static void define_some_regs PARAMS ((void));
static char *parse_operand PARAMS ((char *, expressionS *, int));

const pseudo_typeS
md_pseudo_table[] =
{
  {"align", s_align_bytes, 4},
  {"block", s_space, 0},
  {"cputype", s_ignore, 0},	/* CPU as 29000 or 29050 */
  {"reg", s_lsym, 0},		/* Register equate, same as equ */
  {"space", s_ignore, 0},	/* Listing control */
  {"sect", s_ignore, 0},	/* Creation of coff sections */
#ifndef OBJ_COFF
  /* We can do this right with coff.  */
  {"use", s_use, 0},
#endif
  {"word", cons, 4},
  {NULL, 0, 0},
};

d60 1
a60 1
const int md_reloc_size = RELSZ;	/* Coff headers */
d62 1
a62 1
const int md_reloc_size = 12;		/* something else headers */
d65 1
a65 1
const int md_reloc_size = 12;		/* Not bfdized*/
d69 1
a69 1
   pre-processor is disabled, these aren't very useful */
d74 1
a74 1
   .line and .file directives will appear in the pre-processed output */
d78 1
a78 1
/* Also note that comments like this one will always work */
d85 1
a85 1
/* Chars that can be used to separate mant from exp in floating point nums */
d88 3
a90 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d97 1
a97 3
/*
 *  anull bit - causes the branch delay slot instructions to not be executed
 */
d103 1
a103 2
s_use (ignore)
     int ignore;
d138 1
a138 1
s_data1 ()
d150 1
a150 3
insert_sreg (regname, regnum)
     char *regname;
     int regnum;
d173 1
a173 1
define_some_regs ()
d177 1
a177 1
  /* Protected special-purpose register names */
d194 1
a194 1
  /* Additional protected special-purpose registers for the 29050 */
d214 1
a214 1
  /* Unprotected special-purpose register names */
d233 1
d235 1
a235 1
md_begin ()
d237 1
a237 1
  register const char *retval = NULL;
d239 3
a241 3
  register int skipnext = 0;
  register unsigned int i;
  register char *strend, *strend2;
a258 1

d266 1
d269 1
d276 1
d281 1
d295 1
a295 1
      retval = hash_insert (op_hash, name, (PTR) &machine_opcodes[i]);
a309 28
/* Assemble a single instruction.  Its label has already been handled
   by the generic front end.  We just parse opcode and operands, and
   produce the bytes of data and relocation.  */

void
md_assemble (str)
     char *str;
{
  char *toP;

  know (str);
  machine_ip (str);
  toP = frag_more (4);
  /* put out the opcode */
  md_number_to_chars (toP, the_insn.opcode, 4);

  /* put out the symbol-dependent stuff */
  if (the_insn.reloc != NO_RELOC)
    {
      fix_new_exp (frag_now,
		   (toP - frag_now->fr_literal + the_insn.reloc_offset),
		   4,		/* size */
		   &the_insn.exp,
		   the_insn.pcrel,
		   the_insn.reloc);
    }
}

d311 1
a311 4
parse_operand (s, operandp, opt)
     char *s;
     expressionS *operandp;
     int opt;
d330 1
a330 2
machine_ip (str)
     char *str;
d352 1
a352 1
    case ' ':			/* FIXME-SOMEDAY more whitespace */
a374 1

d376 2
a377 4
    {
      /* Prime the pump.  */
      s = parse_operand (s, operand, insn->args[0] == 'I');
    }
d383 1
a383 2

	case '\0':		/* end of args */
d393 1
a393 1
	case ',':		/* Must match a comma */
d402 2
a403 1
	case 'v':		/* Trap numbers (immediate field) */
d407 1
a407 4
		{
		  opcode |= (operand->X_add_number << 16);
		  continue;
		}
d409 3
a411 5
		{
		  as_bad (_("Immediate value of %ld is too large"),
			  (long) operand->X_add_number);
		  continue;
		}
d414 2
a415 1
	  the_insn.reloc_offset = 1;	/* BIG-ENDIAN Byte 1 of insn */
d419 1
a419 1
	case 'b':		/* A general register or 8-bit immediate */
d434 1
a434 4
		{
		  opcode |= operand->X_add_number;
		  continue;
		}
d436 3
a438 5
		{
		  as_bad (_("Immediate value of %ld is too large"),
			  (long) operand->X_add_number);
		  continue;
		}
d441 1
a441 1
	  the_insn.reloc_offset = 3;	/* BIG-ENDIAN Byte 3 of insn */
d445 1
a445 1
	case 'a':		/* next operand must be a register */
d448 1
a448 1
	  /* lrNNN or grNNN or %%expr or a user-def register name */
d450 1
a450 1
	    break;		/* Only registers */
d455 1
a455 1
	    break;		/* No special registers */
d477 2
a478 2
	case 'x':		/* 16 bit constant, zero-extended */
	case 'X':		/* 16 bit constant, one-extended */
d481 2
a482 2
	      opcode |= (operand->X_add_number & 0xFF) << 0 |
		((operand->X_add_number & 0xFF00) << 8);
d492 3
a494 3
	      opcode |= (operand->X_add_number & 0x00FF0000) >> 16 |
		(((unsigned long) operand->X_add_number
		  /* avoid sign ext */  & 0xFF000000) >> 8);
d501 2
a502 2
	case 'P':		/* PC-relative jump address */
	case 'A':		/* Absolute jump address */
d510 1
d513 1
d519 4
a522 3
	      opcode |= ABSOLUTE_BIT |
		(operand->X_add_number & 0x0003FC00) << 6 |
		((operand->X_add_number & 0x000003FC) >> 2);
d525 1
d528 1
a528 1
	  the_insn.pcrel = 1;	/* Assume PC-relative jump */
d530 1
a530 1
             know sym val? */
d533 1
a533 1
	case 'e':		/* Coprocessor enable bit for LOAD/STORE insn */
d546 3
a548 3
	case 'n':		/* Control bits for LOAD/STORE instructions */
	  if (operand->X_op == O_constant &&
	      operand->X_add_number < 128)
d555 1
a555 1
	case 's':		/* Special register number */
d557 1
a557 1
	    break;		/* Only registers */
d559 1
a559 1
	    break;		/* Not a special register */
d563 1
a563 1
	case 'u':		/* UI bit of CONVERT */
d576 3
a578 3
	case 'r':		/* RND bits of CONVERT */
	  if (operand->X_op == O_constant &&
	      operand->X_add_number < 8)
d585 1
a585 1
	case 'I':		/* ID bits of INV and IRETINV.  */
d597 3
a599 3
	case 'd':		/* FD bits of CONVERT */
	  if (operand->X_op == O_constant &&
	      operand->X_add_number < 4)
d606 3
a608 3
	case 'f':		/* FS bits of CONVERT */
	  if (operand->X_op == O_constant &&
	      operand->X_add_number < 4)
d616 2
a617 2
	  if (operand->X_op == O_constant &&
	      operand->X_add_number < 4)
d625 2
a626 2
	  if (operand->X_op == O_constant &&
	      operand->X_add_number < 16)
d642 22
d676 1
a676 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d726 2
a727 3
/*
 * Write out big-endian.
 */
d729 1
a729 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d735 1
a735 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d795 1
a795 1
    case RELOC_JUMPTARG:	/* 00XX00XX pattern in a word */
d818 2
a819 1
      buf[1] = val >> 10;	/* Holds bits 0003FFFC of address */
d823 2
a824 2
    case RELOC_CONST:		/* 00XX00XX pattern in a word */
      buf[1] = val >> 8;	/* Holds bits 0000XXXX */
d828 2
a829 2
    case RELOC_CONSTH:		/* 00XX00XX pattern in a word */
      buf[1] = val >> 24;	/* Holds bits XXXX0000 */
d845 1
a845 2
tc_coff_fix2rtype (fixP)
     fixS *fixP;
a846 1

d849 5
a853 10
    case RELOC_32:
      return (R_WORD);
    case RELOC_8:
      return (R_BYTE);
    case RELOC_CONST:
      return (R_ILOHALF);
    case RELOC_CONSTH:
      return (R_IHIHALF);
    case RELOC_JUMPTARG:
      return (R_IREL);
d857 1
a857 1
    }				/* switch on type */
d859 1
a859 1
  return (0);
d864 2
a865 1
/* should never be called for 29k */
d867 3
a869 4
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     register fragS *fragP ATTRIBUTE_UNUSED;
d874 2
a875 1
/* should never be called for a29k */
d877 2
a878 3
md_estimate_size_before_relax (fragP, segtype)
     register fragS *fragP ATTRIBUTE_UNUSED;
     segT segtype ATTRIBUTE_UNUSED;
d890 2
a891 1
/* Thanx and a tip of the hat to Michael Bloom, mb@@ttidca.tti.com */
d896 3
a898 4
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
d917 2
a918 1
  /* Also easy */
d925 3
a927 1
struct option md_longopts[] = {
d930 1
d934 1
a934 3
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d940 1
a940 2
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
d948 1
a948 2
a29k_unrecognized_line (c)
     int c;
d990 1
a990 2
md_undefined_symbol (name)
     char *name;
d999 1
a999 1
      /* Perhaps a global or local register name */
d1017 1
a1017 1
	    return NULL;	/* gr007 or lr7foo or whatever */
d1035 1
a1035 2
md_operand (expressionP)
     expressionS *expressionP;
a1036 1

d1118 1
a1118 3
	{
	  return;
	}
d1125 1
d1156 1
d1158 1
a1158 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d1160 1
a1160 1
  return size;			/* Byte alignment is fine */
d1166 1
d1168 1
a1168 2
md_pcrel_from (fixP)
     fixS *fixP;
d1172 16
@


1.10
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 2
a3 1
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001, 2002
d791 1
a791 1
     valueT * valP;
d794 1
a794 1
  long val = *valP;
d868 1
a868 3
	  long v = val >> 17;

	  if (v != 0 && v != -1)
@


1.9
log
@	* config/tc-a29k.c (insert_sreg): Prototype.
	(define_some_regs): Prototype, make static.
	(parse_operand): Likewise.
	(md_parse_option <c,arg>): Add ATTRIBUTE_UNUSED.
	(md_show_usage <stream>): Likewise.
	(md_section_align <segment>): Likewise.
	(md_convert_frag <all args>): Likewise.
	(md_estimate_size_before_relax <all args>): Likewise.
	(md_apply_fix3): Don't cast valP pointer type.  Fix bogus >>='s.
	* config/tc-arm.c (arm_validate_fix): Only for OBJ_COFF or OBJ_ELF.
@
text
@a947 57
#if 0
/* for debugging only */
static void
print_insn (insn)
     struct machine_it *insn;
{
  char *Reloc[] =
  {
    "RELOC_8",
    "RELOC_16",
    "RELOC_32",
    "RELOC_DISP8",
    "RELOC_DISP16",
    "RELOC_DISP32",
    "RELOC_WDISP30",
    "RELOC_WDISP22",
    "RELOC_HI22",
    "RELOC_22",
    "RELOC_13",
    "RELOC_LO10",
    "RELOC_SFA_BASE",
    "RELOC_SFA_OFF13",
    "RELOC_BASE10",
    "RELOC_BASE13",
    "RELOC_BASE22",
    "RELOC_PC10",
    "RELOC_PC22",
    "RELOC_JMP_TBL",
    "RELOC_SEGOFF16",
    "RELOC_GLOB_DAT",
    "RELOC_JMP_SLOT",
    "RELOC_RELATIVE",
    "NO_RELOC"
  };

  if (insn->error)
    {
      fprintf (stderr, "ERROR: %s\n");
    }
  fprintf (stderr, "opcode=0x%08x\n", insn->opcode);
  fprintf (stderr, "reloc = %s\n", Reloc[insn->reloc]);
  fprintf (stderr, "exp =  {\n");
  fprintf (stderr, "\t\tX_add_symbol = %s\n",
	   insn->exp.X_add_symbol ?
	   (S_GET_NAME (insn->exp.X_add_symbol) ?
	    S_GET_NAME (insn->exp.X_add_symbol) : "???") : "0");
  fprintf (stderr, "\t\tX_op_symbol = %s\n",
	   insn->exp.X_op_symbol ?
	   (S_GET_NAME (insn->exp.X_op_symbol) ?
	    S_GET_NAME (insn->exp.X_op_symbol) : "???") : "0");
  fprintf (stderr, "\t\tX_add_number = %d\n",
	   insn->exp.X_add_number);
  fprintf (stderr, "}\n");
}

#endif

@


1.8
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d64 3
d204 1
a204 1
void
d366 1
a366 1
char *
d793 1
a793 1
  long val = * (long *) valP;
d819 1
a819 1
      val = (val >>= 2) + 1;
d843 1
a843 1
      val = (val >>= 2) + 1;
d931 3
a933 3
     object_headers *headers;
     segT seg;
     register fragS *fragP;
d941 2
a942 2
     register fragS *fragP;
     segT segtype;
d1052 2
a1053 2
     int c;
     char *arg;
d1060 1
a1060 1
     FILE *stream;
d1283 1
a1283 1
     segT segment;
@


1.7
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001
d1041 1
a1041 1
CONST char *md_shortopts = "";
@


1.6
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d785 1
a785 1
md_apply_fix (fixP, val)
d787 2
a788 1
     long val;
d790 1
d793 1
a793 1
  fixP->fx_addnumber = val;	/* Remember value for emit_reloc */
d800 1
a800 3
    {
      val += fixP->fx_where + fixP->fx_frag->fr_address;
    }
a803 1

d865 1
d871 1
a871 1
	/* this case was supposed to be handled in machine_ip */
d892 3
@


1.5
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 2000
a25 1
#include <ctype.h>
d27 1
d191 1
a191 1
    buf[i] = islower (regname[i]) ? toupper (regname[i]) : regname[i];
d400 3
a402 4
  if (isalpha (*s))
    for (; isalnum (*s); ++s)
      if (isupper (*s))
	*s = tolower (*s);
d1069 1
a1069 1
      || ! isdigit ((unsigned char) input_line_pointer[0]))
d1075 1
a1075 1
  while (isdigit ((unsigned char) *s))
d1178 1
a1178 1
	   && isdigit ((unsigned char) input_line_pointer[1]))
d1240 1
a1240 1
      if (isdigit (*s))
@


1.4
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 98, 2000
@


1.4.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 2000
@


1.3
log
@2000-09-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-a29k.c: Fix formatting.
	* config/tc-alpha.c: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-tic80.h: Likewise.
@
text
@d1043 1
a1043 1
size_t md_longopts_size = sizeof(md_longopts);
@


1.2
log
@Fix comments.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1998
d101 1
a101 1
   #NO_APP at the beginning of its output. */
d151 1
a151 1
     instruction memory on some 29k's.  So, into initialized data. */
d286 1
a286 1
	 variations (b/i field and P/A field) and handle them. */
d430 1
a430 1
   
d448 1
a448 1
	      /* We are truly done. */
a671 1

a793 1

d1005 1
a1005 1
   five bits as relocation type.  Next 4 bytes are long addend. */
d1122 1
a1122 1
	     trailing chars. */
d1236 1
a1236 1
      else 
d1267 1
a1267 1
      expressionP->X_op = O_constant; 
a1292 2

/* end of tc-a29k.c */
@


1.1
log
@Initial revision
@
text
@d713 2
a714 2
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

