head	1.24;
access;
symbols
	binutils-2_24-branch:1.24.0.8
	binutils-2_24-branchpoint:1.24
	binutils-2_21_1:1.23
	binutils-2_23_2:1.24
	binutils-2_23_1:1.24
	binutils-2_23:1.24
	binutils-2_23-branch:1.24.0.6
	binutils-2_23-branchpoint:1.24
	binutils-2_22_branch:1.24.0.4
	binutils-2_22:1.24
	binutils-2_22-branch:1.24.0.2
	binutils-2_22-branchpoint:1.24
	binutils-2_21:1.23
	binutils-2_21-branch:1.23.0.4
	binutils-2_21-branchpoint:1.23
	binutils-2_20_1:1.23
	binutils-2_20:1.23
	binutils-arc-20081103-branch:1.20.0.6
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.23.0.2
	binutils-2_20-branchpoint:1.23
	dje-cgen-play1-branch:1.21.0.2
	dje-cgen-play1-branchpoint:1.21
	arc-20081103-branch:1.20.0.4
	arc-20081103-branchpoint:1.20
	binutils-2_19_1:1.20
	binutils-2_19:1.20
	binutils-2_19-branch:1.20.0.2
	binutils-2_19-branchpoint:1.20
	binutils-2_18:1.19
	binutils-2_18-branch:1.19.0.2
	binutils-2_18-branchpoint:1.19
	binutils-csl-coldfire-4_1-32:1.18
	binutils-csl-sourcerygxx-4_1-32:1.18
	binutils-csl-innovasic-fido-3_4_4-33:1.18
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.18
	binutils-csl-sourcerygxx-4_1-30:1.18
	binutils-csl-coldfire-4_1-28:1.18
	binutils-csl-sourcerygxx-4_1-29:1.18
	binutils-csl-sourcerygxx-4_1-28:1.18
	binutils-csl-arm-2006q3-27:1.18
	binutils-csl-sourcerygxx-4_1-27:1.18
	binutils-csl-arm-2006q3-26:1.18
	binutils-csl-sourcerygxx-4_1-26:1.18
	binutils-csl-sourcerygxx-4_1-25:1.18
	binutils-csl-sourcerygxx-4_1-24:1.18
	binutils-csl-sourcerygxx-4_1-23:1.18
	binutils-csl-sourcerygxx-4_1-21:1.18
	binutils-csl-arm-2006q3-21:1.18
	binutils-csl-sourcerygxx-4_1-22:1.18
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.18
	binutils-csl-sourcerygxx-4_1-20:1.18
	binutils-csl-arm-2006q3-19:1.18
	binutils-csl-sourcerygxx-4_1-19:1.18
	binutils-csl-sourcerygxx-4_1-18:1.18
	binutils-csl-renesas-4_1-9:1.18
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	binutils-csl-renesas-4_1-8:1.18
	binutils-csl-renesas-4_1-7:1.18
	binutils-csl-renesas-4_1-6:1.18
	binutils-csl-sourcerygxx-4_1-17:1.18
	binutils-csl-sourcerygxx-4_1-14:1.18
	binutils-csl-sourcerygxx-4_1-15:1.18
	binutils-csl-sourcerygxx-4_1-13:1.18
	binutils-2_17:1.18
	binutils-csl-sourcerygxx-4_1-12:1.18
	binutils-csl-sourcerygxx-3_4_4-21:1.18
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	binutils-csl-sourcerygxx-4_1-9:1.18
	binutils-csl-sourcerygxx-4_1-8:1.18
	binutils-csl-sourcerygxx-4_1-7:1.18
	binutils-csl-arm-2006q1-6:1.18
	binutils-csl-sourcerygxx-4_1-6:1.18
	binutils-csl-wrs-linux-3_4_4-22:1.14
	binutils-csl-coldfire-4_1-11:1.18
	binutils-csl-sourcerygxx-3_4_4-19:1.18
	binutils-csl-coldfire-4_1-10:1.18
	binutils-csl-sourcerygxx-4_1-5:1.18
	binutils-csl-sourcerygxx-4_1-4:1.18
	binutils-csl-wrs-linux-3_4_4-21:1.14
	binutils-csl-morpho-4_1-4:1.18
	binutils-csl-sourcerygxx-3_4_4-17:1.18
	binutils-csl-wrs-linux-3_4_4-20:1.14
	binutils-2_17-branch:1.18.0.4
	binutils-2_17-branchpoint:1.18
	binutils-csl-2_17-branch:1.18.0.2
	binutils-csl-2_17-branchpoint:1.18
	binutils-csl-gxxpro-3_4-branch:1.14.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	binutils-csl-arm-2005q1a:1.14
	binutils-csl-arm-2005q1-branch:1.14.0.4
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.2
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.12
	csl-arm-2004-q3:1.10
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	binutils-2_15-branch:1.9.0.10
	cagney_bfdfile-20040213-branch:1.9.0.8
	cagney_bfdfile-20040213-branchpoint:1.9
	cagney_bigcore-20040122-branch:1.9.0.6
	cagney_bigcore-20040122-branchpoint:1.9
	csl-arm-2003-q4:1.9
	binutils-2_14:1.9
	binutils-2_14-branch:1.9.0.4
	binutils-2_14-branchpoint:1.9
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	binutils-2_13_1:1.9
	binutils-2_13:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.2
	binutils-2_12_1:1.6
	binutils-2_12:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	x86_64versiong3:1.2
	binutils_latest_snapshot:1.24;
locks; strict;
comment	@ * @;


1.24
date	2011.01.06.16.40.13;	author pkoning;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.03.10.58.46;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.05.15.07.45;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.05.09.13.02;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.23.11.18.13;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.03.11.47.54;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.31.23.18.33;	author bje;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.03.01.54.25;	author hp;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.01.11.19.37;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.17.12.19.57;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.11.09.53.50;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.05.03.10.34;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.15.21.28.58;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.19.05.33.29;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.23.14.02.13;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.21.00.04.47;	author kazu;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.18.23.33.03;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.24
log
@* config/tc-pdp11.c (parse_op_no_deferred): Allow PC-relative
references to absolute addresses.
@
text
@/* tc-pdp11.c - pdp11-specific -
   Copyright 2001, 2002, 2004, 2005, 2007, 2009
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "opcode/pdp11.h"

extern int flonum_gen2vax (int, FLONUM_TYPE * f, LITTLENUM_TYPE *);

#define TRUE  1
#define FALSE 0

/* A representation for PDP-11 machine code.  */
struct pdp11_code
{
  char *error;
  int code;
  int additional;	/* Is there an additional word?  */
  int word;		/* Additional word, if any.  */
  struct
  {
    bfd_reloc_code_real_type type;
    expressionS exp;
    int pc_rel;
  } reloc;
};

/* Instruction set extensions.

   If you change this from an array to something else, please update
   the "PDP-11 instruction set extensions" comment in pdp11.h.  */
int pdp11_extension[PDP11_EXT_NUM];

/* Assembly options.  */

#define ASM_OPT_PIC 1
#define ASM_OPT_NUM 2

int asm_option[ASM_OPT_NUM];

/* These chars start a comment anywhere in a source file (except inside
   another comment.  */
const char comment_chars[] = "#/";

/* These chars only start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#/";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* as in 0f123.456.  */
/* or    0H1.234E-12 (see exp chars above).  */
const char FLT_CHARS[] = "dDfF";

void pseudo_even (int);
void pseudo_bss (int);

const pseudo_typeS md_pseudo_table[] =
{
  { "bss", pseudo_bss, 0 },
  { "even", pseudo_even, 0 },
  { 0, 0, 0 },
};

static struct hash_control *insn_hash = NULL;

static int
set_option (char *arg)
{
  int yes = 1;

  if (strcmp (arg, "all-extensions") == 0
      || strcmp (arg, "all") == 0)
    {
      memset (pdp11_extension, ~0, sizeof pdp11_extension);
      pdp11_extension[PDP11_NONE] = 0;
      return 1;
    }
  else if (strcmp (arg, "no-extensions") == 0)
    {
      memset (pdp11_extension, 0, sizeof pdp11_extension);
      pdp11_extension[PDP11_BASIC] = 1;
      return 1;
    }

  if (strncmp (arg, "no-", 3) == 0)
    {
      yes = 0;
      arg += 3;
    }

  /* Commersial instructions.  */
  if (strcmp (arg, "cis") == 0)
    pdp11_extension[PDP11_CIS] = yes;
  /* Call supervisor mode.  */
  else if (strcmp (arg, "csm") == 0)
    pdp11_extension[PDP11_CSM] = yes;
  /* Extended instruction set.  */
  else if (strcmp (arg, "eis") == 0)
    pdp11_extension[PDP11_EIS] = pdp11_extension[PDP11_LEIS] = yes;
  /* KEV11 floating-point.  */
  else if (strcmp (arg, "fis") == 0
	   || strcmp (arg, "kev11") == 0
	   || strcmp (arg, "kev-11") == 0)
    pdp11_extension[PDP11_FIS] = yes;
  /* FP-11 floating-point.  */
  else if (strcmp (arg, "fpp") == 0
	   || strcmp (arg, "fpu") == 0
	   || strcmp (arg, "fp11") == 0
	   || strcmp (arg, "fp-11") == 0
	   || strcmp (arg, "fpj11") == 0
	   || strcmp (arg, "fp-j11") == 0
	   || strcmp (arg, "fpj-11") == 0)
    pdp11_extension[PDP11_FPP] = yes;
  /* Limited extended insns.  */
  else if (strcmp (arg, "limited-eis") == 0)
    {
      pdp11_extension[PDP11_LEIS] = yes;
      if (!pdp11_extension[PDP11_LEIS])
	pdp11_extension[PDP11_EIS] = 0;
    }
  /* Move from processor type.  */
  else if (strcmp (arg, "mfpt") == 0)
    pdp11_extension[PDP11_MFPT] = yes;
  /* Multiprocessor insns:  */
  else if (strncmp (arg, "mproc", 5) == 0
	   /* TSTSET, WRTLCK */
	   || strncmp (arg, "multiproc", 9) == 0)
    pdp11_extension[PDP11_MPROC] = yes;
  /* Move from/to proc status.  */
  else if (strcmp (arg, "mxps") == 0)
    pdp11_extension[PDP11_MXPS] = yes;
  /* Position-independent code.  */
  else if (strcmp (arg, "pic") == 0)
    asm_option[ASM_OPT_PIC] = yes;
  /* Set priority level.  */
  else if (strcmp (arg, "spl") == 0)
    pdp11_extension[PDP11_SPL] = yes;
  /* Microcode instructions:  */
  else if (strcmp (arg, "ucode") == 0
	   /* LDUB, MED, XFC */
	   || strcmp (arg, "microcode") == 0)
    pdp11_extension[PDP11_UCODE] = yes;
  else
    return 0;

  return 1;
}


static void
init_defaults (void)
{
  static int first = 1;

  if (first)
    {
      set_option ("all-extensions");
      set_option ("pic");
      first = 0;
    }
}

void
md_begin (void)
{
  int i;

  init_defaults ();

  insn_hash = hash_new ();
  if (insn_hash == NULL)
    as_fatal (_("Virtual memory exhausted"));

  for (i = 0; i < pdp11_num_opcodes; i++)
    hash_insert (insn_hash, pdp11_opcodes[i].name, (void *) (pdp11_opcodes + i));
  for (i = 0; i < pdp11_num_aliases; i++)
    hash_insert (insn_hash, pdp11_aliases[i].name, (void *) (pdp11_aliases + i));
}

void
md_number_to_chars (char con[], valueT value, int nbytes)
{
  /* On a PDP-11, 0x1234 is stored as "\x12\x34", and
     0x12345678 is stored as "\x56\x78\x12\x34". It's
     anyones guess what 0x123456 would be stored like.  */

  switch (nbytes)
    {
    case 0:
      break;
    case 1:
      con[0] =  value       & 0xff;
      break;
    case 2:
      con[0] =  value        & 0xff;
      con[1] = (value >>  8) & 0xff;
      break;
    case 4:
      con[0] = (value >> 16) & 0xff;
      con[1] = (value >> 24) & 0xff;
      con[2] =  value        & 0xff;
      con[3] = (value >>  8) & 0xff;
      break;
    default:
      BAD_CASE (nbytes);
    }
}

/* Fix up some data or instructions after we find out the value of a symbol
   that they reference.  Knows about order of bytes in address.  */

void
md_apply_fix (fixS *fixP,
	       valueT * valP,
	       segT seg ATTRIBUTE_UNUSED)
{
  valueT code;
  valueT mask;
  valueT val = * valP;
  char *buf;
  int shift;
  int size;

  buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  size = fixP->fx_size;
  code = md_chars_to_number ((unsigned char *) buf, size);

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_16:
    case BFD_RELOC_16_PCREL:
      mask = 0xffff;
      shift = 0;
      break;
    case BFD_RELOC_PDP11_DISP_8_PCREL:
      mask = 0x00ff;
      shift = 1;
      break;
    case BFD_RELOC_PDP11_DISP_6_PCREL:
      mask = 0x003f;
      shift = 1;
      val = -val;
      break;
    default:
      BAD_CASE (fixP->fx_r_type);
    }

  if (fixP->fx_addsy != NULL)
    val += symbol_get_bfdsym (fixP->fx_addsy)->section->vma;
    /* *value += fixP->fx_addsy->bsym->section->vma; */

  code &= ~mask;
  code |= (val >> shift) & mask;
  number_to_chars_littleendian (buf, code, size);

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

long
md_chars_to_number (con, nbytes)
     unsigned char con[];	/* Low order byte 1st.  */
     int nbytes;		/* Number of bytes in the input.  */
{
  /* On a PDP-11, 0x1234 is stored as "\x12\x34", and
     0x12345678 is stored as "\x56\x78\x12\x34". It's
     anyones guess what 0x123456 would be stored like.  */
  switch (nbytes)
    {
    case 0:
      return 0;
    case 1:
      return con[0];
    case 2:
      return (con[1] << BITS_PER_CHAR) | con[0];
    case 4:
      return
	(((con[1] << BITS_PER_CHAR) | con[0]) << (2 * BITS_PER_CHAR))
	|((con[3] << BITS_PER_CHAR) | con[2]);
    default:
      BAD_CASE (nbytes);
      return 0;
    }
}

static char *
skip_whitespace (char *str)
{
  while (*str == ' ' || *str == '\t')
    str++;
  return str;
}

static char *
find_whitespace (char *str)
{
  while (*str != ' ' && *str != '\t' && *str != 0)
    str++;
  return str;
}

static char *
parse_reg (char *str, struct pdp11_code *operand)
{
  str = skip_whitespace (str);
  if (TOLOWER (*str) == 'r')
    {
      str++;
      switch (*str)
	{
	case '0': case '1': case '2': case '3':
	case '4': case '5': case '6': case '7':
	  operand->code = *str - '0';
	  str++;
	  break;
	default:
	  operand->error = _("Bad register name");
	  return str - 1;
	}
    }
  else if (strncmp (str, "sp", 2) == 0
	   || strncmp (str, "SP", 2) == 0)
    {
      operand->code = 6;
      str += 2;
    }
  else if (strncmp (str, "pc", 2) == 0
	   || strncmp (str, "PC", 2) == 0)
    {
      operand->code = 7;
      str += 2;
    }
  else
    {
      operand->error = _("Bad register name");
      return str;
    }

  return str;
}

static char *
parse_ac5 (char *str, struct pdp11_code *operand)
{
  str = skip_whitespace (str);
  if (strncmp (str, "fr", 2) == 0
      || strncmp (str, "FR", 2) == 0
      || strncmp (str, "ac", 2) == 0
      || strncmp (str, "AC", 2) == 0)
    {
      str += 2;
      switch (*str)
	{
	case '0': case '1': case '2': case '3':
        case '4': case '5':
	  operand->code = *str - '0';
	  str++;
	  break;
	default:
	  operand->error = _("Bad register name");
	  return str - 2;
	}
    }
  else
    {
      operand->error = _("Bad register name");
      return str;
    }

  return str;
}

static char *
parse_ac (char *str, struct pdp11_code *operand)
{
  str = parse_ac5 (str, operand);
  if (!operand->error && operand->code > 3)
    {
      operand->error = _("Bad register name");
	  return str - 3;
    }

  return str;
}

static char *
parse_expression (char *str, struct pdp11_code *operand)
{
  char *save_input_line_pointer;
  segT seg;

  save_input_line_pointer = input_line_pointer;
  input_line_pointer = str;
  seg = expression (&operand->reloc.exp);
  if (seg == NULL)
    {
      input_line_pointer = save_input_line_pointer;
      operand->error = _("Error in expression");
      return str;
    }

  str = input_line_pointer;
  input_line_pointer = save_input_line_pointer;

  operand->reloc.pc_rel = 0;

  return str;
}

static char *
parse_op_no_deferred (char *str, struct pdp11_code *operand)
{
  LITTLENUM_TYPE literal_float[2];

  str = skip_whitespace (str);

  switch (*str)
    {
    case '(':				/* (rn) and (rn)+ */
      str = parse_reg (str + 1, operand);
      if (operand->error)
	return str;
      str = skip_whitespace (str);
      if (*str != ')')
	{
	  operand->error = _("Missing ')'");
	  return str;
	}
      str++;
      if (*str == '+')
	{
	  operand->code |= 020;
	  str++;
	}
      else
	{
	  operand->code |= 010;
	}
      break;

      /* Immediate.  */
    case '#':
    case '$':
      str = parse_expression (str + 1, operand);
      if (operand->error)
	return str;
      operand->additional = TRUE;
      operand->word = operand->reloc.exp.X_add_number;
      switch (operand->reloc.exp.X_op)
	{
	case O_constant:
	  break;
	case O_symbol:
	case O_add:
	case O_subtract:
	  operand->reloc.type = BFD_RELOC_16;
	  operand->reloc.pc_rel = 0;
	  break;
        case O_big:
          if (operand->reloc.exp.X_add_number > 0)
            {
              operand->error = _("Error in expression");
              break;
            }
          /* It's a floating literal...  */
          know (operand->reloc.exp.X_add_number < 0);
          flonum_gen2vax ('f', &generic_floating_point_number, literal_float);
          operand->word = literal_float[0];
          if (literal_float[1] != 0)
            as_warn (_("Low order bits truncated in immediate float operand"));
          break;
	default:
	  operand->error = _("Error in expression");
	  break;
	}
      operand->code = 027;
      break;

      /* label, d(rn), -(rn)  */
    default:
      {
	if (strncmp (str, "-(", 2) == 0)	/* -(rn) */
	  {
	    str = parse_reg (str + 2, operand);
	    if (operand->error)
	      return str;
	    str = skip_whitespace (str);
	    if (*str != ')')
	      {
		operand->error = _("Missing ')'");
		return str;
	      }
	    operand->code |= 040;
	    str++;
	    break;
	  }

	str = parse_expression (str, operand);
	if (operand->error)
	  return str;

	str = skip_whitespace (str);

	if (*str != '(')
	  {
	    operand->code = 067;
	    operand->additional = 1;
	    operand->word = 0;
	    operand->reloc.type = BFD_RELOC_16_PCREL;
	    operand->reloc.pc_rel = 1;
	    break;
	  }

	/* d(rn) */
	str++;
	str = parse_reg (str, operand);
	if (operand->error)
	  return str;

	str = skip_whitespace (str);

	if (*str != ')')
	  {
	    operand->error = _("Missing ')'");
	    return str;
	  }

	str++;
	operand->additional = TRUE;
	operand->code |= 060;
	switch (operand->reloc.exp.X_op)
	  {
	  case O_symbol:
	    operand->reloc.type = BFD_RELOC_16;
	    operand->reloc.pc_rel = 0;
	    break;
	  case O_constant:
	    if ((operand->code & 7) == 7)
	      {
		operand->reloc.pc_rel = 1;
		operand->word = operand->reloc.exp.X_add_number;
	      }
	    else
	      operand->word = operand->reloc.exp.X_add_number;

	    break;
	  default:
	    BAD_CASE (operand->reloc.exp.X_op);
	  }
	break;
      }
    }

  return str;
}

static char *
parse_op_noreg (char *str, struct pdp11_code *operand)
{
  str = skip_whitespace (str);
  operand->error = NULL;

  if (*str == '@@' || *str == '*')
    {
      str = parse_op_no_deferred (str + 1, operand);
      if (operand->error)
	return str;
      operand->code |= 010;
    }
  else
    str = parse_op_no_deferred (str, operand);

  return str;
}

static char *
parse_op (char *str, struct pdp11_code *operand)
{
  str = skip_whitespace (str);

  str = parse_reg (str, operand);
  if (!operand->error)
    return str;

  operand->error = NULL;
  parse_ac5 (str, operand);
  if (!operand->error)
    {
      operand->error = _("Float AC not legal as integer operand");
      return str;
    }

  return parse_op_noreg (str, operand);
}

static char *
parse_fop (char *str, struct pdp11_code *operand)
{
  str = skip_whitespace (str);

  str = parse_ac5 (str, operand);
  if (!operand->error)
    return str;

  operand->error = NULL;
  parse_reg (str, operand);
  if (!operand->error)
    {
      operand->error = _("General register not legal as float operand");
      return str;
    }

  return parse_op_noreg (str, operand);
}

static char *
parse_separator (char *str, int *error)
{
  str = skip_whitespace (str);
  *error = (*str != ',');
  if (!*error)
    str++;
  return str;
}

void
md_assemble (char *instruction_string)
{
  const struct pdp11_opcode *op;
  struct pdp11_code insn, op1, op2;
  int error;
  int size;
  char *err = NULL;
  char *str;
  char *p;
  char c;

  str = skip_whitespace (instruction_string);
  p = find_whitespace (str);
  if (p - str == 0)
    {
      as_bad (_("No instruction found"));
      return;
    }

  c = *p;
  *p = '\0';
  op = (struct pdp11_opcode *)hash_find (insn_hash, str);
  *p = c;
  if (op == 0)
    {
      as_bad (_("Unknown instruction '%s'"), str);
      return;
    }

  if (!pdp11_extension[op->extension])
    {
      as_warn (_("Unsupported instruction set extension: %s"), op->name);
      return;
    }

  insn.error = NULL;
  insn.code = op->opcode;
  insn.reloc.type = BFD_RELOC_NONE;
  op1.error = NULL;
  op1.additional = FALSE;
  op1.reloc.type = BFD_RELOC_NONE;
  op2.error = NULL;
  op2.additional = FALSE;
  op2.reloc.type = BFD_RELOC_NONE;

  str = p;
  size = 2;

  switch (op->type)
    {
    case PDP11_OPCODE_NO_OPS:
      str = skip_whitespace (str);
      if (*str == 0)
	str = "";
      break;

    case PDP11_OPCODE_IMM3:
    case PDP11_OPCODE_IMM6:
    case PDP11_OPCODE_IMM8:
      str = skip_whitespace (str);
      if (*str == '#' || *str == '$')
	str++;
      str = parse_expression (str, &op1);
      if (op1.error)
	break;
      if (op1.reloc.exp.X_op != O_constant || op1.reloc.type != BFD_RELOC_NONE)
	{
	  op1.error = _("operand is not an absolute constant");
	  break;
	}
      switch (op->type)
	{
	case PDP11_OPCODE_IMM3:
	  if (op1.reloc.exp.X_add_number & ~7)
	    {
	      op1.error = _("3-bit immediate out of range");
	      break;
	    }
	  break;
	case PDP11_OPCODE_IMM6:
	  if (op1.reloc.exp.X_add_number & ~0x3f)
	    {
	      op1.error = _("6-bit immediate out of range");
	      break;
	    }
	  break;
	case PDP11_OPCODE_IMM8:
	  if (op1.reloc.exp.X_add_number & ~0xff)
	    {
	      op1.error = _("8-bit immediate out of range");
	      break;
	    }
	  break;
	}
      insn.code |= op1.reloc.exp.X_add_number;
      break;

    case PDP11_OPCODE_DISPL:
      {
	char *new_pointer;
	new_pointer = parse_expression (str, &op1);
	op1.code = 0;
	op1.reloc.pc_rel = 1;
	op1.reloc.type = BFD_RELOC_PDP11_DISP_8_PCREL;
	if (op1.reloc.exp.X_op != O_symbol)
	  {
	    op1.error = _("Symbol expected");
	    break;
	  }
	if (op1.code & ~0xff)
	  {
	    err = _("8-bit displacement out of range");
	    break;
	  }
	str = new_pointer;
	insn.code |= op1.code;
	insn.reloc = op1.reloc;
      }
      break;

    case PDP11_OPCODE_REG:
      str = parse_reg (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      break;

    case PDP11_OPCODE_OP:
      str = parse_op (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      if (op1.additional)
	size += 2;
      break;

    case PDP11_OPCODE_FOP:
      str = parse_fop (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      if (op1.additional)
	size += 2;
      break;

    case PDP11_OPCODE_REG_OP:
      str = parse_reg (str, &op2);
      if (op2.error)
	break;
      insn.code |= op2.code << 6;
      str = parse_separator (str, &error);
      if (error)
	{
	  op2.error = _("Missing ','");
	  break;
	}
      str = parse_op (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      if (op1.additional)
	size += 2;
      break;

    case PDP11_OPCODE_REG_OP_REV:
      str = parse_op (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      if (op1.additional)
	size += 2;
      str = parse_separator (str, &error);
      if (error)
	{
	  op2.error = _("Missing ','");
	  break;
	}
      str = parse_reg (str, &op2);
      if (op2.error)
	break;
      insn.code |= op2.code << 6;
      break;

    case PDP11_OPCODE_AC_FOP:
      str = parse_ac (str, &op2);
      if (op2.error)
	break;
      insn.code |= op2.code << 6;
      str = parse_separator (str, &error);
      if (error)
	{
	  op1.error = _("Missing ','");
	  break;
	}
      str = parse_fop (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      if (op1.additional)
	size += 2;
      break;

    case PDP11_OPCODE_FOP_AC:
      str = parse_fop (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      if (op1.additional)
	size += 2;
      str = parse_separator (str, &error);
      if (error)
	{
	  op1.error = _("Missing ','");
	  break;
	}
      str = parse_ac (str, &op2);
      if (op2.error)
	break;
      insn.code |= op2.code << 6;
      break;

    case PDP11_OPCODE_AC_OP:
      str = parse_ac (str, &op2);
      if (op2.error)
	break;
      insn.code |= op2.code << 6;
      str = parse_separator (str, &error);
      if (error)
	{
	  op1.error = _("Missing ','");
	  break;
	}
      str = parse_op (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      if (op1.additional)
	size += 2;
      break;

    case PDP11_OPCODE_OP_AC:
      str = parse_op (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code;
      if (op1.additional)
	size += 2;
      str = parse_separator (str, &error);
      if (error)
	{
	  op1.error = _("Missing ','");
	  break;
	}
      str = parse_ac (str, &op2);
      if (op2.error)
	break;
      insn.code |= op2.code << 6;
      break;

    case PDP11_OPCODE_OP_OP:
      str = parse_op (str, &op1);
      if (op1.error)
	break;
      insn.code |= op1.code << 6;
      if (op1.additional)
	size += 2;
      str = parse_separator (str, &error);
      if (error)
	{
	  op2.error = _("Missing ','");
	  break;
	}
      str = parse_op (str, &op2);
      if (op2.error)
	break;
      insn.code |= op2.code;
      if (op2.additional)
	size += 2;
      break;

    case PDP11_OPCODE_REG_DISPL:
      {
	char *new_pointer;
	str = parse_reg (str, &op2);
	if (op2.error)
	  break;
	insn.code |= op2.code << 6;
	str = parse_separator (str, &error);
	if (error)
	  {
	    op1.error = _("Missing ','");
	    break;
	  }
	new_pointer = parse_expression (str, &op1);
	op1.code = 0;
	op1.reloc.pc_rel = 1;
	op1.reloc.type = BFD_RELOC_PDP11_DISP_6_PCREL;
	if (op1.reloc.exp.X_op != O_symbol)
	  {
	    op1.error = _("Symbol expected");
	    break;
	  }
	if (op1.code & ~0x3f)
	  {
	    err = _("6-bit displacement out of range");
	    break;
	  }
	str = new_pointer;
	insn.code |= op1.code;
	insn.reloc = op1.reloc;
      }
      break;

    default:
      BAD_CASE (op->type);
    }

  if (op1.error)
    err = op1.error;
  else if (op2.error)
    err = op2.error;
  else
    {
      str = skip_whitespace (str);
      if (*str)
	err = _("Too many operands");
    }

  {
    char *to = NULL;

    if (err)
      {
	as_bad ("%s", err);
	return;
      }

    to = frag_more (size);

    md_number_to_chars (to, insn.code, 2);
    if (insn.reloc.type != BFD_RELOC_NONE)
      fix_new_exp (frag_now, to - frag_now->fr_literal, 2,
		   &insn.reloc.exp, insn.reloc.pc_rel, insn.reloc.type);
    to += 2;

    if (op1.additional)
      {
	md_number_to_chars (to, op1.word, 2);
	if (op1.reloc.type != BFD_RELOC_NONE)
	  fix_new_exp (frag_now, to - frag_now->fr_literal, 2,
		       &op1.reloc.exp, op1.reloc.pc_rel, op1.reloc.type);
	to += 2;
      }

    if (op2.additional)
      {
	md_number_to_chars (to, op2.word, 2);
	if (op2.reloc.type != BFD_RELOC_NONE)
	  fix_new_exp (frag_now, to - frag_now->fr_literal, 2,
		       &op2.reloc.exp, op2.reloc.pc_rel, op2.reloc.type);
      }
  }
}

int
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
			       segT segment ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_convert_frag (bfd *headers ATTRIBUTE_UNUSED,
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
}

int md_short_jump_size = 2;
int md_long_jump_size = 4;

void
md_create_short_jump (char *ptr ATTRIBUTE_UNUSED,
		      addressT from_addr ATTRIBUTE_UNUSED,
		      addressT to_addr ATTRIBUTE_UNUSED,
		      fragS *frag ATTRIBUTE_UNUSED,
		      symbolS *to_symbol ATTRIBUTE_UNUSED)
{
}

void
md_create_long_jump (char *ptr ATTRIBUTE_UNUSED,
		     addressT from_addr ATTRIBUTE_UNUSED,
		     addressT to_addr ATTRIBUTE_UNUSED,
		     fragS *frag ATTRIBUTE_UNUSED,
		     symbolS *to_symbol ATTRIBUTE_UNUSED)
{
}

static int
set_cpu_model (char *arg)
{
  char buf[4];
  char *model = buf;

  if (arg[0] == 'k')
    arg++;

  *model++ = *arg++;

  if (strchr ("abdx", model[-1]) == NULL)
    return 0;

  if (model[-1] == 'd')
    {
      if (arg[0] == 'f' || arg[0] == 'j')
	model[-1] = *arg++;
    }
  else if (model[-1] == 'x')
    {
      if (arg[0] == 't')
	model[-1] = *arg++;
    }

  if (arg[0] == '-')
    arg++;

  if (strncmp (arg, "11", 2) != 0)
    return 0;
  arg += 2;

  if (arg[0] == '-')
    {
      if (*++arg == 0)
	return 0;
    }

  /* Allow up to two revision letters.  */
  if (arg[0] != 0)
    *model++ = *arg++;
  if (arg[0] != 0)
    *model++ = *arg++;

  *model++ = 0;

  set_option ("no-extensions");

  /* KA11 (11/15/20).  */
  if (strncmp (buf, "a", 1) == 0)
    return 1; /* No extensions.  */

  /* KB11 (11/45/50/55/70).  */
  else if (strncmp (buf, "b", 1) == 0)
    return set_option ("eis") && set_option ("spl");

  /* KD11-A (11/35/40).  */
  else if (strncmp (buf, "da", 2) == 0)
    return set_option ("limited-eis");

  /* KD11-B (11/05/10).  */
  else if (strncmp (buf, "db", 2) == 0
	   /* KD11-D (11/04).  */
	   || strncmp (buf, "dd", 2) == 0)
    return 1; /* no extensions */

  /* KD11-E (11/34).  */
  else if (strncmp (buf, "de", 2) == 0)
    return set_option ("eis") && set_option ("mxps");

  /* KD11-F (11/03).  */
  else if (strncmp (buf, "df", 2) == 0
	   /* KD11-H (11/03).  */
	   || strncmp (buf, "dh", 2) == 0
	   /* KD11-Q (11/03).  */
	   || strncmp (buf, "dq", 2) == 0)
    return set_option ("limited-eis") && set_option ("mxps");

  /* KD11-K (11/60).  */
  else if (strncmp (buf, "dk", 2) == 0)
    return set_option ("eis")
      && set_option ("mxps")
      && set_option ("ucode");

  /* KD11-Z (11/44).  */
  else if (strncmp (buf, "dz", 2) == 0)
    return set_option ("csm")
      && set_option ("eis")
      && set_option ("mfpt")
      && set_option ("mxps")
      && set_option ("spl");

  /* F11 (11/23/24).  */
  else if (strncmp (buf, "f", 1) == 0)
    return set_option ("eis")
      && set_option ("mfpt")
      && set_option ("mxps");

  /* J11 (11/53/73/83/84/93/94).  */
  else if (strncmp (buf, "j", 1) == 0)
    return set_option ("csm")
      && set_option ("eis")
      && set_option ("mfpt")
      && set_option ("multiproc")
      && set_option ("mxps")
      && set_option ("spl");

  /* T11 (11/21).  */
  else if (strncmp (buf, "t", 1) == 0)
    return set_option ("limited-eis")
      && set_option ("mxps");

  else
    return 0;
}

static int
set_machine_model (char *arg)
{
  if (strncmp (arg, "pdp-11/", 7) != 0
      && strncmp (arg, "pdp11/", 6) != 0
      && strncmp (arg, "11/", 3) != 0)
    return 0;

  if (strncmp (arg, "pdp", 3) == 0)
    arg += 3;
  if (arg[0] == '-')
    arg++;
  if (strncmp (arg, "11/", 3) == 0)
    arg += 3;

  if (strcmp (arg, "03") == 0)
    return set_cpu_model ("kd11f");

  else if (strcmp (arg, "04") == 0)
    return set_cpu_model ("kd11d");

  else if (strcmp (arg, "05") == 0
	   || strcmp (arg, "10") == 0)
    return set_cpu_model ("kd11b");

  else if (strcmp (arg, "15") == 0
	   || strcmp (arg, "20") == 0)
    return set_cpu_model ("ka11");

  else if (strcmp (arg, "21") == 0)
    return set_cpu_model ("t11");

  else if (strcmp (arg, "23") == 0
	   || strcmp (arg, "24") == 0)
    return set_cpu_model ("f11");

  else if (strcmp (arg, "34") == 0
	   || strcmp (arg, "34a") == 0)
    return set_cpu_model ("kd11e");

  else if (strcmp (arg, "35") == 0
	   || strcmp (arg, "40") == 0)
    return set_cpu_model ("kd11da");

  else if (strcmp (arg, "44") == 0)
    return set_cpu_model ("kd11dz");

  else if (strcmp (arg, "45") == 0
	   || strcmp (arg, "50") == 0
	   || strcmp (arg, "55") == 0
	   || strcmp (arg, "70") == 0)
    return set_cpu_model ("kb11");

  else if (strcmp (arg, "60") == 0)
    return set_cpu_model ("kd11k");

  else if (strcmp (arg, "53") == 0
	   || strcmp (arg, "73") == 0
	   || strcmp (arg, "83") == 0
	   || strcmp (arg, "84") == 0
	   || strcmp (arg, "93") == 0
	   || strcmp (arg, "94") == 0)
    return set_cpu_model ("j11")
      && set_option ("fpp");

  else
    return 0;
}

const char *md_shortopts = "m:";

struct option md_longopts[] =
{
#define OPTION_CPU 257
  { "cpu", required_argument, NULL, OPTION_CPU },
#define OPTION_MACHINE 258
  { "machine", required_argument, NULL, OPTION_MACHINE },
#define OPTION_PIC 259
  { "pic", no_argument, NULL, OPTION_PIC },
  { NULL, no_argument, NULL, 0 }
};

size_t md_longopts_size = sizeof (md_longopts);

/* Invocation line includes a switch not recognized by the base assembler.
   See if it's a processor-specific option.  */

int
md_parse_option (int c, char *arg)
{
  init_defaults ();

  switch (c)
    {
    case 'm':
      if (set_option (arg))
	return 1;
      if (set_cpu_model (arg))
	return 1;
      if (set_machine_model (arg))
	return 1;
      break;

    case OPTION_CPU:
      if (set_cpu_model (arg))
	return 1;
      break;

    case OPTION_MACHINE:
      if (set_machine_model (arg))
	return 1;
      break;

    case OPTION_PIC:
      if (set_option ("pic"))
	return 1;
      break;

    default:
      break;
    }

  return 0;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, "\
\n\
PDP-11 instruction set extentions:\n\
\n\
-m(no-)cis		allow (disallow) commersial instruction set\n\
-m(no-)csm		allow (disallow) CSM instruction\n\
-m(no-)eis		allow (disallow) full extended instruction set\n\
-m(no-)fis		allow (disallow) KEV11 floating-point instructions\n\
-m(no-)fpp		allow (disallow) FP-11 floating-point instructions\n\
-m(no-)fpu		allow (disallow) FP-11 floating-point instructions\n\
-m(no-)limited-eis	allow (disallow) limited extended instruction set\n\
-m(no-)mfpt		allow (disallow) processor type instruction\n\
-m(no-)multiproc	allow (disallow) multiprocessor instructions\n\
-m(no-)mxps		allow (disallow) processor status instructions\n\
-m(no-)spl		allow (disallow) SPL instruction\n\
-m(no-)ucode		allow (disallow) microcode instructions\n\
-mall-extensions	allow all instruction set extensions\n\
			(this is the default)\n\
-mno-extentions		disallow all instruction set extensions\n\
-pic			generate position-indepenent code\n\
\n\
PDP-11 CPU model options:\n\
\n\
-mka11*			KA11 CPU.  base line instruction set only\n\
-mkb11*			KB11 CPU.  enable full EIS and SPL\n\
-mkd11a*		KD11-A CPU.  enable limited EIS\n\
-mkd11b*		KD11-B CPU.  base line instruction set only\n\
-mkd11d*		KD11-D CPU.  base line instruction set only\n\
-mkd11e*		KD11-E CPU.  enable full EIS, MTPS, and MFPS\n\
-mkd11f*		KD11-F CPU.  enable limited EIS, MTPS, and MFPS\n\
-mkd11h*		KD11-H CPU.  enable limited EIS, MTPS, and MFPS\n\
-mkd11q*		KD11-Q CPU.  enable limited EIS, MTPS, and MFPS\n\
-mkd11k*		KD11-K CPU.  enable full EIS, MTPS, MFPS, LDUB, MED,\n\
			XFC, and MFPT\n\
-mkd11z*		KD11-Z CPU.  enable full EIS, MTPS, MFPS, MFPT, SPL,\n\
			and CSM\n\
-mf11*			F11 CPU.  enable full EIS, MFPS, MTPS, and MFPT\n\
-mj11*			J11 CPU.  enable full EIS, MTPS, MFPS, MFPT, SPL,\n\
			CSM, TSTSET, and WRTLCK\n\
-mt11*			T11 CPU.  enable limited EIS, MTPS, and MFPS\n\
\n\
PDP-11 machine model options:\n\
\n\
-m11/03			same as -mkd11f\n\
-m11/04			same as -mkd11d\n\
-m11/05			same as -mkd11b\n\
-m11/10			same as -mkd11b\n\
-m11/15			same as -mka11\n\
-m11/20			same as -mka11\n\
-m11/21			same as -mt11\n\
-m11/23			same as -mf11\n\
-m11/24			same as -mf11\n\
-m11/34			same as -mkd11e\n\
-m11/34a		same as -mkd11e -mfpp\n\
-m11/35			same as -mkd11a\n\
-m11/40			same as -mkd11a\n\
-m11/44			same as -mkd11z\n\
-m11/45			same as -mkb11\n\
-m11/50			same as -mkb11\n\
-m11/53			same as -mj11\n\
-m11/55			same as -mkb11\n\
-m11/60			same as -mkd11k\n\
-m11/70			same as -mkb11\n\
-m11/73			same as -mj11\n\
-m11/83			same as -mj11\n\
-m11/84			same as -mj11\n\
-m11/93			same as -mj11\n\
-m11/94			same as -mj11\n\
");
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED,
		  valueT size)
{
  return (size + 1) & ~1;
}

long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_frag->fr_address + fixP->fx_where + fixP->fx_size;
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,
	      fixS *fixp)
{
  arelent *reloc;
  bfd_reloc_code_real_type code;

  reloc = xmalloc (sizeof (* reloc));

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* This is taken account for in md_apply_fix().  */
  reloc->addend = -symbol_get_bfdsym (fixp->fx_addsy)->section->vma;

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_16:
      if (fixp->fx_pcrel)
	code = BFD_RELOC_16_PCREL;
      else
	code = BFD_RELOC_16;
      break;

    case BFD_RELOC_16_PCREL:
      code = BFD_RELOC_16_PCREL;
      break;

    default:
      BAD_CASE (fixp->fx_r_type);
      return NULL;
    }

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Can not represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }

  return reloc;
}

void
pseudo_bss (int c ATTRIBUTE_UNUSED)
{
  int temp;

  temp = get_absolute_expression ();
  subseg_set (bss_section, temp);
  demand_empty_rest_of_line ();
}

void
pseudo_even (int c ATTRIBUTE_UNUSED)
{
  int alignment = 1; /* 2^1 */
  frag_align (alignment, 0, 1);
  record_alignment (now_seg, alignment);
}

char *
md_atof (int type, char * litP, int * sizeP)
{
  return vax_md_atof (type, litP, sizeP);
}
@


1.23
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@a503 2
	char *old = str;

a527 5
	    if (operand->reloc.exp.X_op != O_symbol)
	      {
		operand->error = _("Label expected");
		return old;
	      }
@


1.22
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d755 2
a756 2
	char *new;
	new = parse_expression (str, &op1);
d770 1
a770 1
	str = new;
d938 1
a938 1
	char *new;
d949 1
a949 1
	new = parse_expression (str, &op1);
d963 1
a963 1
	str = new;
@


1.21
log
@        PR 9779
        * config/tc-pdp11.c (parse_op_no_deferred): Fix handling of
        indexed addressing for symbolic expressions.
@
text
@d194 1
a194 1
    as_fatal ("Virtual memory exhausted");
d339 1
a339 1
	  operand->error = "Bad register name";
d357 1
a357 1
      operand->error = "Bad register name";
d382 1
a382 1
	  operand->error = "Bad register name";
d388 1
a388 1
      operand->error = "Bad register name";
d401 1
a401 1
	  operand->error = "Bad register name";
d420 1
a420 1
      operand->error = "Error in expression";
d448 1
a448 1
	  operand->error = "Missing ')'";
d484 1
a484 1
              operand->error = "Error in expression";
d495 1
a495 1
	  operand->error = "Error in expression";
d514 1
a514 1
		operand->error = "Missing ')'";
d532 1
a532 1
		operand->error = "Label expected";
d553 1
a553 1
	    operand->error = "Missing ')'";
d618 1
a618 1
      operand->error = "Float AC not legal as integer operand";
d638 1
a638 1
      operand->error = "General register not legal as float operand";
d671 1
a671 1
      as_bad ("No instruction found");
d687 1
a687 1
      as_warn ("Unsupported instruction set extension: %s", op->name);
d723 1
a723 1
	  op1.error = "operand is not an absolute constant";
d731 1
a731 1
	      op1.error = "3-bit immediate out of range";
d738 1
a738 1
	      op1.error = "6-bit immediate out of range";
d745 1
a745 1
	      op1.error = "8-bit immediate out of range";
d762 1
a762 1
	    op1.error = "Symbol expected";
d767 1
a767 1
	    err = "8-bit displacement out of range";
d809 1
a809 1
	  op2.error = "Missing ','";
d830 1
a830 1
	  op2.error = "Missing ','";
d847 1
a847 1
	  op1.error = "Missing ','";
d868 1
a868 1
	  op1.error = "Missing ','";
d885 1
a885 1
	  op1.error = "Missing ','";
d906 1
a906 1
	  op1.error = "Missing ','";
d925 1
a925 1
	  op2.error = "Missing ','";
d946 1
a946 1
	    op1.error = "Missing ','";
d955 1
a955 1
	    op1.error = "Symbol expected";
d960 1
a960 1
	    err = "6-bit displacement out of range";
d981 1
a981 1
	err = "Too many operands";
d989 1
a989 1
	as_bad (err);
d1431 1
a1431 1
		    "Can not represent %s relocation in this object file format",
@


1.20
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2 2
a3 1
   Copyright 2001, 2002, 2004, 2005, 2007 Free Software Foundation, Inc.
d19 2
a20 1
   the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d563 2
a564 2
	    operand->word = 0;
	    operand->reloc.pc_rel = 1;
@


1.19
log
@Switch to GPLv3
@
text
@d1454 6
@


1.18
log
@Fix compile time warnings from a GCC 4.0 compiler
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
d8 1
a8 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.17
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d246 1
a246 1
  code = md_chars_to_number (buf, size);
@


1.16
log
@Update the address and phone number of the FSF
@
text
@d233 1
a233 1
md_apply_fix3 (fixS *fixP,
d1403 1
a1403 1
  /* This is taken account for in md_apply_fix3().  */
@


1.15
log
@Convert to ISO C90 formatting
@
text
@d18 1
a18 1
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.14
log
@update copyright dates
@
text
@a19 8
/*
  Apparently unused functions:
    md_convert_frag
    md_estimate_size_before_relax
    md_create_short_jump
    md_create_long_jump
*/

d24 1
a24 6
static int set_option PARAMS ((char *arg));
static int set_cpu_model PARAMS ((char *arg));
static int set_machine_model PARAMS ((char *arg));

extern int flonum_gen2vax PARAMS ((char format_letter, FLONUM_TYPE * f,
                                   LITTLENUM_TYPE * words));
d26 1
a26 1
#define TRUE 1
d29 1
a29 3
/*
 * A representation for PDP-11 machine code.
 */
d34 2
a35 2
  int additional;	/* is there an additional word? */
  int word;		/* additional word, if any */
d44 4
a47 6
/*
 * Instruction set extensions.
 *
 * If you change this from an array to something else, please update
 * the "PDP-11 instruction set extensions" comment in pdp11.h.
 */
d50 1
a50 3
/*
 * Assembly options.
 */
d58 1
a58 1
   another comment */
d66 1
a66 1
/* Chars that can be used to separate mant from exp in floating point nums */
d69 3
a71 3
/* Chars that mean this number is a floating point constant */
/* as in 0f123.456 */
/* or    0H1.234E-12 (see exp chars above) */
d84 86
d171 1
a171 1
init_defaults ()
a182 2
static struct hash_control *insn_hash = NULL;

d184 1
a184 1
md_begin ()
d195 1
a195 1
    hash_insert (insn_hash, pdp11_opcodes[i].name, (PTR)(pdp11_opcodes + i));
d197 1
a197 1
    hash_insert (insn_hash, pdp11_aliases[i].name, (PTR)(pdp11_aliases + i));
d201 1
a201 4
md_number_to_chars (con, value, nbytes)
     char con[];
     valueT value;
     int nbytes;
d204 2
a205 3
   * 0x12345678 is stored as "\x56\x78\x12\x34". It's
   * anyones guess what 0x123456 would be stored like.
   */
d215 1
a215 1
      con[0] =  value       & 0xff;
d221 1
a221 1
      con[2] =  value       & 0xff;
d233 3
a235 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d286 2
a287 4
   * 0x12345678 is stored as "\x56\x78\x12\x34". It's
   * anyones guess what 0x123456 would be stored like.
   */

d298 2
a299 2
	(((con[1] << BITS_PER_CHAR) | con[0]) << (2 * BITS_PER_CHAR)) |
	 ((con[3] << BITS_PER_CHAR) | con[2]);
d341 2
a342 2
  else if (strncmp (str, "sp", 2) == 0 ||
	   strncmp (str, "SP", 2) == 0)
d347 2
a348 2
  else if (strncmp (str, "pc", 2) == 0 ||
	   strncmp (str, "PC", 2) == 0)
d366 4
a369 4
  if (strncmp (str, "fr", 2) == 0 ||
      strncmp (str, "FR", 2) == 0 ||
      strncmp (str, "ac", 2) == 0 ||
      strncmp (str, "AC", 2) == 0)
d461 2
a462 1
    case '#':				/* immediate */
d485 1
a485 1
          /* it's a floating literal...  */
d499 2
a500 1
    default:				/* label, d(rn), -(rn) */
d526 1
a526 1
	if (*str != '(')		/* label */
d541 2
a542 1
	str++;				/* d(rn) */
d571 2
a572 3
	      {
		operand->word = operand->reloc.exp.X_add_number;
	      }
d654 1
a654 2
md_assemble (instruction_string)
     char *instruction_string;
d1019 2
a1020 3
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP ATTRIBUTE_UNUSED;
     segT segment ATTRIBUTE_UNUSED;
d1026 3
a1028 4
md_convert_frag (headers, seg, fragP)
     bfd *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d1036 5
a1040 6
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr ATTRIBUTE_UNUSED;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d1045 5
a1049 6
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr ATTRIBUTE_UNUSED;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d1054 1
a1054 72
set_option (arg)
     char *arg;
{
  int yes = 1;

  if (strcmp (arg, "all-extensions") == 0 ||
      strcmp (arg, "all") == 0)
    {
      memset (pdp11_extension, ~0, sizeof pdp11_extension);
      pdp11_extension[PDP11_NONE] = 0;
      return 1;
    }
  else if (strcmp (arg, "no-extensions") == 0)
    {
      memset (pdp11_extension, 0, sizeof pdp11_extension);
      pdp11_extension[PDP11_BASIC] = 1;
      return 1;
    }

  if (strncmp (arg, "no-", 3) == 0)
    {
      yes = 0;
      arg += 3;
    }

  if (strcmp (arg, "cis") == 0)			/* commersial instructions */
    pdp11_extension[PDP11_CIS] = yes;
  else if (strcmp (arg, "csm") == 0)		/* call supervisor mode */
    pdp11_extension[PDP11_CSM] = yes;
  else if (strcmp (arg, "eis") == 0)		/* extended instruction set */
    pdp11_extension[PDP11_EIS] = pdp11_extension[PDP11_LEIS] = yes;
  else if (strcmp (arg, "fis") == 0 ||		/* KEV11 floating-point */
	   strcmp (arg, "kev11") == 0 ||
	   strcmp (arg, "kev-11") == 0)
    pdp11_extension[PDP11_FIS] = yes;
  else if (strcmp (arg, "fpp") == 0 ||		/* FP-11 floating-point */
	   strcmp (arg, "fpu") == 0 ||
	   strcmp (arg, "fp11") == 0 ||
	   strcmp (arg, "fp-11") == 0 ||
	   strcmp (arg, "fpj11") == 0 ||
	   strcmp (arg, "fp-j11") == 0 ||
	   strcmp (arg, "fpj-11") == 0)
    pdp11_extension[PDP11_FPP] = yes;
  else if (strcmp (arg, "limited-eis") == 0)	/* limited extended insns */
    {
      pdp11_extension[PDP11_LEIS] = yes;
      if (!pdp11_extension[PDP11_LEIS])
	pdp11_extension[PDP11_EIS] = 0;
    }
  else if (strcmp (arg, "mfpt") == 0)		/* move from processor type */
    pdp11_extension[PDP11_MFPT] = yes;
  else if (strncmp (arg, "mproc", 5) == 0 ||	/* multiprocessor insns: */
	   strncmp (arg, "multiproc", 9) == 0 )	/* TSTSET, WRTLCK */
    pdp11_extension[PDP11_MPROC] = yes;
  else if (strcmp (arg, "mxps") == 0)		/* move from/to proc status */
    pdp11_extension[PDP11_MXPS] = yes;
  else if (strcmp (arg, "pic") == 0)		/* position-independent code */
    asm_option[ASM_OPT_PIC] = yes;
  else if (strcmp (arg, "spl") == 0)		/* set priority level */
    pdp11_extension[PDP11_SPL] = yes;
  else if (strcmp (arg, "ucode") == 0 ||	/* microcode instructions: */
	   strcmp (arg, "microcode") == 0)	/* LDUB, MED, XFC */
    pdp11_extension[PDP11_UCODE] = yes;
  else
    return 0;

  return 1;
}

static int
set_cpu_model (arg)
     char *arg;
d1069 1
a1069 2
      if (arg[0] == 'f' ||
	  arg[0] == 'j')
d1091 1
a1091 1
  /* allow up to two revision letters */
d1101 7
a1107 6
  if (strncmp (buf, "a", 1) == 0)		/* KA11 (11/15/20) */
    return 1; /* no extensions */

  else if (strncmp (buf, "b", 1) == 0)		/* KB11 (11/45/50/55/70) */
    return set_option ("eis") &&
           set_option ("spl");
d1109 2
a1110 1
  else if (strncmp (buf, "da", 2) == 0)		/* KD11-A (11/35/40) */
d1113 4
a1116 2
  else if (strncmp (buf, "db", 2) == 0 ||	/* KD11-B (11/05/10) */
	   strncmp (buf, "dd", 2) == 0)		/* KD11-D (11/04) */
d1119 45
a1163 38
  else if (strncmp (buf, "de", 2) == 0)		/* KD11-E (11/34) */
    return set_option ("eis") &&
           set_option ("mxps");

  else if (strncmp (buf, "df", 2) == 0 ||	/* KD11-F (11/03) */
	   strncmp (buf, "dh", 2) == 0 ||	/* KD11-H (11/03) */
	   strncmp (buf, "dq", 2) == 0)		/* KD11-Q (11/03) */
    return set_option ("limited-eis") &&
           set_option ("mxps");

  else if (strncmp (buf, "dk", 2) == 0)		/* KD11-K (11/60) */
    return set_option ("eis") &&
           set_option ("mxps") &&
           set_option ("ucode");

  else if (strncmp (buf, "dz", 2) == 0)		/* KD11-Z (11/44) */
    return set_option ("csm") &&
           set_option ("eis") &&
           set_option ("mfpt") &&
           set_option ("mxps") &&
           set_option ("spl");

  else if (strncmp (buf, "f", 1) == 0)		/* F11 (11/23/24) */
    return set_option ("eis") &&
           set_option ("mfpt") &&
           set_option ("mxps");

  else if (strncmp (buf, "j", 1) == 0)		/* J11 (11/53/73/83/84/93/94)*/
    return set_option ("csm") &&
           set_option ("eis") &&
           set_option ("mfpt") &&
           set_option ("multiproc") &&
           set_option ("mxps") &&
           set_option ("spl");

  else if (strncmp (buf, "t", 1) == 0)		/* T11 (11/21) */
    return set_option ("limited-eis") &&
           set_option ("mxps");
d1170 1
a1170 2
set_machine_model (arg)
     char *arg;
d1172 3
a1174 3
  if (strncmp (arg, "pdp-11/", 7) != 0 &&
      strncmp (arg, "pdp11/", 6) != 0 &&
      strncmp (arg, "11/", 3) != 0)
d1184 2
a1185 2
  if (strcmp (arg, "03") == 0)			/* 11/03 */
    return set_cpu_model ("kd11f");		/* KD11-F */
d1187 46
a1232 2
  else if (strcmp (arg, "04") == 0)		/* 11/04 */
    return set_cpu_model ("kd11d");		/* KD11-D */
a1233 44
  else if (strcmp (arg, "05") == 0 ||		/* 11/05 or 11/10 */
	   strcmp (arg, "10") == 0)
    return set_cpu_model ("kd11b");		/* KD11-B */

  else if (strcmp (arg, "15") == 0 ||		/* 11/15 or 11/20 */
	   strcmp (arg, "20") == 0)
    return set_cpu_model ("ka11");		/* KA11 */

  else if (strcmp (arg, "21") == 0)		/* 11/21 */
    return set_cpu_model ("t11");		/* T11 */

  else if (strcmp (arg, "23") == 0 ||		/* 11/23 or 11/24 */
	   strcmp (arg, "24") == 0)
    return set_cpu_model ("f11");		/* F11 */

  else if (strcmp (arg, "34") == 0 ||		/* 11/34 or 11/34a */
           strcmp (arg, "34a") == 0)
    return set_cpu_model ("kd11e");		/* KD11-E */

  else if (strcmp (arg, "35") == 0 ||		/* 11/35 or 11/40 */
	   strcmp (arg, "40") == 0)
    return set_cpu_model ("kd11da");		/* KD11-A */

  else if (strcmp (arg, "44") == 0)		/* 11/44 */
    return set_cpu_model ("kd11dz");		/* KD11-Z */

  else if (strcmp (arg, "45") == 0 ||		/* 11/45/50/55/70 */
	   strcmp (arg, "50") == 0 ||
	   strcmp (arg, "55") == 0 ||
	   strcmp (arg, "70") == 0)
    return set_cpu_model ("kb11");		/* KB11 */

  else if (strcmp (arg, "60") == 0)		/* 11/60 */
    return set_cpu_model ("kd11k");		/* KD11-K */ /* FPP? */

  else if (strcmp (arg, "53") == 0 ||		/* 11/53/73/83/84/93/94 */
	   strcmp (arg, "73") == 0 ||
	   strcmp (arg, "83") == 0 ||
	   strcmp (arg, "84") == 0 ||
	   strcmp (arg, "93") == 0 ||
	   strcmp (arg, "94") == 0)
    return set_cpu_model ("j11") &&		/* J11 */
           set_option ("fpp");			/* All J11 machines come */
						/* with FPP installed.  */
d1253 2
a1254 5
/*
 * md_parse_option
 *	Invocation line includes a switch not recognized by the base assembler.
 *	See if it's a processor-specific option.
 */
d1257 1
a1257 3
md_parse_option (c, arg)
     int c;
     char *arg;
a1293 219
/*
One possible way of parsing options.

enum
{
  OPTION_CSM,
  OPTION_CIS,
  ...
};

struct
{
  const char *pattern;
  int opt;
  const char *description;
} options;

static struct options extension_opts[] =
{
  { "Ncsm", OPTION_CSM,
			"allow (disallow) CSM instruction" },
  { "Ncis", OPTION_CIS,
			"allow (disallow) commersial instruction set" },
  { "Neis", OPTION_EIS,
			"allow (disallow) extended instruction set" },
  ...
  { "all-extensions", OPTION_ALL_EXTENSIONS,
			"allow all instruction set extensions\n\
			(this is the default)" },
  { "no-extensions", OPTION_NO_EXTENSIONS,
			"disallow all instruction set extensions" },
  { "pic", OPTION_PIC,
			"position-independent code" },
};

static struct options cpu_opts[] =
{
  { "Ka_11_*", OPTION_KA11, "KA11 CPU. ..." },
  { "Kb_11_*", OPTION_KB11, "KB11 CPU. ..." },
  { "Kd_11_a*", OPTION_KD11A, "KD11-A CPU. ..." },
  { "Kd_11_b*", OPTION_KD11B, "KD11-B CPU. ..." },
  { "Kd_11_d*", OPTION_KD11D, "KD11-D CPU. ..." },
  { "Kd_11_e*", OPTION_KD11E, "KD11-E CPU. ..." },
  { "Kd_11_f*", OPTION_KD11F, "KD11-F CPU. ..." },
  { "Kd_11_h*", OPTION_KD11H, "KD11-H CPU. ..." },
  { "Kd_11_q*", OPTION_KD11Q, "KD11-Q CPU. ..." },
  { "Kd_11_z*", OPTION_KD11Z, "KD11-Z CPU. ..." },
  { "Df_11_*", OPTION_F11, "F11 CPU. ..." },
  { "Dj_11_*", OPTION_J11, "J11 CPU. ..." },
  { "Dt_11_*", OPTION_T11, "T11 CPU. ..." },
};

static struct options model_opts[] =
{
  { "P03", OPTION_PDP11_03, "same as ..." },
  { "P04", OPTION_PDP11_04, "same as ..." },
  { "P05", OPTION_PDP11_05, "same as ..." },
  { "P10", OPTION_PDP11_10, "same as ..." },
  { "P15", OPTION_PDP11_15, "same as ..." },
  { "P20", OPTION_PDP11_20, "same as ..." },
  { "P21", OPTION_PDP11_21, "same as ..." },
  { "P24", OPTION_PDP11_24, "same as ..." },
  { "P34", OPTION_PDP11_34, "same as ..." },
  { "P34a", OPTION_PDP11_34A, "same as ..." },
  { "P40", OPTION_PDP11_40, "same as ..." },
  { "P44", OPTION_PDP11_44, "same as ..." },
  { "P45", OPTION_PDP11_45, "same as ..." },
  { "P50", OPTION_PDP11_50, "same as ..." },
  { "P53", OPTION_PDP11_53, "same as ..." },
  { "P55", OPTION_PDP11_55, "same as ..." },
  { "P60", OPTION_PDP11_60, "same as ..." },
  { "P70", OPTION_PDP11_70, "same as ..." },
  { "P73", OPTION_PDP11_73, "same as ..." },
  { "P83", OPTION_PDP11_83, "same as ..." },
  { "P84", OPTION_PDP11_84, "same as ..." },
  { "P93", OPTION_PDP11_93, "same as ..." },
  { "P94", OPTION_PDP11_94, "same as ..." },
};

struct
{
  const char *title;
  struct options *opts;
  int num;
} all_opts[] =
{
  { "PDP-11 instruction set extentions",
    extension_opts,
    sizeof extension_opts / sizeof extension_opts[0] },
  { "PDP-11 CPU model options",
    cpu_opts,
    sizeof cpu_opts / sizeof cpu_opts[0] },
  { "PDP-11 machine model options",
    model_opts,
    sizeof model_opts / sizeof model_opts[0] },
};

int
parse_match (char *arg, char *pattern)
{
  int yes = 1;

  while (*pattern)
    {
      switch (*pattern++)
	{
	case 'N':
	  if (strncmp (arg, "no-") == 0)
	    {
	      yes = 0;
	      arg += 3;
	    }
	  break;

	case 'K':
	  if (arg[0] == 'k')
	    arg++;
	  break;

	case 'D':
	  if (strncmp (arg, "kd", 2) == 0)
	    arg +=2;
	  break;

	case 'P':
	  if (strncmp (arg, "pdp-11/", 7) == 0)
	    arg += 7;
	  else if (strncmp (arg, "pdp11/", 6) == 0)
	    arg += 6;
	  else if (strncmp (arg, "11/", 3) == 0)
	    arg += 3;
	  break;

	case '_':
	  if (arg[0] == "-")
	    {
	      if (*++arg == 0)
		return 0;
	    }
	  break;

	case '*':
	  return 1;

	default:
	  if (*arg++ != pattern[-1])
	    return 0;
	}
    }

  return arg[0] == 0;
}

int
fprint_opt (stream, pattern)
     FILE *stream;
     const char *pattern;
{
  int n;

  while (*pattern)
    {
      switch (*pattern++)
	{
	case 'N':
	  n += fprintf (stream, "(no-)");
	  break;

	case 'K':
	  n += fprintf (stream, "k");
	  break;

	case 'P':
	  n += fprintf (stream "11/");
	  break;

	case 'D':
	case '_':
	case '*':
	  break;

	default:
	  fputc (pattern[-1], stream);
	  n++;
	}
    }

  return n;
}

int
parse_option (char *arg)
{
  int i, j;

  for (i = 0; i < sizeof all_opts / sizeof all_opts[0]; i++)
    {
      for (j = 0; j < all_opts[i].num; j++)
	{
	  if (parse_match (arg, all_opts[i].opts[j].pattern))
	    {
	      set_option (all_opts[i].opts[j].opt);
	      return 1;
	    }
	}
    }

  return 0;
}

static void
fprint_space (stream, n)
     FILE *stream;
     int n;
{
  while (n--)
    fputc (' ', stream);
}

d1295 1
a1295 23
md_show_usage (stream)
     FILE *stream;
{
  int i, j, n;

  for (i = 0; i < sizeof all_opts / sizeof all_opts[0]; i++)
    {
      fprintf (stream "\n%s:\n\n", all_opts[i].title);

      for (j = 0; j < all_opts[i].num; j++)
	{
	  fprintf (stream, "-m");
	  n = fprintf_opt (stream, all_opts[i].opts[j].pattern);
	  fprint_space (stream, 22 - n);
	  fprintf (stream, "%s\n", all_opts[i].opts[j].description);
	}
    }
}
*/

void
md_show_usage (stream)
     FILE *stream;
d1369 1
a1369 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1375 2
a1376 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d1382 1
a1382 2
md_pcrel_from (fixP)
     fixS *fixP;
d1389 1
d1391 2
a1392 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d1397 1
a1397 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d1399 1
a1399 1
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d1438 1
a1438 2
pseudo_bss (c)
     int c ATTRIBUTE_UNUSED;
d1448 1
a1448 2
pseudo_even (c)
     int c ATTRIBUTE_UNUSED;
a1453 2

/* end of tc-pdp11.c */
@


1.13
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2004 Free Software Foundation, Inc.
@


1.12
log
@	* symbols.c (colon) [!WORKING_DOT_WORD]: Don't declare
	md_short_jump_size, md_long_jump_size.
	* write.c [!WORKING_DOT_WORD]: Ditto.
	* tc.h [!WORKING_DOT_WORD]: Declare them here.  Drop const
	qualifier.
	* config/tc-cris.h (md_short_jump_size, md_long_jump_size): Don't
	declare.
	* config/tc-cris.c (md_short_jump_size, md_long_jump_size): Drop
	const qualifier in these definitions.
	* config/tc-i370.c, config/tc-m68k.c, config/tc-pdp11.c,
	config/tc-s390.c, config/tc-tahoe.c, config/tc-vax.c: Ditto.
@
text
@a368 24
#if 0
  /* FIXME: what follows is broken badly.  You can't deal with differences
     in radix conventions this way, because of symbolic constants, constant
     expressions made up of pieces of differing radix, etc.  The only
     choices are to change ../expr.c to know about pdp11 conventions, or
     to accept the fact that gas will use consistent conventions that differ
     from those of traditional pdp11 assemblers.  For now, I've
     chosen the latter.   paul koning, 12/23/2001
  */
  if (operand->reloc.exp.X_op == O_constant)
    {
      if (*str == '.')
	str++;
      else
	{
	  /* FIXME: buffer overflow! */
	  char buf[100];
	  char *end;

	  sprintf (buf, "%ld", operand->reloc.exp.X_add_number);
	  operand->reloc.exp.X_add_number = strtol (buf, &end, 8);
	}
    }
#endif
a619 22
#if 0
      op1.error = NULL;
      op1.additional = FALSE;
      op1.reloc.type = BFD_RELOC_NONE;
      op1.code = 0;
      op1.word = 0;
      str = parse_expression (str, &op1);
      if (op1.error)
	{
	  as_bad (op1.error);
	  return;
	}

      {
	char *to = frag_more (2);

	md_number_to_chars (to, op1.code, 2);
	if (insn.reloc.type != BFD_RELOC_NONE)
	  fix_new_exp (frag_now, to - frag_now->fr_literal, 2,
		       &insn.reloc.exp, insn.reloc.pc_rel, insn.reloc.type);
      }
#else
a620 2
#endif

@


1.11
log
@Fixes for the encoding and decoding of the PDP11's SOB instruction
@
text
@d1023 2
a1024 2
const int md_short_jump_size = 2;
const int md_long_jump_size = 4;
@


1.10
log
@Add support for a -g switch to GAS
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d202 1
@


1.9
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@a1349 2
  as_bad ("unrecognized option `-%c%s'", c, arg ? arg : "");

@


1.8
log
@	* config/obj-coff.h: Fix formatting.
	* config/tc-mcore.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-openrisc.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-xstormy16.h: Likewise.
@
text
@d78 1
a78 1
CONST char comment_chars[] = "#/";
d81 1
a81 1
CONST char line_comment_chars[] = "#/";
d83 1
a83 1
CONST char line_separator_chars[] = ";";
d86 1
a86 1
CONST char EXP_CHARS[] = "eE";
d91 1
a91 1
CONST char FLT_CHARS[] = "dDfF";
d96 1
a96 1
CONST pseudo_typeS md_pseudo_table[] =
d620 1
a620 1
  CONST struct pdp11_opcode *op;
d1022 2
a1023 2
CONST int md_short_jump_size = 2;
CONST int md_long_jump_size = 4;
d1292 1
a1292 1
CONST char *md_shortopts = "m:";
d1367 1
a1367 1
  CONST char *pattern;
d1369 1
a1369 1
  CONST char *description;
d1436 1
a1436 1
  CONST char *title;
d1511 1
a1511 1
     CONST char *pattern;
@


1.7
log
@	* tc-pdp11.c: Use VAX float format support for PDP-11 target.
	(parse_ac5): New function for parsing float regs in float operand.
	(parse_expression): Remove attempt to make literals be octal.
	(parse_op_no_deferred): Support float literals.
	(parse_op): Reject attempts to refer to float regs.
	(parse_fop): New function, like parse_op but for float operand.
	(md_assemble): Add cases to parse float operands.  Also fix
	IMM3, IMM6, IMM8 cases to pick up the operand from the right spot.
@
text
@d371 1
a371 1
     expressions made up of pieces of differing radix, etc.  The only 
d449 1
a449 1
          /* it's a floating literal... */
d582 1
a582 1
  
@


1.6
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc.
d36 3
d91 1
a91 1
CONST char FLT_CHARS[] = "dDfFgGhH";
d304 1
a304 1
parse_ac (char *str, struct pdp11_code *operand)
d316 1
d335 13
d368 9
d391 1
a391 1

d398 2
d443 13
d548 1
a548 1
parse_op (char *str, struct pdp11_code *operand)
a550 4

  str = parse_reg (str, operand);
  if (!operand->error)
    return str;
d567 40
d665 1
a665 1
      as_warn ("Unknown instruction");
d707 5
d715 1
a715 1
	  if (op1.code & ~7)
d722 1
a722 1
	  if (op1.code & ~0x3f)
d729 1
a729 1
	  if (op1.code & ~0xff)
d736 1
a736 1
      insn.code |= op1.code;
d778 9
d825 38
d880 19
@


1.5
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d166 1
a166 1
   that they reference.  */
d168 2
a169 2
int				/* Knows about order of bytes in address.  */
md_apply_fix (fixP, value)
d171 2
a172 1
     valueT *value;
d176 1
d205 1
a205 1
    *value += symbol_get_bfdsym (fixP->fx_addsy)->section->vma;
d209 1
a209 1
  code |= (*value >> shift) & mask;
d211 3
a213 1
  return 0;
d1560 1
a1560 1
  /* this is taken account for in md_apply_fix() */
@


1.4
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@d29 1
a255 8
static char
mklower (char c)
{
  if (isupper (c))
    return tolower (c);
  return c;
}

d260 1
a260 1
  if (mklower (*str) == 'r')
@


1.3
log
@Fix copyright notices
@
text
@d1160 1
a1160 1
size_t md_longopts_size = sizeof(md_longopts);
@


1.2
log
@2001-02-20  Kazu Hirata  <kazu@@hxi.com>

	* tc-pdp11.c: Fix formatting.
	* tc-pdp11.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2001 Free Software Foundation, Inc.
@


1.1
log
@Add PDP-11 support
@
text
@d76 1
a76 1
/* These chars only start a comment at the beginning of a line. */
a98 1

d124 1
a124 1
    
d161 1
a161 1
    }		  
d167 1
a167 1
int				/* Knows about order of bytes in address. */
d213 2
a214 2
     unsigned char con[];	/* Low order byte 1st. */
     int nbytes;		/* Number of bytes in the input. */
d236 1
a236 1
    }		  
d402 1
a402 1
    case '$': 
d809 1
a809 1
      
d827 1
a827 1
    
d954 1
a954 1
    pdp11_extension[PDP11_MPROC] = yes;	
d1142 1
a1142 1
						/* with FPP installed. */
d1225 1
a1225 1
} options;  
d1299 1
a1299 1
  { "PDP-11 CPU model options", 
d1302 1
a1302 1
  { "PDP-11 machine model options", 
@

