head	1.141;
access;
symbols
	binutils-2_24-branch:1.141.0.2
	binutils-2_24-branchpoint:1.141
	binutils-2_21_1:1.139
	binutils-2_23_2:1.140
	binutils-2_23_1:1.140
	binutils-2_23:1.140
	binutils-2_23-branch:1.140.0.2
	binutils-2_23-branchpoint:1.140
	binutils-2_22_branch:1.139.0.6
	binutils-2_22:1.139
	binutils-2_22-branch:1.139.0.4
	binutils-2_22-branchpoint:1.139
	binutils-2_21:1.139
	binutils-2_21-branch:1.139.0.2
	binutils-2_21-branchpoint:1.139
	binutils-2_20_1:1.134
	binutils-2_20:1.134
	binutils-arc-20081103-branch:1.130.0.6
	binutils-arc-20081103-branchpoint:1.130
	binutils-2_20-branch:1.134.0.2
	binutils-2_20-branchpoint:1.134
	dje-cgen-play1-branch:1.131.0.2
	dje-cgen-play1-branchpoint:1.131
	arc-20081103-branch:1.130.0.4
	arc-20081103-branchpoint:1.130
	binutils-2_19_1:1.130
	binutils-2_19:1.130
	binutils-2_19-branch:1.130.0.2
	binutils-2_19-branchpoint:1.130
	binutils-2_18:1.127
	binutils-2_18-branch:1.127.0.2
	binutils-2_18-branchpoint:1.127
	binutils-csl-coldfire-4_1-32:1.114
	binutils-csl-sourcerygxx-4_1-32:1.114
	binutils-csl-innovasic-fido-3_4_4-33:1.114
	binutils-csl-sourcerygxx-3_4_4-32:1.106
	binutils-csl-coldfire-4_1-30:1.114
	binutils-csl-sourcerygxx-4_1-30:1.114
	binutils-csl-coldfire-4_1-28:1.114
	binutils-csl-sourcerygxx-4_1-29:1.114
	binutils-csl-sourcerygxx-4_1-28:1.114
	binutils-csl-arm-2006q3-27:1.114
	binutils-csl-sourcerygxx-4_1-27:1.114
	binutils-csl-arm-2006q3-26:1.114
	binutils-csl-sourcerygxx-4_1-26:1.114
	binutils-csl-sourcerygxx-4_1-25:1.114
	binutils-csl-sourcerygxx-4_1-24:1.114
	binutils-csl-sourcerygxx-4_1-23:1.114
	binutils-csl-sourcerygxx-4_1-21:1.114
	binutils-csl-arm-2006q3-21:1.114
	binutils-csl-sourcerygxx-4_1-22:1.114
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.114
	binutils-csl-sourcerygxx-4_1-20:1.114
	binutils-csl-arm-2006q3-19:1.114
	binutils-csl-sourcerygxx-4_1-19:1.114
	binutils-csl-sourcerygxx-4_1-18:1.114
	binutils-csl-renesas-4_1-9:1.114
	binutils-csl-sourcerygxx-3_4_4-25:1.106
	binutils-csl-renesas-4_1-8:1.114
	binutils-csl-renesas-4_1-7:1.114
	binutils-csl-renesas-4_1-6:1.114
	binutils-csl-sourcerygxx-4_1-17:1.114
	binutils-csl-sourcerygxx-4_1-14:1.114
	binutils-csl-sourcerygxx-4_1-15:1.114
	binutils-csl-sourcerygxx-4_1-13:1.114
	binutils-2_17:1.114
	binutils-csl-sourcerygxx-4_1-12:1.114
	binutils-csl-sourcerygxx-3_4_4-21:1.114
	binutils-csl-wrs-linux-3_4_4-24:1.106
	binutils-csl-wrs-linux-3_4_4-23:1.106
	binutils-csl-sourcerygxx-4_1-9:1.114
	binutils-csl-sourcerygxx-4_1-8:1.114
	binutils-csl-sourcerygxx-4_1-7:1.114
	binutils-csl-arm-2006q1-6:1.114
	binutils-csl-sourcerygxx-4_1-6:1.114
	binutils-csl-wrs-linux-3_4_4-22:1.106
	binutils-csl-coldfire-4_1-11:1.114
	binutils-csl-sourcerygxx-3_4_4-19:1.114
	binutils-csl-coldfire-4_1-10:1.114
	binutils-csl-sourcerygxx-4_1-5:1.114
	binutils-csl-sourcerygxx-4_1-4:1.114
	binutils-csl-wrs-linux-3_4_4-21:1.106
	binutils-csl-morpho-4_1-4:1.114
	binutils-csl-sourcerygxx-3_4_4-17:1.114
	binutils-csl-wrs-linux-3_4_4-20:1.106
	binutils-2_17-branch:1.114.0.4
	binutils-2_17-branchpoint:1.114
	binutils-csl-2_17-branch:1.114.0.2
	binutils-csl-2_17-branchpoint:1.114
	binutils-csl-gxxpro-3_4-branch:1.106.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.106
	binutils-2_16_1:1.106
	binutils-csl-arm-2005q1b:1.106
	binutils-2_16:1.106
	binutils-csl-arm-2005q1a:1.106
	binutils-csl-arm-2005q1-branch:1.106.0.4
	binutils-csl-arm-2005q1-branchpoint:1.106
	binutils-2_16-branch:1.106.0.2
	binutils-2_16-branchpoint:1.106
	csl-arm-2004-q3d:1.102
	csl-arm-2004-q3:1.102
	binutils-2_15:1.91.6.2
	binutils-2_15-branchpoint:1.91
	csl-arm-2004-q1a:1.98
	csl-arm-2004-q1:1.98
	binutils-2_15-branch:1.91.0.6
	cagney_bfdfile-20040213-branch:1.91.0.4
	cagney_bfdfile-20040213-branchpoint:1.91
	cagney_bigcore-20040122-branch:1.91.0.2
	cagney_bigcore-20040122-branchpoint:1.91
	csl-arm-2003-q4:1.91
	binutils-2_14:1.83
	binutils-2_14-branch:1.83.0.2
	binutils-2_14-branchpoint:1.83
	binutils-2_13_2_1:1.68.2.2
	binutils-2_13_2:1.68.2.2
	binutils-2_13_1:1.68.2.1
	binutils-2_13:1.68
	binutils-2_13-branchpoint:1.68
	binutils-2_13-branch:1.68.0.2
	binutils-2_12_1:1.57.2.3
	binutils-2_12:1.57.2.1
	binutils-2_12-branch:1.57.0.2
	binutils-2_12-branchpoint:1.57
	cygnus_cvs_20020108_pre:1.50
	binutils-2_11_2:1.33.2.4
	binutils-2_11_1:1.33.2.4
	binutils-2_11:1.33.2.1
	x86_64versiong3:1.34
	binutils-2_11-branch:1.33.0.2
	binutils-2_10_1:1.11
	binutils-2_10:1.11
	binutils-2_10-branch:1.11.0.2
	binutils-2_10-branchpoint:1.11
	binutils_latest_snapshot:1.141
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.141
date	2013.04.15.10.30.22;	author jules;	state Exp;
branches;
next	1.140;

1.140
date	2012.03.21.08.58.40;	author tschwinge;	state Exp;
branches;
next	1.139;

1.139
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2010.06.21.07.42.55;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2010.05.25.14.12.39;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	2010.03.02.09.32.21;	author ams;	state Exp;
branches;
next	1.135;

1.135
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2009.08.29.10.38.33;	author kkojima;	state Exp;
branches;
next	1.132;

1.132
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.131;

1.131
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	2008.08.06.15.42.15;	author dj;	state Exp;
branches;
next	1.129;

1.129
date	2008.04.15.15.53.23;	author ams;	state Exp;
branches;
next	1.128;

1.128
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.126;

1.126
date	2007.04.21.13.04.14;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2007.04.16.13.05.30;	author kkojima;	state Exp;
branches;
next	1.124;

1.124
date	2007.04.15.22.02.25;	author kkojima;	state Exp;
branches;
next	1.123;

1.123
date	2007.04.14.14.21.11;	author kkojima;	state Exp;
branches;
next	1.122;

1.122
date	2006.10.27.09.34.45;	author ams;	state Exp;
branches;
next	1.121;

1.121
date	2006.08.08.17.21.04;	author dj;	state Exp;
branches;
next	1.120;

1.120
date	2006.08.04.13.13.56;	author rsandifo;	state Exp;
branches;
next	1.119;

1.119
date	2006.07.21.09.46.15;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	2006.07.12.09.02.00;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2006.05.19.11.26.11;	author ths;	state Exp;
branches;
next	1.115;

1.115
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.114;

1.114
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	2005.10.06.11.44.06;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2005.09.20.18.24.48;	author rth;	state Exp;
branches;
next	1.111;

1.111
date	2005.08.18.11.54.33;	author cpg;	state Exp;
branches;
next	1.110;

1.110
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.108;

1.108
date	2005.05.05.09.13.02;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2005.03.21.15.35.34;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2005.02.23.12.28.05;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2005.02.17.13.46.05;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2005.02.14.23.58.14;	author kkojima;	state Exp;
branches;
next	1.103;

1.103
date	2005.01.17.14.08.10;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2004.07.29.05.17.41;	author aoliva;	state Exp;
branches;
next	1.101;

1.101
date	2004.07.09.12.32.33;	author nickc;	state Exp;
branches;
next	1.100;

1.100
date	2004.07.05.13.35.44;	author amylaar;	state Exp;
branches;
next	1.99;

1.99
date	2004.05.28.12.32.04;	author amylaar;	state Exp;
branches;
next	1.98;

1.98
date	2004.04.02.01.39.30;	author kkojima;	state Exp;
branches;
next	1.97;

1.97
date	2004.03.22.01.44.29;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2004.03.18.00.49.22;	author kkojima;	state Exp;
branches;
next	1.95;

1.95
date	2004.03.03.18.01.49;	author amylaar;	state Exp;
branches;
next	1.94;

1.94
date	2004.02.27.13.16.39;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2004.02.27.12.21.57;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2004.02.26.16.14.42;	author amylaar;	state Exp;
branches;
next	1.91;

1.91
date	2003.12.05.11.55.01;	author nickc;	state Exp;
branches
	1.91.6.1;
next	1.90;

1.90
date	2003.12.05.01.59.54;	author msnyder;	state Exp;
branches;
next	1.89;

1.89
date	2003.11.27.08.29.29;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2003.11.22.02.35.31;	author kazu;	state Exp;
branches;
next	1.87;

1.87
date	2003.10.11.13.40.21;	author kkojima;	state Exp;
branches;
next	1.86;

1.86
date	2003.07.30.20.34.26;	author amylaar;	state Exp;
branches;
next	1.85;

1.85
date	2003.07.29.06.55.34;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2003.04.23.21.09.03;	author amylaar;	state Exp;
branches;
next	1.82;

1.82
date	2003.04.15.08.51.53;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2003.03.03.21.04.00;	author amylaar;	state Exp;
branches;
next	1.80;

1.80
date	2003.01.23.18.50.57;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.30.14.09.10;	author kkojima;	state Exp;
branches;
next	1.77;

1.77
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2002.11.28.23.57.59;	author kkojima;	state Exp;
branches;
next	1.75;

1.75
date	2002.11.21.09.54.12;	author kdienes;	state Exp;
branches;
next	1.74;

1.74
date	2002.10.11.14.34.46;	author kkojima;	state Exp;
branches;
next	1.73;

1.73
date	2002.10.10.13.37.32;	author amylaar;	state Exp;
branches;
next	1.72;

1.72
date	2002.10.03.04.58.28;	author kkojima;	state Exp;
branches;
next	1.71;

1.71
date	2002.09.28.00.41.26;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.19.14.31.07;	author amylaar;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2002.06.19.14.28.09;	author amylaar;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.17.15.32.25;	author amylaar;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.07.10.24.56;	author amylaar;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.06.17.29.54;	author amylaar;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.11.11.31.17;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.11.09.53.50;	author kazu;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.01.09.54.31;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2002.04.09.15.26.59;	author amylaar;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.11.06.14.41;	author aoliva;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.08.06.32.20;	author aoliva;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2002.02.06.06.26.14;	author aoliva;	state Exp;
branches;
next	1.55;

1.55
date	2002.02.06.05.34.34;	author aoliva;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.04.12.29.15;	author aoliva;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.30.18.25.30;	author rsandifo;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.24.02.59.16;	author aoliva;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.24.02.54.46;	author aoliva;	state Exp;
branches;
next	1.50;

1.50
date	2001.12.20.17.28.13;	author aoliva;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.05.09.52.32;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.29.09.41.34;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.15.21.28.58;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.17.05.51.12;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.16.02.36.20;	author hp;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.01.00.06.58;	author hp;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.19.05.33.29;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.15.14.49.54;	author hp;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.03.15.22.19;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.13.16.46.05;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.05.04.21.36;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.30.00.06.10;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.16.02.11.05;	author aoliva;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.09.18.21.42;	author aoliva;	state Exp;
branches;
next	1.33;

1.33
date	2000.12.28.10.07.56;	author rth;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.28.23.53.51;	author hp;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.28.23.48.44;	author hp;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.28.23.33.45;	author hp;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.17.08.47.52;	author rth;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.31.12.33.13;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.30.20.26.42;	author hp;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.25.19.15.33;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.16.19.44.39;	author hp;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.26.07.09.18;	author kazu;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.02.02.36.27;	author aoliva;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.15.20.47.19;	author law;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.15.16.04.37;	author aoliva;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.08.18.13.58;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.07.16.52.31;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.07.16.45.46;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.25.17.59.21;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.24.11.51.53;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.29.22.05.27;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.05.21.43.25;	author amylaar;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.05.21.23.05;	author amylaar;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.27.16.17.08;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.16.23.50.18;	author amylaar;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.16.21.18.53;	author amylaar;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.16.20.59.08;	author amylaar;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.16.01.18.13;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.24.19.46.28;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.17.00.33.36;	author amylaar;	state Exp;
branches;
next	1.4;

1.4
date	99.08.05.22.09.04;	author amylaar;	state Exp;
branches;
next	1.3;

1.3
date	99.06.12.16.49.50;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.42;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.91.6.1
date	2004.03.18.01.17.32;	author kkojima;	state Exp;
branches;
next	1.91.6.2;

1.91.6.2
date	2004.04.09.18.28.12;	author drow;	state Exp;
branches;
next	;

1.68.2.1
date	2002.10.28.18.45.49;	author drow;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2002.12.15.22.31.47;	author drow;	state Exp;
branches;
next	;

1.57.2.1
date	2002.02.11.06.15.10;	author aoliva;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2002.04.27.13.44.15;	author amodra;	state Exp;
branches;
next	1.57.2.3;

1.57.2.3
date	2002.05.11.16.49.58;	author drow;	state Exp;
branches;
next	;

1.33.2.1
date	2001.02.09.18.25.09;	author aoliva;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2001.06.07.03.15.32;	author amodra;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2001.06.11.10.04.50;	author amodra;	state Exp;
branches;
next	1.33.2.4;

1.33.2.4
date	2001.06.13.16.47.27;	author nickc;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.141
log
@    gas/
    * expr.c (add_to_result, subtract_from_result): Make global.
    * expr.h (add_to_result, subtract_from_result): Add prototypes.
    * config/tc-sh.c (sh_optimize_expr): Use add_to_result,
    subtract_from_result to handle extra bit of precision for .sleb128
    directive operands.

    gas/testsuite/
    * gas/all/gas.exp (sleb128-7): Don't run for tic4x, tic54x.
    * gas/all/sleb128-2.s: Reformat, use _ at start of labels, remove
    cruft.
    * gas/all/sleb128-3.s: Likewise.
    * gas/all/sleb128-4.s: Likewise.
    * gas/all/sleb128-5.s: Likewise.
    * gas/all/sleb128-7.s: Likewise.
    * gas/all/sleb128-2.d: Handle data sections named $DATA$.
    * gas/all/sleb128-3.d: Likewise.
    * gas/all/sleb128-4.d: Likewise.
    * gas/all/sleb128-5.d: Likewise.
    * gas/all/sleb128-7.d: Likewise.
@
text
@/* tc-sh.c -- Assemble code for the Renesas / SuperH SH
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>  */

#include "as.h"
#include "subsegs.h"
#define DEFINE_TABLE
#include "opcodes/sh-opc.h"
#include "safe-ctype.h"
#include "struc-symbol.h"

#ifdef OBJ_ELF
#include "elf/sh.h"
#endif

#include "dwarf2dbg.h"
#include "dw2gencfi.h"

typedef struct
  {
    sh_arg_type type;
    int reg;
    expressionS immediate;
  }
sh_operand_info;

const char comment_chars[] = "!";
const char line_separator_chars[] = ";";
const char line_comment_chars[] = "!#";

static void s_uses (int);
static void s_uacons (int);

#ifdef OBJ_ELF
static void sh_elf_cons (int);

symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
#endif

static void
big (int ignore ATTRIBUTE_UNUSED)
{
  if (! target_big_endian)
    as_bad (_("directive .big encountered when option -big required"));

  /* Stop further messages.  */
  target_big_endian = 1;
}

static void
little (int ignore ATTRIBUTE_UNUSED)
{
  if (target_big_endian)
    as_bad (_("directive .little encountered when option -little required"));

  /* Stop further messages.  */
  target_big_endian = 0;
}

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
#ifdef OBJ_ELF
  {"long", sh_elf_cons, 4},
  {"int", sh_elf_cons, 4},
  {"word", sh_elf_cons, 2},
  {"short", sh_elf_cons, 2},
#else
  {"int", cons, 4},
  {"word", cons, 2},
#endif /* OBJ_ELF */
  {"big", big, 0},
  {"form", listing_psize, 0},
  {"little", little, 0},
  {"heading", listing_title, 0},
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
  {"program", s_ignore, 0},
  {"uses", s_uses, 0},
  {"uaword", s_uacons, 2},
  {"ualong", s_uacons, 4},
  {"uaquad", s_uacons, 8},
  {"2byte", s_uacons, 2},
  {"4byte", s_uacons, 4},
  {"8byte", s_uacons, 8},
#ifdef HAVE_SH64
  {"mode", s_sh64_mode, 0 },

  /* Have the old name too.  */
  {"isa", s_sh64_mode, 0 },

  /* Assert that the right ABI is used.  */
  {"abi", s_sh64_abi, 0 },

  { "vtable_inherit", sh64_vtable_inherit, 0 },
  { "vtable_entry", sh64_vtable_entry, 0 },
#endif /* HAVE_SH64 */
  {0, 0, 0}
};

int sh_relax;		/* set if -relax seen */

/* Whether -small was seen.  */

int sh_small;

/* Flag to generate relocations against symbol values for local symbols.  */

static int dont_adjust_reloc_32;

/* Flag to indicate that '$' is allowed as a register prefix.  */

static int allow_dollar_register_prefix;

/* Preset architecture set, if given; zero otherwise.  */

static unsigned int preset_target_arch;

/* The bit mask of architectures that could
   accommodate the insns seen so far.  */
static unsigned int valid_arch;

#ifdef OBJ_ELF
/* Whether --fdpic was given.  */
static int sh_fdpic;
#endif

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

#define C(a,b) ENCODE_RELAX(a,b)

#define ENCODE_RELAX(what,length) (((what) << 4) + (length))
#define GET_WHAT(x) ((x>>4))

/* These are the three types of relaxable instruction.  */
/* These are the types of relaxable instructions; except for END which is
   a marker.  */
#define COND_JUMP 1
#define COND_JUMP_DELAY 2
#define UNCOND_JUMP  3

#ifdef HAVE_SH64

/* A 16-bit (times four) pc-relative operand, at most expanded to 32 bits.  */
#define SH64PCREL16_32 4
/* A 16-bit (times four) pc-relative operand, at most expanded to 64 bits.  */
#define SH64PCREL16_64 5

/* Variants of the above for adjusting the insn to PTA or PTB according to
   the label.  */
#define SH64PCREL16PT_32 6
#define SH64PCREL16PT_64 7

/* A MOVI expansion, expanding to at most 32 or 64 bits.  */
#define MOVI_IMM_32 8
#define MOVI_IMM_32_PCREL 9
#define MOVI_IMM_64 10
#define MOVI_IMM_64_PCREL 11
#define END 12

#else  /* HAVE_SH64 */

#define END 4

#endif /* HAVE_SH64 */

#define UNDEF_DISP 0
#define COND8  1
#define COND12 2
#define COND32 3
#define UNDEF_WORD_DISP 4

#define UNCOND12 1
#define UNCOND32 2

#ifdef HAVE_SH64
#define UNDEF_SH64PCREL 0
#define SH64PCREL16 1
#define SH64PCREL32 2
#define SH64PCREL48 3
#define SH64PCREL64 4
#define SH64PCRELPLT 5

#define UNDEF_MOVI 0
#define MOVI_16 1
#define MOVI_32 2
#define MOVI_48 3
#define MOVI_64 4
#define MOVI_PLT 5
#define MOVI_GOTOFF 6
#define MOVI_GOTPC 7
#endif /* HAVE_SH64 */

/* Branch displacements are from the address of the branch plus
   four, thus all minimum and maximum values have 4 added to them.  */
#define COND8_F 258
#define COND8_M -252
#define COND8_LENGTH 2

/* There is one extra instruction before the branch, so we must add
   two more bytes to account for it.  */
#define COND12_F 4100
#define COND12_M -4090
#define COND12_LENGTH 6

#define COND12_DELAY_LENGTH 4

/* ??? The minimum and maximum values are wrong, but this does not matter
   since this relocation type is not supported yet.  */
#define COND32_F (1<<30)
#define COND32_M -(1<<30)
#define COND32_LENGTH 14

#define UNCOND12_F 4098
#define UNCOND12_M -4092
#define UNCOND12_LENGTH 2

/* ??? The minimum and maximum values are wrong, but this does not matter
   since this relocation type is not supported yet.  */
#define UNCOND32_F (1<<30)
#define UNCOND32_M -(1<<30)
#define UNCOND32_LENGTH 14

#ifdef HAVE_SH64
/* The trivial expansion of a SH64PCREL16 relaxation is just a "PT label,
   TRd" as is the current insn, so no extra length.  Note that the "reach"
   is calculated from the address *after* that insn, but the offset in the
   insn is calculated from the beginning of the insn.  We also need to
   take into account the implicit 1 coded as the "A" in PTA when counting
   forward.  If PTB reaches an odd address, we trap that as an error
   elsewhere, so we don't have to have different relaxation entries.  We
   don't add a one to the negative range, since PTB would then have the
   farthest backward-reaching value skipped, not generated at relaxation.  */
#define SH64PCREL16_F (32767 * 4 - 4 + 1)
#define SH64PCREL16_M (-32768 * 4 - 4)
#define SH64PCREL16_LENGTH 0

/* The next step is to change that PT insn into
     MOVI ((label - datalabel Ln) >> 16) & 65535, R25
     SHORI (label - datalabel Ln) & 65535, R25
    Ln:
     PTREL R25,TRd
   which means two extra insns, 8 extra bytes.  This is the limit for the
   32-bit ABI.

   The expressions look a bit bad since we have to adjust this to avoid overflow on a
   32-bit host.  */
#define SH64PCREL32_F ((((long) 1 << 30) - 1) * 2 + 1 - 4)
#define SH64PCREL32_LENGTH (2 * 4)

/* Similarly, we just change the MOVI and add a SHORI for the 48-bit
   expansion.  */
#if BFD_HOST_64BIT_LONG
/* The "reach" type is long, so we can only do this for a 64-bit-long
   host.  */
#define SH64PCREL32_M (((long) -1 << 30) * 2 - 4)
#define SH64PCREL48_F ((((long) 1 << 47) - 1) - 4)
#define SH64PCREL48_M (((long) -1 << 47) - 4)
#define SH64PCREL48_LENGTH (3 * 4)
#else
/* If the host does not have 64-bit longs, just make this state identical
   in reach to the 32-bit state.  Note that we have a slightly incorrect
   reach, but the correct one above will overflow a 32-bit number.  */
#define SH64PCREL32_M (((long) -1 << 30) * 2)
#define SH64PCREL48_F SH64PCREL32_F
#define SH64PCREL48_M SH64PCREL32_M
#define SH64PCREL48_LENGTH (3 * 4)
#endif /* BFD_HOST_64BIT_LONG */

/* And similarly for the 64-bit expansion; a MOVI + SHORI + SHORI + SHORI
   + PTREL sequence.  */
#define SH64PCREL64_LENGTH (4 * 4)

/* For MOVI, we make the MOVI + SHORI... expansion you can see in the
   SH64PCREL expansions.  The PCREL one is similar, but the other has no
   pc-relative reach; it must be fully expanded in
   shmedia_md_estimate_size_before_relax.  */
#define MOVI_16_LENGTH 0
#define MOVI_16_F (32767 - 4)
#define MOVI_16_M (-32768 - 4)
#define MOVI_32_LENGTH 4
#define MOVI_32_F ((((long) 1 << 30) - 1) * 2 + 1 - 4)
#define MOVI_48_LENGTH 8

#if BFD_HOST_64BIT_LONG
/* The "reach" type is long, so we can only do this for a 64-bit-long
   host.  */
#define MOVI_32_M (((long) -1 << 30) * 2 - 4)
#define MOVI_48_F ((((long) 1 << 47) - 1) - 4)
#define MOVI_48_M (((long) -1 << 47) - 4)
#else
/* If the host does not have 64-bit longs, just make this state identical
   in reach to the 32-bit state.  Note that we have a slightly incorrect
   reach, but the correct one above will overflow a 32-bit number.  */
#define MOVI_32_M (((long) -1 << 30) * 2)
#define MOVI_48_F MOVI_32_F
#define MOVI_48_M MOVI_32_M
#endif /* BFD_HOST_64BIT_LONG */

#define MOVI_64_LENGTH 12
#endif /* HAVE_SH64 */

#define EMPTY { 0, 0, 0, 0 }

const relax_typeS md_relax_table[C (END, 0)] = {
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  EMPTY,
  /* C (COND_JUMP, COND8) */
  { COND8_F, COND8_M, COND8_LENGTH, C (COND_JUMP, COND12) },
  /* C (COND_JUMP, COND12) */
  { COND12_F, COND12_M, COND12_LENGTH, C (COND_JUMP, COND32), },
  /* C (COND_JUMP, COND32) */
  { COND32_F, COND32_M, COND32_LENGTH, 0, },
  /* C (COND_JUMP, UNDEF_WORD_DISP) */
  { 0, 0, COND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  EMPTY,
  /* C (COND_JUMP_DELAY, COND8) */
  { COND8_F, COND8_M, COND8_LENGTH, C (COND_JUMP_DELAY, COND12) },
  /* C (COND_JUMP_DELAY, COND12) */
  { COND12_F, COND12_M, COND12_DELAY_LENGTH, C (COND_JUMP_DELAY, COND32), },
  /* C (COND_JUMP_DELAY, COND32) */
  { COND32_F, COND32_M, COND32_LENGTH, 0, },
  /* C (COND_JUMP_DELAY, UNDEF_WORD_DISP) */
  { 0, 0, COND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  EMPTY,
  /* C (UNCOND_JUMP, UNCOND12) */
  { UNCOND12_F, UNCOND12_M, UNCOND12_LENGTH, C (UNCOND_JUMP, UNCOND32), },
  /* C (UNCOND_JUMP, UNCOND32) */
  { UNCOND32_F, UNCOND32_M, UNCOND32_LENGTH, 0, },
  EMPTY,
  /* C (UNCOND_JUMP, UNDEF_WORD_DISP) */
  { 0, 0, UNCOND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

#ifdef HAVE_SH64
  /* C (SH64PCREL16_32, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16_32, SH64PCREL32) },
  /* C (SH64PCREL16_32, SH64PCREL32) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (SH64PCREL16_32, SH64PCRELPLT) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16_64, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16_64, SH64PCREL32) },
  /* C (SH64PCREL16_64, SH64PCREL32) */
  { SH64PCREL32_F, SH64PCREL32_M, SH64PCREL32_LENGTH, C (SH64PCREL16_64, SH64PCREL48) },
  /* C (SH64PCREL16_64, SH64PCREL48) */
  { SH64PCREL48_F, SH64PCREL48_M, SH64PCREL48_LENGTH, C (SH64PCREL16_64, SH64PCREL64) },
  /* C (SH64PCREL16_64, SH64PCREL64) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  /* C (SH64PCREL16_64, SH64PCRELPLT) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16PT_32, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16PT_32, SH64PCREL32) },
  /* C (SH64PCREL16PT_32, SH64PCREL32) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (SH64PCREL16PT_32, SH64PCRELPLT) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16PT_64, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16PT_64, SH64PCREL32) },
  /* C (SH64PCREL16PT_64, SH64PCREL32) */
  { SH64PCREL32_F,
    SH64PCREL32_M,
    SH64PCREL32_LENGTH,
    C (SH64PCREL16PT_64, SH64PCREL48) },
  /* C (SH64PCREL16PT_64, SH64PCREL48) */
  { SH64PCREL48_F, SH64PCREL48_M, SH64PCREL48_LENGTH, C (SH64PCREL16PT_64, SH64PCREL64) },
  /* C (SH64PCREL16PT_64, SH64PCREL64) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  /* C (SH64PCREL16PT_64, SH64PCRELPLT) */
  { 0, 0, SH64PCREL64_LENGTH, 0},
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_32, UNDEF_MOVI) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  /* C (MOVI_IMM_32, MOVI_16) */
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_32, MOVI_32) },
  /* C (MOVI_IMM_32, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY,
  /* C (MOVI_IMM_32, MOVI_GOTOFF) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_32_PCREL, MOVI_16) */
  EMPTY,
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_32_PCREL, MOVI_32) },
  /* C (MOVI_IMM_32_PCREL, MOVI_32) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (MOVI_IMM_32_PCREL, MOVI_PLT) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_32_PCREL, MOVI_GOTPC) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_64, UNDEF_MOVI) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  /* C (MOVI_IMM_64, MOVI_16) */
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_64, MOVI_32) },
  /* C (MOVI_IMM_64, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, C (MOVI_IMM_64, MOVI_48) },
  /* C (MOVI_IMM_64, MOVI_48) */
  { MOVI_48_F, MOVI_48_M, MOVI_48_LENGTH, C (MOVI_IMM_64, MOVI_64) },
  /* C (MOVI_IMM_64, MOVI_64) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_64, MOVI_GOTOFF) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_64_PCREL, MOVI_16) */
  EMPTY,
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_32) },
  /* C (MOVI_IMM_64_PCREL, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_48) },
  /* C (MOVI_IMM_64_PCREL, MOVI_48) */
  { MOVI_48_F, MOVI_48_M, MOVI_48_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_64) },
  /* C (MOVI_IMM_64_PCREL, MOVI_64) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  /* C (MOVI_IMM_64_PCREL, MOVI_PLT) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_64_PCREL, MOVI_GOTPC) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

#endif /* HAVE_SH64 */

};

#undef EMPTY

static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */


#ifdef OBJ_ELF
/* Determinet whether the symbol needs any kind of PIC relocation.  */

inline static int
sh_PIC_related_p (symbolS *sym)
{
  expressionS *exp;

  if (! sym)
    return 0;

  if (sym == GOT_symbol)
    return 1;

#ifdef HAVE_SH64
  if (sh_PIC_related_p (*symbol_get_tc (sym)))
    return 1;
#endif

  exp = symbol_get_value_expression (sym);

  return (exp->X_op == O_PIC_reloc
	  || sh_PIC_related_p (exp->X_add_symbol)
	  || sh_PIC_related_p (exp->X_op_symbol));
}

/* Determine the relocation type to be used to represent the
   expression, that may be rearranged.  */

static int
sh_check_fixup (expressionS *main_exp, bfd_reloc_code_real_type *r_type_p)
{
  expressionS *exp = main_exp;

  /* This is here for backward-compatibility only.  GCC used to generated:

	f@@PLT + . - (.LPCS# + 2)

     but we'd rather be able to handle this as a PIC-related reference
     plus/minus a symbol.  However, gas' parser gives us:

	O_subtract (O_add (f@@PLT, .), .LPCS#+2)

     so we attempt to transform this into:

        O_subtract (f@@PLT, O_subtract (.LPCS#+2, .))

     which we can handle simply below.  */
  if (exp->X_op == O_subtract)
    {
      if (sh_PIC_related_p (exp->X_op_symbol))
	return 1;

      exp = symbol_get_value_expression (exp->X_add_symbol);

      if (exp && sh_PIC_related_p (exp->X_op_symbol))
	return 1;

      if (exp && exp->X_op == O_add
	  && sh_PIC_related_p (exp->X_add_symbol))
	{
	  symbolS *sym = exp->X_add_symbol;

	  exp->X_op = O_subtract;
	  exp->X_add_symbol = main_exp->X_op_symbol;

	  main_exp->X_op_symbol = main_exp->X_add_symbol;
	  main_exp->X_add_symbol = sym;

	  main_exp->X_add_number += exp->X_add_number;
	  exp->X_add_number = 0;
	}

      exp = main_exp;
    }
  else if (exp->X_op == O_add && sh_PIC_related_p (exp->X_op_symbol))
    return 1;

  if (exp->X_op == O_symbol || exp->X_op == O_add || exp->X_op == O_subtract)
    {
#ifdef HAVE_SH64
      if (exp->X_add_symbol
	  && (exp->X_add_symbol == GOT_symbol
	      || (GOT_symbol
		  && *symbol_get_tc (exp->X_add_symbol) == GOT_symbol)))
	{
	  switch (*r_type_p)
	    {
	    case BFD_RELOC_SH_IMM_LOW16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_LOW16;
	      break;

	    case BFD_RELOC_SH_IMM_MEDLOW16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_MEDLOW16;
	      break;

	    case BFD_RELOC_SH_IMM_MEDHI16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_MEDHI16;
	      break;

	    case BFD_RELOC_SH_IMM_HI16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_HI16;
	      break;

	    case BFD_RELOC_NONE:
	    case BFD_RELOC_UNUSED:
	      *r_type_p = BFD_RELOC_SH_GOTPC;
	      break;

	    default:
	      abort ();
	    }
	  return 0;
	}
#else
      if (exp->X_add_symbol && exp->X_add_symbol == GOT_symbol)
	{
	  *r_type_p = BFD_RELOC_SH_GOTPC;
	  return 0;
	}
#endif
      exp = symbol_get_value_expression (exp->X_add_symbol);
      if (! exp)
	return 0;
    }

  if (exp->X_op == O_PIC_reloc)
    {
      switch (*r_type_p)
	{
	case BFD_RELOC_NONE:
	case BFD_RELOC_UNUSED:
	  *r_type_p = exp->X_md;
	  break;

	case BFD_RELOC_SH_DISP20:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT20;
	      break;

	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF20;
	      break;

	    case BFD_RELOC_SH_GOTFUNCDESC:
	      *r_type_p = BFD_RELOC_SH_GOTFUNCDESC20;
	      break;

	    case BFD_RELOC_SH_GOTOFFFUNCDESC:
	      *r_type_p = BFD_RELOC_SH_GOTOFFFUNCDESC20;
	      break;

	    default:
	      abort ();
	    }
	  break;

#ifdef HAVE_SH64
	case BFD_RELOC_SH_IMM_LOW16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_LOW16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_LOW16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_LOW16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_LOW16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_MEDLOW16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_MEDLOW16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_MEDLOW16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_MEDLOW16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_MEDLOW16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_MEDHI16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_MEDHI16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_MEDHI16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_MEDHI16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_MEDHI16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_HI16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_HI16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_HI16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_HI16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_HI16;
	      break;

	    default:
	      abort ();
	    }
	  break;
#endif

	default:
	  abort ();
	}
      if (exp == main_exp)
	exp->X_op = O_symbol;
      else
	{
	  main_exp->X_add_symbol = exp->X_add_symbol;
	  main_exp->X_add_number += exp->X_add_number;
	}
    }
  else
    return (sh_PIC_related_p (exp->X_add_symbol)
	    || sh_PIC_related_p (exp->X_op_symbol));

  return 0;
}

/* Add expression EXP of SIZE bytes to offset OFF of fragment FRAG.  */

void
sh_cons_fix_new (fragS *frag, int off, int size, expressionS *exp)
{
  bfd_reloc_code_real_type r_type = BFD_RELOC_UNUSED;

  if (sh_check_fixup (exp, &r_type))
    as_bad (_("Invalid PIC expression."));

  if (r_type == BFD_RELOC_UNUSED)
    switch (size)
      {
      case 1:
	r_type = BFD_RELOC_8;
	break;

      case 2:
	r_type = BFD_RELOC_16;
	break;

      case 4:
	r_type = BFD_RELOC_32;
	break;

      case 8:
	r_type = BFD_RELOC_64;
	break;

      default:
	goto error;
      }
  else if (size != 4)
    {
    error:
      as_bad (_("unsupported BFD relocation size %u"), size);
      r_type = BFD_RELOC_UNUSED;
    }

  fix_new_exp (frag, off, size, exp, 0, r_type);
}

/* The regular cons() function, that reads constants, doesn't support
   suffixes such as @@GOT, @@GOTOFF and @@PLT, that generate
   machine-specific relocation types.  So we must define it here.  */
/* Clobbers input_line_pointer, checks end-of-line.  */
/* NBYTES 1=.byte, 2=.word, 4=.long */
static void
sh_elf_cons (register int nbytes)
{
  expressionS exp;

#ifdef HAVE_SH64

  /* Update existing range to include a previous insn, if there was one.  */
  sh64_update_contents_mark (TRUE);

  /* We need to make sure the contents type is set to data.  */
  sh64_flag_output ();

#endif /* HAVE_SH64 */

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  do
    {
      expression (&exp);
      emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  if (*input_line_pointer == '#' || *input_line_pointer == '!')
    {
       while (! is_end_of_line[(unsigned char) *input_line_pointer++]);
    }
  else
    demand_empty_rest_of_line ();
}

/* The regular frag_offset_fixed_p doesn't work for rs_align_test
   frags.  */

static bfd_boolean
align_test_frag_offset_fixed_p (const fragS *frag1, const fragS *frag2,
				bfd_vma *offset)
{
  const fragS *frag;
  bfd_vma off;

  /* Start with offset initialised to difference between the two frags.
     Prior to assigning frag addresses this will be zero.  */
  off = frag1->fr_address - frag2->fr_address;
  if (frag1 == frag2)
    {
      *offset = off;
      return TRUE;
    }

  /* Maybe frag2 is after frag1.  */
  frag = frag1;
  while (frag->fr_type == rs_fill
	 || frag->fr_type == rs_align_test)
    {
      if (frag->fr_type == rs_fill)
	off += frag->fr_fix + frag->fr_offset * frag->fr_var;
      else
	off += frag->fr_fix;
      frag = frag->fr_next;
      if (frag == NULL)
	break;
      if (frag == frag2)
	{
	  *offset = off;
	  return TRUE;
	}
    }

  /* Maybe frag1 is after frag2.  */
  off = frag1->fr_address - frag2->fr_address;
  frag = frag2;
  while (frag->fr_type == rs_fill
	 || frag->fr_type == rs_align_test)
    {
      if (frag->fr_type == rs_fill)
	off -= frag->fr_fix + frag->fr_offset * frag->fr_var;
      else
	off -= frag->fr_fix;
      frag = frag->fr_next;
      if (frag == NULL)
	break;
      if (frag == frag1)
	{
	  *offset = off;
	  return TRUE;
	}
    }

  return FALSE;
}

/* Optimize a difference of symbols which have rs_align_test frag if
   possible.  */

int
sh_optimize_expr (expressionS *l, operatorT op, expressionS *r)
{
  bfd_vma frag_off;

  if (op == O_subtract
      && l->X_op == O_symbol
      && r->X_op == O_symbol
      && S_GET_SEGMENT (l->X_add_symbol) == S_GET_SEGMENT (r->X_add_symbol)
      && (SEG_NORMAL (S_GET_SEGMENT (l->X_add_symbol))
	  || r->X_add_symbol == l->X_add_symbol)
      && align_test_frag_offset_fixed_p (symbol_get_frag (l->X_add_symbol),
					 symbol_get_frag (r->X_add_symbol),
					 &frag_off))
    {
      offsetT symval_diff = S_GET_VALUE (l->X_add_symbol)
			    - S_GET_VALUE (r->X_add_symbol);
      subtract_from_result (l, r->X_add_number, r->X_extrabit);
      subtract_from_result (l, frag_off / OCTETS_PER_BYTE, 0);
      add_to_result (l, symval_diff, symval_diff < 0);
      l->X_op = O_constant;
      l->X_add_symbol = 0;
      return 1;
    }
  return 0;
}
#endif /* OBJ_ELF */

/* This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs.  */

void
md_begin (void)
{
  const sh_opcode_info *opcode;
  char *prev_name = "";
  unsigned int target_arch;

  target_arch
    = preset_target_arch ? preset_target_arch : arch_sh_up & ~arch_sh_has_dsp;
  valid_arch = target_arch;

#ifdef HAVE_SH64
  shmedia_md_begin ();
#endif

  opcode_hash_control = hash_new ();

  /* Insert unique names into hash table.  */
  for (opcode = sh_table; opcode->name; opcode++)
    {
      if (strcmp (prev_name, opcode->name) != 0)
	{
	  if (!SH_MERGE_ARCH_SET_VALID (opcode->arch, target_arch))
	    continue;
	  prev_name = opcode->name;
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	}
    }
}

static int reg_m;
static int reg_n;
static int reg_x, reg_y;
static int reg_efg;
static int reg_b;

#define IDENT_CHAR(c) (ISALNUM (c) || (c) == '_')

/* Try to parse a reg name.  Return the number of chars consumed.  */

static unsigned int
parse_reg_without_prefix (char *src, int *mode, int *reg)
{
  char l0 = TOLOWER (src[0]);
  char l1 = l0 ? TOLOWER (src[1]) : 0;

  /* We use ! IDENT_CHAR for the next character after the register name, to
     make sure that we won't accidentally recognize a symbol name such as
     'sram' or sr_ram as being a reference to the register 'sr'.  */

  if (l0 == 'r')
    {
      if (l1 == '1')
	{
	  if (src[2] >= '0' && src[2] <= '5'
	      && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = A_REG_N;
	      *reg = 10 + src[2] - '0';
	      return 3;
	    }
	}
      if (l1 >= '0' && l1 <= '9'
	  && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_REG_N;
	  *reg = (l1 - '0');
	  return 2;
	}
      if (l1 >= '0' && l1 <= '7' && strncasecmp (&src[2], "_bank", 5) == 0
	  && ! IDENT_CHAR ((unsigned char) src[7]))
	{
	  *mode = A_REG_B;
	  *reg  = (l1 - '0');
	  return 7;
	}

      if (l1 == 'e' && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_RE;
	  return 2;
	}
      if (l1 == 's' && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_RS;
	  return 2;
	}
    }

  if (l0 == 'a')
    {
      if (l1 == '0')
	{
	  if (! IDENT_CHAR ((unsigned char) src[2]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A0_NUM;
	      return 2;
	    }
	  if (TOLOWER (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A0G_NUM;
	      return 3;
	    }
	}
      if (l1 == '1')
	{
	  if (! IDENT_CHAR ((unsigned char) src[2]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A1_NUM;
	      return 2;
	    }
	  if (TOLOWER (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A1G_NUM;
	      return 3;
	    }
	}

      if (l1 == 'x' && src[2] >= '0' && src[2] <= '1'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = A_REG_N;
	  *reg = 4 + (l1 - '0');
	  return 3;
	}
      if (l1 == 'y' && src[2] >= '0' && src[2] <= '1'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = A_REG_N;
	  *reg = 6 + (l1 - '0');
	  return 3;
	}
      if (l1 == 's' && src[2] >= '0' && src[2] <= '3'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  int n = l1 - '0';

	  *mode = A_REG_N;
	  *reg = n | ((~n & 2) << 1);
	  return 3;
	}
    }

  if (l0 == 'i' && l1 && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      if (l1 == 's')
	{
	  *mode = A_REG_N;
	  *reg = 8;
	  return 2;
	}
      if (l1 == 'x')
	{
	  *mode = A_REG_N;
	  *reg = 8;
	  return 2;
	}
      if (l1 == 'y')
	{
	  *mode = A_REG_N;
	  *reg = 9;
	  return 2;
	}
    }

  if (l0 == 'x' && l1 >= '0' && l1 <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = A_X0_NUM + l1 - '0';
      return 2;
    }

  if (l0 == 'y' && l1 >= '0' && l1 <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = A_Y0_NUM + l1 - '0';
      return 2;
    }

  if (l0 == 'm' && l1 >= '0' && l1 <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = l1 == '0' ? A_M0_NUM : A_M1_NUM;
      return 2;
    }

  if (l0 == 's'
      && l1 == 's'
      && TOLOWER (src[2]) == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_SSR;
      return 3;
    }

  if (l0 == 's' && l1 == 'p' && TOLOWER (src[2]) == 'c'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_SPC;
      return 3;
    }

  if (l0 == 's' && l1 == 'g' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_SGR;
      return 3;
    }

  if (l0 == 'd' && l1 == 's' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_DSR;
      return 3;
    }

  if (l0 == 'd' && l1 == 'b' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_DBR;
      return 3;
    }

  if (l0 == 's' && l1 == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = A_SR;
      return 2;
    }

  if (l0 == 's' && l1 == 'p' && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = A_REG_N;
      *reg = 15;
      return 2;
    }

  if (l0 == 'p' && l1 == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = A_PR;
      return 2;
    }
  if (l0 == 'p' && l1 == 'c' && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      /* Don't use A_DISP_PC here - that would accept stuff like 'mova pc,r0'
         and use an uninitialized immediate.  */
      *mode = A_PC;
      return 2;
    }
  if (l0 == 'g' && l1 == 'b' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_GBR;
      return 3;
    }
  if (l0 == 'v' && l1 == 'b' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_VBR;
      return 3;
    }

  if (l0 == 't' && l1 == 'b' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_TBR;
      return 3;
    }
  if (l0 == 'm' && l1 == 'a' && TOLOWER (src[2]) == 'c'
      && ! IDENT_CHAR ((unsigned char) src[4]))
    {
      if (TOLOWER (src[3]) == 'l')
	{
	  *mode = A_MACL;
	  return 4;
	}
      if (TOLOWER (src[3]) == 'h')
	{
	  *mode = A_MACH;
	  return 4;
	}
    }
  if (l0 == 'm' && l1 == 'o' && TOLOWER (src[2]) == 'd'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_MOD;
      return 3;
    }
  if (l0 == 'f' && l1 == 'r')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '5'
	      && ! IDENT_CHAR ((unsigned char) src[4]))
	    {
	      *mode = F_REG_N;
	      *reg = 10 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '9'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = F_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
  if (l0 == 'd' && l1 == 'r')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '4' && ! ((src[3] - '0') & 1)
	      && ! IDENT_CHAR ((unsigned char) src[4]))
	    {
	      *mode = D_REG_N;
	      *reg = 10 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '8' && ! ((src[2] - '0') & 1)
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = D_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
  if (l0 == 'x' && l1 == 'd')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '4' && ! ((src[3] - '0') & 1)
	      && ! IDENT_CHAR ((unsigned char) src[4]))
	    {
	      *mode = X_REG_N;
	      *reg = 11 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '8' && ! ((src[2] - '0') & 1)
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = X_REG_N;
	  *reg = (src[2] - '0') + 1;
	  return 3;
	}
    }
  if (l0 == 'f' && l1 == 'v')
    {
      if (src[2] == '1'&& src[3] == '2' && ! IDENT_CHAR ((unsigned char) src[4]))
	{
	  *mode = V_REG_N;
	  *reg = 12;
	  return 4;
	}
      if ((src[2] == '0' || src[2] == '4' || src[2] == '8')
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = V_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
  if (l0 == 'f' && l1 == 'p' && TOLOWER (src[2]) == 'u'
      && TOLOWER (src[3]) == 'l'
      && ! IDENT_CHAR ((unsigned char) src[4]))
    {
      *mode = FPUL_N;
      return 4;
    }

  if (l0 == 'f' && l1 == 'p' && TOLOWER (src[2]) == 's'
      && TOLOWER (src[3]) == 'c'
      && TOLOWER (src[4]) == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
    {
      *mode = FPSCR_N;
      return 5;
    }

  if (l0 == 'x' && l1 == 'm' && TOLOWER (src[2]) == 't'
      && TOLOWER (src[3]) == 'r'
      && TOLOWER (src[4]) == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
    {
      *mode = XMTRX_M4;
      return 5;
    }

  return 0;
}

/* Like parse_reg_without_prefix, but this version supports
   $-prefixed register names if enabled by the user.  */

static unsigned int
parse_reg (char *src, int *mode, int *reg)
{
  unsigned int prefix;
  unsigned int consumed;

  if (src[0] == '$')
    {
      if (allow_dollar_register_prefix)
	{
	  src ++;
	  prefix = 1;
	}
      else
	return 0;
    }
  else
    prefix = 0;
  
  consumed = parse_reg_without_prefix (src, mode, reg);

  if (consumed == 0)
    return 0;

  return consumed + prefix;
}

static char *
parse_exp (char *s, sh_operand_info *op)
{
  char *save;
  char *new_pointer;

  save = input_line_pointer;
  input_line_pointer = s;
  expression (&op->immediate);
  if (op->immediate.X_op == O_absent)
    as_bad (_("missing operand"));
  new_pointer = input_line_pointer;
  input_line_pointer = save;
  return new_pointer;
}

/* The many forms of operand:

   Rn                   Register direct
   @@Rn                  Register indirect
   @@Rn+                 Autoincrement
   @@-Rn                 Autodecrement
   @@(disp:4,Rn)
   @@(disp:8,GBR)
   @@(disp:8,PC)

   @@(R0,Rn)
   @@(R0,GBR)

   disp:8
   disp:12
   #imm8
   pr, gbr, vbr, macl, mach
 */

static char *
parse_at (char *src, sh_operand_info *op)
{
  int len;
  int mode;
  src++;
  if (src[0] == '@@')
    {
      src = parse_at (src, op);
      if (op->type == A_DISP_TBR)
	op->type = A_DISP2_TBR;
      else
	as_bad (_("illegal double indirection"));
    }
  else if (src[0] == '-')
    {
      /* Must be predecrement.  */
      src++;

      len = parse_reg (src, &mode, &(op->reg));
      if (mode != A_REG_N)
	as_bad (_("illegal register after @@-"));

      op->type = A_DEC_N;
      src += len;
    }
  else if (src[0] == '(')
    {
      /* Could be @@(disp, rn), @@(disp, gbr), @@(disp, pc),  @@(r0, gbr) or
         @@(r0, rn).  */
      src++;
      len = parse_reg (src, &mode, &(op->reg));
      if (len && mode == A_REG_N)
	{
	  src += len;
	  if (op->reg != 0)
	    {
	      as_bad (_("must be @@(r0,...)"));
	    }
	  if (src[0] == ',')
	    {
	      src++;
	      /* Now can be rn or gbr.  */
	      len = parse_reg (src, &mode, &(op->reg));
	    }
	  else
	    {
	      len = 0;
	    }
	  if (len)
	    {
	      if (mode == A_GBR)
		{
		  op->type = A_R0_GBR;
		}
	      else if (mode == A_REG_N)
		{
		  op->type = A_IND_R0_REG_N;
		}
	      else
		{
		  as_bad (_("syntax error in @@(r0,...)"));
		}
	    }
	  else
	    {
	      as_bad (_("syntax error in @@(r0...)"));
	    }
	}
      else
	{
	  /* Must be an @@(disp,.. thing).  */
	  src = parse_exp (src, op);
	  if (src[0] == ',')
	    src++;
	  /* Now can be rn, gbr or pc.  */
	  len = parse_reg (src, &mode, &op->reg);
	  if (len)
	    {
	      if (mode == A_REG_N)
		{
		  op->type = A_DISP_REG_N;
		}
	      else if (mode == A_GBR)
		{
		  op->type = A_DISP_GBR;
		}
	      else if (mode == A_TBR)
		{
		  op->type = A_DISP_TBR;
		}
	      else if (mode == A_PC)
		{
		  /* We want @@(expr, pc) to uniformly address . + expr,
		     no matter if expr is a constant, or a more complex
		     expression, e.g. sym-. or sym1-sym2.
		     However, we also used to accept @@(sym,pc)
		     as addressing sym, i.e. meaning the same as plain sym.
		     Some existing code does use the @@(sym,pc) syntax, so
		     we give it the old semantics for now, but warn about
		     its use, so that users have some time to fix their code.

		     Note that due to this backward compatibility hack,
		     we'll get unexpected results when @@(offset, pc) is used,
		     and offset is a symbol that is set later to an an address
		     difference, or an external symbol that is set to an
		     address difference in another source file, so we want to
		     eventually remove it.  */
		  if (op->immediate.X_op == O_symbol)
		    {
		      op->type = A_DISP_PC;
		      as_warn (_("Deprecated syntax."));
		    }
		  else
		    {
		      op->type = A_DISP_PC_ABS;
		      /* Such operands don't get corrected for PC==.+4, so
			 make the correction here.  */
		      op->immediate.X_add_number -= 4;
		    }
		}
	      else
		{
		  as_bad (_("syntax error in @@(disp,[Rn, gbr, pc])"));
		}
	    }
	  else
	    {
	      as_bad (_("syntax error in @@(disp,[Rn, gbr, pc])"));
	    }
	}
      src += len;
      if (src[0] != ')')
	as_bad (_("expecting )"));
      else
	src++;
    }
  else
    {
      src += parse_reg (src, &mode, &(op->reg));
      if (mode != A_REG_N)
	as_bad (_("illegal register after @@"));

      if (src[0] == '+')
	{
	  char l0, l1;

	  src++;
	  l0 = TOLOWER (src[0]);
	  l1 = TOLOWER (src[1]);

	  if ((l0 == 'r' && l1 == '8')
	      || (l0 == 'i' && (l1 == 'x' || l1 == 's')))
	    {
	      src += 2;
	      op->type = AX_PMOD_N;
	    }
	  else if (   (l0 == 'r' && l1 == '9')
		   || (l0 == 'i' && l1 == 'y'))
	    {
	      src += 2;
	      op->type = AY_PMOD_N;
	    }
	  else
	    op->type = A_INC_N;
	}
      else
	op->type = A_IND_N;
    }
  return src;
}

static void
get_operand (char **ptr, sh_operand_info *op)
{
  char *src = *ptr;
  int mode = -1;
  unsigned int len;

  if (src[0] == '#')
    {
      src++;
      *ptr = parse_exp (src, op);
      op->type = A_IMM;
      return;
    }

  else if (src[0] == '@@')
    {
      *ptr = parse_at (src, op);
      return;
    }
  len = parse_reg (src, &mode, &(op->reg));
  if (len)
    {
      *ptr = src + len;
      op->type = mode;
      return;
    }
  else
    {
      /* Not a reg, the only thing left is a displacement.  */
      *ptr = parse_exp (src, op);
      op->type = A_DISP_PC;
      return;
    }
}

static char *
get_operands (sh_opcode_info *info, char *args, sh_operand_info *operand)
{
  char *ptr = args;
  if (info->arg[0])
    {
      /* The pre-processor will eliminate whitespace in front of '@@'
	 after the first argument; we may be called multiple times
	 from assemble_ppi, so don't insist on finding whitespace here.  */
      if (*ptr == ' ')
	ptr++;

      get_operand (&ptr, operand + 0);
      if (info->arg[1])
	{
	  if (*ptr == ',')
	    {
	      ptr++;
	    }
	  get_operand (&ptr, operand + 1);
	  /* ??? Hack: psha/pshl have a varying operand number depending on
	     the type of the first operand.  We handle this by having the
	     three-operand version first and reducing the number of operands
	     parsed to two if we see that the first operand is an immediate.
             This works because no insn with three operands has an immediate
	     as first operand.  */
	  if (info->arg[2] && operand[0].type != A_IMM)
	    {
	      if (*ptr == ',')
		{
		  ptr++;
		}
	      get_operand (&ptr, operand + 2);
	    }
	  else
	    {
	      operand[2].type = 0;
	    }
	}
      else
	{
	  operand[1].type = 0;
	  operand[2].type = 0;
	}
    }
  else
    {
      operand[0].type = 0;
      operand[1].type = 0;
      operand[2].type = 0;
    }
  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

static sh_opcode_info *
get_specific (sh_opcode_info *opcode, sh_operand_info *operands)
{
  sh_opcode_info *this_try = opcode;
  char *name = opcode->name;
  int n = 0;

  while (opcode->name)
    {
      this_try = opcode++;
      if ((this_try->name != name) && (strcmp (this_try->name, name) != 0))
	{
	  /* We've looked so far down the table that we've run out of
	     opcodes with the same name.  */
	  return 0;
	}

      /* Look at both operands needed by the opcodes and provided by
         the user - since an arg test will often fail on the same arg
         again and again, we'll try and test the last failing arg the
         first on each opcode try.  */
      for (n = 0; this_try->arg[n]; n++)
	{
	  sh_operand_info *user = operands + n;
	  sh_arg_type arg = this_try->arg[n];

	  switch (arg)
	    {
	    case A_DISP_PC:
	      if (user->type == A_DISP_PC_ABS)
		break;
	      /* Fall through.  */
	    case A_IMM:
	    case A_BDISP12:
	    case A_BDISP8:
	    case A_DISP_GBR:
	    case A_DISP2_TBR:
	    case A_MACH:
	    case A_PR:
	    case A_MACL:
	      if (user->type != arg)
		goto fail;
	      break;
	    case A_R0:
	      /* opcode needs r0 */
	      if (user->type != A_REG_N || user->reg != 0)
		goto fail;
	      break;
	    case A_R0_GBR:
	      if (user->type != A_R0_GBR || user->reg != 0)
		goto fail;
	      break;
	    case F_FR0:
	      if (user->type != F_REG_N || user->reg != 0)
		goto fail;
	      break;

	    case A_REG_N:
	    case A_INC_N:
	    case A_DEC_N:
	    case A_IND_N:
	    case A_IND_R0_REG_N:
	    case A_DISP_REG_N:
	    case F_REG_N:
	    case D_REG_N:
	    case X_REG_N:
	    case V_REG_N:
	    case FPUL_N:
	    case FPSCR_N:
	    case DSP_REG_N:
	      /* Opcode needs rn */
	      if (user->type != arg)
		goto fail;
	      reg_n = user->reg;
	      break;
	    case DX_REG_N:
	      if (user->type != D_REG_N && user->type != X_REG_N)
		goto fail;
	      reg_n = user->reg;
	      break;
	    case A_GBR:
	    case A_TBR:
	    case A_SR:
	    case A_VBR:
	    case A_DSR:
	    case A_MOD:
	    case A_RE:
	    case A_RS:
	    case A_SSR:
	    case A_SPC:
	    case A_SGR:
	    case A_DBR:
	      if (user->type != arg)
		goto fail;
	      break;

	    case A_REG_B:
	      if (user->type != arg)
		goto fail;
	      reg_b = user->reg;
	      break;

	    case A_INC_R15:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg != 15)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case A_DEC_R15:
	      if (user->type != A_DEC_N)
		goto fail;
	      if (user->reg != 15)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case A_REG_M:
	    case A_INC_M:
	    case A_DEC_M:
	    case A_IND_M:
	    case A_IND_R0_REG_M:
	    case A_DISP_REG_M:
	    case DSP_REG_M:
	      /* Opcode needs rn */
	      if (user->type != arg - A_REG_M + A_REG_N)
		goto fail;
	      reg_m = user->reg;
	      break;

	    case AS_DEC_N:
	      if (user->type != A_DEC_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AS_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AS_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AS_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AX_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AX_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AX_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AXY_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AXY_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AXY_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AY_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AY_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AY_PMOD_N:
	      if (user->type != AY_PMOD_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AYX_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AYX_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AYX_PMOD_N:
	      if (user->type != AY_PMOD_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;

	    case DSP_REG_A_M:
	      if (user->type != DSP_REG_N)
		goto fail;
	      if (user->reg != A_A0_NUM
		  && user->reg != A_A1_NUM)
		goto fail;
	      reg_m = user->reg;
	      break;

	    case DSP_REG_AX:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_A0_NUM:
		  reg_x = 0;
		  break;
		case A_A1_NUM:
		  reg_x = 2;
		  break;
		case A_X0_NUM:
		  reg_x = 1;
		  break;
		case A_X1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_XY:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_x = 0;
		  break;
		case A_X1_NUM:
		  reg_x = 2;
		  break;
		case A_Y0_NUM:
		  reg_x = 1;
		  break;
		case A_Y1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_AY:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_A0_NUM:
		  reg_y = 0;
		  break;
		case A_A1_NUM:
		  reg_y = 1;
		  break;
		case A_Y0_NUM:
		  reg_y = 2;
		  break;
		case A_Y1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_YX:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_y = 0;
		  break;
		case A_Y1_NUM:
		  reg_y = 1;
		  break;
		case A_X0_NUM:
		  reg_y = 2;
		  break;
		case A_X1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_X:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_x = 0;
		  break;
		case A_X1_NUM:
		  reg_x = 1;
		  break;
		case A_A0_NUM:
		  reg_x = 2;
		  break;
		case A_A1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_Y:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_y = 0;
		  break;
		case A_Y1_NUM:
		  reg_y = 1;
		  break;
		case A_M0_NUM:
		  reg_y = 2;
		  break;
		case A_M1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_E:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_efg = 0 << 10;
		  break;
		case A_X1_NUM:
		  reg_efg = 1 << 10;
		  break;
		case A_Y0_NUM:
		  reg_efg = 2 << 10;
		  break;
		case A_A1_NUM:
		  reg_efg = 3 << 10;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_F:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_efg |= 0 << 8;
		  break;
		case A_Y1_NUM:
		  reg_efg |= 1 << 8;
		  break;
		case A_X0_NUM:
		  reg_efg |= 2 << 8;
		  break;
		case A_A1_NUM:
		  reg_efg |= 3 << 8;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_G:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_M0_NUM:
		  reg_efg |= 0 << 2;
		  break;
		case A_M1_NUM:
		  reg_efg |= 1 << 2;
		  break;
		case A_A0_NUM:
		  reg_efg |= 2 << 2;
		  break;
		case A_A1_NUM:
		  reg_efg |= 3 << 2;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case A_A0:
	      if (user->type != DSP_REG_N || user->reg != A_A0_NUM)
		goto fail;
	      break;
	    case A_X0:
	      if (user->type != DSP_REG_N || user->reg != A_X0_NUM)
		goto fail;
	      break;
	    case A_X1:
	      if (user->type != DSP_REG_N || user->reg != A_X1_NUM)
		goto fail;
	      break;
	    case A_Y0:
	      if (user->type != DSP_REG_N || user->reg != A_Y0_NUM)
		goto fail;
	      break;
	    case A_Y1:
	      if (user->type != DSP_REG_N || user->reg != A_Y1_NUM)
		goto fail;
	      break;

	    case F_REG_M:
	    case D_REG_M:
	    case X_REG_M:
	    case V_REG_M:
	    case FPUL_M:
	    case FPSCR_M:
	      /* Opcode needs rn */
	      if (user->type != arg - F_REG_M + F_REG_N)
		goto fail;
	      reg_m = user->reg;
	      break;
	    case DX_REG_M:
	      if (user->type != D_REG_N && user->type != X_REG_N)
		goto fail;
	      reg_m = user->reg;
	      break;
	    case XMTRX_M4:
	      if (user->type != XMTRX_M4)
		goto fail;
	      reg_m = 4;
	      break;

	    default:
	      printf (_("unhandled %d\n"), arg);
	      goto fail;
	    }
	  if (SH_MERGE_ARCH_SET_VALID (valid_arch, arch_sh2a_nofpu_up)
	      && (   arg == A_DISP_REG_M
		  || arg == A_DISP_REG_N))
	    {
	      /* Check a few key IMM* fields for overflow.  */
	      int opf;
	      long val = user->immediate.X_add_number;

	      for (opf = 0; opf < 4; opf ++)
		switch (this_try->nibbles[opf])
		  {
		  case IMM0_4:
		  case IMM1_4:
		    if (val < 0 || val > 15)
		      goto fail;
		    break;
		  case IMM0_4BY2:
		  case IMM1_4BY2:
		    if (val < 0 || val > 15 * 2)
		      goto fail;
		    break;
		  case IMM0_4BY4:
		  case IMM1_4BY4:
		    if (val < 0 || val > 15 * 4)
		      goto fail;
		    break;
		  default:
		    break;
		  }
	    }
	}
      if ( !SH_MERGE_ARCH_SET_VALID (valid_arch, this_try->arch))
	goto fail;
      valid_arch = SH_MERGE_ARCH_SET (valid_arch, this_try->arch);
      return this_try;
    fail:
      ;
    }

  return 0;
}

static void
insert (char *where, int how, int pcrel, sh_operand_info *op)
{
  fix_new_exp (frag_now,
	       where - frag_now->fr_literal,
	       2,
	       &op->immediate,
	       pcrel,
	       how);
}

static void
insert4 (char * where, int how, int pcrel, sh_operand_info * op)
{
  fix_new_exp (frag_now,
	       where - frag_now->fr_literal,
	       4,
	       & op->immediate,
	       pcrel,
	       how);
}
static void
build_relax (sh_opcode_info *opcode, sh_operand_info *op)
{
  int high_byte = target_big_endian ? 0 : 1;
  char *p;

  if (opcode->arg[0] == A_BDISP8)
    {
      int what = (opcode->nibbles[1] & 4) ? COND_JUMP_DELAY : COND_JUMP;
      p = frag_var (rs_machine_dependent,
		    md_relax_table[C (what, COND32)].rlx_length,
		    md_relax_table[C (what, COND8)].rlx_length,
		    C (what, 0),
		    op->immediate.X_add_symbol,
		    op->immediate.X_add_number,
		    0);
      p[high_byte] = (opcode->nibbles[0] << 4) | (opcode->nibbles[1]);
    }
  else if (opcode->arg[0] == A_BDISP12)
    {
      p = frag_var (rs_machine_dependent,
		    md_relax_table[C (UNCOND_JUMP, UNCOND32)].rlx_length,
		    md_relax_table[C (UNCOND_JUMP, UNCOND12)].rlx_length,
		    C (UNCOND_JUMP, 0),
		    op->immediate.X_add_symbol,
		    op->immediate.X_add_number,
		    0);
      p[high_byte] = (opcode->nibbles[0] << 4);
    }

}

/* Insert ldrs & ldre with fancy relocations that relaxation can recognize.  */

static char *
insert_loop_bounds (char *output, sh_operand_info *operand)
{
  char *name;
  symbolS *end_sym;

  /* Since the low byte of the opcode will be overwritten by the reloc, we
     can just stash the high byte into both bytes and ignore endianness.  */
  output[0] = 0x8c;
  output[1] = 0x8c;
  insert (output, BFD_RELOC_SH_LOOP_START, 1, operand);
  insert (output, BFD_RELOC_SH_LOOP_END, 1, operand + 1);

  if (sh_relax)
    {
      static int count = 0;

      /* If the last loop insn is a two-byte-insn, it is in danger of being
	 swapped with the insn after it.  To prevent this, create a new
	 symbol - complete with SH_LABEL reloc - after the last loop insn.
	 If the last loop insn is four bytes long, the symbol will be
	 right in the middle, but four byte insns are not swapped anyways.  */
      /* A REPEAT takes 6 bytes.  The SH has a 32 bit address space.
	 Hence a 9 digit number should be enough to count all REPEATs.  */
      name = alloca (11);
      sprintf (name, "_R%x", count++ & 0x3fffffff);
      end_sym = symbol_new (name, undefined_section, 0, &zero_address_frag);
      /* Make this a local symbol.  */
#ifdef OBJ_COFF
      SF_SET_LOCAL (end_sym);
#endif /* OBJ_COFF */
      symbol_table_insert (end_sym);
      end_sym->sy_value = operand[1].immediate;
      end_sym->sy_value.X_add_number += 2;
      fix_new (frag_now, frag_now_fix (), 2, end_sym, 0, 1, BFD_RELOC_SH_LABEL);
    }

  output = frag_more (2);
  output[0] = 0x8e;
  output[1] = 0x8e;
  insert (output, BFD_RELOC_SH_LOOP_START, 1, operand);
  insert (output, BFD_RELOC_SH_LOOP_END, 1, operand + 1);

  return frag_more (2);
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static unsigned int
build_Mytes (sh_opcode_info *opcode, sh_operand_info *operand)
{
  int indx;
  char nbuf[8];
  char *output;
  unsigned int size = 2;
  int low_byte = target_big_endian ? 1 : 0;
  int max_index = 4;
  bfd_reloc_code_real_type r_type;
#ifdef OBJ_ELF
  int unhandled_pic = 0;
#endif

  nbuf[0] = 0;
  nbuf[1] = 0;
  nbuf[2] = 0;
  nbuf[3] = 0;
  nbuf[4] = 0;
  nbuf[5] = 0;
  nbuf[6] = 0;
  nbuf[7] = 0;

#ifdef OBJ_ELF
  for (indx = 0; indx < 3; indx++)
    if (opcode->arg[indx] == A_IMM
	&& operand[indx].type == A_IMM
	&& (operand[indx].immediate.X_op == O_PIC_reloc
	    || sh_PIC_related_p (operand[indx].immediate.X_add_symbol)
	    || sh_PIC_related_p (operand[indx].immediate.X_op_symbol)))
      unhandled_pic = 1;
#endif

  if (SH_MERGE_ARCH_SET (opcode->arch, arch_op32))
    {
      output = frag_more (4);
      size = 4;
      max_index = 8;
    }
  else
    output = frag_more (2);

  for (indx = 0; indx < max_index; indx++)
    {
      sh_nibble_type i = opcode->nibbles[indx];
      if (i < 16)
	{
	  nbuf[indx] = i;
	}
      else
	{
	  switch (i)
	    {
	    case REG_N:
	    case REG_N_D:
	      nbuf[indx] = reg_n;
	      break;
	    case REG_M:
	      nbuf[indx] = reg_m;
	      break;
	    case SDT_REG_N:
	      if (reg_n < 2 || reg_n > 5)
		as_bad (_("Invalid register: 'r%d'"), reg_n);
	      nbuf[indx] = (reg_n & 3) | 4;
	      break;
	    case REG_NM:
	      nbuf[indx] = reg_n | (reg_m >> 2);
	      break;
	    case REG_B:
	      nbuf[indx] = reg_b | 0x08;
	      break;
	    case REG_N_B01:
	      nbuf[indx] = reg_n | 0x01;
	      break;
	    case IMM0_3s:
	      nbuf[indx] |= 0x08;
	    case IMM0_3c:
	      insert (output + low_byte, BFD_RELOC_SH_IMM3, 0, operand);
	      break;
	    case IMM0_3Us:
	      nbuf[indx] |= 0x80;
	    case IMM0_3Uc:
	      insert (output + low_byte, BFD_RELOC_SH_IMM3U, 0, operand);
	      break;
	    case DISP0_12:
	      insert (output + 2, BFD_RELOC_SH_DISP12, 0, operand);
	      break;
	    case DISP0_12BY2:
	      insert (output + 2, BFD_RELOC_SH_DISP12BY2, 0, operand);
	      break;
	    case DISP0_12BY4:
	      insert (output + 2, BFD_RELOC_SH_DISP12BY4, 0, operand);
	      break;
	    case DISP0_12BY8:
	      insert (output + 2, BFD_RELOC_SH_DISP12BY8, 0, operand);
	      break;
	    case DISP1_12:
	      insert (output + 2, BFD_RELOC_SH_DISP12, 0, operand+1);
	      break;
	    case DISP1_12BY2:
	      insert (output + 2, BFD_RELOC_SH_DISP12BY2, 0, operand+1);
	      break;
	    case DISP1_12BY4:
	      insert (output + 2, BFD_RELOC_SH_DISP12BY4, 0, operand+1);
	      break;
	    case DISP1_12BY8:
	      insert (output + 2, BFD_RELOC_SH_DISP12BY8, 0, operand+1);
	      break;
	    case IMM0_20_4:
	      break;
	    case IMM0_20:
	      r_type = BFD_RELOC_SH_DISP20;
#ifdef OBJ_ELF
	      if (sh_check_fixup (&operand->immediate, &r_type))
		as_bad (_("Invalid PIC expression."));
	      unhandled_pic = 0;
#endif
	      insert4 (output, r_type, 0, operand);
	      break;
	    case IMM0_20BY8:
	      insert4 (output, BFD_RELOC_SH_DISP20BY8, 0, operand);
	      break;
	    case IMM0_4BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0, operand);
	      break;
	    case IMM0_4BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0, operand);
	      break;
	    case IMM0_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0, operand);
	      break;
	    case IMM1_4BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0, operand + 1);
	      break;
	    case IMM1_4BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0, operand + 1);
	      break;
	    case IMM1_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0, operand + 1);
	      break;
	    case IMM0_8BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0, operand);
	      break;
	    case IMM0_8BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0, operand);
	      break;
	    case IMM0_8:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0, operand);
	      break;
	    case IMM1_8BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0, operand + 1);
	      break;
	    case IMM1_8BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0, operand + 1);
	      break;
	    case IMM1_8:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0, operand + 1);
	      break;
	    case PCRELIMM_8BY4:
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4,
		      operand->type != A_DISP_PC_ABS, operand);
	      break;
	    case PCRELIMM_8BY2:
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2,
		      operand->type != A_DISP_PC_ABS, operand);
	      break;
	    case REPEAT:
	      output = insert_loop_bounds (output, operand);
	      nbuf[indx] = opcode->nibbles[3];
	      operand += 2;
	      break;
	    default:
	      printf (_("failed for %d\n"), i);
	    }
	}
    }
#ifdef OBJ_ELF
  if (unhandled_pic)
    as_bad (_("misplaced PIC operand"));
#endif
  if (!target_big_endian)
    {
      output[1] = (nbuf[0] << 4) | (nbuf[1]);
      output[0] = (nbuf[2] << 4) | (nbuf[3]);
    }
  else
    {
      output[0] = (nbuf[0] << 4) | (nbuf[1]);
      output[1] = (nbuf[2] << 4) | (nbuf[3]);
    }
  if (SH_MERGE_ARCH_SET (opcode->arch, arch_op32))
    {
      if (!target_big_endian)
	{
	  output[3] = (nbuf[4] << 4) | (nbuf[5]);
	  output[2] = (nbuf[6] << 4) | (nbuf[7]);
	}
      else
	{
	  output[2] = (nbuf[4] << 4) | (nbuf[5]);
	  output[3] = (nbuf[6] << 4) | (nbuf[7]);
	}
    }
  return size;
}

/* Find an opcode at the start of *STR_P in the hash table, and set
   *STR_P to the first character after the last one read.  */

static sh_opcode_info *
find_cooked_opcode (char **str_p)
{
  char *str = *str_p;
  unsigned char *op_start;
  unsigned char *op_end;
  char name[20];
  unsigned int nlen = 0;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.
     The pre-processor will eliminate whitespace in front of
     any '@@' after the first argument; we may be called from
     assemble_ppi, so the opcode might be terminated by an '@@'.  */
  for (op_start = op_end = (unsigned char *) str;
       *op_end
       && nlen < sizeof (name) - 1
       && !is_end_of_line[*op_end] && *op_end != ' ' && *op_end != '@@';
       op_end++)
    {
      unsigned char c = op_start[nlen];

      /* The machine independent code will convert CMP/EQ into cmp/EQ
	 because it thinks the '/' is the end of the symbol.  Moreover,
	 all but the first sub-insn is a parallel processing insn won't
	 be capitalized.  Instead of hacking up the machine independent
	 code, we just deal with it here.  */
      c = TOLOWER (c);
      name[nlen] = c;
      nlen++;
    }

  name[nlen] = 0;
  *str_p = (char *) op_end;

  if (nlen == 0)
    as_bad (_("can't find opcode "));

  return (sh_opcode_info *) hash_find (opcode_hash_control, name);
}

/* Assemble a parallel processing insn.  */
#define DDT_BASE 0xf000 /* Base value for double data transfer insns */

static unsigned int
assemble_ppi (char *op_end, sh_opcode_info *opcode)
{
  int movx = 0;
  int movy = 0;
  int cond = 0;
  int field_b = 0;
  char *output;
  int move_code;
  unsigned int size;

  for (;;)
    {
      sh_operand_info operand[3];

      /* Some insn ignore one or more register fields, e.g. psts machl,a0.
	 Make sure we encode a defined insn pattern.  */
      reg_x = 0;
      reg_y = 0;
      reg_n = 0;

      if (opcode->arg[0] != A_END)
	op_end = get_operands (opcode, op_end, operand);
    try_another_opcode:
      opcode = get_specific (opcode, operand);
      if (opcode == 0)
	{
	  /* Couldn't find an opcode which matched the operands.  */
	  char *where = frag_more (2);
	  size = 2;

	  where[0] = 0x0;
	  where[1] = 0x0;
	  as_bad (_("invalid operands for opcode"));
	  return size;
	}

      if (opcode->nibbles[0] != PPI)
	as_bad (_("insn can't be combined with parallel processing insn"));

      switch (opcode->nibbles[1])
	{

	case NOPX:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  movx = DDT_BASE;
	  break;
	case NOPY:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  movy = DDT_BASE;
	  break;

	case MOVX_NOPY:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  if ((reg_n < 4 || reg_n > 5)
	      && (reg_n < 0 || reg_n > 1))
	    as_bad (_("invalid movx address register"));
	  if (movy && movy != DDT_BASE)
	    as_bad (_("insn cannot be combined with non-nopy"));
	  movx = ((((reg_n & 1) != 0) << 9)
		  + (((reg_n & 4) == 0) << 8)
		  + (reg_x << 6)
		  + (opcode->nibbles[2] << 4)
		  + opcode->nibbles[3]
		  + DDT_BASE);
	  break;

	case MOVY_NOPX:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  if ((reg_n < 6 || reg_n > 7)
	      && (reg_n < 2 || reg_n > 3))
	    as_bad (_("invalid movy address register"));
	  if (movx && movx != DDT_BASE)
	    as_bad (_("insn cannot be combined with non-nopx"));
	  movy = ((((reg_n & 1) != 0) << 8)
		  + (((reg_n & 4) == 0) << 9)
		  + (reg_y << 6)
		  + (opcode->nibbles[2] << 4)
		  + opcode->nibbles[3]
		  + DDT_BASE);
	  break;

	case MOVX:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  if (movy & 0x2ac)
	    as_bad (_("previous movy requires nopx"));
	  if (reg_n < 4 || reg_n > 5)
	    as_bad (_("invalid movx address register"));
	  if (opcode->nibbles[2] & 8)
	    {
	      if (reg_m == A_A1_NUM)
		movx = 1 << 7;
	      else if (reg_m != A_A0_NUM)
		as_bad (_("invalid movx dsp register"));
	    }
	  else
	    {
	      if (reg_x > 1)
		as_bad (_("invalid movx dsp register"));
	      movx = reg_x << 7;
	    }
	  movx += ((reg_n - 4) << 9) + (opcode->nibbles[2] << 2) + DDT_BASE;
	  break;

	case MOVY:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  if (movx & 0x153)
	    as_bad (_("previous movx requires nopy"));
	  if (opcode->nibbles[2] & 8)
	    {
	      /* Bit 3 in nibbles[2] is intended for bit 4 of the opcode,
		 so add 8 more.  */
	      movy = 8;
	      if (reg_m == A_A1_NUM)
		movy += 1 << 6;
	      else if (reg_m != A_A0_NUM)
		as_bad (_("invalid movy dsp register"));
	    }
	  else
	    {
	      if (reg_y > 1)
		as_bad (_("invalid movy dsp register"));
	      movy = reg_y << 6;
	    }
	  if (reg_n < 6 || reg_n > 7)
	    as_bad (_("invalid movy address register"));
	  movy += ((reg_n - 6) << 8) + opcode->nibbles[2] + DDT_BASE;
	  break;

	case PSH:
	  if (operand[0].immediate.X_op != O_constant)
	    as_bad (_("dsp immediate shift value not constant"));
	  field_b = ((opcode->nibbles[2] << 12)
		     | (operand[0].immediate.X_add_number & 127) << 4
		     | reg_n);
	  break;
	case PPI3NC:
	  if (cond)
	    {
	      opcode++;
	      goto try_another_opcode;
	    }
	  /* Fall through.  */
	case PPI3:
	  if (field_b)
	    as_bad (_("multiple parallel processing specifications"));
	  field_b = ((opcode->nibbles[2] << 12) + (opcode->nibbles[3] << 8)
		     + (reg_x << 6) + (reg_y << 4) + reg_n);
	  switch (opcode->nibbles[4])
	    {
	    case HEX_0:
	    case HEX_XX00:
	    case HEX_00YY:
	      break;
	    case HEX_1:
	    case HEX_4:
	      field_b += opcode->nibbles[4] << 4;
	      break;
	    default:
	      abort ();
	    }
	  break;
	case PDC:
	  if (cond)
	    as_bad (_("multiple condition specifications"));
	  cond = opcode->nibbles[2] << 8;
	  if (*op_end)
	    goto skip_cond_check;
	  break;
	case PPIC:
	  if (field_b)
	    as_bad (_("multiple parallel processing specifications"));
	  field_b = ((opcode->nibbles[2] << 12) + (opcode->nibbles[3] << 8)
		     + cond + (reg_x << 6) + (reg_y << 4) + reg_n);
	  cond = 0;
	  switch (opcode->nibbles[4])
	    {
	    case HEX_0:
	    case HEX_XX00:
	    case HEX_00YY:
	      break;
	    case HEX_1:
	    case HEX_4:
	      field_b += opcode->nibbles[4] << 4;
	      break;
	    default:
	      abort ();
	    }
	  break;
	case PMUL:
	  if (field_b)
	    {
	      if ((field_b & 0xef00) == 0xa100)
		field_b -= 0x8100;
	      /* pclr Dz pmuls Se,Sf,Dg */
	      else if ((field_b & 0xff00) == 0x8d00
		       && (SH_MERGE_ARCH_SET_VALID (valid_arch, arch_sh4al_dsp_up)))
		{
		  valid_arch = SH_MERGE_ARCH_SET (valid_arch, arch_sh4al_dsp_up);
		  field_b -= 0x8cf0;
		}
	      else
		as_bad (_("insn cannot be combined with pmuls"));
	      switch (field_b & 0xf)
		{
		case A_X0_NUM:
		  field_b += 0 - A_X0_NUM;
		  break;
		case A_Y0_NUM:
		  field_b += 1 - A_Y0_NUM;
		  break;
		case A_A0_NUM:
		  field_b += 2 - A_A0_NUM;
		  break;
		case A_A1_NUM:
		  field_b += 3 - A_A1_NUM;
		  break;
		default:
		  as_bad (_("bad combined pmuls output operand"));
		}
		/* Generate warning if the destination register for padd / psub
		   and pmuls is the same ( only for A0 or A1 ).
		   If the last nibble is 1010 then A0 is used in both
		   padd / psub and pmuls. If it is 1111 then A1 is used
		   as destination register in both padd / psub and pmuls.  */

		if ((((field_b | reg_efg) & 0x000F) == 0x000A)
		    || (((field_b | reg_efg) & 0x000F) == 0x000F))
		  as_warn (_("destination register is same for parallel insns"));
	    }
	  field_b += 0x4000 + reg_efg;
	  break;
	default:
	  abort ();
	}
      if (cond)
	{
	  as_bad (_("condition not followed by conditionalizable insn"));
	  cond = 0;
	}
      if (! *op_end)
	break;
    skip_cond_check:
      opcode = find_cooked_opcode (&op_end);
      if (opcode == NULL)
	{
	  (as_bad
	   (_("unrecognized characters at end of parallel processing insn")));
	  break;
	}
    }

  move_code = movx | movy;
  if (field_b)
    {
      /* Parallel processing insn.  */
      unsigned long ppi_code = (movx | movy | 0xf800) << 16 | field_b;

      output = frag_more (4);
      size = 4;
      if (! target_big_endian)
	{
	  output[3] = ppi_code >> 8;
	  output[2] = ppi_code;
	}
      else
	{
	  output[2] = ppi_code >> 8;
	  output[3] = ppi_code;
	}
      move_code |= 0xf800;
    }
  else
    {
      /* Just a double data transfer.  */
      output = frag_more (2);
      size = 2;
    }
  if (! target_big_endian)
    {
      output[1] = move_code >> 8;
      output[0] = move_code;
    }
  else
    {
      output[0] = move_code >> 8;
      output[1] = move_code;
    }
  return size;
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char *str)
{
  char *op_end;
  sh_operand_info operand[3];
  sh_opcode_info *opcode;
  unsigned int size = 0;
  char *initial_str = str;

#ifdef HAVE_SH64
  if (sh64_isa_mode == sh64_isa_shmedia)
    {
      shmedia_md_assemble (str);
      return;
    }
  else
    {
      /* If we've seen pseudo-directives, make sure any emitted data or
	 frags are marked as data.  */
      if (!seen_insn)
	{
	  sh64_update_contents_mark (TRUE);
	  sh64_set_contents_type (CRT_SH5_ISA16);
	}

      seen_insn = TRUE;
    }
#endif /* HAVE_SH64 */

  opcode = find_cooked_opcode (&str);
  op_end = str;

  if (opcode == NULL)
    {
      /* The opcode is not in the hash table.
	 This means we definitely have an assembly failure,
	 but the instruction may be valid in another CPU variant.
	 In this case emit something better than 'unknown opcode'.
	 Search the full table in sh-opc.h to check. */

      char *name = initial_str;
      int name_length = 0;
      const sh_opcode_info *op;
      int found = 0;

      /* identify opcode in string */
      while (ISSPACE (*name))
	{
	  name++;
	}
      while (!ISSPACE (name[name_length]))
	{
	  name_length++;
	}

      /* search for opcode in full list */
      for (op = sh_table; op->name; op++)
	{
	  if (strncasecmp (op->name, name, name_length) == 0
	      && op->name[name_length] == '\0')
	    {
	      found = 1;
	      break;
	    }
	}

      if ( found )
	{
	  as_bad (_("opcode not valid for this cpu variant"));
	}
      else
	{
	  as_bad (_("unknown opcode"));
	}
      return;
    }

  if (sh_relax
      && ! seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      /* Output a CODE reloc to tell the linker that the following
         bytes are instructions, not data.  */
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0,
	       BFD_RELOC_SH_CODE);
      seg_info (now_seg)->tc_segment_info_data.in_code = 1;
    }

  if (opcode->nibbles[0] == PPI)
    {
      size = assemble_ppi (op_end, opcode);
    }
  else
    {
      if (opcode->arg[0] == A_BDISP12
	  || opcode->arg[0] == A_BDISP8)
	{
	  /* Since we skip get_specific here, we have to check & update
	     valid_arch now.  */
	  if (SH_MERGE_ARCH_SET_VALID (valid_arch, opcode->arch))
	    valid_arch = SH_MERGE_ARCH_SET (valid_arch, opcode->arch);
	  else
	    as_bad (_("Delayed branches not available on SH1"));
	  parse_exp (op_end + 1, &operand[0]);
	  build_relax (opcode, &operand[0]);

	  /* All branches are currently 16 bit.  */
	  size = 2;
	}
      else
	{
	  if (opcode->arg[0] == A_END)
	    {
	      /* Ignore trailing whitespace.  If there is any, it has already
		 been compressed to a single space.  */
	      if (*op_end == ' ')
		op_end++;
	    }
	  else
	    {
	      op_end = get_operands (opcode, op_end, operand);
	    }
	  opcode = get_specific (opcode, operand);

	  if (opcode == 0)
	    {
	      /* Couldn't find an opcode which matched the operands.  */
	      char *where = frag_more (2);
	      size = 2;

	      where[0] = 0x0;
	      where[1] = 0x0;
	      as_bad (_("invalid operands for opcode"));
	    }
	  else
	    {
	      if (*op_end)
		as_bad (_("excess operands: '%s'"), op_end);

	      size = build_Mytes (opcode, operand);
	    }
	}
    }

  dwarf2_emit_insn (size);
}

/* This routine is called each time a label definition is seen.  It
   emits a BFD_RELOC_SH_LABEL reloc if necessary.  */

void
sh_frob_label (symbolS *sym)
{
  static fragS *last_label_frag;
  static int last_label_offset;

  if (sh_relax
      && seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      int offset;

      offset = frag_now_fix ();
      if (frag_now != last_label_frag
	  || offset != last_label_offset)
	{
	  fix_new (frag_now, offset, 2, &abs_symbol, 0, 0, BFD_RELOC_SH_LABEL);
	  last_label_frag = frag_now;
	  last_label_offset = offset;
	}
    }

  dwarf2_emit_label (sym);
}

/* This routine is called when the assembler is about to output some
   data.  It emits a BFD_RELOC_SH_DATA reloc if necessary.  */

void
sh_flush_pending_output (void)
{
  if (sh_relax
      && seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0,
	       BFD_RELOC_SH_DATA);
      seg_info (now_seg)->tc_segment_info_data.in_code = 0;
    }
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Various routines to kill one day.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, target_big_endian);
}

/* Handle the .uses pseudo-op.  This pseudo-op is used just before a
   call instruction.  It refers to a label of the instruction which
   loads the register which the call uses.  We use it to generate a
   special reloc for the linker.  */

static void
s_uses (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;

  if (! sh_relax)
    as_warn (_(".uses pseudo-op seen when not relaxing"));

  expression (&ex);

  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad (_("bad .uses format"));
      ignore_rest_of_line ();
      return;
    }

  fix_new_exp (frag_now, frag_now_fix (), 2, &ex, 1, BFD_RELOC_SH_USES);

  demand_empty_rest_of_line ();
}

enum options
{
  OPTION_RELAX = OPTION_MD_BASE,
  OPTION_BIG,
  OPTION_LITTLE,
  OPTION_SMALL,
  OPTION_DSP,
  OPTION_ISA,
  OPTION_RENESAS,
  OPTION_ALLOW_REG_PREFIX,
#ifdef HAVE_SH64
  OPTION_ABI,
  OPTION_NO_MIX,
  OPTION_SHCOMPACT_CONST_CRANGE,
  OPTION_NO_EXPAND,
  OPTION_PT32,
#endif
  OPTION_H_TICK_HEX,
#ifdef OBJ_ELF
  OPTION_FDPIC,
#endif
  OPTION_DUMMY  /* Not used.  This is just here to make it easy to add and subtract options from this enum.  */
};

const char *md_shortopts = "";
struct option md_longopts[] =
{
  {"relax", no_argument, NULL, OPTION_RELAX},
  {"big", no_argument, NULL, OPTION_BIG},
  {"little", no_argument, NULL, OPTION_LITTLE},
  /* The next two switches are here because the
     generic parts of the linker testsuite uses them.  */
  {"EB", no_argument, NULL, OPTION_BIG},
  {"EL", no_argument, NULL, OPTION_LITTLE},
  {"small", no_argument, NULL, OPTION_SMALL},
  {"dsp", no_argument, NULL, OPTION_DSP},
  {"isa", required_argument, NULL, OPTION_ISA},
  {"renesas", no_argument, NULL, OPTION_RENESAS},
  {"allow-reg-prefix", no_argument, NULL, OPTION_ALLOW_REG_PREFIX},

#ifdef HAVE_SH64
  {"abi",                    required_argument, NULL, OPTION_ABI},
  {"no-mix",                 no_argument, NULL, OPTION_NO_MIX},
  {"shcompact-const-crange", no_argument, NULL, OPTION_SHCOMPACT_CONST_CRANGE},
  {"no-expand",              no_argument, NULL, OPTION_NO_EXPAND},
  {"expand-pt32",            no_argument, NULL, OPTION_PT32},
#endif /* HAVE_SH64 */
  { "h-tick-hex", no_argument,	      NULL, OPTION_H_TICK_HEX  },

#ifdef OBJ_ELF
  {"fdpic", no_argument, NULL, OPTION_FDPIC},
#endif

  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    case OPTION_RELAX:
      sh_relax = 1;
      break;

    case OPTION_BIG:
      target_big_endian = 1;
      break;

    case OPTION_LITTLE:
      target_big_endian = 0;
      break;

    case OPTION_SMALL:
      sh_small = 1;
      break;

    case OPTION_DSP:
      preset_target_arch = arch_sh_up & ~(arch_sh_sp_fpu|arch_sh_dp_fpu);
      break;

    case OPTION_RENESAS:
      dont_adjust_reloc_32 = 1;
      break;

    case OPTION_ALLOW_REG_PREFIX:
      allow_dollar_register_prefix = 1;
      break;

    case OPTION_ISA:
      if (strcasecmp (arg, "dsp") == 0)
	preset_target_arch = arch_sh_up & ~(arch_sh_sp_fpu|arch_sh_dp_fpu);
      else if (strcasecmp (arg, "fp") == 0)
	preset_target_arch = arch_sh_up & ~arch_sh_has_dsp;
      else if (strcasecmp (arg, "any") == 0)
	preset_target_arch = arch_sh_up;
#ifdef HAVE_SH64
      else if (strcasecmp (arg, "shmedia") == 0)
	{
	  if (sh64_isa_mode == sh64_isa_shcompact)
	    as_bad (_("Invalid combination: --isa=SHcompact with --isa=SHmedia"));
	  sh64_isa_mode = sh64_isa_shmedia;
	}
      else if (strcasecmp (arg, "shcompact") == 0)
	{
	  if (sh64_isa_mode == sh64_isa_shmedia)
	    as_bad (_("Invalid combination: --isa=SHmedia with --isa=SHcompact"));
	  if (sh64_abi == sh64_abi_64)
	    as_bad (_("Invalid combination: --abi=64 with --isa=SHcompact"));
	  sh64_isa_mode = sh64_isa_shcompact;
	}
#endif /* HAVE_SH64 */
      else
	{
	  extern const bfd_arch_info_type bfd_sh_arch;
	  bfd_arch_info_type const *bfd_arch = &bfd_sh_arch;

	  preset_target_arch = 0;
	  for (; bfd_arch; bfd_arch=bfd_arch->next)
	    {
	      int len = strlen(bfd_arch->printable_name);
	      
	      if (bfd_arch->mach == bfd_mach_sh5)
		continue;
	      
	      if (strncasecmp (bfd_arch->printable_name, arg, len) != 0)
		continue;

	      if (arg[len] == '\0')
		preset_target_arch =
		  sh_get_arch_from_bfd_mach (bfd_arch->mach);
	      else if (strcasecmp(&arg[len], "-up") == 0)
		preset_target_arch =
		  sh_get_arch_up_from_bfd_mach (bfd_arch->mach);
	      else
		continue;
	      break;
	    }
	  
	  if (!preset_target_arch)
	    as_bad (_("Invalid argument to --isa option: %s"), arg);
	}
      break;

#ifdef HAVE_SH64
    case OPTION_ABI:
      if (strcmp (arg, "32") == 0)
	{
	  if (sh64_abi == sh64_abi_64)
	    as_bad (_("Invalid combination: --abi=32 with --abi=64"));
	  sh64_abi = sh64_abi_32;
	}
      else if (strcmp (arg, "64") == 0)
	{
	  if (sh64_abi == sh64_abi_32)
	    as_bad (_("Invalid combination: --abi=64 with --abi=32"));
	  if (sh64_isa_mode == sh64_isa_shcompact)
	    as_bad (_("Invalid combination: --isa=SHcompact with --abi=64"));
	  sh64_abi = sh64_abi_64;
	}
      else
	as_bad (_("Invalid argument to --abi option: %s"), arg);
      break;

    case OPTION_NO_MIX:
      sh64_mix = FALSE;
      break;

    case OPTION_SHCOMPACT_CONST_CRANGE:
      sh64_shcompact_const_crange = TRUE;
      break;

    case OPTION_NO_EXPAND:
      sh64_expand = FALSE;
      break;

    case OPTION_PT32:
      sh64_pt32 = TRUE;
      break;
#endif /* HAVE_SH64 */

    case OPTION_H_TICK_HEX:
      enable_h_tick_hex = 1;
      break;

#ifdef OBJ_ELF
    case OPTION_FDPIC:
      sh_fdpic = TRUE;
      break;
#endif /* OBJ_ELF */

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
SH options:\n\
--little		generate little endian code\n\
--big			generate big endian code\n\
--relax			alter jump instructions for long displacements\n\
--renesas		disable optimization with section symbol for\n\
			compatibility with Renesas assembler.\n\
--small			align sections to 4 byte boundaries, not 16\n\
--dsp			enable sh-dsp insns, and disable floating-point ISAs.\n\
--allow-reg-prefix	allow '$' as a register name prefix.\n\
--isa=[any		use most appropriate isa\n\
    | dsp               same as '-dsp'\n\
    | fp"));
  {
    extern const bfd_arch_info_type bfd_sh_arch;
    bfd_arch_info_type const *bfd_arch = &bfd_sh_arch;

    for (; bfd_arch; bfd_arch=bfd_arch->next)
      if (bfd_arch->mach != bfd_mach_sh5)
	{
	  fprintf (stream, "\n    | %s", bfd_arch->printable_name);
	  fprintf (stream, "\n    | %s-up", bfd_arch->printable_name);
	}
  }
  fprintf (stream, "]\n");
#ifdef HAVE_SH64
  fprintf (stream, _("\
--isa=[shmedia		set as the default instruction set for SH64\n\
    | SHmedia\n\
    | shcompact\n\
    | SHcompact]\n"));
  fprintf (stream, _("\
--abi=[32|64]		set size of expanded SHmedia operands and object\n\
			file type\n\
--shcompact-const-crange  emit code-range descriptors for constants in\n\
			SHcompact code sections\n\
--no-mix		disallow SHmedia code in the same section as\n\
			constants and SHcompact code\n\
--no-expand		do not expand MOVI, PT, PTA or PTB instructions\n\
--expand-pt32		with -abi=64, expand PT, PTA and PTB instructions\n\
			to 32 bits only\n"));
#endif /* HAVE_SH64 */
#ifdef OBJ_ELF
  fprintf (stream, _("\
--fdpic			generate an FDPIC object file\n"));
#endif /* OBJ_ELF */
}

/* This struct is used to pass arguments to sh_count_relocs through
   bfd_map_over_sections.  */

struct sh_count_relocs
{
  /* Symbol we are looking for.  */
  symbolS *sym;
  /* Count of relocs found.  */
  int count;
};

/* Count the number of fixups in a section which refer to a particular
   symbol.  This is called via bfd_map_over_sections.  */

static void
sh_count_relocs (bfd *abfd ATTRIBUTE_UNUSED, segT sec, void *data)
{
  struct sh_count_relocs *info = (struct sh_count_relocs *) data;
  segment_info_type *seginfo;
  symbolS *sym;
  fixS *fix;

  seginfo = seg_info (sec);
  if (seginfo == NULL)
    return;

  sym = info->sym;
  for (fix = seginfo->fix_root; fix != NULL; fix = fix->fx_next)
    {
      if (fix->fx_addsy == sym)
	{
	  ++info->count;
	  fix->fx_tcbit = 1;
	}
    }
}

/* Handle the count relocs for a particular section.
   This is called via bfd_map_over_sections.  */

static void
sh_frob_section (bfd *abfd ATTRIBUTE_UNUSED, segT sec,
		 void *ignore ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo;
  fixS *fix;

  seginfo = seg_info (sec);
  if (seginfo == NULL)
    return;

  for (fix = seginfo->fix_root; fix != NULL; fix = fix->fx_next)
    {
      symbolS *sym;

      sym = fix->fx_addsy;
      /* Check for a local_symbol.  */
      if (sym && sym->bsym == NULL)
	{
	  struct local_symbol *ls = (struct local_symbol *)sym;
	  /* See if it's been converted.  If so, canonicalize.  */
	  if (local_symbol_converted_p (ls))
	    fix->fx_addsy = local_symbol_get_real_symbol (ls);
	}
    }

  for (fix = seginfo->fix_root; fix != NULL; fix = fix->fx_next)
    {
      symbolS *sym;
      bfd_vma val;
      fixS *fscan;
      struct sh_count_relocs info;

      if (fix->fx_r_type != BFD_RELOC_SH_USES)
	continue;

      /* The BFD_RELOC_SH_USES reloc should refer to a defined local
	 symbol in the same section.  */
      sym = fix->fx_addsy;
      if (sym == NULL
	  || fix->fx_subsy != NULL
	  || fix->fx_addnumber != 0
	  || S_GET_SEGMENT (sym) != sec
	  || S_IS_EXTERNAL (sym))
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 _(".uses does not refer to a local symbol in the same section"));
	  continue;
	}

      /* Look through the fixups again, this time looking for one
	 at the same location as sym.  */
      val = S_GET_VALUE (sym);
      for (fscan = seginfo->fix_root;
	   fscan != NULL;
	   fscan = fscan->fx_next)
	if (val == fscan->fx_frag->fr_address + fscan->fx_where
	    && fscan->fx_r_type != BFD_RELOC_SH_ALIGN
	    && fscan->fx_r_type != BFD_RELOC_SH_CODE
	    && fscan->fx_r_type != BFD_RELOC_SH_DATA
	    && fscan->fx_r_type != BFD_RELOC_SH_LABEL)
	  break;
      if (fscan == NULL)
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 _("can't find fixup pointed to by .uses"));
	  continue;
	}

      if (fscan->fx_tcbit)
	{
	  /* We've already done this one.  */
	  continue;
	}

      /* The variable fscan should also be a fixup to a local symbol
	 in the same section.  */
      sym = fscan->fx_addsy;
      if (sym == NULL
	  || fscan->fx_subsy != NULL
	  || fscan->fx_addnumber != 0
	  || S_GET_SEGMENT (sym) != sec
	  || S_IS_EXTERNAL (sym))
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 _(".uses target does not refer to a local symbol in the same section"));
	  continue;
	}

      /* Now we look through all the fixups of all the sections,
	 counting the number of times we find a reference to sym.  */
      info.sym = sym;
      info.count = 0;
      bfd_map_over_sections (stdoutput, sh_count_relocs, &info);

      if (info.count < 1)
	abort ();

      /* Generate a BFD_RELOC_SH_COUNT fixup at the location of sym.
	 We have already adjusted the value of sym to include the
	 fragment address, so we undo that adjustment here.  */
      subseg_change (sec, 0);
      fix_new (fscan->fx_frag,
	       S_GET_VALUE (sym) - fscan->fx_frag->fr_address,
	       4, &abs_symbol, info.count, 0, BFD_RELOC_SH_COUNT);
    }
}

/* This function is called after the symbol table has been completed,
   but before the relocs or section contents have been written out.
   If we have seen any .uses pseudo-ops, they point to an instruction
   which loads a register with the address of a function.  We look
   through the fixups to find where the function address is being
   loaded from.  We then generate a COUNT reloc giving the number of
   times that function address is referred to.  The linker uses this
   information when doing relaxing, to decide when it can eliminate
   the stored function address entirely.  */

void
sh_frob_file (void)
{
#ifdef HAVE_SH64
  shmedia_frob_file_before_adjust ();
#endif

  if (! sh_relax)
    return;

  bfd_map_over_sections (stdoutput, sh_frob_section, NULL);
}

/* Called after relaxing.  Set the correct sizes of the fragments, and
   create relocs so that md_apply_fix will fill in the correct values.  */

void
md_convert_frag (bfd *headers ATTRIBUTE_UNUSED, segT seg, fragS *fragP)
{
  int donerelax = 0;

  switch (fragP->fr_subtype)
    {
    case C (COND_JUMP, COND8):
    case C (COND_JUMP_DELAY, COND8):
      subseg_change (seg, 0);
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, BFD_RELOC_SH_PCDISP8BY2);
      fragP->fr_fix += 2;
      fragP->fr_var = 0;
      break;

    case C (UNCOND_JUMP, UNCOND12):
      subseg_change (seg, 0);
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, BFD_RELOC_SH_PCDISP12BY2);
      fragP->fr_fix += 2;
      fragP->fr_var = 0;
      break;

    case C (UNCOND_JUMP, UNCOND32):
    case C (UNCOND_JUMP, UNDEF_WORD_DISP):
      if (fragP->fr_symbol == NULL)
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement overflows 12-bit field"));
      else if (S_IS_DEFINED (fragP->fr_symbol))
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to defined symbol %s overflows 12-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
      else
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to undefined symbol %s overflows 12-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
      /* Stabilize this frag, so we don't trip an assert.  */
      fragP->fr_fix += fragP->fr_var;
      fragP->fr_var = 0;
      break;

    case C (COND_JUMP, COND12):
    case C (COND_JUMP_DELAY, COND12):
      /* A bcond won't fit, so turn it into a b!cond; bra disp; nop.  */
      /* I found that a relax failure for gcc.c-torture/execute/930628-1.c
	 was due to gas incorrectly relaxing an out-of-range conditional
	 branch with delay slot.  It turned:
                     bf.s    L6              (slot mov.l   r12,@@(44,r0))
         into:

2c:  8f 01 a0 8b     bf.s    32 <_main+32>   (slot bra       L6)
30:  00 09           nop
32:  10 cb           mov.l   r12,@@(44,r0)
         Therefore, branches with delay slots have to be handled
	 differently from ones without delay slots.  */
      {
	unsigned char *buffer =
	  (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
	int highbyte = target_big_endian ? 0 : 1;
	int lowbyte = target_big_endian ? 1 : 0;
	int delay = fragP->fr_subtype == C (COND_JUMP_DELAY, COND12);

	/* Toggle the true/false bit of the bcond.  */
	buffer[highbyte] ^= 0x2;

	/* If this is a delayed branch, we may not put the bra in the
	   slot.  So we change it to a non-delayed branch, like that:
	   b! cond slot_label; bra disp; slot_label: slot_insn
	   ??? We should try if swapping the conditional branch and
	   its delay-slot insn already makes the branch reach.  */

	/* Build a relocation to six / four bytes farther on.  */
	subseg_change (seg, 0);
	fix_new (fragP, fragP->fr_fix, 2, section_symbol (seg),
		 fragP->fr_address + fragP->fr_fix + (delay ? 4 : 6),
		 1, BFD_RELOC_SH_PCDISP8BY2);

	/* Set up a jump instruction.  */
	buffer[highbyte + 2] = 0xa0;
	buffer[lowbyte + 2] = 0;
	fix_new (fragP, fragP->fr_fix + 2, 2, fragP->fr_symbol,
		 fragP->fr_offset, 1, BFD_RELOC_SH_PCDISP12BY2);

	if (delay)
	  {
	    buffer[highbyte] &= ~0x4; /* Removes delay slot from branch.  */
	    fragP->fr_fix += 4;
	  }
	else
	  {
	    /* Fill in a NOP instruction.  */
	    buffer[highbyte + 4] = 0x0;
	    buffer[lowbyte + 4] = 0x9;

	    fragP->fr_fix += 6;
	  }
	fragP->fr_var = 0;
	donerelax = 1;
      }
      break;

    case C (COND_JUMP, COND32):
    case C (COND_JUMP_DELAY, COND32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP_DELAY, UNDEF_WORD_DISP):
      if (fragP->fr_symbol == NULL)
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement overflows 8-bit field"));
      else if (S_IS_DEFINED (fragP->fr_symbol))
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to defined symbol %s overflows 8-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
      else
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to undefined symbol %s overflows 8-bit field "),
		      S_GET_NAME (fragP->fr_symbol));
      /* Stabilize this frag, so we don't trip an assert.  */
      fragP->fr_fix += fragP->fr_var;
      fragP->fr_var = 0;
      break;

    default:
#ifdef HAVE_SH64
      shmedia_md_convert_frag (headers, seg, fragP, TRUE);
#else
      abort ();
#endif
    }

  if (donerelax && !sh_relax)
    as_warn_where (fragP->fr_file, fragP->fr_line,
		   _("overflow in branch to %s; converted into longer instruction sequence"),
		   (fragP->fr_symbol != NULL
		    ? S_GET_NAME (fragP->fr_symbol)
		    : ""));
}

valueT
md_section_align (segT seg ATTRIBUTE_UNUSED, valueT size)
{
#ifdef OBJ_ELF
  return size;
#else /* ! OBJ_ELF */
  return ((size + (1 << bfd_get_section_alignment (stdoutput, seg)) - 1)
	  & (-1 << bfd_get_section_alignment (stdoutput, seg)));
#endif /* ! OBJ_ELF */
}

/* This static variable is set by s_uacons to tell sh_cons_align that
   the expression does not need to be aligned.  */

static int sh_no_align_cons = 0;

/* This handles the unaligned space allocation pseudo-ops, such as
   .uaword.  .uaword is just like .word, but the value does not need
   to be aligned.  */

static void
s_uacons (int bytes)
{
  /* Tell sh_cons_align not to align this value.  */
  sh_no_align_cons = 1;
  cons (bytes);
}

/* If a .word, et. al., pseud-op is seen, warn if the value is not
   aligned correctly.  Note that this can cause warnings to be issued
   when assembling initialized structured which were declared with the
   packed attribute.  FIXME: Perhaps we should require an option to
   enable this warning?  */

void
sh_cons_align (int nbytes)
{
  int nalign;

  if (sh_no_align_cons)
    {
      /* This is an unaligned pseudo-op.  */
      sh_no_align_cons = 0;
      return;
    }

  nalign = 0;
  while ((nbytes & 1) == 0)
    {
      ++nalign;
      nbytes >>= 1;
    }

  if (nalign == 0)
    return;

  if (now_seg == absolute_section)
    {
      if ((abs_section_offset & ((1 << nalign) - 1)) != 0)
	as_warn (_("misaligned data"));
      return;
    }

  frag_var (rs_align_test, 1, 1, (relax_substateT) 0,
	    (symbolS *) NULL, (offsetT) nalign, (char *) NULL);

  record_alignment (now_seg, nalign);
}

/* When relaxing, we need to output a reloc for any .align directive
   that requests alignment to a four byte boundary or larger.  This is
   also where we check for misaligned data.  */

void
sh_handle_align (fragS *frag)
{
  int bytes = frag->fr_next->fr_address - frag->fr_address - frag->fr_fix;

  if (frag->fr_type == rs_align_code)
    {
      static const unsigned char big_nop_pattern[] = { 0x00, 0x09 };
      static const unsigned char little_nop_pattern[] = { 0x09, 0x00 };

      char *p = frag->fr_literal + frag->fr_fix;

      if (bytes & 1)
	{
	  *p++ = 0;
	  bytes--;
	  frag->fr_fix += 1;
	}

      if (target_big_endian)
	{
	  memcpy (p, big_nop_pattern, sizeof big_nop_pattern);
	  frag->fr_var = sizeof big_nop_pattern;
	}
      else
	{
	  memcpy (p, little_nop_pattern, sizeof little_nop_pattern);
	  frag->fr_var = sizeof little_nop_pattern;
	}
    }
  else if (frag->fr_type == rs_align_test)
    {
      if (bytes != 0)
	as_bad_where (frag->fr_file, frag->fr_line, _("misaligned data"));
    }

  if (sh_relax
      && (frag->fr_type == rs_align
	  || frag->fr_type == rs_align_code)
      && frag->fr_address + frag->fr_fix > 0
      && frag->fr_offset > 1
      && now_seg != bss_section)
    fix_new (frag, frag->fr_fix, 2, &abs_symbol, frag->fr_offset, 0,
	     BFD_RELOC_SH_ALIGN);
}

/* See whether the relocation should be resolved locally.  */

static bfd_boolean
sh_local_pcrel (fixS *fix)
{
  return (! sh_relax
	  && (fix->fx_r_type == BFD_RELOC_SH_PCDISP8BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCDISP12BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY4
	      || fix->fx_r_type == BFD_RELOC_8_PCREL
	      || fix->fx_r_type == BFD_RELOC_SH_SWITCH16
	      || fix->fx_r_type == BFD_RELOC_SH_SWITCH32));
}

/* See whether we need to force a relocation into the output file.
   This is used to force out switch and PC relative relocations when
   relaxing.  */

int
sh_force_relocation (fixS *fix)
{
  /* These relocations can't make it into a DSO, so no use forcing
     them for global symbols.  */
  if (sh_local_pcrel (fix))
    return 0;

  /* Make sure some relocations get emitted.  */
  if (fix->fx_r_type == BFD_RELOC_SH_LOOP_START
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_END
      || fix->fx_r_type == BFD_RELOC_SH_TLS_GD_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LD_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_IE_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LDO_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LE_32
      || generic_force_reloc (fix))
    return 1;

  if (! sh_relax)
    return 0;

  return (fix->fx_pcrel
	  || SWITCH_TABLE (fix)
	  || fix->fx_r_type == BFD_RELOC_SH_COUNT
	  || fix->fx_r_type == BFD_RELOC_SH_ALIGN
	  || fix->fx_r_type == BFD_RELOC_SH_CODE
	  || fix->fx_r_type == BFD_RELOC_SH_DATA
#ifdef HAVE_SH64
	  || fix->fx_r_type == BFD_RELOC_SH_SHMEDIA_CODE
#endif
	  || fix->fx_r_type == BFD_RELOC_SH_LABEL);
}

#ifdef OBJ_ELF
bfd_boolean
sh_fix_adjustable (fixS *fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_32_PLT_PCREL
      || fixP->fx_r_type == BFD_RELOC_32_GOT_PCREL
      || fixP->fx_r_type == BFD_RELOC_SH_GOT20
      || fixP->fx_r_type == BFD_RELOC_SH_GOTPC
      || fixP->fx_r_type == BFD_RELOC_SH_GOTFUNCDESC
      || fixP->fx_r_type == BFD_RELOC_SH_GOTFUNCDESC20
      || fixP->fx_r_type == BFD_RELOC_SH_GOTOFFFUNCDESC
      || fixP->fx_r_type == BFD_RELOC_SH_GOTOFFFUNCDESC20
      || fixP->fx_r_type == BFD_RELOC_SH_FUNCDESC
      || ((fixP->fx_r_type == BFD_RELOC_32) && dont_adjust_reloc_32)
      || fixP->fx_r_type == BFD_RELOC_RVA)
    return 0;

  /* We need the symbol name for the VTABLE entries */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}

void
sh_elf_final_processing (void)
{
  int val;

  /* Set file-specific flags to indicate if this code needs
     a processor with the sh-dsp / sh2e ISA to execute.  */
#ifdef HAVE_SH64
  /* SH5 and above don't know about the valid_arch arch_sh* bits defined
     in sh-opc.h, so check SH64 mode before checking valid_arch.  */
  if (sh64_isa_mode != sh64_isa_unspecified)
    val = EF_SH5;
  else
#elif defined TARGET_SYMBIAN
    if (1)
      {
	extern int sh_symbian_find_elf_flags (unsigned int);

	val = sh_symbian_find_elf_flags (valid_arch);
      }
    else
#endif /* HAVE_SH64 */
    val = sh_find_elf_flags (valid_arch);

  elf_elfheader (stdoutput)->e_flags &= ~EF_SH_MACH_MASK;
  elf_elfheader (stdoutput)->e_flags |= val;

  if (sh_fdpic)
    elf_elfheader (stdoutput)->e_flags |= EF_SH_FDPIC;
}
#endif

#ifdef TE_UCLINUX
/* Return the target format for uClinux.  */

const char *
sh_uclinux_target_format (void)
{
  if (sh_fdpic)
    return (!target_big_endian ? "elf32-sh-fdpic" : "elf32-shbig-fdpic");
  else
    return (!target_big_endian ? "elf32-shl" : "elf32-sh");
}
#endif

/* Apply fixup FIXP to SIZE-byte field BUF given that VAL is its
   assembly-time value.  If we're generating a reloc for FIXP,
   see whether the addend should be stored in-place or whether
   it should be in an ELF r_addend field.  */

static void
apply_full_field_fix (fixS *fixP, char *buf, bfd_vma val, int size)
{
  reloc_howto_type *howto;

  if (fixP->fx_addsy != NULL || fixP->fx_pcrel)
    {
      howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
      if (howto && !howto->partial_inplace)
	{
	  fixP->fx_addnumber = val;
	  return;
	}
    }
  md_number_to_chars (buf, val, size);
}

/* Apply a fixup to the object file.  */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  int lowbyte = target_big_endian ? 1 : 0;
  int highbyte = target_big_endian ? 0 : 1;
  long val = (long) *valP;
  long max, min;
  int shift;

  /* A difference between two symbols, the second of which is in the
     current section, is transformed in a PC-relative relocation to
     the other symbol.  We have to adjust the relocation type here.  */
  if (fixP->fx_pcrel)
    {
#ifndef HAVE_SH64
      /* Safeguard; this must not occur for non-sh64 configurations.  */
      gas_assert (fixP->fx_r_type != BFD_RELOC_64);
#endif

      switch (fixP->fx_r_type)
	{
	default:
	  break;

	case BFD_RELOC_32:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  break;

	  /* Currently, we only support 32-bit PCREL relocations.
	     We'd need a new reloc type to handle 16_PCREL, and
	     8_PCREL is already taken for R_SH_SWITCH8, which
	     apparently does something completely different than what
	     we need.  FIXME.  */
	case BFD_RELOC_16:
	  bfd_set_error (bfd_error_bad_value);
	  return;

	case BFD_RELOC_8:
	  bfd_set_error (bfd_error_bad_value);
	  return;
	}
    }

  /* The function adjust_reloc_syms won't convert a reloc against a weak
     symbol into a reloc against a section, but bfd_install_relocation
     will screw up if the symbol is defined, so we have to adjust val here
     to avoid the screw up later.

     For ordinary relocs, this does not happen for ELF, since for ELF,
     bfd_install_relocation uses the "special function" field of the
     howto, and does not execute the code that needs to be undone, as long
     as the special function does not return bfd_reloc_continue.
     It can happen for GOT- and PLT-type relocs the way they are
     described in elf32-sh.c as they use bfd_elf_generic_reloc, but it
     doesn't matter here since those relocs don't use VAL; see below.  */
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour
      && fixP->fx_addsy != NULL
      && S_IS_WEAK (fixP->fx_addsy))
    val -= S_GET_VALUE  (fixP->fx_addsy);

  if (SWITCH_TABLE (fixP))
    val -= S_GET_VALUE  (fixP->fx_subsy);

  max = min = 0;
  shift = 0;
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_SH_IMM3:
      max = 0x7;
      * buf = (* buf & 0xf8) | (val & 0x7);
      break;
    case BFD_RELOC_SH_IMM3U:
      max = 0x7;
      * buf = (* buf & 0x8f) | ((val & 0x7) << 4);
      break;
    case BFD_RELOC_SH_DISP12:
      max = 0xfff;
      buf[lowbyte] = val & 0xff;
      buf[highbyte] |= (val >> 8) & 0x0f;
      break;
    case BFD_RELOC_SH_DISP12BY2:
      max = 0xfff;
      shift = 1;
      buf[lowbyte] = (val >> 1) & 0xff;
      buf[highbyte] |= (val >> 9) & 0x0f;
      break;
    case BFD_RELOC_SH_DISP12BY4:
      max = 0xfff;
      shift = 2;
      buf[lowbyte] = (val >> 2) & 0xff;
      buf[highbyte] |= (val >> 10) & 0x0f;
      break;
    case BFD_RELOC_SH_DISP12BY8:
      max = 0xfff;
      shift = 3;
      buf[lowbyte] = (val >> 3) & 0xff;
      buf[highbyte] |= (val >> 11) & 0x0f;
      break;
    case BFD_RELOC_SH_DISP20:
      if (! target_big_endian)
	abort();
      max = 0x7ffff;
      min = -0x80000;
      buf[1] = (buf[1] & 0x0f) | ((val >> 12) & 0xf0);
      buf[2] = (val >> 8) & 0xff;
      buf[3] = val & 0xff;
      break;
    case BFD_RELOC_SH_DISP20BY8:
      if (!target_big_endian)
	abort();
      max = 0x7ffff;
      min = -0x80000;
      shift = 8;
      buf[1] = (buf[1] & 0x0f) | ((val >> 20) & 0xf0);
      buf[2] = (val >> 16) & 0xff;
      buf[3] = (val >> 8) & 0xff;
      break;

    case BFD_RELOC_SH_IMM4:
      max = 0xf;
      *buf = (*buf & 0xf0) | (val & 0xf);
      break;

    case BFD_RELOC_SH_IMM4BY2:
      max = 0xf;
      shift = 1;
      *buf = (*buf & 0xf0) | ((val >> 1) & 0xf);
      break;

    case BFD_RELOC_SH_IMM4BY4:
      max = 0xf;
      shift = 2;
      *buf = (*buf & 0xf0) | ((val >> 2) & 0xf);
      break;

    case BFD_RELOC_SH_IMM8BY2:
      max = 0xff;
      shift = 1;
      *buf = val >> 1;
      break;

    case BFD_RELOC_SH_IMM8BY4:
      max = 0xff;
      shift = 2;
      *buf = val >> 2;
      break;

    case BFD_RELOC_8:
    case BFD_RELOC_SH_IMM8:
      /* Sometimes the 8 bit value is sign extended (e.g., add) and
         sometimes it is not (e.g., and).  We permit any 8 bit value.
         Note that adding further restrictions may invalidate
         reasonable looking assembly code, such as ``and -0x1,r0''.  */
      max = 0xff;
      min = -0xff;
      *buf++ = val;
      break;

    case BFD_RELOC_SH_PCRELIMM8BY4:
      /* If we are dealing with a known destination ... */
      if ((fixP->fx_addsy == NULL || S_IS_DEFINED (fixP->fx_addsy))
	  && (fixP->fx_subsy == NULL || S_IS_DEFINED (fixP->fx_addsy)))
      {
	/* Don't silently move the destination due to misalignment.
	   The absolute address is the fragment base plus the offset into
	   the fragment plus the pc relative offset to the label.  */
	if ((fixP->fx_frag->fr_address + fixP->fx_where + val) & 3)
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("offset to unaligned destination"));

	/* The displacement cannot be zero or backward even if aligned.
	   Allow -2 because val has already been adjusted somewhere.  */
	if (val < -2)
	  as_bad_where (fixP->fx_file, fixP->fx_line, _("negative offset"));
      }

      /* The lower two bits of the PC are cleared before the
         displacement is added in.  We can assume that the destination
         is on a 4 byte boundary.  If this instruction is also on a 4
         byte boundary, then we want
	   (target - here) / 4
	 and target - here is a multiple of 4.
	 Otherwise, we are on a 2 byte boundary, and we want
	   (target - (here - 2)) / 4
	 and target - here is not a multiple of 4.  Computing
	   (target - (here - 2)) / 4 == (target - here + 2) / 4
	 works for both cases, since in the first case the addition of
	 2 will be removed by the division.  target - here is in the
	 variable val.  */
      val = (val + 2) / 4;
      if (val & ~0xff)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
      buf[lowbyte] = val;
      break;

    case BFD_RELOC_SH_PCRELIMM8BY2:
      val /= 2;
      if (val & ~0xff)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
      buf[lowbyte] = val;
      break;

    case BFD_RELOC_SH_PCDISP8BY2:
      val /= 2;
      if (val < -0x80 || val > 0x7f)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
      buf[lowbyte] = val;
      break;

    case BFD_RELOC_SH_PCDISP12BY2:
      val /= 2;
      if (val < -0x800 || val > 0x7ff)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
      buf[lowbyte] = val & 0xff;
      buf[highbyte] |= (val >> 8) & 0xf;
      break;

#ifndef HAVE_SH64
    case BFD_RELOC_64:
      apply_full_field_fix (fixP, buf, *valP, 8);
      break;
#endif

    case BFD_RELOC_32:
    case BFD_RELOC_32_PCREL:
      apply_full_field_fix (fixP, buf, val, 4);
      break;

    case BFD_RELOC_16:
      apply_full_field_fix (fixP, buf, val, 2);
      break;

    case BFD_RELOC_SH_USES:
      /* Pass the value into sh_reloc().  */
      fixP->fx_addnumber = val;
      break;

    case BFD_RELOC_SH_COUNT:
    case BFD_RELOC_SH_ALIGN:
    case BFD_RELOC_SH_CODE:
    case BFD_RELOC_SH_DATA:
    case BFD_RELOC_SH_LABEL:
      /* Nothing to do here.  */
      break;

    case BFD_RELOC_SH_LOOP_START:
    case BFD_RELOC_SH_LOOP_END:

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

#ifdef OBJ_ELF
    case BFD_RELOC_32_PLT_PCREL:
      /* Make the jump instruction point to the address of the operand.  At
	 runtime we merely add the offset to the actual PLT entry.  */
      * valP = 0xfffffffc;
      val = fixP->fx_offset;
      if (fixP->fx_subsy)
	val -= S_GET_VALUE (fixP->fx_subsy);
      apply_full_field_fix (fixP, buf, val, 4);
      break;

    case BFD_RELOC_SH_GOTPC:
      /* This is tough to explain.  We end up with this one if we have
         operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".
         The goal here is to obtain the absolute address of the GOT,
         and it is strongly preferable from a performance point of
         view to avoid using a runtime relocation for this.  There are
         cases where you have something like:

         .long	_GLOBAL_OFFSET_TABLE_+[.-.L66]

         and here no correction would be required.  Internally in the
         assembler we treat operands of this form as not being pcrel
         since the '.' is explicitly mentioned, and I wonder whether
         it would simplify matters to do it this way.  Who knows.  In
         earlier versions of the PIC patches, the pcrel_adjust field
         was used to store the correction, but since the expression is
         not pcrel, I felt it would be confusing to do it this way.  */
      * valP -= 1;
      apply_full_field_fix (fixP, buf, val, 4);
      break;

    case BFD_RELOC_SH_TLS_GD_32:
    case BFD_RELOC_SH_TLS_LD_32:
    case BFD_RELOC_SH_TLS_IE_32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* Fallthrough */
    case BFD_RELOC_32_GOT_PCREL:
    case BFD_RELOC_SH_GOT20:
    case BFD_RELOC_SH_GOTPLT32:
    case BFD_RELOC_SH_GOTFUNCDESC:
    case BFD_RELOC_SH_GOTFUNCDESC20:
    case BFD_RELOC_SH_GOTOFFFUNCDESC:
    case BFD_RELOC_SH_GOTOFFFUNCDESC20:
    case BFD_RELOC_SH_FUNCDESC:
      * valP = 0; /* Fully resolved at runtime.  No addend.  */
      apply_full_field_fix (fixP, buf, 0, 4);
      break;

    case BFD_RELOC_SH_TLS_LDO_32:
    case BFD_RELOC_SH_TLS_LE_32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* Fallthrough */
    case BFD_RELOC_32_GOTOFF:
    case BFD_RELOC_SH_GOTOFF20:
      apply_full_field_fix (fixP, buf, val, 4);
      break;
#endif

    default:
#ifdef HAVE_SH64
      shmedia_md_apply_fix (fixP, valP);
      return;
#else
      abort ();
#endif
    }

  if (shift != 0)
    {
      if ((val & ((1 << shift) - 1)) != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("misaligned offset"));
      if (val >= 0)
	val >>= shift;
      else
	val = ((val >> shift)
	       | ((long) -1 & ~ ((long) -1 >> shift)));
    }

  /* Extend sign for 64-bit host.  */
  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;
  if (max != 0 && (val < min || val > max))
    as_bad_where (fixP->fx_file, fixP->fx_line, _("offset out of range"));
  else if (max != 0)
    /* Stop the generic code from trying to overlow check the value as well.
       It may not have the correct value anyway, as we do not store val back
       into *valP.  */
    fixP->fx_no_overflow = 1;

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Called just before address relaxation.  Return the length
   by which a fragment must grow to reach it's destination.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment_type)
{
  int what;

  switch (fragP->fr_subtype)
    {
    default:
#ifdef HAVE_SH64
      return shmedia_md_estimate_size_before_relax (fragP, segment_type);
#else
      abort ();
#endif


    case C (UNCOND_JUMP, UNDEF_DISP):
      /* Used to be a branch to somewhere which was unknown.  */
      if (!fragP->fr_symbol)
	{
	  fragP->fr_subtype = C (UNCOND_JUMP, UNCOND12);
	}
      else if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  fragP->fr_subtype = C (UNCOND_JUMP, UNCOND12);
	}
      else
	{
	  fragP->fr_subtype = C (UNCOND_JUMP, UNDEF_WORD_DISP);
	}
      break;

    case C (COND_JUMP, UNDEF_DISP):
    case C (COND_JUMP_DELAY, UNDEF_DISP):
      what = GET_WHAT (fragP->fr_subtype);
      /* Used to be a branch to somewhere which was unknown.  */
      if (fragP->fr_symbol
	  && S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  /* Got a symbol and it's defined in this segment, become byte
	     sized - maybe it will fix up.  */
	  fragP->fr_subtype = C (what, COND8);
	}
      else if (fragP->fr_symbol)
	{
	  /* Its got a segment, but its not ours, so it will always be long.  */
	  fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
	}
      else
	{
	  /* We know the abs value.  */
	  fragP->fr_subtype = C (what, COND8);
	}
      break;

    case C (UNCOND_JUMP, UNCOND12):
    case C (UNCOND_JUMP, UNCOND32):
    case C (UNCOND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP, COND8):
    case C (COND_JUMP, COND12):
    case C (COND_JUMP, COND32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP_DELAY, COND8):
    case C (COND_JUMP_DELAY, COND12):
    case C (COND_JUMP_DELAY, COND32):
    case C (COND_JUMP_DELAY, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
    }

  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
  return fragP->fr_var;
}

/* Put number into target byte order.  */

void
md_number_to_chars (char *ptr, valueT use, int nbytes)
{
#ifdef HAVE_SH64
  /* We might need to set the contents type to data.  */
  sh64_flag_output ();
#endif

  if (! target_big_endian)
    number_to_chars_littleendian (ptr, use, nbytes);
  else
    number_to_chars_bigendian (ptr, use, nbytes);
}

/* This version is used in obj-coff.c eg. for the sh-hms target.  */

long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address + 2;
}

long
md_pcrel_from_section (fixS *fixP, segT sec)
{
  if (! sh_local_pcrel (fixP)
      && fixP->fx_addsy != (symbolS *) NULL
      && (generic_force_reloc (fixP)
	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
    {
      /* The symbol is undefined (or is defined but not in this section,
	 or we're not sure about it being the final definition).  Let the
	 linker figure it out.  We need to adjust the subtraction of a
	 symbol to the position of the relocated data, though.  */
      return fixP->fx_subsy ? fixP->fx_where + fixP->fx_frag->fr_address : 0;
    }

  return md_pcrel_from (fixP);
}

/* Create a reloc.  */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;

  r_type = fixp->fx_r_type;

  if (SWITCH_TABLE (fixp))
    {
      *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);
      rel->addend = 0;
      if (r_type == BFD_RELOC_16)
	r_type = BFD_RELOC_SH_SWITCH16;
      else if (r_type == BFD_RELOC_8)
	r_type = BFD_RELOC_8_PCREL;
      else if (r_type == BFD_RELOC_32)
	r_type = BFD_RELOC_SH_SWITCH32;
      else
	abort ();
    }
  else if (r_type == BFD_RELOC_SH_USES)
    rel->addend = fixp->fx_addnumber;
  else if (r_type == BFD_RELOC_SH_COUNT)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_SH_ALIGN)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_VTABLE_INHERIT
           || r_type == BFD_RELOC_VTABLE_ENTRY)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_SH_LOOP_START
           || r_type == BFD_RELOC_SH_LOOP_END)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_SH_LABEL && fixp->fx_pcrel)
    {
      rel->addend = 0;
      rel->address = rel->addend = fixp->fx_offset;
    }
#ifdef HAVE_SH64
  else if (shmedia_init_reloc (rel, fixp))
    ;
#endif
  else
    rel->addend = fixp->fx_addnumber;

  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);

  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (r_type));
      /* Set howto to a garbage value so that we can keep going.  */
      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      gas_assert (rel->howto != NULL);
    }
#ifdef OBJ_ELF
  else if (rel->howto->type == R_SH_IND12W)
    rel->addend += fixp->fx_offset - 4;
#endif

  return rel;
}

#ifdef OBJ_ELF
inline static char *
sh_end_of_match (char *cont, char *what)
{
  int len = strlen (what);

  if (strncasecmp (cont, what, strlen (what)) == 0
      && ! is_part_of_name (cont[len]))
    return cont + len;

  return NULL;
}

int
sh_parse_name (char const *name,
	       expressionS *exprP,
	       enum expr_mode mode,
	       char *nextcharP)
{
  char *next = input_line_pointer;
  char *next_end;
  int reloc_type;
  segT segment;

  exprP->X_op_symbol = NULL;

  if (strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (! GOT_symbol)
	GOT_symbol = symbol_find_or_make (name);

      exprP->X_add_symbol = GOT_symbol;
    no_suffix:
      /* If we have an absolute symbol or a reg, then we know its
	 value now.  */
      segment = S_GET_SEGMENT (exprP->X_add_symbol);
      if (mode != expr_defer && segment == absolute_section)
	{
	  exprP->X_op = O_constant;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else if (mode != expr_defer && segment == reg_section)
	{
	  exprP->X_op = O_register;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else
	{
	  exprP->X_op = O_symbol;
	  exprP->X_add_number = 0;
	}

      return 1;
    }

  exprP->X_add_symbol = symbol_find_or_make (name);

  if (*nextcharP != '@@')
    goto no_suffix;
  else if ((next_end = sh_end_of_match (next + 1, "GOTOFF")))
    reloc_type = BFD_RELOC_32_GOTOFF;
  else if ((next_end = sh_end_of_match (next + 1, "GOTPLT")))
    reloc_type = BFD_RELOC_SH_GOTPLT32;
  else if ((next_end = sh_end_of_match (next + 1, "GOT")))
    reloc_type = BFD_RELOC_32_GOT_PCREL;
  else if ((next_end = sh_end_of_match (next + 1, "PLT")))
    reloc_type = BFD_RELOC_32_PLT_PCREL;
  else if ((next_end = sh_end_of_match (next + 1, "TLSGD")))
    reloc_type = BFD_RELOC_SH_TLS_GD_32;
  else if ((next_end = sh_end_of_match (next + 1, "TLSLDM")))
    reloc_type = BFD_RELOC_SH_TLS_LD_32;
  else if ((next_end = sh_end_of_match (next + 1, "GOTTPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_IE_32;
  else if ((next_end = sh_end_of_match (next + 1, "TPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_LE_32;
  else if ((next_end = sh_end_of_match (next + 1, "DTPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_LDO_32;
  else if ((next_end = sh_end_of_match (next + 1, "PCREL")))
    reloc_type = BFD_RELOC_32_PCREL;
  else if ((next_end = sh_end_of_match (next + 1, "GOTFUNCDESC")))
    reloc_type = BFD_RELOC_SH_GOTFUNCDESC;
  else if ((next_end = sh_end_of_match (next + 1, "GOTOFFFUNCDESC")))
    reloc_type = BFD_RELOC_SH_GOTOFFFUNCDESC;
  else if ((next_end = sh_end_of_match (next + 1, "FUNCDESC")))
    reloc_type = BFD_RELOC_SH_FUNCDESC;
  else
    goto no_suffix;

  *input_line_pointer = *nextcharP;
  input_line_pointer = next_end;
  *nextcharP = *input_line_pointer;
  *input_line_pointer = '\0';

  exprP->X_op = O_PIC_reloc;
  exprP->X_add_number = 0;
  exprP->X_md = reloc_type;

  return 1;
}

void
sh_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (15, 0);
}

int
sh_regname_to_dw2regnum (char *regname)
{
  unsigned int regnum = -1;
  unsigned int i;
  const char *p;
  char *q;
  static struct { char *name; int dw2regnum; } regnames[] =
    {
      { "pr", 17 }, { "t", 18 }, { "gbr", 19 }, { "mach", 20 },
      { "macl", 21 }, { "fpul", 23 }
    };

  for (i = 0; i < ARRAY_SIZE (regnames); ++i)
    if (strcmp (regnames[i].name, regname) == 0)
      return regnames[i].dw2regnum;

  if (regname[0] == 'r')
    {
      p = regname + 1;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 16)
	return -1;
    }
  else if (regname[0] == 'f' && regname[1] == 'r')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 16)
	return -1;
      regnum += 25;
    }
  else if (regname[0] == 'x' && regname[1] == 'd')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 8)
	return -1;
      regnum += 87;
    }
  return regnum;
}
#endif /* OBJ_ELF */
@


1.140
log
@gas/
	[SH] Support the .uaquad and .8byte directives also for non-sh64
	configurations.

	* config/tc-sh.c (sh_cons_fix_new, md_apply_fix) [!HAVE_SH64]: Handle
	BFD_RELOC_64.
	* doc/c-sh64.texi (SH64 Machine Directives): Move .uaquad
	description...
	* doc/c-sh.texi (SH Machine Directives): ... here.
@
text
@d934 5
a938 4
      l->X_add_number -= r->X_add_number;
      l->X_add_number -= frag_off / OCTETS_PER_BYTE;
      l->X_add_number += (S_GET_VALUE (l->X_add_symbol)
			  - S_GET_VALUE (r->X_add_symbol));
@


1.139
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
a791 1
#ifdef HAVE_SH64
a794 1
#endif
d3969 5
d4172 6
@


1.138
log
@	PR gas/11733
	* config/tc-sh.c (find_cooked_opcode): Correct array bounds check.
@
text
@d148 1
d151 1
d2352 1
d2354 1
d2365 1
d2373 1
d2454 1
d2458 1
d2518 1
d2521 1
a3727 1
  char *p;
d3753 2
a3754 2
  p = frag_var (rs_align_test, 1, 1, (relax_substateT) 0,
		(symbolS *) NULL, (offsetT) nalign, (char *) NULL);
@


1.137
log
@2010-05-21  Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Andrew Stubbs  <ams@@codesourcery.com>

        bfd/
        * config.bfd (sh-*-uclinux* | sh[12]-*-uclinux*): Add
        bfd_elf32_shl_vec, and FDPIC vectors to targ_selvecs.
        * configure.in: Handle FDPIC vectors.
        * elf32-sh-relocs.h: Add FDPIC and movi20 relocations.
        * elf32-sh.c (DEFAULT_STACK_SIZE): Define.
        (SYMBOL_FUNCDESC_LOCAL): Define.  Use it instead of
        SYMBOL_REFERENCES_LOCAL for function descriptors.
        (fdpic_object_p): New.
        (sh_reloc_map): Add FDPIC and movi20 relocations.
        (sh_elf_info_to_howto, sh_elf_relocate_section): Handle new invalid
        range.
        (struct elf_sh_plt_info): Add got20 and short_plt.  Update all
        definitions.
        (FDPIC_PLT_ENTRY_SIZE, FDPIC_PLT_LAZY_OFFSET): Define.
        (fdpic_sh_plt_entry_be, fdpic_sh_plt_entry_le, fdpic_sh_plts): New.
        (FDPIC_SH2A_PLT_ENTRY_SIZE, FDPIC_SH2A_PLT_LAZY_OFFSET): Define.
        (fdpic_sh2a_plt_entry_be, fdpic_sh2a_plt_entry_le)
        (fdpic_sh2a_short_plt_be, fdpic_sh2a_short_plt_le, fdpic_sh2a_plts):
        New.
        (get_plt_info): Handle FDPIC.
        (MAX_SHORT_PLT): Define.
        (get_plt_index, get_plt_offset): Handle short_plt.
        (union gotref): New.
        (struct elf_sh_link_hash_entry): Add funcdesc, rename tls_type to
        got_type and adjust all uses.  Add GOT_FUNCDESC.
        (struct sh_elf_obj_tdata): Add local_funcdesc.  Rename
        local_got_tls_type to local_got_type.
        (sh_elf_local_got_type): Renamed from sh_elf_local_got_tls_type.  All
        users changed.
        (sh_elf_local_funcdesc): Define.
        (struct elf_sh_link_hash_table): Add sfuncdesc, srelfuncdesc, fdpic_p,
        and srofixup.
        (sh_elf_link_hash_newfunc): Initialize new fields.
        (sh_elf_link_hash_table_create): Set fdpic_p.
        (sh_elf_omit_section_dynsym): New.
        (create_got_section): Create .got.funcdesc, .rela.got.funcdesc
        and .rofixup.
        (allocate_dynrelocs): Allocate local function descriptors and space
        for R_SH_FUNCDESC-related relocations, and for rofixups.
        Handle GOT_FUNCDESC.  Create fixups.  Handle GOT entries which
        require function descriptors.
        (sh_elf_always_size_sections): Handle PT_GNU_STACK and __stacksize.
        (sh_elf_modify_program_headers): New.
        (sh_elf_size_dynamic_sections): Allocate function descriptors for
        local symbols.  Allocate .got.funcdesc contents.  Allocate rofixups.
        Handle local GOT entries of type GOT_FUNCDESC.  Create fixups for
        local GOT entries.  Ensure that FDPIC libraries always have a PLTGOT
        entry in the .dynamic section.
        (sh_elf_add_dyn_reloc, sh_elf_got_offset, sh_elf_initialize_funcdesc)
        (sh_elf_add_rofixup, sh_elf_osec_to_segment)
        (sh_elf_osec_readonly_p, install_movi20_field): New functions.
        (sh_elf_relocate_section): Handle new relocations, R_SH_FUNCDESC,
        R_SH_GOTFUNCDESC and R_SH_GOTOFFFUNCDESC.  Use sh_elf_got_offset
        and .got.plt throughout to find _GLOBAL_OFFSET_TABLE_.  Add rofixup
        read-only section warnings.  Handle undefined weak symbols.  Generate
        fixups for R_SH_DIR32 and GOT entries.  Check for cross-segment
        relocations and clear EF_SH_PIC.  Handle 20-bit relocations.
        Always generate R_SH_DIR32 for FDPIC instead of R_SH_RELATIVE.
        (sh_elf_gc_sweep_hook): Handle R_SH_FUNCDESC, R_SH_GOTOFF20,
        R_SH_GOTFUNCDESC, R_SH_GOTFUNCDESC20, and R_SH_GOTOFFFUNCDESC.
        Handle 20-bit relocations.
        (sh_elf_copy_indirect_symbol): Copy function descriptor reference
        counts.
        (sh_elf_check_relocs): Handle new relocations.  Make symbols
        dynamic for FDPIC relocs.  Account for rofixups.  Error for FDPIC
        symbol mismatches.  Allocate a GOT for R_SH_DIR32. Allocate fixups
        for R_SH_DIR32.
        (sh_elf_copy_private_data): Copy PT_GNU_STACK size.
        (sh_elf_merge_private_data): Copy initial flags.  Do not clobber
        non-mach flags.  Set EF_SH_PIC for FDPIC.  Reject FDPIC mismatches.
        (sh_elf_finish_dynamic_symbol): Do not handle got_funcdesc entries
        here.  Rename sgot to sgotplt and srel to srelplt.  Handle short_plt,
        FDPIC descriptors, and got20.  Create R_SH_FUNCDESC_VALUE for FDPIC.
        Use install_movi20_field.  Rename srel to srelgot.  Always generate
        R_SH_DIR32 for FDPIC instead of R_SH_RELATIVE.
        (sh_elf_finish_dynamic_sections): Fill in the GOT pointer in rofixup.
        Do not fill in reserved GOT entries for FDPIC.  Correct DT_PLTGOT.
        Rename sgot to sgotplt.  Assert that the right number of rofixups
        and dynamic relocations were allocated.
        (sh_elf_use_relative_eh_frame, sh_elf_encode_eh_address): New.
        (elf_backend_omit_section_dynsym): Use sh_elf_omit_section_dynsym.
        (elf_backend_can_make_relative_eh_frame)
        (elf_backend_can_make_lsda_relative_eh_frame)
        (elf_backend_encode_eh_address): Define.
        (TARGET_BIG_SYM, TARGET_BIG_NAME, TARGET_LITTLE_SYM)
        (TARGET_LITTLE_NAME, elf_backend_modify_program_headers, elf32_bed):
        Redefine for FDPIC vector.
        * reloc.c: Add SH FDPIC and movi20 relocations.
        * targets.c (_bfd_target_vector): Add FDPIC vectors.
        * configure, bfd-in2.h, libbfd.h: Regenerated.

        binutils/
        * readelf.c (get_machine_flags): Handle EF_SH_PIC and EF_SH_FDPIC.

        gas/
        * config/tc-sh.c (sh_fdpic): New.
        (sh_check_fixup): Handle relocations on movi20.
        (parse_exp): Do not reject PIC operators here.
        (build_Mytes): Check for unhandled PIC operators here.  Use
        sh_check_fixup for movi20.
        (enum options): Add OPTION_FDPIC.
        (md_longopts, md_parse_option, md_show_usage): Add --fdpic.
        (sh_fix_adjustable, md_apply_fix): Handle FDPIC and movi20 relocations.
        (sh_elf_final_processing): Handle --fdpic.
        (sh_uclinux_target_format): New.
        (sh_parse_name): Handle FDPIC relocation operators.
        * config/tc-sh.h (TARGET_FORMAT): Define specially for TE_UCLINUX.
        (sh_uclinux_target_format): Declare for TE_UCLINUX.
        * configure.tgt (sh-*-uclinux* | sh[12]-*-uclinux*): Set
        em=uclinux.
        * doc/c-sh.texi (SH Options): Document --fdpic.

        gas/testsuite/
        * gas/sh/basic.exp: Run new tests.  Handle uClinux like Linux.
        * gas/sh/fdpic.d: New file.
        * gas/sh/fdpic.s: New file.
        * gas/sh/reg-prefix.d: Force big-endian.
        * gas/sh/sh2a-pic.d: New file.
        * gas/sh/sh2a-pic.s: New file.
        * lib/gas-defs.exp (is_elf_format): Include sh*-*-uclinux*.

        include/elf/
        * sh.h (EF_SH_PIC, EF_SH_FDPIC): Define.
        (R_SH_FIRST_INVALID_RELOC_6, R_SH_LAST_INVALID_RELOC_6): New.  Adjust
        other invalid ranges.
        (R_SH_GOT20, R_SH_GOTOFF20, R_SH_GOTFUNCDESC, R_SH_GOTFUNCDESC20)
        (R_SH_GOTOFFFUNCDESC, R_SH_GOTOFFFUNCDESC20, R_SH_FUNCDESC)
        (R_SH_FUNCDESC_VALUE): New.

        ld/
        * Makefile.am (ALL_EMULATIONS): Add eshelf_fd.o and eshlelf_fd.o.
        (eshelf_fd.c, eshlelf_fd.c): New rules.
        * Makefile.in: Regenerate.
        * configure.tgt (sh-*-uclinux*): Add shelf_fd and shlelf_fd
        emulations.
        * emulparams/shelf_fd.sh: New file.
        * emulparams/shlelf_fd.sh: New file.
        * emulparams/shlelf_linux.sh: Update comment.

        ld/testsuite/
        * ld-sh/sh.exp: Handle uClinux like Linux.
        * lib/ld-lib.exp (is_elf_format): Include sh*-*-uclinux*.
        * ld-sh/fdpic-funcdesc-shared.d: New file.
        * ld-sh/fdpic-funcdesc-shared.s: New file.
        * ld-sh/fdpic-funcdesc-static.d: New file.
        * ld-sh/fdpic-funcdesc-static.s: New file.
        * ld-sh/fdpic-gotfuncdesc-shared.d: New file.
        * ld-sh/fdpic-gotfuncdesc-shared.s: New file.
        * ld-sh/fdpic-gotfuncdesc-static.d: New file.
        * ld-sh/fdpic-gotfuncdesc-static.s: New file.
        * ld-sh/fdpic-gotfuncdesci20-shared.d: New file.
        * ld-sh/fdpic-gotfuncdesci20-shared.s: New file.
        * ld-sh/fdpic-gotfuncdesci20-static.d: New file.
        * ld-sh/fdpic-gotfuncdesci20-static.s: New file.
        * ld-sh/fdpic-goti20-shared.d: New file.
        * ld-sh/fdpic-goti20-shared.s: New file.
        * ld-sh/fdpic-goti20-static.d: New file.
        * ld-sh/fdpic-goti20-static.s: New file.
        * ld-sh/fdpic-gotofffuncdesc-shared.d: New file.
        * ld-sh/fdpic-gotofffuncdesc-shared.s: New file.
        * ld-sh/fdpic-gotofffuncdesc-static.d: New file.
        * ld-sh/fdpic-gotofffuncdesc-static.s: New file.
        * ld-sh/fdpic-gotofffuncdesci20-shared.d: New file.
        * ld-sh/fdpic-gotofffuncdesci20-shared.s: New file.
        * ld-sh/fdpic-gotofffuncdesci20-static.d: New file.
        * ld-sh/fdpic-gotofffuncdesci20-static.s: New file.
        * ld-sh/fdpic-gotoffi20-shared.d: New file.
        * ld-sh/fdpic-gotoffi20-shared.s: New file.
        * ld-sh/fdpic-gotoffi20-static.d: New file.
        * ld-sh/fdpic-gotoffi20-static.s: New file.
        * ld-sh/fdpic-plt-be.d: New file.
        * ld-sh/fdpic-plt-le.d: New file.
        * ld-sh/fdpic-plt.s: New file.
        * ld-sh/fdpic-plti20-be.d: New file.
        * ld-sh/fdpic-plti20-le.d: New file.
        * ld-sh/fdpic-stack-default.d: New file.
        * ld-sh/fdpic-stack-size.d: New file.
        * ld-sh/fdpic-stack.s: New file.
@
text
@d2548 1
a2548 1
  int nlen = 0;
d2560 1
a2560 1
       && nlen < 20
@


1.136
log
@2010-03-02  Andrew Stubbs  <ams@@codesourcery.com>

	* config/tc-sh.c (get_specific): Move overflow checking code to avoid
	reading uninitialized data.
@
text
@d148 3
a617 1
#ifdef HAVE_SH64
d625 25
d745 1
a749 3
#else
      *r_type_p = exp->X_md;
#endif
a1385 6
#ifdef OBJ_ELF
  else if (op->immediate.X_op == O_PIC_reloc
	   || sh_PIC_related_p (op->immediate.X_add_symbol)
	   || sh_PIC_related_p (op->immediate.X_op_symbol))
    as_bad (_("misplaced PIC operand"));
#endif
d2349 2
d2361 8
d2447 5
a2451 1
	      insert4 (output, BFD_RELOC_SH_DISP20, 0, operand);
d2510 2
d3136 3
d3167 4
d3304 6
d3362 4
d3859 1
d3861 5
d3904 16
d4228 1
d4230 5
d4244 1
d4552 8
@


1.135
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
a1682 30
	  if (SH_MERGE_ARCH_SET_VALID (valid_arch, arch_sh2a_nofpu_up)
	      && (   arg == A_DISP_REG_M
		  || arg == A_DISP_REG_N))
	    {
	      /* Check a few key IMM* fields for overflow.  */
	      int opf;
	      long val = user->immediate.X_add_number;

	      for (opf = 0; opf < 4; opf ++)
		switch (this_try->nibbles[opf])
		  {
		  case IMM0_4:
		  case IMM1_4:
		    if (val < 0 || val > 15)
		      goto fail;
		    break;
		  case IMM0_4BY2:
		  case IMM1_4BY2:
		    if (val < 0 || val > 15 * 2)
		      goto fail;
		    break;
		  case IMM0_4BY4:
		  case IMM1_4BY4:
		    if (val < 0 || val > 15 * 4)
		      goto fail;
		    break;
		  default:
		    break;
		  }
	    }
d2176 30
@


1.134
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2323 1
a2323 1
  int index;
d2348 1
a2348 1
  for (index = 0; index < max_index; index++)
d2350 1
a2350 1
      sh_nibble_type i = opcode->nibbles[index];
d2353 1
a2353 1
	  nbuf[index] = i;
d2361 1
a2361 1
	      nbuf[index] = reg_n;
d2364 1
a2364 1
	      nbuf[index] = reg_m;
d2369 1
a2369 1
	      nbuf[index] = (reg_n & 3) | 4;
d2372 1
a2372 1
	      nbuf[index] = reg_n | (reg_m >> 2);
d2375 1
a2375 1
	      nbuf[index] = reg_b | 0x08;
d2378 1
a2378 1
	      nbuf[index] = reg_n | 0x01;
d2381 1
a2381 1
	      nbuf[index] |= 0x08;
d2386 1
a2386 1
	      nbuf[index] |= 0x80;
d2468 1
a2468 1
	      nbuf[index] = opcode->nibbles[3];
@


1.133
log
@	* config/tc-sh.c (md_apply_fix): Extend sign of the offset value
	for 64-bit host.
	* gas/sh/sign-extension.d: New file.
	* gas/sh/sign-extension.s: New file.
	* gas/sh/basic.exp: Run new test.
@
text
@d1353 1
a1353 1
  char *new;
d1366 1
a1366 1
  new = input_line_pointer;
d1368 1
a1368 1
  return new;
@


1.132
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007  Free Software Foundation, Inc.
d4186 3
@


1.131
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3216 1
a3216 1
	    as_bad ("Invalid argument to --isa option: %s", arg);
d3237 1
a3237 1
	as_bad ("Invalid argument to --abi option: %s", arg);
@


1.130
log
@* NEWS: Mention these changes.

* config/tc-h8300.h (H_TICK_HEX): Define.
* config/tc-h8300.c (OPTION_H_TICK_HEX): New.
(md_longopts): Add "-h-tick-hex".
(md_parse_option): Support it.
* doc/c-h8300.texi (H8/300 Options): Document it.
* doc/as.texinfo (Overview): Likewise.

* config/tc-sh.h (H_TICK_HEX): Define.
* config/tc-sh.c (OPTION_H_TICK_HEX): New.
(md_longopts): Add "-h-tick-hex".
(md_parse_option): Support it.
* doc/c-sh.texi (SH Options): Document it.
* doc/c-sh64.texi (SH64 Options): Document it.
* doc/as.texinfo (Overview): Likewise.
@
text
@d4378 1
a4378 1
      assert (rel->howto != NULL);
@


1.129
log
@2008-04-15  Andrew Stubbs  <andrew.stubbs@@st.com>

gas/

	* config/tc-sh.c (md_apply_fix): Make sure BFD_RELOC_SH_PCRELIMM8BY4
	relocations are properly aligned, and not negative.

gas/testsuite/

	* gas/sh/arch/arch.exp: Align PC-relative instructions in the gererated
	assembly files.
	* gas/sh/arch/sh-dsp.s: Regenerate.
	* gas/sh/arch/sh.s: Regenerate.
	* gas/sh/arch/sh2.s: Regenerate.
	* gas/sh/arch/sh2a-nofpu-or-sh3-nommu.s: Regenerate.
	* gas/sh/arch/sh2a-nofpu-or-sh4-nommu-nofpu.s: Regenerate.
	* gas/sh/arch/sh2a-nofpu.s: Regenerate.
	* gas/sh/arch/sh2a-or-sh3e.s: Regenerate.: Regenerate.
	* gas/sh/arch/sh2a-or-sh4.s: Regenerate.
	* gas/sh/arch/sh2a.s: Regenerate.
	* gas/sh/arch/sh2e.s: Regenerate.
	* gas/sh/arch/sh3-dsp.s: Regenerate.
	* gas/sh/arch/sh3-nommu.s: Regenerate.
	* gas/sh/arch/sh3.s: Regenerate.
	* gas/sh/arch/sh3e.s: Regenerate.
	* gas/sh/arch/sh4-nofpu.s: Regenerate.
	* gas/sh/arch/sh4-nommu-nofpu.s: Regenerate.
	* gas/sh/arch/sh4.s: Regenerate.
	* gas/sh/arch/sh4a-nofpu.s: Regenerate.
	* gas/sh/arch/sh4a.s: Regenerate.
	* gas/sh/arch/sh4al-dsp.s: Regenerate.
	* gas/sh/err-mova.s: New test.

ld/testsuite/

	* ld-sh/arch/sh-dsp.s: Regenerate.
	* ld-sh/arch/sh.s: Regenerate.
	* ld-sh/arch/sh2.s: Regenerate.
	* ld-sh/arch/sh2a-nofpu-or-sh3-nommu.s: Regenerate.
	* ld-sh/arch/sh2a-nofpu-or-sh4-nommu-nofpu.s: Regenerate.
	* ld-sh/arch/sh2a-nofpu.s: Regenerate.
	* ld-sh/arch/sh2a-or-sh3e.s: Regenerate.: Regenerate.
	* ld-sh/arch/sh2a-or-sh4.s: Regenerate.
	* ld-sh/arch/sh2a.s: Regenerate.
	* ld-sh/arch/sh2e.s: Regenerate.
	* ld-sh/arch/sh3-dsp.s: Regenerate.
	* ld-sh/arch/sh3-nommu.s: Regenerate.
	* ld-sh/arch/sh3.s: Regenerate.
	* ld-sh/arch/sh3e.s: Regenerate.
	* ld-sh/arch/sh4-nofpu.s: Regenerate.
	* ld-sh/arch/sh4-nommu-nofpu.s: Regenerate.
	* ld-sh/arch/sh4.s: Regenerate.
	* ld-sh/arch/sh4a-nofpu.s: Regenerate.
	* ld-sh/arch/sh4a.s: Regenerate.
	* ld-sh/arch/sh4al-dsp.s: Regenerate.
@
text
@d3099 1
d3126 1
d3257 4
@


1.128
log
@Remove duplicate definitions of the md_atof() function
@
text
@d4021 17
@


1.127
log
@Switch to GPLv3
@
text
@a3047 7
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP .  An error message is
   returned, or NULL on OK.  */
d3052 1
a3052 44
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * 2;

  if (! target_big_endian)
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }

  return NULL;
@


1.126
log
@	* config/atof-vax.c (atof_vax_sizeof): Change return type to unsigned.
	(md_atof): Make number_of_chars unsigned.  Revert last change.
	* config/tc-or32.c (md_apply_fix): Delete bogus assertions.
	* config/tc-sh.c (sh_optimize_expr): Only define for OBJ_ELF.
	* config/tc-sh.h (md_optimize_expr): Likewise.
	* config/tc-sh64.c (shmedia_md_pcrel_from_section): Delete bogus
	assertion.
	* config/tc-xtensa.c (convert_frag_immed_finish_loop): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006  Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.125
log
@	* config/tc-sh.c (sh_handle_align):  Call as_bad_where instead
	of as_warn_where for misaligned data.
@
text
@a888 1
#endif /* OBJ_ELF */
a895 1
#ifdef OBJ_ELF
a915 1
#endif /* OBJ_ELF */
d918 1
@


1.124
log
@	* config/tc-sh.c (align_test_frag_offset_fixed_p): Handle
	rs_fill frags.
@
text
@d3780 1
a3780 1
	as_warn_where (frag->fr_file, frag->fr_line, _("misaligned data"));
@


1.123
log
@	* config/tc-sh.c (align_test_frag_offset_fixed_p): New.
	(sh_optimize_expr): Likewise.
	* config/tc-sh.h (md_optimize_expr): Define.
	(sh_optimize_expr): Prototype.
@
text
@d850 2
a851 1
  while (frag->fr_type == rs_align_test)
d853 4
a856 1
      off += frag->fr_fix;
d870 2
a871 1
  while (frag->fr_type == rs_align_test)
d873 4
a876 1
      off -= frag->fr_fix;
@


1.122
log
@2006-10-27  Andrew Stubbs  <andrew.stubbs@@st.com>

	* config/tc-sh.c (md_assemble): Define size of branches.
@
text
@d828 53
d883 30
@


1.121
log
@* config/tc-sh.c (sh_frob_section): Canonicalize pointers to local
vs full symbols so that we never have more than one pointer value
for any given symbol in our symbol table.
@
text
@d2868 3
@


1.120
log
@bfd/
2006-08-02  Richard Sandiford  <richard@@codesourcery.com>
	    Kazu Hirata  <kazu@@codesourcery.com>
	    Phil Edwards  <phil@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* config.bfd (sh-*-vxworks): Use bfd_elf32_shvxworks_vec and
	bfd_elf32_shlvxworks_vec.
	* configure.in (bfd_elf32_sh64_vec): Add elf-vxworks.lo.
	(bfd_elf32_sh64l_vec, bfd_elf32_sh64lin_vec): Likewise.
	(bfd_elf32_sh64blin_vec, bfd_elf32_sh64lnbsd_vec): Likewise.
	(bfd_elf32_sh64nbsd_vec, bfd_elf32_sh_vec): Likewise.
	(bfd_elf32_shblin_vec, bfd_elf32_shl_vec): Likewise.
	(bfd_elf32_shl_symbian_vec, bfd_elf32_shlin_vec): Likewise.
	(bfd_elf32_shlnbsd_vec, bfd_elf32_shnbsd_vec): Likewise.
	(bfd_elf32_shlvxworks_vec, bfd_elf32_shvxworks_vec): New stanzas.
	* configure: Regenerate.
	* Makefile.am: Regenerate dependencies.
	* Makefile.in: Regenerate.
	* elf-vxworks.c (elf_vxworks_gott_symbol_p): New function.
	(elf_vxworks_add_symbol_hook): Use it.
	(elf_vxworks_link_output_symbol_hook): Likewise.  Use the hash
	table entry to check for weak undefined symbols and to obtain
	the original bfd.
	(elf_vxworks_emit_relocs): Use target_index instead of this_idx.
	* elf32-sh-relocs.h: New file, split from elf32-sh.c.
	(R_SH_DIR32): Use SH_PARTIAL32 for the partial_inplace field,
	SH_SRC_MASK32 for the src_mask field, and SH_ELF_RELOC for the
	special_function field.
	(R_SH_REL32): Use SH_PARTIAL32 and SH_SRC_MASK32 here too.
	(R_SH_REL32, R_SH_TLS_GD_32, R_SH_TLS_LD_32): Likewise.
	(R_SH_TLS_LDO_32, R_SH_TLS_IE_32, R_SH_TLS_LE_32): Likewise.
	(R_SH_TLS_DTPMOD32, R_SH_TLS_DTPOFF32, R_SH_TLS_TPOFF32): Likewise.
	(R_SH_GOT32, R_SH_PLT32, R_SH_COPY, R_SH_GLOB_DAT): Likewise.
	(R_SH_JMP_SLOT, R_SH_RELATIVE, R_SH_GOTOFF, R_SH_GOTPC): Likewise.
	(SH_PARTIAL32, SH_SRC_MASK32, SH_ELF_RELOC): Undefine at end of file.
	* elf32-sh.c: Include elf32-vxworks.h.
	(MINUS_ONE): Define.
	(sh_elf_howto_table): Include elf32-sh-relocs.h with SH_PARTIAL32
	set to TRUE, SH_SRC_MASK32 set to 0xffffffff, and SH_ELF_RELOC set
	to sh_elf_reloc.
	(sh_vxworks_howto_table): New variable.  Include elf32-sh-relocs.h
	with SH_PARTIAL32 set to FALSE, SH_SRC_MASK32 set to 0, and
	SH_ELF_RELOC set to bfd_elf_generic_reloc.
	(vxworks_object_p, get_howto_table): New functions.
	(sh_elf_reloc_type_lookup): Fix typo.  Use get_howto_table.
	(sh_elf_info_to_howto): Use get_howto_table.
	(sh_elf_relax_section): Honor the partial_inplace field of the
	R_SH_DIR32 howto.
	(sh_elf_relax_delete_bytes): Likewise.
	(elf_sh_plt_info): New structure.
	(PLT_ENTRY_SIZE): Replace both definitions with...
	(ELF_PLT_ENTRY_SIZE): ...this new macro, with separate definitions for
	INCLUDE_SHMEDIA and !INCLUDE_SHMEDIA.
	(elf_sh_plt0_entry_be): Update sizes of both definitions accordingly.
	(elf_sh_plt0_entry_le): Likewise.
	(elf_sh_plt_entry_be, elf_sh_plt_entry_le): Likewise.
	(elf_sh_pic_plt_entry_be, elf_sh_pic_plt_entry_le): Likewise.
	(elf_sh_plts): New structure, with separate definitions for
	INCLUDE_SHMEDIA and !INCLUDE_SHMEDIA.
	(elf_sh_plt0_entry): Delete both definitions.
	(elf_sh_plt_entry, elf_sh_pic_plt_entry): Likewise.
	(elf_sh_sizeof_plt, elf_sh_plt_plt0_offset): Likewise.
	(elf_sh_plt_temp_offset, elf_sh_plt_symbol_offset): Likewise.
	(elf_sh_plt_reloc_offset): Likewise.
	(movi_shori_putval): Delete in favor of...
	(install_plt_field): ...this new function, with separate definitions
	for INCLUDE_SHMEDIA and !INCLUDE_SHMEDIA.
	(get_plt_info): New function, with separate definitions
	for INCLUDE_SHMEDIA and !INCLUDE_SHMEDIA.
	(elf_sh_plt0_linker_offset, elf_sh_plt0_gotid_offset): Delete.
	(VXWORKS_PLT_HEADER_SIZE, VXWORKS_PLT_ENTRY_SIZE): New macros.
	(vxworks_sh_plt0_entry_be, vxworks_sh_plt0_entry_le): New constants.
	(vxworks_sh_plt_entry_be, vxworks_sh_plt_entry_le): Likewise.
	(vxworks_sh_pic_plt_entry_be, vxworks_sh_pic_plt_entry_le): Likewise.
	(get_plt_index, get_plt_offset): New functions.
	(elf_sh_link_hash_table): Add srelplt2, plt_info and vxworks_p fields.
	(sh_elf_link_hash_table_create): Initialize them.
	(sh_elf_create_dynamic_sections): Call
	elf_vxworks_create_dynamic_sections for VxWorks.
	(allocate_dynrelocs): Use htab->plt_info to get the size of PLT
	entries.  Allocate relocation entries in .rela.plt.unloaded if
	generating a VxWorks executable.
	(sh_elf_always_size_sections): New function.
	(sh_elf_size_dynamic_sections): Extend .rela.plt handling to
	.rela.plt.unloaded.
	(sh_elf_relocate_section): Use get_howto_table.  Honor
	partial_inplace when calculating the addend for dynamic
	relocations.  Use get_plt_index.
	(sh_elf_finish_dynamic_symbol): Use get_plt_index, install_plt_field
	and htab->plt_info.  Fill in the bra .plt offset for VxWorks
	executables.  Populate .rela.plt.unloaded.  Do not make
	_GLOBAL_OFFSET_TABLE_ absolute on VxWorks.
	(sh_elf_finish_dynamic_sections): Use install_plt_field and
	htab->plt_info.  Handle cases where there is no special PLT header.
	Populate the first relocation in .rela.plt.unloaded and fix up
	the remaining entries.
	(sh_elf_plt_sym_val): Use get_plt_info.
	(elf_backend_always_size_sections): Define.
	(TARGET_BIG_SYM, TARGET_BIG_NAME): Override for VxWorks.
	(TARGET_LITTLE_SYM, TARGET_BIG_SYM): Likewise.
	(elf32_bed, elf_backend_want_plt_sym): Likewise.
	(elf_symbol_leading_char, elf_backend_want_got_underscore): Likewise.
	(elf_backend_grok_prstatus, elf_backend_grok_psinfo): Likewise.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_link_output_symbol_hook): Likewise.
	(elf_backend_emit_relocs): Likewise.
	(elf_backend_final_write_processing): Likewise.
	(ELF_MAXPAGESIZE, ELF_COMMONPAGESIZE): Likewise.
	* targets.c (bfd_elf32_shlvxworks_vec): Declare.
	(bfd_elf32_shvxworks_vec): Likewise.
	(_bfd_target_vector): Include bfd_elf32_shlvxworks_vec and
	bfd_elf32_shvxworks_vec.

gas/
	* config/tc-sh.c (apply_full_field_fix): New function.
	(md_apply_fix): Use it instead of md_number_to_chars.  Do not fill
	in fx_addnumber for BFD_RELOC_32_PLT_PCREL.
	(tc_gen_reloc): Use fx_addnumber rather than 0 as the default case.
	* config/tc-sh.h (TARGET_FORMAT): Override for TE_VXWORKS.

ld/
2006-08-02  Richard Sandiford  <richard@@codesourcery.com>
	    Kazu Hirata  <kazu@@codesourcery.com>
	    Phil Edwards  <phil@@codesourcery.com>

	* Makefile.am (ALL_EMULATIONS): Add eshelf_vxworks.o and
	eshlelf_vxworks.o.
	(eshelf_vxworks.c, eshlelf_vxworks.c): New rules.
	* Makefile.in: Regenerate.
	* configure.tgt (sh-*-vxworks): Use shelf_vxworks and
	shlelf_vxworks.
	* emulparams/shelf_vxworks.sh: New file.
	* emulparams/shlelf_vxworks.sh: Likewise.
	* emulparams/vxworks.sh (FINI): Prefix _etext with ${SYMPREFIX}.
	(OTHER_END_SYMBOLS): Likewise _ehdr.
	(DATA_END_SYMBOLS): Likewise _edata.
	* emultempl/vxworks.em (vxworks_after_open): Check whether output_bfd
	is indeed an ELF file before dealing with --force-dynamic.

ld/testsuite/
	* ld-sh/rd-sh.exp: Treat vxworks1-static.d specially.
	* ld-sh/sh-vxworks.exp: New file.
	* ld-sh/sh.exp: Extend sh-linux SIZEOF_HEADERS handling to
	sh-*-vxworks.
	* ld-sh/vxworks1-le.dd, ld-sh/vxworks1-lib-le.dd,
	* ld-sh/vxworks1-lib.dd, ld-sh/vxworks1-lib.nd,
	* ld-sh/vxworks1-lib.rd, ld-sh/vxworks1-lib.s,
	* ld-sh/vxworks1-static.d, ld-sh/vxworks1.dd,
	* ld-sh/vxworks1.ld, ld-sh/vxworks1.rd, ld-sh/vxworks1.s,
	* ld-sh/vxworks2-static.sd, ld-sh/vxworks2.s,
	* ld-sh/vxworks2.sd, ld-sh/vxworks3-le.dd,
	* ld-sh/vxworks3-lib-le.dd, ld-sh/vxworks3-lib.dd,
	* ld-sh/vxworks3-lib.s, ld-sh/vxworks3.dd, ld-sh/vxworks3.s,
	* ld-sh/vxworks4.d, ld-sh/vxworks4a.s, ld-sh/vxworks4b.s,
	* ld-sh/reloc1.s, ld-sh/reloc1.d: New tests.
@
text
@d3321 15
@


1.119
log
@* config/tc-sh.c (md_longopts): Add -EL and -EB for use by the linker testsuite.
@
text
@d3785 22
d4007 1
a4007 1
      md_number_to_chars (buf, val, 4);
d4011 1
a4011 1
      md_number_to_chars (buf, val, 2);
d4043 1
a4043 2
      fixP->fx_addnumber = val;
      md_number_to_chars (buf, val, 4);
d4064 1
a4064 1
      md_number_to_chars (buf, val, 4);
d4075 1
a4075 1
      md_number_to_chars (buf, 0, 4);
d4083 1
a4083 1
      md_number_to_chars (buf, val, 4);
d4286 1
a4286 3
  else if (fixp->fx_pcrel)
    rel->addend = fixp->fx_addnumber;
  else if (r_type == BFD_RELOC_32 || r_type == BFD_RELOC_32_GOTOFF)
a4287 2
  else
    rel->addend = 0;
@


1.118
log
@* config/tc-sh.c (md_apply_fix): Do not allow the generic code in
  fixup_segment() to repeat a range check on a value that have already
  been checked here.
* gas/sh/basic.exp: Run "too_large" dump test.
* gas/sh/too_large.s: New test file.  Check that .byte directives do not
  generate a bogus overflow message.
* gas/sh/too_large.s: New test control file.
@
text
@d3066 4
@


1.117
log
@remove some duplicate #include's.
@
text
@d4083 5
@


1.116
log
@	* config/tc-arm.c, config/tc-arm.h (tc_arm_regname_to_dw2regnum):
	Un-constify string argument.
	* config/tc-i386.c, config/tc-i386.h (tc_x86_regname_to_dw2regnum):
	Likewise.
	* config/tc-m68k.c, config/tc-m68k.h (tc_m68k_regname_to_dw2regnum):
	Likewise.
	* config/tc-ppc.c, config/tc-ppc.h (tc_ppc_regname_to_dw2regnum):
	Likewise.
	* config/tc-s390.c, config/tc-s390.h (tc_s390_regname_to_dw2regnum):
	Likewise.
	* config/tc-sh.c, config/tc-sh.h (sh_regname_to_dw2regnum):
	Likewise.
	* config/tc-sparc.c, config/tc-sparc.h (sparc_regname_to_dw2regnum):
	Likewise.
-------------------------------------------------------------------
@
text
@d3 1
a3 1
   2003, 2004, 2005  Free Software Foundation, Inc.
a23 1
#include <stdio.h>
a24 1
#include "bfd.h"
@


1.115
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d4385 1
a4385 1
sh_regname_to_dw2regnum (const char *regname)
@


1.114
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d2801 1
a2801 1
	 This means we definately have an assembly failure,
@


1.113
log
@* config/tc-sh.c (allow_dollar_register_prefix): New variable.
  (parse_reg_without_prefix): New function.
  (parse_reg): Check for '$' register prefix if --allow-reg-prefix is set.
  (option md_longopts): Add allow-reg-prefix option.
* doc/c-sh.texi: Document --allow-reg-prefix option.
* NEWS: Mention the new switch.

* gas/sh/basic.exp:  Run reg-prefix test.
* gas/sh/reg-prefix.s: New
* gas/sh/reg-prefix.d: New
@
text
@d4298 4
a4301 1
sh_parse_name (char const *name, expressionS *exprP, char *nextcharP)
d4320 1
a4320 1
      if (segment == absolute_section)
d4326 1
a4326 1
      else if (segment == reg_section)
@


1.112
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d137 5
a141 1
/* preset architecture set, if given; zero otherwise.  */
d876 2
a877 2
static int
parse_reg (char *src, int *mode, int *reg)
d1232 30
d3042 20
a3064 8
#define OPTION_RELAX  (OPTION_MD_BASE)
#define OPTION_BIG (OPTION_MD_BASE + 1)
#define OPTION_LITTLE (OPTION_BIG + 1)
#define OPTION_SMALL (OPTION_LITTLE + 1)
#define OPTION_DSP (OPTION_SMALL + 1)
#define OPTION_ISA                    (OPTION_DSP + 1)
#define OPTION_RENESAS (OPTION_ISA + 1)

d3070 1
a3070 1
  {"isa",                    required_argument, NULL, OPTION_ISA},
d3072 1
a3074 5
#define OPTION_ABI                    (OPTION_RENESAS + 1)
#define OPTION_NO_MIX                 (OPTION_ABI + 1)
#define OPTION_SHCOMPACT_CONST_CRANGE (OPTION_NO_MIX + 1)
#define OPTION_NO_EXPAND              (OPTION_SHCOMPACT_CONST_CRANGE + 1)
#define OPTION_PT32                   (OPTION_NO_EXPAND + 1)
d3115 4
d3146 1
d3223 4
a3226 4
-little			generate little endian code\n\
-big			generate big endian code\n\
-relax			alter jump instructions for long displacements\n\
-renesas		disable optimization with section symbol for\n\
d3228 4
a3231 3
-small			align sections to 4 byte boundaries, not 16\n\
-dsp			enable sh-dsp insns, and disable floating-point ISAs.\n\
-isa=[any		use most appropriate isa\n\
d3237 1
d3248 1
a3248 1
-isa=[shmedia		set as the default instruction set for SH64\n\
d3253 1
a3253 1
-abi=[32|64]		set size of expanded SHmedia operands and object\n\
d3255 1
a3255 1
-shcompact-const-crange	emit code-range descriptors for constants in\n\
d3257 1
a3257 1
-no-mix			disallow SHmedia code in the same section as\n\
d3259 2
a3260 2
-no-expand		do not expand MOVI, PT, PTA or PTB instructions\n\
-expand-pt32		with -abi=64, expand PT, PTA and PTB instructions\n\
d4315 1
a4315 1
	     value now.  */
@


1.111
log
@2005-08-18  Christian Groessler  <chris@@groessler.org>

	* config/tc-h8300.h: Remove TC_RELOC_MANGLE/tc_reloc_mangle.
	* config/tc-mcore.h: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-sh.h: Remove TC_RELOC_MANGLE and
	sh_coff_reloc_mangle declaration.
	* config/tc-sh.c: (md_apply_fix): Fix comment for case
	BFD_RELOC_SH_USES.
@
text
@d2879 1
a2879 1
sh_frob_label (void)
d2898 2
@


1.110
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d3940 1
a3940 1
      /* Pass the value into sh_coff_reloc_mangle.  */
@


1.109
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a126 2
/*int md_reloc_size; */

a2871 1
#ifdef BFD_ASSEMBLER
a2872 1
#endif
a2920 18
#ifdef OBJ_COFF
#ifndef BFD_ASSEMBLER

void
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}

void
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_headers_hook \n"));
}

#endif
#endif

d3226 1
a3226 2
   symbol.  When using BFD_ASSEMBLER, this is called via
   bfd_map_over_sections.  */
d3251 2
a3252 2
/* Handle the count relocs for a particular section.  When using
   BFD_ASSEMBLER, this is called via bfd_map_over_sections.  */
a3281 3
#if ! defined (BFD_ASSEMBLER) && defined (OBJ_COFF)
	  || S_GET_STORAGE_CLASS (sym) == C_EXT
#endif
a3320 3
#if ! defined (BFD_ASSEMBLER) && defined (OBJ_COFF)
	  || S_GET_STORAGE_CLASS (sym) == C_EXT
#endif
a3331 1
#ifdef BFD_ASSEMBLER
a3332 8
#else
      {
	int iscan;

	for (iscan = SEG_E0; iscan < SEG_UNKNOWN; iscan++)
	  sh_count_relocs ((bfd *) NULL, iscan, &info);
      }
#endif
a3366 1
#ifdef BFD_ASSEMBLER
a3367 8
#else
  {
    int iseg;

    for (iseg = SEG_E0; iseg < SEG_UNKNOWN; iseg++)
      sh_frob_section ((bfd *) NULL, iseg, NULL);
  }
#endif
a3373 1
#ifdef BFD_ASSEMBLER
a3374 4
#else
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED, segT seg,
		 fragS *fragP)
#endif
d3447 1
a3447 6
	fix_new (fragP, fragP->fr_fix, 2,
#ifdef BFD_ASSEMBLER
		 section_symbol (seg),
#else
		 seg_info (seg)->dot,
#endif
a3513 1
#ifdef BFD_ASSEMBLER
a3519 4
#else /* ! BFD_ASSEMBLER */
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
#endif /* ! BFD_ASSEMBLER */
a3743 1
#ifdef BFD_ASSEMBLER
a3788 1
#endif
a3789 1
#ifdef BFD_ASSEMBLER
a3791 13
#else
  if (fixP->fx_r_type == 0)
    {
      if (fixP->fx_size == 2)
	fixP->fx_r_type = BFD_RELOC_16;
      else if (fixP->fx_size == 4)
	fixP->fx_r_type = BFD_RELOC_32;
      else if (fixP->fx_size == 1)
	fixP->fx_r_type = BFD_RELOC_8;
      else
	abort ();
    }
#endif
d4132 1
a4132 2
/* This version is used in obj-coff.c when not using BFD_ASSEMBLER.
   eg for the sh-hms target.  */
a4157 161
#ifdef OBJ_COFF

int
tc_coff_sizemachdep (fragS *frag)
{
  return md_relax_table[frag->fr_subtype].rlx_length;
}

#endif /* OBJ_COFF */

#ifndef BFD_ASSEMBLER
#ifdef OBJ_COFF

/* Map BFD relocs to SH COFF relocs.  */

struct reloc_map
{
  bfd_reloc_code_real_type bfd_reloc;
  int sh_reloc;
};

static const struct reloc_map coff_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32 },
  { BFD_RELOC_16, R_SH_IMM16 },
  { BFD_RELOC_8, R_SH_IMM8 },
  { BFD_RELOC_SH_PCDISP8BY2, R_SH_PCDISP8BY2 },
  { BFD_RELOC_SH_PCDISP12BY2, R_SH_PCDISP },
  { BFD_RELOC_SH_IMM4, R_SH_IMM4 },
  { BFD_RELOC_SH_IMM4BY2, R_SH_IMM4BY2 },
  { BFD_RELOC_SH_IMM4BY4, R_SH_IMM4BY4 },
  { BFD_RELOC_SH_IMM8, R_SH_IMM8 },
  { BFD_RELOC_SH_IMM8BY2, R_SH_IMM8BY2 },
  { BFD_RELOC_SH_IMM8BY4, R_SH_IMM8BY4 },
  { BFD_RELOC_SH_PCRELIMM8BY2, R_SH_PCRELIMM8BY2 },
  { BFD_RELOC_SH_PCRELIMM8BY4, R_SH_PCRELIMM8BY4 },
  { BFD_RELOC_8_PCREL, R_SH_SWITCH8 },
  { BFD_RELOC_SH_SWITCH16, R_SH_SWITCH16 },
  { BFD_RELOC_SH_SWITCH32, R_SH_SWITCH32 },
  { BFD_RELOC_SH_USES, R_SH_USES },
  { BFD_RELOC_SH_COUNT, R_SH_COUNT },
  { BFD_RELOC_SH_ALIGN, R_SH_ALIGN },
  { BFD_RELOC_SH_CODE, R_SH_CODE },
  { BFD_RELOC_SH_DATA, R_SH_DATA },
  { BFD_RELOC_SH_LABEL, R_SH_LABEL },
  { BFD_RELOC_UNUSED, 0 }
};

/* Adjust a reloc for the SH.  This is similar to the generic code,
   but does some minor tweaking.  */

void
sh_coff_reloc_mangle (segment_info_type *seg, fixS *fix,
		      struct internal_reloc *intr, unsigned int paddr)
{
  symbolS *symbol_ptr = fix->fx_addsy;
  symbolS *dot;

  intr->r_vaddr = paddr + fix->fx_frag->fr_address + fix->fx_where;

  if (! SWITCH_TABLE (fix))
    {
      const struct reloc_map *rm;

      for (rm = coff_reloc_map; rm->bfd_reloc != BFD_RELOC_UNUSED; rm++)
	if (rm->bfd_reloc == (bfd_reloc_code_real_type) fix->fx_r_type)
	  break;
      if (rm->bfd_reloc == BFD_RELOC_UNUSED)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("Can not represent %s relocation in this object file format"),
		      bfd_get_reloc_code_name (fix->fx_r_type));
      intr->r_type = rm->sh_reloc;
      intr->r_offset = 0;
    }
  else
    {
      know (sh_relax);

      if (fix->fx_r_type == BFD_RELOC_16)
	intr->r_type = R_SH_SWITCH16;
      else if (fix->fx_r_type == BFD_RELOC_8)
	intr->r_type = R_SH_SWITCH8;
      else if (fix->fx_r_type == BFD_RELOC_32)
	intr->r_type = R_SH_SWITCH32;
      else
	abort ();

      /* For a switch reloc, we set r_offset to the difference between
         the reloc address and the subtrahend.  When the linker is
         doing relaxing, it can use the determine the starting and
         ending points of the switch difference expression.  */
      intr->r_offset = intr->r_vaddr - S_GET_VALUE (fix->fx_subsy);
    }

  /* PC relative relocs are always against the current section.  */
  if (symbol_ptr == NULL)
    {
      switch (fix->fx_r_type)
	{
	case BFD_RELOC_SH_PCRELIMM8BY2:
	case BFD_RELOC_SH_PCRELIMM8BY4:
	case BFD_RELOC_SH_PCDISP8BY2:
	case BFD_RELOC_SH_PCDISP12BY2:
	case BFD_RELOC_SH_USES:
	  symbol_ptr = seg->dot;
	  break;
	default:
	  break;
	}
    }

  if (fix->fx_r_type == BFD_RELOC_SH_USES)
    {
      /* We can't store the offset in the object file, since this
	 reloc does not take up any space, so we store it in r_offset.
	 The fx_addnumber field was set in md_apply_fix.  */
      intr->r_offset = fix->fx_addnumber;
    }
  else if (fix->fx_r_type == BFD_RELOC_SH_COUNT)
    {
      /* We can't store the count in the object file, since this reloc
         does not take up any space, so we store it in r_offset.  The
         fx_offset field was set when the fixup was created in
         sh_coff_frob_file.  */
      intr->r_offset = fix->fx_offset;
      /* This reloc is always absolute.  */
      symbol_ptr = NULL;
    }
  else if (fix->fx_r_type == BFD_RELOC_SH_ALIGN)
    {
      /* Store the alignment in the r_offset field.  */
      intr->r_offset = fix->fx_offset;
      /* This reloc is always absolute.  */
      symbol_ptr = NULL;
    }
  else if (fix->fx_r_type == BFD_RELOC_SH_CODE
	   || fix->fx_r_type == BFD_RELOC_SH_DATA
	   || fix->fx_r_type == BFD_RELOC_SH_LABEL)
    {
      /* These relocs are always absolute.  */
      symbol_ptr = NULL;
    }

  /* Turn the segment of the symbol into an offset.  */
  if (symbol_ptr != NULL)
    {
      dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
      if (dot != NULL)
	intr->r_symndx = dot->sy_number;
      else
	intr->r_symndx = symbol_ptr->sy_number;
    }
  else
    intr->r_symndx = -1;
}

#endif /* OBJ_COFF */
#endif /* ! BFD_ASSEMBLER */

#ifdef BFD_ASSEMBLER

a4372 1
#endif /* BFD_ASSEMBLER */
@


1.108
log
@Update the address and phone number of the FSF
@
text
@d3418 1
a3418 1
   create relocs so that md_apply_fix3 will fill in the correct values.  */
d3797 1
a3797 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
d4093 1
a4093 1
      shmedia_md_apply_fix3 (fixP, valP);
d4352 1
a4352 1
	 The fx_addnumber field was set in md_apply_fix3.  */
@


1.107
log
@(sh_elf_final_processing): Fix compile time warning by providing a prototype
for sh_symbian_find_elf_flags.
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.106
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d3780 5
a3784 1
      val = sh_symbian_find_elf_flags (valid_arch);
@


1.105
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d2403 1
a2403 1
  for (op_start = op_end = (unsigned char *) (str);
d2422 1
a2422 1
  *str_p = op_end;
d2737 1
a2737 1
  unsigned char *op_end;
@


1.104
log
@	* config/tc-sh.c (md_apply_fix3): Add parentheses around &
	within |.
@
text
@a4558 1
#endif
d4608 1
@


1.103
log
@Fix SH2A machine variants in order to correctly select instruction inheritance
@
text
@d3907 1
a3907 1
      buf[1] = (buf[1] & 0x0f) | (val >> 12) & 0xf0;
d3917 1
a3917 1
      buf[1] = (buf[1] & 0x0f) | (val >> 20) & 0xf0;
@


1.102
log
@include/elf/ChangeLog:
Introduce SH2a support.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* sh.h (EF_SH2A_NOFPU): New.
2003-12-01  Michael Snyder  <msnyder@@redhat.com>
* sh.h (EF_SH2A): New.
bfd/ChangeLog:
Introduce SH2a support.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* archures.c (bfd_mach_sh2a_nofpu): New.
* bfd-in2.h: Rebuilt.
* cpu-sh.c (SH2A_NOFPU_NEXT): New.
(arch_info_struct): Add sh2a_nofpu.
* elf32-sh.c (sh_elf_set_mach_from_flags): Handle sh2a_nofpu.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* reloc.c: Add relocs for sh2a.
* bfd-in2.h: Regenerate.
* libbfd.hh: Regenerate.
2003-12-01  Michael Snyder  <msnyder@@redhat.com>
* archures.c (bfd_mach_sh2a): New.
* bfd-in2.h: Rebuilt.
* cpu-sh.c (SH_NEXT, SH2_NEXT, etc.): Change defines to enums.
(SH2A_NEXT): New.
(arch_info_struct): Add sh2a.
* elf32-sh.c (sh_elf_set_mach_from_flags): Handle sh2a.
binutils/ChangeLog:
* readelf.c (get_machine_flags <EM_SH>): Handle EF_SH2A and
EF_SH2A_NOFPU.
gas/ChangeLog:
Introduce SH2a support.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (get_specific): Change arch_sh2a_up to
arch_sh2a_nofpu_up.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (md_parse_option): Add sh2a-nofpu ISA handling.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (sh_elf_final_processing): Move sh2a recognition
to end of conditional expression.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c: Add sh2a-nofpu support.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* tc-sh.c: Add sh2a support.
(parse_reg): Add tbr.
(parse_at): Support @@@@(disp,tbr).
(get_specific): Support sh2a opcodes.
(insert4): New, for 4 byte relocs.
(build_Mytes): Support sh2a opcodes.
(md_apply_fix3_Mytes): Support sh2a opcodes.
2003-12-02  Michael Snyder  <msnyder@@redhat.com>
* config/tc-sh.c (md_parse_option): Handle sh2a.
(sh_elf_final_processing): Ditto.
gas/testsuite/ChangeLog:
2003-12-30  DJ Delorie  <dj@@redhat.com>
* gas/sh/sh2a.s: New.
* gas/sh/sh2a.d: New.
* gas/sh/basic.exp: Add it.
@
text
@d3 1
a3 1
   2003, 2004  Free Software Foundation, Inc.
d842 1
a842 1
    = preset_target_arch ? preset_target_arch : arch_sh1_up & ~arch_sh_has_dsp;
d3086 1
a3086 1
      preset_target_arch = arch_sh1_up & ~(arch_sh_sp_fpu|arch_sh_dp_fpu);
d3095 1
a3095 1
	preset_target_arch = arch_sh1_up & ~(arch_sh_sp_fpu|arch_sh_dp_fpu);
d3097 1
a3097 1
	preset_target_arch = arch_sh1_up & ~arch_sh_has_dsp;
d3099 1
a3099 1
	preset_target_arch = arch_sh1_up;
@


1.101
log
@Rename sh-symbian-elf toolchain to sh-*-symbianelf
@
text
@d1101 6
d1277 9
a1285 1
  if (src[0] == '-')
d1358 4
d1563 30
d1603 1
d1648 1
d1669 16
d2110 10
d2205 2
a2206 2
  char nbuf[4];
  char *output = frag_more (2);
d2209 2
d2215 13
d2229 1
a2229 1
  for (index = 0; index < 4; index++)
d2261 42
d2367 13
d3871 51
@


1.100
log
@2004-06-30  Andrew Stubbs <andrew.stubbs@@superh.com>

	bfd:
	* elf32-sh.c: Include ../opcodes/sh-opc.h .
	* Makefile.am: Ran make dep-am .
	* Makefile.in: Ran make dep-in .

	gas:
	* config/tc-sh.c (md_assemble): Change isspace to ISSPACE.
	(md_parse_option): Remove redundant -isa testing.
	Make bfd_arch variable const.
	(md_show_usage): Make bfd_arch variable const.
@
text
@d3632 4
@


1.99
log
@2004-05-28  Andrew Stubbs <andrew.stubbs@@superh.com>

bfd:
	* Makefile.am: Regenerate dependencies.
	* Makefile.in: Regenerate.
	* archures.c: Add bfd_mach_sh3_nommu .
	* bfd-in2.h: Regenerate.
	* cpu-sh.c: Add sh3-nommu architecture.
	(bfd_to_arch_table): Create new table.
	(sh_get_arch_from_bfd_mach): Create new function.
	(sh_get_arch_up_from_bfd_mach): Create new function.
	(sh_merge_bfd_arch): Create new function.
	* elf32-sh.c (sh_ef_bfd_table): Add table.
	(sh_elf_check_relocs): Replace switch statement with
	use of sh_ef_bfd_table .
	(sh_elf_get_flags_from_mach): Add new function.
	(sh_find_elf_flags): Likewise.
	(sh_elf_copy_private_data): Replace most of non-elf contents
	with a call to sh_merge_bfd_arch() .

gas:
	* Makefile.am: Regenerate dependecies.
	* Makefile.in: Regenerate.
	* config/tc-sh.c (valid_arch): Make unsigned.
	(preset_target_arch): Likewise.
	(md_begin): Use new architecture flags system.
	(get_specific): Likewise.
	(assemble_ppi): Likewise.
	(md_assemble): Likewise. Also fix error check for bad opcodes.
	(md_parse_option): Likewise. Also generate -isa values according
	to the table in bfd/cpu-sh.c instead of just constants. Also
	allow <arch>-up ISA variants.
	(sh_elf_final_processing): Replace if-else chain with a call to
	sh_find_elf_flags().
	* testsuite/gas/sh/arch: New directory.
	* testsuite/gas/sh/arch/arch.exp: New test script.
	* testsuite/gas/sh/arch/arch_expected.txt: New file.
	* testsuite/gas/sh/arch/sh.s: New file.
	* testsuite/gas/sh/arch/sh2.s: New file.
	* testsuite/gas/sh/arch/sh-dsp.s: New file.
	* testsuite/gas/sh/arch/sh2e.s: New file.
	* testsuite/gas/sh/arch/sh3-nommu.s: New file.
	* testsuite/gas/sh/arch/sh3.s: New file.
	* testsuite/gas/sh/arch/sh3-dsp.s: New file.
	* testsuite/gas/sh/arch/sh3e.s: New file.
	* testsuite/gas/sh/arch/sh4-nommu-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4.s: New file.
	* testsuite/gas/sh/arch/sh4a-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4al-dsp.s: New file.
	* testsuite/gas/sh/arch/sh4a.s: New file.

include/elf:
	* sh.h (EF_SH_HAS_DSP): Remove.
	(EF_SH_HAS_FP): Remove.
	(EF_SH_MERGE_MACH): Remove.
	(EF_SH4_NOFPU): Convert to decimal.
	(EF_SH4A_NOFPU): Likewise.
	(EF_SH4_NOMMU_NOFPU): Likewise.
	(EF_SH3_NOMMU): Add new macro.
	(EF_SH_BFD_TABLE): Likewise.
	(sh_find_elf_flags): Add prototype.
	(sh_elf_get_flags_from_mach): Likewise.

opcodes:
	* sh-dis.c (target_arch): Make unsigned.
	(print_insn_sh): Replace (most of) switch with a call to
	sh_get_arch_from_bfd_mach(). Also use new architecture flags system.
	* sh-opc.h: Redefine architecture flags values.
	Add sh3-nommu architecture.
	Reorganise <arch>_up macros so they make more visual sense.
	(SH_MERGE_ARCH_SET): Define new macro.
	(SH_VALID_BASE_ARCH_SET): Likewise.
	(SH_VALID_MMU_ARCH_SET): Likewise.
	(SH_VALID_CO_ARCH_SET): Likewise.
	(SH_VALID_ARCH_SET): Likewise.
	(SH_MERGE_ARCH_SET_VALID): Likewise.
	(SH_ARCH_SET_HAS_FPU): Likewise.
	(SH_ARCH_SET_HAS_DSP): Likewise.
	(SH_ARCH_UNKNOWN_ARCH): Likewise.
	(sh_get_arch_from_bfd_mach): Add prototype.
	(sh_get_arch_up_from_bfd_mach): Likewise.
	(sh_get_bfd_mach_from_arch_set): Likewise.
	(sh_merge_bfd_arc): Likewise.

ld:
	* testsuite/ld-sh/arch/arch.exp: New test script.
	* testsuite/ld-sh/arch/arch_expected.txt: New file.
	* testsuite/ld-sh/arch/sh.s: New file.
	* testsuite/ld-sh/arch/sh2.s: New file.
	* testsuite/ld-sh/arch/sh-dsp.s: New file.
	* testsuite/ld-sh/arch/sh2e.s: New file.
	* testsuite/ld-sh/arch/sh3-nommu.s: New file.
	* testsuite/ld-sh/arch/sh3.s: New file.
	* testsuite/ld-sh/arch/sh3-dsp.s: New file.
	* testsuite/ld-sh/arch/sh3e.s: New file.
	* testsuite/ld-sh/arch/sh4-nommu-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4.s: New file.
	* testsuite/ld-sh/arch/sh4a-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4al-dsp.s: New file.
	* testsuite/ld-sh/arch/sh4a.s: New file.
@
text
@d2634 1
a2634 1
      while (isspace (*name))
d2638 1
a2638 1
      while (!isspace (name[name_length]))
d2948 1
a2948 9
      if (strcasecmp (arg, "sh4") == 0)
	preset_target_arch = arch_sh4;
      else if (strcasecmp (arg, "sh4-nofpu") == 0)
	preset_target_arch = arch_sh4_nofpu;
      else if (strcasecmp (arg, "sh4-nommu-nofpu") == 0)
	preset_target_arch = arch_sh4_nommu_nofpu;
      else if (strcasecmp (arg, "sh4a") == 0)
	preset_target_arch = arch_sh4a;
      else if (strcasecmp (arg, "dsp") == 0)
d2973 1
a2973 2
	  extern unsigned int sh_ef_archset_table[];
	  bfd_arch_info_type *bfd_arch = &bfd_sh_arch;
d3062 1
a3062 1
    bfd_arch_info_type *bfd_arch = &bfd_sh_arch;
@


1.98
log
@[gas]
	2004-04-01  Asgari Jinia  <asgarij@@kpitcummins.com>
		    Dhananjay Deshpande <dhananjayd@@kpitcummins.com>
	* config/tc-sh.c (dont_adjust_reloc_32): New variable.
	(sh_fix_adjustable): Avoid adjusting BFD_RELOC_32 when
	dont_adjust_reloc_32 is set.
	(md_longopts): Add option -renesas.
	(md_parse_option, md_show_usage): Likewise.
	* doc/c-sh.texi: Likewise.
[gas/testsuite]
	2004-04-01  Asgari Jinia  <asgarij@@kpitcummins.com>
	* gas/sh/renesas-1.s, gas/sh/renesas-1.d: New test for -renesas
	option.
	* gas/sh/basic.exp: Run the new test.
@
text
@d141 1
a141 1
static int preset_target_arch;
d145 1
a145 1
static int valid_arch;
d839 1
a839 1
  int target_arch;
d842 1
a842 1
    = preset_target_arch ? preset_target_arch : arch_sh1_up & ~arch_sh_dsp_up;
d856 1
a856 1
	  if (! (opcode->arch & target_arch))
d2021 1
a2021 1
      if ( !(valid_arch & this_try->arch))
d2023 1
a2023 1
      valid_arch &= this_try->arch;
d2489 1
a2489 1
		       && (valid_arch & arch_sh4al_dsp_up))
d2491 1
a2491 1
		  valid_arch &= arch_sh4al_dsp_up;
d2646 2
a2647 1
	  if (strncasecmp (op->name, name, name_length) == 0)
d2686 2
a2687 2
	  if (valid_arch & opcode->arch)
	    valid_arch &= opcode->arch;
d2940 1
a2940 1
      preset_target_arch = arch_sh1_up & ~arch_sh2e_up;
d2957 1
a2957 1
	preset_target_arch = arch_sh1_up & ~arch_sh2e_up;
d2959 1
a2959 1
	preset_target_arch = arch_sh2e_up;
d2979 29
a3007 1
	as_bad ("Invalid argument to --isa option: %s", arg);
d3066 1
a3066 4
-isa=[sh4\n\
    | sh4-nofpu		sh4 with fpu disabled\n\
    | sh4-nommu-nofpu   sh4 with no MMU or FPU\n\
    | sh4a\n\
d3068 12
a3079 2
    | fp\n\
    | any]		use most appropriate isa\n"));
d3642 1
a3642 28
  if (valid_arch & arch_sh1)
    val = EF_SH1;
  else if (valid_arch & arch_sh2)
    val = EF_SH2;
  else if (valid_arch & arch_sh2e)
    val = EF_SH2E;
  else if (valid_arch & arch_sh_dsp)
    val = EF_SH_DSP;
  else if (valid_arch & arch_sh3)
    val = EF_SH3;
  else if (valid_arch & arch_sh3_dsp)
    val = EF_SH3_DSP;
  else if (valid_arch & arch_sh3e)
    val = EF_SH3E;
  else if (valid_arch & arch_sh4_nommu_nofpu)
    val = EF_SH4_NOMMU_NOFPU;
  else if (valid_arch & arch_sh4_nofpu)
    val = EF_SH4_NOFPU;
  else if (valid_arch & arch_sh4)
    val = EF_SH4;
  else if (valid_arch & arch_sh4a_nofpu)
    val = EF_SH4A_NOFPU;
  else if (valid_arch & arch_sh4a)
    val = EF_SH4A;
  else if (valid_arch & arch_sh4al_dsp)
    val = EF_SH4AL_DSP;
  else
    abort ();
@


1.97
log
@	* config/tc-sh.c: Remove trailing whitespace.
@
text
@d135 4
d2890 1
d2898 2
d2901 1
a2901 1
#define OPTION_ABI                    (OPTION_ISA + 1)
d2942 4
d3033 2
d3580 1
@


1.96
log
@[gas]
	* config/tc-sh.c: Include dw2gencfi.h.
	(sh_cfi_frame_initial_instructions): New function.
	(sh_regname_to_dw2regnum): Likewise.
	* config/tc-sh.h (DWARF2_LINE_MIN_INSN_LENGTH): Move to the end of
	file.
	(TARGET_USE_CFIPOP): Define.
	(tc_cfi_frame_initial_instructions): Likewise.
	(tc_regname_to_dw2regnum): Likewise.
	(DWARF2_DEFAULT_RETURN_COLUMN, DWARF2_CIE_DATA_ALIGNMENT): Likewise.
	* Makefile.am: Update dependencies.
	* Makefile.in: Regenerate.

[gas/testsuite]
	* gas/cfi/cfi-sh-1.d: New file.
	* gas/cfi/cfi-sh-1.s: Likewise.
	* gas/cfi/cfi.exp: Add SH case.
@
text
@d1635 1
a1635 1
	      
d1643 1
a1643 1
	      
d1651 1
a1651 1
	      
d1659 1
a1659 1
	      
d1667 1
a1667 1
	      
d1675 1
a1675 1
	      
d1683 1
a1683 1
	      
d1692 1
a1692 1
	      
d1701 1
a1701 1
	      
d1710 1
a1710 1
	      
d1718 1
a1718 1
	      
d1726 1
a1726 1
	      
d1743 1
a1743 1
	      
d1752 1
a1752 1
	      
d3027 1
a3027 1
    | sh4a\n\ 
@


1.95
log
@2003-03-03  Andrew Stubbs  <andrew.stubbs@@superh.com>

opcodes:
	* sh-dis.c (print_insn_sh): Don't disassemble fp instructions in
	nofpu mode.  Add BFD type bfd_mach_sh4_nommu_nofpu.
	* sh-opc.h: Add sh4_nommu_nofpu architecture and adjust instructions
	accordingly.
bfd:
	* archures.c: Add bfd_mach_sh4_nommu_nofpu.
	* cpu-sh.c: Ditto.
	* elf32-sh.c: Ditto.
	* bfd-in2.h: Regenerate.
include/elf:
	* sh.h: Add EF_SH4_NOMMU_NOFPU.
gas:
	* config/tc-sh.c (md_parse_option): Add -isa=sh4-nofpu and
	-isa=sh4-nommu-nofpu options. Adjust help messages accordingly.
	(sh_elf_final_processing): Output BFD type sh4_nofpu if that is
	the most general type or the user specifically requested it.
	(md_assemble): Add a new error message for when an instruction
	is understood, but is not allowed due to an -isa option.
@
text
@d38 1
d4345 49
@


1.94
log
@Undo previous delta
Fix underlying problem by changing the order of tests of rel->howto.
@
text
@d2590 1
d2617 39
a2655 1
      as_bad (_("unknown opcode"));
d2937 4
d3022 8
a3029 1
-dsp			enable sh-dsp insns, and disable floating-point ISAs.\n"));
d3032 1
a3032 5
-isa=[sh4\n\
    | sh4a\n\
    | dsp		same as '-dsp'\n\
    | fp\n\
    | shmedia		set as the default instruction set for SH64\n\
d3035 1
a3035 1
    | SHcompact\n"));
a3045 7
#else
  fprintf (stream, _("\
-isa=[sh4\n\
    | sh4a\n\
    | dsp		same as '-dsp'\n\
    | fp\n\
    | any]\n"));
d3605 2
@


1.93
log
@Fix seg fault on erroneous input
@
text
@a1428 2
      if (! ISDIGIT (src[1]))
	as_bad (_("syntax error in #Imm"));
d4194 1
a4194 4
#ifdef OBJ_ELF
  if (rel->howto->type == R_SH_IND12W)
      rel->addend += fixp->fx_offset - 4;
#endif
d4204 4
@


1.92
log
@2004-02-23  Andrew Stubbs <andrew.stubbs@@superh.com>

gas:
	* tc-sh.c (build_Mytes): Add REG_N_D and REG_N_B01
	nibble types to assembler.
opcodes:
	* sh-dis.c (print_insn_sh): Add REG_N_D nibble type to
	ensure that double registers have even numbers.
	Add REG_N_B01 for nn01 (binary 01) nibble to ensure
	that reserved instruction 0xfffd does not decode the same
	as 0xfdfd (ftrv).
	* sh-opc.h: Add REG_N_D nibble type and use it whereever
	REG_N refers to a double register.
	Add REG_N_B01 nibble type and use it instead of REG_NM
	in ftrv.
	Adjust the bit patterns in a few comments.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d1429 2
@


1.91
log
@Fix SH compilation problems introduced by previous delta
@
text
@d2145 1
d2161 3
@


1.91.6.1
log
@[gas]
	* config/tc-sh.c: Include dw2gencfi.h.
	(sh_cfi_frame_initial_instructions): New function.
	(sh_regname_to_dw2regnum): Likewise.
	* config/tc-sh.h (DWARF2_LINE_MIN_INSN_LENGTH): Move to the end of
	file.
	(TARGET_USE_CFIPOP): Define.
	(tc_cfi_frame_initial_instructions): Likewise.
	(tc_regname_to_dw2regnum): Likewise.
	(DWARF2_DEFAULT_RETURN_COLUMN, DWARF2_CIE_DATA_ALIGNMENT): Likewise.
	* Makefile.am: Update dependencies.
	* Makefile.in: Regenerate.

[gas/testsuite]
	* gas/cfi/cfi-sh-1.d: New file.
	* gas/cfi/cfi-sh-1.s: Likewise.
	* gas/cfi/cfi.exp: Add SH case.
@
text
@a37 1
#include "dw2gencfi.h"
a4297 49

void
sh_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (15, 0);
}

int
sh_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum = -1;
  unsigned int i;
  const char *p;
  char *q;
  static struct { char *name; int dw2regnum; } regnames[] =
    {
      { "pr", 17 }, { "t", 18 }, { "gbr", 19 }, { "mach", 20 },
      { "macl", 21 }, { "fpul", 23 }
    };

  for (i = 0; i < ARRAY_SIZE (regnames); ++i)
    if (strcmp (regnames[i].name, regname) == 0)
      return regnames[i].dw2regnum;

  if (regname[0] == 'r')
    {
      p = regname + 1;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 16)
	return -1;
    }
  else if (regname[0] == 'f' && regname[1] == 'r')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 16)
	return -1;
      regnum += 25;
    }
  else if (regname[0] == 'x' && regname[1] == 'd')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 8)
	return -1;
      regnum += 87;
    }
  return regnum;
}
@


1.91.6.2
log
@Merge to 2.15 branch.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004  Free Software Foundation, Inc.
a134 4
/* Flag to generate relocations against symbol values for local symbols.  */

static int dont_adjust_reloc_32;

a2145 1
	    case REG_N_D:
a2161 3
	    case REG_N_B01:
	      nbuf[index] = reg_n | 0x01;
	      break;
a2842 1
#define OPTION_RENESAS (OPTION_ISA + 1)
a2849 2
  {"renesas", no_argument, NULL, OPTION_RENESAS},

d2851 1
a2851 1
#define OPTION_ABI                    (OPTION_RENESAS + 1)
a2891 4
    case OPTION_RENESAS:
      dont_adjust_reloc_32 = 1;
      break;

a2974 2
-renesas		disable optimization with section symbol for\n\
			compatibility with Renesas assembler.\n\
a3523 1
      || ((fixP->fx_r_type == BFD_RELOC_32) && dont_adjust_reloc_32)
d4191 4
a4194 1

a4203 4
#ifdef OBJ_ELF
  else if (rel->howto->type == R_SH_IND12W)
    rel->addend += fixp->fx_offset - 4;
#endif
@


1.90
log
@2003-12-03  Alexandre Oliva  <aoliva@@redhat.com>

	* config/tc-sh.c: Add support for sh4a and no-fpu variants,
	with appropriate additions to md_show_usage.
	* testsuite/gas/sh/basic.exp: Call tests for sh4a.
	* testsuite/gas/sh/{err-sh4a-fp.s, err-sh4a.s,
	err-sh4al-dsp.s, sh4a-dsp.d, sh4a-dsp.s, sh4a-fp.d,
	sh4a-fp.s, sh4a.d, sh4a.s, sh4al-dsp.d, sh4al-dsp.s:
	New files, tests for sh4a and related variants.
	* doc/c-sh.texi: Document new -isa options.
	* doc/c-sh64.texi: Ditto.
	* NEWS: Mention new support for sh4a.
@
text
@d2976 1
d2981 2
a2982 4
    | fp\n"
#ifdef HAVE_SH64
"\
    | shmedia		set default instruction set for SH64\n\
d2985 1
a2985 5
    | SHcompact\n"
#endif
"\
    | any]\n"));
#ifdef HAVE_SH64
d2995 8
a3002 1
			to 32 bits only"));
@


1.89
log
@Check for alignment when emitting constants on the sh-elf target
@
text
@d1403 1
a1403 1
	      op->type = A_PMOD_N;
d1409 1
a1409 1
	      op->type = A_PMODY_N;
a1581 2
	    case A_PMOD_N:
	    case A_PMODY_N:
d1627 231
d2301 1
d2332 32
d2367 2
d2390 2
d2420 7
d2432 13
d2459 13
d2476 10
a2485 1
	      if ((field_b & 0xef00) != 0xa100)
a2486 1
	      field_b -= 0x8100;
d2502 1
a2502 1
		  as_bad (_("bad padd / psub pmuls output operand"));
d2888 1
a2888 1
      preset_target_arch = arch_sh1_up & ~arch_sh3e_up;
d2894 6
d2975 15
a2989 1
-dsp			enable sh-dsp insns, and disable sh2e/sh3e/sh4 insns.\n"));
a2991 4
-isa=[shmedia		set default instruction set for SH64\n\
      | SHmedia\n\
      | shcompact\n\
      | SHcompact]\n\
d3538 1
a3538 1
     a processor with the sh-dsp / sh3e ISA to execute.  */
d3557 1
a3557 1
    val = EF_SH_DSP;
d3560 2
d3564 6
@


1.88
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d804 4
@


1.87
log
@	* config/tc-sh.c: Convert to ISO C90.  Remove unnecessary
        prototypes and casts.
	* config/tc-sh.h: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh64.h: Likewise.
@
text
@d139 1
a139 1
   accomodate the insns seen so far.  */
d154 1
a154 1
/* These are the three types of relaxable instrction.  */
d1341 1
a1341 1
		     as adressing sym, i.e. meaning the same as plain sym.
d3026 1
a3026 1
   the expession does not need to be aligned.  */
d3367 1
a3367 1
         is on a 4 byte bounday.  If this instruction is also on a 4
@


1.86
log
@	* config/tc-sh.c (md_assemble): For branches, check & update
	valid_arch here.
@
text
@d51 2
a52 24
static void s_uses PARAMS ((int));

static void sh_count_relocs PARAMS ((bfd *, segT, PTR));
static void sh_frob_section PARAMS ((bfd *, segT, PTR));

static void s_uacons PARAMS ((int));
static sh_opcode_info *find_cooked_opcode PARAMS ((char **));
static unsigned int assemble_ppi PARAMS ((char *, sh_opcode_info *));
static void little PARAMS ((int));
static void big PARAMS ((int));
static int parse_reg PARAMS ((char *, int *, int *));
static char *parse_exp PARAMS ((char *, sh_operand_info *));
static char *parse_at PARAMS ((char *, sh_operand_info *));
static void get_operand PARAMS ((char **, sh_operand_info *));
static char *get_operands
  PARAMS ((sh_opcode_info *, char *, sh_operand_info *));
static sh_opcode_info *get_specific
  PARAMS ((sh_opcode_info *, sh_operand_info *));
static void insert PARAMS ((char *, int, int, sh_operand_info *));
static void build_relax PARAMS ((sh_opcode_info *, sh_operand_info *));
static char *insert_loop_bounds PARAMS ((char *, sh_operand_info *));
static unsigned int build_Mytes
  PARAMS ((sh_opcode_info *, sh_operand_info *));
static bfd_boolean sh_local_pcrel PARAMS ((fixS *fix));
d55 1
a55 5
static void sh_elf_cons PARAMS ((int));

inline static int sh_PIC_related_p PARAMS ((symbolS *));
static int sh_check_fixup PARAMS ((expressionS *, bfd_reloc_code_real_type *));
inline static char *sh_end_of_match PARAMS ((char *, char *));
d61 1
a61 2
big (ignore)
     int ignore ATTRIBUTE_UNUSED;
d71 1
a71 2
little (ignore)
     int ignore ATTRIBUTE_UNUSED;
d485 1
a485 2
sh_PIC_related_p (sym)
     symbolS *sym;
d511 1
a511 3
sh_check_fixup (main_exp, r_type_p)
     expressionS *main_exp;
     bfd_reloc_code_real_type *r_type_p;
d737 1
a737 4
sh_cons_fix_new (frag, off, size, exp)
     fragS *frag;
     int off, size;
     expressionS *exp;
d782 1
d784 1
a784 2
sh_elf_cons (nbytes)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
d826 1
a826 1
md_begin ()
d866 1
a866 4
parse_reg (src, mode, reg)
     char *src;
     int *mode;
     int *reg;
d1216 1
a1216 3
parse_exp (s, op)
     char *s;
     sh_operand_info *op;
d1257 1
a1257 3
parse_at (src, op)
     char *src;
     sh_operand_info *op;
d1417 1
a1417 3
get_operand (ptr, op)
     char **ptr;
     sh_operand_info *op;
d1453 1
a1453 4
get_operands (info, args, operand)
     sh_opcode_info *info;
     char *args;
     sh_operand_info *operand;
d1511 1
a1511 3
get_specific (opcode, operands)
     sh_opcode_info *opcode;
     sh_operand_info *operands;
d1795 1
a1795 5
insert (where, how, pcrel, op)
     char *where;
     int how;
     int pcrel;
     sh_operand_info *op;
d1806 1
a1806 3
build_relax (opcode, op)
     sh_opcode_info *opcode;
     sh_operand_info *op;
d1840 1
a1840 3
insert_loop_bounds (output, operand)
     char *output;
     sh_operand_info *operand;
d1888 1
a1888 3
build_Mytes (opcode, operand)
     sh_opcode_info *opcode;
     sh_operand_info *operand;
d1999 1
a1999 2
find_cooked_opcode (str_p)
     char **str_p;
d2046 1
a2046 3
assemble_ppi (op_end, opcode)
     char *op_end;
     sh_opcode_info *opcode;
d2269 1
a2269 2
md_assemble (str)
     char *str;
d2377 1
a2377 1
sh_frob_label ()
d2402 1
a2402 1
sh_flush_pending_output ()
d2414 1
a2414 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d2423 1
a2423 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2429 1
a2429 2
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2447 1
a2447 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d2501 1
a2501 2
s_uses (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2556 1
a2556 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d2650 1
a2650 2
md_show_usage (stream)
     FILE *stream;
d2693 1
a2693 4
sh_count_relocs (abfd, sec, data)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
     PTR data;
d2719 2
a2720 4
sh_frob_section (abfd, sec, ignore)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
     PTR ignore ATTRIBUTE_UNUSED;
d2803 1
a2803 1
      bfd_map_over_sections (stdoutput, sh_count_relocs, (PTR) &info);
d2809 1
a2809 1
	  sh_count_relocs ((bfd *) NULL, iscan, (PTR) &info);
d2837 1
a2837 1
sh_frob_file ()
d2847 1
a2847 1
  bfd_map_over_sections (stdoutput, sh_frob_section, (PTR) NULL);
d2853 1
a2853 1
      sh_frob_section ((bfd *) NULL, iseg, (PTR) NULL);
a2861 1
md_convert_frag (headers, seg, fragP)
d2863 1
a2863 1
     bfd *headers ATTRIBUTE_UNUSED;
d2865 2
a2866 1
     object_headers *headers ATTRIBUTE_UNUSED;
a2867 2
     segT seg;
     fragS *fragP;
d3010 1
a3010 3
md_section_align (seg, size)
     segT seg ATTRIBUTE_UNUSED;
     valueT size;
d3035 1
a3035 2
s_uacons (bytes)
     int bytes;
d3049 1
a3049 2
sh_cons_align (nbytes)
     int nbytes;
d3089 1
a3089 2
sh_handle_align (frag)
     fragS *frag;
d3137 1
a3137 2
sh_local_pcrel (fix)
     fixS *fix;
d3154 1
a3154 2
sh_force_relocation (fix)
     fixS *fix;
d3189 1
a3189 2
sh_fix_adjustable (fixP)
   fixS *fixP;
d3206 1
a3206 1
sh_elf_final_processing ()
d3246 1
a3246 4
md_apply_fix3 (fixP, valP, seg)
     fixS * fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d3519 1
a3519 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP;
     register segT segment_type;
d3595 1
a3595 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
d3612 1
a3612 2
md_pcrel_from (fixP)
     fixS *fixP;
d3618 1
a3618 3
md_pcrel_from_section (fixP, sec)
     fixS *fixP;
     segT sec;
d3638 1
a3638 2
tc_coff_sizemachdep (frag)
     fragS *frag;
d3687 2
a3688 5
sh_coff_reloc_mangle (seg, fix, intr, paddr)
     segment_info_type *seg;
     fixS *fix;
     struct internal_reloc *intr;
     unsigned int paddr;
d3799 1
a3799 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d3872 1
a3872 2
sh_end_of_match (cont, what)
     char *cont, *what;
d3884 1
a3884 4
sh_parse_name (name, exprP, nextcharP)
     char const *name;
     expressionS *exprP;
     char *nextcharP;
@


1.85
log
@	* config/tc-sh.c (tc_gen_reloc): Test for R_SH_IND12W only when ELF.
@
text
@d2386 6
@


1.84
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d3951 1
d3954 1
@


1.83
log
@bfd:
        * archures.c (enum bfd_architecture): Amend comment to refer to SuperH.
        * cpu-sh.c: Likewise.
        * elf32-sh.c: Likewise.
        * reloc.c (bfd_reloc_code_real): Likewise.
        * elf32-sh64-com.c: Change comment to refer to SuperH.
        * elf32-sh64.c: Likewise.
        * elf64-sh64.c: Likewise.
        * bfd-in2.h (enum bfd_architecture): Regenerate.
binutils:
        * readelf.c (get_machine_name) <EM_SH>: Amend return value
        to refer to SuperH.
gas:
        * config/tc-sh.c: Amend comment to refer to SuperH.
        * config/tc-sh.h: Likewise.
        (LISTING_HEADER): Amend to refer to SuperH.
        * config/tc-sh64.c: Change comment to refer to SuperH.
        * config/tc-sh64.h (LISTING_HEADER): Change to refer to SuperH.
        * doc/as.texinfo [SH, GENERIC]: Amend / Change to refer to SuperH.
        * doc/c-sh.texi: Amend to refer to SuperH.
        Add SuperH architecture documentation references.
        * doc/c-sh64.texi: Change to refer to SuperH.
include/elf:
        * common.h (EM_SH): Amend comment to refer to SuperH.
ld/testsuite:
        * ld-sh/sh64/crange3-cmpct.rd (Machine): Change to refer to SuperH.
        * ld-sh/sh64/crange3-media.rd (Machine): Likewise.
@
text
@a138 4
#ifdef BFD_ASSEMBLER
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif
@


1.82
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@d1 1
a1 1
/* tc-sh.c -- Assemble code for the Renesas Super-H
@


1.81
log
@Fix sh-elf linker relaxation:

gcc:
	* config/sh/sh.h (EXTRA_SPECS): Add subtarget_asm_relax_spec and
	subtarget_asm_isa_spec.
	(SUBTARGET_ASM_RELAX_SPEC, SUBTARGET_ASM_ISA_SPEC): Define.
	(ASM_SPEC): Define as SH_ASM_SPEC.
	(SH_ASM_SPEC): New; take the role of ASM_SPEC, but safe from svr4.h.
	Use subtarget_asm_relax_spec and subtarget_asm_isa_spec.
	* config/sh/elf.h (ASM_SPEC): Use SH_ASM_SPEC.
	(SUBTARGET_ASM_ISA_SPEC): Undef / define.
gcc/testsuite:
	gcc.dg/sh-relax.c: New test.

include/elf:
	* sh.h (EF_SH_MERGE_MACH): Make sure SH2E & SH3/SH3E merge to SH3E,
	and SH2E & SH4 merge to SH4, not SH2E.

gas:
	* config/tc-sh.c (sh_dsp): Replace with preset_target_arch.
	(md_begin): Use preset_target_arch.
	(md_longopts): Make isa option unconditional.
	(md_parse_option): Make OPTION_DSP and OPTION_ISA sh4 / any
	set preset_target_arch.
	(md_apply_fix3): If BFD_ASSEMBLER, adjust SWITCH_TABLE fixups
	by -S_GET_VALUE  (fixP->fx_subsy).
	(tc_gen_reloc): For SWITCH_TABLE fixups, the symbol is fixp->fx_subsy,
	and the addend is 0.
	Adjust addend of R_SH_IND12W relocations by fixp->fx_offset - 4.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_LOCAL): Define.

bfd:
	elf32-sh.c (sh_elf_howto_tab): Make R_SH_IND12W into an ordinary
	relocation (no special function), and make it non-partial_inplace.
	(sh_elf_relax_section): When creating a bsr, use a consistent value
	no matter if the symbol is extern or not;  set addend to -4.
	Don't swap load / non-load instructions for SH4.
	(sh_elf_relax_delete_bytes): In R_SH_IND12W case, check the offset
	rather than if the symbol is external to determine if adjusting the
	offset makes sense.  Adjust the addend too if appropriate.
	(sh_elf_relocate_section): In R_SH_IND12W, don't fiddle with the
	relocation.
@
text
@d1 1
a1 1
/* tc-sh.c -- Assemble code for the Hitachi Super-H
@


1.80
log
@Add SH2E support
@
text
@d166 1
a166 1
/* Whether -dsp was seen.  */
d168 1
a168 1
static int sh_dsp;
d870 2
a871 1
  target_arch = arch_sh1_up & ~(sh_dsp ? arch_sh3e_up : arch_sh_dsp_up);
d2597 1
d2604 1
a2605 1
#define OPTION_ISA                    (OPTION_DSP + 1)
a2610 1
  {"isa",                    required_argument, NULL, OPTION_ISA},
d2646 1
a2646 1
      sh_dsp = 1;
d2649 5
d2655 1
a2655 2
    case OPTION_ISA:
      if (strcasecmp (arg, "shmedia") == 0)
d2669 1
d2674 1
d3391 4
a3394 1
#ifndef BFD_ASSEMBLER
d3915 2
a3916 1
      rel->addend = rel->address - S_GET_VALUE (fixp->fx_subsy);
d3955 2
@


1.79
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d2721 1
a2721 1
-dsp			enable sh-dsp insns, and disable sh3e / sh4 insns.\n"));
d3301 2
@


1.78
log
@	* config/tc-sh.c (md_apply_fix3): Take account of fx_offset
	for BFD_RELOC_32_PLT_PCREL.
	* sh/gas/sh/pic.s: Add a test for ".long foo@@PLT+.-2-label".
	* sh/gas/sh/pic.d: Add expected output.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d3239 1
a3239 3
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_START
d3246 1
a3246 1
      || S_FORCE_RELOC (fix->fx_addsy))
d3706 1
a3706 1
      && (S_FORCE_RELOC (fixP->fx_addsy)
@


1.77
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3519 1
a3519 1
      val = 0;
@


1.76
log
@	* config/tc-sh.c (md_apply_fix3): Call S_SET_THREAD_LOCAL
	for TLS relocations.
@
text
@d74 1
a74 1
static boolean sh_local_pcrel PARAMS ((fixS *fix));
d829 1
a829 1
  sh64_update_contents_mark (true);
d2351 1
a2351 1
      if (seen_insn == false)
d2353 1
a2353 1
	  sh64_update_contents_mark (true);
d2357 1
a2357 1
      seen_insn = true;
d2688 1
a2688 1
      sh64_mix = false;
d2692 1
a2692 1
      sh64_shcompact_const_crange = true;
d2696 1
a2696 1
      sh64_expand = false;
d2700 1
a2700 1
      sh64_pt32 = true;
d3065 1
a3065 1
      shmedia_md_convert_frag (headers, seg, fragP, true);
d3211 1
a3211 1
static boolean
d3215 8
a3222 8
  return (! sh_relax && 
	  (fix->fx_r_type == BFD_RELOC_SH_PCDISP8BY2
	   || fix->fx_r_type == BFD_RELOC_SH_PCDISP12BY2
	   || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY2
	   || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY4
	   || fix->fx_r_type == BFD_RELOC_8_PCREL
	   || fix->fx_r_type == BFD_RELOC_SH_SWITCH16
	   || fix->fx_r_type == BFD_RELOC_SH_SWITCH32));
d3267 1
a3267 1
boolean
@


1.75
log
@2002-11-20  Klee Dienes  <kdienes@@apple.com>

        * config/tc-mcore.c (md_begin): Use a const iterator.  Don't
        coalesce the name fields to use the same pointer.

        * config/tc-sh.c (md_begin): Use a const iterator.  Don't coalesce
        the name fields to use the same pointer.
        (get_specific): Check for opcodes with the same name using strcmp
        as well as comparing the pointer.
@
text
@a3546 2
    case BFD_RELOC_32_GOT_PCREL:
    case BFD_RELOC_SH_GOTPLT32:
d3550 4
a3557 1
    case BFD_RELOC_32_GOTOFF:
d3560 3
@


1.74
log
@	* config/tc-sh.c (sh_force_relocation): Make sure TLS relocs get
	emitted.
	(md_apply_fix3): Add TLS relocs.
	(sh_parse_name): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF and
	@@DTPOFF.
@
text
@d866 1
a866 1
  sh_opcode_info *opcode;
d882 1
a882 1
      if (strcmp (prev_name, opcode->name))
a888 6
      else
	{
	  /* Make all the opcodes with the same name point to the same
	     string.  */
	  opcode->name = prev_name;
	}
d1571 1
a1571 1
      if (this_try->name != name)
@


1.73
log
@	* config/tc-sh.c (assemble_ppi): Initialize reg_x / reg_y / reg_n
	inside loop.
@
text
@d3244 1
d3249 5
d3555 3
d3563 2
d4029 10
@


1.72
log
@	* contig/tc-sh.c (sh_local_pcrel): New.
	(sh_force_relocation): Use sh_local_pcrel.
	(md_pcrel_from_section): Check the relocation type whether it
	should be resolved locally. Use S_FORCE_RELOC.
	* testsuite/gas/sh/pcrel2.d: Check code also.
@
text
@a2125 6
  /* Some insn ignore one or more register fields, e.g. psts machl,a0.
     Make sure we encode a defined insn pattern.  */
  reg_x = 0;
  reg_y = 0;
  reg_n = 0;

d2129 6
@


1.71
log
@2002-09-27  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>

        * config/tc-sh.c (sh_force_relocation): Return 0 for
        some PC relative relocations when not relaxing.
        * testsuite/gas/sh/pcrel2.s: New.
        * testsuite/gas/sh/pcrel2.d: New.
        * testsuite/gas/sh/basic.exp: Add pcrel2 test.
@
text
@d74 1
d3215 16
d3241 1
a3241 8
  if (! sh_relax
      && (fix->fx_r_type == BFD_RELOC_SH_PCDISP8BY2
	  || fix->fx_r_type == BFD_RELOC_SH_PCDISP12BY2
	  || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY2
	  || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY4
	  || fix->fx_r_type == BFD_RELOC_8_PCREL
	  || fix->fx_r_type == BFD_RELOC_SH_SWITCH16
	  || fix->fx_r_type == BFD_RELOC_SH_SWITCH32))
d3697 3
a3699 4
  if (fixP->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixP->fx_addsy)
	  || S_IS_EXTERN (fixP->fx_addsy)
	  || S_IS_WEAK (fixP->fx_addsy)
@


1.70
log
@gas reloc rewrite.
@
text
@d3222 12
@


1.69
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@a3213 25
/* This macro decides whether a particular reloc is an entry in a
   switch table.  It is used when relaxing, because the linker needs
   to know about all such entries so that it can adjust them if
   necessary.  */

#ifdef BFD_ASSEMBLER
#define SWITCH_TABLE_CONS(fix) (0)
#else
#define SWITCH_TABLE_CONS(fix)				\
  ((fix)->fx_r_type == 0				\
   && ((fix)->fx_size == 2				\
       || (fix)->fx_size == 1				\
       || (fix)->fx_size == 4))
#endif

#define SWITCH_TABLE(fix)				\
  ((fix)->fx_addsy != NULL				\
   && (fix)->fx_subsy != NULL				\
   && S_GET_SEGMENT ((fix)->fx_addsy) == text_section	\
   && S_GET_SEGMENT ((fix)->fx_subsy) == text_section	\
   && ((fix)->fx_r_type == BFD_RELOC_32			\
       || (fix)->fx_r_type == BFD_RELOC_16		\
       || (fix)->fx_r_type == BFD_RELOC_8		\
       || SWITCH_TABLE_CONS (fix)))

a3221 1

d3225 2
a3226 1
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_END)
d3249 3
a3251 14

  if (fixP->fx_addsy == NULL)
    return 1;

  if (fixP->fx_r_type == BFD_RELOC_SH_PCDISP8BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCDISP12BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY4
      || fixP->fx_r_type == BFD_RELOC_8_PCREL
      || fixP->fx_r_type == BFD_RELOC_SH_SWITCH16
      || fixP->fx_r_type == BFD_RELOC_SH_SWITCH32)
    return 1;

  if (! TC_RELOC_RTSYM_LOC_FIXUP (fixP)
d3497 1
a3497 1
      val = fixP->fx_addnumber;
d3500 1
a3870 7
  if (fixp->fx_subsy
      && S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
    {
      fixp->fx_addnumber -= S_GET_VALUE (fixp->fx_subsy);
      fixp->fx_subsy = 0;
    }

d3914 1
a3914 1
  if (rel->howto == NULL || fixp->fx_subsy)
@


1.68
log
@Typo fixes in comment.
@
text
@d139 1
a139 1
  {"file", dwarf2_directive_file, 0 },
@


1.68.2.1
log
@Merge from mainline.
@
text
@d2125 6
a2133 6

      /* Some insn ignore one or more register fields, e.g. psts machl,a0.
	 Make sure we encode a defined insn pattern.  */
      reg_x = 0;
      reg_y = 0;
      reg_n = 0;
@


1.68.2.2
log
@Merge fixes from trunk.
@
text
@d3533 1
a3533 1
      val = fixP->fx_addnumber + fixP->fx_offset;
@


1.67
log
@	* config/tc-sh.c (get_specific): Revert 2002-05-01 change.
	(assemble_ppi): Generate warning if the same register is used
	twice as destination in the same padd / pmuls instruction.
@
text
@d2262 5
a2266 5
		/* Generate waring if destination register for padd / psub
		   and pmuls is same ( only for A0 or A1 )
		   If last nibble is 1010 then A0 is used in both padd / psub
		   and pmuls. If it is 1111 then A1 is used as destination
		   register in both padd / psub and pmuls */
@


1.66
log
@	* config/tc-sh.c (assemble_ppi): Initialize reg_n.
@
text
@a1591 21
 	  /* If this is a parallel insn check to see if both
	     parts have the same destination register.  */
 	  if ((n == 2) && (this_try->nibbles[0] == PPI))
	    {
	      static boolean bIsPPI = false;
	      static int nLastDestReg;

	      if (!bIsPPI)
		{
		  bIsPPI = true;
		  nLastDestReg = user->reg;
		}
	      else /* Second insn.  */
		{
		  if (nLastDestReg == user->reg)
		    as_warn (_("destination register is same for parallel insns"));

		  bIsPPI = false;
		}
	    }

d2262 9
@


1.65
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d2150 1
@


1.64
log
@Add comment for last change.
@
text
@d2604 1
a2604 1
CONST char *md_shortopts = "";
@


1.63
log
@	* config/tc-sh.c (parse_at): @@(symbol,pc) is A_DISP_PC again,
	but warn about it.
	* testsuite/gas/sh/pcrel.s: Also test @@(symbol,pc).
	* testsuite/gas/sh/pcrel.d: Update.
	* testsuite/gas/sh/pcrel.l: New file.
@
text
@d1386 15
@


1.62
log
@Define md_pcrel_from for use with sh-hms target.
@
text
@d1386 12
a1397 4
		  op->type = A_DISP_PC_ABS;
		  /* Such operands don't get corrected for PC==.+4, so
		     make the correction here.  */
		  op->immediate.X_add_number -= 4;
@


1.61
log
@	* config/obj-coff.h: Fix formatting.
	* config/tc-mcore.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-openrisc.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-xstormy16.h: Likewise.
@
text
@d2477 1
a2477 1
     object_headers *headers;
d2484 1
a2484 1
     object_headers *headers;
d2927 1
a2927 1
     object_headers *headers;
d3683 10
d3711 1
a3711 1
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address + 2;
@


1.60
log
@Generate warning if the same destination register is used in parallel
instructions.
@
text
@d436 1
a436 1
    SH64PCREL32_M, 
d557 1
a557 1
       
d562 1
a562 1
     which we can handle simply below.  */	
d623 1
a623 1
	      
d657 1
a657 1
	      
d661 1
a661 1
	      
d665 1
a665 1
	      
d681 1
a681 1
	      
d685 1
a685 1
	      
d689 1
a689 1
	      
d705 1
a705 1
	      
d709 1
a709 1
	      
d713 1
a713 1
	      
d729 1
a729 1
	      
d733 1
a733 1
	      
d737 1
a737 1
	      
d811 1
a811 1
    
d1585 1
a1585 1
		  
d3959 1
a3959 1
}  
d4006 1
a4006 1
  
@


1.59
log
@	* config/tc-sh.c (md_apply_fix3): Don't zero relocations on big
	endian hosts.
@
text
@d1569 21
@


1.58
log
@* config/tc-sh.c (dot): Removed unused function.
@
text
@d3313 1
a3313 1
  long val = * (long *) valP;
@


1.57
log
@Contribute sh64-elf.
2002-02-08  Alexandre Oliva  <aoliva@@redhat.com>
	    Stephen Clarke <Stephen.Clarke@@st.com>
* doc/c-sh64.texi: Fix citation of SH64 architecture manual.
2002-01-31  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-sh.c (md_relax_table): Added default sizes for
non-PC-relative UNDEF_MOVI, and relaxation sequences for
MOVI_16, MOVI_32 and MOVI_48.
* config/tc-sh64.c (shmedia_md_apply_fix3): Fix warning.
(shmedia_md_convert_frag): Handle non-PC-relative UNDEF_MOVI
and MOVI_16.
(shmedia_md_estimate_size_before_relax): Remove redundant
blocks.	 Set fragP->fr_var even if relaxation type unchanged.
Retain UNDEF_MOVI until expression decays to number.
2002-01-24  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-sh64.c (shmedia_init_reloc): Handle new SHmedia PIC
relocation types.  Take fixP->fx_addnumber into account too.
(shmedia_md_apply_fix): Likewise.
(shmedia_md_convert_frag): Likewise.
(shmedia_build_Mytes): Likewise.
(sh64_consume_datalabel): Complain about nested datalabel.
Support PIC relocs.  Call sh_parse_name.
* config/tc-sh64.h (TC_RELOC_RTSYM_LOC_FIXUP): Extend definition
in tc-sh.h to SHmedia reloc types.
* config/tc-sh.c (SH64PCRELPLT, MOVI_PLT, MOVI_GOTOFF,
MOVI_GOTPC): New relaxation constants.
(md_relax_table): Introduce relaxation directives for PIC-related
constants.
(sh_PIC_related_p): Handle datalabel.
(sh_check_fixup): Choose SH5 PIC relocations.
(sh_cons_fix_new): Added BDF_RELOC_64.
(md_apply_fix3, sh_parse_name): Handle GOTPLT.
2002-01-18  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-sh64.c (sh64_max_mem_for_rs_align_code): If the
current ISA is SHmedia, get 7 bytes.
2001-11-28  Nick Clifton  <nickc@@cambridge.redhat.com>
* config/tc-sh.c (md_apply_fix3): Treat shmedia_md_apply_fix3 as a
void function.
* config/tc-sh64.c (shmedia_apply_fix): Rename to
shmedia_apply_fix3 and make void.
2001-05-17  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-sh64.c (s_sh64_abi): Remove unused arguments passed to
as_bad.
2001-04-12  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-sh64.h (md_parse_name): Take &c as argument.
2001-03-14  DJ Delorie	<dj@@redhat.com>
* doc/Makefile.am (CPU_DOCS): Added c-sh64.texi
* doc/Makefile.in(CPU_DOCS): Ditto.
* doc/c-sh64.texi: New file.
* doc/as.texinfo: Add SH64 support.
2001-03-13  DJ Delorie	<dj@@redhat.com>
* config/tc-sh64.c (shmedia_get_operands): Rename A_RESV_Fx to
A_REUSE_PREV so that its purpose is more obvious.
(shmedia_build_Mytes): Ditto.
2001-03-07  DJ Delorie	<dj@@redhat.com>
* config/tc-sh64.c (sh64_vtable_entry): New, strip datalabels
before processing.
(sh64_vtable_inherit): Ditto.
(strip_datalabels): New, strip "datalabel" from given line.
* config/tc-sh.c (md_pseudo_table): Add sh64-specific vtable
pseudos.
2001-03-06  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (shmedia_md_assemble): Move dwarf2_emit_insn
call ...
(shmedia_build_Mytes): ... to here.
2001-03-06  DJ Delorie	<dj@@redhat.com>
* config/tc-sh.c: Remove sh64-specific uaquad now that there
is a generic one.
2001-01-21  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.h (DWARF2_LINE_MIN_INSN_LENGTH): Override.
* config/tc-sh64.c (shmedia_md_assemble): Offset recorded insn
address by one in call to dwarf2_emit_insn.
2001-01-13  Hans-Peter Nilsson	<hpn@@cygnus.com>
Implement ".abi" pseudo and correct .cranges descriptors.  Correct
alignment handling broken by imported changes.
* config/tc-sh64.h (HANDLE_ALIGN): Override definition in tc-sh.h.
(sh64_handle_align): Declare.
(MAX_MEM_FOR_RS_ALIGN_CODE): Override definition in tc-sh.h.
(sh64_max_mem_for_rs_align_code): Declare.
(enum sh64_isa_values): Moved here from tc-sh64.c.
(md_do_align): Define.
(sh64_do_align): Declare.
(struct sh64_tc_frag_data): New.
(TC_FRAG_TYPE): Change to struct sh64_tc_frag_data.  Users
changed.
(TC_FRAG_INIT): Change to set new datatype.
(struct sh64_segment_info_type): Rename member
last_flushed_location to last_contents_mark.  All users changed.
(md_elf_section_change_hook, TC_CONS_FIX_NEW): Do not define.
(shmedia_elf_new_section, sh64_tc_cons_fix_new): Do not prototype.
* config/tc-sh.c (md_pseudo_table): Add ".abi".
(sh_elf_cons) [HAVE_SH64]: Call sh64_update_contents_mark instead
of unsetting seen_insn.
(md_assemble) [HAVE_SH64] <before new SHcompact sequence>: Also
call sh64_update_contents_mark.
(sh_handle_align): Remove HAVE_SH64-conditioned code.
* config/tc-sh64.c (sh64_isa_mode): Correct type from boolean to
enum sh64_isa_values.
(sh64_set_contents_type): Drop segT parameter.	All callers changed.
(emitting_crange): Boolean guard moved to file scope from function
scope in sh64_set_contents_type.
(s_sh64_abi): New.
(sh64_update_contents_mark): New; most split out from
sh64_flush_pending_output.
(shmedia_md_end): Call sh64_update_contents_mark.  Set
sh64_isa_mode to sh64_isa_sh5_guard unless sh64_isa_unspecified.
(sh64_do_align): New function.
(sh64_max_mem_for_rs_align_code): New function.
(sh64_handle_align): Rename from shmedia_do_align.  Make
non-static.  Add head comment.	Emit zero bytes for n bytes modulo
four.  Change return-type to void.
(shmedia_elf_new_section): Remove.
(shmedia_md_assemble): Call sh64_update_contents_mark.
(s_sh64_mode): Ditto.  Do not call md_flush_pending_output.  Make
new frag.  Call sh64_update_contents_mark after making the new
frag.
(sh64_flush_pending_output): Just call sh64_update_contents_mark
and sh_flush_pending_output.
(sh64_flag_output): Also call md_flush_pending_output, but add
condition on not emitting_crange.
(sh64_tc_cons_fix_new): Remove.
2001-01-12  Nick Clifton  <nickc@@redhat.com>
* config/tc-sh64.c (shmedia_do_align): Fix to work with new
alignment handling scheme imported from sourceware.
2001-01-12  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.h (TARGET_FORMAT): Define.
(sh64_target_format): Prototype.
* config/tc-sh64.c (sh64_target_mach): New function.
2001-01-07  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (shmedia_md_end): When equating a symbol, use
zero_address_frag instead of copying the frag of the symbol.
(shmedia_frob_file_before_adjust): Ditto.
(shmedia_md_apply_fix) <case BFD_RELOC_SH_IMM_MEDLOW16>: Cast mask
to valueT to remove signedness.
(shmedia_md_convert_frag): Add parameter final.	 Rename parameter
headers to output_bfd.	Do not evaluate symbols if final is false;
do emit fixups.
(shmedia_md_estimate_size_before_relax) <case C (MOVI_IMM_32,
UNDEF_MOVI) et al>: If symbol cannot be modified to be PC-relative
to the current frag, call shmedia_md_convert_frag to emit fixups
and make frag_wane neutralize the frag.	 Update comments.
* config/tc-sh.c (md_convert_frag): Change caller of
shmedia_md_convert_frag.
2001-01-06  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.h: Tweak comments and correct formatting.
* config/tc-sh64.c: Ditto.
(shmedia_md_convert_frag) <PT/PTA/PTB 32, 48 and 64 bit
expansion, MOVI pcrel expansion>: Fix thinko calculating offset
for the no-relocation case.
(shmedia_check_limits): Fix range check being off-by-one for PTA.
* config/tc-sh.c: Ditto.  Add proper comments to #ifdef/#ifndef
wrappers.
(SH64PCREL16_F): Increment for proper max-PTA handling.	 Update
comment.
(SH64PCREL16_M, MOVI_16_M): Correct range thinko.
(SH64PCREL48_M, MOVI_48_M): Similar; don't count in length of
expansion.
(SH64PCREL32_M, MOVI_32_M): Ditto; handle overflowing expression.
Correct comment.
2001-01-05  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (shmedia_md_apply_fix) <second switch, case
BFD_RELOC_SH_PT_16>: Set lowest bit in field to be relocated to 1.
(shmedia_md_convert_frag) <case C (SH64PCREL16_32, SH64PCREL16) et
al>: Set lowest bit of field to relocate to 1 and rest to empty,
if reloc is emitted.
2000-12-31  Hans-Peter Nilsson	<hpn@@cygnus.com>
New options plus bugfixes.
* config/tc-sh.c (md_longopts): New options "-no-expand" and
"-expand-pt32".
(md_parse_option): Handle new options.
(md_show_usage): Add blurb for new options.
* config/tc-sh64.c (SHMEDIA_BFD_RELOC_PT): New macro.
(sh64_expand, sh64_pt32): New variables.
(shmedia_init_reloc): Handle BFD_RELOC_SH_PT_16.
(shmedia_md_apply_fix): Hold original fixP->fx_r_type in
orig_fx_r_type.	 Change SHMEDIA_BFD_RELOC_PT into
BFD_RELOC_SH_PT_16.  Handle BFD_RELOC_SH_PT_16 as pc-relative.
<resolved previously-pc-relative relocs>: Handle
SHMEDIA_BFD_RELOC_PT and BFD_RELOC_SH_PT_16.
(shmedia_md_convert_frag) <case C (SH64PCREL16PT_64, SH64PCREL16),
case C (SH64PCREL16PT_32, SH64PCREL16)>: Modify to PTB if operand
points to SHcompact code.
<case C (SH64PCREL16_32, SH64PCREL16), case C (SH64PCREL16_64,
SH64PCREL16)>: Check that ISA of what operand points at and
PTA/PTB matches, or emit error.
(shmedia_check_limits): Handle BFD_RELOC_SH_PT_16 and
SHMEDIA_BFD_RELOC_PT.
(shmedia_immediate_op): If pcrel, emit fixup also for constant
operand.
(shmedia_build_Mytes) <case A_IMMS16>: Also check sh64_expand in
condition for MOVI expansion.
<case A_PCIMMS16BY4>: Handle expansion to 32 bits only, if
sh64_pt32.  Emit only a BFD_RELOC_SH_PT_16 fixup if not
sh64_expand.
<case A_PCIMMS16BY4_PT>: Likewise, but emit a SHMEDIA_BFD_RELOC_PT
fixup.
(sh64_target_format): Error-check setting of sh64_pt32 and
sh64_expand.  Fix typo in check for sh64_shcompact_const_crange.
(shmedia_md_pcrel_from_section): Handle BFD_RELOC_SH_PT_16 and
SHMEDIA_BFD_RELOC_PT as coming from SHmedia code.
2000-12-31  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c: Improve comments.
(shmedia_md_convert_frag): Remove inactive is_pt_variant code.	Do
not say the linker will check correctness of PTA/PTB expansion.
(shmedia_md_end): Make non-static.
* config/tc-sh64.h (md_end): Define to shmedia_md_end.	Add
prototype.
* config/tc-sh.c (sh_finalize): Remove.
* config/tc-sh.h (md_end): Do not define.
Remove prototype for sh_finalize.
2000-12-30  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (shmedia_frob_section_type): Use a struct
sh64_section_data container when storing section type in tdata
field in elf_section_data.
* config/tc-sh.c (sh_elf_final_processing): Change from EF_SH64 to
EF_SH5.
* Makefile.am: Update dependencies.
* Makefile.in: Regenerate.
2000-12-22  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (shmedia_md_assemble): Don't protect
dwarf2_emit_insn call with test on debug_type.
2000-12-19  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (sh64_set_contents_type): Make contents-type
CRT_SH5_ISA32 sticky for 64-bit.
2000-12-18  Hans-Peter Nilsson	<hpn@@cygnus.com>
Generate .crange sections when switching ISA mode or emitting
constants in same section as code.
* config/tc-sh64.c: Reformat structure definitions.
(sh64_end_of_assembly, sh64_mix, sh64_shcompact_const_crange): New
variables.
(sh64_set_contents_type): Rename from sh64_init_section.  Rewrite
to emit a .cranges descriptor when contents type changes.  Only
emit error if changing contents type and -no-mix is in effect.
(sh64_emit_crange, sh64_flush_last_crange, sh64_flag_output,
sh64_flush_pending_output, sh64_tc_cons_fix_new): New functions.
(shmedia_md_end): Set sh64_end_of_assembly.  Pass
sh64_flush_last_crange over sections.
When checking main symbol of datalabel symbol, check for
STO_SH5_ISA32, not ISA type of section in definition.
(shmedia_frob_file_before_adjust): Check main symbol for
STO_SH5_ISA32; don't check ISA type of section in definition.
(shmedia_frob_section_type): Adjust for .cranges; set section flag
to SHF_SH5_ISA32_MIXED or SHF_SH5_ISA32 according to whether
.cranges entries have been output.
(shmedia_elf_new_section): Just call md_flush_pending_output.
(shmedia_md_assemble): Do not emit a BFD_RELOC_SH_SHMEDIA_CODE
fix.  Do not set tc_segment_info_data.in_code for section.  Call
sh64_set_contents_type for SHmedia code.
(s_sh64_mode): Do not call sh64_init_section or set seen_insn to
false.	Call md_flush_pending_output.
(sh64_target_format): Check that -no-mix and
-shcompact-const-crange are used in sane combination with other
options.
(shmedia_md_pcrel_from_section): Check type of fix for how to
adjust pc-relative.
(sh64_consume_datalabel): Check symbol for having STO_SH5_ISA32,
not ISA type of section in definition.
* config/tc-sh64.h (struct sh64_segment_info_type): Rewrite to
hold contents-type state.
(md_flush_pending_output): Redefine to sh64_flush_pending_output.
(sh64_flush_pending_output): Declare.
(TC_CONS_FIX_NEW): Define to sh64_tc_cons_fix_new.
(sh64_tc_cons_fix_new): Declare.
* config/tc-sh.c (sh_elf_cons) [HAVE_SH64]: Unset seen_insn and
call sh64_flag_output.
(md_assemble) [HAVE_SH64]: Do not emit BFD_RELOC_SH_CODE.  Just
call sh64_set_contents_type to mark SHcompact code and set
seen_insn.
(md_longopts): New options "-no-mix" and
"-shcompact-const-crange".
(md_parse_option): Handle new options.
(md_show_usage): Add blurb for new options.
(md_number_to_chars) [HAVE_SH64]: Call sh64_flag_output.
2000-12-15  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c: Delete investigated and obsolete fixme:s.
(sh64_last_insn_frag): New.
(shmedia_md_convert_frag): Use tc_frag_data field of incoming frag
to get frag for insn opcode for generating fixups; do not assume it
is the same frag.
(shmedia_build_Mytes): Set sh64_last_insn_frag after growing frag
for new insn.
* config/tc-sh64.h (ELF_TC_SPECIAL_SECTIONS): Define for .cranges
section.
(TC_FRAG_TYPE): Define as fragS *.
(TC_FRAG_INIT): Define to set tc_frag_data to sh64_last_insn_frag.
(sh64_last_insn_frag): Declare.
(sh64_consume_datalabel): Fix typo; check for seginfo != NULL,
not == NULL before dereferencing.
2000-12-12  Hans-Peter Nilsson	<hpn@@cygnus.com>
Get rid of BFD section flag and EF_SH64_ABI64.
* config/tc-sh64.c (shmedia_frob_section_type): Use
elf_section_data (sec)->tdata, not a specific BFD section flag, to
communicate the section as containing SHmedia code.  Describe why.
* config/tc-sh.c (sh_elf_final_processing): Tweak comment.  Set
EF_SH64 regardless of ABI.
* config/tc-sh64.c (shmedia_md_apply_fix): Decapitalize "invalid"
in error message.  Handle resolved expressions for
BFD_RELOC_SH_IMMS10, BFD_RELOC_SH_IMMS10BY2,
BFD_RELOC_SH_IMMS10BY4 and BFD_RELOC_64.
(shmedia_check_limits): Handle BFD_RELOC_64.
(sh64_adjust_symtab): Do not decrement the GAS symbol value for
a STO_SH5_ISA32 symbol, only the BFD value.
2000-12-11  Ben Elliston  <bje@@redhat.com>
* config/tc-sh64.c: Call dwarf2_emit_insn, not the defunct
dwarf2_generate_asm_lineno.
2000-12-11  Hans-Peter Nilsson	<hpn@@cygnus.com>
Handle PC-relative MOVI expansions with assembler relaxation.
Generate PC-relative relocs from 16-bit PC-relative expressions.
* config/tc-sh64.c (SHMEDIA_MD_PCREL_FROM_FIX): Break out from...
(shmedia_md_pcrel_from_section): ...here.
(shmedia_md_apply_fix): Handle fixups for 16-bit operands that has
turned completely resolved.  Adjust relocation type for 16-bit
immediate operands that has turned PC-relative.	 Adjust back for
MD_PCREL_FROM_SECTION being applied twice.
(shmedia_md_convert_frag): Always emit reloc for expression with
global or weak symbol.	Handle relaxation result for PC-relative
expressions.
(shmedia_md_estimate_size_before_relax): An expression with a weak
or global symbol can not be relaxed.  Break out tests for
relaxable symbol into variable sym_relaxable.
<cases C (MOVI_IMM_64, UNDEF_MOVI) and C (MOVI_IMM_32,
UNDEF_MOVI)>: Break out any PC-relative expression and change
relaxation type.
(shmedia_build_Mytes): CSE &operands->operands[j] into variable
opjp.
<case A_IMMS16>: Fix typo for initial minor relaxation type of
MOVI expansion.	 If X_op_symbol of the immediate expression is
set, make an expression symbol for the argument to frag_var.
* config/tc-sh.c (MOVI_IMM_32_PCREL, MOVI_IMM_64_PCREL): New
relaxations.
(END): Adjust for new relaxations.
(md_relax_table): Add entries for new relaxations.
2000-12-07  Ben Elliston  <bje@@redhat.com>
* config/tc-sh64.c (shmedia_parse_reg): Initialize variable len.
2000-12-07  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (shmedia_md_convert_frag): Correct all MOVI and
SHORI operand offsets in PT/PTA/PTB expansions.
2000-12-05  Hans-Peter Nilsson	<hpn@@cygnus.com>
Implement DataLabel semantics.
* config/tc-sh.c (sh_frob_file) [HAVE_SH64]: Call
shmedia_frob_file_before_adjust.
* config/tc-sh64.c [! OBJ_ELF]: Emit #error.
(DATALABEL_SUFFIX): Define.
(shmedia_md_end) <before adjusting STO_SH5_ISA32 symbols>: Walk
symbol list to update "datalabel" symbols to their main symbol
counterparts.
(shmedia_frob_file_before_adjust): New.
(sh64_adjust_symtab): For remaining datalabel symbols, set to
undefined and set STT_DATALABEL.
(sh64_frob_label): Initialize TC symbol field.
(sh64_consume_datalabel): Actually implement semantics.	 New
parameter operandf, call it instead of expression.
(sh64_exclude_symbol): New.
* config/tc-sh64.h (md_parse_name): Pass on the function operand
to sh64_consume_datalabel.
(tc_symbol_new_hook): Define to tc_frob_symbol.
(TC_SYMFIELD_TYPE): Define to symbolS *.
(tc_frob_symbol): Define to call sh64_exclude_symbol.
2000-12-01  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (shmedia_init_reloc): Tweak comment for default
case.
(shmedia_md_assemble): Call dwarf2_generate_asm_lineno if
generating dwarf2 debug information.
2000-11-30  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (sh64_target_format): Use elf64-sh64l and
elf64-sh64 for the 64-bit ABI.
* config/tc-sh.c (md_show_usage): Tweak usage output for -abi=*
option.
2000-11-29  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh.c: Remove conditionalizing on HAVE_SH64 for
case-insensitivity.
2000-11-27  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c: Tweak comments, formatting and error messages.
(enum sh64_abi_values): New type.
(enum sh64_isa_values): New type.
(sh64_isa_mode): Replace shmedia_mode.	All referers changed.
(seen_shcompact_mode, seen_shmedia_mode): Delete.
(sh64_abi): Replace shmedia_64.
(shmedia_md_convert_frag) <C (MOVI_IMM_64, MOVI_64),
C (MOVI_IMM_32, MOVI_32)>: Correct register number handling.
(s_sh64_mode): Check validity for this target.
(sh64_target_format): Initialize defaults for ISA and ABI.
Fallback to old object format if no SH64 ISA or ABI has been
specified.
* config/tc-sh.c (md_parse_option): Check combinations for errors.
(sh_elf_final_processing): Change to have EF_SH64_ABI64 for 64-bit
ABI and EF_SH64 for 32-bit ABI, if SH64 options are specified.
* config/tc-sh64.h: Fix typo in comment.
2000-11-25  Hans-Peter Nilsson	<hpn@@cygnus.com>
* config/tc-sh64.c (shmedia_md_estimate_size_before_relax)
<PT fixups for absolute values>: Size will be longest, not
shortest.
(shmedia_md_convert_frag): Disable PTB-warning machinery.  Correct
all MOVI and SHORI operand offsets in PT/PTA/PTB expansions.
* config/tc-sh.c (parse_reg) [HAVE_SH64]: Add local variables l0
and l1 to hold lowercase of two first characters.  Change all
remaining TO_LOWER to tolower.
* config/tc-sh64.c (TO_LOWER): Delete.
(shmedia_find_cooked_opcode): Use tolower, not TO_LOWER.
(md_parse_name): Define.
(sh64_consume_datalabel): Declare.
(DOLLAR_DOT): Define.
* config/tc-sh64.c (shmedia_parse_exp): New.
(sh64_consume_datalabel): New; just ignoring datalabel semantics.
(shmedia_parse_reg): Remove const from src
parameter.
(shmedia_get_operands): Ditto for args parameter and ptr variable.
(shmedia_md_assemble): Ditto for op_end variable.
(shmedia_get_operand): Ditto for ptr parameter and src variable.
Use shmedia_parse_exp, not parse_exp.
* config/tc-sh64.c (shmedia_parse_reg): Add shmedia_arg_type
parameter.  All callers changed.
(shmedia_get_operand): Add shmedia_arg_type parameter.	All
callers changed.
(shmedia_parse_reg): Put first two character in local variables.
Use tolower, not TO_LOWER.  If no register is found and argtype
indicates a control register, scan shmedia_creg_table
case-insensitive.
2000-11-24  Hans-Peter Nilsson	<hpn@@cygnus.com>
* Makefile.am (CPU_TYPES): Add sh64.
(TARGET_CPU_CFILES): Add config/tc-sh64.c.
(TARGET_CPU_HFILES): Add config/tc-sh64.h.
Regenerate dependencies.
* Makefile.in: Regenerate.
* configure.in: Add support for sh64-*-elf*.
* configure: Regenerate.
* config/tc-sh64.h: New.
* config/tc-sh64.c: New.
* config/tc-sh.c (md_pseudo_table) [HAVE_SH64]: New pseudos
.mode, .isa and .uaquad.
[HAVE_SH64] (SH64PCREL16_32, SH64PCREL16_64, SH64PCREL16PT_32,
SH64PCREL16PT_64, MOVI_IMM_32, MOVI_IMM_64): Define.
[HAVE_SH64] (END): Define as 10.
[HAVE_SH64] (UNDEF_SH64PCREL, SH64PCREL16, SH64PCREL32,
SH64PCREL48, SH64PCREL64, UNDEF_MOVI, MOVI_16, MOVI_32, MOVI_48,
MOVI_64): Define.
[HAVE_SH64] (SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH,
SH64PCREL32_F, SH64PCREL32_M, SH64PCREL32_LENGTH, SH64PCREL48_F,
SH64PCREL48_M, SH64PCREL48_LENGTH, SH64PCREL64_LENGTH,
MOVI_16_LENGTH, MOVI_32_LENGTH, MOVI_48_LENGTH, MOVI_64_LENGTH):
Define.
(md_relax_table) [HAVE_SH64]: Provide relaxations for SHmedia.
(md_begin) [HAVE_SH64]: Call shmedia_md_begin.
(parse_reg) [HAVE_SH64]: Parse register names case-insensitive.
(md_assemble) [HAVE_SH64]: Call shmedia_md_assemble if assembling
SHmedia instructions.  Handle state-change after switching to
SHcompact.
(md_longopts) [HAVE_SH64]: New options --isa=* and --abi=*.
(md_parse_option) [HAVE_SH64]: Parse new options.
(md_show_usage) [HAVE_SH64]: Show usage of new options.
(md_convert_frag) [HAVE_SH64] <default>: Call
shmedia_md_convert_frag instead of abort.
(sh_force_relocation) [HAVE_SH64]: Also force relocation for
BFD_RELOC_SH_SHMEDIA_CODE.
(sh_elf_final_processing) [HAVE_SH64]: Set flags identifying
SHcompact or SHmedia code.
(md_apply_fix) [HAVE_SH64] <default>: Return result from calling
shmedia_md_apply_fix instead of abort.
(md_estimate_size_before_relax) [HAVE_SH64] <default>: Return
result from calling shmedia_md_estimate_size_before_relax instead
of calling abort.
(sh_do_align) [HAVE_SH64]: If shmedia_mode, let shmedia_do_align
do the work.
(tc_gen_reloc) [HAVE_SH64]: For unrecognized relocs, call
shmedia_init_reloc and do nothing more if it returns non-zero.
(sh_finalize) [HAVE_SH64]: Call shmedia_md_end.
* po/POTFILES.in: Regenerate.
* po/gas.pot: Regenerate.
@
text
@a61 1
static symbolS *dot PARAMS ((void));
a1257 14
}

static symbolS *
dot ()
{
  const char *fake;

  /* JF: '.' is pseudo symbol with value of current location
     in current segment.  */
  fake = FAKE_LABEL_NAME;
  return  symbol_new (fake,
		      now_seg,
		      (valueT) frag_now_fix (),
		      frag_now);
@


1.57.2.1
log
@* config/tc-sh.c (dot): Removed unused function.
@
text
@d62 1
d1259 14
@


1.57.2.2
log
@	Merge from mainline.
	2002-04-17  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* config/tc-s390.c (tc_s390_fix_adjustable): Prevent adjustments to
	symbols in merge sections.

	2002-02-19  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* config/tc-s390.c (md_parse_option): Add switches -m31 and -m64.
	Make bit size independent of architecture switch.
	(md_begin): Add warning for -m64 with -Aesa.
	(s390_md_end): Use renamed architecture defines.

	2002-02-19  Tom Tromey  <tromey@@redhat.com>
	* config/tc-xstormy16.h (DWARF2_LINE_MIN_INSN_LENGTH): Define.

	Tue Apr  9 16:45:48 2002  J"orn Rennecke <joern.rennecke@@superh.com>
	* config/tc-sh.h (TC_FIX_ADJUSTABLE): Disable adjusting if
	symbol_used_in_reloc_p is true.
	* config/tc-sh.c (md_apply_fix3): Don't zero relocations on big
	endian hosts.
@
text
@d3313 1
a3313 1
  long val = (long) *valP;
@


1.57.2.3
log
@2002-05-11  Daniel Jacobowitz  <drow@@mvista.com>

        Merge from mainline:
        2002-05-11  Nick Clifton  <nickc@@cambridge.redhat.com>
        * config/obj-coff.c: Fix compile time warnings when compiling
        without BFD_ASSEMBLER defined.
        Fix formatting.

        * config/tc-sh.c (md_pcrel_from): Define for use with sh-hms
        target.
        (md_pcrel_from_section): Use md_pcrel_from().
@
text
@d2456 1
a2456 1
     object_headers *headers ATTRIBUTE_UNUSED;
d2463 1
a2463 1
     object_headers *headers ATTRIBUTE_UNUSED;
d2906 1
a2906 1
     object_headers *headers ATTRIBUTE_UNUSED;
a3661 10
/* This version is used in obj-coff.c when not using BFD_ASSEMBLER.
   eg for the sh-hms target.  */

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address + 2;
}

d3680 1
a3680 1
  return md_pcrel_from (fixP);
@


1.56
log
@* config/tc-sh.c (parse_at): Install the correct version of
2002-02-04's patch.
@
text
@d143 12
d187 2
d192 22
d216 2
d227 18
d275 79
d394 112
d528 5
d596 35
d636 1
d644 108
d753 1
d797 6
d826 10
d873 4
d2328 20
d2589 15
d2635 56
d2709 16
d2894 4
d3051 3
d3055 1
d3245 3
d3288 7
d3543 1
d3554 4
d3559 1
d3592 3
d3596 2
d3666 5
d3916 4
d4005 2
@


1.55
log
@* config/tc-sh.c (md_apply_fix3) <BFD_RELOC_32_PLT_PCREL>: Don't
assume fixP->fx_subsy is non-NULL.
@
text
@d984 4
a987 9
		  /* Turn a plain @@(4,pc) into @@(.+4,pc).  */
		  if (op->immediate.X_op == O_constant)
		    {
		      op->immediate.X_add_symbol = dot ();
		      op->immediate.X_op = O_symbol;
		      op->type = A_DISP_PC;
		    }
		  else
		    op->type = A_DISP_PC_ABS;
@


1.54
log
@* config/tc-sh.c (parse_at): Set arg type of @@(expr,pc) to
A_DISP_PC only if it's an integral constant, and to
A_DISP_PC_ABS otherwise.
(get_specific): Accept A_DISP_PC_ABS where A_DISP_PC is
expected.
(build_Mytes): Mark PCRELIMM fix-ups as pc-relative only if
the operand type is not A_DISP_PC_ABS.
@
text
@d2978 3
a2980 1
      val = fixP->fx_addnumber - S_GET_VALUE (fixP->fx_subsy);
@


1.53
log
@	* config/tc-sh.c (parse_reg): Fix end-of-word check for is, ix, iy
	and mod.
@
text
@d987 1
a987 1
		      op->immediate.X_add_symbol = dot();
d989 1
d991 2
a992 1
		  op->type = A_DISP_PC;
d1174 4
a1181 1
	    case A_DISP_PC:
d1611 2
a1612 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4, 1, operand);
d1615 2
a1616 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2, 1, operand);
@


1.52
log
@copyright years
@
text
@d601 1
a601 1
  if (l0 == 'i' && l1 && ! IDENT_CHAR ((unsigned char) src[3]))
d736 1
a736 1
      && ! IDENT_CHAR ((unsigned char) src[4]))
@


1.51
log
@* config/tc-sh.c (sh_elf_suffix): Removed.
(sh_PIC_related_p, sh_check_fixup, sh_cons_fix_new,
sh_end_of_match, sh_parse_name): New functions.
(sh_elf_cons): Simplify.
(parse_exp): Reject misplaced PIC operands.
(md_undefined_symbol): Simplify.
(sh_fix_adjustable): Let @@GOTOFF be adjusted.
(md_apply_fix3): Write @@PLT and @@GOTOFF addends in place.
(tc_gen_reloc): Move fixp subsy absolute value into addnumber.
Complain if subsy remains at the end.
* config/tc-sh.h (sh_parse_name, sh_cons_fix_new): Declare.
(md_parse_name, TC_CONS_FIX_NEW, O_PIC_reloc): Define.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.50
log
@* config/tc-sh.c (parse_at): Reject @@(r0) and @@(r0,).
@
text
@a60 2
static bfd_reloc_code_real_type sh_elf_suffix
  PARAMS ((char **str_p, expressionS *, expressionS *new_exp_p));
d79 4
d267 28
a294 6
/* Parse @@got, etc. and return the desired relocation.
   If we have additional arithmetic expression, then we fill in new_exp_p.  */
static bfd_reloc_code_real_type
sh_elf_suffix (str_p, exp_p, new_exp_p)
     char **str_p;
     expressionS *exp_p, *new_exp_p;
d296 40
a335 5
  struct map_bfd {
    char *string;
    int length;
    bfd_reloc_code_real_type reloc;
  };
d337 44
a380 6
  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  struct map_bfd *ptr;
d382 2
a383 1
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
d385 2
a386 24
  static struct map_bfd mapping[] = {
    MAP ("got",		BFD_RELOC_32_GOT_PCREL),
    MAP ("plt",		BFD_RELOC_32_PLT_PCREL),
    MAP ("gotoff",	BFD_RELOC_32_GOTOFF),
    { (char *)0,	0,	BFD_RELOC_UNUSED }
  };

  if (*str++ != '@@')
    return BFD_RELOC_UNUSED;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (ISALNUM (ch) || ch == '@@'));
       ch = *++str)
    *str2++ = TOLOWER (ch);

  *str2 = '\0';
  len = str2 - ident;

  ch = ident[0];
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->string, ptr->length) == 0)
d388 3
a390 4
	/* Now check for identifier@@suffix+constant */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
d392 3
a394 9
	    input_line_pointer = str;
	    expression (new_exp_p);
	    if (new_exp_p->X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp_p->X_add_number;
		str = input_line_pointer;
	      }
	    if (new_exp_p->X_op == O_subtract)
	      str = input_line_pointer;
d396 3
a398 3
	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }
d400 2
a401 2
	*str_p = str;
	return ptr->reloc;
d403 8
a410 2

  return BFD_RELOC_UNUSED;
d421 1
a421 3
  expressionS exp, new_exp;
  bfd_reloc_code_real_type reloc;
  const char *name;
d432 1
a432 73
      new_exp.X_op = O_absent;
      new_exp.X_add_symbol = new_exp.X_op_symbol = NULL;
      /* If the _GLOBAL_OFFSET_TABLE_ symbol hasn't been found yet,
	 use the name of the symbol to tell whether it's the
	 _GLOBAL_OFFSET_TABLE_.  If it has, comparing the symbols is
	 sufficient.  */
      if (! GOT_symbol && exp.X_add_symbol)
	name = S_GET_NAME (exp.X_add_symbol);
      else
	name = NULL;
      /* Check whether this expression involves the
	 _GLOBAL_OFFSET_TABLE_ symbol, by itself or added to a
	 difference of two other symbols.  */
      if (((GOT_symbol && GOT_symbol == exp.X_add_symbol)
	   || (! GOT_symbol && name
	       && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0))
	  && (exp.X_op == O_symbol
	      || (exp.X_op == O_add
		  && ((symbol_get_value_expression (exp.X_op_symbol)->X_op)
		      == O_subtract))))
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput,
								 BFD_RELOC_32);
	  int size = bfd_get_reloc_size (reloc_howto);

	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	  if (size > nbytes)
	    as_bad (_("%s relocations do not fit in %d bytes\n"),
		    reloc_howto->name, nbytes);
	  else
	    {
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
			   size, &exp, 0, TC_RELOC_GLOBAL_OFFSET_TABLE);
	    }
	}
      /* Check if this symbol involves one of the magic suffixes, such
	 as @@GOT, @@GOTOFF or @@PLT, and determine which relocation type
	 to use.  */
      else if ((exp.X_op == O_symbol || (exp.X_op == O_add && exp.X_op_symbol))
	  && *input_line_pointer == '@@'
	  && ((reloc = sh_elf_suffix (&input_line_pointer, &exp, &new_exp))
	      != BFD_RELOC_UNUSED))
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput,
								 reloc);
	  int size = bfd_get_reloc_size (reloc_howto);

	  /* Force a GOT to be generated.  */
	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	  if (size > nbytes)
	    as_bad (_("%s relocations do not fit in %d bytes\n"),
		    reloc_howto->name, nbytes);
	  else
	    {
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	      if (new_exp.X_op != O_absent)
		fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			     &new_exp, 0, BFD_RELOC_32);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
d871 6
d2022 1
a2022 1
     char *name;
a2023 18
#ifdef OBJ_ELF
  /* Under ELF we need to default _GLOBAL_OFFSET_TABLE.  Otherwise we
     have no need to default values of symbols.  */
  if (strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");

	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT)0, & zero_address_frag);
	}

      return GOT_symbol;
    }
#endif /* OBJ_ELF */

a2732 1
      || fixP->fx_r_type == BFD_RELOC_32_GOTOFF
d2971 2
d3002 1
d3316 7
d3362 1
a3362 1
  if (rel->howto == NULL)
d3375 83
@


1.49
log
@Corrected incorrect op->type selection due to missing 'else'.
@
text
@d917 1
a917 1
         @@(r0, rn) */
a927 4
	    src++;
	  /* Now can be rn or gbr */
	  len = parse_reg (src, &mode, &(op->reg));
	  if (mode == A_GBR)
d929 7
a935 1
	      op->type = A_R0_GBR;
d937 1
a937 1
	  else if (mode == A_REG_N)
d939 12
a950 1
	      op->type = A_IND_R0_REG_N;
d954 1
a954 1
	      as_bad (_("syntax error in @@(r0,...)"));
d959 1
a959 1
	  /* Must be an @@(disp,.. thing) */
d963 1
a963 1
	  /* Now can be rn, gbr or pc */
@


1.48
log
@Remove case sensitivity in register names.
@
text
@d992 2
a993 3
	{
	  as_bad (_("illegal register after @@"));
	}
d1008 2
a1009 2
	  if ((l0 == 'r' && l1 == '9')
	      || (l0 == 'i' && l1 == 'y'))
d1018 1
a1018 3
	{
	  op->type = A_IND_N;
	}
@


1.47
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d997 2
d1000 5
a1004 2
	  if ((src[0] == 'r' && src[1] == '8')
	      || (src[0] == 'i' && (src[1] == 'x' || src[1] == 's')))
d1009 2
a1010 2
	  if ((src[0] == 'r' && src[1] == '9')
	      || (src[0] == 'i' && src[1] == 'y'))
@


1.46
log
@	* bit_fix.h: Comment typo fix.
	* config/tc-mips.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-arc.c (arc_code_symbol): Remove unnecessary test.
@
text
@d2380 1
a2380 1
   create relocs so that md_apply_fix will fill in the correct values.  */
a2771 6
#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
#else
d2773 4
a2776 4
md_apply_fix (fixP, val)
     fixS *fixP;
     long val;
#endif
d2781 1
a2781 3
#ifdef BFD_ASSEMBLER
  long val = *valp;
#endif
d2807 1
a2807 1
	  return false;
d2811 1
a2811 1
	  return false;
a2960 3
#ifdef BFD_ASSEMBLER
      return 0;
#else
a2961 1
#endif
d2967 1
a2967 1
      *valp = 0xfffffffc;
d2987 1
a2987 1
      *valp -= 1;
d2992 1
a2992 1
      *valp = 0; /* Fully resolved at runtime.  No addend.  */
d3017 2
a3018 3
#ifdef BFD_ASSEMBLER
  return 0;
#endif
d3249 1
a3249 1
	 The fx_addnumber field was set in md_apply_fix.  */
@


1.45
log
@	* config/tc-sh.c (shl): Remove.
 	(big): New function.
	(little): Remove shl handling.  Emit error for endian mismatch.
	(md_show_usage): Add description of -big.
	(md_parse_option): Handle OPTION_BIG.  Remove shl handling.
	(OPTION_BIG): Add.
	(md_pseudo_table): Add .big.
	(md_longopts): Add -big.
	(md_begin): Don't set target_big_endian here.
	* config/tc-sh.h (TARGET_BYTES_BIG_ENDIAN): Remove.
	(LISTING_HEADER, COFF_MAGIC, TARGET_FORMAT): Use target_big_endian.
	(shl): Remove.
	* configure.in (endian): Default is big.
	(sh-*-pe*): Little endian.
	(cpu_type): Set sh for target sh*.
	* configure: Regenerate.
@
text
@d2455 1
a2455 1
	/* If this is a dalayed branch, we may not put the bra in the
@


1.44
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d60 1
d84 10
a93 1
int shl = 0;
d99 4
a102 1
  shl = 1;
d123 1
a455 8
#ifdef TE_PE
  /* The WinCE OS only supports little endian executables.  */
  target_big_endian = 0;
#else
  if (! shl)
    target_big_endian = 1;
#endif

d2136 2
a2137 1
#define OPTION_LITTLE (OPTION_MD_BASE + 1)
d2142 1
d2161 4
a2165 1
      shl = 1;
d2191 1
@


1.43
log
@	* config/tc-sh.c (md_pcrel_from_section): Transformed from
	md_pcrel_from.  Handle pc-relativeness against link-time
	symbol.  Handle relativeness to elsewhere than the fixup.
@
text
@d2443 1
a2443 1
	/* If this is a dalayed branch, we may not put the the bra in the
@


1.42
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d3111 1
a3111 1
md_pcrel_from (fixP)
d3113 1
d3115 13
@


1.41
log
@	* config/tc-sh.h (sh_force_relocation): Prototype.
	(struct fix): Forward declare.
	* config/tc-sh.c (type sh_operand_info): Move to top of file.
	(cons, s_align_bytes): Remove old-type declarations.
	(sh_elf_suffix, parse_reg, dot, parse_exp, parse_at, get_operand,
	get_operands, get_specific, insert, build_relax,
	insert_loop_bounds, build_Mytes): Prototype.
	(little): Make static.  Prototype.
	(check, tc_Nout_fix_to_chars): Delete unused functions.
@
text
@d30 1
a30 1
#include <ctype.h>
d285 1
a285 1
	&& (isalnum (ch) || ch == '@@'));
d287 1
a287 3
    {
      *str2++ = (islower (ch)) ? ch : tolower (ch);
    }
d480 1
a480 1
#define IDENT_CHAR(c) (isalnum (c) || (c) == '_')
d490 2
a491 2
  char l0 = tolower (src[0]);
  char l1 = l0 ? tolower (src[1]) : 0;
d546 1
a546 1
	  if (tolower (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d561 1
a561 1
	  if (tolower (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d642 1
a642 1
      && tolower (src[2]) == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
d648 1
a648 1
  if (l0 == 's' && l1 == 'p' && tolower (src[2]) == 'c'
d655 1
a655 1
  if (l0 == 's' && l1 == 'g' && tolower (src[2]) == 'r'
d662 1
a662 1
  if (l0 == 'd' && l1 == 's' && tolower (src[2]) == 'r'
d669 1
a669 1
  if (l0 == 'd' && l1 == 'b' && tolower (src[2]) == 'r'
d701 1
a701 1
  if (l0 == 'g' && l1 == 'b' && tolower (src[2]) == 'r'
d707 1
a707 1
  if (l0 == 'v' && l1 == 'b' && tolower (src[2]) == 'r'
d714 1
a714 1
  if (l0 == 'm' && l1 == 'a' && tolower (src[2]) == 'c'
d717 1
a717 1
      if (tolower (src[3]) == 'l')
d722 1
a722 1
      if (tolower (src[3]) == 'h')
d728 1
a728 1
  if (l0 == 'm' && l1 == 'o' && tolower (src[2]) == 'd'
d810 2
a811 2
  if (l0 == 'f' && l1 == 'p' && tolower (src[2]) == 'u'
      && tolower (src[3]) == 'l'
d818 3
a820 3
  if (l0 == 'f' && l1 == 'p' && tolower (src[2]) == 's'
      && tolower (src[3]) == 'c'
      && tolower (src[4]) == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
d826 3
a828 3
  if (l0 == 'x' && l1 == 'm' && tolower (src[2]) == 't'
      && tolower (src[3]) == 'r'
      && tolower (src[4]) == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
d1638 1
a1638 1
	 be capitailzed.  Instead of hacking up the machine independent
d1640 1
a1640 1
      c = isupper (c) ? tolower (c) : c;
@


1.40
log
@Fix seg fault by replacing symbol_get_frag() with fscan->fx_frag.
@
text
@d39 8
a55 2
void cons ();
void s_align_bytes ();
d59 17
a481 8
typedef struct
  {
    sh_arg_type type;
    int reg;
    expressionS immediate;
  }
sh_operand_info;

a1398 15
int
check (operand, low, high)
     expressionS *operand;
     int low;
     int high;
{
  if (operand->X_op != O_constant
      || operand->X_add_number < low
      || operand->X_add_number > high)
    {
      as_bad (_("operand must be absolute in range %d..%d"), low, high);
    }
  return operand->X_add_number;
}

a1503 1

a2186 7
void
tc_Nout_fix_to_chars ()
{
  printf (_("call to tc_Nout_fix_to_chars \n"));
  abort ();
}

@


1.39
log
@Stop sh-coff port from trying to call dwarf2 debug functions
@
text
@d2343 2
a2344 2
      fix_new (symbol_get_frag (sym),
	       S_GET_VALUE (sym) - symbol_get_frag (sym)->fr_address,
@


1.38
log
@Fix more breakages from the multiple relax pass patch.
@
text
@d100 1
d103 1
d1950 1
d1952 1
@


1.37
log
@Prepare for multi-pass relaxation.
@
text
@a142 2
#define UNCOND12 1
#define UNCOND32 2
d191 3
a193 1
  EMPTY, EMPTY, EMPTY, EMPTY,
d203 3
a205 1
  EMPTY, EMPTY, EMPTY, EMPTY,
d213 4
a216 1
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
d3036 2
a3047 1
	  fragP->fr_var = md_relax_table[C (UNCOND_JUMP, UNCOND12)].rlx_length;
a3051 1
	  fragP->fr_var = md_relax_table[C (UNCOND_JUMP, UNCOND12)].rlx_length;
a3055 1
	  fragP->fr_var = md_relax_table[C (UNCOND_JUMP, UNCOND32)].rlx_length;
d3061 1
a3065 1
	  int what = GET_WHAT (fragP->fr_subtype);
a3068 1
	  fragP->fr_var = md_relax_table[C (what, COND8)].rlx_length;
a3071 1
	  int what = GET_WHAT (fragP->fr_subtype);
a3073 1
	  fragP->fr_var = md_relax_table[C (what, COND32)].rlx_length;
a3076 1
	  int what = GET_WHAT (fragP->fr_subtype);
a3078 1
	  fragP->fr_var = md_relax_table[C (what, COND8)].rlx_length;
d3083 1
d3086 2
d3090 2
d3094 1
a3094 1
	 do anything.  */
d3097 2
@


1.36
log
@* config/tc-sh.c (parse_reg): Match capital MACH and MACL.
@
text
@d3033 3
a3051 1
	  return md_relax_table[C (UNCOND_JUMP, UNCOND32)].rlx_length;
a3054 2
    default:
      abort ();
a3072 1
	  return md_relax_table[C (what, COND32)].rlx_length;
d3081 1
d3083 8
@


1.35
log
@Fix copyright notices
@
text
@d697 1
a697 1
      if (src[3] == 'l')
d702 1
a702 1
      if (src[3] == 'h')
@


1.34
log
@* config/tc-sh.c (md_pseudo_table): Add uaquad.  Use s_uacons for
2byte, 4byte and 8byte.
@
text
@d2 2
a3 2
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation.
@


1.33
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000 Free Software Foundation.
d96 6
a101 2
  { "file", dwarf2_directive_file, 0 },
  { "loc", dwarf2_directive_loc, 0 },
@


1.33.2.1
log
@* config/tc-sh.c (md_pseudo_table): Add uaquad.  Use s_uacons for
2byte, 4byte and 8byte.
@
text
@d2 1
a2 2
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation.
d95 2
a96 6
  {"uaquad", s_uacons, 8},
  {"2byte", s_uacons, 2},
  {"4byte", s_uacons, 4},
  {"8byte", s_uacons, 8},
  {"file", dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
@


1.33.2.2
log
@Update copyright notices.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.33.2.3
log
@Merge from mainline.
@
text
@d143 2
d193 1
a193 3
  /* C (COND_JUMP, UNDEF_WORD_DISP) */
  { 0, 0, COND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
d203 1
a203 3
  /* C (COND_JUMP_DELAY, UNDEF_WORD_DISP) */
  { 0, 0, COND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
d211 1
a211 4
  EMPTY,
  /* C (UNCOND_JUMP, UNDEF_WORD_DISP) */
  { 0, 0, UNCOND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
d697 1
a697 1
      if (tolower (src[3]) == 'l')
d702 1
a702 1
      if (tolower (src[3]) == 'h')
a3030 2
  int what;

a3032 3
    default:
      abort ();

d3038 1
d3043 1
d3048 2
d3053 2
a3056 1
      what = GET_WHAT (fragP->fr_subtype);
d3061 1
d3065 1
d3069 1
d3072 2
d3077 1
d3080 1
a3081 1
      break;
a3082 13
    case C (UNCOND_JUMP, UNCOND12):
    case C (UNCOND_JUMP, UNCOND32):
    case C (UNCOND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP, COND8):
    case C (COND_JUMP, COND12):
    case C (COND_JUMP, COND32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP_DELAY, COND8):
    case C (COND_JUMP_DELAY, COND12):
    case C (COND_JUMP_DELAY, COND32):
    case C (COND_JUMP_DELAY, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
a3084 2

  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
@


1.33.2.4
log
@Stop sh-coff port from trying to call dwarf2 debug functions
@
text
@a99 1
#ifdef BFD_ASSEMBLER
a101 1
#endif
a1947 1
#ifdef BFD_ASSEMBLER
a1948 1
#endif
@


1.32
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d2585 1
a2585 1
  p = frag_var (rs_align_code, 1, 1, (relax_substateT) 0,
d2599 33
d2633 2
a2634 1
      && frag->fr_type == rs_align
a2639 4

  if (frag->fr_type == rs_align_code
      && frag->fr_next->fr_address - frag->fr_address - frag->fr_fix != 0)
    as_warn_where (frag->fr_file, frag->fr_line, _("misaligned data"));
a3113 30

/* When we align the .text section, insert the correct NOP pattern.  */

int
sh_do_align (n, fill, len, max)
     int n;
     const char *fill;
     int len ATTRIBUTE_UNUSED;
     int max;
{
  if (fill == NULL
      && subseg_text_p (now_seg)
      && n > 1)
    {
      static const unsigned char big_nop_pattern[] = { 0x00, 0x09 };
      static const unsigned char little_nop_pattern[] = { 0x09, 0x00 };

      /* First align to a 2 byte boundary, in case there is an odd
         .byte.  */
      frag_align (1, 0, 0);
      if (target_big_endian)
	frag_align_pattern (n, big_nop_pattern, sizeof big_nop_pattern, max);
      else
	frag_align_pattern (n, little_nop_pattern, sizeof little_nop_pattern,
			    max);
      return 1;
    }

  return 0;
}
@


1.31
log
@	(parse_reg): Parse names case-insensitively.
@
text
@d236 1
a236 1
#define MAP(str,reloc) { str, sizeof(str)-1, reloc }
@


1.30
log
@	(sh_elf_cons): Cast *input_line_pointer to unsigned char when
	indexing is_end_of_line[].
	(md_assemble): Initialize size to 0.
	(md_section_align): Mark parameter seg as unused.
@
text
@d465 3
d472 1
a472 1
  if (src[0] == 'r')
d474 1
a474 1
      if (src[1] == '1')
d484 1
a484 1
      if (src[1] >= '0' && src[1] <= '9'
d488 1
a488 1
	  *reg = (src[1] - '0');
d491 1
a491 1
      if (src[1] >= '0' && src[1] <= '7' && strncmp (&src[2], "_bank", 5) == 0
d495 1
a495 1
	  *reg  = (src[1] - '0');
d499 1
a499 1
      if (src[1] == 'e' && ! IDENT_CHAR ((unsigned char) src[2]))
d504 1
a504 1
      if (src[1] == 's' && ! IDENT_CHAR ((unsigned char) src[2]))
d511 1
a511 1
  if (src[0] == 'a')
d513 1
a513 1
      if (src[1] == '0')
d521 1
a521 1
	  if (src[2] == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d528 1
a528 1
      if (src[1] == '1')
d536 1
a536 1
	  if (src[2] == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d544 1
a544 1
      if (src[1] == 'x' && src[2] >= '0' && src[2] <= '1'
d548 1
a548 1
	  *reg = 4 + (src[1] - '0');
d551 1
a551 1
      if (src[1] == 'y' && src[2] >= '0' && src[2] <= '1'
d555 1
a555 1
	  *reg = 6 + (src[1] - '0');
d558 1
a558 1
      if (src[1] == 's' && src[2] >= '0' && src[2] <= '3'
d561 1
a561 1
	  int n = src[1] - '0';
d569 1
a569 1
  if (src[0] == 'i' && src[1] && ! IDENT_CHAR ((unsigned char) src[3]))
d571 1
a571 1
      if (src[1] == 's')
d577 1
a577 1
      if (src[1] == 'x')
d583 1
a583 1
      if (src[1] == 'y')
d591 1
a591 1
  if (src[0] == 'x' && src[1] >= '0' && src[1] <= '1'
d595 1
a595 1
      *reg = A_X0_NUM + src[1] - '0';
d599 1
a599 1
  if (src[0] == 'y' && src[1] >= '0' && src[1] <= '1'
d603 1
a603 1
      *reg = A_Y0_NUM + src[1] - '0';
d607 1
a607 1
  if (src[0] == 'm' && src[1] >= '0' && src[1] <= '1'
d611 1
a611 1
      *reg = src[1] == '0' ? A_M0_NUM : A_M1_NUM;
d615 3
a617 3
  if (src[0] == 's'
      && src[1] == 's'
      && src[2] == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
d623 1
a623 1
  if (src[0] == 's' && src[1] == 'p' && src[2] == 'c'
d630 1
a630 1
  if (src[0] == 's' && src[1] == 'g' && src[2] == 'r'
d637 1
a637 1
  if (src[0] == 'd' && src[1] == 's' && src[2] == 'r'
d644 1
a644 1
  if (src[0] == 'd' && src[1] == 'b' && src[2] == 'r'
d651 1
a651 1
  if (src[0] == 's' && src[1] == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
d657 1
a657 1
  if (src[0] == 's' && src[1] == 'p' && ! IDENT_CHAR ((unsigned char) src[2]))
d664 1
a664 1
  if (src[0] == 'p' && src[1] == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
d669 1
a669 1
  if (src[0] == 'p' && src[1] == 'c' && ! IDENT_CHAR ((unsigned char) src[2]))
d676 1
a676 1
  if (src[0] == 'g' && src[1] == 'b' && src[2] == 'r'
d682 1
a682 1
  if (src[0] == 'v' && src[1] == 'b' && src[2] == 'r'
d689 1
a689 1
  if (src[0] == 'm' && src[1] == 'a' && src[2] == 'c'
d703 1
a703 1
  if (src[0] == 'm' && src[1] == 'o' && src[2] == 'd'
d709 1
a709 1
  if (src[0] == 'f' && src[1] == 'r')
d729 1
a729 1
  if (src[0] == 'd' && src[1] == 'r')
d749 1
a749 1
  if (src[0] == 'x' && src[1] == 'd')
d769 1
a769 1
  if (src[0] == 'f' && src[1] == 'v')
d785 2
a786 1
  if (src[0] == 'f' && src[1] == 'p' && src[2] == 'u' && src[3] == 'l'
d793 3
a795 2
  if (src[0] == 'f' && src[1] == 'p' && src[2] == 's' && src[3] == 'c'
      && src[4] == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
d801 3
a803 2
  if (src[0] == 'x' && src[1] == 'm' && src[2] == 't' && src[3] == 'r'
      && src[4] == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
@


1.29
log
@	* config/tc-sh.c (md_convert_frag) <undefined symbol, conditional
	jump>: Use as_bad_where	instead of as_bad.  Tweak error message
	accordingly.  Stabilize frag by updating fix part and resetting
	variant part.
	<undefined symbol, unconditional jump>: Ditto.
@
text
@d391 1
a391 1
       while (! is_end_of_line[*input_line_pointer++]);
d1864 1
a1864 1
  unsigned int size;
d2508 1
a2508 1
     segT seg;
@


1.28
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d2394 2
a2395 2
	as_bad (_("at 0x%lx, displacement overflows 12-bit field"),
		(unsigned long) fragP->fr_address);
d2397 3
a2399 3
	as_bad (_("at 0x%lx, displacement to defined symbol %s overflows 12-bit field"),
		(unsigned long) fragP->fr_address,
		S_GET_NAME (fragP->fr_symbol));
d2401 6
a2406 4
	as_bad (_("at 0x%lx, displacement to undefined symbol %s overflows 12-bit field"),
		(unsigned long) fragP->fr_address,
		S_GET_NAME (fragP->fr_symbol));

d2479 2
a2480 2
	as_bad (_("at 0x%lx, displacement overflows 8-bit field"),
		(unsigned long) fragP->fr_address);
d2482 3
a2484 3
	as_bad (_("at 0x%lx, displacement to defined symbol %s overflows 8-bit field "),
		(unsigned long) fragP->fr_address,
		S_GET_NAME (fragP->fr_symbol));
d2486 6
a2491 3
	as_bad (_("at 0x%lx, displacement to undefined symbol %s overflows 8-bit field "),
		(unsigned long) fragP->fr_address,
		S_GET_NAME (fragP->fr_symbol));
@


1.27
log
@Kaz Kojima's BFD_RELOC_SH_PCDISP12BY2 fix.
@
text
@d1932 1
a1932 2
  if (debug_type == DEBUG_DWARF2)
    dwarf2_generate_asm_lineno (size);
a3325 7

void
sh_finalize ()
{
  if (debug_type == DEBUG_DWARF2)
    dwarf2_finish ();
}
@


1.26
log
@	* config/tc-sh.c (md_apply_fix): For ELF, do not "adjust back" VAL
	for weak symbols.
@
text
@d2879 1
a2879 1
      if (val < -0x800 || val >= 0x7ff)
@


1.25
log
@Add --gdwarf2 support to ARM toolchain
@
text
@d2770 11
a2780 2
     to avoid the screw up later.  */
  if (fixP->fx_addsy != NULL
@


1.24
log
@	* config/tc-sh.c (JREG): Remove.
	(md_convert_frag): Remove #if 0:d code using JREG.
@
text
@a36 1
struct dwarf2_line_info debug_line;
d1933 1
a1933 13
    {
      bfd_vma addr;

      /* First update the notion of the current source line.  */
      dwarf2_where (&debug_line);

      /* We want the offset of the start of this instruction within the
	 the current frag.  may be used later */
      addr = frag_now->fr_address + frag_now_fix () - size;

      /* And record the information.  */
      dwarf2_gen_line_info (addr, &debug_line);
    }
@


1.23
log
@2000-09-25  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-cris.c: Fix formatting.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.h: Likewise.
@
text
@a125 1
#define JREG 14			/* Register used as a temp when relaxing */
a2418 41
#if 0
      /* This code works, but generates poor code and the compiler
	 should never produce a sequence that requires it to be used.  */

      /* A jump wont fit in 12 bits, make code which looks like
	 bra foo
	 mov.w @@(0, PC), r14
	 .long disp
	 foo: bra @@r14
	 */
      int t = buffer[0] & 0x10;

      buffer[highbyte     ] = 0xa0;	/* branch over move and disp */
      buffer[lowbyte      ] = 3;
      buffer[highbyte +  2] = 0xd0 | JREG;	/* Build mov insn */
      buffer[lowbyte  +  2] = 0x00;

      buffer[highbyte +  4] = 0;	/* space for 32 bit jump disp */
      buffer[lowbyte  +  4] = 0;
      buffer[highbyte +  6] = 0;
      buffer[lowbyte  +  6] = 0;

      buffer[highbyte +  8] = 0x40 | JREG;	/* Build jmp @@JREG */
      buffer[lowbyte  +  8] = t ? 0xb : 0x2b;

      buffer[highbyte + 10] = 0x20; /* build nop */
      buffer[lowbyte  + 10] = 0x0b;

      /* Make reloc for the long disp.  */
      fix_new (fragP,
	       fragP->fr_fix + 4,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       BFD_RELOC_32);
      fragP->fr_fix += UNCOND32_LENGTH;
      fragP->fr_var = 0;
      donerelax = 1;
#endif

a2500 43

#if 0
      /* This code works, but generates poor code, and the compiler
	 should never produce a sequence that requires it to be used.  */

      /* A bcond won't fit and it won't go into a 12 bit
	 displacement either, the code sequence looks like:
	 b!cond foop
	 mov.w @@(n, PC), r14
	 jmp  @@r14
	 nop
	 .long where
	 foop:
	 */

      buffer[0] ^= 0x2;		/* Toggle T/F bit */
#define JREG 14
      buffer[1] = 5;		/* branch over mov, jump, nop and ptr */
      buffer[2] = 0xd0 | JREG;	/* Build mov insn */
      buffer[3] = 0x2;
      buffer[4] = 0x40 | JREG;	/* Build jmp @@JREG */
      buffer[5] = 0x0b;
      buffer[6] = 0x20;		/* build nop */
      buffer[7] = 0x0b;
      buffer[8] = 0;		/* space for 32 bit jump disp */
      buffer[9] = 0;
      buffer[10] = 0;
      buffer[11] = 0;
      buffer[12] = 0;
      buffer[13] = 0;
      /* Make reloc for the long disp */
      fix_new (fragP,
	       fragP->fr_fix + 8,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       BFD_RELOC_32);
      fragP->fr_fix += COND32_LENGTH;
      fragP->fr_var = 0;
      donerelax = 1;
#endif

@


1.22
log
@* config/tc-sh.h [OBJ_ELF] (TC_FIX_ADJUSTABLE): Define.
* config/tc-sh.c (md_apply_fix): Map 32-bit relocations that
become PC-relative to BFD_RELOC_32_PCREL.  Reject 16- or 8-bit
similar relocs.
(sh_obj_adjustable): Return 1 for PC-relative offsets used in
branches.


* config/tc-sh.h (DIFF_EXPR_OK, GLOBAL_OFFSET_TABLE_NAME,
TC_RELOC_GLOBAL_OFFSET_TABLE, TC_RELOC_RTSYM_LOC_FIXUP): Define.
* config/tc-sh.c (sh_elf_cons, sh_elf_suffix): New functions.
[OBJ_ELF] (md_pseudo_table) <long, int, word, short>: Use them.
(GOT_symbol): New variable.
(md_undefined_symbol): Set it.
@
text
@d218 1
a218 1
/* Parse @@got, etc. and return the desired relocation. 
d380 1
a380 1
	      if (new_exp.X_op != O_absent) 
d390 1
a390 1
  input_line_pointer--;		/* Put terminator back into stream. */
a1932 1
  
d1937 1
a1937 1
      
a1943 1
  
d2003 1
a2003 1
	  
d2007 1
a2007 1
      
d2011 1
a2011 1
  
d2858 1
a2858 1
	  
d3011 1
a3011 1
	 runtime we merely add the offset to the actual PLT entry. */
d3022 1
a3022 1
        
d3024 1
a3024 1
        
@


1.21
log
@	* config/tc-sh.h (DWARF2_LINE_MIN_INSN_LENGTH): Defined.
	* config/tc-sh.c (md_assemble): Changed so debug_type
	test performed for ppi_assemble
	* config/tc-sh.c: Included dwarf2dbg.h.
	(debug_line): Defined.
	(md_assemble): Generates dwarf2 line info.
	(sh_finalize): New function.  Finalize dwarf2 info.
	(assemble_ppi): Returns size of code generated.
	(build_Mytes): Returns size of code generated.
	(md_pseudo_table): Added "file" and "loc" psuedo ops.
	* config/tc-sh.h (md_end): Defined.
	(sh_finalize): Declared.
@
text
@d54 6
d78 6
d86 1
d216 185
d1996 18
d2763 14
d2838 29
d2977 1
d3010 37
d3397 2
@


1.20
log
@* config/tc-sh.c (md_apply_fix) [BFD_RELOC_32, BFD_RELOC_16]: Use
md_number_to_chars.
@
text
@d36 3
d52 1
a52 1
static void assemble_ppi PARAMS ((char *, sh_opcode_info *));
d83 2
d1286 1
a1286 1
static void
d1295 1
d1392 1
d1446 1
a1446 1
static void
d1457 1
d1475 1
d1480 1
a1480 1
	  return;
d1625 1
d1639 5
a1643 2
    /* Just a double data transfer.  */
    output = frag_more (2);
d1654 1
d1668 1
d1691 1
a1691 9
      assemble_ppi (op_end, opcode);
      return;
    }

  if (opcode->arg[0] == A_BDISP12
      || opcode->arg[0] == A_BDISP8)
    {
      parse_exp (op_end + 1, &operand[0]);
      build_relax (opcode, &operand[0]);
d1695 2
a1696 1
      if (opcode->arg[0] == A_END)
d1698 2
a1699 4
	  /* Ignore trailing whitespace.  If there is any, it has already
	     been compressed to a single space.  */
	  if (*op_end == ' ')
	    op_end++;
d1703 18
a1720 3
	  op_end = get_operands (opcode, op_end, operand);
	}
      opcode = get_specific (opcode, operand);
d1722 8
a1729 4
      if (opcode == 0)
	{
	  /* Couldn't find an opcode which matched the operands.  */
	  char *where = frag_more (2);
d1731 2
a1732 4
	  where[0] = 0x0;
	  where[1] = 0x0;
	  as_bad (_("invalid operands for opcode"));
	  return;
d1734 2
d1737 6
a1742 2
      if (*op_end)
	as_bad (_("excess operands: '%s'"), op_end);
d1744 7
a1750 1
      build_Mytes (opcode, operand);
a1751 1

d3119 7
@


1.19
log
@Fix formatting
@
text
@d2684 1
a2684 14
      if (!target_big_endian)
	{
	  *buf++ = val >> 0;
	  *buf++ = val >> 8;
	  *buf++ = val >> 16;
	  *buf++ = val >> 24;
	}
      else
	{
	  *buf++ = val >> 24;
	  *buf++ = val >> 16;
	  *buf++ = val >> 8;
	  *buf++ = val >> 0;
	}
d2688 1
a2688 10
      if (! target_big_endian)
	{
	  *buf++ = val >> 0;
	  *buf++ = val >> 8;
	}
      else
	{
	  *buf++ = val >> 8;
	  *buf++ = val >> 0;
	}
@


1.18
log
@fixed another comment formatting problem.
@
text
@d605 2
a606 1
static symbolS *dot()
a616 1

d619 1
a619 3

static
char *
a636 1

a653 1

d656 1
a656 2
static
char *
d726 6
a731 5
		  /* Turn a plain @@(4,pc) into @@(.+4,pc) */
		  if (op->immediate.X_op == O_constant) { 
		    op->immediate.X_add_symbol = dot();
		    op->immediate.X_op = O_symbol;
		  }
d821 1
a821 2
static
char *
d882 1
a882 2
static
sh_opcode_info *
d890 1
d900 1
a900 1
      
d909 1
a909 1
	  
d977 1
a977 1
            case A_REG_B:
d1148 1
a1148 1
	
d1158 2
a1159 1
    fail:;
a1179 1

d1259 1
a1259 1
      end_sym =  symbol_new (name, undefined_section, 0, &zero_address_frag);
d1321 1
a1321 1
            case REG_B:
d1376 10
a1385 8
  if (! target_big_endian) {
    output[1] = (nbuf[0] << 4) | (nbuf[1]);
    output[0] = (nbuf[2] << 4) | (nbuf[3]);
  }
  else {
    output[0] = (nbuf[0] << 4) | (nbuf[1]);
    output[1] = (nbuf[2] << 4) | (nbuf[3]);
  }
d1400 1
a1400 1
  
d1426 1
a1426 1
  
d1473 1
a1473 1
      
d1737 1
a1737 1
	{	
d1844 1
a1844 1
     
d1890 1
a1890 1
size_t md_longopts_size = sizeof(md_longopts);
d1927 1
a1927 1
  fprintf(stream, _("\
a1956 1
/*ARGSUSED*/
a1985 1
/*ARGSUSED*/
d2165 1
a2165 1
		(unsigned long) fragP->fr_address,		
d2169 1
a2169 1
		(unsigned long) fragP->fr_address,		
d2172 3
a2174 2
#if 0		/* This code works, but generates poor code and the compiler
		   should never produce a sequence that requires it to be used.  */
d2184 9
a2192 9
      buffer[highbyte] = 0xa0;	/* branch over move and disp */
      buffer[lowbyte] = 3;
      buffer[highbyte+2] = 0xd0 | JREG;	/* Build mov insn */
      buffer[lowbyte+2] = 0x00;

      buffer[highbyte+4] = 0;	/* space for 32 bit jump disp */
      buffer[lowbyte+4] = 0;
      buffer[highbyte+6] = 0;
      buffer[lowbyte+6] = 0;
d2194 2
a2195 2
      buffer[highbyte+8] = 0x40 | JREG;	/* Build jmp @@JREG */
      buffer[lowbyte+8] = t ? 0xb : 0x2b;
d2197 2
a2198 2
      buffer[highbyte+10] = 0x20; /* build nop */
      buffer[lowbyte+10] = 0x0b;
d2223 1
a2223 1
   
d2285 1
a2285 1
	as_bad (_("at 0x%lx, displacement overflows 8-bit field"), 
d2289 1
a2289 1
		(unsigned long) fragP->fr_address,		
d2293 1
a2293 1
		(unsigned long) fragP->fr_address,		
d2296 3
a2298 2
#if 0		/* This code works, but generates poor code, and the compiler
		   should never produce a sequence that requires it to be used.  */
d2512 1
a2512 1
  
d2637 1
a2637 1
      min = - 0xff;
d2684 1
a2684 1
      if (! target_big_endian) 
d2691 1
a2691 1
      else 
d2705 2
a2706 2
	} 
      else 
@


1.17
log
@Fix formatting.
@
text
@d1235 1
d1284 1
a1284 1
/* Now we know what sort of opcodes it is, lets build the bytes.  */
@


1.16
log
@Fix spelling typos.
Remove use of DEFUN().
@
text
@d21 1
a21 4
/*
   Written By Steve Chamberlain
   sac@@cygnus.com
 */
d65 1
a65 2
   Integer arg to pass to the function
 */
d101 1
a101 1
/* Chars that mean this number is a floating point constant */
d112 1
a112 1
/* These are the three types of relaxable instrction */
d198 2
a199 4
/*
   This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs
 */
d221 1
a221 1
  /* Insert unique names into hash table */
d234 1
a234 1
	     string */
d256 2
a257 1
/* try and parse a reg name, returns number of chars consumed */
d671 1
a671 1
      /* Must be predecrement */
d818 1
a818 1
      /* Not a reg, the only thing left is a displacement */
d885 1
a885 2
   provided
 */
d902 1
a902 1
	     opcodes with the same name */
d905 2
a906 1
      /* look at both operands needed by the opcodes and provided by
d909 1
a909 2
         first on each opcode try */

d914 1
d1234 1
a1234 1
/* insert ldrs & ldre with fancy relocations that relaxation can recognize.  */
d1284 1
d1402 2
a1403 1
  /* Drop leading whitespace */
d1428 1
d1433 1
a1433 3
    {
      as_bad (_("can't find opcode "));
    }
d1440 1
d1467 1
a1467 1
	  /* Couldn't find an opcode which matched the operands */
d1475 1
d1647 1
a1647 2
   the frags/bytes it assembles to.
 */
d1705 1
a1705 1
	  /* Couldn't find an opcode which matched the operands */
d1789 2
a1790 2
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
d1793 5
a1797 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
d1879 2
a1880 2
struct option md_longopts[] = {

d2055 2
a2056 2
      /* fscan should also be a fixup to a local symbol in the same
	 section.  */
d2176 2
a2177 2
#if 0				/* This code works, but generates poor code and the compiler
				   should never produce a sequence that requires it to be used.  */
d2203 1
a2203 1
      /* Make reloc for the long disp */
d2220 1
a2220 1
      /* A bcond won't fit, so turn it into a b!cond; bra disp; nop */
d2299 2
a2300 2
#if 0				/* This code works, but generates poor code, and the compiler
				   should never produce a sequence that requires it to be used.  */
d2523 2
a2524 1
void sh_elf_final_processing()
d2576 3
a2578 3
  /* adjust_reloc_syms won't convert a reloc against a weak symbol
     into a reloc against a section, but bfd_install_relocation will
     screw up if the symbol is defined, so we have to adjust val here
d2773 1
a2773 1
      /* used to be a branch to somewhere which was unknown */
d2796 1
a2796 1
      /* used to be a branch to somewhere which was unknown */
d2802 1
a2802 1
	     sized - maybe it will fix up */
d2809 1
a2809 1
	  /* Its got a segment, but its not ours, so it will always be long */
d2817 1
a2817 1
	  /* We know the abs value */
d2827 1
a2827 1
/* Put number into target byte order */
@


1.15
log
@Blow away DEFUN.
@
text
@d1288 1
a1288 2
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
@


1.14
log
@Fix compile time warning messages.
@
text
@d1767 2
a1768 2
DEFUN (md_undefined_symbol, (name),
       char *name)
d1777 2
a1778 2
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
d1784 2
a1785 2
DEFUN (tc_headers_hook, (headers),
       object_headers * headers)
d2358 3
a2360 3
DEFUN (md_section_align, (seg, size),
       segT seg AND
       valueT size)
@


1.13
log
@opcodes:
	* sh-opc.c (sh_table): Use A_DISP_PC / PCRELIMM_8BY2 for ldre & ldrs.
	stc GBR,@@-<REG_N> is available for arch_sh1_up.
	Group parallel processing insn with identical mnemonics together.
	Make three-operand psha / pshl come first.
gas:
	* config/tc-sh.c (get_operands): There's no third operand if the
	first operand is an immediate.
@
text
@d33 1
d58 1
a58 1
     int ignore;
d163 2
d166 2
a167 2
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
d169 1
a169 1
  { 0 },
d176 2
a177 2
  { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
d179 1
a179 1
  { 0 },
d186 2
a187 2
  { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
d189 1
a189 1
  { 0 },
d194 2
a195 2
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
d198 2
a835 1

d1860 1
a1860 1
     int ignore;
d1900 1
a1900 1
     char *arg;
d1965 1
a1965 1
     bfd *abfd;
d1995 1
a1995 1
     bfd *abfd;
d1997 1
a1997 1
     PTR ignore;
d2137 1
a2137 1
     bfd *headers;
d2867 1
a2867 1
     int len;
d3049 1
a3049 1
     asection *section;
@


1.12
log
@sh-dsp REPEAT support:
opcodes:

        * sh-opc.h (sh_nibble_type): Remove DISP_8 and DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.
        (sh_arg_type): Add A_PC.
        (sh_table): Update entries using immediates.  Add repeat.
        * sh-dis.c (print_insn_shx): Remove DISP_8 and DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.

gas:

        * config/tc-sh.c (immediate): Delete.
        (sh_operand_info): Add immediate member.
        (parse_reg): Use A_PC for pc.
        (parse_exp): Add second argument 'op'.  All callers changed.
        (parse_at): Expect pc to be coded as A_PC.
        Use immediate field in *op.
        (insert): Add fourth argument 'op'.  All callers changed.
        (build_relax): Add second argument 'op'.  All callers changed.
        (insert_loop_bounds): New function.
        (build_Mytes): Remove DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.
        (assemble_ppi): Use immediate field in *operand.
        (sh_force_relocation): Handle BFD_RELOC_SH_LOOP_{START,END}.
        (md_apply_fix): Likewise.
        (tc_gen_reloc): Likewise.  Check for a pcrel BFD_RELOC_SH_LABEL.

include/coff:

        * sh.h (R_SH_LOOP_START, R_SH_LOOP_END): Define.

include/elf:

        * sh.h (R_SH_LOOP_START, R_SH_LOOP_END): New RELOC_NUMBERs.

bfd:

        * reloc.c (_bfd_relocate_contents): Add BFD_RELOC_SH_LOOP_START and
        BFD_RELOC_SH_LOOP_END.
        * elf32-sh.c (sh_elf_howto_tab): Change special_func to
        sh_elf_ignore_reloc for all entries that sh_elf_reloc used to ignore.
        Add entries for R_SH_LOOP_START and R_SH_LOOP_END.
        (sh_elf_reloc_loop): New function.
        (sh_elf_reloc): No need to test for always-to-be-ignored relocs
        any more.
        (sh_rel): Add entries for BFD_RELOC_SH_LOOP_{START,END}.
        (sh_elf_relocate_section): Handle BFD_RELOC_SH_LOOP_{START,END}.
        * bfd-in2.h, libbfd.h: Regenerate.
@
text
@d850 7
a856 1
	  if (info->arg[2])
@


1.11
log
@	* config/tc-sh.c (md_show_usage): Use backslash before newline in
	string literal.
@
text
@a246 2
static expressionS immediate;	/* absolute expression */

d251 1
a252 1

d467 3
a469 1
      *mode = A_DISP_PC;
d622 1
a622 1
parse_exp (s)
d624 1
d631 2
a632 2
  expression (&immediate);
  if (immediate.X_op == O_absent)
d714 1
a714 1
	  src = parse_exp (src);
d729 1
a729 1
	      else if (mode == A_DISP_PC)
d732 3
a734 3
		  if (immediate.X_op == O_constant) { 
		    immediate.X_add_symbol = dot();
		    immediate.X_op = O_symbol;
d799 1
a799 1
      *ptr = parse_exp (src);
d819 1
a819 1
      *ptr = parse_exp (src);
d1181 1
a1181 1
insert (where, how, pcrel)
d1185 1
d1190 1
a1190 1
	       &immediate,
d1196 1
a1196 1
build_relax (opcode)
d1198 1
d1210 2
a1211 2
		    immediate.X_add_symbol,
		    immediate.X_add_number,
d1221 2
a1222 2
		    immediate.X_add_symbol,
		    immediate.X_add_number,
d1229 49
d1323 14
a1336 2
	    case DISP_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0);
d1338 2
a1339 2
	    case IMM_4BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0);
d1341 2
a1342 2
	    case IMM_4BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0);
d1344 2
a1345 2
	    case IMM_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0);
d1347 2
a1348 2
	    case IMM_8BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0);
d1350 2
a1351 2
	    case IMM_8BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0);
d1353 5
a1357 2
	    case IMM_8:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0);
d1360 1
a1360 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4, 1);
d1363 6
a1368 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2, 1);
d1532 1
a1532 1
	  if (immediate.X_op != O_constant)
d1535 1
a1535 1
		     | (immediate.X_add_number & 127) << 4
d1679 2
a1680 2
      parse_exp (op_end + 1);
      build_relax (opcode);
d2482 3
a2484 1
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
d2720 3
d3073 8
@


1.10
log
@	* config/tc-sh.c (md_begin): When encountering insn that are
	not supported by the current arch, only change the name if
	its contents are the same as prev_name.
	(get_specific): If the the architecture doesn't match, fail.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation.
d1854 1
a1854 1
-small			align sections to 4 byte boundaries, not 16\n
@


1.9
log
@	* config/tc-sh.c (IDENT_CHAR): Define.
	(parse_reg): Use it instead of isalnum.  Put r[0..7]_bank operand
	matching back where it came from.
@
text
@d225 1
a225 1
      if (opcode->arch & target_arch && strcmp (prev_name, opcode->name))
d227 2
d1153 2
@


1.8
log
@	* config/tc-sh.c (md_show_usage): Add description of -dsp.
@
text
@d255 2
d264 1
a264 1
  /* We use !isalnum for the next character after the register name, to
d266 1
a266 1
     'sram' as being a reference to the register 'sr'.  */
a269 7
      if (src[1] >= '0' && src[1] <= '7' && strncmp (&src[2], "_bank", 5) == 0
	  && ! isalnum ((unsigned char) src[7]))
	{
	  *mode = A_REG_B;
	  *reg  = (src[1] - '0');
	  return 7;
	}
d273 1
a273 1
	      && ! isalnum ((unsigned char) src[3]))
d281 1
a281 1
	  && ! isalnum ((unsigned char) src[2]))
d287 7
d295 1
a295 1
      if (src[1] == 'e' && ! isalnum ((unsigned char) src[2]))
d300 1
a300 1
      if (src[1] == 's' && ! isalnum ((unsigned char) src[2]))
d311 1
a311 1
	  if (! isalnum ((unsigned char) src[2]))
d317 1
a317 1
	  if (src[2] == 'g' && ! isalnum ((unsigned char) src[3]))
d326 1
a326 1
	  if (! isalnum ((unsigned char) src[2]))
d332 1
a332 1
	  if (src[2] == 'g' && ! isalnum ((unsigned char) src[3]))
d341 1
a341 1
	  && ! isalnum ((unsigned char) src[3]))
d348 1
a348 1
	  && ! isalnum ((unsigned char) src[3]))
d355 1
a355 1
	  && ! isalnum ((unsigned char) src[3]))
d365 1
a365 1
  if (src[0] == 'i' && src[1] && ! isalnum ((unsigned char) src[3]))
d388 1
a388 1
      && ! isalnum ((unsigned char) src[2]))
d396 1
a396 1
      && ! isalnum ((unsigned char) src[2]))
d404 1
a404 1
      && ! isalnum ((unsigned char) src[2]))
d413 1
a413 1
      && src[2] == 'r' && ! isalnum ((unsigned char) src[3]))
d420 1
a420 1
      && ! isalnum ((unsigned char) src[3]))
d427 1
a427 1
      && ! isalnum ((unsigned char) src[3]))
d434 1
a434 1
      && ! isalnum ((unsigned char) src[3]))
d441 1
a441 1
      && ! isalnum ((unsigned char) src[3]))
d447 1
a447 1
  if (src[0] == 's' && src[1] == 'r' && ! isalnum ((unsigned char) src[2]))
d453 1
a453 1
  if (src[0] == 's' && src[1] == 'p' && ! isalnum ((unsigned char) src[2]))
d460 1
a460 1
  if (src[0] == 'p' && src[1] == 'r' && ! isalnum ((unsigned char) src[2]))
d465 1
a465 1
  if (src[0] == 'p' && src[1] == 'c' && ! isalnum ((unsigned char) src[2]))
d471 1
a471 1
      && ! isalnum ((unsigned char) src[3]))
d477 1
a477 1
      && ! isalnum ((unsigned char) src[3]))
d484 1
a484 1
      && ! isalnum ((unsigned char) src[4]))
d498 1
a498 1
      && ! isalnum ((unsigned char) src[4]))
d508 1
a508 1
	      && ! isalnum ((unsigned char) src[4]))
d516 1
a516 1
	  && ! isalnum ((unsigned char) src[3]))
d528 1
a528 1
	      && ! isalnum ((unsigned char) src[4]))
d536 1
a536 1
	  && ! isalnum ((unsigned char) src[3]))
d548 1
a548 1
	      && ! isalnum ((unsigned char) src[4]))
d556 1
a556 1
	  && ! isalnum ((unsigned char) src[3]))
d565 1
a565 1
      if (src[2] == '1'&& src[3] == '2' && ! isalnum ((unsigned char) src[4]))
d572 1
a572 1
	  && ! isalnum ((unsigned char) src[3]))
d580 1
a580 1
      && ! isalnum ((unsigned char) src[4]))
d587 1
a587 1
      && src[4] == 'r' && ! isalnum ((unsigned char) src[5]))
d594 1
a594 1
      && src[4] == 'x' && ! isalnum ((unsigned char) src[5]))
@


1.7
log
@Match r[0..7]_bank operands before normal operands.
@
text
@d1848 2
a1849 1
-small			align sections to 4 byte boundaries, not 16\n"));
@


1.6
log
@Add support for WinCE targeted toolchains.
@
text
@d268 7
a290 7
	}
      if (src[1] >= '0' && src[1] <= '7' && strncmp(&src[2], "_bank", 5) == 0
	  && ! isalnum ((unsigned char) src[7]))
	{
	  *mode = A_REG_B;
	  *reg  = (src[1] - '0');
	  return 7;
@


1.5
log
@bfd:
Reinstate bits of sh4 support that got accidentally deleted.
Add sh-dsp support.

bfd:

	* archures.c (bfd_mach_sh2, bfd_mach_sh_dsp): New macros.
	(bfd_mach_sh3_dsp): Likewise.
	(bfd_mach_sh4): Reinstate.
	(bfd_default_scan): Recognize 7410, 7708, 7729 and 7750.
	* bfd-in2.h: Regenerate.
	* coff-sh.c (struct sh_opcode): flags is no longer short.
	(USESAS, USESAS_REG, USESR8, SETSAS, SETSAS_REG): New macros.
	(sh_opcode41, sh_opcode42): Integrate as sh_opcode41.
	(sh_opcode01, sh_opcode02, sh_opcode40): Add sh-dsp opcodes.
	(sh_opcode41, sh_opcode4, sh_opcode80): Likewise.
	(sh_opcodes): No longer const.
	(sh_dsp_opcodef0, sh_dsp_opcodef): New arrays.
	(sh_insn_uses_reg): Check for USESAS and USESR8.
	(sh_insn_sets_reg, sh_insns_conflict): Check for SETSAS.
	(_bfd_sh_align_load_span): Return early for SH4.
	Modify sh_opcodes lookup table for sh-dsp / sh3-dsp.
	Take into account that field b of a parallel processing insn
	could be mistaken for a separate insn.
	* cpu-sh.c (arch_info_struct): New array elements for
	sh2, sh-dsp and sh3-dsp.
	Reinstate element for sh4.
	(SH2_NEXT, SH_DSP_NEXT, SH3_DSP_NEXT): New macros.
	(SH4_NEXT): Reinstate.
	(SH3_NEXT, SH3E_NEXT): Adjust.
	* elf-bfd.h (_sh_elf_set_mach_from_flags): Declare.
	* elf32-sh.c (sh_elf_set_private_flags): New function.
	(sh_elf_copy_private_data, sh_elf_set_mach_from_flags): Likewise.
	(sh_elf_merge_private_data): New function.
	(elf_backend_object_p, bfd_elf32_bfd_set_private_bfd_flags): Define.
	(bfd_elf32_bfd_copy_private_bfd_data): Define.
	(bfd_elf32_bfd_merge_private_bfd_data): Change to
	sh_elf_merge_private_data.

gas:

	* config/tc-sh.c ("elf/sh.h"): Include.
	(sh_dsp, valid_arch, reg_x, reg_y, reg_efg): New static variables.
	(md.begin): Initialize target_arch.
	Only include opcodes in has table that match selected architecture.
	(parse_reg): Recognize register names for sh-dsp.
	(parse_at): Recognize post-modify addressing.
	(get_operands): The leading space is now optional.
	(get_specific): Remove FDREG_N support.  Add support for sh-dsp
	arguments.  Update valid_arch.
	(build_Mytes): Add support for SDT_REG_N.
	(find_cooked_opcode): New function, broken out of md_assemble.
	(assemble_ppi, sh_elf_final_processing): New functions.
	(md_assemble): Use find_cooked_opcode and assemble_ppi.
	(md_longopts, md_parse_option): New option: -dsp.
	* config/tc-sh.h (elf_tc_final_processing): Define.
	(sh_elf_final_processing): Declare.

include/elf:

	* sh.h: (EF_SH_MACH_MASK, EF_SH_UNKNOWN, EF_SH1, EF_SH2): New macros.
	(EF_SH3, EF_SH_HAS_DSP, EF_SH_DSP, EF_SH3_DSP): Likewise.
	(EF_SH_HAS_FP, EF_SH3E, EF_SH4, EF_SH_MERGE_MACH): Likewise.

opcodes:

	* sh-dis.c (print_movxy, print_insn_ddt, print_dsp_reg): New functions.
	(print_insn_ppi): Likewise.
	(print_insn_shx): Use info->mach to select appropriate insn set.
	Add support for sh-dsp.  Remove FD_REG_N support.
	* sh-opc.h (sh_nibble_type): Add new values for sh-dsp support.
	(sh_arg_type): Likewise.  Remove FD_REG_N.
	(sh_dsp_reg_nums): New enum.
	(arch_sh1, arch_sh2, arch_sh3, arch_sh3e, arch_sh4): New macros.
	(arch_sh_dsp, arch_sh3_dsp, arch_sh1_up, arch_sh2_up): Likewise.
	(arch_sh3_up, arch_sh3e_up, arch_sh4_up, arch_sh_dsp_up): Likewise.
	(arch_sh3_dsp_up): Likewise.
	(sh_opcode_info): New field: arch.
	(sh_table): Split up insn with FD_REG_N into ones with F_REG_N and
	D_REG_N.  Fill in arch field.  Add sh-dsp insns.
@
text
@d209 4
d215 1
d1686 1
d1702 1
@


1.4
log
@	* config/tc-sh.c (md_assemble):  Call as_bad when there are excess
	operands.
@
text
@d33 5
a46 7
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
 */

d50 2
d63 7
d94 8
d207 1
d212 3
d220 1
a220 1
      if (strcmp (prev_name, opcode->name))
d236 2
d263 17
d287 11
d300 1
a300 1
  if (src[0] == 'r')
d302 15
d319 7
a325 2
	  if (src[2] >= '0' && src[2] <= '5'
	      && ! isalnum ((unsigned char) src[3]))
d327 2
a328 2
	      *mode = A_REG_N;
	      *reg = 10 + src[2] - '0';
d332 41
a372 2
      if (src[1] >= '0' && src[1] <= '9'
	  && ! isalnum ((unsigned char) src[2]))
d375 1
a375 1
	  *reg = (src[1] - '0');
d380 24
d426 7
d490 6
a752 1
	  op->type = A_INC_N;
d754 14
d826 5
a830 1
      ptr++;
d939 3
a946 5
	    case FD_REG_N:
	      if (user->type != F_REG_N && user->type != D_REG_N)
		goto fail;
	      reg_n = user->reg;
	      break;
d955 4
d979 1
d986 131
d1144 1
d1249 5
d1302 2
a1303 4
/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.
 */
d1305 3
a1307 3
void
md_assemble (str)
     char *str;
d1309 1
a1311 2
  sh_operand_info operand[3];
  sh_opcode_info *opcode;
d1318 4
a1321 1
  /* find the op code end */
d1325 1
a1325 1
       && !is_end_of_line[*op_end] && *op_end != ' ';
d1331 4
a1334 3
	 because it thinks the '/' is the end of the symbol.  Instead of
	 hacking up the machine independent code, we just deal with it
	 here.  */
d1340 1
d1347 223
a1569 1
  opcode = (sh_opcode_info *) hash_find (opcode_hash_control, name);
d1587 6
d1792 1
d1797 1
d1822 4
d2426 27
@


1.3
log
@	* subsegs.c (subseg_text_p): New function.
	* as.h (subseg_text_p): Declare.
	* read.c (do_align): Use subseg_text_p to set the default fill.
	* write.c (subsegs_finish): Likewise.
	* config/obj-coff.c (write_object_file): Likewise.
	* config/tc-i386.h (md_maybe_text): Don't define.
	(md_do_align): Use subseg_text_p to set the default fill.
	* config/tc-m32r.c (m32r_do_align): Likewise.
	* config/tc-sh.c (sh_do_align): Likewise.
	* config/tc-sparc.h (md_do_align): Likewise.
@
text
@d1069 1
a1069 1
      if (opcode->arg[0] != A_END)
d1071 8
a1078 1
	  get_operands (opcode, op_end, operand);
d1092 3
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d2195 1
a2195 6
#ifdef BFD_ASSEMBLER
      && (now_seg->flags & SEC_CODE) != 0
#else
      && now_seg != data_section
      && now_seg != bss_section
#endif
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 1998 Free Software Foundation.
d1453 2
a1454 1
      fix_new (sym->sy_frag, S_GET_VALUE (sym) - sym->sy_frag->fr_address,
d2060 3
d2064 1
d2385 2
a2386 1
  rel->sym_ptr_ptr = &fixp->fx_addsy->bsym;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

