head	1.103;
access;
symbols
	binutils-2_24-branch:1.103.0.4
	binutils-2_24-branchpoint:1.103
	binutils-2_21_1:1.89
	binutils-2_23_2:1.103
	binutils-2_23_1:1.103
	binutils-2_23:1.103
	binutils-2_23-branch:1.103.0.2
	binutils-2_23-branchpoint:1.103
	binutils-2_22_branch:1.99.0.4
	binutils-2_22:1.99
	binutils-2_22-branch:1.99.0.2
	binutils-2_22-branchpoint:1.99
	binutils-2_21:1.89
	binutils-2_21-branch:1.89.0.2
	binutils-2_21-branchpoint:1.89
	binutils-2_20_1:1.83
	binutils-2_20:1.83
	binutils-arc-20081103-branch:1.77.0.6
	binutils-arc-20081103-branchpoint:1.77
	binutils-2_20-branch:1.83.0.2
	binutils-2_20-branchpoint:1.83
	dje-cgen-play1-branch:1.82.0.2
	dje-cgen-play1-branchpoint:1.82
	arc-20081103-branch:1.77.0.4
	arc-20081103-branchpoint:1.77
	binutils-2_19_1:1.77
	binutils-2_19:1.77
	binutils-2_19-branch:1.77.0.2
	binutils-2_19-branchpoint:1.77
	binutils-2_18:1.73
	binutils-2_18-branch:1.73.0.2
	binutils-2_18-branchpoint:1.73
	binutils-csl-coldfire-4_1-32:1.71
	binutils-csl-sourcerygxx-4_1-32:1.71
	binutils-csl-innovasic-fido-3_4_4-33:1.71
	binutils-csl-sourcerygxx-3_4_4-32:1.64
	binutils-csl-coldfire-4_1-30:1.71
	binutils-csl-sourcerygxx-4_1-30:1.71
	binutils-csl-coldfire-4_1-28:1.71
	binutils-csl-sourcerygxx-4_1-29:1.71
	binutils-csl-sourcerygxx-4_1-28:1.71
	binutils-csl-arm-2006q3-27:1.71
	binutils-csl-sourcerygxx-4_1-27:1.71
	binutils-csl-arm-2006q3-26:1.71
	binutils-csl-sourcerygxx-4_1-26:1.71
	binutils-csl-sourcerygxx-4_1-25:1.71
	binutils-csl-sourcerygxx-4_1-24:1.71
	binutils-csl-sourcerygxx-4_1-23:1.71
	binutils-csl-sourcerygxx-4_1-21:1.71
	binutils-csl-arm-2006q3-21:1.71
	binutils-csl-sourcerygxx-4_1-22:1.71
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.71
	binutils-csl-sourcerygxx-4_1-20:1.71
	binutils-csl-arm-2006q3-19:1.71
	binutils-csl-sourcerygxx-4_1-19:1.71
	binutils-csl-sourcerygxx-4_1-18:1.71
	binutils-csl-renesas-4_1-9:1.71
	binutils-csl-sourcerygxx-3_4_4-25:1.64
	binutils-csl-renesas-4_1-8:1.71
	binutils-csl-renesas-4_1-7:1.71
	binutils-csl-renesas-4_1-6:1.71
	binutils-csl-sourcerygxx-4_1-17:1.71
	binutils-csl-sourcerygxx-4_1-14:1.71
	binutils-csl-sourcerygxx-4_1-15:1.71
	binutils-csl-sourcerygxx-4_1-13:1.71
	binutils-2_17:1.71
	binutils-csl-sourcerygxx-4_1-12:1.71
	binutils-csl-sourcerygxx-3_4_4-21:1.71
	binutils-csl-wrs-linux-3_4_4-24:1.64
	binutils-csl-wrs-linux-3_4_4-23:1.64
	binutils-csl-sourcerygxx-4_1-9:1.71
	binutils-csl-sourcerygxx-4_1-8:1.71
	binutils-csl-sourcerygxx-4_1-7:1.71
	binutils-csl-arm-2006q1-6:1.71
	binutils-csl-sourcerygxx-4_1-6:1.71
	binutils-csl-wrs-linux-3_4_4-22:1.64
	binutils-csl-coldfire-4_1-11:1.71
	binutils-csl-sourcerygxx-3_4_4-19:1.71
	binutils-csl-coldfire-4_1-10:1.71
	binutils-csl-sourcerygxx-4_1-5:1.71
	binutils-csl-sourcerygxx-4_1-4:1.71
	binutils-csl-wrs-linux-3_4_4-21:1.64
	binutils-csl-morpho-4_1-4:1.71
	binutils-csl-sourcerygxx-3_4_4-17:1.71
	binutils-csl-wrs-linux-3_4_4-20:1.64
	binutils-2_17-branch:1.71.0.4
	binutils-2_17-branchpoint:1.71
	binutils-csl-2_17-branch:1.71.0.2
	binutils-csl-2_17-branchpoint:1.71
	binutils-csl-gxxpro-3_4-branch:1.64.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.64
	binutils-2_16_1:1.64
	binutils-csl-arm-2005q1b:1.64
	binutils-2_16:1.64
	binutils-csl-arm-2005q1a:1.64
	binutils-csl-arm-2005q1-branch:1.64.0.4
	binutils-csl-arm-2005q1-branchpoint:1.64
	binutils-2_16-branch:1.64.0.2
	binutils-2_16-branchpoint:1.64
	csl-arm-2004-q3d:1.62
	csl-arm-2004-q3:1.62
	binutils-2_15:1.61
	binutils-2_15-branchpoint:1.61
	csl-arm-2004-q1a:1.61
	csl-arm-2004-q1:1.61
	binutils-2_15-branch:1.61.0.6
	cagney_bfdfile-20040213-branch:1.61.0.4
	cagney_bfdfile-20040213-branchpoint:1.61
	cagney_bigcore-20040122-branch:1.61.0.2
	cagney_bigcore-20040122-branchpoint:1.61
	csl-arm-2003-q4:1.61
	binutils-2_14:1.54
	binutils-2_14-branch:1.54.0.2
	binutils-2_14-branchpoint:1.54
	binutils-2_13_2_1:1.44.2.4
	binutils-2_13_2:1.44.2.4
	binutils-2_13_1:1.44.2.3
	binutils-2_13:1.44
	binutils-2_13-branchpoint:1.44
	binutils-2_13-branch:1.44.0.2
	binutils-2_12_1:1.37.2.1
	binutils-2_12:1.37.2.1
	binutils-2_12-branch:1.37.0.2
	binutils-2_12-branchpoint:1.37
	cygnus_cvs_20020108_pre:1.35
	binutils-2_11_2:1.22.2.1
	binutils-2_11_1:1.22.2.1
	binutils-2_11:1.22
	x86_64versiong3:1.22
	binutils-2_11-branch:1.22.0.2
	binutils-2_10_1:1.9.2.1
	binutils-2_10:1.9
	binutils-2_10-branch:1.9.0.2
	binutils-2_10-branchpoint:1.9
	binutils_latest_snapshot:1.103
	repo-unification-2000-02-06:1.8
	binu_ss_19990721:1.5
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.103
date	2012.05.16.16.38.20;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2011.11.23.11.32.42;	author gingold;	state Exp;
branches;
next	1.101;

1.101
date	2011.11.23.11.27.51;	author gingold;	state Exp;
branches;
next	1.100;

1.100
date	2011.10.21.13.24.26;	author gingold;	state Exp;
branches;
next	1.99;

1.99
date	2011.09.19.08.24.23;	author gingold;	state Exp;
branches;
next	1.98;

1.98
date	2011.08.26.13.37.28;	author gingold;	state Exp;
branches;
next	1.97;

1.97
date	2011.08.26.13.16.36;	author gingold;	state Exp;
branches;
next	1.96;

1.96
date	2011.08.07.16.32.20;	author rth;	state Exp;
branches;
next	1.95;

1.95
date	2011.06.28.13.33.33;	author gingold;	state Exp;
branches;
next	1.94;

1.94
date	2011.06.28.09.23.53;	author gingold;	state Exp;
branches;
next	1.93;

1.93
date	2011.06.28.07.40.16;	author gingold;	state Exp;
branches;
next	1.92;

1.92
date	2011.06.27.14.08.15;	author gingold;	state Exp;
branches;
next	1.91;

1.91
date	2011.06.24.15.16.03;	author gingold;	state Exp;
branches;
next	1.90;

1.90
date	2011.03.29.18.16.15;	author rth;	state Exp;
branches;
next	1.89;

1.89
date	2010.09.20.16.09.03;	author rth;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.16.23.55.10;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.28.14.06.56;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.31.15.53.13;	author gingold;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.14.09.25.34;	author gingold;	state Exp;
branches;
next	1.84;

1.84
date	2009.09.25.19.13.26;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2009.05.04.13.31.43;	author gingold;	state Exp;
branches;
next	1.80;

1.80
date	2009.03.04.16.15.43;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2009.03.03.10.04.58;	author gingold;	state Exp;
branches;
next	1.78;

1.78
date	2009.01.15.12.42.52;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2007.11.26.01.43.43;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2007.10.17.16.45.54;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2007.03.21.16.08.14;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.16.01.49.48;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.20.18.24.45;	author rth;	state Exp;
branches;
next	1.69;

1.69
date	2005.06.07.17.54.15;	author zack;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.31.22.53.10;	author rth;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.05.09.12.53;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.20.17.40.00;	author hjl;	state Exp;
branches;
next	1.65;

1.65
date	2005.03.24.20.40.25;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2005.03.03.11.47.48;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.31.23.18.25;	author bje;	state Exp;
branches;
next	1.62;

1.62
date	2004.05.06.11.01.48;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches;
next	1.60;

1.60
date	2003.12.04.00.54.16;	author hjl;	state Exp;
branches;
next	1.59;

1.59
date	2003.11.21.00.24.40;	author kazu;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.05.03.27.03;	author rth;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.30.03.01.11;	author rth;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.03.16.04.11;	author hjl;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.03.06.10.59;	author hjl;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.12.30.19.25.07;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2002.11.28.14.15.52;	author jakub;	state Exp;
branches;
next	1.51;

1.51
date	2002.11.21.18.56.06;	author rth;	state Exp;
branches;
next	1.50;

1.50
date	2002.11.19.07.32.28;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2002.11.07.00.42.18;	author rth;	state Exp;
branches;
next	1.48;

1.48
date	2002.09.19.16.13.37;	author rth;	state Exp;
branches;
next	1.47;

1.47
date	2002.09.05.00.01.16;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2002.08.14.13.27.06;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2002.08.06.22.06.08;	author rth;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.02.08.36.10;	author rth;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2002.06.02.02.28.45;	author rth;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.30.22.01.32;	author rth;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.23.13.12.48;	author jakub;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.23.10.12.04;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.09.13.12.57;	author kazu;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.27.23.48.06;	author jakub;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.09.22.55.05;	author rth;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2002.02.08.10.03.01;	author rth;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.18.00.24.47;	author rth;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.28.19.15.11;	author jakub;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.23.12.17.20;	author jakub;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.16.07.17.12;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.15.21.28.54;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.19.05.33.21;	author hjl;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.11.18.26.04;	author rth;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.08.01.12.00;	author rth;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.05.02.39.43;	author rth;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.21.00.22.23;	author rth;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.24.16.43.31;	author jakub;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.22.20.24.11;	author kazu;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.01.20.04.23.33;	author kazu;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.19.12.03.34;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.03.10.03.46;	author pb;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.28.10.07.55;	author rth;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.03.06.49.21;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.17.18.07.33;	author rth;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.17.08.47.51;	author rth;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.14.20.46.25;	author jakub;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.15.01.06.52;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.08.18.34.06;	author obrien;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.28.03.25.35;	author ian;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.11.29.00.46.16;	author meissner;	state Exp;
branches;
next	1.7;

1.7
date	99.11.08.00.44.52;	author rth;	state Exp;
branches;
next	1.6;

1.6
date	99.10.18.22.29.14;	author meissner;	state Exp;
branches;
next	1.5;

1.5
date	99.06.22.14.52.50;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.07.10.23.47;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	99.06.05.23.15.31;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.19;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.44.2.1
date	2002.09.23.22.14.22;	author drow;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2002.10.31.09.32.05;	author obrien;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2002.11.07.00.44.23;	author rth;	state Exp;
branches;
next	1.44.2.4;

1.44.2.4
date	2002.11.19.07.34.41;	author amodra;	state Exp;
branches;
next	;

1.37.2.1
date	2002.02.27.23.49.37;	author jakub;	state Exp;
branches;
next	;

1.22.2.1
date	2001.06.07.03.15.27;	author amodra;	state Exp;
branches;
next	;

1.9.2.1
date	2000.08.30.23.39.17;	author obrien;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.103
log
@	* bfd-in.h (bfd_get_section_name, bfd_get_section_vma,
	bfd_get_section_lma, bfd_get_section_alignment,
	bfd_get_section_flags, bfd_get_section_userdata): Rewrite macros
	in order to use the `bfd' argument.
	* bfd-in2.h: Regenerate.
	* elf-vxworks.c (elf_vxworks_finish_dynamic_entry): Pass proper `bfd'
	as the first argument for `bfd_get_section_alignment'.
	* elf32-arm.c (create_ifunc_sections): Likewise, for
	`bfd_set_section_alignment'.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise, for
	`bfd_get_section_name'.
	* elf32-microblaze.c (microblaze_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_final_link_relocate): Likewise, for
	`bfd_get_section_vma'.
	* elf64-ppc.c (create_linkage_sections): Likewise, for
	`bfd_set_section_alignment'.

	* emultempl/m68hc1xelf.em (hook_in_stub): Pass proper `bfd'
	as the first argument for `bfd_get_section_name'.

	* config/tc-alpha.c (maybe_set_gp): Pass proper `bfd'
	as the first argument for `bfd_get_section_vma'.
@
text
@/* tc-alpha.c - Processor-specific code for the DEC Alpha AXP CPU.
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
   Contributed by Carnegie Mellon University, 1993.
   Written by Alessandro Forin, based on earlier gas-1.38 target CPU files.
   Modified by Ken Raeburn for gas-2.x and ECOFF support.
   Modified by Richard Henderson for ELF support.
   Modified by Klaus K"ampf for EVAX (OpenVMS/Alpha) support.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Mach Operating System
   Copyright (c) 1993 Carnegie Mellon University
   All Rights Reserved.

   Permission to use, copy, modify and distribute this software and its
   documentation is hereby granted, provided that both the copyright
   notice and this permission notice appear in all copies of the
   software, derivative works or modified versions, and any portions
   thereof, and that both notices appear in supporting documentation.

   CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS
   CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
   ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.

   Carnegie Mellon requests users of this software to return to

    Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
    School of Computer Science
    Carnegie Mellon University
    Pittsburgh PA 15213-3890

   any improvements or extensions that they make and grant Carnegie the
   rights to redistribute these changes.  */

#include "as.h"
#include "subsegs.h"
#include "struc-symbol.h"
#include "ecoff.h"

#include "opcode/alpha.h"

#ifdef OBJ_ELF
#include "elf/alpha.h"
#endif

#ifdef OBJ_EVAX
#include "vms.h"
#include "vms/egps.h"
#endif

#include "dwarf2dbg.h"
#include "dw2gencfi.h"
#include "safe-ctype.h"

/* Local types.  */

#define TOKENIZE_ERROR 		-1
#define TOKENIZE_ERROR_REPORT	-2
#define MAX_INSN_FIXUPS		 2
#define MAX_INSN_ARGS		 5

/* Used since new relocation types are introduced in this
   file (DUMMY_RELOC_LITUSE_*) */
typedef int extended_bfd_reloc_code_real_type;

struct alpha_fixup
{
  expressionS exp;
  /* bfd_reloc_code_real_type reloc; */
  extended_bfd_reloc_code_real_type reloc;
#ifdef OBJ_EVAX
  /* The symbol of the item in the linkage section.  */
  symbolS *xtrasym;

  /* The symbol of the procedure descriptor.  */
  symbolS *procsym;
#endif
};

struct alpha_insn
{
  unsigned insn;
  int nfixups;
  struct alpha_fixup fixups[MAX_INSN_FIXUPS];
  long sequence;
};

enum alpha_macro_arg
  {
    MACRO_EOA = 1,
    MACRO_IR,
    MACRO_PIR,
    MACRO_OPIR,
    MACRO_CPIR,
    MACRO_FPR,
    MACRO_EXP
  };

struct alpha_macro
{
  const char *name;
  void (*emit) (const expressionS *, int, const void *);
  const void * arg;
  enum alpha_macro_arg argsets[16];
};

/* Extra expression types.  */

#define O_pregister	O_md1	/* O_register, in parentheses.  */
#define O_cpregister	O_md2	/* + a leading comma.  */

/* The alpha_reloc_op table below depends on the ordering of these.  */
#define O_literal	O_md3		/* !literal relocation.  */
#define O_lituse_addr	O_md4		/* !lituse_addr relocation.  */
#define O_lituse_base	O_md5		/* !lituse_base relocation.  */
#define O_lituse_bytoff	O_md6		/* !lituse_bytoff relocation.  */
#define O_lituse_jsr	O_md7		/* !lituse_jsr relocation.  */
#define O_lituse_tlsgd	O_md8		/* !lituse_tlsgd relocation.  */
#define O_lituse_tlsldm	O_md9		/* !lituse_tlsldm relocation.  */
#define O_lituse_jsrdirect O_md10	/* !lituse_jsrdirect relocation.  */
#define O_gpdisp	O_md11		/* !gpdisp relocation.  */
#define O_gprelhigh	O_md12		/* !gprelhigh relocation.  */
#define O_gprellow	O_md13		/* !gprellow relocation.  */
#define O_gprel		O_md14		/* !gprel relocation.  */
#define O_samegp	O_md15		/* !samegp relocation.  */
#define O_tlsgd		O_md16		/* !tlsgd relocation.  */
#define O_tlsldm	O_md17		/* !tlsldm relocation.  */
#define O_gotdtprel	O_md18		/* !gotdtprel relocation.  */
#define O_dtprelhi	O_md19		/* !dtprelhi relocation.  */
#define O_dtprello	O_md20		/* !dtprello relocation.  */
#define O_dtprel	O_md21		/* !dtprel relocation.  */
#define O_gottprel	O_md22		/* !gottprel relocation.  */
#define O_tprelhi	O_md23		/* !tprelhi relocation.  */
#define O_tprello	O_md24		/* !tprello relocation.  */
#define O_tprel		O_md25		/* !tprel relocation.  */

#define DUMMY_RELOC_LITUSE_ADDR		(BFD_RELOC_UNUSED + 1)
#define DUMMY_RELOC_LITUSE_BASE		(BFD_RELOC_UNUSED + 2)
#define DUMMY_RELOC_LITUSE_BYTOFF	(BFD_RELOC_UNUSED + 3)
#define DUMMY_RELOC_LITUSE_JSR		(BFD_RELOC_UNUSED + 4)
#define DUMMY_RELOC_LITUSE_TLSGD	(BFD_RELOC_UNUSED + 5)
#define DUMMY_RELOC_LITUSE_TLSLDM	(BFD_RELOC_UNUSED + 6)
#define DUMMY_RELOC_LITUSE_JSRDIRECT	(BFD_RELOC_UNUSED + 7)

#define USER_RELOC_P(R) ((R) >= O_literal && (R) <= O_tprel)

/* Macros for extracting the type and number of encoded register tokens.  */

#define is_ir_num(x)		(((x) & 32) == 0)
#define is_fpr_num(x)		(((x) & 32) != 0)
#define regno(x)		((x) & 31)

/* Something odd inherited from the old assembler.  */

#define note_gpreg(R)		(alpha_gprmask |= (1 << (R)))
#define note_fpreg(R)		(alpha_fprmask |= (1 << (R)))

/* Predicates for 16- and 32-bit ranges */
/* XXX: The non-shift version appears to trigger a compiler bug when
   cross-assembling from x86 w/ gcc 2.7.2.  */

#if 1
#define range_signed_16(x) \
	(((offsetT) (x) >> 15) == 0 || ((offsetT) (x) >> 15) == -1)
#define range_signed_32(x) \
	(((offsetT) (x) >> 31) == 0 || ((offsetT) (x) >> 31) == -1)
#else
#define range_signed_16(x)	((offsetT) (x) >= -(offsetT) 0x8000 &&	\
				 (offsetT) (x) <=  (offsetT) 0x7FFF)
#define range_signed_32(x)	((offsetT) (x) >= -(offsetT) 0x80000000 && \
				 (offsetT) (x) <=  (offsetT) 0x7FFFFFFF)
#endif

/* Macros for sign extending from 16- and 32-bits.  */
/* XXX: The cast macros will work on all the systems that I care about,
   but really a predicate should be found to use the non-cast forms.  */

#if 1
#define sign_extend_16(x)	((short) (x))
#define sign_extend_32(x)	((int) (x))
#else
#define sign_extend_16(x)	((offsetT) (((x) & 0xFFFF) ^ 0x8000) - 0x8000)
#define sign_extend_32(x)	((offsetT) (((x) & 0xFFFFFFFF) \
					   ^ 0x80000000) - 0x80000000)
#endif

/* Macros to build tokens.  */

#define set_tok_reg(t, r)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_register,			\
				 (t).X_add_number = (r))
#define set_tok_preg(t, r)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_pregister,		\
				 (t).X_add_number = (r))
#define set_tok_cpreg(t, r)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_cpregister,		\
				 (t).X_add_number = (r))
#define set_tok_freg(t, r)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_register,			\
				 (t).X_add_number = (r) + 32)
#define set_tok_sym(t, s, a)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_symbol,			\
				 (t).X_add_symbol = (s),		\
				 (t).X_add_number = (a))
#define set_tok_const(t, n)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_constant,			\
				 (t).X_add_number = (n))

/* Generic assembler global variables which must be defined by all
   targets.  */

/* Characters which always start a comment.  */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
/* XXX: Do all of these really get used on the alpha??  */
char FLT_CHARS[] = "rRsSfFdDxXpP";

#ifdef OBJ_EVAX
const char *md_shortopts = "Fm:g+1h:HG:";
#else
const char *md_shortopts = "Fm:gG:";
#endif

struct option md_longopts[] =
  {
#define OPTION_32ADDR (OPTION_MD_BASE)
    { "32addr", no_argument, NULL, OPTION_32ADDR },
#define OPTION_RELAX (OPTION_32ADDR + 1)
    { "relax", no_argument, NULL, OPTION_RELAX },
#ifdef OBJ_ELF
#define OPTION_MDEBUG (OPTION_RELAX + 1)
#define OPTION_NO_MDEBUG (OPTION_MDEBUG + 1)
    { "mdebug", no_argument, NULL, OPTION_MDEBUG },
    { "no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG },
#endif
#ifdef OBJ_EVAX
#define OPTION_REPLACE (OPTION_RELAX + 1)
#define OPTION_NOREPLACE (OPTION_REPLACE+1)
    { "replace", no_argument, NULL, OPTION_REPLACE },
    { "noreplace", no_argument, NULL, OPTION_NOREPLACE },    
#endif
    { NULL, no_argument, NULL, 0 }
  };

size_t md_longopts_size = sizeof (md_longopts);

#ifdef OBJ_EVAX
#define AXP_REG_R0     0
#define AXP_REG_R16    16
#define AXP_REG_R17    17
#undef AXP_REG_T9
#define AXP_REG_T9     22
#undef AXP_REG_T10
#define AXP_REG_T10    23
#undef AXP_REG_T11
#define AXP_REG_T11    24
#undef AXP_REG_T12
#define AXP_REG_T12    25
#define AXP_REG_AI     25
#undef AXP_REG_FP
#define AXP_REG_FP     29

#undef AXP_REG_GP
#define AXP_REG_GP AXP_REG_PV

#endif /* OBJ_EVAX  */

/* The cpu for which we are generating code.  */
static unsigned alpha_target = AXP_OPCODE_BASE;
static const char *alpha_target_name = "<all>";

/* The hash table of instruction opcodes.  */
static struct hash_control *alpha_opcode_hash;

/* The hash table of macro opcodes.  */
static struct hash_control *alpha_macro_hash;

#ifdef OBJ_ECOFF
/* The $gp relocation symbol.  */
static symbolS *alpha_gp_symbol;

/* XXX: what is this, and why is it exported? */
valueT alpha_gp_value;
#endif

/* The current $gp register.  */
static int alpha_gp_register = AXP_REG_GP;

/* A table of the register symbols.  */
static symbolS *alpha_register_table[64];

/* Constant sections, or sections of constants.  */
#ifdef OBJ_ECOFF
static segT alpha_lita_section;
#endif
#ifdef OBJ_EVAX
segT alpha_link_section;
#endif
#ifndef OBJ_EVAX
static segT alpha_lit8_section;
#endif

/* Symbols referring to said sections.  */
#ifdef OBJ_ECOFF
static symbolS *alpha_lita_symbol;
#endif
#ifdef OBJ_EVAX
static symbolS *alpha_link_symbol;
#endif
#ifndef OBJ_EVAX
static symbolS *alpha_lit8_symbol;
#endif

/* Literal for .litX+0x8000 within .lita.  */
#ifdef OBJ_ECOFF
static offsetT alpha_lit8_literal;
#endif

/* Is the assembler not allowed to use $at?  */
static int alpha_noat_on = 0;

/* Are macros enabled?  */
static int alpha_macros_on = 1;

/* Are floats disabled?  */
static int alpha_nofloats_on = 0;

/* Are addresses 32 bit?  */
static int alpha_addr32_on = 0;

/* Symbol labelling the current insn.  When the Alpha gas sees
     foo:
       .quad 0
   and the section happens to not be on an eight byte boundary, it
   will align both the symbol and the .quad to an eight byte boundary.  */
static symbolS *alpha_insn_label;
#if defined(OBJ_ELF) || defined (OBJ_EVAX)
static symbolS *alpha_prologue_label;
#endif

#ifdef OBJ_EVAX
/* Symbol associate with the current jsr instruction.  */
static symbolS *alpha_linkage_symbol;
#endif

/* Whether we should automatically align data generation pseudo-ops.
   .align 0 will turn this off.  */
static int alpha_auto_align_on = 1;

/* The known current alignment of the current section.  */
static int alpha_current_align;

/* These are exported to ECOFF code.  */
unsigned long alpha_gprmask, alpha_fprmask;

/* Whether the debugging option was seen.  */
static int alpha_debug;

#ifdef OBJ_ELF
/* Whether we are emitting an mdebug section.  */
int alpha_flag_mdebug = -1;
#endif

#ifdef OBJ_EVAX
/* Whether to perform the VMS procedure call optimization.  */
int alpha_flag_replace = 1;
#endif

/* Don't fully resolve relocations, allowing code movement in the linker.  */
static int alpha_flag_relax;

/* What value to give to bfd_set_gp_size.  */
static int g_switch_value = 8;

#ifdef OBJ_EVAX
/* Collect information about current procedure here.  */
struct alpha_evax_procs
{
  symbolS *symbol;	/* Proc pdesc symbol.  */
  int pdsckind;
  int framereg;		/* Register for frame pointer.  */
  int framesize;	/* Size of frame.  */
  int rsa_offset;
  int ra_save;
  int fp_save;
  long imask;
  long fmask;
  int type;
  int prologue;
  symbolS *handler;
  int handler_data;
};

/* Linked list of .linkage fixups.  */
struct alpha_linkage_fixups *alpha_linkage_fixup_root;
static struct alpha_linkage_fixups *alpha_linkage_fixup_tail;

/* Current procedure descriptor.  */
static struct alpha_evax_procs *alpha_evax_proc;
static struct alpha_evax_procs alpha_evax_proc_data;

static int alpha_flag_hash_long_names = 0;		/* -+ */
static int alpha_flag_show_after_trunc = 0;		/* -H */

/* If the -+ switch is given, then a hash is appended to any name that is
   longer than 64 characters, else longer symbol names are truncated.  */

#endif

#ifdef RELOC_OP_P
/* A table to map the spelling of a relocation operand into an appropriate
   bfd_reloc_code_real_type type.  The table is assumed to be ordered such
   that op-O_literal indexes into it.  */

#define ALPHA_RELOC_TABLE(op)						\
(&alpha_reloc_op[ ((!USER_RELOC_P (op))					\
		  ? (abort (), 0)					\
		  : (int) (op) - (int) O_literal) ])

#define DEF(NAME, RELOC, REQ, ALLOW) \
 { #NAME, sizeof(#NAME)-1, O_##NAME, RELOC, REQ, ALLOW}

static const struct alpha_reloc_op_tag
{
  const char *name;				/* String to lookup.  */
  size_t length;				/* Size of the string.  */
  operatorT op;					/* Which operator to use.  */
  extended_bfd_reloc_code_real_type reloc;
  unsigned int require_seq : 1;			/* Require a sequence number.  */
  unsigned int allow_seq : 1;			/* Allow a sequence number.  */
}
alpha_reloc_op[] =
{
  DEF (literal, BFD_RELOC_ALPHA_ELF_LITERAL, 0, 1),
  DEF (lituse_addr, DUMMY_RELOC_LITUSE_ADDR, 1, 1),
  DEF (lituse_base, DUMMY_RELOC_LITUSE_BASE, 1, 1),
  DEF (lituse_bytoff, DUMMY_RELOC_LITUSE_BYTOFF, 1, 1),
  DEF (lituse_jsr, DUMMY_RELOC_LITUSE_JSR, 1, 1),
  DEF (lituse_tlsgd, DUMMY_RELOC_LITUSE_TLSGD, 1, 1),
  DEF (lituse_tlsldm, DUMMY_RELOC_LITUSE_TLSLDM, 1, 1),
  DEF (lituse_jsrdirect, DUMMY_RELOC_LITUSE_JSRDIRECT, 1, 1),
  DEF (gpdisp, BFD_RELOC_ALPHA_GPDISP, 1, 1),
  DEF (gprelhigh, BFD_RELOC_ALPHA_GPREL_HI16, 0, 0),
  DEF (gprellow, BFD_RELOC_ALPHA_GPREL_LO16, 0, 0),
  DEF (gprel, BFD_RELOC_GPREL16, 0, 0),
  DEF (samegp, BFD_RELOC_ALPHA_BRSGP, 0, 0),
  DEF (tlsgd, BFD_RELOC_ALPHA_TLSGD, 0, 1),
  DEF (tlsldm, BFD_RELOC_ALPHA_TLSLDM, 0, 1),
  DEF (gotdtprel, BFD_RELOC_ALPHA_GOTDTPREL16, 0, 0),
  DEF (dtprelhi, BFD_RELOC_ALPHA_DTPREL_HI16, 0, 0),
  DEF (dtprello, BFD_RELOC_ALPHA_DTPREL_LO16, 0, 0),
  DEF (dtprel, BFD_RELOC_ALPHA_DTPREL16, 0, 0),
  DEF (gottprel, BFD_RELOC_ALPHA_GOTTPREL16, 0, 0),
  DEF (tprelhi, BFD_RELOC_ALPHA_TPREL_HI16, 0, 0),
  DEF (tprello, BFD_RELOC_ALPHA_TPREL_LO16, 0, 0),
  DEF (tprel, BFD_RELOC_ALPHA_TPREL16, 0, 0),
};

#undef DEF

static const int alpha_num_reloc_op
  = sizeof (alpha_reloc_op) / sizeof (*alpha_reloc_op);
#endif /* RELOC_OP_P */

/* Maximum # digits needed to hold the largest sequence #.  */
#define ALPHA_RELOC_DIGITS 25

/* Structure to hold explicit sequence information.  */
struct alpha_reloc_tag
{
  fixS *master;			/* The literal reloc.  */
#ifdef OBJ_EVAX
  struct symbol *sym;		/* Linkage section item symbol.  */
  struct symbol *psym;		/* Pdesc symbol.  */
#endif
  fixS *slaves;			/* Head of linked list of lituses.  */
  segT segment;			/* Segment relocs are in or undefined_section.  */
  long sequence;		/* Sequence #.  */
  unsigned n_master;		/* # of literals.  */
  unsigned n_slaves;		/* # of lituses.  */
  unsigned saw_tlsgd : 1;	/* True if ...  */
  unsigned saw_tlsldm : 1;
  unsigned saw_lu_tlsgd : 1;
  unsigned saw_lu_tlsldm : 1;
  unsigned multi_section_p : 1;	/* True if more than one section was used.  */
  char string[1];		/* Printable form of sequence to hash with.  */
};

/* Hash table to link up literals with the appropriate lituse.  */
static struct hash_control *alpha_literal_hash;

/* Sequence numbers for internal use by macros.  */
static long next_sequence_num = -1;

/* A table of CPU names and opcode sets.  */

static const struct cpu_type
{
  const char *name;
  unsigned flags;
}
cpu_types[] =
{
  /* Ad hoc convention: cpu number gets palcode, process code doesn't.
     This supports usage under DU 4.0b that does ".arch ev4", and
     usage in MILO that does -m21064.  Probably something more
     specific like -m21064-pal should be used, but oh well.  */

  { "21064", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21064a", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21066", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21068", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21164", AXP_OPCODE_BASE|AXP_OPCODE_EV5 },
  { "21164a", AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX },
  { "21164pc", (AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX
		|AXP_OPCODE_MAX) },
  { "21264", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },
  { "21264a", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },
  { "21264b", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },

  { "ev4", AXP_OPCODE_BASE },
  { "ev45", AXP_OPCODE_BASE },
  { "lca45", AXP_OPCODE_BASE },
  { "ev5", AXP_OPCODE_BASE },
  { "ev56", AXP_OPCODE_BASE|AXP_OPCODE_BWX },
  { "pca56", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX },
  { "ev6", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },
  { "ev67", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },
  { "ev68", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },

  { "all", AXP_OPCODE_BASE },
  { 0, 0 }
};

/* Some instruction sets indexed by lg(size).  */
static const char * const sextX_op[] = { "sextb", "sextw", "sextl", NULL };
static const char * const insXl_op[] = { "insbl", "inswl", "insll", "insql" };
static const char * const insXh_op[] = { NULL,    "inswh", "inslh", "insqh" };
static const char * const extXl_op[] = { "extbl", "extwl", "extll", "extql" };
static const char * const extXh_op[] = { NULL,    "extwh", "extlh", "extqh" };
static const char * const mskXl_op[] = { "mskbl", "mskwl", "mskll", "mskql" };
static const char * const mskXh_op[] = { NULL,    "mskwh", "msklh", "mskqh" };
static const char * const stX_op[] = { "stb", "stw", "stl", "stq" };
static const char * const ldXu_op[] = { "ldbu", "ldwu", NULL, NULL };

static void assemble_insn (const struct alpha_opcode *, const expressionS *, int, struct alpha_insn *, extended_bfd_reloc_code_real_type);
static void emit_insn (struct alpha_insn *);
static void assemble_tokens (const char *, const expressionS *, int, int);
#ifdef OBJ_EVAX
static char *s_alpha_section_name (void);
static symbolS *add_to_link_pool (symbolS *, offsetT);
#endif

static struct alpha_reloc_tag *
get_alpha_reloc_tag (long sequence)
{
  char buffer[ALPHA_RELOC_DIGITS];
  struct alpha_reloc_tag *info;

  sprintf (buffer, "!%ld", sequence);

  info = (struct alpha_reloc_tag *) hash_find (alpha_literal_hash, buffer);
  if (! info)
    {
      size_t len = strlen (buffer);
      const char *errmsg;

      info = (struct alpha_reloc_tag *)
          xcalloc (sizeof (struct alpha_reloc_tag) + len, 1);

      info->segment = now_seg;
      info->sequence = sequence;
      strcpy (info->string, buffer);
      errmsg = hash_insert (alpha_literal_hash, info->string, (void *) info);
      if (errmsg)
	as_fatal ("%s", errmsg);
#ifdef OBJ_EVAX
      info->sym = 0;
      info->psym = 0;
#endif
    }

  return info;
}

#ifndef OBJ_EVAX

static void
alpha_adjust_relocs (bfd *abfd ATTRIBUTE_UNUSED,
		     asection *sec,
		     void * ptr ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  fixS **prevP;
  fixS *fixp;
  fixS *next;
  fixS *slave;

  /* If seginfo is NULL, we did not create this section; don't do
     anything with it.  By using a pointer to a pointer, we can update
     the links in place.  */
  if (seginfo == NULL)
    return;

  /* If there are no relocations, skip the section.  */
  if (! seginfo->fix_root)
    return;

  /* First rebuild the fixup chain without the explicit lituse and
     gpdisp_lo16 relocs.  */
  prevP = &seginfo->fix_root;
  for (fixp = seginfo->fix_root; fixp; fixp = next)
    {
      next = fixp->fx_next;
      fixp->fx_next = (fixS *) 0;

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_ALPHA_LITUSE:
	  if (fixp->tc_fix_data.info->n_master == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No !literal!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
#ifdef RELOC_OP_P
	  if (fixp->fx_offset == LITUSE_ALPHA_TLSGD)
	    {
	      if (! fixp->tc_fix_data.info->saw_tlsgd)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("No !tlsgd!%ld was found"),
			      fixp->tc_fix_data.info->sequence);
	    }
	  else if (fixp->fx_offset == LITUSE_ALPHA_TLSLDM)
	    {
	      if (! fixp->tc_fix_data.info->saw_tlsldm)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("No !tlsldm!%ld was found"),
			      fixp->tc_fix_data.info->sequence);
	    }
#endif
	  break;

	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  if (fixp->tc_fix_data.info->n_master == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No ldah !gpdisp!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
	  break;

	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  if (fixp->tc_fix_data.info
	      && (fixp->tc_fix_data.info->saw_tlsgd
	          || fixp->tc_fix_data.info->saw_tlsldm))
	    break;
	  /* FALLTHRU */

	default:
	  *prevP = fixp;
	  prevP = &fixp->fx_next;
	  break;
	}
    }

  /* Go back and re-chain dependent relocations.  They are currently
     linked through the next_reloc field in reverse order, so as we
     go through the next_reloc chain, we effectively reverse the chain
     once again.

     Except if there is more than one !literal for a given sequence
     number.  In that case, the programmer and/or compiler is not sure
     how control flows from literal to lituse, and we can't be sure to
     get the relaxation correct.

     ??? Well, actually we could, if there are enough lituses such that
     we can make each literal have at least one of each lituse type
     present.  Not implemented.

     Also suppress the optimization if the !literals/!lituses are spread
     in different segments.  This can happen with "intersting" uses of
     inline assembly; examples are present in the Linux kernel semaphores.  */

  for (fixp = seginfo->fix_root; fixp; fixp = next)
    {
      next = fixp->fx_next;
      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_ALPHA_TLSGD:
	case BFD_RELOC_ALPHA_TLSLDM:
	  if (!fixp->tc_fix_data.info)
	    break;
	  if (fixp->tc_fix_data.info->n_master == 0)
	    break;
	  else if (fixp->tc_fix_data.info->n_master > 1)
	    {
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("too many !literal!%ld for %s"),
			    fixp->tc_fix_data.info->sequence,
			    (fixp->fx_r_type == BFD_RELOC_ALPHA_TLSGD
			     ? "!tlsgd" : "!tlsldm"));
	      break;
	    }

	  fixp->tc_fix_data.info->master->fx_next = fixp->fx_next;
	  fixp->fx_next = fixp->tc_fix_data.info->master;
	  fixp = fixp->fx_next;
	  /* Fall through.  */

	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  if (fixp->tc_fix_data.info
	      && fixp->tc_fix_data.info->n_master == 1
	      && ! fixp->tc_fix_data.info->multi_section_p)
	    {
	      for (slave = fixp->tc_fix_data.info->slaves;
		   slave != (fixS *) 0;
		   slave = slave->tc_fix_data.next_reloc)
		{
		  slave->fx_next = fixp->fx_next;
		  fixp->fx_next = slave;
		}
	    }
	  break;

	case BFD_RELOC_ALPHA_GPDISP_HI16:
	  if (fixp->tc_fix_data.info->n_slaves == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No lda !gpdisp!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
	  else
	    {
	      slave = fixp->tc_fix_data.info->slaves;
	      slave->fx_next = next;
	      fixp->fx_next = slave;
	    }
	  break;

	default:
	  break;
	}
    }
}

/* Before the relocations are written, reorder them, so that user
   supplied !lituse relocations follow the appropriate !literal
   relocations, and similarly for !gpdisp relocations.  */

void
alpha_before_fix (void)
{
  if (alpha_literal_hash)
    bfd_map_over_sections (stdoutput, alpha_adjust_relocs, NULL);
}

#endif

#ifdef DEBUG_ALPHA
static void
debug_exp (expressionS tok[], int ntok)
{
  int i;

  fprintf (stderr, "debug_exp: %d tokens", ntok);
  for (i = 0; i < ntok; i++)
    {
      expressionS *t = &tok[i];
      const char *name;

      switch (t->X_op)
	{
	default:			name = "unknown";		break;
	case O_illegal:			name = "O_illegal";		break;
	case O_absent:			name = "O_absent";		break;
	case O_constant:		name = "O_constant";		break;
	case O_symbol:			name = "O_symbol";		break;
	case O_symbol_rva:		name = "O_symbol_rva";		break;
	case O_register:		name = "O_register";		break;
	case O_big:			name = "O_big";			break;
	case O_uminus:			name = "O_uminus";		break;
	case O_bit_not:			name = "O_bit_not";		break;
	case O_logical_not:		name = "O_logical_not";		break;
	case O_multiply:		name = "O_multiply";		break;
	case O_divide:			name = "O_divide";		break;
	case O_modulus:			name = "O_modulus";		break;
	case O_left_shift:		name = "O_left_shift";		break;
	case O_right_shift:		name = "O_right_shift";		break;
	case O_bit_inclusive_or:	name = "O_bit_inclusive_or";	break;
	case O_bit_or_not:		name = "O_bit_or_not";		break;
	case O_bit_exclusive_or:	name = "O_bit_exclusive_or";	break;
	case O_bit_and:			name = "O_bit_and";		break;
	case O_add:			name = "O_add";			break;
	case O_subtract:		name = "O_subtract";		break;
	case O_eq:			name = "O_eq";			break;
	case O_ne:			name = "O_ne";			break;
	case O_lt:			name = "O_lt";			break;
	case O_le:			name = "O_le";			break;
	case O_ge:			name = "O_ge";			break;
	case O_gt:			name = "O_gt";			break;
	case O_logical_and:		name = "O_logical_and";		break;
	case O_logical_or:		name = "O_logical_or";		break;
	case O_index:			name = "O_index";		break;
	case O_pregister:		name = "O_pregister";		break;
	case O_cpregister:		name = "O_cpregister";		break;
	case O_literal:			name = "O_literal";		break;
	case O_lituse_addr:		name = "O_lituse_addr";		break;
	case O_lituse_base:		name = "O_lituse_base";		break;
	case O_lituse_bytoff:		name = "O_lituse_bytoff";	break;
	case O_lituse_jsr:		name = "O_lituse_jsr";		break;
	case O_lituse_tlsgd:		name = "O_lituse_tlsgd";	break;
	case O_lituse_tlsldm:		name = "O_lituse_tlsldm";	break;
	case O_lituse_jsrdirect:	name = "O_lituse_jsrdirect";	break;
	case O_gpdisp:			name = "O_gpdisp";		break;
	case O_gprelhigh:		name = "O_gprelhigh";		break;
	case O_gprellow:		name = "O_gprellow";		break;
	case O_gprel:			name = "O_gprel";		break;
	case O_samegp:			name = "O_samegp";		break;
	case O_tlsgd:			name = "O_tlsgd";		break;
	case O_tlsldm:			name = "O_tlsldm";		break;
	case O_gotdtprel:		name = "O_gotdtprel";		break;
	case O_dtprelhi:		name = "O_dtprelhi";		break;
	case O_dtprello:		name = "O_dtprello";		break;
	case O_dtprel:			name = "O_dtprel";		break;
	case O_gottprel:		name = "O_gottprel";		break;
	case O_tprelhi:			name = "O_tprelhi";		break;
	case O_tprello:			name = "O_tprello";		break;
	case O_tprel:			name = "O_tprel";		break;
	}

      fprintf (stderr, ", %s(%s, %s, %d)", name,
	       (t->X_add_symbol) ? S_GET_NAME (t->X_add_symbol) : "--",
	       (t->X_op_symbol) ? S_GET_NAME (t->X_op_symbol) : "--",
	       (int) t->X_add_number);
    }
  fprintf (stderr, "\n");
  fflush (stderr);
}
#endif

/* Parse the arguments to an opcode.  */

static int
tokenize_arguments (char *str,
		    expressionS tok[],
		    int ntok)
{
  expressionS *end_tok = tok + ntok;
  char *old_input_line_pointer;
  int saw_comma = 0, saw_arg = 0;
#ifdef DEBUG_ALPHA
  expressionS *orig_tok = tok;
#endif
#ifdef RELOC_OP_P
  char *p;
  const struct alpha_reloc_op_tag *r;
  int c, i;
  size_t len;
  int reloc_found_p = 0;
#endif

  memset (tok, 0, sizeof (*tok) * ntok);

  /* Save and restore input_line_pointer around this function.  */
  old_input_line_pointer = input_line_pointer;
  input_line_pointer = str;

#ifdef RELOC_OP_P
  /* ??? Wrest control of ! away from the regular expression parser.  */
  is_end_of_line[(unsigned char) '!'] = 1;
#endif

  while (tok < end_tok && *input_line_pointer)
    {
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	case '\0':
	  goto fini;

#ifdef RELOC_OP_P
	case '!':
	  /* A relocation operand can be placed after the normal operand on an
	     assembly language statement, and has the following form:
		!relocation_type!sequence_number.  */
	  if (reloc_found_p)
	    {
	      /* Only support one relocation op per insn.  */
	      as_bad (_("More than one relocation op per insn"));
	      goto err_report;
	    }

	  if (!saw_arg)
	    goto err;

	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  p = input_line_pointer;
	  c = get_symbol_end ();

	  /* Parse !relocation_type.  */
	  len = input_line_pointer - p;
	  if (len == 0)
	    {
	      as_bad (_("No relocation operand"));
	      goto err_report;
	    }

	  r = &alpha_reloc_op[0];
	  for (i = alpha_num_reloc_op - 1; i >= 0; i--, r++)
	    if (len == r->length && memcmp (p, r->name, len) == 0)
	      break;
	  if (i < 0)
	    {
	      as_bad (_("Unknown relocation operand: !%s"), p);
	      goto err_report;
	    }

	  *input_line_pointer = c;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != '!')
	    {
	      if (r->require_seq)
		{
		  as_bad (_("no sequence number after !%s"), p);
		  goto err_report;
		}

	      tok->X_add_number = 0;
	    }
	  else
	    {
	      if (! r->allow_seq)
		{
		  as_bad (_("!%s does not use a sequence number"), p);
		  goto err_report;
		}

	      input_line_pointer++;

	      /* Parse !sequence_number.  */
	      expression (tok);
	      if (tok->X_op != O_constant || tok->X_add_number <= 0)
		{
		  as_bad (_("Bad sequence number: !%s!%s"),
			  r->name, input_line_pointer);
		  goto err_report;
		}
	    }

	  tok->X_op = r->op;
	  reloc_found_p = 1;
	  ++tok;
	  break;
#endif /* RELOC_OP_P */

	case ',':
	  ++input_line_pointer;
	  if (saw_comma || !saw_arg)
	    goto err;
	  saw_comma = 1;
	  break;

	case '(':
	  {
	    char *hold = input_line_pointer++;

	    /* First try for parenthesized register ...  */
	    expression (tok);
	    if (*input_line_pointer == ')' && tok->X_op == O_register)
	      {
		tok->X_op = (saw_comma ? O_cpregister : O_pregister);
		saw_comma = 0;
		saw_arg = 1;
		++input_line_pointer;
		++tok;
		break;
	      }

	    /* ... then fall through to plain expression.  */
	    input_line_pointer = hold;
	  }

	default:
	  if (saw_arg && !saw_comma)
	    goto err;

	  expression (tok);
	  if (tok->X_op == O_illegal || tok->X_op == O_absent)
	    goto err;

	  saw_comma = 0;
	  saw_arg = 1;
	  ++tok;
	  break;
	}
    }

fini:
  if (saw_comma)
    goto err;
  input_line_pointer = old_input_line_pointer;

#ifdef DEBUG_ALPHA
  debug_exp (orig_tok, ntok - (end_tok - tok));
#endif
#ifdef RELOC_OP_P
  is_end_of_line[(unsigned char) '!'] = 0;
#endif

  return ntok - (end_tok - tok);

err:
#ifdef RELOC_OP_P
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
  input_line_pointer = old_input_line_pointer;
  return TOKENIZE_ERROR;

#ifdef RELOC_OP_P
err_report:
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
  input_line_pointer = old_input_line_pointer;
  return TOKENIZE_ERROR_REPORT;
}

/* Search forward through all variants of an opcode looking for a
   syntax match.  */

static const struct alpha_opcode *
find_opcode_match (const struct alpha_opcode *first_opcode,
		   const expressionS *tok,
		   int *pntok,
		   int *pcpumatch)
{
  const struct alpha_opcode *opcode = first_opcode;
  int ntok = *pntok;
  int got_cpu_match = 0;

  do
    {
      const unsigned char *opidx;
      int tokidx = 0;

      /* Don't match opcodes that don't exist on this architecture.  */
      if (!(opcode->flags & alpha_target))
	goto match_failed;

      got_cpu_match = 1;

      for (opidx = opcode->operands; *opidx; ++opidx)
	{
	  const struct alpha_operand *operand = &alpha_operands[*opidx];

	  /* Only take input from real operands.  */
	  if (operand->flags & AXP_OPERAND_FAKE)
	    continue;

	  /* When we expect input, make sure we have it.  */
	  if (tokidx >= ntok)
	    {
	      if ((operand->flags & AXP_OPERAND_OPTIONAL_MASK) == 0)
		goto match_failed;
	      continue;
	    }

	  /* Match operand type with expression type.  */
	  switch (operand->flags & AXP_OPERAND_TYPECHECK_MASK)
	    {
	    case AXP_OPERAND_IR:
	      if (tok[tokidx].X_op != O_register
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_FPR:
	      if (tok[tokidx].X_op != O_register
		  || !is_fpr_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_IR | AXP_OPERAND_PARENS:
	      if (tok[tokidx].X_op != O_pregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_IR | AXP_OPERAND_PARENS | AXP_OPERAND_COMMA:
	      if (tok[tokidx].X_op != O_cpregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;

	    case AXP_OPERAND_RELATIVE:
	    case AXP_OPERAND_SIGNED:
	    case AXP_OPERAND_UNSIGNED:
	      switch (tok[tokidx].X_op)
		{
		case O_illegal:
		case O_absent:
		case O_register:
		case O_pregister:
		case O_cpregister:
		  goto match_failed;

		default:
		  break;
		}
	      break;

	    default:
	      /* Everything else should have been fake.  */
	      abort ();
	    }
	  ++tokidx;
	}

      /* Possible match -- did we use all of our input?  */
      if (tokidx == ntok)
	{
	  *pntok = ntok;
	  return opcode;
	}

    match_failed:;
    }
  while (++opcode - alpha_opcodes < (int) alpha_num_opcodes
	 && !strcmp (opcode->name, first_opcode->name));

  if (*pcpumatch)
    *pcpumatch = got_cpu_match;

  return NULL;
}

/* Given an opcode name and a pre-tokenized set of arguments, assemble
   the insn, but do not emit it.

   Note that this implies no macros allowed, since we can't store more
   than one insn in an insn structure.  */

static void
assemble_tokens_to_insn (const char *opname,
			 const expressionS *tok,
			 int ntok,
			 struct alpha_insn *insn)
{
  const struct alpha_opcode *opcode;

  /* Search opcodes.  */
  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
  if (opcode)
    {
      int cpumatch;
      opcode = find_opcode_match (opcode, tok, &ntok, &cpumatch);
      if (opcode)
	{
	  assemble_insn (opcode, tok, ntok, insn, BFD_RELOC_UNUSED);
	  return;
	}
      else if (cpumatch)
	as_bad (_("inappropriate arguments for opcode `%s'"), opname);
      else
	as_bad (_("opcode `%s' not supported for target %s"), opname,
		alpha_target_name);
    }
  else
    as_bad (_("unknown opcode `%s'"), opname);
}

/* Build a BFD section with its flags set appropriately for the .lita,
   .lit8, or .lit4 sections.  */

static void
create_literal_section (const char *name,
			segT *secp,
			symbolS **symp)
{
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_sec;

  *secp = new_sec = subseg_new (name, 0);
  subseg_set (current_section, current_subsec);
  bfd_set_section_alignment (stdoutput, new_sec, 4);
  bfd_set_section_flags (stdoutput, new_sec,
			 SEC_RELOC | SEC_ALLOC | SEC_LOAD | SEC_READONLY
			 | SEC_DATA);

  S_CLEAR_EXTERNAL (*symp = section_symbol (new_sec));
}

/* Load a (partial) expression into a target register.

   If poffset is not null, after the call it will either contain
   O_constant 0, or a 16-bit offset appropriate for any MEM format
   instruction.  In addition, pbasereg will be modified to point to
   the base register to use in that MEM format instruction.

   In any case, *pbasereg should contain a base register to add to the
   expression.  This will normally be either AXP_REG_ZERO or
   alpha_gp_register.  Symbol addresses will always be loaded via $gp,
   so "foo($0)" is interpreted as adding the address of foo to $0;
   i.e. "ldq $targ, LIT($gp); addq $targ, $0, $targ".  Odd, perhaps,
   but this is what OSF/1 does.

   If explicit relocations of the form !literal!<number> are allowed,
   and used, then explicit_reloc with be an expression pointer.

   Finally, the return value is nonzero if the calling macro may emit
   a LITUSE reloc if otherwise appropriate; the return value is the
   sequence number to use.  */

static long
load_expression (int targreg,
		 const expressionS *exp,
		 int *pbasereg,
		 expressionS *poffset,
		 const char *opname)
{
  long emit_lituse = 0;
  offsetT addend = exp->X_add_number;
  int basereg = *pbasereg;
  struct alpha_insn insn;
  expressionS newtok[3];

  switch (exp->X_op)
    {
    case O_symbol:
      {
#ifdef OBJ_ECOFF
	offsetT lit;

	/* Attempt to reduce .lit load by splitting the offset from
	   its symbol when possible, but don't create a situation in
	   which we'd fail.  */
	if (!range_signed_32 (addend) &&
	    (alpha_noat_on || targreg == AXP_REG_AT))
	  {
	    lit = add_to_literal_pool (exp->X_add_symbol, addend,
				       alpha_lita_section, 8);
	    addend = 0;
	  }
	else
	  lit = add_to_literal_pool (exp->X_add_symbol, 0,
				     alpha_lita_section, 8);

	if (lit >= 0x8000)
	  as_fatal (_("overflow in literal (.lita) table"));

	/* Emit "ldq r, lit(gp)".  */

	if (basereg != alpha_gp_register && targreg == basereg)
	  {
	    if (alpha_noat_on)
	      as_bad (_("macro requires $at register while noat in effect"));
	    if (targreg == AXP_REG_AT)
	      as_bad (_("macro requires $at while $at in use"));

	    set_tok_reg (newtok[0], AXP_REG_AT);
	  }
	else
	  set_tok_reg (newtok[0], targreg);

	set_tok_sym (newtok[1], alpha_lita_symbol, lit);
	set_tok_preg (newtok[2], alpha_gp_register);

	assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

	gas_assert (insn.nfixups == 1);
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
	insn.sequence = emit_lituse = next_sequence_num--;
#endif /* OBJ_ECOFF */
#ifdef OBJ_ELF
	/* Emit "ldq r, gotoff(gp)".  */

	if (basereg != alpha_gp_register && targreg == basereg)
	  {
	    if (alpha_noat_on)
	      as_bad (_("macro requires $at register while noat in effect"));
	    if (targreg == AXP_REG_AT)
	      as_bad (_("macro requires $at while $at in use"));

	    set_tok_reg (newtok[0], AXP_REG_AT);
	  }
	else
	  set_tok_reg (newtok[0], targreg);

	/* XXX: Disable this .got minimizing optimization so that we can get
	   better instruction offset knowledge in the compiler.  This happens
	   very infrequently anyway.  */
	if (1
	    || (!range_signed_32 (addend)
		&& (alpha_noat_on || targreg == AXP_REG_AT)))
	  {
	    newtok[1] = *exp;
	    addend = 0;
	  }
	else
	  set_tok_sym (newtok[1], exp->X_add_symbol, 0);

	set_tok_preg (newtok[2], alpha_gp_register);

	assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

	gas_assert (insn.nfixups == 1);
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
	insn.sequence = emit_lituse = next_sequence_num--;
#endif /* OBJ_ELF */
#ifdef OBJ_EVAX
	/* Find symbol or symbol pointer in link section.  */

	if (exp->X_add_symbol == alpha_evax_proc->symbol)
	  {
            /* Linkage-relative expression.  */
            set_tok_reg (newtok[0], targreg);

	    if (range_signed_16 (addend))
	      {
		set_tok_const (newtok[1], addend);
		addend = 0;
	      }
	    else
	      {
		set_tok_const (newtok[1], 0);
	      }
            set_tok_preg (newtok[2], basereg);
            assemble_tokens_to_insn ("lda", newtok, 3, &insn);
	  }
	else
	  {
	    const char *symname = S_GET_NAME (exp->X_add_symbol);
	    const char *ptr1, *ptr2;
	    int symlen = strlen (symname);

	    if ((symlen > 4 &&
		 strcmp (ptr2 = &symname [symlen - 4], "..lk") == 0))
	      {
                /* Access to an item whose address is stored in the linkage
                   section.  Just read the address.  */
		set_tok_reg (newtok[0], targreg);

		newtok[1] = *exp;
		newtok[1].X_op = O_subtract;
		newtok[1].X_op_symbol = alpha_evax_proc->symbol;

		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("ldq", newtok, 3, &insn);
		alpha_linkage_symbol = exp->X_add_symbol;

		if (poffset)
		  set_tok_const (*poffset, 0);

		if (alpha_flag_replace && targreg == 26)
		  {
                    /* Add a NOP fixup for 'ldX $26,YYY..NAME..lk'.  */
		    char *ensymname;
		    symbolS *ensym;

                    /* Build the entry name as 'NAME..en'.  */
		    ptr1 = strstr (symname, "..") + 2;
		    if (ptr1 > ptr2)
		      ptr1 = symname;
		    ensymname = (char *) alloca (ptr2 - ptr1 + 5);
		    memcpy (ensymname, ptr1, ptr2 - ptr1);
		    memcpy (ensymname + (ptr2 - ptr1), "..en", 5);

		    gas_assert (insn.nfixups + 1 <= MAX_INSN_FIXUPS);
		    insn.fixups[insn.nfixups].reloc = BFD_RELOC_ALPHA_NOP;
		    ensym = symbol_find_or_make (ensymname);
		    symbol_mark_used (ensym);
		    /* The fixup must be the same as the BFD_RELOC_ALPHA_BOH
		       case in emit_jsrjmp.  See B.4.5.2 of the OpenVMS Linker
		       Utility Manual.  */
		    insn.fixups[insn.nfixups].exp.X_op = O_symbol;
		    insn.fixups[insn.nfixups].exp.X_add_symbol = ensym;
		    insn.fixups[insn.nfixups].exp.X_add_number = 0;
		    insn.fixups[insn.nfixups].xtrasym = alpha_linkage_symbol;
		    insn.fixups[insn.nfixups].procsym = alpha_evax_proc->symbol;
		    insn.nfixups++;

		    /* ??? Force bsym to be instantiated now, as it will be
		       too late to do so in tc_gen_reloc.  */
		    symbol_get_bfdsym (exp->X_add_symbol);
		  }
		else if (alpha_flag_replace && targreg == 27)
		  {
                    /* Add a lda fixup for 'ldX $27,YYY.NAME..lk+8'.  */
		    char *psymname;
		    symbolS *psym;

                    /* Extract NAME.  */
		    ptr1 = strstr (symname, "..") + 2;
		    if (ptr1 > ptr2)
		      ptr1 = symname;
		    psymname = (char *) alloca (ptr2 - ptr1 + 1);
		    memcpy (psymname, ptr1, ptr2 - ptr1);
		    psymname [ptr2 - ptr1] = 0;

		    gas_assert (insn.nfixups + 1 <= MAX_INSN_FIXUPS);
		    insn.fixups[insn.nfixups].reloc = BFD_RELOC_ALPHA_LDA;
		    psym = symbol_find_or_make (psymname);
		    symbol_mark_used (psym);
		    insn.fixups[insn.nfixups].exp.X_op = O_subtract;
		    insn.fixups[insn.nfixups].exp.X_add_symbol = psym;
		    insn.fixups[insn.nfixups].exp.X_op_symbol = alpha_evax_proc->symbol;
		    insn.fixups[insn.nfixups].exp.X_add_number = 0;
		    insn.fixups[insn.nfixups].xtrasym = alpha_linkage_symbol;
		    insn.fixups[insn.nfixups].procsym = alpha_evax_proc->symbol;
		    insn.nfixups++;
		  }

		emit_insn (&insn);
		return 0;
	      }
	    else
	      {
                /* Not in the linkage section.  Put the value into the linkage
                   section.  */
		symbolS *linkexp;

		if (!range_signed_32 (addend))
		  addend = sign_extend_32 (addend);
		linkexp = add_to_link_pool (exp->X_add_symbol, 0);
		set_tok_reg (newtok[0], targreg);
		set_tok_sym (newtok[1], linkexp, 0);
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("ldq", newtok, 3, &insn);
	      }
	  }
#endif /* OBJ_EVAX */

	emit_insn (&insn);

#ifndef OBJ_EVAX
	if (basereg != alpha_gp_register && basereg != AXP_REG_ZERO)
	  {
	    /* Emit "addq r, base, r".  */

	    set_tok_reg (newtok[1], basereg);
	    set_tok_reg (newtok[2], targreg);
	    assemble_tokens ("addq", newtok, 3, 0);
	  }
#endif
	basereg = targreg;
      }
      break;

    case O_constant:
      break;

    case O_subtract:
      /* Assume that this difference expression will be resolved to an
	 absolute value and that that value will fit in 16 bits.  */

      set_tok_reg (newtok[0], targreg);
      newtok[1] = *exp;
      set_tok_preg (newtok[2], basereg);
      assemble_tokens (opname, newtok, 3, 0);

      if (poffset)
	set_tok_const (*poffset, 0);
      return 0;

    case O_big:
      if (exp->X_add_number > 0)
	as_bad (_("bignum invalid; zero assumed"));
      else
	as_bad (_("floating point number invalid; zero assumed"));
      addend = 0;
      break;

    default:
      as_bad (_("can't handle expression"));
      addend = 0;
      break;
    }

  if (!range_signed_32 (addend))
    {
#ifdef OBJ_EVAX
      symbolS *litexp;
#else
      offsetT lit;
      long seq_num = next_sequence_num--;
#endif

      /* For 64-bit addends, just put it in the literal pool.  */
#ifdef OBJ_EVAX
      /* Emit "ldq targreg, lit(basereg)".  */
      litexp = add_to_link_pool (section_symbol (absolute_section), addend);
      set_tok_reg (newtok[0], targreg);
      set_tok_sym (newtok[1], litexp, 0);
      set_tok_preg (newtok[2], alpha_gp_register);
      assemble_tokens ("ldq", newtok, 3, 0);
#else

      if (alpha_lit8_section == NULL)
	{
	  create_literal_section (".lit8",
				  &alpha_lit8_section,
				  &alpha_lit8_symbol);

#ifdef OBJ_ECOFF
	  alpha_lit8_literal = add_to_literal_pool (alpha_lit8_symbol, 0x8000,
						    alpha_lita_section, 8);
	  if (alpha_lit8_literal >= 0x8000)
	    as_fatal (_("overflow in literal (.lita) table"));
#endif
	}

      lit = add_to_literal_pool (NULL, addend, alpha_lit8_section, 8) - 0x8000;
      if (lit >= 0x8000)
	as_fatal (_("overflow in literal (.lit8) table"));

      /* Emit "lda litreg, .lit8+0x8000".  */

      if (targreg == basereg)
	{
	  if (alpha_noat_on)
	    as_bad (_("macro requires $at register while noat in effect"));
	  if (targreg == AXP_REG_AT)
	    as_bad (_("macro requires $at while $at in use"));

	  set_tok_reg (newtok[0], AXP_REG_AT);
	}
      else
	set_tok_reg (newtok[0], targreg);
#ifdef OBJ_ECOFF
      set_tok_sym (newtok[1], alpha_lita_symbol, alpha_lit8_literal);
#endif
#ifdef OBJ_ELF
      set_tok_sym (newtok[1], alpha_lit8_symbol, 0x8000);
#endif
      set_tok_preg (newtok[2], alpha_gp_register);

      assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

      gas_assert (insn.nfixups == 1);
#ifdef OBJ_ECOFF
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
#endif
#ifdef OBJ_ELF
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
#endif
      insn.sequence = seq_num;

      emit_insn (&insn);

      /* Emit "ldq litreg, lit(litreg)".  */

      set_tok_const (newtok[1], lit);
      set_tok_preg (newtok[2], newtok[0].X_add_number);

      assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

      gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = seq_num;
      emit_lituse = 0;

      emit_insn (&insn);

      /* Emit "addq litreg, base, target".  */

      if (basereg != AXP_REG_ZERO)
	{
	  set_tok_reg (newtok[1], basereg);
	  set_tok_reg (newtok[2], targreg);
	  assemble_tokens ("addq", newtok, 3, 0);
	}
#endif /* !OBJ_EVAX */

      if (poffset)
	set_tok_const (*poffset, 0);
      *pbasereg = targreg;
    }
  else
    {
      offsetT low, high, extra, tmp;

      /* For 32-bit operands, break up the addend.  */

      low = sign_extend_16 (addend);
      tmp = addend - low;
      high = sign_extend_16 (tmp >> 16);

      if (tmp - (high << 16))
	{
	  extra = 0x4000;
	  tmp -= 0x40000000;
	  high = sign_extend_16 (tmp >> 16);
	}
      else
	extra = 0;

      set_tok_reg (newtok[0], targreg);
      set_tok_preg (newtok[2], basereg);

      if (extra)
	{
	  /* Emit "ldah r, extra(r).  */
	  set_tok_const (newtok[1], extra);
	  assemble_tokens ("ldah", newtok, 3, 0);
	  set_tok_preg (newtok[2], basereg = targreg);
	}

      if (high)
	{
	  /* Emit "ldah r, high(r).  */
	  set_tok_const (newtok[1], high);
	  assemble_tokens ("ldah", newtok, 3, 0);
	  basereg = targreg;
	  set_tok_preg (newtok[2], basereg);
	}

      if ((low && !poffset) || (!poffset && basereg != targreg))
	{
	  /* Emit "lda r, low(base)".  */
	  set_tok_const (newtok[1], low);
	  assemble_tokens ("lda", newtok, 3, 0);
	  basereg = targreg;
	  low = 0;
	}

      if (poffset)
	set_tok_const (*poffset, low);
      *pbasereg = basereg;
    }

  return emit_lituse;
}

/* The lda macro differs from the lda instruction in that it handles
   most simple expressions, particularly symbol address loads and
   large constants.  */

static void
emit_lda (const expressionS *tok,
	  int ntok,
	  const void * unused ATTRIBUTE_UNUSED)
{
  int basereg;

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL, "lda");
}

/* The ldah macro differs from the ldah instruction in that it has $31
   as an implied base register.  */

static void
emit_ldah (const expressionS *tok,
	   int ntok ATTRIBUTE_UNUSED,
	   const void * unused ATTRIBUTE_UNUSED)
{
  expressionS newtok[3];

  newtok[0] = tok[0];
  newtok[1] = tok[1];
  set_tok_preg (newtok[2], AXP_REG_ZERO);

  assemble_tokens ("ldah", newtok, 3, 0);
}

/* Called internally to handle all alignment needs.  This takes care
   of eliding calls to frag_align if'n the cached current alignment
   says we've already got it, as well as taking care of the auto-align
   feature wrt labels.  */

static void
alpha_align (int n,
	     char *pfill,
	     symbolS *label,
	     int force ATTRIBUTE_UNUSED)
{
  if (alpha_current_align >= n)
    return;

  if (pfill == NULL)
    {
      if (subseg_text_p (now_seg))
	frag_align_code (n, 0);
      else
	frag_align (n, 0, 0);
    }
  else
    frag_align (n, *pfill, 0);

  alpha_current_align = n;

  if (label != NULL && S_GET_SEGMENT (label) == now_seg)
    {
      symbol_set_frag (label, frag_now);
      S_SET_VALUE (label, (valueT) frag_now_fix ());
    }

  record_alignment (now_seg, n);

  /* ??? If alpha_flag_relax && force && elf, record the requested alignment
     in a reloc for the linker to see.  */
}

/* Actually output an instruction with its fixup.  */

static void
emit_insn (struct alpha_insn *insn)
{
  char *f;
  int i;

  /* Take care of alignment duties.  */
  if (alpha_auto_align_on && alpha_current_align < 2)
    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > 2)
    alpha_current_align = 2;
  alpha_insn_label = NULL;

  /* Write out the instruction.  */
  f = frag_more (4);
  md_number_to_chars (f, insn->insn, 4);

#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif

  /* Apply the fixups in order.  */
  for (i = 0; i < insn->nfixups; ++i)
    {
      const struct alpha_operand *operand = (const struct alpha_operand *) 0;
      struct alpha_fixup *fixup = &insn->fixups[i];
      struct alpha_reloc_tag *info = NULL;
      int size, pcrel;
      fixS *fixP;

      /* Some fixups are only used internally and so have no howto.  */
      if ((int) fixup->reloc < 0)
	{
	  operand = &alpha_operands[-(int) fixup->reloc];
	  size = 4;
	  pcrel = ((operand->flags & AXP_OPERAND_RELATIVE) != 0);
	}
      else if (fixup->reloc > BFD_RELOC_UNUSED
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_HI16
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_LO16)
	{
	  size = 2;
	  pcrel = 0;
	}
      else
	{
	  reloc_howto_type *reloc_howto =
              bfd_reloc_type_lookup (stdoutput,
                                     (bfd_reloc_code_real_type) fixup->reloc);
	  gas_assert (reloc_howto);

	  size = bfd_get_reloc_size (reloc_howto);

	  switch (fixup->reloc)
	    {
#ifdef OBJ_EVAX
	    case BFD_RELOC_ALPHA_NOP:
	    case BFD_RELOC_ALPHA_BSR:
	    case BFD_RELOC_ALPHA_LDA:
	    case BFD_RELOC_ALPHA_BOH:
	      break;
#endif
	    default:
	      gas_assert (size >= 1 && size <= 4);
	    }
 
	  pcrel = reloc_howto->pc_relative;
	}

      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal, size,
			  &fixup->exp, pcrel, (bfd_reloc_code_real_type) fixup->reloc);

      /* Turn off complaints that the addend is too large for some fixups,
         and copy in the sequence number for the explicit relocations.  */
      switch (fixup->reloc)
	{
	case BFD_RELOC_ALPHA_HINT:
	case BFD_RELOC_GPREL32:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_ALPHA_GPREL_HI16:
	case BFD_RELOC_ALPHA_GPREL_LO16:
	case BFD_RELOC_ALPHA_GOTDTPREL16:
	case BFD_RELOC_ALPHA_DTPREL_HI16:
	case BFD_RELOC_ALPHA_DTPREL_LO16:
	case BFD_RELOC_ALPHA_DTPREL16:
	case BFD_RELOC_ALPHA_GOTTPREL16:
	case BFD_RELOC_ALPHA_TPREL_HI16:
	case BFD_RELOC_ALPHA_TPREL_LO16:
	case BFD_RELOC_ALPHA_TPREL16:
	  fixP->fx_no_overflow = 1;
	  break;

	case BFD_RELOC_ALPHA_GPDISP_HI16:
	  fixP->fx_no_overflow = 1;
	  fixP->fx_addsy = section_symbol (now_seg);
	  fixP->fx_offset = 0;

	  info = get_alpha_reloc_tag (insn->sequence);
	  if (++info->n_master > 1)
	    as_bad (_("too many ldah insns for !gpdisp!%ld"), insn->sequence);
	  if (info->segment != now_seg)
	    as_bad (_("both insns for !gpdisp!%ld must be in the same section"),
		    insn->sequence);
	  fixP->tc_fix_data.info = info;
	  break;

	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  fixP->fx_no_overflow = 1;

	  info = get_alpha_reloc_tag (insn->sequence);
	  if (++info->n_slaves > 1)
	    as_bad (_("too many lda insns for !gpdisp!%ld"), insn->sequence);
	  if (info->segment != now_seg)
	    as_bad (_("both insns for !gpdisp!%ld must be in the same section"),
		    insn->sequence);
	  fixP->tc_fix_data.info = info;
	  info->slaves = fixP;
	  break;

	case BFD_RELOC_ALPHA_LITERAL:
	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  fixP->fx_no_overflow = 1;

	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  info->master = fixP;
	  info->n_master++;
	  if (info->segment != now_seg)
	    info->multi_section_p = 1;
	  fixP->tc_fix_data.info = info;
	  break;

#ifdef RELOC_OP_P
	case DUMMY_RELOC_LITUSE_ADDR:
	  fixP->fx_offset = LITUSE_ALPHA_ADDR;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_BASE:
	  fixP->fx_offset = LITUSE_ALPHA_BASE;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_BYTOFF:
	  fixP->fx_offset = LITUSE_ALPHA_BYTOFF;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_JSR:
	  fixP->fx_offset = LITUSE_ALPHA_JSR;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_TLSGD:
	  fixP->fx_offset = LITUSE_ALPHA_TLSGD;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_TLSLDM:
	  fixP->fx_offset = LITUSE_ALPHA_TLSLDM;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_JSRDIRECT:
	  fixP->fx_offset = LITUSE_ALPHA_JSRDIRECT;
	  goto do_lituse;
	do_lituse:
	  fixP->fx_addsy = section_symbol (now_seg);
	  fixP->fx_r_type = BFD_RELOC_ALPHA_LITUSE;

	  info = get_alpha_reloc_tag (insn->sequence);
	  if (fixup->reloc == DUMMY_RELOC_LITUSE_TLSGD)
	    info->saw_lu_tlsgd = 1;
	  else if (fixup->reloc == DUMMY_RELOC_LITUSE_TLSLDM)
	    info->saw_lu_tlsldm = 1;
	  if (++info->n_slaves > 1)
	    {
	      if (info->saw_lu_tlsgd)
		as_bad (_("too many lituse insns for !lituse_tlsgd!%ld"),
		        insn->sequence);
	      else if (info->saw_lu_tlsldm)
		as_bad (_("too many lituse insns for !lituse_tlsldm!%ld"),
		        insn->sequence);
	    }
	  fixP->tc_fix_data.info = info;
	  fixP->tc_fix_data.next_reloc = info->slaves;
	  info->slaves = fixP;
	  if (info->segment != now_seg)
	    info->multi_section_p = 1;
	  break;

	case BFD_RELOC_ALPHA_TLSGD:
	  fixP->fx_no_overflow = 1;

	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (info->saw_tlsgd)
	    as_bad (_("duplicate !tlsgd!%ld"), insn->sequence);
	  else if (info->saw_tlsldm)
	    as_bad (_("sequence number in use for !tlsldm!%ld"),
		    insn->sequence);
	  else
	    info->saw_tlsgd = 1;
	  fixP->tc_fix_data.info = info;
	  break;

	case BFD_RELOC_ALPHA_TLSLDM:
	  fixP->fx_no_overflow = 1;

	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (info->saw_tlsldm)
	    as_bad (_("duplicate !tlsldm!%ld"), insn->sequence);
	  else if (info->saw_tlsgd)
	    as_bad (_("sequence number in use for !tlsgd!%ld"),
		    insn->sequence);
	  else
	    info->saw_tlsldm = 1;
	  fixP->tc_fix_data.info = info;
	  break;
#endif
#ifdef OBJ_EVAX
	case BFD_RELOC_ALPHA_NOP:
	case BFD_RELOC_ALPHA_LDA:
	case BFD_RELOC_ALPHA_BSR:
	case BFD_RELOC_ALPHA_BOH:
	  info = get_alpha_reloc_tag (next_sequence_num--);
	  fixP->tc_fix_data.info = info;
	  fixP->tc_fix_data.info->sym = fixup->xtrasym;
	  fixP->tc_fix_data.info->psym = fixup->procsym;
	  break;
#endif

	default:
	  if ((int) fixup->reloc < 0)
	    {
	      if (operand->flags & AXP_OPERAND_NOOVERFLOW)
		fixP->fx_no_overflow = 1;
	    }
	  break;
	}
    }
}

/* Insert an operand value into an instruction.  */

static unsigned
insert_operand (unsigned insn,
		const struct alpha_operand *operand,
		offsetT val,
		char *file,
		unsigned line)
{
  if (operand->bits != 32 && !(operand->flags & AXP_OPERAND_NOOVERFLOW))
    {
      offsetT min, max;

      if (operand->flags & AXP_OPERAND_SIGNED)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = -(1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      if (val < min || val > max)
	as_bad_value_out_of_range (_("operand"), val, min, max, file, line);
    }

  if (operand->insert)
    {
      const char *errmsg = NULL;

      insn = (*operand->insert) (insn, val, &errmsg);
      if (errmsg)
	as_warn ("%s", errmsg);
    }
  else
    insn |= ((val & ((1 << operand->bits) - 1)) << operand->shift);

  return insn;
}

/* Turn an opcode description and a set of arguments into
   an instruction and a fixup.  */

static void
assemble_insn (const struct alpha_opcode *opcode,
	       const expressionS *tok,
	       int ntok,
	       struct alpha_insn *insn,
	       extended_bfd_reloc_code_real_type reloc)
{
  const struct alpha_operand *reloc_operand = NULL;
  const expressionS *reloc_exp = NULL;
  const unsigned char *argidx;
  unsigned image;
  int tokidx = 0;

  memset (insn, 0, sizeof (*insn));
  image = opcode->opcode;

  for (argidx = opcode->operands; *argidx; ++argidx)
    {
      const struct alpha_operand *operand = &alpha_operands[*argidx];
      const expressionS *t = (const expressionS *) 0;

      if (operand->flags & AXP_OPERAND_FAKE)
	{
	  /* Fake operands take no value and generate no fixup.  */
	  image = insert_operand (image, operand, 0, NULL, 0);
	  continue;
	}

      if (tokidx >= ntok)
	{
	  switch (operand->flags & AXP_OPERAND_OPTIONAL_MASK)
	    {
	    case AXP_OPERAND_DEFAULT_FIRST:
	      t = &tok[0];
	      break;
	    case AXP_OPERAND_DEFAULT_SECOND:
	      t = &tok[1];
	      break;
	    case AXP_OPERAND_DEFAULT_ZERO:
	      {
		static expressionS zero_exp;
		t = &zero_exp;
		zero_exp.X_op = O_constant;
		zero_exp.X_unsigned = 1;
	      }
	      break;
	    default:
	      abort ();
	    }
	}
      else
	t = &tok[tokidx++];

      switch (t->X_op)
	{
	case O_register:
	case O_pregister:
	case O_cpregister:
	  image = insert_operand (image, operand, regno (t->X_add_number),
				  NULL, 0);
	  break;

	case O_constant:
	  image = insert_operand (image, operand, t->X_add_number, NULL, 0);
	  gas_assert (reloc_operand == NULL);
	  reloc_operand = operand;
	  reloc_exp = t;
	  break;

	default:
	  /* This is only 0 for fields that should contain registers,
	     which means this pattern shouldn't have matched.  */
	  if (operand->default_reloc == 0)
	    abort ();

	  /* There is one special case for which an insn receives two
	     relocations, and thus the user-supplied reloc does not
	     override the operand reloc.  */
	  if (operand->default_reloc == BFD_RELOC_ALPHA_HINT)
	    {
	      struct alpha_fixup *fixup;

	      if (insn->nfixups >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));

	      fixup = &insn->fixups[insn->nfixups++];
	      fixup->exp = *t;
	      fixup->reloc = BFD_RELOC_ALPHA_HINT;
	    }
	  else
	    {
	      if (reloc == BFD_RELOC_UNUSED)
		reloc = operand->default_reloc;

	      gas_assert (reloc_operand == NULL);
	      reloc_operand = operand;
	      reloc_exp = t;
	    }
	  break;
	}
    }

  if (reloc != BFD_RELOC_UNUSED)
    {
      struct alpha_fixup *fixup;

      if (insn->nfixups >= MAX_INSN_FIXUPS)
	as_fatal (_("too many fixups"));

      /* ??? My but this is hacky.  But the OSF/1 assembler uses the same
	 relocation tag for both ldah and lda with gpdisp.  Choose the
	 correct internal relocation based on the opcode.  */
      if (reloc == BFD_RELOC_ALPHA_GPDISP)
	{
	  if (strcmp (opcode->name, "ldah") == 0)
	    reloc = BFD_RELOC_ALPHA_GPDISP_HI16;
	  else if (strcmp (opcode->name, "lda") == 0)
	    reloc = BFD_RELOC_ALPHA_GPDISP_LO16;
	  else
	    as_bad (_("invalid relocation for instruction"));
	}

      /* If this is a real relocation (as opposed to a lituse hint), then
	 the relocation width should match the operand width.
	 Take care of -MDISP in operand table.  */ 
      else if (reloc < BFD_RELOC_UNUSED && reloc > 0)
	{
	  reloc_howto_type *reloc_howto
              = bfd_reloc_type_lookup (stdoutput,
                                       (bfd_reloc_code_real_type) reloc);
	  if (reloc_operand == NULL
	      || reloc_howto->bitsize != reloc_operand->bits)
	    {
	      as_bad (_("invalid relocation for field"));
	      return;
	    }
	}

      fixup = &insn->fixups[insn->nfixups++];
      if (reloc_exp)
	fixup->exp = *reloc_exp;
      else
	fixup->exp.X_op = O_absent;
      fixup->reloc = reloc;
    }

  insn->insn = image;
}

/* Handle all "simple" integer register loads -- ldq, ldq_l, ldq_u,
   etc.  They differ from the real instructions in that they do simple
   expressions like the lda macro.  */

static void
emit_ir_load (const expressionS *tok,
	      int ntok,
	      const void * opname)
{
  int basereg;
  long lituse;
  expressionS newtok[3];
  struct alpha_insn insn;
  const char *symname
    = tok[1].X_add_symbol ? S_GET_NAME (tok[1].X_add_symbol): "";
  int symlen = strlen (symname);

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  lituse = load_expression (tok[0].X_add_number, &tok[1],
			    &basereg, &newtok[1], (const char *) opname);

  if (basereg == alpha_gp_register &&
      (symlen > 4 && strcmp (&symname [symlen - 4], "..lk") == 0))
    return;
  
  newtok[0] = tok[0];
  set_tok_preg (newtok[2], basereg);

  assemble_tokens_to_insn ((const char *) opname, newtok, 3, &insn);

  if (lituse)
    {
      gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
    }

  emit_insn (&insn);
}

/* Handle fp register loads, and both integer and fp register stores.
   Again, we handle simple expressions.  */

static void
emit_loadstore (const expressionS *tok,
		int ntok,
		const void * opname)
{
  int basereg;
  long lituse;
  expressionS newtok[3];
  struct alpha_insn insn;

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  if (tok[1].X_op != O_constant || !range_signed_16 (tok[1].X_add_number))
    {
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      lituse = load_expression (AXP_REG_AT, &tok[1], 
				&basereg, &newtok[1], (const char *) opname);
    }
  else
    {
      newtok[1] = tok[1];
      lituse = 0;
    }

  newtok[0] = tok[0];
  set_tok_preg (newtok[2], basereg);

  assemble_tokens_to_insn ((const char *) opname, newtok, 3, &insn);

  if (lituse)
    {
      gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
    }

  emit_insn (&insn);
}

/* Load a half-word or byte as an unsigned value.  */

static void
emit_ldXu (const expressionS *tok,
	   int ntok,
	   const void * vlgsize)
{
  if (alpha_target & AXP_OPCODE_BWX)
    emit_ir_load (tok, ntok, ldXu_op[(long) vlgsize]);
  else
    {
      expressionS newtok[3];
      struct alpha_insn insn;
      int basereg;
      long lituse;

      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      if (ntok == 2)
	basereg = (tok[1].X_op == O_constant
		   ? AXP_REG_ZERO : alpha_gp_register);
      else
	basereg = tok[2].X_add_number;

      /* Emit "lda $at, exp".  */
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL, "lda");

      /* Emit "ldq_u targ, 0($at)".  */
      newtok[0] = tok[0];
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], basereg);
      assemble_tokens_to_insn ("ldq_u", newtok, 3, &insn);

      if (lituse)
	{
	  gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* Emit "extXl targ, $at, targ".  */
      set_tok_reg (newtok[1], basereg);
      newtok[2] = newtok[0];
      assemble_tokens_to_insn (extXl_op[(long) vlgsize], newtok, 3, &insn);

      if (lituse)
	{
	  gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
    }
}

/* Load a half-word or byte as a signed value.  */

static void
emit_ldX (const expressionS *tok,
	  int ntok,
	  const void * vlgsize)
{
  emit_ldXu (tok, ntok, vlgsize);
  assemble_tokens (sextX_op[(long) vlgsize], tok, 1, 1);
}

/* Load an integral value from an unaligned address as an unsigned
   value.  */

static void
emit_uldXu (const expressionS *tok,
	    int ntok,
	    const void * vlgsize)
{
  long lgsize = (long) vlgsize;
  expressionS newtok[3];

  if (alpha_noat_on)
    as_bad (_("macro requires $at register while noat in effect"));

  /* Emit "lda $at, exp".  */
  memcpy (newtok, tok, sizeof (expressionS) * ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);

  /* Emit "ldq_u $t9, 0($at)".  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* Emit "ldq_u $t10, size-1($at)".  */
  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* Emit "extXl $t9, $at, $t9".  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T9);
  assemble_tokens (extXl_op[lgsize], newtok, 3, 1);

  /* Emit "extXh $t10, $at, $t10".  */
  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_reg (newtok[2], AXP_REG_T10);
  assemble_tokens (extXh_op[lgsize], newtok, 3, 1);

  /* Emit "or $t9, $t10, targ".  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_T10);
  newtok[2] = tok[0];
  assemble_tokens ("or", newtok, 3, 1);
}

/* Load an integral value from an unaligned address as a signed value.
   Note that quads should get funneled to the unsigned load since we
   don't have to do the sign extension.  */

static void
emit_uldX (const expressionS *tok,
	   int ntok,
	   const void * vlgsize)
{
  emit_uldXu (tok, ntok, vlgsize);
  assemble_tokens (sextX_op[(long) vlgsize], tok, 1, 1);
}

/* Implement the ldil macro.  */

static void
emit_ldil (const expressionS *tok,
	   int ntok,
	   const void * unused ATTRIBUTE_UNUSED)
{
  expressionS newtok[2];

  memcpy (newtok, tok, sizeof (newtok));
  newtok[1].X_add_number = sign_extend_32 (tok[1].X_add_number);

  assemble_tokens ("lda", newtok, ntok, 1);
}

/* Store a half-word or byte.  */

static void
emit_stX (const expressionS *tok,
	  int ntok,
	  const void * vlgsize)
{
  int lgsize = (int) (long) vlgsize;

  if (alpha_target & AXP_OPCODE_BWX)
    emit_loadstore (tok, ntok, stX_op[lgsize]);
  else
    {
      expressionS newtok[3];
      struct alpha_insn insn;
      int basereg;
      long lituse;

      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      if (ntok == 2)
	basereg = (tok[1].X_op == O_constant
		   ? AXP_REG_ZERO : alpha_gp_register);
      else
	basereg = tok[2].X_add_number;

      /* Emit "lda $at, exp".  */
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL, "lda");

      /* Emit "ldq_u $t9, 0($at)".  */
      set_tok_reg (newtok[0], AXP_REG_T9);
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], basereg);
      assemble_tokens_to_insn ("ldq_u", newtok, 3, &insn);

      if (lituse)
	{
	  gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* Emit "insXl src, $at, $t10".  */
      newtok[0] = tok[0];
      set_tok_reg (newtok[1], basereg);
      set_tok_reg (newtok[2], AXP_REG_T10);
      assemble_tokens_to_insn (insXl_op[lgsize], newtok, 3, &insn);

      if (lituse)
	{
	  gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* Emit "mskXl $t9, $at, $t9".  */
      set_tok_reg (newtok[0], AXP_REG_T9);
      newtok[2] = newtok[0];
      assemble_tokens_to_insn (mskXl_op[lgsize], newtok, 3, &insn);

      if (lituse)
	{
	  gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* Emit "or $t9, $t10, $t9".  */
      set_tok_reg (newtok[1], AXP_REG_T10);
      assemble_tokens ("or", newtok, 3, 1);

      /* Emit "stq_u $t9, 0($at).  */
      set_tok_const(newtok[1], 0);
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens_to_insn ("stq_u", newtok, 3, &insn);

      if (lituse)
	{
	  gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
    }
}

/* Store an integer to an unaligned address.  */

static void
emit_ustX (const expressionS *tok,
	   int ntok,
	   const void * vlgsize)
{
  int lgsize = (int) (long) vlgsize;
  expressionS newtok[3];

  /* Emit "lda $at, exp".  */
  memcpy (newtok, tok, sizeof (expressionS) * ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);

  /* Emit "ldq_u $9, 0($at)".  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* Emit "ldq_u $10, size-1($at)".  */
  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* Emit "insXl src, $at, $t11".  */
  newtok[0] = tok[0];
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T11);
  assemble_tokens (insXl_op[lgsize], newtok, 3, 1);

  /* Emit "insXh src, $at, $t12".  */
  set_tok_reg (newtok[2], AXP_REG_T12);
  assemble_tokens (insXh_op[lgsize], newtok, 3, 1);

  /* Emit "mskXl $t9, $at, $t9".  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  newtok[2] = newtok[0];
  assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);

  /* Emit "mskXh $t10, $at, $t10".  */
  set_tok_reg (newtok[0], AXP_REG_T10);
  newtok[2] = newtok[0];
  assemble_tokens (mskXh_op[lgsize], newtok, 3, 1);

  /* Emit "or $t9, $t11, $t9".  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_T11);
  newtok[2] = newtok[0];
  assemble_tokens ("or", newtok, 3, 1);

  /* Emit "or $t10, $t12, $t10".  */
  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_reg (newtok[1], AXP_REG_T12);
  newtok[2] = newtok[0];
  assemble_tokens ("or", newtok, 3, 1);

  /* Emit "stq_u $t10, size-1($at)".  */
  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("stq_u", newtok, 3, 1);

  /* Emit "stq_u $t9, 0($at)".  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  assemble_tokens ("stq_u", newtok, 3, 1);
}

/* Sign extend a half-word or byte.  The 32-bit sign extend is
   implemented as "addl $31, $r, $t" in the opcode table.  */

static void
emit_sextX (const expressionS *tok,
	    int ntok,
	    const void * vlgsize)
{
  long lgsize = (long) vlgsize;

  if (alpha_target & AXP_OPCODE_BWX)
    assemble_tokens (sextX_op[lgsize], tok, ntok, 0);
  else
    {
      int bitshift = 64 - 8 * (1 << lgsize);
      expressionS newtok[3];

      /* Emit "sll src,bits,dst".  */
      newtok[0] = tok[0];
      set_tok_const (newtok[1], bitshift);
      newtok[2] = tok[ntok - 1];
      assemble_tokens ("sll", newtok, 3, 1);

      /* Emit "sra dst,bits,dst".  */
      newtok[0] = newtok[2];
      assemble_tokens ("sra", newtok, 3, 1);
    }
}

/* Implement the division and modulus macros.  */

#ifdef OBJ_EVAX

/* Make register usage like in normal procedure call.
   Don't clobber PV and RA.  */

static void
emit_division (const expressionS *tok,
	       int ntok,
	       const void * symname)
{
  /* DIVISION and MODULUS. Yech.

     Convert
        OP x,y,result
     to
        mov x,R16	# if x != R16
        mov y,R17	# if y != R17
        lda AT,__OP
        jsr AT,(AT),0
        mov R0,result

     with appropriate optimizations if R0,R16,R17 are the registers
     specified by the compiler.  */

  int xr, yr, rr;
  symbolS *sym;
  expressionS newtok[3];

  xr = regno (tok[0].X_add_number);
  yr = regno (tok[1].X_add_number);

  if (ntok < 3)
    rr = xr;
  else
    rr = regno (tok[2].X_add_number);

  /* Move the operands into the right place.  */
  if (yr == AXP_REG_R16 && xr == AXP_REG_R17)
    {
      /* They are in exactly the wrong order -- swap through AT.  */
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      set_tok_reg (newtok[0], AXP_REG_R16);
      set_tok_reg (newtok[1], AXP_REG_AT);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_R17);
      set_tok_reg (newtok[1], AXP_REG_R16);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_AT);
      set_tok_reg (newtok[1], AXP_REG_R17);
      assemble_tokens ("mov", newtok, 2, 1);
    }
  else
    {
      if (yr == AXP_REG_R16)
	{
	  set_tok_reg (newtok[0], AXP_REG_R16);
	  set_tok_reg (newtok[1], AXP_REG_R17);
	  assemble_tokens ("mov", newtok, 2, 1);
	}

      if (xr != AXP_REG_R16)
	{
	  set_tok_reg (newtok[0], xr);
	  set_tok_reg (newtok[1], AXP_REG_R16);
	  assemble_tokens ("mov", newtok, 2, 1);
	}

      if (yr != AXP_REG_R16 && yr != AXP_REG_R17)
	{
	  set_tok_reg (newtok[0], yr);
	  set_tok_reg (newtok[1], AXP_REG_R17);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
    }

  sym = symbol_find_or_make ((const char *) symname);

  set_tok_reg (newtok[0], AXP_REG_AT);
  set_tok_sym (newtok[1], sym, 0);
  assemble_tokens ("lda", newtok, 2, 1);

  /* Call the division routine.  */
  set_tok_reg (newtok[0], AXP_REG_AT);
  set_tok_cpreg (newtok[1], AXP_REG_AT);
  set_tok_const (newtok[2], 0);
  assemble_tokens ("jsr", newtok, 3, 1);

  /* Move the result to the right place.  */
  if (rr != AXP_REG_R0)
    {
      set_tok_reg (newtok[0], AXP_REG_R0);
      set_tok_reg (newtok[1], rr);
      assemble_tokens ("mov", newtok, 2, 1);
    }
}

#else /* !OBJ_EVAX */

static void
emit_division (const expressionS *tok,
	       int ntok,
	       const void * symname)
{
  /* DIVISION and MODULUS. Yech.
     Convert
        OP x,y,result
     to
        lda pv,__OP
        mov x,t10
        mov y,t11
        jsr t9,(pv),__OP
        mov t12,result

     with appropriate optimizations if t10,t11,t12 are the registers
     specified by the compiler.  */

  int xr, yr, rr;
  symbolS *sym;
  expressionS newtok[3];

  xr = regno (tok[0].X_add_number);
  yr = regno (tok[1].X_add_number);

  if (ntok < 3)
    rr = xr;
  else
    rr = regno (tok[2].X_add_number);

  sym = symbol_find_or_make ((const char *) symname);

  /* Move the operands into the right place.  */
  if (yr == AXP_REG_T10 && xr == AXP_REG_T11)
    {
      /* They are in exactly the wrong order -- swap through AT.  */
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      set_tok_reg (newtok[0], AXP_REG_T10);
      set_tok_reg (newtok[1], AXP_REG_AT);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_T11);
      set_tok_reg (newtok[1], AXP_REG_T10);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_AT);
      set_tok_reg (newtok[1], AXP_REG_T11);
      assemble_tokens ("mov", newtok, 2, 1);
    }
  else
    {
      if (yr == AXP_REG_T10)
	{
	  set_tok_reg (newtok[0], AXP_REG_T10);
	  set_tok_reg (newtok[1], AXP_REG_T11);
	  assemble_tokens ("mov", newtok, 2, 1);
	}

      if (xr != AXP_REG_T10)
	{
	  set_tok_reg (newtok[0], xr);
	  set_tok_reg (newtok[1], AXP_REG_T10);
	  assemble_tokens ("mov", newtok, 2, 1);
	}

      if (yr != AXP_REG_T10 && yr != AXP_REG_T11)
	{
	  set_tok_reg (newtok[0], yr);
	  set_tok_reg (newtok[1], AXP_REG_T11);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
    }

  /* Call the division routine.  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_sym (newtok[1], sym, 0);
  assemble_tokens ("jsr", newtok, 2, 1);

  /* Reload the GP register.  */
#ifdef OBJ_AOUT
FIXME
#endif
#if defined(OBJ_ECOFF) || defined(OBJ_ELF)
  set_tok_reg (newtok[0], alpha_gp_register);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_T9);
  assemble_tokens ("ldgp", newtok, 3, 1);
#endif

  /* Move the result to the right place.  */
  if (rr != AXP_REG_T12)
    {
      set_tok_reg (newtok[0], AXP_REG_T12);
      set_tok_reg (newtok[1], rr);
      assemble_tokens ("mov", newtok, 2, 1);
    }
}

#endif /* !OBJ_EVAX */

/* The jsr and jmp macros differ from their instruction counterparts
   in that they can load the target address and default most
   everything.  */

static void
emit_jsrjmp (const expressionS *tok,
	     int ntok,
	     const void * vopname)
{
  const char *opname = (const char *) vopname;
  struct alpha_insn insn;
  expressionS newtok[3];
  int r, tokidx = 0;
  long lituse = 0;

  if (tokidx < ntok && tok[tokidx].X_op == O_register)
    r = regno (tok[tokidx++].X_add_number);
  else
    r = strcmp (opname, "jmp") == 0 ? AXP_REG_ZERO : AXP_REG_RA;

  set_tok_reg (newtok[0], r);

  if (tokidx < ntok &&
      (tok[tokidx].X_op == O_pregister || tok[tokidx].X_op == O_cpregister))
    r = regno (tok[tokidx++].X_add_number);
#ifdef OBJ_EVAX
  /* Keep register if jsr $n.<sym>.  */
#else
  else
    {
      int basereg = alpha_gp_register;
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx],
				&basereg, NULL, opname);
    }
#endif

  set_tok_cpreg (newtok[1], r);

#ifndef OBJ_EVAX
  if (tokidx < ntok)
    newtok[2] = tok[tokidx];
  else
#endif
    set_tok_const (newtok[2], 0);

  assemble_tokens_to_insn (opname, newtok, 3, &insn);

  if (lituse)
    {
      gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_JSR;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
    }

#ifdef OBJ_EVAX
  if (alpha_flag_replace
      && r == AXP_REG_RA
      && tok[tokidx].X_add_symbol
      && alpha_linkage_symbol)
    {
      /* Create a BOH reloc for 'jsr $27,NAME'.  */
      const char *symname = S_GET_NAME (tok[tokidx].X_add_symbol);
      int symlen = strlen (symname);
      char *ensymname;

      /* Build the entry name as 'NAME..en'.  */
      ensymname = (char *) alloca (symlen + 5);
      memcpy (ensymname, symname, symlen);
      memcpy (ensymname + symlen, "..en", 5);

      gas_assert (insn.nfixups < MAX_INSN_FIXUPS);
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof(struct alpha_fixup) * insn.nfixups);
	}

      /* The fixup must be the same as the BFD_RELOC_ALPHA_NOP
	 case in load_expression.  See B.4.5.2 of the OpenVMS
	 Linker Utility Manual.  */
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_BOH;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = symbol_find_or_make (ensymname);
      insn.fixups[0].exp.X_add_number = 0;
      insn.fixups[0].xtrasym = alpha_linkage_symbol;
      insn.fixups[0].procsym = alpha_evax_proc->symbol;
      insn.nfixups++;
      alpha_linkage_symbol = 0;
    }
#endif

  emit_insn (&insn);
}

/* The ret and jcr instructions differ from their instruction
   counterparts in that everything can be defaulted.  */

static void
emit_retjcr (const expressionS *tok,
	     int ntok,
	     const void * vopname)
{
  const char *opname = (const char *) vopname;
  expressionS newtok[3];
  int r, tokidx = 0;

  if (tokidx < ntok && tok[tokidx].X_op == O_register)
    r = regno (tok[tokidx++].X_add_number);
  else
    r = AXP_REG_ZERO;

  set_tok_reg (newtok[0], r);

  if (tokidx < ntok &&
      (tok[tokidx].X_op == O_pregister || tok[tokidx].X_op == O_cpregister))
    r = regno (tok[tokidx++].X_add_number);
  else
    r = AXP_REG_RA;

  set_tok_cpreg (newtok[1], r);

  if (tokidx < ntok)
    newtok[2] = tok[tokidx];
  else
    set_tok_const (newtok[2], strcmp (opname, "ret") == 0);

  assemble_tokens (opname, newtok, 3, 0);
}

/* Implement the ldgp macro.  */

static void
emit_ldgp (const expressionS *tok ATTRIBUTE_UNUSED,
	   int ntok ATTRIBUTE_UNUSED,
	   const void * unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_AOUT
FIXME
#endif
#if defined(OBJ_ECOFF) || defined(OBJ_ELF)
  /* from "ldgp r1,n(r2)", generate "ldah r1,X(R2); lda r1,Y(r1)"
     with appropriate constants and relocations.  */
  struct alpha_insn insn;
  expressionS newtok[3];
  expressionS addend;

#ifdef OBJ_ECOFF
  if (regno (tok[2].X_add_number) == AXP_REG_PV)
    ecoff_set_gp_prolog_size (0);
#endif

  newtok[0] = tok[0];
  set_tok_const (newtok[1], 0);
  newtok[2] = tok[2];

  assemble_tokens_to_insn ("ldah", newtok, 3, &insn);

  addend = tok[1];

#ifdef OBJ_ECOFF
  if (addend.X_op != O_constant)
    as_bad (_("can not resolve expression"));
  addend.X_op = O_symbol;
  addend.X_add_symbol = alpha_gp_symbol;
#endif

  insn.nfixups = 1;
  insn.fixups[0].exp = addend;
  insn.fixups[0].reloc = BFD_RELOC_ALPHA_GPDISP_HI16;
  insn.sequence = next_sequence_num;

  emit_insn (&insn);

  set_tok_preg (newtok[2], tok[0].X_add_number);

  assemble_tokens_to_insn ("lda", newtok, 3, &insn);

#ifdef OBJ_ECOFF
  addend.X_add_number += 4;
#endif

  insn.nfixups = 1;
  insn.fixups[0].exp = addend;
  insn.fixups[0].reloc = BFD_RELOC_ALPHA_GPDISP_LO16;
  insn.sequence = next_sequence_num--;

  emit_insn (&insn);
#endif /* OBJ_ECOFF || OBJ_ELF */
}

/* The macro table.  */

static const struct alpha_macro alpha_macros[] =
{
/* Load/Store macros.  */
  { "lda",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldah",	emit_ldah, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "ldl",	emit_ir_load, "ldl",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldl_l",	emit_ir_load, "ldl_l",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq",	emit_ir_load, "ldq",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq_l",	emit_ir_load, "ldq_l",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq_u",	emit_ir_load, "ldq_u",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldf",	emit_loadstore, "ldf",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldg",	emit_loadstore, "ldg",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "lds",	emit_loadstore, "lds",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldt",	emit_loadstore, "ldt",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

  { "ldb",	emit_ldX, (void *) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldbu",	emit_ldXu, (void *) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldw",	emit_ldX, (void *) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldwu",	emit_ldXu, (void *) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

  { "uldw",	emit_uldX, (void *) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldwu",	emit_uldXu, (void *) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldl",	emit_uldX, (void *) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldlu",	emit_uldXu, (void *) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldq",	emit_uldXu, (void *) 3,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

  { "ldgp",	emit_ldgp, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA } },

  { "ldi",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldil",	emit_ldil, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldiq",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "stl",	emit_loadstore, "stl",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stl_c",	emit_loadstore, "stl_c",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq",	emit_loadstore, "stq",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq_c",	emit_loadstore, "stq_c",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq_u",	emit_loadstore, "stq_u",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stf",	emit_loadstore, "stf",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stg",	emit_loadstore, "stg",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "sts",	emit_loadstore, "sts",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stt",	emit_loadstore, "stt",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

  { "stb",	emit_stX, (void *) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stw",	emit_stX, (void *) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustw",	emit_ustX, (void *) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustl",	emit_ustX, (void *) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustq",	emit_ustX, (void *) 3,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

/* Arithmetic macros.  */

  { "sextb",	emit_sextX, (void *) 0,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },
  { "sextw",	emit_sextX, (void *) 1,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },

  { "divl",	emit_division, "__divl",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divlu",	emit_division, "__divlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divq",	emit_division, "__divq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divqu",	emit_division, "__divqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "reml",	emit_division, "__reml",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remlu",	emit_division, "__remlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remq",	emit_division, "__remq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remqu",	emit_division, "__remqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },

  { "jsr",	emit_jsrjmp, "jsr",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "jmp",	emit_jsrjmp, "jmp",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "ret",	emit_retjcr, "ret",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jcr",	emit_retjcr, "jcr",
    { MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_IR,  MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jsr_coroutine",	emit_retjcr, "jcr",
    { MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_IR,  MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
};

static const unsigned int alpha_num_macros
  = sizeof (alpha_macros) / sizeof (*alpha_macros);

/* Search forward through all variants of a macro looking for a syntax
   match.  */

static const struct alpha_macro *
find_macro_match (const struct alpha_macro *first_macro,
		  const expressionS *tok,
		  int *pntok)

{
  const struct alpha_macro *macro = first_macro;
  int ntok = *pntok;

  do
    {
      const enum alpha_macro_arg *arg = macro->argsets;
      int tokidx = 0;

      while (*arg)
	{
	  switch (*arg)
	    {
	    case MACRO_EOA:
	      if (tokidx == ntok)
		return macro;
	      else
		tokidx = 0;
	      break;

	      /* Index register.  */
	    case MACRO_IR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_register
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	      /* Parenthesized index register.  */
	    case MACRO_PIR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_pregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	      /* Optional parenthesized index register.  */
	    case MACRO_OPIR:
	      if (tokidx < ntok && tok[tokidx].X_op == O_pregister
		  && is_ir_num (tok[tokidx].X_add_number))
		++tokidx;
	      break;

	      /* Leading comma with a parenthesized index register.  */
	    case MACRO_CPIR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_cpregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	      /* Floating point register.  */
	    case MACRO_FPR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_register
		  || !is_fpr_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	      /* Normal expression.  */
	    case MACRO_EXP:
	      if (tokidx >= ntok)
		goto match_failed;
	      switch (tok[tokidx].X_op)
		{
		case O_illegal:
		case O_absent:
		case O_register:
		case O_pregister:
		case O_cpregister:
		case O_literal:
		case O_lituse_base:
		case O_lituse_bytoff:
		case O_lituse_jsr:
		case O_gpdisp:
		case O_gprelhigh:
		case O_gprellow:
		case O_gprel:
		case O_samegp:
		  goto match_failed;

		default:
		  break;
		}
	      ++tokidx;
	      break;

	    match_failed:
	      while (*arg != MACRO_EOA)
		++arg;
	      tokidx = 0;
	      break;
	    }
	  ++arg;
	}
    }
  while (++macro - alpha_macros < (int) alpha_num_macros
	 && !strcmp (macro->name, first_macro->name));

  return NULL;
}

/* Given an opcode name and a pre-tokenized set of arguments, take the
   opcode all the way through emission.  */

static void
assemble_tokens (const char *opname,
		 const expressionS *tok,
		 int ntok,
		 int local_macros_on)
{
  int found_something = 0;
  const struct alpha_opcode *opcode;
  const struct alpha_macro *macro;
  int cpumatch = 1;
  extended_bfd_reloc_code_real_type reloc = BFD_RELOC_UNUSED;

#ifdef RELOC_OP_P
  /* If a user-specified relocation is present, this is not a macro.  */
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      reloc = ALPHA_RELOC_TABLE (tok[ntok - 1].X_op)->reloc;
      ntok--;
    }
  else
#endif
  if (local_macros_on)
    {
      macro = ((const struct alpha_macro *)
	       hash_find (alpha_macro_hash, opname));
      if (macro)
	{
	  found_something = 1;
	  macro = find_macro_match (macro, tok, &ntok);
	  if (macro)
	    {
	      (*macro->emit) (tok, ntok, macro->arg);
	      return;
	    }
	}
    }

  /* Search opcodes.  */
  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
  if (opcode)
    {
      found_something = 1;
      opcode = find_opcode_match (opcode, tok, &ntok, &cpumatch);
      if (opcode)
	{
	  struct alpha_insn insn;
	  assemble_insn (opcode, tok, ntok, &insn, reloc);

	  /* Copy the sequence number for the reloc from the reloc token.  */
	  if (reloc != BFD_RELOC_UNUSED)
	    insn.sequence = tok[ntok].X_add_number;

	  emit_insn (&insn);
	  return;
	}
    }

  if (found_something)
    {
      if (cpumatch)
	as_bad (_("inappropriate arguments for opcode `%s'"), opname);
      else
	as_bad (_("opcode `%s' not supported for target %s"), opname,
		alpha_target_name);
    }
  else
    as_bad (_("unknown opcode `%s'"), opname);
}

#ifdef OBJ_EVAX

/* Add sym+addend to link pool.
   Return offset from curent procedure value (pv) to entry in link pool.

   Add new fixup only if offset isn't 16bit.  */

static symbolS *
add_to_link_pool (symbolS *sym, offsetT addend)
{
  symbolS *basesym;
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  char *p;
  segment_info_type *seginfo = seg_info (alpha_link_section);
  fixS *fixp;
  symbolS *linksym, *expsym;
  expressionS e;
  
  basesym = alpha_evax_proc->symbol;

  /* @@@@ This assumes all entries in a given section will be of the same
     size...  Probably correct, but unwise to rely on.  */
  /* This must always be called with the same subsegment.  */

  if (seginfo->frchainP)
    for (fixp = seginfo->frchainP->fix_root;
	 fixp != (fixS *) NULL;
	 fixp = fixp->fx_next)
      {
	if (fixp->fx_addsy == sym
	    && fixp->fx_offset == (valueT)addend
	    && fixp->tc_fix_data.info
	    && fixp->tc_fix_data.info->sym
	    && fixp->tc_fix_data.info->sym->sy_value.X_op_symbol == basesym)
	  return fixp->tc_fix_data.info->sym;
      }

  /* Not found, add a new entry.  */
  subseg_set (alpha_link_section, 0);
  linksym = symbol_new
    (FAKE_LABEL_NAME, now_seg, (valueT) frag_now_fix (), frag_now);
  p = frag_more (8);
  memset (p, 0, 8);

  /* Create a symbol for 'basesym - linksym' (offset of the added entry).  */
  e.X_op = O_subtract;
  e.X_add_symbol = linksym;
  e.X_op_symbol = basesym;
  e.X_add_number = 0;
  expsym = make_expr_symbol (&e);

  /* Create a fixup for the entry.  */
  fixp = fix_new
    (frag_now, p - frag_now->fr_literal, 8, sym, addend, 0, BFD_RELOC_64);
  fixp->tc_fix_data.info = get_alpha_reloc_tag (next_sequence_num--);
  fixp->tc_fix_data.info->sym = expsym;

  subseg_set (current_section, current_subsec);

  /* Return the symbol.  */
  return expsym;
}
#endif /* OBJ_EVAX */

/* Assembler directives.  */

/* Handle the .text pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_text (int i)
{
#ifdef OBJ_ELF
  obj_elf_text (i);
#else
  s_text (i);
#endif
#ifdef OBJ_EVAX
  {
    symbolS * symbolP;

    symbolP = symbol_find (".text");
    if (symbolP == NULL)
      {
	symbolP = symbol_make (".text");
	S_SET_SEGMENT (symbolP, text_section);
	symbol_table_insert (symbolP);
      }
  }
#endif
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

/* Handle the .data pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_data (int i)
{
#ifdef OBJ_ELF
  obj_elf_data (i);
#else
  s_data (i);
#endif
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)

/* Handle the OSF/1 and openVMS .comm pseudo quirks.  */

static void
s_alpha_comm (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char *p;
  offsetT size;
  symbolS *symbolP;
#ifdef OBJ_EVAX
  offsetT temp;
  int log_align = 0;
#endif

  name = input_line_pointer;
  c = get_symbol_end ();

  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;

  SKIP_WHITESPACE ();

  /* Alpha OSF/1 compiler doesn't provide the comma, gcc does.  */
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }
  if ((size = get_absolute_expression ()) < 0)
    {
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) size);
      ignore_rest_of_line ();
      return;
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }

#ifdef OBJ_EVAX
  if (*input_line_pointer != ',')
    temp = 8; /* Default alignment.  */
  else
    {
      input_line_pointer++;
      SKIP_WHITESPACE ();
      temp = get_absolute_expression ();
    }

  /* ??? Unlike on OSF/1, the alignment factor is not in log units.  */
  while ((temp >>= 1) != 0)
    ++log_align;

  if (*input_line_pointer == ',')
    {
      /* Extended form of the directive

	   .comm symbol, size, alignment, section

         where the "common" semantics is transferred to the section.
         The symbol is effectively an alias for the section name.  */

      segT sec;
      char *sec_name;
      symbolS *sec_symbol;
      segT current_seg = now_seg;
      subsegT current_subseg = now_subseg;
      int cur_size;
      
      input_line_pointer++;
      SKIP_WHITESPACE ();
      sec_name = s_alpha_section_name ();
      sec_symbol = symbol_find_or_make (sec_name);
      sec = subseg_new (sec_name, 0);
      S_SET_SEGMENT (sec_symbol, sec);
      symbol_get_bfdsym (sec_symbol)->flags |= BSF_SECTION_SYM;
      bfd_vms_set_section_flags (stdoutput, sec, 0,
				 EGPS__V_OVR | EGPS__V_GBL | EGPS__V_NOMOD);
      record_alignment (sec, log_align);

      /* Reuse stab_string_size to store the size of the section.  */
      cur_size = seg_info (sec)->stabu.stab_string_size;
      if ((int) size > cur_size)
	{
	  char *pfrag
	    = frag_var (rs_fill, 1, 1, (relax_substateT)0, NULL,
			(valueT)size - (valueT)cur_size, NULL);
	  *pfrag = 0;
	  seg_info (sec)->stabu.stab_string_size = (int)size;
	}

      S_SET_SEGMENT (symbolP, sec);

      subseg_set (current_seg, current_subseg);
    }
  else
    {
      /* Regular form of the directive

	   .comm symbol, size, alignment

	 where the "common" semantics in on the symbol.
	 These symbols are assembled in the .bss section.  */

      char *pfrag;
      segT current_seg = now_seg;
      subsegT current_subseg = now_subseg;

      subseg_set (bss_section, 1);
      frag_align (log_align, 0, 0);
      record_alignment (bss_section, log_align);

      symbol_set_frag (symbolP, frag_now);
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
                        size, NULL);
      *pfrag = 0;

      S_SET_SEGMENT (symbolP, bss_section);

      subseg_set (current_seg, current_subseg);
    }
#endif
  
  if (S_GET_VALUE (symbolP))
    {
      if (S_GET_VALUE (symbolP) != (valueT) size)
        as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
                S_GET_NAME (symbolP),
                (long) S_GET_VALUE (symbolP),
                (long) size);
    }
  else
    {
#ifndef OBJ_EVAX
      S_SET_VALUE (symbolP, (valueT) size);
#endif
      S_SET_EXTERNAL (symbolP);
    }
  
#ifndef OBJ_EVAX
  know (symbolP->sy_frag == &zero_address_frag);
#endif
  demand_empty_rest_of_line ();
}

#endif /* ! OBJ_ELF */

#ifdef OBJ_ECOFF

/* Handle the .rdata pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_rdata (int ignore ATTRIBUTE_UNUSED)
{
  get_absolute_expression ();
  subseg_new (".rdata", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

#endif

#ifdef OBJ_ECOFF

/* Handle the .sdata pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_sdata (int ignore ATTRIBUTE_UNUSED)
{
  get_absolute_expression ();
  subseg_new (".sdata", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}
#endif

#ifdef OBJ_ELF
struct alpha_elf_frame_data
{
  symbolS *func_sym;
  symbolS *func_end_sym;
  symbolS *prologue_sym;
  unsigned int mask;
  unsigned int fmask;
  int fp_regno;
  int ra_regno;
  offsetT frame_size;
  offsetT mask_offset;
  offsetT fmask_offset;

  struct alpha_elf_frame_data *next;
};

static struct alpha_elf_frame_data *all_frame_data;
static struct alpha_elf_frame_data **plast_frame_data = &all_frame_data;
static struct alpha_elf_frame_data *cur_frame_data;

/* Handle the .section pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_section (int ignore ATTRIBUTE_UNUSED)
{
  obj_elf_section (ignore);

  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

static void
s_alpha_ent (int dummy ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_ent (0);
  else
    {
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();

      if (! is_name_beginner (*name))
	{
	  as_warn (_(".ent directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;

	  if (cur_frame_data)
	    as_warn (_("nested .ent directives"));

	  sym = symbol_find_or_make (name);
	  symbol_get_bfdsym (sym)->flags |= BSF_FUNCTION;

	  cur_frame_data = (struct alpha_elf_frame_data *)
              calloc (1, sizeof (*cur_frame_data));
	  cur_frame_data->func_sym = sym;

	  /* Provide sensible defaults.  */
	  cur_frame_data->fp_regno = 30;	/* sp */
	  cur_frame_data->ra_regno = 26;	/* ra */

	  *plast_frame_data = cur_frame_data;
	  plast_frame_data = &cur_frame_data->next;

	  /* The .ent directive is sometimes followed by a number.  Not sure
	     what it really means, but ignore it.  */
	  *input_line_pointer = name_end;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      input_line_pointer++;
	      SKIP_WHITESPACE ();
	    }
	  if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')
	    (void) get_absolute_expression ();
	}
      demand_empty_rest_of_line ();
    }
}

static void
s_alpha_end (int dummy ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_end (0);
  else
    {
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();

      if (! is_name_beginner (*name))
	{
	  as_warn (_(".end directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;

	  sym = symbol_find (name);
	  if (!cur_frame_data)
	    as_warn (_(".end directive without matching .ent"));
	  else if (sym != cur_frame_data->func_sym)
	    as_warn (_(".end directive names different symbol than .ent"));

	  /* Create an expression to calculate the size of the function.  */
	  if (sym && cur_frame_data)
	    {
	      OBJ_SYMFIELD_TYPE *obj = symbol_get_obj (sym);
	      expressionS *exp = (expressionS *) xmalloc (sizeof (expressionS));

	      obj->size = exp;
	      exp->X_op = O_subtract;
	      exp->X_add_symbol = symbol_temp_new_now ();
	      exp->X_op_symbol = sym;
	      exp->X_add_number = 0;

	      cur_frame_data->func_end_sym = exp->X_add_symbol;
	    }

	  cur_frame_data = NULL;

	  *input_line_pointer = name_end;
	}
      demand_empty_rest_of_line ();
    }
}

static void
s_alpha_mask (int fp)
{
  if (ECOFF_DEBUGGING)
    {
      if (fp)
	ecoff_directive_fmask (0);
      else
	ecoff_directive_mask (0);
    }
  else
    {
      long val;
      offsetT offset;

      if (!cur_frame_data)
	{
	  if (fp)
	    as_warn (_(".fmask outside of .ent"));
	  else
	    as_warn (_(".mask outside of .ent"));
	  discard_rest_of_line ();
	  return;
	}

      if (get_absolute_expression_and_terminator (&val) != ',')
	{
	  if (fp)
	    as_warn (_("bad .fmask directive"));
	  else
	    as_warn (_("bad .mask directive"));
	  --input_line_pointer;
	  discard_rest_of_line ();
	  return;
	}

      offset = get_absolute_expression ();
      demand_empty_rest_of_line ();

      if (fp)
	{
	  cur_frame_data->fmask = val;
          cur_frame_data->fmask_offset = offset;
	}
      else
	{
	  cur_frame_data->mask = val;
	  cur_frame_data->mask_offset = offset;
	}
    }
}

static void
s_alpha_frame (int dummy ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_frame (0);
  else
    {
      long val;

      if (!cur_frame_data)
	{
	  as_warn (_(".frame outside of .ent"));
	  discard_rest_of_line ();
	  return;
	}

      cur_frame_data->fp_regno = tc_get_register (1);

      SKIP_WHITESPACE ();
      if (*input_line_pointer++ != ','
	  || get_absolute_expression_and_terminator (&val) != ',')
	{
	  as_warn (_("bad .frame directive"));
	  --input_line_pointer;
	  discard_rest_of_line ();
	  return;
	}
      cur_frame_data->frame_size = val;

      cur_frame_data->ra_regno = tc_get_register (0);

      /* Next comes the "offset of saved $a0 from $sp".  In gcc terms
	 this is current_function_pretend_args_size.  There's no place
	 to put this value, so ignore it.  */
      s_ignore (42);
    }
}

static void
s_alpha_prologue (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym;
  int arg;

  arg = get_absolute_expression ();
  demand_empty_rest_of_line ();
  alpha_prologue_label = symbol_new
    (FAKE_LABEL_NAME, now_seg, (valueT) frag_now_fix (), frag_now);

  if (ECOFF_DEBUGGING)
    sym = ecoff_get_cur_proc_sym ();
  else
    sym = cur_frame_data ? cur_frame_data->func_sym : NULL;

  if (sym == NULL)
    {
      as_bad (_(".prologue directive without a preceding .ent directive"));
      return;
    }

  switch (arg)
    {
    case 0: /* No PV required.  */
      S_SET_OTHER (sym, STO_ALPHA_NOPV
		   | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
      break;
    case 1: /* Std GP load.  */
      S_SET_OTHER (sym, STO_ALPHA_STD_GPLOAD
		   | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
      break;
    case 2: /* Non-std use of PV.  */
      break;

    default:
      as_bad (_("Invalid argument %d to .prologue."), arg);
      break;
    }

  if (cur_frame_data)
    cur_frame_data->prologue_sym = symbol_temp_new_now ();
}

static char *first_file_directive;

static void
s_alpha_file (int ignore ATTRIBUTE_UNUSED)
{
  /* Save the first .file directive we see, so that we can change our
     minds about whether ecoff debugging should or shouldn't be enabled.  */
  if (alpha_flag_mdebug < 0 && ! first_file_directive)
    {
      char *start = input_line_pointer;
      size_t len;

      discard_rest_of_line ();

      len = input_line_pointer - start;
      first_file_directive = (char *) xmalloc (len + 1);
      memcpy (first_file_directive, start, len);
      first_file_directive[len] = '\0';

      input_line_pointer = start;
    }

  if (ECOFF_DEBUGGING)
    ecoff_directive_file (0);
  else
    dwarf2_directive_file (0);
}

static void
s_alpha_loc (int ignore ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_loc (0);
  else
    dwarf2_directive_loc (0);
}

static void
s_alpha_stab (int n)
{
  /* If we've been undecided about mdebug, make up our minds in favour.  */
  if (alpha_flag_mdebug < 0)
    {
      segT sec = subseg_new (".mdebug", 0);
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);
      bfd_set_section_alignment (stdoutput, sec, 3);

      ecoff_read_begin_hook ();

      if (first_file_directive)
	{
	  char *save_ilp = input_line_pointer;
	  input_line_pointer = first_file_directive;
	  ecoff_directive_file (0);
	  input_line_pointer = save_ilp;
	  free (first_file_directive);
	}

      alpha_flag_mdebug = 1;
    }
  s_stab (n);
}

static void
s_alpha_coff_wrapper (int which)
{
  static void (* const fns[]) (int) = {
    ecoff_directive_begin,
    ecoff_directive_bend,
    ecoff_directive_def,
    ecoff_directive_dim,
    ecoff_directive_endef,
    ecoff_directive_scl,
    ecoff_directive_tag,
    ecoff_directive_val,
  };

  gas_assert (which >= 0 && which < (int) (sizeof (fns)/sizeof (*fns)));

  if (ECOFF_DEBUGGING)
    (*fns[which]) (0);
  else
    {
      as_bad (_("ECOFF debugging is disabled."));
      ignore_rest_of_line ();
    }
}

/* Called at the end of assembly.  Here we emit unwind info for frames
   unless the compiler has done it for us.  */

void
alpha_elf_md_end (void)
{
  struct alpha_elf_frame_data *p;

  if (cur_frame_data)
    as_warn (_(".ent directive without matching .end"));

  /* If someone has generated the unwind info themselves, great.  */
  if (bfd_get_section_by_name (stdoutput, ".eh_frame") != NULL)
    return;

  /* ??? In theory we could look for functions for which we have
     generated unwind info via CFI directives, and those we have not.
     Those we have not could still get their unwind info from here.
     For now, do nothing if we've seen any CFI directives.  Note that
     the above test will not trigger, as we've not emitted data yet.  */
  if (all_fde_data != NULL)
    return;

  /* Generate .eh_frame data for the unwind directives specified.  */
  for (p = all_frame_data; p ; p = p->next)
    if (p->prologue_sym)
      {
	/* Create a temporary symbol at the same location as our
	   function symbol.  This prevents problems with globals.  */
	cfi_new_fde (symbol_temp_new (S_GET_SEGMENT (p->func_sym),
				      S_GET_VALUE (p->func_sym),
				      symbol_get_frag (p->func_sym)));

	cfi_set_return_column (p->ra_regno);
	cfi_add_CFA_def_cfa_register (30);
	if (p->fp_regno != 30 || p->mask || p->fmask || p->frame_size)
	  {
	    unsigned int mask;
	    offsetT offset;

	    cfi_add_advance_loc (p->prologue_sym);

	    if (p->fp_regno != 30)
	      if (p->frame_size != 0)
		cfi_add_CFA_def_cfa (p->fp_regno, p->frame_size);
	      else
		cfi_add_CFA_def_cfa_register (p->fp_regno);
	    else if (p->frame_size != 0)
	      cfi_add_CFA_def_cfa_offset (p->frame_size);

	    mask = p->mask;
	    offset = p->mask_offset;

	    /* Recall that $26 is special-cased and stored first.  */
	    if ((mask >> 26) & 1)
	      {
	        cfi_add_CFA_offset (26, offset);
		offset += 8;
		mask &= ~(1 << 26);
	      }
	    while (mask)
	      {
		unsigned int i;
		i = mask & -mask;
		mask ^= i;
		i = ffs (i) - 1;

		cfi_add_CFA_offset (i, offset);
		offset += 8;
	      }

	    mask = p->fmask;
	    offset = p->fmask_offset;
	    while (mask)
	      {
		unsigned int i;
		i = mask & -mask;
		mask ^= i;
		i = ffs (i) - 1;

		cfi_add_CFA_offset (i + 32, offset);
		offset += 8;
	      }
	  }

	cfi_end_fde (p->func_end_sym);
      }
}

static void
s_alpha_usepv (int unused ATTRIBUTE_UNUSED)
{
  char *name, name_end;
  char *which, which_end;
  symbolS *sym;
  int other;

  name = input_line_pointer;
  name_end = get_symbol_end ();

  if (! is_name_beginner (*name))
    {
      as_bad (_(".usepv directive has no name"));
      *input_line_pointer = name_end;
      ignore_rest_of_line ();
      return;
    }

  sym = symbol_find_or_make (name);
  *input_line_pointer++ = name_end;

  if (name_end != ',')
    {
      as_bad (_(".usepv directive has no type"));
      ignore_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
  which = input_line_pointer;
  which_end = get_symbol_end ();

  if (strcmp (which, "no") == 0)
    other = STO_ALPHA_NOPV;
  else if (strcmp (which, "std") == 0)
    other = STO_ALPHA_STD_GPLOAD;
  else
    {
      as_bad (_("unknown argument for .usepv"));
      other = 0;
    }

  *input_line_pointer = which_end;
  demand_empty_rest_of_line ();

  S_SET_OTHER (sym, other | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
}
#endif /* OBJ_ELF */

/* Standard calling conventions leaves the CFA at $30 on entry.  */

void
alpha_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa_register (30);
}

#ifdef OBJ_EVAX

/* Get name of section.  */
static char *
s_alpha_section_name (void)
{
  char *name;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      int dummy;

      name = demand_copy_C_string (&dummy);
      if (name == NULL)
	{
	  ignore_rest_of_line ();
	  return NULL;
	}
    }
  else
    {
      char *end = input_line_pointer;

      while (0 == strchr ("\n\t,; ", *end))
	end++;
      if (end == input_line_pointer)
	{
	  as_warn (_("missing name"));
	  ignore_rest_of_line ();
	  return NULL;
	}

      name = xmalloc (end - input_line_pointer + 1);
      memcpy (name, input_line_pointer, end - input_line_pointer);
      name[end - input_line_pointer] = '\0';
      input_line_pointer = end;
    }
  SKIP_WHITESPACE ();
  return name;
}

/* Put clear/set flags in one flagword.  The LSBs are flags to be set,
   the MSBs are the flags to be cleared.  */

#define EGPS__V_NO_SHIFT 16
#define EGPS__V_MASK	 0xffff

/* Parse one VMS section flag.  */

static flagword
s_alpha_section_word (char *str, size_t len)
{
  int no = 0;
  flagword flag = 0;

  if (len == 5 && strncmp (str, "NO", 2) == 0)
    {
      no = 1;
      str += 2;
      len -= 2; 
    }

  if (len == 3)
    {
      if (strncmp (str, "PIC", 3) == 0)
	flag = EGPS__V_PIC;
      else if (strncmp (str, "LIB", 3) == 0)
	flag = EGPS__V_LIB;
      else if (strncmp (str, "OVR", 3) == 0)
	flag = EGPS__V_OVR;
      else if (strncmp (str, "REL", 3) == 0)
	flag = EGPS__V_REL;
      else if (strncmp (str, "GBL", 3) == 0)
	flag = EGPS__V_GBL;
      else if (strncmp (str, "SHR", 3) == 0)
	flag = EGPS__V_SHR;
      else if (strncmp (str, "EXE", 3) == 0)
	flag = EGPS__V_EXE;
      else if (strncmp (str, "WRT", 3) == 0)
	flag = EGPS__V_WRT;
      else if (strncmp (str, "VEC", 3) == 0)
	flag = EGPS__V_VEC;
      else if (strncmp (str, "MOD", 3) == 0)
	{
	  flag = no ? EGPS__V_NOMOD : EGPS__V_NOMOD << EGPS__V_NO_SHIFT;
	  no = 0;
	}
      else if (strncmp (str, "COM", 3) == 0)
	flag = EGPS__V_COM;
    }

  if (flag == 0)
    {
      char c = str[len];
      str[len] = 0;
      as_warn (_("unknown section attribute %s"), str);
      str[len] = c;
      return 0;
    }

  if (no)
    return flag << EGPS__V_NO_SHIFT;
  else
    return flag;
}

/* Handle the section specific pseudo-op.  */

#define EVAX_SECTION_COUNT 5

static char *section_name[EVAX_SECTION_COUNT + 1] =
  { "NULL", ".rdata", ".comm", ".link", ".ctors", ".dtors" };

static void
s_alpha_section (int secid)
{
  char *name, *beg;
  segT sec;
  flagword vms_flags = 0;
  symbolS *symbol;

  if (secid == 0)
    {
      name = s_alpha_section_name ();
      if (name == NULL)
        return;
      sec = subseg_new (name, 0);
      if (*input_line_pointer == ',')
        {
          /* Skip the comma.  */
          ++input_line_pointer;
          SKIP_WHITESPACE ();

     	  do
     	    {
     	      char c;

     	      SKIP_WHITESPACE ();
     	      beg = input_line_pointer;
     	      c = get_symbol_end ();
     	      *input_line_pointer = c;

     	      vms_flags |= s_alpha_section_word (beg, input_line_pointer - beg);

     	      SKIP_WHITESPACE ();
     	    }
     	  while (*input_line_pointer++ == ',');
     	  --input_line_pointer;
        }

	symbol = symbol_find_or_make (name);
	S_SET_SEGMENT (symbol, sec);
	symbol_get_bfdsym (symbol)->flags |= BSF_SECTION_SYM;
        bfd_vms_set_section_flags
          (stdoutput, sec,
           (vms_flags >> EGPS__V_NO_SHIFT) & EGPS__V_MASK,
           vms_flags & EGPS__V_MASK);
    }
  else
    {
      get_absolute_expression ();
      subseg_new (section_name[secid], 0);
    }

  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

static void
s_alpha_literals (int ignore ATTRIBUTE_UNUSED)
{
  subseg_new (".literals", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

/* Parse .ent directives.  */

static void
s_alpha_ent (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbol;
  expressionS symexpr;

  if (alpha_evax_proc != NULL)
    as_bad (_("previous .ent not closed by a .end"));

  alpha_evax_proc = &alpha_evax_proc_data;

  alpha_evax_proc->pdsckind = 0;
  alpha_evax_proc->framereg = -1;
  alpha_evax_proc->framesize = 0;
  alpha_evax_proc->rsa_offset = 0;
  alpha_evax_proc->ra_save = AXP_REG_RA;
  alpha_evax_proc->fp_save = -1;
  alpha_evax_proc->imask = 0;
  alpha_evax_proc->fmask = 0;
  alpha_evax_proc->prologue = 0;
  alpha_evax_proc->type = 0;
  alpha_evax_proc->handler = 0;
  alpha_evax_proc->handler_data = 0;

  expression (&symexpr);

  if (symexpr.X_op != O_symbol)
    {
      as_fatal (_(".ent directive has no symbol"));
      demand_empty_rest_of_line ();
      return;
    }

  symbol = make_expr_symbol (&symexpr);
  symbol_get_bfdsym (symbol)->flags |= BSF_FUNCTION;
  alpha_evax_proc->symbol = symbol;

  demand_empty_rest_of_line ();
}

static void
s_alpha_handler (int is_data)
{
  if (is_data)
    alpha_evax_proc->handler_data = get_absolute_expression ();
  else
    {
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();

      if (! is_name_beginner (*name))
	{
	  as_warn (_(".handler directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;

	  sym = symbol_find_or_make (name);
	  symbol_get_bfdsym (sym)->flags |= BSF_FUNCTION;
	  alpha_evax_proc->handler = sym;
	  *input_line_pointer = name_end;
	}
      }
  demand_empty_rest_of_line ();
}

/* Parse .frame <framreg>,<framesize>,RA,<rsa_offset> directives.  */

static void
s_alpha_frame (int ignore ATTRIBUTE_UNUSED)
{
  long val;
  int ra;

  alpha_evax_proc->framereg = tc_get_register (1);

  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ','
      || get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .frame directive 1./2. param"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }

  alpha_evax_proc->framesize = val;

  ra = tc_get_register (1);
  if (ra != AXP_REG_RA)
    as_warn (_("Bad RA (%d) register for .frame"), ra);

  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ',')
    {
      as_warn (_("Bad .frame directive 3./4. param"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  alpha_evax_proc->rsa_offset = get_absolute_expression ();
}

/* Parse .prologue.  */

static void
s_alpha_prologue (int ignore ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  alpha_prologue_label = symbol_new
    (FAKE_LABEL_NAME, now_seg, (valueT) frag_now_fix (), frag_now);
}

/* Parse .pdesc <entry_name>,{null|stack|reg}
   Insert a procedure descriptor.  */

static void
s_alpha_pdesc (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char name_end;
  register char *p;
  expressionS exp;
  symbolS *entry_sym;
  const char *entry_sym_name;
  const char *pdesc_sym_name;
  fixS *fixp;
  size_t len;

  if (now_seg != alpha_link_section)
    {
      as_bad (_(".pdesc directive not in link (.link) section"));
      return;
    }

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_bad (_(".pdesc directive has no entry symbol"));
      return;
    }
  
  entry_sym = make_expr_symbol (&exp);
  entry_sym_name = S_GET_NAME (entry_sym);
 
  /* Strip "..en".  */
  len = strlen (entry_sym_name);
  if (len < 4 || strcmp (entry_sym_name + len - 4, "..en") != 0)
    {
      as_bad (_(".pdesc has a bad entry symbol"));
      return;
    }
  len -= 4;
  pdesc_sym_name = S_GET_NAME (alpha_evax_proc->symbol);

  if (!alpha_evax_proc
      || !S_IS_DEFINED (alpha_evax_proc->symbol)
      || strlen (pdesc_sym_name) != len
      || memcmp (entry_sym_name, pdesc_sym_name, len) != 0)
    {
      as_fatal (_(".pdesc doesn't match with last .ent"));
      return;
    }

  /* Define pdesc symbol.  */
  symbol_set_value_now (alpha_evax_proc->symbol);
 
  /* Save bfd symbol of proc entry in function symbol.  */
  ((struct evax_private_udata_struct *)
     symbol_get_bfdsym (alpha_evax_proc->symbol)->udata.p)->enbsym
       = symbol_get_bfdsym (entry_sym);
  
  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ',')
    {
      as_warn (_("No comma after .pdesc <entryname>"));
      demand_empty_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  name_end = get_symbol_end ();

  if (strncmp (name, "stack", 5) == 0)
    alpha_evax_proc->pdsckind = PDSC_S_K_KIND_FP_STACK;

  else if (strncmp (name, "reg", 3) == 0)
    alpha_evax_proc->pdsckind = PDSC_S_K_KIND_FP_REGISTER;

  else if (strncmp (name, "null", 4) == 0)
    alpha_evax_proc->pdsckind = PDSC_S_K_KIND_NULL;

  else
    {
      as_fatal (_("unknown procedure kind"));
      demand_empty_rest_of_line ();
      return;
    }

  *input_line_pointer = name_end;
  demand_empty_rest_of_line ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  frag_align (3, 0, 0);
  p = frag_more (16);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;

  *p = alpha_evax_proc->pdsckind
    | ((alpha_evax_proc->framereg == 29) ? PDSC_S_M_BASE_REG_IS_FP : 0)
    | ((alpha_evax_proc->handler) ? PDSC_S_M_HANDLER_VALID : 0)
    | ((alpha_evax_proc->handler_data) ? PDSC_S_M_HANDLER_DATA_VALID : 0);
  *(p + 1) = PDSC_S_M_NATIVE | PDSC_S_M_NO_JACKET;

  switch (alpha_evax_proc->pdsckind)
    {
    case PDSC_S_K_KIND_NULL:
      *(p + 2) = 0;
      *(p + 3) = 0;
      break;
    case PDSC_S_K_KIND_FP_REGISTER:
      *(p + 2) = alpha_evax_proc->fp_save;
      *(p + 3) = alpha_evax_proc->ra_save;
      break;
    case PDSC_S_K_KIND_FP_STACK:
      md_number_to_chars (p + 2, (valueT) alpha_evax_proc->rsa_offset, 2);
      break;
    default:		/* impossible */
      break;
    }

  *(p + 4) = 0;
  *(p + 5) = alpha_evax_proc->type & 0x0f;

  /* Signature offset.  */
  md_number_to_chars (p + 6, (valueT) 0, 2);

  fix_new_exp (frag_now, p - frag_now->fr_literal + 8,
               8, &exp, 0, BFD_RELOC_64);

  if (alpha_evax_proc->pdsckind == PDSC_S_K_KIND_NULL)
    return;

  /* pdesc+16: Size.  */
  p = frag_more (6);
  md_number_to_chars (p, (valueT) alpha_evax_proc->framesize, 4);
  md_number_to_chars (p + 4, (valueT) 0, 2);

  /* Entry length.  */
  exp.X_op = O_subtract;
  exp.X_add_symbol = alpha_prologue_label;
  exp.X_op_symbol = entry_sym;
  emit_expr (&exp, 2);

  if (alpha_evax_proc->pdsckind == PDSC_S_K_KIND_FP_REGISTER)
    return;

  /* pdesc+24: register masks.  */
  p = frag_more (8);
  md_number_to_chars (p, alpha_evax_proc->imask, 4);
  md_number_to_chars (p + 4, alpha_evax_proc->fmask, 4);

  if (alpha_evax_proc->handler)
    {
      p = frag_more (8);
      fixp = fix_new (frag_now, p - frag_now->fr_literal, 8,
	              alpha_evax_proc->handler, 0, 0, BFD_RELOC_64);
    }

  if (alpha_evax_proc->handler_data)
    {
      p = frag_more (8);
      md_number_to_chars (p, alpha_evax_proc->handler_data, 8);
    }
}

/* Support for crash debug on vms.  */

static void
s_alpha_name (int ignore ATTRIBUTE_UNUSED)
{
  char *p;
  expressionS exp;

  if (now_seg != alpha_link_section)
    {
      as_bad (_(".name directive not in link (.link) section"));
      demand_empty_rest_of_line ();
      return;
    }

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_warn (_(".name directive has no symbol"));
      demand_empty_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  frag_align (3, 0, 0);
  p = frag_more (8);

  fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &exp, 0, BFD_RELOC_64);
}

/* Parse .linkage <symbol>.
   Create a linkage pair relocation.  */

static void
s_alpha_linkage (int ignore ATTRIBUTE_UNUSED)
{
  expressionS exp;
  char *p;
  fixS *fixp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_fatal (_("No symbol after .linkage"));
    }
  else
    {
      struct alpha_linkage_fixups *linkage_fixup;
      
      p = frag_more (LKP_S_K_SIZE);
      memset (p, 0, LKP_S_K_SIZE);
      fixp = fix_new_exp
	(frag_now, p - frag_now->fr_literal, LKP_S_K_SIZE, &exp, 0,
	 BFD_RELOC_ALPHA_LINKAGE);

      if (alpha_insn_label == NULL)
	alpha_insn_label = symbol_new
	  (FAKE_LABEL_NAME, now_seg, (valueT) frag_now_fix (), frag_now);

      /* Create a linkage element.  */
      linkage_fixup = (struct alpha_linkage_fixups *)
	xmalloc (sizeof (struct alpha_linkage_fixups));
      linkage_fixup->fixp = fixp;
      linkage_fixup->next = NULL;
      linkage_fixup->label = alpha_insn_label;

      /* Append it to the list.  */
      if (alpha_linkage_fixup_root == NULL)
        alpha_linkage_fixup_root = linkage_fixup;
      else
        alpha_linkage_fixup_tail->next = linkage_fixup;
      alpha_linkage_fixup_tail = linkage_fixup;
    }
  demand_empty_rest_of_line ();
}

/* Parse .code_address <symbol>.
   Create a code address relocation.  */

static void
s_alpha_code_address (int ignore ATTRIBUTE_UNUSED)
{
  expressionS exp;
  char *p;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  expression (&exp);
  if (exp.X_op != O_symbol)
    as_fatal (_("No symbol after .code_address"));
  else
    {
      p = frag_more (8);
      memset (p, 0, 8);
      fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &exp, 0,\
		   BFD_RELOC_ALPHA_CODEADDR);
    }
  demand_empty_rest_of_line ();
}

static void
s_alpha_fp_save (int ignore ATTRIBUTE_UNUSED)
{
  alpha_evax_proc->fp_save = tc_get_register (1);

  demand_empty_rest_of_line ();
}

static void
s_alpha_mask (int ignore ATTRIBUTE_UNUSED)
{
  long val;

  if (get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .mask directive"));
      --input_line_pointer;
    }
  else
    {
      alpha_evax_proc->imask = val;
      (void) get_absolute_expression ();
    }
  demand_empty_rest_of_line ();
}

static void
s_alpha_fmask (int ignore ATTRIBUTE_UNUSED)
{
  long val;

  if (get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .fmask directive"));
      --input_line_pointer;
    }
  else
    {
      alpha_evax_proc->fmask = val;
      (void) get_absolute_expression ();
    }
  demand_empty_rest_of_line ();
}

static void
s_alpha_end (int ignore ATTRIBUTE_UNUSED)
{
  char c;

  c = get_symbol_end ();
  *input_line_pointer = c;
  demand_empty_rest_of_line ();
  alpha_evax_proc = NULL;
}

static void
s_alpha_file (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *s;
  int length;
  static char case_hack[32];

  sprintf (case_hack, "<CASE:%01d%01d>",
	   alpha_flag_hash_long_names, alpha_flag_show_after_trunc);

  s = symbol_find_or_make (case_hack);
  symbol_get_bfdsym (s)->flags |= BSF_FILE;

  get_absolute_expression ();
  s = symbol_find_or_make (demand_copy_string (&length));
  symbol_get_bfdsym (s)->flags |= BSF_FILE;
  demand_empty_rest_of_line ();
}
#endif /* OBJ_EVAX  */

/* Handle the .gprel32 pseudo op.  */

static void
s_alpha_gprel32 (int ignore ATTRIBUTE_UNUSED)
{
  expressionS e;
  char *p;

  SKIP_WHITESPACE ();
  expression (&e);

#ifdef OBJ_ELF
  switch (e.X_op)
    {
    case O_constant:
      e.X_add_symbol = section_symbol (absolute_section);
      e.X_op = O_symbol;
      /* FALLTHRU */
    case O_symbol:
      break;
    default:
      abort ();
    }
#else
#ifdef OBJ_ECOFF
  switch (e.X_op)
    {
    case O_constant:
      e.X_add_symbol = section_symbol (absolute_section);
      /* fall through */
    case O_symbol:
      e.X_op = O_subtract;
      e.X_op_symbol = alpha_gp_symbol;
      break;
    default:
      abort ();
    }
#endif
#endif

  if (alpha_auto_align_on && alpha_current_align < 2)
    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > 2)
    alpha_current_align = 2;
  alpha_insn_label = NULL;

  p = frag_more (4);
  memset (p, 0, 4);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
	       &e, 0, BFD_RELOC_GPREL32);
}

/* Handle floating point allocation pseudo-ops.  This is like the
   generic vresion, but it makes sure the current label, if any, is
   correctly aligned.  */

static void
s_alpha_float_cons (int type)
{
  int log_size;

  switch (type)
    {
    default:
    case 'f':
    case 'F':
      log_size = 2;
      break;

    case 'd':
    case 'D':
    case 'G':
      log_size = 3;
      break;

    case 'x':
    case 'X':
    case 'p':
    case 'P':
      log_size = 4;
      break;
    }

  if (alpha_auto_align_on && alpha_current_align < log_size)
    alpha_align (log_size, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > log_size)
    alpha_current_align = log_size;
  alpha_insn_label = NULL;

  float_cons (type);
}

/* Handle the .proc pseudo op.  We don't really do much with it except
   parse it.  */

static void
s_alpha_proc (int is_static ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char *p;
  symbolS *symbolP;
  int temp;

  /* Takes ".proc name,nargs".  */
  SKIP_WHITESPACE ();
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  symbolP = symbol_find_or_make (name);
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      *p = 0;
      as_warn (_("Expected comma after name \"%s\""), name);
      *p = c;
      temp = 0;
      ignore_rest_of_line ();
    }
  else
    {
      input_line_pointer++;
      temp = get_absolute_expression ();
    }
  /*  *symbol_get_obj (symbolP) = (signed char) temp; */
  (void) symbolP;
  as_warn (_("unhandled: .proc %s,%d"), name, temp);
  demand_empty_rest_of_line ();
}

/* Handle the .set pseudo op.  This is used to turn on and off most of
   the assembler features.  */

static void
s_alpha_set (int x ATTRIBUTE_UNUSED)
{
  char *name, ch, *s;
  int yesno = 1;

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  ch = get_symbol_end ();

  s = name;
  if (s[0] == 'n' && s[1] == 'o')
    {
      yesno = 0;
      s += 2;
    }
  if (!strcmp ("reorder", s))
    /* ignore */ ;
  else if (!strcmp ("at", s))
    alpha_noat_on = !yesno;
  else if (!strcmp ("macro", s))
    alpha_macros_on = yesno;
  else if (!strcmp ("move", s))
    /* ignore */ ;
  else if (!strcmp ("volatile", s))
    /* ignore */ ;
  else
    as_warn (_("Tried to .set unrecognized mode `%s'"), name);

  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

/* Handle the .base pseudo op.  This changes the assembler's notion of
   the $gp register.  */

static void
s_alpha_base (int ignore ATTRIBUTE_UNUSED)
{
  SKIP_WHITESPACE ();

  if (*input_line_pointer == '$')
    {
      /* $rNN form.  */
      input_line_pointer++;
      if (*input_line_pointer == 'r')
	input_line_pointer++;
    }

  alpha_gp_register = get_absolute_expression ();
  if (alpha_gp_register < 0 || alpha_gp_register > 31)
    {
      alpha_gp_register = AXP_REG_GP;
      as_warn (_("Bad base register, using $%d."), alpha_gp_register);
    }

  demand_empty_rest_of_line ();
}

/* Handle the .align pseudo-op.  This aligns to a power of two.  It
   also adjusts any current instruction label.  We treat this the same
   way the MIPS port does: .align 0 turns off auto alignment.  */

static void
s_alpha_align (int ignore ATTRIBUTE_UNUSED)
{
  int align;
  char fill, *pfill;
  long max_alignment = 16;

  align = get_absolute_expression ();
  if (align > max_alignment)
    {
      align = max_alignment;
      as_bad (_("Alignment too large: %d. assumed"), align);
    }
  else if (align < 0)
    {
      as_warn (_("Alignment negative: 0 assumed"));
      align = 0;
    }

  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      fill = get_absolute_expression ();
      pfill = &fill;
    }
  else
    pfill = NULL;

  if (align != 0)
    {
      alpha_auto_align_on = 1;
      alpha_align (align, pfill, NULL, 1);
    }
  else
    {
      alpha_auto_align_on = 0;
    }
  alpha_insn_label = NULL;

  demand_empty_rest_of_line ();
}

/* Hook the normal string processor to reset known alignment.  */

static void
s_alpha_stringer (int terminate)
{
  alpha_current_align = 0;
  alpha_insn_label = NULL;
  stringer (8 + terminate);
}

/* Hook the normal space processing to reset known alignment.  */

static void
s_alpha_space (int ignore)
{
  alpha_current_align = 0;
  alpha_insn_label = NULL;
  s_space (ignore);
}

/* Hook into cons for auto-alignment.  */

void
alpha_cons_align (int size)
{
  int log_size;

  log_size = 0;
  while ((size >>= 1) != 0)
    ++log_size;

  if (alpha_auto_align_on && alpha_current_align < log_size)
    alpha_align (log_size, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > log_size)
    alpha_current_align = log_size;
  alpha_insn_label = NULL;
}

/* Here come the .uword, .ulong, and .uquad explicitly unaligned
   pseudos.  We just turn off auto-alignment and call down to cons.  */

static void
s_alpha_ucons (int bytes)
{
  int hold = alpha_auto_align_on;
  alpha_auto_align_on = 0;
  cons (bytes);
  alpha_auto_align_on = hold;
}

/* Switch the working cpu type.  */

static void
s_alpha_arch (int ignored ATTRIBUTE_UNUSED)
{
  char *name, ch;
  const struct cpu_type *p;

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  ch = get_symbol_end ();

  for (p = cpu_types; p->name; ++p)
    if (strcmp (name, p->name) == 0)
      {
	alpha_target_name = p->name, alpha_target = p->flags;
	goto found;
      }
  as_warn (_("Unknown CPU identifier `%s'"), name);

found:
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

#ifdef DEBUG1
/* print token expression with alpha specific extension.  */

static void
alpha_print_token (FILE *f, const expressionS *exp)
{
  switch (exp->X_op)
    {
    case O_cpregister:
      putc (',', f);
      /* FALLTHRU */
    case O_pregister:
      putc ('(', f);
      {
	expressionS nexp = *exp;
	nexp.X_op = O_register;
	print_expr_1 (f, &nexp);
      }
      putc (')', f);
      break;
    default:
      print_expr_1 (f, exp);
      break;
    }
}
#endif

/* The target specific pseudo-ops which we support.  */

const pseudo_typeS md_pseudo_table[] =
{
#ifdef OBJ_ECOFF
  {"comm", s_alpha_comm, 0},	/* OSF1 compiler does this.  */
  {"rdata", s_alpha_rdata, 0},
#endif
  {"text", s_alpha_text, 0},
  {"data", s_alpha_data, 0},
#ifdef OBJ_ECOFF
  {"sdata", s_alpha_sdata, 0},
#endif
#ifdef OBJ_ELF
  {"section", s_alpha_section, 0},
  {"section.s", s_alpha_section, 0},
  {"sect", s_alpha_section, 0},
  {"sect.s", s_alpha_section, 0},
#endif
#ifdef OBJ_EVAX
  {"section", s_alpha_section, 0},
  {"literals", s_alpha_literals, 0},
  {"pdesc", s_alpha_pdesc, 0},
  {"name", s_alpha_name, 0},
  {"linkage", s_alpha_linkage, 0},
  {"code_address", s_alpha_code_address, 0},
  {"ent", s_alpha_ent, 0},
  {"frame", s_alpha_frame, 0},
  {"fp_save", s_alpha_fp_save, 0},
  {"mask", s_alpha_mask, 0},
  {"fmask", s_alpha_fmask, 0},
  {"end", s_alpha_end, 0},
  {"file", s_alpha_file, 0},
  {"rdata", s_alpha_section, 1},
  {"comm", s_alpha_comm, 0},
  {"link", s_alpha_section, 3},
  {"ctors", s_alpha_section, 4},
  {"dtors", s_alpha_section, 5},
  {"handler", s_alpha_handler, 0},
  {"handler_data", s_alpha_handler, 1},
#endif
#ifdef OBJ_ELF
  /* Frame related pseudos.  */
  {"ent", s_alpha_ent, 0},
  {"end", s_alpha_end, 0},
  {"mask", s_alpha_mask, 0},
  {"fmask", s_alpha_mask, 1},
  {"frame", s_alpha_frame, 0},
  {"prologue", s_alpha_prologue, 0},
  {"file", s_alpha_file, 5},
  {"loc", s_alpha_loc, 9},
  {"stabs", s_alpha_stab, 's'},
  {"stabn", s_alpha_stab, 'n'},
  {"usepv", s_alpha_usepv, 0},
  /* COFF debugging related pseudos.  */
  {"begin", s_alpha_coff_wrapper, 0},
  {"bend", s_alpha_coff_wrapper, 1},
  {"def", s_alpha_coff_wrapper, 2},
  {"dim", s_alpha_coff_wrapper, 3},
  {"endef", s_alpha_coff_wrapper, 4},
  {"scl", s_alpha_coff_wrapper, 5},
  {"tag", s_alpha_coff_wrapper, 6},
  {"val", s_alpha_coff_wrapper, 7},
#else
#ifdef OBJ_EVAX
  {"prologue", s_alpha_prologue, 0},
#else
  {"prologue", s_ignore, 0},
#endif
#endif
  {"gprel32", s_alpha_gprel32, 0},
  {"t_floating", s_alpha_float_cons, 'd'},
  {"s_floating", s_alpha_float_cons, 'f'},
  {"f_floating", s_alpha_float_cons, 'F'},
  {"g_floating", s_alpha_float_cons, 'G'},
  {"d_floating", s_alpha_float_cons, 'D'},

  {"proc", s_alpha_proc, 0},
  {"aproc", s_alpha_proc, 1},
  {"set", s_alpha_set, 0},
  {"reguse", s_ignore, 0},
  {"livereg", s_ignore, 0},
  {"base", s_alpha_base, 0},		/*??*/
  {"option", s_ignore, 0},
  {"aent", s_ignore, 0},
  {"ugen", s_ignore, 0},
  {"eflag", s_ignore, 0},

  {"align", s_alpha_align, 0},
  {"double", s_alpha_float_cons, 'd'},
  {"float", s_alpha_float_cons, 'f'},
  {"single", s_alpha_float_cons, 'f'},
  {"ascii", s_alpha_stringer, 0},
  {"asciz", s_alpha_stringer, 1},
  {"string", s_alpha_stringer, 1},
  {"space", s_alpha_space, 0},
  {"skip", s_alpha_space, 0},
  {"zero", s_alpha_space, 0},

/* Unaligned data pseudos.  */
  {"uword", s_alpha_ucons, 2},
  {"ulong", s_alpha_ucons, 4},
  {"uquad", s_alpha_ucons, 8},

#ifdef OBJ_ELF
/* Dwarf wants these versions of unaligned.  */
  {"2byte", s_alpha_ucons, 2},
  {"4byte", s_alpha_ucons, 4},
  {"8byte", s_alpha_ucons, 8},
#endif

/* We don't do any optimizing, so we can safely ignore these.  */
  {"noalias", s_ignore, 0},
  {"alias", s_ignore, 0},

  {"arch", s_alpha_arch, 0},

  {NULL, 0, 0},
};

#ifdef OBJ_ECOFF

/* @@@@@@ GP selection voodoo.  All of this seems overly complicated and
   unnecessary; which is the primary reason it's for ECOFF only.  */

static inline void
maybe_set_gp (asection *sec)
{
  bfd_vma vma;

  if (!sec)
    return;
  vma = bfd_get_section_vma (sec->owner, sec);
  if (vma && vma < alpha_gp_value)
    alpha_gp_value = vma;
}

static void
select_gp_value (void)
{
  gas_assert (alpha_gp_value == 0);

  /* Get minus-one in whatever width...  */
  alpha_gp_value = 0;
  alpha_gp_value--;

  /* Select the smallest VMA of these existing sections.  */
  maybe_set_gp (alpha_lita_section);

/* @@@@ Will a simple 0x8000 work here?  If not, why not?  */
#define GP_ADJUSTMENT	(0x8000 - 0x10)

  alpha_gp_value += GP_ADJUSTMENT;

  S_SET_VALUE (alpha_gp_symbol, alpha_gp_value);

#ifdef DEBUG1
  printf (_("Chose GP value of %lx\n"), alpha_gp_value);
#endif
}
#endif /* OBJ_ECOFF */

#ifdef OBJ_ELF
/* Map 's' to SHF_ALPHA_GPREL.  */

bfd_vma
alpha_elf_section_letter (int letter, char **ptr_msg)
{
  if (letter == 's')
    return SHF_ALPHA_GPREL;

  *ptr_msg = _("bad .section directive: want a,s,w,x,M,S,G,T in string");
  return -1;
}

/* Map SHF_ALPHA_GPREL to SEC_SMALL_DATA.  */

flagword
alpha_elf_section_flags (flagword flags, bfd_vma attr, int type ATTRIBUTE_UNUSED)
{
  if (attr & SHF_ALPHA_GPREL)
    flags |= SEC_SMALL_DATA;
  return flags;
}
#endif /* OBJ_ELF */

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
alpha_handle_align (fragS *fragp)
{
  static char const unop[4] = { 0x00, 0x00, 0xfe, 0x2f };
  static char const nopunop[8] =
  {
    0x1f, 0x04, 0xff, 0x47,
    0x00, 0x00, 0xfe, 0x2f
  };

  int bytes, fix;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;
  fix = 0;

  if (bytes & 3)
    {
      fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }

  if (bytes & 4)
    {
      memcpy (p, unop, 4);
      p += 4;
      bytes -= 4;
      fix += 4;
    }

  memcpy (p, nopunop, 8);

  fragp->fr_fix += fix;
  fragp->fr_var = 8;
}

/* Public interface functions.  */

/* This function is called once, at assembler startup time.  It sets
   up all the tables, etc. that the MD part of the assembler will
   need, that can be determined before arguments are parsed.  */

void
md_begin (void)
{
  unsigned int i;

  /* Verify that X_op field is wide enough.  */
  {
    expressionS e;

    e.X_op = O_max;
    gas_assert (e.X_op == O_max);
  }

  /* Create the opcode hash table.  */
  alpha_opcode_hash = hash_new ();

  for (i = 0; i < alpha_num_opcodes;)
    {
      const char *name, *retval, *slash;

      name = alpha_opcodes[i].name;
      retval = hash_insert (alpha_opcode_hash, name, (void *) &alpha_opcodes[i]);
      if (retval)
	as_fatal (_("internal error: can't hash opcode `%s': %s"),
		  name, retval);

      /* Some opcodes include modifiers of various sorts with a "/mod"
	 syntax, like the architecture manual suggests.  However, for
	 use with gcc at least, we also need access to those same opcodes
	 without the "/".  */

      if ((slash = strchr (name, '/')) != NULL)
	{
	  char *p = (char *) xmalloc (strlen (name));

	  memcpy (p, name, slash - name);
	  strcpy (p + (slash - name), slash + 1);

	  (void) hash_insert (alpha_opcode_hash, p, (void *) &alpha_opcodes[i]);
	  /* Ignore failures -- the opcode table does duplicate some
	     variants in different forms, like "hw_stq" and "hw_st/q".  */
	}

      while (++i < alpha_num_opcodes
	     && (alpha_opcodes[i].name == name
		 || !strcmp (alpha_opcodes[i].name, name)))
	continue;
    }

  /* Create the macro hash table.  */
  alpha_macro_hash = hash_new ();

  for (i = 0; i < alpha_num_macros;)
    {
      const char *name, *retval;

      name = alpha_macros[i].name;
      retval = hash_insert (alpha_macro_hash, name, (void *) &alpha_macros[i]);
      if (retval)
	as_fatal (_("internal error: can't hash macro `%s': %s"),
		  name, retval);

      while (++i < alpha_num_macros
	     && (alpha_macros[i].name == name
		 || !strcmp (alpha_macros[i].name, name)))
	continue;
    }

  /* Construct symbols for each of the registers.  */
  for (i = 0; i < 32; ++i)
    {
      char name[4];

      sprintf (name, "$%d", i);
      alpha_register_table[i] = symbol_create (name, reg_section, i,
					       &zero_address_frag);
    }

  for (; i < 64; ++i)
    {
      char name[5];

      sprintf (name, "$f%d", i - 32);
      alpha_register_table[i] = symbol_create (name, reg_section, i,
					       &zero_address_frag);
    }

  /* Create the special symbols and sections we'll be using.  */

  /* So .sbss will get used for tiny objects.  */
  bfd_set_gp_size (stdoutput, g_switch_value);

#ifdef OBJ_ECOFF
  create_literal_section (".lita", &alpha_lita_section, &alpha_lita_symbol);

  /* For handling the GP, create a symbol that won't be output in the
     symbol table.  We'll edit it out of relocs later.  */
  alpha_gp_symbol = symbol_create ("<GP value>", alpha_lita_section, 0x8000,
				   &zero_address_frag);
#endif

#ifdef OBJ_EVAX
  create_literal_section (".link", &alpha_link_section, &alpha_link_symbol);
#endif

#ifdef OBJ_ELF
  if (ECOFF_DEBUGGING)
    {
      segT sec = subseg_new (".mdebug", (subsegT) 0);
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);
      bfd_set_section_alignment (stdoutput, sec, 3);
    }
#endif

  /* Create literal lookup hash table.  */
  alpha_literal_hash = hash_new ();

  subseg_set (text_section, 0);
}

/* The public interface to the instruction assembler.  */

void
md_assemble (char *str)
{
  /* Current maximum is 13.  */
  char opname[32];
  expressionS tok[MAX_INSN_ARGS];
  int ntok, trunclen;
  size_t opnamelen;

  /* Split off the opcode.  */
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/46819");
  trunclen = (opnamelen < sizeof (opname) - 1
	      ? opnamelen
	      : sizeof (opname) - 1);
  memcpy (opname, str, trunclen);
  opname[trunclen] = '\0';

  /* Tokenize the rest of the line.  */
  if ((ntok = tokenize_arguments (str + opnamelen, tok, MAX_INSN_ARGS)) < 0)
    {
      if (ntok != TOKENIZE_ERROR_REPORT)
	as_bad (_("syntax error"));

      return;
    }

  /* Finish it off.  */
  assemble_tokens (opname, tok, ntok, alpha_macros_on);
}

/* Round up a section's size to the appropriate boundary.  */

valueT
md_section_align (segT seg, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  valueT mask = ((valueT) 1 << align) - 1;

  return (size + mask) & ~mask;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  extern char *vax_md_atof (int, char *, int *);

  switch (type)
    {
      /* VAX floats.  */
    case 'G':
      /* vax_md_atof() doesn't like "G" for some reason.  */
      type = 'g';
    case 'F':
    case 'D':
      return vax_md_atof (type, litP, sizeP);

    default:
      return ieee_md_atof (type, litP, sizeP, FALSE);
    }
}

/* Take care of the target-specific command-line options.  */

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case 'F':
      alpha_nofloats_on = 1;
      break;

    case OPTION_32ADDR:
      alpha_addr32_on = 1;
      break;

    case 'g':
      alpha_debug = 1;
      break;

    case 'G':
      g_switch_value = atoi (arg);
      break;

    case 'm':
      {
	const struct cpu_type *p;

	for (p = cpu_types; p->name; ++p)
	  if (strcmp (arg, p->name) == 0)
	    {
	      alpha_target_name = p->name, alpha_target = p->flags;
	      goto found;
	    }
	as_warn (_("Unknown CPU identifier `%s'"), arg);
      found:;
      }
      break;

#ifdef OBJ_EVAX
    case '+':			/* For g++.  Hash any name > 63 chars long.  */
      alpha_flag_hash_long_names = 1;
      break;

    case 'H':			/* Show new symbol after hash truncation.  */
      alpha_flag_show_after_trunc = 1;
      break;

    case 'h':			/* For gnu-c/vax compatibility.  */
      break;

    case OPTION_REPLACE:
      alpha_flag_replace = 1;
      break;

    case OPTION_NOREPLACE:
      alpha_flag_replace = 0;
      break;
#endif

    case OPTION_RELAX:
      alpha_flag_relax = 1;
      break;

#ifdef OBJ_ELF
    case OPTION_MDEBUG:
      alpha_flag_mdebug = 1;
      break;
    case OPTION_NO_MDEBUG:
      alpha_flag_mdebug = 0;
      break;
#endif

    default:
      return 0;
    }

  return 1;
}

/* Print a description of the command-line options that we accept.  */

void
md_show_usage (FILE *stream)
{
  fputs (_("\
Alpha options:\n\
-32addr			treat addresses as 32-bit values\n\
-F			lack floating point instructions support\n\
-mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mev67 | -mev68 | -mall\n\
			specify variant of Alpha architecture\n\
-m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264 | -m21264a | -m21264b\n\
			these variants include PALcode opcodes\n"),
	stream);
#ifdef OBJ_EVAX
  fputs (_("\
VMS options:\n\
-+			encode (don't truncate) names longer than 64 characters\n\
-H			show new symbol after hash truncation\n\
-replace/-noreplace	enable or disable the optimization of procedure calls\n"),
	stream);
#endif
}

/* Decide from what point a pc-relative relocation is relative to,
   relative to the pc-relative fixup.  Er, relatively speaking.  */

long
md_pcrel_from (fixS *fixP)
{
  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_ALPHA_HINT:
    case BFD_RELOC_ALPHA_BRSGP:
      return addr + 4;
    default:
      return addr;
    }
}

/* Attempt to simplify or even eliminate a fixup.  The return value is
   ignored; perhaps it was once meaningful, but now it is historical.
   To indicate that a fixup has been eliminated, set fixP->fx_done.

   For ELF, here it is that we transform the GPDISP_HI16 reloc we used
   internally into the GPDISP reloc used externally.  We had to do
   this so that we'd have the GPDISP_LO16 reloc as a tag to compute
   the distance to the "lda" instruction for setting the addend to
   GPDISP.  */

void
md_apply_fix (fixS *fixP, valueT * valP, segT seg)
{
  char * const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
  valueT value = * valP;
  unsigned image, size;

  switch (fixP->fx_r_type)
    {
      /* The GPDISP relocations are processed internally with a symbol
	 referring to the current function's section;  we need to drop
	 in a value which, when added to the address of the start of
	 the function, gives the desired GP.  */
    case BFD_RELOC_ALPHA_GPDISP_HI16:
      {
	fixS *next = fixP->fx_next;

	/* With user-specified !gpdisp relocations, we can be missing
	   the matching LO16 reloc.  We will have already issued an
	   error message.  */
	if (next)
	  fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where
			     - fixP->fx_frag->fr_address - fixP->fx_where);

	value = (value - sign_extend_16 (value)) >> 16;
      }
#ifdef OBJ_ELF
      fixP->fx_r_type = BFD_RELOC_ALPHA_GPDISP;
#endif
      goto do_reloc_gp;

    case BFD_RELOC_ALPHA_GPDISP_LO16:
      value = sign_extend_16 (value);
      fixP->fx_offset = 0;
#ifdef OBJ_ELF
      fixP->fx_done = 1;
#endif

    do_reloc_gp:
      fixP->fx_addsy = section_symbol (seg);
      md_number_to_chars (fixpos, value, 2);
      break;

    case BFD_RELOC_16:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_16_PCREL;
      size = 2;
      goto do_reloc_xx;

    case BFD_RELOC_32:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_32_PCREL;
      size = 4;
      goto do_reloc_xx;

    case BFD_RELOC_64:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_64_PCREL;
      size = 8;

    do_reloc_xx:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  md_number_to_chars (fixpos, value, size);
	  goto done;
	}
      return;

#ifdef OBJ_ECOFF
    case BFD_RELOC_GPREL32:
      gas_assert (fixP->fx_subsy == alpha_gp_symbol);
      fixP->fx_subsy = 0;
      /* FIXME: inherited this obliviousness of `value' -- why?  */
      md_number_to_chars (fixpos, -alpha_gp_value, 4);
      break;
#else
    case BFD_RELOC_GPREL32:
#endif
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
      return;

    case BFD_RELOC_23_PCREL_S2:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  image = bfd_getl32 (fixpos);
	  image = (image & ~0x1FFFFF) | ((value >> 2) & 0x1FFFFF);
	  goto write_done;
	}
      return;

    case BFD_RELOC_ALPHA_HINT:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  image = bfd_getl32 (fixpos);
	  image = (image & ~0x3FFF) | ((value >> 2) & 0x3FFF);
	  goto write_done;
	}
      return;

#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_BRSGP:
      return;

    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      if (fixP->fx_addsy)
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
      return;
#endif

#ifdef OBJ_ECOFF
    case BFD_RELOC_ALPHA_LITERAL:
      md_number_to_chars (fixpos, value, 2);
      return;
#endif
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
      return;

#ifdef OBJ_EVAX
    case BFD_RELOC_ALPHA_NOP:
      value -= (8 + 4); /* PC-relative, base is jsr+4.  */

      /* From B.4.5.2 of the OpenVMS Linker Utility Manual:
	 "Finally, the ETIR$C_STC_BSR command passes the same address
	  as ETIR$C_STC_NOP (so that they will fail or succeed together),
	  and the same test is done again."  */
      if (S_GET_SEGMENT (fixP->fx_addsy) == undefined_section)
	{
	  fixP->fx_addnumber = -value;
	  return;
	}

      if ((abs (value) >> 2) & ~0xfffff)
	goto done;
      else
	{
	  /* Change to a nop.  */
	  image = 0x47FF041F;
	  goto write_done;
	}

    case BFD_RELOC_ALPHA_LDA:
      /* fixup_segment sets fixP->fx_addsy to NULL when it can pre-compute
	 the value for an O_subtract.  */
      if (fixP->fx_addsy
	  && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section)
	{
	  fixP->fx_addnumber = symbol_get_bfdsym (fixP->fx_subsy)->value;
	  return;
	}

      if ((abs (value)) & ~0x7fff)
	goto done;
      else
	{
	  /* Change to an lda.  */
	  image = 0x237B0000 | (value & 0xFFFF);
	  goto write_done;
	}

    case BFD_RELOC_ALPHA_BSR:
    case BFD_RELOC_ALPHA_BOH:
      value -= 4; /* PC-relative, base is jsr+4.  */

      /* See comment in the BFD_RELOC_ALPHA_NOP case above.  */
      if (S_GET_SEGMENT (fixP->fx_addsy) == undefined_section)
	{
	  fixP->fx_addnumber = -value;
	  return;
	}

      if ((abs (value) >> 2) & ~0xfffff)
	{
	  /* Out of range.  */
	  if (fixP->fx_r_type == BFD_RELOC_ALPHA_BOH)
	    {
	      /* Add a hint.  */
	      image = bfd_getl32(fixpos);
	      image = (image & ~0x3FFF) | ((value >> 2) & 0x3FFF);
	      goto write_done;
	    }
	  goto done;
	}
      else
	{
	  /* Change to a branch.  */
	  image = 0xD3400000 | ((value >> 2) & 0x1FFFFF);
	  goto write_done;
	}
#endif

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return;

    default:
      {
	const struct alpha_operand *operand;

	if ((int) fixP->fx_r_type >= 0)
	  as_fatal (_("unhandled relocation type %s"),
		    bfd_get_reloc_code_name (fixP->fx_r_type));

	gas_assert (-(int) fixP->fx_r_type < (int) alpha_num_operands);
	operand = &alpha_operands[-(int) fixP->fx_r_type];

	/* The rest of these fixups only exist internally during symbol
	   resolution and have no representation in the object file.
	   Therefore they must be completely resolved as constants.  */

	if (fixP->fx_addsy != 0
	    && S_GET_SEGMENT (fixP->fx_addsy) != absolute_section)
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("non-absolute expression in constant field"));

	image = bfd_getl32 (fixpos);
	image = insert_operand (image, operand, (offsetT) value,
				fixP->fx_file, fixP->fx_line);
      }
      goto write_done;
    }

  if (fixP->fx_addsy != 0 || fixP->fx_pcrel != 0)
    return;
  else
    {
      as_warn_where (fixP->fx_file, fixP->fx_line,
		     _("type %d reloc done?\n"), (int) fixP->fx_r_type);
      goto done;
    }

write_done:
  md_number_to_chars (fixpos, image, 4);

done:
  fixP->fx_done = 1;
}

/* Look for a register name in the given symbol.  */

symbolS *
md_undefined_symbol (char *name)
{
  if (*name == '$')
    {
      int is_float = 0, num;

      switch (*++name)
	{
	case 'f':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[AXP_REG_FP];
	  is_float = 32;
	  /* Fall through.  */

	case 'r':
	  if (!ISDIGIT (*++name))
	    break;
	  /* Fall through.  */

	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	  if (name[1] == '\0')
	    num = name[0] - '0';
	  else if (name[0] != '0' && ISDIGIT (name[1]) && name[2] == '\0')
	    {
	      num = (name[0] - '0') * 10 + name[1] - '0';
	      if (num >= 32)
		break;
	    }
	  else
	    break;

	  if (!alpha_noat_on && (num + is_float) == AXP_REG_AT)
	    as_warn (_("Used $at without \".set noat\""));
	  return alpha_register_table[num + is_float];

	case 'a':
	  if (name[1] == 't' && name[2] == '\0')
	    {
	      if (!alpha_noat_on)
		as_warn (_("Used $at without \".set noat\""));
	      return alpha_register_table[AXP_REG_AT];
	    }
	  break;

	case 'g':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[alpha_gp_register];
	  break;

	case 's':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[AXP_REG_SP];
	  break;
	}
    }
  return NULL;
}

#ifdef OBJ_ECOFF
/* @@@@@@ Magic ECOFF bits.  */

void
alpha_frob_ecoff_data (void)
{
  select_gp_value ();
  /* $zero and $f31 are read-only.  */
  alpha_gprmask &= ~1;
  alpha_fprmask &= ~1;
}
#endif

/* Hook to remember a recently defined label so that the auto-align
   code can adjust the symbol after we know what alignment will be
   required.  */

void
alpha_define_label (symbolS *sym)
{
  alpha_insn_label = sym;
#ifdef OBJ_ELF
  dwarf2_emit_label (sym);
#endif
}

/* Return true if we must always emit a reloc for a type and false if
   there is some hope of resolving it at assembly time.  */

int
alpha_force_relocation (fixS *f)
{
  if (alpha_flag_relax)
    return 1;

  switch (f->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_GPDISP:
    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
    case BFD_RELOC_ALPHA_BRSGP:
    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
#ifdef OBJ_EVAX
    case BFD_RELOC_ALPHA_NOP:
    case BFD_RELOC_ALPHA_BSR:
    case BFD_RELOC_ALPHA_LDA:
    case BFD_RELOC_ALPHA_BOH:
#endif
      return 1;

    default:
      break;
    }

  return generic_force_reloc (f);
}

/* Return true if we can partially resolve a relocation now.  */

int
alpha_fix_adjustable (fixS *f)
{
  /* Are there any relocation types for which we must generate a
     reloc but we can adjust the values contained within it?   */
  switch (f->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_GPDISP:
      return 0;

    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
      return 1;

    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      return 0;

    case BFD_RELOC_GPREL16:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_16:
    case BFD_RELOC_32:
    case BFD_RELOC_64:
    case BFD_RELOC_ALPHA_HINT:
      return 1;

    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      /* ??? No idea why we can't return a reference to .tbss+10, but
	 we're preventing this in the other assemblers.  Follow for now.  */
      return 0;

#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_BRSGP:
      /* If we have a BRSGP reloc to a local symbol, adjust it to BRADDR and
         let it get resolved at assembly time.  */
      {
	symbolS *sym = f->fx_addsy;
	const char *name;
	int offset = 0;

	if (generic_force_reloc (f))
	  return 0;

	switch (S_GET_OTHER (sym) & STO_ALPHA_STD_GPLOAD)
	  {
	  case STO_ALPHA_NOPV:
	    break;
	  case STO_ALPHA_STD_GPLOAD:
	    offset = 8;
	    break;
	  default:
	    if (S_IS_LOCAL (sym))
	      name = "<local>";
	    else
	      name = S_GET_NAME (sym);
	    as_bad_where (f->fx_file, f->fx_line,
		_("!samegp reloc against symbol without .prologue: %s"),
		name);
	    break;
	  }
	f->fx_r_type = BFD_RELOC_23_PCREL_S2;
	f->fx_offset += offset;
	return 1;
      }
#endif
#ifdef OBJ_EVAX
    case BFD_RELOC_ALPHA_NOP:
    case BFD_RELOC_ALPHA_BSR:
    case BFD_RELOC_ALPHA_LDA:
    case BFD_RELOC_ALPHA_BOH:
      return 1;
#endif

    default:
      return 1;
    }
}

/* Generate the BFD reloc to be stuck in the object file from the
   fixup used internally in the assembler.  */

arelent *
tc_gen_reloc (asection *sec ATTRIBUTE_UNUSED,
	      fixS *fixp)
{
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (* reloc));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* Make sure none of our internal relocations make it this far.
     They'd better have been fully resolved by this point.  */
  gas_assert ((int) fixp->fx_r_type > 0);

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent `%s' relocation in object file"),
		    bfd_get_reloc_code_name (fixp->fx_r_type));
      return NULL;
    }

  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
    as_fatal (_("internal error? cannot generate `%s' relocation"),
	      bfd_get_reloc_code_name (fixp->fx_r_type));

  gas_assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);

  reloc->addend = fixp->fx_offset;

#ifdef OBJ_ECOFF
  /* Fake out bfd_perform_relocation. sigh.  */
  /* ??? Better would be to use the special_function hook.  */
  if (fixp->fx_r_type == BFD_RELOC_ALPHA_LITERAL)
    reloc->addend = -alpha_gp_value;
#endif

#ifdef OBJ_EVAX
  switch (fixp->fx_r_type)
    {
      struct evax_private_udata_struct *udata;
      const char *pname;
      int pname_len;

    case BFD_RELOC_ALPHA_LINKAGE:
      /* Copy the linkage index.  */
      reloc->addend = fixp->fx_addnumber;
      break;

    case BFD_RELOC_ALPHA_NOP:
    case BFD_RELOC_ALPHA_BSR:
    case BFD_RELOC_ALPHA_LDA:
    case BFD_RELOC_ALPHA_BOH:
      pname = symbol_get_bfdsym (fixp->fx_addsy)->name;

      /* We need the non-suffixed name of the procedure.  Beware that
      the main symbol might be equated so look it up and take its name.  */
      pname_len = strlen (pname);
      if (pname_len > 4 && strcmp (pname + pname_len - 4, "..en") == 0)
	{
	  symbolS *sym;
	  char *my_pname = (char *) alloca (pname_len - 4 + 1);

	  memcpy (my_pname, pname, pname_len - 4);
	  my_pname [pname_len - 4] = 0;
	  sym = symbol_find (my_pname);
	  if (sym == NULL)
	    abort ();

	  while (symbol_equated_reloc_p (sym))
	    {
	      symbolS *n = symbol_get_value_expression (sym)->X_add_symbol;

	      /* We must avoid looping, as that can occur with a badly
	         written program.  */
	      if (n == sym)
		break;
	      sym = n;
	    }
	  pname = symbol_get_bfdsym (sym)->name;
	}

      udata = (struct evax_private_udata_struct *)
	xmalloc (sizeof (struct evax_private_udata_struct));
      udata->enbsym = symbol_get_bfdsym (fixp->fx_addsy);
      udata->bsym = symbol_get_bfdsym (fixp->tc_fix_data.info->psym);
      udata->origname = (char *)pname;
      udata->lkindex = ((struct evax_private_udata_struct *)
        symbol_get_bfdsym (fixp->tc_fix_data.info->sym)->udata.p)->lkindex;
      reloc->sym_ptr_ptr = (void *)udata;
      reloc->addend = fixp->fx_addnumber;

    default:
      break;
    }
#endif

  return reloc;
}

/* Parse a register name off of the input_line and return a register
   number.  Gets md_undefined_symbol above to do the register name
   matching for us.

   Only called as a part of processing the ECOFF .frame directive.  */

int
tc_get_register (int frame ATTRIBUTE_UNUSED)
{
  int framereg = AXP_REG_SP;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {
      char *s = input_line_pointer;
      char c = get_symbol_end ();
      symbolS *sym = md_undefined_symbol (s);

      *strchr (s, '\0') = c;
      if (sym && (framereg = S_GET_VALUE (sym)) <= 31)
	goto found;
    }
  as_warn (_("frame reg expected, using $%d."), framereg);

found:
  note_gpreg (framereg);
  return framereg;
}

/* This is called before the symbol table is processed.  In order to
   work with gcc when using mips-tfile, we must keep all local labels.
   However, in other cases, we want to discard them.  If we were
   called with -g, but we didn't see any debugging information, it may
   mean that gcc is smuggling debugging information through to
   mips-tfile, in which case we must generate all local labels.  */

#ifdef OBJ_ECOFF

void
alpha_frob_file_before_adjust (void)
{
  if (alpha_debug != 0
      && ! ecoff_debugging_seen)
    flag_keep_locals = 1;
}

#endif /* OBJ_ECOFF */

/* The Alpha has support for some VAX floating point types, as well as for
   IEEE floating point.  We consider IEEE to be the primary floating point
   format, and sneak in the VAX floating point support here.  */
#include "config/atof-vax.c"
@


1.102
log
@2011-11-23  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (s_alpha_prologue): Requires empty line.
@
text
@d5305 1
a5305 1
  vma = bfd_get_section_vma (foo, sec);
@


1.101
log
@2011-11-23  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (s_alpha_frame): Emit a warning if bad value
	of RA.
	(s_alpha_pdesc): Adjust comment.
@
text
@a4473 1
  get_absolute_expression ();
@


1.100
log
@2011-10-21  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (load_expression): Use symbol_mark_used accessor.
	(s_alpha_comm): Use symbol_set_frag accessor.
@
text
@d4438 1
d4454 4
a4457 1
  (void) tc_get_register (1);
d4480 1
a4480 1
/* Parse .pdesc <entry_name>.
@


1.99
log
@2011-09-19  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (insert_operand): Call as_bad_value_out_of_range
	instead of as_warn_out_of_range.
@
text
@d1397 1
a1397 1
		    ensym->sy_used = 1;
d1429 1
a1429 1
		    psym->sy_used = 1;
d3605 1
a3605 1
      symbolP->sy_frag = frag_now;
@


1.98
log
@2011-08-26  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (s_alpha_linkage): Simplify.  Add comments.
@
text
@d1998 1
a1998 1
	as_warn_value_out_of_range (_("operand"), val, min, max, file, line);
@


1.97
log
@2011-08-26  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (add_to_link_pool): Improve comment.
	(s_alpha_fp_save): Fix indentation.
@
text
@d4704 1
a4704 1
	(frag_now, p - frag_now->fr_literal, LKP_S_K_SIZE, &exp, 0,\
d4707 5
a4713 1

d4715 1
a4715 5
      linkage_fixup->next = 0;

      if (alpha_insn_label == 0)
	alpha_insn_label = symbol_new
	  (FAKE_LABEL_NAME, now_seg, (valueT) frag_now_fix (), frag_now);
d4718 3
a4720 5
      if (alpha_linkage_fixup_root == 0)
	{
	  alpha_linkage_fixup_root = alpha_linkage_fixup_tail = linkage_fixup;
	  alpha_linkage_fixup_tail->next = 0;
	}
d4722 2
a4723 5
	{
	  alpha_linkage_fixup_tail->next = linkage_fixup;
	  alpha_linkage_fixup_tail = linkage_fixup;
	  alpha_linkage_fixup_tail->next = 0;
	}
@


1.96
log
@        * dw2gencfi.c (all_fde_data): Export.
        * dw2gencfi.h (all_fde_data): Declare.
        * config/tc-alpha.c (alpha_elf_md_end): Don't convert legacy unwind
        info to cfi unwind info if the user already has supplied some.
@
text
@d3415 1
a3415 1
  /* Create the basesym - linksym expression (offset of the added entry).  */
d3422 1
d3429 2
a4761 1

@


1.95
log
@2011-06-28  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (s_alpha_pdesc): Fix indentation. Do not
	generate dummy fix.
@
text
@d4045 8
@


1.94
log
@2011-06-28  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (load_expression): Use alloca instead of xmalloc.
	(emit_jsrjmp): Ditto.
	(tc_gen_reloc): Ditto.
@
text
@d4593 2
a4594 1
  fix_new_exp (frag_now, p - frag_now->fr_literal+8, 8, &exp, 0, BFD_RELOC_64);
d4599 1
a4599 1
  /* Add dummy fix to make add_to_link_pool work.  */
a4600 4
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 6, 0, 0, 0, 0);
  fixp->fx_done = 1;
  
  /* pdesc+16: Size.  */
a4601 1

d4613 1
a4613 1
  /* Add dummy fix to make add_to_link_pool work.  */
a4614 5
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;

  /* pdesc+24: register masks.  */

a4626 1
      /* Add dummy fix to make add_to_link_pool work.  */
a4627 2
      fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
      fixp->fx_done = 1;
@


1.93
log
@2011-06-28  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (alpha_evax_proc_hash): Remove.
	(alpha_evax_proc_data): New variable.
	(s_alpha_ent): Prevent nested function.  Remove has_insert call.
	(s_alpha_pdesc): Do not call demand_empty_rest_of_line in case of
	error.  Do not search in the hash table.  Check if match with .ent.
	(s_alpha_name): Remove unused variable.
	(md_begin): Remove initialization of alpha_evax_proc_hash.
@
text
@d1390 1
a1390 1
		    ensymname = (char *) xmalloc (ptr2 - ptr1 + 5);
d1422 1
a1422 1
		    psymname = (char *) xmalloc (ptr2 - ptr1 + 1);
d2887 1
a2887 1
      ensymname = (char *) xmalloc (symlen + 5);
d6285 3
a6287 1
	  char *my_pname = xstrdup (pname);
d6292 1
@


1.92
log
@2011-06-27  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (add_to_link_pool): Remove basesym parameter.
	Locally declare basesym.  Add comments.  Do not set literal_pool_size.
	(load_expression): Adjust call to add_to_link_pool.
	(s_alpha_pdesc): Define pdesc symbol using dot.
	Do not set literal_pool_size.
	(s_alpha_end): Use NULL instead of 0.
@
text
@a295 2
static struct hash_control *alpha_evax_proc_hash;

d430 1
d4358 4
a4361 2
  alpha_evax_proc
    = (struct alpha_evax_procs *) xmalloc (sizeof (struct alpha_evax_procs));
a4388 4
  (void) hash_insert
    (alpha_evax_proc_hash,
     symbol_get_bfdsym (alpha_evax_proc->symbol)->name, (PTR)alpha_evax_proc);

d4476 2
d4479 1
a4479 4
  segment_info_type *seginfo = seg_info (alpha_link_section);
  const char *entry_sym_name;
  char *sym_name;
  int len;
a4483 1
      demand_empty_rest_of_line ();
d4490 1
a4490 2
      as_warn (_(".pdesc directive has no entry symbol"));
      demand_empty_rest_of_line ();
d4495 1
a4495 1
  entry_sym_name = symbol_get_bfdsym (entry_sym)->name;
d4499 12
a4510 8
  sym_name = (char *) xmalloc (len - 4 + 1);
  strncpy (sym_name, entry_sym_name, len - 4);
  sym_name [len - 4] = 0;
  
  alpha_evax_proc = (struct alpha_evax_procs *)
    hash_find (alpha_evax_proc_hash, sym_name);
 
  if (!alpha_evax_proc || !S_IS_DEFINED (alpha_evax_proc->symbol))
d4512 1
a4512 2
      as_fatal (_(".pdesc has no matching .ent"));
      demand_empty_rest_of_line ();
d4517 1
a4517 1
  define_sym_at_dot (alpha_evax_proc->symbol);
a4650 1
  segment_info_type *seginfo = seg_info (alpha_link_section);
a5516 1
  alpha_evax_proc_hash = hash_new ();
@


1.91
log
@2011-06-24  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c (add_to_link_pool): Remove useless offset
	variable.  Fix style.
@
text
@d585 1
a585 1
static symbolS *add_to_link_pool (symbolS *, symbolS *, offsetT);
d1451 1
a1451 2
		linkexp = add_to_link_pool (alpha_evax_proc->symbol,
					    exp->X_add_symbol, 0);
d1518 1
a1518 2
      litexp = add_to_link_pool (alpha_evax_proc->symbol,
				 section_symbol (absolute_section), addend);
d3374 1
a3374 1
   Return offset from basesym to entry in link pool.
d3379 1
a3379 3
add_to_link_pool (symbolS *basesym,
		  symbolS *sym,
		  offsetT addend)
d3381 1
d3390 2
d3409 1
a3409 2
  /* Not found in 16bit signed range.  */

d3416 1
a3428 1
  seginfo->literal_pool_size += 8;
d4503 1
d4519 2
a4520 4
  *symbol_get_obj (alpha_evax_proc->symbol) =
    (valueT) seginfo->literal_pool_size;

  alpha_evax_proc->symbol->sy_obj = (valueT)seginfo->literal_pool_size;
a4565 1
  seginfo->literal_pool_size += 16;
a4604 1
  seginfo->literal_pool_size += 6;
a4623 1
  seginfo->literal_pool_size += 8;
a4642 1
      seginfo->literal_pool_size += 8;
a4678 1
  seginfo->literal_pool_size += 8;
d4817 1
a4817 1
  alpha_evax_proc = 0;
@


1.90
log
@PR 12610
* config/tc-alpha.c (s_alpha_align): Don't auto-align a previous
label; zap alpha_insn_label.
@
text
@d3375 1
a3375 1
/* Add symbol+addend to link pool.
a3386 1
  valueT offset;
a3392 2
  offset = 0; /* ??? DBR */

a3401 5
	if (fixp->tc_fix_data.info
	    && fixp->tc_fix_data.info->sym
	    && fixp->tc_fix_data.info->sym->sy_value.X_op_symbol == basesym)
	  offset += 8;
	
d3425 1
a3425 1
    (frag_now, p-frag_now->fr_literal, 8, sym, addend, 0, BFD_RELOC_64);
@


1.89
log
@Use bfd_elf_generic_reloc for alpha-elf.
@
text
@d5084 1
a5084 1
      alpha_align (align, pfill, alpha_insn_label, 1);
d5090 1
@


1.88
log
@	PR gas/12011
	* config/obj-elf.c (obj_elf_parse_section_letters): Correct test
	for error return from md_elf_section_letter.
	* config/tc-alpha.c (alpha_elf_section_letter): Correct error message.
	* config/tc-i386.c (x86_64_section_letter): Likewise.
	* config/tc-ia64.c (ia64_elf_section_letter): Likewise.
	* config/tc-mep.c (mep_elf_section_letter): Likewise.
	* gas/elf/bad-section-flag.d, * gas/elf/bad-section-flag.err,
	* gas/elf/bad-section-flag.s: New test.
	* gas/elf/elf.exp: Run it.
@
text
@d6272 2
d6275 2
a6277 1
    /* Fake out bfd_perform_relocation. sigh.  */
a6278 14
  else
#endif
    {
      reloc->addend = fixp->fx_offset;
#ifdef OBJ_ELF
      /* Ohhh, this is ugly.  The problem is that if this is a local global
         symbol, the relocation will entirely be performed at link time, not
         at assembly time.  bfd_perform_reloc doesn't know about this sort
         of thing, and as a result we need to fake it out here.  */
      if ((S_IS_EXTERNAL (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_THREAD_LOCAL))
	  && !S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= symbol_get_bfdsym (fixp->fx_addsy)->value;
a6279 1
    }
@


1.87
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d5367 1
a5367 1
  *ptr_msg = _("Bad .section directive: want a,s,w,x,M,S,G,T in string");
@


1.86
log
@2010-05-31  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c: Add comments for evax.
	* config/obj-evax.c: Ditto.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
a1385 1
		    volatile asymbol *dummy;
d1411 1
a1411 1
		    dummy = symbol_get_bfdsym (exp->X_add_symbol);
d2956 1
a2956 1
emit_ldgp (const expressionS *tok,
d3011 1
a3011 4
#else /* OBJ_ECOFF || OBJ_ELF */
  /* Avoid warning.  */
  tok = NULL;
#endif
d3656 1
a3656 3
  int temp;

  temp = get_absolute_expression ();
d3674 1
a3674 3
  int temp;

  temp = get_absolute_expression ();
a4296 1
  int temp;
d4341 1
a4341 1
      temp = get_absolute_expression ();
d4472 1
a4472 3
  int arg;

  arg = get_absolute_expression ();
d4982 1
@


1.85
log
@2010-04-14  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c: Includes vms/egps.h on EVAX.
	(s_alpha_comm): Used new EGPS macros from egps.h
	(RGPS__V_NO_SHIFT, EGPS__V_MASK): New local macros.
	(s_alpha_section_word): Add comments.  Use new EGPS macros.
	Adjust for modified bfd_vms_set_section_flags function.
@
text
@d89 5
a93 1
  symbolS *xtrasym, *procsym;
d426 1
d430 1
d504 2
a505 2
  struct symbol *sym;
  struct symbol *psym;
d1342 3
a1346 1
		set_tok_reg (newtok[0], targreg);
a1347 2
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("lda", newtok, 3, &insn);
a1351 1
		set_tok_reg (newtok[0], targreg);
a1352 2
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("lda", newtok, 3, &insn);
d1354 2
d1366 2
d1383 1
d1388 1
d1416 1
d1420 1
d1427 1
d1441 1
a1441 1
		emit_insn(&insn);
d1446 2
d2885 1
d2890 1
d4476 2
d4489 3
d4710 3
d4765 3
d6311 1
@


1.84
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d65 1
d3565 2
a3566 2
      bfd_vms_set_section_flags (stdoutput, sec,
				 EGPS_S_V_OVR | EGPS_S_V_GBL | EGPS_S_V_NOMOD);
d4214 8
d4238 1
a4238 1
	flag = EGPS_S_V_PIC;
d4240 1
a4240 1
	flag = EGPS_S_V_LIB;
d4242 1
a4242 1
	flag = EGPS_S_V_OVR;
d4244 1
a4244 1
	flag = EGPS_S_V_REL;
d4246 1
a4246 1
	flag = EGPS_S_V_GBL;
d4248 1
a4248 1
	flag = EGPS_S_V_SHR;
d4250 1
a4250 1
	flag = EGPS_S_V_EXE;
d4252 1
a4252 1
	flag = EGPS_S_V_WRT;
d4254 1
a4254 1
	flag = EGPS_S_V_VEC;
d4257 1
a4257 1
	  flag = no ? EGPS_S_V_NOMOD : EGPS_S_V_NOMOD << EGPS_S_V_NO_SHIFT;
d4261 1
a4261 1
	flag = EGPS_S_V_COM;
d4274 1
a4274 1
    return flag << EGPS_S_V_NO_SHIFT;
d4327 4
a4330 1
        bfd_vms_set_section_flags (stdoutput, sec, vms_flags);
@


1.83
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d78 4
d85 2
a86 1
  bfd_reloc_code_real_type reloc;
d452 1
a452 1
  bfd_reloc_code_real_type reloc;		/* Relocation before frob.  */
d573 1
a573 1
static void assemble_insn (const struct alpha_opcode *, const expressionS *, int, struct alpha_insn *, bfd_reloc_code_real_type);
d595 2
a596 1
      info = xcalloc (sizeof (struct alpha_reloc_tag) + len, 1);
d1773 3
a1775 2
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
d1797 1
a1797 1
			  &fixup->exp, pcrel, fixup->reloc);
d2012 1
a2012 1
	       bfd_reloc_code_real_type reloc)
d2135 2
a2136 1
	    = bfd_reloc_type_lookup (stdoutput, reloc);
d2179 1
a2179 1
			    &basereg, &newtok[1], opname);
d2226 1
a2226 1
				&basereg, &newtok[1], opname);
d3301 1
a3301 1
  bfd_reloc_code_real_type reloc = BFD_RELOC_UNUSED;
d3734 2
a3735 1
	  cur_frame_data = calloc (1, sizeof (*cur_frame_data));
d3791 1
a3791 1
	      expressionS *exp = xmalloc (sizeof (expressionS));
d3959 1
a3959 1
      first_file_directive = xmalloc (len + 1);
d5437 1
a5437 1
	  char *p = xmalloc (strlen (name));
d6219 2
a6220 2
  reloc = xmalloc (sizeof (* reloc));
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
@


1.82
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 2
a4 1
   2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
d597 1
a597 1
	as_fatal (errmsg);
d1989 1
a1989 1
	as_warn (errmsg);
d3606 1
a3606 1
        as_bad ("Length of .comm \"%s\" is already %ld. Not changed to %ld.",
d5124 1
a5124 1
  as_warn ("Unknown CPU identifier `%s'", name);
@


1.81
log
@2009-05-04  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-alpha.c: Also declare alpha_prologue_label for OBJ_EVAX.
@
text
@d1283 1
a1283 1
	assert (insn.nfixups == 1);
d1319 1
a1319 1
	assert (insn.nfixups == 1);
d1379 1
a1379 1
		    assert (insn.nfixups + 1 <= MAX_INSN_FIXUPS);
d1408 1
a1408 1
		    assert (insn.nfixups + 1 <= MAX_INSN_FIXUPS);
d1547 1
a1547 1
      assert (insn.nfixups == 1);
d1565 1
a1565 1
      assert (insn.nfixups < MAX_INSN_FIXUPS);
d1768 1
a1768 1
	  assert (reloc_howto);
d1782 1
a1782 1
	      assert (size >= 1 && size <= 4);
d2063 1
a2063 1
	  assert (reloc_operand == NULL);
d2093 1
a2093 1
	      assert (reloc_operand == NULL);
d2183 1
a2183 1
      assert (insn.nfixups < MAX_INSN_FIXUPS);
d2232 1
a2232 1
      assert (insn.nfixups < MAX_INSN_FIXUPS);
d2278 1
a2278 1
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
d2294 1
a2294 1
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
d2430 1
a2430 1
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
d2447 1
a2447 1
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
d2463 1
a2463 1
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
d2483 1
a2483 1
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
d2848 1
a2848 1
      assert (insn.nfixups < MAX_INSN_FIXUPS);
d2869 1
a2869 1
      assert (insn.nfixups < MAX_INSN_FIXUPS);
d4011 1
a4011 1
  assert (which >= 0 && which < (int) (sizeof (fns)/sizeof (*fns)));
d5297 1
a5297 1
  assert (alpha_gp_value == 0);
d5404 1
a5404 1
    assert (e.X_op == O_max);
d5785 1
a5785 1
      assert (fixP->fx_subsy == alpha_gp_symbol);
d5931 1
a5931 1
	assert (-(int) fixP->fx_r_type < (int) alpha_num_operands);
d6216 1
a6216 1
  assert ((int) fixp->fx_r_type > 0);
d6231 1
a6231 1
  assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);
@


1.80
log
@        * config/tc-alpha.c (alpha_prologue_label): Only define for ELF
        based targets.
        (s_alpha_comm): Only define "temp" and "log_align" local variables
        for EVAX targets.
@
text
@d358 1
a358 1
#ifdef OBJ_ELF
@


1.79
log
@2009-03-03  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>
	    Douglas B Rupp  <rupp@@gnat.com>

	* doc/as.texinfo (Overview): Mention -replace/-noreplace options
	for Alpha.
	* doc/c-alpha.texi (Alpha Options): Document -replace/-noreplace.
	* config/tc-alpha.h (TC_VALIDATE_FIX_SUB): Define to 1 (evax).
	(OBJ_SYMFIELD_TYPE): Remove.
	(tc_canonicalize_symbol_name): Define to evax_shorten_name.
	(TC_IMPLICIT_LCOMM_ALIGNMENT): For alignment to 3 on evax.
	(tc_frob_file_before_fix): Do not defined on evax.
	* config/tc-alpha.c: Always includes dwarf2dbg.h.
	Include vms.h if OBJ_EVAX.
	(struct alpha_fixup): Add xtrasym and procsym (evax only).
	(enum alpha_macro_arg): Remove trailing comma.
	(md_longopts): Add replace and noreplace arguments (evax only).
	(alpha_evax_proc_hash): New variable.
	(alpha_link_section): Make it global.
	(alpha_ctors_section, alpha_dtors_section): Removed.
	(alpha_ctors_symbol, alpha_dtors_symbol): Ditto.
	(alpha_lit8_section): Ifndef'ed on evax.
	(alpha_lit8_symbol): Ditto.
	(alpha_prologue_label): New variable.
	(alpha_linkage_symbol): New variable (evax only).
	(alpha_flag_replace): Ditto.
	(struct alpha_evax_procs): Add handler and handler_data field.
	(alpha_evax_proc): Now of type pointer.
	(alpha_linkage_fixup_root, alpha_linkage_fixup_tail): New variables.
	(struct alpha_reloc_tag): Add sym and psym fields (evax only).
	(get_alpha_reloc_tag): Initialize sym and psym fields (evax only).
	(alpha_adjust_relocs): Ifndef'ed on evax.
	(load_expression): Add opname argument.
	Implement LDA/BSR optimization for evax.
	(emit_lda): Adjust for new prototype of load_expression.
	(emit_ir_load): Ditto. Do not nothing for GP if ..lk symbols.
	(emit_loadstore): Likewise.
	(emit_ldXu): Likewise.
	(emit_stX): Likewise.
	(emit_jsrjmp): Likewise.  Implement LDA/BSR optimization for evax.
	(emit_ldgp): Avoid warning in evax case.
	(add_to_link_pool): Make it static.  Return symbolic expression rather
	than number expression for the offset.
	(s_alpha_text): Create .text symbol for evax if not already created.
	(s_alpha_comm): Do not create specific section for common symbol.
	Fill common area with zeros for evax.
	(s_alpha_prologue): Create alpha_prologue_label.
	(s_alpha_section_name): New function (evax).
	(s_alpha_section_word): Likewise.
	(section_name): New static variabke moved out from ...
	(s_alpha_section): ... here.  Create new sections on demand.
	(s_alpha_literals): New function (evax).
	(s_alpha_ent): Create alpha_evax_proc instance and insert it in the
	alpha_evax_proc_hash table.
	(s_alpha_handler): New function (evax).
	(s_alpha_frame): Adjust for new type of alpha_evax_proc.
	(s_alpha_prologue): New function (evax).
	(s_alpha_pdesc): Adjust for new type of alpha_evax_proc and new
	handling of procedures with hash table.
	Add support for condition handlers.
	(s_alpha_linkage): Create linkage_fixup instance and chain it.
	(s_alpha_fp_save): Adjust for new type of alpha_evax_proc.
	(s_alpha_mask): Likewise.
	(s_alpha_fmask): Likewise.
	(s_alpha_end): Clear alpha_evax_proc.
	(s_alpha_align): Increase max_alignment to 16.
	(alpha_print_token): Call print_expr_1 instead of print_expr.
	(md_pseudo_table): Add "section", "literals", "handler" and
	"handler_data" (evax).  Do not ignore "prologue" on evax.
	Fix indentation.
	(md_begin): Create hash table for alpha_evax_proc_hash.
	(md_parse_option): Handle OPTION_REPLACE and OPTION_NOREPLACE.
	(md_show_usage): Mention -replace/-noreplace for evax.
	(md_apply_fix): Handle evax relocs (_NOP, _LDA, _BSR and _BOH).
	(alpha_force_relocation): Likewise.
	(alpha_fix_adjustable): Likewise. Add BFD_RELOC_16 case.
	(tc_gen_reloc): Likewise.  Add BFD_RELOC_ALPHA_LINKAGE for evax.
	(emit_insn): New cases for evax specific relocs.
	(assemble_insn): Fix indentation.
	Take care of -MDISP in operand table.
	* config/obj-evax.h (struct alpha_linkage_fixups): New struct.
	(OBJ_SYMFIELD_TYPE): New macro.
	(obj_symbol_new_hook): Define.
	(obj_frob_symbol, obj_frob_file_before_adjust): Ditto.
	(obj_frob_file_before_fix): Ditto.
	(PDSC_S_M_HANDLER_VALID): New macro.
	(PDSC_S_M_HANDLER_DATA_VALID): Ditto.
	(TC_IMPLICIT_LCOMM_ALIGNMENT): Remove.
	Add prototypes for functions declared in obj-evax.c
	* config/obj-evax.c: Include subsegs.h, struc-symbol.h, safe-ctype.h.
	(s_evax_weak): Convert to ansi-C.
	(evax_symbol_new_hook): New function.
	(evax_frob_symbol): Ditto.
	(evax_frob_file_before_adjust): Ditto.
	(evax_frob_file_before_fix): Ditto.
	(evax_shorten_name): Ditto.
	(crc32): Ditto.
	(encode_32): Ditto.
	(encode_16): Ditto.
	(decode_16): Ditto.
	(shorten_identifier): Ditto.
	(is_truncated_identifier): Ditto.
	* dwarf2dbg.c (out_debug_info): Do not append trailing slash on	VMS.
	* as.c (close_output_file): Remove #ifndef OBJ_VMS.
	(main): Ditto.
@
text
@d358 1
d360 1
d3478 1
a3478 1
  offsetT temp, size;
d3480 2
d3483 1
@


1.78
log
@        * include/elf/ia64.h (SHT_IA_64_VMS_DISPLAY_NAME_INFO,
        EF_IA_64_ARCHVER_1): New macros. Minor reformatting.

        * bfd/Makefile.am (BFD32_BACKENDS): Add new object vmsutil.lo
        (BFD32_BACKENDS_CFILES): Add new file vmsutil.c
        (vmsutil.lo): Add dependency rule
        * bfd/Makefile.in: Regenerate
        * bfd/config.bfd (ia64*-*-*vms*): Add case.
        * bfd/configure.in (bfd_elf64_ia64_vms_vec): Add case.
        * bfd/configure: Regenerate
        * bfd/vmsutil.[ch]: New files
        * bfd/elf-bfd.h (struct bfd_elf_special_section): Change type of
        attr to bfd_vma.
        * bfd/elfxx-ia64.c (elfNN_vms_post_process_headers,
        elfNN_vms_section_processing, elfNN_vms_final_write_processing,
        elfNN_vms_close_and_cleanup, elfNN_vms_section_from_shdr,
        elfNN_vms_object_p): New functions
        * bfd/targets.c (bfd_elf64_ia64_vms_vec): New target.

        * gas/configure.tgt(ia64-*-*vms*): New target.
        * gas/dwarf2dbg.h (dwarf2_loc_mark_labels): Make extern.
        * gas/tc.h (md_number_to_chars): Declare iff undefined.
        * gas/config/obj-elf.c (obj_elf_change_section): Change type of
        arg attr to bfd_vma.
        (obj_elf_parse_section_letters): Return a bfd_vma. Change type of
        variables attr, md_attr to bfd_vma.
        (obj_elf_section_word): Likewise.
        (obj_elf_section): Change type of variable attr to bfd_vma
        * gas/config/obj-elf.h (obj_elf_change_section): Change type of
        arg attr to bfd_vma
        * gas/config/tc-ia64.c (bfdver.h,time.h): Include.
        (ia64_elf_section_letter): Now returns a bfd_vma.
        Handle VMS specific attributes.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (ia64_init): Don't turn on dependency checking for VMS.
        (ia64_target_format): Check for VMS flag bit.
        (do_alias): Hande decc$ functions.
        (get_vms_time): New function.
        (ia64_vms_note): New function.
        * gas/config/tc-ia64.h (ia64_elf_section_letter): Now returns a bfd_vma.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (tc_init_after_args): Define for VMS.
        * gas/config/tc-alpha.c (alpha_elf_section_letter): Return a bfd_vma.
        (alpha_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-alpha.h: Likewise.
        * gas/config/tc-i386.c (x86_64_section_letter): Return a bfd_vma.
        (x86_64_section_word): Return a bfd_vma.
        * gas/config/tc-i386.h: Likewise.
        * gas/config/tc-ip2k.c (ip2k_elf_section_flags): Change type of arg
        attr to bfd_vma.
        * gas/config/tc-ip2k.h: Likewise.
        * gas/config/tc-mep.c (mep_elf_section_letter): Return a bfd_vma.
        (mep_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-mep.h: Likewise.
        * gas/config/tc-ppc.c  (ppc_section_letter): Return a bfd_vma.
        (ppc_section_word): Return a bfd_vma.
        (ppc_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-ppc.h: Likewise.
        * gas/config/te-vms.h (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,
        DWAR2_FILE_TIME_NAME, DWARF2_FILE_SIZE_NAME, DWARF2_FILEN_NAME):
        New file with new macros
        * gas/dwarf2dbg.c (get_filenum, out_file_list): Default and call new
        macros.
@
text
@a59 1
#include "dwarf2dbg.h"
d62 5
d81 3
d102 1
a102 1
    MACRO_EXP,
d255 6
d284 3
d318 1
a318 3
static segT alpha_link_section;
static segT alpha_ctors_section;
static segT alpha_dtors_section;
d320 1
d322 1
a329 2
static symbolS *alpha_ctors_symbol;
static symbolS *alpha_dtors_symbol;
d331 1
d333 1
d358 6
d383 5
d396 1
a396 1
static struct
d409 8
a416 1
} alpha_evax_proc;
d488 4
d568 4
d595 4
d604 2
d769 2
d1229 2
a1230 1
		 expressionS *poffset)
a1321 2
	offsetT link;

d1324 1
a1324 1
	if (exp->X_add_symbol == alpha_evax_proc.symbol)
d1344 6
a1349 1
	    if (!range_signed_32 (addend))
d1351 70
a1420 3
		link = add_to_link_pool (alpha_evax_proc.symbol,
					 exp->X_add_symbol, addend);
		addend = 0;
d1423 2
a1424 2
	      link = add_to_link_pool (alpha_evax_proc.symbol,
				       exp->X_add_symbol, 0);
d1426 9
a1434 4
	    set_tok_reg (newtok[0], targreg);
	    set_tok_const (newtok[1], link);
	    set_tok_preg (newtok[2], basereg);
	    assemble_tokens_to_insn ("ldq", newtok, 3, &insn);
d1464 1
a1464 1
      assemble_tokens ("lda", newtok, 3, 0);
d1486 3
d1491 1
d1496 2
a1497 2
      lit = add_to_link_pool (alpha_evax_proc.symbol,
			      section_symbol (absolute_section), addend);
d1499 1
a1499 1
      set_tok_const (newtok[1], lit);
d1658 1
a1658 1
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL);
a1768 1
	  assert (size >= 1 && size <= 4);
d1770 13
d1929 12
d2120 3
a2122 2
	 the relocation width should match the operand width.  */
      else if (reloc < BFD_RELOC_UNUSED)
d2158 3
d2167 2
a2168 2
  lituse = load_expression (tok[0].X_add_number, &tok[1], &basereg,
			    &newtok[1]);
d2170 4
d2214 2
a2215 1
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1]);
d2266 1
a2266 1
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL);
d2418 1
a2418 1
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL);
d2828 2
a2829 1
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL);
d2835 1
a2835 3
#ifdef OBJ_EVAX
  /* FIXME: Add hint relocs to BFD for evax.  */
#else
d2853 35
d2984 4
a2987 1
#endif /* OBJ_ECOFF || OBJ_ELF */
d3356 1
a3356 1
valueT
a3363 1
  bfd_reloc_code_real_type reloc_type;
d3367 4
a3370 2

  offset = - *symbol_get_obj (basesym);
d3379 1
a3379 1
	 fixp = fixp->fx_next, offset += 8)
d3381 11
a3391 7
	if (fixp->fx_addsy == sym && fixp->fx_offset == addend)
	  {
	    if (range_signed_16 (offset))
	      {
		return offset;
	      }
	  }
d3397 2
d3402 10
a3411 2
  fix_new (frag_now, p - frag_now->fr_literal, 8, sym, addend, 0,
	   BFD_RELOC_64);
d3415 1
a3415 1
  return offset;
a3416 1

a3425 1

d3432 13
d3468 1
a3468 2
/* Handle the OSF/1 and openVMS .comm pseudo quirks.
   openVMS constructs a section for every common symbol.  */
d3476 1
a3476 1
  offsetT temp;
d3478 1
a3478 5
#ifdef OBJ_EVAX
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_seg;
#endif
d3495 1
a3495 1
  if ((temp = get_absolute_expression ()) < 0)
d3497 1
a3497 1
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
d3504 8
d3514 8
a3521 3
  /* Make a section for the common symbol.  */
  new_seg = subseg_new (xstrdup (name), 0);
#endif
d3523 3
a3525 1
  *p = c;
a3526 2
#ifdef OBJ_EVAX
  /* Alignment might follow.  */
d3529 1
a3529 1
      offsetT align;
d3531 12
d3544 24
a3567 2
      align = get_absolute_expression ();
      bfd_set_section_alignment (stdoutput, new_seg, align);
d3569 21
a3589 1
#endif
d3591 1
a3591 6
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }
d3593 1
a3593 8
#ifdef OBJ_EVAX
  if (bfd_section_size (stdoutput, new_seg) > 0)
    {
      if (bfd_section_size (stdoutput, new_seg) != temp)
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) bfd_section_size (stdoutput, new_seg),
		(long) temp);
d3595 2
a3596 1
#else
d3599 5
a3603 5
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
a3604 1
#endif
d3607 2
a3608 8
#ifdef OBJ_EVAX
      subseg_set (new_seg, 0);
      p = frag_more (temp);
      new_seg->flags |= SEC_IS_COMMON;
      S_SET_SEGMENT (symbolP, new_seg);
#else
      S_SET_VALUE (symbolP, (valueT) temp);
      S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
d3612 3
a3614 3

#ifdef OBJ_EVAX
  subseg_set (current_section, current_subsec);
a3615 3

  know (symbol_get_frag (symbolP) == &zero_address_frag);

d3893 2
d4158 97
d4257 5
d4266 4
a4269 3
#define EVAX_SECTION_COUNT 5
  static char *section_name[EVAX_SECTION_COUNT + 1] =
    { "NULL", ".rdata", ".comm", ".link", ".ctors", ".dtors" };
d4271 35
a4305 1
  if ((secid <= 0) || (secid > EVAX_SECTION_COUNT))
d4307 2
a4308 3
      as_fatal (_("Unknown section directive"));
      demand_empty_rest_of_line ();
      return;
d4310 11
a4320 2
  temp = get_absolute_expression ();
  subseg_new (section_name[secid], 0);
d4335 15
a4349 10
  alpha_evax_proc.pdsckind = 0;
  alpha_evax_proc.framereg = -1;
  alpha_evax_proc.framesize = 0;
  alpha_evax_proc.rsa_offset = 0;
  alpha_evax_proc.ra_save = AXP_REG_RA;
  alpha_evax_proc.fp_save = -1;
  alpha_evax_proc.imask = 0;
  alpha_evax_proc.fmask = 0;
  alpha_evax_proc.prologue = 0;
  alpha_evax_proc.type = 0;
d4362 5
a4366 1
  alpha_evax_proc.symbol = symbol;
d4371 29
d4407 1
a4407 1
  alpha_evax_proc.framereg = tc_get_register (1);
d4419 1
a4419 1
  alpha_evax_proc.framesize = val;
d4430 12
a4441 1
  alpha_evax_proc.rsa_offset = get_absolute_expression ();
a4448 1
  long val;
d4454 3
d4465 2
a4466 2
  if ((alpha_evax_proc.symbol == 0)
      || (!S_IS_DEFINED (alpha_evax_proc.symbol)))
d4468 1
a4468 1
      as_fatal (_(".pdesc has no matching .ent"));
d4472 13
a4484 6

  *symbol_get_obj (alpha_evax_proc.symbol) =
    (valueT) seginfo->literal_pool_size;

  expression (&exp);
  if (exp.X_op != O_symbol)
d4486 1
a4486 1
      as_warn (_(".pdesc directive has no entry symbol"));
d4491 2
a4492 4
  entry_sym = make_expr_symbol (&exp);
  /* Save bfd symbol of proc desc in function symbol.  */
  symbol_get_bfdsym (alpha_evax_proc.symbol)->udata.p
    = symbol_get_bfdsym (entry_sym);
d4494 7
d4514 1
a4514 1
    alpha_evax_proc.pdsckind = PDSC_S_K_KIND_FP_STACK;
d4517 1
a4517 1
    alpha_evax_proc.pdsckind = PDSC_S_K_KIND_FP_REGISTER;
d4520 1
a4520 1
    alpha_evax_proc.pdsckind = PDSC_S_K_KIND_NULL;
d4542 4
a4545 2
  *p = alpha_evax_proc.pdsckind
    | ((alpha_evax_proc.framereg == 29) ? PDSC_S_M_BASE_REG_IS_FP : 0);
d4548 1
a4548 1
  switch (alpha_evax_proc.pdsckind)
d4555 2
a4556 2
      *(p + 2) = alpha_evax_proc.fp_save;
      *(p + 3) = alpha_evax_proc.ra_save;
d4559 1
a4559 1
      md_number_to_chars (p + 2, (valueT) alpha_evax_proc.rsa_offset, 2);
d4566 1
a4566 1
  *(p + 5) = alpha_evax_proc.type & 0x0f;
d4573 1
a4573 1
  if (alpha_evax_proc.pdsckind == PDSC_S_K_KIND_NULL)
d4577 2
a4578 2
  p = frag_more (8);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
d4580 2
a4581 2
  seginfo->literal_pool_size += 8;

d4583 1
a4583 1
  md_number_to_chars (p, (valueT) alpha_evax_proc.framesize, 4);
d4588 4
a4591 1
  md_number_to_chars (p + 6, alpha_evax_proc.prologue, 2);
d4593 1
a4593 1
  if (alpha_evax_proc.pdsckind == PDSC_S_K_KIND_FP_REGISTER)
d4604 19
a4622 2
  md_number_to_chars (p, alpha_evax_proc.imask, 4);
  md_number_to_chars (p + 4, alpha_evax_proc.fmask, 4);
d4667 1
d4680 2
d4684 26
a4709 2
      fix_new_exp (frag_now, p - frag_now->fr_literal, LKP_S_K_SIZE, &exp, 0,\
		   BFD_RELOC_ALPHA_LINKAGE);
d4741 1
a4741 1
  alpha_evax_proc.fp_save = tc_get_register (1);
d4758 1
a4758 1
      alpha_evax_proc.imask = val;
d4776 1
a4776 1
      alpha_evax_proc.fmask = val;
d4790 1
a4790 1
  alpha_evax_proc.symbol = 0;
d5014 1
a5014 1
  long max_alignment = 15;
d5141 1
a5141 1
	print_expr (f, &nexp);
d5146 1
a5146 1
      print_expr (f, exp);
d5172 20
a5191 16
  { "pdesc", s_alpha_pdesc, 0},
  { "name", s_alpha_name, 0},
  { "linkage", s_alpha_linkage, 0},
  { "code_address", s_alpha_code_address, 0},
  { "ent", s_alpha_ent, 0},
  { "frame", s_alpha_frame, 0},
  { "fp_save", s_alpha_fp_save, 0},
  { "mask", s_alpha_mask, 0},
  { "fmask", s_alpha_fmask, 0},
  { "end", s_alpha_end, 0},
  { "file", s_alpha_file, 0},
  { "rdata", s_alpha_section, 1},
  { "comm", s_alpha_comm, 0},
  { "link", s_alpha_section, 3},
  { "ctors", s_alpha_section, 4},
  { "dtors", s_alpha_section, 5},
d5216 3
d5221 1
d5492 1
d5627 8
d5674 3
a5676 2
-+			hash encode (don't truncate) names longer than 64 characters\n\
-H			show new symbol after hash truncation\n"),
d5841 73
d6083 6
d6128 1
d6182 7
d6249 56
@


1.77
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d4783 1
a4783 1
int
d4796 1
a4796 1
alpha_elf_section_flags (flagword flags, int attr, int type ATTRIBUTE_UNUSED)
@


1.76
log
@	* config/tc-alpha.c (assemble_insn): Don't segv on NULL reloc_operand.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
d3726 1
a3726 1
  static void (* const fns[]) PARAMS ((int)) = {
a4741 1
static inline void maybe_set_gp PARAMS ((asection *));
@


1.75
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1971 2
a1972 1
	  if (reloc_howto->bitsize != reloc_operand->bits)
@


1.74
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@a5022 5
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

extern char *vax_md_atof (int, char *, int *);

d5026 1
a5026 4
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;
d5032 1
a5032 1
      /* VAX md_atof doesn't like "G" for some reason.  */
a5037 19
      /* IEEE floats.  */
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

d5039 1
a5039 2
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
a5040 12
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
a5671 1
#define md_atof vax_md_atof
@


1.73
log
@Switch to GPLv3
@
text
@d4530 1
a4530 1
  stringer (terminate);
@


1.72
log
@PR gas/4124
* config/tc-alpha.c (emit_ustX): Fix ustq code generation.
@
text
@d14 1
a14 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.71
log
@	* config/tc-ppc.c (ppc_pe_comm): Set bfd_com_section segment.
	* config/tc-alpha.c (s_alpha_comm): Likewise.  Also, remove
	redundant check.
	* read.c (s_lsym): Remove non-BFD assembler sym handling.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d2386 6
a2394 6
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("stq_u", newtok, 3, 1);

  /* Emit "stq_u $t10, size-1($at)".  */
  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
@


1.70
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d3334 1
a3334 2
      if (! S_IS_DEFINED (symbolP))
	S_SET_SEGMENT (symbolP, new_seg);
d3337 1
@


1.69
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d5467 3
@


1.68
log
@        * config/tc-alpha.c (O_lituse_jsrdirect): New.
        (alpha_reloc_op): Add it.
        (debug_exp): Handle it.
        (DUMMY_RELOC_LITUSE_JSRDIRECT): New.
        (emit_insn): Handle it.
        * doc/c-alpha.texi (Alpha-Relocs): Document lituse_jsrdirect.
@
text
@d5207 1
a5207 1
md_apply_fix3 (fixS *fixP, valueT * valP, segT seg)
@


1.67
log
@Update the address and phone number of the FSF
@
text
@d112 23
a134 22
#define O_literal	O_md3	/* !literal relocation.  */
#define O_lituse_addr	O_md4	/* !lituse_addr relocation.  */
#define O_lituse_base	O_md5	/* !lituse_base relocation.  */
#define O_lituse_bytoff	O_md6	/* !lituse_bytoff relocation.  */
#define O_lituse_jsr	O_md7	/* !lituse_jsr relocation.  */
#define O_lituse_tlsgd	O_md8	/* !lituse_tlsgd relocation.  */
#define O_lituse_tlsldm	O_md9	/* !lituse_tlsldm relocation.  */
#define O_gpdisp	O_md10	/* !gpdisp relocation.  */
#define O_gprelhigh	O_md11	/* !gprelhigh relocation.  */
#define O_gprellow	O_md12	/* !gprellow relocation.  */
#define O_gprel		O_md13	/* !gprel relocation.  */
#define O_samegp	O_md14	/* !samegp relocation.  */
#define O_tlsgd		O_md15	/* !tlsgd relocation.  */
#define O_tlsldm	O_md16	/* !tlsldm relocation.  */
#define O_gotdtprel	O_md17	/* !gotdtprel relocation.  */
#define O_dtprelhi	O_md18	/* !dtprelhi relocation.  */
#define O_dtprello	O_md19	/* !dtprello relocation.  */
#define O_dtprel	O_md20	/* !dtprel relocation.  */
#define O_gottprel	O_md21	/* !gottprel relocation.  */
#define O_tprelhi	O_md22	/* !tprelhi relocation.  */
#define O_tprello	O_md23	/* !tprello relocation.  */
#define O_tprel		O_md24	/* !tprel relocation.  */
d142 1
d423 1
d776 1
d1727 3
@


1.66
log
@2005-04-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-aout.h (S_IS_EXTERN): Removed.
	* config/obj-bout.h (S_IS_EXTERN): Likewise.
	* config/obj-coff.h (S_IS_EXTERN): Likewise.
	* symbols.c (S_IS_EXTERN): Likewise.
	* symbols.h (S_IS_EXTERN): Likewise.

	* config/tc-alpha.c (tc_gen_reloc): Replace S_IS_EXTERN with
	S_IS_EXTERNAL.
	* config/tc-d10v.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_fix_adjustable): Likewise.
	* config/tc-iq2000.c (iq2000_fix_adjustable): Likewise.
	* config/tc-m32r.c (m32r_fix_adjustable): Likewise.
	* config/tc-mmix.c (mmix_adjust_symtab): Likewise.
	* config/tc-sh64.c (shmedia_frob_file_before_adjust): Likewise.
	(shmedia_md_convert_frag): Likewise.
	* symbols.c (print_symbol_value_1): Likewise.
	* write.c (write_object_file): Likewise.
@
text
@d24 2
a25 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.65
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d5640 1
a5640 1
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)
@


1.64
log
@update copyright dates
@
text
@d27 23
a49 25
/*
 * Mach Operating System
 * Copyright (c) 1993 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
a60 1
#include "dw2gencfi.h"
d63 1
d68 4
a71 5
#define TOKENIZE_ERROR -1
#define TOKENIZE_ERROR_REPORT -2

#define MAX_INSN_FIXUPS 2
#define MAX_INSN_ARGS 5
d101 2
a102 2
  void (*emit) PARAMS ((const expressionS *, int, const PTR));
  const PTR arg;
d108 2
a109 2
#define O_pregister	O_md1	/* O_register, in parentheses */
#define O_cpregister	O_md2	/* + a leading comma */
d112 22
a133 22
#define O_literal	O_md3	/* !literal relocation */
#define O_lituse_addr	O_md4	/* !lituse_addr relocation */
#define O_lituse_base	O_md5	/* !lituse_base relocation */
#define O_lituse_bytoff	O_md6	/* !lituse_bytoff relocation */
#define O_lituse_jsr	O_md7	/* !lituse_jsr relocation */
#define O_lituse_tlsgd	O_md8	/* !lituse_tlsgd relocation */
#define O_lituse_tlsldm	O_md9	/* !lituse_tlsldm relocation */
#define O_gpdisp	O_md10	/* !gpdisp relocation */
#define O_gprelhigh	O_md11	/* !gprelhigh relocation */
#define O_gprellow	O_md12	/* !gprellow relocation */
#define O_gprel		O_md13	/* !gprel relocation */
#define O_samegp	O_md14	/* !samegp relocation */
#define O_tlsgd		O_md15	/* !tlsgd relocation */
#define O_tlsldm	O_md16	/* !tlsldm relocation */
#define O_gotdtprel	O_md17	/* !gotdtprel relocation */
#define O_dtprelhi	O_md18	/* !dtprelhi relocation */
#define O_dtprello	O_md19	/* !dtprello relocation */
#define O_dtprel	O_md20	/* !dtprel relocation */
#define O_gottprel	O_md21	/* !gottprel relocation */
#define O_tprelhi	O_md22	/* !tprelhi relocation */
#define O_tprello	O_md23	/* !tprello relocation */
#define O_tprel		O_md24	/* !tprel relocation */
a205 83
/* Prototypes for all local functions.  */

static struct alpha_reloc_tag *get_alpha_reloc_tag PARAMS ((long));
static void alpha_adjust_relocs PARAMS ((bfd *, asection *, PTR));

static int tokenize_arguments PARAMS ((char *, expressionS *, int));
static const struct alpha_opcode *find_opcode_match
  PARAMS ((const struct alpha_opcode *, const expressionS *, int *, int *));
static const struct alpha_macro *find_macro_match
  PARAMS ((const struct alpha_macro *, const expressionS *, int *));
static unsigned insert_operand
  PARAMS ((unsigned, const struct alpha_operand *, offsetT, char *, unsigned));
static void assemble_insn
  PARAMS ((const struct alpha_opcode *, const expressionS *, int,
	   struct alpha_insn *, bfd_reloc_code_real_type));
static void emit_insn PARAMS ((struct alpha_insn *));
static void assemble_tokens_to_insn
  PARAMS ((const char *, const expressionS *, int, struct alpha_insn *));
static void assemble_tokens
  PARAMS ((const char *, const expressionS *, int, int));

static long load_expression
  PARAMS ((int, const expressionS *, int *, expressionS *));

static void emit_ldgp PARAMS ((const expressionS *, int, const PTR));
static void emit_division PARAMS ((const expressionS *, int, const PTR));
static void emit_lda PARAMS ((const expressionS *, int, const PTR));
static void emit_ldah PARAMS ((const expressionS *, int, const PTR));
static void emit_ir_load PARAMS ((const expressionS *, int, const PTR));
static void emit_loadstore PARAMS ((const expressionS *, int, const PTR));
static void emit_jsrjmp PARAMS ((const expressionS *, int, const PTR));
static void emit_ldX PARAMS ((const expressionS *, int, const PTR));
static void emit_ldXu PARAMS ((const expressionS *, int, const PTR));
static void emit_uldX PARAMS ((const expressionS *, int, const PTR));
static void emit_uldXu PARAMS ((const expressionS *, int, const PTR));
static void emit_ldil PARAMS ((const expressionS *, int, const PTR));
static void emit_stX PARAMS ((const expressionS *, int, const PTR));
static void emit_ustX PARAMS ((const expressionS *, int, const PTR));
static void emit_sextX PARAMS ((const expressionS *, int, const PTR));
static void emit_retjcr PARAMS ((const expressionS *, int, const PTR));

static void s_alpha_text PARAMS ((int));
static void s_alpha_data PARAMS ((int));
#ifndef OBJ_ELF
static void s_alpha_comm PARAMS ((int));
static void s_alpha_rdata PARAMS ((int));
#endif
#ifdef OBJ_ECOFF
static void s_alpha_sdata PARAMS ((int));
#endif
#ifdef OBJ_ELF
static void s_alpha_section PARAMS ((int));
static void s_alpha_ent PARAMS ((int));
static void s_alpha_end PARAMS ((int));
static void s_alpha_mask PARAMS ((int));
static void s_alpha_frame PARAMS ((int));
static void s_alpha_prologue PARAMS ((int));
static void s_alpha_file PARAMS ((int));
static void s_alpha_loc PARAMS ((int));
static void s_alpha_stab PARAMS ((int));
static void s_alpha_coff_wrapper PARAMS ((int));
static void s_alpha_usepv PARAMS ((int));
#endif
#ifdef OBJ_EVAX
static void s_alpha_section PARAMS ((int));
#endif
static void s_alpha_gprel32 PARAMS ((int));
static void s_alpha_float_cons PARAMS ((int));
static void s_alpha_proc PARAMS ((int));
static void s_alpha_set PARAMS ((int));
static void s_alpha_base PARAMS ((int));
static void s_alpha_align PARAMS ((int));
static void s_alpha_stringer PARAMS ((int));
static void s_alpha_space PARAMS ((int));
static void s_alpha_ucons PARAMS ((int));
static void s_alpha_arch PARAMS ((int));

static void create_literal_section PARAMS ((const char *, segT *, symbolS **));
#ifndef OBJ_ELF
static void select_gp_value PARAMS ((void));
#endif
static void alpha_align PARAMS ((int, char *, symbolS *, int));

d367 3
a369 2
static struct {
  symbolS *symbol;	/* proc pdesc symbol */
d371 2
a372 2
  int framereg;		/* register for frame pointer */
  int framesize;	/* size of frame */
d405 6
a410 6
  const char *name;				/* string to lookup */
  size_t length;				/* size of the string */
  operatorT op;					/* which operator to use */
  bfd_reloc_code_real_type reloc;		/* relocation before frob */
  unsigned int require_seq : 1;			/* require a sequence number */
  unsigned int allow_seq : 1;			/* allow a sequence number */
d414 22
a435 22
  DEF(literal, BFD_RELOC_ALPHA_ELF_LITERAL, 0, 1),
  DEF(lituse_addr, DUMMY_RELOC_LITUSE_ADDR, 1, 1),
  DEF(lituse_base, DUMMY_RELOC_LITUSE_BASE, 1, 1),
  DEF(lituse_bytoff, DUMMY_RELOC_LITUSE_BYTOFF, 1, 1),
  DEF(lituse_jsr, DUMMY_RELOC_LITUSE_JSR, 1, 1),
  DEF(lituse_tlsgd, DUMMY_RELOC_LITUSE_TLSGD, 1, 1),
  DEF(lituse_tlsldm, DUMMY_RELOC_LITUSE_TLSLDM, 1, 1),
  DEF(gpdisp, BFD_RELOC_ALPHA_GPDISP, 1, 1),
  DEF(gprelhigh, BFD_RELOC_ALPHA_GPREL_HI16, 0, 0),
  DEF(gprellow, BFD_RELOC_ALPHA_GPREL_LO16, 0, 0),
  DEF(gprel, BFD_RELOC_GPREL16, 0, 0),
  DEF(samegp, BFD_RELOC_ALPHA_BRSGP, 0, 0),
  DEF(tlsgd, BFD_RELOC_ALPHA_TLSGD, 0, 1),
  DEF(tlsldm, BFD_RELOC_ALPHA_TLSLDM, 0, 1),
  DEF(gotdtprel, BFD_RELOC_ALPHA_GOTDTPREL16, 0, 0),
  DEF(dtprelhi, BFD_RELOC_ALPHA_DTPREL_HI16, 0, 0),
  DEF(dtprello, BFD_RELOC_ALPHA_DTPREL_LO16, 0, 0),
  DEF(dtprel, BFD_RELOC_ALPHA_DTPREL16, 0, 0),
  DEF(gottprel, BFD_RELOC_ALPHA_GOTTPREL16, 0, 0),
  DEF(tprelhi, BFD_RELOC_ALPHA_TPREL_HI16, 0, 0),
  DEF(tprello, BFD_RELOC_ALPHA_TPREL_LO16, 0, 0),
  DEF(tprel, BFD_RELOC_ALPHA_TPREL16, 0, 0),
d444 1
a444 1
/* Maximum # digits needed to hold the largest sequence # */
d450 7
a456 7
  fixS *master;			/* the literal reloc */
  fixS *slaves;			/* head of linked list of lituses */
  segT segment;			/* segment relocs are in or undefined_section*/
  long sequence;		/* sequence # */
  unsigned n_master;		/* # of literals */
  unsigned n_slaves;		/* # of lituses */
  unsigned saw_tlsgd : 1;	/* true if ... */
d460 2
a461 2
  unsigned multi_section_p : 1;	/* true if more than one section was used */
  char string[1];		/* printable form of sequence to hash with */
d464 1
a464 1
/* Hash table to link up literals with the appropriate lituse */
d513 10
a522 1
/* The macro table */
d524 6
a529 1
static const struct alpha_macro alpha_macros[] =
d531 2
a532 5
/* Load/Store macros */
  { "lda",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldah",	emit_ldah, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
d534 1
a534 18
  { "ldl",	emit_ir_load, "ldl",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldl_l",	emit_ir_load, "ldl_l",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq",	emit_ir_load, "ldq",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq_l",	emit_ir_load, "ldq_l",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq_u",	emit_ir_load, "ldq_u",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldf",	emit_loadstore, "ldf",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldg",	emit_loadstore, "ldg",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "lds",	emit_loadstore, "lds",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldt",	emit_loadstore, "ldt",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d536 5
a540 8
  { "ldb",	emit_ldX, (PTR) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldbu",	emit_ldXu, (PTR) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldw",	emit_ldX, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldwu",	emit_ldXu, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d542 1
a542 10
  { "uldw",	emit_uldX, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldwu",	emit_uldXu, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldl",	emit_uldX, (PTR) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldlu",	emit_uldXu, (PTR) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldq",	emit_uldXu, (PTR) 3,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d544 7
a550 2
  { "ldgp",	emit_ldgp, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA } },
d552 2
a553 6
  { "ldi",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldil",	emit_ldil, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldiq",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
d555 10
a564 18
  { "stl",	emit_loadstore, "stl",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stl_c",	emit_loadstore, "stl_c",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq",	emit_loadstore, "stq",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq_c",	emit_loadstore, "stq_c",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq_u",	emit_loadstore, "stq_u",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stf",	emit_loadstore, "stf",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stg",	emit_loadstore, "stg",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "sts",	emit_loadstore, "sts",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stt",	emit_loadstore, "stt",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d566 5
a570 10
  { "stb",	emit_stX, (PTR) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stw",	emit_stX, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustw",	emit_ustX, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustl",	emit_ustX, (PTR) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustq",	emit_ustX, (PTR) 3,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d572 3
a574 1
/* Arithmetic macros */
d576 7
a582 8
  { "sextb",	emit_sextX, (PTR) 0,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },
  { "sextw",	emit_sextX, (PTR) 1,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },
d584 24
a607 40
  { "divl",	emit_division, "__divl",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divlu",	emit_division, "__divlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divq",	emit_division, "__divq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divqu",	emit_division, "__divqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "reml",	emit_division, "__reml",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remlu",	emit_division, "__remlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remq",	emit_division, "__remq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remqu",	emit_division, "__remqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
d609 6
a614 32
  { "jsr",	emit_jsrjmp, "jsr",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "jmp",	emit_jsrjmp, "jmp",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "ret",	emit_retjcr, "ret",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jcr",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jsr_coroutine",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
};
d616 6
a621 4
static const unsigned int alpha_num_macros
  = sizeof (alpha_macros) / sizeof (*alpha_macros);

/* Public interface functions */
d623 6
a628 3
/* This function is called once, at assembler startup time.  It sets
   up all the tables, etc. that the MD part of the assembler will
   need, that can be determined before arguments are parsed.  */
d630 13
a642 4
void
md_begin ()
{
  unsigned int i;
d644 3
a646 6
  /* Verify that X_op field is wide enough.  */
  {
    expressionS e;
    e.X_op = O_max;
    assert (e.X_op == O_max);
  }
d648 1
a648 3
  /* Create the opcode hash table.  */
  alpha_opcode_hash = hash_new ();
  for (i = 0; i < alpha_num_opcodes;)
d650 18
a667 1
      const char *name, *retval, *slash;
d669 4
a672 5
      name = alpha_opcodes[i].name;
      retval = hash_insert (alpha_opcode_hash, name, (PTR) &alpha_opcodes[i]);
      if (retval)
	as_fatal (_("internal error: can't hash opcode `%s': %s"),
		  name, retval);
d674 14
a687 4
      /* Some opcodes include modifiers of various sorts with a "/mod"
	 syntax, like the architecture manual suggests.  However, for
	 use with gcc at least, we also need access to those same opcodes
	 without the "/".  */
d689 12
a700 5
      if ((slash = strchr (name, '/')) != NULL)
	{
	  char *p = xmalloc (strlen (name));
	  memcpy (p, name, slash - name);
	  strcpy (p + (slash - name), slash + 1);
d702 2
a703 3
	  (void) hash_insert (alpha_opcode_hash, p, (PTR) &alpha_opcodes[i]);
	  /* Ignore failures -- the opcode table does duplicate some
	     variants in different forms, like "hw_stq" and "hw_st/q".  */
a704 5

      while (++i < alpha_num_opcodes
	     && (alpha_opcodes[i].name == name
		 || !strcmp (alpha_opcodes[i].name, name)))
	continue;
d706 1
d708 3
a710 5
  /* Create the macro hash table.  */
  alpha_macro_hash = hash_new ();
  for (i = 0; i < alpha_num_macros;)
    {
      const char *name, *retval;
d712 12
a723 5
      name = alpha_macros[i].name;
      retval = hash_insert (alpha_macro_hash, name, (PTR) &alpha_macros[i]);
      if (retval)
	as_fatal (_("internal error: can't hash macro `%s': %s"),
		  name, retval);
d725 2
a726 8
      while (++i < alpha_num_macros
	     && (alpha_macros[i].name == name
		 || !strcmp (alpha_macros[i].name, name)))
	continue;
    }

  /* Construct symbols for each of the registers.  */
  for (i = 0; i < 32; ++i)
d728 2
a729 1
      char name[4];
d731 58
a788 7
      sprintf (name, "$%d", i);
      alpha_register_table[i] = symbol_create (name, reg_section, i,
					       &zero_address_frag);
    }
  for (; i < 64; ++i)
    {
      char name[5];
d790 4
a793 3
      sprintf (name, "$f%d", i - 32);
      alpha_register_table[i] = symbol_create (name, reg_section, i,
					       &zero_address_frag);
d795 4
d800 1
a800 1
  /* Create the special symbols and sections we'll be using.  */
d802 18
a819 2
  /* So .sbss will get used for tiny objects.  */
  bfd_set_gp_size (stdoutput, g_switch_value);
d821 1
a821 2
#ifdef OBJ_ECOFF
  create_literal_section (".lita", &alpha_lita_section, &alpha_lita_symbol);
d823 3
a825 5
  /* For handling the GP, create a symbol that won't be output in the
     symbol table.  We'll edit it out of relocs later.  */
  alpha_gp_symbol = symbol_create ("<GP value>", alpha_lita_section, 0x8000,
				   &zero_address_frag);
#endif
d827 3
a829 2
#ifdef OBJ_EVAX
  create_literal_section (".link", &alpha_link_section, &alpha_link_symbol);
d832 1
a832 2
#ifdef OBJ_ELF
  if (ECOFF_DEBUGGING)
d834 17
a850 5
      segT sec = subseg_new (".mdebug", (subsegT) 0);
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);
      bfd_set_section_alignment (stdoutput, sec, 3);
    }
#endif /* OBJ_ELF */
d852 2
a853 2
  /* Create literal lookup hash table.  */
  alpha_literal_hash = hash_new ();
d855 4
a858 2
  subseg_set (text_section, 0);
}
d860 7
a866 1
/* The public interface to the instruction assembler.  */
d868 9
a876 8
void
md_assemble (str)
     char *str;
{
  char opname[32];			/* Current maximum is 13.  */
  expressionS tok[MAX_INSN_ARGS];
  int ntok, trunclen;
  size_t opnamelen;
d878 9
a886 7
  /* Split off the opcode.  */
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/46819");
  trunclen = (opnamelen < sizeof (opname) - 1
	      ? opnamelen
	      : sizeof (opname) - 1);
  memcpy (opname, str, trunclen);
  opname[trunclen] = '\0';
d888 9
a896 5
  /* Tokenize the rest of the line.  */
  if ((ntok = tokenize_arguments (str + opnamelen, tok, MAX_INSN_ARGS)) < 0)
    {
      if (ntok != TOKENIZE_ERROR_REPORT)
	as_bad (_("syntax error"));
d898 1
a898 2
      return;
    }
d900 9
a908 3
  /* Finish it off.  */
  assemble_tokens (opname, tok, ntok, alpha_macros_on);
}
d910 5
a914 1
/* Round up a section's size to the appropriate boundary.  */
d916 6
a921 7
valueT
md_section_align (seg, size)
     segT seg;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  valueT mask = ((valueT) 1 << align) - 1;
d923 3
a925 2
  return (size + mask) & ~mask;
}
d927 11
a937 4
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */
d939 3
a941 2
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6
d943 3
a945 1
extern char *vax_md_atof PARAMS ((int, char *, int *));
d947 3
a949 10
char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;
d951 6
a956 9
  switch (type)
    {
      /* VAX floats */
    case 'G':
      /* VAX md_atof doesn't like "G" for some reason.  */
      type = 'g';
    case 'F':
    case 'D':
      return vax_md_atof (type, litP, sizeP);
d958 4
a961 4
      /* IEEE floats */
    case 'f':
      prec = 2;
      break;
d963 6
a968 3
    case 'd':
      prec = 4;
      break;
d970 1
a970 4
    case 'x':
    case 'X':
      prec = 6;
      break;
d972 6
a977 4
    case 'p':
    case 'P':
      prec = 6;
      break;
d979 6
a984 16
    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
d987 2
a988 1
/* Take care of the target-specific command-line options.  */
d990 5
a994 4
int
md_parse_option (c, arg)
     int c;
     char *arg;
d996 5
a1000 1
  switch (c)
d1002 6
a1007 3
    case 'F':
      alpha_nofloats_on = 1;
      break;
d1009 1
a1009 3
    case OPTION_32ADDR:
      alpha_addr32_on = 1;
      break;
d1011 3
a1013 3
    case 'g':
      alpha_debug = 1;
      break;
d1015 3
a1017 3
    case 'G':
      g_switch_value = atoi (arg);
      break;
d1019 2
a1020 5
    case 'm':
      {
	const struct cpu_type *p;
	for (p = cpu_types; p->name; ++p)
	  if (strcmp (arg, p->name) == 0)
d1022 3
a1024 2
	      alpha_target_name = p->name, alpha_target = p->flags;
	      goto found;
a1025 4
	as_warn (_("Unknown CPU identifier `%s'"), arg);
      found:;
      }
      break;
d1027 23
a1049 4
#ifdef OBJ_EVAX
    case '+':			/* For g++.  Hash any name > 63 chars long.  */
      alpha_flag_hash_long_names = 1;
      break;
d1051 11
a1061 3
    case 'H':			/* Show new symbol after hash truncation */
      alpha_flag_show_after_trunc = 1;
      break;
d1063 4
a1066 3
    case 'h':			/* for gnu-c/vax compatibility.  */
      break;
#endif
d1068 6
a1073 3
    case OPTION_RELAX:
      alpha_flag_relax = 1;
      break;
d1075 6
a1080 8
#ifdef OBJ_ELF
    case OPTION_MDEBUG:
      alpha_flag_mdebug = 1;
      break;
    case OPTION_NO_MDEBUG:
      alpha_flag_mdebug = 0;
      break;
#endif
d1082 1
a1082 2
    default:
      return 0;
d1084 5
d1090 1
a1090 1
  return 1;
d1093 5
a1097 1
/* Print a description of the command-line options that we accept.  */
d1099 5
a1103 3
void
md_show_usage (stream)
     FILE *stream;
d1105 21
a1125 16
  fputs (_("\
Alpha options:\n\
-32addr			treat addresses as 32-bit values\n\
-F			lack floating point instructions support\n\
-mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mev67 | -mev68 | -mall\n\
			specify variant of Alpha architecture\n\
-m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264 | -m21264a | -m21264b\n\
			these variants include PALcode opcodes\n"),
	stream);
#ifdef OBJ_EVAX
  fputs (_("\
VMS options:\n\
-+			hash encode (don't truncate) names longer than 64 characters\n\
-H			show new symbol after hash truncation\n"),
	stream);
#endif
d1128 2
a1129 2
/* Decide from what point a pc-relative relocation is relative to,
   relative to the pc-relative fixup.  Er, relatively speaking.  */
d1131 4
a1134 3
long
md_pcrel_from (fixP)
     fixS *fixP;
d1136 12
a1147 10
  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_ALPHA_HINT:
    case BFD_RELOC_ALPHA_BRSGP:
      return addr + 4;
    default:
      return addr;
    }
d1150 16
a1165 3
/* Attempt to simplify or even eliminate a fixup.  The return value is
   ignored; perhaps it was once meaningful, but now it is historical.
   To indicate that a fixup has been eliminated, set fixP->fx_done.
d1167 3
a1169 5
   For ELF, here it is that we transform the GPDISP_HI16 reloc we used
   internally into the GPDISP reloc used externally.  We had to do
   this so that we'd have the GPDISP_LO16 reloc as a tag to compute
   the distance to the "lda" instruction for setting the addend to
   GPDISP.  */
d1171 5
a1175 5
void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg;
d1177 5
a1181 3
  char * const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
  valueT value = * valP;
  unsigned image, size;
d1183 1
a1183 1
  switch (fixP->fx_r_type)
d1185 1
a1185 5
      /* The GPDISP relocations are processed internally with a symbol
	 referring to the current function's section;  we need to drop
	 in a value which, when added to the address of the start of
	 the function, gives the desired GP.  */
    case BFD_RELOC_ALPHA_GPDISP_HI16:
d1187 19
a1205 1
	fixS *next = fixP->fx_next;
d1207 1
a1207 6
	/* With user-specified !gpdisp relocations, we can be missing
	   the matching LO16 reloc.  We will have already issued an
	   error message.  */
	if (next)
	  fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where
			     - fixP->fx_frag->fr_address - fixP->fx_where);
d1209 6
a1214 6
	value = (value - sign_extend_16 (value)) >> 16;
      }
#ifdef OBJ_ELF
      fixP->fx_r_type = BFD_RELOC_ALPHA_GPDISP;
#endif
      goto do_reloc_gp;
d1216 4
a1219 6
    case BFD_RELOC_ALPHA_GPDISP_LO16:
      value = sign_extend_16 (value);
      fixP->fx_offset = 0;
#ifdef OBJ_ELF
      fixP->fx_done = 1;
#endif
d1221 2
a1222 4
    do_reloc_gp:
      fixP->fx_addsy = section_symbol (seg);
      md_number_to_chars (fixpos, value, 2);
      break;
d1224 1
a1224 21
    case BFD_RELOC_16:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_16_PCREL;
      size = 2;
      goto do_reloc_xx;
    case BFD_RELOC_32:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_32_PCREL;
      size = 4;
      goto do_reloc_xx;
    case BFD_RELOC_64:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_64_PCREL;
      size = 8;
    do_reloc_xx:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  md_number_to_chars (fixpos, value, size);
	  goto done;
	}
      return;
d1226 6
a1231 14
#ifdef OBJ_ECOFF
    case BFD_RELOC_GPREL32:
      assert (fixP->fx_subsy == alpha_gp_symbol);
      fixP->fx_subsy = 0;
      /* FIXME: inherited this obliviousness of `value' -- why? */
      md_number_to_chars (fixpos, -alpha_gp_value, 4);
      break;
#else
    case BFD_RELOC_GPREL32:
#endif
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
      return;
d1233 6
a1238 8
    case BFD_RELOC_23_PCREL_S2:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  image = bfd_getl32 (fixpos);
	  image = (image & ~0x1FFFFF) | ((value >> 2) & 0x1FFFFF);
	  goto write_done;
	}
      return;
d1240 4
a1243 8
    case BFD_RELOC_ALPHA_HINT:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  image = bfd_getl32 (fixpos);
	  image = (image & ~0x3FFF) | ((value >> 2) & 0x3FFF);
	  goto write_done;
	}
      return;
d1245 12
a1256 3
#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_BRSGP:
      return;
d1258 1
a1258 14
    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      if (fixP->fx_addsy)
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
      return;
#endif
d1260 1
a1260 10
#ifdef OBJ_ECOFF
    case BFD_RELOC_ALPHA_LITERAL:
      md_number_to_chars (fixpos, value, 2);
      return;
#endif
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
      return;
d1262 6
a1267 3
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return;
d1269 1
a1269 3
    default:
      {
	const struct alpha_operand *operand;
d1271 29
a1299 3
	if ((int) fixP->fx_r_type >= 0)
	  as_fatal (_("unhandled relocation type %s"),
		    bfd_get_reloc_code_name (fixP->fx_r_type));
d1301 6
a1306 2
	assert (-(int) fixP->fx_r_type < (int) alpha_num_operands);
	operand = &alpha_operands[-(int) fixP->fx_r_type];
d1308 1
a1308 3
	/* The rest of these fixups only exist internally during symbol
	   resolution and have no representation in the object file.
	   Therefore they must be completely resolved as constants.  */
d1310 4
a1313 4
	if (fixP->fx_addsy != 0
	    && S_GET_SEGMENT (fixP->fx_addsy) != absolute_section)
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("non-absolute expression in constant field"));
d1315 6
a1320 3
	image = bfd_getl32 (fixpos);
	image = insert_operand (image, operand, (offsetT) value,
				fixP->fx_file, fixP->fx_line);
d1322 30
a1351 1
      goto write_done;
d1354 1
a1354 3
  if (fixP->fx_addsy != 0 || fixP->fx_pcrel != 0)
    return;
  else
d1356 13
a1368 4
      as_warn_where (fixP->fx_file, fixP->fx_line,
		     _("type %d reloc done?\n"), (int) fixP->fx_r_type);
      goto done;
    }
d1370 5
a1374 2
write_done:
  md_number_to_chars (fixpos, image, 4);
d1376 7
a1382 3
done:
  fixP->fx_done = 1;
}
d1384 3
a1386 1
/* Look for a register name in the given symbol.  */
d1388 1
a1388 7
symbolS *
md_undefined_symbol (name)
     char *name;
{
  if (*name == '$')
    {
      int is_float = 0, num;
d1390 1
a1390 1
      switch (*++name)
d1392 65
a1456 5
	case 'f':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[AXP_REG_FP];
	  is_float = 32;
	  /* FALLTHRU */
d1458 3
a1460 4
	case 'r':
	  if (!ISDIGIT (*++name))
	    break;
	  /* FALLTHRU */
d1462 8
a1469 12
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	  if (name[1] == '\0')
	    num = name[0] - '0';
	  else if (name[0] != '0' && ISDIGIT (name[1]) && name[2] == '\0')
	    {
	      num = (name[0] - '0') * 10 + name[1] - '0';
	      if (num >= 32)
		break;
	    }
	  else
	    break;
d1471 2
a1472 3
	  if (!alpha_noat_on && (num + is_float) == AXP_REG_AT)
	    as_warn (_("Used $at without \".set noat\""));
	  return alpha_register_table[num + is_float];
d1474 7
a1480 8
	case 'a':
	  if (name[1] == 't' && name[2] == '\0')
	    {
	      if (!alpha_noat_on)
		as_warn (_("Used $at without \".set noat\""));
	      return alpha_register_table[AXP_REG_AT];
	    }
	  break;
d1482 8
a1489 4
	case 'g':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[alpha_gp_register];
	  break;
d1491 7
a1497 4
	case 's':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[AXP_REG_SP];
	  break;
d1499 4
d1504 2
a1505 1
  return NULL;
d1508 3
a1510 2
#ifdef OBJ_ECOFF
/* @@@@@@ Magic ECOFF bits.  */
d1512 4
a1515 2
void
alpha_frob_ecoff_data ()
d1517 8
a1524 4
  select_gp_value ();
  /* $zero and $f31 are read-only */
  alpha_gprmask &= ~1;
  alpha_fprmask &= ~1;
a1525 1
#endif
d1527 2
a1528 3
/* Hook to remember a recently defined label so that the auto-align
   code can adjust the symbol after we know what alignment will be
   required.  */
d1530 4
a1533 3
void
alpha_define_label (sym)
     symbolS *sym;
d1535 7
a1541 1
  alpha_insn_label = sym;
d1544 4
a1547 2
/* Return true if we must always emit a reloc for a type and false if
   there is some hope of resolving it at assembly time.  */
d1549 5
a1553 3
int
alpha_force_relocation (f)
     fixS *f;
d1555 2
a1556 2
  if (alpha_flag_relax)
    return 1;
d1558 1
a1558 1
  switch (f->fx_r_type)
d1560 9
a1568 24
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_GPDISP:
    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
    case BFD_RELOC_ALPHA_BRSGP:
    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      return 1;
d1570 4
a1573 2
    default:
      break;
d1576 4
a1579 1
  return generic_force_reloc (f);
d1582 1
a1582 1
/* Return true if we can partially resolve a relocation now.  */
d1584 2
a1585 3
int
alpha_fix_adjustable (f)
     fixS *f;
d1587 13
a1599 8
  /* Are there any relocation types for which we must generate a reloc
     but we can adjust the values contained within it?  */
  switch (f->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_GPDISP:
      return 0;
d1601 61
a1661 6
    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
      return 1;
d1663 4
a1666 3
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      return 0;
d1668 8
a1675 9
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_32:
    case BFD_RELOC_64:
    case BFD_RELOC_ALPHA_HINT:
      return 1;
d1677 2
a1678 13
    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      /* ??? No idea why we can't return a reference to .tbss+10, but
	 we're preventing this in the other assemblers.  Follow for now.  */
      return 0;
d1680 9
a1688 8
#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_BRSGP:
      /* If we have a BRSGP reloc to a local symbol, adjust it to BRADDR and
         let it get resolved at assembly time.  */
      {
	symbolS *sym = f->fx_addsy;
	const char *name;
	int offset = 0;
d1690 3
a1692 2
	if (generic_force_reloc (f))
	  return 0;
d1694 1
a1694 3
	switch (S_GET_OTHER (sym) & STO_ALPHA_STD_GPLOAD)
	  {
	  case STO_ALPHA_NOPV:
d1696 56
a1751 2
	  case STO_ALPHA_STD_GPLOAD:
	    offset = 8;
d1753 15
a1767 8
	  default:
	    if (S_IS_LOCAL (sym))
	      name = "<local>";
	    else
	      name = S_GET_NAME (sym);
	    as_bad_where (f->fx_file, f->fx_line,
		_("!samegp reloc against symbol without .prologue: %s"),
		name);
d1769 10
a1778 5
	  }
	f->fx_r_type = BFD_RELOC_23_PCREL_S2;
	f->fx_offset += offset;
	return 1;
      }
d1780 8
a1787 3

    default:
      return 1;
a1788 1
  /*NOTREACHED*/
d1791 1
a1791 2
/* Generate the BFD reloc to be stuck in the object file from the
   fixup used internally in the assembler.  */
d1793 6
a1798 4
arelent *
tc_gen_reloc (sec, fixp)
     asection *sec ATTRIBUTE_UNUSED;
     fixS *fixp;
d1800 3
a1802 1
  arelent *reloc;
d1804 10
a1813 4
  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
d1815 2
a1816 11
  /* Make sure none of our internal relocations make it this far.
     They'd better have been fully resolved by this point.  */
  assert ((int) fixp->fx_r_type > 0);

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent `%s' relocation in object file"),
		    bfd_get_reloc_code_name (fixp->fx_r_type));
      return NULL;
d1819 1
a1819 1
  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
d1821 1
a1821 4
      as_fatal (_("internal error? cannot generate `%s' relocation"),
		bfd_get_reloc_code_name (fixp->fx_r_type));
    }
  assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);
d1823 3
a1825 5
#ifdef OBJ_ECOFF
  if (fixp->fx_r_type == BFD_RELOC_ALPHA_LITERAL)
    {
      /* Fake out bfd_perform_relocation. sigh.  */
      reloc->addend = -alpha_gp_value;
d1828 1
a1828 15
#endif
    {
      reloc->addend = fixp->fx_offset;
#ifdef OBJ_ELF
      /* Ohhh, this is ugly.  The problem is that if this is a local global
         symbol, the relocation will entirely be performed at link time, not
         at assembly time.  bfd_perform_reloc doesn't know about this sort
         of thing, and as a result we need to fake it out here.  */
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_THREAD_LOCAL))
	  && !S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= symbol_get_bfdsym (fixp->fx_addsy)->value;
#endif
    }
d1830 1
a1830 1
  return reloc;
d1833 2
a1834 3
/* Parse a register name off of the input_line and return a register
   number.  Gets md_undefined_symbol above to do the register name
   matching for us.
d1836 12
a1847 1
   Only called as a part of processing the ECOFF .frame directive.  */
d1849 2
a1850 5
int
tc_get_register (frame)
     int frame ATTRIBUTE_UNUSED;
{
  int framereg = AXP_REG_SP;
d1852 1
a1852 2
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
d1854 34
a1887 3
      char *s = input_line_pointer;
      char c = get_symbol_end ();
      symbolS *sym = md_undefined_symbol (s);
d1889 8
a1896 5
      *strchr (s, '\0') = c;
      if (sym && (framereg = S_GET_VALUE (sym)) <= 31)
	goto found;
    }
  as_warn (_("frame reg expected, using $%d."), framereg);
d1898 6
a1903 4
found:
  note_gpreg (framereg);
  return framereg;
}
d1905 5
a1909 6
/* This is called before the symbol table is processed.  In order to
   work with gcc when using mips-tfile, we must keep all local labels.
   However, in other cases, we want to discard them.  If we were
   called with -g, but we didn't see any debugging information, it may
   mean that gcc is smuggling debugging information through to
   mips-tfile, in which case we must generate all local labels.  */
d1911 6
a1916 1
#ifdef OBJ_ECOFF
d1918 2
a1919 7
void
alpha_frob_file_before_adjust ()
{
  if (alpha_debug != 0
      && ! ecoff_debugging_seen)
    flag_keep_locals = 1;
}
d1921 8
a1928 8
#endif /* OBJ_ECOFF */

static struct alpha_reloc_tag *
get_alpha_reloc_tag (sequence)
     long sequence;
{
  char buffer[ALPHA_RELOC_DIGITS];
  struct alpha_reloc_tag *info;
d1930 7
a1936 1
  sprintf (buffer, "!%ld", sequence);
d1938 1
a1938 2
  info = (struct alpha_reloc_tag *) hash_find (alpha_literal_hash, buffer);
  if (! info)
d1940 17
a1956 2
      size_t len = strlen (buffer);
      const char *errmsg;
d1958 12
a1969 2
      info = (struct alpha_reloc_tag *)
	xcalloc (sizeof (struct alpha_reloc_tag) + len, 1);
d1971 6
a1976 6
      info->segment = now_seg;
      info->sequence = sequence;
      strcpy (info->string, buffer);
      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
      if (errmsg)
	as_fatal (errmsg);
d1979 1
a1979 1
  return info;
d1982 3
a1984 10
/* Before the relocations are written, reorder them, so that user
   supplied !lituse relocations follow the appropriate !literal
   relocations, and similarly for !gpdisp relocations.  */

void
alpha_before_fix ()
{
  if (alpha_literal_hash)
    bfd_map_over_sections (stdoutput, alpha_adjust_relocs, NULL);
}
d1987 3
a1989 4
alpha_adjust_relocs (abfd, sec, ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR ptr ATTRIBUTE_UNUSED;
d1991 4
a1994 5
  segment_info_type *seginfo = seg_info (sec);
  fixS **prevP;
  fixS *fixp;
  fixS *next;
  fixS *slave;
d1996 4
a1999 5
  /* If seginfo is NULL, we did not create this section; don't do
     anything with it.  By using a pointer to a pointer, we can update
     the links in place.  */
  if (seginfo == NULL)
    return;
d2001 2
a2002 3
  /* If there are no relocations, skip the section.  */
  if (! seginfo->fix_root)
    return;
d2004 6
a2009 4
  /* First rebuild the fixup chain without the explicit lituse and
     gpdisp_lo16 relocs.  */
  prevP = &seginfo->fix_root;
  for (fixp = seginfo->fix_root; fixp; fixp = next)
d2011 12
a2022 2
      next = fixp->fx_next;
      fixp->fx_next = (fixS *) 0;
d2024 9
a2032 24
      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_ALPHA_LITUSE:
	  if (fixp->tc_fix_data.info->n_master == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No !literal!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
#ifdef RELOC_OP_P
	  if (fixp->fx_offset == LITUSE_ALPHA_TLSGD)
	    {
	      if (! fixp->tc_fix_data.info->saw_tlsgd)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("No !tlsgd!%ld was found"),
			      fixp->tc_fix_data.info->sequence);
	    }
	  else if (fixp->fx_offset == LITUSE_ALPHA_TLSLDM)
	    {
	      if (! fixp->tc_fix_data.info->saw_tlsldm)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("No !tlsldm!%ld was found"),
			      fixp->tc_fix_data.info->sequence);
	    }
#endif
	  break;
d2034 4
a2037 6
	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  if (fixp->tc_fix_data.info->n_master == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No ldah !gpdisp!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
	  break;
d2039 4
a2042 6
	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  if (fixp->tc_fix_data.info
	      && (fixp->tc_fix_data.info->saw_tlsgd
	          || fixp->tc_fix_data.info->saw_tlsldm))
	    break;
	  /* FALLTHRU */
d2044 6
a2049 5
	default:
	  *prevP = fixp;
	  prevP = &fixp->fx_next;
	  break;
	}
d2052 4
a2055 4
  /* Go back and re-chain dependent relocations.  They are currently
     linked through the next_reloc field in reverse order, so as we
     go through the next_reloc chain, we effectively reverse the chain
     once again.
d2057 8
a2064 4
     Except if there is more than one !literal for a given sequence
     number.  In that case, the programmer and/or compiler is not sure
     how control flows from literal to lituse, and we can't be sure to
     get the relaxation correct.
d2066 2
a2067 3
     ??? Well, actually we could, if there are enough lituses such that
     we can make each literal have at least one of each lituse type
     present.  Not implemented.
d2069 1
a2069 3
     Also suppress the optimization if the !literals/!lituses are spread
     in different segments.  This can happen with "intersting" uses of
     inline assembly; examples are present in the Linux kernel semaphores.  */
d2071 8
a2078 1
  for (fixp = seginfo->fix_root; fixp; fixp = next)
d2080 24
a2103 2
      next = fixp->fx_next;
      switch (fixp->fx_r_type)
d2105 6
a2110 15
	case BFD_RELOC_ALPHA_TLSGD:
	case BFD_RELOC_ALPHA_TLSLDM:
	  if (!fixp->tc_fix_data.info)
	    break;
	  if (fixp->tc_fix_data.info->n_master == 0)
	    break;
	  else if (fixp->tc_fix_data.info->n_master > 1)
	    {
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("too many !literal!%ld for %s"),
			    fixp->tc_fix_data.info->sequence,
			    (fixp->fx_r_type == BFD_RELOC_ALPHA_TLSGD
			     ? "!tlsgd" : "!tlsldm"));
	      break;
	    }
d2112 1
a2112 4
	  fixp->tc_fix_data.info->master->fx_next = fixp->fx_next;
	  fixp->fx_next = fixp->tc_fix_data.info->master;
	  fixp = fixp->fx_next;
	  /* FALLTHRU */
d2114 4
a2117 14
	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  if (fixp->tc_fix_data.info
	      && fixp->tc_fix_data.info->n_master == 1
	      && ! fixp->tc_fix_data.info->multi_section_p)
	    {
	      for (slave = fixp->tc_fix_data.info->slaves;
		   slave != (fixS *) 0;
		   slave = slave->tc_fix_data.next_reloc)
		{
		  slave->fx_next = fixp->fx_next;
		  fixp->fx_next = slave;
		}
	    }
	  break;
d2119 8
a2126 12
	case BFD_RELOC_ALPHA_GPDISP_HI16:
	  if (fixp->tc_fix_data.info->n_slaves == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No lda !gpdisp!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
	  else
	    {
	      slave = fixp->tc_fix_data.info->slaves;
	      slave->fx_next = next;
	      fixp->fx_next = slave;
	    }
	  break;
d2128 1
a2128 3
	default:
	  break;
	}
d2131 15
a2145 2

#ifdef DEBUG_ALPHA
d2147 3
a2149 3
debug_exp (tok, ntok)
     expressionS tok[];
     int ntok;
d2151 21
a2171 1
  int i;
d2173 5
a2177 5
  fprintf (stderr, "debug_exp: %d tokens", ntok);
  for (i = 0; i < ntok; i++)
    {
      expressionS *t = &tok[i];
      const char *name;
d2179 15
a2193 58
      switch (t->X_op)
	{
	default:			name = "unknown";		break;
	case O_illegal:			name = "O_illegal";		break;
	case O_absent:			name = "O_absent";		break;
	case O_constant:		name = "O_constant";		break;
	case O_symbol:			name = "O_symbol";		break;
	case O_symbol_rva:		name = "O_symbol_rva";		break;
	case O_register:		name = "O_register";		break;
	case O_big:			name = "O_big";			break;
	case O_uminus:			name = "O_uminus";		break;
	case O_bit_not:			name = "O_bit_not";		break;
	case O_logical_not:		name = "O_logical_not";		break;
	case O_multiply:		name = "O_multiply";		break;
	case O_divide:			name = "O_divide";		break;
	case O_modulus:			name = "O_modulus";		break;
	case O_left_shift:		name = "O_left_shift";		break;
	case O_right_shift:		name = "O_right_shift";		break;
	case O_bit_inclusive_or:	name = "O_bit_inclusive_or";	break;
	case O_bit_or_not:		name = "O_bit_or_not";		break;
	case O_bit_exclusive_or:	name = "O_bit_exclusive_or";	break;
	case O_bit_and:			name = "O_bit_and";		break;
	case O_add:			name = "O_add";			break;
	case O_subtract:		name = "O_subtract";		break;
	case O_eq:			name = "O_eq";			break;
	case O_ne:			name = "O_ne";			break;
	case O_lt:			name = "O_lt";			break;
	case O_le:			name = "O_le";			break;
	case O_ge:			name = "O_ge";			break;
	case O_gt:			name = "O_gt";			break;
	case O_logical_and:		name = "O_logical_and";		break;
	case O_logical_or:		name = "O_logical_or";		break;
	case O_index:			name = "O_index";		break;
	case O_pregister:		name = "O_pregister";		break;
	case O_cpregister:		name = "O_cpregister";		break;
	case O_literal:			name = "O_literal";		break;
	case O_lituse_addr:		name = "O_lituse_addr";		break;
	case O_lituse_base:		name = "O_lituse_base";		break;
	case O_lituse_bytoff:		name = "O_lituse_bytoff";	break;
	case O_lituse_jsr:		name = "O_lituse_jsr";		break;
	case O_lituse_tlsgd:		name = "O_lituse_tlsgd";	break;
	case O_lituse_tlsldm:		name = "O_lituse_tlsldm";	break;
	case O_gpdisp:			name = "O_gpdisp";		break;
	case O_gprelhigh:		name = "O_gprelhigh";		break;
	case O_gprellow:		name = "O_gprellow";		break;
	case O_gprel:			name = "O_gprel";		break;
	case O_samegp:			name = "O_samegp";		break;
	case O_tlsgd:			name = "O_tlsgd";		break;
	case O_tlsldm:			name = "O_tlsldm";		break;
	case O_gotdtprel:		name = "O_gotdtprel";		break;
	case O_dtprelhi:		name = "O_dtprelhi";		break;
	case O_dtprello:		name = "O_dtprello";		break;
	case O_dtprel:			name = "O_dtprel";		break;
	case O_gottprel:		name = "O_gottprel";		break;
	case O_tprelhi:			name = "O_tprelhi";		break;
	case O_tprello:			name = "O_tprello";		break;
	case O_tprel:			name = "O_tprel";		break;
	}
d2195 7
a2201 7
      fprintf (stderr, ", %s(%s, %s, %d)", name,
	       (t->X_add_symbol) ? S_GET_NAME (t->X_add_symbol) : "--",
	       (t->X_op_symbol) ? S_GET_NAME (t->X_op_symbol) : "--",
	       (int) t->X_add_number);
    }
  fprintf (stderr, "\n");
  fflush (stderr);
a2202 1
#endif
d2204 1
a2204 1
/* Parse the arguments to an opcode.  */
d2206 4
a2209 5
static int
tokenize_arguments (str, tok, ntok)
     char *str;
     expressionS tok[];
     int ntok;
d2211 4
a2214 13
  expressionS *end_tok = tok + ntok;
  char *old_input_line_pointer;
  int saw_comma = 0, saw_arg = 0;
#ifdef DEBUG_ALPHA
  expressionS *orig_tok = tok;
#endif
#ifdef RELOC_OP_P
  char *p;
  const struct alpha_reloc_op_tag *r;
  int c, i;
  size_t len;
  int reloc_found_p = 0;
#endif
d2216 2
a2217 1
  memset (tok, 0, sizeof (*tok) * ntok);
d2219 1
a2219 3
  /* Save and restore input_line_pointer around this function.  */
  old_input_line_pointer = input_line_pointer;
  input_line_pointer = str;
d2221 6
a2226 4
#ifdef RELOC_OP_P
  /* ??? Wrest control of ! away from the regular expression parser.  */
  is_end_of_line[(unsigned char) '!'] = 1;
#endif
d2228 3
a2230 1
  while (tok < end_tok && *input_line_pointer)
d2232 13
a2244 5
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	case '\0':
	  goto fini;
d2246 2
a2247 11
#ifdef RELOC_OP_P
	case '!':
	  /* A relocation operand can be placed after the normal operand on an
	     assembly language statement, and has the following form:
		!relocation_type!sequence_number.  */
	  if (reloc_found_p)
	    {
	      /* Only support one relocation op per insn.  */
	      as_bad (_("More than one relocation op per insn"));
	      goto err_report;
	    }
d2249 5
a2253 2
	  if (!saw_arg)
	    goto err;
d2255 8
a2262 4
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  p = input_line_pointer;
	  c = get_symbol_end ();
d2264 1
a2264 7
	  /* Parse !relocation_type.  */
	  len = input_line_pointer - p;
	  if (len == 0)
	    {
	      as_bad (_("No relocation operand"));
	      goto err_report;
	    }
d2266 5
a2270 9
	  r = &alpha_reloc_op[0];
	  for (i = alpha_num_reloc_op - 1; i >= 0; i--, r++)
	    if (len == r->length && memcmp (p, r->name, len) == 0)
	      break;
	  if (i < 0)
	    {
	      as_bad (_("Unknown relocation operand: !%s"), p);
	      goto err_report;
	    }
d2272 8
a2279 9
	  *input_line_pointer = c;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != '!')
	    {
	      if (r->require_seq)
		{
		  as_bad (_("no sequence number after !%s"), p);
		  goto err_report;
		}
d2281 1
a2281 9
	      tok->X_add_number = 0;
	    }
	  else
	    {
	      if (! r->allow_seq)
		{
		  as_bad (_("!%s does not use a sequence number"), p);
		  goto err_report;
		}
d2283 4
a2286 1
	      input_line_pointer++;
d2288 8
a2295 9
	      /* Parse !sequence_number.  */
	      expression (tok);
	      if (tok->X_op != O_constant || tok->X_add_number <= 0)
		{
		  as_bad (_("Bad sequence number: !%s!%s"),
			  r->name, input_line_pointer);
		  goto err_report;
		}
	    }
d2297 1
a2297 5
	  tok->X_op = r->op;
	  reloc_found_p = 1;
	  ++tok;
	  break;
#endif /* RELOC_OP_P */
d2299 3
a2301 6
	case ',':
	  ++input_line_pointer;
	  if (saw_comma || !saw_arg)
	    goto err;
	  saw_comma = 1;
	  break;
d2303 4
a2306 3
	case '(':
	  {
	    char *hold = input_line_pointer++;
d2308 33
a2340 11
	    /* First try for parenthesized register ...  */
	    expression (tok);
	    if (*input_line_pointer == ')' && tok->X_op == O_register)
	      {
		tok->X_op = (saw_comma ? O_cpregister : O_pregister);
		saw_comma = 0;
		saw_arg = 1;
		++input_line_pointer;
		++tok;
		break;
	      }
d2342 4
a2345 3
	    /* ... then fall through to plain expression.  */
	    input_line_pointer = hold;
	  }
d2347 5
a2351 3
	default:
	  if (saw_arg && !saw_comma)
	    goto err;
d2353 3
a2355 3
	  expression (tok);
	  if (tok->X_op == O_illegal || tok->X_op == O_absent)
	    goto err;
d2357 4
a2360 6
	  saw_comma = 0;
	  saw_arg = 1;
	  ++tok;
	  break;
	}
    }
d2362 4
a2365 4
fini:
  if (saw_comma)
    goto err;
  input_line_pointer = old_input_line_pointer;
d2367 5
a2371 6
#ifdef DEBUG_ALPHA
  debug_exp (orig_tok, ntok - (end_tok - tok));
#endif
#ifdef RELOC_OP_P
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
d2373 5
a2377 1
  return ntok - (end_tok - tok);
d2379 5
a2383 6
err:
#ifdef RELOC_OP_P
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
  input_line_pointer = old_input_line_pointer;
  return TOKENIZE_ERROR;
d2385 4
a2388 6
#ifdef RELOC_OP_P
err_report:
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
  input_line_pointer = old_input_line_pointer;
  return TOKENIZE_ERROR_REPORT;
d2391 2
a2392 2
/* Search forward through all variants of an opcode looking for a
   syntax match.  */
d2394 4
a2397 6
static const struct alpha_opcode *
find_opcode_match (first_opcode, tok, pntok, pcpumatch)
     const struct alpha_opcode *first_opcode;
     const expressionS *tok;
     int *pntok;
     int *pcpumatch;
d2399 1
a2399 3
  const struct alpha_opcode *opcode = first_opcode;
  int ntok = *pntok;
  int got_cpu_match = 0;
d2401 3
a2403 1
  do
d2405 2
a2406 2
      const unsigned char *opidx;
      int tokidx = 0;
d2408 5
a2412 3
      /* Don't match opcodes that don't exist on this architecture.  */
      if (!(opcode->flags & alpha_target))
	goto match_failed;
d2414 5
a2418 1
      got_cpu_match = 1;
d2420 1
a2420 3
      for (opidx = opcode->operands; *opidx; ++opidx)
	{
	  const struct alpha_operand *operand = &alpha_operands[*opidx];
d2422 1
a2422 3
	  /* Only take input from real operands.  */
	  if (operand->flags & AXP_OPERAND_FAKE)
	    continue;
d2424 2
a2425 7
	  /* When we expect input, make sure we have it.  */
	  if (tokidx >= ntok)
	    {
	      if ((operand->flags & AXP_OPERAND_OPTIONAL_MASK) == 0)
		goto match_failed;
	      continue;
	    }
d2427 6
a2432 23
	  /* Match operand type with expression type.  */
	  switch (operand->flags & AXP_OPERAND_TYPECHECK_MASK)
	    {
	    case AXP_OPERAND_IR:
	      if (tok[tokidx].X_op != O_register
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_FPR:
	      if (tok[tokidx].X_op != O_register
		  || !is_fpr_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_IR | AXP_OPERAND_PARENS:
	      if (tok[tokidx].X_op != O_pregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_IR | AXP_OPERAND_PARENS | AXP_OPERAND_COMMA:
	      if (tok[tokidx].X_op != O_cpregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
d2434 8
a2441 11
	    case AXP_OPERAND_RELATIVE:
	    case AXP_OPERAND_SIGNED:
	    case AXP_OPERAND_UNSIGNED:
	      switch (tok[tokidx].X_op)
		{
		case O_illegal:
		case O_absent:
		case O_register:
		case O_pregister:
		case O_cpregister:
		  goto match_failed;
d2443 2
a2444 4
		default:
		  break;
		}
	      break;
d2446 3
a2448 6
	    default:
	      /* Everything else should have been fake.  */
	      abort ();
	    }
	  ++tokidx;
	}
d2450 2
a2451 6
      /* Possible match -- did we use all of our input?  */
      if (tokidx == ntok)
	{
	  *pntok = ntok;
	  return opcode;
	}
d2453 4
a2456 4
    match_failed:;
    }
  while (++opcode - alpha_opcodes < (int) alpha_num_opcodes
	 && !strcmp (opcode->name, first_opcode->name));
d2458 6
a2463 2
  if (*pcpumatch)
    *pcpumatch = got_cpu_match;
d2465 3
a2467 2
  return NULL;
}
d2469 3
a2471 2
/* Search forward through all variants of a macro looking for a syntax
   match.  */
d2473 12
a2484 8
static const struct alpha_macro *
find_macro_match (first_macro, tok, pntok)
     const struct alpha_macro *first_macro;
     const expressionS *tok;
     int *pntok;
{
  const struct alpha_macro *macro = first_macro;
  int ntok = *pntok;
d2486 6
a2491 4
  do
    {
      const enum alpha_macro_arg *arg = macro->argsets;
      int tokidx = 0;
d2493 1
a2493 1
      while (*arg)
d2495 7
a2501 8
	  switch (*arg)
	    {
	    case MACRO_EOA:
	      if (tokidx == ntok)
		return macro;
	      else
		tokidx = 0;
	      break;
d2503 3
a2505 7
	      /* Index register.  */
	    case MACRO_IR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_register
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;
d2507 5
a2511 7
	      /* Parenthesized index register.  */
	    case MACRO_PIR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_pregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;
d2513 8
a2520 6
	      /* Optional parenthesized index register.  */
	    case MACRO_OPIR:
	      if (tokidx < ntok && tok[tokidx].X_op == O_pregister
		  && is_ir_num (tok[tokidx].X_add_number))
		++tokidx;
	      break;
d2522 1
a2522 7
	      /* Leading comma with a parenthesized index register.  */
	    case MACRO_CPIR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_cpregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;
d2524 14
a2537 7
	      /* Floating point register.  */
	    case MACRO_FPR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_register
		  || !is_fpr_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;
d2539 2
a2540 21
	      /* Normal expression.  */
	    case MACRO_EXP:
	      if (tokidx >= ntok)
		goto match_failed;
	      switch (tok[tokidx].X_op)
		{
		case O_illegal:
		case O_absent:
		case O_register:
		case O_pregister:
		case O_cpregister:
		case O_literal:
		case O_lituse_base:
		case O_lituse_bytoff:
		case O_lituse_jsr:
		case O_gpdisp:
		case O_gprelhigh:
		case O_gprellow:
		case O_gprel:
		case O_samegp:
		  goto match_failed;
d2542 3
a2544 5
		default:
		  break;
		}
	      ++tokidx;
	      break;
d2546 2
a2547 11
	    match_failed:
	      while (*arg != MACRO_EOA)
		++arg;
	      tokidx = 0;
	      break;
	    }
	  ++arg;
	}
    }
  while (++macro - alpha_macros < (int) alpha_num_macros
	 && !strcmp (macro->name, first_macro->name));
d2549 4
a2552 2
  return NULL;
}
d2554 1
a2554 1
/* Insert an operand value into an instruction.  */
d2556 2
a2557 9
static unsigned
insert_operand (insn, operand, val, file, line)
     unsigned insn;
     const struct alpha_operand *operand;
     offsetT val;
     char *file;
     unsigned line;
{
  if (operand->bits != 32 && !(operand->flags & AXP_OPERAND_NOOVERFLOW))
d2559 11
a2569 1
      offsetT min, max;
d2571 7
a2577 1
      if (operand->flags & AXP_OPERAND_SIGNED)
d2579 3
a2581 2
	  max = (1 << (operand->bits - 1)) - 1;
	  min = -(1 << (operand->bits - 1));
d2583 2
a2584 1
      else
d2586 3
a2588 2
	  max = (1 << operand->bits) - 1;
	  min = 0;
d2591 6
a2596 2
      if (val < min || val > max)
	as_warn_value_out_of_range (_("operand"), val, min, max, file, line);
d2599 18
a2616 1
  if (operand->insert)
d2618 3
a2620 5
      const char *errmsg = NULL;

      insn = (*operand->insert) (insn, val, &errmsg);
      if (errmsg)
	as_warn (errmsg);
d2622 1
a2622 2
  else
    insn |= ((val & ((1 << operand->bits) - 1)) << operand->shift);
d2624 1
a2624 2
  return insn;
}
d2626 3
a2628 2
/* Turn an opcode description and a set of arguments into
   an instruction and a fixup.  */
d2631 3
a2633 6
assemble_insn (opcode, tok, ntok, insn, reloc)
     const struct alpha_opcode *opcode;
     const expressionS *tok;
     int ntok;
     struct alpha_insn *insn;
     bfd_reloc_code_real_type reloc;
d2635 5
a2639 5
  const struct alpha_operand *reloc_operand = NULL;
  const expressionS *reloc_exp = NULL;
  const unsigned char *argidx;
  unsigned image;
  int tokidx = 0;
d2641 4
a2644 2
  memset (insn, 0, sizeof (*insn));
  image = opcode->opcode;
d2646 1
a2646 4
  for (argidx = opcode->operands; *argidx; ++argidx)
    {
      const struct alpha_operand *operand = &alpha_operands[*argidx];
      const expressionS *t = (const expressionS *) 0;
d2648 12
a2659 6
      if (operand->flags & AXP_OPERAND_FAKE)
	{
	  /* fake operands take no value and generate no fixup */
	  image = insert_operand (image, operand, 0, NULL, 0);
	  continue;
	}
d2661 1
a2661 24
      if (tokidx >= ntok)
	{
	  switch (operand->flags & AXP_OPERAND_OPTIONAL_MASK)
	    {
	    case AXP_OPERAND_DEFAULT_FIRST:
	      t = &tok[0];
	      break;
	    case AXP_OPERAND_DEFAULT_SECOND:
	      t = &tok[1];
	      break;
	    case AXP_OPERAND_DEFAULT_ZERO:
	      {
		static expressionS zero_exp;
		t = &zero_exp;
		zero_exp.X_op = O_constant;
		zero_exp.X_unsigned = 1;
	      }
	      break;
	    default:
	      abort ();
	    }
	}
      else
	t = &tok[tokidx++];
d2663 8
a2670 8
      switch (t->X_op)
	{
	case O_register:
	case O_pregister:
	case O_cpregister:
	  image = insert_operand (image, operand, regno (t->X_add_number),
				  NULL, 0);
	  break;
d2672 1
a2672 6
	case O_constant:
	  image = insert_operand (image, operand, t->X_add_number, NULL, 0);
	  assert (reloc_operand == NULL);
	  reloc_operand = operand;
	  reloc_exp = t;
	  break;
d2674 8
a2681 5
	default:
	  /* This is only 0 for fields that should contain registers,
	     which means this pattern shouldn't have matched.  */
	  if (operand->default_reloc == 0)
	    abort ();
d2683 2
a2684 6
	  /* There is one special case for which an insn receives two
	     relocations, and thus the user-supplied reloc does not
	     override the operand reloc.  */
	  if (operand->default_reloc == BFD_RELOC_ALPHA_HINT)
	    {
	      struct alpha_fixup *fixup;
d2686 2
a2687 2
	      if (insn->nfixups >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));
d2689 8
a2696 8
	      fixup = &insn->fixups[insn->nfixups++];
	      fixup->exp = *t;
	      fixup->reloc = BFD_RELOC_ALPHA_HINT;
	    }
	  else
	    {
	      if (reloc == BFD_RELOC_UNUSED)
		reloc = operand->default_reloc;
d2698 4
a2701 7
	      assert (reloc_operand == NULL);
	      reloc_operand = operand;
	      reloc_exp = t;
	    }
	  break;
	}
    }
d2703 1
a2703 3
  if (reloc != BFD_RELOC_UNUSED)
    {
      struct alpha_fixup *fixup;
d2705 5
a2709 2
      if (insn->nfixups >= MAX_INSN_FIXUPS)
	as_fatal (_("too many fixups"));
d2711 1
a2711 12
      /* ??? My but this is hacky.  But the OSF/1 assembler uses the same
	 relocation tag for both ldah and lda with gpdisp.  Choose the
	 correct internal relocation based on the opcode.  */
      if (reloc == BFD_RELOC_ALPHA_GPDISP)
	{
	  if (strcmp (opcode->name, "ldah") == 0)
	    reloc = BFD_RELOC_ALPHA_GPDISP_HI16;
	  else if (strcmp (opcode->name, "lda") == 0)
	    reloc = BFD_RELOC_ALPHA_GPDISP_LO16;
	  else
	    as_bad (_("invalid relocation for instruction"));
	}
d2713 4
a2716 12
      /* If this is a real relocation (as opposed to a lituse hint), then
	 the relocation width should match the operand width.  */
      else if (reloc < BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, reloc);
	  if (reloc_howto->bitsize != reloc_operand->bits)
	    {
	      as_bad (_("invalid relocation for field"));
	      return;
	    }
	}
d2718 1
a2718 9
      fixup = &insn->fixups[insn->nfixups++];
      if (reloc_exp)
	fixup->exp = *reloc_exp;
      else
	fixup->exp.X_op = O_absent;
      fixup->reloc = reloc;
    }

  insn->insn = image;
d2721 1
a2721 1
/* Actually output an instruction with its fixup.  */
d2724 3
a2726 2
emit_insn (insn)
     struct alpha_insn *insn;
d2728 18
a2745 2
  char *f;
  int i;
d2747 1
a2747 6
  /* Take care of alignment duties.  */
  if (alpha_auto_align_on && alpha_current_align < 2)
    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > 2)
    alpha_current_align = 2;
  alpha_insn_label = NULL;
d2749 1
a2749 3
  /* Write out the instruction.  */
  f = frag_more (4);
  md_number_to_chars (f, insn->insn, 4);
d2751 5
a2755 2
#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
d2758 10
a2767 8
  /* Apply the fixups in order.  */
  for (i = 0; i < insn->nfixups; ++i)
    {
      const struct alpha_operand *operand = (const struct alpha_operand *) 0;
      struct alpha_fixup *fixup = &insn->fixups[i];
      struct alpha_reloc_tag *info = NULL;
      int size, pcrel;
      fixS *fixP;
d2769 3
a2771 19
      /* Some fixups are only used internally and so have no howto.  */
      if ((int) fixup->reloc < 0)
	{
	  operand = &alpha_operands[-(int) fixup->reloc];
	  size = 4;
	  pcrel = ((operand->flags & AXP_OPERAND_RELATIVE) != 0);
	}
      else if (fixup->reloc > BFD_RELOC_UNUSED
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_HI16
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_LO16)
	{
	  size = 2;
	  pcrel = 0;
	}
      else
	{
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	  assert (reloc_howto);
d2773 4
a2776 2
	  size = bfd_get_reloc_size (reloc_howto);
	  assert (size >= 1 && size <= 4);
d2778 3
a2780 2
	  pcrel = reloc_howto->pc_relative;
	}
d2782 1
a2782 2
      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal, size,
			  &fixup->exp, pcrel, fixup->reloc);
d2784 97
a2880 19
      /* Turn off complaints that the addend is too large for some fixups,
         and copy in the sequence number for the explicit relocations.  */
      switch (fixup->reloc)
	{
	case BFD_RELOC_ALPHA_HINT:
	case BFD_RELOC_GPREL32:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_ALPHA_GPREL_HI16:
	case BFD_RELOC_ALPHA_GPREL_LO16:
	case BFD_RELOC_ALPHA_GOTDTPREL16:
	case BFD_RELOC_ALPHA_DTPREL_HI16:
	case BFD_RELOC_ALPHA_DTPREL_LO16:
	case BFD_RELOC_ALPHA_DTPREL16:
	case BFD_RELOC_ALPHA_GOTTPREL16:
	case BFD_RELOC_ALPHA_TPREL_HI16:
	case BFD_RELOC_ALPHA_TPREL_LO16:
	case BFD_RELOC_ALPHA_TPREL16:
	  fixP->fx_no_overflow = 1;
	  break;
d2882 40
a2921 4
	case BFD_RELOC_ALPHA_GPDISP_HI16:
	  fixP->fx_no_overflow = 1;
	  fixP->fx_addsy = section_symbol (now_seg);
	  fixP->fx_offset = 0;
d2923 32
a2954 8
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (++info->n_master > 1)
	    as_bad (_("too many ldah insns for !gpdisp!%ld"), insn->sequence);
	  if (info->segment != now_seg)
	    as_bad (_("both insns for !gpdisp!%ld must be in the same section"),
		    insn->sequence);
	  fixP->tc_fix_data.info = info;
	  break;
d2956 2
a2957 2
	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  fixP->fx_no_overflow = 1;
d2959 2
a2960 9
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (++info->n_slaves > 1)
	    as_bad (_("too many lda insns for !gpdisp!%ld"), insn->sequence);
	  if (info->segment != now_seg)
	    as_bad (_("both insns for !gpdisp!%ld must be in the same section"),
		    insn->sequence);
	  fixP->tc_fix_data.info = info;
	  info->slaves = fixP;
	  break;
d2962 4
a2965 3
	case BFD_RELOC_ALPHA_LITERAL:
	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  fixP->fx_no_overflow = 1;
d2967 3
a2969 9
	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  info->master = fixP;
	  info->n_master++;
	  if (info->segment != now_seg)
	    info->multi_section_p = 1;
	  fixP->tc_fix_data.info = info;
	  break;
d2971 4
a2974 22
#ifdef RELOC_OP_P
	case DUMMY_RELOC_LITUSE_ADDR:
	  fixP->fx_offset = LITUSE_ALPHA_ADDR;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_BASE:
	  fixP->fx_offset = LITUSE_ALPHA_BASE;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_BYTOFF:
	  fixP->fx_offset = LITUSE_ALPHA_BYTOFF;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_JSR:
	  fixP->fx_offset = LITUSE_ALPHA_JSR;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_TLSGD:
	  fixP->fx_offset = LITUSE_ALPHA_TLSGD;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_TLSLDM:
	  fixP->fx_offset = LITUSE_ALPHA_TLSLDM;
	  goto do_lituse;
	do_lituse:
	  fixP->fx_addsy = section_symbol (now_seg);
	  fixP->fx_r_type = BFD_RELOC_ALPHA_LITUSE;
d2976 3
a2978 6
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (fixup->reloc == DUMMY_RELOC_LITUSE_TLSGD)
	    info->saw_lu_tlsgd = 1;
	  else if (fixup->reloc == DUMMY_RELOC_LITUSE_TLSLDM)
	    info->saw_lu_tlsldm = 1;
	  if (++info->n_slaves > 1)
d2980 37
a3016 13
	      if (info->saw_lu_tlsgd)
		as_bad (_("too many lituse insns for !lituse_tlsgd!%ld"),
		        insn->sequence);
	      else if (info->saw_lu_tlsldm)
		as_bad (_("too many lituse insns for !lituse_tlsldm!%ld"),
		        insn->sequence);
	    }
	  fixP->tc_fix_data.info = info;
	  fixP->tc_fix_data.next_reloc = info->slaves;
	  info->slaves = fixP;
	  if (info->segment != now_seg)
	    info->multi_section_p = 1;
	  break;
d3018 7
a3024 2
	case BFD_RELOC_ALPHA_TLSGD:
	  fixP->fx_no_overflow = 1;
d3026 21
a3046 12
	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (info->saw_tlsgd)
	    as_bad (_("duplicate !tlsgd!%ld"), insn->sequence);
	  else if (info->saw_tlsldm)
	    as_bad (_("sequence number in use for !tlsldm!%ld"),
		    insn->sequence);
	  else
	    info->saw_tlsgd = 1;
	  fixP->tc_fix_data.info = info;
	  break;
d3048 5
a3052 2
	case BFD_RELOC_ALPHA_TLSLDM:
	  fixP->fx_no_overflow = 1;
d3054 5
a3058 18
	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (info->saw_tlsldm)
	    as_bad (_("duplicate !tlsldm!%ld"), insn->sequence);
	  else if (info->saw_tlsgd)
	    as_bad (_("sequence number in use for !tlsgd!%ld"),
		    insn->sequence);
	  else
	    info->saw_tlsldm = 1;
	  fixP->tc_fix_data.info = info;
	  break;
#endif
	default:
	  if ((int) fixup->reloc < 0)
	    {
	      if (operand->flags & AXP_OPERAND_NOOVERFLOW)
		fixP->fx_no_overflow = 1;
d3060 1
a3060 1
	  break;
d3063 2
a3064 1
}
d3066 1
a3066 34
/* Given an opcode name and a pre-tokenized set of arguments, assemble
   the insn, but do not emit it.

   Note that this implies no macros allowed, since we can't store more
   than one insn in an insn structure.  */

static void
assemble_tokens_to_insn (opname, tok, ntok, insn)
     const char *opname;
     const expressionS *tok;
     int ntok;
     struct alpha_insn *insn;
{
  const struct alpha_opcode *opcode;

  /* search opcodes */
  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
  if (opcode)
    {
      int cpumatch;
      opcode = find_opcode_match (opcode, tok, &ntok, &cpumatch);
      if (opcode)
	{
	  assemble_insn (opcode, tok, ntok, insn, BFD_RELOC_UNUSED);
	  return;
	}
      else if (cpumatch)
	as_bad (_("inappropriate arguments for opcode `%s'"), opname);
      else
	as_bad (_("opcode `%s' not supported for target %s"), opname,
		alpha_target_name);
    }
  else
    as_bad (_("unknown opcode `%s'"), opname);
d3073 4
a3076 5
assemble_tokens (opname, tok, ntok, local_macros_on)
     const char *opname;
     const expressionS *tok;
     int ntok;
     int local_macros_on;
a3140 73
/* Some instruction sets indexed by lg(size).  */
static const char * const sextX_op[] = { "sextb", "sextw", "sextl", NULL };
static const char * const insXl_op[] = { "insbl", "inswl", "insll", "insql" };
static const char * const insXh_op[] = { NULL,    "inswh", "inslh", "insqh" };
static const char * const extXl_op[] = { "extbl", "extwl", "extll", "extql" };
static const char * const extXh_op[] = { NULL,    "extwh", "extlh", "extqh" };
static const char * const mskXl_op[] = { "mskbl", "mskwl", "mskll", "mskql" };
static const char * const mskXh_op[] = { NULL,    "mskwh", "msklh", "mskqh" };
static const char * const stX_op[] = { "stb", "stw", "stl", "stq" };
static const char * const ldXu_op[] = { "ldbu", "ldwu", NULL, NULL };

/* Implement the ldgp macro.  */

static void
emit_ldgp (tok, ntok, unused)
     const expressionS *tok;
     int ntok ATTRIBUTE_UNUSED;
     const PTR unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_AOUT
FIXME
#endif
#if defined(OBJ_ECOFF) || defined(OBJ_ELF)
  /* from "ldgp r1,n(r2)", generate "ldah r1,X(R2); lda r1,Y(r1)"
     with appropriate constants and relocations.  */
  struct alpha_insn insn;
  expressionS newtok[3];
  expressionS addend;

#ifdef OBJ_ECOFF
  if (regno (tok[2].X_add_number) == AXP_REG_PV)
    ecoff_set_gp_prolog_size (0);
#endif

  newtok[0] = tok[0];
  set_tok_const (newtok[1], 0);
  newtok[2] = tok[2];

  assemble_tokens_to_insn ("ldah", newtok, 3, &insn);

  addend = tok[1];

#ifdef OBJ_ECOFF
  if (addend.X_op != O_constant)
    as_bad (_("can not resolve expression"));
  addend.X_op = O_symbol;
  addend.X_add_symbol = alpha_gp_symbol;
#endif

  insn.nfixups = 1;
  insn.fixups[0].exp = addend;
  insn.fixups[0].reloc = BFD_RELOC_ALPHA_GPDISP_HI16;
  insn.sequence = next_sequence_num;

  emit_insn (&insn);

  set_tok_preg (newtok[2], tok[0].X_add_number);

  assemble_tokens_to_insn ("lda", newtok, 3, &insn);

#ifdef OBJ_ECOFF
  addend.X_add_number += 4;
#endif

  insn.nfixups = 1;
  insn.fixups[0].exp = addend;
  insn.fixups[0].reloc = BFD_RELOC_ALPHA_GPDISP_LO16;
  insn.sequence = next_sequence_num--;

  emit_insn (&insn);
#endif /* OBJ_ECOFF || OBJ_ELF */
}

d3149 3
a3151 4
add_to_link_pool (basesym, sym, addend)
     symbolS *basesym;
     symbolS *sym;
     offsetT addend;
d3196 8
d3205 10
a3214 164
/* Load a (partial) expression into a target register.

   If poffset is not null, after the call it will either contain
   O_constant 0, or a 16-bit offset appropriate for any MEM format
   instruction.  In addition, pbasereg will be modified to point to
   the base register to use in that MEM format instruction.

   In any case, *pbasereg should contain a base register to add to the
   expression.  This will normally be either AXP_REG_ZERO or
   alpha_gp_register.  Symbol addresses will always be loaded via $gp,
   so "foo($0)" is interpreted as adding the address of foo to $0;
   i.e. "ldq $targ, LIT($gp); addq $targ, $0, $targ".  Odd, perhaps,
   but this is what OSF/1 does.

   If explicit relocations of the form !literal!<number> are allowed,
   and used, then explicit_reloc with be an expression pointer.

   Finally, the return value is nonzero if the calling macro may emit
   a LITUSE reloc if otherwise appropriate; the return value is the
   sequence number to use.  */

static long
load_expression (targreg, exp, pbasereg, poffset)
     int targreg;
     const expressionS *exp;
     int *pbasereg;
     expressionS *poffset;
{
  long emit_lituse = 0;
  offsetT addend = exp->X_add_number;
  int basereg = *pbasereg;
  struct alpha_insn insn;
  expressionS newtok[3];

  switch (exp->X_op)
    {
    case O_symbol:
      {
#ifdef OBJ_ECOFF
	offsetT lit;

	/* Attempt to reduce .lit load by splitting the offset from
	   its symbol when possible, but don't create a situation in
	   which we'd fail.  */
	if (!range_signed_32 (addend) &&
	    (alpha_noat_on || targreg == AXP_REG_AT))
	  {
	    lit = add_to_literal_pool (exp->X_add_symbol, addend,
				       alpha_lita_section, 8);
	    addend = 0;
	  }
	else
	  {
	    lit = add_to_literal_pool (exp->X_add_symbol, 0,
				       alpha_lita_section, 8);
	  }

	if (lit >= 0x8000)
	  as_fatal (_("overflow in literal (.lita) table"));

	/* emit "ldq r, lit(gp)" */

	if (basereg != alpha_gp_register && targreg == basereg)
	  {
	    if (alpha_noat_on)
	      as_bad (_("macro requires $at register while noat in effect"));
	    if (targreg == AXP_REG_AT)
	      as_bad (_("macro requires $at while $at in use"));

	    set_tok_reg (newtok[0], AXP_REG_AT);
	  }
	else
	  set_tok_reg (newtok[0], targreg);
	set_tok_sym (newtok[1], alpha_lita_symbol, lit);
	set_tok_preg (newtok[2], alpha_gp_register);

	assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

	assert (insn.nfixups == 1);
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
	insn.sequence = emit_lituse = next_sequence_num--;
#endif /* OBJ_ECOFF */
#ifdef OBJ_ELF
	/* emit "ldq r, gotoff(gp)" */

	if (basereg != alpha_gp_register && targreg == basereg)
	  {
	    if (alpha_noat_on)
	      as_bad (_("macro requires $at register while noat in effect"));
	    if (targreg == AXP_REG_AT)
	      as_bad (_("macro requires $at while $at in use"));

	    set_tok_reg (newtok[0], AXP_REG_AT);
	  }
	else
	  set_tok_reg (newtok[0], targreg);

	/* XXX: Disable this .got minimizing optimization so that we can get
	   better instruction offset knowledge in the compiler.  This happens
	   very infrequently anyway.  */
	if (1
	    || (!range_signed_32 (addend)
		&& (alpha_noat_on || targreg == AXP_REG_AT)))
	  {
	    newtok[1] = *exp;
	    addend = 0;
	  }
	else
	  {
	    set_tok_sym (newtok[1], exp->X_add_symbol, 0);
	  }

	set_tok_preg (newtok[2], alpha_gp_register);

	assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

	assert (insn.nfixups == 1);
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
	insn.sequence = emit_lituse = next_sequence_num--;
#endif /* OBJ_ELF */
#ifdef OBJ_EVAX
	offsetT link;

	/* Find symbol or symbol pointer in link section.  */

	if (exp->X_add_symbol == alpha_evax_proc.symbol)
	  {
	    if (range_signed_16 (addend))
	      {
		set_tok_reg (newtok[0], targreg);
		set_tok_const (newtok[1], addend);
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("lda", newtok, 3, &insn);
		addend = 0;
	      }
	    else
	      {
		set_tok_reg (newtok[0], targreg);
		set_tok_const (newtok[1], 0);
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("lda", newtok, 3, &insn);
	      }
	  }
	else
	  {
	    if (!range_signed_32 (addend))
	      {
		link = add_to_link_pool (alpha_evax_proc.symbol,
					 exp->X_add_symbol, addend);
		addend = 0;
	      }
	    else
	      {
		link = add_to_link_pool (alpha_evax_proc.symbol,
					 exp->X_add_symbol, 0);
	      }
	    set_tok_reg (newtok[0], targreg);
	    set_tok_const (newtok[1], link);
	    set_tok_preg (newtok[2], basereg);
	    assemble_tokens_to_insn ("ldq", newtok, 3, &insn);
	  }
#endif /* OBJ_EVAX */

	emit_insn (&insn);
d3216 2
a3217 4
#ifndef OBJ_EVAX
	if (basereg != alpha_gp_register && basereg != AXP_REG_ZERO)
	  {
	    /* emit "addq r, base, r" */
d3219 7
a3225 4
	    set_tok_reg (newtok[1], basereg);
	    set_tok_reg (newtok[2], targreg);
	    assemble_tokens ("addq", newtok, 3, 0);
	  }
d3227 4
d3232 1
a3232 3
	basereg = targreg;
      }
      break;
d3234 2
a3235 2
    case O_constant:
      break;
d3237 13
a3249 3
    case O_subtract:
      /* Assume that this difference expression will be resolved to an
	 absolute value and that that value will fit in 16 bits.  */
d3251 2
a3252 4
      set_tok_reg (newtok[0], targreg);
      newtok[1] = *exp;
      set_tok_preg (newtok[2], basereg);
      assemble_tokens ("lda", newtok, 3, 0);
d3254 3
a3256 3
      if (poffset)
	set_tok_const (*poffset, 0);
      return 0;
d3258 1
a3258 7
    case O_big:
      if (exp->X_add_number > 0)
	as_bad (_("bignum invalid; zero assumed"));
      else
	as_bad (_("floating point number invalid; zero assumed"));
      addend = 0;
      break;
d3260 11
a3270 4
    default:
      as_bad (_("can't handle expression"));
      addend = 0;
      break;
d3273 13
a3285 1
  if (!range_signed_32 (addend))
d3287 7
a3293 2
      offsetT lit;
      long seq_num = next_sequence_num--;
d3295 6
a3300 1
      /* For 64-bit addends, just put it in the literal pool.  */
d3303 26
a3328 7
      /* emit "ldq targreg, lit(basereg)"  */
      lit = add_to_link_pool (alpha_evax_proc.symbol,
			      section_symbol (absolute_section), addend);
      set_tok_reg (newtok[0], targreg);
      set_tok_const (newtok[1], lit);
      set_tok_preg (newtok[2], alpha_gp_register);
      assemble_tokens ("ldq", newtok, 3, 0);
d3330 13
d3344 1
a3344 5
      if (alpha_lit8_section == NULL)
	{
	  create_literal_section (".lit8",
				  &alpha_lit8_section,
				  &alpha_lit8_symbol);
a3346 6
	  alpha_lit8_literal = add_to_literal_pool (alpha_lit8_symbol, 0x8000,
						    alpha_lita_section, 8);
	  if (alpha_lit8_literal >= 0x8000)
	    as_fatal (_("overflow in literal (.lita) table"));
#endif
	}
d3348 2
a3349 3
      lit = add_to_literal_pool (NULL, addend, alpha_lit8_section, 8) - 0x8000;
      if (lit >= 0x8000)
	as_fatal (_("overflow in literal (.lit8) table"));
d3351 4
a3354 1
      /* emit "lda litreg, .lit8+0x8000" */
d3356 7
a3362 6
      if (targreg == basereg)
	{
	  if (alpha_noat_on)
	    as_bad (_("macro requires $at register while noat in effect"));
	  if (targreg == AXP_REG_AT)
	    as_bad (_("macro requires $at while $at in use"));
a3363 9
	  set_tok_reg (newtok[0], AXP_REG_AT);
	}
      else
	set_tok_reg (newtok[0], targreg);
#ifdef OBJ_ECOFF
      set_tok_sym (newtok[1], alpha_lita_symbol, alpha_lit8_literal);
#endif
#ifdef OBJ_ELF
      set_tok_sym (newtok[1], alpha_lit8_symbol, 0x8000);
a3364 1
      set_tok_preg (newtok[2], alpha_gp_register);
d3366 1
a3366 1
      assemble_tokens_to_insn ("ldq", newtok, 3, &insn);
d3368 2
a3369 8
      assert (insn.nfixups == 1);
#ifdef OBJ_ECOFF
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
#endif
#ifdef OBJ_ELF
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
#endif
      insn.sequence = seq_num;
d3371 4
a3374 1
      emit_insn (&insn);
d3376 8
a3383 1
      /* emit "ldq litreg, lit(litreg)" */
d3385 13
a3397 2
      set_tok_const (newtok[1], lit);
      set_tok_preg (newtok[2], newtok[0].X_add_number);
d3399 2
a3400 1
      assemble_tokens_to_insn ("ldq", newtok, 3, &insn);
d3402 3
a3404 6
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = seq_num;
      emit_lituse = 0;
d3406 2
a3407 1
      emit_insn (&insn);
d3409 4
a3412 1
      /* emit "addq litreg, base, target" */
d3414 4
a3417 7
      if (basereg != AXP_REG_ZERO)
	{
	  set_tok_reg (newtok[1], basereg);
	  set_tok_reg (newtok[2], targreg);
	  assemble_tokens ("addq", newtok, 3, 0);
	}
#endif /* !OBJ_EVAX */
d3419 5
a3423 4
      if (poffset)
	set_tok_const (*poffset, 0);
      *pbasereg = targreg;
    }
d3426 3
a3428 1
      offsetT low, high, extra, tmp;
d3430 1
a3430 7
      /* for 32-bit operands, break up the addend */

      low = sign_extend_16 (addend);
      tmp = addend - low;
      high = sign_extend_16 (tmp >> 16);

      if (tmp - (high << 16))
d3432 2
a3433 3
	  extra = 0x4000;
	  tmp -= 0x40000000;
	  high = sign_extend_16 (tmp >> 16);
d3436 8
a3443 1
	extra = 0;
d3445 2
a3446 2
      set_tok_reg (newtok[0], targreg);
      set_tok_preg (newtok[2], basereg);
d3448 3
a3450 7
      if (extra)
	{
	  /* emit "ldah r, extra(r) */
	  set_tok_const (newtok[1], extra);
	  assemble_tokens ("ldah", newtok, 3, 0);
	  set_tok_preg (newtok[2], basereg = targreg);
	}
d3452 2
a3453 8
      if (high)
	{
	  /* emit "ldah r, high(r) */
	  set_tok_const (newtok[1], high);
	  assemble_tokens ("ldah", newtok, 3, 0);
	  basereg = targreg;
	  set_tok_preg (newtok[2], basereg);
	}
d3455 11
a3465 7
      if ((low && !poffset) || (!poffset && basereg != targreg))
	{
	  /* emit "lda r, low(base)" */
	  set_tok_const (newtok[1], low);
	  assemble_tokens ("lda", newtok, 3, 0);
	  basereg = targreg;
	  low = 0;
d3467 1
a3467 4

      if (poffset)
	set_tok_const (*poffset, low);
      *pbasereg = basereg;
a3468 2

  return emit_lituse;
a3470 4
/* The lda macro differs from the lda instruction in that it handles
   most simple expressions, particularly symbol address loads and
   large constants.  */

d3472 1
a3472 4
emit_lda (tok, ntok, unused)
     const expressionS *tok;
     int ntok;
     const PTR unused ATTRIBUTE_UNUSED;
d3474 2
a3475 4
  int basereg;

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
d3477 4
a3480 1
    basereg = tok[2].X_add_number;
d3482 8
a3489 2
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL);
}
d3491 5
a3495 2
/* The ldah macro differs from the ldah instruction in that it has $31
   as an implied base register.  */
d3497 5
a3501 7
static void
emit_ldah (tok, ntok, unused)
     const expressionS *tok;
     int ntok ATTRIBUTE_UNUSED;
     const PTR unused ATTRIBUTE_UNUSED;
{
  expressionS newtok[3];
d3503 5
a3507 3
  newtok[0] = tok[0];
  newtok[1] = tok[1];
  set_tok_preg (newtok[2], AXP_REG_ZERO);
d3509 2
a3510 2
  assemble_tokens ("ldah", newtok, 3, 0);
}
d3512 1
a3512 3
/* Handle all "simple" integer register loads -- ldq, ldq_l, ldq_u,
   etc.  They differ from the real instructions in that they do simple
   expressions like the lda macro.  */
d3514 3
a3516 31
static void
emit_ir_load (tok, ntok, opname)
     const expressionS *tok;
     int ntok;
     const PTR opname;
{
  int basereg;
  long lituse;
  expressionS newtok[3];
  struct alpha_insn insn;

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  lituse = load_expression (tok[0].X_add_number, &tok[1], &basereg,
			    &newtok[1]);

  newtok[0] = tok[0];
  set_tok_preg (newtok[2], basereg);

  assemble_tokens_to_insn ((const char *) opname, newtok, 3, &insn);

  if (lituse)
    {
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
a3517 2

  emit_insn (&insn);
a3519 3
/* Handle fp register loads, and both integer and fp register stores.
   Again, we handle simple expressions.  */

d3521 1
a3521 4
emit_loadstore (tok, ntok, opname)
     const expressionS *tok;
     int ntok;
     const PTR opname;
d3523 1
a3523 11
  int basereg;
  long lituse;
  expressionS newtok[3];
  struct alpha_insn insn;

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  if (tok[1].X_op != O_constant || !range_signed_16 (tok[1].X_add_number))
d3525 4
a3528 4
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1]);
d3532 12
a3543 3
      newtok[1] = tok[1];
      lituse = 0;
    }
d3545 10
a3554 2
  newtok[0] = tok[0];
  set_tok_preg (newtok[2], basereg);
d3556 2
a3557 1
  assemble_tokens_to_insn ((const char *) opname, newtok, 3, &insn);
d3559 10
a3568 7
  if (lituse)
    {
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
a3569 2

  emit_insn (&insn);
a3571 2
/* Load a half-word or byte as an unsigned value.  */

d3573 1
a3573 4
emit_ldXu (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
d3575 2
a3576 2
  if (alpha_target & AXP_OPCODE_BWX)
    emit_ir_load (tok, ntok, ldXu_op[(long) vlgsize]);
d3579 1
a3579 4
      expressionS newtok[3];
      struct alpha_insn insn;
      int basereg;
      long lituse;
d3581 1
a3581 21
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      if (ntok == 2)
	basereg = (tok[1].X_op == O_constant
		   ? AXP_REG_ZERO : alpha_gp_register);
      else
	basereg = tok[2].X_add_number;

      /* emit "lda $at, exp" */

      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL);

      /* emit "ldq_u targ, 0($at)" */

      newtok[0] = tok[0];
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], basereg);
      assemble_tokens_to_insn ("ldq_u", newtok, 3, &insn);

      if (lituse)
d3583 3
a3585 5
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
d3588 1
a3588 1
      emit_insn (&insn);
d3590 3
a3592 7
      /* emit "extXl targ, $at, targ" */

      set_tok_reg (newtok[1], basereg);
      newtok[2] = newtok[0];
      assemble_tokens_to_insn (extXl_op[(long) vlgsize], newtok, 3, &insn);

      if (lituse)
d3594 4
a3597 5
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
d3599 3
d3603 4
a3606 1
      emit_insn (&insn);
a3609 2
/* Load a half-word or byte as a signed value.  */

d3611 1
a3611 4
emit_ldX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
d3613 2
a3614 3
  emit_ldXu (tok, ntok, vlgsize);
  assemble_tokens (sextX_op[(long) vlgsize], tok, 1, 1);
}
d3616 2
a3617 2
/* Load an integral value from an unaligned address as an unsigned
   value.  */
d3619 4
a3622 8
static void
emit_uldXu (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
{
  long lgsize = (long) vlgsize;
  expressionS newtok[3];
d3624 5
a3628 2
  if (alpha_noat_on)
    as_bad (_("macro requires $at register while noat in effect"));
d3630 12
a3641 1
  /* emit "lda $at, exp" */
d3643 4
a3646 3
  memcpy (newtok, tok, sizeof (expressionS) * ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);
d3648 2
a3649 32
  /* emit "ldq_u $t9, 0($at)" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "ldq_u $t10, size-1($at)" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "extXl $t9, $at, $t9" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T9);
  assemble_tokens (extXl_op[lgsize], newtok, 3, 1);

  /* emit "extXh $t10, $at, $t10" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_reg (newtok[2], AXP_REG_T10);
  assemble_tokens (extXh_op[lgsize], newtok, 3, 1);

  /* emit "or $t9, $t10, targ" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_T10);
  newtok[2] = tok[0];
  assemble_tokens ("or", newtok, 3, 1);
d3652 1
a3652 3
/* Load an integral value from an unaligned address as a signed value.
   Note that quads should get funneled to the unsigned load since we
   don't have to do the sign extension.  */
d3655 1
a3655 4
emit_uldX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
d3657 6
a3662 3
  emit_uldXu (tok, ntok, vlgsize);
  assemble_tokens (sextX_op[(long) vlgsize], tok, 1, 1);
}
d3664 1
a3664 1
/* Implement the ldil macro.  */
d3666 4
a3669 7
static void
emit_ldil (tok, ntok, unused)
     const expressionS *tok;
     int ntok;
     const PTR unused ATTRIBUTE_UNUSED;
{
  expressionS newtok[2];
d3671 2
a3672 2
  memcpy (newtok, tok, sizeof (newtok));
  newtok[1].X_add_number = sign_extend_32 (tok[1].X_add_number);
d3674 4
a3677 1
  assemble_tokens ("lda", newtok, ntok, 1);
a3679 2
/* Store a half-word or byte.  */

d3681 1
a3681 4
emit_stX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
d3683 2
a3684 4
  int lgsize = (int) (long) vlgsize;

  if (alpha_target & AXP_OPCODE_BWX)
    emit_loadstore (tok, ntok, stX_op[lgsize]);
d3686 2
a3687 73
    {
      expressionS newtok[3];
      struct alpha_insn insn;
      int basereg;
      long lituse;

      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      if (ntok == 2)
	basereg = (tok[1].X_op == O_constant
		   ? AXP_REG_ZERO : alpha_gp_register);
      else
	basereg = tok[2].X_add_number;

      /* emit "lda $at, exp" */

      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL);

      /* emit "ldq_u $t9, 0($at)" */

      set_tok_reg (newtok[0], AXP_REG_T9);
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], basereg);
      assemble_tokens_to_insn ("ldq_u", newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* emit "insXl src, $at, $t10" */

      newtok[0] = tok[0];
      set_tok_reg (newtok[1], basereg);
      set_tok_reg (newtok[2], AXP_REG_T10);
      assemble_tokens_to_insn (insXl_op[lgsize], newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* emit "mskXl $t9, $at, $t9" */

      set_tok_reg (newtok[0], AXP_REG_T9);
      newtok[2] = newtok[0];
      assemble_tokens_to_insn (mskXl_op[lgsize], newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* emit "or $t9, $t10, $t9" */
d3689 9
a3697 2
      set_tok_reg (newtok[1], AXP_REG_T10);
      assemble_tokens ("or", newtok, 3, 1);
d3699 1
a3699 1
      /* emit "stq_u $t9, 0($at) */
d3701 1
a3701 5
      set_tok_const(newtok[1], 0);
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens_to_insn ("stq_u", newtok, 3, &insn);

      if (lituse)
d3703 5
a3707 5
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
d3710 1
a3710 1
      emit_insn (&insn);
d3712 1
a3714 2
/* Store an integer to an unaligned address.  */

d3716 1
a3716 4
emit_ustX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
d3718 10
a3727 2
  int lgsize = (int) (long) vlgsize;
  expressionS newtok[3];
d3729 1
a3729 1
  /* emit "lda $at, exp" */
d3731 8
a3738 3
  memcpy (newtok, tok, sizeof (expressionS) * ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);
d3740 2
a3741 1
  /* emit "ldq_u $9, 0($at)" */
d3743 4
a3746 4
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);
d3748 2
a3749 1
  /* emit "ldq_u $10, size-1($at)" */
d3751 3
a3753 3
  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  assemble_tokens ("ldq_u", newtok, 3, 1);
d3755 9
a3763 1
  /* emit "insXl src, $at, $t11" */
d3765 6
a3770 4
  newtok[0] = tok[0];
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T11);
  assemble_tokens (insXl_op[lgsize], newtok, 3, 1);
d3772 1
a3772 1
  /* emit "insXh src, $at, $t12" */
d3774 7
a3780 2
  set_tok_reg (newtok[2], AXP_REG_T12);
  assemble_tokens (insXh_op[lgsize], newtok, 3, 1);
d3782 2
a3783 1
  /* emit "mskXl $t9, $at, $t9" */
d3785 13
a3797 3
  set_tok_reg (newtok[0], AXP_REG_T9);
  newtok[2] = newtok[0];
  assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);
d3799 3
a3801 1
  /* emit "mskXh $t10, $at, $t10" */
d3803 8
a3810 3
  set_tok_reg (newtok[0], AXP_REG_T10);
  newtok[2] = newtok[0];
  assemble_tokens (mskXh_op[lgsize], newtok, 3, 1);
d3812 4
a3815 1
  /* emit "or $t9, $t11, $t9" */
d3817 2
a3818 24
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_T11);
  newtok[2] = newtok[0];
  assemble_tokens ("or", newtok, 3, 1);

  /* emit "or $t10, $t12, $t10" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_reg (newtok[1], AXP_REG_T12);
  newtok[2] = newtok[0];
  assemble_tokens ("or", newtok, 3, 1);

  /* emit "stq_u $t9, 0($at)" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("stq_u", newtok, 3, 1);

  /* emit "stq_u $t10, size-1($at)" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  assemble_tokens ("stq_u", newtok, 3, 1);
a3820 3
/* Sign extend a half-word or byte.  The 32-bit sign extend is
   implemented as "addl $31, $r, $t" in the opcode table.  */

d3822 1
a3822 4
emit_sextX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
d3824 7
a3830 1
  long lgsize = (long) vlgsize;
d3832 1
a3832 3
  if (alpha_target & AXP_OPCODE_BWX)
    assemble_tokens (sextX_op[lgsize], tok, ntok, 0);
  else
d3834 4
a3837 14
      int bitshift = 64 - 8 * (1 << lgsize);
      expressionS newtok[3];

      /* emit "sll src,bits,dst" */

      newtok[0] = tok[0];
      set_tok_const (newtok[1], bitshift);
      newtok[2] = tok[ntok - 1];
      assemble_tokens ("sll", newtok, 3, 1);

      /* emit "sra dst,bits,dst" */

      newtok[0] = newtok[2];
      assemble_tokens ("sra", newtok, 3, 1);
a3838 1
}
d3840 2
a3841 1
/* Implement the division and modulus macros.  */
d3843 1
a3843 39
#ifdef OBJ_EVAX

/* Make register usage like in normal procedure call.
   Don't clobber PV and RA.  */

static void
emit_division (tok, ntok, symname)
     const expressionS *tok;
     int ntok;
     const PTR symname;
{
  /* DIVISION and MODULUS. Yech.
   
     Convert
        OP x,y,result
     to
        mov x,R16	# if x != R16
        mov y,R17	# if y != R17
        lda AT,__OP
        jsr AT,(AT),0
        mov R0,result
    
     with appropriate optimizations if R0,R16,R17 are the registers
     specified by the compiler.  */

  int xr, yr, rr;
  symbolS *sym;
  expressionS newtok[3];

  xr = regno (tok[0].X_add_number);
  yr = regno (tok[1].X_add_number);

  if (ntok < 3)
    rr = xr;
  else
    rr = regno (tok[2].X_add_number);

  /* Move the operands into the right place.  */
  if (yr == AXP_REG_R16 && xr == AXP_REG_R17)
d3845 4
a3848 1
      /* They are in exactly the wrong order -- swap through AT.  */
d3850 3
a3852 2
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));
d3854 4
a3857 12
      set_tok_reg (newtok[0], AXP_REG_R16);
      set_tok_reg (newtok[1], AXP_REG_AT);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_R17);
      set_tok_reg (newtok[1], AXP_REG_R16);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_AT);
      set_tok_reg (newtok[1], AXP_REG_R17);
      assemble_tokens ("mov", newtok, 2, 1);
    }
d3860 10
a3869 6
      if (yr == AXP_REG_R16)
	{
	  set_tok_reg (newtok[0], AXP_REG_R16);
	  set_tok_reg (newtok[1], AXP_REG_R17);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
d3871 1
a3871 6
      if (xr != AXP_REG_R16)
	{
	  set_tok_reg (newtok[0], xr);
	  set_tok_reg (newtok[1], AXP_REG_R16);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
d3873 5
a3877 7
      if (yr != AXP_REG_R16 && yr != AXP_REG_R17)
	{
	  set_tok_reg (newtok[0], yr);
	  set_tok_reg (newtok[1], AXP_REG_R17);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
    }
d3879 1
a3879 1
  sym = symbol_find_or_make ((const char *) symname);
d3881 1
a3881 3
  set_tok_reg (newtok[0], AXP_REG_AT);
  set_tok_sym (newtok[1], sym, 0);
  assemble_tokens ("lda", newtok, 2, 1);
d3883 7
a3889 5
  /* Call the division routine.  */
  set_tok_reg (newtok[0], AXP_REG_AT);
  set_tok_cpreg (newtok[1], AXP_REG_AT);
  set_tok_const (newtok[2], 0);
  assemble_tokens ("jsr", newtok, 3, 1);
d3891 1
a3891 2
  /* Move the result to the right place.  */
  if (rr != AXP_REG_R0)
d3893 3
a3895 3
      set_tok_reg (newtok[0], AXP_REG_R0);
      set_tok_reg (newtok[1], rr);
      assemble_tokens ("mov", newtok, 2, 1);
d3897 6
d3905 1
a3905 1
#else /* !OBJ_EVAX */
d3908 1
a3908 4
emit_division (tok, ntok, symname)
     const expressionS *tok;
     int ntok;
     const PTR symname;
d3910 13
a3922 12
  /* DIVISION and MODULUS. Yech.
     Convert
        OP x,y,result
     to
        lda pv,__OP
        mov x,t10
        mov y,t11
        jsr t9,(pv),__OP
        mov t12,result
    
     with appropriate optimizations if t10,t11,t12 are the registers
     specified by the compiler.  */
d3924 1
a3924 3
  int xr, yr, rr;
  symbolS *sym;
  expressionS newtok[3];
d3926 6
a3931 2
  xr = regno (tok[0].X_add_number);
  yr = regno (tok[1].X_add_number);
d3933 3
a3935 4
  if (ntok < 3)
    rr = xr;
  else
    rr = regno (tok[2].X_add_number);
d3937 2
a3938 1
  sym = symbol_find_or_make ((const char *) symname);
d3940 1
a3940 6
  /* Move the operands into the right place.  */
  if (yr == AXP_REG_T10 && xr == AXP_REG_T11)
    {
      /* They are in exactly the wrong order -- swap through AT.  */
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));
d3942 4
a3945 3
      set_tok_reg (newtok[0], AXP_REG_T10);
      set_tok_reg (newtok[1], AXP_REG_AT);
      assemble_tokens ("mov", newtok, 2, 1);
d3947 1
a3947 3
      set_tok_reg (newtok[0], AXP_REG_T11);
      set_tok_reg (newtok[1], AXP_REG_T10);
      assemble_tokens ("mov", newtok, 2, 1);
d3949 8
a3956 3
      set_tok_reg (newtok[0], AXP_REG_AT);
      set_tok_reg (newtok[1], AXP_REG_T11);
      assemble_tokens ("mov", newtok, 2, 1);
d3958 6
a3963 1
  else
d3965 7
a3971 6
      if (yr == AXP_REG_T10)
	{
	  set_tok_reg (newtok[0], AXP_REG_T10);
	  set_tok_reg (newtok[1], AXP_REG_T11);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
d3973 11
a3983 6
      if (xr != AXP_REG_T10)
	{
	  set_tok_reg (newtok[0], xr);
	  set_tok_reg (newtok[1], AXP_REG_T10);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
d3985 5
a3989 6
      if (yr != AXP_REG_T10 && yr != AXP_REG_T11)
	{
	  set_tok_reg (newtok[0], yr);
	  set_tok_reg (newtok[1], AXP_REG_T11);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
d3992 7
a3998 4
  /* Call the division routine.  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_sym (newtok[1], sym, 0);
  assemble_tokens ("jsr", newtok, 2, 1);
d4000 2
a4001 10
  /* Reload the GP register.  */
#ifdef OBJ_AOUT
FIXME
#endif
#if defined(OBJ_ECOFF) || defined(OBJ_ELF)
  set_tok_reg (newtok[0], alpha_gp_register);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_T9);
  assemble_tokens ("ldgp", newtok, 3, 1);
#endif
d4003 2
a4004 2
  /* Move the result to the right place.  */
  if (rr != AXP_REG_T12)
d4006 3
a4008 3
      set_tok_reg (newtok[0], AXP_REG_T12);
      set_tok_reg (newtok[1], rr);
      assemble_tokens ("mov", newtok, 2, 1);
a4009 1
}
d4011 12
a4022 1
#endif /* !OBJ_EVAX */
d4024 3
a4026 3
/* The jsr and jmp macros differ from their instruction counterparts
   in that they can load the target address and default most
   everything.  */
d4028 2
a4029 11
static void
emit_jsrjmp (tok, ntok, vopname)
     const expressionS *tok;
     int ntok;
     const PTR vopname;
{
  const char *opname = (const char *) vopname;
  struct alpha_insn insn;
  expressionS newtok[3];
  int r, tokidx = 0;
  long lituse = 0;
d4031 2
a4032 4
  if (tokidx < ntok && tok[tokidx].X_op == O_register)
    r = regno (tok[tokidx++].X_add_number);
  else
    r = strcmp (opname, "jmp") == 0 ? AXP_REG_ZERO : AXP_REG_RA;
d4034 2
a4035 1
  set_tok_reg (newtok[0], r);
a4036 6
  if (tokidx < ntok &&
      (tok[tokidx].X_op == O_pregister || tok[tokidx].X_op == O_cpregister))
    r = regno (tok[tokidx++].X_add_number);
#ifdef OBJ_EVAX
  /* keep register if jsr $n.<sym>  */
#else
d4039 3
a4041 2
      int basereg = alpha_gp_register;
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL);
a4042 1
#endif
d4044 2
a4045 1
  set_tok_cpreg (newtok[1], r);
d4047 2
a4048 6
#ifdef OBJ_EVAX
  /* FIXME: Add hint relocs to BFD for evax.  */
#else
  if (tokidx < ntok)
    newtok[2] = tok[tokidx];
  else
a4049 1
    set_tok_const (newtok[2], 0);
d4051 9
a4059 1
  assemble_tokens_to_insn (opname, newtok, 3, &insn);
d4061 1
a4061 1
  if (lituse)
d4063 13
a4075 5
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_JSR;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
d4078 2
a4079 2
  emit_insn (&insn);
}
d4081 2
a4082 2
/* The ret and jcr instructions differ from their instruction
   counterparts in that everything can be defaulted.  */
d4084 1
a4084 9
static void
emit_retjcr (tok, ntok, vopname)
     const expressionS *tok;
     int ntok;
     const PTR vopname;
{
  const char *opname = (const char *) vopname;
  expressionS newtok[3];
  int r, tokidx = 0;
d4086 2
a4087 4
  if (tokidx < ntok && tok[tokidx].X_op == O_register)
    r = regno (tok[tokidx++].X_add_number);
  else
    r = AXP_REG_ZERO;
d4089 5
a4093 1
  set_tok_reg (newtok[0], r);
d4095 2
a4096 5
  if (tokidx < ntok &&
      (tok[tokidx].X_op == O_pregister || tok[tokidx].X_op == O_cpregister))
    r = regno (tok[tokidx++].X_add_number);
  else
    r = AXP_REG_RA;
d4098 1
a4098 1
  set_tok_cpreg (newtok[1], r);
d4100 2
a4101 4
  if (tokidx < ntok)
    newtok[2] = tok[tokidx];
  else
    set_tok_const (newtok[2], strcmp (opname, "ret") == 0);
d4103 2
a4104 4
  assemble_tokens (opname, newtok, 3, 0);
}

/* Assembler directives.  */
d4106 5
a4110 2
/* Handle the .text pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */
d4112 1
a4112 3
static void
s_alpha_text (i)
     int i;
d4114 2
a4115 9
{
#ifdef OBJ_ELF
  obj_elf_text (i);
#else
  s_text (i);
#endif
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
d4118 1
a4118 2
/* Handle the .data pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */
d4121 1
a4121 2
s_alpha_data (i)
     int i;
d4123 3
a4125 9
#ifdef OBJ_ELF
  obj_elf_data (i);
#else
  s_data (i);
#endif
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}
d4127 1
a4127 32
#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)

/* Handle the OSF/1 and openVMS .comm pseudo quirks.
   openVMS constructs a section for every common symbol.  */

static void
s_alpha_comm (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  register char *name;
  register char c;
  register char *p;
  offsetT temp;
  register symbolS *symbolP;

#ifdef OBJ_EVAX
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_seg;
#endif

  name = input_line_pointer;
  c = get_symbol_end ();

  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;

  SKIP_WHITESPACE ();

  /* Alpha OSF/1 compiler doesn't provide the comma, gcc does.  */
  if (*input_line_pointer == ',')
d4129 3
a4131 2
      input_line_pointer++;
      SKIP_WHITESPACE ();
d4133 3
a4135 1
  if ((temp = get_absolute_expression ()) < 0)
d4137 2
a4138 2
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
      ignore_rest_of_line ();
d4142 1
a4142 2
  *p = 0;
  symbolP = symbol_find_or_make (name);
d4144 2
a4145 3
#ifdef OBJ_EVAX
  /* Make a section for the common symbol.  */
  new_seg = subseg_new (xstrdup (name), 0);
d4148 6
a4153 1
  *p = c;
d4155 5
a4159 5
#ifdef OBJ_EVAX
  /* alignment might follow  */
  if (*input_line_pointer == ',')
    {
      offsetT align;
d4161 2
a4162 4
      input_line_pointer++;
      align = get_absolute_expression ();
      bfd_set_section_alignment (stdoutput, new_seg, align);
    }
d4165 2
a4166 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d4168 1
a4168 3
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
d4170 1
a4170 3

#ifdef OBJ_EVAX
  if (bfd_section_size (stdoutput, new_seg) > 0)
d4172 4
a4175 28
      if (bfd_section_size (stdoutput, new_seg) != temp)
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) bfd_section_size (stdoutput, new_seg),
		(long) temp);
    }
#else
  if (S_GET_VALUE (symbolP))
    {
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
    }
#endif
  else
    {
#ifdef OBJ_EVAX
      subseg_set (new_seg, 0);
      p = frag_more (temp);
      new_seg->flags |= SEC_IS_COMMON;
      if (! S_IS_DEFINED (symbolP))
	S_SET_SEGMENT (symbolP, new_seg);
#else
      S_SET_VALUE (symbolP, (valueT) temp);
#endif
      S_SET_EXTERNAL (symbolP);
d4177 8
d4186 2
a4187 2
#ifdef OBJ_EVAX
  subseg_set (current_section, current_subsec);
d4190 10
a4199 2
  know (symbol_get_frag (symbolP) == &zero_address_frag);

d4203 3
a4205 1
#endif /* ! OBJ_ELF */
d4207 1
a4207 1
#ifdef OBJ_ECOFF
d4209 2
a4210 2
/* Handle the .rdata pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */
d4213 1
a4213 2
s_alpha_rdata (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4215 1
a4215 1
  int temp;
d4217 10
a4226 2
  temp = get_absolute_expression ();
  subseg_new (".rdata", 0);
a4227 3
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
a4229 7
#endif

#ifdef OBJ_ECOFF

/* Handle the .sdata pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

d4231 1
a4231 2
s_alpha_sdata (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4233 1
a4233 1
  int temp;
d4235 10
a4244 2
  temp = get_absolute_expression ();
  subseg_new (".sdata", 0);
a4245 3
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
a4246 25
#endif

#ifdef OBJ_ELF
struct alpha_elf_frame_data
{
  symbolS *func_sym;
  symbolS *func_end_sym;
  symbolS *prologue_sym;
  unsigned int mask;
  unsigned int fmask;
  int fp_regno;
  int ra_regno;
  offsetT frame_size;
  offsetT mask_offset;
  offsetT fmask_offset;

  struct alpha_elf_frame_data *next;
};

static struct alpha_elf_frame_data *all_frame_data;
static struct alpha_elf_frame_data **plast_frame_data = &all_frame_data;
static struct alpha_elf_frame_data *cur_frame_data;

/* Handle the .section pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */
d4249 1
a4249 2
s_alpha_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4251 1
a4251 1
  obj_elf_section (ignore);
d4253 4
a4256 3
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
d4260 1
a4260 2
s_alpha_ent (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4262 3
a4264 7
  if (ECOFF_DEBUGGING)
    ecoff_directive_ent (0);
  else
    {
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();
d4266 2
a4267 8
      if (! is_name_beginner (*name))
	{
	  as_warn (_(".ent directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;
d4269 2
a4270 2
	  if (cur_frame_data)
	    as_warn (_("nested .ent directives"));
d4272 6
a4277 2
	  sym = symbol_find_or_make (name);
	  symbol_get_bfdsym (sym)->flags |= BSF_FUNCTION;
d4279 1
a4279 2
	  cur_frame_data = calloc (1, sizeof (*cur_frame_data));
	  cur_frame_data->func_sym = sym;
d4281 5
a4285 3
	  /* Provide sensible defaults.  */
	  cur_frame_data->fp_regno = 30;	/* sp */
	  cur_frame_data->ra_regno = 26;	/* ra */
d4287 2
a4288 2
	  *plast_frame_data = cur_frame_data;
	  plast_frame_data = &cur_frame_data->next;
d4290 25
a4314 13
	  /* The .ent directive is sometimes followed by a number.  Not sure
	     what it really means, but ignore it.  */
	  *input_line_pointer = name_end;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      input_line_pointer++;
	      SKIP_WHITESPACE ();
	    }
	  if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')
	    (void) get_absolute_expression ();
	}
      demand_empty_rest_of_line ();
d4316 13
d4331 4
d4336 1
a4336 2
s_alpha_end (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4338 3
a4340 3
  if (ECOFF_DEBUGGING)
    ecoff_directive_end (0);
  else
d4342 5
a4346 3
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();
d4348 5
a4352 8
      if (! is_name_beginner (*name))
	{
	  as_warn (_(".end directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;
d4354 7
a4360 5
	  sym = symbol_find (name);
	  if (!cur_frame_data)
	    as_warn (_(".end directive without matching .ent"));
	  else if (sym != cur_frame_data->func_sym)
	    as_warn (_(".end directive names different symbol than .ent"));
d4362 5
a4366 11
	  /* Create an expression to calculate the size of the function.  */
	  if (sym && cur_frame_data)
	    {
	      OBJ_SYMFIELD_TYPE *obj = symbol_get_obj (sym);
	      expressionS *exp = xmalloc (sizeof (expressionS));

	      obj->size = exp;
	      exp->X_op = O_subtract;
	      exp->X_add_symbol = symbol_temp_new_now ();
	      exp->X_op_symbol = sym;
	      exp->X_add_number = 0;
d4368 2
a4369 2
	      cur_frame_data->func_end_sym = exp->X_add_symbol;
	    }
d4371 2
a4372 7
	  cur_frame_data = NULL;

	  *input_line_pointer = name_end;
	}
      demand_empty_rest_of_line ();
    }
}
d4375 1
a4375 2
s_alpha_mask (fp)
     int fp;
d4377 15
a4391 1
  if (ECOFF_DEBUGGING)
d4393 5
a4397 4
      if (fp)
	ecoff_directive_fmask (0);
      else
	ecoff_directive_mask (0);
d4401 7
a4407 2
      long val;
      offsetT offset;
d4409 2
a4410 9
      if (!cur_frame_data)
	{
	  if (fp)
	    as_warn (_(".fmask outside of .ent"));
	  else
	    as_warn (_(".mask outside of .ent"));
	  discard_rest_of_line ();
	  return;
	}
d4412 5
a4416 10
      if (get_absolute_expression_and_terminator (&val) != ',')
	{
	  if (fp)
	    as_warn (_("bad .fmask directive"));
	  else
	    as_warn (_("bad .mask directive"));
	  --input_line_pointer;
	  discard_rest_of_line ();
	  return;
	}
d4418 3
a4420 2
      offset = get_absolute_expression ();
      demand_empty_rest_of_line ();
d4422 5
a4426 10
      if (fp)
	{
	  cur_frame_data->fmask = val;
          cur_frame_data->fmask_offset = offset;
	}
      else
	{
	  cur_frame_data->mask = val;
	  cur_frame_data->mask_offset = offset;
	}
d4428 15
d4445 3
d4449 1
a4449 2
s_alpha_frame (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4451 3
a4453 3
  if (ECOFF_DEBUGGING)
    ecoff_directive_frame (0);
  else
d4455 5
a4459 1
      long val;
d4461 6
a4466 6
      if (!cur_frame_data)
	{
	  as_warn (_(".frame outside of .ent"));
	  discard_rest_of_line ();
	  return;
	}
d4468 2
a4469 1
      cur_frame_data->fp_regno = tc_get_register (1);
d4471 3
a4473 19
      SKIP_WHITESPACE ();
      if (*input_line_pointer++ != ','
	  || get_absolute_expression_and_terminator (&val) != ',')
	{
	  as_warn (_("bad .frame directive"));
	  --input_line_pointer;
	  discard_rest_of_line ();
	  return;
	}
      cur_frame_data->frame_size = val;

      cur_frame_data->ra_regno = tc_get_register (0);

      /* Next comes the "offset of saved $a0 from $sp".  In gcc terms
	 this is current_function_pretend_args_size.  There's no place
	 to put this value, so ignore it.  */
      s_ignore (42);
    }
}
d4476 1
a4476 2
s_alpha_prologue (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4478 3
a4480 2
  symbolS *sym;
  int arg;
d4482 11
a4492 2
  arg = get_absolute_expression ();
  demand_empty_rest_of_line ();
d4494 6
a4499 2
  if (ECOFF_DEBUGGING)
    sym = ecoff_get_cur_proc_sym ();
d4501 1
a4501 1
    sym = cur_frame_data ? cur_frame_data->func_sym : NULL;
d4503 6
a4508 1
  if (sym == NULL)
d4510 1
a4510 2
      as_bad (_(".prologue directive without a preceding .ent directive"));
      return;
d4513 2
a4514 12
  switch (arg)
    {
    case 0: /* No PV required.  */
      S_SET_OTHER (sym, STO_ALPHA_NOPV
		   | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
      break;
    case 1: /* Std GP load.  */
      S_SET_OTHER (sym, STO_ALPHA_STD_GPLOAD
		   | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
      break;
    case 2: /* Non-std use of PV.  */
      break;
d4516 1
a4516 4
    default:
      as_bad (_("Invalid argument %d to .prologue."), arg);
      break;
    }
d4518 6
a4523 2
  if (cur_frame_data)
    cur_frame_data->prologue_sym = symbol_temp_new_now ();
d4526 1
a4526 1
static char *first_file_directive;
d4529 1
a4529 2
s_alpha_file (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4531 4
a4534 6
  /* Save the first .file directive we see, so that we can change our
     minds about whether ecoff debugging should or shouldn't be enabled.  */
  if (alpha_flag_mdebug < 0 && ! first_file_directive)
    {
      char *start = input_line_pointer;
      size_t len;
d4536 1
a4536 1
      discard_rest_of_line ();
d4538 4
a4541 4
      len = input_line_pointer - start;
      first_file_directive = xmalloc (len + 1);
      memcpy (first_file_directive, start, len);
      first_file_directive[len] = '\0';
d4543 3
a4545 2
      input_line_pointer = start;
    }
d4547 5
a4551 4
  if (ECOFF_DEBUGGING)
    ecoff_directive_file (0);
  else
    dwarf2_directive_file (0);
d4554 3
d4558 1
a4558 2
s_alpha_loc (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4560 4
a4563 4
  if (ECOFF_DEBUGGING)
    ecoff_directive_loc (0);
  else
    dwarf2_directive_loc (0);
d4566 2
d4569 1
a4569 2
s_alpha_stab (n)
     int n;
d4571 2
a4572 6
  /* If we've been undecided about mdebug, make up our minds in favour.  */
  if (alpha_flag_mdebug < 0)
    {
      segT sec = subseg_new (".mdebug", 0);
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);
      bfd_set_section_alignment (stdoutput, sec, 3);
d4574 3
a4576 1
      ecoff_read_begin_hook ();
d4578 7
a4584 8
      if (first_file_directive)
	{
	  char *save_ilp = input_line_pointer;
	  input_line_pointer = first_file_directive;
	  ecoff_directive_file (0);
	  input_line_pointer = save_ilp;
	  free (first_file_directive);
	}
d4586 3
a4588 3
      alpha_flag_mdebug = 1;
    }
  s_stab (n);
d4590 3
d4595 1
a4595 2
s_alpha_coff_wrapper (which)
     int which;
d4597 1
a4597 16
  static void (* const fns[]) PARAMS ((int)) = {
    ecoff_directive_begin,
    ecoff_directive_bend,
    ecoff_directive_def,
    ecoff_directive_dim,
    ecoff_directive_endef,
    ecoff_directive_scl,
    ecoff_directive_tag,
    ecoff_directive_val,
  };

  assert (which >= 0 && which < (int) (sizeof (fns)/sizeof (*fns)));

  if (ECOFF_DEBUGGING)
    (*fns[which]) (0);
  else
d4599 15
a4613 2
      as_bad (_("ECOFF debugging is disabled."));
      ignore_rest_of_line ();
d4616 3
d4620 1
a4620 5
/* Called at the end of assembly.  Here we emit unwind info for frames
   unless the compiler has done it for us.  */

void
alpha_elf_md_end (void)
d4622 64
a4685 1
  struct alpha_elf_frame_data *p;
d4687 10
a4696 2
  if (cur_frame_data)
    as_warn (_(".ent directive without matching .end"));
d4698 10
a4707 3
  /* If someone has generated the unwind info themselves, great.  */
  if (bfd_get_section_by_name (stdoutput, ".eh_frame") != NULL)
    return;
d4709 4
a4712 9
  /* Generate .eh_frame data for the unwind directives specified.  */
  for (p = all_frame_data; p ; p = p->next)
    if (p->prologue_sym)
      {
	/* Create a temporary symbol at the same location as our
	   function symbol.  This prevents problems with globals.  */
	cfi_new_fde (symbol_temp_new (S_GET_SEGMENT (p->func_sym),
				      S_GET_VALUE (p->func_sym),
				      symbol_get_frag (p->func_sym)));
d4714 6
a4719 6
	cfi_set_return_column (p->ra_regno);
	cfi_add_CFA_def_cfa_register (30);
	if (p->fp_regno != 30 || p->mask || p->fmask || p->frame_size)
	  {
	    unsigned int mask;
	    offsetT offset;
d4721 3
a4723 1
	    cfi_add_advance_loc (p->prologue_sym);
d4725 1
a4725 7
	    if (p->fp_regno != 30)
	      if (p->frame_size != 0)
		cfi_add_CFA_def_cfa (p->fp_regno, p->frame_size);
	      else
		cfi_add_CFA_def_cfa_register (p->fp_regno);
	    else if (p->frame_size != 0)
	      cfi_add_CFA_def_cfa_offset (p->frame_size);
d4727 4
a4730 2
	    mask = p->mask;
	    offset = p->mask_offset;
d4732 3
a4734 13
	    /* Recall that $26 is special-cased and stored first.  */
	    if ((mask >> 26) & 1)
	      {
	        cfi_add_CFA_offset (26, offset);
		offset += 8;
		mask &= ~(1 << 26);
	      }
	    while (mask)
	      {
		unsigned int i;
		i = mask & -mask;
		mask ^= i;
		i = ffs (i) - 1;
d4736 4
a4739 17
		cfi_add_CFA_offset (i, offset);
		offset += 8;
	      }

	    mask = p->fmask;
	    offset = p->fmask_offset;
	    while (mask)
	      {
		unsigned int i;
		i = mask & -mask;
		mask ^= i;
		i = ffs (i) - 1;

		cfi_add_CFA_offset (i + 32, offset);
		offset += 8;
	      }
	  }
d4741 5
a4745 2
	cfi_end_fde (p->func_end_sym);
      }
d4749 1
a4749 1
s_alpha_usepv (int unused ATTRIBUTE_UNUSED)
d4751 1
a4751 4
  char *name, name_end;
  char *which, which_end;
  symbolS *sym;
  int other;
d4753 3
a4755 2
  name = input_line_pointer;
  name_end = get_symbol_end ();
d4757 2
a4758 7
  if (! is_name_beginner (*name))
    {
      as_bad (_(".usepv directive has no name"));
      *input_line_pointer = name_end;
      ignore_rest_of_line ();
      return;
    }
d4760 2
a4761 2
  sym = symbol_find_or_make (name);
  *input_line_pointer++ = name_end;
d4763 1
a4763 6
  if (name_end != ',')
    {
      as_bad (_(".usepv directive has no type"));
      ignore_rest_of_line ();
      return;
    }
d4765 1
a4765 3
  SKIP_WHITESPACE ();
  which = input_line_pointer;
  which_end = get_symbol_end ();
d4767 3
a4769 14
  if (strcmp (which, "no") == 0)
    other = STO_ALPHA_NOPV;
  else if (strcmp (which, "std") == 0)
    other = STO_ALPHA_STD_GPLOAD;
  else
    {
      as_bad (_("unknown argument for .usepv"));
      other = 0;
    }
  
  *input_line_pointer = which_end;
  demand_empty_rest_of_line ();

  S_SET_OTHER (sym, other | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
d4771 1
a4771 1
#endif /* OBJ_ELF */
d4773 2
a4774 1
/* Standard calling conventions leaves the CFA at $30 on entry.  */
d4776 2
a4777 2
void
alpha_cfi_frame_initial_instructions ()
d4779 5
a4783 1
  cfi_add_CFA_def_cfa_register (30);
d4786 1
a4786 1
#ifdef OBJ_EVAX
d4788 2
a4789 5
/* Handle the section specific pseudo-op.  */

static void
s_alpha_section (secid)
     int secid;
d4791 3
a4793 17
  int temp;
#define EVAX_SECTION_COUNT 5
  static char *section_name[EVAX_SECTION_COUNT + 1] =
    { "NULL", ".rdata", ".comm", ".link", ".ctors", ".dtors" };

  if ((secid <= 0) || (secid > EVAX_SECTION_COUNT))
    {
      as_fatal (_("Unknown section directive"));
      demand_empty_rest_of_line ();
      return;
    }
  temp = get_absolute_expression ();
  subseg_new (section_name[secid], 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
d4795 1
d4797 2
a4798 1
/* Parse .ent directives.  */
d4800 2
a4801 3
static void
s_alpha_ent (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4803 12
a4814 2
  symbolS *symbol;
  expressionS symexpr;
d4816 3
a4818 10
  alpha_evax_proc.pdsckind = 0;
  alpha_evax_proc.framereg = -1;
  alpha_evax_proc.framesize = 0;
  alpha_evax_proc.rsa_offset = 0;
  alpha_evax_proc.ra_save = AXP_REG_RA;
  alpha_evax_proc.fp_save = -1;
  alpha_evax_proc.imask = 0;
  alpha_evax_proc.fmask = 0;
  alpha_evax_proc.prologue = 0;
  alpha_evax_proc.type = 0;
d4820 7
a4826 1
  expression (&symexpr);
d4828 1
a4828 1
  if (symexpr.X_op != O_symbol)
d4830 4
a4833 3
      as_fatal (_(".ent directive has no symbol"));
      demand_empty_rest_of_line ();
      return;
d4836 1
a4836 3
  symbol = make_expr_symbol (&symexpr);
  symbol_get_bfdsym (symbol)->flags |= BSF_FUNCTION;
  alpha_evax_proc.symbol = symbol;
d4838 2
a4839 1
  demand_empty_rest_of_line ();
d4841 2
d4844 3
a4846 1
/* Parse .frame <framreg>,<framesize>,RA,<rsa_offset> directives.  */
d4848 2
a4849 3
static void
s_alpha_frame (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4851 1
a4851 1
  long val;
d4853 3
a4855 1
  alpha_evax_proc.framereg = tc_get_register (1);
d4857 3
a4859 9
  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ','
      || get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .frame directive 1./2. param"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
d4861 2
a4862 1
  alpha_evax_proc.framesize = val;
d4864 1
a4864 3
  (void) tc_get_register (1);
  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ',')
d4866 1
a4866 7
      as_warn (_("Bad .frame directive 3./4. param"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  alpha_evax_proc.rsa_offset = get_absolute_expression ();
}
d4868 5
a4872 12
static void
s_alpha_pdesc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char name_end;
  long val;
  register char *p;
  expressionS exp;
  symbolS *entry_sym;
  fixS *fixp;
  segment_info_type *seginfo = seg_info (alpha_link_section);
d4874 4
a4877 6
  if (now_seg != alpha_link_section)
    {
      as_bad (_(".pdesc directive not in link (.link) section"));
      demand_empty_rest_of_line ();
      return;
    }
d4879 3
a4881 7
  if ((alpha_evax_proc.symbol == 0)
      || (!S_IS_DEFINED (alpha_evax_proc.symbol)))
    {
      as_fatal (_(".pdesc has no matching .ent"));
      demand_empty_rest_of_line ();
      return;
    }
d4883 2
a4884 2
  *symbol_get_obj (alpha_evax_proc.symbol) =
    (valueT) seginfo->literal_pool_size;
d4886 4
a4889 7
  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_warn (_(".pdesc directive has no entry symbol"));
      demand_empty_rest_of_line ();
      return;
    }
d4891 4
a4894 11
  entry_sym = make_expr_symbol (&exp);
  /* Save bfd symbol of proc desc in function symbol.  */
  symbol_get_bfdsym (alpha_evax_proc.symbol)->udata.p
    = symbol_get_bfdsym (entry_sym);

  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ',')
    {
      as_warn (_("No comma after .pdesc <entryname>"));
      demand_empty_rest_of_line ();
      return;
d4897 2
a4898 3
  SKIP_WHITESPACE ();
  name = input_line_pointer;
  name_end = get_symbol_end ();
d4900 1
a4900 1
  if (strncmp (name, "stack", 5) == 0)
d4902 1
a4902 16
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_FP_STACK;
    }
  else if (strncmp (name, "reg", 3) == 0)
    {
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_FP_REGISTER;
    }
  else if (strncmp (name, "null", 4) == 0)
    {
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_NULL;
    }
  else
    {
      as_fatal (_("unknown procedure kind"));
      demand_empty_rest_of_line ();
      return;
    }
d4904 5
a4908 2
  *input_line_pointer = name_end;
  demand_empty_rest_of_line ();
d4910 5
a4914 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
d4916 4
a4919 5
  frag_align (3, 0, 0);
  p = frag_more (16);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 16;
d4921 4
a4924 3
  *p = alpha_evax_proc.pdsckind
    | ((alpha_evax_proc.framereg == 29) ? PDSC_S_M_BASE_REG_IS_FP : 0);
  *(p + 1) = PDSC_S_M_NATIVE | PDSC_S_M_NO_JACKET;
d4926 1
a4926 1
  switch (alpha_evax_proc.pdsckind)
d4928 5
a4932 13
    case PDSC_S_K_KIND_NULL:
      *(p + 2) = 0;
      *(p + 3) = 0;
      break;
    case PDSC_S_K_KIND_FP_REGISTER:
      *(p + 2) = alpha_evax_proc.fp_save;
      *(p + 3) = alpha_evax_proc.ra_save;
      break;
    case PDSC_S_K_KIND_FP_STACK:
      md_number_to_chars (p + 2, (valueT) alpha_evax_proc.rsa_offset, 2);
      break;
    default:		/* impossible */
      break;
d4935 1
a4935 2
  *(p + 4) = 0;
  *(p + 5) = alpha_evax_proc.type & 0x0f;
d4937 2
a4938 2
  /* Signature offset.  */
  md_number_to_chars (p + 6, (valueT) 0, 2);
d4940 2
a4941 1
  fix_new_exp (frag_now, p - frag_now->fr_literal+8, 8, &exp, 0, BFD_RELOC_64);
d4943 5
a4947 2
  if (alpha_evax_proc.pdsckind == PDSC_S_K_KIND_NULL)
    return;
d4949 3
a4951 5
  /* Add dummy fix to make add_to_link_pool work.  */
  p = frag_more (8);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 8;
d4953 8
a4960 2
  /* pdesc+16: Size.  */
  md_number_to_chars (p, (valueT) alpha_evax_proc.framesize, 4);
d4962 2
a4963 1
  md_number_to_chars (p + 4, (valueT) 0, 2);
d4965 1
a4965 16
  /* Entry length.  */
  md_number_to_chars (p + 6, alpha_evax_proc.prologue, 2);

  if (alpha_evax_proc.pdsckind == PDSC_S_K_KIND_FP_REGISTER)
    return;

  /* Add dummy fix to make add_to_link_pool work.  */
  p = frag_more (8);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 8;

  /* pdesc+24: register masks.  */

  md_number_to_chars (p, alpha_evax_proc.imask, 4);
  md_number_to_chars (p + 4, alpha_evax_proc.fmask, 4);
d4968 1
a4968 1
/* Support for crash debug on vms.  */
d4970 2
a4971 3
static void
s_alpha_name (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4973 13
a4985 3
  register char *p;
  expressionS exp;
  segment_info_type *seginfo = seg_info (alpha_link_section);
d4987 2
a4988 1
  if (now_seg != alpha_link_section)
d4990 2
a4991 4
      as_bad (_(".name directive not in link (.link) section"));
      demand_empty_rest_of_line ();
      return;
    }
a4992 5
  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_warn (_(".name directive has no symbol"));
      demand_empty_rest_of_line ();
d4996 3
a4998 1
  demand_empty_rest_of_line ();
d5000 1
a5000 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
d5002 5
a5006 3
  frag_align (3, 0, 0);
  p = frag_more (8);
  seginfo->literal_pool_size += 8;
d5008 1
a5008 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &exp, 0, BFD_RELOC_64);
d5011 4
a5014 6
static void
s_alpha_linkage (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  expressionS exp;
  char *p;
d5016 2
a5017 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
d5019 1
a5019 14
  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_fatal (_("No symbol after .linkage"));
    }
  else
    {
      p = frag_more (LKP_S_K_SIZE);
      memset (p, 0, LKP_S_K_SIZE);
      fix_new_exp (frag_now, p - frag_now->fr_literal, LKP_S_K_SIZE, &exp, 0,\
		   BFD_RELOC_ALPHA_LINKAGE);
    }
  demand_empty_rest_of_line ();
}
d5021 2
a5022 3
static void
s_alpha_code_address (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5024 4
a5027 2
  expressionS exp;
  char *p;
d5029 1
a5029 6
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  expression (&exp);
  if (exp.X_op != O_symbol)
d5031 7
a5037 11
      as_fatal (_("No symbol after .code_address"));
    }
  else
    {
      p = frag_more (8);
      memset (p, 0, 8);
      fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &exp, 0,\
		   BFD_RELOC_ALPHA_CODEADDR);
    }
  demand_empty_rest_of_line ();
}
d5039 4
a5042 4
static void
s_alpha_fp_save (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
d5044 3
a5046 1
  alpha_evax_proc.fp_save = tc_get_register (1);
d5048 4
a5051 2
  demand_empty_rest_of_line ();
}
d5053 4
a5056 5
static void
s_alpha_mask (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  long val;
d5058 3
a5060 4
  if (get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .mask directive"));
      --input_line_pointer;
d5062 6
a5067 1
  else
d5069 2
a5070 2
      alpha_evax_proc.imask = val;
      (void) get_absolute_expression ();
d5072 2
a5073 1
  demand_empty_rest_of_line ();
d5076 4
a5079 3
static void
s_alpha_fmask (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5081 1
a5081 3
  long val;

  if (get_absolute_expression_and_terminator (&val) != ',')
d5083 3
a5085 10
      as_warn (_("Bad .fmask directive"));
      --input_line_pointer;
    }
  else
    {
      alpha_evax_proc.fmask = val;
      (void) get_absolute_expression ();
    }
  demand_empty_rest_of_line ();
}
d5087 3
a5089 5
static void
s_alpha_end (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char c;
d5091 3
a5093 5
  c = get_symbol_end ();
  *input_line_pointer = c;
  demand_empty_rest_of_line ();
  alpha_evax_proc.symbol = 0;
}
d5095 3
a5097 7
static void
s_alpha_file (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *s;
  int length;
  static char case_hack[32];
d5099 3
a5101 2
  sprintf (case_hack, "<CASE:%01d%01d>",
	   alpha_flag_hash_long_names, alpha_flag_show_after_trunc);
d5103 10
a5112 2
  s = symbol_find_or_make (case_hack);
  symbol_get_bfdsym (s)->flags |= BSF_FILE;
d5114 4
a5117 6
  get_absolute_expression ();
  s = symbol_find_or_make (demand_copy_string (&length));
  symbol_get_bfdsym (s)->flags |= BSF_FILE;
  demand_empty_rest_of_line ();
}
#endif /* OBJ_EVAX  */
d5119 3
a5121 1
/* Handle the .gprel32 pseudo op.  */
d5123 3
a5125 6
static void
s_alpha_gprel32 (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  expressionS e;
  char *p;
d5127 3
a5129 2
  SKIP_WHITESPACE ();
  expression (&e);
d5132 2
a5133 7
  switch (e.X_op)
    {
    case O_constant:
      e.X_add_symbol = section_symbol (absolute_section);
      e.X_op = O_symbol;
      /* FALLTHRU */
    case O_symbol:
d5135 2
a5136 13
    default:
      abort ();
    }
#else
#ifdef OBJ_ECOFF
  switch (e.X_op)
    {
    case O_constant:
      e.X_add_symbol = section_symbol (absolute_section);
      /* fall through */
    case O_symbol:
      e.X_op = O_subtract;
      e.X_op_symbol = alpha_gp_symbol;
d5138 2
d5141 1
a5141 1
      abort ();
d5143 24
d5168 4
a5171 1
#endif
d5173 4
a5176 5
  if (alpha_auto_align_on && alpha_current_align < 2)
    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > 2)
    alpha_current_align = 2;
  alpha_insn_label = NULL;
d5178 9
a5186 4
  p = frag_more (4);
  memset (p, 0, 4);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
	       &e, 0, BFD_RELOC_GPREL32);
d5189 9
a5197 3
/* Handle floating point allocation pseudo-ops.  This is like the
   generic vresion, but it makes sure the current label, if any, is
   correctly aligned.  */
d5199 2
a5200 3
static void
s_alpha_float_cons (type)
     int type;
d5202 3
a5204 1
  int log_size;
d5206 1
a5206 1
  switch (type)
d5208 21
a5228 5
    default:
    case 'f':
    case 'F':
      log_size = 2;
      break;
d5230 6
a5235 5
    case 'd':
    case 'D':
    case 'G':
      log_size = 3;
      break;
d5237 3
a5239 5
    case 'x':
    case 'X':
    case 'p':
    case 'P':
      log_size = 4;
a5240 7
    }

  if (alpha_auto_align_on && alpha_current_align < log_size)
    alpha_align (log_size, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > log_size)
    alpha_current_align = log_size;
  alpha_insn_label = NULL;
d5242 5
a5246 2
  float_cons (type);
}
d5248 5
a5252 2
/* Handle the .proc pseudo op.  We don't really do much with it except
   parse it.  */
d5254 4
a5257 9
static void
s_alpha_proc (is_static)
     int is_static ATTRIBUTE_UNUSED;
{
  char *name;
  char c;
  char *p;
  symbolS *symbolP;
  int temp;
d5259 7
a5265 25
  /* Takes ".proc name,nargs"  */
  SKIP_WHITESPACE ();
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  symbolP = symbol_find_or_make (name);
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      *p = 0;
      as_warn (_("Expected comma after name \"%s\""), name);
      *p = c;
      temp = 0;
      ignore_rest_of_line ();
    }
  else
    {
      input_line_pointer++;
      temp = get_absolute_expression ();
    }
  /*  *symbol_get_obj (symbolP) = (signed char) temp; */
  as_warn (_("unhandled: .proc %s,%d"), name, temp);
  demand_empty_rest_of_line ();
}
d5267 14
a5280 2
/* Handle the .set pseudo op.  This is used to turn on and off most of
   the assembler features.  */
d5282 8
a5289 6
static void
s_alpha_set (x)
     int x ATTRIBUTE_UNUSED;
{
  char *name, ch, *s;
  int yesno = 1;
d5291 8
a5298 3
  SKIP_WHITESPACE ();
  name = input_line_pointer;
  ch = get_symbol_end ();
d5300 3
a5302 18
  s = name;
  if (s[0] == 'n' && s[1] == 'o')
    {
      yesno = 0;
      s += 2;
    }
  if (!strcmp ("reorder", s))
    /* ignore */ ;
  else if (!strcmp ("at", s))
    alpha_noat_on = !yesno;
  else if (!strcmp ("macro", s))
    alpha_macros_on = yesno;
  else if (!strcmp ("move", s))
    /* ignore */ ;
  else if (!strcmp ("volatile", s))
    /* ignore */ ;
  else
    as_warn (_("Tried to .set unrecognized mode `%s'"), name);
d5304 14
a5317 3
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}
d5319 10
a5328 2
/* Handle the .base pseudo op.  This changes the assembler's notion of
   the $gp register.  */
d5330 3
a5332 11
static void
s_alpha_base (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {				/* $rNN form */
      input_line_pointer++;
      if (*input_line_pointer == 'r')
	input_line_pointer++;
    }
d5334 3
a5336 6
  alpha_gp_register = get_absolute_expression ();
  if (alpha_gp_register < 0 || alpha_gp_register > 31)
    {
      alpha_gp_register = AXP_REG_GP;
      as_warn (_("Bad base register, using $%d."), alpha_gp_register);
    }
d5338 3
a5340 2
  demand_empty_rest_of_line ();
}
d5342 2
a5343 3
/* Handle the .align pseudo-op.  This aligns to a power of two.  It
   also adjusts any current instruction label.  We treat this the same
   way the MIPS port does: .align 0 turns off auto alignment.  */
d5345 3
a5347 7
static void
s_alpha_align (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int align;
  char fill, *pfill;
  long max_alignment = 15;
d5349 4
a5352 11
  align = get_absolute_expression ();
  if (align > max_alignment)
    {
      align = max_alignment;
      as_bad (_("Alignment too large: %d. assumed"), align);
    }
  else if (align < 0)
    {
      as_warn (_("Alignment negative: 0 assumed"));
      align = 0;
    }
d5354 5
a5358 5
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      fill = get_absolute_expression ();
      pfill = &fill;
a5359 2
  else
    pfill = NULL;
d5361 2
a5362 5
  if (align != 0)
    {
      alpha_auto_align_on = 1;
      alpha_align (align, pfill, alpha_insn_label, 1);
    }
d5365 3
a5367 1
      alpha_auto_align_on = 0;
d5370 2
a5371 2
  demand_empty_rest_of_line ();
}
d5373 2
a5374 39
/* Hook the normal string processor to reset known alignment.  */

static void
s_alpha_stringer (terminate)
     int terminate;
{
  alpha_current_align = 0;
  alpha_insn_label = NULL;
  stringer (terminate);
}

/* Hook the normal space processing to reset known alignment.  */

static void
s_alpha_space (ignore)
     int ignore;
{
  alpha_current_align = 0;
  alpha_insn_label = NULL;
  s_space (ignore);
}

/* Hook into cons for auto-alignment.  */

void
alpha_cons_align (size)
     int size;
{
  int log_size;

  log_size = 0;
  while ((size >>= 1) != 0)
    ++log_size;

  if (alpha_auto_align_on && alpha_current_align < log_size)
    alpha_align (log_size, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > log_size)
    alpha_current_align = log_size;
  alpha_insn_label = NULL;
d5377 1
a5377 2
/* Here come the .uword, .ulong, and .uquad explicitly unaligned
   pseudos.  We just turn off auto-alignment and call down to cons.  */
d5379 2
a5380 3
static void
s_alpha_ucons (bytes)
     int bytes;
d5382 11
a5392 5
  int hold = alpha_auto_align_on;
  alpha_auto_align_on = 0;
  cons (bytes);
  alpha_auto_align_on = hold;
}
d5394 4
a5397 1
/* Switch the working cpu type.  */
d5399 12
a5410 6
static void
s_alpha_arch (ignored)
     int ignored ATTRIBUTE_UNUSED;
{
  char *name, ch;
  const struct cpu_type *p;
d5412 3
a5414 3
  SKIP_WHITESPACE ();
  name = input_line_pointer;
  ch = get_symbol_end ();
d5416 8
a5423 7
  for (p = cpu_types; p->name; ++p)
    if (strcmp (name, p->name) == 0)
      {
	alpha_target_name = p->name, alpha_target = p->flags;
	goto found;
      }
  as_warn ("Unknown CPU identifier `%s'", name);
d5425 4
a5428 7
found:
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

#ifdef DEBUG1
/* print token expression with alpha specific extension.  */
d5430 5
a5434 22
static void
alpha_print_token (f, exp)
     FILE *f;
     const expressionS *exp;
{
  switch (exp->X_op)
    {
    case O_cpregister:
      putc (',', f);
      /* FALLTHRU */
    case O_pregister:
      putc ('(', f);
      {
	expressionS nexp = *exp;
	nexp.X_op = O_register;
	print_expr (f, &nexp);
      }
      putc (')', f);
      break;
    default:
      print_expr (f, exp);
      break;
d5436 1
a5437 3
#endif

/* The target specific pseudo-ops which we support.  */
a5438 1
const pseudo_typeS md_pseudo_table[] = {
d5440 1
a5440 63
  {"comm", s_alpha_comm, 0},	/* osf1 compiler does this */
  {"rdata", s_alpha_rdata, 0},
#endif
  {"text", s_alpha_text, 0},
  {"data", s_alpha_data, 0},
#ifdef OBJ_ECOFF
  {"sdata", s_alpha_sdata, 0},
#endif
#ifdef OBJ_ELF
  {"section", s_alpha_section, 0},
  {"section.s", s_alpha_section, 0},
  {"sect", s_alpha_section, 0},
  {"sect.s", s_alpha_section, 0},
#endif
#ifdef OBJ_EVAX
  { "pdesc", s_alpha_pdesc, 0},
  { "name", s_alpha_name, 0},
  { "linkage", s_alpha_linkage, 0},
  { "code_address", s_alpha_code_address, 0},
  { "ent", s_alpha_ent, 0},
  { "frame", s_alpha_frame, 0},
  { "fp_save", s_alpha_fp_save, 0},
  { "mask", s_alpha_mask, 0},
  { "fmask", s_alpha_fmask, 0},
  { "end", s_alpha_end, 0},
  { "file", s_alpha_file, 0},
  { "rdata", s_alpha_section, 1},
  { "comm", s_alpha_comm, 0},
  { "link", s_alpha_section, 3},
  { "ctors", s_alpha_section, 4},
  { "dtors", s_alpha_section, 5},
#endif
#ifdef OBJ_ELF
  /* Frame related pseudos.  */
  {"ent", s_alpha_ent, 0},
  {"end", s_alpha_end, 0},
  {"mask", s_alpha_mask, 0},
  {"fmask", s_alpha_mask, 1},
  {"frame", s_alpha_frame, 0},
  {"prologue", s_alpha_prologue, 0},
  {"file", s_alpha_file, 5},
  {"loc", s_alpha_loc, 9},
  {"stabs", s_alpha_stab, 's'},
  {"stabn", s_alpha_stab, 'n'},
  {"usepv", s_alpha_usepv, 0},
  /* COFF debugging related pseudos.  */
  {"begin", s_alpha_coff_wrapper, 0},
  {"bend", s_alpha_coff_wrapper, 1},
  {"def", s_alpha_coff_wrapper, 2},
  {"dim", s_alpha_coff_wrapper, 3},
  {"endef", s_alpha_coff_wrapper, 4},
  {"scl", s_alpha_coff_wrapper, 5},
  {"tag", s_alpha_coff_wrapper, 6},
  {"val", s_alpha_coff_wrapper, 7},
#else
  {"prologue", s_ignore, 0},
#endif
  {"gprel32", s_alpha_gprel32, 0},
  {"t_floating", s_alpha_float_cons, 'd'},
  {"s_floating", s_alpha_float_cons, 'f'},
  {"f_floating", s_alpha_float_cons, 'F'},
  {"g_floating", s_alpha_float_cons, 'G'},
  {"d_floating", s_alpha_float_cons, 'D'},
d5442 8
a5449 32
  {"proc", s_alpha_proc, 0},
  {"aproc", s_alpha_proc, 1},
  {"set", s_alpha_set, 0},
  {"reguse", s_ignore, 0},
  {"livereg", s_ignore, 0},
  {"base", s_alpha_base, 0},		/*??*/
  {"option", s_ignore, 0},
  {"aent", s_ignore, 0},
  {"ugen", s_ignore, 0},
  {"eflag", s_ignore, 0},

  {"align", s_alpha_align, 0},
  {"double", s_alpha_float_cons, 'd'},
  {"float", s_alpha_float_cons, 'f'},
  {"single", s_alpha_float_cons, 'f'},
  {"ascii", s_alpha_stringer, 0},
  {"asciz", s_alpha_stringer, 1},
  {"string", s_alpha_stringer, 1},
  {"space", s_alpha_space, 0},
  {"skip", s_alpha_space, 0},
  {"zero", s_alpha_space, 0},

/* Unaligned data pseudos.  */
  {"uword", s_alpha_ucons, 2},
  {"ulong", s_alpha_ucons, 4},
  {"uquad", s_alpha_ucons, 8},

#ifdef OBJ_ELF
/* Dwarf wants these versions of unaligned.  */
  {"2byte", s_alpha_ucons, 2},
  {"4byte", s_alpha_ucons, 4},
  {"8byte", s_alpha_ucons, 8},
d5452 3
a5454 3
/* We don't do any optimizing, so we can safely ignore these.  */
  {"noalias", s_ignore, 0},
  {"alias", s_ignore, 0},
d5456 5
a5460 1
  {"arch", s_alpha_arch, 0},
d5462 2
a5463 5
  {NULL, 0, 0},
};

/* Build a BFD section with its flags set appropriately for the .lita,
   .lit8, or .lit4 sections.  */
d5465 2
a5466 5
static void
create_literal_section (name, secp, symp)
     const char *name;
     segT *secp;
     symbolS **symp;
d5468 29
a5496 3
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_sec;
d5498 3
a5500 6
  *secp = new_sec = subseg_new (name, 0);
  subseg_set (current_section, current_subsec);
  bfd_set_section_alignment (stdoutput, new_sec, 4);
  bfd_set_section_flags (stdoutput, new_sec,
			 SEC_RELOC | SEC_ALLOC | SEC_LOAD | SEC_READONLY
			 | SEC_DATA);
d5502 1
a5502 1
  S_CLEAR_EXTERNAL (*symp = section_symbol (new_sec));
d5505 1
a5505 1
#ifdef OBJ_ECOFF
d5507 2
a5508 7
/* @@@@@@ GP selection voodoo.  All of this seems overly complicated and
   unnecessary; which is the primary reason it's for ECOFF only.  */
static inline void maybe_set_gp PARAMS ((asection *));

static inline void
maybe_set_gp (sec)
     asection *sec;
d5510 8
a5517 7
  bfd_vma vma;
  if (!sec)
    return;
  vma = bfd_get_section_vma (foo, sec);
  if (vma && vma < alpha_gp_value)
    alpha_gp_value = vma;
}
d5519 6
a5524 4
static void
select_gp_value ()
{
  assert (alpha_gp_value == 0);
d5526 3
a5528 3
  /* Get minus-one in whatever width...  */
  alpha_gp_value = 0;
  alpha_gp_value--;
d5530 9
a5538 2
  /* Select the smallest VMA of these existing sections.  */
  maybe_set_gp (alpha_lita_section);
d5540 13
a5552 2
/* @@@@ Will a simple 0x8000 work here?  If not, why not?  */
#define GP_ADJUSTMENT	(0x8000 - 0x10)
d5554 8
a5561 1
  alpha_gp_value += GP_ADJUSTMENT;
d5563 2
a5564 1
  S_SET_VALUE (alpha_gp_symbol, alpha_gp_value);
d5566 21
a5586 2
#ifdef DEBUG1
  printf (_("Chose GP value of %lx\n"), alpha_gp_value);
a5587 2
}
#endif /* OBJ_ECOFF */
d5589 3
a5591 13
#ifdef OBJ_ELF
/* Map 's' to SHF_ALPHA_GPREL.  */

int
alpha_elf_section_letter (letter, ptr_msg)
     int letter;
     char **ptr_msg;
{
  if (letter == 's')
    return SHF_ALPHA_GPREL;

  *ptr_msg = _("Bad .section directive: want a,s,w,x,M,S,G,T in string");
  return -1;
d5594 2
a5595 1
/* Map SHF_ALPHA_GPREL to SEC_SMALL_DATA.  */
d5597 3
a5599 4
flagword
alpha_elf_section_flags (flags, attr, type)
     flagword flags;
     int attr, type ATTRIBUTE_UNUSED;
d5601 1
a5601 5
  if (attr & SHF_ALPHA_GPREL)
    flags |= SEC_SMALL_DATA;
  return flags;
}
#endif /* OBJ_ELF */
d5603 4
a5606 4
/* Called internally to handle all alignment needs.  This takes care
   of eliding calls to frag_align if'n the cached current alignment
   says we've already got it, as well as taking care of the auto-align
   feature wrt labels.  */
d5608 3
a5610 9
static void
alpha_align (n, pfill, label, force)
     int n;
     char *pfill;
     symbolS *label;
     int force ATTRIBUTE_UNUSED;
{
  if (alpha_current_align >= n)
    return;
d5612 2
a5613 1
  if (pfill == NULL)
d5615 4
a5618 4
      if (subseg_text_p (now_seg))
	frag_align_code (n, 0);
      else
	frag_align (n, 0, 0);
a5619 2
  else
    frag_align (n, *pfill, 0);
d5621 5
a5625 1
  alpha_current_align = n;
d5627 6
a5632 1
  if (label != NULL && S_GET_SEGMENT (label) == now_seg)
d5634 12
a5645 2
      symbol_set_frag (label, frag_now);
      S_SET_VALUE (label, (valueT) frag_now_fix ());
d5648 2
a5649 1
  record_alignment (now_seg, n);
d5651 3
a5653 3
  /* ??? If alpha_flag_relax && force && elf, record the requested alignment
     in a reloc for the linker to see.  */
}
d5655 1
a5655 2
/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */
d5657 2
a5658 3
void
alpha_handle_align (fragp)
     fragS *fragp;
d5660 1
a5660 5
  static char const unop[4] = { 0x00, 0x00, 0xfe, 0x2f };
  static char const nopunop[8] = {
    0x1f, 0x04, 0xff, 0x47,
    0x00, 0x00, 0xfe, 0x2f
  };
d5662 6
a5667 2
  int bytes, fix;
  char *p;
d5669 5
a5673 2
  if (fragp->fr_type != rs_align_code)
    return;
d5675 4
a5678 3
  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;
  fix = 0;
d5680 6
a5685 7
  if (bytes & 3)
    {
      fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }
d5687 1
a5687 7
  if (bytes & 4)
    {
      memcpy (p, unop, 4);
      p += 4;
      bytes -= 4;
      fix += 4;
    }
d5689 7
a5695 1
  memcpy (p, nopunop, 8);
d5697 1
a5697 3
  fragp->fr_fix += fix;
  fragp->fr_var = 8;
}
@


1.63
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
@


1.62
log
@Remove duplicate code and provide a function for generating internally consistent 'value out of range' messages
@
text
@a310 3
#if 0
const char FLT_CHARS[] = "dD";
#else
a312 1
#endif
a655 12
#if 0
  { "ldif"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldid"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldig"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldis"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldit"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
#endif
a687 8
#if 0
  { "absl"	emit_absl, 1, { IR } },
  { "absl"	emit_absl, 2, { IR, IR } },
  { "absl"	emit_absl, 2, { EXP, IR } },
  { "absq"	emit_absq, 1, { IR } },
  { "absq"	emit_absq, 2, { IR, IR } },
  { "absq"	emit_absq, 2, { EXP, IR } },
#endif
a5444 9
#if 0
  if (first_32bit_quadrant)
    {
      /* not fatal, but it might not work in the end */
      as_warn (_("File overrides no-base-register option."));
      first_32bit_quadrant = 0;
    }
#endif

a5780 6
#if 0
  /* These were disabled before -- should we use them?  */
  maybe_set_gp (sdata);
  maybe_set_gp (lit8_sec);
  maybe_set_gp (lit4_sec);
#endif
@


1.61
log
@Remove redundant returns in void functions.
@
text
@d2376 1
a2376 11
	{
	  const char *err =
	    _("operand out of range (%s not between %d and %d)");
	  char buf[sizeof (val) * 3 + 2];

	  sprint_value (buf, val);
	  if (file)
	    as_warn_where (file, line, err, buf, min, max);
	  else
	    as_warn (err, buf, min, max);
	}
@


1.60
log
@2003-11-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-alpha.c (s_alpha_end): Don't crash if there is no
	matching .ent.
@
text
@a4945 1
  return;
a4979 2

  return;
a5128 2

  return;
a5166 2

  return;
a5192 2

  return;
a5218 2

  return;
a5228 1
  return;
a5247 2

  return;
a5266 2

  return;
a5278 2

  return;
a5298 2

  return;
a5657 1
  return;
@


1.59
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-alpha.c: Likewise.
	* config/tc-alpha.h: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-dlx.h: Likewise.
@
text
@d4497 1
a4497 1
	  if (sym)
@


1.58
log
@        * config/tc-alpha.c (s_alpha_usepv): New.
        (md_pseudo_table): Add it.
        (alpha_cfi_frame_initial_instructions): New.
        * config/tc-alpha.h (TARGET_USE_CFIPOP): New.
        (tc_cfi_frame_initial_instructions): New.
        * doc/c-alpha.texi: Document .usepv.

        * gas/alpha/elf-usepv-1.[sd]: New.
        * gas/alpha/elf-usepv-2.[sd]: New.
        * gas/alpha/alpha.exp: Run them.
        * gas/cfi/cfi-alpha-3.[sd]: New.
        * gas/cfi/cfi.exp: Run it.
@
text
@d536 1
a536 1
/* Structure to hold explict sequence information.  */
d1730 1
a1730 1
  /* First rebuild the fixup chain without the expicit lituse and
d3017 1
a3017 1
   and used, then explict_reloc with be an expression pointer.
d3368 1
a3368 1
   most simple expressions, particualrly symbol address loads and
@


1.57
log
@        * config/tc-alpha.c (alpha_cur_ent_sym): Remove.
        (all_frame_data, plast_frame_data, cur_frame_data): New.
        (s_alpha_ent): Record data for dwarf2 cfi.
        (s_alpha_end, s_alpha_mask, s_alpha_frame, s_alpha_prologue): Likewise.[
        (alpha_elf_md_end): Emit dwarf2 cfi for ecoff unwind directives.
        * config/tc-alpha.h (md_end): New.
        (DWARF2_DEFAULT_RETURN_COLUMN): New.
        (DWARF2_CIE_DATA_ALIGNMENT): New.

        * gas/alpha/elf-reloc-8.d: Add .eh_frame relocs.
        * gas/cfi/cfi-alpha-1.d: New.
        * gas/cfi/cfi-alpha-1.s: New.
        * gas/cfi/cfi.exp: Run it.
@
text
@d270 1
d4826 49
d4877 8
d5730 1
@


1.56
log
@gas/

2003-05-03  H.J. Lu <hjl@@gnu.org>

	* config/obj-elf.c (obj_elf_parse_section_letters): Make it a
	fatal error for unknown section attribute.

	* config/tc-alpha.c (alpha_elf_section_letter): Return -1 for
	unknown section attribute.
	* config/tc-ia64.c (ia64_elf_section_letter): Likewise.
	* config/tc-ppc.c (ppc_section_letter): Likewise.

	* config/tc-ia64.c (ia64_elf_section_letter): Handle 'o'.
	(ia64_elf_section_type): Accept "unwind".

gas/testsuite/

2003-05-03  H.J. Lu <hjl@@gnu.org>

	* gas/ia64/ia64.exp: Add unwind.

	* gas/ia64/unwind.s: New. Test the new section attribute 'o'
	and the new section type "unwind".
	* gas/ia64/unwind.d: Likewise.
@
text
@d63 1
a410 5
#ifdef OBJ_ELF
/* The active .ent symbol.  */
static symbolS *alpha_cur_ent_sym;
#endif

d4381 19
d4436 1
a4436 1
	  if (alpha_cur_ent_sym)
d4441 10
a4450 1
	  alpha_cur_ent_sym = sym;
d4490 3
a4492 1
	  if (sym != alpha_cur_ent_sym)
d4498 10
a4507 7
	      symbol_get_obj (sym)->size =
		(expressionS *) xmalloc (sizeof (expressionS));
	      symbol_get_obj (sym)->size->X_op = O_subtract;
	      symbol_get_obj (sym)->size->X_add_symbol
		= symbol_new ("L0\001", now_seg, frag_now_fix (), frag_now);
	      symbol_get_obj (sym)->size->X_op_symbol = sym;
	      symbol_get_obj (sym)->size->X_add_number = 0;
d4510 1
a4510 1
	  alpha_cur_ent_sym = NULL;
d4530 39
a4568 1
    discard_rest_of_line ();
d4578 30
a4607 1
    discard_rest_of_line ();
d4623 1
a4623 1
    sym = alpha_cur_ent_sym;
d4648 3
d4743 81
@


1.55
log
@2003-05-02  H.J. Lu <hjl@@gnu.org>

	* read.h (demand_copy_string): New.

	* config/tc-alpha.c (demand_copy_string): Removed.
@
text
@d5638 1
a5638 1
  return 0;
@


1.54
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@a5068 2
  extern char *demand_copy_string PARAMS ((int *lenP));

@


1.53
log
@Add support for msp430.
@
text
@d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
a1450 2
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
d1467 1
a1467 1
  return S_FORCE_RELOC (f->fx_addsy);
d1529 1
a1529 1
	if (S_FORCE_RELOC (sym))
@


1.52
log
@	* symbols.c (S_SET_THREAD_LOCAL): New function.
	* symbols.h (S_SET_THREAD_LOCAL): New prototype.
	* config/tc-i386.c (md_apply_fix3): Call S_SET_THREAD_LOCAL
	for TLS relocations.
	* config/tc-ia64.c (md_apply_fix3): Likewise.
	* config/tc-alpha.c (md_apply_fix3): Likewise.

	* ld-i386/tlsnopic.rd: Change NOTYPE to TLS for UND sg* symbols.
@
text
@d1522 1
d1555 1
@


1.51
log
@        * config/tc-alpha.c (alpha_fix_adjustable): Remove redundant
        S_IS_DEFINED test.
@
text
@d1264 2
d1276 2
@


1.50
log
@	* config/tc-alpha.c (s_alpha_prologue): as_bad when sym is NULL.
@
text
@d1526 1
a1526 1
	if (! S_IS_DEFINED (sym) || S_FORCE_RELOC (sym))
@


1.49
log
@        * config/tc-alpha.c (alpha_validate_fix): Move code ...
        (alpha_fix_adjustable): ... here.
        * config/tc-alpha.h (TC_VALIDATE_FIX): Remove.
@
text
@d4524 6
a4529 1
  know (sym != NULL);
@


1.48
log
@        * config/tc-alpha.c (md_pcrel_from): Only adjust special for
        branch type relocs.
        (alpha_force_relocation): Don't special-case branch type relocs.

        * gas/alpha/elf-reloc-7.s: New.
        * gas/alpha/elf-reloc-7.d: New.
        * gas/alpha/alpha.exp: Run it.
@
text
@a1421 43
/* If we have a BRSGP reloc to a local symbol, adjust it to BRADDR and
   let it get resolved at assembly time.  */

#ifdef OBJ_ELF
void
alpha_validate_fix (f)
     fixS *f;
{
  int offset = 0;
  const char *name;

  if (f->fx_r_type != BFD_RELOC_ALPHA_BRSGP)
    return;

  if (! S_IS_DEFINED (f->fx_addsy))
    return;

  switch (S_GET_OTHER (f->fx_addsy) & STO_ALPHA_STD_GPLOAD)
    {
    case STO_ALPHA_NOPV:
      break;
    case STO_ALPHA_STD_GPLOAD:
      offset = 8;
      break;
    default:
      if (S_IS_LOCAL (f->fx_addsy))
	name = "<local>";
      else
	name = S_GET_NAME (f->fx_addsy);
      as_bad_where (f->fx_file, f->fx_line,
		    _("!samegp reloc against symbol without .prologue: %s"),
		    name);
      break;
    }

  if (! (S_IS_EXTERN (f->fx_addsy) || S_IS_WEAK (f->fx_addsy)))
    {
      f->fx_r_type = BFD_RELOC_23_PCREL_S2;
      f->fx_offset += offset;
    }
}
#endif

a1480 1
    case BFD_RELOC_ALPHA_BRSGP:
d1517 33
@


1.47
log
@gas reloc rewrite.
@
text
@d1142 5
a1146 3
    case BFD_RELOC_ALPHA_GPDISP:
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
a1147 2
    default:
      return fixP->fx_size + addr;
a1502 4

    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_ALPHA_HINT:
      return 0;
@


1.46
log
@Fix compiling for COFF targets.
Some minor formatting tidyups.
@
text
@d211 1
a211 1
static void alpha_adjust_symtab_relocs PARAMS ((bfd *, asection *, PTR));
d1174 3
a1176 3
	 referring to the current function; we need to drop in a value
	 which, when added to the address of the start of the function,
	 gives the desired GP.  */
a1504 2
    case BFD_RELOC_32:
    case BFD_RELOC_64:
d1509 1
a1509 1
      return 0;
d1511 2
a1520 6
#ifdef OBJ_ELF
  /* Prevent all adjustments to global symbols */
  if (S_IS_EXTERN (f->fx_addsy) || S_IS_WEAK (f->fx_addsy))
    return 0;
#endif

d1716 1
a1716 1
alpha_adjust_symtab ()
d1719 1
a1719 1
    bfd_map_over_sections (stdoutput, alpha_adjust_symtab_relocs, NULL);
d1723 1
a1723 1
alpha_adjust_symtab_relocs (abfd, sec, ptr)
@


1.45
log
@        * config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
        and m21264b processor names and cpu types.
        * doc/c-alpha.texi: Documented new types.
@
text
@d67 1
a67 1
/* Local types */
d75 2
a76 1
struct alpha_fixup {
d81 2
a82 1
struct alpha_insn {
d89 10
a98 9
enum alpha_macro_arg {
  MACRO_EOA = 1,
  MACRO_IR,
  MACRO_PIR,
  MACRO_OPIR,
  MACRO_CPIR,
  MACRO_FPR,
  MACRO_EXP,
};
d100 2
a101 1
struct alpha_macro {
d146 1
a146 1
/* Macros for extracting the type and number of encoded register tokens */
d152 1
a152 1
/* Something odd inherited from the old assembler */
d186 1
a186 1
/* Macros to build tokens */
d208 1
a208 1
/* Prototypes for all local functions */
d322 2
a323 1
struct option md_longopts[] = {
d325 1
a325 1
  { "32addr", no_argument, NULL, OPTION_32ADDR },
d327 1
a327 1
  { "relax", no_argument, NULL, OPTION_RELAX },
d331 2
a332 2
  { "mdebug", no_argument, NULL, OPTION_MDEBUG },
  { "no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG },
d334 2
a335 2
  { NULL, no_argument, NULL, 0 }
};
d359 1
a359 1
/* The cpu for which we are generating code */
d363 1
a363 1
/* The hash table of instruction opcodes */
d366 1
a366 1
/* The hash table of macro opcodes */
d370 1
a370 1
/* The $gp relocation symbol */
d377 1
a377 1
/* The current $gp register */
d380 1
a380 1
/* A table of the register symbols */
d383 1
a383 1
/* Constant sections, or sections of constants */
a385 1
static segT alpha_lit4_section;
a396 1
static symbolS *alpha_lit4_symbol;
d405 1
a405 1
/* Literal for .litX+0x8000 within .lita */
a406 1
static offsetT alpha_lit4_literal;
d415 1
a415 1
/* Is the assembler not allowed to use $at? */
d418 1
a418 1
/* Are macros enabled? */
d421 1
a421 1
/* Are floats disabled? */
d424 1
a424 1
/* Are addresses 32 bit? */
d478 1
a478 2
 * longer than 64 characters, else longer symbol names are truncated.
 */
d495 2
a496 1
static const struct alpha_reloc_op_tag {
d503 3
a505 1
} alpha_reloc_op[] = {
d564 2
a565 1
static const struct cpu_type {
d568 3
a570 1
} cpu_types[] = {
d607 2
a608 1
static const struct alpha_macro alpha_macros[] = {
d820 1
a820 2
  /* Create the opcode hash table */

d854 1
a854 2
  /* Create the macro hash table */

d872 1
a872 2
  /* Construct symbols for each of the registers */

d876 1
d884 1
d890 1
a890 1
  /* Create the special symbols and sections we'll be using */
d929 1
a929 1
  char opname[32];			/* current maximum is 13 */
d934 1
a934 1
  /* split off the opcode */
d942 1
a942 1
  /* tokenize the rest of the line */
d951 1
a951 1
  /* finish it off */
d973 1
a973 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d1425 1
a1429 1
#ifdef OBJ_ELF
d1462 1
a1463 1
}
d1616 1
a1616 1
      /* fake out bfd_perform_relocation. sigh */
d1624 4
a1627 6
      /*
       * Ohhh, this is ugly.  The problem is that if this is a local global
       * symbol, the relocation will entirely be performed at link time, not
       * at assembly time.  bfd_perform_reloc doesn't know about this sort
       * of thing, and as a result we need to fake it out here.
       */
d1765 1
d1780 1
d1895 1
d1979 1
d1985 1
d1989 1
a1989 1
  /* Save and restore input_line_pointer around this function */
d2012 2
a2013 1
	    {			/* only support one relocation op per insn */
d2026 1
a2026 1
	  /* Parse !relocation_type */
d2066 1
a2066 1
	      /* Parse !sequence_number */
d2105 1
a2105 1
	    /* ... then fall through to plain expression */
d2145 1
a2146 1
#ifdef RELOC_OP_P
d2172 1
a2172 1
      /* Don't match opcodes that don't exist on this architecture */
d2182 1
a2182 1
	  /* only take input from real operands */
d2186 1
a2186 1
	  /* when we expect input, make sure we have it */
d2194 1
a2194 1
	  /* match operand type with expression type */
d2236 1
a2236 1
	      /* everything else should have been fake */
d2242 1
a2242 1
      /* possible match -- did we use all of our input? */
d2251 1
a2251 1
  while (++opcode - alpha_opcodes < alpha_num_opcodes
d2288 1
a2288 1
	      /* index register */
d2296 1
a2296 1
	      /* parenthesized index register */
d2304 1
a2304 1
	      /* optional parenthesized index register */
d2311 1
a2311 1
	      /* leading comma with a parenthesized index register */
d2319 1
a2319 1
	      /* floating point register */
d2327 1
a2327 1
	      /* normal expression */
d2364 1
a2364 1
  while (++macro - alpha_macros < alpha_num_macros
d2423 2
a2424 4
/*
 * Turn an opcode description and a set of arguments into
 * an instruction and a fixup.
 */
d2573 1
a2573 3
/*
 * Actually output an instruction with its fixup.
 */
d2597 1
a2597 1
  /* Apply the fixups in order */
d2606 1
a2606 1
      /* Some fixups are only used internally and so have no howto */
d2696 1
d2771 1
a2771 1

d2860 1
a2860 1
  /* search opcodes */
d2892 1
a2892 1
/* Some instruction sets indexed by lg(size) */
d3063 1
a3063 1
	/* attempt to reduce .lit load by splitting the offset from
d3915 12
a3926 13
   *
   * Convert
   *    OP x,y,result
   * to
   *    mov x,R16	# if x != R16
   *    mov y,R17	# if y != R17
   *    lda AT,__OP
   *    jsr AT,(AT),0
   *    mov R0,result
   *
   * with appropriate optimizations if R0,R16,R17 are the registers
   * specified by the compiler.
   */
d3940 1
a3940 1
  /* Move the operands into the right place */
d3943 1
a3943 1
      /* They are in exactly the wrong order -- swap through AT */
d3990 1
a3990 1
  /* Call the division routine */
d3996 1
a3996 1
  /* Move the result to the right place */
d4014 11
a4024 12
   * Convert
   *    OP x,y,result
   * to
   *    lda pv,__OP
   *    mov x,t10
   *    mov y,t11
   *    jsr t9,(pv),__OP
   *    mov t12,result
   *
   * with appropriate optimizations if t10,t11,t12 are the registers
   * specified by the compiler.
   */
d4040 1
a4040 1
  /* Move the operands into the right place */
d4043 1
a4043 2
      /* They are in exactly the wrong order -- swap through AT */

d4083 1
a4083 1
  /* Call the division routine */
d4088 1
a4088 1
  /* Reload the GP register */
d4099 1
a4099 1
  /* Move the result to the right place */
d4207 1
a4207 1
/* Assembler directives */
d4251 1
a4251 1
     int ignore;
d4367 1
a4367 1
     int ignore;
d4388 1
a4388 1
     int ignore;
d4408 1
a4408 1
     int ignore;
d4690 1
a4690 1
     int ignore;
d4727 1
a4727 1
     int ignore;
d4761 1
a4761 1
     int ignore;
d4914 1
a4914 1
     int ignore;
d4952 1
a4952 1
     int ignore;
d4980 1
a4980 1
     int ignore;
d5008 1
a5008 1
     int ignore;
d5019 1
a5019 1
     int ignore;
d5040 1
a5040 1
     int ignore;
d5061 1
a5061 1
     int ignore;
d5075 1
a5075 1
     int ignore;
d5595 1
@


1.44
log
@        * config/tc-alpha.c (alpha_adjust_symtab_relocs): Fix thinko
        with LITERALs without sequence numbers.
@
text
@d579 4
d591 2
d1111 1
a1111 1
-mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mall\n\
d1113 1
a1113 1
-m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264\n\
@


1.44.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* write.c: Delete set_segment_vma and prototype. Update all callers.

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.

	2002-09-16  Chris Demetriou  <cgd@@broadcom.com>
	* config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
	(IS_SEXT_16BIT_NUM): New macro.
	(macro_build_ldst_constoffset): New function, to build a set of
	instructions to do a load or store from a constant offset relative
	to a given register.
	(macro, s_cprestore): Use macro_build_ldst_constoffset to implement
	.cprestore pseudo-op.

	2002-09-16  Elias Athanasopoulos  <eathan@@otenet.gr>
	* dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
	(out_debug_info): Likewise.

	2002-09-13  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_assemble): Do not count FAKE operands
	when deciding if any operands have been skipped.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-09-04  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_begin): Do not insert non-BookE32
	instructions into the hash table if the target cpu is the BookE32.

	2002-08-20  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
	by zero.

	2002-08-15  Alexandre Oliva  <aoliva@@redhat.com>
	* config/tc-mips.c (macro_build_jalr): Make sure we generate
	the fix-up against on the right frag.
	(s_cpsetup): Likewise.  Parse third argument as expression, to
	handle global symbols and forward/backward labels correctly.

	2002-08-14  Nick Clifton  <nickc@@redhat.com>
	* read.c (stringer): Catch attempts to create strings in the abs
	section.

	2002-08-12  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

	2002-08-10  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.

	2002-08-06  George France <france@@handhelds.org>
	* config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
	and m21264b processor names and cpu types.
	* doc/c-alpha.texi: Documented new types.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.

	2002-08-03  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.

	2002-07-31  Momchil Velikov  <velco@@fadata.bg>
	* config/tc-v850.c (md_assemble): Fix range check for immediate
	operand.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".
@
text
@a578 4
  { "21264a", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },
  { "21264b", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },
a586 2
  { "ev67", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },
  { "ev68", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },
d1105 1
a1105 1
-mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mev67 | -mev68 | -mall\n\
d1107 1
a1107 1
-m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264 | -m21264a | -m21264b\n\
@


1.44.2.2
log
@2002-10-31  David O'Brien  <obrien@@FreeBSD.org>
	* config/tc-ia64.c: Cast dwarf2_directive_file to int.
	* config/tc-sparc.c: Likewise.
	* config/tc-alpha.c: Cast s_alpha_file to int.
	* config/tc-alpha.h (TC_INIT_FIX_DATA): info is of type struct
	alpha_reloc_tag.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20021012184546.W979@@bubble.sa.bigpond.net.au>
@
text
@d5497 1
a5497 1
  {"file", (void (*) PARAMS ((int))) s_alpha_file, 5},
@


1.44.2.3
log
@        * config/tc-alpha.c (alpha_validate_fix): Move code ...
        (alpha_fix_adjustable): ... here.
        * config/tc-alpha.h (TC_VALIDATE_FIX): Remove.
@
text
@d1415 43
d1527 1
a1563 33

    case BFD_RELOC_ALPHA_BRSGP:
      /* If we have a BRSGP reloc to a local symbol, adjust it to BRADDR and
         let it get resolved at assembly time.  */
      {
	symbolS *sym = f->fx_addsy;
	const char *name;
	int offset = 0;

	if (! S_IS_DEFINED (sym))
	  return 0;

	switch (S_GET_OTHER (sym) & STO_ALPHA_STD_GPLOAD)
	  {
	  case STO_ALPHA_NOPV:
	    break;
	  case STO_ALPHA_STD_GPLOAD:
	    offset = 8;
	    break;
	  default:
	    if (S_IS_LOCAL (sym))
	      name = "<local>";
	    else
	      name = S_GET_NAME (sym);
	    as_bad_where (f->fx_file, f->fx_line,
		_("!samegp reloc against symbol without .prologue: %s"),
		name);
	    break;
	  }
	f->fx_r_type = BFD_RELOC_23_PCREL_S2;
	f->fx_offset += offset;
	return 1;
      }
@


1.44.2.4
log
@	* config/tc-alpha.c (s_alpha_prologue): as_bad when sym is NULL.
@
text
@d4529 1
a4529 6

  if (sym == NULL)
    {
      as_bad (_(".prologue directive without a preceding .ent directive"));
      return;
    }
@


1.43
log
@	include/elf/
        * alpha.h (LITUSE_ALPHA_ADDR, LITUSE_ALPHA_BASE, LITUSE_ALPHA_BYTOFF,
        LITUSE_ALPHA_JSR, LITUSE_ALPHA_TLSGD, LITUSE_ALPHA_TLSLDM): New.

	gas/
        * config/tc-alpha.c: Move LITUSE constants to "elf/alpha.h".
        Rename them LITUSE_ALPHA_*.

	bfd/
        * elf64-alpha.c (alpha_get_dtprel_base, alpha_get_tprel_base): New.
        (elf64_alpha_relocate_section): Use them.  Reject LE TLS relocs
        in shared libraries.  Fix DTPRELHI and TPRELHI value.
        (INSN_ADDQ, INSN_RDUNIQ): New.
        (struct alpha_relax_info): Add symtab_hdr, tls_segment, first_gotent.
        (elf64_alpha_relax_with_lituse): Return boolean.  Remove irelend
        argument.  Reject dynamic symbols.  Use LITUSE symbolic constants.
        (elf64_alpha_relax_got_load): Rename from relax_without_lituse.
        Handle GOTDTPREL and GOTTPREL relocations.
        (elf64_alpha_relax_gprelhilo): New.
        (elf64_alpha_relax_tls_get_addr): New.
        (elf64_alpha_relax_find_tls_segment): New.
        (elf64_alpha_relax_section): Handle TLS relocations.
        (ALPHA_ELF_LINK_HASH_TLS_IE): New.
        (elf64_alpha_check_relocs): Set it.
@
text
@d1778 3
a1780 2
	  if (fixp->tc_fix_data.info->saw_tlsgd
	      || fixp->tc_fix_data.info->saw_tlsldm)
d1836 2
a1837 1
	  if (fixp->tc_fix_data.info->n_master == 1
@


1.42
log
@include/elf/
        * alpha.h (R_ALPHA_TLSGD, R_ALPHA_TLSLDM, R_ALPHA_DTPMOD64,
        R_ALPHA_GOTDTPREL, R_ALPHA_DTPREL64, R_ALPHA_DTPRELHI,
        R_ALPHA_DTPRELLO, R_ALPHA_DTPREL16, R_ALPHA_GOTTPREL, R_ALPHA_TPREL64,
        R_ALPHA_TPRELHI, R_ALPHA_TPRELLO, R_ALPHA_TPREL16): New.

bfd/
        * elf64-alpha.c (ALPHA_ELF_LINK_HASH_LU_TLSGD,
        ALPHA_ELF_LINK_HASH_LU_TLSLDM, ALPHA_ELF_LINK_HASH_LU_FUNC): New.
        (ALPHA_ELF_GOT_ENTRY_RELOCS_DONE): Remove.
        (ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED): Remove.
        (struct alpha_elf_got_entry): Add reloc_type, reloc_done, reloc_xlated.
        (struct alpha_elf_obj_tdata): Rename total_got_entries and
        n_local_got_entries to total_got_size and local_got_size.
        (elf64_alpha_howto, elf64_alpha_reloc_map): Update for TLS relocs.
        (alpha_got_entry_size): New.
        (elf64_alpha_relax_with_lituse): Use it.
        (elf64_alpha_relax_without_lituse): Likewise.
        (MAX_GOT_SIZE): Rename from MAX_GOT_ENTRIES.
        (get_got_entry): New.
        (elf64_alpha_check_relocs): Handle TLS relocs.  Reorganize.
        (elf64_alpha_adjust_dynamic_symbol): Test LU_FUNC as a mask.
        (elf64_alpha_merge_ind_symbols): Check gotent->reloc_type.
        (elf64_alpha_can_merge_gots, elf64_alpha_merge_gots): Likewise.
        (elf64_alpha_calc_got_offsets_for_symbol): Use alpha_got_entry_size.
        (elf64_alpha_calc_got_offsets): Likewise.
        (alpha_dynamic_entries_for_reloc): New.
        (elf64_alpha_calc_dynrel_sizes): Use it.
        (elf64_alpha_size_dynamic_sections): Likewise.
        (elf64_alpha_relocate_section): Handle TLS relocations.
        * reloc.c: Add Alpha TLS relocations.
        * bfd-in2.h, libbfd.h: Rebuild.

gas/
        * expr.h (operatorT): Add O_md17..O_md32.
        * config/tc-alpha.c (O_lituse_tlsgd, O_lituse_tlsldm, O_tlsgd,
        O_tlsldm, O_gotdtprel, O_dtprelhi, O_dtprello, O_dtprel, O_gottprel,
        O_tprelhi, O_tprello, O_tprel): New.
        (USER_RELOC_P, alpha_reloc_op_tag, debug_exp): Include them.
        (DUMMY_RELOC_LITUSE_TLSGD, DUMMY_RELOC_LITUSE_TLSLDM): New.
        (LITUSE_TLSGD, LITUSE_TLSLDM): New.
        (struct alpha_reloc_tag): Add master, saw_tlsgd, saw_tlsld,
        saw_lu_tlsgd, saw_lu_tlsldm.  Make multi_section_p a bit field.
        (md_apply_fix3): Handle TLS relocations.
        (alpha_force_relocation, alpha_fix_adjustable): Likewise.
        (alpha_adjust_symtab_relocs): Sort LITERAL relocs after the
        associated TLS reloc.  Check lituse_tls relocs match up.
        (emit_insn): Handle TLS relocations.
        (ldX_op): Remove.

gas/testsuite/
        * gas/alpha/elf-tls-1.s, gas/alpha/elf-tls-1.d: New.
        * gas/alpha/elf-tls-2.s, gas/alpha/elf-tls-1.l: New.
        * gas/alpha/elf-tls-3.s, gas/alpha/elf-tls-1.l: New.
        * gas/alpha/alpha.exp: Run them.
@
text
@a139 7
#define LITUSE_ADDR	0
#define LITUSE_BASE	1
#define LITUSE_BYTOFF	2
#define LITUSE_JSR	3
#define LITUSE_TLSGD	4
#define LITUSE_TLSLDM	5

d1754 1
a1754 1
	  if (fixp->fx_offset == LITUSE_TLSGD)
d1761 1
a1761 1
	  else if (fixp->fx_offset == LITUSE_TLSLDM)
d2682 1
a2682 1
	  fixP->fx_offset = LITUSE_ADDR;
d2685 1
a2685 1
	  fixP->fx_offset = LITUSE_BASE;
d2688 1
a2688 1
	  fixP->fx_offset = LITUSE_BYTOFF;
d2691 1
a2691 1
	  fixP->fx_offset = LITUSE_JSR;
d2694 1
a2694 1
	  fixP->fx_offset = LITUSE_TLSGD;
d2697 1
a2697 1
	  fixP->fx_offset = LITUSE_TLSLDM;
@


1.41
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d109 1
a109 2
/* Note, the alpha_reloc_op table below depends on the ordering
   of O_literal .. O_gpre16.  */
d115 17
a131 5
#define O_gpdisp	O_md8	/* !gpdisp relocation */
#define O_gprelhigh	O_md9	/* !gprelhigh relocation */
#define O_gprellow	O_md10	/* !gprellow relocation */
#define O_gprel		O_md11	/* !gprel relocation */
#define O_samegp	O_md12	/* !samegp relocation */
d137 2
d144 2
d147 1
a147 1
#define USER_RELOC_P(R) ((R) >= O_literal && (R) <= O_samegp)
d514 2
d520 11
a530 1
  DEF(samegp, BFD_RELOC_ALPHA_BRSGP, 0, 0)
d545 2
a546 1
  fixS *slaves;			/* head of linked list of !literals */
d551 5
a555 1
  char multi_section_p;		/* True if more than one section was used */
d1258 10
d1486 10
d1552 14
a1734 1
  unsigned long n_slaves = 0;
a1756 1
	  n_slaves++;
d1761 14
a1777 1
	  n_slaves++;
d1784 6
d1797 4
a1800 4
  /* If there were any dependent relocations, go and add them back to
     the chain.  They are linked through the next_reloc field in
     reverse order, so as we go through the next_reloc chain, we
     effectively reverse the chain once again.
d1820 21
d1927 2
d1934 10
a1943 4
	case O_md13:			name = "O_md13";		break;
	case O_md14:			name = "O_md14";		break;
	case O_md15:			name = "O_md15";		break;
	case O_md16:			name = "O_md16";		break;
d2594 1
a2594 1
      struct alpha_reloc_tag *info;
d2636 8
d2678 2
d2681 1
d2699 7
d2711 13
a2723 1
	  info->n_slaves++;
d2731 32
a2891 1
static const char * const ldX_op[] = { "ldb", "ldw", "ldll", "ldq" };
@


1.40
log
@	* config/tc-alpha.c (assemble_tokens): Protect use of
	ALPHA_RELOC_TABLE with #ifdef RELOC_OP_P.
@
text
@d1559 2
a1560 1
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE))
d5471 1
a5471 1
  *ptr_msg = _("Bad .section directive: want a,s,w,x,M,S in string");
@


1.39
log
@	* config/obj-coff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/tc-alpha.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-hppa.c: Likewise.
@
text
@d2651 1
d2658 3
a2660 1
  else if (local_macros_on)
@


1.38
log
@	* config/tc-alpha.c (s_alpha_text): Use obj_elf_text for OBJ_ELF, not
	s_text.
	(s_alpha_data): Use obj_elf_data for OBJ_ELF, not s_data.
@
text
@d2 2
a3 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d1897 1
a1897 1
          SKIP_WHITESPACE ();
d1920 1
a1920 1
          SKIP_WHITESPACE ();
d2380 1
a2380 1
	     relocations, and thus the user-supplied reloc does not 
@


1.37
log
@        * config/tc-alpha.c (O_samegp): New.
        (USER_RELOC_P): Include it.
        (alpha_reloc_op_tag, debug_exp, find_macro_match): Add it.
        (md_apply_fix3): Handle BFD_RELOC_ALPHA_BRSGP.
        (alpha_force_relocation, alpha_fix_adjustable): Likewise.
        (alpha_validate_fix): New.
        * config/tc-alpha.h (TC_VALIDATE_FIX): New.

        * gas/alpha/elf-reloc-5.s, gas/alpha/elf-reloc-5.d: New.
        * gas/alpha/elf-reloc-6.s, gas/alpha/elf-reloc-6.l: New.
        * gas/alpha/alpha.exp: Run them.
@
text
@d4034 3
d4038 1
d4051 3
d4055 1
@


1.37.2.1
log
@	* config/tc-alpha.c (s_alpha_text): Use obj_elf_text for OBJ_ELF, not
	s_text.
	(s_alpha_data): Use obj_elf_data for OBJ_ELF, not s_data.
@
text
@a4033 3
#ifdef OBJ_ELF
  obj_elf_text (i);
#else
a4034 1
#endif
a4046 3
#ifdef OBJ_ELF
  obj_elf_data (i);
#else
a4047 1
#endif
@


1.36
log
@        * config/tc-alpha.c (alpha_force_relocation): Don't assert that
        we've eliminated all foreign relocation types yet.
        (alpha_fix_adjustable): Likewise.
@
text
@d120 1
d132 1
a132 1
#define USER_RELOC_P(R) ((R) >= O_literal && (R) <= O_gprel)
d502 2
a503 1
  DEF(gprel, BFD_RELOC_GPREL16, 0, 0)
d1224 5
d1374 43
d1441 1
d1476 1
d1818 1
d1826 1
a1826 2
	case O_md11:			name = "O_md11";		break;
	case O_md12:			name = "O_md12";		break;
d2221 1
@


1.35
log
@        * config/tc-alpha.c (alpha_handle_align): Encode unop with RB as $sp.
@
text
@a1401 2
      assert ((int) f->fx_r_type < 0
	      && -(int) f->fx_r_type < (int) alpha_num_operands);
a1448 2
      assert ((int) f->fx_r_type < 0
	      && - (int) f->fx_r_type < (int) alpha_num_operands);
@


1.34
log
@	* elf64-alpha.c (ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED): Defined.
	(elf64_alpha_relocate_section): Translate local_got_entries
	for STT_SECTION symbol to SHF_MERGE section the first time
	we see it.
	* elfxx-ia64.c (struct elfNN_ia64_local_hash_entry): Add
	sec_merge_done.
	(get_local_sym_hash): New, extracted from get_dyn_sym_info.
	(get_dyn_sym_info): Use it.
	(elfNN_ia64_relocate_section): Translate local dyn entries
	for STT_SECTION symbol to SHF_MERGE section the first time
	we see it.

        * write.c (adjust_reloc_syms): Mark SEC_MERGE symbols as used
        in reloc if it has non-zero addend.
        * config/tc-alpha.c (tc_gen_reloc): Reinstall SEC_MERGE check.
        * config/tc-sparc.c (md_apply_fix3): Likewise.
@
text
@d5473 1
a5473 1
  static char const unop[4] = { 0x00, 0x00, 0xe0, 0x2f };
d5476 1
a5476 1
    0x00, 0x00, 0xe0, 0x2f
@


1.33
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d1510 2
a1511 1
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
@


1.32
log
@2001-11-15  H.J. Lu  <hjl@@gnu.org>

	* config/tc-alpha.c (md_apply_fix3): Fix a typo.
@
text
@d1510 1
a1510 2
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE))
@


1.31
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d1122 1
a1122 1
md_apply_fix3 (fixP, valueP, seg)
@


1.30
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d1121 1
a1121 1
int
d1124 1
a1124 1
     valueT *valueP;
d1128 1
a1128 1
  valueT value = *valueP;
d1187 1
a1187 1
      return 1;
d1202 1
a1202 1
      return 1;
d1211 1
a1211 1
      return 1;
d1220 1
a1220 1
      return 1;
d1225 1
a1225 1
      return 1;
d1231 1
a1231 1
      return 1;
d1235 1
a1235 1
      return 1;
d1265 1
a1265 1
    return 1;
a1277 1
  return 0;
d1280 1
a1280 3
/*
 * Look for a register name in the given symbol.
 */
@


1.29
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1371 1
a1371 1
   there is some hope of resolving it a assembly time.  */
@


1.28
log
@        * config/tc-alpha.c (alpha_elf_section_letter): New.
        (alpha_elf_section_flags): New.
        * config/tc-alpha.h (md_elf_section_letter): New.
        (md_elf_section_flags): New.
        * config/tc-ia64.c (ia64_elf_section_letter): New.
        * config/tc-ia64.h (md_elf_section_letter): New.
@
text
@d65 1
a65 1
#include <ctype.h>
d1302 1
a1302 1
	  if (!isdigit (*++name))
d1310 1
a1310 1
	  else if (name[0] != '0' && isdigit (name[1]) && name[2] == '\0')
d4217 1
a4217 1
	  if (isdigit (*input_line_pointer) || *input_line_pointer == '-')
@


1.27
log
@        * config/tc-alpha.c (alpha_reloc_op_tag): Replace need_seq with
        require_seq and allow_seq.  Let !literal omit the sequence number.
        (tokenize_arguments): Reject sequence numbers of !allow_seq.
@
text
@d5402 28
@


1.26
log
@ 	* config/tc-alpha.c (struct alpha_insn): Make sequence scalar long.
 	(MACRO_LITERAL, MACRO_BASE, MACRO_BYTOFF, MACRO_JSR): Remove.
 	(alpha_macros): Remove occurrences of same.
 	(O_lituse_addr, O_gprel): New.
 	(DUMMY_RELOC_LITUSE_*): New.
 	(s_alpha_ucons, s_alpha_arch): Prototype.
 	(alpha_reloc_op): Construct elements via DEF macro.
 	(ALPHA_RELOC_SEQUENCE_OK): Remove.
 	(struct alpha_reloc_tag): Rename from alpha_literal_tag; rename
 	members to not be literal specific.
 	(next_sequence_num): New.
 	(md_apply_fix3): Cope with missing GPDISP_LO16.  Adjust for
 	added/removed BFD relocations.
 	(alpha_force_relocation, alpha_fix_adjustable): Likewise.
 	(alpha_adjust_symtab_relocs): Handle GPDISP relocs as well.
 	(tokenize_arguments): Parse ! relocations properly.
 	(find_macro_match): Delete unused macro argument types.
 	(assemble_insn): Add reloc parameter; emit that instead of the
 	default as appropriate.
 	(get_alpha_reloc_tag): New.  Split from ...
 	(emit_insn): ... here.  Allocate a reloc tag for GPDISP.
 	(assemble_tokens): Don't search macros if user relocation present.
 	Copy reloc sequence number to insn struct.
 	(emit_ldgp): Remove user reloc handling.
 	(load_expression, emit_lda, emit_ldah, emit_ir_load): Likewise.
 	(emit_loadstore, emit_ldXu, emit_ldil, emit_stX): Likewise.
 	(emit_sextX, emit_division, emit_jsrjmp, emit_retjcr): Likewise.
 	* config/tc-alpha.h (tc_adjust_symtab): Always define.
 	(struct alpha_fix_tag): Name members less literal specific.

 	* gas/alpha/alpha.exp: New file.
 	* gas/alpha/elf-reloc-1.[sd]: New test.
 	* gas/alpha/elf-reloc-2.[sl]: New test.
 	* gas/alpha/elf-reloc-3.[sl]: New test.
 	* gas/alpha/elf-reloc-4.[sd]: New test.
 	* gas/alpha/fp.exp: Remove file.
 	* gas/alpha/fp.s: Output to .data not .rdata.
 	* gas/alpha/fp.d: Adjust to match.
@
text
@d482 2
a483 2
#define DEF(NAME, RELOC, NEED_SEQ) \
 { #NAME, sizeof(#NAME)-1, O_##NAME, RELOC, NEED_SEQ }
d490 2
a491 1
  unsigned int need_seq : 1;			/* require a sequence number */
d493 9
a501 9
  DEF(literal, BFD_RELOC_ALPHA_ELF_LITERAL, 1),
  DEF(lituse_addr, DUMMY_RELOC_LITUSE_ADDR, 1),
  DEF(lituse_base, DUMMY_RELOC_LITUSE_BASE, 1),
  DEF(lituse_bytoff, DUMMY_RELOC_LITUSE_BYTOFF, 1),
  DEF(lituse_jsr, DUMMY_RELOC_LITUSE_JSR, 1),
  DEF(gpdisp, BFD_RELOC_ALPHA_GPDISP, 1),
  DEF(gprelhigh, BFD_RELOC_ALPHA_GPREL_HI16, 0),
  DEF(gprellow, BFD_RELOC_ALPHA_GPREL_LO16, 0),
  DEF(gprel, BFD_RELOC_GPREL16, 0)
d1878 1
a1878 1
	      if (r->need_seq)
d1880 1
a1880 2
		  as_bad (_("No !sequence-number after !%s"),
			  input_line_pointer);
a1883 1
	      tok->X_op = r->op;
a1884 3
	      reloc_found_p = 1;
	      ++tok;
	      break;
d1886 7
d1894 1
a1894 1
	  input_line_pointer++;
d1896 8
a1903 7
	  /* Parse !sequence_number */
	  expression (tok);
	  if (tok->X_op != O_constant || tok->X_add_number <= 0)
	    {
	      as_bad (_("Bad sequence number: !%s!%s"),
		      r->name, input_line_pointer);
	      goto err_report;
@


1.25
log
@        * config/tc-alpha.h (MD_APPLY_FIX3): Define.
        * config/tc-alpha.c (md_apply_fix3): Rename from md_apply_fix;
        use seg parameter instead of now_seg.
@
text
@d84 1
a84 1
  unsigned sequence[MAX_INSN_FIXUPS];
a94 4
  MACRO_LITERAL,
  MACRO_BASE,
  MACRO_BYTOFF,
  MACRO_JSR
a108 1
#ifdef RELOC_OP_P
d110 1
a110 1
   of O_literal .. O_gprelow.  */
d112 18
a129 6
#define O_lituse_base	O_md4	/* !lituse_base relocation */
#define O_lituse_bytoff	O_md5	/* !lituse_bytoff relocation */
#define O_lituse_jsr	O_md6	/* !lituse_jsr relocation */
#define O_gpdisp	O_md7	/* !gpdisp relocation */
#define O_gprelhigh	O_md8	/* !gprelhigh relocation */
#define O_gprellow	O_md9	/* !gprellow relocation */
d131 1
a131 2
#define USER_RELOC_P(R) ((R) >= O_literal && (R) <= O_gprellow)
#endif
d197 3
d209 1
a209 1
	   struct alpha_insn *));
d216 2
a217 3
static int load_expression
  PARAMS ((int, const expressionS *, int *, expressionS *,
	   const expressionS *));
d268 2
a275 4

#ifdef RELOC_OP_P
static void alpha_adjust_symtab_relocs PARAMS ((bfd *, asection *, PTR));
#endif
d478 1
a478 1
&alpha_reloc_op[ ((!USER_RELOC_P (op))					\
d480 1
a480 1
		  : (int) (op) - (int) O_literal) ]
d482 2
a483 3
#define LITUSE_BASE	1
#define LITUSE_BYTOFF	2
#define LITUSE_JSR	3
d488 1
d490 1
a490 2
  operatorT op;					/* which operator to use */
  int lituse;					/* addened to specify lituse */
d492 10
d503 1
a503 56
  {
    "literal",					/* name */
    sizeof ("literal")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITERAL,		/* reloc */
    O_literal,					/* op */
    0,						/* lituse */
  },

  {
    "lituse_base",				/* name */
    sizeof ("lituse_base")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_BASE,		/* reloc */
    O_lituse_base,				/* op */
    LITUSE_BASE,				/* lituse */
  },

  {
    "lituse_bytoff",				/* name */
    sizeof ("lituse_bytoff")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,		/* reloc */
    O_lituse_bytoff,				/* op */
    LITUSE_BYTOFF,				/* lituse */
  },

  {
    "lituse_jsr",				/* name */
    sizeof ("lituse_jsr")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_JSR,		/* reloc */
    O_lituse_jsr,				/* op */
    LITUSE_JSR,					/* lituse */
  },

  {
    "gpdisp",					/* name */
    sizeof ("gpdisp")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPDISP,		/* reloc */
    O_gpdisp,					/* op */
    0,						/* lituse */
  },

  {
    "gprelhigh",				/* name */
    sizeof ("gprelhigh")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPRELHIGH,		/* reloc */
    O_gprelhigh,				/* op */
    0,						/* lituse */
  },

  {
    "gprellow",					/* name */
    sizeof ("gprellow")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPRELLOW,		/* reloc */
    O_gprellow,					/* op */
    0,						/* lituse */
  },
};
d507 1
a511 3
/* Whether a sequence number is valid.  */
#define ALPHA_RELOC_SEQUENCE_OK(X) ((X) > 0 && ((unsigned) (X)) == (X))

d513 1
a513 1
struct alpha_literal_tag
d515 1
a515 1
  fixS *lituse;			/* head of linked list of !literals */
d517 4
a520 4
  int multi_section_p;		/* True if more than one section was used */
  unsigned sequence;		/* sequence # */
  unsigned n_literals;		/* # of literals */
  unsigned n_lituses;		/* # of lituses */
d526 3
a528 1
#endif
d569 1
a569 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_LITERAL, MACRO_BASE, MACRO_EOA } },
d574 1
a574 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d576 1
a576 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d578 1
a578 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_LITERAL, MACRO_EOA } },
d580 1
a580 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d582 1
a582 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d584 1
a584 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d586 1
a586 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d588 1
a588 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d590 1
a590 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d593 1
a593 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d595 1
a595 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d597 1
a597 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d599 1
a599 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d602 1
a602 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d604 1
a604 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d606 1
a606 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d608 1
a608 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d610 1
a610 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d635 1
a635 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d637 1
a637 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d639 1
a639 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d641 1
a641 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d643 1
a643 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d645 1
a645 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d647 1
a647 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d649 1
a649 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d651 1
a651 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d654 1
a654 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d656 1
a656 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d658 1
a658 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d660 1
a660 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d662 1
a662 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d725 4
a728 4
    { MACRO_PIR, MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_PIR, MACRO_JSR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_EXP, MACRO_JSR, MACRO_EOA } },
d730 4
a733 4
    { MACRO_PIR, MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_PIR, MACRO_JSR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_EXP, MACRO_JSR, MACRO_EOA } },
d788 2
a789 1
	as_fatal (_("internal error: can't hash opcode `%s': %s"), name, retval);
a875 3
  subseg_set (text_section, 0);

#ifdef RELOC_OP_P
d878 2
a879 1
#endif
a1138 1
	assert (next->fx_r_type == BFD_RELOC_ALPHA_GPDISP_LO16);
d1140 6
a1145 2
	fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where
			   - fixP->fx_frag->fr_address - fixP->fx_where);
d1195 2
d1198 3
a1200 2
#ifdef OBJ_ELF
    case BFD_RELOC_GPREL32:
a1201 1
#endif
a1224 3

    case BFD_RELOC_ALPHA_LITUSE:
      return 1;
a1225 1
#ifdef OBJ_ELF
a1227 3
      return 1;
#endif
#ifdef OBJ_EVAX
a1230 14
#endif

#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
      return 1;

    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
      abort ();
#endif
a1383 1
#ifdef OBJ_ECOFF
a1384 2
#endif
#ifdef OBJ_ELF
a1385 1
#endif
d1387 1
d1389 2
a1390 1
#ifdef OBJ_EVAX
a1392 10
#endif
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
#endif
a1430 1
#ifdef OBJ_ECOFF
a1431 2
#endif
#ifdef OBJ_ELF
d1433 1
a1433 5
#endif
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
#endif
#ifdef OBJ_EVAX
a1435 1
#endif
a1437 9
    case BFD_RELOC_ALPHA_LITUSE:
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
#endif
d1442 1
d1444 2
d1571 28
a1598 1
#ifdef RELOC_OP_P
d1602 1
a1602 2
   relocations.  Also convert the gas-internal relocations to the
   appropriate linker relocations.  */
d1608 1
a1608 11
    {
#ifdef DEBUG2_ALPHA
      fprintf (stderr, "alpha_adjust_symtab called\n");
#endif

      /* Go over each section, reordering the relocations so that all
         of the explicit LITUSE's are adjacent to the explicit
         LITERAL's.  */
      bfd_map_over_sections (stdoutput, alpha_adjust_symtab_relocs,
			     (char *) 0);
    }
a1609 2

/* Inner function to move LITUSE's next to the LITERAL.  */
d1621 2
a1622 8
  fixS *lituse;
  int n_lituses = 0;

#ifdef DEBUG2_ALPHA
  int n = 0;
  int n_literals = 0;
  int n_dup_literals = 0;
#endif
d1634 3
a1636 2
  /* First rebuild the fixup chain without the expicit lituse's.  */
  prevP = &(seginfo->fix_root);
a1640 3
#ifdef DEBUG2_ALPHA
      n++;
#endif
d1644 6
a1649 9
	default:
	  *prevP = fixp;
	  prevP = &(fixp->fx_next);
#ifdef DEBUG2_ALPHA
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, other relocation %s\n",
		   (long) fixp,
		   bfd_get_reloc_code_name (fixp->fx_r_type));
#endif
d1652 6
a1657 14
	case BFD_RELOC_ALPHA_USER_LITERAL:
	  *prevP = fixp;
	  prevP = &(fixp->fx_next);
	  /* prevent assembler from trying to adjust the offset */
#ifdef DEBUG2_ALPHA
	  n_literals++;
	  if (fixp->tc_fix_data.info->n_literals != 1)
	    n_dup_literals++;
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, !literal!%.6d, # literals = %2d\n",
		   (long) fixp,
		   fixp->tc_fix_data.info->sequence,
		   fixp->tc_fix_data.info->n_literals);
#endif
d1660 3
a1662 17
	  /* do not link in lituse's */
	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  n_lituses++;
	  if (fixp->tc_fix_data.info->n_literals == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No !literal!%d was found"),
			  fixp->tc_fix_data.info->sequence);
#ifdef DEBUG2_ALPHA
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, !lituse !%.6d, # lituses  = %2d, next_lituse = 0x%lx\n",
		   (long) fixp,
		   fixp->tc_fix_data.info->sequence,
		   fixp->tc_fix_data.info->n_lituses,
		   (long) fixp->tc_fix_data.next_lituse);
#endif
d1667 19
a1685 9
  /* If there were any lituses, go and add them to the chain, unless there is
     more than one !literal for a given sequence number.  They are linked
     through the next_lituse field in reverse order, so as we go through the
     next_lituse chain, we effectively reverse the chain once again.  If there
     was more than one !literal, we fall back to loading up the address w/o
     optimization.  Also, if the !literals/!lituses are spread in different
     segments (happens in the Linux kernel semaphores), suppress the
     optimization.  */
  if (n_lituses)
d1687 2
a1688 1
      for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
d1690 3
a1692 1
	  switch (fixp->fx_r_type)
d1694 3
a1696 11
	    default:
	      break;

	    case BFD_RELOC_ALPHA_USER_LITERAL:
#ifdef OBJ_ELF
	      fixp->fx_r_type = BFD_RELOC_ALPHA_ELF_LITERAL;
#else
	      fixp->fx_r_type = BFD_RELOC_ALPHA_LITERAL;	/* XXX check this */
#endif
	      if (fixp->tc_fix_data.info->n_literals == 1
		  && ! fixp->tc_fix_data.info->multi_section_p)
d1698 2
a1699 7
		  for (lituse = fixp->tc_fix_data.info->lituse;
		       lituse != (fixS *) 0;
		       lituse = lituse->tc_fix_data.next_lituse)
		    {
		      lituse->fx_next = fixp->fx_next;
		      fixp->fx_next = lituse;
		    }
d1701 2
a1702 1
	      break;
d1704 10
a1713 5
	    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	      fixp->fx_r_type = BFD_RELOC_ALPHA_LITUSE;
	      break;
d1715 4
a1720 8

#ifdef DEBUG2_ALPHA
  fprintf (stderr, "alpha_adjust_symtab_relocs: %s, %d literal%s, %d duplicate literal%s, %d lituse%s\n\n",
	   sec->name,
	   n_literals, (n_literals == 1) ? "" : "s",
	   n_dup_literals, (n_dup_literals == 1) ? "" : "s",
	   n_lituses, (n_lituses == 1) ? "" : "s");
#endif
a1721 2

#endif /* RELOC_OP_P */
d1778 1
a1778 1
	case O_md10:			name = "O_md10";		break;
a1810 1
#ifdef RELOC_OP_P
a1815 1
#endif
d1823 5
d1850 4
a1853 5
	  for (p = ++input_line_pointer;
	       ((c = *p) != '!' && c != ';' && c != '#' && c != ','
		&& !is_end_of_line[c]);
	       p++)
	    ;
d1856 1
a1856 1
	  len = p - input_line_pointer;
d1863 5
a1867 1
	  if (c != '!')
d1869 1
a1869 1
	      as_bad (_("No !sequence-number after !%s"), input_line_pointer);
d1873 3
a1875 2
	  r = &alpha_reloc_op[0];
	  for (i = alpha_num_reloc_op - 1; i >= 0; i--, r++)
d1877 12
a1888 9
	      if (len == r->length
		  && memcmp (input_line_pointer, r->name, len) == 0)
		break;
	    }
	  if (i < 0)
	    {
	      as_bad (_("Unknown relocation operand: !%s"),
		      input_line_pointer);
	      goto err_report;
d1891 1
a1891 1
	  input_line_pointer = ++p;
a1893 1
	  memset (tok, '\0', sizeof (expressionS));
d1895 1
a1895 3

	  if (tok->X_op != O_constant
	      || ! ALPHA_RELOC_SEQUENCE_OK (tok->X_add_number))
d1906 1
a1906 1
#endif
d1958 3
d1965 3
d1971 1
d1973 2
a1974 1
err_report:
a1976 1
#endif
a2163 1
#ifdef RELOC_OP_P
d2171 1
a2171 1
#endif
a2179 32
	      /* optional !literal!<number> */
	    case MACRO_LITERAL:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_literal)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_base!<number> */
	    case MACRO_BASE:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_base)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_bytoff!<number> */
	    case MACRO_BYTOFF:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_bytoff)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_jsr!<number> */
	    case MACRO_JSR:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_jsr)
		tokidx++;
#endif
	      break;

d2254 1
a2254 1
assemble_insn (opcode, tok, ntok, insn)
d2259 1
d2261 2
d2318 3
d2324 11
a2334 2
	  {
	    struct alpha_fixup *fixup;
d2336 2
a2337 2
	    if (insn->nfixups >= MAX_INSN_FIXUPS)
	      as_fatal (_("too many fixups"));
d2339 8
a2346 1
	    fixup = &insn->fixups[insn->nfixups++];
d2348 4
a2351 3
	    fixup->exp = *t;
	    fixup->reloc = operand->default_reloc;
	  }
d2356 41
d2431 1
a2433 4
#ifdef RELOC_OP_P
      char buffer[ALPHA_RELOC_DIGITS];
      struct alpha_literal_tag *info;
#endif
d2442 7
d2450 4
a2453 23
	switch (fixup->reloc)
	  {
#ifdef OBJ_ELF
	    /* These relocation types are only used internally.  */
	  case BFD_RELOC_ALPHA_GPDISP_HI16:
	  case BFD_RELOC_ALPHA_GPDISP_LO16:
	    size = 2;
	    pcrel = 0;
	    break;
#endif
#ifdef RELOC_OP_P
	    /* and these also are internal only relocations */
	  case BFD_RELOC_ALPHA_USER_LITERAL:
	  case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	  case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	  case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  case BFD_RELOC_ALPHA_USER_GPDISP:
	  case BFD_RELOC_ALPHA_USER_GPRELHIGH:
	  case BFD_RELOC_ALPHA_USER_GPRELLOW:
	    size = 2;
	    pcrel = 0;
	    break;
#endif
d2455 2
a2456 5
	  default:
	    {
	      reloc_howto_type *reloc_howto
		= bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	      assert (reloc_howto);
d2458 2
a2459 6
	      size = bfd_get_reloc_size (reloc_howto);
	      pcrel = reloc_howto->pc_relative;
	    }
	    assert (size >= 1 && size <= 4);
	    break;
	  }
d2468 1
a2468 7
	case BFD_RELOC_ALPHA_GPDISP_LO16:
#ifdef OBJ_ECOFF
	case BFD_RELOC_ALPHA_LITERAL:
#endif
#ifdef OBJ_ELF
	case BFD_RELOC_ALPHA_ELF_LITERAL:
#endif
d2470 3
d2476 1
a2476 2
#ifdef RELOC_OP_P
	case BFD_RELOC_ALPHA_USER_LITERAL:
d2478 2
a2479 3
	  sprintf (buffer, "!%u", insn->sequence[i]);
	  info = ((struct alpha_literal_tag *)
		  hash_find (alpha_literal_hash, buffer));
d2481 8
a2488 4
	  if (! info)
	    {
	      size_t len = strlen (buffer);
	      const char *errmsg;
d2490 2
a2491 2
	      info = ((struct alpha_literal_tag *)
		      xcalloc (sizeof (struct alpha_literal_tag) + len, 1));
d2493 9
a2501 7
	      info->segment = now_seg;
	      info->sequence = insn->sequence[i];
	      strcpy (info->string, buffer);
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
	      if (errmsg)
		as_bad (errmsg);
	    }
d2503 3
a2505 1
	  ++info->n_literals;
d2507 2
a2510 1

d2514 14
a2527 11
	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  sprintf (buffer, "!%u", insn->sequence[i]);
	  info = ((struct alpha_literal_tag *)
		  hash_find (alpha_literal_hash, buffer));

	  if (! info)
	    {
	      size_t len = strlen (buffer);
	      const char *errmsg;
d2529 2
a2530 11
	      info = ((struct alpha_literal_tag *)
		      xcalloc (sizeof (struct alpha_literal_tag) + len, 1));

	      info->segment = now_seg;
	      info->sequence = insn->sequence[i];
	      strcpy (info->string, buffer);
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
	      if (errmsg)
		as_bad (errmsg);
	    }
	  info->n_lituses++;
d2532 2
a2533 2
	  fixP->tc_fix_data.next_lituse = info->lituse;
	  info->lituse = fixP;
a2535 1

a2536 1
#endif
d2572 1
a2572 1
	  assemble_insn (opcode, tok, ntok, insn);
d2599 1
d2601 7
a2607 2
  /* search macros */
  if (local_macros_on)
a2622 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif

d2632 6
a2637 1
	  assemble_insn (opcode, tok, ntok, &insn);
d2644 7
a2650 5
    if (cpumatch)
      as_bad (_("inappropriate arguments for opcode `%s'"), opname);
    else
      as_bad (_("opcode `%s' not supported for target %s"), opname,
	      alpha_target_name);
a2684 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, "ldgp");
      ntok--;
    }
#endif

d2708 1
d2723 1
d2803 3
a2805 2
   Finally, the return value is true if the calling macro may emit a
   LITUSE reloc if otherwise appropriate.  */
d2807 2
a2808 2
static int
load_expression (targreg, exp, pbasereg, poffset, explicit_reloc)
a2812 1
     const expressionS *explicit_reloc;
d2814 1
a2814 1
  int emit_lituse = 0;
a2863 1
	assert (explicit_reloc == (const expressionS *) 0);
d2866 1
d2903 2
a2904 12
	if (!explicit_reloc)
	  insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
	else
	  {
#ifdef RELOC_OP_P
	    insn.fixups[0].reloc
	      = (ALPHA_RELOC_TABLE (explicit_reloc->X_op))->reloc;
	    insn.sequence[0] = explicit_reloc->X_add_number;
#else
	    abort ();
#endif
	  }
a2910 1
	assert (explicit_reloc == (const expressionS *) 0);
a2951 2
	emit_lituse = 1;

a2966 1
      assert (explicit_reloc == (const expressionS *) 0);
a2972 1
      assert (explicit_reloc == (const expressionS *) 0);
d2999 1
d3001 1
a3001 1
      /* for 64-bit addends, just put it in the literal pool */
d3061 1
d3073 2
a3074 5
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof (struct alpha_fixup) * insn.nfixups);
	}
d3076 1
a3076 4
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
d3156 1
a3156 1
emit_lda (tok, ntok, opname)
d3159 1
a3159 1
     const PTR opname;
a3161 47
  const expressionS *reloc = (const expressionS *) 0;

#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const struct alpha_reloc_op_tag *r;

      reloc = &tok[ntok - 1];
      r = ALPHA_RELOC_TABLE (reloc->X_op);
      switch (reloc->X_op)
	{
	default:
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc->X_add_number, (const char *) opname);

	  reloc = (const expressionS *) 0;
	  ntok--;
	  break;

	case O_literal:
	  ntok--;
	  break;

	  /* For lda $x,0($x)!lituse_base!y, don't use load_expression, since
	     it is really too general for our needs.  Instead just generate the
	     lda directly.  */
	case O_lituse_base:
	  if (ntok != 4
	      || tok[0].X_op != O_register
	      || !is_ir_num (tok[0].X_add_number)
	      || tok[1].X_op != O_constant
	      || tok[2].X_op != O_pregister
	      || !is_ir_num (tok[2].X_add_number))
	    {
	      as_bad (_("bad instruction format for lda !%s!%ld"), r->name,
		      (long) reloc->X_add_number);

	      reloc = (const expressionS *) 0;
	      ntok--;
	      break;
	    }

	  emit_loadstore (tok, ntok, "lda");
	  return;
	}
    }
#endif
d3168 1
a3168 1
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL, reloc);
a3181 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, "ldah");
      ntok--;
    }
#endif

d3199 2
a3200 1
  int basereg, lituse;
a3203 31
#ifdef RELOC_OP_P
  const expressionS *reloc = (const expressionS *) 0;

  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const struct alpha_reloc_op_tag *r;

      reloc = &tok[ntok - 1];
      switch (reloc->X_op)
	{
	case O_lituse_base:
	  ntok--;
	  break;

	case O_literal:
	  if (strcmp ((const char *) opname, "ldq") == 0)
	    {
	      emit_lda (tok, ntok, opname);
	      return;
	    }

	  /* fall through */
	default:
	  ntok--;
	  r = ALPHA_RELOC_TABLE (reloc->X_op);
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc->X_add_number, (const char *) opname);
	}
    }
#endif

d3210 1
a3210 1
			    &newtok[1], (const expressionS *) 0);
a3216 16
#ifdef RELOC_OP_P
  if (reloc)
    {
      int nfixups = insn.nfixups;
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc->X_op);

      assert (nfixups < MAX_INSN_FIXUPS);
      insn.fixups[nfixups].reloc = r->reloc;
      insn.fixups[nfixups].exp.X_op = O_symbol;
      insn.fixups[nfixups].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[nfixups].exp.X_add_number = r->lituse;
      insn.sequence[nfixups] = reloc->X_add_number;
      insn.nfixups++;
    }
#endif

d3220 2
a3221 5
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof (struct alpha_fixup) * insn.nfixups);
	}
d3223 1
a3223 4
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
d3238 2
a3239 1
  int basereg, lituse;
a3242 15
#ifdef RELOC_OP_P
  const expressionS *reloc = (const expressionS *) 0;

  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      reloc = &tok[--ntok];
      if (reloc->X_op != O_lituse_base)
	{
	  const struct alpha_reloc_op_tag *r = &alpha_reloc_op[reloc->X_md];
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc->X_add_number, (const char *) opname);
	}
    }
#endif

d3253 1
a3253 2
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1],
				(const expressionS *) 0);
a3265 16
#ifdef RELOC_OP_P
  if (reloc)
    {
      int nfixups = insn.nfixups;
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc->X_op);

      assert (nfixups < MAX_INSN_FIXUPS);
      insn.fixups[nfixups].reloc = r->reloc;
      insn.fixups[nfixups].exp.X_op = O_symbol;
      insn.fixups[nfixups].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[nfixups].exp.X_add_number = r->lituse;
      insn.sequence[nfixups] = reloc->X_add_number;
      insn.nfixups++;
    }
#endif

d3269 2
a3270 5
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof (struct alpha_fixup) * insn.nfixups);
	}
d3272 1
a3272 4
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
d3291 3
a3293 13

#ifdef RELOC_OP_P
      if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
	{
	  const expressionS *reloc_exp = &tok[ntok - 1];
	  const struct alpha_reloc_op_tag *r
	    = ALPHA_RELOC_TABLE (reloc_exp->X_op);

	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc_exp->X_add_number, "ldbu/ldwu");
	  ntok--;
	}
#endif
d3298 6
d3306 1
a3306 3
      memcpy (newtok, tok, sizeof (expressionS) * ntok);
      newtok[0].X_add_number = AXP_REG_AT;
      assemble_tokens ("lda", newtok, ntok, 1);
d3312 13
a3324 2
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens ("ldq_u", newtok, 3, 1);
d3328 1
a3328 1
      set_tok_reg (newtok[1], AXP_REG_AT);
d3330 12
a3341 1
      assemble_tokens (extXl_op[(long) vlgsize], newtok, 3, 1);
a3435 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, "ldil");
      ntok--;
    }
#endif

d3457 3
d3464 6
d3472 1
a3472 3
      memcpy (newtok, tok, sizeof (expressionS) * ntok);
      newtok[0].X_add_number = AXP_REG_AT;
      assemble_tokens ("lda", newtok, ntok, 1);
d3478 13
a3490 2
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens ("ldq_u", newtok, 3, 1);
d3495 1
a3495 1
      set_tok_reg (newtok[1], AXP_REG_AT);
d3497 12
a3508 1
      assemble_tokens (insXl_op[lgsize], newtok, 3, 1);
d3514 12
a3525 1
      assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);
d3534 1
a3534 1
      set_tok_const (newtok[1], 0);
d3536 12
a3547 1
      assemble_tokens ("stq_u", newtok, 3, 1);
a3650 13
#ifdef RELOC_OP_P
      if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
	{
	  const expressionS *reloc_exp = &tok[ntok - 1];
	  const struct alpha_reloc_op_tag *r
	    = ALPHA_RELOC_TABLE (reloc_exp->X_op);

	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc_exp->X_add_number, "setxt");
	  ntok--;
	}
#endif

a3696 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, (char char *) symname);
      ntok--;
    }
#endif

a3795 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, (const char *) symname);
      ntok--;
    }
#endif

d3890 2
a3891 12
  int r, tokidx = 0, lituse = 0;

#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif
d3909 1
a3909 2
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL,
				(const expressionS *) 0);
a3925 1
  /* add the LITUSE fixup */
d3929 2
a3930 5
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof (struct alpha_fixup) * insn.nfixups);
	}
d3932 1
a3932 4
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_JSR;
a3949 11

#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif
@


1.24
log
@	* config/tc-alpha.c (tc_gen_reloc): Handle relocs against SEC_MERGE
	section symbols the same way as externs.
@
text
@d1162 1
a1162 1
md_apply_fix (fixP, valueP)
d1165 1
d1200 1
a1200 1
      fixP->fx_addsy = section_symbol (now_seg);
@


1.23
log
@Fix copyright notices
@
text
@d1594 2
a1595 1
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
@


1.22
log
@2001-01-22  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 93-98, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.22.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.21
log
@2001-01-19  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
@
text
@a64 1

d74 1
a74 2
struct alpha_fixup
{
d79 1
a79 2
struct alpha_insn
{
d86 1
a86 2
enum alpha_macro_arg
{
d100 1
a100 2
struct alpha_macro
{
d179 1
a179 1
				 (t).X_add_number = (r)+32)
a186 1

a268 1

d305 1
a305 1
#define OPTION_RELAX (OPTION_32ADDR+1)
d308 2
a309 2
#define OPTION_MDEBUG (OPTION_RELAX+1)
#define OPTION_NO_MDEBUG (OPTION_MDEBUG+1)
a316 1

d571 1
a571 2
static const struct cpu_type
{
d574 1
a574 2
} cpu_types[] =
{
d820 1
a820 1
  for (i = 0; i < alpha_num_opcodes; )
d825 1
a825 1
      retval = hash_insert (alpha_opcode_hash, name, (PTR)&alpha_opcodes[i]);
d840 1
a840 1
	  (void) hash_insert (alpha_opcode_hash, p, (PTR)&alpha_opcodes[i]);
d854 1
a854 1
  for (i = 0; i < alpha_num_macros; )
d859 1
a859 1
      retval = hash_insert (alpha_macro_hash, name, (PTR)&alpha_macros[i]);
d861 2
a862 1
	as_fatal (_("internal error: can't hash macro `%s': %s"), name, retval);
d882 1
a882 1
      sprintf (name, "$f%d", i-32);
d909 1
a909 1
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS|SEC_READONLY);
d1323 1
a1323 1
		    _("type %d reloc done?\n"), (int) fixP->fx_r_type);
d1471 2
a1472 1
      assert ((int) f->fx_r_type < 0 && -(int) f->fx_r_type < (int) alpha_num_operands);
d1653 4
a1656 4
/* Before the relocations are written, reorder them, so that user supplied
   !lituse relocations follow the appropriate !literal relocations.  Also
   convert the gas-internal relocations to the appropriate linker relocations.
   */
d1667 5
a1671 3
      /* Go over each section, reordering the relocations so that all of the
         explicit LITUSE's are adjacent to the explicit LITERAL's */
      bfd_map_over_sections (stdoutput, alpha_adjust_symtab_relocs, (char *) 0);
a1673 1

d1696 3
a1698 2
  /* If seginfo is NULL, we did not create this section; don't do anything with
     it.  By using a pointer to a pointer, we can update the links in place.  */
a1820 1

d1967 1
a1967 1
	  for (i = alpha_num_reloc_op-1; i >= 0; i--, r++)
d1975 2
a1976 1
	      as_bad (_("Unknown relocation operand: !%s"), input_line_pointer);
d1989 2
a1990 1
	      as_bad (_("Bad sequence number: !%s!%s"), r->name, input_line_pointer);
d2118 1
a2118 1
	    case AXP_OPERAND_IR|AXP_OPERAND_PARENS:
d2123 1
a2123 1
	    case AXP_OPERAND_IR|AXP_OPERAND_PARENS|AXP_OPERAND_COMMA:
d2162 1
a2162 1
  while (++opcode-alpha_opcodes < alpha_num_opcodes
d2307 1
a2307 1
  while (++macro-alpha_macros < alpha_num_macros
d2460 1
a2460 1
    struct alpha_insn *insn;
d2465 1
a2465 1
  /* Take care of alignment duties */
d2698 1
a2698 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d2700 1
a2700 1
      const expressionS *reloc_exp = &tok[ntok-1];
a2731 1

d2764 1
a2764 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d2766 1
a2766 1
      const expressionS *reloc_exp = &tok[ntok-1];
d2973 3
a2975 2
	if (1 || (!range_signed_32 (addend)
	    && (alpha_noat_on || targreg == AXP_REG_AT)))
d3271 1
a3271 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3275 1
a3275 1
      reloc = &tok[ntok-1];
d3336 1
a3336 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3338 1
a3338 1
      const expressionS *reloc_exp = &tok[ntok-1];
d3370 1
a3370 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3374 1
a3374 1
      reloc = &tok[ntok-1];
d3461 1
a3461 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3466 1
a3466 1
	  const struct alpha_reloc_op_tag *r = &alpha_reloc_op[ reloc->X_md ];
d3546 1
a3546 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3548 1
a3548 1
	  const expressionS *reloc_exp = &tok[ntok-1];
d3625 1
a3625 1
  set_tok_const (newtok[1], (1<<lgsize)-1);
d3674 1
a3674 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3676 1
a3676 1
      const expressionS *reloc_exp = &tok[ntok-1];
d3775 1
a3775 1
  set_tok_const (newtok[1], (1 << lgsize)-1);
d3826 1
a3826 1
  set_tok_const (newtok[1], (1 << lgsize)-1);
d3849 1
a3849 1
      if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3851 1
a3851 1
	  const expressionS *reloc_exp = &tok[ntok-1];
d3908 1
a3908 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3910 1
a3910 1
      const expressionS *reloc_exp = &tok[ntok-1];
d4018 1
a4018 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d4020 1
a4020 1
      const expressionS *reloc_exp = &tok[ntok-1];
d4125 1
a4125 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d4127 1
a4127 1
      const expressionS *reloc_exp = &tok[ntok-1];
d4202 1
a4202 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d4204 1
a4204 1
      const expressionS *reloc_exp = &tok[ntok-1];
d4513 1
a4513 1
	        = symbol_new ("L0\001", now_seg, frag_now_fix (), frag_now);
d4586 1
a4586 1
static char * first_file_directive;
d4633 1
a4633 1
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS|SEC_READONLY);
d4641 1
a4641 1
          input_line_pointer = first_file_directive;
d4689 1
a4689 1
  static char *section_name[EVAX_SECTION_COUNT+1] =
d4869 1
a4869 2
  *(p+1) = PDSC_S_M_NATIVE
    | PDSC_S_M_NO_JACKET;
d4874 2
a4875 2
      *(p+2) = 0;
      *(p+3) = 0;
d4878 2
a4879 2
      *(p+2) = alpha_evax_proc.fp_save;
      *(p+3) = alpha_evax_proc.ra_save;
d4882 1
a4882 1
      md_number_to_chars (p+2, (valueT) alpha_evax_proc.rsa_offset, 2);
d4888 2
a4889 2
  *(p+4) = 0;
  *(p+5) = alpha_evax_proc.type & 0x0f;
d4892 1
a4892 1
  md_number_to_chars (p+6, (valueT) 0, 2);
d4894 1
a4894 1
  fix_new_exp (frag_now, p-frag_now->fr_literal+8, 8, &exp, 0, BFD_RELOC_64);
d4908 1
a4908 1
  md_number_to_chars (p+4, (valueT) 0, 2);
d4911 1
a4911 1
  md_number_to_chars (p+6, alpha_evax_proc.prologue, 2);
d4925 1
a4925 1
  md_number_to_chars (p+4, alpha_evax_proc.fmask, 4);
d4965 1
a4965 1
  fix_new_exp (frag_now, p-frag_now->fr_literal, 8, &exp, 0, BFD_RELOC_64);
d5167 1
a5167 1
  fix_new_exp (frag_now, p-frag_now->fr_literal, 4,
a5446 1

a5447 1

d5480 1
a5480 2
const pseudo_typeS md_pseudo_table[] =
{
a5586 1

d5634 2
a5635 1
  alpha_gp_value = 0; alpha_gp_value--;
@


1.20
log
@2001-01-18  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
@
text
@d2171 1
a2171 1
      *pcpumatch = got_cpu_match;
d2504 3
a2506 2
      else switch (fixup->reloc)
	{
d2508 19
a2526 19
	  /* These relocation types are only used internally.  */
	case BFD_RELOC_ALPHA_GPDISP_HI16:
	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  size = 2;
	  pcrel = 0;
	  break;
#endif
#ifdef RELOC_OP_P
	  /* and these also are internal only relocations */
	case BFD_RELOC_ALPHA_USER_LITERAL:
	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	case BFD_RELOC_ALPHA_USER_GPDISP:
	case BFD_RELOC_ALPHA_USER_GPRELHIGH:
	case BFD_RELOC_ALPHA_USER_GPRELLOW:
	  size = 2;
	  pcrel = 0;
	  break;
d2529 5
a2533 5
	default:
	  {
	    reloc_howto_type *reloc_howto
	      = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	    assert (reloc_howto);
d2535 5
a2539 2
	    size = bfd_get_reloc_size (reloc_howto);
	    pcrel = reloc_howto->pc_relative;
a2540 3
	  assert (size >= 1 && size <= 4);
	  break;
	}
d2664 1
a2664 1
	        alpha_target_name);
d2858 1
a2858 1
	        return offset;
d3854 1
a3854 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3964 1
a3964 1
          assemble_tokens ("mov", newtok, 2, 1);
d4076 1
a4076 1
          assemble_tokens ("mov", newtok, 2, 1);
d4538 1
a4538 1
        ecoff_directive_fmask (0);
d4540 1
a4540 1
        ecoff_directive_mask (0);
d4574 14
a4587 14
      case 0: /* No PV required.  */
	S_SET_OTHER (sym, STO_ALPHA_NOPV
			  | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
	break;
      case 1: /* Std GP load.  */
	S_SET_OTHER (sym, STO_ALPHA_STD_GPLOAD
			  | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
	break;
      case 2: /* Non-std use of PV.  */
	break;

      default:
	as_bad (_("Invalid argument %d to .prologue."), arg);
	break;
d4873 1
a4873 1
       | ((alpha_evax_proc.framereg == 29) ? PDSC_S_M_BASE_REG_IS_FP : 0);
d4875 1
a4875 1
	   | PDSC_S_M_NO_JACKET;
d4879 13
a4891 13
      case PDSC_S_K_KIND_NULL:
	*(p+2) = 0;
	*(p+3) = 0;
	break;
      case PDSC_S_K_KIND_FP_REGISTER:
	*(p+2) = alpha_evax_proc.fp_save;
	*(p+3) = alpha_evax_proc.ra_save;
	break;
      case PDSC_S_K_KIND_FP_STACK:
	md_number_to_chars (p+2, (valueT) alpha_evax_proc.rsa_offset, 2);
	break;
      default:		/* impossible */
	break;
d5444 1
a5444 1
        alpha_target_name = p->name, alpha_target = p->flags;
d5461 2
a5462 2
    FILE *f;
    const expressionS *exp;
d5466 15
a5480 15
      case O_cpregister:
	putc (',', f);
	/* FALLTHRU */
      case O_pregister:
	putc ('(', f);
	{
	  expressionS nexp = *exp;
	  nexp.X_op = O_register;
	  print_expr (f, &nexp);
	}
	putc (')', f);
	break;
      default:
	print_expr (f, exp);
	break;
d5716 2
a5717 2
	0x1f, 0x04, 0xff, 0x47,
	0x00, 0x00, 0xe0, 0x2f
@


1.19
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d152 4
a155 4
#define range_signed_16(x)	((offsetT) (x) >= -(offsetT)0x8000 &&	\
				 (offsetT) (x) <=  (offsetT)0x7FFF)
#define range_signed_32(x)	((offsetT) (x) >= -(offsetT)0x80000000 && \
				 (offsetT) (x) <=  (offsetT)0x7FFFFFFF)
d173 1
a173 1
#define set_tok_reg(t, r)	(memset(&(t), 0, sizeof (t)),		\
d176 1
a176 1
#define set_tok_preg(t, r)	(memset(&(t), 0, sizeof (t)),		\
d179 1
a179 1
#define set_tok_cpreg(t, r)	(memset(&(t), 0, sizeof (t)),		\
d182 1
a182 1
#define set_tok_freg(t, r)	(memset(&(t), 0, sizeof (t)),		\
d185 1
a185 1
#define set_tok_sym(t, s, a)	(memset(&(t), 0, sizeof (t)),		\
d189 1
a189 1
#define set_tok_const(t, n)	(memset(&(t), 0, sizeof (t)),		\
d481 1
a481 1
		  : (int) (op) - (int)O_literal) ]
d641 1
a641 1
  { "ldb",	emit_ldX, (PTR)0,
d643 1
a643 1
  { "ldbu",	emit_ldXu, (PTR)0,
d645 1
a645 1
  { "ldw",	emit_ldX, (PTR)1,
d647 1
a647 1
  { "ldwu",	emit_ldXu, (PTR)1,
d650 1
a650 1
  { "uldw",	emit_uldX, (PTR)1,
d652 1
a652 1
  { "uldwu",	emit_uldXu, (PTR)1,
d654 1
a654 1
  { "uldl",	emit_uldX, (PTR)2,
d656 1
a656 1
  { "uldlu",	emit_uldXu, (PTR)2,
d658 1
a658 1
  { "uldq",	emit_uldXu, (PTR)3,
d702 1
a702 1
  { "stb",	emit_stX, (PTR)0,
d704 1
a704 1
  { "stw",	emit_stX, (PTR)1,
d706 1
a706 1
  { "ustw",	emit_ustX, (PTR)1,
d708 1
a708 1
  { "ustl",	emit_ustX, (PTR)2,
d710 1
a710 1
  { "ustq",	emit_ustX, (PTR)3,
d723 1
a723 1
  { "sextb",	emit_sextX, (PTR)0,
d727 1
a727 1
  { "sextw",	emit_sextX, (PTR)1,
d850 1
a850 1
	  (void)hash_insert(alpha_opcode_hash, p, (PTR)&alpha_opcodes[i]);
d885 2
a886 2
      alpha_register_table[i] = symbol_create(name, reg_section, i,
					      &zero_address_frag);
d892 2
a893 2
      alpha_register_table[i] = symbol_create(name, reg_section, i,
					      &zero_address_frag);
d917 3
a919 3
      segT sec = subseg_new(".mdebug", (subsegT)0);
      bfd_set_section_flags(stdoutput, sec, SEC_HAS_CONTENTS|SEC_READONLY);
      bfd_set_section_alignment(stdoutput, sec, 3);
d923 1
a923 1
  subseg_set(text_section, 0);
d927 1
a927 1
  alpha_literal_hash = hash_new();
d970 2
a971 2
  int align = bfd_get_section_alignment(stdoutput, seg);
  valueT mask = ((valueT)1 << align) - 1;
d1066 1
a1066 1
      g_switch_value = atoi(arg);
d1073 1
a1073 1
	  if (strcmp(arg, p->name) == 0)
d1078 1
a1078 1
	as_warn(_("Unknown CPU identifier `%s'"), arg);
d1122 1
a1122 1
  fputs(_("\
d1249 1
a1249 1
	  image = bfd_getl32(fixpos);
d1258 1
a1258 1
	  image = bfd_getl32(fixpos);
d1304 1
a1304 1
	if ((int)fixP->fx_r_type >= 0)
d1308 2
a1309 2
	assert (-(int)fixP->fx_r_type < (int)alpha_num_operands);
	operand = &alpha_operands[-(int)fixP->fx_r_type];
d1320 3
a1322 3
	image = bfd_getl32(fixpos);
	image = insert_operand(image, operand, (offsetT)value,
			       fixP->fx_file, fixP->fx_line);
d1331 2
a1332 2
      as_warn_where(fixP->fx_file, fixP->fx_line,
		    _("type %d reloc done?\n"), (int)fixP->fx_r_type);
d1337 1
a1337 1
  md_number_to_chars(fixpos, image, 4);
d1349 1
a1349 1
md_undefined_symbol(name)
d1365 1
a1365 1
	  if (!isdigit(*++name))
d1373 1
a1373 1
	  else if (name[0] != '0' && isdigit(name[1]) && name[2] == '\0')
d1383 1
a1383 1
	    as_warn(_("Used $at without \".set noat\""));
d1390 1
a1390 1
		as_warn(_("Used $at without \".set noat\""));
d1480 1
a1480 1
      assert((int)f->fx_r_type < 0 && -(int)f->fx_r_type < (int)alpha_num_operands);
d1542 2
a1543 2
      assert ((int)f->fx_r_type < 0
	      && - (int)f->fx_r_type < (int)alpha_num_operands);
d1566 1
a1566 1
  assert ((int)fixp->fx_r_type > 0);
d1602 1
a1602 1
	  && !S_IS_COMMON(fixp->fx_addsy))
d1629 1
a1629 1
      *strchr(s, '\0') = c;
d1717 1
a1717 1
      fixp->fx_next = (fixS *)0;
d1730 1
a1730 1
		   (long)fixp,
d1745 1
a1745 1
		   (long)fixp,
d1763 1
a1763 1
		   (long)fixp,
d1766 1
a1766 1
		   (long)fixp->tc_fix_data.next_lituse);
d1799 1
a1799 1
		       lituse != (fixS *)0;
d1896 1
a1896 1
	       (int)t->X_add_number);
d2073 1
a2073 1
find_opcode_match(first_opcode, tok, pntok, pcpumatch)
d2115 1
a2115 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2120 1
a2120 1
		  || !is_fpr_num(tok[tokidx].X_add_number))
d2125 1
a2125 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2130 1
a2130 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2168 1
a2168 1
	 && !strcmp(opcode->name, first_opcode->name));
d2180 1
a2180 1
find_macro_match(first_macro, tok, pntok)
d2207 1
a2207 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2215 1
a2215 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2223 1
a2223 1
		  && is_ir_num(tok[tokidx].X_add_number))
d2230 1
a2230 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2238 1
a2238 1
		  || !is_fpr_num(tok[tokidx].X_add_number))
d2313 1
a2313 1
	 && !strcmp(macro->name, first_macro->name));
d2321 1
a2321 1
insert_operand(insn, operand, val, file, line)
d2349 1
a2349 1
	  sprint_value(buf, val);
d2351 1
a2351 1
	    as_warn_where(file, line, err, buf, min, max);
d2353 1
a2353 1
	    as_warn(err, buf, min, max);
d2377 1
a2377 1
assemble_insn(opcode, tok, ntok, insn)
d2393 1
a2393 1
      const expressionS *t = (const expressionS *)0;
d2398 1
a2398 1
	  image = insert_operand(image, operand, 0, NULL, 0);
d2432 2
a2433 2
	  image = insert_operand(image, operand, regno(t->X_add_number),
				 NULL, 0);
d2437 1
a2437 1
	  image = insert_operand(image, operand, t->X_add_number, NULL, 0);
d2445 1
a2445 1
	      as_fatal(_("too many fixups"));
d2488 1
a2488 1
      const struct alpha_operand *operand = (const struct alpha_operand *)0;
d2498 1
a2498 1
      if ((int)fixup->reloc < 0)
d2500 1
a2500 1
	  operand = &alpha_operands[-(int)fixup->reloc];
d2577 1
a2577 1
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR)info);
d2608 1
a2608 1
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR)info);
d2623 1
a2623 1
	  if ((int)fixup->reloc < 0)
d2640 1
a2640 1
assemble_tokens_to_insn(opname, tok, ntok, insn)
d2707 1
a2707 1
	      (int)reloc_exp->X_add_number, opname);
d2774 1
a2774 1
	      (int)reloc_exp->X_add_number, "ldgp");
d2956 1
a2956 1
	assert (explicit_reloc == (const expressionS *)0);
d3012 1
a3012 1
	assert (explicit_reloc == (const expressionS *)0);
d3051 1
a3051 1
	emit_insn(&insn);
d3071 1
a3071 1
      assert (explicit_reloc == (const expressionS *)0);
d3078 1
a3078 1
      assert (explicit_reloc == (const expressionS *)0);
d3272 1
a3272 1
  const expressionS *reloc = (const expressionS *)0;
d3285 1
a3285 1
		  (int)reloc->X_add_number, (const char *)opname);
d3287 1
a3287 1
	  reloc = (const expressionS *)0;
d3301 1
a3301 1
	      || !is_ir_num(tok[0].X_add_number)
d3304 1
a3304 1
	      || !is_ir_num(tok[2].X_add_number))
d3309 1
a3309 1
	      reloc = (const expressionS *)0;
d3345 1
a3345 1
	      (int)reloc_exp->X_add_number, "ldah");
d3372 1
a3372 1
  const expressionS *reloc = (const expressionS *)0;
d3386 1
a3386 1
	  if (strcmp ((const char *)opname, "ldq") == 0)
d3397 1
a3397 1
		  (int)reloc->X_add_number, (const char *)opname);
d3408 1
a3408 1
			    &newtok[1], (const expressionS *)0);
d3413 1
a3413 1
  assemble_tokens_to_insn ((const char *)opname, newtok, 3, &insn);
d3463 1
a3463 1
  const expressionS *reloc = (const expressionS *)0;
d3472 1
a3472 1
		  (int)reloc->X_add_number, (const char *)opname);
d3482 1
a3482 1
  if (tok[1].X_op != O_constant || !range_signed_16(tok[1].X_add_number))
d3488 1
a3488 1
				(const expressionS *)0);
d3499 1
a3499 1
  assemble_tokens_to_insn ((const char *)opname, newtok, 3, &insn);
d3544 1
a3544 1
    emit_ir_load (tok, ntok, ldXu_op[(long)vlgsize]);
d3557 1
a3557 1
		  (int)reloc_exp->X_add_number, "ldbu/ldwu");
d3582 1
a3582 1
      assemble_tokens (extXl_op[(long)vlgsize], newtok, 3, 1);
d3595 1
a3595 1
  assemble_tokens (sextX_op[(long)vlgsize], tok, 1, 1);
d3607 1
a3607 1
  long lgsize = (long)vlgsize;
d3664 1
a3664 1
  assemble_tokens (sextX_op[(long)vlgsize], tok, 1, 1);
d3683 1
a3683 1
	      (int)reloc_exp->X_add_number, "ldil");
d3702 1
a3702 1
  int lgsize = (int) (long)vlgsize;
d3711 1
a3711 1
	as_bad(_("macro requires $at register while noat in effect"));
d3760 1
a3760 1
  int lgsize = (int) (long)vlgsize;
d3843 1
a3843 1
  long lgsize = (long)vlgsize;
d3860 1
a3860 1
		  (int)reloc_exp->X_add_number, "setxt");
d3917 1
a3917 1
	      (int)reloc_exp->X_add_number, (char char *)symname);
d3974 1
a3974 1
  sym = symbol_find_or_make ((const char *)symname);
d4027 1
a4027 1
	      (int)reloc_exp->X_add_number, (const char *)symname);
d4040 1
a4040 1
  sym = symbol_find_or_make ((const char *)symname);
d4134 1
a4134 1
	      (int)reloc_exp->X_add_number, opname);
d4156 1
a4156 1
				(const expressionS *)0);
d4201 1
a4201 1
  const char *opname = (const char *)vopname;
d4211 1
a4211 1
	      (int)reloc_exp->X_add_number, opname);
d4234 1
a4234 1
    set_tok_const (newtok[2], strcmp(opname, "ret") == 0);
d4636 3
a4638 3
      segT sec = subseg_new(".mdebug", 0);
      bfd_set_section_flags(stdoutput, sec, SEC_HAS_CONTENTS|SEC_READONLY);
      bfd_set_section_alignment(stdoutput, sec, 3);
d4839 1
a4839 1
  if (strncmp(name, "stack", 5) == 0)
d4843 1
a4843 1
  else if (strncmp(name, "reg", 3) == 0)
d4847 1
a4847 1
  else if (strncmp(name, "null", 4) == 0)
d4887 1
a4887 1
	md_number_to_chars (p+2, (valueT)alpha_evax_proc.rsa_offset, 2);
d4897 1
a4897 1
  md_number_to_chars (p+6, (valueT)0, 2);
d4911 1
a4911 1
  md_number_to_chars (p, (valueT)alpha_evax_proc.framesize, 4);
d4913 1
a4913 1
  md_number_to_chars (p+4, (valueT)0, 2);
d5056 1
a5056 1
      (void)get_absolute_expression ();
d5139 1
a5139 1
      e.X_add_symbol = section_symbol(absolute_section);
d5441 1
a5441 1
    if (strcmp(name, p->name) == 0)
d5446 1
a5446 1
  as_warn("Unknown CPU identifier `%s'", name);
d5459 1
a5459 1
alpha_print_token(f, exp)
@


1.18
log
@2001-01-03  Philip Blundell  <pb@@futuretv.com>

	* config/tc-alpha.c (alpha_force_relocation): Handle vtable
	relocs.
	(alpha_fix_adjustable): Likewise.
	(md_apply_fix): Likewise.
@
text
@d5709 1
a5709 1
void 
@


1.17
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93-98, 1999, 2000 Free Software Foundation, Inc.
d1296 4
d1469 2
d1530 2
@


1.16
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d5676 2
a5677 21
      if (n > 2
	  && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
	{
	  static char const unop[4] = { 0x00, 0x00, 0xe0, 0x2f };
	  static char const nopunop[8] = {
		0x1f, 0x04, 0xff, 0x47,
		0x00, 0x00, 0xe0, 0x2f
	  };

	  /* First, make sure we're on a four-byte boundary, in case
	     someone has been putting .byte values into the text
	     section.  The DEC assembler silently fills with unaligned
	     no-op instructions.  This will zero-fill, then nop-fill
	     with proper alignment.  */
	  if (alpha_current_align < 2)
	    frag_align (2, 0, 0);
	  if (alpha_current_align < 3)
	    frag_align_pattern (3, unop, sizeof unop, 0);
	  if (n > 3)
	    frag_align_pattern (n, nopunop, sizeof nopunop, 0);
	}
d5694 1
a5694 1
  /* ??? if alpha_flag_relax && force && elf, record the requested alignment
d5696 45
@


1.15
log
@        * dwarf2dbg.c (dwarf2_gen_line_info): Early out for no line number.
        * config/obj-elf.h (ECOFF_DEBUGGING) [TC_ALPHA]: Adjust for
        tri-state definition of alpha_flag_mdebug.
        * config/tc-alpha.c (alpha_flag_mdebug): Init to -1.
        (s_alpha_file): Store first .file directive.
        (s_alpha_stab): New.
        (md_pseudo_table): Add stabs and stabn.
@
text
@d148 1
a148 1
	(((offsetT)(x) >> 15) == 0 || ((offsetT)(x) >> 15) == -1)
d150 1
a150 1
	(((offsetT)(x) >> 31) == 0 || ((offsetT)(x) >> 31) == -1)
d152 4
a155 4
#define range_signed_16(x)	((offsetT)(x) >= -(offsetT)0x8000 &&	\
				 (offsetT)(x) <=  (offsetT)0x7FFF)
#define range_signed_32(x)	((offsetT)(x) >= -(offsetT)0x80000000 && \
				 (offsetT)(x) <=  (offsetT)0x7FFFFFFF)
d163 2
a164 2
#define sign_extend_16(x)	((short)(x))
#define sign_extend_32(x)	((int)(x))
d166 2
a167 2
#define sign_extend_16(x)	((offsetT)(((x) & 0xFFFF) ^ 0x8000) - 0x8000)
#define sign_extend_32(x)	((offsetT)(((x) & 0xFFFFFFFF) \
d173 1
a173 1
#define set_tok_reg(t, r)	(memset(&(t), 0, sizeof(t)),		\
d176 1
a176 1
#define set_tok_preg(t, r)	(memset(&(t), 0, sizeof(t)),		\
d179 1
a179 1
#define set_tok_cpreg(t, r)	(memset(&(t), 0, sizeof(t)),		\
d182 1
a182 1
#define set_tok_freg(t, r)	(memset(&(t), 0, sizeof(t)),		\
d185 1
a185 1
#define set_tok_sym(t, s, a)	(memset(&(t), 0, sizeof(t)),		\
d189 1
a189 1
#define set_tok_const(t, n)	(memset(&(t), 0, sizeof(t)),		\
d323 1
a323 1
size_t md_longopts_size = sizeof(md_longopts);
d481 1
a481 1
		  : (int)(op) - (int)O_literal) ]
d553 1
a553 1
  = sizeof(alpha_reloc_op) / sizeof(*alpha_reloc_op);
d559 1
a559 1
#define ALPHA_RELOC_SEQUENCE_OK(X) ((X) > 0 && ((unsigned)(X)) == (X))
d807 1
a807 1
  = sizeof(alpha_macros) / sizeof(*alpha_macros);
d884 1
a884 1
      sprintf(name, "$%d", i);
d891 1
a891 1
      sprintf(name, "$f%d", i-32);
d2145 1
a2145 1
	      abort();
d2413 1
a2413 1
	      abort();
d3172 1
a3172 1
		   sizeof(struct alpha_fixup) * insn.nfixups);
d3429 1
a3429 1
		   sizeof(struct alpha_fixup) * insn.nfixups);
d3515 1
a3515 1
		   sizeof(struct alpha_fixup) * insn.nfixups);
d3680 1
a3680 1
  memcpy (newtok, tok, sizeof(newtok));
d3694 1
a3694 1
  int lgsize = (int)(long)vlgsize;
d3752 1
a3752 1
  int lgsize = (int)(long)vlgsize;
d4172 1
a4172 1
		   sizeof(struct alpha_fixup) * insn.nfixups);
d4663 1
a4663 1
  assert (which >= 0 && which < (int)(sizeof(fns)/sizeof(*fns)));
d4666 1
a4666 1
    (*fns[which])(0);
d5137 1
a5137 1
      abort();
@


1.14
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d251 1
d439 1
a439 1
int alpha_flag_mdebug = 1;
d4582 2
d4588 17
d4622 27
d5524 2
@


1.13
log
@	* elf64-alpha.c (elf64_alpha_relax_opt_call): Only check bits used
	by STO_ALPHA constants.

	* config/tc-alpha.c (s_alpha_prologue): Preserve visibility bits.
@
text
@d61 1
d249 2
d399 1
a400 1
#ifdef OBJ_ELF
d1677 1
a1677 1
     bfd *abfd;
d1679 1
a1679 1
     PTR ptr;
d2472 4
d3297 2
a3298 2
	      as_bad (_("bad instruction format for lda !%s!%d"), r->name,
		      reloc->X_add_number);
d4582 20
a4610 1
    ecoff_directive_file,
a4613 1
    ecoff_directive_loc,
d5475 2
d5483 3
a5485 5
  {"file", s_alpha_coff_wrapper, 5},
  {"scl", s_alpha_coff_wrapper, 6},
  {"tag", s_alpha_coff_wrapper, 7},
  {"val", s_alpha_coff_wrapper, 8},
  {"loc", s_alpha_coff_wrapper, 9},
@


1.12
log
@2000-09-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-a29k.c: Fix formatting.
	* config/tc-alpha.c: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-tic80.h: Likewise.
@
text
@d4558 2
a4559 1
	S_SET_OTHER (sym, STO_ALPHA_NOPV);
d4562 2
a4563 1
	S_SET_OTHER (sym, STO_ALPHA_STD_GPLOAD);
@


1.11
log
@Fix comments.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93-98, 1999 Free Software Foundation, Inc.
d111 1
a111 1
/* Extra expression types. */
a129 1

d378 1
a378 1
/* Symbols referring to said sections. */
d582 1
a582 1
     This supports usage under DU 4.0b that does ".arch ev4", and 
d1080 1
a1080 1
    case '+':			/* For g++.  Hash any name > 63 chars long. */
d2004 1
a2004 1
	    /* First try for parenthesized register ... */
d2491 1
a2491 1
	  /* These relocation types are only used internally. */
d3060 1
a3060 1
	 absolute value and that that value will fit in 16 bits. */
d4311 1
a4311 1
      input_line_pointer++;      
d4326 1
a4326 1
    { 
d4345 1
a4345 1
#ifdef OBJ_EVAX 
d4569 1
a4569 1
    }  
d4602 1
a4602 1
  
d4604 1
a4604 1
  
a4627 1

a4664 1

a4852 1

a4892 1

a4920 1

a4948 1

a4959 1

a4980 1

a5014 1

@


1.10
log
@* config/tc-alpha.c (md_undefined_symbol): Properly understand that $at
is the integer register $r28, vs. both $r28 and the floating point
register $f28.

This quiets a bogus warning about needing ".set noat".

Approved by:	Nick Clifton <nickc@@cygnus.com>
		Message-Id: <200006081749.KAA12558@@elmo.cygnus.com>
@
text
@d974 2
a975 2
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP.  An error message is
@


1.9
log
@	* config/tc-alpha.c (md_assemble): Accept `1' and `9' in an
	opcode, for the instruction `pal19'.  From Andrea Arcangeli
	<andrea@@suse.de>.
@
text
@d1375 1
a1375 1
	  if (!alpha_noat_on && num == AXP_REG_AT)
@


1.9.2.1
log
@* config/tc-alpha.c (md_undefined_symbol): Properly understand that $at
is the integer register $r28, vs. both $r28 and the floating point
register $f28.

This quiets a bogus warning about needing ".set noat".

Approved by:  Philip Blundell <pb@@tazenda.demon.co.uk>
              Message-Id: <E13KpFp-0000sK-00@@kings-cross.london.uk.eu.org>
@
text
@d1375 1
a1375 1
	  if (!alpha_noat_on && (num + is_float) == AXP_REG_AT)
@


1.8
log
@Add support for !literal and !lituse_base
@
text
@d940 1
a940 1
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/468");
@


1.7
log
@        * config/tc-alpha.c (alpha_align): Check, don't assert, that
        the previous label was in the current section before playing
        with auto-alignment.
@
text
@d54 1
d68 3
d85 1
d90 11
a100 1
  MACRO_EOA = 1, MACRO_IR, MACRO_PIR, MACRO_CPIR, MACRO_FPR, MACRO_EXP
d116 15
d213 2
a214 1
  PARAMS ((int, const expressionS *, int *, expressionS *));
d269 4
d470 104
d615 1
a615 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d620 1
a620 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d622 1
a622 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d624 1
a624 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d626 1
a626 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d628 1
a628 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d630 1
a630 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d632 1
a632 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d634 1
a634 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d636 1
a636 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d639 1
a639 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d641 1
a641 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d643 1
a643 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d645 1
a645 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d648 1
a648 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d650 1
a650 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d652 1
a652 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d654 1
a654 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d656 1
a656 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d681 1
a681 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d683 1
a683 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d685 1
a685 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d687 1
a687 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d689 1
a689 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d691 1
a691 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d693 1
a693 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d695 1
a695 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d697 1
a697 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d700 1
a700 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d702 1
a702 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d704 1
a704 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d706 1
a706 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d708 1
a708 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d771 4
a774 4
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
d776 4
a779 4
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
d921 5
d950 3
a952 1
      as_bad (_("syntax error"));
d1280 13
d1453 9
d1503 3
d1513 8
d1648 244
d1903 10
d1928 66
d2024 1
d2040 5
d2049 7
a2055 1
  return -1;
d2193 1
d2200 2
d2208 9
d2223 2
d2232 1
d2243 9
d2260 32
d2477 4
d2489 2
d2492 19
a2510 6
      /* These relocation types are only used internally. */
      else if (fixup->reloc == BFD_RELOC_ALPHA_GPDISP_HI16
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_LO16)
	{
	  size = 2, pcrel = 0;
	}
a2511 5
      else
	{
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	  assert (reloc_howto);
d2513 11
a2523 2
	  size = bfd_get_reloc_size (reloc_howto);
	  pcrel = reloc_howto->pc_relative;
a2524 1
      assert (size >= 1 && size <= 4);
d2529 2
a2530 1
      /* Turn off complaints that the addend is too large for some fixups */
d2544 63
d2686 11
d2753 11
d2877 3
d2884 1
a2884 1
load_expression (targreg, exp, pbasereg, poffset)
d2889 1
d2941 1
d2979 12
a2990 1
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
d2997 1
d3056 1
d3063 1
d3171 1
a3171 1
      insn.fixups[0].exp.X_add_number = 1;
d3251 1
a3251 1
emit_lda (tok, ntok, unused)
d3254 1
a3254 1
     const PTR unused ATTRIBUTE_UNUSED;
d3257 47
d3310 1
a3310 1
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL);
d3324 11
d3356 31
d3393 1
a3393 1
			    &newtok[1]);
d3400 16
d3428 1
a3428 1
      insn.fixups[0].exp.X_add_number = 1;
d3447 15
d3472 2
a3473 1
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1]);
d3486 16
d3514 1
a3514 1
      insn.fixups[0].exp.X_add_number = 1;
d3534 13
d3662 11
d3837 13
d3896 11
d4006 11
d4113 11
d4140 2
a4141 1
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL);
d4171 1
a4171 1
      insn.fixups[0].exp.X_add_number = 3;
d4189 11
@


1.6
log
@Add md expression support; Cleanup alpha warnings
@
text
@d4759 1
a4759 1
  if (label != NULL)
a4760 1
      assert (S_GET_SEGMENT (label) == now_seg);
d4765 1
a4765 1
  record_alignment(now_seg, n);
@


1.5
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d96 1
a96 2
/* Two extra symbols we want to see in our input.  This is a blatent
   misuse of the expressionS.X_op field.  */
d98 2
a99 3
#define O_pregister  ((operatorT) (O_max+1)) /* O_register, in parentheses */
#define O_cpregister ((operatorT) (O_pregister+1)) /* + a leading comma */
#define O_alpha_max  ((operatorT) (O_cpregister+1))
d468 1
a468 1
  { 0 }
d697 1
a697 1
static const int alpha_num_macros
d714 2
a715 2
    e.X_op = O_alpha_max;
    assert (e.X_op == O_alpha_max);
d825 2
a826 1
  int ntok, opnamelen, trunclen;
d1175 1
a1175 1
	assert (-(int)fixP->fx_r_type < alpha_num_operands);
d1336 1
a1336 1
      assert((int)f->fx_r_type < 0 && -(int)f->fx_r_type < alpha_num_operands);
d1386 1
a1386 1
	      && - (int)f->fx_r_type < alpha_num_operands);
d1397 1
a1397 1
     asection *sec;
d1461 1
a1461 1
     int frame;
d1848 1
a1848 1
      const expressionS *t;
d1869 1
a1869 1
		static const expressionS zero_exp = { 0, 0, 0, O_constant, 1 };
d1871 2
d1939 1
a1939 1
      const struct alpha_operand *operand;
d2109 2
a2110 2
     int ntok;
     const PTR unused;
d2593 1
a2593 1
     const PTR unused;
d2611 2
a2612 2
     int ntok;
     const PTR unused;
d2847 1
a2847 1
     const PTR unused;
d3548 1
a3548 1
     int dummy;
d3592 1
a3592 1
     int dummy;
d3652 1
a3652 1
     int dummy;
d3662 1
a3662 1
     int ignore;
d3710 1
a3710 1
  assert (which >= 0 && which < sizeof(fns)/sizeof(*fns));
d4175 1
a4175 1
     int ignore;
d4270 1
a4270 1
     int is_static;
d4309 1
a4309 1
     int x;
d4346 1
a4346 1
     int ignore;
d4381 1
a4381 1
     int ignore;
d4479 1
a4479 1
     int ignored;
d4723 1
a4723 1
     int force;
@


1.4
log
@        * expr.h (struct expressionS): Revert last change; widen X_op.
        * config/tc-alpha.c (md_begin): Check the field is wide enough.
@
text
@d2184 1
a2184 1
  offset = -basesym->sy_obj;
d3481 1
a3481 1
  know (symbolP->sy_frag == &zero_address_frag);
d3851 2
a3852 1
  alpha_evax_proc.symbol->sy_obj = (valueT)seginfo->literal_pool_size;
d4298 1
a4298 1
  /*  symbolP->sy_other = (signed char) temp; */
@


1.3
log
@        * dwarf2dbg.c (dwarf2_gen_line_info): Mirror the section symbol
        creation logic from obj_elf_create_section.
        * config/obj-elf.c (elf_pseudo_tab): Add pushsection/popsection.
        (section_stack): New.
        (special_sections): Make const.
        (obj_elf_section): Gut and rewrite parsing.
        (obj_elf_change_section): New function broken out of obj_elf_section.
        (obj_elf_parse_section_letters): Likewise.
        (obj_elf_section_word): Likewise.
        (obj_elf_section_type): Likewise.
        (obj_elf_previous): Treat as a toggle.
        (obj_elf_popsection): New.
        * config/tc-ppc.c (ppc_section_word): Take str+len not ptr_str.
        (ppc_section_type): Likewise.
        * config/tc-ppc.h: Likewise.
        * expr.h (struct expressionS): Don't make X_op a bitfield.
        * config/tc-alpha.c: Update for symbol handling changes.
        (md_apply_fix) [case GPREL]: Use now_seg instead of absolute_section.
        (load_expression, emit_ir_load, emit_loadstore, emit_jsrjmp): Likewise.
@
text
@d99 3
a101 2
#define O_pregister	(O_max+1)	/* O_register, but in parentheses */
#define O_cpregister	(O_pregister+1)	/* + a leading comma */
d712 7
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d7 1
a7 1
   Modified by Klaus K"ampf for EVAX (openVMS/Alpha) support.
d1084 1
a1084 1
      fixP->fx_addsy = section_symbol (absolute_section);
a2112 3
  /* We're going to need this symbol in md_apply_fix().  */
  (void) section_symbol (absolute_section);

d2499 2
a2500 1
      insn.fixups[0].exp.X_op = O_constant;
d2651 2
a2652 1
      insn.fixups[0].exp.X_op = O_constant;
d2705 2
a2706 1
      insn.fixups[0].exp.X_op = O_constant;
d3291 2
a3292 1
      insn.fixups[0].exp.X_op = O_constant;
d3462 1
a3462 1
	symbolP->bsym->section = new_seg;
d3771 1
a3771 1
  symbol->bsym->flags |= BSF_FUNCTION;
d3855 2
a3856 1
  alpha_evax_proc.symbol->bsym->udata.p = (PTR)entry_sym->bsym;
d4147 1
a4147 1
	    alpha_flag_hash_long_names, alpha_flag_show_after_trunc);
d4150 1
a4150 1
  s->bsym->flags |= BSF_FILE;
d4154 1
a4154 1
  s->bsym->flags |= BSF_FILE;
@


1.1
log
@Initial revision
@
text
@d1176 1
a1176 1
	    && fixP->fx_addsy->bsym->section != absolute_section)
d1396 2
a1397 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d1439 1
a1439 1
	reloc->addend -= fixp->fx_addsy->bsym->value;
d3561 1
a3561 1
	  sym->bsym->flags |= BSF_FUNCTION;
d3608 4
a3611 3
	      sym->sy_obj.size = (expressionS *) xmalloc (sizeof (expressionS));
	      sym->sy_obj.size->X_op = O_subtract;
	      sym->sy_obj.size->X_add_symbol
d3613 2
a3614 2
	      sym->sy_obj.size->X_op_symbol = sym;
	      sym->sy_obj.size->X_add_number = 0;
d4750 1
a4750 1
      label->sy_frag = frag_now;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

