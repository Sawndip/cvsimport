head	1.127;
access;
symbols
	binutils-2_24-branch:1.127.0.2
	binutils-2_24-branchpoint:1.127
	binutils-2_21_1:1.125
	binutils-2_23_2:1.126
	binutils-2_23_1:1.126
	binutils-2_23:1.126
	binutils-2_23-branch:1.126.0.2
	binutils-2_23-branchpoint:1.126
	binutils-2_22_branch:1.125.0.6
	binutils-2_22:1.125
	binutils-2_22-branch:1.125.0.4
	binutils-2_22-branchpoint:1.125
	binutils-2_21:1.125
	binutils-2_21-branch:1.125.0.2
	binutils-2_21-branchpoint:1.125
	binutils-2_20_1:1.116
	binutils-2_20:1.116
	binutils-arc-20081103-branch:1.104.0.4
	binutils-arc-20081103-branchpoint:1.104
	binutils-2_20-branch:1.116.0.2
	binutils-2_20-branchpoint:1.116
	dje-cgen-play1-branch:1.110.0.2
	dje-cgen-play1-branchpoint:1.110
	arc-20081103-branch:1.104.0.2
	arc-20081103-branchpoint:1.104
	binutils-2_19_1:1.103
	binutils-2_19:1.103
	binutils-2_19-branch:1.103.0.2
	binutils-2_19-branchpoint:1.103
	binutils-2_18:1.86
	binutils-2_18-branch:1.86.0.2
	binutils-2_18-branchpoint:1.86
	binutils-csl-coldfire-4_1-32:1.59.2.1
	binutils-csl-sourcerygxx-4_1-32:1.59.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.59.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.22.2.11
	binutils-csl-coldfire-4_1-30:1.59.2.1
	binutils-csl-sourcerygxx-4_1-30:1.59.2.1
	binutils-csl-coldfire-4_1-28:1.59.2.1
	binutils-csl-sourcerygxx-4_1-29:1.59.2.1
	binutils-csl-sourcerygxx-4_1-28:1.59.2.1
	binutils-csl-arm-2006q3-27:1.59.2.1
	binutils-csl-sourcerygxx-4_1-27:1.59.2.1
	binutils-csl-arm-2006q3-26:1.59.2.1
	binutils-csl-sourcerygxx-4_1-26:1.59.2.1
	binutils-csl-sourcerygxx-4_1-25:1.59.2.1
	binutils-csl-sourcerygxx-4_1-24:1.59.2.1
	binutils-csl-sourcerygxx-4_1-23:1.59.2.1
	binutils-csl-sourcerygxx-4_1-21:1.59.2.1
	binutils-csl-arm-2006q3-21:1.59.2.1
	binutils-csl-sourcerygxx-4_1-22:1.59.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.59.2.1
	binutils-csl-sourcerygxx-4_1-20:1.59.2.1
	binutils-csl-arm-2006q3-19:1.59.2.1
	binutils-csl-sourcerygxx-4_1-19:1.59.2.1
	binutils-csl-sourcerygxx-4_1-18:1.59.2.1
	binutils-csl-renesas-4_1-9:1.59.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.22.2.11
	binutils-csl-renesas-4_1-8:1.59
	binutils-csl-renesas-4_1-7:1.59
	binutils-csl-renesas-4_1-6:1.59
	binutils-csl-sourcerygxx-4_1-17:1.59
	binutils-csl-sourcerygxx-4_1-14:1.59
	binutils-csl-sourcerygxx-4_1-15:1.59
	binutils-csl-sourcerygxx-4_1-13:1.59
	binutils-2_17:1.63.2.1
	binutils-csl-sourcerygxx-4_1-12:1.59
	binutils-csl-sourcerygxx-3_4_4-21:1.59
	binutils-csl-wrs-linux-3_4_4-24:1.22.2.3
	binutils-csl-wrs-linux-3_4_4-23:1.22.2.3
	binutils-csl-sourcerygxx-4_1-9:1.59
	binutils-csl-sourcerygxx-4_1-8:1.59
	binutils-csl-sourcerygxx-4_1-7:1.59
	binutils-csl-arm-2006q1-6:1.59
	binutils-csl-sourcerygxx-4_1-6:1.59
	binutils-csl-wrs-linux-3_4_4-22:1.22.2.3
	binutils-csl-coldfire-4_1-11:1.59
	binutils-csl-sourcerygxx-3_4_4-19:1.59
	binutils-csl-coldfire-4_1-10:1.59
	binutils-csl-sourcerygxx-4_1-5:1.59
	binutils-csl-sourcerygxx-4_1-4:1.59
	binutils-csl-wrs-linux-3_4_4-21:1.22.2.3
	binutils-csl-morpho-4_1-4:1.59
	binutils-csl-sourcerygxx-3_4_4-17:1.59
	binutils-csl-wrs-linux-3_4_4-20:1.22.2.3
	binutils-2_17-branch:1.63.0.2
	binutils-2_17-branchpoint:1.63
	binutils-csl-2_17-branch:1.59.0.2
	binutils-csl-2_17-branchpoint:1.59
	binutils-csl-gxxpro-3_4-branch:1.22.2.11.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.22.2.11
	binutils-2_16_1:1.22.2.11
	binutils-csl-arm-2005q1b:1.22.2.3
	binutils-2_16:1.22.2.11
	binutils-csl-arm-2005q1a:1.22.2.3
	binutils-csl-arm-2005q1-branch:1.22.2.3.0.2
	binutils-csl-arm-2005q1-branchpoint:1.22.2.3
	binutils-2_16-branch:1.22.0.2
	binutils-2_16-branchpoint:1.22
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.10
	binutils-2_15:1.7.6.2
	binutils-2_15-branchpoint:1.7
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.9
	binutils-2_15-branch:1.7.0.6
	cagney_bfdfile-20040213-branch:1.7.0.4
	cagney_bfdfile-20040213-branchpoint:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	csl-arm-2003-q4:1.7
	binutils-2_14:1.1
	binutils-2_14-branch:1.1.0.2
	binutils-2_14-branchpoint:1.1
	binutils_latest_snapshot:1.127;
locks; strict;
comment	@ * @;


1.127
date	2012.11.09.08.29.32;	author hjl;	state Exp;
branches;
next	1.126;

1.126
date	2012.05.17.15.13.16;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2010.02.11.19.08.09;	author sterling;	state Exp;
branches;
next	1.123;

1.123
date	2010.02.11.19.00.21;	author sterling;	state Exp;
branches;
next	1.122;

1.122
date	2010.02.10.20.18.14;	author sterling;	state Exp;
branches;
next	1.121;

1.121
date	2010.02.09.19.36.50;	author sterling;	state Exp;
branches;
next	1.120;

1.120
date	2010.02.08.18.45.05;	author sterling;	state Exp;
branches;
next	1.119;

1.119
date	2010.02.05.18.52.27;	author sterling;	state Exp;
branches;
next	1.118;

1.118
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	2009.09.22.21.47.03;	author sterling;	state Exp;
branches;
next	1.116;

1.116
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2009.08.21.19.35.35;	author sterling;	state Exp;
branches;
next	1.114;

1.114
date	2009.08.20.18.12.21;	author sterling;	state Exp;
branches;
next	1.113;

1.113
date	2009.08.19.16.10.46;	author sterling;	state Exp;
branches;
next	1.112;

1.112
date	2009.08.18.16.42.15;	author sterling;	state Exp;
branches;
next	1.111;

1.111
date	2009.08.18.16.21.47;	author sterling;	state Exp;
branches;
next	1.110;

1.110
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	2009.04.01.21.07.14;	author sterling;	state Exp;
branches;
next	1.108;

1.108
date	2009.01.07.17.41.09;	author sterling;	state Exp;
branches;
next	1.107;

1.107
date	2008.11.21.22.13.31;	author sterling;	state Exp;
branches;
next	1.106;

1.106
date	2008.11.05.00.45.04;	author bwilson;	state Exp;
branches;
next	1.105;

1.105
date	2008.11.04.23.11.02;	author bwilson;	state Exp;
branches;
next	1.104;

1.104
date	2008.09.12.18.53.55;	author bwilson;	state Exp;
branches;
next	1.103;

1.103
date	2008.08.20.23.28.58;	author bwilson;	state Exp;
branches;
next	1.102;

1.102
date	2008.08.08.18.21.26;	author bwilson;	state Exp;
branches;
next	1.101;

1.101
date	2008.05.07.23.13.09;	author bwilson;	state Exp;
branches;
next	1.100;

1.100
date	2008.04.04.23.25.49;	author bwilson;	state Exp;
branches;
next	1.99;

1.99
date	2008.03.03.23.23.41;	author bwilson;	state Exp;
branches;
next	1.98;

1.98
date	2008.02.05.19.39.08;	author bwilson;	state Exp;
branches;
next	1.97;

1.97
date	2008.01.18.19.13.48;	author bwilson;	state Exp;
branches;
next	1.96;

1.96
date	2007.12.20.17.21.07;	author bwilson;	state Exp;
branches;
next	1.95;

1.95
date	2007.12.13.19.03.44;	author bwilson;	state Exp;
branches;
next	1.94;

1.94
date	2007.12.12.21.16.47;	author bwilson;	state Exp;
branches;
next	1.93;

1.93
date	2007.12.11.21.52.39;	author bwilson;	state Exp;
branches;
next	1.92;

1.92
date	2007.12.07.22.52.09;	author bwilson;	state Exp;
branches;
next	1.91;

1.91
date	2007.12.07.01.07.33;	author bwilson;	state Exp;
branches;
next	1.90;

1.90
date	2007.11.19.19.40.55;	author bwilson;	state Exp;
branches;
next	1.89;

1.89
date	2007.11.08.01.40.58;	author bwilson;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.02.00.45.34;	author bwilson;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2007.07.25.17.33.27;	author bwilson;	state Exp;
branches;
next	1.85;

1.85
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.22.18.44.50;	author bwilson;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.19.19.08.37;	author bwilson;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.11.16.53.08;	author bwilson;	state Exp;
branches;
next	1.81;

1.81
date	2007.04.21.13.04.14;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2007.04.02.20.05.47;	author bwilson;	state Exp;
branches;
next	1.79;

1.79
date	2007.03.31.00.09.34;	author bwilson;	state Exp;
branches;
next	1.78;

1.78
date	2007.03.26.23.01.46;	author bwilson;	state Exp;
branches;
next	1.77;

1.77
date	2007.02.03.00.08.22;	author bwilson;	state Exp;
branches;
next	1.76;

1.76
date	2007.02.02.23.59.29;	author bwilson;	state Exp;
branches;
next	1.75;

1.75
date	2007.02.02.23.26.53;	author bwilson;	state Exp;
branches;
next	1.74;

1.74
date	2007.02.01.23.54.59;	author bwilson;	state Exp;
branches;
next	1.73;

1.73
date	2007.02.01.14.12.18;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2006.11.27.23.58.39;	author bwilson;	state Exp;
branches;
next	1.71;

1.71
date	2006.11.27.20.14.52;	author bwilson;	state Exp;
branches;
next	1.70;

1.70
date	2006.08.25.19.59.31;	author bwilson;	state Exp;
branches;
next	1.69;

1.69
date	2006.08.25.00.08.55;	author bwilson;	state Exp;
branches;
next	1.68;

1.68
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.15.17.03.15;	author bwilson;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.03.23.52.15;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.25.16.32.56;	author bwilson;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.63;

1.63
date	2006.04.15.00.04.15;	author bwilson;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2006.04.10.19.00.31;	author bwilson;	state Exp;
branches;
next	1.61;

1.61
date	2006.04.03.19.11.05;	author bwilson;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.21.20.34.38;	author bwilson;	state Exp;
branches;
next	1.59;

1.59
date	2006.03.13.21.46.53;	author bwilson;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2006.03.06.18.02.06;	author bwilson;	state Exp;
branches;
next	1.57;

1.57
date	2006.02.14.00.58.05;	author bwilson;	state Exp;
branches;
next	1.56;

1.56
date	2006.02.10.01.02.12;	author bwilson;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.31.19.36.57;	author bwilson;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.26.05.21.43;	author bwilson;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.30.23.33.59;	author bwilson;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.29.21.04.14;	author bwilson;	state Exp;
branches;
next	1.51;

1.51
date	2005.12.20.19.37.26;	author bwilson;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.20.18.13.32;	author bwilson;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.27.22.16.31;	author bwilson;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.18.23.13.48;	author bwilson;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.17.18.17.08;	author bwilson;	state Exp;
branches;
next	1.46;

1.46
date	2005.09.30.21.58.28;	author bwilson;	state Exp;
branches;
next	1.45;

1.45
date	2005.09.20.18.24.48;	author rth;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.07.18.31.34;	author bwilson;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.20.19.01.56;	author bwilson;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.13.17.35.17;	author bwilson;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.06.21.27.47;	author bwilson;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.05.09.13.04;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.03.17.08.43;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.03.12.02.47;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.22.21.37.31;	author bwilson;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.22.20.21.59;	author bwilson;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.20.15.27.02;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.15.04.15.02;	author bwilson;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.14.22.38.49;	author bwilson;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.11.22.45.37;	author bwilson;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.08.17.26.42;	author bwilson;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.05.23.37.34;	author bwilson;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.05.20.55.40;	author bwilson;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.29.00.26.00;	author bwilson;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.26.00.21.01;	author bwilson;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.21.19.46.01;	author bwilson;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.17.21.49.47;	author bwilson;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.11.00.14.15;	author bwilson;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.03.11.47.57;	author amodra;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2005.01.31.23.18.34;	author bje;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.03.01.00.07;	author bwilson;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.22.19.13.04;	author bwilson;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.12.21.59.12;	author bwilson;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.11.19.05.41;	author bwilson;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.10.22.20.27;	author bwilson;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.05.17.25.34;	author bwilson;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.04.21.52.54;	author bwilson;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.12.23.05.32;	author bwilson;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.12.18.33.15;	author bwilson;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.08.00.22.11;	author bwilson;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.19.10.35.23;	author jakub;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.23.01.37.00;	author bwilson;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.19.22.35.32;	author bwilson;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.19.23.55.06;	author bwilson;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2003.10.14.22.28.28;	author bwilson;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.12.00.00.03;	author bwilson;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.10.00.17.29;	author bwilson;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.09.23.41.43;	author bwilson;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.21.12.07.56;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.01.15.50.29;	author nickc;	state Exp;
branches;
next	;

1.63.2.1
date	2006.04.25.16.34.36;	author bwilson;	state Exp;
branches;
next	;

1.59.2.1
date	2006.08.22.15.08.36;	author jsm28;	state Exp;
branches;
next	;

1.22.2.1
date	2005.03.11.00.16.00;	author bwilson;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2005.03.18.17.37.52;	author bwilson;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2005.03.21.19.55.05;	author bwilson;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2005.03.26.00.28.27;	author bwilson;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2005.03.29.00.51.51;	author bwilson;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2005.04.06.16.56.49;	author bwilson;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2005.04.06.16.59.03;	author bwilson;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2005.04.08.17.36.38;	author bwilson;	state Exp;
branches;
next	1.22.2.9;

1.22.2.9
date	2005.04.11.22.51.52;	author bwilson;	state Exp;
branches;
next	1.22.2.10;

1.22.2.10
date	2005.04.14.22.42.26;	author bwilson;	state Exp;
branches;
next	1.22.2.11;

1.22.2.11
date	2005.04.15.04.24.48;	author bwilson;	state Exp;
branches;
next	;

1.7.6.1
date	2004.03.19.22.43.28;	author bwilson;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2004.03.23.01.42.47;	author bwilson;	state Exp;
branches;
next	;


desc
@@


1.127
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@/* tc-xtensa.c -- Assemble Xtensa instructions.
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "as.h"
#include <limits.h>
#include "sb.h"
#include "safe-ctype.h"
#include "tc-xtensa.h"
#include "subsegs.h"
#include "xtensa-relax.h"
#include "dwarf2dbg.h"
#include "xtensa-istack.h"
#include "struc-symbol.h"
#include "xtensa-config.h"

/* Provide default values for new configuration settings.  */
#ifndef XSHAL_ABI
#define XSHAL_ABI 0
#endif

#ifndef uint32
#define uint32 unsigned int
#endif
#ifndef int32
#define int32 signed int
#endif

/* Notes:

   Naming conventions (used somewhat inconsistently):
      The xtensa_ functions are exported
      The xg_ functions are internal

   We also have a couple of different extensibility mechanisms.
   1) The idiom replacement:
      This is used when a line is first parsed to
      replace an instruction pattern with another instruction
      It is currently limited to replacements of instructions
      with constant operands.
   2) The xtensa-relax.c mechanism that has stronger instruction
      replacement patterns.  When an instruction's immediate field
      does not fit the next instruction sequence is attempted.
      In addition, "narrow" opcodes are supported this way.  */


/* Define characters with special meanings to GAS.  */
const char comment_chars[] = "#";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = ";";
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "rRsSfFdDxXpP";


/* Flags to indicate whether the hardware supports the density and
   absolute literals options.  */

bfd_boolean density_supported = XCHAL_HAVE_DENSITY;
bfd_boolean absolute_literals_supported = XSHAL_USE_ABSOLUTE_LITERALS;

static vliw_insn cur_vinsn;

unsigned xtensa_num_pipe_stages;
unsigned xtensa_fetch_width = XCHAL_INST_FETCH_WIDTH;

static enum debug_info_type xt_saved_debug_type = DEBUG_NONE;

/* Some functions are only valid in the front end.  This variable
   allows us to assert that we haven't crossed over into the
   back end.  */
static bfd_boolean past_xtensa_end = FALSE;

/* Flags for properties of the last instruction in a segment.  */
#define FLAG_IS_A0_WRITER	0x1
#define FLAG_IS_BAD_LOOPEND	0x2


/* We define a special segment names ".literal" to place literals
   into.  The .fini and .init sections are special because they
   contain code that is moved together by the linker.  We give them
   their own special .fini.literal and .init.literal sections.  */

#define LITERAL_SECTION_NAME		xtensa_section_rename (".literal")
#define LIT4_SECTION_NAME		xtensa_section_rename (".lit4")
#define INIT_SECTION_NAME		xtensa_section_rename (".init")
#define FINI_SECTION_NAME		xtensa_section_rename (".fini")


/* This type is used for the directive_stack to keep track of the
   state of the literal collection pools.  If lit_prefix is set, it is
   used to determine the literal section names; otherwise, the literal
   sections are determined based on the current text section.  The
   lit_seg and lit4_seg fields cache these literal sections, with the
   current_text_seg field used a tag to indicate whether the cached
   values are valid.  */

typedef struct lit_state_struct
{
  char *lit_prefix;
  segT current_text_seg;
  segT lit_seg;
  segT lit4_seg;
} lit_state;

static lit_state default_lit_sections;


/* We keep a list of literal segments.  The seg_list type is the node
   for this list.  The literal_head pointer is the head of the list,
   with the literal_head_h dummy node at the start.  */

typedef struct seg_list_struct
{
  struct seg_list_struct *next;
  segT seg;
} seg_list;

static seg_list literal_head_h;
static seg_list *literal_head = &literal_head_h;


/* Lists of symbols.  We keep a list of symbols that label the current
   instruction, so that we can adjust the symbols when inserting alignment
   for various instructions.  We also keep a list of all the symbols on
   literals, so that we can fix up those symbols when the literals are
   later moved into the text sections.  */

typedef struct sym_list_struct
{
  struct sym_list_struct *next;
  symbolS *sym;
} sym_list;

static sym_list *insn_labels = NULL;
static sym_list *free_insn_labels = NULL;
static sym_list *saved_insn_labels = NULL;

static sym_list *literal_syms;


/* Flags to determine whether to prefer const16 or l32r
   if both options are available.  */
int prefer_const16 = 0;
int prefer_l32r = 0;

/* Global flag to indicate when we are emitting literals.  */
int generating_literals = 0;

/* The following PROPERTY table definitions are copied from
   <elf/xtensa.h> and must be kept in sync with the code there.  */

/* Flags in the property tables to specify whether blocks of memory
   are literals, instructions, data, or unreachable.  For
   instructions, blocks that begin loop targets and branch targets are
   designated.  Blocks that do not allow density, instruction
   reordering or transformation are also specified.  Finally, for
   branch targets, branch target alignment priority is included.
   Alignment of the next block is specified in the current block
   and the size of the current block does not include any fill required
   to align to the next block.  */

#define XTENSA_PROP_LITERAL		0x00000001
#define XTENSA_PROP_INSN		0x00000002
#define XTENSA_PROP_DATA		0x00000004
#define XTENSA_PROP_UNREACHABLE		0x00000008
/* Instruction only properties at beginning of code.  */
#define XTENSA_PROP_INSN_LOOP_TARGET	0x00000010
#define XTENSA_PROP_INSN_BRANCH_TARGET	0x00000020
/* Instruction only properties about code.  */
#define XTENSA_PROP_INSN_NO_DENSITY	0x00000040
#define XTENSA_PROP_INSN_NO_REORDER	0x00000080
/* Historically, NO_TRANSFORM was a property of instructions,
   but it should apply to literals under certain circumstances.  */
#define XTENSA_PROP_NO_TRANSFORM	0x00000100

/*  Branch target alignment information.  This transmits information
    to the linker optimization about the priority of aligning a
    particular block for branch target alignment: None, low priority,
    high priority, or required.  These only need to be checked in
    instruction blocks marked as XTENSA_PROP_INSN_BRANCH_TARGET.
    Common usage is

    switch (GET_XTENSA_PROP_BT_ALIGN (flags))
    case XTENSA_PROP_BT_ALIGN_NONE:
    case XTENSA_PROP_BT_ALIGN_LOW:
    case XTENSA_PROP_BT_ALIGN_HIGH:
    case XTENSA_PROP_BT_ALIGN_REQUIRE:
*/
#define XTENSA_PROP_BT_ALIGN_MASK       0x00000600

/* No branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_NONE       0x0
/* Low priority branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_LOW        0x1
/* High priority branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_HIGH       0x2
/* Required branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_REQUIRE    0x3

#define GET_XTENSA_PROP_BT_ALIGN(flag) \
  (((unsigned) ((flag) & (XTENSA_PROP_BT_ALIGN_MASK))) >> 9)
#define SET_XTENSA_PROP_BT_ALIGN(flag, align) \
  (((flag) & (~XTENSA_PROP_BT_ALIGN_MASK)) | \
    (((align) << 9) & XTENSA_PROP_BT_ALIGN_MASK))


/* Alignment is specified in the block BEFORE the one that needs
   alignment.  Up to 5 bits.  Use GET_XTENSA_PROP_ALIGNMENT(flags) to
   get the required alignment specified as a power of 2.  Use
   SET_XTENSA_PROP_ALIGNMENT(flags, pow2) to set the required
   alignment.  Be careful of side effects since the SET will evaluate
   flags twice.  Also, note that the SIZE of a block in the property
   table does not include the alignment size, so the alignment fill
   must be calculated to determine if two blocks are contiguous.
   TEXT_ALIGN is not currently implemented but is a placeholder for a
   possible future implementation.  */

#define XTENSA_PROP_ALIGN		0x00000800

#define XTENSA_PROP_ALIGNMENT_MASK      0x0001f000

#define GET_XTENSA_PROP_ALIGNMENT(flag) \
  (((unsigned) ((flag) & (XTENSA_PROP_ALIGNMENT_MASK))) >> 12)
#define SET_XTENSA_PROP_ALIGNMENT(flag, align) \
  (((flag) & (~XTENSA_PROP_ALIGNMENT_MASK)) | \
    (((align) << 12) & XTENSA_PROP_ALIGNMENT_MASK))

#define XTENSA_PROP_INSN_ABSLIT 0x00020000


/* Structure for saving instruction and alignment per-fragment data
   that will be written to the object file.  This structure is
   equivalent to the actual data that will be written out to the file
   but is easier to use.   We provide a conversion to file flags
   in frag_flags_to_number.  */

typedef struct frag_flags_struct frag_flags;

struct frag_flags_struct
{
  /* is_literal should only be used after xtensa_move_literals.
     If you need to check if you are generating a literal fragment,
     then use the generating_literals global.  */

  unsigned is_literal : 1;
  unsigned is_insn : 1;
  unsigned is_data : 1;
  unsigned is_unreachable : 1;

  /* is_specific_opcode implies no_transform.  */
  unsigned is_no_transform : 1;

  struct
  {
    unsigned is_loop_target : 1;
    unsigned is_branch_target : 1; /* Branch targets have a priority.  */
    unsigned bt_align_priority : 2;

    unsigned is_no_density : 1;
    /* no_longcalls flag does not need to be placed in the object file.  */

    unsigned is_no_reorder : 1;

    /* Uses absolute literal addressing for l32r.  */
    unsigned is_abslit : 1;
  } insn;
  unsigned is_align : 1;
  unsigned alignment : 5;
};


/* Structure for saving information about a block of property data
   for frags that have the same flags.  */
struct xtensa_block_info_struct
{
  segT sec;
  bfd_vma offset;
  size_t size;
  frag_flags flags;
  struct xtensa_block_info_struct *next;
};


/* Structure for saving the current state before emitting literals.  */
typedef struct emit_state_struct
{
  const char *name;
  segT now_seg;
  subsegT now_subseg;
  int generating_literals;
} emit_state;


/* Opcode placement information */

typedef unsigned long long bitfield;
#define bit_is_set(bit, bf)	((bf) & (0x01ll << (bit)))
#define set_bit(bit, bf)	((bf) |= (0x01ll << (bit)))
#define clear_bit(bit, bf)	((bf) &= ~(0x01ll << (bit)))

#define MAX_FORMATS 32

typedef struct op_placement_info_struct
{
  int num_formats;
  /* A number describing how restrictive the issue is for this
     opcode.  For example, an opcode that fits lots of different
     formats has a high freedom, as does an opcode that fits
     only one format but many slots in that format.  The most
     restrictive is the opcode that fits only one slot in one
     format.  */
  int issuef;
  xtensa_format narrowest;
  char narrowest_size;
  char narrowest_slot;

  /* formats is a bitfield with the Nth bit set
     if the opcode fits in the Nth xtensa_format.  */
  bitfield formats;

  /* slots[N]'s Mth bit is set if the op fits in the
     Mth slot of the Nth xtensa_format.  */
  bitfield slots[MAX_FORMATS];

  /* A count of the number of slots in a given format
     an op can fit (i.e., the bitcount of the slot field above).  */
  char slots_in_format[MAX_FORMATS];

} op_placement_info, *op_placement_info_table;

op_placement_info_table op_placement_table;


/* Extra expression types.  */

#define O_pltrel	O_md1	/* like O_symbol but use a PLT reloc */
#define O_hi16		O_md2	/* use high 16 bits of symbolic value */
#define O_lo16		O_md3	/* use low 16 bits of symbolic value */
#define O_pcrel		O_md4	/* value is a PC-relative offset */
#define O_tlsfunc	O_md5	/* TLS_FUNC/TLSDESC_FN relocation */
#define O_tlsarg	O_md6	/* TLS_ARG/TLSDESC_ARG relocation */
#define O_tlscall	O_md7	/* TLS_CALL relocation */
#define O_tpoff		O_md8	/* TPOFF relocation */
#define O_dtpoff	O_md9	/* DTPOFF relocation */

struct suffix_reloc_map
{
  char *suffix;
  int length;
  bfd_reloc_code_real_type reloc;
  unsigned char operator;
};

#define SUFFIX_MAP(str, reloc, op) { str, sizeof (str) - 1, reloc, op }

static struct suffix_reloc_map suffix_relocs[] =
{
  SUFFIX_MAP ("l",	BFD_RELOC_LO16,			O_lo16),
  SUFFIX_MAP ("h",	BFD_RELOC_HI16,			O_hi16),
  SUFFIX_MAP ("plt",	BFD_RELOC_XTENSA_PLT,		O_pltrel),
  SUFFIX_MAP ("pcrel",	BFD_RELOC_32_PCREL,		O_pcrel),
  SUFFIX_MAP ("tlsfunc", BFD_RELOC_XTENSA_TLS_FUNC,	O_tlsfunc),
  SUFFIX_MAP ("tlsarg",	BFD_RELOC_XTENSA_TLS_ARG,	O_tlsarg),
  SUFFIX_MAP ("tlscall", BFD_RELOC_XTENSA_TLS_CALL,	O_tlscall),
  SUFFIX_MAP ("tpoff",	BFD_RELOC_XTENSA_TLS_TPOFF,	O_tpoff),
  SUFFIX_MAP ("dtpoff",	BFD_RELOC_XTENSA_TLS_DTPOFF,	O_dtpoff),
  { (char *) 0, 0,	BFD_RELOC_UNUSED,		0 }
};


/* Directives.  */

typedef enum
{
  directive_none = 0,
  directive_literal,
  directive_density,
  directive_transform,
  directive_freeregs,
  directive_longcalls,
  directive_literal_prefix,
  directive_schedule,
  directive_absolute_literals,
  directive_last_directive
} directiveE;

typedef struct
{
  const char *name;
  bfd_boolean can_be_negated;
} directive_infoS;

const directive_infoS directive_info[] =
{
  { "none",		FALSE },
  { "literal",		FALSE },
  { "density",		TRUE },
  { "transform",	TRUE },
  { "freeregs",		FALSE },
  { "longcalls",	TRUE },
  { "literal_prefix",	FALSE },
  { "schedule",		TRUE },
  { "absolute-literals", TRUE }
};

bfd_boolean directive_state[] =
{
  FALSE,			/* none */
  FALSE,			/* literal */
#if !XCHAL_HAVE_DENSITY
  FALSE,			/* density */
#else
  TRUE,				/* density */
#endif
  TRUE,				/* transform */
  FALSE,			/* freeregs */
  FALSE,			/* longcalls */
  FALSE,			/* literal_prefix */
  FALSE,			/* schedule */
#if XSHAL_USE_ABSOLUTE_LITERALS
  TRUE				/* absolute_literals */
#else
  FALSE				/* absolute_literals */
#endif
};


/* Directive functions.  */

static void xtensa_begin_directive (int);
static void xtensa_end_directive (int);
static void xtensa_literal_prefix (void);
static void xtensa_literal_position (int);
static void xtensa_literal_pseudo (int);
static void xtensa_frequency_pseudo (int);
static void xtensa_elf_cons (int);
static void xtensa_leb128 (int);

/* Parsing and Idiom Translation.  */

static bfd_reloc_code_real_type xtensa_elf_suffix (char **, expressionS *);

/* Various Other Internal Functions.  */

extern bfd_boolean xg_is_single_relaxable_insn (TInsn *, TInsn *, bfd_boolean);
static bfd_boolean xg_build_to_insn (TInsn *, TInsn *, BuildInstr *);
static void xtensa_mark_literal_pool_location (void);
static addressT get_expanded_loop_offset (xtensa_opcode);
static fragS *get_literal_pool_location (segT);
static void set_literal_pool_location (segT, fragS *);
static void xtensa_set_frag_assembly_state (fragS *);
static void finish_vinsn (vliw_insn *);
static bfd_boolean emit_single_op (TInsn *);
static int total_frag_text_expansion (fragS *);

/* Alignment Functions.  */

static int get_text_align_power (unsigned);
static int get_text_align_max_fill_size (int, bfd_boolean, bfd_boolean);
static int branch_align_power (segT);

/* Helpers for xtensa_relax_frag().  */

static long relax_frag_add_nop (fragS *);

/* Accessors for additional per-subsegment information.  */

static unsigned get_last_insn_flags (segT, subsegT);
static void set_last_insn_flags (segT, subsegT, unsigned, bfd_boolean);
static float get_subseg_total_freq (segT, subsegT);
static float get_subseg_target_freq (segT, subsegT);
static void set_subseg_freq (segT, subsegT, float, float);

/* Segment list functions.  */

static void xtensa_move_literals (void);
static void xtensa_reorder_segments (void);
static void xtensa_switch_to_literal_fragment (emit_state *);
static void xtensa_switch_to_non_abs_literal_fragment (emit_state *);
static void xtensa_switch_section_emit_state (emit_state *, segT, subsegT);
static void xtensa_restore_emit_state (emit_state *);
static segT cache_literal_section (bfd_boolean);

/* Import from elf32-xtensa.c in BFD library.  */

extern asection *xtensa_make_property_section (asection *, const char *);

/* op_placement_info functions.  */

static void init_op_placement_info_table (void);
extern bfd_boolean opcode_fits_format_slot (xtensa_opcode, xtensa_format, int);
static int xg_get_single_size (xtensa_opcode);
static xtensa_format xg_get_single_format (xtensa_opcode);
static int xg_get_single_slot (xtensa_opcode);

/* TInsn and IStack functions.  */

static bfd_boolean tinsn_has_symbolic_operands (const TInsn *);
static bfd_boolean tinsn_has_invalid_symbolic_operands (const TInsn *);
static bfd_boolean tinsn_has_complex_operands (const TInsn *);
static bfd_boolean tinsn_to_insnbuf (TInsn *, xtensa_insnbuf);
static bfd_boolean tinsn_check_arguments (const TInsn *);
static void tinsn_from_chars (TInsn *, char *, int);
static void tinsn_immed_from_frag (TInsn *, fragS *, int);
static int get_num_stack_text_bytes (IStack *);
static int get_num_stack_literal_bytes (IStack *);

/* vliw_insn functions.  */

static void xg_init_vinsn (vliw_insn *);
static void xg_copy_vinsn (vliw_insn *, vliw_insn *);
static void xg_clear_vinsn (vliw_insn *);
static bfd_boolean vinsn_has_specific_opcodes (vliw_insn *);
static void xg_free_vinsn (vliw_insn *);
static bfd_boolean vinsn_to_insnbuf
  (vliw_insn *, char *, fragS *, bfd_boolean);
static void vinsn_from_chars (vliw_insn *, char *);

/* Expression Utilities.  */

bfd_boolean expr_is_const (const expressionS *);
offsetT get_expr_const (const expressionS *);
void set_expr_const (expressionS *, offsetT);
bfd_boolean expr_is_register (const expressionS *);
offsetT get_expr_register (const expressionS *);
void set_expr_symbol_offset (expressionS *, symbolS *, offsetT);
bfd_boolean expr_is_equal (expressionS *, expressionS *);
static void copy_expr (expressionS *, const expressionS *);

/* Section renaming.  */

static void build_section_rename (const char *);


/* ISA imported from bfd.  */
extern xtensa_isa xtensa_default_isa;

extern int target_big_endian;

static xtensa_opcode xtensa_addi_opcode;
static xtensa_opcode xtensa_addmi_opcode;
static xtensa_opcode xtensa_call0_opcode;
static xtensa_opcode xtensa_call4_opcode;
static xtensa_opcode xtensa_call8_opcode;
static xtensa_opcode xtensa_call12_opcode;
static xtensa_opcode xtensa_callx0_opcode;
static xtensa_opcode xtensa_callx4_opcode;
static xtensa_opcode xtensa_callx8_opcode;
static xtensa_opcode xtensa_callx12_opcode;
static xtensa_opcode xtensa_const16_opcode;
static xtensa_opcode xtensa_entry_opcode;
static xtensa_opcode xtensa_extui_opcode;
static xtensa_opcode xtensa_movi_opcode;
static xtensa_opcode xtensa_movi_n_opcode;
static xtensa_opcode xtensa_isync_opcode;
static xtensa_opcode xtensa_j_opcode;
static xtensa_opcode xtensa_jx_opcode;
static xtensa_opcode xtensa_l32r_opcode;
static xtensa_opcode xtensa_loop_opcode;
static xtensa_opcode xtensa_loopnez_opcode;
static xtensa_opcode xtensa_loopgtz_opcode;
static xtensa_opcode xtensa_nop_opcode;
static xtensa_opcode xtensa_nop_n_opcode;
static xtensa_opcode xtensa_or_opcode;
static xtensa_opcode xtensa_ret_opcode;
static xtensa_opcode xtensa_ret_n_opcode;
static xtensa_opcode xtensa_retw_opcode;
static xtensa_opcode xtensa_retw_n_opcode;
static xtensa_opcode xtensa_rsr_lcount_opcode;
static xtensa_opcode xtensa_waiti_opcode;
static int config_max_slots = 0;


/* Command-line Options.  */

bfd_boolean use_literal_section = TRUE;
enum flix_level produce_flix = FLIX_ALL;
static bfd_boolean align_targets = TRUE;
static bfd_boolean warn_unaligned_branch_targets = FALSE;
static bfd_boolean has_a0_b_retw = FALSE;
static bfd_boolean workaround_a0_b_retw = FALSE;
static bfd_boolean workaround_b_j_loop_end = FALSE;
static bfd_boolean workaround_short_loop = FALSE;
static bfd_boolean maybe_has_short_loop = FALSE;
static bfd_boolean workaround_close_loop_end = FALSE;
static bfd_boolean maybe_has_close_loop_end = FALSE;
static bfd_boolean enforce_three_byte_loop_align = FALSE;

/* When workaround_short_loops is TRUE, all loops with early exits must
   have at least 3 instructions.  workaround_all_short_loops is a modifier
   to the workaround_short_loop flag.  In addition to the
   workaround_short_loop actions, all straightline loopgtz and loopnez
   must have at least 3 instructions.  */

static bfd_boolean workaround_all_short_loops = FALSE;


static void
xtensa_setup_hw_workarounds (int earliest, int latest)
{
  if (earliest > latest)
    as_fatal (_("illegal range of target hardware versions"));

  /* Enable all workarounds for pre-T1050.0 hardware.  */
  if (earliest < 105000 || latest < 105000)
    {
      workaround_a0_b_retw |= TRUE;
      workaround_b_j_loop_end |= TRUE;
      workaround_short_loop |= TRUE;
      workaround_close_loop_end |= TRUE;
      workaround_all_short_loops |= TRUE;
      enforce_three_byte_loop_align = TRUE;
    }
}


enum
{
  option_density = OPTION_MD_BASE,
  option_no_density,

  option_flix,
  option_no_generate_flix,
  option_no_flix,

  option_relax,
  option_no_relax,

  option_link_relax,
  option_no_link_relax,

  option_generics,
  option_no_generics,

  option_transform,
  option_no_transform,

  option_text_section_literals,
  option_no_text_section_literals,

  option_absolute_literals,
  option_no_absolute_literals,

  option_align_targets,
  option_no_align_targets,

  option_warn_unaligned_targets,

  option_longcalls,
  option_no_longcalls,

  option_workaround_a0_b_retw,
  option_no_workaround_a0_b_retw,

  option_workaround_b_j_loop_end,
  option_no_workaround_b_j_loop_end,

  option_workaround_short_loop,
  option_no_workaround_short_loop,

  option_workaround_all_short_loops,
  option_no_workaround_all_short_loops,

  option_workaround_close_loop_end,
  option_no_workaround_close_loop_end,

  option_no_workarounds,

  option_rename_section_name,

  option_prefer_l32r,
  option_prefer_const16,

  option_target_hardware
};

const char *md_shortopts = "";

struct option md_longopts[] =
{
  { "density", no_argument, NULL, option_density },
  { "no-density", no_argument, NULL, option_no_density },

  { "flix", no_argument, NULL, option_flix },
  { "no-generate-flix", no_argument, NULL, option_no_generate_flix },
  { "no-allow-flix", no_argument, NULL, option_no_flix },

  /* Both "relax" and "generics" are deprecated and treated as equivalent
     to the "transform" option.  */
  { "relax", no_argument, NULL, option_relax },
  { "no-relax", no_argument, NULL, option_no_relax },
  { "generics", no_argument, NULL, option_generics },
  { "no-generics", no_argument, NULL, option_no_generics },

  { "transform", no_argument, NULL, option_transform },
  { "no-transform", no_argument, NULL, option_no_transform },
  { "text-section-literals", no_argument, NULL, option_text_section_literals },
  { "no-text-section-literals", no_argument, NULL,
    option_no_text_section_literals },
  { "absolute-literals", no_argument, NULL, option_absolute_literals },
  { "no-absolute-literals", no_argument, NULL, option_no_absolute_literals },
  /* This option was changed from -align-target to -target-align
     because it conflicted with the "-al" option.  */
  { "target-align", no_argument, NULL, option_align_targets },
  { "no-target-align", no_argument, NULL, option_no_align_targets },
  { "warn-unaligned-targets", no_argument, NULL,
    option_warn_unaligned_targets },
  { "longcalls", no_argument, NULL, option_longcalls },
  { "no-longcalls", no_argument, NULL, option_no_longcalls },

  { "no-workaround-a0-b-retw", no_argument, NULL,
    option_no_workaround_a0_b_retw },
  { "workaround-a0-b-retw", no_argument, NULL, option_workaround_a0_b_retw },

  { "no-workaround-b-j-loop-end", no_argument, NULL,
    option_no_workaround_b_j_loop_end },
  { "workaround-b-j-loop-end", no_argument, NULL,
    option_workaround_b_j_loop_end },

  { "no-workaround-short-loops", no_argument, NULL,
    option_no_workaround_short_loop },
  { "workaround-short-loops", no_argument, NULL,
    option_workaround_short_loop },

  { "no-workaround-all-short-loops", no_argument, NULL,
    option_no_workaround_all_short_loops },
  { "workaround-all-short-loop", no_argument, NULL,
    option_workaround_all_short_loops },

  { "prefer-l32r", no_argument, NULL, option_prefer_l32r },
  { "prefer-const16", no_argument, NULL, option_prefer_const16 },

  { "no-workarounds", no_argument, NULL, option_no_workarounds },

  { "no-workaround-close-loop-end", no_argument, NULL,
    option_no_workaround_close_loop_end },
  { "workaround-close-loop-end", no_argument, NULL,
    option_workaround_close_loop_end },

  { "rename-section", required_argument, NULL, option_rename_section_name },

  { "link-relax", no_argument, NULL, option_link_relax },
  { "no-link-relax", no_argument, NULL, option_no_link_relax },

  { "target-hardware", required_argument, NULL, option_target_hardware },

  { NULL, no_argument, NULL, 0 }
};

size_t md_longopts_size = sizeof md_longopts;


int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case option_density:
      as_warn (_("--density option is ignored"));
      return 1;
    case option_no_density:
      as_warn (_("--no-density option is ignored"));
      return 1;
    case option_link_relax:
      linkrelax = 1;
      return 1;
    case option_no_link_relax:
      linkrelax = 0;
      return 1;
    case option_flix:
      produce_flix = FLIX_ALL;
      return 1;
    case option_no_generate_flix:
      produce_flix = FLIX_NO_GENERATE;
      return 1;
    case option_no_flix:
      produce_flix = FLIX_NONE;
      return 1;
    case option_generics:
      as_warn (_("--generics is deprecated; use --transform instead"));
      return md_parse_option (option_transform, arg);
    case option_no_generics:
      as_warn (_("--no-generics is deprecated; use --no-transform instead"));
      return md_parse_option (option_no_transform, arg);
    case option_relax:
      as_warn (_("--relax is deprecated; use --transform instead"));
      return md_parse_option (option_transform, arg);
    case option_no_relax:
      as_warn (_("--no-relax is deprecated; use --no-transform instead"));
      return md_parse_option (option_no_transform, arg);
    case option_longcalls:
      directive_state[directive_longcalls] = TRUE;
      return 1;
    case option_no_longcalls:
      directive_state[directive_longcalls] = FALSE;
      return 1;
    case option_text_section_literals:
      use_literal_section = FALSE;
      return 1;
    case option_no_text_section_literals:
      use_literal_section = TRUE;
      return 1;
    case option_absolute_literals:
      if (!absolute_literals_supported)
	{
	  as_fatal (_("--absolute-literals option not supported in this Xtensa configuration"));
	  return 0;
	}
      directive_state[directive_absolute_literals] = TRUE;
      return 1;
    case option_no_absolute_literals:
      directive_state[directive_absolute_literals] = FALSE;
      return 1;

    case option_workaround_a0_b_retw:
      workaround_a0_b_retw = TRUE;
      return 1;
    case option_no_workaround_a0_b_retw:
      workaround_a0_b_retw = FALSE;
      return 1;
    case option_workaround_b_j_loop_end:
      workaround_b_j_loop_end = TRUE;
      return 1;
    case option_no_workaround_b_j_loop_end:
      workaround_b_j_loop_end = FALSE;
      return 1;

    case option_workaround_short_loop:
      workaround_short_loop = TRUE;
      return 1;
    case option_no_workaround_short_loop:
      workaround_short_loop = FALSE;
      return 1;

    case option_workaround_all_short_loops:
      workaround_all_short_loops = TRUE;
      return 1;
    case option_no_workaround_all_short_loops:
      workaround_all_short_loops = FALSE;
      return 1;

    case option_workaround_close_loop_end:
      workaround_close_loop_end = TRUE;
      return 1;
    case option_no_workaround_close_loop_end:
      workaround_close_loop_end = FALSE;
      return 1;

    case option_no_workarounds:
      workaround_a0_b_retw = FALSE;
      workaround_b_j_loop_end = FALSE;
      workaround_short_loop = FALSE;
      workaround_all_short_loops = FALSE;
      workaround_close_loop_end = FALSE;
      return 1;

    case option_align_targets:
      align_targets = TRUE;
      return 1;
    case option_no_align_targets:
      align_targets = FALSE;
      return 1;

    case option_warn_unaligned_targets:
      warn_unaligned_branch_targets = TRUE;
      return 1;

    case option_rename_section_name:
      build_section_rename (arg);
      return 1;

    case 'Q':
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
         should be emitted or not.  FIXME: Not implemented.  */
      return 1;

    case option_prefer_l32r:
      if (prefer_const16)
	as_fatal (_("prefer-l32r conflicts with prefer-const16"));
      prefer_l32r = 1;
      return 1;

    case option_prefer_const16:
      if (prefer_l32r)
	as_fatal (_("prefer-const16 conflicts with prefer-l32r"));
      prefer_const16 = 1;
      return 1;

    case option_target_hardware:
      {
	int earliest, latest = 0;
	if (*arg == 0 || *arg == '-')
	  as_fatal (_("invalid target hardware version"));

	earliest = strtol (arg, &arg, 0);

	if (*arg == 0)
	  latest = earliest;
	else if (*arg == '-')
	  {
	    if (*++arg == 0)
	      as_fatal (_("invalid target hardware version"));
	    latest = strtol (arg, &arg, 0);
	  }
	if (*arg != 0)
	  as_fatal (_("invalid target hardware version"));

	xtensa_setup_hw_workarounds (earliest, latest);
	return 1;
      }

    case option_transform:
      /* This option has no affect other than to use the defaults,
	 which are already set.  */
      return 1;

    case option_no_transform:
      /* This option turns off all transformations of any kind.
	 However, because we want to preserve the state of other
	 directives, we only change its own field.  Thus, before
	 you perform any transformation, always check if transform
	 is available.  If you use the functions we provide for this
	 purpose, you will be ok.  */
      directive_state[directive_transform] = FALSE;
      return 1;

    default:
      return 0;
    }
}


void
md_show_usage (FILE *stream)
{
  fputs ("\n\
Xtensa options:\n\
  --[no-]text-section-literals\n\
                          [Do not] put literals in the text section\n\
  --[no-]absolute-literals\n\
                          [Do not] default to use non-PC-relative literals\n\
  --[no-]target-align     [Do not] try to align branch targets\n\
  --[no-]longcalls        [Do not] emit 32-bit call sequences\n\
  --[no-]transform        [Do not] transform instructions\n\
  --flix                  both allow hand-written and generate flix bundles\n\
  --no-generate-flix      allow hand-written but do not generate\n\
                          flix bundles\n\
  --no-allow-flix         neither allow hand-written nor generate\n\
                          flix bundles\n\
  --rename-section old=new Rename section 'old' to 'new'\n", stream);
}


/* Functions related to the list of current label symbols.  */

static void
xtensa_add_insn_label (symbolS *sym)
{
  sym_list *l;

  if (!free_insn_labels)
    l = (sym_list *) xmalloc (sizeof (sym_list));
  else
    {
      l = free_insn_labels;
      free_insn_labels = l->next;
    }

  l->sym = sym;
  l->next = insn_labels;
  insn_labels = l;
}


static void
xtensa_clear_insn_labels (void)
{
  sym_list **pl;

  for (pl = &free_insn_labels; *pl != NULL; pl = &(*pl)->next)
    ;
  *pl = insn_labels;
  insn_labels = NULL;
}


static void
xtensa_move_labels (fragS *new_frag, valueT new_offset)
{
  sym_list *lit;

  for (lit = insn_labels; lit; lit = lit->next)
    {
      symbolS *lit_sym = lit->sym;
      S_SET_VALUE (lit_sym, new_offset);
      symbol_set_frag (lit_sym, new_frag);
    }
}


/* Directive data and functions.  */

typedef struct state_stackS_struct
{
  directiveE directive;
  bfd_boolean negated;
  bfd_boolean old_state;
  const char *file;
  unsigned int line;
  const void *datum;
  struct state_stackS_struct *prev;
} state_stackS;

state_stackS *directive_state_stack;

const pseudo_typeS md_pseudo_table[] =
{
  { "align", s_align_bytes, 0 }, /* Defaulting is invalid (0).  */
  { "literal_position", xtensa_literal_position, 0 },
  { "frame", s_ignore, 0 },	/* Formerly used for STABS debugging.  */
  { "long", xtensa_elf_cons, 4 },
  { "word", xtensa_elf_cons, 4 },
  { "4byte", xtensa_elf_cons, 4 },
  { "short", xtensa_elf_cons, 2 },
  { "2byte", xtensa_elf_cons, 2 },
  { "sleb128", xtensa_leb128, 1},
  { "uleb128", xtensa_leb128, 0},
  { "begin", xtensa_begin_directive, 0 },
  { "end", xtensa_end_directive, 0 },
  { "literal", xtensa_literal_pseudo, 0 },
  { "frequency", xtensa_frequency_pseudo, 0 },
  { NULL, 0, 0 },
};


static bfd_boolean
use_transform (void)
{
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
  gas_assert (!past_xtensa_end);
  return directive_state[directive_transform];
}


static bfd_boolean
do_align_targets (void)
{
  /* Do not use this function after md_end; just look at align_targets
     instead.  There is no target-align directive, so alignment is either
     enabled for all frags or not done at all.  */
  gas_assert (!past_xtensa_end);
  return align_targets && use_transform ();
}


static void
directive_push (directiveE directive, bfd_boolean negated, const void *datum)
{
  char *file;
  unsigned int line;
  state_stackS *stack = (state_stackS *) xmalloc (sizeof (state_stackS));

  as_where (&file, &line);

  stack->directive = directive;
  stack->negated = negated;
  stack->old_state = directive_state[directive];
  stack->file = file;
  stack->line = line;
  stack->datum = datum;
  stack->prev = directive_state_stack;
  directive_state_stack = stack;

  directive_state[directive] = !negated;
}


static void
directive_pop (directiveE *directive,
	       bfd_boolean *negated,
	       const char **file,
	       unsigned int *line,
	       const void **datum)
{
  state_stackS *top = directive_state_stack;

  if (!directive_state_stack)
    {
      as_bad (_("unmatched end directive"));
      *directive = directive_none;
      return;
    }

  directive_state[directive_state_stack->directive] = top->old_state;
  *directive = top->directive;
  *negated = top->negated;
  *file = top->file;
  *line = top->line;
  *datum = top->datum;
  directive_state_stack = top->prev;
  free (top);
}


static void
directive_balance (void)
{
  while (directive_state_stack)
    {
      directiveE directive;
      bfd_boolean negated;
      const char *file;
      unsigned int line;
      const void *datum;

      directive_pop (&directive, &negated, &file, &line, &datum);
      as_warn_where ((char *) file, line,
		     _(".begin directive with no matching .end directive"));
    }
}


static bfd_boolean
inside_directive (directiveE dir)
{
  state_stackS *top = directive_state_stack;

  while (top && top->directive != dir)
    top = top->prev;

  return (top != NULL);
}


static void
get_directive (directiveE *directive, bfd_boolean *negated)
{
  int len;
  unsigned i;
  char *directive_string;

  if (strncmp (input_line_pointer, "no-", 3) != 0)
    *negated = FALSE;
  else
    {
      *negated = TRUE;
      input_line_pointer += 3;
    }

  len = strspn (input_line_pointer,
		"abcdefghijklmnopqrstuvwxyz_-/0123456789.");

  /* This code is a hack to make .begin [no-][generics|relax] exactly
     equivalent to .begin [no-]transform.  We should remove it when
     we stop accepting those options.  */

  if (strncmp (input_line_pointer, "generics", strlen ("generics")) == 0)
    {
      as_warn (_("[no-]generics is deprecated; use [no-]transform instead"));
      directive_string = "transform";
    }
  else if (strncmp (input_line_pointer, "relax", strlen ("relax")) == 0)
    {
      as_warn (_("[no-]relax is deprecated; use [no-]transform instead"));
      directive_string = "transform";
    }
  else
    directive_string = input_line_pointer;

  for (i = 0; i < sizeof (directive_info) / sizeof (*directive_info); ++i)
    {
      if (strncmp (directive_string, directive_info[i].name, len) == 0)
	{
	  input_line_pointer += len;
	  *directive = (directiveE) i;
	  if (*negated && !directive_info[i].can_be_negated)
	    as_bad (_("directive %s cannot be negated"),
		    directive_info[i].name);
	  return;
	}
    }

  as_bad (_("unknown directive"));
  *directive = (directiveE) XTENSA_UNDEFINED;
}


static void
xtensa_begin_directive (int ignore ATTRIBUTE_UNUSED)
{
  directiveE directive;
  bfd_boolean negated;
  emit_state *state;
  lit_state *ls;

  get_directive (&directive, &negated);
  if (directive == (directiveE) XTENSA_UNDEFINED)
    {
      discard_rest_of_line ();
      return;
    }

  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));

  switch (directive)
    {
    case directive_literal:
      if (!inside_directive (directive_literal))
	{
	  /* Previous labels go with whatever follows this directive, not with
	     the literal, so save them now.  */
	  saved_insn_labels = insn_labels;
	  insn_labels = NULL;
	}
      as_warn (_(".begin literal is deprecated; use .literal instead"));
      state = (emit_state *) xmalloc (sizeof (emit_state));
      xtensa_switch_to_literal_fragment (state);
      directive_push (directive_literal, negated, state);
      break;

    case directive_literal_prefix:
      /* Have to flush pending output because a movi relaxed to an l32r
	 might produce a literal.  */
      md_flush_pending_output ();
      /* Check to see if the current fragment is a literal
	 fragment.  If it is, then this operation is not allowed.  */
      if (generating_literals)
	{
	  as_bad (_("cannot set literal_prefix inside literal fragment"));
	  return;
	}

      /* Allocate the literal state for this section and push
	 onto the directive stack.  */
      ls = xmalloc (sizeof (lit_state));
      gas_assert (ls);

      *ls = default_lit_sections;
      directive_push (directive_literal_prefix, negated, ls);

      /* Process the new prefix.  */
      xtensa_literal_prefix ();
      break;

    case directive_freeregs:
      /* This information is currently unused, but we'll accept the statement
         and just discard the rest of the line.  This won't check the syntax,
         but it will accept every correct freeregs directive.  */
      input_line_pointer += strcspn (input_line_pointer, "\n");
      directive_push (directive_freeregs, negated, 0);
      break;

    case directive_schedule:
      md_flush_pending_output ();
      frag_var (rs_fill, 0, 0, frag_now->fr_subtype,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);
      directive_push (directive_schedule, negated, 0);
      xtensa_set_frag_assembly_state (frag_now);
      break;

    case directive_density:
      as_warn (_(".begin [no-]density is ignored"));
      break;

    case directive_absolute_literals:
      md_flush_pending_output ();
      if (!absolute_literals_supported && !negated)
	{
	  as_warn (_("Xtensa absolute literals option not supported; ignored"));
	  break;
	}
      xtensa_set_frag_assembly_state (frag_now);
      directive_push (directive, negated, 0);
      break;

    default:
      md_flush_pending_output ();
      xtensa_set_frag_assembly_state (frag_now);
      directive_push (directive, negated, 0);
      break;
    }

  demand_empty_rest_of_line ();
}


static void
xtensa_end_directive (int ignore ATTRIBUTE_UNUSED)
{
  directiveE begin_directive, end_directive;
  bfd_boolean begin_negated, end_negated;
  const char *file;
  unsigned int line;
  emit_state *state;
  emit_state **state_ptr;
  lit_state *s;

  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));

  get_directive (&end_directive, &end_negated);

  md_flush_pending_output ();

  switch ((int) end_directive)
    {
    case XTENSA_UNDEFINED:
      discard_rest_of_line ();
      return;

    case (int) directive_density:
      as_warn (_(".end [no-]density is ignored"));
      demand_empty_rest_of_line ();
      break;

    case (int) directive_absolute_literals:
      if (!absolute_literals_supported && !end_negated)
	{
	  as_warn (_("Xtensa absolute literals option not supported; ignored"));
	  demand_empty_rest_of_line ();
	  return;
	}
      break;

    default:
      break;
    }

  state_ptr = &state; /* use state_ptr to avoid type-punning warning */
  directive_pop (&begin_directive, &begin_negated, &file, &line,
		 (const void **) state_ptr);

  if (begin_directive != directive_none)
    {
      if (begin_directive != end_directive || begin_negated != end_negated)
	{
	  as_bad (_("does not match begin %s%s at %s:%d"),
		  begin_negated ? "no-" : "",
		  directive_info[begin_directive].name, file, line);
	}
      else
	{
	  switch (end_directive)
	    {
	    case directive_literal:
	      frag_var (rs_fill, 0, 0, 0, NULL, 0, NULL);
	      xtensa_restore_emit_state (state);
	      xtensa_set_frag_assembly_state (frag_now);
	      free (state);
	      if (!inside_directive (directive_literal))
		{
		  /* Restore the list of current labels.  */
		  xtensa_clear_insn_labels ();
		  insn_labels = saved_insn_labels;
		}
	      break;

	    case directive_literal_prefix:
	      /* Restore the default collection sections from saved state.  */
	      s = (lit_state *) state;
	      gas_assert (s);
	      default_lit_sections = *s;

	      /* Free the state storage.  */
	      free (s->lit_prefix);
	      free (s);
	      break;

	    case directive_schedule:
	    case directive_freeregs:
	      break;

	    default:
	      xtensa_set_frag_assembly_state (frag_now);
	      break;
	    }
	}
    }

  demand_empty_rest_of_line ();
}


/* Place an aligned literal fragment at the current location.  */

static void
xtensa_literal_position (int ignore ATTRIBUTE_UNUSED)
{
  md_flush_pending_output ();

  if (inside_directive (directive_literal))
    as_warn (_(".literal_position inside literal directive; ignoring"));
  xtensa_mark_literal_pool_location ();

  demand_empty_rest_of_line ();
  xtensa_clear_insn_labels ();
}


/* Support .literal label, expr, ...  */

static void
xtensa_literal_pseudo (int ignored ATTRIBUTE_UNUSED)
{
  emit_state state;
  char *p, *base_name;
  char c;
  segT dest_seg;

  if (inside_directive (directive_literal))
    {
      as_bad (_(".literal not allowed inside .begin literal region"));
      ignore_rest_of_line ();
      return;
    }

  md_flush_pending_output ();

  /* Previous labels go with whatever follows this directive, not with
     the literal, so save them now.  */
  saved_insn_labels = insn_labels;
  insn_labels = NULL;

  /* If we are using text-section literals, then this is the right value... */
  dest_seg = now_seg;

  base_name = input_line_pointer;

  xtensa_switch_to_literal_fragment (&state);

  /* ...but if we aren't using text-section-literals, then we
     need to put them in the section we just switched to.  */
  if (use_literal_section || directive_state[directive_absolute_literals])
    dest_seg = now_seg;

  /* FIXME, despite the previous comments, dest_seg is unused...  */
  (void) dest_seg;

  /* All literals are aligned to four-byte boundaries.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  c = get_symbol_end ();
  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',' && *input_line_pointer != ':')
    {
      as_bad (_("expected comma or colon after symbol name; "
		"rest of line ignored"));
      ignore_rest_of_line ();
      xtensa_restore_emit_state (&state);
      return;
    }
  *p = 0;

  colon (base_name);

  *p = c;
  input_line_pointer++;		/* skip ',' or ':' */

  xtensa_elf_cons (4);

  xtensa_restore_emit_state (&state);

  /* Restore the list of current labels.  */
  xtensa_clear_insn_labels ();
  insn_labels = saved_insn_labels;
}


static void
xtensa_literal_prefix (void)
{
  char *name;
  int len;

  /* Parse the new prefix from the input_line_pointer.  */
  SKIP_WHITESPACE ();
  len = strspn (input_line_pointer,
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"abcdefghijklmnopqrstuvwxyz_/0123456789.$");

  /* Get a null-terminated copy of the name.  */
  name = xmalloc (len + 1);
  gas_assert (name);
  strncpy (name, input_line_pointer, len);
  name[len] = 0;

  /* Skip the name in the input line.  */
  input_line_pointer += len;

  default_lit_sections.lit_prefix = name;

  /* Clear cached literal sections, since the prefix has changed.  */
  default_lit_sections.lit_seg = NULL;
  default_lit_sections.lit4_seg = NULL;
}


/* Support ".frequency branch_target_frequency fall_through_frequency".  */

static void
xtensa_frequency_pseudo (int ignored ATTRIBUTE_UNUSED)
{
  float fall_through_f, target_f;

  fall_through_f = (float) strtod (input_line_pointer, &input_line_pointer);
  if (fall_through_f < 0)
    {
      as_bad (_("fall through frequency must be greater than 0"));
      ignore_rest_of_line ();
      return;
    }

  target_f = (float) strtod (input_line_pointer, &input_line_pointer);
  if (target_f < 0)
    {
      as_bad (_("branch target frequency must be greater than 0"));
      ignore_rest_of_line ();
      return;
    }

  set_subseg_freq (now_seg, now_subseg, target_f + fall_through_f, target_f);

  demand_empty_rest_of_line ();
}


/* Like normal .long/.short/.word, except support @@plt, etc.
   Clobbers input_line_pointer, checks end-of-line.  */

static void
xtensa_elf_cons (int nbytes)
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;

  md_flush_pending_output ();

  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);
      if (exp.X_op == O_symbol
	  && *input_line_pointer == '@@'
	  && ((reloc = xtensa_elf_suffix (&input_line_pointer, &exp))
	      != BFD_RELOC_NONE))
	{
	  reloc_howto_type *reloc_howto =
	    bfd_reloc_type_lookup (stdoutput, reloc);

	  if (reloc == BFD_RELOC_UNUSED || !reloc_howto)
	    as_bad (_("unsupported relocation"));
	  else if ((reloc >= BFD_RELOC_XTENSA_SLOT0_OP
		    && reloc <= BFD_RELOC_XTENSA_SLOT14_OP)
		   || (reloc >= BFD_RELOC_XTENSA_SLOT0_ALT
		       && reloc <= BFD_RELOC_XTENSA_SLOT14_ALT))
	    as_bad (_("opcode-specific %s relocation used outside "
		      "an instruction"), reloc_howto->name);
	  else if (nbytes != (int) bfd_get_reloc_size (reloc_howto))
	    as_bad (_("%s relocations do not fit in %d bytes"),
		    reloc_howto->name, nbytes);
	  else if (reloc == BFD_RELOC_XTENSA_TLS_FUNC
		   || reloc == BFD_RELOC_XTENSA_TLS_ARG
		   || reloc == BFD_RELOC_XTENSA_TLS_CALL)
	    as_bad (_("invalid use of %s relocation"), reloc_howto->name);
	  else
	    {
	      char *p = frag_more ((int) nbytes);
	      xtensa_set_frag_assembly_state (frag_now);
	      fix_new_exp (frag_now, p - frag_now->fr_literal,
			   nbytes, &exp, reloc_howto->pc_relative, reloc);
	    }
	}
      else
	{
	  xtensa_set_frag_assembly_state (frag_now);
	  emit_expr (&exp, (unsigned int) nbytes);
	}
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
}

static bfd_boolean is_leb128_expr;

static void
xtensa_leb128 (int sign)
{
  is_leb128_expr = TRUE;
  s_leb128 (sign);
  is_leb128_expr = FALSE;
}


/* Parsing and Idiom Translation.  */

/* Parse @@plt, etc. and return the desired relocation.  */
static bfd_reloc_code_real_type
xtensa_elf_suffix (char **str_p, expressionS *exp_p)
{
  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  struct suffix_reloc_map *ptr;

  if (*str++ != '@@')
    return BFD_RELOC_NONE;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (ISALNUM (ch) || ch == '@@'));
       ch = *++str)
    {
      *str2++ = (ISLOWER (ch)) ? ch : TOLOWER (ch);
    }

  *str2 = '\0';
  len = str2 - ident;

  ch = ident[0];
  for (ptr = &suffix_relocs[0]; ptr->length > 0; ptr++)
    if (ch == ptr->suffix[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->suffix, ptr->length) == 0)
      {
	/* Now check for "identifier@@suffix+constant".  */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;

	    input_line_pointer = str;
	    expression (&new_exp);
	    if (new_exp.X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp.X_add_number;
		str = input_line_pointer;
	      }

	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }

	*str_p = str;
	return ptr->reloc;
      }

  return BFD_RELOC_UNUSED;
}


/* Find the matching operator type.  */
static unsigned char
map_suffix_reloc_to_operator (bfd_reloc_code_real_type reloc)
{
  struct suffix_reloc_map *sfx;
  unsigned char operator = (unsigned char) -1;
  
  for (sfx = &suffix_relocs[0]; sfx->suffix; sfx++)
    {
      if (sfx->reloc == reloc)
	{
	  operator = sfx->operator;
	  break;
	}
    }
  gas_assert (operator != (unsigned char) -1);
  return operator;
}


/* Find the matching reloc type.  */
static bfd_reloc_code_real_type
map_operator_to_reloc (unsigned char operator, bfd_boolean is_literal)
{
  struct suffix_reloc_map *sfx;
  bfd_reloc_code_real_type reloc = BFD_RELOC_UNUSED;

  for (sfx = &suffix_relocs[0]; sfx->suffix; sfx++)
    {
      if (sfx->operator == operator)
	{
	  reloc = sfx->reloc;
	  break;
	}
    }

  if (is_literal)
    {
      if (reloc == BFD_RELOC_XTENSA_TLS_FUNC)
	return BFD_RELOC_XTENSA_TLSDESC_FN;
      else if (reloc == BFD_RELOC_XTENSA_TLS_ARG)
	return BFD_RELOC_XTENSA_TLSDESC_ARG;
    }

  if (reloc == BFD_RELOC_UNUSED)
    return BFD_RELOC_32;

  return reloc;
}


static const char *
expression_end (const char *name)
{
  while (1)
    {
      switch (*name)
	{
	case '}':
	case ';':
	case '\0':
	case ',':
	case ':':
	  return name;
	case ' ':
	case '\t':
	  ++name;
	  continue;
	default:
	  return 0;
	}
    }
}


#define ERROR_REG_NUM ((unsigned) -1)

static unsigned
tc_get_register (const char *prefix)
{
  unsigned reg;
  const char *next_expr;
  const char *old_line_pointer;

  SKIP_WHITESPACE ();
  old_line_pointer = input_line_pointer;

  if (*input_line_pointer == '$')
    ++input_line_pointer;

  /* Accept "sp" as a synonym for "a1".  */
  if (input_line_pointer[0] == 's' && input_line_pointer[1] == 'p'
      && expression_end (input_line_pointer + 2))
    {
      input_line_pointer += 2;
      return 1;  /* AR[1] */
    }

  while (*input_line_pointer++ == *prefix++)
    ;
  --input_line_pointer;
  --prefix;

  if (*prefix)
    {
      as_bad (_("bad register name: %s"), old_line_pointer);
      return ERROR_REG_NUM;
    }

  if (!ISDIGIT ((unsigned char) *input_line_pointer))
    {
      as_bad (_("bad register number: %s"), input_line_pointer);
      return ERROR_REG_NUM;
    }

  reg = 0;

  while (ISDIGIT ((int) *input_line_pointer))
    reg = reg * 10 + *input_line_pointer++ - '0';

  if (!(next_expr = expression_end (input_line_pointer)))
    {
      as_bad (_("bad register name: %s"), old_line_pointer);
      return ERROR_REG_NUM;
    }

  input_line_pointer = (char *) next_expr;

  return reg;
}


static void
expression_maybe_register (xtensa_opcode opc, int opnd, expressionS *tok)
{
  xtensa_isa isa = xtensa_default_isa;

  /* Check if this is an immediate operand.  */
  if (xtensa_operand_is_register (isa, opc, opnd) == 0)
    {
      bfd_reloc_code_real_type reloc;
      segT t = expression (tok);

      if (t == absolute_section
	  && xtensa_operand_is_PCrelative (isa, opc, opnd) == 1)
	{
	  gas_assert (tok->X_op == O_constant);
	  tok->X_op = O_symbol;
	  tok->X_add_symbol = &abs_symbol;
	}

      if ((tok->X_op == O_constant || tok->X_op == O_symbol)
	  && ((reloc = xtensa_elf_suffix (&input_line_pointer, tok))
	      != BFD_RELOC_NONE))
	{
	  switch (reloc)
	    {
	    case BFD_RELOC_LO16:
	      if (tok->X_op == O_constant)
		{
		  tok->X_add_number &= 0xffff;
		  return;
		}
	      break;
	    case BFD_RELOC_HI16:
	      if (tok->X_op == O_constant)
		{
		  tok->X_add_number = ((unsigned) tok->X_add_number) >> 16;
		  return;
		}
	      break;
	    case BFD_RELOC_UNUSED:
	      as_bad (_("unsupported relocation"));
	      return;
	    case BFD_RELOC_32_PCREL:
	      as_bad (_("pcrel relocation not allowed in an instruction"));
	      return;
	    default:
	      break;
	    }
	  tok->X_op = map_suffix_reloc_to_operator (reloc);
	}
    }
  else
    {
      xtensa_regfile opnd_rf = xtensa_operand_regfile (isa, opc, opnd);
      unsigned reg = tc_get_register (xtensa_regfile_shortname (isa, opnd_rf));

      if (reg != ERROR_REG_NUM)	/* Already errored */
	{
	  uint32 buf = reg;
	  if (xtensa_operand_encode (isa, opc, opnd, &buf))
	    as_bad (_("register number out of range"));
	}

      tok->X_op = O_register;
      tok->X_add_symbol = 0;
      tok->X_add_number = reg;
    }
}


/* Split up the arguments for an opcode or pseudo-op.  */

static int
tokenize_arguments (char **args, char *str)
{
  char *old_input_line_pointer;
  bfd_boolean saw_comma = FALSE;
  bfd_boolean saw_arg = FALSE;
  bfd_boolean saw_colon = FALSE;
  int num_args = 0;
  char *arg_end, *arg;
  int arg_len;

  /* Save and restore input_line_pointer around this function.  */
  old_input_line_pointer = input_line_pointer;
  input_line_pointer = str;

  while (*input_line_pointer)
    {
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	case '\0':
	case '}':
	  goto fini;

	case ':':
	  input_line_pointer++;
	  if (saw_comma || saw_colon || !saw_arg)
	    goto err;
	  saw_colon = TRUE;
	  break;

	case ',':
	  input_line_pointer++;
	  if (saw_comma || saw_colon || !saw_arg)
	    goto err;
	  saw_comma = TRUE;
	  break;

	default:
	  if (!saw_comma && !saw_colon && saw_arg)
	    goto err;

	  arg_end = input_line_pointer + 1;
	  while (!expression_end (arg_end))
	    arg_end += 1;

	  arg_len = arg_end - input_line_pointer;
	  arg = (char *) xmalloc ((saw_colon ? 1 : 0) + arg_len + 1);
	  args[num_args] = arg;

	  if (saw_colon)
	    *arg++ = ':';
	  strncpy (arg, input_line_pointer, arg_len);
	  arg[arg_len] = '\0';

	  input_line_pointer = arg_end;
	  num_args += 1;
	  saw_comma = FALSE;
	  saw_colon = FALSE;
	  saw_arg = TRUE;
	  break;
	}
    }

fini:
  if (saw_comma || saw_colon)
    goto err;
  input_line_pointer = old_input_line_pointer;
  return num_args;

err:
  if (saw_comma)
    as_bad (_("extra comma"));
  else if (saw_colon)
    as_bad (_("extra colon"));
  else if (!saw_arg)
    as_bad (_("missing argument"));
  else
    as_bad (_("missing comma or colon"));
  input_line_pointer = old_input_line_pointer;
  return -1;
}


/* Parse the arguments to an opcode.  Return TRUE on error.  */

static bfd_boolean
parse_arguments (TInsn *insn, int num_args, char **arg_strings)
{
  expressionS *tok, *last_tok;
  xtensa_opcode opcode = insn->opcode;
  bfd_boolean had_error = TRUE;
  xtensa_isa isa = xtensa_default_isa;
  int n, num_regs = 0;
  int opcode_operand_count;
  int opnd_cnt, last_opnd_cnt;
  unsigned int next_reg = 0;
  char *old_input_line_pointer;

  if (insn->insn_type == ITYPE_LITERAL)
    opcode_operand_count = 1;
  else
    opcode_operand_count = xtensa_opcode_num_operands (isa, opcode);

  tok = insn->tok;
  memset (tok, 0, sizeof (*tok) * MAX_INSN_ARGS);

  /* Save and restore input_line_pointer around this function.  */
  old_input_line_pointer = input_line_pointer;

  last_tok = 0;
  last_opnd_cnt = -1;
  opnd_cnt = 0;

  /* Skip invisible operands.  */
  while (xtensa_operand_is_visible (isa, opcode, opnd_cnt) == 0)
    {
      opnd_cnt += 1;
      tok++;
    }

  for (n = 0; n < num_args; n++)
    {
      input_line_pointer = arg_strings[n];
      if (*input_line_pointer == ':')
	{
	  xtensa_regfile opnd_rf;
	  input_line_pointer++;
	  if (num_regs == 0)
	    goto err;
	  gas_assert (opnd_cnt > 0);
	  num_regs--;
	  opnd_rf = xtensa_operand_regfile (isa, opcode, last_opnd_cnt);
	  if (next_reg
	      != tc_get_register (xtensa_regfile_shortname (isa, opnd_rf)))
	    as_warn (_("incorrect register number, ignoring"));
	  next_reg++;
	}
      else
	{
	  if (opnd_cnt >= opcode_operand_count)
	    {
	      as_warn (_("too many arguments"));
	      goto err;
	    }
	  gas_assert (opnd_cnt < MAX_INSN_ARGS);

	  expression_maybe_register (opcode, opnd_cnt, tok);
	  next_reg = tok->X_add_number + 1;

	  if (tok->X_op == O_illegal || tok->X_op == O_absent)
	    goto err;
	  if (xtensa_operand_is_register (isa, opcode, opnd_cnt) == 1)
	    {
	      num_regs = xtensa_operand_num_regs (isa, opcode, opnd_cnt) - 1;
	      /* minus 1 because we are seeing one right now */
	    }
	  else
	    num_regs = 0;

	  last_tok = tok;
	  last_opnd_cnt = opnd_cnt;
	  demand_empty_rest_of_line ();

	  do
	    {
	      opnd_cnt += 1;
	      tok++;
	    }
	  while (xtensa_operand_is_visible (isa, opcode, opnd_cnt) == 0);
	}
    }

  if (num_regs > 0 && ((int) next_reg != last_tok->X_add_number + 1))
    goto err;

  insn->ntok = tok - insn->tok;
  had_error = FALSE;

 err:
  input_line_pointer = old_input_line_pointer;
  return had_error;
}


static int
get_invisible_operands (TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_format fmt;
  xtensa_opcode opc = insn->opcode;
  int slot, opnd, fmt_found;
  unsigned val;

  if (!slotbuf)
    slotbuf = xtensa_insnbuf_alloc (isa);

  /* Find format/slot where this can be encoded.  */
  fmt_found = 0;
  slot = 0;
  for (fmt = 0; fmt < xtensa_isa_num_formats (isa); fmt++)
    {
      for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
	{
	  if (xtensa_opcode_encode (isa, fmt, slot, slotbuf, opc) == 0)
	    {
	      fmt_found = 1;
	      break;
	    }
	}
      if (fmt_found) break;
    }

  if (!fmt_found)
    {
      as_bad (_("cannot encode opcode \"%s\""), xtensa_opcode_name (isa, opc));
      return -1;
    }

  /* First encode all the visible operands
     (to deal with shared field operands).  */
  for (opnd = 0; opnd < insn->ntok; opnd++)
    {
      if (xtensa_operand_is_visible (isa, opc, opnd) == 1
	  && (insn->tok[opnd].X_op == O_register
	      || insn->tok[opnd].X_op == O_constant))
	{
	  val = insn->tok[opnd].X_add_number;
	  xtensa_operand_encode (isa, opc, opnd, &val);
	  xtensa_operand_set_field (isa, opc, opnd, fmt, slot, slotbuf, val);
	}
    }

  /* Then pull out the values for the invisible ones.  */
  for (opnd = 0; opnd < insn->ntok; opnd++)
    {
      if (xtensa_operand_is_visible (isa, opc, opnd) == 0)
	{
	  xtensa_operand_get_field (isa, opc, opnd, fmt, slot, slotbuf, &val);
	  xtensa_operand_decode (isa, opc, opnd, &val);
	  insn->tok[opnd].X_add_number = val;
	  if (xtensa_operand_is_register (isa, opc, opnd) == 1)
	    insn->tok[opnd].X_op = O_register;
	  else
	    insn->tok[opnd].X_op = O_constant;
	}
    }

  return 0;
}


static void
xg_reverse_shift_count (char **cnt_argp)
{
  char *cnt_arg, *new_arg;
  cnt_arg = *cnt_argp;

  /* replace the argument with "31-(argument)" */
  new_arg = (char *) xmalloc (strlen (cnt_arg) + 6);
  sprintf (new_arg, "31-(%s)", cnt_arg);

  free (cnt_arg);
  *cnt_argp = new_arg;
}


/* If "arg" is a constant expression, return non-zero with the value
   in *valp.  */

static int
xg_arg_is_constant (char *arg, offsetT *valp)
{
  expressionS exp;
  char *save_ptr = input_line_pointer;

  input_line_pointer = arg;
  expression (&exp);
  input_line_pointer = save_ptr;

  if (exp.X_op == O_constant)
    {
      *valp = exp.X_add_number;
      return 1;
    }

  return 0;
}


static void
xg_replace_opname (char **popname, char *newop)
{
  free (*popname);
  *popname = (char *) xmalloc (strlen (newop) + 1);
  strcpy (*popname, newop);
}


static int
xg_check_num_args (int *pnum_args,
		   int expected_num,
		   char *opname,
		   char **arg_strings)
{
  int num_args = *pnum_args;

  if (num_args < expected_num)
    {
      as_bad (_("not enough operands (%d) for '%s'; expected %d"),
	      num_args, opname, expected_num);
      return -1;
    }

  if (num_args > expected_num)
    {
      as_warn (_("too many operands (%d) for '%s'; expected %d"),
	       num_args, opname, expected_num);
      while (num_args-- > expected_num)
	{
	  free (arg_strings[num_args]);
	  arg_strings[num_args] = 0;
	}
      *pnum_args = expected_num;
      return -1;
    }

  return 0;
}


/* If the register is not specified as part of the opcode,
   then get it from the operand and move it to the opcode.  */

static int
xg_translate_sysreg_op (char **popname, int *pnum_args, char **arg_strings)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_sysreg sr;
  char *opname, *new_opname;
  const char *sr_name;
  int is_user, is_write;

  opname = *popname;
  if (*opname == '_')
    opname += 1;
  is_user = (opname[1] == 'u');
  is_write = (opname[0] == 'w');

  /* Opname == [rw]ur or [rwx]sr... */

  if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
    return -1;

  /* Check if the argument is a symbolic register name.  */
  sr = xtensa_sysreg_lookup_name (isa, arg_strings[1]);
  /* Handle WSR to "INTSET" as a special case.  */
  if (sr == XTENSA_UNDEFINED && is_write && !is_user
      && !strcasecmp (arg_strings[1], "intset"))
    sr = xtensa_sysreg_lookup_name (isa, "interrupt");
  if (sr == XTENSA_UNDEFINED
      || (xtensa_sysreg_is_user (isa, sr) == 1) != is_user)
    {
      /* Maybe it's a register number.... */
      offsetT val;
      if (!xg_arg_is_constant (arg_strings[1], &val))
	{
	  as_bad (_("invalid register '%s' for '%s' instruction"),
		  arg_strings[1], opname);
	  return -1;
	}
      sr = xtensa_sysreg_lookup (isa, val, is_user);
      if (sr == XTENSA_UNDEFINED)
	{
	  as_bad (_("invalid register number (%ld) for '%s' instruction"),
		  (long) val, opname);
	  return -1;
	}
    }

  /* Remove the last argument, which is now part of the opcode.  */
  free (arg_strings[1]);
  arg_strings[1] = 0;
  *pnum_args = 1;

  /* Translate the opcode.  */
  sr_name = xtensa_sysreg_name (isa, sr);
  /* Another special case for "WSR.INTSET"....  */
  if (is_write && !is_user && !strcasecmp ("interrupt", sr_name))
    sr_name = "intset";
  new_opname = (char *) xmalloc (strlen (sr_name) + 6);
  sprintf (new_opname, "%s.%s", *popname, sr_name);
  free (*popname);
  *popname = new_opname;

  return 0;
}


static int
xtensa_translate_old_userreg_ops (char **popname)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_sysreg sr;
  char *opname, *new_opname;
  const char *sr_name;
  bfd_boolean has_underbar = FALSE;

  opname = *popname;
  if (opname[0] == '_')
    {
      has_underbar = TRUE;
      opname += 1;
    }

  sr = xtensa_sysreg_lookup_name (isa, opname + 1);
  if (sr != XTENSA_UNDEFINED)
    {
      /* The new default name ("nnn") is different from the old default
	 name ("URnnn").  The old default is handled below, and we don't
	 want to recognize [RW]nnn, so do nothing if the name is the (new)
	 default.  */
      static char namebuf[10];
      sprintf (namebuf, "%d", xtensa_sysreg_number (isa, sr));
      if (strcmp (namebuf, opname + 1) == 0)
	return 0;
    }
  else
    {
      offsetT val;
      char *end;

      /* Only continue if the reg name is "URnnn".  */
      if (opname[1] != 'u' || opname[2] != 'r')
	return 0;
      val = strtoul (opname + 3, &end, 10);
      if (*end != '\0')
	return 0;

      sr = xtensa_sysreg_lookup (isa, val, 1);
      if (sr == XTENSA_UNDEFINED)
	{
	  as_bad (_("invalid register number (%ld) for '%s'"),
		  (long) val, opname);
	  return -1;
	}
    }

  /* Translate the opcode.  */
  sr_name = xtensa_sysreg_name (isa, sr);
  new_opname = (char *) xmalloc (strlen (sr_name) + 6);
  sprintf (new_opname, "%s%cur.%s", (has_underbar ? "_" : ""),
	   opname[0], sr_name);
  free (*popname);
  *popname = new_opname;

  return 0;
}


static int
xtensa_translate_zero_immed (char *old_op,
			     char *new_op,
			     char **popname,
			     int *pnum_args,
			     char **arg_strings)
{
  char *opname;
  offsetT val;

  opname = *popname;
  gas_assert (opname[0] != '_');

  if (strcmp (opname, old_op) != 0)
    return 0;

  if (xg_check_num_args (pnum_args, 3, opname, arg_strings))
    return -1;
  if (xg_arg_is_constant (arg_strings[1], &val) && val == 0)
    {
      xg_replace_opname (popname, new_op);
      free (arg_strings[1]);
      arg_strings[1] = arg_strings[2];
      arg_strings[2] = 0;
      *pnum_args = 2;
    }

  return 0;
}


/* If the instruction is an idiom (i.e., a built-in macro), translate it.
   Returns non-zero if an error was found.  */

static int
xg_translate_idioms (char **popname, int *pnum_args, char **arg_strings)
{
  char *opname = *popname;
  bfd_boolean has_underbar = FALSE;

  if (*opname == '_')
    {
      has_underbar = TRUE;
      opname += 1;
    }

  if (strcmp (opname, "mov") == 0)
    {
      if (use_transform () && !has_underbar && density_supported)
	xg_replace_opname (popname, "mov.n");
      else
	{
	  if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
	    return -1;
	  xg_replace_opname (popname, (has_underbar ? "_or" : "or"));
	  arg_strings[2] = (char *) xmalloc (strlen (arg_strings[1]) + 1);
	  strcpy (arg_strings[2], arg_strings[1]);
	  *pnum_args = 3;
	}
      return 0;
    }

  if (strcmp (opname, "bbsi.l") == 0)
    {
      if (xg_check_num_args (pnum_args, 3, opname, arg_strings))
	return -1;
      xg_replace_opname (popname, (has_underbar ? "_bbsi" : "bbsi"));
      if (target_big_endian)
	xg_reverse_shift_count (&arg_strings[1]);
      return 0;
    }

  if (strcmp (opname, "bbci.l") == 0)
    {
      if (xg_check_num_args (pnum_args, 3, opname, arg_strings))
	return -1;
      xg_replace_opname (popname, (has_underbar ? "_bbci" : "bbci"));
      if (target_big_endian)
	xg_reverse_shift_count (&arg_strings[1]);
      return 0;
    }

  /* Don't do anything special with NOPs inside FLIX instructions.  They
     are handled elsewhere.  Real NOP instructions are always available 
     in configurations with FLIX, so this should never be an issue but
     check for it anyway.  */
  if (!cur_vinsn.inside_bundle && xtensa_nop_opcode == XTENSA_UNDEFINED
      && strcmp (opname, "nop") == 0)
    {
      if (use_transform () && !has_underbar && density_supported)
	xg_replace_opname (popname, "nop.n");
      else
	{
	  if (xg_check_num_args (pnum_args, 0, opname, arg_strings))
	    return -1;
	  xg_replace_opname (popname, (has_underbar ? "_or" : "or"));
	  arg_strings[0] = (char *) xmalloc (3);
	  arg_strings[1] = (char *) xmalloc (3);
	  arg_strings[2] = (char *) xmalloc (3);
	  strcpy (arg_strings[0], "a1");
	  strcpy (arg_strings[1], "a1");
	  strcpy (arg_strings[2], "a1");
	  *pnum_args = 3;
	}
      return 0;
    }

  /* Recognize [RW]UR and [RWX]SR.  */
  if ((((opname[0] == 'r' || opname[0] == 'w')
	&& (opname[1] == 'u' || opname[1] == 's'))
       || (opname[0] == 'x' && opname[1] == 's'))
      && opname[2] == 'r'
      && opname[3] == '\0')
    return xg_translate_sysreg_op (popname, pnum_args, arg_strings);

  /* Backward compatibility for RUR and WUR: Recognize [RW]UR<nnn> and
     [RW]<name> if <name> is the non-default name of a user register.  */
  if ((opname[0] == 'r' || opname[0] == 'w')
      && xtensa_opcode_lookup (xtensa_default_isa, opname) == XTENSA_UNDEFINED)
    return xtensa_translate_old_userreg_ops (popname);

  /* Relax branches that don't allow comparisons against an immediate value
     of zero to the corresponding branches with implicit zero immediates.  */
  if (!has_underbar && use_transform ())
    {
      if (xtensa_translate_zero_immed ("bnei", "bnez", popname,
				       pnum_args, arg_strings))
	return -1;

      if (xtensa_translate_zero_immed ("beqi", "beqz", popname,
				       pnum_args, arg_strings))
	return -1;

      if (xtensa_translate_zero_immed ("bgei", "bgez", popname,
				       pnum_args, arg_strings))
	return -1;

      if (xtensa_translate_zero_immed ("blti", "bltz", popname,
				       pnum_args, arg_strings))
	return -1;
    }

  return 0;
}


/* Functions for dealing with the Xtensa ISA.  */

/* Currently the assembler only allows us to use a single target per
   fragment.  Because of this, only one operand for a given
   instruction may be symbolic.  If there is a PC-relative operand,
   the last one is chosen.  Otherwise, the result is the number of the
   last immediate operand, and if there are none of those, we fail and
   return -1.  */

static int
get_relaxable_immed (xtensa_opcode opcode)
{
  int last_immed = -1;
  int noperands, opi;

  if (opcode == XTENSA_UNDEFINED)
    return -1;

  noperands = xtensa_opcode_num_operands (xtensa_default_isa, opcode);
  for (opi = noperands - 1; opi >= 0; opi--)
    {
      if (xtensa_operand_is_visible (xtensa_default_isa, opcode, opi) == 0)
	continue;
      if (xtensa_operand_is_PCrelative (xtensa_default_isa, opcode, opi) == 1)
	return opi;
      if (last_immed == -1
	  && xtensa_operand_is_register (xtensa_default_isa, opcode, opi) == 0)
	last_immed = opi;
    }
  return last_immed;
}


static xtensa_opcode
get_opcode_from_buf (const char *buf, int slot)
{
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, (const unsigned char *) buf, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;

  if (slot >= xtensa_format_num_slots (isa, fmt))
    return XTENSA_UNDEFINED;

  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  return xtensa_opcode_decode (isa, fmt, slot, slotbuf);
}


#ifdef TENSILICA_DEBUG

/* For debugging, print out the mapping of opcode numbers to opcodes.  */

static void
xtensa_print_insn_table (void)
{
  int num_opcodes, num_operands;
  xtensa_opcode opcode;
  xtensa_isa isa = xtensa_default_isa;

  num_opcodes = xtensa_isa_num_opcodes (xtensa_default_isa);
  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      int opn;
      fprintf (stderr, "%d: %s: ", opcode, xtensa_opcode_name (isa, opcode));
      num_operands = xtensa_opcode_num_operands (isa, opcode);
      for (opn = 0; opn < num_operands; opn++)
	{
	  if (xtensa_operand_is_visible (isa, opcode, opn) == 0)
	    continue;
	  if (xtensa_operand_is_register (isa, opcode, opn) == 1)
	    {
	      xtensa_regfile opnd_rf =
		xtensa_operand_regfile (isa, opcode, opn);
	      fprintf (stderr, "%s ", xtensa_regfile_shortname (isa, opnd_rf));
	    }
	  else if (xtensa_operand_is_PCrelative (isa, opcode, opn) == 1)
	    fputs ("[lLr] ", stderr);
	  else
	    fputs ("i ", stderr);
	}
      fprintf (stderr, "\n");
    }
}


static void
print_vliw_insn (xtensa_insnbuf vbuf)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format f = xtensa_format_decode (isa, vbuf);
  xtensa_insnbuf sbuf = xtensa_insnbuf_alloc (isa);
  int op;

  fprintf (stderr, "format = %d\n", f);

  for (op = 0; op < xtensa_format_num_slots (isa, f); op++)
    {
      xtensa_opcode opcode;
      const char *opname;
      int operands;

      xtensa_format_get_slot (isa, f, op, vbuf, sbuf);
      opcode = xtensa_opcode_decode (isa, f, op, sbuf);
      opname = xtensa_opcode_name (isa, opcode);

      fprintf (stderr, "op in slot %i is %s;\n", op, opname);
      fprintf (stderr, "   operands = ");
      for (operands = 0;
	   operands < xtensa_opcode_num_operands (isa, opcode);
	   operands++)
	{
	  unsigned int val;
	  if (xtensa_operand_is_visible (isa, opcode, operands) == 0)
	    continue;
	  xtensa_operand_get_field (isa, opcode, operands, f, op, sbuf, &val);
	  xtensa_operand_decode (isa, opcode, operands, &val);
	  fprintf (stderr, "%d ", val);
	}
      fprintf (stderr, "\n");
    }
  xtensa_insnbuf_free (isa, sbuf);
}

#endif /* TENSILICA_DEBUG */


static bfd_boolean
is_direct_call_opcode (xtensa_opcode opcode)
{
  xtensa_isa isa = xtensa_default_isa;
  int n, num_operands;

  if (xtensa_opcode_is_call (isa, opcode) != 1)
    return FALSE;

  num_operands = xtensa_opcode_num_operands (isa, opcode);
  for (n = 0; n < num_operands; n++)
    {
      if (xtensa_operand_is_register (isa, opcode, n) == 0
	  && xtensa_operand_is_PCrelative (isa, opcode, n) == 1)
	return TRUE;
    }
  return FALSE;
}


/* Convert from BFD relocation type code to slot and operand number.
   Returns non-zero on failure.  */

static int
decode_reloc (bfd_reloc_code_real_type reloc, int *slot, bfd_boolean *is_alt)
{
  if (reloc >= BFD_RELOC_XTENSA_SLOT0_OP
      && reloc <= BFD_RELOC_XTENSA_SLOT14_OP)
    {
      *slot = reloc - BFD_RELOC_XTENSA_SLOT0_OP;
      *is_alt = FALSE;
    }
  else if (reloc >= BFD_RELOC_XTENSA_SLOT0_ALT
      && reloc <= BFD_RELOC_XTENSA_SLOT14_ALT)
    {
      *slot = reloc - BFD_RELOC_XTENSA_SLOT0_ALT;
      *is_alt = TRUE;
    }
  else
    return -1;

  return 0;
}


/* Convert from slot number to BFD relocation type code for the
   standard PC-relative relocations.  Return BFD_RELOC_NONE on
   failure.  */

static bfd_reloc_code_real_type
encode_reloc (int slot)
{
  if (slot < 0 || slot > 14)
    return BFD_RELOC_NONE;

  return BFD_RELOC_XTENSA_SLOT0_OP + slot;
}


/* Convert from slot numbers to BFD relocation type code for the
   "alternate" relocations.  Return BFD_RELOC_NONE on failure.  */

static bfd_reloc_code_real_type
encode_alt_reloc (int slot)
{
  if (slot < 0 || slot > 14)
    return BFD_RELOC_NONE;

  return BFD_RELOC_XTENSA_SLOT0_ALT + slot;
}


static void
xtensa_insnbuf_set_operand (xtensa_insnbuf slotbuf,
			    xtensa_format fmt,
			    int slot,
			    xtensa_opcode opcode,
			    int operand,
			    uint32 value,
			    const char *file,
			    unsigned int line)
{
  uint32 valbuf = value;

  if (xtensa_operand_encode (xtensa_default_isa, opcode, operand, &valbuf))
    {
      if (xtensa_operand_is_PCrelative (xtensa_default_isa, opcode, operand)
	  == 1)
	as_bad_where ((char *) file, line,
		      _("operand %d of '%s' has out of range value '%u'"), 
		      operand + 1,
		      xtensa_opcode_name (xtensa_default_isa, opcode),
		      value);
      else
	as_bad_where ((char *) file, line,
		      _("operand %d of '%s' has invalid value '%u'"),
		      operand + 1,
		      xtensa_opcode_name (xtensa_default_isa, opcode),
		      value);
      return;
    }

  xtensa_operand_set_field (xtensa_default_isa, opcode, operand, fmt, slot,
			    slotbuf, valbuf);
}


static uint32
xtensa_insnbuf_get_operand (xtensa_insnbuf slotbuf,
			    xtensa_format fmt,
			    int slot,
			    xtensa_opcode opcode,
			    int opnum)
{
  uint32 val = 0;
  (void) xtensa_operand_get_field (xtensa_default_isa, opcode, opnum,
				   fmt, slot, slotbuf, &val);
  (void) xtensa_operand_decode (xtensa_default_isa, opcode, opnum, &val);
  return val;
}


/* Checks for rules from xtensa-relax tables.  */

/* The routine xg_instruction_matches_option_term must return TRUE
   when a given option term is true.  The meaning of all of the option
   terms is given interpretation by this function.  */

static bfd_boolean
xg_instruction_matches_option_term (TInsn *insn, const ReqOrOption *option)
{
  if (strcmp (option->option_name, "realnop") == 0
      || strncmp (option->option_name, "IsaUse", 6) == 0)
    {
      /* These conditions were evaluated statically when building the
	 relaxation table.  There's no need to reevaluate them now.  */
      return TRUE;
    }
  else if (strcmp (option->option_name, "FREEREG") == 0)
    return insn->extra_arg.X_op == O_register;
  else
    {
      as_fatal (_("internal error: unknown option name '%s'"),
		option->option_name);
    }
}


static bfd_boolean
xg_instruction_matches_or_options (TInsn *insn,
				   const ReqOrOptionList *or_option)
{
  const ReqOrOption *option;
  /* Must match each of the AND terms.  */
  for (option = or_option; option != NULL; option = option->next)
    {
      if (xg_instruction_matches_option_term (insn, option))
	return TRUE;
    }
  return FALSE;
}


static bfd_boolean
xg_instruction_matches_options (TInsn *insn, const ReqOptionList *options)
{
  const ReqOption *req_options;
  /* Must match each of the AND terms.  */
  for (req_options = options;
       req_options != NULL;
       req_options = req_options->next)
    {
      /* Must match one of the OR clauses.  */
      if (!xg_instruction_matches_or_options (insn,
					      req_options->or_option_terms))
	return FALSE;
    }
  return TRUE;
}


/* Return the transition rule that matches or NULL if none matches.  */

static bfd_boolean
xg_instruction_matches_rule (TInsn *insn, TransitionRule *rule)
{
  PreconditionList *condition_l;

  if (rule->opcode != insn->opcode)
    return FALSE;

  for (condition_l = rule->conditions;
       condition_l != NULL;
       condition_l = condition_l->next)
    {
      expressionS *exp1;
      expressionS *exp2;
      Precondition *cond = condition_l->precond;

      switch (cond->typ)
	{
	case OP_CONSTANT:
	  /* The expression must be the constant.  */
	  gas_assert (cond->op_num < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  if (expr_is_const (exp1))
	    {
	      switch (cond->cmp)
		{
		case OP_EQUAL:
		  if (get_expr_const (exp1) != cond->op_data)
		    return FALSE;
		  break;
		case OP_NOTEQUAL:
		  if (get_expr_const (exp1) == cond->op_data)
		    return FALSE;
		  break;
		default:
		  return FALSE;
		}
	    }
	  else if (expr_is_register (exp1))
	    {
	      switch (cond->cmp)
		{
		case OP_EQUAL:
		  if (get_expr_register (exp1) != cond->op_data)
		    return FALSE;
		  break;
		case OP_NOTEQUAL:
		  if (get_expr_register (exp1) == cond->op_data)
		    return FALSE;
		  break;
		default:
		  return FALSE;
		}
	    }
	  else
	    return FALSE;
	  break;

	case OP_OPERAND:
	  gas_assert (cond->op_num < insn->ntok);
	  gas_assert (cond->op_data < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  exp2 = &insn->tok[cond->op_data];

	  switch (cond->cmp)
	    {
	    case OP_EQUAL:
	      if (!expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    case OP_NOTEQUAL:
	      if (expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    }
	  break;

	case OP_LITERAL:
	case OP_LABEL:
	default:
	  return FALSE;
	}
    }
  if (!xg_instruction_matches_options (insn, rule->options))
    return FALSE;

  return TRUE;
}


static int
transition_rule_cmp (const TransitionRule *a, const TransitionRule *b)
{
  bfd_boolean a_greater = FALSE;
  bfd_boolean b_greater = FALSE;

  ReqOptionList *l_a = a->options;
  ReqOptionList *l_b = b->options;

  /* We only care if they both are the same except for
     a const16 vs. an l32r.  */

  while (l_a && l_b && ((l_a->next == NULL) == (l_b->next == NULL)))
    {
      ReqOrOptionList *l_or_a = l_a->or_option_terms;
      ReqOrOptionList *l_or_b = l_b->or_option_terms;
      while (l_or_a && l_or_b && ((l_a->next == NULL) == (l_b->next == NULL)))
	{
	  if (l_or_a->is_true != l_or_b->is_true)
	    return 0;
	  if (strcmp (l_or_a->option_name, l_or_b->option_name) != 0)
	    {
	      /* This is the case we care about.  */
	      if (strcmp (l_or_a->option_name, "IsaUseConst16") == 0
		  && strcmp (l_or_b->option_name, "IsaUseL32R") == 0)
		{
		  if (prefer_const16)
		    a_greater = TRUE;
		  else
		    b_greater = TRUE;
		}
	      else if (strcmp (l_or_a->option_name, "IsaUseL32R") == 0
		       && strcmp (l_or_b->option_name, "IsaUseConst16") == 0)
		{
		  if (prefer_const16)
		    b_greater = TRUE;
		  else
		    a_greater = TRUE;
		}
	      else
		return 0;
	    }
	  l_or_a = l_or_a->next;
	  l_or_b = l_or_b->next;
	}
      if (l_or_a || l_or_b)
	return 0;

      l_a = l_a->next;
      l_b = l_b->next;
    }
  if (l_a || l_b)
    return 0;

  /* Incomparable if the substitution was used differently in two cases.  */
  if (a_greater && b_greater)
    return 0;

  if (b_greater)
    return 1;
  if (a_greater)
    return -1;

  return 0;
}


static TransitionRule *
xg_instruction_match (TInsn *insn)
{
  TransitionTable *table = xg_build_simplify_table (&transition_rule_cmp);
  TransitionList *l;
  gas_assert (insn->opcode < table->num_opcodes);

  /* Walk through all of the possible transitions.  */
  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      if (xg_instruction_matches_rule (insn, rule))
	return rule;
    }
  return NULL;
}


/* Various Other Internal Functions.  */

static bfd_boolean
is_unique_insn_expansion (TransitionRule *r)
{
  if (!r->to_instr || r->to_instr->next != NULL)
    return FALSE;
  if (r->to_instr->typ != INSTR_INSTR)
    return FALSE;
  return TRUE;
}


/* Check if there is exactly one relaxation for INSN that converts it to
   another instruction of equal or larger size.  If so, and if TARG is
   non-null, go ahead and generate the relaxed instruction into TARG.  If
   NARROW_ONLY is true, then only consider relaxations that widen a narrow
   instruction, i.e., ignore relaxations that convert to an instruction of
   equal size.  In some contexts where this function is used, only
   a single widening is allowed and the NARROW_ONLY argument is used to
   exclude cases like ADDI being "widened" to an ADDMI, which may
   later be relaxed to an ADDMI/ADDI pair.  */

bfd_boolean
xg_is_single_relaxable_insn (TInsn *insn, TInsn *targ, bfd_boolean narrow_only)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  TransitionRule *match = 0;

  gas_assert (insn->insn_type == ITYPE_INSN);
  gas_assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule)
	  && is_unique_insn_expansion (rule)
	  && (xg_get_single_size (insn->opcode) + (narrow_only ? 1 : 0)
	      <= xg_get_single_size (rule->to_instr->opcode)))
	{
	  if (match)
	    return FALSE;
	  match = rule;
	}
    }
  if (!match)
    return FALSE;

  if (targ)
    xg_build_to_insn (targ, insn, match->to_instr);
  return TRUE;
}


/* Return the maximum number of bytes this opcode can expand to.  */

static int
xg_get_max_insn_widen_size (xtensa_opcode opcode)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int max_size = xg_get_single_size (opcode);

  gas_assert (opcode < table->num_opcodes);

  for (l = table->table[opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      BuildInstr *build_list;
      int this_size = 0;

      if (!rule)
	continue;
      build_list = rule->to_instr;
      if (is_unique_insn_expansion (rule))
	{
	  gas_assert (build_list->typ == INSTR_INSTR);
	  this_size = xg_get_max_insn_widen_size (build_list->opcode);
	}
      else
	for (; build_list != NULL; build_list = build_list->next)
	  {
	    switch (build_list->typ)
	      {
	      case INSTR_INSTR:
		this_size += xg_get_single_size (build_list->opcode);
		break;
	      case INSTR_LITERAL_DEF:
	      case INSTR_LABEL_DEF:
	      default:
		break;
	      }
	  }
      if (this_size > max_size)
	max_size = this_size;
    }
  return max_size;
}


/* Return the maximum number of literal bytes this opcode can generate.  */

static int
xg_get_max_insn_widen_literal_size (xtensa_opcode opcode)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int max_size = 0;

  gas_assert (opcode < table->num_opcodes);

  for (l = table->table[opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      BuildInstr *build_list;
      int this_size = 0;

      if (!rule)
	continue;
      build_list = rule->to_instr;
      if (is_unique_insn_expansion (rule))
	{
	  gas_assert (build_list->typ == INSTR_INSTR);
	  this_size = xg_get_max_insn_widen_literal_size (build_list->opcode);
	}
      else
	for (; build_list != NULL; build_list = build_list->next)
	  {
	    switch (build_list->typ)
	      {
	      case INSTR_LITERAL_DEF:
		/* Hard-coded 4-byte literal.  */
		this_size += 4;
		break;
	      case INSTR_INSTR:
	      case INSTR_LABEL_DEF:
	      default:
		break;
	      }
	  }
      if (this_size > max_size)
	max_size = this_size;
    }
  return max_size;
}


static bfd_boolean
xg_is_relaxable_insn (TInsn *insn, int lateral_steps)
{
  int steps_taken = 0;
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;

  gas_assert (insn->insn_type == ITYPE_INSN);
  gas_assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule))
	{
	  if (steps_taken == lateral_steps)
	    return TRUE;
	  steps_taken++;
	}
    }
  return FALSE;
}


static symbolS *
get_special_literal_symbol (void)
{
  static symbolS *sym = NULL;

  if (sym == NULL)
    sym = symbol_find_or_make ("SPECIAL_LITERAL0\001");
  return sym;
}


static symbolS *
get_special_label_symbol (void)
{
  static symbolS *sym = NULL;

  if (sym == NULL)
    sym = symbol_find_or_make ("SPECIAL_LABEL0\001");
  return sym;
}


static bfd_boolean
xg_valid_literal_expression (const expressionS *exp)
{
  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_big:
    case O_uminus:
    case O_subtract:
    case O_pltrel:
    case O_pcrel:
    case O_tlsfunc:
    case O_tlsarg:
    case O_tpoff:
    case O_dtpoff:
      return TRUE;
    default:
      return FALSE;
    }
}


/* This will check to see if the value can be converted into the
   operand type.  It will return TRUE if it does not fit.  */

static bfd_boolean
xg_check_operand (int32 value, xtensa_opcode opcode, int operand)
{
  uint32 valbuf = value;
  if (xtensa_operand_encode (xtensa_default_isa, opcode, operand, &valbuf))
    return TRUE;
  return FALSE;
}


/* Assumes: All immeds are constants.  Check that all constants fit
   into their immeds; return FALSE if not.  */

static bfd_boolean
xg_immeds_fit (const TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  int i;

  int n = insn->ntok;
  gas_assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < n; ++i)
    {
      const expressionS *exp = &insn->tok[i];

      if (xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	continue;

      switch (exp->X_op)
	{
	case O_register:
	case O_constant:
	  if (xg_check_operand (exp->X_add_number, insn->opcode, i))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  gas_assert (FALSE);
	  break;
	}
    }
  return TRUE;
}


/* This should only be called after we have an initial
   estimate of the addresses.  */

static bfd_boolean
xg_symbolic_immeds_fit (const TInsn *insn,
			segT pc_seg,
			fragS *pc_frag,
			offsetT pc_offset,
			long stretch)
{
  xtensa_isa isa = xtensa_default_isa;
  symbolS *symbolP;
  fragS *sym_frag;
  offsetT target, pc;
  uint32 new_offset;
  int i;
  int n = insn->ntok;

  gas_assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
    {
      const expressionS *exp = &insn->tok[i];

      if (xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	continue;

      switch (exp->X_op)
	{
	case O_register:
	case O_constant:
	  if (xg_check_operand (exp->X_add_number, insn->opcode, i))
	    return FALSE;
	  break;

	case O_lo16:
	case O_hi16:
	  /* Check for the worst case.  */
	  if (xg_check_operand (0xffff, insn->opcode, i))
	    return FALSE;
	  break;

	case O_symbol:
	  /* We only allow symbols for PC-relative references.
	     If pc_frag == 0, then we don't have frag locations yet.  */
	  if (pc_frag == 0
	      || xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 0)
	    return FALSE;

	  /* If it is a weak symbol or a symbol in a different section,
	     it cannot be known to fit at assembly time.  */
	  if (S_IS_WEAK (exp->X_add_symbol)
	      || S_GET_SEGMENT (exp->X_add_symbol) != pc_seg)
	    {
	      /* For a direct call with --no-longcalls, be optimistic and
		 assume it will be in range.  If the symbol is weak and
		 undefined, it may remain undefined at link-time, in which
		 case it will have a zero value and almost certainly be out
		 of range for a direct call; thus, relax for undefined weak
		 symbols even if longcalls is not enabled.  */
	      if (is_direct_call_opcode (insn->opcode)
		  && ! pc_frag->tc_frag_data.use_longcalls
		  && (! S_IS_WEAK (exp->X_add_symbol)
		      || S_IS_DEFINED (exp->X_add_symbol)))
		return TRUE;

	      return FALSE;
	    }

	  symbolP = exp->X_add_symbol;
	  sym_frag = symbol_get_frag (symbolP);
	  target = S_GET_VALUE (symbolP) + exp->X_add_number;
	  pc = pc_frag->fr_address + pc_offset;

	  /* If frag has yet to be reached on this pass, assume it
	     will move by STRETCH just as we did.  If this is not so,
	     it will be because some frag between grows, and that will
	     force another pass.  Beware zero-length frags.  There
	     should be a faster way to do this.  */

	  if (stretch != 0
	      && sym_frag->relax_marker != pc_frag->relax_marker
	      && S_GET_SEGMENT (symbolP) == pc_seg)
	    {
	      target += stretch;
	    }

	  new_offset = target;
	  xtensa_operand_do_reloc (isa, insn->opcode, i, &new_offset, pc);
	  if (xg_check_operand (new_offset, insn->opcode, i))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  return FALSE;
	}
    }

  return TRUE;
}


/* Return TRUE on success.  */

static bfd_boolean
xg_build_to_insn (TInsn *targ, TInsn *insn, BuildInstr *bi)
{
  BuildOp *op;
  symbolS *sym;

  tinsn_init (targ);
  targ->debug_line = insn->debug_line;
  targ->loc_directive_seen = insn->loc_directive_seen;
  switch (bi->typ)
    {
    case INSTR_INSTR:
      op = bi->ops;
      targ->opcode = bi->opcode;
      targ->insn_type = ITYPE_INSN;
      targ->is_specific_opcode = FALSE;

      for (; op != NULL; op = op->next)
	{
	  int op_num = op->op_num;
	  int op_data = op->op_data;

	  gas_assert (op->op_num < MAX_INSN_ARGS);

	  if (targ->ntok <= op_num)
	    targ->ntok = op_num + 1;

	  switch (op->typ)
	    {
	    case OP_CONSTANT:
	      set_expr_const (&targ->tok[op_num], op_data);
	      break;
	    case OP_OPERAND:
	      gas_assert (op_data < insn->ntok);
	      copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
	      break;
	    case OP_FREEREG:
	      if (insn->extra_arg.X_op != O_register)
		return FALSE;
	      copy_expr (&targ->tok[op_num], &insn->extra_arg);
	      break;
	    case OP_LITERAL:
	      sym = get_special_literal_symbol ();
	      set_expr_symbol_offset (&targ->tok[op_num], sym, 0);
	      if (insn->tok[op_data].X_op == O_tlsfunc
		  || insn->tok[op_data].X_op == O_tlsarg)
		copy_expr (&targ->extra_arg, &insn->tok[op_data]);
	      break;
	    case OP_LABEL:
	      sym = get_special_label_symbol ();
	      set_expr_symbol_offset (&targ->tok[op_num], sym, 0);
	      break;
	    case OP_OPERAND_HI16U:
	    case OP_OPERAND_LOW16U:
	      gas_assert (op_data < insn->ntok);
	      if (expr_is_const (&insn->tok[op_data]))
		{
		  long val;
		  copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
		  val = xg_apply_userdef_op_fn (op->typ,
						targ->tok[op_num].
						X_add_number);
		  targ->tok[op_num].X_add_number = val;
		}
	      else
		{
		  /* For const16 we can create relocations for these.  */
		  if (targ->opcode == XTENSA_UNDEFINED
		      || (targ->opcode != xtensa_const16_opcode))
		    return FALSE;
		  gas_assert (op_data < insn->ntok);
		  /* Need to build a O_lo16 or O_hi16.  */
		  copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
		  if (targ->tok[op_num].X_op == O_symbol)
		    {
		      if (op->typ == OP_OPERAND_HI16U)
			targ->tok[op_num].X_op = O_hi16;
		      else if (op->typ == OP_OPERAND_LOW16U)
			targ->tok[op_num].X_op = O_lo16;
		      else
			return FALSE;
		    }
		}
	      break;
	    default:
	      /* currently handles:
		 OP_OPERAND_LOW8
		 OP_OPERAND_HI24S
		 OP_OPERAND_F32MINUS */
	      if (xg_has_userdef_op_fn (op->typ))
		{
		  gas_assert (op_data < insn->ntok);
		  if (expr_is_const (&insn->tok[op_data]))
		    {
		      long val;
		      copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
		      val = xg_apply_userdef_op_fn (op->typ,
						    targ->tok[op_num].
						    X_add_number);
		      targ->tok[op_num].X_add_number = val;
		    }
		  else
		    return FALSE; /* We cannot use a relocation for this.  */
		  break;
		}
	      gas_assert (0);
	      break;
	    }
	}
      break;

    case INSTR_LITERAL_DEF:
      op = bi->ops;
      targ->opcode = XTENSA_UNDEFINED;
      targ->insn_type = ITYPE_LITERAL;
      targ->is_specific_opcode = FALSE;
      for (; op != NULL; op = op->next)
	{
	  int op_num = op->op_num;
	  int op_data = op->op_data;
	  gas_assert (op->op_num < MAX_INSN_ARGS);

	  if (targ->ntok <= op_num)
	    targ->ntok = op_num + 1;

	  switch (op->typ)
	    {
	    case OP_OPERAND:
	      gas_assert (op_data < insn->ntok);
	      /* We can only pass resolvable literals through.  */
	      if (!xg_valid_literal_expression (&insn->tok[op_data]))
		return FALSE;
	      copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
	      break;
	    case OP_LITERAL:
	    case OP_CONSTANT:
	    case OP_LABEL:
	    default:
	      gas_assert (0);
	      break;
	    }
	}
      break;

    case INSTR_LABEL_DEF:
      op = bi->ops;
      targ->opcode = XTENSA_UNDEFINED;
      targ->insn_type = ITYPE_LABEL;
      targ->is_specific_opcode = FALSE;
      /* Literal with no ops is a label?  */
      gas_assert (op == NULL);
      break;

    default:
      gas_assert (0);
    }

  return TRUE;
}


/* Return TRUE on success.  */

static bfd_boolean
xg_build_to_stack (IStack *istack, TInsn *insn, BuildInstr *bi)
{
  for (; bi != NULL; bi = bi->next)
    {
      TInsn *next_insn = istack_push_space (istack);

      if (!xg_build_to_insn (next_insn, insn, bi))
	return FALSE;
    }
  return TRUE;
}


/* Return TRUE on valid expansion.  */

static bfd_boolean
xg_expand_to_stack (IStack *istack, TInsn *insn, int lateral_steps)
{
  int stack_size = istack->ninsn;
  int steps_taken = 0;
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;

  gas_assert (insn->insn_type == ITYPE_INSN);
  gas_assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule))
	{
	  if (lateral_steps == steps_taken)
	    {
	      int i;

	      /* This is it.  Expand the rule to the stack.  */
	      if (!xg_build_to_stack (istack, insn, rule->to_instr))
		return FALSE;

	      /* Check to see if it fits.  */
	      for (i = stack_size; i < istack->ninsn; i++)
		{
		  TInsn *tinsn = &istack->insn[i];

		  if (tinsn->insn_type == ITYPE_INSN
		      && !tinsn_has_symbolic_operands (tinsn)
		      && !xg_immeds_fit (tinsn))
		    {
		      istack->ninsn = stack_size;
		      return FALSE;
		    }
		}
	      return TRUE;
	    }
	  steps_taken++;
	}
    }
  return FALSE;
}


/* Relax the assembly instruction at least "min_steps".
   Return the number of steps taken.

   For relaxation to correctly terminate, every relaxation chain must
   terminate in one of two ways:

   1.  If the chain from one instruction to the next consists entirely of
       single instructions, then the chain *must* handle all possible
       immediates without failing.  It must not ever fail because an
       immediate is out of range.  The MOVI.N -> MOVI -> L32R relaxation
       chain is one example.  L32R loads 32 bits, and there cannot be an
       immediate larger than 32 bits, so it satisfies this condition.
       Single instruction relaxation chains are as defined by
       xg_is_single_relaxable_instruction.

   2.  Otherwise, the chain must end in a multi-instruction expansion: e.g.,
       BNEZ.N -> BNEZ -> BNEZ.W15 -> BENZ.N/J

   Strictly speaking, in most cases you can violate condition 1 and be OK
   -- in particular when the last two instructions have the same single
   size.  But nevertheless, you should guarantee the above two conditions.

   We could fix this so that single-instruction expansions correctly
   terminate when they can't handle the range, but the error messages are
   worse, and it actually turns out that in every case but one (18-bit wide
   branches), you need a multi-instruction expansion to get the full range
   anyway.  And because 18-bit branches are handled identically to 15-bit
   branches, there isn't any point in changing it.  */

static int
xg_assembly_relax (IStack *istack,
		   TInsn *insn,
		   segT pc_seg,
		   fragS *pc_frag,	/* if pc_frag == 0, not pc-relative */
		   offsetT pc_offset,	/* offset in fragment */
		   int min_steps,	/* minimum conversion steps */
		   long stretch)	/* number of bytes stretched so far */
{
  int steps_taken = 0;

  /* Some of its immeds don't fit.  Try to build a relaxed version.
     This may go through a couple of stages of single instruction
     transformations before we get there.  */

  TInsn single_target;
  TInsn current_insn;
  int lateral_steps = 0;
  int istack_size = istack->ninsn;

  if (xg_symbolic_immeds_fit (insn, pc_seg, pc_frag, pc_offset, stretch)
      && steps_taken >= min_steps)
    {
      istack_push (istack, insn);
      return steps_taken;
    }
  current_insn = *insn;

  /* Walk through all of the single instruction expansions.  */
  while (xg_is_single_relaxable_insn (&current_insn, &single_target, FALSE))
    {
      steps_taken++;
      if (xg_symbolic_immeds_fit (&single_target, pc_seg, pc_frag, pc_offset,
				  stretch))
	{
	  if (steps_taken >= min_steps)
	    {
	      istack_push (istack, &single_target);
	      return steps_taken;
	    }
	}
      current_insn = single_target;
    }

  /* Now check for a multi-instruction expansion.  */
  while (xg_is_relaxable_insn (&current_insn, lateral_steps))
    {
      if (xg_symbolic_immeds_fit (&current_insn, pc_seg, pc_frag, pc_offset,
				  stretch))
	{
	  if (steps_taken >= min_steps)
	    {
	      istack_push (istack, &current_insn);
	      return steps_taken;
	    }
	}
      steps_taken++;
      if (xg_expand_to_stack (istack, &current_insn, lateral_steps))
	{
	  if (steps_taken >= min_steps)
	    return steps_taken;
	}
      lateral_steps++;
      istack->ninsn = istack_size;
    }

  /* It's not going to work -- use the original.  */
  istack_push (istack, insn);
  return steps_taken;
}


static void
xg_finish_frag (char *last_insn,
		enum xtensa_relax_statesE frag_state,
		enum xtensa_relax_statesE slot0_state,
		int max_growth,
		bfd_boolean is_insn)
{
  /* Finish off this fragment so that it has at LEAST the desired
     max_growth.  If it doesn't fit in this fragment, close this one
     and start a new one.  In either case, return a pointer to the
     beginning of the growth area.  */

  fragS *old_frag;

  frag_grow (max_growth);
  old_frag = frag_now;

  frag_now->fr_opcode = last_insn;
  if (is_insn)
    frag_now->tc_frag_data.is_insn = TRUE;

  frag_var (rs_machine_dependent, max_growth, max_growth,
	    frag_state, frag_now->fr_symbol, frag_now->fr_offset, last_insn);

  old_frag->tc_frag_data.slot_subtypes[0] = slot0_state;
  xtensa_set_frag_assembly_state (frag_now);

  /* Just to make sure that we did not split it up.  */
  gas_assert (old_frag->fr_next == frag_now);
}


/* Return TRUE if the target frag is one of the next non-empty frags.  */

static bfd_boolean
is_next_frag_target (const fragS *fragP, const fragS *target)
{
  if (fragP == NULL)
    return FALSE;

  for (; fragP; fragP = fragP->fr_next)
    {
      if (fragP == target)
	return TRUE;
      if (fragP->fr_fix != 0)
	return FALSE;
      if (fragP->fr_type == rs_fill && fragP->fr_offset != 0)
	return FALSE;
      if ((fragP->fr_type == rs_align || fragP->fr_type == rs_align_code)
	  && ((fragP->fr_address % (1 << fragP->fr_offset)) != 0))
	return FALSE;
      if (fragP->fr_type == rs_space)
	return FALSE;
    }
  return FALSE;
}


static bfd_boolean
is_branch_jmp_to_next (TInsn *insn, fragS *fragP)
{
  xtensa_isa isa = xtensa_default_isa;
  int i;
  int num_ops = xtensa_opcode_num_operands (isa, insn->opcode);
  int target_op = -1;
  symbolS *sym;
  fragS *target_frag;

  if (xtensa_opcode_is_branch (isa, insn->opcode) != 1
      && xtensa_opcode_is_jump (isa, insn->opcode) != 1)
    return FALSE;

  for (i = 0; i < num_ops; i++)
    {
      if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1)
	{
	  target_op = i;
	  break;
	}
    }
  if (target_op == -1)
    return FALSE;

  if (insn->ntok <= target_op)
    return FALSE;

  if (insn->tok[target_op].X_op != O_symbol)
    return FALSE;

  sym = insn->tok[target_op].X_add_symbol;
  if (sym == NULL)
    return FALSE;

  if (insn->tok[target_op].X_add_number != 0)
    return FALSE;

  target_frag = symbol_get_frag (sym);
  if (target_frag == NULL)
    return FALSE;

  if (is_next_frag_target (fragP->fr_next, target_frag)
      && S_GET_VALUE (sym) == target_frag->fr_address)
    return TRUE;

  return FALSE;
}


static void
xg_add_branch_and_loop_targets (TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  int num_ops = xtensa_opcode_num_operands (isa, insn->opcode);

  if (xtensa_opcode_is_loop (isa, insn->opcode) == 1)
    {
      int i = 1;
      if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1
	  && insn->tok[i].X_op == O_symbol)
	symbol_get_tc (insn->tok[i].X_add_symbol)->is_loop_target = TRUE;
      return;
    }

  if (xtensa_opcode_is_branch (isa, insn->opcode) == 1
      || xtensa_opcode_is_loop (isa, insn->opcode) == 1)
    {
      int i;

      for (i = 0; i < insn->ntok && i < num_ops; i++)
	{
	  if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1
	      && insn->tok[i].X_op == O_symbol)
	    {
	      symbolS *sym = insn->tok[i].X_add_symbol;
	      symbol_get_tc (sym)->is_branch_target = TRUE;
	      if (S_IS_DEFINED (sym))
		symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;
	    }
	}
    }
}


/* Return FALSE if no error.  */

static bfd_boolean
xg_build_token_insn (BuildInstr *instr_spec, TInsn *old_insn, TInsn *new_insn)
{
  int num_ops = 0;
  BuildOp *b_op;

  switch (instr_spec->typ)
    {
    case INSTR_INSTR:
      new_insn->insn_type = ITYPE_INSN;
      new_insn->opcode = instr_spec->opcode;
      break;
    case INSTR_LITERAL_DEF:
      new_insn->insn_type = ITYPE_LITERAL;
      new_insn->opcode = XTENSA_UNDEFINED;
      break;
    case INSTR_LABEL_DEF:
      abort ();
    }
  new_insn->is_specific_opcode = FALSE;
  new_insn->debug_line = old_insn->debug_line;
  new_insn->loc_directive_seen = old_insn->loc_directive_seen;

  for (b_op = instr_spec->ops; b_op != NULL; b_op = b_op->next)
    {
      expressionS *exp;
      const expressionS *src_exp;

      num_ops++;
      switch (b_op->typ)
	{
	case OP_CONSTANT:
	  /* The expression must be the constant.  */
	  gas_assert (b_op->op_num < MAX_INSN_ARGS);
	  exp = &new_insn->tok[b_op->op_num];
	  set_expr_const (exp, b_op->op_data);
	  break;

	case OP_OPERAND:
	  gas_assert (b_op->op_num < MAX_INSN_ARGS);
	  gas_assert (b_op->op_data < (unsigned) old_insn->ntok);
	  src_exp = &old_insn->tok[b_op->op_data];
	  exp = &new_insn->tok[b_op->op_num];
	  copy_expr (exp, src_exp);
	  break;

	case OP_LITERAL:
	case OP_LABEL:
	  as_bad (_("can't handle generation of literal/labels yet"));
	  gas_assert (0);

	default:
	  as_bad (_("can't handle undefined OP TYPE"));
	  gas_assert (0);
	}
    }

  new_insn->ntok = num_ops;
  return FALSE;
}


/* Return TRUE if it was simplified.  */

static bfd_boolean
xg_simplify_insn (TInsn *old_insn, TInsn *new_insn)
{
  TransitionRule *rule;
  BuildInstr *insn_spec;

  if (old_insn->is_specific_opcode || !density_supported)
    return FALSE;

  rule = xg_instruction_match (old_insn);
  if (rule == NULL)
    return FALSE;

  insn_spec = rule->to_instr;
  /* There should only be one.  */
  gas_assert (insn_spec != NULL);
  gas_assert (insn_spec->next == NULL);
  if (insn_spec->next != NULL)
    return FALSE;

  xg_build_token_insn (insn_spec, old_insn, new_insn);

  return TRUE;
}


/* xg_expand_assembly_insn: (1) Simplify the instruction, i.e., l32i ->
   l32i.n. (2) Check the number of operands.  (3) Place the instruction
   tokens into the stack or relax it and place multiple
   instructions/literals onto the stack.  Return FALSE if no error.  */

static bfd_boolean
xg_expand_assembly_insn (IStack *istack, TInsn *orig_insn)
{
  int noperands;
  TInsn new_insn;
  bfd_boolean do_expand;

  tinsn_init (&new_insn);

  /* Narrow it if we can.  xg_simplify_insn now does all the
     appropriate checking (e.g., for the density option).  */
  if (xg_simplify_insn (orig_insn, &new_insn))
    orig_insn = &new_insn;

  noperands = xtensa_opcode_num_operands (xtensa_default_isa,
					  orig_insn->opcode);
  if (orig_insn->ntok < noperands)
    {
      as_bad (_("found %d operands for '%s':  Expected %d"),
	      orig_insn->ntok,
	      xtensa_opcode_name (xtensa_default_isa, orig_insn->opcode),
	      noperands);
      return TRUE;
    }
  if (orig_insn->ntok > noperands)
    as_warn (_("found too many (%d) operands for '%s':  Expected %d"),
	     orig_insn->ntok,
	     xtensa_opcode_name (xtensa_default_isa, orig_insn->opcode),
	     noperands);

  /* If there are not enough operands, we will assert above.  If there
     are too many, just cut out the extras here.  */
  orig_insn->ntok = noperands;

  if (tinsn_has_invalid_symbolic_operands (orig_insn))
    return TRUE;

  /* Special case for extui opcode which has constraints not handled
     by the ordinary operand encoding checks.  The number of operands
     and related syntax issues have already been checked.  */
  if (orig_insn->opcode == xtensa_extui_opcode)
    {
      int shiftimm = orig_insn->tok[2].X_add_number;
      int maskimm = orig_insn->tok[3].X_add_number;
      if (shiftimm + maskimm > 32)
	{
	  as_bad (_("immediate operands sum to greater than 32"));
	  return TRUE;
	}
    }

  /* If the instruction will definitely need to be relaxed, it is better
     to expand it now for better scheduling.  Decide whether to expand
     now....  */
  do_expand = (!orig_insn->is_specific_opcode && use_transform ());

  /* Calls should be expanded to longcalls only in the backend relaxation
     so that the assembly scheduler will keep the L32R/CALLX instructions
     adjacent.  */
  if (is_direct_call_opcode (orig_insn->opcode))
    do_expand = FALSE;

  if (tinsn_has_symbolic_operands (orig_insn))
    {
      /* The values of symbolic operands are not known yet, so only expand
	 now if an operand is "complex" (e.g., difference of symbols) and
	 will have to be stored as a literal regardless of the value.  */
      if (!tinsn_has_complex_operands (orig_insn))
	do_expand = FALSE;
    }
  else if (xg_immeds_fit (orig_insn))
    do_expand = FALSE;

  if (do_expand)
    xg_assembly_relax (istack, orig_insn, 0, 0, 0, 0, 0);
  else
    istack_push (istack, orig_insn);

  return FALSE;
}


/* Return TRUE if the section flags are marked linkonce
   or the name is .gnu.linkonce.*.  */

static int linkonce_len = sizeof (".gnu.linkonce.") - 1;

static bfd_boolean
get_is_linkonce_section (bfd *abfd ATTRIBUTE_UNUSED, segT sec)
{
  flagword flags, link_once_flags;

  flags = bfd_get_section_flags (abfd, sec);
  link_once_flags = (flags & SEC_LINK_ONCE);

  /* Flags might not be set yet.  */
  if (!link_once_flags
      && strncmp (segment_name (sec), ".gnu.linkonce.", linkonce_len) == 0)
    link_once_flags = SEC_LINK_ONCE;

  return (link_once_flags != 0);
}


static void
xtensa_add_literal_sym (symbolS *sym)
{
  sym_list *l;

  l = (sym_list *) xmalloc (sizeof (sym_list));
  l->sym = sym;
  l->next = literal_syms;
  literal_syms = l;
}


static symbolS *
xtensa_create_literal_symbol (segT sec, fragS *frag)
{
  static int lit_num = 0;
  static char name[256];
  symbolS *symbolP;

  sprintf (name, ".L_lit_sym%d", lit_num);

  /* Create a local symbol.  If it is in a linkonce section, we have to
     be careful to make sure that if it is used in a relocation that the
     symbol will be in the output file.  */
  if (get_is_linkonce_section (stdoutput, sec))
    {
      symbolP = symbol_new (name, sec, 0, frag);
      S_CLEAR_EXTERNAL (symbolP);
      /* symbolP->local = 1; */
    }
  else
    symbolP = symbol_new (name, sec, 0, frag);

  xtensa_add_literal_sym (symbolP);

  lit_num++;
  return symbolP;
}


/* Currently all literals that are generated here are 32-bit L32R targets.  */

static symbolS *
xg_assemble_literal (/* const */ TInsn *insn)
{
  emit_state state;
  symbolS *lit_sym = NULL;
  bfd_reloc_code_real_type reloc;
  bfd_boolean pcrel = FALSE;
  char *p;

  /* size = 4 for L32R.  It could easily be larger when we move to
     larger constants.  Add a parameter later.  */
  offsetT litsize = 4;
  offsetT litalign = 2;		/* 2^2 = 4 */
  expressionS saved_loc;
  expressionS * emit_val;

  set_expr_symbol_offset (&saved_loc, frag_now->fr_symbol, frag_now_fix ());

  gas_assert (insn->insn_type == ITYPE_LITERAL);
  gas_assert (insn->ntok == 1);	/* must be only one token here */

  xtensa_switch_to_literal_fragment (&state);

  emit_val = &insn->tok[0];
  if (emit_val->X_op == O_big)
    {
      int size = emit_val->X_add_number * CHARS_PER_LITTLENUM;
      if (size > litsize)
	{
	  /* This happens when someone writes a "movi a2, big_number".  */
	  as_bad_where (frag_now->fr_file, frag_now->fr_line,
			_("invalid immediate"));
	  xtensa_restore_emit_state (&state);
	  return NULL;
	}
    }

  /* Force a 4-byte align here.  Note that this opens a new frag, so all
     literals done with this function have a frag to themselves.  That's
     important for the way text section literals work.  */
  frag_align (litalign, 0, 0);
  record_alignment (now_seg, litalign);

  switch (emit_val->X_op)
    {
    case O_pcrel:
      pcrel = TRUE;
      /* fall through */
    case O_pltrel:
    case O_tlsfunc:
    case O_tlsarg:
    case O_tpoff:
    case O_dtpoff:
      p = frag_more (litsize);
      xtensa_set_frag_assembly_state (frag_now);
      reloc = map_operator_to_reloc (emit_val->X_op, TRUE);
      if (emit_val->X_add_symbol)
	emit_val->X_op = O_symbol;
      else
	emit_val->X_op = O_constant;
      fix_new_exp (frag_now, p - frag_now->fr_literal,
		   litsize, emit_val, pcrel, reloc);
      break;

    default:
      emit_expr (emit_val, litsize);
      break;
    }

  gas_assert (frag_now->tc_frag_data.literal_frag == NULL);
  frag_now->tc_frag_data.literal_frag = get_literal_pool_location (now_seg);
  frag_now->fr_symbol = xtensa_create_literal_symbol (now_seg, frag_now);
  lit_sym = frag_now->fr_symbol;

  /* Go back.  */
  xtensa_restore_emit_state (&state);
  return lit_sym;
}


static void
xg_assemble_literal_space (/* const */ int size, int slot)
{
  emit_state state;
  /* We might have to do something about this alignment.  It only
     takes effect if something is placed here.  */
  offsetT litalign = 2;		/* 2^2 = 4 */
  fragS *lit_saved_frag;

  gas_assert (size % 4 == 0);

  xtensa_switch_to_literal_fragment (&state);

  /* Force a 4-byte align here.  */
  frag_align (litalign, 0, 0);
  record_alignment (now_seg, litalign);

  frag_grow (size);

  lit_saved_frag = frag_now;
  frag_now->tc_frag_data.literal_frag = get_literal_pool_location (now_seg);
  frag_now->fr_symbol = xtensa_create_literal_symbol (now_seg, frag_now);
  xg_finish_frag (0, RELAX_LITERAL, 0, size, FALSE);

  /* Go back.  */
  xtensa_restore_emit_state (&state);
  frag_now->tc_frag_data.literal_frags[slot] = lit_saved_frag;
}


/* Put in a fixup record based on the opcode.
   Return TRUE on success.  */

static bfd_boolean
xg_add_opcode_fix (TInsn *tinsn,
		   int opnum,
		   xtensa_format fmt,
		   int slot,
		   expressionS *exp,
		   fragS *fragP,
		   offsetT offset)
{
  xtensa_opcode opcode = tinsn->opcode;
  bfd_reloc_code_real_type reloc;
  reloc_howto_type *howto;
  int fmt_length;
  fixS *the_fix;

  reloc = BFD_RELOC_NONE;

  /* First try the special cases for "alternate" relocs.  */
  if (opcode == xtensa_l32r_opcode)
    {
      if (fragP->tc_frag_data.use_absolute_literals)
	reloc = encode_alt_reloc (slot);
    }
  else if (opcode == xtensa_const16_opcode)
    {
      if (exp->X_op == O_lo16)
	{
	  reloc = encode_reloc (slot);
	  exp->X_op = O_symbol;
	}
      else if (exp->X_op == O_hi16)
	{
	  reloc = encode_alt_reloc (slot);
	  exp->X_op = O_symbol;
	}
    }

  if (opnum != get_relaxable_immed (opcode))
    {
      as_bad (_("invalid relocation for operand %i of '%s'"),
	      opnum + 1, xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }

  /* Handle erroneous "@@h" and "@@l" expressions here before they propagate
     into the symbol table where the generic portions of the assembler
     won't know what to do with them.  */
  if (exp->X_op == O_lo16 || exp->X_op == O_hi16)
    {
      as_bad (_("invalid expression for operand %i of '%s'"),
	      opnum + 1, xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }

  /* Next try the generic relocs.  */
  if (reloc == BFD_RELOC_NONE)
    reloc = encode_reloc (slot);
  if (reloc == BFD_RELOC_NONE)
    {
      as_bad (_("invalid relocation in instruction slot %i"), slot);
      return FALSE;
    }

  howto = bfd_reloc_type_lookup (stdoutput, reloc);
  if (!howto)
    {
      as_bad (_("undefined symbol for opcode \"%s\""),
	      xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }

  fmt_length = xtensa_format_length (xtensa_default_isa, fmt);
  the_fix = fix_new_exp (fragP, offset, fmt_length, exp,
			 howto->pc_relative, reloc);
  the_fix->fx_no_overflow = 1;
  the_fix->tc_fix_data.X_add_symbol = exp->X_add_symbol;
  the_fix->tc_fix_data.X_add_number = exp->X_add_number;
  the_fix->tc_fix_data.slot = slot;

  return TRUE;
}


static bfd_boolean
xg_emit_insn_to_buf (TInsn *tinsn,
		     char *buf,
		     fragS *fragP,
		     offsetT offset,
		     bfd_boolean build_fix)
{
  static xtensa_insnbuf insnbuf = NULL;
  bfd_boolean has_symbolic_immed = FALSE;
  bfd_boolean ok = TRUE;

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  has_symbolic_immed = tinsn_to_insnbuf (tinsn, insnbuf);
  if (has_symbolic_immed && build_fix)
    {
      /* Add a fixup.  */
      xtensa_format fmt = xg_get_single_format (tinsn->opcode);
      int slot = xg_get_single_slot (tinsn->opcode);
      int opnum = get_relaxable_immed (tinsn->opcode);
      expressionS *exp = &tinsn->tok[opnum];

      if (!xg_add_opcode_fix (tinsn, opnum, fmt, slot, exp, fragP, offset))
	ok = FALSE;
    }
  fragP->tc_frag_data.is_insn = TRUE;
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf,
			   (unsigned char *) buf, 0);
  return ok;
}


static void
xg_resolve_literals (TInsn *insn, symbolS *lit_sym)
{
  symbolS *sym = get_special_literal_symbol ();
  int i;
  if (lit_sym == 0)
    return;
  gas_assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < insn->ntok; i++)
    if (insn->tok[i].X_add_symbol == sym)
      insn->tok[i].X_add_symbol = lit_sym;

}


static void
xg_resolve_labels (TInsn *insn, symbolS *label_sym)
{
  symbolS *sym = get_special_label_symbol ();
  int i;
  for (i = 0; i < insn->ntok; i++)
    if (insn->tok[i].X_add_symbol == sym)
      insn->tok[i].X_add_symbol = label_sym;

}


/* Return TRUE if the instruction can write to the specified
   integer register.  */

static bfd_boolean
is_register_writer (const TInsn *insn, const char *regset, int regnum)
{
  int i;
  int num_ops;
  xtensa_isa isa = xtensa_default_isa;

  num_ops = xtensa_opcode_num_operands (isa, insn->opcode);

  for (i = 0; i < num_ops; i++)
    {
      char inout;
      inout = xtensa_operand_inout (isa, insn->opcode, i);
      if ((inout == 'o' || inout == 'm')
	  && xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	{
	  xtensa_regfile opnd_rf =
	    xtensa_operand_regfile (isa, insn->opcode, i);
	  if (!strcmp (xtensa_regfile_shortname (isa, opnd_rf), regset))
	    {
	      if ((insn->tok[i].X_op == O_register)
		  && (insn->tok[i].X_add_number == regnum))
		return TRUE;
	    }
	}
    }
  return FALSE;
}


static bfd_boolean
is_bad_loopend_opcode (const TInsn *tinsn)
{
  xtensa_opcode opcode = tinsn->opcode;

  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  if (opcode == xtensa_call0_opcode
      || opcode == xtensa_callx0_opcode
      || opcode == xtensa_call4_opcode
      || opcode == xtensa_callx4_opcode
      || opcode == xtensa_call8_opcode
      || opcode == xtensa_callx8_opcode
      || opcode == xtensa_call12_opcode
      || opcode == xtensa_callx12_opcode
      || opcode == xtensa_isync_opcode
      || opcode == xtensa_ret_opcode
      || opcode == xtensa_ret_n_opcode
      || opcode == xtensa_retw_opcode
      || opcode == xtensa_retw_n_opcode
      || opcode == xtensa_waiti_opcode
      || opcode == xtensa_rsr_lcount_opcode)
    return TRUE;

  return FALSE;
}


/* Labels that begin with ".Ln" or ".LM"  are unaligned.
   This allows the debugger to add unaligned labels.
   Also, the assembler generates stabs labels that need
   not be aligned:  FAKE_LABEL_NAME . {"F", "L", "endfunc"}.  */

static bfd_boolean
is_unaligned_label (symbolS *sym)
{
  const char *name = S_GET_NAME (sym);
  static size_t fake_size = 0;

  if (name
      && name[0] == '.'
      && name[1] == 'L' && (name[2] == 'n' || name[2] == 'M'))
    return TRUE;

  /* FAKE_LABEL_NAME followed by "F", "L" or "endfunc" */
  if (fake_size == 0)
    fake_size = strlen (FAKE_LABEL_NAME);

  if (name
      && strncmp (FAKE_LABEL_NAME, name, fake_size) == 0
      && (name[fake_size] == 'F'
	  || name[fake_size] == 'L'
	  || (name[fake_size] == 'e'
	      && strncmp ("endfunc", name+fake_size, 7) == 0)))
    return TRUE;

  return FALSE;
}


static fragS *
next_non_empty_frag (const fragS *fragP)
{
  fragS *next_fragP = fragP->fr_next;

  /* Sometimes an empty will end up here due storage allocation issues.
     So we have to skip until we find something legit.  */
  while (next_fragP && next_fragP->fr_fix == 0)
    next_fragP = next_fragP->fr_next;

  if (next_fragP == NULL || next_fragP->fr_fix == 0)
    return NULL;

  return next_fragP;
}


static bfd_boolean
next_frag_opcode_is_loop (const fragS *fragP, xtensa_opcode *opcode)
{
  xtensa_opcode out_opcode;
  const fragS *next_fragP = next_non_empty_frag (fragP);

  if (next_fragP == NULL)
    return FALSE;

  out_opcode = get_opcode_from_buf (next_fragP->fr_literal, 0);
  if (xtensa_opcode_is_loop (xtensa_default_isa, out_opcode) == 1)
    {
      *opcode = out_opcode;
      return TRUE;
    }
  return FALSE;
}


static int
frag_format_size (const fragS *fragP)
{
  static xtensa_insnbuf insnbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  int fmt_size;

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  if (fragP == NULL)
    return XTENSA_UNDEFINED;

  xtensa_insnbuf_from_chars (isa, insnbuf,
			     (unsigned char *) fragP->fr_literal, 0);

  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;
  fmt_size = xtensa_format_length (isa, fmt);

  /* If the next format won't be changing due to relaxation, just
     return the length of the first format.  */
  if (fragP->fr_opcode != fragP->fr_literal)
    return fmt_size;

  /* If during relaxation we have to pull an instruction out of a
     multi-slot instruction, we will return the more conservative
     number.  This works because alignment on bigger instructions
     is more restrictive than alignment on smaller instructions.
     This is more conservative than we would like, but it happens
     infrequently.  */

  if (xtensa_format_num_slots (xtensa_default_isa, fmt) > 1)
    return fmt_size;

  /* If we aren't doing one of our own relaxations or it isn't
     slot-based, then the insn size won't change.  */
  if (fragP->fr_type != rs_machine_dependent)
    return fmt_size;
  if (fragP->fr_subtype != RELAX_SLOTS)
    return fmt_size;

  /* If an instruction is about to grow, return the longer size.  */
  if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED_STEP1
      || fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED_STEP2
      || fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED_STEP3)
    {
      /* For most frags at RELAX_IMMED_STEPX, with X > 0, the first
	 instruction in the relaxed version is of length 3.  (The case
	 where we have to pull the instruction out of a FLIX bundle
	 is handled conservatively above.)  However, frags with opcodes
	 that are expanding to wide branches end up having formats that
	 are not determinable by the RELAX_IMMED_STEPX enumeration, and
	 we can't tell directly what format the relaxer picked.  This
	 is a wart in the design of the relaxer that should someday be
	 fixed, but would require major changes, or at least should
	 be accompanied by major changes to make use of that data.

	 In any event, we can tell that we are expanding from a single-slot
	 format to a wider one with the logic below.  */

      int i;
      int relaxed_size = fmt_size + fragP->tc_frag_data.text_expansion[0];

      for (i = 0; i < xtensa_isa_num_formats (isa); i++)
	{
	  if (relaxed_size == xtensa_format_length (isa, i))
	    return relaxed_size;
	}

      return 3;
    }

  if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
    return 2 + fragP->tc_frag_data.text_expansion[0];

  return fmt_size;
}


static int
next_frag_format_size (const fragS *fragP)
{
  const fragS *next_fragP = next_non_empty_frag (fragP);
  return frag_format_size (next_fragP);
}


/* In early Xtensa Processors, for reasons that are unclear, the ISA
   required two-byte instructions to be treated as three-byte instructions
   for loop instruction alignment.  This restriction was removed beginning
   with Xtensa LX.  Now the only requirement on loop instruction alignment
   is that the first instruction of the loop must appear at an address that
   does not cross a fetch boundary.  */

static int
get_loop_align_size (int insn_size)
{
  if (insn_size == XTENSA_UNDEFINED)
    return xtensa_fetch_width;

  if (enforce_three_byte_loop_align && insn_size == 2)
    return 3;

  return insn_size;
}


/* If the next legit fragment is an end-of-loop marker,
   switch its state so it will instantiate a NOP.  */

static void
update_next_frag_state (fragS *fragP)
{
  fragS *next_fragP = fragP->fr_next;
  fragS *new_target = NULL;

  if (align_targets)
    {
      /* We are guaranteed there will be one of these...   */
      while (!(next_fragP->fr_type == rs_machine_dependent
	       && (next_fragP->fr_subtype == RELAX_MAYBE_UNREACHABLE
		   || next_fragP->fr_subtype == RELAX_UNREACHABLE)))
	next_fragP = next_fragP->fr_next;

      gas_assert (next_fragP->fr_type == rs_machine_dependent
	      && (next_fragP->fr_subtype == RELAX_MAYBE_UNREACHABLE
		  || next_fragP->fr_subtype == RELAX_UNREACHABLE));

      /* ...and one of these.  */
      new_target = next_fragP->fr_next;
      while (!(new_target->fr_type == rs_machine_dependent
	       && (new_target->fr_subtype == RELAX_MAYBE_DESIRE_ALIGN
		   || new_target->fr_subtype == RELAX_DESIRE_ALIGN)))
	new_target = new_target->fr_next;

      gas_assert (new_target->fr_type == rs_machine_dependent
	      && (new_target->fr_subtype == RELAX_MAYBE_DESIRE_ALIGN
		  || new_target->fr_subtype == RELAX_DESIRE_ALIGN));
    }

  while (next_fragP && next_fragP->fr_fix == 0)
    {
      if (next_fragP->fr_type == rs_machine_dependent
	  && next_fragP->fr_subtype == RELAX_LOOP_END)
	{
	  next_fragP->fr_subtype = RELAX_LOOP_END_ADD_NOP;
	  return;
	}

      next_fragP = next_fragP->fr_next;
    }
}


static bfd_boolean
next_frag_is_branch_target (const fragS *fragP)
{
  /* Sometimes an empty will end up here due to storage allocation issues,
     so we have to skip until we find something legit.  */
  for (fragP = fragP->fr_next; fragP; fragP = fragP->fr_next)
    {
      if (fragP->tc_frag_data.is_branch_target)
	return TRUE;
      if (fragP->fr_fix != 0)
	break;
    }
  return FALSE;
}


static bfd_boolean
next_frag_is_loop_target (const fragS *fragP)
{
  /* Sometimes an empty will end up here due storage allocation issues.
     So we have to skip until we find something legit. */
  for (fragP = fragP->fr_next; fragP; fragP = fragP->fr_next)
    {
      if (fragP->tc_frag_data.is_loop_target)
	return TRUE;
      if (fragP->fr_fix != 0)
	break;
    }
  return FALSE;
}


/* As specified in the relaxation table, when a loop instruction is
   relaxed, there are 24 bytes between the loop instruction itself and
   the first instruction in the loop.  */

#define RELAXED_LOOP_INSN_BYTES 24

static addressT
next_frag_pre_opcode_bytes (const fragS *fragp)
{
  const fragS *next_fragp = fragp->fr_next;
  xtensa_opcode next_opcode;

  if (!next_frag_opcode_is_loop (fragp, &next_opcode))
    return 0;

  /* Sometimes an empty will end up here due to storage allocation issues,
     so we have to skip until we find something legit.  */
  while (next_fragp->fr_fix == 0)
    next_fragp = next_fragp->fr_next;

  if (next_fragp->fr_type != rs_machine_dependent)
    return 0;

  /* There is some implicit knowledge encoded in here.
     The LOOP instructions that are NOT RELAX_IMMED have
     been relaxed.  Note that we can assume that the LOOP
     instruction is in slot 0 because loops aren't bundleable.  */
  if (next_fragp->tc_frag_data.slot_subtypes[0] > RELAX_IMMED)
      return get_expanded_loop_offset (next_opcode) + RELAXED_LOOP_INSN_BYTES;

  return 0;
}


/* Mark a location where we can later insert literal frags.  Update
   the section's literal_pool_loc, so subsequent literals can be
   placed nearest to their use.  */

static void
xtensa_mark_literal_pool_location (void)
{
  /* Any labels pointing to the current location need
     to be adjusted to after the literal pool.  */
  emit_state s;
  fragS *pool_location;

  if (use_literal_section)
    return;

  /* We stash info in these frags so we can later move the literal's
     fixes into this frchain's fix list.  */
  pool_location = frag_now;
  frag_now->tc_frag_data.lit_frchain = frchain_now;
  frag_now->tc_frag_data.literal_frag = frag_now;
  frag_variant (rs_machine_dependent, 0, 0,
		RELAX_LITERAL_POOL_BEGIN, NULL, 0, NULL);
  xtensa_set_frag_assembly_state (frag_now);
  frag_now->tc_frag_data.lit_seg = now_seg;
  frag_variant (rs_machine_dependent, 0, 0,
		RELAX_LITERAL_POOL_END, NULL, 0, NULL);
  xtensa_set_frag_assembly_state (frag_now);

  /* Now put a frag into the literal pool that points to this location.  */
  set_literal_pool_location (now_seg, pool_location);
  xtensa_switch_to_non_abs_literal_fragment (&s);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  /* Close whatever frag is there.  */
  frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
  xtensa_set_frag_assembly_state (frag_now);
  frag_now->tc_frag_data.literal_frag = pool_location;
  frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
  xtensa_restore_emit_state (&s);
  xtensa_set_frag_assembly_state (frag_now);
}


/* Build a nop of the correct size into tinsn.  */

static void
build_nop (TInsn *tinsn, int size)
{
  tinsn_init (tinsn);
  switch (size)
    {
    case 2:
      tinsn->opcode = xtensa_nop_n_opcode;
      tinsn->ntok = 0;
      if (tinsn->opcode == XTENSA_UNDEFINED)
	as_fatal (_("opcode 'NOP.N' unavailable in this configuration"));
      break;

    case 3:
      if (xtensa_nop_opcode == XTENSA_UNDEFINED)
	{
	  tinsn->opcode = xtensa_or_opcode;
	  set_expr_const (&tinsn->tok[0], 1);
	  set_expr_const (&tinsn->tok[1], 1);
	  set_expr_const (&tinsn->tok[2], 1);
	  tinsn->ntok = 3;
	}
      else
	tinsn->opcode = xtensa_nop_opcode;

      gas_assert (tinsn->opcode != XTENSA_UNDEFINED);
    }
}


/* Assemble a NOP of the requested size in the buffer.  User must have
   allocated "buf" with at least "size" bytes.  */

static void
assemble_nop (int size, char *buf)
{
  static xtensa_insnbuf insnbuf = NULL;
  TInsn tinsn;

  build_nop (&tinsn, size);

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  tinsn_to_insnbuf (&tinsn, insnbuf);
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf,
			   (unsigned char *) buf, 0);
}


/* Return the number of bytes for the offset of the expanded loop
   instruction.  This should be incorporated into the relaxation
   specification but is hard-coded here.  This is used to auto-align
   the loop instruction.  It is invalid to call this function if the
   configuration does not have loops or if the opcode is not a loop
   opcode.  */

static addressT
get_expanded_loop_offset (xtensa_opcode opcode)
{
  /* This is the OFFSET of the loop instruction in the expanded loop.
     This MUST correspond directly to the specification of the loop
     expansion.  It will be validated on fragment conversion.  */
  gas_assert (opcode != XTENSA_UNDEFINED);
  if (opcode == xtensa_loop_opcode)
    return 0;
  if (opcode == xtensa_loopnez_opcode)
    return 3;
  if (opcode == xtensa_loopgtz_opcode)
    return 6;
  as_fatal (_("get_expanded_loop_offset: invalid opcode"));
  return 0;
}


static fragS *
get_literal_pool_location (segT seg)
{
  return seg_info (seg)->tc_segment_info_data.literal_pool_loc;
}


static void
set_literal_pool_location (segT seg, fragS *literal_pool_loc)
{
  seg_info (seg)->tc_segment_info_data.literal_pool_loc = literal_pool_loc;
}


/* Set frag assembly state should be called when a new frag is
   opened and after a frag has been closed.  */

static void
xtensa_set_frag_assembly_state (fragS *fragP)
{
  if (!density_supported)
    fragP->tc_frag_data.is_no_density = TRUE;

  /* This function is called from subsegs_finish, which is called
     after xtensa_end, so we can't use "use_transform" or
     "use_schedule" here.  */
  if (!directive_state[directive_transform])
    fragP->tc_frag_data.is_no_transform = TRUE;
  if (directive_state[directive_longcalls])
    fragP->tc_frag_data.use_longcalls = TRUE;
  fragP->tc_frag_data.use_absolute_literals =
    directive_state[directive_absolute_literals];
  fragP->tc_frag_data.is_assembly_state_set = TRUE;
}


static bfd_boolean
relaxable_section (asection *sec)
{
  return ((sec->flags & SEC_DEBUGGING) == 0
	  && strcmp (sec->name, ".eh_frame") != 0);
}


static void
xtensa_mark_frags_for_org (void)
{
  segT *seclist;

  /* Walk over each fragment of all of the current segments.  If we find
     a .org frag in any of the segments, mark all frags prior to it as
     "no transform", which will prevent linker optimizations from messing
     up the .org distance.  This should be done after
     xtensa_find_unmarked_state_frags, because we don't want to worry here
     about that function trashing the data we save here.  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segT sec = *seclist;
      segment_info_type *seginfo;
      fragS *fragP;
      flagword flags;
      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
	continue;

      seginfo = seg_info (sec);
      if (seginfo && seginfo->frchainP)
	{
	  fragS *last_fragP = seginfo->frchainP->frch_root;
	  for (fragP = seginfo->frchainP->frch_root; fragP;
	       fragP = fragP->fr_next)
	    {
	      /* cvt_frag_to_fill has changed the fr_type of org frags to
		 rs_fill, so use the value as cached in rs_subtype here.  */
	      if (fragP->fr_subtype == RELAX_ORG)
		{
		  while (last_fragP != fragP->fr_next)
		    {
		      last_fragP->tc_frag_data.is_no_transform = TRUE;
		      last_fragP = last_fragP->fr_next;
		    }
		}
	    }
	}
    }
}


static void
xtensa_find_unmarked_state_frags (void)
{
  segT *seclist;

  /* Walk over each fragment of all of the current segments.  For each
     unmarked fragment, mark it with the same info as the previous
     fragment.  */
  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segT sec = *seclist;
      segment_info_type *seginfo;
      fragS *fragP;
      flagword flags;
      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
	continue;

      seginfo = seg_info (sec);
      if (seginfo && seginfo->frchainP)
	{
	  fragS *last_fragP = 0;
	  for (fragP = seginfo->frchainP->frch_root; fragP;
	       fragP = fragP->fr_next)
	    {
	      if (fragP->fr_fix != 0
		  && !fragP->tc_frag_data.is_assembly_state_set)
		{
		  if (last_fragP == 0)
		    {
		      as_warn_where (fragP->fr_file, fragP->fr_line,
				     _("assembly state not set for first frag in section %s"),
				     sec->name);
		    }
		  else
		    {
		      fragP->tc_frag_data.is_assembly_state_set = TRUE;
		      fragP->tc_frag_data.is_no_density =
			last_fragP->tc_frag_data.is_no_density;
		      fragP->tc_frag_data.is_no_transform =
			last_fragP->tc_frag_data.is_no_transform;
		      fragP->tc_frag_data.use_longcalls =
			last_fragP->tc_frag_data.use_longcalls;
		      fragP->tc_frag_data.use_absolute_literals =
			last_fragP->tc_frag_data.use_absolute_literals;
		    }
		}
	      if (fragP->tc_frag_data.is_assembly_state_set)
		last_fragP = fragP;
	    }
	}
    }
}


static void
xtensa_find_unaligned_branch_targets (bfd *abfd ATTRIBUTE_UNUSED,
				      asection *sec,
				      void *unused ATTRIBUTE_UNUSED)
{
  flagword flags = bfd_get_section_flags (abfd, sec);
  segment_info_type *seginfo = seg_info (sec);
  fragS *frag = seginfo->frchainP->frch_root;

  if (flags & SEC_CODE)
    {
      xtensa_isa isa = xtensa_default_isa;
      xtensa_insnbuf insnbuf = xtensa_insnbuf_alloc (isa);
      while (frag != NULL)
	{
	  if (frag->tc_frag_data.is_branch_target)
	    {
	      int op_size;
	      addressT branch_align, frag_addr;
	      xtensa_format fmt;

	      xtensa_insnbuf_from_chars
		(isa, insnbuf, (unsigned char *) frag->fr_literal, 0);
	      fmt = xtensa_format_decode (isa, insnbuf);
	      op_size = xtensa_format_length (isa, fmt);
	      branch_align = 1 << branch_align_power (sec);
	      frag_addr = frag->fr_address % branch_align;
	      if (frag_addr + op_size > branch_align)
		as_warn_where (frag->fr_file, frag->fr_line,
			       _("unaligned branch target: %d bytes at 0x%lx"),
			       op_size, (long) frag->fr_address);
	    }
	  frag = frag->fr_next;
	}
      xtensa_insnbuf_free (isa, insnbuf);
    }
}


static void
xtensa_find_unaligned_loops (bfd *abfd ATTRIBUTE_UNUSED,
			     asection *sec,
			     void *unused ATTRIBUTE_UNUSED)
{
  flagword flags = bfd_get_section_flags (abfd, sec);
  segment_info_type *seginfo = seg_info (sec);
  fragS *frag = seginfo->frchainP->frch_root;
  xtensa_isa isa = xtensa_default_isa;

  if (flags & SEC_CODE)
    {
      xtensa_insnbuf insnbuf = xtensa_insnbuf_alloc (isa);
      while (frag != NULL)
	{
	  if (frag->tc_frag_data.is_first_loop_insn)
	    {
	      int op_size;
	      addressT frag_addr;
	      xtensa_format fmt;

	      if (frag->fr_fix == 0)
		frag = next_non_empty_frag (frag);
	      
	      if (frag)
		{
		  xtensa_insnbuf_from_chars
		    (isa, insnbuf, (unsigned char *) frag->fr_literal, 0);
		  fmt = xtensa_format_decode (isa, insnbuf);
		  op_size = xtensa_format_length (isa, fmt);
		  frag_addr = frag->fr_address % xtensa_fetch_width;
		  
		  if (frag_addr + op_size > xtensa_fetch_width)
		    as_warn_where (frag->fr_file, frag->fr_line,
				   _("unaligned loop: %d bytes at 0x%lx"),
				   op_size, (long) frag->fr_address);
		}
	    }
	  frag = frag->fr_next;
	}
      xtensa_insnbuf_free (isa, insnbuf);
    }
}


static int
xg_apply_fix_value (fixS *fixP, valueT val)
{
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_format fmt;
  int slot;
  bfd_boolean alt_reloc;
  xtensa_opcode opcode;
  char *const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;

  if (decode_reloc (fixP->fx_r_type, &slot, &alt_reloc)
      || alt_reloc)
    as_fatal (_("unexpected fix"));

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, (unsigned char *) fixpos, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("undecodable fix"));
  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);
  if (opcode == XTENSA_UNDEFINED)
    as_fatal (_("undecodable fix"));

  /* CONST16 immediates are not PC-relative, despite the fact that we
     reuse the normal PC-relative operand relocations for the low part
     of a CONST16 operand.  */
  if (opcode == xtensa_const16_opcode)
    return 0;

  xtensa_insnbuf_set_operand (slotbuf, fmt, slot, opcode,
			      get_relaxable_immed (opcode), val,
			      fixP->fx_file, fixP->fx_line);

  xtensa_format_set_slot (isa, fmt, slot, insnbuf, slotbuf);
  xtensa_insnbuf_to_chars (isa, insnbuf, (unsigned char *) fixpos, 0);

  return 1;
}


/* External Functions and Other GAS Hooks.  */

const char *
xtensa_target_format (void)
{
  return (target_big_endian ? "elf32-xtensa-be" : "elf32-xtensa-le");
}


void
xtensa_file_arch_init (bfd *abfd)
{
  bfd_set_private_flags (abfd, 0x100 | 0x200);
}


void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}


/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will
   need.  */

void
md_begin (void)
{
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  xtensa_isa isa;
  int i;

  xtensa_default_isa = xtensa_isa_init (0, 0);
  isa = xtensa_default_isa;

  linkrelax = 1;

  /* Set up the literal sections.  */
  memset (&default_lit_sections, 0, sizeof (default_lit_sections));

  subseg_set (current_section, current_subsec);

  xtensa_addi_opcode = xtensa_opcode_lookup (isa, "addi");
  xtensa_addmi_opcode = xtensa_opcode_lookup (isa, "addmi");
  xtensa_call0_opcode = xtensa_opcode_lookup (isa, "call0");
  xtensa_call4_opcode = xtensa_opcode_lookup (isa, "call4");
  xtensa_call8_opcode = xtensa_opcode_lookup (isa, "call8");
  xtensa_call12_opcode = xtensa_opcode_lookup (isa, "call12");
  xtensa_callx0_opcode = xtensa_opcode_lookup (isa, "callx0");
  xtensa_callx4_opcode = xtensa_opcode_lookup (isa, "callx4");
  xtensa_callx8_opcode = xtensa_opcode_lookup (isa, "callx8");
  xtensa_callx12_opcode = xtensa_opcode_lookup (isa, "callx12");
  xtensa_const16_opcode = xtensa_opcode_lookup (isa, "const16");
  xtensa_entry_opcode = xtensa_opcode_lookup (isa, "entry");
  xtensa_extui_opcode = xtensa_opcode_lookup (isa, "extui");
  xtensa_movi_opcode = xtensa_opcode_lookup (isa, "movi");
  xtensa_movi_n_opcode = xtensa_opcode_lookup (isa, "movi.n");
  xtensa_isync_opcode = xtensa_opcode_lookup (isa, "isync");
  xtensa_j_opcode = xtensa_opcode_lookup (isa, "j");
  xtensa_jx_opcode = xtensa_opcode_lookup (isa, "jx");
  xtensa_l32r_opcode = xtensa_opcode_lookup (isa, "l32r");
  xtensa_loop_opcode = xtensa_opcode_lookup (isa, "loop");
  xtensa_loopnez_opcode = xtensa_opcode_lookup (isa, "loopnez");
  xtensa_loopgtz_opcode = xtensa_opcode_lookup (isa, "loopgtz");
  xtensa_nop_opcode = xtensa_opcode_lookup (isa, "nop");
  xtensa_nop_n_opcode = xtensa_opcode_lookup (isa, "nop.n");
  xtensa_or_opcode = xtensa_opcode_lookup (isa, "or");
  xtensa_ret_opcode = xtensa_opcode_lookup (isa, "ret");
  xtensa_ret_n_opcode = xtensa_opcode_lookup (isa, "ret.n");
  xtensa_retw_opcode = xtensa_opcode_lookup (isa, "retw");
  xtensa_retw_n_opcode = xtensa_opcode_lookup (isa, "retw.n");
  xtensa_rsr_lcount_opcode = xtensa_opcode_lookup (isa, "rsr.lcount");
  xtensa_waiti_opcode = xtensa_opcode_lookup (isa, "waiti");

  for (i = 0; i < xtensa_isa_num_formats (isa); i++) 
    {
      int format_slots = xtensa_format_num_slots (isa, i);
      if (format_slots > config_max_slots)
	config_max_slots = format_slots;
    }

  xg_init_vinsn (&cur_vinsn);

  xtensa_num_pipe_stages = xtensa_isa_num_pipe_stages (isa);

  init_op_placement_info_table ();

  /* Set up the assembly state.  */
  if (!frag_now->tc_frag_data.is_assembly_state_set)
    xtensa_set_frag_assembly_state (frag_now);
}


/* TC_INIT_FIX_DATA hook */

void
xtensa_init_fix_data (fixS *x)
{
  x->tc_fix_data.slot = 0;
  x->tc_fix_data.X_add_symbol = NULL;
  x->tc_fix_data.X_add_number = 0;
}


/* tc_frob_label hook */

void
xtensa_frob_label (symbolS *sym)
{
  float freq;

  if (cur_vinsn.inside_bundle)
    {
      as_bad (_("labels are not valid inside bundles"));
      return;
    }

  freq = get_subseg_target_freq (now_seg, now_subseg);

  /* Since the label was already attached to a frag associated with the
     previous basic block, it now needs to be reset to the current frag.  */
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, (valueT) frag_now_fix ());

  if (generating_literals)
    xtensa_add_literal_sym (sym);
  else
    xtensa_add_insn_label (sym);

  if (symbol_get_tc (sym)->is_loop_target)
    {
      if ((get_last_insn_flags (now_seg, now_subseg)
	  & FLAG_IS_BAD_LOOPEND) != 0)
	as_bad (_("invalid last instruction for a zero-overhead loop"));

      xtensa_set_frag_assembly_state (frag_now);
      frag_var (rs_machine_dependent, 4, 4, RELAX_LOOP_END,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);

      xtensa_set_frag_assembly_state (frag_now);
      xtensa_move_labels (frag_now, 0);
    }

  /* No target aligning in the absolute section.  */
  if (now_seg != absolute_section
      && !is_unaligned_label (sym)
      && !generating_literals)
    {
      xtensa_set_frag_assembly_state (frag_now);

      if (do_align_targets ())
	frag_var (rs_machine_dependent, 0, (int) freq,
		  RELAX_DESIRE_ALIGN_IF_TARGET, frag_now->fr_symbol,
		  frag_now->fr_offset, NULL);
      else
	frag_var (rs_fill, 0, 0, frag_now->fr_subtype,
		  frag_now->fr_symbol, frag_now->fr_offset, NULL);
      xtensa_set_frag_assembly_state (frag_now);
      xtensa_move_labels (frag_now, 0);
    }

  /* We need to mark the following properties even if we aren't aligning.  */

  /* If the label is already known to be a branch target, i.e., a
     forward branch, mark the frag accordingly.  Backward branches
     are handled by xg_add_branch_and_loop_targets.  */
  if (symbol_get_tc (sym)->is_branch_target)
    symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;

  /* Loops only go forward, so they can be identified here.  */
  if (symbol_get_tc (sym)->is_loop_target)
    symbol_get_frag (sym)->tc_frag_data.is_loop_target = TRUE;

  dwarf2_emit_label (sym);
}


/* tc_unrecognized_line hook */

int
xtensa_unrecognized_line (int ch)
{
  switch (ch)
    {
    case '{' :
      if (cur_vinsn.inside_bundle == 0)
	{
	  /* PR8110: Cannot emit line number info inside a FLIX bundle
	     when using --gstabs.  Temporarily disable debug info.  */
	  generate_lineno_debug ();
	  if (debug_type == DEBUG_STABS)
	    {
	      xt_saved_debug_type = debug_type;
	      debug_type = DEBUG_NONE;
	    }

	  cur_vinsn.inside_bundle = 1;
	}
      else
	{
	  as_bad (_("extra opening brace"));
	  return 0;
	}
      break;

    case '}' :
      if (cur_vinsn.inside_bundle)
	finish_vinsn (&cur_vinsn);
      else
	{
	  as_bad (_("extra closing brace"));
	  return 0;
	}
      break;
    default:
      as_bad (_("syntax error"));
      return 0;
    }
  return 1;
}


/* md_flush_pending_output hook */

void
xtensa_flush_pending_output (void)
{
  /* This line fixes a bug where automatically generated gstabs info
     separates a function label from its entry instruction, ending up
     with the literal position between the function label and the entry
     instruction and crashing code.  It only happens with --gstabs and
     --text-section-literals, and when several other obscure relaxation
     conditions are met.  */
  if (outputting_stabs_line_debug)
    return;

  if (cur_vinsn.inside_bundle)
    as_bad (_("missing closing brace"));

  /* If there is a non-zero instruction fragment, close it.  */
  if (frag_now_fix () != 0 && frag_now->tc_frag_data.is_insn)
    {
      frag_wane (frag_now);
      frag_new (0);
      xtensa_set_frag_assembly_state (frag_now);
    }
  frag_now->tc_frag_data.is_insn = FALSE;

  xtensa_clear_insn_labels ();
}


/* We had an error while parsing an instruction.  The string might look
   like this: "insn arg1, arg2 }".  If so, we need to see the closing
   brace and reset some fields.  Otherwise, the vinsn never gets closed
   and the num_slots field will grow past the end of the array of slots,
   and bad things happen.  */

static void
error_reset_cur_vinsn (void)
{
  if (cur_vinsn.inside_bundle)
    {
      if (*input_line_pointer == '}'
	  || *(input_line_pointer - 1) == '}'
	  || *(input_line_pointer - 2) == '}')
	xg_clear_vinsn (&cur_vinsn);
    }
}


void
md_assemble (char *str)
{
  xtensa_isa isa = xtensa_default_isa;
  char *opname;
  unsigned opnamelen;
  bfd_boolean has_underbar = FALSE;
  char *arg_strings[MAX_INSN_ARGS];
  int num_args;
  TInsn orig_insn;		/* Original instruction from the input.  */

  tinsn_init (&orig_insn);

  /* Split off the opcode.  */
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/0123456789.");
  opname = xmalloc (opnamelen + 1);
  memcpy (opname, str, opnamelen);
  opname[opnamelen] = '\0';

  num_args = tokenize_arguments (arg_strings, str + opnamelen);
  if (num_args == -1)
    {
      as_bad (_("syntax error"));
      return;
    }

  if (xg_translate_idioms (&opname, &num_args, arg_strings))
    return;

  /* Check for an underbar prefix.  */
  if (*opname == '_')
    {
      has_underbar = TRUE;
      opname += 1;
    }

  orig_insn.insn_type = ITYPE_INSN;
  orig_insn.ntok = 0;
  orig_insn.is_specific_opcode = (has_underbar || !use_transform ());
  orig_insn.opcode = xtensa_opcode_lookup (isa, opname);

  /* Special case: Check for "CALLXn.TLS" psuedo op.  If found, grab its
     extra argument and set the opcode to "CALLXn".  */
  if (orig_insn.opcode == XTENSA_UNDEFINED
      && strncasecmp (opname, "callx", 5) == 0)
    {
      unsigned long window_size;
      char *suffix;

      window_size = strtoul (opname + 5, &suffix, 10);
      if (suffix != opname + 5
	  && (window_size == 0
	      || window_size == 4
	      || window_size == 8
	      || window_size == 12)
	  && strcasecmp (suffix, ".tls") == 0)
	{
	  switch (window_size)
	    {
	    case 0: orig_insn.opcode = xtensa_callx0_opcode; break;
	    case 4: orig_insn.opcode = xtensa_callx4_opcode; break;
	    case 8: orig_insn.opcode = xtensa_callx8_opcode; break;
	    case 12: orig_insn.opcode = xtensa_callx12_opcode; break;
	    }

	  if (num_args != 2)
	    as_bad (_("wrong number of operands for '%s'"), opname);
	  else
	    {
	      bfd_reloc_code_real_type reloc;
	      char *old_input_line_pointer;
	      expressionS *tok = &orig_insn.extra_arg;

	      old_input_line_pointer = input_line_pointer;
	      input_line_pointer = arg_strings[num_args - 1];

	      expression (tok);
	      if (tok->X_op == O_symbol
		  && ((reloc = xtensa_elf_suffix (&input_line_pointer, tok))
		      == BFD_RELOC_XTENSA_TLS_CALL))
		tok->X_op = map_suffix_reloc_to_operator (reloc);
	      else
		as_bad (_("bad relocation expression for '%s'"), opname);

	      input_line_pointer = old_input_line_pointer;
	      num_args -= 1;
	    }
	}
    }

  /* Special case: Check for "j.l" psuedo op.  */
  if (orig_insn.opcode == XTENSA_UNDEFINED
      && strncasecmp (opname, "j.l", 3) == 0)
    {
      if (num_args != 2)
	as_bad (_("wrong number of operands for '%s'"), opname);
      else
	{
	  char *old_input_line_pointer;
	  expressionS *tok = &orig_insn.extra_arg;

	  old_input_line_pointer = input_line_pointer;
	  input_line_pointer = arg_strings[num_args - 1];

	  expression_maybe_register (xtensa_jx_opcode, 0, tok);
	  input_line_pointer = old_input_line_pointer;

	  num_args -= 1;
	  orig_insn.opcode = xtensa_j_opcode;
	}
    }

  if (orig_insn.opcode == XTENSA_UNDEFINED)
    {
      xtensa_format fmt = xtensa_format_lookup (isa, opname);
      if (fmt == XTENSA_UNDEFINED)
	{
	  as_bad (_("unknown opcode or format name '%s'"), opname);
	  error_reset_cur_vinsn ();
	  return;
	}
      if (!cur_vinsn.inside_bundle)
	{
	  as_bad (_("format names only valid inside bundles"));
	  error_reset_cur_vinsn ();
	  return;
	}
      if (cur_vinsn.format != XTENSA_UNDEFINED)
	as_warn (_("multiple formats specified for one bundle; using '%s'"),
		 opname);
      cur_vinsn.format = fmt;
      free (has_underbar ? opname - 1 : opname);
      error_reset_cur_vinsn ();
      return;
    }

  /* Parse the arguments.  */
  if (parse_arguments (&orig_insn, num_args, arg_strings))
    {
      as_bad (_("syntax error"));
      error_reset_cur_vinsn ();
      return;
    }

  /* Free the opcode and argument strings, now that they've been parsed.  */
  free (has_underbar ? opname - 1 : opname);
  opname = 0;
  while (num_args-- > 0)
    free (arg_strings[num_args]);

  /* Get expressions for invisible operands.  */
  if (get_invisible_operands (&orig_insn))
    {
      error_reset_cur_vinsn ();
      return;
    }

  /* Check for the right number and type of arguments.  */
  if (tinsn_check_arguments (&orig_insn))
    {
      error_reset_cur_vinsn ();
      return;
    }

  /* Record the line number for each TInsn, because a FLIX bundle may be
     spread across multiple input lines and individual instructions may be
     moved around in some cases.  */
  orig_insn.loc_directive_seen = dwarf2_loc_directive_seen;
  dwarf2_where (&orig_insn.debug_line);
  dwarf2_consume_line_info ();

  xg_add_branch_and_loop_targets (&orig_insn);

  /* Check that immediate value for ENTRY is >= 16.  */
  if (orig_insn.opcode == xtensa_entry_opcode && orig_insn.ntok >= 3)
    {
      expressionS *exp = &orig_insn.tok[2];
      if (exp->X_op == O_constant && exp->X_add_number < 16)
	as_warn (_("entry instruction with stack decrement < 16"));
    }

  /* Finish it off:
     assemble_tokens (opcode, tok, ntok);
     expand the tokens from the orig_insn into the
     stack of instructions that will not expand
     unless required at relaxation time.  */

  if (!cur_vinsn.inside_bundle)
    emit_single_op (&orig_insn);
  else /* We are inside a bundle.  */
    {
      cur_vinsn.slots[cur_vinsn.num_slots] = orig_insn;
      cur_vinsn.num_slots++;
      if (*input_line_pointer == '}'
	  || *(input_line_pointer - 1) == '}'
	  || *(input_line_pointer - 2) == '}')
	finish_vinsn (&cur_vinsn);
    }

  /* We've just emitted a new instruction so clear the list of labels.  */
  xtensa_clear_insn_labels ();
}


/* HANDLE_ALIGN hook */

/* For a .align directive, we mark the previous block with the alignment
   information.  This will be placed in the object file in the
   property section corresponding to this section.  */

void
xtensa_handle_align (fragS *fragP)
{
  if (linkrelax
      && ! fragP->tc_frag_data.is_literal
      && (fragP->fr_type == rs_align
	  || fragP->fr_type == rs_align_code)
      && fragP->fr_address + fragP->fr_fix > 0
      && fragP->fr_offset > 0
      && now_seg != bss_section)
    {
      fragP->tc_frag_data.is_align = TRUE;
      fragP->tc_frag_data.alignment = fragP->fr_offset;
    }

  if (fragP->fr_type == rs_align_test)
    {
      int count;
      count = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
      if (count != 0)
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("unaligned entry instruction"));
    }

  if (linkrelax && fragP->fr_type == rs_org)
    fragP->fr_subtype = RELAX_ORG;
}


/* TC_FRAG_INIT hook */

void
xtensa_frag_init (fragS *frag)
{
  xtensa_set_frag_assembly_state (frag);
}


symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}


/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
  return size;			/* Byte alignment is fine.  */
}


long
md_pcrel_from (fixS *fixP)
{
  char *insn_p;
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  int opnum;
  uint32 opnd_value;
  xtensa_opcode opcode;
  xtensa_format fmt;
  int slot;
  xtensa_isa isa = xtensa_default_isa;
  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
  bfd_boolean alt_reloc;

  if (fixP->fx_r_type == BFD_RELOC_XTENSA_ASM_EXPAND)
    return 0;

  if (fixP->fx_r_type == BFD_RELOC_32_PCREL)
    return addr;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  insn_p = &fixP->fx_frag->fr_literal[fixP->fx_where];
  xtensa_insnbuf_from_chars (isa, insnbuf, (unsigned char *) insn_p, 0);
  fmt = xtensa_format_decode (isa, insnbuf);

  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("bad instruction format"));

  if (decode_reloc (fixP->fx_r_type, &slot, &alt_reloc) != 0)
    as_fatal (_("invalid relocation"));

  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);

  /* Check for "alternate" relocations (operand not specified).  None
     of the current uses for these are really PC-relative.  */
  if (alt_reloc || opcode == xtensa_const16_opcode)
    {
      if (opcode != xtensa_l32r_opcode
	  && opcode != xtensa_const16_opcode)
	as_fatal (_("invalid relocation for '%s' instruction"),
		  xtensa_opcode_name (isa, opcode));
      return 0;
    }

  opnum = get_relaxable_immed (opcode);
  opnd_value = 0;
  if (xtensa_operand_is_PCrelative (isa, opcode, opnum) != 1
      || xtensa_operand_do_reloc (isa, opcode, opnum, &opnd_value, addr))
    {
      as_bad_where (fixP->fx_file,
		    fixP->fx_line,
		    _("invalid relocation for operand %d of '%s'"),
		    opnum, xtensa_opcode_name (isa, opcode));
      return 0;
    }
  return 0 - opnd_value;
}


/* TC_FORCE_RELOCATION hook */

int
xtensa_force_relocation (fixS *fix)
{
  switch (fix->fx_r_type)
    {
    case BFD_RELOC_XTENSA_ASM_EXPAND:
    case BFD_RELOC_XTENSA_SLOT0_ALT:
    case BFD_RELOC_XTENSA_SLOT1_ALT:
    case BFD_RELOC_XTENSA_SLOT2_ALT:
    case BFD_RELOC_XTENSA_SLOT3_ALT:
    case BFD_RELOC_XTENSA_SLOT4_ALT:
    case BFD_RELOC_XTENSA_SLOT5_ALT:
    case BFD_RELOC_XTENSA_SLOT6_ALT:
    case BFD_RELOC_XTENSA_SLOT7_ALT:
    case BFD_RELOC_XTENSA_SLOT8_ALT:
    case BFD_RELOC_XTENSA_SLOT9_ALT:
    case BFD_RELOC_XTENSA_SLOT10_ALT:
    case BFD_RELOC_XTENSA_SLOT11_ALT:
    case BFD_RELOC_XTENSA_SLOT12_ALT:
    case BFD_RELOC_XTENSA_SLOT13_ALT:
    case BFD_RELOC_XTENSA_SLOT14_ALT:
      return 1;
    default:
      break;
    }

  if (linkrelax && fix->fx_addsy
      && relaxable_section (S_GET_SEGMENT (fix->fx_addsy)))
    return 1;

  return generic_force_reloc (fix);
}


/* TC_VALIDATE_FIX_SUB hook */

int
xtensa_validate_fix_sub (fixS *fix)
{
  segT add_symbol_segment, sub_symbol_segment;

  /* The difference of two symbols should be resolved by the assembler when
     linkrelax is not set.  If the linker may relax the section containing
     the symbols, then an Xtensa DIFF relocation must be generated so that
     the linker knows to adjust the difference value.  */
  if (!linkrelax || fix->fx_addsy == NULL)
    return 0;

  /* Make sure both symbols are in the same segment, and that segment is
     "normal" and relaxable.  If the segment is not "normal", then the
     fix is not valid.  If the segment is not "relaxable", then the fix
     should have been handled earlier.  */
  add_symbol_segment = S_GET_SEGMENT (fix->fx_addsy);
  if (! SEG_NORMAL (add_symbol_segment) ||
      ! relaxable_section (add_symbol_segment))
    return 0;
  sub_symbol_segment = S_GET_SEGMENT (fix->fx_subsy);
  return (sub_symbol_segment == add_symbol_segment);
}


/* NO_PSEUDO_DOT hook */

/* This function has nothing to do with pseudo dots, but this is the
   nearest macro to where the check needs to take place.  FIXME: This
   seems wrong.  */

bfd_boolean
xtensa_check_inside_bundle (void)
{
  if (cur_vinsn.inside_bundle && input_line_pointer[-1] == '.')
    as_bad (_("directives are not valid inside bundles"));

  /* This function must always return FALSE because it is called via a
     macro that has nothing to do with bundling.  */
  return FALSE;
}


/* md_elf_section_change_hook */

void
xtensa_elf_section_change_hook (void)
{
  /* Set up the assembly state.  */
  if (!frag_now->tc_frag_data.is_assembly_state_set)
    xtensa_set_frag_assembly_state (frag_now);
}


/* tc_fix_adjustable hook */

bfd_boolean
xtensa_fix_adjustable (fixS *fixP)
{
  /* We need the symbol name for the VTABLE entries.  */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}


/* tc_symbol_new_hook */

symbolS *expr_symbols = NULL;

void 
xtensa_symbol_new_hook (symbolS *sym)
{
  if (is_leb128_expr && S_GET_SEGMENT (sym) == expr_section)
    {
      symbol_get_tc (sym)->next_expr_symbol = expr_symbols;
      expr_symbols = sym;
    }
}


void
md_apply_fix (fixS *fixP, valueT *valP, segT seg)
{
  char *const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
  valueT val = 0;

  /* Subtracted symbols are only allowed for a few relocation types, and
     unless linkrelax is enabled, they should not make it to this point.  */
  if (fixP->fx_subsy && !(linkrelax && (fixP->fx_r_type == BFD_RELOC_32
					|| fixP->fx_r_type == BFD_RELOC_16
					|| fixP->fx_r_type == BFD_RELOC_8)))
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_32_PCREL:
    case BFD_RELOC_32:
    case BFD_RELOC_16:
    case BFD_RELOC_8:
      if (fixP->fx_subsy)
	{
	  switch (fixP->fx_r_type)
	    {
	    case BFD_RELOC_8:
	      fixP->fx_r_type = BFD_RELOC_XTENSA_DIFF8;
	      break;
	    case BFD_RELOC_16:
	      fixP->fx_r_type = BFD_RELOC_XTENSA_DIFF16;
	      break;
	    case BFD_RELOC_32:
	      fixP->fx_r_type = BFD_RELOC_XTENSA_DIFF32;
	      break;
	    default:
	      break;
	    }

	  val = (S_GET_VALUE (fixP->fx_addsy) + fixP->fx_offset
		 - S_GET_VALUE (fixP->fx_subsy));

	  /* The difference value gets written out, and the DIFF reloc
	     identifies the address of the subtracted symbol (i.e., the one
	     with the lowest address).  */
	  *valP = val;
	  fixP->fx_offset -= val;
	  fixP->fx_subsy = NULL;
	}
      else if (! fixP->fx_addsy)
	{
	  val = *valP;
	  fixP->fx_done = 1;
	}
      /* fall through */

    case BFD_RELOC_XTENSA_PLT:
      md_number_to_chars (fixpos, val, fixP->fx_size);
      fixP->fx_no_overflow = 0; /* Use the standard overflow check.  */
      break;

    case BFD_RELOC_XTENSA_TLSDESC_FN:
    case BFD_RELOC_XTENSA_TLSDESC_ARG:
    case BFD_RELOC_XTENSA_TLS_TPOFF:
    case BFD_RELOC_XTENSA_TLS_DTPOFF:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      md_number_to_chars (fixpos, 0, fixP->fx_size);
      fixP->fx_no_overflow = 0; /* Use the standard overflow check.  */
      break;

    case BFD_RELOC_XTENSA_SLOT0_OP:
    case BFD_RELOC_XTENSA_SLOT1_OP:
    case BFD_RELOC_XTENSA_SLOT2_OP:
    case BFD_RELOC_XTENSA_SLOT3_OP:
    case BFD_RELOC_XTENSA_SLOT4_OP:
    case BFD_RELOC_XTENSA_SLOT5_OP:
    case BFD_RELOC_XTENSA_SLOT6_OP:
    case BFD_RELOC_XTENSA_SLOT7_OP:
    case BFD_RELOC_XTENSA_SLOT8_OP:
    case BFD_RELOC_XTENSA_SLOT9_OP:
    case BFD_RELOC_XTENSA_SLOT10_OP:
    case BFD_RELOC_XTENSA_SLOT11_OP:
    case BFD_RELOC_XTENSA_SLOT12_OP:
    case BFD_RELOC_XTENSA_SLOT13_OP:
    case BFD_RELOC_XTENSA_SLOT14_OP:
      if (linkrelax)
	{
	  /* Write the tentative value of a PC-relative relocation to a
	     local symbol into the instruction.  The value will be ignored
	     by the linker, and it makes the object file disassembly
	     readable when all branch targets are encoded in relocations.  */

	  gas_assert (fixP->fx_addsy);
	  if (S_GET_SEGMENT (fixP->fx_addsy) == seg
	      && !S_FORCE_RELOC (fixP->fx_addsy, 1))
	    {
	      val = (S_GET_VALUE (fixP->fx_addsy) + fixP->fx_offset
		     - md_pcrel_from (fixP));
	      (void) xg_apply_fix_value (fixP, val);
	    }
	}
      else if (! fixP->fx_addsy)
	{
	  val = *valP;
	  if (xg_apply_fix_value (fixP, val))
	    fixP->fx_done = 1;
	}
      break;

    case BFD_RELOC_XTENSA_ASM_EXPAND:
    case BFD_RELOC_XTENSA_TLS_FUNC:
    case BFD_RELOC_XTENSA_TLS_ARG:
    case BFD_RELOC_XTENSA_TLS_CALL:
    case BFD_RELOC_XTENSA_SLOT0_ALT:
    case BFD_RELOC_XTENSA_SLOT1_ALT:
    case BFD_RELOC_XTENSA_SLOT2_ALT:
    case BFD_RELOC_XTENSA_SLOT3_ALT:
    case BFD_RELOC_XTENSA_SLOT4_ALT:
    case BFD_RELOC_XTENSA_SLOT5_ALT:
    case BFD_RELOC_XTENSA_SLOT6_ALT:
    case BFD_RELOC_XTENSA_SLOT7_ALT:
    case BFD_RELOC_XTENSA_SLOT8_ALT:
    case BFD_RELOC_XTENSA_SLOT9_ALT:
    case BFD_RELOC_XTENSA_SLOT10_ALT:
    case BFD_RELOC_XTENSA_SLOT11_ALT:
    case BFD_RELOC_XTENSA_SLOT12_ALT:
    case BFD_RELOC_XTENSA_SLOT13_ALT:
    case BFD_RELOC_XTENSA_SLOT14_ALT:
      /* These all need to be resolved at link-time.  Do nothing now.  */
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      break;

    default:
      as_bad (_("unhandled local relocation fix %s"),
	      bfd_get_reloc_code_name (fixP->fx_r_type));
    }
}


char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, target_big_endian);
}


int
md_estimate_size_before_relax (fragS *fragP, segT seg ATTRIBUTE_UNUSED)
{
  return total_frag_text_expansion (fragP);
}


/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* Make sure none of our internal relocations make it this far.
     They'd better have been fully resolved by this point.  */
  gas_assert ((int) fixp->fx_r_type > 0);

  reloc->addend = fixp->fx_offset;

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent `%s' relocation in object file"),
		    bfd_get_reloc_code_name (fixp->fx_r_type));
      free (reloc->sym_ptr_ptr);
      free (reloc);
      return NULL;
    }

  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
    as_fatal (_("internal error; cannot generate `%s' relocation"),
	      bfd_get_reloc_code_name (fixp->fx_r_type));

  return reloc;
}


/* Checks for resource conflicts between instructions.  */

/* The func unit stuff could be implemented as bit-vectors rather
   than the iterative approach here.  If it ends up being too
   slow, we will switch it.  */

resource_table *
new_resource_table (void *data,
		    int cycles,
		    int nu,
		    unit_num_copies_func uncf,
		    opcode_num_units_func onuf,
		    opcode_funcUnit_use_unit_func ouuf,
		    opcode_funcUnit_use_stage_func ousf)
{
  int i;
  resource_table *rt = (resource_table *) xmalloc (sizeof (resource_table));
  rt->data = data;
  rt->cycles = cycles;
  rt->allocated_cycles = cycles;
  rt->num_units = nu;
  rt->unit_num_copies = uncf;
  rt->opcode_num_units = onuf;
  rt->opcode_unit_use = ouuf;
  rt->opcode_unit_stage = ousf;

  rt->units = (unsigned char **) xcalloc (cycles, sizeof (unsigned char *));
  for (i = 0; i < cycles; i++)
    rt->units[i] = (unsigned char *) xcalloc (nu, sizeof (unsigned char));

  return rt;
}


void
clear_resource_table (resource_table *rt)
{
  int i, j;
  for (i = 0; i < rt->allocated_cycles; i++)
    for (j = 0; j < rt->num_units; j++)
      rt->units[i][j] = 0;
}


/* We never shrink it, just fake it into thinking so.  */

void
resize_resource_table (resource_table *rt, int cycles)
{
  int i, old_cycles;

  rt->cycles = cycles;
  if (cycles <= rt->allocated_cycles)
    return;

  old_cycles = rt->allocated_cycles;
  rt->allocated_cycles = cycles;

  rt->units = xrealloc (rt->units,
			rt->allocated_cycles * sizeof (unsigned char *));
  for (i = 0; i < old_cycles; i++)
    rt->units[i] = xrealloc (rt->units[i],
			     rt->num_units * sizeof (unsigned char));
  for (i = old_cycles; i < cycles; i++)
    rt->units[i] = xcalloc (rt->num_units, sizeof (unsigned char));
}


bfd_boolean
resources_available (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++)
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      int copies_in_use = rt->units[stage + cycle][unit];
      int copies = (rt->unit_num_copies) (rt->data, unit);
      if (copies_in_use >= copies)
	return FALSE;
    }
  return TRUE;
}


void
reserve_resources (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++)
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      /* Note that this allows resources to be oversubscribed.  That's
	 essential to the way the optional scheduler works.
	 resources_available reports when a resource is over-subscribed,
	 so it's easy to tell.  */
      rt->units[stage + cycle][unit]++;
    }
}


void
release_resources (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++)
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      gas_assert (rt->units[stage + cycle][unit] > 0);
      rt->units[stage + cycle][unit]--;
    }
}


/* Wrapper functions make parameterized resource reservation
   more convenient.  */

int
opcode_funcUnit_use_unit (void *data, xtensa_opcode opcode, int idx)
{
  xtensa_funcUnit_use *use = xtensa_opcode_funcUnit_use (data, opcode, idx);
  return use->unit;
}


int
opcode_funcUnit_use_stage (void *data, xtensa_opcode opcode, int idx)
{
  xtensa_funcUnit_use *use = xtensa_opcode_funcUnit_use (data, opcode, idx);
  return use->stage;
}


/* Note that this function does not check issue constraints, but
   solely whether the hardware is available to execute the given
   instructions together.  It also doesn't check if the tinsns
   write the same state, or access the same tieports.  That is
   checked by check_t1_t2_reads_and_writes.  */

static bfd_boolean
resources_conflict (vliw_insn *vinsn)
{
  int i;
  static resource_table *rt = NULL;

  /* This is the most common case by far.  Optimize it.  */
  if (vinsn->num_slots == 1)
    return FALSE;

  if (rt == NULL)
    {
      xtensa_isa isa = xtensa_default_isa;
      rt = new_resource_table
	(isa, xtensa_num_pipe_stages,
	 xtensa_isa_num_funcUnits (isa),
	 (unit_num_copies_func) xtensa_funcUnit_num_copies,
	 (opcode_num_units_func) xtensa_opcode_num_funcUnit_uses,
	 opcode_funcUnit_use_unit,
	 opcode_funcUnit_use_stage);
    }

  clear_resource_table (rt);

  for (i = 0; i < vinsn->num_slots; i++)
    {
      if (!resources_available (rt, vinsn->slots[i].opcode, 0))
	return TRUE;
      reserve_resources (rt, vinsn->slots[i].opcode, 0);
    }

  return FALSE;
}


/* finish_vinsn, emit_single_op and helper functions.  */

static bfd_boolean find_vinsn_conflicts (vliw_insn *);
static xtensa_format xg_find_narrowest_format (vliw_insn *);
static void xg_assemble_vliw_tokens (vliw_insn *);


/* We have reached the end of a bundle; emit into the frag.  */

static void
finish_vinsn (vliw_insn *vinsn)
{
  IStack slotstack;
  int i;
  char *file_name;
  unsigned line;

  if (find_vinsn_conflicts (vinsn))
    {
      xg_clear_vinsn (vinsn);
      return;
    }

  /* First, find a format that works.  */
  if (vinsn->format == XTENSA_UNDEFINED)
    vinsn->format = xg_find_narrowest_format (vinsn);

  if (xtensa_format_num_slots (xtensa_default_isa, vinsn->format) > 1
      && produce_flix == FLIX_NONE)
    {
      as_bad (_("The option \"--no-allow-flix\" prohibits multi-slot flix."));
      xg_clear_vinsn (vinsn);
      return;
    }

  if (vinsn->format == XTENSA_UNDEFINED)
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line,
		    _("couldn't find a valid instruction format"));
      fprintf (stderr, _("    ops were: "));
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, _(" %s;"),
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, _("\n"));
      xg_clear_vinsn (vinsn);
      return;
    }

  if (vinsn->num_slots
      != xtensa_format_num_slots (xtensa_default_isa, vinsn->format))
    {
      as_bad (_("format '%s' allows %d slots, but there are %d opcodes"),
	      xtensa_format_name (xtensa_default_isa, vinsn->format),
	      xtensa_format_num_slots (xtensa_default_isa, vinsn->format),
	      vinsn->num_slots);
      xg_clear_vinsn (vinsn);
      return;
    }

  if (resources_conflict (vinsn))
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line, _("illegal resource usage in bundle"));
      fprintf (stderr, "    ops were: ");
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, " %s;",
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, "\n");
      xg_clear_vinsn (vinsn);
      return;
    }

  for (i = 0; i < vinsn->num_slots; i++)
    {
      if (vinsn->slots[i].opcode != XTENSA_UNDEFINED)
	{
	  symbolS *lit_sym = NULL;
	  int j;
	  bfd_boolean e = FALSE;
	  bfd_boolean saved_density = density_supported;

	  /* We don't want to narrow ops inside multi-slot bundles.  */
	  if (vinsn->num_slots > 1)
	    density_supported = FALSE;

	  istack_init (&slotstack);
	  if (vinsn->slots[i].opcode == xtensa_nop_opcode)
	    {
	      vinsn->slots[i].opcode =
		xtensa_format_slot_nop_opcode (xtensa_default_isa,
					       vinsn->format, i);
	      vinsn->slots[i].ntok = 0;
	    }

	  if (xg_expand_assembly_insn (&slotstack, &vinsn->slots[i]))
	    {
	      e = TRUE;
	      continue;
	    }

	  density_supported = saved_density;

	  if (e)
	    {
	      xg_clear_vinsn (vinsn);
	      return;
	    }

	  for (j = 0; j < slotstack.ninsn; j++)
	    {
	      TInsn *insn = &slotstack.insn[j];
	      if (insn->insn_type == ITYPE_LITERAL)
		{
		  gas_assert (lit_sym == NULL);
		  lit_sym = xg_assemble_literal (insn);
		}
	      else
		{
		  gas_assert (insn->insn_type == ITYPE_INSN);
		  if (lit_sym)
		    xg_resolve_literals (insn, lit_sym);
		  if (j != slotstack.ninsn - 1)
		    emit_single_op (insn);
		}
	    }

	  if (vinsn->num_slots > 1)
	    {
	      if (opcode_fits_format_slot
		  (slotstack.insn[slotstack.ninsn - 1].opcode,
		   vinsn->format, i))
		{
		  vinsn->slots[i] = slotstack.insn[slotstack.ninsn - 1];
		}
	      else
		{
		  emit_single_op (&slotstack.insn[slotstack.ninsn - 1]);
		  if (vinsn->format == XTENSA_UNDEFINED)
		    vinsn->slots[i].opcode = xtensa_nop_opcode;
		  else
		    vinsn->slots[i].opcode
		      = xtensa_format_slot_nop_opcode (xtensa_default_isa,
						       vinsn->format, i);

		  vinsn->slots[i].ntok = 0;
		}
	    }
	  else
	    {
	      vinsn->slots[0] = slotstack.insn[slotstack.ninsn - 1];
	      vinsn->format = XTENSA_UNDEFINED;
	    }
	}
    }

  /* Now check resource conflicts on the modified bundle.  */
  if (resources_conflict (vinsn))
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line, _("illegal resource usage in bundle"));
      fprintf (stderr, "    ops were: ");
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, " %s;",
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, "\n");
      xg_clear_vinsn (vinsn);
      return;
    }

  /* First, find a format that works.  */
  if (vinsn->format == XTENSA_UNDEFINED)
      vinsn->format = xg_find_narrowest_format (vinsn);

  xg_assemble_vliw_tokens (vinsn);

  xg_clear_vinsn (vinsn);
}


/* Given an vliw instruction, what conflicts are there in register
   usage and in writes to states and queues?

   This function does two things:
   1. Reports an error when a vinsn contains illegal combinations
      of writes to registers states or queues.
   2. Marks individual tinsns as not relaxable if the combination
      contains antidependencies.

   Job 2 handles things like swap semantics in instructions that need
   to be relaxed.  For example,

	addi a0, a1, 100000

   normally would be relaxed to

	l32r a0, some_label
	add a0, a1, a0

   _but_, if the above instruction is bundled with an a0 reader, e.g.,

	{ addi a0, a1, 10000 ; add a2, a0, a4 ; }

   then we can't relax it into

	l32r a0, some_label
	{ add a0, a1, a0 ; add a2, a0, a4 ; }

   because the value of a0 is trashed before the second add can read it.  */

static char check_t1_t2_reads_and_writes (TInsn *, TInsn *);

static bfd_boolean
find_vinsn_conflicts (vliw_insn *vinsn)
{
  int i, j;
  int branches = 0;
  xtensa_isa isa = xtensa_default_isa;

  gas_assert (!past_xtensa_end);

  for (i = 0 ; i < vinsn->num_slots; i++)
    {
      TInsn *op1 = &vinsn->slots[i];
      if (op1->is_specific_opcode)
	op1->keep_wide = TRUE;
      else
	op1->keep_wide = FALSE;
    }

  for (i = 0 ; i < vinsn->num_slots; i++)
    {
      TInsn *op1 = &vinsn->slots[i];

      if (xtensa_opcode_is_branch (isa, op1->opcode) == 1)
	branches++;

      for (j = 0; j < vinsn->num_slots; j++)
	{
	  if (i != j)
	    {
	      TInsn *op2 = &vinsn->slots[j];
	      char conflict_type = check_t1_t2_reads_and_writes (op1, op2);
	      switch (conflict_type)
		{
		case 'c':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same register"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'd':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same state"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'e':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same port"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'f':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) both have volatile port accesses"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		default:
		  /* Everything is OK.  */
		  break;
		}
	      op2->is_specific_opcode = (op2->is_specific_opcode
					 || conflict_type == 'a');
	    }
	}
    }

  if (branches > 1)
    {
      as_bad (_("multiple branches or jumps in the same bundle"));
      return TRUE;
    }

  return FALSE;
}


/* Check how the state used by t1 and t2 relate.
   Cases found are:

   case A: t1 reads a register t2 writes (an antidependency within a bundle)
   case B: no relationship between what is read and written (both could
           read the same reg though)
   case C: t1 writes a register t2 writes (a register conflict within a
           bundle)
   case D: t1 writes a state that t2 also writes
   case E: t1 writes a tie queue that t2 also writes
   case F: two volatile queue accesses
*/

static char
check_t1_t2_reads_and_writes (TInsn *t1, TInsn *t2)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_regfile t1_regfile, t2_regfile;
  int t1_reg, t2_reg;
  int t1_base_reg, t1_last_reg;
  int t2_base_reg, t2_last_reg;
  char t1_inout, t2_inout;
  int i, j;
  char conflict = 'b';
  int t1_states;
  int t2_states;
  int t1_interfaces;
  int t2_interfaces;
  bfd_boolean t1_volatile = FALSE;
  bfd_boolean t2_volatile = FALSE;

  /* Check registers.  */
  for (j = 0; j < t2->ntok; j++)
    {
      if (xtensa_operand_is_register (isa, t2->opcode, j) != 1)
	continue;

      t2_regfile = xtensa_operand_regfile (isa, t2->opcode, j);
      t2_base_reg = t2->tok[j].X_add_number;
      t2_last_reg = t2_base_reg + xtensa_operand_num_regs (isa, t2->opcode, j);

      for (i = 0; i < t1->ntok; i++)
	{
	  if (xtensa_operand_is_register (isa, t1->opcode, i) != 1)
	    continue;

	  t1_regfile = xtensa_operand_regfile (isa, t1->opcode, i);

	  if (t1_regfile != t2_regfile)
	    continue;

	  t1_inout = xtensa_operand_inout (isa, t1->opcode, i);
	  t2_inout = xtensa_operand_inout (isa, t2->opcode, j);

	  if (xtensa_operand_is_known_reg (isa, t1->opcode, i) == 0
	      || xtensa_operand_is_known_reg (isa, t2->opcode, j) == 0)
	    {
	      if (t1_inout == 'm' || t1_inout == 'o'
		  || t2_inout == 'm' || t2_inout == 'o')
		{
		  conflict = 'a';
		  continue;
		}
	    }

	  t1_base_reg = t1->tok[i].X_add_number;
	  t1_last_reg = (t1_base_reg
			 + xtensa_operand_num_regs (isa, t1->opcode, i));

	  for (t1_reg = t1_base_reg; t1_reg < t1_last_reg; t1_reg++)
	    {
	      for (t2_reg = t2_base_reg; t2_reg < t2_last_reg; t2_reg++)
		{
		  if (t1_reg != t2_reg)
		    continue;

		  if (t2_inout == 'i' && (t1_inout == 'm' || t1_inout == 'o'))
		    {
		      conflict = 'a';
		      continue;
		    }

		  if (t1_inout == 'i' && (t2_inout == 'm' || t2_inout == 'o'))
		    {
		      conflict = 'a';
		      continue;
		    }

		  if (t1_inout != 'i' && t2_inout != 'i')
		    return 'c';
		}
	    }
	}
    }

  /* Check states.  */
  t1_states = xtensa_opcode_num_stateOperands (isa, t1->opcode);
  t2_states = xtensa_opcode_num_stateOperands (isa, t2->opcode);
  for (j = 0; j < t2_states; j++)
    {
      xtensa_state t2_so = xtensa_stateOperand_state (isa, t2->opcode, j);
      t2_inout = xtensa_stateOperand_inout (isa, t2->opcode, j);
      for (i = 0; i < t1_states; i++)
	{
	  xtensa_state t1_so = xtensa_stateOperand_state (isa, t1->opcode, i);
	  t1_inout = xtensa_stateOperand_inout (isa, t1->opcode, i);
	  if (t1_so != t2_so || xtensa_state_is_shared_or (isa, t1_so) == 1)
	    continue;

	  if (t2_inout == 'i' && (t1_inout == 'm' || t1_inout == 'o'))
	    {
	      conflict = 'a';
	      continue;
	    }

	  if (t1_inout == 'i' && (t2_inout == 'm' || t2_inout == 'o'))
	    {
	      conflict = 'a';
	      continue;
	    }

	  if (t1_inout != 'i' && t2_inout != 'i')
	    return 'd';
	}
    }

  /* Check tieports.  */
  t1_interfaces = xtensa_opcode_num_interfaceOperands (isa, t1->opcode);
  t2_interfaces = xtensa_opcode_num_interfaceOperands (isa, t2->opcode);
  for (j = 0; j < t2_interfaces; j++)
    {
      xtensa_interface t2_int
	= xtensa_interfaceOperand_interface (isa, t2->opcode, j);
      int t2_class = xtensa_interface_class_id (isa, t2_int);

      t2_inout = xtensa_interface_inout (isa, t2_int);
      if (xtensa_interface_has_side_effect (isa, t2_int) == 1)
	t2_volatile = TRUE;

      for (i = 0; i < t1_interfaces; i++)
	{
	  xtensa_interface t1_int
	    = xtensa_interfaceOperand_interface (isa, t1->opcode, j);
	  int t1_class = xtensa_interface_class_id (isa, t1_int);

	  t1_inout = xtensa_interface_inout (isa, t1_int);
	  if (xtensa_interface_has_side_effect (isa, t1_int) == 1)
	    t1_volatile = TRUE;

	  if (t1_volatile && t2_volatile && (t1_class == t2_class))
	    return 'f';

	  if (t1_int != t2_int)
	    continue;

	  if (t2_inout == 'i' && t1_inout == 'o')
	    {
	      conflict = 'a';
	      continue;
	    }

	  if (t1_inout == 'i' && t2_inout == 'o')
	    {
	      conflict = 'a';
	      continue;
	    }

	  if (t1_inout != 'i' && t2_inout != 'i')
	    return 'e';
	}
    }

  return conflict;
}


static xtensa_format
xg_find_narrowest_format (vliw_insn *vinsn)
{
  /* Right now we assume that the ops within the vinsn are properly
     ordered for the slots that the programmer wanted them in.  In
     other words, we don't rearrange the ops in hopes of finding a
     better format.  The scheduler handles that.  */

  xtensa_isa isa = xtensa_default_isa;
  xtensa_format format;
  xtensa_opcode nop_opcode = xtensa_nop_opcode;

  if (vinsn->num_slots == 1)
    return xg_get_single_format (vinsn->slots[0].opcode);

  for (format = 0; format < xtensa_isa_num_formats (isa); format++)
    {
      vliw_insn v_copy;
      xg_copy_vinsn (&v_copy, vinsn);
      if (xtensa_format_num_slots (isa, format) == v_copy.num_slots)
	{
	  int slot;
	  int fit = 0;
	  for (slot = 0; slot < v_copy.num_slots; slot++)
	    {
	      if (v_copy.slots[slot].opcode == nop_opcode)
		{
		  v_copy.slots[slot].opcode =
		    xtensa_format_slot_nop_opcode (isa, format, slot);
		  v_copy.slots[slot].ntok = 0;
		}

	      if (opcode_fits_format_slot (v_copy.slots[slot].opcode,
					   format, slot))
		fit++;
	      else if (v_copy.num_slots > 1)
		{
		  TInsn widened;
		  /* Try the widened version.  */
		  if (!v_copy.slots[slot].keep_wide
		      && !v_copy.slots[slot].is_specific_opcode
		      && xg_is_single_relaxable_insn (&v_copy.slots[slot],
						      &widened, TRUE)
		      && opcode_fits_format_slot (widened.opcode,
						  format, slot))
		    {
		      v_copy.slots[slot] = widened;
		      fit++;
		    }
		}
	    }
	  if (fit == v_copy.num_slots)
	    {
	      xg_copy_vinsn (vinsn, &v_copy);
	      xtensa_format_encode (isa, format, vinsn->insnbuf);
	      vinsn->format = format;
	      break;
	    }
	}
    }

  if (format == xtensa_isa_num_formats (isa))
    return XTENSA_UNDEFINED;

  return format;
}


/* Return the additional space needed in a frag
   for possible relaxations of any ops in a VLIW insn.
   Also fill out the relaxations that might be required of
   each tinsn in the vinsn.  */

static int
relaxation_requirements (vliw_insn *vinsn, bfd_boolean *pfinish_frag)
{
  bfd_boolean finish_frag = FALSE;
  int extra_space = 0;
  int slot;

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      TInsn *tinsn = &vinsn->slots[slot];
      if (!tinsn_has_symbolic_operands (tinsn))
	{
	  /* A narrow instruction could be widened later to help
	     alignment issues.  */
	  if (xg_is_single_relaxable_insn (tinsn, 0, TRUE)
	      && !tinsn->is_specific_opcode
	      && vinsn->num_slots == 1)
	    {
	      /* Difference in bytes between narrow and wide insns...  */
	      extra_space += 1;
	      tinsn->subtype = RELAX_NARROW;
	    }
	}
      else
	{
	  if (workaround_b_j_loop_end
	      && tinsn->opcode == xtensa_jx_opcode
	      && use_transform ())
	    {
	      /* Add 2 of these.  */
	      extra_space += 3; /* for the nop size */
	      tinsn->subtype = RELAX_ADD_NOP_IF_PRE_LOOP_END;
	    }

	  /* Need to assemble it with space for the relocation.  */
	  if (xg_is_relaxable_insn (tinsn, 0)
	      && !tinsn->is_specific_opcode)
	    {
	      int max_size = xg_get_max_insn_widen_size (tinsn->opcode);
	      int max_literal_size =
		xg_get_max_insn_widen_literal_size (tinsn->opcode);

	      tinsn->literal_space = max_literal_size;

	      tinsn->subtype = RELAX_IMMED;
	      extra_space += max_size;
	    }
	  else
	    {
	      /* A fix record will be added for this instruction prior
		 to relaxation, so make it end the frag.  */
	      finish_frag = TRUE;
	    }
	}
    }
  *pfinish_frag = finish_frag;
  return extra_space;
}


static void
bundle_tinsn (TInsn *tinsn, vliw_insn *vinsn)
{
  xtensa_isa isa = xtensa_default_isa;
  int slot, chosen_slot;

  vinsn->format = xg_get_single_format (tinsn->opcode);
  gas_assert (vinsn->format != XTENSA_UNDEFINED);
  vinsn->num_slots = xtensa_format_num_slots (isa, vinsn->format);

  chosen_slot = xg_get_single_slot (tinsn->opcode);
  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      if (slot == chosen_slot)
	vinsn->slots[slot] = *tinsn;
      else
	{
	  vinsn->slots[slot].opcode =
	    xtensa_format_slot_nop_opcode (isa, vinsn->format, slot);
	  vinsn->slots[slot].ntok = 0;
	  vinsn->slots[slot].insn_type = ITYPE_INSN;
	}
    }
}


static bfd_boolean
emit_single_op (TInsn *orig_insn)
{
  int i;
  IStack istack;		/* put instructions into here */
  symbolS *lit_sym = NULL;
  symbolS *label_sym = NULL;

  istack_init (&istack);

  /* Special-case for "movi aX, foo" which is guaranteed to need relaxing.
     Because the scheduling and bundling characteristics of movi and
     l32r or const16 are so different, we can do much better if we relax
     it prior to scheduling and bundling, rather than after.  */
  if ((orig_insn->opcode == xtensa_movi_opcode
       || orig_insn->opcode == xtensa_movi_n_opcode)
      && !cur_vinsn.inside_bundle
      && (orig_insn->tok[1].X_op == O_symbol
	  || orig_insn->tok[1].X_op == O_pltrel
	  || orig_insn->tok[1].X_op == O_tlsfunc
	  || orig_insn->tok[1].X_op == O_tlsarg
	  || orig_insn->tok[1].X_op == O_tpoff
	  || orig_insn->tok[1].X_op == O_dtpoff)
      && !orig_insn->is_specific_opcode && use_transform ())
    xg_assembly_relax (&istack, orig_insn, now_seg, frag_now, 0, 1, 0);
  else
    if (xg_expand_assembly_insn (&istack, orig_insn))
      return TRUE;

  for (i = 0; i < istack.ninsn; i++)
    {
      TInsn *insn = &istack.insn[i];
      switch (insn->insn_type)
	{
	case ITYPE_LITERAL:
	  gas_assert (lit_sym == NULL);
	  lit_sym = xg_assemble_literal (insn);
	  break;
	case ITYPE_LABEL:
	  {
	    static int relaxed_sym_idx = 0;
	    char *label = xmalloc (strlen (FAKE_LABEL_NAME) + 12);
	    sprintf (label, "%s_rl_%x", FAKE_LABEL_NAME, relaxed_sym_idx++);
	    colon (label);
	    gas_assert (label_sym == NULL);
	    label_sym = symbol_find_or_make (label);
	    gas_assert (label_sym);
	    free (label);
	  }
	  break;
	case ITYPE_INSN:
	  {
	    vliw_insn v;
	    if (lit_sym)
	      xg_resolve_literals (insn, lit_sym);
	    if (label_sym)
	      xg_resolve_labels (insn, label_sym);
	    xg_init_vinsn (&v);
	    bundle_tinsn (insn, &v);
	    finish_vinsn (&v);
	    xg_free_vinsn (&v);
	  }
	  break;
	default:
	  gas_assert (0);
	  break;
	}
    }
  return FALSE;
}


static int
total_frag_text_expansion (fragS *fragP)
{
  int slot;
  int total_expansion = 0;

  for (slot = 0; slot < config_max_slots; slot++)
    total_expansion += fragP->tc_frag_data.text_expansion[slot];

  return total_expansion;
}


/* Emit a vliw instruction to the current fragment.  */

static void
xg_assemble_vliw_tokens (vliw_insn *vinsn)
{
  bfd_boolean finish_frag;
  bfd_boolean is_jump = FALSE;
  bfd_boolean is_branch = FALSE;
  xtensa_isa isa = xtensa_default_isa;
  int insn_size;
  int extra_space;
  char *f = NULL;
  int slot;
  struct dwarf2_line_info debug_line;
  bfd_boolean loc_directive_seen = FALSE;
  TInsn *tinsn;

  memset (&debug_line, 0, sizeof (struct dwarf2_line_info));

  if (generating_literals)
    {
      static int reported = 0;
      if (reported < 4)
	as_bad_where (frag_now->fr_file, frag_now->fr_line,
		      _("cannot assemble into a literal fragment"));
      if (reported == 3)
	as_bad (_("..."));
      reported++;
      return;
    }

  if (frag_now_fix () != 0
      && (! frag_now->tc_frag_data.is_insn
 	  || (vinsn_has_specific_opcodes (vinsn) && use_transform ())
 	  || !use_transform () != frag_now->tc_frag_data.is_no_transform
 	  || (directive_state[directive_longcalls]
	      != frag_now->tc_frag_data.use_longcalls)
 	  || (directive_state[directive_absolute_literals]
	      != frag_now->tc_frag_data.use_absolute_literals)))
    {
      frag_wane (frag_now);
      frag_new (0);
      xtensa_set_frag_assembly_state (frag_now);
    }

  if (workaround_a0_b_retw
      && vinsn->num_slots == 1
      && (get_last_insn_flags (now_seg, now_subseg) & FLAG_IS_A0_WRITER) != 0
      && xtensa_opcode_is_branch (isa, vinsn->slots[0].opcode) == 1
      && use_transform ())
    {
      has_a0_b_retw = TRUE;

      /* Mark this fragment with the special RELAX_ADD_NOP_IF_A0_B_RETW.
	 After the first assembly pass we will check all of them and
	 add a nop if needed.  */
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, 4,
		RELAX_ADD_NOP_IF_A0_B_RETW,
		frag_now->fr_symbol,
		frag_now->fr_offset,
		NULL);
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, 4,
		RELAX_ADD_NOP_IF_A0_B_RETW,
		frag_now->fr_symbol,
		frag_now->fr_offset,
		NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      tinsn = &vinsn->slots[slot];

      /* See if the instruction implies an aligned section.  */
      if (xtensa_opcode_is_loop (isa, tinsn->opcode) == 1)
	record_alignment (now_seg, 2);

      /* Determine the best line number for debug info.  */
      if ((tinsn->loc_directive_seen || !loc_directive_seen)
	  && (tinsn->debug_line.filenum != debug_line.filenum
	      || tinsn->debug_line.line < debug_line.line
	      || tinsn->debug_line.column < debug_line.column))
	debug_line = tinsn->debug_line;
      if (tinsn->loc_directive_seen)
	loc_directive_seen = TRUE;
    }

  /* Special cases for instructions that force an alignment... */
  /* None of these opcodes are bundle-able.  */
  if (xtensa_opcode_is_loop (isa, vinsn->slots[0].opcode) == 1)
    {
      int max_fill;

      /* Remember the symbol that marks the end of the loop in the frag
	 that marks the start of the loop.  This way we can easily find
	 the end of the loop at the beginning, without adding special code
	 to mark the loop instructions themselves.  */
      symbolS *target_sym = NULL;
      if (vinsn->slots[0].tok[1].X_op == O_symbol)
	target_sym = vinsn->slots[0].tok[1].X_add_symbol;

      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;

      max_fill = get_text_align_max_fill_size
	(get_text_align_power (xtensa_fetch_width),
	 TRUE, frag_now->tc_frag_data.is_no_density);

      if (use_transform ())
	frag_var (rs_machine_dependent, max_fill, max_fill,
		  RELAX_ALIGN_NEXT_OPCODE, target_sym, 0, NULL);
      else
	frag_var (rs_machine_dependent, 0, 0,
		  RELAX_CHECK_ALIGN_NEXT_OPCODE, target_sym, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }

  if (vinsn->slots[0].opcode == xtensa_entry_opcode
      && !vinsn->slots[0].is_specific_opcode)
    {
      xtensa_mark_literal_pool_location ();
      xtensa_move_labels (frag_now, 0);
      frag_var (rs_align_test, 1, 1, 0, NULL, 2, NULL);
    }

  if (vinsn->num_slots == 1)
    {
      if (workaround_a0_b_retw && use_transform ())
	set_last_insn_flags (now_seg, now_subseg, FLAG_IS_A0_WRITER,
			     is_register_writer (&vinsn->slots[0], "a", 0));

      set_last_insn_flags (now_seg, now_subseg, FLAG_IS_BAD_LOOPEND,
			   is_bad_loopend_opcode (&vinsn->slots[0]));
    }
  else
    set_last_insn_flags (now_seg, now_subseg, FLAG_IS_BAD_LOOPEND, FALSE);

  insn_size = xtensa_format_length (isa, vinsn->format);

  extra_space = relaxation_requirements (vinsn, &finish_frag);

  /* vinsn_to_insnbuf will produce the error.  */
  if (vinsn->format != XTENSA_UNDEFINED)
    {
      f = frag_more (insn_size + extra_space);
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;
    }

  vinsn_to_insnbuf (vinsn, f, frag_now, FALSE);
  if (vinsn->format == XTENSA_UNDEFINED)
    return;

  xtensa_insnbuf_to_chars (isa, vinsn->insnbuf, (unsigned char *) f, 0);

  if (debug_type == DEBUG_DWARF2 || loc_directive_seen)
    dwarf2_gen_line_info (frag_now_fix () - (insn_size + extra_space),
			  &debug_line);

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      tinsn = &vinsn->slots[slot];
      frag_now->tc_frag_data.slot_subtypes[slot] = tinsn->subtype;
      frag_now->tc_frag_data.slot_symbols[slot] = tinsn->symbol;
      frag_now->tc_frag_data.slot_offsets[slot] = tinsn->offset;
      frag_now->tc_frag_data.literal_frags[slot] = tinsn->literal_frag;
      if (tinsn->literal_space != 0)
	xg_assemble_literal_space (tinsn->literal_space, slot);
      frag_now->tc_frag_data.free_reg[slot] = tinsn->extra_arg;

      if (tinsn->subtype == RELAX_NARROW)
	gas_assert (vinsn->num_slots == 1);
      if (xtensa_opcode_is_jump (isa, tinsn->opcode) == 1)
	is_jump = TRUE;
      if (xtensa_opcode_is_branch (isa, tinsn->opcode) == 1)
	is_branch = TRUE;

      if (tinsn->subtype || tinsn->symbol || tinsn->offset
	  || tinsn->literal_frag || is_jump || is_branch)
	finish_frag = TRUE;
    }

  if (vinsn_has_specific_opcodes (vinsn) && use_transform ())
    frag_now->tc_frag_data.is_specific_opcode = TRUE;

  if (finish_frag)
    {
      frag_variant (rs_machine_dependent,
		    extra_space, extra_space, RELAX_SLOTS,
		    frag_now->fr_symbol, frag_now->fr_offset, f);
      xtensa_set_frag_assembly_state (frag_now);
    }

  /* Special cases for loops:
     close_loop_end should be inserted AFTER short_loop.
     Make sure that CLOSE loops are processed BEFORE short_loops
     when converting them.  */

  /* "short_loop": Add a NOP if the loop is < 4 bytes.  */
  if (xtensa_opcode_is_loop (isa, vinsn->slots[0].opcode) == 1
      && !vinsn->slots[0].is_specific_opcode)
    {
      if (workaround_short_loop && use_transform ())
	{
	  maybe_has_short_loop = TRUE;
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_SHORT_LOOP,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_SHORT_LOOP,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	}

      /* "close_loop_end": Add up to 12 bytes of NOPs to keep a
	 loop at least 12 bytes away from another loop's end.  */
      if (workaround_close_loop_end && use_transform ())
	{
	  maybe_has_close_loop_end = TRUE;
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 12, 12,
		    RELAX_ADD_NOP_IF_CLOSE_LOOP_END,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	}
    }

  if (use_transform ())
    {
      if (is_jump)
	{
	  gas_assert (finish_frag);
	  frag_var (rs_machine_dependent,
		    xtensa_fetch_width, xtensa_fetch_width,
		    RELAX_UNREACHABLE,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	}
      else if (is_branch && do_align_targets ())
	{
	  gas_assert (finish_frag);
	  frag_var (rs_machine_dependent,
		    xtensa_fetch_width, xtensa_fetch_width,
		    RELAX_MAYBE_UNREACHABLE,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	  frag_var (rs_machine_dependent,
		    0, 0,
		    RELAX_MAYBE_DESIRE_ALIGN,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	}
    }

  /* Now, if the original opcode was a call...  */
  if (do_align_targets ()
      && xtensa_opcode_is_call (isa, vinsn->slots[0].opcode) == 1)
    {
      float freq = get_subseg_total_freq (now_seg, now_subseg);
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, (int) freq, RELAX_DESIRE_ALIGN,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }

  if (vinsn_has_specific_opcodes (vinsn) && use_transform ())
    {
      frag_wane (frag_now);
      frag_new (0);
      xtensa_set_frag_assembly_state (frag_now);
    }
}


/* xtensa_end and helper functions.  */

static void xtensa_cleanup_align_frags (void);
static void xtensa_fix_target_frags (void);
static void xtensa_mark_narrow_branches (void);
static void xtensa_mark_zcl_first_insns (void);
static void xtensa_mark_difference_of_two_symbols (void);
static void xtensa_fix_a0_b_retw_frags (void);
static void xtensa_fix_b_j_loop_end_frags (void);
static void xtensa_fix_close_loop_end_frags (void);
static void xtensa_fix_short_loop_frags (void);
static void xtensa_sanity_check (void);
static void xtensa_add_config_info (void);

void
xtensa_end (void)
{
  directive_balance ();
  xtensa_flush_pending_output ();

  past_xtensa_end = TRUE;

  xtensa_move_literals ();

  xtensa_reorder_segments ();
  xtensa_cleanup_align_frags ();
  xtensa_fix_target_frags ();
  if (workaround_a0_b_retw && has_a0_b_retw)
    xtensa_fix_a0_b_retw_frags ();
  if (workaround_b_j_loop_end)
    xtensa_fix_b_j_loop_end_frags ();

  /* "close_loop_end" should be processed BEFORE "short_loop".  */
  if (workaround_close_loop_end && maybe_has_close_loop_end)
    xtensa_fix_close_loop_end_frags ();

  if (workaround_short_loop && maybe_has_short_loop)
    xtensa_fix_short_loop_frags ();
  if (align_targets)
    xtensa_mark_narrow_branches ();
  xtensa_mark_zcl_first_insns ();

  xtensa_sanity_check ();

  xtensa_add_config_info ();
}


static void
xtensa_cleanup_align_frags (void)
{
  frchainS *frchP;
  asection *s;

  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;
	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if ((fragP->fr_type == rs_align
		 || fragP->fr_type == rs_align_code
		 || (fragP->fr_type == rs_machine_dependent
		     && (fragP->fr_subtype == RELAX_DESIRE_ALIGN
			 || fragP->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)))
		&& fragP->fr_fix == 0)
	      {
		fragS *next = fragP->fr_next;

		while (next
		       && next->fr_fix == 0
		       && next->fr_type == rs_machine_dependent
		       && next->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)
		  {
		    frag_wane (next);
		    next = next->fr_next;
		  }
	      }
	    /* If we don't widen branch targets, then they
	       will be easier to align.  */
	    if (fragP->tc_frag_data.is_branch_target
		&& fragP->fr_opcode == fragP->fr_literal
		&& fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_SLOTS
		&& fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
	      frag_wane (fragP);
	    if (fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_UNREACHABLE)
	      fragP->tc_frag_data.is_unreachable = TRUE;
	  }
      }
}


/* Re-process all of the fragments looking to convert all of the
   RELAX_DESIRE_ALIGN_IF_TARGET fragments.  If there is a branch
   target in the next fragment, convert this to RELAX_DESIRE_ALIGN.
   Otherwise, convert to a .fill 0.  */

static void
xtensa_fix_target_frags (void)
{
  frchainS *frchP;
  asection *s;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;

	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if (fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)
	      {
		if (next_frag_is_branch_target (fragP))
		  fragP->fr_subtype = RELAX_DESIRE_ALIGN;
		else
		  frag_wane (fragP);
	      }
	  }
      }
}


static bfd_boolean is_narrow_branch_guaranteed_in_range (fragS *, TInsn *);

static void
xtensa_mark_narrow_branches (void)
{
  frchainS *frchP;
  asection *s;

  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;
	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if (fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_SLOTS
		&& fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED)
	      {
		vliw_insn vinsn;

		vinsn_from_chars (&vinsn, fragP->fr_opcode);
		tinsn_immed_from_frag (&vinsn.slots[0], fragP, 0);

		if (vinsn.num_slots == 1
		    && xtensa_opcode_is_branch (xtensa_default_isa,
						vinsn.slots[0].opcode) == 1
		    && xg_get_single_size (vinsn.slots[0].opcode) == 2
		    && is_narrow_branch_guaranteed_in_range (fragP,
							     &vinsn.slots[0]))
		  {
		    fragP->fr_subtype = RELAX_SLOTS;
		    fragP->tc_frag_data.slot_subtypes[0] = RELAX_NARROW;
		    fragP->tc_frag_data.is_aligning_branch = 1;
		  }
	      }
	  }
      }
}


/* A branch is typically widened only when its target is out of
   range.  However, we would like to widen them to align a subsequent
   branch target when possible.

   Because the branch relaxation code is so convoluted, the optimal solution
   (combining the two cases) is difficult to get right in all circumstances.
   We therefore go with an "almost as good" solution, where we only
   use for alignment narrow branches that definitely will not expand to a
   jump and a branch.  These functions find and mark these cases.  */

/* The range in bytes of BNEZ.N and BEQZ.N.  The target operand is encoded
   as PC + 4 + imm6, where imm6 is a 6-bit immediate ranging from 0 to 63.
   We start counting beginning with the frag after the 2-byte branch, so the
   maximum offset is (4 - 2) + 63 = 65.  */
#define MAX_IMMED6 65

static offsetT unrelaxed_frag_max_size (fragS *);

static bfd_boolean
is_narrow_branch_guaranteed_in_range (fragS *fragP, TInsn *tinsn)
{
  const expressionS *exp = &tinsn->tok[1];
  symbolS *symbolP = exp->X_add_symbol;
  offsetT max_distance = exp->X_add_number;
  fragS *target_frag;

  if (exp->X_op != O_symbol)
    return FALSE;

  target_frag = symbol_get_frag (symbolP);

  max_distance += (S_GET_VALUE (symbolP) - target_frag->fr_address);
  if (is_branch_jmp_to_next (tinsn, fragP))
    return FALSE;

  /* The branch doesn't branch over it's own frag,
     but over the subsequent ones.  */
  fragP = fragP->fr_next;
  while (fragP != NULL && fragP != target_frag && max_distance <= MAX_IMMED6)
    {
      max_distance += unrelaxed_frag_max_size (fragP);
      fragP = fragP->fr_next;
    }
  if (max_distance <= MAX_IMMED6 && fragP == target_frag)
    return TRUE;
  return FALSE;
}


static void
xtensa_mark_zcl_first_insns (void)
{
  frchainS *frchP;
  asection *s;

  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;
	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if (fragP->fr_type == rs_machine_dependent
		&& (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE
		    || fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE))
	      {
		/* Find the loop frag.  */
		fragS *loop_frag = next_non_empty_frag (fragP);
		/* Find the first insn frag.  */
		fragS *targ_frag = next_non_empty_frag (loop_frag);

	      /* Handle a corner case that comes up in hardware
		 diagnostics.  The original assembly looks like this:
		 
		 loop aX, LabelA
		 <empty_frag>--not found by next_non_empty_frag
		 loop aY, LabelB

		 Depending on the start address, the assembler may or
		 may not change it to look something like this:

		 loop aX, LabelA
		 nop--frag isn't empty anymore
		 loop aY, LabelB

		 So set up to check the alignment of the nop if it
		 exists  */
		while (loop_frag != targ_frag)
		  {
		    if (loop_frag->fr_type == rs_machine_dependent
			&& (loop_frag->fr_subtype == RELAX_ALIGN_NEXT_OPCODE
			    || loop_frag->fr_subtype 
			    == RELAX_CHECK_ALIGN_NEXT_OPCODE))
		      targ_frag = loop_frag;
		    else
		      loop_frag = loop_frag->fr_next;
		  }

		/* Of course, sometimes (mostly for toy test cases) a
		   zero-cost loop instruction is the last in a section.  */
		if (targ_frag)
		  {
		    targ_frag->tc_frag_data.is_first_loop_insn = TRUE;
		    /* Do not widen a frag that is the first instruction of a
		       zero-cost loop.  It makes that loop harder to align.  */
		    if (targ_frag->fr_type == rs_machine_dependent
			&& targ_frag->fr_subtype == RELAX_SLOTS
			&& (targ_frag->tc_frag_data.slot_subtypes[0]
			    == RELAX_NARROW))
		      {
			if (targ_frag->tc_frag_data.is_aligning_branch)
			  targ_frag->tc_frag_data.slot_subtypes[0] = RELAX_IMMED;
			else
			  {
			    frag_wane (targ_frag);
			    targ_frag->tc_frag_data.slot_subtypes[0] = 0;
			  }
		      }
		  }
		if (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)
		  frag_wane (fragP);
	      }
	  }
      }
}


/* When a difference-of-symbols expression is encoded as a uleb128 or
   sleb128 value, the linker is unable to adjust that value to account for
   link-time relaxation.  Mark all the code between such symbols so that
   its size cannot be changed by linker relaxation.  */
  
static void
xtensa_mark_difference_of_two_symbols (void)
{
  symbolS *expr_sym;

  for (expr_sym = expr_symbols; expr_sym; 
       expr_sym = symbol_get_tc (expr_sym)->next_expr_symbol)
    {
      expressionS *exp = symbol_get_value_expression (expr_sym);

      if (exp->X_op == O_subtract)
	{
	  symbolS *left = exp->X_add_symbol;
	  symbolS *right = exp->X_op_symbol;
	  
	  /* Difference of two symbols not in the same section
	     are handled with relocations in the linker.  */
	  if (S_GET_SEGMENT (left) == S_GET_SEGMENT (right))
	    {
	      fragS *start;
	      fragS *end;
	      fragS *walk;

	      if (symbol_get_frag (left)->fr_address 
		  <= symbol_get_frag (right)->fr_address)
		{
		  start = symbol_get_frag (left);
		  end = symbol_get_frag (right);
		}
	      else
		{
		  start = symbol_get_frag (right);
		  end = symbol_get_frag (left);
		}

	      if (start->tc_frag_data.no_transform_end != NULL)
		walk = start->tc_frag_data.no_transform_end;
	      else
		walk = start;
	      do 
		{
		  walk->tc_frag_data.is_no_transform = 1;
		  walk = walk->fr_next;
		}
	      while (walk && walk->fr_address < end->fr_address);

	      start->tc_frag_data.no_transform_end = walk;
	    }
	}
    }
}


/* Re-process all of the fragments looking to convert all of the
   RELAX_ADD_NOP_IF_A0_B_RETW.  If the next instruction is a
   conditional branch or a retw/retw.n, convert this frag to one that
   will generate a NOP.  In any case close it off with a .fill 0.  */

static bfd_boolean next_instrs_are_b_retw (fragS *);

static void
xtensa_fix_a0_b_retw_frags (void)
{
  frchainS *frchP;
  asection *s;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;

	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if (fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_ADD_NOP_IF_A0_B_RETW)
	      {
		if (next_instrs_are_b_retw (fragP))
		  {
		    if (fragP->tc_frag_data.is_no_transform)
		      as_bad (_("instruction sequence (write a0, branch, retw) may trigger hardware errata"));
		    else
		      relax_frag_add_nop (fragP);
		  }
		frag_wane (fragP);
	      }
	  }
      }
}


static bfd_boolean
next_instrs_are_b_retw (fragS *fragP)
{
  xtensa_opcode opcode;
  xtensa_format fmt;
  const fragS *next_fragP = next_non_empty_frag (fragP);
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  int offset = 0;
  int slot;
  bfd_boolean branch_seen = FALSE;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  if (next_fragP == NULL)
    return FALSE;

  /* Check for the conditional branch.  */
  xtensa_insnbuf_from_chars
    (isa, insnbuf, (unsigned char *) &next_fragP->fr_literal[offset], 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return FALSE;

  for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
    {
      xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
      opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);

      branch_seen = (branch_seen
		     || xtensa_opcode_is_branch (isa, opcode) == 1);
    }

  if (!branch_seen)
    return FALSE;

  offset += xtensa_format_length (isa, fmt);
  if (offset == next_fragP->fr_fix)
    {
      next_fragP = next_non_empty_frag (next_fragP);
      offset = 0;
    }

  if (next_fragP == NULL)
    return FALSE;

  /* Check for the retw/retw.n.  */
  xtensa_insnbuf_from_chars
    (isa, insnbuf, (unsigned char *) &next_fragP->fr_literal[offset], 0);
  fmt = xtensa_format_decode (isa, insnbuf);

  /* Because RETW[.N] is not bundleable, a VLIW bundle here means that we
     have no problems.  */
  if (fmt == XTENSA_UNDEFINED
      || xtensa_format_num_slots (isa, fmt) != 1)
    return FALSE;

  xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);

  if (opcode == xtensa_retw_opcode || opcode == xtensa_retw_n_opcode)
    return TRUE;

  return FALSE;
}


/* Re-process all of the fragments looking to convert all of the
   RELAX_ADD_NOP_IF_PRE_LOOP_END.  If there is one instruction and a
   loop end label, convert this frag to one that will generate a NOP.
   In any case close it off with a .fill 0.  */

static bfd_boolean next_instr_is_loop_end (fragS *);

static void
xtensa_fix_b_j_loop_end_frags (void)
{
  frchainS *frchP;
  asection *s;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;

	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if (fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_ADD_NOP_IF_PRE_LOOP_END)
	      {
		if (next_instr_is_loop_end (fragP))
		  {
		    if (fragP->tc_frag_data.is_no_transform)
		      as_bad (_("branching or jumping to a loop end may trigger hardware errata"));
		    else
		      relax_frag_add_nop (fragP);
		  }
		frag_wane (fragP);
	      }
	  }
      }
}


static bfd_boolean
next_instr_is_loop_end (fragS *fragP)
{
  const fragS *next_fragP;

  if (next_frag_is_loop_target (fragP))
    return FALSE;

  next_fragP = next_non_empty_frag (fragP);
  if (next_fragP == NULL)
    return FALSE;

  if (!next_frag_is_loop_target (next_fragP))
    return FALSE;

  /* If the size is >= 3 then there is more than one instruction here.
     The hardware bug will not fire.  */
  if (next_fragP->fr_fix > 3)
    return FALSE;

  return TRUE;
}


/* Re-process all of the fragments looking to convert all of the
   RELAX_ADD_NOP_IF_CLOSE_LOOP_END.  If there is an loop end that is
   not MY loop's loop end within 12 bytes, add enough nops here to
   make it at least 12 bytes away.  In any case close it off with a
   .fill 0.  */

static offsetT min_bytes_to_other_loop_end
  (fragS *, fragS *, offsetT);

static void
xtensa_fix_close_loop_end_frags (void)
{
  frchainS *frchP;
  asection *s;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;

	fragS *current_target = NULL;

	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if (fragP->fr_type == rs_machine_dependent
		&& ((fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
		    || (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)))
	      current_target = symbol_get_frag (fragP->fr_symbol);

	    if (current_target
		&& fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_ADD_NOP_IF_CLOSE_LOOP_END)
	      {
		offsetT min_bytes;
		int bytes_added = 0;

#define REQUIRED_LOOP_DIVIDING_BYTES 12
		/* Max out at 12.  */
		min_bytes = min_bytes_to_other_loop_end
		  (fragP->fr_next, current_target, REQUIRED_LOOP_DIVIDING_BYTES);

		if (min_bytes < REQUIRED_LOOP_DIVIDING_BYTES)
		  {
		    if (fragP->tc_frag_data.is_no_transform)
		      as_bad (_("loop end too close to another loop end may trigger hardware errata"));
		    else
		      {
			while (min_bytes + bytes_added
			       < REQUIRED_LOOP_DIVIDING_BYTES)
			  {
			    int length = 3;

			    if (fragP->fr_var < length)
			      as_fatal (_("fr_var %lu < length %d"),
					(long) fragP->fr_var, length);
			    else
			      {
				assemble_nop (length,
					      fragP->fr_literal + fragP->fr_fix);
				fragP->fr_fix += length;
				fragP->fr_var -= length;
			      }
			    bytes_added += length;
			  }
		      }
		  }
		frag_wane (fragP);
	      }
	    gas_assert (fragP->fr_type != rs_machine_dependent
		    || fragP->fr_subtype != RELAX_ADD_NOP_IF_CLOSE_LOOP_END);
	  }
      }
}


static offsetT unrelaxed_frag_min_size (fragS *);

static offsetT
min_bytes_to_other_loop_end (fragS *fragP,
			     fragS *current_target,
			     offsetT max_size)
{
  offsetT offset = 0;
  fragS *current_fragP;

  for (current_fragP = fragP;
       current_fragP;
       current_fragP = current_fragP->fr_next)
    {
      if (current_fragP->tc_frag_data.is_loop_target
	  && current_fragP != current_target)
	return offset;

      offset += unrelaxed_frag_min_size (current_fragP);

      if (offset >= max_size)
	return max_size;
    }
  return max_size;
}


static offsetT
unrelaxed_frag_min_size (fragS *fragP)
{
  offsetT size = fragP->fr_fix;

  /* Add fill size.  */
  if (fragP->fr_type == rs_fill)
    size += fragP->fr_offset;

  return size;
}


static offsetT
unrelaxed_frag_max_size (fragS *fragP)
{
  offsetT size = fragP->fr_fix;
  switch (fragP->fr_type)
    {
    case 0:
      /* Empty frags created by the obstack allocation scheme
	 end up with type 0.  */
      break;
    case rs_fill:
    case rs_org:
    case rs_space:
      size += fragP->fr_offset;
      break;
    case rs_align:
    case rs_align_code:
    case rs_align_test:
    case rs_leb128:
    case rs_cfa:
    case rs_dwarf2dbg:
      /* No further adjustments needed.  */
      break;
    case rs_machine_dependent:
      if (fragP->fr_subtype != RELAX_DESIRE_ALIGN)
	size += fragP->fr_var;
      break;
    default:
      /* We had darn well better know how big it is.  */
      gas_assert (0);
      break;
    }

  return size;
}


/* Re-process all of the fragments looking to convert all
   of the RELAX_ADD_NOP_IF_SHORT_LOOP.  If:

   A)
     1) the instruction size count to the loop end label
        is too short (<= 2 instructions),
     2) loop has a jump or branch in it

   or B)
     1) workaround_all_short_loops is TRUE
     2) The generating loop was a  'loopgtz' or 'loopnez'
     3) the instruction size count to the loop end label is too short
        (<= 2 instructions)
   then convert this frag (and maybe the next one) to generate a NOP.
   In any case close it off with a .fill 0.  */

static int count_insns_to_loop_end (fragS *, bfd_boolean, int);
static bfd_boolean branch_before_loop_end (fragS *);

static void
xtensa_fix_short_loop_frags (void)
{
  frchainS *frchP;
  asection *s;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;
	xtensa_opcode current_opcode = XTENSA_UNDEFINED;

	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if (fragP->fr_type == rs_machine_dependent
		&& ((fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
		    || (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)))
	      {
		TInsn t_insn;
		fragS *loop_frag = next_non_empty_frag (fragP);
		tinsn_from_chars (&t_insn, loop_frag->fr_opcode, 0);
		current_opcode = t_insn.opcode;
		gas_assert (xtensa_opcode_is_loop (xtensa_default_isa,
					       current_opcode) == 1);
	      }

	    if (fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_ADD_NOP_IF_SHORT_LOOP)
	      {
		if (count_insns_to_loop_end (fragP->fr_next, TRUE, 3) < 3
		    && (branch_before_loop_end (fragP->fr_next)
			|| (workaround_all_short_loops
			    && current_opcode != XTENSA_UNDEFINED
			    && current_opcode != xtensa_loop_opcode)))
		  {
		    if (fragP->tc_frag_data.is_no_transform)
		      as_bad (_("loop containing less than three instructions may trigger hardware errata"));
		    else
		      relax_frag_add_nop (fragP);
		  }
		frag_wane (fragP);
	      }
	  }
      }
}


static int unrelaxed_frag_min_insn_count (fragS *);

static int
count_insns_to_loop_end (fragS *base_fragP,
			 bfd_boolean count_relax_add,
			 int max_count)
{
  fragS *fragP = NULL;
  int insn_count = 0;

  fragP = base_fragP;

  for (; fragP && !fragP->tc_frag_data.is_loop_target; fragP = fragP->fr_next)
    {
      insn_count += unrelaxed_frag_min_insn_count (fragP);
      if (insn_count >= max_count)
	return max_count;

      if (count_relax_add)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_SHORT_LOOP)
	    {
	      /* In order to add the appropriate number of
	         NOPs, we count an instruction for downstream
	         occurrences.  */
	      insn_count++;
	      if (insn_count >= max_count)
		return max_count;
	    }
	}
    }
  return insn_count;
}


static int
unrelaxed_frag_min_insn_count (fragS *fragP)
{
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf insnbuf = NULL;
  int insn_count = 0;
  int offset = 0;

  if (!fragP->tc_frag_data.is_insn)
    return insn_count;

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  /* Decode the fixed instructions.  */
  while (offset < fragP->fr_fix)
    {
      xtensa_format fmt;

      xtensa_insnbuf_from_chars
	(isa, insnbuf, (unsigned char *) fragP->fr_literal + offset, 0);
      fmt = xtensa_format_decode (isa, insnbuf);

      if (fmt == XTENSA_UNDEFINED)
	{
	  as_fatal (_("undecodable instruction in instruction frag"));
	  return insn_count;
	}
      offset += xtensa_format_length (isa, fmt);
      insn_count++;
    }

  return insn_count;
}


static bfd_boolean unrelaxed_frag_has_b_j (fragS *);

static bfd_boolean
branch_before_loop_end (fragS *base_fragP)
{
  fragS *fragP;

  for (fragP = base_fragP;
       fragP && !fragP->tc_frag_data.is_loop_target;
       fragP = fragP->fr_next)
    {
      if (unrelaxed_frag_has_b_j (fragP))
	return TRUE;
    }
  return FALSE;
}


static bfd_boolean
unrelaxed_frag_has_b_j (fragS *fragP)
{
  static xtensa_insnbuf insnbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  int offset = 0;

  if (!fragP->tc_frag_data.is_insn)
    return FALSE;

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  /* Decode the fixed instructions.  */
  while (offset < fragP->fr_fix)
    {
      xtensa_format fmt;
      int slot;

      xtensa_insnbuf_from_chars
	(isa, insnbuf, (unsigned char *) fragP->fr_literal + offset, 0);
      fmt = xtensa_format_decode (isa, insnbuf);
      if (fmt == XTENSA_UNDEFINED)
	return FALSE;

      for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
	{
	  xtensa_opcode opcode =
	    get_opcode_from_buf (fragP->fr_literal + offset, slot);
	  if (xtensa_opcode_is_branch (isa, opcode) == 1
	      || xtensa_opcode_is_jump (isa, opcode) == 1)
	    return TRUE;
	}
      offset += xtensa_format_length (isa, fmt);
    }
  return FALSE;
}


/* Checks to be made after initial assembly but before relaxation.  */

static bfd_boolean is_empty_loop (const TInsn *, fragS *);
static bfd_boolean is_local_forward_loop (const TInsn *, fragS *);

static void
xtensa_sanity_check (void)
{
  char *file_name;
  unsigned line;
  frchainS *frchP;
  asection *s;

  as_where (&file_name, &line);
  for (s = stdoutput->sections; s; s = s->next)
    for (frchP = seg_info (s)->frchainP; frchP; frchP = frchP->frch_next)
      {
	fragS *fragP;

	/* Walk over all of the fragments in a subsection.  */
	for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	  {
	    if (fragP->fr_type == rs_machine_dependent
		&& fragP->fr_subtype == RELAX_SLOTS 
		&& fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED)
	      {
		static xtensa_insnbuf insnbuf = NULL;
		TInsn t_insn;

		if (fragP->fr_opcode != NULL)
		  {
		    if (!insnbuf)
		      insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
		    tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
		    tinsn_immed_from_frag (&t_insn, fragP, 0);

		    if (xtensa_opcode_is_loop (xtensa_default_isa,
					       t_insn.opcode) == 1)
		      {
			if (is_empty_loop (&t_insn, fragP))
			  {
			    new_logical_line (fragP->fr_file, fragP->fr_line);
			    as_bad (_("invalid empty loop"));
			  }
			if (!is_local_forward_loop (&t_insn, fragP))
			  {
			    new_logical_line (fragP->fr_file, fragP->fr_line);
			    as_bad (_("loop target does not follow "
				      "loop instruction in section"));
			  }
		      }
		  }
	      }
	  }
      }
  new_logical_line (file_name, line);
}


#define LOOP_IMMED_OPN 1

/* Return TRUE if the loop target is the next non-zero fragment.  */

static bfd_boolean
is_empty_loop (const TInsn *insn, fragS *fragP)
{
  const expressionS *exp;
  symbolS *symbolP;
  fragS *next_fragP;

  if (insn->insn_type != ITYPE_INSN)
    return FALSE;

  if (xtensa_opcode_is_loop (xtensa_default_isa, insn->opcode) != 1)
    return FALSE;

  if (insn->ntok <= LOOP_IMMED_OPN)
    return FALSE;

  exp = &insn->tok[LOOP_IMMED_OPN];

  if (exp->X_op != O_symbol)
    return FALSE;

  symbolP = exp->X_add_symbol;
  if (!symbolP)
    return FALSE;

  if (symbol_get_frag (symbolP) == NULL)
    return FALSE;

  if (S_GET_VALUE (symbolP) != 0)
    return FALSE;

  /* Walk through the zero-size fragments from this one.  If we find
     the target fragment, then this is a zero-size loop.  */

  for (next_fragP = fragP->fr_next;
       next_fragP != NULL;
       next_fragP = next_fragP->fr_next)
    {
      if (next_fragP == symbol_get_frag (symbolP))
	return TRUE;
      if (next_fragP->fr_fix != 0)
	return FALSE;
    }
  return FALSE;
}


static bfd_boolean
is_local_forward_loop (const TInsn *insn, fragS *fragP)
{
  const expressionS *exp;
  symbolS *symbolP;
  fragS *next_fragP;

  if (insn->insn_type != ITYPE_INSN)
    return FALSE;

  if (xtensa_opcode_is_loop (xtensa_default_isa, insn->opcode) != 1)
    return FALSE;

  if (insn->ntok <= LOOP_IMMED_OPN)
    return FALSE;

  exp = &insn->tok[LOOP_IMMED_OPN];

  if (exp->X_op != O_symbol)
    return FALSE;

  symbolP = exp->X_add_symbol;
  if (!symbolP)
    return FALSE;

  if (symbol_get_frag (symbolP) == NULL)
    return FALSE;

  /* Walk through fragments until we find the target.
     If we do not find the target, then this is an invalid loop.  */

  for (next_fragP = fragP->fr_next;
       next_fragP != NULL;
       next_fragP = next_fragP->fr_next)
    {
      if (next_fragP == symbol_get_frag (symbolP))
	return TRUE;
    }

  return FALSE;
}


#define XTINFO_NAME "Xtensa_Info"
#define XTINFO_NAMESZ 12
#define XTINFO_TYPE 1

static void
xtensa_add_config_info (void)
{
  asection *info_sec;
  char *data, *p;
  int sz;

  info_sec = subseg_new (".xtensa.info", 0);
  bfd_set_section_flags (stdoutput, info_sec, SEC_HAS_CONTENTS | SEC_READONLY);

  data = xmalloc (100);
  sprintf (data, "USE_ABSOLUTE_LITERALS=%d\nABI=%d\n",
	   XSHAL_USE_ABSOLUTE_LITERALS, XSHAL_ABI);
  sz = strlen (data) + 1;

  /* Add enough null terminators to pad to a word boundary.  */
  do
    data[sz++] = 0;
  while ((sz & 3) != 0);

  /* Follow the standard note section layout:
     First write the length of the name string.  */
  p = frag_more (4);
  md_number_to_chars (p, (valueT) XTINFO_NAMESZ, 4);

  /* Next comes the length of the "descriptor", i.e., the actual data.  */
  p = frag_more (4);
  md_number_to_chars (p, (valueT) sz, 4);

  /* Write the note type.  */
  p = frag_more (4);
  md_number_to_chars (p, (valueT) XTINFO_TYPE, 4);

  /* Write the name field.  */
  p = frag_more (XTINFO_NAMESZ);
  memcpy (p, XTINFO_NAME, XTINFO_NAMESZ);

  /* Finally, write the descriptor.  */
  p = frag_more (sz);
  memcpy (p, data, sz);

  free (data);
}


/* Alignment Functions.  */

static int
get_text_align_power (unsigned target_size)
{
  if (target_size <= 4)
    return 2;

  if (target_size <= 8)
    return 3;

  if (target_size <= 16)
    return 4;

  if (target_size <= 32)
    return 5;

  if (target_size <= 64)
    return 6;

  if (target_size <= 128)
    return 7;

  if (target_size <= 256)
    return 8;

  if (target_size <= 512)
    return 9;

  if (target_size <= 1024)
    return 10;

  gas_assert (0);
  return 0;
}


static int
get_text_align_max_fill_size (int align_pow,
			      bfd_boolean use_nops,
			      bfd_boolean use_no_density)
{
  if (!use_nops)
    return (1 << align_pow);
  if (use_no_density)
    return 3 * (1 << align_pow);

  return 1 + (1 << align_pow);
}


/* Calculate the minimum bytes of fill needed at "address" to align a
   target instruction of size "target_size" so that it does not cross a
   power-of-two boundary specified by "align_pow".  If "use_nops" is FALSE,
   the fill can be an arbitrary number of bytes.  Otherwise, the space must
   be filled by NOP instructions.  */

static int
get_text_align_fill_size (addressT address,
			  int align_pow,
			  int target_size,
			  bfd_boolean use_nops,
			  bfd_boolean use_no_density)
{
  addressT alignment, fill, fill_limit, fill_step;
  bfd_boolean skip_one = FALSE;

  alignment = (1 << align_pow);
  gas_assert (target_size > 0 && alignment >= (addressT) target_size);

  if (!use_nops)
    {
      fill_limit = alignment;
      fill_step = 1;
    }
  else if (!use_no_density)
    {
      /* Combine 2- and 3-byte NOPs to fill anything larger than one.  */
      fill_limit = alignment * 2;
      fill_step = 1;
      skip_one = TRUE;
    }
  else
    {
      /* Fill with 3-byte NOPs -- can only fill multiples of 3.  */
      fill_limit = alignment * 3;
      fill_step = 3;
    }

  /* Try all fill sizes until finding one that works.  */
  for (fill = 0; fill < fill_limit; fill += fill_step)
    {
      if (skip_one && fill == 1)
	continue;
      if ((address + fill) >> align_pow
	  == (address + fill + target_size - 1) >> align_pow)
	return fill;
    }
  gas_assert (0);
  return 0;
}


static int
branch_align_power (segT sec)
{
  /* If the Xtensa processor has a fetch width of X, and
     the section is aligned to at least that boundary, then a branch
     target need only fit within that aligned block of memory to avoid
     a stall.  Otherwise, try to fit branch targets within 4-byte
     aligned blocks (which may be insufficient, e.g., if the section
     has no alignment, but it's good enough).  */
  int fetch_align = get_text_align_power(xtensa_fetch_width);
  int sec_align = get_recorded_alignment (sec);

  if (sec_align >= fetch_align)
    return fetch_align;

  return 2;
}


/* This will assert if it is not possible.  */

static int
get_text_align_nop_count (offsetT fill_size, bfd_boolean use_no_density)
{
  int count = 0;

  if (use_no_density)
    {
      gas_assert (fill_size % 3 == 0);
      return (fill_size / 3);
    }

  gas_assert (fill_size != 1);	/* Bad argument.  */

  while (fill_size > 1)
    {
      int insn_size = 3;
      if (fill_size == 2 || fill_size == 4)
	insn_size = 2;
      fill_size -= insn_size;
      count++;
    }
  gas_assert (fill_size != 1);	/* Bad algorithm.  */
  return count;
}


static int
get_text_align_nth_nop_size (offsetT fill_size,
			     int n,
			     bfd_boolean use_no_density)
{
  int count = 0;

  if (use_no_density)
    return 3;

  gas_assert (fill_size != 1);	/* Bad argument.  */

  while (fill_size > 1)
    {
      int insn_size = 3;
      if (fill_size == 2 || fill_size == 4)
	insn_size = 2;
      fill_size -= insn_size;
      count++;
      if (n + 1 == count)
	return insn_size;
    }
  gas_assert (0);
  return 0;
}


/* For the given fragment, find the appropriate address
   for it to begin at if we are using NOPs to align it.  */

static addressT
get_noop_aligned_address (fragS *fragP, addressT address)
{
  /* The rule is: get next fragment's FIRST instruction.  Find
     the smallest number of bytes that need to be added to
     ensure that the next fragment's FIRST instruction will fit
     in a single word.

     E.G.,   2 bytes : 0, 1, 2 mod 4
	     3 bytes: 0, 1 mod 4

     If the FIRST instruction MIGHT be relaxed,
     assume that it will become a 3-byte instruction.

     Note again here that LOOP instructions are not bundleable,
     and this relaxation only applies to LOOP opcodes.  */

  int fill_size = 0;
  int first_insn_size;
  int loop_insn_size;
  addressT pre_opcode_bytes;
  int align_power;
  fragS *first_insn;
  xtensa_opcode opcode;
  bfd_boolean is_loop;

  gas_assert (fragP->fr_type == rs_machine_dependent);
  gas_assert (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE);

  /* Find the loop frag.  */
  first_insn = next_non_empty_frag (fragP);
  /* Now find the first insn frag.  */
  first_insn = next_non_empty_frag (first_insn);

  is_loop = next_frag_opcode_is_loop (fragP, &opcode);
  gas_assert (is_loop);
  loop_insn_size = xg_get_single_size (opcode);

  pre_opcode_bytes = next_frag_pre_opcode_bytes (fragP);
  pre_opcode_bytes += loop_insn_size;

  /* For loops, the alignment depends on the size of the
     instruction following the loop, not the LOOP instruction.  */

  if (first_insn == NULL)
    first_insn_size = xtensa_fetch_width;
  else
    first_insn_size = get_loop_align_size (frag_format_size (first_insn));

  /* If it was 8, then we'll need a larger alignment for the section.  */
  align_power = get_text_align_power (first_insn_size);
  record_alignment (now_seg, align_power);

  fill_size = get_text_align_fill_size
    (address + pre_opcode_bytes, align_power, first_insn_size, TRUE,
     fragP->tc_frag_data.is_no_density);

  return address + fill_size;
}


/* 3 mechanisms for relaxing an alignment:

   Align to a power of 2.
   Align so the next fragment's instruction does not cross a word boundary.
   Align the current instruction so that if the next instruction
       were 3 bytes, it would not cross a word boundary.

   We can align with:

   zeros    - This is easy; always insert zeros.
   nops     - 3-byte and 2-byte instructions
              2 - 2-byte nop
              3 - 3-byte nop
              4 - 2 2-byte nops
              >=5 : 3-byte instruction + fn (n-3)
   widening - widen previous instructions.  */

static offsetT
get_aligned_diff (fragS *fragP, addressT address, offsetT *max_diff)
{
  addressT target_address, loop_insn_offset;
  int target_size;
  xtensa_opcode loop_opcode;
  bfd_boolean is_loop;
  int align_power;
  offsetT opt_diff;
  offsetT branch_align;
  fragS *loop_frag;

  gas_assert (fragP->fr_type == rs_machine_dependent);
  switch (fragP->fr_subtype)
    {
    case RELAX_DESIRE_ALIGN:
      target_size = next_frag_format_size (fragP);
      if (target_size == XTENSA_UNDEFINED)
	target_size = 3;
      align_power = branch_align_power (now_seg);
      branch_align = 1 << align_power;
      /* Don't count on the section alignment being as large as the target.  */
      if (target_size > branch_align)
	target_size = branch_align;
      opt_diff = get_text_align_fill_size (address, align_power,
					   target_size, FALSE, FALSE);

      *max_diff = (opt_diff + branch_align
		   - (target_size + ((address + opt_diff) % branch_align)));
      gas_assert (*max_diff >= opt_diff);
      return opt_diff;

    case RELAX_ALIGN_NEXT_OPCODE:
      /* The next non-empty frag after this one holds the LOOP instruction
	 that needs to be aligned.  The required alignment depends on the
	 size of the next non-empty frag after the loop frag, i.e., the
	 first instruction in the loop.  */
      loop_frag = next_non_empty_frag (fragP);
      target_size = get_loop_align_size (next_frag_format_size (loop_frag));
      loop_insn_offset = 0;
      is_loop = next_frag_opcode_is_loop (fragP, &loop_opcode);
      gas_assert (is_loop);

      /* If the loop has been expanded then the LOOP instruction
	 could be at an offset from this fragment.  */
      if (loop_frag->tc_frag_data.slot_subtypes[0] != RELAX_IMMED)
	loop_insn_offset = get_expanded_loop_offset (loop_opcode);

      /* In an ideal world, which is what we are shooting for here,
	 we wouldn't need to use any NOPs immediately prior to the
	 LOOP instruction.  If this approach fails, relax_frag_loop_align
	 will call get_noop_aligned_address.  */
      target_address =
	address + loop_insn_offset + xg_get_single_size (loop_opcode);
      align_power = get_text_align_power (target_size);
      opt_diff = get_text_align_fill_size (target_address, align_power,
					   target_size, FALSE, FALSE);

      *max_diff = xtensa_fetch_width
	- ((target_address + opt_diff) % xtensa_fetch_width)
	- target_size + opt_diff;
      gas_assert (*max_diff >= opt_diff);
      return opt_diff;

    default:
      break;
    }
  gas_assert (0);
  return 0;
}


/* md_relax_frag Hook and Helper Functions.  */

static long relax_frag_loop_align (fragS *, long);
static long relax_frag_for_align (fragS *, long);
static long relax_frag_immed
  (segT, fragS *, long, int, xtensa_format, int, int *, bfd_boolean);


/* Return the number of bytes added to this fragment, given that the
   input has been stretched already by "stretch".  */

long
xtensa_relax_frag (fragS *fragP, long stretch, int *stretched_p)
{
  xtensa_isa isa = xtensa_default_isa;
  int unreported = fragP->tc_frag_data.unreported_expansion;
  long new_stretch = 0;
  char *file_name;
  unsigned line;
  int lit_size;
  static xtensa_insnbuf vbuf = NULL;
  int slot, num_slots;
  xtensa_format fmt;

  as_where (&file_name, &line);
  new_logical_line (fragP->fr_file, fragP->fr_line);

  fragP->tc_frag_data.unreported_expansion = 0;

  switch (fragP->fr_subtype)
    {
    case RELAX_ALIGN_NEXT_OPCODE:
      /* Always convert.  */
      if (fragP->tc_frag_data.relax_seen)
	new_stretch = relax_frag_loop_align (fragP, stretch);
      break;

    case RELAX_LOOP_END:
      /* Do nothing.  */
      break;

    case RELAX_LOOP_END_ADD_NOP:
      /* Add a NOP and switch to .fill 0.  */
      new_stretch = relax_frag_add_nop (fragP);
      frag_wane (fragP);
      break;

    case RELAX_DESIRE_ALIGN:
      /* Do nothing. The narrowing before this frag will either align
         it or not.  */
      break;

    case RELAX_LITERAL:
    case RELAX_LITERAL_FINAL:
      return 0;

    case RELAX_LITERAL_NR:
      lit_size = 4;
      fragP->fr_subtype = RELAX_LITERAL_FINAL;
      gas_assert (unreported == lit_size);
      memset (&fragP->fr_literal[fragP->fr_fix], 0, 4);
      fragP->fr_var -= lit_size;
      fragP->fr_fix += lit_size;
      new_stretch = 4;
      break;

    case RELAX_SLOTS:
      if (vbuf == NULL)
	vbuf = xtensa_insnbuf_alloc (isa);

      xtensa_insnbuf_from_chars
	(isa, vbuf, (unsigned char *) fragP->fr_opcode, 0);
      fmt = xtensa_format_decode (isa, vbuf);
      num_slots = xtensa_format_num_slots (isa, fmt);

      for (slot = 0; slot < num_slots; slot++)
	{
	  switch (fragP->tc_frag_data.slot_subtypes[slot])
	    {
	    case RELAX_NARROW:
	      if (fragP->tc_frag_data.relax_seen)
		new_stretch += relax_frag_for_align (fragP, stretch);
	      break;

	    case RELAX_IMMED:
	    case RELAX_IMMED_STEP1:
	    case RELAX_IMMED_STEP2:
	    case RELAX_IMMED_STEP3:
	      /* Place the immediate.  */
	      new_stretch += relax_frag_immed
		(now_seg, fragP, stretch,
		 fragP->tc_frag_data.slot_subtypes[slot] - RELAX_IMMED,
		 fmt, slot, stretched_p, FALSE);
	      break;

	    default:
	      /* This is OK; see the note in xg_assemble_vliw_tokens.  */
	      break;
	    }
	}
      break;

    case RELAX_LITERAL_POOL_BEGIN:
    case RELAX_LITERAL_POOL_END:
    case RELAX_MAYBE_UNREACHABLE:
    case RELAX_MAYBE_DESIRE_ALIGN:
      /* No relaxation required.  */
      break;

    case RELAX_FILL_NOP:
    case RELAX_UNREACHABLE:
      if (fragP->tc_frag_data.relax_seen)
	new_stretch += relax_frag_for_align (fragP, stretch);
      break;

    default:
      as_bad (_("bad relaxation state"));
    }

  /* Tell gas we need another relaxation pass.  */
  if (! fragP->tc_frag_data.relax_seen)
    {
      fragP->tc_frag_data.relax_seen = TRUE;
      *stretched_p = 1;
    }

  new_logical_line (file_name, line);
  return new_stretch;
}


static long
relax_frag_loop_align (fragS *fragP, long stretch)
{
  addressT old_address, old_next_address, old_size;
  addressT new_address, new_next_address, new_size;
  addressT growth;

  /* All the frags with relax_frag_for_alignment prior to this one in the
     section have been done, hopefully eliminating the need for a NOP here.
     But, this will put it in if necessary.  */

  /* Calculate the old address of this fragment and the next fragment.  */
  old_address = fragP->fr_address - stretch;
  old_next_address = (fragP->fr_address - stretch + fragP->fr_fix +
		      fragP->tc_frag_data.text_expansion[0]);
  old_size = old_next_address - old_address;

  /* Calculate the new address of this fragment and the next fragment.  */
  new_address = fragP->fr_address;
  new_next_address =
    get_noop_aligned_address (fragP, fragP->fr_address + fragP->fr_fix);
  new_size = new_next_address - new_address;

  growth = new_size - old_size;

  /* Fix up the text_expansion field and return the new growth.  */
  fragP->tc_frag_data.text_expansion[0] += growth;
  return growth;
}


/* Add a NOP instruction.  */

static long
relax_frag_add_nop (fragS *fragP)
{
  char *nop_buf = fragP->fr_literal + fragP->fr_fix;
  int length = fragP->tc_frag_data.is_no_density ? 3 : 2;
  assemble_nop (length, nop_buf);
  fragP->tc_frag_data.is_insn = TRUE;

  if (fragP->fr_var < length)
    {
      as_fatal (_("fr_var (%ld) < length (%d)"), (long) fragP->fr_var, length);
      return 0;
    }

  fragP->fr_fix += length;
  fragP->fr_var -= length;
  return length;
}


static long future_alignment_required (fragS *, long);

static long
relax_frag_for_align (fragS *fragP, long stretch)
{
  /* Overview of the relaxation procedure for alignment:
     We can widen with NOPs or by widening instructions or by filling
     bytes after jump instructions.  Find the opportune places and widen
     them if necessary.  */

  long stretch_me;
  long diff;

  gas_assert (fragP->fr_subtype == RELAX_FILL_NOP
	  || fragP->fr_subtype == RELAX_UNREACHABLE
	  || (fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW));

  stretch_me = future_alignment_required (fragP, stretch);
  diff = stretch_me - fragP->tc_frag_data.text_expansion[0];
  if (diff == 0)
    return 0;

  if (diff < 0)
    {
      /* We expanded on a previous pass.  Can we shrink now?  */
      long shrink = fragP->tc_frag_data.text_expansion[0] - stretch_me;
      if (shrink <= stretch && stretch > 0)
	{
	  fragP->tc_frag_data.text_expansion[0] = stretch_me;
	  return -shrink;
	}
      return 0;
    }

  /* Below here, diff > 0.  */
  fragP->tc_frag_data.text_expansion[0] = stretch_me;

  return diff;
}


/* Return the address of the next frag that should be aligned.

   By "address" we mean the address it _would_ be at if there
   is no action taken to align it between here and the target frag.
   In other words, if no narrows and no fill nops are used between
   here and the frag to align, _even_if_ some of the frags we use
   to align targets have already expanded on a previous relaxation
   pass.

   Also, count each frag that may be used to help align the target.

   Return 0 if there are no frags left in the chain that need to be
   aligned.  */

static addressT
find_address_of_next_align_frag (fragS **fragPP,
				 int *wide_nops,
				 int *narrow_nops,
				 int *widens,
				 bfd_boolean *paddable)
{
  fragS *fragP = *fragPP;
  addressT address = fragP->fr_address;

  /* Do not reset the counts to 0.  */

  while (fragP)
    {
      /* Limit this to a small search.  */
      if (*widens >= (int) xtensa_fetch_width)
	{
	  *fragPP = fragP;
	  return 0;
	}
      address += fragP->fr_fix;

      if (fragP->fr_type == rs_fill)
	address += fragP->fr_offset * fragP->fr_var;
      else if (fragP->fr_type == rs_machine_dependent)
	{
	  switch (fragP->fr_subtype)
	    {
	    case RELAX_UNREACHABLE:
	      *paddable = TRUE;
	      break;

	    case RELAX_FILL_NOP:
	      (*wide_nops)++;
	      if (!fragP->tc_frag_data.is_no_density)
		(*narrow_nops)++;
	      break;

	    case RELAX_SLOTS:
	      if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
		{
		  (*widens)++;
		  break;
		}
	      address += total_frag_text_expansion (fragP);
	      break;

	    case RELAX_IMMED:
	      address += fragP->tc_frag_data.text_expansion[0];
	      break;

	    case RELAX_ALIGN_NEXT_OPCODE:
	    case RELAX_DESIRE_ALIGN:
	      *fragPP = fragP;
	      return address;

	    case RELAX_MAYBE_UNREACHABLE:
	    case RELAX_MAYBE_DESIRE_ALIGN:
	      /* Do nothing.  */
	      break;

	    default:
	      /* Just punt if we don't know the type.  */
	      *fragPP = fragP;
	      return 0;
	    }
	}
      else
	{
	  /* Just punt if we don't know the type.  */
	  *fragPP = fragP;
	  return 0;
	}
      fragP = fragP->fr_next;
    }

  *fragPP = fragP;
  return 0;
}


static long bytes_to_stretch (fragS *, int, int, int, int);

static long
future_alignment_required (fragS *fragP, long stretch ATTRIBUTE_UNUSED)
{
  fragS *this_frag = fragP;
  long address;
  int num_widens = 0;
  int wide_nops = 0;
  int narrow_nops = 0;
  bfd_boolean paddable = FALSE;
  offsetT local_opt_diff;
  offsetT opt_diff;
  offsetT max_diff;
  int stretch_amount = 0;
  int local_stretch_amount;
  int global_stretch_amount;

  address = find_address_of_next_align_frag
    (&fragP, &wide_nops, &narrow_nops, &num_widens, &paddable);

  if (!address)
    {
      if (this_frag->tc_frag_data.is_aligning_branch)
	this_frag->tc_frag_data.slot_subtypes[0] = RELAX_IMMED;
      else
	frag_wane (this_frag);
    }
  else
    {
      local_opt_diff = get_aligned_diff (fragP, address, &max_diff);
      opt_diff = local_opt_diff;
      gas_assert (opt_diff >= 0);
      gas_assert (max_diff >= opt_diff);
      if (max_diff == 0)
	return 0;

      if (fragP)
	fragP = fragP->fr_next;

      while (fragP && opt_diff < max_diff && address)
	{
	  /* We only use these to determine if we can exit early
	     because there will be plenty of ways to align future
	     align frags.  */
	  int glob_widens = 0;
	  int dnn = 0;
	  int dw = 0;
	  bfd_boolean glob_pad = 0;
	  address = find_address_of_next_align_frag
	    (&fragP, &glob_widens, &dnn, &dw, &glob_pad);
	  /* If there is a padable portion, then skip.  */
	  if (glob_pad || glob_widens >= (1 << branch_align_power (now_seg)))
	    address = 0;

	  if (address)
	    {
	      offsetT next_m_diff;
	      offsetT next_o_diff;

	      /* Downrange frags haven't had stretch added to them yet.  */
	      address += stretch;

	      /* The address also includes any text expansion from this
		 frag in a previous pass, but we don't want that.  */
	      address -= this_frag->tc_frag_data.text_expansion[0];

	      /* Assume we are going to move at least opt_diff.  In
		 reality, we might not be able to, but assuming that
		 we will helps catch cases where moving opt_diff pushes
		 the next target from aligned to unaligned.  */
	      address += opt_diff;

	      next_o_diff = get_aligned_diff (fragP, address, &next_m_diff);

	      /* Now cleanup for the adjustments to address.  */
	      next_o_diff += opt_diff;
	      next_m_diff += opt_diff;
	      if (next_o_diff <= max_diff && next_o_diff > opt_diff)
		opt_diff = next_o_diff;
	      if (next_m_diff < max_diff)
		max_diff = next_m_diff;
	      fragP = fragP->fr_next;
	    }
	}

      /* If there are enough wideners in between, do it.  */
      if (paddable)
	{
	  if (this_frag->fr_subtype == RELAX_UNREACHABLE)
	    {
	      gas_assert (opt_diff <= (signed) xtensa_fetch_width);
	      return opt_diff;
	    }
	  return 0;
	}
      local_stretch_amount
	= bytes_to_stretch (this_frag, wide_nops, narrow_nops,
			    num_widens, local_opt_diff);
      global_stretch_amount
	= bytes_to_stretch (this_frag, wide_nops, narrow_nops,
			    num_widens, opt_diff);
      /* If the condition below is true, then the frag couldn't
	 stretch the correct amount for the global case, so we just
	 optimize locally.  We'll rely on the subsequent frags to get
	 the correct alignment in the global case.  */
      if (global_stretch_amount < local_stretch_amount)
	stretch_amount = local_stretch_amount;
      else
	stretch_amount = global_stretch_amount;

      if (this_frag->fr_subtype == RELAX_SLOTS
	  && this_frag->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
	gas_assert (stretch_amount <= 1);
      else if (this_frag->fr_subtype == RELAX_FILL_NOP)
	{
	  if (this_frag->tc_frag_data.is_no_density)
	    gas_assert (stretch_amount == 3 || stretch_amount == 0);
	  else
	    gas_assert (stretch_amount <= 3);
	}
    }
  return stretch_amount;
}


/* The idea: widen everything you can to get a target or loop aligned,
   then start using NOPs.

   wide_nops   = the number of wide NOPs available for aligning
   narrow_nops = the number of narrow NOPs available for aligning
		 (a subset of wide_nops)
   widens      = the number of narrow instructions that should be widened

*/

static long
bytes_to_stretch (fragS *this_frag,
		  int wide_nops,
		  int narrow_nops,
		  int num_widens,
		  int desired_diff)
{
  int nops_needed;
  int nop_bytes;
  int extra_bytes;
  int bytes_short = desired_diff - num_widens;

  gas_assert (desired_diff >= 0 
	      && desired_diff < (signed) xtensa_fetch_width);
  if (desired_diff == 0)
    return 0;

  gas_assert (wide_nops > 0 || num_widens > 0);

  /* Always prefer widening to NOP-filling.  */
  if (bytes_short < 0)
    {
      /* There are enough RELAX_NARROW frags after this one
	 to align the target without widening this frag in any way.  */
      return 0;
    }

  if (bytes_short == 0)
    {
      /* Widen every narrow between here and the align target
	 and the align target will be properly aligned.  */
      if (this_frag->fr_subtype == RELAX_FILL_NOP)
	return 0;
      else
	return 1;
    }

  /* From here we will need at least one NOP to get an alignment.
     However, we may not be able to align at all, in which case,
     don't widen.  */
  nops_needed = desired_diff / 3;

  /* If there aren't enough nops, don't widen.  */
  if (nops_needed > wide_nops)
    return 0;

  /* First try it with all wide nops.  */
  nop_bytes = nops_needed * 3;
  extra_bytes = desired_diff - nop_bytes;

  if (nop_bytes + num_widens >= desired_diff)
    {
      if (this_frag->fr_subtype == RELAX_FILL_NOP)
	return 3;
      else if (num_widens == extra_bytes)
	return 1;
      return 0;
    }

  /* Add a narrow nop.  */
  nops_needed++;
  nop_bytes += 2;
  extra_bytes -= 2;
  if (narrow_nops == 0 || nops_needed > wide_nops)
    return 0;

  if (nop_bytes + num_widens >= desired_diff && extra_bytes >= 0)
    {
      if (this_frag->fr_subtype == RELAX_FILL_NOP)
	return !this_frag->tc_frag_data.is_no_density ? 2 : 3;
      else if (num_widens == extra_bytes)
	return 1;
      return 0;
    }

  /* Replace a wide nop with a narrow nop--we can get here if
     extra_bytes was negative in the previous conditional.  */
  if (narrow_nops == 1)
    return 0;
  nop_bytes--;
  extra_bytes++;
  if (nop_bytes + num_widens >= desired_diff)
    {
      if (this_frag->fr_subtype == RELAX_FILL_NOP)
	return !this_frag->tc_frag_data.is_no_density ? 2 : 3;
      else if (num_widens == extra_bytes)
	return 1;
      return 0;
    }

  /* If we can't satisfy any of the above cases, then we can't align
     using padding or fill nops.  */
  return 0;
}


static long
relax_frag_immed (segT segP,
		  fragS *fragP,
		  long stretch,
		  int min_steps,
		  xtensa_format fmt,
		  int slot,
		  int *stretched_p,
		  bfd_boolean estimate_only)
{
  TInsn tinsn;
  int old_size;
  bfd_boolean negatable_branch = FALSE;
  bfd_boolean branch_jmp_to_next = FALSE;
  bfd_boolean from_wide_insn = FALSE;
  xtensa_isa isa = xtensa_default_isa;
  IStack istack;
  offsetT frag_offset;
  int num_steps;
  int num_text_bytes, num_literal_bytes;
  int literal_diff, total_text_diff, this_text_diff;

  gas_assert (fragP->fr_opcode != NULL);

  xg_clear_vinsn (&cur_vinsn);
  vinsn_from_chars (&cur_vinsn, fragP->fr_opcode);
  if (cur_vinsn.num_slots > 1)
    from_wide_insn = TRUE;

  tinsn = cur_vinsn.slots[slot];
  tinsn_immed_from_frag (&tinsn, fragP, slot);

  if (estimate_only && xtensa_opcode_is_loop (isa, tinsn.opcode) == 1)
    return 0;

  if (workaround_b_j_loop_end && ! fragP->tc_frag_data.is_no_transform)
    branch_jmp_to_next = is_branch_jmp_to_next (&tinsn, fragP);

  negatable_branch = (xtensa_opcode_is_branch (isa, tinsn.opcode) == 1);

  old_size = xtensa_format_length (isa, fmt);

  /* Special case: replace a branch to the next instruction with a NOP.
     This is required to work around a hardware bug in T1040.0 and also
     serves as an optimization.  */

  if (branch_jmp_to_next
      && ((old_size == 2) || (old_size == 3))
      && !next_frag_is_loop_target (fragP))
    return 0;

  /* Here is the fun stuff: Get the immediate field from this
     instruction.  If it fits, we are done.  If not, find the next
     instruction sequence that fits.  */

  frag_offset = fragP->fr_opcode - fragP->fr_literal;
  istack_init (&istack);
  num_steps = xg_assembly_relax (&istack, &tinsn, segP, fragP, frag_offset,
				 min_steps, stretch);
  gas_assert (num_steps >= min_steps && num_steps <= RELAX_IMMED_MAXSTEPS);

  fragP->tc_frag_data.slot_subtypes[slot] = (int) RELAX_IMMED + num_steps;

  /* Figure out the number of bytes needed.  */
  num_literal_bytes = get_num_stack_literal_bytes (&istack);
  literal_diff
    = num_literal_bytes - fragP->tc_frag_data.literal_expansion[slot];
  num_text_bytes = get_num_stack_text_bytes (&istack);

  if (from_wide_insn)
    {
      int first = 0;
      while (istack.insn[first].opcode == XTENSA_UNDEFINED)
	first++;

      num_text_bytes += old_size;
      if (opcode_fits_format_slot (istack.insn[first].opcode, fmt, slot))
	num_text_bytes -= xg_get_single_size (istack.insn[first].opcode);
      else
	{
	  /* The first instruction in the relaxed sequence will go after
	     the current wide instruction, and thus its symbolic immediates
	     might not fit.  */
	  
	  istack_init (&istack);
	  num_steps = xg_assembly_relax (&istack, &tinsn, segP, fragP, 
					 frag_offset + old_size,
					 min_steps, stretch + old_size);
	  gas_assert (num_steps >= min_steps && num_steps <= RELAX_IMMED_MAXSTEPS);

	  fragP->tc_frag_data.slot_subtypes[slot] 
	    = (int) RELAX_IMMED + num_steps;

	  num_literal_bytes = get_num_stack_literal_bytes (&istack);
	  literal_diff 
	    = num_literal_bytes - fragP->tc_frag_data.literal_expansion[slot];
	  
	  num_text_bytes = get_num_stack_text_bytes (&istack) + old_size;
	}
    }

  total_text_diff = num_text_bytes - old_size;
  this_text_diff = total_text_diff - fragP->tc_frag_data.text_expansion[slot];

  /* It MUST get larger.  If not, we could get an infinite loop.  */
  gas_assert (num_text_bytes >= 0);
  gas_assert (literal_diff >= 0);
  gas_assert (total_text_diff >= 0);

  fragP->tc_frag_data.text_expansion[slot] = total_text_diff;
  fragP->tc_frag_data.literal_expansion[slot] = num_literal_bytes;
  gas_assert (fragP->tc_frag_data.text_expansion[slot] >= 0);
  gas_assert (fragP->tc_frag_data.literal_expansion[slot] >= 0);

  /* Find the associated expandable literal for this.  */
  if (literal_diff != 0)
    {
      fragS *lit_fragP = fragP->tc_frag_data.literal_frags[slot];
      if (lit_fragP)
	{
	  gas_assert (literal_diff == 4);
	  lit_fragP->tc_frag_data.unreported_expansion += literal_diff;

	  /* We expect that the literal section state has NOT been
	     modified yet.  */
	  gas_assert (lit_fragP->fr_type == rs_machine_dependent
		  && lit_fragP->fr_subtype == RELAX_LITERAL);
	  lit_fragP->fr_subtype = RELAX_LITERAL_NR;

	  /* We need to mark this section for another iteration
	     of relaxation.  */
	  (*stretched_p)++;
	}
    }

  if (negatable_branch && istack.ninsn > 1)
    update_next_frag_state (fragP);

  return this_text_diff;
}


/* md_convert_frag Hook and Helper Functions.  */

static void convert_frag_align_next_opcode (fragS *);
static void convert_frag_narrow (segT, fragS *, xtensa_format, int);
static void convert_frag_fill_nop (fragS *);
static void convert_frag_immed (segT, fragS *, int, xtensa_format, int);

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec, fragS *fragp)
{
  static xtensa_insnbuf vbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  int slot;
  int num_slots;
  xtensa_format fmt;
  char *file_name;
  unsigned line;

  as_where (&file_name, &line);
  new_logical_line (fragp->fr_file, fragp->fr_line);

  switch (fragp->fr_subtype)
    {
    case RELAX_ALIGN_NEXT_OPCODE:
      /* Always convert.  */
      convert_frag_align_next_opcode (fragp);
      break;

    case RELAX_DESIRE_ALIGN:
      /* Do nothing.  If not aligned already, too bad.  */
      break;

    case RELAX_LITERAL:
    case RELAX_LITERAL_FINAL:
      break;

    case RELAX_SLOTS:
      if (vbuf == NULL)
	vbuf = xtensa_insnbuf_alloc (isa);

      xtensa_insnbuf_from_chars
	(isa, vbuf, (unsigned char *) fragp->fr_opcode, 0);
      fmt = xtensa_format_decode (isa, vbuf);
      num_slots = xtensa_format_num_slots (isa, fmt);

      for (slot = 0; slot < num_slots; slot++)
	{
	  switch (fragp->tc_frag_data.slot_subtypes[slot])
	    {
	    case RELAX_NARROW:
	      convert_frag_narrow (sec, fragp, fmt, slot);
	      break;

	    case RELAX_IMMED:
	    case RELAX_IMMED_STEP1:
	    case RELAX_IMMED_STEP2:
	    case RELAX_IMMED_STEP3:
	      /* Place the immediate.  */
	      convert_frag_immed
		(sec, fragp,
		 fragp->tc_frag_data.slot_subtypes[slot] - RELAX_IMMED,
		 fmt, slot);
	      break;

	    default:
	      /* This is OK because some slots could have
		 relaxations and others have none.  */
	      break;
	    }
	}
      break;

    case RELAX_UNREACHABLE:
      memset (&fragp->fr_literal[fragp->fr_fix], 0, fragp->fr_var);
      fragp->fr_fix += fragp->tc_frag_data.text_expansion[0];
      fragp->fr_var -= fragp->tc_frag_data.text_expansion[0];
      frag_wane (fragp);
      break;

    case RELAX_MAYBE_UNREACHABLE:
    case RELAX_MAYBE_DESIRE_ALIGN:
      frag_wane (fragp);
      break;

    case RELAX_FILL_NOP:
      convert_frag_fill_nop (fragp);
      break;

    case RELAX_LITERAL_NR:
      if (use_literal_section)
	{
	  /* This should have been handled during relaxation.  When
	     relaxing a code segment, literals sometimes need to be
	     added to the corresponding literal segment.  If that
	     literal segment has already been relaxed, then we end up
	     in this situation.  Marking the literal segments as data
	     would make this happen less often (since GAS always relaxes
	     code before data), but we could still get into trouble if
	     there are instructions in a segment that is not marked as
	     containing code.  Until we can implement a better solution,
	     cheat and adjust the addresses of all the following frags.
	     This could break subsequent alignments, but the linker's
	     literal coalescing will do that anyway.  */

	  fragS *f;
	  fragp->fr_subtype = RELAX_LITERAL_FINAL;
	  gas_assert (fragp->tc_frag_data.unreported_expansion == 4);
	  memset (&fragp->fr_literal[fragp->fr_fix], 0, 4);
	  fragp->fr_var -= 4;
	  fragp->fr_fix += 4;
	  for (f = fragp->fr_next; f; f = f->fr_next)
	    f->fr_address += 4;
	}
      else
	as_bad (_("invalid relaxation fragment result"));
      break;
    }

  fragp->fr_var = 0;
  new_logical_line (file_name, line);
}


static void
convert_frag_align_next_opcode (fragS *fragp)
{
  char *nop_buf;		/* Location for Writing.  */
  bfd_boolean use_no_density = fragp->tc_frag_data.is_no_density;
  addressT aligned_address;
  offsetT fill_size;
  int nop, nop_count;

  aligned_address = get_noop_aligned_address (fragp, fragp->fr_address +
					      fragp->fr_fix);
  fill_size = aligned_address - (fragp->fr_address + fragp->fr_fix);
  nop_count = get_text_align_nop_count (fill_size, use_no_density);
  nop_buf = fragp->fr_literal + fragp->fr_fix;

  for (nop = 0; nop < nop_count; nop++)
    {
      int nop_size;
      nop_size = get_text_align_nth_nop_size (fill_size, nop, use_no_density);

      assemble_nop (nop_size, nop_buf);
      nop_buf += nop_size;
    }

  fragp->fr_fix += fill_size;
  fragp->fr_var -= fill_size;
}


static void
convert_frag_narrow (segT segP, fragS *fragP, xtensa_format fmt, int slot)
{
  TInsn tinsn, single_target;
  int size, old_size, diff;
  offsetT frag_offset;

  gas_assert (slot == 0);
  tinsn_from_chars (&tinsn, fragP->fr_opcode, 0);

  if (fragP->tc_frag_data.is_aligning_branch == 1)
    {
      gas_assert (fragP->tc_frag_data.text_expansion[0] == 1
	      || fragP->tc_frag_data.text_expansion[0] == 0);
      convert_frag_immed (segP, fragP, fragP->tc_frag_data.text_expansion[0],
			  fmt, slot);
      return;
    }

  if (fragP->tc_frag_data.text_expansion[0] == 0)
    {
      /* No conversion.  */
      fragP->fr_var = 0;
      return;
    }

  gas_assert (fragP->fr_opcode != NULL);

  /* Frags in this relaxation state should only contain
     single instruction bundles.  */
  tinsn_immed_from_frag (&tinsn, fragP, 0);

  /* Just convert it to a wide form....  */
  size = 0;
  old_size = xg_get_single_size (tinsn.opcode);

  tinsn_init (&single_target);
  frag_offset = fragP->fr_opcode - fragP->fr_literal;

  if (! xg_is_single_relaxable_insn (&tinsn, &single_target, FALSE))
    {
      as_bad (_("unable to widen instruction"));
      return;
    }

  size = xg_get_single_size (single_target.opcode);
  xg_emit_insn_to_buf (&single_target, fragP->fr_opcode, fragP,
		       frag_offset, TRUE);

  diff = size - old_size;
  gas_assert (diff >= 0);
  gas_assert (diff <= fragP->fr_var);
  fragP->fr_var -= diff;
  fragP->fr_fix += diff;

  /* clean it up */
  fragP->fr_var = 0;
}


static void
convert_frag_fill_nop (fragS *fragP)
{
  char *loc = &fragP->fr_literal[fragP->fr_fix];
  int size = fragP->tc_frag_data.text_expansion[0];
  gas_assert ((unsigned) size == (fragP->fr_next->fr_address
			      - fragP->fr_address - fragP->fr_fix));
  if (size == 0)
    {
      /* No conversion.  */
      fragP->fr_var = 0;
      return;
    }
  assemble_nop (size, loc);
  fragP->tc_frag_data.is_insn = TRUE;
  fragP->fr_var -= size;
  fragP->fr_fix += size;
  frag_wane (fragP);
}


static fixS *fix_new_exp_in_seg
  (segT, subsegT, fragS *, int, int, expressionS *, int,
   bfd_reloc_code_real_type);
static void convert_frag_immed_finish_loop (segT, fragS *, TInsn *);

static void
convert_frag_immed (segT segP,
		    fragS *fragP,
		    int min_steps,
		    xtensa_format fmt,
		    int slot)
{
  char *immed_instr = fragP->fr_opcode;
  TInsn orig_tinsn;
  bfd_boolean expanded = FALSE;
  bfd_boolean branch_jmp_to_next = FALSE;
  char *fr_opcode = fragP->fr_opcode;
  xtensa_isa isa = xtensa_default_isa;
  bfd_boolean from_wide_insn = FALSE;
  int bytes;
  bfd_boolean is_loop;

  gas_assert (fr_opcode != NULL);

  xg_clear_vinsn (&cur_vinsn);

  vinsn_from_chars (&cur_vinsn, fr_opcode);
  if (cur_vinsn.num_slots > 1)
    from_wide_insn = TRUE;

  orig_tinsn = cur_vinsn.slots[slot];
  tinsn_immed_from_frag (&orig_tinsn, fragP, slot);

  is_loop = xtensa_opcode_is_loop (xtensa_default_isa, orig_tinsn.opcode) == 1;

  if (workaround_b_j_loop_end && ! fragP->tc_frag_data.is_no_transform)
    branch_jmp_to_next = is_branch_jmp_to_next (&orig_tinsn, fragP);

  if (branch_jmp_to_next && !next_frag_is_loop_target (fragP))
    {
      /* Conversion just inserts a NOP and marks the fix as completed.  */
      bytes = xtensa_format_length (isa, fmt);
      if (bytes >= 4)
	{
	  cur_vinsn.slots[slot].opcode =
	    xtensa_format_slot_nop_opcode (isa, cur_vinsn.format, slot);
	  cur_vinsn.slots[slot].ntok = 0;
	}
      else
	{
	  bytes += fragP->tc_frag_data.text_expansion[0];
	  gas_assert (bytes == 2 || bytes == 3);
	  build_nop (&cur_vinsn.slots[0], bytes);
	  fragP->fr_fix += fragP->tc_frag_data.text_expansion[0];
	}
      vinsn_to_insnbuf (&cur_vinsn, fr_opcode, frag_now, TRUE);
      xtensa_insnbuf_to_chars
	(isa, cur_vinsn.insnbuf, (unsigned char *) fr_opcode, 0);
      fragP->fr_var = 0;
    }
  else
    {
      /* Here is the fun stuff:  Get the immediate field from this
	 instruction.  If it fits, we're done.  If not, find the next
	 instruction sequence that fits.  */

      IStack istack;
      int i;
      symbolS *lit_sym = NULL;
      int total_size = 0;
      int target_offset = 0;
      int old_size;
      int diff;
      symbolS *gen_label = NULL;
      offsetT frag_offset;
      bfd_boolean first = TRUE;

      /* It does not fit.  Find something that does and
         convert immediately.  */
      frag_offset = fr_opcode - fragP->fr_literal;
      istack_init (&istack);
      xg_assembly_relax (&istack, &orig_tinsn,
			 segP, fragP, frag_offset, min_steps, 0);

      old_size = xtensa_format_length (isa, fmt);

      /* Assemble this right inline.  */

      /* First, create the mapping from a label name to the REAL label.  */
      target_offset = 0;
      for (i = 0; i < istack.ninsn; i++)
	{
	  TInsn *tinsn = &istack.insn[i];
	  fragS *lit_frag;

	  switch (tinsn->insn_type)
	    {
	    case ITYPE_LITERAL:
	      if (lit_sym != NULL)
		as_bad (_("multiple literals in expansion"));
	      /* First find the appropriate space in the literal pool.  */
	      lit_frag = fragP->tc_frag_data.literal_frags[slot];
	      if (lit_frag == NULL)
		as_bad (_("no registered fragment for literal"));
	      if (tinsn->ntok != 1)
		as_bad (_("number of literal tokens != 1"));

	      /* Set the literal symbol and add a fixup.  */
	      lit_sym = lit_frag->fr_symbol;
	      break;

	    case ITYPE_LABEL:
	      if (align_targets && !is_loop)
		{
		  fragS *unreach = fragP->fr_next;
		  while (!(unreach->fr_type == rs_machine_dependent
			   && (unreach->fr_subtype == RELAX_MAYBE_UNREACHABLE
			       || unreach->fr_subtype == RELAX_UNREACHABLE)))
		    {
		      unreach = unreach->fr_next;
		    }

		  gas_assert (unreach->fr_type == rs_machine_dependent
			  && (unreach->fr_subtype == RELAX_MAYBE_UNREACHABLE
			      || unreach->fr_subtype == RELAX_UNREACHABLE));

		  target_offset += unreach->tc_frag_data.text_expansion[0];
		}
	      gas_assert (gen_label == NULL);
	      gen_label = symbol_new (FAKE_LABEL_NAME, now_seg,
				      fr_opcode - fragP->fr_literal
				      + target_offset, fragP);
	      break;

	    case ITYPE_INSN:
	      if (first && from_wide_insn)
		{
		  target_offset += xtensa_format_length (isa, fmt);
		  first = FALSE;
		  if (!opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    target_offset += xg_get_single_size (tinsn->opcode);
		}
	      else
		target_offset += xg_get_single_size (tinsn->opcode);
	      break;
	    }
	}

      total_size = 0;
      first = TRUE;
      for (i = 0; i < istack.ninsn; i++)
	{
	  TInsn *tinsn = &istack.insn[i];
	  fragS *lit_frag;
	  int size;
	  segT target_seg;
	  bfd_reloc_code_real_type reloc_type;

	  switch (tinsn->insn_type)
	    {
	    case ITYPE_LITERAL:
	      lit_frag = fragP->tc_frag_data.literal_frags[slot];
	      /* Already checked.  */
	      gas_assert (lit_frag != NULL);
	      gas_assert (lit_sym != NULL);
	      gas_assert (tinsn->ntok == 1);
	      /* Add a fixup.  */
	      target_seg = S_GET_SEGMENT (lit_sym);
	      gas_assert (target_seg);
	      reloc_type = map_operator_to_reloc (tinsn->tok[0].X_op, TRUE);
	      fix_new_exp_in_seg (target_seg, 0, lit_frag, 0, 4,
				  &tinsn->tok[0], FALSE, reloc_type);
	      break;

	    case ITYPE_LABEL:
	      break;

	    case ITYPE_INSN:
	      xg_resolve_labels (tinsn, gen_label);
	      xg_resolve_literals (tinsn, lit_sym);
	      if (from_wide_insn && first)
		{
		  first = FALSE;
		  if (opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    {
		      cur_vinsn.slots[slot] = *tinsn;
		    }
		  else
		    {
		      cur_vinsn.slots[slot].opcode =
			xtensa_format_slot_nop_opcode (isa, fmt, slot);
		      cur_vinsn.slots[slot].ntok = 0;
		    }
		  vinsn_to_insnbuf (&cur_vinsn, immed_instr, fragP, TRUE);
		  xtensa_insnbuf_to_chars (isa, cur_vinsn.insnbuf,
					   (unsigned char *) immed_instr, 0);
		  fragP->tc_frag_data.is_insn = TRUE;
		  size = xtensa_format_length (isa, fmt);
		  if (!opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    {
		      xg_emit_insn_to_buf
			(tinsn, immed_instr + size, fragP,
			 immed_instr - fragP->fr_literal + size, TRUE);
		      size += xg_get_single_size (tinsn->opcode);
		    }
		}
	      else
		{
		  size = xg_get_single_size (tinsn->opcode);
		  xg_emit_insn_to_buf (tinsn, immed_instr, fragP,
				       immed_instr - fragP->fr_literal, TRUE);
		}
	      immed_instr += size;
	      total_size += size;
	      break;
	    }
	}

      diff = total_size - old_size;
      gas_assert (diff >= 0);
      if (diff != 0)
	expanded = TRUE;
      gas_assert (diff <= fragP->fr_var);
      fragP->fr_var -= diff;
      fragP->fr_fix += diff;
    }

  /* Check for undefined immediates in LOOP instructions.  */
  if (is_loop)
    {
      symbolS *sym;
      sym = orig_tinsn.tok[1].X_add_symbol;
      if (sym != NULL && !S_IS_DEFINED (sym))
	{
	  as_bad (_("unresolved loop target symbol: %s"), S_GET_NAME (sym));
	  return;
	}
      sym = orig_tinsn.tok[1].X_op_symbol;
      if (sym != NULL && !S_IS_DEFINED (sym))
	{
	  as_bad (_("unresolved loop target symbol: %s"), S_GET_NAME (sym));
	  return;
	}
    }

  if (expanded && xtensa_opcode_is_loop (isa, orig_tinsn.opcode) == 1)
    convert_frag_immed_finish_loop (segP, fragP, &orig_tinsn);

  if (expanded && is_direct_call_opcode (orig_tinsn.opcode))
    {
      /* Add an expansion note on the expanded instruction.  */
      fix_new_exp_in_seg (now_seg, 0, fragP, fr_opcode - fragP->fr_literal, 4,
			  &orig_tinsn.tok[0], TRUE,
			  BFD_RELOC_XTENSA_ASM_EXPAND);
    }
}


/* Add a new fix expression into the desired segment.  We have to
   switch to that segment to do this.  */

static fixS *
fix_new_exp_in_seg (segT new_seg,
		    subsegT new_subseg,
		    fragS *frag,
		    int where,
		    int size,
		    expressionS *exp,
		    int pcrel,
		    bfd_reloc_code_real_type r_type)
{
  fixS *new_fix;
  segT seg = now_seg;
  subsegT subseg = now_subseg;

  gas_assert (new_seg != 0);
  subseg_set (new_seg, new_subseg);

  new_fix = fix_new_exp (frag, where, size, exp, pcrel, r_type);
  subseg_set (seg, subseg);
  return new_fix;
}


/* Relax a loop instruction so that it can span loop >256 bytes.

                  loop    as, .L1
          .L0:
                  rsr     as, LEND
                  wsr     as, LBEG
                  addi    as, as, lo8 (label-.L1)
                  addmi   as, as, mid8 (label-.L1)
                  wsr     as, LEND
                  isync
                  rsr     as, LCOUNT
                  addi    as, as, 1
          .L1:
                  <<body>>
          label:
*/

static void
convert_frag_immed_finish_loop (segT segP, fragS *fragP, TInsn *tinsn)
{
  TInsn loop_insn;
  TInsn addi_insn;
  TInsn addmi_insn;
  unsigned long target;
  static xtensa_insnbuf insnbuf = NULL;
  unsigned int loop_length, loop_length_hi, loop_length_lo;
  xtensa_isa isa = xtensa_default_isa;
  addressT loop_offset;
  addressT addi_offset = 9;
  addressT addmi_offset = 12;
  fragS *next_fragP;
  int target_count;

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  /* Get the loop offset.  */
  loop_offset = get_expanded_loop_offset (tinsn->opcode);

  /* Validate that there really is a LOOP at the loop_offset.  Because
     loops are not bundleable, we can assume that the instruction will be
     in slot 0.  */
  tinsn_from_chars (&loop_insn, fragP->fr_opcode + loop_offset, 0);
  tinsn_immed_from_frag (&loop_insn, fragP, 0);

  gas_assert (xtensa_opcode_is_loop (isa, loop_insn.opcode) == 1);
  addi_offset += loop_offset;
  addmi_offset += loop_offset;

  gas_assert (tinsn->ntok == 2);
  if (tinsn->tok[1].X_op == O_constant)
    target = tinsn->tok[1].X_add_number;
  else if (tinsn->tok[1].X_op == O_symbol)
    {
      /* Find the fragment.  */
      symbolS *sym = tinsn->tok[1].X_add_symbol;
      gas_assert (S_GET_SEGMENT (sym) == segP
	      || S_GET_SEGMENT (sym) == absolute_section);
      target = (S_GET_VALUE (sym) + tinsn->tok[1].X_add_number);
    }
  else
    {
      as_bad (_("invalid expression evaluation type %d"), tinsn->tok[1].X_op);
      target = 0;
    }

  loop_length = target - (fragP->fr_address + fragP->fr_fix);
  loop_length_hi = loop_length & ~0x0ff;
  loop_length_lo = loop_length & 0x0ff;
  if (loop_length_lo >= 128)
    {
      loop_length_lo -= 256;
      loop_length_hi += 256;
    }

  /* Because addmi sign-extends the immediate, 'loop_length_hi' can be at most
     32512.  If the loop is larger than that, then we just fail.  */
  if (loop_length_hi > 32512)
    as_bad_where (fragP->fr_file, fragP->fr_line,
		  _("loop too long for LOOP instruction"));

  tinsn_from_chars (&addi_insn, fragP->fr_opcode + addi_offset, 0);
  gas_assert (addi_insn.opcode == xtensa_addi_opcode);

  tinsn_from_chars (&addmi_insn, fragP->fr_opcode + addmi_offset, 0);
  gas_assert (addmi_insn.opcode == xtensa_addmi_opcode);

  set_expr_const (&addi_insn.tok[2], loop_length_lo);
  tinsn_to_insnbuf (&addi_insn, insnbuf);

  fragP->tc_frag_data.is_insn = TRUE;
  xtensa_insnbuf_to_chars
    (isa, insnbuf, (unsigned char *) fragP->fr_opcode + addi_offset, 0);

  set_expr_const (&addmi_insn.tok[2], loop_length_hi);
  tinsn_to_insnbuf (&addmi_insn, insnbuf);
  xtensa_insnbuf_to_chars
    (isa, insnbuf, (unsigned char *) fragP->fr_opcode + addmi_offset, 0);

  /* Walk through all of the frags from here to the loop end
     and mark them as no_transform to keep them from being modified
     by the linker.  If we ever have a relocation for the
     addi/addmi of the difference of two symbols we can remove this.  */

  target_count = 0;
  for (next_fragP = fragP; next_fragP != NULL;
       next_fragP = next_fragP->fr_next)
    {
      next_fragP->tc_frag_data.is_no_transform = TRUE;
      if (next_fragP->tc_frag_data.is_loop_target)
	target_count++;
      if (target_count == 2)
	break;
    }
}


/* A map that keeps information on a per-subsegment basis.  This is
   maintained during initial assembly, but is invalid once the
   subsegments are smashed together.  I.E., it cannot be used during
   the relaxation.  */

typedef struct subseg_map_struct
{
  /* the key */
  segT seg;
  subsegT subseg;

  /* the data */
  unsigned flags;
  float total_freq;	/* fall-through + branch target frequency */
  float target_freq;	/* branch target frequency alone */

  struct subseg_map_struct *next;
} subseg_map;


static subseg_map *sseg_map = NULL;

static subseg_map *
get_subseg_info (segT seg, subsegT subseg)
{
  subseg_map *subseg_e;

  for (subseg_e = sseg_map; subseg_e; subseg_e = subseg_e->next)
    {
      if (seg == subseg_e->seg && subseg == subseg_e->subseg)
	break;
    }
  return subseg_e;
}


static subseg_map *
add_subseg_info (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = (subseg_map *) xmalloc (sizeof (subseg_map));
  memset (subseg_e, 0, sizeof (subseg_map));
  subseg_e->seg = seg;
  subseg_e->subseg = subseg;
  subseg_e->flags = 0;
  /* Start off considering every branch target very important.  */
  subseg_e->target_freq = 1.0;
  subseg_e->total_freq = 1.0;
  subseg_e->next = sseg_map;
  sseg_map = subseg_e;
  return subseg_e;
}


static unsigned
get_last_insn_flags (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->flags;
  return 0;
}


static void
set_last_insn_flags (segT seg,
		     subsegT subseg,
		     unsigned fl,
		     bfd_boolean val)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (! subseg_e)
    subseg_e = add_subseg_info (seg, subseg);
  if (val)
    subseg_e->flags |= fl;
  else
    subseg_e->flags &= ~fl;
}


static float
get_subseg_total_freq (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->total_freq;
  return 1.0;
}


static float
get_subseg_target_freq (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->target_freq;
  return 1.0;
}


static void
set_subseg_freq (segT seg, subsegT subseg, float total_f, float target_f)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (! subseg_e)
    subseg_e = add_subseg_info (seg, subseg);
  subseg_e->total_freq = total_f;
  subseg_e->target_freq = target_f;
}


/* Segment Lists and emit_state Stuff.  */

static void
xtensa_move_seg_list_to_beginning (seg_list *head)
{
  head = head->next;
  while (head)
    {
      segT literal_section = head->seg;

      /* Move the literal section to the front of the section list.  */
      gas_assert (literal_section);
      if (literal_section != stdoutput->sections)
	{
	  bfd_section_list_remove (stdoutput, literal_section);
	  bfd_section_list_prepend (stdoutput, literal_section);
	}
      head = head->next;
    }
}


static void mark_literal_frags (seg_list *);

static void
xtensa_move_literals (void)
{
  seg_list *segment;
  frchainS *frchain_from, *frchain_to;
  fragS *search_frag, *next_frag, *literal_pool, *insert_after;
  fragS **frag_splice;
  emit_state state;
  segT dest_seg;
  fixS *fix, *next_fix, **fix_splice;
  sym_list *lit;

  mark_literal_frags (literal_head->next);

  if (use_literal_section)
    return;

  for (segment = literal_head->next; segment; segment = segment->next)
    {
      /* Keep the literals for .init and .fini in separate sections.  */
      if (!strcmp (segment_name (segment->seg), INIT_SECTION_NAME)
	  || !strcmp (segment_name (segment->seg), FINI_SECTION_NAME))
	continue;

      frchain_from = seg_info (segment->seg)->frchainP;
      search_frag = frchain_from->frch_root;
      literal_pool = NULL;
      frchain_to = NULL;
      frag_splice = &(frchain_from->frch_root);

      while (!search_frag->tc_frag_data.literal_frag)
	{
	  gas_assert (search_frag->fr_fix == 0
		  || search_frag->fr_type == rs_align);
	  search_frag = search_frag->fr_next;
	}

      gas_assert (search_frag->tc_frag_data.literal_frag->fr_subtype
	      == RELAX_LITERAL_POOL_BEGIN);
      xtensa_switch_section_emit_state (&state, segment->seg, 0);

      /* Make sure that all the frags in this series are closed, and
	 that there is at least one left over of zero-size.  This
	 prevents us from making a segment with an frchain without any
	 frags in it.  */
      frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
      frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);

      while (search_frag != frag_now)
	{
	  next_frag = search_frag->fr_next;

	  /* First, move the frag out of the literal section and
	     to the appropriate place.  */
	  if (search_frag->tc_frag_data.literal_frag)
	    {
	      literal_pool = search_frag->tc_frag_data.literal_frag;
	      gas_assert (literal_pool->fr_subtype == RELAX_LITERAL_POOL_BEGIN);
	      frchain_to = literal_pool->tc_frag_data.lit_frchain;
	      gas_assert (frchain_to);
	    }
	  insert_after = literal_pool->tc_frag_data.literal_frag;
	  dest_seg = insert_after->fr_next->tc_frag_data.lit_seg;

	  *frag_splice = next_frag;
	  search_frag->fr_next = insert_after->fr_next;
	  insert_after->fr_next = search_frag;
	  search_frag->tc_frag_data.lit_seg = dest_seg;
	  literal_pool->tc_frag_data.literal_frag = search_frag;

	  /* Now move any fixups associated with this frag to the
	     right section.  */
	  fix = frchain_from->fix_root;
	  fix_splice = &(frchain_from->fix_root);
	  while (fix)
	    {
	      next_fix = fix->fx_next;
	      if (fix->fx_frag == search_frag)
		{
		  *fix_splice = next_fix;
		  fix->fx_next = frchain_to->fix_root;
		  frchain_to->fix_root = fix;
		  if (frchain_to->fix_tail == NULL)
		    frchain_to->fix_tail = fix;
		}
	      else
		fix_splice = &(fix->fx_next);
	      fix = next_fix;
	    }
	  search_frag = next_frag;
	}

      if (frchain_from->fix_root != NULL)
	{
	  frchain_from = seg_info (segment->seg)->frchainP;
	  as_warn (_("fixes not all moved from %s"), segment->seg->name);

	  gas_assert (frchain_from->fix_root == NULL);
	}
      frchain_from->fix_tail = NULL;
      xtensa_restore_emit_state (&state);
    }

  /* Now fix up the SEGMENT value for all the literal symbols.  */
  for (lit = literal_syms; lit; lit = lit->next)
    {
      symbolS *lit_sym = lit->sym;
      segT dseg = symbol_get_frag (lit_sym)->tc_frag_data.lit_seg;
      if (dseg)
	S_SET_SEGMENT (lit_sym, dseg);
    }
}


/* Walk over all the frags for segments in a list and mark them as
   containing literals.  As clunky as this is, we can't rely on frag_var
   and frag_variant to get called in all situations.  */

static void
mark_literal_frags (seg_list *segment)
{
  frchainS *frchain_from;
  fragS *search_frag;

  while (segment)
    {
      frchain_from = seg_info (segment->seg)->frchainP;
      search_frag = frchain_from->frch_root;
      while (search_frag)
	{
	  search_frag->tc_frag_data.is_literal = TRUE;
	  search_frag = search_frag->fr_next;
	}
      segment = segment->next;
    }
}


static void
xtensa_reorder_seg_list (seg_list *head, segT after)
{
  /* Move all of the sections in the section list to come
     after "after" in the gnu segment list.  */

  head = head->next;
  while (head)
    {
      segT literal_section = head->seg;

      /* Move the literal section after "after".  */
      gas_assert (literal_section);
      if (literal_section != after)
	{
	  bfd_section_list_remove (stdoutput, literal_section);
	  bfd_section_list_insert_after (stdoutput, after, literal_section);
	}

      head = head->next;
    }
}


/* Push all the literal segments to the end of the gnu list.  */

static void
xtensa_reorder_segments (void)
{
  segT sec;
  segT last_sec = 0;
  int old_count = 0;
  int new_count = 0;

  for (sec = stdoutput->sections; sec != NULL; sec = sec->next)
    {
      last_sec = sec;
      old_count++;
    }

  /* Now that we have the last section, push all the literal
     sections to the end.  */
  xtensa_reorder_seg_list (literal_head, last_sec);

  /* Now perform the final error check.  */
  for (sec = stdoutput->sections; sec != NULL; sec = sec->next)
    new_count++;
  gas_assert (new_count == old_count);
}


/* Change the emit state (seg, subseg, and frag related stuff) to the
   correct location.  Return a emit_state which can be passed to
   xtensa_restore_emit_state to return to current fragment.  */

static void
xtensa_switch_to_literal_fragment (emit_state *result)
{
  if (directive_state[directive_absolute_literals])
    {
      segT lit4_seg = cache_literal_section (TRUE);
      xtensa_switch_section_emit_state (result, lit4_seg, 0);
    }
  else
    xtensa_switch_to_non_abs_literal_fragment (result);

  /* Do a 4-byte align here.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
}


static void
xtensa_switch_to_non_abs_literal_fragment (emit_state *result)
{
  static bfd_boolean recursive = FALSE;
  fragS *pool_location = get_literal_pool_location (now_seg);
  segT lit_seg;
  bfd_boolean is_init =
    (now_seg && !strcmp (segment_name (now_seg), INIT_SECTION_NAME));
  bfd_boolean is_fini =
    (now_seg && !strcmp (segment_name (now_seg), FINI_SECTION_NAME));

  if (pool_location == NULL
      && !use_literal_section
      && !recursive
      && !is_init && ! is_fini)
    {
      as_bad (_("literal pool location required for text-section-literals; specify with .literal_position"));

      /* When we mark a literal pool location, we want to put a frag in
	 the literal pool that points to it.  But to do that, we want to
	 switch_to_literal_fragment.  But literal sections don't have
	 literal pools, so their location is always null, so we would
	 recurse forever.  This is kind of hacky, but it works.  */

      recursive = TRUE;
      xtensa_mark_literal_pool_location ();
      recursive = FALSE;
    }

  lit_seg = cache_literal_section (FALSE);
  xtensa_switch_section_emit_state (result, lit_seg, 0);

  if (!use_literal_section
      && !is_init && !is_fini
      && get_literal_pool_location (now_seg) != pool_location)
    {
      /* Close whatever frag is there.  */
      frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.literal_frag = pool_location;
      frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }
}


/* Call this function before emitting data into the literal section.
   This is a helper function for xtensa_switch_to_literal_fragment.
   This is similar to a .section new_now_seg subseg. */

static void
xtensa_switch_section_emit_state (emit_state *state,
				  segT new_now_seg,
				  subsegT new_now_subseg)
{
  state->name = now_seg->name;
  state->now_seg = now_seg;
  state->now_subseg = now_subseg;
  state->generating_literals = generating_literals;
  generating_literals++;
  subseg_set (new_now_seg, new_now_subseg);
}


/* Use to restore the emitting into the normal place.  */

static void
xtensa_restore_emit_state (emit_state *state)
{
  generating_literals = state->generating_literals;
  subseg_set (state->now_seg, state->now_subseg);
}


/* Predicate function used to look up a section in a particular group.  */

static bfd_boolean
match_section_group (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  const char *gname = inf;
  const char *group_name = elf_group_name (sec);
  
  return (group_name == gname
	  || (group_name != NULL
	      && gname != NULL
	      && strcmp (group_name, gname) == 0));
}


/* Get the literal section to be used for the current text section.
   The result may be cached in the default_lit_sections structure.  */

static segT
cache_literal_section (bfd_boolean use_abs_literals)
{
  const char *text_name, *group_name = 0;
  char *base_name, *name, *suffix;
  segT *pcached;
  segT seg, current_section;
  int current_subsec;
  bfd_boolean linkonce = FALSE;

  /* Save the current section/subsection.  */
  current_section = now_seg;
  current_subsec = now_subseg;

  /* Clear the cached values if they are no longer valid.  */
  if (now_seg != default_lit_sections.current_text_seg)
    {
      default_lit_sections.current_text_seg = now_seg;
      default_lit_sections.lit_seg = NULL;
      default_lit_sections.lit4_seg = NULL;
    }

  /* Check if the literal section is already cached.  */
  if (use_abs_literals)
    pcached = &default_lit_sections.lit4_seg;
  else
    pcached = &default_lit_sections.lit_seg;

  if (*pcached)
    return *pcached;
  
  text_name = default_lit_sections.lit_prefix;
  if (! text_name || ! *text_name)
    {
      text_name = segment_name (current_section);
      group_name = elf_group_name (current_section);
      linkonce = (current_section->flags & SEC_LINK_ONCE) != 0;
    }

  base_name = use_abs_literals ? ".lit4" : ".literal";
  if (group_name)
    {
      name = xmalloc (strlen (base_name) + strlen (group_name) + 2);
      sprintf (name, "%s.%s", base_name, group_name);
    }
  else if (strncmp (text_name, ".gnu.linkonce.", linkonce_len) == 0)
    {
      suffix = strchr (text_name + linkonce_len, '.');

      name = xmalloc (linkonce_len + strlen (base_name) + 1
		      + (suffix ? strlen (suffix) : 0));
      strcpy (name, ".gnu.linkonce");
      strcat (name, base_name);
      if (suffix)
	strcat (name, suffix);
      linkonce = TRUE;
    }
  else
    {
      /* If the section name begins or ends with ".text", then replace
	 that portion instead of appending an additional suffix.  */
      size_t len = strlen (text_name);
      if (len >= 5
	  && (strcmp (text_name + len - 5, ".text") == 0
	      || strncmp (text_name, ".text", 5) == 0))
	len -= 5;

      name = xmalloc (len + strlen (base_name) + 1);
      if (strncmp (text_name, ".text", 5) == 0)
	{
	  strcpy (name, base_name);
	  strcat (name, text_name + 5);
	}
      else
	{
	  strcpy (name, text_name);
	  strcpy (name + len, base_name);
	}
    }

  /* Canonicalize section names to allow renaming literal sections.
     The group name, if any, came from the current text section and
     has already been canonicalized.  */
  name = tc_canonicalize_symbol_name (name);

  seg = bfd_get_section_by_name_if (stdoutput, name, match_section_group,
				    (void *) group_name);
  if (! seg)
    {
      flagword flags;

      seg = subseg_force_new (name, 0);

      if (! use_abs_literals)
	{
	  /* Add the newly created literal segment to the list.  */
	  seg_list *n = (seg_list *) xmalloc (sizeof (seg_list));
	  n->seg = seg;
	  n->next = literal_head->next;
	  literal_head->next = n;
	}

      flags = (SEC_HAS_CONTENTS | SEC_READONLY | SEC_ALLOC | SEC_LOAD
	       | (linkonce ? (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD) : 0)
	       | (use_abs_literals ? SEC_DATA : SEC_CODE));

      elf_group_name (seg) = group_name;

      bfd_set_section_flags (stdoutput, seg, flags);
      bfd_set_section_alignment (stdoutput, seg, 2);
    }

  *pcached = seg;
  subseg_set (current_section, current_subsec);
  return seg;
}


/* Property Tables Stuff.  */

#define XTENSA_INSN_SEC_NAME ".xt.insn"
#define XTENSA_LIT_SEC_NAME ".xt.lit"
#define XTENSA_PROP_SEC_NAME ".xt.prop"

typedef bfd_boolean (*frag_predicate) (const fragS *);
typedef void (*frag_flags_fn) (const fragS *, frag_flags *);

static bfd_boolean get_frag_is_literal (const fragS *);
static void xtensa_create_property_segments
  (frag_predicate, frag_predicate, const char *, xt_section_type);
static void xtensa_create_xproperty_segments
  (frag_flags_fn, const char *, xt_section_type);
static bfd_boolean exclude_section_from_property_tables (segT);
static bfd_boolean section_has_property (segT, frag_predicate);
static bfd_boolean section_has_xproperty (segT, frag_flags_fn);
static void add_xt_block_frags
  (segT, xtensa_block_info **, frag_predicate, frag_predicate);
static bfd_boolean xtensa_frag_flags_is_empty (const frag_flags *);
static void xtensa_frag_flags_init (frag_flags *);
static void get_frag_property_flags (const fragS *, frag_flags *);
static flagword frag_flags_to_number (const frag_flags *);
static void add_xt_prop_frags (segT, xtensa_block_info **, frag_flags_fn);

/* Set up property tables after relaxation.  */

void
xtensa_post_relax_hook (void)
{
  xtensa_move_seg_list_to_beginning (literal_head);

  xtensa_find_unmarked_state_frags ();
  xtensa_mark_frags_for_org ();
  xtensa_mark_difference_of_two_symbols ();

  xtensa_create_property_segments (get_frag_is_literal,
				   NULL,
				   XTENSA_LIT_SEC_NAME,
				   xt_literal_sec);
  xtensa_create_xproperty_segments (get_frag_property_flags,
				    XTENSA_PROP_SEC_NAME,
				    xt_prop_sec);

  if (warn_unaligned_branch_targets)
    bfd_map_over_sections (stdoutput, xtensa_find_unaligned_branch_targets, 0);
  bfd_map_over_sections (stdoutput, xtensa_find_unaligned_loops, 0);
}


/* This function is only meaningful after xtensa_move_literals.  */

static bfd_boolean
get_frag_is_literal (const fragS *fragP)
{
  gas_assert (fragP != NULL);
  return fragP->tc_frag_data.is_literal;
}


static void
xtensa_create_property_segments (frag_predicate property_function,
				 frag_predicate end_property_function,
				 const char *section_name_base,
				 xt_section_type sec_type)
{
  segT *seclist;

  /* Walk over all of the current segments.
     Walk over each fragment
     For each non-empty fragment,
     Build a property record (append where possible).  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segT sec = *seclist;

      if (exclude_section_from_property_tables (sec))
	continue;

      if (section_has_property (sec, property_function))
	{
	  segment_info_type *xt_seg_info;
	  xtensa_block_info **xt_blocks;
	  segT prop_sec = xtensa_make_property_section (sec, section_name_base);

	  prop_sec->output_section = prop_sec;
	  subseg_set (prop_sec, 0);
	  xt_seg_info = seg_info (prop_sec);
	  xt_blocks = &xt_seg_info->tc_segment_info_data.blocks[sec_type];

	  /* Walk over all of the frchains here and add new sections.  */
	  add_xt_block_frags (sec, xt_blocks, property_function,
			      end_property_function);
	}
    }

  /* Now we fill them out....  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segment_info_type *seginfo;
      xtensa_block_info *block;
      segT sec = *seclist;

      seginfo = seg_info (sec);
      block = seginfo->tc_segment_info_data.blocks[sec_type];

      if (block)
	{
	  xtensa_block_info *cur_block;
	  int num_recs = 0;
	  bfd_size_type rec_size;

	  for (cur_block = block; cur_block; cur_block = cur_block->next)
	    num_recs++;

	  rec_size = num_recs * 8;
	  bfd_set_section_size (stdoutput, sec, rec_size);

	  if (num_recs)
	    {
	      char *frag_data;
	      int i;

	      subseg_set (sec, 0);
	      frag_data = frag_more (rec_size);
	      cur_block = block;
	      for (i = 0; i < num_recs; i++)
		{
		  fixS *fix;

		  /* Write the fixup.  */
		  gas_assert (cur_block);
		  fix = fix_new (frag_now, i * 8, 4,
				 section_symbol (cur_block->sec),
				 cur_block->offset,
				 FALSE, BFD_RELOC_32);
		  fix->fx_file = "<internal>";
		  fix->fx_line = 0;

		  /* Write the length.  */
		  md_number_to_chars (&frag_data[4 + i * 8],
				      cur_block->size, 4);
		  cur_block = cur_block->next;
		}
	      frag_wane (frag_now);
	      frag_new (0);
	      frag_wane (frag_now);
	    }
	}
    }
}


static void
xtensa_create_xproperty_segments (frag_flags_fn flag_fn,
				  const char *section_name_base,
				  xt_section_type sec_type)
{
  segT *seclist;

  /* Walk over all of the current segments.
     Walk over each fragment.
     For each fragment that has instructions,
     build an instruction record (append where possible).  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segT sec = *seclist;

      if (exclude_section_from_property_tables (sec))
	continue;

      if (section_has_xproperty (sec, flag_fn))
	{
	  segment_info_type *xt_seg_info;
	  xtensa_block_info **xt_blocks;
	  segT prop_sec = xtensa_make_property_section (sec, section_name_base);

	  prop_sec->output_section = prop_sec;
	  subseg_set (prop_sec, 0);
	  xt_seg_info = seg_info (prop_sec);
	  xt_blocks = &xt_seg_info->tc_segment_info_data.blocks[sec_type];

	  /* Walk over all of the frchains here and add new sections.  */
	  add_xt_prop_frags (sec, xt_blocks, flag_fn);
	}
    }

  /* Now we fill them out....  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segment_info_type *seginfo;
      xtensa_block_info *block;
      segT sec = *seclist;

      seginfo = seg_info (sec);
      block = seginfo->tc_segment_info_data.blocks[sec_type];

      if (block)
	{
	  xtensa_block_info *cur_block;
	  int num_recs = 0;
	  bfd_size_type rec_size;

	  for (cur_block = block; cur_block; cur_block = cur_block->next)
	    num_recs++;

	  rec_size = num_recs * (8 + 4);
	  bfd_set_section_size (stdoutput, sec, rec_size);
	  /* elf_section_data (sec)->this_hdr.sh_entsize = 12; */

	  if (num_recs)
	    {
	      char *frag_data;
	      int i;

	      subseg_set (sec, 0);
	      frag_data = frag_more (rec_size);
	      cur_block = block;
	      for (i = 0; i < num_recs; i++)
		{
		  fixS *fix;

		  /* Write the fixup.  */
		  gas_assert (cur_block);
		  fix = fix_new (frag_now, i * 12, 4,
				 section_symbol (cur_block->sec),
				 cur_block->offset,
				 FALSE, BFD_RELOC_32);
		  fix->fx_file = "<internal>";
		  fix->fx_line = 0;

		  /* Write the length.  */
		  md_number_to_chars (&frag_data[4 + i * 12],
				      cur_block->size, 4);
		  md_number_to_chars (&frag_data[8 + i * 12],
				      frag_flags_to_number (&cur_block->flags),
				      sizeof (flagword));
		  cur_block = cur_block->next;
		}
	      frag_wane (frag_now);
	      frag_new (0);
	      frag_wane (frag_now);
	    }
	}
    }
}


static bfd_boolean
exclude_section_from_property_tables (segT sec)
{
  flagword flags = bfd_get_section_flags (stdoutput, sec);

  /* Sections that don't contribute to the memory footprint are excluded.  */
  if ((flags & SEC_DEBUGGING)
      || !(flags & SEC_ALLOC)
      || (flags & SEC_MERGE))
    return TRUE;

  /* Linker cie and fde optimizations mess up property entries for
     eh_frame sections, but there is nothing inside them relevant to
     property tables anyway.  */
  if (strcmp (sec->name, ".eh_frame") == 0)
    return TRUE;

  return FALSE;
}


static bfd_boolean
section_has_property (segT sec, frag_predicate property_function)
{
  segment_info_type *seginfo = seg_info (sec);
  fragS *fragP;

  if (seginfo && seginfo->frchainP)
    {
      for (fragP = seginfo->frchainP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (property_function (fragP)
	      && (fragP->fr_type != rs_fill || fragP->fr_fix != 0))
	    return TRUE;
	}
    }
  return FALSE;
}


static bfd_boolean
section_has_xproperty (segT sec, frag_flags_fn property_function)
{
  segment_info_type *seginfo = seg_info (sec);
  fragS *fragP;

  if (seginfo && seginfo->frchainP)
    {
      for (fragP = seginfo->frchainP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  frag_flags prop_flags;
	  property_function (fragP, &prop_flags);
	  if (!xtensa_frag_flags_is_empty (&prop_flags))
	    return TRUE;
	}
    }
  return FALSE;
}


/* Two types of block sections exist right now: literal and insns.  */

static void
add_xt_block_frags (segT sec,
		    xtensa_block_info **xt_block,
		    frag_predicate property_function,
		    frag_predicate end_property_function)
{
  fragS *fragP;

  /* Build it if needed.  */
  while (*xt_block != NULL)
    xt_block = &(*xt_block)->next;
  /* We are either at NULL at the beginning or at the end.  */

  /* Walk through the frags.  */
  if (seg_info (sec)->frchainP)
    {
      for (fragP = seg_info (sec)->frchainP->frch_root;
	   fragP;
	   fragP = fragP->fr_next)
	{
	  if (property_function (fragP)
	      && (fragP->fr_type != rs_fill || fragP->fr_fix != 0))
	    {
	      if (*xt_block != NULL)
		{
		  if ((*xt_block)->offset + (*xt_block)->size
		      == fragP->fr_address)
		    (*xt_block)->size += fragP->fr_fix;
		  else
		    xt_block = &((*xt_block)->next);
		}
	      if (*xt_block == NULL)
		{
		  xtensa_block_info *new_block = (xtensa_block_info *)
		    xmalloc (sizeof (xtensa_block_info));
		  new_block->sec = sec;
		  new_block->offset = fragP->fr_address;
		  new_block->size = fragP->fr_fix;
		  new_block->next = NULL;
		  xtensa_frag_flags_init (&new_block->flags);
		  *xt_block = new_block;
		}
	      if (end_property_function
		  && end_property_function (fragP))
		{
		  xt_block = &((*xt_block)->next);
		}
	    }
	}
    }
}


/* Break the encapsulation of add_xt_prop_frags here.  */

static bfd_boolean
xtensa_frag_flags_is_empty (const frag_flags *prop_flags)
{
  if (prop_flags->is_literal
      || prop_flags->is_insn
      || prop_flags->is_data
      || prop_flags->is_unreachable)
    return FALSE;
  return TRUE;
}


static void
xtensa_frag_flags_init (frag_flags *prop_flags)
{
  memset (prop_flags, 0, sizeof (frag_flags));
}


static void
get_frag_property_flags (const fragS *fragP, frag_flags *prop_flags)
{
  xtensa_frag_flags_init (prop_flags);
  if (fragP->tc_frag_data.is_literal)
    prop_flags->is_literal = TRUE;
  if (fragP->tc_frag_data.is_specific_opcode
      || fragP->tc_frag_data.is_no_transform)
    {
      prop_flags->is_no_transform = TRUE;
      if (xtensa_frag_flags_is_empty (prop_flags))
	prop_flags->is_data = TRUE;
    }
  if (fragP->tc_frag_data.is_unreachable)
    prop_flags->is_unreachable = TRUE;
  else if (fragP->tc_frag_data.is_insn)
    {
      prop_flags->is_insn = TRUE;
      if (fragP->tc_frag_data.is_loop_target)
	prop_flags->insn.is_loop_target = TRUE;
      if (fragP->tc_frag_data.is_branch_target)
	prop_flags->insn.is_branch_target = TRUE;
      if (fragP->tc_frag_data.is_no_density)
	prop_flags->insn.is_no_density = TRUE;
      if (fragP->tc_frag_data.use_absolute_literals)
	prop_flags->insn.is_abslit = TRUE;
    }
  if (fragP->tc_frag_data.is_align)
    {
      prop_flags->is_align = TRUE;
      prop_flags->alignment = fragP->tc_frag_data.alignment;
      if (xtensa_frag_flags_is_empty (prop_flags))
	prop_flags->is_data = TRUE;
    }
}


static flagword
frag_flags_to_number (const frag_flags *prop_flags)
{
  flagword num = 0;
  if (prop_flags->is_literal)
    num |= XTENSA_PROP_LITERAL;
  if (prop_flags->is_insn)
    num |= XTENSA_PROP_INSN;
  if (prop_flags->is_data)
    num |= XTENSA_PROP_DATA;
  if (prop_flags->is_unreachable)
    num |= XTENSA_PROP_UNREACHABLE;
  if (prop_flags->insn.is_loop_target)
    num |= XTENSA_PROP_INSN_LOOP_TARGET;
  if (prop_flags->insn.is_branch_target)
    {
      num |= XTENSA_PROP_INSN_BRANCH_TARGET;
      num = SET_XTENSA_PROP_BT_ALIGN (num, prop_flags->insn.bt_align_priority);
    }

  if (prop_flags->insn.is_no_density)
    num |= XTENSA_PROP_INSN_NO_DENSITY;
  if (prop_flags->is_no_transform)
    num |= XTENSA_PROP_NO_TRANSFORM;
  if (prop_flags->insn.is_no_reorder)
    num |= XTENSA_PROP_INSN_NO_REORDER;
  if (prop_flags->insn.is_abslit)
    num |= XTENSA_PROP_INSN_ABSLIT;

  if (prop_flags->is_align)
    {
      num |= XTENSA_PROP_ALIGN;
      num = SET_XTENSA_PROP_ALIGNMENT (num, prop_flags->alignment);
    }

  return num;
}


static bfd_boolean
xtensa_frag_flags_combinable (const frag_flags *prop_flags_1,
			      const frag_flags *prop_flags_2)
{
  /* Cannot combine with an end marker.  */

  if (prop_flags_1->is_literal != prop_flags_2->is_literal)
    return FALSE;
  if (prop_flags_1->is_insn != prop_flags_2->is_insn)
    return FALSE;
  if (prop_flags_1->is_data != prop_flags_2->is_data)
    return FALSE;

  if (prop_flags_1->is_insn)
    {
      /* Properties of the beginning of the frag.  */
      if (prop_flags_2->insn.is_loop_target)
	return FALSE;
      if (prop_flags_2->insn.is_branch_target)
	return FALSE;
      if (prop_flags_1->insn.is_no_density !=
	  prop_flags_2->insn.is_no_density)
	return FALSE;
      if (prop_flags_1->is_no_transform !=
	  prop_flags_2->is_no_transform)
	return FALSE;
      if (prop_flags_1->insn.is_no_reorder !=
	  prop_flags_2->insn.is_no_reorder)
	return FALSE;
      if (prop_flags_1->insn.is_abslit !=
	  prop_flags_2->insn.is_abslit)
	return FALSE;
    }

  if (prop_flags_1->is_align)
    return FALSE;

  return TRUE;
}


static bfd_vma
xt_block_aligned_size (const xtensa_block_info *xt_block)
{
  bfd_vma end_addr;
  unsigned align_bits;

  if (!xt_block->flags.is_align)
    return xt_block->size;

  end_addr = xt_block->offset + xt_block->size;
  align_bits = xt_block->flags.alignment;
  end_addr = ((end_addr + ((1 << align_bits) -1)) >> align_bits) << align_bits;
  return end_addr - xt_block->offset;
}


static bfd_boolean
xtensa_xt_block_combine (xtensa_block_info *xt_block,
			 const xtensa_block_info *xt_block_2)
{
  if (xt_block->sec != xt_block_2->sec)
    return FALSE;
  if (xt_block->offset + xt_block_aligned_size (xt_block)
      != xt_block_2->offset)
    return FALSE;

  if (xt_block_2->size == 0
      && (!xt_block_2->flags.is_unreachable
	  || xt_block->flags.is_unreachable))
    {
      if (xt_block_2->flags.is_align
	  && xt_block->flags.is_align)
	{
	  /* Nothing needed.  */
	  if (xt_block->flags.alignment >= xt_block_2->flags.alignment)
	    return TRUE;
	}
      else
	{
	  if (xt_block_2->flags.is_align)
	    {
	      /* Push alignment to previous entry.  */
	      xt_block->flags.is_align = xt_block_2->flags.is_align;
	      xt_block->flags.alignment = xt_block_2->flags.alignment;
	    }
	  return TRUE;
	}
    }
  if (!xtensa_frag_flags_combinable (&xt_block->flags,
				     &xt_block_2->flags))
    return FALSE;

  xt_block->size += xt_block_2->size;

  if (xt_block_2->flags.is_align)
    {
      xt_block->flags.is_align = TRUE;
      xt_block->flags.alignment = xt_block_2->flags.alignment;
    }

  return TRUE;
}


static void
add_xt_prop_frags (segT sec,
		   xtensa_block_info **xt_block,
		   frag_flags_fn property_function)
{
  fragS *fragP;

  /* Build it if needed.  */
  while (*xt_block != NULL)
    {
      xt_block = &(*xt_block)->next;
    }
  /* We are either at NULL at the beginning or at the end.  */

  /* Walk through the frags.  */
  if (seg_info (sec)->frchainP)
    {
      for (fragP = seg_info (sec)->frchainP->frch_root; fragP;
	   fragP = fragP->fr_next)
	{
	  xtensa_block_info tmp_block;
	  tmp_block.sec = sec;
	  tmp_block.offset = fragP->fr_address;
	  tmp_block.size = fragP->fr_fix;
	  tmp_block.next = NULL;
	  property_function (fragP, &tmp_block.flags);

	  if (!xtensa_frag_flags_is_empty (&tmp_block.flags))
	    /* && fragP->fr_fix != 0) */
	    {
	      if ((*xt_block) == NULL
		  || !xtensa_xt_block_combine (*xt_block, &tmp_block))
		{
		  xtensa_block_info *new_block;
		  if ((*xt_block) != NULL)
		    xt_block = &(*xt_block)->next;
		  new_block = (xtensa_block_info *)
		    xmalloc (sizeof (xtensa_block_info));
		  *new_block = tmp_block;
		  *xt_block = new_block;
		}
	    }
	}
    }
}


/* op_placement_info_table */

/* op_placement_info makes it easier to determine which
   ops can go in which slots.  */

static void
init_op_placement_info_table (void)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_insnbuf ibuf = xtensa_insnbuf_alloc (isa);
  xtensa_opcode opcode;
  xtensa_format fmt;
  int slot;
  int num_opcodes = xtensa_isa_num_opcodes (isa);

  op_placement_table = (op_placement_info_table)
    xmalloc (sizeof (op_placement_info) * num_opcodes);
  gas_assert (xtensa_isa_num_formats (isa) < MAX_FORMATS);

  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      op_placement_info *opi = &op_placement_table[opcode];
      /* FIXME: Make tinsn allocation dynamic.  */
      if (xtensa_opcode_num_operands (isa, opcode) > MAX_INSN_ARGS)
	as_fatal (_("too many operands in instruction"));
      opi->narrowest = XTENSA_UNDEFINED;
      opi->narrowest_size = 0x7F;
      opi->narrowest_slot = 0;
      opi->formats = 0;
      opi->num_formats = 0;
      opi->issuef = 0;
      for (fmt = 0; fmt < xtensa_isa_num_formats (isa); fmt++)
	{
	  opi->slots[fmt] = 0;
	  for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
	    {
	      if (xtensa_opcode_encode (isa, fmt, slot, ibuf, opcode) == 0)
		{
		  int fmt_length = xtensa_format_length (isa, fmt);
		  opi->issuef++;
		  set_bit (fmt, opi->formats);
		  set_bit (slot, opi->slots[fmt]);
		  if (fmt_length < opi->narrowest_size
		      || (fmt_length == opi->narrowest_size
			  && (xtensa_format_num_slots (isa, fmt)
			      < xtensa_format_num_slots (isa,
							 opi->narrowest))))
		    {
		      opi->narrowest = fmt;
		      opi->narrowest_size = fmt_length;
		      opi->narrowest_slot = slot;
		    }
		}
	    }
	  if (opi->formats)
	    opi->num_formats++;
	}
    }
  xtensa_insnbuf_free (isa, ibuf);
}


bfd_boolean
opcode_fits_format_slot (xtensa_opcode opcode, xtensa_format fmt, int slot)
{
  return bit_is_set (slot, op_placement_table[opcode].slots[fmt]);
}


/* If the opcode is available in a single slot format, return its size.  */

static int
xg_get_single_size (xtensa_opcode opcode)
{
  return op_placement_table[opcode].narrowest_size;
}


static xtensa_format
xg_get_single_format (xtensa_opcode opcode)
{
  return op_placement_table[opcode].narrowest;
}


static int
xg_get_single_slot (xtensa_opcode opcode)
{
  return op_placement_table[opcode].narrowest_slot;
}


/* Instruction Stack Functions (from "xtensa-istack.h").  */

void
istack_init (IStack *stack)
{
  stack->ninsn = 0;
}


bfd_boolean
istack_empty (IStack *stack)
{
  return (stack->ninsn == 0);
}


bfd_boolean
istack_full (IStack *stack)
{
  return (stack->ninsn == MAX_ISTACK);
}


/* Return a pointer to the top IStack entry.
   It is an error to call this if istack_empty () is TRUE. */

TInsn *
istack_top (IStack *stack)
{
  int rec = stack->ninsn - 1;
  gas_assert (!istack_empty (stack));
  return &stack->insn[rec];
}


/* Add a new TInsn to an IStack.
   It is an error to call this if istack_full () is TRUE.  */

void
istack_push (IStack *stack, TInsn *insn)
{
  int rec = stack->ninsn;
  gas_assert (!istack_full (stack));
  stack->insn[rec] = *insn;
  stack->ninsn++;
}


/* Clear space for the next TInsn on the IStack and return a pointer
   to it.  It is an error to call this if istack_full () is TRUE.  */

TInsn *
istack_push_space (IStack *stack)
{
  int rec = stack->ninsn;
  TInsn *insn;
  gas_assert (!istack_full (stack));
  insn = &stack->insn[rec];
  tinsn_init (insn);
  stack->ninsn++;
  return insn;
}


/* Remove the last pushed instruction.  It is an error to call this if
   istack_empty () returns TRUE.  */

void
istack_pop (IStack *stack)
{
  int rec = stack->ninsn - 1;
  gas_assert (!istack_empty (stack));
  stack->ninsn--;
  tinsn_init (&stack->insn[rec]);
}


/* TInsn functions.  */

void
tinsn_init (TInsn *dst)
{
  memset (dst, 0, sizeof (TInsn));
}


/* Return TRUE if ANY of the operands in the insn are symbolic.  */

static bfd_boolean
tinsn_has_symbolic_operands (const TInsn *insn)
{
  int i;
  int n = insn->ntok;

  gas_assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
    {
      switch (insn->tok[i].X_op)
	{
	case O_register:
	case O_constant:
	  break;
	default:
	  return TRUE;
	}
    }
  return FALSE;
}


bfd_boolean
tinsn_has_invalid_symbolic_operands (const TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  int i;
  int n = insn->ntok;

  gas_assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
    {
      switch (insn->tok[i].X_op)
	{
	case O_register:
	case O_constant:
	  break;
	case O_big:
	case O_illegal:
	case O_absent:
	  /* Errors for these types are caught later.  */
	  break;
	case O_hi16:
	case O_lo16:
	default:
	  /* Symbolic immediates are only allowed on the last immediate
	     operand.  At this time, CONST16 is the only opcode where we
	     support non-PC-relative relocations.  */
	  if (i != get_relaxable_immed (insn->opcode)
	      || (xtensa_operand_is_PCrelative (isa, insn->opcode, i) != 1
		  && insn->opcode != xtensa_const16_opcode))
	    {
	      as_bad (_("invalid symbolic operand"));
	      return TRUE;
	    }
	}
    }
  return FALSE;
}


/* For assembly code with complex expressions (e.g. subtraction),
   we have to build them in the literal pool so that
   their results are calculated correctly after relaxation.
   The relaxation only handles expressions that
   boil down to SYMBOL + OFFSET.  */

static bfd_boolean
tinsn_has_complex_operands (const TInsn *insn)
{
  int i;
  int n = insn->ntok;
  gas_assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < n; ++i)
    {
      switch (insn->tok[i].X_op)
	{
	case O_register:
	case O_constant:
	case O_symbol:
	case O_lo16:
	case O_hi16:
	  break;
	default:
	  return TRUE;
	}
    }
  return FALSE;
}


/* Encode a TInsn opcode and its constant operands into slotbuf.
   Return TRUE if there is a symbol in the immediate field.  This
   function assumes that:
   1) The number of operands are correct.
   2) The insn_type is ITYPE_INSN.
   3) The opcode can be encoded in the specified format and slot.
   4) Operands are either O_constant or O_symbol, and all constants fit.  */

static bfd_boolean
tinsn_to_slotbuf (xtensa_format fmt,
		  int slot,
		  TInsn *tinsn,
		  xtensa_insnbuf slotbuf)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = tinsn->opcode;
  bfd_boolean has_fixup = FALSE;
  int noperands = xtensa_opcode_num_operands (isa, opcode);
  int i;

  gas_assert (tinsn->insn_type == ITYPE_INSN);
  if (noperands != tinsn->ntok)
    as_fatal (_("operand number mismatch"));

  if (xtensa_opcode_encode (isa, fmt, slot, slotbuf, opcode))
    {
      as_bad (_("cannot encode opcode \"%s\" in the given format \"%s\""),
	      xtensa_opcode_name (isa, opcode), xtensa_format_name (isa, fmt));
      return FALSE;
    }

  for (i = 0; i < noperands; i++)
    {
      expressionS *exp = &tinsn->tok[i];
      int rc;
      unsigned line;
      char *file_name;
      uint32 opnd_value;

      switch (exp->X_op)
	{
	case O_register:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  /* The register number has already been checked in
	     expression_maybe_register, so we don't need to check here.  */
	  opnd_value = exp->X_add_number;
	  (void) xtensa_operand_encode (isa, opcode, i, &opnd_value);
	  rc = xtensa_operand_set_field (isa, opcode, i, fmt, slot, slotbuf,
					 opnd_value);
	  if (rc != 0)
	    as_warn (_("xtensa-isa failure: %s"), xtensa_isa_error_msg (isa));
	  break;

	case O_constant:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  as_where (&file_name, &line);
	  /* It is a constant and we called this function
	     then we have to try to fit it.  */
	  xtensa_insnbuf_set_operand (slotbuf, fmt, slot, opcode, i,
				      exp->X_add_number, file_name, line);
	  break;

	default:
	  has_fixup = TRUE;
	  break;
	}
    }

  return has_fixup;
}


/* Encode a single TInsn into an insnbuf.  If the opcode can only be encoded
   into a multi-slot instruction, fill the other slots with NOPs.
   Return TRUE if there is a symbol in the immediate field.  See also the
   assumptions listed for tinsn_to_slotbuf.  */

static bfd_boolean
tinsn_to_insnbuf (TInsn *tinsn, xtensa_insnbuf insnbuf)
{
  static xtensa_insnbuf slotbuf = 0;
  static vliw_insn vinsn;
  xtensa_isa isa = xtensa_default_isa;
  bfd_boolean has_fixup = FALSE;
  int i;

  if (!slotbuf)
    {
      slotbuf = xtensa_insnbuf_alloc (isa);
      xg_init_vinsn (&vinsn);
    }

  xg_clear_vinsn (&vinsn);

  bundle_tinsn (tinsn, &vinsn);

  xtensa_format_encode (isa, vinsn.format, insnbuf);

  for (i = 0; i < vinsn.num_slots; i++)
    {
      /* Only one slot may have a fix-up because the rest contains NOPs.  */
      has_fixup |=
	tinsn_to_slotbuf (vinsn.format, i, &vinsn.slots[i], vinsn.slotbuf[i]);
      xtensa_format_set_slot (isa, vinsn.format, i, insnbuf, vinsn.slotbuf[i]);
    }

  return has_fixup;
}


/* Check the instruction arguments.  Return TRUE on failure.  */

static bfd_boolean
tinsn_check_arguments (const TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = insn->opcode;
  xtensa_regfile t1_regfile, t2_regfile;
  int t1_reg, t2_reg;
  int t1_base_reg, t1_last_reg;
  int t2_base_reg, t2_last_reg;
  char t1_inout, t2_inout;
  int i, j;

  if (opcode == XTENSA_UNDEFINED)
    {
      as_bad (_("invalid opcode"));
      return TRUE;
    }

  if (xtensa_opcode_num_operands (isa, opcode) > insn->ntok)
    {
      as_bad (_("too few operands"));
      return TRUE;
    }

  if (xtensa_opcode_num_operands (isa, opcode) < insn->ntok)
    {
      as_bad (_("too many operands"));
      return TRUE;
    }

  /* Check registers.  */
  for (j = 0; j < insn->ntok; j++)
    {
      if (xtensa_operand_is_register (isa, insn->opcode, j) != 1)
	continue;

      t2_regfile = xtensa_operand_regfile (isa, insn->opcode, j);
      t2_base_reg = insn->tok[j].X_add_number;
      t2_last_reg
	= t2_base_reg + xtensa_operand_num_regs (isa, insn->opcode, j);

      for (i = 0; i < insn->ntok; i++)
	{
	  if (i == j)
	    continue;

	  if (xtensa_operand_is_register (isa, insn->opcode, i) != 1)
	    continue;

	  t1_regfile = xtensa_operand_regfile (isa, insn->opcode, i);

	  if (t1_regfile != t2_regfile)
	    continue;

	  t1_inout = xtensa_operand_inout (isa, insn->opcode, i);
	  t2_inout = xtensa_operand_inout (isa, insn->opcode, j);

	  t1_base_reg = insn->tok[i].X_add_number;
	  t1_last_reg = (t1_base_reg
			 + xtensa_operand_num_regs (isa, insn->opcode, i));

	  for (t1_reg = t1_base_reg; t1_reg < t1_last_reg; t1_reg++)
	    {
	      for (t2_reg = t2_base_reg; t2_reg < t2_last_reg; t2_reg++)
		{
		  if (t1_reg != t2_reg)
		    continue;

		  if (t1_inout != 'i' && t2_inout != 'i')
		    {
		      as_bad (_("multiple writes to the same register"));
		      return TRUE;
		    }
		}
	    }
	}
    }
  return FALSE;
}


/* Load an instruction from its encoded form.  */

static void
tinsn_from_chars (TInsn *tinsn, char *f, int slot)
{
  vliw_insn vinsn;

  xg_init_vinsn (&vinsn);
  vinsn_from_chars (&vinsn, f);

  *tinsn = vinsn.slots[slot];
  xg_free_vinsn (&vinsn);
}


static void
tinsn_from_insnbuf (TInsn *tinsn,
		    xtensa_insnbuf slotbuf,
		    xtensa_format fmt,
		    int slot)
{
  int i;
  xtensa_isa isa = xtensa_default_isa;

  /* Find the immed.  */
  tinsn_init (tinsn);
  tinsn->insn_type = ITYPE_INSN;
  tinsn->is_specific_opcode = FALSE;	/* must not be specific */
  tinsn->opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);
  tinsn->ntok = xtensa_opcode_num_operands (isa, tinsn->opcode);
  for (i = 0; i < tinsn->ntok; i++)
    {
      set_expr_const (&tinsn->tok[i],
		      xtensa_insnbuf_get_operand (slotbuf, fmt, slot,
						  tinsn->opcode, i));
    }
}


/* Read the value of the relaxable immed from the fr_symbol and fr_offset.  */

static void
tinsn_immed_from_frag (TInsn *tinsn, fragS *fragP, int slot)
{
  xtensa_opcode opcode = tinsn->opcode;
  int opnum;

  if (fragP->tc_frag_data.slot_symbols[slot])
    {
      opnum = get_relaxable_immed (opcode);
      gas_assert (opnum >= 0);
      set_expr_symbol_offset (&tinsn->tok[opnum],
			      fragP->tc_frag_data.slot_symbols[slot],
			      fragP->tc_frag_data.slot_offsets[slot]);
    }
  tinsn->extra_arg = fragP->tc_frag_data.free_reg[slot];
}


static int
get_num_stack_text_bytes (IStack *istack)
{
  int i;
  int text_bytes = 0;

  for (i = 0; i < istack->ninsn; i++)
    {
      TInsn *tinsn = &istack->insn[i];
      if (tinsn->insn_type == ITYPE_INSN)
	text_bytes += xg_get_single_size (tinsn->opcode);
    }
  return text_bytes;
}


static int
get_num_stack_literal_bytes (IStack *istack)
{
  int i;
  int lit_bytes = 0;

  for (i = 0; i < istack->ninsn; i++)
    {
      TInsn *tinsn = &istack->insn[i];
      if (tinsn->insn_type == ITYPE_LITERAL && tinsn->ntok == 1)
	lit_bytes += 4;
    }
  return lit_bytes;
}


/* vliw_insn functions.  */

static void
xg_init_vinsn (vliw_insn *v)
{
  int i;
  xtensa_isa isa = xtensa_default_isa;

  xg_clear_vinsn (v);

  v->insnbuf = xtensa_insnbuf_alloc (isa);
  if (v->insnbuf == NULL)
    as_fatal (_("out of memory"));

  for (i = 0; i < config_max_slots; i++)
    {
      v->slotbuf[i] = xtensa_insnbuf_alloc (isa);
      if (v->slotbuf[i] == NULL)
	as_fatal (_("out of memory"));
    }
}


static void
xg_clear_vinsn (vliw_insn *v)
{
  int i;

  memset (v, 0, offsetof (vliw_insn, slots) 
                + sizeof(TInsn) * config_max_slots);

  v->format = XTENSA_UNDEFINED;
  v->num_slots = 0;
  v->inside_bundle = FALSE;

  if (xt_saved_debug_type != DEBUG_NONE)
    debug_type = xt_saved_debug_type;

  for (i = 0; i < config_max_slots; i++)
    v->slots[i].opcode = XTENSA_UNDEFINED;
}


static void
xg_copy_vinsn (vliw_insn *dst, vliw_insn *src)
{
  memcpy (dst, src, 
	  offsetof(vliw_insn, slots) + src->num_slots * sizeof(TInsn));
  dst->insnbuf = src->insnbuf;
  memcpy (dst->slotbuf, src->slotbuf, src->num_slots * sizeof(xtensa_insnbuf));
}


static bfd_boolean
vinsn_has_specific_opcodes (vliw_insn *v)
{
  int i;

  for (i = 0; i < v->num_slots; i++)
    {
      if (v->slots[i].is_specific_opcode)
	return TRUE;
    }
  return FALSE;
}


static void
xg_free_vinsn (vliw_insn *v)
{
  int i;
  xtensa_insnbuf_free (xtensa_default_isa, v->insnbuf);
  for (i = 0; i < config_max_slots; i++)
    xtensa_insnbuf_free (xtensa_default_isa, v->slotbuf[i]);
}


/* Encode a vliw_insn into an insnbuf.  Return TRUE if there are any symbolic
   operands.  See also the assumptions listed for tinsn_to_slotbuf.  */

static bfd_boolean
vinsn_to_insnbuf (vliw_insn *vinsn,
		  char *frag_offset,
		  fragS *fragP,
		  bfd_boolean record_fixup)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt = vinsn->format;
  xtensa_insnbuf insnbuf = vinsn->insnbuf;
  int slot;
  bfd_boolean has_fixup = FALSE;

  xtensa_format_encode (isa, fmt, insnbuf);

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      TInsn *tinsn = &vinsn->slots[slot];
      expressionS *extra_arg = &tinsn->extra_arg;
      bfd_boolean tinsn_has_fixup =
	tinsn_to_slotbuf (vinsn->format, slot, tinsn,
			  vinsn->slotbuf[slot]);

      xtensa_format_set_slot (isa, fmt, slot,
			      insnbuf, vinsn->slotbuf[slot]);
      if (extra_arg->X_op != O_illegal && extra_arg->X_op != O_register)
	{
	  if (vinsn->num_slots != 1)
	    as_bad (_("TLS relocation not allowed in FLIX bundle"));
	  else if (record_fixup)
	    /* Instructions that generate TLS relocations should always be
	       relaxed in the front-end.  If "record_fixup" is set, then this
	       function is being called during back-end relaxation, so flag
	       the unexpected behavior as an error.  */
	    as_bad (_("unexpected TLS relocation"));
	  else
	    fix_new (fragP, frag_offset - fragP->fr_literal,
		     xtensa_format_length (isa, fmt),
		     extra_arg->X_add_symbol, extra_arg->X_add_number,
		     FALSE, map_operator_to_reloc (extra_arg->X_op, FALSE));
	}
      if (tinsn_has_fixup)
	{
	  int i;
	  xtensa_opcode opcode = tinsn->opcode;
	  int noperands = xtensa_opcode_num_operands (isa, opcode);
	  has_fixup = TRUE;

	  for (i = 0; i < noperands; i++)
	    {
	      expressionS* exp = &tinsn->tok[i];
	      switch (exp->X_op)
		{
		case O_symbol:
		case O_lo16:
		case O_hi16:
		  if (get_relaxable_immed (opcode) == i)
		    {
		      /* Add a fix record for the instruction, except if this
			 function is being called prior to relaxation, i.e.,
			 if record_fixup is false, and the instruction might
			 be relaxed later.  */
		      if (record_fixup
			  || tinsn->is_specific_opcode
			  || !xg_is_relaxable_insn (tinsn, 0))
			{
			  xg_add_opcode_fix (tinsn, i, fmt, slot, exp, fragP,
					     frag_offset - fragP->fr_literal);
			}
		      else
			{
			  if (exp->X_op != O_symbol)
			    as_bad (_("invalid operand"));
			  tinsn->symbol = exp->X_add_symbol;
			  tinsn->offset = exp->X_add_number;
			}
		    }
		  else
		    as_bad (_("symbolic operand not allowed"));
		  break;

		case O_constant:
		case O_register:
		  break;

		default:
		  as_bad (_("expression too complex"));
		  break;
		}
	    }
	}
    }

  return has_fixup;
}


static void
vinsn_from_chars (vliw_insn *vinsn, char *f)
{
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  int i;
  xtensa_format fmt;
  xtensa_isa isa = xtensa_default_isa;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, (unsigned char *) f, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("cannot decode instruction format"));
  vinsn->format = fmt;
  vinsn->num_slots = xtensa_format_num_slots (isa, fmt);

  for (i = 0; i < vinsn->num_slots; i++)
    {
      TInsn *tinsn = &vinsn->slots[i];
      xtensa_format_get_slot (isa, fmt, i, insnbuf, slotbuf);
      tinsn_from_insnbuf (tinsn, slotbuf, fmt, i);
    }
}


/* Expression utilities.  */

/* Return TRUE if the expression is an integer constant.  */

bfd_boolean
expr_is_const (const expressionS *s)
{
  return (s->X_op == O_constant);
}


/* Get the expression constant.
   Calling this is illegal if expr_is_const () returns TRUE.  */

offsetT
get_expr_const (const expressionS *s)
{
  gas_assert (expr_is_const (s));
  return s->X_add_number;
}


/* Set the expression to a constant value.  */

void
set_expr_const (expressionS *s, offsetT val)
{
  s->X_op = O_constant;
  s->X_add_number = val;
  s->X_add_symbol = NULL;
  s->X_op_symbol = NULL;
}


bfd_boolean
expr_is_register (const expressionS *s)
{
  return (s->X_op == O_register);
}


/* Get the expression constant.
   Calling this is illegal if expr_is_const () returns TRUE.  */

offsetT
get_expr_register (const expressionS *s)
{
  gas_assert (expr_is_register (s));
  return s->X_add_number;
}


/* Set the expression to a symbol + constant offset.  */

void
set_expr_symbol_offset (expressionS *s, symbolS *sym, offsetT offset)
{
  s->X_op = O_symbol;
  s->X_add_symbol = sym;
  s->X_op_symbol = NULL;	/* unused */
  s->X_add_number = offset;
}


/* Return TRUE if the two expressions are equal.  */

bfd_boolean
expr_is_equal (expressionS *s1, expressionS *s2)
{
  if (s1->X_op != s2->X_op)
    return FALSE;
  if (s1->X_add_symbol != s2->X_add_symbol)
    return FALSE;
  if (s1->X_op_symbol != s2->X_op_symbol)
    return FALSE;
  if (s1->X_add_number != s2->X_add_number)
    return FALSE;
  return TRUE;
}


static void
copy_expr (expressionS *dst, const expressionS *src)
{
  memcpy (dst, src, sizeof (expressionS));
}


/* Support for the "--rename-section" option.  */

struct rename_section_struct
{
  char *old_name;
  char *new_name;
  struct rename_section_struct *next;
};

static struct rename_section_struct *section_rename;


/* Parse the string "oldname=new_name(:oldname2=new_name2)*" and add
   entries to the section_rename list.  Note: Specifying multiple
   renamings separated by colons is not documented and is retained only
   for backward compatibility.  */

static void
build_section_rename (const char *arg)
{
  struct rename_section_struct *r;
  char *this_arg = NULL;
  char *next_arg = NULL;

  for (this_arg = xstrdup (arg); this_arg != NULL; this_arg = next_arg)
    {
      char *old_name, *new_name;

      if (this_arg)
	{
	  next_arg = strchr (this_arg, ':');
	  if (next_arg)
	    {
	      *next_arg = '\0';
	      next_arg++;
	    }
	}

      old_name = this_arg;
      new_name = strchr (this_arg, '=');

      if (*old_name == '\0')
	{
	  as_warn (_("ignoring extra '-rename-section' delimiter ':'"));
	  continue;
	}
      if (!new_name || new_name[1] == '\0')
	{
	  as_warn (_("ignoring invalid '-rename-section' specification: '%s'"),
		   old_name);
	  continue;
	}
      *new_name = '\0';
      new_name++;

      /* Check for invalid section renaming.  */
      for (r = section_rename; r != NULL; r = r->next)
	{
	  if (strcmp (r->old_name, old_name) == 0)
	    as_bad (_("section %s renamed multiple times"), old_name);
	  if (strcmp (r->new_name, new_name) == 0)
	    as_bad (_("multiple sections remapped to output section %s"),
		    new_name);
	}

      /* Now add it.  */
      r = (struct rename_section_struct *)
	xmalloc (sizeof (struct rename_section_struct));
      r->old_name = xstrdup (old_name);
      r->new_name = xstrdup (new_name);
      r->next = section_rename;
      section_rename = r;
    }
}


char *
xtensa_section_rename (char *name)
{
  struct rename_section_struct *r = section_rename;

  for (r = section_rename; r != NULL; r = r->next)
    {
      if (strcmp (r->old_name, name) == 0)
	return r->new_name;
    }

  return name;
}
@


1.126
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d8881 1
a8881 1
	      address += total_frag_text_expansion (fragP);;
@


1.125
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d22 1
a23 1
#include "as.h"
@


1.124
log
@2010-02-11  Sterling Augustine  <sterling@@jaw.hq.tensilica.com>

	* config/tc-xtensa.c (istack_init): Don't call memset.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009
d1324 1
a1324 1
  switch (end_directive)
d1326 1
a1326 1
    case (directiveE) XTENSA_UNDEFINED:
d1330 1
a1330 1
    case directive_density:
d1335 1
a1335 1
    case directive_absolute_literals:
d1455 3
a5442 1
	      segT t;
d5447 1
a5447 1
	      t = expression (tok);
a7897 1
	fragS *current_target = NULL;
a7909 1
		current_target = symbol_get_frag (fragP->fr_symbol);
a9600 1
      bfd_boolean last_is_jump;
a9674 1
      last_is_jump = FALSE;
d10065 1
a10065 1
  fragS *search_frag, *next_frag, *last_frag, *literal_pool, *insert_after;
a10106 1
      last_frag = frag_now;
@


1.123
log
@2010-02-11  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.c (cache_literal_section): Handle prefixes as
	well as suffixes.
@
text
@a11205 1
  memset (stack, 0, sizeof (IStack));
@


1.122
log
@2010-02-10  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.c (xtensa_find_unaligned_loops): Rewrite.
@
text
@d10426 2
a10427 2
      /* If the section name ends with ".text", then replace that suffix
	 instead of appending an additional suffix.  */
d10429 3
a10431 1
      if (len >= 5 && strcmp (text_name + len - 5, ".text") == 0)
d10435 10
a10444 2
      strcpy (name, text_name);
      strcpy (name + len, base_name);
@


1.121
log
@2010-02-09  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.c (RELAXED_LOOP_INSN_BYTES): New.
	(next_frag_pre_opcode_bytes): Use RELAXED_LOOP_INSN_BYTES.
	(xtensa_mark_zcl_first_insns): Rewrite to handle corner case.
@
text
@d5019 16
a5034 10
	      xtensa_insnbuf_from_chars
		(isa, insnbuf, (unsigned char *) frag->fr_literal, 0);
	      fmt = xtensa_format_decode (isa, insnbuf);
	      op_size = xtensa_format_length (isa, fmt);
	      frag_addr = frag->fr_address % xtensa_fetch_width;

	      if (frag_addr + op_size > xtensa_fetch_width)
		as_warn_where (frag->fr_file, frag->fr_line,
			       _("unaligned loop: %d bytes at 0x%lx"),
			       op_size, (long) frag->fr_address);
@


1.120
log
@2010-02-08  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.c (frag_format_size): Generalize logic to
	handle more instruction	sizes and fetch widths.
	(branch_align_power): Likewise.
	(text_align_power): Likewise.
	(bytes_to_stretch): Likewise.
@
text
@d4652 6
d4680 1
a4680 1
      return get_expanded_loop_offset (next_opcode);
d7410 1
a7410 1
		fragS *targ_frag = next_non_empty_frag (fragP);
d7412 28
a7439 1
		targ_frag = next_non_empty_frag (targ_frag);
@


1.119
log
@10-02-05  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.c (UNREACHABLE_MAX_WIDTH): Delete and
	replace with...
	(xtensa_fetch_width) ...this.
@
text
@d4524 1
a4524 1
	 three-byte format to a wider one with the logic below.  */
d4526 10
a4535 4
      if (fmt_size <= 3 && fragP->tc_frag_data.text_expansion[0] != 3)
	return 3 + fragP->tc_frag_data.text_expansion[0];
      else
	return 3;
d8235 27
a8261 2
  gas_assert (target_size == 8);
  return 3;
d8334 11
a8344 13
  /* If the Xtensa processor has a fetch width of 8 bytes, and the section
     is aligned to at least an 8-byte boundary, then a branch target need
     only fit within an 8-byte aligned block of memory to avoid a stall.
     Otherwise, try to fit branch targets within 4-byte aligned blocks
     (which may be insufficient, e.g., if the section has no alignment, but
     it's good enough).  */
  if (xtensa_fetch_width == 8)
    {
      if (get_recorded_alignment (sec) >= 3)
	return 3;
    }
  else
    gas_assert (xtensa_fetch_width == 4);
a9007 3
   When we must have a NOP, here is a table of how we decide
   (so you don't have to fight through the control flow below):

a9012 25
   Desired   wide   narrow
   Diff      nop    nop      widens
   1           0      0         1
   2           0      1         0
   3a          1      0         0
    b          0      1         1 (case 3a makes this case unnecessary)
   4a          1      0         1
    b          0      2         0
    c          0      1         2 (case 4a makes this case unnecessary)
   5a          1      0         2
    b          1      1         0
    c          0      2         1 (case 5b makes this case unnecessary)
   6a          2      0         0
    b          1      0         3
    c          0      1         4 (case 6b makes this case unnecessary)
    d          1      1         1 (case 6a makes this case unnecessary)
    e          0      2         2 (case 6a makes this case unnecessary)
    f          0      3         0 (case 6a makes this case unnecessary)
   7a          1      0         4
    b          2      0         1
    c          1      1         2 (case 7b makes this case unnecessary)
    d          0      1         5 (case 7a makes this case unnecessary)
    e          0      2         3 (case 7b makes this case unnecessary)
    f          0      3         1 (case 7b makes this case unnecessary)
    g          1      2         1 (case 7b makes this case unnecessary)
d9022 3
d9055 11
a9065 1
  if (this_frag->fr_subtype == RELAX_FILL_NOP)
d9067 5
a9071 51
      switch (desired_diff)
	{
	case 1:
	  return 0;
	case 2:
	  if (!this_frag->tc_frag_data.is_no_density && narrow_nops == 1)
	    return 2; /* case 2 */
	  return 0;
	case 3:
	  if (wide_nops > 1)
	    return 0;
	  else
	    return 3; /* case 3a */
	case 4:
	  if (num_widens >= 1 && wide_nops == 1)
	    return 3; /* case 4a */
	  if (!this_frag->tc_frag_data.is_no_density && narrow_nops == 2)
	    return 2; /* case 4b */
	  return 0;
	case 5:
	  if (num_widens >= 2 && wide_nops == 1)
	    return 3; /* case 5a */
	  /* We will need two nops.  Are there enough nops
	     between here and the align target?  */
	  if (wide_nops < 2 || narrow_nops == 0)
	    return 0;
	  /* Are there other nops closer that can serve instead?  */
	  if (wide_nops > 2 && narrow_nops > 1)
	    return 0;
	  /* Take the density one first, because there might not be
	     another density one available.  */
	  if (!this_frag->tc_frag_data.is_no_density)
	    return 2; /* case 5b narrow */
	  else
	    return 3; /* case 5b wide */
	  return 0;
	case 6:
	  if (wide_nops == 2)
	    return 3; /* case 6a */
	  else if (num_widens >= 3 && wide_nops == 1)
	    return 3; /* case 6b */
	  return 0;
	case 7:
	  if (wide_nops == 1 && num_widens >= 4)
	    return 3; /* case 7a */
	  else if (wide_nops == 2 && num_widens >= 1)
	    return 3; /* case 7b */
	  return 0;
	default:
	  gas_assert (0);
	}
d9073 9
a9081 1
  else
d9083 6
a9088 2
      /* We will need a NOP no matter what, but should we widen
	 this instruction to help?
d9090 13
a9102 33
	 This is a RELAX_NARROW frag.  */
      switch (desired_diff)
	{
	case 1:
	  gas_assert (0);
	  return 0;
	case 2:
	case 3:
	  return 0;
	case 4:
	  if (wide_nops >= 1 && num_widens == 1)
	    return 1; /* case 4a */
	  return 0;
	case 5:
	  if (wide_nops >= 1 && num_widens == 2)
	    return 1; /* case 5a */
	  return 0;
	case 6:
	  if (wide_nops >= 2)
	    return 0; /* case 6a */
	  else if (wide_nops >= 1 && num_widens == 3)
	    return 1; /* case 6b */
	  return 0;
	case 7:
	  if (wide_nops >= 1 && num_widens == 4)
	    return 1; /* case 7a */
	  else if (wide_nops >= 2 && num_widens == 1)
	    return 1; /* case 7b */
	  return 0;
	default:
	  gas_assert (0);
	  return 0;
	}
d9104 3
a9106 1
  gas_assert (0);
@


1.118
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@a77 3
/* Maximum width we would pad an unreachable frag to get alignment.  */
#define UNREACHABLE_MAX_WIDTH  8

d7120 1
a7120 1
		    UNREACHABLE_MAX_WIDTH, UNREACHABLE_MAX_WIDTH,
d7129 1
a7129 1
		    UNREACHABLE_MAX_WIDTH, UNREACHABLE_MAX_WIDTH,
d8941 1
a8941 1
	      gas_assert (opt_diff <= UNREACHABLE_MAX_WIDTH);
d9023 2
a9024 1
  gas_assert (desired_diff >= 0 && desired_diff < 8);
@


1.117
log
@2009-09-22  Sterling Augustine  <sterling@@jaw.hq.tensilica.com>

	* config/tc-xtensa.c (md_apply_fix): Remove check for constant with
	difference of of two symbols.
	(xtensa_fix_adjustable): Likewise.
@
text
@d1829 1
d3239 2
a3240 1
      const expressionS *expr = &insn->tok[i];
d3244 1
a3244 1
      switch (expr->X_op)
d3248 1
a3248 1
	  if (xg_check_operand (expr->X_add_number, insn->opcode, i))
d3284 2
a3285 1
      const expressionS *expr = &insn->tok[i];
d3289 1
a3289 1
      switch (expr->X_op)
d3293 1
a3293 1
	  if (xg_check_operand (expr->X_add_number, insn->opcode, i))
d3313 2
a3314 2
	  if (S_IS_WEAK (expr->X_add_symbol)
	      || S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
d3324 2
a3325 2
		  && (! S_IS_WEAK (expr->X_add_symbol)
		      || S_IS_DEFINED (expr->X_add_symbol)))
d3331 1
a3331 1
	  symbolP = expr->X_add_symbol;
d3333 1
a3333 1
	  target = S_GET_VALUE (symbolP) + expr->X_add_number;
d3574 1
a3574 1
		  TInsn *insn = &istack->insn[i];
d3576 3
a3578 3
		  if (insn->insn_type == ITYPE_INSN
		      && !tinsn_has_symbolic_operands (insn)
		      && !xg_immeds_fit (insn))
d4198 1
a4198 1
		   expressionS *expr,
d4218 1
a4218 1
      if (expr->X_op == O_lo16)
d4221 1
a4221 1
	  expr->X_op = O_symbol;
d4223 1
a4223 1
      else if (expr->X_op == O_hi16)
d4226 1
a4226 1
	  expr->X_op = O_symbol;
d4240 1
a4240 1
  if (expr->X_op == O_lo16 || expr->X_op == O_hi16)
d4265 1
a4265 1
  the_fix = fix_new_exp (fragP, offset, fmt_length, expr,
d4268 2
a4269 2
  the_fix->tc_fix_data.X_add_symbol = expr->X_add_symbol;
  the_fix->tc_fix_data.X_add_number = expr->X_add_number;
d7355 3
a7357 3
  const expressionS *expr = &tinsn->tok[1];
  symbolS *symbolP = expr->X_add_symbol;
  offsetT max_distance = expr->X_add_number;
d7360 1
a7360 1
  if (expr->X_op != O_symbol)
d7447 1
a7447 1
      expressionS *expr = symbol_get_value_expression (expr_sym);
d7449 1
a7449 1
      if (expr->X_op == O_subtract)
d7451 2
a7452 2
	  symbolS *left = expr->X_add_symbol;
	  symbolS *right = expr->X_op_symbol;
d8089 1
a8089 1
  const expressionS *expr;
d8102 1
a8102 1
  expr = &insn->tok[LOOP_IMMED_OPN];
d8104 1
a8104 1
  if (expr->X_op != O_symbol)
d8107 1
a8107 1
  symbolP = expr->X_add_symbol;
d8136 1
a8136 1
  const expressionS *expr;
d8149 1
a8149 1
  expr = &insn->tok[LOOP_IMMED_OPN];
d8151 1
a8151 1
  if (expr->X_op != O_symbol)
d8154 1
a8154 1
  symbolP = expr->X_add_symbol;
d10173 3
a10175 3
      segT dest_seg = symbol_get_frag (lit_sym)->tc_frag_data.lit_seg;
      if (dest_seg)
	S_SET_SEGMENT (lit_sym, dest_seg);
d11407 1
a11407 1
      expressionS *expr = &tinsn->tok[i];
d11413 1
a11413 1
      switch (expr->X_op)
d11420 1
a11420 1
	  opnd_value = expr->X_add_number;
d11435 1
a11435 1
				      expr->X_add_number, file_name, line);
d11789 2
a11790 2
	      expressionS* expr = &tinsn->tok[i];
	      switch (expr->X_op)
d11805 1
a11805 1
			  xg_add_opcode_fix (tinsn, i, fmt, slot, expr, fragP,
d11810 1
a11810 1
			  if (expr->X_op != O_symbol)
d11812 2
a11813 2
			  tinsn->symbol = expr->X_add_symbol;
			  tinsn->offset = expr->X_add_number;
@


1.116
log
@update copyright dates
@
text
@a5777 8
  /* An offset is not allowed in combination with the difference of two
     symbols, but that cannot be easily detected after a local symbol
     has been adjusted to a (section+offset) form.  Return 0 so that such
     an fix will not be adjusted.  */
  if (fixP->fx_subsy && fixP->fx_addsy && fixP->fx_offset
      && relaxable_section (S_GET_SEGMENT (fixP->fx_subsy)))
    return 0;

a5837 9
	  /* An offset is only allowed when it results from adjusting a
	     local symbol into a section-relative offset.  If the offset
	     came from the original expression, tc_fix_adjustable will have
	     prevented the fix from being converted to a section-relative
	     form so that we can flag the error here.  */
	  if (fixP->fx_offset != 0 && !symbol_section_p (fixP->fx_addsy))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("cannot represent subtraction with an offset"));

@


1.115
log
@2009-08-21  Sterling Augustine  <sterling@@jaw.hq.tensilica.com>

	* config/tc-xtensa.c (config_max_slots): New global variable.
	(md_begin): Set config_max_slots.
	(total_frag_text_expansion): Use config_max_slots instead of
	MAX_SLOTS.
	(xg_init_vinsn): Likewise.
	(xg_clear_vinsn): Likewise.
	(xg_free_vinsn): Likewise.
@
text
@d2 2
a3 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.114
log
@2009-08-20  Sterling Augustine  <sterling@@jaw.hq.tensilica.com>

	* config/tc-xtensa.c (xg_copy_vinsn): New function.
	(finish_vinsn): Call xg_copy_vinsn.
@
text
@d590 1
d5108 1
a5119 2
  xg_init_vinsn (&cur_vinsn);

d5152 9
d6893 1
a6893 1
  for (slot = 0; slot < MAX_SLOTS; slot++)
d11687 1
a11687 1
  for (i = 0; i < MAX_SLOTS; i++)
d11701 2
a11702 1
  memset (v, 0, offsetof (vliw_insn, insnbuf));
d11711 1
a11711 1
  for (i = 0; i < MAX_SLOTS; i++)
d11745 1
a11745 1
  for (i = 0; i < MAX_SLOTS; i++)
@


1.113
log
@2009-08-19  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.h (xtensa_frag_data): Rename unused field fr_prev
	to no_transform_end.
	* config/tc-xtensa.c (xtensa_mark_difference_of_two_symbols): Set
	and use no_transform_end.
@
text
@d530 1
a6656 1
  vliw_insn v_copy = *vinsn;
d6664 2
a6665 1
      v_copy = *vinsn;
d6700 1
a6700 1
	      *vinsn = v_copy;
d11706 10
@


1.112
log
@2009-08-18  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.c (xtensa_create_xproperty_segments): Use
	sizeof instead of hard-coded value.
	(add_xt_block_frags): Remove unused local variable.
	(frag_flags_to_number): Change return type to flagword.  Remove
	unused local variable.
@
text
@d7463 1
d7476 5
d7483 2
a7484 2
		  start->tc_frag_data.is_no_transform = 1;
		  start = start->fr_next;
d7486 3
a7488 1
	      while (start && start->fr_address < end->fr_address);
@


1.111
log
@2009-08-17  Sterling Augustine  <sterling@@jaw.hq.tensilica.com>

	* config/tc-xtensa.c (xtensa_frob_label): move call to
	do_align_targets to set frag_type only.
@
text
@d10493 1
a10493 1
static bfd_vma frag_flags_to_number (const frag_flags *);
d10719 1
a10719 1
				      4);
a10798 1
  bfd_vma seg_offset;
a10806 2
  seg_offset = 0;

d10904 1
a10904 1
static bfd_vma
d10907 1
a10907 1
  bfd_vma num = 0;
a11052 1
  bfd_vma seg_offset;
a11062 2
  seg_offset = 0;

@


1.110
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@a5212 1
      && do_align_targets ()
d5218 7
a5224 4
      frag_var (rs_machine_dependent,
		0, (int) freq,
		RELAX_DESIRE_ALIGN_IF_TARGET,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);
@


1.109
log
@2009-04-01  Sterling Augustine  <sterling@@jaw.hq.tensilica.com>

	* config/tc-xtensa.c (parse_arguments): call demand_empty_rest_of_line
@
text
@d1058 1
a1058 1
  assert (!past_xtensa_end);
d1069 1
a1069 1
  assert (!past_xtensa_end);
d1255 1
a1255 1
      assert (ls);
d1380 1
a1380 1
	      assert (s);
d1504 1
a1504 1
  assert (name);
d1699 1
a1699 1
  assert (operator != (unsigned char) -1);
d1829 1
a1829 1
	  assert (tok->X_op == O_constant);
d2017 1
a2017 1
	  assert (opnd_cnt > 0);
d2032 1
a2032 1
	  assert (opnd_cnt < MAX_INSN_ARGS);
d2359 1
a2359 1
  assert (opname[0] != '_');
d2835 1
a2835 1
	  assert (cond->op_num < insn->ntok);
d2874 2
a2875 2
	  assert (cond->op_num < insn->ntok);
	  assert (cond->op_data < insn->ntok);
d2977 1
a2977 1
  assert (insn->opcode < table->num_opcodes);
d3020 2
a3021 2
  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);
d3055 1
a3055 1
  assert (opcode < table->num_opcodes);
d3068 1
a3068 1
	  assert (build_list->typ == INSTR_INSTR);
d3101 1
a3101 1
  assert (opcode < table->num_opcodes);
d3114 1
a3114 1
	  assert (build_list->typ == INSTR_INSTR);
d3146 2
a3147 2
  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);
d3232 1
a3232 1
  assert (insn->insn_type == ITYPE_INSN);
d3249 1
a3249 1
	  assert (FALSE);
d3275 1
a3275 1
  assert (insn->insn_type == ITYPE_INSN);
d3383 1
a3383 1
	  assert (op->op_num < MAX_INSN_ARGS);
d3394 1
a3394 1
	      assert (op_data < insn->ntok);
d3415 1
a3415 1
	      assert (op_data < insn->ntok);
d3431 1
a3431 1
		  assert (op_data < insn->ntok);
d3452 1
a3452 1
		  assert (op_data < insn->ntok);
d3466 1
a3466 1
	      assert (0);
d3481 1
a3481 1
	  assert (op->op_num < MAX_INSN_ARGS);
d3489 1
a3489 1
	      assert (op_data < insn->ntok);
d3499 1
a3499 1
	      assert (0);
d3511 1
a3511 1
      assert (op == NULL);
d3515 1
a3515 1
      assert (0);
d3548 2
a3549 2
  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);
d3716 1
a3716 1
  assert (old_frag->fr_next == frag_now);
d3866 1
a3866 1
	  assert (b_op->op_num < MAX_INSN_ARGS);
d3872 2
a3873 2
	  assert (b_op->op_num < MAX_INSN_ARGS);
	  assert (b_op->op_data < (unsigned) old_insn->ntok);
d3882 1
a3882 1
	  assert (0);
d3886 1
a3886 1
	  assert (0);
d3912 2
a3913 2
  assert (insn_spec != NULL);
  assert (insn_spec->next == NULL);
d4092 2
a4093 2
  assert (insn->insn_type == ITYPE_LITERAL);
  assert (insn->ntok == 1);	/* must be only one token here */
d4143 1
a4143 1
  assert (frag_now->tc_frag_data.literal_frag == NULL);
d4163 1
a4163 1
  assert (size % 4 == 0);
d4310 1
a4310 1
  assert (insn->insn_type == ITYPE_INSN);
d4581 1
a4581 1
      assert (next_fragP->fr_type == rs_machine_dependent
d4592 1
a4592 1
      assert (new_target->fr_type == rs_machine_dependent
d4742 1
a4742 1
      assert (tinsn->opcode != XTENSA_UNDEFINED);
d4780 1
a4780 1
  assert (opcode != XTENSA_UNDEFINED);
d5895 1
a5895 1
	  assert (fixP->fx_addsy);
d5975 1
a5975 1
  assert ((int) fixp->fx_r_type > 0);
d6114 1
a6114 1
      assert (rt->units[stage + cycle][unit] > 0);
d6296 1
a6296 1
		  assert (lit_sym == NULL);
d6301 1
a6301 1
		  assert (insn->insn_type == ITYPE_INSN);
d6402 1
a6402 1
  assert (!past_xtensa_end);
d6784 1
a6784 1
  assert (vinsn->format != XTENSA_UNDEFINED);
d6838 1
a6838 1
	  assert (lit_sym == NULL);
d6847 1
a6847 1
	    assert (label_sym == NULL);
d6849 1
a6849 1
	    assert (label_sym);
d6867 1
a6867 1
	  assert (0);
d7062 1
a7062 1
	assert (vinsn->num_slots == 1);
d7122 1
a7122 1
	  assert (finish_frag);
d7131 1
a7131 1
	  assert (finish_frag);
d7732 1
a7732 1
	    assert (fragP->fr_type != rs_machine_dependent
d7808 1
a7808 1
      assert (0);
d7862 1
a7862 1
		assert (xtensa_opcode_is_loop (xtensa_default_isa,
d8225 1
a8225 1
  assert (target_size == 8);
d8261 1
a8261 1
  assert (target_size > 0 && alignment >= (addressT) target_size);
d8291 1
a8291 1
  assert (0);
d8311 1
a8311 1
    assert (xtensa_fetch_width == 4);
d8326 1
a8326 1
      assert (fill_size % 3 == 0);
d8330 1
a8330 1
  assert (fill_size != 1);	/* Bad argument.  */
d8340 1
a8340 1
  assert (fill_size != 1);	/* Bad algorithm.  */
d8355 1
a8355 1
  assert (fill_size != 1);	/* Bad argument.  */
d8367 1
a8367 1
  assert (0);
d8401 2
a8402 2
  assert (fragP->fr_type == rs_machine_dependent);
  assert (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE);
d8410 1
a8410 1
  assert (is_loop);
d8465 1
a8465 1
  assert (fragP->fr_type == rs_machine_dependent);
d8482 1
a8482 1
      assert (*max_diff >= opt_diff);
d8494 1
a8494 1
      assert (is_loop);
d8514 1
a8514 1
      assert (*max_diff >= opt_diff);
d8520 1
a8520 1
  assert (0);
d8584 1
a8584 1
      assert (unreported == lit_size);
d8722 1
a8722 1
  assert (fragP->fr_subtype == RELAX_FILL_NOP
d8878 2
a8879 2
      assert (opt_diff >= 0);
      assert (max_diff >= opt_diff);
d8937 1
a8937 1
	      assert (opt_diff <= UNREACHABLE_MAX_WIDTH);
d8959 1
a8959 1
	assert (stretch_amount <= 1);
d8963 1
a8963 1
	    assert (stretch_amount == 3 || stretch_amount == 0);
d8965 1
a8965 1
	    assert (stretch_amount <= 3);
d9019 1
a9019 1
  assert (desired_diff >= 0 && desired_diff < 8);
d9023 1
a9023 1
  assert (wide_nops > 0 || num_widens > 0);
d9097 1
a9097 1
	  assert (0);
d9109 1
a9109 1
	  assert (0);
d9135 1
a9135 1
	  assert (0);
d9139 1
a9139 1
  assert (0);
d9166 1
a9166 1
  assert (fragP->fr_opcode != NULL);
d9203 1
a9203 1
  assert (num_steps >= min_steps && num_steps <= RELAX_IMMED_MAXSTEPS);
d9232 1
a9232 1
	  assert (num_steps >= min_steps && num_steps <= RELAX_IMMED_MAXSTEPS);
d9249 3
a9251 3
  assert (num_text_bytes >= 0);
  assert (literal_diff >= 0);
  assert (total_text_diff >= 0);
d9255 2
a9256 2
  assert (fragP->tc_frag_data.text_expansion[slot] >= 0);
  assert (fragP->tc_frag_data.literal_expansion[slot] >= 0);
d9264 1
a9264 1
	  assert (literal_diff == 4);
d9269 1
a9269 1
	  assert (lit_fragP->fr_type == rs_machine_dependent
d9392 1
a9392 1
	  assert (fragp->tc_frag_data.unreported_expansion == 4);
d9445 1
a9445 1
  assert (slot == 0);
d9450 1
a9450 1
      assert (fragP->tc_frag_data.text_expansion[0] == 1
d9464 1
a9464 1
  assert (fragP->fr_opcode != NULL);
d9488 2
a9489 2
  assert (diff >= 0);
  assert (diff <= fragP->fr_var);
d9503 1
a9503 1
  assert ((unsigned) size == (fragP->fr_next->fr_address
d9541 1
a9541 1
  assert (fr_opcode != NULL);
d9570 1
a9570 1
	  assert (bytes == 2 || bytes == 3);
d9642 1
a9642 1
		  assert (unreach->fr_type == rs_machine_dependent
d9648 1
a9648 1
	      assert (gen_label == NULL);
d9684 3
a9686 3
	      assert (lit_frag != NULL);
	      assert (lit_sym != NULL);
	      assert (tinsn->ntok == 1);
d9689 1
a9689 1
	      assert (target_seg);
d9740 1
a9740 1
      assert (diff >= 0);
d9743 1
a9743 1
      assert (diff <= fragP->fr_var);
d9796 1
a9796 1
  assert (new_seg != 0);
d9850 1
a9850 1
  assert (xtensa_opcode_is_loop (isa, loop_insn.opcode) == 1);
d9854 1
a9854 1
  assert (tinsn->ntok == 2);
d9861 1
a9861 1
      assert (S_GET_SEGMENT (sym) == segP
d9887 1
a9887 1
  assert (addi_insn.opcode == xtensa_addi_opcode);
d9890 1
a9890 1
  assert (addmi_insn.opcode == xtensa_addmi_opcode);
d10043 1
a10043 1
      assert (literal_section);
d10088 1
a10088 1
	  assert (search_frag->fr_fix == 0
d10093 1
a10093 1
      assert (search_frag->tc_frag_data.literal_frag->fr_subtype
d10116 1
a10116 1
	      assert (literal_pool->fr_subtype == RELAX_LITERAL_POOL_BEGIN);
d10118 1
a10118 1
	      assert (frchain_to);
d10156 1
a10156 1
	  assert (frchain_from->fix_root == NULL);
d10209 1
a10209 1
      assert (literal_section);
d10244 1
a10244 1
  assert (new_count == old_count);
d10524 1
a10524 1
  assert (fragP != NULL);
d10606 1
a10606 1
		  assert (cur_block);
d10704 1
a10704 1
		  assert (cur_block);
d11116 1
a11116 1
  assert (xtensa_isa_num_formats (isa) < MAX_FORMATS);
d11222 1
a11222 1
  assert (!istack_empty (stack));
d11234 1
a11234 1
  assert (!istack_full (stack));
d11248 1
a11248 1
  assert (!istack_full (stack));
d11263 1
a11263 1
  assert (!istack_empty (stack));
d11286 1
a11286 1
  assert (insn->insn_type == ITYPE_INSN);
d11310 1
a11310 1
  assert (insn->insn_type == ITYPE_INSN);
d11354 1
a11354 1
  assert (insn->insn_type == ITYPE_INSN);
d11393 1
a11393 1
  assert (tinsn->insn_type == ITYPE_INSN);
d11618 1
a11618 1
      assert (opnum >= 0);
d11872 1
a11872 1
  assert (expr_is_const (s));
d11902 1
a11902 1
  assert (expr_is_register (s));
@


1.108
log
@2009-01-07  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.c (produce_flix): New.
	(option_flix, optoin_no_generate_flix, option_no_flix) Define.
	(md_longopts): Add support for them.
	(md_parse_option): Likewise.
	(md_show_usage): Add help message.
	(finish_vinsn): Don't allow multi-slot flix when produce_flix
	option is set to FLIX_NONE.
	* config/xtensa-relax.c (transition_applies): Only relax to
	flix branches when produce_flix equals FLIX_ALL.
	* config/xtensa-relax.h (flix_level, FLIX_ALL, FLIX_NO_GENERATE
	FLIX_NONE): New.
	(produce_flix): Declare.
@
text
@d2049 1
@


1.107
log
@2008-11-21  Sterling Augustine  <sterling@@tensilica.com>

        * xtensa-isa.c (xtensa_state_is_shared_or): New function.

2008-11-21  Sterling Augustine  <sterling@@tensilica.com>

        * xtensa-isa-internal.h (XTENSA_STATE_IS_SHARED_OR): New flag.
        * xtensa-isa.h (xtensa_state_is_shared_or): New prototype.

2008-11-21  Sterling Augustine  <sterling@@tensilica.com>

        * config/tc-xtensa.c (check_t1_t2_reads_and_writes): Call
        xtensa_state_is_shared_or to allow multiple opcodes within a
        single FLIX bundle to write to these special states.
@
text
@d594 1
d639 4
d701 4
d787 9
d962 5
d6206 8
@


1.106
log
@2008-11-04  Sterling Augustine  <sterling@@tensilica.com>
	* config/tc-xtensa.c (tinsn_check_arguments): Check for multiple
	writes to the same register.
@
text
@d6542 1
a6542 1
	  if (t1_so != t2_so)
@


1.105
log
@2008-11-04  Sterling Augustine  <sterling@@tensilica.com>
	* config/tc-xtensa.c (xtensa_j_opcode): New.
	(xg_instruction_matches_option_term): Handle "FREEREG" option.
	(xg_build_to_insn): Likewise.  Update renamed tls_reloc reference.
	(md_begin): Initialize xtensa_j_opcode.
	(md_assemble): Update renamed tls_reloc reference.  Handle "j.l".
	(xg_assemble_vliw_tokens): Save free_reg info in the frag.
	(tinsn_immed_from_frag): Get free_reg info back out of the frag.
	(vinsn_to_insnbuf): Update renamed tls_reloc references.
	Distinguish extra argument for "FREEREG" from extra TLS argument.
	* config/tc-xtensa.h (struct xtensa_frag_type): Add free_reg field.
	* config/xtensa-istack.h (struct tinsn_struct): Rename tls_reloc
	field to extra_arg.
	* config/xtensa-relax.c (widen_spec_list): Add rules to relax "j.l".
	(build_transition): Handle "FREEREG" operand.
	* config/xtensa-relax.h (enum op_type): Add OP_FREEREG.
2008-11-04  Bob Wilson  <bob.wilson@@acm.org>
	* gas/xtensa/all.exp: Run jlong test.
	* gas/xtensa/jlong.d: New.
	* gas/xtensa/jlong.s: New.
@
text
@d11460 6
d11484 48
@


1.104
log
@2008-09-12  Sterling Augustine  <sterling@@tensilica.com>
	* config/tc-xtensa.c (init_op_placement_info_table): Allow number of
	operands equal to MAX_INSN_ARGS.
@
text
@d574 1
d2734 1
a2734 3
   terms is given interpretation by this function.  This is needed when
   an option depends on the state of a directive, but there are no such
   options in use right now.  */
d2737 1
a2737 2
xg_instruction_matches_option_term (TInsn *insn ATTRIBUTE_UNUSED,
				    const ReqOrOption *option)
d2746 2
d3373 5
d3383 1
a3383 1
		copy_expr (&targ->tls_reloc, &insn->tok[op_data]);
d5111 1
d5384 1
a5384 1
	      expressionS *tok = &orig_insn.tls_reloc;
d5404 22
d7027 1
d11537 1
d11659 1
a11659 1
      expressionS *tls_reloc = &tinsn->tls_reloc;
d11666 1
a11666 1
      if (tls_reloc->X_op != O_illegal)
d11679 2
a11680 2
		     tls_reloc->X_add_symbol, tls_reloc->X_add_number,
		     FALSE, map_operator_to_reloc (tls_reloc->X_op, FALSE));
@


1.103
log
@2008-08-20  Bob Wilson  <bob.wilson@@acm.org>
bfd/
        * elf-bfd.h (elf_object_id): Add XTENSA_ELF_TDATA.
        * elf32-xtensa.c (elf_howto_table): Add TLS relocations.
        (elf_xtensa_reloc_type_lookup): Likewise.
        (TCB_SIZE): Define.
        (elf_xtensa_link_hash_entry): New.
        (GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE, GOT_TLS_ANY): Define.
        (elf_xtensa_hash_entry): Define.
        (elf_xtensa_obj_tdata): New.
        (elf_xtensa_tdata): Define.
        (elf_xtensa_local_got_tls_type): Define.
        (elf_xtensa_local_tlsfunc_refcounts): Define.
        (is_xtensa_elf): Define.
        (elf_xtensa_mkobject): New.
        (elf_xtensa_link_hash_table): Add tlsbase field.
        (elf_xtensa_link_hash_newfunc): New.
        (elf_xtensa_link_hash_table_create): Use elf_xtensa_link_hash_newfunc.
        Create an entry for "_TLS_MODULE_BASE_" and save it in tlsbase field.
        (elf_xtensa_copy_indirect_symbol): New.
        (elf_xtensa_check_relocs): Rewrite to handle TLS relocations.
        (elf_xtensa_gc_sweep_hook): Likewise.
        (elf_xtensa_allocate_dynrelocs): Optimize away GOT entries for
        TLSDESC_FN relocations when an IE reference is seen.
        (elf_xtensa_allocate_local_got_size): Likewise.
        (elf_xtensa_always_size_sections): New.
        (dtpoff_base, tpoff): New.
        (elf_xtensa_do_reloc): Handle TLS relocations.
        (replace_tls_insn): New.
        (IS_XTENSA_TLS_RELOC): Define.
        (elf_xtensa_relocate_section): Handle TLS relocations.
        (get_indirect_call_dest_reg): New.
        (bfd_elf32_mkobject): Define.
        (elf_backend_always_size_sections): New.
        (elf_backend_copy_indirect_symbol): New.
        * reloc.c (BFD_RELOC_XTENSA_TLSDESC_FN, BFD_RELOC_XTENSA_TLSDESC_ARG)
        (BFD_RELOC_XTENSA_TLS_DTPOFF, BFD_RELOC_XTENSA_TLS_TPOFF)
        (BFD_RELOC_XTENSA_TLS_FUNC, BFD_RELOC_XTENSA_TLS_ARG)
        (BFD_RELOC_XTENSA_TLS_CALL): New.
        * bfd-in2.h: Regenerate.
        * libbfd.h: Regenerate.
gas/
        * config/tc-xtensa.c (O_tlsfunc, O_tlsarg, O_tlscall): Define.
        (O_tpoff, O_dtpoff): Define.
        (suffix_relocs): Add entries for TLS suffixes.
        (xtensa_elf_cons): Check for invalid use of TLS relocations.
        (map_operator_to_reloc): Add is_literal parameter and use it to
        control translating TLS instruction relocations to the corresponding
        literal relocations.
        (xg_valid_literal_expression): Allow TLS operators.
        (xg_build_to_insn): Copy TLS operators from pseudo-instruction
        operands to generated literals.
        (xg_assemble_literal): Handle TLS operators.  Update call to
        map_operator_to_reloc.
        (md_assemble): Handle CALLXn.TLS pseudo-instruction.
        (md_apply_fix): Handle TLS relocations.
        (emit_single_op): Handle TLS operators.
        (convert_frag_immed): Update call to map_operator_to_reloc.
        (vinsn_to_insnbuf): Emit relocations for TLS-related instructions.
        * config/xtensa-istack.h (tinsn_struct): Add tls_reloc field.
        * config/xtensa-relax.c (append_literal_op): Add src_op parameter
        to initialize the op_data field of the BuildOp.
        (build_transition): Use it here to record the source operand
        corresponding to a generated literal.
        * config/xtensa-relax.h (build_op): Comment op_data use for literals.
include/elf/
        * xtensa.h (R_XTENSA_TLSDESC_FN, R_XTENSA_TLSDESC_ARG)
        (R_XTENSA_TLS_DTPOFF, R_XTENSA_TLS_TPOFF, R_XTENSA_TLS_FUNC)
        (R_XTENSA_TLS_ARG, R_XTENSA_TLS_CALL): New.
ld/testsuite/
        * ld-xtensa/tlsbin.dd, ld-xtensa/tlsbin.rd, ld-xtensa/tlsbin.s,
        ld-xtensa/tlsbin.sd, ld-xtensa/tlsbin.td, ld-xtensa/tlslib.s,
        ld-xtensa/tlspic.dd, ld-xtensa/tlspic.rd, ld-xtensa/tlspic.sd,
        ld-xtensa/tlspic.td, ld-xtensa/tlspic1.s, ld-xtensa/tlspic2.s: New.
        * ld-xtensa/xtensa.exp: Run them.
@
text
@d11061 1
a11061 1
      if (xtensa_opcode_num_operands (isa, opcode) >= MAX_INSN_ARGS)
@


1.102
log
@2008-08-08  Sterling Augustine  <sterling@@tensilica.com>
	* config/tc-xtensa.c (exclude_section_from_property_tables): New.
	(xtensa_create_property_segments): Use it.
	(xtensa_create_xproperty_segments): Likewise.
@
text
@d359 5
d381 5
d1566 4
d1682 1
a1682 1
map_operator_to_reloc (unsigned char operator)
d1696 8
d3174 4
d3376 3
d4094 4
d4100 1
a4100 1
      reloc = map_operator_to_reloc (emit_val->X_op);
d5346 51
a5397 1
  orig_insn.opcode = xtensa_opcode_lookup (isa, opname);
d5812 9
d5861 3
d6761 5
a6765 1
	  || orig_insn->tok[1].X_op == O_pltrel)
d9629 1
a9629 1
	      reloc_type = map_operator_to_reloc (tinsn->tok[0].X_op);
d11629 1
d11636 16
@


1.101
log
@bfd/
        * elf32-xtensa.c (xtensa_property_section_name): New.
        (xtensa_make_property_section): New.
        (xtensa_get_property_section): Make static.  Do not create a new
        section if it does not exist.
gas/
        * config/tc-xtensa.c (xtensa_create_property_segments): Use
        xtensa_make_property_section instead of xtensa_get_property_section.
        (xtensa_create_xproperty_segments): Likewise.
@
text
@d10323 1
a10386 1
      flagword flags;
d10388 1
a10388 4
      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
a10484 1
      flagword flags;
d10486 1
a10486 4
      flags = bfd_get_section_flags (stdoutput, sec);
      if ((flags & SEC_DEBUGGING)
	  || !(flags & SEC_ALLOC)
	  || (flags & SEC_MERGE))
d10570 21
@


1.100
log
@2008-04-04  Adrian Bunk  <bunk@@stusta.de>
	    Bob Wilson  <bob.wilson@@acm.org>

	* config/tc-xtensa.c (xg_apply_fix_value): Check return code from
	call to decode_reloc.
@
text
@d495 1
a495 1
extern asection *xtensa_get_property_section (asection *, const char *);
d10398 1
a10398 1
	  segT prop_sec = xtensa_get_property_section (sec, section_name_base);
d10500 1
a10500 1
	  segT prop_sec = xtensa_get_property_section (sec, section_name_base);
@


1.99
log
@bfd/
	* xtensa-isa.c (xtensa_isa_num_pipe_stages): Make max_stage static and
	only compute its value once.
gas/
	* config/tc-xtensa.c (xtensa_num_pipe_stages): New.
	(md_begin): Initialize it.
	(resources_conflict): Use it.
@
text
@d4972 2
a4973 2
  (void) decode_reloc (fixP->fx_r_type, &slot, &alt_reloc);
  if (alt_reloc)
@


1.98
log
@2008-02-05  Sterling Augustine  <sterling@@tensilica.com>
	* config/tc-xtensa.c (relax_frag_immed): Change internal consistency
	checks into assertions.  When relaxation produces an operation that
	does not fit in the current FLIX instruction, make sure that the
	operation is relaxed as needed to account for being placed following
	the current instruction.
@
text
@d82 1
d5088 2
d6012 1
a6012 1
	(isa, xtensa_isa_num_pipe_stages (isa),
@


1.97
log
@	* config/tc-xtensa.c (xtensa_leb128): New function.
	(md_pseudo_table): Use it for sleb128 and uleb128.
	(is_leb128_expr): New internal flag.
	(xtensa_symbol_new_hook): Check new flag.
@
text
@a8999 1
  fragS *lit_fragP;
d9001 1
a9001 1
  int literal_diff, total_text_diff, this_text_diff, first;
d9040 1
a9040 11
  if (num_steps < min_steps)
    {
      as_fatal (_("internal error: relaxation failed"));
      return 0;
    }

  if (num_steps > RELAX_IMMED_MAXSTEPS)
    {
      as_fatal (_("internal error: relaxation requires too many steps"));
      return 0;
    }
a9044 1
  lit_fragP = 0;
d9046 2
a9047 6
  literal_diff =
    num_literal_bytes - fragP->tc_frag_data.literal_expansion[slot];
  first = 0;
  while (istack.insn[first].opcode == XTENSA_UNDEFINED)
    first++;

d9052 4
d9059 21
d9098 1
a9098 1
      lit_fragP = fragP->tc_frag_data.literal_frags[slot];
@


1.96
log
@	* config/tc-xtensa.c (xtensa_elf_cons): Set frag flags for
	expressions without suffixes.
	(get_frag_property_flags): Preserve is_no_transform flag for frags
	not marked as either instructions or literals.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d445 1
d1008 2
d1575 10
d5651 1
a5651 1
  if (S_GET_SEGMENT (sym) == expr_section)
d7272 5
a7276 4
/* Some difference-of-symbols expressions make it out to the linker.  Some 
   don't.  If one does, then the linker can optimize between the two labels.
   If it doesn't, then the linker shouldn't.  */

@


1.95
log
@gas/
	* config/tc-xtensa.c (xg_symbolic_immeds_fit): Relax for weak
	references but not weak definitions.
gas/testsuite/
	* gas/xtensa/all.exp: Run new weak-call test.
	* gas/xtensa/weak-call.d: New.
	* gas/xtensa/weak-call.s: New.
@
text
@d1561 4
a1564 1
	emit_expr (&exp, (unsigned int) nbytes);
d10676 5
a10680 1
    prop_flags->is_no_transform = TRUE;
@


1.94
log
@        * config/tc-xtensa.c (xg_symbolic_immeds_fit): Do not relax calls to            weak symbols if longcalls are disabled.
@
text
@d3244 5
a3248 1
		 assume it will be in range.  */
d3250 3
a3252 1
		  && ! pc_frag->tc_frag_data.use_longcalls)
@


1.93
log
@	* config/tc-xtensa.c (frag_format_size): Handle frags that expand to
	wide branches.
	(get_aligned_diff): For RELAX_ALIGN_NEXT_OPCODE, skip to the next
	non-empty frag to find the LOOP instruction.  Change comma typo to
	a semicolon.
	(relax_frag_immed, convert_frag_immed): Rename wide_insn variable to
	from_widen_insn.
@
text
@d3238 10
a3247 3
	  /* If it is a weak symbol, then assume it won't reach.  */
	  if (S_IS_WEAK (expr->X_add_symbol))
	    return FALSE;
d3249 1
a3249 7
	  if (is_direct_call_opcode (insn->opcode)
	      && ! pc_frag->tc_frag_data.use_longcalls)
	    {
	      /* If callee is undefined or in a different segment, be
		 optimistic and assume it will be in range.  */
	      if (S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
		return TRUE;
a3251 5
	  /* Only references within a segment can be known to fit in the
	     operands at assembly time.  */
	  if (S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
	    return FALSE;

@


1.92
log
@2007-12-07  Bob Wilson  <bob.wilson@@acm.org>

include/elf/
	* xtensa.h (R_XTENSA_32_PCREL): New.

bfd/
	* elf32-xtensa.c (elf_howto_table): Add R_XTENSA_32_PCREL.
	(elf_xtensa_reloc_type_lookup): Handle BFD_RELOC_32_PCREL.
	(elf_xtensa_check_relocs): Use default case for all relocations that
	need nothing done here.
	(elf_xtensa_do_reloc): Compute self_address for all relocation types.
	Handle R_XTENSA_32_PCREL.
	(elf_xtensa_relocate_section): Check for R_XTENSA_32_PCREL for dynamic
	symbols.
	(check_section_ebb_pcrels_fit): Ignore R_XTENSA_32_PCREL relocations.

gas/
	* config/tc-xtensa.c (O_pcrel): Define.
	(suffix_relocs): Add pcrel suffix.
	(md_pseudo_table): Add 4byte and 2byte directives.
	(xtensa_elf_cons): Pass correct pcrel argument to fix_new_exp.
	(xg_assemble_literal): Likewise.  Check for O_pcrel.
	(expression_maybe_register): Reorganize.  Handle BFD_RELOC_32_PCREL.
	(xg_valid_literal_expression): Allow O_pcrel.
	(md_pcrel_from, md_apply_fix): Handle BFD_RELOC_32_PCREL.
	(tc_gen_reloc): Fix punctuation in error message.

gas/testsuite/
	* gas/xtensa/all.exp: Run new pcrel test.
	* gas/xtensa/err-pcrel.s: New.
	* gas/xtensa/pcrel.d: New.
	* gas/xtensa/pcrel.s: New.
	* gas/xtensa/xtensa-err.exp: New.
@
text
@d4427 20
a4446 1
    return 3;
d8281 1
d8304 6
a8309 1
      target_size = get_loop_align_size (next_frag_format_size (fragP));
d8316 1
a8316 2
      if (next_non_empty_frag(fragP)->tc_frag_data.slot_subtypes[0]
	  != RELAX_IMMED)
d8325 1
a8325 1
      align_power = get_text_align_power (target_size),
d8976 1
a8976 1
  bfd_boolean wide_insn = FALSE;
d8990 1
a8990 1
    wide_insn = TRUE;
d9044 1
d9046 2
a9047 1
  if (wide_insn)
d9053 1
d9346 1
a9346 1
  bfd_boolean wide_insn = FALSE;
d9356 1
a9356 1
    wide_insn = TRUE;
d9464 1
a9464 1
	      if (first && wide_insn)
d9510 1
a9510 1
	      if (wide_insn && first)
@


1.91
log
@        * config/tc-xtensa.c (xg_force_frag_space): Delete.
        (xg_finish_frag, xg_assemble_literal_space): Replace calls to it.
        (xtensa_create_property_segments, xtensa_create_xproperty_segments):
        Set output_section for new property sections.  Use subseg_set and
        seg_info instead of retrieve_segment_info.  Adjust arguments to
        add_xt_block_frags and add_xt_prop_frags.  Use standard functions
        to create frags and fix records.
        (retrieve_segment_info): Delete.
        (add_xt_block_frags, add_xt_prop_frags): Replace calls to
        retrieve_segment_info.  Remove unused xt_block_sec arguments.
@
text
@d357 1
d374 1
d1004 1
d1006 1
d1557 1
a1557 1
			   nbytes, &exp, 0, reloc);
d1775 1
a1775 1
	  if (reloc == BFD_RELOC_UNUSED)
d1777 2
a1778 7
	      as_bad (_("unsupported relocation"));
	      return;
	    }

	  if (tok->X_op == O_constant)
	    {
	      switch (reloc)
a1779 1
		case BFD_RELOC_LO16:
d1782 5
a1786 2

		case BFD_RELOC_HI16:
a1788 3

		default:
		  break;
d1790 9
d3134 1
d4003 1
d4042 3
d4054 1
a4054 1
		   litsize, emit_val, 0, reloc);
d5445 3
a5621 1

d5637 1
d5804 1
a5804 1
    as_fatal (_("internal error? cannot generate `%s' relocation"),
@


1.90
log
@	* config/xtensa-istack.h (tinsn_struct): Replace linenum field
	with loc_directive_seen and debug_line.
	* config/tc-xtensa.c: Include xtensa-istack.h after dwarf2dbg.h.
	(xg_build_to_insn): Copy the new fields instead of linenum.
	(xg_build_token_insn): Likewise.  Abort on INSTR_LABEL_DEF and move
	common code out of the switch.
	(md_assemble): Set new tinsn fields from DWARF information.  Call
	dwarf2_consume_line_info.
	(xg_assemble_vliw_tokens): Update the code to select the "best" line
	number to use new information.  Call dwarf2_gen_line_info instead
	of dwarf2_emit_insn.
@
text
@a3603 10
xg_force_frag_space (int size)
{
  /* This may have the side effect of creating a new fragment for the
     space to go into.  I just do not like the name of the "frag"
     functions.  */
  frag_grow (size);
}


static void
d3617 1
a3617 2
  xg_force_frag_space (max_growth);

d4078 1
a4078 1
  xg_force_frag_space (size);
a10249 1
static segment_info_type *retrieve_segment_info (segT);
d10253 1
a10253 1
  (segT, segT, xtensa_block_info **, frag_predicate, frag_predicate);
d10258 1
a10258 2
static void add_xt_prop_frags
  (segT, segT, xtensa_block_info **, frag_flags_fn);
d10323 9
a10331 5
	  segT insn_sec = 
	    xtensa_get_property_section (sec, section_name_base);
	  segment_info_type *xt_seg_info = retrieve_segment_info (insn_sec);
	  xtensa_block_info **xt_blocks =
	    &xt_seg_info->tc_segment_info_data.blocks[sec_type];
d10333 1
a10333 1
	  add_xt_block_frags (sec, insn_sec, xt_blocks, property_function,
a10353 1
	  /* This is a section with some data.  */
a10362 5
	  /* In order to make this work with the assembler, we have to
	     build some frags and then build the "fixups" for it.  It
	     would be easier to just set the contents then set the
	     arlents.  */

d10365 1
a10365 5
	      /* Allocate a fragment and leak it.  */
	      fragS *fragP;
	      bfd_size_type frag_size;
	      fixS *fixes;
	      frchainS *frchainP;
a10366 19
	      char *frag_data;

	      frag_size = sizeof (fragS) + rec_size;
	      fragP = (fragS *) xmalloc (frag_size);

	      memset (fragP, 0, frag_size);
	      fragP->fr_address = 0;
	      fragP->fr_next = NULL;
	      fragP->fr_fix = rec_size;
	      fragP->fr_var = 0;
	      fragP->fr_type = rs_fill;
	      /* The rest are zeros.  */

	      frchainP = seginfo->frchainP;
	      frchainP->frch_root = fragP;
	      frchainP->frch_last = fragP;

	      fixes = (fixS *) xmalloc (sizeof (fixS) * num_recs);
	      memset (fixes, 0, sizeof (fixS) * num_recs);
d10368 2
a10369 2
	      seginfo->fix_root = fixes;
	      seginfo->fix_tail = &fixes[num_recs - 1];
a10370 1
	      frag_data = &fragP->fr_literal[0];
d10373 1
a10373 2
		  fixS *fix = &fixes[i];
		  assert (cur_block);
d10376 6
a10381 12
		  if (i != num_recs - 1)
		    fix->fx_next = &fixes[i + 1];
		  else
		    fix->fx_next = NULL;
		  fix->fx_size = 4;
		  fix->fx_done = 0;
		  fix->fx_frag = fragP;
		  fix->fx_where = i * 8;
		  fix->fx_addsy = section_symbol (cur_block->sec);
		  fix->fx_offset = cur_block->offset;
		  fix->fx_r_type = BFD_RELOC_32;
		  fix->fx_file = "Internal Assembly";
d10385 1
a10385 1
		  md_number_to_chars (&frag_data[4 + 8 * i],
d10389 3
d10425 9
a10433 5
	  segT insn_sec =
	    xtensa_get_property_section (sec, section_name_base);
	  segment_info_type *xt_seg_info = retrieve_segment_info (insn_sec);
	  xtensa_block_info **xt_blocks =
	    &xt_seg_info->tc_segment_info_data.blocks[sec_type];
d10435 1
a10435 1
	  add_xt_prop_frags (sec, insn_sec, xt_blocks, flag_fn);
a10454 1
	  /* This is a section with some data.  */
a10462 1

a10464 4
	  /* In order to make this work with the assembler, we have to build
	     some frags then build the "fixups" for it.  It would be easier to
	     just set the contents then set the arlents.  */

d10467 1
a10467 5
	      /* Allocate a fragment and (unfortunately) leak it.  */
	      fragS *fragP;
	      bfd_size_type frag_size;
	      fixS *fixes;
	      frchainS *frchainP;
a10468 4
	      char *frag_data;

	      frag_size = sizeof (fragS) + rec_size;
	      fragP = (fragS *) xmalloc (frag_size);
d10470 2
a10471 17
	      memset (fragP, 0, frag_size);
	      fragP->fr_address = 0;
	      fragP->fr_next = NULL;
	      fragP->fr_fix = rec_size;
	      fragP->fr_var = 0;
	      fragP->fr_type = rs_fill;
	      /* The rest are zeros.  */

	      frchainP = seginfo->frchainP;
	      frchainP->frch_root = fragP;
	      frchainP->frch_last = fragP;

	      fixes = (fixS *) xmalloc (sizeof (fixS) * num_recs);
	      memset (fixes, 0, sizeof (fixS) * num_recs);

	      seginfo->fix_root = fixes;
	      seginfo->fix_tail = &fixes[num_recs - 1];
a10472 1
	      frag_data = &fragP->fr_literal[0];
d10475 1
a10475 2
		  fixS *fix = &fixes[i];
		  assert (cur_block);
d10478 6
a10483 12
		  if (i != num_recs - 1)
		    fix->fx_next = &fixes[i + 1];
		  else
		    fix->fx_next = NULL;
		  fix->fx_size = 4;
		  fix->fx_done = 0;
		  fix->fx_frag = fragP;
		  fix->fx_where = i * (8 + 4);
		  fix->fx_addsy = section_symbol (cur_block->sec);
		  fix->fx_offset = cur_block->offset;
		  fix->fx_r_type = BFD_RELOC_32;
		  fix->fx_file = "Internal Assembly";
d10487 1
a10487 1
		  md_number_to_chars (&frag_data[4 + (8+4) * i],
d10489 1
a10489 1
		  md_number_to_chars (&frag_data[8 + (8+4) * i],
d10494 3
a10502 37
static segment_info_type *
retrieve_segment_info (segT seg)
{
  segment_info_type *seginfo;
  seginfo = (segment_info_type *) bfd_get_section_userdata (stdoutput, seg);
  if (!seginfo)
    {
      frchainS *frchainP;

      seginfo = (segment_info_type *) xmalloc (sizeof (*seginfo));
      memset ((void *) seginfo, 0, sizeof (*seginfo));
      seginfo->fix_root = NULL;
      seginfo->fix_tail = NULL;
      seginfo->bfd_section = seg;
      seginfo->sym = 0;
      /* We will not be dealing with these, only our special ones.  */
      bfd_set_section_userdata (stdoutput, seg, (void *) seginfo);

      frchainP = (frchainS *) xmalloc (sizeof (frchainS));
      frchainP->frch_root = NULL;
      frchainP->frch_last = NULL;
      frchainP->frch_next = NULL;
      frchainP->frch_subseg = 0;
      frchainP->fix_root = NULL;
      frchainP->fix_tail = NULL;
      /* Do not init the objstack.  */
      /* obstack_begin (&frchainP->frch_obstack, chunksize); */
      /* frchainP->frch_frag_now = fragP; */
      frchainP->frch_frag_now = NULL;

      seginfo->frchainP = frchainP;
    }

  return seginfo;
}


a10545 1
		    segT xt_block_sec,
a10549 2
  segment_info_type *seg_info;
  segment_info_type *xt_seg_info;
a10552 3
  xt_seg_info = retrieve_segment_info (xt_block_sec);
  seg_info = retrieve_segment_info (sec);

d10561 1
a10561 1
  if (seg_info->frchainP)
d10563 1
a10563 1
      for (fragP = seg_info->frchainP->frch_root;
a10799 1
		   segT xt_block_sec,
a10802 2
  segment_info_type *seg_info;
  segment_info_type *xt_seg_info;
a10805 2
  xt_seg_info = retrieve_segment_info (xt_block_sec);
  seg_info = retrieve_segment_info (sec);
d10816 1
a10816 1
  if (seg_info->frchainP)
d10818 1
a10818 1
      for (fragP = seg_info->frchainP->frch_root; fragP;
@


1.89
log
@        * config/tc-xtensa.c (relaxable_section): Check for .eh_frame.
@
text
@d28 1
a29 1
#include "dwarf2dbg.h"
d3291 2
a3292 1
  targ->linenum = insn->linenum;
a3769 2
      new_insn->is_specific_opcode = FALSE;
      new_insn->linenum = old_insn->linenum;
a3773 2
      new_insn->is_specific_opcode = FALSE;
      new_insn->linenum = old_insn->linenum;
d3776 1
a3776 2
      as_bad (_("INSTR_LABEL_DEF not supported yet"));
      break;
d3778 3
d5237 1
a5237 1
  char *opname, *file_name;
d5326 6
a5331 5
  /* A FLIX bundle may be spread across multiple input lines.  We want to
     report the first such line in the debug information.  Record the line
     number for each TInsn (assume the file name doesn't change), so the
     first line can be found later.  */
  as_where (&file_name, &orig_insn.linenum);
a6693 1
  int i;
d6698 3
a6700 2
  unsigned current_line, best_linenum;
  char *current_file;
d6702 1
a6702 1
  best_linenum = UINT_MAX;
d6757 1
a6757 1
  for (i = 0; i < vinsn->num_slots; i++)
d6759 2
d6762 1
a6762 1
      if (xtensa_opcode_is_loop (isa, vinsn->slots[i].opcode) == 1)
d6765 8
a6772 3
      /* Also determine the best line number for debug info.  */
      best_linenum = vinsn->slots[i].linenum < best_linenum
	? vinsn->slots[i].linenum : best_linenum;
d6843 3
a6845 6
  /* Temporarily set the logical line number to the one we want to appear
     in the debug information.  */
  as_where (&current_file, &current_line);
  new_logical_line (current_file, best_linenum);
  dwarf2_emit_insn (insn_size + extra_space);
  new_logical_line (current_file, current_line);
d6849 1
a6849 1
      TInsn *tinsn = &vinsn->slots[slot];
@


1.88
log
@	* config/tc-xtensa.c (xtensa_symbol_new_hook): New.
	(xtensa_mark_difference_of_two_symbols): New.
	(xtensa_post_relax_hook): Call xtensa_mark_difference_of_two_symbols.
	* config/tc-xtensa.h (xtensa_symfield_type): Add next_expr_symbol.
	(tc_symbol_new_hook): Define.
@
text
@d4731 2
a4732 1
  return (sec->flags & SEC_DEBUGGING) == 0;
@


1.87
log
@Remove duplicate definitions of the md_atof() function
@
text
@d5602 16
d6962 1
d7226 49
d10277 1
@


1.86
log
@        * config/tc-xtensa.c (xtensa_extui_opcode): New.
        (xg_expand_assembly_insn): Check for invalid extui operands.
        (md_begin): Initialize xtensa_extui_opcode.
@
text
@d5741 1
a5741 37
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return "bad call to md_atof";
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      int idx = i;
      if (target_big_endian)
	idx = (prec - 1 - i);

      md_number_to_chars (litP, (valueT) words[idx], 2);
      litP += 2;
    }

  return NULL;
@


1.85
log
@Switch to GPLv3
@
text
@d556 1
d3892 14
d5030 1
@


1.84
log
@	* config/tc-xtensa.c (xg_assembly_relax): Comment termination rules.
	(frag_format_size): Handle RELAX_IMMED_STEP3.
	(xtensa_relax_frag, md_convert_frag): Likewise.
	* config/tc-xtensa.h (xtensa_relax_statesE): Add RELAX_IMMED_STEP3.
	(RELAX_IMMED_MAXSTEPS): Adjust.
	* config/xtensa-relax.c (widen_spec_list): Add transitions from
	wide branches to branch-over-jumps.
	(build_transition): Handle wide branches in transition patterns.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.83
log
@	* config/tc-xtensa.h (struct xtensa_frag_type): Update comment about
	use of literal_frag field.
	* config/tc-xtensa.c (xtensa_mark_literal_pool_location): Record frag
	in the literal_frag field.
	(xtensa_move_literals): Use it here instead of searching.  Update
	literal_frag field with new value.
@
text
@d3501 27
a3527 1
   Return the number of steps taken.  */
d3540 3
a3542 6
  /* assert (has no symbolic operands)
     Some of its immeds don't fit.
     Try to build a relaxed version.
     This may go through a couple of stages
     of single instruction transformations before
     we get there.  */
d4410 2
a4411 1
      || fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED_STEP2)
d8351 1
d9069 1
@


1.82
log
@bfd/
        * elf32-xtensa.c (extend_ebb_bounds_forward): Use renamed
        XTENSA_PROP_NO_TRANSFORM flag instead of XTENSA_PROP_INSN_NO_TRANSFORM.
        (extend_ebb_bounds_backward, compute_text_actions): Likewise.
        (compute_ebb_proposed_actions, coalesce_shared_literal): Likewise.
        (xtensa_get_property_predef_flags): Likewise.
        (compute_removed_literals): Pass new arguments to is_removable_literal.
        (is_removable_literal): Add sec, prop_table and ptblsize arguments.
        Do not remove literal if the NO_TRANSFORM property flag is set.
gas/
        * config/tc-xtensa.c (XTENSA_PROP_INSN_NO_TRANSFORM): Renamed to...
        (XTENSA_PROP_NO_TRANSFORM): ...this.
        (frag_flags_struct): Move is_no_transform out of the insn sub-struct.
        (xtensa_mark_frags_for_org): New.
        (xtensa_handle_align): Set RELAX_ORG frag subtype for rs_org.
        (xtensa_post_relax_hook): Call xtensa_mark_frags_for_org.
        (get_frag_property_flags): Adjust reference to is_no_transform flag.
        (xtensa_frag_flags_combinable): Likewise.
        (frag_flags_to_number): Likewise.  Use XTENSA_PROP_NO_TRANSFORM.
        * config/tc-xtensa.h (xtensa_relax_statesE): Add RELAX_ORG.
include/elf/
        * xtensa.h (XTENSA_PROP_INSN_NO_TRANSFORM): Renamed to...
        (XTENSA_PROP_NO_TRANSFORM): ...this.
ld/
        * emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use renamed
        XTENSA_PROP_NO_TRANSFORM flag instead of XTENSA_PROP_INSN_NO_TRANSFORM.
@
text
@d4551 1
d9821 1
a9821 5
	  insert_after = literal_pool;

	  while (insert_after->fr_next->fr_subtype != RELAX_LITERAL_POOL_END)
	    insert_after = insert_after->fr_next;

d9828 1
@


1.81
log
@	* config/atof-vax.c (atof_vax_sizeof): Change return type to unsigned.
	(md_atof): Make number_of_chars unsigned.  Revert last change.
	* config/tc-or32.c (md_apply_fix): Delete bogus assertions.
	* config/tc-sh.c (sh_optimize_expr): Only define for OBJ_ELF.
	* config/tc-sh.h (md_optimize_expr): Likewise.
	* config/tc-sh64.c (shmedia_md_pcrel_from_section): Delete bogus
	assertion.
	* config/tc-xtensa.c (convert_frag_immed_finish_loop): Likewise.
@
text
@d190 3
a192 1
#define XTENSA_PROP_INSN_NO_TRANSFORM	0x00000100
d268 3
a278 2
    /* is_specific_opcode implies no_transform.  */
    unsigned is_no_transform : 1;
d4696 49
d5353 3
d10206 1
d10667 3
a10678 3
      if (fragP->tc_frag_data.is_specific_opcode
	  || fragP->tc_frag_data.is_no_transform)
	prop_flags->insn.is_no_transform = TRUE;
d10716 2
a10717 2
  if (prop_flags->insn.is_no_transform)
    num |= XTENSA_PROP_INSN_NO_TRANSFORM;
d10756 2
a10757 2
      if (prop_flags_1->insn.is_no_transform !=
	  prop_flags_2->insn.is_no_transform)
@


1.80
log
@	* config/tc-xtensa.c (xtensa_flush_pending_output): Check
	outputting_stabs_line_debug.
@
text
@a9515 5
  know (symbolP);
  know (symbolP->sy_frag);
  know (!(S_GET_SEGMENT (symbolP) == absolute_section)
	|| symbol_get_frag (symbolP) == &zero_address_frag);

@


1.79
log
@	* config/tc-xtensa.c (xtensa_move_labels): Remove loops_ok argument.
	Do not check is_loop_target flag.
	(xtensa_frob_label): Adjust calls to xtensa_move_labels.
	(xg_assemble_vliw_tokens): Likewise.  Also avoid calling
	xtensa_move_labels for alignment of loop opcodes.
@
text
@d5096 9
@


1.78
log
@	* config/tc-xtensa.c (xg_translate_idioms): Allow assembly idioms
	in FLIX instructions.
@
text
@a961 24
/* The "loops_ok" argument is provided to allow ignoring labels that
   define loop ends.  This fixes a bug where the NOPs to align a
   loop opcode were included in a previous zero-cost loop:

   loop a0, loopend
     <loop1 body>
   loopend:

   loop a2, loopend2
     <loop2 body>

   would become:

   loop a0, loopend
     <loop1 body>
     nop.n <===== bad!
   loopend:

   loop a2, loopend2
     <loop2 body>

   This argument is used to prevent moving the NOP to before the
   loop-end label, which is what you want in this special case.  */

d963 1
a963 1
xtensa_move_labels (fragS *new_frag, valueT new_offset, bfd_boolean loops_ok)
d970 2
a971 5
      if (loops_ok || ! symbol_get_tc (lit_sym)->is_loop_target)
	{
	  S_SET_VALUE (lit_sym, new_offset);
	  symbol_set_frag (lit_sym, new_frag);
	}
d5011 1
a5011 1
      xtensa_move_labels (frag_now, 0, TRUE);
d5027 1
a5027 1
      xtensa_move_labels (frag_now, 0, TRUE);
a6709 2

      xtensa_move_labels (frag_now, 0, FALSE);
d6716 1
a6716 1
      xtensa_move_labels (frag_now, 0, TRUE);
@


1.77
log
@	* config/tc-xtensa.c (xg_build_to_insn): Use tinsn_init.
	(xg_expand_assembly_insn, istack_push_space, istack_pop): Likewise.
@
text
@a2339 3
  if (cur_vinsn.inside_bundle)
    return 0;

d2382 5
a2386 1
  if (xtensa_nop_opcode == XTENSA_UNDEFINED
@


1.76
log
@	* config/tc-xtensa.c (SUFFIX_MAP, suffix_relocs): New.
	(xtensa_elf_suffix): Use suffix_relocs instead of local mapping table.
	(map_suffix_reloc_to_operator): New.
	(map_operator_to_reloc): New.
	(expression_maybe_register): Fix incorrect test of return value from
	xtensa_elf_suffix.  Rearrange to use map_suffix_reloc_to_operator.
	(xg_assemble_literal, convert_frag_immed): Use map_operator_to_reloc.
@
text
@d3312 1
a3312 1
  memset (targ, 0, sizeof (TInsn));
d3861 1
a3861 1
  memset (&new_insn, 0, sizeof (TInsn));
d11012 1
a11012 1
  memset (insn, 0, sizeof (TInsn));
d11027 1
a11027 1
  memset (&stack->insn[rec], 0, sizeof (TInsn));
@


1.75
log
@	* config/xtensa-istack.h (struct tinsn_struct): Delete fixup field.
	(tinsn_get_tok): Delete prototype.
	* config/tc-xtensa.c (tinsn_get_tok): Delete.
@
text
@d355 18
a1594 7
  struct map_bfd
  {
    char *string;
    int length;
    bfd_reloc_code_real_type reloc;
  };

d1600 1
a1600 11
  struct map_bfd *ptr;

#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }

  static struct map_bfd mapping[] =
  {
    MAP ("l",		BFD_RELOC_LO16),
    MAP ("h",		BFD_RELOC_HI16),
    MAP ("plt",		BFD_RELOC_XTENSA_PLT),
    { (char *) 0, 0,	BFD_RELOC_UNUSED }
  };
d1617 2
a1618 2
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
d1620 1
a1620 1
	&& memcmp (ident, ptr->string, ptr->length) == 0)
d1648 43
d1791 2
a1792 2
	  && (reloc = xtensa_elf_suffix (&input_line_pointer, tok))
	  && (reloc != BFD_RELOC_NONE))
d1794 1
a1794 1
	  switch (reloc)
d1796 3
a1798 4
	      default:
	      case BFD_RELOC_UNUSED:
		as_bad (_("unsupported relocation"));
	        break;
d1800 5
a1804 6
	      case BFD_RELOC_XTENSA_PLT:
		tok->X_op = O_pltrel;
		break;

	      case BFD_RELOC_LO16:
		if (tok->X_op == O_constant)
d1806 1
a1806 3
		else
		  tok->X_op = O_lo16;
		break;
d1808 1
a1808 2
	      case BFD_RELOC_HI16:
		if (tok->X_op == O_constant)
d1810 5
a1814 3
		else
		  tok->X_op = O_hi16;
		break;
d1816 1
d3991 2
d4028 1
a4028 1
  if (emit_val->X_op == O_pltrel)
d4030 2
a4031 1
      char *p = frag_more (litsize);
d4033 1
d4039 6
a4044 1
		   litsize, emit_val, 0, BFD_RELOC_XTENSA_PLT);
a4045 2
  else
    emit_expr (emit_val, litsize);
d9354 1
a9354 4
	      if (tinsn->tok[0].X_op == O_pltrel)
		reloc_type = BFD_RELOC_XTENSA_PLT;
	      else
		reloc_type = BFD_RELOC_32;
@


1.74
log
@	* config/tc-xtensa.c (xg_add_opcode_fix, md_apply_fix): Delete use of
	fx_tcbit.
	* config/tc-xtensa.h (TC_FORCE_RELOCATION_LOCAL): Remove.
@
text
@a10993 11
/* Get the ``num''th token of the TInsn.
   It is illegal to call this if num > insn->ntoks.  */

expressionS *
tinsn_get_tok (TInsn *insn, int num)
{
  assert (num < insn->ntok);
  return &insn->tok[num];
}


@


1.73
log
@	* write.h (struct fix <fx_pcrel_adjust, fx_size>): Move.
	(struct fix <fx_plt>): Rename to tcbit2.
	* write.c (fix_new_internal): Adjust.
	(TC_FORCE_RELOCATION_LOCAL): Don't test fx_plt.
	* config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-cris.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-i960.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sh.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sparc.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-msp430.c (msp430_force_relocation_local): Likewise.
	* config/tc-ia64.c (emit_one_bundle): Don't set fx_plt.
	* config/tc-ia64.h (TC_FORCE_RELOCATION_LOCAL): Don't test fx_plt.
	Instead, compare fx_r_type.
	* config/tc-xtensa.c (xg_add_opcode_fix, md_apply_fix): Use
	fx_tcbit in place of fx_plt.
	* config/tc-xtensa.h (TC_FORCE_RELOCATION_LOCAL): Define.
	* doc/internals.texi (TC_FORCE_RELOCATION_LOCAL): Remove reference
	to fx_plt.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
a4116 6

  if (expr->X_add_symbol
      && (S_IS_EXTERNAL (expr->X_add_symbol)
	  || S_IS_WEAK (expr->X_add_symbol)))
    the_fix->fx_tcbit = TRUE;

a5563 1
	      && !fixP->fx_tcbit
@


1.72
log
@	* config/tc-xtensa.c (xtensa_sanity_check): Check for RELAX_IMMED
	as the first slot_subtype, not the frag subtype.
@
text
@d4121 1
a4121 1
    the_fix->fx_plt = TRUE;
d5569 2
a5570 1
	  if (S_GET_SEGMENT (fixP->fx_addsy) == seg && !fixP->fx_plt
@


1.71
log
@bfd/
	* elf32-xtensa.c (elf_xtensa_special_sections): Add .xtensa.info.
gas/
	* config/tc-xtensa.c (XSHAL_ABI): Add default definition.
	(directive_state): Disable scheduling by default.
	(xtensa_add_config_info): New.
	(xtensa_end): Call xtensa_add_config_info.
gas/testsuite/
	* gas/elf/section2.e-xtensa: New file.
	* gas/elf/elf.exp: Use it.
include/
	* xtensa-config.h (XSHAL_ABI): New.
	(XTHAL_ABI_WINDOWED, XTHAL_ABI_CALL0): New.
ld/
	* emultempl/xtensaelf.em (XSHAL_ABI): Add default definition.
	(replace_insn_sec_with_prop_sec): Use bfd_make_section_with_flags.
	Delete redundant code to set sections flags and alignment.
	(xt_config_info_unpack_and_check, check_xtensa_info): New.
	(elf_xtensa_after_open): Iterate over input statements instead of
	link_info.input_bfds.
	(elf_xtensa_before_allocation): Likewise.  Call check_xtensa_info for
	each input, and write a new .xtensa.info section in the output.
@
text
@a7677 1
	    /* Currently we only check for empty loops here.  */
d7679 2
a7680 1
		&& fragP->fr_subtype == RELAX_IMMED)
@


1.70
log
@	* config/tc-xtensa.c (xtensa_mark_literal_pool_location): Do not check
	the state of the absolute_literals directive.  Remove align frag at
	the start of the literal pool position.
@
text
@d33 5
d404 1
a404 1
  TRUE,				/* schedule */
d6867 1
d6898 2
d7808 49
@


1.69
log
@bfd/
	* elf32-xtensa.c (xtensa_get_property_section_name): Delete.
	(xtensa_get_property_section): New.
	(xtensa_read_table_entries): Use xtensa_get_property_section.
	(relax_property_section, xtensa_get_property_predef_flags): Handle
	group name suffixes in property section names.
	(match_section_group): New.
gas/
	* config/tc-xtensa.c (FINI_LITERAL_SECTION_NAME): Delete.
	(INIT_LITERAL_SECTION_NAME): Delete.
	(lit_state struct): Remove segment names, init_lit_seg, and
	fini_lit_seg.  Add lit_prefix and current_text_seg.
	(init_literal_head_h, init_literal_head): Delete.
	(fini_literal_head_h, fini_literal_head): Delete.
	(xtensa_begin_directive): Move argument parsing to
	xtensa_literal_prefix function.
	(xtensa_end_directive): Deallocate lit_prefix field of lit_state.
	(xtensa_literal_prefix): Parse the directive argument here and
	record it in the lit_prefix field.  Remove code to derive literal
	section names.
	(linkonce_len): New.
	(get_is_linkonce_section): Use linkonce_len.  Check for any
	".gnu.linkonce.*" section, not just text sections.
	(md_begin): Remove initialization of deleted lit_state fields.
	(xtensa_reorder_segments, xtensa_post_relax_hook): Remove references
	to init_literal_head and fini_literal_head.
	(xtensa_move_literals): Likewise.  Skip literals for .init and .fini
	when traversing literal_head list.
	(match_section_group): New.
	(cache_literal_section): Rewrite to determine the literal section
	name on the fly, create the section and return it.
	(xtensa_switch_to_literal_fragment): Adjust for cache_literal_section.
	(xtensa_switch_to_non_abs_literal_fragment): Likewise.
	(xtensa_create_property_segments, xtensa_create_xproperty_segments):
	Use xtensa_get_property_section from bfd.
	(retrieve_xtensa_section): Delete.
	* doc/c-xtensa.texi (Xtensa Options): Fix --text-section-literals
	description to refer to plural literal sections and add xref to
	the Literal Directive section.
	(Literal Directive): Describe new rules for deriving literal section
	names.  Add footnote for special case of .init/.fini with
	--text-section-literals.
	(Literal Prefix Directive): Replace old naming rules with xref to the
	Literal Directive section.
ld/
	* emulparams/elf32xtensa.sh (.xt.prop): Add .xt.prop.*.
	* scripttempl/elfxtensa.sc (.text): Add .literal.*.
@
text
@d4519 1
a4519 1
  if (use_literal_section && !directive_state[directive_absolute_literals])
a4521 3
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

@


1.68
log
@remove some duplicate #include's.
@
text
@d98 1
a99 3
#define INIT_SECTION_NAME		xtensa_section_rename (".init")
#define FINI_LITERAL_SECTION_NAME	xtensa_section_rename (".fini.literal")
#define INIT_LITERAL_SECTION_NAME	xtensa_section_rename (".init.literal")
d103 6
a108 1
   state of the literal collection pools.  */
d112 2
a113 4
  const char *lit_seg_name;
  const char *lit4_seg_name;
  const char *init_lit_seg_name;
  const char *fini_lit_seg_name;
a115 2
  segT init_lit_seg;
  segT fini_lit_seg;
d121 3
a123 3
/* We keep lists of literal segments.  The seg_list type is the node
   for such a list.  The *_literal_head locals are the heads of the
   various lists.  All of these lists have a dummy node at the start.  */
a132 4
static seg_list init_literal_head_h;
static seg_list *init_literal_head = &init_literal_head_h;
static seg_list fini_literal_head_h;
static seg_list *fini_literal_head = &fini_literal_head_h;
d412 1
a412 1
static void xtensa_literal_prefix (char const *, int);
d461 1
a461 2
static void cache_literal_section
  (seg_list *, const char *, segT *, bfd_boolean);
d465 1
a465 1
extern char *xtensa_get_property_section_name (asection *, const char *);
a1169 1
  int len;
a1215 1

a1217 6
      /* Parse the new prefix from the input_line_pointer.  */
      SKIP_WHITESPACE ();
      len = strspn (input_line_pointer,
		    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		    "abcdefghijklmnopqrstuvwxyz_/0123456789.$");

d1219 1
a1219 4
      xtensa_literal_prefix (input_line_pointer, len);

      /* Skip the name in the input line.  */
      input_line_pointer += len;
a1338 1

d1341 2
a1342 1
	      /* free the state storage */
d1449 1
a1449 1
xtensa_literal_prefix (char const *start, int len)
d1451 8
a1458 3
  char *name, *linkonce_suffix;
  char *newname, *newname4;
  size_t linkonce_len;
d1463 1
a1463 2

  strncpy (name, start, len);
d1466 2
a1467 24
  /* Allocate the sections (interesting note: the memory pointing to
     the name is actually used for the name by the new section). */

  newname = xmalloc (len + strlen (".literal") + 1);
  newname4 = xmalloc (len + strlen (".lit4") + 1);

  linkonce_len = sizeof (".gnu.linkonce.") - 1;
  if (strncmp (name, ".gnu.linkonce.", linkonce_len) == 0
      && (linkonce_suffix = strchr (name + linkonce_len, '.')) != 0)
    {
      strcpy (newname, ".gnu.linkonce.literal");
      strcpy (newname4, ".gnu.linkonce.lit4");

      strcat (newname, linkonce_suffix);
      strcat (newname4, linkonce_suffix);
    }
  else
    {
      int suffix_pos = len;

      /* If the section name ends with ".text", then replace that suffix
	 instead of appending an additional suffix.  */
      if (len >= 5 && strcmp (name + len - 5, ".text") == 0)
	suffix_pos -= 5;
d1469 1
a1469 6
      strcpy (newname, name);
      strcpy (newname4, name);

      strcpy (newname + suffix_pos, ".literal");
      strcpy (newname4 + suffix_pos, ".lit4");
    }
d1471 1
a1471 2
  /* Note that cache_literal_section does not create a segment if
     it already exists.  */
a1473 7

  /* Canonicalizing section names allows renaming literal
     sections to occur correctly.  */
  default_lit_sections.lit_seg_name = tc_canonicalize_symbol_name (newname);
  default_lit_sections.lit4_seg_name = tc_canonicalize_symbol_name (newname4);

  free (name);
d3876 3
a3878 1
   or the name is .gnu.linkonce*.  */
d3889 3
a3891 3
  if (!link_once_flags)
    {
      static size_t len = sizeof ".gnu.linkonce.t.";
a3892 3
      if (strncmp (segment_name (sec), ".gnu.linkonce.t.", len - 1) == 0)
	link_once_flags = SEC_LINK_ONCE;
    }
d4900 1
a4900 1
  /* Set up the .literal, .fini.literal and .init.literal sections.  */
a4901 4
  default_lit_sections.init_lit_seg_name = INIT_LITERAL_SECTION_NAME;
  default_lit_sections.fini_lit_seg_name = FINI_LITERAL_SECTION_NAME;
  default_lit_sections.lit_seg_name = LITERAL_SECTION_NAME;
  default_lit_sections.lit4_seg_name = LIT4_SECTION_NAME;
a9643 2
  mark_literal_frags (init_literal_head->next);
  mark_literal_frags (fini_literal_head->next);
d9648 1
a9648 2
  segment = literal_head->next;
  while (segment)
d9650 5
a9737 1
      segment = segment->next;
a9817 2
  xtensa_reorder_seg_list (init_literal_head, last_sec);
  xtensa_reorder_seg_list (fini_literal_head, last_sec);
d9835 2
a9836 4
      cache_literal_section (0, default_lit_sections.lit4_seg_name,
			     &default_lit_sections.lit4_seg, FALSE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.lit4_seg, 0);
a9849 6
  /* When we mark a literal pool location, we want to put a frag in
     the literal pool that points to it.  But to do that, we want to
     switch_to_literal_fragment.  But literal sections don't have
     literal pools, so their location is always null, so we would
     recurse forever.  This is kind of hacky, but it works.  */

d9852 1
a9854 1

d9864 7
d9876 2
a9877 28
  /* Special case: If we are in the ".fini" or ".init" section, then
     we will ALWAYS be generating to the ".fini.literal" and
     ".init.literal" sections.  */

  if (is_init)
    {
      cache_literal_section (init_literal_head,
			     default_lit_sections.init_lit_seg_name,
			     &default_lit_sections.init_lit_seg, TRUE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.init_lit_seg, 0);
    }
  else if (is_fini)
    {
      cache_literal_section (fini_literal_head,
			     default_lit_sections.fini_lit_seg_name,
			     &default_lit_sections.fini_lit_seg, TRUE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.fini_lit_seg, 0);
    }
  else
    {
      cache_literal_section (literal_head,
			     default_lit_sections.lit_seg_name,
			     &default_lit_sections.lit_seg, TRUE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.lit_seg, 0);
    }
d9921 1
a9921 2
/* Get a segment of a given name.  If the segment is already
   present, return it; otherwise, create a new one.  */
d9923 2
a9924 5
static void
cache_literal_section (seg_list *head,
		       const char *name,
		       segT *pseg,
		       bfd_boolean is_code)
d9926 12
a9937 3
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT seg;
d9939 27
a9965 2
  if (*pseg != 0)
    return;
d9967 5
a9971 2
  /* Check if the named section exists.  */
  for (seg = stdoutput->sections; seg; seg = seg->next)
d9973 3
a9975 2
      if (!strcmp (segment_name (seg), name))
	break;
d9978 7
a9984 1
  if (!seg)
d9986 37
a10022 3
      /* Create a new literal section.  */
      seg = subseg_new (name, (subsegT) 0);
      if (head)
d10024 1
a10024 1
	  /* Add the newly created literal segment to the specified list.  */
d10027 2
a10028 2
	  n->next = head->next;
	  head->next = n;
d10030 8
a10037 3
      bfd_set_section_flags (stdoutput, seg, SEC_HAS_CONTENTS |
			     SEC_READONLY | SEC_ALLOC | SEC_LOAD
			     | (is_code ? SEC_CODE : SEC_DATA));
d10041 1
a10041 1
  *pseg = seg;
d10043 1
a10061 1
static segT retrieve_xtensa_section (char *);
a10078 2
  xtensa_move_seg_list_to_beginning (init_literal_head);
  xtensa_move_seg_list_to_beginning (fini_literal_head);
d10134 2
a10135 3
	  char *property_section_name =
	    xtensa_get_property_section_name (sec, section_name_base);
	  segT insn_sec = retrieve_xtensa_section (property_section_name);
d10266 2
a10267 3
	  char *property_section_name =
	    xtensa_get_property_section_name (sec, section_name_base);
	  segT insn_sec = retrieve_xtensa_section (property_section_name);
a10410 23
static segT
retrieve_xtensa_section (char *sec_name)
{
  bfd *abfd = stdoutput;
  flagword flags, out_flags, link_once_flags;
  segT s;

  flags = bfd_get_section_flags (abfd, now_seg);
  link_once_flags = (flags & SEC_LINK_ONCE);
  if (link_once_flags)
    link_once_flags |= (flags & SEC_LINK_DUPLICATES);
  out_flags = (SEC_RELOC | SEC_HAS_CONTENTS | SEC_READONLY | link_once_flags);

  s = bfd_make_section_old_way (abfd, sec_name);
  if (s == NULL)
    as_bad (_("could not create section %s"), sec_name);
  if (!bfd_set_section_flags (abfd, s, out_flags))
    as_bad (_("invalid flag combination on section %s"), sec_name);

  return s;
}


@


1.67
log
@bfd:
        * elf32-xtensa.c (check_loop_aligned): Fix reversed check for
        undefined opcode.  Clean up assertions.
        (narrow_instruction, widen_instruction): Remove "do_it" parameters.
        Factor most of the code into separate functions....
        (can_narrow_instruction, can_widen_instruction): New.
        (prev_instr_is_a_loop): New.
        (compute_ebb_proposed_actions): Combine error handling code for
        decode errors.  Replace call to insn_decode_len with inline code.
        Use can_narrow_instruction and can_widen_instruction.  Handle errors
        from call to xtensa_opcode_is_loop.
        (relax_section): Adjust calls to narrow_instruction and
        widen_instruction.
gas:
        * config/tc-xtensa.c (is_direct_call_opcode, is_branch_jmp_to_next,
        xg_assemble_vliw_tokens, xtensa_mark_narrow_branches,
        xtensa_fix_short_loop_frags, is_local_forward_loop, relax_frag_immed):
        Handle errors from calls to xtensa_opcode_is_* functions.
@
text
@a20 1
#include <string.h>
a25 1
#include "frags.h"
@


1.66
log
@	* subsegs.h (struct frchain): Delete frch_seg.
	(frchain_root): Delete.
	(seg_info): Define as macro.
	* subsegs.c (frchain_root): Delete.
	(abs_seg_info, und_seg_info, absolute_frchain): Delete.
	(subsegs_begin, subseg_change): Adjust for above.
	(subseg_set_rest): Likewise.  Add new frchain structs to seginfo
	rather than to one big list.
	(subseg_get): Don't special case abs, und sections.
	(subseg_new, subseg_force_new): Don't set frchainP here.
	(seg_info): Delete.
	(subsegs_print_statistics): Adjust frag chain control list traversal.
	* debug.c (dmp_frags):  Likewise.
	* dwarf2dbg.c (first_frag_for_seg): Don't start looking for frag
	at frchain_root.  Make use of known frchain ordering.
	(last_frag_for_seg): Likewise.
	(get_frag_fix): Likewise.  Add seg param.
	(process_entries, out_debug_aranges): Adjust get_frag_fix calls.
	* write.c (chain_frchains_together_1): Adjust for struct frchain.
	(SUB_SEGMENT_ALIGN): Likewise.
	(subsegs_finish): Adjust frchain list traversal.
	* config/tc-xtensa.c (xtensa_cleanup_align_frags): Likewise.
	(xtensa_fix_target_frags, xtensa_mark_narrow_branches): Likewise.
	(xtensa_mark_zcl_first_insns, xtensa_fix_a0_b_retw_frags): Likewise.
	(xtensa_fix_b_j_loop_end_frags): Likewise.
	(xtensa_fix_close_loop_end_frags): Likewise.
	(xtensa_fix_short_loop_frags, xtensa_sanity_check): Likewise.
	(retrieve_segment_info): Delete frch_seg initialisation.
@
text
@d2592 1
a2592 1
  if (xtensa_opcode_is_call (isa, opcode) == 0)
d3683 2
a3684 2
  if (xtensa_opcode_is_branch (isa, insn->opcode) == 0
      && xtensa_opcode_is_jump (isa, insn->opcode) == 0)
d6834 1
a6834 1
  if (xtensa_opcode_is_loop (isa, vinsn->slots[0].opcode)
d7060 1
a7060 1
						vinsn.slots[0].opcode)
d7553 1
a7553 1
					       current_opcode));
d7826 1
a7826 1
  if (xtensa_opcode_is_loop (xtensa_default_isa, insn->opcode) == 0)
d8812 1
a8812 1
  if (estimate_only && xtensa_opcode_is_loop (isa, tinsn.opcode))
@


1.65
log
@	* config/tc-xtensa.c (xtensa_create_literal_symbol,
	xg_assemble_literal, xg_assemble_literal_space): Do not set the
	frag's is_literal flag.
@
text
@d6957 1
d6959 38
a6996 37
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if ((fragP->fr_type == rs_align
	       || fragP->fr_type == rs_align_code
	       || (fragP->fr_type == rs_machine_dependent
		   && (fragP->fr_subtype == RELAX_DESIRE_ALIGN
		       || fragP->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)))
	      && fragP->fr_fix == 0)
	    {
	      fragS *next = fragP->fr_next;

	      while (next
		     && next->fr_fix == 0
		     && next->fr_type == rs_machine_dependent
		     && next->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)
		{
		  frag_wane (next);
		  next = next->fr_next;
		}
	    }
	  /* If we don't widen branch targets, then they
	     will be easier to align.  */
	  if (fragP->tc_frag_data.is_branch_target
	      && fragP->fr_opcode == fragP->fr_literal
	      && fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
	    frag_wane (fragP);
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_UNREACHABLE)
	    fragP->tc_frag_data.is_unreachable = TRUE;
	}
    }
d7009 1
d7013 18
a7030 17
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)
	    {
	      if (next_frag_is_branch_target (fragP))
		fragP->fr_subtype = RELAX_DESIRE_ALIGN;
	      else
		frag_wane (fragP);
	    }
	}
    }
d7040 1
d7042 30
a7071 29
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED)
	    {
	      vliw_insn vinsn;

	      vinsn_from_chars (&vinsn, fragP->fr_opcode);
	      tinsn_immed_from_frag (&vinsn.slots[0], fragP, 0);

	      if (vinsn.num_slots == 1
		  && xtensa_opcode_is_branch (xtensa_default_isa,
					      vinsn.slots[0].opcode)
		  && xg_get_single_size (vinsn.slots[0].opcode) == 2
		  && is_narrow_branch_guaranteed_in_range (fragP,
							   &vinsn.slots[0]))
		{
		  fragP->fr_subtype = RELAX_SLOTS;
		  fragP->tc_frag_data.slot_subtypes[0] = RELAX_NARROW;
		  fragP->tc_frag_data.is_aligning_branch = 1;
		}
	    }
	}
    }
d7128 1
d7130 42
a7171 41
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE
		  || fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE))
	    {
	      /* Find the loop frag.  */
	      fragS *targ_frag = next_non_empty_frag (fragP);
	      /* Find the first insn frag.  */
	      targ_frag = next_non_empty_frag (targ_frag);

	      /* Of course, sometimes (mostly for toy test cases) a
		 zero-cost loop instruction is the last in a section.  */
	      if (targ_frag)
		{
		  targ_frag->tc_frag_data.is_first_loop_insn = TRUE;
		  /* Do not widen a frag that is the first instruction of a
		     zero-cost loop.  It makes that loop harder to align.  */
		  if (targ_frag->fr_type == rs_machine_dependent
		      && targ_frag->fr_subtype == RELAX_SLOTS
		      && (targ_frag->tc_frag_data.slot_subtypes[0]
			  == RELAX_NARROW))
		    {
		      if (targ_frag->tc_frag_data.is_aligning_branch)
			targ_frag->tc_frag_data.slot_subtypes[0] = RELAX_IMMED;
		      else
			{
			  frag_wane (targ_frag);
			  targ_frag->tc_frag_data.slot_subtypes[0] = 0;
			}
		    }
		}
	      if (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)
		frag_wane (fragP);
	    }
	}
    }
d7186 1
d7190 22
a7211 21
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_A0_B_RETW)
	    {
	      if (next_instrs_are_b_retw (fragP))
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("instruction sequence (write a0, branch, retw) may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
	    }
	}
    }
d7298 1
d7302 22
a7323 21
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_PRE_LOOP_END)
	    {
	      if (next_instr_is_loop_end (fragP))
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("branching or jumping to a loop end may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
	    }
	}
    }
d7364 1
d7368 13
a7380 12
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      fragS *current_target = NULL;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && ((fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
		  || (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)))
d7383 6
a7388 6
	  if (current_target
	      && fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_CLOSE_LOOP_END)
	    {
	      offsetT min_bytes;
	      int bytes_added = 0;
d7391 35
a7425 35
	      /* Max out at 12.  */
	      min_bytes = min_bytes_to_other_loop_end
		(fragP->fr_next, current_target, REQUIRED_LOOP_DIVIDING_BYTES);

	      if (min_bytes < REQUIRED_LOOP_DIVIDING_BYTES)
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("loop end too close to another loop end may trigger hardware errata"));
		  else
		    {
		      while (min_bytes + bytes_added
			     < REQUIRED_LOOP_DIVIDING_BYTES)
			{
			  int length = 3;

			  if (fragP->fr_var < length)
			    as_fatal (_("fr_var %lu < length %d"),
				      (long) fragP->fr_var, length);
			  else
			    {
			      assemble_nop (length,
					    fragP->fr_literal + fragP->fr_fix);
			      fragP->fr_fix += length;
			      fragP->fr_var -= length;
			    }
			  bytes_added += length;
			}
		    }
		}
	      frag_wane (fragP);
	    }
	  assert (fragP->fr_type != rs_machine_dependent
		  || fragP->fr_subtype != RELAX_ADD_NOP_IF_CLOSE_LOOP_END);
	}
    }
d7529 1
d7533 41
a7573 40
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      fragS *current_target = NULL;
      xtensa_opcode current_opcode = XTENSA_UNDEFINED;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && ((fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
		  || (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)))
	    {
	      TInsn t_insn;
	      fragS *loop_frag = next_non_empty_frag (fragP);
	      tinsn_from_chars (&t_insn, loop_frag->fr_opcode, 0);
	      current_target = symbol_get_frag (fragP->fr_symbol);
	      current_opcode = t_insn.opcode;
	      assert (xtensa_opcode_is_loop (xtensa_default_isa,
					     current_opcode));
	    }

	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_SHORT_LOOP)
	    {
	      if (count_insns_to_loop_end (fragP->fr_next, TRUE, 3) < 3
		  && (branch_before_loop_end (fragP->fr_next)
		      || (workaround_all_short_loops
			  && current_opcode != XTENSA_UNDEFINED
			  && current_opcode != xtensa_loop_opcode)))
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("loop containing less than three instructions may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
	    }
	}
    }
a7715 1

d7717 1
d7720 41
a7760 40
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  /* Currently we only check for empty loops here.  */
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_IMMED)
	    {
	      static xtensa_insnbuf insnbuf = NULL;
	      TInsn t_insn;

	      if (fragP->fr_opcode != NULL)
		{
		  if (!insnbuf)
		    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
		  tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
		  tinsn_immed_from_frag (&t_insn, fragP, 0);

		  if (xtensa_opcode_is_loop (xtensa_default_isa,
					     t_insn.opcode) == 1)
		    {
		      if (is_empty_loop (&t_insn, fragP))
			{
			  new_logical_line (fragP->fr_file, fragP->fr_line);
			  as_bad (_("invalid empty loop"));
			}
		      if (!is_local_forward_loop (&t_insn, fragP))
			{
			  new_logical_line (fragP->fr_file, fragP->fr_line);
			  as_bad (_("loop target does not follow "
				    "loop instruction in section"));
			}
		    }
		}
	    }
	}
    }
a10403 1
      frchainP->frch_seg = seg;
@


1.64
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@a3982 1
  frag->tc_frag_data.is_literal = TRUE;
a4047 1
  frag_now->tc_frag_data.is_literal = TRUE;
a4075 1
  frag_now->tc_frag_data.is_literal = TRUE;
a4229 1
  /* assert (!insn->is_literal); */
@


1.63
log
@	* config/tc-xtensa.c (emit_single_op): Do not relax MOVI
	instructions when such transformations have been disabled.
@
text
@d8619 1
a8619 1
    c          0      1         4 (case 6b makes this case unneccesary)
@


1.63.2.1
log
@	* config/tc-xtensa.c (xtensa_create_literal_symbol,
	xg_assemble_literal, xg_assemble_literal_space): Do not set the
	frag's is_literal flag.
@
text
@d3983 1
d4049 1
d4078 1
d4233 1
@


1.62
log
@	* config/tc-xtensa.c (xg_assemble_vliw_tokens): Record loop target
	symbols in RELAX[_CHECK]_ALIGN_NEXT_OPCODE frags.
	(xtensa_fix_close_loop_end_frags): Use the recorded values instead of
	decoding the loop instructions.  Remove current_offset variable.
	(xtensa_fix_short_loop_frags): Likewise.
	(min_bytes_to_other_loop_end): Remove current_offset argument.
@
text
@d6576 2
a6577 1
	  || orig_insn->tok[1].X_op == O_pltrel))
@


1.61
log
@	* config/tc-xtensa.c (init_op_placement_info_table): Check for formats
	of the same length but different numbers of slots.
@
text
@d6727 8
d6744 1
a6744 4
		  RELAX_ALIGN_NEXT_OPCODE,
		  frag_now->fr_symbol,
		  frag_now->fr_offset,
		  NULL);
d6747 1
a6747 1
		  RELAX_CHECK_ALIGN_NEXT_OPCODE, 0, 0, NULL);
d7349 1
a7349 1
  (fragS *, fragS *, offsetT, offsetT);
a7362 1
      offsetT current_offset = 0;
d7368 3
a7370 20
	      && ((fragP->fr_subtype == RELAX_IMMED)
		  || ((fragP->fr_subtype == RELAX_SLOTS)
		      && (fragP->tc_frag_data.slot_subtypes[0]
			  == RELAX_IMMED))))
	    {
	      /* Read it.  If the instruction is a loop, get the target.  */
	      TInsn t_insn;
	      tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
	      if (xtensa_opcode_is_loop (xtensa_default_isa,
					 t_insn.opcode) == 1)
		{
		  /* Get the current fragment target.  */
		  if (fragP->tc_frag_data.slot_symbols[0])
		    {
		      symbolS *sym = fragP->tc_frag_data.slot_symbols[0];
		      current_target = symbol_get_frag (sym);
		      current_offset = fragP->fr_offset;
		    }
		}
	    }
d7382 1
a7382 2
		(fragP->fr_next, current_target, current_offset,
		 REQUIRED_LOOP_DIVIDING_BYTES);
a7422 1
			     offsetT current_offset,
d7434 1
a7434 1
	return offset + current_offset;
d7438 1
a7438 1
      if (offset + current_offset >= max_size)
a7524 1
      offsetT current_offset = 0;
a7529 1
	  /* Check on the current loop.  */
d7531 2
a7532 4
	      && ((fragP->fr_subtype == RELAX_IMMED)
		  || ((fragP->fr_subtype == RELAX_SLOTS)
		      && (fragP->tc_frag_data.slot_subtypes[0]
			  == RELAX_IMMED))))
d7535 6
a7540 15

	      /* Read it.  If the instruction is a loop, get the target.  */
	      tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
	      if (xtensa_opcode_is_loop (xtensa_default_isa,
					 t_insn.opcode) == 1)
		{
		  /* Get the current fragment target.  */
		  if (fragP->tc_frag_data.slot_symbols[0])
		    {
		      symbolS *sym = fragP->tc_frag_data.slot_symbols[0];
		      current_target = symbol_get_frag (sym);
		      current_offset = fragP->fr_offset;
		      current_opcode = t_insn.opcode;
		    }
		}
@


1.60
log
@	* config/tc-xtensa.c (enforce_three_byte_loop_align): New flag.
	(xtensa_setup_hw_workarounds): Set this new flag for older hardware.
	(get_loop_align_size): New.
	(xtensa_end): Skip xtensa_mark_narrow_branches when not aligning.
	(xtensa_mark_zcl_first_insns): Prevent widening of first loop frag.
	(get_text_align_power): Rewrite to handle inputs in the range 2-8.
	(get_noop_aligned_address): Use get_loop_align_size.
	(get_aligned_diff): Likewise.
@
text
@d10855 5
a10859 2
		  /* opi->slot_count[fmt]++; */
		  if (fmt_length < opi->narrowest_size)
@


1.59
log
@	* config/tc-xtensa.c (xg_translate_sysreg_op): Remove has_underbar
	flag and avoid double underscore prefixes.
@
text
@d569 1
d594 1
d4435 20
d6943 2
a6944 1
  xtensa_mark_narrow_branches ();
d7139 18
a7156 1
		targ_frag->tc_frag_data.is_first_loop_insn = TRUE;
d7878 4
a7881 10
  int i = 0;
  unsigned power = 1;

  assert (target_size <= INT_MAX);
  while (target_size > power)
    {
      power <<= 1;
      i += 1;
    }
  return i;
d8075 3
a8077 8
    return address;

  assert (first_insn->tc_frag_data.is_first_loop_insn);

  first_insn_size = frag_format_size (first_insn);

  if (first_insn_size == 2 || first_insn_size == XTENSA_UNDEFINED)
    first_insn_size = 3;	/* ISA specifies this */
d8140 1
a8140 1
      target_size = next_frag_format_size (fragP);
a8150 3
      if (target_size == 2)
	target_size = 3; /* ISA specifies this */

d8754 1
a8754 1
	 This is a RELAX_FRAG_NARROW frag.  */
@


1.59.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a568 1
static bfd_boolean enforce_three_byte_loop_align = FALSE;
a592 1
      enforce_three_byte_loop_align = TRUE;
d3981 1
d4047 1
d4076 1
d4231 1
a4432 20
/* In early Xtensa Processors, for reasons that are unclear, the ISA
   required two-byte instructions to be treated as three-byte instructions
   for loop instruction alignment.  This restriction was removed beginning
   with Xtensa LX.  Now the only requirement on loop instruction alignment
   is that the first instruction of the loop must appear at an address that
   does not cross a fetch boundary.  */

static int
get_loop_align_size (int insn_size)
{
  if (insn_size == XTENSA_UNDEFINED)
    return xtensa_fetch_width;

  if (enforce_three_byte_loop_align && insn_size == 2)
    return 3;

  return insn_size;
}


d6554 1
a6554 2
	  || orig_insn->tok[1].X_op == O_pltrel)
      && !orig_insn->is_specific_opcode && use_transform ())
a6704 8
      /* Remember the symbol that marks the end of the loop in the frag
	 that marks the start of the loop.  This way we can easily find
	 the end of the loop at the beginning, without adding special code
	 to mark the loop instructions themselves.  */
      symbolS *target_sym = NULL;
      if (vinsn->slots[0].tok[1].X_op == O_symbol)
	target_sym = vinsn->slots[0].tok[1].X_add_symbol;

d6714 4
a6717 1
		  RELAX_ALIGN_NEXT_OPCODE, target_sym, 0, NULL);
d6720 1
a6720 1
		  RELAX_CHECK_ALIGN_NEXT_OPCODE, target_sym, 0, NULL);
d6921 1
a6921 2
  if (align_targets)
    xtensa_mark_narrow_branches ();
d7116 1
a7116 18
		{
		  targ_frag->tc_frag_data.is_first_loop_insn = TRUE;
		  /* Do not widen a frag that is the first instruction of a
		     zero-cost loop.  It makes that loop harder to align.  */
		  if (targ_frag->fr_type == rs_machine_dependent
		      && targ_frag->fr_subtype == RELAX_SLOTS
		      && (targ_frag->tc_frag_data.slot_subtypes[0]
			  == RELAX_NARROW))
		    {
		      if (targ_frag->tc_frag_data.is_aligning_branch)
			targ_frag->tc_frag_data.slot_subtypes[0] = RELAX_IMMED;
		      else
			{
			  frag_wane (targ_frag);
			  targ_frag->tc_frag_data.slot_subtypes[0] = 0;
			}
		    }
		}
d7304 1
a7304 1
  (fragS *, fragS *, offsetT);
d7318 1
d7324 20
a7343 3
	      && ((fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
		  || (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)))
	      current_target = symbol_get_frag (fragP->fr_symbol);
d7355 2
a7356 1
		(fragP->fr_next, current_target, REQUIRED_LOOP_DIVIDING_BYTES);
d7397 1
d7409 1
a7409 1
	return offset;
d7413 1
a7413 1
      if (offset >= max_size)
d7500 1
d7506 1
d7508 4
a7511 2
	      && ((fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
		  || (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)))
d7514 15
a7528 6
	      fragS *loop_frag = next_non_empty_frag (fragP);
	      tinsn_from_chars (&t_insn, loop_frag->fr_opcode, 0);
	      current_target = symbol_get_frag (fragP->fr_symbol);
	      current_opcode = t_insn.opcode;
	      assert (xtensa_opcode_is_loop (xtensa_default_isa,
					     current_opcode));
d7838 10
a7847 4
  if (target_size <= 4)
    return 2;
  assert (target_size == 8);
  return 3;
d8041 8
a8048 3
    first_insn_size = xtensa_fetch_width;
  else
    first_insn_size = get_loop_align_size (frag_format_size (first_insn));
d8111 1
a8111 1
      target_size = get_loop_align_size (next_frag_format_size (fragP));
d8122 3
d8728 1
a8728 1
	 This is a RELAX_NARROW frag.  */
d10829 2
a10830 5
		  if (fmt_length < opi->narrowest_size
		      || (fmt_length == opi->narrowest_size
			  && (xtensa_format_num_slots (isa, fmt)
			      < xtensa_format_num_slots (isa,
							 opi->narrowest))))
@


1.58
log
@	* config/tc-xtensa.c (xtensa_post_relax_hook): Generate literal tables
	even when using the text-section-literals option.
@
text
@a2182 1
  bfd_boolean has_underbar = FALSE;
d2186 1
a2186 4
    {
      has_underbar = TRUE;
      opname += 1;
    }
d2232 1
a2232 2
  sprintf (new_opname, "%s%s.%s", (has_underbar ? "_" : ""),
	   *popname, sr_name);
@


1.57
log
@	* config/tc-xtensa.c (xg_add_opcode_fix): Number operands starting
	from 1, not 0, in error messages.
	(md_assemble): Simplify special-case check for ENTRY instructions.
	(tinsn_has_invalid_symbolic_operands): Do not include opcode and
	operand in error message.
@
text
@d10081 4
a10084 5
  if (use_literal_section)
    xtensa_create_property_segments (get_frag_is_literal,
				     NULL,
				     XTENSA_LIT_SEC_NAME,
				     xt_literal_sec);
@


1.56
log
@	* config/tc-xtensa.c (xg_assembly_relax): Increment steps_taken for
	each relaxation step.
@
text
@d4134 1
a4134 1
	      opnum, xtensa_opcode_name (xtensa_default_isa, opcode));
d4144 1
a4144 1
	      opnum, xtensa_opcode_name (xtensa_default_isa, opcode));
d5255 2
a5256 2
  /* Special-case for "entry" instruction.  */
  if (orig_insn.opcode == xtensa_entry_opcode)
d5258 3
a5260 15
      /* Check that the third opcode (#2) is >= 16.  */
      if (orig_insn.ntok >= 3)
	{
	  expressionS *exp = &orig_insn.tok[2];
	  switch (exp->X_op)
	    {
	    case O_constant:
	      if (exp->X_add_number < 16)
		as_warn (_("entry instruction with stack decrement < 16"));
	      break;

	    default:
	      as_warn (_("entry instruction with non-constant decrement"));
	    }
	}
d11036 1
a11036 2
	      as_bad (_("invalid symbolic operand %d on '%s'"),
		      i, xtensa_opcode_name (isa, insn->opcode));
@


1.55
log
@	* config/xtensa-istack.h (TInsn): Remove record_fix and sub_symbol
	fields.
	* config/tc-xtensa.h (xtensa_frag_type): Remove slot_sub_symbols field.
	* config/tc-xtensa.c (md_apply_fix): Check for unexpected uses of
	subtracted symbols.
	(relaxation_requirements): Add pfinish_frag argument and use it to
	replace setting tinsn->record_fix fields.
	(xg_assemble_vliw_tokens): Adjust calls to relaxation_requirements
	and vinsn_to_insnbuf.  Remove references to record_fix and
	slot_sub_symbols fields.
	(xtensa_mark_narrow_branches): Delete unused code.
	(is_narrow_branch_guaranteed_in_range): Handle expr that is not just
	a symbol.
	(convert_frag_immed): Adjust vinsn_to_insnbuf call and do not set
	record_fix fields.
	(tinsn_immed_from_frag): Remove code for handling slot_sub_symbols.
	(vinsn_to_insnbuf): Change use of record_fixup argument, replacing use
	of the record_fix field.  Simplify error messages for unexpected
	symbolic operands.
	(set_expr_symbol_offset_diff): Delete.
@
text
@d3566 1
a3569 1
	  steps_taken++;
@


1.54
log
@* config/tc-xtensa.c (md_apply_fix): Set value to zero for PLT relocs.
@
text
@a512 2
static void set_expr_symbol_offset_diff
  (expressionS *, symbolS *, symbolS *, offsetT);
d5538 7
d5550 1
a5550 1
      if (linkrelax && fixP->fx_subsy)
d6468 1
a6468 1
relaxation_requirements (vliw_insn *vinsn)
d6470 1
a6487 7
	      tinsn->record_fix = TRUE;
	      break;
	    }
	  else
	    {
	      tinsn->record_fix = FALSE;
	      /* No extra_space needed.  */
a6511 1
	      tinsn->record_fix = FALSE;
d6516 3
a6518 2
	      tinsn->record_fix = TRUE;
	      /* No extra space needed.  */
d6522 1
d6638 1
a6638 1
  bfd_boolean finish_frag = FALSE;
d6765 1
a6765 1
  extra_space = relaxation_requirements (vinsn);
d6775 1
a6775 1
  vinsn_to_insnbuf (vinsn, f, frag_now, TRUE);
a6792 1
      frag_now->tc_frag_data.slot_sub_symbols[slot] = tinsn->sub_symbol;
d6805 2
a6806 2
      if (tinsn->subtype || tinsn->symbol || tinsn->record_fix
	  || tinsn->offset || tinsn->literal_frag || is_jump || is_branch)
a7039 2
	      const expressionS *expr;
	      symbolS *symbolP;
a7043 3
	      expr = &vinsn.slots[0].tok[1];
	      symbolP = expr->X_add_symbol;

a7083 1
  fragS *target_frag = symbol_get_frag (symbolP);
d7085 7
d9201 1
a9201 1
      vinsn_to_insnbuf (&cur_vinsn, fr_opcode, frag_now, FALSE);
a9335 1
		      tinsn->record_fix = TRUE;
a9342 1
		      cur_vinsn.slots[slot].record_fix = FALSE;
d11043 1
a11043 6
	     support non-PC-relative relocations.  (It isn't necessary
	     to complain about non-PC-relative relocations here, but
	     otherwise, no error is reported until the relocations are
	     generated, and the assembler won't get that far if there
	     are any other errors.  It's nice to see all the problems
	     at once.)  */
d11280 3
a11282 15
      if (fragP->tc_frag_data.slot_sub_symbols[slot])
	{
	  set_expr_symbol_offset_diff
	    (&tinsn->tok[opnum],
	     fragP->tc_frag_data.slot_symbols[slot],
	     fragP->tc_frag_data.slot_sub_symbols[slot],
	     fragP->tc_frag_data.slot_offsets[slot]);
	}
      else
	{
	  set_expr_symbol_offset
	    (&tinsn->tok[opnum],
	     fragP->tc_frag_data.slot_symbols[slot],
	     fragP->tc_frag_data.slot_offsets[slot]);
	}
d11385 2
a11386 11
/* Before this is called, we should have
   filled out the following fields:

   1) the number of operands for each opcode are correct
   2) the tinsn in the slots are ITYPE_INSN
   3) ONLY the relaxable_ is built
   4) All operands are
       O_constant, O_symbol
      All constants fit

   The return value tells whether there are any remaining O_symbols.  */
d11411 1
a11411 8
      /* tinsn_has_fixup tracks if there is a fixup at all.
	 record_fixup controls globally.  I.E., we use this
	 function from several places, some of which are after
	 fixups have already been recorded.  Finally,
	 tinsn->record_fixup controls based on the individual ops,
	 which may or may not need it based on the relaxation
	 requirements.  */
      if (tinsn_has_fixup && record_fixup)
d11428 7
a11434 1
		      if (tinsn->record_fix || expr->X_op != O_symbol)
d11436 2
a11437 4
			  if (!xg_add_opcode_fix
			      (tinsn, i, fmt, slot, expr, fragP,
			       frag_offset - fragP->fr_literal))
			    as_bad (_("instruction with constant operands does not fit"));
d11441 2
d11448 1
a11448 2
		    as_bad (_("invalid operand %d on '%s'"),
			    i, xtensa_opcode_name (isa, opcode));
a11454 17
		case O_subtract:
		  if (get_relaxable_immed (opcode) == i)
		    {
		      if (tinsn->record_fix)
			  as_bad (_("invalid subtract operand"));
		      else
			{
			  tinsn->symbol = expr->X_add_symbol;
			  tinsn->sub_symbol = expr->X_op_symbol;
			  tinsn->offset = expr->X_add_number;
			}
		    }
		  else
		    as_bad (_("invalid operand %d on '%s'"),
			    i, xtensa_opcode_name (isa, opcode));
		  break;

d11456 1
a11456 2
		  as_bad (_("invalid expression for operand %d on '%s'"),
			  i, xtensa_opcode_name (isa, opcode));
a11561 15
/* Set the expression to symbol - minus_sym + offset.  */

static void
set_expr_symbol_offset_diff (expressionS *s,
			     symbolS *sym,
			     symbolS *minus_sym,
			     offsetT offset)
{
  s->X_op = O_subtract;
  s->X_add_symbol = sym;
  s->X_op_symbol = minus_sym;	/* unused */
  s->X_add_number = offset;
}


@


1.53
log
@include:
	* xtensa-config.h (XCHAL_HAVE_WIDE_BRANCHES): New.
gas:
	* config/tc-xtensa.c (op_placement_info_struct): Delete single,
	single_size, widest, and widest_size fields.  Add narrowest_slot.
	(xg_emit_insn_to_buf): Remove fmt parameter and compute it here.
	Use xg_get_single_slot to find the slot.
	(finish_vinsn): Use emit_single_op instead of bundle_single_op.
	(bundle_single_op): Rename this to....
	(bundle_tinsn): ...this function, which builds a vliw_insn but does
	not call finish_vinsn.
	(emit_single_op): Use bundle_tinsn instead of bundle_single_op.
	(relax_frag_immed): Get num_slots from cur_vinsn.
	(convert_frag_narrow): Update call to xg_emit_insn_to_buf.
	(convert_frag_immed): Likewise.  Also, get num_slots from cur_vinsn.
	(init_op_placement_info_table): Set narrowest_slot field.  Remove
	code for deleted fields.
	(xg_get_single_size): Return narrowest_size field, not single_size.
	(xg_get_single_format): Return narrowest field, not single.
	(xg_get_single_slot): New.
	(tinsn_to_insnbuf): Rewrite to use tinsn_to_slotbuf.
	* config/xtensa-relax.c (widen_spec_list): Add wide branch relaxations.
	(transition_applies): Check wide branch option availability.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
d5538 1
a5538 1
  valueT val;
d5586 3
a5588 2
      else
	break;
a5631 1
    case BFD_RELOC_XTENSA_PLT:
@


1.52
log
@	* config/tc-xtensa.c (tinsn_to_slotbuf): Do not zero slotbuf.
@
text
@a329 4
  /* The single format (i.e., if the op can live in a bundle by itself),
     narrowest format, and widest format the op can be bundled in
     and their sizes:  */
  xtensa_format single;
a330 1
  xtensa_format widest;
d332 1
a332 2
  char widest_size;
  char single_size;
d481 1
a4186 1
		     xtensa_format fmt,
d4195 1
d4203 2
d4208 1
a4208 1
      if (!xg_add_opcode_fix (tinsn, opnum, fmt, 0, exp, fragP, offset))
a5936 1
static void bundle_single_op (TInsn *);
d6064 1
a6064 1
		  bundle_single_op (&slotstack.insn[slotstack.ninsn - 1]);
d6528 1
a6528 1
bundle_single_op (TInsn *orig_insn)
d6531 1
a6531 2
  vliw_insn v;
  int slot;
d6533 3
a6535 4
  xg_init_vinsn (&v);
  v.format = op_placement_table[orig_insn->opcode].narrowest;
  assert (v.format != XTENSA_UNDEFINED);
  v.num_slots = xtensa_format_num_slots (isa, v.format);
d6537 2
a6538 3
  for (slot = 0;
       !opcode_fits_format_slot (orig_insn->opcode, v.format, slot);
       slot++)
d6540 9
a6548 4
      v.slots[slot].opcode =
	xtensa_format_slot_nop_opcode (isa, v.format, slot);
      v.slots[slot].ntok = 0;
      v.slots[slot].insn_type = ITYPE_INSN;
a6549 14

  v.slots[slot] = *orig_insn;
  slot++;

  for ( ; slot < v.num_slots; slot++)
    {
      v.slots[slot].opcode =
	xtensa_format_slot_nop_opcode (isa, v.format, slot);
      v.slots[slot].ntok = 0;
      v.slots[slot].insn_type = ITYPE_INSN;
    }

  finish_vinsn (&v);
  xg_free_vinsn (&v);
d6599 11
a6609 5
	  if (lit_sym)
	    xg_resolve_literals (insn, lit_sym);
	  if (label_sym)
	    xg_resolve_labels (insn, label_sym);
	  bundle_single_op (insn);
d8811 1
a8811 1
  if (xtensa_format_num_slots (isa, fmt) > 1)
a9068 1
  xtensa_format single_fmt;
d9111 2
a9112 4
  single_fmt = xg_get_single_format (single_target.opcode);

  xg_emit_insn_to_buf (&single_target, single_fmt, fragP->fr_opcode,
		       fragP, frag_offset, TRUE);
d9173 1
a9173 1
  if (xtensa_format_num_slots (isa, fmt) > 1)
a9352 3
		      xtensa_format single_fmt =
			xg_get_single_format (tinsn->opcode);

d9354 1
a9354 1
			(tinsn, single_fmt, immed_instr + size, fragP,
a9360 1
		  xtensa_format single_format;
d9362 1
a9362 3
		  single_format = xg_get_single_format (tinsn->opcode);
		  xg_emit_insn_to_buf (tinsn, single_format, immed_instr,
				       fragP,
a10831 4
      opi->single = XTENSA_UNDEFINED;
      opi->single_size = 0;
      opi->widest = XTENSA_UNDEFINED;
      opi->widest_size = 0;
d10834 1
d10854 1
a10854 14
		    }
		  if (fmt_length > opi->widest_size)
		    {
		      opi->widest = fmt;
		      opi->widest_size = fmt_length;
		    }
		  if (xtensa_format_num_slots (isa, fmt) == 1)
		    {
		      if (opi->single_size == 0
			  || fmt_length < opi->single_size)
			{
			  opi->single = fmt;
			  opi->single_size = fmt_length;
			}
d10878 1
a10878 2
  assert (op_placement_table[opcode].single != XTENSA_UNDEFINED);
  return op_placement_table[opcode].single_size;
d10885 8
a10892 1
  return op_placement_table[opcode].single;
d11095 7
a11101 86
/* Convert the constant operands in the tinsn to insnbuf.
   Return TRUE if there is a symbol in the immediate field.

   Before this is called,
   1) the number of operands are correct
   2) the tinsn is a ITYPE_INSN
   3) ONLY the relaxable_ is built
   4) All operands are O_constant, O_symbol.  All constants fit
   The return value tells whether there are any remaining O_symbols.  */

static bfd_boolean
tinsn_to_insnbuf (TInsn *tinsn, xtensa_insnbuf insnbuf)
{
  static xtensa_insnbuf slotbuf = 0;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = tinsn->opcode;
  xtensa_format fmt = xg_get_single_format (opcode);
  bfd_boolean has_fixup = FALSE;
  int noperands = xtensa_opcode_num_operands (isa, opcode);
  int i;
  uint32 opnd_value;
  char *file_name;
  unsigned line;

  if (!slotbuf)
    slotbuf = xtensa_insnbuf_alloc (isa);

  assert (tinsn->insn_type == ITYPE_INSN);
  if (noperands != tinsn->ntok)
    as_fatal (_("operand number mismatch"));

  if (xtensa_opcode_encode (isa, fmt, 0, slotbuf, opcode))
    as_fatal (_("cannot encode opcode"));

  for (i = 0; i < noperands; ++i)
    {
      expressionS *expr = &tinsn->tok[i];
      switch (expr->X_op)
	{
	case O_register:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  /* The register number has already been checked in
	     expression_maybe_register, so we don't need to check here.  */
	  opnd_value = expr->X_add_number;
	  (void) xtensa_operand_encode (isa, opcode, i, &opnd_value);
	  xtensa_operand_set_field (isa, opcode, i, fmt, 0,
				    slotbuf, opnd_value);
	  break;

	case O_constant:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  as_where (&file_name, &line);
	  /* It is a constant and we called this function,
	     then we have to try to fit it.  */
	  xtensa_insnbuf_set_operand (slotbuf, fmt, 0, opcode, i,
				      expr->X_add_number, file_name, line);
	  break;

	default:
	  has_fixup = TRUE;
	  break;
	}
    }

  xtensa_format_encode (isa, fmt, insnbuf);
  xtensa_format_set_slot (isa, fmt, 0, insnbuf, slotbuf);

  return has_fixup;
}


/* Convert the constant operands in the tinsn to slotbuf.
   Return TRUE if there is a symbol in the immediate field.
   (Eventually this should replace tinsn_to_insnbuf.)  */

/* Before this is called,
   1) the number of operands are correct
   2) the tinsn is a ITYPE_INSN
   3) ONLY the relaxable_ is built
   4) All operands are
       O_constant, O_symbol
      All constants fit

   The return value tells whether there are any remaining O_symbols.  */
d11169 38
@


1.51
log
@	* config/tc-xtensa.c (xtensa_mark_narrow_branches): Set
	is_aligning_branch flag.
	(find_address_of_next_align_frag): Limit by xtensa_fetch_width.
	(future_alignment_required): Except for frags with is_aligning_branch
	flag set, call frag_wane for frags that do not need to be reexamined
	for aligning.
	(relax_frag_immed): Replace orig_vinsn with cur_vinsn to fix a leak.
	(convert_frag_immed): Likewise.
	(convert_frag_narrow): Check is_aligning_branch flag.
	* config/tc-xtensa.h (xtensa_frag_type): Add is_aligning_branch flag.
@
text
@a11222 2
  *((int *) &slotbuf[0]) = 0;
  *((int *) &slotbuf[1]) = 0;
@


1.50
log
@	* config/tc-xtensa.c (xg_find_narrowest_format): Optimize 1 slot case.
	(xg_init_vinsn): Remove redundant initialization.
	(xg_clear_vinsn): Zero all the slots with a single memset.
	* config/xtensa-istack.h (vliw_insn): Move insnbuf field after slots.
@
text
@d7069 1
d8430 1
a8430 1
      if (*widens > 8)
d8517 8
a8524 1
  if (address)
d8549 1
a8549 1
	    break;
a8804 1
  vliw_insn orig_vinsn;
d8819 2
a8820 2
  xg_init_vinsn (&orig_vinsn);
  vinsn_from_chars (&orig_vinsn, fragP->fr_opcode);
d8824 1
a8824 1
  tinsn = orig_vinsn.slots[slot];
d9086 1
a9086 1
  if (xtensa_opcode_is_branch (xtensa_default_isa, tinsn.opcode) == 1)
a9175 1
  vliw_insn orig_vinsn;
d9183 1
a9183 1
  xg_init_vinsn (&orig_vinsn);
d9185 1
a9185 1
  vinsn_from_chars (&orig_vinsn, fr_opcode);
d9189 1
a9189 1
  orig_tinsn = orig_vinsn.slots[slot];
d9203 3
a9205 3
	  orig_vinsn.slots[slot].opcode =
	    xtensa_format_slot_nop_opcode (isa, orig_vinsn.format, slot);
	  orig_vinsn.slots[slot].ntok = 0;
d9211 1
a9211 1
	  build_nop (&orig_vinsn.slots[0], bytes);
d9214 1
a9214 1
      vinsn_to_insnbuf (&orig_vinsn, fr_opcode, frag_now, FALSE);
d9216 1
a9216 1
	(isa, orig_vinsn.insnbuf, (unsigned char *) fr_opcode, 0);
d9350 1
a9350 1
		      orig_vinsn.slots[slot] = *tinsn;
d9354 1
a9354 1
		      orig_vinsn.slots[slot].opcode =
d9356 2
a9357 2
		      orig_vinsn.slots[slot].ntok = 0;
		      orig_vinsn.slots[slot].record_fix = FALSE;
d9359 2
a9360 2
		  vinsn_to_insnbuf (&orig_vinsn, immed_instr, fragP, TRUE);
		  xtensa_insnbuf_to_chars (isa, orig_vinsn.insnbuf,
a9398 3
  /* Clean it up.  */
  xg_free_vinsn (&orig_vinsn);

@


1.49
log
@	* config/tc-xtensa.c (find_vinsn_conflicts): Change error messages to
	refer to "ports" instead of "queues".
	(check_t1_t2_reads_and_writes): Pass correct interface values to
	xtensa_interface_inout.
@
text
@d6406 3
a11422 2
      tinsn_init (&v->slots[i]);
      v->slots[i].opcode = XTENSA_UNDEFINED;
d11434 3
d11445 1
a11445 4
    {
      memset (&v->slots[i], 0, sizeof (TInsn));
      v->slots[i].opcode = XTENSA_UNDEFINED;
    }
@


1.48
log
@	* config/tc-xtensa.c (xtensa_end_directive): Restore
	default_lit_sections regardless of use_literal_section.
@
text
@d6188 1
a6188 1
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same queue"),
d6193 1
a6193 1
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) both have volatile queue accesses"),
d6352 1
a6352 1
      t2_inout = xtensa_interface_inout (isa, j);
d6362 1
a6362 1
	  t1_inout = xtensa_interface_inout (isa, i);
@


1.47
log
@	* config/xtensa-istack.h (TInsn): Replace dwarf2_line_info with an
	unsigned line number.  Do not include "dwarf2dbg.h".
	* config/tc-xtensa.c (md_pseudo_table): Remove entry for "loc".
	(xtensa_dwarf2_directive_loc, xtensa_dwarf2_emit_insn): Delete.
	(xg_build_to_insn, xg_build_token_insn): Update TInsn uses.
	(md_assemble): Use as_where instead of dwarf2_where.
	(xg_assemble_vliw_tokens): Use unsigned line numbers instead of
	dwarf2_line_infos.  Change to call new_logical_line followed by
	dwarf2_emit_insn.
@
text
@d1364 1
a1364 2
	      if (use_literal_section)
		default_lit_sections = *s;
@


1.46
log
@	* config/tc-xtensa.c (xtensa_frob_label): Disallow labels in bundles.
@
text
@a424 1
static void xtensa_dwarf2_directive_loc (int);
a1017 1
  { "loc", xtensa_dwarf2_directive_loc, 0 },
a1385 22
/* Wrap dwarf2 functions so that we correctly support the .loc directive.  */

static bfd_boolean xtensa_loc_directive_seen = FALSE;

static void
xtensa_dwarf2_directive_loc (int x)
{
  xtensa_loc_directive_seen = TRUE;
  dwarf2_directive_loc (x);
}


static void
xtensa_dwarf2_emit_insn (int size, struct dwarf2_line_info *loc)
{
  if (debug_type != DEBUG_DWARF2 && ! xtensa_loc_directive_seen)
    return;
  xtensa_loc_directive_seen = FALSE;
  dwarf2_gen_line_info (frag_now_fix () - size, loc);
}


d3327 1
a3327 1
  targ->loc = insn->loc;
d3783 1
a3783 1
      new_insn->loc = old_insn->loc;
d3789 1
a3789 1
      new_insn->loc = old_insn->loc;
d5164 1
a5164 1
  char *opname;
d5253 5
a5257 1
  dwarf2_where (&orig_insn.loc);
d6655 2
a6656 1
  struct dwarf2_line_info best_loc;
d6658 1
a6658 1
  best_loc.line = INT_MAX;
d6720 2
a6721 2
      best_loc = vinsn->slots[i].loc.line < best_loc.line
	? vinsn->slots[i].loc : best_loc;
d6789 6
a6794 1
  xtensa_dwarf2_emit_insn (insn_size + extra_space, &best_loc);
@


1.45
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d5033 9
a5041 1
  float freq = get_subseg_target_freq (now_seg, now_subseg);
@


1.44
log
@        * config/tc-xtensa.h (resource_table): Change units to unsigned chars.
        * config/tc-xtensa.c (new_resource_table): Likewise.
        (resize_resource_table): Likewise.
        (release_resources): Fix assertion for unsigned values.
@
text
@d5057 1
a5057 1
  }
d5086 2
@


1.43
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d5791 1
a5791 1
  rt->units = (char **) xcalloc (cycles, sizeof (char *));
d5793 1
a5793 1
    rt->units[i] = (char *) xcalloc (nu, sizeof (char));
d5823 2
a5824 1
  rt->units = xrealloc (rt->units, sizeof (char *) * rt->allocated_cycles);
d5826 2
a5827 1
    rt->units[i] = xrealloc (rt->units[i], sizeof (char) * rt->num_units);
d5829 1
a5829 1
    rt->units[i] = xcalloc (rt->num_units, sizeof (char));
d5881 1
a5882 1
      assert (rt->units[stage + cycle][unit] >= 0);
@


1.42
log
@	* config/tc-xtensa.c (xg_assemble_vliw_tokens): Change subtraction
	to addition in argument to xtensa_dwarf2_emit_insn.
@
text
@d5549 1
a5549 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg)
@


1.41
log
@	* config/tc-xtensa.c (xtensa_insnbuf_set_operand): Clarify error
	message.
	(xtensa_mark_zcl_first_insns): Fix incorrect nesting of conditional
	for handling RELAX_CHECK_ALIGN_NEXT_OPCODE.
@
text
@d6796 1
a6796 1
  xtensa_dwarf2_emit_insn (insn_size - extra_space, &best_loc);
@


1.40
log
@	* config/tc-xtensa.c: Remove excess whitespace.
	* config/tc-xtensa.h: Likewise.
	* config/xtensa-istack.h: Likewise.
	* config/xtensa-relax.c: Likewise.
	* config/xtensa-relax.h: Likewise.
@
text
@d2710 4
a2713 2
		      _("operand %u is out of range for '%s'"), value,
		      xtensa_opcode_name (xtensa_default_isa, opcode));
d2716 4
a2719 2
		      _("operand %u is invalid for '%s'"), value,
		      xtensa_opcode_name (xtensa_default_isa, opcode));
d7142 3
a7144 5
		{
		  targ_frag->tc_frag_data.is_first_loop_insn = TRUE;
		  if (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)
		    frag_wane (fragP);
		}
@


1.39
log
@Update the address and phone number of the FSF
@
text
@d84 1
a84 1
   allows us to assert that we haven't crossed over into the 
d325 1
a325 1
     formats has a high freedom, as does an opcode that fits 
d327 1
a327 1
     restrictive is the opcode that fits only one slot in one 
d331 1
a331 1
     narrowest format, and widest format the op can be bundled in 
d847 1
a847 1
      
d860 1
a860 1
    case option_target_hardware: 
d953 2
a954 2
/* The "loops_ok" argument is provided to allow ignoring labels that 
   define loop ends.  This fixes a bug where the NOPs to align a 
d1147 1
a1147 1
     
d1157 1
a1157 1
    }    
d1215 1
a1215 1
      /* Have to flush pending output because a movi relaxed to an l32r 
d1930 1
a1930 1
	  saw_comma = FALSE; 
d1932 1
a1932 1
	  saw_arg = TRUE; 
d1949 1
a1949 1
    as_bad (_("missing argument"));  
d2049 1
a2049 1
  had_error = FALSE; 
d2995 1
a2995 1
   a single widening is allowed and the NARROW_ONLY argument is used to 
d3321 1
a3321 1
 
d3746 1
a3746 1
  if (is_next_frag_target (fragP->fr_next, target_frag) 
d4049 1
a4049 1
	  as_bad_where (frag_now->fr_file, frag_now->fr_line, 
d4206 1
a4206 1
  
d4327 1
a4327 1
  
d4369 1
a4369 1
  /* Sometimes an empty will end up here due storage allocation issues. 
d4406 1
a4406 1
  int fmt_size; 
d4427 1
a4427 1
  /* If during relaxation we have to pull an instruction out of a 
d4448 1
a4448 1
  
d4530 1
a4530 1
  /* Sometimes an empty will end up here due storage allocation issues. 
d4718 1
a4718 1
     after xtensa_end, so we can't use "use_transform" or 
d4804 1
a4804 1
  
d4806 1
a4806 1
    {  
d4844 1
a4844 1
  
d4846 1
a4846 1
    {  
d5264 1
a5264 1
  
d5336 1
a5336 1
	as_bad_where (fragP->fr_file, fragP->fr_line, 
d5763 2
a5764 2
/* The func unit stuff could be implemented as bit-vectors rather 
   than the iterative approach here.  If it ends up being too 
d5767 1
a5767 1
resource_table * 
d5795 1
a5795 1
void 
d5807 1
a5807 1
void 
d5827 1
a5827 1
bfd_boolean 
d5833 1
a5833 1
  for (i = 0; i < uses; i++) 
a5843 1
     
d5845 2
a5846 1
void 
d5852 1
a5852 1
  for (i = 0; i < uses; i++) 
d5856 2
a5857 2
      /* Note that this allows resources to be oversubscribed.  That's 
	 essential to the way the optional scheduler works. 
d5865 1
a5865 1
void 
d5871 1
a5871 1
  for (i = 0; i < uses; i++) 
d5879 1
a5879 1
     
d5884 1
a5884 1
int 
d5888 1
a5888 1
  return use->unit;  
d5892 1
a5892 1
int 
d5902 1
a5902 1
   instructions together.  It also doesn't check if the tinsns 
d5916 1
a5916 1
  if (rt == NULL) 
d5995 1
a5995 1
  if (resources_conflict (vinsn)) 
d6077 1
a6077 1
		    vinsn->slots[i].opcode 
d6093 1
a6093 1
  if (resources_conflict (vinsn)) 
d6228 1
a6228 1
   case C: t1 writes a register t2 writes (a register conflict within a 
d6328 1
a6328 1
	  if (t1_so != t2_so) 
d6336 1
a6336 1
	  
d6342 1
a6342 1
	  
d6345 1
a6345 1
	}      
d6351 1
a6351 1
  for (j = 0; j < t2_interfaces; j++) 
d6373 1
a6373 1
	  
d6376 1
a6376 1
	  
d6382 1
a6382 1
	  
d6388 1
a6388 1
	  
d6393 1
a6393 1
  
d6507 1
a6507 1
	  
d6515 1
a6515 1
	      
d6517 1
a6517 1
	      
d6582 2
a6583 2
     Because the scheduling and bundling characteristics of movi and 
     l32r or const16 are so different, we can do much better if we relax 
d6585 1
a6585 1
  if ((orig_insn->opcode == xtensa_movi_opcode 
d6598 1
a6598 1
      switch (insn->insn_type) 
d6721 1
a6721 1
      
d6723 1
a6723 1
      best_loc = vinsn->slots[i].loc.line < best_loc.line 
d6732 1
a6732 1
      
d6735 1
a6735 1
      
d6747 1
a6747 1
	frag_var (rs_machine_dependent, 0, 0, 
d6750 1
a6750 1
      
d6791 1
a6791 1
  
d6812 1
a6812 1
      if (tinsn->subtype || tinsn->symbol || tinsn->record_fix 
d6989 1
a6989 1
	  if (fragP->fr_type == rs_machine_dependent 
d7137 1
a7137 1
	      if (targ_frag) 
d7392 1
a7392 1
			  
d7464 1
a7464 1
      /* Empty frags created by the obstack allocation scheme 
d7907 1
a7907 1
  
d8027 1
a8027 1
     
d8030 1
a8030 1
     
d8033 1
a8033 1
     
d8036 1
a8036 1
  
d8077 1
a8077 1
  
d8292 1
a8292 1
  if (! fragP->tc_frag_data.relax_seen) 
d8479 1
a8479 1
      else 
d8520 1
a8520 1
      if (max_diff == 0) 
d8529 1
a8529 1
	     because there will be plenty of ways to align future 
d8541 1
a8541 1
	  if (address) 
d8582 1
a8582 1
      local_stretch_amount 
d8585 2
a8586 2
      global_stretch_amount 
	= bytes_to_stretch (this_frag, wide_nops, narrow_nops, 
d8588 3
a8590 3
      /* If the condition below is true, then the frag couldn't 
	 stretch the correct amount for the global case, so we just 
	 optimize locally.  We'll rely on the subsequent frags to get 
d8662 1
a8662 1
  
d8672 1
a8672 1
  
d8682 1
a8682 1
  
d8696 1
a8696 1
	case 3: 
d8710 1
a8710 1
	  /* We will need two nops.  Are there enough nops 
d8742 1
a8742 1
      /* We will need a NOP no matter what, but should we widen 
d9840 1
a9840 1
      while (search_frag) 
d9937 1
a9937 1
  bfd_boolean is_init = 
d9940 1
a9940 1
  bfd_boolean is_fini = 
d11453 1
a11453 1
  
@


1.38
log
@	* config/obj-ecoff.c (ecoff_frob_file_before_fix): Correct section
	list traversal.  Use bfd_section_list_prepend.
	* config/tc-mmix.c (mmix_frob_file): Don't needlessly iterate
	over the section list.
	* config/tc-xtensa.c (xtensa_remove_section): Delete.
	(xtensa_insert_section): Delete.
	(xtensa_move_seg_list_to_beginning): Use bfd_section_list_remove
	and bfd_section_list_prepend.
	(xtensa_reorder_seg_list): Use bfd_section_list_remove and
	bfd_section_list_insert_after.
@
text
@d18 2
a19 2
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,
   MA 02111-1307, USA.  */
@


1.37
log
@* config/obj-ecoff.c (ecoff_frob_file_before_fix): Fix invocations of bfd_section_list... macros.
* config/tc-mmix.c (mmix_frob_file): Likewise.
* config/tc-xtensa.c (xtensa_remove_section): Likewise.
	(xtensa_insert_section): Likewise.

* macro.c (macro_hash): Remove static.
* macro.h (macro_hash): Provide an external declaration.
@
text
@a9684 33
/* Remove the segment from the global sections list.  */

static void
xtensa_remove_section (segT sec)
{
  /* Handle brain-dead bfd_section_list_remove macro, which
     expect the address of the prior section's "next" field, not
     just the address of the section to remove.  */
  segT ps_next_ptr = stdoutput->sections;

  while (ps_next_ptr != sec && ps_next_ptr != NULL) 
    ps_next_ptr = ps_next_ptr->next;
  
  assert (ps_next_ptr != NULL);

  bfd_section_list_remove (stdoutput, ps_next_ptr);
}


static void
xtensa_insert_section (segT after_sec, segT sec)
{
  segT after_sec_next;

  if (after_sec == NULL)
    after_sec_next = stdoutput->sections;
  else
    after_sec_next = after_sec->next;

  bfd_section_list_insert_after (stdoutput, after_sec_next, sec);
}


d9695 5
a9699 3
      xtensa_remove_section (literal_section);
      xtensa_insert_section (NULL, literal_section);

d9865 2
a9866 2
	  xtensa_remove_section (literal_section);
	  xtensa_insert_section (after, literal_section);
@


1.36
log
@	* config/tc-xtensa.c (LOOKAHEAD_ALIGNER): Delete macro.
	(future_alignment_required): Remove ifdefs that use it.
@
text
@d9693 1
d9695 2
a9696 3
  segT *ps_next_ptr = &stdoutput->sections;
  while (*ps_next_ptr != sec && *ps_next_ptr != NULL) 
    ps_next_ptr = &(*ps_next_ptr)->next;
d9698 1
a9698 1
  assert (*ps_next_ptr != NULL);
d9707 2
a9708 1
  segT *after_sec_next;
d9710 1
a9710 1
    after_sec_next = &stdoutput->sections;
d9712 1
a9712 1
    after_sec_next = &after_sec->next;
d9714 1
a9714 1
  bfd_section_list_insert (stdoutput, after_sec_next, sec);
@


1.35
log
@	* config/tc-xtensa.c (xg_get_build_instr_size): Remove.
	(xg_is_narrow_insn, xg_expand_narrow): Remove.  Merge into...
	(xg_is_single_relaxable_insn): ...here.  Add "targ" and "narrow_only"
	parameters.
	(xg_assembly_relax, xg_find_narrowest_format, relaxation_requirements,
	convert_frag_narrow): Use new version of xg_is_single_relaxable_insn.
@
text
@a8494 5
/* Undefine LOOKAHEAD_ALIGNER to get the older behavior.
   I'll leave this in until I am more confident this works.  */

#define LOOKAHEAD_ALIGNER 1

d8522 1
a8522 1
#ifdef LOOKAHEAD_ALIGNER
d8571 1
a8571 1
#endif /* LOOKAHEAD_ALIGNER */
a8584 1
#ifdef LOOKAHEAD_ALIGNER
d8596 1
a8596 3
#else /* ! LOOKAHEAD_ALIGNER */
      stretch_amount = local_stretch_amount;
#endif /* ! LOOKAHEAD_ALIGNER */
@


1.34
log
@(get_aligned_diff): Change type of branch_align to offsetT so that its
signedness matches that of target_size.
@
text
@d438 2
d2989 9
a2997 6
static int
xg_get_build_instr_size (BuildInstr *insn)
{
  assert (insn->typ == INSTR_INSTR);
  return xg_get_single_size (insn->opcode);
}
d2999 2
a3000 3

static bfd_boolean
xg_is_narrow_insn (TInsn *insn)
d3004 2
a3005 1
  int num_match = 0;
d3014 3
a3016 1
	  && is_unique_insn_expansion (rule))
d3018 3
a3020 10
	  /* It only generates one instruction... */
	  assert (insn->insn_type == ITYPE_INSN);
	  /* ...and it is a larger instruction.  */
	  if (xg_get_single_size (insn->opcode)
	      < xg_get_build_instr_size (rule->to_instr))
	    {
	      num_match++;
	      if (num_match > 1)
		return FALSE;
	    }
d3023 2
a3024 2
  return (num_match == 1);
}
d3026 3
a3028 30

static bfd_boolean
xg_is_single_relaxable_insn (TInsn *insn)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int num_match = 0;
  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule)
	  && is_unique_insn_expansion (rule))
	{
	  /* It only generates one instruction... */
	  assert (insn->insn_type == ITYPE_INSN);
	  /* ... and it is a larger instruction.  */
	  if (xg_get_single_size (insn->opcode)
	      <= xg_get_build_instr_size (rule->to_instr))
	    {
	      num_match++;
	      if (num_match > 1)
		return FALSE;
	    }
	}
    }
  return (num_match == 1);
a3555 28

static bfd_boolean
xg_expand_narrow (TInsn *targ, TInsn *insn)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;

  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      if (xg_instruction_matches_rule (insn, rule)
	  && is_unique_insn_expansion (rule))
	{
	  /* Is it a larger instruction?  */
	  if (xg_get_single_size (insn->opcode)
	      <= xg_get_build_instr_size (rule->to_instr))
	    {
	      xg_build_to_insn (targ, insn, rule->to_instr);
	      return FALSE;
	    }
	}
    }
  return TRUE;
}

d3592 1
a3592 1
  while (xg_is_single_relaxable_insn (&current_insn))
a3593 4
      int error_val = xg_expand_narrow (&single_target, &current_insn);

      assert (!error_val);

d6436 2
a6437 2
		      && xg_is_narrow_insn (&v_copy.slots[slot])
		      && !xg_expand_narrow (&widened, &v_copy.slots[slot])
a6440 11
		      /* The xg_is_narrow clause requires some explanation:

			 addi can be "widened" to an addmi, which is then
			 expanded to an addmi/addi pair if the immediate
			 requires it, but here we must have a single widen
			 only.

			 xg_is_narrow tells us that addi isn't really
			 narrow.  The widen_spec_list says that there are
			 other cases.  */

d6481 1
a6481 1
	  if (xg_is_narrow_insn (tinsn)
d9079 1
a9079 1
  int size, old_size, diff, error_val;
d9114 1
a9114 2
  error_val = xg_expand_narrow (&single_target, &tinsn);
  if (error_val)
@


1.33
log
@        * config/tc-xtensa.c (get_aligned_diff): Handle target_size larger
        than the section alignment.
@
text
@d8182 1
a8182 1
  addressT branch_align;
@


1.32
log
@	* config/tc-xtensa.h (struct xtensa_frag_type): Add lit_frchain field.
	* config/tc-xtensa.c (xg_translate_sysreg_op,
	xtensa_translate_old_userregs_ops,
	xtensa_find_unaligned_branch_targets,
	xtensa_find_unaligned_loops, xtensa_fix_close_loop_end_frags,
	relax_frag_add_nop): Support 64-bit host.
	(xtensa_mark_literal_pool_location, xtensa_move_literals): Use
	tc_frag_data lit_frchain and lit_seg fields instead of fr_var.
@
text
@d8193 3
@


1.31
log
@	* config/tc-xtensa.c (check_t1_t2_reads_and_writes): Fix typo.
@
text
@d2250 1
a2250 1
		  val, opname);
d2319 1
a2319 1
		  val, opname);
d4648 2
a4649 4
  /* We stash info in the fr_var of these frags
     so we can later move the literal's fixes into this
     frchain's fix list.  We can use fr_var because fr_var's
     interpretation depends solely on the fr_type and subtype.  */
d4651 2
a4652 1
  frag_variant (rs_machine_dependent, 0, (int) frchain_now,
d4655 2
a4656 1
  frag_variant (rs_machine_dependent, 0, (int) now_seg,
d4885 1
a4885 1
			       op_size, frag->fr_address);
d4924 1
a4924 1
			       op_size, frag->fr_address);
d7465 1
a7465 1
				      fragP->fr_var, length);
d8413 1
a8413 1
      as_fatal (_("fr_var (%ld) < length (%d)"), fragP->fr_var, length);
d9872 2
a9873 4
	      /* Note that we set this fr_var to be a fix
		 chain when we created the literal pool location
		 as RELAX_LITERAL_POOL_BEGIN.  */
	      frchain_to = (frchainS *) literal_pool->fr_var;
d9880 1
a9880 1
	  dest_seg = (segT) insert_after->fr_next->fr_var;
@


1.30
log
@	* config/tc-xtensa.c (xtensa_create_xproperty_segments): Skip
	SEC_MERGE sections.
@
text
@d6424 1
a6424 1
	  int t1_class = xtensa_interface_class_id (isa, t2_int);
@


1.29
log
@	* config/tc-xtensa.c (branch_align_power): New.
	(xtensa_find_unaligned_branch_targets, get_aligned_diff,
	future_alignment_required): Use branch_align_power to check section
	alignment as well as xtensa_fetch_width when aligning branch targets.
@
text
@d10396 3
a10398 3
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
@


1.28
log
@	* config/tc-xtensa.c: Warning fixes throughout.
	(xtensa_fetch_width): Change to unsigned.
	(assemble_nop, xtensa_find_unaligned_branch_targets,
	xtensa_find_unaligned_loops, xg_assemble_vliw_tokens,
	is_narrow_branch_guaranteed_in_range, xtensa_fix_close_loop_end_frags,
	min_bytes_to_other_loop_end, unrelaxed_frag_min_size,
	unrelaxed_frag_max_size, xtensa_fix_short_loop_frags,
	count_insns_to_loop_end, unrelaxed_frag_min_insn_count,
	get_text_align_max_fill_size, get_text_align_nop_count,
	get_text_align_nth_nop_size, get_noop_aligned_address,
	get_aligned_diff, convert_frag_align_next_opcode,
	convert_frag_immed_finish_loop, xtensa_create_property_segments,
	xtensa_create_xproperty_segments, xt_block_aligned_size): Clean up
	types, avoiding size_t and using offsetT and addressT appropriately.
	(get_text_align_power): Clean up types.  Avoid incorrect bound.
	(get_text_align_fill_size): Clean up types.  Restructure for clarity.
@
text
@d451 1
d4873 1
a4873 1
	      addressT frag_addr;
d4880 3
a4882 2
	      frag_addr = frag->fr_address % xtensa_fetch_width;
	      if (frag_addr + op_size > xtensa_fetch_width)
d8011 21
d8182 1
d8191 2
a8192 1
      align_power = get_text_align_power (xtensa_fetch_width);
d8196 2
a8197 3
      *max_diff = (opt_diff + xtensa_fetch_width
		   - (target_size + ((address + opt_diff)
				     % xtensa_fetch_width)));
d8610 1
a8610 1
	  if (glob_pad || glob_widens >= (int) xtensa_fetch_width)
@


1.27
log
@	* config/tc-xtensa.c (do_align_targets): Update comment.
	(xtensa_frob_label): Compute "freq" before possibly switching frags.
	Insert a LOOP_END frag before every loop target, and do not overload
	DESIRE_ALIGN_IF_TARGET frags with loop end information.
	(xg_assemble_vliw_tokens): Use do_align_targets.
	(xtensa_fix_target_frags): Remove code to convert a
	DESIRE_ALIGN_IF_TARGET frag to a LOOP_END frag when there is a
	negatable branch at the end of a loop.
	(frag_can_negate_branch): Delete.
@
text
@d79 1
a79 1
size_t xtensa_fetch_width = XCHAL_INST_FETCH_WIDTH;
d449 2
a450 2
static size_t get_text_align_power (int);
static addressT get_text_align_max_fill_size (int, bfd_boolean, bfd_boolean);
d2527 1
a2527 1
  xtensa_insnbuf_from_chars (isa, insnbuf, buf, 0);
d4294 2
a4295 1
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf, 0);
d4472 2
a4473 1
  xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal, 0);
d4711 1
a4711 1
assemble_nop (size_t size, char *buf)
d4722 2
a4723 1
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf, 0);
d4872 1
a4872 1
	      int frag_addr;
d4875 2
a4876 1
	      xtensa_insnbuf_from_chars (isa, insnbuf, frag->fr_literal, 0);
d4880 1
a4880 1
	      if (frag_addr + op_size > (int) xtensa_fetch_width)
d4910 1
a4910 1
	      int frag_addr;
d4913 2
a4914 1
	      xtensa_insnbuf_from_chars (isa, insnbuf, frag->fr_literal, 0);
d4919 1
a4919 1
	      if (frag_addr + op_size > (signed) xtensa_fetch_width)
d4953 1
a4953 1
  xtensa_insnbuf_from_chars (isa, insnbuf, fixpos, 0);
d4973 1
a4973 1
  xtensa_insnbuf_to_chars (isa, insnbuf, fixpos, 0);
d5449 1
a5449 1
  xtensa_insnbuf_from_chars (isa, insnbuf, insn_p, 0);
d6014 1
a6014 1
  int line;
d6799 1
a6799 1
      size_t max_fill;
d6849 1
a6849 1
      f = (char *) frag_more (insn_size + extra_space);
d6858 1
a6858 1
  xtensa_insnbuf_to_chars (isa, vinsn->insnbuf, f, 0);
d7156 1
a7156 1
static size_t unrelaxed_frag_max_size (fragS *);
d7164 1
a7164 1
  size_t max_distance = expr->X_add_number;
d7278 2
a7279 1
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset], 0);
d7307 2
a7308 1
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset], 0);
d7395 2
a7396 1
static size_t min_bytes_to_other_loop_end (fragS *, fragS *, offsetT, size_t);
d7441 2
a7442 2
	      size_t min_bytes;
	      size_t bytes_added = 0;
d7484 1
a7484 1
static size_t unrelaxed_frag_min_size (fragS *);
d7486 1
a7486 1
static size_t
d7490 1
a7490 1
			     size_t max_size)
d7492 1
a7492 1
  size_t offset = 0;
d7512 1
a7512 1
static size_t
d7515 1
a7515 1
  size_t size = fragP->fr_fix;
d7517 1
a7517 1
  /* add fill size */
d7525 1
a7525 1
static size_t
d7528 1
a7528 1
  size_t size = fragP->fr_fix;
d7578 1
a7578 1
static size_t count_insns_to_loop_end (fragS *, bfd_boolean, size_t);
d7626 1
a7626 3
	      size_t insn_count =
		count_insns_to_loop_end (fragP->fr_next, TRUE, 3);
	      if (insn_count < 3
d7644 1
a7644 1
static size_t unrelaxed_frag_min_insn_count (fragS *);
d7646 1
a7646 1
static size_t
d7649 1
a7649 1
			 size_t max_count)
d7652 1
a7652 1
  size_t insn_count = 0;
d7680 1
a7680 1
static size_t
d7685 1
a7685 1
  size_t insn_count = 0;
d7699 2
a7700 1
      xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal + offset, 0);
d7753 2
a7754 1
      xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal + offset, 0);
d7782 1
a7782 1
  int line;
d7927 2
a7928 2
static size_t
get_text_align_power (int target_size)
d7930 5
a7934 2
  size_t i = 0;
  for (i = 0; i < sizeof (size_t); i++)
d7936 2
a7937 2
      if (target_size <= (1 << i))
	return i;
d7939 1
a7939 2
  assert (0);
  return 0;
d7943 1
a7943 1
static addressT
d7957 5
a7961 1
/* get_text_align_fill_size ()
d7963 1
a7963 22
   Desired alignments:
      give the address
      target_size = size of next instruction
      align_pow = get_text_align_power (target_size).
      use_nops = 0
      use_no_density = 0;
   Loop alignments:
      address = current address + loop instruction size;
      target_size = 3 (for 2 or 3 byte target)
                  = 4 (for 4 byte target)
                  = 8 (for 8 byte target)
      align_pow = get_text_align_power (target_size);
      use_nops = 1
      use_no_density = set appropriately
   Text alignments:
      address = current address + loop instruction size;
      target_size = 0
      align_pow = get_text_align_power (target_size);
      use_nops = 0
      use_no_density = 0.  */

static addressT
d7970 2
a7971 1
  /* Input arguments:
d7973 2
a7974 28
     align_pow: log2 (required alignment).

     target_size: alignment must allow the new_address and
     new_address+target_size-1.

     use_nops: if TRUE, then we can only use 2- or 3-byte nops.

     use_no_density: if use_nops and use_no_density, we can only use
     3-byte nops.

     Usually the align_pow is the power of 2 that is greater than 
     or equal to the target_size.  This handles the 2-byte, 3-byte 
     and 8-byte instructions.

     Two cases:

     (1) aligning an instruction properly, but without using NOPs.
       E.G.: a 3-byte instruction can go on any address where address mod 4
       is zero or one.  The aligner uses this case to find the optimal
       number of fill bytes for relax_frag_for_align.

     (2) aligning an instruction properly, but where we might need to use
       extra NOPs.  E.G.: when the aligner couldn't find enough widenings
       or similar to get the optimal location.  */

  size_t alignment = (1 << align_pow);

  assert (target_size != 0);
d7978 2
a7979 9
      unsigned fill_bytes;
      for (fill_bytes = 0; fill_bytes < alignment; fill_bytes++)
	{
	  addressT end_address = address + target_size - 1 + fill_bytes;
	  addressT start_address = address + fill_bytes;
	  if ((end_address >> align_pow) == (start_address >> align_pow))
	    return fill_bytes;
	}
      assert (0);
d7981 1
a7981 5

  /* This is the slightly harder case.  */
  assert ((int) alignment >= target_size);
  assert (target_size > 0);
  if (!use_no_density)
d7983 4
a7986 9
      size_t i;
      for (i = 0; i < alignment * 2; i++)
	{
	  if (i == 1)
	    continue;
	  if ((address + i) >> align_pow
	      == (address + i + target_size - 1) >> align_pow)
	    return i;
	}
d7990 4
a7993 1
      size_t i;
d7995 8
a8002 7
      /* Can only fill multiples of 3.  */
      for (i = 0; i <= alignment * 3; i += 3)
	{
	  if ((address + i) >> align_pow
	      == (address + i + target_size - 1) >> align_pow)
	    return i;
	}
d8011 2
a8012 2
static size_t
get_text_align_nop_count (size_t fill_size, bfd_boolean use_no_density)
d8014 2
a8015 1
  size_t count = 0;
d8026 1
a8026 1
      size_t insn_size = 3;
d8037 3
a8039 3
static size_t
get_text_align_nth_nop_size (size_t fill_size,
			     size_t n,
d8042 1
a8042 3
  size_t count = 0;

  assert (get_text_align_nop_count (fill_size, use_no_density) > n);
d8047 2
d8051 1
a8051 1
      size_t insn_size = 3;
d8084 1
a8084 1
  size_t fill_size = 0;
d8088 1
a8088 1
  size_t alignment;
d8122 2
a8123 4
  alignment = get_text_align_power (first_insn_size);

  /* Is now_seg valid?  */
  record_alignment (now_seg, alignment);
d8126 2
a8127 3
    (address + pre_opcode_bytes,
     get_text_align_power (first_insn_size),
     first_insn_size, TRUE, fragP->tc_frag_data.is_no_density);
d8150 2
a8151 2
static addressT
get_aligned_diff (fragS *fragP, addressT address, addressT *max_diff)
d8157 2
a8158 2
  int text_align_power;
  addressT opt_diff;
d8167 2
a8168 2
      text_align_power = get_text_align_power (xtensa_fetch_width);
      opt_diff = get_text_align_fill_size (address, text_align_power,
d8171 3
a8173 2
      *max_diff = opt_diff + xtensa_fetch_width
	- (target_size + ((address + opt_diff) % xtensa_fetch_width));
d8198 2
a8199 2
      text_align_power = get_text_align_power (target_size),
      opt_diff = get_text_align_fill_size (target_address, text_align_power,
d8234 2
a8235 1
  int line, lit_size;
d8286 2
a8287 1
      xtensa_insnbuf_from_chars (isa, vbuf, fragP->fr_opcode, 0);
d8579 1
a8579 1
	  unsigned int glob_widens = 0;
d8586 1
a8586 1
	  if (glob_pad || (glob_widens >= xtensa_fetch_width))
d8982 1
a8982 1
  int line;
d9006 2
a9007 1
      xtensa_insnbuf_from_chars (isa, vbuf, fragp->fr_opcode, 0);
a9091 2
  size_t i;

d9094 2
a9095 1
  size_t fill_size, nop_count;
d9103 1
a9103 1
  for (i = 0; i < nop_count; i++)
d9105 2
a9106 2
      size_t nop_size;
      nop_size = get_text_align_nth_nop_size (fill_size, i, use_no_density);
d9259 2
a9260 1
      xtensa_insnbuf_to_chars (isa, orig_vinsn.insnbuf, fr_opcode, 0);
d9405 1
a9405 1
					   immed_instr, 0);
d9534 1
a9534 1
  size_t target_count;
d9599 2
a9600 1
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addi_offset, 0);
d9604 2
a9605 1
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addmi_offset, 0);
d10276 1
a10276 1
	  size_t rec_size;
d10293 1
a10293 1
	      size_t frag_size;
d10408 1
a10408 1
	  size_t rec_size;
d10426 1
a10426 1
	      size_t frag_size;
d10790 1
a10790 1
  size_t align_bits;
d11225 1
a11225 1
  int line;
d11318 2
a11319 1
      int rc, line;
d11683 1
a11683 1
  xtensa_insnbuf_from_chars (isa, insnbuf, f, 0);
@


1.26
log
@	* config/tc-xtensa.c (use_longcalls): Delete.
	(xg_symbolic_immeds_fit): Check for direct calls and return TRUE if
	the use_longcalls flag is set.  Do this before checking the segment.
	(xg_expand_assembly_insn): Rearrange to use new do_expand flag.  Never
	expand direct calls at this point.
	(xtensa_set_frag_assembly_state): Set use_longcalls flag.
	(xtensa_find_unmarked_state_frags): Likewise.
	(md_assemble): Do not disable longcalls by setting is_specific_opcode.
	(xg_assemble_vliw_tokens): Switch frags when use_longcalls changes.
	(convert_frag_immed): Remove unnecessary check of is_specific_opcode.
	* config/tc-xtensa.h (xtensa_frag_type): Add use_longcalls flag.
@
text
@d1036 3
a1038 2
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
d4529 1
a4529 1
  if (align_targets) 
d5081 2
d5093 3
a5095 2
  if (symbol_get_tc (sym)->is_loop_target
      && (get_last_insn_flags (now_seg, now_subseg)
d5097 9
a5105 1
    as_bad (_("invalid last instruction for a zero-overhead loop"));
a5112 1
      float freq = get_subseg_target_freq (now_seg, now_subseg);
a5114 15
      /* The only time this type of frag grows is when there is a
	 negatable branch that needs to be relaxed as the last
	 instruction in a zero-overhead loop.  Because alignment frags
	 are so common, marking them all as possibly growing four
	 bytes makes any worst-case analysis appear much worse than it
	 is.  So, we make fr_var not actually reflect the amount of
	 memory allocated at the end of this frag, but rather the
	 amount of memory this frag might grow.  The "4, 0" below
	 allocates four bytes at the end of the frag for room to grow
	 if we need to relax a loop end with a NOP.  Frags prior to
	 this one might grow to align this one, but the frag itself
	 won't grow unless it meets the condition above.  */

#define RELAX_LOOP_END_BYTES 4

d5116 1
a5116 1
		RELAX_LOOP_END_BYTES, (int) freq,
d6936 1
a6936 1
      else if (is_branch && align_targets)
d7063 1
a7063 5
   If the next fragment starts with a loop target, AND the previous
   fragment can be expanded to negate the branch, convert this to a
   RELAX_LOOP_END.  Otherwise, convert to a .fill 0.  */

static bfd_boolean frag_can_negate_branch (fragS *);
a7073 1
      bfd_boolean prev_frag_can_negate_branch = FALSE;
d7082 1
a7082 18
	      if (next_frag_is_loop_target (fragP))
		{
		  if (prev_frag_can_negate_branch)
		    {
		      fragP->fr_subtype = RELAX_LOOP_END;
		      /* See the comment near the frag_var with a
			 RELAX_DESIRE_ALIGN to see why we do this.  */
		      fragP->fr_var = RELAX_LOOP_END_BYTES;
		    }
		  else
		    {
		      if (next_frag_is_branch_target (fragP))
			fragP->fr_subtype = RELAX_DESIRE_ALIGN;
		      else
			frag_wane (fragP);
		    }
		}
	      else if (next_frag_is_branch_target (fragP))
a7086 4
	  if (fragP->fr_fix != 0)
	    prev_frag_can_negate_branch = FALSE;
	  if (frag_can_negate_branch (fragP))
	    prev_frag_can_negate_branch = TRUE;
a7091 24
static bfd_boolean
frag_can_negate_branch (fragS *fragP)
{
  xtensa_isa isa = xtensa_default_isa;
  vliw_insn vinsn;
  int slot;

  if (fragP->fr_type != rs_machine_dependent
      || fragP->fr_subtype != RELAX_SLOTS)
    return FALSE;

  vinsn_from_chars (&vinsn, fragP->fr_opcode);

  for (slot = 0; slot < xtensa_format_num_slots (isa, vinsn.format); slot++)
    {
      if ((fragP->tc_frag_data.slot_subtypes[slot] == RELAX_IMMED)
	  && xtensa_opcode_is_branch (isa, vinsn.slots[slot].opcode) == 1)
	return TRUE;
    }

  return FALSE;
}


@


1.25
log
@	* config/tc-xtensa.c (md_apply_fix3): Recognize XTENSA_PLT relocations.
@
text
@a1033 10
use_longcalls (void)
{
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
  assert (!past_xtensa_end);
  return directive_state[directive_longcalls] && use_transform ();
}


static bfd_boolean
d3305 1
a3305 1
	  /* We only allow symbols for pc-relative stuff.
d3307 2
a3308 1
	  if (pc_frag == 0)
d3311 2
a3312 4
	  /* If it is PC-relative and the symbol is not in the same 
	     segment as the PC.... */
	  if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 0
	      || S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
d3315 12
a3326 5
	  /* If it is a weak symbol, then assume it won't reach.  This will
	     only affect calls when longcalls are enabled, because if
	     longcalls are disabled, then the call is marked as a specific
	     opcode.  */
	  if (S_IS_WEAK (expr->X_add_symbol))
d3644 1
a3644 1
  /* Walk through all of the single instruction expansions. */
d3942 2
a3943 3
   tokens into the stack or if we can relax it at assembly time, place
   multiple instructions/literals onto the stack.  Return FALSE if no
   error.  */
d3950 2
a3976 1

a3978 18
  /* Cases:

     Instructions with all constant immeds:
     Assemble them and relax the instruction if possible.
     Give error if not possible; no fixup needed.

     Instructions with symbolic immeds:
     Assemble them with a Fix up (that may cause instruction expansion).
     Also close out the fragment if the fixup may cause instruction expansion.

     There are some other special cases where we need alignment.
     1) before certain instructions with required alignment (OPCODE_ALIGN)
     2) before labels that have jumps (LABEL_ALIGN)
     3) after call instructions (RETURN_ALIGN)
        Multiple of these may be possible on the same fragment.
	If so, make sure to satisfy the required alignment.
	Then try to get the desired alignment.  */

d3982 10
a3991 5
  if (orig_insn->is_specific_opcode || !use_transform ())
    {
      istack_push (istack, orig_insn);
      return FALSE;
    }
d3995 5
a3999 4
      if (tinsn_has_complex_operands (orig_insn))
	xg_assembly_relax (istack, orig_insn, 0, 0, 0, 0, 0);
      else
	istack_push (istack, orig_insn);
d4001 5
d4007 1
a4007 6
    {
      if (xg_immeds_fit (orig_insn))
	istack_push (istack, orig_insn);
      else
	xg_assembly_relax (istack, orig_insn, 0, 0, 0, 0, 0);
    }
d4776 2
d4836 2
a5290 5
  /* Special case: The call instructions should be marked "specific opcode"
     to keep them from expanding.  */
  if (!use_longcalls () && is_direct_call_opcode (orig_insn.opcode))
    orig_insn.is_specific_opcode = TRUE;

d6746 2
d6865 3
a6867 3
      frag_now->tc_frag_data.slot_symbols[slot] =  tinsn->symbol;
      frag_now->tc_frag_data.slot_sub_symbols[slot] =  tinsn->sub_symbol;
      frag_now->tc_frag_data.slot_offsets[slot] =  tinsn->offset;
d9359 1
a9359 1
  else if (!orig_tinsn.is_specific_opcode)
@


1.24
log
@        * config/tc-xtensa.c (xg_apply_tentative_value): Rename to
        xg_apply_fix_value and return a value to indicate success.
        (md_pcrel_from): Skip check of fx_done.  Return 0 if not PC-relative.
        (xtensa_force_relocation): Remove checks for VTABLE relocs.
        (xtensa_validate_fix_sub): New.
        (xtensa_fix_adjustable): Remove check for external or weak symbols.
        (tc_gen_reloc): Move code to handle difference of symbols and code to
        apply tentative fix values to ...
        (md_apply_fix3): ...here.  Enable standard overflow checks for simple
        8, 16, and 32 bit relocations.  Apply fixes for slot-specific
        relocations when linkrelax flag is not set.
        * config/tc-xtensa.h (xtensa_validate_fix_sub): Add prototype.
        (TC_FORCE_RELOCATION_SUB_SAME, TC_VALIDATE_FIX_SUB): Define.
@
text
@d5714 1
@


1.23
log
@        * config/tc-xtensa.c (finish_vinsn): Include the last instruction slot
        when checking if xg_resolve_literals needs to be called.
        * config/tc-xtensa.h: Fix spelling typo in a comment.
@
text
@d4937 2
a4938 2
static void
xg_apply_tentative_value (fixS *fixP, valueT val)
d4970 1
a4970 3
     of a CONST16 operand.  The code in tc_gen_reloc does not decode
     the opcodes so it is more convenient to detect this special case
     here.  */
d4972 1
a4972 1
    return;
d4980 2
a5454 3
  if (fixP->fx_done)
    return addr;

d5456 1
a5456 1
    return addr;
d5477 2
a5478 1
  /* Check for "alternate" relocation (operand not specified).  */
d5485 1
a5485 1
      return addr;
d5497 1
a5497 1
      return addr;
d5509 2
a5510 1
   {
a5525 2
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
d5539 27
a5612 4
  if (fixP->fx_addsy
      && (S_IS_EXTERNAL (fixP->fx_addsy) || S_IS_WEAK (fixP->fx_addsy)))
    return 0;

d5618 1
a5618 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
d5620 4
a5623 1
  if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
d5625 19
a5643 1
      char *const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
d5645 20
a5664 1
      switch (fixP->fx_r_type)
d5666 1
a5666 1
	case BFD_RELOC_XTENSA_ASM_EXPAND:
d5668 6
a5673 1
	  break;
d5675 38
a5712 4
	case BFD_RELOC_XTENSA_ASM_SIMPLIFY:
	  as_bad (_("unhandled local relocation fix %s"),
		  bfd_get_reloc_code_name (fixP->fx_r_type));
	  break;
d5714 18
a5731 7
	case BFD_RELOC_32:
	case BFD_RELOC_16:
	case BFD_RELOC_8:
	  /* The only one we support that isn't an instruction field.  */
	  md_number_to_chars (fixpos, *valP, fixP->fx_size);
	  fixP->fx_done = 1;
	  break;
d5733 4
a5736 4
	case BFD_RELOC_VTABLE_INHERIT:
	case BFD_RELOC_VTABLE_ENTRY:
	  fixP->fx_done = 0;
	  break;
d5738 3
a5740 4
	default:
	  as_bad (_("unhandled local relocation fix %s"),
		  bfd_get_reloc_code_name (fixP->fx_r_type));
	}
d5799 1
a5799 1
tc_gen_reloc (asection *section, fixS *fixp)
a5801 1
  bfd_boolean apply_tentative_value = FALSE;
d5812 1
a5812 122
  if (linkrelax && fixp->fx_subsy
      && (fixp->fx_r_type == BFD_RELOC_8
	  || fixp->fx_r_type == BFD_RELOC_16
	  || fixp->fx_r_type == BFD_RELOC_32))
    {
      int diff_size = 0;
      bfd_vma diff_value, diff_mask = 0;

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_8:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF8;
	  diff_size = 1;
	  diff_mask = 0xff;
	  break;
	case BFD_RELOC_16:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF16;
	  diff_size = 2;
	  diff_mask = 0xffff;
	  break;
	case BFD_RELOC_32:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF32;
	  diff_size = 4;
	  diff_mask = 0xffffffff;
	  break;
	default:
	  break;
	}

      /* An offset is only allowed when it results from adjusting a local
	 symbol into a section-relative offset.  If the offset came from the
	 original expression, tc_fix_adjustable will have prevented the fix
	 from being converted to a section-relative form so that we can flag
	 the error here.  */
      if (fixp->fx_offset != 0 && !symbol_section_p (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("cannot represent subtraction with an offset"));
	  free (reloc->sym_ptr_ptr);
	  free (reloc);
	  return NULL;
	}

      assert (S_GET_SEGMENT (fixp->fx_addsy)
	      == S_GET_SEGMENT (fixp->fx_subsy));

      diff_value = (S_GET_VALUE (fixp->fx_addsy) + fixp->fx_offset
		    - S_GET_VALUE (fixp->fx_subsy));

      /* Check for overflow.  */
      if ((diff_value & ~diff_mask) != 0)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("value of %ld too large"), diff_value);
	  free (reloc->sym_ptr_ptr);
	  free (reloc);
	  return NULL;
	}

      md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
			  diff_value, diff_size);
      reloc->addend = fixp->fx_offset - diff_value;
    }
  else
    {
      reloc->addend = fixp->fx_offset;

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_XTENSA_SLOT0_OP:
	case BFD_RELOC_XTENSA_SLOT1_OP:
	case BFD_RELOC_XTENSA_SLOT2_OP:
	case BFD_RELOC_XTENSA_SLOT3_OP:
	case BFD_RELOC_XTENSA_SLOT4_OP:
	case BFD_RELOC_XTENSA_SLOT5_OP:
	case BFD_RELOC_XTENSA_SLOT6_OP:
	case BFD_RELOC_XTENSA_SLOT7_OP:
	case BFD_RELOC_XTENSA_SLOT8_OP:
	case BFD_RELOC_XTENSA_SLOT9_OP:
	case BFD_RELOC_XTENSA_SLOT10_OP:
	case BFD_RELOC_XTENSA_SLOT11_OP:
	case BFD_RELOC_XTENSA_SLOT12_OP:
	case BFD_RELOC_XTENSA_SLOT13_OP:
	case BFD_RELOC_XTENSA_SLOT14_OP:
	  /* As a special case, the immediate value for a CONST16 opcode
	     should not be applied, since this kind of relocation is
	     handled specially for CONST16 and is not really PC-relative.
	     Rather than decode the opcode here, just wait and handle it
	     in xg_apply_tentative_value.  */
	  apply_tentative_value = TRUE;
	  break;

	case BFD_RELOC_XTENSA_SLOT0_ALT:
	case BFD_RELOC_XTENSA_SLOT1_ALT:
	case BFD_RELOC_XTENSA_SLOT2_ALT:
	case BFD_RELOC_XTENSA_SLOT3_ALT:
	case BFD_RELOC_XTENSA_SLOT4_ALT:
	case BFD_RELOC_XTENSA_SLOT5_ALT:
	case BFD_RELOC_XTENSA_SLOT6_ALT:
	case BFD_RELOC_XTENSA_SLOT7_ALT:
	case BFD_RELOC_XTENSA_SLOT8_ALT:
	case BFD_RELOC_XTENSA_SLOT9_ALT:
	case BFD_RELOC_XTENSA_SLOT10_ALT:
	case BFD_RELOC_XTENSA_SLOT11_ALT:
	case BFD_RELOC_XTENSA_SLOT12_ALT:
	case BFD_RELOC_XTENSA_SLOT13_ALT:
	case BFD_RELOC_XTENSA_SLOT14_ALT:
	case BFD_RELOC_XTENSA_ASM_EXPAND:
	case BFD_RELOC_32:
	case BFD_RELOC_XTENSA_PLT:
	case BFD_RELOC_VTABLE_INHERIT:
	case BFD_RELOC_VTABLE_ENTRY:
	  break;

	case BFD_RELOC_XTENSA_ASM_SIMPLIFY:
	  as_warn (_("emitting simplification relocation"));
	  break;

	default:
	  as_warn (_("emitting unknown relocation"));
	}
    }
a5828 18
  /* Write the tentative value of a PC-relative relocation to a local symbol
     into the instruction.  The value will be ignored by the linker, and it
     makes the object file disassembly readable when the linkrelax flag is
     set and all branch targets are encoded in relocations.  */

  if (linkrelax && apply_tentative_value && fixp->fx_pcrel)
    {
      valueT val;
      assert (fixp->fx_addsy);
      if (S_GET_SEGMENT (fixp->fx_addsy) == section && !fixp->fx_plt
	  && !S_FORCE_RELOC (fixp->fx_addsy, 1))
	{
	  val = (S_GET_VALUE (fixp->fx_addsy) + fixp->fx_offset
		 - md_pcrel_from (fixp));
	  xg_apply_tentative_value (fixp, val);
	}
    }

@


1.22
log
@update copyright dates
@
text
@d6148 1
a6148 1
	  for (j = 0; j < slotstack.ninsn - 1; j++)
d6158 1
d6161 2
a6162 1
		  emit_single_op (insn);
@


1.22.2.1
log
@	* config/tc-xtensa.c (finish_vinsn): Include the last instruction slot
	when checking if xg_resolve_literals needs to be called.
	* config/tc-xtensa.h: Fix spelling typo in a comment.
@
text
@d6148 1
a6148 1
	  for (j = 0; j < slotstack.ninsn; j++)
a6157 1
		  assert (insn->insn_type == ITYPE_INSN);
d6160 1
a6160 2
		  if (j != slotstack.ninsn - 1)
		    emit_single_op (insn);
@


1.22.2.2
log
@	* config/tc-xtensa.c (xg_apply_tentative_value): Rename to
	xg_apply_fix_value and return a value to indicate success.
	(md_pcrel_from): Skip check of fx_done.  Return 0 if not PC-relative.
	(xtensa_force_relocation): Remove checks for VTABLE relocs.
	(xtensa_validate_fix_sub): New.
	(xtensa_fix_adjustable): Remove check for external or weak symbols.
	(tc_gen_reloc): Move code to handle difference of symbols and code to
	apply tentative fix values to ...
	(md_apply_fix3): ...here.  Enable standard overflow checks for simple
	8, 16, and 32 bit relocations.  Apply fixes for slot-specific
	relocations when linkrelax flag is not set.
	* config/tc-xtensa.h (xtensa_validate_fix_sub): Add prototype.
	(TC_FORCE_RELOCATION_SUB_SAME, TC_VALIDATE_FIX_SUB): Define.
@
text
@d4937 2
a4938 2
static int
xg_apply_fix_value (fixS *fixP, valueT val)
d4970 3
a4972 1
     of a CONST16 operand.  */
d4974 1
a4974 1
    return 0;
a4981 2

  return 1;
d5455 3
d5459 1
a5459 1
    return 0;
d5480 1
a5480 2
  /* Check for "alternate" relocations (operand not specified).  None
     of the current uses for these are really PC-relative.  */
d5487 1
a5487 1
      return 0;
d5499 1
a5499 1
      return 0;
d5511 1
a5511 2
    {
    case BFD_RELOC_XTENSA_ASM_EXPAND:
d5527 2
a5541 27
/* TC_VALIDATE_FIX_SUB hook */

int
xtensa_validate_fix_sub (fixS *fix)
{
  segT add_symbol_segment, sub_symbol_segment;

  /* The difference of two symbols should be resolved by the assembler when
     linkrelax is not set.  If the linker may relax the section containing
     the symbols, then an Xtensa DIFF relocation must be generated so that
     the linker knows to adjust the difference value.  */
  if (!linkrelax || fix->fx_addsy == NULL)
    return 0;

  /* Make sure both symbols are in the same segment, and that segment is
     "normal" and relaxable.  If the segment is not "normal", then the
     fix is not valid.  If the segment is not "relaxable", then the fix
     should have been handled earlier.  */
  add_symbol_segment = S_GET_SEGMENT (fix->fx_addsy);
  if (! SEG_NORMAL (add_symbol_segment) ||
      ! relaxable_section (add_symbol_segment))
    return 0;
  sub_symbol_segment = S_GET_SEGMENT (fix->fx_subsy);
  return (sub_symbol_segment == add_symbol_segment);
}


d5589 4
d5598 1
a5598 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg)
d5600 1
a5600 4
  char *const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
  valueT val;

  switch (fixP->fx_r_type)
d5602 1
a5602 19
    case BFD_RELOC_32:
    case BFD_RELOC_16:
    case BFD_RELOC_8:
      if (linkrelax && fixP->fx_subsy)
	{
	  switch (fixP->fx_r_type)
	    {
	    case BFD_RELOC_8:
	      fixP->fx_r_type = BFD_RELOC_XTENSA_DIFF8;
	      break;
	    case BFD_RELOC_16:
	      fixP->fx_r_type = BFD_RELOC_XTENSA_DIFF16;
	      break;
	    case BFD_RELOC_32:
	      fixP->fx_r_type = BFD_RELOC_XTENSA_DIFF32;
	      break;
	    default:
	      break;
	    }
d5604 1
a5604 20
	  /* An offset is only allowed when it results from adjusting a
	     local symbol into a section-relative offset.  If the offset
	     came from the original expression, tc_fix_adjustable will have
	     prevented the fix from being converted to a section-relative
	     form so that we can flag the error here.  */
	  if (fixP->fx_offset != 0 && !symbol_section_p (fixP->fx_addsy))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("cannot represent subtraction with an offset"));

	  val = (S_GET_VALUE (fixP->fx_addsy) + fixP->fx_offset
		 - S_GET_VALUE (fixP->fx_subsy));

	  /* The difference value gets written out, and the DIFF reloc
	     identifies the address of the subtracted symbol (i.e., the one
	     with the lowest address).  */
	  *valP = val;
	  fixP->fx_offset -= val;
	  fixP->fx_subsy = NULL;
	}
      else if (! fixP->fx_addsy)
d5606 1
a5606 1
	  val = *valP;
d5608 1
a5608 6
	}
      else
	break;
      md_number_to_chars (fixpos, val, fixP->fx_size);
      fixP->fx_no_overflow = 0; /* Use the standard overflow check.  */
      break;
d5610 4
a5613 38
    case BFD_RELOC_XTENSA_SLOT0_OP:
    case BFD_RELOC_XTENSA_SLOT1_OP:
    case BFD_RELOC_XTENSA_SLOT2_OP:
    case BFD_RELOC_XTENSA_SLOT3_OP:
    case BFD_RELOC_XTENSA_SLOT4_OP:
    case BFD_RELOC_XTENSA_SLOT5_OP:
    case BFD_RELOC_XTENSA_SLOT6_OP:
    case BFD_RELOC_XTENSA_SLOT7_OP:
    case BFD_RELOC_XTENSA_SLOT8_OP:
    case BFD_RELOC_XTENSA_SLOT9_OP:
    case BFD_RELOC_XTENSA_SLOT10_OP:
    case BFD_RELOC_XTENSA_SLOT11_OP:
    case BFD_RELOC_XTENSA_SLOT12_OP:
    case BFD_RELOC_XTENSA_SLOT13_OP:
    case BFD_RELOC_XTENSA_SLOT14_OP:
      if (linkrelax)
	{
	  /* Write the tentative value of a PC-relative relocation to a
	     local symbol into the instruction.  The value will be ignored
	     by the linker, and it makes the object file disassembly
	     readable when all branch targets are encoded in relocations.  */

	  assert (fixP->fx_addsy);
	  if (S_GET_SEGMENT (fixP->fx_addsy) == seg && !fixP->fx_plt
	      && !S_FORCE_RELOC (fixP->fx_addsy, 1))
	    {
	      val = (S_GET_VALUE (fixP->fx_addsy) + fixP->fx_offset
		     - md_pcrel_from (fixP));
	      (void) xg_apply_fix_value (fixP, val);
	    }
	}
      else if (! fixP->fx_addsy)
	{
	  val = *valP;
	  if (xg_apply_fix_value (fixP, val))
	    fixP->fx_done = 1;
	}
      break;
d5615 7
a5621 18
    case BFD_RELOC_XTENSA_ASM_EXPAND:
    case BFD_RELOC_XTENSA_SLOT0_ALT:
    case BFD_RELOC_XTENSA_SLOT1_ALT:
    case BFD_RELOC_XTENSA_SLOT2_ALT:
    case BFD_RELOC_XTENSA_SLOT3_ALT:
    case BFD_RELOC_XTENSA_SLOT4_ALT:
    case BFD_RELOC_XTENSA_SLOT5_ALT:
    case BFD_RELOC_XTENSA_SLOT6_ALT:
    case BFD_RELOC_XTENSA_SLOT7_ALT:
    case BFD_RELOC_XTENSA_SLOT8_ALT:
    case BFD_RELOC_XTENSA_SLOT9_ALT:
    case BFD_RELOC_XTENSA_SLOT10_ALT:
    case BFD_RELOC_XTENSA_SLOT11_ALT:
    case BFD_RELOC_XTENSA_SLOT12_ALT:
    case BFD_RELOC_XTENSA_SLOT13_ALT:
    case BFD_RELOC_XTENSA_SLOT14_ALT:
      /* These all need to be resolved at link-time.  Do nothing now.  */
      break;
d5623 4
a5626 4
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      break;
d5628 4
a5631 3
    default:
      as_bad (_("unhandled local relocation fix %s"),
	      bfd_get_reloc_code_name (fixP->fx_r_type));
d5690 1
a5690 1
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
d5693 1
d5704 122
a5825 1
  reloc->addend = fixp->fx_offset;
d5842 18
@


1.22.2.3
log
@	* config/tc-xtensa.c (md_apply_fix3): Recognize XTENSA_PLT relocations.
@
text
@a5713 1
    case BFD_RELOC_XTENSA_PLT:
@


1.22.2.4
log
@	* config/tc-xtensa.c (use_longcalls): Delete.
	(xg_symbolic_immeds_fit): Check for direct calls and return TRUE if
	the use_longcalls flag is set.  Do this before checking the segment.
	(xg_expand_assembly_insn): Rearrange to use new do_expand flag.  Never
	expand direct calls at this point.
	(xtensa_set_frag_assembly_state): Set use_longcalls flag.
	(xtensa_find_unmarked_state_frags): Likewise.
	(md_assemble): Do not disable longcalls by setting is_specific_opcode.
	(xg_assemble_vliw_tokens): Switch frags when use_longcalls changes.
	(convert_frag_immed): Remove unnecessary check of is_specific_opcode.
	* config/tc-xtensa.h (xtensa_frag_type): Add use_longcalls flag.
@
text
@d1034 10
d3315 1
a3315 1
	  /* We only allow symbols for PC-relative references.
d3317 1
a3317 2
	  if (pc_frag == 0
	      || xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 0)
d3320 4
a3323 2
	  /* If it is a weak symbol, then assume it won't reach.  */
	  if (S_IS_WEAK (expr->X_add_symbol))
d3326 5
a3330 12
	  if (is_direct_call_opcode (insn->opcode)
	      && ! pc_frag->tc_frag_data.use_longcalls)
	    {
	      /* If callee is undefined or in a different segment, be
		 optimistic and assume it will be in range.  */
	      if (S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
		return TRUE;
	    }

	  /* Only references within a segment can be known to fit in the
	     operands at assembly time.  */
	  if (S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
d3648 1
a3648 1
  /* Walk through all of the single instruction expansions.  */
d3946 3
a3948 2
   tokens into the stack or relax it and place multiple
   instructions/literals onto the stack.  Return FALSE if no error.  */
a3954 2
  bfd_boolean do_expand;

d3980 1
d3983 18
d4004 5
a4008 10
  /* If the instruction will definitely need to be relaxed, it is better
     to expand it now for better scheduling.  Decide whether to expand
     now....  */
  do_expand = (!orig_insn->is_specific_opcode && use_transform ());

  /* Calls should be expanded to longcalls only in the backend relaxation
     so that the assembly scheduler will keep the L32R/CALLX instructions
     adjacent.  */
  if (is_direct_call_opcode (orig_insn->opcode))
    do_expand = FALSE;
d4012 4
a4015 5
      /* The values of symbolic operands are not known yet, so only expand
	 now if an operand is "complex" (e.g., difference of symbols) and
	 will have to be stored as a literal regardless of the value.  */
      if (!tinsn_has_complex_operands (orig_insn))
	do_expand = FALSE;
a4016 5
  else if (xg_immeds_fit (orig_insn))
    do_expand = FALSE;

  if (do_expand)
    xg_assembly_relax (istack, orig_insn, 0, 0, 0, 0, 0);
d4018 6
a4023 1
    istack_push (istack, orig_insn);
a4791 2
  if (directive_state[directive_longcalls])
    fragP->tc_frag_data.use_longcalls = TRUE;
a4849 2
		      fragP->tc_frag_data.use_longcalls =
			last_fragP->tc_frag_data.use_longcalls;
d5303 5
a6762 2
 	  || (directive_state[directive_longcalls]
	      != frag_now->tc_frag_data.use_longcalls)
d6880 3
a6882 3
      frag_now->tc_frag_data.slot_symbols[slot] = tinsn->symbol;
      frag_now->tc_frag_data.slot_sub_symbols[slot] = tinsn->sub_symbol;
      frag_now->tc_frag_data.slot_offsets[slot] = tinsn->offset;
d9374 1
a9374 1
  else
@


1.22.2.5
log
@	* config/tc-xtensa.c (do_align_targets): Update comment.
	(xtensa_frob_label): Compute "freq" before possibly switching frags.
	Insert a LOOP_END frag before every loop target, and do not overload
	DESIRE_ALIGN_IF_TARGET frags with loop end information.
	(xg_assemble_vliw_tokens): Use do_align_targets.
	(xtensa_fix_target_frags): Remove code to convert a
	DESIRE_ALIGN_IF_TARGET frag to a LOOP_END frag when there is a
	negatable branch at the end of a loop.
	(frag_can_negate_branch): Delete.
@
text
@d1036 2
a1037 3
  /* Do not use this function after md_end; just look at align_targets
     instead.  There is no target-align directive, so alignment is either
     enabled for all frags or not done at all.  */
d4528 1
a4528 1
  if (align_targets)
a5079 2
  float freq = get_subseg_target_freq (now_seg, now_subseg);

d5090 2
a5091 3
  if (symbol_get_tc (sym)->is_loop_target)
    {
      if ((get_last_insn_flags (now_seg, now_subseg)
d5093 1
a5093 9
	as_bad (_("invalid last instruction for a zero-overhead loop"));

      xtensa_set_frag_assembly_state (frag_now);
      frag_var (rs_machine_dependent, 4, 4, RELAX_LOOP_END,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);

      xtensa_set_frag_assembly_state (frag_now);
      xtensa_move_labels (frag_now, 0, TRUE);
  }
d5101 1
d5104 15
d5120 1
a5120 1
		0, (int) freq,
d6940 1
a6940 1
      else if (is_branch && do_align_targets ())
d7067 5
a7071 1
   Otherwise, convert to a .fill 0.  */
d7082 1
d7091 18
a7108 1
	      if (next_frag_is_branch_target (fragP))
d7113 4
d7122 24
@


1.22.2.6
log
@        * config/tc-xtensa.c: Warning fixes throughout.
        (xtensa_fetch_width): Change to unsigned.
        (assemble_nop, xtensa_find_unaligned_branch_targets,
        xtensa_find_unaligned_loops, xg_assemble_vliw_tokens,
        is_narrow_branch_guaranteed_in_range, xtensa_fix_close_loop_end_frags,
        min_bytes_to_other_loop_end, unrelaxed_frag_min_size,
        unrelaxed_frag_max_size, xtensa_fix_short_loop_frags,
        count_insns_to_loop_end, unrelaxed_frag_min_insn_count,
        get_text_align_max_fill_size, get_text_align_nop_count,
        get_text_align_nth_nop_size, get_noop_aligned_address,
        get_aligned_diff, convert_frag_align_next_opcode,
        convert_frag_immed_finish_loop, xtensa_create_property_segments,
        xtensa_create_xproperty_segments, xt_block_aligned_size): Clean up
        types, avoiding size_t and using offsetT and addressT appropriately.
        (get_text_align_power): Clean up types.  Avoid incorrect bound.
        (get_text_align_fill_size): Clean up types.  Restructure for clarity.
@
text
@d79 1
a79 1
unsigned xtensa_fetch_width = XCHAL_INST_FETCH_WIDTH;
d449 2
a450 2
static int get_text_align_power (unsigned);
static int get_text_align_max_fill_size (int, bfd_boolean, bfd_boolean);
d2527 1
a2527 1
  xtensa_insnbuf_from_chars (isa, insnbuf, (const unsigned char *) buf, 0);
d4294 1
a4294 2
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf,
			   (unsigned char *) buf, 0);
d4471 1
a4471 2
  xtensa_insnbuf_from_chars (isa, insnbuf,
			     (unsigned char *) fragP->fr_literal, 0);
d4709 1
a4709 1
assemble_nop (int size, char *buf)
d4720 1
a4720 2
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf,
			   (unsigned char *) buf, 0);
d4869 1
a4869 1
	      addressT frag_addr;
d4872 1
a4872 2
	      xtensa_insnbuf_from_chars
		(isa, insnbuf, (unsigned char *) frag->fr_literal, 0);
d4876 1
a4876 1
	      if (frag_addr + op_size > xtensa_fetch_width)
d4906 1
a4906 1
	      addressT frag_addr;
d4909 1
a4909 2
	      xtensa_insnbuf_from_chars
		(isa, insnbuf, (unsigned char *) frag->fr_literal, 0);
d4914 1
a4914 1
	      if (frag_addr + op_size > xtensa_fetch_width)
d4948 1
a4948 1
  xtensa_insnbuf_from_chars (isa, insnbuf, (unsigned char *) fixpos, 0);
d4968 1
a4968 1
  xtensa_insnbuf_to_chars (isa, insnbuf, (unsigned char *) fixpos, 0);
d5444 1
a5444 1
  xtensa_insnbuf_from_chars (isa, insnbuf, (unsigned char *) insn_p, 0);
d6009 1
a6009 1
  unsigned line;
d6794 1
a6794 1
      int max_fill;
d6844 1
a6844 1
      f = frag_more (insn_size + extra_space);
d6853 1
a6853 1
  xtensa_insnbuf_to_chars (isa, vinsn->insnbuf, (unsigned char *) f, 0);
d7151 1
a7151 1
static offsetT unrelaxed_frag_max_size (fragS *);
d7159 1
a7159 1
  offsetT max_distance = expr->X_add_number;
d7273 1
a7273 2
  xtensa_insnbuf_from_chars
    (isa, insnbuf, (unsigned char *) &next_fragP->fr_literal[offset], 0);
d7301 1
a7301 2
  xtensa_insnbuf_from_chars
    (isa, insnbuf, (unsigned char *) &next_fragP->fr_literal[offset], 0);
d7388 1
a7388 2
static offsetT min_bytes_to_other_loop_end
  (fragS *, fragS *, offsetT, offsetT);
d7433 2
a7434 2
	      offsetT min_bytes;
	      int bytes_added = 0;
d7476 1
a7476 1
static offsetT unrelaxed_frag_min_size (fragS *);
d7478 1
a7478 1
static offsetT
d7482 1
a7482 1
			     offsetT max_size)
d7484 1
a7484 1
  offsetT offset = 0;
d7504 1
a7504 1
static offsetT
d7507 1
a7507 1
  offsetT size = fragP->fr_fix;
d7509 1
a7509 1
  /* Add fill size.  */
d7517 1
a7517 1
static offsetT
d7520 1
a7520 1
  offsetT size = fragP->fr_fix;
d7570 1
a7570 1
static int count_insns_to_loop_end (fragS *, bfd_boolean, int);
d7618 3
a7620 1
	      if (count_insns_to_loop_end (fragP->fr_next, TRUE, 3) < 3
d7638 1
a7638 1
static int unrelaxed_frag_min_insn_count (fragS *);
d7640 1
a7640 1
static int
d7643 1
a7643 1
			 int max_count)
d7646 1
a7646 1
  int insn_count = 0;
d7674 1
a7674 1
static int
d7679 1
a7679 1
  int insn_count = 0;
d7693 1
a7693 2
      xtensa_insnbuf_from_chars
	(isa, insnbuf, (unsigned char *) fragP->fr_literal + offset, 0);
d7746 1
a7746 2
      xtensa_insnbuf_from_chars
	(isa, insnbuf, (unsigned char *) fragP->fr_literal + offset, 0);
d7774 1
a7774 1
  unsigned line;
d7919 2
a7920 2
static int
get_text_align_power (unsigned target_size)
d7922 2
a7923 5
  int i = 0;
  unsigned power = 1;

  assert (target_size <= INT_MAX);
  while (target_size > power)
d7925 2
a7926 2
      power <<= 1;
      i += 1;
d7928 2
a7929 1
  return i;
d7933 1
a7933 1
static int
d7947 22
a7968 5
/* Calculate the minimum bytes of fill needed at "address" to align a
   target instruction of size "target_size" so that it does not cross a
   power-of-two boundary specified by "align_pow".  If "use_nops" is FALSE,
   the fill can be an arbitrary number of bytes.  Otherwise, the space must
   be filled by NOP instructions.  */
d7970 1
a7970 1
static int
d7977 1
a7977 2
  addressT alignment, fill, fill_limit, fill_step;
  bfd_boolean skip_one = FALSE;
d7979 28
a8006 2
  alignment = (1 << align_pow);
  assert (target_size > 0 && alignment >= (addressT) target_size);
d8010 9
a8018 2
      fill_limit = alignment;
      fill_step = 1;
d8020 5
a8024 1
  else if (!use_no_density)
d8026 9
a8034 4
      /* Combine 2- and 3-byte NOPs to fill anything larger than one.  */
      fill_limit = alignment * 2;
      fill_step = 1;
      skip_one = TRUE;
d8038 1
a8038 4
      /* Fill with 3-byte NOPs -- can only fill multiples of 3.  */
      fill_limit = alignment * 3;
      fill_step = 3;
    }
d8040 7
a8046 8
  /* Try all fill sizes until finding one that works.  */
  for (fill = 0; fill < fill_limit; fill += fill_step)
    {
      if (skip_one && fill == 1)
	continue;
      if ((address + fill) >> align_pow
	  == (address + fill + target_size - 1) >> align_pow)
	return fill;
d8055 2
a8056 2
static int
get_text_align_nop_count (offsetT fill_size, bfd_boolean use_no_density)
d8058 1
a8058 2
  int count = 0;

d8069 1
a8069 1
      int insn_size = 3;
d8080 3
a8082 3
static int
get_text_align_nth_nop_size (offsetT fill_size,
			     int n,
d8085 3
a8087 1
  int count = 0;
a8091 2
  assert (fill_size != 1);	/* Bad argument.  */

d8094 1
a8094 1
      int insn_size = 3;
d8127 1
a8127 1
  int fill_size = 0;
d8131 1
a8131 1
  int align_power;
d8165 4
a8168 2
  align_power = get_text_align_power (first_insn_size);
  record_alignment (now_seg, align_power);
d8171 3
a8173 2
    (address + pre_opcode_bytes, align_power, first_insn_size, TRUE,
     fragP->tc_frag_data.is_no_density);
d8196 2
a8197 2
static offsetT
get_aligned_diff (fragS *fragP, addressT address, offsetT *max_diff)
d8203 2
a8204 2
  int align_power;
  offsetT opt_diff;
d8213 2
a8214 2
      align_power = get_text_align_power (xtensa_fetch_width);
      opt_diff = get_text_align_fill_size (address, align_power,
d8217 2
a8218 3
      *max_diff = (opt_diff + xtensa_fetch_width
		   - (target_size + ((address + opt_diff)
				     % xtensa_fetch_width)));
d8243 2
a8244 2
      align_power = get_text_align_power (target_size),
      opt_diff = get_text_align_fill_size (target_address, align_power,
d8279 1
a8279 2
  unsigned line;
  int lit_size;
d8330 1
a8330 2
      xtensa_insnbuf_from_chars
	(isa, vbuf, (unsigned char *) fragP->fr_opcode, 0);
d8622 1
a8622 1
	  int glob_widens = 0;
d8629 1
a8629 1
	  if (glob_pad || glob_widens >= (int) xtensa_fetch_width)
d9025 1
a9025 1
  unsigned line;
d9049 1
a9049 2
      xtensa_insnbuf_from_chars
	(isa, vbuf, (unsigned char *) fragp->fr_opcode, 0);
d9134 2
d9138 1
a9138 2
  offsetT fill_size;
  int nop, nop_count;
d9146 1
a9146 1
  for (nop = 0; nop < nop_count; nop++)
d9148 2
a9149 2
      int nop_size;
      nop_size = get_text_align_nth_nop_size (fill_size, nop, use_no_density);
d9302 1
a9302 2
      xtensa_insnbuf_to_chars
	(isa, orig_vinsn.insnbuf, (unsigned char *) fr_opcode, 0);
d9447 1
a9447 1
					   (unsigned char *) immed_instr, 0);
d9576 1
a9576 1
  int target_count;
d9641 1
a9641 2
  xtensa_insnbuf_to_chars
    (isa, insnbuf, (unsigned char *) fragP->fr_opcode + addi_offset, 0);
d9645 1
a9645 2
  xtensa_insnbuf_to_chars
    (isa, insnbuf, (unsigned char *) fragP->fr_opcode + addmi_offset, 0);
d10316 1
a10316 1
	  bfd_size_type rec_size;
d10333 1
a10333 1
	      bfd_size_type frag_size;
d10448 1
a10448 1
	  bfd_size_type rec_size;
d10466 1
a10466 1
	      bfd_size_type frag_size;
d10830 1
a10830 1
  unsigned align_bits;
d11265 1
a11265 1
  unsigned line;
d11358 1
a11358 2
      int rc;
      unsigned line;
d11722 1
a11722 1
  xtensa_insnbuf_from_chars (isa, insnbuf, (unsigned char *) f, 0);
@


1.22.2.7
log
@        * config/tc-xtensa.c (branch_align_power): New.
        (xtensa_find_unaligned_branch_targets, get_aligned_diff,
        future_alignment_required): Use branch_align_power to check section
        alignment as well as xtensa_fetch_width when aligning branch targets.
@
text
@a450 1
static int branch_align_power (segT);
d4872 1
a4872 1
	      addressT branch_align, frag_addr;
d4879 2
a4880 3
	      branch_align = 1 << branch_align_power (sec);
	      frag_addr = frag->fr_address % branch_align;
	      if (frag_addr + op_size > branch_align)
a8008 21
static int
branch_align_power (segT sec)
{
  /* If the Xtensa processor has a fetch width of 8 bytes, and the section
     is aligned to at least an 8-byte boundary, then a branch target need
     only fit within an 8-byte aligned block of memory to avoid a stall.
     Otherwise, try to fit branch targets within 4-byte aligned blocks
     (which may be insufficient, e.g., if the section has no alignment, but
     it's good enough).  */
  if (xtensa_fetch_width == 8)
    {
      if (get_recorded_alignment (sec) >= 3)
	return 3;
    }
  else
    assert (xtensa_fetch_width == 4);

  return 2;
}


a8158 1
  addressT branch_align;
d8167 1
a8167 2
      align_power = branch_align_power (now_seg);
      branch_align = 1 << align_power;
d8171 3
a8173 2
      *max_diff = (opt_diff + branch_align
		   - (target_size + ((address + opt_diff) % branch_align)));
d8586 1
a8586 1
	  if (glob_pad || glob_widens >= (1 << branch_align_power (now_seg)))
@


1.22.2.8
log
@	* config/tc-xtensa.c (xtensa_create_xproperty_segments): Skip
	SEC_MERGE sections.
@
text
@d10396 3
a10398 3
      if ((flags & SEC_DEBUGGING)
	  || !(flags & SEC_ALLOC)
	  || (flags & SEC_MERGE))
@


1.22.2.9
log
@	* config/tc-xtensa.c (check_t1_t2_reads_and_writes): Fix typo.
@
text
@d6424 1
a6424 1
	  int t1_class = xtensa_interface_class_id (isa, t1_int);
@


1.22.2.10
log
@	* config/tc-xtensa.h (struct xtensa_frag_type): Add lit_frchain field.
	* config/tc-xtensa.c (xg_translate_sysreg_op,
	xtensa_translate_old_userregs_ops,
	xtensa_find_unaligned_branch_targets,
	xtensa_find_unaligned_loops, xtensa_fix_close_loop_end_frags,
	relax_frag_add_nop): Support 64-bit host.
	(xtensa_mark_literal_pool_location, xtensa_move_literals): Use
	tc_frag_data lit_frchain and lit_seg fields instead of fr_var.
@
text
@d2250 1
a2250 1
		  (long) val, opname);
d2319 1
a2319 1
		  (long) val, opname);
d4648 4
a4651 2
  /* We stash info in these frags so we can later move the literal's
     fixes into this frchain's fix list.  */
d4653 1
a4653 2
  frag_now->tc_frag_data.lit_frchain = frchain_now;
  frag_variant (rs_machine_dependent, 0, 0,
d4656 1
a4656 2
  frag_now->tc_frag_data.lit_seg = now_seg;
  frag_variant (rs_machine_dependent, 0, 0,
d4885 1
a4885 1
			       op_size, (long) frag->fr_address);
d4924 1
a4924 1
			       op_size, (long) frag->fr_address);
d7465 1
a7465 1
				      (long) fragP->fr_var, length);
d8413 1
a8413 1
      as_fatal (_("fr_var (%ld) < length (%d)"), (long) fragP->fr_var, length);
d9872 4
a9875 2
	      frchain_to = literal_pool->tc_frag_data.lit_frchain;
	      assert (frchain_to);
d9882 1
a9882 1
	  dest_seg = insert_after->fr_next->tc_frag_data.lit_seg;
@


1.22.2.11
log
@        * config/tc-xtensa.c (get_aligned_diff): Handle target_size larger
        than the section alignment.
@
text
@a8192 3
      /* Don't count on the section alignment being as large as the target.  */
      if (target_size > branch_align)
	target_size = branch_align;
@


1.21
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
@


1.20
log
@	* config/tc-xtensa.c (xtensa_switch_section_emit_state): Use subseg_set.
	(xtensa_restore_emit_state): Likewise.
@
text
@a5592 9
#if 0
  /* We may someday want to enable this code to preserve relocations for
     non-PC-relative fixes, possibly under control of a PIC flag.  */
  return (fixP->fx_pcrel
	  || (fixP->fx_subsy != NULL
	      && (S_GET_SEGMENT (fixP->fx_subsy)
		  == S_GET_SEGMENT (fixP->fx_addsy)))
	  || S_IS_LOCAL (fixP->fx_addsy));
#else
a5593 1
#endif
a9565 28
#if 0
		  /* Code to recognize branch-around expansion
		     so the fragment is properly marked as ending in a
		     jump. */
		  if ((((i == istack.ninsn - 2)
			&& (istack.insn[istack.ninsn-1].insn_type
			    == ITYPE_LABEL))
		       || i == istack.ninsn -1)
		      && xtensa_opcode_is_jump (xtensa_default_isa,
						tinsn->opcode) == 1
		      && fragP->fr_next != NULL
		      && ! fragP->fr_next->tc_frag_data.is_unreachable)
		    {
		      /* Create a new unreachable frag of zero size.  */
		      size_t frag_size = sizeof (fragS);
		      fragS *new_fragP = (fragS *) xmalloc (frag_size);
		      memset (new_fragP, 0, frag_size);
		      new_fragP->fr_address = fragP->fr_next->fr_address;
		      new_fragP->fr_next = fragP->fr_next;
		      new_fragP->fr_fix = 0;
		      new_fragP->fr_var = 0;
		      new_fragP->fr_type = rs_fill;
		      new_fragP->tc_frag_data.is_unreachable = TRUE;
		      /* The rest are zeros....  */
		      /* Link it in to the chain.  */
		      fragP->fr_next = new_fragP;
		    }
#endif
d10641 1
a10641 12
#if 0
      if (seg == bfd_abs_section_ptr)
	abs_seg_info = seginfo;
      else if (seg == bfd_und_section_ptr)
	und_seg_info = seginfo;
      else
#endif
	bfd_set_section_userdata (stdoutput, seg, (void *) seginfo);
#if 0
      seg_fix_rootP = &segment_info[seg].fix_root;
      seg_fix_tailP = &segment_info[seg].fix_tail;
#endif
@


1.19
log
@        * config/tc-xtensa.c (xg_add_opcode_fix): Set fx_no_overflow.
@
text
@d10270 1
a10270 1
  subseg_new (segment_name (new_now_seg), new_now_subseg);
d10280 1
a10280 1
  subseg_new (state->name, state->now_subseg);
@


1.18
log
@2004-11-12  Bob Wilson  <bob.wilson@@acm.org>

include/ChangeLog
	* xtensa-isa-internal.h (xtensa_interface_internal): Add class_id.
	* xtensa-isa.h (xtensa_interface_class_id): New prototype.

bfd/ChangeLog
	* xtensa-isa.c (xtensa_interface_class_id): New.

gas/ChangeLog
	* config/tc-xtensa.c (finish_vinsn): Clear pending instruction if
	there is a conflict.
	(check_t1_t2_reads_and_writes): Check for both reads and writes to
	interfaces that are related as determined by xtensa_interface_class_id.
@
text
@d4269 1
@


1.17
log
@gas/
        * config/tc-xtensa.c (MAX_IMMED6): Change value to 65.
gas/testsuite/
        * gas/xtensa/short_branch_offset.s: New.
        * gas/xtensa/short_branch_offset.d: New.
        * gas/xtensa/all.exp: Run new test.
@
text
@d6016 1
a6016 1
   checked by check_t1_t2_read_write.  */
d6072 4
a6075 1
    return;
d6332 1
a6332 1
/* Check how the result registers of t1 and t2 relate.
d6342 1
a6342 1
   case F: two volatile queue writes
d6465 2
d6468 1
a6468 2
      if (xtensa_interface_has_side_effect (isa, t2_int) == 1 
	  && t2_inout != 'i')
d6470 1
d6475 2
d6478 1
a6478 2
	  if (xtensa_interface_has_side_effect (isa, t1_int) == 1 
	      && t1_inout != 'i')
d6480 3
a6502 3

  if (t1_volatile && t2_volatile)
    return 'f';
@


1.16
log
@	* config/tc-xtensa.c (update_next_frag_state): Always add a NOP if
	relaxing at the end of a loop.  Don't mark frags as UNREACHABLE or
	MAYBE_UNREACHABLE.
	(relax_frag_immed): Update call to update_next_frag_state.
@
text
@d7245 5
a7249 2
/* the range in bytes of a bnez.n and beqz.n */
#define MAX_IMMED6 68
@


1.15
log
@	* config/tc-xtensa.c (total_frag_text_expansion): New.
	(md_estimate_size_before_relax): Use it.
	(find_address_of_next_align_frag): Likewise.
@
text
@d4538 1
a4538 1
update_next_frag_state (fragS *fragP, bfd_boolean unreachable)
d4566 2
a4567 1
  if (unreachable)
d4569 2
a4570 1
      if (align_targets)
d4572 2
a4573 4
	  next_fragP->fr_subtype = RELAX_UNREACHABLE;
	  next_fragP->tc_frag_data.is_unreachable = TRUE;
	  new_target->fr_subtype = RELAX_DESIRE_ALIGN;
	  new_target->tc_frag_data.is_branch_target = TRUE;
a4574 8
      while (next_fragP && next_fragP->fr_fix == 0)
	{
	  if (next_fragP->fr_type == rs_machine_dependent
	      && next_fragP->fr_subtype == RELAX_LOOP_END)
	    {
	      next_fragP->fr_subtype = RELAX_LOOP_END_ADD_NOP;
	      return;
	    }
d4576 1
a4576 12
	  next_fragP = next_fragP->fr_next;
	}
    }
  else
    {
      if (align_targets)
	{
	  next_fragP->fr_subtype = RELAX_MAYBE_UNREACHABLE;
	  next_fragP->tc_frag_data.is_unreachable = FALSE;
	  new_target->fr_subtype = RELAX_MAYBE_DESIRE_ALIGN;
	  new_target->tc_frag_data.is_branch_target = FALSE;
	}
a9098 5
  /* FIXME: When a negatable branch expands and then contracts in a
     subsequent pass, update_next_frag_state correctly updates the
     type of the frag to RELAX_MAYBE_UNREACHABLE, but it doesn't undo
     any expansion relax_frag_for_align may have expected it to.  For
     now, change back to only call it when the branch expands.  */
d9100 1
a9100 1
    update_next_frag_state (fragP, FALSE /* istack.ninsn > 1 */);      
@


1.14
log
@	* config/tc-xtensa.c: Remove XTENSA_SECTION_RENAME ifdefs.
	(add_section_rename): Delete.  Inlined into...
	(build_section_rename): ...here.  Use xstrdup instead of strdup.
	(xtensa_section_rename): Drop "const" from argument and return types.
	(md_show_usage): Indent to match show_usage().
	* config/tc-xtensa.h: Remove XTENSA_SECTION_RENAME ifdefs.
	(tc_canonicalize_section_name): Define.
	(md_elf_section_rename): Remove unused macro.
	* doc/as.texinfo (Overview): Document Xtensa --rename-section option.
	* doc/c-xtensa.texi (Xtensa Options): Likewise.
	(Frame Directive): Delete.
@
text
@d445 1
d5710 1
a5710 1
  return fragP->tc_frag_data.text_expansion[0];
d6766 13
d8658 1
a8658 2
	      /* FIXME: shouldn't this add the expansion of all slots?  */
	      address += fragP->tc_frag_data.text_expansion[0];
@


1.13
log
@bfd ChangeLog

	* elf32-xtensa.c (elf_xtensa_get_private_bfd_flags): Delete.
	(narrow_instruction, widen_instruction): Remove unnecessary calls to
	xtensa_format_encode.
	(ebb_propose_action): Inline call to ebb_add_proposed_action.
	(ebb_add_proposed_action): Delete.

gas ChangeLog

	* config/tc-xtensa.c (xtensa_frequency_pseudo): Use set_subseg_freq.
	(is_entry_opcode, is_movi_opcode, is_the_loop_opcode, is_jx_opcode,
	is_windowed_return_opcode): Delete.
	(xtensa_frob_label): Use get_subseg_target_freq.
	(md_assemble): Inline call to is_entry_opcode.
	(xtensa_handle_align): Inline call to get_frag_is_literal.
	(relaxation_requirements): Inline call to is_jx_opcode.
	(emit_single_op): Inline call to is_movi_opcode.
	(xg_assemble_vliw_tokens): Inline calls to get_frag_is_insn,
	get_frag_is_no_transform, is_entry_opcode, and
	set_frag_is_specific_opcode.  Use get_subseg_total_freq.
	(xtensa_fix_a0_b_retw_frags, xtensa_fix_b_j_loop_end_frags,
	xtensa_fix_close_loop_end_frags, relax_frag_immed, convert_frag_immed):
	Inline calls to get_frag_is_no_transform.
	(next_instrs_are_b_retw): Inline call to is_windowed_return_opcode.
	(xtensa_fix_short_loop_frags): Inline calls to is_the_loop_opcode and
	get_frag_is_no_transform.
	(convert_frag_immed_finish_loop): Inline calls to get_expression_value
	and set_frag_is_no_transform.
	(get_expression_value): Delete.
	(subseg_map struct): Rename cur_total_freq to total_freq.  Rename
	cur_target_freq to target_freq.
	(get_subseg_info): Split out code to create a new map entry into ...
	(add_subseg_info): ... this new function.
	(get_last_insn_flags): Check if get_subseg_info succeeded.
	(set_last_insn_flags): Call add_subseg_info if needed.
	(get_subseg_total_freq, get_subseg_target_freq, set_subseg_freq): New.
	(xtensa_reorder_segments): Compute last_sec while counting sections.
	Remove call to get_last_sec.
	(get_last_sec): Delete.
	(cache_literal_section): Inline call to retrieve_literal_seg and its
	callees, seg_present and add_seg_list.
	(retrieve_literal_seg, seg_present, add_seg_list): Delete.
	(get_frag_is_insn, get_frag_is_no_transform,
	set_frag_is_specific_opcode, set_frag_is_no_transform): Delete.
	* config/tc-xtensa.h (MAX_SLOTS): Reduce from 31 to 15.
@
text
@d520 2
a521 1
#ifdef XTENSA_SECTION_RENAME
a522 2
static void add_section_rename (char *, char *);
#endif
a648 1
#ifdef XTENSA_SECTION_RENAME
a649 1
#endif
a715 1
#ifdef XTENSA_SECTION_RENAME
a716 1
#endif /* XTENSA_SECTION_RENAME */
a834 1
#ifdef XTENSA_SECTION_RENAME
a837 1
#endif /* XTENSA_SECTION_RENAME */
d905 8
a912 12
--[no-]text-section-literals\n\
                        [Do not] put literals in the text section\n\
--[no-]absolute-literals\n\
                        [Do not] default to use non-PC-relative literals\n\
--[no-]target-align     [Do not] try to align branch targets\n\
--[no-]longcalls        [Do not] emit 32-bit call sequences\n\
--[no-]transform        [Do not] transform instructions\n"
#ifdef XTENSA_SECTION_RENAME
"--rename-section old=new(:old1=new1)*\n\
                        Rename section 'old' to 'new'\n"
#endif /* XTENSA_SECTION_RENAME */
	 , stream);
d11988 1
a11988 3
/* Support for Tensilica's "--rename-section" option.  */

#ifdef XTENSA_SECTION_RENAME
d12000 4
a12003 2
/* Parse the string oldname=new_name:oldname2=new_name2
   and call add_section_rename.  */
d12008 1
d12012 1
a12012 1
  for (this_arg = strdup (arg); this_arg != NULL; this_arg = next_arg)
d12014 2
a12024 3
      {
	char *old_name = this_arg;
	char *new_name = strchr (this_arg, '=');
d12026 2
a12027 17
	if (*old_name == '\0')
	  {
	    as_warn (_("ignoring extra '-rename-section' delimiter ':'"));
	    continue;
	  }
	if (!new_name || new_name[1] == '\0')
	  {
	    as_warn (_("ignoring invalid '-rename-section' "
		       "specification: '%s'"), old_name);
	    continue;
	  }
	*new_name = '\0';
	new_name++;
	add_section_rename (old_name, new_name);
      }
    }
}
d12029 13
d12043 17
a12059 13
static void
add_section_rename (char *old_name, char *new_name)
{
  struct rename_section_struct *r = section_rename;

  /* Check for invalid section renaming.  */
  for (r = section_rename; r != NULL; r = r->next)
    {
      if (strcmp (r->old_name, old_name) == 0)
	as_bad (_("section %s renamed multiple times"), old_name);
      if (strcmp (r->new_name, new_name) == 0)
	as_bad (_("multiple sections remapped to output section %s"),
		new_name);
a12060 8

  /* Now add it.  */
  r = (struct rename_section_struct *)
    xmalloc (sizeof (struct rename_section_struct));
  r->old_name = strdup (old_name);
  r->new_name = strdup (new_name);
  r->next = section_rename;
  section_rename = r;
d12064 2
a12065 2
const char *
xtensa_section_rename (const char *name)
a12076 2

#endif /* XTENSA_SECTION_RENAME */
@


1.12
log
@bfd ChangeLog

	* elf32-xtensa.c: Use ISO C90 formatting.

gas ChangeLog

	* config/tc-xtensa.c: Use ISO C90 formatting.
	* config/tc-xtensa.h: Likewise.
	* config/xtensa-istack.h: Likewise.
	* config/xtensa-relax.c: Likewise.
	* config/xtensa-relax.h: Likewise.

ld ChangeLog

	* emultempl/xtensaelf.em: Use ISO C90 formatting.

opcodes ChangeLog

	* xtensa-dis.c: Use ISO C90 formatting.
@
text
@a310 23
/* A map that keeps information on a per-subsegment basis.  This is
   maintained during initial assembly, but is invalid once the
   subsegments are smashed together.  I.E., it cannot be used during
   the relaxation.  */

typedef struct subseg_map_struct
{
  /* the key */
  segT seg;
  subsegT subseg;

  /* the data */
  unsigned flags;
  /* the fall-through frequency + the branch target frequency
     typically used for the instruction after a call */
  float cur_total_freq;
  /* the branch target frequency alone */
  float cur_target_freq;

  struct subseg_map_struct *next;
} subseg_map;


d455 1
a455 1
/* Flags for the Last Instruction in Each Subsegment.  */
a456 1
static subseg_map *get_subseg_info (segT, subsegT);
d459 3
a473 8
/* Property flags on fragments and conversion to object file flags.  */

static bfd_boolean get_frag_is_literal (const fragS *);
static bfd_boolean get_frag_is_insn (const fragS *);
static bfd_boolean get_frag_is_no_transform (fragS *);
static void set_frag_is_specific_opcode (fragS *, bfd_boolean);
static void set_frag_is_no_transform (fragS *, bfd_boolean);

d1559 1
a1559 1
  /* Note that retrieve_literal_seg does not create a segment if
a1578 1
  subseg_map *seginfo;
d1596 1
a1596 3
  seginfo = get_subseg_info (now_seg, now_subseg);
  seginfo->cur_target_freq = target_f;
  seginfo->cur_total_freq = target_f + fall_through_f;
a2656 61
/* Return TRUE if the opcode is an entry opcode.  This is used because
   "entry" adds an implicit ".align 4" and also the entry instruction
   has an extra check for an operand value.  */

static bfd_boolean
is_entry_opcode (xtensa_opcode opcode)
{
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  return (opcode == xtensa_entry_opcode);
}


/* Return TRUE if the opcode is a movi or movi.n opcode.  This is 
   so we can relax "movi aX, foo" in the front end.  */

static bfd_boolean
is_movi_opcode (xtensa_opcode opcode)
{
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  return (opcode == xtensa_movi_opcode) 
    || (opcode == xtensa_movi_n_opcode);
}


static bfd_boolean
is_the_loop_opcode (xtensa_opcode opcode)
{
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  return (opcode == xtensa_loop_opcode);
}


static bfd_boolean
is_jx_opcode (xtensa_opcode opcode)
{
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  return (opcode == xtensa_jx_opcode);
}


/* Return TRUE if the opcode is a retw or retw.n.
   Needed to add nops to avoid a hardware interlock issue.  */

static bfd_boolean
is_windowed_return_opcode (xtensa_opcode opcode)
{
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  return (opcode == xtensa_retw_opcode || opcode == xtensa_retw_n_opcode);
}


d5141 1
a5141 1
      float freq = get_subseg_info (now_seg, now_subseg)->cur_target_freq;
d5369 1
a5369 1
  if (is_entry_opcode (orig_insn.opcode))
d5421 1
a5421 1
      && !get_frag_is_literal (fragP)
d6643 2
a6644 1
	  if (workaround_b_j_loop_end && is_jx_opcode (tinsn->opcode) 
d6729 3
a6731 1
  if (is_movi_opcode (orig_insn->opcode) && !cur_vinsn.inside_bundle
d6807 1
a6807 1
      && (!get_frag_is_insn (frag_now)
d6809 1
a6809 1
 	  || !use_transform () != get_frag_is_no_transform (frag_now)
d6883 1
a6883 1
  if (is_entry_opcode (vinsn->slots[0].opcode) 
d6947 1
a6947 1
    set_frag_is_specific_opcode (frag_now, TRUE);
d7022 1
a7022 1
      float freq = get_subseg_info (now_seg, now_subseg)->cur_total_freq;
d7351 1
a7351 1
		  if (get_frag_is_no_transform (fragP))
d7426 1
a7426 1
  if (is_windowed_return_opcode (opcode))
d7459 1
a7459 1
		  if (get_frag_is_no_transform (fragP))
d7557 1
a7557 1
		  if (get_frag_is_no_transform (fragP))
d7737 1
a7737 1
			  && !is_the_loop_opcode (current_opcode))))
d7739 1
a7739 1
		  if (get_frag_is_no_transform (fragP))
d9029 1
a9029 1
  if (workaround_b_j_loop_end && !get_frag_is_no_transform (fragP))
d9400 1
a9400 1
  if (workaround_b_j_loop_end && !get_frag_is_no_transform (fragP))
a9708 2
static offsetT get_expression_value (segT, expressionS *);

d9742 15
a9756 1
  target = get_expression_value (segP, &tinsn->tok[1]);
d9803 1
a9803 1
      set_frag_is_no_transform (next_fragP, TRUE);
d9811 5
d9817 1
a9817 2
static offsetT
get_expression_value (segT segP, expressionS *exp)
d9819 8
a9826 6
  if (exp->X_op == O_constant)
    return exp->X_add_number;
  if (exp->X_op == O_symbol)
    {
      /* Find the fragment.  */
      symbolS *sym = exp->X_add_symbol;
d9828 2
a9829 2
      assert (S_GET_SEGMENT (sym) == segP
	      || S_GET_SEGMENT (sym) == absolute_section);
a9830 5
      return (S_GET_VALUE (sym) + exp->X_add_number);
    }
  as_bad (_("invalid expression evaluation type %d"), exp->X_op);
  return 0;
}
a9831 1

d9842 1
a9842 1
	return subseg_e;
d9844 8
a9851 2
  
  subseg_e = (subseg_map *) xmalloc (sizeof (subseg_map));
d9857 2
a9858 2
  subseg_e->cur_target_freq = 1.0;
  subseg_e->cur_total_freq = 1.0;
a9860 1
  
d9869 3
a9871 1
  return subseg_e->flags;
d9882 2
d9890 31
a10146 2
static segT get_last_sec (void);

d10151 1
a10151 1
  segT last_sec;
d10156 4
a10159 1
    old_count++;
a10162 1
  last_sec = get_last_sec ();
a10173 11
static segT
get_last_sec (void)
{
  segT last_sec = stdoutput->sections;
  while (last_sec->next != NULL)
    last_sec = last_sec->next;

  return last_sec;
}


a10298 2
static segT retrieve_literal_seg (seg_list *, const char *, bfd_boolean);

d10302 1
a10302 1
		       segT *seg,
d10307 1
d10309 1
a10309 1
  if (*seg != 0)
a10310 3
  *seg = retrieve_literal_seg (head, name, is_code);
  subseg_set (current_section, current_subsec);
}
d10312 6
d10319 1
a10319 13
/* Get a segment of a given name.  If the segment is already
   present, return it; otherwise, create a new one.  */

static segT seg_present (const char *);
static void add_seg_list (seg_list *, segT);

static segT
retrieve_literal_seg (seg_list *head, const char *name, bfd_boolean is_code)
{
  segT ret = 0;

  ret = seg_present (name);
  if (!ret)
d10321 2
a10322 1
      ret = subseg_new (name, (subsegT) 0);
d10324 8
a10331 2
	add_seg_list (head, ret);
      bfd_set_section_flags (stdoutput, ret, SEC_HAS_CONTENTS |
d10334 1
a10334 1
      bfd_set_section_alignment (stdoutput, ret, 2);
d10337 2
a10338 35
  return ret;
}


/* Return a segment of a given name if it is present.  */

static segT
seg_present (const char *name)
{
  segT seg;
  seg = stdoutput->sections;

  while (seg)
    {
      if (!strcmp (segment_name (seg), name))
	return seg;
      seg = seg->next;
    }

  return 0;
}


/* Add a segment to a segment list.  */

static void
add_seg_list (seg_list *head, segT seg)
{
  seg_list *n;
  n = (seg_list *) xmalloc (sizeof (seg_list));
  assert (n);

  n->seg = seg;
  n->next = head->next;
  head->next = n;
d10351 1
a10404 29
static bfd_boolean
get_frag_is_insn (const fragS *fragP)
{
  assert (fragP != NULL);
  return fragP->tc_frag_data.is_insn;
}


static bfd_boolean
get_frag_is_no_transform (fragS *fragP)
{
  return fragP->tc_frag_data.is_no_transform;
}


static void
set_frag_is_specific_opcode (fragS *fragP, bfd_boolean is_specific_opcode)
{
  fragP->tc_frag_data.is_specific_opcode = is_specific_opcode;
}
 

static void
set_frag_is_no_transform (fragS *fragP, bfd_boolean is_no_transform)
{
  fragP->tc_frag_data.is_no_transform = is_no_transform;
}


@


1.11
log
@bfd ChangeLog

	* elf32-xtensa.c (elf32xtensa_size_opt): New global variable.
	(xtensa_default_isa): Global variable moved here from xtensa-isa.c.
	(elf32xtensa_no_literal_movement): New global variable.
	(elf_howto_table): Add entries for new relocations.
	(elf_xtensa_reloc_type_lookup): Handle new relocations.
	(property_table_compare): When addresses are equal, compare sizes and
	various property flags.
	(property_table_matches): New.
	(xtensa_read_table_entries): Extend to read new property tables.  Add
	output_addr parameter to indicate that output addresses should be used.
	Use bfd_get_section_limit.
	(elf_xtensa_find_property_entry): New.
	(elf_xtensa_in_literal_pool): Use elf_xtensa_find_property_entry.
	(elf_xtensa_check_relocs): Handle new relocations.
	(elf_xtensa_do_reloc): Use bfd_get_section_limit.  Handle new
	relocations.  Use new xtensa-isa.h functions.
	(build_encoding_error_message): Remove encode_result parameter.  Add
	new target_address parameter used to detect alignment errors.
	(elf_xtensa_relocate_section): Use bfd_get_section_limit.  Clean up
	error handling.  Use new is_operand_relocation function.
	(elf_xtensa_combine_prop_entries, elf_xtensa_merge_private_bfd_data):
	Use underbar macro for error messages.  Formatting.
	(get_const16_opcode): New.
	(get_l32r_opcode): Add a separate flag for initialization.
	(get_relocation_opnd): Operand number is no longer explicit in the
	relocation.  Change to decode the opcode and analyze its operands.
	(get_relocation_slot): New.
	(get_relocation_opcode): Add bfd parameter.  Use bfd_get_section_limit.
	Use new xtensa-isa.h functions to handle multislot instructions.
	(is_l32r_relocation): Add bfd parameter.  Use is_operand_relocation.
	(get_asm_simplify_size, is_alt_relocation, is_operand_relocation,
	insn_decode_len, insn_decode_opcode, check_branch_target_aligned,
	check_loop_aligned, check_branch_target_aligned_address, narrowable,
	widenable, narrow_instruction, widen_instruction, op_single_fmt_table,
	get_single_format, init_op_single_format_table): New.
	(elf_xtensa_do_asm_simplify): Add error_message parameter and use it
	instead of calling _bfd_error_handler.  Use new xtensa-isa.h functions.
	(contract_asm_expansion): Add error_message parameter and pass it to
	elf_xtensa_do_asm_simplify.  Replace use of R_XTENSA_OP0 relocation
	with R_XTENSA_SLOT0_OP.
	(get_expanded_call_opcode): Extend to handle either L32R or CONST16
	instructions.  Use new xtensa-isa.h functions.
	(r_reloc struct): Add new virtual_offset field.
	(r_reloc_init): Add contents and content_length parameters.  Set
	virtual_offset field to zero.  Add contents to target_offset field for
	partial_inplace relocations.
	(r_reloc_is_defined): Check for null.
	(print_r_reloc): New debug function.
	(source_reloc struct): Replace xtensa_operand field with pair of the
	opcode and the operand position.  Add is_abs_literal field.
	(init_source_reloc): Specify operand by opcode/position pair.  Set
	is_abs_literal field.
	(source_reloc_compare): When target_offsets are equal, compare other
	fields to make sorting predictable.
	(literal_value struct): Add is_abs_literal field.
	(value_map_hash_table struct): Add has_last_loc and last_loc fields.
	(init_literal_value): New.
	(is_same_value): Replace with ...
	(literal_value_equal): ... this function.  Add comparisons of
	virtual_offset and is_abs_literal fields.
	(value_map_hash_table_init): Use bfd_zmalloc.  Check for allocation
	failure.  Initialize has_last_loc field.
	(value_map_hash_table_delete): New.
	(hash_literal_value): Rename to ...
	(literal_value_hash): ... this.  Include is_abs_literal flag and
	virtual_offset field in the hash value.
	(get_cached_value): Rename to ...
	(value_map_get_cached_value): ... this.  Update calls to
	literal_value_hash and literal_value_equal.
	(add_value_map): Check for allocation failure.  Update calls to
	value_map_get_cached_value and literal_value_hash.
	(text_action, text_action_list, text_action_t): New types.
	(find_fill_action, compute_removed_action_diff, adjust_fill_action,
	text_action_add, text_action_add_literal, offset_with_removed_text,
	offset_with_removed_text_before_fill, find_insn_action,
	print_action_list, print_removed_literals): New.
	(offset_with_removed_literals): Delete.
	(xtensa_relax_info struct): Add is_relaxable_asm_section, action_list,
	fix_array, fix_array_count, allocated_relocs, relocs_count, and
	allocated_relocs_count fields.
	(init_xtensa_relax_info): Initialize new fields.
	(reloc_bfd_fix struct): Add new translated field.
	(reloc_bfd_fix_init): Add translated parameter and use it to set the
	translated field.
	(fix_compare, cache_fix_array): New.
	(get_bfd_fix): Remove fix_list parameter and get all relax_info for the
	section via get_xtensa_relax_info.  Use cache_fix_array to set up
	sorted fix_array and use bsearch instead of linear search.
	(section_cache_t): New struct.
	(init_section_cache, section_cache_section, clear_section_cache): New.
	(ebb_t, ebb_target_enum, proposed_action, ebb_constraint): New types.
	(init_ebb_constraint, free_ebb_constraint, init_ebb, extend_ebb_bounds,
	extend_ebb_bounds_forward, extend_ebb_bounds_backward,
	insn_block_decodable_len, ebb_propose_action, ebb_add_proposed_action):
	New.
	(retrieve_contents): Use bfd_get_section_limit.
	(elf_xtensa_relax_section): Add relocations_analyzed flag.  Update call
	to compute_removed_literals.  Free value_map_hash_table when no longer
	needed.
	(analyze_relocations): Check is_relaxable_asm_section flag.  Call
	compute_text_actions for all sections.
	(find_relaxable_sections): Mark sections as relaxable if they contain
	ASM_EXPAND relocations that can be optimized.  Adjust r_reloc_init
	call.  Increment relax_info src_count field only for appropriate
	relocation types.  Remove is_literal_section check.
	(collect_source_relocs): Use bfd_get_section_limit.  Adjust calls to
	r_reloc_init and find_associated_l32r_irel.  Check
	is_relaxable_asm_section flag.  Handle L32R instructions with absolute
	literals.  Pass is_abs_literal flag to init_source_reloc.
	(is_resolvable_asm_expansion): Use bfd_get_section_limit.  Check for
	CONST16 instructions.  Adjust calls to r_reloc_init and
	pcrel_reloc_fits.  Handle weak symbols conservatively.
	(find_associated_l32r_irel): Add bfd parameter and pass it to
	is_l32r_relocation.
	(compute_text_actions, compute_ebb_proposed_actions,
	compute_ebb_actions, check_section_ebb_pcrels_fit,
	check_section_ebb_reduces, text_action_add_proposed,
	compute_fill_extra_space): New.
	(remove_literals): Replace with ...
	(compute_removed_literals): ... this function.  Call
	init_section_cache.  Use bfd_get_section_limit.  Sort internal_relocs.
	Call xtensa_read_table_entries to get the property table.  Skip
	relocations other than R_XTENSA_32 and R_XTENSA_PLT.  Use new
	is_removable_literal, remove_dead_literal, and
	identify_literal_placement functions.
	(get_irel_at_offset): Rewrite to use bsearch on sorted relocations
	instead of linear search.
	(is_removable_literal, remove_dead_literal,
	identify_literal_placement): New.
	(relocations_reach): Update check for literal not referenced by any
	PC-relative relocations.  Adjust call to pcrel_reloc_fits.
	(coalesce_shared_literal, move_shared_literal): New.
	(relax_section): Use bfd_get_section_limit.  Call
	translate_section_fixes.  Update calls to r_reloc_init and
	offset_with_removed_text.  Check new is_relaxable_asm_section flag.
	Add call to pin_internal_relocs.  Add special handling for
	R_XTENSA_ASM_SIMPLIFY and R_XTENSA_DIFF* relocs.  Use virtual_offset
	info to calculate new addend_displacement variable.  Replace code for
	deleting literals with more general code to perform the actions
	determined by the action_list for the section.
	(translate_section_fixes, translate_reloc_bfd_fix): New.
	(translate_reloc): Check new is_relaxable_asm_section flag.  Call
	find_removed_literal only if is_operand_relocation.  Update call to
	offset_with_removed_text.  Use new target_offset and removed_bytes
	variables.
	(move_literal): New.
	(relax_property_section):  Use bfd_get_section_limit.  Set new
	is_full_prop_section flag and handle new property tables.  Update calls
	to r_reloc_init and offset_with_removed_text.  Check
	is_relaxable_asm_section flag.  Handle expansion of zero-sized
	unreachable entries, with use of offset_with_removed_text_before_fill.
	For relocatable links, combine entries only for literal tables.
	(relax_section_symbols): Check is_relaxable_asm_section flag.  Update
	calls to offset_with_removed_text.  Translate st_size field for
	function symbols.
	(do_fix_for_relocatable_link): Change to return bfd_boolean to indicate
	failure.  Add contents parameter.  Update call to get_bfd_fix.  Update
	call to r_reloc_init.  Call _bfd_error_handler and return FALSE for
	R_XTENSA_ASM_EXPAND relocs.
	(do_fix_for_final_link): Add input_bfd and contents parameters.  Update
	call to get_bfd_fix.  Include offset from contents for partial_inplace
	relocations.
	(is_reloc_sym_weak): New.
	(pcrel_reloc_fits): Use new xtensa-isa.h functions.
	(prop_sec_len): New.
	(xtensa_is_property_section): Handle new property sections.
	(is_literal_section): Delete.
	(internal_reloc_compare): When r_offset matches, compare r_info and
	r_addend to make sorting predictable.
	(internal_reloc_matches): New.
	(xtensa_get_property_section_name): Handle new property sections.
	(xtensa_get_property_predef_flags): New.
	(xtensa_callback_required_dependence): Use bfd_get_section_limit.
	Update calls to xtensa_isa_init, is_l32r_relocation, and r_reloc_init.
	* xtensa-isa.c (xtensa_default_isa): Moved to elf32-xtensa.c.
	(xtisa_errno, xtisa_error_msg): New variables.
	(xtensa_isa_errno, xtensa_isa_error_msg): New.
	(xtensa_insnbuf_alloc): Add error handling.
	(xtensa_insnbuf_to_chars): Add num_chars parameter.  Update to
	use xtensa_format_decode.  Add error handling.
	(xtensa_insnbuf_from_chars): Add num_chars parameter.  Decode the
	instruction length to find the number of bytes to copy.
	(xtensa_isa_init): Add error handling.  Replace calls to
	xtensa_load_isa and xtensa_extend_isa with code to initialize lookup
	tables in the xtensa_modules structure.
	(xtensa_check_isa_config, xtensa_add_isa, xtensa_load_isa,
	xtensa_extend_isa): Delete.
	(xtensa_isa_free): Change to only free lookup tables.
	(opname_lookup_compare): Replace with ...
	(xtensa_isa_name_compare): ... this function.  Use strcasecmp.
	(xtensa_insn_maxlength): Rename to ...
	(xtensa_isa_maxlength): ... this.
	(xtensa_insn_length): Delete.
	(xtensa_insn_length_from_first_byte): Replace with ...
	(xtensa_isa_length_from_chars): ... this function.
	(xtensa_num_opcodes): Rename to ...
	(xtensa_isa_num_opcodes): ... this.
	(xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_regfiles, xtensa_isa_num_stages,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot): New functions.
	(xtensa_opcode_lookup): Add error handling.
	(xtensa_decode_insn): Replace with ...
	(xtensa_opcode_decode): ... this function, with new format and
	slot parameters.  Add error handling.
	(xtensa_encode_insn): Replace with ...
	(xtensa_opcode_encode): ... this function, which does the encoding via
	one of the entries in the "encode_fns" array.  Add error handling.
	(xtensa_opcode_name): Add error handling.
	(xtensa_opcode_is_branch, xtensa_opcode_is_jump, xtensa_opcode_is_loop,
	xtensa_opcode_is_call): New.
	(xtensa_num_operands): Replace with ...
	(xtensa_opcode_num_operands): ... this function.  Add error handling.
	(xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible): New.
	(xtensa_get_operand, xtensa_operand_kind): Delete.
	(xtensa_operand_inout): Add error handling and special-case for
	"sout" operands.
	(xtensa_operand_get_field, xtensa_operand_set_field): Rewritten to
	operate on one slot of an instruction.  Added error handling.
	(xtensa_operand_encode): Handle default operands with no encoding
	functions.  Check for success by comparing against decoded value.
	Add error handling.
	(xtensa_operand_decode): Handle default operands.  Return decoded value
	through argument pointer.  Add error handling.
	(xtensa_operand_is_register, xtensa_operand_regfile,
	xtensa_operand_num_regs, xtensa_operand_is_known_reg): New.
	(xtensa_operand_isPCRelative): Rename to ...
	(xtensa_operand_is_PCrelative): ... this.  Add error handling.
	(xtensa_operand_do_reloc, xtensa_operand_undo_reloc): Return value
	through argument pointer.  Add error handling.
	(xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New.
	* xtensa-modules.c: Rewrite to use new data structures.
	* reloc.c (BFD_RELOC_XTENSA_DIFF8, BFD_RELOC_XTENSA_DIFF16,
	BFD_RELOC_XTENSA_DIFF32, BFD_RELOC_XTENSA_SLOT0_OP,
	BFD_RELOC_XTENSA_SLOT1_OP, BFD_RELOC_XTENSA_SLOT2_OP,
	BFD_RELOC_XTENSA_SLOT3_OP, BFD_RELOC_XTENSA_SLOT4_OP,
	BFD_RELOC_XTENSA_SLOT5_OP, BFD_RELOC_XTENSA_SLOT6_OP,
	BFD_RELOC_XTENSA_SLOT7_OP, BFD_RELOC_XTENSA_SLOT8_OP,
	BFD_RELOC_XTENSA_SLOT9_OP, BFD_RELOC_XTENSA_SLOT10_OP,
	BFD_RELOC_XTENSA_SLOT11_OP, BFD_RELOC_XTENSA_SLOT12_OP,
	BFD_RELOC_XTENSA_SLOT13_OP, BFD_RELOC_XTENSA_SLOT14_OP,
	BFD_RELOC_XTENSA_SLOT0_ALT, BFD_RELOC_XTENSA_SLOT1_ALT,
	BFD_RELOC_XTENSA_SLOT2_ALT, BFD_RELOC_XTENSA_SLOT3_ALT,
	BFD_RELOC_XTENSA_SLOT4_ALT, BFD_RELOC_XTENSA_SLOT5_ALT,
	BFD_RELOC_XTENSA_SLOT6_ALT, BFD_RELOC_XTENSA_SLOT7_ALT,
	BFD_RELOC_XTENSA_SLOT8_ALT, BFD_RELOC_XTENSA_SLOT9_ALT,
	BFD_RELOC_XTENSA_SLOT10_ALT, BFD_RELOC_XTENSA_SLOT11_ALT,
	BFD_RELOC_XTENSA_SLOT12_ALT, BFD_RELOC_XTENSA_SLOT13_ALT,
	BFD_RELOC_XTENSA_SLOT14_ALT): Add new relocations.
	* Makefile.am (xtensa-isa.lo, xtensa-modules.lo): Update dependencies.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Likewise.
	* libbfd.h: Likewise.

gas ChangeLog

	* config/tc-xtensa.c (absolute_literals_supported): New global flag.
	(UNREACHABLE_MAX_WIDTH): Define.
	(XTENSA_FETCH_WIDTH): Delete.
	(cur_vinsn, xtensa_fetch_width, xt_saved_debug_type, past_xtensa_end,
	prefer_const16, prefer_l32r): New global variables.
	(LIT4_SECTION_NAME): Define.
	(lit4_state struct): Add lit4_seg_name and lit4_seg fields.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.
	(frag_flags struct): New.
	(xtensa_block_info struct): Move from tc-xtensa.h.  Add flags field.
	(subseg_map struct): Add cur_total_freq and cur_target_freq fields.
	(bitfield, bit_is_set, set_bit, clear_bit): Define.
	(MAX_FORMATS): Define.
	(op_placement_info struct, op_placement_table): New.
	(O_pltrel, O_hi16, O_lo16): Define.
	(directiveE enum): Rename directive_generics to directive_transform.
	Delete directive_relax.  Add directive_schedule,
	directive_absolute_literals, and directive_last_directive.
	(directive_info): Rename "generics" to "transform".  Delete "relax".
	Add "schedule" and "absolute-literals".
	(directive_state): Adjust entries to match changes in directive_info.
	(xtensa_relax_statesE, RELAX_IMMED_MAXSTEPS): Move to tc-xtensa.h.
	(xtensa_const16_opcode, xtensa_movi_opcode, xtensa_movi_n_opcode,
	xtensa_l32r_opcode, xtensa_nop_opcode, xtensa_rsr_lcount_opcode): New.
	(xtensa_j_opcode, xtensa_rsr_opcode): Delete.
	(align_only_targets, software_a0_b_retw_interlock,
	software_avoid_b_j_loop_end, maybe_has_b_j_loop_end,
	software_avoid_short_loop, software_avoid_close_loop_end,
	software_avoid_all_short_loops, specific_opcode): Delete.
	(warn_unaligned_branch_targets): New.
	(workaround_a0_b_retw, workaround_b_j_loop_end, workaround_short_loop,
	workaround_close_loop_end, workaround_all_short_loops): Default FALSE.
	(option_[no_]link_relax, option_[no_]transform,
	option_[no_]absolute_literals, option_warn_unaligned_targets,
	option_prefer_l32r, option_prefer_const16, option_target_hardware):
	New enum values.
	(option_[no_]align_only_targets, option_literal_section_name,
	option_text_section_name, option_data_section_name,
	option_bss_section_name, option_eb, option_el): Delete.
	(md_longopts): Add entries for: [no-]transform, [no-]absolute-literals,
	warn-unaligned-targets, prefer-l32r, prefer-const16, [no-]link-relax,
	and target-hardware.  Delete entries for [no-]target-align-only,
	literal-section-name, text-section-name, data-section-name, and
	bss-section-name.
	(md_parse_option): Handle new options and remove old ones.  Accept but
	ignore [no-]density options.  Warn for [no-]generics and [no-]relax
	and treat them as [no-]transform.
	(md_show_usage): Add new options and remove old ones.
	(xtensa_setup_hw_workarounds): New.
	(md_pseudo_table): Change "word" entry to use xtensa_elf_cons.  Add
	"long", "short", "loc" and "frequency" entries.
	(use_generics): Rename to ...
	(use_transform): ... this function.  Add past_xtensa_end check.
	(use_longcalls): Add past_xtensa_end check.
	(code_density_available, can_relax): Delete.
	(do_align_targets): New.
	(get_directive): Accept dashes in directive names.  Warn about
	[no-]generics and [no-]relax directives and treat them as
	[no-]transform.
	(xtensa_begin_directive): Call md_flush_pending_output only for some
	directives.  Check for directives inside instruction bundles.  Warn
	about deprecated ".begin literal" usage.  Warn and ignore [no-]density
	directives.  Handle new directives.  Check generating_literals flag
	for literal_prefix.
	(xtensa_end_directive): Check for directives inside instruction
	bundles.  Warn and ignore [no-]density directives.  Handle new
	directives.  Call xtensa_set_frag_assembly_state.
	(xtensa_loc_directive_seen, xtensa_dwarf2_directive_loc,
	xtensa_dwarf2_emit_insn): New.
	(xtensa_literal_position): Call md_flush_pending_output.  Do not check
	use_literal_section flag.
	(xtensa_literal_pseudo): Call md_flush_pending_output.  Handle absolute
	literals.  Use xtensa_elf_cons to parse the expression.
	(xtensa_literal_prefix): Do not check use_literal_section.  Support
	".lit4" sections for absolute literals.  Change prefix convention to
	replace ".text" (or ".t" in a linkonce section).  No need to call
	subseg_set.
	(xtensa_frequency_pseudo, xtensa_elf_cons, xtensa_elf_suffix): New.
	(expression_end): Handle closing braces and colons.
	(PLT_SUFFIX, plt_suffix): Delete.
	(expression_maybe_register): Use new xtensa-isa.h functions.  Use
	xtensa_elf_suffix instead of checking for plt suffix, and handle O_lo16
	and O_hi16 expressions as well.
	(tokenize_arguments): Handle closing braces and colons.
	(parse_arguments): Use new xtensa-isa.h functions.  Handle "invisible"
	operands and paired register syntax.
	(get_invisible_operands): New.
	(xg_translate_sysreg_op): Handle new Xtensa LX RSR/WSR/XSR syntax.  Use
	new xtensa-isa.h functions.
	(xtensa_translate_old_userreg_ops, xtensa_translate_zero_immed): New.
	(xg_translate_idioms): Check if inside bundle.  Use use_transform.
	Handle new Xtensa LX RSR/WSR/XSR syntax.  Remove code to widen density
	instructions.  Use xtensa_translate_zero_immed.
	(operand_is_immed, operand_is_pcrel_label): Delete.
	(get_relaxable_immed): Use new xtensa-isa.h functions.
	(get_opcode_from_buf): Add slot parameter.  Use new xtensa-isa.h
	functions.
	(xtensa_print_insn_table, print_vliw_insn): New.
	(is_direct_call_opcode): Use new xtensa-isa.h functions.
	(is_call_opcode, is_loop_opcode, is_conditional_branch_opcode,
	is_branch_or_jump_opcode): Delete.
	(is_movi_opcode, decode_reloc, encode_reloc, encode_alt_reloc): New.
	(opnum_to_reloc, reloc_to_opnum): Delete.
	(xtensa_insnbuf_set_operand, xtensa_insnbuf_get_operand): Use new
	xtensa-isa.h functions.  Operate on one slot of an instruction.
	(xtensa_insnbuf_set_immediate_field, is_negatable_branch,
	xg_get_insn_size): Delete.
	(xg_get_build_instr_size): Use xg_get_single_size.
	(xg_is_narrow_insn, xg_is_single_relaxable_insn): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_get_max_narrow_insn_size): Delete.
	(xg_get_max_insn_widen_size, xg_get_max_insn_widen_literal_size,
	xg_is_relaxable_insn): Update calls to xg_build_widen_table.  Use
	xg_get_single_size.
	(xg_build_to_insn): Record the loc field.  Handle OP_OPERAND_HI16U and
	OP_OPERAND_LOW16U.  Check xg_valid_literal_expression.
	(xg_expand_to_stack, xg_expand_narrow): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_immeds_fit): Use new xtensa-isa.h functions.  Update call to
	xg_check_operand.
	(xg_symbolic_immeds_fit): Likewise.  Also handle O_lo16 and O_hi16, and
	treat weak symbols conservatively.
	(xg_check_operand): Use new xtensa-isa.h functions.
	(is_dnrange): Delete.
	(xg_assembly_relax): Inline previous calls to tinsn_copy.
	(xg_finish_frag): Specify separate relax states for the frag and slot0.
	(is_branch_jmp_to_next, xg_add_branch_and_loop_targets): Use new
	xtensa-isa.h functions.
	(xg_instruction_matches_option_term, xg_instruction_matches_or_options,
	xg_instruction_matches_options): New.
	(xg_instruction_matches_rule): Handle O_register expressions.  Call
	xg_instruction_matches_options.
	(transition_rule_cmp): New.
	(xg_instruction_match): Update call to xg_build_simplify_table.
	(xg_build_token_insn): Record loc fields.
	(xg_simplify_insn): Check is_specific_opcode field and
	density_supported flag.
	(xg_expand_assembly_insn): Skip checking code_density_available.  Use
	new xtensa-isa.h functions.  Call use_transform instead of can_relax.
	(xg_assemble_literal): Add error handling for O_big.  Call
	record_alignment.  Handle O_pltrel.
	(xg_valid_literal_expression): New.
	(xg_assemble_literal_space): Add slot parameter.  Remove call to
	set_expr_symbol_offset.  Add call to record_alignment.  Update call to
	xg_finish_frag.
	(xg_emit_insn): Delete.
	(xg_emit_insn_to_buf): Add format parameter.  Update calls to
	xg_add_opcode_fix and xtensa_insnbuf_to_chars.
	(xg_add_opcode_fix): Change opcode parameter to tinsn and add format
	and slot parameters.  Handle new "alternate" relocations for absolute
	literals and CONST16 instructions.  Check for bad uses of O_lo16 and
	O_hi16.  Use new xtensa-isa.h functions.
	(xg_assemble_tokens): Delete.
	(is_register_writer): Use new xtensa-isa.h functions.
	(is_bad_loopend_opcode): Check for xtensa_rsr_lcount_opcode instead of
	old-style RSR from LCOUNT.
	(next_frag_opcode): Delete.
	(next_frag_opcode_is_loop, next_frag_format_size, frag_format_size,
	update_next_frag_state): New.
	(update_next_frag_nop_state): Delete.
	(next_frag_pre_opcode_bytes): Use next_frag_opcode_is_loop.
	(xtensa_mark_literal_pool_location): Check use_literal_section flag and
	the state of the absolute-literals directive.  Add calls to
	record_alignment and xtensa_set_frag_assembly_state.  Call
	xtensa_switch_to_non_abs_literal_fragment instead of
	xtensa_switch_to_literal_fragment.
	(build_nop): New.
	(assemble_nop): Use build_nop.  Update call to xtensa_insnbuf_to_chars.
	(get_expanded_loop_offset): Change check for undefined opcode to an
	assertion.
	(xtensa_set_frag_assembly_state, relaxable_section,
	xtensa_find_unmarked_state_frags, xtensa_find_unaligned_branch_targets,
	xtensa_find_unaligned_loops, xg_apply_tentative_value): New.
	(md_begin): Update call to xtensa_isa_init.  Initialize linkrelax to 1.
	Set lit4_seg_name.  Call xg_init_vinsn.  Initialize new global opcodes.
	Call init_op_placement_info_table and xtensa_set_frag_assembly_state.
	(xtensa_init_fix_data): New.
	(xtensa_frob_label): Reset label symbol to the current frag.  Check
	do_align_targets and generating_literals flag.  Propagate frequency
	info to new alignment frag.  Call xtensa_set_frag_assembly_state.
	(xtensa_unrecognized_line): New.
	(xtensa_flush_pending_output): Check if inside a bundle.  Add a call
	to xtensa_set_frag_assembly_state.
	(error_reset_cur_vinsn): New.
	(md_assemble): Remove check for literal frag.  Remove call to
	istack_init.  Call use_transform instead of use_generics.  Parse
	explicit instruction format specifiers.  Move code for
	a0_b_retw_interlock workaround to xg_assemble_vliw_tokens.  Call
	error_reset_cur_vinsn on errors.  Add call to get_invisible_operands.
	Add dwarf2_where call.  Remote automatic alignment for ENTRY
	instructions.  Move call to xtensa_clear_insn_labels to the end.
	Rearrange to handle bundles.
	(xtensa_cons_fix_new): Delete.
	(xtensa_handle_align): New.
	(xtensa_frag_init): Call xtensa_set_frag_assembly_state.  Remove
	assignment to is_no_density field.
	(md_pcrel_from): Use new xtensa-isa.h functions.  Use decode_reloc
	instead of reloc_to_opnum.  Handle "alternate" relocations.
	(xtensa_force_relocation, xtensa_check_inside_bundle,
	xtensa_elf_section_change_hook): New.
	(xtensa_symbol_new_hook): Delete.
	(xtensa_fix_adjustable): Check for difference of symbols with an
	offset.  Check for external and weak symbols.
	(md_apply_fix3): Remove cases for XTENSA_OP{0,1,2} relocs.
	(md_estimate_size_before_relax): Return expansion for the first slot.
	(tc_gen_reloc): Handle difference of symbols by producing
	XTENSA_DIFF{8,16,32} relocs and by writing the value of the difference
	into the output.  Handle new XTENSA_SLOT*_OP relocs by storing the
	tentative values into the output when linkrelax is set.
	(XTENSA_PROP_SEC_NAME): Define.
	(xtensa_post_relax_hook): Call xtensa_find_unmarked_state_frags.
	Create literal tables only if using literal sections.  Create new
	property tables instead of old instruction tables.  Check for unaligned
	branch targets and loops.
	(finish_vinsn, find_vinsn_conflicts, check_t1_t2_reads_and_writes,
	new_resource_table, clear_resource_table, resize_resource_table,
	resources_available, reserve_resources, release_resources,
	opcode_funcUnit_use_unit, opcode_funcUnit_use_stage,
	resources_conflict, xg_find_narrowest_format, relaxation_requirements,
	bundle_single_op, emit_single_op, xg_assemble_vliw_tokens): New.
	(xtensa_end): Call xtensa_flush_pending_output.  Set past_xtensa_end
	flag.  Update checks for workaround options.  Call
	xtensa_mark_narrow_branches and xtensa_mark_zcl_first_insns.
	(xtensa_cleanup_align_frags): Add special case for branch targets.
	Check for and mark unreachable frags.
	(xtensa_fix_target_frags): Remove use of align_only_targets flag.
	Use RELAX_LOOP_END_BYTES in special case for negatable branch at the
	end of a zero-overhead loop body.
	(frag_can_negate_branch): Handle instructions with multiple slots.
	Use new xtensa-isa.h functions
	(xtensa_mark_narrow_branches, is_narrow_branch_guaranteed_in_range,
	xtensa_mark_zcl_first_insns): New.
	(xtensa_fix_a0_b_retw_frags, xtensa_fix_b_j_loop_end_frags): Error if
	transformations are disabled.
	(next_instrs_are_b_retw): Use new xtensa-isa.h functions.  Handle
	multislot instructions.
	(xtensa_fix_close_loop_end_frags, xtensa_fix_short_loop_frags):
	Likewise.  Also error if transformations are disabled.
	(unrelaxed_frag_max_size): New.
	(unrelaxed_frag_min_insn_count, unrelax_frag_has_b_j): Use new
	xtensa-isa.h functions.
	(xtensa_sanity_check, is_empty_loop, is_local_forward_loop): Use
	xtensa_opcode_is_loop instead of is_loop_opcode.
	(get_text_align_power): Replace as_fatal with assertion.
	(get_text_align_fill_size): Iterate instead of using modulus when
	use_nops is false.
	(get_noop_aligned_address): Assert that this is for a machine-dependent
	RELAX_ALIGN_NEXT_OPCODE frag.  Use next_frag_opcode_is_loop,
	xg_get_single_size, and frag_format_size.
	(get_widen_aligned_address): Rename to ...
	(get_aligned_diff): ... this function.  Add max_diff parameter.
	Remove handling of rs_align/rs_align_code frags.  Use
	next_frag_format_size, get_text_align_power, get_text_align_fill_size,
	next_frag_opcode_is_loop, and xg_get_single_size.  Compute max_diff
	and pass it back to caller.
	(xtensa_relax_frag): Use relax_frag_loop_align.  Add code for new
	RELAX_SLOTS, RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN,
	RELAX_FILL_NOP, and RELAX_UNREACHABLE frag types.  Check relax_seen.
	(relax_frag_text_align): Rename to ...
	(relax_frag_loop_align): ... this function.  Assume loops can only be
	in the first slot of an instruction.
	(relax_frag_add_nop): Use assemble_nop instead of constructing an OR
	instruction.  Remove call to frag_wane.
	(relax_frag_narrow): Rename to ...
	(relax_frag_for_align): ... this function.  Extend to handle
	RELAX_FILL_NOP and RELAX_UNREACHABLE, as well as RELAX_SLOTS with
	RELAX_NARROW for the first slot.
	(find_address_of_next_align_frag, bytes_to_stretch): New.
	(future_alignment_required): Use find_address_of_next_align_frag and
	bytes_to_stretch.  Look ahead to subsequent frags to make smarter
	alignment decisions.
	(relax_frag_immed): Add format, slot, and estimate_only parameters.
	Check if transformations are enabled for b_j_loop_end workaround.
	Use new xtensa-isa.h functions and handle multislot instructions.
	Update call to xg_assembly_relax.
	(md_convert_frag): Handle new RELAX_SLOTS, RELAX_UNREACHABLE,
	RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN, and RELAX_FILL_NOP
	frag types.
	(convert_frag_narrow): Add segP, format and slot parameters.  Call
	convert_frag_immed for branch instructions.  Adjust calls to
	tinsn_from_chars, tinsn_immed_from_frag, and xg_emit_insn_to_buf.  Use
	xg_get_single_size and xg_get_single_format.
	(convert_frag_fill_nop): New.
	(convert_frag_immed): Add format and slot parameters.  Handle multislot
	instructions and use new xtensa-isa.h functions.  Update calls to
	tinsn_immed_from_frag and xg_assembly_relax.  Check if transformations
	enabled for b_j_loop_end workaround.  Use build_nop instead of
	assemble_nop.  Check is_specific_opcode flag.  Check for unreachable
	frags.  Use xg_get_single_size.  Handle O_pltrel.
	(fix_new_exp_in_seg): Remove check for old plt flag.
	(convert_frag_immed_finish_loop): Update calls to tinsn_from_chars and
	xtensa_insnbuf_to_chars.  Call tinsn_immed_from_frag.  Change check
	for loop opcode to an assertion.  Mark all frags up to the end of the
	loop as not transformable.
	(get_last_insn_flags, set_last_insn_flags): Use get_subseg_info.
	(get_subseg_info): New.
	(xtensa_move_literals): Call xtensa_set_frag_assembly_state.  Add null
	check for dest_seg.
	(xtensa_switch_to_literal_fragment): Rewrite to handle absolute
	literals and use xtensa_switch_to_non_abs_literal_fragment otherwise.
	(xtensa_switch_to_non_abs_literal_fragment): New.
	(cache_literal_section): Add is_code parameter and pass it through to
	retrieve_literal_seg.
	(retrieve_literal_seg): Add is_code parameter and use it to set the
	flags on the literal section.  Handle case where head parameter is 0.
	(get_frag_is_no_transform, set_frag_is_specific_opcode,
	set_frag_is_no_transform): New.
	(xtensa_create_property_segments): Add end_property_function parameter
	and pass it through to add_xt_block_frags.  Call bfd_get_section_flags
	and skip SEC_DEBUGGING and !SEC_ALLOC sections.
	(xtensa_create_xproperty_segments, section_has_xproperty): New.
	(add_xt_block_frags): Add end_property_function parameter and call it
	if it is non-zero.  Call xtensa_frag_flags_init.
	(xtensa_frag_flags_is_empty, xtensa_frag_flags_init,
	get_frag_property_flags, frag_flags_to_number,
	xtensa_frag_flags_combinable, xt_block_aligned_size,
	xtensa_xt_block_combine, add_xt_prop_frags,
	init_op_placement_info_table, opcode_fits_format_slot,
	xg_get_single_size, xg_get_single_format): New.
	(istack_push): Inline call to tinsn_copy.
	(tinsn_copy): Delete.
	(tinsn_has_invalid_symbolic_operands): Handle O_hi16 and O_lo16 and
	CONST16 opcodes.  Handle O_big, O_illegal, and O_absent.
	(tinsn_has_complex_operands): Handle O_hi16 and O_lo16.
	(tinsn_to_insnbuf): Use xg_get_single_format and new xtensa-isa.h
	functions.  Handle invisible operands.
	(tinsn_to_slotbuf): New.
	(tinsn_check_arguments): Use new xtensa-isa.h functions.
	(tinsn_from_chars): Add slot parameter.  Rewrite using xg_init_vinsn,
	vinsn_from_chars, and xg_free_vinsn.
	(tinsn_from_insnbuf): New.
	(tinsn_immed_from_frag): Add slot parameter and handle multislot
	instructions.  Handle symbol differences.
	(get_num_stack_text_bytes): Use xg_get_single_size.
	(xg_init_vinsn, xg_clear_vinsn, vinsn_has_specific_opcodes,
	xg_free_vinsn, vinsn_to_insnbuf, vinsn_from_chars, expr_is_register,
	get_expr_register, set_expr_symbol_offset_diff): New.
	* config/tc-xtensa.h (MAX_SLOTS): Define.
	(xtensa_relax_statesE): Move from tc-xtensa.c. Add
	RELAX_CHECK_ALIGN_NEXT_OPCODE, RELAX_MAYBE_DESIRE_ALIGN, RELAX_SLOTS,
	RELAX_FILL_NOP, RELAX_UNREACHABLE, RELAX_MAYBE_UNREACHABLE, and
	RELAX_NONE types.
	(RELAX_IMMED_MAXSTEPS): Move from tc-xtensa.c.
	(xtensa_frag_type struct): Add is_assembly_state_set,
	use_absolute_literals, relax_seen, is_unreachable, is_specific_opcode,
	is_align, is_text_align, alignment, and is_first_loop_insn fields.
	Replace is_generics and is_relax fields by is_no_transform field.
	Delete is_text and is_longcalls fields.  Change text_expansion and
	literal_expansion to arrays of MAX_SLOTS entries.  Add arrays of
	per-slot information: literal_frags, slot_subtypes, slot_symbols,
	slot_sub_symbols, and slot_offsets.  Add fr_prev field.
	(xtensa_fix_data struct): New.
	(xtensa_symfield_type struct): Delete plt field.
	(xtensa_block_info struct): Move definition to tc-xtensa.h.  Add
	forward declaration here.
	(xt_section_type enum): Delete xt_insn_sec.  Add xt_prop_sec.
	(XTENSA_SECTION_RENAME): Undefine.
	(TC_FIX_TYPE, TC_INIT_FIX_DATA, TC_FORCE_RELOCATION, NO_PSEUDO_DOT,
	tc_unrecognized_line, md_do_align, md_elf_section_change_hook,
	HANDLE_ALIGN, TC_LINKRELAX_FIXUP, SUB_SEGMENT_ALIGN): Define.
	(TC_CONS_FIX_NEW, tc_symbol_new_hook): Delete.
	(unit_num_copies_func, opcode_num_units_func,
	opcode_funcUnit_use_unit_func, opcode_funcUnit_use_stage_func): New.
	(resource_table struct): New.
	* config/xtensa-istack.h (MAX_INSN_ARGS): Increase from 6 to 10.
	(TInsn struct): Add keep_wide, loc, fixup, record_fix, subtype,
	literal_space, symbol, sub_symbol, offset, and literal_frag fields.
	(tinsn_copy): Delete prototype.
	(vliw_insn struct): New.
	* config/xtensa-relax.c (insn_pattern_struct): Add options field.
	(widen_spec_list): Add option conditions for density and boolean
	instructions.  Add expansions using CONST16 and conditions for using
	CONST16 vs. L32R.  Use new Xtensa LX RSR/WSR syntax.  Add entries for
	predicted branches.
	(simplify_spec_list): Add option conditions for density instructions.
	Add entry for NOP instruction.
	(append_transition): Add cmp function pointer parameter and use it to
	insert the new entry in order.
	(operand_function_LOW16U, operand_function_HI16U): New.
	(xg_has_userdef_op_fn, xg_apply_userdef_op_fn): Handle
	OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(enter_opname, split_string): Use xstrdup instead of strdup.
	(init_insn_pattern): Initialize new options field.
	(clear_req_or_option_list, clear_req_option_list,
	clone_req_or_option_list, clone_req_option_list, parse_option_cond):
	New.
	(parse_insn_pattern): Parse option conditions.
	(transition_applies): New.
	(build_transition): Use new xtensa-isa.h functions.  Fix incorrectly
	swapped last arguments in calls to append_constant_value_condition.
	Call clone_req_option_list.  Add warning about invalid opcode.
	Handle LOW16U and HI16U function names.
	(build_transition_table): Add cmp parameter and use it in calls to
	append_transition.  Use new xtensa-isa.h functions.  Check
	transition_applies before adding entries.
	(xg_build_widen_table, xg_build_simplify_table): Add cmp parameter and
	pass it through to build_transition_table.
	* config/xtensa-relax.h (ReqOrOptionList, ReqOrOption, ReqOptionList,
	ReqOption, transition_cmp_fn): New types.
	(OpType enum): Add OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(transition_rule struct): Add options field.
	* doc/as.texinfo (Overview): Update Xtensa options.
	* doc/c-xtensa.texi (Xtensa Options): Delete --[no-]density,
	--[no-]relax, and --[no-]generics options.  Update descriptions of
	--text-section-literals and --[no-]longcalls.  Add
	--[no-]absolute-literals and --[no-]transform.
	(Xtensa Syntax): Add description of syntax for FLIX instructions.
	Remove use of "generic" and "specific" terminology for opcodes.
	(Xtensa Registers): Generalize the syntax description to include
	user-defined register files.
	(Xtensa Automatic Alignment): Update.
	(Xtensa Branch Relaxation): Mention limitation of unconditional jumps.
	(Xtensa Call Relaxation): Linker can now remove most of the overhead.
	(Xtensa Directives): Remove confusing rules about precedence.
	(Density Directive, Relax Directive): Delete.
	(Schedule Directive): New.
	(Generics Directive): Rename to ...
	(Transform Directive): ... this node.
	(Literal Directive): Update for absolute literals.  Missing
	literal_position directive is now an error.
	(Literal Position Directive): Update for absolute literals.
	(Freeregs Directive): Delete.
	(Absolute Literals Directive): New.
	(Frame Directive): Minor editing.
	* Makefile.am (DEPTC_xtensa_elf, DEPOBJ_xtensa_elf, DEP_xtensa_elf):
	Update dependencies.
	* Makefile.in: Regenerate.

gas/testsuite ChangeLog

	* gas/xtensa/all.exp: Adjust expected error message for j_too_far.
	Change entry_align test to expect an error.
	* gas/xtensa/entry_misalign2.s: Use no-transform instead of
	no-generics directives.

include ChangeLog

	* xtensa-config.h (XSHAL_USE_ABSOLUTE_LITERALS,
	XCHAL_HAVE_PREDICTED_BRANCHES, XCHAL_INST_FETCH_WIDTH): New.
	(XCHAL_EXTRA_SA_SIZE, XCHAL_EXTRA_SA_ALIGN): Delete.
	* xtensa-isa-internal.h (ISA_INTERFACE_VERSION): Delete.
	(config_sturct struct): Delete.
	(XTENSA_OPERAND_IS_REGISTER, XTENSA_OPERAND_IS_PCRELATIVE,
	XTENSA_OPERAND_IS_INVISIBLE, XTENSA_OPERAND_IS_UNKNOWN,
	XTENSA_OPCODE_IS_BRANCH, XTENSA_OPCODE_IS_JUMP,
	XTENSA_OPCODE_IS_LOOP, XTENSA_OPCODE_IS_CALL,
	XTENSA_STATE_IS_EXPORTED, XTENSA_INTERFACE_HAS_SIDE_EFFECT): Define.
	(xtensa_format_encode_fn, xtensa_get_slot_fn, xtensa_set_slot_fn): New.
	(xtensa_insn_decode_fn): Rename to ...
	(xtensa_opcode_decode_fn): ... this.
	(xtensa_immed_decode_fn, xtensa_immed_encode_fn, xtensa_do_reloc_fn,
	xtensa_undo_reloc_fn): Update.
	(xtensa_encoding_template_fn): Delete.
	(xtensa_opcode_encode_fn, xtensa_format_decode_fn,
	xtensa_length_decode_fn): New.
	(xtensa_format_internal, xtensa_slot_internal): New types.
	(xtensa_operand_internal): Delete operand_kind, inout, isPCRelative,
	get_field, and set_field fields.  Add name, field_id, regfile,
	num_regs, and flags fields.
	(xtensa_arg_internal): New type.
	(xtensa_iclass_internal): Change operands field to array of
	xtensa_arg_internal.  Add num_stateOperands, stateOperands,
	num_interfaceOperands, and interfaceOperands fields.
	(xtensa_opcode_internal): Delete length, template, and iclass fields.
	Add iclass_id, flags, encode_fns, num_funcUnit_uses, and funcUnit_uses.
	(opname_lookup_entry): Delete.
	(xtensa_regfile_internal, xtensa_interface_internal,
	xtensa_funcUnit_internal, xtensa_state_internal,
	xtensa_sysreg_internal, xtensa_lookup_entry): New.
	(xtensa_isa_internal): Replace opcode_table field with opcodes field.
	Change type of opname_lookup_table.  Delete num_modules,
	module_opcode_base, module_decode_fn, config, and has_density fields.
	Add num_formats, formats, format_decode_fn, length_decode_fn,
	num_slots, slots, num_fields, num_operands, operands, num_iclasses,
	iclasses, num_regfiles, regfiles, num_states, states,
	state_lookup_table, num_sysregs, sysregs, sysreg_lookup_table,
	max_sysreg_num, sysreg_table, num_interfaces, interfaces,
	interface_lookup_table, num_funcUnits, funcUnits and
	funcUnit_lookup_table fields.
	(xtensa_isa_module, xtensa_isa_modules): Delete.
	(xtensa_isa_name_compare): New prototype.
	(xtisa_errno, xtisa_error_msg): New.
	* xtensa-isa.h (XTENSA_ISA_VERSION): Define.
	(xtensa_isa): Change type.
	(xtensa_operand): Delete.
	(xtensa_format, xtensa_regfile, xtensa_state, xtensa_sysreg,
	xtensa_interface, xtensa_funcUnit, xtensa_isa_status,
	xtensa_funcUnit_use): New types.
	(libisa_module_specifier): Delete.
	(xtensa_isa_errno, xtensa_isa_error_msg): New prototypes.
	(xtensa_insnbuf_free, xtensa_insnbuf_to_chars,
	xtensa_insnbuf_from_chars): Update prototypes.
	(xtensa_load_isa, xtensa_extend_isa, xtensa_default_isa,
	xtensa_insn_maxlength, xtensa_num_opcodes, xtensa_decode_insn,
	xtensa_encode_insn, xtensa_insn_length,
	xtensa_insn_length_from_first_byte, xtensa_num_operands,
	xtensa_operand_kind, xtensa_encode_result,
	xtensa_operand_isPCRelative): Delete.
	(xtensa_isa_init, xtensa_operand_inout, xtensa_operand_get_field,
	xtensa_operand_set_field, xtensa_operand_encode,
	xtensa_operand_decode, xtensa_operand_do_reloc,
	xtensa_operand_undo_reloc): Update prototypes.
	(xtensa_isa_maxlength, xtensa_isa_length_from_chars,
	xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_opcodes, xtensa_isa_num_regfiles, xtensa_isa_num_states,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot, xtensa_opcode_decode,
	xtensa_opcode_encode, xtensa_opcode_is_branch, xtensa_opcode_is_jump,
	xtensa_opcode_is_loop, xtensa_opcode_is_call,
	xtensa_opcode_num_operands, xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible, xtensa_operand_is_register,
	xtensa_operand_regfile, xtensa_operand_num_regs,
	xtensa_operand_is_known_reg, xtensa_operand_is_PCrelative,
	xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New prototypes.
	* elf/xtensa.h (R_XTENSA_DIFF8, R_XTENSA_DIFF16, R_XTENSA_DIFF32,
	R_XTENSA_SLOT*_OP, R_XTENSA_SLOT*_ALT): New relocations.
	(XTENSA_PROP_SEC_NAME): Define.
	(property_table_entry): Add flags field.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.

ld ChangeLog

	* ld.texinfo (Xtensa): Describe new linker relaxation to optimize
	assembler-generated longcall sequences.  Describe new --size-opt
	option.
	* emulparams/elf32xtensa.sh (OTHER_SECTIONS): Add .xt.prop section.
	* emultempl/xtensaelf.em (remove_section,
	replace_insn_sec_with_prop_sec, replace_instruction_table_sections,
	elf_xtensa_after_open): New.
	(OPTION_OPT_SIZEOPT, OPTION_LITERAL_MOVEMENT,
	OPTION_NO_LITERAL_MOVEMENT): Define.
	(elf32xtensa_size_opt, elf32xtensa_no_literal_movement): New globals.
	(PARSE_AND_LIST_LONGOPTS): Add size-opt and [no-]literal-movement.
	(PARSE_AND_LIST_OPTIONS): Add --size-opt.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_OPT_SIZEOPT,
	OPTION_LITERAL_MOVEMENT, and OPTION_NO_LITERAL_MOVEMENT.
	(LDEMUL_AFTER_OPEN): Set to elf_xtensa_after_open.
	* scripttempl/elfxtensa.sc: Update with changes from elf.sc.
	* Makefile.am (eelf32xtensa.c): Update dependencies.
	* Makefile.in: Regenerate.

ld/testsuite ChangeLog

	* ld-xtensa/lcall1.s: Use .literal directive.
	* ld-xtensa/lcall2.s: Align function entry.
	* ld-xtensa/coalesce2.s: Likewise.

opcodes ChangeLog

	* xtensa-dis.c (state_names): Delete.
	(fetch_data): Use xtensa_isa_maxlength.
	(print_xtensa_operand): Replace operand parameter with opcode/operand
	pair.  Remove print_sr_name parameter.  Use new xtensa-isa.h functions.
	(print_insn_xtensa): Use new xtensa-isa.h functions.  Handle multislot
	instruction bundles.  Use xmalloc instead of malloc.
@
text
@a76 1
static void error_reset_cur_vinsn PARAMS ((void));
a442 5
typedef bfd_boolean (*frag_predicate) (const fragS *);
typedef void (*frag_flags_fn) (const fragS *, frag_flags *);

/* Command-line option functions.  */
static void xtensa_setup_hw_workarounds PARAMS ((int, int));
d446 8
a453 68
static bfd_boolean use_transform
  PARAMS ((void));
static bfd_boolean use_longcalls
  PARAMS ((void));
static bfd_boolean do_align_targets
  PARAMS ((void));
static void directive_push
  PARAMS ((directiveE, bfd_boolean, const void *));
static void directive_pop
  PARAMS ((directiveE *, bfd_boolean *, const char **,
	   unsigned int *, const void **));
static void directive_balance
  PARAMS ((void));
static bfd_boolean inside_directive
  PARAMS ((directiveE));
static void get_directive
  PARAMS ((directiveE *, bfd_boolean *));
static void xtensa_begin_directive
  PARAMS ((int));
static void xtensa_end_directive
  PARAMS ((int));
static void xtensa_dwarf2_directive_loc
  PARAMS ((int));
static void xtensa_dwarf2_emit_insn 
  PARAMS ((int, struct dwarf2_line_info *));
static void xtensa_literal_prefix
  PARAMS ((char const *, int));
static void xtensa_literal_position
  PARAMS ((int));
static void xtensa_literal_pseudo
  PARAMS ((int));
static void xtensa_frequency_pseudo
  PARAMS ((int));
static void xtensa_elf_cons
  PARAMS ((int));
static bfd_reloc_code_real_type xtensa_elf_suffix
  PARAMS ((char **, expressionS *));

/* Parsing and Idiom Translation Functions.  */

static const char *expression_end
  PARAMS ((const char *));
static unsigned tc_get_register
  PARAMS ((const char *));
static void expression_maybe_register
  PARAMS ((xtensa_opcode, int, expressionS *));
static int tokenize_arguments
  PARAMS ((char **, char *));
static bfd_boolean parse_arguments
  PARAMS ((TInsn *, int, char **));
static int get_invisible_operands
  PARAMS ((TInsn *));
static int xg_translate_idioms
  PARAMS ((char **, int *, char **));
static int xg_translate_sysreg_op
  PARAMS ((char **, int *, char **));
static int xtensa_translate_old_userreg_ops
  PARAMS ((char **));
static int xtensa_translate_zero_immed
  PARAMS ((char *, char *, char **, int *, char **));
static void xg_reverse_shift_count
  PARAMS ((char **));
static int xg_arg_is_constant
  PARAMS ((char *, offsetT *));
static void xg_replace_opname
  PARAMS ((char **, char *));
static int xg_check_num_args
  PARAMS ((int *, int, char *, char **));
d455 1
a455 1
/* Functions for dealing with the Xtensa ISA.  */
d457 1
a457 33
static int get_relaxable_immed
  PARAMS ((xtensa_opcode));
static xtensa_opcode get_opcode_from_buf
  PARAMS ((const char *, int));
#ifdef TENSILICA_DEBUG
static void xtensa_print_insn_table
  PARAMS ((void));
static void print_vliw_insn
  PARAMS ((xtensa_insnbuf));
#endif
static bfd_boolean is_direct_call_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_entry_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_movi_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_the_loop_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_jx_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_windowed_return_opcode
  PARAMS ((xtensa_opcode));
static int decode_reloc
  PARAMS ((bfd_reloc_code_real_type, int *, bfd_boolean *));
static bfd_reloc_code_real_type encode_reloc
  PARAMS ((int));
static bfd_reloc_code_real_type encode_alt_reloc
  PARAMS ((int));
static void xtensa_insnbuf_set_operand
  PARAMS ((xtensa_insnbuf, xtensa_format, int, xtensa_opcode, int, uint32,
	   const char *, unsigned int));
static uint32 xtensa_insnbuf_get_operand
  PARAMS ((xtensa_insnbuf, xtensa_format, int, xtensa_opcode, int));
d461 7
a467 200
static bfd_boolean is_unique_insn_expansion
  PARAMS ((TransitionRule *));
static int xg_get_build_instr_size
  PARAMS ((BuildInstr *));
static bfd_boolean xg_is_narrow_insn
  PARAMS ((TInsn *));
static bfd_boolean xg_is_single_relaxable_insn
  PARAMS ((TInsn *));
static int xg_get_max_insn_widen_size
  PARAMS ((xtensa_opcode));
static int xg_get_max_insn_widen_literal_size
  PARAMS ((xtensa_opcode));
static bfd_boolean xg_is_relaxable_insn
  PARAMS ((TInsn *, int));
static symbolS *get_special_literal_symbol
  PARAMS ((void));
static symbolS *get_special_label_symbol
  PARAMS ((void));
static bfd_boolean xg_build_to_insn
  PARAMS ((TInsn *, TInsn *, BuildInstr *));
static bfd_boolean xg_build_to_stack
  PARAMS ((IStack *, TInsn *, BuildInstr *));
static bfd_boolean xg_expand_to_stack
  PARAMS ((IStack *, TInsn *, int));
static bfd_boolean xg_expand_narrow
  PARAMS ((TInsn *, TInsn *));
static bfd_boolean xg_immeds_fit
  PARAMS ((const TInsn *));
static bfd_boolean xg_symbolic_immeds_fit
  PARAMS ((const TInsn *, segT, fragS *, offsetT, long));
static bfd_boolean xg_check_operand
  PARAMS ((int32, xtensa_opcode, int));
static int xg_assembly_relax
  PARAMS ((IStack *, TInsn *, segT, fragS *, offsetT, int, long));
static void xg_force_frag_space
  PARAMS ((int));
static void xg_finish_frag
  PARAMS ((char *, enum xtensa_relax_statesE, enum xtensa_relax_statesE,
	   int, bfd_boolean));
static bfd_boolean is_branch_jmp_to_next
  PARAMS ((TInsn *, fragS *));
static void xg_add_branch_and_loop_targets
  PARAMS ((TInsn *));
static bfd_boolean xg_instruction_matches_options
  PARAMS ((TInsn *, const ReqOption *));
static bfd_boolean xg_instruction_matches_or_options
  PARAMS ((TInsn *, const ReqOrOptionList *));
static bfd_boolean xg_instruction_matches_option_term
  PARAMS ((TInsn *, const ReqOrOption *));
static bfd_boolean xg_instruction_matches_rule
  PARAMS ((TInsn *, TransitionRule *));
static TransitionRule *xg_instruction_match
  PARAMS ((TInsn *));
static int transition_rule_cmp
  PARAMS ((const TransitionRule *, const TransitionRule *));
static bfd_boolean xg_build_token_insn
  PARAMS ((BuildInstr *, TInsn *, TInsn *));
static bfd_boolean xg_simplify_insn
  PARAMS ((TInsn *, TInsn *));
static bfd_boolean xg_expand_assembly_insn
  PARAMS ((IStack *, TInsn *));
static symbolS *xg_assemble_literal
  PARAMS ((TInsn *));
static bfd_boolean xg_valid_literal_expression
  PARAMS ((const expressionS *));
static void xg_assemble_literal_space
  PARAMS ((int, int));
static symbolS *xtensa_create_literal_symbol
  PARAMS ((segT, fragS *));
static void xtensa_add_literal_sym
  PARAMS ((symbolS *));
static void xtensa_add_insn_label
  PARAMS ((symbolS *));
static void xtensa_clear_insn_labels
  PARAMS ((void));
static bfd_boolean get_is_linkonce_section
  PARAMS ((bfd *, segT));
static bfd_boolean xg_emit_insn_to_buf
  PARAMS ((TInsn *, xtensa_format, char *, fragS *, offsetT, bfd_boolean));
static bfd_boolean xg_add_opcode_fix
  PARAMS ((TInsn *, int, xtensa_format, int, expressionS *, fragS *, offsetT));
static void xg_resolve_literals
  PARAMS ((TInsn *, symbolS *));
static void xg_resolve_labels
  PARAMS ((TInsn *, symbolS *));
static bfd_boolean is_register_writer
  PARAMS ((const TInsn *, const char *, int));
static bfd_boolean is_bad_loopend_opcode
  PARAMS ((const TInsn *));
static bfd_boolean is_unaligned_label
  PARAMS ((symbolS *));
static fragS *next_non_empty_frag
  PARAMS ((const fragS *));
static bfd_boolean next_frag_opcode_is_loop
  PARAMS ((const fragS *, xtensa_opcode *));
static int next_frag_format_size
  PARAMS ((const fragS *));
static int frag_format_size
  PARAMS ((const fragS *));
static void update_next_frag_state
  PARAMS ((fragS *, bfd_boolean));
static bfd_boolean next_frag_is_branch_target
  PARAMS ((const fragS *));
static bfd_boolean next_frag_is_loop_target
  PARAMS ((const fragS *));
static addressT next_frag_pre_opcode_bytes
  PARAMS ((const fragS *));
static bfd_boolean is_next_frag_target
  PARAMS ((const fragS *, const fragS *));
static void xtensa_mark_literal_pool_location
  PARAMS ((void));
static void xtensa_move_labels
  PARAMS ((fragS *, valueT, bfd_boolean));
static void assemble_nop
  PARAMS ((size_t, char *));
static void build_nop
  PARAMS ((TInsn *, int));
static addressT get_expanded_loop_offset
  PARAMS ((xtensa_opcode));
static fragS *get_literal_pool_location
  PARAMS ((segT));
static void set_literal_pool_location
  PARAMS ((segT, fragS *));
static void xtensa_set_frag_assembly_state
  PARAMS ((fragS *));
static bfd_boolean relaxable_section
  PARAMS ((asection *));
static void xtensa_find_unmarked_state_frags
  PARAMS ((void));
static void xtensa_find_unaligned_branch_targets
  PARAMS ((bfd *, asection *, PTR));
static void xtensa_find_unaligned_loops
  PARAMS ((bfd *, asection *, PTR));
static void xg_apply_tentative_value
  PARAMS ((fixS *, valueT));
static void finish_vinsn
  PARAMS ((vliw_insn *));
static bfd_boolean find_vinsn_conflicts
  PARAMS ((vliw_insn *));
static char check_t1_t2_reads_and_writes
  PARAMS ((TInsn *, TInsn *));
static bfd_boolean resources_conflict
  PARAMS ((vliw_insn *));
static xtensa_format xg_find_narrowest_format
  PARAMS ((vliw_insn *));
static int relaxation_requirements
  PARAMS ((vliw_insn *));
static void bundle_single_op
  PARAMS ((TInsn *));
static bfd_boolean emit_single_op
  PARAMS ((TInsn *));
static void xg_assemble_vliw_tokens
  PARAMS ((vliw_insn *));

/* Helpers for xtensa_end().  */

static void xtensa_cleanup_align_frags
  PARAMS ((void));
static void xtensa_fix_target_frags
  PARAMS ((void));
static bfd_boolean frag_can_negate_branch
  PARAMS ((fragS *));
static void xtensa_mark_narrow_branches
  PARAMS ((void));
static bfd_boolean is_narrow_branch_guaranteed_in_range
  PARAMS ((fragS *, TInsn *));
static void xtensa_mark_zcl_first_insns
  PARAMS ((void));
static void xtensa_fix_a0_b_retw_frags
  PARAMS ((void));
static bfd_boolean next_instrs_are_b_retw
  PARAMS ((fragS *));
static void xtensa_fix_b_j_loop_end_frags
  PARAMS ((void));
static bfd_boolean next_instr_is_loop_end
  PARAMS ((fragS *));
static void xtensa_fix_close_loop_end_frags
  PARAMS ((void));
static size_t min_bytes_to_other_loop_end
  PARAMS ((fragS *, fragS *, offsetT, size_t));
static size_t unrelaxed_frag_min_size
  PARAMS ((fragS *));
static size_t unrelaxed_frag_max_size
  PARAMS ((fragS *));
static void xtensa_fix_short_loop_frags
  PARAMS ((void));
static size_t count_insns_to_loop_end
  PARAMS ((fragS *, bfd_boolean, size_t));
static size_t unrelaxed_frag_min_insn_count
  PARAMS ((fragS *));
static bfd_boolean branch_before_loop_end
  PARAMS ((fragS *));
static bfd_boolean unrelaxed_frag_has_b_j
  PARAMS ((fragS *));
static void xtensa_sanity_check
  PARAMS ((void));
static bfd_boolean is_empty_loop
  PARAMS ((const TInsn *, fragS *));
static bfd_boolean is_local_forward_loop
  PARAMS ((const TInsn *, fragS *));
d471 2
a472 14
static size_t get_text_align_power
  PARAMS ((int));
static addressT get_text_align_max_fill_size
  PARAMS ((int, bfd_boolean, bfd_boolean));
static addressT get_text_align_fill_size
  PARAMS ((addressT, int, int, bfd_boolean, bfd_boolean));
static size_t get_text_align_nop_count
  PARAMS ((size_t, bfd_boolean));
static size_t get_text_align_nth_nop_size
  PARAMS ((size_t, size_t, bfd_boolean));
static addressT get_noop_aligned_address
  PARAMS ((fragS *, addressT));
static addressT get_aligned_diff
  PARAMS ((fragS *, addressT, addressT *));
d476 1
a476 32
static long relax_frag_loop_align
  PARAMS ((fragS *, long));
static long relax_frag_add_nop
  PARAMS ((fragS *));
static long relax_frag_for_align
  PARAMS ((fragS *, long));
static long future_alignment_required
  PARAMS ((fragS *, long));
static addressT find_address_of_next_align_frag 
  PARAMS ((fragS **, int *, int *, int *, bfd_boolean *));
static long bytes_to_stretch
  PARAMS ((fragS *, int, int, int, int));
static long relax_frag_immed
  PARAMS ((segT, fragS *, long, int, xtensa_format, int, int *, bfd_boolean));

/* Helpers for md_convert_frag().  */

static void convert_frag_align_next_opcode
  PARAMS ((fragS *));
static void convert_frag_narrow
  PARAMS ((segT, fragS *, xtensa_format, int));
static void convert_frag_fill_nop
  PARAMS ((fragS *));
static void convert_frag_immed
  PARAMS ((segT, fragS *, int, xtensa_format, int));
static fixS *fix_new_exp_in_seg
  PARAMS ((segT, subsegT, fragS *, int, int, expressionS *, int,
	   bfd_reloc_code_real_type));
static void convert_frag_immed_finish_loop
  PARAMS ((segT, fragS *, TInsn *));
static offsetT get_expression_value
  PARAMS ((segT, expressionS *));
d480 3
a482 4
static unsigned get_last_insn_flags
  PARAMS ((segT, subsegT));
static void set_last_insn_flags
  PARAMS ((segT, subsegT, unsigned, bfd_boolean));
d486 6
a491 26
static void xtensa_remove_section
  PARAMS ((segT));
static void xtensa_insert_section
  PARAMS ((segT, segT));
static void xtensa_move_seg_list_to_beginning
  PARAMS ((seg_list *));
static subseg_map *get_subseg_info
  PARAMS ((segT, subsegT));
static void xtensa_move_literals
  PARAMS ((void));
static void mark_literal_frags
  PARAMS ((seg_list *));
static void xtensa_reorder_seg_list
  PARAMS ((seg_list *, segT));
static void xtensa_reorder_segments
  PARAMS ((void));
static segT get_last_sec
  PARAMS ((void));
static void xtensa_switch_to_literal_fragment
  PARAMS ((emit_state *));
static void xtensa_switch_to_non_abs_literal_fragment
  PARAMS ((emit_state *));
static void xtensa_switch_section_emit_state
  PARAMS ((emit_state *, segT, subsegT));
static void xtensa_restore_emit_state
  PARAMS ((emit_state *));
d493 1
a493 7
  PARAMS ((seg_list *, const char *, segT *, bfd_boolean));
static segT retrieve_literal_seg
  PARAMS ((seg_list *, const char *, bfd_boolean));
static segT seg_present
  PARAMS ((const char *));
static void add_seg_list
  PARAMS ((seg_list *, segT));
d497 5
a501 40
static bfd_boolean get_frag_is_literal
  PARAMS ((const fragS *));
static bfd_boolean get_frag_is_insn
  PARAMS ((const fragS *));
static bfd_boolean get_frag_is_no_transform
  PARAMS ((fragS *));
static void set_frag_is_specific_opcode
  PARAMS ((fragS *, bfd_boolean));
static void set_frag_is_no_transform
  PARAMS ((fragS *, bfd_boolean));
static void xtensa_create_property_segments
  PARAMS ((frag_predicate, frag_predicate, const char *, xt_section_type));
static void xtensa_create_xproperty_segments
  PARAMS ((frag_flags_fn, const char *, xt_section_type));
static segment_info_type *retrieve_segment_info
  PARAMS ((segT));
static segT retrieve_xtensa_section
  PARAMS ((char *));
static bfd_boolean section_has_property
  PARAMS ((segT, frag_predicate));
static bfd_boolean section_has_xproperty
  PARAMS ((segT, frag_flags_fn));
static void add_xt_block_frags
  PARAMS ((segT, segT, xtensa_block_info **, frag_predicate, frag_predicate));
static bfd_boolean xtensa_frag_flags_is_empty
  PARAMS ((const frag_flags *));
static void xtensa_frag_flags_init
  PARAMS ((frag_flags *));
static void get_frag_property_flags
  PARAMS ((const fragS *, frag_flags *));
static bfd_vma frag_flags_to_number
  PARAMS ((const frag_flags *));
static bfd_boolean xtensa_frag_flags_combinable
  PARAMS ((const frag_flags *, const frag_flags *));
static bfd_vma xt_block_aligned_size
  PARAMS ((const xtensa_block_info *));
static bfd_boolean xtensa_xt_block_combine
  PARAMS ((xtensa_block_info *, const xtensa_block_info *));
static void add_xt_prop_frags
  PARAMS ((segT, segT, xtensa_block_info **, frag_flags_fn));
d505 1
a505 2
extern char *xtensa_get_property_section_name
  PARAMS ((asection *, const char *));
d509 4
a512 8
static void init_op_placement_info_table
  PARAMS ((void));
extern bfd_boolean opcode_fits_format_slot
  PARAMS ((xtensa_opcode, xtensa_format, int));
static int xg_get_single_size
  PARAMS ((xtensa_opcode));
static xtensa_format xg_get_single_format
  PARAMS ((xtensa_opcode));
d516 9
a524 22
static bfd_boolean tinsn_has_symbolic_operands
  PARAMS ((const TInsn *));
static bfd_boolean tinsn_has_invalid_symbolic_operands
  PARAMS ((const TInsn *));
static bfd_boolean tinsn_has_complex_operands
  PARAMS ((const TInsn *));
static bfd_boolean tinsn_to_insnbuf
  PARAMS ((TInsn *, xtensa_insnbuf));
static bfd_boolean tinsn_to_slotbuf
  PARAMS ((xtensa_format, int, TInsn *, xtensa_insnbuf));
static bfd_boolean tinsn_check_arguments
  PARAMS ((const TInsn *));
static void tinsn_from_chars
  PARAMS ((TInsn *, char *, int));
static void tinsn_from_insnbuf
  PARAMS ((TInsn *, xtensa_insnbuf, xtensa_format, int));
static void tinsn_immed_from_frag
  PARAMS ((TInsn *, fragS *, int));
static int get_num_stack_text_bytes
  PARAMS ((IStack *));
static int get_num_stack_literal_bytes
  PARAMS ((IStack *));
d528 4
a531 8
static void xg_init_vinsn
  PARAMS ((vliw_insn *));
static void xg_clear_vinsn
  PARAMS ((vliw_insn *));
static bfd_boolean vinsn_has_specific_opcodes
  PARAMS ((vliw_insn *));
static void xg_free_vinsn
  PARAMS ((vliw_insn *));
d533 2
a534 3
  PARAMS ((vliw_insn *, char *, fragS *, bfd_boolean));
static void vinsn_from_chars
  PARAMS ((vliw_insn *, char *));
d538 6
a543 12
bfd_boolean expr_is_const
  PARAMS ((const expressionS *));
offsetT get_expr_const
  PARAMS ((const expressionS *));
void set_expr_const
  PARAMS ((expressionS *, offsetT));
bfd_boolean expr_is_register
  PARAMS ((const expressionS *));
offsetT get_expr_register
  PARAMS ((const expressionS *));
void set_expr_symbol_offset
  PARAMS ((expressionS *, symbolS *, offsetT));
d545 3
a547 5
  PARAMS ((expressionS *, symbolS *, symbolS *, offsetT));
bfd_boolean expr_is_equal
  PARAMS ((expressionS *, expressionS *));
static void copy_expr
  PARAMS ((expressionS *, const expressionS *));
d550 2
a551 4
static void build_section_rename
  PARAMS ((const char *));
static void add_section_rename
  PARAMS ((char *, char *));
d612 19
d713 3
a715 3
  { "no-target-align", no_argument, NULL,
    option_no_align_targets },
  { "warn-unaligned-targets", no_argument, NULL, option_warn_unaligned_targets },
d730 2
a731 1
  { "workaround-short-loops", no_argument, NULL, option_workaround_short_loop },
d749 1
a749 2
  { "rename-section", required_argument, NULL,
    option_rename_section_name },
d764 1
a764 3
md_parse_option (c, arg)
     int c;
     char *arg;
d937 1
a937 2
md_show_usage (stream)
     FILE *stream;
d955 57
d1014 1
a1014 3
xtensa_setup_hw_workarounds (earliest, latest)
     int earliest;
     int latest; 
d1016 1
a1016 2
  if (earliest > latest)
    as_fatal (_("illegal range of target hardware versions"));
d1018 1
a1018 2
  /* Enable all workarounds for pre-T1050.0 hardware.  */
  if (earliest < 105000 || latest < 105000)
d1020 6
a1025 5
      workaround_a0_b_retw |= TRUE;
      workaround_b_j_loop_end |= TRUE;
      workaround_short_loop |= TRUE;
      workaround_close_loop_end |= TRUE;
      workaround_all_short_loops |= TRUE;
d1062 2
a1063 2
bfd_boolean
use_transform ()
d1072 2
a1073 2
bfd_boolean
use_longcalls ()
d1082 2
a1083 2
bfd_boolean
do_align_targets ()
d1093 1
a1093 4
directive_push (directive, negated, datum)
     directiveE directive;
     bfd_boolean negated;
     const void *datum;
d1113 1
d1115 5
a1119 6
directive_pop (directive, negated, file, line, datum)
     directiveE *directive;
     bfd_boolean *negated;
     const char **file;
     unsigned int *line;
     const void **datum;
d1142 1
a1142 1
directive_balance ()
d1160 1
a1160 2
inside_directive (dir)
     directiveE dir;
d1172 1
a1172 3
get_directive (directive, negated)
     directiveE *directive;
     bfd_boolean *negated;
d1225 1
a1225 2
xtensa_begin_directive (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1336 1
a1336 2
xtensa_end_directive (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1438 1
a1438 2
xtensa_dwarf2_directive_loc (x)
     int x;
d1446 1
a1446 3
xtensa_dwarf2_emit_insn (size, loc)
     int size;
     struct dwarf2_line_info *loc;
d1458 1
a1458 2
xtensa_literal_position (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1474 1
a1474 2
xtensa_literal_pseudo (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1543 1
a1543 3
xtensa_literal_prefix (start, len)
     char const *start;
     int len;
d1605 1
a1605 2
xtensa_frequency_pseudo (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1638 1
a1638 2
xtensa_elf_cons (nbytes)
     int nbytes;
d1693 2
d1698 1
a1698 3
xtensa_elf_suffix (str_p, exp_p)
     char **str_p;
     expressionS *exp_p;
a1768 2

/* Parsing and Idiom Translation.  */
d1771 1
a1771 2
expression_end (name)
     const char *name;
d1797 1
a1797 2
tc_get_register (prefix)
     const char *prefix;
d1852 1
a1852 4
expression_maybe_register (opc, opnd, tok)
     xtensa_opcode opc;
     int opnd;
     expressionS *tok;
d1922 1
a1922 3
tokenize_arguments (args, str)
     char **args;
     char *str;
d2008 1
a2008 4
parse_arguments (insn, num_args, arg_strings)
     TInsn *insn;
     int num_args;
     char **arg_strings;
d2106 1
a2106 2
get_invisible_operands (insn)
     TInsn *insn;
d2174 1
a2174 2
xg_reverse_shift_count (cnt_argp)
     char **cnt_argp;
d2192 1
a2192 3
xg_arg_is_constant (arg, valp)
     char *arg;
     offsetT *valp;
d2212 1
a2212 3
xg_replace_opname (popname, newop)
     char **popname;
     char *newop;
d2221 4
a2224 5
xg_check_num_args (pnum_args, expected_num, opname, arg_strings)
     int *pnum_args;
     int expected_num;
     char *opname;
     char **arg_strings;
d2256 1
a2256 4
xg_translate_sysreg_op (popname, pnum_args, arg_strings)
     char **popname;
     int *pnum_args;
     char **arg_strings;
d2326 1
a2326 2
xtensa_translate_old_userreg_ops (popname)
     char **popname;
d2387 5
a2391 6
xtensa_translate_zero_immed (old_op, new_op, popname, pnum_args, arg_strings)
     char *old_op;
     char *new_op;
     char **popname;
     int *pnum_args;
     char **arg_strings;
d2421 1
a2421 4
xg_translate_idioms (popname, pnum_args, arg_strings)
     char **popname;
     int *pnum_args;
     char **arg_strings;
d2540 2
a2541 3
int
get_relaxable_immed (opcode)
     xtensa_opcode opcode;
d2565 1
a2565 3
get_opcode_from_buf (buf, slot)
     const char *buf;
     int slot;
d2595 2
a2596 2
void
xtensa_print_insn_table ()
d2629 1
a2629 2
print_vliw_insn (vbuf)
     xtensa_insnbuf vbuf;
d2670 1
a2670 2
is_direct_call_opcode (opcode)
     xtensa_opcode opcode;
d2694 1
a2694 2
is_entry_opcode (opcode)
     xtensa_opcode opcode;
d2707 1
a2707 2
is_movi_opcode (opcode)
     xtensa_opcode opcode;
d2718 1
a2718 2
is_the_loop_opcode (opcode)
     xtensa_opcode opcode;
d2728 1
a2728 2
is_jx_opcode (opcode)
     xtensa_opcode opcode;
d2741 1
a2741 2
is_windowed_return_opcode (opcode)
     xtensa_opcode opcode;
d2754 1
a2754 4
decode_reloc (reloc, slot, is_alt)
     bfd_reloc_code_real_type reloc;
     int *slot;
     bfd_boolean *is_alt;
d2780 1
a2780 2
encode_reloc (slot)
     int slot;
d2793 1
a2793 2
encode_alt_reloc (slot)
     int slot;
d2803 8
a2810 10
xtensa_insnbuf_set_operand (slotbuf, fmt, slot, opcode, operand, value,
			    file, line)
     xtensa_insnbuf slotbuf;
     xtensa_format fmt;
     int slot;
     xtensa_opcode opcode;
     int operand;
     uint32 value;
     const char *file;
     unsigned int line;
d2834 5
a2838 6
xtensa_insnbuf_get_operand (slotbuf, fmt, slot, opcode, opnum)
     xtensa_insnbuf slotbuf;
     xtensa_format fmt;
     int slot;
     xtensa_opcode opcode;
     int opnum;
d2848 7
a2854 1
/* Various Other Internal Functions.  */
d2857 2
a2858 2
is_unique_insn_expansion (r)
     TransitionRule *r;
d2860 12
a2871 5
  if (!r->to_instr || r->to_instr->next != NULL)
    return FALSE;
  if (r->to_instr->typ != INSTR_INSTR)
    return FALSE;
  return TRUE;
d2875 3
a2877 3
static int
xg_get_build_instr_size (insn)
     BuildInstr *insn;
d2879 3
a2881 16
  assert (insn->typ == INSTR_INSTR);
  return xg_get_single_size (insn->opcode);
}


bfd_boolean
xg_is_narrow_insn (insn)
     TInsn *insn;
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int num_match = 0;
  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
d2883 2
a2884 16
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule)
	  && is_unique_insn_expansion (rule))
	{
	  /* It only generates one instruction... */
	  assert (insn->insn_type == ITYPE_INSN);
	  /* ...and it is a larger instruction.  */
	  if (xg_get_single_size (insn->opcode)
	      < xg_get_build_instr_size (rule->to_instr))
	    {
	      num_match++;
	      if (num_match > 1)
		return FALSE;
	    }
	}
d2886 1
a2886 1
  return (num_match == 1);
d2890 2
a2891 3
bfd_boolean
xg_is_single_relaxable_insn (insn)
     TInsn *insn;
d2893 5
a2897 7
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int num_match = 0;
  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
d2899 4
a2902 16
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule)
	  && is_unique_insn_expansion (rule))
	{
	  /* It only generates one instruction... */
	  assert (insn->insn_type == ITYPE_INSN);
	  /* ... and it is a larger instruction.  */
	  if (xg_get_single_size (insn->opcode)
	      <= xg_get_build_instr_size (rule->to_instr))
	    {
	      num_match++;
	      if (num_match > 1)
		return FALSE;
	    }
	}
d2904 1
a2904 1
  return (num_match == 1);
d2908 1
a2908 1
/* Return the maximum number of bytes this opcode can expand to.  */
d2910 2
a2911 3
int
xg_get_max_insn_widen_size (opcode)
     xtensa_opcode opcode;
d2913 1
a2913 3
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int max_size = xg_get_single_size (opcode);
d2915 2
a2916 1
  assert (opcode < table->num_opcodes);
d2918 3
a2920 1
  for (l = table->table[opcode]; l != NULL; l = l->next)
d2922 3
a2924 3
      TransitionRule *rule = l->rule;
      BuildInstr *build_list;
      int this_size = 0;
d2926 265
a3190 4
      if (!rule)
	continue;
      build_list = rule->to_instr;
      if (is_unique_insn_expansion (rule))
d3218 2
a3219 3
int
xg_get_max_insn_widen_literal_size (opcode)
     xtensa_opcode opcode;
d3249 122
a3370 9
		break;
	      case INSTR_INSTR:
	      case INSTR_LABEL_DEF:
	      default:
		break;
	      }
	  }
      if (this_size > max_size)
	max_size = this_size;
d3372 1
a3372 1
  return max_size;
d3376 9
a3384 4
bfd_boolean
xg_is_relaxable_insn (insn, lateral_steps)
     TInsn *insn;
     int lateral_steps;
d3386 7
a3392 3
  int steps_taken = 0;
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
a3394 1
  assert (insn->opcode < table->num_opcodes);
d3396 1
a3396 1
  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
d3398 3
a3400 1
      TransitionRule *rule = l->rule;
d3402 1
a3402 1
      if (xg_instruction_matches_rule (insn, rule))
d3404 24
a3427 7
	  if (steps_taken == lateral_steps)
	    return TRUE;
	  steps_taken++;
	}
    }
  return FALSE;
}
d3429 6
d3436 4
a3439 4
static symbolS *
get_special_literal_symbol ()
{
  static symbolS *sym = NULL;
d3441 5
a3445 4
  if (sym == NULL)
    sym = symbol_find_or_make ("SPECIAL_LITERAL0\001");
  return sym;
}
d3447 12
d3460 5
a3464 4
static symbolS *
get_special_label_symbol ()
{
  static symbolS *sym = NULL;
d3466 1
a3466 3
  if (sym == NULL)
    sym = symbol_find_or_make ("SPECIAL_LABEL0\001");
  return sym;
d3472 2
a3473 5
bfd_boolean
xg_build_to_insn (targ, insn, bi)
     TInsn *targ;
     TInsn *insn;
     BuildInstr *bi;
d3626 2
a3627 5
bfd_boolean
xg_build_to_stack (istack, insn, bi)
     IStack *istack;
     TInsn *insn;
     BuildInstr *bi;
d3642 2
a3643 5
bfd_boolean
xg_expand_to_stack (istack, insn, lateral_steps)
     IStack *istack;
     TInsn *insn;
     int lateral_steps;
d3689 2
a3690 4
bfd_boolean
xg_expand_narrow (targ, insn)
     TInsn *targ;
     TInsn *insn;
a3715 147

/* Assumes: All immeds are constants.  Check that all constants fit
   into their immeds; return FALSE if not.  */

static bfd_boolean
xg_immeds_fit (insn)
     const TInsn *insn;
{
  xtensa_isa isa = xtensa_default_isa;
  int i;

  int n = insn->ntok;
  assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < n; ++i)
    {
      const expressionS *expr = &insn->tok[i];
      if (xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	continue;

      switch (expr->X_op)
	{
	case O_register:
	case O_constant:
	  if (xg_check_operand (expr->X_add_number, insn->opcode, i))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  assert (FALSE);
	  break;
	}
    }
  return TRUE;
}


/* This should only be called after we have an initial
   estimate of the addresses.  */

static bfd_boolean
xg_symbolic_immeds_fit (insn, pc_seg, pc_frag, pc_offset, stretch)
     const TInsn *insn;
     segT pc_seg;
     fragS *pc_frag;
     offsetT pc_offset;
     long stretch;
{
  xtensa_isa isa = xtensa_default_isa;
  symbolS *symbolP;
  fragS *sym_frag;
  offsetT target, pc;
  uint32 new_offset;
  int i;
  int n = insn->ntok;

  assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
    {
      const expressionS *expr = &insn->tok[i];
      if (xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	continue;

      switch (expr->X_op)
	{
	case O_register:
	case O_constant:
	  if (xg_check_operand (expr->X_add_number, insn->opcode, i))
	    return FALSE;
	  break;

	case O_lo16:
	case O_hi16:
	  /* Check for the worst case.  */
	  if (xg_check_operand (0xffff, insn->opcode, i))
	    return FALSE;
	  break;

	case O_symbol:
	  /* We only allow symbols for pc-relative stuff.
	     If pc_frag == 0, then we don't have frag locations yet.  */
	  if (pc_frag == 0)
	    return FALSE;

	  /* If it is PC-relative and the symbol is not in the same 
	     segment as the PC.... */
	  if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 0
	      || S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
	    return FALSE;

	  /* If it is a weak symbol, then assume it won't reach.  This will
	     only affect calls when longcalls are enabled, because if
	     longcalls are disabled, then the call is marked as a specific
	     opcode.  */
	  if (S_IS_WEAK (expr->X_add_symbol))
	    return FALSE;

	  symbolP = expr->X_add_symbol;
	  sym_frag = symbol_get_frag (symbolP);
	  target = S_GET_VALUE (symbolP) + expr->X_add_number;
	  pc = pc_frag->fr_address + pc_offset;

	  /* If frag has yet to be reached on this pass, assume it
	     will move by STRETCH just as we did.  If this is not so,
	     it will be because some frag between grows, and that will
	     force another pass.  Beware zero-length frags.  There
	     should be a faster way to do this.  */

	  if (stretch != 0
	      && sym_frag->relax_marker != pc_frag->relax_marker
	      && S_GET_SEGMENT (symbolP) == pc_seg)
	    {
	      target += stretch;
	    }
 
	  new_offset = target;
	  xtensa_operand_do_reloc (isa, insn->opcode, i, &new_offset, pc);
	  if (xg_check_operand (new_offset, insn->opcode, i))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  return FALSE;
	}
    }

  return TRUE;
}


/* This will check to see if the value can be converted into the
   operand type.  It will return TRUE if it does not fit.  */

static bfd_boolean
xg_check_operand (value, opcode, operand)
     int32 value;
     xtensa_opcode opcode;
     int operand;
{
  uint32 valbuf = value;
  if (xtensa_operand_encode (xtensa_default_isa, opcode, operand, &valbuf))
    return TRUE;
  return FALSE;
}

a3716 1

d3720 8
a3727 10
int
xg_assembly_relax (istack, insn, pc_seg, pc_frag, pc_offset, min_steps,
		   stretch)
     IStack *istack;
     TInsn *insn;
     segT pc_seg;
     fragS *pc_frag;		/* if pc_frag == 0, then no pc-relative */
     offsetT pc_offset;		/* offset in fragment */
     int min_steps;		/* minimum number of conversion steps */
     long stretch;		/* number of bytes stretched so far */
d3800 1
a3800 2
xg_force_frag_space (size)
     int size;
d3809 6
a3814 7
void
xg_finish_frag (last_insn, frag_state, slot0_state, max_growth, is_insn)
     char *last_insn;
     enum xtensa_relax_statesE frag_state;
     enum xtensa_relax_statesE slot0_state;
     int max_growth;
     bfd_boolean is_insn;
d3842 26
d3869 1
a3869 3
is_branch_jmp_to_next (insn, fragP)
     TInsn *insn;
     fragS *fragP;
d3919 1
a3919 2
xg_add_branch_and_loop_targets (insn)
     TInsn *insn;
d3933 4
a3936 244
  if (xtensa_opcode_is_branch (isa, insn->opcode) == 1
      || xtensa_opcode_is_loop (isa, insn->opcode) == 1)
    {
      int i;

      for (i = 0; i < insn->ntok && i < num_ops; i++)
	{
	  if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1
	      && insn->tok[i].X_op == O_symbol)
	    {
	      symbolS *sym = insn->tok[i].X_add_symbol;
	      symbol_get_tc (sym)->is_branch_target = TRUE;
	      if (S_IS_DEFINED (sym))
		symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;
	    }
	}
    }
}


/* The routine xg_instruction_matches_option_term must return TRUE
   when a given option term is true.  The meaning of all of the option
   terms is given interpretation by this function.  This is needed when
   an option depends on the state of a directive, but there are no such
   options in use right now.  */

bfd_boolean
xg_instruction_matches_option_term (insn, option)
     TInsn *insn ATTRIBUTE_UNUSED;
     const ReqOrOption *option;
{
  if (strcmp (option->option_name, "realnop") == 0
      || strncmp (option->option_name, "IsaUse", 6) == 0)
    {
      /* These conditions were evaluated statically when building the
	 relaxation table.  There's no need to reevaluate them now.  */
      return TRUE;
    }
  else
    {
      as_fatal (_("internal error: unknown option name '%s'"),
		option->option_name);
    }
}


bfd_boolean
xg_instruction_matches_or_options (insn, or_option)
     TInsn *insn;
     const ReqOrOptionList *or_option;
{
  const ReqOrOption *option;
  /* Must match each of the AND terms.  */
  for (option = or_option; option != NULL; option = option->next)
    {
      if (xg_instruction_matches_option_term (insn, option))
	return TRUE;
    }
  return FALSE;
}


bfd_boolean
xg_instruction_matches_options (insn, options)
     TInsn *insn;
     const ReqOptionList *options;
{
  const ReqOption *req_options;
  /* Must match each of the AND terms.  */
  for (req_options = options;
       req_options != NULL;
       req_options = req_options->next)
    {
      /* Must match one of the OR clauses.  */
      if (!xg_instruction_matches_or_options (insn,
					      req_options->or_option_terms))
	return FALSE;
    }
  return TRUE;
}


/* Return the transition rule that matches or NULL if none matches.  */

bfd_boolean
xg_instruction_matches_rule (insn, rule)
     TInsn *insn;
     TransitionRule *rule;
{
  PreconditionList *condition_l;

  if (rule->opcode != insn->opcode)
    return FALSE;

  for (condition_l = rule->conditions;
       condition_l != NULL;
       condition_l = condition_l->next)
    {
      expressionS *exp1;
      expressionS *exp2;
      Precondition *cond = condition_l->precond;

      switch (cond->typ)
	{
	case OP_CONSTANT:
	  /* The expression must be the constant.  */
	  assert (cond->op_num < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  if (expr_is_const (exp1))
	    {
	      switch (cond->cmp)
		{
		case OP_EQUAL:
		  if (get_expr_const (exp1) != cond->op_data)
		    return FALSE;
		  break;
		case OP_NOTEQUAL:
		  if (get_expr_const (exp1) == cond->op_data)
		    return FALSE;
		  break;
		default:
		  return FALSE;
		}
	    }
	  else if (expr_is_register (exp1))
	    {
	      switch (cond->cmp)
		{
		case OP_EQUAL:
		  if (get_expr_register (exp1) != cond->op_data)
		    return FALSE;
		  break;
		case OP_NOTEQUAL:
		  if (get_expr_register (exp1) == cond->op_data)
		    return FALSE;
		  break;
		default:
		  return FALSE;
		}
	    }
	  else
	    return FALSE;
	  break;

	case OP_OPERAND:
	  assert (cond->op_num < insn->ntok);
	  assert (cond->op_data < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  exp2 = &insn->tok[cond->op_data];

	  switch (cond->cmp)
	    {
	    case OP_EQUAL:
	      if (!expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    case OP_NOTEQUAL:
	      if (expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    }
	  break;

	case OP_LITERAL:
	case OP_LABEL:
	default:
	  return FALSE;
	}
    }
  if (!xg_instruction_matches_options (insn, rule->options))
    return FALSE;

  return TRUE;
}


static int
transition_rule_cmp (a, b)
     const TransitionRule *a;
     const TransitionRule *b;
{
  bfd_boolean a_greater = FALSE;
  bfd_boolean b_greater = FALSE;

  ReqOptionList *l_a = a->options;
  ReqOptionList *l_b = b->options;

  /* We only care if they both are the same except for
     a const16 vs. an l32r.  */

  while (l_a && l_b && ((l_a->next == NULL) == (l_b->next == NULL)))
    {
      ReqOrOptionList *l_or_a = l_a->or_option_terms;
      ReqOrOptionList *l_or_b = l_b->or_option_terms;
      while (l_or_a && l_or_b && ((l_a->next == NULL) == (l_b->next == NULL)))
	{
	  if (l_or_a->is_true != l_or_b->is_true)
	    return 0;
	  if (strcmp (l_or_a->option_name, l_or_b->option_name) != 0)
	    {
	      /* This is the case we care about.  */
	      if (strcmp (l_or_a->option_name, "IsaUseConst16") == 0
		  && strcmp (l_or_b->option_name, "IsaUseL32R") == 0)
		{
		  if (prefer_const16)
		    a_greater = TRUE;
		  else
		    b_greater = TRUE;
		}
	      else if (strcmp (l_or_a->option_name, "IsaUseL32R") == 0
		       && strcmp (l_or_b->option_name, "IsaUseConst16") == 0)
		{
		  if (prefer_const16)
		    b_greater = TRUE;
		  else
		    a_greater = TRUE;
		}
	      else
		return 0;
	    }
	  l_or_a = l_or_a->next;
	  l_or_b = l_or_b->next;
	}
      if (l_or_a || l_or_b)
	return 0;

      l_a = l_a->next;
      l_b = l_b->next;
    }
  if (l_a || l_b)
    return 0;

  /* Incomparable if the substitution was used differently in two cases.  */
  if (a_greater && b_greater)
    return 0;

  if (b_greater)
    return 1;
  if (a_greater)
    return -1;

  return 0;
}

d3938 11
a3948 14
TransitionRule *
xg_instruction_match (insn)
     TInsn *insn;
{
  TransitionTable *table = xg_build_simplify_table (&transition_rule_cmp);
  TransitionList *l;
  assert (insn->opcode < table->num_opcodes);

  /* Walk through all of the possible transitions.  */
  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      if (xg_instruction_matches_rule (insn, rule))
	return rule;
a3949 1
  return NULL;
d3955 2
a3956 5
bfd_boolean
xg_build_token_insn (instr_spec, old_insn, new_insn)
     BuildInstr *instr_spec;
     TInsn *old_insn;
     TInsn *new_insn;
d4021 2
a4022 4
bfd_boolean
xg_simplify_insn (old_insn, new_insn)
     TInsn *old_insn;
     TInsn *new_insn;
d4054 1
a4054 3
xg_expand_assembly_insn (istack, orig_insn)
     IStack *istack;
     TInsn *orig_insn;
d4132 64
d4198 2
a4199 3
symbolS *
xg_assemble_literal (insn)
     /* const */ TInsn *insn;
a4263 19
bfd_boolean
xg_valid_literal_expression (exp)
     const expressionS *exp;
{
  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_big:
    case O_uminus:
    case O_subtract:
    case O_pltrel:
      return TRUE;
    default:
      return FALSE;
    }
}


d4265 1
a4265 3
xg_assemble_literal_space (size, slot)
     /* const */ int size;
     int slot;
a4294 132
symbolS *
xtensa_create_literal_symbol (sec, frag)
     segT sec;
     fragS *frag;
{
  static int lit_num = 0;
  static char name[256];
  symbolS *symbolP;

  sprintf (name, ".L_lit_sym%d", lit_num);

  /* Create a local symbol.  If it is in a linkonce section, we have to
     be careful to make sure that if it is used in a relocation that the
     symbol will be in the output file.  */
  if (get_is_linkonce_section (stdoutput, sec))
    {
      symbolP = symbol_new (name, sec, 0, frag);
      S_CLEAR_EXTERNAL (symbolP);
      /* symbolP->local = 1; */
    }
  else
    symbolP = symbol_new (name, sec, 0, frag);

  xtensa_add_literal_sym (symbolP);

  frag->tc_frag_data.is_literal = TRUE;
  lit_num++;
  return symbolP;
}


static void
xtensa_add_literal_sym (sym)
     symbolS *sym;
{
  sym_list *l;

  l = (sym_list *) xmalloc (sizeof (sym_list));
  l->sym = sym;
  l->next = literal_syms;
  literal_syms = l;
}


static void
xtensa_add_insn_label (sym)
     symbolS *sym;
{
  sym_list *l;

  if (!free_insn_labels)
    l = (sym_list *) xmalloc (sizeof (sym_list));
  else
    {
      l = free_insn_labels;
      free_insn_labels = l->next;
    }

  l->sym = sym;
  l->next = insn_labels;
  insn_labels = l;
}


static void
xtensa_clear_insn_labels (void)
{
  sym_list **pl;

  for (pl = &free_insn_labels; *pl != NULL; pl = &(*pl)->next)
    ;
  *pl = insn_labels;
  insn_labels = NULL;
}


/* Return TRUE if the section flags are marked linkonce
   or the name is .gnu.linkonce*.  */

bfd_boolean
get_is_linkonce_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
{
  flagword flags, link_once_flags;

  flags = bfd_get_section_flags (abfd, sec);
  link_once_flags = (flags & SEC_LINK_ONCE);

  /* Flags might not be set yet.  */
  if (!link_once_flags)
    {
      static size_t len = sizeof ".gnu.linkonce.t.";

      if (strncmp (segment_name (sec), ".gnu.linkonce.t.", len - 1) == 0)
	link_once_flags = SEC_LINK_ONCE;
    }
  return (link_once_flags != 0);
}


static bfd_boolean
xg_emit_insn_to_buf (tinsn, fmt, buf, fragP, offset, build_fix)
     TInsn *tinsn;
     xtensa_format fmt;
     char *buf;
     fragS *fragP;
     offsetT offset;
     bfd_boolean build_fix;
{
  static xtensa_insnbuf insnbuf = NULL;
  bfd_boolean has_symbolic_immed = FALSE;
  bfd_boolean ok = TRUE;
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  has_symbolic_immed = tinsn_to_insnbuf (tinsn, insnbuf);
  if (has_symbolic_immed && build_fix)
    {
      /* Add a fixup.  */
      int opnum = get_relaxable_immed (tinsn->opcode);
      expressionS *exp = &tinsn->tok[opnum];

      if (!xg_add_opcode_fix (tinsn, opnum, fmt, 0, exp, fragP, offset))
	ok = FALSE;
    }
  fragP->tc_frag_data.is_insn = TRUE;
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf, 0);
  return ok;
}


d4298 8
a4305 9
bfd_boolean
xg_add_opcode_fix (tinsn, opnum, fmt, slot, expr, fragP, offset)
     TInsn *tinsn;
     int opnum;
     xtensa_format fmt;
     int slot;
     expressionS *expr;
     fragS *fragP;
     offsetT offset;
d4374 32
a4405 3
      && (S_IS_EXTERNAL (expr->X_add_symbol)
	  || S_IS_WEAK (expr->X_add_symbol)))
    the_fix->fx_plt = TRUE;
d4407 6
a4412 5
  the_fix->tc_fix_data.X_add_symbol = expr->X_add_symbol;
  the_fix->tc_fix_data.X_add_number = expr->X_add_number;
  the_fix->tc_fix_data.slot = slot;
  
  return TRUE;
d4416 2
a4417 4
void
xg_resolve_literals (insn, lit_sym)
     TInsn *insn;
     symbolS *lit_sym;
d4431 2
a4432 4
void
xg_resolve_labels (insn, label_sym)
     TInsn *insn;
     symbolS *label_sym;
d4448 1
a4448 4
is_register_writer (insn, regset, regnum)
     const TInsn *insn;
     const char *regset;
     int regnum;
d4478 1
a4478 2
is_bad_loopend_opcode (tinsn)
     const TInsn * tinsn;
d4511 2
a4512 3
bfd_boolean
is_unaligned_label (sym)
     symbolS *sym;
d4538 2
a4539 3
fragS *
next_non_empty_frag (fragP)
     const fragS *fragP;
d4556 1
a4556 3
next_frag_opcode_is_loop (fragP, opcode)
     const fragS *fragP;
     xtensa_opcode *opcode;
d4575 1
a4575 11
next_frag_format_size (fragP)
     const fragS *fragP;
{
  const fragS *next_fragP = next_non_empty_frag (fragP);
  return frag_format_size (next_fragP);
}


static int
frag_format_size (fragP)
     const fragS * fragP;
d4629 2
a4630 6
/* Return TRUE if the target frag is one of the next non-empty frags.  */

bfd_boolean
is_next_frag_target (fragP, target)
     const fragS *fragP;
     const fragS *target;
d4632 2
a4633 18
  if (fragP == NULL)
    return FALSE;

  for (; fragP; fragP = fragP->fr_next)
    {
      if (fragP == target)
	return TRUE;
      if (fragP->fr_fix != 0)
	return FALSE;
      if (fragP->fr_type == rs_fill && fragP->fr_offset != 0)
	return FALSE;
      if ((fragP->fr_type == rs_align || fragP->fr_type == rs_align_code)
	  && ((fragP->fr_address % (1 << fragP->fr_offset)) != 0))
	return FALSE;
      if (fragP->fr_type == rs_space)
	return FALSE;
    }
  return FALSE;
d4641 1
a4641 3
update_next_frag_state (fragP, unreachable)
     fragS *fragP;
     bfd_boolean unreachable;
d4704 1
a4704 2
next_frag_is_branch_target (fragP)
     const fragS *fragP;
d4720 1
a4720 2
next_frag_is_loop_target (fragP)
     const fragS *fragP;
d4736 1
a4736 2
next_frag_pre_opcode_bytes (fragp)
     const fragS *fragp;
d4768 1
a4768 1
xtensa_mark_literal_pool_location ()
a4808 44
/* The "loops_ok" argument is provided to allow ignoring labels that 
   define loop ends.  This fixes a bug where the NOPs to align a 
   loop opcode were included in a previous zero-cost loop:

   loop a0, loopend
     <loop1 body>
   loopend:

   loop a2, loopend2
     <loop2 body>

   would become:

   loop a0, loopend
     <loop1 body>
     nop.n <===== bad!
   loopend:

   loop a2, loopend2
     <loop2 body>

   This argument is used to prevent moving the NOP to before the
   loop-end label, which is what you want in this special case.  */

static void
xtensa_move_labels (new_frag, new_offset, loops_ok)
     fragS *new_frag;
     valueT new_offset;
     bfd_boolean loops_ok;
{
  sym_list *lit;

  for (lit = insn_labels; lit; lit = lit->next)
    {
      symbolS *lit_sym = lit->sym;
      if (loops_ok || ! symbol_get_tc (lit_sym)->is_loop_target)
	{
	  S_SET_VALUE (lit_sym, new_offset);
	  symbol_set_frag (lit_sym, new_frag);
	}
    }
}


d4812 1
a4812 3
build_nop (tinsn, size)
     TInsn *tinsn;
     int size;
d4844 2
a4845 4
void
assemble_nop (size, buf)
     size_t size;
     char *buf;
d4868 1
a4868 2
get_expanded_loop_offset (opcode)
     xtensa_opcode opcode;
d4885 2
a4886 3
fragS *
get_literal_pool_location (seg)
     segT seg;
d4893 1
a4893 3
set_literal_pool_location (seg, literal_pool_loc)
     segT seg;
     fragS *literal_pool_loc;
d4902 2
a4903 3
void
xtensa_set_frag_assembly_state (fragP)
     fragS *fragP;
d4919 2
a4920 3
bfd_boolean
relaxable_section (sec)
     asection *sec;
d4927 1
a4927 1
xtensa_find_unmarked_state_frags ()
d4984 3
a4986 4
xtensa_find_unaligned_branch_targets (abfd, sec, unused)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR unused ATTRIBUTE_UNUSED;
d5021 3
a5023 4
xtensa_find_unaligned_loops (abfd, sec, unused)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR unused ATTRIBUTE_UNUSED;
d5058 2
a5059 4
void
xg_apply_tentative_value (fixP, val)
     fixS *fixP;
     valueT val;
d5109 1
a5109 1
xtensa_target_format ()
d5116 1
a5116 2
xtensa_file_arch_init (abfd)
     bfd *abfd;
d5123 1
a5123 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d5137 1
a5137 1
md_begin ()
d5200 1
a5200 2
xtensa_init_fix_data (x)
     fixS *x;
d5211 1
a5211 2
xtensa_frob_label (sym)
     symbolS *sym;
d5277 1
a5277 2
xtensa_unrecognized_line (ch)
     int ch;
d5322 1
a5322 1
xtensa_flush_pending_output ()
d5347 1
a5347 1
error_reset_cur_vinsn ()
d5360 1
a5360 2
md_assemble (str)
     char *str;
d5511 1
a5511 2
xtensa_handle_align (fragP)
     fragS *fragP;
d5539 1
a5539 2
xtensa_frag_init (frag)
     fragS *frag;
d5546 1
a5546 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d5555 1
a5555 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d5562 1
a5562 2
md_pcrel_from (fixP)
     fixS *fixP;
d5629 1
a5629 2
xtensa_force_relocation (fix)
     fixS *fix;
d5670 1
a5670 1
xtensa_check_inside_bundle ()
d5684 1
a5684 1
xtensa_elf_section_change_hook ()
d5695 1
a5695 2
xtensa_fix_adjustable (fixP)
     fixS *fixP;
d5729 1
a5729 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d5768 1
a5768 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d5811 1
a5811 3
md_estimate_size_before_relax (fragP, seg)
     fragS *fragP;
     segT seg ATTRIBUTE_UNUSED;
d5821 1
a5821 3
tc_gen_reloc (section, fixp)
     asection *section;
     fixS *fixp;
d5987 173
a6159 2
	  xg_apply_tentative_value (fixp, val);
	}
d6162 1
a6162 2
  return reloc;
}
d6164 6
d6171 2
a6172 1
/* md_post_relax_hook */
d6174 2
a6175 21
#define XTENSA_INSN_SEC_NAME ".xt.insn"
#define XTENSA_LIT_SEC_NAME ".xt.lit"
#define XTENSA_PROP_SEC_NAME ".xt.prop"

void
xtensa_post_relax_hook ()
{
  xtensa_move_seg_list_to_beginning (literal_head);
  xtensa_move_seg_list_to_beginning (init_literal_head);
  xtensa_move_seg_list_to_beginning (fini_literal_head);

  xtensa_find_unmarked_state_frags ();

  if (use_literal_section)
    xtensa_create_property_segments (get_frag_is_literal,
				     NULL,
				     XTENSA_LIT_SEC_NAME,
				     xt_literal_sec);
  xtensa_create_xproperty_segments (get_frag_property_flags,
				    XTENSA_PROP_SEC_NAME,
				    xt_prop_sec);
d6177 4
a6180 4
  if (warn_unaligned_branch_targets)
    bfd_map_over_sections (stdoutput, xtensa_find_unaligned_branch_targets, 0);
  bfd_map_over_sections (stdoutput, xtensa_find_unaligned_loops, 0);
}
d6186 1
a6186 2
finish_vinsn (vinsn)
     vliw_insn *vinsn;
d6376 2
d6379 1
a6379 2
find_vinsn_conflicts (vinsn)
     vliw_insn *vinsn;
d6465 1
a6465 3
check_t1_t2_reads_and_writes (t1, t2)
     TInsn *t1;
     TInsn *t2;
d6533 5
a6537 259
		  if (t1_inout == 'i' && (t2_inout == 'm' || t2_inout == 'o'))
		    {
		      conflict = 'a';
		      continue;
		    }

		  if (t1_inout != 'i' && t2_inout != 'i')
		    return 'c';
		}
	    }
	}
    }

  /* Check states.  */
  t1_states = xtensa_opcode_num_stateOperands (isa, t1->opcode);
  t2_states = xtensa_opcode_num_stateOperands (isa, t2->opcode);
  for (j = 0; j < t2_states; j++)
    {
      xtensa_state t2_so = xtensa_stateOperand_state (isa, t2->opcode, j);
      t2_inout = xtensa_stateOperand_inout (isa, t2->opcode, j);
      for (i = 0; i < t1_states; i++)
	{
	  xtensa_state t1_so = xtensa_stateOperand_state (isa, t1->opcode, i);
	  t1_inout = xtensa_stateOperand_inout (isa, t1->opcode, i);
	  if (t1_so != t2_so) 
	    continue;

	  if (t2_inout == 'i' && (t1_inout == 'm' || t1_inout == 'o'))
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout == 'i' && (t2_inout == 'm' || t2_inout == 'o'))
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout != 'i' && t2_inout != 'i')
	    return 'd';
	}      
    }

  /* Check tieports.  */
  t1_interfaces = xtensa_opcode_num_interfaceOperands (isa, t1->opcode);
  t2_interfaces = xtensa_opcode_num_interfaceOperands (isa, t2->opcode);
  for (j = 0; j < t2_interfaces; j++) 
    {
      xtensa_interface t2_int
	= xtensa_interfaceOperand_interface (isa, t2->opcode, j);
      t2_inout = xtensa_interface_inout (isa, j);
      if (xtensa_interface_has_side_effect (isa, t2_int) == 1 
	  && t2_inout != 'i')
	t2_volatile = TRUE;
      for (i = 0; i < t1_interfaces; i++)
	{
	  xtensa_interface t1_int
	    = xtensa_interfaceOperand_interface (isa, t1->opcode, j);
	  t1_inout = xtensa_interface_inout (isa, i);
	  if (xtensa_interface_has_side_effect (isa, t1_int) == 1 
	      && t1_inout != 'i')
	    t1_volatile = TRUE;
	  
	  if (t1_int != t2_int)
	    continue;
	  
	  if (t2_inout == 'i' && t1_inout == 'o')
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout == 'i' && t2_inout == 'o')
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout != 'i' && t2_inout != 'i')
	    return 'e';
	}
    }

  if (t1_volatile && t2_volatile)
    return 'f';
  
  return conflict;
}


/* The func unit stuff could be implemented as bit-vectors rather 
   than the iterative approach here.  If it ends up being too 
   slow, we will switch it.  */

resource_table * 
new_resource_table (data, cycles, nu, uncf, onuf, ouuf, ousf)
     void *data;
     int cycles;
     int nu;
     unit_num_copies_func uncf;
     opcode_num_units_func onuf;
     opcode_funcUnit_use_unit_func ouuf; 
     opcode_funcUnit_use_stage_func ousf;
{
  int i;
  resource_table *rt = (resource_table *) xmalloc (sizeof (resource_table));
  rt->data = data;
  rt->cycles = cycles;
  rt->allocated_cycles = cycles;
  rt->num_units = nu;
  rt->unit_num_copies = uncf;
  rt->opcode_num_units = onuf;
  rt->opcode_unit_use = ouuf;
  rt->opcode_unit_stage = ousf;

  rt->units = (char **) xcalloc (cycles, sizeof (char *));
  for (i = 0; i < cycles; i++)
    rt->units[i] = (char *) xcalloc (nu, sizeof (char));

  return rt;
}


void 
clear_resource_table (rt)
     resource_table *rt;
{
  int i, j;
  for (i = 0; i < rt->allocated_cycles; i++)
    for (j = 0; j < rt->num_units; j++)
      rt->units[i][j] = 0;
}


/* We never shrink it, just fake it into thinking so.  */

void 
resize_resource_table (rt, cycles)
     resource_table *rt;
     int cycles;
{
  int i, old_cycles;

  rt->cycles = cycles;
  if (cycles <= rt->allocated_cycles)
    return;

  old_cycles = rt->allocated_cycles;
  rt->allocated_cycles = cycles;

  rt->units = xrealloc (rt->units, sizeof (char *) * rt->allocated_cycles);
  for (i = 0; i < old_cycles; i++)
    rt->units[i] = xrealloc (rt->units[i], sizeof (char) * rt->num_units);
  for (i = old_cycles; i < cycles; i++)
    rt->units[i] = xcalloc (rt->num_units, sizeof (char));
}


bfd_boolean 
resources_available (rt, opcode, cycle)
     resource_table *rt;
     xtensa_opcode opcode;
     int cycle;
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      int copies_in_use = rt->units[stage + cycle][unit];
      int copies = (rt->unit_num_copies) (rt->data, unit);
      if (copies_in_use >= copies)
	return FALSE;
    }
  return TRUE;
}
     

void 
reserve_resources (rt, opcode, cycle)
     resource_table *rt;
     xtensa_opcode opcode;
     int cycle;
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      /* Note that this allows resources to be oversubscribed.  That's 
	 essential to the way the optional scheduler works. 
	 resources_available reports when a resource is over-subscribed,
	 so it's easy to tell.  */
      rt->units[stage + cycle][unit]++;
    }
}


void 
release_resources (rt, opcode, cycle)
     resource_table *rt;
     xtensa_opcode opcode;
     int cycle;
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      rt->units[stage + cycle][unit]--;
      assert (rt->units[stage + cycle][unit] >= 0);
    }
}
     

/* Wrapper functions make parameterized resource reservation
   more convenient.  */

int 
opcode_funcUnit_use_unit (data, opcode, idx)
     void *data;
     xtensa_opcode opcode;
     int idx;
{
  xtensa_funcUnit_use *use = xtensa_opcode_funcUnit_use (data, opcode, idx);
  return use->unit;  
}


int 
opcode_funcUnit_use_stage (data, opcode, idx)
     void *data;
     xtensa_opcode opcode;
     int idx;
{
  xtensa_funcUnit_use *use = xtensa_opcode_funcUnit_use (data, opcode, idx);
  return use->stage;
}


/* Note that this function does not check issue constraints, but
   solely whether the hardware is available to execute the given
   instructions together.  It also doesn't check if the tinsns 
   write the same state, or access the same tieports.  That is
   checked by check_t1_t2_read_write.  */

static bfd_boolean
resources_conflict (vinsn)
     vliw_insn *vinsn;
{
  int i;
  static resource_table *rt = NULL;
d6539 6
a6544 3
  /* This is the most common case by far.  Optimize it.  */
  if (vinsn->num_slots == 1)
    return FALSE;
d6546 4
a6549 1
  if (rt == NULL) 
d6551 24
a6574 8
      xtensa_isa isa = xtensa_default_isa;
      rt = new_resource_table
	(isa, xtensa_isa_num_pipe_stages (isa),
	 xtensa_isa_num_funcUnits (isa),
	 (unit_num_copies_func) xtensa_funcUnit_num_copies,
	 (opcode_num_units_func) xtensa_opcode_num_funcUnit_uses,
	 opcode_funcUnit_use_unit,
	 opcode_funcUnit_use_stage);
d6577 4
a6580 3
  clear_resource_table (rt);

  for (i = 0; i < vinsn->num_slots; i++)
d6582 33
a6614 3
      if (!resources_available (rt, vinsn->slots[i].opcode, 0))
	return TRUE;
      reserve_resources (rt, vinsn->slots[i].opcode, 0);
d6617 4
a6620 1
  return FALSE;
d6625 1
a6625 2
xg_find_narrowest_format (vinsn)
     vliw_insn *vinsn;
d6656 1
a6656 1
	      else
d6658 8
a6665 1
		  if (v_copy.num_slots > 1)
d6667 1
a6667 10
		      TInsn widened;
		      /* Try the widened version.  */
		      if (!v_copy.slots[slot].keep_wide
			  && !v_copy.slots[slot].is_specific_opcode
			  && xg_is_narrow_insn (&v_copy.slots[slot])
			  && !xg_expand_narrow (&widened, &v_copy.slots[slot])
			  && opcode_fits_format_slot (widened.opcode,
						      format, slot))
			{
			  /* The xg_is_narrow clause requires some explanation:
d6669 8
a6676 8
			     addi can be "widened" to an addmi, which is then
			     expanded to an addmi/addi pair if the immediate
			     requires it, but here we must have a single widen
			     only.

			     xg_is_narrow tells us that addi isn't really
			     narrow.  The widen_spec_list says that there are
			     other cases.  */
d6678 2
a6679 3
			  v_copy.slots[slot] = widened;
			  fit++;
			}
d6706 1
a6706 2
relaxation_requirements (vinsn)
     vliw_insn *vinsn;
d6770 1
a6770 2
bundle_single_op (orig_insn)
     TInsn *orig_insn;
d6808 1
a6808 2
emit_single_op (orig_insn)
     TInsn *orig_insn;
d6868 2
a6869 3
void
xg_assemble_vliw_tokens (vinsn)
     vliw_insn *vinsn;
d7128 12
d7141 1
a7141 1
xtensa_end ()
d7172 1
a7172 1
xtensa_cleanup_align_frags ()
d7223 2
d7226 1
a7226 1
xtensa_fix_target_frags ()
d7275 1
a7275 2
frag_can_negate_branch (fragP)
     fragS *fragP;
d7298 2
d7301 1
a7301 1
xtensa_mark_narrow_branches ()
d7354 2
d7357 1
a7357 3
is_narrow_branch_guaranteed_in_range (fragP, tinsn)
     fragS *fragP;
     TInsn *tinsn;
d7382 1
a7382 1
xtensa_mark_zcl_first_insns ()
d7420 2
d7423 1
a7423 1
xtensa_fix_a0_b_retw_frags ()
d7453 2
a7454 3
bfd_boolean
next_instrs_are_b_retw (fragP)
     fragS *fragP;
d7528 2
d7531 1
a7531 1
xtensa_fix_b_j_loop_end_frags ()
d7561 2
a7562 3
bfd_boolean
next_instr_is_loop_end (fragP)
     fragS * fragP;
d7591 2
d7594 1
a7594 1
xtensa_fix_close_loop_end_frags ()
d7679 2
d7682 4
a7685 5
min_bytes_to_other_loop_end (fragP, current_target, current_offset, max_size)
     fragS *fragP;
     fragS *current_target;
     offsetT current_offset;
     size_t max_size;
d7708 1
a7708 2
unrelaxed_frag_min_size (fragP)
     fragS *fragP;
d7721 1
a7721 2
unrelaxed_frag_max_size (fragP)
     fragS *fragP;
d7773 3
d7777 1
a7777 1
xtensa_fix_short_loop_frags ()
d7841 2
d7844 3
a7846 4
count_insns_to_loop_end (base_fragP, count_relax_add, max_count)
     fragS *base_fragP;
     bfd_boolean count_relax_add;
     size_t max_count;
d7878 1
a7878 2
unrelaxed_frag_min_insn_count (fragP)
     fragS *fragP;
d7912 2
d7915 1
a7915 2
branch_before_loop_end (base_fragP)
     fragS *base_fragP;
d7931 1
a7931 2
unrelaxed_frag_has_b_j (fragP)
     fragS *fragP;
d7970 3
d7974 1
a7974 1
xtensa_sanity_check ()
d8030 2
a8031 4
bfd_boolean
is_empty_loop (insn, fragP)
     const TInsn *insn;
     fragS *fragP;
d8077 2
a8078 4
bfd_boolean
is_local_forward_loop (insn, fragP)
     const TInsn *insn;
     fragS *fragP;
d8123 1
a8123 2
get_text_align_power (target_size)
     int target_size;
d8137 3
a8139 4
get_text_align_max_fill_size (align_pow, use_nops, use_no_density)
     int align_pow;
     bfd_boolean use_nops;
     bfd_boolean use_no_density;
d8174 5
a8178 7
get_text_align_fill_size (address, align_pow, target_size,
			  use_nops, use_no_density)
     addressT address;
     int align_pow;
     int target_size;
     bfd_boolean use_nops;
     bfd_boolean use_no_density;
d8258 2
a8259 4
size_t
get_text_align_nop_count (fill_size, use_no_density)
     size_t fill_size;
     bfd_boolean use_no_density;
d8283 4
a8286 5
size_t
get_text_align_nth_nop_size (fill_size, n, use_no_density)
     size_t fill_size;
     size_t n;
     bfd_boolean use_no_density;
d8314 1
a8314 3
get_noop_aligned_address (fragP, address)
     fragS *fragP;
     addressT address;
d8400 1
a8400 4
get_aligned_diff (fragP, address, max_diff)
     fragS *fragP;
     addressT address;
     addressT *max_diff;
d8466 6
d8476 1
a8476 4
xtensa_relax_frag (fragP, stretch, stretched_p)
     fragS *fragP;
     long stretch;
     int *stretched_p;
d8593 1
a8593 3
relax_frag_loop_align (fragP, stretch)
     fragS *fragP;
     long stretch;
d8626 1
a8626 2
relax_frag_add_nop (fragP)
     fragS *fragP;
d8645 2
d8648 1
a8648 3
relax_frag_for_align (fragP, stretch)
     fragS *fragP;
     long stretch;
d8702 5
a8706 7
find_address_of_next_align_frag (fragPP, wide_nops, narrow_nops,
				 widens, paddable)
     fragS **fragPP;
     int *wide_nops;
     int *narrow_nops;
     int *widens;
     bfd_boolean *paddable;
d8783 2
d8791 1
a8791 3
future_alignment_required (fragP, stretch)
     fragS *fragP;
     long stretch ATTRIBUTE_UNUSED;
d8806 2
a8807 3
  address 
    = find_address_of_next_align_frag (&fragP, &wide_nops, &narrow_nops, 
				       &num_widens, &paddable);
d8830 2
a8831 3
	  address = 
	    find_address_of_next_align_frag (&fragP, &glob_widens, 
					     &dnn, &dw, &glob_pad);
d8949 5
a8953 6
bytes_to_stretch (this_frag, wide_nops, narrow_nops, num_widens, desired_diff)
     fragS *this_frag;
     int wide_nops;
     int narrow_nops;
     int num_widens;
     int desired_diff;
d9083 8
a9090 10
relax_frag_immed (segP, fragP, stretch, min_steps, fmt, slot, stretched_p,
		  estimate_only)
     segT segP;
     fragS *fragP;
     long stretch;
     int min_steps;
     xtensa_format fmt;
     int slot;
     int *stretched_p;
     bfd_boolean estimate_only;
d9220 5
d9226 1
a9226 4
md_convert_frag (abfd, sec, fragp)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
     fragS *fragp;
d9339 2
a9340 3
void
convert_frag_align_next_opcode (fragp)
     fragS *fragp;
d9370 1
a9370 5
convert_frag_narrow (segP, fragP, fmt, slot)
     segT segP;
     fragS *fragP;
     xtensa_format fmt;
     int slot;
d9434 1
a9434 2
convert_frag_fill_nop (fragP)
     fragS *fragP;
d9454 5
d9460 5
a9464 6
convert_frag_immed (segP, fragP, min_steps, fmt, slot)
     segT segP;
     fragS *fragP;
     int min_steps;
     xtensa_format fmt;
     int slot;
d9760 8
a9767 10
fix_new_exp_in_seg (new_seg, new_subseg,
		    frag, where, size, exp, pcrel, r_type)
     segT new_seg;
     subsegT new_subseg;
     fragS *frag;
     int where;
     int size;
     expressionS *exp;
     int pcrel;
     bfd_reloc_code_real_type r_type;
d9799 2
d9802 1
a9802 4
convert_frag_immed_finish_loop (segP, fragP, tinsn)
     segT segP;
     fragS *fragP;
     TInsn *tinsn;
d9891 1
a9891 3
get_expression_value (segP, exp)
     segT segP;
     expressionS *exp;
a9911 11

static unsigned
get_last_insn_flags (seg, subseg)
     segT seg;
     subsegT subseg;
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  return subseg_e->flags;
}


d9913 1
a9913 3
get_subseg_info (seg, subseg)
     segT seg;
     subsegT subseg;
d9937 9
d9947 4
a9950 5
set_last_insn_flags (seg, subseg, fl, val)
     segT seg;
     subsegT subseg;
     unsigned fl;
     bfd_boolean val;
d9965 1
a9965 2
xtensa_remove_section (sec)
     segT sec;
d9982 1
a9982 3
xtensa_insert_section (after_sec, sec)
     segT after_sec;
     segT sec;
d9995 1
a9995 2
xtensa_move_seg_list_to_beginning (head)
     seg_list *head;
d10012 4
a10015 2
void
xtensa_move_literals ()
d10140 1
a10140 2
mark_literal_frags (segment)
     seg_list *segment;
d10160 1
a10160 3
xtensa_reorder_seg_list (head, after)
     seg_list *head;
     segT after;
d10185 4
a10188 2
void
xtensa_reorder_segments ()
d10212 2
a10213 2
segT
get_last_sec ()
d10227 2
a10228 3
void
xtensa_switch_to_literal_fragment (result)
     emit_state *result;
d10246 2
a10247 3
void
xtensa_switch_to_non_abs_literal_fragment (result)
     emit_state *result;
d10321 4
a10324 5
void
xtensa_switch_section_emit_state (state, new_now_seg, new_now_subseg)
     emit_state *state;
     segT new_now_seg;
     subsegT new_now_subseg;
d10337 2
a10338 3
void
xtensa_restore_emit_state (state)
     emit_state *state;
d10348 2
d10351 4
a10354 5
cache_literal_section (head, name, seg, is_code)
     seg_list *head;
     const char *name;
     segT *seg;
     bfd_boolean is_code;
d10369 3
d10373 1
a10373 4
retrieve_literal_seg (head, name, is_code)
     seg_list *head;
     const char *name;
     bfd_boolean is_code;
d10396 1
a10396 2
seg_present (name)
     const char *name;
d10415 1
a10415 3
add_seg_list (head, seg)
     seg_list *head;
     segT seg;
d10429 50
d10482 1
a10482 2
get_frag_is_literal (fragP)
     const fragS *fragP;
d10490 1
a10490 2
get_frag_is_insn (fragP)
     const fragS *fragP;
d10497 2
a10498 3
bfd_boolean
get_frag_is_no_transform (fragP)
     fragS *fragP;
d10504 2
a10505 4
void
set_frag_is_specific_opcode (fragP, is_specific_opcode)
     fragS *fragP;
     bfd_boolean is_specific_opcode;
d10511 2
a10512 4
void
set_frag_is_no_transform (fragP, is_no_transform)
     fragS *fragP;
     bfd_boolean is_no_transform;
d10519 4
a10522 6
xtensa_create_property_segments (property_function, end_property_function,
				 section_name_base, sec_type)
     frag_predicate property_function;
     frag_predicate end_property_function;
     const char *section_name_base;
     xt_section_type sec_type;
d10652 4
a10655 5
void
xtensa_create_xproperty_segments (flag_fn, section_name_base, sec_type)
     frag_flags_fn flag_fn;
     const char *section_name_base;
     xt_section_type sec_type;
d10788 2
a10789 3
segment_info_type *
retrieve_segment_info (seg)
     segT seg;
d10798 1
a10798 1
      memset ((PTR) seginfo, 0, sizeof (*seginfo));
d10811 1
a10811 1
	bfd_set_section_userdata (stdoutput, seg, (PTR) seginfo);
d10837 2
a10838 3
segT
retrieve_xtensa_section (sec_name)
     char *sec_name;
d10860 2
a10861 4
bfd_boolean
section_has_property (sec, property_function)
     segT sec;
     frag_predicate property_function;
d10879 2
a10880 4
bfd_boolean
section_has_xproperty (sec, property_function)
     segT sec;
     frag_flags_fn property_function;
d10901 6
a10906 8
void
add_xt_block_frags (sec, xt_block_sec, xt_block, property_function,
		    end_property_function)
     segT sec;
     segT xt_block_sec;
     xtensa_block_info **xt_block;
     frag_predicate property_function;
     frag_predicate end_property_function;
d10965 2
a10966 3
bfd_boolean
xtensa_frag_flags_is_empty (prop_flags)
     const frag_flags *prop_flags;
d10977 2
a10978 3
void
xtensa_frag_flags_init (prop_flags)
     frag_flags *prop_flags;
d10984 2
a10985 4
void
get_frag_property_flags (fragP, prop_flags)
     const fragS *fragP;
     frag_flags *prop_flags;
d10991 1
a10991 3
    {
      prop_flags->is_unreachable = TRUE;
    }
d11017 2
a11018 3
bfd_vma
frag_flags_to_number (prop_flags)
     const frag_flags *prop_flags;
d11057 2
a11058 3
xtensa_frag_flags_combinable (prop_flags_1, prop_flags_2)
     const frag_flags *prop_flags_1;
     const frag_flags *prop_flags_2;
d11097 2
a11098 3
bfd_vma
xt_block_aligned_size (xt_block)
     const xtensa_block_info *xt_block;
d11114 2
a11115 3
xtensa_xt_block_combine (xt_block, xt_block_2)
     xtensa_block_info *xt_block;
     const xtensa_block_info *xt_block_2;
d11161 5
a11165 6
void
add_xt_prop_frags (sec, xt_block_sec, xt_block, property_function)
     segT sec;
     segT xt_block_sec;
     xtensa_block_info **xt_block;
     frag_flags_fn property_function;
d11222 1
a11222 1
init_op_placement_info_table ()
d11292 1
a11292 4
opcode_fits_format_slot (opcode, fmt, slot)
     xtensa_opcode opcode;
     xtensa_format fmt;
     int slot;
d11300 2
a11301 3
int
xg_get_single_size (opcode)
     xtensa_opcode opcode;
d11308 2
a11309 3
xtensa_format
xg_get_single_format (opcode)
     xtensa_opcode opcode;
d11318 1
a11318 2
istack_init (stack)
     IStack *stack;
d11326 1
a11326 2
istack_empty (stack)
     IStack *stack;
d11333 1
a11333 2
istack_full (stack)
     IStack *stack;
d11343 1
a11343 2
istack_top (stack)
     IStack *stack;
d11355 1
a11355 3
istack_push (stack, insn)
     IStack *stack;
     TInsn *insn;
d11368 1
a11368 2
istack_push_space (stack)
     IStack *stack;
d11384 1
a11384 2
istack_pop (stack)
     IStack *stack;
d11396 1
a11396 2
tinsn_init (dst)
     TInsn *dst;
d11406 1
a11406 3
tinsn_get_tok (insn, num)
     TInsn *insn;
     int num;
d11416 1
a11416 2
tinsn_has_symbolic_operands (insn)
     const TInsn *insn;
d11439 1
a11439 2
tinsn_has_invalid_symbolic_operands (insn)
     const TInsn *insn;
d11491 1
a11491 2
tinsn_has_complex_operands (insn)
     const TInsn *insn;
d11525 1
a11525 3
tinsn_to_insnbuf (tinsn, insnbuf)
     TInsn *tinsn;
     xtensa_insnbuf insnbuf;
d11602 4
a11605 5
tinsn_to_slotbuf (fmt, slot, tinsn, slotbuf)
     xtensa_format fmt;
     int slot;
     TInsn *tinsn;
     xtensa_insnbuf slotbuf;
d11670 2
a11671 3
bfd_boolean
tinsn_check_arguments (insn)
     const TInsn *insn;
d11700 1
a11700 4
tinsn_from_chars (tinsn, f, slot)
     TInsn *tinsn;
     char *f;
     int slot;
d11713 4
a11716 5
tinsn_from_insnbuf (tinsn, slotbuf, fmt, slot)
     TInsn *tinsn;
     xtensa_insnbuf slotbuf;
     xtensa_format fmt;
     int slot;
d11739 1
a11739 4
tinsn_immed_from_frag (tinsn, fragP, slot)
     TInsn *tinsn;
     fragS *fragP;
     int slot;
d11768 1
a11768 2
get_num_stack_text_bytes (istack)
     IStack *istack;
d11784 1
a11784 2
get_num_stack_literal_bytes (istack)
     IStack *istack;
d11801 2
a11802 3
void
xg_init_vinsn (v)
     vliw_insn *v;
d11824 2
a11825 3
void
xg_clear_vinsn (v)
     vliw_insn *v;
d11843 2
a11844 3
bfd_boolean
vinsn_has_specific_opcodes (v)
     vliw_insn *v;
d11857 2
a11858 3
void
xg_free_vinsn (v)
     vliw_insn *v;
d11880 4
a11883 5
vinsn_to_insnbuf (vinsn, frag_offset, fragP, record_fixup)
     vliw_insn *vinsn;
     char *frag_offset;
     fragS *fragP;
     bfd_boolean record_fixup;
d11979 1
a11979 3
vinsn_from_chars (vinsn, f)
     vliw_insn *vinsn;
     char *f;
d12014 1
a12014 2
expr_is_const (s)
     const expressionS *s;
d12024 1
a12024 2
get_expr_const (s)
     const expressionS *s;
d12034 1
a12034 3
set_expr_const (s, val)
     expressionS *s;
     offsetT val;
d12044 1
a12044 2
expr_is_register (s)
     const expressionS *s;
d12054 1
a12054 2
get_expr_register (s)
     const expressionS *s;
d12064 1
a12064 4
set_expr_symbol_offset (s, sym, offset)
     expressionS *s;
     symbolS *sym;
     offsetT offset;
d12075 5
a12079 6
void
set_expr_symbol_offset_diff (s, sym, minus_sym, offset)
     expressionS *s;
     symbolS *sym;
     symbolS *minus_sym;
     offsetT offset;
d12091 1
a12091 3
expr_is_equal (s1, s2)
     expressionS *s1;
     expressionS *s2;
d12106 1
a12106 3
copy_expr (dst, src)
     expressionS *dst;
     const expressionS *src;
d12129 2
a12130 3
void
build_section_rename (arg)
     const char *arg;
d12170 1
a12170 3
add_section_rename (old_name, new_name)
     char *old_name;
     char *new_name;
d12195 1
a12195 2
xtensa_section_rename (name)
     const char *name;
@


1.10
log
@	* config/tc-xtensa.c (xg_assembler_literal): Fix a typo.
@
text
@d2 1
a2 1
   Copyright 2003 Free Software Foundation, Inc.
d18 1
a18 1
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, 
d22 1
a43 7
   There are 3 forms for instructions,
   1) the MEMORY format -- this is the encoding 2 or 3 byte instruction
   2) the TInsn -- handles instructions/labels and literals;
      all operands are assumed to be expressions
   3) the IStack -- a stack of TInsn.  this allows us to 
      reason about the generated expansion instructions
  
d68 2
a69 3
/* Flag to indicate whether the hardware supports the density option.
   If not, enabling density instructions (via directives or --density flag)
   is illegal.  */
a70 1
#if STATIC_LIBISA
d72 11
a82 3
#else
bfd_boolean density_supported = TRUE;
#endif
d84 4
a87 1
#define XTENSA_FETCH_WIDTH 4
d100 1
d107 1
a107 1
/* This type is used for the directive_stack to keep track of the 
d113 1
d117 1
d162 5
d170 131
d312 76
d395 1
a395 2
  directive_generics,
  directive_relax,
d398 4
a401 1
  directive_literal_prefix
d412 9
a420 8
  {"none",	FALSE},
  {"literal",	FALSE},
  {"density",	TRUE},
  {"generics",	TRUE},
  {"relax",	TRUE},
  {"freeregs",	FALSE},
  {"longcalls",	TRUE},
  {"literal_prefix", FALSE}
d427 1
a427 1
#if STATIC_LIBISA && !XCHAL_HAVE_DENSITY
d432 1
a432 2
  TRUE,				/* generics */
  TRUE,				/* relax */
d435 7
a441 95
  FALSE				/* literal_prefix */
};


enum xtensa_relax_statesE
{
  RELAX_ALIGN_NEXT_OPCODE,
  /* Use the first opcode of the next fragment to determine the
     alignment requirements.  This is ONLY used for LOOPS
     currently.  */

  RELAX_DESIRE_ALIGN_IF_TARGET,
  /* These are placed in front of labels.  They will all be converted
     to RELAX_DESIRE_ALIGN / RELAX_LOOP_END or rs_fill of 0 before
     relaxation begins.  */

  RELAX_ADD_NOP_IF_A0_B_RETW,
  /* These are placed in front of conditional branches.  It will be
     turned into a NOP (using a1) if the branch is immediately
     followed by a RETW or RETW.N.  Otherwise it will be turned into
     an rs_fill of 0 before relaxation begins.  */

  RELAX_ADD_NOP_IF_PRE_LOOP_END,
  /* These are placed after JX instructions.  It will be turned into a
     NOP if there is one instruction before a loop end label.
     Otherwise it will be turned into an rs_fill of 0 before
     relaxation begins.  This is used to avoid a hardware TIE
     interlock issue prior to T1040.  */

  RELAX_ADD_NOP_IF_SHORT_LOOP,
  /* These are placed after LOOP instructions.  It will be turned into
     a NOP when: (1) there are less than 3 instructions in the loop;
     we place 2 of these in a row to add up to 2 NOPS in short loops;
     or (2) The instructions in the loop do not include a branch or
     jump.  Otherwise it will be turned into an rs_fill of 0 before
     relaxation begins.  This is used to avoid hardware bug
     PR3830.  */

  RELAX_ADD_NOP_IF_CLOSE_LOOP_END,
  /* These are placed after LOOP instructions.  It will be turned into
     a NOP if there are less than 12 bytes to the end of some other
     loop's end.  Otherwise it will be turned into an rs_fill of 0
     before relaxation begins.  This is used to avoid hardware bug
     PR3830.  */

  RELAX_DESIRE_ALIGN,
  /* The next fragment like its first instruction to NOT cross a
     4-byte boundary.  */

  RELAX_LOOP_END,
  /* This will be turned into a NOP or NOP.N if the previous
     instruction is expanded to negate a loop.  */

  RELAX_LOOP_END_ADD_NOP,
  /* When the code density option is available, this will generate a
     NOP.N marked RELAX_NARROW.  Otherwise, it will create an rs_fill
     fragment with a NOP in it.  */

  RELAX_LITERAL,
  /* Another fragment could generate an expansion here but has not yet.  */

  RELAX_LITERAL_NR,
  /* Expansion has been generated by an instruction that generates a
     literal.  However, the stretch has NOT been reported yet in this
     fragment.  */

  RELAX_LITERAL_FINAL,
  /* Expansion has been generated by an instruction that generates a
     literal.  */

  RELAX_LITERAL_POOL_BEGIN,
  RELAX_LITERAL_POOL_END,
  /* Technically these are not relaxations at all, but mark a location
     to store literals later.  Note that fr_var stores the frchain for
     BEGIN frags and fr_var stores now_seg for END frags.  */

  RELAX_NARROW,
  /* The last instruction in this fragment (at->fr_opcode) can be
     freely replaced with a single wider instruction if a future
     alignment desires or needs it.  */

  RELAX_IMMED,
  /* The last instruction in this fragment (at->fr_opcode) contains
     the value defined by fr_symbol (fr_offset = 0).  If the value
     does not fit, use the specified expansion.  This is similar to
     "NARROW", except that these may not be expanded in order to align
     code.  */
  
  RELAX_IMMED_STEP1,
  /* The last instruction in this fragment (at->fr_opcode) contains a
     literal.  It has already been expanded at least 1 step.  */

  RELAX_IMMED_STEP2
  /* The last instruction in this fragment (at->fr_opcode) contains a
     literal.  It has already been expanded at least 2 steps.  */
a443 5
/* This is used as a stopper to bound the number of steps that
   can be taken.  */
#define RELAX_IMMED_MAXSTEPS (RELAX_IMMED_STEP2 - RELAX_IMMED)


d445 1
d447 2
d452 1
a452 1
static bfd_boolean use_generics
d456 1
a456 3
static bfd_boolean code_density_available
  PARAMS ((void));
static bfd_boolean can_relax
d473 4
d483 6
d497 1
a497 1
  PARAMS ((xtensa_operand, expressionS *));
d502 2
d508 4
a522 4
static bfd_boolean operand_is_immed
  PARAMS ((xtensa_operand));
static bfd_boolean operand_is_pcrel_label
  PARAMS ((xtensa_operand));
d526 7
a532 1
  PARAMS ((const char *));
a534 2
static bfd_boolean is_call_opcode
  PARAMS ((xtensa_opcode));
d537 1
a537 1
static bfd_boolean is_loop_opcode
d545 5
a549 5
static bfd_boolean is_conditional_branch_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_branch_or_jump_opcode
  PARAMS ((xtensa_opcode));
static bfd_reloc_code_real_type opnum_to_reloc
a550 2
static int reloc_to_opnum
  PARAMS ((bfd_reloc_code_real_type));
d552 1
a552 1
  PARAMS ((xtensa_insnbuf, xtensa_opcode, xtensa_operand, int32,
d555 1
a555 6
  PARAMS ((xtensa_insnbuf, xtensa_opcode, int));
static void xtensa_insnbuf_set_immediate_field
  PARAMS ((xtensa_opcode, xtensa_insnbuf, int32, const char *,
	   unsigned int));
static bfd_boolean is_negatable_branch
  PARAMS ((TInsn *));
a560 2
static int xg_get_insn_size
  PARAMS ((TInsn *));
a566 2
static int xg_get_max_narrow_insn_size
  PARAMS ((xtensa_opcode));
d590 1
a590 3
  PARAMS ((int32, xtensa_operand));
static int is_dnrange
  PARAMS ((fragS *, symbolS *, long));
d596 2
a597 1
  PARAMS ((char *, enum xtensa_relax_statesE, int, bfd_boolean));
d602 6
d612 2
d622 2
d625 1
a625 1
  PARAMS ((int));
a635 2
static bfd_boolean xg_emit_insn
  PARAMS ((TInsn *, bfd_boolean));
d637 1
a637 1
  PARAMS ((TInsn *, char *, fragS *, offsetT, bfd_boolean));
d639 1
a639 1
  PARAMS ((xtensa_opcode, int, expressionS *, fragS *, offsetT));
a643 2
static void xg_assemble_tokens
  PARAMS ((TInsn *));
d652 5
a656 1
static xtensa_opcode next_frag_opcode
d658 2
a659 2
static void update_next_frag_nop_state
  PARAMS ((fragS *));
d674 2
d682 30
d721 6
d741 2
d774 2
a775 2
static addressT get_widen_aligned_address
  PARAMS ((fragS *, addressT));
d779 1
a779 1
static long relax_frag_text_align
d783 1
a783 1
static long relax_frag_narrow
d785 1
a785 1
static bfd_boolean future_alignment_required
d787 4
d792 1
a792 1
  PARAMS ((segT, fragS *, long, int, int *));
d799 2
d803 1
a803 1
  PARAMS ((segT, fragS *, int));
d827 2
d841 2
d848 1
a848 1
  PARAMS ((seg_list *, const char *, segT *));
d850 1
a850 1
  PARAMS ((seg_list *, const char *));
d856 1
a856 1
/* Property Table (e.g., ".xt.insn" and ".xt.lit") Functions.  */
d858 10
d869 3
a871 1
  PARAMS ((frag_predicate, const char *, xt_section_type));
d877 3
a879 1
  PARAMS ((segT sec, frag_predicate));
d881 17
a897 5
  PARAMS ((segT, segT, xtensa_block_info **, frag_predicate));
static bfd_boolean get_frag_is_literal
  PARAMS ((const fragS *));
static bfd_boolean get_frag_is_insn
  PARAMS ((const fragS *));
d900 1
d904 11
d916 1
d925 2
d930 3
a932 1
  PARAMS ((TInsn *, char *));
d934 1
a934 1
  PARAMS ((TInsn *, fragS *));
d940 15
d956 1
d963 4
d969 2
d999 1
d1001 2
a1003 1
static xtensa_opcode xtensa_j_opcode;
d1005 1
d1009 1
d1016 1
a1016 1
static xtensa_opcode xtensa_rsr_opcode;
d1024 1
a1024 2
static bfd_boolean align_only_targets = FALSE;
static bfd_boolean software_a0_b_retw_interlock = TRUE;
d1026 3
a1028 8
static bfd_boolean workaround_a0_b_retw = TRUE;

static bfd_boolean software_avoid_b_j_loop_end = TRUE;
static bfd_boolean workaround_b_j_loop_end = TRUE;
static bfd_boolean maybe_has_b_j_loop_end = FALSE;

static bfd_boolean software_avoid_short_loop = TRUE;
static bfd_boolean workaround_short_loop = TRUE;
d1030 1
a1030 3

static bfd_boolean software_avoid_close_loop_end = TRUE;
static bfd_boolean workaround_close_loop_end = TRUE;
d1033 5
a1037 5
/* When avoid_short_loops is true, all loops with early exits must
   have at least 3 instructions.  avoid_all_short_loops is a modifier
   to the avoid_short_loop flag.  In addition to the avoid_short_loop
   actions, all straightline loopgtz and loopnez must have at least 3
   instructions.  */
d1039 1
a1039 5
static bfd_boolean software_avoid_all_short_loops = TRUE;
static bfd_boolean workaround_all_short_loops = TRUE;

/* This is on a per-instruction basis.  */
static bfd_boolean specific_opcode = FALSE;
d1049 3
d1055 3
d1061 3
d1067 1
a1067 2
  option_align_only_targets,
  option_no_align_only_targets,
a1089 4
  option_literal_section_name,
  option_text_section_name,
  option_data_section_name,
  option_bss_section_name,
d1093 4
a1096 2
  option_eb,
  option_el
d1103 17
a1119 13
  {"density", no_argument, NULL, option_density},
  {"no-density", no_argument, NULL, option_no_density},
  /* At least as early as alameda, --[no-]relax didn't work as
     documented, so as of albany, --[no-]relax is equivalent to
     --[no-]generics.  Both of these will be deprecated in
     BearValley.  */
  {"relax", no_argument, NULL, option_generics},
  {"no-relax", no_argument, NULL, option_no_generics},
  {"generics", no_argument, NULL, option_generics},
  {"no-generics", no_argument, NULL, option_no_generics},
  {"text-section-literals", no_argument, NULL, option_text_section_literals},
  {"no-text-section-literals", no_argument, NULL,
   option_no_text_section_literals},
d1122 34
a1155 37
  {"target-align", no_argument, NULL, option_align_targets},
  {"no-target-align", no_argument, NULL,
   option_no_align_targets},
#if 0
  /* This option  should do a better job aligning targets because
     it will only attempt to align targets that are the target of a 
     branch.  */
   { "target-align-only", no_argument, NULL, option_align_only_targets },
   { "no-target-align-only", no_argument, NULL, option_no_align_only_targets },
#endif /* 0 */
  {"longcalls", no_argument, NULL, option_longcalls},
  {"no-longcalls", no_argument, NULL, option_no_longcalls},

  {"no-workaround-a0-b-retw", no_argument, NULL,
   option_no_workaround_a0_b_retw},
  {"workaround-a0-b-retw", no_argument, NULL, option_workaround_a0_b_retw},
  
  {"no-workaround-b-j-loop-end", no_argument, NULL,
   option_no_workaround_b_j_loop_end},
  {"workaround-b-j-loop-end", no_argument, NULL,
   option_workaround_b_j_loop_end},
  
  {"no-workaround-short-loops", no_argument, NULL,
   option_no_workaround_short_loop},
  {"workaround-short-loops", no_argument, NULL, option_workaround_short_loop},

  {"no-workaround-all-short-loops", no_argument, NULL,
   option_no_workaround_all_short_loops},
  {"workaround-all-short-loop", no_argument, NULL,
   option_workaround_all_short_loops},

  {"no-workaround-close-loop-end", no_argument, NULL,
   option_no_workaround_close_loop_end},
  {"workaround-close-loop-end", no_argument, NULL,
   option_workaround_close_loop_end},

  {"no-workarounds", no_argument, NULL, option_no_workarounds},
d1158 2
a1159 10
  {"literal-section-name", required_argument, NULL,
   option_literal_section_name},
  {"text-section-name", required_argument, NULL,
   option_text_section_name},
  {"data-section-name", required_argument, NULL,
   option_data_section_name},
  {"rename-section", required_argument, NULL,
   option_rename_section_name},
  {"bss-section-name", required_argument, NULL,
   option_bss_section_name},
d1162 6
a1167 1
  {NULL, no_argument, NULL, 0}
d1181 1
a1181 7
      if (!density_supported)
	{
	  as_bad (_("'--density' option not supported in this Xtensa "
		  "configuration"));
	  return 0;
	}
      directive_state[directive_density] = TRUE;
d1184 7
a1190 1
      directive_state[directive_density] = FALSE;
d1193 2
a1194 2
      directive_state[directive_generics] = TRUE;
      return 1;
d1196 8
a1203 2
      directive_state[directive_generics] = FALSE;
      return 1;
d1216 12
a1229 1
      software_a0_b_retw_interlock = TRUE;
a1232 1
      software_a0_b_retw_interlock = FALSE;
a1235 1
      software_avoid_b_j_loop_end = TRUE;
a1238 1
      software_avoid_b_j_loop_end = FALSE;
a1242 1
      software_avoid_short_loop = TRUE;
a1245 1
      software_avoid_short_loop = FALSE;
a1249 1
      software_avoid_all_short_loops = TRUE;
a1252 1
      software_avoid_all_short_loops = FALSE;
a1256 1
      software_avoid_close_loop_end = TRUE;
a1259 1
      software_avoid_close_loop_end = FALSE;
a1263 1
      software_a0_b_retw_interlock = FALSE;
a1264 1
      software_avoid_b_j_loop_end = FALSE;
a1265 1
      software_avoid_short_loop = FALSE;
a1266 1
      software_avoid_all_short_loops = FALSE;
a1267 1
      software_avoid_close_loop_end = FALSE;
d1269 1
a1269 1
      
d1277 2
a1278 5
    case option_align_only_targets:
      align_only_targets = TRUE;
      return 1;
    case option_no_align_only_targets:
      align_only_targets = FALSE;
d1282 2
a1283 4
    case option_literal_section_name:
      add_section_rename (".literal", arg);
      as_warn (_("'--literal-section-name' is deprecated; "
		 "use '--rename-section .literal=NEWNAME'"));
d1285 1
d1287 9
a1295 4
    case option_text_section_name:
      add_section_rename (".text", arg);
      as_warn (_("'--text-section-name' is deprecated; "
		 "use '--rename-section .text=NEWNAME'"));
d1298 4
a1301 4
    case option_data_section_name:
      add_section_rename (".data", arg);
      as_warn (_("'--data-section-name' is deprecated; "
		 "use '--rename-section .data=NEWNAME'"));
d1304 26
a1329 4
    case option_bss_section_name:
      add_section_rename (".bss", arg);
      as_warn (_("'--bss-section-name' is deprecated; "
		 "use '--rename-section .bss=NEWNAME'"));
d1332 8
a1339 2
    case option_rename_section_name:
      build_section_rename (arg);
a1340 1
#endif /* XTENSA_SECTION_RENAME */
a1341 5
    case 'Q':
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
         should be emitted or not.  FIXME: Not implemented.  */
      return 1;
      
d1352 9
a1360 9
  fputs ("\nXtensa options:\n"
	 "--[no-]density          [Do not] emit density instructions\n"
	 "--[no-]relax            [Do not] perform branch relaxation\n"
	 "--[no-]generics         [Do not] transform instructions\n"
	 "--[no-]longcalls        [Do not] emit 32-bit call sequences\n"
	 "--[no-]target-align     [Do not] try to align branch targets\n"
	 "--[no-]text-section-literals\n"
	 "                        [Do not] put literals in the text section\n"
	 "--no-workarounds        Do not use any Xtensa workarounds\n"
d1362 3
a1364 8
	 "--rename-section old=new(:old1=new1)*\n"
	 "                        Rename section 'old' to 'new'\n"
	 "\nThe following Xtensa options are deprecated\n"
	 "--literal-section-name  Name of literal section (default .literal)\n"
	 "--text-section-name     Name of text section (default .text)\n"
	 "--data-section-name     Name of data section (default .data)\n"
	 "--bss-section-name      Name of bss section (default .bss)\n"
#endif
d1368 20
d1406 12
a1417 8
  {"align", s_align_bytes, 0},	/* Defaulting is invalid (0) */
  {"literal_position", xtensa_literal_position, 0},
  {"frame", s_ignore, 0},	/* formerly used for STABS debugging */
  {"word", cons, 4},
  {"begin", xtensa_begin_directive, 0},
  {"end", xtensa_end_directive, 0},
  {"literal", xtensa_literal_pseudo, 0},
  {NULL, 0, 0},
d1422 1
a1422 1
use_generics ()
d1424 4
a1427 1
  return directive_state[directive_generics];
d1434 4
a1437 8
  return directive_state[directive_longcalls];
}


bfd_boolean
code_density_available ()
{
  return directive_state[directive_density];
d1442 1
a1442 1
can_relax ()
d1444 4
a1447 1
  return use_generics ();
d1541 1
d1552 18
a1569 1
		"abcdefghijklmnopqrstuvwxyz_/0123456789.");
d1573 1
a1573 1
      if (strncmp (input_line_pointer, directive_info[i].name, len) == 0)
d1578 1
a1578 1
	    as_bad (_("directive %s can't be negated"),
a1598 2
  md_flush_pending_output ();

d1606 3
d1619 1
d1626 3
d1631 1
a1631 1
      if (frag_now->tc_frag_data.is_literal)
d1667 8
d1676 6
a1681 1
      if (!density_supported && !negated)
d1683 1
a1683 1
	  as_warn (_("Xtensa density option not supported; ignored"));
d1686 3
a1688 1
      /* fall through */
d1691 2
d1710 1
d1713 5
d1720 1
a1720 2
  get_directive (&end_directive, &end_negated);
  if (end_directive == (directiveE) XTENSA_UNDEFINED)
d1722 1
a1724 1
    }
d1726 2
a1727 3
  if (end_directive == directive_density && !density_supported && !end_negated)
    {
      as_warn (_("Xtensa density option not supported; ignored"));
d1729 13
a1741 1
      return;
d1744 1
d1746 1
a1746 1
		 (const void **) &state);
d1763 1
a1772 3
	    case directive_freeregs:
	      break;

d1785 4
d1790 1
d1800 25
d1831 2
d1835 1
a1835 2
  else if (!use_literal_section)
    xtensa_mark_literal_pool_location ();
d1842 1
a1842 1
/* Support .literal label, value@@plt + offset.  */
a1850 1
  expressionS expP;
d1860 2
d1874 1
a1874 1
  /* ...but if we aren't using text-section-literals, then we 
d1876 1
a1876 1
  if (use_literal_section)
d1879 3
a1881 3
  /* All literals are aligned to four-byte boundaries
     which is handled by switch to literal fragment.  */
  /* frag_align (2, 0, 0);  */
a1900 11
  do 
    {
      input_line_pointer++;		/* skip ',' or ':' */
      
      expr (0, &expP);

      /* We only support 4-byte literals with .literal.  */
      emit_expr (&expP, 4);
    }
  while (*input_line_pointer == ',');

d1902 1
d1904 1
a1904 1
  demand_empty_rest_of_line ();
d1919 3
a1921 11
  segT s_now;			/* Storage for the current seg and subseg.  */
  subsegT ss_now;
  char *name;			/* Pointer to the name itself.  */
  char *newname;

  if (!use_literal_section)
    return;

  /* Store away the current section and subsection.  */
  s_now = now_seg;
  ss_now = now_subseg;
d1932 1
d1934 20
a1953 2
  strcpy (newname, name);
  strcpy (newname + len, ".literal");
d1955 8
a1962 1
  /* Note that retrieve_literal_seg does not create a segment if 
d1964 2
a1965 1
  default_lit_sections.lit_seg = NULL;	/* retrieved on demand */
d1969 2
a1970 2
  default_lit_sections.lit_seg_name =
    tc_canonicalize_symbol_name (newname);
d1973 1
a1974 4
  /* Restore the current section and subsection and set the 
     generation into the old segment.  */
  subseg_set (s_now, ss_now);
}
d1976 1
a1976 2

/* Parsing and Idiom Translation.  */
d1978 173
a2150 3
static const char *
expression_end (name)
     const char *name;
d2156 1
d2160 1
a2230 3
#define PLT_SUFFIX "@@PLT"
#define plt_suffix "@@plt"

d2232 3
a2234 2
expression_maybe_register (opnd, tok)
     xtensa_operand opnd;
d2237 1
a2237 1
  char *kind = xtensa_operand_kind (opnd);
d2239 2
a2240 2
  if ((strlen (kind) == 1)
      && (*kind == 'l' || *kind == 'L' || *kind == 'i' || *kind == 'r'))
d2242 1
d2244 2
a2245 1
      if (t == absolute_section && operand_is_pcrel_label (opnd))
d2251 4
a2254 5
      if (tok->X_op == O_symbol 
	  && (!strncmp (input_line_pointer, PLT_SUFFIX,
			strlen (PLT_SUFFIX) - 1)
	      || !strncmp (input_line_pointer, plt_suffix,
			   strlen (plt_suffix) - 1)))
d2256 25
a2280 2
	  symbol_get_tc (tok->X_add_symbol)->plt = 1;
	  input_line_pointer += strlen (plt_suffix);
d2285 2
a2286 1
      unsigned reg = tc_get_register (kind);
d2291 1
a2291 2
	  if ((xtensa_operand_encode (opnd, &buf) != xtensa_encode_result_ok)
	      || (reg != xtensa_operand_decode (opnd, buf)))
d2312 1
d2316 2
a2317 2
  
  /* Save and restore input_line_pointer around this function.  */ 
d2327 1
d2330 7
d2339 1
a2339 1
	  if (saw_comma || !saw_arg)
d2345 1
a2345 1
	  if (!saw_comma && saw_arg)
d2351 1
a2351 1
 
d2353 1
a2353 1
	  arg = (char *) xmalloc (arg_len + 1);
d2356 2
d2360 1
a2360 1
 
d2364 1
d2371 1
a2371 1
  if (saw_comma)
d2377 8
d2390 1
a2390 1
/* Parse the arguments to an opcode.  Return true on error.  */
d2398 1
a2398 1
  expressionS *tok = insn->tok;
d2401 2
a2402 2
  xtensa_isa isa = xtensa_default_isa; 
  int n;
d2404 2
a2405 2
  int actual_operand_count = 0;
  xtensa_operand opnd = NULL; 
d2411 1
a2411 1
    opcode_operand_count = xtensa_num_operands (isa, opcode);
d2413 1
d2417 12
a2428 1
  old_input_line_pointer = input_line_pointer; 
d2431 1
a2431 1
    { 
d2433 47
d2481 2
a2482 15
      if (actual_operand_count >= opcode_operand_count)
	{ 
	  as_warn (_("too many arguments")); 
	  goto err;
	} 
      assert (actual_operand_count < MAX_INSN_ARGS);

      opnd = xtensa_get_operand (isa, opcode, actual_operand_count); 
      expression_maybe_register (opnd, tok);

      if (tok->X_op == O_illegal || tok->X_op == O_absent) 
	goto err; 
      actual_operand_count++;
      tok++; 
    } 
d2488 1
a2488 1
  input_line_pointer = old_input_line_pointer; 
d2493 69
d2617 1
a2617 1
     int expected_num; 
d2623 1
a2623 1
  if (num_args < expected_num) 
d2647 3
d2656 2
d2659 2
a2660 1
  offsetT val;
d2669 2
d2672 1
a2672 1
  /* Opname == [rw]ur... */
d2674 11
a2684 1
  if (opname[3] == '\0')
d2686 2
a2687 6
      /* If the register is not specified as part of the opcode,
	 then get it from the operand and move it to the opcode.  */

      if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
	return -1;

d2690 9
a2698 1
	  as_bad (_("register number for `%s' is not a constant"), opname);
d2701 65
a2765 1
      if ((unsigned) val > 255)
d2767 1
a2767 1
	  as_bad (_("register number (%ld) for `%s' is out of range"),
d2771 30
d2802 5
a2806 1
      /* Remove the last argument, which is now part of the opcode.  */
d2808 3
a2810 9
      arg_strings[1] = 0;
      *pnum_args = 1;

      /* Translate the opcode.  */
      new_opname = (char *) xmalloc (8);
      sprintf (new_opname, "%s%cur%u", (has_underbar ? "_" : ""),
	       opname[0], (unsigned) val);
      free (*popname);
      *popname = new_opname;
d2829 3
d2840 1
a2840 1
      if (!has_underbar && code_density_available ())
d2874 2
a2875 1
  if (strcmp (opname, "nop") == 0)
d2877 1
a2877 1
      if (!has_underbar && code_density_available ())
d2895 6
a2900 3
  if ((opname[0] == 'r' || opname[0] == 'w')
      && opname[1] == 'u'
      && opname[2] == 'r')
d2903 5
d2909 3
a2911 29
  /* WIDENING DENSITY OPCODES

     questionable relaxations (widening) from old "tai" idioms:

       ADD.N --> ADD
       BEQZ.N --> BEQZ
       RET.N --> RET
       RETW.N --> RETW
       MOVI.N --> MOVI
       MOV.N --> MOV
       NOP.N --> NOP

     Note: this incomplete list was imported to match the "tai"
     behavior; other density opcodes are not handled.

     The xtensa-relax code may know how to do these but it doesn't do
     anything when these density opcodes appear inside a no-density
     region.  Somehow GAS should either print an error when that happens
     or do the widening.  The old "tai" behavior was to do the widening.
     For now, I'll make it widen but print a warning.

     FIXME: GAS needs to detect density opcodes inside no-density
     regions and treat them as errors.  This code should be removed
     when that is done.  */

  if (use_generics ()
      && !has_underbar
      && density_supported
      && !code_density_available ())
d2913 3
a2915 2
      if (strcmp (opname, "add.n") == 0)
	xg_replace_opname (popname, "add");
d2917 3
a2919 2
      else if (strcmp (opname, "beqz.n") == 0)
	xg_replace_opname (popname, "beqz");
d2921 3
a2923 2
      else if (strcmp (opname, "ret.n") == 0)
	xg_replace_opname (popname, "ret");
d2925 3
a2927 29
      else if (strcmp (opname, "retw.n") == 0)
	xg_replace_opname (popname, "retw");

      else if (strcmp (opname, "movi.n") == 0)
	xg_replace_opname (popname, "movi");

      else if (strcmp (opname, "mov.n") == 0)
	{
	  if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
	    return -1;
	  xg_replace_opname (popname, "or");
	  arg_strings[2] = (char *) xmalloc (strlen (arg_strings[1]) + 1);
	  strcpy (arg_strings[2], arg_strings[1]);
	  *pnum_args = 3;
	}

      else if (strcmp (opname, "nop.n") == 0)
	{
	  if (xg_check_num_args (pnum_args, 0, opname, arg_strings))
	    return -1;
	  xg_replace_opname (popname, "or");
	  arg_strings[0] = (char *) xmalloc (3);
	  arg_strings[1] = (char *) xmalloc (3);
	  arg_strings[2] = (char *) xmalloc (3);
	  strcpy (arg_strings[0], "a1");
	  strcpy (arg_strings[1], "a1");
	  strcpy (arg_strings[2], "a1");
	  *pnum_args = 3;
	}
d2936 6
a2941 49
/* Return true if the given operand is an immed or target instruction,
   i.e., has a reloc associated with it.  Currently, this is only true
   if the operand kind is "i, "l" or "L".  */

static bfd_boolean
operand_is_immed (opnd)
     xtensa_operand opnd;
{
  const char *opkind = xtensa_operand_kind (opnd);
  if (opkind[0] == '\0' || opkind[1] != '\0')
    return FALSE;
  switch (opkind[0])
    {
    case 'i':
    case 'l':
    case 'L':
      return TRUE;
    }
  return FALSE;
}


/* Return true if the given operand is a pc-relative label.  This is
   true for "l", "L", and "r" operand kinds.  */

bfd_boolean
operand_is_pcrel_label (opnd)
     xtensa_operand opnd;
{
  const char *opkind = xtensa_operand_kind (opnd);
  if (opkind[0] == '\0' || opkind[1] != '\0')
    return FALSE;
  switch (opkind[0])
    {
    case 'r':
    case 'l':
    case 'L':
      return TRUE;
    }
  return FALSE;
}


/* Currently the assembler only allows us to use a single target per
   fragment.  Because of this, only one operand for a given
   instruction may be symbolic.  If there is an operand of kind "lrL",
   the last one is chosen.  Otherwise, the result is the number of the
   last operand of type "i", and if there are none of those, we fail
   and return -1.  */
a2948 1
  xtensa_operand operand;
d2953 1
a2953 1
  noperands = xtensa_num_operands (xtensa_default_isa, opcode);
d2956 3
a2958 2
      operand = xtensa_get_operand (xtensa_default_isa, opcode, opi);
      if (operand_is_pcrel_label (operand))
d2960 2
a2961 1
      if (last_immed == -1 && operand_is_immed (operand))
d2968 2
a2969 2
xtensa_opcode
get_opcode_from_buf (buf)
d2971 1
d2974 31
a3006 2
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);
d3008 23
a3030 3
  xtensa_insnbuf_from_chars (isa, insnbuf, buf);
  opcode = xtensa_decode_insn (isa, insnbuf);
  return opcode;
d3034 3
a3036 3
static bfd_boolean
is_direct_call_opcode (opcode)
     xtensa_opcode opcode;
d3038 12
a3049 2
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
d3051 20
a3070 4
  return (opcode == xtensa_call0_opcode
	  || opcode == xtensa_call4_opcode
	  || opcode == xtensa_call8_opcode
	  || opcode == xtensa_call12_opcode);
d3073 2
d3077 1
a3077 1
is_call_opcode (opcode)
d3080 2
a3081 2
  if (is_direct_call_opcode (opcode))
    return TRUE;
d3083 1
a3083 1
  if (opcode == XTENSA_UNDEFINED)
d3086 8
a3093 4
  return (opcode == xtensa_callx0_opcode
	  || opcode == xtensa_callx4_opcode
	  || opcode == xtensa_callx8_opcode
	  || opcode == xtensa_callx12_opcode);
d3097 1
a3097 1
/* Return true if the opcode is an entry opcode.  This is used because
d3112 2
a3113 3
/* Return true if it is one of the loop opcodes.  Loops are special
   because they need automatic alignment and they have a relaxation so
   complex that we hard-coded it.  */
d3116 1
a3116 1
is_loop_opcode (opcode)
d3122 2
a3123 3
  return (opcode == xtensa_loop_opcode
	  || opcode == xtensa_loopnez_opcode
	  || opcode == xtensa_loopgtz_opcode);
d3149 1
a3149 1
/* Return true if the opcode is a retw or retw.n.
d3163 2
a3164 1
/* Return true if the opcode type is "l" and the opcode is NOT a jump.  */
d3166 5
a3170 3
static bfd_boolean
is_conditional_branch_opcode (opcode)
     xtensa_opcode opcode;
d3172 8
a3179 8
  xtensa_isa isa = xtensa_default_isa;
  int num_ops, i;

  if (opcode == xtensa_j_opcode && opcode != XTENSA_UNDEFINED)
    return FALSE;

  num_ops = xtensa_num_operands (isa, opcode);
  for (i = 0; i < num_ops; i++)
d3181 2
a3182 3
      xtensa_operand operand = xtensa_get_operand (isa, opcode, i);
      if (strcmp (xtensa_operand_kind (operand), "l") == 0)
	return TRUE;
d3184 4
a3187 1
  return FALSE;
d3191 3
a3193 3
/* Return true if the given opcode is a conditional branch
   instruction, i.e., currently this is true if the instruction 
   is a jx or has an operand with 'l' type and is not a loop.  */
d3195 3
a3197 3
bfd_boolean
is_branch_or_jump_opcode (opcode)
     xtensa_opcode opcode;
d3199 2
a3200 1
  int opn, op_count;
d3202 1
a3202 19
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  if (is_loop_opcode (opcode))
    return FALSE;

  if (is_jx_opcode (opcode))
    return TRUE;

  op_count = xtensa_num_operands (xtensa_default_isa, opcode);
  for (opn = 0; opn < op_count; opn++)
    {
      xtensa_operand opnd =
	xtensa_get_operand (xtensa_default_isa, opcode, opn);
      const char *opkind = xtensa_operand_kind (opnd);
      if (opkind && opkind[0] == 'l' && opkind[1] == '\0')
	return TRUE;
    }
  return FALSE;
d3206 2
a3207 2
/* Convert from operand numbers to BFD relocation type code.
   Return BFD_RELOC_NONE on failure.  */
d3209 3
a3211 3
bfd_reloc_code_real_type
opnum_to_reloc (opnum)
     int opnum;
d3213 2
a3214 14
  switch (opnum)
    {
    case 0:
      return BFD_RELOC_XTENSA_OP0;
    case 1:
      return BFD_RELOC_XTENSA_OP1;
    case 2:
      return BFD_RELOC_XTENSA_OP2;
    default:
      break;
    }
  return BFD_RELOC_NONE;
}

d3216 1
a3216 19
/* Convert from BFD relocation type code to operand number.
   Return -1 on failure.  */

int
reloc_to_opnum (reloc)
     bfd_reloc_code_real_type reloc;
{
  switch (reloc)
    {
    case BFD_RELOC_XTENSA_OP0:
      return 0;
    case BFD_RELOC_XTENSA_OP1:
      return 1;
    case BFD_RELOC_XTENSA_OP2:
      return 2;
    default:
      break;
    }
  return -1;
d3221 5
a3225 2
xtensa_insnbuf_set_operand (insnbuf, opcode, operand, value, file, line)
     xtensa_insnbuf insnbuf;
d3227 2
a3228 2
     xtensa_operand operand;
     int32 value;
a3231 1
  xtensa_encode_result encode_result;
d3234 1
a3234 3
  encode_result = xtensa_operand_encode (operand, &valbuf);

  switch (encode_result)
d3236 10
a3245 29
    case xtensa_encode_result_ok:
      break;
    case xtensa_encode_result_align:
      as_bad_where ((char *) file, line,
		    _("operand %d not properly aligned for '%s'"),
		    value, xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    case xtensa_encode_result_not_in_table:
      as_bad_where ((char *) file, line,
		    _("operand %d not in immediate table for '%s'"),
		    value, xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    case xtensa_encode_result_too_high:
      as_bad_where ((char *) file, line,
		    _("operand %d too large for '%s'"), value,
		    xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    case xtensa_encode_result_too_low:
      as_bad_where ((char *) file, line,
		    _("operand %d too small for '%s'"), value,
		    xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    case xtensa_encode_result_not_ok:
      as_bad_where ((char *) file, line,
		    _("operand %d is invalid for '%s'"), value,
		    xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    default:
      abort ();
d3248 2
a3249 1
  xtensa_operand_set_field (operand, insnbuf, valbuf);
d3254 4
a3257 2
xtensa_insnbuf_get_operand (insnbuf, opcode, opnum)
     xtensa_insnbuf insnbuf;
d3261 5
a3265 36
  xtensa_operand op = xtensa_get_operand (xtensa_default_isa, opcode, opnum);
  return xtensa_operand_decode (op, xtensa_operand_get_field (op, insnbuf));
}


static void
xtensa_insnbuf_set_immediate_field (opcode, insnbuf, value, file, line)
     xtensa_opcode opcode;
     xtensa_insnbuf insnbuf;
     int32 value;
     const char *file;
     unsigned int line;
{
  xtensa_isa isa = xtensa_default_isa;
  int last_opnd = xtensa_num_operands (isa, opcode) - 1;
  xtensa_operand operand = xtensa_get_operand (isa, opcode, last_opnd);
  xtensa_insnbuf_set_operand (insnbuf, opcode, operand, value, file, line);
}


static bfd_boolean
is_negatable_branch (insn)
     TInsn *insn;
{
  xtensa_isa isa = xtensa_default_isa;
  int i;
  int num_ops = xtensa_num_operands (isa, insn->opcode);

  for (i = 0; i < num_ops; i++)
    {
      xtensa_operand opnd = xtensa_get_operand (isa, insn->opcode, i);
      char *kind = xtensa_operand_kind (opnd);
      if (strlen (kind) == 1 && *kind == 'l')
	return TRUE;
    }
  return FALSE;
a3283 9
xg_get_insn_size (insn)
     TInsn *insn;
{
  assert (insn->insn_type == ITYPE_INSN);
  return xtensa_insn_length (xtensa_default_isa, insn->opcode);
}


static int
d3288 1
a3288 1
  return xtensa_insn_length (xtensa_default_isa, insn->opcode);
d3296 1
a3296 1
  TransitionTable *table = xg_build_widen_table ();
d3312 1
a3312 1
	  if (xg_get_insn_size (insn)
d3329 1
a3329 1
  TransitionTable *table = xg_build_widen_table ();
d3342 1
d3345 1
a3345 1
	  if (xg_get_insn_size (insn)
a3357 35
/* Return the largest size instruction that this instruction can
   expand to.  Currently, in all cases, this is 3 bytes.  Of course we
   could just calculate this once and generate a table.  */

int
xg_get_max_narrow_insn_size (opcode)
     xtensa_opcode opcode;
{
  /* Go ahead and compute it, but it better be 3.  */
  TransitionTable *table = xg_build_widen_table ();
  TransitionList *l;
  int old_size = xtensa_insn_length (xtensa_default_isa, opcode);
  assert (opcode < table->num_opcodes);

  /* Actually we can do better. Check to see of Only one applies.  */
  for (l = table->table[opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      /* If it only generates one instruction.  */
      if (is_unique_insn_expansion (rule))
	{
	  int new_size = xtensa_insn_length (xtensa_default_isa,
					     rule->to_instr->opcode);
	  if (new_size > old_size)
	    {
	      assert (new_size == 3);
	      return 3;
	    }
	}
    }
  return old_size;
}


d3364 1
a3364 1
  TransitionTable *table = xg_build_widen_table ();
d3366 1
a3366 1
  int max_size = xtensa_insn_length (xtensa_default_isa, opcode);
d3390 1
a3390 3
		this_size += xtensa_insn_length (xtensa_default_isa,
						 build_list->opcode);

d3411 1
a3411 1
  TransitionTable *table = xg_build_widen_table ();
d3437 1
a3437 1
		/* hard coded 4-byte literal.  */
d3459 1
a3459 1
  TransitionTable *table = xg_build_widen_table ();
d3502 1
a3502 1
/* Return true on success.  */
d3514 1
d3550 32
d3627 3
d3647 1
a3647 1
      /* Literal with no ops. is a label?  */
d3659 1
a3659 1
/* Return true on success.  */
d3678 1
a3678 1
/* Return true on valid expansion.  */
d3688 1
a3688 1
  TransitionTable *table = xg_build_widen_table ();
d3735 1
a3735 1
  TransitionTable *table = xg_build_widen_table ();
d3748 1
a3748 1
	  if (xg_get_insn_size (insn)
d3761 1
a3761 1
   into their immeds; return false if not.  */
d3767 1
d3775 1
a3775 3
      xtensa_operand opnd = xtensa_get_operand (xtensa_default_isa,
						insn->opcode, i);
      if (!operand_is_immed (opnd))
d3782 2
a3783 4
	  {
	    if (xg_check_operand (expr->X_add_number, opnd))
	      return FALSE;
	  }
d3785 1
d3807 1
d3809 3
a3811 1
  offsetT target, pc, new_offset;
d3820 1
a3820 3
      xtensa_operand opnd = xtensa_get_operand (xtensa_default_isa,
						insn->opcode, i);
      if (!operand_is_immed (opnd))
d3827 8
a3834 1
	  if (xg_check_operand (expr->X_add_number, opnd))
d3844 3
a3846 3
	  /* If it is PC-relative and the symbol is in the same segment as
	     the PC.... */
	  if (!xtensa_operand_isPCRelative (opnd)
d3850 7
d3858 1
d3868 10
a3877 5
	  if (stretch && is_dnrange (pc_frag, symbolP, stretch))
	    target += stretch;

	  new_offset = xtensa_operand_do_reloc (opnd, target, pc);
	  if (xg_check_operand (new_offset, opnd))
d3892 1
a3892 1
   operand type.  It will return true if it does not fit.  */
d3895 1
a3895 1
xg_check_operand (value, operand)
d3897 2
a3898 1
     xtensa_operand operand;
d3901 3
a3903 1
  return (xtensa_operand_encode (operand, &valbuf) != xtensa_encode_result_ok);
d3906 1
a3907 62
/* Check if a symbol is pointing to somewhere after
   the start frag, given that the segment has stretched 
   by stretch during relaxation.

   This is more complicated than it might appear at first blush
   because of the stretching that goes on. Here is how the check
   works:

   If the symbol and the frag are in the same segment, then
   the symbol could be down range. Note that this function 
   assumes that start_frag is in now_seg.

   If the symbol is pointing to a frag with an address greater than 
   than the start_frag's address, then it _could_ be down range. 

   The problem comes because target_frag may or may not have had
   stretch bytes added to its address already, depending on if it is 
   before or after start frag. (And if we knew that, then we wouldn't
   need this function.) start_frag has definitely already had stretch
   bytes added to its address.
   
   If target_frag's address hasn't been adjusted yet, then to 
   determine if it comes after start_frag, we need to subtract
   stretch from start_frag's address.

   If target_frag's address has been adjusted, then it might have
   been adjusted such that it comes after start_frag's address minus
   stretch bytes.

   So, in that case, we scan for it down stream to within 
   stretch bytes. We could search to the end of the fr_chain, but
   that ends up taking too much time (over a minute on some gnu 
   tests).  */

int
is_dnrange (start_frag, sym, stretch)
     fragS *start_frag;
     symbolS *sym;
     long stretch;
{
  if (S_GET_SEGMENT (sym) == now_seg)
    {
      fragS *cur_frag = symbol_get_frag (sym);

      if (cur_frag->fr_address >= start_frag->fr_address - stretch)
	{
	  int distance = stretch;

	  while (cur_frag && distance >= 0) 
	    {
	      distance -= cur_frag->fr_fix;
	      if (cur_frag == start_frag)
		return 0;
	      cur_frag = cur_frag->fr_next;
	    }
	  return 1;
	}
    }
  return 0;
}


d3917 4
a3920 4
     fragS *pc_frag;		/* If pc_frag == 0, then no pc-relative.  */
     offsetT pc_offset;		/* Offset in fragment.  */
     int min_steps;		/* Minimum number of conversion steps.  */
     long stretch;		/* Number of bytes stretched so far.  */
d3942 1
a3942 1
  tinsn_copy (&current_insn, insn);
d3961 1
a3961 1
      tinsn_copy (&current_insn, &single_target);
d4004 1
a4004 1
xg_finish_frag (last_insn, state, max_growth, is_insn)
d4006 2
a4007 1
     enum xtensa_relax_statesE state;
d4017 1
d4027 4
a4030 1
	    state, frag_now->fr_symbol, frag_now->fr_offset, last_insn);
d4044 1
a4044 1
  int num_ops = xtensa_num_operands (isa, insn->opcode);
d4049 2
a4050 1
  if (is_loop_opcode (insn->opcode))
d4055 1
a4055 3
      xtensa_operand opnd = xtensa_get_operand (isa, insn->opcode, i);
      char *kind = xtensa_operand_kind (opnd);
      if (strlen (kind) == 1 && *kind == 'l')
d4094 1
a4094 1
  int num_ops = xtensa_num_operands (isa, insn->opcode);
d4096 1
a4096 1
  if (is_loop_opcode (insn->opcode))
d4099 3
a4101 5
      xtensa_operand opnd = xtensa_get_operand (isa, insn->opcode, i);
      char *kind = xtensa_operand_kind (opnd);
      if (strlen (kind) == 1 && *kind == 'l')
	if (insn->tok[i].X_op == O_symbol)
	  symbol_get_tc (insn->tok[i].X_add_symbol)->is_loop_target = TRUE;
d4105 2
a4106 5
  /* Currently, we do not add branch targets.  This is an optimization
     for later that tries to align only branch targets, not just any
     label in a text section.  */

  if (align_only_targets)
d4112 1
a4112 3
	  xtensa_operand opnd = xtensa_get_operand (isa, insn->opcode, i);
	  char *kind = xtensa_operand_kind (opnd);
	  if (strlen (kind) == 1 && *kind == 'l'
d4125 5
a4129 1
/* Return the transition rule that matches or NULL if none matches.  */
d4132 3
a4134 3
xg_instruction_matches_rule (insn, rule)
     TInsn *insn;
     TransitionRule *rule;
d4136 59
a4194 1
  PreconditionList *condition_l;
d4213 17
a4229 3
	  if (!expr_is_const (exp1))
	    return FALSE;
	  switch (cond->cmp)
d4231 13
a4243 8
	    case OP_EQUAL:
	      if (get_expr_const (exp1) != cond->op_data)
		return FALSE;
	      break;
	    case OP_NOTEQUAL:
	      if (get_expr_const (exp1) == cond->op_data)
		return FALSE;
	      break;
d4245 2
d4274 3
d4281 69
d4354 1
a4354 1
  TransitionTable *table = xg_build_simplify_table ();
d4369 1
a4369 1
/* Return false if no error.  */
d4386 1
d4392 1
d4438 1
a4438 1
/* Return true if it was simplified.  */
d4445 1
a4445 1
  TransitionRule *rule = xg_instruction_match (old_insn);
d4447 5
d4471 1
a4471 1
   multiple instructions/literals onto the stack.  Return false if no
d4483 4
a4486 7
  /* On return, we will be using the "use_tokens" with "use_ntok".
     This will reduce things like addi to addi.n.  */
  if (code_density_available () && !orig_insn->is_specific_opcode)
    {
      if (xg_simplify_insn (orig_insn, &new_insn))
	orig_insn = &new_insn;
    }
d4488 2
a4489 1
  noperands = xtensa_num_operands (xtensa_default_isa, orig_insn->opcode);
d4504 1
a4504 1
  /* If there are not enough operands, we will assert above. If there
d4509 1
a4509 1
  /* Cases: 
d4517 2
a4518 2
     Also close out the fragment if the fixup may cause instruction expansion. 
     
d4523 2
a4524 2
        Multiple of these may be possible on the same fragment. 
	If so, make sure to satisfy the required alignment. 
d4530 1
a4530 1
  if (orig_insn->is_specific_opcode || !can_relax ())
a4550 8
#if 0
  for (i = 0; i < istack->ninsn; i++)
    {
      if (xg_simplify_insn (&new_insn, &istack->insn[i]))
	istack->insn[i] = new_insn;
    }
#endif

d4569 2
d4578 14
d4596 1
d4598 13
a4610 1
  emit_expr (&insn->tok[0], litsize);
d4624 19
d4644 1
a4644 1
xg_assemble_literal_space (size)
d4646 1
d4649 1
a4649 1
  /* We might have to do something about this alignment.  It only  
a4653 2
  expressionS saved_loc;

a4654 1
  set_expr_symbol_offset (&saved_loc, frag_now->fr_symbol, frag_now_fix ());
d4660 1
d4668 1
a4668 1
  xg_finish_frag (0, RELAX_LITERAL, size, FALSE);
d4672 1
a4672 1
  frag_now->tc_frag_data.literal_frag = lit_saved_frag;
d4752 1
a4752 1
/* Return true if the section flags are marked linkonce
a4776 104
/* Emit an instruction to the current fragment.  If record_fix is true,
   then this instruction will not change and we can go ahead and record
   the fixup.  If record_fix is false, then the instruction may change
   and we are going to close out this fragment.  Go ahead and set the
   fr_symbol and fr_offset instead of adding a fixup.  */

static bfd_boolean
xg_emit_insn (t_insn, record_fix)
     TInsn *t_insn;
     bfd_boolean record_fix;
{
  bfd_boolean ok = TRUE;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = t_insn->opcode;
  bfd_boolean has_fixup = FALSE;
  int noperands;
  int i, byte_count;
  fragS *oldfrag;
  size_t old_size;
  char *f;
  static xtensa_insnbuf insnbuf = NULL;
  
  /* Use a static pointer to the insn buffer so we don't have to call 
     malloc each time through.  */
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  has_fixup = tinsn_to_insnbuf (t_insn, insnbuf);

  noperands = xtensa_num_operands (isa, opcode);
  assert (noperands == t_insn->ntok);

  byte_count = xtensa_insn_length (isa, opcode);
  oldfrag = frag_now;
  /* This should NEVER cause us to jump into a new frag;
     we've already reserved space.  */
  old_size = frag_now_fix ();
  f = frag_more (byte_count);
  assert (oldfrag == frag_now);

  /* This needs to generate a record that lists the parts that are
     instructions.  */
  if (!frag_now->tc_frag_data.is_insn)
    {
      /* If we are at the beginning of a fragment, switch this
	 fragment to an instruction fragment.  */
      if (now_seg != absolute_section && old_size != 0)
	as_warn (_("instruction fragment may contain data"));
      frag_now->tc_frag_data.is_insn = TRUE;
    }

  xtensa_insnbuf_to_chars (isa, insnbuf, f);

  dwarf2_emit_insn (byte_count);

  /* Now spit out the opcode fixup.... */
  if (!has_fixup)
    return !ok;

  for (i = 0; i < noperands; ++i)
    {
      expressionS *expr = &t_insn->tok[i];
      switch (expr->X_op)
	{
	case O_symbol:
	  if (get_relaxable_immed (opcode) == i)
	    {
	      if (record_fix)
		{
		  if (!xg_add_opcode_fix (opcode, i, expr, frag_now,
					  f - frag_now->fr_literal))
		    ok = FALSE;
		}
	      else
		{
		  /* Write it to the fr_offset, fr_symbol.  */
		  frag_now->fr_symbol = expr->X_add_symbol;
		  frag_now->fr_offset = expr->X_add_number;
		}
	    }
	  else
	    {
	      as_bad (_("invalid operand %d on '%s'"),
		      i, xtensa_opcode_name (isa, opcode));
	      ok = FALSE;
	    }
	  break;

	case O_constant:
	case O_register:
	  break;

	default:
	  as_bad (_("invalid expression for operand %d on '%s'"),
		  i, xtensa_opcode_name (isa, opcode));
	  ok = FALSE;
	  break;
	}
    }

  return !ok;
}


d4778 3
a4780 2
xg_emit_insn_to_buf (t_insn, buf, fragP, offset, build_fix)
     TInsn *t_insn;
d4792 1
a4792 1
  has_symbolic_immed = tinsn_to_insnbuf (t_insn, insnbuf);
d4796 2
a4797 2
      int opnum = get_relaxable_immed (t_insn->opcode);
      expressionS *exp = &t_insn->tok[opnum];
d4799 1
a4799 2
      if (!xg_add_opcode_fix (t_insn->opcode, 
			      opnum, exp, fragP, offset))
d4803 1
a4803 1
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf);
d4809 1
a4809 1
   Return true on success.  */
d4812 2
a4813 2
xg_add_opcode_fix (opcode, opnum, expr, fragP, offset)
     xtensa_opcode opcode;
d4815 2
d4820 5
a4824 4
{ 
  bfd_reloc_code_real_type reloc; 
  reloc_howto_type *howto; 
  int insn_length;
d4827 42
a4868 1
  reloc = opnum_to_reloc (opnum);
d4871 1
a4871 2
      as_bad (_("invalid relocation operand %i on '%s'"),
	      opnum, xtensa_opcode_name (xtensa_default_isa, opcode));
a4875 1

d4878 1
a4878 1
      as_bad (_("undefined symbol for opcode \"%s\"."),
d4883 2
a4884 2
  insn_length = xtensa_insn_length (xtensa_default_isa, opcode);
  the_fix = fix_new_exp (fragP, offset, insn_length, expr,
d4887 3
a4889 2
  if (expr->X_add_symbol && 
      (S_IS_EXTERNAL (expr->X_add_symbol) || S_IS_WEAK (expr->X_add_symbol)))
d4891 4
d4924 1
a4924 1
  /* assert(!insn->is_literal); */
d4932 1
a4932 151
static void
xg_assemble_tokens (insn)
     /*const */ TInsn *insn;
{
  /* By the time we get here, there's not too much left to do. 
     1) Check our assumptions. 
     2) Check if the current instruction is "narrow". 
        If so, then finish the frag, create another one.
        We could also go back to change some previous
        "narrow" frags into no-change ones if we have more than
        MAX_NARROW_ALIGNMENT of them without alignment restrictions
        between them.

     Cases:
        1) It has constant operands and doesn't fit.
           Go ahead and assemble it so it will fail.
        2) It has constant operands that fit.
           If narrow and !is_specific_opcode,
              assemble it and put in a relocation
           else
              assemble it.
        3) It has a symbolic immediate operand
           a) Find the worst-case relaxation required
           b) Find the worst-case literal pool space required.
              Insert appropriate alignment & space in the literal.
              Assemble it.
              Add the relocation.  */

  assert (insn->insn_type == ITYPE_INSN);

  if (!tinsn_has_symbolic_operands (insn))
    {
      if (xg_is_narrow_insn (insn) && !insn->is_specific_opcode)
	{
	  /* assemble it but add max required space */
	  int max_size = xg_get_max_narrow_insn_size (insn->opcode);
	  int min_size = xg_get_insn_size (insn);
	  char *last_insn;
	  assert (max_size == 3);
	  /* make sure we have enough space to widen it */
	  xg_force_frag_space (max_size);
	  /* Output the instruction.  It may cause an error if some 
	     operands do not fit.  */
	  last_insn = frag_more (0);
	  if (xg_emit_insn (insn, TRUE))
	    as_warn (_("instruction with constant operands does not fit"));
	  xg_finish_frag (last_insn, RELAX_NARROW, max_size - min_size, TRUE);
	}
      else
	{
	  /* Assemble it.  No relocation needed.  */
	  int max_size = xg_get_insn_size (insn);
	  xg_force_frag_space (max_size);
	  if (xg_emit_insn (insn, FALSE))
	    as_warn (_("instruction with constant operands does not "
		       "fit without widening"));
	  /* frag_more (max_size); */

	  /* Special case for jx.  If the jx is the next to last
	     instruction in a loop, we will add a NOP after it.  This
	     avoids a hardware issue that could occur if the jx jumped
	     to the next instruction.  */
	  if (software_avoid_b_j_loop_end
	      && is_jx_opcode (insn->opcode))
	    {
	      maybe_has_b_j_loop_end = TRUE;
	      /* add 2 of these */
	      frag_now->tc_frag_data.is_insn = TRUE;
	      frag_var (rs_machine_dependent, 4, 4,
			RELAX_ADD_NOP_IF_PRE_LOOP_END,
			frag_now->fr_symbol, frag_now->fr_offset, NULL);
	    }
	}
    }
  else
    {
      /* Need to assemble it with space for the relocation.  */
      if (!insn->is_specific_opcode)
	{
	  /* Assemble it but add max required space.  */
	  char *last_insn;
	  int min_size = xg_get_insn_size (insn);
	  int max_size = xg_get_max_insn_widen_size (insn->opcode);
	  int max_literal_size =
	    xg_get_max_insn_widen_literal_size (insn->opcode);

#if 0
	  symbolS *immed_sym = xg_get_insn_immed_symbol (insn);
	  set_frag_segment (frag_now, now_seg);
#endif /* 0 */

	  /* Make sure we have enough space to widen the instruction. 
	     This may open a new fragment.  */
	  xg_force_frag_space (max_size);
	  if (max_literal_size != 0)
	    xg_assemble_literal_space (max_literal_size);

	  /* Output the instruction.  It may cause an error if some 
	     operands do not fit.  Emit the incomplete instruction.  */
	  last_insn = frag_more (0);
	  xg_emit_insn (insn, FALSE);

	  xg_finish_frag (last_insn, RELAX_IMMED, max_size - min_size, TRUE);

	  /* Special cases for loops:
	     close_loop_end should be inserted AFTER short_loop.
	     Make sure that CLOSE loops are processed BEFORE short_loops
	     when converting them.  */

	  /* "short_loop": add a NOP if the loop is < 4 bytes.  */
	  if (software_avoid_short_loop
	      && is_loop_opcode (insn->opcode))
	    {
	      maybe_has_short_loop = TRUE;
	      frag_now->tc_frag_data.is_insn = TRUE;
	      frag_var (rs_machine_dependent, 4, 4,
			RELAX_ADD_NOP_IF_SHORT_LOOP,
			frag_now->fr_symbol, frag_now->fr_offset, NULL);
	      frag_now->tc_frag_data.is_insn = TRUE;
	      frag_var (rs_machine_dependent, 4, 4,
			RELAX_ADD_NOP_IF_SHORT_LOOP,
			frag_now->fr_symbol, frag_now->fr_offset, NULL);
	    }

	  /* "close_loop_end": Add up to 12 bytes of NOPs to keep a
	     loop at least 12 bytes away from another loop's loop
	     end.  */
	  if (software_avoid_close_loop_end
	      && is_loop_opcode (insn->opcode))
	    {
	      maybe_has_close_loop_end = TRUE;
	      frag_now->tc_frag_data.is_insn = TRUE;
	      frag_var (rs_machine_dependent, 12, 12,
			RELAX_ADD_NOP_IF_CLOSE_LOOP_END,
			frag_now->fr_symbol, frag_now->fr_offset, NULL);
	    }
	}
      else
	{
	  /* Assemble it in place.  No expansion will be required, 
	     but we'll still need a relocation record.  */
	  int max_size = xg_get_insn_size (insn);
	  xg_force_frag_space (max_size);
	  if (xg_emit_insn (insn, TRUE))
	    as_warn (_("instruction's constant operands do not fit"));
	}
    }
}


/* Return true if the instruction can write to the specified
d4945 1
a4945 1
  num_ops = xtensa_num_operands (isa, insn->opcode);
d4949 8
a4956 6
      xtensa_operand operand = xtensa_get_operand (isa, insn->opcode, i);
      char inout = xtensa_operand_inout (operand);

      if (inout == '>' || inout == '=')
	{
	  if (strcmp (xtensa_operand_kind (operand), regset) == 0)
d4990 2
a4991 1
      || opcode == xtensa_waiti_opcode)
a4993 7
  /* An RSR of LCOUNT is illegal as the last opcode in a loop.  */
  if (opcode == xtensa_rsr_opcode
      && tinsn->ntok >= 2
      && tinsn->tok[1].X_op == O_constant
      && tinsn->tok[1].X_add_number == 2)
    return TRUE;

d5004 2
a5005 2
is_unaligned_label (sym) 
     symbolS *sym; 
d5019 1
a5019 1
  if (name 
d5049 32
a5080 2
xtensa_opcode
next_frag_opcode (fragP)
a5082 1
  const fragS *next_fragP = next_non_empty_frag (fragP);
d5085 2
d5091 1
a5091 1
  if (next_fragP == NULL)
d5094 1
a5094 3
  xtensa_insnbuf_from_chars (isa, insnbuf, next_fragP->fr_literal);
  return xtensa_decode_insn (isa, insnbuf);
}
d5096 4
d5101 35
a5135 1
/* Return true if the target frag is one of the next non-empty frags.  */
d5167 1
a5167 1
update_next_frag_nop_state (fragP)
d5169 1
d5172 42
d5215 4
a5218 1
  while (next_fragP && next_fragP->fr_fix == 0)
d5220 1
a5220 2
      if (next_fragP->fr_type == rs_machine_dependent
	  && next_fragP->fr_subtype == RELAX_LOOP_END)
d5222 4
a5225 2
	  next_fragP->fr_subtype = RELAX_LOOP_END_ADD_NOP;
	  return;
a5226 1
      next_fragP = next_fragP->fr_next;
d5235 1
a5235 1
  /* Sometimes an empty will end up here due storage allocation issues,
d5270 1
d5272 1
a5272 2
  xtensa_opcode next_opcode = next_frag_opcode (fragp);
  if (!is_loop_opcode (next_opcode))
d5275 2
a5276 2
  /* Sometimes an empty will end up here due storage allocation issues.
     So we have to skip until we find something legit.  */
d5285 3
a5287 2
     been relaxed.  */
  if (next_fragp->fr_subtype > RELAX_IMMED)
d5306 3
d5310 1
d5313 1
a5313 1
     so we can later move the literal's fixes into this 
d5317 1
a5317 1
  frag_variant (rs_machine_dependent, 0, (int) frchain_now, 
d5319 2
a5320 1
  frag_variant (rs_machine_dependent, 0, (int) now_seg, 
d5322 1
d5326 3
a5328 1
  xtensa_switch_to_literal_fragment (&s);
d5332 1
d5336 1
d5375 1
a5375 1
      if (loops_ok || symbol_get_tc (lit_sym)->is_loop_target == 0)
d5384 34
d5427 4
a5430 1
  TInsn t_insn;
d5434 2
a5435 28
  tinsn_init (&t_insn);
  switch (size)
    {
    case 2:
      t_insn.opcode = xtensa_nop_n_opcode;
      t_insn.ntok = 0;
      if (t_insn.opcode == XTENSA_UNDEFINED)
	as_fatal (_("opcode 'NOP.N' unavailable in this configuration"));
      tinsn_to_insnbuf (&t_insn, insnbuf);
      xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf);
      break;

    case 3:
      t_insn.opcode = xtensa_or_opcode;
      assert (t_insn.opcode != XTENSA_UNDEFINED);
      if (t_insn.opcode == XTENSA_UNDEFINED)
	as_fatal (_("opcode 'OR' unavailable in this configuration"));
      set_expr_const (&t_insn.tok[0], 1);
      set_expr_const (&t_insn.tok[1], 1);
      set_expr_const (&t_insn.tok[2], 1);
      t_insn.ntok = 3;
      tinsn_to_insnbuf (&t_insn, insnbuf);
      xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf);
      break;

    default:
      as_fatal (_("invalid %d-byte NOP requested"), size);
    }
d5453 1
a5453 2
  if (opcode == XTENSA_UNDEFINED)
    as_fatal (_("get_expanded_loop_offset: undefined opcode"));
d5481 213
d5736 1
a5736 4
#if STATIC_LIBISA
  isa = xtensa_isa_init ();
#else
  /* ISA was already initialized by xtensa_init().  */
a5737 1
#endif
d5739 3
a5741 1
  /* Set  up the .literal, .fini.literal and .init.literal sections.  */
d5746 1
d5750 2
d5762 1
d5764 2
a5766 1
  xtensa_j_opcode = xtensa_opcode_lookup (isa, "j");
d5768 1
d5772 1
d5779 1
a5779 1
  xtensa_rsr_opcode = xtensa_opcode_lookup (isa, "rsr");
d5781 18
d5808 5
d5825 1
a5825 1
      && align_targets
d5827 1
a5827 1
      && !frag_now->tc_frag_data.is_literal)
d5829 20
a5848 2
      /* frag_now->tc_frag_data.is_insn = TRUE; */
      frag_var (rs_machine_dependent, 4, 4,
d5851 1
d5853 44
d5898 12
a5909 9
      /* If the label is already known to be a branch target, i.e., a
	 forward branch, mark the frag accordingly.  Backward branches
	 are handled by xg_add_branch_and_loop_targets.  */
      if (symbol_get_tc (sym)->is_branch_target)
	symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;

      /* Loops only go forward, so they can be identified here.  */
      if (symbol_get_tc (sym)->is_loop_target)
	symbol_get_frag (sym)->tc_frag_data.is_loop_target = TRUE;
d5911 1
d5920 3
d5928 1
d5936 19
d5963 1
a5963 1
  char *arg_strings[MAX_INSN_ARGS]; 
a5964 1
  IStack istack;		/* Put instructions into here.  */
a5965 13
  int i;
  symbolS *lit_sym = NULL;

  if (frag_now->tc_frag_data.is_literal)
    {
      static bfd_boolean reported = 0;
      if (reported < 4)
	as_bad (_("cannot assemble '%s' into a literal fragment"), str);
      if (reported == 3)
	as_bad (_("..."));
      reported++;
      return;
    }
a5966 1
  istack_init (&istack);
d5994 1
a5994 2
  orig_insn.is_specific_opcode = (has_underbar || !use_generics ());
  specific_opcode = orig_insn.is_specific_opcode;
d5999 8
a6006 14
      as_bad (_("unknown opcode %s"), opname);
      return;
    }

  if (frag_now_fix () != 0 && !frag_now->tc_frag_data.is_insn)
    {
      frag_wane (frag_now);
      frag_new (0);
    }

  if (software_a0_b_retw_interlock)
    {
      if ((get_last_insn_flags (now_seg, now_subseg) & FLAG_IS_A0_WRITER) != 0
	  && is_conditional_branch_opcode (orig_insn.opcode))
d6008 3
a6010 13
	  has_a0_b_retw = TRUE;

	  /* Mark this fragment with the special RELAX_ADD_NOP_IF_A0_B_RETW.
	     After the first assembly pass we will check all of them and
	     add a nop if needed.  */
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_A0_B_RETW,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_A0_B_RETW,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
d6012 7
d6030 1
d6040 7
d6049 4
a6052 5
    return;

  /* See if the instruction implies an aligned section.  */
  if (is_entry_opcode (orig_insn.opcode) || is_loop_opcode (orig_insn.opcode))
    record_alignment (now_seg, 2);
d6054 2
d6058 2
a6059 2
  /* Special cases for instructions that force an alignment... */
  if (!orig_insn.is_specific_opcode && is_loop_opcode (orig_insn.opcode))
d6061 9
a6069 26
      size_t max_fill;

      frag_now->tc_frag_data.is_insn = TRUE;
      frag_now->tc_frag_data.is_no_density = !code_density_available ();
      max_fill = get_text_align_max_fill_size
	(get_text_align_power (XTENSA_FETCH_WIDTH),
	 TRUE, frag_now->tc_frag_data.is_no_density);
      frag_var (rs_machine_dependent, max_fill, max_fill,
		RELAX_ALIGN_NEXT_OPCODE, frag_now->fr_symbol,
		frag_now->fr_offset, NULL);

      xtensa_move_labels (frag_now, 0, FALSE);
    }

  /* Special-case for "entry" instruction.  */
  if (is_entry_opcode (orig_insn.opcode))
    {
      /* Check that the second opcode (#1) is >= 16.  */
      if (orig_insn.ntok >= 2)
	{
	  expressionS *exp = &orig_insn.tok[1];
	  switch (exp->X_op)
	    {
	    case O_constant:
	      if (exp->X_add_number < 16)
		as_warn (_("entry instruction with stack decrement < 16"));
a6075 9

      if (!orig_insn.is_specific_opcode)
	{
	  xtensa_mark_literal_pool_location ();

	  /* Automatically align ENTRY instructions.  */
	  xtensa_move_labels (frag_now, 0, TRUE);
	  frag_align (2, 0, 0);
	}
a6077 11
  /* Any extra alignment frags have been inserted now, and we're about to
     emit a new instruction so clear the list of labels.  */
  xtensa_clear_insn_labels ();

  if (software_a0_b_retw_interlock)
    set_last_insn_flags (now_seg, now_subseg, FLAG_IS_A0_WRITER,
			 is_register_writer (&orig_insn, "a", 0));

  set_last_insn_flags (now_seg, now_subseg, FLAG_IS_BAD_LOOPEND,
		       is_bad_loopend_opcode (&orig_insn));

d6079 3
a6081 3
     assemble_tokens (opcode, tok, ntok); 
     expand the tokens from the orig_insn into the 
     stack of instructions that will not expand 
a6082 2
  if (xg_expand_assembly_insn (&istack, &orig_insn))
    return;
d6084 10
a6093 14
  for (i = 0; i < istack.ninsn; i++)
    {
      TInsn *insn = &istack.insn[i];
      if (insn->insn_type == ITYPE_LITERAL)
	{
	  assert (lit_sym == NULL);
	  lit_sym = xg_assemble_literal (insn);
	}
      else
	{
	  if (lit_sym)
	    xg_resolve_literals (insn, lit_sym);
	  xg_assemble_tokens (insn);
	}
d6096 2
a6097 10
  /* Now, if the original opcode was a call... */
  if (align_targets && is_call_opcode (orig_insn.opcode))
    {
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, 4,
		RELAX_DESIRE_ALIGN,
		frag_now->fr_symbol,
		frag_now->fr_offset,
		NULL);
    }
d6101 5
a6105 3
/* TC_CONS_FIX_NEW hook: Check for "@@PLT" suffix on symbol references.
   If found, use an XTENSA_PLT reloc for 4-byte values.  Otherwise, this
   is the same as the standard code in read.c.  */
d6107 3
a6109 6
void 
xtensa_cons_fix_new (frag, where, size, exp)
     fragS *frag;
     int where; 
     int size;
     expressionS *exp;
d6111 19
a6129 17
  bfd_reloc_code_real_type r;
  bfd_boolean plt = FALSE;

  if (*input_line_pointer == '@@') 
    {
      if (!strncmp (input_line_pointer, PLT_SUFFIX, strlen (PLT_SUFFIX) - 1)
	  && !strncmp (input_line_pointer, plt_suffix,
		       strlen (plt_suffix) - 1))
	{
	  as_bad (_("undefined @@ suffix '%s', expected '%s'"), 
		  input_line_pointer, plt_suffix);
	  ignore_rest_of_line ();
	  return;
	}

      input_line_pointer += strlen (plt_suffix);
      plt = TRUE;
d6131 1
a6132 22
  switch (size)
    {
    case 1:
      r = BFD_RELOC_8;
      break;
    case 2:
      r = BFD_RELOC_16;
      break;
    case 4:
      r = plt ? BFD_RELOC_XTENSA_PLT : BFD_RELOC_32;
      break;
    case 8:
      r = BFD_RELOC_64;
      break;
    default:
      as_bad (_("unsupported BFD relocation size %u"), size);
      r = BFD_RELOC_32;
      break;
    }
  fix_new_exp (frag, where, size, exp, 0, r);
}
  
d6140 1
a6140 1
  frag->tc_frag_data.is_no_density = !code_density_available ();
d6169 1
d6171 1
a6171 1
  xtensa_operand operand;
d6173 2
d6177 1
d6186 4
a6189 1
    insnbuf = xtensa_insnbuf_alloc (isa);
d6192 2
a6193 2
  xtensa_insnbuf_from_chars (isa, insnbuf, insn_p);
  opcode = xtensa_decode_insn (isa, insnbuf);
d6195 2
a6196 1
  opnum = reloc_to_opnum (fixP->fx_r_type);
d6198 13
a6210 13
  if (opnum < 0)
    as_fatal (_("invalid operand relocation for '%s' instruction"),
	      xtensa_opcode_name (isa, opcode));
  if (opnum >= xtensa_num_operands (isa, opcode))
    as_fatal (_("invalid relocation for operand %d in '%s' instruction"),
	      opnum, xtensa_opcode_name (isa, opcode));
  operand = xtensa_get_operand (isa, opcode, opnum);
  if (!operand)
    {
      as_warn_where (fixP->fx_file,
		     fixP->fx_line,
		     _("invalid relocation type %d for %s instruction"),
		     fixP->fx_r_type, xtensa_opcode_name (isa, opcode));
d6214 4
a6217 1
  if (!operand_is_pcrel_label (operand))
d6225 32
a6256 8
  if (!xtensa_operand_isPCRelative (operand))
    {
      as_warn_where (fixP->fx_file,
		     fixP->fx_line,
		     _("non-PCREL relocation operand %d for '%s': %s"),
		     opnum, xtensa_opcode_name (isa, opcode),
		     bfd_get_reloc_code_name (fixP->fx_r_type));
      return addr;
d6259 23
a6281 1
  return 0 - xtensa_operand_do_reloc (operand, 0, addr);
d6285 1
a6285 1
/* tc_symbol_new_hook */
d6288 1
a6288 2
xtensa_symbol_new_hook (symbolP)
     symbolS *symbolP;
d6290 3
a6292 1
  symbol_get_tc (symbolP)->plt = 0;
d6302 8
d6315 13
d6329 1
a6340 4
      /* This happens when the relocation is within the current section. 
         It seems this implies a PCREL operation.  We'll catch it and error 
         if not.  */

a6341 3
      static xtensa_insnbuf insnbuf = NULL;
      xtensa_opcode opcode;
      xtensa_isa isa;
a6361 20
	case BFD_RELOC_XTENSA_OP0:
	case BFD_RELOC_XTENSA_OP1:
	case BFD_RELOC_XTENSA_OP2:
	  isa = xtensa_default_isa;
	  if (!insnbuf)
	    insnbuf = xtensa_insnbuf_alloc (isa);

	  xtensa_insnbuf_from_chars (isa, insnbuf, fixpos);
	  opcode = xtensa_decode_insn (isa, insnbuf);
	  if (opcode == XTENSA_UNDEFINED)
	    as_fatal (_("undecodable FIX"));

	  xtensa_insnbuf_set_immediate_field (opcode, insnbuf, *valP,
					      fixP->fx_file, fixP->fx_line);

	  fixP->fx_frag->tc_frag_data.is_insn = TRUE;
	  xtensa_insnbuf_to_chars (isa, insnbuf, fixpos);
	  fixP->fx_done = 1;
	  break;

d6426 1
a6426 1
  return fragP->tc_frag_data.text_expansion;
d6435 1
a6435 1
     asection *section ATTRIBUTE_UNUSED;
d6439 1
d6450 123
d6579 2
d6585 19
a6603 3
    {
      as_fatal (_("internal error? cannot generate `%s' relocation"),
		bfd_get_reloc_code_name (fixp->fx_r_type));
a6604 1
  assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);
d6606 2
a6607 1
  reloc->addend = fixp->fx_offset;
a6608 11
  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_XTENSA_OP0:
    case BFD_RELOC_XTENSA_OP1:
    case BFD_RELOC_XTENSA_OP2:
    case BFD_RELOC_XTENSA_ASM_EXPAND:
    case BFD_RELOC_32: 
    case BFD_RELOC_XTENSA_PLT: 
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      break;
d6610 1
a6610 3
    case BFD_RELOC_XTENSA_ASM_SIMPLIFY:
      as_warn (_("emitting simplification relocation"));
      break;
d6612 3
a6614 6
    default:
      as_warn (_("emitting unknown relocation"));
    }

  return reloc;
}
a6615 1

d6617 1
a6617 1
xtensa_end ()
d6619 3
a6621 10
  directive_balance ();
  xtensa_move_literals ();

  xtensa_reorder_segments ();
  xtensa_cleanup_align_frags ();
  xtensa_fix_target_frags ();
  if (software_a0_b_retw_interlock && has_a0_b_retw)
    xtensa_fix_a0_b_retw_frags ();
  if (software_avoid_b_j_loop_end && maybe_has_b_j_loop_end)
    xtensa_fix_b_j_loop_end_frags ();
d6623 1
a6623 3
  /* "close_loop_end" should be processed BEFORE "short_loop".  */
  if (software_avoid_close_loop_end && maybe_has_close_loop_end)
    xtensa_fix_close_loop_end_frags ();
d6625 8
a6632 2
  if (software_avoid_short_loop && maybe_has_short_loop)
    xtensa_fix_short_loop_frags ();
d6634 3
a6636 1
  xtensa_sanity_check ();
d6640 2
d6643 2
a6644 1
xtensa_cleanup_align_frags ()
d6646 37
a6682 1
  frchainS *frchP;
d6684 1
a6684 1
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
d6686 11
a6696 1
      fragS *fragP;
d6698 3
a6700 2
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
d6702 33
a6734 6
	  if ((fragP->fr_type == rs_align
	       || fragP->fr_type == rs_align_code
	       || (fragP->fr_type == rs_machine_dependent
		   && (fragP->fr_subtype == RELAX_DESIRE_ALIGN
		       || fragP->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)))
	      && fragP->fr_fix == 0)
d6736 13
a6748 1
	      fragS * next = fragP->fr_next;
d6750 9
a6758 3
	      while (next
		     && next->fr_type == rs_machine_dependent 
		     && next->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET) 
d6760 9
a6768 2
		  frag_wane (next);
		  next = next->fr_next;
d6771 5
d6778 23
d6804 1071
a7874 6
/* Re-process all of the fragments looking to convert all of the
   RELAX_DESIRE_ALIGN_IF_TARGET fragments.  If there is a branch
   target in the next fragment, convert this to RELAX_DESIRE_ALIGN.
   If the next fragment starts with a loop target, AND the previous
   fragment can be expanded to negate the branch, convert this to a
   RELAX_LOOP_END.  Otherwise, convert to a .fill 0.  */
d7897 6
a7902 1
		    fragP->fr_subtype = RELAX_LOOP_END;
d7905 1
a7905 2
		      if (!align_only_targets ||
			  next_frag_is_branch_target (fragP))
d7911 1
a7911 2
	      else if (!align_only_targets
		       || next_frag_is_branch_target (fragP))
d7929 11
a7939 2
  if (fragP->fr_type == rs_machine_dependent
      && fragP->fr_subtype == RELAX_IMMED)
d7941 2
a7942 3
      TInsn t_insn;
      tinsn_from_chars (&t_insn, fragP->fr_opcode);
      if (is_negatable_branch (&t_insn))
d7945 82
d8031 34
d8088 7
a8094 3
		relax_frag_add_nop (fragP);
	      else
		frag_wane (fragP);
d8103 1
a8103 1
     fragS * fragP;
d8106 1
d8109 1
d8112 2
d8116 4
a8119 1
    insnbuf = xtensa_insnbuf_alloc (isa);
d8125 13
a8137 2
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset]);
  opcode = xtensa_decode_insn (isa, insnbuf);
d8139 1
a8139 1
  if (!is_conditional_branch_opcode (opcode))
d8142 1
a8142 1
  offset += xtensa_insn_length (isa, opcode);
d8148 1
d8153 11
a8163 2
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset]);
  opcode = xtensa_decode_insn (isa, insnbuf);
d8167 1
d8195 7
a8201 3
		relax_frag_add_nop (fragP);
	      else
		frag_wane (fragP);
d8257 4
a8260 1
	      && fragP->fr_subtype == RELAX_IMMED)
d8263 4
a8266 2
	      xtensa_opcode opcode = get_opcode_from_buf (fragP->fr_opcode);
	      if (is_loop_opcode (opcode))
a8267 5
		  TInsn t_insn;

		  tinsn_from_chars (&t_insn, fragP->fr_opcode);
		  tinsn_immed_from_frag (&t_insn, fragP);

d8269 1
a8269 1
		  if (fragP->fr_symbol)
d8271 2
a8272 1
		      current_target = symbol_get_frag (fragP->fr_symbol);
d8293 3
a8295 2
		  while (min_bytes + bytes_added
			 < REQUIRED_LOOP_DIVIDING_BYTES)
d8297 2
a8298 6
		      int length = 3;

		      if (fragP->fr_var < length)
			as_warn (_("fr_var %lu < length %d; ignoring"),
				 fragP->fr_var, length);
		      else
d8300 13
a8312 4
			  assemble_nop (length,
					fragP->fr_literal + fragP->fr_fix);
			  fragP->fr_fix += length;
			  fragP->fr_var -= length;
a8313 1
		      bytes_added += length;
d8318 2
d8325 1
a8325 1
size_t
d8352 1
a8352 1
size_t
d8354 1
a8354 1
     fragS * fragP;
d8366 38
d8413 1
a8413 1
     1) software_avoid_all_short_loops is true
d8437 1
a8437 1
	  /* check on the current loop */
d8439 4
a8442 1
	      && fragP->fr_subtype == RELAX_IMMED)
d8444 2
d8447 3
a8449 2
	      xtensa_opcode opcode = get_opcode_from_buf (fragP->fr_opcode);
	      if (is_loop_opcode (opcode))
a8450 5
		  TInsn t_insn;

		  tinsn_from_chars (&t_insn, fragP->fr_opcode);
		  tinsn_immed_from_frag (&t_insn, fragP);

d8452 1
a8452 1
		  if (fragP->fr_symbol)
d8454 2
a8455 1
		      current_target = symbol_get_frag (fragP->fr_symbol);
d8457 1
a8457 1
		      current_opcode = opcode;
d8469 1
a8469 1
		      || (software_avoid_all_short_loops
d8472 7
a8478 3
		relax_frag_add_nop (fragP);
	      else
		frag_wane (fragP);
d8485 1
a8485 1
size_t
d8520 1
a8520 1
size_t
d8524 2
d8532 3
d8538 6
a8543 2
      xtensa_opcode opcode = get_opcode_from_buf (fragP->fr_literal + offset);
      if (opcode == XTENSA_UNDEFINED)
d8548 1
a8548 1
      offset += xtensa_insn_length (xtensa_default_isa, opcode);
d8556 1
a8556 1
bfd_boolean
d8573 1
a8573 1
bfd_boolean
d8577 2
a8578 1
  size_t insn_count = 0;
d8584 3
d8590 9
a8598 2
      xtensa_opcode opcode = get_opcode_from_buf (fragP->fr_literal + offset);
      if (opcode == XTENSA_UNDEFINED)
d8600 5
a8604 2
	  as_fatal (_("undecodable instruction in instruction frag"));
	  return insn_count;
d8606 1
a8606 3
      if (is_branch_or_jump_opcode (opcode))
	return TRUE;
      offset += xtensa_insn_length (xtensa_default_isa, opcode);
d8641 2
a8642 2
		  tinsn_from_chars (&t_insn, fragP->fr_opcode);
		  tinsn_immed_from_frag (&t_insn, fragP);
d8644 2
a8645 1
		  if (is_loop_opcode (t_insn.opcode))
d8669 1
a8669 1
/* Return true if the loop target is the next non-zero fragment.  */
d8683 1
a8683 1
  if (!is_loop_opcode (insn->opcode))
d8706 1
d8732 1
a8732 1
  if (!is_loop_opcode (insn->opcode))
d8752 1
d8756 4
a8759 2
    if (next_fragP == symbol_get_frag (symbolP))
      return TRUE;
d8767 1
a8767 1
size_t
d8777 1
a8777 1
  as_fatal (_("get_text_align_power: argument too large"));
d8782 1
a8782 1
addressT
d8798 1
a8798 1
  
d8808 1
d8820 1
a8820 1
addressT
d8836 1
a8836 1
     use_nops: if true, then we can only use 2 or 3 byte nops.
d8841 14
a8854 3
     Usually, for non-zero target_size, the align_pow is the power of 2
     that is greater than or equal to the target_size.  This handles the
     2-byte, 3-byte and 8-byte instructions.  */
d8857 3
d8862 9
a8870 7
      /* This is the easy case.  */
      size_t mod;
      mod = address % alignment;
      if (mod != 0)
	mod = alignment - mod;
      assert ((address + mod) % alignment == 0);
      return mod;
d8883 2
a8884 2
	  if ((address + i) >> align_pow ==
	      (address + i + target_size - 1) >> align_pow)
d8895 2
a8896 2
	  if ((address + i) >> align_pow ==
	      (address + i + target_size - 1) >> align_pow)
d8970 14
a8983 1
  static xtensa_insnbuf insnbuf = NULL;
d8985 7
d8993 2
a8994 12
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  switch (fragP->fr_type)
    {
    case rs_machine_dependent:
      if (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
	{
	  /* The rule is: get next fragment's FIRST instruction.  Find
	     the smallest number of bytes that need to be added to
	     ensure that the next fragment's FIRST instruction will fit
	     in a single word.
d8996 4
a8999 2
	     E.G.,   2 bytes : 0, 1, 2 mod 4 
		     3 bytes: 0, 1 mod 4 
d9001 3
a9003 2
	     If the FIRST instruction MIGHT be relaxed, 
	     assume that it will become a 3 byte instruction.  */
d9005 2
a9006 3
	  int target_insn_size;
	  xtensa_opcode opcode = next_frag_opcode (fragP);
	  addressT pre_opcode_bytes;
d9008 2
a9009 6
	  if (opcode == XTENSA_UNDEFINED)
	    {
	      as_bad_where (fragP->fr_file, fragP->fr_line,
			    _("invalid opcode for RELAX_ALIGN_NEXT_OPCODE"));
	      as_fatal (_("cannot continue"));
	    }
d9011 2
a9012 1
	  target_insn_size = xtensa_insn_length (xtensa_default_isa, opcode);
d9014 1
a9014 1
	  pre_opcode_bytes = next_frag_pre_opcode_bytes (fragP);
d9016 1
a9016 6
	  if (is_loop_opcode (opcode))
	    {
	      /* next_fragP should be the loop.  */
	      const fragS *next_fragP = next_non_empty_frag (fragP);
	      xtensa_opcode next_opcode = next_frag_opcode (next_fragP);
	      size_t alignment;
d9018 2
a9019 1
	      pre_opcode_bytes += target_insn_size;
d9021 2
a9022 8
	      /* For loops, the alignment depends on the size of the
		 instruction following the loop, not the loop instruction.  */
	      if (next_opcode == XTENSA_UNDEFINED)
		target_insn_size = 3;
	      else
		{
		  target_insn_size =
		    xtensa_insn_length (xtensa_default_isa, next_opcode);
d9024 7
a9030 3
		  if (target_insn_size == 2)
		    target_insn_size = 3;	/* ISA specifies this.  */
		}
d9032 2
a9033 3
	      /* If it was 8, then we'll need a larger alignment
	         for the section.  */
	      alignment = get_text_align_power (target_insn_size);
a9034 23
	      /* Is Now_seg valid */
	      record_alignment (now_seg, alignment);
	    }
	  else
	    as_fatal (_("expected loop opcode in relax align next target"));

	  fill_size = get_text_align_fill_size
	    (address + pre_opcode_bytes,
	     get_text_align_power (target_insn_size),
	     target_insn_size, TRUE, fragP->tc_frag_data.is_no_density);
	}
      break;
#if 0
    case rs_align:
    case rs_align_code:
      fill_size = get_text_align_fill_size
	(address, fragP->fr_offset, 1, TRUE,
	 fragP->tc_frag_data.is_no_density);
      break;
#endif
    default:
      as_fatal (_("expected align_code or RELAX_ALIGN_NEXT_OPCODE"));
    }
d9036 1
a9036 2
  return address + fill_size;
}
d9038 4
a9042 7
/* 3 mechanisms for relaxing an alignment: 
   
   Align to a power of 2. 
   Align so the next fragment's instruction does not cross a word boundary. 
   Align the current instruction so that if the next instruction 
       were 3 bytes, it would not cross a word boundary. 
   
d9045 6
a9050 6
   zeros    - This is easy; always insert zeros. 
   nops     - 3 and 2 byte instructions 
              2 - 2 byte nop 
              3 - 3 byte nop 
              4 - 2, 2-byte nops 
              >=5 : 3 byte instruction + fn(n-3) 
d9054 1
a9054 1
get_widen_aligned_address (fragP, address)
d9057 1
d9059 6
a9064 5
  addressT align_pow, new_address, loop_insn_offset;
  fragS *next_frag;
  int insn_size;
  xtensa_opcode opcode, next_opcode;
  static xtensa_insnbuf insnbuf = NULL;
d9066 15
a9080 2
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
d9082 30
a9111 76
  if (fragP->fr_type == rs_align || fragP->fr_type == rs_align_code)
    {
      align_pow = fragP->fr_offset;
      new_address = ((address + ((1 << align_pow) - 1))
		     << align_pow) >> align_pow;
      return new_address;
    }

  if (fragP->fr_type == rs_machine_dependent)
    {
      switch (fragP->fr_subtype)
	{
	case RELAX_DESIRE_ALIGN:

	  /* The rule is: get the next fragment's FIRST instruction. 
	     Find the smallest number of bytes needed to be added 
	     in order to ensure that the next fragment is FIRST 
	     instruction will fit in a single word. 
	     i.e.    2 bytes : 0, 1, 2.  mod 4 
	             3 bytes: 0, 1 mod 4 
	     If the FIRST instruction MIGHT be relaxed, 
	     assume that it will become a 3-byte instruction.  */

	  insn_size = 3;
	  /* Check to see if it might be 2 bytes.  */
	  next_opcode = next_frag_opcode (fragP);
	  if (next_opcode != XTENSA_UNDEFINED
	      && xtensa_insn_length (xtensa_default_isa, next_opcode) == 2)
	    insn_size = 2;

	  assert (insn_size <= 4);
	  for (new_address = address; new_address < address + 4; new_address++)
	    {
	      if (new_address >> 2 == (new_address + insn_size - 1) >> 2)
		return new_address;
	    }
	  as_bad (_("internal error aligning"));
	  return address;

	case RELAX_ALIGN_NEXT_OPCODE:
	  /* The rule is: get next fragment's FIRST instruction. 
	     Find the smallest number of bytes needed to be added 
	     in order to ensure that the next fragment's FIRST 
	     instruction will fit in a single word. 
	     i.e.    2 bytes : 0, 1, 2.  mod 4 
	             3 bytes: 0, 1 mod 4 
	     If the FIRST instruction MIGHT be relaxed, 
	     assume that it will become a 3 byte instruction.  */

	  opcode = next_frag_opcode (fragP);
	  if (opcode == XTENSA_UNDEFINED)
	    {
	      as_bad_where (fragP->fr_file, fragP->fr_line,
			    _("invalid opcode for RELAX_ALIGN_NEXT_OPCODE"));
	      as_fatal (_("cannot continue"));
	    }
	  insn_size = xtensa_insn_length (xtensa_default_isa, opcode);
	  assert (insn_size <= 4);
	  assert (is_loop_opcode (opcode));

	  loop_insn_offset = 0;
	  next_frag = next_non_empty_frag (fragP);

	  /* If the loop has been expanded then the loop
	     instruction could be at an offset from this fragment.  */
	  if (next_frag->fr_subtype != RELAX_IMMED)
	    loop_insn_offset = get_expanded_loop_offset (opcode);

	  for (new_address = address; new_address < address + 4; new_address++)
	    {
	      if ((new_address + loop_insn_offset + insn_size) >> 2 ==
		  (new_address + loop_insn_offset + insn_size + 2) >> 2)
		return new_address;
	    }
	  as_bad (_("internal error aligning"));
	  return address;
d9113 2
a9114 4
	default:
	  as_bad (_("internal error aligning"));
	  return address;
	}
d9116 2
a9117 2
  as_bad (_("internal error aligning"));
  return address;
d9132 1
d9137 3
d9150 2
a9151 1
      new_stretch = relax_frag_text_align (fragP, stretch);
d9161 1
d9165 1
a9165 2
      /* We REALLY want to change the relaxation order here.  This
         should do NOTHING.  The narrowing before it will either align
d9183 26
a9208 3
    case RELAX_NARROW:
      new_stretch = relax_frag_narrow (fragP, stretch);
      break;
d9210 5
a9214 7
    case RELAX_IMMED:
    case RELAX_IMMED_STEP1:
    case RELAX_IMMED_STEP2:
      /* Place the immediate.  */
      new_stretch = relax_frag_immed (now_seg, fragP, stretch,
				      fragP->fr_subtype - RELAX_IMMED,
				      stretched_p);
d9219 2
d9224 6
d9234 7
d9247 1
a9247 1
relax_frag_text_align (fragP, stretch)
d9255 3
a9257 7
  /* Overview of the relaxation procedure for alignment
     inside an executable section:
    
     The old size is stored in the tc_frag_data.text_expansion field.
    
     Calculate the new address, fix up the text_expansion and
     return the growth.  */
d9262 1
a9262 1
		      fragP->tc_frag_data.text_expansion);
d9274 1
a9274 1
  fragP->tc_frag_data.text_expansion += growth;
d9279 1
a9279 3
/* Add a NOP (i.e., "or a1, a1, a1").  Use the 3-byte one because we
   don't know about the availability of density yet.  TODO: When the
   flags are stored per fragment, use NOP.N when possible.  */
a9284 2
  static xtensa_insnbuf insnbuf = NULL;
  TInsn t_insn;
d9286 2
a9287 14
  int length;
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  tinsn_init (&t_insn);
  t_insn.opcode = xtensa_or_opcode;
  assert (t_insn.opcode != XTENSA_UNDEFINED);

  t_insn.ntok = 3;
  set_expr_const (&t_insn.tok[0], 1);
  set_expr_const (&t_insn.tok[1], 1);
  set_expr_const (&t_insn.tok[2], 1);

  tinsn_to_insnbuf (&t_insn, insnbuf);
a9288 1
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, nop_buf);
a9289 1
  length = xtensa_insn_length (xtensa_default_isa, t_insn.opcode);
d9292 1
a9292 3
      as_warn (_("fr_var (%ld) < length (%d); ignoring"),
	       fragP->fr_var, length);
      frag_wane (fragP);
a9297 1
  frag_wane (fragP);
d9303 1
a9303 1
relax_frag_narrow (fragP, stretch)
d9307 23
a9329 17
  /* Overview of the relaxation procedure for alignment inside an
     executable section: Find the number of widenings required and the
     number of nop bytes required. Store the number of bytes ALREADY
     widened. If there are enough instructions to widen (must go back
     ONLY through NARROW fragments), mark each of the fragments as TO BE
     widened, recalculate the fragment addresses.  */

  assert (fragP->fr_type == rs_machine_dependent
	  && fragP->fr_subtype == RELAX_NARROW);

  if (!future_alignment_required (fragP, 0))
    {
      /* If already expanded but no longer needed because of a prior
         stretch, it is SAFE to unexpand because the next fragment will
         NEVER start at an address > the previous time through the
         relaxation.  */
      if (fragP->tc_frag_data.text_expansion)
d9331 2
a9332 7
	  if (stretch > 0)
	    {
	      fragP->tc_frag_data.text_expansion = 0;
	      return -1;
	    }
	  /* Otherwise we have to live with this bad choice.  */
	  return 0;
d9337 2
a9338 5
  if (fragP->tc_frag_data.text_expansion == 0)
    {
      fragP->tc_frag_data.text_expansion = 1;
      return 1;
    }
d9340 1
a9340 1
  return 0;
d9344 22
a9365 4
static bfd_boolean
future_alignment_required (fragP, stretch)
     fragS *fragP;
     long stretch;
d9367 4
a9370 4
  long address = fragP->fr_address + stretch;
  int num_widens = 0;
  addressT aligned_address;
  offsetT desired_diff;
d9375 5
a9379 2
      if (num_widens > 8)
	return FALSE;
d9382 3
a9384 1
      switch (fragP->fr_type)
a9385 5
	case rs_fill:
	  address += fragP->fr_offset * fragP->fr_var;
	  break;

	case rs_machine_dependent:
d9388 18
a9405 3
	    case RELAX_NARROW:
	      /* address += fragP->fr_fix; */
	      num_widens++;
d9409 1
a9409 2
	      address += (/* fragP->fr_fix + */
			  fragP->tc_frag_data.text_expansion);
d9414 6
a9419 10
	      /* address += fragP->fr_fix; */
	      aligned_address = get_widen_aligned_address (fragP, address);
	      desired_diff = aligned_address - address;
	      assert (desired_diff >= 0);
	      /* If there are enough wideners in between do it.  */
	      /* return (num_widens == desired_diff); */
	      if (num_widens == desired_diff)
		return TRUE;
	      if (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
		return FALSE;
d9423 112
a9534 1
	      return FALSE;
d9536 88
a9623 1
	  break;
d9625 71
d9697 1
a9697 1
	  return FALSE;
a9698 1
      fragP = fragP->fr_next;
d9700 4
d9705 36
a9740 1
  return FALSE;
d9745 2
a9746 1
relax_frag_immed (segP, fragP, stretch, min_steps, stretched_p)
d9751 2
d9754 1
d9756 2
a9757 2
  static xtensa_insnbuf insnbuf = NULL;
  TInsn t_insn;
d9761 2
d9768 1
a9768 1
  int literal_diff, text_diff;
d9772 7
a9778 2
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
d9780 2
a9781 2
  tinsn_from_chars (&t_insn, fragP->fr_opcode);
  tinsn_immed_from_frag (&t_insn, fragP);
d9783 2
a9784 1
  negatable_branch = is_negatable_branch (&t_insn);
d9786 1
a9786 1
  old_size = xtensa_insn_length (xtensa_default_isa, t_insn.opcode);
d9788 1
a9788 2
  if (software_avoid_b_j_loop_end)
    branch_jmp_to_next = is_branch_jmp_to_next (&t_insn, fragP);
d9805 1
a9805 1
  num_steps = xg_assembly_relax (&istack, &t_insn, segP, fragP, frag_offset,
d9819 1
a9819 1
  fragP->fr_subtype = (int) RELAX_IMMED + num_steps;
a9822 1
  num_text_bytes = get_num_stack_text_bytes (&istack) - old_size;
d9824 14
a9837 2
  literal_diff = num_literal_bytes - fragP->tc_frag_data.literal_expansion;
  text_diff = num_text_bytes - fragP->tc_frag_data.text_expansion;
d9840 8
a9847 5
  know (num_text_bytes >= 0);
  know (literal_diff >= 0 && text_diff >= 0);

  fragP->tc_frag_data.text_expansion = num_text_bytes;
  fragP->tc_frag_data.literal_expansion = num_literal_bytes;
d9852 1
a9852 1
      lit_fragP = fragP->tc_frag_data.literal_frag;
d9870 7
a9876 8
  /* This implicitly uses the assumption that a branch is negated
     when the size of the output increases by at least 2 bytes.  */

  if (negatable_branch && num_text_bytes >= 2)
    {
      /* If next frag is a loop end, then switch it to add a NOP.  */
      update_next_frag_nop_state (fragP);
    }
d9878 1
a9878 1
  return text_diff;
d9890 5
d9916 44
a9959 3
    case RELAX_NARROW:
      /* No conversion.  */
      convert_frag_narrow (fragp);
d9962 2
a9963 5
    case RELAX_IMMED:
    case RELAX_IMMED_STEP1:
    case RELAX_IMMED_STEP2:
      /* Place the immediate.  */
      convert_frag_immed (sec, fragp, fragp->fr_subtype - RELAX_IMMED);
d10033 2
a10034 1
convert_frag_narrow (fragP)
d10036 2
d10039 16
a10054 4
  static xtensa_insnbuf insnbuf = NULL;
  TInsn t_insn, single_target;
  int size, old_size, diff, error_val;
  offsetT frag_offset;
d10056 1
a10056 1
  if (fragP->tc_frag_data.text_expansion == 0)
d10065 3
a10067 5
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  tinsn_from_chars (&t_insn, fragP->fr_opcode);
  tinsn_immed_from_frag (&t_insn, fragP);
d10071 1
a10071 1
  old_size = xtensa_insn_length (xtensa_default_isa, t_insn.opcode);
d10076 1
a10076 1
  error_val = xg_expand_narrow (&single_target, &t_insn);
d10078 7
a10084 1
    as_bad (_("unable to widen instruction"));
d10086 1
a10086 2
  size = xtensa_insn_length (xtensa_default_isa, single_target.opcode);
  xg_emit_insn_to_buf (&single_target, fragP->fr_opcode,
d10101 23
a10123 1
convert_frag_immed (segP, fragP, min_steps)
d10127 2
d10131 1
a10131 2
  static xtensa_insnbuf insnbuf = NULL;
  TInsn orig_t_insn;
d10133 1
d10135 7
a10141 2
  bfd_boolean branch_jmp_to_next = FALSE;
  int size;
d10143 1
a10143 1
  assert (fragP->fr_opcode != NULL);
d10145 3
a10147 2
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
d10149 2
a10150 2
  tinsn_from_chars (&orig_t_insn, fragP->fr_opcode);
  tinsn_immed_from_frag (&orig_t_insn, fragP);
d10152 1
a10152 3
  /* Here is the fun stuff:  Get the immediate field from this
     instruction.  If it fits, we're done.  If not, find the next
     instruction sequence that fits.  */
d10154 2
a10155 2
  if (software_avoid_b_j_loop_end)
    branch_jmp_to_next = is_branch_jmp_to_next (&orig_t_insn, fragP);
d10160 16
a10175 2
      size = xtensa_insn_length (xtensa_default_isa, orig_t_insn.opcode);
      assemble_nop (size, fragP->fr_opcode);
d10178 1
a10178 1
  else
d10180 4
d10188 1
d10193 2
d10196 1
a10196 1
      /* It does not fit.  Find something that does and 
d10198 1
a10198 1
      frag_offset = fragP->fr_opcode - fragP->fr_literal;
d10200 1
a10200 1
      xg_assembly_relax (&istack, &orig_t_insn,
d10203 1
a10203 1
      old_size = xtensa_insn_length (xtensa_default_isa, orig_t_insn.opcode);
d10208 1
a10208 1
      total_size = 0;
d10211 1
a10211 2
	  TInsn *t_insn = &istack.insn[i];
	  int size = 0;
d10214 1
a10214 1
	  switch (t_insn->insn_type)
d10220 1
a10220 1
	      lit_frag = fragP->tc_frag_data.literal_frag;
d10223 1
a10223 1
	      if (t_insn->ntok != 1)
d10231 16
d10249 2
a10250 2
				      fragP->fr_opcode - fragP->fr_literal +
				      total_size, fragP);
d10254 9
a10262 2
	      size = xtensa_insn_length (xtensa_default_isa, t_insn->opcode);
	      total_size += size;
d10268 2
d10272 1
a10272 1
	  TInsn *t_insn = &istack.insn[i];
d10276 1
d10278 1
a10278 1
	  switch (t_insn->insn_type)
d10281 2
a10282 2
	      lit_frag = fragP->tc_frag_data.literal_frag;
	      /* already checked */
d10285 2
a10286 2
	      assert (t_insn->ntok == 1);
	      /* add a fixup */
d10289 4
d10294 1
a10294 1
				  &t_insn->tok[0], FALSE, BFD_RELOC_32);
d10301 71
a10371 3
	      xg_resolve_labels (t_insn, gen_label);
	      xg_resolve_literals (t_insn, lit_sym);
	      size = xtensa_insn_length (xtensa_default_isa, t_insn->opcode);
a10372 3
	      xg_emit_insn_to_buf (t_insn, immed_instr, fragP,
				   immed_instr - fragP->fr_literal, TRUE);
	      immed_instr += size;
d10387 1
a10387 1
  fragP->fr_var = 0;
d10390 1
a10390 1
  if (is_loop_opcode (orig_t_insn.opcode))
d10393 1
a10393 1
      sym = orig_t_insn.tok[1].X_add_symbol;
d10399 1
a10399 1
      sym = orig_t_insn.tok[1].X_op_symbol;
d10407 2
a10408 2
  if (expanded && is_loop_opcode (orig_t_insn.opcode))
    convert_frag_immed_finish_loop (segP, fragP, &orig_t_insn);
d10410 1
a10410 1
  if (expanded && is_direct_call_opcode (orig_t_insn.opcode))
d10414 1
a10414 1
			  &orig_t_insn.tok[0], TRUE,
a10415 1

d10438 1
a10441 7
  if (r_type == BFD_RELOC_32
      && exp->X_add_symbol
      && symbol_get_tc (exp->X_add_symbol)->plt == 1)
    {
      r_type = BFD_RELOC_XTENSA_PLT;
    }

d10448 16
a10463 15
/* Relax a loop instruction so that it can span loop >256 bytes.  */
/* 
                  loop    as, .L1 
          .L0: 
                  rsr     as, LEND 
                  wsr     as, LBEG 
                  addi    as, as, lo8(label-.L1) 
                  addmi   as, as, mid8(label-.L1) 
                  wsr     as, LEND 
                  isync 
                  rsr     as, LCOUNT 
                  addi    as, as, 1 
          .L1: 
                  <<body>> 
          label:                                     */
d10466 1
a10466 1
convert_frag_immed_finish_loop (segP, fragP, t_insn)
d10469 1
a10469 1
     TInsn *t_insn;
d10481 2
d10488 1
a10488 3
  loop_offset = get_expanded_loop_offset (t_insn->opcode);
  /* Validate that there really is a LOOP at the loop_offset.  */
  tinsn_from_chars (&loop_insn, fragP->fr_opcode + loop_offset);
d10490 7
a10496 6
  if (!is_loop_opcode (loop_insn.opcode))
    {
      as_bad_where (fragP->fr_file, fragP->fr_line,
		    _("loop relaxation specification does not correspond"));
      assert (0);
    }
d10500 2
a10501 2
  assert (t_insn->ntok == 2);
  target = get_expression_value (segP, &t_insn->tok[1]);
d10517 1
a10517 1
  /* Because addmi sign-extends the immediate, 'loop_length_hi' can be at most 
d10523 1
a10523 1
  tinsn_from_chars (&addi_insn, fragP->fr_opcode + addi_offset);
d10526 1
a10526 1
  tinsn_from_chars (&addmi_insn, fragP->fr_opcode + addmi_offset);
d10531 1
a10531 1
  
d10533 1
a10533 1
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addi_offset);
d10537 17
a10553 1
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addmi_offset);
a10578 17
/* A map that keeps information on a per-subsegment basis.  This is
   maintained during initial assembly, but is invalid once the
   subsegments are smashed together.  I.E., it cannot be used during
   the relaxation.  */

typedef struct subseg_map_struct
{
  /* the key */
  segT seg;
  subsegT subseg;

  /* the data */
  unsigned flags;

  struct subseg_map_struct *next;
} subseg_map;

d10587 2
a10588 7
  subseg_map *subseg_e;

  for (subseg_e = sseg_map; subseg_e != NULL; subseg_e = subseg_e->next)
    if (seg == subseg_e->seg && subseg == subseg_e->subseg)
      return subseg_e->flags;

  return 0;
d10592 2
a10593 2
static void
set_last_insn_flags (seg, subseg, fl, val)
a10595 2
     unsigned fl;
     bfd_boolean val;
a10599 4
    if (seg == subseg_e->seg && subseg == subseg_e->subseg)
      break;

  if (!subseg_e)
d10601 2
a10602 7
      subseg_e = (subseg_map *) xmalloc (sizeof (subseg_map));
      memset (subseg_e, 0, sizeof (subseg_map));
      subseg_e->seg = seg;
      subseg_e->subseg = subseg;
      subseg_e->flags = 0;
      subseg_e->next = sseg_map;
      sseg_map = subseg_e;
d10604 14
d10619 8
d10734 1
d10737 1
d10739 1
a10739 1
      while (search_frag != frag_now) 
d10743 1
a10743 1
	  /* First, move the frag out of the literal section and 
d10749 1
a10749 1
	      /* Note that we set this fr_var to be a fix 
d10755 1
a10755 1
	  
d10760 1
a10760 1
	  
d10805 2
a10806 1
      S_SET_SEGMENT (lit_sym, dest_seg);
d10908 20
a10940 1
  
d10942 2
a10943 2
  if (pool_location == NULL 
      && !use_literal_section 
d10947 1
a10947 2
      as_warn (_("inlining literal pool; "
		 "specify location with .literal_position."));
d10961 1
a10961 1
			     &default_lit_sections.init_lit_seg);
d10969 1
a10969 1
			     &default_lit_sections.fini_lit_seg);
d10973 1
a10973 1
  else 
d10977 1
a10977 1
			     &default_lit_sections.lit_seg);
d10982 3
a10984 3
  if (!use_literal_section &&
      !is_init && !is_fini &&
      get_literal_pool_location (now_seg) != pool_location)
d10988 1
d10991 1
a10992 3

  /* Do a 4 byte align here.  */
  frag_align (2, 0, 0);
d11030 1
a11030 1
cache_literal_section (head, name, seg)
d11034 1
d11041 1
a11041 1
  *seg = retrieve_literal_seg (head, name);
d11050 1
a11050 1
retrieve_literal_seg (head, name)
d11053 1
a11056 2
  assert (head);

d11061 2
a11062 1
      add_seg_list (head, ret);
d11064 2
a11065 1
			     SEC_READONLY | SEC_ALLOC | SEC_LOAD | SEC_CODE);
d11106 134
a11239 2
  head->next = n;
}
d11241 2
a11242 2

/* Set up Property Tables after Relaxation.  */
d11244 7
a11250 2
#define XTENSA_INSN_SEC_NAME ".xt.insn"
#define XTENSA_LIT_SEC_NAME ".xt.lit"
d11252 3
a11254 6
void
xtensa_post_relax_hook ()
{
  xtensa_move_seg_list_to_beginning (literal_head);
  xtensa_move_seg_list_to_beginning (init_literal_head);
  xtensa_move_seg_list_to_beginning (fini_literal_head);
d11256 2
a11257 7
  xtensa_create_property_segments (get_frag_is_insn,
				   XTENSA_INSN_SEC_NAME,
				   xt_insn_sec);
  xtensa_create_property_segments (get_frag_is_literal,
				   XTENSA_LIT_SEC_NAME,
				   xt_literal_sec);
}
d11259 8
d11268 14
a11281 8
static bfd_boolean
get_frag_is_literal (fragP)
     const fragS *fragP;
{
  assert (fragP != NULL);
  return (fragP->tc_frag_data.is_literal);
}
 
d11283 8
a11290 6
static bfd_boolean
get_frag_is_insn (fragP)
     const fragS *fragP;
{
  assert (fragP != NULL);
  return (fragP->tc_frag_data.is_insn);
d11294 4
a11297 5
static void
xtensa_create_property_segments (property_function, section_name_base, 
				 sec_type)
     frag_predicate property_function;
     const char * section_name_base;
d11303 3
a11305 3
     Walk over each fragment
      For each fragment that has instructions
      Build an instruction record (append where possible).  */
d11312 9
a11320 1
      if (section_has_property (sec, property_function))
d11326 1
a11326 1
	  xtensa_block_info **xt_blocks = 
d11329 1
a11329 1
	  add_xt_block_frags (sec, insn_sec, xt_blocks, property_function);
d11342 1
d11350 1
a11350 1
	  size_t num_recs = 0;
d11356 1
a11356 1
	  rec_size = num_recs * 8;
d11359 5
a11363 4
	  /* In order to make this work with the assembler, we have to
	     build some frags and then build the "fixups" for it.  It
	     would be easier to just set the contents then set the
	     arlents.  */
d11367 1
a11367 1
	      /* Allocate a fragment and leak it.  */
d11372 1
a11372 1
	      size_t i;
d11384 1
a11384 1
	      /* the rest are zeros */
d11410 1
a11410 1
		  fix->fx_where = i * 8;
d11418 1
a11418 1
		  md_number_to_chars (&frag_data[4 + 8 * i],
d11420 3
d11526 22
d11551 2
a11552 1
add_xt_block_frags (sec, xt_block_sec, xt_block, property_function)
d11557 1
d11586 332
a11917 7
		  if ((*xt_block)->offset + (*xt_block)->size
		      == fragP->fr_address)
		    (*xt_block)->size += fragP->fr_fix;
		  else
		    xt_block = &((*xt_block)->next);
		}
	      if (*xt_block == NULL)
d11919 24
a11942 7
		  xtensa_block_info *new_block = (xtensa_block_info *)
		    xmalloc (sizeof (xtensa_block_info));
		  new_block->sec = sec;
		  new_block->offset = fragP->fr_address;
		  new_block->size = fragP->fr_fix;
		  new_block->next = NULL;
		  *xt_block = new_block;
d11945 2
d11949 30
d12010 1
a12010 1
   It is an error to call this if istack_empty () is true. */
d12023 1
a12023 1
   It is an error to call this if istack_full () is true.  */
d12032 1
a12032 1
  tinsn_copy (&stack->insn[rec], insn);
d12038 1
a12038 1
   to it.  It is an error to call this if istack_full () is true.  */
d12055 1
a12055 1
   istack_empty () returns true.  */
a12077 10
void
tinsn_copy (dst, src)
     TInsn *dst;
     const TInsn *src;
{
  tinsn_init (dst);
  memcpy (dst, src, sizeof (TInsn));
}


d12091 1
a12091 1
/* Return true if ANY of the operands in the insn are symbolic.  */
d12121 1
d12134 7
d12142 16
a12157 5
	  if (i == get_relaxable_immed (insn->opcode))
	    break;
	  as_bad (_("invalid symbolic operand %d on '%s'"),
		  i, xtensa_opcode_name (xtensa_default_isa, insn->opcode));
	  return TRUE;
d12184 2
d12195 2
a12196 2
/* Convert the constant operands in the t_insn to insnbuf.
   Return true if there is a symbol in the immediate field.
d12198 1
a12198 1
   Before this is called, 
d12200 1
a12200 1
   2) the t_insn is a ITYPE_INSN
d12206 2
a12207 2
tinsn_to_insnbuf (t_insn, insnbuf)
     TInsn *t_insn;
d12210 1
d12212 2
a12213 1
  xtensa_opcode opcode = t_insn->opcode;
d12215 1
a12215 1
  int noperands = xtensa_num_operands (isa, opcode);
d12221 5
a12225 2
  assert (t_insn->insn_type == ITYPE_INSN);
  if (noperands != t_insn->ntok)
d12228 2
a12229 1
  xtensa_encode_insn (isa, opcode, insnbuf);
d12233 1
a12233 2
      expressionS *expr = &t_insn->tok[i];
      xtensa_operand operand = xtensa_get_operand (isa, opcode, i);
d12237 3
a12239 1
	  /* The register number has already been checked in  
d12242 3
a12244 2
	  (void) xtensa_operand_encode (operand, &opnd_value);
	  xtensa_operand_set_field (operand, insnbuf, opnd_value);
d12248 2
d12253 86
a12338 1
	  xtensa_insnbuf_set_operand (insnbuf, opcode, operand,
a12341 1
	case O_symbol:
d12347 1
d12352 1
a12352 1
/* Check the instruction arguments.  Return true on failure.  */
d12367 1
a12367 1
  if (xtensa_num_operands (isa, opcode) > insn->ntok)
d12373 1
a12373 1
  if (xtensa_num_operands (isa, opcode) < insn->ntok)
d12385 2
a12386 2
tinsn_from_chars (t_insn, f)
     TInsn *t_insn;
d12388 18
a12406 1
  static xtensa_insnbuf insnbuf = NULL;
a12407 1
  xtensa_opcode opcode;
a12409 6
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  xtensa_insnbuf_from_chars (isa, insnbuf, f);
  opcode = xtensa_decode_insn (isa, insnbuf);

d12411 10
a12420 9
  tinsn_init (t_insn);
  t_insn->insn_type = ITYPE_INSN;
  t_insn->is_specific_opcode = FALSE;	/* Must not be specific.  */
  t_insn->opcode = opcode;
  t_insn->ntok = xtensa_num_operands (isa, opcode);
  for (i = 0; i < t_insn->ntok; i++)
    {
      set_expr_const (&t_insn->tok[i],
		      xtensa_insnbuf_get_operand (insnbuf, opcode, i));
d12428 2
a12429 2
tinsn_immed_from_frag (t_insn, fragP)
     TInsn *t_insn;
d12431 1
d12433 1
a12433 1
  xtensa_opcode opcode = t_insn->opcode;
d12436 1
a12436 1
  if (fragP->fr_symbol)
d12439 16
a12454 2
      set_expr_symbol_offset (&t_insn->tok[opnum],
			      fragP->fr_symbol, fragP->fr_offset);
d12468 3
a12470 3
      TInsn *t_insn = &istack->insn[i];
      if (t_insn->insn_type == ITYPE_INSN)
	text_bytes += xg_get_insn_size (t_insn);
d12485 2
a12486 3
      TInsn *t_insn = &istack->insn[i];

      if (t_insn->insn_type == ITYPE_LITERAL && t_insn->ntok == 1)
d12493 217
d12712 1
a12712 1
/* Return true if the expression is an integer constant.  */
d12723 1
a12723 1
   Calling this is illegal if expr_is_const () returns true.  */
d12748 20
d12783 18
d12841 1
a12841 1
/* Parse the string oldname=new_name:oldname2=new_name2 
d12919 4
a12922 2
    if (strcmp (r->old_name, name) == 0)
      return r->new_name;
@


1.9
log
@bfd/ChangeLog:
	* elf32-xtensa.c (elf_xtensa_check_relocs): Remove code to read
	literal tables and check for relocs outside of literal pools.
	(elf_xtensa_make_sym_local): Don't clear ELF_LINK_NON_GOT_REF flag.
	(elf_xtensa_fix_refcounts): Don't check ELF_LINK_NON_GOT_REF or
	set DF_TEXTREL.
	(elf_xtensa_size_dynamic_sections): Don't add DT_TEXTREL entry.
	(elf_xtensa_relocate_section): Read literal tables and check for
	dynamic relocations in read-only sections and not in literal pools.
gas/ChangeLog:
	* config/tc-xtensa.c (xtensa_post_relax_hook): Create literal
	tables even when use_literal_section flag is not set.
@
text
@d3724 1
a3724 1
  assert (insn->ntok = 1);	/* must be only one token here */
@


1.8
log
@	* config/tc-xtensa.c (mark_literal_frags): New function.
	(xtensa_move_literals): Call mark_literal_frags for all literal
	segments, including init and fini literal segments.
	(xtensa_post_relax_hook): Swap use of xt_insn_sec and xt_literal_sec.
@
text
@d7891 3
a7893 4
  if (use_literal_section)
    xtensa_create_property_segments (get_frag_is_literal,
				     XTENSA_LIT_SEC_NAME,
				     xt_literal_sec);
@


1.7
log
@	* config/tc-xtensa.c (xg_emit_insn): Include "dwarf2dbg.h" and add
	call to dwarf2_emit_insn.
@
text
@d641 2
d7490 3
a7492 15
  /* As clunky as this is, we can't rely on frag_var
     and frag_variant to get called in all situations.  */

  segment = literal_head->next;
  while (segment)
    {
      frchain_from = seg_info (segment->seg)->frchainP;
      search_frag = frchain_from->frch_root;
      while (search_frag) 
	{
	  search_frag->tc_frag_data.is_literal = TRUE;
	  search_frag = search_frag->fr_next;
	}
      segment = segment->next;
    }
d7596 25
d7890 1
a7890 1
				   xt_literal_sec);
d7894 1
a7894 1
				     xt_insn_sec);
@


1.7.6.1
log
@	* config/tc-xtensa.c (mark_literal_frags): New function.
	(xtensa_move_literals): Call mark_literal_frags for all literal
	segments, including init and fini literal segments.
	(xtensa_post_relax_hook): Swap use of xt_insn_sec and xt_literal_sec.
@
text
@a640 2
static void mark_literal_frags
  PARAMS ((seg_list *));
d7488 15
a7502 3
  mark_literal_frags (literal_head->next);
  mark_literal_frags (init_literal_head->next);
  mark_literal_frags (fini_literal_head->next);
a7605 25
/* Walk over all the frags for segments in a list and mark them as
   containing literals.  As clunky as this is, we can't rely on frag_var
   and frag_variant to get called in all situations.  */

static void
mark_literal_frags (segment)
     seg_list *segment;
{
  frchainS *frchain_from;
  fragS *search_frag;

  while (segment)
    {
      frchain_from = seg_info (segment->seg)->frchainP;
      search_frag = frchain_from->frch_root;
      while (search_frag) 
	{
	  search_frag->tc_frag_data.is_literal = TRUE;
	  search_frag = search_frag->fr_next;
	}
      segment = segment->next;
    }
}


d7875 1
a7875 1
				   xt_insn_sec);
d7879 1
a7879 1
				     xt_literal_sec);
@


1.7.6.2
log
@bfd/ChangeLog:
	* elf32-xtensa.c (elf_xtensa_check_relocs): Remove code to read
	literal tables and check for relocs outside of literal pools.
	(elf_xtensa_make_sym_local): Don't clear ELF_LINK_NON_GOT_REF flag.
	(elf_xtensa_fix_refcounts): Don't check ELF_LINK_NON_GOT_REF or
	set DF_TEXTREL.
	(elf_xtensa_size_dynamic_sections): Don't add DT_TEXTREL entry.
	(elf_xtensa_relocate_section): Read literal tables and check for
	dynamic relocations in read-only sections and not in literal pools.
gas/ChangeLog:
	* config/tc-xtensa.c (xtensa_post_relax_hook): Create literal
	tables even when use_literal_section flag is not set.
@
text
@d7891 4
a7894 3
  xtensa_create_property_segments (get_frag_is_literal,
				   XTENSA_LIT_SEC_NAME,
				   xt_literal_sec);
@


1.6
log
@bfd ChangeLog:

2003-10-14  Bob Wilson  <bob.wilson@@acm.org>

	* elf32-xtensa.c (get_is_linkonce_section): Delete.
	(xtensa_is_property_section, xtensa_is_littable_section): Use
	XTENSA_INSN_SEC_NAME and XTENSA_LIT_SEC_NAME macros.  Do not recognize
	linkonce sections containing ".xt.insn" and ".xt.lit" substrings.
	(xtensa_get_property_section_name): Check section name instead of
	calling get_is_linkonce_section.  Remove unused bfd parameter.  Use
	XTENSA_INSN_SEC_NAME and XTENSA_LIT_SEC_NAME macros.  Never generate
	linkonce section names by appending ".xt.insn" or ".xt.lit".
	(xtensa_read_table_entries): Remove bfd argument in call to
	xtensa_get_property_section_name.  Free section name when done.
	(elf_xtensa_combine_prop_entries): Free leaking table.

gas ChangeLog:

2003-10-14  Bob Wilson  <bob.wilson@@acm.org>

	* config/tc-xtensa.c (xtensa_create_property_segments): Remove bfd
	argument in call to xtensa_get_property_section_name.  Formatting.

include ChangeLog:

2003-10-14  Bob Wilson  <bob.wilson@@acm.org>

	* elf/xtensa.h: Formatting.  Fix comments about property section
	names for linkonce sections.
@
text
@d30 1
d3932 2
@


1.5
log
@	* config/tc-xtensa.c (insn_labels, free_insn_labels, saved_insn_labels,
	literal_syms): New global variables.
	(xtensa_define_label, add_target_symbol, xtensa_find_label,
	map_over_defined_symbols, is_loop_target_label,
	xtensa_mark_target_fragments, xtensa_move_frag_symbol,
	xtensa_move_frag_symbols, defined_symbols, branch_targets): Delete.
	(xtensa_begin_directive): Call md_flush_pending_output.  Move symbols
	from insn_labels to saved_insn_labels when entering a literal region.
	(xtensa_end_directive): Call md_flush_pending_output.  Restore
	insn_labels list when leaving a literal region.
	(xtensa_literal_position): Call xtensa_clear_insn_labels.
	(xtensa_literal_pseudo): Add check to disallow .literal inside a
	literal region.  Move insn_labels to saved_insn_labels and then restore
	insn_labels on exit.
	(xg_add_branch_and_loop_targets): Replace add_target_symbol calls with
	code to set is_loop_target or is_branch_target flag on the symbol
	(xtensa_create_literal_symbol): Call xtensa_add_literal_sym.
	(xtensa_add_literal_sym, xtensa_add_insn_label,
	xtensa_clear_insn_labels): New functions.
	(xtensa_move_labels): Remove old_frag and old_offset arguments.  Add
	loops_ok argument.  Rewrite to use insn_labels list instead of
	calling xtensa_find_label and to check the is_loop_target flag on
	symbols when loops_ok is false.
	(xtensa_frob_label): Remove call to xtensa_define_label.  Add call
	to either xtensa_add_literal_sym or xtensa_add_insn_label.  Adjust
	call to xtensa_move_labels.  Propagate is_branch_target and
	is_loop_target flags from symbols to frags.
	(xtensa_flush_pending_output): Call xtensa_clear_insn_labels.
	(md_assemble): Use xtensa_move_labels with loops_ok = FALSE when
	aligning a loop instruction.  Adjust call to xtensa_move_labels for
	aligning entry instructions.  Add call to xtensa_clear_insn_labels.
	(xtensa_end): Remove call to xtensa_mark_target_fragments.
	(xtensa_move_literals): Replace xtensa_move_frag_symbols call with
	code to use new literal_syms list.
	* config/tc-xtensa.h (xtensa_symfield_type): Add is_loop_target and
	is_branch_target flags.
@
text
@d680 1
a680 1
  PARAMS ((bfd *, asection *, const char *));
d7919 2
a7920 3
	  char * property_section_name =
	    xtensa_get_property_section_name (stdoutput, sec,
					      section_name_base);
d7923 1
a7923 1
	  xtensa_block_info ** xt_blocks = 
@


1.4
log
@	* config/tc-xtensa.c (xtensa_mark_literal_pool_location): Remove
	"move_labels" argument and corresponding call to xtensa_move_labels.
	(md_assemble): Add a separate call to xtensa_move_labels and remove
	argument for call to xtensa_mark_literal_pool_location.
	(xtensa_literal_position, xtensa_switch_to_literal_fragment): Fix
	calls to xtensa_mark_literal_pool_location.
	(xtensa_create_local_symbol): Delete and inline the code into...
	(xtensa_create_literal_symbol): ...here.
	(xtensa_frob_label): Combine conditionals.
	(expression_maybe_register, xtensa_symbol_new_hook,
	fix_new_exp_in_seg): Use symbol_get_tc.
@
text
@d136 19
a418 14
/* Functions for Internal Lists of Symbols.  */
static void xtensa_define_label
  PARAMS ((symbolS *));
static void add_target_symbol
  PARAMS ((symbolS *, bfd_boolean));
static symbolS *xtensa_find_label
  PARAMS ((fragS *, offsetT, bfd_boolean));
static void map_over_defined_symbols
  PARAMS ((void (*fn) (symbolS *)));
static bfd_boolean is_loop_target_label
  PARAMS ((symbolS *));
static void xtensa_mark_target_fragments
  PARAMS ((void));

d485 6
d528 1
a528 1
  PARAMS ((fragS *, valueT, fragS *, valueT));
a639 4
static void xtensa_move_frag_symbol
  PARAMS ((symbolS *));
static void xtensa_move_frag_symbols
  PARAMS ((void));
d1278 2
d1290 7
d1369 2
d1404 6
d1449 1
d1465 12
d1527 4
a2518 161
/* Lists for recording various properties of symbols.  */

typedef struct symbol_consS_struct
{
  symbolS *first;
  /* These are used for the target taken.  */
  int is_loop_target:1;
  int is_branch_target:1;
  int is_literal:1;
  int is_moved:1;
  struct symbol_consS_struct *rest;
} symbol_consS;

symbol_consS *defined_symbols = 0;
symbol_consS *branch_targets = 0;


static void
xtensa_define_label (sym)
     symbolS *sym;
{
  symbol_consS *cons = (symbol_consS *) xmalloc (sizeof (symbol_consS));

  cons->first = sym;
  cons->is_branch_target = 0;
  cons->is_loop_target = 0;
  cons->is_literal = generating_literals ? 1 : 0;
  cons->is_moved = 0;
  cons->rest = defined_symbols;
  defined_symbols = cons;
}


void
add_target_symbol (sym, is_loop)
     symbolS *sym;
     bfd_boolean is_loop;
{
  symbol_consS *cons, *sym_e;

  for (sym_e = branch_targets; sym_e; sym_e = sym_e->rest)
    {
      if (sym_e->first == sym)
	{
	  if (is_loop)
	    sym_e->is_loop_target = 1;
	  else
	    sym_e->is_branch_target = 1;
	  return;
	}
    }

  cons = (symbol_consS *) xmalloc (sizeof (symbol_consS));
  cons->first = sym;
  cons->is_branch_target = (is_loop ? 0 : 1);
  cons->is_loop_target = (is_loop ? 1 : 0);
  cons->rest = branch_targets;
  branch_targets = cons;
}


/* Find the symbol at a given position.  (Note: the "loops_ok"
   argument is provided to allow ignoring labels that define loop
   ends.  This fixes a bug where the NOPs to align a loop opcode were
   included in a previous zero-cost loop:

   loop a0, loopend
     <loop1 body>
   loopend:

   loop a2, loopend2
     <loop2 body>
             
   would become:

   loop a0, loopend
     <loop1 body>
     nop.n <===== bad!
   loopend:

   loop a2, loopend2
     <loop2 body>

   This argument is used to prevent moving the NOP to before the
   loop-end label, which is what you want in this special case.)  */

static symbolS *
xtensa_find_label (fragP, offset, loops_ok)
     fragS *fragP;
     offsetT offset;
     bfd_boolean loops_ok;
{
  symbol_consS *consP;

  for (consP = defined_symbols; consP; consP = consP->rest)
    {
      symbolS *symP = consP->first;

      if (S_GET_SEGMENT (symP) == now_seg
	  && symbol_get_frag (symP) == fragP
	  && symbol_constant_p (symP)
	  && S_GET_VALUE (symP) == fragP->fr_address + (unsigned) offset
	  && (loops_ok || !is_loop_target_label (symP)))
	return symP;
    }
  return NULL;
}


static void
map_over_defined_symbols (fn)
     void (*fn) PARAMS ((symbolS *));
{
  symbol_consS *sym_cons;

  for (sym_cons = defined_symbols; sym_cons; sym_cons = sym_cons->rest)
    fn (sym_cons->first);
}


static bfd_boolean
is_loop_target_label (sym)
     symbolS *sym;
{
  symbol_consS *sym_e;

  for (sym_e = branch_targets; sym_e; sym_e = sym_e->rest)
    {
      if (sym_e->first == sym)
        return sym_e->is_loop_target;
    }
  return FALSE;
} 


/* Walk over all of the symbols that are branch target labels and
   loop target labels.  Mark the associated fragments for these with
   the appropriate flags.  */

static void
xtensa_mark_target_fragments ()
{
  symbol_consS *sym_e;

  for (sym_e = branch_targets; sym_e; sym_e = sym_e->rest)
    {
      symbolS *sym = sym_e->first;

      if (symbol_get_frag (sym)
	  && symbol_constant_p (sym)
	  && S_GET_VALUE (sym) == 0)
	{
	  if (sym_e->is_branch_target)
	    symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;
	  if (sym_e->is_loop_target)
	    symbol_get_frag (sym)->tc_frag_data.is_loop_target = TRUE;
	}
    }
}


d3397 1
a3397 1
	  add_target_symbol (insn->tok[i].X_add_symbol, TRUE);
d3415 6
a3420 1
	    add_target_symbol (insn->tok[i].X_add_symbol, FALSE);
d3801 2
d3809 45
d4527 24
d4552 2
a4553 4
xtensa_move_labels (old_frag, old_offset, new_frag, new_offset)
     fragS *old_frag;
     valueT old_offset;
     fragS *new_frag ATTRIBUTE_UNUSED;
d4555 1
d4557 1
a4557 1
  symbolS *old_sym;
d4559 1
a4559 4
  /* Repeat until there are no more.... */
  for (old_sym = xtensa_find_label (old_frag, old_offset, TRUE);
       old_sym;
       old_sym = xtensa_find_label (old_frag, old_offset, TRUE))
d4561 6
a4566 2
      S_SET_VALUE (old_sym, (valueT) new_offset);
      symbol_set_frag (old_sym, frag_now);
d4749 6
a4754 2
  xtensa_define_label (sym);
  if (is_loop_target_label (sym) 
a4764 2
      fragS *old_frag = frag_now;
      offsetT old_offset = frag_now_fix ();
d4769 11
a4779 3
      xtensa_move_labels (old_frag, old_offset, frag_now, 0);
      /* Once we know whether or not the label is a branch target
         We will suppress some of these alignments.  */
d4796 2
a4922 3
      fragS *old_frag = frag_now;
      offsetT old_offset = frag_now_fix ();
      symbolS *old_sym = NULL;
d4934 1
a4934 6
      /* Repeat until there are no more.  */
      while ((old_sym = xtensa_find_label (old_frag, old_offset, FALSE)))
	{
	  S_SET_VALUE (old_sym, (valueT) 0);
	  symbol_set_frag (old_sym, frag_now);
	}
a4957 3
	  fragS *label_target = frag_now;
	  offsetT label_offset = frag_now_fix ();

d4961 1
a4961 1
	  xtensa_move_labels (label_target, label_offset, frag_now, 0);
d4966 4
a5377 1
  xtensa_mark_target_fragments ();
d7483 1
d7593 7
a7599 29
  xtensa_move_frag_symbols ();
}


static void
xtensa_move_frag_symbol (sym)
     symbolS *sym;
{
  fragS *frag = symbol_get_frag (sym);	

  if (frag->tc_frag_data.lit_seg != (segT) 0)
    S_SET_SEGMENT (sym, frag->tc_frag_data.lit_seg);
}


static void
xtensa_move_frag_symbols ()
{
  symbolS *symbolP;

  /* Although you might think that only one of these lists should be
     searched, it turns out that the difference of the two sets
     (either way) is not empty.  They do overlap quite a bit,
     however.  */

  for (symbolP = symbol_rootP; symbolP; symbolP = symbolP->sy_next)
    xtensa_move_frag_symbol (symbolP);

  map_over_defined_symbols (xtensa_move_frag_symbol);
@


1.3
log
@	* config/tc-xtensa.c (xtensa_literal_pseudo): Remove code for
	combining identical literals.
	(expression_maybe_register): Remove call to find_lit_sym_translation.
	(is_duplicate_expression, cache_literal, is_duplicate_literal,
	add_lit_sym_translation, find_lit_sym_translation): Delete.
@
text
@a479 2
static symbolS *xtensa_create_local_symbol
  PARAMS ((bfd *, const char *, segT, valueT, fragS *));
d515 1
a515 1
  PARAMS ((bfd_boolean));
d1422 1
a1422 1
    xtensa_mark_literal_pool_location (FALSE);
d1649 1
a1649 1
	  tok->X_add_symbol->sy_tc.plt = 1;
d3900 1
a3900 1
  symbolS *fragSym;
a3902 21
  fragSym = xtensa_create_local_symbol (stdoutput, name, sec, 0, frag_now);

  frag->tc_frag_data.is_literal = TRUE;
  lit_num++;
  return fragSym;
}


/* Create a local symbol.  If it is in a linkonce section, we have to
   be careful to make sure that if it is used in a relocation that the
   symbol will be in the output file.  */

symbolS *
xtensa_create_local_symbol (abfd, name, sec, value, frag)
     bfd *abfd;
     const char *name;
     segT sec;
     valueT value;
     fragS *frag;
{
  symbolS *symbolP;
d3904 4
a3907 1
  if (get_is_linkonce_section (abfd, sec))
d3909 1
a3909 1
      symbolP = symbol_new (name, sec, value, frag);
d3914 1
a3914 1
    symbolP = symbol_new (name, sec, value, frag);
d3916 2
d4564 1
a4564 2
xtensa_mark_literal_pool_location (move_labels)
     bfd_boolean move_labels;
a4568 1
  fragS *label_target = frag_now;
a4569 1
  offsetT label_offset = frag_now_fix ();
a4591 2
  if (move_labels)
    xtensa_move_labels (label_target, label_offset, frag_now, 0);
d4800 4
a4803 2
  if (now_seg != absolute_section && align_targets
      && !is_unaligned_label (sym))
a4806 2
      if (frag_now->tc_frag_data.is_literal)
	return;
d4977 1
a4977 1
  /* Special count for "entry" instruction.  */
a4994 1
    }
d4996 6
a5001 3
  if (!orig_insn.is_specific_opcode && is_entry_opcode (orig_insn.opcode))
    {
      xtensa_mark_literal_pool_location (TRUE);
d5003 4
a5006 2
      /* Automatically align ENTRY instructions.  */
      frag_align (2, 0, 0);
d5206 1
a5206 1
  symbolP->sy_tc.plt = 0;
d7267 1
a7267 1
      && exp->X_add_symbol->sy_tc.plt == 1)
d7759 1
a7759 1
      xtensa_mark_literal_pool_location (FALSE);
@


1.2
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@a717 7
#ifdef XTENSA_COMBINE_LITERALS
static void find_lit_sym_translation
  PARAMS ((expressionS *));
static void add_lit_sym_translation
  PARAMS ((char *, offsetT, symbolS *));
#endif

d1437 1
a1437 7
  char *base_name;
#ifdef XTENSA_COMBINE_LITERALS
  char *next_name;
  symbolS *duplicate;
  bfd_boolean used_name = FALSE;
  int offset = 0;
#endif
a1438 1
  char *p;
a1473 13
#ifdef XTENSA_COMBINE_LITERALS
  /* We need next name to start out equal to base_name,
     but we modify it later to refer to a symbol and an offset.  */
  next_name = xmalloc (strlen (base_name) + 1);
  strcpy (next_name, base_name);

  /* We need a copy of base_name because we refer to it in the 
     lit_sym_translations and the source is somewhere in the input stream.  */
  base_name = xmalloc (strlen (base_name) + 1);
  strcpy (base_name, next_name);

#else

a1474 1
#endif
a1481 11
#ifdef XTENSA_COMBINE_LITERALS
      duplicate = is_duplicate_literal (&expP, dest_seg);
      if (duplicate)
	{
	  add_lit_sym_translation (base_name, offset, duplicate);
	  used_name = TRUE;
	  continue;
	}
      colon (next_name);
#endif

a1483 14

#ifdef XTENSA_COMBINE_LITERALS
      cache_literal (next_name, &expP, dest_seg);
      free (next_name);

      if (*input_line_pointer == ',') 
	{
	  offset += 4;
	  next_name = xmalloc (strlen (base_name) + 
			       strlen (XTENSA_LIT_PLUS_OFFSET) + 10);
	  sprintf (next_name, "%s%s%d", 
		   XTENSA_LIT_PLUS_OFFSET, base_name, offset);
	}
#endif
a1487 4
#ifdef XTENSA_COMBINE_LITERALS
  if (!used_name)
    free (base_name);
#endif
a1653 3
#ifdef XTENSA_COMBINE_LITERALS
      find_lit_sym_translation (tok);
#endif
a8814 135


/* Combining identical literals.  */

#ifdef XTENSA_COMBINE_LITERALS 

/* This code records all the .literal values that are ever seen and
   detects duplicates so that identical values can be combined.  This
   is currently disabled because it's only half-baked.  */

#define XTENSA_LIT_PLUS_OFFSET ".xtensa_litsym_offset_"

/* TODO: make this into a more efficient data structure.  */
typedef struct literal_list_elem
{
  symbolS *sym;			/* The symbol that points to this literal.  */
  expressionS expr;		/* The expression.  */
  segT seg;
  struct literal_list_elem *next; /* Next in the list.  */
} literal_list_elem;

literal_list_elem *lit_cache = NULL;

typedef struct lit_sym_translation
{
  char *name;			/* This name.  */
  offsetT offset;		/* Plus this offset.  */
  symbolS *sym;			/* Should really mean this symbol.  */
  struct lit_sym_translation *next;
} lit_sym_translation;

lit_sym_translation *translations = NULL;

static bfd_boolean is_duplicate_expression
  PARAMS ((expressionS *, expressionS *));
static void cache_literal
  PARAMS ((char *sym_name, expressionS *, segT));
static symbolS *is_duplicate_literal
  PARAMS ((expressionS *, segT));


static bfd_boolean
is_duplicate_expression (e1, e2)
     expressionS *e1;
     expressionS *e2;
{
  if (e1->X_op != e2->X_op)
    return FALSE;
  if (e1->X_add_symbol != e2->X_add_symbol)
    return FALSE;
  if (e1->X_op_symbol != e2->X_op_symbol)
    return FALSE;
  if (e1->X_add_number != e2->X_add_number)
    return FALSE;
  if (e1->X_unsigned != e2->X_unsigned)
    return FALSE;
  if (e1->X_md != e2->X_md)
    return FALSE;
  return TRUE;
}


static void
cache_literal (sym_name, expP, seg)
     char *sym_name;
     expressionS *expP;
     segT seg;
{
  literal_list_elem *lit = xmalloc (sizeof (literal_list_elem));

  lit->sym = symbol_find (sym_name);
  lit->expr = *expP;
  lit->seg = seg;
  lit->next = lit_cache;
  lit_cache = lit;
}

 
static symbolS *
is_duplicate_literal (expr, seg)
     expressionS *expr;
     segT seg;
{
  literal_list_elem *lit = lit_cache;

  while (lit != NULL) 
    {
      if (is_duplicate_expression (&lit->expr, expr) && seg == lit->seg)
	return lit->sym;
      lit = lit->next;
    }

  return NULL;
}


static void
add_lit_sym_translation (name, offset, target)
     char * name;
     offsetT offset;
     symbolS * target;
{
  lit_sym_translation *lit_trans = xmalloc (sizeof (lit_sym_translation));

  lit_trans->name = name;
  lit_trans->offset = offset;
  lit_trans->sym = target;
  lit_trans->next = translations;
  translations = lit_trans;
}


static void
find_lit_sym_translation (expr)
     expressionS *expr;
{
  lit_sym_translation *lit_trans = translations;

  if (expr->X_op != O_symbol)
    return;

  while (lit_trans != NULL)
    {
      if (lit_trans->offset == expr->X_add_number 
	  && strcmp (lit_trans->name, S_GET_NAME (expr->X_add_symbol)) == 0)
	{
	  expr->X_add_symbol = lit_trans->sym;
	  expr->X_add_number = 0;
	  return;
	}
      lit_trans = lit_trans->next;
    }
}

#endif /* XTENSA_COMBINE_LITERALS */
@


1.1
log
@Add Xtensa port
@
text
@a29 1
#include "dwarf2dbg.h"
a1116 2
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
a4076 2

  /* dwarf2_emit_insn (byte_count); */
@

