head	1.64;
access;
symbols
	binutils-2_24-branch:1.64.0.2
	binutils-2_24-branchpoint:1.64
	binutils-2_21_1:1.59
	binutils-2_23_2:1.60.2.3
	binutils-2_23_1:1.60.2.3
	binutils-2_23:1.60.2.2
	binutils-2_23-branch:1.60.0.2
	binutils-2_23-branchpoint:1.60
	binutils-2_22_branch:1.59.0.6
	binutils-2_22:1.59
	binutils-2_22-branch:1.59.0.4
	binutils-2_22-branchpoint:1.59
	binutils-2_21:1.59
	binutils-2_21-branch:1.59.0.2
	binutils-2_21-branchpoint:1.59
	binutils-2_20_1:1.56
	binutils-2_20:1.56
	binutils-arc-20081103-branch:1.54.0.6
	binutils-arc-20081103-branchpoint:1.54
	binutils-2_20-branch:1.56.0.2
	binutils-2_20-branchpoint:1.56
	dje-cgen-play1-branch:1.55.0.2
	dje-cgen-play1-branchpoint:1.55
	arc-20081103-branch:1.54.0.4
	arc-20081103-branchpoint:1.54
	binutils-2_19_1:1.54
	binutils-2_19:1.54
	binutils-2_19-branch:1.54.0.2
	binutils-2_19-branchpoint:1.54
	binutils-2_18:1.52
	binutils-2_18-branch:1.52.0.2
	binutils-2_18-branchpoint:1.52
	binutils-csl-coldfire-4_1-32:1.48
	binutils-csl-sourcerygxx-4_1-32:1.48
	binutils-csl-innovasic-fido-3_4_4-33:1.48
	binutils-csl-sourcerygxx-3_4_4-32:1.46
	binutils-csl-coldfire-4_1-30:1.48
	binutils-csl-sourcerygxx-4_1-30:1.48
	binutils-csl-coldfire-4_1-28:1.48
	binutils-csl-sourcerygxx-4_1-29:1.48
	binutils-csl-sourcerygxx-4_1-28:1.48
	binutils-csl-arm-2006q3-27:1.48
	binutils-csl-sourcerygxx-4_1-27:1.48
	binutils-csl-arm-2006q3-26:1.48
	binutils-csl-sourcerygxx-4_1-26:1.48
	binutils-csl-sourcerygxx-4_1-25:1.48
	binutils-csl-sourcerygxx-4_1-24:1.48
	binutils-csl-sourcerygxx-4_1-23:1.48
	binutils-csl-sourcerygxx-4_1-21:1.48
	binutils-csl-arm-2006q3-21:1.48
	binutils-csl-sourcerygxx-4_1-22:1.48
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.48
	binutils-csl-sourcerygxx-4_1-20:1.48
	binutils-csl-arm-2006q3-19:1.48
	binutils-csl-sourcerygxx-4_1-19:1.48
	binutils-csl-sourcerygxx-4_1-18:1.48
	binutils-csl-renesas-4_1-9:1.48
	binutils-csl-sourcerygxx-3_4_4-25:1.46
	binutils-csl-renesas-4_1-8:1.48
	binutils-csl-renesas-4_1-7:1.48
	binutils-csl-renesas-4_1-6:1.48
	binutils-csl-sourcerygxx-4_1-17:1.48
	binutils-csl-sourcerygxx-4_1-14:1.48
	binutils-csl-sourcerygxx-4_1-15:1.48
	binutils-csl-sourcerygxx-4_1-13:1.48
	binutils-2_17:1.48
	binutils-csl-sourcerygxx-4_1-12:1.48
	binutils-csl-sourcerygxx-3_4_4-21:1.48
	binutils-csl-wrs-linux-3_4_4-24:1.46
	binutils-csl-wrs-linux-3_4_4-23:1.46
	binutils-csl-sourcerygxx-4_1-9:1.48
	binutils-csl-sourcerygxx-4_1-8:1.48
	binutils-csl-sourcerygxx-4_1-7:1.48
	binutils-csl-arm-2006q1-6:1.48
	binutils-csl-sourcerygxx-4_1-6:1.48
	binutils-csl-wrs-linux-3_4_4-22:1.46
	binutils-csl-coldfire-4_1-11:1.48
	binutils-csl-sourcerygxx-3_4_4-19:1.48
	binutils-csl-coldfire-4_1-10:1.48
	binutils-csl-sourcerygxx-4_1-5:1.48
	binutils-csl-sourcerygxx-4_1-4:1.48
	binutils-csl-wrs-linux-3_4_4-21:1.46
	binutils-csl-morpho-4_1-4:1.48
	binutils-csl-sourcerygxx-3_4_4-17:1.48
	binutils-csl-wrs-linux-3_4_4-20:1.46
	binutils-2_17-branch:1.48.0.4
	binutils-2_17-branchpoint:1.48
	binutils-csl-2_17-branch:1.48.0.2
	binutils-csl-2_17-branchpoint:1.48
	binutils-csl-gxxpro-3_4-branch:1.46.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.46
	binutils-2_16_1:1.46
	binutils-csl-arm-2005q1b:1.46
	binutils-2_16:1.46
	binutils-csl-arm-2005q1a:1.46
	binutils-csl-arm-2005q1-branch:1.46.0.4
	binutils-csl-arm-2005q1-branchpoint:1.46
	binutils-2_16-branch:1.46.0.2
	binutils-2_16-branchpoint:1.46
	csl-arm-2004-q3d:1.44
	csl-arm-2004-q3:1.44
	binutils-2_15:1.44
	binutils-2_15-branchpoint:1.44
	csl-arm-2004-q1a:1.44
	csl-arm-2004-q1:1.44
	binutils-2_15-branch:1.44.0.6
	cagney_bfdfile-20040213-branch:1.44.0.4
	cagney_bfdfile-20040213-branchpoint:1.44
	cagney_bigcore-20040122-branch:1.44.0.2
	cagney_bigcore-20040122-branchpoint:1.44
	csl-arm-2003-q4:1.43
	binutils-2_14:1.39
	binutils-2_14-branch:1.39.0.2
	binutils-2_14-branchpoint:1.39
	binutils-2_13_2_1:1.24
	binutils-2_13_2:1.24
	binutils-2_13_1:1.24
	binutils-2_13:1.24
	binutils-2_13-branchpoint:1.24
	binutils-2_13-branch:1.24.0.2
	binutils-2_12_1:1.23
	binutils-2_12:1.23
	binutils-2_12-branch:1.23.0.2
	binutils-2_12-branchpoint:1.23
	cygnus_cvs_20020108_pre:1.23
	binutils-2_11_2:1.12.2.5
	binutils-2_11_1:1.12.2.5
	binutils-2_11:1.12.2.3
	x86_64versiong3:1.14
	binutils-2_11-branch:1.12.0.2
	binutils_latest_snapshot:1.64;
locks; strict;
comment	@ * @;


1.64
date	2012.11.07.20.36.33;	author seank;	state Exp;
branches;
next	1.63;

1.63
date	2012.11.06.00.49.37;	author seank;	state Exp;
branches;
next	1.62;

1.62
date	2012.08.02.20.25.35;	author seank;	state Exp;
branches;
next	1.61;

1.61
date	2012.07.27.14.13.23;	author seank;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.15.12.55.30;	author nickc;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2010.08.25.11.51.07;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.27.08.15.17;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2006.10.23.03.23.49;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2006.07.06.10.34.02;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.05.09.12.58;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2005.01.31.23.18.30;	author bje;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.21.11.17.51;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.27.09.57.59;	author ciceron;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.06.20.43.05;	author ciceron;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.05.12.43.45;	author ciceron;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.23.11.51.34;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.17.22.51.28;	author ciceron;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.17.22.29.54;	author ciceron;	state Exp;
branches;
next	1.34;

1.34
date	2002.12.08.20.47.21;	author ciceron;	state Exp;
branches;
next	1.33;

1.33
date	2002.12.01.11.19.31;	author ciceron;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.01.11.02.10;	author ciceron;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.01.10.20.06;	author ciceron;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.13.22.20.50;	author ciceron;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.13.21.52.57;	author ciceron;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.13.21.38.15;	author ciceron;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.15.21.28.56;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.01.09.56.17;	author ciceron;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.30.09.20.55;	author ciceron;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.19.05.33.25;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.28.19.28.04;	author ciceron;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.23.13.03.39;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.10.11.32.51;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.18.10.14.13;	author ciceron;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.04.13.58.30;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.02.14.14.11;	author ciceron;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.15.23.09.52;	author kazu;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.01.11.20.19.17;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.11.19.42.47;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.26.21.18.14;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.17.08.47.52;	author rth;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.25.19.15.33;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.20.22.05.08;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.08.21.40.33;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.17.21.37.02;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.19.01.22.40;	author nickc;	state Exp;
branches;
next	;

1.60.2.1
date	2012.07.30.16.11.02;	author nickc;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2012.08.06.19.39.47;	author seank;	state Exp;
branches;
next	1.60.2.3;

1.60.2.3
date	2012.11.11.03.44.49;	author seank;	state Exp;
branches;
next	;

1.12.2.1
date	2001.02.02.14.41.37;	author ciceron;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.02.04.14.11.46;	author ciceron;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.03.18.10.11.45;	author ciceron;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.06.07.03.15.30;	author amodra;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.06.11.10.04.48;	author amodra;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2001.09.30.09.22.10;	author ciceron;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2001.11.01.09.57.24;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.64
log
@2012-11-07  James Murray <jsm@@jsm-net.demon.co.uk>

	* config/tc-m68hc11.c: Fix R_M68HC12_16B relocation for movb/w
@
text
@/* tc-m68hc11.c -- Assembler code for the Motorola 68HC11 & 68HC12.
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010,
   2011, 2012
   Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)
   XGATE and S12X added by James Murray (jsm@@jsm-net.demon.co.uk)

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/m68hc11.h"
#include "dwarf2dbg.h"
#include "elf/m68hc11.h"

const char comment_chars[] = ";!";
const char line_comment_chars[] = "#*";
const char line_separator_chars[] = "";

const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "dD";

#define STATE_CONDITIONAL_BRANCH	(1)
#define STATE_PC_RELATIVE		(2)
#define STATE_INDEXED_OFFSET            (3)
#define STATE_INDEXED_PCREL             (4)
#define STATE_XBCC_BRANCH               (5)
#define STATE_CONDITIONAL_BRANCH_6812	(6)

#define STATE_BYTE			(0)
#define STATE_BITS5                     (0)
#define STATE_WORD			(1)
#define STATE_BITS9                     (1)
#define STATE_LONG			(2)
#define STATE_BITS16                    (2)
#define STATE_UNDF			(3)	/* Symbol undefined in pass1 */

/* This macro has no side-effects.  */
#define ENCODE_RELAX(what,length) (((what) << 2) + (length))
#define RELAX_STATE(s) ((s) >> 2)
#define RELAX_LENGTH(s) ((s) & 3)

#define IS_OPCODE(C1,C2)        (((C1) & 0x0FF) == ((C2) & 0x0FF))

/* This table describes how you change sizes for the various types of variable
   size expressions.  This version only supports two kinds.  */

/* The fields are:
   How far Forward this mode will reach.
   How far Backward this mode will reach.
   How many bytes this mode will add to the size of the frag.
   Which mode to go to if the offset won't fit in this one.  */

relax_typeS md_relax_table[] =
{
  {1, 1, 0, 0},			/* First entries aren't used.  */
  {1, 1, 0, 0},			/* For no good reason except.  */
  {1, 1, 0, 0},			/* that the VAX doesn't either.  */
  {1, 1, 0, 0},

  /* Relax for bcc <L>.
     These insns are translated into b!cc +3 jmp L.  */
  {(127), (-128), 0, ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_WORD)},
  {0, 0, 3, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  /* Relax for bsr <L> and bra <L>.
     These insns are translated into jsr and jmp.  */
  {(127), (-128), 0, ENCODE_RELAX (STATE_PC_RELATIVE, STATE_WORD)},
  {0, 0, 1, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  /* Relax for indexed offset: 5-bits, 9-bits, 16-bits.  */
  {(15), (-16), 0, ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS9)},
  {(255), (-256), 1, ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS16)},
  {0, 0, 2, 0},
  {1, 1, 0, 0},

  /* Relax for PC relative offset: 5-bits, 9-bits, 16-bits.
     For the 9-bit case, there will be a -1 correction to take into
     account the new byte that's why the range is -255..256.  */
  {(15), (-16), 0, ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_BITS9)},
  {(256), (-255), 1, ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_BITS16)},
  {0, 0, 2, 0},
  {1, 1, 0, 0},

  /* Relax for dbeq/ibeq/tbeq r,<L>:
     These insns are translated into db!cc +3 jmp L.  */
  {(255), (-256), 0, ENCODE_RELAX (STATE_XBCC_BRANCH, STATE_WORD)},
  {0, 0, 3, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  /* Relax for bcc <L> on 68HC12.
     These insns are translated into lbcc <L>.  */
  {(127), (-128), 0, ENCODE_RELAX (STATE_CONDITIONAL_BRANCH_6812, STATE_WORD)},
  {0, 0, 2, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

};

/* 68HC11 and 68HC12 registers.  They are numbered according to the 68HC12.  */
typedef enum register_id
{
  REG_NONE = -1,
  REG_A = 0,
  REG_B = 1,
  REG_CCR = 2,
  REG_D = 4,
  REG_X = 5,
  REG_Y = 6,
  REG_SP = 7,
  REG_PC = 8,
  REG_R0 = 0,
  REG_R1 = 1,
  REG_R2 = 2,
  REG_R3 = 3,
  REG_R4 = 4,
  REG_R5 = 5,
  REG_R6 = 6,
  REG_R7 = 7,
  REG_SP_XG = 8,
  REG_PC_XG = 9,
  REG_CCR_XG = 10
} register_id;

typedef struct operand
{
  expressionS exp;
  register_id reg1;
  register_id reg2;
  int mode;
} operand;

struct m68hc11_opcode_def
{
  long format;
  int min_operands;
  int max_operands;
  int nb_modes;
  int used;
  struct m68hc11_opcode *opcode;
};

static struct m68hc11_opcode_def *m68hc11_opcode_defs = 0;
static int m68hc11_nb_opcode_defs = 0;

typedef struct alias
{
  const char *name;
  const char *alias;
} alias;

static alias alias_opcodes[] =
{
  {"cpd", "cmpd"},
  {"cpx", "cmpx"},
  {"cpy", "cmpy"},
  {0, 0}
};

struct m9s12xg_opcode_def
{
  long format;
  int min_operands;
  int max_operands;
  int nb_modes;
  int used;
  struct m9s12xg_opcode *opcode;
};

/* Local functions.  */
static register_id reg_name_search (char *);
static register_id register_name (void);
static int cmp_opcode (struct m68hc11_opcode *, struct m68hc11_opcode *);
static char *print_opcode_format (struct m68hc11_opcode *, int);
static char *skip_whites (char *);
static int check_range (long, int);
static void print_opcode_list (void);
static void get_default_target (void);
static void print_insn_format (char *);
static int get_operand (operand *, int, long);
static void fixup8 (expressionS *, int, int);
static void fixup16 (expressionS *, int, int);
static void fixup24 (expressionS *, int, int);
static void fixup8_xg (expressionS *, int, int);
static unsigned char convert_branch (unsigned char);
static char *m68hc11_new_insn (int);
static void build_dbranch_insn (struct m68hc11_opcode *,
                                operand *, int, int);
static int build_indexed_byte (operand *, int, int);
static int build_reg_mode (operand *, int);

static struct m68hc11_opcode *find (struct m68hc11_opcode_def *,
                                    operand *, int);
static struct m68hc11_opcode *find_opcode (struct m68hc11_opcode_def *,
                                           operand *, int *);
static void build_jump_insn (struct m68hc11_opcode *, operand *, int, int);
static void build_insn_xg (struct m68hc11_opcode *, operand *, int);
static void build_insn (struct m68hc11_opcode *, operand *, int);
static int relaxable_symbol (symbolS *);

/* Pseudo op to indicate a relax group.  */
static void s_m68hc11_relax (int);

/* Pseudo op to control the ELF flags.  */
static void s_m68hc11_mode (int);

/* Process directives specified via pseudo ops.  */
static void s_m68hc11_parse_pseudo_instruction (int);

/* Mark the symbols with STO_M68HC12_FAR to indicate the functions
   are using 'rtc' for returning.  It is necessary to use 'call'
   to invoke them.  This is also used by the debugger to correctly
   find the stack frame.  */
static void s_m68hc11_mark_symbol (int);

/* Controls whether relative branches can be turned into long branches.
   When the relative offset is too large, the insn are changed:
    bra -> jmp
    bsr -> jsr
    bcc -> b!cc +3
           jmp L
    dbcc -> db!cc +3
            jmp L

  Setting the flag forbidds this.  */
static short flag_fixed_branches = 0;

/* Force to use long jumps (absolute) instead of relative branches.  */
static short flag_force_long_jumps = 0;

/* Change the direct addressing mode into an absolute addressing mode
   when the insn does not support direct addressing.
   For example, "clr *ZD0" is normally not possible and is changed
   into "clr ZDO".  */
static short flag_strict_direct_addressing = 1;

/* When an opcode has invalid operand, print out the syntax of the opcode
   to stderr.  */
static short flag_print_insn_syntax = 0;

/* Dumps the list of instructions with syntax and then exit:
   1 -> Only dumps the list (sorted by name)
   2 -> Generate an example (or test) that can be compiled.  */
static short flag_print_opcodes = 0;

/* Opcode hash table.  */
static struct hash_control *m68hc11_hash;

/* Current cpu (either cpu6811 or cpu6812).  This is determined automagically
   by 'get_default_target' by looking at default BFD vector.  This is overridden
   with the -m<cpu> option.  */
static int current_architecture = 0;

/* Default cpu determined by 'get_default_target'.  */
static const char *default_cpu;

/* Number of opcodes in the sorted table (filtered by current cpu).  */
static int num_opcodes;

/* The opcodes sorted by name and filtered by current cpu.  */
static struct m68hc11_opcode *m68hc11_sorted_opcodes;

/* ELF flags to set in the output file header.  */
static int elf_flags = E_M68HC11_F64;

/* These are the machine dependent pseudo-ops.  These are included so
   the assembler can work on the output from the SUN C compiler, which
   generates these.  */

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */
const pseudo_typeS md_pseudo_table[] =
{
  /* The following pseudo-ops are supported for MRI compatibility.  */
  {"fcb", cons, 1},
  {"fdb", cons, 2},
  {"fqb", cons, 4},
  {"fcc", stringer, 8 + 1},
  {"rmb", s_space, 0},

  /* Motorola ALIS.  */
  {"xrefb", s_ignore, 0}, /* Same as xref  */

  /* Gcc driven relaxation.  */
  {"relax", s_m68hc11_relax, 0},

  /* .mode instruction (ala SH).  */
  {"mode", s_m68hc11_mode, 0},

  /* .far instruction.  */
  {"far", s_m68hc11_mark_symbol, STO_M68HC12_FAR},

  /* .interrupt instruction.  */
  {"interrupt", s_m68hc11_mark_symbol, STO_M68HC12_INTERRUPT},

  /* .nobankwarning instruction.  */
  {"nobankwarning", s_m68hc11_parse_pseudo_instruction, E_M68HC11_NO_BANK_WARNING},

  {0, 0, 0}
};

/* Options and initialization.  */

const char *md_shortopts = "Sm:";

struct option md_longopts[] =
{
#define OPTION_FORCE_LONG_BRANCH (OPTION_MD_BASE)
  {"force-long-branches", no_argument, NULL, OPTION_FORCE_LONG_BRANCH},
  {"force-long-branchs", no_argument, NULL, OPTION_FORCE_LONG_BRANCH}, /* Misspelt version kept for backwards compatibility.  */

#define OPTION_SHORT_BRANCHES     (OPTION_MD_BASE + 1)
  {"short-branches", no_argument, NULL, OPTION_SHORT_BRANCHES},
  {"short-branchs", no_argument, NULL, OPTION_SHORT_BRANCHES}, /* Misspelt version kept for backwards compatibility.  */

#define OPTION_STRICT_DIRECT_MODE  (OPTION_MD_BASE + 2)
  {"strict-direct-mode", no_argument, NULL, OPTION_STRICT_DIRECT_MODE},

#define OPTION_PRINT_INSN_SYNTAX  (OPTION_MD_BASE + 3)
  {"print-insn-syntax", no_argument, NULL, OPTION_PRINT_INSN_SYNTAX},

#define OPTION_PRINT_OPCODES  (OPTION_MD_BASE + 4)
  {"print-opcodes", no_argument, NULL, OPTION_PRINT_OPCODES},

#define OPTION_GENERATE_EXAMPLE  (OPTION_MD_BASE + 5)
  {"generate-example", no_argument, NULL, OPTION_GENERATE_EXAMPLE},

#define OPTION_MSHORT  (OPTION_MD_BASE + 6)
  {"mshort", no_argument, NULL, OPTION_MSHORT},

#define OPTION_MLONG  (OPTION_MD_BASE + 7)
  {"mlong", no_argument, NULL, OPTION_MLONG},

#define OPTION_MSHORT_DOUBLE  (OPTION_MD_BASE + 8)
  {"mshort-double", no_argument, NULL, OPTION_MSHORT_DOUBLE},

#define OPTION_MLONG_DOUBLE  (OPTION_MD_BASE + 9)
  {"mlong-double", no_argument, NULL, OPTION_MLONG_DOUBLE},

#define OPTION_XGATE_RAMOFFSET  (OPTION_MD_BASE + 10)
  {"xgate-ramoffset", no_argument, NULL, OPTION_XGATE_RAMOFFSET},

  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

/* Get the target cpu for the assembler.  This is based on the configure
   options and on the -m68hc11/-m68hc12 option.  If no option is specified,
   we must get the default.  */
const char *
m68hc11_arch_format (void)
{
  get_default_target ();
  if (current_architecture & cpu6811)
    return "elf32-m68hc11";
  else
    return "elf32-m68hc12";
}

enum bfd_architecture
m68hc11_arch (void)
{
  get_default_target ();
  if (current_architecture & cpu6811)
    return bfd_arch_m68hc11;
  else
    return bfd_arch_m68hc12;
}

int
m68hc11_mach (void)
{
  return 0;
}

/* Listing header selected according to cpu.  */
const char *
m68hc11_listing_header (void)
{
  if (current_architecture & cpu6811)
    return "M68HC11 GAS ";
  else if (current_architecture & cpuxgate)
    return "XGATE GAS ";
  else if (current_architecture & cpu9s12x)
    return "S12X GAS ";
  else
    return "M68HC12 GAS ";
}

void
md_show_usage (FILE *stream)
{
  get_default_target ();
  fprintf (stream, _("\
Motorola 68HC11/68HC12/68HCS12 options:\n\
  -m68hc11 | -m68hc12 |\n\
  -m68hcs12 | -mm9s12x |\n\
  -mm9s12xg               specify the processor [default %s]\n\
  -mshort                 use 16-bit int ABI (default)\n\
  -mlong                  use 32-bit int ABI\n\
  -mshort-double          use 32-bit double ABI\n\
  -mlong-double           use 64-bit double ABI (default)\n\
  --force-long-branches   always turn relative branches into absolute ones\n\
  -S,--short-branches     do not turn relative branches into absolute ones\n\
                          when the offset is out of range\n\
  --strict-direct-mode    do not turn the direct mode into extended mode\n\
                          when the instruction does not support direct mode\n\
  --print-insn-syntax     print the syntax of instruction in case of error\n\
  --print-opcodes         print the list of instructions with syntax\n\
  --xgate-ramoffset       offset ram addresses by 0xc000\n\
  --generate-example      generate an example of each instruction\n\
                          (used for testing)\n"), default_cpu);

}

/* Try to identify the default target based on the BFD library.  */
static void
get_default_target (void)
{
  const bfd_target *target;
  bfd abfd;

  if (current_architecture != 0)
    return;

  default_cpu = "unknown";
  target = bfd_find_target (0, &abfd);
  if (target && target->name)
    {
      if (strcmp (target->name, "elf32-m68hc12") == 0)
	{
	  current_architecture = cpu6812;
	  default_cpu = "m68hc12";
	}
      else if (strcmp (target->name, "elf32-m68hc11") == 0)
	{
	  current_architecture = cpu6811;
	  default_cpu = "m68hc11";
	}
      else
	{
	  as_bad (_("Default target `%s' is not supported."), target->name);
	}
    }
}

void
m68hc11_print_statistics (FILE *file)
{
  int i;
  struct m68hc11_opcode_def *opc;

  hash_print_statistics (file, "opcode table", m68hc11_hash);

  opc = m68hc11_opcode_defs;
  if (opc == 0 || m68hc11_nb_opcode_defs == 0)
    return;

  /* Dump the opcode statistics table.  */
  fprintf (file, _("Name   # Modes  Min ops  Max ops  Modes mask  # Used\n"));
  for (i = 0; i < m68hc11_nb_opcode_defs; i++, opc++)
    {
      fprintf (file, "%-7.7s  %5d  %7d  %7d  0x%08lx  %7d\n",
	       opc->opcode->name,
	       opc->nb_modes,
	       opc->min_operands, opc->max_operands, opc->format, opc->used);
    }
}

int
md_parse_option (int c, char *arg)
{
  get_default_target ();
  switch (c)
    {
      /* -S means keep external to 2 bit offset rather than 16 bit one.  */
    case OPTION_SHORT_BRANCHES:
    case 'S':
      flag_fixed_branches = 1;
      break;

    case OPTION_FORCE_LONG_BRANCH:
      flag_force_long_jumps = 1;
      break;

    case OPTION_PRINT_INSN_SYNTAX:
      flag_print_insn_syntax = 1;
      break;

    case OPTION_PRINT_OPCODES:
      flag_print_opcodes = 1;
      break;

    case OPTION_STRICT_DIRECT_MODE:
      flag_strict_direct_addressing = 0;
      break;

    case OPTION_GENERATE_EXAMPLE:
      flag_print_opcodes = 2;
      break;

    case OPTION_MSHORT:
      elf_flags &= ~E_M68HC11_I32;
      break;

    case OPTION_MLONG:
      elf_flags |= E_M68HC11_I32;
      break;

    case OPTION_MSHORT_DOUBLE:
      elf_flags &= ~E_M68HC11_F64;
      break;

    case OPTION_MLONG_DOUBLE:
      elf_flags |= E_M68HC11_F64;
      break;

    case OPTION_XGATE_RAMOFFSET:
      elf_flags |= E_M68HC11_XGATE_RAMOFFSET;
      break;

    case 'm':
      if ((strcasecmp (arg, "68hc11") == 0)
          || (strcasecmp (arg, "m68hc11") == 0))
	current_architecture = cpu6811;
      else if ((strcasecmp (arg, "68hc12") == 0)
          || (strcasecmp (arg, "m68hc12") == 0))
	current_architecture = cpu6812;
      else if ((strcasecmp (arg, "68hcs12") == 0)
          || (strcasecmp (arg, "m68hcs12") == 0))
	current_architecture = cpu6812 | cpu6812s;
     else if (strcasecmp (arg, "m9s12x") == 0)
	current_architecture = cpu6812 | cpu6812s | cpu9s12x;
     else if ((strcasecmp (arg, "m9s12xg") == 0)
          || (strcasecmp (arg, "xgate") == 0))
	/* xgate for backwards compatability */
	current_architecture = cpuxgate;
      else
	as_bad (_("Option `%s' is not recognized."), arg);
      break;

    default:
      return 0;
    }

  return 1;
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

static int
cmp_opcode (struct m68hc11_opcode *op1, struct m68hc11_opcode *op2)
{
  return strcmp (op1->name, op2->name);
}

#define IS_CALL_SYMBOL(MODE) \
(((MODE) & (M6812_OP_PAGE|M6811_OP_IND16)) \
  == ((M6812_OP_PAGE|M6811_OP_IND16)))

/* Initialize the assembler.  Create the opcode hash table
   (sorted on the names) with the M6811 opcode table
   (from opcode library).  */
void
md_begin (void)
{
  char *prev_name = "";
  struct m68hc11_opcode *opcodes;
  struct m68hc11_opcode_def *opc = 0;
  int i, j;

  get_default_target ();

  m68hc11_hash = hash_new ();

  /* Get a writable copy of the opcode table and sort it on the names.  */
  opcodes = (struct m68hc11_opcode *) xmalloc (m68hc11_num_opcodes *
					       sizeof (struct
						       m68hc11_opcode));
  m68hc11_sorted_opcodes = opcodes;
  num_opcodes = 0;
  for (i = 0; i < m68hc11_num_opcodes; i++)
    {
      if (m68hc11_opcodes[i].arch & current_architecture)
	{
	  opcodes[num_opcodes] = m68hc11_opcodes[i];
	  if (opcodes[num_opcodes].name[0] == 'b'
	      && opcodes[num_opcodes].format & M6811_OP_JUMP_REL
	      && !(opcodes[num_opcodes].format & M6811_OP_BITMASK))
	    {
	      num_opcodes++;
	      opcodes[num_opcodes] = m68hc11_opcodes[i];
	    }
	  num_opcodes++;
	  for (j = 0; alias_opcodes[j].name != 0; j++)
	    if (strcmp (m68hc11_opcodes[i].name, alias_opcodes[j].name) == 0)
	      {
		opcodes[num_opcodes] = m68hc11_opcodes[i];
		opcodes[num_opcodes].name = alias_opcodes[j].alias;
		num_opcodes++;
		break;
	      }
	}
    }
  qsort (opcodes, num_opcodes, sizeof (struct m68hc11_opcode),
         (int (*) (const void*, const void*)) cmp_opcode);

  opc = (struct m68hc11_opcode_def *)
    xmalloc (num_opcodes * sizeof (struct m68hc11_opcode_def));
  m68hc11_opcode_defs = opc--;

  /* Insert unique names into hash table.  The M6811 instruction set
     has several identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */
  for (i = 0; i < num_opcodes; i++, opcodes++)
    {
      int expect;

      if (strcmp (prev_name, opcodes->name))
	{
	  prev_name = (char *) opcodes->name;

	  opc++;
	  opc->format = 0;
	  opc->min_operands = 100;
	  opc->max_operands = 0;
	  opc->nb_modes = 0;
	  opc->opcode = opcodes;
	  opc->used = 0;
	  hash_insert (m68hc11_hash, opcodes->name, opc);
	}
      opc->nb_modes++;
      opc->format |= opcodes->format;

      /* See how many operands this opcode needs.  */
      expect = 0;
      if (opcodes->arch == cpuxgate)
	{
	  if (opcodes->format & (M68XG_OP_IMM3 | M68XG_OP_R | M68XG_OP_REL9
				 | M68XG_OP_REL10 ))
	    expect = 1;
	  else if (opcodes->format & (M68XG_OP_R_R | M68XG_OP_R_IMM4
				      | M68XG_OP_R_IMM8 | M68XG_OP_R_IMM8))
	    expect = 2;
	  else if (opcodes->format & (M68XG_OP_R_R_R | M68XG_OP_R_R_OFFS5
				      | M68XG_OP_RD_RB_RI | M68XG_OP_RD_RB_RIp
				      | M68XG_OP_RD_RB_mRI))
	    expect = 3;
	}
      else
	{
	  if (opcodes->format & M6811_OP_MASK)
	    expect++;
	  if (opcodes->format & M6811_OP_BITMASK)
	    expect++;
	  if (opcodes->format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
	    expect++;
	  if (opcodes->format & (M6812_OP_IND16_P2 | M6812_OP_IDX_P2))
	    expect++;
	  /* Special case for call instruction.  */
	  if ((opcodes->format & M6812_OP_PAGE)
	      && !(opcodes->format & M6811_OP_IND16))
	    expect++;
	}

      if (expect < opc->min_operands)
	opc->min_operands = expect;
      if (IS_CALL_SYMBOL (opcodes->format))
	expect++;
      if (expect > opc->max_operands)
	opc->max_operands = expect;
    }
  opc++;
  m68hc11_nb_opcode_defs = opc - m68hc11_opcode_defs;

  if (flag_print_opcodes)
    {
      print_opcode_list ();
      exit (EXIT_SUCCESS);
    }
}

void
m68hc11_init_after_args (void)
{
}

/* Builtin help.  */

/* Return a string that represents the operand format for the instruction.
   When example is true, this generates an example of operand.  This is used
   to give an example and also to generate a test.  */

static char *
print_opcode_format (struct m68hc11_opcode *opcode, int example)
{
  static char buf[128];
  int format = opcode->format;
  char *p;

  p = buf;
  buf[0] = 0;

  if (current_architecture == cpuxgate)
    {
      if (format & M68XG_OP_IMM3)
	{
	  if (example)
	    sprintf (p, "#%d", rand () & 0x007);
	  else
	    strcpy (p, _("imm3"));
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_R)
	{
	  if (example)
	    sprintf (p, "R%d", rand () & 0x07);
	  else
	    strcpy (p, _("RD"));
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_R_R)
	{
	  if (example)
	    sprintf (p, "R%d,R%d", rand () & 0x07, rand () & 0x07);
	  else
	    strcpy (p, _("RD,RS"));
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_R_IMM4)
	{
	  if (example)
	    sprintf (p, "R%d,#%d", rand () & 0x07, rand () & 0x0f);
	  else
    	    strcpy (p, _("RI, #imm4"));
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_R_R_R)
	{
	  if (example)
	    sprintf (p, "R%d,R%d,R%d", rand () & 0x07, rand () & 0x07, rand () & 0x07);
	  else
	    strcpy (p, "RD,RS1,RS2");
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_REL9)
	{
	  if (example)
	    sprintf (p, "%d", rand () & 0x1FF);
	  else
	    strcpy (p, "<rel9>");
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_REL10)
	{
	  if (example)
	    sprintf (p, "%d", rand () & 0x3FF);
	  else
    	    strcpy (p, "<rel10>");
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_R_R_OFFS5)
	{
	  if (example)
	    sprintf (p, "R%d, (R%d, #0x%x)", rand () & 0x07, rand () & 0x07, rand () & 0x1f);
	  else
	    strcpy (p, _("RD, (RI,#offs5)"));
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_RD_RB_RI)
	{
	  if (example)
	    sprintf (p, "R%d, (R%d, R%d)", rand () & 0x07, rand () & 0x07, rand () & 0x07);
	  else
	    strcpy (p, "RD, (RB, RI)");
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_RD_RB_RIp)
	{
	  if (example)
	    sprintf (p, "R%d, (R%d, R%d+)", rand () & 0x07, rand () & 0x07, rand () & 0x07);
	  else
	    strcpy (p, "RD, (RB, RI+)");
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_RD_RB_mRI)
	{
	  if (example)
	    sprintf (p, "R%d, (R%d, -R%d)", rand () & 0x07, rand () & 0x07, rand () & 0x07);
	  else
	    strcpy (p, "RD, (RB, -RI)");
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_R_IMM8)
	{
	  if (example)
	    sprintf (p, "R%d, #0x%x", rand () & 0x07, rand () & 0xff);
	  else
	    strcpy (p, "RD, #imm8");
	  p = &p[strlen (p)];
	}
      else if (format & M68XG_OP_R_IMM16)
	{
	  if (example)
	    sprintf (p, "R%d, #0x%x", rand () & 0x07, rand () & 0xffff);
	  else
	    strcpy (p, "RD, #imm16");
	  p = &p[strlen (p)];
	}
    }
  else
    {

      if (format & M6811_OP_IMM8)
	{
	  if (example)
	    sprintf (p, "#%d", rand () & 0x0FF);
	  else
	    strcpy (p, _("#<imm8>"));
	  p = &p[strlen (p)];
	}

      if (format & M6811_OP_IMM16)
	{
	  if (example)
	    sprintf (p, "#%d", rand () & 0x0FFFF);
	  else
	    strcpy (p, _("#<imm16>"));
	  p = &p[strlen (p)];
	}

      if (format & M6811_OP_IX)
	{
	  if (example)
	    sprintf (p, "%d,X", rand () & 0x0FF);
	  else
	    strcpy (p, _("<imm8>,X"));
	  p = &p[strlen (p)];
	}

      if (format & M6811_OP_IY)
	{
	  if (example)
	    sprintf (p, "%d,X", rand () & 0x0FF);
	  else
	    strcpy (p, _("<imm8>,X"));
	  p = &p[strlen (p)];
	}

      if (format & M6812_OP_IDX)
	{
	  if (example)
	    sprintf (p, "%d,X", rand () & 0x0FF);
	  else
	    strcpy (p, "n,r");
	  p = &p[strlen (p)];
	}

      if (format & M6812_OP_PAGE)
	{
	  if (example)
	    sprintf (p, ", %d", rand () & 0x0FF);
	  else
	    strcpy (p, ", <page>");
	  p = &p[strlen (p)];
	}

      if (format & M6811_OP_DIRECT)
	{
	  if (example)
	    sprintf (p, "*Z%d", rand () & 0x0FF);
	  else
	    strcpy (p, _("*<abs8>"));
	  p = &p[strlen (p)];
	}

      if (format & M6811_OP_BITMASK)
	{
	  if (buf[0])
	    *p++ = ' ';

	  if (example)
	    sprintf (p, "#$%02x", rand () & 0x0FF);
	  else
	    strcpy (p, _("#<mask>"));

	  p = &p[strlen (p)];
	  if (format & M6811_OP_JUMP_REL)
	    *p++ = ' ';
	}

      if (format & M6811_OP_IND16)
	{
	  if (example)
	    sprintf (p, _("symbol%d"), rand () & 0x0FF);
	  else
	    strcpy (p, _("<abs>"));

	  p = &p[strlen (p)];
	}

      if (format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
	{
	  if (example)
	    {
	      if (format & M6811_OP_BITMASK)
		{
		  sprintf (p, ".+%d", rand () & 0x7F);
		}
	      else
		{
		  sprintf (p, "L%d", rand () & 0x0FF);
		}
	    }
	  else
	    strcpy (p, _("<label>"));
	}
    }
  return buf;
}

/* Prints the list of instructions with the possible operands.  */
static void
print_opcode_list (void)
{
  int i;
  char *prev_name = "";
  struct m68hc11_opcode *opcodes;
  int example = flag_print_opcodes == 2;

  if (example)
    printf (_("# Example of `%s' instructions\n\t.sect .text\n_start:\n"),
	    default_cpu);

  opcodes = m68hc11_sorted_opcodes;

  /* Walk the list sorted on names (by md_begin).  We only report
     one instruction per line, and we collect the different operand
     formats.  */
  for (i = 0; i < num_opcodes; i++, opcodes++)
    {
      char *fmt = print_opcode_format (opcodes, example);

      if (example)
	{
	  printf ("L%d:\t", i);
	  printf ("%s %s\n", opcodes->name, fmt);
	}
      else
	{
	  if (strcmp (prev_name, opcodes->name))
	    {
	      if (i > 0)
		printf ("\n");

	      printf ("%-5.5s ", opcodes->name);
	      prev_name = (char *) opcodes->name;
	    }
	  if (fmt[0])
	    printf ("  [%s]", fmt);
	}
    }
  printf ("\n");
}

/* Print the instruction format.  This operation is called when some
   instruction is not correct.  Instruction format is printed as an
   error message.  */
static void
print_insn_format (char *name)
{
  struct m68hc11_opcode_def *opc;
  struct m68hc11_opcode *opcode;
  char buf[128];

  opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);
  if (opc == NULL)
    {
      as_bad (_("Instruction `%s' is not recognized."), name);
      return;
    }
  opcode = opc->opcode;

  as_bad (_("Instruction formats for `%s':"), name);
  do
    {
      char *fmt;

      fmt = print_opcode_format (opcode, 0);
      sprintf (buf, "\t%-5.5s %s", opcode->name, fmt);

      as_bad ("%s", buf);
      opcode++;
    }
  while (strcmp (opcode->name, name) == 0);
}

/* Analysis of 68HC11 and 68HC12 operands.  */

/* reg_name_search() finds the register number given its name.
   Returns the register number or REG_NONE on failure.  */
static register_id
reg_name_search (char *name)
{
  if (strcasecmp (name, "x") == 0 || strcasecmp (name, "ix") == 0)
    return REG_X;
  if (strcasecmp (name, "y") == 0 || strcasecmp (name, "iy") == 0)
    return REG_Y;
  if (strcasecmp (name, "a") == 0)
    return REG_A;
  if (strcasecmp (name, "b") == 0)
    return REG_B;
  if (strcasecmp (name, "d") == 0)
    return REG_D;
  if (strcasecmp (name, "sp") == 0)
    return REG_SP;
  if (strcasecmp (name, "pc") == 0)
    return REG_PC;
  if (strcasecmp (name, "ccr") == 0)
    return REG_CCR;
/* XGATE */
  if (strcasecmp (name, "r0") == 0)
    return REG_R0;
  if (strcasecmp (name, "r1") == 0)
    return REG_R1;
  if (strcasecmp (name, "r2") == 0)
    return REG_R2;
  if (strcasecmp (name, "r3") == 0)
    return REG_R3;
  if (strcasecmp (name, "r4") == 0)
    return REG_R4;
  if (strcasecmp (name, "r5") == 0)
    return REG_R5;
  if (strcasecmp (name, "r6") == 0)
    return REG_R6;
  if (strcasecmp (name, "r7") == 0)
    return REG_R7;
  if (strcasecmp (name, "sp") == 0)
    return REG_SP_XG;
  if (strcasecmp (name, "pc") == 0)
    return REG_PC_XG;
  if (strcasecmp (name, "ccr") == 0)
    return REG_CCR_XG;
  return REG_NONE;
}

static char *
skip_whites (char *p)
{
  while (*p == ' ' || *p == '\t')
    p++;

  return p;
}

/* Check the string at input_line_pointer
   to see if it is a valid register name.  */
static register_id
register_name (void)
{
  register_id reg_number;
  char c, *p = input_line_pointer;

  if (!is_name_beginner (*p++))
    return REG_NONE;

  while (is_part_of_name (*p++))
    continue;

  c = *--p;
  if (c)
    *p++ = 0;

  /* Look to see if it's in the register table.  */
  reg_number = reg_name_search (input_line_pointer);
  if (reg_number != REG_NONE)
    {
      if (c)
	*--p = c;

      input_line_pointer = p;
      return reg_number;
    }
  if (c)
    *--p = c;

  return reg_number;
}
#define M6811_OP_CALL_ADDR    0x00800000
#define M6811_OP_PAGE_ADDR    0x04000000

/* Parse a string of operands and return an array of expressions.

   Operand      mode[0]         mode[1]       exp[0]       exp[1]
   #n           M6811_OP_IMM16  -             O_*
   *<exp>       M6811_OP_DIRECT -             O_*
   .{+-}<exp>   M6811_OP_JUMP_REL -           O_*
   <exp>        M6811_OP_IND16  -             O_*
   ,r N,r       M6812_OP_IDX    M6812_OP_REG  O_constant   O_register
   n,-r         M6812_PRE_DEC   M6812_OP_REG  O_constant   O_register
   n,+r         M6812_PRE_INC   " "
   n,r-         M6812_POST_DEC  " "
   n,r+         M6812_POST_INC  " "
   A,r B,r D,r  M6811_OP_REG    M6812_OP_REG  O_register   O_register
   [D,r]        M6811_OP_D_IDX  M6812_OP_REG  O_register   O_register
   [n,r]        M6811_OP_D_IDX_2 M6812_OP_REG  O_constant   O_register  */
static int
get_operand (operand *oper, int which, long opmode)
{
  char *p = input_line_pointer;
  int mode;
  register_id reg;

  oper->exp.X_op = O_absent;
  oper->reg1 = REG_NONE;
  oper->reg2 = REG_NONE;
  mode = M6811_OP_NONE;

  p = skip_whites (p);

  if (*p == 0 || *p == '\n' || *p == '\r')
    {
      input_line_pointer = p;
      return 0;
    }

  if (*p == '*' && (opmode & (M6811_OP_DIRECT | M6811_OP_IND16)))
    {
      mode = M6811_OP_DIRECT;
      p++;
    }
  else if (*p == '#')
    {
      if (!(opmode & (M6811_OP_IMM8 | M6811_OP_IMM16 | M6811_OP_BITMASK)))
	{
	  as_bad (_("Immediate operand is not allowed for operand %d."),
		  which);
	  return -1;
	}

      mode = M6811_OP_IMM16;
      p++;
      if (strncmp (p, "%hi", 3) == 0)
	{
	  p += 3;
	  mode |= M6811_OP_HIGH_ADDR;
	}
      else if (strncmp (p, "%lo", 3) == 0)
	{
	  p += 3;
	  mode |= M6811_OP_LOW_ADDR;
	}
      /* %page modifier is used to obtain only the page number
         of the address of a function.  */
      else if (strncmp (p, "%page", 5) == 0)
	{
	  p += 5;
	  mode |= M6811_OP_PAGE_ADDR;
	}

      /* %addr modifier is used to obtain the physical address part
         of the function (16-bit).  For 68HC12 the function will be
         mapped in the 16K window at 0x8000 and the value will be
         within that window (although the function address may not fit
         in 16-bit).  See bfd/elf32-m68hc12.c for the translation.  */
      else if (strncmp (p, "%addr", 5) == 0)
	{
	  p += 5;
	  mode |= M6811_OP_CALL_ADDR;
	}
    }
  else if (*p == '.' && (p[1] == '+' || p[1] == '-'))
    {
      p++;
      mode = M6811_OP_JUMP_REL;
    }
  else if (*p == '[')
    {
      if (current_architecture & cpu6811)
	as_bad (_("Indirect indexed addressing is not valid for 68HC11."));

      p++;
      mode = M6812_OP_D_IDX;
      p = skip_whites (p);
    }
  else if (*p == ',')		/* Special handling of ,x and ,y.  */
    {
      p++;
      input_line_pointer = p;

      reg = register_name ();
      if (reg != REG_NONE)
	{
	  oper->reg1 = reg;
	  oper->exp.X_op = O_constant;
	  oper->exp.X_add_number = 0;
	  oper->mode = M6812_OP_IDX;
	  return 1;
	}
      as_bad (_("Spurious `,' or bad indirect register addressing mode."));
      return -1;
    }
  /* Handle 68HC12 page specification in 'call foo,%page(bar)'.  */
  else if ((opmode & M6812_OP_PAGE) && strncmp (p, "%page", 5) == 0)
    {
      p += 5;
      mode = M6811_OP_PAGE_ADDR | M6812_OP_PAGE | M6811_OP_IND16;
    }
  input_line_pointer = p;

  if (mode == M6811_OP_NONE || mode == M6812_OP_D_IDX)
    reg = register_name ();
  else
    reg = REG_NONE;

  if (reg != REG_NONE)
    {
      p = skip_whites (input_line_pointer);
      if (*p == ']' && mode == M6812_OP_D_IDX)
	{
	  as_bad
	    (_("Missing second register or offset for indexed-indirect mode."));
	  return -1;
	}

      oper->reg1 = reg;
      oper->mode = mode | M6812_OP_REG;
      if (*p != ',')
	{
	  if (mode == M6812_OP_D_IDX)
	    {
	      as_bad (_("Missing second register for indexed-indirect mode."));
	      return -1;
	    }
	  return 1;
	}

      p++;
      input_line_pointer = p;
      reg = register_name ();
      if (reg != REG_NONE)
	{
	  p = skip_whites (input_line_pointer);
	  if (mode == M6812_OP_D_IDX)
	    {
	      if (*p != ']')
		{
		  as_bad (_("Missing `]' to close indexed-indirect mode."));
		  return -1;
		}
	      p++;
              oper->mode = M6812_OP_D_IDX;
	    }
	  input_line_pointer = p;

	  oper->reg2 = reg;
	  return 1;
	}
      return 1;
    }

  /* In MRI mode, isolate the operand because we can't distinguish
     operands from comments.  */
  if (flag_mri)
    {
      char c = 0;

      p = skip_whites (p);
      while (*p && *p != ' ' && *p != '\t')
	p++;

      if (*p)
	{
	  c = *p;
	  *p = 0;
	}

      /* Parse as an expression.  */
      expression (&oper->exp);

      if (c)
	{
	  *p = c;
	}
    }
  else
    {
      expression (&oper->exp);
    }

  if (oper->exp.X_op == O_illegal)
    {
      as_bad (_("Illegal operand."));
      return -1;
    }
  else if (oper->exp.X_op == O_absent)
    {
      as_bad (_("Missing operand."));
      return -1;
    }

  p = input_line_pointer;

  if (mode == M6811_OP_NONE || mode == M6811_OP_DIRECT
      || mode == M6812_OP_D_IDX)
    {
      p = skip_whites (input_line_pointer);

      if (*p == ',')
	{
	  int possible_mode = M6811_OP_NONE;
	  char *old_input_line;

	  old_input_line = p;
	  p++;

	  /* 68HC12 pre increment or decrement.  */
	  if (mode == M6811_OP_NONE)
	    {
	      if (*p == '-')
		{
		  possible_mode = M6812_PRE_DEC;
		  p++;
		}
	      else if (*p == '+')
		{
		  possible_mode = M6812_PRE_INC;
		  p++;
		}
	      p = skip_whites (p);
	    }
	  input_line_pointer = p;
	  reg = register_name ();

	  /* Backtrack if we have a valid constant expression and
	     it does not correspond to the offset of the 68HC12 indexed
	     addressing mode (as in N,x).  */
	  if (reg == REG_NONE && mode == M6811_OP_NONE
	      && possible_mode != M6811_OP_NONE)
	    {
	      oper->mode = M6811_OP_IND16 | M6811_OP_JUMP_REL;
	      input_line_pointer = skip_whites (old_input_line);
	      return 1;
	    }

	  if (possible_mode != M6811_OP_NONE)
	    mode = possible_mode;

	  if ((current_architecture & cpu6811)
	      && possible_mode != M6811_OP_NONE)
	    as_bad (_("Pre-increment mode is not valid for 68HC11"));
	  /* Backtrack.  */
	  if (which == 0 && opmode & M6812_OP_IDX_P2
	      && reg != REG_X && reg != REG_Y
	      && reg != REG_PC && reg != REG_SP)
	    {
	      reg = REG_NONE;
	      input_line_pointer = p;
	    }

	  if (reg == REG_NONE && mode != M6811_OP_DIRECT
	      && !(mode == M6811_OP_NONE && opmode & M6811_OP_IND16))
	    {
	      as_bad (_("Wrong register in register indirect mode."));
	      return -1;
	    }
	  if (mode == M6812_OP_D_IDX)
	    {
	      p = skip_whites (input_line_pointer);
	      if (*p++ != ']')
		{
		  as_bad (_("Missing `]' to close register indirect operand."));
		  return -1;
		}
	      input_line_pointer = p;
              oper->reg1 = reg;
              oper->mode = M6812_OP_D_IDX_2;
              return 1;
	    }
	  if (reg != REG_NONE)
	    {
	      oper->reg1 = reg;
	      if (mode == M6811_OP_NONE)
		{
		  p = input_line_pointer;
		  if (*p == '-')
		    {
		      mode = M6812_POST_DEC;
		      p++;
		      if (current_architecture & cpu6811)
			as_bad
			  (_("Post-decrement mode is not valid for 68HC11."));
		    }
		  else if (*p == '+')
		    {
		      mode = M6812_POST_INC;
		      p++;
		      if (current_architecture & cpu6811)
			as_bad
			  (_("Post-increment mode is not valid for 68HC11."));
		    }
		  else
		    mode = M6812_OP_IDX;

		  input_line_pointer = p;
		}
	      else
		mode |= M6812_OP_IDX;

	      oper->mode = mode;
	      return 1;
	    }
          input_line_pointer = old_input_line;
	}

      if (mode == M6812_OP_D_IDX_2)
	{
	  as_bad (_("Invalid indexed indirect mode."));
	  return -1;
	}
    }

  /* If the mode is not known until now, this is either a label
     or an indirect address.  */
  if (mode == M6811_OP_NONE)
    mode = M6811_OP_IND16 | M6811_OP_JUMP_REL;

  p = input_line_pointer;
  while (*p == ' ' || *p == '\t')
    p++;
  input_line_pointer = p;
  oper->mode = mode;

  return 1;
}

#define M6812_AUTO_INC_DEC (M6812_PRE_INC | M6812_PRE_DEC \
                            | M6812_POST_INC | M6812_POST_DEC)

/* Checks that the number 'num' fits for a given mode.  */
static int
check_range (long num, int mode)
{
  if (current_architecture == cpuxgate)
    {
      switch (mode)
	{
	case M68XG_OP_IMM3:
	  return (num >= 0 && num <= 7) ? 1 : 0;

	case M68XG_OP_R_IMM4:
	  return (num >= 0 && num <= 15) ? 1 : 0;

	case M68XG_OP_R_R_OFFS5:
	  return (num >= 0 && num <= 31) ? 1 : 0;

	case M68XG_OP_R_IMM8:
	  return (num >= 0 && num <= 255) ? 1 : 0;

	case M68XG_OP_R_IMM16:
	  return (num >= 0 && num <= 65535) ? 1 : 0;

	case M68XG_OP_B_MARKER:
	  return (num >= -512 && num <= 511) ? 1 : 0;

	case M68XG_OP_BRA_MARKER:
	  return (num >= -1024 && num <= 1023) ? 1 : 0;

	default:
	  return 0;
	}
    }
  else
    {
      /* Auto increment and decrement are ok for [-8..8] without 0.  */
      if (mode & M6812_AUTO_INC_DEC)
	return (num != 0 && num <= 8 && num >= -8);

      /* The 68HC12 supports 5, 9 and 16-bit offsets.  */
      if (mode & (M6812_INDEXED_IND | M6812_INDEXED | M6812_OP_IDX))
	mode = M6811_OP_IND16;

      if (mode & M6812_OP_JUMP_REL16)
	mode = M6811_OP_IND16;

      mode &= ~M6811_OP_BRANCH;
      switch (mode)
	{
	case M6811_OP_IX:
	case M6811_OP_IY:
	case M6811_OP_DIRECT:
	  return (num >= 0 && num <= 255) ? 1 : 0;

	case M6811_OP_BITMASK:
	case M6811_OP_IMM8:
	case M6812_OP_PAGE:
	  return (((num & 0xFFFFFF00) == 0) || ((num & 0xFFFFFF00) == 0xFFFFFF00))
	    ? 1 : 0;

	case M6811_OP_JUMP_REL:
	  return (num >= -128 && num <= 127) ? 1 : 0;

	case M6811_OP_IND16:
	case M6811_OP_IND16 | M6812_OP_PAGE:
	case M6811_OP_IMM16:
	  return (((num & 0xFFFF0000) == 0) || ((num & 0xFFFF0000) == 0xFFFF0000))
	    ? 1 : 0;

	case M6812_OP_IBCC_MARKER:
	case M6812_OP_TBCC_MARKER:
	case M6812_OP_DBCC_MARKER:
	  return (num >= -256 && num <= 255) ? 1 : 0;

	case M6812_OP_TRAP_ID:
	  return ((num >= 0x30 && num <= 0x39)
		  || (num >= 0x40 && num <= 0x0ff)) ? 1 : 0;

	default:
	  return 0;
	}
    }
}

/* Gas fixup generation.  */

/* Put a 1 byte expression described by 'oper'.  If this expression contains
   unresolved symbols, generate an 8-bit fixup.  */
static void
fixup8 (expressionS *oper, int mode, int opmode)
{
  char *f;

  f = frag_more (1);

  if (oper->X_op == O_constant)
    {
      if (mode & M6812_OP_TRAP_ID
	  && !check_range (oper->X_add_number, M6812_OP_TRAP_ID))
	{
	  static char trap_id_warn_once = 0;

	  as_bad (_("Trap id `%ld' is out of range."), oper->X_add_number);
	  if (trap_id_warn_once == 0)
	    {
	      trap_id_warn_once = 1;
	      as_bad (_("Trap id must be within [0x30..0x39] or [0x40..0xff]."));
	    }
	}

      if (!(mode & M6812_OP_TRAP_ID)
	  && !check_range (oper->X_add_number, mode))
	{
	  as_bad (_("Operand out of 8-bit range: `%ld'."), oper->X_add_number);
	}
      number_to_chars_bigendian (f, oper->X_add_number & 0x0FF, 1);
    }
  else if (oper->X_op != O_register)
    {
      if (mode & M6812_OP_TRAP_ID)
	as_bad (_("The trap id must be a constant."));

      if (mode == M6811_OP_JUMP_REL)
	{
	  fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
		       oper, TRUE, BFD_RELOC_8_PCREL);
	}
      else
	{
	  fixS *fixp;
          int reloc;

	  /* Now create an 8-bit fixup.  If there was some %hi, %lo
	     or %page modifier, generate the reloc accordingly.  */
          if (opmode & M6811_OP_HIGH_ADDR)
            reloc = BFD_RELOC_M68HC11_HI8;
          else if (opmode & M6811_OP_LOW_ADDR)
            reloc = BFD_RELOC_M68HC11_LO8;
          else if (opmode & M6811_OP_PAGE_ADDR)
            reloc = BFD_RELOC_M68HC11_PAGE;
          else
            reloc = BFD_RELOC_8;

	  fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
                              oper, FALSE, reloc);
          if (reloc != BFD_RELOC_8)
            fixp->fx_no_overflow = 1;
	}
      number_to_chars_bigendian (f, 0, 1);
    }
  else
    {
      as_fatal (_("Operand `%x' not recognized in fixup8."), oper->X_op);
    }
}

/* Put a 2 byte expression described by 'oper'.  If this expression contains
   unresolved symbols, generate a 16-bit fixup.  */
static void
fixup16 (expressionS *oper, int mode, int opmode ATTRIBUTE_UNUSED)
{
  char *f;

  f = frag_more (2);

  if (oper->X_op == O_constant)
    {
      if (!check_range (oper->X_add_number, mode))
	{
	  as_bad (_("Operand out of 16-bit range: `%ld'."),
		  oper->X_add_number);
	}
      number_to_chars_bigendian (f, oper->X_add_number & 0x0FFFF, 2);
    }
  else if (oper->X_op != O_register)
    {
      fixS *fixp;
      int reloc;

      if ((opmode & M6811_OP_CALL_ADDR) && (mode & M6811_OP_IMM16))
        reloc = BFD_RELOC_M68HC11_LO16;
      else if (mode & M6812_OP_JUMP_REL16)
        reloc = BFD_RELOC_16_PCREL;
      else if (mode & M6812_OP_PAGE)
        reloc = BFD_RELOC_M68HC11_LO16;
      else
        reloc = BFD_RELOC_16;

      /* Now create a 16-bit fixup.  */
      fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
			  oper,
			  reloc == BFD_RELOC_16_PCREL,
                          reloc);
      number_to_chars_bigendian (f, 0, 2);

      if (reloc == BFD_RELOC_M68HC11_LO16)
        fixp->fx_no_overflow = 1;
    }
  else
    {
      as_fatal (_("Operand `%x' not recognized in fixup16."), oper->X_op);
    }
}

/* Put a 3 byte expression described by 'oper'.  If this expression contains
   unresolved symbols, generate a 24-bit fixup.  */
static void
fixup24 (expressionS *oper, int mode, int opmode ATTRIBUTE_UNUSED)
{
  char *f;

  f = frag_more (3);

  if (oper->X_op == O_constant)
    {
      if (!check_range (oper->X_add_number, mode))
	{
	  as_bad (_("Operand out of 16-bit range: `%ld'."),
		  oper->X_add_number);
	}
      number_to_chars_bigendian (f, oper->X_add_number & 0x0FFFFFF, 3);
    }
  else if (oper->X_op != O_register)
    {
      /* Now create a 24-bit fixup.  */
      fix_new_exp (frag_now, f - frag_now->fr_literal, 3,
		   oper, FALSE, BFD_RELOC_M68HC11_24);
      number_to_chars_bigendian (f, 0, 3);
    }
  else
    {
      as_fatal (_("Operand `%x' not recognized in fixup16."), oper->X_op);
    }
}

/* XGATE Put a 1 byte expression described by 'oper'.  If this expression
   containts unresolved symbols, generate an 8-bit fixup.  */
static void
fixup8_xg (expressionS *oper, int mode, int opmode)
{
  char *f;

  f = frag_more (1);

  if (oper->X_op == O_constant)
    {
      fixS *fixp;
      int reloc;

      if ((opmode & M6811_OP_HIGH_ADDR) || (opmode & M6811_OP_LOW_ADDR))
        {
          if (opmode & M6811_OP_HIGH_ADDR)
            reloc = BFD_RELOC_M68HC11_HI8;
          else
            reloc = BFD_RELOC_M68HC11_LO8;

          fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
			      oper, FALSE, reloc);
          fixp->fx_no_overflow = 1;
          number_to_chars_bigendian (f, 0, 1);
        }
     else
        {
	  if (!(check_range (oper->X_add_number, mode)))
	    as_bad (_("Operand out of 8-bit range: `%ld'."),
		    oper->X_add_number);
          number_to_chars_bigendian (f, oper->X_add_number & 0x0FF, 1);
        }
    }
  else if (oper->X_op != O_register)
    {
      if (mode == M68XG_OP_REL9)
        {
          /* Future improvement:
	     This fixup/reloc isn't adding on constants to symbols.  */
          fix_new_exp (frag_now, f - frag_now->fr_literal -1, 2,
		       oper, TRUE, BFD_RELOC_M68HC12_9_PCREL);
      	}
      else if (mode == M68XG_OP_REL10)
        {
          /* Future improvement:
	     This fixup/reloc isn't adding on constants to symbols.  */
          fix_new_exp (frag_now, f - frag_now->fr_literal -1, 2,
    	               oper, TRUE, BFD_RELOC_M68HC12_10_PCREL);
        }
      else
        {
          fixS *fixp;
          int reloc;

          /* Now create an 8-bit fixup.  If there was some %hi, %lo
             modifier, generate the reloc accordingly.  */
          if (opmode & M6811_OP_HIGH_ADDR)
            reloc = BFD_RELOC_M68HC11_HI8;
          else if (opmode & M6811_OP_LOW_ADDR)
            reloc = BFD_RELOC_M68HC11_LO8;
          else
            reloc = BFD_RELOC_8;

          fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
            oper, FALSE, reloc);
          if (reloc != BFD_RELOC_8)
              fixp->fx_no_overflow = 1;
        }
      number_to_chars_bigendian (f, 0, 1);
    }
  else
    as_fatal (_("Operand `%x' not recognized in fixup8."), oper->X_op);
}

/* 68HC11 and 68HC12 code generation.  */

/* Translate the short branch/bsr instruction into a long branch.  */

static unsigned char
convert_branch (unsigned char code)
{
  if (IS_OPCODE (code, M6812_BSR))
    return M6812_JSR;
  else if (IS_OPCODE (code, M6811_BSR))
    return M6811_JSR;
  else if (IS_OPCODE (code, M6811_BRA))
    return (current_architecture & cpu6812) ? M6812_JMP : M6811_JMP;
  else
    as_fatal (_("Unexpected branch conversion with `%x'"), code);

  /* Keep gcc happy.  */
  return M6811_JSR;
}

/* Start a new insn that contains at least 'size' bytes.  Record the
   line information of that insn in the dwarf2 debug sections.  */
static char *
m68hc11_new_insn (int size)
{
  char *f;

  f = frag_more (size);

  dwarf2_emit_insn (size);

  return f;
}

/* Builds a jump instruction (bra, bcc, bsr).  */
static void
build_jump_insn (struct m68hc11_opcode *opcode, operand operands[],
                 int nb_operands, int jmp_mode)
{
  unsigned char code;
  char *f;
  unsigned long n;

  /* The relative branch conversion is not supported for
     brclr and brset.  */
  gas_assert ((opcode->format & M6811_OP_BITMASK) == 0);
  gas_assert (nb_operands == 1);
  gas_assert (operands[0].reg1 == REG_NONE && operands[0].reg2 == REG_NONE);

  code = opcode->opcode;

  n = operands[0].exp.X_add_number;

  /* Turn into a long branch:
     - when force long branch option (and not for jbcc pseudos),
     - when jbcc and the constant is out of -128..127 range,
     - when branch optimization is allowed and branch out of range.  */
  if ((jmp_mode == 0 && flag_force_long_jumps)
      || (operands[0].exp.X_op == O_constant
	  && (!check_range (n, opcode->format) &&
	      (jmp_mode == 1 || flag_fixed_branches == 0))))
    {
      fix_new (frag_now, frag_now_fix (), 0,
               &abs_symbol, 0, 1, BFD_RELOC_M68HC11_RL_JUMP);

      if (code == M6811_BSR || code == M6811_BRA || code == M6812_BSR)
	{
	  code = convert_branch (code);

	  f = m68hc11_new_insn (1);
	  number_to_chars_bigendian (f, code, 1);
	}
      else if (current_architecture & cpu6812)
	{
	  /* 68HC12: translate the bcc into a lbcc.  */
	  f = m68hc11_new_insn (2);
	  number_to_chars_bigendian (f, M6811_OPCODE_PAGE2, 1);
	  number_to_chars_bigendian (f + 1, code, 1);
	  fixup16 (&operands[0].exp, M6812_OP_JUMP_REL16,
		   M6812_OP_JUMP_REL16);
	  return;
	}
      else
	{
	  /* 68HC11: translate the bcc into b!cc +3; jmp <L>.  */
	  f = m68hc11_new_insn (3);
	  code ^= 1;
	  number_to_chars_bigendian (f, code, 1);
	  number_to_chars_bigendian (f + 1, 3, 1);
	  number_to_chars_bigendian (f + 2, M6811_JMP, 1);
	}
      fixup16 (&operands[0].exp, M6811_OP_IND16, M6811_OP_IND16);
      return;
    }

  /* Branch with a constant that must fit in 8-bits.  */
  if (operands[0].exp.X_op == O_constant)
    {
      if (!check_range (n, opcode->format))
	{
	  as_bad (_("Operand out of range for a relative branch: `%ld'"),
                  n);
	}
      else if (opcode->format & M6812_OP_JUMP_REL16)
	{
	  f = m68hc11_new_insn (4);
	  number_to_chars_bigendian (f, M6811_OPCODE_PAGE2, 1);
	  number_to_chars_bigendian (f + 1, code, 1);
	  number_to_chars_bigendian (f + 2, n & 0x0ffff, 2);
	}
      else
	{
	  f = m68hc11_new_insn (2);
	  number_to_chars_bigendian (f, code, 1);
	  number_to_chars_bigendian (f + 1, n & 0x0FF, 1);
	}
    }
  else if (opcode->format & M6812_OP_JUMP_REL16)
    {
      fix_new (frag_now, frag_now_fix (), 0,
               &abs_symbol, 0, 1, BFD_RELOC_M68HC11_RL_JUMP);

      f = m68hc11_new_insn (2);
      number_to_chars_bigendian (f, M6811_OPCODE_PAGE2, 1);
      number_to_chars_bigendian (f + 1, code, 1);
      fixup16 (&operands[0].exp, M6812_OP_JUMP_REL16, M6812_OP_JUMP_REL16);
    }
  else
    {
      char *op;

      fix_new (frag_now, frag_now_fix (), 0,
               &abs_symbol, 0, 1, BFD_RELOC_M68HC11_RL_JUMP);

      /* Branch offset must fit in 8-bits, don't do some relax.  */
      if (jmp_mode == 0 && flag_fixed_branches)
	{
	  op = m68hc11_new_insn (1);
	  number_to_chars_bigendian (op, code, 1);
	  fixup8 (&operands[0].exp, M6811_OP_JUMP_REL, M6811_OP_JUMP_REL);
	}

      /* bra/bsr made be changed into jmp/jsr.  */
      else if (code == M6811_BSR || code == M6811_BRA || code == M6812_BSR)
	{
          /* Allocate worst case storage.  */
	  op = m68hc11_new_insn (3);
	  number_to_chars_bigendian (op, code, 1);
	  number_to_chars_bigendian (op + 1, 0, 1);
	  frag_variant (rs_machine_dependent, 1, 1,
                        ENCODE_RELAX (STATE_PC_RELATIVE, STATE_UNDF),
                        operands[0].exp.X_add_symbol, (offsetT) n,
                        op);
	}
      else if (current_architecture & cpu6812)
	{
	  op = m68hc11_new_insn (2);
	  number_to_chars_bigendian (op, code, 1);
	  number_to_chars_bigendian (op + 1, 0, 1);
	  frag_var (rs_machine_dependent, 2, 2,
		    ENCODE_RELAX (STATE_CONDITIONAL_BRANCH_6812, STATE_UNDF),
		    operands[0].exp.X_add_symbol, (offsetT) n, op);
	}
      else
	{
	  op = m68hc11_new_insn (2);
	  number_to_chars_bigendian (op, code, 1);
	  number_to_chars_bigendian (op + 1, 0, 1);
	  frag_var (rs_machine_dependent, 3, 3,
		    ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_UNDF),
		    operands[0].exp.X_add_symbol, (offsetT) n, op);
	}
    }
}

/* Builds a dbne/dbeq/tbne/tbeq instruction.  */
static void
build_dbranch_insn (struct m68hc11_opcode *opcode, operand operands[],
                    int nb_operands, int jmp_mode)
{
  unsigned char code;
  char *f;
  unsigned long n;

  /* The relative branch conversion is not supported for
     brclr and brset.  */
  gas_assert ((opcode->format & M6811_OP_BITMASK) == 0);
  gas_assert (nb_operands == 2);
  gas_assert (operands[0].reg1 != REG_NONE);

  code = opcode->opcode & 0x0FF;

  f = m68hc11_new_insn (1);
  number_to_chars_bigendian (f, code, 1);

  n = operands[1].exp.X_add_number;
  code = operands[0].reg1;

  if (operands[0].reg1 == REG_NONE || operands[0].reg1 == REG_CCR
      || operands[0].reg1 == REG_PC)
    as_bad (_("Invalid register for dbcc/tbcc instruction."));

  if (opcode->format & M6812_OP_IBCC_MARKER)
    code |= 0x80;
  else if (opcode->format & M6812_OP_TBCC_MARKER)
    code |= 0x40;

  if (!(opcode->format & M6812_OP_EQ_MARKER))
    code |= 0x20;

  /* Turn into a long branch:
     - when force long branch option (and not for jbcc pseudos),
     - when jdbcc and the constant is out of -256..255 range,
     - when branch optimization is allowed and branch out of range.  */
  if ((jmp_mode == 0 && flag_force_long_jumps)
      || (operands[1].exp.X_op == O_constant
	  && (!check_range (n, M6812_OP_IBCC_MARKER) &&
	      (jmp_mode == 1 || flag_fixed_branches == 0))))
    {
      f = frag_more (2);
      code ^= 0x20;
      number_to_chars_bigendian (f, code, 1);
      number_to_chars_bigendian (f + 1, M6812_JMP, 1);
      fixup16 (&operands[0].exp, M6811_OP_IND16, M6811_OP_IND16);
      return;
    }

  /* Branch with a constant that must fit in 9-bits.  */
  if (operands[1].exp.X_op == O_constant)
    {
      if (!check_range (n, M6812_OP_IBCC_MARKER))
	{
	  as_bad (_("Operand out of range for a relative branch: `%ld'"),
                  n);
	}
      else
	{
	  if ((long) n < 0)
	    code |= 0x10;

	  f = frag_more (2);
	  number_to_chars_bigendian (f, code, 1);
	  number_to_chars_bigendian (f + 1, n & 0x0FF, 1);
	}
    }
  else
    {
      /* Branch offset must fit in 8-bits, don't do some relax.  */
      if (jmp_mode == 0 && flag_fixed_branches)
	{
	  fixup8 (&operands[0].exp, M6811_OP_JUMP_REL, M6811_OP_JUMP_REL);
	}

      else
	{
	  f = frag_more (2);
	  number_to_chars_bigendian (f, code, 1);
	  number_to_chars_bigendian (f + 1, 0, 1);
	  frag_var (rs_machine_dependent, 3, 3,
		    ENCODE_RELAX (STATE_XBCC_BRANCH, STATE_UNDF),
		    operands[1].exp.X_add_symbol, (offsetT) n, f);
	}
    }
}

#define OP_EXTENDED (M6811_OP_PAGE2 | M6811_OP_PAGE3 | M6811_OP_PAGE4)

/* Assemble the post index byte for 68HC12 extended addressing modes.  */

static int
build_indexed_byte (operand *op, int format ATTRIBUTE_UNUSED, int move_insn)
{
  unsigned char byte = 0;
  char *f;
  int mode;
  long val;

  val = op->exp.X_add_number;
  mode = op->mode;
  if (mode & M6812_AUTO_INC_DEC)
    {
      byte = 0x20;
      if (mode & (M6812_POST_INC | M6812_POST_DEC))
	byte |= 0x10;

      if (op->exp.X_op == O_constant)
	{
	  if (!check_range (val, mode))
	    as_bad (_("Increment/decrement value is out of range: `%ld'."),
		    val);

	  if (mode & (M6812_POST_INC | M6812_PRE_INC))
	    byte |= (val - 1) & 0x07;
	  else
	    byte |= (8 - ((val) & 7)) | 0x8;
	}

      switch (op->reg1)
	{
	case REG_NONE:
	  as_fatal (_("Expecting a register."));

	case REG_X:
	  byte |= 0;
	  break;

	case REG_Y:
	  byte |= 0x40;
	  break;

	case REG_SP:
	  byte |= 0x80;
	  break;

	default:
	  as_bad (_("Invalid register for post/pre increment."));
	  break;
	}

      f = frag_more (1);
      number_to_chars_bigendian (f, byte, 1);
      return 1;
    }

  if (mode & (M6812_OP_IDX | M6812_OP_D_IDX_2))
    {
      switch (op->reg1)
	{
	case REG_X:
	  byte = 0;
	  break;

	case REG_Y:
	  byte = 1;
	  break;

	case REG_SP:
	  byte = 2;
	  break;

	case REG_PC:
	  byte = 3;
	  break;

	default:
	  as_bad (_("Invalid register."));
	  break;
	}

      if (op->exp.X_op == O_constant)
	{
	  if (!check_range (val, M6812_OP_IDX))
	    as_bad (_("Offset out of 16-bit range: %ld."), val);

	  if (move_insn && !(val >= -16 && val <= 15) 
	      && ((!(mode & M6812_OP_IDX) && !(mode & M6812_OP_D_IDX_2)) 
		  || !(current_architecture & cpu9s12x)))
	    {
	      as_bad (_("Offset out of 5-bit range for movw/movb insn: %ld."),
		      val);
	      return -1;
	    }

	  if (val >= -16 && val <= 15 && !(mode & M6812_OP_D_IDX_2))
	    {
	      byte = byte << 6;
	      byte |= val & 0x1f;
	      f = frag_more (1);
	      number_to_chars_bigendian (f, byte, 1);
	      return 1;
	    }
	  else if (val >= -256 && val <= 255 && !(mode & M6812_OP_D_IDX_2))
	    {
	      byte = byte << 3;
	      byte |= 0xe0;
	      if (val < 0)
		byte |= 0x1;
	      f = frag_more (2);
	      number_to_chars_bigendian (f, byte, 1);
	      number_to_chars_bigendian (f + 1, val & 0x0FF, 1);
	      return 2;
	    }
	  else
	    {
	      byte = byte << 3;
	      if (mode & M6812_OP_D_IDX_2)
		byte |= 0xe3;
	      else
		byte |= 0xe2;

	      f = frag_more (3);
	      number_to_chars_bigendian (f, byte, 1);
	      number_to_chars_bigendian (f + 1, val & 0x0FFFF, 2);
	      return 3;
	    }
	}

      if (mode & M6812_OP_D_IDX_2)
        {
          byte = (byte << 3) | 0xe3;
          f = frag_more (1);
          number_to_chars_bigendian (f, byte, 1);

          fixup16 (&op->exp, 0, 0);
        }
      else if (op->reg1 != REG_PC)
	{
          symbolS *sym;
          offsetT off;

	  f = frag_more (1);
	  number_to_chars_bigendian (f, byte, 1);
          sym = op->exp.X_add_symbol;
          off = op->exp.X_add_number;
          if (op->exp.X_op != O_symbol)
            {
              sym = make_expr_symbol (&op->exp);
              off = 0;
            }

	  /* movb/movw cannot be relaxed.  */
	  if (move_insn)
	    {
	      if ((mode & M6812_OP_IDX) && (current_architecture & cpu9s12x))
		{
		  /* Must treat as a 16bit relocate as size of final result is unknown.  */

		  byte <<= 3;
		  byte |= 0xe2;
		  number_to_chars_bigendian (f, byte, 1);
		  f = frag_more (2);
		  fix_new (frag_now, f - frag_now->fr_literal, 2,
			   sym, off, 0, BFD_RELOC_M68HC12_16B);
		  return 1;
		}
	      else
		{
		  /* Non-S12X will fail at relocate stage if offset out of range.  */
		  byte <<= 6;
		  number_to_chars_bigendian (f, byte, 1);
		  fix_new (frag_now, f - frag_now->fr_literal, 1,
			   sym, off, 0, BFD_RELOC_M68HC12_5B);
		  return 1;
		}
	    }
	  else
	    {
	      number_to_chars_bigendian (f, byte, 1);
	      frag_var (rs_machine_dependent, 2, 2,
			ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_UNDF),
			sym, off, f);
	    }
	}
      else
	{
	  f = frag_more (1);

	  /* movb/movw cannot be relaxed.  */
	  if (move_insn)
	    {
	      byte <<= 6;
	      number_to_chars_bigendian (f, byte, 1);
	      fix_new (frag_now, f - frag_now->fr_literal, 1,
		       op->exp.X_add_symbol, op->exp.X_add_number, 0, BFD_RELOC_M68HC12_5B);
	      return 1;
	    }
	  else
	    {
	      number_to_chars_bigendian (f, byte, 1);
	      frag_var (rs_machine_dependent, 2, 2,
			ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_UNDF),
			op->exp.X_add_symbol,
			op->exp.X_add_number, f);
	    }
	}
      return 3;
    }

  if (mode & (M6812_OP_REG | M6812_OP_D_IDX))
    {
      if (mode & M6812_OP_D_IDX)
	{
	  if (op->reg1 != REG_D)
	    as_bad (_("Expecting register D for indexed indirect mode."));
	  if ((move_insn) && (!(current_architecture & cpu9s12x)))
	    as_bad (_("Indexed indirect mode is not allowed for movb/movw."));

	  byte = 0xE7;
	}
      else
	{
	  switch (op->reg1)
	    {
	    case REG_A:
	      byte = 0xE4;
	      break;

	    case REG_B:
	      byte = 0xE5;
	      break;

	    default:
	      as_bad (_("Invalid accumulator register."));

	    case REG_D:
	      byte = 0xE6;
	      break;
	    }
	}
      switch (op->reg2)
	{
	case REG_X:
	  break;

	case REG_Y:
	  byte |= (1 << 3);
	  break;

	case REG_SP:
	  byte |= (2 << 3);
	  break;

	case REG_PC:
	  byte |= (3 << 3);
	  break;

	default:
	  as_bad (_("Invalid indexed register."));
	  break;
	}
      f = frag_more (1);
      number_to_chars_bigendian (f, byte, 1);
      return 1;
    }

  fprintf (stderr, "mode = 0x%x\nop->reg1 = 0x%x\nop->reg2 = 0x%x\n",
	   mode, op->reg1, op->reg2);
  as_fatal (_("Addressing mode not implemented yet."));
  return 0;
}

/* Assemble the 68HC12 register mode byte.  */
static int
build_reg_mode (operand *op, int format)
{
  unsigned char byte;
  char *f;

  if ((format & M6812_OP_SEX_MARKER)
      && (op->reg1 != REG_A) && (op->reg1 != REG_B) && (op->reg1 != REG_CCR)
	  && (!(current_architecture & cpu9s12x)))
    as_bad (_("Invalid source register for this instruction, use 'tfr'."));
  else if (op->reg1 == REG_NONE || op->reg1 == REG_PC)
    as_bad (_("Invalid source register."));

  if (format & M6812_OP_SEX_MARKER
      && op->reg2 != REG_D
      && op->reg2 != REG_X && op->reg2 != REG_Y && op->reg2 != REG_SP)
    as_bad (_("Invalid destination register for this instruction, use 'tfr'."));
  else if (op->reg2 == REG_NONE || op->reg2 == REG_PC)
    as_bad (_("Invalid destination register."));

  byte = (op->reg1 << 4) | (op->reg2);
  if (format & M6812_OP_EXG_MARKER)
    byte |= 0x80;

  if ((format & M6812_OP_SEX_MARKER)
      && (op->reg1 == REG_D) && (current_architecture & cpu9s12x))
	byte |= 0x08;

  f = frag_more (1);
  number_to_chars_bigendian (f, byte, 1);
  return 1;
}

/* build_insn_xg takes a pointer to the opcode entry in the opcode table,
   the array of operand expressions and builds the corresponding instruction.  */

static void
build_insn_xg (struct m68hc11_opcode *opcode,
	       operand operands[],
	       int nb_operands ATTRIBUTE_UNUSED)
{
  char *f;
  long format;

  /* Put the page code instruction if there is one.  */
  format = opcode->format;

  if (!(operands[0].mode & (M6811_OP_LOW_ADDR | M6811_OP_HIGH_ADDR)))
    /* Need to retain those two modes, but clear for others. */
    operands[0].mode = 0;

  if (format & M68XG_OP_R_IMM8)
    {
      /* These opcodes are byte followed by imm8.  */
      f = m68hc11_new_insn (1);
      number_to_chars_bigendian (f, opcode->opcode >> 8, 1);
      fixup8_xg (&operands[0].exp, format, operands[0].mode);
    }
  else if (format & M68XG_OP_R_IMM16)
    {
      fixS *fixp;
      /* These opcodes expand into two imm8 instructions.
         Emit as low:high as per the Freescale datasheet.
         The linker requires them to be adjacent to handle the upper byte.  */

      /* Build low byte.  */
      f = m68hc11_new_insn (1);
      number_to_chars_bigendian (f, opcode->opcode >> 8, 1);
      operands[0].mode = M6811_OP_LOW_ADDR;
      f = frag_more (1);
      fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
                          &operands[0].exp, FALSE, BFD_RELOC_M68HC12_LO8XG);
      fixp->fx_no_overflow = 1;
      number_to_chars_bigendian (f, 0, 1);

      /* Build high byte.  */
      f = m68hc11_new_insn (1);
      number_to_chars_bigendian (f, (opcode->opcode >> 8) | 0x08, 1);
      operands[0].mode = M6811_OP_HIGH_ADDR;
      f = frag_more (1);
      fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
                          &operands[0].exp, FALSE, BFD_RELOC_M68HC12_HI8XG);
      fixp->fx_no_overflow = 1;
      number_to_chars_bigendian (f, 0, 1);

    }
  else if (format & M68XG_OP_REL9)
    {
      f = m68hc11_new_insn (1);
      number_to_chars_bigendian (f, opcode->opcode >> 8, 1); /* High byte.  */
      fixup8_xg (&operands[0].exp, format, M68XG_OP_REL9);
    } 
  else if (format & M68XG_OP_REL10)
    {
      f = m68hc11_new_insn (1);
      number_to_chars_bigendian (f, opcode->opcode >> 8, 1); /* High byte.  */
      fixup8_xg (&operands[0].exp, format, M68XG_OP_REL10);
    }
  else
    {
      f = m68hc11_new_insn (2);
      number_to_chars_bigendian (f, opcode->opcode, 2);
    }
  return;
}

/* build_insn takes a pointer to the opcode entry in the opcode table,
   the array of operand expressions and builds the corresponding instruction.
   This operation only deals with non relative jumps insn (need special
   handling).  */

static void
build_insn (struct m68hc11_opcode *opcode,
	    operand operands[],
            int nb_operands ATTRIBUTE_UNUSED)
{
  int i;
  char *f;
  long format;
  int move_insn = 0;

  /* Put the page code instruction if there is one.  */
  format = opcode->format;

  if (format & M6811_OP_BRANCH)
    fix_new (frag_now, frag_now_fix (), 0,
             &abs_symbol, 0, 1, BFD_RELOC_M68HC11_RL_JUMP);

  if (format & OP_EXTENDED)
    {
      int page_code;

      f = m68hc11_new_insn (2);
      if (format & M6811_OP_PAGE2)
	page_code = M6811_OPCODE_PAGE2;
      else if (format & M6811_OP_PAGE3)
	page_code = M6811_OPCODE_PAGE3;
      else
	page_code = M6811_OPCODE_PAGE4;

      number_to_chars_bigendian (f, page_code, 1);
      f++;
    }
  else
    f = m68hc11_new_insn (1);

  number_to_chars_bigendian (f, opcode->opcode, 1);

  i = 0;

  /* The 68HC12 movb and movw instructions are special.  We have to handle
     them in a special way.  */
  if (format & (M6812_OP_IND16_P2 | M6812_OP_IDX_P2))
    {
      move_insn = 1;
      if (format & M6812_OP_IDX)
	{
	  build_indexed_byte (&operands[0], format, 1);
	  i = 1;
	  format &= ~M6812_OP_IDX;
	}
      if (format & M6812_OP_IDX_P2)
	{
	  build_indexed_byte (&operands[1], format, 1);
	  i = 0;
	  format &= ~M6812_OP_IDX_P2;
	}
    }

  if (format & (M6811_OP_DIRECT | M6811_OP_IMM8))
    {
      fixup8 (&operands[i].exp,
	      format & (M6811_OP_DIRECT | M6811_OP_IMM8 | M6812_OP_TRAP_ID),
	      operands[i].mode);
      i++;
    }
  else if (IS_CALL_SYMBOL (format) && nb_operands == 1)
    {
      format &= ~M6812_OP_PAGE;
      fixup24 (&operands[i].exp, format & M6811_OP_IND16,
	       operands[i].mode);
      i++;
    }
  else if (format & (M6811_OP_IMM16 | M6811_OP_IND16))
    {
      fixup16 (&operands[i].exp,
               format & (M6811_OP_IMM16 | M6811_OP_IND16 | M6812_OP_PAGE),
	       operands[i].mode);
      i++;
    }
  else if (format & (M6811_OP_IX | M6811_OP_IY))
    {
      if ((format & M6811_OP_IX) && (operands[0].reg1 != REG_X))
	as_bad (_("Invalid indexed register, expecting register X."));
      if ((format & M6811_OP_IY) && (operands[0].reg1 != REG_Y))
	as_bad (_("Invalid indexed register, expecting register Y."));

      fixup8 (&operands[0].exp, M6811_OP_IX, operands[0].mode);
      i = 1;
    }
  else if (format &
	   (M6812_OP_IDX | M6812_OP_IDX_2 | M6812_OP_IDX_1
            | M6812_OP_D_IDX | M6812_OP_D_IDX_2))
    {
      build_indexed_byte (&operands[i], format, move_insn);
      i++;
    }
  else if (format & M6812_OP_REG && current_architecture & cpu6812)
    {
      build_reg_mode (&operands[i], format);
      i++;
    }
  if (format & M6811_OP_BITMASK)
    {
      fixup8 (&operands[i].exp, M6811_OP_BITMASK, operands[i].mode);
      i++;
    }
  if (format & M6811_OP_JUMP_REL)
    {
      fixup8 (&operands[i].exp, M6811_OP_JUMP_REL, operands[i].mode);
    }
  else if (format & M6812_OP_IND16_P2)
    {
      fixup16 (&operands[1].exp, M6811_OP_IND16, operands[1].mode);
    }
  if (format & M6812_OP_PAGE)
    {
      fixup8 (&operands[i].exp, M6812_OP_PAGE, operands[i].mode);
    }
}

/* Opcode identification and operand analysis.  */

/* find() gets a pointer to an entry in the opcode table.  It must look at all
   opcodes with the same name and use the operands to choose the correct
   opcode.  Returns the opcode pointer if there was a match and 0 if none.  */
static struct m68hc11_opcode *
find (struct m68hc11_opcode_def *opc, operand operands[], int nb_operands)
{
  int i, match, pos;
  struct m68hc11_opcode *opcode;
  struct m68hc11_opcode *op_indirect;

  op_indirect = 0;
  opcode = opc->opcode;

  /* Now search the opcode table table for one with operands
     that matches what we've got.  */

  if (current_architecture & cpuxgate)
    {
      /* Many XGATE insns are simple enough that we get an exact match.  */
      for (pos = match = 0; match == 0 && pos < opc->nb_modes; pos++, opcode++)
        if (opcode->format == operands[nb_operands-1].mode)
	  return opcode;

      return 0;
    }

  /* Non XGATE */

  /* Now search the opcode table table for one with operands
     that matches what we've got.  We're only done if the operands matched so
     far AND there are no more to check.  */
  for (pos = match = 0; match == 0 && pos < opc->nb_modes; pos++, opcode++)
    {
      int poss_indirect = 0;
      long format = opcode->format;
      int expect;

      expect = 0;
      if (opcode->format & M6811_OP_MASK)
	expect++;
      if (opcode->format & M6811_OP_BITMASK)
	expect++;
      if (opcode->format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
	expect++;
      if (opcode->format & (M6812_OP_IND16_P2 | M6812_OP_IDX_P2))
	expect++;
      if ((opcode->format & M6812_OP_PAGE)
          && (!IS_CALL_SYMBOL (opcode->format) || nb_operands == 2))
        expect++;

      for (i = 0; expect == nb_operands && i < nb_operands; i++)
	{
	  int mode = operands[i].mode;

	  if (mode & M6811_OP_IMM16)
	    {
	      if (format &
		  (M6811_OP_IMM8 | M6811_OP_IMM16 | M6811_OP_BITMASK))
		continue;
	      break;
	    }
	  if (mode == M6811_OP_DIRECT)
	    {
	      if (format & M6811_OP_DIRECT)
		continue;

	      /* If the operand is a page 0 operand, remember a
	         possible <abs-16> addressing mode.  We mark
	         this and continue to check other operands.  */
	      if (format & M6811_OP_IND16
		  && flag_strict_direct_addressing && op_indirect == 0)
		{
		  poss_indirect = 1;
		  continue;
		}
	      break;
	    }
	  if (mode & M6811_OP_IND16)
	    {
	      if (i == 0 && (format & M6811_OP_IND16) != 0)
		continue;
              if (i != 0 && (format & M6812_OP_PAGE) != 0)
                continue;
	      if (i != 0 && (format & M6812_OP_IND16_P2) != 0)
		continue;
	      if (i == 0 && (format & M6811_OP_BITMASK))
		break;
	    }
	  if (mode & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
	    {
	      if (format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
		continue;
	    }
	  if (mode & M6812_OP_REG)
	    {
	      if (i == 0
		  && (format & M6812_OP_REG)
		  && (operands[i].reg2 == REG_NONE))
		continue;
	      if (i == 0
		  && (format & M6812_OP_REG)
		  && (format & M6812_OP_REG_2)
		  && (operands[i].reg2 != REG_NONE))
		continue;
	      if (i == 0
		  && (format & M6812_OP_IDX)
		  && (operands[i].reg2 != REG_NONE))
		continue;
	      if (i == 0
		  && (format & M6812_OP_IDX)
		  && (format & (M6812_OP_IND16_P2 | M6812_OP_IDX_P2)))
		continue;
	      if (i == 1
		  && (format & M6812_OP_IDX_P2))
		continue;
	      break;
	    }
	  if (mode & M6812_OP_IDX)
	    {
	      if (format & M6811_OP_IX && operands[i].reg1 == REG_X)
		continue;
	      if (format & M6811_OP_IY && operands[i].reg1 == REG_Y)
		continue;
	      if (i == 0
		  && format & (M6812_OP_IDX | M6812_OP_IDX_1 | M6812_OP_IDX_2)
		  && (operands[i].reg1 == REG_X
		      || operands[i].reg1 == REG_Y
		      || operands[i].reg1 == REG_SP
		      || operands[i].reg1 == REG_PC))
		continue;
	      if (i == 1 && (format & M6812_OP_IDX_P2))
		continue;
	    }
          if (mode & format & (M6812_OP_D_IDX | M6812_OP_D_IDX_2))
            {
              if (i == 0)
                continue;
            }
	  if (mode & M6812_AUTO_INC_DEC)
	    {
	      if (i == 0
		  && format & (M6812_OP_IDX | M6812_OP_IDX_1 |
			       M6812_OP_IDX_2))
		continue;
	      if (i == 1 && format & M6812_OP_IDX_P2)
		continue;
	    }
	  break;
	}
      match = i == nb_operands;

      /* Operands are ok but an operand uses page 0 addressing mode
         while the insn supports abs-16 mode.  Keep a reference to this
         insns in case there is no insn supporting page 0 addressing.  */
      if (match && poss_indirect)
	{
	  op_indirect = opcode;
	  match = 0;
	}
      if (match)
	break;
    }

  /* Page 0 addressing is used but not supported by any insn.
     If absolute addresses are supported, we use that insn.  */
  if (match == 0 && op_indirect)
    {
      opcode = op_indirect;
      match = 1;
    }

  return match ? opcode : 0;
}

/* Find the real opcode and its associated operands.  We use a progressive
   approach here.  On entry, 'opc' points to the first opcode in the
   table that matches the opcode name in the source line.  We try to
   isolate an operand, find a possible match in the opcode table.
   We isolate another operand if no match were found.  The table 'operands'
   is filled while operands are recognized.

   Returns the opcode pointer that matches the opcode name in the
   source line and the associated operands.  */
static struct m68hc11_opcode *
find_opcode (struct m68hc11_opcode_def *opc, operand operands[],
             int *nb_operands)
{
  struct m68hc11_opcode *opcode;
  int i;

  if (opc->max_operands == 0)
    {
      *nb_operands = 0;
      return opc->opcode;
    }

  for (i = 0; i < opc->max_operands;)
    {
      int result;

      result = get_operand (&operands[i], i, opc->format);
      if (result <= 0)
	return 0;

      /* Special case where the bitmask of the bclr/brclr
         instructions is not introduced by #.
         Example: bclr 3,x $80.  */
      if (i == 1 && (opc->format & M6811_OP_BITMASK)
	  && (operands[i].mode & M6811_OP_IND16))
	{
	  operands[i].mode = M6811_OP_IMM16;
	}

      i += result;
      *nb_operands = i;
      if (i >= opc->min_operands)
	{
	  opcode = find (opc, operands, i);

          /* Another special case for 'call foo,page' instructions.
             Since we support 'call foo' and 'call foo,page' we must look
             if the optional page specification is present otherwise we will
             assemble immediately and treat the page spec as garbage.  */
          if (opcode && !(opcode->format & M6812_OP_PAGE))
             return opcode;

	  if (opcode && *input_line_pointer != ',')
	    return opcode;
	}

      if (*input_line_pointer == ',')
	input_line_pointer++;
    }

  return 0;
}

#define M6812_XBCC_MARKER (M6812_OP_TBCC_MARKER \
                           | M6812_OP_DBCC_MARKER \
                           | M6812_OP_IBCC_MARKER)

/* Gas line assembler entry point.  */

/* This is the main entry point for the machine-dependent assembler.  str
   points to a machine-dependent instruction.  This function is supposed to
   emit the frags/bytes it assembles to.  */
void
md_assemble (char *str)
{
  struct m68hc11_opcode_def *opc;
  struct m68hc11_opcode *opcode;

  struct m68hc11_opcode opcode_local;
  unsigned char *op_start, *op_end;
  char *save;
  char name[20];
  int nlen = 0;
  operand operands[M6811_MAX_OPERANDS];
  int nb_operands = 0;
  int branch_optimize = 0;
  int alias_id = -1;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the opcode end and get the opcode in 'name'.  The opcode is forced
     lower case (the opcode table only has lower case op-codes).  */
  for (op_start = op_end = (unsigned char *) str;
       *op_end && !is_end_of_line[*op_end] && *op_end != ' ';
       op_end++)
    {
      name[nlen] = TOLOWER (op_start[nlen]);
      nlen++;
      if (nlen == sizeof (name) - 1)
	break;
    }
  name[nlen] = 0;

  if (nlen == 0)
    {
      as_bad (_("No instruction or missing opcode."));
      return;
    }

  if (current_architecture == cpuxgate)
    {
      /* Find the opcode definition given its name.  */
      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);
      if (opc == NULL)
        {
          as_bad (_("Opcode `%s' is not recognized."), name);
          return;
        }

      /* Grab a local copy. */
      opcode_local.name = opc->opcode->name;
      /* These will be incomplete where multiple variants exist. */
      opcode_local.opcode = opc->opcode->opcode;
      opcode_local.format = opc->opcode->format;

      save = input_line_pointer;
      input_line_pointer = (char *) op_end;

      if (opc->format == M68XG_OP_NONE)
        {
          /* No special handling required. */
          opcode_local.format = M68XG_OP_NONE;
          build_insn_xg (opc->opcode, operands, 0);
          return;
        }

      /* Special handling of TFR. */
      if (strncmp (opc->opcode->name, "tfr",3) == 0)
        {
          /* There must be two operands with a comma. */
          input_line_pointer = skip_whites (input_line_pointer);
          operands[0].reg1 = register_name ();
          if (operands[0].reg1 == REG_NONE)
            {
              as_bad ("Invalid register\n");
              return;
            }
          input_line_pointer = skip_whites (input_line_pointer);
          if (*input_line_pointer != ',')
            {
              as_bad ("Missing comma.\n");
              return;
            }
          input_line_pointer++;
          input_line_pointer = skip_whites (input_line_pointer);
          operands[1].reg1 = register_name ();
          if (operands[1].reg1 == REG_NONE)
            {
              as_bad ("Invalid register\n");
              return;
            }
          input_line_pointer = skip_whites (input_line_pointer);
          if (*input_line_pointer != '\n' && *input_line_pointer)
            {
              as_bad (_("Garbage at end of instruction: `%s'."),
		      input_line_pointer);
              return;
            }
          if (operands[1].reg1 == REG_CCR) /* ,CCR */
	    opc->opcode->opcode = 0x00f8 | ( operands[0].reg1 << 8);
          else if (operands[0].reg1 == REG_CCR) /* CCR, */
	    opc->opcode->opcode = 0x00f9 | ( operands[1].reg1 << 8);
          else if (operands[1].reg1 == REG_PC) /* ,PC */
	    opc->opcode->opcode = 0x00fa | ( operands[0].reg1 << 8);
          else
            {
              as_bad ("Invalid operand to TFR\n");
              return;
            }
          /* no special handling required */
          opcode_local.format = M68XG_OP_NONE;
          opcode_local.opcode = opc->opcode->opcode;
          build_insn_xg (&opcode_local, operands, 0);
          return;
	}

      /* CSEM, SSEM */
      if (opc->format & M68XG_OP_IMM3)
        {
	  /* Either IMM3 or R */
          input_line_pointer = skip_whites (input_line_pointer);
          if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r'))
            {
              operands[0].reg1 = register_name ();
              if (operands[0].reg1 == REG_NONE)
                {
                  as_bad ("Invalid register\n");
                  return;
                }
              operands[0].mode = M68XG_OP_R;
              /* One opcode has multiple modes, so find right one. */
              opcode = find (opc, operands, 1);
              if (opcode)
              	{
                  opcode_local.opcode = opcode->opcode
		    | (operands[0].reg1 << 8);
                  opcode_local.format = M68XG_OP_NONE;
                  build_insn_xg (&opcode_local, operands, 1);
		}
	      else
		as_bad ("No opcode found\n");
              
              return;
            }
          else
            {
              if (*input_line_pointer == '#')
                input_line_pointer++;

              expression (&operands[0].exp);
              if (operands[0].exp.X_op == O_illegal)
              	{
                  as_bad (_("Illegal operand."));
                  return;
              	}
              else if (operands[0].exp.X_op == O_absent)
              	{
                  as_bad (_("Missing operand."));
                  return;
              	}

              if (check_range (operands[0].exp.X_add_number,M68XG_OP_IMM3))
              	{
		  opcode_local.opcode |= (operands[0].exp.X_add_number);
		  operands[0].mode = M68XG_OP_IMM3;
  
		  opcode = find (opc, operands, 1);
                  if (opcode)
                    {
		      opcode_local.opcode = opcode->opcode;
		      opcode_local.opcode
			|= (operands[0].exp.X_add_number) << 8;
		      opcode_local.format = M68XG_OP_NONE;
		      build_insn_xg (&opcode_local, operands, 1);
                    }
                  else
                    as_bad ("No opcode found\n");

                  return;
                }
              else
                {
                  as_bad ("Number out of range for IMM3\n");
                  return;
                }
            }
	}

      /* Special handling of SIF. */
      if (strncmp (opc->opcode->name, "sif",3) == 0)
        {
          /* Either OP_NONE or OP_RS. */
          if (*input_line_pointer != '\n')
	    input_line_pointer = skip_whites (input_line_pointer);

          if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r')
              || (*input_line_pointer == '\0'))
	    opc->opcode->opcode = 0x0300;
          else
            {
              operands[0].reg1 = register_name ();
              if (operands[0].reg1 == REG_NONE)
		{
                  as_bad ("Invalid register\n");
                  return;
		}
              opcode_local.opcode = 0x00f7 | (operands[0].reg1 << 8);
            }
          opcode_local.format = M68XG_OP_NONE;
          build_insn_xg (&opcode_local, operands, 0);
          return;
        }

      /* SEX, PAR, JAL plus aliases NEG, TST, COM */
      if (opc->format & M68XG_OP_R)
        {
          input_line_pointer = skip_whites (input_line_pointer);
          operands[0].reg1 = register_name ();
          if (operands[0].reg1 == REG_NONE)
            {
              as_bad ("Invalid register\n");
              return;
            }
          if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r')
              || (*input_line_pointer == '\0'))
            {
              /* Likely to be OP R. */
              if (opc->format & M68XG_OP_R)
                {
                  operands[0].mode = M68XG_OP_R;

                  opcode = find (opc, operands, 1);
                  if (opcode)
		    {
                      if ((strncmp (opc->opcode->name, "com",3) == 0)
                          || (strncmp (opc->opcode->name, "neg",3) == 0))
                        /* Special case for com RD as alias for sub RD,R0,RS */
                        /* Special case for neg RD as alias for sub RD,R0,RS */
                        opcode_local.opcode = opcode->opcode
                          | (operands[0].reg1 << 8) | (operands[0].reg1 << 2);
		      else if (strncmp (opc->opcode->name, "tst",3) == 0)
                        /* Special case for tst RS alias for sub R0, RS, R0 */
                        opcode_local.opcode = opcode->opcode
                          | (operands[0].reg1 << 5);
                      else
                        opcode_local.opcode |= (operands[0].reg1 << 8);
                    }
                  opcode_local.format = M68XG_OP_NONE;
                  build_insn_xg (&opcode_local, operands, 0);
                }
              else
		as_bad ("No valid mode found\n");

              return;
            }
        }

      if (opc->format & (M68XG_OP_REL9 | M68XG_OP_REL10))
        {
          opcode_local.format = opc->format; 
          input_line_pointer = skip_whites (input_line_pointer);
          expression (&operands[0].exp);
          if (operands[0].exp.X_op == O_illegal)
            {
              as_bad (_("Illegal operand."));
              return;
            }
          else if (operands[0].exp.X_op == O_absent)
            {
              as_bad (_("Missing operand."));
              return;
            }
          opcode_local.opcode = opc->opcode->opcode;
          build_insn_xg (&opcode_local, operands, 1);
          return;
        }


      /* For other command formats, parse input line and determine the mode
         we are using as we go. */

      input_line_pointer = skip_whites (input_line_pointer);
      if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r')
          || (*input_line_pointer == '\0'))
        return; /* nothing left */
      
      if (*input_line_pointer == '#')
        {
          as_bad ("No register specified before hash\n");
          return;
        } 

      /* first operand is expected to be a register */
      if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r'))
        {
          operands[0].reg1 = register_name ();
          if (operands[0].reg1 == REG_NONE)
            {
              as_bad ("Invalid register\n");
              return;
            }
        }

      input_line_pointer = skip_whites (input_line_pointer);
      if (*input_line_pointer != ',')
        {
          as_bad ("Missing operand\n");
          return;
        }
      input_line_pointer++;
      input_line_pointer = skip_whites (input_line_pointer);

      if (*input_line_pointer == '#')
        {
          /* Some kind of immediate mode, check if this is possible. */
          if (!(opc->format
		& (M68XG_OP_R_IMM8 | M68XG_OP_R_IMM16 | M68XG_OP_R_IMM4)))
            as_bad ("Invalid immediate mode for `%s'", opc->opcode->name);
          else
            {
              input_line_pointer++;
              input_line_pointer = skip_whites (input_line_pointer);
              if (strncmp (input_line_pointer, "%hi", 3) == 0)
                {
                  input_line_pointer += 3;
                  operands[0].mode = M6811_OP_HIGH_ADDR;
                }
              else if (strncmp (input_line_pointer, "%lo", 3) == 0)
                {
		  input_line_pointer += 3;
		  operands[0].mode = M6811_OP_LOW_ADDR;
                }
              else
		operands[0].mode = 0;

              expression (&operands[0].exp);
              if (operands[0].exp.X_op == O_illegal)
                {
                  as_bad (_("Illegal operand."));
                  return;
                }
              else if (operands[0].exp.X_op == O_absent)
                {
                  as_bad (_("Missing operand."));
                  return;
                }
              /* ok so far, can only be one mode */
              opcode_local.format = opc->format
		& (M68XG_OP_R_IMM8 | M68XG_OP_R_IMM16 | M68XG_OP_R_IMM4);
              if (opcode_local.format & M68XG_OP_R_IMM4)
                {
                  operands[0].mode = M68XG_OP_R_IMM4;
                  /* same opcodes have multiple modes, so find right one */
                  opcode = find (opc, operands, 1);
                  if (opcode)
		    opcode_local.opcode = opcode->opcode
		      | (operands[0].reg1 << 8);
                  
                  if (operands[0].exp.X_op != O_constant)
                    as_bad ("Only constants supported at for IMM4 mode\n");
                  else
                    {
                      if (check_range 
                          (operands[0].exp.X_add_number,M68XG_OP_R_IMM4))
                        opcode_local.opcode
			  |= (operands[0].exp.X_add_number << 4);
                      else
                        as_bad ("Number out of range for IMM4\n");
                    }
                  opcode_local.format = M68XG_OP_NONE;
                }
              else if (opcode_local.format & M68XG_OP_R_IMM16)
                {
                  operands[0].mode = M68XG_OP_R_IMM16;

                  opcode = find (opc, operands, 1);
                  if (opcode)
                    {
                      opcode_local.opcode = opcode->opcode
			| (operands[0].reg1 << 8);
                    }
                }
              else
                {
                  opcode_local.opcode = opc->opcode->opcode
		    | (operands[0].reg1 << 8);
                }
              build_insn_xg (&opcode_local, operands, 1);
            }
        }
      else if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r'))
        {
          /* we've got as far as OP R, R */
          operands[1].reg1 = register_name ();
          if (operands[1].reg1 == REG_NONE)
            {
              as_bad ("Invalid register\n");
              return;
            }
          if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r')
	      || (*input_line_pointer == '\0'))
            {
              /* looks like OP_R_R */
              if (opc->format & M68XG_OP_R_R)
                {
                  operands[0].mode = M68XG_OP_R_R;
                  /* same opcodes have multiple modes, so find right one */
                  opcode = find (opc, operands, 1);
                  if (opcode)
                    {
                      if ((strncmp (opc->opcode->name, "com",3) == 0)
			  || (strncmp (opc->opcode->name, "mov",3) == 0)
			  || (strncmp (opc->opcode->name, "neg",3) == 0))
                        {
                          /* Special cases for:
                             com RD, RS alias for xnor RD,R0,RS
                             mov RD, RS alias for or RD, R0, RS
                             neg RD, RS alias for sub RD, R0, RS */
                          opcode_local.opcode = opcode->opcode 
                            | (operands[0].reg1 << 8) | (operands[1].reg1 << 2);
                        }
                      else if ((strncmp (opc->opcode->name, "cmp",3) == 0)
			       || (strncmp (opc->opcode->name, "cpc",3) == 0))
                        {
                          /* special cases for:
                             cmp RS1, RS2 alias for sub R0, RS1, RS2
                             cpc RS1, RS2 alias for sbc R0, RS1, RS2 */
                          opcode_local.opcode = opcode->opcode 
			    | (operands[0].reg1 << 5) | (operands[1].reg1 << 2);
                        }
                      else
                        {
                          opcode_local.opcode = opcode->opcode
                            | (operands[0].reg1 << 8) | (operands[1].reg1 << 5);
                        }
                      opcode_local.format = M68XG_OP_NONE;
                      build_insn_xg (&opcode_local, operands, 1);
                    }
                }
              else
                {
                  as_bad ("No valid mode found\n");
                }
            }
          else
            {
              /* more data */
              if (*input_line_pointer != ',')
                {
                  as_bad (_("Missing operand."));
                  return;
                }
              input_line_pointer++;
              input_line_pointer = skip_whites (input_line_pointer);
              if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r'))
                {
                  operands[2].reg1 = register_name ();
                  if (operands[2].reg1 == REG_NONE)
                    {
                      as_bad ("Invalid register\n");
                      return;
                    }
                  if (opc->format & M68XG_OP_R_R_R)
                    {
                      operands[0].mode = M68XG_OP_R_R_R;

                      opcode = find (opc, operands, 1);
                      if (opcode)
                        {
                          opcode_local.opcode = opcode->opcode 
                            | (operands[0].reg1 << 8) | (operands[1].reg1 << 5)
                            | (operands[2].reg1 << 2);
                          opcode_local.format = M68XG_OP_NONE;
                          build_insn_xg (&opcode_local, operands, 1);
                        }
                    }
                  else
                    {
                      as_bad ("No valid mode found\n");
                    }
                }
            }
        }
      else if (*input_line_pointer == '(') /* Indexed modes */
        {
          input_line_pointer++;
          input_line_pointer = skip_whites (input_line_pointer);
          if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r'))
            {
              /* we've got as far as OP R, (R */
              operands[1].reg1 = register_name ();
              if (operands[1].reg1 == REG_NONE)
                {
                  as_bad ("Invalid register\n");
                  return;
                }

              if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r')
		  || (*input_line_pointer == '\0'))
                {
                  /* Looks like OP_R_R. */
                  as_bad (_("Missing operand."));
                  return;
                }

              input_line_pointer = skip_whites (input_line_pointer);
              
              if (*input_line_pointer != ',')
                {
                  as_bad (_("Missing operand."));
                  return;
                }
              input_line_pointer++;
              input_line_pointer = skip_whites (input_line_pointer);

              if (*input_line_pointer == '#')
                {
                  input_line_pointer++;
                  input_line_pointer = skip_whites (input_line_pointer);
                  expression (&operands[0].exp);
                  if (operands[0].exp.X_op == O_illegal)
                    {
                      as_bad (_("Illegal operand."));
                      return;
                    }
                  else if (operands[0].exp.X_op == O_absent)
                    {
                      as_bad (_("Missing operand."));
                      return;
                    }

                  input_line_pointer = skip_whites (input_line_pointer);
                  if (*input_line_pointer != ')')
                    {
		      as_bad ("Missing `)' to close register indirect operand.");
                      return;
                    }
                  else
                    {
                      input_line_pointer++;
                    }
                      
                  /* Ok so far, can only be one mode. */
                  opcode_local.format = M68XG_OP_R_R_OFFS5;
                  operands[0].mode = M68XG_OP_R_R_OFFS5;

                  opcode = find (opc, operands, 1);
                  if (opcode)
                    {
                      opcode_local.opcode = opcode->opcode
                        | (operands[0].reg1 << 8) | (operands[1].reg1 << 5);
                      if (operands[0].exp.X_op != O_constant)
                        {
                          as_bad
                            ("Only constants supported for indexed OFFS5 mode\n");
                        }
                      else
                        {
                          if (check_range (operands[0].exp.X_add_number,
					   M68XG_OP_R_R_OFFS5))
                            {
                              opcode_local.opcode
				|= (operands[0].exp.X_add_number);
                              opcode_local.format = M68XG_OP_NONE;
                              build_insn_xg (&opcode_local, operands, 1);
                            }
                          else
                            {
                              as_bad ("Number out of range for OFFS5\n");
                            }
                        }
                    }
                }
              else
                {
                  operands[0].mode = M68XG_OP_RD_RB_RI;

                  if (*input_line_pointer == '-')
                    {
                      operands[0].mode = M68XG_OP_RD_RB_mRI;
                      input_line_pointer++;
                    }
                  operands[2].reg1 = register_name ();
                  if (operands[2].reg1 == REG_NONE)
                    {
                      as_bad ("Invalid register\n");
                      return;
                    }

                  if (*input_line_pointer == '+')
                    {
                      if (opcode_local.format == M68XG_OP_RD_RB_mRI)
                        {
                          as_bad (_("Illegal operand."));
                          return;
                        }
                      operands[0].mode = M68XG_OP_RD_RB_RIp;
                      input_line_pointer++;
                    }

                  input_line_pointer = skip_whites (input_line_pointer);
                  if (*input_line_pointer != ')')
                    {
		      as_bad
                        ("Missing `)' to close register indirect operand.");
                      return;
                    }
                  else
                    {
                      input_line_pointer++;
                    }

                  opcode = find (opc, operands, 1);
                  if (opcode)
                    {
                      opcode_local.opcode = opcode->opcode
                        | (operands[0].reg1 << 8) | (operands[1].reg1 << 5)
                        | (operands[2].reg1 << 2);
                      opcode_local.format = M68XG_OP_NONE;
                      build_insn_xg (&opcode_local, operands, 1);
                    }
                  else
                    {
                      as_bad ("Failed to find opcode for %s %s\n",
			      opc->opcode->name, (char *)op_end);
                    }
                }
            }
        }
      else
        {
	  as_bad (_("Failed to find a valid mode for `%s'."),
		  opc->opcode->name);
        }

      if (opc->opcode && !flag_mri)
        {
          char *p = input_line_pointer;

          while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r')
	    p++;

          if (*p != '\n' && *p)
            as_bad (_("Garbage at end of instruction: `%s'."), p);
        }

      input_line_pointer = save;

      /* Opcode is known but does not have valid operands.  Print out the
         syntax for this opcode.  */
      if (opc->opcode == 0)
        {
          if (flag_print_insn_syntax)
            print_insn_format (name);

          as_bad (_("Invalid operand for `%s'"), name);
          return;
        }

      return;
    }

  /* Find the opcode definition given its name.  */
  opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);

  /* If it's not recognized, look for 'jbsr' and 'jbxx'.  These are
     pseudo insns for relative branch.  For these branches, we always
     optimize them (turned into absolute branches) even if --short-branches
     is given.  */
  if (opc == NULL && name[0] == 'j' && name[1] == 'b')
    {
      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, &name[1]);
      if (opc
	  && (!(opc->format & M6811_OP_JUMP_REL)
	      || (opc->format & M6811_OP_BITMASK)))
	opc = 0;
      if (opc)
	branch_optimize = 1;
    }

  /* The following test should probably be removed.  This does not conform
     to Motorola assembler specs.  */
  if (opc == NULL && flag_mri)
    {
      if (*op_end == ' ' || *op_end == '\t')
	{
	  while (*op_end == ' ' || *op_end == '\t')
	    op_end++;

	  if (nlen < 19
	      && (*op_end &&
		  (is_end_of_line[op_end[1]]
		   || op_end[1] == ' ' || op_end[1] == '\t'
		   || !ISALNUM (op_end[1])))
	      && (*op_end == 'a' || *op_end == 'b'
		  || *op_end == 'A' || *op_end == 'B'
		  || *op_end == 'd' || *op_end == 'D'
		  || *op_end == 'x' || *op_end == 'X'
		  || *op_end == 'y' || *op_end == 'Y'))
	    {
	      name[nlen++] = TOLOWER (*op_end++);
	      name[nlen] = 0;
	      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash,
							     name);
	    }
	}
    }

  /* Identify a possible instruction alias.  There are some on the
     68HC12 to emulate a few 68HC11 instructions.  */
  if (opc == NULL && (current_architecture & cpu6812))
    {
      int i;

      for (i = 0; i < m68hc12_num_alias; i++)
	if (strcmp (m68hc12_alias[i].name, name) == 0)
	  {
	    alias_id = i;
	    break;
	  }
    }
  if (opc == NULL && alias_id < 0)
    {
      as_bad (_("Opcode `%s' is not recognized."), name);
      return;
    }
  save = input_line_pointer;
  input_line_pointer = (char *) op_end;

  if (opc)
    {
      opc->used++;
      opcode = find_opcode (opc, operands, &nb_operands);
    }
  else
    opcode = 0;

  if ((opcode || alias_id >= 0) && !flag_mri)
    {
      char *p = input_line_pointer;

      while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r')
	p++;

      if (*p != '\n' && *p)
	as_bad (_("Garbage at end of instruction: `%s'."), p);
    }

  input_line_pointer = save;

  if (alias_id >= 0)
    {
      char *f = m68hc11_new_insn (m68hc12_alias[alias_id].size);

      number_to_chars_bigendian (f, m68hc12_alias[alias_id].code1, 1);
      if (m68hc12_alias[alias_id].size > 1)
	number_to_chars_bigendian (f + 1, m68hc12_alias[alias_id].code2, 1);

      return;
    }

  /* Opcode is known but does not have valid operands.  Print out the
     syntax for this opcode.  */
  if (opcode == 0)
    {
      if (flag_print_insn_syntax)
	print_insn_format (name);

      if (((strcmp (name, "movb") == 0) || (strcmp (name, "movw") == 0))
	  && (current_architecture & cpu9s12x))
	{
	  char *f;
	  int movb;
	  if (strcmp (name, "movb") == 0)
	    movb = 8;
	  else
	    movb = 0;

	  /* The existing operand extract code fell over if these additional modes
	     were enabled in m68hc11-opc.c. So they are commented there and
	     decoded here instead.  */

	  if (operands[1].mode & (M6812_OP_IDX | M6812_OP_IDX_1
				  | M6812_OP_IDX_2 | M6812_OP_D_IDX | M6812_OP_D_IDX_2 | M6812_PRE_INC
				  | M6812_PRE_DEC | M6812_POST_INC | M6812_POST_DEC ))
	    {
	      /* first check if valid mode then start building it up */
	      if (operands[0].mode & (M6811_OP_IMM8 | M6811_OP_IMM16
				      | M6811_OP_IND16 | M6812_OP_IDX | M6812_OP_IDX_1
				      | M6812_OP_IDX_2 | M6812_OP_D_IDX | M6812_OP_D_IDX_2))
		{
		  int opr16a;
		  if (operands[1].mode & (M6811_OP_IND16))
		    opr16a = 3;
		  else
		    opr16a = 0;

		  f = m68hc11_new_insn (2);

		  if (operands[0].mode & (M6811_OP_IMM8 | M6811_OP_IMM16))
		    {
		      number_to_chars_bigendian (f, 0x1800 + movb + opr16a, 2);
		      build_indexed_byte (&operands[1], operands[1].mode, 1);
		      if (movb)
			fixup8 (&operands[0].exp, M6811_OP_IMM8,
				operands[0].mode);
		      else
			fixup16 (&operands[0].exp, M6811_OP_IMM16,
				 operands[0].mode);

		      return;
		    }
		  else if (operands[0].mode & M6811_OP_IND16)
		    {
		      number_to_chars_bigendian (f, 0x1801 + movb + opr16a, 2);
		      build_indexed_byte (&operands[1], operands[1].mode, 1);
		      fixup16 (&operands[0].exp, M6811_OP_IND16, operands[0].mode);
		      return;
		    }
		  else
		    {
		      number_to_chars_bigendian (f, 0x1802 + movb + opr16a, 2);
		      build_indexed_byte (&operands[0], operands[0].mode, 1);
		      build_indexed_byte (&operands[1], operands[1].mode, 1);
		      return;
		    }
		}
	    }
	  else if (operands[1].mode & M6811_OP_IND16)
	    {
	      /* First check if this is valid mode, then start building it up. */
	      if (operands[0].mode & (M6811_OP_IMM8 | M6811_OP_IMM16
				      | M6811_OP_IND16 | M6812_OP_IDX | M6812_OP_IDX_1
				      | M6812_OP_IDX_2 | M6812_OP_D_IDX | M6812_OP_D_IDX_2))
		{
		  int opr16a;
		  if (operands[1].mode & (M6811_OP_IND16))
		    opr16a = 3;
		  else
		    opr16a = 0;

		  f = m68hc11_new_insn (2);

		  /* The first two cases here should actually be covered by the
		     normal operand code. */
		  if (operands[0].mode & (M6811_OP_IMM8 | M6811_OP_IMM16))
		    {
		      number_to_chars_bigendian (f, 0x1800 + movb + opr16a, 2);
		      if (movb)
			fixup8 (&operands[0].exp, M6811_OP_IMM8, operands[0].mode);
		      else
			fixup16 (&operands[0].exp, M6811_OP_IMM16, operands[0].mode);

		      fixup16 (&operands[0].exp, M6811_OP_IND16, operands[0].mode);
		      return;
		    }
		  else if (operands[0].mode & M6811_OP_IND16)
		    {
		      number_to_chars_bigendian (f, 0x1801 + movb + opr16a, 2);
		      build_indexed_byte (&operands[1], operands[1].mode, 1);
		      fixup16 (&operands[0].exp, M6811_OP_IND16, operands[0].mode);
		      return;
		    }
		  else
		    {
		      number_to_chars_bigendian (f, 0x1802 + movb + opr16a, 2);
		      build_indexed_byte (&operands[0], operands[0].mode, 1);
		      fixup16 (&operands[1].exp, M6811_OP_IND16, operands[1].mode);
		      return;
		    }
		}
	    }

	  as_bad (_("Invalid operand for `%s'"), name);
	  return;

	}
      else
	{
	  as_bad (_("Invalid operand for `%s'"), name);
	  return;
	}
    }

  /* Treat dbeq/ibeq/tbeq instructions in a special way.  The branch is
     relative and must be in the range -256..255 (9-bits).  */
  if ((opcode->format & M6812_XBCC_MARKER)
      && (opcode->format & M6811_OP_JUMP_REL))
    build_dbranch_insn (opcode, operands, nb_operands, branch_optimize);

  /* Relative jumps instructions are taken care of separately.  We have to make
     sure that the relative branch is within the range -128..127.  If it's out
     of range, the instructions are changed into absolute instructions.
     This is not supported for the brset and brclr instructions.  */
  else if ((opcode->format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
	   && !(opcode->format & M6811_OP_BITMASK))
    build_jump_insn (opcode, operands, nb_operands, branch_optimize);
  else
    build_insn (opcode, operands, nb_operands);
}


/* Pseudo op to control the ELF flags.  */
static void
s_m68hc11_mode (int x ATTRIBUTE_UNUSED)
{
  char *name = input_line_pointer, ch;

  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;
  ch = *input_line_pointer;
  *input_line_pointer = '\0';

  if (strcmp (name, "mshort") == 0)
    {
      elf_flags &= ~E_M68HC11_I32;
    }
  else if (strcmp (name, "mlong") == 0)
    {
      elf_flags |= E_M68HC11_I32;
    }
  else if (strcmp (name, "mshort-double") == 0)
    {
      elf_flags &= ~E_M68HC11_F64;
    }
  else if (strcmp (name, "mlong-double") == 0)
    {
      elf_flags |= E_M68HC11_F64;
    }
  else
    {
      as_warn (_("Invalid mode: %s\n"), name);
    }
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

/* Mark the symbols with STO_M68HC12_FAR to indicate the functions
   are using 'rtc' for returning.  It is necessary to use 'call'
   to invoke them.  This is also used by the debugger to correctly
   find the stack frame.  */
static void
s_m68hc11_mark_symbol (int mark)
{
  char *name;
  int c;
  symbolS *symbolP;
  asymbol *bfdsym;
  elf_symbol_type *elfsym;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;

      SKIP_WHITESPACE ();

      bfdsym = symbol_get_bfdsym (symbolP);
      elfsym = elf_symbol_from (bfd_asymbol_bfd (bfdsym), bfdsym);

      gas_assert (elfsym);

      /* Mark the symbol far (using rtc for function return).  */
      elfsym->internal_elf_sym.st_other |= mark;

      if (c == ',')
	{
	  input_line_pointer ++;

	  SKIP_WHITESPACE ();

	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

static void
s_m68hc11_relax (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;

  expression (&ex);

  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad (_("bad .relax format"));
      ignore_rest_of_line ();
      return;
    }

  fix_new_exp (frag_now, frag_now_fix (), 0, &ex, 1,
               BFD_RELOC_M68HC11_RL_GROUP);

  demand_empty_rest_of_line ();
}


/* Relocation, relaxation and frag conversions.  */

/* PC-relative offsets are relative to the start of the
   next instruction.  That is, the address of the offset, plus its
   size, since the offset is always the last part of the insn.  */
long
md_pcrel_from (fixS *fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_M68HC11_RL_JUMP)
    return 0;

  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

/* If while processing a fixup, a reloc really needs to be created
   then it is done here.  */
arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  if (fixp->fx_r_type == 0)
    reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_16);
  else
    reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Relocation %d is not supported by object file format."),
		    (int) fixp->fx_r_type);
      return NULL;
    }

  /* Since we use Rel instead of Rela, encode the vtable entry to be
     used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  reloc->addend = 0;
  return reloc;
}

/* We need a port-specific relaxation function to cope with sym2 - sym1
   relative expressions with both symbols in the same segment (but not
   necessarily in the same frag as this insn), for example:
     ldab sym2-(sym1-2),pc
    sym1:
   The offset can be 5, 9 or 16 bits long.  */

long
m68hc11_relax_frag (segT seg ATTRIBUTE_UNUSED, fragS *fragP,
                    long stretch ATTRIBUTE_UNUSED)
{
  long growth;
  offsetT aim = 0;
  symbolS *symbolP;
  const relax_typeS *this_type;
  const relax_typeS *start_type;
  relax_substateT next_state;
  relax_substateT this_state;
  const relax_typeS *table = TC_GENERIC_RELAX_TABLE;

  /* We only have to cope with frags as prepared by
     md_estimate_size_before_relax.  The STATE_BITS16 case may geet here
     because of the different reasons that it's not relaxable.  */
  switch (fragP->fr_subtype)
    {
    case ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_BITS16):
    case ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS16):
      /* When we get to this state, the frag won't grow any more.  */
      return 0;

    case ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_BITS5):
    case ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS5):
    case ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_BITS9):
    case ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS9):
      if (fragP->fr_symbol == NULL
	  || S_GET_SEGMENT (fragP->fr_symbol) != absolute_section)
	as_fatal (_("internal inconsistency problem in %s: fr_symbol %lx"),
		  __FUNCTION__, (long) fragP->fr_symbol);
      symbolP = fragP->fr_symbol;
      if (symbol_resolved_p (symbolP))
	as_fatal (_("internal inconsistency problem in %s: resolved symbol"),
		  __FUNCTION__);
      aim = S_GET_VALUE (symbolP);
      break;

    default:
      as_fatal (_("internal inconsistency problem in %s: fr_subtype %d"),
		  __FUNCTION__, fragP->fr_subtype);
    }

  /* The rest is stolen from relax_frag.  There's no obvious way to
     share the code, but fortunately no requirement to keep in sync as
     long as fragP->fr_symbol does not have its segment changed.  */

  this_state = fragP->fr_subtype;
  start_type = this_type = table + this_state;

  if (aim < 0)
    {
      /* Look backwards.  */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim >= this_type->rlx_backward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state.  */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }
  else
    {
      /* Look forwards.  */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim <= this_type->rlx_forward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state.  */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }

  growth = this_type->rlx_length - start_type->rlx_length;
  if (growth != 0)
    fragP->fr_subtype = this_state;
  return growth;
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, asection *sec ATTRIBUTE_UNUSED,
                 fragS *fragP)
{
  long value;
  long disp;
  char *buffer_address = fragP->fr_literal;

  /* Address in object code of the displacement.  */
  register int object_address = fragP->fr_fix + fragP->fr_address;

  buffer_address += fragP->fr_fix;

  /* The displacement of the address, from current location.  */
  value = S_GET_VALUE (fragP->fr_symbol);
  disp = (value + fragP->fr_offset) - object_address;

  switch (fragP->fr_subtype)
    {
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE):
      fragP->fr_opcode[1] = disp;
      break;

    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_WORD):
      /* This relax is only for bsr and bra.  */
      gas_assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
	      || IS_OPCODE (fragP->fr_opcode[0], M6811_BRA)
	      || IS_OPCODE (fragP->fr_opcode[0], M6812_BSR));

      fragP->fr_opcode[0] = convert_branch (fragP->fr_opcode[0]);

      fix_new (fragP, fragP->fr_fix - 1, 2,
	       fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_16);
      fragP->fr_fix += 1;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE):
    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH_6812, STATE_BYTE):
      fragP->fr_opcode[1] = disp;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_WORD):
      /* Invert branch.  */
      fragP->fr_opcode[0] ^= 1;
      fragP->fr_opcode[1] = 3;	/* Branch offset.  */
      buffer_address[0] = M6811_JMP;
      fix_new (fragP, fragP->fr_fix + 1, 2,
	       fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_16);
      fragP->fr_fix += 3;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH_6812, STATE_WORD):
      /* Translate branch into a long branch.  */
      fragP->fr_opcode[1] = fragP->fr_opcode[0];
      fragP->fr_opcode[0] = M6811_OPCODE_PAGE2;

      fix_new (fragP, fragP->fr_fix, 2,
	       fragP->fr_symbol, fragP->fr_offset, 1,
		      BFD_RELOC_16_PCREL);
      fragP->fr_fix += 2;
      break;

    case ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_BITS5):
      if (fragP->fr_symbol != 0
          && S_GET_SEGMENT (fragP->fr_symbol) != absolute_section)
        value = disp;
      /* fall through  */

    case ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS5):
      fragP->fr_opcode[0] = fragP->fr_opcode[0] << 6;
      fragP->fr_opcode[0] |= value & 0x1f;
      break;

    case ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_BITS9):
      /* For a PC-relative offset, use the displacement with a -1 correction
         to take into account the additional byte of the insn.  */
      if (fragP->fr_symbol != 0
          && S_GET_SEGMENT (fragP->fr_symbol) != absolute_section)
        value = disp - 1;
      /* fall through  */

    case ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS9):
      fragP->fr_opcode[0] = (fragP->fr_opcode[0] << 3);
      fragP->fr_opcode[0] |= 0xE0;
      fragP->fr_opcode[0] |= (value >> 8) & 1;
      fragP->fr_opcode[1] = value;
      fragP->fr_fix += 1;
      break;

    case ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_BITS16):
    case ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS16):
      fragP->fr_opcode[0] = (fragP->fr_opcode[0] << 3);
      fragP->fr_opcode[0] |= 0xe2;
      if ((fragP->fr_opcode[0] & 0x0ff) == 0x0fa
          && fragP->fr_symbol != 0
          && S_GET_SEGMENT (fragP->fr_symbol) != absolute_section)
	{
	  fix_new (fragP, fragP->fr_fix, 2,
	           fragP->fr_symbol, fragP->fr_offset,
		   1, BFD_RELOC_16_PCREL);
	}
      else
	{
	  fix_new (fragP, fragP->fr_fix, 2,
		   fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_16);
	}
      fragP->fr_fix += 2;
      break;

    case ENCODE_RELAX (STATE_XBCC_BRANCH, STATE_BYTE):
      if (disp < 0)
	fragP->fr_opcode[0] |= 0x10;

      fragP->fr_opcode[1] = disp & 0x0FF;
      break;

    case ENCODE_RELAX (STATE_XBCC_BRANCH, STATE_WORD):
      /* Invert branch.  */
      fragP->fr_opcode[0] ^= 0x20;
      fragP->fr_opcode[1] = 3;	/* Branch offset.  */
      buffer_address[0] = M6812_JMP;
      fix_new (fragP, fragP->fr_fix + 1, 2,
	       fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_16);
      fragP->fr_fix += 3;
      break;

    default:
      break;
    }
}

/* On an ELF system, we can't relax a weak symbol.  The weak symbol
   can be overridden at final link time by a non weak symbol.  We can
   relax externally visible symbol because there is no shared library
   and such symbol can't be overridden (unless they are weak).  */
static int
relaxable_symbol (symbolS *symbol)
{
  return ! S_IS_WEAK (symbol);
}

/* Force truly undefined symbols to their maximum size, and generally set up
   the frag list to be relaxed.  */
int
md_estimate_size_before_relax (fragS *fragP, asection *segment)
{
  if (RELAX_LENGTH (fragP->fr_subtype) == STATE_UNDF)
    {
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment
	  || !relaxable_symbol (fragP->fr_symbol)
          || (segment != absolute_section
              && RELAX_STATE (fragP->fr_subtype) == STATE_INDEXED_OFFSET))
	{
	  /* Non-relaxable cases.  */
	  int old_fr_fix;
	  char *buffer_address;

	  old_fr_fix = fragP->fr_fix;
	  buffer_address = fragP->fr_fix + fragP->fr_literal;

	  switch (RELAX_STATE (fragP->fr_subtype))
	    {
	    case STATE_PC_RELATIVE:

	      /* This relax is only for bsr and bra.  */
	      gas_assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
		      || IS_OPCODE (fragP->fr_opcode[0], M6811_BRA)
		      || IS_OPCODE (fragP->fr_opcode[0], M6812_BSR));

	      if (flag_fixed_branches)
		as_bad_where (fragP->fr_file, fragP->fr_line,
			      _("bra or bsr with undefined symbol."));

	      /* The symbol is undefined or in a separate section.
		 Turn bra into a jmp and bsr into a jsr.  The insn
		 becomes 3 bytes long (instead of 2).  A fixup is
		 necessary for the unresolved symbol address.  */
	      fragP->fr_opcode[0] = convert_branch (fragP->fr_opcode[0]);

	      fix_new (fragP, fragP->fr_fix - 1, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
	      fragP->fr_fix++;
	      break;

	    case STATE_CONDITIONAL_BRANCH:
	      gas_assert (current_architecture & cpu6811);

	      fragP->fr_opcode[0] ^= 1;	/* Reverse sense of branch.  */
	      fragP->fr_opcode[1] = 3;	/* Skip next jmp insn (3 bytes).  */

	      /* Don't use fr_opcode[2] because this may be
		 in a different frag.  */
	      buffer_address[0] = M6811_JMP;

	      fragP->fr_fix++;
	      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
	      fragP->fr_fix += 2;
	      break;

	    case STATE_INDEXED_OFFSET:
	      gas_assert (current_architecture & cpu6812);

              if (fragP->fr_symbol
                  && S_GET_SEGMENT (fragP->fr_symbol) == absolute_section)
                {
                   fragP->fr_subtype = ENCODE_RELAX (STATE_INDEXED_OFFSET,
                                                     STATE_BITS5);
                   /* Return the size of the variable part of the frag. */
                   return md_relax_table[fragP->fr_subtype].rlx_length;
                }
              else
                {
                   /* Switch the indexed operation to 16-bit mode.  */
                   fragP->fr_opcode[0] = fragP->fr_opcode[0] << 3;
                   fragP->fr_opcode[0] |= 0xe2;
                   fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
                            fragP->fr_offset, 0, BFD_RELOC_16);
                   fragP->fr_fix += 2;
                }
	      break;

	    case STATE_INDEXED_PCREL:
	      gas_assert (current_architecture & cpu6812);

              if (fragP->fr_symbol
                  && S_GET_SEGMENT (fragP->fr_symbol) == absolute_section)
                {
                   fragP->fr_subtype = ENCODE_RELAX (STATE_INDEXED_PCREL,
                                                     STATE_BITS5);
                   /* Return the size of the variable part of the frag. */
                   return md_relax_table[fragP->fr_subtype].rlx_length;
                }
              else
                {
                   fragP->fr_opcode[0] = fragP->fr_opcode[0] << 3;
                   fragP->fr_opcode[0] |= 0xe2;
                   fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
			    fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
                   fragP->fr_fix += 2;
                }
	      break;

	    case STATE_XBCC_BRANCH:
	      gas_assert (current_architecture & cpu6812);

	      fragP->fr_opcode[0] ^= 0x20;	/* Reverse sense of branch.  */
	      fragP->fr_opcode[1] = 3;	/* Skip next jmp insn (3 bytes).  */

	      /* Don't use fr_opcode[2] because this may be
		 in a different frag.  */
	      buffer_address[0] = M6812_JMP;

	      fragP->fr_fix++;
	      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
	      fragP->fr_fix += 2;
	      break;

	    case STATE_CONDITIONAL_BRANCH_6812:
	      gas_assert (current_architecture & cpu6812);

	      /* Translate into a lbcc branch.  */
	      fragP->fr_opcode[1] = fragP->fr_opcode[0];
	      fragP->fr_opcode[0] = M6811_OPCODE_PAGE2;

	      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
                       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
	      fragP->fr_fix += 2;
	      break;

	    default:
	      as_fatal (_("Subtype %d is not recognized."), fragP->fr_subtype);
	    }
	  frag_wane (fragP);

	  /* Return the growth in the fixed part of the frag.  */
	  return fragP->fr_fix - old_fr_fix;
	}

      /* Relaxable cases.  */
      switch (RELAX_STATE (fragP->fr_subtype))
	{
	case STATE_PC_RELATIVE:
	  /* This relax is only for bsr and bra.  */
	  gas_assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
		  || IS_OPCODE (fragP->fr_opcode[0], M6811_BRA)
		  || IS_OPCODE (fragP->fr_opcode[0], M6812_BSR));

	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	  break;

	case STATE_CONDITIONAL_BRANCH:
	  gas_assert (current_architecture & cpu6811);

	  fragP->fr_subtype = ENCODE_RELAX (STATE_CONDITIONAL_BRANCH,
					    STATE_BYTE);
	  break;

	case STATE_INDEXED_OFFSET:
	  gas_assert (current_architecture & cpu6812);

	  fragP->fr_subtype = ENCODE_RELAX (STATE_INDEXED_OFFSET,
					    STATE_BITS5);
	  break;

	case STATE_INDEXED_PCREL:
	  gas_assert (current_architecture & cpu6812);

	  fragP->fr_subtype = ENCODE_RELAX (STATE_INDEXED_PCREL,
					    STATE_BITS5);
	  break;

	case STATE_XBCC_BRANCH:
	  gas_assert (current_architecture & cpu6812);

	  fragP->fr_subtype = ENCODE_RELAX (STATE_XBCC_BRANCH, STATE_BYTE);
	  break;

	case STATE_CONDITIONAL_BRANCH_6812:
	  gas_assert (current_architecture & cpu6812);

	  fragP->fr_subtype = ENCODE_RELAX (STATE_CONDITIONAL_BRANCH_6812,
					    STATE_BYTE);
	  break;
	}
    }

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    as_fatal (_("Subtype %d is not recognized."), fragP->fr_subtype);

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* See whether we need to force a relocation into the output file.  */
int
tc_m68hc11_force_relocation (fixS *fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_M68HC11_RL_GROUP)
    return 1;

  return generic_force_reloc (fixP);
}

/* Here we decide which fixups can be adjusted to make them relative
   to the beginning of the section instead of the symbol.  Basically
   we need to make sure that the linker relaxation is done
   correctly, so in some cases we force the original symbol to be
   used.  */
int
tc_m68hc11_fix_adjustable (fixS *fixP)
{
  switch (fixP->fx_r_type)
    {
      /* For the linker relaxation to work correctly, these relocs
         need to be on the symbol itself.  */
    case BFD_RELOC_16:
    case BFD_RELOC_M68HC11_RL_JUMP:
    case BFD_RELOC_M68HC11_RL_GROUP:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_32:

      /* The memory bank addressing translation also needs the original
         symbol.  */
    case BFD_RELOC_M68HC11_LO16:
    case BFD_RELOC_M68HC11_PAGE:
    case BFD_RELOC_M68HC11_24:
      return 0;

    default:
      return 1;
    }
}

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *where;
  long value = * valP;

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  /* We don't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != (symbolS *) NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("Expression too complex."));

  /* Patch the instruction with the resolved operand.  Elf relocation
     info will also be generated to take care of linker/loader fixups.
     The 68HC11 addresses only 64Kb, we are only concerned by 8 and 16-bit
     relocs.  BFD_RELOC_8 is basically used for .page0 access (the linker
     will warn for overflows).  BFD_RELOC_8_PCREL should not be generated
     because it's either resolved or turned out into non-relative insns (see
     relax table, bcc, bra, bsr transformations)

     The BFD_RELOC_32 is necessary for the support of --gstabs.  */
  where = fixP->fx_frag->fr_literal + fixP->fx_where;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_32:
      bfd_putb32 ((bfd_vma) value, (unsigned char *) where);
      break;

    case BFD_RELOC_24:
    case BFD_RELOC_M68HC11_24:
      bfd_putb16 ((bfd_vma) (value & 0x0ffff), (unsigned char *) where);
      ((bfd_byte*) where)[2] = ((value >> 16) & 0x0ff);
      break;

    case BFD_RELOC_16:
    case BFD_RELOC_16_PCREL:
    case BFD_RELOC_M68HC11_LO16:
      bfd_putb16 ((bfd_vma) value, (unsigned char *) where);
      if (value < -65537 || value > 65535)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value out of 16-bit range."));
      break;

    case BFD_RELOC_M68HC11_HI8:
        /* Caution, %hi(<symbol>+%ld) will generate incorrect code if %lo
          causes a carry. */
    case BFD_RELOC_M68HC12_HI8XG:
      value = value >> 8;
      /* Fall through.  */

    case BFD_RELOC_M68HC12_LO8XG:
    case BFD_RELOC_M68HC11_LO8:
    case BFD_RELOC_8:
    case BFD_RELOC_M68HC11_PAGE:
      ((bfd_byte *) where)[0] = (bfd_byte) value;
      break;

    case BFD_RELOC_8_PCREL:
      ((bfd_byte *) where)[0] = (bfd_byte) value;

      if (value < -128 || value > 127)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value %ld too large for 8-bit PC-relative branch."),
		      value);
      break;

    /* These next two are for XGATE. */
    case BFD_RELOC_M68HC12_9_PCREL:
     ((bfd_byte *) where)[0] |= (bfd_byte) ((value >>9) & 0x01);
     ((bfd_byte *) where)[1] = (bfd_byte) ((value>>1) & 0xff);
      if (value < -512 || value > 511)
        as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value %ld too large for 9-bit PC-relative branch."),
		      value);
      break;

    case BFD_RELOC_M68HC12_10_PCREL:
     ((bfd_byte *) where)[0] |= (bfd_byte) ((value >>9) & 0x03);
     ((bfd_byte *) where)[1] = (bfd_byte) ((value>>1) & 0xff);
      if (value < -1024 || value > 1023)
        as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value %ld too large for 10-bit PC-relative branch."),
		      value);

      break;

    case BFD_RELOC_M68HC11_3B:
      if (value <= 0 || value > 8)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Auto increment/decrement offset '%ld' is out of range."),
		      value);
      if (where[0] & 0x8)
	value = 8 - value;
      else
	value--;

      where[0] = where[0] | (value & 0x07);
      break;

    case BFD_RELOC_M68HC12_5B:
      if (value < -16 || value > 15)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Offset out of 5-bit range for movw/movb insn: %ld"),
		      value);
      if (value >= 0)
	where[0] |= value;
      else 
	where[0] |= (0x10 | (16 + value));
      break;

    case BFD_RELOC_M68HC12_9B:
      if (value < -256 || value > 255)
        as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Offset out of 9-bit range for movw/movb insn: %ld"),
		      value);
        /* sign bit already in xb postbyte */
      if (value >= 0)
        where[1] = value;
      else 
        where[1] = (256 + value);
      break;

    case BFD_RELOC_M68HC12_16B:
      if (value < -32768 || value > 32767)
        as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Offset out of 16-bit range for movw/movb insn: %ld"),
		      value);
      if (value < 0)
        value += 65536;

      where[0] = (value >> 8);
      where[1] = (value & 0xff);
      break;

    case BFD_RELOC_M68HC11_RL_JUMP:
    case BFD_RELOC_M68HC11_RL_GROUP:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    default:
      as_fatal (_("Line %d: unknown relocation type: 0x%x."),
		fixP->fx_line, fixP->fx_r_type);
    }
}

/* Set the ELF specific flags.  */
void
m68hc11_elf_final_processing (void)
{
  if (current_architecture & cpu6812s)
    elf_flags |= EF_M68HCS12_MACH;
  elf_elfheader (stdoutput)->e_flags &= ~EF_M68HC11_ABI;
  elf_elfheader (stdoutput)->e_flags |= elf_flags;
}

/* Process directives specified via pseudo ops */
static void
s_m68hc11_parse_pseudo_instruction (int pseudo_insn)
{
  switch (pseudo_insn)
    {
    case E_M68HC11_NO_BANK_WARNING:
      elf_flags |= E_M68HC11_NO_BANK_WARNING;
      break;
    default:
      as_bad (_("Invalid directive"));
    }
}
@


1.63
log
@        * config/tc-xgate.c: Remove bogus use of <fx_pcrel_adjust>.
        * config/tc-m68hc11.c: Likewise.
@
text
@d2222 1
a2224 1
		  f = frag_more (2);
d4462 2
a4463 2
      where[1] = (value >> 8);
      where[2] = (value & 0xff);
@


1.62
log
@	* tc-m68hc11.c (s_m68hc11_parse_pseudo_instruction):
	New function to parse pseudo ops that are unreleated to
	existing pseudo ops.
@
text
@d1606 2
a1607 5
	  fixS *fixp;

	  fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
			      oper, TRUE, BFD_RELOC_8_PCREL);
	  fixp->fx_pcrel_adjust = 1;
d1676 1
a1676 2
      if (reloc == BFD_RELOC_16_PCREL)
	fixp->fx_pcrel_adjust = 2;
a1754 2
          fixS *fixp;

d1757 2
a1758 3
          fixp = fix_new_exp (frag_now, f - frag_now->fr_literal -1, 2,
			      oper, TRUE, BFD_RELOC_M68HC12_9_PCREL);
          fixp->fx_pcrel_adjust = 1;
a1761 2
          fixS *fixp;

d1764 2
a1765 3
          fixp = fix_new_exp (frag_now, f - frag_now->fr_literal -1, 2,
    	      oper, TRUE, BFD_RELOC_M68HC12_10_PCREL);
          fixp->fx_pcrel_adjust = 1;
a3957 1
  fixS *fixp;
d4010 2
a4011 2
      fixp = fix_new (fragP, fragP->fr_fix, 2,
		      fragP->fr_symbol, fragP->fr_offset, 1,
a4012 1
      fixp->fx_pcrel_adjust = 2;
d4051 3
a4053 3
	  fixp = fix_new (fragP, fragP->fr_fix, 2,
			  fragP->fr_symbol, fragP->fr_offset,
			  1, BFD_RELOC_16_PCREL);
@


1.61
log
@2012-07-27  James Murray  <jsm@@jsm-net.demon.co.uk>

	* config/tc-m68hc11.c: Replace binary with hex for cygwin.
@
text
@d228 3
d320 3
d4500 14
@


1.60
log
@	* config/tc-m68hc11.c: Add S12X and XGATE co-processor support.
	Add option to offset S12 addresses into XGATE memory space.
	Tweak target flags to match other tools. (i.e. -m m68hc11).
	* doc/as.texinfo: Mention new options.
	* doc/c-m68hc11.texi: Document new options.
	* NEWS: Mention new support.

	* archures.c: Add bfd_arch_m9s12x and bfd_arch_m9s12xg.
	* config.bfd: Likewise.
	* cpu-m9s12x.c: New.
	* cpu-m9s12xg.c: New.
	* elf32-m68hc12.c: Add S12X and XGATE co-processor support.
	Add option to offset S12 addresses into XGATE memory space.
	Fix carry bug in IMM16 (IMM8 low/high) relocate.
	* Makefile.am (ALL_MACHINES): Add cpu-m9s12x and cpu-m9s12xg.
	(ALL_MACHINES_CFILES): Likewise.
	* reloc.c: Add S12X relocs.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* gas/m68hc11/insns9s12x.s: New
	* gas/m68hc11/insns9s12x.d: New
	* gas/m68hc11/hexprefix.s: New
	* gas/m68hc11/hexprefix.d: New
	* gas/m68hc11/9s12x-exg-sex-tfr.s: New
	* gas/m68hc11/9s12x-exg-sex-tfr.d: New
	* gas/m68hc11/insns9s12xg.s: New
	* gas/m68hc11/insns9s12xg.d: New
	* gas/m68hc11/9s12x-mov.s: New
	* gas/m68hc11/9s12x-mov.d: New
	* gas/m68hc11/m68hc11.exp: Updated
	* gas/m68hc11/*.d: Brought in line with changed objdump output.
	* gas/all/gas.exp: XFAIL all hc11/12 targets for redef2,3.
	* gas/elf/elf.exp: XFAIL all hc11/12 targets for redef.
	* gas/elf/dwarf2-1.d: Skip for hc11/12 targets.
	* gas/elf/dwarf2-2.d: Likewise.

	* ld-m68hc11/xgate-link.s: New.
	* ld-m68hc11/xgate-link.d: New.
	* ld-m68hc11/xgate-offset.s: New.
	* ld-m68hc11/xgate-offset.d: New.
	* ld-m68hc11/xgate1.s: New.
	* ld-m68hc11/xgate1.d: New.
	* ld-m68hc11/xgate2.s: New.
	* ld-m68hc11/m68hc11.exp: Updated.
	* ld-m68hc11/*.d: Brought in line with changed objdump output.
	* ld-gc/gc.exp: Update CFLAGS for m68hc11.
	* ld-plugin/plugin.exp: Likewise.
	* ld-srec/srec.exp: XFAIL for m68hc11 and m68hc12.

	* configure.in: Add S12X and XGATE co-processor support to m68hc11
	target.
	* disassemble.c: Likewise.
	* configure: Regenerate.
	* m68hc11-dis.c: Make objdump output more consistent, use hex
	instead of decimal and use 0x prefix for hex.
	* m68hc11-opc.c: Add S12X and XGATE opcodes.
	* dis-asm.h (print_insn_m9s12x): Prototype.
	(print_insn_m9s12xg): Prototype.

	* m68hc11.h (R_M68HC12_16B, R_M68HC12_PCREL_9, R_M68HC12_PCREL_10)
	R_M68HC12_HI8XG, R_M68HC12_LO8XG): New relocations.
	(E_M68HC11_XGATE_RAMOFFSET): Define.

	* m68hc11.h: Add XGate definitions.
	(struct m68hc11_opcode): Add xg_mask field.
@
text
@d2224 1
a2224 1
		  byte |= 0b11100010;
@


1.60.2.1
log
@	* config/tc-m68hc11.c (build_indexed_byte): Replace use of binary
	constant with hex for building on cygwin.
@
text
@d2224 1
a2224 1
		  byte |= 0xe2;
@


1.60.2.2
log
@	* tc-m68hc11.c (s_m68hc11_parse_pseudo_instruction):
	New function to parse pseudo ops that are unreleated to
	existing pseudo ops.
@
text
@a227 3
/* Process directives specified via pseudo ops.  */
static void s_m68hc11_parse_pseudo_instruction (int);

a316 3
  /* .nobankwarning instruction.  */
  {"nobankwarning", s_m68hc11_parse_pseudo_instruction, E_M68HC11_NO_BANK_WARNING},

a4493 14

/* Process directives specified via pseudo ops */
static void
s_m68hc11_parse_pseudo_instruction (int pseudo_insn)
{
  switch (pseudo_insn)
    {
    case E_M68HC11_NO_BANK_WARNING:
      elf_flags |= E_M68HC11_NO_BANK_WARNING;
      break;
    default:
      as_bad (_("Invalid directive"));
    }
}
@


1.60.2.3
log
@2012-11-07  James Murray <jsm@@jsm-net.demon.co.uk>

	* config/tc-m68hc11.c: Fix R_M68HC12_16B relocation for movb/w
@
text
@a2231 1
		  f = frag_more (2);
d2234 1
d4474 2
a4475 2
      where[0] = (value >> 8);
      where[1] = (value & 0xff);
@


1.59
log
@	* config/tc-d10v.c (do_assemble): Correctly detect overflow of
	"name" buffer.
	* config/tc-m68hc11.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_assemble): Likewise.  Correct cast
	of is_end_of_line index.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
d6 1
d70 2
a71 1
relax_typeS md_relax_table[] = {
d122 2
a123 1
typedef enum register_id {
d132 12
a143 1
  REG_PC = 8
d146 2
a147 1
typedef struct operand {
d154 2
a155 1
struct m68hc11_opcode_def {
d167 2
a168 1
typedef struct alias {
d173 2
a174 1
static alias alias_opcodes[] = {
d181 10
d205 1
d218 1
d293 2
a294 1
const pseudo_typeS md_pseudo_table[] = {
d298 1
d324 2
a325 1
struct option md_longopts[] = {
d358 3
d400 4
d415 2
a416 1
  -m68hcs12               specify the processor [default %s]\n\
d428 1
d536 4
d541 2
a542 1
      if (strcasecmp (arg, "68hc11") == 0)
d544 2
a545 1
      else if (strcasecmp (arg, "68hc12") == 0)
d547 2
a548 1
      else if (strcasecmp (arg, "68hcs12") == 0)
d550 6
d673 28
a700 12
      if (opcodes->format & M6811_OP_MASK)
	expect++;
      if (opcodes->format & M6811_OP_BITMASK)
	expect++;
      if (opcodes->format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
	expect++;
      if (opcodes->format & (M6812_OP_IND16_P2 | M6812_OP_IDX_P2))
	expect++;
      /* Special case for call instruction.  */
      if ((opcodes->format & M6812_OP_PAGE)
          && !(opcodes->format & M6811_OP_IND16))
        expect++;
d705 1
a705 1
         expect++;
d729 1
d739 2
a740 1
  if (format & M6811_OP_IMM8)
d742 104
a845 5
      if (example)
	sprintf (p, "#%d", rand () & 0x0FF);
      else
	strcpy (p, _("#<imm8>"));
      p = &p[strlen (p)];
d847 11
d859 8
a866 8
  if (format & M6811_OP_IMM16)
    {
      if (example)
	sprintf (p, "#%d", rand () & 0x0FFFF);
      else
	strcpy (p, _("#<imm16>"));
      p = &p[strlen (p)];
    }
d868 8
a875 8
  if (format & M6811_OP_IX)
    {
      if (example)
	sprintf (p, "%d,X", rand () & 0x0FF);
      else
	strcpy (p, _("<imm8>,X"));
      p = &p[strlen (p)];
    }
d877 8
a884 8
  if (format & M6811_OP_IY)
    {
      if (example)
	sprintf (p, "%d,X", rand () & 0x0FF);
      else
	strcpy (p, _("<imm8>,X"));
      p = &p[strlen (p)];
    }
d886 8
a893 8
  if (format & M6812_OP_IDX)
    {
      if (example)
	sprintf (p, "%d,X", rand () & 0x0FF);
      else
	strcpy (p, "n,r");
      p = &p[strlen (p)];
    }
d895 8
a902 8
  if (format & M6812_OP_PAGE)
    {
      if (example)
	sprintf (p, ", %d", rand () & 0x0FF);
      else
	strcpy (p, ", <page>");
      p = &p[strlen (p)];
    }
d904 8
a911 8
  if (format & M6811_OP_DIRECT)
    {
      if (example)
	sprintf (p, "*Z%d", rand () & 0x0FF);
      else
	strcpy (p, _("*<abs8>"));
      p = &p[strlen (p)];
    }
d913 4
a916 4
  if (format & M6811_OP_BITMASK)
    {
      if (buf[0])
	*p++ = ' ';
d918 4
a921 4
      if (example)
	sprintf (p, "#$%02x", rand () & 0x0FF);
      else
	strcpy (p, _("#<mask>"));
d923 4
a926 4
      p = &p[strlen (p)];
      if (format & M6811_OP_JUMP_REL)
	*p++ = ' ';
    }
d928 6
a933 6
  if (format & M6811_OP_IND16)
    {
      if (example)
	sprintf (p, _("symbol%d"), rand () & 0x0FF);
      else
	strcpy (p, _("<abs>"));
d935 2
a936 2
      p = &p[strlen (p)];
    }
d938 1
a938 3
  if (format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
    {
      if (example)
d940 1
a940 1
	  if (format & M6811_OP_BITMASK)
d942 8
a949 1
	      sprintf (p, ".+%d", rand () & 0x7F);
d952 1
a952 3
	    {
	      sprintf (p, "L%d", rand () & 0x0FF);
	    }
a953 2
      else
	strcpy (p, _("<label>"));
a954 1

d1057 23
a1079 1

d1480 24
a1503 3
  /* Auto increment and decrement are ok for [-8..8] without 0.  */
  if (mode & M6812_AUTO_INC_DEC)
    return (num != 0 && num <= 8 && num >= -8);
d1505 48
a1552 38
  /* The 68HC12 supports 5, 9 and 16-bit offsets.  */
  if (mode & (M6812_INDEXED_IND | M6812_INDEXED | M6812_OP_IDX))
    mode = M6811_OP_IND16;

  if (mode & M6812_OP_JUMP_REL16)
    mode = M6811_OP_IND16;

  mode &= ~M6811_OP_BRANCH;
  switch (mode)
    {
    case M6811_OP_IX:
    case M6811_OP_IY:
    case M6811_OP_DIRECT:
      return (num >= 0 && num <= 255) ? 1 : 0;

    case M6811_OP_BITMASK:
    case M6811_OP_IMM8:
    case M6812_OP_PAGE:
      return (((num & 0xFFFFFF00) == 0) || ((num & 0xFFFFFF00) == 0xFFFFFF00))
	? 1 : 0;

    case M6811_OP_JUMP_REL:
      return (num >= -128 && num <= 127) ? 1 : 0;

    case M6811_OP_IND16:
    case M6811_OP_IND16 | M6812_OP_PAGE:
    case M6811_OP_IMM16:
      return (((num & 0xFFFF0000) == 0) || ((num & 0xFFFF0000) == 0xFFFF0000))
	? 1 : 0;

    case M6812_OP_IBCC_MARKER:
    case M6812_OP_TBCC_MARKER:
    case M6812_OP_DBCC_MARKER:
      return (num >= -256 && num <= 255) ? 1 : 0;

    case M6812_OP_TRAP_ID:
      return ((num >= 0x30 && num <= 0x39)
	      || (num >= 0x40 && num <= 0x0ff)) ? 1 : 0;
d1554 3
a1556 2
    default:
      return 0;
d1714 81
d1799 1
d2064 1
d2084 3
a2086 4
	    {
	      as_bad (_("Increment/decrement value is out of range: `%ld'."),
		      val);
	    }
d2092 1
d2144 1
d2148 1
a2148 3
	    {
	      as_bad (_("Offset out of 16-bit range: %ld."), val);
	    }
d2150 3
a2152 1
	  if (move_insn && !(val >= -16 && val <= 15))
d2192 1
d2215 1
d2219 21
a2239 5
	      byte <<= 6;
	      number_to_chars_bigendian (f, byte, 1);
	      fix_new (frag_now, f - frag_now->fr_literal, 1,
		       sym, off, 0, BFD_RELOC_M68HC12_5B);
	      return 1;
d2252 1
d2280 1
a2280 1
	  if (move_insn)
d2331 2
d2344 3
a2346 2
  if (format & M6812_OP_SEX_MARKER
      && op->reg1 != REG_A && op->reg1 != REG_B && op->reg1 != REG_CCR)
d2362 4
d2371 73
d2448 1
d2450 2
a2451 1
build_insn (struct m68hc11_opcode *opcode, operand operands[],
d2585 15
d2701 1
a2701 1
	      if (i == 1 && format & M6812_OP_IDX_P2)
d2742 1
a2742 6
  if (!match)
    {
      return (0);
    }

  return opcode;
d2823 1
d2856 623
d3497 1
a3497 1
  /* The following test should probably be removed.  This is not conform
d3585 114
a3698 2
      as_bad (_("Invalid operand for `%s'"), name);
      return;
d4382 3
d4388 1
d4404 20
d4448 24
@


1.58
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d2406 1
a2406 1
       *op_end && nlen < 20 && !is_end_of_line[*op_end] && *op_end != ' ';
d2411 2
@


1.57
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
a1465 2
      fixS *fixp;

d1467 2
a1468 2
      fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 3,
			  oper, FALSE, BFD_RELOC_M68HC11_24);
a1517 2
  fragS *frag;
  int where;
a1537 3
      frag = frag_now;
      where = frag_now_fix ();

a1594 3
      frag = frag_now;
      where = frag_now_fix ();

a1606 3
      frag = frag_now;
      where = frag_now_fix ();
      
a3023 2
                   fixS* fixp;

d3026 2
a3027 2
                   fixp = fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
                                   fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
a3169 1
  int op_type;
a3177 2
  op_type = fixP->fx_r_type;

@


1.56
log
@update copyright dates
@
text
@d1615 1
a1615 1
      char *opcode;
d1626 2
a1627 2
	  opcode = m68hc11_new_insn (1);
	  number_to_chars_bigendian (opcode, code, 1);
d1635 3
a1637 3
	  opcode = m68hc11_new_insn (3);
	  number_to_chars_bigendian (opcode, code, 1);
	  number_to_chars_bigendian (opcode + 1, 0, 1);
d1641 1
a1641 1
                        opcode);
d1645 3
a1647 3
	  opcode = m68hc11_new_insn (2);
	  number_to_chars_bigendian (opcode, code, 1);
	  number_to_chars_bigendian (opcode + 1, 0, 1);
d1650 1
a1650 1
		    operands[0].exp.X_add_symbol, (offsetT) n, opcode);
d1654 3
a1656 3
	  opcode = m68hc11_new_insn (2);
	  number_to_chars_bigendian (opcode, code, 1);
	  number_to_chars_bigendian (opcode + 1, 0, 1);
d1659 1
a1659 1
		    operands[0].exp.X_add_symbol, (offsetT) n, opcode);
@


1.55
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.54
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1525 3
a1527 3
  assert ((opcode->format & M6811_OP_BITMASK) == 0);
  assert (nb_operands == 1);
  assert (operands[0].reg1 == REG_NONE && operands[0].reg2 == REG_NONE);
d1675 3
a1677 3
  assert ((opcode->format & M6811_OP_BITMASK) == 0);
  assert (nb_operands == 2);
  assert (operands[0].reg1 != REG_NONE);
d2621 1
a2621 1
      assert (elfsym);
d2826 1
a2826 1
      assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
d2967 1
a2967 1
	      assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
d2987 1
a2987 1
	      assert (current_architecture & cpu6811);
d3003 1
a3003 1
	      assert (current_architecture & cpu6812);
d3025 1
a3025 1
	      assert (current_architecture & cpu6812);
d3048 1
a3048 1
	      assert (current_architecture & cpu6812);
d3064 1
a3064 1
	      assert (current_architecture & cpu6812);
d3089 1
a3089 1
	  assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
d3097 1
a3097 1
	  assert (current_architecture & cpu6811);
d3104 1
a3104 1
	  assert (current_architecture & cpu6812);
d3111 1
a3111 1
	  assert (current_architecture & cpu6812);
d3118 1
a3118 1
	  assert (current_architecture & cpu6812);
d3124 1
a3124 1
	  assert (current_architecture & cpu6812);
@


1.53
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@a516 7
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */
d520 1
a520 46
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
@


1.52
log
@Switch to GPLv3
@
text
@d266 1
a266 1
  {"fcc", stringer, 1},
@


1.51
log
@	* config/tc-m68hc11.c (fixup24): Correct fixup size.
	(build_jump_insn): Likewise.
	(build_insn): Likewise.
	(s_m68hc11_relax): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.50
log
@	* config/tc-m68hc11.c (md_assemble): Quiet warning.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d1521 1
a1521 1
      fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
d1597 1
a1597 1
      fix_new (frag_now, frag_now_fix (), 1,
d1657 1
a1657 1
      fix_new (frag_now, frag_now_fix (), 1,
d1672 1
a1672 1
      fix_new (frag_now, frag_now_fix (), 1,
d2105 1
a2105 1
    fix_new (frag_now, frag_now_fix (), 1,
d2707 1
a2707 1
  fix_new_exp (frag_now, frag_now_fix (), 2, &ex, 1,
@


1.49
log
@PR binutils/2877
* doc/as.texi: Fix spelling typo: branchs => branches.
* doc/c-m68hc11.texi: Likewise.
* config/tc-m68hc11.c: Likewise.
  Support old spelling of command line switch for backwards compatibility.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d2460 1
a2460 1
  int nb_operands;
@


1.48
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d213 1
a213 1
static short flag_fixed_branchs = 0;
d293 2
a294 1
  {"force-long-branchs", no_argument, NULL, OPTION_FORCE_LONG_BRANCH},
d296 3
a298 2
#define OPTION_SHORT_BRANCHS     (OPTION_MD_BASE + 1)
  {"short-branchs", no_argument, NULL, OPTION_SHORT_BRANCHS},
d379 2
a380 2
  --force-long-branchs    always turn relative branchs into absolute ones\n\
  -S,--short-branchs      do not turn relative branchs into absolute ones\n\
d452 1
a452 1
    case OPTION_SHORT_BRANCHS:
d454 1
a454 1
      flag_fixed_branchs = 1;
d1592 1
a1592 1
	      (jmp_mode == 1 || flag_fixed_branchs == 0))))
d1676 1
a1676 1
      if (jmp_mode == 0 && flag_fixed_branchs)
d1758 1
a1758 1
	      (jmp_mode == 1 || flag_fixed_branchs == 0))))
d1789 1
a1789 1
      if (jmp_mode == 0 && flag_fixed_branchs)
d2489 2
a2490 2
     pseudo insns for relative branch.  For these branchs, we always
     optimize them (turned into absolute branchs) even if --short-branchs
d3023 1
a3023 1
	      if (flag_fixed_branchs)
@


1.47
log
@Update the address and phone number of the FSF
@
text
@d3231 1
a3231 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.46
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d20 2
a21 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.45
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d2453 2
a2454 2
  unsigned char *op_start, *save;
  unsigned char *op_end;
d2468 1
a2468 1
  for (op_start = op_end = (unsigned char *) (str);
d2548 1
a2548 1
  input_line_pointer = op_end;
@


1.44
log
@Stop indexed move byte instructions from being relaxed.
@
text
@a3283 3
#if 0
      bfd_putb8 ((bfd_vma) value, (unsigned char *) where);
#endif
a3287 3
#if 0
      bfd_putb8 ((bfd_vma) value, (unsigned char *) where);
#endif
@


1.43
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d1954 16
a1969 3
	  frag_var (rs_machine_dependent, 2, 2,
		    ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_UNDF),
		    sym, off, f);
d1974 17
a1990 5
	  number_to_chars_bigendian (f, byte, 1);
	  frag_var (rs_machine_dependent, 2, 2,
		    ENCODE_RELAX (STATE_INDEXED_PCREL, STATE_UNDF),
		    op->exp.X_add_symbol,
		    op->exp.X_add_number, f);
d3313 11
@


1.42
log
@	* config/tc-m68hc11.c: Convert to ISO C90.
	* config/tc-m68hc11.h: Likewise.
@
text
@d236 1
a236 1
   by 'get_default_target' by looking at default BFD vector.  This is overriden
d1572 1
a1572 1
  /* The relative branch convertion is not supported for
d1722 1
a1722 1
  /* The relative branch convertion is not supported for
d2061 1
a2061 1
   the array of operand expressions and builds the correspding instruction.
@


1.41
log
@	PR savannah/4358:
	* config/tc-m68hc11.c (s_m68hc11_relax): Use 2 for size to avoid
	overflow complain.
@
text
@d162 27
a188 30
static register_id reg_name_search PARAMS ((char *));
static register_id register_name PARAMS ((void));
static int cmp_opcode PARAMS ((struct m68hc11_opcode *,
                               struct m68hc11_opcode *));
static char *print_opcode_format PARAMS ((struct m68hc11_opcode *, int));
static char *skip_whites PARAMS ((char *));
static int check_range PARAMS ((long, int));
static void print_opcode_list PARAMS ((void));
static void get_default_target PARAMS ((void));
static void print_insn_format PARAMS ((char *));
static int get_operand PARAMS ((operand *, int, long));
static void fixup8 PARAMS ((expressionS *, int, int));
static void fixup16 PARAMS ((expressionS *, int, int));
static void fixup24 PARAMS ((expressionS *, int, int));
static unsigned char convert_branch PARAMS ((unsigned char));
static char *m68hc11_new_insn PARAMS ((int));
static void build_dbranch_insn PARAMS ((struct m68hc11_opcode *,
                                        operand *, int, int));
static int build_indexed_byte PARAMS ((operand *, int, int));
static int build_reg_mode PARAMS ((operand *, int));

static struct m68hc11_opcode *find
  PARAMS ((struct m68hc11_opcode_def *, operand *, int));
static struct m68hc11_opcode *find_opcode
  PARAMS ((struct m68hc11_opcode_def *, operand *, int *));
static void build_jump_insn
  PARAMS ((struct m68hc11_opcode *, operand *, int, int));
static void build_insn
  PARAMS ((struct m68hc11_opcode *, operand *, int));
static int relaxable_symbol PARAMS ((symbolS *));
d191 1
a191 1
static void s_m68hc11_relax PARAMS((int));
d194 1
a194 1
static void s_m68hc11_mode PARAMS ((int));
d200 1
a200 1
static void s_m68hc11_mark_symbol PARAMS ((int));
d329 1
a329 1
m68hc11_arch_format ()
d339 1
a339 1
m68hc11_arch ()
d349 1
a349 1
m68hc11_mach ()
d356 1
a356 1
m68hc11_listing_header ()
d365 1
a365 2
md_show_usage (stream)
     FILE *stream;
d390 1
a390 1
get_default_target ()
d420 1
a420 2
m68hc11_print_statistics (file)
     FILE *file;
d443 1
a443 3
md_parse_option (c, arg)
     int c;
     char *arg;
d509 1
a509 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d522 1
a522 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d573 1
a573 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d580 1
a580 3
cmp_opcode (op1, op2)
     struct m68hc11_opcode *op1;
     struct m68hc11_opcode *op2;
d593 1
a593 1
md_begin ()
d634 1
a634 1
         (int (*) PARAMS ((const PTR, const PTR))) cmp_opcode);
d659 1
a659 1
	  hash_insert (m68hc11_hash, opcodes->name, (char *) opc);
d697 1
a697 1
m68hc11_init_after_args ()
d707 1
a707 3
print_opcode_format (opcode, example)
     struct m68hc11_opcode *opcode;
     int example;
d825 1
a825 1
print_opcode_list ()
d871 1
a871 2
print_insn_format (name)
     char *name;
d904 1
a904 2
reg_name_search (name)
     char *name;
d927 1
a927 2
skip_whites (p)
     char *p;
d938 1
a938 1
register_name ()
d987 1
a987 4
get_operand (oper, which, opmode)
     operand *oper;
     int which;
     long opmode;
d1321 1
a1321 3
check_range (num, mode)
     long num;
     int mode;
d1376 1
a1376 4
fixup8 (oper, mode, opmode)
     expressionS *oper;
     int mode;
     int opmode;
d1449 1
a1449 4
fixup16 (oper, mode, opmode)
     expressionS *oper;
     int mode;
     int opmode ATTRIBUTE_UNUSED;
d1498 1
a1498 4
fixup24 (oper, mode, opmode)
     expressionS *oper;
     int mode;
     int opmode ATTRIBUTE_UNUSED;
d1532 1
a1532 2
convert_branch (code)
     unsigned char code;
d1550 1
a1550 2
m68hc11_new_insn (size)
     int size;
d1563 2
a1564 5
build_jump_insn (opcode, operands, nb_operands, jmp_mode)
     struct m68hc11_opcode *opcode;
     operand operands[];
     int nb_operands;
     int jmp_mode;
d1715 2
a1716 5
build_dbranch_insn (opcode, operands, nb_operands, jmp_mode)
     struct m68hc11_opcode *opcode;
     operand operands[];
     int nb_operands;
     int jmp_mode;
d1807 1
a1807 4
build_indexed_byte (op, format, move_insn)
     operand *op;
     int format ATTRIBUTE_UNUSED;
     int move_insn;
d2033 1
a2033 3
build_reg_mode (op, format)
     operand *op;
     int format;
d2065 2
a2066 4
build_insn (opcode, operands, nb_operands)
     struct m68hc11_opcode *opcode;
     operand operands[];
     int nb_operands ATTRIBUTE_UNUSED;
d2189 1
a2189 4
find (opc, operands, nb_operands)
     struct m68hc11_opcode_def *opc;
     operand operands[];
     int nb_operands;
d2359 2
a2360 4
find_opcode (opc, operands, nb_operands)
     struct m68hc11_opcode_def *opc;
     operand operands[];
     int *nb_operands;
d2422 1
a2422 2
md_assemble (str)
     char *str;
d2587 1
a2587 2
s_m68hc11_mode (x)
     int x ATTRIBUTE_UNUSED;
d2625 1
a2625 2
s_m68hc11_mark_symbol (mark)
     int mark;
d2666 1
a2666 2
s_m68hc11_relax (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2692 1
a2692 2
md_pcrel_from (fixP)
     fixS *fixP;
d2703 1
a2703 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d2740 2
a2741 4
m68hc11_relax_frag (seg, fragP, stretch)
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP;
     long stretch ATTRIBUTE_UNUSED;
d2825 2
a2826 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragP;
d2962 1
a2962 2
relaxable_symbol (symbol)
     symbolS *symbol;
d2970 1
a2970 3
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP;
     asection *segment;
d3165 1
a3165 2
tc_m68hc11_force_relocation (fixP)
     fixS * fixP;
d3179 1
a3179 2
tc_m68hc11_fix_adjustable (fixP)
     fixS *fixP;
d3205 1
a3205 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d3305 1
a3305 1
m68hc11_elf_final_processing ()
@


1.40
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d2737 1
a2737 1
  fix_new_exp (frag_now, frag_now_fix (), 1, &ex, 1,
@


1.39
log
@	* config/tc-m68hc11.c (M6811_OP_CALL_ADDR): New internal define.
	(M6811_OP_PAGE_ADDR): New internal define.
	(get_operand): New modifier %page and %addr to obtain page and
	address part of a far-function.
	(fixup8): Use BFD_RELOC_M68HC11_PAGE for a %page modifier; don't
	complain on overflow for the BFD_RELOC_M68HC11_PAGE and truncation
	relocs.
	(fixup16): Use BFD_RELOC_M68HC11_LO16 for a %addr modifier.
	(find_opcode): Add comment.
	(md_estimate_size_before_relax): Force relocation of
	STATE_UNDEXED_OFFSET types when the symbol is not absolute.
	(tc_m68hc11_fix_adjustable): Check for BFD_RELOC_M68HC11_LO16
	instead of BFD_RELOC_LO16; temporarily make the BFD_RELOC_32
	on the symbol itself so that DWARF2 strings are merged correctly.
@
text
@a270 4
  /* Dwarf2 support for Gcc.  */
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},

@


1.38
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d992 2
d1059 18
d1109 6
d1451 18
a1468 10
	  /* Now create an 8-bit fixup.  If there was some %hi or %lo
	     modifier, generate the reloc accordingly.  */
	  fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
		       oper, FALSE,
		       ((opmode & M6811_OP_HIGH_ADDR)
			? BFD_RELOC_M68HC11_HI8
			: ((opmode & M6811_OP_LOW_ADDR)
			   ? BFD_RELOC_M68HC11_LO8
                           : ((mode & M6812_OP_PAGE)
                              ? BFD_RELOC_M68HC11_PAGE : BFD_RELOC_8))));
d1502 10
d1516 2
a1517 5
			  (mode & M6812_OP_JUMP_REL16 ? TRUE : FALSE),
			  (mode & M6812_OP_JUMP_REL16
			   ? BFD_RELOC_16_PCREL
                           : (mode & M6812_OP_PAGE)
                           ? BFD_RELOC_M68HC11_LO16 : BFD_RELOC_16));
d1519 1
a1519 1
      if (mode & M6812_OP_JUMP_REL16)
d1521 2
d2451 5
d3047 3
a3049 1
	  || !relaxable_symbol (fragP->fr_symbol))
d3264 1
d3268 1
a3268 1
    case BFD_RELOC_LO16:
a3272 1
    case BFD_RELOC_32:
@


1.37
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d3190 2
a3191 6
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_M68HC11_RL_GROUP:
      return 1;
d3193 1
a3193 5
    default:
      break;
    }

  return S_FORCE_RELOC (fixP->fx_addsy);
@


1.36
log
@	* config/tc-m68hc11.c (tc_m68hc11_fix_adjustable): Prevent adjustment
	of relocs for memory bank addressing.
@
text
@a21 1
#include <stdio.h>
d378 1
a378 1
  -m68hc11 | -m68hc12 |
@


1.35
log
@	* config/tc-m68hc11.c (md_show_usage): Update usage.
	(md_parse_option): Recognize -m68hcs12.
	(m68hc11_elf_final_processing): Set EF_M68HCS12_MACH flag to identify
	HCS12.
	* doc/as.texinfo (Overview): Document new option -m68hcs12.
@
text
@a3218 1
    case BFD_RELOC_LO16:
d3223 6
@


1.34
log
@	* config/tc-m68hc11.c (STATE_INDEXED_PCREL): New relax code.
	(md_relax_table): Define specific relax for PC-rel offsets.
	(build_indexed_byte): Use a STATE_INDEXED_PCREL relax code.
	(m68hc11_relax_frag): Handle the new relax code.
	(md_convert_frag): Likewise.
	(md_estimate_size_before_relax): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d378 3
a380 2
Motorola 68HC11/68HC12 options:\n\
  -m68hc11 | -m68hc12     specify the processor [default %s]\n\
d507 2
d3338 2
@


1.33
log
@	* config/tc-m68hc11.c (md_begin): Fix qsort warning.
	(tc_gen_reloc): Mark section param as not used.
@
text
@d40 3
a42 2
#define STATE_XBCC_BRANCH               (4)
#define STATE_CONDITIONAL_BRANCH_6812	(5)
d94 8
d1967 1
a1967 1
		    ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_UNDF),
d2774 1
d2779 1
d2781 1
d2907 2
a2908 3
    case ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_BITS5):
      if (fragP->fr_opcode[0] == 3
          && fragP->fr_symbol != 0
d2911 3
d2918 8
a2926 4
      if (fragP->fr_opcode[0] == 3
          && fragP->fr_symbol != 0
          && S_GET_SEGMENT (fragP->fr_symbol) != absolute_section)
        value = disp;
d2934 1
a2944 1
	  fixp->fx_pcrel_adjust = 2;
d3068 23
d3151 7
@


1.32
log
@	Fix Bug savannah/1825:
	* config/tc-m68hc11.h (md_relax_frag): Define to support relaxations
	that are not pc-relative.
	(m68hc11_relax_frag): Declare.

	* config/tc-m68hc11.c (build_indexed_byte): Use a frag_var to handle
	the offsetable indexed addressing modes (n,r).
	(build_insn): Cleanup some locals.
	(m68hc11_relax_frag): New function imported from tc-cris.c to handle
	relaxation of difference between two symbols of same section.
	(md_convert_frag): For INDEXED_OFFSET relaxs, use the displacement
	only when this is a PC-relative operand and the offset is not absolute.
	(md_estimate_size_before_relax): Convert the INDEXED_OFFSET,UNDEF frag
	to INDEXED_OFFSET,STATE_BITS5 when the symbol is absolute; this will
	be handled by m68hc11_relax_frag.
@
text
@d641 2
a642 1
  qsort (opcodes, num_opcodes, sizeof (struct m68hc11_opcode), cmp_opcode);
d2708 1
a2708 1
     asection *section;
@


1.31
log
@	* config/tc-m68hc11.c (elf_flags): Set default ABI to gcc default
	(32-bit int, 64-bit double).
	(md_longopts): New options -mshort, -mlong, -mshort-double and
	-mlong-double to control the ABI.
	(md_show_usage): Update.
	(md_parse_option): Handle new options.
	* doc/as.texinfo (Overview): Document new options for HC11/HC12.
@
text
@d1936 3
a1938 1
	  byte = (byte << 3) | 0xe2;
d1941 10
a1950 5

	  f = frag_more (2);
	  fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
		       &op->exp, FALSE, BFD_RELOC_16);
	  number_to_chars_bigendian (f, 0, 2);
a2069 2
  fragS *frag;
  int where;
a2073 3
  frag = frag_now;
  where = frag_now_fix ();

d2075 1
a2075 1
    fix_new (frag, where, 1,
d2737 91
d2895 4
d2900 1
a2900 4
      if ((fragP->fr_opcode[0] & 0x0ff) == 0x0c0)
	fragP->fr_opcode[0] |= disp & 0x1f;
      else
	fragP->fr_opcode[0] |= value & 0x1f;
d2904 4
d2910 2
a2911 2
      fix_new (fragP, fragP->fr_fix, 1,
	       fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_8);
d2918 3
a2920 1
      if ((fragP->fr_opcode[0] & 0x0ff) == 0x0fa)
d3030 17
a3046 7
	      /* Switch the indexed operation to 16-bit mode.  */
	      fragP->fr_opcode[0] = fragP->fr_opcode[0] << 3;
	      fragP->fr_opcode[0] |= 0xe2;
	      fragP->fr_fix++;
	      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
	      fragP->fr_fix++;
@


1.30
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d245 1
a245 1
static int elf_flags = 0;
d308 12
d371 4
d474 16
@


1.29
log
@gas reloc rewrite.
@
text
@d1376 1
a1376 1
			      oper, true, BFD_RELOC_8_PCREL);
d1384 1
a1384 1
		       oper, false,
d1428 1
a1428 1
			  (mode & M6812_OP_JUMP_REL16 ? true : false),
d1470 1
a1470 1
			  oper, false, BFD_RELOC_M68HC11_24);
d1910 1
a1910 1
		       &op->exp, false, BFD_RELOC_16);
@


1.28
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2694 6
a2699 8
  if (!fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else
    reloc->addend = (section->vma
		     /*+ (fixp->fx_pcrel_adjust == 64
                       ? -1 : fixp->fx_pcrel_adjust)*/
		     + fixp->fx_addnumber
		     + md_pcrel_from (fixp));
d3005 1
a3005 1
      return 0;
d3007 2
a3019 4
  /* Prevent all adjustments to global symbols.  */
  if (! relaxable_symbol (fixP->fx_addsy))
    return 0;

d3051 3
a3053 17
  else if (fixP->fx_pcrel)
    ;

  else
    {
      value = fixP->fx_offset;

      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    /* We don't actually support subtracting a symbol.  */
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("Expression too complex."));
	}
    }
a3137 4

  /* Are we finished with this relocation now?  */
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
    fixP->fx_done = 1;
@


1.27
log
@	* config/tc-m68hc11.h (MD_PCREL_FROM_SECTION): Remove.
	(TC_HANDLES_FX_DONE): Define to let md_apply_fix3 set fx_done flag
	according to the reloc.
	(tc_fix_adjustable, tc_m68hc11_fix_adjustable): Define.
	(TC_FORCE_RELOCATION): Define.
	(tc_m68hc11_force_relocation): Declare.

	* config/tc-m68hc11.c (md_pseudo_table): Add relax command.
	(s_m68hc11_relax): New function for relax group.
	(build_insn, build_jump_insn): Emit a M68HC11_RL_JUMP reloc at
	beginning of jump instruction.
	(md_pcrel_from): Rename from md_pcrel_from_section and fix
	address computation.
	(tc-gen_reloc): Update.
	(md_estimate_size_before_relax): Create the BFD_RELOC_16_PCREL as
	PC-relative fixup.
	(tc_m68hc11_force_relocation): New function, handle new relocs.
	(tc_m68hc11_fix_adjustable): New to make sure there are enough
	reloc for the linker relax pass.
	(md_apply_fix3): Handle M68HC11_RL_JUMP, M68HC11_RL_GROUP
	and VTABLE relocs.
@
text
@d264 1
a264 1
  {"file", dwarf2_directive_file, 0},
@


1.26
log
@	* config/tc-m68hc11.c (m68hc11_elf_final_processing): New function.
	(md_pseudo_table): Add .mode, .far and .interrupt pseudo op.
	(s_m68hc11_mode): New function for .mode pseudo op.
	(s_m68hc11_mark_symbol): New function for .far and .interrupt
	pseudo op.
	* config/tc-m68hc11.h (elf_tc_final_processing): Define.
	(m68hc11_elf_final_processing): Declare.
@
text
@d185 3
d270 3
d1525 2
d1547 6
d1607 6
d1622 6
d2031 2
d2036 8
d2631 22
d2655 4
d2660 2
a2661 3
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec;
d2663 1
a2663 4
  int adjust;
  if (fixp->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
d2666 1
a2666 2
  adjust = fixp->fx_pcrel_adjust;
  return fixp->fx_frag->fr_address + fixp->fx_where + adjust;
d2698 2
a2699 2
		     + (fixp->fx_pcrel_adjust == 64
			? -1 : fixp->fx_pcrel_adjust)
d2701 1
a2701 1
		     + md_pcrel_from_section (fixp, section));
d2933 1
a2933 1
		       fragP->fr_offset, 0, BFD_RELOC_16_PCREL);
d2994 48
d3145 7
d3156 4
@


1.25
log
@	* config/tc-m68hc11.c (md_begin): Take into account additional
	page operand for call instruction.
	(print_opcode_format): Likewise.
	(check_range): Likewise for page range checking.
	(get_operand): Don't skip a possible comma in operands.
	(fixup8): Generate BFD_RELOC_M68HC11_PAGE reloc.
	(fixup16): Likwise with BFD_RELOC_M68HC11_LO16.
	(fixup24): New to handle call reloc.
	(build_insn): Handle missing page operand for call instruction.
	(find): Likewise.
	(md_apply_fix3): Take into account new relocs.
	(get_operand): Fix the mode for indexed indirect addressing.
	(build_indexed_byte): Fix post index byte for indexed indirect mode.
@
text
@d185 9
d241 3
d267 9
d2512 83
d3044 8
@


1.24
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d3 1
a3 1
   Written by Stephane Carrez (stcarrez@@worldnet.fr)
d28 1
d167 1
d534 4
d622 4
d629 2
d710 9
d924 13
a936 13
   Operand              mode[0]         mode[1]       exp[0]       exp[1]
   #n                   M6811_OP_IMM16  -             O_*
   *<exp>               M6811_OP_DIRECT -             O_*
   .{+-}<exp>           M6811_OP_JUMP_REL -           O_*
   <exp>                M6811_OP_IND16  -             O_*
   ,r N,r               M6812_OP_IDX    M6812_OP_REG  O_constant   O_register
   n,-r                 M6812_PRE_DEC   M6812_OP_REG  O_constant   O_register
   n,+r                 M6812_PRE_INC   " "
   n,r-                 M6812_POST_DEC  " "
   n,r+                 M6812_POST_INC  " "
   A,r B,r D,r          M6811_OP_REG    M6812_OP_REG  O_register   O_register
   [D,r]                M6811_OP_IDX_2  M6812_OP_REG  O_register   O_register
   [n,r]                M6811_OP_IDX_1  M6812_OP_REG  O_constant   O_register  */
d998 1
a998 1
      mode = M6812_OP_IDX_2;
d1020 1
a1020 1
  if (mode == M6811_OP_NONE || mode == M6812_OP_IDX_2)
d1028 1
a1028 1
      if (*p == ']' && mode == M6812_OP_IDX_2)
d1039 1
a1039 1
	  if (mode == M6812_OP_IDX_2)
d1053 1
a1053 1
	  if (mode == M6812_OP_IDX_2)
d1061 1
d1114 1
a1114 1
      || mode == M6812_OP_IDX_2)
d1122 2
a1140 1
	  old_input_line = input_line_pointer;
d1176 1
a1176 1
	  if (mode == M6812_OP_IDX_2)
d1185 3
d1222 1
d1266 1
d1276 1
d1284 1
d1361 3
a1363 1
			   ? BFD_RELOC_M68HC11_LO8 : BFD_RELOC_8)));
d1403 3
a1405 1
			   ? BFD_RELOC_16_PCREL : BFD_RELOC_16));
d1415 36
d1776 1
a1776 1
  if (mode & M6812_OP_IDX)
d1814 1
a1814 1
	  if (val >= -16 && val <= 15 && !(mode & M6812_OP_IDX_2))
d1822 1
a1822 1
	  else if (val >= -256 && val <= 255 && !(mode & M6812_OP_IDX_2))
d1836 1
a1836 1
	      if (mode & M6812_OP_IDX_2)
d1847 9
a1855 1
      if (op->reg1 != REG_PC)
d1878 1
a1878 1
  if (mode & M6812_OP_REG)
d1880 1
a1880 1
      if (mode & M6812_OP_IDX_2)
d2035 7
d2044 2
a2045 1
      fixup16 (&operands[i].exp, format & (M6811_OP_IMM16 | M6811_OP_IND16),
d2060 2
a2061 1
	   (M6812_OP_IDX | M6812_OP_IDX_2 | M6812_OP_IDX_1 | M6812_OP_D_IDX))
d2084 4
d2126 3
d2161 2
a2188 3
		  && (format & M6812_OP_D_IDX))
		continue;
	      if (i == 0
d2213 5
d2305 4
a2308 1
	  if (opcode)
d2883 6
d2891 1
d2904 1
@


1.23
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d258 1
a258 1
CONST char *md_shortopts = "Sm:";
@


1.22
log
@	* config/tc-m68hc11.c (build_jump_insn): Allocate worst case storage
	for bra/bsr and use frag_variant(), this ensure that the possible
	16-bit BFD_RELOC_16 will be in the same frag.
@
text
@d2732 5
a2736 4
int
md_apply_fix (fixp, valuep)
     fixS *fixp;
     valueT *valuep;
d2739 1
a2739 1
  long value;
d2742 6
a2747 9
  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    {
      value = *valuep;
    }
d2750 3
a2752 2
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
d2754 2
a2755 4
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    {
	      value -= S_GET_VALUE (fixp->fx_subsy);
	    }
d2757 3
a2759 5
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("Expression too complex."));
	    }
d2763 1
a2763 1
  op_type = fixp->fx_r_type;
d2774 1
a2774 1
  where = fixp->fx_frag->fr_literal + fixp->fx_where;
d2776 1
a2776 1
  switch (fixp->fx_r_type)
d2786 1
a2786 1
	as_bad_where (fixp->fx_file, fixp->fx_line,
d2809 1
a2809 1
	as_bad_where (fixp->fx_file, fixp->fx_line,
d2816 1
a2816 1
	as_bad_where (fixp->fx_file, fixp->fx_line,
d2829 1
a2829 1
		fixp->fx_line, fixp->fx_r_type);
a2830 2

  return 0;
@


1.21
log
@	* config/tc-m68hc11.c (cmp_opcode): Define prototype.
	(print_opcode_format, skip_whites): Likewise.
	(convert_branch, m68hc11_new_insn): Likewise.
	(build_dbranch_insn, build_indexed_byte): Likewise.
	(build_reg_mode, find, find_opcode): Likewise.
	(print_insn_format): Fix call to print_opcode_format.
	(md_assemble): Fix call to build_dbranch_insn.
@
text
@d1522 2
a1523 1
	  opcode = m68hc11_new_insn (2);
d1526 4
a1529 3
	  frag_var (rs_machine_dependent, 2, 1,
		    ENCODE_RELAX (STATE_PC_RELATIVE, STATE_UNDF),
		    operands[0].exp.X_add_symbol, (offsetT) n, opcode);
@


1.20
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d155 4
d166 9
d181 1
d820 1
a820 1
      fmt = print_opcode_format (opcode, 0, 0);
d2376 1
a2376 1
    build_dbranch_insn (opcode, operands, nb_operands);
@


1.19
log
@	* config/tc-m68hc11.c (md_estimate_size_before_relax): Fix bsr
	and bra relax: update fragP->fr_fix after the fixup.
@
text
@a22 1
#include <ctype.h>
d24 1
d2237 1
a2237 1
      name[nlen] = tolower (op_start[nlen]);
d2279 1
a2279 1
		   || !isalnum (op_end[1])))
d2286 1
a2286 1
	      name[nlen++] = tolower (*op_end++);
@


1.18
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d2598 2
a2600 2
	      fix_new (fragP, old_fr_fix - 1, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
@


1.17
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@d2444 1
a2444 1
  value = fragP->fr_symbol ? S_GET_VALUE (fragP->fr_symbol) : 0;
a2445 1
  disp += symbol_get_frag (fragP->fr_symbol)->fr_address;
@


1.16
log
@	* config/tc-m68hc11.c (md_pseudo_table): Recognize xrefb to comply
	with 'Motorola specification for assembly language input standard'.
@
text
@d52 2
d2568 35
a2602 2
  int old_fr_fix;
  char *buffer_address = fragP->fr_fix + fragP->fr_literal;
d2604 43
a2646 1
  old_fr_fix = fragP->fr_fix;
d2648 16
a2663 3
  switch (fragP->fr_subtype)
    {
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_UNDF):
d2665 3
a2667 4
      /* This relax is only for bsr and bra.  */
      assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
	      || IS_OPCODE (fragP->fr_opcode[0], M6811_BRA)
	      || IS_OPCODE (fragP->fr_opcode[0], M6812_BSR));
d2669 2
a2670 3
      /* A relaxable case.  */
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	  && relaxable_symbol (fragP->fr_symbol))
d2672 6
d2679 1
a2679 19
	}
      else
	{
	  if (flag_fixed_branchs)
	    as_bad_where (fragP->fr_file, fragP->fr_line,
			  _("bra or bsr with undefined symbol."));

	  /* The symbol is undefined or in a separate section.  Turn bra into a
	     jmp and bsr into a jsr.  The insn becomes 3 bytes long (instead of
	     2).  A fixup is necessary for the unresolved symbol address.  */

	  fragP->fr_opcode[0] = convert_branch (fragP->fr_opcode[0]);

	  fragP->fr_fix++;
	  fix_new (fragP, old_fr_fix - 1, 2, fragP->fr_symbol,
		   fragP->fr_offset, 0, BFD_RELOC_16);
	  frag_wane (fragP);
	}
      break;
d2681 2
a2682 2
    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_UNDF):
      assert (current_architecture & cpu6811);
a2683 3
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	  && relaxable_symbol (fragP->fr_symbol))
	{
d2686 1
a2686 5
	}
      else
	{
	  fragP->fr_opcode[0] ^= 1;	/* Reverse sense of branch.  */
	  fragP->fr_opcode[1] = 3;	/* Skip next jmp insn (3 bytes).  */
d2688 2
a2689 11
	  /* Don't use fr_opcode[2] because this may be
             in a different frag.  */
	  buffer_address[0] = M6811_JMP;

	  fragP->fr_fix++;
	  fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		   fragP->fr_offset, 0, BFD_RELOC_16);
	  fragP->fr_fix += 2;
	  frag_wane (fragP);
	}
      break;
a2690 6
    case ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_UNDF):
      assert (current_architecture & cpu6812);

      if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	  && relaxable_symbol (fragP->fr_symbol))
	{
d2693 1
a2693 13
	}
      else
	{
	  /* Switch the indexed operation to 16-bit mode.  */
	  fragP->fr_opcode[0] = fragP->fr_opcode[0] << 3;
	  fragP->fr_opcode[0] |= 0xe2;
	  fragP->fr_fix++;
	  fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		   fragP->fr_offset, 0, BFD_RELOC_16);
	  fragP->fr_fix++;
	  frag_wane (fragP);
	}
      break;
d2695 2
a2696 2
    case ENCODE_RELAX (STATE_XBCC_BRANCH, STATE_UNDF):
      assert (current_architecture & cpu6812);
a2697 3
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	  && relaxable_symbol (fragP->fr_symbol))
	{
d2699 1
a2699 5
	}
      else
	{
	  fragP->fr_opcode[0] ^= 0x20;	/* Reverse sense of branch.  */
	  fragP->fr_opcode[1] = 3;	/* Skip next jmp insn (3 bytes).  */
d2701 2
a2702 11
	  /* Don't use fr_opcode[2] because this may be
             in a different frag.  */
	  buffer_address[0] = M6812_JMP;

	  fragP->fr_fix++;
	  fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		   fragP->fr_offset, 0, BFD_RELOC_16);
	  fragP->fr_fix += 2;
	  frag_wane (fragP);
	}
      break;
a2703 6
    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH_6812, STATE_UNDF):
      assert (current_architecture & cpu6812);

      if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	  && relaxable_symbol (fragP->fr_symbol))
	{
d2706 1
d2708 1
a2708 12
      else
	{
	  /* Translate into a lbcc branch.  */
	  fragP->fr_opcode[1] = fragP->fr_opcode[0];
	  fragP->fr_opcode[0] = M6811_OPCODE_PAGE2;

	  fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		   fragP->fr_offset, 0, BFD_RELOC_16_PCREL);
	  fragP->fr_fix += 2;
	  frag_wane (fragP);
	}
      break;
d2710 2
a2711 3
    default:
      as_fatal (_("Subtype %d is not recognized."), fragP->fr_subtype);
    }
d2713 2
a2714 1
  return (fragP->fr_fix - old_fr_fix);
@


1.15
log
@Fix copyright notices
@
text
@d234 3
@


1.14
log
@	* config/tc-m68hc11.h (LISTING_HEADER): Use m68hc11_listing_header
	function to select the header according to the cpu.
	(md_after_pass_hook, md_do_align): Remove.
	(md_cleanup, m68hc11_cleanup): Remove.
	(md_pcrel_from_section): Declare.
	* config/tc-m68hc11.c (build_dbranch_insn): Remove insn_size.
	(build_jump_insn, build_insn): Likewise.
	(m68hc11_listing_header): New function.
	(m68hc11_cleanup): Remove.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001 Free Software Foundation.
@


1.13
log
@	* tc-m68hc11.c (relaxable_symbol): Relax externally visible symbols
	because there is no support for shared libraries and these symbols
	can't be overridden (unless they are weak).
@
text
@d229 2
d293 10
d386 1
a386 1
      /* -S means keep external to 2 bits offset rather than 16 bits one.  */
d1213 1
a1213 1
  /* The 68HC12 supports 5, 9 and 16-bits offsets.  */
d1322 1
a1322 1
/* Put a 2 bytes expression described by 'oper'.  If this expression contains
a1406 1
  int insn_size;
a1416 1
  insn_size = 1;
a1539 1
  int insn_size;
a1549 1
  insn_size = 1;
a1882 1
  int insn_size = 1;
a1901 1
      insn_size = 2;
d1917 1
a1917 1
	  insn_size += build_indexed_byte (&operands[0], format, 1);
d1923 1
a1923 1
	  insn_size += build_indexed_byte (&operands[1], format, 1);
a1930 1
      insn_size++;
a1937 1
      insn_size += 2;
a1948 1
      insn_size++;
d1955 1
a1955 1
      insn_size += build_indexed_byte (&operands[i], format, move_insn);
d1960 1
a1960 1
      insn_size += build_reg_mode (&operands[i], format);
a1964 1
      insn_size++;
a1969 1
      insn_size++;
a1970 1
      i++;
a1973 1
      insn_size += 2;
d2290 1
a2290 1
     68HC12 to emulate a fiew 68HC11 instructions.  */
a2809 6
}

int
m68hc11_cleanup ()
{
  return 1;
@


1.12
log
@2001-01-15  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-m68hc11.c: Fix formatting.
@
text
@d2546 4
a2549 3
/* On an ELF system, we can't relax an externally visible symbol,
   as well as a weak symbol.  The weak symbol can be overriden
   at final link time by a non weak symbol.  */
d2554 1
a2554 1
  return ! S_IS_EXTERNAL (symbol) && ! S_IS_WEAK (symbol);
@


1.12.2.1
log
@	* tc-m68hc11.c (relaxable_symbol): Relax externally visible symbols
	because there is no support for shared libraries and these symbols
	can't be overridden (unless they are weak).
@
text
@d2546 3
a2548 4
/* On an ELF system, we can't relax a weak symbol.  The weak symbol
   can be overridden at final link time by a non weak symbol.  We can
   relax externally visible symbol because there is no shared library
   and such symbol can't be overridden (unless they are weak).  */
d2553 1
a2553 1
  return ! S_IS_WEAK (symbol);
@


1.12.2.2
log
@	* config/tc-m68hc11.h (LISTING_HEADER): Use m68hc11_listing_header
	function to select the header according to the cpu.
	(md_after_pass_hook, md_do_align): Remove.
	(md_cleanup, m68hc11_cleanup): Remove.
	(md_pcrel_from_section): Declare.
	* config/tc-m68hc11.c (build_dbranch_insn): Remove insn_size.
	(build_jump_insn, build_insn): Likewise.
	(m68hc11_listing_header): New function.
	(m68hc11_cleanup): Remove.
@
text
@a228 2

  /* Dwarf2 support for Gcc.  */
a290 10
/* Listing header selected according to cpu.  */
const char *
m68hc11_listing_header ()
{
  if (current_architecture & cpu6811)
    return "M68HC11 GAS ";
  else
    return "M68HC12 GAS ";
}

d374 1
a374 1
      /* -S means keep external to 2 bit offset rather than 16 bit one.  */
d1201 1
a1201 1
  /* The 68HC12 supports 5, 9 and 16-bit offsets.  */
d1310 1
a1310 1
/* Put a 2 byte expression described by 'oper'.  If this expression contains
d1395 1
d1406 1
d1530 1
d1541 1
d1875 1
d1895 1
d1911 1
a1911 1
	  build_indexed_byte (&operands[0], format, 1);
d1917 1
a1917 1
	  build_indexed_byte (&operands[1], format, 1);
d1925 1
d1933 1
d1945 1
d1952 1
a1952 1
      build_indexed_byte (&operands[i], format, move_insn);
d1957 1
a1957 1
      build_reg_mode (&operands[i], format);
d1962 1
d1968 1
d1970 1
d1974 1
d2291 1
a2291 1
     68HC12 to emulate a few 68HC11 instructions.  */
d2811 6
@


1.12.2.3
log
@	* config/tc-m68hc11.c (md_pseudo_table): Recognize xrefb to comply
	with 'Motorola specification for assembly language input standard'.
@
text
@a233 3
  /* Motorola ALIS.  */
  {"xrefb", s_ignore, 0}, /* Same as xref  */

@


1.12.2.4
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.12.2.5
log
@Merge from mainline.
@
text
@a51 2
#define RELAX_STATE(s) ((s) >> 2)
#define RELAX_LENGTH(s) ((s) & 3)
d2566 2
a2567 8
  if (RELAX_LENGTH (fragP->fr_subtype) == STATE_UNDF)
    {
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment
	  || !relaxable_symbol (fragP->fr_symbol))
	{
	  /* Non-relaxable cases.  */
	  int old_fr_fix;
	  char *buffer_address;
d2569 1
a2569 2
	  old_fr_fix = fragP->fr_fix;
	  buffer_address = fragP->fr_fix + fragP->fr_literal;
d2571 3
a2573 3
	  switch (RELAX_STATE (fragP->fr_subtype))
	    {
	    case STATE_PC_RELATIVE:
d2575 4
a2578 4
	      /* This relax is only for bsr and bra.  */
	      assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
		      || IS_OPCODE (fragP->fr_opcode[0], M6811_BRA)
		      || IS_OPCODE (fragP->fr_opcode[0], M6812_BSR));
d2580 21
a2600 74
	      if (flag_fixed_branchs)
		as_bad_where (fragP->fr_file, fragP->fr_line,
			      _("bra or bsr with undefined symbol."));

	      /* The symbol is undefined or in a separate section.
		 Turn bra into a jmp and bsr into a jsr.  The insn
		 becomes 3 bytes long (instead of 2).  A fixup is
		 necessary for the unresolved symbol address.  */
	      fragP->fr_opcode[0] = convert_branch (fragP->fr_opcode[0]);

	      fragP->fr_fix++;
	      fix_new (fragP, old_fr_fix - 1, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
	      break;

	    case STATE_CONDITIONAL_BRANCH:
	      assert (current_architecture & cpu6811);

	      fragP->fr_opcode[0] ^= 1;	/* Reverse sense of branch.  */
	      fragP->fr_opcode[1] = 3;	/* Skip next jmp insn (3 bytes).  */

	      /* Don't use fr_opcode[2] because this may be
		 in a different frag.  */
	      buffer_address[0] = M6811_JMP;

	      fragP->fr_fix++;
	      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
	      fragP->fr_fix += 2;
	      break;

	    case STATE_INDEXED_OFFSET:
	      assert (current_architecture & cpu6812);

	      /* Switch the indexed operation to 16-bit mode.  */
	      fragP->fr_opcode[0] = fragP->fr_opcode[0] << 3;
	      fragP->fr_opcode[0] |= 0xe2;
	      fragP->fr_fix++;
	      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
	      fragP->fr_fix++;
	      break;

	    case STATE_XBCC_BRANCH:
	      assert (current_architecture & cpu6812);

	      fragP->fr_opcode[0] ^= 0x20;	/* Reverse sense of branch.  */
	      fragP->fr_opcode[1] = 3;	/* Skip next jmp insn (3 bytes).  */

	      /* Don't use fr_opcode[2] because this may be
		 in a different frag.  */
	      buffer_address[0] = M6812_JMP;

	      fragP->fr_fix++;
	      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16);
	      fragP->fr_fix += 2;
	      break;

	    case STATE_CONDITIONAL_BRANCH_6812:
	      assert (current_architecture & cpu6812);

	      /* Translate into a lbcc branch.  */
	      fragP->fr_opcode[1] = fragP->fr_opcode[0];
	      fragP->fr_opcode[0] = M6811_OPCODE_PAGE2;

	      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		       fragP->fr_offset, 0, BFD_RELOC_16_PCREL);
	      fragP->fr_fix += 2;
	      break;

	    default:
	      as_fatal (_("Subtype %d is not recognized."), fragP->fr_subtype);
	    }
d2602 2
d2605 2
a2606 3
	  /* Return the growth in the fixed part of the frag.  */
	  return fragP->fr_fix - old_fr_fix;
	}
d2608 2
a2609 2
      /* Relaxable cases.  */
      switch (RELAX_STATE (fragP->fr_subtype))
a2610 12
	case STATE_PC_RELATIVE:
	  /* This relax is only for bsr and bra.  */
	  assert (IS_OPCODE (fragP->fr_opcode[0], M6811_BSR)
		  || IS_OPCODE (fragP->fr_opcode[0], M6811_BRA)
		  || IS_OPCODE (fragP->fr_opcode[0], M6812_BSR));

	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	  break;

	case STATE_CONDITIONAL_BRANCH:
	  assert (current_architecture & cpu6811);

d2613 17
a2629 1
	  break;
d2631 2
a2632 2
	case STATE_INDEXED_OFFSET:
	  assert (current_architecture & cpu6812);
d2634 3
d2639 13
a2651 1
	  break;
d2653 2
a2654 2
	case STATE_XBCC_BRANCH:
	  assert (current_architecture & cpu6812);
d2656 3
d2660 17
a2676 1
	  break;
d2678 2
a2679 2
	case STATE_CONDITIONAL_BRANCH_6812:
	  assert (current_architecture & cpu6812);
d2681 3
a2685 1
	  break;
d2687 15
d2704 1
a2704 5
  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    as_fatal (_("Subtype %d is not recognized."), fragP->fr_subtype);

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
@


1.12.2.6
log
@	* config/tc-m68hc11.c (cmp_opcode): Define prototype.
	(print_opcode_format, skip_whites): Likewise.
	(convert_branch, m68hc11_new_insn): Likewise.
	(build_dbranch_insn, build_indexed_byte): Likewise.
	(build_reg_mode, find, find_opcode): Likewise.
	(print_insn_format): Fix call to print_opcode_format.
	(md_assemble): Fix call to build_dbranch_insn.
@
text
@a154 4
static int cmp_opcode PARAMS ((struct m68hc11_opcode *,
                               struct m68hc11_opcode *));
static char *print_opcode_format PARAMS ((struct m68hc11_opcode *, int));
static char *skip_whites PARAMS ((char *));
a161 9
static unsigned char convert_branch PARAMS ((unsigned char));
static char *m68hc11_new_insn PARAMS ((int));
static void build_dbranch_insn PARAMS ((struct m68hc11_opcode *,
                                        operand *, int, int));
static int build_indexed_byte PARAMS ((operand *, int, int));
static int build_reg_mode PARAMS ((operand *, int));

static struct m68hc11_opcode *find
  PARAMS ((struct m68hc11_opcode_def *, operand *, int));
a167 1
static int relaxable_symbol PARAMS ((symbolS *));
d806 1
a806 1
      fmt = print_opcode_format (opcode, 0);
d2362 1
a2362 1
    build_dbranch_insn (opcode, operands, nb_operands, branch_optimize);
@


1.12.2.7
log
@	* config/tc-m68hc11.c (build_jump_insn): Allocate worst case storage
	for bra/bsr and use frag_variant(), this ensure that the possible
	16-bit BFD_RELOC_16 will be in the same frag.
@
text
@d1522 1
a1522 2
          /* Allocate worst case storage.  */
	  opcode = m68hc11_new_insn (3);
d1525 3
a1527 4
	  frag_variant (rs_machine_dependent, 1, 1,
                        ENCODE_RELAX (STATE_PC_RELATIVE, STATE_UNDF),
                        operands[0].exp.X_add_symbol, (offsetT) n,
                        opcode);
@


1.11
log
@Fix gas 68HC12 indexed addressing code generation
@
text
@d64 1
a64 2
relax_typeS md_relax_table[] =
{
d107 1
a107 2
typedef enum register_id
{
d119 1
a119 2
typedef struct operand
{
d126 1
a126 2
struct m68hc11_opcode_def
{
d138 1
a138 2
typedef struct alias
{
d141 1
a141 2
}
alias;
d143 1
a143 2
static alias alias_opcodes[] =
{
d223 1
a223 2
const pseudo_typeS md_pseudo_table[] =
{
d239 1
a239 2
struct option md_longopts[] =
{
d1067 2
a1068 2
          int possible_mode = M6811_OP_NONE;
          char *old_input_line;
d1086 1
a1086 1
          old_input_line = input_line_pointer;
d1090 17
a1106 17
          /* Backtrack if we have a valid constant expression and
             it does not correspond to the offset of the 68HC12 indexed
             addressing mode (as in N,x).  */
          if (reg == REG_NONE && mode == M6811_OP_NONE
              && possible_mode != M6811_OP_NONE)
            {
              oper->mode = M6811_OP_IND16 | M6811_OP_JUMP_REL;
              input_line_pointer = skip_whites (old_input_line);
              return 1;
            }

          if (possible_mode != M6811_OP_NONE)
            mode = possible_mode;

          if ((current_architecture & cpu6811)
              && possible_mode != M6811_OP_NONE)
            as_bad (_("Pre-increment mode is not valid for 68HC11"));
d1711 1
a1711 1
                      val);
d1749 19
a1767 19
        {
          byte = (byte << 3) | 0xe2;
          f = frag_more (1);
          number_to_chars_bigendian (f, byte, 1);

          f = frag_more (2);
          fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
                       &op->exp, false, BFD_RELOC_16);
          number_to_chars_bigendian (f, 0, 2);
        }
      else
        {
          f = frag_more (1);
          number_to_chars_bigendian (f, byte, 1);
          frag_var (rs_machine_dependent, 2, 2,
                    ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_UNDF),
                    op->exp.X_add_symbol,
                    op->exp.X_add_number, f);
        }
d2493 1
a2493 1
        fragP->fr_opcode[0] |= disp & 0x1f;
d2495 1
a2495 1
        fragP->fr_opcode[0] |= value & 0x1f;
d2510 11
a2520 11
        {
          fixp = fix_new (fragP, fragP->fr_fix, 2,
                          fragP->fr_symbol, fragP->fr_offset,
                          1, BFD_RELOC_16_PCREL);
          fixp->fx_pcrel_adjust = 2;
        }
      else
        {
          fix_new (fragP, fragP->fr_fix, 2,
                   fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_16);
        }
d2551 1
a2551 1
     symbolS* symbol;
d2579 1
a2579 1
          && relaxable_symbol (fragP->fr_symbol))
d2606 1
a2606 1
          && relaxable_symbol (fragP->fr_symbol))
d2632 1
a2632 1
          && relaxable_symbol (fragP->fr_symbol))
d2640 2
a2641 2
          fragP->fr_opcode[0] = fragP->fr_opcode[0] << 3;
          fragP->fr_opcode[0] |= 0xe2;
d2654 1
a2654 1
          && relaxable_symbol (fragP->fr_symbol))
d2679 1
a2679 1
          && relaxable_symbol (fragP->fr_symbol))
@


1.10
log
@Fix weak symbols for 68HC11 as
@
text
@d88 1
a88 1
  {0, 0, 1, 0},
d1757 20
a1776 9
      f = frag_more (1);
      number_to_chars_bigendian (f, byte, 1);
#if 0
      fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
		   &op->exp, false, BFD_RELOC_16);
#endif
      frag_var (rs_machine_dependent, 2, 2,
		ENCODE_RELAX (STATE_INDEXED_OFFSET, STATE_UNDF),
		op->exp.X_add_symbol, val, f);
d2439 1
d2449 2
a2450 2
  disp = fragP->fr_symbol ? S_GET_VALUE (fragP->fr_symbol) : 0;
  disp = (disp + fragP->fr_offset) - object_address;
d2500 5
a2504 2
      fragP->fr_opcode[0] = fragP->fr_opcode[0] << 5;
      fragP->fr_opcode[0] |= disp & 0x1f;
d2510 1
a2510 1
      fix_new (fragP, fragP->fr_fix + 1, 1,
d2517 14
a2530 4
      fragP->fr_opcode[0] |= 0xE2;
      fix_new (fragP, fragP->fr_fix, 2,
	       fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_16);
      fragP->fr_fix += 1;
d2649 2
a2650 3
	  if ((fragP->fr_opcode[1] & 0x21) == 0x20)
	    fragP->fr_opcode[1] = (fragP->fr_opcode[1] >> 3) | 0xc0 | 0x02;

d2654 1
a2654 1
	  fragP->fr_fix += 2;
@


1.9
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation.
d2530 10
d2562 2
a2563 1
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
d2589 2
a2590 1
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
d2615 2
a2616 1
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
d2638 2
a2639 1
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
d2663 2
a2664 1
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
@


1.8
log
@Fix movw/movb operands for 68HC12
@
text
@d1112 1
a1112 1
          
d1115 1
a1115 1
            as_bad (_("Pre-increment mode is not valid for 68HC11"));            
@


1.7
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d1076 2
d1085 1
a1085 1
		  mode = M6812_PRE_DEC;
a1086 2
		  if (current_architecture & cpu6811)
		    as_bad (_("Pre-decrement mode is not valid for 68HC11"));
d1090 1
a1090 1
		  mode = M6812_PRE_INC;
a1091 2
		  if (current_architecture & cpu6811)
		    as_bad (_("Pre-increment mode is not valid for 68HC11"));
d1095 1
d1099 17
d1719 2
a1720 1
	      as_bad (_("Offset out of 5-bit range for movw/movb insn."));
@


1.6
log
@Add --gdwarf2 support to ARM toolchain
@
text
@d1374 1
a1374 3
  /* Emit line number information in dwarf2 debug sections.  */
  if (debug_type == DEBUG_DWARF2)
    dwarf2_generate_asm_lineno (size);
a2768 35
}

void
m68hc11_end_of_source ()
{
  segT saved_seg;
  subsegT saved_subseg;
  segT debug_info;
  char *p;
  long total_size = 0;

  if (debug_type != DEBUG_DWARF2)
    return;

  dwarf2_finish ();

  saved_seg = now_seg;
  saved_subseg = now_subseg;

  debug_info = subseg_new (".debug_info", 0);
  bfd_set_section_flags (stdoutput, debug_info, SEC_READONLY);
  subseg_set (debug_info, 0);
  p = frag_more (10);
  total_size = 12;

# define STUFF(val,size)	md_number_to_chars (p, val, size); p += size;
  STUFF (total_size, 4); /* Length of compilation unit.  */
  STUFF (2, 2); /* Dwarf version */
  STUFF (0, 4);
  STUFF (2, 1); /* Pointer size */
  STUFF (1, 1); /* Compile unit */
  STUFF (0, 4);

  now_subseg = saved_subseg;
  now_seg = saved_seg;
@


1.5
log
@2000-09-20  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-m32r.c: Fix formatting.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68851.h: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.h: Likewise.
@
text
@a28 2
struct dwarf2_line_info debug_line;

d1376 1
a1376 2
    {
      bfd_vma addr;
a1377 4
      dwarf2_where (&debug_line);
      addr = frag_now->fr_address + frag_now_fix () - size;
      dwarf2_gen_line_info (addr, &debug_line);
    }
@


1.4
log
@Make sure the 2 bytes of the jump address are in the same frag.
Accept 68hc12 register indirect modes.

Mention 68HC11 & 68HC12 support in NEWS.
@
text
@d2184 1
a2184 1
  
d2770 1
a2770 1
  
@


1.3
log
@Fix formatting.
@
text
@d1498 1
a1498 1
	  frag_var (rs_machine_dependent, 1, 1,
d2049 3
a2051 2
	      if (i == 0 && format & M6812_OP_REG
		  && operands[i].reg2 == REG_NONE)
d2053 11
a2063 6
	      if (i == 0 && format & M6812_OP_REG
		  && format & M6812_OP_REG_2 && operands[i].reg2 != REG_NONE)
		{
		  continue;
		}
	      if (i == 0 && format & M6812_OP_D_IDX)
d2065 2
a2066 1
	      if (i == 0 && (format & M6812_OP_IDX)
d2069 2
a2070 1
	      if (i == 1 && format & M6812_OP_IDX_P2)
@


1.2
log
@Fix comments.
@
text
@d61 10
a70 9
   How far Forward this mode will reach:
   How far Backward this mode will reach:
   How many bytes this mode will add to the size of the frag
   Which mode to go to if the offset won't fit in this one    */

relax_typeS md_relax_table[] = {
  {1, 1, 0, 0},			/* First entries aren't used */
  {1, 1, 0, 0},			/* For no good reason except */
  {1, 1, 0, 0},			/* that the VAX doesn't either */
d151 2
a152 1
static alias alias_opcodes[] = {
d159 4
a162 5
/* local functions */
static register_id reg_name_search PARAMS ((char *name));
static register_id register_name PARAMS (());
static int check_range PARAMS ((long num, int mode));

a163 1

d165 4
a168 4
static void print_insn_format PARAMS ((char *name));
static int get_operand PARAMS ((operand * op, int first, long opmode));
static void fixup8 PARAMS ((expressionS * oper, int mode, int opmode));
static void fixup16 PARAMS ((expressionS * oper, int mode, int opmode));
d170 1
a170 3
PARAMS (
	(struct m68hc11_opcode_def * opc, operand operands[],
	 int *nb_operands));
d172 3
a174 6
PARAMS (
	(struct m68hc11_opcode * opcode, operand operands[], int nb_operands,
	 int optimize));

static void build_insn PARAMS ((struct m68hc11_opcode * opcode,
			       operand operands[], int nb_operands));
d184 1
a184 1
 
d232 2
a233 1
const pseudo_typeS md_pseudo_table[] = {
a243 1

d249 2
a250 1
struct option md_longopts[] = {
a301 1

d434 1
a434 1
/* Equal to MAX_PRECISION in atof-ieee.c */
a440 1

a503 1

a615 1

d742 2
a743 4
    {
      printf (_("# Example of `%s' instructions\n\t.sect .text\n_start:\n"),
	      default_cpu);
    }
a775 1

a807 1

d847 1
a847 1
/* register_name() checks the string at input_line_pointer
d865 1
a865 1
  /* look to see if it's in the register table.  */
d881 1
a881 2
/* get_operands parses a string of operands and returns
   an array of expressions.
d895 1
a895 4
   [n,r]                M6811_OP_IDX_1  M6812_OP_REG  O_constant   O_register

*/

d929 1
a929 1
                  which);
d1102 1
a1102 1
	  /* Backtrack... */
d1172 1
a1172 3
    {
      mode = M6811_OP_IND16 | M6811_OP_JUMP_REL;
    }
d1194 1
a1194 3
    {
      return (num != 0 && num <= 8 && num >= -8);
    }
d1198 1
a1198 3
    {
      mode = M6811_OP_IND16;
    }
a1235 1

d1322 1
a1322 1
                  oper->X_add_number);
a1344 1

d1368 1
a1368 1
static char*
d1372 1
a1372 1
  char* f;
d1380 1
a1380 1
          
d1645 1
a1645 1
                      val);
d1751 4
a1754 3
      /*
         fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
         &op->exp, false, BFD_RELOC_16); */
a1967 1

a2122 1

d2153 1
a2153 3
	{
	  return 0;
	}
d2170 1
a2170 3
	    {
	      return opcode;
	    }
d2176 1
a2182 1

d2205 1
a2205 1
  /* Drop leading whitespace */
d2317 1
a2317 1
      
a2351 1

a2353 1

d2362 1
a2362 1
          || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
d2452 1
a2452 1
      fragP->fr_opcode[1] = 3;	/* Branch offset */
d2569 2
a2570 2
	  fragP->fr_opcode[0] ^= 1;	/* Reverse sense of branch. */
	  fragP->fr_opcode[1] = 3;	/* Skip next jmp insn (3 bytes) */
d2615 1
a2615 1
	  fragP->fr_opcode[0] ^= 0x20;	/* Reverse sense of branch. */
d2723 1
a2723 1
      /* Fall through */
d2727 3
a2729 1
      /*bfd_putb8 ((bfd_vma) value, (unsigned char *) where); */
d2734 3
a2736 1
      /*bfd_putb8 ((bfd_vma) value, (unsigned char *) where); */
d2762 1
d2778 1
a2778 1
  char* p;
d2780 1
a2780 1
  
d2783 1
a2783 1
  
d2794 1
a2794 1
  
@


1.1
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d443 2
a444 2
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
@

