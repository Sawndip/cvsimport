head	1.74;
access;
symbols
	binutils-2_24-branch:1.74.0.4
	binutils-2_24-branchpoint:1.74
	binutils-2_21_1:1.73
	binutils-2_23_2:1.74
	binutils-2_23_1:1.74
	binutils-2_23:1.74
	binutils-2_23-branch:1.74.0.2
	binutils-2_23-branchpoint:1.74
	binutils-2_22_branch:1.73.0.6
	binutils-2_22:1.73
	binutils-2_22-branch:1.73.0.4
	binutils-2_22-branchpoint:1.73
	binutils-2_21:1.73
	binutils-2_21-branch:1.73.0.2
	binutils-2_21-branchpoint:1.73
	binutils-2_20_1:1.69
	binutils-2_20:1.69
	binutils-arc-20081103-branch:1.67.0.6
	binutils-arc-20081103-branchpoint:1.67
	binutils-2_20-branch:1.69.0.2
	binutils-2_20-branchpoint:1.69
	dje-cgen-play1-branch:1.68.0.2
	dje-cgen-play1-branchpoint:1.68
	arc-20081103-branch:1.67.0.4
	arc-20081103-branchpoint:1.67
	binutils-2_19_1:1.67
	binutils-2_19:1.67
	binutils-2_19-branch:1.67.0.2
	binutils-2_19-branchpoint:1.67
	binutils-2_18:1.61
	binutils-2_18-branch:1.61.0.2
	binutils-2_18-branchpoint:1.61
	binutils-csl-coldfire-4_1-32:1.55
	binutils-csl-sourcerygxx-4_1-32:1.55
	binutils-csl-innovasic-fido-3_4_4-33:1.55
	binutils-csl-sourcerygxx-3_4_4-32:1.50
	binutils-csl-coldfire-4_1-30:1.55
	binutils-csl-sourcerygxx-4_1-30:1.55
	binutils-csl-coldfire-4_1-28:1.55
	binutils-csl-sourcerygxx-4_1-29:1.55
	binutils-csl-sourcerygxx-4_1-28:1.55
	binutils-csl-arm-2006q3-27:1.55
	binutils-csl-sourcerygxx-4_1-27:1.55
	binutils-csl-arm-2006q3-26:1.55
	binutils-csl-sourcerygxx-4_1-26:1.55
	binutils-csl-sourcerygxx-4_1-25:1.55
	binutils-csl-sourcerygxx-4_1-24:1.55
	binutils-csl-sourcerygxx-4_1-23:1.55
	binutils-csl-sourcerygxx-4_1-21:1.55
	binutils-csl-arm-2006q3-21:1.55
	binutils-csl-sourcerygxx-4_1-22:1.55
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.55
	binutils-csl-sourcerygxx-4_1-20:1.55
	binutils-csl-arm-2006q3-19:1.55
	binutils-csl-sourcerygxx-4_1-19:1.55
	binutils-csl-sourcerygxx-4_1-18:1.55
	binutils-csl-renesas-4_1-9:1.55
	binutils-csl-sourcerygxx-3_4_4-25:1.50
	binutils-csl-renesas-4_1-8:1.55
	binutils-csl-renesas-4_1-7:1.55
	binutils-csl-renesas-4_1-6:1.55
	binutils-csl-sourcerygxx-4_1-17:1.55
	binutils-csl-sourcerygxx-4_1-14:1.55
	binutils-csl-sourcerygxx-4_1-15:1.55
	binutils-csl-sourcerygxx-4_1-13:1.55
	binutils-2_17:1.55
	binutils-csl-sourcerygxx-4_1-12:1.55
	binutils-csl-sourcerygxx-3_4_4-21:1.55
	binutils-csl-wrs-linux-3_4_4-24:1.50
	binutils-csl-wrs-linux-3_4_4-23:1.50
	binutils-csl-sourcerygxx-4_1-9:1.55
	binutils-csl-sourcerygxx-4_1-8:1.55
	binutils-csl-sourcerygxx-4_1-7:1.55
	binutils-csl-arm-2006q1-6:1.55
	binutils-csl-sourcerygxx-4_1-6:1.55
	binutils-csl-wrs-linux-3_4_4-22:1.50
	binutils-csl-coldfire-4_1-11:1.55
	binutils-csl-sourcerygxx-3_4_4-19:1.55
	binutils-csl-coldfire-4_1-10:1.55
	binutils-csl-sourcerygxx-4_1-5:1.55
	binutils-csl-sourcerygxx-4_1-4:1.55
	binutils-csl-wrs-linux-3_4_4-21:1.50
	binutils-csl-morpho-4_1-4:1.55
	binutils-csl-sourcerygxx-3_4_4-17:1.55
	binutils-csl-wrs-linux-3_4_4-20:1.50
	binutils-2_17-branch:1.55.0.4
	binutils-2_17-branchpoint:1.55
	binutils-csl-2_17-branch:1.55.0.2
	binutils-csl-2_17-branchpoint:1.55
	binutils-csl-gxxpro-3_4-branch:1.50.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.50
	binutils-2_16_1:1.50
	binutils-csl-arm-2005q1b:1.50
	binutils-2_16:1.50
	binutils-csl-arm-2005q1a:1.50
	binutils-csl-arm-2005q1-branch:1.50.0.4
	binutils-csl-arm-2005q1-branchpoint:1.50
	binutils-2_16-branch:1.50.0.2
	binutils-2_16-branchpoint:1.50
	csl-arm-2004-q3d:1.47
	csl-arm-2004-q3:1.47
	binutils-2_15:1.45
	binutils-2_15-branchpoint:1.45
	csl-arm-2004-q1a:1.45
	csl-arm-2004-q1:1.45
	binutils-2_15-branch:1.45.0.6
	cagney_bfdfile-20040213-branch:1.45.0.4
	cagney_bfdfile-20040213-branchpoint:1.45
	cagney_bigcore-20040122-branch:1.45.0.2
	cagney_bigcore-20040122-branchpoint:1.45
	csl-arm-2003-q4:1.45
	binutils-2_14:1.41
	binutils-2_14-branch:1.41.0.2
	binutils-2_14-branchpoint:1.41
	binutils-2_13_2_1:1.36
	binutils-2_13_2:1.36
	binutils-2_13_1:1.36
	binutils-2_13:1.36
	binutils-2_13-branchpoint:1.36
	binutils-2_13-branch:1.36.0.2
	binutils-2_12_1:1.34.2.1
	binutils-2_12:1.34.2.1
	binutils-2_12-branch:1.34.0.2
	binutils-2_12-branchpoint:1.34
	cygnus_cvs_20020108_pre:1.33
	binutils-2_11_2:1.16.2.1
	binutils-2_11_1:1.16.2.1
	binutils-2_11:1.16
	x86_64versiong3:1.17
	binutils-2_11-branch:1.16.0.2
	binutils-2_10_1:1.3.2.2
	binutils-2_10:1.3.2.2
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.74
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2012.03.07.17.51.56;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2010.09.23.12.11.31;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2010.09.08.11.07.39;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.18.10.03.06;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.13.10.40.28;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.30.15.18.29;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.19.17.31.24;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.19.11.48.57;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.22.22.34.16;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2007.01.12.06.23.52;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.19.15.47.33;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.03.14.26.41;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.11.17.39.49;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.51;

1.51
date	2005.05.05.09.13.01;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.03.11.47.54;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2004.11.23.14.49.11;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2004.11.12.12.27.05;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.28.21.33.07;	author dj;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.06.11.01.48;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.10.04.44.56;	author aoliva;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.10.03.20.14;	author aoliva;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.10.02.50.00;	author aoliva;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.12.03.16.33;	author aoliva;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.11.09.53.49;	author kazu;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.12.07.41.35;	author aoliva;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.23.01.52.18;	author aoliva;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.11.15.21.28.57;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.05.07.49.24;	author aoliva;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.25.08.51.52;	author aoliva;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.19.05.33.28;	author hjl;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.18.10.08.15;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.30.06.15.49;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.16.01.48.51;	author aoliva;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.14.20.01.12;	author aoliva;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.13.23.16.30;	author aoliva;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.09.13.32.01;	author aoliva;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.06.20.05.28;	author aoliva;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.14.06.53.57;	author aoliva;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.06.07.50.48;	author aoliva;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.30.00.06.10;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.23.18.32.51;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.17.08.47.52;	author rth;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2000.11.14.20.57.30;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.02.19.17.04;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.01.00.54.00;	author echristo;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.05.21.01.39;	author echristo;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.31.18.30.51;	author echristo;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.22.01.20.41;	author echristo;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.28.03.33.32;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.17.21.06.14;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.27.21.40.22;	author aoliva;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.12.06.16.30;	author aoliva;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.20.22.18.27;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.03.20.20.26;	author aoliva;	state Exp;
branches;
next	1.3;

1.3
date	99.12.01.10.40.07;	author law;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.06.22.14.07.37;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.34.2.1
date	2002.02.12.07.40.44;	author aoliva;	state Exp;
branches;
next	;

1.16.2.1
date	2001.05.23.03.41.10;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2000.04.04.22.42.23;	author aoliva;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2000.04.20.22.18.36;	author aoliva;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.74
log
@	* mn10300.h (elf_mn10300_reloc_type): Add R_MN10300_TLS_GD,
	R_MN10300_TLS_LD, R_MN10300_TLS_LDO, R_MN10300_TLS_GOTIE,
	R_MN10300_TLS_IE, R_MN10300_TLS_LE, R_MN10300_TLS_DPTMOD,
	R_MN10300_TLS_DTPOFF and R_MN10300_TLS_TPOFF.

	* elf-m10300.c (elf32_mn10300_link_hash_entry): Add tls_type
	field.
	(elf32_mn10300_link_hash_table): Add tls_ldm_got entry;
	(elf_mn10300_tdata): Define.
	(elf_mn10300_local_got_tls_type): Define.
	(elf_mn10300_howto_table): Add entries for R_MN10300_TLS_GD,
	R_MN10300_TLS_LD, R_MN10300_TLS_LDO, R_MN10300_TLS_GOTIE,
	R_MN10300_TLS_IE, R_MN10300_TLS_LE, R_MN10300_TLS_DPTMOD,
	R_MN10300_TLS_DTPOFF, R_MN10300_TLS_TPOFF relocs.
	(mn10300_reloc_map): Likewise.
	(elf_mn10300_tls_transition): New function.
	(dtpoff, tpoff, mn10300_do_tls_transition): New functions.
	(mn10300_elf_check_relocs): Add TLS support.
	(mn10300_elf_final_link_relocate): Likewise.
	(mn10300_elf_relocate_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(elf32_mn10300_link_hash_newfunc): Initialise new field.
	(_bfd_mn10300_copy_indirect_symbol): New function.
	(elf32_mn10300_link_hash_table_create): Initialise new fields.
	(_bfd_mn10300_elf_size_dynamic_sections): Add TLS support.
	(_bfd_mn10300_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mn10300_elf_reloc_type_class): Allocate an
	elf_mn10300_obj_tdata structure.
	(elf_backend_copy_indirect_symbol): Define.
	* reloc.c (BFD_MN10300_TLS_GD, BFD_MN10300_TLS_LD,
	BFD_MN10300_TLS_LDO, BFD_MN10300_TLS_GOTIE, BFD_MN10300_TLS_IE,
	BFD_MN10300_TLS_LE, BFD_MN10300_TLS_DPTMOD,
	BFD_MN10300_TLS_DTPOFF, BFD_MN10300_TLS_TPOFF): New relocations.
	(BFD_RELOC_MN10300_32_PCREL, BFD_RELOC_MN10300_16_PCREL): Move to
	alongside other MN10300 relocations.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* config/tc-mn10300.c (other_registers): Add SSP and USP.
	(md_assemble): Add support for TLS relocs.
	(mn10300_parse_name): Likewise.

	* readelf.c (is_16bit_abs_reloc): Add detection of R_MN10300_16.
@
text
@/* tc-mn10300.c -- Assembler code for the Matsushita 10300
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/mn10300.h"
#include "dwarf2dbg.h"
#include "libiberty.h"

/* Structure to hold information about predefined registers.  */
struct reg_name
{
  const char *name;
  int value;
};

/* Generic assembler global variables which must be defined by all
   targets.  */

/* Characters which always start a comment.  */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = ";#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";

const relax_typeS md_relax_table[] =
{
  /* The plus values for the bCC and fBCC instructions in the table below
     are because the branch instruction is translated into a jump
     instruction that is now +2 or +3 bytes further on in memory, and the
     correct size of jump instruction must be selected.  */
  /* bCC relaxing.  */
  {0x7f, -0x80, 2, 1},
  {0x7fff + 2, -0x8000 + 2, 5, 2},
  {0x7fffffff, -0x80000000, 7, 0},

  /* bCC relaxing (uncommon cases for 3byte length instructions)  */
  {0x7f, -0x80, 3, 4},
  {0x7fff + 3, -0x8000 + 3, 6, 5},
  {0x7fffffff, -0x80000000, 8, 0},

  /* call relaxing.  */
  {0x7fff, -0x8000, 5, 7},
  {0x7fffffff, -0x80000000, 7, 0},

  /* calls relaxing.  */
  {0x7fff, -0x8000, 4, 9},
  {0x7fffffff, -0x80000000, 6, 0},

  /* jmp relaxing.  */
  {0x7f, -0x80, 2, 11},
  {0x7fff, -0x8000, 3, 12},
  {0x7fffffff, -0x80000000, 5, 0},

  /* fbCC relaxing.  */
  {0x7f, -0x80, 3, 14},
  {0x7fff + 3, -0x8000 + 3, 6, 15},
  {0x7fffffff, -0x80000000, 8, 0},

};

/*  Set linkrelax here to avoid fixups in most sections.  */
int linkrelax = 1;

static int current_machine;

/* Fixups.  */
#define MAX_INSN_FIXUPS 5

struct mn10300_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};
struct mn10300_fixup fixups[MAX_INSN_FIXUPS];
static int fc;

/* We must store the value of each register operand so that we can
   verify that certain registers do not match.  */
int mn10300_reg_operands[MN10300_MAX_OPERANDS];

const char *md_shortopts = "";

struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

#define HAVE_AM33_2 (current_machine == AM33_2)
#define HAVE_AM33   (current_machine == AM33 || HAVE_AM33_2)
#define HAVE_AM30   (current_machine == AM30)

/* Opcode hash table.  */
static struct hash_control *mn10300_hash;

/* This table is sorted. Suitable for searching by a binary search.  */
static const struct reg_name data_registers[] =
{
  { "d0", 0 },
  { "d1", 1 },
  { "d2", 2 },
  { "d3", 3 },
};

static const struct reg_name address_registers[] =
{
  { "a0", 0 },
  { "a1", 1 },
  { "a2", 2 },
  { "a3", 3 },
};

static const struct reg_name r_registers[] =
{
  { "a0", 8 },
  { "a1", 9 },
  { "a2", 10 },
  { "a3", 11 },
  { "d0", 12 },
  { "d1", 13 },
  { "d2", 14 },
  { "d3", 15 },
  { "e0", 0 },
  { "e1", 1 },
  { "e10", 10 },
  { "e11", 11 },
  { "e12", 12 },
  { "e13", 13 },
  { "e14", 14 },
  { "e15", 15 },
  { "e2", 2 },
  { "e3", 3 },
  { "e4", 4 },
  { "e5", 5 },
  { "e6", 6 },
  { "e7", 7 },
  { "e8", 8 },
  { "e9", 9 },
  { "r0", 0 },
  { "r1", 1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r2", 2 },
  { "r3", 3 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },
};

static const struct reg_name xr_registers[] =
{
  { "mcrh", 2 },
  { "mcrl", 3 },
  { "mcvf", 4 },
  { "mdrq", 1 },
  { "sp", 0 },
  { "xr0", 0 },
  { "xr1", 1 },
  { "xr10", 10 },
  { "xr11", 11 },
  { "xr12", 12 },
  { "xr13", 13 },
  { "xr14", 14 },
  { "xr15", 15 },
  { "xr2", 2 },
  { "xr3", 3 },
  { "xr4", 4 },
  { "xr5", 5 },
  { "xr6", 6 },
  { "xr7", 7 },
  { "xr8", 8 },
  { "xr9", 9 },
};

static const struct reg_name float_registers[] =
{
  { "fs0", 0 },
  { "fs1", 1 },
  { "fs10", 10 },
  { "fs11", 11 },
  { "fs12", 12 },
  { "fs13", 13 },
  { "fs14", 14 },
  { "fs15", 15 },
  { "fs16", 16 },
  { "fs17", 17 },
  { "fs18", 18 },
  { "fs19", 19 },
  { "fs2",   2 },
  { "fs20", 20 },
  { "fs21", 21 },
  { "fs22", 22 },
  { "fs23", 23 },
  { "fs24", 24 },
  { "fs25", 25 },
  { "fs26", 26 },
  { "fs27", 27 },
  { "fs28", 28 },
  { "fs29", 29 },
  { "fs3",   3 },
  { "fs30", 30 },
  { "fs31", 31 },
  { "fs4",   4 },
  { "fs5",   5 },
  { "fs6",   6 },
  { "fs7",   7 },
  { "fs8",   8 },
  { "fs9",   9 },
};

static const struct reg_name double_registers[] =
{
  { "fd0",   0 },
  { "fd10", 10 },
  { "fd12", 12 },
  { "fd14", 14 },
  { "fd16", 16 },
  { "fd18", 18 },
  { "fd2",   2 },
  { "fd20", 20 },
  { "fd22", 22 },
  { "fd24", 24 },
  { "fd26", 26 },
  { "fd28", 28 },
  { "fd30", 30 },
  { "fd4",   4 },
  { "fd6",   6 },
  { "fd8",   8 },
};

/* We abuse the `value' field, that would be otherwise unused, to
   encode the architecture on which (access to) the register was
   introduced.  FIXME: we should probably warn when we encounter a
   register name when assembling for an architecture that doesn't
   support it, before parsing it as a symbol name.  */
static const struct reg_name other_registers[] =
{
  { "epsw", AM33 },
  { "mdr", 0 },
  { "pc", AM33 },
  { "psw", 0 },
  { "sp", 0 },
  { "ssp", 0 },
  { "usp", 0 },
};

#define OTHER_REG_NAME_CNT	ARRAY_SIZE (other_registers)

/* Perform a binary search of the given register table REGS to see
   if NAME is a valid regiter name.  Returns the register number from
   the array on success, or -1 on failure.  */

static int
reg_name_search (const struct reg_name *regs,
		 int regcount,
		 const char *name)
{
  int low, high;

  low = 0;
  high = regcount - 1;

  do
    {
      int cmp, middle;

      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return regs[middle].value;
    }
  while (low <= high);

  return -1;
}

/* Looks at the current position in the input line to see if it is
   the name of a register in TABLE.  If it is, then the name is
   converted into an expression returned in EXPRESSIONP (with X_op
   set to O_register and X_add_number set to the register number), the
   input pointer is left pointing at the first non-blank character after
   the name and the function returns TRUE.  Otherwise the input pointer
   is left alone and the function returns FALSE.  */

static bfd_boolean
get_register_name (expressionS *           expressionP,
		   const struct reg_name * table,
		   size_t                  table_length)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (table, table_length, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

static bfd_boolean
r_register_name (expressionS *expressionP)
{
  return get_register_name (expressionP, r_registers, ARRAY_SIZE (r_registers));
}


static bfd_boolean
xr_register_name (expressionS *expressionP)
{
  return get_register_name (expressionP, xr_registers, ARRAY_SIZE (xr_registers));
}

static bfd_boolean
data_register_name (expressionS *expressionP)
{
  return get_register_name (expressionP, data_registers, ARRAY_SIZE (data_registers));
}

static bfd_boolean
address_register_name (expressionS *expressionP)
{
  return get_register_name (expressionP, address_registers, ARRAY_SIZE (address_registers));
}

static bfd_boolean
float_register_name (expressionS *expressionP)
{
  return get_register_name (expressionP, float_registers, ARRAY_SIZE (float_registers));
}

static bfd_boolean
double_register_name (expressionS *expressionP)
{
  return get_register_name (expressionP, double_registers, ARRAY_SIZE (double_registers));
}

static bfd_boolean
other_register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (other_registers, ARRAY_SIZE (other_registers), name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number == 0
      || (reg_number == AM33 && HAVE_AM33))
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = 0;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("MN10300 assembler options:\n\
none yet\n"));
}

int
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
{
  return 0;
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

char *
md_atof (int type, char *litp, int *sizep)
{
  return ieee_md_atof (type, litp, sizep, FALSE);
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec,
		 fragS *fragP)
{
  static unsigned long label_count = 0;
  char buf[40];

  subseg_change (sec, 0);
  if (fragP->fr_subtype == 0)
    {
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  else if (fragP->fr_subtype == 1)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset] & 0xff;

      switch (opcode)
	{
	case 0xc8:
	  opcode = 0xc9;
	  break;
	case 0xc9:
	  opcode = 0xc8;
	  break;
	case 0xc0:
	  opcode = 0xc2;
	  break;
	case 0xc2:
	  opcode = 0xc0;
	  break;
	case 0xc3:
	  opcode = 0xc1;
	  break;
	case 0xc1:
	  opcode = 0xc3;
	  break;
	case 0xc4:
	  opcode = 0xc6;
	  break;
	case 0xc6:
	  opcode = 0xc4;
	  break;
	case 0xc7:
	  opcode = 0xc5;
	  break;
	case 0xc5:
	  opcode = 0xc7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 1, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 1, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 2] = 0xcc;
      fix_new (fragP, fragP->fr_fix + 3, 2, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 2)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset] & 0xff;

      switch (opcode)
	{
	case 0xc8:
	  opcode = 0xc9;
	  break;
	case 0xc9:
	  opcode = 0xc8;
	  break;
	case 0xc0:
	  opcode = 0xc2;
	  break;
	case 0xc2:
	  opcode = 0xc0;
	  break;
	case 0xc3:
	  opcode = 0xc1;
	  break;
	case 0xc1:
	  opcode = 0xc3;
	  break;
	case 0xc4:
	  opcode = 0xc6;
	  break;
	case 0xc6:
	  opcode = 0xc4;
	  break;
	case 0xc7:
	  opcode = 0xc5;
	  break;
	case 0xc5:
	  opcode = 0xc7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 1, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 1, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 2] = 0xdc;
      fix_new (fragP, fragP->fr_fix + 3, 4, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_32_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 7;
    }
  else if (fragP->fr_subtype == 3)
    {
      fix_new (fragP, fragP->fr_fix + 2, 1, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 4)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xea:
	  opcode = 0xeb;
	  break;
	case 0xeb:
	  opcode = 0xea;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xcc;
      fix_new (fragP, fragP->fr_fix + 4, 2, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 6;
    }
  else if (fragP->fr_subtype == 5)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xea:
	  opcode = 0xeb;
	  break;
	case 0xeb:
	  opcode = 0xea;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xdc;
      fix_new (fragP, fragP->fr_fix + 4, 4, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_32_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 8;
    }
  else if (fragP->fr_subtype == 6)
    {
      int offset = fragP->fr_fix;

      fragP->fr_literal[offset] = 0xcd;
      fix_new (fragP, fragP->fr_fix + 1, 2, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 7)
    {
      int offset = fragP->fr_fix;

      fragP->fr_literal[offset] = 0xdd;
      fragP->fr_literal[offset + 5] = fragP->fr_literal[offset + 3];
      fragP->fr_literal[offset + 6] = fragP->fr_literal[offset + 4];
      fragP->fr_literal[offset + 3] = 0;
      fragP->fr_literal[offset + 4] = 0;

      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_32_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 7;
    }
  else if (fragP->fr_subtype == 8)
    {
      int offset = fragP->fr_fix;

      fragP->fr_literal[offset] = 0xfa;
      fragP->fr_literal[offset + 1] = 0xff;
      fix_new (fragP, fragP->fr_fix + 2, 2, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 4;
    }
  else if (fragP->fr_subtype == 9)
    {
      int offset = fragP->fr_fix;

      fragP->fr_literal[offset] = 0xfc;
      fragP->fr_literal[offset + 1] = 0xff;

      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_32_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 6;
    }
  else if (fragP->fr_subtype == 10)
    {
      fragP->fr_literal[fragP->fr_fix] = 0xca;
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  else if (fragP->fr_subtype == 11)
    {
      int offset = fragP->fr_fix;

      fragP->fr_literal[offset] = 0xcc;

      fix_new (fragP, fragP->fr_fix + 1, 2, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 12)
    {
      int offset = fragP->fr_fix;

      fragP->fr_literal[offset] = 0xdc;

      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_32_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 13)
    {
      fix_new (fragP, fragP->fr_fix + 2, 1, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 14)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xd0:
	  opcode = 0xd1;
	  break;
	case 0xd1:
	  opcode = 0xd0;
	  break;
	case 0xd2:
	  opcode = 0xdc;
	  break;
	case 0xd3:
	  opcode = 0xdb;
	  break;
	case 0xd4:
	  opcode = 0xda;
	  break;
	case 0xd5:
	  opcode = 0xd9;
	  break;
	case 0xd6:
	  opcode = 0xd8;
	  break;
	case 0xd7:
	  opcode = 0xdd;
	  break;
	case 0xd8:
	  opcode = 0xd6;
	  break;
	case 0xd9:
	  opcode = 0xd5;
	  break;
	case 0xda:
	  opcode = 0xd4;
	  break;
	case 0xdb:
	  opcode = 0xd3;
	  break;
	case 0xdc:
	  opcode = 0xd2;
	  break;
	case 0xdd:
	  opcode = 0xd7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xcc;
      fix_new (fragP, fragP->fr_fix + 4, 2, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 6;
    }
  else if (fragP->fr_subtype == 15)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xd0:
	  opcode = 0xd1;
	  break;
	case 0xd1:
	  opcode = 0xd0;
	  break;
	case 0xd2:
	  opcode = 0xdc;
	  break;
	case 0xd3:
	  opcode = 0xdb;
	  break;
	case 0xd4:
	  opcode = 0xda;
	  break;
	case 0xd5:
	  opcode = 0xd9;
	  break;
	case 0xd6:
	  opcode = 0xd8;
	  break;
	case 0xd7:
	  opcode = 0xdd;
	  break;
	case 0xd8:
	  opcode = 0xd6;
	  break;
	case 0xd9:
	  opcode = 0xd5;
	  break;
	case 0xda:
	  opcode = 0xd4;
	  break;
	case 0xdb:
	  opcode = 0xd3;
	  break;
	case 0xdc:
	  opcode = 0xd2;
	  break;
	case 0xdd:
	  opcode = 0xd7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xdc;
      fix_new (fragP, fragP->fr_fix + 4, 4, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_32_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 8;
    }
  else
    abort ();
}

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);

  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin (void)
{
  char *prev_name = "";
  const struct mn10300_opcode *op;

  mn10300_hash = hash_new ();

  /* Insert unique names into hash table.  The MN10300 instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */

  op = mn10300_opcodes;
  while (op->name)
    {
      if (strcmp (prev_name, op->name))
	{
	  prev_name = (char *) op->name;
	  hash_insert (mn10300_hash, op->name, (char *) op);
	}
      op++;
    }

  /* Set the default machine type.  */
#ifdef TE_LINUX
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_mn10300, AM33_2))
    as_warn (_("could not set architecture and machine"));

  current_machine = AM33_2;
#else  
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_mn10300, MN103))
    as_warn (_("could not set architecture and machine"));

  current_machine = MN103;
#endif
}

static symbolS *GOT_symbol;

static inline int
mn10300_PIC_related_p (symbolS *sym)
{
  expressionS *exp;

  if (! sym)
    return 0;

  if (sym == GOT_symbol)
    return 1;

  exp = symbol_get_value_expression (sym);

  return (exp->X_op == O_PIC_reloc
	  || mn10300_PIC_related_p (exp->X_add_symbol)
	  || mn10300_PIC_related_p (exp->X_op_symbol));
}

static inline int
mn10300_check_fixup (struct mn10300_fixup *fixup)
{
  expressionS *exp = &fixup->exp;

 repeat:
  switch (exp->X_op)
    {
    case O_add:
    case O_subtract: /* If we're sufficiently unlucky that the label
			and the expression that references it happen
			to end up in different frags, the subtract
			won't be simplified within expression().  */
      /* The PIC-related operand must be the first operand of a sum.  */
      if (exp != &fixup->exp || mn10300_PIC_related_p (exp->X_op_symbol))
	return 1;

      if (exp->X_add_symbol && exp->X_add_symbol == GOT_symbol)
	fixup->reloc = BFD_RELOC_32_GOT_PCREL;

      exp = symbol_get_value_expression (exp->X_add_symbol);
      goto repeat;

    case O_symbol:
      if (exp->X_add_symbol && exp->X_add_symbol == GOT_symbol)
	fixup->reloc = BFD_RELOC_32_GOT_PCREL;
      break;

    case O_PIC_reloc:
      fixup->reloc = exp->X_md;
      exp->X_op = O_symbol;
      if (fixup->reloc == BFD_RELOC_32_PLT_PCREL
	  && fixup->opindex >= 0
	  && (mn10300_operands[fixup->opindex].flags
	      & MN10300_OPERAND_RELAX))
	return 1;
      break;

    default:
      return (mn10300_PIC_related_p (exp->X_add_symbol)
	      || mn10300_PIC_related_p (exp->X_op_symbol));
    }

  return 0;
}

void
mn10300_cons_fix_new (fragS *frag, int off, int size, expressionS *exp)
{
  struct mn10300_fixup fixup;

  fixup.opindex = -1;
  fixup.exp = *exp;
  fixup.reloc = BFD_RELOC_UNUSED;

  mn10300_check_fixup (&fixup);

  if (fixup.reloc == BFD_RELOC_MN10300_GOT32)
    switch (size)
      {
      case 2:
	fixup.reloc = BFD_RELOC_MN10300_GOT16;
	break;

      case 3:
	fixup.reloc = BFD_RELOC_MN10300_GOT24;
	break;

      case 4:
	break;

      default:
	goto error;
      }
  else if (fixup.reloc == BFD_RELOC_UNUSED)
    switch (size)
      {
      case 1:
	fixup.reloc = BFD_RELOC_8;
	break;

      case 2:
	fixup.reloc = BFD_RELOC_16;
	break;

      case 3:
	fixup.reloc = BFD_RELOC_24;
	break;

      case 4:
	fixup.reloc = BFD_RELOC_32;
	break;

      default:
	goto error;
      }
  else if (size != 4)
    {
    error:
      as_bad (_("unsupported BFD relocation size %u"), size);
      fixup.reloc = BFD_RELOC_UNUSED;
    }
    
  fix_new_exp (frag, off, size, &fixup.exp, 0, fixup.reloc);
}

static bfd_boolean
check_operand (const struct mn10300_operand *operand,
	       offsetT val)
{
  /* No need to check 32bit operands for a bit.  Note that
     MN10300_OPERAND_SPLIT is an implicit 32bit operand.  */
  if (operand->bits != 32
      && (operand->flags & MN10300_OPERAND_SPLIT) == 0)
    {
      long min, max;
      offsetT test;
      int bits;

      bits = operand->bits;
      if (operand->flags & MN10300_OPERAND_24BIT)
	bits = 24;

      if ((operand->flags & MN10300_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (bits - 1)) - 1;
	  min = - (1 << (bits - 1));
	}
      else
	{
	  max = (1 << bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	return FALSE;
    }
  return TRUE;
}

/* Insert an operand value into an instruction.  */

static void
mn10300_insert_operand (unsigned long *insnp,
			unsigned long *extensionp,
			const struct mn10300_operand *operand,
			offsetT val,
			char *file,
			unsigned int line,
			unsigned int shift)
{
  /* No need to check 32bit operands for a bit.  Note that
     MN10300_OPERAND_SPLIT is an implicit 32bit operand.  */
  if (operand->bits != 32
      && (operand->flags & MN10300_OPERAND_SPLIT) == 0)
    {
      long min, max;
      offsetT test;
      int bits;

      bits = operand->bits;
      if (operand->flags & MN10300_OPERAND_24BIT)
	bits = 24;

      if ((operand->flags & MN10300_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (bits - 1)) - 1;
	  min = - (1 << (bits - 1));
	}
      else
	{
	  max = (1 << bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	as_warn_value_out_of_range (_("operand"), test, (offsetT) min, (offsetT) max, file, line);
    }

  if ((operand->flags & MN10300_OPERAND_SPLIT) != 0)
    {
      *insnp |= (val >> (32 - operand->bits)) & ((1 << operand->bits) - 1);
      *extensionp |= ((val & ((1 << (32 - operand->bits)) - 1))
		      << operand->shift);
    }
  else if ((operand->flags & MN10300_OPERAND_24BIT) != 0)
    {
      *insnp |= (val >> (24 - operand->bits)) & ((1 << operand->bits) - 1);
      *extensionp |= ((val & ((1 << (24 - operand->bits)) - 1))
		      << operand->shift);
    }
  else if ((operand->flags & (MN10300_OPERAND_FSREG | MN10300_OPERAND_FDREG)))
    {
      /* See devo/opcodes/m10300-opc.c just before #define FSM0 for an
         explanation of these variables.  Note that FMT-implied shifts
        are not taken into account for FP registers.  */
      unsigned long mask_low, mask_high;
      int shl_low, shr_high, shl_high;

      switch (operand->bits)
	{
	case 5:
	  /* Handle regular FP registers.  */
	  if (operand->shift >= 0)
	    {
	      /* This is an `m' register.  */
	      shl_low = operand->shift;
	      shl_high = 8 + (8 & shl_low) + (shl_low & 4) / 4;
	    }
	  else
	    {
	      /* This is an `n' register.  */
	      shl_low = -operand->shift;
	      shl_high = shl_low / 4;
	    }

	  mask_low = 0x0f;
	  mask_high = 0x10;
	  shr_high = 4;
	  break;

	case 3:
	  /* Handle accumulators.  */
	  shl_low = -operand->shift;
	  shl_high = 0;
	  mask_low = 0x03;
	  mask_high = 0x04;
	  shr_high = 2;
	  break;

	default:
	  abort ();
	}
      *insnp |= ((((val & mask_high) >> shr_high) << shl_high)
		 | ((val & mask_low) << shl_low));
    }
  else if ((operand->flags & MN10300_OPERAND_EXTENDED) == 0)
    {
      *insnp |= (((long) val & ((1 << operand->bits) - 1))
		 << (operand->shift + shift));

      if ((operand->flags & MN10300_OPERAND_REPEATED) != 0)
	*insnp |= (((long) val & ((1 << operand->bits) - 1))
		   << (operand->shift + shift + operand->bits));
    }
  else
    {
      *extensionp |= (((long) val & ((1 << operand->bits) - 1))
		      << (operand->shift + shift));

      if ((operand->flags & MN10300_OPERAND_REPEATED) != 0)
	*extensionp |= (((long) val & ((1 << operand->bits) - 1))
			<< (operand->shift + shift + operand->bits));
    }
}

void
md_assemble (char *str)
{
  char *s;
  struct mn10300_opcode *opcode;
  struct mn10300_opcode *next_opcode;
  const unsigned char *opindex_ptr;
  int next_opindex, relaxable;
  unsigned long insn, extension, size = 0;
  char *f;
  int i;
  int match;

  /* Get the opcode.  */
  for (s = str; *s != '\0' && !ISSPACE (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* Find the first opcode with the proper name.  */
  opcode = (struct mn10300_opcode *) hash_find (mn10300_hash, str);
  if (opcode == NULL)
    {
      as_bad (_("Unrecognized opcode: `%s'"), str);
      return;
    }

  str = s;
  while (ISSPACE (*str))
    ++str;

  input_line_pointer = str;

  for (;;)
    {
      const char *errmsg;
      int op_idx;
      char *hold;
      int extra_shift = 0;

      errmsg = _("Invalid opcode/operands");

      /* Reset the array of register operands.  */
      memset (mn10300_reg_operands, -1, sizeof (mn10300_reg_operands));

      relaxable = 0;
      fc = 0;
      match = 0;
      next_opindex = 0;
      insn = opcode->opcode;
      extension = 0;

      /* If the instruction is not available on the current machine
	 then it can not possibly match.  */
      if (opcode->machine
	  && !(opcode->machine == AM33_2 && HAVE_AM33_2)
	  && !(opcode->machine == AM33 && HAVE_AM33)
	  && !(opcode->machine == AM30 && HAVE_AM30))
	goto error;

      for (op_idx = 1, opindex_ptr = opcode->operands;
	   *opindex_ptr != 0;
	   opindex_ptr++, op_idx++)
	{
	  const struct mn10300_operand *operand;
	  expressionS ex;

	  if (next_opindex == 0)
	    {
	      operand = &mn10300_operands[*opindex_ptr];
	    }
	  else
	    {
	      operand = &mn10300_operands[next_opindex];
	      next_opindex = 0;
	    }

	  while (*str == ' ' || *str == ',')
	    ++str;

	  if (operand->flags & MN10300_OPERAND_RELAX)
	    relaxable = 1;

	  /* Gather the operand.  */
	  hold = input_line_pointer;
	  input_line_pointer = str;

	  if (operand->flags & MN10300_OPERAND_PAREN)
	    {
	      if (*input_line_pointer != ')' && *input_line_pointer != '(')
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      input_line_pointer++;
	      goto keep_going;
	    }
	  /* See if we can match the operands.  */
	  else if (operand->flags & MN10300_OPERAND_DREG)
	    {
	      if (!data_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10300_OPERAND_AREG)
	    {
	      if (!address_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10300_OPERAND_SP)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "sp") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_RREG)
	    {
	      if (!r_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10300_OPERAND_XRREG)
	    {
	      if (!xr_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10300_OPERAND_FSREG)
	    {
	      if (!float_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10300_OPERAND_FDREG)
	    {
	      if (!double_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10300_OPERAND_FPCR)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "fpcr") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_USP)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "usp") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_SSP)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "ssp") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_MSP)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "msp") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_PC)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "pc") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_EPSW)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "epsw") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_PLUS)
	    {
	      if (*input_line_pointer != '+')
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      input_line_pointer++;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_PSW)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "psw") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_MDR)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcasecmp (start, "mdr") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10300_OPERAND_REG_LIST)
	    {
	      unsigned int value = 0;
	      if (*input_line_pointer != '[')
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      /* Eat the '['.  */
	      input_line_pointer++;

	      /* We used to reject a null register list here; however,
		 we accept it now so the compiler can emit "call"
		 instructions for all calls to named functions.

		 The linker can then fill in the appropriate bits for the
		 register list and stack size or change the instruction
		 into a "calls" if using "call" is not profitable.  */
	      while (*input_line_pointer != ']')
		{
		  char *start;
		  char c;

		  if (*input_line_pointer == ',')
		    input_line_pointer++;

		  start = input_line_pointer;
		  c = get_symbol_end ();

		  if (strcasecmp (start, "d2") == 0)
		    {
		      value |= 0x80;
		      *input_line_pointer = c;
		    }
		  else if (strcasecmp (start, "d3") == 0)
		    {
		      value |= 0x40;
		      *input_line_pointer = c;
		    }
		  else if (strcasecmp (start, "a2") == 0)
		    {
		      value |= 0x20;
		      *input_line_pointer = c;
		    }
		  else if (strcasecmp (start, "a3") == 0)
		    {
		      value |= 0x10;
		      *input_line_pointer = c;
		    }
		  else if (strcasecmp (start, "other") == 0)
		    {
		      value |= 0x08;
		      *input_line_pointer = c;
		    }
		  else if (HAVE_AM33
			   && strcasecmp (start, "exreg0") == 0)
		    {
		      value |= 0x04;
		      *input_line_pointer = c;
		    }
		  else if (HAVE_AM33
			   && strcasecmp (start, "exreg1") == 0)
		    {
		      value |= 0x02;
		      *input_line_pointer = c;
		    }
		  else if (HAVE_AM33
			   && strcasecmp (start, "exother") == 0)
		    {
		      value |= 0x01;
		      *input_line_pointer = c;
		    }
		  else if (HAVE_AM33
			   && strcasecmp (start, "all") == 0)
		    {
		      value |= 0xff;
		      *input_line_pointer = c;
		    }
		  else
		    {
		      input_line_pointer = hold;
		      str = hold;
		      goto error;
		    }
		}
	      input_line_pointer++;
              mn10300_insert_operand (& insn, & extension, operand,
                                      value, NULL, 0, 0);
	      goto keep_going;

	    }
	  else if (data_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (address_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (other_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (HAVE_AM33 && r_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (HAVE_AM33 && xr_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (HAVE_AM33_2 && float_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (HAVE_AM33_2 && double_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (*str == ')' || *str == '(')
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else
	    {
	      expression (&ex);
	    }

	  switch (ex.X_op)
	    {
	    case O_illegal:
	      errmsg = _("illegal operand");
	      goto error;
	    case O_absent:
	      errmsg = _("missing operand");
	      goto error;
	    case O_register:
	      {
		int mask;

		mask = MN10300_OPERAND_DREG | MN10300_OPERAND_AREG;
		if (HAVE_AM33)
		  mask |= MN10300_OPERAND_RREG | MN10300_OPERAND_XRREG;
		if (HAVE_AM33_2)
		  mask |= MN10300_OPERAND_FSREG | MN10300_OPERAND_FDREG;
		if ((operand->flags & mask) == 0)
		  {
		    input_line_pointer = hold;
		    str = hold;
		    goto error;
		  }

		if (opcode->format == FMT_D1 || opcode->format == FMT_S1)
		  extra_shift = 8;
		else if (opcode->format == FMT_D2
			 || opcode->format == FMT_D4
			 || opcode->format == FMT_S2
			 || opcode->format == FMT_S4
			 || opcode->format == FMT_S6
			 || opcode->format == FMT_D5)
		  extra_shift = 16;
		else if (opcode->format == FMT_D7)
		  extra_shift = 8;
		else if (opcode->format == FMT_D8 || opcode->format == FMT_D9)
		  extra_shift = 8;
		else
		  extra_shift = 0;

		mn10300_insert_operand (& insn, & extension, operand,
					ex.X_add_number, NULL,
					0, extra_shift);

		/* And note the register number in the register array.  */
		mn10300_reg_operands[op_idx - 1] = ex.X_add_number;
		break;
	      }

	    case O_constant:
	      /* If this operand can be promoted, and it doesn't
		 fit into the allocated bitfield for this insn,
		 then promote it (ie this opcode does not match).  */
	      if (operand->flags
		  & (MN10300_OPERAND_PROMOTE | MN10300_OPERAND_RELAX)
		  && !check_operand (operand, ex.X_add_number))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      mn10300_insert_operand (& insn, & extension, operand,
				      ex.X_add_number, NULL, 0, 0);
	      break;

	    default:
	      /* If this operand can be promoted, then this opcode didn't
		 match since we can't know if it needed promotion!  */
	      if (operand->flags & MN10300_OPERAND_PROMOTE)
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      /* We need to generate a fixup for this expression.  */
	      if (fc >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));
	      fixups[fc].exp = ex;
	      fixups[fc].opindex = *opindex_ptr;
	      fixups[fc].reloc = BFD_RELOC_UNUSED;
	      if (mn10300_check_fixup (& fixups[fc]))
		goto error;
	      ++fc;
	      break;
	    }

keep_going:
	  str = input_line_pointer;
	  input_line_pointer = hold;

	  while (*str == ' ' || *str == ',')
	    ++str;
	}

      /* Make sure we used all the operands!  */
      if (*str != ',')
	match = 1;

      /* If this instruction has registers that must not match, verify
	 that they do indeed not match.  */
      if (opcode->no_match_operands)
	{
	  /* Look at each operand to see if it's marked.  */
	  for (i = 0; i < MN10300_MAX_OPERANDS; i++)
	    {
	      if ((1 << i) & opcode->no_match_operands)
		{
		  int j;

		  /* operand I is marked.  Check that it does not match any
		     operands > I which are marked.  */
		  for (j = i + 1; j < MN10300_MAX_OPERANDS; j++)
		    {
		      if (((1 << j) & opcode->no_match_operands)
			  && mn10300_reg_operands[i] == mn10300_reg_operands[j])
			{
			  errmsg = _("Invalid register specification.");
			  match = 0;
			  goto error;
			}
		    }
		}
	    }
	}

    error:
      if (match == 0)
	{
	  next_opcode = opcode + 1;
	  if (!strcmp (next_opcode->name, opcode->name))
	    {
	      opcode = next_opcode;
	      continue;
	    }

	  as_bad ("%s", errmsg);
	  return;
	}
      break;
    }

  while (ISSPACE (*str))
    ++str;

  if (*str != '\0')
    as_bad (_("junk at end of line: `%s'"), str);

  input_line_pointer = str;

  /* Determine the size of the instruction.  */
  if (opcode->format == FMT_S0)
    size = 1;

  if (opcode->format == FMT_S1 || opcode->format == FMT_D0)
    size = 2;

  if (opcode->format == FMT_S2 || opcode->format == FMT_D1)
    size = 3;

  if (opcode->format == FMT_D6)
    size = 3;

  if (opcode->format == FMT_D7 || opcode->format == FMT_D10)
    size = 4;

  if (opcode->format == FMT_D8)
    size = 6;

  if (opcode->format == FMT_D9)
    size = 7;

  if (opcode->format == FMT_S4)
    size = 5;

  if (opcode->format == FMT_S6 || opcode->format == FMT_D5)
    size = 7;

  if (opcode->format == FMT_D2)
    size = 4;

  if (opcode->format == FMT_D3)
    size = 5;

  if (opcode->format == FMT_D4)
    size = 6;

  if (relaxable && fc > 0)
    {
      /* On a 64-bit host the size of an 'int' is not the same
	 as the size of a pointer, so we need a union to convert
	 the opindex field of the fr_cgen structure into a char *
	 so that it can be stored in the frag.  We do not have
	 to worry about loosing accuracy as we are not going to
	 be even close to the 32bit limit of the int.  */
      union
      {
	int opindex;
	char * ptr;
      }
      opindex_converter;
      int type;

      /* We want to anchor the line info to the previous frag (if
	 there isn't one, create it), so that, when the insn is
	 resized, we still get the right address for the beginning of
	 the region.  */
      f = frag_more (0);
      dwarf2_emit_insn (0);

      /* bCC  */
      if (size == 2)
	{
	  /* Handle bra specially.  Basically treat it like jmp so
	     that we automatically handle 8, 16 and 32 bit offsets
	     correctly as well as jumps to an undefined address.

	     It is also important to not treat it like other bCC
	     instructions since the long forms of bra is different
	     from other bCC instructions.  */
	  if (opcode->opcode == 0xca00)
	    type = 10;
	  else
	    type = 0;
	}
      /* call  */
      else if (size == 5)
	type = 6;
      /* calls  */
      else if (size == 4)
	type = 8;
      /* jmp  */
      else if (size == 3 && opcode->opcode == 0xcc0000)
	type = 10;
      else if (size == 3 && (opcode->opcode & 0xfff000) == 0xf8d000)
	type = 13;
      /* bCC (uncommon cases)  */
      else
	type = 3;

      opindex_converter.opindex = fixups[0].opindex;
      f = frag_var (rs_machine_dependent, 8, 8 - size, type,
		    fixups[0].exp.X_add_symbol,
		    fixups[0].exp.X_add_number,
		    opindex_converter.ptr);

      /* This is pretty hokey.  We basically just care about the
	 opcode, so we have to write out the first word big endian.

	 The exception is "call", which has two operands that we
	 care about.

	 The first operand (the register list) happens to be in the
	 first instruction word, and will be in the right place if
	 we output the first word in big endian mode.

	 The second operand (stack size) is in the extension word,
	 and we want it to appear as the first character in the extension
	 word (as it appears in memory).  Luckily, writing the extension
	 word in big endian format will do what we want.  */
      number_to_chars_bigendian (f, insn, size > 4 ? 4 : size);
      if (size > 8)
	{
	  number_to_chars_bigendian (f + 4, extension, 4);
	  number_to_chars_bigendian (f + 8, 0, size - 8);
	}
      else if (size > 4)
	number_to_chars_bigendian (f + 4, extension, size - 4);
    }
  else
    {
      /* Allocate space for the instruction.  */
      f = frag_more (size);

      /* Fill in bytes for the instruction.  Note that opcode fields
	 are written big-endian, 16 & 32bit immediates are written
	 little endian.  Egad.  */
      if (opcode->format == FMT_S0
	  || opcode->format == FMT_S1
	  || opcode->format == FMT_D0
	  || opcode->format == FMT_D6
	  || opcode->format == FMT_D7
	  || opcode->format == FMT_D10
	  || opcode->format == FMT_D1)
	{
	  number_to_chars_bigendian (f, insn, size);
	}
      else if (opcode->format == FMT_S2
	       && opcode->opcode != 0xdf0000
	       && opcode->opcode != 0xde0000)
	{
	  /* A format S2 instruction that is _not_ "ret" and "retf".  */
	  number_to_chars_bigendian (f, (insn >> 16) & 0xff, 1);
	  number_to_chars_littleendian (f + 1, insn & 0xffff, 2);
	}
      else if (opcode->format == FMT_S2)
	{
	  /* This must be a ret or retf, which is written entirely in
	     big-endian format.  */
	  number_to_chars_bigendian (f, insn, 3);
	}
      else if (opcode->format == FMT_S4
	       && opcode->opcode != 0xdc000000)
	{
	  /* This must be a format S4 "call" instruction.  What a pain.  */
	  unsigned long temp = (insn >> 8) & 0xffff;
	  number_to_chars_bigendian (f, (insn >> 24) & 0xff, 1);
	  number_to_chars_littleendian (f + 1, temp, 2);
	  number_to_chars_bigendian (f + 3, insn & 0xff, 1);
	  number_to_chars_bigendian (f + 4, extension & 0xff, 1);
	}
      else if (opcode->format == FMT_S4)
	{
	  /* This must be a format S4 "jmp" instruction.  */
	  unsigned long temp = ((insn & 0xffffff) << 8) | (extension & 0xff);
	  number_to_chars_bigendian (f, (insn >> 24) & 0xff, 1);
	  number_to_chars_littleendian (f + 1, temp, 4);
	}
      else if (opcode->format == FMT_S6)
	{
	  unsigned long temp = ((insn & 0xffffff) << 8)
	    | ((extension >> 16) & 0xff);
	  number_to_chars_bigendian (f, (insn >> 24) & 0xff, 1);
	  number_to_chars_littleendian (f + 1, temp, 4);
	  number_to_chars_bigendian (f + 5, (extension >> 8) & 0xff, 1);
	  number_to_chars_bigendian (f + 6, extension & 0xff, 1);
	}
      else if (opcode->format == FMT_D2
	       && opcode->opcode != 0xfaf80000
	       && opcode->opcode != 0xfaf00000
	       && opcode->opcode != 0xfaf40000)
	{
	  /* A format D2 instruction where the 16bit immediate is
	     really a single 16bit value, not two 8bit values.  */
	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, insn & 0xffff, 2);
	}
      else if (opcode->format == FMT_D2)
	{
	  /* A format D2 instruction where the 16bit immediate
	     is really two 8bit immediates.  */
	  number_to_chars_bigendian (f, insn, 4);
	}
      else if (opcode->format == FMT_D3)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, insn & 0xffff, 2);
	  number_to_chars_bigendian (f + 4, extension & 0xff, 1);
	}
      else if (opcode->format == FMT_D4)
	{
	  unsigned long temp = ((insn & 0xffff) << 16) | (extension & 0xffff);

	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, temp, 4);
	}
      else if (opcode->format == FMT_D5)
	{
	  unsigned long temp = (((insn & 0xffff) << 16)
				| ((extension >> 8) & 0xffff));

	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, temp, 4);
	  number_to_chars_bigendian (f + 6, extension & 0xff, 1);
	}
      else if (opcode->format == FMT_D8)
	{
	  unsigned long temp = ((insn & 0xff) << 16) | (extension & 0xffff);

	  number_to_chars_bigendian (f, (insn >> 8) & 0xffffff, 3);
	  number_to_chars_bigendian (f + 3, (temp & 0xff), 1);
	  number_to_chars_littleendian (f + 4, temp >> 8, 2);
	}
      else if (opcode->format == FMT_D9)
	{
	  unsigned long temp = ((insn & 0xff) << 24) | (extension & 0xffffff);

	  number_to_chars_bigendian (f, (insn >> 8) & 0xffffff, 3);
	  number_to_chars_littleendian (f + 3, temp, 4);
	}

      /* Create any fixups.  */
      for (i = 0; i < fc; i++)
	{
	  const struct mn10300_operand *operand;
	  int reloc_size;

	  operand = &mn10300_operands[fixups[i].opindex];
	  if (fixups[i].reloc != BFD_RELOC_UNUSED
	      && fixups[i].reloc != BFD_RELOC_32_GOT_PCREL
	      && fixups[i].reloc != BFD_RELOC_32_GOTOFF
	      && fixups[i].reloc != BFD_RELOC_32_PLT_PCREL
	      && fixups[i].reloc != BFD_RELOC_MN10300_TLS_GD
	      && fixups[i].reloc != BFD_RELOC_MN10300_TLS_LD
	      && fixups[i].reloc != BFD_RELOC_MN10300_TLS_LDO
	      && fixups[i].reloc != BFD_RELOC_MN10300_TLS_GOTIE
	      && fixups[i].reloc != BFD_RELOC_MN10300_TLS_IE
	      && fixups[i].reloc != BFD_RELOC_MN10300_TLS_LE
	      && fixups[i].reloc != BFD_RELOC_MN10300_GOT32)
	    {
	      reloc_howto_type *reloc_howto;
	      int offset;

	      reloc_howto = bfd_reloc_type_lookup (stdoutput,
						   fixups[i].reloc);

	      if (!reloc_howto)
		abort ();

	      reloc_size = bfd_get_reloc_size (reloc_howto);

	      if (reloc_size < 1 || reloc_size > 4)
		abort ();

	      offset = 4 - size;
	      fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
			   reloc_size, &fixups[i].exp,
			   reloc_howto->pc_relative,
			   fixups[i].reloc);
	    }
	  else
	    {
	      int reloc, pcrel, offset;
	      fixS *fixP;

	      reloc = BFD_RELOC_NONE;
	      if (fixups[i].reloc != BFD_RELOC_UNUSED)
		reloc = fixups[i].reloc;
	      /* How big is the reloc?  Remember SPLIT relocs are
		 implicitly 32bits.  */
	      if ((operand->flags & MN10300_OPERAND_SPLIT) != 0)
		reloc_size = 32;
	      else if ((operand->flags & MN10300_OPERAND_24BIT) != 0)
		reloc_size = 24;
	      else
		reloc_size = operand->bits;

	      /* Is the reloc pc-relative?  */
	      pcrel = (operand->flags & MN10300_OPERAND_PCREL) != 0;
	      if (reloc != BFD_RELOC_NONE)
		pcrel = bfd_reloc_type_lookup (stdoutput, reloc)->pc_relative;

	      offset = size - (reloc_size + operand->shift) / 8;

	      /* Choose a proper BFD relocation type.  */
	      if (reloc != BFD_RELOC_NONE)
		;
	      else if (pcrel)
		{
		  if (reloc_size == 32)
		    reloc = BFD_RELOC_32_PCREL;
		  else if (reloc_size == 16)
		    reloc = BFD_RELOC_16_PCREL;
		  else if (reloc_size == 8)
		    reloc = BFD_RELOC_8_PCREL;
		  else
		    abort ();
		}
	      else
		{
		  if (reloc_size == 32)
		    reloc = BFD_RELOC_32;
		  else if (reloc_size == 16)
		    reloc = BFD_RELOC_16;
		  else if (reloc_size == 8)
		    reloc = BFD_RELOC_8;
		  else
		    abort ();
		}

	      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
				  reloc_size / 8, &fixups[i].exp, pcrel,
				  ((bfd_reloc_code_real_type) reloc));

	      if (pcrel)
		fixP->fx_offset += offset;
	    }
	}

      dwarf2_emit_insn (size);
    }

  /* Label this frag as one that contains instructions.  */
  frag_now->tc_frag_data = TRUE;
}

/* If while processing a fixup, a reloc really needs to be created
   then it is done here.  */

arelent **
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  static arelent * no_relocs = NULL;
  static arelent * relocs[MAX_RELOC_EXPANSION + 1];
  arelent *reloc;

  reloc = xmalloc (sizeof (arelent));

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      free (reloc);
      return & no_relocs;
    }

  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  relocs[0] = reloc;
  relocs[1] = NULL;

  if (fixp->fx_subsy
      && S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
    {
      fixp->fx_offset -= S_GET_VALUE (fixp->fx_subsy);
      fixp->fx_subsy = NULL;
    }

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      asection *asec, *ssec;

      asec = S_GET_SEGMENT (fixp->fx_addsy);
      ssec = S_GET_SEGMENT (fixp->fx_subsy);

      /* If we have a difference between two (non-absolute) symbols we must
	 generate two relocs (one for each symbol) and allow the linker to
	 resolve them - relaxation may change the distances between symbols,
	 even local symbols defined in the same section.  */
      if (ssec != absolute_section || asec != absolute_section)
	{
	  arelent * reloc2 = xmalloc (sizeof * reloc);

	  relocs[0] = reloc2;
	  relocs[1] = reloc;

	  reloc2->address = reloc->address;
	  reloc2->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_MN10300_SYM_DIFF);
	  reloc2->addend = - S_GET_VALUE (fixp->fx_subsy);
	  reloc2->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	  *reloc2->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);

	  reloc->addend = fixp->fx_offset; 
	  if (asec == absolute_section)
	    {
	      reloc->addend += S_GET_VALUE (fixp->fx_addsy);
	      reloc->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	    }
	  else
	    {
	      reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
	    }

	  fixp->fx_pcrel = 0;
	  fixp->fx_done = 1;
	  return relocs;
	}
      else
	{
	  char *fixpos = fixp->fx_where + fixp->fx_frag->fr_literal;

	  reloc->addend = (S_GET_VALUE (fixp->fx_addsy)
			   - S_GET_VALUE (fixp->fx_subsy) + fixp->fx_offset);

	  switch (fixp->fx_r_type)
	    {
	    case BFD_RELOC_8:
	      md_number_to_chars (fixpos, reloc->addend, 1);
	      break;

	    case BFD_RELOC_16:
	      md_number_to_chars (fixpos, reloc->addend, 2);
	      break;

	    case BFD_RELOC_24:
	      md_number_to_chars (fixpos, reloc->addend, 3);
	      break;

	    case BFD_RELOC_32:
	      md_number_to_chars (fixpos, reloc->addend, 4);
	      break;

	    default:
	      reloc->sym_ptr_ptr
		= (asymbol **) bfd_abs_section_ptr->symbol_ptr_ptr;
	      return relocs;
	    }

	  free (reloc);
	  return & no_relocs;
	}
    }
  else
    {
      reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->addend = fixp->fx_offset;
    }
  return relocs;
}

/* Returns true iff the symbol attached to the frag is at a known location
   in the given section, (and hence the relocation to it can be relaxed by
   the assembler).  */
static inline bfd_boolean
has_known_symbol_location (fragS * fragp, asection * sec)
{
  symbolS * sym = fragp->fr_symbol;
  
  return sym != NULL
    && S_IS_DEFINED (sym)
    && ! S_IS_WEAK (sym)
    && S_GET_SEGMENT (sym) == sec;
}

int
md_estimate_size_before_relax (fragS *fragp, asection *seg)
{
  if (fragp->fr_subtype == 6
      && ! has_known_symbol_location (fragp, seg))
    fragp->fr_subtype = 7;
  else if (fragp->fr_subtype == 8
	   && ! has_known_symbol_location (fragp, seg))
    fragp->fr_subtype = 9;
  else if (fragp->fr_subtype == 10
	   && ! has_known_symbol_location (fragp, seg))
    fragp->fr_subtype = 12;

  if (fragp->fr_subtype == 13)
    return 3;

  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
}

long
md_pcrel_from (fixS *fixp)
{
  if (fixp->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)))
    /* The symbol is undefined or weak.  Let the linker figure it out.  */
    return 0;

  return fixp->fx_frag->fr_address + fixp->fx_where;
}

void
md_apply_fix (fixS * fixP, valueT * valP, segT seg)
{
  char * fixpos = fixP->fx_where + fixP->fx_frag->fr_literal;
  int size = 0;
  int value = (int) * valP;

  gas_assert (fixP->fx_r_type < BFD_RELOC_UNUSED);

  /* This should never happen.  */
  if (seg->flags & SEC_ALLOC)
    abort ();

  /* The value we are passed in *valuep includes the symbol values.
     If we are doing this relocation the code in write.c is going to
     call bfd_install_relocation, which is also going to use the symbol
     value.  That means that if the reloc is fully resolved we want to
     use *valuep since bfd_install_relocation is not being used.

     However, if the reloc is not fully resolved we do not want to use
     *valuep, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valuep since it includes the
     result of md_pcrel_from.  */
  if (fixP->fx_addsy != NULL && ! fixP->fx_pcrel)
    value = fixP->fx_offset;

  /* If the fix is relative to a symbol which is not defined, or not
     in the same segment as the fix, we cannot resolve it here.  */
  if (fixP->fx_addsy != NULL
      && (! S_IS_DEFINED (fixP->fx_addsy)
	  || (S_GET_SEGMENT (fixP->fx_addsy) != seg)))
    {
      fixP->fx_done = 0;
      return;
    }

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_8:
    case BFD_RELOC_8_PCREL:
      size = 1;
      break;

    case BFD_RELOC_16:
    case BFD_RELOC_16_PCREL:
      size = 2;
      break;

    case BFD_RELOC_32:
    case BFD_RELOC_32_PCREL:
      size = 4;
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    case BFD_RELOC_MN10300_ALIGN:
      fixP->fx_done = 1;
      return;
      
    case BFD_RELOC_NONE:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
                   _("Bad relocation fixup type (%d)"), fixP->fx_r_type);
    }

  md_number_to_chars (fixpos, value, size);

  /* If a symbol remains, pass the fixup, as a reloc, onto the linker.  */
  if (fixP->fx_addsy == NULL)
    fixP->fx_done = 1;
}

/* Return zero if the fixup in fixp should be left alone and not
   adjusted.  */

bfd_boolean
mn10300_fix_adjustable (struct fix *fixp)
{
  if (fixp->fx_pcrel)
    {
      if (TC_FORCE_RELOCATION_LOCAL (fixp))
	return FALSE;
    }
  /* Non-relative relocs can (and must) be adjusted if they do
     not meet the criteria below, or the generic criteria.  */
  else if (TC_FORCE_RELOCATION (fixp))
    return FALSE;

  /* Do not adjust relocations involving symbols in code sections,
     because it breaks linker relaxations.  This could be fixed in the
     linker, but this fix is simpler, and it pretty much only affects
     object size a little bit.  */
  if (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_CODE)
    return FALSE;

  /* Likewise, do not adjust symbols that won't be merged, or debug
     symbols, because they too break relaxation.  We do want to adjust
     other mergable symbols, like .rodata, because code relaxations
     need section-relative symbols to properly relax them.  */
  if (! (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE))
    return FALSE;

  if (strncmp (S_GET_SEGMENT (fixp->fx_addsy)->name, ".debug", 6) == 0)
    return FALSE;

  return TRUE;
}

static void
set_arch_mach (int mach)
{
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_mn10300, mach))
    as_warn (_("could not set architecture and machine"));

  current_machine = mach;
}

static inline char *
mn10300_end_of_match (char *cont, char *what)
{
  int len = strlen (what);

  if (strncmp (cont, what, strlen (what)) == 0
      && ! is_part_of_name (cont[len]))
    return cont + len;

  return NULL;
}  

int
mn10300_parse_name (char const *name,
		    expressionS *exprP,
		    enum expr_mode mode,
		    char *nextcharP)
{
  char *next = input_line_pointer;
  char *next_end;
  int reloc_type;
  segT segment;

  exprP->X_op_symbol = NULL;

  if (strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (! GOT_symbol)
	GOT_symbol = symbol_find_or_make (name);

      exprP->X_add_symbol = GOT_symbol;
    no_suffix:
      /* If we have an absolute symbol or a reg,
	 then we know its value now.  */
      segment = S_GET_SEGMENT (exprP->X_add_symbol);
      if (mode != expr_defer && segment == absolute_section)
	{
	  exprP->X_op = O_constant;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else if (mode != expr_defer && segment == reg_section)
	{
	  exprP->X_op = O_register;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else
	{
	  exprP->X_op = O_symbol;
	  exprP->X_add_number = 0;
	}

      return 1;
    }

  exprP->X_add_symbol = symbol_find_or_make (name);
  
  if (*nextcharP != '@@')
    goto no_suffix;
  else if ((next_end = mn10300_end_of_match (next + 1, "GOTOFF")))
    reloc_type = BFD_RELOC_32_GOTOFF;
  else if ((next_end = mn10300_end_of_match (next + 1, "GOT")))
    reloc_type = BFD_RELOC_MN10300_GOT32;
  else if ((next_end = mn10300_end_of_match (next + 1, "PLT")))
    reloc_type = BFD_RELOC_32_PLT_PCREL;
  else if ((next_end = mn10300_end_of_match (next + 1, "tlsgd")))
    reloc_type = BFD_RELOC_MN10300_TLS_GD;
  else if ((next_end = mn10300_end_of_match (next + 1, "tlsldm")))
    reloc_type = BFD_RELOC_MN10300_TLS_LD;
  else if ((next_end = mn10300_end_of_match (next + 1, "dtpoff")))
    reloc_type = BFD_RELOC_MN10300_TLS_LDO;
  else if ((next_end = mn10300_end_of_match (next + 1, "gotntpoff")))
    reloc_type = BFD_RELOC_MN10300_TLS_GOTIE;
  else if ((next_end = mn10300_end_of_match (next + 1, "indntpoff")))
    reloc_type = BFD_RELOC_MN10300_TLS_IE;
  else if ((next_end = mn10300_end_of_match (next + 1, "tpoff")))
    reloc_type = BFD_RELOC_MN10300_TLS_LE;
  else
    goto no_suffix;

  *input_line_pointer = *nextcharP;
  input_line_pointer = next_end;
  *nextcharP = *input_line_pointer;
  *input_line_pointer = '\0';

  exprP->X_op = O_PIC_reloc;
  exprP->X_add_number = 0;
  exprP->X_md = reloc_type;

  return 1;
}

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "am30",	set_arch_mach,	AM30 },
  { "am33",	set_arch_mach,	AM33 },
  { "am33_2",	set_arch_mach,	AM33_2 },
  { "mn10300",	set_arch_mach,	MN103 },
  {NULL, 0, 0}
};

/* Returns FALSE if there is some mn10300 specific reason why the
   subtraction of two same-section symbols cannot be computed by
   the assembler.  */

bfd_boolean
mn10300_allow_local_subtract (expressionS * left, expressionS * right, segT section)
{
  bfd_boolean result;
  fragS * left_frag;
  fragS * right_frag;
  fragS * frag;

  /* If we are not performing linker relaxation then we have nothing
     to worry about.  */
  if (linkrelax == 0)
    return TRUE;

  /* If the symbols are not in a code section then they are OK.  */
  if ((section->flags & SEC_CODE) == 0)
    return TRUE;

  /* Otherwise we have to scan the fragments between the two symbols.
     If any instructions are found then we have to assume that linker
     relaxation may change their size and so we must delay resolving
     the subtraction until the final link.  */
  left_frag = symbol_get_frag (left->X_add_symbol);
  right_frag = symbol_get_frag (right->X_add_symbol);

  if (left_frag == right_frag)
    return ! left_frag->tc_frag_data;

  result = TRUE;
  for (frag = left_frag; frag != NULL; frag = frag->fr_next)
    {
      if (frag->tc_frag_data)
	result = FALSE;
      if (frag == right_frag)
	break;
    }

  if (frag == NULL)
    for (frag = right_frag; frag != NULL; frag = frag->fr_next)
      {
	if (frag->tc_frag_data)
	  result = FALSE;
	if (frag == left_frag)
	  break;
      }

  if (frag == NULL)
    /* The two symbols are on disjoint fragment chains
       - we cannot possibly compute their difference.  */
    return FALSE;

  return result;
}

/* When relaxing, we need to output a reloc for any .align directive
   that requests alignment to a two byte boundary or larger.  */

void
mn10300_handle_align (fragS *frag)
{
  if (linkrelax
      && (frag->fr_type == rs_align
	  || frag->fr_type == rs_align_code)
      && frag->fr_address + frag->fr_fix > 0
      && frag->fr_offset > 1
      && now_seg != bss_section
      /* Do not create relocs for the merging sections - such
	 relocs will prevent the contents from being merged.  */
      && (bfd_get_section_flags (now_seg->owner, now_seg) & SEC_MERGE) == 0)
    /* Create a new fixup to record the alignment request.  The symbol is
       irrelevent but must be present so we use the absolute section symbol.
       The offset from the symbol is used to record the power-of-two alignment
       value.  The size is set to 0 because the frag may already be aligned,
       thus causing cvt_frag_to_fill to reduce the size of the frag to zero.  */
    fix_new (frag, frag->fr_fix, 0, & abs_symbol, frag->fr_offset, FALSE,
	     BFD_RELOC_MN10300_ALIGN);
}

bfd_boolean
mn10300_force_relocation (struct fix * fixp)
{
  if (linkrelax
      && (fixp->fx_pcrel
	  || fixp->fx_r_type == BFD_RELOC_MN10300_ALIGN))
    return TRUE;

  return generic_force_reloc (fixp);
}
@


1.73
log
@	* config/tc-mn10300.c (tc_gen_reloc): Replace absolute symbols
	with the absolute section symbol.
@
text
@d284 2
d2068 6
d2512 12
@


1.72
log
@        PR gas/11973
        * config/tc-mn10300.c (md_convert_frag): Zero out top two bytes of
        long call instruction's displacement.
@
text
@a2193 2
      reloc->sym_ptr_ptr = NULL;

d2213 9
a2221 4
	    reloc->addend += S_GET_VALUE (fixp->fx_addsy);

	  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
a2257 2
	  if (reloc->sym_ptr_ptr)
	    free (reloc->sym_ptr_ptr);
@


1.71
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d692 2
@


1.70
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009 Free Software Foundation, Inc.
a2067 1
	      fixS *fixP;
d2081 4
a2084 4
	      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
				  reloc_size, &fixups[i].exp,
				  reloc_howto->pc_relative,
				  fixups[i].reloc);
@


1.69
log
@update copyright dates
@
text
@a1774 2
	  int i;

d2057 1
a2066 1
	      int size;
d2076 1
a2076 1
	      size = bfd_get_reloc_size (reloc_howto);
d2078 1
a2078 1
	      if (size < 1 || size > 4)
d2083 1
a2083 1
				  size, &fixups[i].exp,
d2089 1
a2089 1
	      int reloc, pcrel, reloc_size, offset;
@


1.68
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
@


1.67
log
@        * config/tc-mn10300.c (has_known_symbol_location): New function.
        Do not regard weak symbols as having a known location.
        (md_estimate_size_before_relax): Use new function.
        (md_pcrel_from): Do not compute a pcrel against a weak symbol.
@
text
@d2325 1
a2325 1
  assert (fixP->fx_r_type < BFD_RELOC_UNUSED);
@


1.66
log
@* config/tc-mn10300.c (mn10300_force_relocation): Force a reloc to be generated for alignment fixups.
* config/tc-mn10300.h (TC_FORCE_RELOCATION): Call mn10300_force_relocation.
* elf-m10300.c (mn10300_elf_final_link_relocate): Prevent the accidental termination of DWARF location list entries.
  (mn10300_elf_relax_delete_bytes): Stop deletion if an align reloc is encountered that is larger than or not a mutliple of the number of bytes being deleted.
  When adjusting symbols, any symbols inside the region being deleted must be moved to the end of the region.
  Move align relocs forward if there is room for them after the deletion of the region.
@
text
@d678 1
d688 1
d701 1
d712 1
d732 1
d743 1
d2271 14
d2289 1
a2289 2
      && (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol)))
d2292 1
a2292 2
	   && (!S_IS_DEFINED (fragp->fr_symbol)
	       || seg != S_GET_SEGMENT (fragp->fr_symbol)))
d2295 1
a2295 2
	   &&  (!S_IS_DEFINED (fragp->fr_symbol)
		|| seg != S_GET_SEGMENT (fragp->fr_symbol)))
d2300 1
d2310 5
a2314 5
  if (fixp->fx_addsy != NULL && !S_IS_DEFINED (fixp->fx_addsy))
    {
      /* The symbol is undefined.  Let the linker figure it out.  */
      return 0;
    }
@


1.65
log
@* mn10300.h (R_MN10300_ALIGN): Define.
* reloc.c (BFD_RELOC_MN10300_ALIGN): Add.
* bfd-in2.h: Regenerate.
* libbfd.h: Regenerate.
* elf-m10300.h: Handle R_MN10300_ALIGN relocs.
* mn10300_elf_relax_delete_bytes): Honour R_MN10300_ALIGN relocs.
  Re-fix off by one error in comparisons.
* config/tc-mn10300.c (tc_gen_reloc): Fix test that decides when
  sym_diff relocs should be generated.
  (md_apply_fix): Skip R_MN10300_ALIGN relocs.
  (mn10300_fix_adjustable): Do not adjust R_MN10300_ALIGN relocs.
  (mn10300_handle_align): New function.  Generate R_MN10300_ALIGN
  relocs to record alignment requests.
* config/tc-mn10300.h (TC_FORCE_RELOCATION_SUB_SAME): Also force
  R_MN10300_ALIGN relocs.
  (HANDLE_ALIGN): Define.  Call mn10300_handle_align.
* gas/all/gas.exp: Do not run diff1.s test for mn10300.
* ld-mn10300/mn10300.exp: Run new tests.  Skip i126256 test if
  a compiler is not available.
* ld-mn10300/i112045-3.s: New test.
* ld-mn10300/i112045-3.d: Expected disassembly.
* ld-mn10300/i135409.s: Rename to i135409-1.s.
* ld-mn10300/i135409.d: Rename to i135409-1.d
* ld-mn10300/i135409-2.s: New test.
* ld-mn10300/i135409-2.d: Expected symbol table.
* ld-mn10300/i36434.d: Adjust expected disassembly.
@
text
@d2574 3
a2576 5
  if (! linkrelax)
    return;

  if ((frag->fr_type == rs_align
       || frag->fr_type == rs_align_code)
d2591 11
@


1.64
log
@Add MN10300 linker relaxation support for symbol differences
@
text
@d2184 5
d2194 2
a2195 2
	 even local symbols defined in the same segment.  */
      if (S_GET_SEGMENT (fixp->fx_subsy) == seg)
d2209 1
a2209 1
	  if (S_GET_SEGMENT (fixp->fx_addsy) == absolute_section)
a2218 7

      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	}
d2249 5
a2254 5

      if (reloc->sym_ptr_ptr)
	free (reloc->sym_ptr_ptr);
      free (reloc);
      return & no_relocs;
d2358 4
d2567 26
@


1.63
log
@* elf-m10300.c: Convert to ISO C.
* tc-mn10300.c: Convert to ISO C.
@
text
@d2144 3
d2152 1
a2152 1
arelent *
d2155 2
d2158 1
d2167 2
a2168 1
      return NULL;
d2170 1
d2172 2
d2186 4
a2189 5
      /* If we got a difference between two symbols, and the
	 subtracted symbol is in the current section, use a
	 PC-relative relocation.  If both symbols are in the same
	 section, the difference would have already been simplified
	 to a constant.  */
d2192 1
a2192 11
	  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
	  reloc->addend = (reloc->address - S_GET_VALUE (fixp->fx_subsy)
			   + fixp->fx_offset);

	  switch (fixp->fx_r_type)
	    {
	    case BFD_RELOC_8:
	      reloc->howto = bfd_reloc_type_lookup (stdoutput,
						    BFD_RELOC_8_PCREL);
	      return reloc;
d2194 2
a2195 4
	    case BFD_RELOC_16:
	      reloc->howto = bfd_reloc_type_lookup (stdoutput,
						    BFD_RELOC_16_PCREL);
	      return reloc;
d2197 9
a2205 4
	    case BFD_RELOC_24:
	      reloc->howto = bfd_reloc_type_lookup (stdoutput,
						    BFD_RELOC_24_PCREL);
	      return reloc;
d2207 2
a2208 4
	    case BFD_RELOC_32:
	      reloc->howto = bfd_reloc_type_lookup (stdoutput,
						    BFD_RELOC_32_PCREL);
	      return reloc;
d2210 3
a2212 4
	    default:
	      /* Try to compute the absolute value below.  */
	      break;
	    }
d2249 1
a2249 1
	      return reloc;
d2256 1
a2256 1
      return NULL;
d2264 1
a2264 1
  return reloc;
d2379 8
a2386 5
  if (TC_FORCE_RELOCATION_LOCAL (fixp))
    return FALSE;

  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
d2400 1
a2400 1
  if (! (S_GET_SEGMENT(fixp->fx_addsy)->flags & SEC_MERGE))
d2402 1
d2508 57
@


1.62
log
@Remove duplicate definitions of the md_atof() function
@
text
@d27 1
d63 1
a63 1
  /* bCC relaxing  */
d73 1
a73 1
  /* call relaxing  */
d77 1
a77 1
  /* calls relaxing  */
d81 1
a81 1
  /* jmp relaxing  */
d86 1
a86 1
  /* fbCC relaxing  */
a92 16
/* Local functions.  */
static void mn10300_insert_operand PARAMS ((unsigned long *, unsigned long *,
					    const struct mn10300_operand *,
					    offsetT, char *, unsigned,
					    unsigned));
static unsigned long check_operand PARAMS ((unsigned long,
					    const struct mn10300_operand *,
					    offsetT));
static int reg_name_search PARAMS ((const struct reg_name *, int, const char *));
static bfd_boolean data_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean address_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean other_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean r_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean xr_register_name PARAMS ((expressionS *expressionP));
static void set_arch_mach PARAMS ((int));

d99 2
a100 1
#define MAX_INSN_FIXUPS (5)
d115 3
a117 1
struct option md_longopts[] = {
d120 1
a122 10
/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "am30",	set_arch_mach,		AM30 },
  { "am33",	set_arch_mach,		AM33 },
  { "am33_2",	(void (*) PARAMS ((int))) set_arch_mach, AM33_2 },
  { "mn10300",	set_arch_mach,		MN103 },
  {NULL, 0, 0}
};

d124 2
a125 2
#define HAVE_AM33 (current_machine == AM33 || HAVE_AM33_2)
#define HAVE_AM30 (current_machine == AM30)
a137 2
#define DATA_REG_NAME_CNT				\
  (sizeof (data_registers) / sizeof (struct reg_name))
a146 3
#define ADDRESS_REG_NAME_CNT					\
  (sizeof (address_registers) / sizeof (struct reg_name))

a190 3
#define R_REG_NAME_CNT					\
  (sizeof (r_registers) / sizeof (struct reg_name))

a215 20
#define XR_REG_NAME_CNT					\
  (sizeof (xr_registers) / sizeof (struct reg_name))

/* We abuse the `value' field, that would be otherwise unused, to
   encode the architecture on which (access to) the register was
   introduced.  FIXME: we should probably warn when we encounter a
   register name when assembling for an architecture that doesn't
   support it, before parsing it as a symbol name.  */
static const struct reg_name other_registers[] =
{
  { "epsw", AM33 },
  { "mdr", 0 },
  { "pc", AM33 },
  { "psw", 0 },
  { "sp", 0 },
};

#define OTHER_REG_NAME_CNT				\
  (sizeof (other_registers) / sizeof (struct reg_name))

a251 3
#define FLOAT_REG_NAME_CNT \
  (sizeof (float_registers) / sizeof (struct reg_name))

d272 13
a284 2
#define DOUBLE_REG_NAME_CNT \
  (sizeof (double_registers) / sizeof (struct reg_name))
d286 1
d288 3
a290 3
/* reg_name_search does a binary search of the given register table
   to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure.  */
d293 3
a295 4
reg_name_search (regs, regcount, name)
     const struct reg_name *regs;
     int regcount;
     const char *name;
d297 1
a297 2
  int middle, low, high;
  int cmp;
d304 2
d316 1
d320 7
a326 10
/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
d329 3
a331 2
r_register_name (expressionP)
     expressionS *expressionP;
d342 1
a342 1
  reg_number = reg_name_search (r_registers, R_REG_NAME_CNT, name);
a364 11
/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */

d366 1
a366 2
xr_register_name (expressionP)
     expressionS *expressionP;
d368 2
a369 4
  int reg_number;
  char *name;
  char *start;
  char c;
a370 2
  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;
d372 4
a375 22
  c = get_symbol_end ();
  reg_number = reg_name_search (xr_registers, XR_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
a377 11
/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */

d379 1
a379 2
data_register_name (expressionP)
     expressionS *expressionP;
d381 1
a381 30
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (data_registers, DATA_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
a383 11
/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */

d385 1
a385 2
address_register_name (expressionP)
     expressionS *expressionP;
d387 1
a387 30
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (address_registers, ADDRESS_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
a389 11
/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */

d391 1
a391 2
other_register_name (expressionP)
     expressionS *expressionP;
d393 1
a393 31
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (other_registers, OTHER_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number == 0
      || (reg_number == AM33 && HAVE_AM33))
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = 0;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
a395 13
static bfd_boolean double_register_name PARAMS ((expressionS *));
static bfd_boolean float_register_name  PARAMS ((expressionS *));

/* Summary of float_register_name:

   in: Input_line_pointer points to 1st char of operand.

   out: A expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

d397 1
a397 2
float_register_name (expressionP)
     expressionS *expressionP;
d399 1
a399 30
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (float_registers, FLOAT_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  * input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
a401 10
/* Summary of double_register_name:

   in: Input_line_pointer points to 1st char of operand.

   out: A expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

d403 1
a403 2
double_register_name (expressionP)
     expressionS *expressionP;
d414 1
a414 1
  reg_number = reg_name_search (double_registers, DOUBLE_REG_NAME_CNT, name);
d417 1
a417 1
  * input_line_pointer = c;
d420 2
a421 1
  if (reg_number >= 0)
d424 1
a424 1
      expressionP->X_add_number = reg_number;
d439 1
a439 2
md_show_usage (stream)
     FILE *stream;
d446 1
a446 3
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d452 1
a452 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d464 3
a466 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     fragS *fragP;
d895 1
a895 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d898 1
d903 1
a903 1
md_begin ()
d906 1
a906 1
  register const struct mn10300_opcode *op;
a941 3
static inline int mn10300_check_fixup PARAMS ((struct mn10300_fixup *));
static inline int mn10300_PIC_related_p PARAMS ((symbolS *));

d943 1
a943 2
mn10300_PIC_related_p (sym)
     symbolS *sym;
d961 1
a961 2
mn10300_check_fixup (fixup)
     struct mn10300_fixup *fixup;
d1007 1
a1007 4
mn10300_cons_fix_new (frag, off, size, exp)
     fragS *frag;
     int off, size;
     expressionS *exp;
d1066 154
d1221 1
a1221 2
md_assemble (str)
     char *str;
d1607 2
a1608 2
              mn10300_insert_operand (&insn, &extension, operand,
                                      value, (char *) NULL, 0, 0);
d1705 2
a1706 2
		mn10300_insert_operand (&insn, &extension, operand,
					ex.X_add_number, (char *) NULL,
d1720 1
a1720 1
		  && !check_operand (insn, operand, ex.X_add_number))
d1727 2
a1728 3
	      mn10300_insert_operand (&insn, &extension, operand,
				      ex.X_add_number, (char *) NULL,
				      0, 0);
a1758 1

d2150 1
a2150 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d2153 1
a2153 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d2156 1
a2156 1
  if (reloc->howto == (reloc_howto_type *) NULL)
d2169 1
a2169 1
      fixp->fx_subsy = 0;
d2183 1
a2183 1
	  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d2261 1
a2261 1
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d2269 1
a2269 3
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp;
     asection *seg;
d2293 1
a2293 2
md_pcrel_from (fixp)
     fixS *fixp;
d2295 1
a2295 1
  if (fixp->fx_addsy != (symbolS *) NULL && !S_IS_DEFINED (fixp->fx_addsy))
d2304 1
a2304 4
md_apply_fix (fixP, valP, seg)
     fixS * fixP;
     valueT * valP;
     segT seg;
d2326 1
a2326 1
  if (fixP->fx_addsy != (symbolS *) NULL && ! fixP->fx_pcrel)
d2378 1
a2378 2
mn10300_fix_adjustable (fixp)
     struct fix *fixp;
d2381 1
a2381 1
    return 0;
d2385 1
a2385 1
    return 0;
d2392 1
a2392 1
    return 0;
d2399 1
a2399 1
    return 0;
d2401 1
a2401 155
    return 0;

  return 1;
}

/* Insert an operand value into an instruction.  */

static void
mn10300_insert_operand (insnp, extensionp, operand, val, file, line, shift)
     unsigned long *insnp;
     unsigned long *extensionp;
     const struct mn10300_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
     unsigned int shift;
{
  /* No need to check 32bit operands for a bit.  Note that
     MN10300_OPERAND_SPLIT is an implicit 32bit operand.  */
  if (operand->bits != 32
      && (operand->flags & MN10300_OPERAND_SPLIT) == 0)
    {
      long min, max;
      offsetT test;
      int bits;

      bits = operand->bits;
      if (operand->flags & MN10300_OPERAND_24BIT)
	bits = 24;

      if ((operand->flags & MN10300_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (bits - 1)) - 1;
	  min = - (1 << (bits - 1));
	}
      else
	{
	  max = (1 << bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	as_warn_value_out_of_range (_("operand"), test, (offsetT) min, (offsetT) max, file, line);
    }

  if ((operand->flags & MN10300_OPERAND_SPLIT) != 0)
    {
      *insnp |= (val >> (32 - operand->bits)) & ((1 << operand->bits) - 1);
      *extensionp |= ((val & ((1 << (32 - operand->bits)) - 1))
		      << operand->shift);
    }
  else if ((operand->flags & MN10300_OPERAND_24BIT) != 0)
    {
      *insnp |= (val >> (24 - operand->bits)) & ((1 << operand->bits) - 1);
      *extensionp |= ((val & ((1 << (24 - operand->bits)) - 1))
		      << operand->shift);
    }
  else if ((operand->flags & (MN10300_OPERAND_FSREG | MN10300_OPERAND_FDREG)))
    {
      /* See devo/opcodes/m10300-opc.c just before #define FSM0 for an
         explanation of these variables.  Note that FMT-implied shifts
        are not taken into account for FP registers.  */
      unsigned long mask_low, mask_high;
      int shl_low, shr_high, shl_high;

      switch (operand->bits)
	{
	case 5:
	  /* Handle regular FP registers.  */
	  if (operand->shift >= 0)
	    {
	      /* This is an `m' register.  */
	      shl_low = operand->shift;
	      shl_high = 8 + (8 & shl_low) + (shl_low & 4) / 4;
	    }
	  else
	    {
	      /* This is an `n' register.  */
	      shl_low = -operand->shift;
	      shl_high = shl_low / 4;
	    }

	  mask_low = 0x0f;
	  mask_high = 0x10;
	  shr_high = 4;
	  break;

	case 3:
	  /* Handle accumulators.  */
	  shl_low = -operand->shift;
	  shl_high = 0;
	  mask_low = 0x03;
	  mask_high = 0x04;
	  shr_high = 2;
	  break;

	default:
	  abort ();
	}
      *insnp |= ((((val & mask_high) >> shr_high) << shl_high)
		 | ((val & mask_low) << shl_low));
    }
  else if ((operand->flags & MN10300_OPERAND_EXTENDED) == 0)
    {
      *insnp |= (((long) val & ((1 << operand->bits) - 1))
		 << (operand->shift + shift));

      if ((operand->flags & MN10300_OPERAND_REPEATED) != 0)
	*insnp |= (((long) val & ((1 << operand->bits) - 1))
		   << (operand->shift + shift + operand->bits));
    }
  else
    {
      *extensionp |= (((long) val & ((1 << operand->bits) - 1))
		      << (operand->shift + shift));

      if ((operand->flags & MN10300_OPERAND_REPEATED) != 0)
	*extensionp |= (((long) val & ((1 << operand->bits) - 1))
			<< (operand->shift + shift + operand->bits));
    }
}

static unsigned long
check_operand (insn, operand, val)
     unsigned long insn ATTRIBUTE_UNUSED;
     const struct mn10300_operand *operand;
     offsetT val;
{
  /* No need to check 32bit operands for a bit.  Note that
     MN10300_OPERAND_SPLIT is an implicit 32bit operand.  */
  if (operand->bits != 32
      && (operand->flags & MN10300_OPERAND_SPLIT) == 0)
    {
      long min, max;
      offsetT test;
      int bits;

      bits = operand->bits;
      if (operand->flags & MN10300_OPERAND_24BIT)
	bits = 24;

      if ((operand->flags & MN10300_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (bits - 1)) - 1;
	  min = - (1 << (bits - 1));
	}
      else
	{
	  max = (1 << bits) - 1;
	  min = 0;
	}

      test = val;
d2403 1
a2403 6
      if (test < (offsetT) min || test > (offsetT) max)
	return 0;
      else
	return 1;
    }
  return 1;
d2407 1
a2407 2
set_arch_mach (mach)
     int mach;
a2414 2
static inline char * mn10300_end_of_match PARAMS ((char *, char *));

d2416 1
a2416 2
mn10300_end_of_match (cont, what)
     char *cont, *what;
d2428 4
a2431 5
mn10300_parse_name (name, exprP, mode, nextcharP)
     char const *name;
     expressionS *exprP;
     enum expr_mode mode;
     char *nextcharP;
d2495 10
@


1.61
log
@Switch to GPLv3
@
text
@d714 1
a714 4
md_atof (type, litp, sizep)
     int type;
     char *litp;
     int *sizep;
d716 1
a716 33
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return "bad call to md_atof";
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
@


1.60
log
@	* config/tc-mn10300.c (md_convert_frag): Correct fixup size.
	(md_assemble): Likewise.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.59
log
@	* config/tc-spu.h (TC_RELOC_RTSYM_LOC_FIXUP): Delete.
	* config/tc-m32r.h (TC_RELOC_RTSYM_LOC_FIXUP): Delete.
	* config/tc-mn10300.h (TC_RELOC_RTSYM_LOC_FIXUP): Delete.
	(TC_FORCE_RELOCATION): Define.
	(TC_FORCE_RELOCATION_LOCAL): Define.
	* config/tc-mn10300.c (mn10300_fix_adjustable): Adjust.
@
text
@d1022 1
a1022 1
      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
a2282 9
	      /* Convert the size of the reloc into what fix_new_exp wants.  */
	      reloc_size = reloc_size / 8;
	      if (reloc_size == 8)
		reloc_size = 0;
	      else if (reloc_size == 16)
		reloc_size = 1;
	      else if (reloc_size == 32)
		reloc_size = 2;

d2284 1
a2284 1
				  reloc_size, &fixups[i].exp, pcrel,
@


1.58
log
@Fix score bugs
@
text
@d3 1
a3 1
   2006  Free Software Foundation, Inc.
d2548 1
a2548 1
  if (! TC_RELOC_RTSYM_LOC_FIXUP (fixp))
@


1.57
log
@remove some duplicate #include's.
@
text
@d694 1
a694 1
  fprintf (stream, _("MN10300 options:\n\
@


1.56
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@a21 1
#include <stdio.h>
@


1.55
log
@Fixes for building on 64-bit hosts:
        * config/tc-avr.c (mod_index): New union to allow conversion
        between pointers and integers.
        (md_begin, avr_ldi_expression): Use it.
        * config/tc-i370.c (md_assemble): Add cast for argument to print
        statement.
        * config/tc-tic54x.c (subsym_substitute): Likewise.
        * config/tc-mn10200.c (md_assemble): Use a union to convert the
        opindex field of fr_cgen structure into a pointer so that it can
        be stored in a frag.
        * config/tc-mn10300.c (md_assemble): Likewise.
        * config/tc-frv.c (frv_debug_tomcat): Use %p to print pointer
        types.
        * config/tc-v850.c: Replace uses of (int) casts with correct
        types.
        * gas/tic54x/address.d: Work with 64bit hosts.
        * gas/tic54x/addrfar.d: Likewise.
        * gas/tic54x/align.d: Likewise.
        * gas/tic54x/all-opcodes.d: Likewise.
        * gas/tic54x/asg.d: Likewise.
        * gas/tic54x/cons.d: Likewise.
        * gas/tic54x/consfar.d: Likewise.
        * gas/tic54x/extaddr.d: Likewise.
        * gas/tic54x/field.d: Likewise.
        * gas/tic54x/labels.d: Likewise.
        * gas/tic54x/loop.d: Likewise.
        * gas/tic54x/lp.d: Likewise.
        * gas/tic54x/macro.d: Likewise.
        * gas/tic54x/math.d: Likewise.
        * gas/tic54x/opcodes.d: Likewise.
        * gas/tic54x/sections.d: Likewise.
       * gas/tic54x/set.d: Likewise.
       * gas/tic54x/struct.d: Likewise.
       * gas/tic54x/subsym.d: Likewise.
@
text
@d2410 2
a2411 1
	      reloc->sym_ptr_ptr = (asymbol **) &bfd_abs_symbol;
@


1.54
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d2008 12
d2059 1
d2063 1
a2063 1
		    (char *)fixups[0].opindex);
@


1.53
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d2746 1
a2746 1
mn10300_parse_name (name, exprP, nextcharP)
d2749 1
d2769 1
a2769 1
      if (segment == absolute_section)
d2775 1
a2775 1
      else if (segment == reg_section)
@


1.52
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d2471 4
a2474 5
     Since we are using BFD_ASSEMBLER, if we are doing this relocation
     the code in write.c is going to call bfd_install_relocation, which
     is also going to use the symbol value.  That means that if the
     reloc is fully resolved we want to use *valuep since
     bfd_install_relocation is not being used.
@


1.51
log
@Update the address and phone number of the FSF
@
text
@d2455 1
a2455 1
md_apply_fix3 (fixP, valP, seg)
@


1.50
log
@update copyright dates
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.49
log
@* config/tc-mn10300.c (md_relax_table): More fixes to the offsets in this table.
  They should be correct now.
* gas/mn10300/relax.s: Add further tests of the relaxing of branch instructions.
* gas/mn10300/relax.d: Add expected relocations.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@


1.48
log
@Fix off by one negative offsets for conditional branches.
Add a test of this fix.
@
text
@d57 6
a62 1
const relax_typeS md_relax_table[] = {
d65 1
a65 1
  {0x7fff, -0x8000 + 1, 5, 2},
d68 1
a68 1
  /* bCC relaxing (uncommon cases)  */
d70 1
a70 1
  {0x7fff, -0x8000 + 1, 6, 5},
d88 1
a88 1
  {0x7fff, -0x8000 + 1, 6, 15},
@


1.47
log
@* config/tc-mn10300.h (tc_fix_adjustable): Define.
* config/tc-mn10300.c (mn10300_fix_adjustable): Don't adjust debug
or non-merged symbols.
@
text
@d60 1
a60 1
  {0x7fff, -0x8000, 5, 2},
d65 1
a65 1
  {0x7fff, -0x8000, 6, 5},
d83 1
a83 1
  {0x7fff, -0x8000, 6, 15},
@


1.46
log
@Remove duplicate code and provide a function for generating internally consistent 'value out of range' messages
@
text
@d2545 9
@


1.45
log
@2002-12-12  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-mn10300.h (EXTERN_FORCE_RELOC): Don't define to zero.
2001-05-09  Alexandre Oliva  <aoliva@@redhat.com>
* configure.in (am33_2.0, mn10300-*-linux*): Added.
* configure: Rebuilt.
* config/tc-mn10300.h (TARGET_FORMAT) [TE_LINUX]: Define to
elf32-am33lin.
* config/tc-mn10300.c (md_begin) [TE_LINUX]: Choose AM33/2.0
by default.
@
text
@d2587 1
a2587 11
	{
	  const char *err =
	    _("operand out of range (%s not between %ld and %ld)");
	  char buf[100];

	  sprint_value (buf, test);
	  if (file == (char *) NULL)
	    as_warn (err, buf, min, max);
	  else
	    as_warn_where (file, line, err, buf, min, max);
	}
@


1.44
log
@2003-02-25  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-mn10300.c (mn10300_check_fixup): Set GOT_PCREL type
for subtracts from GLOBAL_OFFSET_TABLE that could not be
simplified.
2002-07-18  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-mn10300.c (mn10300_check_fixup): Accept subtracts that
could not be simplified.
(tc_gen_reloc): Turn an absolute fx_subsy into part of fx_offset.
2001-11-04  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-mn10300.h (TC_RELOC_RTSYM_LOC_FIXUP): Don't adjust
BDF_RELOC_MN10300_GOT32.
* config/tc-mn10300.c (mn10300_fix_adjustable): If
TC_RELOC_RTSYM_LOC_FIXUP doesn't hold, it's not adjustable.
2001-05-09  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-mn10300.c (mn10300_parse_name): Don't return a
symbol if we know its value.
2001-05-09  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-mn10300.h (GLOBAL_OFFSET_TABLE_NAME): Remove
duplicate underscore prefix.
2001-05-09  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-mn10300.c (mn10300_parse_name): Store relocation
type in X_md, not X_add_number.  Zero X_add_number.
(mn10300_check_fixup): Extract relocation type from X_md.
* config/tc-mn10300.h: Update comment.
2001-04-14  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-mn10300.h (O_GOTOFF, O_PLT, O_GOT): Replace with...
(O_PIC_reloc): this.
* config/tc-mn10300.c (mn10300_PIC_related_p): Use it.
(mn10300_check_fixup): Likewise.
(mn10300_parse_name): Set X_add_number to relocation type.
* config/tc-mn10300.h (DIFF_EXPR_OK, GLOBAL_OFFSET_TABLE_NAME,
TC_RELOC_RTSYM_LOC_FIXUP, md_parse_name, TC_CONS_FIX_NEW,
O_GOTOFF, O_PLT, O_GOT): Define.
* config/tc-mn10300.c (mn10300_PIC_related_p): New fn.
(mn10300_check_fixup): New fn.
(md_assemble): Call it.  Check for PIC-related relocs.
(mn10300_cons_fix_new): Likewise.  New fn.
(mn10300_end_of_match): New fn.
(mn10300_md_parse_name_cont): New fn.
@
text
@d1216 6
d1226 1
@


1.43
log
@2000-05-25  Alexandre Oliva  <aoliva@@cygnus.com>
* config/tc-mn10300.c (mn10300_insert_operand): Negate negative
accumulator's shift.
2000-05-08  Alexandre Oliva  <aoliva@@cygnus.com>
* config/tc-mn10300.c (md_relax_table, md_convert_frag,
md_assemble, md_estimate_size_before_relax): Handle fbCC.
2000-04-20  Alexandre Oliva  <aoliva@@cygnus.com>
* config/tc-mn10300.c (HAVE_AM33): Redefine in terms of
HAVE_AM33_2.
2000-04-03  Alexandre Oliva  <aoliva@@cygnus.com>
* config/tc-mn10300.c (md_pseudo_table): Use AM33_2 constant.
(HAVE_AM33): Match AM33_2 too.
(HAVE_AM33_2): New macro.
(md_assemble): Use it.  Match 2.0 registers only if HAVE_AM33_2.
2000-04-01  Alexandre Oliva  <aoliva@@cygnus.com>
* config/tc-mn10300.c (md_pseudo_table): Added `am33_2'.
(float_registers, double_registers): New variables.
(float_register_name, double_register_name): New functions.
(md_assemble): Recognize FP registers.  Implement FMT_D3.
(mn10300_insert_operand): Support FP registers.
@
text
@d1222 134
d1885 2
d2181 5
a2185 1
	  if (fixups[i].reloc != BFD_RELOC_UNUSED)
d2215 2
d2228 2
d2234 3
a2236 1
	      if (pcrel)
d2302 7
d2524 3
d2718 84
@


1.42
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d81 5
d135 1
d140 2
a141 1
#define HAVE_AM33 (current_machine == AM33)
d261 63
d591 95
d1033 145
d1278 1
d1373 33
d1645 12
d1683 2
d1852 3
d1893 2
d2001 6
d2269 2
d2448 45
@


1.41
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@a127 2
  { "file",     (void (*) PARAMS ((int))) dwarf2_directive_file,  0 },
  { "loc",      dwarf2_directive_loc,   0 },
@


1.40
log
@* config/tc-mn10300.c (set_arch_mach): Change argument type to
avoid warnings.
(r_register_name, xr_register_name): Add prototype declarations.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
a1992 15
}

/* Return nonzero if the fixup in FIXP will require a relocation,
   even it if appears that the fixup could be completely handled
   within GAS.  */

int
mn10300_force_relocation (fixp)
     struct fix *fixp;
{
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  return S_FORCE_RELOC (fixp->fx_addsy);
@


1.39
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d95 3
a97 1
static void set_arch_mach PARAMS ((unsigned int));
d2157 1
a2157 1
     unsigned int mach;
@


1.38
log
@gas reloc rewrite.
@
text
@d92 3
a94 3
static boolean data_register_name PARAMS ((expressionS *expressionP));
static boolean address_register_name PARAMS ((expressionS *expressionP));
static boolean other_register_name PARAMS ((expressionS *expressionP));
d296 1
a296 1
static boolean
d324 1
a324 1
      return true;
d329 1
a329 1
  return false;
d343 1
a343 1
static boolean
d371 1
a371 1
      return true;
d376 1
a376 1
  return false;
d390 1
a390 1
static boolean
d418 1
a418 1
      return true;
d423 1
a423 1
  return false;
d437 1
a437 1
static boolean
d465 1
a465 1
      return true;
d470 1
a470 1
  return false;
d484 1
a484 1
static boolean
d513 1
a513 1
      return true;
d518 1
a518 1
  return false;
d2011 1
a2011 1
boolean
@


1.37
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2005 1
a2005 10
  /* Do not adjust relocations involving symbols in code sections,
     because it breaks linker relaxations.  This could be fixed in the
     linker, but this fix is simpler, and it pretty much only affects
     object size a little bit.  */
  if ((S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_CODE)
      && fixp->fx_subsy
      && S_GET_SEGMENT (fixp->fx_addsy) == S_GET_SEGMENT (fixp->fx_subsy))
    return 1;

  return 0;
a2014 4
  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
    return 0;

@


1.36
log
@	* config/obj-coff.h: Fix formatting.
	* config/tc-mcore.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-openrisc.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-xstormy16.h: Likewise.
@
text
@d126 1
a126 1
  { "file",     dwarf2_directive_file,  0 },
@


1.35
log
@* config/tc-mn10300.c (other_registers): Added `epsw'.  Mark `pc'
and `epsw' as available on AM33 and above only.
(other_register_name): Add logic to handle machine type encoded in
reg_number.
@
text
@d1809 1
a1809 1
	      
d1849 1
a1849 1
	      
@


1.34
log
@* config/tc-mn10300.c (xr_registers): Move `pc'...
(other_registers): ... here.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d237 5
d244 1
d246 1
a246 1
  { "pc", 0 },
d503 2
a504 1
  if (reg_number >= 0)
d507 1
a507 1
      expressionP->X_add_number = reg_number;
@


1.34.2.1
log
@* config/tc-mn10300.c (other_registers): Added `epsw'.  Mark `pc'
and `epsw' as available on AM33 and above only.
(other_register_name): Add logic to handle machine type encoded in
reg_number.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
a236 5
/* We abuse the `value' field, that would be otherwise unused, to
   encode the architecture on which (access to) the register was
   introduced.  FIXME: we should probably warn when we encounter a
   register name when assembling for an architecture that doesn't
   support it, before parsing it as a symbol name.  */
a238 1
  { "epsw", AM33 },
d240 1
a240 1
  { "pc", AM33 },
d497 1
a497 2
  if (reg_number == 0
      || (reg_number == AM33 && HAVE_AM33))
d500 1
a500 1
      expressionP->X_add_number = 0;
@


1.33
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@a214 1
  { "pc", 0 },
d240 1
@


1.32
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d1911 4
a1914 4
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
d1917 1
a1917 1
  char *fixpos = fixp->fx_where + fixp->fx_frag->fr_literal;
d1919 1
a1919 1
  int value;
d1921 1
a1921 1
  assert (fixp->fx_r_type < BFD_RELOC_UNUSED);
d1925 1
a1925 1
      abort ();
d1938 2
a1939 4
  if (fixp->fx_addsy == (symbolS *) NULL || fixp->fx_pcrel)
    value = *valuep;
  else
    value = fixp->fx_offset;
d1943 3
a1945 3
  if (fixp->fx_addsy != NULL
      && (! S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != seg)))
d1947 2
a1948 2
      fixp->fx_done = 0;
      return 0;
d1951 1
a1951 1
  switch (fixp->fx_r_type)
d1970 2
a1971 2
      fixp->fx_done = 0;
      return 1;
d1975 2
a1976 2
      as_bad_where (fixp->fx_file, fixp->fx_line,
                   _("Bad relocation fixup type (%d)"), fixp->fx_r_type);
d1982 2
a1983 4
  if (fixp->fx_addsy == NULL)
    fixp->fx_done = 1;

  return 0;
@


1.31
log
@* config/tc-mn10300.c (tc_gen_reloc): Don't free
reloc->sym_ptr_ptr if it's not allocated.
@
text
@d283 1
a283 1
 * out: A expressionS.
d330 1
a330 1
 * out: A expressionS.
d377 1
a377 1
 * out: A expressionS.
d424 1
a424 1
 * out: A expressionS.
d471 1
a471 1
 * out: A expressionS.
@


1.30
log
@* config/tc-mn10300.c (tc_gen_reloc): Don't emit an *ABS*
relocation for differences between symbols in a section other
than the one in which the difference is to be placed; apply
the relocation instead.
@
text
@d1782 2
d1861 2
a1862 1
      free (reloc->sym_ptr_ptr);
@


1.29
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a1826 1
	  return NULL;
d1828 3
d1832 30
a1861 3
      reloc->sym_ptr_ptr = (asymbol **) &bfd_abs_symbol;
      reloc->addend = (S_GET_VALUE (fixp->fx_addsy)
		       - S_GET_VALUE (fixp->fx_subsy) + fixp->fx_offset);
@


1.28
log
@	* dwarf2dbg.c (dwarf2_directive_file): Avoid signed/unsigned warning.

	* write.c (set_symtab): Update bfd_alloc declaration.  Use a temp
	var to ensure bfd_alloc arg is the right type.
	(write_object_file): Cast args of bfd_seek.  Replace bfd_write with
	bfd_bwrite.

	* config/obj-coff.c: Replace calls to bfd_write with calls to
	bfd_bwrite.  Cast args of bfd_seek.

	* config/obj-elf.c (obj_elf_change_section): Avoid signed/unsigned
	warning.

	* config/tc-mn10300.c (set_arch_mach): Make param unsigned.

	* config/tc-tic54x.c (tic54x_mlib): Replace bfd_read call with
	call to bfd_bread.
@
text
@a22 1
#include <ctype.h>
d24 1
d920 1
a920 1
  for (s = str; *s != '\0' && !isspace (*s); s++)
d934 1
a934 1
  while (isspace (*str))
d1448 1
a1448 1
  while (isspace (*str))
@


1.27
log
@	* config/obj-elf.c (obj_elf_symver): Temporarily modify lex_type
	to include '@@' in symbol names when parsing versioned symbols
	rather than calling get_symbol_end multiple times.
	* config/tc-i370.c (register_name): Format fixes.  Don't call
	get_symbol_end after parsing number.
	* config/tc-mn10200.c (data_register_name): Format fixes.  Hoist
	code out of conditional.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-mn10300.c (r_register_name): Likewise.
	(xr_register_name): Likewise.
	(data_register_name): Likewise.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-ppc.c (register_name): Likewise.
	* config/tc-s390.c (register_name): Likewise.
@
text
@d95 1
a95 1
static void set_arch_mach PARAMS ((int));
d2133 1
a2133 1
     int mach;
@


1.26
log
@* config/tc-mn10300.c (mn10300_force_relocation): Don't
optimize differences between symbols in code sections to
constants.
(mn10300_fix_adjustable): Don't adjust to section+offset
relocations pointing at symbols in code sections.
@
text
@d305 3
a317 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d320 4
a323 10
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
    }
d352 3
a364 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d367 4
a370 10
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
    }
d399 3
a411 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d414 4
a417 10
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
    }
d446 3
a458 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
a460 8
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
d462 3
a464 2
      return false;
    }
d493 3
a505 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d508 4
a511 10
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
    }
@


1.25
log
@* config/tc-mn10300.c (md_assemble): Anchor dwarf2 line info
before a relaxable insns.
@
text
@d1996 9
d2021 7
@


1.24
log
@* config/tc-mn10300.c (tc_gen_reloc): Don't reject differences
between symbols if the base symbol is in the current section;
emit a PC-relative relocation instead.
@
text
@d1520 7
d1780 2
a1782 2

  dwarf2_emit_insn (size);
@


1.23
log
@* config/tc-mn10300.c (md_apply_fix3): Accept PC-relative relocs.
@
text
@d1801 39
@


1.22
log
@* config/tc-mn10300.c (md_assemble): Subtract operand->shift
from offset in non-pcrel operands too.
@
text
@d1904 1
d1909 1
d1914 1
@


1.21
log
@* config/tc-mn10300.c (md_assemble): Simplify offset adjustment of
pc-relative relocations not placed at the end of the instruction.
@
text
@d1730 1
a1730 7
	      offset = size - reloc_size / 8;

	      /* If the pcrel relocation isn't at the end of the insn,
		 we have to adjust the offset for the relocation to be
		 correct.  */
	      if (pcrel)
		offset -= operand->shift / 8;
@


1.20
log
@* config/tc-mn10300.c (xr_registers): Added `pc'.
@
text
@d940 1
a940 1
  unsigned long insn, extension, size = 0, real_size;
a1515 2
  real_size = size;

d1730 1
a1730 16
	      /* Gross.  This disgusting hack is to make sure we
		 get the right offset for the 16/32 bit reloc in
		 "call" instructions.  Basically they're a pain
		 because the reloc isn't at the end of the instruction.  */
	      if ((size == 5 || size == 7)
		  && (((insn >> 24) & 0xff) == 0xcd
		      || ((insn >> 24) & 0xff) == 0xdd))
		size -= 2;

	      /* Similarly for certain bit instructions which don't
		 hav their 32bit reloc at the tail of the instruction.  */
	      if (size == 7
		  && (((insn >> 16) & 0xffff) == 0xfe00
		      || ((insn >> 16) & 0xffff) == 0xfe01
		      || ((insn >> 16) & 0xffff) == 0xfe02))
		size -= 1;
d1732 5
a1736 1
	      offset = size - reloc_size / 8;
d1781 1
a1781 1
  dwarf2_emit_insn (real_size);
@


1.19
log
@Prepare for multi-pass relaxation.
@
text
@d215 1
@


1.18
log
@Fix copyright notices
@
text
@d1846 17
a1862 38
  if (fragp->fr_subtype == 0)
    return 2;
  if (fragp->fr_subtype == 3)
    return 3;
  if (fragp->fr_subtype == 6)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 7;
	  return 7;
	}
      else
	return 5;
    }
  if (fragp->fr_subtype == 8)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 9;
	  return 6;
	}
      else
	return 4;
    }
  if (fragp->fr_subtype == 10)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 12;
	  return 5;
	}
      else
	return 2;
    }
  abort ();
@


1.17
log
@Don't mark a fixup as done if it's against a symbol.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation.
@


1.16
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation.
d1966 4
a1969 1
  fixp->fx_done = 1;
a1970 1

@


1.16.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a213 1
  { "pc", 0 },
d938 1
a938 1
  unsigned long insn, extension, size = 0;
d1514 2
a1519 7
      /* We want to anchor the line info to the previous frag (if
	 there isn't one, create it), so that, when the insn is
	 resized, we still get the right address for the beginning of
	 the region.  */
      f = frag_more (0);
      dwarf2_emit_insn (0);

d1730 18
a1747 1
	      offset = size - (reloc_size + operand->shift) / 8;
d1790 1
d1792 1
a1792 2
      dwarf2_emit_insn (size);
    }
a1817 39
      /* If we got a difference between two symbols, and the
	 subtracted symbol is in the current section, use a
	 PC-relative relocation.  If both symbols are in the same
	 section, the difference would have already been simplified
	 to a constant.  */
      if (S_GET_SEGMENT (fixp->fx_subsy) == seg)
	{
	  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
	  reloc->addend = (reloc->address - S_GET_VALUE (fixp->fx_subsy)
			   + fixp->fx_offset);

	  switch (fixp->fx_r_type)
	    {
	    case BFD_RELOC_8:
	      reloc->howto = bfd_reloc_type_lookup (stdoutput,
						    BFD_RELOC_8_PCREL);
	      return reloc;
	      
	    case BFD_RELOC_16:
	      reloc->howto = bfd_reloc_type_lookup (stdoutput,
						    BFD_RELOC_16_PCREL);
	      return reloc;

	    case BFD_RELOC_24:
	      reloc->howto = bfd_reloc_type_lookup (stdoutput,
						    BFD_RELOC_24_PCREL);
	      return reloc;

	    case BFD_RELOC_32:
	      reloc->howto = bfd_reloc_type_lookup (stdoutput,
						    BFD_RELOC_32_PCREL);
	      return reloc;

	    default:
	      /* Try to compute the absolute value below.  */
	      break;
	    }
	}
d1845 38
a1882 17
  if (fragp->fr_subtype == 6
      && (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 7;
  else if (fragp->fr_subtype == 8
	   && (!S_IS_DEFINED (fragp->fr_symbol)
	       || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 9;
  else if (fragp->fr_subtype == 10
	   &&  (!S_IS_DEFINED (fragp->fr_symbol)
		|| seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 12;

  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
a1941 1
    case BFD_RELOC_8_PCREL:
a1945 1
    case BFD_RELOC_16_PCREL:
a1949 1
    case BFD_RELOC_32_PCREL:
d1966 2
a1967 3
  /* If a symbol remains, pass the fixup, as a reloc, onto the linker.  */
  if (fixp->fx_addsy == NULL)
    fixp->fx_done = 1;
a1968 1
  return 0;
a1982 9
  /* Do not adjust relocations involving symbols in code sections,
     because it breaks linker relaxations.  This could be fixed in the
     linker, but this fix is simpler, and it pretty much only affects
     object size a little bit.  */
  if ((S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_CODE)
      && fixp->fx_subsy
      && S_GET_SEGMENT (fixp->fx_addsy) == S_GET_SEGMENT (fixp->fx_subsy))
    return 1;

a1998 7
    return 0;

  /* Do not adjust relocations involving symbols in code sections,
     because it breaks linker relaxations.  This could be fixed in the
     linker, but this fix is simpler, and it pretty much only affects
     object size a little bit.  */
  if (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_CODE)
@


1.15
log
@2000-11-14  Kazu Hirata  <kazu@@hxi.com>

	* config/aout_gnu.h: Fix formatting.
	* config/atof-vax.c: Likewise.
	* config/m68k-parse.h: Likewise.
	* config/m88k-opcode.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/te-386bsd.h: Likewise.
	* config/te-hppa.h: Likewise.
	* config/te-nbsd.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-sparcaout.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/vax-inst.h: Likewise.
	* config/vms-conf.h: Likewise.
@
text
@d1792 1
a1792 2
  if (debug_type == DEBUG_DWARF2)
    dwarf2_generate_asm_lineno (real_size);
a2135 7
}

void
mn10300_finalize ()
{
  if (debug_type == DEBUG_DWARF2)
    dwarf2_finish ();
@


1.14
log
@SWitch over to using dwarf2_generate_asm_lineno
@
text
@a1929 1

@


1.13
log
@2000-10-31  Eric Christopher  <echristo@@cygnus.com>

	* config/tc-mn10300.c (md_apply_fix3): Use valuep if fully resolved
	or pc-relative, else use fx_offset.
@
text
@a34 2
struct dwarf2_line_info debug_line;

d1793 1
a1793 13
    {
      bfd_vma addr;

      /* First update the notion of the current source line.  */
      dwarf2_where (&debug_line);

      /* We want the offset of the start of this instruction within the
         the current frag.  */
      addr = frag_now->fr_address + frag_now_fix () - real_size;

      /* And record the information.  */
      dwarf2_gen_line_info (addr, &debug_line);
    }
@


1.12
log
@2000-09-05  Eric Christopher  <echristo@@cygnus.com>

	* config/tc-mn10300.c: Cleanup.
	(md_pcrel_from): Enable.
@
text
@d1915 1
a1915 1
     valueT *valuep ATTRIBUTE_UNUSED;
d1920 1
d1928 17
d1980 1
a1980 1
  md_number_to_chars (fixpos, fixp->fx_offset, size);
@


1.11
log
@2000-08-31  Eric Christopher  <echristo@@cygnus.com>

	* config/tc-mn10300.c:  Cleanup and fix warnings.
	(md_pseudo_table): Add initializers.
	(md_show_usage): Cleanup.
	(md_parse_option): Fix warnings.
	(md_undefined_symbol): Fix warnings.
	(md_conver_frag): Fix warnings.
	(tc_gen_reloc): Fix warnings.
	(md_apply_fix3): Fix warnings.
	(check_operand): Fix warnings.
@
text
@d98 3
a923 5
  /* This is both a simplification (we don't have to write md_apply_fix)
     and support for future optimizations (branch shortening and similar
     stuff in the linker).  */
  linkrelax = 1;

a1903 2
  return fixp->fx_frag->fr_address;
#if 0
a1909 1
#endif
@


1.10
log
@2000-08-22  Eric Christopher  <echristo@@cygnus.com>

	* config/tc-mn10300.c: (md_apply_fix): New function.
	(mn10300_force_relocation): New function.
	(mn10300_fix_adjustable): New function.

	* config/tc-mn10300.h: (TC_FORCE_RELOCATION): Define.
	(TC_HANDLES_FX_DONE): Define.
	(obj_fix_adjustable): Define.
	(MD_APPLY_FIX3): Define.
	(TC_LINKRELAX_FIXUP): Define.

	* write.c: (TC_LINKRELAX_FIXUP):  Define if not
	previously defined.
	(fixup_segment): Use TC_LINKRELAX_FIXUP.

	* doc/internals.texi: Document TC_LINKRELAX_FIXUP.
@
text
@d124 2
a125 2
  { "file", dwarf2_directive_file },
  { "loc", dwarf2_directive_loc },
d547 2
a548 2
     int c;
     char *arg;
d555 1
a555 1
     char *name;
d603 1
a603 1
     bfd *abfd;
d1817 1
a1817 1
     asection *seg;
d1920 1
a1920 1
     valueT *valuep;
a1922 2

  valueT value = *valuep;
d2093 1
a2093 1
     unsigned long insn;
@


1.9
log
@Fix GCC warnings.
Abort if code falls off end of md_estimate_size_before_relax().
@
text
@d1923 48
a1970 2
  /* We shouldn't ever get here because linkrelax is nonzero.  */
  abort ();
d1973 34
@


1.8
log
@Fix formatting.
@
text
@d662 1
a662 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d719 1
a719 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d765 1
a765 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d801 1
a801 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d1844 1
a1844 1
      reloc->sym_ptr_ptr = &bfd_abs_symbol;
d1899 1
@


1.7
log
@* config/tc-mn10300.c (md_assemble): Copy size to real_size before
it is modified, and use the real_size to compute the frag address
for dwarf2 line info.
@
text
@d24 1
a24 1
#include "subsegs.h"     
d37 2
a38 1
/* Generic assembler global variables which must be defined by all targets. */
d40 1
a40 1
/* Characters which always start a comment. */
d46 1
a46 1
/* Characters which may be used to separate multiple commands on a 
d50 1
a50 1
/* Characters which are used to indicate an exponent in a floating 
d54 1
a54 1
/* Characters which mean that a number is a floating point constant, 
a57 1

d59 1
a59 1
  /* bCC relaxing */
d64 1
a64 1
  /* bCC relaxing (uncommon cases) */
d69 1
a69 1
  /* call relaxing */
d73 1
a73 1
  /* calls relaxing */
d77 1
a77 1
  /* jmp relaxing */
d84 1
a84 1
/* local functions */
d100 1
a100 1
/* fixups */
d119 1
a119 1
size_t md_longopts_size = sizeof(md_longopts); 
d138 1
a138 1
/* This table is sorted. Suitable for searching by a binary search. */
d146 2
a147 1
#define DATA_REG_NAME_CNT	(sizeof(data_registers) / sizeof(struct reg_name))
d156 3
a158 1
#define ADDRESS_REG_NAME_CNT	(sizeof(address_registers) / sizeof(struct reg_name))
d203 3
a205 1
#define R_REG_NAME_CNT	(sizeof(r_registers) / sizeof(struct reg_name))
a230 1
#define XR_REG_NAME_CNT	(sizeof(xr_registers) / sizeof(struct reg_name))
d232 2
d241 3
a243 1
#define OTHER_REG_NAME_CNT	(sizeof(other_registers) / sizeof(struct reg_name))
d247 1
a247 1
   number from the array on success, or -1 on failure. */
d269 2
a270 2
      else 
	  return regs[middle].value;
a275 1

d286 1
d296 1
a296 1
  /* Find the spelling of the operand */
d302 2
a303 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d308 1
a308 1
      /* make the rest nice */
d311 3
a313 1
      *input_line_pointer = c;	/* put back the delimiting char */
d318 6
a323 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d338 1
d348 1
a348 1
  /* Find the spelling of the operand */
d354 2
a355 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d360 1
a360 1
      /* make the rest nice */
d363 3
a365 1
      *input_line_pointer = c;	/* put back the delimiting char */
d370 6
a375 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d390 1
d400 1
a400 1
  /* Find the spelling of the operand */
d406 2
a407 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d412 1
a412 1
      /* make the rest nice */
d415 3
a417 1
      *input_line_pointer = c;	/* put back the delimiting char */
d422 6
a427 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d442 1
d452 1
a452 1
  /* Find the spelling of the operand */
d458 2
a459 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d464 1
a464 1
      /* make the rest nice */
d467 3
a469 1
      *input_line_pointer = c;	/* put back the delimiting char */
d474 7
a480 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d495 1
d505 1
a505 1
  /* Find the spelling of the operand */
d511 2
a512 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d517 1
a517 1
      /* make the rest nice */
d520 3
a522 1
      *input_line_pointer = c;	/* put back the delimiting char */
d527 6
a532 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d539 1
a539 1
  FILE *stream;
d541 1
a541 1
  fprintf(stream, _("MN10300 options:\n\
d543 1
a543 1
} 
d555 1
a555 1
  char *name;
d562 3
a564 3
  int type;
  char *litp;
  int *sizep;
d585 1
a585 1
  
a600 1

d603 3
a605 3
  bfd *abfd;
  asection *sec;
  fragS *fragP;
d903 1
a903 1
  mn10300_hash = hash_new();
d913 1
a913 1
      if (strcmp (prev_name, op->name)) 
d934 1
a934 1
md_assemble (str) 
d948 1
a948 1
  for (s = str; *s != '\0' && ! isspace (*s); s++)
d953 2
a954 2
  /* find the first opcode with the proper name */
  opcode = (struct mn10300_opcode *)hash_find (mn10300_hash, str);
d967 1
a967 1
  for(;;)
a973 1

d1016 1
a1016 1
	  /* Gather the operand. */
d1211 1
a1211 1
	     
d1213 2
a1214 2
		 we accept it now so the compiler can emit "call" instructions
		 for all calls to named functions.
d1333 1
a1333 1
	  switch (ex.X_op) 
d1354 1
a1354 1
		
d1370 1
a1370 1
	      
a1374 1

d1386 1
a1386 1
		  && ! check_operand (insn, operand, ex.X_add_number))
d1462 1
a1462 1
        {
d1464 1
a1464 1
	  if (!strcmp(next_opcode->name, opcode->name))
d1469 1
a1469 1
	  
d1472 1
a1472 1
        }
d1475 1
a1475 1
      
d1524 1
a1524 1
      /* bCC */
d1539 1
a1539 1
      /* call */
d1541 2
a1542 2
        type = 6;
      /* calls */
d1545 1
a1545 1
      /* jmp */
d1548 1
a1548 1
      /* bCC (uncommon cases) */
d1556 1
a1556 1
      
d1657 1
d1663 3
a1665 2
	  unsigned long temp = ((insn & 0xffff) << 16)
	    			| ((extension >> 8) & 0xffff);
d1672 5
a1676 4
          unsigned long temp = ((insn & 0xff) << 16) | (extension & 0xffff);
          number_to_chars_bigendian (f, (insn >> 8) & 0xffffff, 3);
          number_to_chars_bigendian (f + 3, (temp & 0xff), 1);
          number_to_chars_littleendian (f + 4, temp >> 8, 2);
d1680 4
a1683 3
          unsigned long temp = ((insn & 0xff) << 24) | (extension & 0xffffff);
          number_to_chars_bigendian (f, (insn >> 8) & 0xffffff, 3);
          number_to_chars_littleendian (f + 3, temp, 4);
d1699 2
a1700 1
	      reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
d1703 2
a1704 2
		abort();
	  
d1708 1
a1708 1
		abort();
d1735 1
a1735 1
		 get the right offset for the 16/32 bit reloc in 
d1750 1
a1750 1
	
d1812 2
a1814 3
/* if while processing a fixup, a reloc really needs to be created */
/* then it is done here */
                 
d1827 2
a1828 2
                    _("reloc %d not supported by object file format"),
		    (int)fixp->fx_r_type);
d1835 1
a1835 1
    
d1848 1
a1848 1
  else 
d1850 1
a1850 1
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof( asymbol *));
d1899 1
a1899 1
} 
d1907 1
a1907 1
  if (fixp->fx_addsy != (symbolS *) NULL && ! S_IS_DEFINED (fixp->fx_addsy))
d1959 4
a1962 4
        {
          max = (1 << bits) - 1;
          min = 0;
        }
a1965 1

d1967 11
a1977 11
        {
          const char *err =
            _("operand out of range (%s not between %ld and %ld)");
          char buf[100];

          sprint_value (buf, test);
          if (file == (char *) NULL)
            as_warn (err, buf, min, max);
          else
            as_warn_where (file, line, err, buf, min, max);
        }
d2037 4
a2040 4
        {
          max = (1 << bits) - 1;
          min = 0;
        }
a2042 1

@


1.6
log
@* config/tc-mn10300.h (md_end): Define.
(mn10300_finalize): Declare.
* config/tc-mn10300.c: Include dwarf2dbg.h.
(debug_line): Define.
(md_assemble): Generate dwarf2 line info.
(mn10300_finalize): New function.  Finalize dwarf2 info.
@
text
@d905 1
a905 1
  unsigned long insn, extension, size = 0;
d1483 2
d1765 1
a1765 1
      addr = frag_now->fr_address + frag_now_fix () - size;
@


1.5
log
@* config/tc-mn10300.c (HAVE_AM30): Define.
(md_assemble): Use it.
@
text
@d26 1
d35 2
d124 2
d1753 15
d2021 7
@


1.4
log
@* config/tc-mn10300.c (md_pseudo_table): Use constant names.
(md_begin): Likewise.
(HAVE_AM33): New macro.
(md_assemble): Use it.  Match r_regs and xr_regs only if
HAVE_AM33.
@
text
@d128 1
d948 2
a949 1
	  && !(opcode->machine == AM33 && HAVE_AM33))
@


1.3
log
@       * config/tc-mn10300.c (md_pseudo_table): Add ".am33" pseudo-op.
        (r_registers, xr_registers): Define.
        (r_register_name, xr_register_name): New functions.
        (md_assemble): Handle new am33 operand types and instruction
        formats.
        (mn10300_insert_operand, check_operand): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
d121 3
a123 3
  { "am30",	set_arch_mach,		300 },
  { "am33",	set_arch_mach,		330 },
  { "mn10300",	set_arch_mach,		300 },
d127 2
d884 1
a884 1
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_mn10300, 300))
d887 1
a887 1
  current_machine = 300;
d947 1
a947 1
	  && (opcode->machine != current_machine))
d1212 1
a1212 1
		  else if (current_machine == 330
d1218 1
a1218 1
		  else if (current_machine == 330
d1224 1
a1224 1
		  else if (current_machine == 330
d1230 1
a1230 1
		  else if (current_machine == 330
d1267 1
a1267 1
	  else if (r_register_name (&ex))
d1273 1
a1273 1
	  else if (xr_register_name (&ex))
d1303 2
a1304 1
		mask |= MN10300_OPERAND_RREG | MN10300_OPERAND_XRREG;
@


1.3.2.1
log
@* config/tc-mn10300.c (md_pseudo_table): Use constant names.
(md_begin): Likewise.
(HAVE_AM33): New macro.
(md_assemble): Use it.  Match r_regs and xr_regs only if
HAVE_AM33.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation.
d121 3
a123 3
  { "am30",	set_arch_mach,		AM30 },
  { "am33",	set_arch_mach,		AM33 },
  { "mn10300",	set_arch_mach,		MN103 },
a126 2
#define HAVE_AM33 (current_machine == AM33)

d882 1
a882 1
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_mn10300, MN103))
d885 1
a885 1
  current_machine = MN103;
d945 1
a945 1
	  && !(opcode->machine == AM33 && HAVE_AM33))
d1210 1
a1210 1
		  else if (HAVE_AM33
d1216 1
a1216 1
		  else if (HAVE_AM33
d1222 1
a1222 1
		  else if (HAVE_AM33
d1228 1
a1228 1
		  else if (HAVE_AM33
d1265 1
a1265 1
	  else if (HAVE_AM33 && r_register_name (&ex))
d1271 1
a1271 1
	  else if (HAVE_AM33 && xr_register_name (&ex))
d1301 1
a1301 2
		if (HAVE_AM33)
		  mask |= MN10300_OPERAND_RREG | MN10300_OPERAND_XRREG;
@


1.3.2.2
log
@* config/tc-mn10300.c (HAVE_AM30): Define.
(md_assemble): Use it.
@
text
@a127 1
#define HAVE_AM30 (current_machine == AM30)
d947 1
a947 2
	  && !(opcode->machine == AM33 && HAVE_AM33)
	  && !(opcode->machine == AM30 && HAVE_AM30))
@


1.2
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d122 1
d149 71
d261 91
d1020 104
d1210 24
d1265 12
d1301 1
d1318 4
d1449 11
d1544 3
d1621 13
d1674 2
d1884 2
d1921 6
d1963 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2

   Copyright (C) 1996, 1997, 1998 Free Software Foundation.
d1447 2
a1448 1
      reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

