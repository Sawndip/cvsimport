head	1.118;
access;
symbols
	binutils-2_24-branch:1.118.0.2
	binutils-2_24-branchpoint:1.118
	binutils-2_21_1:1.115
	binutils-2_23_2:1.116
	binutils-2_23_1:1.116
	binutils-2_23:1.116
	binutils-2_23-branch:1.116.0.2
	binutils-2_23-branchpoint:1.116
	binutils-2_22_branch:1.115.0.6
	binutils-2_22:1.115
	binutils-2_22-branch:1.115.0.4
	binutils-2_22-branchpoint:1.115
	binutils-2_21:1.115
	binutils-2_21-branch:1.115.0.2
	binutils-2_21-branchpoint:1.115
	binutils-2_20_1:1.111
	binutils-2_20:1.111
	binutils-arc-20081103-branch:1.106.0.4
	binutils-arc-20081103-branchpoint:1.106
	binutils-2_20-branch:1.111.0.2
	binutils-2_20-branchpoint:1.111
	dje-cgen-play1-branch:1.109.0.2
	dje-cgen-play1-branchpoint:1.109
	arc-20081103-branch:1.106.0.2
	arc-20081103-branchpoint:1.106
	binutils-2_19_1:1.104
	binutils-2_19:1.104
	binutils-2_19-branch:1.104.0.2
	binutils-2_19-branchpoint:1.104
	binutils-2_18:1.94
	binutils-2_18-branch:1.94.0.2
	binutils-2_18-branchpoint:1.94
	binutils-csl-coldfire-4_1-32:1.72.2.10
	binutils-csl-sourcerygxx-4_1-32:1.72.2.10
	binutils-csl-innovasic-fido-3_4_4-33:1.72.2.10
	binutils-csl-sourcerygxx-3_4_4-32:1.62.2.1
	binutils-csl-coldfire-4_1-30:1.72.2.9
	binutils-csl-sourcerygxx-4_1-30:1.72.2.9
	binutils-csl-coldfire-4_1-28:1.72.2.9
	binutils-csl-sourcerygxx-4_1-29:1.72.2.10
	binutils-csl-sourcerygxx-4_1-28:1.72.2.9
	binutils-csl-arm-2006q3-27:1.72.2.8
	binutils-csl-sourcerygxx-4_1-27:1.72.2.8
	binutils-csl-arm-2006q3-26:1.72.2.8
	binutils-csl-sourcerygxx-4_1-26:1.72.2.8
	binutils-csl-sourcerygxx-4_1-25:1.72.2.7
	binutils-csl-sourcerygxx-4_1-24:1.72.2.6
	binutils-csl-sourcerygxx-4_1-23:1.72.2.6
	binutils-csl-sourcerygxx-4_1-21:1.72.2.6
	binutils-csl-arm-2006q3-21:1.72.2.6
	binutils-csl-sourcerygxx-4_1-22:1.72.2.6
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.72.2.6
	binutils-csl-sourcerygxx-4_1-20:1.72.2.6
	binutils-csl-arm-2006q3-19:1.72.2.6
	binutils-csl-sourcerygxx-4_1-19:1.72.2.6
	binutils-csl-sourcerygxx-4_1-18:1.72.2.5
	binutils-csl-renesas-4_1-9:1.72.2.5
	binutils-csl-sourcerygxx-3_4_4-25:1.62.2.1
	binutils-csl-renesas-4_1-8:1.72.2.5
	binutils-csl-renesas-4_1-7:1.72.2.5
	binutils-csl-renesas-4_1-6:1.72.2.5
	binutils-csl-sourcerygxx-4_1-17:1.72.2.5
	binutils-csl-sourcerygxx-4_1-14:1.72.2.5
	binutils-csl-sourcerygxx-4_1-15:1.72.2.5
	binutils-csl-sourcerygxx-4_1-13:1.72.2.5
	binutils-2_17:1.75.2.1
	binutils-csl-sourcerygxx-4_1-12:1.72.2.5
	binutils-csl-sourcerygxx-3_4_4-21:1.72.2.5
	binutils-csl-wrs-linux-3_4_4-24:1.62.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.62.2.1
	binutils-csl-sourcerygxx-4_1-9:1.72.2.5
	binutils-csl-sourcerygxx-4_1-8:1.72.2.5
	binutils-csl-sourcerygxx-4_1-7:1.72.2.5
	binutils-csl-arm-2006q1-6:1.72.2.5
	binutils-csl-sourcerygxx-4_1-6:1.72.2.5
	binutils-csl-wrs-linux-3_4_4-22:1.62.2.1
	binutils-csl-coldfire-4_1-11:1.72.2.4
	binutils-csl-sourcerygxx-3_4_4-19:1.72.2.4
	binutils-csl-coldfire-4_1-10:1.72.2.4
	binutils-csl-sourcerygxx-4_1-5:1.72.2.4
	binutils-csl-sourcerygxx-4_1-4:1.72.2.4
	binutils-csl-wrs-linux-3_4_4-21:1.62.2.1
	binutils-csl-morpho-4_1-4:1.72.2.4
	binutils-csl-sourcerygxx-3_4_4-17:1.72.2.4
	binutils-csl-wrs-linux-3_4_4-20:1.62.2.1
	binutils-2_17-branch:1.75.0.2
	binutils-2_17-branchpoint:1.75
	binutils-csl-2_17-branch:1.72.0.2
	binutils-csl-2_17-branchpoint:1.72
	binutils-csl-gxxpro-3_4-branch:1.62.2.1.0.4
	binutils-csl-gxxpro-3_4-branchpoint:1.62.2.1
	binutils-2_16_1:1.62.2.1
	binutils-csl-arm-2005q1b:1.62.2.1
	binutils-2_16:1.62.2.1
	binutils-csl-arm-2005q1a:1.62.2.1
	binutils-csl-arm-2005q1-branch:1.62.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.62.2.1
	binutils-2_16-branch:1.62.0.2
	binutils-2_16-branchpoint:1.62
	csl-arm-2004-q3d:1.60
	csl-arm-2004-q3:1.58
	binutils-2_15:1.49
	binutils-2_15-branchpoint:1.49
	csl-arm-2004-q1a:1.50
	csl-arm-2004-q1:1.49
	binutils-2_15-branch:1.49.0.4
	cagney_bfdfile-20040213-branch:1.49.0.2
	cagney_bfdfile-20040213-branchpoint:1.49
	cagney_bigcore-20040122-branch:1.48.0.2
	cagney_bigcore-20040122-branchpoint:1.48
	csl-arm-2003-q4:1.48
	binutils-2_14:1.43
	binutils-2_14-branch:1.43.0.2
	binutils-2_14-branchpoint:1.43
	binutils-2_13_2_1:1.39.2.1
	binutils-2_13_2:1.39.2.1
	binutils-2_13_1:1.39.2.1
	binutils-2_13:1.39
	binutils-2_13-branchpoint:1.39
	binutils-2_13-branch:1.39.0.2
	binutils-2_12_1:1.36.2.1
	binutils-2_12:1.36.2.1
	binutils-2_12-branch:1.36.0.2
	binutils-2_12-branchpoint:1.36
	cygnus_cvs_20020108_pre:1.36
	binutils-2_11_2:1.17.2.2
	binutils-2_11_1:1.17.2.2
	binutils-2_11:1.17
	x86_64versiong3:1.17
	binutils-2_11-branch:1.17.0.2
	binutils-2_10_1:1.5.2.1
	binutils-2_10:1.5.2.1
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.118
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.5
	binu_ss_19990602:1.3
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.118
date	2013.06.13.08.53.35;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	2012.11.05.07.10.37;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2012.05.16.10.26.47;	author nathan;	state Exp;
branches;
next	1.115;

1.115
date	2010.09.09.10.48.17;	author nickc;	state Exp;
branches;
next	1.114;

1.114
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2009.11.10.18.05.23;	author mkuvyrkov;	state Exp;
branches;
next	1.112;

1.112
date	2009.10.13.08.55.30;	author nickc;	state Exp;
branches;
next	1.111;

1.111
date	2009.07.27.20.07.00;	author mkuvyrkov;	state Exp;
branches;
next	1.110;

1.110
date	2009.07.27.20.05.03;	author mkuvyrkov;	state Exp;
branches;
next	1.109;

1.109
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	2009.02.12.08.31.02;	author nathan;	state Exp;
branches;
next	1.107;

1.107
date	2009.02.03.14.36.46;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2008.10.21.00.26.17;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2008.10.20.01.03.50;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2008.07.08.06.33.41;	author nathan;	state Exp;
branches;
next	1.102;

1.102
date	2008.03.28.09.51.13;	author nathan;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.18.13.03.12;	author nickc;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.99;

1.99
date	2007.09.27.11.14.09;	author kazu;	state Exp;
branches;
next	1.98;

1.98
date	2007.09.25.15.31.05;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2007.09.11.16.07.50;	author kazu;	state Exp;
branches;
next	1.96;

1.96
date	2007.08.28.13.43.06;	author kazu;	state Exp;
branches;
next	1.95;

1.95
date	2007.08.28.13.36.35;	author kazu;	state Exp;
branches;
next	1.94;

1.94
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2007.07.03.07.54.18;	author nathan;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.17.13.10.42;	author nathan;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.15.09.21.23;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.03.15.55.38;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.23.07.51.26;	author nathan;	state Exp;
branches;
next	1.88;

1.88
date	2007.04.20.14.41.38;	author nathan;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.20.14.08.59;	author nathan;	state Exp;
branches;
next	1.86;

1.86
date	2007.04.04.22.10.34;	author kazu;	state Exp;
branches;
next	1.85;

1.85
date	2007.03.16.18.08.58;	author kazu;	state Exp;
branches;
next	1.84;

1.84
date	2007.02.20.09.25.45;	author nathan;	state Exp;
branches;
next	1.83;

1.83
date	2007.02.15.18.37.08;	author nathan;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.08.18.42.37;	author kazu;	state Exp;
branches;
next	1.81;

1.81
date	2006.12.27.07.15.02;	author kazu;	state Exp;
branches;
next	1.80;

1.80
date	2006.12.25.22.39.21;	author kazu;	state Exp;
branches;
next	1.79;

1.79
date	2006.12.07.15.39.01;	author kazu;	state Exp;
branches;
next	1.78;

1.78
date	2006.11.16.07.22.24;	author nathan;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.19.11.26.11;	author ths;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.19.10.18.02;	author nathan;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.28.07.21.49;	author nathan;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2006.03.28.07.19.16;	author nathan;	state Exp;
branches;
next	1.73;

1.73
date	2006.03.25.10.24.27;	author rsandifo;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.06.13.42.04;	author nathan;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2006.02.07.19.01.09;	author nathan;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.20.18.24.47;	author rth;	state Exp;
branches;
next	1.69;

1.69
date	2005.08.11.01.25.27;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2005.06.08.17.02.54;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.05.09.12.59;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.10.16.28.08;	author hjl;	state Exp;
branches;
next	1.64;

1.64
date	2005.03.21.02.25.23;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.18.17.20.33;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.01.01.57.39;	author amodra;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2005.02.17.13.46.03;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.03.01.54.25;	author hp;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.08.08.45.54;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2004.09.30.17.08.50;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2004.08.17.12.19.57;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2004.07.11.15.20.30;	author schwab;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.20.19.33.29;	author schwab;	state Exp;
branches;
next	1.54;

1.54
date	2004.05.28.07.55.20;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.27.07.56.27;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.24.14.33.18;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.05.14.33.14;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.22.10.33.15;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.26.18.09.30;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.21.13.28.59;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.17.10.50.27;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2003.08.08.14.46.41;	author schwab;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2002.12.12.22.16.16;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.09.19.14.52.15;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2002.05.08.01.54.04;	author kazu;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.13.18.14.46;	author thorpej;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.06.12.15.45;	author amodra;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2002.01.02.17.19.07;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.16.09.34.28;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.15.21.28.56;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2001.10.16.14.27.03;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.19.05.33.25;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.23.14.02.12;	author kazu;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.23.13.03.39;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.18.10.25.57;	author schwab;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.06.08.21.35;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.21.06.12.11;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.12.10.35.21;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.06.14.28.00;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.27.11.57.25;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.22.09.01.55;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.08.18.03.27;	author schwab;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.08.13.13.56;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.06.20.12.20;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.25.20.26.17;	author nickc;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.18.19.26.57;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.18.17.42.27;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.26.07.09.18;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.22.17.33.55;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.11.19.49.46;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.31.22.08.14;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.09.00.00.03;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.08.10.24.06;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	99.07.12.08.34.56;	author schwab;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.06.03.00.29.32;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.27.22.36.51;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.05.10.58.59;	author clm;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.75.2.1
date	2006.05.25.13.41.16;	author nathan;	state Exp;
branches;
next	;

1.72.2.1
date	2006.03.21.09.51.28;	author rsandifo;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2006.03.21.10.20.17;	author nathan;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2006.03.21.10.37.27;	author nathan;	state Exp;
branches;
next	1.72.2.4;

1.72.2.4
date	2006.03.26.16.12.21;	author nathan;	state Exp;
branches;
next	1.72.2.5;

1.72.2.5
date	2006.05.25.13.12.42;	author nathan;	state Exp;
branches;
next	1.72.2.6;

1.72.2.6
date	2006.09.11.11.34.51;	author nathan;	state Exp;
branches;
next	1.72.2.7;

1.72.2.7
date	2006.10.13.07.39.34;	author nathan;	state Exp;
branches;
next	1.72.2.8;

1.72.2.8
date	2006.10.30.19.46.09;	author kazu;	state Exp;
branches;
next	1.72.2.9;

1.72.2.9
date	2006.11.17.14.21.51;	author kazu;	state Exp;
branches;
next	1.72.2.10;

1.72.2.10
date	2006.11.30.14.49.43;	author kazu;	state Exp;
branches;
next	;

1.62.2.1
date	2005.03.21.02.50.15;	author amodra;	state Exp;
branches;
next	;

1.39.2.1
date	2002.10.28.18.45.48;	author drow;	state Exp;
branches;
next	;

1.36.2.1
date	2002.02.13.19.16.45;	author thorpej;	state Exp;
branches;
next	;

1.17.2.1
date	2001.06.07.03.15.31;	author amodra;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.06.11.10.04.48;	author amodra;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2001.07.21.13.43.26;	author schwab;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2001.09.19.10.58.37;	author schwab;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2001.10.16.14.31.43;	author amodra;	state Exp;
branches;
next	;

1.5.2.1
date	2000.05.08.10.31.20;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.118
log
@	PR gas/15602
	* config/tc-m68k.h (TC_CHECK_ADJUSTED_BROKEN_DOT_WORD): Define.
	* config/tc-m68k.c (tc_m68k_check_adjusted_broken_word): New
	function.  Generates an error if the adjusted offset is out of a
	16-bit range.
@
text
@/* tc-m68k.c -- Assemble for the m68k family
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"
#include "subsegs.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"

#include "opcode/m68k.h"
#include "m68k-parse.h"

#if defined (OBJ_ELF)
#include "elf/m68k.h"
#endif

#ifdef M68KCOFF
#include "obj-coff.h"
#endif

#ifdef OBJ_ELF
static void m68k_elf_cons (int);
#endif

/* This string holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  The macro
   tc_comment_chars points to this.  We use this, rather than the
   usual comment_chars, so that the --bitwise-or option will work.  */
#if defined (TE_SVR4) || defined (TE_DELTA)
const char *m68k_comment_chars = "|#";
#else
const char *m68k_comment_chars = "|";
#endif

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#*";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant, as
   in "0f12.456" or "0d1.2345e12".  */

const char FLT_CHARS[] = "rRsSfFdDxXeEpP";

/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c .  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.  */

/* Are we trying to generate PIC code?  If so, absolute references
   ought to be made into linkage table references or pc-relative
   references.  Not implemented.  For ELF there are other means
   to denote pic relocations.  */
int flag_want_pic;

static int flag_short_refs;	/* -l option.  */
static int flag_long_jumps;	/* -S option.  */
static int flag_keep_pcrel;	/* --pcrel option.  */

#ifdef REGISTER_PREFIX_OPTIONAL
int flag_reg_prefix_optional = REGISTER_PREFIX_OPTIONAL;
#else
int flag_reg_prefix_optional;
#endif

/* Whether --register-prefix-optional was used on the command line.  */
static int reg_prefix_optional_seen;

/* The floating point coprocessor to use by default.  */
static enum m68k_register m68k_float_copnum = COP1;

/* If this is non-zero, then references to number(%pc) will be taken
   to refer to number, rather than to %pc + number.  */
static int m68k_abspcadd;

/* If this is non-zero, then the quick forms of the move, add, and sub
   instructions are used when possible.  */
static int m68k_quick = 1;

/* If this is non-zero, then if the size is not specified for a base
   or outer displacement, the assembler assumes that the size should
   be 32 bits.  */
static int m68k_rel32 = 1;

/* This is non-zero if m68k_rel32 was set from the command line.  */
static int m68k_rel32_from_cmdline;

/* The default width to use for an index register when using a base
   displacement.  */
static enum m68k_size m68k_index_width_default = SIZE_LONG;

/* We want to warn if any text labels are misaligned.  In order to get
   the right line number, we need to record the line number for each
   label.  */
struct label_line
{
  struct label_line *next;
  symbolS *label;
  char *file;
  unsigned int line;
  int text;
};

/* The list of labels.  */

static struct label_line *labels;

/* The current label.  */

static struct label_line *current_label;

/* Pointer to list holding the opcodes sorted by name.  */
static struct m68k_opcode const ** m68k_sorted_opcodes;

/* Its an arbitrary name:  This means I don't approve of it.
   See flames below.  */
static struct obstack robyn;

struct m68k_incant
  {
    const char *m_operands;
    unsigned long m_opcode;
    short m_opnum;
    short m_codenum;
    int m_arch;
    struct m68k_incant *m_next;
  };

#define getone(x)	((((x)->m_opcode)>>16)&0xffff)
#define gettwo(x)	(((x)->m_opcode)&0xffff)

static const enum m68k_register m68000_ctrl[] = { 0 };
static const enum m68k_register m68010_ctrl[] = {
  SFC, DFC, USP, VBR,
  0
};
static const enum m68k_register m68020_ctrl[] = {
  SFC, DFC, USP, VBR, CACR, CAAR, MSP, ISP,
  0
};
static const enum m68k_register m68040_ctrl[] = {
  SFC, DFC, CACR, TC, ITT0, ITT1, DTT0, DTT1,
  USP, VBR, MSP, ISP, MMUSR, URP, SRP,
  0
};
static const enum m68k_register m68060_ctrl[] = {
  SFC, DFC, CACR, TC, ITT0, ITT1, DTT0, DTT1, BUSCR,
  USP, VBR, URP, SRP, PCR,
  0
};
static const enum m68k_register mcf_ctrl[] = {
  CACR, TC, ACR0, ACR1, ACR2, ACR3, VBR, ROMBAR,
  RAMBAR0, RAMBAR1, RAMBAR, MBAR,
  0
};
static const enum m68k_register mcf51_ctrl[] = {
  VBR, CPUCR,
  0
};
static const enum m68k_register mcf5206_ctrl[] = {
  CACR, ACR0, ACR1, VBR, RAMBAR0, RAMBAR_ALT, MBAR,
  0
};
static const enum m68k_register mcf5208_ctrl[] = {
  CACR, ACR0, ACR1, VBR,  RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5210a_ctrl[] = {
  VBR, CACR, ACR0, ACR1, ROMBAR, RAMBAR, RAMBAR1, MBAR,
  0
};
static const enum m68k_register mcf5213_ctrl[] = {
  VBR, RAMBAR, RAMBAR1, FLASHBAR,
  0
};
static const enum m68k_register mcf5216_ctrl[] = {
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5221x_ctrl[] = {
  VBR, FLASHBAR, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf52223_ctrl[] = {
  VBR, FLASHBAR, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf52235_ctrl[] = {
  VBR, FLASHBAR, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5225_ctrl[] = {
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, MBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf52259_ctrl[] = {
  VBR, FLASHBAR, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf52277_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5235_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5249_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR0, RAMBAR1, RAMBAR, MBAR, MBAR2,
  0
};
static const enum m68k_register mcf5250_ctrl[] = {
  VBR,
  0
};
static const enum m68k_register mcf5253_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR0, RAMBAR1, RAMBAR, MBAR, MBAR2,
  0
};
static const enum m68k_register mcf5271_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5272_ctrl[] = {
  VBR, CACR, ACR0, ACR1, ROMBAR, RAMBAR_ALT, RAMBAR0, MBAR,
  0
};
static const enum m68k_register mcf5275_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5282_ctrl[] = {
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf53017_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5307_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR0, RAMBAR_ALT, MBAR,
  0
};
static const enum m68k_register mcf5329_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcf5373_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
  0
};
static const enum m68k_register mcfv4e_ctrl[] = {
  CACR, ASID, ACR0, ACR1, ACR2, ACR3, MMUBAR,
  VBR, PC, ROMBAR0, ROMBAR1, RAMBAR0, RAMBAR1,
  MBAR, SECMBAR,
  MPCR /* Multiprocessor Control register */,
  EDRAMBAR /* Embedded DRAM Base Address Register */,
  /* Permutation control registers.  */
  PCR1U0, PCR1L0, PCR1U1, PCR1L1, PCR2U0, PCR2L0, PCR2U1, PCR2L1,
  PCR3U0, PCR3L0, PCR3U1, PCR3L1,
  /* Legacy names */
  TC /* ASID */, BUSCR /* MMUBAR */,
  ITT0 /* ACR0 */, ITT1 /* ACR1 */, DTT0 /* ACR2 */, DTT1 /* ACR3 */,
  MBAR1 /* MBAR */, MBAR2 /* SECMBAR */, MBAR0 /* SECMBAR */,
  ROMBAR /* ROMBAR0 */, RAMBAR /* RAMBAR1 */,
  0
};
static const enum m68k_register mcf5407_ctrl[] = {
  CACR, ASID, ACR0, ACR1, ACR2, ACR3,
  VBR, PC, RAMBAR0, RAMBAR1, MBAR,
  /* Legacy names */
  TC /* ASID */,
  ITT0 /* ACR0 */, ITT1 /* ACR1 */, DTT0 /* ACR2 */, DTT1 /* ACR3 */,
  MBAR1 /* MBAR */, RAMBAR /* RAMBAR1 */,
  0
};
static const enum m68k_register mcf54418_ctrl[] = {
  CACR, ASID, ACR0, ACR1, ACR2, ACR3, ACR4, ACR5, ACR6, ACR7, MMUBAR, RGPIOBAR,
  VBR, PC, RAMBAR1,
  /* Legacy names */
  TC /* ASID */, BUSCR /* MMUBAR */,
  ITT0 /* ACR0 */, ITT1 /* ACR1 */, DTT0 /* ACR2 */, DTT1 /* ACR3 */,
  RAMBAR /* RAMBAR1 */,
  0
};
static const enum m68k_register mcf54455_ctrl[] = {
  CACR, ASID, ACR0, ACR1, ACR2, ACR3, MMUBAR,
  VBR, PC, RAMBAR1,
  /* Legacy names */
  TC /* ASID */, BUSCR /* MMUBAR */,
  ITT0 /* ACR0 */, ITT1 /* ACR1 */, DTT0 /* ACR2 */, DTT1 /* ACR3 */,
  RAMBAR /* RAMBAR1 */,
  0
};
static const enum m68k_register mcf5475_ctrl[] = {
  CACR, ASID, ACR0, ACR1, ACR2, ACR3, MMUBAR,
  VBR, PC, RAMBAR0, RAMBAR1, MBAR,
  /* Legacy names */
  TC /* ASID */, BUSCR /* MMUBAR */,
  ITT0 /* ACR0 */, ITT1 /* ACR1 */, DTT0 /* ACR2 */, DTT1 /* ACR3 */,
  MBAR1 /* MBAR */, RAMBAR /* RAMBAR1 */,
  0
};
static const enum m68k_register mcf5485_ctrl[] = {
  CACR, ASID, ACR0, ACR1, ACR2, ACR3, MMUBAR,
  VBR, PC, RAMBAR0, RAMBAR1, MBAR,
  /* Legacy names */
  TC /* ASID */, BUSCR /* MMUBAR */,
  ITT0 /* ACR0 */, ITT1 /* ACR1 */, DTT0 /* ACR2 */, DTT1 /* ACR3 */,
  MBAR1 /* MBAR */, RAMBAR /* RAMBAR1 */,
  0
};
static const enum m68k_register fido_ctrl[] = {
  SFC, DFC, USP, VBR, CAC, MBO,
  0
};
#define cpu32_ctrl m68010_ctrl

static const enum m68k_register *control_regs;

/* Internal form of a 68020 instruction.  */
struct m68k_it
{
  const char *error;
  const char *args;		/* List of opcode info.  */
  int numargs;

  int numo;			/* Number of shorts in opcode.  */
  short opcode[11];

  struct m68k_op operands[6];

  int nexp;			/* Number of exprs in use.  */
  struct m68k_exp exprs[4];

  int nfrag;			/* Number of frags we have to produce.  */
  struct
    {
      int fragoff;		/* Where in the current opcode the frag ends.  */
      symbolS *fadd;
      offsetT foff;
      int fragty;
    }
  fragb[4];

  int nrel;			/* Num of reloc strucs in use.  */
  struct
    {
      int n;
      expressionS exp;
      char wid;
      char pcrel;
      /* In a pc relative address the difference between the address
	 of the offset and the address that the offset is relative
	 to.  This depends on the addressing mode.  Basically this
	 is the value to put in the offset field to address the
	 first byte of the offset, without regarding the special
	 significance of some values (in the branch instruction, for
	 example).  */
      int pcrel_fix;
#ifdef OBJ_ELF
      /* Whether this expression needs special pic relocation, and if
	 so, which.  */
      enum pic_relocation pic_reloc;
#endif
    }
  reloc[5];			/* Five is enough???  */
};

#define cpu_of_arch(x)		((x) & (m68000up | mcfisa_a | fido_a))
#define float_of_arch(x)	((x) & mfloat)
#define mmu_of_arch(x)		((x) & mmmu)
#define arch_coldfire_p(x)	((x) & mcfisa_a)
#define arch_coldfire_fpu(x)	((x) & cfloat)

/* Macros for determining if cpu supports a specific addressing mode.  */
#define HAVE_LONG_DISP(x)	\
	((x) & (m68020|m68030|m68040|m68060|cpu32|fido_a|mcfisa_b|mcfisa_c))
#define HAVE_LONG_CALL(x)	\
	((x) & (m68020|m68030|m68040|m68060|cpu32|fido_a|mcfisa_b|mcfisa_c))
#define HAVE_LONG_COND(x)	\
	((x) & (m68020|m68030|m68040|m68060|cpu32|fido_a|mcfisa_b|mcfisa_c))
#define HAVE_LONG_BRANCH(x)	\
	((x) & (m68020|m68030|m68040|m68060|cpu32|fido_a|mcfisa_b))
#define LONG_BRANCH_VIA_COND(x) (HAVE_LONG_COND(x) && !HAVE_LONG_BRANCH(x))

static struct m68k_it the_ins;	/* The instruction being assembled.  */

#define op(ex)		((ex)->exp.X_op)
#define adds(ex)	((ex)->exp.X_add_symbol)
#define subs(ex)	((ex)->exp.X_op_symbol)
#define offs(ex)	((ex)->exp.X_add_number)

/* Macros for adding things to the m68k_it struct.  */
#define addword(w)	(the_ins.opcode[the_ins.numo++] = (w))

/* Like addword, but goes BEFORE general operands.  */

static void
insop (int w, const struct m68k_incant *opcode)
{
  int z;
  for (z = the_ins.numo; z > opcode->m_codenum; --z)
    the_ins.opcode[z] = the_ins.opcode[z - 1];
  for (z = 0; z < the_ins.nrel; z++)
    the_ins.reloc[z].n += 2;
  for (z = 0; z < the_ins.nfrag; z++)
    the_ins.fragb[z].fragoff++;
  the_ins.opcode[opcode->m_codenum] = w;
  the_ins.numo++;
}

/* The numo+1 kludge is so we can hit the low order byte of the prev word.
   Blecch.  */
static void
add_fix (int width, struct m68k_exp *exp, int pc_rel, int pc_fix)
{
  the_ins.reloc[the_ins.nrel].n = (width == 'B' || width == '3'
				   ? the_ins.numo * 2 - 1
				   : (width == 'b'
				      ? the_ins.numo * 2 + 1
				      : the_ins.numo * 2));
  the_ins.reloc[the_ins.nrel].exp = exp->exp;
  the_ins.reloc[the_ins.nrel].wid = width;
  the_ins.reloc[the_ins.nrel].pcrel_fix = pc_fix;
#ifdef OBJ_ELF
  the_ins.reloc[the_ins.nrel].pic_reloc = exp->pic_reloc;
#endif
  the_ins.reloc[the_ins.nrel++].pcrel = pc_rel;
}

/* Cause an extra frag to be generated here, inserting up to 10 bytes
   (that value is chosen in the frag_var call in md_assemble).  TYPE
   is the subtype of the frag to be generated; its primary type is
   rs_machine_dependent.

   The TYPE parameter is also used by md_convert_frag_1 and
   md_estimate_size_before_relax.  The appropriate type of fixup will
   be emitted by md_convert_frag_1.

   ADD becomes the FR_SYMBOL field of the frag, and OFF the FR_OFFSET.  */
static void
add_frag (symbolS *add, offsetT off, int type)
{
  the_ins.fragb[the_ins.nfrag].fragoff = the_ins.numo;
  the_ins.fragb[the_ins.nfrag].fadd = add;
  the_ins.fragb[the_ins.nfrag].foff = off;
  the_ins.fragb[the_ins.nfrag++].fragty = type;
}

#define isvar(ex) \
  (op (ex) != O_constant && op (ex) != O_big)

static char *crack_operand (char *str, struct m68k_op *opP);
static int get_num (struct m68k_exp *exp, int ok);
static int reverse_16_bits (int in);
static int reverse_8_bits (int in);
static void install_gen_operand (int mode, int val);
static void install_operand (int mode, int val);
static void s_bss (int);
static void s_data1 (int);
static void s_data2 (int);
static void s_even (int);
static void s_proc (int);
static void s_chip (int);
static void s_fopt (int);
static void s_opt (int);
static void s_reg (int);
static void s_restore (int);
static void s_save (int);
static void s_mri_if (int);
static void s_mri_else (int);
static void s_mri_endi (int);
static void s_mri_break (int);
static void s_mri_next (int);
static void s_mri_for (int);
static void s_mri_endf (int);
static void s_mri_repeat (int);
static void s_mri_until (int);
static void s_mri_while (int);
static void s_mri_endw (int);
static void s_m68k_cpu (int);
static void s_m68k_arch (int);

struct m68k_cpu
{
  unsigned long arch;	/* Architecture features.  */
  const enum m68k_register *control_regs;	/* Control regs on chip */
  const char *name;	/* Name */
  int alias;       	/* Alias for a cannonical name.  If 1, then
			   succeeds canonical name, if -1 then
			   succeeds canonical name, if <-1 ||>1 this is a
			   deprecated name, and the next/previous name
			   should be used. */
};

/* We hold flags for features explicitly enabled and explicitly
   disabled.  */
static int current_architecture;
static int not_current_architecture;
static const struct m68k_cpu *selected_arch;
static const struct m68k_cpu *selected_cpu;
static int initialized;

/* Architecture models.  */
static const struct m68k_cpu m68k_archs[] =
{
  {m68000,					m68000_ctrl, "68000", 0},
  {m68010,					m68010_ctrl, "68010", 0},
  {m68020|m68881|m68851,			m68020_ctrl, "68020", 0},
  {m68030|m68881|m68851,			m68020_ctrl, "68030", 0},
  {m68040,					m68040_ctrl, "68040", 0},
  {m68060,					m68060_ctrl, "68060", 0},
  {cpu32|m68881,				cpu32_ctrl, "cpu32", 0},
  {fido_a,					fido_ctrl, "fidoa", 0},
  {mcfisa_a|mcfhwdiv,				NULL, "isaa", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_aa|mcfusp,		NULL, "isaaplus", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b|mcfusp,		NULL, "isab", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_c|mcfusp,		NULL, "isac", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac|mcfusp,	mcf_ctrl, "cfv4", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "cfv4e", 0},
  {0,0,NULL, 0}
};

/* For -mno-mac we want to turn off all types of mac.  */
static const unsigned no_mac = mcfmac | mcfemac;

/* Architecture extensions, here 'alias' -1 for m68k, +1 for cf and 0
   for either.  */
static const struct m68k_cpu m68k_extensions[] =
{
  {m68851,					NULL, "68851", -1},
  {m68881,					NULL, "68881", -1},
  {m68881,					NULL, "68882", -1},

  {cfloat|m68881,				NULL, "float", 0},

  {mcfhwdiv,					NULL, "div", 1},
  {mcfusp,					NULL, "usp", 1},
  {mcfmac,					(void *)&no_mac, "mac", 1},
  {mcfemac,					NULL, "emac", 1},

  {0,NULL,NULL, 0}
};

/* Processor list */
static const struct m68k_cpu m68k_cpus[] =
{
  {m68000,					m68000_ctrl, "68000", 0},
  {m68000,					m68000_ctrl, "68ec000", 1},
  {m68000,					m68000_ctrl, "68hc000", 1},
  {m68000,					m68000_ctrl, "68hc001", 1},
  {m68000,					m68000_ctrl, "68008", 1},
  {m68000,					m68000_ctrl, "68302", 1},
  {m68000,					m68000_ctrl, "68306", 1},
  {m68000,					m68000_ctrl, "68307", 1},
  {m68000,					m68000_ctrl, "68322", 1},
  {m68000,					m68000_ctrl, "68356", 1},
  {m68010,					m68010_ctrl, "68010", 0},
  {m68020|m68881|m68851,			m68020_ctrl, "68020", 0},
  {m68020|m68881|m68851,			m68020_ctrl, "68k", 1},
  {m68020|m68881|m68851,			m68020_ctrl, "68ec020", 1},
  {m68030|m68881|m68851,			m68020_ctrl, "68030", 0},
  {m68030|m68881|m68851,			m68020_ctrl, "68ec030", 1},
  {m68040,					m68040_ctrl, "68040", 0},
  {m68040,					m68040_ctrl, "68ec040", 1},
  {m68060,					m68060_ctrl, "68060", 0},
  {m68060,					m68060_ctrl, "68ec060", 1},

  {cpu32|m68881,				cpu32_ctrl, "cpu32",  0},
  {cpu32|m68881,				cpu32_ctrl, "68330", 1},
  {cpu32|m68881,				cpu32_ctrl, "68331", 1},
  {cpu32|m68881,				cpu32_ctrl, "68332", 1},
  {cpu32|m68881,				cpu32_ctrl, "68333", 1},
  {cpu32|m68881,				cpu32_ctrl, "68334", 1},
  {cpu32|m68881,				cpu32_ctrl, "68336", 1},
  {cpu32|m68881,				cpu32_ctrl, "68340", 1},
  {cpu32|m68881,				cpu32_ctrl, "68341", 1},
  {cpu32|m68881,				cpu32_ctrl, "68349", 1},
  {cpu32|m68881,				cpu32_ctrl, "68360", 1},

  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51", 0},
  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51ac", 1},
  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51ag", 1},
  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51cn", 1},
  {mcfisa_a|mcfisa_c|mcfusp|mcfmac,  		mcf51_ctrl, "51em", 1},
  {mcfisa_a|mcfisa_c|mcfusp|mcfmac,  		mcf51_ctrl, "51je", 1},
  {mcfisa_a|mcfisa_c|mcfusp|mcfemac,            mcf51_ctrl, "51jf", 1},
  {mcfisa_a|mcfisa_c|mcfusp|mcfemac,            mcf51_ctrl, "51jg", 1},
  {mcfisa_a|mcfisa_c|mcfusp,  			mcf51_ctrl, "51jm", 1},
  {mcfisa_a|mcfisa_c|mcfusp|mcfmac,  		mcf51_ctrl, "51mm", 1},
  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51qe", 1},
  {mcfisa_a|mcfisa_c|mcfusp|mcfemac,            mcf51_ctrl, "51qm", 1},

  {mcfisa_a,					mcf_ctrl, "5200", 0},
  {mcfisa_a,					mcf_ctrl, "5202", 1},
  {mcfisa_a,					mcf_ctrl, "5204", 1},
  {mcfisa_a,					mcf5206_ctrl, "5206", 1},

  {mcfisa_a|mcfhwdiv|mcfmac,			mcf5206_ctrl, "5206e", 0},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5208_ctrl, "5207", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5208_ctrl, "5208", 0},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5210a_ctrl, "5210a", 0},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5210a_ctrl, "5211a", 1},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5213_ctrl, "5211", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5213_ctrl, "5212", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5213_ctrl, "5213", 0},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5216_ctrl, "5214", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5216_ctrl, "5216", 0},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5216_ctrl, "521x", 2},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf5221x_ctrl, "5221x", 0},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf52223_ctrl, "52221", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf52223_ctrl, "52223", 0},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52235_ctrl, "52230", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52235_ctrl, "52233", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52235_ctrl, "52234", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52235_ctrl, "52235", 0},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf5225_ctrl, "5224", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf5225_ctrl, "5225", 0},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52277_ctrl, "52274", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52277_ctrl, "52277", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5232", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5233", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5234", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5235", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "523x", 0},
  
  {mcfisa_a|mcfhwdiv|mcfemac,			mcf5249_ctrl, "5249", 0},
  {mcfisa_a|mcfhwdiv|mcfemac,			mcf5250_ctrl, "5250", 0},
  {mcfisa_a|mcfhwdiv|mcfemac, 			mcf5253_ctrl, "5253", 0},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52252", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52254", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52255", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52256", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52258", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52259", 0},
   
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5271_ctrl, "5270", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5271_ctrl, "5271", 0},
  
  {mcfisa_a|mcfhwdiv|mcfmac,			mcf5272_ctrl, "5272", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5275_ctrl, "5274", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5275_ctrl, "5275", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "5280", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "5281", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "5282", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "528x", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53011", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53012", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53013", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53014", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53015", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53016", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53017", 0},
  
  {mcfisa_a|mcfhwdiv|mcfmac,			mcf5307_ctrl, "5307", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "5327", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "5328", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "5329", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "532x", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5373_ctrl, "5372", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5373_ctrl, "5373", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5373_ctrl, "537x", 0},
  
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfmac,		mcf5407_ctrl, "5407",0},

  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54418_ctrl, "54410", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54418_ctrl, "54415", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54418_ctrl, "54416", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54418_ctrl, "54417", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54418_ctrl, "54418", 0},

  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54455_ctrl, "54450", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54455_ctrl, "54451", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54455_ctrl, "54452", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54455_ctrl, "54453", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54455_ctrl, "54454", -1},
  {mcfisa_a|mcfisa_c|mcfhwdiv|mcfemac|mcfusp,   mcf54455_ctrl, "54455", 0},
  
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5475_ctrl, "5470", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5475_ctrl, "5471", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5475_ctrl, "5472", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5475_ctrl, "5473", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5475_ctrl, "5474", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5475_ctrl, "5475", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5475_ctrl, "547x", 0},
  
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5485_ctrl, "5480", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5485_ctrl, "5481", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5485_ctrl, "5482", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5485_ctrl, "5483", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5485_ctrl, "5484", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5485_ctrl, "5485", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcf5485_ctrl, "548x", 0},
  
  {fido_a,				fido_ctrl, "fidoa", 0},
  {fido_a,				fido_ctrl, "fido", 1},

  {0,NULL,NULL, 0}
  };

static const struct m68k_cpu *m68k_lookup_cpu
(const char *, const struct m68k_cpu *, int, int *);
static int m68k_set_arch (const char *, int, int);
static int m68k_set_cpu (const char *, int, int);
static int m68k_set_extension (const char *, int, int);
static void m68k_init_arch (void);

/* This is the assembler relaxation table for m68k. m68k is a rich CISC
   architecture and we have a lot of relaxation modes.  */

/* Macros used in the relaxation code.  */
#define TAB(x,y)	(((x) << 2) + (y))
#define TABTYPE(x)      ((x) >> 2)

/* Relaxation states.  */
#define BYTE		0
#define SHORT		1
#define LONG		2
#define SZ_UNDEF	3

/* Here are all the relaxation modes we support.  First we can relax ordinary
   branches.  On 68020 and higher and on CPU32 all branch instructions take
   three forms, so on these CPUs all branches always remain as such.  When we
   have to expand to the LONG form on a 68000, though, we substitute an
   absolute jump instead.  This is a direct replacement for unconditional
   branches and a branch over a jump for conditional branches.  However, if the
   user requires PIC and disables this with --pcrel, we can only relax between
   BYTE and SHORT forms, punting if that isn't enough.  This gives us four
   different relaxation modes for branches:  */

#define BRANCHBWL	0	/* Branch byte, word, or long.  */
#define BRABSJUNC	1	/* Absolute jump for LONG, unconditional.  */
#define BRABSJCOND	2	/* Absolute jump for LONG, conditional.  */
#define BRANCHBW	3	/* Branch byte or word.  */

/* We also relax coprocessor branches and DBcc's.  All CPUs that support
   coprocessor branches support them in word and long forms, so we have only
   one relaxation mode for them.  DBcc's are word only on all CPUs.  We can
   relax them to the LONG form with a branch-around sequence.  This sequence
   can use a long branch (if available) or an absolute jump (if acceptable).
   This gives us two relaxation modes.  If long branches are not available and
   absolute jumps are not acceptable, we don't relax DBcc's.  */

#define FBRANCH		4	/* Coprocessor branch.  */
#define DBCCLBR		5	/* DBcc relaxable with a long branch.  */
#define DBCCABSJ	6	/* DBcc relaxable with an absolute jump.  */

/* That's all for instruction relaxation.  However, we also relax PC-relative
   operands.  Specifically, we have three operand relaxation modes.  On the
   68000 PC-relative operands can only be 16-bit, but on 68020 and higher and
   on CPU32 they may be 16-bit or 32-bit.  For the latter we relax between the
   two.  Also PC+displacement+index operands in their simple form (with a non-
   suppressed index without memory indirection) are supported on all CPUs, but
   on the 68000 the displacement can be 8-bit only, whereas on 68020 and higher
   and on CPU32 we relax it to SHORT and LONG forms as well using the extended
   form of the PC+displacement+index operand.  Finally, some absolute operands
   can be relaxed down to 16-bit PC-relative.  */

#define PCREL1632	7	/* 16-bit or 32-bit PC-relative.  */
#define PCINDEX		8	/* PC + displacement + index. */
#define ABSTOPCREL	9	/* Absolute relax down to 16-bit PC-relative.  */

/* This relaxation is required for branches where there is no long
   branch and we are in pcrel mode.  We generate a bne/beq pair.  */
#define BRANCHBWPL	10      /* Branch byte, word or pair of longs
				   */

/* Note that calls to frag_var need to specify the maximum expansion
   needed; this is currently 12 bytes for bne/beq pair.  */
#define FRAG_VAR_SIZE 12

/* The fields are:
   How far Forward this mode will reach:
   How far Backward this mode will reach:
   How many bytes this mode will add to the size of the frag
   Which mode to go to if the offset won't fit in this one

   Please check tc-m68k.h:md_prepare_relax_scan if changing this table.  */
relax_typeS md_relax_table[] =
{
  {   127,   -128,  0, TAB (BRANCHBWL, SHORT) },
  { 32767, -32768,  2, TAB (BRANCHBWL, LONG) },
  {     0,	0,  4, 0 },
  {     1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRABSJUNC, SHORT) },
  { 32767, -32768,  2, TAB (BRABSJUNC, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRABSJCOND, SHORT) },
  { 32767, -32768,  2, TAB (BRABSJCOND, LONG) },
  {	0,	0,  6, 0 },
  {	1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRANCHBW, SHORT) },
  {	0,	0,  2, 0 },
  {	1,	1,  0, 0 },
  {	1,	1,  0, 0 },

  {	1, 	1,  0, 0 },		/* FBRANCH doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (FBRANCH, LONG) },
  {	0,	0,  4, 0 },
  {	1, 	1,  0, 0 },

  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (DBCCLBR, LONG) },
  {	0,	0, 10, 0 },
  {	1,	1,  0, 0 },

  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (DBCCABSJ, LONG) },
  {	0,	0, 10, 0 },
  {	1,	1,  0, 0 },

  {	1, 	1,  0, 0 },		/* PCREL1632 doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (PCREL1632, LONG) },
  {	0,	0,  6, 0 },
  {	1,	1,  0, 0 },

  {   125,   -130,  0, TAB (PCINDEX, SHORT) },
  { 32765, -32770,  2, TAB (PCINDEX, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },

  {	1,	1,  0, 0 },		/* ABSTOPCREL doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (ABSTOPCREL, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },
  
  {   127,   -128,  0, TAB (BRANCHBWPL, SHORT) },
  { 32767, -32768,  2, TAB (BRANCHBWPL, LONG) },
  {     0,	0,  10, 0 },
  {     1,	1,  0, 0 },
};

/* These are the machine dependent pseudo-ops.  These are included so
   the assembler can work on the output from the SUN C compiler, which
   generates these.  */

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */
const pseudo_typeS md_pseudo_table[] =
{
  {"data1", s_data1, 0},
  {"data2", s_data2, 0},
  {"bss", s_bss, 0},
  {"even", s_even, 0},
  {"skip", s_space, 0},
  {"proc", s_proc, 0},
#if defined (TE_SUN3) || defined (OBJ_ELF)
  {"align", s_align_bytes, 0},
#endif
#ifdef OBJ_ELF
  {"swbeg", s_ignore, 0},
  {"long", m68k_elf_cons, 4},
#endif
  {"extend", float_cons, 'x'},
  {"ldouble", float_cons, 'x'},

  {"arch", s_m68k_arch, 0},
  {"cpu", s_m68k_cpu, 0},

  /* The following pseudo-ops are supported for MRI compatibility.  */
  {"chip", s_chip, 0},
  {"comline", s_space, 1},
  {"fopt", s_fopt, 0},
  {"mask2", s_ignore, 0},
  {"opt", s_opt, 0},
  {"reg", s_reg, 0},
  {"restore", s_restore, 0},
  {"save", s_save, 0},

  {"if", s_mri_if, 0},
  {"if.b", s_mri_if, 'b'},
  {"if.w", s_mri_if, 'w'},
  {"if.l", s_mri_if, 'l'},
  {"else", s_mri_else, 0},
  {"else.s", s_mri_else, 's'},
  {"else.l", s_mri_else, 'l'},
  {"endi", s_mri_endi, 0},
  {"break", s_mri_break, 0},
  {"break.s", s_mri_break, 's'},
  {"break.l", s_mri_break, 'l'},
  {"next", s_mri_next, 0},
  {"next.s", s_mri_next, 's'},
  {"next.l", s_mri_next, 'l'},
  {"for", s_mri_for, 0},
  {"for.b", s_mri_for, 'b'},
  {"for.w", s_mri_for, 'w'},
  {"for.l", s_mri_for, 'l'},
  {"endf", s_mri_endf, 0},
  {"repeat", s_mri_repeat, 0},
  {"until", s_mri_until, 0},
  {"until.b", s_mri_until, 'b'},
  {"until.w", s_mri_until, 'w'},
  {"until.l", s_mri_until, 'l'},
  {"while", s_mri_while, 0},
  {"while.b", s_mri_while, 'b'},
  {"while.w", s_mri_while, 'w'},
  {"while.l", s_mri_while, 'l'},
  {"endw", s_mri_endw, 0},

  {0, 0, 0}
};

/* The mote pseudo ops are put into the opcode table, since they
   don't start with a . they look like opcodes to gas.  */

const pseudo_typeS mote_pseudo_table[] =
{

  {"dcl", cons, 4},
  {"dc", cons, 2},
  {"dcw", cons, 2},
  {"dcb", cons, 1},

  {"dsl", s_space, 4},
  {"ds", s_space, 2},
  {"dsw", s_space, 2},
  {"dsb", s_space, 1},

  {"xdef", s_globl, 0},
#ifdef OBJ_ELF
  {"align", s_align_bytes, 0},
#else
  {"align", s_align_ptwo, 0},
#endif
#ifdef M68KCOFF
  {"sect", obj_coff_section, 0},
  {"section", obj_coff_section, 0},
#endif
  {0, 0, 0}
};

/* Truncate and sign-extend at 32 bits, so that building on a 64-bit host
   gives identical results to a 32-bit host.  */
#define TRUNC(X)	((valueT) (X) & 0xffffffff)
#define SEXT(X)		((TRUNC (X) ^ 0x80000000) - 0x80000000)

#define issbyte(x)	((valueT) SEXT (x) + 0x80 < 0x100)
#define isubyte(x)	((valueT) TRUNC (x) < 0x100)
#define issword(x)	((valueT) SEXT (x) + 0x8000 < 0x10000)
#define isuword(x)	((valueT) TRUNC (x) < 0x10000)

#define isbyte(x)	((valueT) SEXT (x) + 0xff < 0x1ff)
#define isword(x)	((valueT) SEXT (x) + 0xffff < 0x1ffff)
#define islong(x)	(1)

static char notend_table[256];
static char alt_notend_table[256];
#define notend(s)						\
  (! (notend_table[(unsigned char) *s]				\
      || (*s == ':'						\
	  && alt_notend_table[(unsigned char) s[1]])))

#ifdef OBJ_ELF

/* Return zero if the reference to SYMBOL from within the same segment may
   be relaxed.  */

/* On an ELF system, we can't relax an externally visible symbol,
   because it may be overridden by a shared library.  However, if
   TARGET_OS is "elf", then we presume that we are assembling for an
   embedded system, in which case we don't have to worry about shared
   libraries, and we can relax any external sym.  */

#define relaxable_symbol(symbol) \
  (!((S_IS_EXTERNAL (symbol) && EXTERN_FORCE_RELOC) \
     || S_IS_WEAK (symbol)))

/* Compute the relocation code for a fixup of SIZE bytes, using pc
   relative relocation if PCREL is non-zero.  PIC says whether a special
   pic relocation was requested.  */

static bfd_reloc_code_real_type
get_reloc_code (int size, int pcrel, enum pic_relocation pic)
{
  switch (pic)
    {
    case pic_got_pcrel:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_GOT_PCREL;
	case 2:
	  return BFD_RELOC_16_GOT_PCREL;
	case 4:
	  return BFD_RELOC_32_GOT_PCREL;
	}
      break;

    case pic_got_off:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_GOTOFF;
	case 2:
	  return BFD_RELOC_16_GOTOFF;
	case 4:
	  return BFD_RELOC_32_GOTOFF;
	}
      break;

    case pic_plt_pcrel:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_PLT_PCREL;
	case 2:
	  return BFD_RELOC_16_PLT_PCREL;
	case 4:
	  return BFD_RELOC_32_PLT_PCREL;
	}
      break;

    case pic_plt_off:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_PLTOFF;
	case 2:
	  return BFD_RELOC_16_PLTOFF;
	case 4:
	  return BFD_RELOC_32_PLTOFF;
	}
      break;

    case pic_tls_gd:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_68K_TLS_GD8;
	case 2:
	  return BFD_RELOC_68K_TLS_GD16;
	case 4:
	  return BFD_RELOC_68K_TLS_GD32;
	}
      break;

    case pic_tls_ldm:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_68K_TLS_LDM8;
	case 2:
	  return BFD_RELOC_68K_TLS_LDM16;
	case 4:
	  return BFD_RELOC_68K_TLS_LDM32;
	}
      break;

    case pic_tls_ldo:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_68K_TLS_LDO8;
	case 2:
	  return BFD_RELOC_68K_TLS_LDO16;
	case 4:
	  return BFD_RELOC_68K_TLS_LDO32;
	}
      break;

    case pic_tls_ie:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_68K_TLS_IE8;
	case 2:
	  return BFD_RELOC_68K_TLS_IE16;
	case 4:
	  return BFD_RELOC_68K_TLS_IE32;
	}
      break;

    case pic_tls_le:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_68K_TLS_LE8;
	case 2:
	  return BFD_RELOC_68K_TLS_LE16;
	case 4:
	  return BFD_RELOC_68K_TLS_LE32;
	}
      break;

    case pic_none:
      if (pcrel)
	{
	  switch (size)
	    {
	    case 1:
	      return BFD_RELOC_8_PCREL;
	    case 2:
	      return BFD_RELOC_16_PCREL;
	    case 4:
	      return BFD_RELOC_32_PCREL;
	    }
	}
      else
	{
	  switch (size)
	    {
	    case 1:
	      return BFD_RELOC_8;
	    case 2:
	      return BFD_RELOC_16;
	    case 4:
	      return BFD_RELOC_32;
	    }
	}
    }

  if (pcrel)
    {
      if (pic == pic_none)
	as_bad (_("Can not do %d byte pc-relative relocation"), size);
      else
	as_bad (_("Can not do %d byte pc-relative pic relocation"), size);
    }
  else
    {
      if (pic == pic_none)
	as_bad (_("Can not do %d byte relocation"), size);
      else
	as_bad (_("Can not do %d byte pic relocation"), size);
    }

  return BFD_RELOC_NONE;
}

/* Here we decide which fixups can be adjusted to make them relative
   to the beginning of the section instead of the symbol.  Basically
   we need to make sure that the dynamic relocations are done
   correctly, so in some cases we force the original symbol to be
   used.  */
int
tc_m68k_fix_adjustable (fixS *fixP)
{
  /* Adjust_reloc_syms doesn't know about the GOT.  */
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_8_GOT_PCREL:
    case BFD_RELOC_16_GOT_PCREL:
    case BFD_RELOC_32_GOT_PCREL:
    case BFD_RELOC_8_GOTOFF:
    case BFD_RELOC_16_GOTOFF:
    case BFD_RELOC_32_GOTOFF:
    case BFD_RELOC_8_PLT_PCREL:
    case BFD_RELOC_16_PLT_PCREL:
    case BFD_RELOC_32_PLT_PCREL:
    case BFD_RELOC_8_PLTOFF:
    case BFD_RELOC_16_PLTOFF:
    case BFD_RELOC_32_PLTOFF:
    case BFD_RELOC_68K_TLS_GD32:
    case BFD_RELOC_68K_TLS_GD16:
    case BFD_RELOC_68K_TLS_GD8:
    case BFD_RELOC_68K_TLS_LDM32:
    case BFD_RELOC_68K_TLS_LDM16:
    case BFD_RELOC_68K_TLS_LDM8:
    case BFD_RELOC_68K_TLS_LDO32:
    case BFD_RELOC_68K_TLS_LDO16:
    case BFD_RELOC_68K_TLS_LDO8:
    case BFD_RELOC_68K_TLS_IE32:
    case BFD_RELOC_68K_TLS_IE16:
    case BFD_RELOC_68K_TLS_IE8:
    case BFD_RELOC_68K_TLS_LE32:
    case BFD_RELOC_68K_TLS_LE16:
    case BFD_RELOC_68K_TLS_LE8:
      return 0;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return 0;

    default:
      return 1;
    }
}

#else /* !OBJ_ELF */

#define get_reloc_code(SIZE,PCREL,OTHER) NO_RELOC

/* PR gas/3041 Weak symbols are not relaxable
   because they must be treated as extern.  */
#define relaxable_symbol(symbol)   (!(S_IS_WEAK (symbol)))

#endif /* OBJ_ELF */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;
  bfd_reloc_code_real_type code;

  /* If the tcbit is set, then this was a fixup of a negative value
     that was never resolved.  We do not have a reloc to handle this,
     so just return.  We assume that other code will have detected this
     situation and produced a helpful error message, so we just tell the
     user that the reloc cannot be produced.  */
  if (fixp->fx_tcbit)
    {
      if (fixp->fx_addsy)
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("Unable to produce reloc against symbol '%s'"),
		      S_GET_NAME (fixp->fx_addsy));
      return NULL;
    }

  if (fixp->fx_r_type != BFD_RELOC_NONE)
    {
      code = fixp->fx_r_type;

      /* Since DIFF_EXPR_OK is defined in tc-m68k.h, it is possible
         that fixup_segment converted a non-PC relative reloc into a
         PC relative reloc.  In such a case, we need to convert the
         reloc code.  */
      if (fixp->fx_pcrel)
	{
	  switch (code)
	    {
	    case BFD_RELOC_8:
	      code = BFD_RELOC_8_PCREL;
	      break;
	    case BFD_RELOC_16:
	      code = BFD_RELOC_16_PCREL;
	      break;
	    case BFD_RELOC_32:
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case BFD_RELOC_8_PCREL:
	    case BFD_RELOC_16_PCREL:
	    case BFD_RELOC_32_PCREL:
	    case BFD_RELOC_8_GOT_PCREL:
	    case BFD_RELOC_16_GOT_PCREL:
	    case BFD_RELOC_32_GOT_PCREL:
	    case BFD_RELOC_8_GOTOFF:
	    case BFD_RELOC_16_GOTOFF:
	    case BFD_RELOC_32_GOTOFF:
	    case BFD_RELOC_8_PLT_PCREL:
	    case BFD_RELOC_16_PLT_PCREL:
	    case BFD_RELOC_32_PLT_PCREL:
	    case BFD_RELOC_8_PLTOFF:
	    case BFD_RELOC_16_PLTOFF:
	    case BFD_RELOC_32_PLTOFF:
	    case BFD_RELOC_68K_TLS_GD32:
	    case BFD_RELOC_68K_TLS_GD16:
	    case BFD_RELOC_68K_TLS_GD8:
	    case BFD_RELOC_68K_TLS_LDM32:
	    case BFD_RELOC_68K_TLS_LDM16:
	    case BFD_RELOC_68K_TLS_LDM8:
	    case BFD_RELOC_68K_TLS_LDO32:
	    case BFD_RELOC_68K_TLS_LDO16:
	    case BFD_RELOC_68K_TLS_LDO8:
	    case BFD_RELOC_68K_TLS_IE32:
	    case BFD_RELOC_68K_TLS_IE16:
	    case BFD_RELOC_68K_TLS_IE8:
	    case BFD_RELOC_68K_TLS_LE32:
	    case BFD_RELOC_68K_TLS_LE16:
	    case BFD_RELOC_68K_TLS_LE8:
	      break;
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("Cannot make %s relocation PC relative"),
			    bfd_get_reloc_code_name (code));
	    }
	}
    }
  else
    {
#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
      switch (F (fixp->fx_size, fixp->fx_pcrel))
	{
#define MAP(SZ,PCREL,TYPE)	case F(SZ,PCREL): code = (TYPE); break
	  MAP (1, 0, BFD_RELOC_8);
	  MAP (2, 0, BFD_RELOC_16);
	  MAP (4, 0, BFD_RELOC_32);
	  MAP (1, 1, BFD_RELOC_8_PCREL);
	  MAP (2, 1, BFD_RELOC_16_PCREL);
	  MAP (4, 1, BFD_RELOC_32_PCREL);
	default:
	  abort ();
	}
    }
#undef F
#undef MAP

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
#ifndef OBJ_ELF
  if (OUTPUT_FLAVOR == bfd_target_aout_flavour
      && fixp->fx_addsy
      && S_IS_WEAK (fixp->fx_addsy)
      && ! bfd_is_und_section (S_GET_SEGMENT (fixp->fx_addsy)))
    {
      /* PR gas/3041 References to weak symbols must be treated as extern
	 in order to be overridable by the linker, even if they are defined
	 in the same object file. So the original addend must be written
	 "as is" into the output section without further processing.
	 The addend value must be hacked here in order to force
	 bfd_install_relocation() to write the original value into the
	 output section.
	 1) MD_APPLY_SYM_VALUE() is set to 1 for m68k/a.out, so the symbol
	 value has already been added to the addend in fixup_segment(). We
	 have to remove it.
	 2) bfd_install_relocation() will incorrectly treat this symbol as
	 resolved, so it will write the symbol value plus its addend and
	 section VMA. As a workaround we can tweak the addend value here in
	 order to get the original value in the section after the call to
	 bfd_install_relocation().  */
      reloc->addend = fixp->fx_addnumber
		      /* Fix because of MD_APPLY_SYM_VALUE() */
		      - S_GET_VALUE (fixp->fx_addsy)
		      /* Fix for bfd_install_relocation() */
		      - (S_GET_VALUE (fixp->fx_addsy)
			 + S_GET_SEGMENT (fixp->fx_addsy)->vma);
    }
  else if (fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else
    reloc->addend = 0;
#else
  if (!fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else
    reloc->addend = (section->vma
		     + fixp->fx_pcrel_adjust
		     + fixp->fx_addnumber
		     + md_pcrel_from (fixp));
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  gas_assert (reloc->howto != 0);

  return reloc;
}

/* Handle of the OPCODE hash table.  NULL means any use before
   m68k_ip_begin() will crash.  */
static struct hash_control *op_hash;

/* Assemble an m68k instruction.  */

static void
m68k_ip (char *instring)
{
  register char *p;
  register struct m68k_op *opP;
  register const struct m68k_incant *opcode;
  register const char *s;
  register int tmpreg = 0, baseo = 0, outro = 0, nextword;
  char *pdot, *pdotmove;
  enum m68k_size siz1, siz2;
  char c;
  int losing;
  int opsfound;
  struct m68k_op operands_backup[6];
  LITTLENUM_TYPE words[6];
  LITTLENUM_TYPE *wordp;
  unsigned long ok_arch = 0;

  if (*instring == ' ')
    instring++;			/* Skip leading whitespace.  */

  /* Scan up to end of operation-code, which MUST end in end-of-string
     or exactly 1 space.  */
  pdot = 0;
  for (p = instring; *p != '\0'; p++)
    {
      if (*p == ' ')
	break;
      if (*p == '.')
	pdot = p;
    }

  if (p == instring)
    {
      the_ins.error = _("No operator");
      return;
    }

  /* p now points to the end of the opcode name, probably whitespace.
     Make sure the name is null terminated by clobbering the
     whitespace, look it up in the hash table, then fix it back.
     Remove a dot, first, since the opcode tables have none.  */
  if (pdot != NULL)
    {
      for (pdotmove = pdot; pdotmove < p; pdotmove++)
	*pdotmove = pdotmove[1];
      p--;
    }

  c = *p;
  *p = '\0';
  opcode = (const struct m68k_incant *) hash_find (op_hash, instring);
  *p = c;

  if (pdot != NULL)
    {
      for (pdotmove = p; pdotmove > pdot; pdotmove--)
	*pdotmove = pdotmove[-1];
      *pdot = '.';
      ++p;
    }

  if (opcode == NULL)
    {
      the_ins.error = _("Unknown operator");
      return;
    }

  /* Found a legitimate opcode, start matching operands.  */
  while (*p == ' ')
    ++p;

  if (opcode->m_operands == 0)
    {
      char *old = input_line_pointer;
      *old = '\n';
      input_line_pointer = p;
      /* Ahh - it's a motorola style psuedo op.  */
      mote_pseudo_table[opcode->m_opnum].poc_handler
	(mote_pseudo_table[opcode->m_opnum].poc_val);
      input_line_pointer = old;
      *old = 0;

      return;
    }

  if (flag_mri && opcode->m_opnum == 0)
    {
      /* In MRI mode, random garbage is allowed after an instruction
         which accepts no operands.  */
      the_ins.args = opcode->m_operands;
      the_ins.numargs = opcode->m_opnum;
      the_ins.numo = opcode->m_codenum;
      the_ins.opcode[0] = getone (opcode);
      the_ins.opcode[1] = gettwo (opcode);
      return;
    }

  for (opP = &the_ins.operands[0]; *p; opP++)
    {
      p = crack_operand (p, opP);

      if (opP->error)
	{
	  the_ins.error = opP->error;
	  return;
	}
    }

  opsfound = opP - &the_ins.operands[0];

  /* This ugly hack is to support the floating pt opcodes in their
     standard form.  Essentially, we fake a first enty of type COP#1 */
  if (opcode->m_operands[0] == 'I')
    {
      int n;

      for (n = opsfound; n > 0; --n)
	the_ins.operands[n] = the_ins.operands[n - 1];

      memset (&the_ins.operands[0], '\0', sizeof (the_ins.operands[0]));
      the_ins.operands[0].mode = CONTROL;
      the_ins.operands[0].reg = m68k_float_copnum;
      opsfound++;
    }

  /* We've got the operands.  Find an opcode that'll accept them.  */
  for (losing = 0;;)
    {
      /* If we didn't get the right number of ops, or we have no
	 common model with this pattern then reject this pattern.  */

      ok_arch |= opcode->m_arch;
      if (opsfound != opcode->m_opnum
	  || ((opcode->m_arch & current_architecture) == 0))
	++losing;
      else
	{
	  int i;

	  /* Make a copy of the operands of this insn so that
	     we can modify them safely, should we want to.  */
	  gas_assert (opsfound <= (int) ARRAY_SIZE (operands_backup));
	  for (i = 0; i < opsfound; i++)
	    operands_backup[i] = the_ins.operands[i];

	  for (s = opcode->m_operands, opP = &operands_backup[0];
	       *s && !losing;
	       s += 2, opP++)
	    {
	      /* Warning: this switch is huge! */
	      /* I've tried to organize the cases into this order:
		 non-alpha first, then alpha by letter.  Lower-case
		 goes directly before uppercase counterpart.  */
	      /* Code with multiple case ...: gets sorted by the lowest
		 case ... it belongs to.  I hope this makes sense.  */
	      switch (*s)
		{
		case '!':
		  switch (opP->mode)
		    {
		    case IMMED:
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case AINC:
		    case ADEC:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '<':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case IMMED:
		    case ADEC:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '>':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case IMMED:
		    case AINC:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC
			  || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case 'm':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    default:
		      losing++;
		    }
		  break;

		case 'n':
		  switch (opP->mode)
		    {
		    case DISP:
		      break;
		    default:
		      losing++;
		    }
		  break;

		case 'o':
		  switch (opP->mode)
		    {
		    case BASE:
		    case ABSL:
		    case IMMED:
		      break;
		    default:
		      losing++;
		    }
		  break;

		case 'p':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
			losing++;
		      break;
		    default:
		      losing++;
		    }
		  break;

		case 'q':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
			losing++;
		      break;
		    default:
		      losing++;
		      break;
		    }
		  break;

		case 'v':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		    case ABSL:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
			losing++;
		      break;
		    default:
		      losing++;
		      break;
		    }
		  break;

		case '#':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (s[1] == 'b'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! isbyte (opP->disp.exp.X_add_number)))
		    losing++;
		  else if (s[1] == 'B'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! issbyte (opP->disp.exp.X_add_number)))
		    losing++;
		  else if (s[1] == 'w'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! isword (opP->disp.exp.X_add_number)))
		    losing++;
		  else if (s[1] == 'W'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! issword (opP->disp.exp.X_add_number)))
		    losing++;
		  break;

		case '^':
		case 'T':
		  if (opP->mode != IMMED)
		    losing++;
		  break;

		case '$':
		  if (opP->mode == AREG
		      || opP->mode == CONTROL
		      || opP->mode == FPREG
		      || opP->mode == IMMED
		      || opP->mode == REGLST
		      || (opP->mode != ABSL
			  && (opP->reg == PC
			      || opP->reg == ZPC)))
		    losing++;
		  break;

		case '%':
		  if (opP->mode == CONTROL
		      || opP->mode == FPREG
		      || opP->mode == REGLST
		      || opP->mode == IMMED
		      || (opP->mode != ABSL
			  && (opP->reg == PC
			      || opP->reg == ZPC)))
		    losing++;
		  break;

		case '&':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case IMMED:
		    case AINC:
		    case ADEC:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC
			  || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case '*':
		  if (opP->mode == CONTROL
		      || opP->mode == FPREG
		      || opP->mode == REGLST)
		    losing++;
		  break;

		case '+':
		  if (opP->mode != AINC)
		    losing++;
		  break;

		case '-':
		  if (opP->mode != ADEC)
		    losing++;
		  break;

		case '/':
		  switch (opP->mode)
		    {
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case AINC:
		    case ADEC:
		    case IMMED:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case ';':
		  switch (opP->mode)
		    {
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '?':
		  switch (opP->mode)
		    {
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case AINC:
		    case ADEC:
		    case IMMED:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case '@@':
		  switch (opP->mode)
		    {
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case IMMED:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '~':	/* For now! (JF FOO is this right?) */
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case IMMED:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC
			  || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case '3':
		  if (opP->mode != CONTROL
		      || (opP->reg != TT0 && opP->reg != TT1))
		    losing++;
		  break;

		case 'A':
		  if (opP->mode != AREG)
		    losing++;
		  break;

		case 'a':
		  if (opP->mode != AINDR)
		    ++losing;
		  break;

		case '4':
		  if (opP->mode != AINDR && opP->mode != AINC && opP->mode != ADEC
		      && (opP->mode != DISP
			   || opP->reg < ADDR0
			   || opP->reg > ADDR7))
		    ++losing;
		  break;

		case 'B':	/* FOO */
		  if (opP->mode != ABSL
		      || (flag_long_jumps
			  && strncmp (instring, "jbsr", 4) == 0))
		    losing++;
		  break;

                case 'b':
                  switch (opP->mode)
                    {
                    case IMMED:
                    case ABSL:
                    case AREG:
                    case FPREG:
                    case CONTROL:
                    case POST:
                    case PRE:
                    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
                    }
                  break;

		case 'C':
		  if (opP->mode != CONTROL || opP->reg != CCR)
		    losing++;
		  break;

		case 'd':
		  if (opP->mode != DISP
		      || opP->reg < ADDR0
		      || opP->reg > ADDR7)
		    losing++;
		  break;

		case 'D':
		  if (opP->mode != DREG)
		    losing++;
		  break;

		case 'E':
		  if (opP->reg != ACC)
		    losing++;
		  break;

		case 'e':
		  if (opP->reg != ACC && opP->reg != ACC1
		      && opP->reg != ACC2 && opP->reg != ACC3)
		    losing++;
		  break;

		case 'F':
		  if (opP->mode != FPREG)
		    losing++;
		  break;

		case 'G':
		  if (opP->reg != MACSR)
		    losing++;
		  break;

		case 'g':
		  if (opP->reg != ACCEXT01 && opP->reg != ACCEXT23)
		    losing++;
		  break;

		case 'H':
		  if (opP->reg != MASK)
		    losing++;
		  break;

		case 'I':
		  if (opP->mode != CONTROL
		      || opP->reg < COP0
		      || opP->reg > COP7)
		    losing++;
		  break;

		case 'i':
		  if (opP->mode != LSH && opP->mode != RSH)
		    losing++;
		  break;

		case 'J':
		  if (opP->mode != CONTROL
		      || opP->reg < USP
		      || opP->reg > last_movec_reg
		      || !control_regs)
		    losing++;
		  else
		    {
		      const enum m68k_register *rp;
		      
		      for (rp = control_regs; *rp; rp++)
			{
			  if (*rp == opP->reg)
			    break;
			  /* In most CPUs RAMBAR refers to control reg
	     	 	     c05 (RAMBAR1), but a few CPUs have it
	     	 	     refer to c04 (RAMBAR0).  */
			  else if (*rp == RAMBAR_ALT && opP->reg == RAMBAR)
			    {
			      opP->reg = RAMBAR_ALT;
			      break;
			    }
			}
		      if (*rp == 0)
			losing++;
		    }
		  break;

		case 'k':
		  if (opP->mode != IMMED)
		    losing++;
		  break;

		case 'l':
		case 'L':
		  if (opP->mode == DREG
		      || opP->mode == AREG
		      || opP->mode == FPREG)
		    {
		      if (s[1] == '8')
			losing++;
		      else
			{
			  switch (opP->mode)
			    {
			    case DREG:
			      opP->mask = 1 << (opP->reg - DATA0);
			      break;
			    case AREG:
			      opP->mask = 1 << (opP->reg - ADDR0 + 8);
			      break;
			    case FPREG:
			      opP->mask = 1 << (opP->reg - FP0 + 16);
			      break;
			    default:
			      abort ();
			    }
			  opP->mode = REGLST;
			}
		    }
		  else if (opP->mode == CONTROL)
		    {
		      if (s[1] != '8')
			losing++;
		      else
			{
			  switch (opP->reg)
			    {
			    case FPI:
			      opP->mask = 1 << 24;
			      break;
			    case FPS:
			      opP->mask = 1 << 25;
			      break;
			    case FPC:
			      opP->mask = 1 << 26;
			      break;
			    default:
			      losing++;
			      break;
			    }
			  opP->mode = REGLST;
			}
		    }
		  else if (opP->mode != REGLST)
		    losing++;
		  else if (s[1] == '8' && (opP->mask & 0x0ffffff) != 0)
		    losing++;
		  else if (s[1] == '3' && (opP->mask & 0x7000000) != 0)
		    losing++;
		  break;

		case 'M':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || ! issbyte (opP->disp.exp.X_add_number))
		    losing++;
		  else if (! m68k_quick
			   && instring[3] != 'q'
			   && instring[4] != 'q')
		    losing++;
		  break;

		case 'O':
		  if (opP->mode != DREG
		      && opP->mode != IMMED
		      && opP->mode != ABSL)
		    losing++;
		  break;

		case 'Q':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || TRUNC (opP->disp.exp.X_add_number) - 1 > 7)
		    losing++;
		  else if (! m68k_quick
			   && (strncmp (instring, "add", 3) == 0
			       || strncmp (instring, "sub", 3) == 0)
			   && instring[3] != 'q')
		    losing++;
		  break;

		case 'R':
		  if (opP->mode != DREG && opP->mode != AREG)
		    losing++;
		  break;

		case 'r':
		  if (opP->mode != AINDR
		      && (opP->mode != BASE
			  || (opP->reg != 0
			      && opP->reg != ZADDR0)
			  || opP->disp.exp.X_op != O_absent
			  || ((opP->index.reg < DATA0
			       || opP->index.reg > DATA7)
			      && (opP->index.reg < ADDR0
				  || opP->index.reg > ADDR7))
			  || opP->index.size != SIZE_UNSPEC
			  || opP->index.scale != 1))
		    losing++;
		  break;

		case 's':
		  if (opP->mode != CONTROL
		      || ! (opP->reg == FPI
			    || opP->reg == FPS
			    || opP->reg == FPC))
		    losing++;
		  break;

		case 'S':
		  if (opP->mode != CONTROL || opP->reg != SR)
		    losing++;
		  break;

		case 't':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || TRUNC (opP->disp.exp.X_add_number) > 7)
		    losing++;
		  break;

		case 'U':
		  if (opP->mode != CONTROL || opP->reg != USP)
		    losing++;
		  break;

		case 'x':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || (TRUNC (opP->disp.exp.X_add_number) != 0xffffffff
			       && TRUNC (opP->disp.exp.X_add_number) - 1 > 6))
		    losing++;
		  break;

		case 'j':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || TRUNC (opP->disp.exp.X_add_number) - 1 > 7)
		    losing++;
		  break;

		case 'K':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || TRUNC (opP->disp.exp.X_add_number) > 511)
		    losing++;
		  break;

		  /* JF these are out of order.  We could put them
		     in order if we were willing to put up with
		     bunches of #ifdef m68851s in the code.

		     Don't forget that you need these operands
		     to use 68030 MMU instructions.  */
#ifndef NO_68851
		  /* Memory addressing mode used by pflushr.  */
		case '|':
		  if (opP->mode == CONTROL
		      || opP->mode == FPREG
		      || opP->mode == DREG
		      || opP->mode == AREG
		      || opP->mode == REGLST)
		    losing++;
		  /* We should accept immediate operands, but they
                     supposedly have to be quad word, and we don't
                     handle that.  I would like to see what a Motorola
                     assembler does before doing something here.  */
		  if (opP->mode == IMMED)
		    losing++;
		  break;

		case 'f':
		  if (opP->mode != CONTROL
		      || (opP->reg != SFC && opP->reg != DFC))
		    losing++;
		  break;

		case '0':
		  if (opP->mode != CONTROL || opP->reg != TC)
		    losing++;
		  break;

		case '1':
		  if (opP->mode != CONTROL || opP->reg != AC)
		    losing++;
		  break;

		case '2':
		  if (opP->mode != CONTROL
		      || (opP->reg != CAL
			  && opP->reg != VAL
			  && opP->reg != SCC))
		    losing++;
		  break;

		case 'V':
		  if (opP->mode != CONTROL
		      || opP->reg != VAL)
		    losing++;
		  break;

		case 'W':
		  if (opP->mode != CONTROL
		      || (opP->reg != DRP
			  && opP->reg != SRP
			  && opP->reg != CRP))
		    losing++;
		  break;

		case 'w':
		  switch (opP->mode)
		    {
		      case IMMED:
		      case ABSL:
		      case AREG:
		      case DREG:
		      case FPREG:
		      case CONTROL:
		      case POST:
		      case PRE:
		      case REGLST:
			losing++;
			break;
		      default:
			break;
		    }
		  break;

		case 'X':
		  if (opP->mode != CONTROL
		      || (!(opP->reg >= BAD && opP->reg <= BAD + 7)
			  && !(opP->reg >= BAC && opP->reg <= BAC + 7)))
		    losing++;
		  break;

		case 'Y':
		  if (opP->mode != CONTROL || opP->reg != PSR)
		    losing++;
		  break;

		case 'Z':
		  if (opP->mode != CONTROL || opP->reg != PCSR)
		    losing++;
		  break;
#endif
		case 'c':
		  if (opP->mode != CONTROL
		      || (opP->reg != NC
			  && opP->reg != IC
			  && opP->reg != DC
			  && opP->reg != BC))
		    losing++;
		  break;

		case '_':
		  if (opP->mode != ABSL)
		    ++losing;
		  break;

		case 'u':
		  if (opP->reg < DATA0L || opP->reg > ADDR7U)
		    losing++;
		  /* FIXME: kludge instead of fixing parser:
                     upper/lower registers are *not* CONTROL
                     registers, but ordinary ones.  */
		  if ((opP->reg >= DATA0L && opP->reg <= DATA7L)
		      || (opP->reg >= DATA0U && opP->reg <= DATA7U))
		    opP->mode = DREG;
		  else
		    opP->mode = AREG;
		  break;

		 case 'y':
		   if (!(opP->mode == AINDR
			 || (opP->mode == DISP
			     && !(opP->reg == PC || opP->reg == ZPC))))
		     losing++;
		   break;

		 case 'z':
		   if (!(opP->mode == AINDR || opP->mode == DISP))
		     losing++;
		   break;

		default:
		  abort ();
		}

	      if (losing)
		break;
	    }

	  /* Since we have found the correct instruction, copy
	     in the modifications that we may have made.  */
	  if (!losing)
	    for (i = 0; i < opsfound; i++)
	      the_ins.operands[i] = operands_backup[i];
	}

      if (!losing)
	break;

      opcode = opcode->m_next;

      if (!opcode)
	{
	  if (ok_arch
	      && !(ok_arch & current_architecture))
	    {
	      const struct m68k_cpu *cpu;
	      int any = 0;
	      size_t space = 400;
	      char *buf = xmalloc (space + 1);
	      size_t len;
	      int paren = 1;

	      the_ins.error = buf;
	      /* Make sure there's a NUL at the end of the buffer -- strncpy
		 won't write one when it runs out of buffer.  */
	      buf[space] = 0;
#define APPEND(STRING) \
  (strncpy (buf, STRING, space), len = strlen (buf), buf += len, space -= len)

	      APPEND (_("invalid instruction for this architecture; needs "));
	      switch (ok_arch)
		{
		case mcfisa_a:
		  APPEND ("ColdFire ISA_A");
		  break;
		case mcfhwdiv:
		  APPEND ("ColdFire ");
		  APPEND (_("hardware divide"));
		  break;
		case mcfisa_aa:
		  APPEND ("ColdFire ISA_A+");
		  break;
		case mcfisa_b:
		  APPEND ("ColdFire ISA_B");
		  break;
		case mcfisa_c:
		  APPEND ("ColdFire ISA_C");
		  break;
		case cfloat:
		  APPEND ("ColdFire fpu");
		  break;
		case mfloat:
		  APPEND ("M68K fpu");
		  break;
		case mmmu:
		  APPEND ("M68K mmu");
		  break;
		case m68020up:
		  APPEND ("68020 ");
		  APPEND (_("or higher"));
		  break;
		case m68000up:
		  APPEND ("68000 ");
		  APPEND (_("or higher"));
		  break;
		case m68010up:
		  APPEND ("68010 ");
		  APPEND (_("or higher"));
		  break;
		default:
		  paren = 0;
		}
	      if (paren)
		APPEND (" (");

	      for (cpu = m68k_cpus; cpu->name; cpu++)
		if (!cpu->alias && (cpu->arch & ok_arch))
		  {
		    const struct m68k_cpu *alias;
		    int seen_master = 0;
		    
		    if (any)
		      APPEND (", ");
		    any = 0;
		    APPEND (cpu->name);
		    for (alias = cpu; alias != m68k_cpus; alias--)
		      if (alias[-1].alias >= 0)
			break;
		    for (; !seen_master || alias->alias > 0; alias++)
			{
			  if (!alias->alias)
			    seen_master = 1;
			  else
			    {
			      if (any)
				APPEND (", ");
			      else
				APPEND (" [");
			      APPEND (alias->name);
			      any = 1;
			    }
			}
		    if (any)
		      APPEND ("]");
		    any = 1;
		  }
	      if (paren)
		APPEND (")");
#undef APPEND
	      if (!space)
		{
		  /* We ran out of space, so replace the end of the list
		     with ellipsis.  */
		  buf -= 4;
		  while (*buf != ' ')
		    buf--;
		  strcpy (buf, " ...");
		}
	    }
	  else
	    the_ins.error = _("operands mismatch");
	  return;
	}

      losing = 0;
    }

  /* Now assemble it.  */
  the_ins.args = opcode->m_operands;
  the_ins.numargs = opcode->m_opnum;
  the_ins.numo = opcode->m_codenum;
  the_ins.opcode[0] = getone (opcode);
  the_ins.opcode[1] = gettwo (opcode);

  for (s = the_ins.args, opP = &the_ins.operands[0]; *s; s += 2, opP++)
    {
      int have_disp = 0;
      int use_pl = 0;
      
      /* This switch is a doozy.
	 Watch the first step; its a big one! */
      switch (s[0])
	{

	case '*':
	case '~':
	case '%':
	case ';':
	case '@@':
	case '!':
	case '&':
	case '$':
	case '?':
	case '/':
	case '<':
	case '>':
	case 'b':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'v':
	case 'w':
	case 'y':
	case 'z':
	case '4':
#ifndef NO_68851
	case '|':
#endif
	  switch (opP->mode)
	    {
	    case IMMED:
	      tmpreg = 0x3c;	/* 7.4 */
	      if (strchr ("bwl", s[1]))
		nextword = get_num (&opP->disp, 90);
	      else
		nextword = get_num (&opP->disp, 0);
	      if (isvar (&opP->disp))
		add_fix (s[1], &opP->disp, 0, 0);
	      switch (s[1])
		{
		case 'b':
		  if (!isbyte (nextword))
		    opP->error = _("operand out of range");
		  addword (nextword);
		  baseo = 0;
		  break;
		case 'w':
		  if (!isword (nextword))
		    opP->error = _("operand out of range");
		  addword (nextword);
		  baseo = 0;
		  break;
		case 'W':
		  if (!issword (nextword))
		    opP->error = _("operand out of range");
		  addword (nextword);
		  baseo = 0;
		  break;
		case 'l':
		  addword (nextword >> 16);
		  addword (nextword);
		  baseo = 0;
		  break;

		case 'f':
		  baseo = 2;
		  outro = 8;
		  break;
		case 'F':
		  baseo = 4;
		  outro = 11;
		  break;
		case 'x':
		  baseo = 6;
		  outro = 15;
		  break;
		case 'p':
		  baseo = 6;
		  outro = -1;
		  break;
		default:
		  abort ();
		}
	      if (!baseo)
		break;

	      /* We gotta put out some float.  */
	      if (op (&opP->disp) != O_big)
		{
		  valueT val;
		  int gencnt;

		  /* Can other cases happen here?  */
		  if (op (&opP->disp) != O_constant)
		    abort ();

		  val = (valueT) offs (&opP->disp);
		  gencnt = 0;
		  do
		    {
		      generic_bignum[gencnt] = (LITTLENUM_TYPE) val;
		      val >>= LITTLENUM_NUMBER_OF_BITS;
		      ++gencnt;
		    }
		  while (val != 0);
		  offs (&opP->disp) = gencnt;
		}
	      if (offs (&opP->disp) > 0)
		{
		  if (offs (&opP->disp) > baseo)
		    {
		      as_warn (_("Bignum too big for %c format; truncated"),
			       s[1]);
		      offs (&opP->disp) = baseo;
		    }
		  baseo -= offs (&opP->disp);
		  while (baseo--)
		    addword (0);
		  for (wordp = generic_bignum + offs (&opP->disp) - 1;
		       offs (&opP->disp)--;
		       --wordp)
		    addword (*wordp);
		  break;
		}
	      gen_to_words (words, baseo, (long) outro);
	      for (wordp = words; baseo--; wordp++)
		addword (*wordp);
	      break;
	    case DREG:
	      tmpreg = opP->reg - DATA;	/* 0.dreg */
	      break;
	    case AREG:
	      tmpreg = 0x08 + opP->reg - ADDR;	/* 1.areg */
	      break;
	    case AINDR:
	      tmpreg = 0x10 + opP->reg - ADDR;	/* 2.areg */
	      break;
	    case ADEC:
	      tmpreg = 0x20 + opP->reg - ADDR;	/* 4.areg */
	      break;
	    case AINC:
	      tmpreg = 0x18 + opP->reg - ADDR;	/* 3.areg */
	      break;
	    case DISP:

	      nextword = get_num (&opP->disp, 90);

	      /* Convert mode 5 addressing with a zero offset into
		 mode 2 addressing to reduce the instruction size by a
		 word.  */
	      if (! isvar (&opP->disp)
		  && (nextword == 0)
		  && (opP->disp.size == SIZE_UNSPEC)
		  && (opP->reg >= ADDR0)
		  && (opP->reg <= ADDR7))
		{
		  tmpreg = 0x10 + opP->reg - ADDR; /* 2.areg */
		  break;
		}

	      if (opP->reg == PC
		  && ! isvar (&opP->disp)
		  && m68k_abspcadd)
		{
		  opP->disp.exp.X_op = O_symbol;
		  opP->disp.exp.X_add_symbol =
		    section_symbol (absolute_section);
		}

	      /* Force into index mode.  Hope this works.  */

	      /* We do the first bit for 32-bit displacements, and the
		 second bit for 16 bit ones.  It is possible that we
		 should make the default be WORD instead of LONG, but
		 I think that'd break GCC, so we put up with a little
		 inefficiency for the sake of working output.  */

	      if (!issword (nextword)
		  || (isvar (&opP->disp)
		      && ((opP->disp.size == SIZE_UNSPEC
			   && flag_short_refs == 0
			   && cpu_of_arch (current_architecture) >= m68020
			   && ! arch_coldfire_p (current_architecture))
			  || opP->disp.size == SIZE_LONG)))
		{
		  if (cpu_of_arch (current_architecture) < m68020
		      || arch_coldfire_p (current_architecture))
		    opP->error =
		      _("displacement too large for this architecture; needs 68020 or higher");
		  if (opP->reg == PC)
		    tmpreg = 0x3B;	/* 7.3 */
		  else
		    tmpreg = 0x30 + opP->reg - ADDR;	/* 6.areg */
		  if (isvar (&opP->disp))
		    {
		      if (opP->reg == PC)
			{
			  if (opP->disp.size == SIZE_LONG
#ifdef OBJ_ELF
			      /* If the displacement needs pic
				 relocation it cannot be relaxed.  */
			      || opP->disp.pic_reloc != pic_none
#endif
			      )
			    {
			      addword (0x0170);
			      add_fix ('l', &opP->disp, 1, 2);
			    }
			  else
			    {
			      add_frag (adds (&opP->disp),
					SEXT (offs (&opP->disp)),
					TAB (PCREL1632, SZ_UNDEF));
			      break;
			    }
			}
		      else
			{
			  addword (0x0170);
			  add_fix ('l', &opP->disp, 0, 0);
			}
		    }
		  else
		    addword (0x0170);
		  addword (nextword >> 16);
		}
	      else
		{
		  if (opP->reg == PC)
		    tmpreg = 0x3A;	/* 7.2 */
		  else
		    tmpreg = 0x28 + opP->reg - ADDR;	/* 5.areg */

		  if (isvar (&opP->disp))
		    {
		      if (opP->reg == PC)
			{
			  add_fix ('w', &opP->disp, 1, 0);
			}
		      else
			add_fix ('w', &opP->disp, 0, 0);
		    }
		}
	      addword (nextword);
	      break;

	    case POST:
	    case PRE:
	    case BASE:
	      nextword = 0;
	      baseo = get_num (&opP->disp, 90);
	      if (opP->mode == POST || opP->mode == PRE)
		outro = get_num (&opP->odisp, 90);
	      /* Figure out the `addressing mode'.
		 Also turn on the BASE_DISABLE bit, if needed.  */
	      if (opP->reg == PC || opP->reg == ZPC)
		{
		  tmpreg = 0x3b;	/* 7.3 */
		  if (opP->reg == ZPC)
		    nextword |= 0x80;
		}
	      else if (opP->reg == 0)
		{
		  nextword |= 0x80;
		  tmpreg = 0x30;	/* 6.garbage */
		}
	      else if (opP->reg >= ZADDR0 && opP->reg <= ZADDR7)
		{
		  nextword |= 0x80;
		  tmpreg = 0x30 + opP->reg - ZADDR0;
		}
	      else
		tmpreg = 0x30 + opP->reg - ADDR;	/* 6.areg */

	      siz1 = opP->disp.size;
	      if (opP->mode == POST || opP->mode == PRE)
		siz2 = opP->odisp.size;
	      else
		siz2 = SIZE_UNSPEC;

	      /* Index register stuff.  */
	      if (opP->index.reg != 0
		  && opP->index.reg >= DATA
		  && opP->index.reg <= ADDR7)
		{
		  nextword |= (opP->index.reg - DATA) << 12;

		  if (opP->index.size == SIZE_LONG
		      || (opP->index.size == SIZE_UNSPEC
			  && m68k_index_width_default == SIZE_LONG))
		    nextword |= 0x800;

		  if ((opP->index.scale != 1
		       && cpu_of_arch (current_architecture) < m68020)
		      || (opP->index.scale == 8
			  && (arch_coldfire_p (current_architecture)
                              && !arch_coldfire_fpu (current_architecture))))
		    {
		      opP->error =
			_("scale factor invalid on this architecture; needs cpu32 or 68020 or higher");
		    }

		  if (arch_coldfire_p (current_architecture)
		      && opP->index.size == SIZE_WORD)
		    opP->error = _("invalid index size for coldfire");

		  switch (opP->index.scale)
		    {
		    case 1:
		      break;
		    case 2:
		      nextword |= 0x200;
		      break;
		    case 4:
		      nextword |= 0x400;
		      break;
		    case 8:
		      nextword |= 0x600;
		      break;
		    default:
		      abort ();
		    }
		  /* IF its simple,
		     GET US OUT OF HERE! */

		  /* Must be INDEX, with an index register.  Address
		     register cannot be ZERO-PC, and either :b was
		     forced, or we know it will fit.  For a 68000 or
		     68010, force this mode anyways, because the
		     larger modes aren't supported.  */
		  if (opP->mode == BASE
		      && ((opP->reg >= ADDR0
			   && opP->reg <= ADDR7)
			  || opP->reg == PC))
		    {
		      if (siz1 == SIZE_BYTE
			  || cpu_of_arch (current_architecture) < m68020
			  || arch_coldfire_p (current_architecture)
			  || (siz1 == SIZE_UNSPEC
			      && ! isvar (&opP->disp)
			      && issbyte (baseo)))
			{
 			  nextword += baseo & 0xff;
 			  addword (nextword);
 			  if (isvar (&opP->disp))
			    {
			      /* Do a byte relocation.  If it doesn't
				 fit (possible on m68000) let the
				 fixup processing complain later.  */
			      if (opP->reg == PC)
				add_fix ('B', &opP->disp, 1, 1);
			      else
				add_fix ('B', &opP->disp, 0, 0);
			    }
			  else if (siz1 != SIZE_BYTE)
			    {
			      if (siz1 != SIZE_UNSPEC)
				as_warn (_("Forcing byte displacement"));
			      if (! issbyte (baseo))
				opP->error = _("byte displacement out of range");
			    }

			  break;
			}
		      else if (siz1 == SIZE_UNSPEC
			       && opP->reg == PC
			       && isvar (&opP->disp)
			       && subs (&opP->disp) == NULL
#ifdef OBJ_ELF
			       /* If the displacement needs pic
				  relocation it cannot be relaxed.  */
			       && opP->disp.pic_reloc == pic_none
#endif
			       )
			{
			  /* The code in md_convert_frag_1 needs to be
                             able to adjust nextword.  Call frag_grow
                             to ensure that we have enough space in
                             the frag obstack to make all the bytes
                             contiguous.  */
			  frag_grow (14);
			  nextword += baseo & 0xff;
			  addword (nextword);
			  add_frag (adds (&opP->disp),
				    SEXT (offs (&opP->disp)),
				    TAB (PCINDEX, SZ_UNDEF));

			  break;
			}
		    }
		}
	      else
		{
		  nextword |= 0x40;	/* No index reg.  */
		  if (opP->index.reg >= ZDATA0
		      && opP->index.reg <= ZDATA7)
		    nextword |= (opP->index.reg - ZDATA0) << 12;
		  else if (opP->index.reg >= ZADDR0
			   || opP->index.reg <= ZADDR7)
		    nextword |= (opP->index.reg - ZADDR0 + 8) << 12;
		}

	      /* It isn't simple.  */

	      if (cpu_of_arch (current_architecture) < m68020
		  || arch_coldfire_p (current_architecture))
		opP->error =
		  _("invalid operand mode for this architecture; needs 68020 or higher");

	      nextword |= 0x100;
	      /* If the guy specified a width, we assume that it is
		 wide enough.  Maybe it isn't.  If so, we lose.  */
	      switch (siz1)
		{
		case SIZE_UNSPEC:
		  if (isvar (&opP->disp)
		      ? m68k_rel32
		      : ! issword (baseo))
		    {
		      siz1 = SIZE_LONG;
		      nextword |= 0x30;
		    }
		  else if (! isvar (&opP->disp) && baseo == 0)
		    nextword |= 0x10;
		  else
		    {
		      nextword |= 0x20;
		      siz1 = SIZE_WORD;
		    }
		  break;
		case SIZE_BYTE:
		  as_warn (_(":b not permitted; defaulting to :w"));
		  /* Fall through.  */
		case SIZE_WORD:
		  nextword |= 0x20;
		  break;
		case SIZE_LONG:
		  nextword |= 0x30;
		  break;
		}

	      /* Figure out inner displacement stuff.  */
	      if (opP->mode == POST || opP->mode == PRE)
		{
		  if (cpu_of_arch (current_architecture) & cpu32)
		    opP->error = _("invalid operand mode for this architecture; needs 68020 or higher");
		  switch (siz2)
		    {
		    case SIZE_UNSPEC:
		      if (isvar (&opP->odisp)
			  ? m68k_rel32
			  : ! issword (outro))
			{
			  siz2 = SIZE_LONG;
			  nextword |= 0x3;
			}
		      else if (! isvar (&opP->odisp) && outro == 0)
			nextword |= 0x1;
		      else
			{
			  nextword |= 0x2;
			  siz2 = SIZE_WORD;
			}
		      break;
		    case 1:
		      as_warn (_(":b not permitted; defaulting to :w"));
		      /* Fall through.  */
		    case 2:
		      nextword |= 0x2;
		      break;
		    case 3:
		      nextword |= 0x3;
		      break;
		    }
		  if (opP->mode == POST
		      && (nextword & 0x40) == 0)
		    nextword |= 0x04;
		}
	      addword (nextword);

	      if (siz1 != SIZE_UNSPEC && isvar (&opP->disp))
		{
		  if (opP->reg == PC || opP->reg == ZPC)
		    add_fix (siz1 == SIZE_LONG ? 'l' : 'w', &opP->disp, 1, 2);
		  else
		    add_fix (siz1 == SIZE_LONG ? 'l' : 'w', &opP->disp, 0, 0);
		}
	      if (siz1 == SIZE_LONG)
		addword (baseo >> 16);
	      if (siz1 != SIZE_UNSPEC)
		addword (baseo);

	      if (siz2 != SIZE_UNSPEC && isvar (&opP->odisp))
		add_fix (siz2 == SIZE_LONG ? 'l' : 'w', &opP->odisp, 0, 0);
	      if (siz2 == SIZE_LONG)
		addword (outro >> 16);
	      if (siz2 != SIZE_UNSPEC)
		addword (outro);

	      break;

	    case ABSL:
	      nextword = get_num (&opP->disp, 90);
	      switch (opP->disp.size)
		{
		default:
		  abort ();
		case SIZE_UNSPEC:
		  if (!isvar (&opP->disp) && issword (offs (&opP->disp)))
		    {
		      tmpreg = 0x38;	/* 7.0 */
		      addword (nextword);
		      break;
		    }
		  if (isvar (&opP->disp)
		      && !subs (&opP->disp)
		      && adds (&opP->disp)
#ifdef OBJ_ELF
		      /* If the displacement needs pic relocation it
			 cannot be relaxed.  */
		      && opP->disp.pic_reloc == pic_none
#endif
		      && !flag_long_jumps
		      && !strchr ("~%&$?", s[0]))
		    {
		      tmpreg = 0x3A;	/* 7.2 */
		      add_frag (adds (&opP->disp),
				SEXT (offs (&opP->disp)),
				TAB (ABSTOPCREL, SZ_UNDEF));
		      break;
		    }
		  /* Fall through into long.  */
		case SIZE_LONG:
		  if (isvar (&opP->disp))
		    add_fix ('l', &opP->disp, 0, 0);

		  tmpreg = 0x39;/* 7.1 mode */
		  addword (nextword >> 16);
		  addword (nextword);
		  break;

		case SIZE_BYTE:
		  as_bad (_("unsupported byte value; use a different suffix"));
		  /* Fall through.  */

		case SIZE_WORD:
		  if (isvar (&opP->disp))
		    add_fix ('w', &opP->disp, 0, 0);

		  tmpreg = 0x38;/* 7.0 mode */
		  addword (nextword);
		  break;
		}
	      break;
	    case CONTROL:
	    case FPREG:
	    default:
	      as_bad (_("unknown/incorrect operand"));
	      /* abort (); */
	    }

	  /* If s[0] is '4', then this is for the mac instructions
	     that can have a trailing_ampersand set.  If so, set 0x100
	     bit on tmpreg so install_gen_operand can check for it and
	     set the appropriate bit (word2, bit 5).  */
	  if (s[0] == '4')
	    {
	      if (opP->trailing_ampersand)
		tmpreg |= 0x100;
	    }
	  install_gen_operand (s[1], tmpreg);
	  break;

	case '#':
	case '^':
	  switch (s[1])
	    {			/* JF: I hate floating point! */
	    case 'j':
	      tmpreg = 70;
	      break;
	    case '8':
	      tmpreg = 20;
	      break;
	    case 'C':
	      tmpreg = 50;
	      break;
	    case '3':
	    default:
	      tmpreg = 90;
	      break;
	    }
	  tmpreg = get_num (&opP->disp, tmpreg);
	  if (isvar (&opP->disp))
	    add_fix (s[1], &opP->disp, 0, 0);
	  switch (s[1])
	    {
	    case 'b':		/* Danger:  These do no check for
				   certain types of overflow.
				   user beware! */
	      if (!isbyte (tmpreg))
		opP->error = _("out of range");
	      insop (tmpreg, opcode);
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n =
		  (opcode->m_codenum) * 2 + 1;
	      break;
	    case 'B':
	      if (!issbyte (tmpreg))
		opP->error = _("out of range");
	      the_ins.opcode[the_ins.numo - 1] |= tmpreg & 0xff;
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = opcode->m_codenum * 2 - 1;
	      break;
	    case 'w':
	      if (!isword (tmpreg))
		opP->error = _("out of range");
	      insop (tmpreg, opcode);
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = (opcode->m_codenum) * 2;
	      break;
	    case 'W':
	      if (!issword (tmpreg))
		opP->error = _("out of range");
	      insop (tmpreg, opcode);
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = (opcode->m_codenum) * 2;
	      break;
	    case 'l':
	      /* Because of the way insop works, we put these two out
		 backwards.  */
	      insop (tmpreg, opcode);
	      insop (tmpreg >> 16, opcode);
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = (opcode->m_codenum) * 2;
	      break;
	    case '3':
	      tmpreg &= 0xFF;
	    case '8':
	    case 'C':
	    case 'j':
	      install_operand (s[1], tmpreg);
	      break;
	    default:
	      abort ();
	    }
	  break;

	case '+':
	case '-':
	case 'A':
	case 'a':
	  install_operand (s[1], opP->reg - ADDR);
	  break;

	case 'B':
	  tmpreg = get_num (&opP->disp, 90);
	  
	  switch (s[1])
	    {
	    case 'B':
	      add_fix ('B', &opP->disp, 1, -1);
	      break;
	    case 'W':
	      add_fix ('w', &opP->disp, 1, 0);
	      addword (0);
	      break;
	    case 'L':
	    long_branch:
	      the_ins.opcode[0] |= 0xff;
	      add_fix ('l', &opP->disp, 1, 0);
	      addword (0);
	      addword (0);
	      break;
	    case 'g': /* Conditional branch */
	      have_disp = HAVE_LONG_CALL (current_architecture);
	      goto var_branch;
	      
	    case 'b': /* Unconditional branch */
	      have_disp = HAVE_LONG_BRANCH (current_architecture);
	      use_pl = LONG_BRANCH_VIA_COND (current_architecture);
	      goto var_branch;
	      
	    case 's': /* Unconditional subroutine */
	      have_disp = HAVE_LONG_CALL (current_architecture);
	      
	      var_branch:
	      if (subs (&opP->disp)	/* We can't relax it.  */
#ifdef OBJ_ELF
		  /* If the displacement needs pic relocation it cannot be
		     relaxed.  */
		  || opP->disp.pic_reloc != pic_none
#endif
		  || 0)
		{
		  if (!have_disp)
		    as_warn (_("Can't use long branches on this architecture"));
		  goto long_branch;
		}
	      
	      /* This could either be a symbol, or an absolute
		 address.  If it's an absolute address, turn it into
		 an absolute jump right here and keep it out of the
		 relaxer.  */
	      if (adds (&opP->disp) == 0)
		{
		  if (the_ins.opcode[0] == 0x6000)	/* jbra */
		    the_ins.opcode[0] = 0x4EF9;
		  else if (the_ins.opcode[0] == 0x6100)	/* jbsr */
		    the_ins.opcode[0] = 0x4EB9;
		  else					/* jCC */
		    {
		      the_ins.opcode[0] ^= 0x0100;
		      the_ins.opcode[0] |= 0x0006;
		      addword (0x4EF9);
		    }
		  add_fix ('l', &opP->disp, 0, 0);
		  addword (0);
		  addword (0);
		  break;
		}

	      /* Now we know it's going into the relaxer.  Now figure
		 out which mode.  We try in this order of preference:
		 long branch, absolute jump, byte/word branches only.  */
	      if (have_disp)
		add_frag (adds (&opP->disp),
			  SEXT (offs (&opP->disp)),
			  TAB (BRANCHBWL, SZ_UNDEF));
	      else if (! flag_keep_pcrel)
		{
		  if ((the_ins.opcode[0] == 0x6000)
		      || (the_ins.opcode[0] == 0x6100))
		    add_frag (adds (&opP->disp),
			      SEXT (offs (&opP->disp)),
			      TAB (BRABSJUNC, SZ_UNDEF));
		  else
		    add_frag (adds (&opP->disp),
			      SEXT (offs (&opP->disp)),
			      TAB (BRABSJCOND, SZ_UNDEF));
		}
	      else
		add_frag (adds (&opP->disp),
			  SEXT (offs (&opP->disp)),
			  (use_pl ? TAB (BRANCHBWPL, SZ_UNDEF)
			   : TAB (BRANCHBW, SZ_UNDEF)));
	      break;
	    case 'w':
	      if (isvar (&opP->disp))
		{
		  /* Check for DBcc instructions.  We can relax them,
		     but only if we have long branches and/or absolute
		     jumps.  */
		  if (((the_ins.opcode[0] & 0xf0f8) == 0x50c8)
		      && (HAVE_LONG_BRANCH (current_architecture)
			  || ! flag_keep_pcrel))
		    {
		      if (HAVE_LONG_BRANCH (current_architecture))
			add_frag (adds (&opP->disp),
				  SEXT (offs (&opP->disp)),
				  TAB (DBCCLBR, SZ_UNDEF));
		      else
			add_frag (adds (&opP->disp),
				  SEXT (offs (&opP->disp)),
				  TAB (DBCCABSJ, SZ_UNDEF));
		      break;
		    }
		  add_fix ('w', &opP->disp, 1, 0);
		}
	      addword (0);
	      break;
	    case 'C':		/* Fixed size LONG coproc branches.  */
	      add_fix ('l', &opP->disp, 1, 0);
	      addword (0);
	      addword (0);
	      break;
	    case 'c':		/* Var size Coprocesssor branches.  */
	      if (subs (&opP->disp) || (adds (&opP->disp) == 0))
		{
		  the_ins.opcode[the_ins.numo - 1] |= 0x40;
		  add_fix ('l', &opP->disp, 1, 0);
		  addword (0);
		  addword (0);
		}
	      else
		add_frag (adds (&opP->disp),
			  SEXT (offs (&opP->disp)),
			  TAB (FBRANCH, SZ_UNDEF));
	      break;
	    default:
	      abort ();
	    }
	  break;

	case 'C':		/* Ignore it.  */
	  break;

	case 'd':		/* JF this is a kludge.  */
	  install_operand ('s', opP->reg - ADDR);
	  tmpreg = get_num (&opP->disp, 90);
	  if (!issword (tmpreg))
	    {
	      as_warn (_("Expression out of range, using 0"));
	      tmpreg = 0;
	    }
	  addword (tmpreg);
	  break;

	case 'D':
	  install_operand (s[1], opP->reg - DATA);
	  break;

	case 'e':  /* EMAC ACCx, reg/reg.  */
	  install_operand (s[1], opP->reg - ACC);
	  break;
	  
	case 'E':		/* Ignore it.  */
	  break;

	case 'F':
	  install_operand (s[1], opP->reg - FP0);
	  break;

	case 'g':  /* EMAC ACCEXTx.  */
	  install_operand (s[1], opP->reg - ACCEXT01);
	  break;

	case 'G':		/* Ignore it.  */
	case 'H':
	  break;

	case 'I':
	  tmpreg = opP->reg - COP0;
	  install_operand (s[1], tmpreg);
	  break;

	case 'i':  /* MAC/EMAC scale factor.  */
	  install_operand (s[1], opP->mode == LSH ? 0x1 : 0x3);
	  break;

	case 'J':		/* JF foo.  */
	  switch (opP->reg)
	    {
	    case SFC:
	      tmpreg = 0x000;
	      break;
	    case DFC:
	      tmpreg = 0x001;
	      break;
	    case CACR:
	      tmpreg = 0x002;
	      break;
	    case TC:
	    case ASID:
	      tmpreg = 0x003;
	      break;
	    case ACR0:
	    case ITT0:
	      tmpreg = 0x004;
	      break;
	    case ACR1:
	    case ITT1:
	      tmpreg = 0x005;
	      break;
	    case ACR2:
	    case DTT0:
	      tmpreg = 0x006;
	      break;
	    case ACR3:
	    case DTT1:
	      tmpreg = 0x007;
	      break;
	    case BUSCR:
	    case MMUBAR:
	      tmpreg = 0x008;
	      break;
	    case RGPIOBAR:
	      tmpreg = 0x009;
	      break;
	    case ACR4:
	    case ACR5:
	    case ACR6:
	    case ACR7:
	      tmpreg = 0x00c + (opP->reg - ACR4);
	      break;

	    case USP:
	      tmpreg = 0x800;
	      break;
	    case VBR:
	      tmpreg = 0x801;
	      break;
	    case CAAR:
	    case CPUCR:
	      tmpreg = 0x802;
	      break;
	    case MSP:
	      tmpreg = 0x803;
	      break;
	    case ISP:
	      tmpreg = 0x804;
	      break;
	    case MMUSR:
	      tmpreg = 0x805;
	      break;
	    case URP:
	      tmpreg = 0x806;
	      break;
	    case SRP:
	      tmpreg = 0x807;
	      break;
	    case PCR:
	      tmpreg = 0x808;
	      break;
            case ROMBAR:
            case ROMBAR0:
	      tmpreg = 0xC00;
	      break;
            case ROMBAR1:
              tmpreg = 0xC01;
              break;
	    case FLASHBAR:
	    case RAMBAR0:
	    case RAMBAR_ALT:
	      tmpreg = 0xC04;
	      break;
	    case RAMBAR:
	    case RAMBAR1:
	      tmpreg = 0xC05;
	      break;
            case MPCR:
              tmpreg = 0xC0C;
              break;
            case EDRAMBAR:
              tmpreg = 0xC0D;
              break;
            case MBAR0:
            case MBAR2:
            case SECMBAR:
              tmpreg = 0xC0E;
              break;
            case MBAR1:
	    case MBAR:
	      tmpreg = 0xC0F;
	      break;
            case PCR1U0:
              tmpreg = 0xD02;
              break;
            case PCR1L0:
              tmpreg = 0xD03;
              break;
            case PCR2U0:
              tmpreg = 0xD04;
              break;
            case PCR2L0:
              tmpreg = 0xD05;
              break;
            case PCR3U0:
              tmpreg = 0xD06;
              break;
            case PCR3L0:
              tmpreg = 0xD07;
              break;
            case PCR1L1:
              tmpreg = 0xD0A;
              break;
            case PCR1U1:
              tmpreg = 0xD0B;
              break;
            case PCR2L1:
              tmpreg = 0xD0C;
              break;
            case PCR2U1:
              tmpreg = 0xD0D;
              break;
            case PCR3L1:
              tmpreg = 0xD0E;
              break;
            case PCR3U1:
              tmpreg = 0xD0F;
              break;
            case CAC:
              tmpreg = 0xFFE;
              break;
            case MBO:
              tmpreg = 0xFFF;
              break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;

	case 'k':
	  tmpreg = get_num (&opP->disp, 55);
	  install_operand (s[1], tmpreg & 0x7f);
	  break;

	case 'l':
	  tmpreg = opP->mask;
	  if (s[1] == 'w')
	    {
	      if (tmpreg & 0x7FF0000)
		as_bad (_("Floating point register in register list"));
	      insop (reverse_16_bits (tmpreg), opcode);
	    }
	  else
	    {
	      if (tmpreg & 0x700FFFF)
		as_bad (_("Wrong register in floating-point reglist"));
	      install_operand (s[1], reverse_8_bits (tmpreg >> 16));
	    }
	  break;

	case 'L':
	  tmpreg = opP->mask;
	  if (s[1] == 'w')
	    {
	      if (tmpreg & 0x7FF0000)
		as_bad (_("Floating point register in register list"));
	      insop (tmpreg, opcode);
	    }
	  else if (s[1] == '8')
	    {
	      if (tmpreg & 0x0FFFFFF)
		as_bad (_("incorrect register in reglist"));
	      install_operand (s[1], tmpreg >> 24);
	    }
	  else
	    {
	      if (tmpreg & 0x700FFFF)
		as_bad (_("wrong register in floating-point reglist"));
	      else
		install_operand (s[1], tmpreg >> 16);
	    }
	  break;

	case 'M':
	  install_operand (s[1], get_num (&opP->disp, 60));
	  break;

	case 'O':
	  tmpreg = ((opP->mode == DREG)
		    ? 0x20 + (int) (opP->reg - DATA)
		    : (get_num (&opP->disp, 40) & 0x1F));
	  install_operand (s[1], tmpreg);
	  break;

	case 'Q':
	  tmpreg = get_num (&opP->disp, 10);
	  if (tmpreg == 8)
	    tmpreg = 0;
	  install_operand (s[1], tmpreg);
	  break;

	case 'R':
	  /* This depends on the fact that ADDR registers are eight
	     more than their corresponding DATA regs, so the result
	     will have the ADDR_REG bit set.  */
	  install_operand (s[1], opP->reg - DATA);
	  break;

	case 'r':
	  if (opP->mode == AINDR)
	    install_operand (s[1], opP->reg - DATA);
	  else
	    install_operand (s[1], opP->index.reg - DATA);
	  break;

	case 's':
	  if (opP->reg == FPI)
	    tmpreg = 0x1;
	  else if (opP->reg == FPS)
	    tmpreg = 0x2;
	  else if (opP->reg == FPC)
	    tmpreg = 0x4;
	  else
	    abort ();
	  install_operand (s[1], tmpreg);
	  break;

	case 'S':		/* Ignore it.  */
	  break;

	case 'T':
	  install_operand (s[1], get_num (&opP->disp, 30));
	  break;

	case 'U':		/* Ignore it.  */
	  break;

	case 'c':
	  switch (opP->reg)
	    {
	    case NC:
	      tmpreg = 0;
	      break;
	    case DC:
	      tmpreg = 1;
	      break;
	    case IC:
	      tmpreg = 2;
	      break;
	    case BC:
	      tmpreg = 3;
	      break;
	    default:
	      as_fatal (_("failed sanity check"));
	    }			/* switch on cache token.  */
	  install_operand (s[1], tmpreg);
	  break;
#ifndef NO_68851
	  /* JF: These are out of order, I fear.  */
	case 'f':
	  switch (opP->reg)
	    {
	    case SFC:
	      tmpreg = 0;
	      break;
	    case DFC:
	      tmpreg = 1;
	      break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;

	case '0':
	case '1':
	case '2':
	  switch (opP->reg)
	    {
	    case TC:
	      tmpreg = 0;
	      break;
	    case CAL:
	      tmpreg = 4;
	      break;
	    case VAL:
	      tmpreg = 5;
	      break;
	    case SCC:
	      tmpreg = 6;
	      break;
	    case AC:
	      tmpreg = 7;
	      break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;

	case 'V':
	  if (opP->reg == VAL)
	    break;
	  abort ();

	case 'W':
	  switch (opP->reg)
	    {
	    case DRP:
	      tmpreg = 1;
	      break;
	    case SRP:
	      tmpreg = 2;
	      break;
	    case CRP:
	      tmpreg = 3;
	      break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;

	case 'X':
	  switch (opP->reg)
	    {
	    case BAD:
	    case BAD + 1:
	    case BAD + 2:
	    case BAD + 3:
	    case BAD + 4:
	    case BAD + 5:
	    case BAD + 6:
	    case BAD + 7:
	      tmpreg = (4 << 10) | ((opP->reg - BAD) << 2);
	      break;

	    case BAC:
	    case BAC + 1:
	    case BAC + 2:
	    case BAC + 3:
	    case BAC + 4:
	    case BAC + 5:
	    case BAC + 6:
	    case BAC + 7:
	      tmpreg = (5 << 10) | ((opP->reg - BAC) << 2);
	      break;

	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;
	case 'Y':
	  know (opP->reg == PSR);
	  break;
	case 'Z':
	  know (opP->reg == PCSR);
	  break;
#endif /* m68851 */
	case '3':
	  switch (opP->reg)
	    {
	    case TT0:
	      tmpreg = 2;
	      break;
	    case TT1:
	      tmpreg = 3;
	      break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;
	case 't':
	  tmpreg = get_num (&opP->disp, 20);
	  install_operand (s[1], tmpreg);
	  break;
	case '_':	/* used only for move16 absolute 32-bit address.  */
	  if (isvar (&opP->disp))
	    add_fix ('l', &opP->disp, 0, 0);
	  tmpreg = get_num (&opP->disp, 90);
	  addword (tmpreg >> 16);
	  addword (tmpreg & 0xFFFF);
	  break;
	case 'u':
	  install_operand (s[1], opP->reg - DATA0L);
	  opP->reg -= (DATA0L);
	  opP->reg &= 0x0F;	/* remove upper/lower bit.  */
	  break;
	case 'x':
	  tmpreg = get_num (&opP->disp, 80);
	  if (tmpreg == -1)
	    tmpreg = 0;
	  install_operand (s[1], tmpreg);
	  break;
	case 'j':
	  tmpreg = get_num (&opP->disp, 10);
	  install_operand (s[1], tmpreg - 1);
	  break;
	case 'K':
	  tmpreg = get_num (&opP->disp, 65);
	  install_operand (s[1], tmpreg);
	  break;
	default:
	  abort ();
	}
    }

  /* By the time whe get here (FINALLY) the_ins contains the complete
     instruction, ready to be emitted. . .  */
}

static int
reverse_16_bits (int in)
{
  int out = 0;
  int n;

  static int mask[16] =
  {
    0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000
  };
  for (n = 0; n < 16; n++)
    {
      if (in & mask[n])
	out |= mask[15 - n];
    }
  return out;
}				/* reverse_16_bits() */

static int
reverse_8_bits (int in)
{
  int out = 0;
  int n;

  static int mask[8] =
  {
    0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
  };

  for (n = 0; n < 8; n++)
    {
      if (in & mask[n])
	out |= mask[7 - n];
    }
  return out;
}				/* reverse_8_bits() */

/* Cause an extra frag to be generated here, inserting up to
   FRAG_VAR_SIZE bytes.  TYPE is the subtype of the frag to be
   generated; its primary type is rs_machine_dependent.

   The TYPE parameter is also used by md_convert_frag_1 and
   md_estimate_size_before_relax.  The appropriate type of fixup will
   be emitted by md_convert_frag_1.

   ADD becomes the FR_SYMBOL field of the frag, and OFF the FR_OFFSET.  */
static void
install_operand (int mode, int val)
{
  switch (mode)
    {
    case 's':
      the_ins.opcode[0] |= val & 0xFF;	/* JF FF is for M kludge.  */
      break;
    case 'd':
      the_ins.opcode[0] |= val << 9;
      break;
    case 'E':
      the_ins.opcode[1] |= val << 9;
      break;
    case '1':
      the_ins.opcode[1] |= val << 12;
      break;
    case '2':
      the_ins.opcode[1] |= val << 6;
      break;
    case '3':
      the_ins.opcode[1] |= val;
      break;
    case '4':
      the_ins.opcode[2] |= val << 12;
      break;
    case '5':
      the_ins.opcode[2] |= val << 6;
      break;
    case '6':
      /* DANGER!  This is a hack to force cas2l and cas2w cmds to be
	 three words long! */
      the_ins.numo++;
      the_ins.opcode[2] |= val;
      break;
    case '7':
      the_ins.opcode[1] |= val << 7;
      break;
    case '8':
      the_ins.opcode[1] |= val << 10;
      break;
#ifndef NO_68851
    case '9':
      the_ins.opcode[1] |= val << 5;
      break;
#endif

    case 't':
      the_ins.opcode[1] |= (val << 10) | (val << 7);
      break;
    case 'D':
      the_ins.opcode[1] |= (val << 12) | val;
      break;
    case 'g':
      the_ins.opcode[0] |= val = 0xff;
      break;
    case 'i':
      the_ins.opcode[0] |= val << 9;
      break;
    case 'C':
      the_ins.opcode[1] |= val;
      break;
    case 'j':
      the_ins.opcode[1] |= val;
      the_ins.numo++;		/* What a hack.  */
      break;
    case 'k':
      the_ins.opcode[1] |= val << 4;
      break;
    case 'b':
    case 'w':
    case 'W':
    case 'l':
      break;
    case 'e':
      the_ins.opcode[0] |= (val << 6);
      break;
    case 'L':
      the_ins.opcode[1] = (val >> 16);
      the_ins.opcode[2] = val & 0xffff;
      break;
    case 'm':
      the_ins.opcode[0] |= ((val & 0x8) << (6 - 3));
      the_ins.opcode[0] |= ((val & 0x7) << 9);
      the_ins.opcode[1] |= ((val & 0x10) << (7 - 4));
      break;
    case 'n': /* MAC/EMAC Rx on !load.  */
      the_ins.opcode[0] |= ((val & 0x8) << (6 - 3));
      the_ins.opcode[0] |= ((val & 0x7) << 9);
      the_ins.opcode[1] |= ((val & 0x10) << (7 - 4));
      break;
    case 'o': /* MAC/EMAC Rx on load.  */
      the_ins.opcode[1] |= val << 12;
      the_ins.opcode[1] |= ((val & 0x10) << (7 - 4));
      break;
    case 'M': /* MAC/EMAC Ry on !load.  */
      the_ins.opcode[0] |= (val & 0xF);
      the_ins.opcode[1] |= ((val & 0x10) << (6 - 4));
      break;
    case 'N': /* MAC/EMAC Ry on load.  */
      the_ins.opcode[1] |= (val & 0xF);
      the_ins.opcode[1] |= ((val & 0x10) << (6 - 4));
      break;
    case 'h':
      the_ins.opcode[1] |= ((val != 1) << 10);
      break;
    case 'F':
      the_ins.opcode[0] |= ((val & 0x3) << 9);
      break;
    case 'f':
      the_ins.opcode[0] |= ((val & 0x3) << 0);
      break;
    case 'G':  /* EMAC accumulator in a EMAC load instruction.  */
      the_ins.opcode[0] |= ((~val & 0x1) << 7);
      the_ins.opcode[1] |= ((val & 0x2) << (4 - 1));
      break;
    case 'H':  /* EMAC accumulator in a EMAC non-load instruction.  */
      the_ins.opcode[0] |= ((val & 0x1) << 7);
      the_ins.opcode[1] |= ((val & 0x2) << (4 - 1));
      break;
    case 'I':
      the_ins.opcode[1] |= ((val & 0x3) << 9);
      break;
    case ']':
      the_ins.opcode[0] |= (val & 0x1) <<10;
      break;
    case 'c':
    default:
      as_fatal (_("failed sanity check."));
    }
}

static void
install_gen_operand (int mode, int val)
{
  switch (mode)
    {
    case '/':  /* Special for mask loads for mac/msac insns with
		  possible mask; trailing_ampersend set in bit 8.  */
      the_ins.opcode[0] |= (val & 0x3f);
      the_ins.opcode[1] |= (((val & 0x100) >> 8) << 5);
      break;
    case 's':
      the_ins.opcode[0] |= val;
      break;
    case 'd':
      /* This is a kludge!!! */
      the_ins.opcode[0] |= (val & 0x07) << 9 | (val & 0x38) << 3;
      break;
    case 'b':
    case 'w':
    case 'l':
    case 'f':
    case 'F':
    case 'x':
    case 'p':
      the_ins.opcode[0] |= val;
      break;
      /* more stuff goes here.  */
    default:
      as_fatal (_("failed sanity check."));
    }
}

/* Verify that we have some number of paren pairs, do m68k_ip_op(), and
   then deal with the bitfield hack.  */

static char *
crack_operand (char *str, struct m68k_op *opP)
{
  register int parens;
  register int c;
  register char *beg_str;
  int inquote = 0;

  if (!str)
    {
      return str;
    }
  beg_str = str;
  for (parens = 0; *str && (parens > 0 || inquote || notend (str)); str++)
    {
      if (! inquote)
	{
	  if (*str == '(')
	    parens++;
	  else if (*str == ')')
	    {
	      if (!parens)
		{			/* ERROR.  */
		  opP->error = _("Extra )");
		  return str;
		}
	      --parens;
	    }
	}
      if (flag_mri && *str == '\'')
	inquote = ! inquote;
    }
  if (!*str && parens)
    {				/* ERROR.  */
      opP->error = _("Missing )");
      return str;
    }
  c = *str;
  *str = '\0';
  if (m68k_ip_op (beg_str, opP) != 0)
    {
      *str = c;
      return str;
    }
  *str = c;
  if (c == '}')
    c = *++str;			/* JF bitfield hack.  */
  if (c)
    {
      c = *++str;
      if (!c)
	as_bad (_("Missing operand"));
    }

  /* Detect MRI REG symbols and convert them to REGLSTs.  */
  if (opP->mode == CONTROL && (int)opP->reg < 0)
    {
      opP->mode = REGLST;
      opP->mask = ~(int)opP->reg;
      opP->reg = 0;
    }

  return str;
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.
   */

static void
insert_reg (const char *regname, int regnum)
{
  char buf[100];
  int i;

#ifdef REGISTER_PREFIX
  if (!flag_reg_prefix_optional)
    {
      buf[0] = REGISTER_PREFIX;
      strcpy (buf + 1, regname);
      regname = buf;
    }
#endif

  symbol_table_insert (symbol_new (regname, reg_section, regnum,
				   &zero_address_frag));

  for (i = 0; regname[i]; i++)
    buf[i] = TOUPPER (regname[i]);
  buf[i] = '\0';

  symbol_table_insert (symbol_new (buf, reg_section, regnum,
				   &zero_address_frag));
}

struct init_entry
  {
    const char *name;
    int number;
  };

static const struct init_entry init_table[] =
{
  { "d0", DATA0 },
  { "d1", DATA1 },
  { "d2", DATA2 },
  { "d3", DATA3 },
  { "d4", DATA4 },
  { "d5", DATA5 },
  { "d6", DATA6 },
  { "d7", DATA7 },
  { "a0", ADDR0 },
  { "a1", ADDR1 },
  { "a2", ADDR2 },
  { "a3", ADDR3 },
  { "a4", ADDR4 },
  { "a5", ADDR5 },
  { "a6", ADDR6 },
  { "fp", ADDR6 },
  { "a7", ADDR7 },
  { "sp", ADDR7 },
  { "ssp", ADDR7 },
  { "fp0", FP0 },
  { "fp1", FP1 },
  { "fp2", FP2 },
  { "fp3", FP3 },
  { "fp4", FP4 },
  { "fp5", FP5 },
  { "fp6", FP6 },
  { "fp7", FP7 },
  { "fpi", FPI },
  { "fpiar", FPI },
  { "fpc", FPI },
  { "fps", FPS },
  { "fpsr", FPS },
  { "fpc", FPC },
  { "fpcr", FPC },
  { "control", FPC },
  { "status", FPS },
  { "iaddr", FPI },

  { "cop0", COP0 },
  { "cop1", COP1 },
  { "cop2", COP2 },
  { "cop3", COP3 },
  { "cop4", COP4 },
  { "cop5", COP5 },
  { "cop6", COP6 },
  { "cop7", COP7 },
  { "pc", PC },
  { "zpc", ZPC },
  { "sr", SR },

  { "ccr", CCR },
  { "cc", CCR },

  { "acc", ACC },
  { "acc0", ACC },
  { "acc1", ACC1 },
  { "acc2", ACC2 },
  { "acc3", ACC3 },
  { "accext01", ACCEXT01 },
  { "accext23", ACCEXT23 },
  { "macsr", MACSR },
  { "mask", MASK },

  /* Control registers.  */
  { "sfc", SFC },		/* Source Function Code.  */
  { "sfcr", SFC },
  { "dfc", DFC },		/* Destination Function Code.  */
  { "dfcr", DFC },
  { "cacr", CACR },		/* Cache Control Register.  */
  { "caar", CAAR },		/* Cache Address Register.  */
  { "cpucr", CPUCR },		/* CPU Control Register.  */

  { "usp", USP },		/* User Stack Pointer.  */
  { "vbr", VBR },		/* Vector Base Register.  */
  { "msp", MSP },		/* Master Stack Pointer.  */
  { "isp", ISP },		/* Interrupt Stack Pointer.  */

  { "itt0", ITT0 },		/* Instruction Transparent Translation Reg 0.  */
  { "itt1", ITT1 },		/* Instruction Transparent Translation Reg 1.  */
  { "dtt0", DTT0 },		/* Data Transparent Translation Register 0.  */
  { "dtt1", DTT1 },		/* Data Transparent Translation Register 1.  */

  /* 68ec040 versions of same */
  { "iacr0", ITT0 },		/* Instruction Access Control Register 0.  */
  { "iacr1", ITT1 },		/* Instruction Access Control Register 0.  */
  { "dacr0", DTT0 },		/* Data Access Control Register 0.  */
  { "dacr1", DTT1 },		/* Data Access Control Register 0.  */

  /* Coldfire versions of same.  The ColdFire programmer's reference
     manual indicated that the order is 2,3,0,1, but Ken Rose
     <rose@@netcom.com> says that 0,1,2,3 is the correct order.  */
  { "acr0", ACR0 },		/* Access Control Unit 0.  */
  { "acr1", ACR1 },		/* Access Control Unit 1.  */
  { "acr2", ACR2 },		/* Access Control Unit 2.  */
  { "acr3", ACR3 },		/* Access Control Unit 3.  */
  { "acr4", ACR4 },		/* Access Control Unit 4.  */
  { "acr5", ACR5 },		/* Access Control Unit 5.  */
  { "acr6", ACR6 },		/* Access Control Unit 6.  */
  { "acr7", ACR7 },		/* Access Control Unit 7.  */

  { "tc", TC },			/* MMU Translation Control Register.  */
  { "tcr", TC },
  { "asid", ASID },

  { "mmusr", MMUSR },		/* MMU Status Register.  */
  { "srp", SRP },		/* User Root Pointer.  */
  { "urp", URP },		/* Supervisor Root Pointer.  */

  { "buscr", BUSCR },
  { "mmubar", MMUBAR },
  { "pcr", PCR },

  { "rombar", ROMBAR },		/* ROM Base Address Register.  */
  { "rambar0", RAMBAR0 },	/* ROM Base Address Register.  */
  { "rambar1", RAMBAR1 },	/* ROM Base Address Register.  */
  { "mbar", MBAR },		/* Module Base Address Register.  */

  { "mbar0",    MBAR0 },	/* mcfv4e registers.  */
  { "mbar1",    MBAR1 },	/* mcfv4e registers.  */
  { "rombar0",  ROMBAR0 },	/* mcfv4e registers.  */
  { "rombar1",  ROMBAR1 },	/* mcfv4e registers.  */
  { "mpcr",     MPCR },		/* mcfv4e registers.  */
  { "edrambar", EDRAMBAR },	/* mcfv4e registers.  */
  { "secmbar",  SECMBAR },	/* mcfv4e registers.  */
  { "asid",     TC },		/* mcfv4e registers.  */
  { "mmubar",   BUSCR },	/* mcfv4e registers.  */
  { "pcr1u0",   PCR1U0 },	/* mcfv4e registers.  */
  { "pcr1l0",   PCR1L0 },	/* mcfv4e registers.  */
  { "pcr2u0",   PCR2U0 },	/* mcfv4e registers.  */
  { "pcr2l0",   PCR2L0 },	/* mcfv4e registers.  */
  { "pcr3u0",   PCR3U0 },	/* mcfv4e registers.  */
  { "pcr3l0",   PCR3L0 },	/* mcfv4e registers.  */
  { "pcr1u1",   PCR1U1 },	/* mcfv4e registers.  */
  { "pcr1l1",   PCR1L1 },	/* mcfv4e registers.  */
  { "pcr2u1",   PCR2U1 },	/* mcfv4e registers.  */
  { "pcr2l1",   PCR2L1 },	/* mcfv4e registers.  */
  { "pcr3u1",   PCR3U1 },	/* mcfv4e registers.  */
  { "pcr3l1",   PCR3L1 },	/* mcfv4e registers.  */

  { "flashbar", FLASHBAR }, 	/* mcf528x registers.  */
  { "rambar",   RAMBAR },  	/* mcf528x registers.  */

  { "mbar2",    MBAR2 },  	/* mcf5249 registers.  */

  { "rgpiobar",	RGPIOBAR },	/* mcf54418 registers.  */

  { "cac",    CAC },  		/* fido registers.  */
  { "mbb",    MBO },  		/* fido registers (obsolete).  */
  { "mbo",    MBO },  		/* fido registers.  */
  /* End of control registers.  */

  { "ac", AC },
  { "bc", BC },
  { "cal", CAL },
  { "crp", CRP },
  { "drp", DRP },
  { "pcsr", PCSR },
  { "psr", PSR },
  { "scc", SCC },
  { "val", VAL },
  { "bad0", BAD0 },
  { "bad1", BAD1 },
  { "bad2", BAD2 },
  { "bad3", BAD3 },
  { "bad4", BAD4 },
  { "bad5", BAD5 },
  { "bad6", BAD6 },
  { "bad7", BAD7 },
  { "bac0", BAC0 },
  { "bac1", BAC1 },
  { "bac2", BAC2 },
  { "bac3", BAC3 },
  { "bac4", BAC4 },
  { "bac5", BAC5 },
  { "bac6", BAC6 },
  { "bac7", BAC7 },

  { "ic", IC },
  { "dc", DC },
  { "nc", NC },

  { "tt0", TT0 },
  { "tt1", TT1 },
  /* 68ec030 versions of same.  */
  { "ac0", TT0 },
  { "ac1", TT1 },
  /* 68ec030 access control unit, identical to 030 MMU status reg.  */
  { "acusr", PSR },

  /* Suppressed data and address registers.  */
  { "zd0", ZDATA0 },
  { "zd1", ZDATA1 },
  { "zd2", ZDATA2 },
  { "zd3", ZDATA3 },
  { "zd4", ZDATA4 },
  { "zd5", ZDATA5 },
  { "zd6", ZDATA6 },
  { "zd7", ZDATA7 },
  { "za0", ZADDR0 },
  { "za1", ZADDR1 },
  { "za2", ZADDR2 },
  { "za3", ZADDR3 },
  { "za4", ZADDR4 },
  { "za5", ZADDR5 },
  { "za6", ZADDR6 },
  { "za7", ZADDR7 },

  /* Upper and lower data and address registers, used by macw and msacw.  */
  { "d0l", DATA0L },
  { "d1l", DATA1L },
  { "d2l", DATA2L },
  { "d3l", DATA3L },
  { "d4l", DATA4L },
  { "d5l", DATA5L },
  { "d6l", DATA6L },
  { "d7l", DATA7L },

  { "a0l", ADDR0L },
  { "a1l", ADDR1L },
  { "a2l", ADDR2L },
  { "a3l", ADDR3L },
  { "a4l", ADDR4L },
  { "a5l", ADDR5L },
  { "a6l", ADDR6L },
  { "a7l", ADDR7L },

  { "d0u", DATA0U },
  { "d1u", DATA1U },
  { "d2u", DATA2U },
  { "d3u", DATA3U },
  { "d4u", DATA4U },
  { "d5u", DATA5U },
  { "d6u", DATA6U },
  { "d7u", DATA7U },

  { "a0u", ADDR0U },
  { "a1u", ADDR1U },
  { "a2u", ADDR2U },
  { "a3u", ADDR3U },
  { "a4u", ADDR4U },
  { "a5u", ADDR5U },
  { "a6u", ADDR6U },
  { "a7u", ADDR7U },

  { 0, 0 }
};

static void
init_regtable (void)
{
  int i;
  for (i = 0; init_table[i].name; i++)
    insert_reg (init_table[i].name, init_table[i].number);
}

void
md_assemble (char *str)
{
  const char *er;
  short *fromP;
  char *toP = NULL;
  int m, n = 0;
  char *to_beg_P;
  int shorts_this_frag;
  fixS *fixP;

  if (!selected_cpu && !selected_arch)
    {
      /* We've not selected an architecture yet.  Set the default
	 now.  We do this lazily so that an initial .cpu or .arch directive
	 can specify.  */
      if (!m68k_set_cpu (TARGET_CPU, 1, 1))
	as_bad (_("unrecognized default cpu `%s'"), TARGET_CPU);
    }
  if (!initialized)
    m68k_init_arch ();
  
  /* In MRI mode, the instruction and operands are separated by a
     space.  Anything following the operands is a comment.  The label
     has already been removed.  */
  if (flag_mri)
    {
      char *s;
      int fields = 0;
      int infield = 0;
      int inquote = 0;

      for (s = str; *s != '\0'; s++)
	{
	  if ((*s == ' ' || *s == '\t') && ! inquote)
	    {
	      if (infield)
		{
		  ++fields;
		  if (fields >= 2)
		    {
		      *s = '\0';
		      break;
		    }
		  infield = 0;
		}
	    }
	  else
	    {
	      if (! infield)
		infield = 1;
	      if (*s == '\'')
		inquote = ! inquote;
	    }
	}
    }

  memset (&the_ins, '\0', sizeof (the_ins));
  m68k_ip (str);
  er = the_ins.error;
  if (!er)
    {
      for (n = 0; n < the_ins.numargs; n++)
	if (the_ins.operands[n].error)
	  {
	    er = the_ins.operands[n].error;
	    break;
	  }
    }
  if (er)
    {
      as_bad (_("%s -- statement `%s' ignored"), er, str);
      return;
    }

  /* If there is a current label, record that it marks an instruction.  */
  if (current_label != NULL)
    {
      current_label->text = 1;
      current_label = NULL;
    }

#ifdef OBJ_ELF
  /* Tie dwarf2 debug info to the address at the start of the insn.  */
  dwarf2_emit_insn (0);
#endif

  if (the_ins.nfrag == 0)
    {
      /* No frag hacking involved; just put it out.  */
      toP = frag_more (2 * the_ins.numo);
      fromP = &the_ins.opcode[0];
      for (m = the_ins.numo; m; --m)
	{
	  md_number_to_chars (toP, (long) (*fromP), 2);
	  toP += 2;
	  fromP++;
	}
      /* Put out symbol-dependent info.  */
      for (m = 0; m < the_ins.nrel; m++)
	{
	  switch (the_ins.reloc[m].wid)
	    {
	    case 'B':
	      n = 1;
	      break;
	    case 'b':
	      n = 1;
	      break;
	    case '3':
	      n = 1;
	      break;
	    case 'w':
	    case 'W':
	      n = 2;
	      break;
	    case 'l':
	      n = 4;
	      break;
	    default:
	      as_fatal (_("Don't know how to figure width of %c in md_assemble()"),
			the_ins.reloc[m].wid);
	    }

	  fixP = fix_new_exp (frag_now,
			      ((toP - frag_now->fr_literal)
			       - the_ins.numo * 2 + the_ins.reloc[m].n),
			      n,
			      &the_ins.reloc[m].exp,
			      the_ins.reloc[m].pcrel,
			      get_reloc_code (n, the_ins.reloc[m].pcrel,
					      the_ins.reloc[m].pic_reloc));
	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
	  if (the_ins.reloc[m].wid == 'B')
	    fixP->fx_signed = 1;
	}
      return;
    }

  /* There's some frag hacking.  */
  {
    /* Calculate the max frag size.  */
    int wid;

    wid = 2 * the_ins.fragb[0].fragoff;
    for (n = 1; n < the_ins.nfrag; n++)
      wid += 2 * (the_ins.numo - the_ins.fragb[n - 1].fragoff);
    /* frag_var part.  */
    wid += FRAG_VAR_SIZE;
    /* Make sure the whole insn fits in one chunk, in particular that
       the var part is attached, as we access one byte before the
       variable frag for byte branches.  */
    frag_grow (wid);
  }

  for (n = 0, fromP = &the_ins.opcode[0]; n < the_ins.nfrag; n++)
    {
      int wid;

      if (n == 0)
	wid = 2 * the_ins.fragb[n].fragoff;
      else
	wid = 2 * (the_ins.numo - the_ins.fragb[n - 1].fragoff);
      toP = frag_more (wid);
      to_beg_P = toP;
      shorts_this_frag = 0;
      for (m = wid / 2; m; --m)
	{
	  md_number_to_chars (toP, (long) (*fromP), 2);
	  toP += 2;
	  fromP++;
	  shorts_this_frag++;
	}
      for (m = 0; m < the_ins.nrel; m++)
	{
	  if ((the_ins.reloc[m].n) >= 2 * shorts_this_frag)
	    {
	      the_ins.reloc[m].n -= 2 * shorts_this_frag;
	      break;
	    }
	  wid = the_ins.reloc[m].wid;
	  if (wid == 0)
	    continue;
	  the_ins.reloc[m].wid = 0;
	  wid = (wid == 'b') ? 1 : (wid == 'w') ? 2 : (wid == 'l') ? 4 : 4000;

	  fixP = fix_new_exp (frag_now,
			      ((toP - frag_now->fr_literal)
			       - the_ins.numo * 2 + the_ins.reloc[m].n),
			      wid,
			      &the_ins.reloc[m].exp,
			      the_ins.reloc[m].pcrel,
			      get_reloc_code (wid, the_ins.reloc[m].pcrel,
					      the_ins.reloc[m].pic_reloc));
	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
	}
      (void) frag_var (rs_machine_dependent, FRAG_VAR_SIZE, 0,
		       (relax_substateT) (the_ins.fragb[n].fragty),
		       the_ins.fragb[n].fadd, the_ins.fragb[n].foff, to_beg_P);
    }
  n = (the_ins.numo - the_ins.fragb[n - 1].fragoff);
  shorts_this_frag = 0;
  if (n)
    {
      toP = frag_more (n * 2);
      while (n--)
	{
	  md_number_to_chars (toP, (long) (*fromP), 2);
	  toP += 2;
	  fromP++;
	  shorts_this_frag++;
	}
    }
  for (m = 0; m < the_ins.nrel; m++)
    {
      int wid;

      wid = the_ins.reloc[m].wid;
      if (wid == 0)
	continue;
      the_ins.reloc[m].wid = 0;
      wid = (wid == 'b') ? 1 : (wid == 'w') ? 2 : (wid == 'l') ? 4 : 4000;

      fixP = fix_new_exp (frag_now,
			  ((the_ins.reloc[m].n + toP - frag_now->fr_literal)
			   - shorts_this_frag * 2),
			  wid,
			  &the_ins.reloc[m].exp,
			  the_ins.reloc[m].pcrel,
			  get_reloc_code (wid, the_ins.reloc[m].pcrel,
					  the_ins.reloc[m].pic_reloc));
      fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
    }
}

/* Comparison function used by qsort to rank the opcode entries by name.  */

static int
m68k_compare_opcode (const void * v1, const void * v2)
{
  struct m68k_opcode * op1, * op2;
  int ret;

  if (v1 == v2)
    return 0;

  op1 = *(struct m68k_opcode **) v1;
  op2 = *(struct m68k_opcode **) v2;

  /* Compare the two names.  If different, return the comparison.
     If the same, return the order they are in the opcode table.  */
  ret = strcmp (op1->name, op2->name);
  if (ret)
    return ret;
  if (op1 < op2)
    return -1;
  return 1;
}

void
md_begin (void)
{
  const struct m68k_opcode *ins;
  struct m68k_incant *hack, *slak;
  const char *retval = 0;	/* Empty string, or error msg text.  */
  int i;

  /* Set up hash tables with 68000 instructions.
     similar to what the vax assembler does.  */
  /* RMS claims the thing to do is take the m68k-opcode.h table, and make
     a copy of it at runtime, adding in the information we want but isn't
     there.  I think it'd be better to have an awk script hack the table
     at compile time.  Or even just xstr the table and use it as-is.  But
     my lord ghod hath spoken, so we do it this way.  Excuse the ugly var
     names.  */

  if (flag_mri)
    {
      flag_reg_prefix_optional = 1;
      m68k_abspcadd = 1;
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 0;
    }

  /* First sort the opcode table into alphabetical order to seperate
     the order that the assembler wants to see the opcodes from the
     order that the disassembler wants to see them.  */
  m68k_sorted_opcodes = xmalloc (m68k_numopcodes * sizeof (* m68k_sorted_opcodes));
  if (!m68k_sorted_opcodes)
    as_fatal (_("Internal Error:  Can't allocate m68k_sorted_opcodes of size %d"),
	      m68k_numopcodes * ((int) sizeof (* m68k_sorted_opcodes)));

  for (i = m68k_numopcodes; i--;)
    m68k_sorted_opcodes[i] = m68k_opcodes + i;

  qsort (m68k_sorted_opcodes, m68k_numopcodes,
	 sizeof (m68k_sorted_opcodes[0]), m68k_compare_opcode);

  op_hash = hash_new ();

  obstack_begin (&robyn, 4000);
  for (i = 0; i < m68k_numopcodes; i++)
    {
      hack = slak = obstack_alloc (&robyn, sizeof (struct m68k_incant));
      do
	{
	  ins = m68k_sorted_opcodes[i];

	  /* We must enter all insns into the table, because .arch and
	     .cpu directives can change things.  */
	  slak->m_operands = ins->args;
	  slak->m_arch = ins->arch;
	  slak->m_opcode = ins->opcode;
	  
	  /* In most cases we can determine the number of opcode words
	     by checking the second word of the mask.  Unfortunately
	     some instructions have 2 opcode words, but no fixed bits
	     in the second word.  A leading dot in the operands
	     string also indicates 2 opcodes.  */
	  if (*slak->m_operands == '.')
	    {
	      slak->m_operands++;
	      slak->m_codenum = 2;
	    }
	  else if (ins->match & 0xffffL)
	    slak->m_codenum = 2;
	  else
	    slak->m_codenum = 1;
	  slak->m_opnum = strlen (slak->m_operands) / 2;
	  
	  if (i + 1 != m68k_numopcodes
	      && !strcmp (ins->name, m68k_sorted_opcodes[i + 1]->name))
	    {
	      slak->m_next = obstack_alloc (&robyn, sizeof (struct m68k_incant));
	      i++;
	    }
	  else
	    slak->m_next = 0;
	  slak = slak->m_next;
	}
      while (slak);

      retval = hash_insert (op_hash, ins->name, (char *) hack);
      if (retval)
	as_fatal (_("Internal Error:  Can't hash %s: %s"), ins->name, retval);
    }

  for (i = 0; i < m68k_numaliases; i++)
    {
      const char *name = m68k_opcode_aliases[i].primary;
      const char *alias = m68k_opcode_aliases[i].alias;
      void *val = hash_find (op_hash, name);

      if (!val)
	as_fatal (_("Internal Error: Can't find %s in hash table"), name);
      retval = hash_insert (op_hash, alias, val);
      if (retval)
	as_fatal (_("Internal Error: Can't hash %s: %s"), alias, retval);
    }

  /* In MRI mode, all unsized branches are variable sized.  Normally,
     they are word sized.  */
  if (flag_mri)
    {
      static struct m68k_opcode_alias mri_aliases[] =
	{
	  { "bhi",	"jhi", },
	  { "bls",	"jls", },
	  { "bcc",	"jcc", },
	  { "bcs",	"jcs", },
	  { "bne",	"jne", },
	  { "beq",	"jeq", },
	  { "bvc",	"jvc", },
	  { "bvs",	"jvs", },
	  { "bpl",	"jpl", },
	  { "bmi",	"jmi", },
	  { "bge",	"jge", },
	  { "blt",	"jlt", },
	  { "bgt",	"jgt", },
	  { "ble",	"jle", },
	  { "bra",	"jra", },
	  { "bsr",	"jbsr", },
	};

      for (i = 0;
	   i < (int) (sizeof mri_aliases / sizeof mri_aliases[0]);
	   i++)
	{
	  const char *name = mri_aliases[i].primary;
	  const char *alias = mri_aliases[i].alias;
	  void *val = hash_find (op_hash, name);

	  if (!val)
	    as_fatal (_("Internal Error: Can't find %s in hash table"), name);
	  retval = hash_jam (op_hash, alias, val);
	  if (retval)
	    as_fatal (_("Internal Error: Can't hash %s: %s"), alias, retval);
	}
    }

  for (i = 0; i < (int) sizeof (notend_table); i++)
    {
      notend_table[i] = 0;
      alt_notend_table[i] = 0;
    }

  notend_table[','] = 1;
  notend_table['{'] = 1;
  notend_table['}'] = 1;
  alt_notend_table['a'] = 1;
  alt_notend_table['A'] = 1;
  alt_notend_table['d'] = 1;
  alt_notend_table['D'] = 1;
  alt_notend_table['#'] = 1;
  alt_notend_table['&'] = 1;
  alt_notend_table['f'] = 1;
  alt_notend_table['F'] = 1;
#ifdef REGISTER_PREFIX
  alt_notend_table[REGISTER_PREFIX] = 1;
#endif

  /* We need to put '(' in alt_notend_table to handle
       cas2 %d0:%d2,%d3:%d4,(%a0):(%a1)  */
  alt_notend_table['('] = 1;

  /* We need to put '@@' in alt_notend_table to handle
       cas2 %d0:%d2,%d3:%d4,@@(%d0):@@(%d1)  */
  alt_notend_table['@@'] = 1;

  /* We need to put digits in alt_notend_table to handle
       bfextu %d0{24:1},%d0  */
  alt_notend_table['0'] = 1;
  alt_notend_table['1'] = 1;
  alt_notend_table['2'] = 1;
  alt_notend_table['3'] = 1;
  alt_notend_table['4'] = 1;
  alt_notend_table['5'] = 1;
  alt_notend_table['6'] = 1;
  alt_notend_table['7'] = 1;
  alt_notend_table['8'] = 1;
  alt_notend_table['9'] = 1;

#ifndef MIT_SYNTAX_ONLY
  /* Insert pseudo ops, these have to go into the opcode table since
     gas expects pseudo ops to start with a dot.  */
  {
    int n = 0;

    while (mote_pseudo_table[n].poc_name)
      {
	hack = obstack_alloc (&robyn, sizeof (struct m68k_incant));
	hash_insert (op_hash,
		     mote_pseudo_table[n].poc_name, (char *) hack);
	hack->m_operands = 0;
	hack->m_opnum = n;
	n++;
      }
  }
#endif

  init_regtable ();

#ifdef OBJ_ELF
  record_alignment (text_section, 2);
  record_alignment (data_section, 2);
  record_alignment (bss_section, 2);
#endif
}


/* This is called when a label is defined.  */

void
m68k_frob_label (symbolS *sym)
{
  struct label_line *n;

  n = (struct label_line *) xmalloc (sizeof *n);
  n->next = labels;
  n->label = sym;
  as_where (&n->file, &n->line);
  n->text = 0;
  labels = n;
  current_label = n;

#ifdef OBJ_ELF
  dwarf2_emit_label (sym);
#endif
}

/* This is called when a value that is not an instruction is emitted.  */

void
m68k_flush_pending_output (void)
{
  current_label = NULL;
}

/* This is called at the end of the assembly, when the final value of
   the label is known.  We warn if this is a text symbol aligned at an
   odd location.  */

void
m68k_frob_symbol (symbolS *sym)
{
  if (S_GET_SEGMENT (sym) == reg_section
      && (int) S_GET_VALUE (sym) < 0)
    {
      S_SET_SEGMENT (sym, absolute_section);
      S_SET_VALUE (sym, ~(int)S_GET_VALUE (sym));
    }
  else if ((S_GET_VALUE (sym) & 1) != 0)
    {
      struct label_line *l;

      for (l = labels; l != NULL; l = l->next)
	{
	  if (l->label == sym)
	    {
	      if (l->text)
		as_warn_where (l->file, l->line,
			       _("text label `%s' aligned to odd boundary"),
			       S_GET_NAME (sym));
	      break;
	    }
	}
    }
}

/* This is called if we go in or out of MRI mode because of the .mri
   pseudo-op.  */

void
m68k_mri_mode_change (int on)
{
  if (on)
    {
      if (! flag_reg_prefix_optional)
	{
	  flag_reg_prefix_optional = 1;
#ifdef REGISTER_PREFIX
	  init_regtable ();
#endif
	}
      m68k_abspcadd = 1;
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 0;
    }
  else
    {
      if (! reg_prefix_optional_seen)
	{
#ifdef REGISTER_PREFIX_OPTIONAL
	  flag_reg_prefix_optional = REGISTER_PREFIX_OPTIONAL;
#else
	  flag_reg_prefix_optional = 0;
#endif
#ifdef REGISTER_PREFIX
	  init_regtable ();
#endif
	}
      m68k_abspcadd = 0;
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 1;
    }
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

void
md_number_to_chars (char *buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  offsetT val = *valP;
  addressT upper_limit;
  offsetT lower_limit;

  /* This is unnecessary but it convinces the native rs6000 compiler
     to generate the code we want.  */
  char *buf = fixP->fx_frag->fr_literal;
  buf += fixP->fx_where;
  /* End ibm compiler workaround.  */

  val = SEXT (val);

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;

#ifdef OBJ_ELF
  if (fixP->fx_addsy)
    {
      memset (buf, 0, fixP->fx_size);
      fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */

      if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	  && !S_IS_DEFINED (fixP->fx_addsy)
	  && !S_IS_WEAK (fixP->fx_addsy))
	S_SET_WEAK (fixP->fx_addsy);

      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_68K_TLS_GD32:
	case BFD_RELOC_68K_TLS_GD16:
	case BFD_RELOC_68K_TLS_GD8:
	case BFD_RELOC_68K_TLS_LDM32:
	case BFD_RELOC_68K_TLS_LDM16:
	case BFD_RELOC_68K_TLS_LDM8:
	case BFD_RELOC_68K_TLS_LDO32:
	case BFD_RELOC_68K_TLS_LDO16:
	case BFD_RELOC_68K_TLS_LDO8:
	case BFD_RELOC_68K_TLS_IE32:
	case BFD_RELOC_68K_TLS_IE16:
	case BFD_RELOC_68K_TLS_IE8:
	case BFD_RELOC_68K_TLS_LE32:
	case BFD_RELOC_68K_TLS_LE16:
	case BFD_RELOC_68K_TLS_LE8:
	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
	  break;

	default:
	  break;
	}

      return;
    }
#elif defined(OBJ_AOUT)
  /* PR gas/3041 Do not fix frags referencing a weak symbol.  */
  if (fixP->fx_addsy && S_IS_WEAK (fixP->fx_addsy))
    {
      memset (buf, 0, fixP->fx_size);
      fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */
      return;
    }
#endif

  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return;

  switch (fixP->fx_size)
    {
      /* The cast to offsetT below are necessary to make code
	 correct for machines where ints are smaller than offsetT.  */
    case 1:
      *buf++ = val;
      upper_limit = 0x7f;
      lower_limit = - (offsetT) 0x80;
      break;
    case 2:
      *buf++ = (val >> 8);
      *buf++ = val;
      upper_limit = 0x7fff;
      lower_limit = - (offsetT) 0x8000;
      break;
    case 4:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      upper_limit = 0x7fffffff;
      lower_limit = - (offsetT) 0x7fffffff - 1;	/* Avoid constant overflow.  */
      break;
    default:
      BAD_CASE (fixP->fx_size);
    }

  /* Fix up a negative reloc.  */
  if (fixP->fx_addsy == NULL && fixP->fx_subsy != NULL)
    {
      fixP->fx_addsy = fixP->fx_subsy;
      fixP->fx_subsy = NULL;
      fixP->fx_tcbit = 1;
    }

  /* For non-pc-relative values, it's conceivable we might get something
     like "0xff" for a byte field.  So extend the upper part of the range
     to accept such numbers.  We arbitrarily disallow "-0xff" or "0xff+0xff",
     so that we can do any range checking at all.  */
  if (! fixP->fx_pcrel && ! fixP->fx_signed)
    upper_limit = upper_limit * 2 + 1;

  if ((addressT) val > upper_limit
      && (val > 0 || val < lower_limit))
    as_bad_where (fixP->fx_file, fixP->fx_line,
		  _("value %ld out of range"), (long)val);

  /* A one byte PC-relative reloc means a short branch.  We can't use
     a short branch with a value of 0 or -1, because those indicate
     different opcodes (branches with longer offsets).  fixup_segment
     in write.c may have clobbered fx_pcrel, so we need to examine the
     reloc type.  */
  if ((fixP->fx_pcrel
       || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && fixP->fx_size == 1
      && (fixP->fx_addsy == NULL
	  || S_IS_DEFINED (fixP->fx_addsy))
      && (val == 0 || val == -1))
    as_bad_where (fixP->fx_file, fixP->fx_line,
		  _("invalid byte branch offset"));
}

/* *fragP has been relaxed to its final size, and now needs to have
   the bytes inside it modified to conform to the new size  There is UGLY
   MAGIC here. ..
   */
static void
md_convert_frag_1 (fragS *fragP)
{
  long disp;
  fixS *fixP = NULL;

  /* Address in object code of the displacement.  */
  register int object_address = fragP->fr_fix + fragP->fr_address;

  /* Address in gas core of the place to store the displacement.  */
  /* This convinces the native rs6000 compiler to generate the code we
     want.  */
  register char *buffer_address = fragP->fr_literal;
  buffer_address += fragP->fr_fix;
  /* End ibm compiler workaround.  */

  /* The displacement of the address, from current location.  */
  disp = fragP->fr_symbol ? S_GET_VALUE (fragP->fr_symbol) : 0;
  disp = (disp + fragP->fr_offset) - object_address;

  switch (fragP->fr_subtype)
    {
    case TAB (BRANCHBWL, BYTE):
    case TAB (BRABSJUNC, BYTE):
    case TAB (BRABSJCOND, BYTE):
    case TAB (BRANCHBW, BYTE):
    case TAB (BRANCHBWPL, BYTE):
      know (issbyte (disp));
      if (disp == 0)
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("short branch with zero offset: use :w"));
      fixP = fix_new (fragP, fragP->fr_fix - 1, 1, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC8);
      fixP->fx_pcrel_adjust = -1;
      break;
    case TAB (BRANCHBWL, SHORT):
    case TAB (BRABSJUNC, SHORT):
    case TAB (BRABSJCOND, SHORT):
    case TAB (BRANCHBW, SHORT):
    case TAB (BRANCHBWPL, SHORT):
      fragP->fr_opcode[1] = 0x00;
      fixP = fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (BRANCHBWL, LONG):
      fragP->fr_opcode[1] = (char) 0xFF;
      fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fragP->fr_fix += 4;
      break;
    case TAB (BRANCHBWPL, LONG):
      /* Here we are converting an unconditional branch into a pair of
	 conditional branches, in order to get the range.  */
      fragP->fr_opcode[0] = 0x66; /* bne */
      fragP->fr_opcode[1] = 0xFF;
      fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fixP->fx_file = fragP->fr_file;
      fixP->fx_line = fragP->fr_line;
      fragP->fr_fix += 4;  /* Skip first offset */
      buffer_address += 4;
      *buffer_address++ = 0x67; /* beq */
      *buffer_address++ = 0xff;
      fragP->fr_fix += 2;  /* Skip second branch opcode */
      fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fragP->fr_fix += 4;
      break;
    case TAB (BRABSJUNC, LONG):
      if (fragP->fr_opcode[0] == 0x61)		/* jbsr */
	{
	  if (flag_keep_pcrel)
    	    as_bad_where (fragP->fr_file, fragP->fr_line,
			  _("Conversion of PC relative BSR to absolute JSR"));
	  fragP->fr_opcode[0] = 0x4E;
	  fragP->fr_opcode[1] = (char) 0xB9; /* JSR with ABSL LONG operand.  */
	  fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
			  fragP->fr_offset, 0, RELAX_RELOC_ABS32);
	  fragP->fr_fix += 4;
	}
      else if (fragP->fr_opcode[0] == 0x60)	/* jbra */
	{
	  if (flag_keep_pcrel)
	    as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("Conversion of PC relative branch to absolute jump"));
	  fragP->fr_opcode[0] = 0x4E;
	  fragP->fr_opcode[1] = (char) 0xF9; /* JMP with ABSL LONG operand.  */
	  fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
			  fragP->fr_offset, 0, RELAX_RELOC_ABS32);
	  fragP->fr_fix += 4;
	}
      else
	{
	  /* This cannot happen, because jbsr and jbra are the only two
	     unconditional branches.  */
	  abort ();
	}
      break;
    case TAB (BRABSJCOND, LONG):
      if (flag_keep_pcrel)
    	as_bad_where (fragP->fr_file, fragP->fr_line,
		  _("Conversion of PC relative conditional branch to absolute jump"));

      /* Only Bcc 68000 instructions can come here
	 Change bcc into b!cc/jmp absl long.  */
      fragP->fr_opcode[0] ^= 0x01;	/* Invert bcc.  */
      fragP->fr_opcode[1]  = 0x06;	/* Branch offset = 6.  */

      /* JF: these used to be fr_opcode[2,3], but they may be in a
	   different frag, in which case referring to them is a no-no.
	   Only fr_opcode[0,1] are guaranteed to work.  */
      *buffer_address++ = 0x4e;	/* put in jmp long (0x4ef9) */
      *buffer_address++ = (char) 0xf9;
      fragP->fr_fix += 2;	/* Account for jmp instruction.  */
      fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		      fragP->fr_offset, 0, RELAX_RELOC_ABS32);
      fragP->fr_fix += 4;
      break;
    case TAB (FBRANCH, SHORT):
      know ((fragP->fr_opcode[1] & 0x40) == 0);
      fixP = fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (FBRANCH, LONG):
      fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit.  */
      fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fragP->fr_fix += 4;
      break;
    case TAB (DBCCLBR, SHORT):
    case TAB (DBCCABSJ, SHORT):
      fixP = fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (DBCCLBR, LONG):
      /* Only DBcc instructions can come here.
	 Change dbcc into dbcc/bral.
	 JF: these used to be fr_opcode[2-7], but that's wrong.  */
      if (flag_keep_pcrel)
    	as_bad_where (fragP->fr_file, fragP->fr_line,
		  _("Conversion of DBcc to absolute jump"));

      *buffer_address++ = 0x00;	/* Branch offset = 4.  */
      *buffer_address++ = 0x04;
      *buffer_address++ = 0x60;	/* Put in bra pc+6.  */
      *buffer_address++ = 0x06;
      *buffer_address++ = 0x60;     /* Put in bral (0x60ff).  */
      *buffer_address++ = (char) 0xff;

      fragP->fr_fix += 6;	/* Account for bra/jmp instructions.  */
      fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fragP->fr_fix += 4;
      break;
    case TAB (DBCCABSJ, LONG):
      /* Only DBcc instructions can come here.
	 Change dbcc into dbcc/jmp.
	 JF: these used to be fr_opcode[2-7], but that's wrong.  */
      if (flag_keep_pcrel)
    	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("Conversion of PC relative conditional branch to absolute jump"));

      *buffer_address++ = 0x00;		/* Branch offset = 4.  */
      *buffer_address++ = 0x04;
      *buffer_address++ = 0x60;		/* Put in bra pc + 6.  */
      *buffer_address++ = 0x06;
      *buffer_address++ = 0x4e;		/* Put in jmp long (0x4ef9).  */
      *buffer_address++ = (char) 0xf9;

      fragP->fr_fix += 6;		/* Account for bra/jmp instructions.  */
      fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		      fragP->fr_offset, 0, RELAX_RELOC_ABS32);
      fragP->fr_fix += 4;
      break;
    case TAB (PCREL1632, SHORT):
      fragP->fr_opcode[1] &= ~0x3F;
      fragP->fr_opcode[1] |= 0x3A; /* 072 - mode 7.2 */
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (PCREL1632, LONG):
      /* Already set to mode 7.3; this indicates: PC indirect with
	 suppressed index, 32-bit displacement.  */
      *buffer_address++ = 0x01;
      *buffer_address++ = 0x70;
      fragP->fr_fix += 2;
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fixP->fx_pcrel_adjust = 2;
      fragP->fr_fix += 4;
      break;
    case TAB (PCINDEX, BYTE):
      gas_assert (fragP->fr_fix >= 2);
      buffer_address[-2] &= ~1;
      fixP = fix_new (fragP, fragP->fr_fix - 1, 1, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC8);
      fixP->fx_pcrel_adjust = 1;
      break;
    case TAB (PCINDEX, SHORT):
      gas_assert (fragP->fr_fix >= 2);
      buffer_address[-2] |= 0x1;
      buffer_address[-1] = 0x20;
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fixP->fx_pcrel_adjust = 2;
      fragP->fr_fix += 2;
      break;
    case TAB (PCINDEX, LONG):
      gas_assert (fragP->fr_fix >= 2);
      buffer_address[-2] |= 0x1;
      buffer_address[-1] = 0x30;
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fixP->fx_pcrel_adjust = 2;
      fragP->fr_fix += 4;
      break;
    case TAB (ABSTOPCREL, SHORT):
      fixP = fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (ABSTOPCREL, LONG):
      if (flag_keep_pcrel)
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("Conversion of PC relative displacement to absolute"));
      /* The thing to do here is force it to ABSOLUTE LONG, since
	 ABSTOPCREL is really trying to shorten an ABSOLUTE address anyway.  */
      if ((fragP->fr_opcode[1] & 0x3F) != 0x3A)
	abort ();
      fragP->fr_opcode[1] &= ~0x3F;
      fragP->fr_opcode[1] |= 0x39;	/* Mode 7.1 */
      fixP = fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		      fragP->fr_offset, 0, RELAX_RELOC_ABS32);
      fragP->fr_fix += 4;
      break;
    }
  if (fixP)
    {
      fixP->fx_file = fragP->fr_file;
      fixP->fx_line = fragP->fr_line;
    }
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  md_convert_frag_1 (fragP);
}

/* Force truly undefined symbols to their maximum size, and generally set up
   the frag list to be relaxed
   */
int
md_estimate_size_before_relax (fragS *fragP, segT segment)
{
  /* Handle SZ_UNDEF first, it can be changed to BYTE or SHORT.  */
  switch (fragP->fr_subtype)
    {
    case TAB (BRANCHBWL, SZ_UNDEF):
    case TAB (BRANCHBWPL, SZ_UNDEF):
    case TAB (BRABSJUNC, SZ_UNDEF):
    case TAB (BRABSJCOND, SZ_UNDEF):
      {
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), BYTE);
	  }
	else if (flag_short_refs)
	  {
	    /* Symbol is undefined and we want short ref.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	  }
	else
	  {
	    /* Symbol is still undefined.  Make it LONG.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
	  }
	break;
      }

    case TAB (BRANCHBW, SZ_UNDEF):
      {
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), BYTE);
	  }
	else
	  {
	    /* Symbol is undefined and we don't have long branches.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	  }
	break;
      }

    case TAB (FBRANCH, SZ_UNDEF):
    case TAB (DBCCLBR, SZ_UNDEF):
    case TAB (DBCCABSJ, SZ_UNDEF):
    case TAB (PCREL1632, SZ_UNDEF):
      {
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	  }
	else
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
	  }
	break;
      }

    case TAB (PCINDEX, SZ_UNDEF):
      if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	   && relaxable_symbol (fragP->fr_symbol)))
	{
	  fragP->fr_subtype = TAB (PCINDEX, BYTE);
	}
      else
	{
	  fragP->fr_subtype = TAB (PCINDEX, LONG);
	}
      break;

    case TAB (ABSTOPCREL, SZ_UNDEF):
      {
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol)))
	  {
	    fragP->fr_subtype = TAB (ABSTOPCREL, SHORT);
	  }
	else
	  {
	    fragP->fr_subtype = TAB (ABSTOPCREL, LONG);
	  }
	break;
      }

    default:
      break;
    }

  /* Now that SZ_UNDEF are taken care of, check others.  */
  switch (fragP->fr_subtype)
    {
    case TAB (BRANCHBWL, BYTE):
    case TAB (BRABSJUNC, BYTE):
    case TAB (BRABSJCOND, BYTE):
    case TAB (BRANCHBW, BYTE):
      /* We can't do a short jump to the next instruction, so in that
	 case we force word mode.  If the symbol is at the start of a
	 frag, and it is the next frag with any data in it (usually
	 this is just the next frag, but assembler listings may
	 introduce empty frags), we must use word mode.  */
      if (fragP->fr_symbol)
	{
	  fragS *sym_frag;

	  sym_frag = symbol_get_frag (fragP->fr_symbol);
	  if (S_GET_VALUE (fragP->fr_symbol) == sym_frag->fr_address)
	    {
	      fragS *l;

	      for (l = fragP->fr_next; l && l != sym_frag; l = l->fr_next)
		if (l->fr_fix != 0)
		  break;
	      if (l == sym_frag)
		fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	    }
	}
      break;
    default:
      break;
    }
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

#if defined(OBJ_AOUT) | defined(OBJ_BOUT)
/* the bit-field entries in the relocation_info struct plays hell
   with the byte-order problems of cross-assembly.  So as a hack,
   I added this mach. dependent ri twiddler.  Ugly, but it gets
   you there. -KWK  */
/* on m68k: first 4 bytes are normal unsigned long, next three bytes
   are symbolnum, most sig. byte first.  Last byte is broken up with
   bit 7 as pcrel, bits 6 & 5 as length, bit 4 as pcrel, and the lower
   nibble as nuthin. (on Sun 3 at least) */
/* Translate the internal relocation information into target-specific
   format.  */
#ifdef comment
void
md_ri_to_chars (char *the_bytes, struct reloc_info_generic *ri)
{
  /* This is easy.  */
  md_number_to_chars (the_bytes, ri->r_address, 4);
  /* Now the fun stuff.  */
  the_bytes[4] = (ri->r_symbolnum >> 16) & 0x0ff;
  the_bytes[5] = (ri->r_symbolnum >>  8) & 0x0ff;
  the_bytes[6] =  ri->r_symbolnum        & 0x0ff;
  the_bytes[7] = (((ri->r_pcrel << 7) & 0x80)
		  | ((ri->r_length << 5) & 0x60)
		  | ((ri->r_extern << 4) & 0x10));
}

#endif

#endif /* OBJ_AOUT or OBJ_BOUT */

#ifndef WORKING_DOT_WORD
int md_short_jump_size = 4;
int md_long_jump_size = 6;

void
md_create_short_jump (char *ptr, addressT from_addr, addressT to_addr,
		      fragS *frag ATTRIBUTE_UNUSED,
		      symbolS *to_symbol ATTRIBUTE_UNUSED)
{
  valueT offset;

  offset = to_addr - (from_addr + 2);

  md_number_to_chars (ptr, (valueT) 0x6000, 2);
  md_number_to_chars (ptr + 2, (valueT) offset, 2);
}

void
md_create_long_jump (char *ptr, addressT from_addr, addressT to_addr,
		     fragS *frag, symbolS *to_symbol)
{
  valueT offset;

  if (!HAVE_LONG_BRANCH (current_architecture))
    {
      if (flag_keep_pcrel)
    	as_fatal (_("Tried to convert PC relative branch to absolute jump"));
      offset = to_addr - S_GET_VALUE (to_symbol);
      md_number_to_chars (ptr, (valueT) 0x4EF9, 2);
      md_number_to_chars (ptr + 2, (valueT) offset, 4);
      fix_new (frag, (ptr + 2) - frag->fr_literal, 4, to_symbol, (offsetT) 0,
	       0, NO_RELOC);
    }
  else
    {
      offset = to_addr - (from_addr + 2);
      md_number_to_chars (ptr, (valueT) 0x60ff, 2);
      md_number_to_chars (ptr + 2, (valueT) offset, 4);
    }
}

#endif

/* Different values of OK tell what its OK to return.  Things that
   aren't OK are an error (what a shock, no?)

   0:  Everything is OK
   10:  Absolute 1:8	   only
   20:  Absolute 0:7	   only
   30:  absolute 0:15	   only
   40:  Absolute 0:31	   only
   50:  absolute 0:127	   only
   55:  absolute -64:63    only
   60:  absolute -128:127  only
   65:  absolute 0:511     only
   70:  absolute 0:4095	   only
   80:  absolute -1, 1:7   only
   90:  No bignums.          */

static int
get_num (struct m68k_exp *exp, int ok)
{
  if (exp->exp.X_op == O_absent)
    {
      /* Do the same thing the VAX asm does.  */
      op (exp) = O_constant;
      adds (exp) = 0;
      subs (exp) = 0;
      offs (exp) = 0;
      if (ok == 10)
	{
	  as_warn (_("expression out of range: defaulting to 1"));
	  offs (exp) = 1;
	}
    }
  else if (exp->exp.X_op == O_constant)
    {
      switch (ok)
	{
	case 10:
	  if ((valueT) TRUNC (offs (exp)) - 1 > 7)
	    {
	      as_warn (_("expression out of range: defaulting to 1"));
	      offs (exp) = 1;
	    }
	  break;
	case 20:
	  if ((valueT) TRUNC (offs (exp)) > 7)
	    goto outrange;
	  break;
	case 30:
	  if ((valueT) TRUNC (offs (exp)) > 15)
	    goto outrange;
	  break;
	case 40:
	  if ((valueT) TRUNC (offs (exp)) > 32)
	    goto outrange;
	  break;
	case 50:
	  if ((valueT) TRUNC (offs (exp)) > 127)
	    goto outrange;
	  break;
	case 55:
	  if ((valueT) SEXT (offs (exp)) + 64 > 127)
	    goto outrange;
	  break;
	case 60:
	  if ((valueT) SEXT (offs (exp)) + 128 > 255)
	    goto outrange;
	  break;
	case 65:
	  if ((valueT) TRUNC (offs (exp)) > 511)
	    goto outrange;
	  break;
	case 70:
	  if ((valueT) TRUNC (offs (exp)) > 4095)
	    {
	    outrange:
	      as_warn (_("expression out of range: defaulting to 0"));
	      offs (exp) = 0;
	    }
	  break;
	case 80:
	  if ((valueT) TRUNC (offs (exp)) != 0xffffffff
              && (valueT) TRUNC (offs (exp)) - 1 > 6)
	    {
	      as_warn (_("expression out of range: defaulting to 1"));
	      offs (exp) = 1;
	    }
	  break;
	default:
	  break;
	}
    }
  else if (exp->exp.X_op == O_big)
    {
      if (offs (exp) <= 0	/* flonum.  */
	  && (ok == 90		/* no bignums */
	      || (ok > 10	/* Small-int ranges including 0 ok.  */
		  /* If we have a flonum zero, a zero integer should
		     do as well (e.g., in moveq).  */
		  && generic_floating_point_number.exponent == 0
		  && generic_floating_point_number.low[0] == 0)))
	{
	  /* HACK! Turn it into a long.  */
	  LITTLENUM_TYPE words[6];

	  gen_to_words (words, 2, 8L);	/* These numbers are magic!  */
	  op (exp) = O_constant;
	  adds (exp) = 0;
	  subs (exp) = 0;
	  offs (exp) = words[1] | (words[0] << 16);
	}
      else if (ok != 0)
	{
	  op (exp) = O_constant;
	  adds (exp) = 0;
	  subs (exp) = 0;
	  offs (exp) = (ok == 10) ? 1 : 0;
	  as_warn (_("Can't deal with expression; defaulting to %ld"),
		   (long) offs (exp));
	}
    }
  else
    {
      if (ok >= 10 && ok <= 80)
	{
	  op (exp) = O_constant;
	  adds (exp) = 0;
	  subs (exp) = 0;
	  offs (exp) = (ok == 10) ? 1 : 0;
	  as_warn (_("Can't deal with expression; defaulting to %ld"),
		   (long) offs (exp));
	}
    }

  if (exp->size != SIZE_UNSPEC)
    {
      switch (exp->size)
	{
	case SIZE_UNSPEC:
	case SIZE_LONG:
	  break;
	case SIZE_BYTE:
	  if (!isbyte (offs (exp)))
	    as_warn (_("expression doesn't fit in BYTE"));
	  break;
	case SIZE_WORD:
	  if (!isword (offs (exp)))
	    as_warn (_("expression doesn't fit in WORD"));
	  break;
	}
    }

  return offs (exp);
}

/* These are the back-ends for the various machine dependent pseudo-ops.  */

static void
s_data1 (int ignore ATTRIBUTE_UNUSED)
{
  subseg_set (data_section, 1);
  demand_empty_rest_of_line ();
}

static void
s_data2 (int ignore ATTRIBUTE_UNUSED)
{
  subseg_set (data_section, 2);
  demand_empty_rest_of_line ();
}

static void
s_bss (int ignore ATTRIBUTE_UNUSED)
{
  /* We don't support putting frags in the BSS segment, we fake it
     by marking in_bss, then looking at s_skip for clues.  */

  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
}

static void
s_even (int ignore ATTRIBUTE_UNUSED)
{
  register int temp;
  register long temp_fill;

  temp = 1;			/* JF should be 2? */
  temp_fill = get_absolute_expression ();
  if (!need_pass_2)		/* Never make frag if expect extra pass.  */
    frag_align (temp, (int) temp_fill, 0);
  demand_empty_rest_of_line ();
  record_alignment (now_seg, temp);
}

static void
s_proc (int ignore ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
}

/* Pseudo-ops handled for MRI compatibility.  */

/* This function returns non-zero if the argument is a conditional
   pseudo-op.  This is called when checking whether a pending
   alignment is needed.  */

int
m68k_conditional_pseudoop (pseudo_typeS *pop)
{
  return (pop->poc_handler == s_mri_if
	  || pop->poc_handler == s_mri_else);
}

/* Handle an MRI style chip specification.  */

static void
mri_chip (void)
{
  char *s;
  char c;
  int i;

  s = input_line_pointer;
  /* We can't use get_symbol_end since the processor names are not proper
     symbols.  */
  while (is_part_of_name (c = *input_line_pointer++))
    ;
  *--input_line_pointer = 0;
  for (i = 0; m68k_cpus[i].name; i++)
    if (strcasecmp (s, m68k_cpus[i].name) == 0)
      break;
  if (!m68k_cpus[i].name)
    {
      as_bad (_("%s: unrecognized processor name"), s);
      *input_line_pointer = c;
      ignore_rest_of_line ();
      return;
    }
  *input_line_pointer = c;

  if (*input_line_pointer == '/')
    current_architecture = 0;
  else
    current_architecture &= m68881 | m68851;
  current_architecture |= m68k_cpus[i].arch & ~(m68881 | m68851);
  control_regs = m68k_cpus[i].control_regs;

  while (*input_line_pointer == '/')
    {
      ++input_line_pointer;
      s = input_line_pointer;
      /* We can't use get_symbol_end since the processor names are not
	 proper symbols.  */
      while (is_part_of_name (c = *input_line_pointer++))
	;
      *--input_line_pointer = 0;
      if (strcmp (s, "68881") == 0)
	current_architecture |= m68881;
      else if (strcmp (s, "68851") == 0)
	current_architecture |= m68851;
      *input_line_pointer = c;
    }
}

/* The MRI CHIP pseudo-op.  */

static void
s_chip (int ignore ATTRIBUTE_UNUSED)
{
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);
  mri_chip ();
  if (flag_mri)
    mri_comment_end (stop, stopc);
  demand_empty_rest_of_line ();
}

/* The MRI FOPT pseudo-op.  */

static void
s_fopt (int ignore ATTRIBUTE_UNUSED)
{
  SKIP_WHITESPACE ();

  if (strncasecmp (input_line_pointer, "ID=", 3) == 0)
    {
      int temp;

      input_line_pointer += 3;
      temp = get_absolute_expression ();
      if (temp < 0 || temp > 7)
	as_bad (_("bad coprocessor id"));
      else
	m68k_float_copnum = COP0 + temp;
    }
  else
    {
      as_bad (_("unrecognized fopt option"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();
}

/* The structure used to handle the MRI OPT pseudo-op.  */

struct opt_action
{
  /* The name of the option.  */
  const char *name;

  /* If this is not NULL, just call this function.  The first argument
     is the ARG field of this structure, the second argument is
     whether the option was negated.  */
  void (*pfn) (int arg, int on);

  /* If this is not NULL, and the PFN field is NULL, set the variable
     this points to.  Set it to the ARG field if the option was not
     negated, and the NOTARG field otherwise.  */
  int *pvar;

  /* The value to pass to PFN or to assign to *PVAR.  */
  int arg;

  /* The value to assign to *PVAR if the option is negated.  If PFN is
     NULL, and PVAR is not NULL, and ARG and NOTARG are the same, then
     the option may not be negated.  */
  int notarg;
};

/* The table used to handle the MRI OPT pseudo-op.  */

static void skip_to_comma (int, int);
static void opt_nest (int, int);
static void opt_chip (int, int);
static void opt_list (int, int);
static void opt_list_symbols (int, int);

static const struct opt_action opt_table[] =
{
  { "abspcadd", 0, &m68k_abspcadd, 1, 0 },

  /* We do relaxing, so there is little use for these options.  */
  { "b", 0, 0, 0, 0 },
  { "brs", 0, 0, 0, 0 },
  { "brb", 0, 0, 0, 0 },
  { "brl", 0, 0, 0, 0 },
  { "brw", 0, 0, 0, 0 },

  { "c", 0, 0, 0, 0 },
  { "cex", 0, 0, 0, 0 },
  { "case", 0, &symbols_case_sensitive, 1, 0 },
  { "cl", 0, 0, 0, 0 },
  { "cre", 0, 0, 0, 0 },
  { "d", 0, &flag_keep_locals, 1, 0 },
  { "e", 0, 0, 0, 0 },
  { "f", 0, &flag_short_refs, 1, 0 },
  { "frs", 0, &flag_short_refs, 1, 0 },
  { "frl", 0, &flag_short_refs, 0, 1 },
  { "g", 0, 0, 0, 0 },
  { "i", 0, 0, 0, 0 },
  { "m", 0, 0, 0, 0 },
  { "mex", 0, 0, 0, 0 },
  { "mc", 0, 0, 0, 0 },
  { "md", 0, 0, 0, 0 },
  { "nest", opt_nest, 0, 0, 0 },
  { "next", skip_to_comma, 0, 0, 0 },
  { "o", 0, 0, 0, 0 },
  { "old", 0, 0, 0, 0 },
  { "op", skip_to_comma, 0, 0, 0 },
  { "pco", 0, 0, 0, 0 },
  { "p", opt_chip, 0, 0, 0 },
  { "pcr", 0, 0, 0, 0 },
  { "pcs", 0, 0, 0, 0 },
  { "r", 0, 0, 0, 0 },
  { "quick", 0, &m68k_quick, 1, 0 },
  { "rel32", 0, &m68k_rel32, 1, 0 },
  { "s", opt_list, 0, 0, 0 },
  { "t", opt_list_symbols, 0, 0, 0 },
  { "w", 0, &flag_no_warnings, 0, 1 },
  { "x", 0, 0, 0, 0 }
};

#define OPTCOUNT ((int) (sizeof opt_table / sizeof opt_table[0]))

/* The MRI OPT pseudo-op.  */

static void
s_opt (int ignore ATTRIBUTE_UNUSED)
{
  do
    {
      int t;
      char *s;
      char c;
      int i;
      const struct opt_action *o;

      SKIP_WHITESPACE ();

      t = 1;
      if (*input_line_pointer == '-')
	{
	  ++input_line_pointer;
	  t = 0;
	}
      else if (strncasecmp (input_line_pointer, "NO", 2) == 0)
	{
	  input_line_pointer += 2;
	  t = 0;
	}

      s = input_line_pointer;
      c = get_symbol_end ();

      for (i = 0, o = opt_table; i < OPTCOUNT; i++, o++)
	{
	  if (strcasecmp (s, o->name) == 0)
	    {
	      if (o->pfn)
		{
		  /* Restore input_line_pointer now in case the option
		     takes arguments.  */
		  *input_line_pointer = c;
		  (*o->pfn) (o->arg, t);
		}
	      else if (o->pvar != NULL)
		{
		  if (! t && o->arg == o->notarg)
		    as_bad (_("option `%s' may not be negated"), s);
		  *input_line_pointer = c;
		  *o->pvar = t ? o->arg : o->notarg;
		}
	      else
		*input_line_pointer = c;
	      break;
	    }
	}
      if (i >= OPTCOUNT)
	{
	  as_bad (_("option `%s' not recognized"), s);
	  *input_line_pointer = c;
	}
    }
  while (*input_line_pointer++ == ',');

  /* Move back to terminating character.  */
  --input_line_pointer;
  demand_empty_rest_of_line ();
}

/* Skip ahead to a comma.  This is used for OPT options which we do
   not support and which take arguments.  */

static void
skip_to_comma (int arg ATTRIBUTE_UNUSED, int on ATTRIBUTE_UNUSED)
{
  while (*input_line_pointer != ','
	 && ! is_end_of_line[(unsigned char) *input_line_pointer])
    ++input_line_pointer;
}

/* Handle the OPT NEST=depth option.  */

static void
opt_nest (int arg ATTRIBUTE_UNUSED, int on ATTRIBUTE_UNUSED)
{
  if (*input_line_pointer != '=')
    {
      as_bad (_("bad format of OPT NEST=depth"));
      return;
    }

  ++input_line_pointer;
  max_macro_nest = get_absolute_expression ();
}

/* Handle the OPT P=chip option.  */

static void
opt_chip (int arg ATTRIBUTE_UNUSED, int on ATTRIBUTE_UNUSED)
{
  if (*input_line_pointer != '=')
    {
      /* This is just OPT P, which we do not support.  */
      return;
    }

  ++input_line_pointer;
  mri_chip ();
}

/* Handle the OPT S option.  */

static void
opt_list (int arg ATTRIBUTE_UNUSED, int on)
{
  listing_list (on);
}

/* Handle the OPT T option.  */

static void
opt_list_symbols (int arg ATTRIBUTE_UNUSED, int on)
{
  if (on)
    listing |= LISTING_SYMBOLS;
  else
    listing &= ~LISTING_SYMBOLS;
}

/* Handle the MRI REG pseudo-op.  */

static void
s_reg (int ignore ATTRIBUTE_UNUSED)
{
  char *s;
  int c;
  struct m68k_op rop;
  int mask;
  char *stop = NULL;
  char stopc;

  if (line_label == NULL)
    {
      as_bad (_("missing label"));
      ignore_rest_of_line ();
      return;
    }

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  SKIP_WHITESPACE ();

  s = input_line_pointer;
  while (ISALNUM (*input_line_pointer)
#ifdef REGISTER_PREFIX
	 || *input_line_pointer == REGISTER_PREFIX
#endif
	 || *input_line_pointer == '/'
	 || *input_line_pointer == '-')
    ++input_line_pointer;
  c = *input_line_pointer;
  *input_line_pointer = '\0';

  if (m68k_ip_op (s, &rop) != 0)
    {
      if (rop.error == NULL)
	as_bad (_("bad register list"));
      else
	as_bad (_("bad register list: %s"), rop.error);
      *input_line_pointer = c;
      ignore_rest_of_line ();
      return;
    }

  *input_line_pointer = c;

  if (rop.mode == REGLST)
    mask = rop.mask;
  else if (rop.mode == DREG)
    mask = 1 << (rop.reg - DATA0);
  else if (rop.mode == AREG)
    mask = 1 << (rop.reg - ADDR0 + 8);
  else if (rop.mode == FPREG)
    mask = 1 << (rop.reg - FP0 + 16);
  else if (rop.mode == CONTROL
	   && rop.reg == FPI)
    mask = 1 << 24;
  else if (rop.mode == CONTROL
	   && rop.reg == FPS)
    mask = 1 << 25;
  else if (rop.mode == CONTROL
	   && rop.reg == FPC)
    mask = 1 << 26;
  else
    {
      as_bad (_("bad register list"));
      ignore_rest_of_line ();
      return;
    }

  S_SET_SEGMENT (line_label, reg_section);
  S_SET_VALUE (line_label, ~mask);
  symbol_set_frag (line_label, &zero_address_frag);

  if (flag_mri)
    mri_comment_end (stop, stopc);

  demand_empty_rest_of_line ();
}

/* This structure is used for the MRI SAVE and RESTORE pseudo-ops.  */

struct save_opts
{
  struct save_opts *next;
  int abspcadd;
  int symbols_case_sensitive;
  int keep_locals;
  int short_refs;
  int architecture;
  const enum m68k_register *control_regs;
  int quick;
  int rel32;
  int listing;
  int no_warnings;
  /* FIXME: We don't save OPT S.  */
};

/* This variable holds the stack of saved options.  */

static struct save_opts *save_stack;

/* The MRI SAVE pseudo-op.  */

static void
s_save (int ignore ATTRIBUTE_UNUSED)
{
  struct save_opts *s;

  s = (struct save_opts *) xmalloc (sizeof (struct save_opts));
  s->abspcadd = m68k_abspcadd;
  s->symbols_case_sensitive = symbols_case_sensitive;
  s->keep_locals = flag_keep_locals;
  s->short_refs = flag_short_refs;
  s->architecture = current_architecture;
  s->control_regs = control_regs;
  s->quick = m68k_quick;
  s->rel32 = m68k_rel32;
  s->listing = listing;
  s->no_warnings = flag_no_warnings;

  s->next = save_stack;
  save_stack = s;

  demand_empty_rest_of_line ();
}

/* The MRI RESTORE pseudo-op.  */

static void
s_restore (int ignore ATTRIBUTE_UNUSED)
{
  struct save_opts *s;

  if (save_stack == NULL)
    {
      as_bad (_("restore without save"));
      ignore_rest_of_line ();
      return;
    }

  s = save_stack;
  save_stack = s->next;

  m68k_abspcadd = s->abspcadd;
  symbols_case_sensitive = s->symbols_case_sensitive;
  flag_keep_locals = s->keep_locals;
  flag_short_refs = s->short_refs;
  current_architecture = s->architecture;
  control_regs = s->control_regs;
  m68k_quick = s->quick;
  m68k_rel32 = s->rel32;
  listing = s->listing;
  flag_no_warnings = s->no_warnings;

  free (s);

  demand_empty_rest_of_line ();
}

/* Types of MRI structured control directives.  */

enum mri_control_type
{
  mri_for,
  mri_if,
  mri_repeat,
  mri_while
};

/* This structure is used to stack the MRI structured control
   directives.  */

struct mri_control_info
{
  /* The directive within which this one is enclosed.  */
  struct mri_control_info *outer;

  /* The type of directive.  */
  enum mri_control_type type;

  /* Whether an ELSE has been in an IF.  */
  int else_seen;

  /* The add or sub statement at the end of a FOR.  */
  char *incr;

  /* The label of the top of a FOR or REPEAT loop.  */
  char *top;

  /* The label to jump to for the next iteration, or the else
     expression of a conditional.  */
  char *next;

  /* The label to jump to to break out of the loop, or the label past
     the end of a conditional.  */
  char *bottom;
};

/* The stack of MRI structured control directives.  */

static struct mri_control_info *mri_control_stack;

/* The current MRI structured control directive index number, used to
   generate label names.  */

static int mri_control_index;

/* Assemble an instruction for an MRI structured control directive.  */

static void
mri_assemble (char *str)
{
  char *s;

  /* md_assemble expects the opcode to be in lower case.  */
  for (s = str; *s != ' ' && *s != '\0'; s++)
    *s = TOLOWER (*s);

  md_assemble (str);
}

/* Generate a new MRI label structured control directive label name.  */

static char *
mri_control_label (void)
{
  char *n;

  n = (char *) xmalloc (20);
  sprintf (n, "%smc%d", FAKE_LABEL_NAME, mri_control_index);
  ++mri_control_index;
  return n;
}

/* Create a new MRI structured control directive.  */

static struct mri_control_info *
push_mri_control (enum mri_control_type type)
{
  struct mri_control_info *n;

  n = (struct mri_control_info *) xmalloc (sizeof (struct mri_control_info));

  n->type = type;
  n->else_seen = 0;
  if (type == mri_if || type == mri_while)
    n->top = NULL;
  else
    n->top = mri_control_label ();
  n->next = mri_control_label ();
  n->bottom = mri_control_label ();

  n->outer = mri_control_stack;
  mri_control_stack = n;

  return n;
}

/* Pop off the stack of MRI structured control directives.  */

static void
pop_mri_control (void)
{
  struct mri_control_info *n;

  n = mri_control_stack;
  mri_control_stack = n->outer;
  if (n->top != NULL)
    free (n->top);
  free (n->next);
  free (n->bottom);
  free (n);
}

/* Recognize a condition code in an MRI structured control expression.  */

static int
parse_mri_condition (int *pcc)
{
  char c1, c2;

  know (*input_line_pointer == '<');

  ++input_line_pointer;
  c1 = *input_line_pointer++;
  c2 = *input_line_pointer++;

  if (*input_line_pointer != '>')
    {
      as_bad (_("syntax error in structured control directive"));
      return 0;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  c1 = TOLOWER (c1);
  c2 = TOLOWER (c2);

  *pcc = (c1 << 8) | c2;

  return 1;
}

/* Parse a single operand in an MRI structured control expression.  */

static int
parse_mri_control_operand (int *pcc, char **leftstart, char **leftstop,
			   char **rightstart, char **rightstop)
{
  char *s;

  SKIP_WHITESPACE ();

  *pcc = -1;
  *leftstart = NULL;
  *leftstop = NULL;
  *rightstart = NULL;
  *rightstop = NULL;

  if (*input_line_pointer == '<')
    {
      /* It's just a condition code.  */
      return parse_mri_condition (pcc);
    }

  /* Look ahead for the condition code.  */
  for (s = input_line_pointer; *s != '\0'; ++s)
    {
      if (*s == '<' && s[1] != '\0' && s[2] != '\0' && s[3] == '>')
	break;
    }
  if (*s == '\0')
    {
      as_bad (_("missing condition code in structured control directive"));
      return 0;
    }

  *leftstart = input_line_pointer;
  *leftstop = s;
  if (*leftstop > *leftstart
      && ((*leftstop)[-1] == ' ' || (*leftstop)[-1] == '\t'))
    --*leftstop;

  input_line_pointer = s;
  if (! parse_mri_condition (pcc))
    return 0;

  /* Look ahead for AND or OR or end of line.  */
  for (s = input_line_pointer; *s != '\0'; ++s)
    {
      /* We must make sure we don't misinterpret AND/OR at the end of labels!
         if d0 <eq> #FOOAND and d1 <ne> #BAROR then
                        ^^^                 ^^ */
      if ((s == input_line_pointer
	   || *(s-1) == ' '
	   || *(s-1) == '\t')
	  && ((strncasecmp (s, "AND", 3) == 0
	       && (s[3] == '.' || ! is_part_of_name (s[3])))
	      || (strncasecmp (s, "OR", 2) == 0
		  && (s[2] == '.' || ! is_part_of_name (s[2])))))
	break;
    }

  *rightstart = input_line_pointer;
  *rightstop = s;
  if (*rightstop > *rightstart
      && ((*rightstop)[-1] == ' ' || (*rightstop)[-1] == '\t'))
    --*rightstop;

  input_line_pointer = s;

  return 1;
}

#define MCC(b1, b2) (((b1) << 8) | (b2))

/* Swap the sense of a condition.  This changes the condition so that
   it generates the same result when the operands are swapped.  */

static int
swap_mri_condition (int cc)
{
  switch (cc)
    {
    case MCC ('h', 'i'): return MCC ('c', 's');
    case MCC ('l', 's'): return MCC ('c', 'c');
    /* <HS> is an alias for <CC>.  */
    case MCC ('h', 's'):
    case MCC ('c', 'c'): return MCC ('l', 's');
    /* <LO> is an alias for <CS>.  */
    case MCC ('l', 'o'):
    case MCC ('c', 's'): return MCC ('h', 'i');
    case MCC ('p', 'l'): return MCC ('m', 'i');
    case MCC ('m', 'i'): return MCC ('p', 'l');
    case MCC ('g', 'e'): return MCC ('l', 'e');
    case MCC ('l', 't'): return MCC ('g', 't');
    case MCC ('g', 't'): return MCC ('l', 't');
    case MCC ('l', 'e'): return MCC ('g', 'e');
    /* Issue a warning for conditions we can not swap.  */
    case MCC ('n', 'e'): return MCC ('n', 'e'); /* no problem here */
    case MCC ('e', 'q'): return MCC ('e', 'q'); /* also no problem */
    case MCC ('v', 'c'):
    case MCC ('v', 's'):
    default :
	   as_warn (_("Condition <%c%c> in structured control directive can not be encoded correctly"),
		         (char) (cc >> 8), (char) (cc));
      break;
    }
  return cc;
}

/* Reverse the sense of a condition.  */

static int
reverse_mri_condition (int cc)
{
  switch (cc)
    {
    case MCC ('h', 'i'): return MCC ('l', 's');
    case MCC ('l', 's'): return MCC ('h', 'i');
    /* <HS> is an alias for <CC> */
    case MCC ('h', 's'): return MCC ('l', 'o');
    case MCC ('c', 'c'): return MCC ('c', 's');
    /* <LO> is an alias for <CS> */
    case MCC ('l', 'o'): return MCC ('h', 's');
    case MCC ('c', 's'): return MCC ('c', 'c');
    case MCC ('n', 'e'): return MCC ('e', 'q');
    case MCC ('e', 'q'): return MCC ('n', 'e');
    case MCC ('v', 'c'): return MCC ('v', 's');
    case MCC ('v', 's'): return MCC ('v', 'c');
    case MCC ('p', 'l'): return MCC ('m', 'i');
    case MCC ('m', 'i'): return MCC ('p', 'l');
    case MCC ('g', 'e'): return MCC ('l', 't');
    case MCC ('l', 't'): return MCC ('g', 'e');
    case MCC ('g', 't'): return MCC ('l', 'e');
    case MCC ('l', 'e'): return MCC ('g', 't');
    }
  return cc;
}

/* Build an MRI structured control expression.  This generates test
   and branch instructions.  It goes to TRUELAB if the condition is
   true, and to FALSELAB if the condition is false.  Exactly one of
   TRUELAB and FALSELAB will be NULL, meaning to fall through.  QUAL
   is the size qualifier for the expression.  EXTENT is the size to
   use for the branch.  */

static void
build_mri_control_operand (int qual, int cc, char *leftstart, char *leftstop,
			   char *rightstart, char *rightstop,
			   const char *truelab, const char *falselab,
			   int extent)
{
  char *buf;
  char *s;

  if (leftstart != NULL)
    {
      struct m68k_op leftop, rightop;
      char c;

      /* Swap the compare operands, if necessary, to produce a legal
	 m68k compare instruction.  Comparing a register operand with
	 a non-register operand requires the register to be on the
	 right (cmp, cmpa).  Comparing an immediate value with
	 anything requires the immediate value to be on the left
	 (cmpi).  */

      c = *leftstop;
      *leftstop = '\0';
      (void) m68k_ip_op (leftstart, &leftop);
      *leftstop = c;

      c = *rightstop;
      *rightstop = '\0';
      (void) m68k_ip_op (rightstart, &rightop);
      *rightstop = c;

      if (rightop.mode == IMMED
	  || ((leftop.mode == DREG || leftop.mode == AREG)
	      && (rightop.mode != DREG && rightop.mode != AREG)))
	{
	  char *temp;

	  /* Correct conditional handling:
	     if #1 <lt> d0 then  ;means if (1 < d0)
		...
	     endi

	     should assemble to:

		cmp #1,d0        if we do *not* swap the operands
		bgt true         we need the swapped condition!
		ble false
	     true:
		...
	     false:
	  */
	  temp = leftstart;
	  leftstart = rightstart;
	  rightstart = temp;
	  temp = leftstop;
	  leftstop = rightstop;
	  rightstop = temp;
	}
      else
	{
	  cc = swap_mri_condition (cc);
	}
    }

  if (truelab == NULL)
    {
      cc = reverse_mri_condition (cc);
      truelab = falselab;
    }

  if (leftstart != NULL)
    {
      buf = (char *) xmalloc (20
			      + (leftstop - leftstart)
			      + (rightstop - rightstart));
      s = buf;
      *s++ = 'c';
      *s++ = 'm';
      *s++ = 'p';
      if (qual != '\0')
	*s++ = TOLOWER (qual);
      *s++ = ' ';
      memcpy (s, leftstart, leftstop - leftstart);
      s += leftstop - leftstart;
      *s++ = ',';
      memcpy (s, rightstart, rightstop - rightstart);
      s += rightstop - rightstart;
      *s = '\0';
      mri_assemble (buf);
      free (buf);
    }

  buf = (char *) xmalloc (20 + strlen (truelab));
  s = buf;
  *s++ = 'b';
  *s++ = cc >> 8;
  *s++ = cc & 0xff;
  if (extent != '\0')
    *s++ = TOLOWER (extent);
  *s++ = ' ';
  strcpy (s, truelab);
  mri_assemble (buf);
  free (buf);
}

/* Parse an MRI structured control expression.  This generates test
   and branch instructions.  STOP is where the expression ends.  It
   goes to TRUELAB if the condition is true, and to FALSELAB if the
   condition is false.  Exactly one of TRUELAB and FALSELAB will be
   NULL, meaning to fall through.  QUAL is the size qualifier for the
   expression.  EXTENT is the size to use for the branch.  */

static void
parse_mri_control_expression (char *stop, int qual, const char *truelab,
			      const char *falselab, int extent)
{
  int c;
  int cc;
  char *leftstart;
  char *leftstop;
  char *rightstart;
  char *rightstop;

  c = *stop;
  *stop = '\0';

  if (! parse_mri_control_operand (&cc, &leftstart, &leftstop,
				   &rightstart, &rightstop))
    {
      *stop = c;
      return;
    }

  if (strncasecmp (input_line_pointer, "AND", 3) == 0)
    {
      const char *flab;

      if (falselab != NULL)
	flab = falselab;
      else
	flab = mri_control_label ();

      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, (const char *) NULL, flab, extent);

      input_line_pointer += 3;
      if (*input_line_pointer != '.'
	  || input_line_pointer[1] == '\0')
	qual = '\0';
      else
	{
	  qual = input_line_pointer[1];
	  input_line_pointer += 2;
	}

      if (! parse_mri_control_operand (&cc, &leftstart, &leftstop,
				       &rightstart, &rightstop))
	{
	  *stop = c;
	  return;
	}

      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, truelab, falselab, extent);

      if (falselab == NULL)
	colon (flab);
    }
  else if (strncasecmp (input_line_pointer, "OR", 2) == 0)
    {
      const char *tlab;

      if (truelab != NULL)
	tlab = truelab;
      else
	tlab = mri_control_label ();

      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, tlab, (const char *) NULL, extent);

      input_line_pointer += 2;
      if (*input_line_pointer != '.'
	  || input_line_pointer[1] == '\0')
	qual = '\0';
      else
	{
	  qual = input_line_pointer[1];
	  input_line_pointer += 2;
	}

      if (! parse_mri_control_operand (&cc, &leftstart, &leftstop,
				       &rightstart, &rightstop))
	{
	  *stop = c;
	  return;
	}

      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, truelab, falselab, extent);

      if (truelab == NULL)
	colon (tlab);
    }
  else
    {
      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, truelab, falselab, extent);
    }

  *stop = c;
  if (input_line_pointer != stop)
    as_bad (_("syntax error in structured control directive"));
}

/* Handle the MRI IF pseudo-op.  This may be a structured control
   directive, or it may be a regular assembler conditional, depending
   on its operands.  */

static void
s_mri_if (int qual)
{
  char *s;
  int c;
  struct mri_control_info *n;

  /* A structured control directive must end with THEN with an
     optional qualifier.  */
  s = input_line_pointer;
  /* We only accept '*' as introduction of comments if preceded by white space
     or at first column of a line (I think this can't actually happen here?)
     This is important when assembling:
       if d0 <ne> 12(a0,d0*2) then
       if d0 <ne> #CONST*20   then.  */
  while (! (is_end_of_line[(unsigned char) *s]
            || (flag_mri
                && *s == '*'
                && (s == input_line_pointer
                    || *(s-1) == ' '
                    || *(s-1) == '\t'))))
    ++s;
  --s;
  while (s > input_line_pointer && (*s == ' ' || *s == '\t'))
    --s;

  if (s - input_line_pointer > 1
      && s[-1] == '.')
    s -= 2;

  if (s - input_line_pointer < 3
      || strncasecmp (s - 3, "THEN", 4) != 0)
    {
      if (qual != '\0')
	{
	  as_bad (_("missing then"));
	  ignore_rest_of_line ();
	  return;
	}

      /* It's a conditional.  */
      s_if (O_ne);
      return;
    }

  /* Since this might be a conditional if, this pseudo-op will be
     called even if we are supported to be ignoring input.  Double
     check now.  Clobber *input_line_pointer so that ignore_input
     thinks that this is not a special pseudo-op.  */
  c = *input_line_pointer;
  *input_line_pointer = 0;
  if (ignore_input ())
    {
      *input_line_pointer = c;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  *input_line_pointer = c;

  n = push_mri_control (mri_if);

  parse_mri_control_expression (s - 3, qual, (const char *) NULL,
				n->next, s[1] == '.' ? s[2] : '\0');

  if (s[1] == '.')
    input_line_pointer = s + 3;
  else
    input_line_pointer = s + 1;

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI else pseudo-op.  If we are currently doing an MRI
   structured IF, associate the ELSE with the IF.  Otherwise, assume
   it is a conditional else.  */

static void
s_mri_else (int qual)
{
  int c;
  char *buf;
  char q[2];

  if (qual == '\0'
      && (mri_control_stack == NULL
	  || mri_control_stack->type != mri_if
	  || mri_control_stack->else_seen))
    {
      s_else (0);
      return;
    }

  c = *input_line_pointer;
  *input_line_pointer = 0;
  if (ignore_input ())
    {
      *input_line_pointer = c;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  *input_line_pointer = c;

  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_if
      || mri_control_stack->else_seen)
    {
      as_bad (_("else without matching if"));
      ignore_rest_of_line ();
      return;
    }

  mri_control_stack->else_seen = 1;

  buf = (char *) xmalloc (20 + strlen (mri_control_stack->bottom));
  q[0] = TOLOWER (qual);
  q[1] = '\0';
  sprintf (buf, "bra%s %s", q, mri_control_stack->bottom);
  mri_assemble (buf);
  free (buf);

  colon (mri_control_stack->next);

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI ENDI pseudo-op.  */

static void
s_mri_endi (int ignore ATTRIBUTE_UNUSED)
{
  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_if)
    {
      as_bad (_("endi without matching if"));
      ignore_rest_of_line ();
      return;
    }

  /* ignore_input will not return true for ENDI, so we don't need to
     worry about checking it again here.  */

  if (! mri_control_stack->else_seen)
    colon (mri_control_stack->next);
  colon (mri_control_stack->bottom);

  pop_mri_control ();

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI BREAK pseudo-op.  */

static void
s_mri_break (int extent)
{
  struct mri_control_info *n;
  char *buf;
  char ex[2];

  n = mri_control_stack;
  while (n != NULL
	 && n->type != mri_for
	 && n->type != mri_repeat
	 && n->type != mri_while)
    n = n->outer;
  if (n == NULL)
    {
      as_bad (_("break outside of structured loop"));
      ignore_rest_of_line ();
      return;
    }

  buf = (char *) xmalloc (20 + strlen (n->bottom));
  ex[0] = TOLOWER (extent);
  ex[1] = '\0';
  sprintf (buf, "bra%s %s", ex, n->bottom);
  mri_assemble (buf);
  free (buf);

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI NEXT pseudo-op.  */

static void
s_mri_next (int extent)
{
  struct mri_control_info *n;
  char *buf;
  char ex[2];

  n = mri_control_stack;
  while (n != NULL
	 && n->type != mri_for
	 && n->type != mri_repeat
	 && n->type != mri_while)
    n = n->outer;
  if (n == NULL)
    {
      as_bad (_("next outside of structured loop"));
      ignore_rest_of_line ();
      return;
    }

  buf = (char *) xmalloc (20 + strlen (n->next));
  ex[0] = TOLOWER (extent);
  ex[1] = '\0';
  sprintf (buf, "bra%s %s", ex, n->next);
  mri_assemble (buf);
  free (buf);

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI FOR pseudo-op.  */

static void
s_mri_for (int qual)
{
  const char *varstart, *varstop;
  const char *initstart, *initstop;
  const char *endstart, *endstop;
  const char *bystart, *bystop;
  int up;
  int by;
  int extent;
  struct mri_control_info *n;
  char *buf;
  char *s;
  char ex[2];

  /* The syntax is
       FOR.q var = init { TO | DOWNTO } end [ BY by ] DO.e
     */

  SKIP_WHITESPACE ();
  varstart = input_line_pointer;

  /* Look for the '='.  */
  while (! is_end_of_line[(unsigned char) *input_line_pointer]
	 && *input_line_pointer != '=')
    ++input_line_pointer;
  if (*input_line_pointer != '=')
    {
      as_bad (_("missing ="));
      ignore_rest_of_line ();
      return;
    }

  varstop = input_line_pointer;
  if (varstop > varstart
      && (varstop[-1] == ' ' || varstop[-1] == '\t'))
    --varstop;

  ++input_line_pointer;

  initstart = input_line_pointer;

  /* Look for TO or DOWNTO.  */
  up = 1;
  initstop = NULL;
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (strncasecmp (input_line_pointer, "TO", 2) == 0
	  && ! is_part_of_name (input_line_pointer[2]))
	{
	  initstop = input_line_pointer;
	  input_line_pointer += 2;
	  break;
	}
      if (strncasecmp (input_line_pointer, "DOWNTO", 6) == 0
	  && ! is_part_of_name (input_line_pointer[6]))
	{
	  initstop = input_line_pointer;
	  up = 0;
	  input_line_pointer += 6;
	  break;
	}
      ++input_line_pointer;
    }
  if (initstop == NULL)
    {
      as_bad (_("missing to or downto"));
      ignore_rest_of_line ();
      return;
    }
  if (initstop > initstart
      && (initstop[-1] == ' ' || initstop[-1] == '\t'))
    --initstop;

  SKIP_WHITESPACE ();
  endstart = input_line_pointer;

  /* Look for BY or DO.  */
  by = 0;
  endstop = NULL;
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (strncasecmp (input_line_pointer, "BY", 2) == 0
	  && ! is_part_of_name (input_line_pointer[2]))
	{
	  endstop = input_line_pointer;
	  by = 1;
	  input_line_pointer += 2;
	  break;
	}
      if (strncasecmp (input_line_pointer, "DO", 2) == 0
	  && (input_line_pointer[2] == '.'
	      || ! is_part_of_name (input_line_pointer[2])))
	{
	  endstop = input_line_pointer;
	  input_line_pointer += 2;
	  break;
	}
      ++input_line_pointer;
    }
  if (endstop == NULL)
    {
      as_bad (_("missing do"));
      ignore_rest_of_line ();
      return;
    }
  if (endstop > endstart
      && (endstop[-1] == ' ' || endstop[-1] == '\t'))
    --endstop;

  if (! by)
    {
      bystart = "#1";
      bystop = bystart + 2;
    }
  else
    {
      SKIP_WHITESPACE ();
      bystart = input_line_pointer;

      /* Look for DO.  */
      bystop = NULL;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	{
	  if (strncasecmp (input_line_pointer, "DO", 2) == 0
	      && (input_line_pointer[2] == '.'
		  || ! is_part_of_name (input_line_pointer[2])))
	    {
	      bystop = input_line_pointer;
	      input_line_pointer += 2;
	      break;
	    }
	  ++input_line_pointer;
	}
      if (bystop == NULL)
	{
	  as_bad (_("missing do"));
	  ignore_rest_of_line ();
	  return;
	}
      if (bystop > bystart
	  && (bystop[-1] == ' ' || bystop[-1] == '\t'))
	--bystop;
    }

  if (*input_line_pointer != '.')
    extent = '\0';
  else
    {
      extent = input_line_pointer[1];
      input_line_pointer += 2;
    }

  /* We have fully parsed the FOR operands.  Now build the loop.  */
  n = push_mri_control (mri_for);

  buf = (char *) xmalloc (50 + (input_line_pointer - varstart));

  /* Move init,var.  */
  s = buf;
  *s++ = 'm';
  *s++ = 'o';
  *s++ = 'v';
  *s++ = 'e';
  if (qual != '\0')
    *s++ = TOLOWER (qual);
  *s++ = ' ';
  memcpy (s, initstart, initstop - initstart);
  s += initstop - initstart;
  *s++ = ',';
  memcpy (s, varstart, varstop - varstart);
  s += varstop - varstart;
  *s = '\0';
  mri_assemble (buf);

  colon (n->top);

  /* cmp end,var.  */
  s = buf;
  *s++ = 'c';
  *s++ = 'm';
  *s++ = 'p';
  if (qual != '\0')
    *s++ = TOLOWER (qual);
  *s++ = ' ';
  memcpy (s, endstart, endstop - endstart);
  s += endstop - endstart;
  *s++ = ',';
  memcpy (s, varstart, varstop - varstart);
  s += varstop - varstart;
  *s = '\0';
  mri_assemble (buf);

  /* bcc bottom.  */
  ex[0] = TOLOWER (extent);
  ex[1] = '\0';
  if (up)
    sprintf (buf, "blt%s %s", ex, n->bottom);
  else
    sprintf (buf, "bgt%s %s", ex, n->bottom);
  mri_assemble (buf);

  /* Put together the add or sub instruction used by ENDF.  */
  s = buf;
  if (up)
    strcpy (s, "add");
  else
    strcpy (s, "sub");
  s += 3;
  if (qual != '\0')
    *s++ = TOLOWER (qual);
  *s++ = ' ';
  memcpy (s, bystart, bystop - bystart);
  s += bystop - bystart;
  *s++ = ',';
  memcpy (s, varstart, varstop - varstart);
  s += varstop - varstart;
  *s = '\0';
  n->incr = buf;

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI ENDF pseudo-op.  */

static void
s_mri_endf (int ignore ATTRIBUTE_UNUSED)
{
  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_for)
    {
      as_bad (_("endf without for"));
      ignore_rest_of_line ();
      return;
    }

  colon (mri_control_stack->next);

  mri_assemble (mri_control_stack->incr);

  sprintf (mri_control_stack->incr, "bra %s", mri_control_stack->top);
  mri_assemble (mri_control_stack->incr);

  free (mri_control_stack->incr);

  colon (mri_control_stack->bottom);

  pop_mri_control ();

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI REPEAT pseudo-op.  */

static void
s_mri_repeat (int ignore ATTRIBUTE_UNUSED)
{
  struct mri_control_info *n;

  n = push_mri_control (mri_repeat);
  colon (n->top);
  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }
  demand_empty_rest_of_line ();
}

/* Handle the MRI UNTIL pseudo-op.  */

static void
s_mri_until (int qual)
{
  char *s;

  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_repeat)
    {
      as_bad (_("until without repeat"));
      ignore_rest_of_line ();
      return;
    }

  colon (mri_control_stack->next);

  for (s = input_line_pointer; ! is_end_of_line[(unsigned char) *s]; s++)
    ;

  parse_mri_control_expression (s, qual, (const char *) NULL,
				mri_control_stack->top, '\0');

  colon (mri_control_stack->bottom);

  input_line_pointer = s;

  pop_mri_control ();

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI WHILE pseudo-op.  */

static void
s_mri_while (int qual)
{
  char *s;

  struct mri_control_info *n;

  s = input_line_pointer;
  /* We only accept '*' as introduction of comments if preceded by white space
     or at first column of a line (I think this can't actually happen here?)
     This is important when assembling:
       while d0 <ne> 12(a0,d0*2) do
       while d0 <ne> #CONST*20   do.  */
  while (! (is_end_of_line[(unsigned char) *s]
	    || (flag_mri
		&& *s == '*'
		&& (s == input_line_pointer
		    || *(s-1) == ' '
		    || *(s-1) == '\t'))))
    s++;
  --s;
  while (*s == ' ' || *s == '\t')
    --s;
  if (s - input_line_pointer > 1
      && s[-1] == '.')
    s -= 2;
  if (s - input_line_pointer < 2
      || strncasecmp (s - 1, "DO", 2) != 0)
    {
      as_bad (_("missing do"));
      ignore_rest_of_line ();
      return;
    }

  n = push_mri_control (mri_while);

  colon (n->next);

  parse_mri_control_expression (s - 1, qual, (const char *) NULL, n->bottom,
				s[1] == '.' ? s[2] : '\0');

  input_line_pointer = s + 1;
  if (*input_line_pointer == '.')
    input_line_pointer += 2;

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI ENDW pseudo-op.  */

static void
s_mri_endw (int ignore ATTRIBUTE_UNUSED)
{
  char *buf;

  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_while)
    {
      as_bad (_("endw without while"));
      ignore_rest_of_line ();
      return;
    }

  buf = (char *) xmalloc (20 + strlen (mri_control_stack->next));
  sprintf (buf, "bra %s", mri_control_stack->next);
  mri_assemble (buf);
  free (buf);

  colon (mri_control_stack->bottom);

  pop_mri_control ();

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Parse a .cpu directive.  */

static void
s_m68k_cpu (int ignored ATTRIBUTE_UNUSED)
{
  char saved_char;
  char *name;

  if (initialized)
    {
      as_bad (_("already assembled instructions"));
      ignore_rest_of_line ();
      return;
    }
  
  name = input_line_pointer;
  while (*input_line_pointer && !ISSPACE(*input_line_pointer))
    input_line_pointer++;
  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  m68k_set_cpu (name, 1, 0);
  
  *input_line_pointer = saved_char;
  demand_empty_rest_of_line ();
  return;
}

/* Parse a .arch directive.  */

static void
s_m68k_arch (int ignored ATTRIBUTE_UNUSED)
{
  char saved_char;
  char *name;

  if (initialized)
    {
      as_bad (_("already assembled instructions"));
      ignore_rest_of_line ();
      return;
    }
  
  name = input_line_pointer;
  while (*input_line_pointer && *input_line_pointer != ','
	 && !ISSPACE (*input_line_pointer))
    input_line_pointer++;
  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  if (m68k_set_arch (name, 1, 0))
    {
      /* Scan extensions. */
      do
	{
	  *input_line_pointer++ = saved_char;
	  if (!*input_line_pointer || ISSPACE (*input_line_pointer))
	    break;
	  name = input_line_pointer;
	  while (*input_line_pointer && *input_line_pointer != ','
		 && !ISSPACE (*input_line_pointer))
	    input_line_pointer++;
	  saved_char = *input_line_pointer;
	  *input_line_pointer = 0;
	}
      while (m68k_set_extension (name, 1, 0));
    }
  
  *input_line_pointer = saved_char;
  demand_empty_rest_of_line ();
  return;
}

/* Lookup a cpu name in TABLE and return the slot found.  Return NULL
   if none is found, the caller is responsible for emitting an error
   message.  If ALLOW_M is non-zero, we allow an initial 'm' on the
   cpu name, if it begins with a '6' (possibly skipping an intervening
   'c'.  We also allow a 'c' in the same place.  if NEGATED is
   non-zero, we accept a leading 'no-' and *NEGATED is set to true, if
   the option is indeed negated.  */

static const struct m68k_cpu *
m68k_lookup_cpu (const char *arg, const struct m68k_cpu *table,
		 int allow_m, int *negated)
{
  /* allow negated value? */
  if (negated)
    {
      *negated = 0;

      if (arg[0] == 'n' && arg[1] == 'o' && arg[2] == '-')
	{
	  arg += 3;
	  *negated = 1;
	}
    }
  
  /* Remove 'm' or 'mc' prefix from 68k variants.  */
  if (allow_m)
    {
      if (arg[0] == 'm')
	{
	  if (arg[1] == '6')
	    arg += 1;
	  else if (arg[1] == 'c'  && arg[2] == '6')
	    arg += 2;
	}
    }
  else if (arg[0] == 'c' && arg[1] == '6')
    arg += 1;

  for (; table->name; table++)
    if (!strcmp (arg, table->name))
      {
	if (table->alias < -1 || table->alias > 1)
	  as_bad (_("`%s' is deprecated, use `%s'"),
		  table->name, table[table->alias < 0 ? 1 : -1].name);
	return table;
      }
  return 0;
}

/* Set the cpu, issuing errors if it is unrecognized.  */

static int
m68k_set_cpu (char const *name, int allow_m, int silent)
{
  const struct m68k_cpu *cpu;

  cpu = m68k_lookup_cpu (name, m68k_cpus, allow_m, NULL);

  if (!cpu)
    {
      if (!silent)
	as_bad (_("cpu `%s' unrecognized"), name);
      return 0;
    }
  selected_cpu = cpu;
  return 1;
}

/* Set the architecture, issuing errors if it is unrecognized.  */

static int
m68k_set_arch (char const *name, int allow_m, int silent)
{
  const struct m68k_cpu *arch;

  arch = m68k_lookup_cpu (name, m68k_archs, allow_m, NULL);

  if (!arch)
    {
      if (!silent)
	as_bad (_("architecture `%s' unrecognized"), name);
      return 0;
    }
  selected_arch = arch;
  return 1;
}

/* Set the architecture extension, issuing errors if it is
   unrecognized, or invalid */

static int
m68k_set_extension (char const *name, int allow_m, int silent)
{
  int negated;
  const struct m68k_cpu *ext;

  ext = m68k_lookup_cpu (name, m68k_extensions, allow_m, &negated);

  if (!ext)
    {
      if (!silent)
	as_bad (_("extension `%s' unrecognized"), name);
      return 0;
    }

  if (negated)
    not_current_architecture |= (ext->control_regs
				 ? *(unsigned *)ext->control_regs: ext->arch);
  else
    current_architecture |= ext->arch;
  return 1;
}

/* md_parse_option
   Invocation line includes a switch not recognized by the base assembler.
 */

#ifdef OBJ_ELF
const char *md_shortopts = "lSA:m:kQ:V";
#else
const char *md_shortopts = "lSA:m:k";
#endif

struct option md_longopts[] = {
#define OPTION_PIC (OPTION_MD_BASE)
  {"pic", no_argument, NULL, OPTION_PIC},
#define OPTION_REGISTER_PREFIX_OPTIONAL (OPTION_MD_BASE + 1)
  {"register-prefix-optional", no_argument, NULL,
     OPTION_REGISTER_PREFIX_OPTIONAL},
#define OPTION_BITWISE_OR (OPTION_MD_BASE + 2)
  {"bitwise-or", no_argument, NULL, OPTION_BITWISE_OR},
#define OPTION_BASE_SIZE_DEFAULT_16 (OPTION_MD_BASE + 3)
  {"base-size-default-16", no_argument, NULL, OPTION_BASE_SIZE_DEFAULT_16},
#define OPTION_BASE_SIZE_DEFAULT_32 (OPTION_MD_BASE + 4)
  {"base-size-default-32", no_argument, NULL, OPTION_BASE_SIZE_DEFAULT_32},
#define OPTION_DISP_SIZE_DEFAULT_16 (OPTION_MD_BASE + 5)
  {"disp-size-default-16", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_16},
#define OPTION_DISP_SIZE_DEFAULT_32 (OPTION_MD_BASE + 6)
  {"disp-size-default-32", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_32},
#define OPTION_PCREL (OPTION_MD_BASE + 7)
  {"pcrel", no_argument, NULL, OPTION_PCREL},
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case 'l':			/* -l means keep external to 2 bit offset
				   rather than 16 bit one.  */
      flag_short_refs = 1;
      break;

    case 'S':			/* -S means that jbsr's always turn into
				   jsr's.  */
      flag_long_jumps = 1;
      break;

    case OPTION_PCREL:		/* --pcrel means never turn PC-relative
				   branches into absolute jumps.  */
      flag_keep_pcrel = 1;
      break;

    case OPTION_PIC:
    case 'k':
      flag_want_pic = 1;
      break;			/* -pic, Position Independent Code.  */

    case OPTION_REGISTER_PREFIX_OPTIONAL:
      flag_reg_prefix_optional = 1;
      reg_prefix_optional_seen = 1;
      break;

      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;

      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

    case OPTION_BITWISE_OR:
      {
	char *n, *t;
	const char *s;

	n = (char *) xmalloc (strlen (m68k_comment_chars) + 1);
	t = n;
	for (s = m68k_comment_chars; *s != '\0'; s++)
	  if (*s != '|')
	    *t++ = *s;
	*t = '\0';
	m68k_comment_chars = n;
      }
      break;

    case OPTION_BASE_SIZE_DEFAULT_16:
      m68k_index_width_default = SIZE_WORD;
      break;

    case OPTION_BASE_SIZE_DEFAULT_32:
      m68k_index_width_default = SIZE_LONG;
      break;

    case OPTION_DISP_SIZE_DEFAULT_16:
      m68k_rel32 = 0;
      m68k_rel32_from_cmdline = 1;
      break;

    case OPTION_DISP_SIZE_DEFAULT_32:
      m68k_rel32 = 1;
      m68k_rel32_from_cmdline = 1;
      break;

    case 'A':
#if WARN_DEPRECATED
      as_tsktsk (_ ("option `-A%s' is deprecated: use `-%s'",
		    arg, arg));
#endif
      /* Intentional fall-through.  */
    case 'm':
      if (!strncmp (arg, "arch=", 5))
	m68k_set_arch (arg + 5, 1, 0);
      else if (!strncmp (arg, "cpu=", 4))
	m68k_set_cpu (arg + 4, 1, 0);
      else if (m68k_set_extension (arg, 0, 1))
	;
      else if (m68k_set_arch (arg, 0, 1))
	;
      else if (m68k_set_cpu (arg, 0, 1))
	;
      else
	return 0;
      break;

    default:
      return 0;
    }

  return 1;
}

/* Setup tables from the selected arch and/or cpu */

static void
m68k_init_arch (void)
{
  if (not_current_architecture & current_architecture)
    {
      as_bad (_("architecture features both enabled and disabled"));
      not_current_architecture &= ~current_architecture;
    }
  if (selected_arch)
    {
      current_architecture |= selected_arch->arch;
      control_regs = selected_arch->control_regs;
    }
  else
    current_architecture |= selected_cpu->arch;
  
  current_architecture &= ~not_current_architecture;

  if ((current_architecture & (cfloat | m68881)) == (cfloat | m68881))
    {
      /* Determine which float is really meant.  */
      if (current_architecture & (m68k_mask & ~m68881))
	current_architecture ^= cfloat;
      else
	current_architecture ^= m68881;
    }

  if (selected_cpu)
    {
      control_regs = selected_cpu->control_regs;
      if (current_architecture & ~selected_cpu->arch)
	{
	  as_bad (_("selected processor does not have all features of selected architecture"));
	  current_architecture
	    = selected_cpu->arch & ~not_current_architecture;
	}
    }

  if ((current_architecture & m68k_mask)
      && (current_architecture & ~m68k_mask))
    {
      as_bad (_ ("m68k and cf features both selected"));
      if (current_architecture & m68k_mask)
	current_architecture &= m68k_mask;
      else
	current_architecture &= ~m68k_mask;
    }
  
  /* Permit m68881 specification with all cpus; those that can't work
     with a coprocessor could be doing emulation.  */
  if (current_architecture & m68851)
    {
      if (current_architecture & m68040)
	as_warn (_("68040 and 68851 specified; mmu instructions may assemble incorrectly"));
    }
  /* What other incompatibilities could we check for?  */

  if (cpu_of_arch (current_architecture) < m68020
      || arch_coldfire_p (current_architecture))
    md_relax_table[TAB (PCINDEX, BYTE)].rlx_more = 0;
  
  initialized = 1;
}

void
md_show_usage (FILE *stream)
{
  const char *default_cpu = TARGET_CPU;
  int i;

  /* Get the canonical name for the default target CPU.  */
  if (*default_cpu == 'm')
    default_cpu++;
  for (i = 0; m68k_cpus[i].name; i++)
    {
      if (strcasecmp (default_cpu, m68k_cpus[i].name) == 0)
	{
	  while (m68k_cpus[i].alias > 0)
	    i--;
	  while (m68k_cpus[i].alias < 0)
	    i++;
	  default_cpu = m68k_cpus[i].name;
	}
    }

  fprintf (stream, _("\
-march=<arch>		set architecture\n\
-mcpu=<cpu>		set cpu [default %s]\n\
"), default_cpu);
  for (i = 0; m68k_extensions[i].name; i++)
    fprintf (stream, _("\
-m[no-]%-16s enable/disable%s architecture extension\n\
"), m68k_extensions[i].name,
	     m68k_extensions[i].alias > 0 ? " ColdFire"
	     : m68k_extensions[i].alias < 0 ? " m68k" : "");
  
  fprintf (stream, _("\
-l			use 1 word for refs to undefined symbols [default 2]\n\
-pic, -k		generate position independent code\n\
-S			turn jbsr into jsr\n\
--pcrel                 never turn PC-relative branches into absolute jumps\n\
--register-prefix-optional\n\
			recognize register names without prefix character\n\
--bitwise-or		do not treat `|' as a comment character\n\
--base-size-default-16	base reg without size is 16 bits\n\
--base-size-default-32	base reg without size is 32 bits (default)\n\
--disp-size-default-16	displacement with unknown size is 16 bits\n\
--disp-size-default-32	displacement with unknown size is 32 bits (default)\n\
"));
  
  fprintf (stream, _("Architecture variants are: "));
  for (i = 0; m68k_archs[i].name; i++)
    {
      if (i)
	fprintf (stream, " | ");
      fprintf (stream, "%s", m68k_archs[i].name);
    }
  fprintf (stream, "\n");

  fprintf (stream, _("Processor variants are: "));
  for (i = 0; m68k_cpus[i].name; i++)
    {
      if (i)
	fprintf (stream, " | ");
      fprintf (stream, "%s", m68k_cpus[i].name);
    }
  fprintf (stream, _("\n"));
}

#ifdef TEST2

/* TEST2:  Test md_assemble() */
/* Warning, this routine probably doesn't work anymore.  */
int
main (void)
{
  struct m68k_it the_ins;
  char buf[120];
  char *cp;
  int n;

  m68k_ip_begin ();
  for (;;)
    {
      if (!gets (buf) || !*buf)
	break;
      if (buf[0] == '|' || buf[1] == '.')
	continue;
      for (cp = buf; *cp; cp++)
	if (*cp == '\t')
	  *cp = ' ';
      if (is_label (buf))
	continue;
      memset (&the_ins, '\0', sizeof (the_ins));
      m68k_ip (&the_ins, buf);
      if (the_ins.error)
	{
	  printf (_("Error %s in %s\n"), the_ins.error, buf);
	}
      else
	{
	  printf (_("Opcode(%d.%s): "), the_ins.numo, the_ins.args);
	  for (n = 0; n < the_ins.numo; n++)
	    printf (" 0x%x", the_ins.opcode[n] & 0xffff);
	  printf ("    ");
	  print_the_insn (&the_ins.opcode[0], stdout);
	  (void) putchar ('\n');
	}
      for (n = 0; n < strlen (the_ins.args) / 2; n++)
	{
	  if (the_ins.operands[n].error)
	    {
	      printf ("op%d Error %s in %s\n", n, the_ins.operands[n].error, buf);
	      continue;
	    }
	  printf ("mode %d, reg %d, ", the_ins.operands[n].mode,
		  the_ins.operands[n].reg);
	  if (the_ins.operands[n].b_const)
	    printf ("Constant: '%.*s', ",
		    1 + the_ins.operands[n].e_const - the_ins.operands[n].b_const,
		    the_ins.operands[n].b_const);
	  printf ("ireg %d, isiz %d, imul %d, ", the_ins.operands[n].ireg,
		  the_ins.operands[n].isiz, the_ins.operands[n].imul);
	  if (the_ins.operands[n].b_iadd)
	    printf ("Iadd: '%.*s',",
		    1 + the_ins.operands[n].e_iadd - the_ins.operands[n].b_iadd,
		    the_ins.operands[n].b_iadd);
	  putchar ('\n');
	}
    }
  m68k_ip_end ();
  return 0;
}

int
is_label (char *str)
{
  while (*str == ' ')
    str++;
  while (*str && *str != ' ')
    str++;
  if (str[-1] == ':' || str[1] == '=')
    return 1;
  return 0;
}

#endif

/* Possible states for relaxation:

   0 0	branch offset	byte	(bra, etc)
   0 1			word
   0 2			long

   1 0	indexed offsets	byte	a0@@(32,d4:w:1) etc
   1 1			word
   1 2			long

   2 0	two-offset index word-word a0@@(32,d4)@@(45) etc
   2 1			word-long
   2 2			long-word
   2 3			long-long

   */

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
#ifdef OBJ_AOUT
  /* For a.out, force the section size to be aligned.  If we don't do
     this, BFD will align it for us, but it will not write out the
     final bytes of the section.  This may be a bug in BFD, but it is
     easier to fix it here since that is how the other a.out targets
     work.  */
  int align;

  align = bfd_get_section_alignment (stdoutput, segment);
  size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
#endif

  return size;
}

/* Exactly what point is a PC-relative offset relative TO?
   On the 68k, it is relative to the address of the first extension
   word.  The difference between the addresses of the offset and the
   first extension word is stored in fx_pcrel_adjust.  */
long
md_pcrel_from (fixS *fixP)
{
  int adjust;

  adjust = fixP->fx_pcrel_adjust;
  if (adjust == 64)
    adjust = -1;
  return fixP->fx_where + fixP->fx_frag->fr_address - adjust;
}

#ifdef OBJ_ELF
void
m68k_elf_final_processing (void)
{
  unsigned flags = 0;
  
  if (arch_coldfire_fpu (current_architecture))
    flags |= EF_M68K_CFV4E;
  /* Set file-specific flags if this is a cpu32 processor.  */
  if (cpu_of_arch (current_architecture) & cpu32)
    flags |= EF_M68K_CPU32;
  else if (cpu_of_arch (current_architecture) & fido_a)
    flags |= EF_M68K_FIDO;
  else if ((cpu_of_arch (current_architecture) & m68000up)
	   && !(cpu_of_arch (current_architecture) & m68020up))
    flags |= EF_M68K_M68000;
  
  if (current_architecture & mcfisa_a)
    {
      static const unsigned isa_features[][2] =
      {
	{EF_M68K_CF_ISA_A_NODIV,mcfisa_a},
	{EF_M68K_CF_ISA_A,	mcfisa_a|mcfhwdiv},
	{EF_M68K_CF_ISA_A_PLUS, mcfisa_a|mcfisa_aa|mcfhwdiv|mcfusp},
	{EF_M68K_CF_ISA_B_NOUSP,mcfisa_a|mcfisa_b|mcfhwdiv},
	{EF_M68K_CF_ISA_B,	mcfisa_a|mcfisa_b|mcfhwdiv|mcfusp},
	{EF_M68K_CF_ISA_C,	mcfisa_a|mcfisa_c|mcfhwdiv|mcfusp},
	{EF_M68K_CF_ISA_C_NODIV,mcfisa_a|mcfisa_c|mcfusp},
	{0,0},
      };
      static const unsigned mac_features[][2] =
      {
	{EF_M68K_CF_MAC, mcfmac},
	{EF_M68K_CF_EMAC, mcfemac},
	{0,0},
      };
      unsigned ix;
      unsigned pattern;
      
      pattern = (current_architecture
		 & (mcfisa_a|mcfisa_aa|mcfisa_b|mcfisa_c|mcfhwdiv|mcfusp));
      for (ix = 0; isa_features[ix][1]; ix++)
	{
	  if (pattern == isa_features[ix][1])
	    {
	      flags |= isa_features[ix][0];
	      break;
	    }
	}
      if (!isa_features[ix][1])
	{
	cf_bad:
	  as_warn (_("Not a defined coldfire architecture"));
	}
      else
	{
	  if (current_architecture & cfloat)
	    flags |= EF_M68K_CF_FLOAT | EF_M68K_CFV4E;

	  pattern = current_architecture & (mcfmac|mcfemac);
	  if (pattern)
	    {
	      for (ix = 0; mac_features[ix][1]; ix++)
		{
		  if (pattern == mac_features[ix][1])
		    {
		      flags |= mac_features[ix][0];
		      break;
		    }
		}
	      if (!mac_features[ix][1])
		goto cf_bad;
	    }
	}
    }
  elf_elfheader (stdoutput)->e_flags |= flags;
}

/* Parse @@TLSLDO and return the desired relocation.  */
static bfd_reloc_code_real_type
m68k_elf_suffix (char **str_p, expressionS *exp_p)
{
  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;

  if (*str++ != '@@')
    return BFD_RELOC_UNUSED;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (ISALNUM (ch) || ch == '@@'));
       ch = *++str)
    {
      *str2++ = ch;
    }

  *str2 = '\0';
  len = str2 - ident;

  if (strncmp (ident, "TLSLDO", 6) == 0
      && len == 6)
    {
      /* Now check for identifier@@suffix+constant.  */
      if (*str == '-' || *str == '+')
	{
	  char *orig_line = input_line_pointer;
	  expressionS new_exp;

	  input_line_pointer = str;
	  expression (&new_exp);
	  if (new_exp.X_op == O_constant)
	    {
	      exp_p->X_add_number += new_exp.X_add_number;
	      str = input_line_pointer;
	    }

	  if (&input_line_pointer != str_p)
	    input_line_pointer = orig_line;
	}
      *str_p = str;

      return BFD_RELOC_68K_TLS_LDO32;
      }

  return BFD_RELOC_UNUSED;
}

/* Handles .long <tls_symbol>+0x8000 debug info.
   Clobbers input_line_pointer, checks end-of-line.
   Adapted from tc-ppc.c:ppc_elf_cons.  */
static void
m68k_elf_cons (int nbytes /* 4=.long */)
{
  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expressionS exp;
      bfd_reloc_code_real_type reloc;

      expression (&exp);
      if (exp.X_op == O_symbol
	  && *input_line_pointer == '@@'
	  && (reloc = m68k_elf_suffix (&input_line_pointer,
				      &exp)) != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto;
	  int size;

	  reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  size = bfd_get_reloc_size (reloc_howto);

	  if (size > nbytes)
	    {
	      as_bad (_("%s relocations do not fit in %d bytes\n"),
		      reloc_howto->name, nbytes);
	    }
	  else
	    {
	      char *p;
	      int offset;

	      p = frag_more (nbytes);
	      offset = 0;
	      if (target_big_endian)
		offset = nbytes - size;
	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer--;
  demand_empty_rest_of_line ();
}
#endif

int
tc_m68k_regname_to_dw2regnum (char *regname)
{
  unsigned int regnum;
  static const char *const regnames[] =
    {
      "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
      "a0", "a1", "a2", "a3", "a4", "a5", "a6", "sp",
      "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6", "fp7",
      "pc"
    };

  for (regnum = 0; regnum < ARRAY_SIZE (regnames); regnum++)
    if (strcmp (regname, regnames[regnum]) == 0)
      return regnum;

  return -1;
}

void
tc_m68k_frame_initial_instructions (void)
{
  static int sp_regno = -1;

  if (sp_regno < 0)
    sp_regno = tc_m68k_regname_to_dw2regnum ("sp");

  cfi_add_CFA_def_cfa (sp_regno, -DWARF2_CIE_DATA_ALIGNMENT);
  cfi_add_CFA_offset (DWARF2_DEFAULT_RETURN_COLUMN, DWARF2_CIE_DATA_ALIGNMENT);
}

/* Check and emit error if broken-word handling has failed to fix up a
   case-table.	This is called from write.c, after doing everything it
   knows about how to handle broken words.  */

void
tc_m68k_check_adjusted_broken_word (offsetT new_offset, struct broken_word *brokwP)
{
  if (new_offset > 32767 || new_offset < -32768)
    as_bad_where (brokwP->frag->fr_file, brokwP->frag->fr_line,
		  _("Adjusted signed .word (%#lx) overflows: `switch'-statement too large."),
		  (long) new_offset);
}

@


1.117
log
@	* write.h (struct fix <fx_pcrel_adjust>): Make it a signed char.
	* config/tc-m68k.c (tc_gen_reloc, md_pcrel_from): Remove explicit
	sign extendion of fx_pxrel_adjust.
@
text
@d8136 14
@


1.116
log
@	* config/tc-m68k.c (m68k_cpus): Add 51ag, 51je, 51jf, 51jg, 51mm,
	51qm variants.
@
text
@d1380 1
a1380 3
		     /* Explicit sign extension in case char is
			unsigned.  */
		     + ((fixp->fx_pcrel_adjust & 0xff) ^ 0x80) - 0x80
d7912 1
a7912 3
  /* Because fx_pcrel_adjust is a char, and may be unsigned, we explicitly
     sign extend the value here.  */
  adjust = ((fixP->fx_pcrel_adjust & 0xff) ^ 0x80) - 0x80;
@


1.115
log
@        * gas/config/tc-m68k.c (tc_gen_reloc): Handle references to defined
        weak symbols first if generating an a.out object.
@
text
@d612 1
d615 3
d619 1
d621 1
@


1.114
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d1338 4
a1341 6
  if (fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else if (OUTPUT_FLAVOR == bfd_target_aout_flavour
	   && fixp->fx_addsy
	   && S_IS_WEAK (fixp->fx_addsy)
	   && ! bfd_is_und_section (S_GET_SEGMENT (fixp->fx_addsy)))
d1365 2
@


1.113
log
@	* config/m68k-parse.h (enum m68k_register): Add ACR[4-7], RGPIOBAR.
	* config/tc-m68k.c (mcf5206_ctrl): Fix whitespace.
	(mcf52223_ctrl): Remove non-existent registers.
	(mcf54418): Define.
	(mcf54455): Remove MBAR.
	(m68k_cpus): Add lines for MCF5441x family.
	(m68k_ip, init_table): Handle RGPIOBAR, ACR[4-7].

	* m68k-dis.c (print_insn_arg): Handle RGPIOBAR, ACR[4-7] and MBAR[01].
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
a7715 1
  unsigned int default_arch;
a7723 1
	  default_arch = m68k_cpus[i].arch;
@


1.112
log
@gas:
2009-10-07  Vincent Riviere  <vincent.riviere@@freesbee.fr>

        PR gas/3041
        * config/tc-m68k.c (tc_gen_reloc): Fix addend for relocations
        located in data section an referencing a weak symbol.

gas/testsuite:

2009-10-07  Vincent Riviere  <vincent.riviere@@freesbee.fr>

        PR gas/3041
        * gas/m68k/all.exp: Added "p3041data".
        * gas/m68k/p3041.d, gas/m68k/p3041.s: Added tests of weak references
        from text section to all possible sections.
        * gas/m68k/p3041data.d, gas/m68k/p3041data.s: New test. Check weak
        references from data section.
@
text
@d189 1
a189 1
  CACR, ACR0, ACR1,  VBR, RAMBAR0, RAMBAR_ALT, MBAR,
d213 1
a213 1
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, RAMBAR1,
d305 9
d316 1
a316 1
  VBR, PC, RAMBAR1, MBAR,
d320 1
a320 1
  MBAR1 /* MBAR */,  RAMBAR /* RAMBAR1 */,
d705 6
d3348 9
d4152 4
d4201 2
@


1.111
log
@	* config/tc-m68k.c (mcf5221x_ctrl): New.
	(m68k_cpu): Add line for MCF5221x.
@
text
@d1329 23
a1351 4
    /* PR gas/3041 Adjust addend in order to force bfd_install_relocation()
       to put the symbol offset into frags referencing a weak symbol.  */
    reloc->addend = fixp->fx_addnumber
		    - (S_GET_VALUE (fixp->fx_addsy) * 2);
@


1.110
log
@	* config/tc-m68k.c (mcf52235_ctrl): Remove non-existent CACR, ACR[01].
	(mcf53017_ctrl): Fix RAMBAR.
@
text
@d208 4
d629 2
@


1.109
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d213 1
a213 1
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, RAMBAR1,
d261 1
a261 1
  VBR, CACR, ACR0, ACR1, RAMBAR0, RAMBAR,
@


1.108
log
@	gas/
	* config/tc-m68k.c (mcf51qe_ctrl): Add CPUCR.
	(mcf52259_ctrl, mcf52277_ctrl, mcf53017_ctrl): New.
	(mcf5307_ctrl): Add VBR.
	(no_mac): New variable.
	(m68k_extensions): Refer to no_mac mask.
	(m68k_cpus): Add 51, 51ac, 51cn, 51em, 51jm, 52274, 52277,
	52252..52259, 53011..53017.
	(m68k_ip): Process CPUCR.
	(init_table): Add cpucr entry.
	(m68k_set_extension): Allow negated mask to refer to a variable.
	(md_show_usage): Use '%s' to silence fprintf warning.
	* config/m68k-parse.h (CPUCR): New control register.

	gas/testsuite/
	* m68k/br-isac.d, m68k/br-isac.s: Add stldsr test.

	opcodes/
	* m68k-opc.c (m68k_opcodes): Add stldsr instruction.
@
text
@d1342 1
a1342 1
  assert (reloc->howto != 0);
d1495 1
a1495 1
	  assert (opsfound <= (int) ARRAY_SIZE (operands_backup));
d5167 1
a5167 1
      assert (fragP->fr_fix >= 2);
d5174 1
a5174 1
      assert (fragP->fr_fix >= 2);
d5183 1
a5183 1
      assert (fragP->fr_fix >= 2);
@


1.107
log
@        M68K TLS support.

        ld/testsuite/
        * ld-m68k/got-multigot-12-13-14-34-35-ok.d: Update.
        * ld-m68k/got-multigot-14-ok.d: Update.
        * ld-m68k/m68k-got.exp: Update.
        * ld-m68k/got-negative-12-13-14-34-ok.d: Update.
        * ld-m68k/got-negative-14-ok.d: Update.
        * ld-m68k/tls-gd-1.d, ld-m68k/tls-gd-2.d: New tests.
        * ld-m68k/tls-gd-ie-1.d, ld-m68k/tls-ie-1.d: New tests.
        * ld-m68k/tls-ld-1.d, ld-m68k/tls-ld-2.d: New tests.
        * ld-m68k/tls-ld-1.s, ld-m68k/tls-ld-2.s, ld-m68k/tls-le-1.s:
        New test sources.
        * ld-m68k/tls-no-1.s, ld-m68k/tls-gd-ie-1.s, ld-m68k/tls-gd-1.s:
        New test sources.
        * ld-m68k/tls-gd-2.s, ld-m68k/tls-ie-1.s: New test sources.
        * ld-m68k/m68k.exp: Run new tests.
        (merge isa-a isa-a:nodiv): Fix.

        gas/testsuite/
        * gas/m68k/tls-gd-3.d, gas/m68k/tls-gd-3.s: New test.
        * gas/m68k/all.exp: Run it.

        gas/
        * config/m68k-parse.h (enum pic_relocation): Add values for TLS
        relocations.
        * config/m68k-parse.y (yylex): Parse TLS relocations.
        * config/tc-m68k.c (m68k_elf_cons): New static function.
        (md_pseudo_table): Use it.
        (get_reloc_code, tc_m68k_fix_adjustable, tc_gen_reloc): Handle TLS
        relocations.
        (md_apply_fix): Fix to set thread local flag.
        (m68k_elf_suffix): New static function; helper for m68k_elf_cons.

        include/elf/
        * m68k.h: Map TLS relocations to numbers.

        bfd/
        * bfd-in2.h: Regenerate.
        * elf32-m68k.c: Handle 2-slot GOT entries.  Rename variables and
        fields from n_entries to n_slots where appropriate, update comments.
        (HOWTO): Add TLS relocations.
        (reloc_map): Map BFD_RELOC_68K_TLS_* to R_68K_TLS_*.
        (enum elf_m68k_got_offset_size): New enum.
        (struct elf_m68k_got_entry.type): Move field to ...
        (struct elf_m68k_got_entry_key): ... here.  Update all uses.
        (elf_m68k_reloc_got_type, elf_m68k_reloc_got_offset_size): New static
        functions.
        (elf_m68k_reloc_got_n_entries, elf_m68k_reloc_tls_p): New static
        functions.
        (struct elf_m68k_got): merge rel_8o_n_entries and rel_8o_16o_n_entries
        fields into n_entries array.  Update comments.
        (elf_m68k_init_got): Simplify, update all uses.
        (elf_m68k_init_got_entry_key): Handle R_68K_TLS_LDM32 reloc, update.
        (ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT): Adjust to handle 2-slot
        GOT entries; update name, update all uses.
        (ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): Ditto.
        (elf_m68k_get_got_entry): Update.
        (elf_m68k_update_got_entry_type): Rewrite to handle TLS GOT entries,
        simplify.
        (elf_m68k_remove_got_entry_type): Simplify.
        (elf_m68k_add_entry_to_got, elf_m68k_can_merge_gots_1): Update.
        (elf_m68k_can_merge_gots): Update.
        (elf_m68k_merge_gots_1, elf_m68k_merge_gots): Update.
        (struct elf_m68k_finalize_got_offsets_arg): Rewrite to handle 2-slot
        GOT entries, simplify.
        (elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets): Same.
        (struct elf_m68k_partition_multi_got_arg): Add slots_relas_diff
        field, remove obsoleted local_n_entries field.
        (elf_m68k_partition_multi_got_2): New static function.
        (elf_m68k_partition_multi_got_1, elf_m68k_partition_multi_got): Use it;
        update.
        (elf_m68k_remove_got_entry_type): Update.
        (elf_m68k_install_rela, dtpoff_base, tpoff): New static functions.
        (elf_m68k_check_relocs): Handle TLS relocations.  Remove unnecessary
        update of sgot->size and srelgot->size.
        (elf_m68k_gc_sweep_hook): Update.
        (elf_m68k_install_rela, dtpoff_base, tpoff): New static functions.
        (elf_m68k_relocate_section, elf_m68k_finish_dynamic_symbol): Handle
        TLS relocations.
        * reloc.c (BFD_RELOC_68K_TLS_*): Declare TLS relocations.
        * libbfd.h (bfd_reloc_code_real_names): Add BFD_RELOC_68K_TLS_*.
@
text
@d184 2
a185 2
static const enum m68k_register mcf51qe_ctrl[] = {
  VBR,
d220 8
d260 4
d265 1
a265 1
  CACR, ACR0, ACR1,  VBR, RAMBAR0, RAMBAR_ALT, MBAR,
d540 3
d555 1
a555 1
  {mcfmac,					NULL, "mac", 1},
d597 6
a602 1
  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51qe_ctrl, "51qe", 0},
d636 3
d648 8
a655 1
  
d669 8
d3316 1
d4078 1
d7450 2
a7451 1
    not_current_architecture |= ext->arch;
d7709 1
a7709 1
      fprintf (stream, m68k_archs[i].name);
d7718 1
a7718 1
      fprintf (stream, m68k_cpus[i].name);
@


1.106
log
@Remove unnecessary casts on obstack_alloc invocations.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d41 4
d535 1
a535 1
  
d537 1
a537 1
  
d542 1
a542 1
   
d569 1
a569 1
  
d583 1
a583 1
  
d588 1
a588 1
  
d590 1
a590 1
  
d593 1
a593 1
  
d596 1
a596 1
  
d600 1
a600 1
  
d612 1
a612 1
  
d615 1
a615 1
  
d839 1
d1012 60
d1140 15
d1232 15
d4824 25
d7899 109
@


1.105
log
@	* config/bfin-parse.y: Use C style comments.
	* config/tc-bfin.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mips.c: Likewise.
@
text
@d4425 1
a4425 1
      hack = slak = (struct m68k_incant *) obstack_alloc (&robyn, sizeof (struct m68k_incant));
@


1.104
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d6187 2
a6188 2
    case MCC ('n', 'e'): return MCC ('n', 'e'); // no problem here
    case MCC ('e', 'q'): return MCC ('e', 'q'); // also no problem
@


1.103
log
@	* config/tc-m68k.c (m68k_set_cpu, m68k_set_arch): Don't complain
	about overriding an earlier setting.
@
text
@d3 2
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d4473 1
a4473 1
      PTR val = hash_find (op_hash, name);
d4512 1
a4512 1
	  PTR val = hash_find (op_hash, name);
@


1.102
log
@	* config/tc-m68k.c (md_convert_frag_1): Replace as_fatal with
	as_bad_where.
@
text
@d7232 1
a7232 1
/* Set the cpu, issuing errors if it is unrecognized, or invalid */
a7246 7
      
  if (selected_cpu && selected_cpu != cpu)
    {
      as_bad (_("already selected `%s' processor"),
	      selected_cpu->name);
      return 0;
    }
d7251 1
a7251 1
/* Set the architecture, issuing errors if it is unrecognized, or invalid */
a7265 8
      
  if (selected_arch && selected_arch != arch)
    {
      as_bad (_("already selected `%s' architecture"),
	      selected_arch->name);
      return 0;
    }
  
@


1.101
log
@PR gas/5172
* config/tc-arc.c (md_estimate_size_before_relax): Change error message.
  (md_convert_frag): Just call abort.
* config/tc-i860.c (md_estimate_size_before_relax): Change error message.
* config/tc-i860.h (md_convert_frag): Just call abort.
* config/tc-ip2k.c (md_estimate_size_before_relax): Change error message.
  (md_convert_frag): Just call abort.
* config/tc-m68k.c (m68k_ip): Do not attempt translation of architecture names.
@
text
@d5037 2
a5038 1
	as_fatal (_("Conversion of PC relative displacement to absolute"));
@


1.100
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2181 1
a2181 1
		 won't write one when it runs out of buffer */
d2190 1
a2190 1
		  APPEND (_("ColdFire ISA_A"));
d2193 2
a2194 1
		  APPEND (_("ColdFire hardware divide"));
d2197 1
a2197 1
		  APPEND (_("ColdFire ISA_A+"));
d2200 1
a2200 1
		  APPEND (_("ColdFire ISA_B"));
d2203 1
a2203 1
		  APPEND (_("ColdFire ISA_C"));
d2206 1
a2206 1
		  APPEND (_("ColdFire fpu"));
d2209 1
a2209 1
		  APPEND (_("M68K fpu"));
d2212 1
a2212 1
		  APPEND (_("M68K mmu"));
d2215 2
a2216 1
		  APPEND (_("68020 or higher"));
d2219 2
a2220 1
		  APPEND (_("68000 or higher"));
d2223 2
a2224 1
		  APPEND (_("68010 or higher"));
d2268 1
a2268 1
		  /* we ran out of space, so replace the end of the list
@


1.99
log
@gas/
	* config/m68k-parse.h (m68k_register): Use MBO instead of MBB.
	(last_movec_reg): Change to MBO.
	* config/tc-m68k.c (fido_ctrl): Use MBO instead of MBB.
	(m68k_ip): Use MBO instead of MBO.
	(init_table): Use MBO instead of MBO.  Add an entry for mbo.

gas/testsuite/
	* gas/m68k/fido.s: Add tests for %mbo.
	* gas/m68k/fido.d: Update accordingly.

opcodes/
	* m68k-dis.c (print_insn_arg): Use %mbo instead of %mbb.
@
text
@a4683 8
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d4687 1
a4687 46
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
@


1.98
log
@* config/tc-m68k.c (LONG_BRANCH_VIA_COND): New.
  (BRANCHBWPL, FRAG_VAR_SIZE): New.
  (md_relax_table): Add BRANCHBWPL entries.
  (m68k_ip): Choose BRANCHBWPL relaxation if necessary.
  (md_assemble): Use FRAG_VAR_SIZE.
  (md_convert_frag_1): Add BRANCHBWPL cases.
  (md_estimate_size_before_relaz): Likewise.
* gas/m68k/br-isaa.d: Dump relocs too.
* gas/m68k/br-isab.d: Likewise.
* gas/m68k/br-isac.d: Likewise.  Adjust for long branch relaxation.
Index: gas/config/tc-m68k.c
@
text
@d312 1
a312 1
  SFC, DFC, USP, VBR, CAC, MBB,
d3268 1
a3268 1
            case MBB:
d4009 2
a4010 1
  { "mbb",    MBB },  		/* fido registers.  */
@


1.97
log
@bfd/
	* archures.c: Add bfd_mach_mcf_isa_c_nodiv,
	bfd_mach_mcf_isa_c_nodiv_mac & bfd_mach_mcf_isa_c_nodiv_emac.
	* ieee.c (ieee_write_processor): Update coldfire architecture
	list.
	* bfd-in2.h: Rebuilt.
	* cpu-m68k.c (arch_info_struct): Add isa_c nodiv architectures.
	(m68k_arch_features): Likewise.
	* elf32-m68k.c (elf32_m68k_object_p): Add EF_M68K_CF_ISA_C_NODIV.
	(elf32_m68k_print_private_bfd_data): Likewise.

gas/
	* config/tc-m68k.c (m68k_ip): Add mcfisa_c case.
	(m68k_elf_final_processing): Add EF_M68K_CF_ISA_C_NODIV.

include/elf/
	* m68k.h (EF_M68K_CF_ISA_C_NODIV): New.
@
text
@d383 1
d738 5
d744 2
a745 1
   needed; this is currently 10 bytes for DBCC.  */
d805 5
d2290 1
d2974 1
d3038 2
a3039 1
			  TAB (BRANCHBW, SZ_UNDEF));
d3589 3
a3591 4
/* Cause an extra frag to be generated here, inserting up to 10 bytes
   (that value is chosen in the frag_var call in md_assemble).  TYPE
   is the subtype of the frag to be generated; its primary type is
   rs_machine_dependent.
d4264 1
a4264 1
    wid += 10;
d4312 1
a4312 1
      (void) frag_var (rs_machine_dependent, 10, 0,
d4884 1
d4897 1
d4909 18
d5122 1
@


1.96
log
@	* config/tc-m68k.c (mcf52235_ctrl): Add cache registers.
	(mcf5253_ctrl): Add RAMBAR, MBAR, MBAR2.
	(mcf5407_ctrl): New.
	(m68k_cpus): Adjust 5407 entry.
@
text
@d2189 3
d7755 1
@


1.95
log
@	* config/tc-m68k.c (mcf51qe_ctrl): Define 51QE control registers.
	(m68k_cpus): Define 51QE cpu.
@
text
@d208 1
a208 1
  VBR, FLASHBAR, RAMBAR, RAMBAR1,
d228 1
a228 1
  VBR, CACR, ACR0, ACR1, RAMBAR0, RAMBAR1, MBAR,
d275 9
d644 1
a644 1
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfmac,		mcf_ctrl, "5407",0},
@


1.94
log
@Switch to GPLv3
@
text
@d179 4
d566 2
@


1.93
log
@	gas/testsuite/
	* gas/m68k/mcf-coproc.d: New.
	* gas/m68k/mcf-coproc.s: New.
	* gas/m68k/all.exp: Add it.

	gas/
	* config/tc-m68k.c (m68k_ip): Add j & K operand types.
	(install_operand): Add E encoding.
	(md_begin): Check and skip initial '.' arg character.
	(get_num): Add 0..511 case.

	include/
	* opcode/m68k.h: Document j K & E.

	opcodes/
	* m68k-dis.c (fetch_arg): Add E.  Replace length switch with
	direct masking.
	(print_ins_arg): Add j & K operand types.
	(match_insn_m68k): Check and skip initial '.' arg character.
	(m68k_scan_mask): Likewise.
	* m68k-opc.c (m68k_opcodes): Add coprocessor instructions.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.92
log
@	* config/tc-m68k.c (md_apply_fix): Show value of out of range
	fixups in error message.
	(md_conver_frag_1): Propagate the fix source location and use
	as_bad_where rather than fatal, for better error messages.
@
text
@d1968 16
d3501 8
d3577 3
d4392 2
a4393 2
	  /* We *could* ignore insns that don't match our
	     arch here by just leaving them out of the hash.  */
a4394 1
	  slak->m_opnum = strlen (slak->m_operands) / 2;
d4397 17
a4413 2
	  /* This is kludgey.  */
	  slak->m_codenum = ((ins->match) & 0xffffL) ? 2 : 1;
d5273 1
d5329 4
@


1.91
log
@    PR gas/3041
* config/tc-m68k.c (relaxable_symbol): Make sure that the correct addend is stored for relocs against weak symbols.
    (md_apply_fix): So not loose track of addend for relocs against weak symbols.
* testsuite/gas/m68k/p3041.s: New test case.
* testsuite/gas/m68k/p3041.d: New expected disassembly.
* testsuite/gas/m68k/all.exp: Run new test for m68k-*-netbsd toolchains.
    Only run arch-cpu-1 test for ELF based toolchains.

    Tidy ups for m68k-netbsd gas toolchain:
* testsuite/gas/m68k/cpu32.d: Allow for extra text after expected disassembly.
* testsuite/gas/m68k/mcf-trap.d: Allow for alternative trap mnemonics.
* testsuite/gas/m68k/br-isab.d: Fix name of test.
* testsuite/gas/m68k/br-isac.d: Fix name of test.
@
text
@d4763 2
a4764 1
    as_bad_where (fixP->fx_file, fixP->fx_line, _("value out of range"));
d4777 2
a4778 1
    as_bad_where (fixP->fx_file, fixP->fx_line, _("invalid byte branch offset"));
d4789 1
a4789 1
  fixS *fixP;
d4824 2
a4825 2
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
d4830 2
a4831 2
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC32);
d4838 2
a4839 1
    	    as_fatal (_("Tried to convert PC relative BSR to absolute JSR"));
d4842 2
a4843 2
	  fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
		   0, RELAX_RELOC_ABS32);
d4849 2
a4850 1
	    as_fatal (_("Tried to convert PC relative branch to absolute jump"));
d4853 2
a4854 2
	  fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
		   0, RELAX_RELOC_ABS32);
d4866 2
a4867 1
    	as_fatal (_("Tried to convert PC relative conditional branch to absolute jump"));
d4880 2
a4881 2
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
	       fragP->fr_offset, 0, RELAX_RELOC_ABS32);
d4886 2
a4887 2
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
d4892 2
a4893 2
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC32);
d4898 2
a4899 2
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
d4907 2
a4908 1
    	as_fatal (_("Tried to convert DBcc to absolute jump"));
d4918 2
a4919 2
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset, 1,
	       RELAX_RELOC_PC32);
d4927 2
a4928 1
    	as_fatal (_("Tried to convert PC relative conditional branch to absolute jump"));
d4938 2
a4939 2
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset, 0,
	       RELAX_RELOC_ABS32);
d4945 2
a4946 2
      fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, RELAX_RELOC_PC16);
d4986 2
a4987 2
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
d4992 1
a4992 1
    	as_fatal (_("Tried to convert PC relative conditional branch to absolute jump"));
d4999 2
a5000 2
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       0, RELAX_RELOC_ABS32);
d5004 5
@


1.90
log
@PR gas/3041
* gas/config/tc-m68k.c (relaxable_symbol): Do not relax weak symbols.
    (tc_gen_reloc): Adjust the addend of relocs against weak symbols.
     (md_apply_fix): Put zero values into the frags referencing weak symbols.
* bfd/aoutx.h (swap_std_reloc_out): Treat relocs against weak symbols in the same way as relocs against external symbols.
@
text
@d1163 3
a1165 2
       to put a zero value into frags referencing a weak symbol.  */
    reloc->addend = - S_GET_VALUE (fixp->fx_addsy);
d4706 1
a4706 1
  /* PR gas/3041 Always put zero values into frags referencing a weak symbol.  */
d4710 1
@


1.89
log
@	gas/testsuite/
	* gas/m68k/br-isaa.s: New.
	* gas/m68k/br-isaa.d: New.
	* gas/m68k/br-isab.s: New.
	* gas/m68k/br-isab.d: New.
	* gas/m68k/br-isac.s: New.
	* gas/m68k/br-isac.d: New.
	* gas/m68k/all.exp: Adjust.

	gas/
	* config/tc-m68k.c (mcf54455_ctrl): New.
	(HAVE_LONG_DISP, HAVE_LONG_CALL, HAVE_LONG_COND): New.
	(m68k_archs): Add isac.
	(m68k_cpus): Add 54455 family.
	(m68k_ip): Split Bg into Bb, Bs, Bg.
	(m68k_elf_final_processing): Add ISA_C.
	* doc/c-m68k.texi (M680x0 Options): Add isac.

	include/opcode/
	* m68k.h (mcfisa_c): New.
	(mcfusp, mcf_mask): Adjust.

	bfd/
	* archures.c (bfd_mach_mcf_isa_c, bfd_mach_mcf_isa_c_mac,
	bfd_mach_mcf_isa_c_emac): New.
	* elf32-m68k.c (ISAC_PLT_ENTRY_SIZE, elf_isac_plt0_entry,
	elf_isac_plt_entry, elf_isac_plt_info): New.
	(elf32_m68k_object_p): Add ISA_C.
	(elf32_m68k_print_private_bfd_data): Print ISA_C.
	(elf32_m68k_get_plt_info): Detect ISA_C.
	* cpu-m68k.c (arch_info): Add ISAC.
	(m68k_arch_features): Likewise,
	(bfd_m68k_compatible): ISAs B & C are not compatible.

	opcodes/
	* m68k-opc.c: Mark mcfisa_c instructions.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d1062 3
a1064 1
#define relaxable_symbol(symbol) 1
d1158 7
d4704 7
@


1.88
log
@	* config/tc-m68k.c (mcf5253_ctrl): New.
	(mcf52223_ctrl): New.
	(m68k_cpus): Add 5253, 52221, 52223.
@
text
@d271 9
d362 8
a369 1
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|fido_a|mcfisa_b))
d503 1
d630 7
d2233 2
d2894 1
a2905 2
	      if (! HAVE_LONG_BRANCH (current_architecture))
		as_warn (_("Can't use long branches on 68000/68010/5200"));
d2911 13
a2923 4
	    case 'g':
	      if (subs (&opP->disp))	/* We can't relax it.  */
		goto long_branch;

d2925 3
a2927 4
	      /* If the displacement needs pic relocation it cannot be
		 relaxed.  */
	      if (opP->disp.pic_reloc != pic_none)
		goto long_branch;
d2929 7
d2961 1
a2961 1
	      if (HAVE_LONG_BRANCH (current_architecture))
d2990 1
a2990 1
			  || (! flag_keep_pcrel)))
d7655 1
a7655 1
	{EF_M68K_CF_ISA_A_NODIV, mcfisa_a},
d7657 1
a7657 1
	{EF_M68K_CF_ISA_A_PLUS,mcfisa_a|mcfisa_aa|mcfhwdiv|mcfusp},
d7660 1
d7673 1
a7673 1
		 & (mcfisa_a|mcfisa_aa|mcfisa_b|mcfhwdiv|mcfusp));
@


1.87
log
@	gas/
	* config/m68k-parse.h (RAMBAR_ALT): New.
	* config/tc-m68k.c (mcf5206_ctrl, mcf5307_ctrl): New.
	(mcf_ctrl, mcf5208_ctrl, mcf5210a_ctrl, mcf5213_ctrl, mcf52235_ctrl,
	mcf5225_ctrl, mcf5235_ctrl, mcf5271_ctrl, mcf5275_ctrl,
	mcf5282_ctrl, mcf5329_ctrl, mcf5373_ctrl, mcfv4e_ctrl,
	mcf5475_ctrl, mcf5485_ctrl): Add RAMBAR synonym for
	RAMBAR1.
	(mcf5272_ctrl): Add RAMBAR0, replace add RAMBAR with RAMBAR_ALT.
	(m68k_cpus): Adjust 5206, 5206e & 5307 entries.
	(m68k_ip) <Case J>: Detect when RAMBAR_ALT should be used.  Add it
	to control register mapping.

	gas/testsuite/
	* gas/m68k/ctrl-1.d, gas/m68k/ctrl-1.s: New.
	* gas/m68k/ctrl-2.d, gas/m68k/ctrl-2.s: New.
	* gas/m68k/all.exp: Add them.

	opcodes/
	* m68k-dis.c (print_insn_arg): Show c04 as rambar0 and c05 as
	rambar1.
@
text
@d199 4
d223 4
d567 3
d586 1
@


1.86
log
@	* config/tc-m68k.c (HAVE_LONG_BRANCH): Add fido_a.
@
text
@d176 5
a180 1
  RAMBAR0, RAMBAR1, MBAR,
d184 1
a184 1
  CACR, ACR0, ACR1, VBR, RAMBAR1,
d188 1
a188 1
  VBR, CACR, ACR0, ACR1, ROMBAR, RAMBAR, MBAR,
d192 1
a192 1
  VBR, RAMBAR, FLASHBAR,
d196 1
a196 1
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR,
d200 1
a200 1
  VBR, FLASHBAR, RAMBAR,
d204 1
a204 1
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, MBAR,
d208 1
a208 1
  VBR, CACR, ACR0, ACR1, RAMBAR,
d212 1
a212 1
  VBR, CACR, ACR0, ACR1, RAMBAR0, RAMBAR1, MBAR, MBAR2,
d220 1
a220 1
  VBR, CACR, ACR0, ACR1, RAMBAR,
d224 1
a224 1
  VBR, CACR, ACR0, ACR1, ROMBAR, RAMBAR, MBAR,
d228 1
a228 1
  VBR, CACR, ACR0, ACR1, RAMBAR,
d232 5
a236 1
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR,
d240 1
a240 1
  VBR, CACR, ACR0, ACR1, RAMBAR,
d244 1
a244 1
  VBR, CACR, ACR0, ACR1, RAMBAR,
d260 1
a260 1
  ROMBAR /* ROMBAR0 */,
d269 1
a269 1
  MBAR1 /* MBAR */, ROMBAR /* ROMBAR0 */,
d278 1
a278 1
  MBAR1 /* MBAR */, ROMBAR /* ROMBAR0 */,
d541 1
a541 1
  {mcfisa_a,					mcf_ctrl, "5206", 1},
d543 1
a543 1
  {mcfisa_a|mcfhwdiv|mcfmac,			mcf_ctrl, "5206e", 0},
d589 1
a589 1
  {mcfisa_a|mcfhwdiv|mcfmac,			mcf_ctrl, "5307", 0},
d1754 12
a1765 2
			if (*rp == opP->reg)
			  break;
d3096 1
@


1.85
log
@	* config/tc-m68k.c (m68k_cpus): Add an entry for fidoa.
@
text
@d337 1
a337 1
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|mcfisa_b))
@


1.84
log
@	* config/tc-m68k.c (mcf5210a_ctrl, mcf52235_ctrl, mcf5225_ctrl): New.
	(m68k_cpus): Add 5210a..5211a, 52230..52235 5224..5225.
@
text
@d610 1
@


1.83
log
@	* config/m68k-parse.h (m68k_register): Add ROMBAR0, ASID.
	* config/tc-m68k.c (mcfv4e_ctrl): Add ColdFire specific names.
	(mcf5475_ctrl, mcf5485_ctrl): New.
	(m68k_cpus): Use mcf5485_ctrl and mcf5485_ctrl for those families.
	(m68k_ip): Add ASID, MMUBAR, ROMBAR0 handling.
	(init_table): Add asid, mmubar, adjust rombar0.
@
text
@d183 4
d195 8
d540 3
d551 8
@


1.82
log
@bfd/
	* archures.c (bfd_mach_cpu32_fido): Rename to bfd_mach_fido.
	* bfd-in2.h: Regenerate.
	* cpu-m68k.c (arch_info_struct): Use bfd_mach_fido instead of
	bfd_mach_cpu32_fido.
	(m68k_arch_features): Use fido_a instead of cpu32.
	(bfd_m68k_compatible): Reject the combination of Fido and
	ColdFire.  Accept the combination of CPU32 and Fido with a
	warning.
	* elf32-m68k.c (elf32_m68k_object_p,
	elf32_m68k_merge_private_bfd_data,
	elf32_m68k_print_private_bfd_data): Treat Fido as an
	architecture by itself.

binutils/
	* readelf.c (get_machine_flags): Treat Fido as an architecture
	by itself.

gas/
	* config/tc-m68k.c (m68k_archs, m68k_cpus): Treat Fido as an
	architecture by itself.
	(m68k_ip): Don't issue a warning for tbl instructions on fido.
	(m68k_elf_final_processing): Treat Fido as an architecture by
	itself.

include/elf/
	* m68k.h (EF_M68K_FIDO): New.
	(EF_M68K_ARCH_MASK): OR EF_M68K_FIDO.
	(EF_M68K_CPU32_FIDO_A, EF_M68K_CPU32_MASK): Remove.

include/opcode/
	* m68k.h (m68010up): OR fido_a.

opcodes/
	* m68k-opc.c (m68k_opcodes): Replace cpu32 with
	cpu32 | fido_a except on tbl instructions.
@
text
@d228 6
a233 2
  CACR, TC, ITT0, ITT1, DTT0, DTT1, BUSCR, VBR, PC, ROMBAR,
  ROMBAR1, RAMBAR0, RAMBAR1, MPCR, EDRAMBAR, SECMBAR, MBAR, MBAR0, MBAR1,
d236 23
d571 7
a577 7
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5470", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5471", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5472", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5473", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5474", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5475", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "547x", 0},
d579 7
a585 7
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5480", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5481", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5482", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5483", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5484", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5485", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "548x", 0},
d2994 1
d3014 1
d3046 1
d3792 1
a3792 1
  /* mcf5200 versions of same.  The ColdFire programmer's reference
d3802 1
d3809 1
d3819 1
a3819 1
  { "rombar0",  ROMBAR },	/* mcfv4e registers.  */
@


1.81
log
@gas/
	* config/m68k-parse.h (m68k_register): Add CAC and MBB.
	* config/tc-m68k.c (fido_ctrl): New.
	(m68k_archs): Use fido_ctrl for -mfidoa.
	(m68k_cpus): Use fido_ctrl on fido-*-*.
	(m68k_ip): Add support for CAC and MBB.
	(init_table): Add CAC and MBB.

opcodes/
	* m68k-dis.c (print_insn_arg): Add support for cac and mbb.
@
text
@d428 1
a428 1
  {cpu32|fido_a,				fido_ctrl, "fidoa", 0},
d560 1
a560 1
  {cpu32|fido_a,				fido_ctrl, "fido", 1},
d7517 3
a7519 5
    {
      flags |= EF_M68K_CPU32;
      if (cpu_of_arch (current_architecture) & fido_a)
	flags |= EF_M68K_CPU32_FIDO_A;
    }
@


1.80
log
@bfd/
	* archures.c (bfd_mach_cpu32_fido): New.
	(bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_a,
	bfd_mach_mcf_isa_a_mac, bfd_mach_mcf_isa_a_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_b_nousp,
	bfd_mach_mcf_isa_b_nousp_mac, bfd_mach_mcf_isa_b_nousp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac,
	bfd_mach_mcf_isa_b_emac, bfd_mach_mcf_isa_b_float,
	bfd_mach_mcf_isa_b_float_mac, bfd_mach_mcf_isa_b_float_emac):
	Increment the defined values.
	* bfd-in2.h: Regenerate.
	* cpu-m68k.c (arch_info_struct): Add en entry for
	bfd_mach_cpu32_fido.
	* elf32-m68k.c (elf32_m68k_object_p): Handle
	EF_M68K_CPU32_FIDO_A.
	(elf32_m68k_merge_private_bfd_data): Use EF_M68K_CPU32_MASK.
	(elf32_m68k_print_private_bfd_data): Handle
	EF_M68K_CPU32_FIDO_A.

binutils/
	* readelf.c (get_machine_flags): Handle EF_M68K_CPU32_FIDO_A.

gas/
	* config/tc-m68k.c (cpu_of_arch): Add fido.
	(m68k_archs, m68k_cpu): Add entries for fido.
	(m68k_elf_final_processing): Handle EF_M68K_CPU32_FIDO_A.

include/elf/
	* m68k.h (EF_M68K_CPU32_FIDO_A, EF_M68K_CPU32_MASK): New.

include/opcode/
	* m68k.h (fido_a): New.
@
text
@d234 4
d428 1
a428 1
  {cpu32|fido_a,				cpu32_ctrl, "fidoa", 0},
d560 1
a560 1
  {cpu32|fido_a,				cpu32_ctrl, "fido", 1},
d3081 6
d3811 3
@


1.79
log
@bfd/
	* elf32-m68k.c: Update uses of EF_M68K_*.

binutils/
	* readelf.c: Update uses of EF_M68K_*.

gas/
	* config/tc-m68k.c: Update uses of EF_M68K_*.

include/elf
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A_NODIV,
	EF_M68K_ISA_A, EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B_NOUSP,
	EF_M68K_ISA_B, EF_M68K_ISA_C, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_EMAC_B, EF_M68K_FLOAT): Rename to
	EF_M68K_CF_ISA_MASK, EF_M68K_CF_ISA_A_NODIV, EF_M68K_CF_ISA_A,
	EF_M68K_CF_ISA_A_PLUS, EF_M68K_CF_ISA_B_NOUSP,
	EF_M68K_CF_ISA_B, EF_M68K_CF_ISA_C, EF_M68K_CF_MAC_MASK,
	EF_M68K_CF_MAC, EF_M68K_CF_EMAC, EF_M68K_CF_EMAC_B,
	EF_M68K_CF_FLOAT, respectively.
@
text
@d287 1
a287 1
#define cpu_of_arch(x)		((x) & (m68000up | mcfisa_a))
d424 1
d556 2
d7504 5
a7508 1
    flags |= EF_M68K_CPU32;
@


1.78
log
@gas/
	* config/tc-m68k.c (m68k_ip):  Correct output of cpu aliases.
gas/testsuite/
	* gas/m68k/all.exp: Add mcf-trap.
	* gas/m68k/mcf-trap.[sd]: New.
opcodes/
	* m68k-opc.c (m68k_opcodes): Place trap instructions before set
	conditionals.  Add tpf coldfire instruction as alias for trapf.
@
text
@d7510 5
a7514 5
	{EF_M68K_ISA_A_NODIV, mcfisa_a},
	{EF_M68K_ISA_A,	mcfisa_a|mcfhwdiv},
	{EF_M68K_ISA_A_PLUS,mcfisa_a|mcfisa_aa|mcfhwdiv|mcfusp},
	{EF_M68K_ISA_B_NOUSP,mcfisa_a|mcfisa_b|mcfhwdiv},
	{EF_M68K_ISA_B,	mcfisa_a|mcfisa_b|mcfhwdiv|mcfusp},
d7519 2
a7520 2
	{EF_M68K_MAC, mcfmac},
	{EF_M68K_EMAC, mcfemac},
d7544 1
a7544 1
	    flags |= EF_M68K_FLOAT | EF_M68K_CFV4E;
@


1.77
log
@	* config/tc-arm.c, config/tc-arm.h (tc_arm_regname_to_dw2regnum):
	Un-constify string argument.
	* config/tc-i386.c, config/tc-i386.h (tc_x86_regname_to_dw2regnum):
	Likewise.
	* config/tc-m68k.c, config/tc-m68k.h (tc_m68k_regname_to_dw2regnum):
	Likewise.
	* config/tc-ppc.c, config/tc-ppc.h (tc_ppc_regname_to_dw2regnum):
	Likewise.
	* config/tc-s390.c, config/tc-s390.h (tc_s390_regname_to_dw2regnum):
	Likewise.
	* config/tc-sh.c, config/tc-sh.h (sh_regname_to_dw2regnum):
	Likewise.
	* config/tc-sparc.c, config/tc-sparc.h (sparc_regname_to_dw2regnum):
	Likewise.
-------------------------------------------------------------------
@
text
@d2064 2
a2065 1

d2070 4
a2073 3
		    APPEND (" [");
		    if (cpu != m68k_cpus)
		      for (alias = cpu - 1; alias->alias; alias--)
d2075 11
a2085 4
			  if (any)
			    APPEND (", ");
			  APPEND (alias->name);
			  any = 1;
d2087 2
a2088 9
		    for (alias = cpu + 1; alias->alias; alias++)
		      {
			if (any)
			  APPEND (", ");
			APPEND (alias->name);
			any = 1;
		      }
		    
		    APPEND ("]");
@


1.76
log
@	* gas/config/tc-m68k.c (m68k_init_arch): Move checking of
	cfloat/m68881 to correct architecture before using it.
@
text
@d7565 1
a7565 1
tc_m68k_regname_to_dw2regnum (const char *regname)
@


1.75
log
@	* gas/config/tc-m68k.c (find_cf_chip): Merge into ...
	(m68k_ip): ... here.  Use for all chips.  Protect against buffer
	overrun and avoid excessive copying.
@
text
@d7236 9
a7255 9
  if ((current_architecture & (cfloat | m68881)) == (cfloat | m68881))
    {
      /* Determine which float is really meant.  */
      if (current_architecture & (m68k_mask & ~m68881))
	current_architecture ^= cfloat;
      else
	current_architecture ^= m68881;
    }

@


1.75.2.1
log
@	* gas/config/tc-m68k.c (m68k_init_arch): Move checking of
	cfloat/m68881 to correct architecture before using it.
@
text
@a7235 9
  if ((current_architecture & (cfloat | m68881)) == (cfloat | m68881))
    {
      /* Determine which float is really meant.  */
      if (current_architecture & (m68k_mask & ~m68881))
	current_architecture ^= cfloat;
      else
	current_architecture ^= m68881;
    }

d7247 9
@


1.74
log
@	gas:
	* config/tc-m68k.c (m68000_control_regs, m68010_control_regs,
	m68020_control_regs, m68040_control_regs, m68060_control_regs,
	mcf_control_regs, mcf5208_control_regs, mcf5213_control_regs,
	mcf5329_control_regs, mcf5249_control_regs, mcf528x_control_regs,
	mcfv4e_control_regs, m68010_control_regs): Rename and reorder to ...
	(m68000_ctrl, m68010_ctrl, m68020_ctrl, m68040_ctrl, m68060_ctrl,
	mcf_ctrl, mcf5208_ctrl, mcf5213_ctrl, mcf5235_ctrl, mcf5249_ctrl,
	mcf5216_ctrl, mcf5250_ctrl, mcf5271_ctrl, mcf5272_ctrl,
	mcf5282_ctrl, mcfv4e_ctrl): ... these.
	(mcf5275_ctrl, mcf5329_ctrl, mcf5373_ctrl): New.
	(struct m68k_cpu): Change chip field to control_regs.
	(current_chip): Remove.
	(control_regs): New.
	(m68k_archs, m68k_extensions): Adjust.
	(m68k_cpus): Reorder to be in cpu number order.  Adjust.
	(CPU_ALLOW_MC, CPU_ALLOW_NEGATION): Remove.
	(find_cf_chip): Reimplement for new organization of cpu table.
	(select_control_regs): Remove.
	(mri_chip): Adjust.
	(struct save_opts): Save control regs, not chip.
	(s_save, s_restore): Adjust.
	(m68k_lookup_cpu): Give deprecated warning when necessary.
	(m68k_init_arch): Adjust.
	(md_show_usage): Adjust for new cpu table organization.

	include/opcodes:
	* m68k.h (cpu_m68k, cpu_cf, cpu_m68000, cpu_m68008, cpu_m68010,
	cpu_m68020, cpu_m68ec030, cpu_m68040, cpu_m68060, cpu_m68851,
	cpu_m68881, cpu_m68882, cpu_cpu32, cpu_cf5200, cpu_cf5206e,
	cpu_cf5208, cpu_cf521x, cpu_cf5213, cpu_cf5249, cpu_cf528x,
	cpu_cf5307, cpu_cf5329, cpu_cf5407, cpu_cf547x, cpu_cf548x): Remove.
@
text
@a804 63
/* Return a human readable string holding the list of chips that are
   valid for a particular architecture, suppressing aliases (unless
   there is only one of them).  */

static char *
find_cf_chip (int architecture)
{
  static char buf[1024];
  char *cp;
  const struct m68k_cpu *cpu;
  int any = 0;
  
  strcpy (buf, " (");
  cp = buf + strlen (buf);

  for (cpu = m68k_cpus; cpu->name; cpu++)
    if (!cpu->alias && (cpu->arch & architecture))
      {
	const struct m68k_cpu *alias;
	if (any)
	  {
	    strcpy (cp, ", ");
	    cp += 2;
	  }
	any = 0;
	strcpy (cp, cpu->name);
	cp += strlen (cp);
	strcpy (cp, " [");
	cp += 2;
	if (cpu != m68k_cpus)
	  for (alias = cpu - 1; alias->alias; alias--)
	    {	
	      if (any)
		{
		  strcpy (cp, ", ");
		  cp += 2;
		}
	      strcpy (cp, alias->name);
	      cp += strlen (cp);
	      any = 1;
	    }
	for (alias = cpu + 1; alias->alias; alias++)
	  {
	    if (any)
	      {
		strcpy (cp, ", ");
		cp += 2;
	      }
	    strcpy (cp, alias->name);
	    cp += strlen (cp);
	    any = 1;
	  }
	
	strcpy (cp, "]");
	any = 1;
	if ((unsigned)(cp - buf) >= sizeof (buf))
	  as_fatal (_("coldfire string overflow"));
      }
  strcat (cp, ")");

  return buf;
}

d2007 13
a2019 1
	      char buf[200], *cp;
d2021 1
a2021 4
	      strncpy (buf,
		       _("invalid instruction for this architecture; needs "),
		       sizeof (buf));
	      cp = buf + strlen (buf);
d2025 1
a2025 6
		  strncpy (cp, _("ColdFire ISA_A"),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
		  strncpy (cp, find_cf_chip (ok_arch),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
d2028 1
a2028 6
		  strncpy (cp, _("ColdFire hardware divide"),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
		  strncpy (cp, find_cf_chip (ok_arch),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
d2031 1
a2031 6
		  strncpy (cp, _("ColdFire ISA_A+"),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
		  strncpy (cp, find_cf_chip (ok_arch),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
d2034 1
a2034 6
		  strncpy (cp, _("ColdFire ISA_B"),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
		  strncpy (cp, find_cf_chip (ok_arch),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
d2037 1
a2037 5
		  strncpy (cp, _("ColdFire fpu"), sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
		  strncpy (cp, find_cf_chip (ok_arch),
			   sizeof (buf) - (cp - buf));
		  cp += strlen (cp);
d2040 1
a2040 1
		  strcpy (cp, _("fpu (68040, 68060 or 68881/68882)"));
d2043 1
a2043 1
		  strcpy (cp, _("mmu (68030 or 68851)"));
d2046 1
a2046 1
		  strcpy (cp, _("68020 or higher"));
d2049 1
a2049 1
		  strcpy (cp, _("68000 or higher"));
d2052 1
a2052 1
		  strcpy (cp, _("68010 or higher"));
d2055 7
d2063 1
a2063 1
		    int got_one = 0, idx;
d2065 14
a2078 1
		    for (idx = 0; m68k_cpus[idx].name; idx++)
d2080 4
a2083 12
			if ((m68k_cpus[idx].arch & ok_arch)
			    && ! m68k_cpus[idx].alias)
			  {
			    if (got_one)
			      {
				strcpy (cp, " or ");
				cp += strlen (cp);
			      }
			    got_one = 1;
			    strcpy (cp, m68k_cpus[idx].name);
			    cp += strlen (cp);
			  }
d2085 3
d2089 11
a2100 3
	      cp = xmalloc (strlen (buf) + 1);
	      strcpy (cp, buf);
	      the_ins.error = cp;
@


1.73
log
@bfd/
	* cpu-m68k.c (bfd_m68k_compatible): Treat ISA A+ and ISA B code as
	incompatible.  Likewise MAC and EMAC code.
	* elf32-m68k.c (elf32_m68k_merge_private_bfd_data): Use
	bfd_get_compatible to set the new bfd architecture.  Rely on it
	to detect incompatibilities.

gas/
	* config/tc-m68k.c (m68k_cpus): Change cpu_cf5208 entries to use
	mcfemac instead of mcfmac.

ld/testsuite/
	* ld-m68k/merge-error-1a.s, ld-m68k/merge-error-1b.s,
	* ld-m68k/merge-error-1a.d, ld-m68k/merge-error-1b.d,
	* ld-m68k/merge-error-1c.d, ld-m68k/merge-error-1d.d,
	* ld-m68k/merge-error-1e.d, ld-m68k/merge-ok-1a.d,
	* ld-m68k/merge-ok-1b.d: New tests.
	* ld-m68k/m68k.exp: Run them.
@
text
@d155 2
a156 2
static const enum m68k_register m68000_control_regs[] = { 0 };
static const enum m68k_register m68010_control_regs[] = {
d160 1
a160 1
static const enum m68k_register m68020_control_regs[] = {
d164 1
a164 1
static const enum m68k_register m68040_control_regs[] = {
d169 1
a169 1
static const enum m68k_register m68060_control_regs[] = {
d174 1
a174 1
static const enum m68k_register mcf_control_regs[] = {
d179 1
a179 1
static const enum m68k_register mcf5208_control_regs[] = {
d183 1
a183 1
static const enum m68k_register mcf5213_control_regs[] = {
d187 2
a188 2
static const enum m68k_register mcf5329_control_regs[] = {
  CACR, ACR0, ACR1, VBR, RAMBAR,
d191 2
a192 2
static const enum m68k_register mcf5249_control_regs[] = {
  CACR, ACR0, ACR1, VBR, RAMBAR0, RAMBAR1, MBAR, MBAR2,
d195 2
a196 2
static const enum m68k_register mcf528x_control_regs[] = {
  CACR, ACR0, ACR1, VBR, FLASHBAR, RAMBAR,
d199 29
a227 1
static const enum m68k_register mcfv4e_control_regs[] = {
d234 1
a234 1
#define cpu32_control_regs m68010_control_regs
d397 1
a397 1
  unsigned long chip;	/* Specific chip */
a409 1
static int current_chip;
d417 12
a428 12
  {m68000,					cpu_m68000, "68000", 0},
  {m68010,					cpu_m68010, "68010", 0},
  {m68020|m68881|m68851,			cpu_m68020, "68020", 0},
  {m68030|m68881|m68851,			cpu_m68030, "68030", 0},
  {m68040,					cpu_m68040, "68040", 0},
  {m68060,					cpu_m68060, "68060", 0},
  {cpu32|m68881,				cpu_cpu32, "cpu32", 0},
  {mcfisa_a|mcfhwdiv,				0, "isaa", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_aa|mcfusp,		0, "isaaplus", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b|mcfusp,		0, "isab", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
   cpu_cf547x, "cfv4e", 0},
d436 3
a438 3
  {m68851,					0, "68851", -1},
  {m68881,					0, "68881", -1},
  {m68881,					0, "68882", -1},
d440 1
a440 1
  {cfloat|m68881,				0, "float", 0},
d442 4
a445 4
  {mcfhwdiv,					0, "div", 1},
  {mcfusp,					0, "usp", 1},
  {mcfmac,					0, "mac", 1},
  {mcfemac,					0, "emac", 1},
d447 1
a447 1
  {0,0,NULL, 0}
d453 103
a555 88
  { m68000,					cpu_m68000, "68000", 0},
  { m68010,					cpu_m68010, "68010", 0},
  { m68020|m68881|m68851,			cpu_m68020, "68020", 0},
  { m68030|m68881|m68851,			cpu_m68030, "68030", 0},
  { m68040,					cpu_m68040, "68040", 0},
  { m68060,					cpu_m68060, "68060", 0},
  { cpu32|m68881,				cpu_cpu32, "cpu32",  0},
  { mcfisa_a,					cpu_cf5200, "5200", 0},
  { mcfisa_a|mcfhwdiv|mcfmac,			cpu_cf5206e, "5206e", 0},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf5208, "5208", 0},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	cpu_cf5213, "5213", 0},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,cpu_cf521x, "521x", 0},
  { mcfisa_a|mcfhwdiv|mcfemac,		cpu_cf5249, "5249", 0},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,cpu_cf528x, "528x", 0},
  { mcfisa_a|mcfhwdiv|mcfmac,			cpu_cf5307, "5307", 0},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf5329, "5329", 0},
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac,	cpu_cf5407, "5407",0},
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf547x, "547x", 0},
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
      						cpu_cf548x, "548x", 0},
  /* Aliases (effectively, so far as gas is concerned) for the above
     cpus.  */
  { m68020|m68881|m68851,			cpu_m68020, "68k", 1},
  { m68000,					cpu_m68000, "68008", 1},
  { m68000,					cpu_m68000, "68302", 1},
  { m68000,					cpu_m68000, "68306", 1},
  { m68000,					cpu_m68000, "68307", 1},
  { m68000,					cpu_m68000, "68322", 1},
  { m68000,					cpu_m68000, "68356", 1},
  { m68000,					cpu_m68000, "68ec000", 1},
  { m68000,					cpu_m68000, "68hc000", 1},
  { m68000,					cpu_m68000, "68hc001", 1},
  { m68020|m68881|m68851,			cpu_m68020, "68ec020", 1},
  { m68030|m68881|m68851,			cpu_m68030, "68ec030", 1},
  { m68040,					cpu_m68040, "68ec040", 1},
  { m68060,					cpu_m68060, "68ec060", 1},
  { cpu32|m68881,				cpu_cpu32, "68330", 1},
  { cpu32|m68881,				cpu_cpu32, "68331", 1},
  { cpu32|m68881,				cpu_cpu32, "68332", 1},
  { cpu32|m68881,				cpu_cpu32, "68333", 1},
  { cpu32|m68881,				cpu_cpu32, "68334", 1},
  { cpu32|m68881,				cpu_cpu32, "68336", 1},
  { cpu32|m68881,				cpu_cpu32, "68340", 1},
  { cpu32|m68881,				cpu_cpu32, "68341", 1},
  { cpu32|m68881,				cpu_cpu32, "68349", 1},
  { cpu32|m68881,				cpu_cpu32, "68360", 1},
  { mcfisa_a,					cpu_cf5200, "5202", 1},
  { mcfisa_a,					cpu_cf5200, "5204", 1},
  { mcfisa_a,					cpu_cf5200, "5206", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf5208, "5207", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	cpu_cf5213, "5211", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	cpu_cf5213, "5212", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf521x, "5214", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf521x, "5216", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf5329, "5327", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf5329, "5328", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf528x, "5280", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf528x, "5281", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf528x, "5282", 1},
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac,	cpu_cf5407,	"cfv4", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf547x, "cfv4e", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf547x, "5470", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf547x, "5471", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf547x, "5472", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf547x, "5473", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf547x, "5474", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf547x, "5475", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf548x, "5480", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf548x, "5481", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf548x, "5482", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf548x, "5483", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf548x, "5484", 1 },
  { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,
    cpu_cf548x, "5485", 1 },
  {0,0,NULL, 0}
a557 3
#define CPU_ALLOW_MC 1
#define CPU_ALLOW_NEGATION 4

a812 1
  int i, j, n_chips, n_alias;
d814 3
a816 1

d820 2
a821 2
  for (i = 0, n_chips = 0, n_alias = 0; m68k_cpus[i].name; ++i)
    if (m68k_cpus[i].arch & architecture)
d823 24
a846 15
	n_chips++;
	if (m68k_cpus[i].alias)
	  n_alias++;
      }

  if (n_chips == 0)
    as_fatal (_("no matching ColdFire architectures found"));

  if (n_alias > 1)
    n_chips -= n_alias;
      
  for (i = 0, j = 0; m68k_cpus[i].name && j < n_chips; ++i)
    if (m68k_cpus[i].arch & architecture)
      {
	if (j)
d848 1
a848 1
	    if ((j == n_chips - 1 && !(n_alias > 1)) || ! n_alias)
d850 2
a851 15
		if (n_chips == 2)
		  {
		    strncpy (cp, _(" or "), (sizeof (buf) - (cp - buf)));
		    cp += strlen (cp);
		  }
		else
		  {
		    strncpy (cp, _(", or "), (sizeof (buf) - (cp - buf)));
		    cp += strlen (cp);
		  }
	      }
	    else
	      {
		strncpy (cp, ", ", (sizeof (buf) - (cp - buf)));
		cp += strlen (cp);
d853 3
d857 5
a861 3
	strncpy (cp, m68k_cpus[i].name, (sizeof (buf) - (cp - buf)));
	cp += strlen (cp);
	j++;
d863 1
a863 8

  if (n_alias > 1)
    {
      strncpy (cp, _(", or aliases"), (sizeof (buf) - (cp - buf)));
      cp += strlen (cp);
    }

  strncpy (cp, ")", (sizeof (buf) - (cp - buf)));
a4411 62
static void
select_control_regs (void)
{
  /* Note which set of "movec" control registers is available.  */
  switch (current_chip)
    {
    case 0:
      if (verbose)
	as_warn (_("architecture not yet selected: defaulting to 68020"));
      control_regs = m68020_control_regs;
      break;
      
    case cpu_m68000:
      control_regs = m68000_control_regs;
      break;
    case cpu_m68010:
      control_regs = m68010_control_regs;
      break;
    case cpu_m68020:
    case cpu_m68030:
      control_regs = m68020_control_regs;
      break;
    case cpu_m68040:
      control_regs = m68040_control_regs;
      break;
    case cpu_m68060:
      control_regs = m68060_control_regs;
      break;
    case cpu_cpu32:
      control_regs = cpu32_control_regs;
      break;
    case cpu_cf5200:
    case cpu_cf5206e:
    case cpu_cf5307:
    case cpu_cf5407:
      control_regs = mcf_control_regs;
      break;
    case cpu_cf5249:
      control_regs = mcf5249_control_regs;
      break;
    case cpu_cf528x:
    case cpu_cf521x:
      control_regs = mcf528x_control_regs;
      break;
    case cpu_cf547x:
    case cpu_cf548x:
      control_regs = mcfv4e_control_regs;
      break;
    case cpu_cf5208:
      control_regs = mcf5208_control_regs;
      break;
    case cpu_cf5213:
      control_regs = mcf5213_control_regs;
      break;
    case cpu_cf5329:
      control_regs = mcf5329_control_regs;
      break;
    default:
      abort ();
    }
}

d5341 1
a5341 1
  current_chip = m68k_cpus[i].chip;
a5357 3

  /* Update info about available control registers.  */
  select_control_regs ();
d5703 1
a5703 1
  int chip;
d5728 1
a5728 1
  s->chip = current_chip;
d5762 1
a5762 1
  current_chip = s->chip;
d7051 6
a7056 1
      return table;
d7282 4
a7285 1
    current_architecture |= selected_arch->arch;
d7288 2
a7290 2
  current_architecture &= ~not_current_architecture;
  
d7293 1
a7329 3
  /* Note which set of "movec" control registers is available.  */
  select_control_regs ();

d7352 5
a7356 9
	  for (i = 0; m68k_cpus[i].name; i++)
	    {
	      if (m68k_cpus[i].arch == default_arch
		  && !m68k_cpus[i].alias)
		{
		  default_cpu = m68k_cpus[i].name;
		  break;
		}
	    }
@


1.72
log
@	bfd:
	* archures.c (bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_b_nousp):
	New.  Adjust other variants.
	(bfd_default_scan): Update.
	* bfd-in2.h: Rebuilt.
	* cpu-m68k.c: Adjust.
	(bfd_m68k_compatible): New. Use it for architectures.
	* elf32-m68k.c (elf32_m68k_object_p): Adjust.
	(elf32_m68k_merge_private_bfd_data): Adjust.  Correct isa-a/b
	mismatch.
	(elf32_m68k_print_private_bfd_data): Adjust.
	* ieee.c (ieee_write_processor): Adjust.

	binutils:
	* readelf.c (get_machine_flags): Adjust.

	gas:
	* config/tc-m68k.c (m68k_extensions): Allow 'float' on both m68k
	and cf.
	(m68k_ip): <case 'J'> Check we have some control regs.
	(md_parse_option): Allow raw arch switch.
	(m68k_init_arch): Better detection of arch/cpu mismatch.  Detect
	whether 68881 or cfloat was meant by -mfloat.
	(md_show_usage): Adjust extension display.
	(m68k_elf_final_processing): Adjust.

	gas/testsuite:
	* gas/m68k/arch-cpu-1.s: Tweak.
	* gas/m68k/arch-cpu-1.d: Tweak.

	include/elf:
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A,
	EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B, EF_M68K_ISA_C): Adjust.
	(EF_M68K_ISA_A_NODIV, EF_M68K_ISA_B_NOUSP): New.
	(EF_M68K_HW_DIV, EF_M68K_USP): Remove.
	(EF_M68K_MAC, EF_M68K_EMAC, EF_M68K_FLOAT): Adjust.
	(EF_M68K_EMAC_B): New.

	ld/testsuite:
	* ld-m68k: New tests.
@
text
@d435 1
a435 1
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	cpu_cf5208, "5208", 0},
d476 1
a476 1
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	cpu_cf5208, "5207", 1},
@


1.72.2.1
log
@bfd/
	* cpu-m68k.c (bfd_m68k_compatible): Treat ISA A+ and ISA B code as
	incompatible.  Likewise MAC and EMAC code.
	* elf32-m68k.c (elf32_m68k_merge_private_bfd_data): Use
	bfd_get_compatible to set the new bfd architecture.  Rely on it
	to detect incompatibilities.

gas/
	* config/tc-m68k.c (m68k_cpus): Change cpu_cf5208 entries to use
	mcfemac instead of mcfmac.

ld/testsuite/
	* ld-m68k/merge-error-1a.s, ld-m68k/merge-error-1b.s,
	* ld-m68k/merge-error-1a.d, ld-m68k/merge-error-1b.d,
	* ld-m68k/merge-error-1c.d, ld-m68k/merge-error-1d.d,
	* ld-m68k/merge-error-1e.d, ld-m68k/merge-ok-1a.d,
	* ld-m68k/merge-ok-1b.d: New tests.
	* ld-m68k/m68k.exp: Run them.
@
text
@d435 1
a435 1
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf5208, "5208", 0},
d476 1
a476 1
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	cpu_cf5208, "5207", 1},
@


1.72.2.2
log
@	* gcc/config/tc-m68k.c (m68000_control_regs, m68010_control_regs,
	m68020_control_regs, m68040_control_regs, m68060_control_regs,
	mcf_control_regs, mcf5208_control_regs, mcf5213_control_regs,
	mcf5329_control_regs, mcf5249_control_regs, mcf528x_control_regs,
	mcfv4e_control_regs, m68010_control_regs): Rename and reorder to ...
	(m68000_ctrl, m68010_ctrl, m68020_ctrl, m68040_ctrl, m68060_ctrl,
	mcf_ctrl, mcf5208_ctrl, mcf5213_ctrl, mcf5235_ctrl, mcf5249_ctrl,
	mcf5216_ctrl, mcf5250_ctrl, mcf5271_ctrl, mcf5272_ctrl,
	mcf5282_ctrl, mcfv4e_ctrl): ... these.
	(mcf5275_ctrl, mcf5329_ctrl, mcf5373_ctrl): New.
	(struct m68k_cpu): Change chip field to control_regs.
	(current_chip): Remove.
	(control_regs): New.
	(m68k_archs, m68k_extensions): Adjust.
	(m68k_cpus): Reorder to be in cpu number order.  Adjust.
	(CPU_ALLOW_MC, CPU_ALLOW_NEGATION): Remove.
	(find_cf_chip): Reimplement for new organization of cpu table.
	(select_control_regs): Remove.
	(mri_chip): Adjust.
	(struct save_opts): Save control regs, not chip.
	(s_save, s_restore): Adjust.
	(m68k_lookup_cpu): Give deprecated warning when necessary.
	(m68k_init_arch): Adjust.
	(md_show_usage): Adjust for new cpu table organization.
	* include/opcode/m68k.h (cpu_m68k, cpu_cf, cpu_m68000, cpu_m68008,
	cpu_m68010, cpu_m68020, cpu_m68ec030, cpu_m68040, cpu_m68060,
	cpu_m68851, cpu_m68881, cpu_m68882, cpu_cpu32, cpu_cf5200, cpu_cf5206e,
	cpu_cf5208, cpu_cf521x, cpu_cf5213, cpu_cf5249, cpu_cf528x,
	cpu_cf5307, cpu_cf5329, cpu_cf5407, cpu_cf547x, cpu_cf548x): Remove.
@
text
@d155 2
a156 2
static const enum m68k_register m68000_ctrl[] = { 0 };
static const enum m68k_register m68010_ctrl[] = {
d160 1
a160 1
static const enum m68k_register m68020_ctrl[] = {
d164 1
a164 1
static const enum m68k_register m68040_ctrl[] = {
d169 1
a169 1
static const enum m68k_register m68060_ctrl[] = {
d174 1
a174 1
static const enum m68k_register mcf_ctrl[] = {
d179 1
a179 1
static const enum m68k_register mcf5208_ctrl[] = {
d183 1
a183 1
static const enum m68k_register mcf5213_ctrl[] = {
d187 2
a188 2
static const enum m68k_register mcf5216_ctrl[] = {
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR,
d191 2
a192 2
static const enum m68k_register mcf5235_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR,
d195 2
a196 2
static const enum m68k_register mcf5249_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR0, RAMBAR1, MBAR, MBAR2,
d199 1
a199 29
static const enum m68k_register mcf5250_ctrl[] = {
  VBR,
  0
};
static const enum m68k_register mcf5271_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR,
  0
};
static const enum m68k_register mcf5272_ctrl[] = {
  VBR, CACR, ACR0, ACR1, ROMBAR, RAMBAR, MBAR,
  0
};
static const enum m68k_register mcf5275_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR,
  0
};
static const enum m68k_register mcf5282_ctrl[] = {
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR,
  0
};
static const enum m68k_register mcf5329_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR,
  0
};
static const enum m68k_register mcf5373_ctrl[] = {
  VBR, CACR, ACR0, ACR1, RAMBAR,
  0
};
static const enum m68k_register mcfv4e_ctrl[] = {
d206 1
a206 1
#define cpu32_ctrl m68010_ctrl
d369 1
a369 1
  const enum m68k_register *control_regs;	/* Control regs on chip */
d382 1
d390 12
a401 12
  {m68000,					m68000_ctrl, "68000", 0},
  {m68010,					m68010_ctrl, "68010", 0},
  {m68020|m68881|m68851,			m68020_ctrl, "68020", 0},
  {m68030|m68881|m68851,			m68020_ctrl, "68030", 0},
  {m68040,					m68040_ctrl, "68040", 0},
  {m68060,					m68060_ctrl, "68060", 0},
  {cpu32|m68881,				cpu32_ctrl, "cpu32", 0},
  {mcfisa_a|mcfhwdiv,				NULL, "isaa", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_aa|mcfusp,		NULL, "isaaplus", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b|mcfusp,		NULL, "isab", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac|mcfusp,	mcf_ctrl, "cfv4", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "cfv4e", 0},
d409 3
a411 3
  {m68851,					NULL, "68851", -1},
  {m68881,					NULL, "68881", -1},
  {m68881,					NULL, "68882", -1},
d413 1
a413 1
  {cfloat|m68881,				NULL, "float", 0},
d415 4
a418 4
  {mcfhwdiv,					NULL, "div", 1},
  {mcfusp,					NULL, "usp", 1},
  {mcfmac,					NULL, "mac", 1},
  {mcfemac,					NULL, "emac", 1},
d420 1
a420 1
  {0,NULL,NULL, 0}
d426 88
a513 103
  {m68000,					m68000_ctrl, "68000", 0},
  {m68000,					m68000_ctrl, "68ec000", 1},
  {m68000,					m68000_ctrl, "68hc000", 1},
  {m68000,					m68000_ctrl, "68hc001", 1},
  {m68000,					m68000_ctrl, "68008", 1},
  {m68000,					m68000_ctrl, "68302", 1},
  {m68000,					m68000_ctrl, "68306", 1},
  {m68000,					m68000_ctrl, "68307", 1},
  {m68000,					m68000_ctrl, "68322", 1},
  {m68000,					m68000_ctrl, "68356", 1},
  {m68010,					m68010_ctrl, "68010", 0},
  {m68020|m68881|m68851,			m68020_ctrl, "68020", 0},
  {m68020|m68881|m68851,			m68020_ctrl, "68k", 1},
  {m68020|m68881|m68851,			m68020_ctrl, "68ec020", 1},
  {m68030|m68881|m68851,			m68020_ctrl, "68030", 0},
  {m68030|m68881|m68851,			m68020_ctrl, "68ec030", 1},
  {m68040,					m68040_ctrl, "68040", 0},
  {m68040,					m68040_ctrl, "68ec040", 1},
  {m68060,					m68060_ctrl, "68060", 0},
  {m68060,					m68060_ctrl, "68ec060", 1},
  
  {cpu32|m68881,				cpu32_ctrl, "cpu32",  0},
  {cpu32|m68881,				cpu32_ctrl, "68330", 1},
  {cpu32|m68881,				cpu32_ctrl, "68331", 1},
  {cpu32|m68881,				cpu32_ctrl, "68332", 1},
  {cpu32|m68881,				cpu32_ctrl, "68333", 1},
  {cpu32|m68881,				cpu32_ctrl, "68334", 1},
  {cpu32|m68881,				cpu32_ctrl, "68336", 1},
  {cpu32|m68881,				cpu32_ctrl, "68340", 1},
  {cpu32|m68881,				cpu32_ctrl, "68341", 1},
  {cpu32|m68881,				cpu32_ctrl, "68349", 1},
  {cpu32|m68881,				cpu32_ctrl, "68360", 1},
  
  {mcfisa_a,					mcf_ctrl, "5200", 0},
  {mcfisa_a,					mcf_ctrl, "5202", 1},
  {mcfisa_a,					mcf_ctrl, "5204", 1},
  {mcfisa_a,					mcf_ctrl, "5206", 1},
  
  {mcfisa_a|mcfhwdiv|mcfmac,			mcf_ctrl, "5206e", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5208_ctrl, "5207", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5208_ctrl, "5208", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5213_ctrl, "5211", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5213_ctrl, "5212", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5213_ctrl, "5213", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5216_ctrl, "5214", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5216_ctrl, "5216", 0},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5216_ctrl, "521x", 2},

  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5232", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5233", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5234", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5235", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "523x", 0},
  
  {mcfisa_a|mcfhwdiv|mcfemac,			mcf5249_ctrl, "5249", 0},
  {mcfisa_a|mcfhwdiv|mcfemac,			mcf5250_ctrl, "5250", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5271_ctrl, "5270", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5271_ctrl, "5271", 0},
  
  {mcfisa_a|mcfhwdiv|mcfmac,			mcf5272_ctrl, "5272", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5275_ctrl, "5274", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5275_ctrl, "5275", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "5280", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "5281", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "5282", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "528x", 0},
  
  {mcfisa_a|mcfhwdiv|mcfmac,			mcf_ctrl, "5307", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "5327", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "5328", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "5329", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "532x", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5373_ctrl, "5372", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5373_ctrl, "5373", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5373_ctrl, "537x", 0},
  
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfmac,		mcf_ctrl, "5407",0},
  
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5470", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5471", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5472", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5473", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5474", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5475", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "547x", 0},
  
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5480", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5481", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5482", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5483", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5484", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "5485", -1},
  {mcfisa_a|mcfisa_b|mcfhwdiv|mcfemac|mcfusp|cfloat, mcfv4e_ctrl, "548x", 0},
  
  {0,NULL,NULL, 0}
d516 3
d774 1
d776 1
a776 3
  const struct m68k_cpu *cpu;
  int any = 0;
  
d780 16
a795 2
  for (cpu = m68k_cpus; cpu->name; cpu++)
    if (!cpu->alias && (cpu->arch & architecture))
d797 1
a797 2
	const struct m68k_cpu *alias;
	if (any)
d799 14
a812 23
	    strcpy (cp, ", ");
	    cp += 2;
	  }
	any = 0;
	strcpy (cp, cpu->name);
	cp += strlen (cp);
	strcpy (cp, " [");
	cp += 2;
	if (cpu != m68k_cpus)
	  for (alias = cpu - 1; alias->alias; alias--)
	    {	
	      if (any)
		{
		  strcpy (cp, ", ");
		  cp += 2;
		}
	      strcpy (cp, alias->name);
	      cp += strlen (cp);
	      any = 1;
	    }
	for (alias = cpu + 1; alias->alias; alias++)
	  {
	    if (any)
d814 2
a815 2
		strcpy (cp, ", ");
		cp += 2;
a816 3
	    strcpy (cp, alias->name);
	    cp += strlen (cp);
	    any = 1;
d818 3
a820 5
	
	strcpy (cp, "]");
	any = 1;
	if ((unsigned)(cp - buf) >= sizeof (buf))
	  as_fatal (_("coldfire string overflow"));
d822 8
a829 1
  strcat (cp, ")");
d4378 62
d5369 1
a5369 1
  control_regs = m68k_cpus[i].control_regs;
d5386 3
d5734 1
a5734 1
  const enum m68k_register *control_regs;
d5759 1
a5759 1
  s->control_regs = control_regs;
d5793 1
a5793 1
  control_regs = s->control_regs;
d7082 1
a7082 6
      {
	if (table->alias < -1 || table->alias > 1)
	  as_bad (_("`%s' is deprecated, use `%s'"),
		  table->name, table[table->alias < 0 ? 1 : -1].name);
	return table;
      }
d7308 1
a7308 4
    {
      current_architecture |= selected_arch->arch;
      control_regs = selected_arch->control_regs;
    }
d7311 2
a7313 2
  current_architecture &= ~not_current_architecture;

a7315 1
      control_regs = selected_cpu->control_regs;
d7352 3
d7377 9
a7385 5
	  while (m68k_cpus[i].alias > 0)
	    i--;
	  while (m68k_cpus[i].alias < 0)
	    i++;
	  default_cpu = m68k_cpus[i].name;
@


1.72.2.3
log
@	* gas/config/tc-m68k.c (find_cf_chip): Merge into ...
	(m68k_ip): ... here.  Use for all chips.  Protect against buffer
	overrun and avoid excessive copying.
@
text
@d805 63
d2070 1
a2070 13
	      const struct m68k_cpu *cpu;
	      int any = 0;
	      size_t space = 400;
	      char *buf = xmalloc (space + 1);
	      size_t len;
	      int paren = 1;

	      the_ins.error = buf;
	      /* Make sure there's a NUL at the end of the buffer -- strncpy
		 won't write one when it runs out of buffer */
	      buf[space] = 0;
#define APPEND(STRING) \
  (strncpy (buf, STRING, space), len = strlen (buf), buf += len, space -= len)
d2072 4
a2075 1
	      APPEND (_("invalid instruction for this architecture; needs "));
d2079 6
a2084 1
		  APPEND (_("ColdFire ISA_A"));
d2087 6
a2092 1
		  APPEND (_("ColdFire hardware divide"));
d2095 6
a2100 1
		  APPEND (_("ColdFire ISA_A+"));
d2103 6
a2108 1
		  APPEND (_("ColdFire ISA_B"));
d2111 5
a2115 1
		  APPEND (_("ColdFire fpu"));
d2118 1
a2118 1
		  APPEND (_("M68K fpu"));
d2121 1
a2121 1
		  APPEND (_("M68K mmu"));
d2124 1
a2124 1
		  APPEND (_("68020 or higher"));
d2127 1
a2127 1
		  APPEND (_("68000 or higher"));
d2130 1
a2130 1
		  APPEND (_("68010 or higher"));
a2132 7
		  paren = 0;
		}
	      if (paren)
		APPEND (" (");

	      for (cpu = m68k_cpus; cpu->name; cpu++)
		if (!cpu->alias && (cpu->arch & ok_arch))
d2134 1
a2134 1
		    const struct m68k_cpu *alias;
d2136 1
a2136 14
		    if (any)
		      APPEND (", ");
		    any = 0;
		    APPEND (cpu->name);
		    APPEND (" [");
		    if (cpu != m68k_cpus)
		      for (alias = cpu - 1; alias->alias; alias--)
			{
			  if (any)
			    APPEND (", ");
			  APPEND (alias->name);
			  any = 1;
			}
		    for (alias = cpu + 1; alias->alias; alias++)
d2138 12
a2149 4
			if (any)
			  APPEND (", ");
			APPEND (alias->name);
			any = 1;
a2150 3
		    
		    APPEND ("]");
		    any = 1;
a2151 11
	      if (paren)
		APPEND (")");
#undef APPEND
	      if (!space)
		{
		  /* we ran out of space, so replace the end of the list
		     with ellipsis.  */
		  buf -= 4;
		  while (*buf != ' ')
		    buf--;
		  strcpy (buf, " ...");
d2153 3
@


1.72.2.4
log
@	* gas/config/tc-m68k.c (m68k_init_arch): Move checking of
	cfloat/m68881 to correct architecture before using it.
@
text
@a7235 9
  if ((current_architecture & (cfloat | m68881)) == (cfloat | m68881))
    {
      /* Determine which float is really meant.  */
      if (current_architecture & (m68k_mask & ~m68881))
	current_architecture ^= cfloat;
      else
	current_architecture ^= m68881;
    }

d7247 9
@


1.72.2.5
log
@	* gas/config/tc-m68k.c (mcf52235_ctrl, mcf5225_ctrl): New.
	(m68k_cpus): Add 52230, 52233, 52234, 52235, 5224, 5225.
@
text
@a190 8
static const enum m68k_register mcf52235_ctrl[] = {
  VBR, FLASHBAR, RAMBAR,
  0
};
static const enum m68k_register mcf5225_ctrl[] = {
  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, MBAR,
  0
};
a503 8
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52235_ctrl, "52230", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52235_ctrl, "52233", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52235_ctrl, "52234", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52235_ctrl, "52235", 0},
  
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf5225_ctrl, "5224", -1},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf5225_ctrl, "5225", 0},
  
@


1.72.2.6
log
@	gas/
	* config/tc-m68k.c (m68k_register_mcf5210a_ctrl): New.
	(m68k_cpus): Add 5210a & 5211a.
@
text
@a182 4
static const enum m68k_register mcf5210a_ctrl[] = {
  VBR, CACR, ACR0, ACR1, ROMBAR, RAMBAR, MBAR,
  0
};
a503 3
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5210a_ctrl, "5210a", 0},
  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,	mcf5210a_ctrl, "5211a", 1},
  
@


1.72.2.7
log
@	gas/
	* config/tc-m68k.c (m68k_ip):  Correct output of cpu aliases.
@
text
@d2087 1
a2087 2
		    int seen_master = 0;
		    
d2092 3
a2094 4
		    for (alias = cpu; alias != m68k_cpus; alias--)
		      if (alias[-1].alias >= 0)
			break;
		    for (; !seen_master || alias->alias > 0; alias++)
d2096 4
a2099 11
			  if (!alias->alias)
			    seen_master = 1;
			  else
			    {
			      if (any)
				APPEND (", ");
			      else
				APPEND (" [");
			      APPEND (alias->name);
			      any = 1;
			    }
d2101 9
a2109 2
		    if (any)
		      APPEND ("]");
@


1.72.2.8
log
@	Merge fido bits:
	2006-10-25  Kazu Hirata  <kazu@@codesourcery.com>

	gprof/
	* hist.c, hist.h: Fix formatting.

	gprof/
	* Makefile.in (corefile.o): Depend on hist.h.
	* corefile.c: Include hist.h.

	2006-10-06  Vladimir Prus  <vladimir@@codesourcery.com>

	* hist.h (struct histogram)
	(histograms, num_histograms): New.
	* hist.c (find_histogram, find_histogram_for_pc)
	(read_histogram_header): New.
	(s_lowpc, s_highpc, lowpc, highpc, hist_num_bins)
	(hist_sample): Remove.
	(hist_read_rec): Use the above, and handle multiple
	histogram records with disjoint address ranges.
	(hist_write_hist): Support several histogram records.
	(scale_and_align_entries): Adjust for multiple histograms.
	(hist_assign_samples_1): New.
	(hist_assign_samples): Use the above.
	(hist_clip_symbol_address): New.
	* hist.h (hist_check_address)
	(hist_clip_symbol_address): Declare.
	* gmon_io.c (gmon_out_read, gmon_out_write): Adjust handling
	of legacy format for multiple histogram changes.
	* corefile.c (find_call): Check for core_text_space and
	clip symbol address range here.
	* vax.c	(vax_find_call): Don't check for
	core_text_space, or clip the symbol's address range here.
	Use hist_check_address to check call's target address.
	* sparc.c: Likewise.
	* tahoe.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise. Also use core_text_sect->vma as the base
	address for code accesses, just like other machine-specific
	routines do.

	2006-08-03  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add -mfido as an alias for
	-mfido_a.

	2006-06-23  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (cpu_of_arch): Replace fido with
	fido_a.
	(archs): Likewise.
	(m68k_ip): Likewise.
	(select_control_regs): Likewise.
	(md_show_usage): Replace -mfido with -mfidoa.
	* include/opcode/m68k.h (fido): Rename to fido_a.
	* opcodes/m68k-opc.c (m68k_opcodes): Replace fido with fido_a.

	2006-06-22  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Replace fido with fido.
	* bfd/config.bfd: Likewise
	* gas/configure.tgt: Likewise.
	* gas/config/m68k-parse.h: Likewise.
	* gas/config/tc-m68k.c: Likewise.
	* gas/testsuite/gas/m68k/all.exp: Likewise.
	* gas/testsuite/gas/m68k/fido.d: Rename to fido.d.
	* gas/testsuite/gas/m68k/fido.s: Rename to fido.s.
	* include/opcode/m68k.h: Replace fido with fido.
	* ld/configure.tgt: Likewise.
	* opcodes/m68k-dis.c: Likewise.
	* opcodes/m68k-opc.c: Likewise.

	2005-08-01  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/m68k-parse.h (m68k_register): Add CAC and MBB.
	* gas/config/tc-m68k.c (fido_control_regs): New.
	(cpu_of_arch): Add fido.
	(archs): Add an entry for fido.
	(m68k_ip): Add warnings for uses of tbl[su]{n,}[bwl] on
	fido.  Recognize CAC and MBB.
	(init_tabl): Add CAC and MBB.
	(select_control_regs): Choose fido as the current chip
	when the current architecture is fido or when -mfido
	is given explicitly.
	* gas/testsuite/gas/m68k/all.exp: Disable operands, cas, and
	bitfield on fido-*-*.  Run fido on fido-*-*.
	* gas/testsuite/gas/m68k/fido.d: New.
	* gas/testsuite/gas/m68k/fido.s: Likewise.
	* include/opcode/m68k.h: Document new control registers CAC
	and MBB.
	* opcodes/m68k-dis.c (print_insn_arg): Add cac and mbb.
	* opcodes/m68k-opc.c (m68k_opcodes): Add sleep and trapx.

	2005-07-22  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add fido as an OR of
	cpu32 and fido.
	(md_show_usage): Add -mfido.
	* include/opcode/m68k.h (fido): New.

	2005-07-11  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Recognize fido and fido-*.
	* bfd/config.bfd: Likewise.
	* gas/configure.tgt: Likewise.
	* ld/configure.tgt: Likewise.
@
text
@a245 4
static const enum m68k_register fido_ctrl[] = {
  SFC, DFC, USP, VBR, CAC, MBB,
  0
};
d299 1
a299 1
#define cpu_of_arch(x)		((x) & (m68000up | mcfisa_a | fido_a))
a435 1
  {cpu32|fido_a,				fido_ctrl, "fidoa", 0},
a577 2
  {cpu32|fido_a,				fido_ctrl, "fido", 1},

a1156 15
  /* Fido does not support certain instructions.  Warn about uses
     of those instructions.  */
  if ((cpu_of_arch (current_architecture) & fido_a) != 0)
    {
      /* Recognize tbl[su]{n,}[bwl].  */
      if (strncmp (instring, "tbl", 3) == 0
	  && (instring[3] == 's' || instring[3] == 'u')
	  && ((strchr ("bwl", instring[4]) != 0
	       && instring[5] == '\0')
	      || (instring[4] == 'n'
		  && strchr ("bwl", instring[5]) != 0
		  && instring[6] == '\0')))
	as_warn (_("'%s' not supported on Fido"), instring);
    }

a3096 6
            case CAC:
              tmpreg = 0xFFE;
              break;
            case MBB:
              tmpreg = 0xFFF;
              break;
a3820 3

  { "cac",    CAC },  		/* fido registers.  */
  { "mbb",    MBB },  		/* fido registers.  */
@


1.72.2.9
log
@	bfd/
	* elf32-m68k.c: Update uses of EF_M68K_*.

	binutils/
	* readelf.c: Update uses of EF_M68K_*.

	gas/
	* config/tc-m68k.c: Update uses of EF_M68K_*.

	include/elf
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A_NODIV,
	EF_M68K_ISA_A, EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B_NOUSP,
	EF_M68K_ISA_B, EF_M68K_ISA_C, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_EMAC_B, EF_M68K_FLOAT): Rename to
	EF_M68K_CF_ISA_MASK, EF_M68K_CF_ISA_A_NODIV, EF_M68K_CF_ISA_A,
	EF_M68K_CF_ISA_A_PLUS, EF_M68K_CF_ISA_B_NOUSP,
	EF_M68K_CF_ISA_B, EF_M68K_CF_ISA_C, EF_M68K_CF_MAC_MASK,
	EF_M68K_CF_MAC, EF_M68K_CF_EMAC, EF_M68K_CF_EMAC_B,
	EF_M68K_CF_FLOAT, respectively.
@
text
@d7564 5
a7568 5
	{EF_M68K_CF_ISA_A_NODIV, mcfisa_a},
	{EF_M68K_CF_ISA_A,	mcfisa_a|mcfhwdiv},
	{EF_M68K_CF_ISA_A_PLUS,mcfisa_a|mcfisa_aa|mcfhwdiv|mcfusp},
	{EF_M68K_CF_ISA_B_NOUSP,mcfisa_a|mcfisa_b|mcfhwdiv},
	{EF_M68K_CF_ISA_B,	mcfisa_a|mcfisa_b|mcfhwdiv|mcfusp},
d7573 2
a7574 2
	{EF_M68K_CF_MAC, mcfmac},
	{EF_M68K_CF_EMAC, mcfemac},
d7598 1
a7598 1
	    flags |= EF_M68K_CF_FLOAT | EF_M68K_CFV4E;
@


1.72.2.10
log
@	bfd/
	* archures.c (bfd_mach_cpu32_fido): New.
	(bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_a,
	bfd_mach_mcf_isa_a_mac, bfd_mach_mcf_isa_a_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_b_nousp,
	bfd_mach_mcf_isa_b_nousp_mac, bfd_mach_mcf_isa_b_nousp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac,
	bfd_mach_mcf_isa_b_emac, bfd_mach_mcf_isa_b_float,
	bfd_mach_mcf_isa_b_float_mac, bfd_mach_mcf_isa_b_float_emac):
	Increment the defined values.
	* cpu-m68k.c (arch_info_struct): Add en entry for
	bfd_mach_cpu32_fido.
	(m68k_arch_features): Add an entry corresponding to
	bfd_mach_cpu32_fido.
	(bfd_m68k_compatible): Handle bfd_mach_cpu32_fido.
	* elf32-m68k.c (elf32_m68k_object_p): Handle
	EF_M68K_CPU32_FIDO_A.
	(elf32_m68k_merge_private_bfd_data): Use EF_M68K_CPU32_MASK.
	(elf32_m68k_print_private_bfd_data): Handle
	EF_M68K_CPU32_FIDO_A.

	binutils/
	* readelf.c (get_machine_flags): Handle EF_M68K_CPU32_FIDO_A.

	gas/
	* config/tc-m68k.c (m68k_elf_final_processing): Handle
	EF_M68K_CPU32_FIDO_A.

	include/
	* include/elf/m68k.h (EF_M68K_CPU32_FIDO_A,
	EF_M68K_CPU32_MASK): New.
@
text
@d7555 1
a7555 5
    {
      flags |= EF_M68K_CPU32;
      if (cpu_of_arch (current_architecture) & fido_a)
	flags |= EF_M68K_CPU32_FIDO_A;
    }
@


1.71
log
@	* bfd/archures.c (bfd_mach_mcf5200, bfd_mach_mcf5206e,
	bfd_mach_mcf5307, bfd_mach_mcf5407, bfd_mach_mcf528x,
	bfd_mach_mcfv4e, bfd_mach_mcf521x, bfd_mach_mcf5249,
	bfd_mach_mcf547x, bfd_mach_mcf548x): Remove.
	(bfd_mach_mcf_isa_a, bfd_mach_mcf_isa_a_div,
	bfd_mach_mcf_isa_a_div_mac, bfd_mach_mcf_isa_a_div_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_aplus_usp,
	bfd_mach_mcf_isa_aplus_usp_mac, bfd_mach_mcf_isa_aplus_usp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac, bfd_mach_mcf_isa_b_emac,
	bfd_mach_mcf_isa_b_usp_float, bfd_mach_mcf_isa_b_usp_float_mac,
	bfd_mach_mcf_isa_b_usp_float_emac): New.
	(bfd_default_scan): Update coldfire mapping.
	* bfd/bfd-in.h (bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Declare.
	* bfd/bfd-in2.h: Rebuilt.
	* bfd/cpu-m68k.c (arch_info_struct): Add new coldfire machines,
	adjust legacy names.
	(m68k_arch_features): New.
	(bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Define.
	* bfd/elf32-m68k.c (elf32_m68k_object_p): New.
	(elf32_m68k_merge_private_bfd_data): Merge the CF EF flags.
	(elf32_m68k_print_private_bfd_data): Print the CF EF flags.
	(elf_backend_object_p): Define.
	* bfd/ieee.c (ieee_write_processor): Update coldfire machines.
	* bfd/libbfd.h: Rebuilt.

	* gas/config/tc-m68k.c (mcf5208_control_regs, mcf5213_control_regs,
	mcf5329_control_regs): New.
	(not_current_architecture, selected_arch, selected_cpu): New.
	(m68k_archs, m68k_extensions): New.
	(archs): Renamed to ...
	(m68k_cpus): ... here.  Adjust.
	(n_arches): Remove.
	(md_pseudo_table): Add arch and cpu directives.
	(find_cf_chip, m68k_ip): Adjust table scanning.
	(no_68851, no_68881): Remove.
	(md_assemble): Lazily initialize.
	(select_control_regs): Adjust cpu names. Add 5208, 5213, 5329.
	(md_init_after_args): Move functionality to m68k_init_arch.
	(mri_chip): Adjust table scanning.
	(md_parse_option): Reimplement 'm' processing to add -march & -mcpu
	options with saner parsing.
	(m68k_lookup_cpu, m68k_set_arch, m68k_set_cpu, m68k_set_extension,
	m68k_init_arch): New.
	(s_m68k_cpu, s_m68k_arch): New.
	(md_show_usage): Adjust.
	(m68k_elf_final_processing): Set CF EF flags.
	* gas/config/tc-m68k.h (m68k_init_after_args): Remove.
	(tc_init_after_args): Remove.
	* gas/doc/c-m68k.texi (M68K-Opts): Document -march, -mcpu options.
	(M68k-Directives): Document .arch and .cpu directives.

	* gas/testsuite/gas/m68k/all.exp: Add arch-cpu-1 test.
	* gas/testsuite/gas/m68k/arch-cpu-1.[sd]: New.

	* include/elf/m68k.h (EF_CPU32, EF_M68000, EF_CFV4E): Rename to ...
	(EF_M68K_CPU32, EF_M68K_M68000, EF_M68K_CFV4E): ... here.
	(EF_M68K_ISA_MASK, EF_M68K_ISA_A, EF_M68K_M68K_ISA_A_PLUS,
	EF_M68K_ISA_B, EF_M68K_HW_DIV, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_USP, EF_M68K_FLOAT): New.

	* include/opcode/m68k.h (m68008, m68ec030, m68882): Remove.
	(m68k_mask): New.
	(cpu_m68k, cpu_cf): New.
	(mcf5200, mcf5206e, mcf521x, mcf5249, mcf528x, mcf5307, mcf5407,
	mcf5470, mcf5480): Rename to cpu_<foo>. Add m680x0 variants.

	* opcodes/m68k-dis.c (print_insn_m68k): Use
	bfd_m68k_mach_to_features.

	* binutils/readelf.c (get_machine_flags): Add logic for EF_M68K flags.
@
text
@d371 5
a375 1
  unsigned alias;
d398 2
a399 2
  {mcfisa_a|mcfhwdiv|mcfisa_aa,			0, "isaaplus", 0},
  {mcfisa_a|mcfhwdiv|mcfisa_b,			0, "isab", 0},
d405 2
a406 1
/* Architecture extensions.  */
d409 5
a413 3
  {m68851,					0, "68851", 0},
  {m68881,					0, "68881", 0},
  {m68881,					0, "68882", 0},
a416 1
  {cfloat,					0, "float", 1},
d435 2
a436 2
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac,	cpu_cf5208, "5208", 0},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac,	cpu_cf5213, "5213", 0},
d441 1
a441 1
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,	cpu_cf5329, "5329", 0},
d476 10
a485 10
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac,		cpu_cf5208, "5207", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac,		cpu_cf5213, "5211", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac,		cpu_cf5213, "5212", 1},
  { mcfisa_a|mcfhwdiv|mcfisa_aa|mcfemac,	cpu_cf521x, "5214", 1},
  { mcfisa_a|mcfhwdiv|mcfisa_aa|mcfemac,	cpu_cf521x, "5216", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,	cpu_cf5329, "5327", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,	cpu_cf5329, "5328", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,	cpu_cf528x, "5280", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,	cpu_cf528x, "5281", 1},
  { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,	cpu_cf528x, "5282", 1},
d1709 2
a1710 1
		      || opP->reg > last_movec_reg)
d1715 1
d7282 2
a7301 2
  unsigned arch_of_chip = 0;
  
d7308 7
d7316 1
a7316 3
      arch_of_chip = selected_arch->arch;
      current_chip = selected_arch->chip;
      if (selected_cpu && (arch_of_chip & ~selected_cpu->arch))
d7318 3
a7320 2
	  as_bad (_("selected processor is not from selected architecture"));
	  arch_of_chip = selected_cpu->arch;
a7322 4
  else
    arch_of_chip = selected_cpu->arch;
  if (selected_cpu)
    current_chip = selected_cpu->chip;
d7324 9
a7332 2
  current_architecture |= arch_of_chip;
  current_architecture &= ~not_current_architecture;
d7337 1
a7337 1
      if (arch_of_chip & m68k_mask)
d7395 4
a7398 2
-m[no-]%-16s enable/disable %s architecture extension\n\
"), m68k_extensions[i].name, m68k_extensions[i].alias ? "ColdFire" : "m68k");
d7590 33
a7622 5
      /* Set coldfire specific elf flags */
      if (current_architecture & mcfisa_b)
	flags |= EF_M68K_ISA_B;
      else if (current_architecture & mcfisa_aa)
	flags |= EF_M68K_ISA_A_PLUS;
d7624 3
a7626 1
	flags |= EF_M68K_ISA_A;
d7628 15
a7642 13
      if (current_architecture & mcfhwdiv)
	flags |= EF_M68K_HW_DIV;

      if (current_architecture & mcfusp)
	flags |= EF_M68K_USP;
      
      if (current_architecture & cfloat)
	flags |= EF_M68K_FLOAT;

      if (current_architecture & mcfmac)
	flags |= EF_M68K_MAC;
      else if (current_architecture & mcfemac)
	flags |= EF_M68K_EMAC;
@


1.70
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d179 12
d363 2
d366 10
d377 1
d379 21
d401 107
a507 6
struct m68k_cpu
  {
    unsigned long arch;
    unsigned long chip;
    const char *name;
    int alias;
d510 2
a511 70
static const struct m68k_cpu archs[] =
  {
    { m68000,						m68000, "68000", 0 },
    { m68010,						m68010, "68010", 0 },
    { m68020,						m68020, "68020", 0 },
    { m68030,						m68030, "68030", 0 },
    { m68040,						m68040, "68040", 0 },
    { m68060,						m68060, "68060", 0 },
    { cpu32,						cpu32, "cpu32", 0 },
    { m68881,						m68881, "68881", 0 },
    { m68851,						m68851, "68851", 0 },
    { mcfisa_a,						mcf5200, "5200", 0 },
    { mcfisa_a|mcfhwdiv|mcfmac,				mcf5206e, "5206e", 0 },
    { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf521x, "521x", 0 },
    { mcfisa_a|mcfhwdiv|mcfemac,			mcf5249, "5249", 0 },
    { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf528x, "528x", 0 },
    { mcfisa_a|mcfhwdiv|mcfmac,				mcf5307, "5307", 0 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac,		mcf5407, "5407", 0 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "547x", 0 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5480, "548x", 0 },
    /* Aliases (effectively, so far as gas is concerned) for the above
       cpus.  */
    { m68020,						m68020,	"68k", 1 },
    { m68000,						m68000,	"68008", 1 },
    { m68000,						m68000,	"68302", 1 },
    { m68000,						m68000,	"68306", 1 },
    { m68000,						m68000,	"68307", 1 },
    { m68000,						m68000,	"68322", 1 },
    { m68000,						m68000,	"68356", 1 },
    { m68000,						m68000,	"68ec000", 1 },
    { m68000,						m68000,	"68hc000", 1 },
    { m68000,						m68000,	"68hc001", 1 },
    { m68020,						m68020,	"68ec020", 1 },
    { m68030,						m68030,	"68ec030", 1 },
    { m68040,						m68040,	"68ec040", 1 },
    { m68060,						m68060,	"68ec060", 1 },
    { cpu32,						cpu32,	"68330", 1 },
    { cpu32,						cpu32,	"68331", 1 },
    { cpu32,						cpu32,	"68332", 1 },
    { cpu32,						cpu32,	"68333", 1 },
    { cpu32,						cpu32,	"68334", 1 },
    { cpu32,						cpu32,	"68336", 1 },
    { cpu32,						cpu32,	"68340", 1 },
    { cpu32,						cpu32,	"68341", 1 },
    { cpu32,						cpu32,	"68349", 1 },
    { cpu32,						cpu32,	"68360", 1 },
    { m68881,						m68881,	"68882", 1 },
    { mcfisa_a,						mcf5200, "5202", 1 },
    { mcfisa_a,						mcf5200, "5204", 1 },
    { mcfisa_a,						mcf5200, "5206", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_aa|mcfemac,		mcf521x, "5214", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_aa|mcfemac,		mcf521x, "5216", 1 },
    { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,		mcf528x, "5280", 1 },
    { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,		mcf528x, "5281", 1 },
    { mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac,		mcf528x, "5282", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac,		mcf5407, "cfv4", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5470", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5471", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5472", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5473", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5474", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5475", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5480", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5481", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5482", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5483", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5484", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "5485", 1 },
    { mcfisa_a|mcfhwdiv|mcfisa_b|mcfemac|mcfusp|cfloat,	mcf5470, "cfv4e", 1 },
  };
d513 6
a518 1
static const int n_archs = sizeof (archs) / sizeof (archs[0]);
d664 3
d774 2
a775 2
  for (i = 0, n_chips = 0, n_alias = 0; i < n_archs; ++i)
    if (archs[i].arch & architecture)
d778 1
a778 1
	if (archs[i].alias)
d788 2
a789 2
  for (i = 0, j = 0; i < n_archs && j < n_chips; ++i)
    if (archs[i].arch & architecture)
d812 1
a812 1
	strncpy (cp, archs[i].name, (sizeof (buf) - (cp - buf)));
d2094 1
a2094 1
		    for (idx = 0; idx < n_archs; idx++)
d2096 2
a2097 2
			if ((archs[idx].arch & ok_arch)
			    && ! archs[idx].alias)
d2105 1
a2105 1
			    strcpy (cp, archs[idx].name);
a3914 2
static int no_68851, no_68881;

d3926 11
d4382 1
a4382 1
    case m68000:
d4385 1
a4385 1
    case m68010:
d4388 2
a4389 2
    case m68020:
    case m68030:
d4392 1
a4392 1
    case m68040:
d4395 1
a4395 1
    case m68060:
d4398 1
a4398 1
    case cpu32:
d4401 4
a4404 4
    case mcf5200:
    case mcf5206e:
    case mcf5307:
    case mcf5407:
d4407 1
a4407 1
    case mcf5249:
d4410 2
a4411 2
    case mcf528x:
    case mcf521x:
d4414 2
a4415 2
    case mcf5470:
    case mcf5480:
d4418 9
a4431 55
void
m68k_init_after_args (void)
{
  if (cpu_of_arch (current_architecture) == 0)
    {
      int i;
      const char *default_cpu = TARGET_CPU;

      if (*default_cpu == 'm')
	default_cpu++;
      for (i = 0; i < n_archs; i++)
	if (strcasecmp (default_cpu, archs[i].name) == 0)
	  break;
      if (i == n_archs)
	{
	  as_bad (_("unrecognized default cpu `%s' ???"), TARGET_CPU);
	  current_architecture |= m68020;
	}
      else
	current_architecture |= archs[i].arch;
    }
  /* Permit m68881 specification with all cpus; those that can't work
     with a coprocessor could be doing emulation.  */
  if (current_architecture & m68851)
    {
      if (current_architecture & m68040)
	as_warn (_("68040 and 68851 specified; mmu instructions may assemble incorrectly"));
    }
  /* What other incompatibilities could we check for?  */

  /* Toss in some default assumptions about coprocessors.  */
  if (!no_68881
      && (cpu_of_arch (current_architecture)
	  /* Can CPU32 have a 68881 coprocessor??  */
	  & (m68020 | m68030 | cpu32)))
    current_architecture |= m68881;

  if (!no_68851
      && (cpu_of_arch (current_architecture) & m68020up) != 0
      && (cpu_of_arch (current_architecture) & m68040up) == 0)
    current_architecture |= m68851;

  if (no_68881 && (current_architecture & m68881))
    as_bad (_("options for 68881 and no-68881 both given"));

  if (no_68851 && (current_architecture & m68851))
    as_bad (_("options for 68851 and no-68851 both given"));

  /* Note which set of "movec" control registers is available.  */
  select_control_regs ();

  if (cpu_of_arch (current_architecture) < m68020
      || arch_coldfire_p (current_architecture))
    md_relax_table[TAB (PCINDEX, BYTE)].rlx_more = 0;
}
d5344 2
a5345 2
  for (i = 0; i < n_archs; i++)
    if (strcasecmp (s, archs[i].name) == 0)
d5347 1
a5347 1
  if (i >= n_archs)
d5360 2
a5361 2
  current_architecture |= archs[i].arch;
  current_chip = archs[i].chip;
d6961 195
d7158 1
a7158 20
   See if it's a processor-specific option.  These are:

   -[A]m[c]68000, -[A]m[c]68008, -[A]m[c]68010, -[A]m[c]68020, -[A]m[c]68030, -[A]m[c]68040
   -[A]m[c]68881, -[A]m[c]68882, -[A]m[c]68851
	Select the architecture.  Instructions or features not
	supported by the selected architecture cause fatal
	errors.  More than one may be specified.  The default is
	-m68020 -m68851 -m68881.  Note that -m68008 is a synonym
	for -m68000, and -m68882 is a synonym for -m68881.
   -[A]m[c]no-68851, -[A]m[c]no-68881
	Don't accept 688?1 instructions.  (The "c" is kind of silly,
	so don't use or document it, but that's the way the parsing
	works).

   -pic	Indicates PIC.
   -k	Indicates PIC.  (Sun 3 only.)
   --pcrel
	Never turn PC-relative branches into absolute jumps.
   --bitwise-or
 	Permit `|' to be used in expressions.  */
a7207 74
    case 'A':
      if (*arg == 'm')
	arg++;
      /* Intentional fall-through.  */
    case 'm':

      if (arg[0] == 'n' && arg[1] == 'o' && arg[2] == '-')
	{
	  int i;
	  unsigned long arch;

	  arg += 3;
	  if (*arg == 'm')
	    {
	      arg++;
	      if (arg[0] == 'c' && arg[1] == '6')
		arg++;
	    }
	  for (i = 0; i < n_archs; i++)
	    if (!strcmp (arg, archs[i].name))
	      break;
	  if (i == n_archs)
	    return 0;

	  arch = archs[i].arch;
	  if (arch == m68881)
	    no_68881 = 1;
	  else if (arch == m68851)
	    no_68851 = 1;
	  else
	    return 0;
	}
      else
	{
	  int i;

	  if (arg[0] == 'c' && arg[1] == '6')
	    arg++;

	  for (i = 0; i < n_archs; i++)
	    if (!strcmp (arg, archs[i].name))
	      {
		unsigned long arch = archs[i].arch;

		if (cpu_of_arch (arch))
		  /* It's a cpu spec.  */
		  {
		    current_architecture &= ~m68000up;
		    current_architecture |= arch;
		    current_chip = archs[i].chip;
		  }
		else if (arch == m68881)
		  {
		    current_architecture |= m68881;
		    no_68881 = 0;
		  }
		else if (arch == m68851)
		  {
		    current_architecture |= m68851;
		    no_68851 = 0;
		  }
		else
		  /* ??? */
		  abort ();
		break;
	      }
	  if (i == n_archs)
	    {
	      as_bad (_("unrecognized architecture specification `%s'"), arg);
	      return 0;
	    }
	}
      break;

d7261 19
d7287 58
d7355 1
a7355 1
  for (i = 0; i < n_archs; i++)
d7357 1
a7357 1
      if (strcasecmp (default_cpu, archs[i].name) == 0)
d7359 2
a7360 2
	  default_arch = archs[i].arch;
	  for (i = 0; i < n_archs; i++)
d7362 2
a7363 2
	      if (archs[i].arch == default_arch
		  && !archs[i].alias)
d7365 1
a7365 1
		  default_cpu = archs[i].name;
d7373 9
a7381 1
680X0 options:\n\
a7382 13
-m68000 | -m68008 | -m68010 | -m68020 | -m68030 | -m68040 | -m68060 |\n\
-m68302 | -m68331 | -m68332 | -m68333 | -m68340 | -m68360 | -mcpu32 |\n\
-m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m521x  | -m5249  |\n\
-m528x  | -m5307  | -m5407  | -m547x  | -m548x  | -mcfv4  | -mcfv4e\n\
			specify variant of 680X0 architecture [default %s]\n\
-m68881 | -m68882 | -mno-68881 | -mno-68882\n\
			target has/lacks floating-point coprocessor\n\
			[default yes for 68020, 68030, and cpu32]\n"),
          default_cpu);
  fprintf (stream, _("\
-m68851 | -mno-68851\n\
			target has/lacks memory-management unit coprocessor\n\
			[default yes for 68020 and up]\n\
d7388 1
a7388 2
--bitwise-or		do not treat `|' as a comment character\n"));
  fprintf (stream, _("\
d7392 20
a7411 1
--disp-size-default-32	displacement with unknown size is 32 bits (default)\n"));
d7558 4
a7562 2
  if (arch_coldfire_fpu (current_architecture))
    elf_elfheader (stdoutput)->e_flags |= EF_CFV4E;
d7564 1
a7564 1
    elf_elfheader (stdoutput)->e_flags |= EF_CPU32;
d7567 27
a7593 1
    elf_elfheader (stdoutput)->e_flags |= EF_M68000;
@


1.69
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d4397 4
@


1.68
log
@PR991
* config/tc-m68k.c (m68k_ip): Test for insn compatiblity using a temporary copy
  of the operands array so that changes can be safely backed out if the insn
  does not match.
  (m68k_compare_opcode): Shortcut the test when the parameters are the same.
  Return 1 if the names match but the second opcode is further on in the array
  than the first.
@
text
@a72 2
const int md_reloc_size = 8;	/* Size of relocation record.  */

a740 57
#if defined (M68KCOFF) && !defined (BFD_ASSEMBLER)

#ifdef NO_PCREL_RELOCS

int
make_pcrel_absolute (fixS *fixP, long *add_number)
{
  register unsigned char *opcode = fixP->fx_frag->fr_opcode;

  /* Rewrite the PC relative instructions to absolute address ones.
     these are rumored to be faster, and the apollo linker refuses
     to deal with the PC relative relocations.  */
  if (opcode[0] == 0x60 && opcode[1] == 0xff) /* BRA -> JMP.  */
    {
      if (flag_keep_pcrel)
    	as_fatal (_("Tried to convert PC relative branch to absolute jump"));
      opcode[0] = 0x4e;
      opcode[1] = 0xf9;
    }
  else if (opcode[0] == 0x61 && opcode[1] == 0xff) /* BSR -> JSR.  */
    {
      if (flag_keep_pcrel)
    	as_fatal (_("Tried to convert PC relative BSR to absolute JSR"));
      opcode[0] = 0x4e;
      opcode[1] = 0xb9;
    }
  else
    as_fatal (_("Unknown PC relative instruction"));
  *add_number -= 4;
  return 0;
}

#endif /* NO_PCREL_RELOCS */

short
tc_coff_fix2rtype (fixS *fixP)
{
  if (fixP->fx_tcbit && fixP->fx_size == 4)
    return R_RELLONG_NEG;
#ifdef NO_PCREL_RELOCS
  know (fixP->fx_pcrel == 0);
  return (fixP->fx_size == 1 ? R_RELBYTE
	  : fixP->fx_size == 2 ? R_DIR16
	  : R_DIR32);
#else
  return (fixP->fx_pcrel
	  ? (fixP->fx_size == 1 ? R_PCRBYTE
	     : fixP->fx_size == 2 ? R_PCRWORD
	     : R_PCRLONG)
	  : (fixP->fx_size == 1 ? R_RELBYTE
	     : fixP->fx_size == 2 ? R_RELWORD
	     : R_RELLONG));
#endif
}

#endif

a899 2
#ifdef BFD_ASSEMBLER

a1009 2
#endif /* BFD_ASSEMBLER */

a2212 3
#ifndef BFD_ASSEMBLER
		  opP->disp.exp.X_add_symbol = &abs_symbol;
#else
a2214 1
#endif
a3829 5
#ifdef OBJ_AOUT
/* a.out machine type.  Default to 68020.  */
int m68k_aout_machtype = 2;
#endif

a4374 12
#ifdef OBJ_AOUT
  /* Work out the magic number.  This isn't very general.  */
  if (current_architecture & m68000)
    m68k_aout_machtype = 0;
  else if (current_architecture & m68010)
    m68k_aout_machtype = 1;
  else if (current_architecture & m68020)
    m68k_aout_machtype = 2;
  else
    m68k_aout_machtype = 2;
#endif

a4572 1
#ifdef BFD_ASSEMBLER
a4575 1
#endif
d4629 1
a4629 4
#ifdef BFD_ASSEMBLER
       || fixP->fx_r_type == BFD_RELOC_8_PCREL
#endif
       )
a4856 12
#ifndef BFD_ASSEMBLER

void
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  md_convert_frag_1 (fragP);
}

#else

a4863 1
#endif
a5021 32
#ifndef BFD_ASSEMBLER
void
tc_aout_fix_to_chars (char *where, fixS *fixP,
		      relax_addressT segment_address_in_file)
{
  /*
   * In: length of relocation (or of address) in chars: 1, 2 or 4.
   * Out: GNU LD relocation length code: 0, 1, or 2.
   */

  static const unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
  long r_symbolnum;

  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
		      (fixP->fx_frag->fr_address
		       + fixP->fx_where - segment_address_in_file), 4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  where[4] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[6] = r_symbolnum & 0x0ff;
  where[7] = (((fixP->fx_pcrel << 7) & 0x80)
	      | ((nbytes_r_length[fixP->fx_size] << 5) & 0x60)
	      | ((!S_IS_DEFINED (fixP->fx_addsy) << 4) & 0x10));
}
#endif

a7276 1
#ifdef BFD_ASSEMBLER
a7286 1
#endif
a7307 28
#ifndef BFD_ASSEMBLER
#ifdef OBJ_COFF

void
tc_coff_symbol_emit_hook (symbolS *ignore ATTRIBUTE_UNUSED)
{
}

int
tc_coff_sizemachdep (fragS *frag)
{
  switch (frag->fr_subtype & 0x3)
    {
    case BYTE:
      return 1;
    case SHORT:
      return 2;
    case LONG:
      return 4;
    default:
      abort ();
      return 0;
    }
}

#endif
#endif

@


1.67
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d1092 1
d1217 9
a1225 1
	  for (s = opcode->m_operands, opP = &the_ins.operands[0];
d1986 6
d4134 3
d4147 1
a4147 1
  return 0;
@


1.66
log
@Update the address and phone number of the FSF
@
text
@d4608 1
a4608 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.65
log
@2005-04-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-m68k.c (md_begin): Support 64bit host.
	(get_num): Support 64bit BFD on 32bit host.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.64
log
@	PR gas/780
	* config/tc-m68k.c (TRUNC, SEXT): Define.
	(issbyte, isubyte, issword, isuword, isbyte, isword): Use the above.
	(m68k_ip): Truncate or sign extend expressions as appropriate.
	(get_num): Likewise.
	(md_apply_fix3): Use SEXT.
@
text
@d4163 1
a4163 1
	      m68k_numopcodes * sizeof (* m68k_sorted_opcodes));
d5295 1
a5295 1
		   offs (exp));
d5307 1
a5307 1
		   offs (exp));
@


1.63
log
@Add support for generating PLT lookups for the ColdFire.
@
text
@d654 9
a662 4
#define issbyte(x)	((x) >= -128 && (x) <= 127)
#define isubyte(x)	((x) >= 0 && (x) <= 255)
#define issword(x)	((x) >= -32768 && (x) <= 32767)
#define isuword(x)	((x) >= 0 && (x) <= 65535)
d664 2
a665 2
#define isbyte(x)	((x) >= -255 && (x) <= 255)
#define isword(x)	((x) >= -65536 && (x) <= 65535)
d1770 1
a1770 2
			   || opP->disp.exp.X_add_number < 1
			   || opP->disp.exp.X_add_number > 8)
d1816 1
a1816 2
			   || opP->disp.exp.X_add_number < 0
			   || opP->disp.exp.X_add_number > 7)
d1829 2
a1830 3
			   || opP->disp.exp.X_add_number < -1
                           || opP->disp.exp.X_add_number > 7
                           || opP->disp.exp.X_add_number == 0)
d2311 1
a2311 1
					offs (&opP->disp),
d2483 2
a2484 1
			  add_frag (adds (&opP->disp), offs (&opP->disp),
d2627 1
a2627 1
				offs (&opP->disp),
d2810 2
a2811 1
		add_frag (adds (&opP->disp), offs (&opP->disp),
d2817 2
a2818 1
		    add_frag (adds (&opP->disp), offs (&opP->disp),
d2821 2
a2822 1
		    add_frag (adds (&opP->disp), offs (&opP->disp),
d2826 2
a2827 1
		add_frag (adds (&opP->disp), offs (&opP->disp),
d2841 2
a2842 1
			add_frag (adds (&opP->disp), offs (&opP->disp),
d2845 2
a2846 1
			add_frag (adds (&opP->disp), offs (&opP->disp),
d2868 2
a2869 1
		add_frag (adds (&opP->disp), offs (&opP->disp),
d4620 1
a4620 1
  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;
d5219 1
a5219 1
	  if (offs (exp) < 1 || offs (exp) > 8)
d5226 1
a5226 1
	  if (offs (exp) < 0 || offs (exp) > 7)
d5230 1
a5230 1
	  if (offs (exp) < 0 || offs (exp) > 15)
d5234 1
a5234 1
	  if (offs (exp) < 0 || offs (exp) > 32)
d5238 1
a5238 1
	  if (offs (exp) < 0 || offs (exp) > 127)
d5242 1
a5242 1
	  if (offs (exp) < -64 || offs (exp) > 63)
d5246 1
a5246 1
	  if (offs (exp) < -128 || offs (exp) > 127)
d5250 1
a5250 1
	  if (offs (exp) < 0 || offs (exp) > 4095)
d5258 2
a5259 3
	  if (offs (exp) < -1
              || offs (exp) > 7
              || offs (exp) == 0)
@


1.62
log
@	* config/tc-m68k.c (md_assemble): Don't use sizeof host short.
@
text
@d7450 2
@


1.62.2.1
log
@	PR gas/780
	* config/tc-m68k.c (TRUNC, SEXT): Define.
	(issbyte, isubyte, issword, isuword, isbyte, isword): Use the above.
	(m68k_ip): Truncate or sign extend expressions as appropriate.
	(get_num): Likewise.
	(md_apply_fix3): Use SEXT.
@
text
@d654 4
a657 9
/* Truncate and sign-extend at 32 bits, so that building on a 64-bit host
   gives identical results to a 32-bit host.  */
#define TRUNC(X)	((valueT) (X) & 0xffffffff)
#define SEXT(X)		((TRUNC (X) ^ 0x80000000) - 0x80000000)

#define issbyte(x)	((valueT) SEXT (x) + 0x80 < 0x100)
#define isubyte(x)	((valueT) TRUNC (x) < 0x100)
#define issword(x)	((valueT) SEXT (x) + 0x8000 < 0x10000)
#define isuword(x)	((valueT) TRUNC (x) < 0x10000)
d659 2
a660 2
#define isbyte(x)	((valueT) SEXT (x) + 0xff < 0x1ff)
#define isword(x)	((valueT) SEXT (x) + 0xffff < 0x1ffff)
d1765 2
a1766 1
			   || TRUNC (opP->disp.exp.X_add_number) - 1 > 7)
d1812 2
a1813 1
			   || TRUNC (opP->disp.exp.X_add_number) > 7)
d1826 3
a1828 2
			   || (TRUNC (opP->disp.exp.X_add_number) != 0xffffffff
			       && TRUNC (opP->disp.exp.X_add_number) - 1 > 6))
d2309 1
a2309 1
					SEXT (offs (&opP->disp)),
d2481 1
a2481 2
			  add_frag (adds (&opP->disp),
				    SEXT (offs (&opP->disp)),
d2624 1
a2624 1
				SEXT (offs (&opP->disp)),
d2807 1
a2807 2
		add_frag (adds (&opP->disp),
			  SEXT (offs (&opP->disp)),
d2813 1
a2813 2
		    add_frag (adds (&opP->disp),
			      SEXT (offs (&opP->disp)),
d2816 1
a2816 2
		    add_frag (adds (&opP->disp),
			      SEXT (offs (&opP->disp)),
d2820 1
a2820 2
		add_frag (adds (&opP->disp),
			  SEXT (offs (&opP->disp)),
d2834 1
a2834 2
			add_frag (adds (&opP->disp),
				  SEXT (offs (&opP->disp)),
d2837 1
a2837 2
			add_frag (adds (&opP->disp),
				  SEXT (offs (&opP->disp)),
d2859 1
a2859 2
		add_frag (adds (&opP->disp),
			  SEXT (offs (&opP->disp)),
d4610 1
a4610 1
  val = SEXT (val);
d5209 1
a5209 1
	  if ((valueT) TRUNC (offs (exp)) - 1 > 7)
d5216 1
a5216 1
	  if ((valueT) TRUNC (offs (exp)) > 7)
d5220 1
a5220 1
	  if ((valueT) TRUNC (offs (exp)) > 15)
d5224 1
a5224 1
	  if ((valueT) TRUNC (offs (exp)) > 32)
d5228 1
a5228 1
	  if ((valueT) TRUNC (offs (exp)) > 127)
d5232 1
a5232 1
	  if ((valueT) SEXT (offs (exp)) + 64 > 127)
d5236 1
a5236 1
	  if ((valueT) SEXT (offs (exp)) + 128 > 255)
d5240 1
a5240 1
	  if ((valueT) TRUNC (offs (exp)) > 4095)
d5248 3
a5250 2
	  if ((valueT) TRUNC (offs (exp)) != 0xffffffff
              && (valueT) TRUNC (offs (exp)) - 1 > 6)
@


1.61
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d4070 1
a4070 1
      toP = frag_more (n * sizeof (short));
@


1.60
log
@	* symbols.c (colon) [!WORKING_DOT_WORD]: Don't declare
	md_short_jump_size, md_long_jump_size.
	* write.c [!WORKING_DOT_WORD]: Ditto.
	* tc.h [!WORKING_DOT_WORD]: Declare them here.  Drop const
	qualifier.
	* config/tc-cris.h (md_short_jump_size, md_long_jump_size): Don't
	declare.
	* config/tc-cris.c (md_short_jump_size, md_long_jump_size): Drop
	const qualifier in these definitions.
	* config/tc-i370.c, config/tc-m68k.c, config/tc-pdp11.c,
	config/tc-s390.c, config/tc-tahoe.c, config/tc-vax.c: Ditto.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a7094 1
	  const char *oarg = arg;
@


1.59
log
@m68k-parse.h (enum m68k_register): New control register, MBAR2 (for MCF5249)
tc-m68k.c: Correct control register set for MCF5249.
@
text
@d5131 2
a5132 2
const int md_short_jump_size = 4;
const int md_long_jump_size = 6;
@


1.58
log
@(select_control_regs): Add mcf5249.
@
text
@d181 4
d2996 1
d3762 2
a4350 1
    case mcf5249:
d4355 3
@


1.57
log
@Add support for a -g switch to GAS
@
text
@d4344 1
@


1.56
log
@	* config/tc-m68k.c: Convert to C90.  Remove redundant
	declarations.  Indentation fixup.
	[M68KCOFF]: Include "obj-coff.h" instead of declaring
	obj_coff_section ourselves.
@
text
@d7098 2
a7099 5
	    {
	    unknown:
	      as_bad (_("unrecognized option `%s'"), oarg);
	      return 0;
	    }
d7106 1
a7106 1
	    goto unknown;
d7119 1
@


1.55
log
@	* config/tc-m68k.c (mri_chip): Replace current_chip, not augment.
	(md_parse_option): Likewise.
@
text
@d36 4
d262 1
a262 6
#define addword(w)	the_ins.opcode[the_ins.numo++]=(w)

/* Static functions.  */
static void insop PARAMS ((int, const struct m68k_incant *));
static void add_fix PARAMS ((int, struct m68k_exp *, int, int));
static void add_frag PARAMS ((symbolS *, offsetT, int));
d267 1
a267 3
insop (w, opcode)
     int w;
     const struct m68k_incant *opcode;
d283 7
a289 11
add_fix (width, exp, pc_rel, pc_fix)
     int width;
     struct m68k_exp *exp;
     int pc_rel;
     int pc_fix;
{
  the_ins.reloc[the_ins.nrel].n = ((width == 'B' || width == '3')
				   ? (the_ins.numo*2-1)
				   : (((width)=='b')
				      ? (the_ins.numo*2+1)
				      : (the_ins.numo*2)));
d310 1
a310 4
add_frag (add, off, type)
     symbolS *add;
     offsetT off;
     int type;
d321 28
a348 34
static char *crack_operand PARAMS ((char *str, struct m68k_op *opP));
static int get_num PARAMS ((struct m68k_exp *exp, int ok));
static void m68k_ip PARAMS ((char *));
static void insert_reg PARAMS ((const char *, int));
static void select_control_regs PARAMS ((void));
static void init_regtable PARAMS ((void));
static int reverse_16_bits PARAMS ((int in));
static int reverse_8_bits PARAMS ((int in));
static void install_gen_operand PARAMS ((int mode, int val));
static void install_operand PARAMS ((int mode, int val));
static void s_bss PARAMS ((int));
static void s_data1 PARAMS ((int));
static void s_data2 PARAMS ((int));
static void s_even PARAMS ((int));
static void s_proc PARAMS ((int));
static void mri_chip PARAMS ((void));
static void s_chip PARAMS ((int));
static void s_fopt PARAMS ((int));
static void s_opt PARAMS ((int));
static void s_reg PARAMS ((int));
static void s_restore PARAMS ((int));
static void s_save PARAMS ((int));
static void s_mri_if PARAMS ((int));
static void s_mri_else PARAMS ((int));
static void s_mri_endi PARAMS ((int));
static void s_mri_break PARAMS ((int));
static void s_mri_next PARAMS ((int));
static void s_mri_for PARAMS ((int));
static void s_mri_endf PARAMS ((int));
static void s_mri_repeat PARAMS ((int));
static void s_mri_until PARAMS ((int));
static void s_mri_while PARAMS ((int));
static void s_mri_endw PARAMS ((int));
static void md_convert_frag_1 PARAMS ((fragS *));
d622 1
a622 6
   don't start with a . they look like opcodes to gas.
   */

#ifdef M68KCOFF
extern void obj_coff_section PARAMS ((int));
#endif
d650 4
a653 4
#define issbyte(x)	((x)>=-128 && (x)<=127)
#define isubyte(x)	((x)>=0 && (x)<=255)
#define issword(x)	((x)>=-32768 && (x)<=32767)
#define isuword(x)	((x)>=0 && (x)<=65535)
d655 2
a656 2
#define isbyte(x)	((x)>= -255 && (x)<=255)
#define isword(x)	((x)>=-65536 && (x)<=65535)
a658 2
extern char *input_line_pointer;

d699 1
a699 1
	    if (((j == n_chips - 1) && !(n_alias > 1))|| ! n_alias)
d739 1
a739 3
make_pcrel_absolute (fixP, add_number)
    fixS *fixP;
    long *add_number;
d769 1
a769 2
tc_coff_fix2rtype (fixP)
     fixS *fixP;
d779 7
a785 7
  return (fixP->fx_pcrel ?
	  (fixP->fx_size == 1 ? R_PCRBYTE :
	   fixP->fx_size == 2 ? R_PCRWORD :
	   R_PCRLONG) :
	  (fixP->fx_size == 1 ? R_RELBYTE :
	   fixP->fx_size == 2 ? R_RELWORD :
	   R_RELLONG));
a809 3
static bfd_reloc_code_real_type get_reloc_code
  PARAMS ((int, int, enum pic_relocation));

d811 1
a811 4
get_reloc_code (size, pcrel, pic)
     int size;
     int pcrel;
     enum pic_relocation pic;
d914 1
a914 2
tc_m68k_fix_adjustable (fixP)
     fixS *fixP;
d953 1
a953 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d1071 1
a1071 2
m68k_ip (instring)
     char *instring;
d1189 1
a1189 2
      memset ((char *) (&the_ins.operands[0]), '\0',
	      sizeof (the_ins.operands[0]));
d1954 2
a1955 2
			 || (opP->mode == DISP && !(opP->reg == PC ||
						    opP->reg == ZPC))))
d1986 2
a1987 1
		      _("invalid instruction for this architecture; needs "), sizeof (buf));
d1992 2
a1993 1
		  strncpy (cp, _("ColdFire ISA_A"), (sizeof (buf) - (cp - buf)));
d1995 2
a1996 1
		  strncpy (cp, find_cf_chip (ok_arch), (sizeof (buf) - (cp - buf)));
d2000 2
a2001 1
		  strncpy (cp, _("ColdFire hardware divide"), (sizeof (buf) - (cp - buf)));
d2003 2
a2004 1
		  strncpy (cp, find_cf_chip (ok_arch), (sizeof (buf) - (cp - buf)));
d2008 2
a2009 1
		  strncpy (cp, _("ColdFire ISA_A+"), (sizeof (buf) - (cp - buf)));
d2011 2
a2012 1
		  strncpy (cp, find_cf_chip (ok_arch), (sizeof (buf) - (cp - buf)));
d2016 2
a2017 1
		  strncpy (cp, _("ColdFire ISA_B"), (sizeof (buf) - (cp - buf)));
d2019 2
a2020 1
		  strncpy (cp, find_cf_chip (ok_arch), (sizeof (buf) - (cp - buf)));
d2024 1
a2024 1
		  strncpy (cp, _("ColdFire fpu"), (sizeof (buf) - (cp - buf)));
d2026 2
a2027 1
		  strncpy (cp, find_cf_chip (ok_arch), (sizeof (buf) - (cp - buf)));
d2088 1
a2088 1
       Watch the first step; its a big one! */
d3308 1
a3308 2
reverse_16_bits (in)
     int in;
d3327 1
a3327 2
reverse_8_bits (in)
     int in;
d3356 1
a3356 3
install_operand (mode, val)
     int mode;
     int val;
d3485 1
a3485 3
install_gen_operand (mode, val)
     int mode;
     int val;
d3520 1
a3520 3
crack_operand (str, opP)
     register char *str;
     register struct m68k_op *opP;
d3590 1
a3590 3
insert_reg (regname, regnum)
     const char *regname;
     int regnum;
d3856 1
a3856 1
init_regtable ()
d3871 1
a3871 2
md_assemble (str)
     char *str;
d3916 1
a3916 1
  memset ((char *) (&the_ins), '\0', sizeof (the_ins));
d4312 1
a4312 1
select_control_regs ()
d4362 1
a4362 1
m68k_init_after_args ()
d4432 1
a4432 2
m68k_frob_label (sym)
     symbolS *sym;
d4448 1
a4448 1
m68k_flush_pending_output ()
d4458 1
a4458 2
m68k_frob_symbol (sym)
     symbolS *sym;
d4488 1
a4488 2
m68k_mri_mode_change (on)
     int on;
d4531 1
a4531 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d4582 1
a4582 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d4588 1
a4588 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d4693 1
a4693 2
md_convert_frag_1 (fragP)
     register fragS *fragP;
d4911 3
a4913 4
md_convert_frag (headers, sec, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
d4921 3
a4923 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
d4933 1
a4933 3
md_estimate_size_before_relax (fragP, segment)
     register fragS *fragP;
     segT segment;
d5071 1
a5071 3
md_ri_to_chars (the_bytes, ri)
     char *the_bytes;
     struct reloc_info_generic *ri;
d5079 3
a5081 2
  the_bytes[7] = (((ri->r_pcrel << 7) & 0x80) | ((ri->r_length << 5) & 0x60) |
		  ((ri->r_extern << 4) & 0x10));
d5088 2
a5089 4
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
d5102 2
a5103 2
       fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);
d5112 3
a5114 2
  where[7] = (((fixP->fx_pcrel << 7) & 0x80) | ((nbytes_r_length[fixP->fx_size] << 5) & 0x60) |
	      (((!S_IS_DEFINED (fixP->fx_addsy)) << 4) & 0x10));
d5125 3
a5127 5
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d5138 2
a5139 5
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
d5179 1
a5179 3
get_num (exp, ok)
     struct m68k_exp *exp;
     int ok;
d5316 1
a5316 2
s_data1 (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5323 1
a5323 2
s_data2 (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5330 1
a5330 2
s_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5340 1
a5340 2
s_even (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5354 1
a5354 2
s_proc (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5366 1
a5366 2
m68k_conditional_pseudoop (pop)
     pseudo_typeS *pop;
d5375 1
a5375 1
mri_chip ()
d5429 1
a5429 2
s_chip (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5445 1
a5445 2
s_fopt (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5480 1
a5480 1
  void (*pfn) PARAMS ((int arg, int on));
d5498 5
a5502 5
static void skip_to_comma PARAMS ((int, int));
static void opt_nest PARAMS ((int, int));
static void opt_chip PARAMS ((int, int));
static void opt_list PARAMS ((int, int));
static void opt_list_symbols PARAMS ((int, int));
d5554 1
a5554 2
s_opt (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5621 1
a5621 3
skip_to_comma (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
d5631 1
a5631 3
opt_nest (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
d5646 1
a5646 3
opt_chip (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
d5661 1
a5661 3
opt_list (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on;
d5669 1
a5669 3
opt_list_symbols (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on;
d5680 1
a5680 2
s_reg (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5784 1
a5784 2
s_save (ignore)
     int ignore ATTRIBUTE_UNUSED;
d5809 1
a5809 2
s_restore (ignore)
     int ignore ATTRIBUTE_UNUSED;
a5886 18
/* Some function prototypes.  */

static void mri_assemble PARAMS ((char *));
static char *mri_control_label PARAMS ((void));
static struct mri_control_info *push_mri_control
  PARAMS ((enum mri_control_type));
static void pop_mri_control PARAMS ((void));
static int parse_mri_condition PARAMS ((int *));
static int parse_mri_control_operand
  PARAMS ((int *, char **, char **, char **, char **));
static int swap_mri_condition PARAMS ((int));
static int reverse_mri_condition PARAMS ((int));
static void build_mri_control_operand
  PARAMS ((int, int, char *, char *, char *, char *, const char *,
	   const char *, int));
static void parse_mri_control_expression
  PARAMS ((char *, int, const char *, const char *, int));

d5890 1
a5890 2
mri_assemble (str)
     char *str;
d5904 1
a5904 1
mri_control_label ()
d5917 1
a5917 2
push_mri_control (type)
     enum mri_control_type type;
d5941 1
a5941 1
pop_mri_control ()
d5957 1
a5957 2
parse_mri_condition (pcc)
     int *pcc;
d5987 2
a5988 6
parse_mri_control_operand (pcc, leftstart, leftstop, rightstart, rightstop)
     int *pcc;
     char **leftstart;
     char **leftstop;
     char **rightstart;
     char **rightstop;
d6061 1
a6061 2
swap_mri_condition (cc)
     int cc;
d6095 1
a6095 2
reverse_mri_condition (cc)
     int cc;
d6129 4
a6132 11
build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
			   rightstop, truelab, falselab, extent)
     int qual;
     int cc;
     char *leftstart;
     char *leftstop;
     char *rightstart;
     char *rightstop;
     const char *truelab;
     const char *falselab;
     int extent;
d6165 14
a6178 14
     /* Correct conditional handling:
        if #1 <lt> d0 then  ;means if (1 < d0)
           ...
        endi

        should assemble to:

         cmp #1,d0        if we do *not* swap the operands
         bgt true         we need the swapped condition!
         ble false
        true:
         ...
        false:
     */
d6241 2
a6242 6
parse_mri_control_expression (stop, qual, truelab, falselab, extent)
     char *stop;
     int qual;
     const char *truelab;
     const char *falselab;
     int extent;
d6347 1
a6347 2
s_mri_if (qual)
     int qual;
d6361 6
a6366 6
  while ( ! (    is_end_of_line[(unsigned char) *s]
              || (     flag_mri
                   && *s == '*'
                   && (    s == input_line_pointer
                        || *(s-1) == ' '
                        || *(s-1) == '\t'))))
d6431 1
a6431 2
s_mri_else (qual)
     int qual;
d6490 1
a6490 2
s_mri_endi (ignore)
     int ignore ATTRIBUTE_UNUSED;
d6521 1
a6521 2
s_mri_break (extent)
     int extent;
d6559 1
a6559 2
s_mri_next (extent)
     int extent;
d6597 1
a6597 2
s_mri_for (qual)
     int qual;
d6828 1
a6828 2
s_mri_endf (ignore)
     int ignore ATTRIBUTE_UNUSED;
d6863 1
a6863 2
s_mri_repeat (ignore)
     int ignore ATTRIBUTE_UNUSED;
d6880 1
a6880 2
s_mri_until (qual)
     int qual;
d6918 1
a6918 2
s_mri_while (qual)
     int qual;
d6974 1
a6974 2
s_mri_endw (ignore)
     int ignore ATTRIBUTE_UNUSED;
d7004 22
a7025 25
/*
 * md_parse_option
 *	Invocation line includes a switch not recognized by the base assembler.
 *	See if it's a processor-specific option.  These are:
 *
 *	-[A]m[c]68000, -[A]m[c]68008, -[A]m[c]68010, -[A]m[c]68020, -[A]m[c]68030, -[A]m[c]68040
 *	-[A]m[c]68881, -[A]m[c]68882, -[A]m[c]68851
 *		Select the architecture.  Instructions or features not
 *		supported by the selected architecture cause fatal
 *		errors.  More than one may be specified.  The default is
 *		-m68020 -m68851 -m68881.  Note that -m68008 is a synonym
 *		for -m68000, and -m68882 is a synonym for -m68881.
 *	-[A]m[c]no-68851, -[A]m[c]no-68881
 *		Don't accept 688?1 instructions.  (The "c" is kind of silly,
 *		so don't use or document it, but that's the way the parsing
 *		works).
 *
 *	-pic	Indicates PIC.
 *	-k	Indicates PIC.  (Sun 3 only.)
 *      --pcrel Never turn PC-relative branches into absolute jumps.
 *
 *	--bitwise-or
 *		Permit `|' to be used in expressions.
 *
 */
d7056 1
a7056 3
md_parse_option (c, arg)
     int c;
     char *arg;
d7213 1
a7213 2
md_show_usage (stream)
     FILE *stream;
d7273 1
a7273 1
main ()
d7314 2
a7315 1
	  printf ("mode %d, reg %d, ", the_ins.operands[n].mode, the_ins.operands[n].reg);
d7317 5
a7321 2
	    printf ("Constant: '%.*s', ", 1 + the_ins.operands[n].e_const - the_ins.operands[n].b_const, the_ins.operands[n].b_const);
	  printf ("ireg %d, isiz %d, imul %d, ", the_ins.operands[n].ireg, the_ins.operands[n].isiz, the_ins.operands[n].imul);
d7323 4
a7326 2
	    printf ("Iadd: '%.*s',", 1 + the_ins.operands[n].e_iadd - the_ins.operands[n].b_iadd, the_ins.operands[n].b_iadd);
	  (void) putchar ('\n');
d7333 2
a7334 2
is_label (str)
     char *str;
d7367 1
a7367 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d7374 1
a7374 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d7398 1
a7398 2
md_pcrel_from (fixP)
     fixS *fixP;
d7414 1
a7414 2
tc_coff_symbol_emit_hook (ignore)
     symbolS *ignore ATTRIBUTE_UNUSED;
d7419 1
a7419 2
tc_coff_sizemachdep (frag)
     fragS *frag;
d7437 1
d7440 1
a7440 1
m68k_elf_final_processing ()
@


1.54
log
@Convert mode 5 addressing with zero offset into mode 2 addressing to save a
word.
@
text
@d5474 1
a5474 1
  current_chip |= archs[i].chip;
d7267 1
a7267 1
		    current_chip |= archs[i].chip;
@


1.53
log
@Sort m68k opcodes into alphabetical order
@
text
@d2264 13
@


1.52
log
@Reorganise m68k instruction decoding and improve handling of MAC/EMAC
@
text
@d133 3
d4119 21
d4141 1
a4141 1
md_begin ()
d4143 7
a4149 4
  /*
   * md_begin -- set up hash tables with 68000 instructions.
   * similar to what the vax assembler does.  ---phr
   */
a4156 5
  const struct m68k_opcode *ins;
  struct m68k_incant *hack, *slak;
  const char *retval = 0;	/* Empty string, or error msg text.  */
  int i;

d4165 14
d4187 4
a4190 3
	  ins = &m68k_opcodes[i];
	  /* We *could* ignore insns that don't match our arch here
	     but just leaving them out of the hash.  */
d4198 1
a4198 1
	      && !strcmp (ins->name, m68k_opcodes[i + 1].name))
d4200 1
a4200 1
	      slak->m_next = (struct m68k_incant *) obstack_alloc (&robyn, sizeof (struct m68k_incant));
d4219 1
d4258 1
d4272 1
d4289 1
a4289 2
       cas2 %d0:%d2,%d3:%d4,(%a0):(%a1)
     */
d4293 1
a4293 2
       cas2 %d0:%d2,%d3:%d4,@@(%d0):@@(%d1)
     */
d4297 1
a4297 2
       bfextu %d0{24:1},%d0
     */
d4314 1
d4317 1
a4317 2
	hack = (struct m68k_incant *)
	  obstack_alloc (&robyn, sizeof (struct m68k_incant));
d4412 1
a4412 3
	{
	  as_warn (_("68040 and 68851 specified; mmu instructions may assemble incorrectly"));
	}
d4421 2
a4422 3
    {
      current_architecture |= m68881;
    }
d4426 2
a4427 3
    {
      current_architecture |= m68851;
    }
d4430 1
@


1.51
log
@Add support for 521x,5249,547x,548x.
@
text
@d3479 1
a3479 1
    case 'G':
d3483 1
a3483 1
    case 'H':
@


1.50
log
@Add support for ColdFire MAC instructions and tidy up support for other m68k
variants.
@
text
@d238 1
a238 1
#define cpu_of_arch(x)		((x) & (m68000up | mcf))
d241 2
a242 2
#define arch_coldfire_p(x)	((x) & mcf)
#define arch_coldfire_v4e_p(x)	((x) & mcfv4e)
d245 1
a245 1
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|mcf5407|mcfv4e))
d364 1
d369 1
d376 18
a393 15
    { m68000,		"68000", 0 },
    { m68010,		"68010", 0 },
    { m68020,		"68020", 0 },
    { m68030,		"68030", 0 },
    { m68040,		"68040", 0 },
    { m68060,		"68060", 0 },
    { cpu32,		"cpu32", 0 },
    { m68881,		"68881", 0 },
    { m68851,		"68851", 0 },
    { mcf5200,		"5200",  0 },
    { mcf5206e,		"5206e", 0 },
    { mcf528x|mcfmac,	"528x",  0 },
    { mcf5307|mcfmac,	"5307",  0 },
    { mcf5407|mcfmac,	"5407",  0 },
    { mcfv4e|mcfemac,	"cfv4e", 0 },
d396 47
a442 29
    { m68020,		"68k", 1 },
    { m68000,		"68008", 1 },
    { m68000,		"68302", 1 },
    { m68000,		"68306", 1 },
    { m68000,		"68307", 1 },
    { m68000,		"68322", 1 },
    { m68000,		"68356", 1 },
    { m68000,		"68ec000", 1 },
    { m68000,		"68hc000", 1 },
    { m68000,		"68hc001", 1 },
    { m68020,		"68ec020", 1 },
    { m68030,		"68ec030", 1 },
    { m68040,		"68ec040", 1 },
    { m68060,		"68ec060", 1 },
    { cpu32,		"68330", 1 },
    { cpu32,		"68331", 1 },
    { cpu32,		"68332", 1 },
    { cpu32,		"68333", 1 },
    { cpu32,		"68334", 1 },
    { cpu32,		"68336", 1 },
    { cpu32,		"68340", 1 },
    { cpu32,		"68341", 1 },
    { cpu32,		"68349", 1 },
    { cpu32,		"68360", 1 },
    { m68881,		"68882", 1 },
    { mcf5200,		"5202", 1 },
    { mcf5200,		"5204", 1 },
    { mcf5200,		"5206", 1 },
    { mcf5407|mcfmac,	"cfv4", 1 },
d686 68
d759 1
a759 1
make_pcrel_absolute(fixP, add_number)
d771 1
a771 1
    	as_fatal(_("Tried to convert PC relative branch to absolute jump"));
d778 1
a778 1
    	as_fatal(_("Tried to convert PC relative BSR to absolute JSR"));
d2019 2
a2020 2
	      strcpy (buf,
		      _("invalid instruction for this architecture; needs "));
d2024 24
d2049 4
a2052 1
		  strcpy (cp, _("ColdFire fpu (cfv4e)"));
d2072 2
a2073 3
		    for (idx = 0;
			 idx < (int) (sizeof (archs) / sizeof (archs[0]));
			 idx++)
d2401 1
a2401 1
                              && !arch_coldfire_v4e_p(current_architecture))))
d3497 1
a3497 1
}				/* install_operand() */
d3531 1
a3531 1
}				/* install_gen_operand() */
d3533 2
a3534 4
/*
 * verify that we have some number of paren pairs, do m68k_ip_op(), and
 * then deal with the bitfield hack.
 */
d4303 1
a4303 1
  switch (cpu_of_arch (current_architecture))
d4306 2
a4307 1
      as_warn (_("architecture not yet selected: defaulting to 68020"));
d4337 1
d4340 2
a4341 1
    case mcfv4e:
d4749 1
a4749 1
    	    as_fatal(_("Tried to convert PC relative BSR to absolute JSR"));
d4759 1
a4759 1
	    as_fatal(_("Tried to convert PC relative branch to absolute jump"));
d4775 1
a4775 1
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));
d4815 1
a4815 1
    	as_fatal(_("Tried to convert DBcc to absolute jump"));
d4834 1
a4834 1
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));
d4898 1
a4898 1
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));
d5158 1
a5158 1
  if (!HAVE_LONG_BRANCH(current_architecture))
d5161 1
a5161 1
    	as_fatal(_("Tried to convert PC relative branch to absolute jump"));
d5427 1
d5806 1
d5832 1
d5867 1
d7220 1
d7338 2
a7339 2
-m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m528x  | -m5307  |\n\
-m5407  | -mcfv4  | -mcfv4e\n\
@


1.49
log
@(EXTERN_FORCE_RELOC): Handle m68k-uclinux specially, like m68k-elf.
(RELAXABLE_SYMBOL): Use EXTERN_FORCE_RELOC instead of hard-coded test for
 TARGET_OS=elf.
@
text
@d374 15
a388 15
    { m68000,  "68000", 0 },
    { m68010,  "68010", 0 },
    { m68020,  "68020", 0 },
    { m68030,  "68030", 0 },
    { m68040,  "68040", 0 },
    { m68060,  "68060", 0 },
    { cpu32,   "cpu32", 0 },
    { m68881,  "68881", 0 },
    { m68851,  "68851", 0 },
    { mcf5200, "5200",  0 },
    { mcf5206e,"5206e", 0 },
    { mcf528x, "528x",  0 },
    { mcf5307, "5307",  0 },
    { mcf5407, "5407",  0 },
    { mcfv4e,  "cfv4e", 0 },
d391 29
a419 29
    { m68020, "68k", 1 },
    { m68000, "68008", 1 },
    { m68000, "68302", 1 },
    { m68000, "68306", 1 },
    { m68000, "68307", 1 },
    { m68000, "68322", 1 },
    { m68000, "68356", 1 },
    { m68000, "68ec000", 1 },
    { m68000, "68hc000", 1 },
    { m68000, "68hc001", 1 },
    { m68020, "68ec020", 1 },
    { m68030, "68ec030", 1 },
    { m68040, "68ec040", 1 },
    { m68060, "68ec060", 1 },
    { cpu32,  "68330", 1 },
    { cpu32,  "68331", 1 },
    { cpu32,  "68332", 1 },
    { cpu32,  "68333", 1 },
    { cpu32,  "68334", 1 },
    { cpu32,  "68336", 1 },
    { cpu32,  "68340", 1 },
    { cpu32,  "68341", 1 },
    { cpu32,  "68349", 1 },
    { cpu32,  "68360", 1 },
    { m68881, "68882", 1 },
    { mcf5200, "5202", 1 },
    { mcf5200, "5204", 1 },
    { mcf5200, "5206", 1 },
    { mcf5407, "cfv4", 1 },
d1508 8
d1563 6
d1579 5
d1596 5
d2021 1
d2547 10
d2775 4
d2786 4
d2799 4
d3336 1
a3336 1
    case 'n':
d3339 1
d3341 1
a3341 1
    case 'o':
d3345 1
a3345 1
    case 'M':
d3349 1
a3349 1
    case 'N':
d3356 20
d3389 5
d3583 6
@


1.48
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d735 1
a735 1
  (!((S_IS_EXTERNAL (symbol) && strcmp (TARGET_OS, "elf") != 0)		\
@


1.47
log
@Add ColfFire v4 support
@
text
@d675 1
a675 1
     these are rumoured to be faster, and the apollo linker refuses
d2403 1
a2403 1
	      /* Figure out innner displacement stuff.  */
d4586 1
a4586 1
	   different frag, in which case refering to them is a no-no.
d5446 1
a5446 1
   not suppor tand which take arguments.  */
@


1.46
log
@Enforce	PC-relative jumps with --pcrel.
@
text
@d3 1
a3 2
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d170 1
a170 1
  CACR, TC, ITT0, ITT1, DTT0, DTT1, VBR, ROMBAR,
d174 11
d238 1
a238 1
#define cpu_of_arch(x)		((x) & (m68000up|mcf))
d241 2
a242 1
#define arch_coldfire_p(x)	(((x) & mcf) != 0)
d245 1
a245 1
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|mcf5407))
d374 15
a388 13
    { m68000, "68000", 0 },
    { m68010, "68010", 0 },
    { m68020, "68020", 0 },
    { m68030, "68030", 0 },
    { m68040, "68040", 0 },
    { m68060, "68060", 0 },
    { cpu32,  "cpu32", 0 },
    { m68881, "68881", 0 },
    { m68851, "68851", 0 },
    { mcf5200, "5200", 0 },
    { mcf5206e, "5206e", 0 },
    { mcf5307, "5307", 0},
    { mcf5407, "5407", 0},
d419 1
d1515 18
d1737 10
d1808 19
d1871 12
d1909 3
d1987 1
d1994 3
d2005 1
a2005 1
		nextword = get_num (&opP->disp, 80);
d2117 1
a2117 1
	      nextword = get_num (&opP->disp, 80);
d2213 1
a2213 1
	      baseo = get_num (&opP->disp, 80);
d2215 1
a2215 1
		outro = get_num (&opP->odisp, 80);
d2258 2
a2259 1
			  && arch_coldfire_p (current_architecture)))
d2464 1
a2464 1
	      nextword = get_num (&opP->disp, 80);
d2540 1
a2540 1
	      tmpreg = 80;
d2607 1
a2607 1
	  tmpreg = get_num (&opP->disp, 80);
d2727 1
a2727 1
	  tmpreg = get_num (&opP->disp, 80);
d2771 1
d2775 1
d2779 1
d2783 1
d2821 4
d2828 1
d2832 11
d2846 36
d3130 1
a3130 1
	  tmpreg = get_num (&opP->disp, 80);
d3139 6
d3540 4
a3543 4
  { "acr0", ITT0 },		/* Access Control Unit 0.  */
  { "acr1", ITT1 },		/* Access Control Unit 1.  */
  { "acr2", DTT0 },		/* Access Control Unit 2.  */
  { "acr3", DTT1 },		/* Access Control Unit 3.  */
d3559 25
d4141 6
d4985 5
a4989 5
   10:  Absolute 1:8	only
   20:  Absolute 0:7	only
   30:  absolute 0:15	only
   40:  Absolute 0:31	only
   50:  absolute 0:127	only
d4991 4
a4994 5
   60:  absolute -128:127	only
   70:  absolute 0:4095	only
   80:  No bignums

   */
d5057 9
d5073 1
a5073 1
	  && (ok == 80		/* no bignums.  */
d5101 1
a5101 1
      if (ok >= 10 && ok <= 70)
d7136 2
a7137 1
-m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m5307  | -m5407\n\
@


1.45
log
@gas/
	* config/tc-m68k.h (TARGET_USE_CFIPOP)
	(DWARF2_DEFAULT_RETURN_COLUMN, DWARF2_CIE_DATA_ALIGNMENT)
	(tc_regname_to_dw2regnum, tc_cfi_frame_initial_instructions):
	Define.
	* config/tc-m68k.c: Include "dw2gencfi.h".
	(tc_m68k_regname_to_dw2regnum)
	(tc_m68k_frame_initial_instructions): New functions.

gas/testsuite/
	* gas/cfi/cfi-m68k.s, gas/cfi/cfi-m68k.d: New test.
	* gas/cfi/cfi.exp (run_list_test): Run it.
@
text
@d58 1
a58 1
/* Chars that can be used to separate mant from exp in floating point nums */
d70 1
a70 1
const int md_reloc_size = 8;	/* Size of relocation record */
d78 2
a79 2
static int flag_short_refs;	/* -l option */
static int flag_long_jumps;	/* -S option */
a116 1

d134 2
a135 2
/* Its an arbitrary name:  This means I don't approve of it */
/* See flames below */
d179 1
a179 1
/* internal form of a 68020 instruction */
d183 1
a183 1
  const char *args;		/* list of opcode info */
d186 1
a186 1
  int numo;			/* Number of shorts in opcode */
d191 1
a191 1
  int nexp;			/* number of exprs in use */
d194 1
a194 1
  int nfrag;			/* Number of frags we have to produce */
d197 1
a197 1
      int fragoff;		/* Where in the current opcode the frag ends */
d204 1
a204 1
  int nrel;			/* Num of reloc strucs in use */
d225 1
a225 1
  reloc[5];			/* Five is enough??? */
d233 1
a233 1
/* Macros for determining if cpu supports a specific addressing mode */
d236 1
a236 1
static struct m68k_it the_ins;	/* the instruction being assembled */
d243 1
a243 2
/* Macros for adding things to the m68k_it struct */

a246 1

d251 2
a252 1
/* Like addword, but goes BEFORE general operands */
d433 4
a436 4
#define BRANCHBWL	0	/* branch byte, word, or long */
#define BRABSJUNC	1	/* absolute jump for LONG, unconditional */
#define BRABSJCOND	2	/* absolute jump for LONG, conditional */
#define BRANCHBW	3	/* branch byte or word */
d446 3
a448 3
#define FBRANCH		4	/* coprocessor branch */
#define DBCCLBR		5	/* DBcc relaxable with a long branch */
#define DBCCABSJ	6	/* DBcc relaxable with an absolute jump */
d461 3
a463 3
#define PCREL1632	7	/* 16-bit or 32-bit PC-relative */
#define PCINDEX		8	/* PC+displacement+index */
#define ABSTOPCREL	9	/* absolute relax down to 16-bit PC-relative */
d497 1
a497 1
  {	1, 	1,  0, 0 },		/* FBRANCH doesn't come BYTE */
d502 1
a502 1
  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE */
d507 1
a507 1
  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE */
d512 1
a512 1
  {	1, 	1,  0, 0 },		/* PCREL1632 doesn't come BYTE */
d522 1
a522 1
  {	1,	1,  0, 0 },		/* ABSTOPCREL doesn't come BYTE */
d530 1
a530 2
   generates these.
   */
d536 1
a536 2
   Integer arg to pass to the function
   */
d660 4
a663 5
  /* rewrite the PC relative instructions to absolute address ones.
   * these are rumoured to be faster, and the apollo linker refuses
   * to deal with the PC relative relocations.
   */
  if (opcode[0] == 0x60 && opcode[1] == 0xff) /* BRA -> JMP */
d665 2
d670 1
a670 1
  else if (opcode[0] == 0x61 && opcode[1] == 0xff) /* BSR -> JSR */
d672 2
d841 1
a841 1
  /* adjust_reloc_syms doesn't know about the GOT */
d1016 1
a1016 1
    instring++;			/* skip leading whitespace */
d1065 1
a1065 1
  /* found a legitimate opcode, start matching operands */
d1074 1
a1074 1
      /* Ahh - it's a motorola style psuedo op */
d1124 1
a1124 1
  /* We've got the operands.  Find an opcode that'll accept them */
d1712 1
a1712 1
		  /* Memory addressing mode used by pflushr */
d1789 1
a1789 3
		    {
		      losing++;
		    }		/* not a cache specifier.  */
d1812 1
a1812 1
		}		/* switch on type of operand */
d1816 2
a1817 2
	    }			/* for each operand */
	}			/* if immediately wrong */
d1820 1
a1820 3
	{
	  break;
	}			/* got it.  */
d1880 1
a1880 1
	}			/* Fell off the end */
d1885 1
a1885 2
  /* now assemble it */

d1978 1
a1978 1
	      /* We gotta put out some float */
d2052 1
a2052 1
	      /* Force into index mode.  Hope this works */
d2163 1
a2163 1
	      /* Index register stuff */
d2274 1
a2274 1
		  nextword |= 0x40;	/* No index reg */
d2322 1
a2322 1
	      /* Figure out innner displacement stuff */
d2412 1
a2412 1
		  /* Fall through into long */
d2425 2
a2426 1
		case SIZE_WORD:	/* Word */
d2546 1
a2546 1
	      if (subs (&opP->disp))	/* We can't relax it */
d2619 1
a2619 1
	    case 'C':		/* Fixed size LONG coproc branches */
d2624 1
a2624 1
	    case 'c':		/* Var size Coprocesssor branches */
d2641 1
a2641 1
	case 'C':		/* Ignore it */
d2644 1
a2644 1
	case 'd':		/* JF this is a kludge */
d2659 1
a2659 1
	case 'E':		/* Ignore it */
d2666 1
a2666 1
	case 'G':		/* Ignore it */
d2675 1
a2675 1
	case 'J':		/* JF foo */
d2816 1
a2816 1
	     will have the ADDR_REG bit set */
d2839 1
a2839 1
	case 'S':		/* Ignore it */
d2846 1
a2846 1
	case 'U':		/* Ignore it */
d2866 1
a2866 1
	    }			/* switch on cache token */
d2990 1
a2990 1
	case '_':	/* used only for move16 absolute 32-bit address */
d3000 1
a3000 1
	  opP->reg &= 0x0F;	/* remove upper/lower bit */
d3069 1
a3069 1
      the_ins.opcode[0] |= val & 0xFF;	/* JF FF is for M kludge */
d3124 1
a3124 1
      the_ins.numo++;		/* What a hack */
d3194 1
a3194 1
      /* more stuff goes here */
d3229 1
a3229 1
		{			/* ERROR */
d3240 1
a3240 1
    {				/* ERROR */
d3253 1
a3253 1
    c = *++str;			/* JF bitfield hack */
d3370 2
a3371 2
  /* control registers */
  { "sfc", SFC },		/* Source Function Code */
d3373 1
a3373 1
  { "dfc", DFC },		/* Destination Function Code */
d3375 2
a3376 2
  { "cacr", CACR },		/* Cache Control Register */
  { "caar", CAAR },		/* Cache Address Register */
d3378 9
a3386 9
  { "usp", USP },		/* User Stack Pointer */
  { "vbr", VBR },		/* Vector Base Register */
  { "msp", MSP },		/* Master Stack Pointer */
  { "isp", ISP },		/* Interrupt Stack Pointer */

  { "itt0", ITT0 },		/* Instruction Transparent Translation Reg 0 */
  { "itt1", ITT1 },		/* Instruction Transparent Translation Reg 1 */
  { "dtt0", DTT0 },		/* Data Transparent Translation Register 0 */
  { "dtt1", DTT1 },		/* Data Transparent Translation Register 1 */
d3389 4
a3392 4
  { "iacr0", ITT0 },		/* Instruction Access Control Register 0 */
  { "iacr1", ITT1 },		/* Instruction Access Control Register 0 */
  { "dacr0", DTT0 },		/* Data Access Control Register 0 */
  { "dacr1", DTT1 },		/* Data Access Control Register 0 */
d3397 4
a3400 4
  { "acr0", ITT0 },		/* Access Control Unit 0 */
  { "acr1", ITT1 },		/* Access Control Unit 1 */
  { "acr2", DTT0 },		/* Access Control Unit 2 */
  { "acr3", DTT1 },		/* Access Control Unit 3 */
d3402 1
a3402 1
  { "tc", TC },			/* MMU Translation Control Register */
d3405 3
a3407 3
  { "mmusr", MMUSR },		/* MMU Status Register */
  { "srp", SRP },		/* User Root Pointer */
  { "urp", URP },		/* Supervisor Root Pointer */
d3412 5
a3416 5
  { "rombar", ROMBAR },		/* ROM Base Address Register */
  { "rambar0", RAMBAR0 },	/* ROM Base Address Register */
  { "rambar1", RAMBAR1 },	/* ROM Base Address Register */
  { "mbar", MBAR },		/* Module Base Address Register */
  /* end of control registers */
d3450 1
a3450 1
  /* 68ec030 versions of same */
d3453 1
a3453 1
  /* 68ec030 access control unit, identical to 030 MMU status reg */
d3608 1
a3608 1
      /* No frag hacking involved; just put it out */
d3617 1
a3617 1
      /* put out symbol-dependent info */
d3658 1
a3658 1
  /* There's some frag hacking */
d3770 1
a3770 1
  const char *retval = 0;	/* empty string, or error msg text */
d3796 1
a3796 1
	  /* This is kludgey */
d3912 1
a3912 1
     gas expects pseudo ops to start with a dot */
d4145 1
a4145 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d4230 1
a4230 1
  /* end ibm compiler workaround */
d4241 1
a4241 1
      fixP->fx_addnumber = val;	/* Remember value for emit_reloc */
d4278 1
a4278 1
      lower_limit = - (offsetT) 0x7fffffff - 1;	/* avoid constant overflow */
d4339 1
a4339 1
  /* end ibm compiler workaround */
d4377 2
d4380 1
a4380 1
	  fragP->fr_opcode[1] = (char) 0xB9; /* JSR with ABSL LONG operand */
d4387 2
d4390 1
a4390 1
	  fragP->fr_opcode[1] = (char) 0xF9; /* JMP with ABSL LONG operand */
d4403 2
a4404 2
      /* Only Bcc 68000 instructions can come here.  */
      /* Change bcc into b!cc/jmp absl long.  */
d4406 4
a4409 2
      fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
      fragP->fr_opcode[1] = 0x6;/* branch offset = 6 */
d4416 1
a4416 1
      fragP->fr_fix += 2;	/* account for jmp instruction */
d4428 1
a4428 1
      fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit */
d4440 5
a4444 2
      /* only DBcc instructions can come here */
      /* Change dbcc into dbcc/bral.  */
d4446 1
a4446 2
      /* JF: these used to be fr_opcode[2-7], but that's wrong */
      *buffer_address++ = 0x00;	/* branch offset = 4 */
d4448 1
a4448 1
      *buffer_address++ = 0x60;	/* put in bra pc+6 */
d4453 1
a4453 1
      fragP->fr_fix += 6;	/* account for bra/jmp instructions */
d4459 5
a4463 2
      /* only DBcc instructions can come here */
      /* Change dbcc into dbcc/jmp.  */
d4465 1
a4465 2
      /* JF: these used to be fr_opcode[2-7], but that's wrong */
      *buffer_address++ = 0x00;	/* branch offset = 4 */
d4467 1
a4467 1
      *buffer_address++ = 0x60;	/* put in bra pc+6 */
d4469 1
a4469 1
      *buffer_address++ = 0x4e;     /* Put in jmp long (0x4ef9).  */
d4472 1
a4472 1
      fragP->fr_fix += 6;	/* account for bra/jmp instructions */
d4526 2
d4529 1
a4529 1
	 ABSTOPCREL is really trying to shorten an ABSOLUTE address anyway */
d4699 1
a4699 1
   you there. -KWK */
d4712 1
a4712 1
  /* this is easy */
d4714 1
a4714 1
  /* now the fun stuff */
d4716 2
a4717 2
  the_bytes[5] = (ri->r_symbolnum >> 8) & 0x0ff;
  the_bytes[6] = ri->r_symbolnum & 0x0ff;
d4722 1
a4722 1
#endif /* comment */
d4789 2
d4830 1
a4830 1
      /* Do the same thing the VAX asm does */
d4890 3
a4892 3
      if (offs (exp) <= 0	/* flonum */
	  && (ok == 80		/* no bignums */
	      || (ok > 10	/* small-int ranges including 0 ok */
d4898 1
a4898 1
	  /* HACK! Turn it into a long */
d4901 1
a4901 1
	  gen_to_words (words, 2, 8L);	/* These numbers are magic! */
d5749 1
a5749 1
    /* <HS> is an alias for <CC> */
d5752 1
a5752 1
    /* <LO> is an alias for <CS> */
d5761 1
a5761 1
    /* issue a warning for conditions we can not swap */
d6055 1
a6055 1
       if d0 <ne> #CONST*20   then */
a6449 1

d6454 1
a6454 1
  /* move init,var */
d6473 1
a6473 1
  /* cmp end,var */
d6489 1
a6489 1
  /* bcc bottom */
d6633 1
a6633 1
       while d0 <ne> #CONST*20   do */
d6771 1
a6771 1
				   rather than 16 bit one */
d6788 1
a6788 1
      /* intentional fall-through */
d6864 1
a6864 1
      break;			/* -pic, Position Independent Code */
d6980 2
a6981 2
/* Warning, this routine probably doesn't work anymore */

d7150 1
a7150 1
  /* Set file-specific flags if this is a cpu32 processor */
@


1.44
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d3 1
a3 1
   2000, 2001, 2002
d28 1
d7150 31
@


1.43
log
@	* config/tc-m68k.c (tc_gen_reloc <section>): Add ATTRIBUTE_UNUSED.
	(md_show_usage): Fix signed/unsigned warning.
@
text
@a556 6
#ifdef OBJ_ELF
  /* Dwarf2 support for Gcc.  */
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
#endif

@


1.42
log
@Handle situation where architecture has not yet been selected.
@
text
@d885 1
a885 1
     asection *section;
d6923 2
a6924 1
  int default_arch, i;
@


1.41
log
@gas reloc rewrite.
@
text
@d3953 5
@


1.40
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@a846 4
  /* Prevent all adjustments to global symbols.  */
  if (! relaxable_symbol (fixP->fx_addsy))
    return 0;

@


1.39
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d559 1
a559 1
  {"file", dwarf2_directive_file, 0},
@


1.39.2.1
log
@Merge from mainline.
@
text
@a850 4
  /* Don't adjust symbols in merge sections.  */
  if ((S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0)
    return 0;

@


1.38
log
@	* config/tc-m68k.c: Fix formatting.
@
text
@d58 1
a58 1
CONST char EXP_CHARS[] = "eE";
d63 1
a63 1
CONST char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d614 1
a614 1
CONST pseudo_typeS mote_pseudo_table[] =
d4733 1
a4733 1
  static CONST unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
d4757 2
a4758 2
CONST int md_short_jump_size = 4;
CONST int md_long_jump_size = 6;
d6732 1
a6732 1
CONST char *md_shortopts = "lSA:m:kQ:V";
d6734 1
a6734 1
CONST char *md_shortopts = "lSA:m:k";
@


1.37
log
@bfd:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* elf32-m68k.c (elf32_m68k_print_private_bfd_data): Recognize
EF_M68000.


bintuls:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* readelf.c (get_machine_flags): Recognize EF_M68000.


gas:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* config/tc-m68k.c (md_show_usage): No longer display a
hard-coded "68020" for the default CPU, instead display the
canonical name of the true, configured default CPU.
(m68k_elf_final_processing): Mark objects for sub-68020
CPUs with the new EF_M68000 flag.


include/elf:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* m68k.h (EF_M68000): Define.
@
text
@d3 1
a3 1
   2000, 2001
d261 3
a263 3
    the_ins.opcode[z]=the_ins.opcode[z-1];
  for (z = 0;z < the_ins.nrel; z++)
    the_ins.reloc[z].n+=2;
d266 1
a266 1
  the_ins.opcode[opcode->m_codenum]=w;
d309 4
a312 4
  the_ins.fragb[the_ins.nfrag].fragoff=the_ins.numo;
  the_ins.fragb[the_ins.nfrag].fadd=add;
  the_ins.fragb[the_ins.nfrag].foff=off;
  the_ins.fragb[the_ins.nfrag++].fragty=type;
d1227 1
a1227 1
                  break;
d1237 1
a1237 1
                  break;
d1249 1
a1249 1
                  break;
d1262 1
a1262 1
                        losing++;
d1267 1
a1267 1
                  break;
d1279 1
a1279 1
                        losing++;
d1285 1
a1285 1
                  break;
d1298 1
a1298 1
                        losing++;
d2278 4
a2281 4
 			  nextword += baseo & 0xff;
 			  addword (nextword);
 			  add_frag (adds (&opP->disp), offs (&opP->disp),
 				    TAB (PCINDEX, SZ_UNDEF));
d2284 1
a2284 1
 			}
d5325 1
a5325 1
    listing &=~ LISTING_SYMBOLS;
d5710 8
a5717 8
      if (    (    s == input_line_pointer
                || *(s-1) == ' '
                || *(s-1) == '\t')
           && (    (    strncasecmp (s, "AND", 3) == 0
                     && (s[3] == '.' || ! is_part_of_name (s[3])))
                || (    strncasecmp (s, "OR", 2) == 0
                     && (s[2] == '.' || ! is_part_of_name (s[2])))))
	      break;
d5870 3
a5872 1
	} else {
d6630 6
a6635 6
  while ( ! (    is_end_of_line[(unsigned char) *s]
              || (     flag_mri
                   && *s == '*'
                   && (    s == input_line_pointer
                        || *(s-1) == ' '
                        || *(s-1) == '\t'))))
d6783 1
a6783 1
 	arg++;
d6924 1
a6924 1
  /* Get the canonical name for the default target CPU. */
d7142 2
a7143 1
void m68k_elf_final_processing()
d7145 6
a7150 6
   /* Set file-specific flags if this is a cpu32 processor */
   if (cpu_of_arch (current_architecture) & cpu32)
     elf_elfheader (stdoutput)->e_flags |= EF_CPU32;
   else if ((cpu_of_arch (current_architecture) & m68000up)
	    && !(cpu_of_arch (current_architecture) & m68020up))
     elf_elfheader (stdoutput)->e_flags |= EF_M68000;
@


1.36
log
@	* config/tc-m68k.h (md_prepare_relax_scan): Rewrite.
	* config/tc-m68k.c (md_relax_table): Add md_prepare_relax_scan comment.
@
text
@d6919 23
d6948 1
a6948 1
			specify variant of 680X0 architecture [default 68020]\n\
d6951 2
a6952 1
			[default yes for 68020, 68030, and cpu32]\n"));
d7145 3
@


1.36.2.1
log
@bfd:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* elf32-m68k.c (elf32_m68k_print_private_bfd_data): Recognize
EF_M68000.

bintuls:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* readelf.c (get_machine_flags): Recognize EF_M68000.

gas:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* config/tc-m68k.c (md_show_usage): No longer display a
hard-coded "68020" for the default CPU, instead display the
canonical name of the true, configured default CPU.
(m68k_elf_final_processing): Mark objects for sub-68020
CPUs with the new EF_M68000 flag.

include/elf:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* m68k.h (EF_M68000): Define.
@
text
@a6918 23
  const char *default_cpu = TARGET_CPU;
  int default_arch, i;

  /* Get the canonical name for the default target CPU. */
  if (*default_cpu == 'm')
    default_cpu++;
  for (i = 0; i < n_archs; i++)
    {
      if (strcasecmp (default_cpu, archs[i].name) == 0)
	{
	  default_arch = archs[i].arch;
	  for (i = 0; i < n_archs; i++)
	    {
	      if (archs[i].arch == default_arch
		  && !archs[i].alias)
		{
		  default_cpu = archs[i].name;
		  break;
		}
	    }
	}
    }

d6925 1
a6925 1
			specify variant of 680X0 architecture [default %s]\n\
d6928 1
a6928 2
			[default yes for 68020, 68030, and cpu32]\n"),
          default_cpu);
a7120 3
   else if ((cpu_of_arch (current_architecture) & m68000up)
	    && !(cpu_of_arch (current_architecture) & m68020up))
     elf_elfheader (stdoutput)->e_flags |= EF_M68000;
@


1.35
log
@Test for a NULL frag link.
@
text
@d474 2
a475 1
   */
@


1.34
log
@	* config/tc-m68k.c (md_apply_fix3): Change val back to a signed type.
@
text
@d4677 1
a4677 1
	      for (l = fragP->fr_next; l != sym_frag; l = l->fr_next)
@


1.33
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d4227 1
a4227 1
     valueT * valP;
d4230 1
a4230 1
  valueT val = * valP;
@


1.32
log
@	* config/tc-m68k.c (m68k_ip): Correct absolute jmp opcodes.
@
text
@a350 1
static void md_apply_fix_2 PARAMS ((fixS *, offsetT));
d3781 4
a3784 5
  register const struct m68k_opcode *ins;
  register struct m68k_incant *hack, *slak;
  register const char *retval = 0;	/* empty string, or error msg text */
  register int i;
  register char c;
d4224 2
a4225 2
static void
md_apply_fix_2 (fixP, val)
d4227 2
a4228 1
     offsetT val;
d4230 1
d4242 3
d4267 2
a4268 2
      /* The cast to offsetT below are necessary to make code correct for
	 machines where ints are smaller than offsetT */
a4326 18

#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
{
  md_apply_fix_2 (fixP, (addressT) *valp);
  return 1;
}
#else
void md_apply_fix (fixP, val)
     fixS *fixP;
     long val;
{
  md_apply_fix_2 (fixP, (addressT) val);
}
#endif
@


1.31
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2576 1
a2576 1
		    the_ins.opcode[0] = 0x4EF1;
d2578 1
a2578 1
		    the_ins.opcode[0] = 0x4EB1;
d2583 1
a2583 1
		      addword (0x4EF1);
@


1.30
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@a22 1
#include <ctype.h>
d24 1
a650 2
static char mklower_table[256];
#define mklower(c) (mklower_table[(unsigned char) (c)])
d3312 1
a3312 1
    buf[i] = islower (regname[i]) ? toupper (regname[i]) : regname[i];
a3880 3
  for (i = 0; i < (int) sizeof (mklower_table); i++)
    mklower_table[i] = (isupper (c = (char) i)) ? tolower (c) : c;

d5368 1
a5368 1
  while (isalnum ((unsigned char) *input_line_pointer)
d5580 1
a5580 4
    {
      if (isupper ((unsigned char) *s))
	*s = tolower ((unsigned char) *s);
    }
d5662 2
a5663 4
  if (isupper (c1))
    c1 = tolower (c1);
  if (isupper (c2))
    c2 = tolower (c2);
d5905 1
a5905 1
	*s++ = tolower (qual);
d5923 1
a5923 1
    *s++ = tolower (extent);
d6173 1
a6173 1
  q[0] = tolower (qual);
d6246 1
a6246 1
  ex[0] = tolower (extent);
d6285 1
a6285 1
  ex[0] = tolower (extent);
d6469 1
a6469 1
    *s++ = tolower (qual);
d6487 1
a6487 1
    *s++ = tolower (qual);
d6498 1
a6498 1
  ex[0] = tolower (extent);
d6514 1
a6514 1
    *s++ = tolower (qual);
@


1.29
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d260 1
a260 1
  for(z=the_ins.numo;z>opcode->m_codenum;--z)
d262 1
a262 1
  for(z=0;z<the_ins.nrel;z++)
d5915 1
a5915 1
	*s++ = tolower(qual);
d5933 1
a5933 1
    *s++ = tolower(extent);
d6183 1
a6183 1
  q[0] = tolower(qual);
d6256 1
a6256 1
  ex[0] = tolower(extent);
d6295 1
a6295 1
  ex[0] = tolower(extent);
d6479 1
a6479 1
    *s++ = tolower(qual);
d6497 1
a6497 1
    *s++ = tolower(qual);
d6508 1
a6508 1
  ex[0] = tolower(extent);
d6524 1
a6524 1
    *s++ = tolower(qual);
@


1.28
log
@	* config/tc-m68k.c (md_pseudo_table) [OBJ_ELF]: Add .file and
	.loc.
	(md_assemble) [OBJ_ELF]: Call dwarf2_emit_insn before emitting
	insn.
	* config/tc-m68k.h (DWARF2_LINE_MIN_INSN_LENGTH): Define.
@
text
@d435 4
a438 4
#define BRANCHBWL	1	/* branch byte, word, or long */
#define BRABSJUNC	2	/* absolute jump for LONG, unconditional */
#define BRABSJCOND	3	/* absolute jump for LONG, conditional */
#define BRANCHBW	4	/* branch byte or word */
d448 3
a450 3
#define FBRANCH		5	/* coprocessor branch */
#define DBCCLBR		6	/* DBcc relaxable with a long branch */
#define DBCCABSJ	7	/* DBcc relaxable with an absolute jump */
d463 3
a465 3
#define PCREL1632	8	/* 16-bit or 32-bit PC-relative */
#define PCINDEX		9	/* PC+displacement+index */
#define ABSTOPCREL	10	/* absolute relax down to 16-bit PC-relative */
d478 49
a526 54
  {1, 1, 0, 0},			/* First entries aren't used */
  {1, 1, 0, 0},			/* For no good reason except */
  {1, 1, 0, 0},			/* that the VAX doesn't either */
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRANCHBWL, SHORT)},
  {(32767), (-32768), 2, TAB (BRANCHBWL, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRABSJUNC, SHORT)},
  {(32767), (-32768), 2, TAB (BRABSJUNC, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRABSJCOND, SHORT)},
  {(32767), (-32768), 2, TAB (BRABSJCOND, LONG)},
  {0, 0, 6, 0},
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRANCHBW, SHORT)},
  {0, 0, 2, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* FBRANCH doesn't come BYTE */
  {(32767), (-32768), 2, TAB (FBRANCH, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* DBCC doesn't come BYTE */
  {(32767), (-32768), 2, TAB (DBCCLBR, LONG)},
  {0, 0, 10, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* DBCC doesn't come BYTE */
  {(32767), (-32768), 2, TAB (DBCCABSJ, LONG)},
  {0, 0, 10, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* PCREL1632 doesn't come BYTE */
  {32767, -32768, 2, TAB (PCREL1632, LONG)},
  {0, 0, 6, 0},
  {1, 1, 0, 0},

  {125, -130, 0, TAB (PCINDEX, SHORT)},
  {32765, -32770, 2, TAB (PCINDEX, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* ABSTOPCREL doesn't come BYTE */
  {(32767), (-32768), 2, TAB (ABSTOPCREL, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},
a4372 4
#ifdef BFD_ASSEMBLER
  disp += symbol_get_frag (fragP->fr_symbol)->fr_address;
#endif

a4587 4
  int old_fix;

  old_fix = fragP->fr_fix;

d4684 5
a4688 7
	 case we force word mode.  At this point S_GET_VALUE should
	 return the offset of the symbol within its frag.  If the
	 symbol is at the start of a frag, and it is the next frag
	 with any data in it (usually this is just the next frag, but
	 assembler listings may introduce empty frags), we must use
	 word mode.  */
      if (fragP->fr_symbol && S_GET_VALUE (fragP->fr_symbol) == 0)
d4690 1
a4690 2
	  fragS *stop;
	  fragS *l;
d4692 4
a4695 1
	  stop = symbol_get_frag (fragP->fr_symbol);
d4697 5
a4701 15
	  for (l = fragP->fr_next; l != stop; l = l->fr_next)
	    {
	      /* Catch empty alignment frags whoes fr_offset field
		 is an alignment requirement of 2 bytes.  The check
		 below will misinterpret this as evidence that real
		 code exists between the symbol and the instruction
		 and so will not convert the short jump into a word
		 jump.  */
	      if (l->fr_fix == 0
		  && l->fr_var == 1
		  && (l->fr_type == rs_align || l->fr_type == rs_align_code))
		continue;
    
	      if (l->fr_fix + l->fr_var != 0)
		break;
a4702 2
	  if (l == stop)
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
d4708 1
a4708 2
  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
  return fragP->fr_var + fragP->fr_fix - old_fix;
@


1.27
log
@Catch and ignore empty, ineffectual alignment frags when deciding if a
branch can be short.
@
text
@d27 1
d562 6
d3621 5
@


1.26
log
@	* config/tc-hppa.c (CHECK_FIELD_WHERE): Define.
	(md_apply_fix): Use it here.  Replace printf with equivalent
	as_bad_where.
	(tc_gen_reloc): Use as_bad_where instead of as_bad.
	(md_apply_fix): Here too.
	* config/tc-i386.c (tc_gen_reloc): Use as_bad_where instead of as_bad.
	* config/tc-m68k.c (tc_gen_reloc): Likewise.
	(md_convert_frag_1): Likewise.
@
text
@d4697 1
a4698 3
	    if (l->fr_fix + l->fr_var != 0)
	      break;
	  if (l == stop)
d4700 13
a4712 1
	      fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
d4714 2
@


1.25
log
@Fix m68k/mri mode problems.
@
text
@d903 3
a905 2
	as_bad (_("Unable to produce reloc against symbol '%s'"),
		S_GET_NAME (fixp->fx_addsy));
d4378 2
a4379 1
	as_bad (_("short branch with zero offset: use :w"));
@


1.24
log
@correct some 68k/ColdFire problems
@
text
@d5731 11
a5741 5
      if ((strncasecmp (s, "AND", 3) == 0
	   && (s[3] == '.' || ! is_part_of_name (s[3])))
	  || (strncasecmp (s, "OR", 2) == 0
	      && (s[2] == '.' || ! is_part_of_name (s[2]))))
	break;
d5768 2
d5771 2
d5780 9
d5803 2
d5806 2
d5874 14
a5887 1
	  cc = swap_mri_condition (cc);
d5894 2
d5915 1
a5915 1
	*s++ = qual;
d5933 1
a5933 1
    *s++ = extent;
d6068 11
a6078 2
  while (! is_end_of_line[(unsigned char) *s]
	 && (! flag_mri || *s != '*'))
d6183 1
a6183 1
  q[0] = qual;
d6256 1
a6256 1
  ex[0] = extent;
d6295 1
a6295 1
  ex[0] = extent;
d6479 1
a6479 1
    *s++ = qual;
d6497 1
a6497 1
    *s++ = qual;
d6508 1
a6508 1
  ex[0] = extent;
d6524 1
a6524 1
    *s++ = qual;
d6647 11
a6657 2
  while (! is_end_of_line[(unsigned char) *s]
	 && (! flag_mri || *s != '*'))
@


1.23
log
@	* config/tc-m68k.c (md_assemble): Ensure variable part of frag is
	allocated in the same chunk as the fixed part.
@
text
@d6890 3
a6892 3
-m68000 | -m68008 | -m68010 | -m68020 | -m68030 | -m68040 | -m68060\n\
 | -m68302 | -m68331 | -m68332 | -m68333 | -m68340 | -m68360\n\
 | -mcpu32 | -m5200\n\
@


1.22
log
@	* config/tc-m68k.c (relaxable_symbol): Only treat external symbols
	as relaxable if embedded system, make weak syms non-relaxable.
	Move definition..
	(tc_m68k_fix_adjustable): ..so it can be used here.
	(md_apply_fix_2): Sign extend without conditional.
@
text
@d3667 15
@


1.21
log
@	* config/tc-m68k.c: Instead of replacing -1 by 64 in assignment to
	fx_pcrel_adjust explicitly sign extend when reading it.
@
text
@d717 13
d848 1
a848 2
  if (S_IS_EXTERNAL (fixP->fx_addsy)
      || S_IS_WEAK (fixP->fx_addsy))
d881 2
a999 21
/* Return zero if the reference to SYMBOL from within the same segment may
   be relaxed.  */
#ifdef OBJ_ELF

/* On an ELF system, we can't relax an externally visible symbol,
   because it may be overridden by a shared library.  However, if
   TARGET_OS is "elf", then we presume that we are assembling for an
   embedded system, in which case we don't have to worry about shared
   libraries, and we can relax anything.  */

#define relaxable_symbol(symbol)		\
  (strcmp (TARGET_OS, "elf") == 0		\
   || (! S_IS_EXTERNAL (symbol)			\
       && ! S_IS_WEAK (symbol)))

#else

#define relaxable_symbol(symbol) 1

#endif

d4222 1
a4222 4
  if (val & 0x80000000)
    val |= ~(addressT)0x7fffffff;
  else
    val &= 0x7fffffff;
@


1.20
log
@More fallout from 2001-03-30 changes.
	* config/tc-m68k.c (md_estimate_size_before_relax): Set fr_var
	from md_relax_table, and combine some switch cases.
@
text
@d971 3
a973 2
		     + (fixp->fx_pcrel_adjust == 64
			? -1 : fixp->fx_pcrel_adjust)
d2550 1
a2550 5
	      /* The pc_fix argument winds up in fx_pcrel_adjust,
                 which is a char, and may therefore be unsigned.  We
                 want to pass -1, but we pass 64 instead, and convert
                 back in md_pcrel_from.  */
	      add_fix ('B', &opP->disp, 1, 64);
d7041 3
a7043 3
  /* Because fx_pcrel_adjust is a char, and may be unsigned, we store
     -1 as 64.  */
  adjust = fixP->fx_pcrel_adjust;
@


1.19
log
@Fix copyright notices
@
text
@a4589 21
      {
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), BYTE);
	  }
	else if (flag_short_refs)
	  {
	    /* Symbol is undefined and we want short ref.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	    fragP->fr_var += 2;
	  }
	else
	  {
	    /* Symbol is still undefined.  Make it LONG.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
	    fragP->fr_var += 4;
	  }
	break;
      }

a4600 1
	    fragP->fr_var += 2;
a4605 1
	    fragP->fr_var += 6;
a4620 1
	    fragP->fr_var += 2;
a4625 16
      {
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
	  {
	    fragP->fr_subtype = TAB (FBRANCH, SHORT);
	    fragP->fr_var += 2;
	  }
	else
	  {
	    fragP->fr_subtype = TAB (FBRANCH, LONG);
	    fragP->fr_var += 4;
	  }
	break;
      }

d4628 1
a4634 1
	    fragP->fr_var += 2;
a4638 18
	    fragP->fr_var += 10;
	  }
	break;
      }

    case TAB (PCREL1632, SZ_UNDEF):
      {
	if (((S_GET_SEGMENT (fragP->fr_symbol)) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
	  {
	    fragP->fr_subtype = TAB (PCREL1632, SHORT);
	    fragP->fr_var += 2;
	  }
	else
	  {
	    fragP->fr_subtype = TAB (PCREL1632, LONG);
	    fragP->fr_var += 6;
a4651 1
	  fragP->fr_var += 4;
a4660 1
	    fragP->fr_var += 2;
a4664 1
	    fragP->fr_var += 4;
a4698 1
	      fragP->fr_var += 2;
d4705 1
@


1.18
log
@Rest of the changes for Coldfire V4
@
text
@d2 2
a3 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.17
log
@Do not abort if tcbit is still set.  Issue an error message instead.
Fix compile time warnings
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d232 1
a232 1
#define HAVE_LONG_BRANCH(x)	((x) & (m68020|m68030|m68040|m68060|cpu32))
d354 6
a359 5
struct m68k_cpu {
  unsigned long arch;
  const char *name;
  int alias;
};
d361 46
a406 44
static const struct m68k_cpu archs[] = {
  { m68000, "68000", 0 },
  { m68010, "68010", 0 },
  { m68020, "68020", 0 },
  { m68030, "68030", 0 },
  { m68040, "68040", 0 },
  { m68060, "68060", 0 },
  { cpu32,  "cpu32", 0 },
  { m68881, "68881", 0 },
  { m68851, "68851", 0 },
  { mcf5200, "5200", 0 },
  { mcf5206e, "5206e", 0 },
  { mcf5307, "5307", 0},
  /* Aliases (effectively, so far as gas is concerned) for the above
     cpus.  */
  { m68020, "68k", 1 },
  { m68000, "68008", 1 },
  { m68000, "68302", 1 },
  { m68000, "68306", 1 },
  { m68000, "68307", 1 },
  { m68000, "68322", 1 },
  { m68000, "68356", 1 },
  { m68000, "68ec000", 1 },
  { m68000, "68hc000", 1 },
  { m68000, "68hc001", 1 },
  { m68020, "68ec020", 1 },
  { m68030, "68ec030", 1 },
  { m68040, "68ec040", 1 },
  { m68060, "68ec060", 1 },
  { cpu32,  "68330", 1 },
  { cpu32,  "68331", 1 },
  { cpu32,  "68332", 1 },
  { cpu32,  "68333", 1 },
  { cpu32,  "68334", 1 },
  { cpu32,  "68336", 1 },
  { cpu32,  "68340", 1 },
  { cpu32,  "68341", 1 },
  { cpu32,  "68349", 1 },
  { cpu32,  "68360", 1 },
  { m68881, "68882", 1 },
  { mcf5200, "5202", 1 },
  { mcf5200, "5204", 1 },
  { mcf5200, "5206", 1 },
};
d3971 1
@


1.17.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.17.2.2
log
@Merge from mainline.
@
text
@d233 1
a233 1
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|mcf5407))
d355 5
a359 6
struct m68k_cpu
  {
    unsigned long arch;
    const char *name;
    int alias;
  };
d361 44
a404 46
static const struct m68k_cpu archs[] =
  {
    { m68000, "68000", 0 },
    { m68010, "68010", 0 },
    { m68020, "68020", 0 },
    { m68030, "68030", 0 },
    { m68040, "68040", 0 },
    { m68060, "68060", 0 },
    { cpu32,  "cpu32", 0 },
    { m68881, "68881", 0 },
    { m68851, "68851", 0 },
    { mcf5200, "5200", 0 },
    { mcf5206e, "5206e", 0 },
    { mcf5307, "5307", 0},
    { mcf5407, "5407", 0},
    /* Aliases (effectively, so far as gas is concerned) for the above
       cpus.  */
    { m68020, "68k", 1 },
    { m68000, "68008", 1 },
    { m68000, "68302", 1 },
    { m68000, "68306", 1 },
    { m68000, "68307", 1 },
    { m68000, "68322", 1 },
    { m68000, "68356", 1 },
    { m68000, "68ec000", 1 },
    { m68000, "68hc000", 1 },
    { m68000, "68hc001", 1 },
    { m68020, "68ec020", 1 },
    { m68030, "68ec030", 1 },
    { m68040, "68ec040", 1 },
    { m68060, "68ec060", 1 },
    { cpu32,  "68330", 1 },
    { cpu32,  "68331", 1 },
    { cpu32,  "68332", 1 },
    { cpu32,  "68333", 1 },
    { cpu32,  "68334", 1 },
    { cpu32,  "68336", 1 },
    { cpu32,  "68340", 1 },
    { cpu32,  "68341", 1 },
    { cpu32,  "68349", 1 },
    { cpu32,  "68360", 1 },
    { m68881, "68882", 1 },
    { mcf5200, "5202", 1 },
    { mcf5200, "5204", 1 },
    { mcf5200, "5206", 1 },
  };
a713 13
/* Return zero if the reference to SYMBOL from within the same segment may
   be relaxed.  */

/* On an ELF system, we can't relax an externally visible symbol,
   because it may be overridden by a shared library.  However, if
   TARGET_OS is "elf", then we presume that we are assembling for an
   embedded system, in which case we don't have to worry about shared
   libraries, and we can relax any external sym.  */

#define relaxable_symbol(symbol) \
  (!((S_IS_EXTERNAL (symbol) && strcmp (TARGET_OS, "elf") != 0)		\
     || S_IS_WEAK (symbol)))

d832 2
a833 1
  if (! relaxable_symbol (fixP->fx_addsy))
a865 2
#define relaxable_symbol(symbol) 1

d968 2
a969 3
		     /* Explicit sign extension in case char is
			unsigned.  */
		     + ((fixp->fx_pcrel_adjust & 0xff) ^ 0x80) - 0x80
d982 21
d2546 5
a2550 1
	      add_fix ('B', &opP->disp, 1, -1);
a3673 15
  {
    /* Calculate the max frag size.  */
    int wid;

    wid = 2 * the_ins.fragb[0].fragoff;
    for (n = 1; n < the_ins.nfrag; n++)
      wid += 2 * (the_ins.numo - the_ins.fragb[n - 1].fragoff);
    /* frag_var part.  */
    wid += 10;
    /* Make sure the whole insn fits in one chunk, in particular that
       the var part is attached, as we access one byte before the
       variable frag for byte branches.  */
    frag_grow (wid);
  }

a3968 1
    case mcf5407:
d4228 4
a4231 1
  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;
d4586 21
d4618 1
d4624 1
d4640 1
d4646 16
a4663 1
    case TAB (PCREL1632, SZ_UNDEF):
d4670 1
d4675 18
d4706 1
d4716 1
d4721 1
d4756 1
a4762 1
  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
d6945 3
a6947 3
-m68000 | -m68008 | -m68010 | -m68020 | -m68030 | -m68040 | -m68060 |\n\
-m68302 | -m68331 | -m68332 | -m68333 | -m68340 | -m68360 | -mcpu32 |\n\
-m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m5307  | -m5407\n\
d7101 3
a7103 3
  /* Because fx_pcrel_adjust is a char, and may be unsigned, we explicitly
     sign extend the value here.  */
  adjust = ((fixP->fx_pcrel_adjust & 0xff) ^ 0x80) - 0x80;
@


1.17.2.3
log
@	* config/tc-m68k.c (md_pseudo_table) [OBJ_ELF]: Add .file and
	.loc.
	(md_assemble) [OBJ_ELF]: Call dwarf2_emit_insn before emitting
	insn.
	* config/tc-m68k.h (DWARF2_LINE_MIN_INSN_LENGTH): Define.
@
text
@a560 6
#ifdef OBJ_ELF
  /* Dwarf2 support for Gcc.  */
  {"file", dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
#endif

a3612 5

#ifdef OBJ_ELF
  /* Tie dwarf2 debug info to the address at the start of the insn.  */
  dwarf2_emit_insn (0);
#endif
@


1.17.2.4
log
@	* config/tc-m68k.c: Include "dwarf2dbg.h".
@
text
@a26 1
#include "dwarf2dbg.h"
@


1.17.2.5
log
@	* config/tc-m68k.c (m68k_ip): Correct absolute jmp opcodes.
@
text
@d2582 1
a2582 1
		    the_ins.opcode[0] = 0x4EF9;
d2584 1
a2584 1
		    the_ins.opcode[0] = 0x4EB9;
d2589 1
a2589 1
		      addword (0x4EF9);
@


1.16
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d877 5
d883 6
a888 1
    abort ();
a4576 1
  register char *buffer_address = fragP->fr_fix + fragP->fr_literal;
d4664 2
a4665 2
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol)
@


1.15
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@a7050 1
/* ARGSUSED */
a7101 1
/*ARGSUSED*/
@


1.14
log
@Fix the previous misapplied patch.
@
text
@d646 1
a646 1
#define mklower(c) (mklower_table[(unsigned char)(c)])
d2444 1
a2444 1
	      /* abort(); */
d6768 1
a6768 1
size_t md_longopts_size = sizeof(md_longopts);
d6932 1
a6932 1
  fprintf(stream, _("\
d6942 1
a6942 1
  fprintf(stream, _("\
@


1.13
log
@RELAX_RELOC_*: New definitions for both BFD_ASSEMBLER and !BFD_ASSEMBLER.
@
text
@d4386 1
a4386 1
		   0, RELAX_RELOC_PC32);
@


1.12
log
@2000-09-25  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-cris.c: Fix formatting.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.h: Likewise.
@
text
@d4362 1
a4362 1
		      fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d4371 1
a4371 1
	       1, BFD_RELOC_16_PCREL);
d4377 1
a4377 1
	       1, BFD_RELOC_32_PCREL);
d4386 1
a4386 1
		   0, BFD_RELOC_32);
d4394 1
a4394 1
		   0, BFD_RELOC_32);
d4418 1
a4418 1
	       fragP->fr_offset, 0, BFD_RELOC_32);
d4424 1
a4424 1
	       1, BFD_RELOC_16_PCREL);
d4430 1
a4430 1
	       1, BFD_RELOC_32_PCREL);
d4436 1
a4436 1
	       1, BFD_RELOC_16_PCREL);
d4453 1
a4453 1
	       BFD_RELOC_32_PCREL);
d4470 1
a4470 1
	       BFD_RELOC_32);
d4477 1
a4477 1
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
d4487 1
a4487 1
		      fragP->fr_offset, 1, BFD_RELOC_32_PCREL);
d4495 1
a4495 1
		      fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d4503 1
a4503 1
		      fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
d4512 1
a4512 1
		      fragP->fr_offset, 1, BFD_RELOC_32_PCREL);
d4518 1
a4518 1
	       1, BFD_RELOC_16_PCREL);
d4529 1
a4529 1
	       0, BFD_RELOC_32);
@


1.11
log
@Redesign and clean up the relaxation mechanism.
@
text
@d2548 1
a2548 1
		as_warn (_("Can't use long branches on 68000/68010/5200"));	
d4686 1
a4686 1
      
a7137 1
/* end of tc-m68k.c */
@


1.10
log
@2000-09-11  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-i370.c: Fix formatting.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
@
text
@a135 29
#define TAB(x,y)	(((x)<<2)+(y))
#define TABTYPE(xy)     ((xy) >> 2)
#define BYTE		0
#define SHORT		1
#define LONG		2
#define SZ_UNDEF	3
#undef BRANCH
/* Case `g' except when BCC68000 is applicable.  */
#define ABRANCH		1
/* Coprocessor branches.  */
#define FBRANCH		2
/* Mode 7.2 -- program counter indirect with (16-bit) displacement,
   supported on all cpus.  Widens to 32-bit absolute.  */
#define PCREL		3
/* For inserting an extra jmp instruction with long offset on 68000,
   for expanding conditional branches.  (Not bsr or bra.)  Since the
   68000 doesn't support 32-bit displacements for conditional
   branches, we fake it by reversing the condition and branching
   around a jmp with an absolute long operand.  */
#define BCC68000        4
/* For the DBcc "instructions".  If the displacement requires 32 bits,
   the branch-around-a-jump game is played here too.  */
#define DBCC            5
/* Not currently used?  */
#define PCLEA		6
/* Mode AINDX (apc-relative) using PC, with variable target, might fit
   in 16 or 8 bits.  */
#define PCINDEX		7

d407 2
a408 2
/* BCC68000 is for patching in an extra jmp instruction for long offsets
   on the 68000.  The 68000 doesn't support long branches with branchs */
d410 51
a460 2
/* This table desribes how you change sizes for the various types of variable
   size expressions.  This version only supports two kinds.  */
d478 2
a479 2
  {(127), (-128), 0, TAB (ABRANCH, SHORT)},
  {(32767), (-32768), 2, TAB (ABRANCH, LONG)},
d483 2
a484 2
  {1, 1, 0, 0},			/* FBRANCH doesn't come BYTE */
  {(32767), (-32768), 2, TAB (FBRANCH, LONG)},
d488 12
a499 2
  {1, 1, 0, 0},			/* PCREL doesn't come BYTE */
  {(32767), (-32768), 2, TAB (PCREL, LONG)},
d503 3
a505 3
  {(127), (-128), 0, TAB (BCC68000, SHORT)},
  {(32767), (-32768), 2, TAB (BCC68000, LONG)},
  {0, 0, 6, 0},			/* jmp long space */
d509 2
a510 2
  {(32767), (-32768), 2, TAB (DBCC, LONG)},
  {0, 0, 10, 0},		/* bra/jmp long space */
d513 2
a514 2
  {1, 1, 0, 0},			/* PCLEA doesn't come BYTE */
  {32767, -32768, 2, TAB (PCLEA, LONG)},
a517 1
  /* For, e.g., jmp pcrel indexed.  */
d522 5
d2101 1
a2101 1
					TAB (PCLEA, SZ_UNDEF));
a2408 2
		      && S_GET_SEGMENT (adds (&opP->disp)) == now_seg
		      && relaxable_symbol (adds (&opP->disp))
d2415 1
a2415 1
				TAB (PCREL, SZ_UNDEF));
d2547 3
a2549 3
	      if (!HAVE_LONG_BRANCH(current_architecture))
		as_warn (_("Can't use long branches on 68000/68010/5200"));
	      the_ins.opcode[the_ins.numo - 1] |= 0xff;
d2564 21
d2586 4
a2589 10
	      /* This could either be a symbol, or an absolute
		 address.  No matter, the frag hacking will finger it
		 out.  Not quite: it can't switch from BRANCH to
		 BCC68000 for the case where opnd is absolute (it
		 needs to use the 68000 hack since no conditional abs
		 jumps).  */
	      if (( !HAVE_LONG_BRANCH(current_architecture)
		   || (0 == adds (&opP->disp)))
		  && (the_ins.opcode[0] >= 0x6200)
		  && (the_ins.opcode[0] <= 0x6f00))
d2591 11
a2601 1
			  TAB (BCC68000, SZ_UNDEF));
d2604 1
a2604 1
			  TAB (ABRANCH, SZ_UNDEF));
d2609 6
a2614 3
#if 1
		  /* check for DBcc instruction */
		  if ((the_ins.opcode[0] & 0xf0f8) == 0x50c8)
d2616 6
a2621 4
		      /* size varies if patch */
		      /* needed for long form */
		      add_frag (adds (&opP->disp), offs (&opP->disp),
				TAB (DBCC, SZ_UNDEF));
a2623 1
#endif
d2634 1
a2634 9
	      if (subs (&opP->disp))
		{
		  add_fix ('l', &opP->disp, 1, 0);
		  add_frag ((symbolS *) 0, (offsetT) 0, TAB (FBRANCH, LONG));
		}
	      else if (adds (&opP->disp))
		add_frag (adds (&opP->disp), offs (&opP->disp),
			  TAB (FBRANCH, SZ_UNDEF));
	      else
a2635 2
		  /* add_frag ((symbolS *) 0, offs (&opP->disp),
		     	       TAB(FBRANCH,SHORT)); */
d2641 3
a4331 1
  long ext = 0;
d4354 4
a4357 2
    case TAB (BCC68000, BYTE):
    case TAB (ABRANCH, BYTE):
d4361 12
a4372 2
      fragP->fr_opcode[1] = disp;
      ext = 0;
d4374 5
a4378 9
    case TAB (DBCC, SHORT):
      know (issword (disp));
      ext = 2;
      break;
    case TAB (BCC68000, SHORT):
    case TAB (ABRANCH, SHORT):
      know (issword (disp));
      fragP->fr_opcode[1] = 0x00;
      ext = 2;
d4380 2
a4381 2
    case TAB (ABRANCH, LONG):
      if (!HAVE_LONG_BRANCH (current_architecture))
d4383 13
a4395 37
	  if (flag_keep_pcrel)
	    as_bad (_("long branch not supported"));

	  if (fragP->fr_opcode[0] == 0x61)
	    /* BSR */
	    {
	      fragP->fr_opcode[0] = 0x4E;
	      fragP->fr_opcode[1] = (char) 0xB9; /* JBSR with ABSL LONG offset */

	      fix_new (fragP,
		       fragP->fr_fix,
		       4,
		       fragP->fr_symbol,
		       fragP->fr_offset,
		       0,
		       NO_RELOC);

	      fragP->fr_fix += 4;
	      ext = 0;
	    }
	  /* BRA */
	  else if (fragP->fr_opcode[0] == 0x60)
	    {
	      fragP->fr_opcode[0] = 0x4E;
	      fragP->fr_opcode[1] = (char) 0xF9; /* JMP  with ABSL LONG offset */
	      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		       fragP->fr_offset, 0, NO_RELOC);
	      fragP->fr_fix += 4;
	      ext = 0;
	    }
	  else
	    {
	      /* This should never happen, because if it's a conditional
	         branch and we are on a 68000, BCC68000 should have been
	         picked instead of ABRANCH.  */
	      abort ();
	    }
d4399 3
a4401 2
	  fragP->fr_opcode[1] = (char) 0xff;
	  ext = 4;
d4404 3
a4406 5
    case TAB (BCC68000, LONG):
      /* only Bcc 68000 instructions can come here */
      /* change bcc into b!cc/jmp absl long */
      if (flag_keep_pcrel)
	as_bad (_("long branch not supported"));
d4418 1
a4418 1
	       fragP->fr_offset, 0, NO_RELOC);
a4419 1
      ext = 0;
d4421 20
a4440 2
    case TAB (DBCC, LONG):
      /* only DBcc 68000 instructions can come here */
a4441 2
      if (! HAVE_LONG_BRANCH (current_architecture) && flag_keep_pcrel)
	as_bad (_("long branch not supported"));
d4448 2
a4449 10
      if (HAVE_LONG_BRANCH (current_architecture))
	{
	  *buffer_address++ = 0x60;     /* Put in bral (0x60ff).  */
	  *buffer_address++ = (char) 0xff;
	}
      else
	{
	  *buffer_address++ = 0x4e;     /* Put in jmp long (0x4ef9).  */
	  *buffer_address++ = (char) 0xf9;
	}
d4452 2
a4453 3
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
	       fragP->fr_offset, HAVE_LONG_BRANCH (current_architecture),
	       NO_RELOC);
a4454 1
      ext = 0;
d4456 15
a4470 23
    case TAB (FBRANCH, SHORT):
      know ((fragP->fr_opcode[1] & 0x40) == 0);
      ext = 2;
      break;
    case TAB (FBRANCH, LONG):
      fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit */
      ext = 4;
      break;
    case TAB (PCREL, SHORT):
      ext = 2;
      break;
    case TAB (PCREL, LONG):
      /* The thing to do here is force it to ABSOLUTE LONG, since
	PCREL is really trying to shorten an ABSOLUTE address anyway */
      /* JF FOO This code has not been tested */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       0, NO_RELOC);
      if ((fragP->fr_opcode[1] & 0x3F) != 0x3A)
	as_bad (_("Internal error (long PC-relative operand) for insn 0x%04x at 0x%lx"),
		(unsigned) fragP->fr_opcode[0],
		(unsigned long) fragP->fr_address);
      fragP->fr_opcode[1] &= ~0x3F;
      fragP->fr_opcode[1] |= 0x39;	/* Mode 7.1 */
a4471 1
      ext = 0;
d4473 1
a4473 3
    case TAB (PCLEA, SHORT):
      fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
d4476 3
a4478 1
      ext = 2;
d4480 1
a4480 4
    case TAB (PCLEA, LONG):
      fixP = fix_new (fragP, (int) (fragP->fr_fix) + 2, 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, NO_RELOC);
      fixP->fx_pcrel_adjust = 2;
d4486 4
a4489 1
      ext = 4;
a4490 1

a4491 6
      disp += 2;
      if (!issbyte (disp))
	{
	  as_bad (_("displacement doesn't fit in one byte"));
	  disp = 0;
	}
d4494 3
a4496 2
      buffer_address[-1] = disp;
      ext = 0;
a4498 2
      disp += 2;
      assert (issword (disp));
d4503 1
a4503 2
		      fragP->fr_offset, (fragP->fr_opcode[1] & 077) == 073,
		      NO_RELOC);
d4505 1
a4505 1
      ext = 2;
a4507 5
      disp += 2;
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		      fragP->fr_offset, (fragP->fr_opcode[1] & 077) == 073,
		      NO_RELOC);
      fixP->fx_pcrel_adjust = 2;
d4511 20
a4530 1
      ext = 4;
a4532 6

  if (ext)
    {
      md_number_to_chars (buffer_address, (long) disp, (int) ext);
      fragP->fr_fix += ext;
    }
d4571 1
a4571 1
  /* handle SZ_UNDEF first, it can be changed to BYTE or SHORT */
d4574 2
a4575 2

    case TAB (ABRANCH, SZ_UNDEF):
d4577 1
a4577 2
	if ((fragP->fr_symbol != NULL)	/* Not absolute */
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
a4580 10
	    break;
	  }
	else if ((fragP->fr_symbol != NULL)
		 && (flag_short_refs || flag_keep_pcrel))
	  {			/* Symbol is undefined and we want short ref */
	    fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 2;
	    frag_wane (fragP);
	    break;
d4582 1
a4582 1
	else if ((fragP->fr_symbol == 0) || !HAVE_LONG_BRANCH(current_architecture))
d4584 3
a4586 27
	    /* On 68000, or for absolute value, switch to abs long */
	    /* FIXME, we should check abs val, pick short or long */
	    if (fragP->fr_opcode[0] == 0x61)
	      {
		fragP->fr_opcode[0] = 0x4E;
		fragP->fr_opcode[1] = (char) 0xB9; /* JBSR with ABSL LONG offset */
		fix_new (fragP, fragP->fr_fix, 4,
			 fragP->fr_symbol, fragP->fr_offset, 0, NO_RELOC);
		fragP->fr_fix += 4;
		frag_wane (fragP);
	      }
	    else if (fragP->fr_opcode[0] == 0x60)
	      {
		fragP->fr_opcode[0] = 0x4E;
		fragP->fr_opcode[1] = (char) 0xF9; /* JMP  with ABSL LONG offset */
		fix_new (fragP, fragP->fr_fix, 4,
			 fragP->fr_symbol, fragP->fr_offset, 0, NO_RELOC);
		fragP->fr_fix += 4;
		frag_wane (fragP);
	      }
	    else
	      {
		/* This should never happen, because if it's a conditional
		   branch and we are on a 68000, BCC68000 should have been
		   picked instead of ABRANCH.  */
		abort ();
	      }
d4589 4
a4592 7
	  {			/* Symbol is still undefined.  Make it simple */
	    fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 4;
	    fragP->fr_opcode[1] = (char) 0xff;
	    frag_wane (fragP);
	    break;
a4593 1

d4595 1
a4595 1
      }				/* case TAB(ABRANCH,SZ_UNDEF) */
d4597 1
a4597 1
    case TAB (FBRANCH, SZ_UNDEF):
d4599 6
a4604 3
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
d4606 2
a4607 1
	    fragP->fr_subtype = TAB (FBRANCH, SHORT);
d4612 3
a4614 5
	    fix_new (fragP, (int) fragP->fr_fix, 4, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 4;
	    fragP->fr_opcode[1] |= 0x40; /* Turn on LONG bit */
	    frag_wane (fragP);
d4617 1
a4617 1
      }				/* TAB(FBRANCH,SZ_UNDEF) */
d4619 1
a4619 1
    case TAB (PCREL, SZ_UNDEF):
d4621 2
a4622 3
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
d4624 1
a4624 2
	    fragP->fr_subtype = TAB (PCREL, SHORT);
	    fragP->fr_var += 2;
d4628 3
a4630 2
	    fragP->fr_subtype = TAB (PCREL, LONG);
	    fragP->fr_var += 4;
d4633 1
a4633 1
      }				/* TAB(PCREL,SZ_UNDEF) */
d4635 1
a4635 1
    case TAB (BCC68000, SZ_UNDEF):
d4637 3
a4639 3
	if ((fragP->fr_symbol != NULL)
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
d4641 2
a4642 10
	    fragP->fr_subtype = TAB (BCC68000, BYTE);
	    break;
	  }
	/* only Bcc 68000 instructions can come here */
	if ((fragP->fr_symbol != NULL) && (flag_short_refs || flag_keep_pcrel))
	  {
	    /* the user wants short refs, so emit one */
	    fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 2;
d4646 2
a4647 10
	    /* change bcc into b!cc/jmp absl long */
	    fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
	    fragP->fr_opcode[1] = 0x06;	/* branch offset = 6 */
	    /* JF: these were fr_opcode[2,3] */
	    buffer_address[0] = 0x4e;	/* put in jmp long (0x4ef9) */
	    buffer_address[1] = (char) 0xf9;
	    fragP->fr_fix += 2;	/* account for jmp instruction */
	    fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		     fragP->fr_offset, 0, NO_RELOC);
	    fragP->fr_fix += 4;
a4648 1
	frag_wane (fragP);
d4650 1
a4650 1
      }				/* case TAB(BCC68000,SZ_UNDEF) */
d4652 2
a4653 1
    case TAB (DBCC, SZ_UNDEF):
d4655 3
a4657 3
	if (fragP->fr_symbol != NULL
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
d4659 1
a4659 1
	    fragP->fr_subtype = TAB (DBCC, SHORT);
a4660 13
	    break;
	  }
	/* only DBcc 68000 instructions can come here */

	if (fragP->fr_symbol != NULL
	    && (flag_short_refs
		|| (! HAVE_LONG_BRANCH (current_architecture)
		    && flag_keep_pcrel)))
	  {
	    /* the user wants short refs, so emit one */
	    fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 2;
d4664 2
a4665 22
	    /* Change dbcc into dbcc/bral.  */
	    /* JF: these used to be fr_opcode[2-4], which is wrong.  */
	    buffer_address[0] = 0x00;	/* branch offset = 4 */
	    buffer_address[1] = 0x04;
	    buffer_address[2] = 0x60;	/* put in bra pc + ...  */
	    /* JF: these were fr_opcode[5-7] */
	    buffer_address[3] = 0x06;	/* Plus 6 */
	    if (HAVE_LONG_BRANCH (current_architecture))
	      {
		buffer_address[4] = 0x60;       /* Put in bral (0x60ff).  */
		buffer_address[5] = (char) 0xff;
	      }
	    else
	      {
		buffer_address[4] = 0x4e;       /* Put in jmp long (0x4ef9).  */
		buffer_address[5] = (char) 0xf9;
	      }
	    fragP->fr_fix += 6;	/* account for bra/jmp instruction */
	    fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		     fragP->fr_offset, HAVE_LONG_BRANCH (current_architecture),
		     NO_RELOC);
	    fragP->fr_fix += 4;
a4666 2

	frag_wane (fragP);
d4668 1
a4668 1
      }				/* case TAB(DBCC,SZ_UNDEF) */
d4670 1
a4670 1
    case TAB (PCLEA, SZ_UNDEF):
d4674 1
a4674 3
	    || flag_short_refs
	    || cpu_of_arch (current_architecture) < m68020
	    || cpu_of_arch (current_architecture) == mcf5200)
d4676 1
a4676 1
	    fragP->fr_subtype = TAB (PCLEA, SHORT);
d4681 1
a4681 1
	    fragP->fr_subtype = TAB (PCLEA, LONG);
d4685 2
a4686 2
      }				/* TAB(PCLEA,SZ_UNDEF) */

d4689 1
a4689 3
	   && relaxable_symbol (fragP->fr_symbol))
	  || cpu_of_arch (current_architecture) < m68020
	  || cpu_of_arch (current_architecture) == mcf5200)
d4700 16
d4720 1
a4720 1
  /* now that SZ_UNDEF are taken care of, check others */
d4723 4
a4726 2
    case TAB (BCC68000, BYTE):
    case TAB (ABRANCH, BYTE):
@


1.9
log
@Add --pcrel option to m68k port
@
text
@d49 2
a50 2
   #NO_APP at the beginning of its output. */
/* Also note that comments like this one will always work. */
d71 1
a71 1
   references.  Not implemented.  For ELF there are other means 
d198 1
a198 1
  CACR, TC, ITT0, ITT1, DTT0, DTT1, VBR, ROMBAR, 
d440 1
a440 1
   size expressions.  This version only supports two kinds. */
a565 1

d796 1
a796 1
  /* Prevent all adjustments to global symbols. */
d957 1
a957 1
 
d986 1
a986 1
     or exactly 1 space. */
d1095 1
a1095 1
	 common model with this pattern then reject this pattern. */
d1758 1
a1758 1
		    }		/* not a cache specifier. */
d1771 1
a1771 1
                     registers, but ordinary ones. */
d1791 1
a1791 1
	}			/* got it. */
d2147 1
a2147 1
		  if ((opP->index.scale != 1 
d2149 1
a2149 1
		      || (opP->index.scale == 8 
d2825 1
a2825 1
	  /* JF: These are out of order, I fear. */
d2963 1
a2963 1
     instruction, ready to be emitted. . . */
d3429 1
a3429 1
  /* Upper and lower data and address registers, used by macw and msacw. */
d3727 1
a3727 1
	     but just leaving them out of the hash. */
d4286 1
a4286 1
     want. */
d4324 1
a4324 1
	  
d4356 1
a4356 1
	         picked instead of ABRANCH. */
d4371 1
a4371 1
      
d4377 1
a4377 1
	   Only fr_opcode[0,1] are guaranteed to work. */
d4588 1
a4588 1
		   picked instead of ABRANCH. */
d4701 1
a4701 1
	    /* JF: these used to be fr_opcode[2-4], which is wrong. */
d4704 1
a4704 1
	    buffer_address[2] = 0x60;	/* put in bra pc + ... */
d4810 1
a4810 1
   format. */
d5092 1
a5092 1
  if (!need_pass_2)		/* Never make frag if expect extra pass. */
d5955 1
a5955 1
      
d5977 1
a5977 1
      
d7129 1
a7129 1
   first extension word is stored in fx_pcrel_adjust. */
@


1.8
log
@Fix comments.
@
text
@d77 1
d4321 1
a4321 1
      if (!HAVE_LONG_BRANCH(current_architecture))
d4323 3
d4370 3
d4389 4
a4392 1
      /* change dbcc into dbcc/jmp absl long */
d4398 10
a4407 2
      *buffer_address++ = 0x4e;	/* put in jmp long (0x4ef9) */
      *buffer_address++ = (char) 0xf9;
d4411 2
a4412 1
	       fragP->fr_offset, 0, NO_RELOC);
d4554 2
a4555 1
	else if ((fragP->fr_symbol != NULL) && flag_short_refs)
d4653 1
a4653 1
	if ((fragP->fr_symbol != NULL) && flag_short_refs)
d4689 4
a4692 1
	if (fragP->fr_symbol != NULL && flag_short_refs)
d4701 1
a4701 1
	    /* change dbcc into dbcc/jmp absl long */
d4708 10
a4717 2
	    buffer_address[4] = 0x4e;	/* put in jmp long (0x4ef9) */
	    buffer_address[5] = (char) 0xf9;
d4720 2
a4721 1
		     fragP->fr_offset, 0, NO_RELOC);
d6780 1
d6809 2
d6832 5
d6993 1
@


1.7
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d4082 2
a4083 2
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
@


1.6
log
@Michael Sokolov's 68000 patches + assorted compiler warning fixes.
@
text
@d53 1
a53 1
const char line_separator_chars[] = "";
@


1.5
log
@	* config/tc-m68k.c: Add some ATTRIBUTE_UNUSED.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d1825 2
a1826 1
		    for (idx = 0; idx < sizeof (archs) / sizeof (archs[0]);
a2366 2
		  /* Don't generate pc relative code on 68010 and
		     68000.  */
a2376 1
		      && HAVE_LONG_BRANCH(current_architecture)
d2756 1
a2756 1
		    ? 0x20 + opP->reg - DATA
d3706 1
a3706 1
  register unsigned int i;
d3787 3
a3789 1
      for (i = 0; i < sizeof mri_aliases / sizeof mri_aliases[0]; i++)
d3802 1
a3802 1
  for (i = 0; i < sizeof (mklower_table); i++)
d3805 1
a3805 1
  for (i = 0; i < sizeof (notend_table); i++)
d4351 4
a4354 1
	      as_bad (_("Long branch offset not supported."));
d4490 2
a4491 2
     object_headers *headers;
     segT sec;
d4535 8
d4567 4
a4570 1
		as_warn (_("Long branch offset to extern symbol not supported."));
d4610 1
a4610 3
	    || flag_short_refs
	    || cpu_of_arch (current_architecture) < m68020
	    || cpu_of_arch (current_architecture) == mcf5200)
d4633 1
a4633 3
	/* change bcc into b!cc/jmp absl long */
	fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
	if (flag_short_refs)
d4635 1
a4635 5
	    fragP->fr_opcode[1] = 0x04;	/* branch offset = 6 */
	    /* JF: these were fr_opcode[2,3] */
	    buffer_address[0] = 0x4e;	/* put in jmp long (0x4ef9) */
	    buffer_address[1] = (char) 0xf8;
	    fragP->fr_fix += 2;	/* account for jmp instruction */
d4637 1
a4637 1
		     fragP->fr_offset, 0, NO_RELOC);
d4642 2
a4667 5
	/* change dbcc into dbcc/jmp absl long */
	/* JF: these used to be fr_opcode[2-4], which is wrong. */
	buffer_address[0] = 0x00;	/* branch offset = 4 */
	buffer_address[1] = 0x04;
	buffer_address[2] = 0x60;	/* put in bra pc + ... */
d4669 1
a4669 1
	if (flag_short_refs)
d4671 1
a4671 5
	    /* JF: these were fr_opcode[5-7] */
	    buffer_address[3] = 0x04;	/* plus 4 */
	    buffer_address[4] = 0x4e;	/* Put in Jump Word */
	    buffer_address[5] = (char) 0xf8;
	    fragP->fr_fix += 6;	/* account for bra/jmp instruction */
d4673 1
a4673 1
		     fragP->fr_offset, 0, NO_RELOC);
d4678 5
d5266 1
a5266 1
#define OPTCOUNT (sizeof opt_table / sizeof opt_table[0])
d7110 1
a7110 1
     symbolS *ignore;
@


1.5.2.1
log
@Michael Sokolov's 68000 patches + assorted compiler warning fixes.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d1825 1
a1825 2
		    for (idx = 0;
			 idx < (int) (sizeof (archs) / sizeof (archs[0]));
d2366 2
d2378 1
d2758 1
a2758 1
		    ? 0x20 + (int) (opP->reg - DATA)
d3708 1
a3708 1
  register int i;
d3789 1
a3789 3
      for (i = 0;
	   i < (int) (sizeof mri_aliases / sizeof mri_aliases[0]);
	   i++)
d3802 1
a3802 1
  for (i = 0; i < (int) sizeof (mklower_table); i++)
d3805 1
a3805 1
  for (i = 0; i < (int) sizeof (notend_table); i++)
d4351 1
a4351 4
	      /* This should never happen, because if it's a conditional
	         branch and we are on a 68000, BCC68000 should have been
	         picked instead of ABRANCH. */
	      abort ();
d4487 2
a4488 2
     object_headers *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
a4531 8
	else if ((fragP->fr_symbol != NULL) && flag_short_refs)
	  {			/* Symbol is undefined and we want short ref */
	    fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 2;
	    frag_wane (fragP);
	    break;
	  }
d4556 1
a4556 4
		/* This should never happen, because if it's a conditional
		   branch and we are on a 68000, BCC68000 should have been
		   picked instead of ABRANCH. */
		abort ();
d4596 3
a4598 1
	    || flag_short_refs)
d4621 3
a4623 1
	if ((fragP->fr_symbol != NULL) && flag_short_refs)
d4625 5
a4629 1
	    /* the user wants short refs, so emit one */
d4631 1
a4631 1
		     fragP->fr_offset, 1, NO_RELOC);
a4635 2
	    /* change bcc into b!cc/jmp absl long */
	    fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
d4660 5
d4666 1
a4666 1
	if (fragP->fr_symbol != NULL && flag_short_refs)
d4668 5
a4672 1
	    /* the user wants short refs, so emit one */
d4674 1
a4674 1
		     fragP->fr_offset, 1, NO_RELOC);
a4678 5
	    /* change dbcc into dbcc/jmp absl long */
	    /* JF: these used to be fr_opcode[2-4], which is wrong. */
	    buffer_address[0] = 0x00;	/* branch offset = 4 */
	    buffer_address[1] = 0x04;
	    buffer_address[2] = 0x60;	/* put in bra pc + ... */
d5262 1
a5262 1
#define OPTCOUNT ((int) (sizeof opt_table / sizeof opt_table[0]))
d7106 1
a7106 1
     symbolS *ignore ATTRIBUTE_UNUSED;
@


1.4
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d4498 2
a4499 2
     bfd *abfd;
     segT sec;
d4837 2
a4838 2
     fragS *frag;
     symbolS *to_symbol;
d5023 1
a5023 1
     int ignore;
d5031 1
a5031 1
     int ignore;
d5039 1
a5039 1
     int ignore;
d5050 1
a5050 1
     int ignore;
d5065 1
a5065 1
     int ignore;
d5141 1
a5141 1
     int ignore;
d5158 1
a5158 1
     int ignore;
d5268 1
a5268 1
     int ignore;
d5336 2
a5337 2
     int arg;
     int on;
d5348 2
a5349 2
     int arg;
     int on;
d5365 2
a5366 2
     int arg;
     int on;
d5382 1
a5382 1
     int arg;
d5392 1
a5392 1
     int arg;
d5405 1
a5405 1
     int ignore;
d5509 1
a5509 1
     int ignore;
d5534 1
a5534 1
     int ignore;
d6211 1
a6211 1
     int ignore;
d6554 1
a6554 1
     int ignore;
d6590 1
a6590 1
     int ignore;
d6695 1
a6695 1
     int ignore;
d7054 1
a7054 1
     char *name;
d7062 1
a7062 1
     segT segment;
@


1.3
log
@1999-05-28  Torbjorn Granlund  <tege@@matematik.su.se>
	* config/tc-m68k.c (m68k_ip): Check for disallowed index register
	width for Coldfire.
	(arch_coldfire_p): New #define.
	(m68k_ip, m68k_init_after_args): Use arch_coldfire_p.
1999-05-28  Linus Nordberg  <linus.nordberg@@canit.se>
	* config/tc-m68k.c (install_operand): Add places `n', `o'.
	* config/tc-m68k.c (m68k_ip): Add formats `E', `G', `H'.
	(install_operand): Add place `N'.
	(init_table): Add registers ACC, MACSR, MASK.
	* config/m68k-parse.h (m68k_register): Add ACC, MACSR, MASK.
	* config/tc-m68k.c: Change mcf5200 --> mcf.
	(archs): Add mcf5206e, mcf5307.
	(m68k_ip): Add format `u'.
	(install_operand): Add place `m', `M', `h'.
	(init_table): Add upper/lower registers.
	* config/m68k-parse.h (m68k_register): Add upper/lower registers.
@
text
@d910 2
a911 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d4296 1
a4296 1
  disp += fragP->fr_symbol->sy_frag->fr_address;
d4745 1
d4748 2
a4749 3
	  for (l = fragP->fr_next;
	       l != fragP->fr_symbol->sy_frag;
	       l = l->fr_next)
d4752 1
a4752 1
	  if (l == fragP->fr_symbol->sy_frag)
d5476 1
a5476 1
  line_label->sy_frag = &zero_address_frag;
@


1.2
log
@        * tc-m68k.c: Include elf/m68k.h.
        (m68k_elf_final_processing): New routine.
        * tc-m68k.h (elf_tc_final_processing m68k_elf_final_processing):
        Define.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 1998
d196 1
a196 1
static const enum m68k_register mcf5200_control_regs[] = {
d254 1
a254 1
#define cpu_of_arch(x)		((x) & (m68000up|mcf5200))
d257 1
d399 2
d428 3
d1484 5
d1494 10
d1765 13
d2035 1
a2035 1
			   && cpu_of_arch (current_architecture) != mcf5200)
d2039 1
a2039 1
		      || cpu_of_arch (current_architecture) == mcf5200)
d2148 1
a2148 1
			  && current_architecture == mcf5200))
d2154 4
d2189 1
a2189 1
			  || cpu_of_arch (current_architecture) == mcf5200
d2256 1
a2256 1
		  || cpu_of_arch (current_architecture) == mcf5200)
d2615 3
d2622 4
d2953 5
d3097 24
d3322 4
d3430 37
d3901 3
a3903 1
      control_regs = mcf5200_control_regs;
d3977 1
a3977 1
      || cpu_of_arch (current_architecture) == mcf5200)
@


1.1
log
@Initial revision
@
text
@d30 4
d7012 8
a7019 1

@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

