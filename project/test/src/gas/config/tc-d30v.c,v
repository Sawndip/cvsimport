head	1.42;
access;
symbols
	binutils-2_24-branch:1.42.0.10
	binutils-2_24-branchpoint:1.42
	binutils-2_21_1:1.42
	binutils-2_23_2:1.42
	binutils-2_23_1:1.42
	binutils-2_23:1.42
	binutils-2_23-branch:1.42.0.8
	binutils-2_23-branchpoint:1.42
	binutils-2_22_branch:1.42.0.6
	binutils-2_22:1.42
	binutils-2_22-branch:1.42.0.4
	binutils-2_22-branchpoint:1.42
	binutils-2_21:1.42
	binutils-2_21-branch:1.42.0.2
	binutils-2_21-branchpoint:1.42
	binutils-2_20_1:1.36.2.2
	binutils-2_20:1.36.2.2
	binutils-arc-20081103-branch:1.34.0.6
	binutils-arc-20081103-branchpoint:1.34
	binutils-2_20-branch:1.36.0.2
	binutils-2_20-branchpoint:1.36
	dje-cgen-play1-branch:1.35.0.2
	dje-cgen-play1-branchpoint:1.35
	arc-20081103-branch:1.34.0.4
	arc-20081103-branchpoint:1.34
	binutils-2_19_1:1.34
	binutils-2_19:1.34
	binutils-2_19-branch:1.34.0.2
	binutils-2_19-branchpoint:1.34
	binutils-2_18:1.32
	binutils-2_18-branch:1.32.0.2
	binutils-2_18-branchpoint:1.32
	binutils-csl-coldfire-4_1-32:1.30
	binutils-csl-sourcerygxx-4_1-32:1.30
	binutils-csl-innovasic-fido-3_4_4-33:1.30
	binutils-csl-sourcerygxx-3_4_4-32:1.27
	binutils-csl-coldfire-4_1-30:1.30
	binutils-csl-sourcerygxx-4_1-30:1.30
	binutils-csl-coldfire-4_1-28:1.30
	binutils-csl-sourcerygxx-4_1-29:1.30
	binutils-csl-sourcerygxx-4_1-28:1.30
	binutils-csl-arm-2006q3-27:1.30
	binutils-csl-sourcerygxx-4_1-27:1.30
	binutils-csl-arm-2006q3-26:1.30
	binutils-csl-sourcerygxx-4_1-26:1.30
	binutils-csl-sourcerygxx-4_1-25:1.30
	binutils-csl-sourcerygxx-4_1-24:1.30
	binutils-csl-sourcerygxx-4_1-23:1.30
	binutils-csl-sourcerygxx-4_1-21:1.30
	binutils-csl-arm-2006q3-21:1.30
	binutils-csl-sourcerygxx-4_1-22:1.30
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.30
	binutils-csl-sourcerygxx-4_1-20:1.30
	binutils-csl-arm-2006q3-19:1.30
	binutils-csl-sourcerygxx-4_1-19:1.30
	binutils-csl-sourcerygxx-4_1-18:1.30
	binutils-csl-renesas-4_1-9:1.30
	binutils-csl-sourcerygxx-3_4_4-25:1.27
	binutils-csl-renesas-4_1-8:1.30
	binutils-csl-renesas-4_1-7:1.30
	binutils-csl-renesas-4_1-6:1.30
	binutils-csl-sourcerygxx-4_1-17:1.30
	binutils-csl-sourcerygxx-4_1-14:1.30
	binutils-csl-sourcerygxx-4_1-15:1.30
	binutils-csl-sourcerygxx-4_1-13:1.30
	binutils-2_17:1.30
	binutils-csl-sourcerygxx-4_1-12:1.30
	binutils-csl-sourcerygxx-3_4_4-21:1.30
	binutils-csl-wrs-linux-3_4_4-24:1.27
	binutils-csl-wrs-linux-3_4_4-23:1.27
	binutils-csl-sourcerygxx-4_1-9:1.30
	binutils-csl-sourcerygxx-4_1-8:1.30
	binutils-csl-sourcerygxx-4_1-7:1.30
	binutils-csl-arm-2006q1-6:1.30
	binutils-csl-sourcerygxx-4_1-6:1.30
	binutils-csl-wrs-linux-3_4_4-22:1.27
	binutils-csl-coldfire-4_1-11:1.30
	binutils-csl-sourcerygxx-3_4_4-19:1.30
	binutils-csl-coldfire-4_1-10:1.30
	binutils-csl-sourcerygxx-4_1-5:1.30
	binutils-csl-sourcerygxx-4_1-4:1.30
	binutils-csl-wrs-linux-3_4_4-21:1.27
	binutils-csl-morpho-4_1-4:1.30
	binutils-csl-sourcerygxx-3_4_4-17:1.30
	binutils-csl-wrs-linux-3_4_4-20:1.27
	binutils-2_17-branch:1.30.0.4
	binutils-2_17-branchpoint:1.30
	binutils-csl-2_17-branch:1.30.0.2
	binutils-csl-2_17-branchpoint:1.30
	binutils-csl-gxxpro-3_4-branch:1.27.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.27
	binutils-2_16_1:1.27
	binutils-csl-arm-2005q1b:1.27
	binutils-2_16:1.27
	binutils-csl-arm-2005q1a:1.27
	binutils-csl-arm-2005q1-branch:1.27.0.4
	binutils-csl-arm-2005q1-branchpoint:1.27
	binutils-2_16-branch:1.27.0.2
	binutils-2_16-branchpoint:1.27
	csl-arm-2004-q3d:1.24
	csl-arm-2004-q3:1.24
	binutils-2_15:1.24
	binutils-2_15-branchpoint:1.24
	csl-arm-2004-q1a:1.24
	csl-arm-2004-q1:1.24
	binutils-2_15-branch:1.24.0.6
	cagney_bfdfile-20040213-branch:1.24.0.4
	cagney_bfdfile-20040213-branchpoint:1.24
	cagney_bigcore-20040122-branch:1.24.0.2
	cagney_bigcore-20040122-branchpoint:1.24
	csl-arm-2003-q4:1.24
	binutils-2_14:1.22
	binutils-2_14-branch:1.22.0.2
	binutils-2_14-branchpoint:1.22
	binutils-2_13_2_1:1.18
	binutils-2_13_2:1.18
	binutils-2_13_1:1.18
	binutils-2_13:1.18
	binutils-2_13-branchpoint:1.18
	binutils-2_13-branch:1.18.0.2
	binutils-2_12_1:1.17
	binutils-2_12:1.17
	binutils-2_12-branch:1.17.0.2
	binutils-2_12-branchpoint:1.17
	cygnus_cvs_20020108_pre:1.17
	binutils-2_11_2:1.14.2.1
	binutils-2_11_1:1.14.2.1
	binutils-2_11:1.14
	x86_64versiong3:1.14
	binutils-2_11-branch:1.14.0.2
	binutils-2_10_1:1.9
	binutils-2_10:1.9
	binutils-2_10-branch:1.9.0.2
	binutils-2_10-branchpoint:1.9
	binutils_latest_snapshot:1.42
	repo-unification-2000-02-06:1.6
	binu_ss_19990721:1.4
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2010.10.28.05.34.55;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2010.08.02.13.53.29;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.10.14.05.40;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.08.10.36.39;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.12.08.37.08;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.05.09.12.55;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.24.20.40.26;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.03.11.47.49;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.31.23.18.27;	author bje;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.21.00.24.40;	author kazu;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.16.09.57.49;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.12.22.41.25;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.09.13.12.57;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.15.21.28.55;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.05.33.22;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.26.07.09.18;	author kazu;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.07.31.22.46.36;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.05.21.55.13;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.27.18.21.39;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.21.17.20.03;	author rth;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.02.08.24.54;	author rth;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.02.22.18.12;	author meissner;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.22.20.54.18;	author cchavva;	state Exp;
branches;
next	1.6;

1.6
date	99.10.07.06.26.25;	author dnovillo;	state Exp;
branches;
next	1.5;

1.5
date	99.08.09.19.04.27;	author amylaar;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.14.52.52;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.22.14.07.33;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.25;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.36.2.1
date	2009.09.08.10.53.21;	author amodra;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2009.09.10.14.09.42;	author amodra;	state Exp;
branches;
next	;

1.14.2.1
date	2001.06.07.03.15.28;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.42
log
@	* config/tc-d30v.c (d30v_cons_align): Don't align .eh_frame.
@
text
@/* tc-d30v.c -- Assembler code for the Mitsubishi D30V
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008,
   2009, 2010 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/d30v.h"
#include "dwarf2dbg.h"

const char comment_chars[]        = ";";
const char line_comment_chars[]   = "#";
const char line_separator_chars[] = "";
const char *md_shortopts          = "OnNcC";
const char EXP_CHARS[]            = "eE";
const char FLT_CHARS[]            = "dD";

#if HAVE_LIMITS_H
#include <limits.h>
#endif

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#define NOP_MULTIPLY 1
#define NOP_ALL 2
static int warn_nops = 0;
static int Optimizing = 0;
static int warn_register_name_conflicts = 1;

#define FORCE_SHORT	1
#define FORCE_LONG	2

/* EXEC types.  */
typedef enum _exec_type
{
  EXEC_UNKNOWN,			/* No order specified.  */
  EXEC_PARALLEL,		/* Done in parallel (FM=00).  */
  EXEC_SEQ,			/* Sequential (FM=01).  */
  EXEC_REVSEQ			/* Reverse sequential (FM=10).  */
} exec_type_enum;

/* Fixups.  */
#define MAX_INSN_FIXUPS  5

struct d30v_fixup
{
  expressionS exp;
  int operand;
  int pcrel;
  int size;
  bfd_reloc_code_real_type reloc;
};

typedef struct _fixups
{
  int fc;
  struct d30v_fixup fix[MAX_INSN_FIXUPS];
  struct _fixups *next;
} Fixups;

static Fixups FixUps[2];
static Fixups *fixups;

/* Whether current and previous instruction are word multiply insns.  */
static int cur_mul32_p = 0;
static int prev_mul32_p = 0;

/*  The flag_explicitly_parallel is true iff the instruction being assembled
    has been explicitly written as a parallel short-instruction pair by the
    human programmer.  It is used in parallel_ok () to distinguish between
    those dangerous parallelizations attempted by the human, which are to be
    allowed, and those attempted by the assembler, which are not.  It is set
    from md_assemble ().  */
static int flag_explicitly_parallel = 0;
static int flag_xp_state = 0;

/* Whether current and previous left sub-instruction disables
   execution of right sub-instruction.  */
static int cur_left_kills_right_p = 0;
static int prev_left_kills_right_p = 0;

/* The known current alignment of the current section.  */
static int d30v_current_align;
static segT d30v_current_align_seg;

/* The last seen label in the current section.  This is used to auto-align
   labels preceding instructions.  */
static symbolS *d30v_last_label;

/* Two nops.  */
#define NOP_LEFT   ((long long) NOP << 32)
#define NOP_RIGHT  ((long long) NOP)
#define NOP2 (FM00 | NOP_LEFT | NOP_RIGHT)

struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

/* Opcode hash table.  */
static struct hash_control *d30v_hash;

/* Do a binary search of the pre_defined_registers array to see if
   NAME is a valid regiter name.  Return the register number from the
   array on success, or -1 on failure.  */

static int
reg_name_search (char *name)
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = reg_name_cnt () - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, pre_defined_registers[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	{
	  if (symbol_find (name) != NULL)
	    {
	      if (warn_register_name_conflicts)
		as_warn (_("Register name %s conflicts with symbol of the same name"),
			 name);
	    }

	  return pre_defined_registers[middle].value;
	}
    }
  while (low <= high);

  return -1;
}

/* Check the string at input_line_pointer to see if it is a valid
   register name.  */

static int
register_name (expressionS *expressionP)
{
  int reg_number;
  char c, *p = input_line_pointer;

  while (*p && *p != '\n' && *p != '\r' && *p != ',' && *p != ' ' && *p != ')')
    p++;

  c = *p;
  if (c)
    *p++ = 0;

  /* Look to see if it's in the register table.  */
  reg_number = reg_name_search (input_line_pointer);
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      /* Temporarily store a pointer to the string here.  */
      expressionP->X_op_symbol = (symbolS *) input_line_pointer;
      expressionP->X_add_number = reg_number;
      input_line_pointer = p;
      return 1;
    }
  if (c)
    *(p - 1) = c;
  return 0;
}

static int
check_range (unsigned long num, int bits, int flags)
{
  long min, max;

  /* Don't bother checking 32-bit values.  */
  if (bits == 32)
    {
      if (sizeof (unsigned long) * CHAR_BIT == 32)
	return 0;

      /* We don't record signed or unsigned for 32-bit quantities.
	 Allow either.  */
      min = -((unsigned long) 1 << (bits - 1));
      max = ((unsigned long) 1 << bits) - 1;
      return (long) num < min || (long) num > max;
    }

  if (flags & OPERAND_SHIFT)
    {
      /* We know that all shifts are right by three bits.  */
      num >>= 3;

      if (flags & OPERAND_SIGNED)
	{
	  unsigned long sign_bit = ((unsigned long) -1L >> 4) + 1;
	  num = (num ^ sign_bit) - sign_bit;
	}
    }

  if (flags & OPERAND_SIGNED)
    {
      max = ((unsigned long) 1 << (bits - 1)) - 1;
      min = - ((unsigned long) 1 << (bits - 1));
      return (long) num > max || (long) num < min;
    }
  else
    {
      max = ((unsigned long) 1 << bits) - 1;
      return num > (unsigned long) max;
    }
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\nD30V options:\n\
-O                      Make adjacent short instructions parallel if possible.\n\
-n                      Warn about all NOPs inserted by the assembler.\n\
-N			Warn about NOPs inserted after word multiplies.\n\
-c                      Warn about symbols whoes names match register names.\n\
-C                      Opposite of -C.  -c is the default.\n"));
}

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
      /* Optimize.  Will attempt to parallelize operations.  */
    case 'O':
      Optimizing = 1;
      break;

      /* Warn about all NOPS that the assembler inserts.  */
    case 'n':
      warn_nops = NOP_ALL;
      break;

      /* Warn about the NOPS that the assembler inserts because of the
	 multiply hazard.  */
    case 'N':
      warn_nops = NOP_MULTIPLY;
      break;

    case 'c':
      warn_register_name_conflicts = 1;
      break;

    case 'C':
      warn_register_name_conflicts = 0;
      break;

    default:
      return 0;
    }
  return 1;
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
  abort ();
}

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin (void)
{
  struct d30v_opcode *opcode;
  d30v_hash = hash_new ();

  /* Insert opcode names into a hash table.  */
  for (opcode = (struct d30v_opcode *) d30v_opcode_table; opcode->name; opcode++)
      hash_insert (d30v_hash, opcode->name, (char *) opcode);

  fixups = &FixUps[0];
  FixUps[0].next = &FixUps[1];
  FixUps[1].next = &FixUps[0];

  d30v_current_align_seg = now_seg;
}

/* Remove the postincrement or postdecrement operator ( '+' or '-' )
   from an expression.  */

static int
postfix (char *p)
{
  while (*p != '-' && *p != '+')
    {
      if (*p == 0 || *p == '\n' || *p == '\r' || *p == ' ' || *p == ',')
	break;
      p++;
    }

  if (*p == '-')
    {
      *p = ' ';
      return -1;
    }

  if (*p == '+')
    {
      *p = ' ';
      return 1;
    }

  return 0;
}

static bfd_reloc_code_real_type
get_reloc (const struct d30v_operand *op, int rel_flag)
{
  switch (op->bits)
    {
    case 6:
      if (op->flags & OPERAND_SHIFT)
	return BFD_RELOC_D30V_9_PCREL;
      else
	return BFD_RELOC_D30V_6;
      break;
    case 12:
      if (!(op->flags & OPERAND_SHIFT))
	as_warn (_("unexpected 12-bit reloc type"));
      if (rel_flag == RELOC_PCREL)
	return BFD_RELOC_D30V_15_PCREL;
      else
	return BFD_RELOC_D30V_15;
    case 18:
      if (!(op->flags & OPERAND_SHIFT))
	as_warn (_("unexpected 18-bit reloc type"));
      if (rel_flag == RELOC_PCREL)
	return BFD_RELOC_D30V_21_PCREL;
      else
	return BFD_RELOC_D30V_21;
    case 32:
      if (rel_flag == RELOC_PCREL)
	return BFD_RELOC_D30V_32_PCREL;
      else
	return BFD_RELOC_D30V_32;
    default:
      return 0;
    }
}

/* Parse a string of operands and return an array of expressions.  */

static int
get_operands (expressionS exp[], int cmp_hack)
{
  char *p = input_line_pointer;
  int numops = 0;
  int post = 0;

  if (cmp_hack)
    {
      exp[numops].X_op = O_absent;
      exp[numops++].X_add_number = cmp_hack - 1;
    }

  while (*p)
    {
      while (*p == ' ' || *p == '\t' || *p == ',')
	p++;

      if (*p == 0 || *p == '\n' || *p == '\r')
	break;

      if (*p == '@@')
	{
	  p++;
	  exp[numops].X_op = O_absent;
	  if (*p == '(')
	    {
	      p++;
	      exp[numops].X_add_number = OPERAND_ATPAR;
	      post = postfix (p);
	    }
	  else if (*p == '-')
	    {
	      p++;
	      exp[numops].X_add_number = OPERAND_ATMINUS;
	    }
	  else
	    {
	      exp[numops].X_add_number = OPERAND_ATSIGN;
	      post = postfix (p);
	    }
	  numops++;
	  continue;
	}

      if (*p == ')')
	{
	  /* Just skip the trailing paren.  */
	  p++;
	  continue;
	}

      input_line_pointer = p;

      /* Check to see if it might be a register name.  */
      if (!register_name (&exp[numops]))
	{
	  /* Parse as an expression.  */
	  expression (&exp[numops]);
	}

      if (exp[numops].X_op == O_illegal)
	as_bad (_("illegal operand"));
      else if (exp[numops].X_op == O_absent)
	as_bad (_("missing operand"));

      numops++;
      p = input_line_pointer;

      switch (post)
	{
	case -1:
	  /* Postdecrement mode.  */
	  exp[numops].X_op = O_absent;
	  exp[numops++].X_add_number = OPERAND_MINUS;
	  break;
	case 1:
	  /* Postincrement mode.  */
	  exp[numops].X_op = O_absent;
	  exp[numops++].X_add_number = OPERAND_PLUS;
	  break;
	}
      post = 0;
    }

  exp[numops].X_op = 0;

  return numops;
}

/* Generate the instruction.
   It does everything but write the FM bits.  */

static long long
build_insn (struct d30v_insn *opcode, expressionS *opers)
{
  int i, bits, shift, flags;
  unsigned long number, id = 0;
  long long insn;
  struct d30v_opcode *op = opcode->op;
  struct d30v_format *form = opcode->form;

  insn =
    opcode->ecc << 28 | op->op1 << 25 | op->op2 << 20 | form->modifier << 18;

  for (i = 0; form->operands[i]; i++)
    {
      flags = d30v_operand_table[form->operands[i]].flags;

      /* Must be a register or number.  */
      if (!(flags & OPERAND_REG) && !(flags & OPERAND_NUM)
	  && !(flags & OPERAND_NAME) && !(flags & OPERAND_SPECIAL))
	continue;

      bits = d30v_operand_table[form->operands[i]].bits;
      if (flags & OPERAND_SHIFT)
	bits += 3;

      shift = 12 - d30v_operand_table[form->operands[i]].position;
      if (opers[i].X_op != O_symbol)
	number = opers[i].X_add_number;
      else
	number = 0;
      if (flags & OPERAND_REG)
	{
	  /* Check for mvfsys or mvtsys control registers.  */
	  if (flags & OPERAND_CONTROL && (number & 0x7f) > MAX_CONTROL_REG)
	    {
	      /* PSWL or PSWH.  */
	      id = (number & 0x7f) - MAX_CONTROL_REG;
	      number = 0;
	    }
	  else if (number & OPERAND_FLAG)
	    /* NUMBER is a flag register.  */
	    id = 3;

	  number &= 0x7F;
	}
      else if (flags & OPERAND_SPECIAL)
	number = id;

      if (opers[i].X_op != O_register && opers[i].X_op != O_constant
	  && !(flags & OPERAND_NAME))
	{
	  /* Now create a fixup.  */
	  if (fixups->fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));

	  fixups->fix[fixups->fc].reloc =
	    get_reloc (d30v_operand_table + form->operands[i], op->reloc_flag);
	  fixups->fix[fixups->fc].size = 4;
	  fixups->fix[fixups->fc].exp = opers[i];
	  fixups->fix[fixups->fc].operand = form->operands[i];
	  if (fixups->fix[fixups->fc].reloc == BFD_RELOC_D30V_9_PCREL)
	    fixups->fix[fixups->fc].pcrel = RELOC_PCREL;
	  else
	    fixups->fix[fixups->fc].pcrel = op->reloc_flag;
	  (fixups->fc)++;
	}

      /* Truncate to the proper number of bits.  */
      if ((opers[i].X_op == O_constant) && check_range (number, bits, flags))
	as_bad (_("operand out of range: %ld"), number);
      if (bits < 31)
	number &= 0x7FFFFFFF >> (31 - bits);
      if (flags & OPERAND_SHIFT)
	number >>= 3;
      if (bits == 32)
	{
	  /* It's a LONG instruction.  */
	  insn |= ((number & 0xffffffff) >> 26);	/* Top 6 bits.  */
	  insn <<= 32;			/* Shift the first word over.  */
	  insn |= ((number & 0x03FC0000) << 2);		/* Next 8 bits.  */
	  insn |= number & 0x0003FFFF;			/* Bottom 18 bits.  */
	}
      else
	insn |= number << shift;
    }

  return insn;
}

static void
d30v_number_to_chars (char *buf,	/* Return 'nbytes' of chars here.  */
		      long long value,	/* The value of the bits.  */
		      int n)		/* Number of bytes in the output.  */
{
  while (n--)
    {
      buf[n] = value & 0xff;
      value >>= 8;
    }
}

/* Write out a long form instruction.  */

static void
write_long (struct d30v_insn *opcode ATTRIBUTE_UNUSED,
	    long long insn,
	    Fixups *fx)
{
  int i, where;
  char *f = frag_more (8);

  dwarf2_emit_insn (8);
  insn |= FM11;
  d30v_number_to_chars (f, insn, 8);

  for (i = 0; i < fx->fc; i++)
    {
      if (fx->fix[i].reloc)
	{
	  where = f - frag_now->fr_literal;
	  fix_new_exp (frag_now, where, fx->fix[i].size, &(fx->fix[i].exp),
		       fx->fix[i].pcrel, fx->fix[i].reloc);
	}
    }

  fx->fc = 0;
}

/* Write out a short form instruction by itself.  */

static void
write_1_short (struct d30v_insn *opcode,
	       long long insn,
	       Fixups *fx,
	       int use_sequential)
{
  char *f = frag_more (8);
  int i, where;

  dwarf2_emit_insn (8);
  if (warn_nops == NOP_ALL)
    as_warn (_("%s NOP inserted"), use_sequential ?
	     _("sequential") : _("parallel"));

  /* The other container needs to be NOP.  */
  if (use_sequential)
    {
      /* Use a sequential NOP rather than a parallel one,
	 as the current instruction is a FLAG_MUL32 type one
	 and the next instruction is a load.  */

      /* According to 4.3.1: for FM=01, sub-instructions performed
	 only by IU cannot be encoded in L-container.  */
      if (opcode->op->unit == IU)
	/* Right then left.  */
	insn |= FM10 | NOP_LEFT;
      else
	/* Left then right.  */
	insn = FM01 | (insn << 32) | NOP_RIGHT;
    }
  else
    {
      /* According to 4.3.1: for FM=00, sub-instructions performed
	 only by IU cannot be encoded in L-container.  */
      if (opcode->op->unit == IU)
	/* Right container.  */
	insn |= FM00 | NOP_LEFT;
      else
	/* Left container.  */
	insn = FM00 | (insn << 32) | NOP_RIGHT;
    }

  d30v_number_to_chars (f, insn, 8);

  for (i = 0; i < fx->fc; i++)
    {
      if (fx->fix[i].reloc)
	{
	  where = f - frag_now->fr_literal;
	  fix_new_exp (frag_now,
		       where,
		       fx->fix[i].size,
		       &(fx->fix[i].exp),
		       fx->fix[i].pcrel,
		       fx->fix[i].reloc);
	}
    }

  fx->fc = 0;
}

/* Check 2 instructions and determine if they can be safely
   executed in parallel.  Return 1 if they can be.  */

static int
parallel_ok (struct d30v_insn *op1,
	     unsigned long insn1,
	     struct d30v_insn *op2,
	     unsigned long insn2,
	     exec_type_enum exec_type)
{
  int i, j, shift, regno, bits, ecc;
  unsigned long flags, mask, flags_set1, flags_set2, flags_used1, flags_used2;
  unsigned long ins, mod_reg[2][3], used_reg[2][3], flag_reg[2];
  struct d30v_format *f;
  struct d30v_opcode *op;

  /* Section 4.3: Both instructions must not be IU or MU only.  */
  if ((op1->op->unit == IU && op2->op->unit == IU)
      || (op1->op->unit == MU && op2->op->unit == MU))
    return 0;

  /* First instruction must not be a jump to safely optimize, unless this
     is an explicit parallel operation.  */
  if (exec_type != EXEC_PARALLEL
      && (op1->op->flags_used & (FLAG_JMP | FLAG_JSR)))
    return 0;

  /* If one instruction is /TX or /XT and the other is /FX or /XF respectively,
     then it is safe to allow the two to be done as parallel ops, since only
     one will ever be executed at a time.  */
  if ((op1->ecc == ECC_TX && op2->ecc == ECC_FX)
      || (op1->ecc == ECC_FX && op2->ecc == ECC_TX)
      || (op1->ecc == ECC_XT && op2->ecc == ECC_XF)
      || (op1->ecc == ECC_XF && op2->ecc == ECC_XT))
    return 1;

  /* [0] r0-r31
     [1] r32-r63
     [2] a0, a1, flag registers.  */
  for (j = 0; j < 2; j++)
    {
      if (j == 0)
	{
	  f = op1->form;
	  op = op1->op;
	  ecc = op1->ecc;
	  ins = insn1;
	}
      else
	{
	  f = op2->form;
	  op = op2->op;
	  ecc = op2->ecc;
	  ins = insn2;
	}

      flag_reg[j] = 0;
      mod_reg[j][0] = mod_reg[j][1] = 0;
      used_reg[j][0] = used_reg[j][1] = 0;

      if (flag_explicitly_parallel)
	{
	  /* For human specified parallel instructions we have been asked
	     to ignore the possibility that both instructions could modify
	     bits in the PSW, so we initialise the mod & used arrays to 0.
	     We have been asked, however, to refuse to allow parallel
	     instructions which explicitly set the same flag register,
	     eg "cmpne f0,r1,0x10 || cmpeq f0, r5, 0x2", so further on we test
	     for the use of a flag register and set a bit in the mod or used
	     array appropriately.  */
	  mod_reg[j][2]  = 0;
	  used_reg[j][2] = 0;
	}
      else
	{
	  mod_reg[j][2] = (op->flags_set & FLAG_ALL);
	  used_reg[j][2] = (op->flags_used & FLAG_ALL);
	}

      /* BSR/JSR always sets R62.  */
      if (op->flags_used & FLAG_JSR)
	mod_reg[j][1] = (1L << (62 - 32));

      /* Conditional execution affects the flags_used.  */
      switch (ecc)
	{
	case ECC_TX:
	case ECC_FX:
	  used_reg[j][2] |= flag_reg[j] = FLAG_0;
	  break;

	case ECC_XT:
	case ECC_XF:
	  used_reg[j][2] |= flag_reg[j] = FLAG_1;
	  break;

	case ECC_TT:
	case ECC_TF:
	  used_reg[j][2] |= flag_reg[j] = (FLAG_0 | FLAG_1);
	  break;
	}

      for (i = 0; f->operands[i]; i++)
	{
	  flags = d30v_operand_table[f->operands[i]].flags;
	  shift = 12 - d30v_operand_table[f->operands[i]].position;
	  bits = d30v_operand_table[f->operands[i]].bits;
	  if (bits == 32)
	    mask = 0xffffffff;
	  else
	    mask = 0x7FFFFFFF >> (31 - bits);

	  if ((flags & OPERAND_PLUS) || (flags & OPERAND_MINUS))
	    {
	      /* This is a post-increment or post-decrement.
		 The previous register needs to be marked as modified.  */
	      shift = 12 - d30v_operand_table[f->operands[i - 1]].position;
	      regno = (ins >> shift) & 0x3f;
	      if (regno >= 32)
		mod_reg[j][1] |= 1L << (regno - 32);
	      else
		mod_reg[j][0] |= 1L << regno;
	    }
	  else if (flags & OPERAND_REG)
	    {
	      regno = (ins >> shift) & mask;
	      /* The memory write functions don't have a destination
                 register.  */
	      if ((flags & OPERAND_DEST) && !(op->flags_set & FLAG_MEM))
		{
		  /* MODIFIED registers and flags.  */
		  if (flags & OPERAND_ACC)
		    {
		      if (regno == 0)
			mod_reg[j][2] |= FLAG_A0;
		      else if (regno == 1)
			mod_reg[j][2] |= FLAG_A1;
		      else
			abort ();
		    }
		  else if (flags & OPERAND_FLAG)
		    mod_reg[j][2] |= 1L << regno;
		  else if (!(flags & OPERAND_CONTROL))
		    {
		      int r, z;

		      /* Need to check if there are two destination
			 registers, for example ld2w.  */
		      if (flags & OPERAND_2REG)
			z = 1;
		      else
			z = 0;

		      for (r = regno; r <= regno + z; r++)
			{
			  if (r >= 32)
			    mod_reg[j][1] |= 1L << (r - 32);
			  else
			    mod_reg[j][0] |= 1L << r;
			}
		    }
		}
	      else
		{
		  /* USED, but not modified registers and flags.  */
		  if (flags & OPERAND_ACC)
		    {
		      if (regno == 0)
			used_reg[j][2] |= FLAG_A0;
		      else if (regno == 1)
			used_reg[j][2] |= FLAG_A1;
		      else
			abort ();
		    }
		  else if (flags & OPERAND_FLAG)
		    used_reg[j][2] |= 1L << regno;
		  else if (!(flags & OPERAND_CONTROL))
		    {
		      int r, z;

		      /* Need to check if there are two source
			 registers, for example st2w.  */
		      if (flags & OPERAND_2REG)
			z = 1;
		      else
			z = 0;

		      for (r = regno; r <= regno + z; r++)
			{
			  if (r >= 32)
			    used_reg[j][1] |= 1L << (r - 32);
			  else
			    used_reg[j][0] |= 1L << r;
			}
		    }
		}
	    }
	}
    }

  flags_set1 = op1->op->flags_set;
  flags_set2 = op2->op->flags_set;
  flags_used1 = op1->op->flags_used;
  flags_used2 = op2->op->flags_used;

  /* Check for illegal combinations with ADDppp/SUBppp.  */
  if (((flags_set1 & FLAG_NOT_WITH_ADDSUBppp) != 0
       && (flags_used2 & FLAG_ADDSUBppp) != 0)
      || ((flags_set2 & FLAG_NOT_WITH_ADDSUBppp) != 0
	  && (flags_used1 & FLAG_ADDSUBppp) != 0))
    return 0;

  /* Load instruction combined with half-word multiply is illegal.  */
  if (((flags_used1 & FLAG_MEM) != 0 && (flags_used2 & FLAG_MUL16))
      || ((flags_used2 & FLAG_MEM) != 0 && (flags_used1 & FLAG_MUL16)))
    return 0;

  /* Specifically allow add || add by removing carry, overflow bits dependency.
     This is safe, even if an addc follows since the IU takes the argument in
     the right container, and it writes its results last.
     However, don't paralellize add followed by addc or sub followed by
     subb.  */
  if (mod_reg[0][2] == FLAG_CVVA && mod_reg[1][2] == FLAG_CVVA
      && (used_reg[0][2] & ~flag_reg[0]) == 0
      && (used_reg[1][2] & ~flag_reg[1]) == 0
      && op1->op->unit == EITHER && op2->op->unit == EITHER)
    {
      mod_reg[0][2] = mod_reg[1][2] = 0;
    }

  for (j = 0; j < 3; j++)
    {
      /* If the second instruction depends on the first, we obviously
	 cannot parallelize.  Note, the mod flag implies use, so
	 check that as well.  */
      /* If flag_explicitly_parallel is set, then the case of the
	 second instruction using a register the first instruction
	 modifies is assumed to be okay; we trust the human.  We
	 don't trust the human if both instructions modify the same
	 register but we do trust the human if they modify the same
	 flags.  */
      /* We have now been requested not to trust the human if the
	 instructions modify the same flag registers either.  */
      if (flag_explicitly_parallel)
	{
	  if ((mod_reg[0][j] & mod_reg[1][j]) != 0)
	    return 0;
	}
      else
	if ((mod_reg[0][j] & (mod_reg[1][j] | used_reg[1][j])) != 0)
	  return 0;
    }

  return 1;
}

/* Write out a short form instruction if possible.
   Return number of instructions not written out.  */

static int
write_2_short (struct d30v_insn *opcode1,
	       long long insn1,
	       struct d30v_insn *opcode2,
	       long long insn2,
	       exec_type_enum exec_type,
	       Fixups *fx)
{
  long long insn = NOP2;
  char *f;
  int i, j, where;

  if (exec_type == EXEC_SEQ
      && (opcode1->op->flags_used & (FLAG_JMP | FLAG_JSR))
      && ((opcode1->op->flags_used & FLAG_DELAY) == 0)
      && ((opcode1->ecc == ECC_AL) || ! Optimizing))
    {
      /* Unconditional, non-delayed branches kill instructions in
	 the right bin.  Conditional branches don't always but if
	 we are not optimizing, then we have been asked to produce
	 an error about such constructs.  For the purposes of this
	 test, subroutine calls are considered to be branches.  */
      write_1_short (opcode1, insn1, fx->next, FALSE);
      return 1;
    }

  /* Note: we do not have to worry about subroutine calls occurring
     in the right hand container.  The return address is always
     aligned to the next 64 bit boundary, be that 64 or 32 bit away.  */
  switch (exec_type)
    {
    case EXEC_UNKNOWN:	/* Order not specified.  */
      if (Optimizing
	  && parallel_ok (opcode1, insn1, opcode2, insn2, exec_type)
	  && ! (   (opcode1->op->unit == EITHER_BUT_PREFER_MU
		 || opcode1->op->unit == MU)
		&&
		(   opcode2->op->unit == EITHER_BUT_PREFER_MU
		 || opcode2->op->unit == MU)))
	{
	  /* Parallel.  */
	  exec_type = EXEC_PARALLEL;

	  if (opcode1->op->unit == IU
	      || opcode2->op->unit == MU
	      || opcode2->op->unit == EITHER_BUT_PREFER_MU)
	    insn = FM00 | (insn2 << 32) | insn1;
	  else
	    {
	      insn = FM00 | (insn1 << 32) | insn2;
	      fx = fx->next;
	    }
	}
      else if ((opcode1->op->flags_used & (FLAG_JMP | FLAG_JSR)
		&& ((opcode1->op->flags_used & FLAG_DELAY) == 0))
	       || opcode1->op->flags_used & FLAG_RP)
	{
	  /* We must emit (non-delayed) branch type instructions
	     on their own with nothing in the right container.  */
	  /* We must treat repeat instructions likewise, since the
	     following instruction has to be separate from the repeat
	     in order to be repeated.  */
	  write_1_short (opcode1, insn1, fx->next, FALSE);
	  return 1;
	}
      else if (prev_left_kills_right_p)
	{
	  /* The left instruction kils the right slot, so we
	     must leave it empty.  */
	  write_1_short (opcode1, insn1, fx->next, FALSE);
	  return 1;
	}
      else if (opcode1->op->unit == IU)
	{
	  if (opcode2->op->unit == EITHER_BUT_PREFER_MU)
	    {
	      /* Case 103810 is a request from Mitsubishi that opcodes
		 with EITHER_BUT_PREFER_MU should not be executed in
		 reverse sequential order.  */
	      write_1_short (opcode1, insn1, fx->next, FALSE);
	      return 1;
	    }

	  /* Reverse sequential.  */
	  insn = FM10 | (insn2 << 32) | insn1;
	  exec_type = EXEC_REVSEQ;
	}
      else
	{
	  /* Sequential.  */
	  insn = FM01 | (insn1 << 32) | insn2;
	  fx = fx->next;
	  exec_type = EXEC_SEQ;
	}
      break;

    case EXEC_PARALLEL:	/* Parallel.  */
      flag_explicitly_parallel = flag_xp_state;
      if (! parallel_ok (opcode1, insn1, opcode2, insn2, exec_type))
	as_bad (_("Instructions may not be executed in parallel"));
      else if (opcode1->op->unit == IU)
	{
	  if (opcode2->op->unit == IU)
	    as_bad (_("Two IU instructions may not be executed in parallel"));
	  as_warn (_("Swapping instruction order"));
	  insn = FM00 | (insn2 << 32) | insn1;
	}
      else if (opcode2->op->unit == MU)
	{
	  if (opcode1->op->unit == MU)
	    as_bad (_("Two MU instructions may not be executed in parallel"));
	  else if (opcode1->op->unit == EITHER_BUT_PREFER_MU)
	    as_warn (_("Executing %s in IU may not work"), opcode1->op->name);
	  as_warn (_("Swapping instruction order"));
	  insn = FM00 | (insn2 << 32) | insn1;
	}
      else
	{
	  if (opcode2->op->unit == EITHER_BUT_PREFER_MU)
	    as_warn (_("Executing %s in IU may not work in parallel execution"),
		     opcode2->op->name);

	  insn = FM00 | (insn1 << 32) | insn2;
	  fx = fx->next;
	}
      flag_explicitly_parallel = 0;
      break;

    case EXEC_SEQ:	/* Sequential.  */
      if (opcode1->op->unit == IU)
	as_bad (_("IU instruction may not be in the left container"));
      if (prev_left_kills_right_p)
	as_bad (_("special left instruction `%s' kills instruction "
		  "`%s' in right container"),
		opcode1->op->name, opcode2->op->name);
      insn = FM01 | (insn1 << 32) | insn2;
      fx = fx->next;
      break;

    case EXEC_REVSEQ:	/* Reverse sequential.  */
      if (opcode2->op->unit == MU)
	as_bad (_("MU instruction may not be in the right container"));
      if (opcode1->op->unit == EITHER_BUT_PREFER_MU)
	as_warn (_("Executing %s in reverse serial with %s may not work"),
		 opcode1->op->name, opcode2->op->name);
      else if (opcode2->op->unit == EITHER_BUT_PREFER_MU)
	as_warn (_("Executing %s in IU in reverse serial may not work"),
		 opcode2->op->name);
      insn = FM10 | (insn1 << 32) | insn2;
      fx = fx->next;
      break;

    default:
      as_fatal (_("unknown execution type passed to write_2_short()"));
    }

  f = frag_more (8);
  dwarf2_emit_insn (8);
  d30v_number_to_chars (f, insn, 8);

  /* If the previous instruction was a 32-bit multiply but it is put into a
     parallel container, mark the current instruction as being a 32-bit
     multiply.  */
  if (prev_mul32_p && exec_type == EXEC_PARALLEL)
    cur_mul32_p = 1;

  for (j = 0; j < 2; j++)
    {
      for (i = 0; i < fx->fc; i++)
	{
	  if (fx->fix[i].reloc)
	    {
	      where = (f - frag_now->fr_literal) + 4 * j;

	      fix_new_exp (frag_now,
			   where,
			   fx->fix[i].size,
			   &(fx->fix[i].exp),
			   fx->fix[i].pcrel,
			   fx->fix[i].reloc);
	    }
	}

      fx->fc = 0;
      fx = fx->next;
    }

  return 0;
}

/* Get a pointer to an entry in the format table.
   It must look at all formats for an opcode and use the operands
   to choose the correct one.  Return NULL on error.  */

static struct d30v_format *
find_format (struct d30v_opcode *opcode,
	     expressionS myops[],
	     int fsize,
	     int cmp_hack)
{
  int match, opcode_index, i = 0, j, k;
  struct d30v_format *fm;

  if (opcode == NULL)
    return NULL;

  /* Get all the operands and save them as expressions.  */
  get_operands (myops, cmp_hack);

  while ((opcode_index = opcode->format[i++]) != 0)
    {
      if (fsize == FORCE_SHORT && opcode_index >= LONG)
	continue;

      if (fsize == FORCE_LONG && opcode_index < LONG)
	continue;

      fm = (struct d30v_format *) &d30v_format_table[opcode_index];
      k = opcode_index;
      while (fm->form == opcode_index)
	{
	  match = 1;
	  /* Now check the operands for compatibility.  */
	  for (j = 0; match && fm->operands[j]; j++)
	    {
	      int flags = d30v_operand_table[fm->operands[j]].flags;
	      int bits = d30v_operand_table[fm->operands[j]].bits;
	      int X_op = myops[j].X_op;
	      int num = myops[j].X_add_number;

	      if (flags & OPERAND_SPECIAL)
		break;
	      else if (X_op == O_illegal)
		match = 0;
	      else if (flags & OPERAND_REG)
		{
		  if (X_op != O_register
		      || ((flags & OPERAND_ACC) && !(num & OPERAND_ACC))
		      || (!(flags & OPERAND_ACC) && (num & OPERAND_ACC))
		      || ((flags & OPERAND_FLAG) && !(num & OPERAND_FLAG))
		      || (!(flags & (OPERAND_FLAG | OPERAND_CONTROL)) && (num & OPERAND_FLAG))
		      || ((flags & OPERAND_CONTROL)
			  && !(num & (OPERAND_CONTROL | OPERAND_FLAG))))
		    match = 0;
		}
	      else if (((flags & OPERAND_MINUS)
			&& (X_op != O_absent || num != OPERAND_MINUS))
		       || ((flags & OPERAND_PLUS)
			   && (X_op != O_absent || num != OPERAND_PLUS))
		       || ((flags & OPERAND_ATMINUS)
			   && (X_op != O_absent || num != OPERAND_ATMINUS))
		       || ((flags & OPERAND_ATPAR)
			   && (X_op != O_absent || num != OPERAND_ATPAR))
		       || ((flags & OPERAND_ATSIGN)
			   && (X_op != O_absent || num != OPERAND_ATSIGN)))
		match = 0;
	      else if (flags & OPERAND_NUM)
		{
		  /* A number can be a constant or symbol expression.  */

		  /* If we have found a register name, but that name
		     also matches a symbol, then re-parse the name as
		     an expression.  */
		  if (X_op == O_register
		      && symbol_find ((char *) myops[j].X_op_symbol))
		    {
		      input_line_pointer = (char *) myops[j].X_op_symbol;
		      expression (&myops[j]);
		    }

		  /* Turn an expression into a symbol for later resolution.  */
		  if (X_op != O_absent && X_op != O_constant
		      && X_op != O_symbol && X_op != O_register
		      && X_op != O_big)
		    {
		      symbolS *sym = make_expr_symbol (&myops[j]);
		      myops[j].X_op = X_op = O_symbol;
		      myops[j].X_add_symbol = sym;
		      myops[j].X_add_number = num = 0;
		    }

		  if (fm->form >= LONG)
		    {
		      /* If we're testing for a LONG format, either fits.  */
		      if (X_op != O_constant && X_op != O_symbol)
			match = 0;
		    }
		  else if (fm->form < LONG
			   && ((fsize == FORCE_SHORT && X_op == O_symbol)
			       || (fm->form == SHORT_D2 && j == 0)))
		    match = 1;

		  /* This is the tricky part.  Will the constant or symbol
		     fit into the space in the current format?  */
		  else if (X_op == O_constant)
		    {
		      if (check_range (num, bits, flags))
			match = 0;
		    }
		  else if (X_op == O_symbol
			   && S_IS_DEFINED (myops[j].X_add_symbol)
			   && S_GET_SEGMENT (myops[j].X_add_symbol) == now_seg
			   && opcode->reloc_flag == RELOC_PCREL)
		    {
		      /* If the symbol is defined, see if the value will fit
			 into the form we're considering.  */
		      fragS *f;
		      long value;

		      /* Calculate the current address by running through the
			 previous frags and adding our current offset.  */
		      value = 0;
		      for (f = frchain_now->frch_root; f; f = f->fr_next)
			value += f->fr_fix + f->fr_offset;
		      value = (S_GET_VALUE (myops[j].X_add_symbol) - value
			       - (obstack_next_free (&frchain_now->frch_obstack)
				  - frag_now->fr_literal));
		      if (check_range (value, bits, flags))
			match = 0;
		    }
		  else
		    match = 0;
		}
	    }
	  /* We're only done if the operands matched so far AND there
	     are no more to check.  */
	  if (match && myops[j].X_op == 0)
	    {
	      /* Final check - issue a warning if an odd numbered register
		 is used as the first register in an instruction that reads
		 or writes 2 registers.  */

	      for (j = 0; fm->operands[j]; j++)
		if (myops[j].X_op == O_register
		    && (myops[j].X_add_number & 1)
		    && (d30v_operand_table[fm->operands[j]].flags & OPERAND_2REG))
		  as_warn (_("Odd numbered register used as target of multi-register instruction"));

	      return fm;
	    }
	  fm = (struct d30v_format *) &d30v_format_table[++k];
	}
    }
  return NULL;
}

/* Assemble a single instruction and return an opcode.
   Return -1 (an invalid opcode) on error.  */

#define NAME_BUF_LEN	20

static long long
do_assemble (char *str,
	     struct d30v_insn *opcode,
	     int shortp,
	     int is_parallel)
{
  char *op_start;
  char *save;
  char *op_end;
  char           name[NAME_BUF_LEN];
  int            cmp_hack;
  int            nlen = 0;
  int            fsize = (shortp ? FORCE_SHORT : 0);
  expressionS    myops[6];
  long long      insn;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the opcode end.  */
  for (op_start = op_end = str;
       *op_end
       && nlen < (NAME_BUF_LEN - 1)
       && *op_end != '/'
       && !is_end_of_line[(unsigned char) *op_end] && *op_end != ' ';
       op_end++)
    {
      name[nlen] = TOLOWER (op_start[nlen]);
      nlen++;
    }

  if (nlen == 0)
    return -1;

  name[nlen] = 0;

  /* If there is an execution condition code, handle it.  */
  if (*op_end == '/')
    {
      int i = 0;
      while ((i < ECC_MAX) && strncasecmp (d30v_ecc_names[i], op_end + 1, 2))
	i++;

      if (i == ECC_MAX)
	{
	  char tmp[4];
	  strncpy (tmp, op_end + 1, 2);
	  tmp[2] = 0;
	  as_bad (_("unknown condition code: %s"), tmp);
	  return -1;
	}
      opcode->ecc = i;
      op_end += 3;
    }
  else
    opcode->ecc = ECC_AL;

  /* CMP and CMPU change their name based on condition codes.  */
  if (!strncmp (name, "cmp", 3))
    {
      int p, i;
      char **d30v_str = (char **) d30v_cc_names;

      if (name[3] == 'u')
	p = 4;
      else
	p = 3;

      for (i = 1; *d30v_str && strncmp (*d30v_str, &name[p], 2); i++, d30v_str++)
	;

      /* cmpu only supports some condition codes.  */
      if (p == 4)
	{
	  if (i < 3 || i > 6)
	    {
	      name[p + 2] = 0;
	      as_bad (_("cmpu doesn't support condition code %s"), &name[p]);
	    }
	}

      if (!*d30v_str)
	{
	  name[p + 2] = 0;
	  as_bad (_("unknown condition code: %s"), &name[p]);
	}

      cmp_hack = i;
      name[p] = 0;
    }
  else
    cmp_hack = 0;

  /* Need to look for .s or .l.  */
  if (name[nlen - 2] == '.')
    {
      switch (name[nlen - 1])
	{
	case 's':
	  fsize = FORCE_SHORT;
	  break;
	case 'l':
	  fsize = FORCE_LONG;
	  break;
	}
      name[nlen - 2] = 0;
    }

  /* Find the first opcode with the proper name.  */
  opcode->op = (struct d30v_opcode *) hash_find (d30v_hash, name);
  if (opcode->op == NULL)
    {
      as_bad (_("unknown opcode: %s"), name);
      return -1;
    }

  save = input_line_pointer;
  input_line_pointer = op_end;
  while (!(opcode->form = find_format (opcode->op, myops, fsize, cmp_hack)))
    {
      opcode->op++;
      if (opcode->op->name == NULL || strcmp (opcode->op->name, name))
	{
	  as_bad (_("operands for opcode `%s' do not match any valid format"),
		  name);
	  return -1;
	}
    }
  input_line_pointer = save;

  insn = build_insn (opcode, myops);

  /* Propagate multiply status.  */
  if (insn != -1)
    {
      if (is_parallel && prev_mul32_p)
	cur_mul32_p = 1;
      else
	{
	  prev_mul32_p = cur_mul32_p;
	  cur_mul32_p  = (opcode->op->flags_used & FLAG_MUL32) != 0;
	}
    }

  /* Propagate left_kills_right status.  */
  if (insn != -1)
    {
      prev_left_kills_right_p = cur_left_kills_right_p;

      if (opcode->op->flags_set & FLAG_LKR)
	{
	  cur_left_kills_right_p = 1;

	  if (strcmp (opcode->op->name, "mvtsys") == 0)
	    {
	      /* Left kills right for only mvtsys only for
                 PSW/PSWH/PSWL/flags target.  */
	      if ((myops[0].X_op == O_register) &&
		  ((myops[0].X_add_number == OPERAND_CONTROL) || /* psw */
		   (myops[0].X_add_number == OPERAND_CONTROL+MAX_CONTROL_REG+2) || /* pswh */
		   (myops[0].X_add_number == OPERAND_CONTROL+MAX_CONTROL_REG+1) || /* pswl */
		   (myops[0].X_add_number == OPERAND_FLAG+0) || /* f0 */
		   (myops[0].X_add_number == OPERAND_FLAG+1) || /* f1 */
		   (myops[0].X_add_number == OPERAND_FLAG+2) || /* f2 */
		   (myops[0].X_add_number == OPERAND_FLAG+3) || /* f3 */
		   (myops[0].X_add_number == OPERAND_FLAG+4) || /* f4 */
		   (myops[0].X_add_number == OPERAND_FLAG+5) || /* f5 */
		   (myops[0].X_add_number == OPERAND_FLAG+6) || /* f6 */
		   (myops[0].X_add_number == OPERAND_FLAG+7))) /* f7 */
		{
		  cur_left_kills_right_p = 1;
		}
	      else
		{
		  /* Other mvtsys target registers don't kill right
                     instruction.  */
		  cur_left_kills_right_p = 0;
		}
	    } /* mvtsys */
	}
      else
	cur_left_kills_right_p = 0;
    }

  return insn;
}

/* Called internally to handle all alignment needs.  This takes care
   of eliding calls to frag_align if'n the cached current alignment
   says we've already got it, as well as taking care of the auto-aligning
   labels wrt code.  */

static void
d30v_align (int n, char *pfill, symbolS *label)
{
  /* The front end is prone to changing segments out from under us
     temporarily when -g is in effect.  */
  int switched_seg_p = (d30v_current_align_seg != now_seg);

  /* Do not assume that if 'd30v_current_align >= n' and
     '! switched_seg_p' that it is safe to avoid performing
     this alignment request.  The alignment of the current frag
     can be changed under our feet, for example by a .ascii
     directive in the source code.  cf testsuite/gas/d30v/reloc.s  */
  d30v_cleanup (FALSE);

  if (pfill == NULL)
    {
      if (n > 2
	  && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
	{
	  static char const nop[4] = { 0x00, 0xf0, 0x00, 0x00 };

	  /* First, make sure we're on a four-byte boundary, in case
	     someone has been putting .byte values the text section.  */
	  if (d30v_current_align < 2 || switched_seg_p)
	    frag_align (2, 0, 0);
	  frag_align_pattern (n, nop, sizeof nop, 0);
	}
      else
	frag_align (n, 0, 0);
    }
  else
    frag_align (n, *pfill, 0);

  if (!switched_seg_p)
    d30v_current_align = n;

  if (label != NULL)
    {
      symbolS     *sym;
      int          label_seen = FALSE;
      struct frag *old_frag;
      valueT       old_value;
      valueT       new_value;

      gas_assert (S_GET_SEGMENT (label) == now_seg);

      old_frag  = symbol_get_frag (label);
      old_value = S_GET_VALUE (label);
      new_value = (valueT) frag_now_fix ();

      /* It is possible to have more than one label at a particular
	 address, especially if debugging is enabled, so we must
	 take care to adjust all the labels at this address in this
	 fragment.  To save time we search from the end of the symbol
	 list, backwards, since the symbols we are interested in are
	 almost certainly the ones that were most recently added.
	 Also to save time we stop searching once we have seen at least
	 one matching label, and we encounter a label that is no longer
	 in the target fragment.  Note, this search is guaranteed to
	 find at least one match when sym == label, so no special case
	 code is necessary.  */
      for (sym = symbol_lastP; sym != NULL; sym = symbol_previous (sym))
	{
	  if (symbol_get_frag (sym) == old_frag
	      && S_GET_VALUE (sym) == old_value)
	    {
	      label_seen = TRUE;
	      symbol_set_frag (sym, frag_now);
	      S_SET_VALUE (sym, new_value);
	    }
	  else if (label_seen && symbol_get_frag (sym) != old_frag)
	    break;
	}
    }

  record_alignment (now_seg, n);
}

/* This is the main entry point for the machine-dependent assembler.
   STR points to a machine-dependent instruction.  This function is
   supposed to emit the frags/bytes it assembles to.  For the D30V, it
   mostly handles the special VLIW parsing and packing and leaves the
   difficult stuff to do_assemble ().  */

static long long prev_insn = -1;
static struct d30v_insn prev_opcode;
static subsegT prev_subseg;
static segT prev_seg = 0;

void
md_assemble (char *str)
{
  struct d30v_insn opcode;
  long long insn;
  /* Execution type; parallel, etc.  */
  exec_type_enum extype = EXEC_UNKNOWN;
  /* Saved extype.  Used for multiline instructions.  */
  static exec_type_enum etype = EXEC_UNKNOWN;
  char *str2;

  if ((prev_insn != -1) && prev_seg
      && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))
    d30v_cleanup (FALSE);

  if (d30v_current_align < 3)
    d30v_align (3, NULL, d30v_last_label);
  else if (d30v_current_align > 3)
    d30v_current_align = 3;
  d30v_last_label = NULL;

  flag_explicitly_parallel = 0;
  flag_xp_state = 0;
  if (etype == EXEC_UNKNOWN)
    {
      /* Look for the special multiple instruction separators.  */
      str2 = strstr (str, "||");
      if (str2)
	{
	  extype = EXEC_PARALLEL;
	  flag_xp_state = 1;
	}
      else
	{
	  str2 = strstr (str, "->");
	  if (str2)
	    extype = EXEC_SEQ;
	  else
	    {
	      str2 = strstr (str, "<-");
	      if (str2)
		extype = EXEC_REVSEQ;
	    }
	}

      /* STR2 points to the separator, if one.  */
      if (str2)
	{
	  *str2 = 0;

	  /* If two instructions are present and we already have one saved,
	     then first write it out.  */
	  d30v_cleanup (FALSE);

	  /* Assemble first instruction and save it.  */
	  prev_insn = do_assemble (str, &prev_opcode, 1, 0);
	  if (prev_insn == -1)
	    as_bad (_("Cannot assemble instruction"));
	  if (prev_opcode.form != NULL && prev_opcode.form->form >= LONG)
	    as_bad (_("First opcode is long.  Unable to mix instructions as specified."));
	  fixups = fixups->next;
	  str = str2 + 2;
	  prev_seg = now_seg;
	  prev_subseg = now_subseg;
	}
    }

  insn = do_assemble (str, &opcode,
		      (extype != EXEC_UNKNOWN || etype != EXEC_UNKNOWN),
		      extype == EXEC_PARALLEL);
  if (insn == -1)
    {
      if (extype != EXEC_UNKNOWN)
	etype = extype;
      as_bad (_("Cannot assemble instruction"));
      return;
    }

  if (etype != EXEC_UNKNOWN)
    {
      extype = etype;
      etype = EXEC_UNKNOWN;
    }

  /* Word multiply instructions must not be followed by either a load or a
     16-bit multiply instruction in the next cycle.  */
  if (   (extype != EXEC_REVSEQ)
      && prev_mul32_p
      && (opcode.op->flags_used & (FLAG_MEM | FLAG_MUL16)))
    {
      /* However, load and multiply should able to be combined in a parallel
	 operation, so check for that first.  */
      if (prev_insn != -1
	  && (opcode.op->flags_used & FLAG_MEM)
	  && opcode.form->form < LONG
	  && (extype == EXEC_PARALLEL || (Optimizing && extype == EXEC_UNKNOWN))
	  && parallel_ok (&prev_opcode, (long) prev_insn,
			  &opcode, (long) insn, extype)
	  && write_2_short (&prev_opcode, (long) prev_insn,
			    &opcode, (long) insn, extype, fixups) == 0)
	{
	  /* No instructions saved.  */
	  prev_insn = -1;
	  return;
	}
      else
	{
	  /* Can't parallelize, flush previous instruction and emit a
	     word of NOPS, unless the previous instruction is a NOP,
	     in which case just flush it, as this will generate a word
	     of NOPs for us.  */

	  if (prev_insn != -1 && (strcmp (prev_opcode.op->name, "nop") == 0))
	    d30v_cleanup (FALSE);
	  else
	    {
	      char *f;

	      if (prev_insn != -1)
		d30v_cleanup (TRUE);
	      else
		{
		  f = frag_more (8);
		  dwarf2_emit_insn (8);
		  d30v_number_to_chars (f, NOP2, 8);

		  if (warn_nops == NOP_ALL || warn_nops == NOP_MULTIPLY)
		    {
		      if (opcode.op->flags_used & FLAG_MEM)
			as_warn (_("word of NOPs added between word multiply and load"));
		      else
			as_warn (_("word of NOPs added between word multiply and 16-bit multiply"));
		    }
		}
	    }

	  extype = EXEC_UNKNOWN;
	}
    }
  else if (   (extype == EXEC_REVSEQ)
	   && cur_mul32_p
	   && (prev_opcode.op->flags_used & (FLAG_MEM | FLAG_MUL16)))
    {
      /* Can't parallelize, flush current instruction and add a
         sequential NOP.  */
      write_1_short (&opcode, (long) insn, fixups->next->next, TRUE);

      /* Make the previous instruction the current one.  */
      extype = EXEC_UNKNOWN;
      insn = prev_insn;
      now_seg = prev_seg;
      now_subseg = prev_subseg;
      prev_insn = -1;
      cur_mul32_p = prev_mul32_p;
      prev_mul32_p = 0;
      memcpy (&opcode, &prev_opcode, sizeof (prev_opcode));
    }

  /* If this is a long instruction, write it and any previous short
     instruction.  */
  if (opcode.form->form >= LONG)
    {
      if (extype != EXEC_UNKNOWN)
	as_bad (_("Instruction uses long version, so it cannot be mixed as specified"));
      d30v_cleanup (FALSE);
      write_long (&opcode, insn, fixups);
      prev_insn = -1;
    }
  else if ((prev_insn != -1)
	   && (write_2_short
	       (&prev_opcode, (long) prev_insn, &opcode,
		(long) insn, extype, fixups) == 0))
    {
      /* No instructions saved.  */
      prev_insn = -1;
    }
  else
    {
      if (extype != EXEC_UNKNOWN)
	as_bad (_("Unable to mix instructions as specified"));

      /* Save off last instruction so it may be packed on next pass.  */
      memcpy (&prev_opcode, &opcode, sizeof (prev_opcode));
      prev_insn = insn;
      prev_seg = now_seg;
      prev_subseg = now_subseg;
      fixups = fixups->next;
      prev_mul32_p = cur_mul32_p;
    }
}

/* If while processing a fixup, a reloc really needs to be created,
   then it is done here.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;
  reloc = xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }

  reloc->addend = 0;
  return reloc;
}

int
md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
			       asection *seg ATTRIBUTE_UNUSED)
{
  abort ();
  return 0;
}

long
md_pcrel_from_section (fixS *fixp, segT sec)
{
  if (fixp->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
    return 0;
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

/* Called after the assembler has finished parsing the input file or
   after a label is defined.  Because the D30V assembler sometimes
   saves short instructions to see if it can package them with the
   next instruction, there may be a short instruction that still needs
   written.  */

int
d30v_cleanup (int use_sequential)
{
  segT seg;
  subsegT subseg;

  if (prev_insn != -1)
    {
      seg = now_seg;
      subseg = now_subseg;
      subseg_set (prev_seg, prev_subseg);
      write_1_short (&prev_opcode, (long) prev_insn, fixups->next,
		     use_sequential);
      subseg_set (seg, subseg);
      prev_insn = -1;
      if (use_sequential)
	prev_mul32_p = FALSE;
    }

  return 1;
}

/* This function is called at the start of every line.  It checks to
   see if the first character is a '.', which indicates the start of a
   pseudo-op.  If it is, then write out any unwritten instructions.  */

void
d30v_start_line (void)
{
  char *c = input_line_pointer;

  while (ISSPACE (*c))
    c++;

  if (*c == '.')
    d30v_cleanup (FALSE);
}

static void
check_size (long value, int bits, char *file, int line)
{
  int tmp, max;

  if (value < 0)
    tmp = ~value;
  else
    tmp = value;

  max = (1 << (bits - 1)) - 1;

  if (tmp > max)
    as_bad_where (file, line, _("value too large to fit in %d bits"), bits);
}

/* d30v_frob_label() is called when after a label is recognized.  */

void
d30v_frob_label (symbolS *lab)
{
  /* Emit any pending instructions.  */
  d30v_cleanup (FALSE);

  /* Update the label's address with the current output pointer.  */
  symbol_set_frag (lab, frag_now);
  S_SET_VALUE (lab, (valueT) frag_now_fix ());

  /* Record this label for future adjustment after we find out what
     kind of data it references, and the required alignment therewith.  */
  d30v_last_label = lab;

  dwarf2_emit_label (lab);
}

/* Hook into cons for capturing alignment changes.  */

void
d30v_cons_align (int size)
{
  int log_size;

  /* Don't specially align anything in debug sections.  */
  if ((now_seg->flags & SEC_ALLOC) == 0
      || strcmp (now_seg->name, ".eh_frame") == 0)
    return;

  log_size = 0;
  while ((size >>= 1) != 0)
    ++log_size;

  if (d30v_current_align < log_size)
    d30v_align (log_size, (char *) NULL, NULL);
  else if (d30v_current_align > log_size)
    d30v_current_align = log_size;
  d30v_last_label = NULL;
}

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *where;
  unsigned long insn, insn2;
  long value = *valP;

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  /* We don't support subtracting a symbol.  */
  if (fixP->fx_subsy != (symbolS *) NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));

  /* Fetch the instruction, insert the fully resolved operand
     value, and stuff the instruction back again.  */
  where = fixP->fx_frag->fr_literal + fixP->fx_where;
  insn = bfd_getb32 ((unsigned char *) where);

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_8:  /* Check for a bad .byte directive.  */
      if (fixP->fx_addsy != NULL)
	as_bad (_("line %d: unable to place address of symbol '%s' into a byte"),
		fixP->fx_line, S_GET_NAME (fixP->fx_addsy));
      else if (((unsigned)value) > 0xff)
	as_bad (_("line %d: unable to place value %lx into a byte"),
		fixP->fx_line, value);
      else
	*(unsigned char *) where = value;
      break;

    case BFD_RELOC_16:  /* Check for a bad .short directive.  */
      if (fixP->fx_addsy != NULL)
	as_bad (_("line %d: unable to place address of symbol '%s' into a short"),
		fixP->fx_line, S_GET_NAME (fixP->fx_addsy));
      else if (((unsigned)value) > 0xffff)
	as_bad (_("line %d: unable to place value %lx into a short"),
		fixP->fx_line, value);
      else
	bfd_putb16 ((bfd_vma) value, (unsigned char *) where);
      break;

    case BFD_RELOC_64:  /* Check for a bad .quad directive.  */
      if (fixP->fx_addsy != NULL)
	as_bad (_("line %d: unable to place address of symbol '%s' into a quad"),
		fixP->fx_line, S_GET_NAME (fixP->fx_addsy));
      else
	{
	  bfd_putb32 ((bfd_vma) value, (unsigned char *) where);
	  bfd_putb32 (0, ((unsigned char *) where) + 4);
	}
      break;

    case BFD_RELOC_D30V_6:
      check_size (value, 6, fixP->fx_file, fixP->fx_line);
      insn |= value & 0x3F;
      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      break;

    case BFD_RELOC_D30V_9_PCREL:
      if (fixP->fx_where & 0x7)
	{
	  if (fixP->fx_done)
	    value += 4;
	  else
	    fixP->fx_r_type = BFD_RELOC_D30V_9_PCREL_R;
	}
      check_size (value, 9, fixP->fx_file, fixP->fx_line);
      insn |= ((value >> 3) & 0x3F) << 12;
      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      break;

    case BFD_RELOC_D30V_15:
      check_size (value, 15, fixP->fx_file, fixP->fx_line);
      insn |= (value >> 3) & 0xFFF;
      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      break;

    case BFD_RELOC_D30V_15_PCREL:
      if (fixP->fx_where & 0x7)
	{
	  if (fixP->fx_done)
	    value += 4;
	  else
	    fixP->fx_r_type = BFD_RELOC_D30V_15_PCREL_R;
	}
      check_size (value, 15, fixP->fx_file, fixP->fx_line);
      insn |= (value >> 3) & 0xFFF;
      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      break;

    case BFD_RELOC_D30V_21:
      check_size (value, 21, fixP->fx_file, fixP->fx_line);
      insn |= (value >> 3) & 0x3FFFF;
      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      break;

    case BFD_RELOC_D30V_21_PCREL:
      if (fixP->fx_where & 0x7)
	{
	  if (fixP->fx_done)
	    value += 4;
	  else
	    fixP->fx_r_type = BFD_RELOC_D30V_21_PCREL_R;
	}
      check_size (value, 21, fixP->fx_file, fixP->fx_line);
      insn |= (value >> 3) & 0x3FFFF;
      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      break;

    case BFD_RELOC_D30V_32:
      insn2 = bfd_getb32 ((unsigned char *) where + 4);
      insn |= (value >> 26) & 0x3F;		/* Top 6 bits.  */
      insn2 |= ((value & 0x03FC0000) << 2);	/* Next 8 bits.  */
      insn2 |= value & 0x0003FFFF;		/* Bottom 18 bits.  */
      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      bfd_putb32 ((bfd_vma) insn2, (unsigned char *) where + 4);
      break;

    case BFD_RELOC_D30V_32_PCREL:
      insn2 = bfd_getb32 ((unsigned char *) where + 4);
      insn |= (value >> 26) & 0x3F;		/* Top 6 bits.  */
      insn2 |= ((value & 0x03FC0000) << 2);	/* Next 8 bits.  */
      insn2 |= value & 0x0003FFFF;		/* Bottom 18 bits.  */
      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      bfd_putb32 ((bfd_vma) insn2, (unsigned char *) where + 4);
      break;

    case BFD_RELOC_32:
      bfd_putb32 ((bfd_vma) value, (unsigned char *) where);
      break;

    default:
      as_bad (_("line %d: unknown relocation type: 0x%x"),
	      fixP->fx_line, fixP->fx_r_type);
    }
}

/* Handle the .align pseudo-op.  This aligns to a power of two.  We
   hook here to latch the current alignment.  */

static void
s_d30v_align (int ignore ATTRIBUTE_UNUSED)
{
  int align;
  char fill, *pfill = NULL;
  long max_alignment = 15;

  align = get_absolute_expression ();
  if (align > max_alignment)
    {
      align = max_alignment;
      as_warn (_("Alignment too large: %d assumed"), align);
    }
  else if (align < 0)
    {
      as_warn (_("Alignment negative: 0 assumed"));
      align = 0;
    }

  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      fill = get_absolute_expression ();
      pfill = &fill;
    }

  d30v_last_label = NULL;
  d30v_align (align, pfill, NULL);

  demand_empty_rest_of_line ();
}

/* Handle the .text pseudo-op.  This is like the usual one, but it
   clears the saved last label and resets known alignment.  */

static void
s_d30v_text (int i)

{
  s_text (i);
  d30v_last_label = NULL;
  d30v_current_align = 0;
  d30v_current_align_seg = now_seg;
}

/* Handle the .data pseudo-op.  This is like the usual one, but it
   clears the saved last label and resets known alignment.  */

static void
s_d30v_data (int i)
{
  s_data (i);
  d30v_last_label = NULL;
  d30v_current_align = 0;
  d30v_current_align_seg = now_seg;
}

/* Handle the .section pseudo-op.  This is like the usual one, but it
   clears the saved last label and resets known alignment.  */

static void
s_d30v_section (int ignore)
{
  obj_elf_section (ignore);
  d30v_last_label = NULL;
  d30v_current_align = 0;
  d30v_current_align_seg = now_seg;
}

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "word", cons, 4 },
  { "hword", cons, 2 },
  { "align", s_d30v_align, 0 },
  { "text", s_d30v_text, 0 },
  { "data", s_d30v_data, 0 },
  { "section", s_d30v_section, 0 },
  { "section.s", s_d30v_section, 0 },
  { "sect", s_d30v_section, 0 },
  { "sect.s", s_d30v_section, 0 },
  { NULL, NULL, 0 }
};
@


1.41
log
@	* config/tc-d30v.c (d30v_cons_align): Don't align constants
	in debug sections.
@
text
@d1888 2
a1889 1
  if ((now_seg->flags & SEC_ALLOC) == 0)
@


1.40
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d1887 4
@


1.39
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2009 Free Software Foundation, Inc.
d488 1
a488 1
  int i, length, bits, shift, flags;
a509 1
      length = d30v_operand_table[form->operands[i]].length;
d1135 1
a1135 1
  int numops, match, opcode_index, i = 0, j, k;
d1142 1
a1142 1
  numops = get_operands (myops, cmp_hack);
@


1.38
log
@	* config/tc-d30v.c (d30v_frob_label): Call dwarf2_emit_label.
	* config/tc-frv.c (frv_frob_label): Likewise.
@
text
@d1136 1
a1136 1
  int numops, match, index, i = 0, j, k;
d1145 1
a1145 1
  while ((index = opcode->format[i++]) != 0)
d1147 1
a1147 1
      if (fsize == FORCE_SHORT && index >= LONG)
d1150 1
a1150 1
      if (fsize == FORCE_LONG && index < LONG)
d1153 3
a1155 3
      fm = (struct d30v_format *) &d30v_format_table[index];
      k = index;
      while (fm->form == index)
d1349 2
a1350 1
      char **str = (char **) d30v_cc_names;
d1356 1
a1356 1
      for (i = 1; *str && strncmp (*str, &name[p], 2); i++, str++)
d1369 1
a1369 1
      if (!*str)
@


1.37
log
@	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
@
text
@d1876 2
@


1.36
log
@update copyright dates
@
text
@d26 1
d597 1
d625 1
d1093 1
d1691 1
@


1.36.2.1
log
@gas/
	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
gas/testsuite/
	* gas/d30v/serial2.l: Adjust position of page break.
	* gas/lns/lns-common-1-alt.d: Match 2009-04-24 change.
	* gas/mt/ms1-16-003.d: Correct reloc name.
	* gas/mt/relocs.d: Elide incorrect file format strings.
@
text
@a25 1
#include "dwarf2dbg.h"
a595 1
  dwarf2_emit_insn (8);
a622 1
  dwarf2_emit_insn (8);
a1089 1
  dwarf2_emit_insn (8);
a1686 1
		  dwarf2_emit_insn (8);
@


1.36.2.2
log
@	* config/tc-d30v.c (d30v_frob_label): Call dwarf2_emit_label.
	* config/tc-frv.c (frv_frob_label): Likewise.
@
text
@a1875 2

  dwarf2_emit_label (lab);
@


1.35
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d2 2
a3 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.34
log
@* config/tc-tic4x.c (tic4x_insn_insert): Add const qualifier to
  argument.
  (tic4x_insn_add): Likewise.
  (md_begin): Drop cast that was discarding a const qualifier.
  * config/tc-d30v.c (get_reloc): Add const qualifier to op
  argument.
  (build_insn): Drop cast that was discarding a const qualifier.
@
text
@d1519 1
a1519 1
      assert (S_GET_SEGMENT (label) == now_seg);
a2115 1

@


1.33
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
d355 1
a355 1
get_reloc (struct d30v_operand *op, int rel_flag)
d541 1
a541 1
	    get_reloc ((struct d30v_operand *) &d30v_operand_table[form->operands[i]], op->reloc_flag);
@


1.32
log
@Switch to GPLv3
@
text
@a287 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d291 1
a291 30
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;
    case 'd':
      prec = 4;
      break;
    default:
      *sizeP = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * 2;

  for (i = 0; i < prec; i++)
    {
      md_number_to_chars (litP, (valueT) words[i], 2);
      litP += 2;
    }
  return NULL;
@


1.31
log
@remove some duplicate #include's.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.30
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
a21 1
#include <stdio.h>
@


1.29
log
@Update the address and phone number of the FSF
@
text
@d1927 1
a1927 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.28
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.27
log
@update copyright dates
@
text
@d28 2
a29 2
const char comment_chars[] = ";";
const char line_comment_chars[] = "#";
d31 3
a33 3
const char *md_shortopts = "OnNcC";
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "dD";
d55 4
a58 4
  EXEC_UNKNOWN,			/* no order specified */
  EXEC_PARALLEL,		/* done in parallel (FM=00) */
  EXEC_SEQ,			/* sequential (FM=01) */
  EXEC_REVSEQ			/* reverse sequential (FM=10) */
d62 2
a63 1
#define MAX_INSN_FIXUPS (5)
a113 28
/* Local functions.  */
static int reg_name_search PARAMS ((char *name));
static int register_name PARAMS ((expressionS *expressionP));
static int check_range PARAMS ((unsigned long num, int bits, int flags));
static int postfix PARAMS ((char *p));
static bfd_reloc_code_real_type get_reloc PARAMS ((struct d30v_operand *op, int rel_flag));
static int get_operands PARAMS ((expressionS exp[], int cmp_hack));
static struct d30v_format *find_format PARAMS ((struct d30v_opcode *opcode,
			expressionS ops[],int fsize, int cmp_hack));
static long long build_insn PARAMS ((struct d30v_insn *opcode, expressionS *opers));
static void write_long PARAMS ((struct d30v_insn *opcode, long long insn, Fixups *fx));
static void write_1_short PARAMS ((struct d30v_insn *opcode, long long insn,
				   Fixups *fx, int use_sequential));
static int write_2_short PARAMS ((struct d30v_insn *opcode1, long long insn1,
		   struct d30v_insn *opcode2, long long insn2, exec_type_enum exec_type, Fixups *fx));
static long long do_assemble PARAMS ((char *str, struct d30v_insn *opcode,
				      int shortp, int is_parallel));
static int parallel_ok PARAMS ((struct d30v_insn *opcode1, unsigned long insn1,
				struct d30v_insn *opcode2, unsigned long insn2,
				exec_type_enum exec_type));
static void d30v_number_to_chars PARAMS ((char *buf, long long value, int nbytes));
static void check_size PARAMS ((long value, int bits, char *file, int line));
static void d30v_align PARAMS ((int, char *, symbolS *));
static void s_d30v_align PARAMS ((int));
static void s_d30v_text PARAMS ((int));
static void s_d30v_data PARAMS ((int));
static void s_d30v_section PARAMS ((int));

a120 15
/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "word", cons, 4 },
  { "hword", cons, 2 },
  { "align", s_d30v_align, 0 },
  { "text", s_d30v_text, 0 },
  { "data", s_d30v_data, 0 },
  { "section", s_d30v_section, 0 },
  { "section.s", s_d30v_section, 0 },
  { "sect", s_d30v_section, 0 },
  { "sect.s", s_d30v_section, 0 },
  { NULL, NULL, 0 }
};

d129 1
a129 2
reg_name_search (name)
     char *name;
d166 1
a166 2
register_name (expressionP)
     expressionS *expressionP;
d195 1
a195 4
check_range (num, bits, flags)
     unsigned long num;
     int bits;
     int flags;
d238 1
a238 2
md_show_usage (stream)
     FILE *stream;
d249 1
a249 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d284 1
a284 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d295 1
a295 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d330 3
a332 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d338 1
a338 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d345 1
a345 1
md_begin ()
d365 1
a365 2
postfix (p)
     char *p;
d390 1
a390 3
get_reloc (op, rel_flag)
     struct d30v_operand *op;
     int rel_flag;
d427 1
a427 3
get_operands (exp, cmp_hack)
     expressionS exp[];
     int cmp_hack;
d520 1
a520 3
build_insn (opcode, opers)
     struct d30v_insn *opcode;
     expressionS *opers;
d560 3
a562 4
	    {
	      /* NUMBER is a flag register.  */
	      id = 3;
	    }
d566 1
a566 3
	{
	  number = id;
	}
d597 4
a600 4
	  insn |= ((number & 0xffffffff) >> 26);	/* top 6 bits */
	  insn <<= 32;			/* shift the first word over */
	  insn |= ((number & 0x03FC0000) << 2);		/* next 8 bits */
	  insn |= number & 0x0003FFFF;			/* bottom 18 bits */
d609 12
d624 3
a626 4
write_long (opcode, insn, fx)
     struct d30v_insn *opcode ATTRIBUTE_UNUSED;
     long long insn;
     Fixups *fx;
d639 2
a640 6
	  fix_new_exp (frag_now,
		       where,
		       fx->fix[i].size,
		       &(fx->fix[i].exp),
		       fx->fix[i].pcrel,
		       fx->fix[i].reloc);
d650 4
a653 5
write_1_short (opcode, insn, fx, use_sequential)
     struct d30v_insn *opcode;
     long long insn;
     Fixups *fx;
     int use_sequential;
a670 1

a681 1

a708 191
/* Write out a short form instruction if possible.
   Return number of instructions not written out.  */

static int
write_2_short (opcode1, insn1, opcode2, insn2, exec_type, fx)
     struct d30v_insn *opcode1, *opcode2;
     long long insn1, insn2;
     exec_type_enum exec_type;
     Fixups *fx;
{
  long long insn = NOP2;
  char *f;
  int i, j, where;

  if (exec_type == EXEC_SEQ
      && (opcode1->op->flags_used & (FLAG_JMP | FLAG_JSR))
      && ((opcode1->op->flags_used & FLAG_DELAY) == 0)
      && ((opcode1->ecc == ECC_AL) || ! Optimizing))
    {
      /* Unconditional, non-delayed branches kill instructions in
	 the right bin.  Conditional branches don't always but if
	 we are not optimizing, then we have been asked to produce
	 an error about such constructs.  For the purposes of this
	 test, subroutine calls are considered to be branches.  */
      write_1_short (opcode1, insn1, fx->next, FALSE);
      return 1;
    }

  /* Note: we do not have to worry about subroutine calls occurring
     in the right hand container.  The return address is always
     aligned to the next 64 bit boundary, be that 64 or 32 bit away.  */
  switch (exec_type)
    {
    case EXEC_UNKNOWN:	/* Order not specified.  */
      if (Optimizing
	  && parallel_ok (opcode1, insn1, opcode2, insn2, exec_type)
	  && ! (   (opcode1->op->unit == EITHER_BUT_PREFER_MU
		 || opcode1->op->unit == MU)
		&&
		(   opcode2->op->unit == EITHER_BUT_PREFER_MU
		 || opcode2->op->unit == MU)))
	{
	  /* Parallel.  */
	  exec_type = EXEC_PARALLEL;

	  if (opcode1->op->unit == IU
	      || opcode2->op->unit == MU
	      || opcode2->op->unit == EITHER_BUT_PREFER_MU)
	    insn = FM00 | (insn2 << 32) | insn1;
	  else
	    {
	      insn = FM00 | (insn1 << 32) | insn2;
	      fx = fx->next;
	    }
	}
      else if ((opcode1->op->flags_used & (FLAG_JMP | FLAG_JSR)
		&& ((opcode1->op->flags_used & FLAG_DELAY) == 0))
	       || opcode1->op->flags_used & FLAG_RP)
	{
	  /* We must emit (non-delayed) branch type instructions
	     on their own with nothing in the right container.  */
	  /* We must treat repeat instructions likewise, since the
	     following instruction has to be separate from the repeat
	     in order to be repeated.  */
	  write_1_short (opcode1, insn1, fx->next, FALSE);
	  return 1;
	}
      else if (prev_left_kills_right_p)
	{
	  /* The left instruction kils the right slot, so we
	     must leave it empty.  */
	  write_1_short (opcode1, insn1, fx->next, FALSE);
	  return 1;
	}
      else if (opcode1->op->unit == IU)
	{
	  if (opcode2->op->unit == EITHER_BUT_PREFER_MU)
	    {
	      /* Case 103810 is a request from Mitsubishi that opcodes
		 with EITHER_BUT_PREFER_MU should not be executed in
		 reverse sequential order.  */
	      write_1_short (opcode1, insn1, fx->next, FALSE);
	      return 1;
	    }

	  /* Reverse sequential.  */
	  insn = FM10 | (insn2 << 32) | insn1;
	  exec_type = EXEC_REVSEQ;
	}
      else
	{
	  /* Sequential.  */
	  insn = FM01 | (insn1 << 32) | insn2;
	  fx = fx->next;
	  exec_type = EXEC_SEQ;
	}
      break;

    case EXEC_PARALLEL:	/* Parallel.  */
      flag_explicitly_parallel = flag_xp_state;
      if (! parallel_ok (opcode1, insn1, opcode2, insn2, exec_type))
	as_bad (_("Instructions may not be executed in parallel"));
      else if (opcode1->op->unit == IU)
	{
	  if (opcode2->op->unit == IU)
	    as_bad (_("Two IU instructions may not be executed in parallel"));
	  as_warn (_("Swapping instruction order"));
	  insn = FM00 | (insn2 << 32) | insn1;
	}
      else if (opcode2->op->unit == MU)
	{
	  if (opcode1->op->unit == MU)
	    as_bad (_("Two MU instructions may not be executed in parallel"));
	  else if (opcode1->op->unit == EITHER_BUT_PREFER_MU)
	    as_warn (_("Executing %s in IU may not work"), opcode1->op->name);
	  as_warn (_("Swapping instruction order"));
	  insn = FM00 | (insn2 << 32) | insn1;
	}
      else
	{
	  if (opcode2->op->unit == EITHER_BUT_PREFER_MU)
	    as_warn (_("Executing %s in IU may not work in parallel execution"),
		     opcode2->op->name);

	  insn = FM00 | (insn1 << 32) | insn2;
	  fx = fx->next;
	}
      flag_explicitly_parallel = 0;
      break;

    case EXEC_SEQ:	/* Sequential.  */
      if (opcode1->op->unit == IU)
	as_bad (_("IU instruction may not be in the left container"));
      if (prev_left_kills_right_p)
	as_bad (_("special left instruction `%s' kills instruction "
		  "`%s' in right container"),
		opcode1->op->name, opcode2->op->name);
      insn = FM01 | (insn1 << 32) | insn2;
      fx = fx->next;
      break;

    case EXEC_REVSEQ:	/* Reverse sequential.  */
      if (opcode2->op->unit == MU)
	as_bad (_("MU instruction may not be in the right container"));
      if (opcode1->op->unit == EITHER_BUT_PREFER_MU)
	as_warn (_("Executing %s in reverse serial with %s may not work"),
		 opcode1->op->name, opcode2->op->name);
      else if (opcode2->op->unit == EITHER_BUT_PREFER_MU)
	as_warn (_("Executing %s in IU in reverse serial may not work"),
		 opcode2->op->name);
      insn = FM10 | (insn1 << 32) | insn2;
      fx = fx->next;
      break;

    default:
      as_fatal (_("unknown execution type passed to write_2_short()"));
    }

  f = frag_more (8);
  d30v_number_to_chars (f, insn, 8);

  /* If the previous instruction was a 32-bit multiply but it is put into a
     parallel container, mark the current instruction as being a 32-bit
     multiply.  */
  if (prev_mul32_p && exec_type == EXEC_PARALLEL)
    cur_mul32_p = 1;

  for (j = 0; j < 2; j++)
    {
      for (i = 0; i < fx->fc; i++)
	{
	  if (fx->fix[i].reloc)
	    {
	      where = (f - frag_now->fr_literal) + 4 * j;

	      fix_new_exp (frag_now,
			   where,
			   fx->fix[i].size,
			   &(fx->fix[i].exp),
			   fx->fix[i].pcrel,
			   fx->fix[i].reloc);
	    }
	}

      fx->fc = 0;
      fx = fx->next;
    }

  return 0;
}

d713 5
a717 4
parallel_ok (op1, insn1, op2, insn2, exec_type)
     struct d30v_insn *op1, *op2;
     unsigned long insn1, insn2;
     exec_type_enum exec_type;
d965 2
a966 5
/* This is the main entry point for the machine-dependent assembler.
   STR points to a machine-dependent instruction.  This function is
   supposed to emit the frags/bytes it assembles to.  For the D30V, it
   mostly handles the special VLIW parsing and packing and leaves the
   difficult stuff to do_assemble ().  */
d968 7
a974 8
static long long prev_insn = -1;
static struct d30v_insn prev_opcode;
static subsegT prev_subseg;
static segT prev_seg = 0;

void
md_assemble (str)
     char *str;
d976 3
a978 7
  struct d30v_insn opcode;
  long long insn;
  /* Execution type; parallel, etc.  */
  exec_type_enum extype = EXEC_UNKNOWN;
  /* Saved extype.  Used for multiline instructions.  */
  static exec_type_enum etype = EXEC_UNKNOWN;
  char *str2;
d980 13
a992 3
  if ((prev_insn != -1) && prev_seg
      && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))
    d30v_cleanup (FALSE);
d994 16
a1009 5
  if (d30v_current_align < 3)
    d30v_align (3, NULL, d30v_last_label);
  else if (d30v_current_align > 3)
    d30v_current_align = 3;
  d30v_last_label = NULL;
d1011 23
a1033 7
  flag_explicitly_parallel = 0;
  flag_xp_state = 0;
  if (etype == EXEC_UNKNOWN)
    {
      /* Look for the special multiple instruction separators.  */
      str2 = strstr (str, "||");
      if (str2)
d1035 4
a1038 2
	  extype = EXEC_PARALLEL;
	  flag_xp_state = 1;
d1040 1
a1040 1
      else
d1042 1
a1042 4
	  str2 = strstr (str, "->");
	  if (str2)
	    extype = EXEC_SEQ;
	  else
d1044 5
a1048 3
	      str2 = strstr (str, "<-");
	      if (str2)
		extype = EXEC_REVSEQ;
d1050 11
d1062 1
d1064 21
a1084 2
      /* STR2 points to the separator, if one.  */
      if (str2)
d1086 20
a1105 1
	  *str2 = 0;
d1107 12
a1118 3
	  /* If two instructions are present and we already have one saved,
	     then first write it out.  */
	  d30v_cleanup (FALSE);
d1120 2
a1121 11
	  /* Assemble first instruction and save it.  */
	  prev_insn = do_assemble (str, &prev_opcode, 1, 0);
	  if (prev_insn == -1)
	    as_bad (_("Cannot assemble instruction"));
	  if (prev_opcode.form != NULL && prev_opcode.form->form >= LONG)
	    as_bad (_("First opcode is long.  Unable to mix instructions as specified."));
	  fixups = fixups->next;
	  str = str2 + 2;
	  prev_seg = now_seg;
	  prev_subseg = now_subseg;
	}
d1124 2
a1125 10
  insn = do_assemble (str, &opcode,
		      (extype != EXEC_UNKNOWN || etype != EXEC_UNKNOWN),
		      extype == EXEC_PARALLEL);
  if (insn == -1)
    {
      if (extype != EXEC_UNKNOWN)
	etype = extype;
      as_bad (_("Cannot assemble instruction"));
      return;
    }
d1127 5
a1131 5
  if (etype != EXEC_UNKNOWN)
    {
      extype = etype;
      etype = EXEC_UNKNOWN;
    }
d1133 1
a1133 5
  /* Word multiply instructions must not be followed by either a load or a
     16-bit multiply instruction in the next cycle.  */
  if (   (extype != EXEC_REVSEQ)
      && prev_mul32_p
      && (opcode.op->flags_used & (FLAG_MEM | FLAG_MUL16)))
d1135 1
a1135 10
      /* However, load and multiply should able to be combined in a parallel
	 operation, so check for that first.  */
      if (prev_insn != -1
	  && (opcode.op->flags_used & FLAG_MEM)
	  && opcode.form->form < LONG
	  && (extype == EXEC_PARALLEL || (Optimizing && extype == EXEC_UNKNOWN))
	  && parallel_ok (&prev_opcode, (long) prev_insn,
			  &opcode, (long) insn, extype)
	  && write_2_short (&prev_opcode, (long) prev_insn,
			    &opcode, (long) insn, extype, fixups) == 0)
d1137 1
a1137 14
	  /* No instructions saved.  */
	  prev_insn = -1;
	  return;
	}
      else
	{
	  /* Can't parallelize, flush previous instruction and emit a
	     word of NOPS, unless the previous instruction is a NOP,
	     in which case just flush it, as this will generate a word
	     of NOPs for us.  */

	  if (prev_insn != -1 && (strcmp (prev_opcode.op->name, "nop") == 0))
	    d30v_cleanup (FALSE);
	  else
d1139 1
a1139 1
	      char *f;
d1141 6
a1146 15
	      if (prev_insn != -1)
		d30v_cleanup (TRUE);
	      else
		{
		  f = frag_more (8);
		  d30v_number_to_chars (f, NOP2, 8);

		  if (warn_nops == NOP_ALL || warn_nops == NOP_MULTIPLY)
		    {
		      if (opcode.op->flags_used & FLAG_MEM)
			as_warn (_("word of NOPs added between word multiply and load"));
		      else
			as_warn (_("word of NOPs added between word multiply and 16-bit multiply"));
		    }
		}
d1148 1
d1150 2
a1151 2
	  extype = EXEC_UNKNOWN;
	}
a1152 7
  else if (   (extype == EXEC_REVSEQ)
	   && cur_mul32_p
	   && (prev_opcode.op->flags_used & (FLAG_MEM | FLAG_MUL16)))
    {
      /* Can't parallelize, flush current instruction and add a
         sequential NOP.  */
      write_1_short (&opcode, (long) insn, fixups->next->next, TRUE);
d1154 21
a1174 10
      /* Make the previous instruction the current one.  */
      extype = EXEC_UNKNOWN;
      insn = prev_insn;
      now_seg = prev_seg;
      now_subseg = prev_subseg;
      prev_insn = -1;
      cur_mul32_p = prev_mul32_p;
      prev_mul32_p = 0;
      memcpy (&opcode, &prev_opcode, sizeof (prev_opcode));
    }
d1176 1
a1176 3
  /* If this is a long instruction, write it and any previous short
     instruction.  */
  if (opcode.form->form >= LONG)
d1178 126
a1303 18
      if (extype != EXEC_UNKNOWN)
	as_bad (_("Instruction uses long version, so it cannot be mixed as specified"));
      d30v_cleanup (FALSE);
      write_long (&opcode, insn, fixups);
      prev_insn = -1;
    }
  else if ((prev_insn != -1)
	   && (write_2_short
	       (&prev_opcode, (long) prev_insn, &opcode,
		(long) insn, extype, fixups) == 0))
    {
      /* No instructions saved.  */
      prev_insn = -1;
    }
  else
    {
      if (extype != EXEC_UNKNOWN)
	as_bad (_("Unable to mix instructions as specified"));
d1305 4
a1308 7
      /* Save off last instruction so it may be packed on next pass.  */
      memcpy (&prev_opcode, &opcode, sizeof (prev_opcode));
      prev_insn = insn;
      prev_seg = now_seg;
      prev_subseg = now_subseg;
      fixups = fixups->next;
      prev_mul32_p = cur_mul32_p;
d1310 1
d1319 4
a1322 5
do_assemble (str, opcode, shortp, is_parallel)
     char *str;
     struct d30v_insn *opcode;
     int shortp;
     int is_parallel;
d1505 4
a1508 3
/* Get a pointer to an entry in the format table.
   It must look at all formats for an opcode and use the operands
   to choose the correct one.  Return NULL on error.  */
d1510 2
a1511 6
static struct d30v_format *
find_format (opcode, myops, fsize, cmp_hack)
     struct d30v_opcode *opcode;
     expressionS myops[];
     int fsize;
     int cmp_hack;
d1513 17
a1529 2
  int numops, match, index, i = 0, j, k;
  struct d30v_format *fm;
d1531 11
a1541 2
  if (opcode == NULL)
    return NULL;
d1543 2
a1544 2
  /* Get all the operands and save them as expressions.  */
  numops = get_operands (myops, cmp_hack);
d1546 1
a1546 1
  while ((index = opcode->format[i++]) != 0)
d1548 7
a1554 2
      if (fsize == FORCE_SHORT && index >= LONG)
	continue;
d1556 3
a1558 2
      if (fsize == FORCE_LONG && index < LONG)
	continue;
d1560 145
a1704 3
      fm = (struct d30v_format *) &d30v_format_table[index];
      k = index;
      while (fm->form == index)
d1706 8
a1713 3
	  match = 1;
	  /* Now check the operands for compatibility.  */
	  for (j = 0; match && fm->operands[j]; j++)
d1715 1
a1715 4
	      int flags = d30v_operand_table[fm->operands[j]].flags;
	      int bits = d30v_operand_table[fm->operands[j]].bits;
	      int X_op = myops[j].X_op;
	      int num = myops[j].X_add_number;
d1717 3
a1719 5
	      if (flags & OPERAND_SPECIAL)
		break;
	      else if (X_op == O_illegal)
		match = 0;
	      else if (flags & OPERAND_REG)
d1721 4
a1724 7
		  if (X_op != O_register
		      || ((flags & OPERAND_ACC) && !(num & OPERAND_ACC))
		      || (!(flags & OPERAND_ACC) && (num & OPERAND_ACC))
		      || ((flags & OPERAND_FLAG) && !(num & OPERAND_FLAG))
		      || (!(flags & (OPERAND_FLAG | OPERAND_CONTROL)) && (num & OPERAND_FLAG))
		      || ((flags & OPERAND_CONTROL)
			  && !(num & (OPERAND_CONTROL | OPERAND_FLAG))))
d1726 4
a1729 1
		      match = 0;
d1732 130
a1861 16
	      else if (((flags & OPERAND_MINUS)
			&& (X_op != O_absent || num != OPERAND_MINUS))
		       || ((flags & OPERAND_PLUS)
			   && (X_op != O_absent || num != OPERAND_PLUS))
		       || ((flags & OPERAND_ATMINUS)
			   && (X_op != O_absent || num != OPERAND_ATMINUS))
		       || ((flags & OPERAND_ATPAR)
			   && (X_op != O_absent || num != OPERAND_ATPAR))
		       || ((flags & OPERAND_ATSIGN)
			   && (X_op != O_absent || num != OPERAND_ATSIGN)))
		{
		  match = 0;
		}
	      else if (flags & OPERAND_NUM)
		{
		  /* A number can be a constant or symbol expression.  */
d1863 4
a1866 9
		  /* If we have found a register name, but that name
		     also matches a symbol, then re-parse the name as
		     an expression.  */
		  if (X_op == O_register
		      && symbol_find ((char *) myops[j].X_op_symbol))
		    {
		      input_line_pointer = (char *) myops[j].X_op_symbol;
		      expression (&myops[j]);
		    }
d1868 2
a1869 10
		  /* Turn an expression into a symbol for later resolution.  */
		  if (X_op != O_absent && X_op != O_constant
		      && X_op != O_symbol && X_op != O_register
		      && X_op != O_big)
		    {
		      symbolS *sym = make_expr_symbol (&myops[j]);
		      myops[j].X_op = X_op = O_symbol;
		      myops[j].X_add_symbol = sym;
		      myops[j].X_add_number = num = 0;
		    }
d1871 3
a1873 10
		  if (fm->form >= LONG)
		    {
		      /* If we're testing for a LONG format, either fits.  */
		      if (X_op != O_constant && X_op != O_symbol)
			match = 0;
		    }
		  else if (fm->form < LONG
			   && ((fsize == FORCE_SHORT && X_op == O_symbol)
			       || (fm->form == SHORT_D2 && j == 0)))
		    match = 1;
d1875 4
a1878 16
		  /* This is the tricky part.  Will the constant or symbol
		     fit into the space in the current format?  */
		  else if (X_op == O_constant)
		    {
		      if (check_range (num, bits, flags))
			match = 0;
		    }
		  else if (X_op == O_symbol
			   && S_IS_DEFINED (myops[j].X_add_symbol)
			   && S_GET_SEGMENT (myops[j].X_add_symbol) == now_seg
			   && opcode->reloc_flag == RELOC_PCREL)
		    {
		      /* If the symbol is defined, see if the value will fit
			 into the form we're considering.  */
		      fragS *f;
		      long value;
d1880 4
a1883 22
		      /* Calculate the current address by running through the
			 previous frags and adding our current offset.  */
		      value = 0;
		      for (f = frchain_now->frch_root; f; f = f->fr_next)
			value += f->fr_fix + f->fr_offset;
		      value = (S_GET_VALUE (myops[j].X_add_symbol) - value
			       - (obstack_next_free (&frchain_now->frch_obstack)
				  - frag_now->fr_literal));
		      if (check_range (value, bits, flags))
			match = 0;
		    }
		  else
		    match = 0;
		}
	    }
	  /* We're only done if the operands matched so far AND there
	     are no more to check.  */
	  if (match && myops[j].X_op == 0)
	    {
	      /* Final check - issue a warning if an odd numbered register
		 is used as the first register in an instruction that reads
		 or writes 2 registers.  */
d1885 1
a1885 5
	      for (j = 0; fm->operands[j]; j++)
		if (myops[j].X_op == O_register
		    && (myops[j].X_add_number & 1)
		    && (d30v_operand_table[fm->operands[j]].flags & OPERAND_2REG))
		  as_warn (_("Odd numbered register used as target of multi-register instruction"));
d1887 2
a1888 6
	      return fm;
	    }
	  fm = (struct d30v_format *) &d30v_format_table[++k];
	}
    }
  return NULL;
d1891 1
a1891 2
/* If while processing a fixup, a reloc really needs to be created,
   then it is done here.  */
d1893 2
a1894 4
arelent *
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d1896 6
a1901 13
  arelent *reloc;
  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }
d1903 3
a1905 2
  reloc->addend = 0;
  return reloc;
d1908 4
a1911 4
int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d1913 5
a1917 3
  abort ();
  return 0;
}
d1919 5
a1923 10
long
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec;
{
  if (fixp->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
    return 0;
  return fixp->fx_frag->fr_address + fixp->fx_where;
d1927 1
a1927 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
a2064 201
/* Called after the assembler has finished parsing the input file or
   after a label is defined.  Because the D30V assembler sometimes
   saves short instructions to see if it can package them with the
   next instruction, there may be a short instruction that still needs
   written.  */

int
d30v_cleanup (use_sequential)
     int use_sequential;
{
  segT seg;
  subsegT subseg;

  if (prev_insn != -1)
    {
      seg = now_seg;
      subseg = now_subseg;
      subseg_set (prev_seg, prev_subseg);
      write_1_short (&prev_opcode, (long) prev_insn, fixups->next,
		     use_sequential);
      subseg_set (seg, subseg);
      prev_insn = -1;
      if (use_sequential)
	prev_mul32_p = FALSE;
    }

  return 1;
}

static void
d30v_number_to_chars (buf, value, n)
     char *buf;			/* Return 'nbytes' of chars here.  */
     long long value;		/* The value of the bits.  */
     int n;			/* Number of bytes in the output.  */
{
  while (n--)
    {
      buf[n] = value & 0xff;
      value >>= 8;
    }
}

/* This function is called at the start of every line.  It checks to
   see if the first character is a '.', which indicates the start of a
   pseudo-op.  If it is, then write out any unwritten instructions.  */

void
d30v_start_line ()
{
  char *c = input_line_pointer;

  while (ISSPACE (*c))
    c++;

  if (*c == '.')
    d30v_cleanup (FALSE);
}

static void
check_size (value, bits, file, line)
     long value;
     int bits;
     char *file;
     int line;
{
  int tmp, max;

  if (value < 0)
    tmp = ~value;
  else
    tmp = value;

  max = (1 << (bits - 1)) - 1;

  if (tmp > max)
    as_bad_where (file, line, _("value too large to fit in %d bits"), bits);
}

/* d30v_frob_label() is called when after a label is recognized.  */

void
d30v_frob_label (lab)
     symbolS *lab;
{
  /* Emit any pending instructions.  */
  d30v_cleanup (FALSE);

  /* Update the label's address with the current output pointer.  */
  symbol_set_frag (lab, frag_now);
  S_SET_VALUE (lab, (valueT) frag_now_fix ());

  /* Record this label for future adjustment after we find out what
     kind of data it references, and the required alignment therewith.  */
  d30v_last_label = lab;
}

/* Hook into cons for capturing alignment changes.  */

void
d30v_cons_align (size)
     int size;
{
  int log_size;

  log_size = 0;
  while ((size >>= 1) != 0)
    ++log_size;

  if (d30v_current_align < log_size)
    d30v_align (log_size, (char *) NULL, NULL);
  else if (d30v_current_align > log_size)
    d30v_current_align = log_size;
  d30v_last_label = NULL;
}

/* Called internally to handle all alignment needs.  This takes care
   of eliding calls to frag_align if'n the cached current alignment
   says we've already got it, as well as taking care of the auto-aligning
   labels wrt code.  */

static void
d30v_align (n, pfill, label)
     int n;
     char *pfill;
     symbolS *label;
{
  /* The front end is prone to changing segments out from under us
     temporarily when -g is in effect.  */
  int switched_seg_p = (d30v_current_align_seg != now_seg);

  /* Do not assume that if 'd30v_current_align >= n' and
     '! switched_seg_p' that it is safe to avoid performing
     this alignment request.  The alignment of the current frag
     can be changed under our feet, for example by a .ascii
     directive in the source code.  cf testsuite/gas/d30v/reloc.s  */
  d30v_cleanup (FALSE);

  if (pfill == NULL)
    {
      if (n > 2
	  && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
	{
	  static char const nop[4] = { 0x00, 0xf0, 0x00, 0x00 };

	  /* First, make sure we're on a four-byte boundary, in case
	     someone has been putting .byte values the text section.  */
	  if (d30v_current_align < 2 || switched_seg_p)
	    frag_align (2, 0, 0);
	  frag_align_pattern (n, nop, sizeof nop, 0);
	}
      else
	frag_align (n, 0, 0);
    }
  else
    frag_align (n, *pfill, 0);

  if (!switched_seg_p)
    d30v_current_align = n;

  if (label != NULL)
    {
      symbolS     *sym;
      int          label_seen = FALSE;
      struct frag *old_frag;
      valueT       old_value;
      valueT       new_value;

      assert (S_GET_SEGMENT (label) == now_seg);

      old_frag  = symbol_get_frag (label);
      old_value = S_GET_VALUE (label);
      new_value = (valueT) frag_now_fix ();

      /* It is possible to have more than one label at a particular
	 address, especially if debugging is enabled, so we must
	 take care to adjust all the labels at this address in this
	 fragment.  To save time we search from the end of the symbol
	 list, backwards, since the symbols we are interested in are
	 almost certainly the ones that were most recently added.
	 Also to save time we stop searching once we have seen at least
	 one matching label, and we encounter a label that is no longer
	 in the target fragment.  Note, this search is guaranteed to
	 find at least one match when sym == label, so no special case
	 code is necessary.  */
      for (sym = symbol_lastP; sym != NULL; sym = symbol_previous (sym))
	{
	  if (symbol_get_frag (sym) == old_frag
	      && S_GET_VALUE (sym) == old_value)
	    {
	      label_seen = TRUE;
	      symbol_set_frag (sym, frag_now);
	      S_SET_VALUE (sym, new_value);
	    }
	  else if (label_seen && symbol_get_frag (sym) != old_frag)
	    break;
	}
    }

  record_alignment (now_seg, n);
}

d2069 1
a2069 2
s_d30v_align (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2104 1
a2104 2
s_d30v_text (i)
     int i;
d2117 1
a2117 2
s_d30v_data (i)
     int i;
d2129 1
a2129 2
s_d30v_section (ignore)
     int ignore;
d2136 16
@


1.26
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2005
@


1.25
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 2
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d1432 3
a1434 3
  unsigned char *op_start;
  unsigned char *save;
  unsigned char *op_end;
d1447 1
a1447 1
  for (op_start = op_end = (unsigned char *) (str);
d1451 1
a1451 1
       && !is_end_of_line[*op_end] && *op_end != ' ';
@


1.24
log
@Remove redundant returns in void functions.
@
text
@a928 3
#if 0
  printf ("writing out %llx\n", insn);
#endif
a1476 3
#if 0
      printf ("condition code=%d\n", i);
#endif
a1517 4
#if 0
  printf ("cmp_hack=%d\n", cmp_hack);
#endif

a1750 3
#if 0
	  printf ("through the loop: match=%d\n", match);
#endif
a1768 3
#if 0
      printf ("trying another format: i=%d\n", i);
#endif
@


1.23
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-alpha.c: Likewise.
	* config/tc-alpha.h: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-dlx.h: Likewise.
@
text
@a2053 2

  return;
@


1.22
log
@	* config/tc-d30v.c (check_range): Warning fixes, formatting.
	Simplify sign extension.  Remove redundant unsigned < 0 test.
	* config/tc-i960.c (md_ri_to_chars): Prototype.
	* config/tc-mcore.c (md_pseudo_table): Fix typo.
	(dump_literals): Init brarsym, and test later instead of isforce.
@
text
@d104 1
a104 1
   labels preceeding instructions.  */
d799 1
a799 1
  /* Note: we do not have to worry about subroutine calls occuring
d1567 1
a1567 1
  /* Propigate multiply status.  */
d2112 1
a2112 1
     this alignement request.  The alignment of the current frag
@


1.21
log
@	* config/tc-d30v.c (md_parse_option <arg>): Add ATTRIBUTE_UNUSED.
	(md_undefined_symbol <name>): Likewise.
	(md_convert_frag <all args>): Likewise.
	(write_long <opcode>): Likewise.
	(tc_gen_reloc <seg>): Likewise.
	(md_estimate_size_before_relax <all args>): Likewise.
	(md_apply_fix3 <seg>): Likewise.
	(s_d30v_align <ignore>): Likewise.
	(build_insn): Correct format string.
	(md_apply_fix3): Likewise.
@
text
@d255 1
a255 1
      return (long)num < min || (long)num > max;
d261 1
d264 4
a267 5
	num = (unsigned long) ((long) num >= 0)
		? (((long) num) >> 3)
		: ((num >> 3) | ~(~(unsigned long) 0 >> 3));
      else
	num >>= 3;
d274 1
a274 1
      return (long)num > max || (long)num < min;
d279 1
a279 2
      min = 0;
      return num > max || num < min;
@


1.20
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d299 1
a299 1
     char *arg;
d335 1
a335 1
     char *name;
d385 3
a387 3
     bfd *abfd;
     asection *sec;
     fragS *fragP;
d656 1
a656 1
	as_bad (_("operand out of range: %d"), number);
d680 1
a680 1
     struct d30v_insn *opcode;
d1795 1
a1795 1
     asection *seg;
d1818 2
a1819 2
     fragS *fragp;
     asection *seg;
d1841 1
a1841 1
     segT seg;
d1866 1
a1866 1
	as_bad (_("line %d: unable to place value %x into a byte"),
d1877 1
a1877 1
	as_bad (_("line %d: unable to place value %x into a short"),
d2187 1
a2187 1
     int ignore;
@


1.19
log
@gas reloc rewrite.
@
text
@d796 1
a796 1
      write_1_short (opcode1, insn1, fx->next, false);
d836 1
a836 1
	  write_1_short (opcode1, insn1, fx->next, false);
d843 1
a843 1
	  write_1_short (opcode1, insn1, fx->next, false);
d853 1
a853 1
	      write_1_short (opcode1, insn1, fx->next, false);
d1246 1
a1246 1
    d30v_cleanup (false);
d1285 1
a1285 1
	  d30v_cleanup (false);
d1346 1
a1346 1
	    d30v_cleanup (false);
d1352 1
a1352 1
		d30v_cleanup (true);
d1377 1
a1377 1
      write_1_short (&opcode, (long) insn, fixups->next->next, true);
d1396 1
a1396 1
      d30v_cleanup (false);
d2002 1
a2002 1
	prev_mul32_p = false;
d2034 1
a2034 1
    d30v_cleanup (false);
d2066 1
a2066 1
  d30v_cleanup (false);
d2116 1
a2116 1
  d30v_cleanup (false);
d2143 1
a2143 1
      int          label_seen = false;
d2170 1
a2170 1
	      label_seen = true;
@


1.18
log
@	* config/obj-coff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/tc-alpha.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-hppa.c: Likewise.
@
text
@d1811 2
a1812 1
  reloc->addend = fixp->fx_addnumber;
d1840 1
a1840 1
     valueT * valP;
d1845 1
a1845 1
  long value = * (long *) valP;
d1850 3
a1852 17
  else if (fixP->fx_pcrel)
    ;

  else
    {
      value = fixP->fx_offset;

      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    /* We don't actually support subtracting a symbol.  */
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("expression too complex"));
	}
    }
@


1.17
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d249 1
a249 1
        return 0;
d1214 1
a1214 1
        if ((mod_reg[0][j] & (mod_reg[1][j] | used_reg[1][j])) != 0)
@


1.16
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1836 4
a1839 4
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
d1844 7
a1850 1
  long value;
a1851 7
  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = *valuep;
d1854 1
a1854 1
      value = fixp->fx_offset;
d1856 1
a1856 1
      if (fixp->fx_subsy != (symbolS *) NULL)
d1858 2
a1859 2
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
d1861 3
a1863 5
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("expression too complex"));
	    }
d1869 1
a1869 1
  where = fixp->fx_frag->fr_literal + fixp->fx_where;
d1872 1
a1872 1
  switch (fixp->fx_r_type)
d1875 1
a1875 1
      if (fixp->fx_addsy != NULL)
d1877 1
a1877 1
		fixp->fx_line, S_GET_NAME (fixp->fx_addsy));
d1880 1
a1880 1
		fixp->fx_line, value);
d1886 1
a1886 1
      if (fixp->fx_addsy != NULL)
d1888 1
a1888 1
		fixp->fx_line, S_GET_NAME (fixp->fx_addsy));
d1891 1
a1891 1
		fixp->fx_line, value);
d1897 1
a1897 1
      if (fixp->fx_addsy != NULL)
d1899 1
a1899 1
		fixp->fx_line, S_GET_NAME (fixp->fx_addsy));
d1908 1
a1908 1
      check_size (value, 6, fixp->fx_file, fixp->fx_line);
d1914 1
a1914 1
      if (fixp->fx_where & 0x7)
d1916 1
a1916 1
	  if (fixp->fx_done)
d1919 1
a1919 1
	    fixp->fx_r_type = BFD_RELOC_D30V_9_PCREL_R;
d1921 1
a1921 1
      check_size (value, 9, fixp->fx_file, fixp->fx_line);
d1927 1
a1927 1
      check_size (value, 15, fixp->fx_file, fixp->fx_line);
d1933 1
a1933 1
      if (fixp->fx_where & 0x7)
d1935 1
a1935 1
	  if (fixp->fx_done)
d1938 1
a1938 1
	    fixp->fx_r_type = BFD_RELOC_D30V_15_PCREL_R;
d1940 1
a1940 1
      check_size (value, 15, fixp->fx_file, fixp->fx_line);
d1946 1
a1946 1
      check_size (value, 21, fixp->fx_file, fixp->fx_line);
d1952 1
a1952 1
      if (fixp->fx_where & 0x7)
d1954 1
a1954 1
	  if (fixp->fx_done)
d1957 1
a1957 1
	    fixp->fx_r_type = BFD_RELOC_D30V_21_PCREL_R;
d1959 1
a1959 1
      check_size (value, 21, fixp->fx_file, fixp->fx_line);
d1988 1
a1988 1
	      fixp->fx_line, fixp->fx_r_type);
a1989 2

  return 0;
@


1.15
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
a21 1
#include <ctype.h>
d23 1
d1457 1
a1457 1
      name[nlen] = tolower (op_start[nlen]);
d2048 1
a2048 1
  while (isspace (*c))
@


1.14
log
@2000-09-25  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-cris.c: Fix formatting.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation.
@


1.14.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.13
log
@Fix formatting.
@
text
@d437 1
a437 1
  
d505 1
a505 1
      
d574 1
a574 1
  
d672 1
a672 1
  
d703 1
a703 1
  
d768 1
a768 1
  
d1020 1
a1020 1
      
d1277 1
a1277 1
      
d1978 3
a1980 3
      insn |= (value >> 26) & 0x3F;		/* Top 6 bits. */
      insn2 |= ((value & 0x03FC0000) << 2);	/* Next 8 bits. */
      insn2 |= value & 0x0003FFFF;		/* Bottom 18 bits. */
d2022 1
a2022 1
  
@


1.12
log
@Further changes to warning messages
@
text
@d24 1
a24 1
#include "subsegs.h"     
d60 1
a60 1
/* fixups */
d87 1
a87 1
    human programmer.  It is used in parallel_ok() to distinguish between
d90 2
a91 2
    from md_assemble().  */
static int flag_explicitly_parallel = 0; 
d107 1
a107 1
/* Two nops */
d112 1
a112 1
/* local functions */
d119 1
a119 1
static struct d30v_format *find_format PARAMS ((struct d30v_opcode *opcode, 
d125 1
a125 1
static int write_2_short PARAMS ((struct d30v_insn *opcode1, long long insn1, 
d129 1
a129 1
static int parallel_ok PARAMS ((struct d30v_insn *opcode1, unsigned long insn1, 
d140 2
a141 1
struct option md_longopts[] = {
a143 1
size_t md_longopts_size = sizeof(md_longopts);       
d145 1
d165 3
a167 3
/* reg_name_search does a binary search of the pre_defined_registers
   array to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure. */
d195 1
a195 1
  
d200 1
a200 1
  
d204 2
a205 2
/* register_name() checks the string at input_line_pointer
   to see if it is a valid register name.  */
d213 2
a214 2
  
  while (*p && *p!='\n' && *p!='\r' && *p !=',' && *p!=' ' && *p!=')')
d221 1
a221 1
  /* look to see if it's in the register table */
d223 1
a223 1
  if (reg_number >= 0) 
d226 2
a227 2
      /* temporarily store a pointer to the string here */
      expressionP->X_op_symbol = (symbolS *)input_line_pointer;
d233 1
a233 1
    *(p-1) = c;
a236 1

d248 1
a248 1
      if (sizeof(unsigned long) * CHAR_BIT == 32)
d253 2
a254 2
      min = -((unsigned long)1 << (bits - 1));
      max = ((unsigned long)1 << bits) - 1;
d260 2
a261 2
      /* We know that all shifts are right by three bits.... */
      
d263 3
a265 3
	num = (unsigned long) ( (long) num >= 0) 
		? ( ((long) num) >> 3 )
		: ( (num >> 3) | ~(~(unsigned long)0 >> 3) );
d272 2
a273 2
      max = ((unsigned long)1 << (bits - 1)) - 1; 
      min = - ((unsigned long)1 << (bits - 1));
d278 1
a278 1
      max = ((unsigned long)1 << bits) - 1;
a283 1

d286 1
a286 1
  FILE *stream;
d303 1
a303 1
      /* Optimize. Will attempt to parallelize operations */
d326 1
a326 1
      
d335 1
a335 1
  char *name;
d340 5
a344 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
d355 1
a355 1
  
d372 1
a372 1
  
d374 1
a374 1
  
d378 1
a378 1
	  litP += 2;
d385 3
a387 3
  bfd *abfd;
  asection *sec;
  fragS *fragP;
a400 1

d404 1
a404 1
  struct d30v_opcode * opcode;
d407 2
a408 2
  /* Insert opcode names into a hash table. */
  for (opcode = (struct d30v_opcode *)d30v_opcode_table; opcode->name; opcode++)
d418 2
d421 2
a422 4
/* this function removes the postincrement or postdecrement
   operator ( '+' or '-' ) from an expression */

static int postfix (p) 
d425 1
a425 1
  while (*p != '-' && *p != '+') 
d427 1
a427 1
      if (*p==0 || *p=='\n' || *p=='\r' || *p==' ' || *p==',') 
d432 1
a432 1
  if (*p == '-') 
d435 1
a435 1
      return (-1);
d437 2
a438 1
  if (*p == '+') 
d441 1
a441 1
      return (1);
d444 1
a444 1
  return (0);
d447 2
a448 3

static bfd_reloc_code_real_type 
get_reloc (op, rel_flag) 
d484 1
a484 2
/* get_operands parses a string of operands and returns
   an array of expressions */
d487 1
a487 1
get_operands (exp, cmp_hack) 
d501 1
a501 1
  while (*p)  
d503 1
a503 1
      while (*p == ' ' || *p == '\t' || *p == ',') 
d505 2
a506 1
      if (*p==0 || *p=='\n' || *p=='\r') 
d508 2
a509 2
      
      if (*p == '@@') 
d513 1
a513 1
	  if (*p == '(') 
d519 1
a519 1
	  else if (*p == '-') 
d533 1
a533 1
      if (*p == ')') 
d535 1
a535 1
	  /* just skip the trailing paren */
d542 1
a542 1
      /* check to see if it might be a register name */
d545 1
a545 1
	  /* parse as an expression */
d549 1
a549 1
      if (exp[numops].X_op == O_illegal) 
d551 1
a551 1
      else if (exp[numops].X_op == O_absent) 
d557 1
a557 1
      switch (post) 
d559 2
a560 1
	case -1:	/* postdecrement mode */
d564 2
a565 1
	case 1:	/* postincrement mode */
d574 2
a575 1
  return (numops);
d578 2
a579 2
/* build_insn generates the instruction.  It does everything */
/* but write the FM bits. */
d582 1
a582 1
build_insn (opcode, opers) 
d587 1
a587 1
  unsigned long number, id=0;
d592 2
a593 1
  insn = opcode->ecc << 28 | op->op1 << 25 | op->op2 << 20 | form->modifier << 18;
d595 2
a596 2
  for (i=0; form->operands[i]; i++) 
    { 
d599 3
a601 3
      /* must be a register or number */
      if (!(flags & OPERAND_REG) && !(flags & OPERAND_NUM) && 
	  !(flags & OPERAND_NAME) && !(flags & OPERAND_SPECIAL))
d616 1
a616 1
	  /* check for mvfsys or mvtsys control registers */
d619 1
a619 1
	      /* PSWL or PSWH */
d625 2
a626 1
	      id = 3;  /* number is a flag register */
d635 2
a636 1
      if (opers[i].X_op != O_register && opers[i].X_op != O_constant && !(flags & OPERAND_NAME))
d638 1
a638 2
	  /* now create a fixup */

d642 2
a643 2
	  fixups->fix[fixups->fc].reloc = 
	    get_reloc ((struct d30v_operand *)&d30v_operand_table[form->operands[i]], op->reloc_flag);
d654 1
a654 1
      /* truncate to the proper number of bits */
d656 1
a656 1
	as_bad (_("operand out of range: %d"),number);
d663 1
a663 1
	  /* it's a LONG instruction */
d666 1
a666 1
	  insn |= ((number & 0x03FC0000) << 2);		/* next 8 bits */ 
d672 1
d676 1
a677 1
/* write out a long form instruction */
d679 1
a679 1
write_long (opcode, insn, fx) 
d690 1
a690 1
  for (i=0; i < fx->fc; i++) 
d693 2
a694 2
	{ 
	  where = f - frag_now->fr_literal; 
d703 1
d707 1
a708 1
/* Write out a short form instruction by itself.  */
d710 1
a710 1
write_1_short (opcode, insn, fx, use_sequential) 
d723 1
a723 1
  /* The other container needs to be NOP. */
d729 1
a729 1
      
d731 2
a732 2
	 only by IU cannot be encoded in L-container. */
      
d734 2
a735 1
	insn |= FM10 | NOP_LEFT;	/* right then left */
d737 2
a738 1
	insn = FM01 | (insn << 32) | NOP_RIGHT;	/* left then right */
d743 2
a744 2
	 only by IU cannot be encoded in L-container. */
      
d746 2
a747 1
	insn |= FM00 | NOP_LEFT;		/* right container */
d749 2
a750 1
	insn = FM00 | (insn << 32) | NOP_RIGHT;	/* left container */
d755 1
a755 1
  for (i=0; i < fx->fc; i++) 
d758 2
a759 2
	{ 
	  where = f - frag_now->fr_literal; 
d761 1
a761 1
		       where, 
d768 1
d774 1
d776 1
a776 1
write_2_short (opcode1, insn1, opcode2, insn2, exec_type, fx) 
d784 1
a784 1
  int i,j, where;
d799 1
a799 1
  
d803 1
a803 2
  
  switch (exec_type) 
d805 1
a805 1
    case EXEC_UNKNOWN:	/* Order not specified. */
d814 1
a814 1
	  /* parallel */
d816 1
a816 1
	  
d823 1
a823 1
	      insn = FM00 | (insn1 << 32) | insn2;  
d857 1
a857 1
	  /* reverse sequential */
d863 1
a863 1
	  /* sequential */
d870 1
a870 1
    case EXEC_PARALLEL:	/* parallel */
d879 1
a879 1
 	  insn = FM00 | (insn2 << 32) | insn1;
d895 2
a896 2
	  
	  insn = FM00 | (insn1 << 32) | insn2;  
d902 1
a902 1
    case EXEC_SEQ:	/* sequential */
d907 3
a909 3
		   "`%s' in right container"),
		 opcode1->op->name, opcode2->op->name);
      insn = FM01 | (insn1 << 32) | insn2;  
d913 1
a913 1
    case EXEC_REVSEQ:	/* reverse sequential */
d922 1
a922 1
      insn = FM10 | (insn1 << 32) | insn2;  
d930 3
a932 1
  /*  printf ("writing out %llx\n",insn); */
d942 1
a942 1
  for (j=0; j<2; j++) 
d944 1
a944 1
      for (i=0; i < fx->fc; i++) 
d948 1
a948 1
	      where = (f - frag_now->fr_literal) + 4*j;
d951 1
a951 1
			   where, 
d958 1
a958 1
      
d962 1
a962 1
  
d966 2
a968 2
/* Check 2 instructions and determine if they can be safely */
/* executed in parallel.  Returns 1 if they can be.         */
d981 1
a981 1
  /* section 4.3: both instructions must not be IU or MU only */
d986 1
a986 1
  /* first instruction must not be a jump to safely optimize, unless this
d999 1
a999 1
     return 1;
d1003 1
a1003 2
     [2] a0, a1, flag registers */

d1020 1
a1034 1
	     
d1043 2
a1044 2
      
      /* BSR/JSR always sets R62 */
d1046 1
a1046 1
	mod_reg[j][1] = (1L << (62-32));
d1048 1
a1048 1
      /* conditional execution affects the flags_used */
d1079 3
a1081 4
	      /* this is a post-increment or post-decrement */
	      /* the previous register needs to be marked as modified */

	      shift = 12 - d30v_operand_table[f->operands[i-1]].position;
d1091 2
a1092 1
	      /* the memory write functions don't have a destination register */
d1095 1
a1095 1
		  /* MODIFIED registers and flags */
d1111 2
a1112 2
		      /* need to check if there are two destination */
		      /* registers, for example ld2w */
d1119 1
a1119 1
			{ 
d1129 1
a1129 1
		  /* USED, but not modified registers and flags */
d1145 2
a1146 2
		      /* need to check if there are two source */
		      /* registers, for example st2w */
d1153 1
a1153 1
			{ 
d1164 1
a1164 1
  
a1186 1

d1200 1
a1200 1
      /* If flag_explicitly_parallel is set, then the case of the 
d1205 1
a1205 1
	 flags. */
d1221 5
a1225 5

/* This is the main entry point for the machine-dependent assembler.  str points to a
   machine-dependent instruction.  This function is supposed to emit the frags/bytes 
   it assembles to.  For the D30V, it mostly handles the special VLIW parsing and packing
   and leaves the difficult stuff to do_assemble().  */
d1238 4
a1241 2
  exec_type_enum extype = EXEC_UNKNOWN;		/* execution type; parallel, etc */
  static exec_type_enum etype = EXEC_UNKNOWN;	/* saved extype.  used for multiline instructions */
d1245 1
a1245 1
       && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))
d1258 1
a1258 1
      /* look for the special multiple instruction separators */
d1260 1
a1260 1
      if (str2) 
d1268 1
a1268 1
	  if (str2) 
d1273 1
a1273 1
	      if (str2) 
d1277 3
a1279 2
      /* str2 points to the separator, if one */
      if (str2) 
d1282 3
a1284 3
	  
	  /* if two instructions are present and we already have one saved
	     then first write it out */
d1286 1
a1286 1
	  
d1292 1
a1292 1
	    as_bad (_("First opcode is long.  Unable to mix instructions as specified.")); 
d1329 4
a1332 4
	  && parallel_ok (&prev_opcode, (long)prev_insn,
			  &opcode, (long)insn, extype)
	  && write_2_short (&prev_opcode, (long)prev_insn,
			    &opcode, (long)insn, extype, fixups) == 0)
d1334 1
a1334 1
	  /* no instructions saved */
d1340 4
a1343 3
	  /* Can't parallelize, flush previous instruction and emit a word of NOPS,
	     unless the previous instruction is a NOP, in which case just flush it,
	     as this will generate a word of NOPs for us.  */
d1349 2
a1350 2
	      char * f;
	      
d1357 1
a1357 1
		  
d1367 1
a1367 1
	  
d1375 4
a1378 3
      /* Can't parallelize, flush current instruction and add a sequential NOP. */
      write_1_short (& opcode, (long) insn, fixups->next->next, true);
      
d1390 3
a1392 2
  /* If this is a long instruction, write it and any previous short instruction.  */
  if (opcode.form->form >= LONG) 
d1394 1
a1394 1
      if (extype != EXEC_UNKNOWN) 
d1397 1
a1397 1
      write_long (& opcode, insn, fixups);
d1402 2
a1403 2
	       (& prev_opcode, (long) prev_insn, & opcode,
		(long) insn, extype, fixups) == 0)) 
d1410 1
a1410 1
      if (extype != EXEC_UNKNOWN) 
d1412 1
a1412 1
      
d1423 2
a1424 3

/* do_assemble assembles a single instruction and returns an opcode */
/* it returns -1 (an invalid opcode) on error */
d1429 1
a1429 1
do_assemble (str, opcode, shortp, is_parallel) 
d1435 13
a1447 13
  unsigned char * op_start;
  unsigned char * save;
  unsigned char * op_end;
  char            name [NAME_BUF_LEN];
  int             cmp_hack;
  int             nlen = 0;
  int             fsize = (shortp ? FORCE_SHORT : 0);
  expressionS     myops [6];
  long long       insn;

  /* Drop leading whitespace */
  while (* str == ' ')
    str ++;
d1449 1
a1449 1
  /* find the opcode end */
d1451 1
a1451 1
       * op_end
d1453 1
a1453 1
       && * op_end != '/'
d1466 1
a1466 1
  /* if there is an execution condition code, handle it */
d1470 1
a1470 1
      while ( (i < ECC_MAX) && strncasecmp (d30v_ecc_names[i], op_end + 1, 2))
d1472 1
a1472 1
      
d1478 1
a1478 1
	  as_bad (_("unknown condition code: %s"),tmp);
d1481 3
a1483 1
      /*      printf ("condition code=%d\n",i); */
a1488 1
  
d1490 1
a1490 1
  /* CMP and CMPU change their name based on condition codes */
d1493 2
a1494 2
      int p,i;
      char **str = (char **)d30v_cc_names;
d1500 1
a1500 1
      for (i=1; *str && strncmp (*str, & name[p], 2); i++, str++)
d1503 1
a1503 1
      /* cmpu only supports some condition codes */
d1508 2
a1509 2
	      name[p+2]=0;
	      as_bad (_("cmpu doesn't support condition code %s"),&name[p]);
d1515 2
a1516 2
	  name[p+2]=0;
	  as_bad (_("unknown condition code: %s"),&name[p]);      
d1518 1
a1518 1
      
a1523 2
  
  /*  printf("cmp_hack=%d\n",cmp_hack); */
d1525 6
a1530 2
  /* need to look for .s or .l */
  if (name[nlen-2] == '.')
d1532 1
a1532 1
      switch (name[nlen-1])
d1541 1
a1541 1
      name[nlen-2] = 0;
d1544 2
a1545 2
  /* find the first opcode with the proper name */  
  opcode->op = (struct d30v_opcode *)hash_find (d30v_hash, name);
d1548 1
a1548 1
      as_bad (_("unknown opcode: %s"),name);
d1559 2
a1560 1
	  as_bad (_("operands for opcode `%s' do not match any valid format"), name);
d1566 1
a1566 1
  insn = build_insn (opcode, myops); 
d1568 1
a1568 1
  /* Propigate multiply status */
d1580 1
a1580 1
  /* Propagate left_kills_right status */
d1588 1
a1588 1
	  
d1591 2
a1592 1
	      /* Left kills right for only mvtsys only for PSW/PSWH/PSWL/flags target. */
d1610 2
a1611 1
		  /* Other mvtsys target registers don't kill right instruction. */
d1623 1
a1623 2

/* find_format() gets a pointer to an entry in the format table.
d1625 1
a1625 1
   to choose the correct one.  Returns NULL on error. */
d1634 1
a1634 1
  int numops, match, index, i=0, j, k;
d1639 1
a1639 1
  
d1651 1
a1651 1
      fm = (struct d30v_format *)&d30v_format_table[index];
d1663 1
a1663 1
	      
d1682 1
a1682 1
		        && (X_op != O_absent || num != OPERAND_MINUS))
d1692 1
a1692 1
		  match=0;
d1698 3
a1700 2
		  /* If we have found a register name, but that name also
		     matches a symbol, then re-parse the name as an expression.  */
d1705 1
a1705 1
		      expression (& myops[j]);
d1707 1
a1707 1
		      
d1721 1
a1721 1
		      /* If we're testing for a LONG format, either fits. */
d1729 1
d1731 1
a1731 1
		     fit into the space in the current format? */
d1743 1
a1743 1
			 into the form we're considering. */
d1755 1
a1755 1
		      if (check_range (value, bits, flags)) 
d1762 3
a1764 1
	  /* printf("through the loop: match=%d\n",match);  */
d1777 2
a1778 3
		  as_warn (\
_("Odd numbered register used as target of multi-register instruction"));
	      
d1781 1
a1781 1
	  fm = (struct d30v_format *)&d30v_format_table[++k];
d1783 3
a1785 1
      /* printf("trying another format: i=%d\n",i); */
d1790 3
a1792 3
/* if while processing a fixup, a reloc really needs to be created */
/* then it is done here */
                 
d1807 2
a1808 1
                    _("reloc %d not supported by object file format"), (int)fixp->fx_r_type);
d1822 1
a1822 1
} 
d1829 3
a1831 2
  if (fixp->fx_addsy != (symbolS *)NULL && (!S_IS_DEFINED (fixp->fx_addsy) ||
     (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
d1838 2
a1839 2
     fixS * fixp;
     valueT * valuep;
d1842 1
a1842 1
  char * where;
d1845 1
a1845 1
  
d1848 1
a1848 1
      value = * valuep;
d1852 1
a1852 1
    value = * valuep;
d1856 1
a1856 1
      
d1859 1
a1859 1
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section) 
d1869 1
a1869 1
  
d1874 1
a1874 1
  
d1882 2
a1883 2
	  as_bad (_("line %d: unable to place value %x into a byte"),
		    fixp->fx_line, value);
d1885 1
a1885 1
	* (unsigned char *) where = value;
d1887 1
a1887 1
      
d1893 2
a1894 2
	  as_bad (_("line %d: unable to place value %x into a short"),
		    fixp->fx_line, value);
d1898 1
a1898 1
      
d1909 1
a1909 1
      
d1969 3
a1971 3
      insn |= (value >> 26) & 0x3F;		/* top 6 bits */
      insn2 |= ((value & 0x03FC0000) << 2);	/* next 8 bits */ 
      insn2 |= value & 0x0003FFFF;		/* bottom 18 bits */
d1978 3
a1980 3
      insn |= (value >> 26) & 0x3F;		/* top 6 bits */
      insn2 |= ((value & 0x03FC0000) << 2);	/* next 8 bits */ 
      insn2 |= value & 0x0003FFFF;		/* bottom 18 bits */
d1991 1
a1991 1
	      fixp->fx_line,fixp->fx_r_type);
d1993 1
a1993 1
  
d1997 5
a2002 4
/* d30v_cleanup() is called after the assembler has finished parsing the input 
   file or after a label is defined.  Because the D30V assembler sometimes saves short 
   instructions to see if it can package them with the next instruction, there may
   be a short instruction that still needs written.  */
d2015 2
a2016 1
      write_1_short (&prev_opcode, (long)prev_insn, fixups->next, use_sequential);
d2022 1
d2026 1
a2026 1
static void                      
d2028 3
a2030 3
     char *buf;			/* Return 'nbytes' of chars here. */
     long long value;		/* The value of the bits. */
     int n;			/* Number of bytes in the output. */
d2039 3
d2043 1
a2043 6
/* This function is called at the start of every line. */
/* it checks to see if the first character is a '.' */
/* which indicates the start of a pseudo-op.  If it is, */
/* then write out any unwritten instructions */

void 
d2055 1
a2055 1
static void 
d2068 1
a2068 1
    
a2133 1
  
d2160 6
a2165 6
      symbolS *     sym;
      int           label_seen = false;
      struct frag * old_frag;
      valueT        old_value;
      valueT        new_value;
      
d2171 1
a2171 1
      
@


1.11
log
@Do not allow EITHER_BUT_PREFER_MU opcodes to be packed into reverse
sequential buckets, and warn if the user does so.
@
text
@d882 2
a883 2
	    as_warn (_("Executing %s in IU in parallel with %s may not work"),
		     opcode1->op->name, opcode2->op->name);
d905 1
a905 2
      if (opcode1->op->unit == EITHER_BUT_PREFER_MU
	  || opcode2->op->unit == EITHER_BUT_PREFER_MU)
d908 3
@


1.10
log
@        * config/tc-d30v.c (write_2_short): Disregard opcode1->ecc when
        bundling a non-delayed branch type instruction.
@
text
@d835 1
a835 3
      else if (opcode1->op->unit == IU
	       || (opcode1->op->unit == EITHER
		   && opcode2->op->unit == EITHER_BUT_PREFER_MU))
d837 9
d882 2
a883 1
	    as_warn (_("Executing %s in IU may not work"), opcode2->op->name);
a897 2
      if (opcode2->op->unit == EITHER_BUT_PREFER_MU)
	as_warn (_("Executing %s in IU may not work"), opcode2->op->name);
d905 4
a908 2
      if (opcode2->op->unit == EITHER_BUT_PREFER_MU)
	as_warn (_("Executing %s in IU may not work"), opcode2->op->name);
@


1.9
log
@        * config/tc-d30v.c (check_range): Allow signed or unsigned 32-bit
        quantities.  Correct right shift sign extension.
        (build_insn): Make `number' unsigned long.  Mask top 6 bits of
        32-bit value when shifting into place.
@
text
@d817 1
a817 2
		&& ((opcode1->op->flags_used & FLAG_DELAY) == 0)
		&& ((opcode1->ecc == ECC_AL) || ! Optimizing))
@


1.8
log
@fix sign extension problem with d30v
@
text
@a243 1
  int retval=0;
d245 12
a256 3
  /* don't bother checking 32-bit values */
  if (bits == 32 && sizeof(unsigned long) * CHAR_BIT == 32)
    return 0;
d265 1
a265 1
		: ( (num >> 3) | ((unsigned long)-1 << (32 - 3)) );
d274 1
a274 2
      if (((long)num > max) || ((long)num < min))
	retval = 1;
d280 1
a280 2
      if ((num > max) || (num < min))
	retval = 1;
a281 2
  
  return retval;
d585 1
a585 1
  unsigned int number, id=0;
d660 1
a660 1
	  insn |= (number >> 26);	/* top 6 bits */
d662 2
a663 2
	  insn |= ((number & 0x03FC0000) << 2);  /* next 8 bits */ 
	  insn |= number & 0x0003FFFF;		/* bottom 18 bits */
@


1.7
log
@        * config/tc-d30v.c (parallel_ok): Use FLAG_NOT_WITH_ADDSUBppp to
        determine if an instruction can be used in parallel with an ADDppp
        or SUBppp instruction.
@
text
@a249 4
  /* Sign extend signed values to unsigned long */
  if ((flags & OPERAND_SIGNED) && (num & ((unsigned long)1 << (bits - 1))))
    num |= ((long)-1 << (bits - 1));

@


1.6
log
@
	* config/tc-d30v.c (CHAR_BIT): Define.
	(check_range): Fix bit operations to support integers
	bigger than 32 bits.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 1999 Free Software Foundation.
d1149 2
a1150 2
  /* ST2W/ST4HB combined with ADDppp/SUBppp is illegal.  */
  if (((flags_set1 & (FLAG_MEM | FLAG_2WORD)) == (FLAG_MEM | FLAG_2WORD)
d1152 1
a1152 1
      || ((flags_set2 & (FLAG_MEM | FLAG_2WORD)) == (FLAG_MEM | FLAG_2WORD)
@


1.5
log
@	* config/tc-d30v.c (write_2_short): Don't group repeat instructions
	with the following instruction unless this was specified.
@
text
@d34 8
d247 1
a247 1
  if (bits == 32)
d250 4
d259 3
a261 1
	num = (unsigned long) (((/*signed*/ long) num) >> 3);
d268 2
a269 2
      max = (1 << (bits - 1))-1; 
      min = - (1 << (bits - 1));
d275 1
a275 1
      max = (1 << bits) - 1;
@


1.4
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d802 4
a805 3
      else if (opcode1->op->flags_used & (FLAG_JMP | FLAG_JSR)
	       && ((opcode1->op->flags_used & FLAG_DELAY) == 0)
	       && ((opcode1->ecc == ECC_AL) || ! Optimizing))
d809 3
@


1.3
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d2031 1
a2031 1
  lab->sy_frag = frag_now;
d2113 1
a2113 1
      old_frag  = label->sy_frag;
d2128 1
a2128 1
      for (sym = symbol_lastP; sym != NULL; sym = sym->sy_previous)
d2130 2
a2131 1
	  if (sym->sy_frag == old_frag && S_GET_VALUE (sym) == old_value)
d2134 1
a2134 1
	      sym->sy_frag = frag_now;
d2137 1
a2137 1
	  else if (label_seen && sym->sy_frag != old_frag)
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@a1 1

d1747 2
a1748 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright (C) 1997, 1998 Free Software Foundation.
d219 1
a219 1
      expressionP->X_op_symbol = (struct symbol *)input_line_pointer;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

