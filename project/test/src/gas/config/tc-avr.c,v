head	1.90;
access;
symbols
	binutils-2_24-branch:1.90.0.2
	binutils-2_24-branchpoint:1.90
	binutils-2_21_1:1.74
	binutils-2_23_2:1.83
	binutils-2_23_1:1.83
	binutils-2_23:1.83
	binutils-2_23-branch:1.83.0.2
	binutils-2_23-branchpoint:1.83
	binutils-2_22_branch:1.79.0.4
	binutils-2_22:1.79
	binutils-2_22-branch:1.79.0.2
	binutils-2_22-branchpoint:1.79
	binutils-2_21:1.74
	binutils-2_21-branch:1.74.0.2
	binutils-2_21-branchpoint:1.74
	binutils-2_20_1:1.68.2.1
	binutils-2_20:1.68.2.1
	binutils-arc-20081103-branch:1.60.0.6
	binutils-arc-20081103-branchpoint:1.60
	binutils-2_20-branch:1.68.0.2
	binutils-2_20-branchpoint:1.68
	dje-cgen-play1-branch:1.63.0.2
	dje-cgen-play1-branchpoint:1.63
	arc-20081103-branch:1.60.0.4
	arc-20081103-branchpoint:1.60
	binutils-2_19_1:1.60
	binutils-2_19:1.60
	binutils-2_19-branch:1.60.0.2
	binutils-2_19-branchpoint:1.60
	binutils-2_18:1.38
	binutils-2_18-branch:1.38.0.2
	binutils-2_18-branchpoint:1.38
	binutils-csl-coldfire-4_1-32:1.31.2.1
	binutils-csl-sourcerygxx-4_1-32:1.31.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.31.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.25
	binutils-csl-coldfire-4_1-30:1.31.2.1
	binutils-csl-sourcerygxx-4_1-30:1.31.2.1
	binutils-csl-coldfire-4_1-28:1.31.2.1
	binutils-csl-sourcerygxx-4_1-29:1.31.2.1
	binutils-csl-sourcerygxx-4_1-28:1.31.2.1
	binutils-csl-arm-2006q3-27:1.31.2.1
	binutils-csl-sourcerygxx-4_1-27:1.31.2.1
	binutils-csl-arm-2006q3-26:1.31.2.1
	binutils-csl-sourcerygxx-4_1-26:1.31.2.1
	binutils-csl-sourcerygxx-4_1-25:1.31.2.1
	binutils-csl-sourcerygxx-4_1-24:1.31.2.1
	binutils-csl-sourcerygxx-4_1-23:1.31.2.1
	binutils-csl-sourcerygxx-4_1-21:1.31.2.1
	binutils-csl-arm-2006q3-21:1.31.2.1
	binutils-csl-sourcerygxx-4_1-22:1.31.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.31.2.1
	binutils-csl-sourcerygxx-4_1-20:1.31.2.1
	binutils-csl-arm-2006q3-19:1.31.2.1
	binutils-csl-sourcerygxx-4_1-19:1.31.2.1
	binutils-csl-sourcerygxx-4_1-18:1.31.2.1
	binutils-csl-renesas-4_1-9:1.31.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.25
	binutils-csl-renesas-4_1-8:1.31
	binutils-csl-renesas-4_1-7:1.31
	binutils-csl-renesas-4_1-6:1.31
	binutils-csl-sourcerygxx-4_1-17:1.31
	binutils-csl-sourcerygxx-4_1-14:1.31
	binutils-csl-sourcerygxx-4_1-15:1.31
	binutils-csl-sourcerygxx-4_1-13:1.31
	binutils-2_17:1.32
	binutils-csl-sourcerygxx-4_1-12:1.31
	binutils-csl-sourcerygxx-3_4_4-21:1.31
	binutils-csl-wrs-linux-3_4_4-24:1.25
	binutils-csl-wrs-linux-3_4_4-23:1.25
	binutils-csl-sourcerygxx-4_1-9:1.31
	binutils-csl-sourcerygxx-4_1-8:1.31
	binutils-csl-sourcerygxx-4_1-7:1.31
	binutils-csl-arm-2006q1-6:1.31
	binutils-csl-sourcerygxx-4_1-6:1.31
	binutils-csl-wrs-linux-3_4_4-22:1.25
	binutils-csl-coldfire-4_1-11:1.31
	binutils-csl-sourcerygxx-3_4_4-19:1.31
	binutils-csl-coldfire-4_1-10:1.31
	binutils-csl-sourcerygxx-4_1-5:1.31
	binutils-csl-sourcerygxx-4_1-4:1.31
	binutils-csl-wrs-linux-3_4_4-21:1.25
	binutils-csl-morpho-4_1-4:1.31
	binutils-csl-sourcerygxx-3_4_4-17:1.31
	binutils-csl-wrs-linux-3_4_4-20:1.25
	binutils-2_17-branch:1.32.0.2
	binutils-2_17-branchpoint:1.32
	binutils-csl-2_17-branch:1.31.0.2
	binutils-csl-2_17-branchpoint:1.31
	binutils-csl-gxxpro-3_4-branch:1.25.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.25
	binutils-2_16_1:1.25
	binutils-csl-arm-2005q1b:1.25
	binutils-2_16:1.25
	binutils-csl-arm-2005q1a:1.25
	binutils-csl-arm-2005q1-branch:1.25.0.4
	binutils-csl-arm-2005q1-branchpoint:1.25
	binutils-2_16-branch:1.25.0.2
	binutils-2_16-branchpoint:1.25
	csl-arm-2004-q3d:1.21
	csl-arm-2004-q3:1.21
	binutils-2_15:1.20
	binutils-2_15-branchpoint:1.20
	csl-arm-2004-q1a:1.20
	csl-arm-2004-q1:1.20
	binutils-2_15-branch:1.20.0.8
	cagney_bfdfile-20040213-branch:1.20.0.6
	cagney_bfdfile-20040213-branchpoint:1.20
	cagney_bigcore-20040122-branch:1.20.0.4
	cagney_bigcore-20040122-branchpoint:1.20
	csl-arm-2003-q4:1.20
	binutils-2_14:1.20
	binutils-2_14-branch:1.20.0.2
	binutils-2_14-branchpoint:1.20
	binutils-2_13_2_1:1.17
	binutils-2_13_2:1.17
	binutils-2_13_1:1.17
	binutils-2_13:1.17
	binutils-2_13-branchpoint:1.17
	binutils-2_13-branch:1.17.0.2
	binutils-2_12_1:1.15
	binutils-2_12:1.15
	binutils-2_12-branch:1.15.0.2
	binutils-2_12-branchpoint:1.15
	cygnus_cvs_20020108_pre:1.15
	binutils-2_11_2:1.10.2.1
	binutils-2_11_1:1.10.2.1
	binutils-2_11:1.10
	x86_64versiong3:1.10
	binutils-2_11-branch:1.10.0.2
	binutils-2_10_1:1.1
	binutils-2_10:1.1
	binutils-2_10-branch:1.1.0.2
	binutils-2_10-branchpoint:1.1
	binutils_latest_snapshot:1.90;
locks; strict;
comment	@ * @;


1.90
date	2013.07.18.11.52.47;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2013.07.18.11.47.30;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2013.06.01.07.14.44;	author denisc;	state Exp;
branches;
next	1.87;

1.87
date	2013.04.09.15.39.37;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2013.03.21.14.47.34;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2013.02.05.23.02.54;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2013.01.23.12.01.12;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2012.06.11.14.26.41;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2012.05.16.14.52.15;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.11.12.59.22;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.17.13.59.40;	author rsandifo;	state Exp;
branches;
next	1.79;

1.79
date	2011.03.29.18.16.15;	author rth;	state Exp;
branches;
next	1.78;

1.78
date	2011.03.24.17.03.03;	author eweddington;	state Exp;
branches;
next	1.77;

1.77
date	2011.03.23.15.02.02;	author eweddington;	state Exp;
branches;
next	1.76;

1.76
date	2011.03.22.18.10.44;	author eweddington;	state Exp;
branches;
next	1.75;

1.75
date	2011.03.21.20.25.56;	author eweddington;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.09.03.48.54;	author eweddington;	state Exp;
branches;
next	1.72;

1.72
date	2010.02.23.11.38.36;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.29.09.43.18;	author gingold;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.27.15.39.27;	author gingold;	state Exp;
branches;
next	1.69;

1.69
date	2009.09.08.10.36.38;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2009.08.05.12.47.33;	author eweddington;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.02.14.34.55;	author eweddington;	state Exp;
branches;
next	1.65;

1.65
date	2009.08.01.16.17.23;	author eweddington;	state Exp;
branches;
next	1.64;

1.64
date	2009.07.17.15.22.11;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2009.02.03.17.24.35;	author eweddington;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.26.13.38.52;	author eweddington;	state Exp;
branches;
next	1.61;

1.61
date	2008.12.23.09.51.38;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2008.08.29.16.58.02;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2008.08.09.05.35.13;	author eweddington;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.25.16.19.11;	author eweddington;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.09.16.07.01;	author eweddington;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.30.14.20.27;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.28.21.51.38;	author eweddington;	state Exp;
branches;
next	1.54;

1.54
date	2008.03.28.21.04.22;	author eweddington;	state Exp;
branches;
next	1.53;

1.53
date	2008.03.28.19.24.52;	author eweddington;	state Exp;
branches;
next	1.52;

1.52
date	2008.03.27.14.52.35;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2008.02.14.13.04.29;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.23.17.36.23;	author eweddington;	state Exp;
branches;
next	1.49;

1.49
date	2008.01.16.17.59.07;	author eweddington;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.16.17.39.22;	author eweddington;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.16.17.25.28;	author eweddington;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.07.17.59.05;	author eweddington;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.07.17.24.59;	author eweddington;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.31.18.11.28;	author eweddington;	state Exp;
branches;
next	1.43;

1.43
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.12.16.28.02;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.08.10.39.17;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.08.10.33.27;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.03.14.35.06;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.26.17.18.23;	author denisc;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.02.18.42.36;	author denisc;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.19.16.58.29;	author denisc;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.24.07.36.10;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.07.15.18.08;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.03.15.25.30;	author nickc;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2006.01.11.17.39.49;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.12.10.56.46;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.11.01.25.25;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.05.09.12.54;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.25.20.34.24;	author marekm;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.22.14.25.40;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.26.16.23.03;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.11.13.15.04;	author marekm;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.27.04.38.47;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.09.17.57.09;	author marekm;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.16.19.24.00;	author marekm;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.20.09.33.49;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.15.21.28.54;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.10.09.34.32;	author denisc;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.19.05.33.22;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.15.01.06.52;	author kazu;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.08.06.14.03.58;	author denisc;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.28.00.42.18;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.03.22.25.33;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.27.01.45.30;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.07.18.56.15;	author denisc;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.07.17.42.44;	author denisc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.01.11.14.05;	author denisc;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.01.08.48.32;	author denisc;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.27.08.39.13;	author amodra;	state Exp;
branches;
next	;

1.68.2.1
date	2009.09.08.10.53.21;	author amodra;	state Exp;
branches;
next	;

1.31.2.1
date	2006.08.22.15.08.35;	author jsm28;	state Exp;
branches;
next	;

1.10.2.1
date	2001.06.07.03.15.28;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.90
log
@	* config/tc-avr.c (md_show_usage): Add avrxmega2 to help text
@
text
@/* tc-avr.c -- Assembler code for the ATMEL AVR

   Copyright 1999-2013 Free Software Foundation, Inc.
   Contributed by Denis Chertykov <denisc@@overta.ru>

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"


struct avr_opcodes_s
{
  char *        name;
  char *        constraints;
  char *        opcode;
  int           insn_size;		/* In words.  */
  int           isa;
  unsigned int  bin_opcode;
};

#define AVR_INSN(NAME, CONSTR, OPCODE, SIZE, ISA, BIN) \
{#NAME, CONSTR, OPCODE, SIZE, ISA, BIN},

struct avr_opcodes_s avr_opcodes[] =
{
  #include "opcode/avr.h"
  {NULL, NULL, NULL, 0, 0, 0}
};

const char comment_chars[] = ";";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = "$";

const char *md_shortopts = "m:";
struct mcu_type_s
{
  char *name;
  int isa;
  int mach;
};

/* XXX - devices that don't seem to exist (renamed, replaced with larger
   ones, or planned but never produced), left here for compatibility.  */

static struct mcu_type_s mcu_types[] =
{
  {"avr1",       AVR_ISA_AVR1,    bfd_mach_avr1},
/* TODO: insruction set for avr2 architecture should be AVR_ISA_AVR2,
 but set to AVR_ISA_AVR25 for some following version
 of GCC (from 4.3) for backward compatibility.  */
  {"avr2",       AVR_ISA_AVR25,   bfd_mach_avr2},
  {"avr25",      AVR_ISA_AVR25,   bfd_mach_avr25},
/* TODO: insruction set for avr3 architecture should be AVR_ISA_AVR3,
 but set to AVR_ISA_AVR3_ALL for some following version
 of GCC (from 4.3) for backward compatibility.  */
  {"avr3",       AVR_ISA_AVR3_ALL, bfd_mach_avr3},
  {"avr31",      AVR_ISA_AVR31,   bfd_mach_avr31},
  {"avr35",      AVR_ISA_AVR35,   bfd_mach_avr35},
  {"avr4",       AVR_ISA_AVR4,    bfd_mach_avr4},
/* TODO: insruction set for avr5 architecture should be AVR_ISA_AVR5,
 but set to AVR_ISA_AVR51 for some following version
 of GCC (from 4.3) for backward compatibility.  */
  {"avr5",       AVR_ISA_AVR51,   bfd_mach_avr5},
  {"avr51",      AVR_ISA_AVR51,   bfd_mach_avr51},
  {"avr6",       AVR_ISA_AVR6,    bfd_mach_avr6},
  {"avrxmega1",  AVR_ISA_XMEGA,   bfd_mach_avrxmega1},
  {"avrxmega2",  AVR_ISA_XMEGA,   bfd_mach_avrxmega2},
  {"avrxmega3",  AVR_ISA_XMEGA,   bfd_mach_avrxmega3},
  {"avrxmega4",  AVR_ISA_XMEGA,   bfd_mach_avrxmega4},
  {"avrxmega5",  AVR_ISA_XMEGA,   bfd_mach_avrxmega5},
  {"avrxmega6",  AVR_ISA_XMEGA,   bfd_mach_avrxmega6},
  {"avrxmega7",  AVR_ISA_XMEGA,   bfd_mach_avrxmega7},
  {"at90s1200",  AVR_ISA_1200,    bfd_mach_avr1},
  {"attiny11",   AVR_ISA_AVR1,    bfd_mach_avr1},
  {"attiny12",   AVR_ISA_AVR1,    bfd_mach_avr1},
  {"attiny15",   AVR_ISA_AVR1,    bfd_mach_avr1},
  {"attiny28",   AVR_ISA_AVR1,    bfd_mach_avr1},
  {"at90s2313",  AVR_ISA_AVR2,    bfd_mach_avr2},
  {"at90s2323",  AVR_ISA_AVR2,    bfd_mach_avr2},
  {"at90s2333",  AVR_ISA_AVR2,    bfd_mach_avr2}, /* XXX -> 4433 */
  {"at90s2343",  AVR_ISA_AVR2,    bfd_mach_avr2},
  {"attiny22",   AVR_ISA_AVR2,    bfd_mach_avr2}, /* XXX -> 2343 */
  {"attiny26",   AVR_ISA_2xxe,    bfd_mach_avr2},
  {"at90s4414",  AVR_ISA_AVR2,    bfd_mach_avr2}, /* XXX -> 8515 */
  {"at90s4433",  AVR_ISA_AVR2,    bfd_mach_avr2},
  {"at90s4434",  AVR_ISA_AVR2,    bfd_mach_avr2}, /* XXX -> 8535 */
  {"at90s8515",  AVR_ISA_AVR2,    bfd_mach_avr2},
  {"at90c8534",  AVR_ISA_AVR2,    bfd_mach_avr2},
  {"at90s8535",  AVR_ISA_AVR2,    bfd_mach_avr2},
  {"attiny13",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny13a",  AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny2313", AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny2313a",AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny24",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny24a",  AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny4313", AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny44",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny44a",  AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny84",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny84a",  AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny25",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny45",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny85",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny261",  AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny261a", AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny461",  AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny461a", AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny861",  AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny861a", AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny87",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny43u",  AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny48",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"attiny88",   AVR_ISA_AVR25,   bfd_mach_avr25},
  {"at86rf401",  AVR_ISA_RF401,   bfd_mach_avr25},
  {"at43usb355", AVR_ISA_AVR3,    bfd_mach_avr3},
  {"at76c711",   AVR_ISA_AVR3,    bfd_mach_avr3},
  {"atmega103",  AVR_ISA_AVR31,   bfd_mach_avr31},
  {"at43usb320", AVR_ISA_AVR31,   bfd_mach_avr31},
  {"attiny167",  AVR_ISA_AVR35,   bfd_mach_avr35},
  {"at90usb82",  AVR_ISA_AVR35,   bfd_mach_avr35},
  {"at90usb162", AVR_ISA_AVR35,   bfd_mach_avr35},
  {"atmega8u2",  AVR_ISA_AVR35,   bfd_mach_avr35},
  {"atmega16u2", AVR_ISA_AVR35,   bfd_mach_avr35},
  {"atmega32u2", AVR_ISA_AVR35,   bfd_mach_avr35},
  {"atmega8",    AVR_ISA_M8,      bfd_mach_avr4},
  {"ata6289",    AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega48",   AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega48a",  AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega48p",  AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega88",   AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega88a",  AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega88p",  AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega88pa", AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega8515", AVR_ISA_M8,      bfd_mach_avr4},
  {"atmega8535", AVR_ISA_M8,      bfd_mach_avr4},
  {"atmega8hva", AVR_ISA_AVR4,    bfd_mach_avr4},
  {"at90pwm1",   AVR_ISA_AVR4,    bfd_mach_avr4},
  {"at90pwm2",   AVR_ISA_AVR4,    bfd_mach_avr4},
  {"at90pwm2b",  AVR_ISA_AVR4,    bfd_mach_avr4},
  {"at90pwm3",   AVR_ISA_AVR4,    bfd_mach_avr4},
  {"at90pwm3b",  AVR_ISA_AVR4,    bfd_mach_avr4},
  {"at90pwm81",  AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega16",   AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega16a",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega161",  AVR_ISA_M161,    bfd_mach_avr5},
  {"atmega162",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega163",  AVR_ISA_M161,    bfd_mach_avr5},
  {"atmega164a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega164p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega165",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega165a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega165p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega168",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega168a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega168p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega169",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega169a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega169p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega169pa",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega32",   AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega323",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega324a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega324p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega324pa",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega325",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega325a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega325p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega325pa",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega3250", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega3250a",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega3250p",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega3250pa",AVR_ISA_AVR5,   bfd_mach_avr5},
  {"atmega328",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega328p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega329",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega329a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega329p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega329pa",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega3290", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega3290a",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega3290p",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega3290pa",AVR_ISA_AVR5,   bfd_mach_avr5},
  {"atmega406",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega64",   AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega640",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega644",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega644a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega644p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega644pa",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega645",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega645a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega645p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega649",  AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega649a", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega649p", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega6450", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega6450a",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega6450p",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega6490", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega6490a",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega6490p",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega64rfr2",AVR_ISA_AVR5,   bfd_mach_avr5},
  {"atmega644rfr2",AVR_ISA_AVR5,  bfd_mach_avr5},
  {"atmega16hva",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega16hva2",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega16hvb",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega16hvbrevb",AVR_ISA_AVR5,bfd_mach_avr5},
  {"atmega32hvb",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega32hvbrevb",AVR_ISA_AVR5,bfd_mach_avr5},
  {"atmega64hve",AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at90can32" , AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at90can64" , AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at90pwm161", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at90pwm216", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at90pwm316", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega32c1", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega64c1", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega16m1", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega32m1", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega64m1", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega16u4", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega32u4", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega32u6", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at90usb646", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at90usb647", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at90scr100", AVR_ISA_AVR5,    bfd_mach_avr5},
  {"at94k",      AVR_ISA_94K,     bfd_mach_avr5},
  {"m3000",      AVR_ISA_AVR5,    bfd_mach_avr5},
  {"atmega128",  AVR_ISA_AVR51,   bfd_mach_avr51},
  {"atmega1280", AVR_ISA_AVR51,   bfd_mach_avr51},
  {"atmega1281", AVR_ISA_AVR51,   bfd_mach_avr51},
  {"atmega1284p",AVR_ISA_AVR51,   bfd_mach_avr51},
  {"atmega128rfa1",AVR_ISA_AVR51, bfd_mach_avr51},
  {"atmega128rfr2",AVR_ISA_AVR51, bfd_mach_avr51},
  {"atmega1284rfr2",AVR_ISA_AVR51, bfd_mach_avr51},
  {"at90can128", AVR_ISA_AVR51,   bfd_mach_avr51},
  {"at90usb1286",AVR_ISA_AVR51,   bfd_mach_avr51},
  {"at90usb1287",AVR_ISA_AVR51,   bfd_mach_avr51},
  {"atmega2560", AVR_ISA_AVR6,    bfd_mach_avr6},
  {"atmega2561", AVR_ISA_AVR6,    bfd_mach_avr6},
  {"atmega256rfr2", AVR_ISA_AVR6, bfd_mach_avr6},
  {"atmega2564rfr2", AVR_ISA_AVR6, bfd_mach_avr6},
  {"atxmega16a4", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
  {"atxmega16d4", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
  {"atxmega16x1", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
  {"atxmega32a4", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
  {"atxmega32d4", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
  {"atxmega32x1", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
  {"atxmega64a3", AVR_ISA_XMEGA,  bfd_mach_avrxmega4},
  {"atxmega64d3", AVR_ISA_XMEGA,  bfd_mach_avrxmega4},
  {"atxmega64a1", AVR_ISA_XMEGA,  bfd_mach_avrxmega5},
  {"atxmega64a1u",AVR_ISA_XMEGAU, bfd_mach_avrxmega5},
  {"atxmega128a3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
  {"atxmega128b1", AVR_ISA_XMEGAU, bfd_mach_avrxmega6},
  {"atxmega128d3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
  {"atxmega192a3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
  {"atxmega192d3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
  {"atxmega256a3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
  {"atxmega256a3b",AVR_ISA_XMEGA, bfd_mach_avrxmega6},
  {"atxmega256a3bu",AVR_ISA_XMEGAU, bfd_mach_avrxmega6},
  {"atxmega256d3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
  {"atxmega128a1", AVR_ISA_XMEGA, bfd_mach_avrxmega7},
  {"atxmega128a1u", AVR_ISA_XMEGAU, bfd_mach_avrxmega7},
  {NULL, 0, 0}
};

/* Current MCU type.  */
static struct mcu_type_s   default_mcu = {"avr2", AVR_ISA_AVR2, bfd_mach_avr2};
static struct mcu_type_s * avr_mcu = & default_mcu;

/* AVR target-specific switches.  */
struct avr_opt_s
{
  int all_opcodes;  /* -mall-opcodes: accept all known AVR opcodes.  */
  int no_skip_bug;  /* -mno-skip-bug: no warnings for skipping 2-word insns.  */
  int no_wrap;      /* -mno-wrap: reject rjmp/rcall with 8K wrap-around.  */
};

static struct avr_opt_s avr_opt = { 0, 0, 0 };

const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "dD";

static void avr_set_arch (int);

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  {"arch", avr_set_arch,	0},
  { NULL,	NULL,		0}
};

#define LDI_IMMEDIATE(x) (((x) & 0xf) | (((x) << 4) & 0xf00))

#define EXP_MOD_NAME(i)       exp_mod[i].name
#define EXP_MOD_RELOC(i)      exp_mod[i].reloc
#define EXP_MOD_NEG_RELOC(i)  exp_mod[i].neg_reloc
#define HAVE_PM_P(i)          exp_mod[i].have_pm

struct exp_mod_s
{
  char *                    name;
  bfd_reloc_code_real_type  reloc;
  bfd_reloc_code_real_type  neg_reloc;
  int                       have_pm;
};

static struct exp_mod_s exp_mod[] =
{
  {"hh8",    BFD_RELOC_AVR_HH8_LDI,    BFD_RELOC_AVR_HH8_LDI_NEG,    1},
  {"pm_hh8", BFD_RELOC_AVR_HH8_LDI_PM, BFD_RELOC_AVR_HH8_LDI_PM_NEG, 0},
  {"hi8",    BFD_RELOC_AVR_HI8_LDI,    BFD_RELOC_AVR_HI8_LDI_NEG,    1},
  {"pm_hi8", BFD_RELOC_AVR_HI8_LDI_PM, BFD_RELOC_AVR_HI8_LDI_PM_NEG, 0},
  {"lo8",    BFD_RELOC_AVR_LO8_LDI,    BFD_RELOC_AVR_LO8_LDI_NEG,    1},
  {"pm_lo8", BFD_RELOC_AVR_LO8_LDI_PM, BFD_RELOC_AVR_LO8_LDI_PM_NEG, 0},
  {"hlo8",   BFD_RELOC_AVR_HH8_LDI,    BFD_RELOC_AVR_HH8_LDI_NEG,    0},
  {"hhi8",   BFD_RELOC_AVR_MS8_LDI,    BFD_RELOC_AVR_MS8_LDI_NEG,    0},
};

/* A union used to store indicies into the exp_mod[] array
   in a hash table which expects void * data types.  */
typedef union
{
  void * ptr;
  int    index;
} mod_index;

/* Opcode hash table.  */
static struct hash_control *avr_hash;

/* Reloc modifiers hash control (hh8,hi8,lo8,pm_xx).  */
static struct hash_control *avr_mod_hash;

#define OPTION_MMCU 'm'
enum options
{
  OPTION_ALL_OPCODES = OPTION_MD_BASE + 1,
  OPTION_NO_SKIP_BUG,
  OPTION_NO_WRAP
};

struct option md_longopts[] =
{
  { "mmcu",   required_argument, NULL, OPTION_MMCU        },
  { "mall-opcodes", no_argument, NULL, OPTION_ALL_OPCODES },
  { "mno-skip-bug", no_argument, NULL, OPTION_NO_SKIP_BUG },
  { "mno-wrap",     no_argument, NULL, OPTION_NO_WRAP     },
  { NULL, no_argument, NULL, 0 }
};

size_t md_longopts_size = sizeof (md_longopts);

/* Display nicely formatted list of known MCU names.  */

static void
show_mcu_list (FILE *stream)
{
  int i, x;

  fprintf (stream, _("Known MCU names:"));
  x = 1000;

  for (i = 0; mcu_types[i].name; i++)
    {
      int len = strlen (mcu_types[i].name);

      x += len + 1;

      if (x < 75)
	fprintf (stream, " %s", mcu_types[i].name);
      else
	{
	  fprintf (stream, "\n  %s", mcu_types[i].name);
	  x = len + 2;
	}
    }

  fprintf (stream, "\n");
}

static inline char *
skip_space (char *s)
{
  while (*s == ' ' || *s == '\t')
    ++s;
  return s;
}

/* Extract one word from FROM and copy it to TO.  */

static char *
extract_word (char *from, char *to, int limit)
{
  char *op_end;
  int size = 0;

  /* Drop leading whitespace.  */
  from = skip_space (from);
  *to = 0;

  /* Find the op code end.  */
  for (op_end = from; *op_end != 0 && is_part_of_name (*op_end);)
    {
      to[size++] = *op_end++;
      if (size + 1 >= limit)
	break;
    }

  to[size] = 0;
  return op_end;
}

int
md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
			       asection *seg ATTRIBUTE_UNUSED)
{
  abort ();
  return 0;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream,
      _("AVR Assembler options:\n"
	"  -mmcu=[avr-name] select microcontroller variant\n"
	"                   [avr-name] can be:\n"
	"                   avr1  - classic AVR core without data RAM\n"
	"                   avr2  - classic AVR core with up to 8K program memory\n"
	"                   avr25 - classic AVR core with up to 8K program memory\n"
	"                           plus the MOVW instruction\n"
	"                   avr3  - classic AVR core with up to 64K program memory\n"
	"                   avr31 - classic AVR core with up to 128K program memory\n"
	"                   avr35 - classic AVR core with up to 64K program memory\n"
	"                           plus the MOVW instruction\n"
	"                   avr4  - enhanced AVR core with up to 8K program memory\n"
	"                   avr5  - enhanced AVR core with up to 64K program memory\n"
	"                   avr51 - enhanced AVR core with up to 128K program memory\n"
	"                   avr6  - enhanced AVR core with up to 256K program memory\n"
	"                   avrxmega2 - XMEGA, > 8K, < 64K FLASH, < 64K RAM\n"
	"                   avrxmega3 - XMEGA, > 8K, <= 64K FLASH, > 64K RAM\n"
	"                   avrxmega4 - XMEGA, > 64K, <= 128K FLASH, <= 64K RAM\n"
	"                   avrxmega5 - XMEGA, > 64K, <= 128K FLASH, > 64K RAM\n"
	"                   avrxmega6 - XMEGA, > 128K, <= 256K FLASH, <= 64K RAM\n"
	"                   avrxmega7 - XMEGA, > 128K, <= 256K FLASH, > 64K RAM\n"
	"                   or immediate microcontroller name.\n"));
  fprintf (stream,
      _("  -mall-opcodes    accept all AVR opcodes, even if not supported by MCU\n"
	"  -mno-skip-bug    disable warnings for skipping two-word instructions\n"
	"                   (default for avr4, avr5)\n"
	"  -mno-wrap        reject rjmp/rcall instructions with 8K wrap-around\n"
	"                   (default for avr3, avr5)\n"));
  show_mcu_list (stream);
}

static void
avr_set_arch (int dummy ATTRIBUTE_UNUSED)
{
  char str[20];

  input_line_pointer = extract_word (input_line_pointer, str, 20);
  md_parse_option (OPTION_MMCU, str);
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, avr_mcu->mach);
}

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case OPTION_MMCU:
      {
	int i;
	char *s = alloca (strlen (arg) + 1);

	{
	  char *t = s;
	  char *arg1 = arg;

	  do
	    *t = TOLOWER (*arg1++);
	  while (*t++);
	}

	for (i = 0; mcu_types[i].name; ++i)
	  if (strcmp (mcu_types[i].name, s) == 0)
	    break;

	if (!mcu_types[i].name)
	  {
	    show_mcu_list (stderr);
	    as_fatal (_("unknown MCU: %s\n"), arg);
	  }

	/* It is OK to redefine mcu type within the same avr[1-5] bfd machine
	   type - this for allows passing -mmcu=... via gcc ASM_SPEC as well
	   as .arch ... in the asm output at the same time.  */
	if (avr_mcu == &default_mcu || avr_mcu->mach == mcu_types[i].mach)
	  avr_mcu = &mcu_types[i];
	else
	  as_fatal (_("redefinition of mcu type `%s' to `%s'"),
		    avr_mcu->name, mcu_types[i].name);
	return 1;
      }
    case OPTION_ALL_OPCODES:
      avr_opt.all_opcodes = 1;
      return 1;
    case OPTION_NO_SKIP_BUG:
      avr_opt.no_skip_bug = 1;
      return 1;
    case OPTION_NO_WRAP:
      avr_opt.no_wrap = 1;
      return 1;
    }

  return 0;
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, FALSE);
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
  abort ();
}

void
md_begin (void)
{
  unsigned int i;
  struct avr_opcodes_s *opcode;

  avr_hash = hash_new ();

  /* Insert unique names into hash table.  This hash table then provides a
     quick index to the first opcode with a particular name in the opcode
     table.  */
  for (opcode = avr_opcodes; opcode->name; opcode++)
    hash_insert (avr_hash, opcode->name, (char *) opcode);

  avr_mod_hash = hash_new ();

  for (i = 0; i < ARRAY_SIZE (exp_mod); ++i)
    {
      mod_index m;

      m.index = i + 10;
      hash_insert (avr_mod_hash, EXP_MOD_NAME (i), m.ptr);
    }

  bfd_set_arch_mach (stdoutput, TARGET_ARCH, avr_mcu->mach);
}

/* Resolve STR as a constant expression and return the result.
   If result greater than MAX then error.  */

static unsigned int
avr_get_constant (char *str, int max)
{
  expressionS ex;

  str = skip_space (str);
  input_line_pointer = str;
  expression (& ex);

  if (ex.X_op != O_constant)
    as_bad (_("constant value required"));

  if (ex.X_add_number > max || ex.X_add_number < 0)
    as_bad (_("number must be positive and less than %d"), max + 1);

  return ex.X_add_number;
}

/* Parse for ldd/std offset.  */

static void
avr_offset_expression (expressionS *exp)
{
  char *str = input_line_pointer;
  char *tmp;
  char op[8];

  tmp = str;
  str = extract_word (str, op, sizeof (op));

  input_line_pointer = tmp;
  expression (exp);

  /* Warn about expressions that fail to use lo8 ().  */
  if (exp->X_op == O_constant)
    {
      int x = exp->X_add_number;

      if (x < -255 || x > 255)
	as_warn (_("constant out of 8-bit range: %d"), x);
    }
}

/* Parse ordinary expression.  */

static char *
parse_exp (char *s, expressionS *op)
{
  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  return input_line_pointer;
}

/* Parse special expressions (needed for LDI command):
   xx8 (address)
   xx8 (-address)
   pm_xx8 (address)
   pm_xx8 (-address)
   where xx is: hh, hi, lo.  */

static bfd_reloc_code_real_type
avr_ldi_expression (expressionS *exp)
{
  char *str = input_line_pointer;
  char *tmp;
  char op[8];
  int mod;
  int linker_stubs_should_be_generated = 0;

  tmp = str;

  str = extract_word (str, op, sizeof (op));

  if (op[0])
    {
      mod_index m;

      m.ptr = hash_find (avr_mod_hash, op);
      mod = m.index;

      if (mod)
	{
	  int closes = 0;

	  mod -= 10;
	  str = skip_space (str);

	  if (*str == '(')
	    {
	      bfd_reloc_code_real_type  reloc_to_return;
	      int neg_p = 0;

	      ++str;

	      if (strncmp ("pm(", str, 3) == 0
                  || strncmp ("gs(",str,3) == 0
                  || strncmp ("-(gs(",str,5) == 0
		  || strncmp ("-(pm(", str, 5) == 0)
		{
		  if (HAVE_PM_P (mod))
		    {
		      ++mod;
		      ++closes;
		    }
		  else
		    as_bad (_("illegal expression"));

                  if (str[0] == 'g' || str[2] == 'g')
                    linker_stubs_should_be_generated = 1;

		  if (*str == '-')
		    {
		      neg_p = 1;
		      ++closes;
		      str += 5;
		    }
		  else
		    str += 3;
		}

	      if (*str == '-' && *(str + 1) == '(')
		{
		  neg_p ^= 1;
		  ++closes;
		  str += 2;
		}

	      input_line_pointer = str;
	      expression (exp);

	      do
		{
		  if (*input_line_pointer != ')')
		    {
		      as_bad (_("`)' required"));
		      break;
		    }
		  input_line_pointer++;
		}
	      while (closes--);

	      reloc_to_return =
		neg_p ? EXP_MOD_NEG_RELOC (mod) : EXP_MOD_RELOC (mod);
	      if (linker_stubs_should_be_generated)
		{
		  switch (reloc_to_return)
		    {
		    case BFD_RELOC_AVR_LO8_LDI_PM:
		      reloc_to_return = BFD_RELOC_AVR_LO8_LDI_GS;
		      break;
		    case BFD_RELOC_AVR_HI8_LDI_PM:
		      reloc_to_return = BFD_RELOC_AVR_HI8_LDI_GS;
		      break;

		    default:
		      /* PR 5523: Do not generate a warning here,
			 legitimate code can trigger this case.  */
		      break;
		    }
		}
	      return reloc_to_return;
	    }
	}
    }

  input_line_pointer = tmp;
  expression (exp);

  /* Warn about expressions that fail to use lo8 ().  */
  if (exp->X_op == O_constant)
    {
      int x = exp->X_add_number;

      if (x < -255 || x > 255)
	as_warn (_("constant out of 8-bit range: %d"), x);
    }

  return BFD_RELOC_AVR_LDI;
}

/* Parse one instruction operand.
   Return operand bitmask.  Also fixups can be generated.  */

static unsigned int
avr_operand (struct avr_opcodes_s *opcode,
	     int where,
	     char *op,
	     char **line)
{
  expressionS op_expr;
  unsigned int op_mask = 0;
  char *str = skip_space (*line);

  switch (*op)
    {
      /* Any register operand.  */
    case 'w':
    case 'd':
    case 'r':
    case 'a':
    case 'v':
      if (*str == 'r' || *str == 'R')
	{
	  char r_name[20];

	  str = extract_word (str, r_name, sizeof (r_name));
	  op_mask = 0xff;
	  if (ISDIGIT (r_name[1]))
	    {
	      if (r_name[2] == '\0')
		op_mask = r_name[1] - '0';
	      else if (r_name[1] != '0'
		       && ISDIGIT (r_name[2])
		       && r_name[3] == '\0')
		op_mask = (r_name[1] - '0') * 10 + r_name[2] - '0';
	    }
	}
      else
	{
	  op_mask = avr_get_constant (str, 31);
	  str = input_line_pointer;
	}

      if (op_mask <= 31)
	{
	  switch (*op)
	    {
	    case 'a':
	      if (op_mask < 16 || op_mask > 23)
		as_bad (_("register r16-r23 required"));
	      op_mask -= 16;
	      break;

	    case 'd':
	      if (op_mask < 16)
		as_bad (_("register number above 15 required"));
	      op_mask -= 16;
	      break;

	    case 'v':
	      if (op_mask & 1)
		as_bad (_("even register number required"));
	      op_mask >>= 1;
	      break;

	    case 'w':
	      if ((op_mask & 1) || op_mask < 24)
		as_bad (_("register r24, r26, r28 or r30 required"));
	      op_mask = (op_mask - 24) >> 1;
	      break;
	    }
	  break;
	}
      as_bad (_("register name or number from 0 to 31 required"));
      break;

    case 'e':
      {
	char c;

	if (*str == '-')
	  {
	    str = skip_space (str + 1);
	    op_mask = 0x1002;
	  }
	c = TOLOWER (*str);
	if (c == 'x')
	  op_mask |= 0x100c;
	else if (c == 'y')
	  op_mask |= 0x8;
	else if (c != 'z')
	  as_bad (_("pointer register (X, Y or Z) required"));

	str = skip_space (str + 1);
	if (*str == '+')
	  {
	    ++str;
	    if (op_mask & 2)
	      as_bad (_("cannot both predecrement and postincrement"));
	    op_mask |= 0x1001;
	  }

	/* avr1 can do "ld r,Z" and "st Z,r" but no other pointer
	   registers, no predecrement, no postincrement.  */
	if (!avr_opt.all_opcodes && (op_mask & 0x100F)
	    && !(avr_mcu->isa & AVR_ISA_SRAM))
	  as_bad (_("addressing mode not supported"));
      }
      break;

    case 'z':
      if (*str == '-')
	as_bad (_("can't predecrement"));

      if (! (*str == 'z' || *str == 'Z'))
	as_bad (_("pointer register Z required"));

      str = skip_space (str + 1);

      if (*str == '+')
	{
	  ++str;
          char *s;
          for (s = opcode->opcode; *s; ++s)
            {
              if (*s == '+')
                op_mask |= (1 << (15 - (s - opcode->opcode)));
            }
	}

      /* attiny26 can do "lpm" and "lpm r,Z" but not "lpm r,Z+".  */
      if (!avr_opt.all_opcodes
	  && (op_mask & 0x0001)
	  && !(avr_mcu->isa & AVR_ISA_MOVW))
	as_bad (_("postincrement not supported"));
      break;

    case 'b':
      {
	char c = TOLOWER (*str++);

	if (c == 'y')
	  op_mask |= 0x8;
	else if (c != 'z')
	  as_bad (_("pointer register (Y or Z) required"));
	str = skip_space (str);
	if (*str++ == '+')
	  {
	    input_line_pointer = str;
	    avr_offset_expression (& op_expr);
	    str = input_line_pointer;
	    fix_new_exp (frag_now, where, 3,
			 &op_expr, FALSE, BFD_RELOC_AVR_6);
	  }
      }
      break;

    case 'h':
      str = parse_exp (str, &op_expr);
      fix_new_exp (frag_now, where, opcode->insn_size * 2,
		   &op_expr, FALSE, BFD_RELOC_AVR_CALL);
      break;

    case 'L':
      str = parse_exp (str, &op_expr);
      fix_new_exp (frag_now, where, opcode->insn_size * 2,
		   &op_expr, TRUE, BFD_RELOC_AVR_13_PCREL);
      break;

    case 'l':
      str = parse_exp (str, &op_expr);
      fix_new_exp (frag_now, where, opcode->insn_size * 2,
		   &op_expr, TRUE, BFD_RELOC_AVR_7_PCREL);
      break;

    case 'i':
      str = parse_exp (str, &op_expr);
      fix_new_exp (frag_now, where + 2, opcode->insn_size * 2,
		   &op_expr, FALSE, BFD_RELOC_16);
      break;

    case 'M':
      {
	bfd_reloc_code_real_type r_type;

	input_line_pointer = str;
	r_type = avr_ldi_expression (&op_expr);
	str = input_line_pointer;
	fix_new_exp (frag_now, where, 3,
		     &op_expr, FALSE, r_type);
      }
      break;

    case 'n':
      {
	unsigned int x;

	x = ~avr_get_constant (str, 255);
	str = input_line_pointer;
	op_mask |= (x & 0xf) | ((x << 4) & 0xf00);
      }
      break;

    case 'K':
      input_line_pointer = str;
      avr_offset_expression (& op_expr);
      str = input_line_pointer;
      fix_new_exp (frag_now, where, 3,
		   & op_expr, FALSE, BFD_RELOC_AVR_6_ADIW);
      break;

    case 'S':
    case 's':
      {
	unsigned int x;

	x = avr_get_constant (str, 7);
	str = input_line_pointer;
	if (*op == 'S')
	  x <<= 4;
	op_mask |= x;
      }
      break;

    case 'P':
      {
	unsigned int x;

	x = avr_get_constant (str, 63);
	str = input_line_pointer;
	op_mask |= (x & 0xf) | ((x & 0x30) << 5);
      }
      break;

    case 'p':
      {
	unsigned int x;

	x = avr_get_constant (str, 31);
	str = input_line_pointer;
	op_mask |= x << 3;
      }
      break;

    case 'E':
      {
	unsigned int x;

	x = avr_get_constant (str, 15);
	str = input_line_pointer;
	op_mask |= (x << 4);
      }
      break;

    case '?':
      break;

    default:
      as_bad (_("unknown constraint `%c'"), *op);
    }

  *line = str;
  return op_mask;
}

/* Parse instruction operands.
   Return binary opcode.  */

static unsigned int
avr_operands (struct avr_opcodes_s *opcode, char **line)
{
  char *op = opcode->constraints;
  unsigned int bin = opcode->bin_opcode;
  char *frag = frag_more (opcode->insn_size * 2);
  char *str = *line;
  int where = frag - frag_now->fr_literal;
  static unsigned int prev = 0;  /* Previous opcode.  */

  /* Opcode have operands.  */
  if (*op)
    {
      unsigned int reg1 = 0;
      unsigned int reg2 = 0;
      int reg1_present = 0;
      int reg2_present = 0;

      /* Parse first operand.  */
      if (REGISTER_P (*op))
	reg1_present = 1;
      reg1 = avr_operand (opcode, where, op, &str);
      ++op;

      /* Parse second operand.  */
      if (*op)
	{
	  if (*op == ',')
	    ++op;

	  if (*op == '=')
	    {
	      reg2 = reg1;
	      reg2_present = 1;
	    }
	  else
	    {
	      if (REGISTER_P (*op))
		reg2_present = 1;

	      str = skip_space (str);
	      if (*str++ != ',')
		as_bad (_("`,' required"));
	      str = skip_space (str);

	      reg2 = avr_operand (opcode, where, op, &str);
	    }

	  if (reg1_present && reg2_present)
	    reg2 = (reg2 & 0xf) | ((reg2 << 5) & 0x200);
	  else if (reg2_present)
	    reg2 <<= 4;
	}
      if (reg1_present)
	reg1 <<= 4;
      bin |= reg1 | reg2;
    }

  /* Detect undefined combinations (like ld r31,Z+).  */
  if (!avr_opt.all_opcodes && AVR_UNDEF_P (bin))
    as_warn (_("undefined combination of operands"));

  if (opcode->insn_size == 2)
    {
      /* Warn if the previous opcode was cpse/sbic/sbis/sbrc/sbrs
         (AVR core bug, fixed in the newer devices).  */
      if (!(avr_opt.no_skip_bug ||
            (avr_mcu->isa & (AVR_ISA_MUL | AVR_ISA_MOVW)))
	  && AVR_SKIP_P (prev))
	as_warn (_("skipping two-word instruction"));

      bfd_putl32 ((bfd_vma) bin, frag);
    }
  else
    bfd_putl16 ((bfd_vma) bin, frag);

  prev = bin;
  *line = str;
  return bin;
}

/* GAS will call this function for each section at the end of the assembly,
   to permit the CPU backend to adjust the alignment of a section.  */

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

/* If you define this macro, it should return the offset between the
   address of a PC relative fixup and the position from which the PC
   relative adjustment should be made.  On many processors, the base
   of a PC relative instruction is the next instruction, so this
   macro would return the length of an instruction.  */

long
md_pcrel_from_section (fixS *fixp, segT sec)
{
  if (fixp->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
    return 0;

  return fixp->fx_frag->fr_address + fixp->fx_where;
}

/* GAS will call this for each fixup.  It should store the correct
   value in the object file.  */

void
md_apply_fix (fixS *fixP, valueT * valP, segT seg)
{
  unsigned char *where;
  unsigned long insn;
  long value = *valP;

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  else if (fixP->fx_pcrel)
    {
      segT s = S_GET_SEGMENT (fixP->fx_addsy);

      if (s == seg || s == absolute_section)
	{
	  value += S_GET_VALUE (fixP->fx_addsy);
	  fixP->fx_done = 1;
	}
    }

  /* We don't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != (symbolS *) NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));

  switch (fixP->fx_r_type)
    {
    default:
      fixP->fx_no_overflow = 1;
      break;
    case BFD_RELOC_AVR_7_PCREL:
    case BFD_RELOC_AVR_13_PCREL:
    case BFD_RELOC_32:
    case BFD_RELOC_16:
    case BFD_RELOC_AVR_CALL:
      break;
    }

  if (fixP->fx_done)
    {
      /* Fetch the instruction, insert the fully resolved operand
	 value, and stuff the instruction back again.  */
      where = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
      insn = bfd_getl16 (where);

      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_AVR_7_PCREL:
	  if (value & 1)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("odd address operand: %ld"), value);

	  /* Instruction addresses are always right-shifted by 1.  */
	  value >>= 1;
	  --value;			/* Correct PC.  */

	  if (value < -64 || value > 63)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("operand out of range: %ld"), value);
	  value = (value << 3) & 0x3f8;
	  bfd_putl16 ((bfd_vma) (value | insn), where);
	  break;

	case BFD_RELOC_AVR_13_PCREL:
	  if (value & 1)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("odd address operand: %ld"), value);

	  /* Instruction addresses are always right-shifted by 1.  */
	  value >>= 1;
	  --value;			/* Correct PC.  */

	  if (value < -2048 || value > 2047)
	    {
	      /* No wrap for devices with >8K of program memory.  */
	      if ((avr_mcu->isa & AVR_ISA_MEGA) || avr_opt.no_wrap)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("operand out of range: %ld"), value);
	    }

	  value &= 0xfff;
	  bfd_putl16 ((bfd_vma) (value | insn), where);
	  break;

	case BFD_RELOC_32:
	  bfd_putl32 ((bfd_vma) value, where);
	  break;

	case BFD_RELOC_16:
	  bfd_putl16 ((bfd_vma) value, where);
	  break;

	case BFD_RELOC_8:
          if (value > 255 || value < -128)
	    as_warn_where (fixP->fx_file, fixP->fx_line,
                           _("operand out of range: %ld"), value);
          *where = value;
	  break;

	case BFD_RELOC_AVR_16_PM:
	  bfd_putl16 ((bfd_vma) (value >> 1), where);
	  break;

	case BFD_RELOC_AVR_LDI:
	  if (value > 255)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("operand out of range: %ld"), value);
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value), where);
	  break;

	case BFD_RELOC_AVR_6:
	  if ((value > 63) || (value < 0))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("operand out of range: %ld"), value);
	  bfd_putl16 ((bfd_vma) insn | ((value & 7) | ((value & (3 << 3)) << 7) | ((value & (1 << 5)) << 8)), where);
	  break;

	case BFD_RELOC_AVR_6_ADIW:
	  if ((value > 63) || (value < 0))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("operand out of range: %ld"), value);
	  bfd_putl16 ((bfd_vma) insn | (value & 0xf) | ((value & 0x30) << 2), where);
	  break;

	case BFD_RELOC_AVR_LO8_LDI:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value), where);
	  break;

	case BFD_RELOC_AVR_HI8_LDI:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 8), where);
	  break;

	case BFD_RELOC_AVR_MS8_LDI:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 24), where);
	  break;

	case BFD_RELOC_AVR_HH8_LDI:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 16), where);
	  break;

	case BFD_RELOC_AVR_LO8_LDI_NEG:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value), where);
	  break;

	case BFD_RELOC_AVR_HI8_LDI_NEG:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 8), where);
	  break;

	case BFD_RELOC_AVR_MS8_LDI_NEG:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 24), where);
	  break;

	case BFD_RELOC_AVR_HH8_LDI_NEG:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 16), where);
	  break;

	case BFD_RELOC_AVR_LO8_LDI_PM:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 1), where);
	  break;

	case BFD_RELOC_AVR_HI8_LDI_PM:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 9), where);
	  break;

	case BFD_RELOC_AVR_HH8_LDI_PM:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 17), where);
	  break;

	case BFD_RELOC_AVR_LO8_LDI_PM_NEG:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 1), where);
	  break;

	case BFD_RELOC_AVR_HI8_LDI_PM_NEG:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 9), where);
	  break;

	case BFD_RELOC_AVR_HH8_LDI_PM_NEG:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 17), where);
	  break;

	case BFD_RELOC_AVR_CALL:
	  {
	    unsigned long x;

	    x = bfd_getl16 (where);
	    if (value & 1)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("odd address operand: %ld"), value);
	    value >>= 1;
	    x |= ((value & 0x10000) | ((value << 3) & 0x1f00000)) >> 16;
	    bfd_putl16 ((bfd_vma) x, where);
	    bfd_putl16 ((bfd_vma) (value & 0xffff), where + 2);
	  }
	  break;

        case BFD_RELOC_AVR_8_LO:
          *where = 0xff & value;
          break;

        case BFD_RELOC_AVR_8_HI:
          *where = 0xff & (value >> 8);
          break;

        case BFD_RELOC_AVR_8_HLO:
          *where = 0xff & (value >> 16);
          break;

        default:
	  as_fatal (_("line %d: unknown relocation type: 0x%x"),
		    fixP->fx_line, fixP->fx_r_type);
	  break;
	}
    }
  else
    {
      switch ((int) fixP->fx_r_type)
	{
	case -BFD_RELOC_AVR_HI8_LDI_NEG:
	case -BFD_RELOC_AVR_HI8_LDI:
	case -BFD_RELOC_AVR_LO8_LDI_NEG:
	case -BFD_RELOC_AVR_LO8_LDI:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("only constant expression allowed"));
	  fixP->fx_done = 1;
	  break;
	default:
	  break;
	}
    }
}

/* GAS will call this to generate a reloc, passing the resulting reloc
   to `bfd_install_relocation'.  This currently works poorly, as
   `bfd_install_relocation' often does the wrong thing, and instances of
   `tc_gen_reloc' have been written to work around the problems, which
   in turns makes it difficult to fix `bfd_install_relocation'.  */

/* If while processing a fixup, a reloc really needs to be created
   then it is done here.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED,
	      fixS *fixp)
{
  arelent *reloc;

  if (fixp->fx_subsy != NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line, _("expression too complex"));
      return NULL;
    }

  reloc = xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);

  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }

  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  reloc->addend = fixp->fx_offset;

  return reloc;
}

void
md_assemble (char *str)
{
  struct avr_opcodes_s *opcode;
  char op[11];

  str = skip_space (extract_word (str, op, sizeof (op)));

  if (!op[0])
    as_bad (_("can't find opcode "));

  opcode = (struct avr_opcodes_s *) hash_find (avr_hash, op);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode `%s'"), op);
      return;
    }

  /* Special case for opcodes with optional operands (lpm, elpm) -
     version with operands exists in avr_opcodes[] in the next entry.  */

  if (*str && *opcode->constraints == '?')
    ++opcode;

  if (!avr_opt.all_opcodes && (opcode->isa & avr_mcu->isa) != opcode->isa)
    as_bad (_("illegal opcode %s for mcu %s"), opcode->name, avr_mcu->name);

  dwarf2_emit_insn (0);

  /* We used to set input_line_pointer to the result of get_operands,
     but that is wrong.  Our caller assumes we don't change it.  */
  {
    char *t = input_line_pointer;

    avr_operands (opcode, &str);
    if (*skip_space (str))
      as_bad (_("garbage at end of line"));
    input_line_pointer = t;
  }
}

typedef struct
{
  /* Name of the expression modifier allowed with .byte, .word, etc.  */
  const char *name;

  /* Only allowed with n bytes of data.  */
  int nbytes;

  /* Associated RELOC.  */
  bfd_reloc_code_real_type reloc;

  /* Part of the error message.  */
  const char *error;
} exp_mod_data_t;

static const exp_mod_data_t exp_mod_data[] =
{
  /* Default, must be first.  */
  { "", 0, BFD_RELOC_16, "" },
  /* Divides by 2 to get word address.  Generate Stub.  */
  { "gs", 2, BFD_RELOC_AVR_16_PM, "`gs' " },
  { "pm", 2, BFD_RELOC_AVR_16_PM, "`pm' " },
  /* The following are used together with avr-gcc's __memx address space
     in order to initialize a 24-bit pointer variable with a 24-bit address.
     For address in flash, hlo8 will contain the flash segment if the
     symbol is located in flash. If the symbol is located in RAM; hlo8
     will contain 0x80 which matches avr-gcc's notion of how 24-bit RAM/flash
     addresses linearize address space.  */
  { "lo8",  1, BFD_RELOC_AVR_8_LO,  "`lo8' "  },
  { "hi8",  1, BFD_RELOC_AVR_8_HI,  "`hi8' "  },
  { "hlo8", 1, BFD_RELOC_AVR_8_HLO, "`hlo8' " },
  { "hh8",  1, BFD_RELOC_AVR_8_HLO, "`hh8' "  },
  /* End of list.  */
  { NULL, 0, 0, NULL }
};

/* Data to pass between `avr_parse_cons_expression' and `avr_cons_fix_new'.  */
static const exp_mod_data_t *pexp_mod_data = &exp_mod_data[0];

/* Parse special CONS expression: pm (expression) or alternatively
   gs (expression).  These are used for addressing program memory.  Moreover,
   define lo8 (expression), hi8 (expression) and hlo8 (expression).  */

void
avr_parse_cons_expression (expressionS *exp, int nbytes)
{
  const exp_mod_data_t *pexp = &exp_mod_data[0];
  char *tmp;

  pexp_mod_data = pexp;

  tmp = input_line_pointer = skip_space (input_line_pointer);

  /* The first entry of exp_mod_data[] contains an entry if no
     expression modifier is present.  Skip it.  */

  for (pexp++; pexp->name; pexp++)
    {
      int len = strlen (pexp->name);

      if (nbytes == pexp->nbytes
          && strncasecmp (input_line_pointer, pexp->name, len) == 0)
	{
	  input_line_pointer = skip_space (input_line_pointer + len);

	  if (*input_line_pointer == '(')
	    {
	      input_line_pointer = skip_space (input_line_pointer + 1);
	      pexp_mod_data = pexp;
	      expression (exp);

	      if (*input_line_pointer == ')')
		++input_line_pointer;
	      else
		{
		  as_bad (_("`)' required"));
		  pexp_mod_data = &exp_mod_data[0];
		}

	      return;
	    }

	  input_line_pointer = tmp;

          break;
	}
    }

  expression (exp);
}

void
avr_cons_fix_new (fragS *frag,
		  int where,
		  int nbytes,
		  expressionS *exp)
{
  int bad = 0;

  switch (pexp_mod_data->reloc)
    {
    default:
      if (nbytes == 1)
	fix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_8);
      else if (nbytes == 2)
	fix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_16);
      else if (nbytes == 4)
	fix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_32);
      else
	bad = 1;
      break;

    case BFD_RELOC_AVR_16_PM:
    case BFD_RELOC_AVR_8_LO:
    case BFD_RELOC_AVR_8_HI:
    case BFD_RELOC_AVR_8_HLO:
      if (nbytes == pexp_mod_data->nbytes)
        fix_new_exp (frag, where, nbytes, exp, FALSE, pexp_mod_data->reloc);
      else
        bad = 1;
      break;
    }

  if (bad)
    as_bad (_("illegal %srelocation size: %d"), pexp_mod_data->error, nbytes);

  pexp_mod_data = &exp_mod_data[0];
}

static bfd_boolean
mcu_has_3_byte_pc (void)
{
  int mach = avr_mcu->mach; 

  return mach == bfd_mach_avr6 
    || mach == bfd_mach_avrxmega6 
    || mach == bfd_mach_avrxmega7;
}

void
tc_cfi_frame_initial_instructions (void)
{
  /* AVR6 pushes 3 bytes for calls.  */
  int return_size = (mcu_has_3_byte_pc () ? 3 : 2);

  /* The CFA is the caller's stack location before the call insn.  */
  /* Note that the stack pointer is dwarf register number 32.  */
  cfi_add_CFA_def_cfa (32, return_size);

  /* Note that AVR consistently uses post-decrement, which means that things
     do not line up the same way as for targers that use pre-decrement.  */
  cfi_add_CFA_offset (DWARF2_DEFAULT_RETURN_COLUMN, 1-return_size);
}
@


1.89
log
@	* config/tc-avr.c: Make ata6289's ISA to AVR_ISA_AVR4.
	* doc/c-avr.texi: Likewise.
@
text
@d459 1
@


1.88
log
@	* gas/config/tc-avr.c: Change ISA for devices with USB support to
	AVR_ISA_XMEGAU

	* include/opcode/avr.h: Rename AVR_ISA_XCH to AVR_ISA_RMW. Remove
	from AVR_ISA_XMEGA and add new AVR_ISA_XMEGAU
@
text
@a133 1
  {"ata6289",    AVR_ISA_AVR25,   bfd_mach_avr25},
d145 1
@


1.87
log
@	* gas/config/tc-avr.c (mcu_types): Add ATmega64RFR2,
	ATmega644RFR2, ATmega128RFR2, ATmega1284RFR2, ATmega256RFR2,
	ATmega2564RFR2
	* gas/doc/c-avr.texi (-mmcu documentation): Likewise.
@
text
@d271 1
a271 1
  {"atxmega64a1u",AVR_ISA_XMEGA,  bfd_mach_avrxmega5},
d273 1
a273 1
  {"atxmega128b1", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
d279 1
a279 1
  {"atxmega256a3bu",AVR_ISA_XMEGA,bfd_mach_avrxmega6},
d282 1
a282 1
  {"atxmega128a1u", AVR_ISA_XMEGA, bfd_mach_avrxmega7},
@


1.86
log
@	PR gas/15282
	* tc-avr.c (mcu_has_3_byte_pc): New function.
	(tc_cfi_frame_initial_instructions): Call it to find return
	address size.
@
text
@d221 2
d253 2
d260 2
@


1.85
log
@	PR gas/14255
	* config/tc-avr.h (TC_VALIDATE_FIX): Mark symbol used by reloc.
	Don't skip fixups with fx_subsy non-NULL.
	* config/tc-avr.c (tc_gen_reloc): Don't specially handle fixups
	with fx_subsy non-NULL.
@
text
@d3 1
a3 2
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2012, 2013  Free Software Foundation, Inc.
d1589 10
d1603 1
a1603 1
  int return_size = (avr_mcu->mach == bfd_mach_avr6 ? 3 : 2);
@


1.84
log
@	PR gas/15039
	* config/tc-avr.c: Include dwarf2dbg.h.
@
text
@d1389 1
a1389 1
  if (fixp->fx_addsy && fixp->fx_subsy)
d1391 1
a1391 21
      long value = 0;

      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
          || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
        {
          as_bad_where (fixp->fx_file, fixp->fx_line,
              "Difference of symbols in different sections is not supported");
          return NULL;
        }

      /* We are dealing with two symbols defined in the same section.
         Let us fix-up them here.  */
      value += S_GET_VALUE (fixp->fx_addsy);
      value -= S_GET_VALUE (fixp->fx_subsy);

      /* When fx_addsy and fx_subsy both are zero, md_apply_fix
         only takes it's second operands for the fixup value.  */
      fixp->fx_addsy = NULL;
      fixp->fx_subsy = NULL;
      md_apply_fix (fixp, (valueT *) &value, NULL);

@


1.83
log
@	PR 13503
	* config/tc-avr.c (exp_mod): Fix typo introduced in 1.82
	from 2012-05-16.
@
text
@d4 1
a4 1
   2010, 2012  Free Software Foundation, Inc.
d27 1
@


1.82
log
@	PR 13503
	* reloc.c: Rename BFD_RELOC_AVR_8_HHI to BFD_RELOC_AVR_8_HLO.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenrate.
	* elf32-avr.c (elf_avr_howto_table): Rename R_AVR_8_HHI8 to
	R_AVR_8_HLO8.
	(avr_reloc_map): Ditto.

	* config/tc-avr.c (avr_cons_fix_new): Rename R_AVR_8_HHI8 to
	R_AVR_8_HLO8.
	(exp_mod_data) Ditto. And replace "hhi8" with "hlo8".
	(md_apply_fix): Rename BFD_RELOC_AVR_8_HHI to BFD_RELOC_AVR_8_HLO.

	* avr.h (RELOC_NUMBERS): Rename R_AVR_8_HHI8 to R_AVR_8_HLO8.
@
text
@d330 1
a330 1
  {"hlo8",   BFD_RELOC_AVR_MS8_LDI,    BFD_RELOC_AVR_MS8_LDI_NEG,    0},
@


1.81
log
@	PR 13503
	* reloc.c: Add new ENUM for BFD_RELOC_AVR_8_LO,
	BFD_RELOC_AVR_8_HI, BFD_RELOC_AVR_8_HHI.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenrate.
	* elf32-avr.c (elf_avr_howto_table): Add entries for
	R_AVR_8_LO8, R_AVR_8_HI8, R_AVR_8_HHI8.
	(avr_reloc_map): Add RELOC mappings for R_AVR_8_LO8, R_AVR_8_HI8,
	R_AVR_8_HHI8.

	* config/tc-avr.c (exp_mod_pm): Remove variable.
	(exp_mod_data_t): New typedef.
	(pexp_mod_data, exp_mod_data): New variables.
	(avr_parse_cons_expression): Scan through exp_mod_data[] to find
	data expression modifiers "pm", "gs", "lo8", hi8", "hhi8", "hh8"
	and set pexp_mod_data accordingly to be used in avr_cons_fix_new.
	(avr_cons_fix_new): Handle new data expression modifiers shipped
	in pexp_mod_data.
	(md_apply_fix): Handle BFD_RELOC_AVR_8_LO, BFD_RELOC_AVR_8_HI,
	BFD_RELOC_AVR_8_HHI.

	* elf/avr.h (RELOC_NUMBERS): Add values for R_AVR_8_LO8,
	R_AVR_8_HI8, R_AVR_8_HHI8.
@
text
@d330 1
a330 1
  {"hhi8",   BFD_RELOC_AVR_MS8_LDI,    BFD_RELOC_AVR_MS8_LDI_NEG,    0},
d1345 1
a1345 1
        case BFD_RELOC_AVR_8_HHI:
d1504 2
a1505 2
     For address in flash, hhi8 will contain the flash segment if the
     symbol is located in flash. If the symbol is located in RAM; hhi8
d1510 2
a1511 2
  { "hhi8", 1, BFD_RELOC_AVR_8_HHI, "`hhi8' " },
  { "hh8",  1, BFD_RELOC_AVR_8_HHI, "`hh8' "  },
d1521 1
a1521 1
   define lo8 (expression), hi8 (expression) and hhi8 (expression).  */
d1595 1
a1595 1
    case BFD_RELOC_AVR_8_HHI:
@


1.80
log
@gas/
	* config/tc-avr.c (md_apply_fix): Fix handling of BFD_RELOC32.
@
text
@d4 1
a4 1
   2010  Free Software Foundation, Inc.
d68 2
a69 2
 but set to AVR_ISA_AVR25 for some following version 
 of GCC (from 4.3) for backward compatibility.  */  
d72 2
a73 2
/* TODO: insruction set for avr3 architecture should be AVR_ISA_AVR3, 
 but set to AVR_ISA_AVR3_ALL for some following version 
d79 2
a80 2
/* TODO: insruction set for avr5 architecture should be AVR_ISA_AVR5, 
 but set to AVR_ISA_AVR51 for some following version 
d1016 1
a1016 1
    
d1337 13
a1349 1
	default:
d1480 42
a1521 8
/* Flag to pass `pm' mode between `avr_parse_cons_expression' and
   `avr_cons_fix_new'.  */
static int exp_mod_pm = 0;

/* Parse special CONS expression: pm (expression)
   or alternatively: gs (expression).
   These are used for addressing program memory.
   Relocation: BFD_RELOC_AVR_16_PM.  */
d1526 1
d1529 1
a1529 1
  exp_mod_pm = 0;
d1533 4
a1536 1
  if (nbytes == 2)
d1538 1
a1538 4
      char *pm_name1 = "pm";
      char *pm_name2 = "gs";
      int len = strlen (pm_name1);
      /* len must be the same for both pm identifiers.  */
d1540 2
a1541 2
      if (strncasecmp (input_line_pointer, pm_name1, len) == 0
          || strncasecmp (input_line_pointer, pm_name2, len) == 0)
d1548 1
a1548 1
	      exp_mod_pm = 1;
d1556 1
a1556 1
		  exp_mod_pm = 0;
d1563 2
d1577 3
a1579 1
  if (exp_mod_pm == 0)
d1581 1
d1589 9
a1597 6
	as_bad (_("illegal %srelocation size: %d"), "", nbytes);
    }
  else
    {
      if (nbytes == 2)
	fix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_AVR_16_PM);
d1599 2
a1600 2
	as_bad (_("illegal %srelocation size: %d"), "`pm' ", nbytes);
      exp_mod_pm = 0;
d1602 5
@


1.79
log
@PR 12610
* config/tc-alpha.c (s_alpha_align): Don't auto-align a previous
label; zap alpha_insn_label.
@
text
@d1227 1
a1227 1
	  bfd_putl16 ((bfd_vma) value, where);
@


1.78
log
@2011-03-24  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add new devices: atmega325pa,
	atmega3250pa, atmega3290pa, atmega16hvbrevb, atmega32hvbrevb,
	at90pwm161.
	* doc/c-avr.texi: Document new device names.
@
text
@d27 2
d1548 15
@


1.77
log
@2011-03-23  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add new xmega devices: atxmega64a1u,
	atxmega128a1u, atxmega16x1, atxmega32x1, atxmega128b1, atxmega256a3bu.
	* doc/c-avr.texi: Document new device names.
@
text
@d185 1
d189 1
d199 1
d222 1
d224 1
d228 1
@


1.76
log
@/bfd:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* archures.c: Add AVR XMEGA architecture information.
	* cpu-avr.c (arch_info_struct): Likewise.
	* elf32-avr.c (bfd_elf_avr_final_write_processing): Likewise.
	(elf32_avr_object_p): Likewise.

/gas:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (struct avr_opcodes_s): Add opcode field.
	(AVR_INSN): Change definition to match.
	(avr_opcodes): Likewise, change to match.
	(mcu_types): Add XMEGA architecture names and new XMEGA device names.
	(md_show_usage): Add XMEGA architecture names.
	(avr_operand): Add 'E' constraint for DES instruction of XMEGA devices.
	Add support for SPM Z+ instruction.
	* doc/c-avr.texi: Add documentation for XMEGA architectures and
	devices.

/include/opcode:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* avr.h (AVR_ISA_SPMX,AVR_ISA_DES,AVR_ISA_M256,AVR_ISA_XMEGA):
	New instruction set flags.
	(AVR_INSN): Add new instructions for SPM Z+, DES for XMEGA.

/ld:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* Makefile.am (ALL_EMULATION_SOURCES): Add AVR XMEGA architectures.
	(eavrxmega?.c): Likewise.
	* configure.tgt (targ_extra_emuls): Likewise.
	* emulparams/avrxmega1.sh: New file.
	* emulparams/avrxmega2.sh: Likewise.
	* emulparams/avrxmega3.sh: Likewise.
	* emulparams/avrxmega4.sh: Likewise.
	* emulparams/avrxmega5.sh: Likewise.
	* emulparams/avrxmega6.sh: Likewise.
	* emulparams/avrxmega7.sh: Likewise.
	* emultempl/avrelf.em (avr_elf_${EMULATION_NAME}_before_allocation):
	Add avrxmega6, avrxmega7 to list of architectures for no stubs.

/opcodes:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* avr-dis.c (avr_operand): Add opcode_str parameter. Check for
	post-increment to support LPM Z+ instruction. Add support for 'E'
	constraint for DES instruction.
	(print_insn_avr): Adjust calls to avr_operand. Rename variable.
@
text
@d250 1
d253 1
d257 1
d259 1
d265 1
d268 1
@


1.75
log
@2011-03-21  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (md_show_usage): Add "Assembler" text to output.
@
text
@d32 1
d39 1
a39 1
{#NAME, CONSTR, SIZE, ISA, BIN},
d44 1
a44 1
  {NULL, NULL, 0, 0, 0}
d83 7
d248 15
d439 5
d871 6
a876 1
	  op_mask |= 1;
d993 10
@


1.74
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d401 1
a401 1
      _("AVR options:\n"
@


1.73
log
@2010-04-07  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add support for atmega16a, atmega168a,
	atmega164a, atmega165a, atmega169a, atmega169pa, atmega16hva2,
	atmega324a, atmega324pa, atmega325a, atmega3250a, atmega328,
	atmega329a, atmega329pa, atmega3290a, atmega48a, atmega644a,
	atmega645a, atmega645p, atmega6450a, atmega6450p, atmega649a,
	atmega649p, atmega6490a, atmega6490p, atmega64hve, atmega88a,
	atmega88pa, attiny461a, attiny84a, m3000.
	Remove support for atmega8m1, atmega8c1, atmega16c1, atmega4hvd,
	atmega8hvd, attiny327, m3000f, m3000s, m3001b.
	* doc/c-avr.texi: Same.
@
text
@a369 1
  char *op_start;
d378 1
a378 1
  for (op_start = op_end = from; *op_end != 0 && is_part_of_name (*op_end);)
@


1.72
log
@PR 11297: Add support for 8-bit relocations to the AVR toolchain.
@
text
@d109 1
d116 1
a129 1
  {"attiny327",  AVR_ISA_AVR35,   bfd_mach_avr35},
d137 1
d140 1
d142 1
a145 4
  {"atmega4hvd", AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega8hvd", AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega8c1",  AVR_ISA_AVR4,    bfd_mach_avr4},
  {"atmega8m1",  AVR_ISA_AVR4,    bfd_mach_avr4},
d153 1
d157 1
d160 1
d163 1
d166 1
d168 1
a168 1
  {"atmega16c1", AVR_ISA_AVR5,    bfd_mach_avr5},
d171 1
d173 1
d175 1
d178 1
d180 1
d183 1
d185 1
d187 1
d193 1
d197 2
d200 2
d203 2
d206 2
d209 1
d212 1
d229 1
a237 3
  {"m3000f",     AVR_ISA_AVR51,   bfd_mach_avr51},
  {"m3000s",     AVR_ISA_AVR51,   bfd_mach_avr51},
  {"m3001b",     AVR_ISA_AVR51,   bfd_mach_avr51},
@


1.71
log
@2009-10-29  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-mep.c (md_pseudo_table): Remove dwarf2 pseudo
	as they are already defined in obj-elf.c
	* config/tc-m32c.c (md_pseudo_table): Ditto.
	* config/tc-spu.c (md_pseudo_table): Ditto.
	* config/tc-avr.c (md_pseudo_table): Ditto.
@
text
@d3 2
a4 2
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
d1156 7
d1452 3
a1454 1
      if (nbytes == 2)
@


1.70
log
@2009-10-27  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-avr.c (md_pseudo_table): Add dwarf2 debug pseudo.
	* config/tc-avr.h (DWARF2_LINE_MIN_INSN_LENGTH): Define.
	(DWARF2_ADDR_SIZE): Define.
@
text
@a243 3
  {"file", (void (*) (int)) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
  {"loc_mark_labels", dwarf2_directive_loc_mark_labels, 0},
@


1.69
log
@	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
@
text
@d244 3
@


1.68
log
@update copyright dates
@
text
@d1369 2
@


1.68.2.1
log
@gas/
	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
gas/testsuite/
	* gas/d30v/serial2.l: Adjust position of page break.
	* gas/lns/lns-common-1-alt.d: Match 2009-04-24 change.
	* gas/mt/ms1-16-003.d: Correct reloc name.
	* gas/mt/relocs.d: Elide incorrect file format strings.
@
text
@a1368 2
  dwarf2_emit_insn (0);

@


1.67
log
@/gas:
2009-08-05  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add attiny2313a, attiny4313, attiny261a,
	attiny861a, atmega644pa, attiny24a, attiny44a.
	* doc/c-avr.texi: Likewise.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008
@


1.66
log
@/gas:
2009-08-02  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add atmega8m1, atmega8c1, atmega16c1.
	* doc/c-avr.texi: Likewise.
@
text
@d102 1
d104 2
d107 1
d113 1
d116 1
d181 1
@


1.65
log
@/gas:
2009-08-01  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add atmega8u2, atmega16u2, atmega32u2.
	* doc/c-avr.texi: Likewise.
@
text
@d138 2
d157 1
@


1.64
log
@        * config/tc-avr.c (md_apply_fix): Cast fixup reloc type to avoid
        compile time warning.
@
text
@d125 3
@


1.63
log
@/gas:
2009-01-29  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add ata6289.
	* doc/c-avr.texi: Likewise.
@
text
@d1247 1
a1247 1
      switch (fixP->fx_r_type)
@


1.62
log
@/gas:
2009-01-26  Eric B. Weddington  <eric.weddington@@atmel.com>

	PR 9789
	* config/tc-avr.c (mcu_types): Fix typo in atmega128rfa1 name.
	* doc/c-avr.texi: Likewise.
@
text
@d116 1
@


1.61
log
@        * config/tc-avr.c (mcu_types): Add attiny87, attiny327, atmega4hvd,
        atmega8hvd, atmega16hvb, atmega32hvb, atmega64c1, atmega16m1,
        atmega64m1, atmega32u6, atmega128rfa1,  at90pwm81, at90scr100,
        m3000f, m3000s and m3001b devices.
        * doc/c-avr.texi: Likewise.
@
text
@d195 1
a195 1
  {"atmega128rfa",AVR_ISA_AVR51,  bfd_mach_avr51},
@


1.60
log
@        * config/tc-avr.c (mcu_types): Add atmega16u4.
        * doc/c-avr.texi: Likewise.
@
text
@d111 1
d121 1
d132 2
d139 1
d173 2
a178 1
  {"atmega16u4", AVR_ISA_AVR5,    bfd_mach_avr5},
d180 2
d183 2
d186 1
d189 1
d195 1
d199 3
@


1.59
log
@Add AVR architectures avr25, avr31, avr35, and avr51 to match GCC.
bfd/
	* archures.c (bfd_mach_avr25, bfd_mach_avr31, bfd_mach_avr35,
	bfd_mach_avr51): New.
	* bfd-in2.h: Regenerate.
	* cpu-avr.c (arch_info_struct): Add avr25, avr31, avr35, and avr51
	architectures. Change comments to match architecture comments in GCC.
	(compatible): Add test for new AVR architectures.
	* elf32-avr.c (bfd_elf_avr_final_write_processing): Recognize
	bfd_mach_avr25, bfd_mach_avr31, bfd_mach_avr35 and bfd_mach_avr51.
	(elf32_avr_object_p): Recognize E_AVR_MACH_AVR25, E_AVR_MACH_AVR31,
	E_AVR_MACH_AVR35 and E_AVR_MACH_AVR51.

gas/
	* config/tc-avr.c (mcu_types): Add avr25, avr31, avr35, and avr51
	architectures. Reorganize list to put mcu types in correct architectures
	and to order list same as in GCC. Use new ISA definitions in
	include/opcode/avr.h.
	* doc/c-avr.texi: Add avr25, avr31, avr35, and avr51 architecture
	descriptions. Reorganize descriptions to put mcu types in correct
	architectures and to order lists same as in GCC.

include/
	* elf/avr.h (E_AVR_MACH_AVR25, E_AVR_MACH_AVR31,
	E_AVR_MACH_AVR35, E_AVR_MACH_AVR51): Define.
	(EF_AVR_MACH): Redefine to 0x7F.
	* opcode/avr.h (AVR_ISA_TINY3, AVR_ISA_ALL, AVR_ISA_USB162): Remove.
	(AVR_ISA_AVR3): Redefine.
	(AVR_ISA_AVR1, AVR_ISA_AVR2, AVR_ISA_AVR31, AVR_ISA_AVR35,
	AVR_ISA_AVR3_ALL, AVR_ISA_AVR4, AVR_ISA_AVR5, AVR_ISA_AVR51,
	AVR_ISA_AVR6): Define.

ld/
	* Makefile.am (ALL_EMULATIONS): Add eavr25.o, eavr31.o, eavr35.o,
	and eavr51.o.
	Add rules for eavr25.c, eavr31.c, eavr35.c, eavr51.c.
	* Makefile.in: Regenerate.
	* configure.tgt (avr-*-*, targ_extra_emuls): Add avr25, avr31, avr35
	and avr51.
	* emulparams/avr25.sh: New file.
	* emulparams/avr31.sh: New file.
	* emulparams/avr35.sh: New file.
	* emulparams/avr51.sh: New file.
@
text
@d172 1
@


1.58
log
@/gas:
2008-06-24  Eric B. Weddington  <eric.weddington@@atmel.com>

	Add support for ATtiny13A.
	* config/tc-avr.c (mcu_types): Add attiny13a.
	* doc/c-avr.texi: Likewise.
@
text
@d59 1
a59 2
   ones, or planned but never produced), left here for compatibility.
   TODO: hide them in show_mcu_list output?  */
d63 19
a81 6
  {"avr1",       AVR_ISA_TINY1,   bfd_mach_avr1},
  {"avr2",       AVR_ISA_TINY2,   bfd_mach_avr2},
  {"avr3",       AVR_ISA_AVR3,    bfd_mach_avr3},
  {"avr4",       AVR_ISA_M8,      bfd_mach_avr4},
  {"avr5",       AVR_ISA_ALL,     bfd_mach_avr5},
  {"avr6",       AVR_ISA_ALL,     bfd_mach_avr6},
d83 9
a91 9
  {"attiny11",   AVR_ISA_TINY1,   bfd_mach_avr1},
  {"attiny12",   AVR_ISA_TINY1,   bfd_mach_avr1},
  {"attiny15",   AVR_ISA_TINY1,   bfd_mach_avr1},
  {"attiny28",   AVR_ISA_TINY1,   bfd_mach_avr1},
  {"at90s2313",  AVR_ISA_2xxx,    bfd_mach_avr2},
  {"at90s2323",  AVR_ISA_2xxx,    bfd_mach_avr2},
  {"at90s2333",  AVR_ISA_2xxx,    bfd_mach_avr2}, /* XXX -> 4433 */
  {"at90s2343",  AVR_ISA_2xxx,    bfd_mach_avr2},
  {"attiny22",   AVR_ISA_2xxx,    bfd_mach_avr2}, /* XXX -> 2343 */
d93 29
a121 31
  {"at90s4433",  AVR_ISA_2xxx,    bfd_mach_avr2},
  {"at90s4414",  AVR_ISA_2xxx,    bfd_mach_avr2}, /* XXX -> 8515 */
  {"at90s4434",  AVR_ISA_2xxx,    bfd_mach_avr2}, /* XXX -> 8535 */
  {"at90s8515",  AVR_ISA_2xxx,    bfd_mach_avr2},
  {"at90s8535",  AVR_ISA_2xxx,    bfd_mach_avr2},
  {"at90c8534",  AVR_ISA_2xxx,    bfd_mach_avr2},
  {"at86rf401",  AVR_ISA_RF401,   bfd_mach_avr2},
  {"attiny13",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny13a",  AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny2313", AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny261",  AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny461",  AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny861",  AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny24",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny44",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny84",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny25",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny45",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny85",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny43u",  AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny48",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"attiny88",   AVR_ISA_TINY2,   bfd_mach_avr2},
  {"atmega103",  AVR_ISA_M103,    bfd_mach_avr3},
  {"at43usb320", AVR_ISA_M103,    bfd_mach_avr3},
  {"at43usb355", AVR_ISA_M603,    bfd_mach_avr3},
  {"at76c711",   AVR_ISA_M603,    bfd_mach_avr3},
  {"at90usb82",  AVR_ISA_USB162,  bfd_mach_avr3},
  {"at90usb162", AVR_ISA_USB162,  bfd_mach_avr3},
  {"attiny167",  AVR_ISA_TINY3,   bfd_mach_avr3},
  {"atmega48",   AVR_ISA_PWMx,    bfd_mach_avr4},
  {"atmega48p",  AVR_ISA_PWMx,    bfd_mach_avr4},
d123 4
a126 2
  {"atmega88",   AVR_ISA_PWMx,    bfd_mach_avr4},
  {"atmega88p",  AVR_ISA_PWMx,    bfd_mach_avr4},
d129 7
a135 7
  {"atmega8hva", AVR_ISA_PWMx,    bfd_mach_avr4},
  {"at90pwm1",   AVR_ISA_PWMx,    bfd_mach_avr4},
  {"at90pwm2",   AVR_ISA_PWMx,    bfd_mach_avr4},
  {"at90pwm2b",  AVR_ISA_PWMx,    bfd_mach_avr4},
  {"at90pwm3",   AVR_ISA_PWMx,    bfd_mach_avr4},
  {"at90pwm3b",  AVR_ISA_PWMx,    bfd_mach_avr4},
  {"atmega16",   AVR_ISA_M323,    bfd_mach_avr5},
d137 1
a137 1
  {"atmega162",  AVR_ISA_M323,    bfd_mach_avr5},
d139 38
a176 45
  {"atmega164p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega165",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega165p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega168",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega168p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega169",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega169p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega32",   AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega323",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega324p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega325",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega325p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega328p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega329",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega329p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega3250", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega3250p",AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega3290", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega3290p",AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega406",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega64",   AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega640",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega644",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega644p", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega128",  AVR_ISA_M128,    bfd_mach_avr5},
  {"atmega1280", AVR_ISA_M128,    bfd_mach_avr5},
  {"atmega1281", AVR_ISA_M128,    bfd_mach_avr5},
  {"atmega1284p",AVR_ISA_M128,    bfd_mach_avr5},
  {"atmega645",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega649",  AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega6450", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega6490", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega16hva",AVR_ISA_M323,    bfd_mach_avr5},
  {"at90can32" , AVR_ISA_M323,    bfd_mach_avr5},
  {"at90can64" , AVR_ISA_M323,    bfd_mach_avr5},
  {"at90can128", AVR_ISA_M128,    bfd_mach_avr5},
  {"at90pwm216", AVR_ISA_M323,    bfd_mach_avr5},
  {"at90pwm316", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega32c1", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega32m1", AVR_ISA_M323,    bfd_mach_avr5},
  {"atmega32u4", AVR_ISA_M323,    bfd_mach_avr5},
  {"at90usb646", AVR_ISA_M323,    bfd_mach_avr5},
  {"at90usb647", AVR_ISA_M323,    bfd_mach_avr5},
  {"at90usb1286",AVR_ISA_M128,    bfd_mach_avr5},
  {"at90usb1287",AVR_ISA_M128,    bfd_mach_avr5},
d178 9
a186 2
  {"atmega2560", AVR_ISA_ALL,     bfd_mach_avr6},
  {"atmega2561", AVR_ISA_ALL,     bfd_mach_avr6},
d191 1
a191 1
static struct mcu_type_s   default_mcu = {"avr2", AVR_ISA_2xxx,bfd_mach_avr2};
d352 12
a363 5
	"                   avr1 - AT90S1200, ATtiny1x, ATtiny28\n"
	"                   avr2 - AT90S2xxx, AT90S4xxx, AT90S8xxx, ATtiny22\n"
	"                   avr3 - ATmega103\n"
	"                   avr4 - ATmega8, ATmega88\n"
	"                   avr5 - ATmega161, ATmega163, ATmega32, AT94K\n"
@


1.57
log
@/gas:
2008-06-09  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Remove support for ATmega32HVB device.
	* doc/c-avr.texi: Likewise.
@
text
@d89 1
@


1.56
log
@        PR 5523
        * config/tc-avr.c (avr_ldi_expression): Do not warn about unknown
        relocs here.
@
text
@a144 1
  {"atmega32hvb",AVR_ISA_M323,    bfd_mach_avr5},
@


1.55
log
@/gas:
2008-03-28  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add attiny167.
	* doc/c-avr.texi: Likewise.

/include:
2008-03-28  Eric B. Weddington  <eric.weddington@@atmel.com>

	* opcode/avr.h (AVR_ISA_TINY3): Define new opcode set for attiny167.
@
text
@d625 3
a627 1
		      as_warn (_("expression dangerous with linker stubs"));
@


1.54
log
@/gas:
2008-03-28  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add atmega32u4.
	* doc/c-avr.texi: Likewise.
@
text
@d108 1
@


1.53
log
@/gas:
2008-03-28  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add atmega32c1.
	* doc/c-avr.texi: Likewise.
@
text
@d166 1
@


1.52
log
@  * config/tc-avr.c (mcu_types): Add atmega32m1.
  * doc/c-avr.texi: Likewise.
@
text
@d164 1
@


1.51
log
@        PR gas/2626

        * avr.h (AVR_ISA_2xxe): Define.

        * config/tc-avr.c (mcu_types): Change the ISA tyoe of the attiny26
        to AVR_ISA_2xxe.
        (avr_operand): Disallow post-increment addressing in the lpm
        instruction for the attiny26.
@
text
@d164 1
@


1.50
log
@/gas:
2008-01-23  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Change opcode set for at86rf401.

/include:
2008-01-23  Eric B. Weddington  <eric.weddington@@atmel.com>

	* opcode/avr.h (AVR_ISA_RF401): Add new opcode set for at86rf401.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007
d80 1
a80 1
  {"attiny26",   AVR_ISA_2xxx,    bfd_mach_avr2},
d768 6
@


1.49
log
@/gas:
2008-01-03  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Change opcode set for avr3,
	at90usb82, at90usb162.
	* doc/c-avr.texi: Change architecture grouping for at90usb82,
	at90usb162.
	These changes support the new avr35 architecture group in gcc.

/include:
2008-01-03  Eric B. Weddington  <eric.weddington@@atmel.com>

	* opcode/avr.h (AVR_ISA_USB162): Add new opcode set.
	(AVR_ISA_AVR3): Likewise.
@
text
@d87 1
a87 1
  {"at86rf401",  AVR_ISA_2xxx,    bfd_mach_avr2},
@


1.48
log
@2007-11-16  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add ATmega32HVB device.
	* doc/c-avr.texi: Likewise.
@
text
@d66 1
a66 1
  {"avr3",       AVR_ISA_M103,    bfd_mach_avr3},
d106 2
a163 2
  {"at90usb82",  AVR_ISA_M323,    bfd_mach_avr5},
  {"at90usb162", AVR_ISA_M323,    bfd_mach_avr5},
@


1.47
log
@2007-11-16  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (mcu_types): Add ATmega1284P device.
	* doc/c-avr.texi: Likewise.
@
text
@d142 1
@


1.46
log
@2007-11-07  Eric B. Weddington  <eweddington@@cso.atmel.com>

	* config/tc-avr.c (mcu_types): Add ATtiny88 device.
	* doc/c-avr.texi: Likewise.
@
text
@d150 1
@


1.45
log
@2007-11-07  Anatoly Sokolov <aesok@@post.ru>

	* config/tc-avr.c (mcu_types): Add new devices: ATmega48P, ATmega88P,
	ATmega168P, Atmega328P
	* doc/c-avr.texi: Document new devices.
@
text
@d101 1
@


1.44
log
@2007-10-31  Eric B. Weddington  <eweddington@@cso.atmel.com>

	* config/tc-avr.c (mcu_types): Remove devices that were never produced:
	attiny10, atmega83, atmega85, atmega603.
	* doc/c-avr.texi: Likewise.
@
text
@d106 1
d109 1
d126 1
d134 1
@


1.43
log
@Remove duplicate definitions of the md_atof() function
@
text
@a70 1
  {"attiny10",   AVR_ISA_TINY1,   bfd_mach_avr1}, /* XXX -> tn11 */
a100 1
  {"atmega603",  AVR_ISA_M603,    bfd_mach_avr3}, /* XXX -> m103 */
a106 2
  {"atmega83",   AVR_ISA_M8,      bfd_mach_avr4}, /* XXX -> m8535 */
  {"atmega85",   AVR_ISA_M8,      bfd_mach_avr4}, /* XXX -> m8 */
d331 2
a332 2
	"                   avr3 - ATmega103, ATmega603\n"
	"                   avr4 - ATmega83, ATmega85\n"
@


1.42
log
@* config/tc-avr.c (mcu_types): Add new devices: AT90PWM2B, AT90PWM3B.
* doc/c-avr.texi: Document new devices.
@
text
@a416 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d420 1
a420 32
  int prec;
  LITTLENUM_TYPE words[4];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;
    case 'd':
      prec = 4;
      break;
    default:
      *sizeP = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  /* This loop outputs the LITTLENUMs in REVERSE order.  */
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return NULL;
@


1.41
log
@* config/tc-avr.c (mcu_types): Add new devices: AT90PWM216, AT90PWM316.
* doc/c-avr.texi: Document new devices.
@
text
@d117 1
d119 1
@


1.40
log
@* config/tc-avr.c (mcu_types): Add new devices: ATtiny43U, ATtiny48.
* doc/c-avr.texi: Document new devices.
@
text
@d155 2
@


1.39
log
@PR gas/5078
* config/tc-avr.c (avr_get_constant): Extend error message to mention that the constant must be positive.
@
text
@d100 2
@


1.38
log
@Switch to GPLv3
@
text
@d504 1
a504 1
    as_bad (_("number must be less than %d"), max + 1);
@


1.37
log
@	* config/tc-avr.c (mcu_types): Add support for atmega8hva and
	atmega16hva devices. Move at90usb82 device to 'avr5' architecture.
	* doc/c-avr.texi: Document new devices.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006
d11 1
a11 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.36
log
@	* config/tc-avr.c (mcu_types): Add support for at90pwm1, at90usb82,
	at90usb162, atmega325p, atmega329p, atmega3250p and atmega3290p
	devices.
	* doc/c-avr.texi: Document new devices.
@
text
@d112 1
a115 1
  {"at90usb82",  AVR_ISA_PWMx,    bfd_mach_avr4},
d149 1
d153 1
@


1.35
log
@	* config/tc-avr.c (mcu_types): Add support for atmega165p, atmega169p
	and atmega644p devices. Rename atmega164/atmega324 devices to
	atmega164p/atmega324p.
	* doc/c-avr.texi: Document new mcu and arch options.
@
text
@d112 1
d115 1
d130 1
d132 1
d134 1
d136 1
d152 1
@


1.34
log
@remove some duplicate #include's.
@
text
@d118 1
a118 1
  {"atmega164",  AVR_ISA_M323,    bfd_mach_avr5},
d120 1
d123 1
d126 1
a126 1
  {"atmega324",  AVR_ISA_M323,    bfd_mach_avr5},
d135 1
@


1.33
log
@Add support for AVR6 family
@
text
@a23 1
#include <stdio.h>
a26 1
#include "libiberty.h"
@


1.32
log
@Add support for attiny261, attiny461, attiny861, attiny25, attiny45,
attiny85, attiny24, attiny44, attiny84, at90pwm2, at90pwm3, atmega164,
atmega324, atmega644, atmega329, atmega3290, atmega649, atmega6490,
atmega406, atmega640, atmega1280, atmega1281, at90can32, at90can64,
at90usb646, at90usb647, at90usb1286 and at90usb1287.
Move atmega48 and atmega88 from AVR_ISA_M8 to AVR_ISA_PWMx.
@
text
@d66 79
a144 78
  {"avr1",      AVR_ISA_TINY1,    bfd_mach_avr1},
  {"avr2",      AVR_ISA_TINY2,    bfd_mach_avr2},
  {"avr3",      AVR_ISA_M103,     bfd_mach_avr3},
  {"avr4",      AVR_ISA_M8,       bfd_mach_avr4},
  {"avr5",      AVR_ISA_ALL,      bfd_mach_avr5},
  {"at90s1200", AVR_ISA_1200,     bfd_mach_avr1},
  {"attiny10",  AVR_ISA_TINY1,    bfd_mach_avr1}, /* XXX -> tn11 */
  {"attiny11",  AVR_ISA_TINY1,    bfd_mach_avr1},
  {"attiny12",  AVR_ISA_TINY1,    bfd_mach_avr1},
  {"attiny15",  AVR_ISA_TINY1,    bfd_mach_avr1},
  {"attiny28",  AVR_ISA_TINY1,    bfd_mach_avr1},
  {"at90s2313", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at90s2323", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at90s2333", AVR_ISA_2xxx,     bfd_mach_avr2}, /* XXX -> 4433 */
  {"at90s2343", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"attiny22",  AVR_ISA_2xxx,     bfd_mach_avr2}, /* XXX -> 2343 */
  {"attiny26",  AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at90s4433", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at90s4414", AVR_ISA_2xxx,     bfd_mach_avr2}, /* XXX -> 8515 */
  {"at90s4434", AVR_ISA_2xxx,     bfd_mach_avr2}, /* XXX -> 8535 */
  {"at90s8515", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at90s8535", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at90c8534", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at86rf401", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"attiny13",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny2313",AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny261", AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny461", AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny861", AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny24",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny44",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny84",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny25",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny45",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny85",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"atmega603", AVR_ISA_M603,     bfd_mach_avr3}, /* XXX -> m103 */
  {"atmega103", AVR_ISA_M103,     bfd_mach_avr3},
  {"at43usb320",AVR_ISA_M103,     bfd_mach_avr3},
  {"at43usb355",AVR_ISA_M603,     bfd_mach_avr3},
  {"at76c711",  AVR_ISA_M603,     bfd_mach_avr3},
  {"atmega48",  AVR_ISA_PWMx,     bfd_mach_avr4},
  {"atmega8",   AVR_ISA_M8,       bfd_mach_avr4},
  {"atmega83",  AVR_ISA_M8,       bfd_mach_avr4}, /* XXX -> m8535 */
  {"atmega85",  AVR_ISA_M8,       bfd_mach_avr4}, /* XXX -> m8 */
  {"atmega88",  AVR_ISA_PWMx,     bfd_mach_avr4},
  {"atmega8515",AVR_ISA_M8,       bfd_mach_avr4},
  {"atmega8535",AVR_ISA_M8,       bfd_mach_avr4},
  {"at90pwm2",  AVR_ISA_PWMx,     bfd_mach_avr4},
  {"at90pwm3",  AVR_ISA_PWMx,     bfd_mach_avr4},
  {"atmega16",  AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega161", AVR_ISA_M161,     bfd_mach_avr5},
  {"atmega162", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega163", AVR_ISA_M161,     bfd_mach_avr5},
  {"atmega164", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega165", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega168", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega169", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega32",  AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega323", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega324", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega325", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega329", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega3250",AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega3290",AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega406", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega64",  AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega640", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega644", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega128", AVR_ISA_M128,     bfd_mach_avr5},
  {"atmega1280",AVR_ISA_M128,     bfd_mach_avr5},
  {"atmega1281",AVR_ISA_M128,     bfd_mach_avr5},
  {"atmega645", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega649", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega6450",AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega6490",AVR_ISA_M323,     bfd_mach_avr5},
  {"at90can32" ,AVR_ISA_M323,     bfd_mach_avr5},
  {"at90can64" ,AVR_ISA_M323,     bfd_mach_avr5},
  {"at90can128",AVR_ISA_M128,     bfd_mach_avr5},
d149 3
a151 1
  {"at94k",     AVR_ISA_94K,      bfd_mach_avr5},
d518 1
a518 1
      
d550 2
d559 1
a559 1
      
d572 1
d578 2
d590 3
d624 18
a641 1
	      return neg_p ? EXP_MOD_NEG_RELOC (mod) : EXP_MOD_RELOC (mod);
d1258 1
a1258 1
      /* We are dealing with two symbols defined in the same section. 
d1341 2
a1342 1
   which is used for addressing to a program memory.
d1356 4
a1359 2
      char *pm_name = "pm";
      int len = strlen (pm_name);
d1361 2
a1362 1
      if (strncasecmp (input_line_pointer, pm_name, len) == 0)
@


1.31
log
@Add linker relaxation support for the AVR
@
text
@d92 9
d106 1
a106 1
  {"atmega48",  AVR_ISA_M8,       bfd_mach_avr4},
d110 1
a110 1
  {"atmega88",  AVR_ISA_M8,       bfd_mach_avr4},
d113 2
d119 1
d125 1
d127 1
d129 2
d132 2
d135 2
d138 1
d140 3
d144 4
@


1.31.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a91 9
  {"attiny261", AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny461", AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny861", AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny24",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny44",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny84",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny25",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny45",  AVR_ISA_TINY2,    bfd_mach_avr2},
  {"attiny85",  AVR_ISA_TINY2,    bfd_mach_avr2},
d97 1
a97 1
  {"atmega48",  AVR_ISA_PWMx,     bfd_mach_avr4},
d101 1
a101 1
  {"atmega88",  AVR_ISA_PWMx,     bfd_mach_avr4},
a103 2
  {"at90pwm2",  AVR_ISA_PWMx,     bfd_mach_avr4},
  {"at90pwm3",  AVR_ISA_PWMx,     bfd_mach_avr4},
a107 1
  {"atmega164", AVR_ISA_M323,     bfd_mach_avr5},
a112 1
  {"atmega324", AVR_ISA_M323,     bfd_mach_avr5},
a113 1
  {"atmega329", AVR_ISA_M323,     bfd_mach_avr5},
a114 2
  {"atmega3290",AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega406", AVR_ISA_M323,     bfd_mach_avr5},
a115 2
  {"atmega640", AVR_ISA_M323,     bfd_mach_avr5},
  {"atmega644", AVR_ISA_M323,     bfd_mach_avr5},
a116 2
  {"atmega1280",AVR_ISA_M128,     bfd_mach_avr5},
  {"atmega1281",AVR_ISA_M128,     bfd_mach_avr5},
a117 1
  {"atmega649", AVR_ISA_M323,     bfd_mach_avr5},
a118 3
  {"atmega6490",AVR_ISA_M323,     bfd_mach_avr5},
  {"at90can32" ,AVR_ISA_M323,     bfd_mach_avr5},
  {"at90can64" ,AVR_ISA_M323,     bfd_mach_avr5},
a119 4
  {"at90usb646", AVR_ISA_M323,    bfd_mach_avr5},
  {"at90usb647", AVR_ISA_M323,    bfd_mach_avr5},
  {"at90usb1286",AVR_ISA_M128,    bfd_mach_avr5},
  {"at90usb1287",AVR_ISA_M128,    bfd_mach_avr5},
@


1.30
log
@Fixes for building on 64-bit hosts:
        * config/tc-avr.c (mod_index): New union to allow conversion
        between pointers and integers.
        (md_begin, avr_ldi_expression): Use it.
        * config/tc-i370.c (md_assemble): Add cast for argument to print
        statement.
        * config/tc-tic54x.c (subsym_substitute): Likewise.
        * config/tc-mn10200.c (md_assemble): Use a union to convert the
        opindex field of fr_cgen structure into a pointer so that it can
        be stored in a frag.
        * config/tc-mn10300.c (md_assemble): Likewise.
        * config/tc-frv.c (frv_debug_tomcat): Use %p to print pointer
        types.
        * config/tc-v850.c: Replace uses of (int) casts with correct
        types.
        * gas/tic54x/address.d: Work with 64bit hosts.
        * gas/tic54x/addrfar.d: Likewise.
        * gas/tic54x/align.d: Likewise.
        * gas/tic54x/all-opcodes.d: Likewise.
        * gas/tic54x/asg.d: Likewise.
        * gas/tic54x/cons.d: Likewise.
        * gas/tic54x/consfar.d: Likewise.
        * gas/tic54x/extaddr.d: Likewise.
        * gas/tic54x/field.d: Likewise.
        * gas/tic54x/labels.d: Likewise.
        * gas/tic54x/loop.d: Likewise.
        * gas/tic54x/lp.d: Likewise.
        * gas/tic54x/macro.d: Likewise.
        * gas/tic54x/math.d: Likewise.
        * gas/tic54x/opcodes.d: Likewise.
        * gas/tic54x/sections.d: Likewise.
       * gas/tic54x/set.d: Likewise.
       * gas/tic54x/struct.d: Likewise.
       * gas/tic54x/subsym.d: Likewise.
@
text
@d173 2
a174 2
  {"hlo8",   -BFD_RELOC_AVR_LO8_LDI,   -BFD_RELOC_AVR_LO8_LDI_NEG,   0},
  {"hhi8",   -BFD_RELOC_AVR_HI8_LDI,   -BFD_RELOC_AVR_HI8_LDI_NEG,   0},
a1083 4
	case -BFD_RELOC_AVR_LO8_LDI:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 16), where);
	  break;

d1088 1
a1088 1
	case -BFD_RELOC_AVR_HI8_LDI:
a1099 4
	case -BFD_RELOC_AVR_LO8_LDI_NEG:
	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 16), where);
	  break;

d1104 1
a1104 1
	case -BFD_RELOC_AVR_HI8_LDI_NEG:
d1190 26
@


1.29
log
@* config/tc-avr.c: Convert to ISO C90 format.  Fix formatting and generally
  tidy up the code.
* config/tc-avr.h: Likewise.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005
d177 8
d437 6
a442 1
    hash_insert (avr_mod_hash, EXP_MOD_NAME (i), (void *) (i + 10));
d525 4
a528 1
      mod = (int) hash_find (avr_mod_hash, op);
@


1.28
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d28 1
d32 5
a36 5
  char *name;
  char *constraints;
  int insn_size;		/* In words.  */
  int isa;
  unsigned int bin_opcode;
d125 2
a126 2
static struct mcu_type_s default_mcu = {"avr2", AVR_ISA_2xxx,bfd_mach_avr2};
static struct mcu_type_s *avr_mcu = &default_mcu;
d131 3
a133 3
  int all_opcodes;  /* -mall-opcodes: accept all known AVR opcodes  */
  int no_skip_bug;  /* -mno-skip-bug: no warnings for skipping 2-word insns  */
  int no_wrap;      /* -mno-wrap: reject rjmp/rcall with 8K wrap-around  */
d140 2
a141 1
static void avr_set_arch (int dummy);
d152 4
a155 14
static void show_mcu_list PARAMS ((FILE *));
static char *skip_space PARAMS ((char *));
static char *extract_word PARAMS ((char *, char *, int));
static unsigned int avr_operand PARAMS ((struct avr_opcodes_s *,
					 int, char *, char **));
static unsigned int avr_operands PARAMS ((struct avr_opcodes_s *, char **));
static unsigned int avr_get_constant PARAMS ((char *, int));
static char *parse_exp PARAMS ((char *, expressionS *));
static bfd_reloc_code_real_type avr_ldi_expression PARAMS ((expressionS *));

#define EXP_MOD_NAME(i) exp_mod[i].name
#define EXP_MOD_RELOC(i) exp_mod[i].reloc
#define EXP_MOD_NEG_RELOC(i) exp_mod[i].neg_reloc
#define HAVE_PM_P(i) exp_mod[i].have_pm
d159 4
a162 4
  char *name;
  bfd_reloc_code_real_type reloc;
  bfd_reloc_code_real_type neg_reloc;
  int have_pm;
d184 6
a189 3
#define OPTION_ALL_OPCODES (OPTION_MD_BASE + 1)
#define OPTION_NO_SKIP_BUG (OPTION_MD_BASE + 2)
#define OPTION_NO_WRAP     (OPTION_MD_BASE + 3)
d205 1
a205 2
show_mcu_list (stream)
     FILE *stream;
d231 1
a231 2
skip_space (s)
     char *s;
d264 2
a265 3
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d272 1
a272 2
md_show_usage (stream)
     FILE *stream;
d294 1
a294 2
avr_set_arch (dummy)
     int dummy ATTRIBUTE_UNUSED;
d296 1
a296 1
  char *str;
a297 1
  str = (char *) alloca (20);
d304 1
a304 3
md_parse_option (c, arg)
     int c;
     char *arg;
d357 1
a357 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d359 1
a359 1
  return 0;
d368 1
a368 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d405 3
a407 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d413 1
a413 1
md_begin ()
d417 1
d428 1
a428 1
  for (i = 0; i < sizeof (exp_mod) / sizeof (exp_mod[0]); ++i)
d438 1
a438 3
avr_get_constant (str, max)
     char *str;
     int max;
d441 1
d444 1
a444 1
  expression (&ex);
d455 1
a455 2
/* Parse instruction operands.
   Return binary opcode.  */
d457 2
a458 4
static unsigned int
avr_operands (opcode, line)
     struct avr_opcodes_s *opcode;
     char **line;
d460 9
a468 6
  char *op = opcode->constraints;
  unsigned int bin = opcode->bin_opcode;
  char *frag = frag_more (opcode->insn_size * 2);
  char *str = *line;
  int where = frag - frag_now->fr_literal;
  static unsigned int prev = 0;  /* Previous opcode.  */
d470 2
a471 2
  /* Opcode have operands.  */
  if (*op)
d473 8
a480 4
      unsigned int reg1 = 0;
      unsigned int reg2 = 0;
      int reg1_present = 0;
      int reg2_present = 0;
d482 9
a490 5
      /* Parse first operand.  */
      if (REGISTER_P (*op))
	reg1_present = 1;
      reg1 = avr_operand (opcode, where, op, &str);
      ++op;
d492 6
a497 5
      /* Parse second operand.  */
      if (*op)
	{
	  if (*op == ',')
	    ++op;
d499 8
a506 9
	  if (*op == '=')
	    {
	      reg2 = reg1;
	      reg2_present = 1;
	    }
	  else
	    {
	      if (REGISTER_P (*op))
		reg2_present = 1;
d508 1
a508 4
	      str = skip_space (str);
	      if (*str++ != ',')
		as_bad (_("`,' required"));
	      str = skip_space (str);
d510 3
a512 1
	      reg2 = avr_operand (opcode, where, op, &str);
d514 3
a516 1
	    }
d518 2
a519 9
	  if (reg1_present && reg2_present)
	    reg2 = (reg2 & 0xf) | ((reg2 << 5) & 0x200);
	  else if (reg2_present)
	    reg2 <<= 4;
	}
      if (reg1_present)
	reg1 <<= 4;
      bin |= reg1 | reg2;
    }
d521 3
a523 3
  /* Detect undefined combinations (like ld r31,Z+).  */
  if (!avr_opt.all_opcodes && AVR_UNDEF_P (bin))
    as_warn (_("undefined combination of operands"));
d525 1
a525 4
  if (opcode->insn_size == 2)
    {
      /* Warn if the previous opcode was cpse/sbic/sbis/sbrc/sbrs
         (AVR core bug, fixed in the newer devices).  */
d527 10
a536 4
      if (!(avr_opt.no_skip_bug ||
            (avr_mcu->isa & (AVR_ISA_MUL | AVR_ISA_MOVW)))
	  && AVR_SKIP_P (prev))
	as_warn (_("skipping two-word instruction"));
d538 9
a546 4
      bfd_putl32 ((bfd_vma) bin, frag);
    }
  else
    bfd_putl16 ((bfd_vma) bin, frag);
d548 6
a553 4
  prev = bin;
  *line = str;
  return bin;
}
d555 2
a556 1
/* Parse for ldd/std offset */
d558 10
a567 6
static void
avr_offset_expression (expressionS *exp)
{
  char *str = input_line_pointer;
  char *tmp;
  char op[8];
d569 4
a572 2
  tmp = str;
  str = extract_word (str, op, sizeof (op));
d581 1
a581 1
      
d585 2
d593 4
a596 5
avr_operand (opcode, where, op, line)
     struct avr_opcodes_s *opcode;
     int where;
     char *op;
     char **line;
d833 84
d921 1
a921 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d934 1
a934 3
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec;
d948 1
a948 4
md_apply_fix (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg;
d1177 2
a1178 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d1182 1
a1182 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d1184 1
a1184 1
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d1207 1
a1207 2
md_assemble (str)
     char *str;
d1238 1
a1245 111
/* Parse ordinary expression.  */

static char *
parse_exp (s, op)
     char *s;
     expressionS *op;
{
  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  return input_line_pointer;
}

/* Parse special expressions (needed for LDI command):
   xx8 (address)
   xx8 (-address)
   pm_xx8 (address)
   pm_xx8 (-address)
   where xx is: hh, hi, lo.  */

static bfd_reloc_code_real_type
avr_ldi_expression (exp)
     expressionS *exp;
{
  char *str = input_line_pointer;
  char *tmp;
  char op[8];
  int mod;
  tmp = str;

  str = extract_word (str, op, sizeof (op));

  if (op[0])
    {
      mod = (int) hash_find (avr_mod_hash, op);

      if (mod)
	{
	  int closes = 0;

	  mod -= 10;
	  str = skip_space (str);

	  if (*str == '(')
	    {
	      int neg_p = 0;

	      ++str;

	      if (strncmp ("pm(", str, 3) == 0
		  || strncmp ("-(pm(", str, 5) == 0)
		{
		  if (HAVE_PM_P (mod))
		    {
		      ++mod;
		      ++closes;
		    }
		  else
		    as_bad (_("illegal expression"));

		  if (*str == '-')
		    {
		      neg_p = 1;
		      ++closes;
		      str += 5;
		    }
		  else
		    str += 3;
		}

	      if (*str == '-' && *(str + 1) == '(')
		{
		  neg_p ^= 1;
		  ++closes;
		  str += 2;
		}

	      input_line_pointer = str;
	      expression (exp);

	      do
		{
		  if (*input_line_pointer != ')')
		    {
		      as_bad (_("`)' required"));
		      break;
		    }
		  input_line_pointer++;
		}
	      while (closes--);

	      return neg_p ? EXP_MOD_NEG_RELOC (mod) : EXP_MOD_RELOC (mod);
	    }
	}
    }

  input_line_pointer = tmp;
  expression (exp);

  /* Warn about expressions that fail to use lo8 ().  */
  if (exp->X_op == O_constant)
    {
      int x = exp->X_add_number;
      if (x < -255 || x > 255)
	as_warn (_("constant out of 8-bit range: %d"), x);
    }

  return BFD_RELOC_AVR_LDI;
}

d1255 1
a1255 3
avr_parse_cons_expression (exp, nbytes)
     expressionS *exp;
     int nbytes;
d1297 4
a1300 5
avr_cons_fix_new (frag, where, nbytes, exp)
     fragS *frag;
     int where;
     int nbytes;
     expressionS *exp;
@


1.27
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d1088 5
a1092 6
/* A `BFD_ASSEMBLER' GAS will call this to generate a reloc.  GAS
   will pass the resulting reloc to `bfd_install_relocation'.  This
   currently works poorly, as `bfd_install_relocation' often does the
   wrong thing, and instances of `tc_gen_reloc' have been written to
   work around the problems, which in turns makes it difficult to fix
   `bfd_install_relocation'.  */
@


1.26
log
@Update the address and phone number of the FSF
@
text
@d866 1
a866 1
md_apply_fix3 (fixP, valP, seg)
@


1.25
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d21 2
a22 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.24
log
@
	* config/tc-avr.c (mcu_types): Move attiny{13,2313} from avr4 to avr2.
@
text
@d3 2
a4 1
   Copyright 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
d910 1
a910 1
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
@


1.23
log
@Add support for the new R_AVR_LDI, R_AVR_6 and R_AVR_6_ADIW relocs for the
LDI, ADIW/SBIW and LDD/STD instructions.
@
text
@d65 1
a65 1
  {"avr2",      AVR_ISA_2xxx,     bfd_mach_avr2},
d88 2
a101 2
  {"attiny13",  AVR_ISA_TINY2,    bfd_mach_avr4},
  {"attiny2313",AVR_ISA_TINY2,    bfd_mach_avr4},
@


1.22
log
@Add support for atmega165, atmega325, atmega3250, atmega645 and atmega6450.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d560 25
d723 2
a724 2
	    unsigned int x;
	    x = avr_get_constant (str, 63);
d726 2
a727 1
	    op_mask |= (x & 7) | ((x & (3 << 3)) << 7) | ((x & (1 << 5)) << 8);
d779 5
a783 7
      {
	unsigned int x;

	x = avr_get_constant (str, 63);
	str = input_line_pointer;
	op_mask |= (x & 0xf) | ((x & 0x30) << 2);
      }
d963 21
a1274 2
  else
    as_warn (_("expression possibly out of 8-bit range"));
d1276 1
a1276 1
  return BFD_RELOC_AVR_LO8_LDI;
@


1.21
log
@
	* gas/config/tc-avr.c: Add support for
	atmega48, atmega88, atmega168, attiny13, attiny2313, at90can128.

	* include/opcode/avr.h: Add support for
	atmega48, atmega88, atmega168, attiny13, attiny2313, at90can128.
@
text
@d106 1
d111 2
d115 2
@


1.20
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d93 1
d97 1
d100 2
d106 1
d112 1
d540 2
a541 1
      if (!(avr_opt.no_skip_bug || (avr_mcu->isa & AVR_ISA_MUL))
@


1.19
log
@	* config/tc-avr.c (md_apply_fix3): Reinstate code handling pcrel
	fixups to current or absolute section.
@
text
@d697 1
a697 1
		   &op_expr, false, BFD_RELOC_AVR_CALL);
d703 1
a703 1
		   &op_expr, true, BFD_RELOC_AVR_13_PCREL);
d709 1
a709 1
		   &op_expr, true, BFD_RELOC_AVR_7_PCREL);
d715 1
a715 1
		   &op_expr, false, BFD_RELOC_16);
d726 1
a726 1
		     &op_expr, false, r_type);
d1286 1
a1286 1
	fix_new_exp (frag, where, nbytes, exp, false, BFD_RELOC_16);
d1288 1
a1288 1
	fix_new_exp (frag, where, nbytes, exp, false, BFD_RELOC_32);
d1295 1
a1295 1
	fix_new_exp (frag, where, nbytes, exp, false, BFD_RELOC_AVR_16_PM);
@


1.18
log
@gas reloc rewrite.
@
text
@d841 11
@


1.17
log
@
	* config/tc-avr.c (mcu_types): Update.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d836 1
a836 1
  long value = * (long *) valP;
d841 3
a843 29
  else if (fixP->fx_pcrel)
    {
      segT s = S_GET_SEGMENT (fixP->fx_addsy);

      if (fixP->fx_addsy && (s == seg || s == absolute_section))
	{
	  value += S_GET_VALUE (fixP->fx_addsy);
	  fixP->fx_done = 1;
	}
    }
  else
    {
      value = fixP->fx_offset;

      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    {
	      value -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_done = 1;
	    }
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("expression too complex"));
	    }
	}
    }
a1015 1
      fixP->fx_addnumber = value;
@


1.16
log
@
	* config/tc-avr.c (mcu_types): Update for new devices.
@
text
@d87 1
d94 1
a94 1
  {"atmega83",  AVR_ISA_M8,       bfd_mach_avr4}, /* XXX -> m163 */
d97 1
d102 1
@


1.15
log
@Fix md_apply_fix3 typo.
@
text
@a77 1
  {"attiny22" , AVR_ISA_2xxx,     bfd_mach_avr2},
d79 2
d90 1
d95 1
d98 1
a103 1
  {"at43usb355",AVR_ISA_94K,      bfd_mach_avr5},
@


1.14
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d841 1
a841 1
	  value = S_GET_VALUE (fixP->fx_addsy) + *valuep;
@


1.13
log
@	* config/tc-avr.c (mcu_types): Update for new devices.
@
text
@d822 4
a825 4
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
d830 1
a830 1
  long value;
d832 4
a835 6
  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
d837 1
a837 1
      segT s = S_GET_SEGMENT (fixp->fx_addsy);
d839 1
a839 1
      if (fixp->fx_addsy && (s == seg || s == absolute_section))
d841 2
a842 2
	  value = S_GET_VALUE (fixp->fx_addsy) + *valuep;
	  fixp->fx_done = 1;
a843 2
      else
	value = *valuep;
d847 1
a847 1
      value = fixp->fx_offset;
d849 1
a849 1
      if (fixp->fx_subsy != (symbolS *) NULL)
d851 1
a851 1
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
d853 2
a854 2
	      value -= S_GET_VALUE (fixp->fx_subsy);
	      fixp->fx_done = 1;
d859 1
a859 1
	      as_bad_where (fixp->fx_file, fixp->fx_line,
d865 1
a865 1
  switch (fixp->fx_r_type)
d868 1
a868 1
      fixp->fx_no_overflow = 1;
d878 1
a878 1
  if (fixp->fx_done)
d882 1
a882 1
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
d885 1
a885 1
      switch (fixp->fx_r_type)
d889 1
a889 1
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d897 1
a897 1
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d905 1
a905 1
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d916 1
a916 1
		as_bad_where (fixp->fx_file, fixp->fx_line,
d1006 1
a1006 1
	      as_bad_where (fixp->fx_file, fixp->fx_line,
d1017 1
a1017 1
		    fixp->fx_line, fixp->fx_r_type);
d1023 1
a1023 1
      switch (fixp->fx_r_type)
d1029 1
a1029 1
	  as_bad_where (fixp->fx_file, fixp->fx_line,
d1031 1
a1031 1
	  fixp->fx_done = 1;
d1036 1
a1036 1
      fixp->fx_addnumber = value;
a1037 1
  return 0;
@


1.12
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d58 4
d67 1
a67 1
  {"avr4",      AVR_ISA_M83,      bfd_mach_avr4},
d70 1
a70 1
  {"attiny10",  AVR_ISA_TINY1,    bfd_mach_avr1},
d77 1
a77 1
  {"at90s2333", AVR_ISA_2xxx,     bfd_mach_avr2},
d81 2
a82 2
  {"at90s4414", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at90s4434", AVR_ISA_2xxx,     bfd_mach_avr2},
d86 1
a86 1
  {"atmega603", AVR_ISA_M603,     bfd_mach_avr3},
d88 6
a93 2
  {"atmega83",  AVR_ISA_M83,      bfd_mach_avr4},
  {"atmega85",  AVR_ISA_M83,      bfd_mach_avr4},
d96 5
a100 1
  {"atmega32",  AVR_ISA_M161,     bfd_mach_avr5},
@


1.11
log
@Fix copyright notices
@
text
@d3 1
a3 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
a23 1
#include <ctype.h>
d25 1
d301 1
a301 1
	    *t = tolower (*arg1++);
d558 1
a558 1
	  if (isdigit (r_name[1]))
d563 1
a563 1
		       && isdigit (r_name[2])
d616 1
a616 1
	c = tolower (*str);
d659 1
a659 1
	char c = tolower (*str++);
@


1.10
log
@2000-09-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-a29k.c: Fix formatting.
	* config/tc-alpha.c: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-tic80.h: Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.10.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.9
log
@	* config/tc-avr.c: Use PARAMS macro in function declarations.
	Don't declare md_pcrel_from_section (already in tc-avr.h).
	(avr_operands): Use AVR_UNDEF_P and AVR_SKIP_P macros.
	(avr_operand): Don't set (unsigned) op_mask to -1.
@
text
@d187 1
a187 1
  
d191 1
a191 1
      
d193 1
a193 1
      
d202 1
a202 1
  
d235 1
a235 1
  
d277 1
a277 1
  
d335 1
a335 1
  
d380 1
a380 1
  
d387 1
a387 1
  
d439 1
a439 1
  
d477 1
a477 1
	  
d496 1
a496 1
	  
d555 1
a555 1
	  
d573 1
a573 1
      
d583 1
a583 1
	      
d589 1
a589 1
	      
d595 1
a595 1
	      
d610 1
a610 1
	
d644 1
a644 1
      
d647 1
a647 1
      
d660 1
a660 1
	
d703 1
a703 1
	
d715 1
a715 1
	
d725 1
a725 1
	
d736 1
a736 1
	
d748 1
a748 1
	
d758 1
a758 1
	
d764 1
a764 1
      
d767 1
a767 1
      
d771 1
a771 1
  
d803 1
a803 1
  
d828 1
a828 1
      
d840 1
a840 1
      
d856 1
a856 1
  
d883 1
a883 1
	  
d887 1
a887 1
	  
d899 1
a899 1
	  
d995 1
a995 1
	    
d1146 1
a1146 1
  
d1150 1
a1150 1
      
d1154 1
a1154 1
	  
d1157 1
a1157 1
	  
d1161 1
a1161 1
	      
d1163 1
a1163 1
	      
d1174 1
a1174 1
		  
d1184 1
a1184 1
	      
d1191 1
a1191 1
	      
d1194 1
a1194 1
	      
d1205 1
a1205 1
	      
d1210 1
a1210 1
  
d1250 1
a1250 1
      
d1254 1
a1254 1
	  
d1260 1
a1260 1
	      
d1268 1
a1268 1
	      
d1271 1
a1271 1
	  
d1275 1
a1275 1
  
@


1.8
log
@Fix formatting
@
text
@d120 9
a128 10
static void show_mcu_list (FILE *stream);
static char *skip_space (char *s);
static char *extract_word (char *from, char *to, int limit);
static unsigned int avr_operand (struct avr_opcodes_s *opcode,
				 int where, char *op, char **line);
static unsigned int avr_operands (struct avr_opcodes_s *opcode, char **line);
static unsigned int avr_get_constant (char *str, int max);
static char *parse_exp (char *s, expressionS *op);
static bfd_reloc_code_real_type avr_ldi_expression (expressionS *exp);
long md_pcrel_from_section PARAMS ((fixS *, segT));
d507 3
a509 9
  if (!avr_opt.all_opcodes)
    {
      /* Detect undefined combinations (like ld r31,Z+).  */
      if (((bin & 0xFDEF) == 0x91AD) || ((bin & 0xFDEF) == 0x91AE) ||
	  ((bin & 0xFDEF) == 0x91C9) || ((bin & 0xFDEF) == 0x91CA) ||
	  ((bin & 0xFDEF) == 0x91E1) || ((bin & 0xFDEF) == 0x91E2) ||
	  ((bin & 0xFFED) == 0x91E5))
	as_warn (_("undefined combination of operands"));
    }
d516 3
a518 7
      if (!((avr_mcu->isa & AVR_ISA_MUL) || avr_opt.no_skip_bug))
	{
	  if ((prev & 0xFC00) == 0x1000
	      || (prev & 0xFD00) == 0x9900
	      || (prev & 0xFC08) == 0xFC00)
	    as_warn (_("skipping two-word instruction"));
	}
a551 2
      op_mask = -1;
      
d557 1
d597 1
a597 2
	      op_mask -= 24;
	      if (op_mask & 1 || op_mask > 6)
d599 1
a599 1
	      op_mask >>= 1;
@


1.7
log
@Tidy up formatting.
Add  -mall-opcodes, -mno-skip-bug, -mno-wrap.
@
text
@d32 1
a32 1
  int insn_size;		/* in words */
a45 1

a92 1

d100 3
a102 3
  int all_opcodes;  /* -mall-opcodes: accept all known AVR opcodes */
  int no_skip_bug;  /* -mno-skip-bug: no warnings for skipping 2-word insns */
  int no_wrap;      /* -mno-wrap: reject rjmp/rcall with 8K wrap-around */
d121 2
a122 2
static char * skip_space (char * s);
static char * extract_word (char *from, char *to, int limit);
d126 2
a127 2
static unsigned int avr_get_constant (char * str, int max);
static char *parse_exp (char *s, expressionS * op);
a130 1

d138 1
a138 1
  char * name;
d144 2
a145 1
static struct exp_mod_s exp_mod[] = {
d167 2
a168 1
struct option md_longopts[] = {
a174 1
size_t md_longopts_size = sizeof(md_longopts);
d176 1
d179 1
d181 2
a182 1
show_mcu_list (FILE *stream)
d188 1
d192 1
d194 1
d196 1
a196 3
	{
	  fprintf (stream, " %s", mcu_types[i].name);
	}
d203 2
a204 1
    fprintf (stream, "\n");
a206 1

d209 1
a209 1
     char * s;
d217 1
d228 1
d230 1
a230 1
  for (op_start = op_end = from; *op_end != 0 && is_part_of_name(*op_end); )
d236 1
d252 1
a252 1
  FILE *stream;
d277 3
a279 2
  char * str;
  str = (char *)alloca (20);
d302 1
a302 1
	    *t = tolower(*arg1++);
a318 1

d336 1
d341 1
a341 1
md_undefined_symbol(name)
d347 5
a351 4
/* Convert a string pointed to by input_line_pointer into a floating point
   constant of type `type', and store the appropriate bytes to `*litP'.
   The number of LITTLENUMS emitted is stored in `*sizeP'.  Returns NULL if
   OK, or an error message otherwise.  */
d381 1
d388 1
d394 3
a396 3
  bfd *abfd ATTRIBUTE_UNUSED;
  asection *sec ATTRIBUTE_UNUSED;
  fragS *fragP ATTRIBUTE_UNUSED;
a400 1

d406 1
a406 1
  avr_hash = hash_new();
a410 1

d417 2
a418 2
    hash_insert (avr_mod_hash, EXP_MOD_NAME(i), (void*)(i+10));
  
a421 1

d423 1
a423 1
   If result greater than MAX then error. */
d427 1
a427 1
     char * str;
d439 2
a440 1
    as_bad (_("number must be less than %d"), max+1);
a443 1

d445 1
a445 1
   Returns binary opcode. */
d457 1
a457 1
  static unsigned int prev = 0;  /* previous opcode */
d478 1
d497 1
d531 1
a531 1
      bfd_putl32 ((bfd_vma)bin, frag);
d534 1
a534 1
    bfd_putl16 ((bfd_vma)bin, frag);
d541 2
a543 3
/* Parse one instruction operand.
   Returns operand bitmask. Also fixups can be generated.  */
   
d563 55
a617 57
      {
	op_mask = -1;

	if (*str == 'r' || *str == 'R')
	  {	    
	    char r_name[20];
	    
	    str = extract_word (str, r_name, sizeof (r_name));
	    if (isdigit(r_name[1]))
	      {
		if (r_name[2] == '\0')
		  op_mask = r_name[1] - '0';
		else if (r_name[1] != '0'
			 && isdigit(r_name[2])
			 && r_name[3] == '\0')
		  op_mask = (r_name[1] - '0') * 10 + r_name[2] - '0';
	      }
	  }
	else
	  {
	    op_mask = avr_get_constant (str, 31);
	    str = input_line_pointer;
	  }
	
	if (op_mask <= 31)
	  {
	    switch (*op)
	      {
	      case 'a':
		if (op_mask < 16 || op_mask > 23)
		  as_bad (_("register r16-r23 required"));
		op_mask -= 16;
		break;

	      case 'd':
		if (op_mask < 16)
		  as_bad (_("register number above 15 required"));
		op_mask -= 16;
		break;
		
	      case 'v':
		if (op_mask & 1)
		  as_bad (_("even register number required"));
		op_mask >>= 1;
		break;
		
	      case 'w':
		op_mask -= 24;
		if (op_mask & 1 || op_mask > 6)
		  as_bad (_("register r24, r26, r28 or r30 required"));
		op_mask >>= 1;
		break;
	      }
	    break;
	  }
	as_bad (_("register name or number from 0 to 31 required"));
      }
d623 1
d626 1
a626 1
	    str = skip_space (str+1);
d637 1
a637 1
	str = skip_space (str+1);
a647 1
	
d655 7
a661 3
      {
	if (*str == '-')
	  as_bad (_("can't predecrement"));
d663 5
a667 10
	if (! (*str == 'z' || *str == 'Z'))
	  as_bad (_("pointer register Z required"));

	str = skip_space (str + 1);
	if (*str == '+')
	  {
	    ++str;
	    op_mask |= 1;
	  }
      }
d673 1
d690 3
a692 6
      {
	str = parse_exp (str, &op_expr);
	fix_new_exp (frag_now, where, opcode->insn_size * 2,
		     &op_expr, false, BFD_RELOC_AVR_CALL);

      }
d696 3
a698 6
      {
	str = parse_exp (str, &op_expr);
	fix_new_exp (frag_now, where, opcode->insn_size * 2,
		     &op_expr, true, BFD_RELOC_AVR_13_PCREL);

      }
d702 3
a704 6
      {
	str = parse_exp (str, &op_expr);
	fix_new_exp (frag_now, where, opcode->insn_size * 2,
		     &op_expr, true, BFD_RELOC_AVR_7_PCREL);

      }
d708 3
a710 6
      {
	str = parse_exp (str, &op_expr);
	fix_new_exp (frag_now, where+2, opcode->insn_size * 2,
		     &op_expr, false, BFD_RELOC_16);

      }
d716 4
a719 3
 	input_line_pointer = str;
 	r_type = avr_ldi_expression (&op_expr);
 	str = input_line_pointer;
d728 1
d738 1
d749 1
d761 1
d771 1
d777 1
d780 1
d784 1
d791 1
d806 1
d812 1
a812 1
  if (fixp->fx_addsy != (symbolS *)NULL
d816 1
d821 2
a822 1
   value in the object file. */
d841 1
d853 1
d864 1
a864 1
 	      as_bad_where (fixp->fx_file, fixp->fx_line,
d869 1
d896 1
d900 1
d912 1
d938 1
a938 1
	  bfd_putl16 ((bfd_vma) (value>>1), where);
d1008 1
d1016 1
a1016 1
	    bfd_putl16 ((bfd_vma) (value & 0xffff), where+2);
d1021 2
a1022 2
	  as_fatal ( _("line %d: unknown relocation type: 0x%x"),
		     fixp->fx_line, fixp->fx_r_type);
a1045 1

d1051 1
a1051 1
   `bfd_install_relocation'. */
d1073 2
a1074 2
                    _("reloc %d not supported by object file format"),
		    (int)fixp->fx_r_type);
a1086 1

d1091 1
a1091 1
  struct avr_opcodes_s * opcode;
d1094 1
a1094 1
  str = skip_space (extract_word (str, op, sizeof(op)));
d1109 1
a1109 1
  
d1128 1
d1132 1
a1132 1
     expressionS * op;
a1140 1

d1146 2
a1147 2
   where xx is: hh, hi, lo
*/
d1159 1
d1163 1
d1167 1
d1170 1
d1174 1
d1176 1
d1180 1
a1180 1
		  if (HAVE_PM_P(mod))
d1187 1
d1197 1
d1204 1
d1207 1
d1218 1
d1223 1
d1227 1
a1227 1
  /* Warn about expressions that fail to use lo8().  */
d1241 1
a1241 1
   `avr_cons_fix_new' */
d1246 2
a1247 1
   Relocation: BFD_RELOC_AVR_16_PM */
d1253 1
a1253 1
  char * tmp;
d1261 1
a1261 1
      char * pm_name = "pm";
d1263 1
d1267 1
d1273 1
d1281 1
d1284 1
d1288 1
d1293 1
a1293 1
avr_cons_fix_new(frag, where, nbytes, exp)
@


1.6
log
@Applied Marek Michalkiewicz <marekm@@linux.org.pl>'s patch to ehance the AVR port.
@
text
@d99 10
d122 1
d164 4
a167 1
#define OPTION_MMCU (OPTION_MD_BASE + 1)
d170 5
a174 2
  {"mmcu", required_argument, NULL, 'm'},
  {NULL, no_argument, NULL, 0}
d178 27
d249 2
a250 3
  fprintf
    (stream,
     _ ("AVR options:\n"
d259 7
d275 1
a275 1
  md_parse_option ('m', str);
d284 6
a289 6
  char *t = alloca (strlen (arg) + 1);
  char *s = t;
  char *arg1 = arg;
  do
    *t = tolower (*arg1++);
  while (*t++);
d291 8
a298 3
  if (c == 'm')
    {
      int i;
d300 3
a302 3
      for (i = 0; mcu_types[i].name; ++i)
	if (strcmp (mcu_types[i].name, s) == 0)
	  break;
d304 5
a308 2
      if (!mcu_types[i].name)
	as_fatal (_ ("unknown MCU: %s\n"), arg);
d310 3
a312 3
      /* It is OK to redefine mcu type within the same avr[1-5] bfd machine
	 type - this for allows passing -mmcu=... via gcc ASM_SPEC as well
	 as .arch ... in the asm output at the same time.  */
d314 15
a328 5
      if (avr_mcu == &default_mcu || avr_mcu->mach == mcu_types[i].mach)
	avr_mcu = &mcu_types[i];
      else
	as_fatal (_ ("redefinition of mcu type `%s' to `%s'"),
		  avr_mcu->name, mcu_types[i].name);
d484 1
a484 1
		as_bad (_ ("`,' required"));
d500 10
a509 7
  /* detect undefined combinations (like lpm r31,Z+) */
    if (((bin & 0xFDEF) == 0x91AD) || ((bin & 0xFDEF) == 0x91AE) ||
	((bin & 0xFDEF) == 0x91C9) || ((bin & 0xFDEF) == 0x91CA) ||
	((bin & 0xFDEF) == 0x91E1) || ((bin & 0xFDEF) == 0x91E2) ||
	((bin & 0xFFED) == 0x91E5))
      as_warn( _("undefined combination of operands"));
    
d512 11
a522 7
      /* warn if previous opcode was cpse/sbic/sbis/sbrc/sbrs
	 (AVR core bug)  */
      if ((prev & 0xFC00) == 0x1000
	  || (prev & 0xFD00) == 0x9900
	  || (prev & 0xFC08) == 0xFC00)
	as_warn (_("skipping two-word instruction"));
      
d586 1
a586 1
		  as_bad (_ ("register r16-r23 required"));
d592 1
a592 1
		  as_bad (_ ("register number above 15 required"));
d598 1
a598 1
		  as_bad (_ ("even register number required"));
d605 1
a605 1
		  as_bad (_ ("register r24,r26,r28 or r30 required"));
d611 1
a611 1
	as_bad (_ ("register name or number from 0 to 31 required"));
d629 1
a629 1
	  as_bad (_ ("pointer register (X,Y or Z) required"));
d636 1
a636 1
	      as_bad (_ ("cannot both predecrement and postincrement"));
d643 3
a645 2
	if ((op_mask & 0x100F) && !(avr_mcu->isa & AVR_ISA_SRAM))
	  as_bad (_ ("addressing mode not supported"));
d652 1
a652 1
	  as_bad (_ ("can't predecrement"));
d655 1
a655 1
	  as_bad (_ ("pointer register Z required"));
d672 1
a672 1
	  as_bad (_ ("pointer register (Y or Z) required"));
d781 1
a781 1
      as_bad (_ ("unknown constraint `%c'"), *op);
d857 1
a857 1
			    _ ("expression too complex"));
d908 1
a908 1
	      if (avr_mcu->isa & AVR_ISA_MEGA)
d1086 1
a1086 1
    as_bad (_ ("can't find opcode "));
d1092 1
a1092 1
      as_bad (_ ("unknown opcode `%s'"), op);
d1102 2
a1103 2
  if ((opcode->isa & avr_mcu->isa) != opcode->isa)
    as_bad (_ ("illegal opcode %s for mcu %s"), opcode->name, avr_mcu->name);
d1111 1
a1111 1
      as_bad (_ ("garbage at end of line"));
d1169 1
a1169 1
		    as_bad (_ ("illegal expression"));
d1191 1
a1191 1
		      as_bad (_ ("`)' required"));
d1203 11
d1251 1
a1251 1
		  as_bad (_ ("`)' required"));
d1276 1
a1276 1
	as_bad (_ ("illegal %srelocation size: %d"), "", nbytes);
d1283 1
a1283 1
	as_bad (_ ("illegal %srelocation size: %d"), "`pm' ", nbytes);
@


1.5
log
@	* config/tc-avr.c (avr_operand): fix the fomratting of the comment.
@
text
@d62 1
a62 1
  {"avr2",      AVR_ISA_85xx,     bfd_mach_avr2},
d64 2
a65 1
  {"avr4",      AVR_ISA_ALL,      bfd_mach_avr4},
d80 3
a82 3
  {"at90s8515", AVR_ISA_85xx,     bfd_mach_avr2},
  {"at90s8535", AVR_ISA_85xx,     bfd_mach_avr2},
  {"at90c8534", AVR_ISA_85xx,     bfd_mach_avr2},
d85 6
a90 4
  {"atmega161", AVR_ISA_M161,     bfd_mach_avr4},
  {"at94k10",   AVR_ISA_94K,      bfd_mach_avr4},
  {"at94k20",   AVR_ISA_94K,      bfd_mach_avr4},
  {"at94k40",   AVR_ISA_94K,      bfd_mach_avr4},
d210 5
a214 4
	"                   avr1 - AT90S1200\n"
	"                   avr2 - AT90S2xxx, AT90S4xxx, AT90S85xx, ATtiny22\n"
	"                   avr3 - ATmega103 or ATmega603\n"
	"                   avr4 - ATmega161\n"
d251 6
a256 1
      if (avr_mcu == &default_mcu)
d259 2
a260 1
	as_fatal (_ ("redefinition of mcu type `%s'"), mcu_types[i].name);
d831 2
a832 8
	      if (avr_mcu->isa & AVR_ISA_WRAP)
		{
		  if (value > 2047)
		    value -= 4096;
		  else
		    value += 4096;
		}
	      else
@


1.4
log
@	* config/tc-avr.c (AVR_ISA_???): moved to include/opcode/avr.h
	(REGISTER_P): likewise.
	(avr_opcodes): uses include/opcode/avr.h
	(avr_operand): enable ld r,Z or st r,Z for at90s1200.
@
text
@d554 1
d556 2
a557 1
	   registers, no predecrement, no postincrement */
@


1.3
log
@	* config/tc-avr.c: ATTRIBUTE_UNUSED added to the necessary places.
	More comments added.
	(md_begin): Removed "construct symbols for each register name".
	Because register names conflicts with GCC generated function
	names.
	(avr_operand): Now constant numbers can be used as a register
	identifiers (0 as r0, 31 as r31).
	(md_assemble): use skip_space () before parsing instruction
	operands.
@
text
@d28 19
a50 23
#define AVR_ISA_1200  0x0001 /* in the beginning there was ... */
#define AVR_ISA_LPM   0x0002 /* device has LPM */
#define AVR_ISA_LPMX  0x0004 /* device has LPM Rd,Z[+] */
#define AVR_ISA_SRAM  0x0008 /* device has SRAM (LD, ST, PUSH, POP, ...) */
#define AVR_ISA_WRAP  0x0010 /* device has exactly 8K program memory */
#define AVR_ISA_MEGA  0x0020 /* device has >8K program memory (JMP, CALL) */
#define AVR_ISA_MUL   0x0040 /* device has new core (MUL, MOVW, ...) */
#define AVR_ISA_ELPM  0x0080 /* device has >64K program memory (ELPM) */
#define AVR_ISA_ELPMX 0x0100 /* device has ELPM Rd,Z[+] (none yet) */
#define AVR_ISA_SPM   0x0200 /* device can program itself (<=64K) */
#define AVR_ISA_ESPM  0x0400 /* device can program itself (>64K, none yet) */
#define AVR_ISA_EIND  0x0800 /* device has >128K program memory (none yet) */

#define AVR_ISA_TINY1 (AVR_ISA_1200 | AVR_ISA_LPM)
#define AVR_ISA_2xxx (AVR_ISA_TINY1 | AVR_ISA_SRAM)
#define AVR_ISA_85xx (AVR_ISA_2xxx | AVR_ISA_WRAP)
#define AVR_ISA_M603 (AVR_ISA_2xxx | AVR_ISA_MEGA)
#define AVR_ISA_M103 (AVR_ISA_M603 | AVR_ISA_ELPM)
#define AVR_ISA_M161 (AVR_ISA_M603 | AVR_ISA_MUL | AVR_ISA_LPMX | AVR_ISA_SPM)
#define AVR_ISA_94K  (AVR_ISA_M603 | AVR_ISA_MUL | AVR_ISA_LPMX)

#define AVR_ISA_ALL   0xFFFF

a107 15
#define REGISTER_P(x) ((x) == 'r'		\
		       || (x) == 'd'		\
		       || (x) == 'w'		\
		       || (x) == 'a'		\
		       || (x) == 'v')

struct avr_opcodes_s
{
  char *name;
  char *constraints;
  char *opcode;
  int insn_size;		/* in words */
  int isa;
  unsigned int bin_opcode;
};
a119 164
/* constraint letters
   r - any register
   d - `ldi' register (r16-r31)
   v - `movw' even register (r0, r2, ..., r28, r30)
   a - `fmul' register (r16-r23)
   w - `adiw' register (r24,r26,r28,r30)
   e - pointer registers (X,Y,Z)
   b - base pointer register and displacement ([YZ]+disp)
   z - Z pointer register (for [e]lpm Rd,Z[+])
   M - immediate value from 0 to 255
   n - immediate value from 0 to 255 ( n = ~M ). Relocation impossible
   s - immediate value from 0 to 7
   P - Port address value from 0 to 64. (in, out)
   p - Port address value from 0 to 32. (cbi, sbi, sbic, sbis)
   K - immediate value from 0 to 64 (used in `adiw', `sbiw')
   i - immediate value
   l - signed pc relative offset from -64 to 63
   L - signed pc relative offset from -2048 to 2047
   h - absolut code address (call, jmp)
   S - immediate value from 0 to 7 (S = s << 4)
*/

struct avr_opcodes_s avr_opcodes[] =
{
  {"adc",  "r,r", "000111rdddddrrrr", 1, AVR_ISA_1200, 0x1c00},
  {"add",  "r,r", "000011rdddddrrrr", 1, AVR_ISA_1200, 0x0c00},
  {"and",  "r,r", "001000rdddddrrrr", 1, AVR_ISA_1200, 0x2000},
  {"cp",   "r,r", "000101rdddddrrrr", 1, AVR_ISA_1200, 0x1400},
  {"cpc",  "r,r", "000001rdddddrrrr", 1, AVR_ISA_1200, 0x0400},
  {"cpse", "r,r", "000100rdddddrrrr", 1, AVR_ISA_1200, 0x1000},
  {"eor",  "r,r", "001001rdddddrrrr", 1, AVR_ISA_1200, 0x2400},
  {"mov",  "r,r", "001011rdddddrrrr", 1, AVR_ISA_1200, 0x2c00},
  {"mul",  "r,r", "100111rdddddrrrr", 1, AVR_ISA_MUL,  0x9c00},
  {"or",   "r,r", "001010rdddddrrrr", 1, AVR_ISA_1200, 0x2800},
  {"sbc",  "r,r", "000010rdddddrrrr", 1, AVR_ISA_1200, 0x0800},
  {"sub",  "r,r", "000110rdddddrrrr", 1, AVR_ISA_1200, 0x1800},

  {"clr",  "r=r", "001001rdddddrrrr", 1, AVR_ISA_1200, 0x2400},
  {"lsl",  "r=r", "000011rdddddrrrr", 1, AVR_ISA_1200, 0x0c00},
  {"rol",  "r=r", "000111rdddddrrrr", 1, AVR_ISA_1200, 0x1c00},
  {"tst",  "r=r", "001000rdddddrrrr", 1, AVR_ISA_1200, 0x2000},

  {"andi", "d,M", "0111KKKKddddKKKK", 1, AVR_ISA_1200, 0x7000},
  /*XXX special case*/
  {"cbr",  "d,n", "0111KKKKddddKKKK", 1, AVR_ISA_1200, 0x7000},
  {"cpi",  "d,M", "0011KKKKddddKKKK", 1, AVR_ISA_1200, 0x3000},
  {"ldi",  "d,M", "1110KKKKddddKKKK", 1, AVR_ISA_1200, 0xe000},
  {"ori",  "d,M", "0110KKKKddddKKKK", 1, AVR_ISA_1200, 0x6000},
  {"sbci", "d,M", "0100KKKKddddKKKK", 1, AVR_ISA_1200, 0x4000},
  {"sbr",  "d,M", "0110KKKKddddKKKK", 1, AVR_ISA_1200, 0x6000},
  {"subi", "d,M", "0101KKKKddddKKKK", 1, AVR_ISA_1200, 0x5000},

  {"sbrc", "r,s", "1111110rrrrr0sss", 1, AVR_ISA_1200, 0xfc00},
  {"sbrs", "r,s", "1111111rrrrr0sss", 1, AVR_ISA_1200, 0xfe00},
  {"bld",  "r,s", "1111100ddddd0sss", 1, AVR_ISA_1200, 0xf800},
  {"bst",  "r,s", "1111101ddddd0sss", 1, AVR_ISA_1200, 0xfa00},

  {"in",   "r,P", "10110PPdddddPPPP", 1, AVR_ISA_1200, 0xb000},
  {"out",  "P,r", "10111PPrrrrrPPPP", 1, AVR_ISA_1200, 0xb800},

  {"adiw", "w,K", "10010110KKddKKKK", 1, AVR_ISA_2xxx, 0x9600},
  {"sbiw", "w,K", "10010111KKddKKKK", 1, AVR_ISA_2xxx, 0x9700},

  {"cbi",  "p,s", "10011000pppppsss", 1, AVR_ISA_1200, 0x9800},
  {"sbi",  "p,s", "10011010pppppsss", 1, AVR_ISA_1200, 0x9a00},
  {"sbic", "p,s", "10011001pppppsss", 1, AVR_ISA_1200, 0x9900},
  {"sbis", "p,s", "10011011pppppsss", 1, AVR_ISA_1200, 0x9b00},

  /* ee = {X=11,Y=10,Z=00, 0} */
  {"ld",   "r,e", "100!000dddddee-+", 1, AVR_ISA_2xxx, 0x8000},
  {"st",   "e,r", "100!001rrrrree-+", 1, AVR_ISA_2xxx, 0x8200},
  {"ldd",  "r,b", "10o0oo0dddddbooo", 1, AVR_ISA_2xxx, 0x8000},
  {"std",  "b,r", "10o0oo1rrrrrbooo", 1, AVR_ISA_2xxx, 0x8200},
  {"sts",  "i,r", "1001001ddddd0000", 2, AVR_ISA_2xxx, 0x9200},
  {"lds",  "r,i", "1001000ddddd0000", 2, AVR_ISA_2xxx, 0x9000},

  {"brbc", "s,l", "111101lllllllsss", 1, AVR_ISA_1200, 0xf400},
  {"brbs", "s,l", "111100lllllllsss", 1, AVR_ISA_1200, 0xf000},

  {"brcc", "l",   "111101lllllll000", 1, AVR_ISA_1200, 0xf400},
  {"brcs", "l",   "111100lllllll000", 1, AVR_ISA_1200, 0xf000},
  {"breq", "l",   "111100lllllll001", 1, AVR_ISA_1200, 0xf001},
  {"brge", "l",   "111101lllllll100", 1, AVR_ISA_1200, 0xf404},
  {"brhc", "l",   "111101lllllll101", 1, AVR_ISA_1200, 0xf405},
  {"brhs", "l",   "111100lllllll101", 1, AVR_ISA_1200, 0xf005},
  {"brid", "l",   "111101lllllll111", 1, AVR_ISA_1200, 0xf407},
  {"brie", "l",   "111100lllllll111", 1, AVR_ISA_1200, 0xf007},
  {"brlo", "l",   "111100lllllll000", 1, AVR_ISA_1200, 0xf000},
  {"brlt", "l",   "111100lllllll100", 1, AVR_ISA_1200, 0xf004},
  {"brmi", "l",   "111100lllllll010", 1, AVR_ISA_1200, 0xf002},
  {"brne", "l",   "111101lllllll001", 1, AVR_ISA_1200, 0xf401},
  {"brpl", "l",   "111101lllllll010", 1, AVR_ISA_1200, 0xf402},
  {"brsh", "l",   "111101lllllll000", 1, AVR_ISA_1200, 0xf400},
  {"brtc", "l",   "111101lllllll110", 1, AVR_ISA_1200, 0xf406},
  {"brts", "l",   "111100lllllll110", 1, AVR_ISA_1200, 0xf006},
  {"brvc", "l",   "111101lllllll011", 1, AVR_ISA_1200, 0xf403},
  {"brvs", "l",   "111100lllllll011", 1, AVR_ISA_1200, 0xf003},

  {"rcall", "L",  "1101LLLLLLLLLLLL", 1, AVR_ISA_1200, 0xd000},
  {"rjmp",  "L",  "1100LLLLLLLLLLLL", 1, AVR_ISA_1200, 0xc000},

  {"call", "h",   "1001010hhhhh111h", 2, AVR_ISA_MEGA, 0x940e},
  {"jmp",  "h",   "1001010hhhhh110h", 2, AVR_ISA_MEGA, 0x940c},

  {"asr",  "r",   "1001010rrrrr0101", 1, AVR_ISA_1200, 0x9405},
  {"com",  "r",   "1001010rrrrr0000", 1, AVR_ISA_1200, 0x9400},
  {"dec",  "r",   "1001010rrrrr1010", 1, AVR_ISA_1200, 0x940a},
  {"inc",  "r",   "1001010rrrrr0011", 1, AVR_ISA_1200, 0x9403},
  {"lsr",  "r",   "1001010rrrrr0110", 1, AVR_ISA_1200, 0x9406},
  {"neg",  "r",   "1001010rrrrr0001", 1, AVR_ISA_1200, 0x9401},
  {"pop",  "r",   "1001000rrrrr1111", 1, AVR_ISA_2xxx, 0x900f},
  {"push", "r",   "1001001rrrrr1111", 1, AVR_ISA_2xxx, 0x920f},
  {"ror",  "r",   "1001010rrrrr0111", 1, AVR_ISA_1200, 0x9407},
  {"ser",  "d",   "11101111dddd1111", 1, AVR_ISA_1200, 0xef0f},
  {"swap", "r",   "1001010rrrrr0010", 1, AVR_ISA_1200, 0x9402},

  {"bclr", "S",   "100101001SSS1000", 1, AVR_ISA_1200, 0x9488},
  {"bset", "S",   "100101000SSS1000", 1, AVR_ISA_1200, 0x9408},

  {"clc",  "", 	  "1001010010001000", 1, AVR_ISA_1200, 0x9488},
  {"clh",  "", 	  "1001010011011000", 1, AVR_ISA_1200, 0x94d8},
  {"cli",  "", 	  "1001010011111000", 1, AVR_ISA_1200, 0x94f8},
  {"cln",  "", 	  "1001010010101000", 1, AVR_ISA_1200, 0x94a8},
  {"cls",  "", 	  "1001010011001000", 1, AVR_ISA_1200, 0x94c8},
  {"clt",  "", 	  "1001010011101000", 1, AVR_ISA_1200, 0x94e8},
  {"clv",  "", 	  "1001010010111000", 1, AVR_ISA_1200, 0x94b8},
  {"clz",  "", 	  "1001010010011000", 1, AVR_ISA_1200, 0x9498},
  {"icall","", 	  "1001010100001001", 1, AVR_ISA_2xxx, 0x9509},
  {"ijmp", "", 	  "1001010000001001", 1, AVR_ISA_2xxx, 0x9409},
  {"lpm",  "", 	  "1001010111001000", 1, AVR_ISA_TINY1,0x95c8},
  {"nop",  "", 	  "0000000000000000", 1, AVR_ISA_1200, 0x0000},
  {"ret",  "", 	  "1001010100001000", 1, AVR_ISA_1200, 0x9508},
  {"reti", "", 	  "1001010100011000", 1, AVR_ISA_1200, 0x9518},
  {"sec",  "", 	  "1001010000001000", 1, AVR_ISA_1200, 0x9408},
  {"seh",  "", 	  "1001010001011000", 1, AVR_ISA_1200, 0x9458},
  {"sei",  "", 	  "1001010001111000", 1, AVR_ISA_1200, 0x9478},
  {"sen",  "", 	  "1001010000101000", 1, AVR_ISA_1200, 0x9428},
  {"ses",  "", 	  "1001010001001000", 1, AVR_ISA_1200, 0x9448},
  {"set",  "", 	  "1001010001101000", 1, AVR_ISA_1200, 0x9468},
  {"sev",  "", 	  "1001010000111000", 1, AVR_ISA_1200, 0x9438},
  {"sez",  "", 	  "1001010000011000", 1, AVR_ISA_1200, 0x9418},
  {"sleep","", 	  "1001010110001000", 1, AVR_ISA_1200, 0x9588},
  {"wdr",  "", 	  "1001010110101000", 1, AVR_ISA_1200, 0x95a8},
  {"elpm", "", 	  "1001010111011000", 1, AVR_ISA_ELPM, 0x95d8},
  {"spm", "",     "1001010111101000", 1, AVR_ISA_SPM,  0x95e8},
  {"movw", "v,v", "00000001ddddrrrr", 1, AVR_ISA_MUL,  0x0100},
  {"muls", "d,d", "00000010ddddrrrr", 1, AVR_ISA_MUL,  0x0200},
  {"mulsu","a,a", "000000110ddd0rrr", 1, AVR_ISA_MUL,  0x0300},
  {"fmul", "a,a", "000000110ddd1rrr", 1, AVR_ISA_MUL,  0x0308},
  {"fmuls","a,a", "000000111ddd0rrr", 1, AVR_ISA_MUL,  0x0380},
  {"fmulsu","a,a","000000111ddd1rrr", 1, AVR_ISA_MUL,  0x0388},
  {"lpmx", "r,z", "1001000ddddd010+", 1, AVR_ISA_LPMX, 0x9004},
  /* these are for devices that don't exists yet */
  /* >64K program memory, new core */
  {"elpmx","r,z", "1001000ddddd011+", 1, AVR_ISA_ELPMX,0x9006},
  {"espm", "", 	  "1001010111111000", 1, AVR_ISA_ESPM, 0x95f8},
  /* >128K program memory (PC = EIND:Z) */
  {"eicall", "",  "1001010100011001", 1, AVR_ISA_EIND, 0x9519},
  {"eijmp", "",   "1001010000011001", 1, AVR_ISA_EIND, 0x9419},
  {NULL, NULL, NULL, 0, 0, 0}
};



d554 4
d690 2
d1015 1
a1015 1
     version with operands is listed in avr_opcodes[] with "x" suffix.  */
d1017 2
a1018 12
  if (*str && !(*opcode->constraints))
    {
      struct avr_opcodes_s *opc1;

      /* known opcode, so strlen(op) <= 6 and strcat() should be safe */
      strcat(op, "x");
      opc1 = (struct avr_opcodes_s *) hash_find (avr_hash, op);

      /* if unknown, just forget it and use the original opcode */
      if (opc1)
	opcode = opc1;
    }
@


1.2
log
@	* config/tc-avr.c: New AVR_ISA_ defined.
	(md_assemble): Handle opcodes with optional operands (lpm,elpm).
	(avr_operand): Handle 'a', 'v' and 'z' constraint letters needed
	for `fmul', `movw' and `lpm R,Z' instructions.
	(avr_operands): Warn if current opcode is a two-word instruction
	and previous opcode was cpse/sbic/sbis/sbrc/sbrs.
	(avr_opcodes): New commands added.
	(REGISTER_P): Check 'a' and 'v' constraint letters.
	(mcu_types): New MCU added.
@
text
@d133 1
a133 1
static unsigned int avr_get_constant (char * str, unsigned int max);
d374 2
a375 2
     fragS *fragp;
     asection *seg;
d399 1
a399 1
     int dummy;
d441 1
a441 1
     char *name;
d490 3
a492 3
  bfd *abfd;
  asection *sec;
  fragS *fragP;
d501 1
a501 1
  int i;
d516 4
d521 2
a522 6
  /* Construct symbols for each register */
  /* FIXME: register names are in the same namespace as labels.
     This means that C functions or global variables with the same
     name as a register will cause assembler errors, even though
     such names (r0-r31) are perfectly valid in C.  I'd suggest to
     put '%' or "." in front of register names both here and in avr-gcc.  */
d524 12
a535 3
  for (i = 0; i < 32; i++)
    {
      char buf[10];
d537 3
a539 9
      sprintf (buf, "r%d", i);
      symbol_table_insert (symbol_new (buf, reg_section, i,
				       &zero_address_frag));
      sprintf (buf, "R%d", i);
      symbol_table_insert (symbol_new (buf, reg_section, i,
				       &zero_address_frag));
    }
  
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, avr_mcu->mach);
d543 3
a630 17
static unsigned int
avr_get_constant (str, max)
     char * str;
     unsigned int max;
{
  expressionS ex;
  str = skip_space (str);
  input_line_pointer = str;
  expression (&ex);

  if (ex.X_op != O_constant)
    as_bad (_("constant value required"));

  if (ex.X_add_number > max)
    as_bad (_("number must be less than %d"), max+1);
  return ex.X_add_number;
}
d632 3
d642 1
d644 1
a644 2
  char *str = *line;
  expressionS op_expr;
a645 1
  str = skip_space (str);
a654 1
	char r_name[256];
d657 5
a661 3
	str = extract_word (str, r_name, sizeof (r_name));
	if (r_name[0] == 'r' || r_name[0] == 'R')
	  {
d674 2
a675 3
	    parse_exp (r_name, &op_expr);
	    if (op_expr.X_op == O_register)
	      op_mask = op_expr.X_add_number;
d678 1
a678 1
	if (op_mask <= 31 && op_mask >= 0)
d709 1
a709 1
	as_bad (_ ("register required"));
d1141 1
a1141 1
     asection *seg;
d1178 1
a1178 1
  str = extract_word (str, op, sizeof(op));
@


1.1
log
@ATMEL AVR microcontroller support.
@
text
@d32 22
a53 5
#define AVR_ISA_1200      1
#define AVR_ISA_2xxx      3
#define AVR_ISA_MEGA_x03  0x17
#define AVR_ISA_MEGA      0x10
#define AVR_ISA_MEGA_161  0x1b
d65 4
a68 4
  {"avr1",      AVR_ISA_1200,     bfd_mach_avr1},
  {"avr2",      AVR_ISA_2xxx,     bfd_mach_avr2},
  {"avr3",      AVR_ISA_MEGA_x03, bfd_mach_avr3},
  {"avr4",      AVR_ISA_MEGA_161, bfd_mach_avr4},
d70 5
d83 9
a91 5
  {"at90s8515", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"at90s8535", AVR_ISA_2xxx,     bfd_mach_avr2},
  {"atmega603", AVR_ISA_MEGA_x03, bfd_mach_avr3},
  {"atmega103", AVR_ISA_MEGA_x03, bfd_mach_avr3},
  {"atmega161", AVR_ISA_MEGA_161, bfd_mach_avr4},
d112 5
a116 1
#define REGISTER_P(x) ((x) == 'r' || (x) == 'd' || (x) == 'w')
d138 1
d142 6
a149 1
   w - `adiw' register (r24,r26,r28,r30)
a153 2
   e - pointer regegisters (X,Y,Z)
   b - base pointer register and displacement ([YZ]+disp)
d160 1
d171 1
a171 1
  {"mul",  "r,r", "100111rdddddrrrr", 1, AVR_ISA_MEGA_161, 0x9c00},
d268 1
a268 1
  {"lpm",  "", 	  "1001010111001000", 1, AVR_ISA_2xxx, 0x95c8},
d282 16
a297 1
  {"elpm", "", 	  "1001010111011000", 1, AVR_ISA_MEGA_x03, 0x95d8},
d440 2
a441 2
md_undefined_symbol (name)
  char *name;
d517 7
d526 1
a526 1
      char buf[5];
d535 1
a535 1

d550 1
d598 8
d608 7
d618 3
a620 3
    {
      bfd_putl16 ((bfd_vma)bin, frag);
    }
d661 2
d665 2
d668 20
a687 2
	parse_exp (r_name, &op_expr);
	if (op_expr.X_op == O_register)
d689 1
a689 2
	    op_mask = op_expr.X_add_number;
	    if (op_mask <= 31)
d691 23
a713 13
		if (*op == 'd')
		  {
		    if (op_mask < 16)
		      as_bad (_ ("register number above 15 required"));
		    op_mask -= 16;
		  }
		if (*op == 'w')
		  {
		    op_mask -= 24;
		    if (op_mask & 1 || op_mask > 6)
		      as_bad (_ ("register r24,r26,r28 or r30 required"));
		    op_mask >>= 1;
		  }
d716 1
d749 17
a1001 1
	  /* XXX AT90S8515 must have WRAP here.  */
d1005 1
a1005 1
	      if (avr_mcu->mach == bfd_mach_avr2)
d1200 16
d1224 1
a1224 1
    if (*str)
@

