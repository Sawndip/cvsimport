head	1.48;
access;
symbols
	binutils-2_24-branch:1.48.0.8
	binutils-2_24-branchpoint:1.48
	binutils-2_21_1:1.47.2.1
	binutils-2_23_2:1.48
	binutils-2_23_1:1.48
	binutils-2_23:1.48
	binutils-2_23-branch:1.48.0.6
	binutils-2_23-branchpoint:1.48
	binutils-2_22_branch:1.48.0.4
	binutils-2_22:1.48
	binutils-2_22-branch:1.48.0.2
	binutils-2_22-branchpoint:1.48
	binutils-2_21:1.47
	binutils-2_21-branch:1.47.0.2
	binutils-2_21-branchpoint:1.47
	binutils-2_20_1:1.45.2.1
	binutils-2_20:1.45.2.1
	binutils-arc-20081103-branch:1.43.0.6
	binutils-arc-20081103-branchpoint:1.43
	binutils-2_20-branch:1.45.0.2
	binutils-2_20-branchpoint:1.45
	dje-cgen-play1-branch:1.44.0.2
	dje-cgen-play1-branchpoint:1.44
	arc-20081103-branch:1.43.0.4
	arc-20081103-branchpoint:1.43
	binutils-2_19_1:1.43
	binutils-2_19:1.43
	binutils-2_19-branch:1.43.0.2
	binutils-2_19-branchpoint:1.43
	binutils-2_18:1.40
	binutils-2_18-branch:1.40.0.2
	binutils-2_18-branchpoint:1.40
	binutils-csl-coldfire-4_1-32:1.38
	binutils-csl-sourcerygxx-4_1-32:1.38
	binutils-csl-innovasic-fido-3_4_4-33:1.38
	binutils-csl-sourcerygxx-3_4_4-32:1.33
	binutils-csl-coldfire-4_1-30:1.38
	binutils-csl-sourcerygxx-4_1-30:1.38
	binutils-csl-coldfire-4_1-28:1.38
	binutils-csl-sourcerygxx-4_1-29:1.38
	binutils-csl-sourcerygxx-4_1-28:1.38
	binutils-csl-arm-2006q3-27:1.38
	binutils-csl-sourcerygxx-4_1-27:1.38
	binutils-csl-arm-2006q3-26:1.38
	binutils-csl-sourcerygxx-4_1-26:1.38
	binutils-csl-sourcerygxx-4_1-25:1.38
	binutils-csl-sourcerygxx-4_1-24:1.38
	binutils-csl-sourcerygxx-4_1-23:1.38
	binutils-csl-sourcerygxx-4_1-21:1.38
	binutils-csl-arm-2006q3-21:1.38
	binutils-csl-sourcerygxx-4_1-22:1.38
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.38
	binutils-csl-sourcerygxx-4_1-20:1.38
	binutils-csl-arm-2006q3-19:1.38
	binutils-csl-sourcerygxx-4_1-19:1.38
	binutils-csl-sourcerygxx-4_1-18:1.38
	binutils-csl-renesas-4_1-9:1.38
	binutils-csl-sourcerygxx-3_4_4-25:1.33
	binutils-csl-renesas-4_1-8:1.38
	binutils-csl-renesas-4_1-7:1.38
	binutils-csl-renesas-4_1-6:1.38
	binutils-csl-sourcerygxx-4_1-17:1.38
	binutils-csl-sourcerygxx-4_1-14:1.38
	binutils-csl-sourcerygxx-4_1-15:1.38
	binutils-csl-sourcerygxx-4_1-13:1.38
	binutils-2_17:1.38
	binutils-csl-sourcerygxx-4_1-12:1.38
	binutils-csl-sourcerygxx-3_4_4-21:1.38
	binutils-csl-wrs-linux-3_4_4-24:1.33
	binutils-csl-wrs-linux-3_4_4-23:1.33
	binutils-csl-sourcerygxx-4_1-9:1.38
	binutils-csl-sourcerygxx-4_1-8:1.38
	binutils-csl-sourcerygxx-4_1-7:1.38
	binutils-csl-arm-2006q1-6:1.38
	binutils-csl-sourcerygxx-4_1-6:1.38
	binutils-csl-wrs-linux-3_4_4-22:1.33
	binutils-csl-coldfire-4_1-11:1.38
	binutils-csl-sourcerygxx-3_4_4-19:1.38
	binutils-csl-coldfire-4_1-10:1.38
	binutils-csl-sourcerygxx-4_1-5:1.38
	binutils-csl-sourcerygxx-4_1-4:1.38
	binutils-csl-wrs-linux-3_4_4-21:1.33
	binutils-csl-morpho-4_1-4:1.38
	binutils-csl-sourcerygxx-3_4_4-17:1.38
	binutils-csl-wrs-linux-3_4_4-20:1.33
	binutils-2_17-branch:1.38.0.4
	binutils-2_17-branchpoint:1.38
	binutils-csl-2_17-branch:1.38.0.2
	binutils-csl-2_17-branchpoint:1.38
	binutils-csl-gxxpro-3_4-branch:1.33.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.33
	binutils-2_16_1:1.33
	binutils-csl-arm-2005q1b:1.33
	binutils-2_16:1.33
	binutils-csl-arm-2005q1a:1.33
	binutils-csl-arm-2005q1-branch:1.33.0.4
	binutils-csl-arm-2005q1-branchpoint:1.33
	binutils-2_16-branch:1.33.0.2
	binutils-2_16-branchpoint:1.33
	csl-arm-2004-q3d:1.28
	csl-arm-2004-q3:1.27
	binutils-2_15:1.25.6.1
	binutils-2_15-branchpoint:1.25
	csl-arm-2004-q1a:1.26
	csl-arm-2004-q1:1.26
	binutils-2_15-branch:1.25.0.6
	cagney_bfdfile-20040213-branch:1.25.0.4
	cagney_bfdfile-20040213-branchpoint:1.25
	cagney_bigcore-20040122-branch:1.25.0.2
	cagney_bigcore-20040122-branchpoint:1.25
	csl-arm-2003-q4:1.25
	binutils-2_14:1.21
	binutils-2_14-branch:1.21.0.2
	binutils-2_14-branchpoint:1.21
	binutils-2_13_2_1:1.19
	binutils-2_13_2:1.19
	binutils-2_13_1:1.19
	binutils-2_13:1.19
	binutils-2_13-branchpoint:1.19
	binutils-2_13-branch:1.19.0.4
	binutils-2_12_1:1.19
	binutils-2_12:1.19
	binutils-2_12-branch:1.19.0.2
	binutils-2_12-branchpoint:1.19
	cygnus_cvs_20020108_pre:1.19
	binutils-2_11_2:1.10.2.1
	binutils-2_11_1:1.10.2.1
	binutils-2_11:1.10
	x86_64versiong3:1.10
	binutils-2_11-branch:1.10.0.2
	binutils-2_10_1:1.4
	binutils-2_10:1.4
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.48
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.4
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2011.03.10.10.06.05;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2009.09.25.19.13.26;	author nickc;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2009.09.05.07.56.24;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2007.10.18.13.03.12;	author nickc;	state Exp;
branches
	1.43.6.1;
next	1.42;

1.42
date	2007.10.17.16.45.54;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.08.15.26.42;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.10.12.10.21;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.07.17.54.15;	author zack;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.05.09.12.54;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.24.20.40.25;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.03.05.30.10;	author ramana;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.01.15.05.25;	author ramana;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.23.12.28.03;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2005.02.17.13.46.03;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2005.01.31.23.18.25;	author bje;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.01.08.08.54;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.06.11.01.48;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.18.13.31.04;	author nathan;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches
	1.25.6.1;
next	1.24;

1.24
date	2003.11.21.00.24.40;	author kazu;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.20.01.36.49;	author kazu;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.05.00.01.16;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.15.21.28.54;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.17.05.51.12;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.24.14.47.10;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.05.33.21;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.23.14.02.12;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.22.11.03.35;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.16.01.08.20;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.12.15.14.52;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.15.01.37.20;	author kazu;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.01.14.20.36.41;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.11.21.20.17;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.08.00.06.34;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.15.01.06.52;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.14.52.51;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.22.14.35.14;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.22.14.07.31;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.47.2.1
date	2011.05.29.04.51.38;	author amodra;	state Exp;
branches;
next	;

1.45.2.1
date	2009.09.05.08.00.20;	author nickc;	state Exp;
branches;
next	;

1.43.6.1
date	2009.09.10.15.09.32;	author amylaar;	state Exp;
branches;
next	;

1.25.6.1
date	2004.04.09.18.28.11;	author drow;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.23.03.41.10;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.48
log
@	* gas/config/obj-elf.h (ELF_TARGET_SYMBOL_FIELDS,
	TARGET_SYMBOL_FIELDS): Don't define.
	* gas/config/tc-arc.c (arc_common): Use correct symbol "local" field.
@
text
@/* tc-arc.c -- Assembler for the ARC
   Copyright 1994, 1995, 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2009, 2011  Free Software Foundation, Inc.
   Contributed by Doug Evans (dje@@cygnus.com).

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "struc-symbol.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/arc.h"
#include "../opcodes/arc-ext.h"
#include "elf/arc.h"
#include "dwarf2dbg.h"

const struct suffix_classes
{
  char *name;
  int  len;
} suffixclass[] =
{
  { "SUFFIX_COND|SUFFIX_FLAG",23 },
  { "SUFFIX_FLAG", 11 },
  { "SUFFIX_COND", 11 },
  { "SUFFIX_NONE", 11 }
};

#define MAXSUFFIXCLASS (sizeof (suffixclass) / sizeof (struct suffix_classes))

const struct syntax_classes
{
  char *name;
  int  len;
  int  s_class;
} syntaxclass[] =
{
  { "SYNTAX_3OP|OP1_MUST_BE_IMM", 26, SYNTAX_3OP|OP1_MUST_BE_IMM|SYNTAX_VALID },
  { "OP1_MUST_BE_IMM|SYNTAX_3OP", 26, OP1_MUST_BE_IMM|SYNTAX_3OP|SYNTAX_VALID },
  { "SYNTAX_2OP|OP1_IMM_IMPLIED", 26, SYNTAX_2OP|OP1_IMM_IMPLIED|SYNTAX_VALID },
  { "OP1_IMM_IMPLIED|SYNTAX_2OP", 26, OP1_IMM_IMPLIED|SYNTAX_2OP|SYNTAX_VALID },
  { "SYNTAX_3OP",                 10, SYNTAX_3OP|SYNTAX_VALID },
  { "SYNTAX_2OP",                 10, SYNTAX_2OP|SYNTAX_VALID }
};

#define MAXSYNTAXCLASS (sizeof (syntaxclass) / sizeof (struct syntax_classes))

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "#;";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments started like this one will always
   work if '/' isn't otherwise defined.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = "";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
   As in 0f12.456 or 0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdD";

/* Byte order.  */
extern int target_big_endian;
const char *arc_target_format = DEFAULT_TARGET_FORMAT;
static int byte_order = DEFAULT_BYTE_ORDER;

static segT arcext_section;

/* One of bfd_mach_arc_n.  */
static int arc_mach_type = bfd_mach_arc_6;

/* Non-zero if the cpu type has been explicitly specified.  */
static int mach_type_specified_p = 0;

/* Non-zero if opcode tables have been initialized.
   A .option command must appear before any instructions.  */
static int cpu_tables_init_p = 0;

static struct hash_control *arc_suffix_hash = NULL;

const char *md_shortopts = "";

enum options
{
  OPTION_EB = OPTION_MD_BASE,
  OPTION_EL,
  OPTION_ARC5,
  OPTION_ARC6,
  OPTION_ARC7,
  OPTION_ARC8,
  OPTION_ARC
};

struct option md_longopts[] =
{
  { "EB", no_argument, NULL, OPTION_EB },
  { "EL", no_argument, NULL, OPTION_EL },
  { "marc5", no_argument, NULL, OPTION_ARC5 },
  { "pre-v6", no_argument, NULL, OPTION_ARC5 },
  { "marc6", no_argument, NULL, OPTION_ARC6 },
  { "marc7", no_argument, NULL, OPTION_ARC7 },
  { "marc8", no_argument, NULL, OPTION_ARC8 },
  { "marc", no_argument, NULL, OPTION_ARC },
  { NULL, no_argument, NULL, 0 }
};
size_t md_longopts_size = sizeof (md_longopts);

#define IS_SYMBOL_OPERAND(o) \
 ((o) == 'b' || (o) == 'c' || (o) == 's' || (o) == 'o' || (o) == 'O')

struct arc_operand_value *get_ext_suffix (char *s);

/* Invocation line includes a switch not recognized by the base assembler.
   See if it's a processor-specific option.  */

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    case OPTION_ARC5:
      arc_mach_type = bfd_mach_arc_5;
      break;
    case OPTION_ARC:
    case OPTION_ARC6:
      arc_mach_type = bfd_mach_arc_6;
      break;
    case OPTION_ARC7:
      arc_mach_type = bfd_mach_arc_7;
      break;
    case OPTION_ARC8:
      arc_mach_type = bfd_mach_arc_8;
      break;
    case OPTION_EB:
      byte_order = BIG_ENDIAN;
      arc_target_format = "elf32-bigarc";
      break;
    case OPTION_EL:
      byte_order = LITTLE_ENDIAN;
      arc_target_format = "elf32-littlearc";
      break;
    default:
      return 0;
    }
  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, "\
ARC Options:\n\
  -marc[5|6|7|8]          select processor variant (default arc%d)\n\
  -EB                     assemble code for a big endian cpu\n\
  -EL                     assemble code for a little endian cpu\n", arc_mach_type + 5);
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will need.
   Opcode selection is deferred until later because we might see a .option
   command.  */

void
md_begin (void)
{
  /* The endianness can be chosen "at the factory".  */
  target_big_endian = byte_order == BIG_ENDIAN;

  if (!bfd_set_arch_mach (stdoutput, bfd_arch_arc, arc_mach_type))
    as_warn (_("could not set architecture and machine"));

  /* This call is necessary because we need to initialize `arc_operand_map'
     which may be needed before we see the first insn.  */
  arc_opcode_init_tables (arc_get_opcode_mach (arc_mach_type,
					       target_big_endian));
}

/* Initialize the various opcode and operand tables.
   MACH is one of bfd_mach_arc_xxx.  */

static void
init_opcode_tables (int mach)
{
  int i;
  char *last;

  if ((arc_suffix_hash = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  if (!bfd_set_arch_mach (stdoutput, bfd_arch_arc, mach))
    as_warn (_("could not set architecture and machine"));

  /* This initializes a few things in arc-opc.c that we need.
     This must be called before the various arc_xxx_supported fns.  */
  arc_opcode_init_tables (arc_get_opcode_mach (mach, target_big_endian));

  /* Only put the first entry of each equivalently named suffix in the
     table.  */
  last = "";
  for (i = 0; i < arc_suffixes_count; i++)
    {
      if (strcmp (arc_suffixes[i].name, last) != 0)
	hash_insert (arc_suffix_hash, arc_suffixes[i].name, (void *) (arc_suffixes + i));
      last = arc_suffixes[i].name;
    }

  /* Since registers don't have a prefix, we put them in the symbol table so
     they can't be used as symbols.  This also simplifies argument parsing as
     we can let gas parse registers for us.  The recorded register number is
     the address of the register's entry in arc_reg_names.

     If the register name is already in the table, then the existing
     definition is assumed to be from an .ExtCoreRegister pseudo-op.  */

  for (i = 0; i < arc_reg_names_count; i++)
    {
      if (symbol_find (arc_reg_names[i].name))
	continue;
      /* Use symbol_create here instead of symbol_new so we don't try to
	 output registers into the object file's symbol table.  */
      symbol_table_insert (symbol_create (arc_reg_names[i].name,
					  reg_section,
					  (valueT) &arc_reg_names[i],
					  &zero_address_frag));
    }

  /* Tell `.option' it's too late.  */
  cpu_tables_init_p = 1;
}

/* Insert an operand value into an instruction.
   If REG is non-NULL, it is a register number and ignore VAL.  */

static arc_insn
arc_insert_operand (arc_insn insn,
		    const struct arc_operand *operand,
		    int mods,
		    const struct arc_operand_value *reg,
		    offsetT val,
		    char *file,
		    unsigned int line)
{
  if (operand->bits != 32)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & ARC_OPERAND_SIGNED) != 0)
	{
	  if ((operand->flags & ARC_OPERAND_SIGNOPT) != 0)
	    max = (1 << operand->bits) - 1;
	  else
	    max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      if ((operand->flags & ARC_OPERAND_NEGATIVE) != 0)
	test = - val;
      else
	test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	as_warn_value_out_of_range (_("operand"), test, (offsetT) min, (offsetT) max, file, line);
    }

  if (operand->insert)
    {
      const char *errmsg;

      errmsg = NULL;
      insn = (*operand->insert) (insn, operand, mods, reg, (long) val, &errmsg);
      if (errmsg != (const char *) NULL)
	as_warn ("%s", errmsg);
    }
  else
    insn |= (((long) val & ((1 << operand->bits) - 1))
	     << operand->shift);

  return insn;
}

/* We need to keep a list of fixups.  We can't simply generate them as
   we go, because that would require us to first create the frag, and
   that would screw up references to ``.''.  */

struct arc_fixup
{
  /* index into `arc_operands'  */
  int opindex;
  expressionS exp;
};

#define MAX_FIXUPS 5

#define MAX_SUFFIXES 5

/* Compute the reloc type of an expression.
   The possibly modified expression is stored in EXPNEW.

   This is used to convert the expressions generated by the %-op's into
   the appropriate operand type.  It is called for both data in instructions
   (operands) and data outside instructions (variables, debugging info, etc.).

   Currently supported %-ops:

   %st(symbol): represented as "symbol >> 2"
                "st" is short for STatus as in the status register (pc)

   DEFAULT_TYPE is the type to use if no special processing is required.

   DATA_P is non-zero for data or limm values, zero for insn operands.
   Remember that the opcode "insertion fns" cannot be used on data, they're
   only for inserting operands into insns.  They also can't be used for limm
   values as the insertion routines don't handle limm values.  When called for
   insns we return fudged reloc types (real_value - BFD_RELOC_UNUSED).  When
   called for data or limm values we use real reloc types.  */

static int
get_arc_exp_reloc_type (int data_p,
			int default_type,
			expressionS *exp,
			expressionS *expnew)
{
  /* If the expression is "symbol >> 2" we must change it to just "symbol",
     as fix_new_exp can't handle it.  Similarly for (symbol - symbol) >> 2.
     That's ok though.  What's really going on here is that we're using
     ">> 2" as a special syntax for specifying BFD_RELOC_ARC_B26.  */

  if (exp->X_op == O_right_shift
      && exp->X_op_symbol != NULL
      && exp->X_op_symbol->sy_value.X_op == O_constant
      && exp->X_op_symbol->sy_value.X_add_number == 2
      && exp->X_add_number == 0)
    {
      if (exp->X_add_symbol != NULL
	  && (exp->X_add_symbol->sy_value.X_op == O_constant
	      || exp->X_add_symbol->sy_value.X_op == O_symbol))
	{
	  *expnew = *exp;
	  expnew->X_op = O_symbol;
	  expnew->X_op_symbol = NULL;
	  return data_p ? BFD_RELOC_ARC_B26 : arc_operand_map['J'];
	}
      else if (exp->X_add_symbol != NULL
	       && exp->X_add_symbol->sy_value.X_op == O_subtract)
	{
	  *expnew = exp->X_add_symbol->sy_value;
	  return data_p ? BFD_RELOC_ARC_B26 : arc_operand_map['J'];
	}
    }

  *expnew = *exp;
  return default_type;
}

static int
arc_set_ext_seg (void)
{
  if (!arcext_section)
    {
      arcext_section = subseg_new (".arcextmap", 0);
      bfd_set_section_flags (stdoutput, arcext_section,
			     SEC_READONLY | SEC_HAS_CONTENTS);
    }
  else
    subseg_set (arcext_section, 0);
  return 1;
}

static void
arc_extoper (int opertype)
{
  char *name;
  char *mode;
  char c;
  char *p;
  int imode = 0;
  int number;
  struct arc_ext_operand_value *ext_oper;
  symbolS *symbolP;

  segT old_sec;
  int old_subsec;

  name = input_line_pointer;
  c = get_symbol_end ();
  name = xstrdup (name);

  p = name;
  while (*p)
    {
      *p = TOLOWER (*p);
      p++;
    }

  /* just after name is now '\0'  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after operand name"));
      ignore_rest_of_line ();
      free (name);
      return;
    }

  input_line_pointer++;		/* skip ','  */
  number = get_absolute_expression ();

  if (number < 0)
    {
      as_bad (_("negative operand number %d"), number);
      ignore_rest_of_line ();
      free (name);
      return;
    }

  if (opertype)
    {
      SKIP_WHITESPACE ();

      if (*input_line_pointer != ',')
	{
	  as_bad (_("expected comma after register-number"));
	  ignore_rest_of_line ();
	  free (name);
	  return;
	}

      input_line_pointer++;		/* skip ','  */
      mode = input_line_pointer;

      if (!strncmp (mode, "r|w", 3))
	{
	  imode = 0;
	  input_line_pointer += 3;
	}
      else
	{
	  if (!strncmp (mode, "r", 1))
	    {
	      imode = ARC_REGISTER_READONLY;
	      input_line_pointer += 1;
	    }
	  else
	    {
	      if (strncmp (mode, "w", 1))
		{
		  as_bad (_("invalid mode"));
		  ignore_rest_of_line ();
		  free (name);
		  return;
		}
	      else
		{
		  imode = ARC_REGISTER_WRITEONLY;
		  input_line_pointer += 1;
		}
	    }
	}
      SKIP_WHITESPACE ();
      if (1 == opertype)
	{
	  if (*input_line_pointer != ',')
	    {
	      as_bad (_("expected comma after register-mode"));
	      ignore_rest_of_line ();
	      free (name);
	      return;
	    }

	  input_line_pointer++;		/* skip ','  */

	  if (!strncmp (input_line_pointer, "cannot_shortcut", 15))
	    {
	      imode |= arc_get_noshortcut_flag ();
	      input_line_pointer += 15;
	    }
	  else
	    {
	      if (strncmp (input_line_pointer, "can_shortcut", 12))
		{
		  as_bad (_("shortcut designator invalid"));
		  ignore_rest_of_line ();
		  free (name);
		  return;
		}
	      else
		{
		  input_line_pointer += 12;
		}
	    }
	}
    }

  if ((opertype == 1) && number > 60)
    {
      as_bad (_("core register value (%d) too large"), number);
      ignore_rest_of_line ();
      free (name);
      return;
    }

  if ((opertype == 0) && number > 31)
    {
      as_bad (_("condition code value (%d) too large"), number);
      ignore_rest_of_line ();
      free (name);
      return;
    }

  ext_oper = (struct arc_ext_operand_value *)
      xmalloc (sizeof (struct arc_ext_operand_value));

  if (opertype)
    {
      /* If the symbol already exists, point it at the new definition.  */
      if ((symbolP = symbol_find (name)))
	{
	  if (S_GET_SEGMENT (symbolP) == reg_section)
	    S_SET_VALUE (symbolP, (valueT) &ext_oper->operand);
	  else
	    {
	      as_bad (_("attempt to override symbol: %s"), name);
	      ignore_rest_of_line ();
	      free (name);
	      free (ext_oper);
	      return;
	    }
	}
      else
	{
	  /* If its not there, add it.  */
	  symbol_table_insert (symbol_create (name, reg_section,
					      (valueT) &ext_oper->operand,
					      &zero_address_frag));
	}
    }

  ext_oper->operand.name  = name;
  ext_oper->operand.value = number;
  ext_oper->operand.type  = arc_operand_type (opertype);
  ext_oper->operand.flags = imode;

  ext_oper->next = arc_ext_operands;
  arc_ext_operands = ext_oper;

  /* OK, now that we know what this operand is, put a description in
     the arc extension section of the output file.  */

  old_sec    = now_seg;
  old_subsec = now_subseg;

  arc_set_ext_seg ();

  switch (opertype)
    {
    case 0:
      p = frag_more (1);
      *p = 3 + strlen (name) + 1;
      p = frag_more (1);
      *p = EXT_COND_CODE;
      p = frag_more (1);
      *p = number;
      p = frag_more (strlen (name) + 1);
      strcpy (p, name);
      break;
    case 1:
      p = frag_more (1);
      *p = 3 + strlen (name) + 1;
      p = frag_more (1);
      *p = EXT_CORE_REGISTER;
      p = frag_more (1);
      *p = number;
      p = frag_more (strlen (name) + 1);
      strcpy (p, name);
      break;
    case 2:
      p = frag_more (1);
      *p = 6 + strlen (name) + 1;
      p = frag_more (1);
      *p = EXT_AUX_REGISTER;
      p = frag_more (1);
      *p = number >> 24 & 0xff;
      p = frag_more (1);
      *p = number >> 16 & 0xff;
      p = frag_more (1);
      *p = number >>  8 & 0xff;
      p = frag_more (1);
      *p = number       & 0xff;
      p = frag_more (strlen (name) + 1);
      strcpy (p, name);
      break;
    default:
      as_bad (_("invalid opertype"));
      ignore_rest_of_line ();
      free (name);
      return;
      break;
    }

  subseg_set (old_sec, old_subsec);

  /* Enter all registers into the symbol table.  */

  demand_empty_rest_of_line ();
}

static void
arc_extinst (int ignore ATTRIBUTE_UNUSED)
{
  char syntax[129];
  char *name;
  char *p;
  char c;
  int suffixcode = -1;
  int opcode, subopcode;
  int i;
  int s_class = 0;
  int name_len;
  struct arc_opcode *ext_op;

  segT old_sec;
  int old_subsec;

  name = input_line_pointer;
  c = get_symbol_end ();
  name = xstrdup (name);
  strcpy (syntax, name);
  name_len = strlen (name);

  /* just after name is now '\0'  */
  p = input_line_pointer;
  *p = c;

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after operand name"));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','  */
  opcode = get_absolute_expression ();

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after opcode"));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','  */
  subopcode = get_absolute_expression ();

  if (subopcode < 0)
    {
      as_bad (_("negative subopcode %d"), subopcode);
      ignore_rest_of_line ();
      return;
    }

  if (subopcode)
    {
      if (3 != opcode)
	{
	  as_bad (_("subcode value found when opcode not equal 0x03"));
	  ignore_rest_of_line ();
	  return;
	}
      else
	{
	  if (subopcode < 0x09 || subopcode == 0x3f)
	    {
	      as_bad (_("invalid subopcode %d"), subopcode);
	      ignore_rest_of_line ();
	      return;
	    }
	}
    }

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after subopcode"));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','  */

  for (i = 0; i < (int) MAXSUFFIXCLASS; i++)
    {
      if (!strncmp (suffixclass[i].name,input_line_pointer, suffixclass[i].len))
	{
	  suffixcode = i;
	  input_line_pointer += suffixclass[i].len;
	  break;
	}
    }

  if (-1 == suffixcode)
    {
      as_bad (_("invalid suffix class"));
      ignore_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after suffix class"));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','  */

  for (i = 0; i < (int) MAXSYNTAXCLASS; i++)
    {
      if (!strncmp (syntaxclass[i].name,input_line_pointer, syntaxclass[i].len))
	{
	  s_class = syntaxclass[i].s_class;
	  input_line_pointer += syntaxclass[i].len;
	  break;
	}
    }

  if (0 == (SYNTAX_VALID & s_class))
    {
      as_bad (_("invalid syntax class"));
      ignore_rest_of_line ();
      return;
    }

  if ((0x3 == opcode) & (s_class & SYNTAX_3OP))
    {
      as_bad (_("opcode 0x3 and SYNTAX_3OP invalid"));
      ignore_rest_of_line ();
      return;
    }

  switch (suffixcode)
    {
    case 0:
      strcat (syntax, "%.q%.f ");
      break;
    case 1:
      strcat (syntax, "%.f ");
      break;
    case 2:
      strcat (syntax, "%.q ");
      break;
    case 3:
      strcat (syntax, " ");
      break;
    default:
      as_bad (_("unknown suffix class"));
      ignore_rest_of_line ();
      return;
      break;
    };

  strcat (syntax, ((opcode == 0x3) ? "%a,%b" : ((s_class & SYNTAX_3OP) ? "%a,%b,%c" : "%b,%c")));
  if (suffixcode < 2)
    strcat (syntax, "%F");
  strcat (syntax, "%S%L");

  ext_op = (struct arc_opcode *) xmalloc (sizeof (struct arc_opcode));
  ext_op->syntax = xstrdup (syntax);

  ext_op->mask  = I (-1) | ((0x3 == opcode) ? C (-1) : 0);
  ext_op->value = I (opcode) | ((0x3 == opcode) ? C (subopcode) : 0);
  ext_op->flags = s_class;
  ext_op->next_asm = arc_ext_opcodes;
  ext_op->next_dis = arc_ext_opcodes;
  arc_ext_opcodes = ext_op;

  /* OK, now that we know what this inst is, put a description in the
     arc extension section of the output file.  */

  old_sec    = now_seg;
  old_subsec = now_subseg;

  arc_set_ext_seg ();

  p = frag_more (1);
  *p = 5 + name_len + 1;
  p = frag_more (1);
  *p = EXT_INSTRUCTION;
  p = frag_more (1);
  *p = opcode;
  p = frag_more (1);
  *p = subopcode;
  p = frag_more (1);
  *p = (s_class & (OP1_MUST_BE_IMM | OP1_IMM_IMPLIED) ? IGNORE_FIRST_OPD : 0);
  p = frag_more (name_len);
  strncpy (p, syntax, name_len);
  p = frag_more (1);
  *p = '\0';

  subseg_set (old_sec, old_subsec);

  demand_empty_rest_of_line ();
}

static void
arc_common (int localScope)
{
  char *name;
  char c;
  char *p;
  int align, size;
  symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();
  /* just after name is now '\0'  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after symbol name"));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','  */
  size = get_absolute_expression ();

  if (size < 0)
    {
      as_bad (_("negative symbol length"));
      ignore_rest_of_line ();
      return;
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }
  if (((int) S_GET_VALUE (symbolP) != 0) \
      && ((int) S_GET_VALUE (symbolP) != size))
    {
      as_warn (_("length of symbol \"%s\" already %ld, ignoring %d"),
	       S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
    }
  gas_assert (symbolP->sy_frag == &zero_address_frag);

  /* Now parse the alignment field.  This field is optional for
     local and global symbols. Default alignment is zero.  */
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      align = get_absolute_expression ();
      if (align < 0)
	{
	  align = 0;
	  as_warn (_("assuming symbol alignment of zero"));
	}
    }
  else
    align = 0;

  if (localScope != 0)
    {
      segT old_sec;
      int old_subsec;
      char *pfrag;

      old_sec    = now_seg;
      old_subsec = now_subseg;
      record_alignment (bss_section, align);
      subseg_set (bss_section, 0);  /* ??? subseg_set (bss_section, 1); ???  */

      if (align)
	/* Do alignment.  */
	frag_align (align, 0, 0);

      /* Detach from old frag.  */
      if (S_GET_SEGMENT (symbolP) == bss_section)
	symbolP->sy_frag->fr_symbol = NULL;

      symbolP->sy_frag = frag_now;
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			(offsetT) size, (char *) 0);
      *pfrag = 0;

      S_SET_SIZE       (symbolP, size);
      S_SET_SEGMENT    (symbolP, bss_section);
      S_CLEAR_EXTERNAL (symbolP);
      symbol_get_obj (symbolP)->local = 1;
      subseg_set (old_sec, old_subsec);
    }
  else
    {
      S_SET_VALUE    (symbolP, (valueT) size);
      S_SET_ALIGN    (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT  (symbolP, bfd_com_section_ptr);
    }

  symbolP->bsym->flags |= BSF_OBJECT;

  demand_empty_rest_of_line ();
}

/* Select the cpu we're assembling for.  */

static void
arc_option (int ignore ATTRIBUTE_UNUSED)
{
  extern int arc_get_mach (char *);
  int mach;
  char c;
  char *cpu;

  cpu = input_line_pointer;
  c = get_symbol_end ();
  mach = arc_get_mach (cpu);
  *input_line_pointer = c;

  /* If an instruction has already been seen, it's too late.  */
  if (cpu_tables_init_p)
    {
      as_bad (_("\".option\" directive must appear before any instructions"));
      ignore_rest_of_line ();
      return;
    }

  if (mach == -1)
    goto bad_cpu;

  if (mach_type_specified_p && mach != arc_mach_type)
    {
      as_bad (_("\".option\" directive conflicts with initial definition"));
      ignore_rest_of_line ();
      return;
    }
  else
    {
      /* The cpu may have been selected on the command line.  */
      if (mach != arc_mach_type)
	as_warn (_("\".option\" directive overrides command-line (default) value"));
      arc_mach_type = mach;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_arc, mach))
	as_fatal (_("could not set architecture and machine"));
      mach_type_specified_p = 1;
    }
  demand_empty_rest_of_line ();
  return;

 bad_cpu:
  as_bad (_("invalid identifier for \".option\""));
  ignore_rest_of_line ();
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

/* Write a value out to the object file, using the appropriate
   endianness.  */

void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);

  return ((size + (1 << align) - 1) & (-1 << align));
}

/* We don't have any form of relaxing.  */

int
md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
			       asection *seg ATTRIBUTE_UNUSED)
{
  as_fatal (_("relaxation not supported\n"));
  return 1;
}

/* Convert a machine dependent frag.  We never generate these.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec ATTRIBUTE_UNUSED,
		 fragS *fragp ATTRIBUTE_UNUSED)
{
  abort ();
}

static void
arc_code_symbol (expressionS *expressionP)
{
  if (expressionP->X_op == O_symbol && expressionP->X_add_number == 0)
    {
      expressionS two;

      expressionP->X_op = O_right_shift;
      expressionP->X_add_symbol->sy_value.X_op = O_constant;
      two.X_op = O_constant;
      two.X_add_symbol = two.X_op_symbol = NULL;
      two.X_add_number = 2;
      expressionP->X_op_symbol = make_expr_symbol (&two);
    }
  /* Allow %st(sym1-sym2)  */
  else if (expressionP->X_op == O_subtract
	   && expressionP->X_add_symbol != NULL
	   && expressionP->X_op_symbol != NULL
	   && expressionP->X_add_number == 0)
    {
      expressionS two;

      expressionP->X_add_symbol = make_expr_symbol (expressionP);
      expressionP->X_op = O_right_shift;
      two.X_op = O_constant;
      two.X_add_symbol = two.X_op_symbol = NULL;
      two.X_add_number = 2;
      expressionP->X_op_symbol = make_expr_symbol (&two);
    }
  else
    as_bad (_("expression too complex code symbol"));
}

/* Parse an operand that is machine-specific.

   The ARC has a special %-op to adjust addresses so they're usable in
   branches.  The "st" is short for the STatus register.
   ??? Later expand this to take a flags value too.

   ??? We can't create new expression types so we map the %-op's onto the
   existing syntax.  This means that the user could use the chosen syntax
   to achieve the same effect.  */

void
md_operand (expressionS *expressionP)
{
  char *p = input_line_pointer;

  if (*p != '%')
    return;

  if (strncmp (p, "%st(", 4) == 0)
    {
      input_line_pointer += 4;
      expression (expressionP);
      if (*input_line_pointer != ')')
	{
	  as_bad (_("missing ')' in %%-op"));
	  return;
	}
      ++input_line_pointer;
      arc_code_symbol (expressionP);
    }
  else
    {
      /* It could be a register.  */
      int i, l;
      struct arc_ext_operand_value *ext_oper = arc_ext_operands;
      p++;

      while (ext_oper)
	{
	  l = strlen (ext_oper->operand.name);
	  if (!strncmp (p, ext_oper->operand.name, l) && !ISALNUM (*(p + l)))
	    {
	      input_line_pointer += l + 1;
	      expressionP->X_op = O_register;
	      expressionP->X_add_number = (offsetT) &ext_oper->operand;
	      return;
	    }
	  ext_oper = ext_oper->next;
	}
      for (i = 0; i < arc_reg_names_count; i++)
	{
	  l = strlen (arc_reg_names[i].name);
	  if (!strncmp (p, arc_reg_names[i].name, l) && !ISALNUM (*(p + l)))
	    {
	      input_line_pointer += l + 1;
	      expressionP->X_op = O_register;
	      expressionP->X_add_number = (offsetT) &arc_reg_names[i];
	      break;
	    }
	}
    }
}

/* We have no need to default values of symbols.
   We could catch register names here, but that is handled by inserting
   them all in the symbol table to begin with.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Functions concerning expressions.  */

/* Parse a .byte, .word, etc. expression.

   Values for the status register are specified with %st(label).
   `label' will be right shifted by 2.  */

void
arc_parse_cons_expression (expressionS *exp,
			   unsigned int nbytes ATTRIBUTE_UNUSED)
{
  char *p = input_line_pointer;
  int code_symbol_fix = 0;

  for (; ! is_end_of_line[(unsigned char) *p]; p++)
    if (*p == '@@' && !strncmp (p, "@@h30", 4))
      {
	code_symbol_fix = 1;
	strcpy (p, ";   ");
      }
  expression_and_evaluate (exp);
  if (code_symbol_fix)
    {
      arc_code_symbol (exp);
      input_line_pointer = p;
    }
}

/* Record a fixup for a cons expression.  */

void
arc_cons_fix_new (fragS *frag,
		  int where,
		  int nbytes,
		  expressionS *exp)
{
  if (nbytes == 4)
    {
      int reloc_type;
      expressionS exptmp;

      /* This may be a special ARC reloc (eg: %st()).  */
      reloc_type = get_arc_exp_reloc_type (1, BFD_RELOC_32, exp, &exptmp);
      fix_new_exp (frag, where, nbytes, &exptmp, 0,
                   (enum bfd_reloc_code_real) reloc_type);
    }
  else
    {
      fix_new_exp (frag, where, nbytes, exp, 0,
		   nbytes == 2 ? BFD_RELOC_16
		   : nbytes == 8 ? BFD_RELOC_64
		   : BFD_RELOC_32);
    }
}

/* Functions concerning relocs.  */

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from (fixS *fixP)
{
  /* Return the address of the delay slot.  */
  return fixP->fx_frag->fr_address + fixP->fx_where + fixP->fx_size;
}

/* Apply a fixup to the object code.  This is called for all the
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the fixup.  */

void
md_apply_fix (fixS *fixP, valueT * valP, segT seg)
{
  valueT value = * valP;

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  else if (fixP->fx_pcrel)
    {
      /* Hack around bfd_install_relocation brain damage.  */
      if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
    }

  /* We can't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex;
      const struct arc_operand *operand;
      char *where;
      arc_insn insn;

      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;

      operand = &arc_operands[opindex];

      /* Fetch the instruction, insert the fully resolved operand
	 value, and stuff the instruction back again.  */
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
      if (target_big_endian)
	insn = bfd_getb32 ((unsigned char *) where);
      else
	insn = bfd_getl32 ((unsigned char *) where);
      insn = arc_insert_operand (insn, operand, -1, NULL, (offsetT) value,
				 fixP->fx_file, fixP->fx_line);
      if (target_big_endian)
	bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      else
	bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);

      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;

      /* Determine a BFD reloc value based on the operand information.
	 We are only prepared to turn a few of the operands into relocs.
	 !!! Note that we can't handle limm values here.  Since we're using
	 implicit addends the addend must be inserted into the instruction,
	 however, the opcode insertion routines currently do nothing with
	 limm values.  */
      if (operand->fmt == 'B')
	{
	  gas_assert ((operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0
		  && operand->bits == 20
		  && operand->shift == 7);
	  fixP->fx_r_type = BFD_RELOC_ARC_B22_PCREL;
	}
      else if (operand->fmt == 'J')
	{
	  gas_assert ((operand->flags & ARC_OPERAND_ABSOLUTE_BRANCH) != 0
		  && operand->bits == 24
		  && operand->shift == 32);
	  fixP->fx_r_type = BFD_RELOC_ARC_B26;
	}
      else if (operand->fmt == 'L')
	{
	  gas_assert ((operand->flags & ARC_OPERAND_LIMM) != 0
		  && operand->bits == 32
		  && operand->shift == 32);
	  fixP->fx_r_type = BFD_RELOC_32;
	}
      else
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("unresolved expression that must be resolved"));
	  fixP->fx_done = 1;
	  return;
	}
    }
  else
    {
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_8:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 1);
	  break;
	case BFD_RELOC_16:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 2);
	  break;
	case BFD_RELOC_32:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 4);
	  break;
	case BFD_RELOC_ARC_B26:
	  /* If !fixP->fx_done then `value' is an implicit addend.
	     We must shift it right by 2 in this case as well because the
	     linker performs the relocation and then adds this in (as opposed
	     to adding this in and then shifting right by 2).  */
	  value >>= 2;
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 4);
	  break;
	default:
	  abort ();
	}
    }
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,
	      fixS *fixP)
{
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));

  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("internal error: can't export reloc type %d (`%s')"),
		    fixP->fx_r_type,
		    bfd_get_reloc_code_name (fixP->fx_r_type));
      return NULL;
    }

  gas_assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);

  /* Set addend to account for PC being advanced one insn before the
     target address is computed.  */

  reloc->addend = (fixP->fx_pcrel ? -4 : 0);

  return reloc;
}

const pseudo_typeS md_pseudo_table[] =
{
  { "align", s_align_bytes, 0 }, /* Defaulting is invalid (0).  */
  { "comm", arc_common, 0 },
  { "common", arc_common, 0 },
  { "lcomm", arc_common, 1 },
  { "lcommon", arc_common, 1 },
  { "2byte", cons, 2 },
  { "half", cons, 2 },
  { "short", cons, 2 },
  { "3byte", cons, 3 },
  { "4byte", cons, 4 },
  { "word", cons, 4 },
  { "option", arc_option, 0 },
  { "cpu", arc_option, 0 },
  { "block", s_space, 0 },
  { "extcondcode", arc_extoper, 0 },
  { "extcoreregister", arc_extoper, 1 },
  { "extauxregister", arc_extoper, 2 },
  { "extinstruction", arc_extinst, 0 },
  { NULL, 0, 0 },
};

/* This routine is called for each instruction to be assembled.  */

void
md_assemble (char *str)
{
  const struct arc_opcode *opcode;
  const struct arc_opcode *std_opcode;
  struct arc_opcode *ext_opcode;
  char *start;
  const char *last_errmsg = 0;
  arc_insn insn;
  static int init_tables_p = 0;

  /* Opcode table initialization is deferred until here because we have to
     wait for a possible .option command.  */
  if (!init_tables_p)
    {
      init_opcode_tables (arc_mach_type);
      init_tables_p = 1;
    }

  /* Skip leading white space.  */
  while (ISSPACE (*str))
    str++;

  /* The instructions are stored in lists hashed by the first letter (though
     we needn't care how they're hashed).  Get the first in the list.  */

  ext_opcode = arc_ext_opcodes;
  std_opcode = arc_opcode_lookup_asm (str);

  /* Keep looking until we find a match.  */
  start = str;
  for (opcode = (ext_opcode ? ext_opcode : std_opcode);
       opcode != NULL;
       opcode = (ARC_OPCODE_NEXT_ASM (opcode)
		 ? ARC_OPCODE_NEXT_ASM (opcode)
		 : (ext_opcode ? ext_opcode = NULL, std_opcode : NULL)))
    {
      int past_opcode_p, fc, num_suffixes;
      int fix_up_at = 0;
      char *syn;
      struct arc_fixup fixups[MAX_FIXUPS];
      /* Used as a sanity check.  If we need a limm reloc, make sure we ask
	 for an extra 4 bytes from frag_more.  */
      int limm_reloc_p;
      int ext_suffix_p;
      const struct arc_operand_value *insn_suffixes[MAX_SUFFIXES];

      /* Is this opcode supported by the selected cpu?  */
      if (! arc_opcode_supported (opcode))
	continue;

      /* Scan the syntax string.  If it doesn't match, try the next one.  */
      arc_opcode_init_insert ();
      insn = opcode->value;
      fc = 0;
      past_opcode_p = 0;
      num_suffixes = 0;
      limm_reloc_p = 0;
      ext_suffix_p = 0;

      /* We don't check for (*str != '\0') here because we want to parse
	 any trailing fake arguments in the syntax string.  */
      for (str = start, syn = opcode->syntax; *syn != '\0';)
	{
	  int mods;
	  const struct arc_operand *operand;

	  /* Non operand chars must match exactly.  */
	  if (*syn != '%' || *++syn == '%')
	    {
	     if (*str == *syn)
		{
		  if (*syn == ' ')
		    past_opcode_p = 1;
		  ++syn;
		  ++str;
		}
	      else
		break;
	      continue;
	    }

	  /* We have an operand.  Pick out any modifiers.  */
	  mods = 0;
	  while (ARC_MOD_P (arc_operands[arc_operand_map[(int) *syn]].flags))
	    {
	      mods |= arc_operands[arc_operand_map[(int) *syn]].flags & ARC_MOD_BITS;
	      ++syn;
	    }
	  operand = arc_operands + arc_operand_map[(int) *syn];
	  if (operand->fmt == 0)
	    as_fatal (_("unknown syntax format character `%c'"), *syn);

	  if (operand->flags & ARC_OPERAND_FAKE)
	    {
	      const char *errmsg = NULL;
	      if (operand->insert)
		{
		  insn = (*operand->insert) (insn, operand, mods, NULL, 0, &errmsg);
		  if (errmsg != (const char *) NULL)
		    {
		      last_errmsg = errmsg;
		      if (operand->flags & ARC_OPERAND_ERROR)
			{
			  as_bad ("%s", errmsg);
			  return;
			}
		      else if (operand->flags & ARC_OPERAND_WARN)
			as_warn ("%s", errmsg);
		      break;
		    }
		  if (limm_reloc_p
		      && (operand->flags && operand->flags & ARC_OPERAND_LIMM)
		      && (operand->flags &
			  (ARC_OPERAND_ABSOLUTE_BRANCH | ARC_OPERAND_ADDRESS)))
		    {
		      fixups[fix_up_at].opindex = arc_operand_map[operand->fmt];
		    }
		}
	      ++syn;
	    }
	  /* Are we finished with suffixes?  */
	  else if (!past_opcode_p)
	    {
	      int found;
	      char c;
	      char *s, *t;
	      const struct arc_operand_value *suf, *suffix_end;
	      const struct arc_operand_value *suffix = NULL;

	      if (!(operand->flags & ARC_OPERAND_SUFFIX))
		abort ();

	      /* If we're at a space in the input string, we want to skip the
		 remaining suffixes.  There may be some fake ones though, so
		 just go on to try the next one.  */
	      if (*str == ' ')
		{
		  ++syn;
		  continue;
		}

	      s = str;
	      if (mods & ARC_MOD_DOT)
		{
		  if (*s != '.')
		    break;
		  ++s;
		}
	      else
		{
		  /* This can happen in "b.nd foo" and we're currently looking
		     for "%q" (ie: a condition code suffix).  */
		  if (*s == '.')
		    {
		      ++syn;
		      continue;
		    }
		}

	      /* Pick the suffix out and look it up via the hash table.  */
	      for (t = s; *t && ISALNUM (*t); ++t)
		continue;
	      c = *t;
	      *t = '\0';
	      if ((suf = get_ext_suffix (s)))
		ext_suffix_p = 1;
	      else
		suf = (const struct arc_operand_value *)
                    hash_find (arc_suffix_hash, s);
	      if (!suf)
		{
		  /* This can happen in "blle foo" and we're currently using
		     the template "b%q%.n %j".  The "bl" insn occurs later in
		     the table so "lle" isn't an illegal suffix.  */
		  *t = c;
		  break;
		}

	      /* Is it the right type?  Note that the same character is used
		 several times, so we have to examine all of them.  This is
		 relatively efficient as equivalent entries are kept
		 together.  If it's not the right type, don't increment `str'
		 so we try the next one in the series.  */
	      found = 0;
	      if (ext_suffix_p && arc_operands[suf->type].fmt == *syn)
		{
		  /* Insert the suffix's value into the insn.  */
		  *t = c;
		  if (operand->insert)
		    insn = (*operand->insert) (insn, operand,
					       mods, NULL, suf->value,
					       NULL);
		  else
		    insn |= suf->value << operand->shift;
		  suffix = suf;
		  str = t;
		  found = 1;
		}
	      else
		{
		  *t = c;
		  suffix_end = arc_suffixes + arc_suffixes_count;
		  for (suffix = suf;
		       suffix < suffix_end && strcmp (suffix->name, suf->name) == 0;
		       ++suffix)
		    {
		      if (arc_operands[suffix->type].fmt == *syn)
			{
			  /* Insert the suffix's value into the insn.  */
			  if (operand->insert)
			    insn = (*operand->insert) (insn, operand,
						       mods, NULL, suffix->value,
						       NULL);
			  else
			    insn |= suffix->value << operand->shift;

			  str = t;
			  found = 1;
			  break;
			}
		    }
		}
	      ++syn;
	      if (!found)
		/* Wrong type.  Just go on to try next insn entry.  */
		;
	      else
		{
		  if (num_suffixes == MAX_SUFFIXES)
		    as_bad (_("too many suffixes"));
		  else
		    insn_suffixes[num_suffixes++] = suffix;
		}
	    }
	  else
	    /* This is either a register or an expression of some kind.  */
	    {
	      char *hold;
	      const struct arc_operand_value *reg = NULL;
	      long value = 0;
	      expressionS exp;

	      if (operand->flags & ARC_OPERAND_SUFFIX)
		abort ();

	      /* Is there anything left to parse?
		 We don't check for this at the top because we want to parse
		 any trailing fake arguments in the syntax string.  */
	      if (is_end_of_line[(unsigned char) *str])
		break;

	      /* Parse the operand.  */
	      hold = input_line_pointer;
	      input_line_pointer = str;
	      expression (&exp);
	      str = input_line_pointer;
	      input_line_pointer = hold;

	      if (exp.X_op == O_illegal)
		as_bad (_("illegal operand"));
	      else if (exp.X_op == O_absent)
		as_bad (_("missing operand"));
	      else if (exp.X_op == O_constant)
		value = exp.X_add_number;
	      else if (exp.X_op == O_register)
		reg = (struct arc_operand_value *) exp.X_add_number;
#define IS_REG_DEST_OPERAND(o) ((o) == 'a')
	      else if (IS_REG_DEST_OPERAND (*syn))
		as_bad (_("symbol as destination register"));
	      else
		{
		  if (!strncmp (str, "@@h30", 4))
		    {
		      arc_code_symbol (&exp);
		      str += 4;
		    }
		  /* We need to generate a fixup for this expression.  */
		  if (fc >= MAX_FIXUPS)
		    as_fatal (_("too many fixups"));
		  fixups[fc].exp = exp;
		  /* We don't support shimm relocs. break here to force
		     the assembler to output a limm.  */
#define IS_REG_SHIMM_OFFSET(o) ((o) == 'd')
		  if (IS_REG_SHIMM_OFFSET (*syn))
		    break;
		  /* If this is a register constant (IE: one whose
		     register value gets stored as 61-63) then this
		     must be a limm.  */
		  /* ??? This bit could use some cleaning up.
		     Referencing the format chars like this goes
		     against style.  */
		  if (IS_SYMBOL_OPERAND (*syn))
		    {
		      const char *junk;
		      limm_reloc_p = 1;
		      /* Save this, we don't yet know what reloc to use.  */
		      fix_up_at = fc;
		      /* Tell insert_reg we need a limm.  This is
			 needed because the value at this point is
			 zero, a shimm.  */
		      /* ??? We need a cleaner interface than this.  */
		      (*arc_operands[arc_operand_map['Q']].insert)
			(insn, operand, mods, reg, 0L, &junk);
		    }
		  else
		    fixups[fc].opindex = arc_operand_map[(int) *syn];
		  ++fc;
		  value = 0;
		}

	      /* Insert the register or expression into the instruction.  */
	      if (operand->insert)
		{
		  const char *errmsg = NULL;
		  insn = (*operand->insert) (insn, operand, mods,
					     reg, (long) value, &errmsg);
		  if (errmsg != (const char *) NULL)
		    {
		      last_errmsg = errmsg;
		      if (operand->flags & ARC_OPERAND_ERROR)
			{
			  as_bad ("%s", errmsg);
			  return;
			}
		      else if (operand->flags & ARC_OPERAND_WARN)
			as_warn ("%s", errmsg);
		      break;
		    }
		}
	      else
		insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;

	      ++syn;
	    }
	}

      /* If we're at the end of the syntax string, we're done.  */
      /* FIXME: try to move this to a separate function.  */
      if (*syn == '\0')
	{
	  int i;
	  char *f;
	  long limm, limm_p;

	  /* For the moment we assume a valid `str' can only contain blanks
	     now.  IE: We needn't try again with a longer version of the
	     insn and it is assumed that longer versions of insns appear
	     before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */

	  while (ISSPACE (*str))
	    ++str;

	  if (!is_end_of_line[(unsigned char) *str])
	    as_bad (_("junk at end of line: `%s'"), str);

	  /* Is there a limm value?  */
	  limm_p = arc_opcode_limm_p (&limm);

	  /* Perform various error and warning tests.  */

	  {
	    static int in_delay_slot_p = 0;
	    static int prev_insn_needs_cc_nop_p = 0;
	    /* delay slot type seen */
	    int delay_slot_type = ARC_DELAY_NONE;
	    /* conditional execution flag seen */
	    int conditional = 0;
	    /* 1 if condition codes are being set */
	    int cc_set_p = 0;
	    /* 1 if conditional branch, including `b' "branch always" */
	    int cond_branch_p = opcode->flags & ARC_OPCODE_COND_BRANCH;

	    for (i = 0; i < num_suffixes; ++i)
	      {
		switch (arc_operands[insn_suffixes[i]->type].fmt)
		  {
		  case 'n':
		    delay_slot_type = insn_suffixes[i]->value;
		    break;
		  case 'q':
		    conditional = insn_suffixes[i]->value;
		    break;
		  case 'f':
		    cc_set_p = 1;
		    break;
		  }
	      }

	    /* Putting an insn with a limm value in a delay slot is supposed to
	       be legal, but let's warn the user anyway.  Ditto for 8 byte
	       jumps with delay slots.  */
	    if (in_delay_slot_p && limm_p)
	      as_warn (_("8 byte instruction in delay slot"));
	    if (delay_slot_type != ARC_DELAY_NONE
		&& limm_p && arc_insn_not_jl (insn)) /* except for jl  addr */
	      as_warn (_("8 byte jump instruction with delay slot"));
	    in_delay_slot_p = (delay_slot_type != ARC_DELAY_NONE) && !limm_p;

	    /* Warn when a conditional branch immediately follows a set of
	       the condition codes.  Note that this needn't be done if the
	       insn that sets the condition codes uses a limm.  */
	    if (cond_branch_p && conditional != 0 /* 0 = "always" */
		&& prev_insn_needs_cc_nop_p && arc_mach_type == bfd_mach_arc_5)
	      as_warn (_("conditional branch follows set of flags"));
	    prev_insn_needs_cc_nop_p =
	      /* FIXME: ??? not required:
		 (delay_slot_type != ARC_DELAY_NONE) &&  */
	      cc_set_p && !limm_p;
	  }

	  /* Write out the instruction.
	     It is important to fetch enough space in one call to `frag_more'.
	     We use (f - frag_now->fr_literal) to compute where we are and we
	     don't want frag_now to change between calls.  */
	  if (limm_p)
	    {
	      f = frag_more (8);
	      md_number_to_chars (f, insn, 4);
	      md_number_to_chars (f + 4, limm, 4);
	      dwarf2_emit_insn (8);
	    }
	  else if (limm_reloc_p)
	    /* We need a limm reloc, but the tables think we don't.  */
	    abort ();
	  else
	    {
	      f = frag_more (4);
	      md_number_to_chars (f, insn, 4);
	      dwarf2_emit_insn (4);
	    }

	  /* Create any fixups.  */
	  for (i = 0; i < fc; ++i)
	    {
	      int op_type, reloc_type;
	      expressionS exptmp;
	      const struct arc_operand *operand;

	      /* Create a fixup for this operand.
		 At this point we do not use a bfd_reloc_code_real_type for
		 operands residing in the insn, but instead just use the
		 operand index.  This lets us easily handle fixups for any
		 operand type, although that is admittedly not a very exciting
		 feature.  We pick a BFD reloc type in md_apply_fix.

		 Limm values (4 byte immediate "constants") must be treated
		 normally because they're not part of the actual insn word
		 and thus the insertion routines don't handle them.  */

	      if (arc_operands[fixups[i].opindex].flags & ARC_OPERAND_LIMM)
		{
		  /* Modify the fixup addend as required by the cpu.  */
		  fixups[i].exp.X_add_number += arc_limm_fixup_adjust (insn);
		  op_type = fixups[i].opindex;
		  /* FIXME: can we add this data to the operand table?  */
		  if (op_type == arc_operand_map['L']
		      || op_type == arc_operand_map['s']
		      || op_type == arc_operand_map['o']
		      || op_type == arc_operand_map['O'])
		    reloc_type = BFD_RELOC_32;
		  else if (op_type == arc_operand_map['J'])
		    reloc_type = BFD_RELOC_ARC_B26;
		  else
		    abort ();
		  reloc_type = get_arc_exp_reloc_type (1, reloc_type,
						       &fixups[i].exp,
						       &exptmp);
		}
	      else
		{
		  op_type = get_arc_exp_reloc_type (0, fixups[i].opindex,
						    &fixups[i].exp, &exptmp);
		  reloc_type = op_type + (int) BFD_RELOC_UNUSED;
		}
	      operand = &arc_operands[op_type];
	      fix_new_exp (frag_now,
			   ((f - frag_now->fr_literal)
			    + (operand->flags & ARC_OPERAND_LIMM ? 4 : 0)), 4,
			   &exptmp,
			   (operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0,
			   (bfd_reloc_code_real_type) reloc_type);
	    }
	  return;
	}
    }

  if (NULL == last_errmsg)
    as_bad (_("bad instruction `%s'"), start);
  else
    as_bad ("%s", last_errmsg);
}
@


1.47
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d3 1
a3 1
   2006, 2007, 2009  Free Software Foundation, Inc.
d937 1
a937 1
      symbolP->local = 1;
@


1.47.2.1
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2011  Free Software Foundation, Inc.
d937 1
a937 1
      symbol_get_obj (symbolP)->local = 1;
@


1.46
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d543 2
a544 1
  ext_oper = xmalloc (sizeof (struct arc_ext_operand_value));
d806 1
a806 1
  ext_op = xmalloc (sizeof (struct arc_opcode));
d1200 2
a1201 1
      fix_new_exp (frag, where, nbytes, &exptmp, 0, reloc_type);
d1355 2
a1356 2
  reloc = xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
d1573 2
a1574 1
		suf = hash_find (arc_suffix_hash, s);
@


1.45
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d50 1
a50 1
  int  class;
d649 1
a649 1
  int class = 0;
d759 1
a759 1
	  class = syntaxclass[i].class;
d765 1
a765 1
  if (0 == (SYNTAX_VALID & class))
d772 1
a772 1
  if ((0x3 == opcode) & (class & SYNTAX_3OP))
d800 1
a800 1
  strcat (syntax, ((opcode == 0x3) ? "%a,%b" : ((class & SYNTAX_3OP) ? "%a,%b,%c" : "%b,%c")));
d810 1
a810 1
  ext_op->flags = class;
d832 1
a832 1
  *p = (class & (OP1_MUST_BE_IMM | OP1_IMM_IMPLIED) ? IGNORE_FIRST_OPD : 0);
@


1.45.2.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d50 1
a50 1
  int  s_class;
d649 1
a649 1
  int s_class = 0;
d759 1
a759 1
	  s_class = syntaxclass[i].s_class;
d765 1
a765 1
  if (0 == (SYNTAX_VALID & s_class))
d772 1
a772 1
  if ((0x3 == opcode) & (s_class & SYNTAX_3OP))
d800 1
a800 1
  strcat (syntax, ((opcode == 0x3) ? "%a,%b" : ((s_class & SYNTAX_3OP) ? "%a,%b,%c" : "%b,%c")));
d810 1
a810 1
  ext_op->flags = s_class;
d832 1
a832 1
  *p = (s_class & (OP1_MUST_BE_IMM | OP1_IMM_IMPLIED) ? IGNORE_FIRST_OPD : 0);
@


1.44
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2006, 2007  Free Software Foundation, Inc.
d302 1
a302 1
	as_warn (errmsg);
d1507 1
a1507 1
			  as_bad (errmsg);
d1511 1
a1511 1
			as_warn (errmsg);
d1724 1
a1724 1
			  as_bad (errmsg);
d1728 1
a1728 1
			as_warn (errmsg);
d1892 1
a1892 1
    as_bad (last_errmsg);
@


1.43
log
@PR gas/5172
* config/tc-arc.c (md_estimate_size_before_relax): Change error message.
  (md_convert_frag): Just call abort.
* config/tc-i860.c (md_estimate_size_before_relax): Change error message.
* config/tc-i860.h (md_convert_frag): Just call abort.
* config/tc-ip2k.c (md_estimate_size_before_relax): Change error message.
  (md_convert_frag): Just call abort.
* config/tc-m68k.c (m68k_ip): Do not attempt translation of architecture names.
@
text
@d892 1
a892 1
  assert (symbolP->sy_frag == &zero_address_frag);
d1286 1
a1286 1
	  assert ((operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0
d1293 1
a1293 1
	  assert ((operand->flags & ARC_OPERAND_ABSOLUTE_BRANCH) != 0
d1300 1
a1300 1
	  assert ((operand->flags & ARC_OPERAND_LIMM) != 0
d1368 1
a1368 1
  assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);
@


1.43.6.1
log
@Commit patches for ARCompact support to binutils-arc-20081103-branch .
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
a5 1
   Support for PIC : Added by Codito Technologies.
d27 1
d32 1
a32 46
/* #define DEBUG_INST_PATTERN 0 */
#define GAS_DEBUG_STMT(x) 
#define GAS_DEBUG_PIC(x)	
/* fprintf(stderr,"At %d in %s current_type is %s\n",
   __LINE__,__PRETTY_FUNCTION__,
   (current_pic_flag == GOT_TYPE)?"GOT":"NO_TYPE") 
*/

extern int arc_get_mach (char *);
extern int arc_insn_not_jl (arc_insn);
extern int arc_get_noshortcut_flag (void);
static void arc_set_ext_seg (enum ExtOperType, int, int, int);

extern int a4_brk_insn(arc_insn insn);
extern int ac_brk_s_insn(arc_insn insn);
extern int ARC700_rtie_insn(arc_insn insn);

static arc_insn arc_insert_operand (arc_insn, long *,
				    const struct arc_operand *, int,
				    const struct arc_operand_value *,
				    offsetT, char *, unsigned int);
static valueT md_chars_to_number (char *, int);

static void arc_common (int);
static void arc_handle_extinst (int);
static void arc_extinst (int);
static void arc_extoper (int);
static void arc_option (int);
static int  get_arc_exp_reloc_type (int, int, expressionS *,
				    expressionS *);
static int  arc_get_sda_reloc (arc_insn, int);

static void init_opcode_tables (int);
static void arc_ac_extinst (int);

/* fields for extended instruction format in extmap section */
static int use_extended_instruction_format=0;
static unsigned char extended_register_format[RCLASS_SET_SIZE];
static unsigned char extended_operand_format1[OPD_FORMAT_SIZE];
static unsigned char extended_operand_format2[OPD_FORMAT_SIZE];
static unsigned char extended_operand_format3[OPD_FORMAT_SIZE];
static unsigned char extended_instruction_flags[4];

symbolS * GOT_symbol = 0;

static const struct suffix_classes
d46 1
a46 1
static const struct syntax_classes
d58 1
a58 1
  { "SYNTAX_2OP",                 10, SYNTAX_2OP|SYNTAX_VALID },
a62 1

d77 1
a77 1
const char line_separator_chars[] = "`";
d94 1
a94 1
static int arc_mach_type = bfd_mach_arc_a4;
a98 4
/* This is a flag that is set when an instruction is being assembled and
   otherwise it is reset.  */
static int assembling_instruction = 0;

a102 23

/* Bit field of extension instruction options.  */
static unsigned long extinsnlib = 0;

#define SWAP_INSN		0x1
#define NORM_INSN		(SWAP_INSN << 1)
#define BARREL_SHIFT_INSN	(NORM_INSN << 1)
#define MIN_MAX_INSN		(BARREL_SHIFT_INSN << 1)
#define NO_MPY_INSN		(MIN_MAX_INSN << 1)
#define EA_INSN			(NO_MPY_INSN << 1)
#define MUL64_INSN		(EA_INSN << 1)
#define SIMD_INSN               (MUL64_INSN << 1)
#define SP_FLOAT_INSN           (SIMD_INSN << 1)
#define DP_FLOAT_INSN           (SP_FLOAT_INSN << 1)
#define XMAC_D16                (DP_FLOAT_INSN << 1)
#define XMAC_24                 (XMAC_D16      << 1)
#define DSP_PACKA               (XMAC_24       << 1)
#define CRC                     (DSP_PACKA     << 1)
#define DVBF                    (CRC           << 1)
#define TELEPHONY               (DVBF          << 1)
#define XYMEMORY                (TELEPHONY     << 1)


d104 1
a104 1

d111 5
a115 24
  OPTION_A4,
  OPTION_A5,
  OPTION_ARC600,
  OPTION_ARC700,
  OPTION_USER_MODE,
  OPTION_LD_EXT_MASK,
  OPTION_SWAP,
  OPTION_NORM,
  OPTION_BARREL_SHIFT,
  OPTION_MIN_MAX,
  OPTION_NO_MPY,
  OPTION_EA,
  OPTION_MUL64,
  OPTION_SIMD,
  OPTION_SPFP,
  OPTION_DPFP,
  OPTION_XMAC_D16,
  OPTION_XMAC_24,
  OPTION_DSP_PACKA,
  OPTION_CRC,
  OPTION_DVBF,
  OPTION_TELEPHONY,
  OPTION_XYMEMORY
/* ARC Extension library options.  */  
d122 6
a127 31
  { "mA4", no_argument, NULL, OPTION_A4 },
  { "mA5", no_argument, NULL, OPTION_A5 },
  { "mA6", no_argument, NULL, OPTION_ARC600 },
  { "mARC600", no_argument, NULL, OPTION_ARC600 },
  { "mARC700", no_argument, NULL, OPTION_ARC700 },
  { "mA7", no_argument, NULL, OPTION_ARC700 },
  { "muser-mode-only", no_argument, NULL, OPTION_USER_MODE },
  { "mld-extension-reg-mask", required_argument, NULL, OPTION_LD_EXT_MASK },

/* ARC Extension library options.  */  
  { "mswap", no_argument, NULL, OPTION_SWAP },
  { "mnorm", no_argument, NULL, OPTION_NORM },
  { "mbarrel_shifter", no_argument, NULL, OPTION_BARREL_SHIFT },
  { "mmin_max", no_argument, NULL, OPTION_MIN_MAX },
  { "mno-mpy", no_argument, NULL, OPTION_NO_MPY },
  { "mEA", no_argument, NULL, OPTION_EA },
  { "mmul64", no_argument, NULL, OPTION_MUL64 },
  { "msimd", no_argument, NULL, OPTION_SIMD},
  { "mspfp", no_argument, NULL, OPTION_SPFP},
  { "mspfp_compact", no_argument, NULL, OPTION_SPFP},
  { "mspfp_fast", no_argument, NULL, OPTION_SPFP},
  { "mdpfp", no_argument, NULL, OPTION_DPFP},
  { "mdpfp_compact", no_argument, NULL, OPTION_DPFP},
  { "mdpfp_fast", no_argument, NULL, OPTION_DPFP},
  { "mmac_d16", no_argument, NULL, OPTION_XMAC_D16},
  { "mmac_24", no_argument, NULL, OPTION_XMAC_24},
  { "mdsp_packa", no_argument, NULL, OPTION_DSP_PACKA},
  { "mcrc", no_argument, NULL, OPTION_CRC},
  { "mdvbf", no_argument, NULL, OPTION_DVBF},
  { "mtelephony", no_argument, NULL, OPTION_TELEPHONY},
  { "mxy", no_argument, NULL, OPTION_XYMEMORY},
a129 1

d133 1
a133 186
 ((arc_mach_a4 && \
   ((o) == 'b' || (o) == 'c' || (o) == 's' || (o) == 'o' || (o) == 'O')) || \
  (!arc_mach_a4 && \
   ((o) == 'g' || (o) == 'o' || (o) == 'M' || (o) == 'O' || (o) == 'R')))

typedef enum 
  {
    GOT_TYPE,
    PLT_TYPE,
    GOTOFF_TYPE,
    SDA_REF_TYPE,
    NO_TYPE
  } arc700_special_symtype;

static arc700_special_symtype current_special_sym_flag;


/**************************************************************************/
/* Here's all the ARCompact illegal instruction sequence checking stuff.  */
/**************************************************************************/

#define MAJOR_OPCODE(x) ((x & 0xf8000000) >> 27)
#define SUB_OPCODE(x)	 ((x & 0x003f0000) >> 16)

#define SUB_OPCODE2(x)	(x & 0x0000003f)
  
#define SUB_OPCODE3(x)	(((x & 0x07000000) >> 24) |   \
			 ((x & 0x00007000) >> 9))
  
#define J_INSN(x)	((MAJOR_OPCODE (x) == 0x4) && \
			 (SUB_OPCODE (x) >= 0x21) &&  \
			 (SUB_OPCODE (x) <= 0x22))
  
#define JL_INSN(x)	((MAJOR_OPCODE (x) == 0x4) && \
			 (SUB_OPCODE (x) >= 0x23) &&  \
			 (SUB_OPCODE (x) <= 0x24))

#define BLcc_INSN(x)    ((MAJOR_OPCODE (x) == 0x1) && \
			 ((x & 00010000) == 0))

#define LP_INSN(x)	((MAJOR_OPCODE (x) == 0x4) && \
			 (SUB_OPCODE (x) == 0x28))

#define SLEEP_INSN(x)	((MAJOR_OPCODE (x) == 0x4) && \
			 (SUB_OPCODE (x) == 0x2f)  && \
			 (SUB_OPCODE2 (x) == 0x3f) && \
			 (SUB_OPCODE3 (x) == 0x01))
			 
#define BRK_INSN(x)	((MAJOR_OPCODE (x) == 0x4) && \
			 (SUB_OPCODE (x) == 0x2f)  && \
			 (SUB_OPCODE2 (x) == 0x3f) && \
			 (SUB_OPCODE3 (x) == 0x05))

/* Data structures and functions for illegal instruction sequence
   checks. arc_insn last_two_insns is a queue of the last two instructions
   that have been assembled.  last_two_insns[0] is the head and
   last_two_insns[1] is the tail.  */

#define PREV_INSN_2 1
#define PREV_INSN_1 0

/* Queue containing the last two instructions seen.  */
static struct enriched_insn last_two_insns[2];

/* This is an "insert at front" linked list per Metaware spec
   that new definitions override older ones.  */
static struct arc_opcode *arc_ext_opcodes;

static void zero_overhead_checks (struct loop_target *);
static void insert_last_insn (arc_insn insn,
			      unsigned short delay_slot,
			      unsigned short limm,
			      symbolS *sym)
{
  last_two_insns[PREV_INSN_2]=last_two_insns[PREV_INSN_1];
  last_two_insns[PREV_INSN_1].insn=insn;
  last_two_insns[PREV_INSN_1].delay_slot=delay_slot;
  last_two_insns[PREV_INSN_1].limm=limm;
  if (LP_INSN (insn))
    last_two_insns[PREV_INSN_1].sym= symbol_get_bfdsym (sym);
  else
    last_two_insns[PREV_INSN_1].sym = NULL;
}


/* labelsym and lt->symbol form a commutative pair of symbol of the label
   definition and the symbol of the label use.  This function needs to be
   called only when we've identified a loop completely, ie. found both the
   head (the defining lpcc instruction) and the tail (loop ending label).  */
static void zero_overhead_checks (struct loop_target *lt)
{

  switch (arc_mach_type)
    {
    case bfd_mach_arc_a5:

      /* This takes care of insn being Jcc.d, Bcc.d, JCcc.d, BRcc.d,
	 BBITn.d, J_S.d.  */
      if (lt->prev_two_insns[PREV_INSN_1].delay_slot || 
	  BLcc_INSN (lt->prev_two_insns[PREV_INSN_1].insn) ||
	  JL_INSN (lt->prev_two_insns[PREV_INSN_1].insn))
	as_bad ("An instruction of this type may not be executed in this \
instruction slot.");
      
      /* We haven't handled JL_S.d in insn-1 of the loop.  */
      if (lt->prev_two_insns[PREV_INSN_2].delay_slot)
	if (JL_INSN (lt->prev_two_insns[PREV_INSN_2].insn) ||
	    BLcc_INSN (lt->prev_two_insns[PREV_INSN_2].insn))
	  as_bad ("An instruction of this type may not be executed in this \
instruction slot.");

      /* This takes care of JLcc limm.  */
      if (lt->prev_two_insns[PREV_INSN_2].limm)
	if (JL_INSN (lt->prev_two_insns[PREV_INSN_2].insn))
	  as_bad ("An instruction of this type may not be executed in this \
instruction slot.");

      /* This takes care of LP other_loop in insn and insn-1.  */
      if ((LP_INSN (lt->prev_two_insns[PREV_INSN_1].insn) &&
	   lt->prev_two_insns[PREV_INSN_1].sym != lt->symbol) ||
	  (LP_INSN (lt->prev_two_insns[PREV_INSN_2].insn) &&
	   lt->prev_two_insns[PREV_INSN_2].sym != lt->symbol))
	as_bad ("An instruction of this type may not be executed in this \
instruction slot.");

      if (SLEEP_INSN (lt->prev_two_insns[PREV_INSN_1].insn) ||
	  BRK_INSN (lt->prev_two_insns[PREV_INSN_1].insn))
	as_bad ("An instruction of this type may not be executed in this \
instruction slot.");	
      
      break;

    case bfd_mach_arc_arc600:

      if (BLcc_INSN (lt->prev_two_insns[PREV_INSN_1].insn) ||
	  JL_INSN (lt->prev_two_insns[PREV_INSN_1].insn))
	as_bad ("An instruction of this type may not be executed in this \
instruction slot.");
      
      /* This takes care of LP other_loop in insn and insn-1.  */
      if (LP_INSN (lt->prev_two_insns[PREV_INSN_1].insn) &&
	  LP_INSN (lt->prev_two_insns[PREV_INSN_2].insn))
	as_bad ("An instruction of this type may not be executed in this \
instruction slot.");

      if (SLEEP_INSN (lt->prev_two_insns[PREV_INSN_1].insn) ||
	  BRK_INSN (lt->prev_two_insns[PREV_INSN_1].insn))
	as_bad ("An instruction of this type may not be executed in this \
instruction slot.");

      if (lt->prev_two_insns[PREV_INSN_2].limm)
	if (JL_INSN (lt->prev_two_insns[PREV_INSN_2].insn))
	  as_bad ("An instruction of this type may not be executed in this \
instruction slot.");

      if (lt->prev_two_insns[PREV_INSN_1].limm)
	if (J_INSN (lt->prev_two_insns[PREV_INSN_1].insn))
	  as_bad ("An instruction of this type may not be executed in this \
instruction slot.");
      
      if (lt->prev_two_insns[PREV_INSN_1].delay_slot)
	as_bad ("An instruction of this type may not be executed in this \
instruction slot.");
      
      /* We haven't handled JL_S.d in insn-1 of the loop.  */
      if (lt->prev_two_insns[PREV_INSN_2].delay_slot)
	if (JL_INSN (lt->prev_two_insns[PREV_INSN_2].insn) ||
	    BLcc_INSN (lt->prev_two_insns[PREV_INSN_2].insn))
	  as_bad ("An instruction of this type may not be executed in this \
instruction slot.");

      break;

    case bfd_mach_arc_arc700:

      if (lt->prev_two_insns[PREV_INSN_1].delay_slot)
	as_bad ("An instruction of this type may not be executed in this \
instruction slot.");
      
      break;
      
    default:
      ;

    }
}
d135 1
a135 47
static void add_loop_target (symbolS *symbol)
{
  struct loop_target *tmp = &symbol_get_tc (symbol)->loop_target;
  
  if (!tmp->symbol)
    {
      tmp->symbol = symbol_get_bfdsym (symbol);
    }
  else
    {
      zero_overhead_checks (tmp);
    }
}

void
arc_check_label (symbolS *labelsym)
{
  /* At this point, the current line pointer is sitting on the character
     just after the first colon on the label.  */ 
  
  struct loop_target *tmp = &symbol_get_tc (labelsym)->loop_target;
  asymbol *new;
  
  new = symbol_get_bfdsym (labelsym);
  
  /* Label already defined.  */
  if (tmp->symbol)
    {
      /* Store the last two instructions.  */
      tmp->prev_two_insns[PREV_INSN_1]=last_two_insns[PREV_INSN_1];
      tmp->prev_two_insns[PREV_INSN_2]=last_two_insns[PREV_INSN_2];
      
      /* Now perform whatever checks on these last two instructions.  */
      zero_overhead_checks (tmp);
    }
  /* Label not defined.  */
  else
    {
      tmp->symbol = new;
      
      /* Store the last two instructions.  */
      tmp->prev_two_insns[PREV_INSN_1]=last_two_insns[PREV_INSN_1];
      tmp->prev_two_insns[PREV_INSN_2]=last_two_insns[PREV_INSN_2];
    }
}

/* Here's where all the ARCompact illegal instruction sequence checks end.  */
d137 2
a138 6
/*
 * md_parse_option
 *
 * Invocation line includes a switch not recognized by the base assembler.
 * See if it's a processor-specific option.
 */
d145 2
a146 14
    case OPTION_A4:
      mach_type_specified_p = 1;
      arc_mach_type = bfd_mach_arc_a4;
      arc_mach_a4= 1;
      break;
    case OPTION_A5:
      mach_type_specified_p = 1;
      arc_mach_type = bfd_mach_arc_a5;
      arc_mach_a4= 0;
      break;
    case OPTION_ARC600:
      mach_type_specified_p = 1;
      arc_mach_type = bfd_mach_arc_arc600;
      arc_mach_a4= 0;
d148 3
a150 4
    case OPTION_ARC700:
      mach_type_specified_p = 1;
      arc_mach_type = bfd_mach_arc_arc700;
      arc_mach_a4= 0;
d152 2
a153 2
    case OPTION_USER_MODE:
      arc_user_mode_only = 1;
d155 2
a156 2
    case OPTION_LD_EXT_MASK:
      arc_ld_ext_mask = strtoul (arg, NULL, 0);
a165 52
    case OPTION_SWAP:
      extinsnlib |= SWAP_INSN;
      break;
    case OPTION_NORM:
      extinsnlib |= NORM_INSN;
      break;
    case OPTION_BARREL_SHIFT:
      extinsnlib |= BARREL_SHIFT_INSN;
      break;
    case OPTION_MIN_MAX:
      extinsnlib |= MIN_MAX_INSN;
      break;
    case OPTION_NO_MPY:
      extinsnlib |= NO_MPY_INSN;
      break;
    case OPTION_EA:
      extinsnlib |= EA_INSN;
      break;
    case OPTION_MUL64:
      extinsnlib |= MUL64_INSN;
      break;
    case OPTION_SIMD:
      extinsnlib |= SIMD_INSN;
      break;
    case OPTION_SPFP:
      extinsnlib |= SP_FLOAT_INSN;
      break;
    case OPTION_DPFP:
      extinsnlib |= DP_FLOAT_INSN;
      break;      
    case OPTION_XMAC_D16:
      extinsnlib |= XMAC_D16;
      break;
    case OPTION_XMAC_24:
      extinsnlib |= XMAC_24;
      break;
    case OPTION_DSP_PACKA:
      extinsnlib |= DSP_PACKA;
      break;
    case OPTION_CRC:
      extinsnlib |= CRC;
      break;
    case OPTION_DVBF:
      extinsnlib |= DVBF;
      break;
    case OPTION_TELEPHONY:
      extinsnlib |= TELEPHONY;
      break;
    case OPTION_XYMEMORY:
      extinsnlib |= XYMEMORY;
      break;

d177 1
a177 2
  -mA[4|5]                select processor variant (default arc%d)\n\
  -mARC[600|700]          select processor variant\n\
a181 195
/* Extension library support. */

extern char *myname;

/* There are two directories in which the binary in the install
   directory.  We would need to use the appropriate binary directory
   depending on which of the binaries is being executed.  */

#define BINDIR1 "/home/bin"
#define BINDIR2 "/home/arc-elf32/bin"
#define LIBDIR1 "/home/extlib"

#define BINDIR3 "/gas"
#define LIBDIR2 "/gas/config/extlib"
#define EXTLIBFILE "arcextlib.s"
#define SIMDEXTLIBFILE "arcsimd.s"

struct extension_macro
{
  unsigned long option;
  char name[20];
};

static struct extension_macro extension_macros[]=
  {
    {SWAP_INSN, "__Xswap"},
    {NORM_INSN, "__Xnorm"},
    {BARREL_SHIFT_INSN,"__Xbarrel_shifter"},
    {MIN_MAX_INSN,"__Xmin_max"},
    {NO_MPY_INSN,"__Xno_mpy"},
    {EA_INSN,"__Xea"},
    {MUL64_INSN,"__Xmult32"},
    {SIMD_INSN, "__Xsimd"},
    {SP_FLOAT_INSN, "__Xspfp"},
    {DP_FLOAT_INSN, "__Xdpfp"},
    {XMAC_D16, "__Xxmac_d16"},
    {XMAC_24, "__Xxmac_24"},
    {DSP_PACKA, "__Xdsp_packa"},
    {CRC, "__Xcrc"},
    {DVBF, "__Xdvbf"},
    {TELEPHONY, "__Xtelephony"},
    {XYMEMORY, "__Xxy"}
  };

static unsigned short n_extension_macros = (sizeof (extension_macros) /
				   sizeof (struct extension_macro));

static int
file_exists (char *filename)
{
  FILE *fp = fopen (filename , "r");

  if (fp)
    {
      fclose (fp);
      return 1;
    }
  else
    return 0;
}

/* This function reads in the "configuration files" based on the options
   passed on the command line through the options -mswap and -mnorm.  */
static void
arc_process_extinstr_options (void)
{
  unsigned long i;
  char extension_library_path[160];
  char temp[80];
  symbolS *sym;
  
  /* Let's get to the right extension configuration library based on which
     processor we are assembling the source assembly file for.  */

  switch (arc_mach_type)
    {
    case bfd_mach_arc_a4:
      strcpy (temp, "__A4__");
      break;

    case bfd_mach_arc_a5:
      strcpy (temp, "__A5__");
      break;

    case bfd_mach_arc_arc600:
      strcpy (temp, "__ARC600__");
      break;

    case bfd_mach_arc_arc700:
      strcpy (temp, "__ARC700__");
      break;

    default:
      as_bad ("Oops! Something went wrong here!");
      break;
    }

  if ((extinsnlib & NO_MPY_INSN) && (arc_mach_type != bfd_mach_arc_arc700))
    {
      as_bad ("-mno-mpy can only be used with ARC700");
      exit (1);
    }

  if ((extinsnlib & MUL64_INSN) && (arc_mach_type == bfd_mach_arc_arc700))
    {
      as_bad ("-mmul64 cannot be used with ARC 700");
      exit (1);
    }

  if ((extinsnlib & SIMD_INSN ) && ( arc_mach_type != bfd_mach_arc_arc700))
    {
      as_bad ("-msimd can only be used with ARC 700");
      exit (1);
    }
  
  sym = (symbolS *) local_symbol_make (temp, absolute_section, 1,
				       &zero_address_frag);
  symbol_table_insert (sym);

  for (i=0 ; i < n_extension_macros ; ++i){
    if (extinsnlib & extension_macros[i].option)
      {
	sym = (symbolS *) local_symbol_make (extension_macros[i].name,
					     absolute_section, 1,
					     &zero_address_frag);
	symbol_table_insert (sym);
      }
      }


  /* Let's get the path of the base directory of the extension configuration
  libraries.  */
  
  strcpy (extension_library_path,
	  make_relative_prefix (myname, BINDIR1, LIBDIR1));
  strcat (extension_library_path, "/"EXTLIBFILE);
  
  if (!file_exists (extension_library_path))
    {
      strcpy (extension_library_path,
	      make_relative_prefix (myname, BINDIR2, LIBDIR1));
      strcat (extension_library_path, "/"EXTLIBFILE);
    }

  if (!file_exists (extension_library_path))
    {
      strcpy (extension_library_path,
	      make_relative_prefix (myname, BINDIR3, LIBDIR2));
      strcat (extension_library_path, "/"EXTLIBFILE);
    }

  if (!file_exists (extension_library_path))
    {
      as_bad ("Extension library file(s) do not exist\n");
      exit (1);
    }
  
  /* For A4, A5 and ARC600 read the lib file if extinsnlib is set
     For ARC700 do not read the lib file if the NO_MPY_INSN flag 
     is the only one set*/
  if ( (arc_mach_type == bfd_mach_arc_arc700)? 
       (extinsnlib != NO_MPY_INSN)
       : extinsnlib)
    read_a_source_file (extension_library_path);

  if (extinsnlib &  SIMD_INSN)
    {
      strcpy (extension_library_path,
	      make_relative_prefix (myname, BINDIR1, LIBDIR1));
      strcat (extension_library_path, "/"SIMDEXTLIBFILE);
  
      if (!file_exists (extension_library_path))
	{
	  strcpy (extension_library_path,
		  make_relative_prefix (myname, BINDIR2, LIBDIR1));
	  strcat (extension_library_path, "/"SIMDEXTLIBFILE);
	}

      if (!file_exists (extension_library_path))
	{
	  strcpy (extension_library_path,
		  make_relative_prefix (myname, BINDIR3, LIBDIR2));
	  strcat (extension_library_path, "/"SIMDEXTLIBFILE);
	}

      if (!file_exists (extension_library_path))
	{
	  as_bad ("ARC700 SIMD Extension library file(s) do not exist\n");
	  exit (1);
	}

      read_a_source_file (extension_library_path );
    }
}

d194 1
a194 1
    as_warn ("could not set architecture and machine");
d196 2
a197 3
  /* Assume the base cpu.  This call is necessary because we need to
     initialize `arc_operand_map' which may be needed before we see the
     first insn.  */
a199 2

  arc_process_extinstr_options ();
d212 1
a212 1
    as_fatal ("virtual memory exhausted");
d215 1
a215 1
    as_warn ("could not set architecture and machine");
a225 4
	/*
	  A check using arc_opval_supported is omitted in the 2.15
	  Not adding it until required.
	*/
d231 20
d259 1
a259 1
arc_insert_operand (arc_insn insn, long *insn2,
d269 1
a269 1
      long min, max, bits;
a271 7
      if (operand->flags & ARC_OPERAND_4BYTE_ALIGNED)
	bits = operand->bits + 2;
      else if (operand->flags & ARC_OPERAND_2BYTE_ALIGNED)
	bits = operand->bits + 1;
      else 
	bits = operand->bits;

d275 1
a275 1
	    max = (1 << bits) - 1;
d277 2
a278 2
	    max = (1 << (bits - 1)) - 1;
	  min = - (1 << (bits - 1));
d282 1
a282 1
	  max = (1 << bits) - 1;
d292 1
a292 3
	((operand->flags & ARC_OPERAND_ERROR
	  ? as_bad_value_out_of_range : as_warn_value_out_of_range)
	 (_("operand"), test, (offsetT) min, (offsetT) max, file, line));
d300 1
a300 1
      insn = (*operand->insert) (insn,insn2, operand, mods, reg, (long) val, &errmsg);
a318 1
  unsigned int modifier_flags;
d364 11
a374 1
      if (exp->X_add_symbol != NULL)
d376 2
a377 25
	  if (!(exp->X_add_symbol->bsym)
	      || (exp->X_add_symbol->sy_value.X_op == O_constant
	      || exp->X_add_symbol->sy_value.X_op == O_symbol))
	    {
	      *expnew = *exp;
	      expnew->X_op = O_symbol;
	      expnew->X_op_symbol = NULL;
#if 0
	      if (!arc_mach_a4 && current_special_sym_flag == GOT_TYPE)
		return BFD_RELOC_ARC_GOTPC32;
#endif
	      if (arc_mach_a4)
		return data_p ? BFD_RELOC_ARC_B26 : arc_operand_map['J'];
	      else
		return data_p ? BFD_RELOC_ARC_32_ME : arc_operand_map['L'];
	    }
	  else if (!(exp->X_add_symbol->bsym)
		   || exp->X_add_symbol->sy_value.X_op == O_subtract)
	    {
	      *expnew = exp->X_add_symbol->sy_value;
	      if (arc_mach_a4)
		return data_p ? BFD_RELOC_ARC_B26 : arc_operand_map['J'];
	      else
		return data_p ? BFD_RELOC_ARC_32_ME : arc_operand_map['L'];
	    }
d385 2
a386 20
/* n1 - syntax type (3 operand, 2 operand, 1 operand or 0 operand).
	core register number.
	auxillary register number.
	condition code.
   n2 - major opcode if instruction.
   n2 - index to special type if core register.

   n3 - subopcode.  
        If n1 has AC_SYNTAX_SIMD set then n3 has additional fields packed.
        bits  usage
        0-7    sub_opcode
        8-15   real opcode if EXTEND2
        16-23  real opcode if EXTEND3
        24-25  accumulator mode
        28-29  nops
        30-31  flag1 and flag2
*/

void
arc_set_ext_seg (enum ExtOperType type, int n1, int n2, int n3)
d388 1
a388 13
  int nn2;
  char *type_str;
  char type_strings[][8] = {"inst","core","aux","cond","corereg"};
  char temp[10];
  char *aamode,*efmode;

  char section_name[80];

  /* Generate section names based on the type of extension map record.  */

  aamode = "";
  efmode = "";
  switch (type)
d390 1
a390 121

    case EXT_AC_INSTRUCTION:
    case EXT_INSTRUCTION:

      type_str = type_strings[0];
      switch (n1)
	{
	case AC_SYNTAX_3OP:
	case SYNTAX_3OP:
	  n1 = 3;
	  break;
	case AC_SYNTAX_2OP:
	case SYNTAX_2OP:
	  n1 = 2;
	  break;
	case AC_SYNTAX_1OP:
	case SYNTAX_1OP:
	  n1 = 1;
	  break;
	case AC_SYNTAX_NOP:
	case SYNTAX_NOP:
	  n1 = 0;
	  break;
	default:
          n1 = (n3 >> 28) & 0x3;
          switch((n3 >> 24) & 0x3){
          case 0:
              aamode = "aa0";
              break;
          case 1:
              aamode = "aa1";
              extended_instruction_flags[2] |= (FLAG_AS >> 8);
              break;
          case 2:
              aamode = "aa2";
              extended_instruction_flags[2] |= (FLAG_AP >> 8);
              break;
          case 3:
              aamode = "aa3";
              extended_instruction_flags[2] |= (FLAG_AM >> 8);
              break;
              }
          switch((n3 >> 30) & 0x3){
          case 0:
              efmode = ".ef0";
              break;
          case 1:
              efmode = ".ef1";
              extended_instruction_flags[1] |= (FLAG_FMT1 >> 16);
              break;
          case 2:
              efmode = ".ef2";
              extended_instruction_flags[1] |= (FLAG_FMT2 >> 16);
              break;
          case 3:
              efmode = ".ef3";
              extended_instruction_flags[1] |= (FLAG_FMT3 >> 16);
              break;
              }
	  ;
	} /* end switch(n1) */

      nn2 = n3 & 0x3f;
      if(n2 == 0xa || n2 == 0x9){
          if(nn2 == 0x2f){
              nn2 = (n3 >> 8) & 0x3f;
              if(nn2 == 0x3f){
                  nn2 = (n3 >> 16) & 0x3f;
                  }
              }
          }
      if(n2 == 0x9){
          if(n3 & 0x4000000){
              extended_instruction_flags[3] |= FLAG_3OP_U8;
              sprintf(temp, "%d.%d.%du8", n1, n2, nn2&0x3f);
              }
          else
              sprintf (temp, "%d.%d.%d", n1, n2, nn2&0x3f);
          }
      else
          sprintf (temp, "%d.%d.%d%s%s", n1, n2, nn2&0x3f,aamode,efmode);
      break;

    case EXT_LONG_CORE_REGISTER:
      type_str = type_strings[4];
      if(n2!=0)
          sprintf(temp,"%d%c",n1,n2);
      else 
          sprintf (temp, "%d", n1);
      break;

    case EXT_CORE_REGISTER:
      type_str = type_strings[1];
      if(n2!=0)
          sprintf(temp,"%d%c",n1,n2);
      else 
          sprintf (temp, "%d", n1);
      break;

    case EXT_AUX_REGISTER:
      type_str = type_strings[2];
      sprintf (temp, "%d", n1);
      break;

    case EXT_COND_CODE:
      type_str = type_strings[3];
      sprintf (temp, "%d", n1);
      break;

    default:
      abort ();

    } /* end switch(type) */
  sprintf (section_name, ".gnu.linkonce.arcextmap.%s.%s", type_str, temp);
  if (!symbol_find (section_name) || (n2 !=9 &&n2 !=10)){
      symbolS *sym;
      sym = (symbolS *) local_symbol_make (section_name,
                                       absolute_section, 1,
                                       &zero_address_frag);
      symbol_table_insert (sym);
      arcext_section = subseg_new (xstrdup (section_name), 0);
d392 5
a396 5
			 SEC_READONLY | SEC_HAS_CONTENTS);
      }
  else {
      use_extended_instruction_format = 2;
      }
a398 17
/* process extension condition code
 * format   .extCondCode   name,value
 *      name   is name of condition code.
 *      value  is value of condition code.
 * extension core register.
 * format   .extCoreRegister name,value,mode,shortcut
 *      name   is name of register.
 *      value  is register number.
 *      mode   is r,w,r|w,w|r or blank for Read/Write usage.
 *      shortcut  can_shortcut 
 *                cannot_shortcut
 * extension auxiliary register.
 * format    .extAuxRegister name,value,mode
 *      name   is name of register.
 *      value  is register number.
 *      r,w,r|w,w|r, or blank for Read/Write usage.
 */
a407 1
  int iregextension=0;
d432 1
a432 1
      as_bad ("expected comma after operand name");
d440 1
d443 1
a443 1
      as_bad ("negative operand number %d", number);
d455 1
a455 1
	  as_bad ("expected comma after register-number");
d464 1
a464 1
      if (!strncmp (mode, "r|w", 3) || !strncmp (mode, "w|r",3))
d480 1
a480 1
		  as_bad ("invalid mode");
d497 1
a497 1
	      as_bad ("expected comma after register-mode");
d505 1
a505 1
	  if (!strncasecmp (input_line_pointer, "cannot_shortcut", 15))
d512 1
a512 1
	      if (strncasecmp (input_line_pointer, "can_shortcut", 12))
d514 1
a514 1
		  as_bad ("shortcut designator invalid");
a523 42

	  if (*input_line_pointer == ',' )
	    {
	      input_line_pointer++;  /* skip ',' */

	      if  (!strncasecmp (input_line_pointer, "VECTOR", 6))
		{
		  imode |= ARC_REGISTER_SIMD_VR;
		  input_line_pointer +=6;
                  iregextension = 'v';
		}
	      else if (!strncasecmp (input_line_pointer, "SCALAR", 6))
		{
		  imode |= ARC_REGISTER_SIMD_I;
		  input_line_pointer +=6;
                  iregextension = 'i';
		}
	      else if (!strncasecmp (input_line_pointer, "KSCALAR", 7))
		{
		  imode |= ARC_REGISTER_SIMD_K;
		  input_line_pointer +=7;
                  iregextension = 'k';
		}
	      else if (!strncasecmp (input_line_pointer, "DMA", 3))
		{
		  imode |= ARC_REGISTER_SIMD_DR;
		  input_line_pointer +=3;
                  iregextension = 'd';
		}
              else if (!strncasecmp (input_line_pointer, "CORE", 4))
                  {
                  input_line_pointer +=4;
                  iregextension = 0;
                  }
	      else
		{
		  as_bad ("invalid register class");
		  ignore_rest_of_line ();
		  free (name);
		  return;
		}
	    }
d527 1
a527 3
  if (((opertype == 1) && number > 60)
      && (!(imode & ARC_REGISTER_SIMD_DR))
      && (!(imode & ARC_REGISTER_SIMD_VR)))
d529 1
a529 1
      as_bad ("core register value (%d) too large", number);
d537 1
a537 1
      as_bad ("condition code value (%d) too large", number);
d554 1
a554 1
	      as_bad ("attempt to override symbol: %s", name);
d584 1
a584 1

d589 8
a596 9
        arc_set_ext_seg (EXT_COND_CODE, number, 0, 0);
        p = frag_more (1);
        *p = 3 + strlen (name) + 1;
        p = frag_more (1);
        *p = EXT_COND_CODE;
        p = frag_more (1);
        *p = number;
        p = frag_more (strlen (name) + 1);
        strcpy (p, name);
d599 8
a606 69
        /* use extended format for vector registers */
        if(imode & (ARC_REGISTER_SIMD_VR | ARC_REGISTER_SIMD_I |
                    ARC_REGISTER_SIMD_K  | ARC_REGISTER_SIMD_DR)){
            arc_set_ext_seg(EXT_LONG_CORE_REGISTER, number,iregextension,0);
            p = frag_more(1);
            *p = 8+strlen(name)+1;
            p = frag_more(1);
            *p = 9;
            p = frag_more(1);
            *p = number;
            p = frag_more(1);/* first flags byte*/
            *p = 0;
            p = frag_more(1);/* second flags byte*/
            *p = 0;
            p = frag_more(1);/* third flags byte*/
            *p = 0;
            p = frag_more(1);/* fourth flags byte*/
            *p = REG_WRITE | REG_READ;
            if(imode & ARC_REGISTER_WRITEONLY)
                *p = REG_WRITE;
            if(imode & ARC_REGISTER_READONLY)
                *p = REG_READ;
            p = frag_more(1);
            *p = 'v';
            if(imode & ARC_REGISTER_SIMD_VR)
                *p = 'v';
            if(imode & ARC_REGISTER_SIMD_I)
                *p = 'i';
            if(imode & ARC_REGISTER_SIMD_K)
                *p = 'k';
            if(imode & ARC_REGISTER_SIMD_DR)
                *p = 'd';
            p = frag_more (strlen(name) + 1);
            strcpy(p,name);
            break;
            }
       /* use old format for all others */
      arc_set_ext_seg (EXT_CORE_REGISTER, number, iregextension, 0);      
      if (imode & (ARC_REGISTER_WRITEONLY | ARC_REGISTER_READONLY))
	{
	  p = frag_more (1);
	  *p = 7 + strlen (name) + 1;
	  p = frag_more (1);
	  *p = EXT_LONG_CORE_REGISTER;
	  p = frag_more (1);
	  *p = number;
	  
	  p = frag_more (3);
	  *(p + 0) = 0;
	  *(p + 1) = 0;
	  *(p + 2) = 0;
	  
	  p = frag_more (1);
	  *p = (imode == ARC_REGISTER_WRITEONLY) ? REG_WRITE : REG_READ;
	  
	  p = frag_more (strlen (name) + 1);
	  strcpy (p, name);
	}
      else
	{
	  p = frag_more (1);
	  *p = 3 + strlen (name) + 1;
	  p = frag_more (1);
	  *p = EXT_CORE_REGISTER;
	  p = frag_more (1);
	  *p = number;
	  p = frag_more (strlen (name) + 1);
	  strcpy (p, name);
	}
a608 1
      arc_set_ext_seg (EXT_AUX_REGISTER, number, 0, 0);
d625 1
a625 1
      as_bad ("invalid opertype");
a638 14
/* There are two functions which handle the parsing and encoding of the
   .extinstruction directive.  This function basically chooses between the two
   functions.  */

static void
arc_handle_extinst (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (arc_mach_a4)
    arc_extinst (ignore);
  else
    arc_ac_extinst (ignore);
}

d670 1
a670 1
      as_bad ("expected comma after operand name");
d682 1
a682 1
      as_bad ("expected comma after opcode");
d692 1
a692 1
      as_bad ("negative subopcode %d", subopcode);
d701 1
a701 1
	  as_bad ("subcode value found when opcode not equal 0x03");
d707 1
a707 1
	  if (subopcode < 0x09 || subopcode > 0x3f)
d709 1
a709 1
	      as_bad ("invalid subopcode %d", subopcode);
d720 1
a720 1
      as_bad ("expected comma after subopcode");
d739 1
a739 1
      as_bad ("invalid suffix class");
d748 1
a748 1
      as_bad ("expected comma after suffix class");
d767 1
a767 1
      as_bad ("invalid syntax class");
d774 1
a774 1
      as_bad ("opcode 0x3 and SYNTAX_3OP invalid");
d794 1
a794 1
      as_bad ("unknown suffix class");
a809 4

  if (class == (SYNTAX_2OP|OP1_IMM_IMPLIED|SYNTAX_VALID))
    ext_op->value |= A (0x3f);

d821 1
a821 3
  arc_set_ext_seg (EXT_INSTRUCTION,
		   class & (SYNTAX_3OP | SYNTAX_2OP | SYNTAX_1OP | SYNTAX_NOP),
		   opcode, subopcode);
d843 3
a845 11
/*********************************************************************/
/* Here's all the ARCompact extension instruction assembling stuff.  */
/*********************************************************************/

/* Lots of the code here needs to used for the ARCTangent .extinstruction
   directive too.  For now, both the code exists but leisurely cleanup would
   eliminate a lot of the old code.  */

/* This structure will replace suffixclass and syntaxclass.  */

struct attributes {
d847 4
a850 33
  int len;
  int class;  
  };

static const struct attributes ac_suffixclass[] = {
  { "SUFFIX_FLAG", 11, AC_SUFFIX_FLAG},
  { "SUFFIX_COND", 11, AC_SUFFIX_COND},
  { "SUFFIX_NONE", 11, AC_SUFFIX_NONE},
  { "FLAGS_NONE" , 10, AC_SIMD_FLAGS_NONE},
  { "FLAG_SET"   ,  8, AC_SIMD_FLAG_SET},
  { "FLAG1_SET"  ,  9, AC_SIMD_FLAG1_SET},
  { "FLAG2_SET"  ,  9, AC_SIMD_FLAG2_SET},
  { "ENCODE_U8"  ,  9, AC_SIMD_ENCODE_U8},
  { "ENCODE_U6"  ,  9, AC_SIMD_ENCODE_U6},
  { "SCALE_0"    ,  7, AC_SIMD_SCALE_0},
  { "SCALE_1"    ,  7, AC_SIMD_SCALE_1},
  { "SCALE_2"    ,  7, AC_SIMD_SCALE_2},
  { "SCALE_3"    ,  7, AC_SIMD_SCALE_3},
  { "SCALE_4"    ,  7, AC_SIMD_SCALE_4},
  { "ENCODE_LIMM", 11, AC_SIMD_ENCODE_LIMM},
  { "EXTENDED",     8, AC_SIMD_EXTENDED},
  { "EXTEND2",      7, AC_SIMD_EXTEND2},
  { "EXTEND3",      7, AC_SIMD_EXTEND3},
  { "SUFFIX_MASK", 11, AC_SUFFIX_LANEMASK},
  { "ENCODE_S12",  10, AC_SIMD_ENCODE_S12},
  { "ENCODE_ZEROA",12, AC_SIMD_ZERVA},
  { "ENCODE_ZEROB",12, AC_SIMD_ZERVB},
  { "ENCODE_ZEROC",12, AC_SIMD_ZERVC},
  { "ENCODE_SETLM",12, AC_SIMD_SETLM},
  { "EXTEND1",      7, AC_SIMD_EXTEND1},
  { "ENCODE_KREG", 11, AC_SIMD_KREG},
  { "ENCODE_U16", 10, AC_SIMD_ENCODE_U16}
};
d852 6
a857 1
#define AC_MAXSUFFIXCLASS (sizeof (ac_suffixclass) / sizeof (struct attributes))
d859 6
a864 30
/* remember, if any entries contain other entries as prefixes, the longer 
 * entries must be first.
 */
static const struct attributes ac_syntaxclass[] = {
  { "SYNTAX_3OP", 10, AC_SYNTAX_3OP},
  { "SYNTAX_2OP", 10, AC_SYNTAX_2OP},  
  { "SYNTAX_1OP", 10, AC_SYNTAX_1OP},
  { "SYNTAX_NOP", 10, AC_SYNTAX_NOP},
  { "SYNTAX_VbI0"     , 11, AC_SIMD_SYNTAX_VbI0},
  { "SYNTAX_Vb00"     , 11, AC_SIMD_SYNTAX_Vb00},
  { "SYNTAX_VbC0"     , 11, AC_SIMD_SYNTAX_VbC0},
  { "SYNTAX_VVV"      , 10, AC_SIMD_SYNTAX_VVV},
  { "SYNTAX_VV0"      , 10, AC_SIMD_SYNTAX_VV0},
  { "SYNTAX_V00"      , 10, AC_SIMD_SYNTAX_V00},
  { "SYNTAX_VC0"      , 10, AC_SIMD_SYNTAX_VC0},
  { "SYNTAX_VVC"      , 10, AC_SIMD_SYNTAX_VVC},
  { "SYNTAX_VVI"      , 10, AC_SIMD_SYNTAX_VVI},
  { "SYNTAX_VVL"      , 10, AC_SIMD_SYNTAX_VVL},
  { "SYNTAX_VU0"      , 10, AC_SIMD_SYNTAX_VU0},
  { "SYNTAX_VL0"      , 10, AC_SIMD_SYNTAX_VL0},
  { "SYNTAX_C00"      , 10, AC_SIMD_SYNTAX_C00},
  { "SYNTAX_VV"       ,  9, AC_SIMD_SYNTAX_VV},
  { "SYNTAX_CC"       ,  9, AC_SIMD_SYNTAX_CC},
  { "SYNTAX_C0"       ,  9, AC_SIMD_SYNTAX_C0},
  { "SYNTAX_DC"       ,  9, AC_SIMD_SYNTAX_DC},
  { "SYNTAX_D0"       ,  9, AC_SIMD_SYNTAX_D0},
  { "SYNTAX_VD"       ,  9, AC_SIMD_SYNTAX_VD},
  { "SYNTAX_C"        ,  8, AC_SIMD_SYNTAX_C},
  { "SYNTAX_0"        ,  8, AC_SIMD_SYNTAX_0}
};
d866 2
a867 1
#define AC_MAXSYNTAXCLASS (sizeof (ac_syntaxclass) / sizeof (struct attributes))
d869 6
a874 39
static const struct attributes ac_syntaxclassmodifier[] = {
  { "OP1_DEST_IGNORED", 16, AC_OP1_DEST_IGNORED},
  { "OP1_IMM_IMPLIED" , 15, AC_OP1_IMM_IMPLIED},
  { "OP1_MUST_BE_IMM" , 15, AC_OP1_MUST_BE_IMM},
  { "SYNTAX_DISC"     , 11, AC_SIMD_SYNTAX_DISC},
  { "SYNTAX_IREGA"    , 12, AC_SIMD_IREGA},
  { "SYNTAX_IREGB"    , 12, AC_SIMD_IREGB}
  };

#define AC_MAXSYNTAXCLASSMODIFIER (sizeof (ac_syntaxclassmodifier) / sizeof (struct attributes))

/* This macro takes the various fields of a 32-bit extension instruction and
   builds the instruction word.  */
#define INSN_32(m,i,p,a,b,c)	(((m & 0x1f) << 27) | \
				 ((i & 0x3f) << 16) | \
				 ((p & 0x03) << 22) | \
				 ((a & 0x3f) << 0)  | \
				 ((b & 0x07) << 24) | \
				 ((b & 0x38) << 9)  | \
				 ((c & 0x3f) << 6))

/* This macro takes the various fields of a 16-bit extension instruction and
   builds the instruction word.  */
#define INSN_16(I,b,c,i)	(((I & 0x1f) << 11) | \
				 ((b & 0x07) << 8)  | \
				 ((c & 0x07) << 5)  | \
				 ((i & 0x1f) << 0))

/* This macro plugs in the I-field into a 32-bit instruction.  There are two
   definitions here.  The first one is in accordance with the ARCompact
   Programmer's Reference while the other is what Metaware does and what
   seems to be the more correct thing to do.  */
#ifndef UNMANGLED
#define I_FIELD(x,i)		((( x << 1) & (64 - (1 << i)))  | \
				 ( x & (i - 1))			| \
				 ((x & 0x20) >> (6 - i)))
#else
#define I_FIELD(x,i)		(x & 0x3f)
#endif
d876 1
a876 1689
/* This function generates the list of extension instructions.  The last
   argument is used to append a .f or a .cc to the instruction name.  */
static void
arc_add_ext_inst (char *name, char *operands, unsigned long value,
		  unsigned long mask ATTRIBUTE_UNUSED, unsigned flags, unsigned suffix)
{
  char realsyntax[160];
  struct arc_opcode *ext_op;
  
  ext_op = (struct arc_opcode *) xmalloc (sizeof (struct arc_opcode));

  strcpy (realsyntax,name);
  
  if(suffix & AC_SUFFIX_COND){
    strcat(realsyntax,"%.q");
      }
    
  if(suffix & AC_SUFFIX_FLAG){
    strcat(realsyntax,"%.f");
      }

  strcat (realsyntax,operands);
  
  flags = flags & ~(ARC_SIMD_ZERVA|ARC_SIMD_ZERVB|ARC_SIMD_ZERVC|
                     ARC_SIMD_SETLM);
  if(suffix&AC_SIMD_ZERVA)
      flags |= ARC_SIMD_ZERVA;
  if(suffix&AC_SIMD_ZERVB){
      flags |= ARC_SIMD_ZERVB;
      }
  if(suffix&AC_SIMD_ZERVC)
      flags |= ARC_SIMD_ZERVC;
  if(suffix&AC_SIMD_SETLM)
      flags |= ARC_SIMD_SETLM;
  
  ext_op->syntax = xstrdup (realsyntax);
  ext_op->value = value;
  ext_op->flags = flags | ARCOMPACT ;
  ext_op->next_asm = arc_ext_opcodes;
  ext_op->next_dis = arc_ext_opcodes;
  arc_ext_opcodes = ext_op;
}
/* This function generates the list of extension instructions.  The last
   argument is used to append a .f or a .cc to the instruction name.  */
static void
arc_add_long_ext_inst (char *name, char *operands, unsigned long value,
		  unsigned long mask ATTRIBUTE_UNUSED, unsigned long value2,
                       unsigned long mask2 ATTRIBUTE_UNUSED, 
                       unsigned long flags, unsigned long suffix)
{
  char realsyntax[160];
  struct arc_opcode *ext_op;
  
  ext_op = (struct arc_opcode *) xmalloc (sizeof (struct arc_opcode));

  strcpy (realsyntax,name);

  if(suffix & AC_SUFFIX_COND){
    strcat(realsyntax,"%.q");
      }
    
  if(flags & ARC_SIMD_LANEMASK){
      strcat(realsyntax,"%.]");
      }
  
  if(suffix & AC_SUFFIX_FLAG){
    strcat(realsyntax,"%.f");
      }

  strcat (realsyntax,operands);
  
  flags = flags & ~(ARC_SIMD_ZERVA | ARC_SIMD_ZERVB | ARC_SIMD_ZERVC|
                     ARC_SIMD_SETLM);
  if(suffix & AC_SIMD_ZERVA)
      flags |= ARC_SIMD_ZERVA;
  if(suffix & AC_SIMD_ZERVB){
      flags |= ARC_SIMD_ZERVB;
      }
  if(suffix & AC_SIMD_ZERVC)
      flags |= ARC_SIMD_ZERVC;
  if(suffix & AC_SIMD_SETLM)
      flags |= ARC_SIMD_SETLM;

  ext_op->syntax = xstrdup (realsyntax);
  ext_op->value = value;
  ext_op->value2 = value2;
  ext_op->flags = flags | ARCOMPACT | SIMD_LONG_INST;
  ext_op->next_asm = arc_ext_opcodes;
  ext_op->next_dis = arc_ext_opcodes;
  arc_ext_opcodes = ext_op;
}

/* This function generates the operand strings based on the syntax class and
 *  syntax class modifiers and does some error checking.  
 * instruction name      name of instruction.
 * major-opcode          five bit major opcode.
 * sub_opcode            sub operation code. If long simd we also pack in
 *                         a mode and two other sub op code.
 *                       a3322ss
 *                       a is accumulation mode in second word of long form.
 *                       3 is third op-code which goes in operand b
 *                       2 is second op-code which goes in operand a
 *                       s is sub op-code in sub op-code field.
 * syntax_class          or'd syntax class flags.
 * syntax_class_modifiers  or'd syntax modifier flags.
 * suffix_class          or'd suffix class flags.
 * returns               number of operands.
 */
static int
arc_generate_extinst32_operand_strings (char *instruction_name,
					unsigned char major_opcode,
					unsigned long sub_opcode,
					unsigned long syntax_class,
					unsigned long syntax_class_modifiers,
					unsigned long suffix_class)
{
  char op1[6], op2[6], op3[6], operand_string[18];
  unsigned long xmitsuffix;
  char suffixstr[10];
  int nop = 0;
  int i;
  unsigned long insn,mask,insn2,mask2;
  /* The ARCompact reference manual states this range to be 0x04 to 0x07
     but this is the correct thing.  */
  if((major_opcode > 0x0a) || (major_opcode < 0x04))
    {
      as_bad ("major opcode not in range [0x04-0x0a]");
      ignore_rest_of_line ();
      return 0;
    }

  if(sub_opcode > 0x3f&&major_opcode!=0x0a&&major_opcode!=5&&major_opcode!=9)
    {
      as_bad ("sub opcode not in range [0x00-0x3f]");
      ignore_rest_of_line ();
      return 0;
    }
  switch(syntax_class &
	 (AC_SYNTAX_3OP | AC_SYNTAX_2OP | AC_SYNTAX_1OP | AC_SYNTAX_NOP
	  | AC_SYNTAX_SIMD))
    {
    case AC_SYNTAX_3OP:
      
      if(suffix_class & AC_SUFFIX_COND)
	{
	  arc_add_ext_inst (instruction_name, " 0,%L,%L%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    3, 0, 62, 62),
			    INSN_32(-1,-1,-1,32,-1,-1),
			    syntax_class | syntax_class_modifiers,
			    suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND));
	  
	  arc_add_ext_inst (instruction_name, " 0,%L,%u%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    3, 32, 62, 0),
			    INSN_32(-1,-1,-1,32,-1,0),
			    syntax_class | syntax_class_modifiers,
			    suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND));
	  
	  arc_add_ext_inst (instruction_name, " 0,%L,%C%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    3, 0, 62, 0),
			    INSN_32(-1,-1,-1,32,-1,0),
			    syntax_class | syntax_class_modifiers,
			    suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND));
	  
	  if(!(syntax_class_modifiers & AC_OP1_MUST_BE_IMM))
	    {
	      arc_add_ext_inst (instruction_name, "%Q %#,%B,%L%F",
				INSN_32(major_opcode,
					I_FIELD(sub_opcode, 1),
					3, 0, 0, 62),
				INSN_32(-1,-1,-1,0,0,0),
				(syntax_class | syntax_class_modifiers),
				suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND));
	      
	      arc_add_ext_inst (instruction_name, " %#,%B,%u%F",
				INSN_32(major_opcode,
					I_FIELD(sub_opcode, 0),
					3, 32, 0, 0),
				INSN_32(-1,-1,-1,32,0,0),
				(syntax_class | syntax_class_modifiers),
				suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND));
	      
	      arc_add_ext_inst (instruction_name, " %#,%B,%C%F",
				INSN_32(major_opcode,
					I_FIELD(sub_opcode, 1),
					3, 0, 0, 0),
				INSN_32(-1,-1,-1,0,0,0),
				(syntax_class | syntax_class_modifiers),
				suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND));
	    }
	}
      
      if(!(syntax_class_modifiers & AC_OP1_MUST_BE_IMM))
	{
	  
	  arc_add_ext_inst (instruction_name, "%Q %A,%B,%L%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    0, 0, 0, 62),
			    INSN_32(-1,-1,-1,0,0,-1),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
	  
	  arc_add_ext_inst (instruction_name, " %#,%B,%K%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    2, 0, 0, 0),
			    INSN_32(-1,-1,-1,0,0,0),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
	  
	  arc_add_ext_inst (instruction_name, " %A,%B,%u%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 2),
				    1, 0, 0, 0),
			    INSN_32(-1,-1,-1,0,0,0),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
	  
	  arc_add_ext_inst (instruction_name, " %A,%B,%C%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    0, 0, 0, 0),
			    INSN_32(-1,-1,-1,0,0,0),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
	  
	  arc_add_ext_inst (instruction_name, "%Q %A,%L,%L%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    0, 0, 62, 62),
			    INSN_32(-1,-1,-1,0,-1,-1),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
	  
	  arc_add_ext_inst (instruction_name, "%Q %A,%L,%u%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 2),
				    1, 0, 62, 0),
			    INSN_32(-1,-1,-1,0,-1,-1),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
	  
	  arc_add_ext_inst (instruction_name, "%Q %A,%L,%C%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    0, 0, 62, 0),
			    INSN_32(-1,-1,-1,0,-1,0),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
	}

      arc_add_ext_inst (instruction_name, "%Q 0,%L,%L%F",
			INSN_32(major_opcode,
				I_FIELD(sub_opcode, 1),
				0, 62, 62, 62),
			INSN_32(-1,-1,-1,-1,-1,-1),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, "%Q 0,%L,%K%F",
			INSN_32(major_opcode,
				I_FIELD(sub_opcode, 1),
				2, 0, 62, 0),
			INSN_32(-1,-1,-1,0,-1,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, "%Q 0,%L,%u%F",
			INSN_32(major_opcode,
				I_FIELD(sub_opcode, 2),
				1, 62, 62, 0),
			INSN_32(-1,-1,-1,-1,-1,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " 0,%L,%C%F",
			INSN_32(major_opcode,
				I_FIELD(sub_opcode, 1),
				0, 62, 62, 0),
			INSN_32(-1,-1,-1,0,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, "%Q 0,%B,%L%F",
			INSN_32(major_opcode,
				I_FIELD(sub_opcode, 1),
				0, 62, 0, 62),
			INSN_32(-1,-1,-1,-1,0,-1),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " 0,%B,%u%F",
			INSN_32(major_opcode,
				I_FIELD(sub_opcode, 2),
				1, 62, 0, 0),
			INSN_32(-1,-1,-1,0,-1,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));

      arc_add_ext_inst (instruction_name, " 0,%B,%K%F",
			INSN_32(major_opcode,
				I_FIELD(sub_opcode, 2),
				1, 62, 0, 0),
			INSN_32(-1,-1,-1,0,-1,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " 0,%B,%C%F",
			INSN_32(major_opcode,
				I_FIELD(sub_opcode, 1),
				0, 62, 0, 0),
			INSN_32(-1,-1,-1,0,-1,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      break;
      
    case AC_SYNTAX_2OP:
      if (sub_opcode == 0x3f)
	{
	  as_bad ("Subopcode 0x3f not allowed with SYNTAX_2OP\n");
	}

      arc_add_ext_inst (instruction_name, "%Q %L,%u%F",
			INSN_32(major_opcode,
				0x2f,
				1, sub_opcode, 62, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, "%Q %L,%C%F",
			INSN_32(major_opcode,
				0x2f,
				0, sub_opcode, 62, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, "%Q %B,%L%F",
			INSN_32(major_opcode,
				0x2f,
				0, sub_opcode, 0, 62),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " %B,%u%F",
			INSN_32(major_opcode,
				0x2f,
				1, sub_opcode, 0, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " %B,%C%F",
			INSN_32(major_opcode,
				0x2f,
				0, sub_opcode, 0, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, "%Q 0,%L%F",
			INSN_32(major_opcode,
				0x2f,
				0, sub_opcode, 62, 62),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " 0,%u%F",
			INSN_32(major_opcode,
				0x2f,
				1, sub_opcode, 62, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " 0,%C%F",
			INSN_32(major_opcode,
				0x2f,
				0, sub_opcode, 62, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));

      if (syntax_class_modifiers & AC_OP1_IMM_IMPLIED)
      {
	  
	  if(suffix_class & AC_SUFFIX_COND)
	  {
	      arc_add_ext_inst (instruction_name, "%Q %L,%C%F",
				INSN_32(major_opcode,
					I_FIELD(sub_opcode, 1),
					3, 0, 62, 0),
				INSN_32(-1,-1,-1,32,-1,0),
				syntax_class | syntax_class_modifiers,
				suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND));
	  
	      arc_add_ext_inst (instruction_name, "%Q %L,%u%F",
				INSN_32(major_opcode,
					I_FIELD(sub_opcode, 1),
					3, 32, 62, 0),
				INSN_32(-1,-1,-1,32,-1,0),
				syntax_class | syntax_class_modifiers,
				suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND));
	  }
      
	  arc_add_ext_inst (instruction_name, "%Q %L,%u%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 2),
				    1, 62, 62, 0),
			    INSN_32(-1,-1,-1,-1,-1,0),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));

	  arc_add_ext_inst (instruction_name, "%Q %B,%L%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    0, 62, 0, 62),
			    INSN_32(-1,-1,-1,-1,0,-1),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
      
	  arc_add_ext_inst (instruction_name, " %B,%u%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 2),
				    1, 62, 0, 0),
			    INSN_32(-1,-1,-1,0,-1,0),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));

	  arc_add_ext_inst (instruction_name, " %B,%K%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 2),
				    1, 62, 0, 0),
			    INSN_32(-1,-1,-1,0,-1,0),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
      
	  arc_add_ext_inst (instruction_name, " %B,%C%F",
			    INSN_32(major_opcode,
				    I_FIELD(sub_opcode, 1),
				    0, 62, 0, 0),
			    INSN_32(-1,-1,-1,0,-1,0),
			    (syntax_class | syntax_class_modifiers),
			    suffix_class & (AC_SUFFIX_FLAG));
      }
      
      break;
      
    case AC_SYNTAX_1OP:
      
      arc_add_ext_inst (instruction_name, "%Q %L%F",
			INSN_32(major_opcode,
				0x2f,
				0, 0x3f, sub_opcode, 62),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " %u%F",
			INSN_32(major_opcode,
				0x2f,
				1, 0x3f, sub_opcode, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      
      arc_add_ext_inst (instruction_name, " %C%F",
			INSN_32(major_opcode,
				0x2f,
				0, 0x3f, sub_opcode, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      break;
      
    case AC_SYNTAX_NOP:
      
      /* FIXME: The P field need not be 1 necessarily. The value to be
       * plugged in will depend on the final ABI statement for the same */
      arc_add_ext_inst (instruction_name, "%F",
			INSN_32(major_opcode,
				0x2f,
				1, 0x3f, sub_opcode, 0),
			INSN_32(-1,-1,-1,-1,0,0),
			(syntax_class | syntax_class_modifiers),
			suffix_class & (AC_SUFFIX_FLAG));
      break;
    case AC_SYNTAX_SIMD:
      op1[0] = op2 [0] = op3[0] = operand_string[0] = '\0';
      nop = 0;
      suffixstr[0] = '\0';
      use_extended_instruction_format = 1;
      for(i = 0; i < RCLASS_SET_SIZE; i++)
          extended_register_format[i] = 0;
      for(i = 0; i < OPD_FORMAT_SIZE; i++){
          extended_operand_format1[i] = 0;
          extended_operand_format2[i] = 0;
          extended_operand_format3[i] = 0;
          }
      for(i = 0; i < 4; i++)
          extended_instruction_flags[i] = 0;
      switch (syntax_class
	      & (AC_SIMD_SYNTAX_VVV | AC_SIMD_SYNTAX_VV | AC_SIMD_SYNTAX_VV0
		 | AC_SIMD_SYNTAX_VbI0 | AC_SIMD_SYNTAX_Vb00
		 | AC_SIMD_SYNTAX_V00 | AC_SIMD_SYNTAX_0 |AC_SIMD_SYNTAX_C00
		 | AC_SIMD_SYNTAX_C0  | AC_SIMD_SYNTAX_D0 | AC_SIMD_SYNTAX_VD))
	{
	case AC_SIMD_SYNTAX_VVV:
          extended_register_format[0] = 'v';
          extended_register_format[1] = 'v';
          extended_register_format[2] = 'v';
          strcpy (op1, " %*,");
          if(syntax_class_modifiers & AC_SIMD_IREGA){
              if(suffix_class & AC_SIMD_KREG){
                  extended_register_format[0] = 'k';
                  strcpy(op1," %\15,");}
              else {
                  extended_register_format[0] = 'i';
                  strcpy(op1," %\13,");}
              }
          if(suffix_class & AC_SIMD_ZERVA)
              strcpy(op1," %\23,");
	  strcpy (op2, "%(,");
	  strcpy (op3, "%)");
          if(syntax_class & AC_SIMD_SYNTAX_VVI){
              if(suffix_class & AC_SIMD_KREG){
                  extended_register_format[2] = 'k';
                  strcpy(op3, "%\17");}
              else {
                  extended_register_format[2] = 'i';
                  strcpy(op3, "%}");}
              }
          if(syntax_class & AC_SIMD_SYNTAX_VVL){
              extended_register_format[2] = '0';
              strcpy(op3,"%\24");
              suffix_class |= AC_SIMD_ZERVC;
              }
	  nop = 3;
	  break;
	case AC_SIMD_SYNTAX_VV:
	  strcpy (op1, " %(");
          extended_register_format[0] = 'v';
          extended_register_format[1] = 'v';
          if(suffix_class & AC_SIMD_EXTEND3){
              strcpy (op1, " %)");
              nop=1;
              break;
              }
          if(suffix_class & AC_SIMD_ZERVB)
              strcpy (op1, " %\23");
	  strcpy (op2, ",%)");
          if(syntax_class & AC_SIMD_SYNTAX_VVL){
              extended_register_format[1] = '0';
              strcpy(op2, ",%\24");
              suffix_class |= AC_SIMD_ZERVC;
              }
	  nop = 2;
	  break;
	case AC_SIMD_SYNTAX_VV0:
            extended_register_format[0] = 'v';
            extended_register_format[1] = 'v';
            if(suffix_class & AC_SIMD_EXTEND2){
                strcpy(op1," %(,");
                if(syntax_class_modifiers & AC_SIMD_IREGB){
                    if(suffix_class & AC_SIMD_KREG){
                        extended_register_format[0] = 'k';
                        strcpy(op1," %\16,");}
                    else {
                        extended_register_format[0] = 'i';
                        strcpy(op1," %{,");}
                    }
                if(suffix_class & AC_SIMD_ZERVB)
                    strcpy(op1," %\23,");
                strcpy(op2,"%)");
                if(syntax_class & AC_SIMD_SYNTAX_VVI){
                    if(suffix_class & AC_SIMD_KREG){
                        extended_register_format[1] = 'k';
                        strcpy(op2,"%\17");}
                    else {
                        extended_register_format[1] = 'i';
                        strcpy(op2,"%}");}
                    }
                if(suffix_class & AC_SIMD_ENCODE_U6){
                    extended_register_format[1] = '0';
                    strcpy(op2,"%u");
                    }
                if(suffix_class & AC_SIMD_ENCODE_U16){
                    extended_register_format[1] = '0';
                    strcpy(op2,"%\20");
                    }
                if(suffix_class & AC_SIMD_ENCODE_U8){
                    extended_register_format[1] = '0';
                    strcpy(op2,"%?");
                    }
                if(syntax_class & AC_SIMD_SYNTAX_VVL){
                    extended_register_format[1] = '0';
                    strcpy(op2,"%\24");
                    suffix_class |= AC_SIMD_ZERVC;
                    }
                if(syntax_class & AC_SIMD_SYNTAX_VVC){
                    extended_register_format[1] = 'c';
                    strcpy(op2,"%C");
                    }
                nop = 2;
                break;
                }
            else 
                {
                strcpy (op1, " %*,");
                if(syntax_class_modifiers & AC_SIMD_IREGA){
                    if(suffix_class & AC_SIMD_KREG){
                        extended_register_format[0] = 'k';
                        strcpy(op1," %\15,");}
                    else {
                        extended_register_format[0] = 'i';
                        strcpy(op1," %\13,");}
                    }
                if(suffix_class & AC_SIMD_ZERVA)
                    strcpy(op1, " %\23,");
                strcpy (op2, "%(,");
                strcpy(op3,"");
                switch  (syntax_class
                         & (AC_SIMD_SYNTAX_VVC | AC_SIMD_SYNTAX_VVI | AC_SIMD_SYNTAX_VVL))
                    {
                    case AC_SIMD_SYNTAX_VVC:
                        extended_register_format[2] = 'c';
                        strcpy (op3, "%C");
                        break;
                    case AC_SIMD_SYNTAX_VVI:
                        if(suffix_class & AC_SIMD_KREG){
                            extended_register_format[2] = 'k';
                            strcpy (op3, "%\17");}
                        else {
                            extended_register_format[2] = 'i';
                            strcpy (op3, "%}");}
                        break;
                    case AC_SIMD_SYNTAX_VVL:
                        extended_register_format[2] = '0';
                        strcpy(op3,"%L");
                        if(suffix_class & AC_SIMD_EXTENDED)
                            strcpy(op3,"%\24");
                        suffix_class |= AC_SIMD_ZERVC;
                        break;
                    default:
                        if (suffix_class & AC_SIMD_ENCODE_U8){
                            extended_register_format[2] = '0';
                            strcpy (op3, "%?");}
                        else if ( suffix_class & AC_SIMD_ENCODE_U6) {
                            extended_register_format[2] = '0';
                            strcpy (op3, "%u"); }
                        else if ( suffix_class & AC_SIMD_ENCODE_U16) {
                            extended_register_format[2] = '0';
                            strcpy (op3, "%\20");}
                        break;
                    }
                if(strcmp(op3,"")!=0)
                    nop = 3;
                else
                    nop = 2;
                }
	  break;

	case AC_SIMD_SYNTAX_VbI0:
          extended_register_format[0] = 'v';
          extended_register_format[1] = 'i';
          extended_register_format[2] = '0';
	  strcpy (op1, " %*,");
          if(suffix_class & AC_SIMD_KREG){
              extended_register_format[1] = 'k';
              strcpy (op2, "%\16,");}
          else
              strcpy (op2, "%{,");
	  if (suffix_class & AC_SIMD_ENCODE_U6)
	    strcpy (op3, "%u");
	  if (suffix_class & AC_SIMD_ENCODE_U8)
	    strcpy (op3, "%?");
	  if (suffix_class & AC_SIMD_ENCODE_S12)
	    strcpy (op3, "%\14");
	  nop = 3;
	  if (!strcmp(op3,""))//temp .. please remove
	    printf("SYNTAX_VbI0 op3 not found:%s\n",instruction_name); 
	  break;

	case AC_SIMD_SYNTAX_Vb00:
          extended_register_format[0] = 'v';
          extended_register_format[0] = 'i';
          extended_register_format[0] = '0';
	  strcpy (op1, " %*,");
          if(suffix_class & AC_SIMD_KREG){
              extended_register_format[1] = 'k';
              strcpy(op2,"%\16");}
          else
              strcpy(op2,"%{");
	  if (syntax_class & AC_SIMD_SYNTAX_VbC0){
              extended_register_format[1] = 'c';
              strcpy (op2, "%B");
              }
 	  if (suffix_class & AC_SIMD_ENCODE_U8) 
 	    strcpy (op3, ",%?"); 
 	  if (suffix_class & AC_SIMD_ENCODE_S12) 
 	    strcpy (op3, ",%\14"); 
          if(strcmp(op3,"")!=0)
              nop =3;
          else {
              extended_register_format[2] = 0;
              nop = 2;
              }
	  break;

	case AC_SIMD_SYNTAX_V00:
            extended_register_format[0] = 'v';
            extended_register_format[1] = '0';
            if((suffix_class & AC_SIMD_EXTEND2) || (suffix_class & AC_SIMD_EXTEND3)){
                strcpy(op1," %(,");
                if(suffix_class & AC_SIMD_ZERVB){
                    strcpy(op1," %\23,");
                    }
                strcpy(op2,"%u");
                if(syntax_class_modifiers & AC_SIMD_IREGA){
                    if(suffix_class & AC_SIMD_KREG){
                        extended_register_format[1] = 'k';
                        strcpy(op2,"%\17");}
                    else {
                        extended_register_format[1] = 'i';
                        strcpy(op2,"%}");}
                    }
                if(syntax_class&AC_SIMD_SYNTAX_VC0)
                    strcpy(op2,"%C");
                if(suffix_class&AC_SIMD_ENCODE_LIMM)
                    strcpy(op2,"%L");
                if(suffix_class & AC_SIMD_ENCODE_S12)
                    strcpy(op2,"%\14");
                nop = 2;
                }
            else
                {
                strcpy (op1, " %*,");
                if(syntax_class_modifiers & AC_SIMD_IREGA){
                    if(suffix_class & AC_SIMD_KREG){
                        extended_register_format[0] = 'k';
                        strcpy(op1, " %\15,");}
                    else {
                        extended_register_format[0] = 'i';
                        strcpy(op1, " %\13,");}
                    }
                if(suffix_class & AC_SIMD_ZERVA){
                    strcpy(op1," %\23,");
                    }

                extended_register_format[2] = '0';
                if (suffix_class & AC_SIMD_ENCODE_U8)
                    strcpy (op3, "%?");
                if(suffix_class & AC_SIMD_ENCODE_U6)
                    strcpy(op3, "%u");
                if(suffix_class & AC_SIMD_ENCODE_U16)
                    strcpy(op3, "%\20");
                if(suffix_class &AC_SIMD_ENCODE_LIMM)
                    strcpy(op3, "%L");
                if(syntax_class & AC_SIMD_SYNTAX_VVC){
                    extended_register_format[1] = 'c';
                    strcpy(op3, "%C");
                    }
                if(suffix_class & AC_SIMD_ENCODE_S12)
                    strcpy(op3,"%\14");
                if(strcmp(op3,"")==0){
                    extended_register_format[1] = '0';
                    if (syntax_class & AC_SIMD_SYNTAX_VC0){
                        extended_register_format[1] = 'c';
                        strcpy (op2, "%B");
                        }
                    if(syntax_class & AC_SIMD_SYNTAX_VU0)
                        strcpy(op2, "%u");
                    if(syntax_class & AC_SIMD_SYNTAX_VL0)
                        strcpy(op2, "%L");
                    if(syntax_class_modifiers & AC_SIMD_IREGB){
                        if(suffix_class & AC_SIMD_KREG){
                            extended_register_format[1] = 'k';
                            strcpy(op2, "%\16");}
                        else {
                            extended_register_format[1] = 'i';
                            strcpy(op2, "%{");}
                        }
                    if(suffix_class & AC_SIMD_ENCODE_S12)
                        strcpy(op2,"%\14");
                    nop = 2;
                    }
                else
                    {
                    if (syntax_class & AC_SIMD_SYNTAX_VC0){
                        extended_register_format[1] = 'c';
                        strcpy (op2, "%B,");
                        }
                    if(syntax_class & AC_SIMD_SYNTAX_VU0){
                        extended_register_format[1] = '0';
                        strcpy(op2, "%u,");
                        }
                    if(syntax_class & AC_SIMD_SYNTAX_VL0){
                        extended_register_format[1] = '0';
                        strcpy(op2, "%L,");
                        suffix_class |= AC_SIMD_ZERVB;
                        }
                    if(syntax_class_modifiers & AC_SIMD_IREGB){
                        if(suffix_class & AC_SIMD_KREG){
                            extended_register_format[1] = 'k';
                            strcpy(op2, "%\16,");}
                        else {
                            extended_register_format[1] = 'i';
                            strcpy(op2, "%{,");}
                        }
                    nop = 3;
                    }

                if(!strcmp(op2,""))
                    printf ("SYNTAX_v00 .. unknown op2:%s\n",instruction_name);
                }
	  break;
        case AC_SIMD_SYNTAX_C00:
            extended_register_format[0] = 'c';
            if(suffix_class & AC_SIMD_EXTEND2){
                strcpy(op1," %B");
                if(syntax_class_modifiers & AC_SIMD_IREGB){
                    if(suffix_class & AC_SIMD_KREG){
                        extended_register_format[0] = 'k';
                        strcpy(op1," %\16");}
                    else {
                        extended_register_format[0] = 'i';
                        strcpy(op1," %{");}
                    }
                if(syntax_class & AC_SIMD_SYNTAX_VVI){
                    if(suffix_class & AC_SIMD_KREG){
                        extended_register_format[1] = 'k';
                        strcpy(op2,",%\17");}
                    else {
                        extended_register_format[1] = 'i';
                        strcpy(op2,",%}");}
                    }
                extended_register_format[1] = '0';
                if(syntax_class& AC_SIMD_SYNTAX_VVC){
                    extended_register_format[1] = 'c';
                    strcpy(op2,",%C");
                    }
                if (suffix_class & AC_SIMD_ENCODE_U8)
                    strcpy (op2, ",%?");
                if(suffix_class & AC_SIMD_ENCODE_U6)
                    strcpy(op2,",%u");
                if(suffix_class & AC_SIMD_ENCODE_U16)
                    strcpy(op2,",%\20");
                if(syntax_class & AC_SIMD_SYNTAX_VL0)
                    strcpy(op2,",%L");
                nop = 2;
                break;
                }
            strcpy(op1," %A,");
            extended_register_format[0] = 'c';
            if(syntax_class_modifiers & AC_SIMD_IREGA){
                if(suffix_class & AC_SIMD_KREG){
                    extended_register_format[0] = 'k';
                    strcpy(op1, " %\15,");}
                else {
                    extended_register_format[0] = 'i';
                    strcpy(op1, " %\13,"); }
                }
            strcpy(op2,"%B,");
            extended_register_format[1] = 'c';
            if(syntax_class_modifiers & AC_SIMD_IREGB){
                if(suffix_class & AC_SIMD_KREG){
                    extended_register_format[1] = 'k';
                    strcpy(op2,"%\16,");}
                else {
                    extended_register_format[2] = 'i';
                    strcpy(op2,"%{,");}
                }
            extended_register_format[2] = 'c';
            if (suffix_class & AC_SIMD_ENCODE_U8)
                strcpy (op3, "%?");
            if(suffix_class & AC_SIMD_ENCODE_U6)
                strcpy(op3,"%u");
            if(suffix_class & AC_SIMD_ENCODE_U16)
                strcpy(op3,"%\20");
            if(suffix_class & AC_SIMD_ENCODE_S12)
                strcpy(op3,"%\14");
            nop = 3;
            break;
	case AC_SIMD_SYNTAX_0:
            extended_register_format[0] = '0';
            if (syntax_class & AC_SIMD_SYNTAX_C){
                extended_register_format[0] = 'c';
                strcpy (op1, " %C");
                }
            else if (suffix_class & AC_SIMD_ENCODE_U6)
                strcpy (op1, " %u");
            else if (suffix_class & AC_SIMD_ENCODE_U16)
                strcpy (op1, " %\20");
            else if (syntax_class & AC_SIMD_SYNTAX_VVI){
                if(suffix_class & AC_SIMD_KREG){
                    extended_register_format[0] = 'k';
                    strcpy (op1, " %\17");}
                else {
                    extended_register_format[0] = 'i';
                    strcpy (op1, " %}");}
                }
            if(strcmp(op1,""))
                nop = 1;
            else
                nop = 0;
	  break;


	case AC_SIMD_SYNTAX_C0:
/* special case of instruction with two constant 8 bit operands fitting 
 * into sixteen bit constant field 
 */
            extended_register_format[0] = '0';
            extended_register_format[1] = '0';

            if((suffix_class & AC_SIMD_ENCODE_U6) &&
               (suffix_class & AC_SIMD_ENCODE_U16)){
                strcpy(op1," %\21");
                strcpy(op2,",%\22");
                nop = 2;
                break;
                }
            strcpy (op1, " %B,");
            extended_register_format[0] = 'c';
            if(syntax_class_modifiers & AC_SIMD_SYNTAX_DISC){
                extended_register_format[0] = '0';
                strcpy(op1, " %u,");
                }
            if(syntax_class_modifiers & AC_SIMD_IREGB){
                if(suffix_class & AC_SIMD_KREG){
                    extended_register_format[0] = 'k';
                    strcpy(op1, " %\16,");}
                else {
                    extended_register_format[0] = 'i';
                    strcpy(op1, " %{,"); }
                }
            if (syntax_class & AC_SIMD_SYNTAX_CC){
                extended_register_format[1] = 'c';
                strcpy (op2, "%C");
                }
            if(syntax_class & AC_SIMD_SYNTAX_VVI){
                if(suffix_class & AC_SIMD_KREG){
                    extended_register_format[1] = 'k';
                    strcpy(op2, "%\17");}
                else {
                    extended_register_format[1] = 'i';
                    strcpy(op2, "%}");}
                }
            if(suffix_class & AC_SIMD_ENCODE_U6){
                extended_register_format[1] = '0';
                strcpy(op2,"%u");
                }
            if(suffix_class & AC_SIMD_ENCODE_U16){
                extended_register_format[1] = '0';
                strcpy(op2,"%\20");
                }
            if(suffix_class & AC_SIMD_ENCODE_U8){
                extended_register_format[1] = '0';
                strcpy(op2,"%?");
                }
            if(suffix_class & AC_SIMD_ENCODE_LIMM){
                strcpy(op2,"%L");
                extended_register_format[1] = '0';
                }
            nop = 2;
            if (!strcmp(op2,""))
                printf("SYNTAX_C0 op2 not found:%s\n",instruction_name); 

	  break;


	case AC_SIMD_SYNTAX_D0:
            extended_register_format[0] = 'd';
	  strcpy (op1, " %<,");
	  if (syntax_class & AC_SIMD_SYNTAX_CC){
                extended_register_format[0] = 'c';
                strcpy (op1, " %B,");
              }
	  if (syntax_class & AC_SIMD_SYNTAX_DC){
              extended_register_format[1] = 'c';
              strcpy (op2, "%C");
              }
	  if (syntax_class & AC_SIMD_SYNTAX_VVI){
              if(suffix_class & AC_SIMD_KREG){
                  extended_register_format[1] = 'k';
                  strcpy (op2, "%\17");}
              else {
                  extended_register_format[1] = 'i';
                  strcpy (op2, "%}");}
              }
          if(syntax_class & AC_SIMD_SYNTAX_VL0){
              extended_register_format[1] = '0';
              strcpy(op2, "%L");
              if( suffix_class & (AC_SIMD_EXTEND1 | AC_SIMD_EXTEND2))
                  suffix_class |= AC_SIMD_ZERVC;
              else
                  suffix_class |= AC_SIMD_ZERVB;
              }

	  nop = 2;
	  if (!strcmp(op2,""))//temp .. please remove
	    printf("SYNTAX_D0 op2 not found:%s\n",instruction_name);
	  break;


	case AC_SIMD_SYNTAX_VD:
          extended_register_format[0] = 'v';
          extended_register_format[1] = 'd';
	  strcpy (op1, " %(,");
	  strcpy (op2, "%>");
	  nop = 2;
	  break;


	default:
	    printf("unmapped syntax class found:%s\n",instruction_name); 
	  break;

	}

      insn = mask =0;
      insn2 = mask2 = 0;
      
      insn = (major_opcode << 27); /*SIMD Major Opcode*/
      mask = (-1 & 0xfc000000);

      if(suffix_class&AC_SUFFIX_LANEMASK){
          syntax_class_modifiers |= ARC_SIMD_LANEMASK;
          }
      if(suffix_class & AC_SIMD_EXTENDED){
          insn |= ((sub_opcode & 0x3f) << 16);
          mask |= 0x3f << 16;
          }
      if(suffix_class & AC_SIMD_EXTEND2 || suffix_class&AC_SIMD_EXTEND1||
          suffix_class & AC_SIMD_EXTEND3){
          insn |= (((sub_opcode >> 8) & 0x3f));
          mask |= 0x3f;
          if((insn&0x3f)==0x3f){
              insn |= (((sub_opcode >> 16) & 0x7)) << 24;
              mask |= 0x7 << 24;
              }
          }
      if(suffix_class & AC_SIMD_EXTEND3){
          insn |= (((sub_opcode >> 16) & 0x7) << 24);
          mask |= 0x7 << 24;
          }
      if(suffix_class & (AC_SIMD_EXTENDED|AC_SIMD_EXTEND2|AC_SIMD_EXTEND3)){
          insn2 |= (((sub_opcode>>24) & 3) << 30);
          mask2 |= 3 << 30;
          }
      if (suffix_class & AC_SIMD_FLAG_SET)
	insn |= (1 << 15);
      mask |= (1 << 15);

      syntax_class_modifiers &= ~(ARC_SIMD_SCALE1|ARC_SIMD_SCALE2|ARC_SIMD_SCALE3|ARC_SIMD_SCALE4);
      syntax_class   &= ~(ARC_SIMD_SCALE1|ARC_SIMD_SCALE2|ARC_SIMD_SCALE3|ARC_SIMD_SCALE4);

      if (suffix_class
	  & (AC_SIMD_SCALE_4 | AC_SIMD_SCALE_3 | AC_SIMD_SCALE_2
	     | AC_SIMD_SCALE_1 |AC_SIMD_SCALE_0))
	{
	  sprintf (operand_string,"%s[%s%s]",op1,op2,op3);
	  insn |= (1 << 23);

	  switch(suffix_class
	  & (AC_SIMD_SCALE_4 | AC_SIMD_SCALE_3 | AC_SIMD_SCALE_2
	     | AC_SIMD_SCALE_1|AC_SIMD_SCALE_0))
	    {
	    case AC_SIMD_SCALE_1:
              extended_instruction_flags[2] |= FLAG_SCALE_1 >> 8;
	      syntax_class_modifiers |= ARC_SIMD_SCALE1;
	      break;
	    case AC_SIMD_SCALE_2:
              extended_instruction_flags[2] |= FLAG_SCALE_2 >> 8;
	      syntax_class_modifiers |= ARC_SIMD_SCALE2;
	      break;
	    case AC_SIMD_SCALE_3:
              extended_instruction_flags[2] |= FLAG_SCALE_3 >> 8;
	      syntax_class_modifiers |= ARC_SIMD_SCALE3;
	      break;
	    case AC_SIMD_SCALE_4:
              extended_instruction_flags[2] |= FLAG_SCALE_4 >> 8;
	      syntax_class_modifiers |= ARC_SIMD_SCALE4;
	      break;
            case AC_SIMD_SCALE_0:
                break;
	    default:
	      abort();
	      break;
	    }
	}
      else {
	sprintf (operand_string,"%s%s%s",op1,op2,op3);
          }

      if (suffix_class & AC_SIMD_ENCODE_S12)
          extended_instruction_flags[2] |= FLAG_EXT_S16 >> 8;
      if (suffix_class & AC_SIMD_ENCODE_U16)
          extended_instruction_flags[2] |= FLAG_EXT_S16 >> 8;

      if (suffix_class & AC_SIMD_FLAG1_SET)
	{
	  insn |= (1 << 23);
	  mask |= (1 << 23);
	}

      if (suffix_class & AC_SIMD_FLAG2_SET)
	{
	  insn |= (1 << 22);
	  mask |= (1 << 22);
	}
      /*FIXME:Bit 22 and 23  to be taken care of*/
      /* OP3 
	27-31 - major opcode (6 in this case)
	26,25,24- op2-lower 3 bits
	23- unknown
	22- set when instrn name ends in i
	21-17 - subopcode if u8 present
	21-16 - subopcode if non-u8 present
	15- set if flag_set
	14-12- op2- high 3 bits
	11-6 - op3 bits
	5-0- op 1 bits
      */
      /*NOP=2
	27-31-Major OPcode
	26,25,24 - opb lower 3 bits
	23-unknown
	22 -set when instrn name ends in i
	21-16=101111
	15- set if flag_set
	14-12-opb high 3 bits
	11-6- opc bits
	5-0- sub_opcode
      */
      


      switch (nop)
	{
	case 3:
            extended_instruction_flags[3] |= FLAG_3OP;
	  if (suffix_class & AC_SIMD_ENCODE_U8)
	    {
	      insn |= ((sub_opcode & 0x1f) << 17);
	      mask |= (0x1f << 17);
	    }
	  else
	    {
	      insn |= ((sub_opcode & 0x3f) << 16);
	      mask |= (0x3f << 16);
	    }
	  break;

	case 2:
            extended_instruction_flags[3] |= FLAG_2OP;
            if(suffix_class&(AC_SIMD_EXTENDED|AC_SIMD_EXTEND2|AC_SIMD_EXTEND3|AC_SIMD_EXTEND1)){
                if (suffix_class & AC_SIMD_ENCODE_U8)
                    {
                    insn |= ((sub_opcode & 0x1f) << 17);
                    mask |= (0x1f << 17);
                    }
                else
                    {
                    insn |= ((sub_opcode & 0x3f) << 16);
                    mask |= (0x3f << 16);
                    }
                break;
              }
          else
              {
              if(suffix_class & AC_SIMD_ENCODE_U8){
                  insn |= ((sub_opcode & 0x1f) << 17);
                  mask |= (0x1f << 17);
                  }
              else
                  {
                  insn |= ((sub_opcode & 0x3f) << 16);
                  mask |= (0x3f << 16);
                  }
              }
	  break;

	case 1:
            extended_instruction_flags[3] |= FLAG_1OP;
            if(suffix_class&(AC_SIMD_EXTENDED|AC_SIMD_EXTEND2|AC_SIMD_EXTEND3|AC_SIMD_EXTEND1)){
                if (suffix_class & AC_SIMD_ENCODE_U8)
                    {
                    insn |= ((sub_opcode & 0x1f) << 17);
                    mask |= (0x1f << 17);
                    }
                else
                    {
                    insn |= ((sub_opcode & 0x3f) << 16);
                    mask |= (0x3f << 16);
                    if((insn & 0x3f) == 0x3f){
                        insn |= (((sub_opcode >> 16) & 0x7) << 24);
                        mask |= 7 << 24;
                        }
                    }
                break;
                }
            else
                {
                insn |= (0x2f << 16);
                mask |= (0x3f << 16);

                insn |= (0x3f << 0);
                mask |= (0x3f << 0);

                insn |= ((sub_opcode & 0x7) << 24);
                mask |= ((0x7) << 24);
                }
	  break;
        case 0:
            extended_instruction_flags[3] |= FLAG_NOP;
            if(suffix_class&(AC_SIMD_EXTENDED|AC_SIMD_EXTEND2|AC_SIMD_EXTEND3|AC_SIMD_EXTEND1)){
                if (suffix_class & AC_SIMD_ENCODE_U8)
                    {
                    insn |= ((sub_opcode & 0x1f) << 17);
                    mask |= (0x1f << 17);
                    }
                else
                    {
                    insn |= ((sub_opcode & 0x3f) << 16);
                    mask |= (0x3f << 16);
                    if((insn & 0x3f) == 0x3f){
                        insn |= (((sub_opcode >> 16) & 0x7) << 24);
                        mask |= 7 << 24;
                        }
                    }
                break;
                }
            else
                {
                insn |= (0x2f << 16);
                mask |= (0x3f << 16);
                insn |= ((sub_opcode & 0x3f) << 16);
                mask |= ((0x3f) << 16);
                }
            break;

	default:
	  as_fatal ("Invalid syntax\n");
	  break;
	}
      if(syntax_class & AC_SIMD_SYNTAX_VbI0 || 
         syntax_class & AC_SIMD_SYNTAX_Vb00){
          extended_operand_format2[0] |= '[';
          extended_operand_format2[1] |= '%';
          extended_operand_format2[2] |= 'o';
          extended_operand_format3[0] |= '%';
          extended_operand_format3[1] |= 'o';
          extended_operand_format3[2] |= ']';
          }

      xmitsuffix = suffix_class & (AC_SUFFIX_FLAG | AC_SUFFIX_COND | ARC_SIMD_LANEMASK | AC_SIMD_ZERVA | AC_SIMD_ZERVB | AC_SIMD_ZERVC | AC_SIMD_SETLM);

      syntax_class &= ~(ARC_SIMD_SCALE1 | ARC_SIMD_SCALE2 |
                        ARC_SIMD_SCALE3 | ARC_SIMD_SCALE4);
      if(suffix_class&(AC_SIMD_EXTENDED | AC_SIMD_EXTEND2 | AC_SIMD_EXTEND3)){
          arc_add_long_ext_inst(instruction_name,operand_string,
                           insn,mask,insn2,mask2, 
                                (syntax_class|syntax_class_modifiers),
                                xmitsuffix);
          }
      else
      arc_add_ext_inst (instruction_name, operand_string,
			insn,
			mask,
			(syntax_class | syntax_class_modifiers),
			xmitsuffix);
			
      break;

    default:
      as_bad("Invalid syntax\n");

    }
  return nop;
}


/* This function generates the operand strings based on the syntax class and
   syntax class modifiers and does some error checking.  */
static void
arc_generate_extinst16_operand_strings (char *instruction_name,
					unsigned char major_opcode,
					unsigned char sub_opcode,
					unsigned long syntax_class,
					unsigned long syntax_class_modifiers ATTRIBUTE_UNUSED,
					unsigned long suffix_class ATTRIBUTE_UNUSED)
{
  if((major_opcode > 0x0B) || (major_opcode < 0x08))
    {
      as_bad ("major opcode not in range [0x08-0x0B]");
      ignore_rest_of_line ();
      return;
    }
  
  switch(syntax_class &
	 (AC_SYNTAX_3OP | AC_SYNTAX_2OP | AC_SYNTAX_1OP | AC_SYNTAX_NOP))
    {
    case AC_SYNTAX_3OP:
    case AC_SYNTAX_2OP:

      if (sub_opcode < 0x01 || sub_opcode > 0x1f)
	as_bad ("Subopcode not in range [0x01 - 0x1f]\n");
      
      arc_add_ext_inst (instruction_name, " %b,%b,%c",
			INSN_16(major_opcode, 0, 0, sub_opcode),
			INSN_16(-1, 0, 0, -1),
			syntax_class, 0);
      break;

    case AC_SYNTAX_1OP:
      
      /* if (sub_opcode < 0x00 || sub_opcode > 0x06) */
      if (sub_opcode > 0x06)
	as_bad ("Subopcode not in range [0x00 - 0x06]\n");
      
      arc_add_ext_inst (instruction_name, " %b",
			INSN_16(major_opcode, 0, sub_opcode, 0),
			INSN_16(-1, 0, -1, -1),
			syntax_class, 0);
      break;
      
    case AC_SYNTAX_NOP:
      
      /*  if (sub_opcode < 0x00 || sub_opcode > 0x07) */
      if (sub_opcode > 0x07)
	as_bad ("Subopcode not in range [0x00 - 0x07]\n");

      arc_add_ext_inst (instruction_name, "",
			INSN_16(major_opcode, sub_opcode, 0x7, 0),
			INSN_16(-1, 0, -1, -1),
			syntax_class, 0);
      break;
      
    default:

      as_bad("Invalid syntax or unimplemented class\n");
    }
}

/* This function does the parsing of the .extinstruction directive and puts
   the instruction definition into the extension map while assembling for
   the ARCompact.  This function should be used for the ARCTangent too.  */
static void
arc_ac_extinst (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  unsigned int i;
  char c, *p;
  unsigned char major_opcode;
  unsigned long sub_opcode,sub_op;
  unsigned long syntax_class = 0;
  unsigned long syntax_class_modifiers = 0;  
  unsigned long suffix_class = 0;
  char *instruction_name;
  unsigned int name_length;
  int nops;

  segT old_sec;
  int old_subsec;

  
  /* Get all the parameters.  */

  /* Start off with the name of the instruction.  */

  SKIP_WHITESPACE ();
  
  instruction_name = input_line_pointer;
  c = get_symbol_end ();
  instruction_name = xstrdup (instruction_name);
  name_length = strlen(instruction_name);
  *input_line_pointer = c;

  /* Get major opcode.  */

  SKIP_WHITESPACE ();
  
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after instruction name");
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','.  */
  major_opcode = get_absolute_expression ();
  if ((major_opcode == 9 || major_opcode ==10)  && (extinsnlib & (SIMD_INSN)))
    syntax_class |= (AC_SYNTAX_SIMD);

  /* Get sub-opcode.  */
  
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after majoropcode");
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','.  */
  sub_opcode = get_absolute_expression ();
  /* Get suffix class.  */

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after sub opcode");
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','.  */

  while (1)
    {
      SKIP_WHITESPACE ();
      for (i=0 ; i<AC_MAXSUFFIXCLASS ; i++)
	if (!strncmp (ac_suffixclass[i].name,
		     input_line_pointer,
		     ac_suffixclass[i].len))
	  {
	    suffix_class |= ac_suffixclass[i].class;
	    input_line_pointer += ac_suffixclass[i].len;
	    break;
	  }

      if(i == AC_MAXSUFFIXCLASS)
	{
	  as_bad ("invalid suffix class");
	  ignore_rest_of_line ();
	  return;
	}

      SKIP_WHITESPACE ();
      
      if (*input_line_pointer == '|')
	input_line_pointer++;		/* skip '|'.  */
      else
	if (*input_line_pointer == ',')
	  break;
	else
	  {
	    as_bad ("invalid character '%c' in expression",
		    *input_line_pointer);
	    ignore_rest_of_line ();
	    return;
	  }
    }

  /* Get syntax class and syntax class modifiers.  */
  
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after suffix class");
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','.  */

  while (1)
    {
      SKIP_WHITESPACE ();
      for (i=0 ; i<AC_MAXSYNTAXCLASSMODIFIER ; i++)
	if (!strncmp (ac_syntaxclassmodifier[i].name,
		     input_line_pointer,
		     ac_syntaxclassmodifier[i].len))
	  {
	    syntax_class_modifiers |= ac_syntaxclassmodifier[i].class;
	    input_line_pointer += ac_syntaxclassmodifier[i].len;
	    break;
	  }

      if(i == AC_MAXSYNTAXCLASSMODIFIER)
	{
	  for(i= 0 ; i<AC_MAXSYNTAXCLASS ; i++)
	    if(!strncmp(ac_syntaxclass[i].name,
			input_line_pointer,
			ac_syntaxclass[i].len))
	      {
		syntax_class |= ac_syntaxclass[i].class;
		input_line_pointer += ac_syntaxclass[i].len;
		break;
	      }
	  
	  if(i == AC_MAXSYNTAXCLASS)
	    {
	      as_bad ("invalid syntax");
	      ignore_rest_of_line ();
	      return;
	    }
	}

      SKIP_WHITESPACE ();
      if(*input_line_pointer == '|')
	input_line_pointer++;		/* skip '|'.  */
      else
	if (is_end_of_line[(unsigned char) *input_line_pointer])
	  break;
	else
	  {
	    as_bad ("invalid character '%c' in expression",
		    *input_line_pointer);
	    ignore_rest_of_line ();
	    return;
	  }
    }

  /* Done getting all the parameters.  */

  /* Make extension instruction syntax strings.  */
  /* catch a few oddball cases */
  if(syntax_class&(AC_SIMD_SYNTAX_0|AC_SIMD_SYNTAX_C0|AC_SIMD_SYNTAX_VVV|
                   AC_SIMD_SYNTAX_VV|AC_SIMD_SYNTAX_VV0|AC_SIMD_SYNTAX_D0)){
      syntax_class |= AC_SYNTAX_SIMD;
      
      }
  nops = 0;
/* don't use extended format unless needed*/
  use_extended_instruction_format=0; 
  if (!strncmp (instruction_name + name_length - 2, "_s", 2))
    arc_generate_extinst16_operand_strings (instruction_name,
				    major_opcode, sub_opcode,
				    syntax_class, syntax_class_modifiers,
				    suffix_class);

  else
    nops = arc_generate_extinst32_operand_strings (instruction_name,
				    major_opcode, sub_opcode,
				    syntax_class, syntax_class_modifiers,
				    suffix_class);
  sub_op = sub_opcode;
  if(syntax_class & AC_SYNTAX_SIMD){
      if(major_opcode==0xa){
          if(suffix_class & AC_SIMD_FLAG2_SET)
              sub_opcode |= 0x40000000;
          if(suffix_class & AC_SIMD_FLAG1_SET)
              sub_opcode |= 0x80000000;
          }
      sub_opcode = sub_opcode | (nops << 28);
      if(suffix_class & AC_SIMD_ENCODE_U8)
          sub_opcode |= 0x4000000;
      } /* end if(syntax_class & AC_SYNTAX_SIMD) */

  /* Done making the extension syntax strings.  */
  
  /* OK, now that we know what this inst is, put a description in the
     arc extension section of the output file.  */

  old_sec    = now_seg;
  old_subsec = now_subseg;

  arc_set_ext_seg (EXT_INSTRUCTION32, syntax_class, major_opcode, sub_opcode);
  switch( use_extended_instruction_format){
  case 1:
      sub_op = sub_opcode & 0x3f;
      if(syntax_class & AC_SYNTAX_SIMD){
          if(suffix_class & (AC_SIMD_EXTEND2 | AC_SIMD_EXTEND1)){
              sub_op = (sub_opcode >> 8) & 0x3f;
              }
          if(suffix_class & AC_SIMD_EXTEND3){
              sub_op = (sub_opcode >>16) & 0x3f;
              }
          }
      p = frag_more(OPD_FORMAT_SIZE*3+RCLASS_SET_SIZE+13);
      *p = OPD_FORMAT_SIZE*3+RCLASS_SET_SIZE+13+name_length+1;
      p++;
      *p = EXT_INSTRUCTION32_EXTENDED;
      p++;
      *p = major_opcode;
      p++;
      *p = sub_op;
      p++;
      for(i = 0; i < RCLASS_SET_SIZE; i++){
          *p = extended_register_format[i];
          p++;
          }
      for(i = 0; i < OPD_FORMAT_SIZE; i++){
          *p = extended_operand_format1[i];
          p++;
          }
      for(i = 0; i < OPD_FORMAT_SIZE; i++){
          *p = extended_operand_format2[i];
          p++;
          }
      for(i = 0; i < OPD_FORMAT_SIZE; i++){
          *p = extended_operand_format3[i];
          p++;
          }
      for(i = 0; i < 4; i++){
          *p = extended_instruction_flags[i];
          p++;
          }
      if(suffix_class & (AC_SIMD_EXTENDED|AC_SIMD_EXTEND2|AC_SIMD_EXTEND3))
          *p = 1;
      else
          *p = 0;
      p++;
      for(i = 0; i < 3; i++){
          *p = 0;
          p++;
          }
      *p = extended_instruction_flags[3];              
      p++;
      break;
    case 0:
      p = frag_more (1);
      *p = 5 + name_length + 1;
      p = frag_more (1);

      /* By comparing with the Metaware assembler, EXT_INSTRUCTION should be
         0x40 as opposed to 0x00 which we have defined. arc-ext.h.  */
  
      *p = EXT_INSTRUCTION32;
      p = frag_more (1);
      *p = major_opcode;
      p = frag_more (1);
      *p = sub_opcode;
      p = frag_more (1);
      *p = (syntax_class | syntax_class_modifiers);
      break;
  case 2:
      demand_empty_rest_of_line();
      free (instruction_name);
      return;
      }

  p = frag_more (name_length + 1);
  strcpy (p, instruction_name);

  subseg_set (old_sec, old_subsec);
  demand_empty_rest_of_line ();

  free (instruction_name);
}

/* Here ends all the ARCompact extension instruction assembling stuff.  */

static void
arc_common (int localScope)
{
  char *name;
  char c;
  char *p;
  int align, size;
  symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();
  /* just after name is now '\0'  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after symbol name");
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ','  */
  size = get_absolute_expression ();

  if (size < 0)
    {
      as_bad ("negative symbol length");
      ignore_rest_of_line ();
      return;
    }

  *p = 0;
d882 1
a882 1
      as_bad ("ignoring attempt to re-define symbol");
d889 1
a889 1
      as_warn ("length of symbol \"%s\" already %ld, ignoring %d",
d903 1
a903 1
	  as_warn ("assuming symbol alignment of zero");
d906 1
a906 1
  else if (localScope == 0)
a908 8
  else
    {
      as_bad ("Expected comma after length for lcomm directive");
      ignore_rest_of_line ();
      return;
    }


d970 1
a970 1
      as_bad ("\".option\" directive must appear before any instructions");
d978 7
a984 2
 
  if (!mach_type_specified_p)
d986 4
a989 4
	arc_mach_type = mach;
	arc_mach_a4 = (mach == bfd_mach_arc_a4);
	arc_opcode_init_tables (arc_get_opcode_mach (mach, target_big_endian));

d991 1
a991 2
	as_fatal ("could not set architecture and machine");
      
a993 4
  else
    if (arc_mach_type != mach)
      as_warn ("Command-line value overrides \".option\" directive");

a994 1

d998 1
a998 1
  as_bad ("invalid identifier for \".option\"");
a1001 8
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c  */
#define MAX_LITTLENUMS 6

d1005 1
a1005 88
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
      prec = 2;
      break;

    case 'd':
    case 'D':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return "bad call to md_atof";
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return NULL;
}

/* Convert from target byte order to host byte order */

static valueT
md_chars_to_number (buf, n)
     char *buf;
     int n;
{
  valueT result;
  unsigned char *where = (unsigned char *) buf;
 
  result = 0;
 
  if (target_big_endian)
    {
      if (n == -4) n = 4;
      switch (n)
        {
        case 2:
        case 4:
          while (n--)
            {
              result <<= 8;
              result |= (*where++ & 255);
            }
          break;
        default:
          abort ();
        }
    }
  else
    {
      switch (n)
        {
        case 2:
        case 4:
          while (n--)
            {
              result <<= 8;
              result |= (where[n] & 255);
            }
          break;
        case -4:
          result |= ((where[0] & 255) << 16);
          result |= ((where[1] & 255) << 24);
          result |= (where[2] & 255);
          result |= ((where[3] & 255) << 8);
          break;
        default:
          abort ();
        }
    }
 
  return result;
d1014 4
a1017 19
  void (*endian) (char *, valueT, int) = (target_big_endian)
    ? number_to_chars_bigendian : number_to_chars_littleendian;
 
  switch (n)
    {
    case 1:
    case 2:
    case 3:
    case 4:
    case 8:
      endian (buf, val, n);
      break;
    case -4:
      endian (buf, (val & 0xffff0000) >> 16, 2);
      endian (buf + 2, val & 0xffff, 2);
      break;
    default:
      abort ();
    }
d1036 1
a1036 1
  as_fatal (_("md_estimate_size_before_relax\n"));
d1047 1
a1047 1
  as_fatal (_("md_convert_frag\n"));
d1058 1
a1058 6

      /* Explicitly make normal symbols constant but assume local symbols as
       * constants anyway (I guess that is a safe enough assumption). */
      if(expressionP->X_add_symbol->bsym)
	  expressionP->X_add_symbol->sy_value.X_op = O_constant;
      
d1080 1
a1080 1
    as_bad ("expression too complex code symbol");
d1098 4
a1101 1
  switch(*p)
d1103 3
a1105 2
    case '%':
      if (strncmp (p, "%st(", 4) == 0)
d1107 12
a1118 1
	  input_line_pointer += 4;
d1120 4
a1123 10
	  /* Resetting assembling_instruction before calling
	     expression so that arc_parse_name won't evaluate a name
	     to be a register.  Here the name assembling_instruction
	     seems like a misnomer. */

	  assembling_instruction = 0;
	  expression (expressionP);
	  assembling_instruction = 1;	  

	  if (*input_line_pointer != ')')
d1125 3
a1127 1
	      as_bad ("missing ')' in %%-op");
d1130 1
a1130 6
	  if (arc_mach_type != bfd_mach_arc_a4)
	    {
	      as_bad ("%%st directive allowed only in case of ARCtangent A4");
	    }
	  ++input_line_pointer;
	  arc_code_symbol (expressionP);
d1132 1
a1132 1
      else
d1134 2
a1135 6
	  /* It could be a register.  */
	  int i, l;
	  struct arc_ext_operand_value *ext_oper = arc_ext_operands;
	  p++;
	  
	  while (ext_oper)
d1137 4
a1140 9
	      l = strlen (ext_oper->operand.name);
	      if (!strncmp (p, ext_oper->operand.name, l) && !ISALNUM (*(p + l)))
		{
		  input_line_pointer += l + 1;
		  expressionP->X_op = O_register;
		  expressionP->X_add_number = (offsetT) &ext_oper->operand;
		  return;
		}
	      ext_oper = ext_oper->next;
a1141 61
	  for (i = 0; i < arc_reg_names_count; i++)
	    {
	      l = strlen (arc_reg_names[i].name);
	      if (!strncmp (p, arc_reg_names[i].name, l) && !ISALNUM (*(p + l)))
		{
		  input_line_pointer += l + 1;
		  expressionP->X_op = O_register;
		  expressionP->X_add_number = (offsetT) &arc_reg_names[i];
		  break;
		}
	    }
	}
      break;
    case '@@':
      /*
	If this identifier is prefixed with '@@' then make the expression
	(operand) of the type O_symbol so that arc_parse_name will not
	treat it as a register.
      */
      input_line_pointer++;
      expressionP->X_op = O_symbol;
      expression (expressionP);
      break;
    }
}

/*
  This function is called from the function 'expression', it attempts
  to parse special names (in our case register names).  It fills in
  the expression with the identified register.  It returns 1 if it is
  a register and 0 otherwise.
*/

int
arc_parse_name (name, expressionP)
     const char *name;
     expressionS *expressionP;
{
  int i, l;
  struct arc_ext_operand_value *ext_oper = arc_ext_operands;

  /* By default, expressionP->X_op has O_illegal.  However whenever we
    encounter the '@@' chatacter (which is handled in md_operand) we
    set the expression type to O_symbol.  Thereby we over-ride the
    register name being treated as a register if it is prefixed with
    '@@'. */

  if(!assembling_instruction)
    return 0;
  
  if(expressionP->X_op == O_symbol)
    return 0;
  
  while (ext_oper)
    {
      l = strlen (ext_oper->operand.name);
      if (!strcasecmp (name, ext_oper->operand.name) && !ISALNUM (*(name + l)))
	{
	  expressionP->X_op = O_register;
	  expressionP->X_add_number = (offsetT) &ext_oper->operand;
	  return 1;	  
a1142 1
      ext_oper = ext_oper->next;
a1143 16
  for (i = 0; i < arc_reg_names_count; i++)
    {
      l = strlen (arc_reg_names[i].name);
      if (!strcasecmp (name, arc_reg_names[i].name) && !ISALNUM (*(name + l)))
	{
	  expressionP->X_op = O_register;
	  expressionP->X_add_number = (offsetT) &arc_reg_names[i];
	  return 1;	  
	  break;
	}
    }

#ifdef ENFORCE_AT_PREFIX
  as_bad ("Symbol %s not prefixed with '@@'",name);
#endif
  return 0;
d1153 1
a1153 21
    /* The arc abi demands that a GOT[0] should be referencible as 
       [ pc+_DYNAMIC@@gotpc ].Hence we convert a _DYNAMIC@@gotpc to 
       a GOTPC reference to _GLOBAL_OFFSET_TABLE_  */
    if ((*name == '_' && *(name+1) == 'G'
	 && strcmp(name, GLOBAL_OFFSET_TABLE_NAME) == 0)
	||
	(*name == '_' && *(name+1) == 'D'
	 && strcmp(name, DYNAMIC_STRUCT_NAME) == 0))
    {
	if(!GOT_symbol)
	{
	    if(symbol_find(name)) 
		as_bad("GOT already in symbol table");
	    
		GOT_symbol = symbol_new (GLOBAL_OFFSET_TABLE_NAME, undefined_section, 
					 (valueT) 0, &zero_address_frag);
	};
	return GOT_symbol;
    }
    
    return 0;
d1169 1
a1169 1
  
a1176 1
      
d1198 1
a1198 1
      reloc_type = get_arc_exp_reloc_type (1, BFD_RELOC_32 , exp, &exptmp);
d1203 4
a1206 4
      static int bfd_reloc_map[] = {BFD_RELOC_NONE,BFD_RELOC_8,BFD_RELOC_16,
				BFD_RELOC_24,BFD_RELOC_32,BFD_RELOC_NONE,
				BFD_RELOC_NONE,BFD_RELOC_64 }; 
      fix_new_exp (frag, where, nbytes, exp, 0, bfd_reloc_map[nbytes]);
d1218 2
a1219 55
  if (fixP->fx_addsy != (symbolS *) NULL
      && ! S_IS_DEFINED (fixP->fx_addsy))
    {
      /* The symbol is undefined.  Let the linker figure it out.  */
      return 0;
    }

  /* Return the address of the delay slot for ARCtangent-A4 architecture.
     For ARCtangent-A5 and higher variants (which implement ARCompact ISA),
     return the address of the current instruction */
  if (arc_mach_type == bfd_mach_arc_a4)
    return fixP->fx_frag->fr_address + fixP->fx_where + fixP->fx_size;
  else
    return (fixP->fx_frag->fr_address + fixP->fx_where) & ~0x3;
}

/* Get the relocation for the sda symbol reference in insn */
static int
arc_get_sda_reloc (arc_insn insn, int compact_insn_16)
{
  if (ac_add_reg_sdasym_insn (insn))
    return BFD_RELOC_ARC_SDA32_ME;

  /* Refer to opcodes/arc-opc.c for 'insn to return value' mappings for this
     function.  */
  switch (ac_get_load_sdasym_insn_type (insn, compact_insn_16))
    {
    case 0:
      return BFD_RELOC_ARC_SDA_LDST2;
    case 1:
      return BFD_RELOC_ARC_SDA_LDST;
    case 2:
      return BFD_RELOC_ARC_SDA_LDST1;

    case 10:
      return BFD_RELOC_ARC_SDA16_LD2;
    case 11:
      return BFD_RELOC_ARC_SDA16_LD;
    case 12:
      return BFD_RELOC_ARC_SDA16_LD1;
    }
  
  /* Refer to opcodes/arc-opc.c for 'insn to return value' mappings for this
     function.  */
  switch (ac_get_store_sdasym_insn_type (insn, compact_insn_16))
    {
    case 0:
      return BFD_RELOC_ARC_SDA_LDST2;
    case 1:
      return BFD_RELOC_ARC_SDA_LDST;
    case 2:
      return BFD_RELOC_ARC_SDA_LDST1;
    }

  abort();
d1231 1
a1231 1
md_apply_fix (fixS *fixP, valueT *valueP, segT seg)
d1233 1
a1233 2
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT value;
d1235 2
a1236 10
  /* FIXME FIXME FIXME: The value we are passed in *valueP includes
     the symbol values.  Since we are using BFD_ASSEMBLER, if we are
     doing this relocation the code in write.c is going to call
     bfd_perform_relocation, which is also going to use the symbol
     value.  That means that if the reloc is fully resolved we want to
     use *valueP since bfd_perform_relocation is not being used.
     However, if the reloc is not fully resolved we do not want to use
     *valueP, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valueP since it includes the
     result of md_pcrel_from.  This is confusing.  */
a1237 5
  if (fixP->fx_addsy == (symbolS *) NULL)
    {
      value = *valueP;
      fixP->fx_done = 1;
    }
d1240 2
a1241 8
      value = *valueP;
      /* ELF relocations are against symbols.
	 If this symbol is in a different section then we need to leave it for
	 the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
	 so we have to undo it's effects here.  */
      if ( (S_IS_DEFINED (fixP->fx_addsy) &&
	    S_GET_SEGMENT (fixP->fx_addsy) != seg) ||
	   S_IS_WEAK(fixP->fx_addsy))
a1243 15
  else
    {
      value = fixP->fx_offset;
      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    {
	      /* We can't actually support subtracting a symbol.  */
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    "expression too complex");
	    }
	}
    }
d1245 4
d1254 1
a1254 1
      arc_insn insn = 0;
d1259 15
a1273 1
      
d1275 2
a1276 58
	{
          /* Only if the fixup is totally done up is it used
             correctly. */
      
          /* Fetch the instruction, insert the fully resolved operand
             value, and stuff the instruction back again.  */
          where = fixP->fx_frag->fr_literal + fixP->fx_where;
          if (arc_mach_a4)
	    {
	      if (target_big_endian)
		insn = bfd_getb32 ((unsigned char *) where);
	      else
		insn = bfd_getl32 ((unsigned char *) where);
            }
          else
	    {
              switch (fixP->fx_size)
		{
		case 2:
                  insn = md_chars_to_number (buf, fixP->fx_size);
                  break;
		case 4:
                  insn = md_chars_to_number (buf, - fixP->fx_size);
                  break;
		}
            }
          
          insn = arc_insert_operand (insn, 0, operand, -1, NULL, (offsetT) value,
                                     fixP->fx_file, fixP->fx_line);
          if (arc_mach_a4)
	    {
              if (target_big_endian)
		bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
              else
		bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
            }
          else
	    {
              switch (fixP->fx_size)
		{
		case 2:
                  md_number_to_chars (buf, insn, fixP->fx_size);
                  break;
                case 4:
                  md_number_to_chars (buf, insn, - fixP->fx_size);
                  break;
		}
            }
           return;
	}

      /* FIXME:: 19th May 2005 . 
	 Is this comment valid any longer with respect
         to the relocations being in the addends and not in place. We no
	 longer have inplace addends in any case. The only thing valid that
	 needs to be done is to set up the correct BFD reloc values and 
	 nothing else. 
      */
d1284 1
a1284 1
      if (arc_mach_a4 && (operand->fmt == 'B'))
d1291 1
a1291 1
      else if (arc_mach_a4 && (operand->fmt == 'J'))
d1303 1
a1303 37
	  fixP->fx_r_type = (arc_mach_a4) ? BFD_RELOC_32 : BFD_RELOC_ARC_32_ME;
	}
      /* ARCtangent-A5 21-bit (shift by 2) PC-relative relocation. Used for
         bl<cc> instruction */
      else if (!arc_mach_a4 && (operand->fmt == 'h'))
	{
	  assert ((operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0
		  && operand->bits == 19
		  && operand->shift == 18);
	  fixP->fx_r_type = BFD_RELOC_ARC_S21W_PCREL;
	}
      /* ARCtangent-A5 25-bit (shift by 2) PC-relative relocation. Used for
         'bl' instruction. */
      else if (!arc_mach_a4 && (operand->fmt == 'H'))
	{
	  assert ((operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0
		  && operand->bits == 23
		  && operand->shift == 18);
	  fixP->fx_r_type = BFD_RELOC_ARC_S25W_PCREL;
	}
      /* ARCtangent-A5 21-bit (shift by 1) PC-relative relocation. Used for
         'b<cc>' instruction. */
      else if (!arc_mach_a4 && (operand->fmt == 'i'))
	{
	  assert ((operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0
		  && operand->bits == 20
		  && operand->shift == 17);
	  fixP->fx_r_type = BFD_RELOC_ARC_S21H_PCREL;
	}
      /* ARCtangent-A5 25-bit (shift by 1) PC-relative relocation. Used for
         unconditional branch ('b') instruction.  */
      else if (!arc_mach_a4 && (operand->fmt == 'I'))
	{
	  assert ((operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0
		  && operand->bits == 24
		  && operand->shift == 17);
	  fixP->fx_r_type = BFD_RELOC_ARC_S25H_PCREL;
a1304 7
      else if (!arc_mach_a4 && (operand->fmt == 'W'))
        {
          assert ((operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0
                  && operand->bits == 11
                  && operand->shift == 0);
          fixP->fx_r_type = BFD_RELOC_ARC_S13_PCREL;
        }
d1308 1
a1308 1
			"unresolved expression that must be resolved");
d1310 1
a1314 3
      /* Zero out the in place addend for relocations */
      if ( !fixP->fx_done)
        value = 0;
a1320 1

d1325 1
a1325 2

	case BFD_RELOC_24:
a1326 5
			      value, 3);
	  break;

	case BFD_RELOC_32:
  	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
a1328 9

	case BFD_RELOC_ARC_GOTPC32:
	case BFD_RELOC_ARC_GOTOFF:
	case BFD_RELOC_ARC_32_ME:   
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, -4);
            
	  break;
	    
d1334 1
a1337 21
	  /* Take care of PLT relocations for bl<cc>
	     case BFD_RELOC_ARC_PLT25W :
	     break;
	  */

	case BFD_RELOC_ARC_PLT32:
	    /* Currently we are treating PLT32 as a 25bit relocation type */
	    
	    break;

	case BFD_RELOC_ARC_SDA:
	case BFD_RELOC_ARC_SDA32:
	case BFD_RELOC_ARC_SDA_LDST:
	case BFD_RELOC_ARC_SDA_LDST1:
	case BFD_RELOC_ARC_SDA_LDST2:
	case BFD_RELOC_ARC_SDA16_LD:
	case BFD_RELOC_ARC_SDA16_LD1:
	case BFD_RELOC_ARC_SDA16_LD2:
	case BFD_RELOC_ARC_SDA32_ME:
	  break;

a1341 2

  return;
a1351 14
  bfd_reloc_code_real_type code;
  code = fixP->fx_r_type;

  if (code == BFD_RELOC_ARC_GOTPC32
      && GOT_symbol
      && fixP->fx_addsy == GOT_symbol)
    code = BFD_RELOC_ARC_GOTPC;

  /* irfan 1 */
  if (fixP->fx_pcrel && fixP->fx_r_type == BFD_RELOC_ARC_32_ME)
  {
	  code = BFD_RELOC_ARC_PC32;
  	  // fixp->fx_offset = ???
  }
d1358 1
a1358 4



  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
d1362 1
a1362 1
		    "internal error: can't export reloc type %d (`%s')",
d1367 1
a1367 1
 
d1369 5
a1373 2
  
  reloc->addend = fixP->fx_offset;
d1397 1
a1397 1
  { "extinstruction", arc_handle_extinst, 0 },
a1400 6
static struct arc_operand_value num_suf;

static struct arc_operand_value zer_rega={"ZEROV",62,'*',0};
static struct arc_operand_value zer_regb={"ZEROV",62,'(',0};
static struct arc_operand_value zer_regc={"ZEROV",62,')',0};

d1409 1
a1409 2
  char *start, *s;
  char *firstsuf;
a1410 1
  int lm_present;
a1411 1
  long insn2;
a1412 7
  current_special_sym_flag = NO_TYPE;
  char insn_name[64]={0};
  int insn_name_idx = 0;
  /* Non-zero if the insn being encoded is 16-bit ARCompact instruction */
  int compact_insn_16;

  assembling_instruction = 1;
a1425 21
  /* Check whether insn being encoded is 16-bit ARCompact insn */
  for (s = str; (*s && (ISALNUM (*s) ) ) ; s++)
  {;}


  for (insn_name_idx = 0; insn_name_idx < (int) strlen(str); insn_name_idx++)
  {
	if ( !(ISALNUM(str[insn_name_idx]) || str[insn_name_idx] == '_') ){
		break;
	}
	insn_name[insn_name_idx] = str[insn_name_idx];
  }

  /* All ARCompact 16 bit instructions have a <operation_name>_s which
   * is what we attempt to exploit here .
   */
  if ((*s && *s == '_' && *(s+1) == 's') || strcmp(str,"unimp") == 0) /* FIXME: cleanup required */
    compact_insn_16 = 1;
  else
    compact_insn_16 = 0;

d1431 1
a1431 3
#if DEBUG_INST_PATTERN
fprintf (stdout, "Matching ****** %s *************\n", str);
#endif
a1443 2
      int mods=0;

a1448 2
      int regb_p;
      const struct arc_operand_value *regb;
d1451 1
a1451 1
      if (!arc_opcode_supported (opcode))
a1453 7
      /* If opcode syntax is for 32-bit insn but input is 16-bit insn,
         then go for the next opcode */
      for (syn = opcode->syntax; *syn && ISALNUM (*syn); syn++);
      if (compact_insn_16 && !(*syn && *syn == '_' && *(syn + 1) == 's'))
        if (strcmp(opcode->syntax,"unimp") !=0) /* FIXME: This is too bad a check!!! cleanup required */
	  continue;

a1456 2
      insn2 = opcode->value2;
      lm_present = 0;
a1457 2
      num_suf.value = 0;
      firstsuf = 0;
d1462 1
a1462 5
      regb_p = 0;
      regb = NULL;
#if DEBUG_INST_PATTERN
fprintf (stdout, "Trying syntax %s\n", opcode->syntax);
#endif
d1467 1
a1469 3
#if DEBUG_INST_PATTERN
printf(" syn=%s str=||%s||insn=%x\n",syn,str,insn);//ejm
#endif
d1473 1
a1473 1
	      if (*str == *syn || (*syn=='.'&&*str=='!'))
d1475 1
a1475 1
                if (*syn == ' '){
a1476 1
                    }
d1484 1
a1484 1
          if(firstsuf==0)firstsuf = syn-1;
d1489 1
a1489 10
	      if (arc_operands[arc_operand_map[(int) *syn]].insert)
#if 1
		/* FIXME: Need 'operand' parameter which is uninitialized.  */
		abort ();
#else
		(arc_operands[arc_operand_map[(int) *syn]].insert) (insn, operand, mods, NULL, 0, NULL);
#endif

	      mods |= (arc_operands[arc_operand_map[(int) *syn]].flags
		       & ARC_MOD_BITS);
d1491 1
a1491 1
	    } /* end while(ARC_MOD_P(...)) */
d1493 2
a1494 3
	  if (operand->fmt == 0){
	    as_fatal ("unknown syntax format character `%c'", *syn);
              }
d1500 2
a1501 3
                  {
		  insn = (*operand->insert) (insn,&insn2, operand, mods, NULL, 0,
					     &errmsg);
a1507 1
			  assembling_instruction = 0;
d1516 2
a1517 3
		      && (operand->flags
			  & (ARC_OPERAND_ABSOLUTE_BRANCH
			     | ARC_OPERAND_ADDRESS)))
d1527 1
a1527 1
	      int found,negflg;
a1530 1
              struct arc_operand_value *varsuf;
d1533 1
a1533 1
	      if (!(operand->flags & ARC_OPERAND_SUFFIX)){
a1534 2
                  }

a1544 1

a1545 1
              negflg = 0;
d1548 1
a1548 2
                negflg = *s=='!';
		  if (*s != '.'&&*s != '!')
d1562 1
d1568 4
a1571 234
              found = 0;
              suf = NULL;
              if(!found && ((insn >> 27) == 0x0a)){
                  char *restore;
                  int sum=0;
                  if(num_suf.type == 0){
                      int i;
                      for(i=0;i<256;i++){
                          if(arc_operands[i].fmt == ']'){
                              num_suf.type = i;
                              break;
                              }
                          if(arc_operands[i].fmt == 0)break;
                          }
                      } /* end if(num_suf.type == 0) */

                  if(*syn == ']' || *(syn+3) == ']'){
                      restore = str;
                      if(*str == '.' || *str == '!')str++;
                      if((*str == 'i' || *str == 'I') && (*(str+1) >= '0' && 
                                                      *(str+1)<='9')){
                          str++;
                          sum = 0;
                              if(*str  ==  '1'){
                                  sum = 1;
                                  str++;
                              }
                              if(*str >= '0' && *str <= '9'){
                                  sum = sum*10 + *str-'0';
                                  str++;
                                  }
                              sum = sum & 0xf;
                              if(negflg)
                                  sum |= 0x20; //negation flag
                              suf = &num_suf;
                              varsuf = &num_suf;
                              varsuf->value = sum;
                              insn2 |= sum << 15;
                              insn2 |= 1 << 29;
                              lm_present = 1;
                              if(firstsuf)
                                  syn = firstsuf-1;
                              found = 1;
                          } 
                      else
                          {
                          if(*str == '0' && *(str+1) == 'x'){
                              str = str+2;
                              while(1){
                                  if(*str >= '0' && *str <= '9')
                                      {
                                      sum = (sum << 4) + *str-'0';
                                      str++;
                                      }
                                  else {
                                      if(*str >= 'a' && *str <= 'z'){
                                          sum = (sum <<4) + *str-'a'+10;
                                          str++;
                                          }
                                      else
                                          break;
                                      }
                                  } /* end while(1) */
                              suf = &num_suf;
                              varsuf = &num_suf;
                              /* lane masks accumulate */
                              varsuf->value |= sum;
                              found = 1;
                              if(firstsuf)
                                  syn = firstsuf-1;
                              insn2 |= sum << 15;
                              lm_present = 1;
                              } 
                          else
                              {
                              if(*(str) >= '0' && *(str) <= '9'){
                                  while(*str >= '0' && *str <= '9'){
                                      sum = sum*10 + *str-'0';
                                      str++;
                                      }
                                  suf = &num_suf;
                                  varsuf = &num_suf;
                                  /* lane masks accumulate */
                                  varsuf->value |= sum;
                                  found = 1;
                                  if(firstsuf)
                                      syn = firstsuf-1;
                                  insn2 |= sum << 15;
                                  lm_present = 1;
                                  } 
                              else 
                                  {
                                  if(*str == 'u'){
                                      str++;
                                      if(*str == 's' || *str == 'S')str++;
                                      found = 1;
                                      sum = 0x20;
                                      insn2 |= sum << 23;
                                      lm_present = 1;
                                      suf=&num_suf;
                                      }
                                  if((*str == 's' || *str == 'S') && found == 0){
                                      found = 1;
                                      str++;
                                      sum = 0x14;
                                      insn2 |= sum << 23;
                                      lm_present = 1;
                                      suf = &num_suf;
                                      }
                                  if((*str == 'l' || *str == 'L') && found == 0){
                                      found = 1;
                                      str++;
                                      sum = 0xc;
                                      if(*str == 'e' || *str == 'E'){
                                          str++;
                                          sum = 0xc;
                                          }
                                      if(*str == 's' || *str == 'S'){
                                          str++;
                                          sum = 0xf;
                                          }
                                      if(*str == 't' || *str == 'T'){
                                          str++;
                                          sum = 0xb;
                                          }
                                      if(*str == 'o' || *str == 'O'){
                                          str++;
                                          sum = 0x5;
                                          }
                                      insn2 |= sum << 23;
                                      lm_present = 1;
                                      suf = &num_suf;
                                      }
                                  if((*str == 'g' || *str == 'G') && found==0){
                                      found = 1;
                                      str++;
                                      sum = 0xa;
                                      if(*str == 'e' || *str == 'E'){
                                          str++;
                                          sum = 0xa;
                                          }
                                      if(*str == 't' || *str == 'T'){
                                          str++;
                                          sum = 0x9;
                                          }
                                      insn2 |= sum << 23;
                                      suf = &num_suf;
                                      lm_present = 1;
                                      }
                                  if((*str == 'h' || *str == 'H') && found==0){
                                      found = 1;
                                      str++;
                                      sum = 0xd;
                                      if(*str == 'i' || *str == 'I'){
                                          str++;
                                          sum = 0xd;
                                          }
                                      if(*str == 's' || *str == 'S'){
                                          str++;
                                          sum = 0x6;
                                          }
                                      insn2 |= sum << 23;
                                      lm_present = 1;
                                      suf = &num_suf;
                                      }
                                  if((*str == 'z' || *str == 'Z') && found == 0){
                                      str++;
                                      insn2 |= 1 << 23;
                                      found = 1;
                                      lm_present = 1;
                                      suf = &num_suf;
                                      }
                                  }
                              if((*str == 'e' || *str == 'E') && found == 0){
                                  str++;
                                  if(*str == 'q') str++;
                                  insn2 |= 1 << 23;
                                  lm_present = 1;
                                  found = 1;
                                  suf = &num_suf;
                                  }
                              if((*str == 'f' || *str == 'F') && found == 0){
                                  str++;
                                  insn |= 1 << 15;
                                  found = 1;
                                  suf = &num_suf;
                                  lm_present = 1;
                                  }
                              if((*str == 'n' || *str == 'N') && found == 0){
                                  str++;
                                  sum = 2;
                                  if(*str == 'z' || *str == 'Z'){
                                      str++;
                                      sum = 2;
                                      }
                                  if(*str == 'e' || *str == 'E'){
                                      str++;
                                      sum = 2;
                                      }
                                  if(*str == 'c' || *str == 'C'){
                                      str++;
                                      sum = 6;
                                      }
                                  insn2 |= sum << 23;
                                  found = 1;
                                  lm_present = 1;
                                  suf = &num_suf;
                                  }
                              if((*str == 'c' || *str == 'C') && found == 0){
                                  str++;
                                  if(*str == 'c' || *str == 'C')str++;
                                  sum = 6;
                                  found = 1;
                                  insn2 |= sum << 23;
                                  suf = &num_suf;
                                  lm_present = 1;
                                  }
                              if(!found){
                                  str = restore;
                                  }
                              }
                          }
                      }
                  } /* end if(!found&&insn>>27==0x0a) */
              if(!suf){
                  if ((suf = get_ext_suffix (s,*syn))){
                      ext_suffix_p = 1;
                      }
                  else 
                      {
                      suf = hash_find (arc_suffix_hash, s);
                      }
                  }

d1580 1
d1582 1
a1582 1
                 several times, so we have to examine all of them.  This is
d1586 1
d1592 1
a1592 1
		    insn = (*operand->insert) (insn,&insn2, operand,
d1606 1
a1606 2
		       (suffix < suffix_end
			&& strcmp (suffix->name, suf->name) == 0);
d1613 2
a1614 2
			    insn = (*operand->insert) (insn,&insn2, operand, mods,
						       NULL, suffix->value,
d1622 2
a1623 2
			} /* end if(arc_operands[suffix->type].fmt == *syn) */
		    } /* end for(suffix=suf; ....) */
d1632 1
a1632 1
		    as_bad ("too many suffixes");
a1641 1
	      int match_failed = 0;
d1644 1
a1644 1
	      exp.X_op = O_illegal;
d1654 6
a1659 69
	      /* Verify the input for the special operands for ARCompact ISA */
	      if (!arc_mach_a4)
		{
		  switch (operand->fmt)
		    {
		    case '4':
		      if (*str == '%')
			str++;
		      if (strncmp (str, "r0", 2))
			match_failed = 1;
		      else if (ISALNUM (*(str + 2)))
			match_failed = 1;
		      break;
		    case '5':
		      if (*str == '%')
			str++;
		      if (strncmp (str, "gp", 2))
			match_failed = 1;
		      else if (ISALNUM (*(str + 2)))
			match_failed = 1;
		      break;
		    case '6':
		      if (*str == '%')
			str++;
		      if (strncmp (str, "sp", 2))
			match_failed = 1;
		      else if (ISALNUM (*(str + 2)))
			match_failed = 1;
		      break;
		    case '7':
		      if (*str == '%')
			str++;
		      if (strncmp (str, "ilink1", 6))
			match_failed = 1;
		      else if (ISALNUM (*(str + 6)))
			match_failed = 1;
		      break;
		    case '8':
		      if (*str == '%')
			str++;
		      if (strncmp (str, "ilink2", 6))
			match_failed = 1;
		      else if (ISALNUM (*(str + 6)))
			match_failed = 1;
		      break;
		    case '9':
		      if (*str == '%')
			str++;
		      if (strncmp (str, "blink", 5))
			match_failed = 1;
		      else if (ISALNUM (*(str + 5)))
			match_failed = 1;
		      break;
		    case '!':
		      if (*str == '%')
			str++;
		      if (strncmp (str, "pcl", 3))
			match_failed = 1;
		      else if (ISALNUM (*(str + 3)))
			match_failed = 1;
		      break;
		    } /* end switch(operand->fmt) */
		  if (match_failed)
		    break;
		} /* end if(!arc_mach_a4) */

	      {
		/* Parse the operand.  */
		/* Attempt to parse PIC related stuff */
a1660 30
		/*
		   Any identifier prefixed with '@@' is treated as a
		   symbol.  However there are a few expressions (or rather
		   special cases to be handled) viz. ...@@gotpc, ...@@gotoff,
		   ...@@plt and ...@@h30.  If it is any of these then we have
		   to do some special "PIC related stuff".
		 */

		char *tmpbuf = NULL;
		hold = input_line_pointer;
		tmpbuf = strchr (str, '@@');
		if (tmpbuf
		    && (!strncmp (tmpbuf + 1, "gotpc", 5)
			|| !strncmp (tmpbuf + 1, "gotoff", 6)
			|| !strncmp (tmpbuf + 1, "plt", 3)
			|| !strncmp (tmpbuf + 1, "h30", 3)))
		  *tmpbuf = 0;

		input_line_pointer = str;
		expression (&exp);

		if (tmpbuf
		    && (!strncmp (tmpbuf + 1, "gotpc", 5)
			|| !strncmp (tmpbuf + 1, "gotoff", 6)
			|| !strncmp (tmpbuf + 1, "plt", 3)
			|| !strncmp (tmpbuf + 1, "h30", 3)))
		  *tmpbuf = '@@';
		str = input_line_pointer;
		input_line_pointer = hold;
	      }
d1662 1
a1662 1
		as_bad ("illegal operand");
d1664 1
a1664 1
		as_bad ("missing operand");
d1666 1
a1666 180
		{
		  value = exp.X_add_number;
		  /* Ensure that the constant value is within the
		     operand's limit, for ARCompact ISA */
		  if (!arc_mach_a4)
		    {
		      /* Try next insn syntax, if the current operand being
		         matched is not a constant operand */
		      if (!ac_constant_operand (operand))
			break;
		      switch (operand->fmt)
			{
			case 'u':
			  if (opcode->flags & ARC_INCR_U6)
			    value++;    /* Incrementing value of u6 for pseudo
					   mnemonics of BRcc .  */
			  if ((value < 0) || (value > 63)){
			    match_failed = 1;
                              }
			  break;
			case 'K':
			  if ((value < -2048) || (value > 2047))
			    match_failed = 1;
			  break;
			case 'o':
			  if ((value < -256) || (value > 255))
			    match_failed = 1;
			  break;
			case 'e':
			  if ((value < 0) || (value > 7))
			    match_failed = 1;
			  break;
			case 'E':
			  if ((value < 0) || (value > 31))
			    match_failed = 1;
			  break;
			case 'j':
			  if ((value < 0) || (value > 127))
			    match_failed = 1;
			  break;
			case 'J':
			  if ((value < 0) || (value > 255))
			    match_failed = 1;
			  break;
			case 'k':
			  if ((value % 2) || (value < 0) || (value > 63))
			    match_failed = 1;
			  break;
			case 'l':
			  if ((value % 4) || (value < 0) || (value > 127))
			    match_failed = 1;
			  break;
			case 'm':
			  if ((value % 4) || (value < 0) || (value > 1023))
			    match_failed = 1;
			  break;
			case 'M':
			  if ((value < -256) || (value > 255))
			    match_failed = 1;
			  break;
			case 'O':
			  if ((value % 2) || (value < -512) || (value > 511))
			    match_failed = 1;
			  break;
			case 'R':
			  if ((value % 4) || (value < -1024) || (value > 1023))
			    match_failed = 1;
			  break;
                        case '\24':
                            if((value > 0x3fff) || (value <-(0x3fff)))
                                match_failed = 1;
                            break;
                        case '\20':
                        case '\23': /* discarded constant field */
                            break;
                        case '\21':
                        case '\22':
                            if(value<0||value >0xff)
                                match_failed = 1;
                            break;
                        case '\14': /* signed 12 bit operand */
                            switch(opcode->flags&(ARC_SIMD_SCALE1
  					   | ARC_SIMD_SCALE2
					   | ARC_SIMD_SCALE3
                                           | ARC_SIMD_SCALE4)){
                            case ARC_SIMD_SCALE1:
                                if((value&0x1)!=0)
                                    as_warn("Offset must be divisible by 2.");
                                value = value>>1;
                                if((value>2047)||(value<-2048))
                                    match_failed = 1;
                                break;
                            case ARC_SIMD_SCALE2:
                                if((value&0x3)!=0)
                                    as_warn("Offset must be divisible by 4.");
                                value = value>>2;
                                if((value>2047)||(value<-2048))
                                    match_failed = 1;
                                break;
                            case ARC_SIMD_SCALE3:
                                if((value&0x7)!=0)
                                    as_warn("Offset must be divisible by 8.");
                                value = value>>3;
                                if((value>2047)||(value<-2048))
                                    match_failed = 1;
                                break;
                            case ARC_SIMD_SCALE4:
                                if((value&0xf)!=0)
                                    as_warn("Offset must be divisible by 16.");
                                value = value>>4;
                                if((value>2047)||(value<-2048))
                                    match_failed = 1;
                                break;
                            default:;
                                break;
                            } /* end switch(opcode->flags&&(...)) */
                            break;
			case '?':       /* SIMD Unsigned 8 bit operand */
			  switch (opcode->flags & (ARC_SIMD_SCALE1
						   | ARC_SIMD_SCALE2
						   | ARC_SIMD_SCALE3
						   | ARC_SIMD_SCALE4))
			    {
			    case ARC_SIMD_SCALE1:
			      if (value != ((value >> 1) << 1))
				as_warn ("Offset must be divisible by 2. Truncating last bit ");
			      value = value >> 1;
			      break;

			    case ARC_SIMD_SCALE2:
			      if (value != ((value >> 2) << 2))
				as_warn ("Offset must be divisible by 4. Truncating last 2 bits ");
			      value = value >> 2;
			      break;
			    case ARC_SIMD_SCALE3:
			      if (value != ((value >> 3) << 3))
				as_warn ("Offset must be divisible by 8. Truncating last 3 bits ");
			      value = value >> 3;
			      break;
			    case ARC_SIMD_SCALE4:
			      if (value != ((value >> 4) << 4))
				as_warn ("Offset must be divisible by 16. Truncating last 4 bits ");
			      value = value >> 4;
			      break;
			    default:
			      ;
			    } /* end switch (opcode->flags&&(ARC_SIMD_SCALE1...))*/
/* for compatibility with corner cases of MetaWare assembler allow to -128 */
			  if ((value < -128) || (value > 255)){
			    match_failed = 1;
                              }
			  break;
			} /* end switch(operand->fmt) */

		      if (match_failed)
			break;
		    } /* end if(!arc_mach_a4) */
		} /* else if(exp.X_op==O_constant ) */

	      /* For ARCompact ISA, try next insn syntax if the input operand
		 is a symbol but the current operand being matched is not a
		 symbol operand */
	      else if (!arc_mach_a4 && (exp.X_op == O_symbol)
		       && !ac_symbol_operand (operand)){
                  break;}

	      /* For ARCompact ISA, try next insn syntax if "%st" operand is
		 not being matched with long-immediate operand */
	      else if (!arc_mach_a4 && (exp.X_op == O_right_shift)
		       && (operand->fmt != 'L'))
		break;
			  else if (!arc_mach_a4 && (exp.X_op == O_subtract)
				   && (operand->fmt != 'L')
				   && ( (insn_name[0] == 'a' || insn_name[0] == 'A') && 
						(insn_name[1] == 'd' || insn_name[1] == 'D') && 
						(insn_name[2] == 'd' || insn_name[2] == 'D') ) )
					   {
					
					break;
			  }
d1668 2
a1669 138
		{
		  reg = (struct arc_operand_value *) exp.X_add_number;
		  if (!arc_mach_a4) /* For ARCompact ISA */
		    {
		      /* Try next instruction syntax, if the current operand
			 being matched is not a register operand. */

		      if (!ac_register_operand (operand)
			  && !ARC700_register_simd_operand (operand->fmt))
			break;

		      /* For 16-bit insns, select proper register value */
		      if (compact_insn_16
			  && ((operand->fmt == 'a')
			      || (operand->fmt == 'b')
			      || (operand->fmt == 'c')))
			{
			  int i, l;
			  for (i = 0; i < arc_reg_names_count; i++)
			    {
			      if (!arc_opval_supported (&arc_reg_names[i]))
				continue;
			      l = strlen (arc_reg_names[i].name);
			      if ((arc_reg_names[i].flags & ARC_REGISTER_16)
				  && !strncmp (reg->name,
					       arc_reg_names[i].name, l)
				  && !ISALNUM (*(reg->name + l)))
				{
				  reg = &arc_reg_names[i];
				  break;
				}
			    } /* end for(i=0;i<arc_reg_names_count; i++ ) */
			  if (i == arc_reg_names_count)
			    break;
			} /* end if(compact_insn_16...) */

		      /* Ashwin: For SIMD instructions checking if its any
			 of the SIMD register.*/
		      if (ARC700_register_simd_operand (operand->fmt)
			  && !ac_register_operand (operand))
			{

			  struct arc_ext_operand_value *ext_oper
			    = arc_ext_operands;

			  while (ext_oper)
			    {
			      short flg = 0;

			      switch (ext_oper->operand.flags
				      & (ARC_REGISTER_SIMD_VR
					 | ARC_REGISTER_SIMD_I
					 | ARC_REGISTER_SIMD_K
					 | ARC_REGISTER_SIMD_DR))
				{
				case ARC_REGISTER_SIMD_VR:
				  if ((ARC700_register_simd_operand
				       (operand->fmt) == 1)
				      && !strcmp (reg->name,
						  ext_oper->operand.name))
				    flg = 1;
				  break;
				case ARC_REGISTER_SIMD_I:
				  if ((ARC700_register_simd_operand
				       (operand->fmt) == 3)
				      && !strcmp (reg->name,
						  ext_oper->operand.name))
				    flg = 1;
				  break;
				case ARC_REGISTER_SIMD_K:
				  if ((ARC700_register_simd_operand
				       (operand->fmt) == 4)
				      && !strcmp (reg->name,
						  ext_oper->operand.name))
				    flg = 1;
				  break;
				case ARC_REGISTER_SIMD_DR:
				  if ((ARC700_register_simd_operand
				       (operand->fmt) == 2)
				      && !strcmp (reg->name,
						  ext_oper->operand.name))
				    flg = 1;
				  break;
				default:
				  break;
				}
			      if (flg){
				break;
                                  }
			      ext_oper = ext_oper->next;
			    } /* end while(ext_oper ) */

			  if (!ext_oper)
			    break; /* Move on to next syntax.  */
			}

		      /*Ashwin: Checking if SIMD registers dont try to sub
			any of the Core registers. */
		      if (!ARC700_register_simd_operand (operand->fmt))
			{
			  if ((reg->flags & ARC_REGISTER_SIMD_VR )
			      || (reg->flags & ARC_REGISTER_SIMD_I )
			      || (reg->flags & ARC_REGISTER_SIMD_K )
			      || (reg->flags & ARC_REGISTER_SIMD_DR)
			     )
			    break;
			}


		      /* For conditional code instruction (ex: addeq) and
			 some 16-bit insns, the destination register should
			 be same as that of first source register. Ensure
			 that same register is matched for first and second
			 occurance of the operand's format 'B'(or 'b') in the
			 instruction's syntax being matched */
		      /* Added # as destination version of B */
		      if ((*syn == 'B') || (*syn == 'b') || (*syn == '#'))
			{
			  if (regb_p && regb != reg)
			    {
			      break;
			    }
			  else
			    {
			      regb_p = 1;
			      regb = reg;
			    }
			}

		      /* Try next insn syntax, if input operand is a auxiliary
			 regiser but the current operand being matched is
			 not a auxiliary register */
		      if ((arc_operands[reg->type].fmt == 'G')
			  && !(mods & ARC_MOD_AUXREG))
			break;
		    }
		}
#define IS_REG_DEST_OPERAND(o) (((o) == 'a') || (!arc_mach_a4 && (o) == 'A'))
d1671 1
a1671 1
		as_bad ("symbol as destination register");
a1673 1
		  int sda_seen_p = 0;
a1678 117
		  else
		    {
		

     
 			int needGOTSymbol = 0;
		      if (strchr (str, '@@'))
			{
			  if (!strncmp (str, "@@gotpc", 6))
			    {
			      str += 6;
			      if (arc_mach_type != bfd_mach_arc_arc700)
				as_warn ("PIC not supported for processors prior to ARC 700\n");
			      else
				current_special_sym_flag = GOT_TYPE;

				  needGOTSymbol = 1;
			    }
			  else if (!strncmp (str, "@@plt", 4))
			    {
			      str += 4;
			      if (arc_mach_type != bfd_mach_arc_arc700)
				as_warn ("PIC not supported for processors prior to ARC 700\n");
			      else
				current_special_sym_flag = PLT_TYPE;
				  needGOTSymbol = 1;
			    }
			  else if (!strncmp (str, "@@gotoff", 7))
			    {
			      if (arc_mach_type != bfd_mach_arc_arc700)
				as_warn ("PIC not supported for processors prior to ARC 700\n");
			      else
				current_special_sym_flag = GOTOFF_TYPE;

			      /* Now check for identifier@@gotoff+constant */
			      if (*(str + 7) == '-' || *(str + 7) == '+')
				{
				  char *orig_line = input_line_pointer;
				  expressionS new_exp;

				  input_line_pointer = str + 7;
				  expression (&new_exp);
				  if (new_exp.X_op == O_constant)
				    {
				      exp.X_add_number += new_exp.X_add_number;
				      str = input_line_pointer;
				    }
				  if (input_line_pointer != str)
				    input_line_pointer = orig_line;
				}
			      else
				str += 7;
				needGOTSymbol = 1;
			    }
			  else
			    {
			      if (!strncmp (str, "@@sda", 3))
				{
				  //	 	  fprintf (stderr, "sda seen\n");
				  if (!(mods & ARC_MOD_SDASYM))
				    {
				      //  fprintf (stderr, "Error: failed to match\n");
				      break;
				    }

				  sda_seen_p = 1;
				  current_special_sym_flag = SDA_REF_TYPE;
				  str += 4;

				  /* Now check for identifier@@sda+constant */
				  if (*(str) == '-' || *(str) == '+')
				    {
				      char *orig_line = input_line_pointer;
				      expressionS new_exp;

				      input_line_pointer = str + (*(str) == '+');
				      expression (&new_exp);
				      if (new_exp.X_op == O_constant)
					{
					  exp.X_add_number
					    += new_exp.X_add_number;
					  str = input_line_pointer;
					}
				      //     if (input_line_pointer != str)
				      input_line_pointer = orig_line;
				    }
					needGOTSymbol = 1;
				}
			    }

			/* Force GOT symbols to be limm in case of ld (@@gotpc & @@gotoff) instruction: 	workaround*/			

			if (arc_cond_p ==0 && 
			current_special_sym_flag != SDA_REF_TYPE &&
			 needGOTSymbol == 1 && 
			(insn_name[0] == 'l' || insn_name[0] == 'L') &&
			 (insn_name[1] == 'd' || insn_name[1] == 'D') &&
			 (!(insn_name[2] == '_')) ) {
				break;
			}
			  /*
			     In any of the above PIC related cases we would
			     have to make a GOT symbol if it is NULL
			   */
			  if (needGOTSymbol && (GOT_symbol == NULL) )
			    GOT_symbol
			      = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);
			}
		      else if (mods & ARC_MOD_SDASYM)
			{
			  //			  fprintf (stderr, "Not the sda syntax string. Trying next ********\n");
			  break;
			}

		    }


d1681 1
a1681 1
		    as_fatal ("too many fixups");
a1682 2
		  fixups[fc].modifier_flags = mods;

d1685 3
a1687 5
/*
		 #define IS_REG_SHIMM_OFFSET(o) ((o) == 'd')
		 if (IS_REG_SHIMM_OFFSET (*syn))
		 break;
*/
d1705 1
a1705 2
			(insn, &insn2,operand, mods, reg, 0L, &junk);
		      fixups[fc].opindex = arc_operand_map[0];
a1712 4
	      /* The sda modifier is allowed only with symbols */
	      if ((mods & ARC_MOD_SDASYM) && exp.X_op != O_symbol)
		break;

d1717 1
a1717 1
		  insn = (*operand->insert) (insn,&insn2, operand, mods,
a1724 1
                          assembling_instruction = 0;
a1731 19
	      else if (!arc_mach_a4)
		{
		  switch (operand->fmt)
		    {
		    case 'K':
		      insn |= ((value & 0x3f) << operand->shift);
                      insn |= ((value >>6 ) & 0x3f);
		      break;
		    case 'l':
		      insn |= (value >> 2) << operand->shift;
		      break;
		    case 'E':
		      insn |= value << operand->shift;
		      break;
		    default:
		      insn |= ((value & ((1 << operand->bits) - 1))
			       << operand->shift);
		    }
		}
d1737 2
a1738 1
	} /* end for(str=start,...) */
d1746 1
a1746 46
          const char *errmsg=0;
	  const struct arc_operand *operand;
          if(!lm_present && !(opcode->flags & AC_SIMD_SETLM))
              insn2 |= (0xff << 15);
          if(opcode->flags & ARC_SIMD_ZERVA){
              operand = &arc_operands[arc_operand_map[zer_rega.type]];
              if(operand->insert){
		  insn = (*operand->insert) (insn,&insn2, operand, mods,
					     &zer_rega, (long)zer_rega.value, &errmsg);
                  }
              else
                  {
                  insn |= ((zer_rega.value & ((1 << operand->bits) - 1)) <<
                      operand->shift);
                  }

              }
          if(opcode->flags & ARC_SIMD_ZERVB){
              operand = &arc_operands[arc_operand_map[zer_regb.type]];
              if(operand->insert){
		  insn = (*operand->insert) (insn,&insn2, operand, mods,
					     &zer_regb, (long)zer_regb.value, &errmsg);
                  }
              else
                  {
                  insn |= ((zer_regb.value & ((1 << operand->bits) - 1)) <<
                      operand->shift);
                  }


              }
          if(opcode->flags & ARC_SIMD_ZERVC){
              operand = &arc_operands[arc_operand_map[zer_regc.type]];
              if(operand->insert){
		  insn = (*operand->insert) (insn,&insn2, operand, mods,
					     &zer_regc, (long)zer_regc.value, &errmsg);
                  }
              else
                  {
                  insn |= ((zer_regc.value & ((1 << operand->bits) - 1)) <<
                      operand->shift);
                  }
              }
          if(opcode->flags&ARC_SIMD_SETLM){
              insn2 |= (0x3f)<<23;
              }
d1756 1
a1756 1
	    as_bad ("junk at end of line: `%s'", str);
a1759 4
          if(insn>>27==0x0a){
              limm_p = 1;
              limm = insn2;
              }
a1779 1
		  case 'N':
a1783 9
		    if (arc_mach_type != bfd_mach_arc_arc700
		       && conditional > 15
		       && !ext_suffix_p)
		      {
			/* It is invalid for the ARC 600 and
			   A5 to have condition codes ss and sc
			 */
			as_bad ("Invalid condition code \n");
		      }
a1790 3
	    insert_last_insn (insn, delay_slot_type, limm_p,
			      fixups[0].exp.X_add_symbol);

d1795 1
a1795 2
	      as_warn ("8 byte instruction in delay slot");

d1797 2
a1798 31
	      && limm_p && arc_insn_not_jl (insn)) /* except for jl  addr */
	      as_bad ("8 byte jump instruction with delay slot");

	    if (in_delay_slot_p)
	      {
		if (!arc_mach_a4)
		  {
		    if (ac_branch_or_jump_insn (insn, compact_insn_16)) {

		      as_bad ("branch/jump instruction in delay slot");
			}
		    else if (ac_lpcc_insn (insn))
		      as_bad ("lpcc instruction in delay slot");
		    else if (ARC700_rtie_insn (insn))
		      as_bad ("rtie instruction in delay slot");
		  }

		if (arc_mach_type != bfd_mach_arc_arc700)
		  {
		    if (a4_brk_insn (insn))
		      as_bad ("brk instruction in delay slot");
		    else if (ac_brk_s_insn (insn))
		      as_bad ("brk_s instruction in delay slot");
		  }
	      }

	    if (ac_lpcc_insn (insn))
	      {
		add_loop_target ((fixups[0].exp).X_add_symbol);
	      }

d1805 2
a1806 2
		&& prev_insn_needs_cc_nop_p && arc_mach_type == bfd_mach_arc_a5)
	      as_warn ("conditional branch follows set of flags");
d1819 4
a1822 22
	      if (compact_insn_16)
		{
		  f = frag_more (6);
		  md_number_to_chars (f, insn, 2);
		  md_number_to_chars (f + 2, limm, -4);
		  dwarf2_emit_insn (6);
		}
	      else
		{
		  f = frag_more (8);
		  if (arc_mach_a4)
		    {
		      md_number_to_chars (f, insn, 4);
		      md_number_to_chars (f + 4, limm, 4);
		    }
		  else
		    {
		      md_number_to_chars (f, insn, -4);
		      md_number_to_chars (f + 4, limm, -4);
		    }
		  dwarf2_emit_insn (8);
		}
d1829 3
a1831 19
	      if (compact_insn_16)
		{
		  f = frag_more (2);
		  md_number_to_chars (f, insn, 2);
		  dwarf2_emit_insn (2);
		}
	      else
		{
		  f = frag_more (4);
		  if (arc_mach_a4)
		    {
		      md_number_to_chars (f, insn, 4);
		    }
		  else
		    {
		      md_number_to_chars (f, insn, -4);
		    }
		  dwarf2_emit_insn (4);
		}
d1837 1
a1837 7
	      int op_type;
	      bfd_reloc_code_real_type reloc_type;

	      int offset = 0; /* offset of the location within the frag where
				 the fixup occurs. */
	      int size = 4;   /* size of the fixup; mostly used for error
				 checking */
d1853 1
a1853 1
	      {
d1859 6
a1864 12
		      || (arc_mach_a4 && op_type == arc_operand_map['s'])
		      || (arc_mach_a4 && op_type == arc_operand_map['o'])
		      || (arc_mach_a4 && op_type == arc_operand_map['O']))
		  {
		      reloc_type = (arc_mach_a4) ? BFD_RELOC_32 : BFD_RELOC_ARC_32_ME;
		      GAS_DEBUG_PIC (reloc_type);
		  }
		  else if (arc_mach_a4 && (op_type == arc_operand_map['J']))
		  {
		      reloc_type = BFD_RELOC_ARC_B26;
		      GAS_DEBUG_PIC (reloc_type);
		  }
d1866 1
a1866 1
		      abort ();
d1870 1
a1870 2
		  GAS_DEBUG_PIC (reloc_type);
	      }
a1876 17
	      switch (current_special_sym_flag)
	      {
	      case SDA_REF_TYPE:
		reloc_type = arc_get_sda_reloc (insn, compact_insn_16);
		break;
	      case GOT_TYPE:
		  reloc_type = BFD_RELOC_ARC_GOTPC32;
		  break;
	      case PLT_TYPE:
		  reloc_type = BFD_RELOC_ARC_PLT32;
		  break;
	      case GOTOFF_TYPE:
		  reloc_type = BFD_RELOC_ARC_GOTOFF;
		  break;
	      default:
		break;
	      }
a1877 23

	      /* Calculate appropriate offset and size for the fixup */
	      if (compact_insn_16)
		{
		  /* If limm is needed */
		  if ((operand->flags & ARC_OPERAND_LIMM)
		      && (!(fixups[i].modifier_flags & ARC_MOD_SDASYM) || ac_add_reg_sdasym_insn (insn)))
		    {
		      offset = 2;
		    }
		  else
		    {
		      size = 2;
		    }
		}
	      else /* for 32-bit instructions */
		{
		  /* If limm is needed */
		  if ((operand->flags & ARC_OPERAND_LIMM)
		      && (!(fixups[i].modifier_flags & ARC_MOD_SDASYM) || ac_add_reg_sdasym_insn (insn)))
		    offset = 4;
		}

d1879 2
a1880 3
			   ((f - frag_now->fr_literal) + offset),
			   /* + (operand->flags & ARC_OPERAND_LIMM ? 4 : 0)),*/
			   size,
a1881 1
			   (current_special_sym_flag == PLT_TYPE)?0:
a1884 1
	  assembling_instruction = 0;
a1886 2

      /* Try the next entry.  */
d1889 2
a1890 3
  if (NULL == last_errmsg){
    as_bad ("bad instruction `%s'", start);
      }
a1892 82
  assembling_instruction = 0;
}

/* Frobbers.  */

#if 0
/* Set the real name if the .rename pseudo-op was used.
   Return 1 if the symbol should not be included in the symbol table.  */

int
arc_frob_symbol (sym)
     symbolS *sym;
{
  if (sym->sy_tc.real_name != (char *) NULL)
    S_SET_NAME (sym, sym->sy_tc.real_name);

  return 0;
}
#endif
/*
 * Here we decide which fixups can be adjusted to make them relative to
 * the beginning of the section instead of the symbol.  Basically we need
 * to make sure that the dynamic relocations are done correctly, so in
 * some cases we force the original symbol to be used.
 */
int
tc_arc_fix_adjustable (fixP)
     fixS * fixP;
{

  /* Prevent all adjustments to global symbols. */
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;
  /* adjust_reloc_syms doesn't know about the GOT */
  if (fixP->fx_r_type == BFD_RELOC_ARC_GOTPC32
      || fixP->fx_r_type == BFD_RELOC_ARC_PLT32)
    return 0;
  return 1;
}

/* This is a function to handle alignment and fill in the
   gaps created with nop/nop_s.
*/
void
arc_handle_align (fragS* fragP)
{
  if ((fragP)->fr_type == rs_align_code)
    { 
      char *dest = (fragP)->fr_literal + (fragP)->fr_fix;
      int pad_bytes_a4;
      valueT count = ((fragP)->fr_next->fr_address
		      - (fragP)->fr_address - (fragP)->fr_fix);

      pad_bytes_a4    = ((count & 3));
      (fragP)->fr_var = (arc_mach_a4 ? 4  : 2);
       
      if (arc_mach_a4)
	{
	  if (pad_bytes_a4)
	    {
	      (fragP)->fr_fix += pad_bytes_a4;
	      do/* Padding in the gap till the next 4-byte boundary
		   with 0s.  */
		{
		  *dest++ = 0;
		  pad_bytes_a4--;
		}
	      while (pad_bytes_a4);
	    }
	  md_number_to_chars (dest, 0x7fffffff, 4); /* writing nop */
	}
       else
	{
	  if (count & 1)/* Padding in the gap till the next 2-byte boundary
			   with 0s.  */
	    {
	      (fragP)->fr_fix++;
	      *dest++ = 0;
	    }
	  md_number_to_chars (dest, 0x78e0, 2);  /*writing nop_s */
	}
    }
@


1.42
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1036 1
a1036 1
  as_fatal (_("md_estimate_size_before_relax\n"));
d1047 1
a1047 1
  as_fatal (_("md_convert_frag\n"));
@


1.41
log
@PR gas/5121 gas/5122 gas/5123 gas/5124 gas/5125 gas/5126 gas/5129 gas/5131 gas/5132 gas/5137 gas/5143
* Makefile.am (CFILES): Add cgen.c
  (TARGET_CPU_CFILES): Add tc-iq2000.c, tc-maxq.c, tc-mt.c, tc-tic4x.c and xtensa-relax.c.
  (TARGET_CPU_HFILES): Add tc-iq2000.h, tc-maxq.h, tc-mt.h, tc-tic4x.h and xtensa-relax.h.
  (TARG_ENV_HFILES): Remove te-aux.h, te-delta.h, te-delt88.h, te-ic960.h, te-linux.h.
   Add te-aix5.h, te-armeabi.h, te-freebsd.h, te-gnu.h, te-interix.h, te-vxworks.h.
  (CONFIG_ATOF_CFILES): New variable.
  (POTFILES): Add CONFIG_ATOF_CFILES to dependencies.  Fix typo with dependency upon TARG_ENV_HFILES.
  (DEPTC): Do not put "#include opcodes/<foo>-desc.h" into cgen-desc.h when foo-desc.h does not exit.
   Run make dep-am.
* Makefile.in: Regenerate.
* doc/Makefile.in: Regenerate.
* po/POTFILES.in: Regenerate.
* po/es.po: Regenerate.
* po/fr.po: Regenerate.
* po/gas.pot: Regenerate.
* po/rw.po: Regenerate.
* po/tr.po: Regenerate.
* config/obj-elf.c (obj_elf_vtable_inherit): Allow for translation of error messages.
* config/obj-som.c: Likewise.
* config/tc-arc.c: Likewise.
* config/tc-arm.c: Likewise.
* config/tc-bfin.c: Likewise.
* config/tc-frv.c: Likewise.
@
text
@a1001 8
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c  */
#define MAX_LITTLENUMS 6

d1005 1
a1005 33
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
      prec = 2;
      break;

    case 'd':
    case 'D':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return "bad call to md_atof";
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return NULL;
@


1.40
log
@Switch to GPLv3
@
text
@d194 1
a194 1
    as_warn ("could not set architecture and machine");
d212 1
a212 1
    as_fatal ("virtual memory exhausted");
d215 1
a215 1
    as_warn ("could not set architecture and machine");
d432 1
a432 1
      as_bad ("expected comma after operand name");
d443 1
a443 1
      as_bad ("negative operand number %d", number);
d455 1
a455 1
	  as_bad ("expected comma after register-number");
d480 1
a480 1
		  as_bad ("invalid mode");
d497 1
a497 1
	      as_bad ("expected comma after register-mode");
d514 1
a514 1
		  as_bad ("shortcut designator invalid");
d529 1
a529 1
      as_bad ("core register value (%d) too large", number);
d537 1
a537 1
      as_bad ("condition code value (%d) too large", number);
d554 1
a554 1
	      as_bad ("attempt to override symbol: %s", name);
d625 1
a625 1
      as_bad ("invalid opertype");
d670 1
a670 1
      as_bad ("expected comma after operand name");
d682 1
a682 1
      as_bad ("expected comma after opcode");
d692 1
a692 1
      as_bad ("negative subopcode %d", subopcode);
d701 1
a701 1
	  as_bad ("subcode value found when opcode not equal 0x03");
d709 1
a709 1
	      as_bad ("invalid subopcode %d", subopcode);
d720 1
a720 1
      as_bad ("expected comma after subopcode");
d739 1
a739 1
      as_bad ("invalid suffix class");
d748 1
a748 1
      as_bad ("expected comma after suffix class");
d767 1
a767 1
      as_bad ("invalid syntax class");
d774 1
a774 1
      as_bad ("opcode 0x3 and SYNTAX_3OP invalid");
d794 1
a794 1
      as_bad ("unknown suffix class");
d861 1
a861 1
      as_bad ("expected comma after symbol name");
d871 1
a871 1
      as_bad ("negative symbol length");
d882 1
a882 1
      as_bad ("ignoring attempt to re-define symbol");
d889 1
a889 1
      as_warn ("length of symbol \"%s\" already %ld, ignoring %d",
d903 1
a903 1
	  as_warn ("assuming symbol alignment of zero");
d970 1
a970 1
      as_bad ("\".option\" directive must appear before any instructions");
d980 1
a980 1
      as_bad ("\".option\" directive conflicts with initial definition");
d988 1
a988 1
	as_warn ("\".option\" directive overrides command-line (default) value");
d991 1
a991 1
	as_fatal ("could not set architecture and machine");
d998 1
a998 1
  as_bad ("invalid identifier for \".option\"");
d1120 1
a1120 1
    as_bad ("expression too complex code symbol");
d1147 1
a1147 1
	  as_bad ("missing ')' in %%-op");
d1348 1
a1348 1
			"unresolved expression that must be resolved");
d1402 1
a1402 1
		    "internal error: can't export reloc type %d (`%s')",
d1534 1
a1534 1
	    as_fatal ("unknown syntax format character `%c'", *syn);
d1672 1
a1672 1
		    as_bad ("too many suffixes");
d1702 1
a1702 1
		as_bad ("illegal operand");
d1704 1
a1704 1
		as_bad ("missing operand");
d1711 1
a1711 1
		as_bad ("symbol as destination register");
d1721 1
a1721 1
		    as_fatal ("too many fixups");
d1796 1
a1796 1
	    as_bad ("junk at end of line: `%s'", str);
d1835 1
a1835 1
	      as_warn ("8 byte instruction in delay slot");
d1838 1
a1838 1
	      as_warn ("8 byte jump instruction with delay slot");
d1846 1
a1846 1
	      as_warn ("conditional branch follows set of flags");
d1930 1
a1930 1
    as_bad ("bad instruction `%s'", start);
@


1.39
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   2006  Free Software Foundation, Inc.
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.38
log
@Fix casts to allow for a 64-bit host.
@
text
@a22 2
#include <stdio.h>
#include "libiberty.h"
@


1.37
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d249 1
a249 1
					  (int) &arc_reg_names[i],
d553 1
a553 1
	    S_SET_VALUE (symbolP, (int) &ext_oper->operand);
d567 2
a568 1
					      (int) &ext_oper->operand, &zero_address_frag));
d1169 1
a1169 1
	      expressionP->X_add_number = (int) &ext_oper->operand;
d1181 1
a1181 1
	      expressionP->X_add_number = (int) &arc_reg_names[i];
@


1.36
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d1217 1
a1217 1
  expr (0, exp);
@


1.35
log
@Update the address and phone number of the FSF
@
text
@d1272 1
a1272 1
md_apply_fix3 (fixS *fixP, valueT * valP, segT seg)
d1887 1
a1887 1
		 feature.  We pick a BFD reloc type in md_apply_fix3.
@


1.34
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.33
log
@2005-03-03  Ramana Radhakrishnan  <ramana.radhakrishnan@@codito.com>

        * config/tc-arc.c(md_assemble): Remove dead code for handling
        immediate indexing with ld and st.
@
text
@d34 2
a35 22
extern int arc_get_mach PARAMS ((char *));
extern int arc_operand_type PARAMS ((int));
extern int arc_insn_not_jl PARAMS ((arc_insn));
extern int arc_limm_fixup_adjust PARAMS ((arc_insn));
extern int arc_get_noshortcut_flag PARAMS ((void));
extern int arc_set_ext_seg PARAMS ((void));
extern void arc_code_symbol PARAMS ((expressionS *));

static arc_insn arc_insert_operand PARAMS ((arc_insn,
					    const struct arc_operand *, int,
					    const struct arc_operand_value *,
					    offsetT, char *, unsigned int));
static void arc_common PARAMS ((int));
static void arc_extinst PARAMS ((int));
static void arc_extoper PARAMS ((int));
static void arc_option PARAMS ((int));
static int  get_arc_exp_reloc_type PARAMS ((int, int, expressionS *,
					   expressionS *));

static void init_opcode_tables PARAMS ((int));

const struct suffix_classes {
d38 2
a39 1
} suffixclass[] = {
d48 2
a49 1
const struct syntax_classes {
d53 2
a54 1
} syntaxclass[] = {
a64 22
const pseudo_typeS md_pseudo_table[] = {
  { "align", s_align_bytes, 0 }, /* Defaulting is invalid (0).  */
  { "comm", arc_common, 0 },
  { "common", arc_common, 0 },
  { "lcomm", arc_common, 1 },
  { "lcommon", arc_common, 1 },
  { "2byte", cons, 2 },
  { "half", cons, 2 },
  { "short", cons, 2 },
  { "3byte", cons, 3 },
  { "4byte", cons, 4 },
  { "word", cons, 4 },
  { "option", arc_option, 0 },
  { "cpu", arc_option, 0 },
  { "block", s_space, 0 },
  { "extcondcode", arc_extoper, 0 },
  { "extcoreregister", arc_extoper, 1 },
  { "extauxregister", arc_extoper, 2 },
  { "extinstruction", arc_extinst, 0 },
  { NULL, 0, 0 },
};

d108 14
a121 2
struct option md_longopts[] = {
#define OPTION_EB (OPTION_MD_BASE + 0)
a122 1
#define OPTION_EL (OPTION_MD_BASE + 1)
a123 1
#define OPTION_ARC5 (OPTION_MD_BASE + 2)
a125 1
#define OPTION_ARC6 (OPTION_MD_BASE + 3)
a126 1
#define OPTION_ARC7 (OPTION_MD_BASE + 4)
a127 1
#define OPTION_ARC8 (OPTION_MD_BASE + 5)
a128 1
#define OPTION_ARC (OPTION_MD_BASE + 6)
d143 1
a143 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d175 1
a175 2
md_show_usage (stream)
     FILE *stream;
d190 1
a190 1
md_begin ()
d206 1
d208 1
a208 2
init_opcode_tables (mach)
     int mach;
d229 1
a229 1
	hash_insert (arc_suffix_hash, arc_suffixes[i].name, (PTR) (arc_suffixes + i));
d261 7
a267 8
arc_insert_operand (insn, operand, mods, reg, val, file, line)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     offsetT val;
     char *file;
     unsigned int line;
d317 2
a318 1
struct arc_fixup {
d328 20
a347 1
/* This routine is called for each instruction to be assembled.  */
d349 5
a353 3
void
md_assemble (str)
     char *str;
d355 27
a381 7
  const struct arc_opcode *opcode;
  const struct arc_opcode *std_opcode;
  struct arc_opcode *ext_opcode;
  char *start;
  const char *last_errmsg = 0;
  arc_insn insn;
  static int init_tables_p = 0;
d383 8
a390 3
  /* Opcode table initialization is deferred until here because we have to
     wait for a possible .option command.  */
  if (!init_tables_p)
d392 3
a394 2
      init_opcode_tables (arc_mach_type);
      init_tables_p = 1;
d396 16
d413 2
a414 3
  /* Skip leading white space.  */
  while (ISSPACE (*str))
    str++;
d416 3
a418 2
  /* The instructions are stored in lists hashed by the first letter (though
     we needn't care how they're hashed).  Get the first in the list.  */
d420 6
a425 2
  ext_opcode = arc_ext_opcodes;
  std_opcode = arc_opcode_lookup_asm (str);
d427 4
a430 1
  /* Keep looking until we find a match.  */
d432 1
a432 6
  start = str;
  for (opcode = (ext_opcode ? ext_opcode : std_opcode);
       opcode != NULL;
       opcode = (ARC_OPCODE_NEXT_ASM (opcode)
		 ? ARC_OPCODE_NEXT_ASM (opcode)
		 : (ext_opcode ? ext_opcode = NULL, std_opcode : NULL)))
d434 5
a438 9
      int past_opcode_p, fc, num_suffixes;
      int fix_up_at = 0;
      char *syn;
      struct arc_fixup fixups[MAX_FIXUPS];
      /* Used as a sanity check.  If we need a limm reloc, make sure we ask
	 for an extra 4 bytes from frag_more.  */
      int limm_reloc_p;
      int ext_suffix_p;
      const struct arc_operand_value *insn_suffixes[MAX_SUFFIXES];
d440 2
a441 3
      /* Is this opcode supported by the selected cpu?  */
      if (! arc_opcode_supported (opcode))
	continue;
d443 7
a449 1
      /* Scan the syntax string.  If it doesn't match, try the next one.  */
d451 3
a453 7
      arc_opcode_init_insert ();
      insn = opcode->value;
      fc = 0;
      past_opcode_p = 0;
      num_suffixes = 0;
      limm_reloc_p = 0;
      ext_suffix_p = 0;
d455 1
a455 3
      /* We don't check for (*str != '\0') here because we want to parse
	 any trailing fake arguments in the syntax string.  */
      for (str = start, syn = opcode->syntax; *syn != '\0';)
d457 8
a464 2
	  int mods;
	  const struct arc_operand *operand;
d466 13
a478 2
	  /* Non operand chars must match exactly.  */
	  if (*syn != '%' || *++syn == '%')
d480 1
a480 1
	     if (*str == *syn)
d482 4
a485 4
		  if (*syn == ' ')
		    past_opcode_p = 1;
		  ++syn;
		  ++str;
d488 4
a491 2
		break;
	      continue;
d493 5
a497 4

	  /* We have an operand.  Pick out any modifiers.  */
	  mods = 0;
	  while (ARC_MOD_P (arc_operands[arc_operand_map[(int) *syn]].flags))
d499 4
a502 2
	      mods |= arc_operands[arc_operand_map[(int) *syn]].flags & ARC_MOD_BITS;
	      ++syn;
a503 3
	  operand = arc_operands + arc_operand_map[(int) *syn];
	  if (operand->fmt == 0)
	    as_fatal ("unknown syntax format character `%c'", *syn);
d505 3
a507 1
	  if (operand->flags & ARC_OPERAND_FAKE)
d509 2
a510 25
	      const char *errmsg = NULL;
	      if (operand->insert)
		{
		  insn = (*operand->insert) (insn, operand, mods, NULL, 0, &errmsg);
		  if (errmsg != (const char *) NULL)
		    {
		      last_errmsg = errmsg;
		      if (operand->flags & ARC_OPERAND_ERROR)
			{
			  as_bad (errmsg);
			  return;
			}
		      else if (operand->flags & ARC_OPERAND_WARN)
			as_warn (errmsg);
		      break;
		    }
		  if (limm_reloc_p
		      && (operand->flags && operand->flags & ARC_OPERAND_LIMM)
		      && (operand->flags &
			  (ARC_OPERAND_ABSOLUTE_BRANCH | ARC_OPERAND_ADDRESS)))
		    {
		      fixups[fix_up_at].opindex = arc_operand_map[operand->fmt];
		    }
		}
	      ++syn;
d512 1
a512 2
	  /* Are we finished with suffixes?  */
	  else if (!past_opcode_p)
d514 1
a514 13
	      int found;
	      char c;
	      char *s, *t;
	      const struct arc_operand_value *suf, *suffix_end;
	      const struct arc_operand_value *suffix = NULL;

	      if (!(operand->flags & ARC_OPERAND_SUFFIX))
		abort ();

	      /* If we're at a space in the input string, we want to skip the
		 remaining suffixes.  There may be some fake ones though, so
		 just go on to try the next one.  */
	      if (*str == ' ')
d516 4
a519 10
		  ++syn;
		  continue;
		}

	      s = str;
	      if (mods & ARC_MOD_DOT)
		{
		  if (*s != '.')
		    break;
		  ++s;
d523 1
a523 7
		  /* This can happen in "b.nd foo" and we're currently looking
		     for "%q" (ie: a condition code suffix).  */
		  if (*s == '.')
		    {
		      ++syn;
		      continue;
		    }
d525 11
d537 7
a543 17
	      /* Pick the suffix out and look it up via the hash table.  */
	      for (t = s; *t && ISALNUM (*t); ++t)
		continue;
	      c = *t;
	      *t = '\0';
	      if ((suf = get_ext_suffix (s)))
		ext_suffix_p = 1;
	      else
		suf = hash_find (arc_suffix_hash, s);
	      if (!suf)
		{
		  /* This can happen in "blle foo" and we're currently using
		     the template "b%q%.n %j".  The "bl" insn occurs later in
		     the table so "lle" isn't an illegal suffix.  */
		  *t = c;
		  break;
		}
d545 1
a545 37
	      /* Is it the right type?  Note that the same character is used
		 several times, so we have to examine all of them.  This is
		 relatively efficient as equivalent entries are kept
		 together.  If it's not the right type, don't increment `str'
		 so we try the next one in the series.  */
	      found = 0;
	      if (ext_suffix_p && arc_operands[suf->type].fmt == *syn)
		{
		  /* Insert the suffix's value into the insn.  */
		  *t = c;
		  if (operand->insert)
		    insn = (*operand->insert) (insn, operand,
					       mods, NULL, suf->value,
					       NULL);
		  else
		    insn |= suf->value << operand->shift;
		  suffix = suf;
		  str = t;
		  found = 1;
		}
	      else
		{
		  *t = c;
		  suffix_end = arc_suffixes + arc_suffixes_count;
		  for (suffix = suf;
		       suffix < suffix_end && strcmp (suffix->name, suf->name) == 0;
		       ++suffix)
		    {
		      if (arc_operands[suffix->type].fmt == *syn)
			{
			  /* Insert the suffix's value into the insn.  */
			  if (operand->insert)
			    insn = (*operand->insert) (insn, operand,
						       mods, NULL, suffix->value,
						       NULL);
			  else
			    insn |= suffix->value << operand->shift;
d547 7
a553 18
			  str = t;
			  found = 1;
			  break;
			}
		    }
		}
	      ++syn;
	      if (!found)
		/* Wrong type.  Just go on to try next insn entry.  */
		;
	      else
		{
		  if (num_suffixes == MAX_SUFFIXES)
		    as_bad ("too many suffixes");
		  else
		    insn_suffixes[num_suffixes++] = suffix;
		}
	    }
a554 1
	    /* This is either a register or an expression of some kind.  */
d556 28
a583 4
	      char *hold;
	      const struct arc_operand_value *reg = NULL;
	      long value = 0;
	      expressionS exp;
d585 1
a585 2
	      if (operand->flags & ARC_OPERAND_SUFFIX)
		abort ();
d587 45
a631 5
	      /* Is there anything left to parse?
		 We don't check for this at the top because we want to parse
		 any trailing fake arguments in the syntax string.  */
	      if (is_end_of_line[(unsigned char) *str])
		break;
d633 1
a633 6
	      /* Parse the operand.  */
	      hold = input_line_pointer;
	      input_line_pointer = str;
	      expression (&exp);
	      str = input_line_pointer;
	      input_line_pointer = hold;
d635 1
a635 55
	      if (exp.X_op == O_illegal)
		as_bad ("illegal operand");
	      else if (exp.X_op == O_absent)
		as_bad ("missing operand");
	      else if (exp.X_op == O_constant)
		{
		  value = exp.X_add_number;
		}
	      else if (exp.X_op == O_register)
		{
		  reg = (struct arc_operand_value *) exp.X_add_number;
		}
#define IS_REG_DEST_OPERAND(o) ((o) == 'a')
	      else if (IS_REG_DEST_OPERAND (*syn))
		as_bad ("symbol as destination register");
	      else
		{
		  if (!strncmp (str, "@@h30", 4))
		    {
		      arc_code_symbol (&exp);
		      str += 4;
		    }
		  /* We need to generate a fixup for this expression.  */
		  if (fc >= MAX_FIXUPS)
		    as_fatal ("too many fixups");
		  fixups[fc].exp = exp;
		  /* We don't support shimm relocs. break here to force
		     the assembler to output a limm.  */
#define IS_REG_SHIMM_OFFSET(o) ((o) == 'd')
		  if (IS_REG_SHIMM_OFFSET (*syn))
		    break;
		  /* If this is a register constant (IE: one whose
		     register value gets stored as 61-63) then this
		     must be a limm.  */
		  /* ??? This bit could use some cleaning up.
		     Referencing the format chars like this goes
		     against style.  */
		  if (IS_SYMBOL_OPERAND (*syn))
		    {
		      const char *junk;
		      limm_reloc_p = 1;
		      /* Save this, we don't yet know what reloc to use.  */
		      fix_up_at = fc;
		      /* Tell insert_reg we need a limm.  This is
			 needed because the value at this point is
			 zero, a shimm.  */
		      /* ??? We need a cleaner interface than this.  */
		      (*arc_operands[arc_operand_map['Q']].insert)
			(insn, operand, mods, reg, 0L, &junk);
		    }
		  else
		    fixups[fc].opindex = arc_operand_map[(int) *syn];
		  ++fc;
		  value = 0;
		}
d637 2
a638 21
	      /* Insert the register or expression into the instruction.  */
	      if (operand->insert)
		{
		  const char *errmsg = NULL;
		  insn = (*operand->insert) (insn, operand, mods,
					     reg, (long) value, &errmsg);
		  if (errmsg != (const char *) NULL)
		    {
		      last_errmsg = errmsg;
		      if (operand->flags & ARC_OPERAND_ERROR)
			{
			  as_bad (errmsg);
			  return;
			}
		      else if (operand->flags & ARC_OPERAND_WARN)
			as_warn (errmsg);
		      break;
		    }
		}
	      else
		insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;
d640 13
a652 3
	      ++syn;
	    }
	}
d654 2
a655 7
      /* If we're at the end of the syntax string, we're done.  */
      /* FIXME: try to move this to a separate function.  */
      if (*syn == '\0')
	{
	  int i;
	  char *f;
	  long limm, limm_p;
d657 5
a661 4
	  /* For the moment we assume a valid `str' can only contain blanks
	     now.  IE: We needn't try again with a longer version of the
	     insn and it is assumed that longer versions of insns appear
	     before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
d663 3
a665 2
	  while (ISSPACE (*str))
	    ++str;
d667 1
a667 2
	  if (!is_end_of_line[(unsigned char) *str])
	    as_bad ("junk at end of line: `%s'", str);
d669 6
a674 2
	  /* Is there a limm value?  */
	  limm_p = arc_opcode_limm_p (&limm);
d676 2
a677 1
	  /* Perform various error and warning tests.  */
d679 1
a679 11
	  {
	    static int in_delay_slot_p = 0;
	    static int prev_insn_needs_cc_nop_p = 0;
	    /* delay slot type seen */
	    int delay_slot_type = ARC_DELAY_NONE;
	    /* conditional execution flag seen */
	    int conditional = 0;
	    /* 1 if condition codes are being set */
	    int cc_set_p = 0;
	    /* 1 if conditional branch, including `b' "branch always" */
	    int cond_branch_p = opcode->flags & ARC_OPCODE_COND_BRANCH;
d681 6
a686 15
	    for (i = 0; i < num_suffixes; ++i)
	      {
		switch (arc_operands[insn_suffixes[i]->type].fmt)
		  {
		  case 'n':
		    delay_slot_type = insn_suffixes[i]->value;
		    break;
		  case 'q':
		    conditional = insn_suffixes[i]->value;
		    break;
		  case 'f':
		    cc_set_p = 1;
		    break;
		  }
	      }
d688 2
a689 9
	    /* Putting an insn with a limm value in a delay slot is supposed to
	       be legal, but let's warn the user anyway.  Ditto for 8 byte
	       jumps with delay slots.  */
	    if (in_delay_slot_p && limm_p)
	      as_warn ("8 byte instruction in delay slot");
	    if (delay_slot_type != ARC_DELAY_NONE
		&& limm_p && arc_insn_not_jl (insn)) /* except for jl  addr */
	      as_warn ("8 byte jump instruction with delay slot");
	    in_delay_slot_p = (delay_slot_type != ARC_DELAY_NONE) && !limm_p;
d691 6
a696 11
	    /* Warn when a conditional branch immediately follows a set of
	       the condition codes.  Note that this needn't be done if the
	       insn that sets the condition codes uses a limm.  */
	    if (cond_branch_p && conditional != 0 /* 0 = "always" */
		&& prev_insn_needs_cc_nop_p && arc_mach_type == bfd_mach_arc_5)
	      as_warn ("conditional branch follows set of flags");
	    prev_insn_needs_cc_nop_p =
	      /* FIXME: ??? not required:
		 (delay_slot_type != ARC_DELAY_NONE) &&  */
	      cc_set_p && !limm_p;
	  }
d698 11
a708 5
	  /* Write out the instruction.
	     It is important to fetch enough space in one call to `frag_more'.
	     We use (f - frag_now->fr_literal) to compute where we are and we
	     don't want frag_now to change between calls.  */
	  if (limm_p)
d710 3
a712 15
	      f = frag_more (8);
	      md_number_to_chars (f, insn, 4);
	      md_number_to_chars (f + 4, limm, 4);
	      dwarf2_emit_insn (8);
	    }
	  else if (limm_reloc_p)
	    {
	      /* We need a limm reloc, but the tables think we don't.  */
	      abort ();
	    }
	  else
	    {
	      f = frag_more (4);
	      md_number_to_chars (f, insn, 4);
	      dwarf2_emit_insn (4);
d714 4
d719 6
a724 6
	  /* Create any fixups.  */
	  for (i = 0; i < fc; ++i)
	    {
	      int op_type, reloc_type;
	      expressionS exptmp;
	      const struct arc_operand *operand;
d726 1
a726 6
	      /* Create a fixup for this operand.
		 At this point we do not use a bfd_reloc_code_real_type for
		 operands residing in the insn, but instead just use the
		 operand index.  This lets us easily handle fixups for any
		 operand type, although that is admittedly not a very exciting
		 feature.  We pick a BFD reloc type in md_apply_fix3.
d728 9
a736 3
		 Limm values (4 byte immediate "constants") must be treated
		 normally because they're not part of the actual insn word
		 and thus the insertion routines don't handle them.  */
d738 17
a754 33
	      if (arc_operands[fixups[i].opindex].flags & ARC_OPERAND_LIMM)
		{
		  /* Modify the fixup addend as required by the cpu.  */
		  fixups[i].exp.X_add_number += arc_limm_fixup_adjust (insn);
		  op_type = fixups[i].opindex;
		  /* FIXME: can we add this data to the operand table?  */
		  if (op_type == arc_operand_map['L']
		      || op_type == arc_operand_map['s']
		      || op_type == arc_operand_map['o']
		      || op_type == arc_operand_map['O'])
		    reloc_type = BFD_RELOC_32;
		  else if (op_type == arc_operand_map['J'])
		    reloc_type = BFD_RELOC_ARC_B26;
		  else
		    abort ();
		  reloc_type = get_arc_exp_reloc_type (1, reloc_type,
						       &fixups[i].exp,
						       &exptmp);
		}
	      else
		{
		  op_type = get_arc_exp_reloc_type (0, fixups[i].opindex,
						    &fixups[i].exp, &exptmp);
		  reloc_type = op_type + (int) BFD_RELOC_UNUSED;
		}
	      operand = &arc_operands[op_type];
	      fix_new_exp (frag_now,
			   ((f - frag_now->fr_literal)
			    + (operand->flags & ARC_OPERAND_LIMM ? 4 : 0)), 4,
			   &exptmp,
			   (operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0,
			   (bfd_reloc_code_real_type) reloc_type);
	    }
d756 7
a762 2
	  /* All done.  */
	  return;
d764 8
d773 5
a777 1
      /* Try the next entry.  */
d780 62
a841 4
  if (NULL == last_errmsg)
    as_bad ("bad instruction `%s'", start);
  else
    as_bad (last_errmsg);
d843 1
a843 1

d845 1
a845 2
arc_extoper (opertype)
     int opertype;
a847 1
  char *mode;
d850 1
a850 3
  int imode = 0;
  int number;
  struct arc_ext_operand_value *ext_oper;
a852 3
  segT old_sec;
  int old_subsec;

a854 9
  name = xstrdup (name);

  p = name;
  while (*p)
    {
      *p = TOLOWER (*p);
      p++;
    }

d862 1
a862 1
      as_bad ("expected comma after operand name");
a863 1
      free (name);
d868 1
a868 1
  number = get_absolute_expression ();
d870 1
a870 1
  if (number < 0)
d872 1
a872 1
      as_bad ("negative operand number %d", number);
a873 1
      free (name);
d877 12
a888 1
  if (opertype)
d890 4
a893 1
      SKIP_WHITESPACE ();
d895 7
a901 1
      if (*input_line_pointer != ',')
d903 2
a904 4
	  as_bad ("expected comma after register-number");
	  ignore_rest_of_line ();
	  free (name);
	  return;
d906 3
d910 5
a914 2
      input_line_pointer++;		/* skip ','  */
      mode = input_line_pointer;
d916 4
a919 38
      if (!strncmp (mode, "r|w", 3))
	{
	  imode = 0;
	  input_line_pointer += 3;
	}
      else
	{
	  if (!strncmp (mode, "r", 1))
	    {
	      imode = ARC_REGISTER_READONLY;
	      input_line_pointer += 1;
	    }
	  else
	    {
	      if (strncmp (mode, "w", 1))
		{
		  as_bad ("invalid mode");
		  ignore_rest_of_line ();
		  free (name);
		  return;
		}
	      else
		{
		  imode = ARC_REGISTER_WRITEONLY;
		  input_line_pointer += 1;
		}
	    }
	}
      SKIP_WHITESPACE ();
      if (1 == opertype)
	{
	  if (*input_line_pointer != ',')
	    {
	      as_bad ("expected comma after register-mode");
	      ignore_rest_of_line ();
	      free (name);
	      return;
	    }
d921 3
a923 1
	  input_line_pointer++;		/* skip ','  */
d925 21
a945 20
	  if (!strncmp (input_line_pointer, "cannot_shortcut", 15))
	    {
	      imode |= arc_get_noshortcut_flag ();
	      input_line_pointer += 15;
	    }
	  else
	    {
	      if (strncmp (input_line_pointer, "can_shortcut", 12))
		{
		  as_bad ("shortcut designator invalid");
		  ignore_rest_of_line ();
		  free (name);
		  return;
		}
	      else
		{
		  input_line_pointer += 12;
		}
	    }
	}
d948 22
a969 1
  if ((opertype == 1) && number > 60)
d971 1
a971 1
      as_bad ("core register value (%d) too large", number);
a972 1
      free (name);
d976 4
a979 1
  if ((opertype == 0) && number > 31)
d981 1
a981 1
      as_bad ("condition code value (%d) too large", number);
a982 1
      free (name);
d985 1
a985 5

  ext_oper = (struct arc_ext_operand_value *) \
    xmalloc (sizeof (struct arc_ext_operand_value));

  if (opertype)
d987 7
a993 20
      /* If the symbol already exists, point it at the new definition.  */
      if ((symbolP = symbol_find (name)))
	{
	  if (S_GET_SEGMENT (symbolP) == reg_section)
	    S_SET_VALUE (symbolP, (int) &ext_oper->operand);
	  else
	    {
	      as_bad ("attempt to override symbol: %s", name);
	      ignore_rest_of_line ();
	      free (name);
	      free (ext_oper);
	      return;
	    }
	}
      else
	{
	  /* If its not there, add it.  */
	  symbol_table_insert (symbol_create (name, reg_section,
					      (int) &ext_oper->operand, &zero_address_frag));
	}
d995 2
d998 9
a1006 4
  ext_oper->operand.name  = name;
  ext_oper->operand.value = number;
  ext_oper->operand.type  = arc_operand_type (opertype);
  ext_oper->operand.flags = imode;
d1008 2
a1009 2
  ext_oper->next = arc_ext_operands;
  arc_ext_operands = ext_oper;
d1011 7
a1017 2
  /* OK, now that we know what this operand is, put a description in
     the arc extension section of the output file.  */
d1019 1
a1019 6
  old_sec    = now_seg;
  old_subsec = now_subseg;

  arc_set_ext_seg ();

  switch (opertype)
d1021 3
a1023 9
    case 0:
      p = frag_more (1);
      *p = 3 + strlen (name) + 1;
      p = frag_more (1);
      *p = EXT_COND_CODE;
      p = frag_more (1);
      *p = number;
      p = frag_more (strlen (name) + 1);
      strcpy (p, name);
d1025 4
a1028 25
    case 1:
      p = frag_more (1);
      *p = 3 + strlen (name) + 1;
      p = frag_more (1);
      *p = EXT_CORE_REGISTER;
      p = frag_more (1);
      *p = number;
      p = frag_more (strlen (name) + 1);
      strcpy (p, name);
      break;
    case 2:
      p = frag_more (1);
      *p = 6 + strlen (name) + 1;
      p = frag_more (1);
      *p = EXT_AUX_REGISTER;
      p = frag_more (1);
      *p = number >> 24 & 0xff;
      p = frag_more (1);
      *p = number >> 16 & 0xff;
      p = frag_more (1);
      *p = number >>  8 & 0xff;
      p = frag_more (1);
      *p = number       & 0xff;
      p = frag_more (strlen (name) + 1);
      strcpy (p, name);
d1030 1
d1032 12
a1043 5
      as_bad ("invalid opertype");
      ignore_rest_of_line ();
      free (name);
      return;
      break;
d1046 2
a1047 1
  subseg_set (old_sec, old_subsec);
d1049 2
a1050 1
  /* Enter all registers into the symbol table.  */
d1052 7
a1058 1
  demand_empty_rest_of_line ();
d1061 4
a1064 3
static void
arc_extinst (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1066 4
a1069 10
  char syntax[129];
  char *name;
  char *p;
  char c;
  int suffixcode = -1;
  int opcode, subopcode;
  int i;
  int class = 0;
  int name_len;
  struct arc_opcode *ext_op;
d1071 1
a1071 2
  segT old_sec;
  int old_subsec;
d1073 7
a1079 5
  name = input_line_pointer;
  c = get_symbol_end ();
  name = xstrdup (name);
  strcpy (syntax, name);
  name_len = strlen (name);
d1081 1
a1081 3
  /* just after name is now '\0'  */
  p = input_line_pointer;
  *p = c;
d1083 7
a1089 1
  SKIP_WHITESPACE ();
d1091 4
a1094 1
  if (*input_line_pointer != ',')
d1096 1
a1096 4
      as_bad ("expected comma after operand name");
      ignore_rest_of_line ();
      return;
    }
d1098 27
a1124 2
  input_line_pointer++;		/* skip ','  */
  opcode = get_absolute_expression ();
d1126 3
a1128 1
  SKIP_WHITESPACE ();
d1130 3
a1132 6
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after opcode");
      ignore_rest_of_line ();
      return;
    }
d1134 4
a1137 2
  input_line_pointer++;		/* skip ','  */
  subopcode = get_absolute_expression ();
d1139 2
a1140 6
  if (subopcode < 0)
    {
      as_bad ("negative subopcode %d", subopcode);
      ignore_rest_of_line ();
      return;
    }
d1142 1
a1142 1
  if (subopcode)
d1144 3
a1146 1
      if (3 != opcode)
d1148 1
a1148 2
	  as_bad ("subcode value found when opcode not equal 0x03");
	  ignore_rest_of_line ();
d1151 11
a1161 1
      else
d1163 2
a1164 1
	  if (subopcode < 0x09 || subopcode == 0x3f)
d1166 3
a1168 2
	      as_bad ("invalid subopcode %d", subopcode);
	      ignore_rest_of_line ();
d1171 12
d1185 1
d1187 23
a1209 1
  SKIP_WHITESPACE ();
d1211 8
a1218 1
  if (*input_line_pointer != ',')
d1220 2
a1221 3
      as_bad ("expected comma after subopcode");
      ignore_rest_of_line ();
      return;
d1223 1
d1225 1
a1225 1
  input_line_pointer++;		/* skip ','  */
d1227 7
a1233 1
  for (i = 0; i < (int) MAXSUFFIXCLASS; i++)
d1235 6
a1240 6
      if (!strncmp (suffixclass[i].name,input_line_pointer, suffixclass[i].len))
	{
	  suffixcode = i;
	  input_line_pointer += suffixclass[i].len;
	  break;
	}
d1242 1
a1242 2

  if (-1 == suffixcode)
d1244 4
a1247 3
      as_bad ("invalid suffix class");
      ignore_rest_of_line ();
      return;
d1249 6
d1256 6
a1261 1
  SKIP_WHITESPACE ();
d1263 7
a1269 6
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after suffix class");
      ignore_rest_of_line ();
      return;
    }
d1271 4
a1274 1
  input_line_pointer++;		/* skip ','  */
d1276 2
a1277 9
  for (i = 0; i < (int) MAXSYNTAXCLASS; i++)
    {
      if (!strncmp (syntaxclass[i].name,input_line_pointer, syntaxclass[i].len))
	{
	  class = syntaxclass[i].class;
	  input_line_pointer += syntaxclass[i].len;
	  break;
	}
    }
d1279 1
a1279 1
  if (0 == (SYNTAX_VALID & class))
d1281 3
a1283 3
      as_bad ("invalid syntax class");
      ignore_rest_of_line ();
      return;
d1286 3
a1288 6
  if ((0x3 == opcode) & (class & SYNTAX_3OP))
    {
      as_bad ("opcode 0x3 and SYNTAX_3OP invalid");
      ignore_rest_of_line ();
      return;
    }
d1290 1
a1290 1
  switch (suffixcode)
d1292 4
a1295 18
    case 0:
      strcat (syntax, "%.q%.f ");
      break;
    case 1:
      strcat (syntax, "%.f ");
      break;
    case 2:
      strcat (syntax, "%.q ");
      break;
    case 3:
      strcat (syntax, " ");
      break;
    default:
      as_bad ("unknown suffix class");
      ignore_rest_of_line ();
      return;
      break;
    };
d1297 1
a1297 4
  strcat (syntax, ((opcode == 0x3) ? "%a,%b" : ((class & SYNTAX_3OP) ? "%a,%b,%c" : "%b,%c")));
  if (suffixcode < 2)
    strcat (syntax, "%F");
  strcat (syntax, "%S%L");
d1299 1
a1299 2
  ext_op = (struct arc_opcode *) xmalloc (sizeof (struct arc_opcode));
  ext_op->syntax = xstrdup (syntax);
d1301 13
a1313 6
  ext_op->mask  = I (-1) | ((0x3 == opcode) ? C (-1) : 0);
  ext_op->value = I (opcode) | ((0x3 == opcode) ? C (subopcode) : 0);
  ext_op->flags = class;
  ext_op->next_asm = arc_ext_opcodes;
  ext_op->next_dis = arc_ext_opcodes;
  arc_ext_opcodes = ext_op;
d1315 3
a1317 2
  /* OK, now that we know what this inst is, put a description in the
     arc extension section of the output file.  */
d1319 65
a1383 2
  old_sec    = now_seg;
  old_subsec = now_subseg;
d1385 2
a1386 1
  arc_set_ext_seg ();
d1388 5
a1392 14
  p = frag_more (1);
  *p = 5 + name_len + 1;
  p = frag_more (1);
  *p = EXT_INSTRUCTION;
  p = frag_more (1);
  *p = opcode;
  p = frag_more (1);
  *p = subopcode;
  p = frag_more (1);
  *p = (class & (OP1_MUST_BE_IMM | OP1_IMM_IMPLIED) ? IGNORE_FIRST_OPD : 0);
  p = frag_more (name_len);
  strncpy (p, syntax, name_len);
  p = frag_more (1);
  *p = '\0';
d1394 2
a1395 1
  subseg_set (old_sec, old_subsec);
d1397 4
a1400 7
  demand_empty_rest_of_line ();
}

int
arc_set_ext_seg ()
{
  if (!arcext_section)
d1402 5
a1406 3
      arcext_section = subseg_new (".arcextmap", 0);
      bfd_set_section_flags (stdoutput, arcext_section,
			     SEC_READONLY | SEC_HAS_CONTENTS);
d1408 9
a1416 3
  else
    subseg_set (arcext_section, 0);
  return 1;
d1419 1
a1419 3
static void
arc_common (localScope)
     int localScope;
d1421 20
a1440 5
  char *name;
  char c;
  char *p;
  int align, size;
  symbolS *symbolP;
d1442 1
a1442 6
  name = input_line_pointer;
  c = get_symbol_end ();
  /* just after name is now '\0'  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
d1444 10
a1453 6
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after symbol name");
      ignore_rest_of_line ();
      return;
    }
d1455 3
a1457 4
  input_line_pointer++;		/* skip ','  */
  size = get_absolute_expression ();

  if (size < 0)
d1459 2
a1460 3
      as_bad ("negative symbol length");
      ignore_rest_of_line ();
      return;
d1463 3
a1465 3
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
d1467 2
a1468 13
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad ("ignoring attempt to re-define symbol");
      ignore_rest_of_line ();
      return;
    }
  if (((int) S_GET_VALUE (symbolP) != 0) \
      && ((int) S_GET_VALUE (symbolP) != size))
    {
      as_warn ("length of symbol \"%s\" already %ld, ignoring %d",
	       S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
    }
  assert (symbolP->sy_frag == &zero_address_frag);
d1470 2
a1471 14
  /* Now parse the alignment field.  This field is optional for
     local and global symbols. Default alignment is zero.  */
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      align = get_absolute_expression ();
      if (align < 0)
	{
	  align = 0;
	  as_warn ("assuming symbol alignment of zero");
	}
    }
  else
    align = 0;
d1473 7
a1479 1
  if (localScope != 0)
d1481 9
a1489 3
      segT old_sec;
      int old_subsec;
      char *pfrag;
d1491 3
a1493 4
      old_sec    = now_seg;
      old_subsec = now_subseg;
      record_alignment (bss_section, align);
      subseg_set (bss_section, 0);  /* ??? subseg_set (bss_section, 1); ???  */
d1495 8
a1502 3
      if (align)
	/* Do alignment.  */
	frag_align (align, 0, 0);
d1504 3
a1506 235
      /* Detach from old frag.  */
      if (S_GET_SEGMENT (symbolP) == bss_section)
	symbolP->sy_frag->fr_symbol = NULL;

      symbolP->sy_frag = frag_now;
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			(offsetT) size, (char *) 0);
      *pfrag = 0;

      S_SET_SIZE       (symbolP, size);
      S_SET_SEGMENT    (symbolP, bss_section);
      S_CLEAR_EXTERNAL (symbolP);
      symbolP->local = 1;
      subseg_set (old_sec, old_subsec);
    }
  else
    {
      S_SET_VALUE    (symbolP, (valueT) size);
      S_SET_ALIGN    (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT  (symbolP, bfd_com_section_ptr);
    }

  symbolP->bsym->flags |= BSF_OBJECT;

  demand_empty_rest_of_line ();
}

/* Select the cpu we're assembling for.  */

static void
arc_option (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int mach;
  char c;
  char *cpu;

  cpu = input_line_pointer;
  c = get_symbol_end ();
  mach = arc_get_mach (cpu);
  *input_line_pointer = c;

  /* If an instruction has already been seen, it's too late.  */
  if (cpu_tables_init_p)
    {
      as_bad ("\".option\" directive must appear before any instructions");
      ignore_rest_of_line ();
      return;
    }

  if (mach == -1)
    goto bad_cpu;

  if (mach_type_specified_p && mach != arc_mach_type)
    {
      as_bad ("\".option\" directive conflicts with initial definition");
      ignore_rest_of_line ();
      return;
    }
  else
    {
      /* The cpu may have been selected on the command line.  */
      if (mach != arc_mach_type)
	as_warn ("\".option\" directive overrides command-line (default) value");
      arc_mach_type = mach;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_arc, mach))
	as_fatal ("could not set architecture and machine");
      mach_type_specified_p = 1;
    }
  demand_empty_rest_of_line ();
  return;

 bad_cpu:
  as_bad ("invalid identifier for \".option\"");
  ignore_rest_of_line ();
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c  */
#define MAX_LITTLENUMS 6

char *
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
      prec = 2;
      break;

    case 'd':
    case 'D':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return "bad call to md_atof";
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return NULL;
}

/* Write a value out to the object file, using the appropriate
   endianness.  */

void
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, segment);

  return ((size + (1 << align) - 1) & (-1 << align));
}

/* We don't have any form of relaxing.  */

int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
{
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
}

/* Convert a machine dependent frag.  We never generate these.  */

void
md_convert_frag (abfd, sec, fragp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragp ATTRIBUTE_UNUSED;
{
  as_fatal (_("md_convert_frag\n"));
}

void
arc_code_symbol (expressionP)
     expressionS *expressionP;
{
  if (expressionP->X_op == O_symbol && expressionP->X_add_number == 0)
    {
      expressionS two;
      expressionP->X_op = O_right_shift;
      expressionP->X_add_symbol->sy_value.X_op = O_constant;
      two.X_op = O_constant;
      two.X_add_symbol = two.X_op_symbol = NULL;
      two.X_add_number = 2;
      expressionP->X_op_symbol = make_expr_symbol (&two);
    }
  /* Allow %st(sym1-sym2)  */
  else if (expressionP->X_op == O_subtract
	   && expressionP->X_add_symbol != NULL
	   && expressionP->X_op_symbol != NULL
	   && expressionP->X_add_number == 0)
    {
      expressionS two;
      expressionP->X_add_symbol = make_expr_symbol (expressionP);
      expressionP->X_op = O_right_shift;
      two.X_op = O_constant;
      two.X_add_symbol = two.X_op_symbol = NULL;
      two.X_add_number = 2;
      expressionP->X_op_symbol = make_expr_symbol (&two);
    }
  else
    {
      as_bad ("expression too complex code symbol");
      return;
    }
}

/* Parse an operand that is machine-specific.

   The ARC has a special %-op to adjust addresses so they're usable in
   branches.  The "st" is short for the STatus register.
   ??? Later expand this to take a flags value too.

   ??? We can't create new expression types so we map the %-op's onto the
   existing syntax.  This means that the user could use the chosen syntax
   to achieve the same effect.  */

void
md_operand (expressionP)
     expressionS *expressionP;
{
  char *p = input_line_pointer;

  if (*p != '%')
    return;

  if (strncmp (p, "%st(", 4) == 0)
    {
      input_line_pointer += 4;
      expression (expressionP);
      if (*input_line_pointer != ')')
d1508 2
a1509 12
	  as_bad ("missing ')' in %%-op");
	  return;
	}
      ++input_line_pointer;
      arc_code_symbol (expressionP);
    }
  else
    {
      /* It could be a register.  */
      int i, l;
      struct arc_ext_operand_value *ext_oper = arc_ext_operands;
      p++;
d1511 2
a1512 4
      while (ext_oper)
	{
	  l = strlen (ext_oper->operand.name);
	  if (!strncmp (p, ext_oper->operand.name, l) && !ISALNUM (*(p + l)))
d1514 10
a1523 4
	      input_line_pointer += l + 1;
	      expressionP->X_op = O_register;
	      expressionP->X_add_number = (int) &ext_oper->operand;
	      return;
d1525 4
a1528 6
	  ext_oper = ext_oper->next;
	}
      for (i = 0; i < arc_reg_names_count; i++)
	{
	  l = strlen (arc_reg_names[i].name);
	  if (!strncmp (p, arc_reg_names[i].name, l) && !ISALNUM (*(p + l)))
d1530 2
a1531 4
	      input_line_pointer += l + 1;
	      expressionP->X_op = O_register;
	      expressionP->X_add_number = (int) &arc_reg_names[i];
	      break;
d1533 3
a1535 3
	}
    }
}
d1537 36
a1572 3
/* We have no need to default values of symbols.
   We could catch register names here, but that is handled by inserting
   them all in the symbol table to begin with.  */
d1574 2
a1575 8
symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Functions concerning expressions.  */
d1577 8
a1584 55
/* Parse a .byte, .word, etc. expression.

   Values for the status register are specified with %st(label).
   `label' will be right shifted by 2.  */

void
arc_parse_cons_expression (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes ATTRIBUTE_UNUSED;
{
  char *p = input_line_pointer;
  int code_symbol_fix = 0;

  for (; ! is_end_of_line[(unsigned char) *p]; p++)
    if (*p == '@@' && !strncmp (p, "@@h30", 4))
      {
	code_symbol_fix = 1;
	strcpy (p, ";   ");
      }
  expr (0, exp);
  if (code_symbol_fix)
    {
      arc_code_symbol (exp);
      input_line_pointer = p;
    }
}

/* Record a fixup for a cons expression.  */

void
arc_cons_fix_new (frag, where, nbytes, exp)
     fragS *frag;
     int where;
     int nbytes;
     expressionS *exp;
{
  if (nbytes == 4)
    {
      int reloc_type;
      expressionS exptmp;

      /* This may be a special ARC reloc (eg: %st()).  */
      reloc_type = get_arc_exp_reloc_type (1, BFD_RELOC_32, exp, &exptmp);
      fix_new_exp (frag, where, nbytes, &exptmp, 0, reloc_type);
    }
  else
    {
      fix_new_exp (frag, where, nbytes, exp, 0,
		   nbytes == 2 ? BFD_RELOC_16
		   : nbytes == 8 ? BFD_RELOC_64
		   : BFD_RELOC_32);
    }
}

/* Functions concerning relocs.  */
d1586 17
a1602 2
/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */
d1604 17
a1620 7
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  /* Return the address of the delay slot.  */
  return fixP->fx_frag->fr_address + fixP->fx_where + fixP->fx_size;
}
d1622 37
a1658 2
/* Compute the reloc type of an expression.
   The possibly modified expression is stored in EXPNEW.
d1660 25
a1684 3
   This is used to convert the expressions generated by the %-op's into
   the appropriate operand type.  It is called for both data in instructions
   (operands) and data outside instructions (variables, debugging info, etc.).
d1686 2
a1687 1
   Currently supported %-ops:
d1689 5
a1693 2
   %st(symbol): represented as "symbol >> 2"
                "st" is short for STatus as in the status register (pc)
d1695 6
a1700 1
   DEFAULT_TYPE is the type to use if no special processing is required.
d1702 51
a1752 6
   DATA_P is non-zero for data or limm values, zero for insn operands.
   Remember that the opcode "insertion fns" cannot be used on data, they're
   only for inserting operands into insns.  They also can't be used for limm
   values as the insertion routines don't handle limm values.  When called for
   insns we return fudged reloc types (real_value - BFD_RELOC_UNUSED).  When
   called for data or limm values we use real reloc types.  */
d1754 21
a1774 11
static int
get_arc_exp_reloc_type (data_p, default_type, exp, expnew)
     int data_p;
     int default_type;
     expressionS *exp;
     expressionS *expnew;
{
  /* If the expression is "symbol >> 2" we must change it to just "symbol",
     as fix_new_exp can't handle it.  Similarly for (symbol - symbol) >> 2.
     That's ok though.  What's really going on here is that we're using
     ">> 2" as a special syntax for specifying BFD_RELOC_ARC_B26.  */
d1776 2
a1777 14
  if (exp->X_op == O_right_shift
      && exp->X_op_symbol != NULL
      && exp->X_op_symbol->sy_value.X_op == O_constant
      && exp->X_op_symbol->sy_value.X_add_number == 2
      && exp->X_add_number == 0)
    {
      if (exp->X_add_symbol != NULL
	  && (exp->X_add_symbol->sy_value.X_op == O_constant
	      || exp->X_add_symbol->sy_value.X_op == O_symbol))
	{
	  *expnew = *exp;
	  expnew->X_op = O_symbol;
	  expnew->X_op_symbol = NULL;
	  return data_p ? BFD_RELOC_ARC_B26 : arc_operand_map['J'];
d1779 4
a1782 2
      else if (exp->X_add_symbol != NULL
	       && exp->X_add_symbol->sy_value.X_op == O_subtract)
d1784 3
a1786 16
	  *expnew = exp->X_add_symbol->sy_value;
	  return data_p ? BFD_RELOC_ARC_B26 : arc_operand_map['J'];
	}
    }

  *expnew = *exp;
  return default_type;
}

/* Apply a fixup to the object code.  This is called for all the
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the fixup.  */
d1788 4
a1791 7
void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg;
{
  valueT value = * valP;
d1793 2
a1794 2
  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;
d1796 2
a1797 6
  else if (fixP->fx_pcrel)
    {
      /* Hack around bfd_install_relocation brain damage.  */
      if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
    }
d1799 2
a1800 3
  /* We can't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
d1802 1
a1802 6
  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex;
      const struct arc_operand *operand;
      char *where;
      arc_insn insn;
d1804 11
a1814 1
      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
d1816 15
a1830 1
      operand = &arc_operands[opindex];
d1832 9
a1840 13
      /* Fetch the instruction, insert the fully resolved operand
	 value, and stuff the instruction back again.  */
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
      if (target_big_endian)
	insn = bfd_getb32 ((unsigned char *) where);
      else
	insn = bfd_getl32 ((unsigned char *) where);
      insn = arc_insert_operand (insn, operand, -1, NULL, (offsetT) value,
				 fixP->fx_file, fixP->fx_line);
      if (target_big_endian)
	bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      else
	bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
d1842 11
a1852 5
      if (fixP->fx_done)
	{
	  /* Nothing else to do here.  */
	  return;
	}
d1854 20
a1873 65
      /* Determine a BFD reloc value based on the operand information.
	 We are only prepared to turn a few of the operands into relocs.
	 !!! Note that we can't handle limm values here.  Since we're using
	 implicit addends the addend must be inserted into the instruction,
	 however, the opcode insertion routines currently do nothing with
	 limm values.  */
      if (operand->fmt == 'B')
	{
	  assert ((operand->flags & ARC_OPERAND_RELATIVE_BRANCH) != 0
		  && operand->bits == 20
		  && operand->shift == 7);
	  fixP->fx_r_type = BFD_RELOC_ARC_B22_PCREL;
	}
      else if (operand->fmt == 'J')
	{
	  assert ((operand->flags & ARC_OPERAND_ABSOLUTE_BRANCH) != 0
		  && operand->bits == 24
		  && operand->shift == 32);
	  fixP->fx_r_type = BFD_RELOC_ARC_B26;
	}
      else if (operand->fmt == 'L')
	{
	  assert ((operand->flags & ARC_OPERAND_LIMM) != 0
		  && operand->bits == 32
		  && operand->shift == 32);
	  fixP->fx_r_type = BFD_RELOC_32;
	}
      else
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"unresolved expression that must be resolved");
	  fixP->fx_done = 1;
	  return;
	}
    }
  else
    {
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_8:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 1);
	  break;
	case BFD_RELOC_16:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 2);
	  break;
	case BFD_RELOC_32:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 4);
	  break;
	case BFD_RELOC_ARC_B26:
	  /* If !fixP->fx_done then `value' is an implicit addend.
	     We must shift it right by 2 in this case as well because the
	     linker performs the relocation and then adds this in (as opposed
	     to adding this in and then shifting right by 2).  */
	  value >>= 2;
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 4);
	  break;
	default:
	  abort ();
	}
    }
}
d1875 6
a1880 2
/* Translate internal representation of relocation info to BFD target
   format.  */
d1882 6
a1887 6
arelent *
tc_gen_reloc (section, fixP)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixP;
{
  arelent *reloc;
d1889 3
a1891 2
  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d1893 35
a1927 10
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    "internal error: can't export reloc type %d (`%s')",
		    fixP->fx_r_type,
		    bfd_get_reloc_code_name (fixP->fx_r_type));
      return NULL;
d1930 4
a1933 8
  assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);

  /* Set addend to account for PC being advanced one insn before the
     target address is computed.  */

  reloc->addend = (fixP->fx_pcrel ? -4 : 0);

  return reloc;
@


1.32
log
@2005-03-01  Ramana Radhakrishnan  <ramana.radhakrishnan@@codito.com>

	PR gas/708
	* config/tc-arc.c(md_assemble):Initialize suffix for extension
	suffixes also.
	* testsuite/gas/arc/extensions.s:New file
	* testsuite/gas/arc/extensions.d:New file
@
text
@d439 1
a439 9
	      /* Handle '+' specially as we want to allow "ld r0,[sp-4]".  */
	      /* ??? The syntax has changed to [sp,-4].  */
	      if (0 && *syn == '+' && *str == '-')
		{
		  /* Skip over syn's +, but leave str's - alone.
		     That makes the case identical to "ld r0,[sp+-4]".  */
		  ++syn;
		}
	      else if (*str == *syn)
@


1.31
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d571 1
a571 1

@


1.30
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d1124 1
a1124 1
  unsigned char syntax[129];
@


1.29
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1999, 2000, 2001, 2002, 2003, 2004
d1648 21
a1668 19
  if (*p == '%')
    if (strncmp (p, "%st(", 4) == 0)
      {
	input_line_pointer += 4;
	expression (expressionP);
	if (*input_line_pointer != ')')
	  {
	    as_bad ("missing ')' in %%-op");
	    return;
	  }
	++input_line_pointer;
	arc_code_symbol (expressionP);
      }
    else
      {
	/* It could be a register.  */
	int i, l;
	struct arc_ext_operand_value *ext_oper = arc_ext_operands;
	p++;
d1670 24
a1693 24
	while (ext_oper)
	  {
	    l = strlen (ext_oper->operand.name);
	    if (!strncmp (p, ext_oper->operand.name, l) && !ISALNUM (*(p + l)))
	      {
		input_line_pointer += l + 1;
		expressionP->X_op = O_register;
		expressionP->X_add_number = (int) &ext_oper->operand;
		return;
	      }
	    ext_oper = ext_oper->next;
	  }
	for (i = 0; i < arc_reg_names_count; i++)
	  {
	    l = strlen (arc_reg_names[i].name);
	    if (!strncmp (p, arc_reg_names[i].name, l) && !ISALNUM (*(p + l)))
	      {
		input_line_pointer += l + 1;
		expressionP->X_op = O_register;
		expressionP->X_add_number = (int) &arc_reg_names[i];
		break;
	      }
	  }
      }
@


1.28
log
@	* config/tc-arc.c (tc_gen_reloc): Don't assume fixP->fx_addsy is an
	asymbol *, instead use symbol_get_bfdsym.
@
text
@a1847 3
#if 0
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
#endif
a1945 6
#if 0
	case BFD_RELOC_64:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 8);
	  break;
#endif
@


1.27
log
@Remove duplicate code and provide a function for generating internally consistent 'value out of range' messages
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1999, 2000, 2001, 2002
d1981 1
d1983 1
a1983 1
  reloc->sym_ptr_ptr = &fixP->fx_addsy->bsym;
@


1.26
log
@	* read.c (read_a_source_file): Use demand_empty_rest_of_line.
	(demand_empty_rest_of_line): Issue an error here.
	(ignore_rest_of_line): Silently skip to end.
	(demand_copy_string): Issue an error, not warning.
	(equals): Likewise.
	* config/obj-elf.c (obj_elf_section_name): Likewise.
	(obj_elf_section): Likewise.
	* config/tc-arc.c (arc_extoper): Remove bogus NULL checks.
	(arc_extinst): Likewise.
	* config/tc-ia64.c (dot_saveb): Use demand_empty_rest_of_line.
	(dot_spill): Likewise.
	(dot_unwabi): Likewise.
	(dot_prologue): Likewise.
@
text
@d331 1
a331 11
	{
	  const char *err =
	    "operand out of range (%s not between %ld and %ld)";
	  char buf[100];

	  sprint_value (buf, test);
	  if (file == (char *) NULL)
	    as_warn (err, buf, min, max);
	  else
	    as_warn_where (file, line, err, buf, min, max);
	}
@


1.25
log
@Remove redundant returns in void functions.
@
text
@a907 5
  if (NULL == name)
    {
      ignore_rest_of_line ();
      return;
    }
a1150 5
  if (NULL == name)
    {
      ignore_rest_of_line ();
      return;
    }
a1297 6
  if (NULL == ext_op)
    {
      ignore_rest_of_line ();
      return;
    }

a1298 5
  if (NULL == ext_op->syntax)
    {
      ignore_rest_of_line ();
      return;
    }
@


1.25.6.1
log
@Merge to 2.15 branch.
@
text
@d908 5
d1156 5
d1308 6
d1315 5
@


1.24
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-alpha.c: Likewise.
	* config/tc-alpha.h: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-dlx.h: Likewise.
@
text
@a1477 1
  return;
@


1.23
log
@	* config/tc-arc.c: Remove a local prototype of atof_ieee.
	* config/tc-ip2k.c: Likewise.
	* config/tc-iq2000.c: Likewise.
	* config/tc-tic30.c: Remove a comment.
@
text
@d1835 1
a1835 1
     as fix_new_exp can't handle it.  Similarily for (symbol - symbol) >> 2.
@


1.22
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@a1548 1
  char * atof_ieee PARAMS ((char *, int, LITTLENUM_TYPE *));
@


1.21
log
@gas reloc rewrite.
@
text
@a96 2
  { "file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  { "loc", dwarf2_directive_loc, 0 },
@


1.20
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d26 1
a1804 7
  if (fixP->fx_addsy != (symbolS *) NULL
      && ! S_IS_DEFINED (fixP->fx_addsy))
    {
      /* The symbol is undefined.  Let the linker figure it out.  */
      return 0;
    }

a1887 11
  /* FIXME FIXME FIXME: The value we are passed in *valueP includes
     the symbol values.  Since we are using BFD_ASSEMBLER, if we are
     doing this relocation the code in write.c is going to call
     bfd_perform_relocation, which is also going to use the symbol
     value.  That means that if the reloc is fully resolved we want to
     use *valueP since bfd_perform_relocation is not being used.
     However, if the reloc is not fully resolved we do not want to use
     *valueP, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valueP since it includes the
     result of md_pcrel_from.  This is confusing.  */

d1893 2
a1894 6
      /* ELF relocations are against symbols.
	 If this symbol is in a different section then we need to leave it for
	 the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
	 so we have to undo it's effects here.  */
      if (S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
d1897 4
a1900 15
  else
    {
      value = fixP->fx_offset;
      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    {
	      /* We can't actually support subtracting a symbol.  */
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    "expression too complex");
	    }
	}
    }
a2002 2

  fixP->fx_addnumber = value;
d2032 1
a2032 2
     target address is computed, drop fx_addnumber as it is handled
     elsewhere mlm  */
@


1.19
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1999, 2000, 2001
d96 1
a96 1
  { "file", dwarf2_directive_file, 0 },
@


1.18
log
@	* bit_fix.h: Comment typo fix.
	* config/tc-mips.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-arc.c (arc_code_symbol): Remove unnecessary test.
@
text
@d837 1
a837 1
		 feature.  We pick a BFD reloc type in md_apply_fix.
d1883 2
a1884 2
int
md_apply_fix3 (fixP, valueP, seg)
d1886 1
a1886 1
     valueT *valueP;
d1892 1
a1892 1
  valueT value;
d1906 2
a1907 4
    {
      value = *valueP;
      fixP->fx_done = 1;
    }
a1909 1
      value = *valueP;
d1962 1
a1962 1
	  return 1;
d1997 1
a1997 1
	  return 1;
a2036 2

  return 1;
@


1.17
log
@fix compile time warning messages
@
text
@d1635 1
a1635 3
  if (expressionP->X_op == O_symbol && expressionP->X_add_number == 0
      /* I think this test is unnecessary but just as a sanity check...  */
      && expressionP->X_op_symbol == NULL)
@


1.16
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d49 1
a49 1
static int get_arc_exp_reloc_type PARAMS ((int, int, expressionS *,
d52 2
d1542 1
a1542 1
     char type;
d1550 1
a1550 1
  char *atof_ieee ();
@


1.15
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@a23 1
#include <ctype.h>
d26 1
d396 1
a396 1
  while (isspace (*str))
d547 1
a547 1
	      for (t = s; *t && isalnum (*t); ++t)
d739 1
a739 1
	  while (isspace (*str))
d916 1
a916 2
      if (isupper (*p))
	*p = tolower (*p);
d1705 1
a1705 1
	    if (!strncmp (p, ext_oper->operand.name, l) && !isalnum (*(p + l)))
d1717 1
a1717 1
	    if (!strncmp (p, arc_reg_names[i].name, l) && !isalnum (*(p + l)))
@


1.14
log
@	* config/tc-arc.c (md_assemble): Use is_end_of_line instead of
	testing for NULs.
@
text
@d1706 1
a1706 1
	    if (!strncmp (p, ext_oper->operand.name, l) && !isalnum(*(p + l)))
@


1.13
log
@Fix dwarf2_emit_insn calls when frag_var breaks things.
Put back an old entry in ChangeLog-9899, deleted when ChangeLog split.
@
text
@d634 1
a634 1
	      if (*str == '\0')
d742 1
a742 1
	  if (*str != '\0')
@


1.12
log
@Peter Targett's backwards compatibility and other arc fixes.
@
text
@d809 1
d820 1
a873 2

	  dwarf2_emit_insn (4);
@


1.11
log
@Fix copyright notices
@
text
@d31 1
d80 1
a80 1
  { "align", s_align_bytes, 0 }, /* Defaulting is invalid (0) */
d92 1
d94 2
d104 1
a104 1
   pre-processor is disabled, these aren't very useful */
d119 1
a119 1
/* Chars that can be used to separate mant from exp in floating point nums */
d122 2
a123 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d134 1
a134 1
static int arc_mach_type = bfd_mach_arc_5;
d140 1
a140 1
   A .cpu command must appear before any instructions.  */
d148 1
a148 1
  {"EB", no_argument, NULL, OPTION_EB},
d150 1
a150 1
  {"EL", no_argument, NULL, OPTION_EL},
d152 2
a153 1
  {"marc5", no_argument, NULL, OPTION_ARC5},
d155 1
a155 1
  {"marc6", no_argument, NULL, OPTION_ARC6},
d157 1
a157 1
  {"marc7", no_argument, NULL, OPTION_ARC7},
d159 1
a159 1
  {"marc8", no_argument, NULL, OPTION_ARC8},
d161 1
a161 1
  {"marc", no_argument, NULL, OPTION_ARC},
a180 1
    case OPTION_ARC:
d184 1
d221 1
a221 1
   Opcode selection is defered until later because we might see a .cpu
d233 2
a234 3
  /* This call is necessary because we need to
     initialize `arc_operand_map' which may be needed before we see the
     first insn.  */
a240 1

d282 4
a285 2
      symbol_table_insert (symbol_create (arc_reg_names[i].name, reg_section,
                           (int) &arc_reg_names[i], &zero_address_frag));
d364 1
a364 1
  /* index into `arc_operands' */
d388 1
a388 1
     wait for a possible .cpu command.  */
d873 2
d921 1
a921 1
  /* just after name is now '\0' */
d934 1
a934 1
  input_line_pointer++;		/* skip ',' */
d957 1
a957 1
      input_line_pointer++;		/* skip ',' */
d999 1
a999 1
	  input_line_pointer++;             /* skip ',' */
d1164 1
a1164 1
  /* just after name is now '\0' */
d1177 1
a1177 1
  input_line_pointer++;		/* skip ',' */
d1189 1
a1189 1
  input_line_pointer++;		/* skip ',' */
d1227 1
a1227 1
  input_line_pointer++;         /* skip ',' */
d1255 1
a1255 1
  input_line_pointer++;         /* skip ',' */
d1382 1
a1382 1
  /* just after name is now '\0' */
d1394 1
a1394 1
  input_line_pointer++;		/* skip ',' */
d1446 1
a1446 1
      subseg_set (bss_section, 0);  /* ??? subseg_set (bss_section, 1); ??? */
d1640 1
d1646 1
a1646 1
  /* Allow %st(sym1-sym2) */
d1697 2
a1698 1
      {       /* It could be a register.  */
@


1.10
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-arc.c: Fix formatting.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 1995, 1997, 2000 Free Software Foundation, Inc.
@


1.10.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1999, 2000, 2001
   Free Software Foundation, Inc.
a29 1
#include "dwarf2dbg.h"
d78 1
a78 1
  { "align", s_align_bytes, 0 }, /* Defaulting is invalid (0).  */
a89 1
  { "cpu", arc_option, 0 },
a90 2
  { "file", dwarf2_directive_file, 0 },
  { "loc", dwarf2_directive_loc, 0 },
d99 1
a99 1
   pre-processor is disabled, these aren't very useful.  */
d114 1
a114 1
/* Chars that can be used to separate mant from exp in floating point nums.  */
d117 3
a119 2
/* Chars that mean this number is a floating point constant
   As in 0f12.456 or 0d1.2345e12.  */
d130 1
a130 1
static int arc_mach_type = bfd_mach_arc_6;
d136 1
a136 1
   A .option command must appear before any instructions.  */
d144 1
a144 1
  { "EB", no_argument, NULL, OPTION_EB },
d146 1
a146 1
  { "EL", no_argument, NULL, OPTION_EL },
d148 1
a148 2
  { "marc5", no_argument, NULL, OPTION_ARC5 },
  { "pre-v6", no_argument, NULL, OPTION_ARC5 },
d150 1
a150 1
  { "marc6", no_argument, NULL, OPTION_ARC6 },
d152 1
a152 1
  { "marc7", no_argument, NULL, OPTION_ARC7 },
d154 1
a154 1
  { "marc8", no_argument, NULL, OPTION_ARC8 },
d156 1
a156 1
  { "marc", no_argument, NULL, OPTION_ARC },
d176 1
a179 1
    case OPTION_ARC:
d216 1
a216 1
   Opcode selection is deferred until later because we might see a .option
d228 3
a230 2
  /* This call is necessary because we need to initialize `arc_operand_map'
     which may be needed before we see the first insn.  */
d237 1
d279 2
a280 4
      symbol_table_insert (symbol_create (arc_reg_names[i].name,
					  reg_section,
					  (int) &arc_reg_names[i],
					  &zero_address_frag));
d359 1
a359 1
  /* index into `arc_operands'  */
d383 1
a383 1
     wait for a possible .option command.  */
d629 1
a629 1
	      if (is_end_of_line[(unsigned char) *str])
d737 1
a737 1
	  if (!is_end_of_line[(unsigned char) *str])
a803 1
	      dwarf2_emit_insn (8);
a813 1
	      dwarf2_emit_insn (4);
d914 1
a914 1
  /* just after name is now '\0'  */
d927 1
a927 1
  input_line_pointer++;		/* skip ','  */
d950 1
a950 1
      input_line_pointer++;		/* skip ','  */
d992 1
a992 1
	  input_line_pointer++;		/* skip ','  */
d1157 1
a1157 1
  /* just after name is now '\0'  */
d1170 1
a1170 1
  input_line_pointer++;		/* skip ','  */
d1182 1
a1182 1
  input_line_pointer++;		/* skip ','  */
d1220 1
a1220 1
  input_line_pointer++;		/* skip ','  */
d1248 1
a1248 1
  input_line_pointer++;		/* skip ','  */
d1375 1
a1375 1
  /* just after name is now '\0'  */
d1387 1
a1387 1
  input_line_pointer++;		/* skip ','  */
d1439 1
a1439 1
      subseg_set (bss_section, 0);  /* ??? subseg_set (bss_section, 1); ???  */
a1632 1
      expressionP->X_add_symbol->sy_value.X_op = O_constant;
d1638 1
a1638 1
  /* Allow %st(sym1-sym2)  */
d1689 1
a1689 2
      {
	/* It could be a register.  */
@


1.9
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-arc.c: Fix formatting.
@
text
@d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 1
a37 1
extern void arc_code_symbol PARAMS((expressionS *));
d77 1
a77 2
const pseudo_typeS md_pseudo_table[] =
{
d142 1
a142 2
struct option md_longopts[] =
{
d164 1
a164 1
struct arc_operand_value *get_ext_suffix(char *s);
d166 2
a167 6
/*
 * md_parse_option
 *
 * Invocation line includes a switch not recognized by the base assembler.
 * See if it's a processor-specific option.
 */
d275 1
a275 1
      if (symbol_find(arc_reg_names[i].name))
d358 1
a358 2
struct arc_fixup
{
d403 1
a403 1
  for (opcode = (ext_opcode ? ext_opcode : std_opcode) ;
d435 1
a435 1
      for (str = start, syn = opcode->syntax; *syn != '\0'; )
d492 4
a495 4
		  if(limm_reloc_p
		     && (operand->flags && operand->flags & ARC_OPERAND_LIMM)
		     && (operand->flags &
			 (ARC_OPERAND_ABSOLUTE_BRANCH | ARC_OPERAND_ADDRESS)))
d507 2
a508 2
	      char *s,*t;
	      const struct arc_operand_value *suf,*suffix_end;
d546 1
a546 1
	      if ((suf = get_ext_suffix(s)))
d605 2
a606 1
		; /* Wrong type.  Just go on to try next insn entry.  */
d653 1
a653 1
		as_bad("symbol as destination register");
d656 1
a656 1
		  if(!strncmp(str,"@@h30",4))
d658 1
a658 1
		      arc_code_symbol(&exp);
d666 1
a666 1
		     the assembler to output a limm  */
d668 1
a668 1
		  if(IS_REG_SHIMM_OFFSET(*syn))
d680 1
a680 1
		      /* save this, we don't yet know what reloc to use */
d761 1
a761 1
		  case 'n' :
d764 1
a764 1
		  case 'q' :
d767 1
a767 1
		  case 'f' :
d779 1
a779 1
		&& limm_p && arc_insn_not_jl(insn)) /* except for jl  addr */
d836 2
a837 2
		  /* modify the fixup addend as required by the cpu */
		  fixups[i].exp.X_add_number += arc_limm_fixup_adjust(insn);
d875 1
a875 1
  if(NULL == last_errmsg)
a879 1

a880 1

d899 1
a899 1
  name = xstrdup(name);
d902 1
a902 1
      ignore_rest_of_line();
d909 2
a910 2
      if (isupper(*p))
	*p = tolower(*p);
d923 1
a923 1
      free(name);
d930 1
a930 1
  if(number < 0)
d932 3
a934 3
      as_bad ("negative operand number %d",number);
      ignore_rest_of_line();
      free(name);
d940 1
a940 1
      SKIP_WHITESPACE();
d946 1
a946 1
	  free(name);
d953 1
a953 1
      if (!strncmp(mode, "r|w",3))
d960 1
a960 1
	  if (!strncmp(mode,"r",1))
d967 1
a967 1
	      if (strncmp(mode,"w",1))
d970 2
a971 2
		  ignore_rest_of_line();
		  free(name);
d981 1
a981 1
      SKIP_WHITESPACE();
d988 1
a988 1
	      free(name);
d994 1
a994 1
	  if(!strncmp(input_line_pointer,"cannot_shortcut",15))
d996 1
a996 1
	      imode |= arc_get_noshortcut_flag();
d1001 1
a1001 1
	      if(strncmp(input_line_pointer,"can_shortcut",12))
d1004 2
a1005 2
		  ignore_rest_of_line();
		  free(name);
d1018 3
a1020 3
      as_bad("core register value (%d) too large", number);
      ignore_rest_of_line();
      free(name);
d1026 3
a1028 3
      as_bad("condition code value (%d) too large", number);
      ignore_rest_of_line();
      free(name);
d1033 1
a1033 1
    xmalloc(sizeof (struct arc_ext_operand_value));
d1035 1
a1035 1
  if(opertype)
d1037 1
a1037 1
      /* if the symbol already exists, point it at the new definition */
d1040 2
a1041 2
	  if (S_GET_SEGMENT(symbolP) == reg_section)
	    S_SET_VALUE(symbolP,(int)&ext_oper->operand);
d1044 4
a1047 4
	      as_bad("attempt to override symbol: %s",name);
	      ignore_rest_of_line();
	      free(name);
	      free(ext_oper);
d1053 1
a1053 1
	  /* If its not there, add it */
d1061 1
a1061 1
  ext_oper->operand.type  = arc_operand_type(opertype);
d1067 2
a1068 2
  /* ok, now that we know what this operand is, put a description
     in the arc extension section of the output file */
d1073 1
a1073 1
  arc_set_ext_seg();
d1078 3
a1080 3
      p = frag_more(1);
      *p = 3 + strlen(name) + 1;
      p = frag_more(1);
d1082 1
a1082 1
      p = frag_more(1);
d1084 2
a1085 2
      p = frag_more(strlen(name) + 1);
      strcpy(p,name);
d1088 3
a1090 3
      p = frag_more(1);
      *p = 3 + strlen(name) + 1;
      p = frag_more(1);
d1092 1
a1092 1
      p = frag_more(1);
d1094 2
a1095 2
      p = frag_more(strlen(name) + 1);
      strcpy(p,name);
d1098 3
a1100 3
      p = frag_more(1);
      *p = 6 + strlen(name) + 1;
      p = frag_more(1);
d1102 1
a1102 1
      p = frag_more(1);
d1104 1
a1104 1
      p = frag_more(1);
d1106 1
a1106 1
      p = frag_more(1);
d1108 1
a1108 1
      p = frag_more(1);
d1110 2
a1111 2
      p = frag_more(strlen(name) + 1);
      strcpy(p,name);
d1114 3
a1116 3
      as_bad("invalid opertype");
      ignore_rest_of_line();
      free(name);
d1123 1
a1123 1
  /* enter all registers into the symbol table */
d1125 1
a1125 1
  demand_empty_rest_of_line();
d1130 1
a1130 1
    int ignore ATTRIBUTE_UNUSED;
d1137 1
a1137 1
  int opcode,subopcode;
d1148 1
a1148 1
  name = xstrdup(name);
d1151 1
a1151 1
      ignore_rest_of_line();
d1154 2
a1155 2
  strcpy(syntax,name);
  name_len = strlen(name);
d1185 1
a1185 1
  if(subopcode < 0)
d1187 2
a1188 2
      as_bad ("negative subopcode %d",subopcode);
      ignore_rest_of_line();
d1192 1
a1192 1
  if(subopcode)
d1194 1
a1194 1
      if(3 != opcode)
d1197 1
a1197 1
	  ignore_rest_of_line();
d1205 1
a1205 1
	      ignore_rest_of_line();
d1222 1
a1222 1
  for(i = 0; i < (int) MAXSUFFIXCLASS; i++)
d1224 1
a1224 1
      if(!strncmp(suffixclass[i].name,input_line_pointer, suffixclass[i].len))
d1232 1
a1232 1
  if(-1 == suffixcode)
d1250 1
a1250 1
  for(i = 0; i < (int) MAXSYNTAXCLASS; i++)
d1252 1
a1252 1
      if(!strncmp(syntaxclass[i].name,input_line_pointer, syntaxclass[i].len))
d1260 1
a1260 1
  if(0 == (SYNTAX_VALID & class))
d1267 1
a1267 1
  if ((0x3 == opcode) & (class &  SYNTAX_3OP))
d1277 1
a1277 1
      strcat(syntax,"%.q%.f ");
d1280 1
a1280 1
      strcat(syntax,"%.f ");
d1283 1
a1283 1
      strcat(syntax,"%.q ");
d1286 1
a1286 1
      strcat(syntax," ");
d1289 2
a1290 2
      as_bad("unknown suffix class");
      ignore_rest_of_line();
d1295 4
a1298 4
  strcat(syntax,((opcode == 0x3) ? "%a,%b" : ((class & SYNTAX_3OP) ? "%a,%b,%c" : "%b,%c")));
  if(suffixcode < 2)
    strcat(syntax,"%F");
  strcat(syntax,"%S%L");
d1300 2
a1301 2
  ext_op = (struct arc_opcode *) xmalloc(sizeof (struct arc_opcode));
  if(NULL == ext_op)
d1307 1
a1307 1
  ext_op->syntax = xstrdup(syntax);
d1314 2
a1315 2
  ext_op->mask  = I(-1) | ((0x3 == opcode) ? C(-1) : 0 );
  ext_op->value = I(opcode) | ((0x3 == opcode) ? C(subopcode) : 0 );
d1321 2
a1322 2
  /* ok, now that we know what this inst is, put a description in
     the arc extension section of the output file */
d1327 1
a1327 1
  arc_set_ext_seg();
d1329 3
a1331 3
  p = frag_more(1);
  *p = 5 + name_len +1;
  p = frag_more(1);
d1333 1
a1333 1
  p = frag_more(1);
d1335 1
a1335 1
  p = frag_more(1);
d1337 1
a1337 1
  p = frag_more(1);
d1339 3
a1341 3
  p = frag_more(name_len);
  strncpy(p,syntax,name_len);
  p = frag_more(1);
d1346 1
a1346 1
  demand_empty_rest_of_line();
d1350 1
a1350 1
arc_set_ext_seg()
d1356 1
a1356 1
                             SEC_READONLY | SEC_HAS_CONTENTS);
d1370 1
a1370 1
  int  align, size;
d1407 2
a1408 2
  if ( ((int) S_GET_VALUE (symbolP) != 0) \
       && ((int) S_GET_VALUE (symbolP) != size) )
d1442 2
a1443 1
	frag_align (align, 0, 0); /* do alignment */
d1445 1
a1445 1
      /* detach from old frag */
d1451 1
a1451 1
		        (offsetT) size, (char *) 0);
a1472 1

a1473 1

d1478 1
a1478 1
    int ignore ATTRIBUTE_UNUSED;
a1522 1

d1524 4
a1527 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP.
   An error message is returned, or NULL on OK.  */
d1534 3
a1536 3
  char type;
  char *litP;
  int *sizeP;
d1624 1
a1624 1
arc_code_symbol(expressionP)
d1638 5
a1642 3
  /* allow %st(sym1-sym2) */
  else if (expressionP->X_op == O_subtract && expressionP->X_add_symbol != NULL
	   && expressionP->X_op_symbol != NULL && expressionP->X_add_number == 0)
d1676 1
a1676 1
    if(strncmp (p, "%st(", 4) == 0)
d1686 1
a1686 1
	arc_code_symbol(expressionP);
d1689 2
a1690 2
      {       /* it could be a register */
	int i,l;
d1696 2
a1697 2
	    l = strlen(ext_oper->operand.name);
	    if(!strncmp(p,ext_oper->operand.name,l) && !isalnum(*(p + l)))
d1708 2
a1709 2
	    l = strlen(arc_reg_names[i].name);
	    if(!strncmp(p,arc_reg_names[i].name,l) && !isalnum(*(p + l)))
d1713 1
a1713 1
		expressionP->X_add_number = (int)  &arc_reg_names[i];
d1740 2
a1741 2
  expressionS *exp;
  unsigned int nbytes ATTRIBUTE_UNUSED;
d1746 2
a1747 2
  for (;! is_end_of_line[(unsigned char) *p]; p++)
    if (*p == '@@' && !strncmp(p,"@@h30",4))
d1750 1
a1750 1
	strcpy(p,";   ");
d1755 1
a1755 1
      arc_code_symbol(exp);
d1881 3
a1883 1
  /*char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;*/
d2055 2
a2056 1
		    fixP->fx_r_type, bfd_get_reloc_code_name (fixP->fx_r_type));
d2062 3
a2064 2
/* set addend to account for PC being advanced one insn before the target
   address is computed, drop fx_addnumber as it is handled elsewhere  mlm */
d2066 1
a2066 1
  reloc->addend = ( fixP->fx_pcrel ? -4 : 0 );
@


1.8
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d180 1
a180 1
  {
d204 1
a204 1
  }
d412 2
a413 2
         ? ARC_OPCODE_NEXT_ASM (opcode)
         : (ext_opcode ? ext_opcode = NULL, std_opcode : NULL)))
d486 12
a497 12
                  if (errmsg != (const char *) NULL)
                    {
                    last_errmsg = errmsg;
                    if (operand->flags & ARC_OPERAND_ERROR)
                      {
                      as_bad (errmsg);
                      return;
                      }
                    else if (operand->flags & ARC_OPERAND_WARN)
                      as_warn (errmsg);
                    break;
                    }
d499 6
a504 6
                   && (operand->flags && operand->flags & ARC_OPERAND_LIMM)
                   && (operand->flags &
                        (ARC_OPERAND_ABSOLUTE_BRANCH | ARC_OPERAND_ADDRESS)))
                    {
		    fixups[fix_up_at].opindex = arc_operand_map[operand->fmt];
                    }
d552 4
a555 4
              if ((suf = get_ext_suffix(s)))
                ext_suffix_p = 1;
              else
	        suf = hash_find (arc_suffix_hash, s);
d561 1
a561 1
	          *t = c;
d566 1
a566 1
	         several times, so we have to examine all of them.  This is
d571 38
a608 38
              if (ext_suffix_p && arc_operands[suf->type].fmt == *syn)
                {
                  /* Insert the suffix's value into the insn.  */
	          *t = c;
                  if (operand->insert)
                    insn = (*operand->insert) (insn, operand,
                                               mods, NULL, suf->value,
                                               NULL);
                  else
                    insn |= suf->value << operand->shift;

                  str = t;
                  found = 1;
                }
              else
                {
	          *t = c;
	          suffix_end = arc_suffixes + arc_suffixes_count;
	          for (suffix = suf;
		     suffix < suffix_end && strcmp (suffix->name, suf->name) == 0;
		     ++suffix)
		     {
		       if (arc_operands[suffix->type].fmt == *syn)
		         {
		           /* Insert the suffix's value into the insn.  */
		           if (operand->insert)
			     insn = (*operand->insert) (insn, operand,
						    mods, NULL, suffix->value,
						    NULL);
		           else
			     insn |= suffix->value << operand->shift;

		           str = t;
		           found = 1;
		           break;
		         }
		      }
                 }
d658 2
a659 2
                as_bad("symbol as destination register");
              else
d661 5
a665 5
                  if(!strncmp(str,"@@h30",4))
                    {
                    arc_code_symbol(&exp);
                    str += 4;
                    }
d670 2
a671 2
                  /* We don't support shimm relocs. break here to force
                     the assembler to output a limm  */
d673 2
a674 2
                  if(IS_REG_SHIMM_OFFSET(*syn))
                    break;
d685 2
a686 2
                      /* save this, we don't yet know what reloc to use */
                      fix_up_at = fc;
d706 12
a717 12
                  if (errmsg != (const char *) NULL)
                    {
                    last_errmsg = errmsg;
                    if (operand->flags & ARC_OPERAND_ERROR)
                      {
                      as_bad (errmsg);
                      return;
                      }
                    else if (operand->flags & ARC_OPERAND_WARN)
                      as_warn (errmsg);
                    break;
                    }
d782 1
a782 1
		as_warn ("8 byte instruction in delay slot");
d785 1
a785 1
		as_warn ("8 byte jump instruction with delay slot");
d793 1
a793 1
		as_warn ("conditional branch follows set of flags");
d795 3
a797 3
	    /* FIXME: ??? not required:
	       (delay_slot_type != ARC_DELAY_NONE) &&  */
		cc_set_p && !limm_p;
d841 2
a842 2
                /* modify the fixup addend as required by the cpu */
                  fixups[i].exp.X_add_number += arc_limm_fixup_adjust(insn);
d846 3
a848 3
                   || op_type == arc_operand_map['s']
                   || op_type == arc_operand_map['o']
                   || op_type == arc_operand_map['O'])
d909 2
a910 2
    ignore_rest_of_line();
    return;
d916 3
a918 3
    if (isupper(*p))
      *p = tolower(*p);
    p++;
d939 4
a942 4
    as_bad ("negative operand number %d",number);
    ignore_rest_of_line();
    free(name);
    return;
d950 6
a955 6
        {
          as_bad ("expected comma after register-number");
          ignore_rest_of_line ();
          free(name);
          return;
        }
d961 4
a964 4
        {
          imode = 0;
          input_line_pointer += 3;
        }
d966 56
a1021 56
        {
          if (!strncmp(mode,"r",1))
            {
              imode = ARC_REGISTER_READONLY;
              input_line_pointer += 1;
            }
          else
            {
              if (strncmp(mode,"w",1))
                {
                  as_bad ("invalid mode");
                  ignore_rest_of_line();
                  free(name);
                  return;
                }
              else
                {
                  imode = ARC_REGISTER_WRITEONLY;
                  input_line_pointer += 1;
                }
            }
          }
    SKIP_WHITESPACE();
    if (1 == opertype)
      {
        if (*input_line_pointer != ',')
          {
            as_bad ("expected comma after register-mode");
            ignore_rest_of_line ();
            free(name);
            return;
          }

        input_line_pointer++;             /* skip ',' */

        if(!strncmp(input_line_pointer,"cannot_shortcut",15))
          {
          imode |= arc_get_noshortcut_flag();
          input_line_pointer += 15;
          }
      else
        {
          if(strncmp(input_line_pointer,"can_shortcut",12))
            {
            as_bad ("shortcut designator invalid");
            ignore_rest_of_line();
            free(name);
            return;
            }
          else
           {
             input_line_pointer += 12;
           }
         }
       }
     }
d1024 6
a1029 6
   {
   as_bad("core register value (%d) too large", number);
   ignore_rest_of_line();
   free(name);
   return;
   }
d1032 6
a1037 6
   {
   as_bad("condition code value (%d) too large", number);
   ignore_rest_of_line();
   free(name);
   return;
   }
d1040 1
a1040 1
      xmalloc(sizeof (struct arc_ext_operand_value));
d1046 12
a1057 12
        {
          if (S_GET_SEGMENT(symbolP) == reg_section)
            S_SET_VALUE(symbolP,(int)&ext_oper->operand);
          else
            {
              as_bad("attempt to override symbol: %s",name);
              ignore_rest_of_line();
              free(name);
              free(ext_oper);
              return;
            }
        }
d1059 5
a1063 5
        {
        /* If its not there, add it */
        symbol_table_insert (symbol_create (name, reg_section,
                           (int) &ext_oper->operand, &zero_address_frag));
        }
d1074 2
a1075 2
/* ok, now that we know what this operand is, put a description
   in the arc extension section of the output file */
d1083 44
a1126 44
   {
   case 0:
    p = frag_more(1);
    *p = 3 + strlen(name) + 1;
    p = frag_more(1);
    *p = EXT_COND_CODE;
    p = frag_more(1);
    *p = number;
    p = frag_more(strlen(name) + 1);
    strcpy(p,name);
    break;
   case 1:
    p = frag_more(1);
    *p = 3 + strlen(name) + 1;
    p = frag_more(1);
    *p = EXT_CORE_REGISTER;
    p = frag_more(1);
    *p = number;
    p = frag_more(strlen(name) + 1);
    strcpy(p,name);
    break;
   case 2:
    p = frag_more(1);
    *p = 6 + strlen(name) + 1;
    p = frag_more(1);
    *p = EXT_AUX_REGISTER;
    p = frag_more(1);
    *p = number >> 24 & 0xff;
    p = frag_more(1);
    *p = number >> 16 & 0xff;
    p = frag_more(1);
    *p = number >>  8 & 0xff;
    p = frag_more(1);
    *p = number       & 0xff;
    p = frag_more(strlen(name) + 1);
    strcpy(p,name);
    break;
   default:
    as_bad("invalid opertype");
    ignore_rest_of_line();
    free(name);
    return;
    break;
   }
d1130 1
a1130 1
/* enter all registers into the symbol table */
d1158 2
a1159 2
    ignore_rest_of_line();
    return;
d1194 3
a1196 3
    as_bad ("negative subopcode %d",subopcode);
    ignore_rest_of_line();
    return;
d1201 15
a1215 15
    if(3 != opcode)
      {
        as_bad ("subcode value found when opcode not equal 0x03");
        ignore_rest_of_line();
        return;
      }
    else
      {
      if (subopcode < 0x09 || subopcode == 0x3f)
        {
          as_bad ("invalid subopcode %d", subopcode);
          ignore_rest_of_line();
          return;
        }
      }
d1231 6
a1236 6
    if(!strncmp(suffixclass[i].name,input_line_pointer, suffixclass[i].len))
      {
      suffixcode = i;
      input_line_pointer += suffixclass[i].len;
      break;
      }
d1259 6
a1264 6
    if(!strncmp(syntaxclass[i].name,input_line_pointer, syntaxclass[i].len))
      {
      class = syntaxclass[i].class;
      input_line_pointer += syntaxclass[i].len;
      break;
      }
d1282 19
a1300 19
   {
   case 0:
    strcat(syntax,"%.q%.f ");
    break;
   case 1:
    strcat(syntax,"%.f ");
    break;
   case 2:
    strcat(syntax,"%.q ");
    break;
   case 3:
    strcat(syntax," ");
    break;
   default:
    as_bad("unknown suffix class");
    ignore_rest_of_line();
    return;
    break;
   };
d1310 2
a1311 2
    ignore_rest_of_line ();
    return;
d1317 2
a1318 2
    ignore_rest_of_line ();
    return;
d1328 2
a1329 2
/* ok, now that we know what this inst is, put a description in
  the arc extension section of the output file */
d1637 2
a1638 2
	  /* I think this test is unnecessary but just as a sanity check...  */
    && expressionP->X_op_symbol == NULL)
d1640 6
a1645 6
    expressionS two;
    expressionP->X_op = O_right_shift;
    two.X_op = O_constant;
    two.X_add_symbol = two.X_op_symbol = NULL;
    two.X_add_number = 2;
    expressionP->X_op_symbol = make_expr_symbol (&two);
d1647 1
a1647 1
      /* allow %st(sym1-sym2) */
d1649 1
a1649 1
       && expressionP->X_op_symbol != NULL && expressionP->X_add_number == 0)
d1651 7
a1657 7
    expressionS two;
    expressionP->X_add_symbol = make_expr_symbol (expressionP);
    expressionP->X_op = O_right_shift;
    two.X_op = O_constant;
    two.X_add_symbol = two.X_op_symbol = NULL;
    two.X_add_number = 2;
    expressionP->X_op_symbol = make_expr_symbol (&two);
d1661 2
a1662 2
    as_bad ("expression too complex code symbol");
    return;
d1685 9
a1693 9
      input_line_pointer += 4;
      expression (expressionP);
      if (*input_line_pointer != ')')
	{
	  as_bad ("missing ')' in %%-op");
	  return;
	}
      ++input_line_pointer;
      arc_code_symbol(expressionP);
d1695 5
a1699 5
  else
    {       /* it could be a register */
    int i,l;
    struct arc_ext_operand_value *ext_oper = arc_ext_operands;
    p++;
d1701 23
a1723 22
    while (ext_oper)
      {
      l = strlen(ext_oper->operand.name);
      if(!strncmp(p,ext_oper->operand.name,l) && !isalnum(*(p + l)))
        {
        input_line_pointer += l + 1;
        expressionP->X_op = O_register;
        expressionP->X_add_number = (int) &ext_oper->operand;
        return;
        }
      ext_oper = ext_oper->next;
      }
    for (i = 0; i < arc_reg_names_count; i++)
      {
      l = strlen(arc_reg_names[i].name);
      if(!strncmp(p,arc_reg_names[i].name,l) && !isalnum(*(p + l)))
        {
        input_line_pointer += l + 1;
        expressionP->X_op = O_register;
        expressionP->X_add_number = (int)  &arc_reg_names[i];
        break;
        }
a1724 1
    }
d1754 5
a1758 5
      if (*p == '@@' && !strncmp(p,"@@h30",4))
	  {
	      code_symbol_fix = 1;
	      strcpy(p,";   ");
	  }
d1761 4
a1764 4
      {
	  arc_code_symbol(exp);
	  input_line_pointer = p;
      }
@


1.7
log
@Updated ARC assembler from arccores.com
@
text
@d59 1
a59 1
#define MAXSUFFIXCLASS (sizeof(suffixclass) / sizeof(struct suffix_classes))
d74 1
a74 1
#define MAXSYNTAXCLASS (sizeof(syntaxclass) / sizeof(struct syntax_classes))
d107 1
a107 1
   #NO_APP at the beginning of its output. */
d109 1
a109 1
   work if '/' isn't otherwise defined. */
d602 1
a602 1
 
d677 1
a677 1
		     must be a limm. */
d685 1
a685 1
                      /* save this, we don't yet know what reloc to use */ 
d956 1
a956 1
    
d959 1
a959 1
    
d1017 1
a1017 1
             input_line_pointer += 12; 
d1040 1
a1040 1
      xmalloc(sizeof(struct arc_ext_operand_value));
d1044 1
a1044 1
      /* if the symbol already exists, point it at the new definition */ 
d1307 1
a1307 1
  ext_op = (struct arc_opcode *) xmalloc(sizeof(struct arc_opcode));
a1421 1

d1598 1
a1598 1
/* Round up a section size to the appropriate boundary. */
d1637 1
a1637 1
	  /* I think this test is unnecessary but just as a sanity check... */
d1674 1
a1674 1
   to achieve the same effect. */
d1676 1
a1676 1
void 
d1799 1
a1799 1
long 
@


1.6
log
@Apply patch from Peter Targett to fix building arc-elf32 target.
@
text
@d2 1
a2 2
   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d23 1
d27 1
d31 6
d43 3
a45 2
static void arc_cpu PARAMS ((int));
/*static void arc_rename PARAMS ((int));*/
d49 27
d78 2
a79 1
  { "align", s_align_bytes, 0 },	/* Defaulting is invalid (0) */
d81 7
a87 1
/*{ "hword", cons, 2 }, - already exists */
d89 6
a94 3
/*{ "xword", cons, 8 },*/
  { "cpu", arc_cpu, 0 },
/*{ "rename", arc_rename, 0 },*/
d107 1
a107 1
   #NO_APP at the beginning of its output.  */
d109 1
a109 1
   work if '/' isn't otherwise defined.  */
d127 4
a130 2
/* One of bfd_mach_arc_xxx.  */
static int arc_mach_type = bfd_mach_arc_base;
d148 10
d162 5
d180 14
a193 1
    {
d204 1
a204 1
    }
d212 5
a216 4
  fprintf (stream, _("\
ARC options:\n\
-EB			generate big endian output\n\
-EL			generate little endian output\n"));
d231 1
a231 1
    as_warn (_("could not set architecture and machine"));
d233 1
a233 1
  /* Assume the base cpu.  This call is necessary because we need to
d236 1
a236 1
  arc_opcode_init_tables (arc_get_opcode_mach (bfd_mach_arc_base,
d251 1
a251 1
    as_fatal (_("virtual memory exhausted"));
d254 1
a254 1
    as_warn (_("could not set architecture and machine"));
a264 2
      if (! arc_opval_supported (&arc_suffixes[i]))
	continue;
d273 5
a277 1
     the index in `arc_reg_names'.  */
d280 1
a280 1
      if (! arc_opval_supported (&arc_reg_names[i]))
d285 1
a285 1
					  i, &zero_address_frag));
d288 1
a288 1
  /* Tell `s_cpu' it's too late.  */
d332 1
a332 1
	    _("operand out of range (%s not between %ld and %ld)");
d381 2
d384 1
d403 2
a404 1
  opcode = arc_opcode_lookup_asm (str);
d409 5
a413 1
  for ( ; opcode != NULL; opcode = ARC_OPCODE_NEXT_ASM (opcode))
d416 1
d422 1
d437 1
d478 1
a478 1
	    as_fatal (_("unknown syntax format character `%c'"), *syn);
d486 19
a504 3
		  /* If we get an error, go on to try the next insn.  */
		  if (errmsg)
		    break;
d514 2
a515 1
	      const struct arc_operand_value *suf,*suffix,*suffix_end;
d548 1
a548 1
	      for (t = s; *t && isalpha (*t); ++t)
d552 4
a555 2
	      suf = hash_find (arc_suffix_hash, s);
	      *t = c;
d561 1
d571 38
a608 20
	      suffix_end = arc_suffixes + arc_suffixes_count;
	      for (suffix = suf;
		   suffix < suffix_end && strcmp (suffix->name, suf->name) == 0;
		   ++suffix)
		{
		  if (arc_operands[suffix->type].fmt == *syn)
		    {
		      /* Insert the suffix's value into the insn.  */
		      if (operand->insert)
			insn = (*operand->insert) (insn, operand,
						   mods, NULL, suffix->value,
						   NULL);
		      else
			insn |= suffix->value << operand->shift;

		      str = t;
		      found = 1;
		      break;
		    }
		}
d615 1
a615 1
		    as_bad (_("too many suffixes"));
a635 14
#if 0
	      /* Is this a syntax character?  Eg: is there a '[' present when
		 there shouldn't be?  */
	      if (!isalnum (*str)
		  /* '.' as in ".LLC0" */
		  && *str != '.'
		  /* '_' as in "_print" */
		  && *str != '_'
		  /* '-' as in "[fp,-4]" */
		  && *str != '-'
		  /* '%' as in "%ia(_func)" */
		  && *str != '%')
		break;
#endif
d645 1
a645 1
		as_bad (_("illegal operand"));
d647 1
a647 1
		as_bad (_("missing operand"));
d654 1
a654 1
		  reg = arc_reg_names + exp.X_add_number;
d656 4
a659 1
	      else
d661 5
d668 1
a668 1
		    as_fatal (_("too many fixups"));
d670 5
a674 1

d677 1
a677 1
		     must be a limm.  We don't support shimm relocs.  */
d681 1
a681 2
#define IS_REG_OPERAND(o) ((o) == 'a' || (o) == 'b' || (o) == 'c')
		  if (IS_REG_OPERAND (*syn))
a683 2

		      fixups[fc].opindex = arc_operand_map['L'];
d685 2
d706 12
a717 12
#if 0
		  if (errmsg != (const char *) NULL)
		    as_warn (errmsg);
#endif
		  /* FIXME: We want to try shimm insns for limm ones.  But if
		     the constant won't fit, we must go on to try the next
		     possibility.  Where do we issue warnings for constants
		     that are too big then?  At present, we'll flag the insn
		     as unrecognizable!  Maybe have the "bad instruction"
		     error message include our `errmsg'?  */
		  if (errmsg != (const char *) NULL)
		    break;
d743 1
a743 1
	    as_bad (_("junk at end of line: `%s'"), str);
d782 4
a785 3
	      as_warn (_("8 byte instruction in delay slot"));
	    if (delay_slot_type != ARC_DELAY_NONE && limm_p)
	      as_warn (_("8 byte jump instruction with delay slot"));
d792 6
a797 3
		&& prev_insn_needs_cc_nop_p)
	      as_warn (_("conditional branch follows set of flags"));
	    prev_insn_needs_cc_nop_p = cc_set_p && !limm_p;
d841 2
d845 4
a848 1
		  if (op_type == arc_operand_map['L'])
d880 4
a883 1
  as_bad (_("bad instruction `%s'"), start);
d885 1
a886 1
/* ??? This was copied from tc-sparc.c, I think.  Is it necessary?  */
d889 2
a890 2
arc_common (ignore)
     int ignore ATTRIBUTE_UNUSED;
d893 1
d896 3
a898 2
  int temp;
  unsigned int size;
d901 3
d906 15
d925 1
d928 1
a928 1
      as_bad (_("expected comma after symbol-name"));
d930 1
d933 1
d935 236
a1170 1
  if ((temp = get_absolute_expression ()) < 0)
d1172 1
a1172 1
      as_bad (_(".COMMon length (%d.) <0! Ignored."), temp);
d1176 7
a1182 5
  size = temp;
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d1184 1
a1184 1
      as_bad (_("ignoring attempt to re-define symbol"));
d1188 12
a1199 1
  if (S_GET_VALUE (symbolP) != 0)
d1201 15
a1215 5
      if (S_GET_VALUE (symbolP) != size)
	{
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
	}
d1217 3
a1219 1
  assert (symbol_get_frag (symbolP) == &zero_address_frag);
d1222 1
a1222 1
      as_bad (_("expected comma after common length"));
d1226 20
a1245 1
  input_line_pointer++;
d1247 28
a1274 1
  if (*input_line_pointer != '"')
d1276 3
a1278 38
      temp = get_absolute_expression ();
      if (temp < 0)
	{
	  temp = 0;
	  as_warn (_("Common alignment negative; 0 assumed"));
	}
      if (S_IS_LOCAL(symbolP))
	{
	  segT old_sec;
	  int old_subsec;
	  char *p;
	  int align;

	  old_sec = now_seg;
	  old_subsec = now_subseg;
	  align = temp;
	  record_alignment (bss_section, align);
	  subseg_set (bss_section, 0);
	  if (align)
	    frag_align (align, 0, 0);
	  if (S_GET_SEGMENT (symbolP) == bss_section)
	    symbol_get_frag (symbolP)->fr_symbol = 0;
	  symbol_set_frag (symbolP, frag_now);
	  p = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			(offsetT) size, (char *) 0);
	  *p = 0;
	  S_SET_SEGMENT (symbolP, bss_section);
	  S_CLEAR_EXTERNAL (symbolP);
	  subseg_set (old_sec, old_subsec);
	}
      else
	{
	allocate_common:
	  S_SET_VALUE (symbolP, (valueT) size);
	  S_SET_ALIGN (symbolP, temp);
	  S_SET_EXTERNAL (symbolP);
	  S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
	}
d1280 29
a1308 1
  else
d1310 2
a1311 11
      input_line_pointer++;
      /* ??? Some say data, some say bss.  */
      if (strncmp (input_line_pointer, ".bss\"", 5)
	  && strncmp (input_line_pointer, ".data\"", 6))
	{
	  input_line_pointer--;
	  goto bad_common_segment;
	}
      while (*input_line_pointer++ != '"')
	;
      goto allocate_common;
a1312 2
  demand_empty_rest_of_line ();
  return;
d1314 3
a1316 10
  {
  bad_common_segment:
    p = input_line_pointer;
    while (*p && *p != '\n')
      p++;
    c = *p;
    *p = '\0';
    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
    *p = c;
    input_line_pointer = p;
d1319 35
a1353 1
  }
d1356 13
a1368 1
/* Select the cpu we're assembling for.  */
d1371 2
a1372 2
arc_cpu (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1374 1
a1374 1
  int mach;
d1376 31
a1406 1
  char *cpu;
d1408 1
a1408 2
  /* If an instruction has already been seen, it's too late.  */
  if (cpu_tables_init_p)
d1410 1
a1410 1
      as_bad (_(".cpu command must appear before any instructions"));
d1414 7
a1421 6
  cpu = input_line_pointer;
  c = get_symbol_end ();
  mach = arc_get_mach (cpu);
  *input_line_pointer = c;
  if (mach == -1)
    goto bad_cpu;
d1423 14
a1436 1
  demand_empty_rest_of_line ();
d1438 29
a1466 6
  /* The cpu may have been selected on the command line.
     The choices must match.  */
  /* ??? This was a command line option early on.  It's gone now, but
     leave this in.  */
  if (mach_type_specified_p && mach != arc_mach_type)
    as_bad (_(".cpu conflicts with previous value"));
d1469 4
a1472 4
      arc_mach_type = mach;
      mach_type_specified_p = 1;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_arc, mach))
	as_warn (_("could not set architecture and machine"));
d1474 4
d1479 1
d1481 1
a1481 4
 bad_cpu:
  as_bad (_("bad .cpu op"));
  ignore_rest_of_line ();
}
d1483 1
a1483 3
#if 0
/* The .rename pseudo-op.  This is used by gcc to implement
   -mmangle-cpu-libgcc.  */
d1486 2
a1487 2
arc_rename (ignore)
     int ignore;
d1489 1
a1489 1
  char *name,*new;
d1491 1
a1491 2
  symbolS *sym;
  int len;
d1493 1
a1493 1
  name = input_line_pointer;
d1495 1
a1495 1
  sym = symbol_find_or_make (name);
d1498 2
a1499 1
  if (*input_line_pointer != ',')
d1501 1
a1501 1
      as_bad (_("missing rename string"));
a1504 2
  ++input_line_pointer;
  SKIP_WHITESPACE ();
d1506 4
a1509 3
  name = input_line_pointer;
  c = get_symbol_end ();
  if (*name == '\0')
d1511 1
a1511 2
      *input_line_pointer = c;
      as_bad (_("invalid symbol to rename to"));
d1515 12
a1526 4
  new = (char *) xmalloc (strlen (name) + 1);
  strcpy (new, name);
  *input_line_pointer = c;
  symbol_get_tc (sym)->real_name = new;
d1528 3
a1530 1
  demand_empty_rest_of_line ();
d1532 1
a1532 1
#endif
d1539 1
a1539 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d1544 3
a1546 3
     char type;
     char *litP;
     int *sizeP;
d1568 1
a1568 1
      return _("bad call to md_atof");
d1599 1
a1599 1
/* Round up a section size to the appropriate boundary.  */
d1618 2
a1619 1
  abort ();
d1630 35
a1664 1
  abort ();
d1675 1
a1675 2
   to achieve the same effect.  Perhaps put a special cookie in X_add_number
   to mark the expression as special.  */
d1677 1
a1677 1
void
d1683 3
a1685 2
  if (*p == '%' && strncmp (p, "%st(", 4) == 0)
    {
d1690 1
a1690 1
	  as_bad (_("missing ')' in %-op"));
d1694 31
a1724 33
      if (expressionP->X_op == O_symbol
	  && expressionP->X_add_number == 0
	  /* I think this test is unnecessary but just as a sanity check...  */
	  && expressionP->X_op_symbol == NULL)
	{
	  expressionS two;

	  expressionP->X_op = O_right_shift;
	  two.X_op = O_constant;
	  two.X_add_symbol = two.X_op_symbol = NULL;
	  two.X_add_number = 2;
	  expressionP->X_op_symbol = make_expr_symbol (&two);
	}
      /* allow %st(sym1-sym2) */
      else if (expressionP->X_op == O_subtract
	       && expressionP->X_add_symbol != NULL
	       && expressionP->X_op_symbol != NULL
	       && expressionP->X_add_number == 0)
	{
	  expressionS two;

	  expressionP->X_add_symbol = make_expr_symbol (expressionP);
	  expressionP->X_op = O_right_shift;
	  two.X_op = O_constant;
	  two.X_add_symbol = two.X_op_symbol = NULL;
	  two.X_add_number = 2;
	  expressionP->X_op_symbol = make_expr_symbol (&two);
	}
      else
	{
	  as_bad (_("expression too complex for %%st"));
	  return;
	}
d1748 2
a1749 2
     expressionS *exp;
     int nbytes ATTRIBUTE_UNUSED;
d1751 9
d1761 5
d1800 1
a1800 1
long
d1850 2
a1851 2
      && symbol_constant_p (exp->X_op_symbol)
      && S_GET_VALUE (exp->X_op_symbol) == 2
d1855 2
a1856 2
	  && (symbol_constant_p (exp->X_add_symbol)
	      || symbol_equated_p (exp->X_add_symbol)))
d1864 1
a1864 2
	       && (symbol_get_value_expression (exp->X_add_symbol)->X_op
		   == O_subtract))
d1866 1
a1866 1
	  *expnew = *symbol_get_value_expression (exp->X_add_symbol);
d1930 1
a1930 1
			    _("expression too complex"));
d1979 1
a1979 1
      else if (0 && operand->fmt == 'J')
d1986 1
a1986 1
      else if (0 && operand->fmt == 'L')
d1996 1
a1996 1
			_("unresolved expression that must be resolved"));
d2054 1
a2054 2
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
d2060 1
a2060 1
		    _("internal error: can't export reloc type %d (`%s')"),
d2067 4
a2070 1
  reloc->addend = fixP->fx_addnumber;
a2073 17

/* Frobbers.  */

#if 0
/* Set the real name if the .rename pseudo-op was used.
   Return 1 if the symbol should not be included in the symbol table.  */

int
arc_frob_symbol (sym)
     symbolS *sym;
{
  if (symbol_get_tc (sym)->real_name != (char *) NULL)
    S_SET_NAME (sym, symbol_get_tc (sym)->real_name);

  return 0;
}
#endif
@


1.5
log
@2000-09-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-a29k.c: Fix formatting.
	* config/tc-alpha.c: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-tic80.h: Likewise.
@
text
@d116 1
a116 1
     char *arg;
d172 1
a172 1
  register unsigned int i;
d383 1
a383 1
	  while (ARC_MOD_P (arc_operands[arc_operand_map[*syn]].flags))
d385 1
a385 1
	      mods |= arc_operands[arc_operand_map[*syn]].flags & ARC_MOD_BITS;
d388 1
a388 1
	  operand = arc_operands + arc_operand_map[*syn];
a496 1
	      char c;
d572 1
a572 1
		    fixups[fc].opindex = arc_operand_map[*syn];
a637 1
	    int need_cc_nop_p = 0;
d755 1
a755 1
     int ignore;
d760 2
a761 1
  int temp, size;
d818 1
a818 1
      if (symbolP->local)
a824 1
	allocate_bss:
d887 1
a887 1
     int ignore;
d1056 2
a1057 2
     fragS *fragp;
     asection *seg;
d1066 3
a1068 3
     bfd *abfd;
     asection *sec;
     fragS *fragp;
d1142 1
a1142 1
     char *name;
d1157 1
a1157 1
     int nbytes;
d1442 1
a1442 1
     asection *section;
@


1.4
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 1995, 1997, 1998, 1999 Free Software Foundation, Inc.
d21 1
a21 1
   02111-1307, USA. */
d63 1
a63 1
   #NO_APP at the beginning of its output. */
d65 1
a65 1
   work if '/' isn't otherwise defined. */
d1042 1
a1042 1
/* Round up a section size to the appropriate boundary. */
d1086 1
a1086 1
void 
d1104 1
a1104 1
	  /* I think this test is unnecessary but just as a sanity check... */
d1196 1
a1196 1
long 
@


1.3
log
@	* config/tc-arc.c (get_arc_exp_reloc_type): Change uses of
	sy_value with appropriate accessor functions.
	* config/tc-arm.c (md_apply_fix3): Likewise.
	* config/tc-d10v.c (AT_WORD_P): Likewise.
	* config/tc-v850.c (reg_name_search): Likewise.
@
text
@d801 1
a801 1
  assert (symbolP->sy_frag == &zero_address_frag);
d834 2
a835 2
	    symbolP->sy_frag->fr_symbol = 0;
	  symbolP->sy_frag = frag_now;
d970 1
a970 1
  sym->sy_tc.real_name = new;
d1479 2
a1480 2
  if (sym->sy_tc.real_name != (char *) NULL)
    S_SET_NAME (sym, sym->sy_tc.real_name);
@


1.2
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d1245 2
a1246 2
      && exp->X_op_symbol->sy_value.X_op == O_constant
      && exp->X_op_symbol->sy_value.X_add_number == 2
d1250 2
a1251 2
	  && (exp->X_add_symbol->sy_value.X_op == O_constant
	      || exp->X_add_symbol->sy_value.X_op == O_symbol))
d1259 2
a1260 1
	       && exp->X_add_symbol->sy_value.X_op == O_subtract)
d1262 1
a1262 1
	  *expnew = exp->X_add_symbol->sy_value;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1997, 1998 Free Software Foundation, Inc.
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d1449 2
a1450 1
  reloc->sym_ptr_ptr = &fixP->fx_addsy->bsym;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

