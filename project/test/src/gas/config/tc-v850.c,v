head	1.64;
access;
symbols
	binutils-2_24-branch:1.64.0.2
	binutils-2_24-branchpoint:1.64
	binutils-2_21_1:1.57.2.1
	binutils-2_23_2:1.58
	binutils-2_23_1:1.58
	binutils-2_23:1.58
	binutils-2_23-branch:1.58.0.6
	binutils-2_23-branchpoint:1.58
	binutils-2_22_branch:1.58.0.4
	binutils-2_22:1.58
	binutils-2_22-branch:1.58.0.2
	binutils-2_22-branchpoint:1.58
	binutils-2_21:1.57
	binutils-2_21-branch:1.57.0.2
	binutils-2_21-branchpoint:1.57
	binutils-2_20_1:1.54
	binutils-2_20:1.54
	binutils-arc-20081103-branch:1.53.0.8
	binutils-arc-20081103-branchpoint:1.53
	binutils-2_20-branch:1.54.0.2
	binutils-2_20-branchpoint:1.54
	dje-cgen-play1-branch:1.53.0.6
	dje-cgen-play1-branchpoint:1.53
	arc-20081103-branch:1.53.0.4
	arc-20081103-branchpoint:1.53
	binutils-2_19_1:1.53
	binutils-2_19:1.53
	binutils-2_19-branch:1.53.0.2
	binutils-2_19-branchpoint:1.53
	binutils-2_18:1.52
	binutils-2_18-branch:1.52.0.2
	binutils-2_18-branchpoint:1.52
	binutils-csl-coldfire-4_1-32:1.50
	binutils-csl-sourcerygxx-4_1-32:1.50
	binutils-csl-innovasic-fido-3_4_4-33:1.50
	binutils-csl-sourcerygxx-3_4_4-32:1.43
	binutils-csl-coldfire-4_1-30:1.50
	binutils-csl-sourcerygxx-4_1-30:1.50
	binutils-csl-coldfire-4_1-28:1.50
	binutils-csl-sourcerygxx-4_1-29:1.50
	binutils-csl-sourcerygxx-4_1-28:1.50
	binutils-csl-arm-2006q3-27:1.50
	binutils-csl-sourcerygxx-4_1-27:1.50
	binutils-csl-arm-2006q3-26:1.50
	binutils-csl-sourcerygxx-4_1-26:1.50
	binutils-csl-sourcerygxx-4_1-25:1.50
	binutils-csl-sourcerygxx-4_1-24:1.50
	binutils-csl-sourcerygxx-4_1-23:1.50
	binutils-csl-sourcerygxx-4_1-21:1.50
	binutils-csl-arm-2006q3-21:1.50
	binutils-csl-sourcerygxx-4_1-22:1.50
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.50
	binutils-csl-sourcerygxx-4_1-20:1.50
	binutils-csl-arm-2006q3-19:1.50
	binutils-csl-sourcerygxx-4_1-19:1.50
	binutils-csl-sourcerygxx-4_1-18:1.50
	binutils-csl-renesas-4_1-9:1.50
	binutils-csl-sourcerygxx-3_4_4-25:1.43
	binutils-csl-renesas-4_1-8:1.50
	binutils-csl-renesas-4_1-7:1.50
	binutils-csl-renesas-4_1-6:1.50
	binutils-csl-sourcerygxx-4_1-17:1.50
	binutils-csl-sourcerygxx-4_1-14:1.50
	binutils-csl-sourcerygxx-4_1-15:1.50
	binutils-csl-sourcerygxx-4_1-13:1.50
	binutils-2_17:1.50
	binutils-csl-sourcerygxx-4_1-12:1.50
	binutils-csl-sourcerygxx-3_4_4-21:1.50
	binutils-csl-wrs-linux-3_4_4-24:1.43
	binutils-csl-wrs-linux-3_4_4-23:1.43
	binutils-csl-sourcerygxx-4_1-9:1.50
	binutils-csl-sourcerygxx-4_1-8:1.50
	binutils-csl-sourcerygxx-4_1-7:1.50
	binutils-csl-arm-2006q1-6:1.50
	binutils-csl-sourcerygxx-4_1-6:1.50
	binutils-csl-wrs-linux-3_4_4-22:1.43
	binutils-csl-coldfire-4_1-11:1.50
	binutils-csl-sourcerygxx-3_4_4-19:1.50
	binutils-csl-coldfire-4_1-10:1.50
	binutils-csl-sourcerygxx-4_1-5:1.50
	binutils-csl-sourcerygxx-4_1-4:1.50
	binutils-csl-wrs-linux-3_4_4-21:1.43
	binutils-csl-morpho-4_1-4:1.50
	binutils-csl-sourcerygxx-3_4_4-17:1.50
	binutils-csl-wrs-linux-3_4_4-20:1.43
	binutils-2_17-branch:1.50.0.4
	binutils-2_17-branchpoint:1.50
	binutils-csl-2_17-branch:1.50.0.2
	binutils-csl-2_17-branchpoint:1.50
	binutils-csl-gxxpro-3_4-branch:1.43.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.43
	binutils-2_16_1:1.43
	binutils-csl-arm-2005q1b:1.43
	binutils-2_16:1.43
	binutils-csl-arm-2005q1a:1.43
	binutils-csl-arm-2005q1-branch:1.43.0.4
	binutils-csl-arm-2005q1-branchpoint:1.43
	binutils-2_16-branch:1.43.0.2
	binutils-2_16-branchpoint:1.43
	csl-arm-2004-q3d:1.39
	csl-arm-2004-q3:1.39
	binutils-2_15:1.37
	binutils-2_15-branchpoint:1.37
	csl-arm-2004-q1a:1.37
	csl-arm-2004-q1:1.37
	binutils-2_15-branch:1.37.0.6
	cagney_bfdfile-20040213-branch:1.37.0.4
	cagney_bfdfile-20040213-branchpoint:1.37
	cagney_bigcore-20040122-branch:1.37.0.2
	cagney_bigcore-20040122-branchpoint:1.37
	csl-arm-2003-q4:1.37
	binutils-2_14:1.31.2.1
	binutils-2_14-branch:1.31.0.2
	binutils-2_14-branchpoint:1.31
	binutils-2_13_2_1:1.21.2.2
	binutils-2_13_2:1.21.2.2
	binutils-2_13_1:1.21.2.2
	binutils-2_13:1.21
	binutils-2_13-branchpoint:1.21
	binutils-2_13-branch:1.21.0.2
	binutils-2_12_1:1.20
	binutils-2_12:1.20
	binutils-2_12-branch:1.20.0.2
	binutils-2_12-branchpoint:1.20
	cygnus_cvs_20020108_pre:1.19
	binutils-2_11_2:1.12.2.1
	binutils-2_11_1:1.12.2.1
	binutils-2_11:1.12
	x86_64versiong3:1.12
	binutils-2_11-branch:1.12.0.2
	binutils-2_10_1:1.7
	binutils-2_10:1.7
	binutils-2_10-branch:1.7.0.2
	binutils-2_10-branchpoint:1.7
	binutils_latest_snapshot:1.64
	repo-unification-2000-02-06:1.7
	binu_ss_19990721:1.6
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.64
date	2013.04.04.07.24.08;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2013.01.24.11.14.00;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2013.01.15.08.45.41;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2012.11.09.17.36.14;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2012.11.09.08.29.32;	author hjl;	state Exp;
branches;
next	1.59;

1.59
date	2012.10.04.10.30.04;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.12.23.50.23;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2010.08.02.08.43.18;	author amodra;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2010.07.23.14.52.50;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2010.03.13.15.54.21;	author segher;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.24.11.45.01;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.11.17.39.49;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.22.05.55.15;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.18.09.42.13;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.17.11.56.11;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.05.09.13.04;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.24.20.40.27;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.03.11.47.56;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.23.12.28.06;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.31.23.18.34;	author bje;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.16.16.56.02;	author rsandifo;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.17.12.19.57;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.06.11.01.48;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.22.15.32.28;	author kazu;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.04.11.04.36;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.15.04.04.18;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.24.11.10.47;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.03.16.24.06;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.21.12.07.56;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.21.12.33.34;	author nickc;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.14.11.28.56;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.26.22.04.19;	author wilson;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.29.06.49.34;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.16.07.01.47;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.31.09.17.52;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.08.07.37.16;	author amodra;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2002.02.01.16.29.19;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.15.21.28.59;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.19.05.33.30;	author hjl;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.22.08.41.10;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.16.01.08.21;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.10.11.32.52;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.17.08.47.52;	author rth;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.11.16.00.59.49;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.15.19.22.22;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.01.19.02.49;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.19.00.58.35;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.11.06.14.05.24;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	99.07.07.09.34.14;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.06.22.14.53.01;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.14.35.19;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.22.14.17.55;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.22.14.07.40;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.57.2.1
date	2011.05.12.23.50.42;	author amodra;	state Exp;
branches;
next	;

1.31.2.1
date	2003.06.03.16.26.49;	author nickc;	state Exp;
branches;
next	;

1.21.2.1
date	2002.09.23.22.14.23;	author drow;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.10.14.11.30.07;	author amodra;	state Exp;
branches;
next	;

1.12.2.1
date	2001.05.23.03.41.10;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.64
log
@oops - omitted from previous delta
@
text
@/* tc-v850.c -- Assembler code for the NEC V850
   Copyright 1996-2013 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/v850.h"
#include "dwarf2dbg.h"

/* Sign-extend a 16-bit number.  */
#define SEXT16(x)	((((x) & 0xffff) ^ (~0x7fff)) + 0x8000)

/* Temporarily holds the reloc in a cons expression.  */
static bfd_reloc_code_real_type hold_cons_reloc = BFD_RELOC_UNUSED;

/* Set to TRUE if we want to be pedantic about signed overflows.  */
static bfd_boolean warn_signed_overflows   = FALSE;
static bfd_boolean warn_unsigned_overflows = FALSE;

/* Indicates the target BFD machine number.  */
static int machine = -1;


/* Indiciates the target BFD architecture.  */
int          v850_target_arch = bfd_arch_v850_rh850;
const char * v850_target_format = "elf32-v850-rh850";
static flagword v850_e_flags = 0;

/* Indicates the target processor(s) for the assemble.  */
static int processor_mask = 0;

/* Structure to hold information about predefined registers.  */
struct reg_name
{
  const char *name;
  int value;
  unsigned int processors;
};

/* Generic assembler global variables which must be defined by all
   targets.  */

/* Characters which always start a comment.  */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = ";#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";

const relax_typeS md_relax_table[] =
{
  /* Conditional branches.(V850/V850E, max 22bit)  */
#define SUBYPTE_COND_9_22	0
  {0xfe,	 -0x100,        2, SUBYPTE_COND_9_22 + 1},
  {0x1ffffe + 2, -0x200000 + 2, 6, 0},
  /* Conditional branches.(V850/V850E, max 22bit)  */
#define SUBYPTE_SA_9_22	2
  {0xfe,         -0x100,      2, SUBYPTE_SA_9_22 + 1},
  {0x1ffffe + 4, -0x200000 + 4, 8, 0},
  /* Unconditional branches.(V850/V850E, max 22bit)  */
#define SUBYPTE_UNCOND_9_22	4
  {0xfe,     -0x100,    2, SUBYPTE_UNCOND_9_22 + 1},
  {0x1ffffe, -0x200000, 4, 0},
  /* Conditional branches.(V850E2, max 32bit)  */
#define SUBYPTE_COND_9_22_32	6
  {0xfe,     -0x100,    2, SUBYPTE_COND_9_22_32 + 1},
  {0x1fffff + 2, -0x200000 + 2, 6, SUBYPTE_COND_9_22_32 + 2},
  {0x7ffffffe, -0x80000000, 8, 0},
  /* Conditional branches.(V850E2, max 32bit)  */
#define SUBYPTE_SA_9_22_32	9
  {0xfe,     -0x100,    2, SUBYPTE_SA_9_22_32 + 1},
  {0x1ffffe + 4, -0x200000 + 4, 8, SUBYPTE_SA_9_22_32 + 2},
  {0x7ffffffe, -0x80000000, 10, 0},
  /* Unconditional branches.(V850E2, max 32bit)  */
#define SUBYPTE_UNCOND_9_22_32	12
  {0xfe,     -0x100,    2, SUBYPTE_UNCOND_9_22_32 + 1},
  {0x1ffffe, -0x200000, 4, SUBYPTE_UNCOND_9_22_32 + 2},
  {0x7ffffffe, -0x80000000, 6, 0},
  /* Conditional branches.(V850E2R max 22bit)  */
#define SUBYPTE_COND_9_17_22	15
  {0xfe,     -0x100,    2, SUBYPTE_COND_9_17_22 + 1},
  {0xfffe, -0x10000,	4, SUBYPTE_COND_9_17_22 + 2},
  {0x1ffffe + 2, -0x200000 + 2, 6, 0},
  /* Conditional branches.(V850E2R max 22bit)  */
#define SUBYPTE_SA_9_17_22	18
  {0xfe,     -0x100,    2, SUBYPTE_SA_9_17_22 + 1},
  {0xfffe, -0x10000,	4, SUBYPTE_SA_9_17_22 + 2},
  {0x1ffffe + 4, -0x200000 + 4, 8, 0},
  /* Conditional branches.(V850E2R max 32bit)  */
#define SUBYPTE_COND_9_17_22_32	21
  {0xfe,     -0x100,    2, SUBYPTE_COND_9_17_22_32 + 1},
  {0xfffe, -0x10000,	4, SUBYPTE_COND_9_17_22_32 + 2},
  {0x1ffffe + 2, -0x200000 + 2, 6, SUBYPTE_COND_9_17_22_32 + 3},
  {0x7ffffffe, -0x80000000, 8, 0},
  /* Conditional branches.(V850E2R max 32bit)  */
#define SUBYPTE_SA_9_17_22_32	25
  {0xfe,     -0x100,    2, SUBYPTE_SA_9_17_22_32 + 1},
  {0xfffe, -0x10000,	4, SUBYPTE_SA_9_17_22_32 + 2},
  {0x1ffffe + 4, -0x200000 + 4, 8, SUBYPTE_SA_9_17_22_32 + 3},
  {0x7ffffffe, -0x80000000, 10, 0},
  /* Loop.  (V850E2V4_UP, max 22-bit).  */
#define SUBYPTE_LOOP_16_22	29
  {0x0, -0x0fffe, 4, SUBYPTE_LOOP_16_22 + 1},
  {0x1ffffe + 2, -0x200000 + 2, 6, 0},
};

static int v850_relax = 0;

/* Default branch disp size 22 or 32.  */
static int default_disp_size = 22;

/* Default no using bcond17.  */
static int no_bcond17 = 0;

/* Default no using ld/st 23bit offset.  */
static int no_stld23 = 0;

/* Fixups.  */
#define MAX_INSN_FIXUPS   5

struct v850_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};

struct v850_fixup fixups[MAX_INSN_FIXUPS];
static int fc;

struct v850_seg_entry
{
  segT s;
  const char *name;
  flagword flags;
};

struct v850_seg_entry v850_seg_table[] =
{
  { NULL, ".sdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
    | SEC_SMALL_DATA },
  { NULL, ".tdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
  { NULL, ".zdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
  { NULL, ".sbss",
    SEC_ALLOC | SEC_SMALL_DATA },
  { NULL, ".tbss",
    SEC_ALLOC },
  { NULL, ".zbss",
    SEC_ALLOC},
  { NULL, ".rosdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_DATA
    | SEC_HAS_CONTENTS | SEC_SMALL_DATA },
  { NULL, ".rozdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_DATA
    | SEC_HAS_CONTENTS },
  { NULL, ".scommon",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
    | SEC_SMALL_DATA | SEC_IS_COMMON },
  { NULL, ".tcommon",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
    | SEC_IS_COMMON },
  { NULL, ".zcommon",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
    | SEC_IS_COMMON },
  { NULL, ".call_table_data",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
  { NULL, ".call_table_text",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_CODE
    | SEC_HAS_CONTENTS},
  { NULL, ".bss",
    SEC_ALLOC }
};

#define SDATA_SECTION		0
#define TDATA_SECTION		1
#define ZDATA_SECTION		2
#define SBSS_SECTION		3
#define TBSS_SECTION		4
#define ZBSS_SECTION		5
#define ROSDATA_SECTION		6
#define ROZDATA_SECTION		7
#define SCOMMON_SECTION		8
#define TCOMMON_SECTION		9
#define ZCOMMON_SECTION		10
#define CALL_TABLE_DATA_SECTION	11
#define CALL_TABLE_TEXT_SECTION	12
#define BSS_SECTION		13

static void
do_v850_seg (int i, subsegT sub)
{
  struct v850_seg_entry *seg = v850_seg_table + i;

  obj_elf_section_change_hook ();

  if (seg->s != NULL)
    subseg_set (seg->s, sub);
  else
    {
      seg->s = subseg_new (seg->name, sub);
      bfd_set_section_flags (stdoutput, seg->s, seg->flags);
      if ((seg->flags & SEC_LOAD) == 0)
	seg_info (seg->s)->bss = 1;
    }
}

static void
v850_seg (int i)
{
  subsegT sub = get_absolute_expression ();

  do_v850_seg (i, sub);
  demand_empty_rest_of_line ();
}

static void
v850_offset (int ignore ATTRIBUTE_UNUSED)
{
  char *pfrag;
  int temp = get_absolute_expression ();

  pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, (symbolS *)0,
		    (offsetT) temp, (char *) 0);
  *pfrag = 0;

  demand_empty_rest_of_line ();
}

/* Copied from obj_elf_common() in gas/config/obj-elf.c.  */

static void
v850_comm (int area)
{
  char *name;
  char c;
  char *p;
  int temp;
  unsigned int size;
  symbolS *symbolP;
  int have_align;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after symbol-name"));
      ignore_rest_of_line ();
      return;
    }

  /* Skip ','.  */
  input_line_pointer++;

  if ((temp = get_absolute_expression ()) < 0)
    {
      /* xgettext:c-format  */
      as_bad (_(".COMMon length (%d.) < 0! Ignored."), temp);
      ignore_rest_of_line ();
      return;
    }

  size = temp;
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }

  if (S_GET_VALUE (symbolP) != 0)
    {
      if (S_GET_VALUE (symbolP) != size)
	/* xgettext:c-format  */
	as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
		 S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
    }

  know (symbol_get_frag (symbolP) == &zero_address_frag);

  if (*input_line_pointer != ',')
    have_align = 0;
  else
    {
      have_align = 1;
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }

  if (! have_align || *input_line_pointer != '"')
    {
      if (! have_align)
	temp = 0;
      else
	{
	  temp = get_absolute_expression ();

	  if (temp < 0)
	    {
	      temp = 0;
	      as_warn (_("Common alignment negative; 0 assumed"));
	    }
	}

      if (symbol_get_obj (symbolP)->local)
	{
	  segT old_sec;
	  int old_subsec;
	  char *pfrag;
	  int align;
	  flagword applicable;

	  old_sec = now_seg;
	  old_subsec = now_subseg;

	  applicable = bfd_applicable_section_flags (stdoutput);

	  applicable &= SEC_ALLOC;

	  switch (area)
	    {
	    case SCOMMON_SECTION:
	      do_v850_seg (SBSS_SECTION, 0);
	      break;

	    case ZCOMMON_SECTION:
	      do_v850_seg (ZBSS_SECTION, 0);
	      break;

	    case TCOMMON_SECTION:
	      do_v850_seg (TBSS_SECTION, 0);
	      break;
	    }

	  if (temp)
	    {
	      /* Convert to a power of 2 alignment.  */
	      for (align = 0; (temp & 1) == 0; temp >>= 1, ++align)
		;

	      if (temp != 1)
		{
		  as_bad (_("Common alignment not a power of 2"));
		  ignore_rest_of_line ();
		  return;
		}
	    }
	  else
	    align = 0;

	  record_alignment (now_seg, align);

	  if (align)
	    frag_align (align, 0, 0);

	  switch (area)
	    {
	    case SCOMMON_SECTION:
	      if (S_GET_SEGMENT (symbolP) == v850_seg_table[SBSS_SECTION].s)
		symbol_get_frag (symbolP)->fr_symbol = 0;
	      break;

	    case ZCOMMON_SECTION:
	      if (S_GET_SEGMENT (symbolP) == v850_seg_table[ZBSS_SECTION].s)
		symbol_get_frag (symbolP)->fr_symbol = 0;
	      break;

	    case TCOMMON_SECTION:
	      if (S_GET_SEGMENT (symbolP) == v850_seg_table[TBSS_SECTION].s)
		symbol_get_frag (symbolP)->fr_symbol = 0;
	      break;

	    default:
	      abort ();
	    }

	  symbol_set_frag (symbolP, frag_now);
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			    (offsetT) size, (char *) 0);
	  *pfrag = 0;
	  S_SET_SIZE (symbolP, size);

	  switch (area)
	    {
	    case SCOMMON_SECTION:
	      S_SET_SEGMENT (symbolP, v850_seg_table[SBSS_SECTION].s);
	      break;

	    case ZCOMMON_SECTION:
	      S_SET_SEGMENT (symbolP, v850_seg_table[ZBSS_SECTION].s);
	      break;

	    case TCOMMON_SECTION:
	      S_SET_SEGMENT (symbolP, v850_seg_table[TBSS_SECTION].s);
	      break;

	    default:
	      abort ();
	    }

	  S_CLEAR_EXTERNAL (symbolP);
	  obj_elf_section_change_hook ();
	  subseg_set (old_sec, old_subsec);
	}
      else
	{
	  segT   old_sec;
	  int    old_subsec;

	allocate_common:
	  old_sec = now_seg;
	  old_subsec = now_subseg;

	  S_SET_VALUE (symbolP, (valueT) size);
	  S_SET_ALIGN (symbolP, temp);
	  S_SET_EXTERNAL (symbolP);

	  switch (area)
	    {
	    case SCOMMON_SECTION:
	    case ZCOMMON_SECTION:
	    case TCOMMON_SECTION:
	      do_v850_seg (area, 0);
	      S_SET_SEGMENT (symbolP, v850_seg_table[area].s);
	      break;

	    default:
	      abort ();
	    }

	  obj_elf_section_change_hook ();
	  subseg_set (old_sec, old_subsec);
	}
    }
  else
    {
      input_line_pointer++;

      /* @@@@ Some use the dot, some don't.  Can we get some consistency??  */
      if (*input_line_pointer == '.')
	input_line_pointer++;

      /* @@@@ Some say data, some say bss.  */
      if (strncmp (input_line_pointer, "bss\"", 4)
	  && strncmp (input_line_pointer, "data\"", 5))
	{
	  while (*--input_line_pointer != '"')
	    ;
	  input_line_pointer--;
	  goto bad_common_segment;
	}

      while (*input_line_pointer++ != '"')
	;

      goto allocate_common;
    }

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  demand_empty_rest_of_line ();
  return;

  {
  bad_common_segment:
    p = input_line_pointer;
    while (*p && *p != '\n')
      p++;
    c = *p;
    *p = '\0';
    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
    *p = c;
    input_line_pointer = p;
    ignore_rest_of_line ();
    return;
  }
}

static void
set_machine (int number)
{
  machine = number;
  bfd_set_arch_mach (stdoutput, v850_target_arch, machine);

  switch (machine)
    {
    case 0:                SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850);    break;
    case bfd_mach_v850:    SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850);    break;
    case bfd_mach_v850e:   SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E);   break;
    case bfd_mach_v850e1:  SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E);   break;
    case bfd_mach_v850e2:  SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E2);  break;
    case bfd_mach_v850e2v3:SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E2V3); break;
    case bfd_mach_v850e3v5: SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E3V5); break;
    }
}

static void
v850_longcode (int type)
{
  expressionS ex;

  if (! v850_relax)
    {
      if (type == 1)
	as_warn (_(".longcall pseudo-op seen when not relaxing"));
      else
	as_warn (_(".longjump pseudo-op seen when not relaxing"));
    }

  expression (&ex);

  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad (_("bad .longcall format"));
      ignore_rest_of_line ();

      return;
    }

  if (type == 1)
    fix_new_exp (frag_now, frag_now_fix (), 4, & ex, 1,
		 BFD_RELOC_V850_LONGCALL);
  else
    fix_new_exp (frag_now, frag_now_fix (), 4, & ex, 1,
		 BFD_RELOC_V850_LONGJUMP);

  demand_empty_rest_of_line ();
}

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "sdata",		v850_seg,		SDATA_SECTION		},
  { "tdata",		v850_seg,		TDATA_SECTION		},
  { "zdata",		v850_seg,		ZDATA_SECTION		},
  { "sbss",		v850_seg,		SBSS_SECTION		},
  { "tbss",		v850_seg,		TBSS_SECTION		},
  { "zbss",		v850_seg,		ZBSS_SECTION		},
  { "rosdata",		v850_seg,		ROSDATA_SECTION 	},
  { "rozdata",		v850_seg,		ROZDATA_SECTION 	},
  { "bss",		v850_seg,		BSS_SECTION		},
  { "offset",		v850_offset,		0			},
  { "word",		cons,			4			},
  { "zcomm",		v850_comm,		ZCOMMON_SECTION 	},
  { "scomm",		v850_comm,		SCOMMON_SECTION 	},
  { "tcomm",		v850_comm,		TCOMMON_SECTION 	},
  { "v850",		set_machine,		0			},
  { "call_table_data",	v850_seg,		CALL_TABLE_DATA_SECTION	},
  { "call_table_text",	v850_seg,		CALL_TABLE_TEXT_SECTION	},
  { "v850e",		set_machine,		bfd_mach_v850e		},
  { "v850e1",		set_machine,		bfd_mach_v850e1         },
  { "v850e2",		set_machine,		bfd_mach_v850e2 	},
  { "v850e2v3",		set_machine,		bfd_mach_v850e2v3 	},
  { "v850e2v4",		set_machine,		bfd_mach_v850e3v5 	},
  { "v850e3v5",		set_machine,		bfd_mach_v850e3v5 	},
  { "longcall",		v850_longcode,		1			},
  { "longjump",		v850_longcode,		2			},
  { NULL,		NULL,			0			}
};

/* Opcode hash table.  */
static struct hash_control *v850_hash;

/* This table is sorted.  Suitable for searching by a binary search.  */
static const struct reg_name pre_defined_registers[] =
{
  { "ep",  30, PROCESSOR_ALL },		/* ep - element ptr.  */
  { "gp",   4, PROCESSOR_ALL },		/* gp - global ptr.  */
  { "hp",   2, PROCESSOR_ALL },		/* hp - handler stack ptr.  */
  { "lp",  31, PROCESSOR_ALL },		/* lp - link ptr.  */
  { "r0",   0, PROCESSOR_ALL },
  { "r1",   1, PROCESSOR_ALL },
  { "r10", 10, PROCESSOR_ALL },
  { "r11", 11, PROCESSOR_ALL },
  { "r12", 12, PROCESSOR_ALL },
  { "r13", 13, PROCESSOR_ALL },
  { "r14", 14, PROCESSOR_ALL },
  { "r15", 15, PROCESSOR_ALL },
  { "r16", 16, PROCESSOR_ALL },
  { "r17", 17, PROCESSOR_ALL },
  { "r18", 18, PROCESSOR_ALL },
  { "r19", 19, PROCESSOR_ALL },
  { "r2",   2, PROCESSOR_ALL },
  { "r20", 20, PROCESSOR_ALL },
  { "r21", 21, PROCESSOR_ALL },
  { "r22", 22, PROCESSOR_ALL },
  { "r23", 23, PROCESSOR_ALL },
  { "r24", 24, PROCESSOR_ALL },
  { "r25", 25, PROCESSOR_ALL },
  { "r26", 26, PROCESSOR_ALL },
  { "r27", 27, PROCESSOR_ALL },
  { "r28", 28, PROCESSOR_ALL },
  { "r29", 29, PROCESSOR_ALL },
  { "r3",   3, PROCESSOR_ALL },
  { "r30", 30, PROCESSOR_ALL },
  { "r31", 31, PROCESSOR_ALL },
  { "r4",   4, PROCESSOR_ALL },
  { "r5",   5, PROCESSOR_ALL },
  { "r6",   6, PROCESSOR_ALL },
  { "r7",   7, PROCESSOR_ALL },
  { "r8",   8, PROCESSOR_ALL },
  { "r9",   9, PROCESSOR_ALL },
  { "sp",   3, PROCESSOR_ALL },		/* sp - stack ptr.  */
  { "tp",   5, PROCESSOR_ALL },		/* tp - text ptr.  */
  { "zero", 0, PROCESSOR_ALL },
};

#define REG_NAME_CNT						\
  (sizeof (pre_defined_registers) / sizeof (struct reg_name))

static const struct reg_name system_registers[] =
{
  { "asid",        23, PROCESSOR_NOT_V850 },
  { "bpam",        25, PROCESSOR_NOT_V850 },
  { "bpav",        24, PROCESSOR_NOT_V850 },
  { "bpc",         22, PROCESSOR_NOT_V850 },
  { "bpdm",        27, PROCESSOR_NOT_V850 },
  { "bpdv",        26, PROCESSOR_NOT_V850 },
  { "bsel",        31, PROCESSOR_V850E2_UP },
  { "cfg",          7, PROCESSOR_V850E2V3_UP },
  { "ctbp",        20, PROCESSOR_NOT_V850 },
  { "ctpc",        16, PROCESSOR_NOT_V850 },
  { "ctpsw",       17, PROCESSOR_NOT_V850 },
  { "dbic",        15, PROCESSOR_V850E2_UP },
  { "dbpc",        18, PROCESSOR_NOT_V850 },
  { "dbpsw",       19, PROCESSOR_NOT_V850 },
  { "dbwr",        30, PROCESSOR_V850E2_UP },
  { "dir",         21, PROCESSOR_NOT_V850 },
  { "dpa0l",       16, PROCESSOR_V850E2V3_UP },
  { "dpa0u",       17, PROCESSOR_V850E2V3_UP },
  { "dpa1l",       18, PROCESSOR_V850E2V3_UP },
  { "dpa1u",       19, PROCESSOR_V850E2V3_UP },
  { "dpa2l",       20, PROCESSOR_V850E2V3_UP },
  { "dpa2u",       21, PROCESSOR_V850E2V3_UP },
  { "dpa3l",       22, PROCESSOR_V850E2V3_UP },
  { "dpa3u",       23, PROCESSOR_V850E2V3_UP },
  { "dpa4l",       24, PROCESSOR_V850E2V3_UP },
  { "dpa4u",       25, PROCESSOR_V850E2V3_UP },
  { "dpa5l",       26, PROCESSOR_V850E2V3_UP },
  { "dpa5u",       27, PROCESSOR_V850E2V3_UP },
  { "ecr",          4, PROCESSOR_ALL },
  { "eh_base",      3, PROCESSOR_V850E2V3_UP },
  { "eh_cfg",       1, PROCESSOR_V850E2V3_UP },
  { "eh_reset",     2, PROCESSOR_V850E2V3_UP },
  { "eiic",        13, PROCESSOR_V850E2_UP },
  { "eipc",         0, PROCESSOR_ALL },
  { "eipsw",        1, PROCESSOR_ALL },
  { "eiwr",        28, PROCESSOR_V850E2_UP },
  { "feic",        14, PROCESSOR_V850E2_UP },
  { "fepc",         2, PROCESSOR_ALL },
  { "fepsw",        3, PROCESSOR_ALL },
  { "fewr",        29, PROCESSOR_V850E2_UP },
  { "fpcc",         9, PROCESSOR_V850E2V3_UP },
  { "fpcfg",       10, PROCESSOR_V850E2V3_UP },
  { "fpec",        11, PROCESSOR_V850E2V3_UP },
  { "fpepc",        7, PROCESSOR_V850E2V3_UP },
  { "fpspc",       27, PROCESSOR_V850E2V3_UP },
  { "fpsr",         6, PROCESSOR_V850E2V3_UP },
  { "fpst",         8, PROCESSOR_V850E2V3_UP },
  { "ipa0l",        6, PROCESSOR_V850E2V3_UP },
  { "ipa0u",        7, PROCESSOR_V850E2V3_UP },
  { "ipa1l",        8, PROCESSOR_V850E2V3_UP },
  { "ipa1u",        9, PROCESSOR_V850E2V3_UP },
  { "ipa2l",       10, PROCESSOR_V850E2V3_UP },
  { "ipa2u",       11, PROCESSOR_V850E2V3_UP },
  { "ipa3l",       12, PROCESSOR_V850E2V3_UP },
  { "ipa3u",       13, PROCESSOR_V850E2V3_UP },
  { "ipa4l",       14, PROCESSOR_V850E2V3_UP },
  { "ipa4u",       15, PROCESSOR_V850E2V3_UP },
  { "mca",         24, PROCESSOR_V850E2V3_UP },
  { "mcc",         26, PROCESSOR_V850E2V3_UP },
  { "mcr",         27, PROCESSOR_V850E2V3_UP },
  { "mcs",         25, PROCESSOR_V850E2V3_UP },
  { "mpc",          1, PROCESSOR_V850E2V3_UP },
  { "mpm",          0, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa0l", 16, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa0u", 17, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa1l", 18, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa1u", 19, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa2l", 20, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa2u", 21, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa3l", 22, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa3u", 23, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa4l", 24, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa4u", 25, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa5l", 26, PROCESSOR_V850E2V3_UP },
  { "mpu10_dpa5u", 27, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa0l",  6, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa0u",  7, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa1l",  8, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa1u",  9, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa2l", 10, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa2u", 11, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa3l", 12, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa3u", 13, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa4l", 14, PROCESSOR_V850E2V3_UP },
  { "mpu10_ipa4u", 15, PROCESSOR_V850E2V3_UP },
  { "mpu10_mpc",    1, PROCESSOR_V850E2V3_UP },
  { "mpu10_mpm",    0, PROCESSOR_V850E2V3_UP },
  { "mpu10_tid",    2, PROCESSOR_V850E2V3_UP },
  { "mpu10_vmadr",  5, PROCESSOR_V850E2V3_UP },
  { "mpu10_vmecr",  3, PROCESSOR_V850E2V3_UP },
  { "mpu10_vmtid",  4, PROCESSOR_V850E2V3_UP },
  { "pid",          6, PROCESSOR_V850E2V3_UP },
  { "pmcr0",        4, PROCESSOR_V850E2V3_UP },
  { "pmis2",       14, PROCESSOR_V850E2V3_UP },
  { "psw",          5, PROCESSOR_ALL },
  { "scbp",        12, PROCESSOR_V850E2V3_UP },
  { "sccfg",       11, PROCESSOR_V850E2V3_UP },
  { "sr0",          0, PROCESSOR_ALL },
  { "sr1",          1, PROCESSOR_ALL },
  { "sr10",        10, PROCESSOR_ALL },
  { "sr11",        11, PROCESSOR_ALL },
  { "sr12",        12, PROCESSOR_ALL },
  { "sr13",        13, PROCESSOR_ALL },
  { "sr14",        14, PROCESSOR_ALL },
  { "sr15",        15, PROCESSOR_ALL },
  { "sr16",        16, PROCESSOR_ALL },
  { "sr17",        17, PROCESSOR_ALL },
  { "sr18",        18, PROCESSOR_ALL },
  { "sr19",        19, PROCESSOR_ALL },
  { "sr2",          2, PROCESSOR_ALL },
  { "sr20",        20, PROCESSOR_ALL },
  { "sr21",        21, PROCESSOR_ALL },
  { "sr22",        22, PROCESSOR_ALL },
  { "sr23",        23, PROCESSOR_ALL },
  { "sr24",        24, PROCESSOR_ALL },
  { "sr25",        25, PROCESSOR_ALL },
  { "sr26",        26, PROCESSOR_ALL },
  { "sr27",        27, PROCESSOR_ALL },
  { "sr28",        28, PROCESSOR_ALL },
  { "sr29",        29, PROCESSOR_ALL },
  { "sr3",          3, PROCESSOR_ALL },
  { "sr30",        30, PROCESSOR_ALL },
  { "sr31",        31, PROCESSOR_ALL },
  { "sr4",          4, PROCESSOR_ALL },
  { "sr5",          5, PROCESSOR_ALL },
  { "sr6",          6, PROCESSOR_ALL },
  { "sr7",          7, PROCESSOR_ALL },
  { "sr8",          8, PROCESSOR_ALL },
  { "sr9",          9, PROCESSOR_ALL },
  { "sw_base",      3, PROCESSOR_V850E2V3_UP },
  { "sw_cfg",       1, PROCESSOR_V850E2V3_UP },
  { "sw_ctl",       0, PROCESSOR_V850E2V3_UP },
  { "tid",          2, PROCESSOR_V850E2V3_UP },
  { "vmadr",        6, PROCESSOR_V850E2V3_UP },
  { "vmecr",        4, PROCESSOR_V850E2V3_UP },
  { "vmtid",        5, PROCESSOR_V850E2V3_UP },
  { "vsadr",        2, PROCESSOR_V850E2V3_UP },
  { "vsecr",        0, PROCESSOR_V850E2V3_UP },
  { "vstid",        1, PROCESSOR_V850E2V3_UP },
};

#define SYSREG_NAME_CNT						\
  (sizeof (system_registers) / sizeof (struct reg_name))


static const struct reg_name cc_names[] =
{
  { "c",  0x1, PROCESSOR_ALL },
  { "e",  0x2, PROCESSOR_ALL },
  { "ge", 0xe, PROCESSOR_ALL },
  { "gt", 0xf, PROCESSOR_ALL },
  { "h",  0xb, PROCESSOR_ALL },
  { "l",  0x1, PROCESSOR_ALL },
  { "le", 0x7, PROCESSOR_ALL },
  { "lt", 0x6, PROCESSOR_ALL },
  { "n",  0x4, PROCESSOR_ALL },
  { "nc", 0x9, PROCESSOR_ALL },
  { "ne", 0xa, PROCESSOR_ALL },
  { "nh", 0x3, PROCESSOR_ALL },
  { "nl", 0x9, PROCESSOR_ALL },
  { "ns", 0xc, PROCESSOR_ALL },
  { "nv", 0x8, PROCESSOR_ALL },
  { "nz", 0xa, PROCESSOR_ALL },
  { "p",  0xc, PROCESSOR_ALL },
  { "s",  0x4, PROCESSOR_ALL },
#define COND_SA_NUM 0xd
  { "sa", COND_SA_NUM, PROCESSOR_ALL },
  { "t",  0x5, PROCESSOR_ALL },
  { "v",  0x0, PROCESSOR_ALL },
  { "z",  0x2, PROCESSOR_ALL },
};

#define CC_NAME_CNT					\
  (sizeof (cc_names) / sizeof (struct reg_name))

static const struct reg_name float_cc_names[] =
{
  { "eq",  0x2, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "f",   0x0, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "ge",  0xd, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "gl",  0xb, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "gle", 0x9, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "gt",  0xf, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "le",  0xe, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "lt",  0xc, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "neq", 0x2, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "nge", 0xd, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "ngl", 0xb, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "ngle",0x9, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "ngt", 0xf, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "nle", 0xe, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "nlt", 0xc, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "oge", 0x5, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "ogl", 0x3, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "ogt", 0x7, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "ole", 0x6, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "olt", 0x4, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "or",  0x1, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "seq", 0xa, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "sf",  0x8, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "sne", 0xa, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "st",  0x8, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "t",   0x0, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "ueq", 0x3, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "uge", 0x4, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "ugt", 0x6, PROCESSOR_V850E2V3_UP },	/* false.  */
  { "ule", 0x7, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "ult", 0x5, PROCESSOR_V850E2V3_UP },	/* true.  */
  { "un",  0x1, PROCESSOR_V850E2V3_UP },	/* true.  */
};

#define FLOAT_CC_NAME_CNT					\
  (sizeof (float_cc_names) / sizeof (struct reg_name))


static const struct reg_name cacheop_names[] =
{
  { "cfald",   0x44, PROCESSOR_V850E3V5_UP },
  { "cfali",   0x40, PROCESSOR_V850E3V5_UP },
  { "chbid",   0x04, PROCESSOR_V850E3V5_UP },
  { "chbii",   0x00, PROCESSOR_V850E3V5_UP },
  { "chbiwbd", 0x06, PROCESSOR_V850E3V5_UP },
  { "chbwbd",  0x07, PROCESSOR_V850E3V5_UP },
  { "cibid",   0x24, PROCESSOR_V850E3V5_UP },
  { "cibii",   0x20, PROCESSOR_V850E3V5_UP },
  { "cibiwbd", 0x26, PROCESSOR_V850E3V5_UP },
  { "cibwbd",  0x27, PROCESSOR_V850E3V5_UP },
  { "cildd",   0x65, PROCESSOR_V850E3V5_UP },
  { "cildi",   0x61, PROCESSOR_V850E3V5_UP },
  { "cistd",   0x64, PROCESSOR_V850E3V5_UP },
  { "cisti",   0x60, PROCESSOR_V850E3V5_UP },
};

#define CACHEOP_NAME_CNT					\
  (sizeof (cacheop_names) / sizeof (struct reg_name))

static const struct reg_name prefop_names[] =
{
  { "prefd",   0x04, PROCESSOR_V850E3V5_UP },
  { "prefi",   0x00, PROCESSOR_V850E3V5_UP },
};

#define PREFOP_NAME_CNT					\
  (sizeof (prefop_names) / sizeof (struct reg_name))

static const struct reg_name vector_registers[] =
{
  { "vr0",   0, PROCESSOR_V850E3V5_UP },
  { "vr1",   1, PROCESSOR_V850E3V5_UP },
  { "vr10", 10, PROCESSOR_V850E3V5_UP },
  { "vr11", 11, PROCESSOR_V850E3V5_UP },
  { "vr12", 12, PROCESSOR_V850E3V5_UP },
  { "vr13", 13, PROCESSOR_V850E3V5_UP },
  { "vr14", 14, PROCESSOR_V850E3V5_UP },
  { "vr15", 15, PROCESSOR_V850E3V5_UP },
  { "vr16", 16, PROCESSOR_V850E3V5_UP },
  { "vr17", 17, PROCESSOR_V850E3V5_UP },
  { "vr18", 18, PROCESSOR_V850E3V5_UP },
  { "vr19", 19, PROCESSOR_V850E3V5_UP },
  { "vr2",   2, PROCESSOR_V850E3V5_UP },
  { "vr20", 20, PROCESSOR_V850E3V5_UP },
  { "vr21", 21, PROCESSOR_V850E3V5_UP },
  { "vr22", 22, PROCESSOR_V850E3V5_UP },
  { "vr23", 23, PROCESSOR_V850E3V5_UP },
  { "vr24", 24, PROCESSOR_V850E3V5_UP },
  { "vr25", 25, PROCESSOR_V850E3V5_UP },
  { "vr26", 26, PROCESSOR_V850E3V5_UP },
  { "vr27", 27, PROCESSOR_V850E3V5_UP },
  { "vr28", 28, PROCESSOR_V850E3V5_UP },
  { "vr29", 29, PROCESSOR_V850E3V5_UP },
  { "vr3",   3, PROCESSOR_V850E3V5_UP },
  { "vr30", 30, PROCESSOR_V850E3V5_UP },
  { "vr31", 31, PROCESSOR_V850E3V5_UP },
  { "vr4",   4, PROCESSOR_V850E3V5_UP },
  { "vr5",   5, PROCESSOR_V850E3V5_UP },
  { "vr6",   6, PROCESSOR_V850E3V5_UP },
  { "vr7",   7, PROCESSOR_V850E3V5_UP },
  { "vr8",   8, PROCESSOR_V850E3V5_UP },
  { "vr9",   9, PROCESSOR_V850E3V5_UP },
};

#define VREG_NAME_CNT						\
  (sizeof (vector_registers) / sizeof (struct reg_name))

/* Do a binary search of the given register table to see if NAME is a
   valid regiter name.  Return the register number from the array on
   success, or -1 on failure.  */

static int
reg_name_search (const struct reg_name *regs,
		 int regcount,
		 const char *name,
		 bfd_boolean accept_numbers)
{
  int middle, low, high;
  int cmp;
  symbolS *symbolP;

  /* If the register name is a symbol, then evaluate it.  */
  if ((symbolP = symbol_find (name)) != NULL)
    {
      /* If the symbol is an alias for another name then use that.
	 If the symbol is an alias for a number, then return the number.  */
      if (symbol_equated_p (symbolP))
	name
	  = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
      else if (accept_numbers)
	{
	  int reg = S_GET_VALUE (symbolP);
	  return reg;
	}

      /* Otherwise drop through and try parsing name normally.  */
    }

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return ((regs[middle].processors & processor_mask)
		? regs[middle].value
		: -1);
    }
  while (low <= high);
  return -1;
}

/* Summary of register_name().

   in: Input_line_pointer points to 1st char of operand.

   out: An expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

static bfd_boolean
register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();

  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT,
				name, FALSE);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  expressionP->X_add_symbol = NULL;
  expressionP->X_op_symbol  = NULL;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op		= O_register;
      expressionP->X_add_number = reg_number;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;

  expressionP->X_op = O_illegal;

  return FALSE;
}

/* Summary of system_register_name().

   in:  INPUT_LINE_POINTER points to 1st char of operand.
	EXPRESSIONP points to an expression structure to be filled in.
	ACCEPT_NUMBERS is true iff numerical register names may be used.

   out: An expressionS structure in expressionP.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

static bfd_boolean
system_register_name (expressionS *expressionP,
		      bfd_boolean accept_numbers)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
				accept_numbers);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  if (reg_number < 0
      && accept_numbers)
    {
      /* Reset input_line pointer.  */
      input_line_pointer = start;

      if (ISDIGIT (*input_line_pointer))
	{
	  reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
	}
    }

  expressionP->X_add_symbol = NULL;
  expressionP->X_op_symbol  = NULL;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op		= O_register;
      expressionP->X_add_number = reg_number;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;

  expressionP->X_op = O_illegal;

  return FALSE;
}

/* Summary of cc_name().

   in: INPUT_LINE_POINTER points to 1st char of operand.

   out: An expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

static bfd_boolean
cc_name (expressionS *expressionP,
	 bfd_boolean accept_numbers)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (cc_names, CC_NAME_CNT, name, accept_numbers);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  if (reg_number < 0
      && accept_numbers)
    {
      /* Reset input_line pointer.  */
      input_line_pointer = start;

      if (ISDIGIT (*input_line_pointer))
	{
	  reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
	}
    }

  expressionP->X_add_symbol = NULL;
  expressionP->X_op_symbol  = NULL;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op		= O_constant;
      expressionP->X_add_number = reg_number;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;

  expressionP->X_op = O_illegal;
  expressionP->X_add_number = 0;

  return FALSE;
}

static bfd_boolean
float_cc_name (expressionS *expressionP,
	       bfd_boolean accept_numbers)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (float_cc_names, FLOAT_CC_NAME_CNT, name, accept_numbers);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  if (reg_number < 0
      && accept_numbers)
    {
      /* Reset input_line pointer.  */
      input_line_pointer = start;

      if (ISDIGIT (*input_line_pointer))
	{
	  reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
	}
    }

  expressionP->X_add_symbol = NULL;
  expressionP->X_op_symbol  = NULL;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op		= O_constant;
      expressionP->X_add_number = reg_number;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;

  expressionP->X_op = O_illegal;
  expressionP->X_add_number = 0;

  return FALSE;
}

static bfd_boolean
cacheop_name (expressionS * expressionP,
	      bfd_boolean accept_numbers)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (cacheop_names, CACHEOP_NAME_CNT, name, accept_numbers);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  if (reg_number < 0
      && accept_numbers)
    {
      /* Reset input_line pointer.  */
      input_line_pointer = start;

      if (ISDIGIT (*input_line_pointer))
	reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
    }

  expressionP->X_add_symbol = NULL;
  expressionP->X_op_symbol  = NULL;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op		= O_constant;
      expressionP->X_add_number = reg_number;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;

  expressionP->X_op = O_illegal;
  expressionP->X_add_number = 0;

  return FALSE;
}

static bfd_boolean
prefop_name (expressionS * expressionP,
	     bfd_boolean accept_numbers)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (prefop_names, PREFOP_NAME_CNT, name, accept_numbers);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  if (reg_number < 0
      && accept_numbers)
    {
      /* Reset input_line pointer.  */
      input_line_pointer = start;

      if (ISDIGIT (*input_line_pointer))
	reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
    }

  expressionP->X_add_symbol = NULL;
  expressionP->X_op_symbol  = NULL;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op		= O_constant;
      expressionP->X_add_number = reg_number;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;

  expressionP->X_op = O_illegal;
  expressionP->X_add_number = 0;

  return FALSE;
}

static bfd_boolean
vector_register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();

  reg_number = reg_name_search (vector_registers, VREG_NAME_CNT,
				name, FALSE);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  expressionP->X_add_symbol = NULL;
  expressionP->X_op_symbol  = NULL;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op		= O_register;
      expressionP->X_add_number = reg_number;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;

  expressionP->X_op = O_illegal;

  return FALSE;
}

static void
skip_white_space (void)
{
  while (*input_line_pointer == ' '
	 || *input_line_pointer == '\t')
    ++input_line_pointer;
}

/* Summary of parse_register_list ().

   in: INPUT_LINE_POINTER  points to 1st char of a list of registers.
       INSN		   is the partially constructed instruction.
       OPERAND		   is the operand being inserted.

   out: NULL if the parse completed successfully, otherwise a
	pointer to an error message is returned.  If the parse
	completes the correct bit fields in the instruction
	will be filled in.

   Parses register lists with the syntax:

     { rX }
     { rX, rY }
     { rX - rY }
     { rX - rY, rZ }
     etc

   and also parses constant expressions whoes bits indicate the
   registers in the lists.  The LSB in the expression refers to
   the lowest numbered permissible register in the register list,
   and so on upwards.  System registers are considered to be very
   high numbers.  */

static char *
parse_register_list (unsigned long *insn,
		     const struct v850_operand *operand)
{
  static int type1_regs[32] =
  {
    30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24
  };

  int *regs;
  expressionS exp;

  /* Select a register array to parse.  */
  switch (operand->shift)
    {
    case 0xffe00001: regs = type1_regs; break;
    default:
      as_bad (_("unknown operand shift: %x\n"), operand->shift);
      return _("internal failure in parse_register_list");
    }

  skip_white_space ();

  /* If the expression starts with a curly brace it is a register list.
     Otherwise it is a constant expression, whoes bits indicate which
     registers are to be included in the list.  */
  if (*input_line_pointer != '{')
    {
      int reg;
      int i;

      expression (&exp);

      if (exp.X_op != O_constant)
	return _("constant expression or register list expected");

      if (regs == type1_regs)
	{
	  if (exp.X_add_number & 0xFFFFF000)
	    return _("high bits set in register list expression");

	  for (reg = 20; reg < 32; reg++)
	    if (exp.X_add_number & (1 << (reg - 20)))
	      {
		for (i = 0; i < 32; i++)
		  if (regs[i] == reg)
		    *insn |= (1 << i);
	      }
	}

      return NULL;
    }

  input_line_pointer++;

  /* Parse the register list until a terminator (closing curly brace or
     new-line) is found.  */
  for (;;)
    {
      skip_white_space ();

      if (register_name (&exp))
	{
	  int i;

	  /* Locate the given register in the list, and if it is there,
	     insert the corresponding bit into the instruction.  */
	  for (i = 0; i < 32; i++)
	    {
	      if (regs[i] == exp.X_add_number)
		{
		  *insn |= (1 << i);
		  break;
		}
	    }

	  if (i == 32)
	    return _("illegal register included in list");
	}
      else if (system_register_name (&exp, TRUE))
	{
	  if (regs == type1_regs)
	    {
	      return _("system registers cannot be included in list");
	    }
	}

      if (*input_line_pointer == '}')
	{
	  input_line_pointer++;
	  break;
	}
      else if (*input_line_pointer == ',')
	{
	  input_line_pointer++;
	  continue;
	}
      else if (*input_line_pointer == '-')
	{
	  /* We have encountered a range of registers: rX - rY.  */
	  int j;
	  expressionS exp2;

	  /* Skip the dash.  */
	  ++input_line_pointer;

	  /* Get the second register in the range.  */
	  if (! register_name (&exp2))
	    {
	      return _("second register should follow dash in register list");
	    }

	  if (exp.X_add_number > exp2.X_add_number)
	    {
	      return _("second register should be greater than first register");
	    }

	  /* Add the rest of the registers in the range.  */
	  for (j = exp.X_add_number + 1; j <= exp2.X_add_number; j++)
	    {
	      int i;

	      /* Locate the given register in the list, and if it is there,
		 insert the corresponding bit into the instruction.  */
	      for (i = 0; i < 32; i++)
		{
		  if (regs[i] == j)
		    {
		      *insn |= (1 << i);
		      break;
		    }
		}

	      if (i == 32)
		return _("illegal register included in list");
	    }

	  exp = exp2;
	}
      else
	break;
    }

  return NULL;
}

const char *md_shortopts = "m:";

struct option md_longopts[] =
{
#define OPTION_DISP_SIZE_DEFAULT_22 (OPTION_MD_BASE)
  {"disp-size-default-22", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_22},
#define OPTION_DISP_SIZE_DEFAULT_32 (OPTION_MD_BASE + 1)
  {"disp-size-default-32", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_32},
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _(" V850 options:\n"));
  fprintf (stream, _("  -mwarn-signed-overflow    Warn if signed immediate values overflow\n"));
  fprintf (stream, _("  -mwarn-unsigned-overflow  Warn if unsigned immediate values overflow\n"));
  fprintf (stream, _("  -mv850                    The code is targeted at the v850\n"));
  fprintf (stream, _("  -mv850e                   The code is targeted at the v850e\n"));
  fprintf (stream, _("  -mv850e1                  The code is targeted at the v850e1\n"));
  fprintf (stream, _("  -mv850e2                  The code is targeted at the v850e2\n"));
  fprintf (stream, _("  -mv850e2v3                The code is targeted at the v850e2v3\n"));
  fprintf (stream, _("  -mv850e2v4                Alias for -mv850e3v5\n"));
  fprintf (stream, _("  -mv850e3v5                The code is targeted at the v850e3v5\n"));
  fprintf (stream, _("  -mrelax                   Enable relaxation\n"));
  fprintf (stream, _("  --disp-size-default-22    branch displacement with unknown size is 22 bits (default)\n"));
  fprintf (stream, _("  --disp-size-default-32    branch displacement with unknown size is 32 bits\n"));
  fprintf (stream, _("  -mextension               enable extension opcode support\n"));
  fprintf (stream, _("  -mno-bcond17		  disable b<cond> disp17 instruction\n"));
  fprintf (stream, _("  -mno-stld23		  disable st/ld offset23 instruction\n"));
  fprintf (stream, _("  -mgcc-abi                 Mark the binary as using the old GCC ABI\n"));
  fprintf (stream, _("  -mrh850-abi               Mark the binary as using the RH850 ABI (default)\n"));
  fprintf (stream, _("  -m8byte-align             Mark the binary as using 64-bit alignment\n"));
  fprintf (stream, _("  -m4byte-align             Mark the binary as using 32-bit alignment (default)\n"));
}

int
md_parse_option (int c, char *arg)
{
  if (c != 'm')
    {
      switch (c)
        {
        case OPTION_DISP_SIZE_DEFAULT_22:
          default_disp_size = 22;
          return 1;

        case OPTION_DISP_SIZE_DEFAULT_32:
          default_disp_size = 32;
          return 1;
        }
      return 0;
    }

  if (strcmp (arg, "warn-signed-overflow") == 0)
    warn_signed_overflows = TRUE;

  else if (strcmp (arg, "warn-unsigned-overflow") == 0)
    warn_unsigned_overflows = TRUE;

  else if (strcmp (arg, "v850") == 0)
    {
      machine = 0;
      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850);
    }
  else if (strcmp (arg, "v850e") == 0)
    {
      machine = bfd_mach_v850e;
      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E);
    }
  else if (strcmp (arg, "v850e1") == 0)
    {
      machine = bfd_mach_v850e1;
      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E1);
    }
  else if (strcmp (arg, "v850e2") == 0)
    {
      machine = bfd_mach_v850e2;
      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E2);
    }
  else if (strcmp (arg, "v850e2v3") == 0)
    {
      machine = bfd_mach_v850e2v3;
      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E2V3);
    }
  else if (strcmp (arg, "v850e2v4") == 0)
    {
      machine = bfd_mach_v850e3v5;
      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E3V5);
    }
  else if (strcmp (arg, "v850e3v5") == 0)
    {
      machine = bfd_mach_v850e3v5;
      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E3V5);
    }
  else if (strcmp (arg, "extension") == 0)
    {
      processor_mask |= PROCESSOR_OPTION_EXTENSION | PROCESSOR_OPTION_ALIAS;
    }
  else if (strcmp (arg, "no-bcond17") == 0)
    {
      no_bcond17 = 1;
    }
  else if (strcmp (arg, "no-stld23") == 0)
    {
      no_stld23 = 1;
    }
  else if (strcmp (arg, "relax") == 0)
    v850_relax = 1;
  else if (strcmp (arg, "gcc-abi") == 0)
    {
      v850_target_arch = bfd_arch_v850;
      v850_target_format = "elf32-v850";
    }
  else if (strcmp (arg, "rh850-abi") == 0)
    {
      v850_target_arch = bfd_arch_v850_rh850;
      v850_target_format = "elf32-v850-rh850";
    }
  else if (strcmp (arg, "8byte-align") == 0)
    v850_e_flags |= EF_RH850_DATA_ALIGN8;
  else if (strcmp (arg, "4byte-align") == 0)
    v850_e_flags &= ~ EF_RH850_DATA_ALIGN8;
  else
    return 0;

  return 1;
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

char *
md_atof (int type, char *litp, int *sizep)
{
  return ieee_md_atof (type, litp, sizep, FALSE);
}

/* Very gross.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec,
		 fragS *fragP)
{
  union u
  {
    bfd_reloc_code_real_type fx_r_type;
    char * fr_opcode;
  }
  opcode_converter;
  subseg_change (sec, 0);

  opcode_converter.fr_opcode = fragP->fr_opcode;

  subseg_change (sec, 0);

  if (fragP->fr_subtype == SUBYPTE_LOOP_16_22)
    {
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1,
	       BFD_RELOC_UNUSED + opcode_converter.fx_r_type);
      fragP->fr_fix += 4;
    }
  else if (fragP->fr_subtype == SUBYPTE_LOOP_16_22 + 1)
    {
      unsigned char * buffer =
	(unsigned char *) (fragP->fr_fix + fragP->fr_literal);
      int loop_reg = (buffer[0] & 0x1f);

      /* Add -1.reg.  */
      md_number_to_chars ((char *) buffer, 0x025f | (loop_reg << 11), 2);
      /* Now create the conditional branch + fixup to the final target.  */
      /* 0x000107ea = bne LBL(disp17).  */
      md_number_to_chars ((char *) buffer + 2, 0x000107ea, 4);
      fix_new (fragP, fragP->fr_fix+2, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1,
	       BFD_RELOC_V850_17_PCREL);
      fragP->fr_fix += 6;
    }
  /* In range conditional or unconditional branch.  */
  else if (fragP->fr_subtype == SUBYPTE_COND_9_22
      || fragP->fr_subtype == SUBYPTE_UNCOND_9_22
      || fragP->fr_subtype == SUBYPTE_COND_9_22_32
      || fragP->fr_subtype == SUBYPTE_UNCOND_9_22_32
      || fragP->fr_subtype == SUBYPTE_COND_9_17_22
      || fragP->fr_subtype == SUBYPTE_COND_9_17_22_32
      || fragP->fr_subtype == SUBYPTE_SA_9_22
      || fragP->fr_subtype == SUBYPTE_SA_9_22_32
      || fragP->fr_subtype == SUBYPTE_SA_9_17_22
      || fragP->fr_subtype == SUBYPTE_SA_9_17_22_32)

    {
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1,
	       BFD_RELOC_UNUSED + opcode_converter.fx_r_type);
      fragP->fr_fix += 2;
    }
  /* V850e2r-v3 17bit conditional branch.  */
  else if (fragP->fr_subtype == SUBYPTE_COND_9_17_22 + 1
	   || fragP->fr_subtype == SUBYPTE_COND_9_17_22_32 + 1
	   || fragP->fr_subtype == SUBYPTE_SA_9_17_22 + 1
	   || fragP->fr_subtype == SUBYPTE_SA_9_17_22_32 + 1)
    {
      unsigned char *buffer =
	(unsigned char *) (fragP->fr_fix + fragP->fr_literal);

      buffer[0] &= 0x0f;	/* Use condition.  */
      buffer[0] |= 0xe0;
      buffer[1] = 0x07;

      /* Now create the unconditional branch + fixup to the final
	 target.  */
      md_number_to_chars ((char *) buffer + 2, 0x0001, 2);
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_V850_17_PCREL);
      fragP->fr_fix += 4;
    }
  /* Out of range conditional branch.  Emit a branch around a 22bit jump.  */
  else if (fragP->fr_subtype == SUBYPTE_COND_9_22 + 1
	   || fragP->fr_subtype == SUBYPTE_COND_9_22_32 + 1
	   || fragP->fr_subtype == SUBYPTE_COND_9_17_22 + 2 
	   || fragP->fr_subtype == SUBYPTE_COND_9_17_22_32 + 2)
    {
      unsigned char *buffer =
	(unsigned char *) (fragP->fr_fix + fragP->fr_literal);

      /* Reverse the condition of the first branch.  */
      buffer[0] ^= 0x08;
      /* Mask off all the displacement bits.  */
      buffer[0] &= 0x8f;
      buffer[1] &= 0x07;
      /* Now set the displacement bits so that we branch
	 around the unconditional branch.  */
      buffer[0] |= 0x30;

      /* Now create the unconditional branch + fixup to the final
	 target.  */
      md_number_to_chars ((char *) buffer + 2, 0x00000780, 4);
      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_V850_22_PCREL);
      fragP->fr_fix += 6;
    }
  /* Out of range conditional branch.  Emit a branch around a 32bit jump.  */
  else if (fragP->fr_subtype == SUBYPTE_COND_9_22_32 + 2
	   || fragP->fr_subtype == SUBYPTE_COND_9_17_22_32 + 3)
    {
      unsigned char *buffer =
	(unsigned char *) (fragP->fr_fix + fragP->fr_literal);

      /* Reverse the condition of the first branch.  */
      buffer[0] ^= 0x08;
      /* Mask off all the displacement bits.  */
      buffer[0] &= 0x8f;
      buffer[1] &= 0x07;
      /* Now set the displacement bits so that we branch
	 around the unconditional branch.  */
      buffer[0] |= 0x40;

      /* Now create the unconditional branch + fixup to the final
	 target.  */
      md_number_to_chars ((char *) buffer + 2, 0x02e0, 2);
      fix_new (fragP, fragP->fr_fix + 4, 4, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_V850_32_PCREL);
      fragP->fr_fix += 8;
    }
  /* Out of range unconditional branch.  Emit a 22bit jump.  */
  else if (fragP->fr_subtype == SUBYPTE_UNCOND_9_22 + 1
	   || fragP->fr_subtype == SUBYPTE_UNCOND_9_22_32 + 1)
    {
      md_number_to_chars (fragP->fr_fix + fragP->fr_literal, 0x00000780, 4);
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_V850_22_PCREL);
      fragP->fr_fix += 4;
    }
  /* Out of range unconditional branch.  Emit a 32bit jump.  */
  else if (fragP->fr_subtype == SUBYPTE_UNCOND_9_22_32 + 2)
    {
      md_number_to_chars (fragP->fr_fix + fragP->fr_literal, 0x02e0, 2);
      fix_new (fragP, fragP->fr_fix + 4, 4, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_V850_32_PCREL);
      fragP->fr_fix += 6;
    }
  /* Out of range SA conditional branch.  Emit a branch to a 22bit jump.  */
  else if (fragP->fr_subtype == SUBYPTE_SA_9_22 + 1
	   || fragP->fr_subtype == SUBYPTE_SA_9_22_32 + 1
	   || fragP->fr_subtype == SUBYPTE_SA_9_17_22 + 2
	   || fragP->fr_subtype == SUBYPTE_SA_9_17_22_32 + 2)
    {
      unsigned char *buffer =
	(unsigned char *) (fragP->fr_fix + fragP->fr_literal);

      /* bsa .+4 */
      buffer[0] &= 0x8f;
      buffer[0] |= 0x20;
      buffer[1] &= 0x07;

      /* br .+6 */
      md_number_to_chars ((char *) buffer + 2, 0x05b5, 2);

      /* Now create the unconditional branch + fixup to the final
	 target.  */
      /* jr SYM */
      md_number_to_chars ((char *) buffer + 4, 0x00000780, 4);
      fix_new (fragP, fragP->fr_fix + 4, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1,
	       BFD_RELOC_V850_22_PCREL);
      fragP->fr_fix += 8;
    }
  /* Out of range SA conditional branch.  Emit a branch around a 32bit jump.  */
  else if (fragP->fr_subtype == SUBYPTE_SA_9_22_32 + 2
	   || fragP->fr_subtype == SUBYPTE_SA_9_17_22_32 + 3)
    {
      unsigned char *buffer =
	(unsigned char *) (fragP->fr_fix + fragP->fr_literal);

      /* bsa .+2 */
      buffer[0] &= 0x8f;
      buffer[0] |= 0x20;
      buffer[1] &= 0x07;

      /* br .+8 */
      md_number_to_chars ((char *) buffer + 2, 0x05c5, 2);

      /* Now create the unconditional branch + fixup to the final
	 target.  */
      /* jr SYM */
      md_number_to_chars ((char *) buffer + 4, 0x02e0, 2);
      fix_new (fragP, fragP->fr_fix + 6, 4, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_V850_32_PCREL);

      fragP->fr_fix += 10;
    }
  else
    abort ();
}

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin (void)
{
  char *prev_name = "";
  const struct v850_opcode *op;

  if (strncmp (TARGET_CPU, "v850e3v5", 8) == 0)
    {
      if (machine == -1)
	machine = bfd_mach_v850e3v5;

      if (!processor_mask)
	SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E3V5);
    }
  else if (strncmp (TARGET_CPU, "v850e2v4", 8) == 0)
    {
      if (machine == -1)
	machine = bfd_mach_v850e3v5;

      if (!processor_mask)
	SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E3V5);
    }
  else if (strncmp (TARGET_CPU, "v850e2v3", 8) == 0)
    {
      if (machine == -1)
        machine = bfd_mach_v850e2v3;

      if (!processor_mask)
        SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E2V3);
    }
  else if (strncmp (TARGET_CPU, "v850e2", 6) == 0)
    {
      if (machine == -1)
	machine = bfd_mach_v850e2;

      if (!processor_mask)
	SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E2);
    }
  else if (strncmp (TARGET_CPU, "v850e1", 6) == 0)
    {
      if (machine == -1)
        machine = bfd_mach_v850e1;

      if (!processor_mask)
        SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E1);
    }
  else if (strncmp (TARGET_CPU, "v850e", 5) == 0)
    {
      if (machine == -1)
	machine = bfd_mach_v850e;

      if (!processor_mask)
	SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850E);
    }
  else if (strncmp (TARGET_CPU, "v850", 4) == 0)
    {
      if (machine == -1)
	machine = 0;

      if (!processor_mask)
	SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V850);
    }
  else
    /* xgettext:c-format  */
    as_bad (_("Unable to determine default target processor from string: %s"),
	    TARGET_CPU);

  v850_hash = hash_new ();

  /* Insert unique names into hash table.  The V850 instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */
  op = v850_opcodes;
  while (op->name)
    {
      if (strcmp (prev_name, op->name))
	{
	  prev_name = (char *) op->name;
	  hash_insert (v850_hash, op->name, (char *) op);
	}
      op++;
    }

  v850_seg_table[BSS_SECTION].s = bss_section;
  bfd_set_arch_mach (stdoutput, v850_target_arch, machine);
  bfd_set_private_flags (stdoutput, v850_e_flags);
}


static bfd_reloc_code_real_type
handle_hi016 (const struct v850_operand *operand, const char **errmsg)
{
  if (operand == NULL)
    return BFD_RELOC_HI16;

  if (operand->default_reloc == BFD_RELOC_HI16)
    return BFD_RELOC_HI16;

  if (operand->default_reloc == BFD_RELOC_HI16_S)
    return BFD_RELOC_HI16;

  if (operand->default_reloc == BFD_RELOC_16)
    return BFD_RELOC_HI16;

  *errmsg = _("hi0() relocation used on an instruction which does "
	      "not support it");
  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
}

static bfd_reloc_code_real_type
handle_hi16 (const struct v850_operand *operand, const char **errmsg)
{
  if (operand == NULL)
    return BFD_RELOC_HI16_S;

  if (operand->default_reloc == BFD_RELOC_HI16_S)
    return BFD_RELOC_HI16_S;

  if (operand->default_reloc == BFD_RELOC_HI16)
    return BFD_RELOC_HI16_S;

  if (operand->default_reloc == BFD_RELOC_16)
    return BFD_RELOC_HI16_S;

  *errmsg = _("hi() relocation used on an instruction which does "
	      "not support it");
  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
}

static bfd_reloc_code_real_type
handle_lo16 (const struct v850_operand *operand, const char **errmsg)
{
  if (operand == NULL)
    return BFD_RELOC_LO16;

  if (operand->default_reloc == BFD_RELOC_LO16)
    return BFD_RELOC_LO16;

  if (operand->default_reloc == BFD_RELOC_V850_16_SPLIT_OFFSET)
    return BFD_RELOC_V850_LO16_SPLIT_OFFSET;

  if (operand->default_reloc == BFD_RELOC_V850_16_S1)
    return BFD_RELOC_V850_LO16_S1;

  if (operand->default_reloc == BFD_RELOC_16)
    return BFD_RELOC_LO16;

  *errmsg = _("lo() relocation used on an instruction which does "
	      "not support it");
  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
}

static bfd_reloc_code_real_type
handle_ctoff (const struct v850_operand *operand, const char **errmsg)
{
  if (operand == NULL)
    return BFD_RELOC_V850_CALLT_16_16_OFFSET;

  if (operand->default_reloc == BFD_RELOC_V850_CALLT_6_7_OFFSET)
    return operand->default_reloc;

  if (operand->default_reloc == BFD_RELOC_V850_16_S1)
    return BFD_RELOC_V850_CALLT_15_16_OFFSET;

  if (operand->default_reloc == BFD_RELOC_16)
    return BFD_RELOC_V850_CALLT_16_16_OFFSET;

  *errmsg = _("ctoff() relocation used on an instruction which does not support it");
  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
}

static bfd_reloc_code_real_type
handle_sdaoff (const struct v850_operand *operand, const char **errmsg)
{
  if (operand == NULL)
    return BFD_RELOC_V850_SDA_16_16_OFFSET;

  if (operand->default_reloc == BFD_RELOC_V850_16_SPLIT_OFFSET)
    return BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET;

  if (operand->default_reloc == BFD_RELOC_16)
    return BFD_RELOC_V850_SDA_16_16_OFFSET;

  if (operand->default_reloc == BFD_RELOC_V850_16_S1)
    return BFD_RELOC_V850_SDA_15_16_OFFSET;

  *errmsg = _("sdaoff() relocation used on an instruction which does not support it");
  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
}

static bfd_reloc_code_real_type
handle_zdaoff (const struct v850_operand *operand, const char **errmsg)
{
  if (operand == NULL)
    return BFD_RELOC_V850_ZDA_16_16_OFFSET;

  if (operand->default_reloc == BFD_RELOC_V850_16_SPLIT_OFFSET)
    return BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET;

  if (operand->default_reloc == BFD_RELOC_16)
    return BFD_RELOC_V850_ZDA_16_16_OFFSET;

  if (operand->default_reloc == BFD_RELOC_V850_16_S1)
    return BFD_RELOC_V850_ZDA_15_16_OFFSET;

  *errmsg = _("zdaoff() relocation used on an instruction which does not support it");
  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
}

static bfd_reloc_code_real_type
handle_tdaoff (const struct v850_operand *operand, const char **errmsg)
{
  if (operand == NULL)
    /* Data item, not an instruction.  */
    return BFD_RELOC_V850_TDA_16_16_OFFSET;

  switch (operand->default_reloc)
    {
      /* sld.hu, operand: D5-4.  */
    case BFD_RELOC_V850_TDA_4_5_OFFSET:
      /* sld.bu, operand: D4.  */
    case BFD_RELOC_V850_TDA_4_4_OFFSET:
    /* sld.w/sst.w, operand: D8_6.  */
    case BFD_RELOC_V850_TDA_6_8_OFFSET:
    /* sld.h/sst.h, operand: D8_7.  */
    case BFD_RELOC_V850_TDA_7_8_OFFSET:
      /* sld.b/sst.b, operand: D7.  */
    case BFD_RELOC_V850_TDA_7_7_OFFSET:
      return operand->default_reloc;
    default:
      break;
    }

  if (operand->default_reloc == BFD_RELOC_16 && operand->shift == 16)
    /* set1 & chums, operands: D16.  */
    return BFD_RELOC_V850_TDA_16_16_OFFSET;

  *errmsg = _("tdaoff() relocation used on an instruction which does not support it");
  /* Used to indicate an error condition.  */
  return BFD_RELOC_64;
}

/* Warning: The code in this function relies upon the definitions
   in the v850_operands[] array (defined in opcodes/v850-opc.c)
   matching the hard coded values contained herein.  */

static bfd_reloc_code_real_type
v850_reloc_prefix (const struct v850_operand *operand, const char **errmsg)
{
  bfd_boolean paren_skipped = FALSE;

  /* Skip leading opening parenthesis.  */
  if (*input_line_pointer == '(')
    {
      ++input_line_pointer;
      paren_skipped = TRUE;
    }

#define CHECK_(name, reloc) 						\
  if (strncmp (input_line_pointer, name "(", strlen (name) + 1) == 0)	\
    {									\
      input_line_pointer += strlen (name);				\
      return reloc;							\
    }

  CHECK_ ("hi0",    handle_hi016(operand, errmsg)  );
  CHECK_ ("hi",	    handle_hi16(operand, errmsg)   );
  CHECK_ ("lo",	    handle_lo16 (operand, errmsg)  );
  CHECK_ ("sdaoff", handle_sdaoff (operand, errmsg));
  CHECK_ ("zdaoff", handle_zdaoff (operand, errmsg));
  CHECK_ ("tdaoff", handle_tdaoff (operand, errmsg));
  CHECK_ ("hilo",   BFD_RELOC_32);
  CHECK_ ("lo23",   BFD_RELOC_V850_23);
  CHECK_ ("ctoff",  handle_ctoff (operand, errmsg) );

  /* Restore skipped parenthesis.  */
  if (paren_skipped)
    --input_line_pointer;

  return BFD_RELOC_UNUSED;
}

/* Insert an operand value into an instruction.  */

static unsigned long
v850_insert_operand (unsigned long insn,
		     const struct v850_operand *operand,
		     offsetT val,
		     const char **errmsg)
{
  if (operand->insert)
    {
      const char *message = NULL;

      insn = operand->insert (insn, val, &message);
      if (message != NULL)
	{
	  if ((operand->flags & V850_OPERAND_SIGNED)
	      && ! warn_signed_overflows
              && v850_msg_is_out_of_range (message))
	    {
	      /* Skip warning...  */
	    }
	  else if ((operand->flags & V850_OPERAND_SIGNED) == 0
		   && ! warn_unsigned_overflows
                  && v850_msg_is_out_of_range (message))
	    {
	      /* Skip warning...  */
	    }
	  else
	    {
             if (errmsg != NULL)
               *errmsg = message;
	    }
	}
    }
  else if (operand->bits == -1
          || operand->flags & V850E_IMMEDIATE16
          || operand->flags & V850E_IMMEDIATE23
          || operand->flags & V850E_IMMEDIATE32)
    {
      abort ();
    }
  else
    {
      if (operand->bits < 32)
	{
	  long min, max;

	  if ((operand->flags & V850_OPERAND_SIGNED) != 0)
	    {
	      if (! warn_signed_overflows)
		max = (1 << operand->bits) - 1;
	      else
		max = (1 << (operand->bits - 1)) - 1;

	      min = -(1 << (operand->bits - 1));
	    }
	  else
	    {
	      max = (1 << operand->bits) - 1;

	      if (! warn_unsigned_overflows)
		min = -(1 << (operand->bits - 1));
	      else
		min = 0;
	    }

	  /* Some people write constants with the sign extension done by
	     hand but only up to 32 bits.  This shouldn't really be valid,
	     but, to permit this code to assemble on a 64-bit host, we
	     sign extend the 32-bit value to 64 bits if so doing makes the
	     value valid.  */
	  if (val > max
	      && (offsetT) (val - 0x80000000 - 0x80000000) >= min
	      && (offsetT) (val - 0x80000000 - 0x80000000) <= max)
	    val = val - 0x80000000 - 0x80000000;

	  /* Similarly, people write expressions like ~(1<<15), and expect
	     this to be OK for a 32-bit unsigned value.  */
	  else if (val < min
		   && (offsetT) (val + 0x80000000 + 0x80000000) >= min
		   && (offsetT) (val + 0x80000000 + 0x80000000) <= max)
	    val = val + 0x80000000 + 0x80000000;

	  else if (val < (offsetT) min || val > (offsetT) max)
	    {
	      static char buf [128];

	      /* Restore min and mix to expected values for decimal ranges.  */
	      if ((operand->flags & V850_OPERAND_SIGNED)
		  && ! warn_signed_overflows)
		max = (1 << (operand->bits - 1)) - 1;

	      if (! (operand->flags & V850_OPERAND_SIGNED)
		  && ! warn_unsigned_overflows)
		min = 0;

	      sprintf (buf, _("operand out of range (%d is not between %d and %d)"),
		       (int) val, (int) min, (int) max);
	      *errmsg = buf;
	    }

	  insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
	}
      else
	{
	  insn |= (((long) val) << operand->shift);
	}
    }

  return insn;
}

static char copy_of_instruction[128];

void
md_assemble (char *str)
{
  char *s;
  char *start_of_operands;
  struct v850_opcode *opcode;
  struct v850_opcode *next_opcode;
  const unsigned char *opindex_ptr;
  int next_opindex;
  int relaxable = 0;
  unsigned long insn;
  unsigned long insn_size;
  char *f = NULL;
  int i;
  int match;
  bfd_boolean extra_data_after_insn = FALSE;
  unsigned extra_data_len = 0;
  unsigned long extra_data = 0;
  char *saved_input_line_pointer;
  char most_match_errmsg[1024];
  int most_match_count = -1;

  strncpy (copy_of_instruction, str, sizeof (copy_of_instruction) - 1);
  most_match_errmsg[0] = 0;

  /* Get the opcode.  */
  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
    continue;

  if (*s != '\0')
    *s++ = '\0';

  /* Find the first opcode with the proper name.  */
  opcode = (struct v850_opcode *) hash_find (v850_hash, str);
  if (opcode == NULL)
    {
      /* xgettext:c-format  */
      as_bad (_("Unrecognized opcode: `%s'"), str);
      ignore_rest_of_line ();
      return;
    }

  str = s;
  while (ISSPACE (*str))
    ++str;

  start_of_operands = str;

  saved_input_line_pointer = input_line_pointer;

  for (;;)
    {
      const char *errmsg = NULL;
      const char *warningmsg = NULL;

      match = 0;
      opindex_ptr = opcode->operands;

      if (no_stld23)
	{
	  if ((strncmp (opcode->name, "st.", 3) == 0
	       && v850_operands[opcode->operands[1]].bits == 23)
	      || (strncmp (opcode->name, "ld.", 3) == 0
		  && v850_operands[opcode->operands[0]].bits == 23))
	    {
	      errmsg = _("st/ld offset 23 instruction was disabled .");
	      goto error;
	    }
	}

      if ((opcode->processors & processor_mask & PROCESSOR_MASK) == 0
	  || (((opcode->processors & ~PROCESSOR_MASK) != 0)
	      && ((opcode->processors & processor_mask & ~PROCESSOR_MASK) == 0)))
	{
	  errmsg = _("Target processor does not support this instruction.");
	  goto error;
	}

      relaxable = 0;
      fc = 0;
      next_opindex = 0;
      insn = opcode->opcode;
      extra_data_len = 0;
      extra_data_after_insn = FALSE;

      input_line_pointer = str = start_of_operands;

      for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
	{
	  const struct v850_operand *operand;
	  char *hold;
	  expressionS ex;
	  bfd_reloc_code_real_type reloc;

	  if (next_opindex == 0)
	    operand = &v850_operands[*opindex_ptr];
	  else
	    {
	      operand = &v850_operands[next_opindex];
	      next_opindex = 0;
	    }

	  errmsg = NULL;

	  while (*str == ' ')
	    ++str;

	  if (operand->flags & V850_OPERAND_BANG
	      && *str == '!')
	    ++str;
	  else if (operand->flags & V850_OPERAND_PERCENT
		   && *str == '%')
	    ++str;

	  if (*str == ',' || *str == '[' || *str == ']')
	    ++str;

	  while (*str == ' ')
	    ++str;

	  if (   (strcmp (opcode->name, "pushsp") == 0
	       || strcmp (opcode->name, "popsp") == 0
	       || strcmp (opcode->name, "dbpush") == 0)
	      && (*str == '-'))
	    ++str;

	  if (operand->flags & V850_OPERAND_RELAX)
	    relaxable = 1;

	  /* Gather the operand.  */
	  hold = input_line_pointer;
	  input_line_pointer = str;

	  /* lo(), hi(), hi0(), etc...  */
	  if ((reloc = v850_reloc_prefix (operand, &errmsg)) != BFD_RELOC_UNUSED)
	    {
	      /* This is a fake reloc, used to indicate an error condition.  */
	      if (reloc == BFD_RELOC_64)
		{
		  /* match = 1;  */
		  goto error;
		}

	      expression (&ex);

	      if (ex.X_op == O_constant)
		{
		  switch (reloc)
		    {
		    case BFD_RELOC_V850_ZDA_16_16_OFFSET:
		    case BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET:
		    case BFD_RELOC_V850_ZDA_15_16_OFFSET:
		      /* To cope with "not1 7, zdaoff(0xfffff006)[r0]"
			 and the like.  */
		      /* Fall through.  */

		    case BFD_RELOC_LO16:
		    case BFD_RELOC_V850_LO16_S1:
		    case BFD_RELOC_V850_LO16_SPLIT_OFFSET:
		      {
			/* Truncate, then sign extend the value.  */
			ex.X_add_number = SEXT16 (ex.X_add_number);
			break;
		      }

		    case BFD_RELOC_HI16:
		      {
			/* Truncate, then sign extend the value.  */
			ex.X_add_number = SEXT16 (ex.X_add_number >> 16);
			break;
		      }

		    case BFD_RELOC_HI16_S:
		      {
			/* Truncate, then sign extend the value.  */
			int temp = (ex.X_add_number >> 16) & 0xffff;

			temp += (ex.X_add_number >> 15) & 1;

			ex.X_add_number = SEXT16 (temp);
			break;
		      }

		    case BFD_RELOC_V850_23:
		      if ((operand->flags & V850E_IMMEDIATE23) == 0)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}
		      break;

		    case BFD_RELOC_32:
		    case BFD_RELOC_V850_32_ABS:
		    case BFD_RELOC_V850_32_PCREL:
		      if ((operand->flags & V850E_IMMEDIATE32) == 0)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}

		      break;

		    default:
		      as_bad (_("AAARG -> unhandled constant reloc: %d"), reloc);
		      break;
		    }

		  if (operand->flags & V850E_IMMEDIATE32)
		    {
		      extra_data_after_insn = TRUE;
		      extra_data_len	    = 4;
		      extra_data	    = 0;
		    }
		  else if (operand->flags & V850E_IMMEDIATE23)
		    {
		      if (reloc != BFD_RELOC_V850_23)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}
		      extra_data_after_insn = TRUE;
		      extra_data_len	    = 2;
		      extra_data	    = 0;
		    }
		  else if ((operand->flags & V850E_IMMEDIATE16)
			   || (operand->flags & V850E_IMMEDIATE16HI))
		    {
		      if (operand->flags & V850E_IMMEDIATE16HI
			  && reloc != BFD_RELOC_HI16
			  && reloc != BFD_RELOC_HI16_S)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}
		      else if (operand->flags & V850E_IMMEDIATE16
			       && reloc != BFD_RELOC_LO16)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}

		      extra_data_after_insn = TRUE;
		      extra_data_len	    = 2;
		      extra_data	    = 0;
		    }

		  if (fc > MAX_INSN_FIXUPS)
		    as_fatal (_("too many fixups"));

		  fixups[fc].exp     = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc   = reloc;
		  fc++;
		}
	      else	/* ex.X_op != O_constant.  */
		{
		  if ((reloc == BFD_RELOC_32
		       || reloc == BFD_RELOC_V850_32_ABS
		       || reloc == BFD_RELOC_V850_32_PCREL)
		      && operand->bits < 32)
		    {
		      errmsg = _("immediate operand is too large");
		      goto error;
		    }
		  else if (reloc == BFD_RELOC_V850_23
			   && (operand->flags & V850E_IMMEDIATE23) == 0)
		    {
		      errmsg = _("immediate operand is too large");
		      goto error;
		    }
		  else if ((reloc == BFD_RELOC_HI16
			    || reloc == BFD_RELOC_HI16_S)
			   && operand->bits < 16)
		    {
		      errmsg = _("immediate operand is too large");
		      goto error;
		    }

		  if (operand->flags & V850E_IMMEDIATE32)
		    {
		      extra_data_after_insn = TRUE;
		      extra_data_len	    = 4;
		      extra_data	    = 0;
		    }
		  else if (operand->flags & V850E_IMMEDIATE23)
		    {
		      if (reloc != BFD_RELOC_V850_23)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}
		      extra_data_after_insn = TRUE;
		      extra_data_len	    = 2;
		      extra_data	    = 0;
		    }
		  else if ((operand->flags & V850E_IMMEDIATE16)
			   || (operand->flags & V850E_IMMEDIATE16HI))
		    {
		      if (operand->flags & V850E_IMMEDIATE16HI
			  && reloc != BFD_RELOC_HI16
			  && reloc != BFD_RELOC_HI16_S)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}
		      else if (operand->flags & V850E_IMMEDIATE16
			       && reloc != BFD_RELOC_LO16)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}

		      extra_data_after_insn = TRUE;
		      extra_data_len	    = 2;
		      extra_data	    = 0;
		    }

		  if (fc > MAX_INSN_FIXUPS)
		    as_fatal (_("too many fixups"));

		  fixups[fc].exp     = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc   = reloc;
		  fc++;
		}
	    }
	  else if (operand->flags & V850E_IMMEDIATE16
		   || operand->flags & V850E_IMMEDIATE16HI)
	    {
	      expression (&ex);

	      switch (ex.X_op)
		{
		case O_constant:
		  if (operand->flags & V850E_IMMEDIATE16HI)
		    {
		      if (ex.X_add_number & 0xffff)
			{
			  errmsg = _("constant too big to fit into instruction");
			  goto error;
			}

		      ex.X_add_number >>= 16;
		    }
		  if (operand->flags & V850E_IMMEDIATE16)
		    {
		      if ((ex.X_add_number & 0xffff8000)
			  && ((ex.X_add_number & 0xffff8000) != 0xffff8000))
			{
			  errmsg = _("constant too big to fit into instruction");
			  goto error;
			}
		    }
		  break;

		case O_illegal:
		  errmsg = _("illegal operand");
		  goto error;

		case O_absent:
		  errmsg = _("missing operand");
		  goto error;

		default:
		  if (fc >= MAX_INSN_FIXUPS)
		    as_fatal (_("too many fixups"));

		  fixups[fc].exp     = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc   = operand->default_reloc;
		  ++fc;

		  ex.X_add_number = 0;
		  break;
		}

	      extra_data_after_insn = TRUE;
	      extra_data_len        = 2;
	      extra_data            = ex.X_add_number;
	    }
	  else if (operand->flags & V850E_IMMEDIATE23)
	    {
	      expression (&ex);

	      switch (ex.X_op)
		{
		case O_constant:
		  break;

		case O_illegal:
		  errmsg = _("illegal operand");
		  goto error;

		case O_absent:
		  errmsg = _("missing operand");
		  goto error;

		default:
		  break;
		}

	      if (fc >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));

	      fixups[fc].exp     = ex;
	      fixups[fc].opindex = *opindex_ptr;
	      fixups[fc].reloc   = operand->default_reloc;
	      ++fc;

	      extra_data_after_insn = TRUE;
	      extra_data_len        = 2;
	      extra_data            = 0;
	    }
	  else if (operand->flags & V850E_IMMEDIATE32)
	    {
	      expression (&ex);

	      switch (ex.X_op)
		{
		case O_constant:
		  if ((operand->default_reloc == BFD_RELOC_V850_32_ABS
		       || operand->default_reloc == BFD_RELOC_V850_32_PCREL)
		      && (ex.X_add_number & 1))
		    {
		      errmsg = _("odd number cannot be used here");
		      goto error;
		    }
		  break;

		case O_illegal:
		  errmsg = _("illegal operand");
		  goto error;

		case O_absent:
		  errmsg = _("missing operand");
		  goto error;

		default:
		  if (fc >= MAX_INSN_FIXUPS)
		    as_fatal (_("too many fixups"));

		  fixups[fc].exp     = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc   = operand->default_reloc;
		  ++fc;

		  ex.X_add_number = 0;
		  break;
		}

	      extra_data_after_insn = TRUE;
	      extra_data_len        = 4;
	      extra_data            = ex.X_add_number;
	    }
	  else if (operand->flags & V850E_OPERAND_REG_LIST)
	    {
	      errmsg = parse_register_list (&insn, operand);

	      if (errmsg)
		goto error;
	    }
	  else
	    {
	      errmsg = NULL;

	      if ((operand->flags & V850_OPERAND_REG) != 0)
		{
		  if (!register_name (&ex))
		    {
		      errmsg = _("invalid register name");
		    }

		  if ((operand->flags & V850_NOT_R0)
			   && ex.X_add_number == 0)
		    {
		      errmsg = _("register r0 cannot be used here");
		    }

		  if (operand->flags & V850_REG_EVEN)
		    {
		      if (ex.X_add_number % 2)
			errmsg = _("odd register cannot be used here");
		      ex.X_add_number = ex.X_add_number / 2;
		    }

		}
	      else if ((operand->flags & V850_OPERAND_SRG) != 0)
		{
		  if (!system_register_name (&ex, TRUE))
		    {
		      errmsg = _("invalid system register name");
		    }
		}
	      else if ((operand->flags & V850_OPERAND_EP) != 0)
		{
		  char *start = input_line_pointer;
		  char c = get_symbol_end ();

		  if (strcmp (start, "ep") != 0 && strcmp (start, "r30") != 0)
		    {
		      /* Put things back the way we found them.  */
		      *input_line_pointer = c;
		      input_line_pointer = start;
		      errmsg = _("expected EP register");
		      goto error;
		    }

		  *input_line_pointer = c;
		  str = input_line_pointer;
		  input_line_pointer = hold;

		  while (*str == ' ' || *str == ','
			 || *str == '[' || *str == ']')
		    ++str;
		  continue;
		}
	      else if ((operand->flags & V850_OPERAND_CC) != 0)
		{
		  if (!cc_name (&ex, TRUE))
		    {
		      errmsg = _("invalid condition code name");
		    }

		  if ((operand->flags & V850_NOT_SA)
		      && ex.X_add_number == COND_SA_NUM)
		    {
		      errmsg = _("condition sa cannot be used here");
		    }
		}
	      else if ((operand->flags & V850_OPERAND_FLOAT_CC) != 0)
		{
		  if (!float_cc_name (&ex, TRUE))
		    {
		      errmsg = _("invalid condition code name");
		    }
		}
	      else if ((operand->flags & V850_OPERAND_CACHEOP) != 0)
		{
		  if (!cacheop_name (&ex, TRUE))
		    errmsg = _("invalid cache oparation name");
		}
	      else if ((operand->flags & V850_OPERAND_PREFOP) != 0)
		{
		  if (!prefop_name (&ex, TRUE))
		    errmsg = _("invalid pref oparation name");
		}
	      else if ((operand->flags & V850_OPERAND_VREG) != 0)
		{
		  if (!vector_register_name (&ex))
		    errmsg = _("invalid vector register name");
		}
	      else if ((register_name (&ex)
			&& (operand->flags & V850_OPERAND_REG) == 0))
		{
		  char c;
		  int exists = 0;

		  /* It is possible that an alias has been defined that
		     matches a register name.  For example the code may
		     include a ".set ZERO, 0" directive, which matches
		     the register name "zero".  Attempt to reparse the
		     field as an expression, and only complain if we
		     cannot generate a constant.  */

		  input_line_pointer = str;

		  c = get_symbol_end ();

		  if (symbol_find (str) != NULL)
		    exists = 1;

		  *input_line_pointer = c;
		  input_line_pointer = str;

		  expression (&ex);

		  if (ex.X_op != O_constant)
		    {
		      /* If this register is actually occurring too early on
			 the parsing of the instruction, (because another
			 field is missing) then report this.  */
		      if (opindex_ptr[1] != 0
			  && ((v850_operands[opindex_ptr[1]].flags
			       & V850_OPERAND_REG)
			      ||(v850_operands[opindex_ptr[1]].flags
				 & V850_OPERAND_VREG)))
			errmsg = _("syntax error: value is missing before the register name");
		      else
			errmsg = _("syntax error: register not expected");

		      /* If we created a symbol in the process of this
			 test then delete it now, so that it will not
			 be output with the real symbols...  */
		      if (exists == 0
			  && ex.X_op == O_symbol)
			symbol_remove (ex.X_add_symbol,
				       &symbol_rootP, &symbol_lastP);
		    }
		}
	      else if (system_register_name (&ex, FALSE)
		       && (operand->flags & V850_OPERAND_SRG) == 0)
		{
		  errmsg = _("syntax error: system register not expected");
		}
	      else if (cc_name (&ex, FALSE)
		       && (operand->flags & V850_OPERAND_CC) == 0)
		{
		  errmsg = _("syntax error: condition code not expected");
		}
	      else if (float_cc_name (&ex, FALSE)
		       && (operand->flags & V850_OPERAND_FLOAT_CC) == 0)
		{
		  errmsg = _("syntax error: condition code not expected");
		}
	      else if (vector_register_name (&ex)
		       && (operand->flags & V850_OPERAND_VREG) == 0)
		{
		  errmsg = _("syntax error: vector register not expected");
		}
	      else
		{
		  expression (&ex);

		  if ((operand->flags & V850_NOT_IMM0)
		      && ex.X_op == O_constant
		      && ex.X_add_number == 0)
		    {
		      errmsg = _("immediate 0 cannot be used here");
		    }

		  /* Special case:
		     If we are assembling a MOV/JARL/JR instruction and the immediate
		     value does not fit into the bits available then create a
		     fake error so that the next MOV/JARL/JR instruction will be
		     selected.  This one has a 32 bit immediate field.  */

		  if ((strcmp (opcode->name, "mov") == 0
		       || strcmp (opcode->name, "jarl") == 0
		       || strcmp (opcode->name, "jr") == 0)
		      && ex.X_op == O_constant
		      && (ex.X_add_number < (-(1 << (operand->bits - 1)))
			  || ex.X_add_number > ((1 << (operand->bits - 1)) - 1)))
		    {
		      errmsg = _("immediate operand is too large");
		    }

		  if ((strcmp (opcode->name, "jarl") == 0
		       || strcmp (opcode->name, "jr") == 0)
		      && ex.X_op != O_constant
		      && operand->bits != default_disp_size)
		    {
		      errmsg = _("immediate operand is not match");
		    }

                  /* Special case2 :
                     If we are assembling a ld/st instruction and the immediate
                     value does not fit into the bits available then create a
                     fake error so that the next ld/st instruction will be
                     selected.  */
                  if ( (  (strncmp (opcode->name, "st.", 3) == 0)
		       || (strncmp (opcode->name, "ld.", 3) == 0))
                      && ex.X_op == O_constant
                      && (ex.X_add_number < (-(1 << (operand->bits - 1)))
			  || ex.X_add_number > ((1 << (operand->bits - 1)) - 1)))
		    errmsg = _("displacement is too large");
		}

	      if (errmsg)
		goto error;

	      switch (ex.X_op)
		{
		case O_illegal:
		  errmsg = _("illegal operand");
		  goto error;
		case O_absent:
		  errmsg = _("missing operand");
		  goto error;
		case O_register:
		  if ((operand->flags
		       & (V850_OPERAND_REG | V850_OPERAND_SRG | V850_OPERAND_VREG)) == 0)
		    {
		      errmsg = _("invalid operand");
		      goto error;
		    }

		  insn = v850_insert_operand (insn, operand,
					      ex.X_add_number,
					      &warningmsg);

		  break;

		case O_constant:
		  insn = v850_insert_operand (insn, operand, ex.X_add_number,
					      &warningmsg);
		  break;

		default:
		  /* We need to generate a fixup for this expression.  */
		  if (fc >= MAX_INSN_FIXUPS)
		    as_fatal (_("too many fixups"));

		  fixups[fc].exp     = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc   = BFD_RELOC_UNUSED;
		  ++fc;
		  break;
		}
	    }

	  str = input_line_pointer;
	  input_line_pointer = hold;

	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']'
		 || *str == ')')
	    ++str;
	}

      while (ISSPACE (*str))
	++str;

      if (*str == '\0')
	match = 1;

    error:
      if (match == 0)
	{
	  if ((opindex_ptr - opcode->operands) >= most_match_count)
	    {
	      most_match_count = opindex_ptr - opcode->operands;
	      if (errmsg != NULL)
		strncpy (most_match_errmsg, errmsg, sizeof (most_match_errmsg)-1);
	    }

	  next_opcode = opcode + 1;
	  if (next_opcode->name != NULL
	      && strcmp (next_opcode->name, opcode->name) == 0)
	    {
	      opcode = next_opcode;

	      /* Skip versions that are not supported by the target
		 processor.  */
	      if ((opcode->processors & processor_mask) == 0)
		goto error;

	      continue;
	    }

	  if (most_match_errmsg[0] == 0)
	    /* xgettext:c-format.  */
	    as_bad (_("junk at end of line: `%s'"), str);
	  else
	    as_bad ("%s: %s", copy_of_instruction, most_match_errmsg);

	  if (*input_line_pointer == ']')
	    ++input_line_pointer;

	  ignore_rest_of_line ();
	  input_line_pointer = saved_input_line_pointer;
	  return;
	}

      if (warningmsg != NULL)
	as_warn ("%s", warningmsg);
      break;
    }

  input_line_pointer = str;

  /* Tie dwarf2 debug info to the address at the start of the insn.
     We can't do this after the insn has been output as the current
     frag may have been closed off.  eg. by frag_var.  */
  dwarf2_emit_insn (0);

  /* Write out the instruction.  */

  if (relaxable && fc > 0)
    {
      insn_size = 2;
      fc = 0;

      if (strcmp (opcode->name, "loop") == 0)
	{
	  if (((processor_mask & PROCESSOR_V850E3V5_UP) == 0) || default_disp_size == 22)
	    {
	      insn_size = 4;
	      f = frag_var (rs_machine_dependent, 6, 2, SUBYPTE_LOOP_16_22,
			    fixups[0].exp.X_add_symbol,
			    fixups[0].exp.X_add_number,
			    (char *)(size_t) fixups[0].opindex);
	      md_number_to_chars (f, insn, insn_size);
	      md_number_to_chars (f+4, 0, 4);
	    }
	  else
	    {
	      as_bad (_("loop: 32-bit displacement not supported"));
	    }
	}
      else if (strcmp (opcode->name, "br") == 0
	       || strcmp (opcode->name, "jbr") == 0)
	{
	  if ((processor_mask & PROCESSOR_V850E2_UP) == 0 || default_disp_size == 22)
	    {
	      f = frag_var (rs_machine_dependent, 4, 2, SUBYPTE_UNCOND_9_22,
			    fixups[0].exp.X_add_symbol,
			    fixups[0].exp.X_add_number,
			    (char *)(size_t) fixups[0].opindex);
	      md_number_to_chars (f, insn, insn_size);
	      md_number_to_chars (f + 2, 0, 2);
	    }
	  else
	    {
	      f = frag_var (rs_machine_dependent, 6, 4, SUBYPTE_UNCOND_9_22_32,
			    fixups[0].exp.X_add_symbol,
			    fixups[0].exp.X_add_number,
			    (char *)(size_t) fixups[0].opindex);
	      md_number_to_chars (f, insn, insn_size);
	      md_number_to_chars (f + 2, 0, 4);
	    }
	}
      else /* b<cond>, j<cond>.  */
	{
	  if (default_disp_size == 22
	      || (processor_mask & PROCESSOR_V850E2_UP) == 0)
	    {
	      if (processor_mask & PROCESSOR_V850E2V3_UP && !no_bcond17)
		{
		  if (strcmp (opcode->name, "bsa") == 0)
		    {
		      f = frag_var (rs_machine_dependent, 8, 6, SUBYPTE_SA_9_17_22,
				    fixups[0].exp.X_add_symbol,
				    fixups[0].exp.X_add_number,
				    (char *)(size_t) fixups[0].opindex);
		      md_number_to_chars (f, insn, insn_size);
		      md_number_to_chars (f + 2, 0, 6);
		    }
		  else
		    {
		      f = frag_var (rs_machine_dependent, 6, 4, SUBYPTE_COND_9_17_22,
				    fixups[0].exp.X_add_symbol,
				    fixups[0].exp.X_add_number,
				    (char *)(size_t) fixups[0].opindex);
		      md_number_to_chars (f, insn, insn_size);
		      md_number_to_chars (f + 2, 0, 4);
		    }
		}
	      else
		{
		  if (strcmp (opcode->name, "bsa") == 0)
		    {
		      f = frag_var (rs_machine_dependent, 8, 6, SUBYPTE_SA_9_22,
				    fixups[0].exp.X_add_symbol,
				    fixups[0].exp.X_add_number,
				    (char *)(size_t) fixups[0].opindex);
		      md_number_to_chars (f, insn, insn_size);
		      md_number_to_chars (f + 2, 0, 6);
		    }
		  else
		    {
		      f = frag_var (rs_machine_dependent, 6, 4, SUBYPTE_COND_9_22,
				    fixups[0].exp.X_add_symbol,
				    fixups[0].exp.X_add_number,
				    (char *)(size_t) fixups[0].opindex);
		      md_number_to_chars (f, insn, insn_size);
		      md_number_to_chars (f + 2, 0, 4);
		    }
		}
	    }
	  else
	    {
	      if (processor_mask & PROCESSOR_V850E2V3_UP && !no_bcond17)
		{
		  if (strcmp (opcode->name, "bsa") == 0)
		    {
		      f = frag_var (rs_machine_dependent, 10, 8, SUBYPTE_SA_9_17_22_32,
				    fixups[0].exp.X_add_symbol,
				    fixups[0].exp.X_add_number,
				    (char *)(size_t) fixups[0].opindex);
		      md_number_to_chars (f, insn, insn_size);
		      md_number_to_chars (f + 2, 0, 8);
		    }
		  else
		    {
		      f = frag_var (rs_machine_dependent, 8, 6, SUBYPTE_COND_9_17_22_32,
				    fixups[0].exp.X_add_symbol,
				    fixups[0].exp.X_add_number,
				    (char *)(size_t) fixups[0].opindex);
		      md_number_to_chars (f, insn, insn_size);
		      md_number_to_chars (f + 2, 0, 6);
		    }
		}
	      else
		{
		  if (strcmp (opcode->name, "bsa") == 0)
		    {
		      f = frag_var (rs_machine_dependent, 10, 8, SUBYPTE_SA_9_22_32,
				    fixups[0].exp.X_add_symbol,
				    fixups[0].exp.X_add_number,
				    (char *)(size_t) fixups[0].opindex);
		      md_number_to_chars (f, insn, insn_size);
		      md_number_to_chars (f + 2, 0, 8);
		    }
		  else
		    {
		      f = frag_var (rs_machine_dependent, 8, 6, SUBYPTE_COND_9_22_32,
				    fixups[0].exp.X_add_symbol,
				    fixups[0].exp.X_add_number,
				    (char *)(size_t) fixups[0].opindex);
		      md_number_to_chars (f, insn, insn_size);
		      md_number_to_chars (f + 2, 0, 6);
		    }
		}
	    }
	}
    }
  else
    {
      /* Four byte insns have an opcode with the two high bits on.  */
      if ((insn & 0x0600) == 0x0600)
	insn_size = 4;
      else
	insn_size = 2;

      /* Special case: 32 bit MOV.  */
      if ((insn & 0xffe0) == 0x0620)
	insn_size = 2;

      /* Special case: 32 bit JARL,JMP,JR.  */
      if ((insn & 0x1ffe0) == 0x2e0	/* JARL.  */
	  || (insn & 0x1ffe0) == 0x6e0	/* JMP.  */
	  || (insn & 0x1ffff) == 0x2e0)	/* JR.  */
	insn_size = 2;

      if (obstack_room (& frchain_now->frch_obstack) < (insn_size + extra_data_len))
	{
          frag_wane (frag_now);
          frag_new (0);
	}

      f = frag_more (insn_size);
      md_number_to_chars (f, insn, insn_size);

      if (extra_data_after_insn)
	{
	  f = frag_more (extra_data_len);
	  md_number_to_chars (f, extra_data, extra_data_len);

	  extra_data_after_insn = FALSE;
	}
    }

  /* Create any fixups.  At this point we do not use a
     bfd_reloc_code_real_type, but instead just use the
     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
     handle fixups for any operand type, although that is admittedly
     not a very exciting feature.  We pick a BFD reloc type in
     md_apply_fix.  */
  for (i = 0; i < fc; i++)
    {
      const struct v850_operand *operand;
      bfd_reloc_code_real_type reloc;

      operand = &v850_operands[fixups[i].opindex];

      reloc = fixups[i].reloc;

      if (reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto =
	    bfd_reloc_type_lookup (stdoutput, reloc);
	  int size;
	  int address;
	  fixS *fixP;

	  if (!reloc_howto)
	    abort ();

	  size = bfd_get_reloc_size (reloc_howto);

	  /* XXX This will abort on an R_V850_8 reloc -
	     is this reloc actually used?  */
	  if (size != 2 && size != 4)
	    abort ();

	  if (extra_data_len == 0)
	    {
	      address = (f - frag_now->fr_literal) + insn_size - size;
	    }
	  else
	    {
	      address = (f - frag_now->fr_literal) + extra_data_len - size;
	    }

	  if ((operand->flags & V850E_IMMEDIATE32) && (operand->flags & V850_PCREL))
	    {
	      fixups[i].exp.X_add_number += 2;
	    }
	  else if (operand->default_reloc ==  BFD_RELOC_V850_16_PCREL)
	    {
	      fixups[i].exp.X_add_number += 2;
	      address += 2;
	    }

	  /* fprintf (stderr, "0x%x %d %ld\n", address, size, fixups[i].exp.X_add_number);  */
	  fixP = fix_new_exp (frag_now, address, size,
			      &fixups[i].exp,
			      reloc_howto->pc_relative,
			      reloc);

	  fixP->tc_fix_data = (void *) operand;

	  switch (reloc)
	    {
	    case BFD_RELOC_LO16:
	    case BFD_RELOC_V850_LO16_S1:
	    case BFD_RELOC_V850_LO16_SPLIT_OFFSET:
	    case BFD_RELOC_HI16:
	    case BFD_RELOC_HI16_S:
	      fixP->fx_no_overflow = 1;
	      break;
	    default:
	      break;
	    }
	}
      else
	{
	  gas_assert (f != NULL);
	  fix_new_exp (frag_now,
		       f - frag_now->fr_literal, 4,
		       & fixups[i].exp,
		       (operand->flags & V850_PCREL) != 0,
		       (bfd_reloc_code_real_type) (fixups[i].opindex
						   + (int) BFD_RELOC_UNUSED));
	}
    }

  input_line_pointer = saved_input_line_pointer;
}

/* If while processing a fixup, a reloc really needs to be created
   then it is done here.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;

  reloc		      = xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr  = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address      = fixp->fx_frag->fr_address + fixp->fx_where;

  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_V850_LONGCALL
      || fixp->fx_r_type == BFD_RELOC_V850_LONGJUMP
      || fixp->fx_r_type == BFD_RELOC_V850_ALIGN)
    reloc->addend = fixp->fx_offset;
  else
    {
#if 0
      if (fixp->fx_r_type == BFD_RELOC_32
	  && fixp->fx_pcrel)
	fixp->fx_r_type = BFD_RELOC_32_PCREL;
#endif

      reloc->addend = fixp->fx_addnumber;
    }

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    /* xgettext:c-format  */
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);

      xfree (reloc);

      return NULL;
    }

  return reloc;
}

void
v850_handle_align (fragS * frag)
{
  if (v850_relax
      && frag->fr_type == rs_align
      && frag->fr_address + frag->fr_fix > 0
      && frag->fr_offset > 1
      && now_seg != bss_section
      && now_seg != v850_seg_table[SBSS_SECTION].s
      && now_seg != v850_seg_table[TBSS_SECTION].s
      && now_seg != v850_seg_table[ZBSS_SECTION].s)
    fix_new (frag, frag->fr_fix, 2, & abs_symbol, frag->fr_offset, 0,
	     BFD_RELOC_V850_ALIGN);
}

/* Return current size of variable part of frag.  */

int
md_estimate_size_before_relax (fragS *fragp, asection *seg ATTRIBUTE_UNUSED)
{
  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
}

long
v850_pcrel_from_section (fixS *fixp, segT section)
{
  /* If the symbol is undefined, or in a section other than our own,
     or it is weak (in which case it may well be in another section,
     then let the linker figure it out.  */
  if (fixp->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixp->fx_addsy)
	  || S_IS_WEAK (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != section)))
    return 0;

  return fixp->fx_frag->fr_address + fixp->fx_where;
}

void
md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)
{
  valueT value = * valueP;
  char *where;

  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_V850_LONGCALL
      || fixP->fx_r_type == BFD_RELOC_V850_LONGJUMP
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    {
      fixP->fx_done = 0;
      return;
    }

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_addnumber = value,
    fixP->fx_done = 1;

  else if (fixP->fx_pcrel)
    fixP->fx_addnumber = fixP->fx_offset;

  else
    {
      value = fixP->fx_offset;
      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    /* We don't actually support subtracting a symbol.  */
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("expression too complex"));
	}
      fixP->fx_addnumber = value;
    }

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex;
      const struct v850_operand *operand;
      unsigned long insn;
      const char *errmsg = NULL;

      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
      operand = &v850_operands[opindex];

      /* Fetch the instruction, insert the fully resolved operand
	 value, and stuff the instruction back again.

	 Note the instruction has been stored in little endian
	 format!  */
      where = fixP->fx_frag->fr_literal + fixP->fx_where;

      if (fixP->fx_size > 2)
	insn = bfd_getl32 ((unsigned char *) where);
      else
	insn = bfd_getl16 ((unsigned char *) where);

      /* When inserting loop offets a backwards displacement
	 is encoded as a positive value.  */
      if (operand->flags & V850_INVERSE_PCREL)
	value = - value;

      insn = v850_insert_operand (insn, operand, (offsetT) value,
				  &errmsg);
      if (errmsg)
	as_warn_where (fixP->fx_file, fixP->fx_line, "%s", errmsg);

      if (fixP->fx_size > 2)
	bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
      else
	bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);

      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;

      /* Determine a BFD reloc value based on the operand information.
	 We are only prepared to turn a few of the operands into relocs.  */

      if (operand->default_reloc == BFD_RELOC_NONE)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("unresolved expression that must be resolved"));
	  fixP->fx_done = 1;
	  return;
	}

      {
	fixP->fx_r_type = operand->default_reloc;
	if (operand->default_reloc ==  BFD_RELOC_V850_16_PCREL)
	  {
	    fixP->fx_where += 2;
	    fixP->fx_size = 2;
	    fixP->fx_addnumber += 2;
	  }
      }
    }
  else if (fixP->fx_done)
    {
      /* We still have to insert the value into memory!  */
      where = fixP->fx_frag->fr_literal + fixP->fx_where;

      if (fixP->tc_fix_data != NULL
          && ((struct v850_operand *) fixP->tc_fix_data)->insert != NULL)
        {
          const char * message = NULL;
          struct v850_operand * operand = (struct v850_operand *) fixP->tc_fix_data;
          unsigned long insn;

          /* The variable "where" currently points at the exact point inside
             the insn where we need to insert the value.  But we need to
             extract the entire insn so we probably need to move "where"
             back a few bytes.  */

          if (fixP->fx_size == 2)
            where -= 2;
          else if (fixP->fx_size == 1)
            where -= 3;

          insn = bfd_getl32 ((unsigned char *) where);

          /* Use the operand's insertion procedure, if present, in order to
             make sure that the value is correctly stored in the insn.  */
          insn = operand->insert (insn, (offsetT) value, & message);
          /* Ignore message even if it is set.  */

          bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
        }
      else
        {
	  switch (fixP->fx_r_type)
	    {
	    case BFD_RELOC_V850_32_ABS:
	    case BFD_RELOC_V850_32_PCREL:
	      bfd_putl32 (value & 0xfffffffe, (unsigned char *) where);
	      break;

	    case BFD_RELOC_32:
	      bfd_putl32 (value, (unsigned char *) where);
	      break;

	    case BFD_RELOC_V850_23:
	      bfd_putl32 (((value & 0x7f) << 4) | ((value & 0x7fff80) << (16-7))
			  | (bfd_getl32 (where) & ~((0x7f << 4) | (0xffff << 16))),
			  (unsigned char *) where);
	    break;

	    case BFD_RELOC_16:
	    case BFD_RELOC_HI16:
	    case BFD_RELOC_HI16_S:
	    case BFD_RELOC_LO16:
	    case BFD_RELOC_V850_ZDA_16_16_OFFSET:
	    case BFD_RELOC_V850_SDA_16_16_OFFSET:
	    case BFD_RELOC_V850_TDA_16_16_OFFSET:
	    case BFD_RELOC_V850_CALLT_16_16_OFFSET:
	      bfd_putl16 (value & 0xffff, (unsigned char *) where);
	      break;

	    case BFD_RELOC_8:
	      *where = value & 0xff;
	      break;

	    case BFD_RELOC_V850_9_PCREL:
	      bfd_putl16 (((value & 0x1f0) << 7) | ((value & 0x0e) << 3)
			  | (bfd_getl16 (where) & ~((0x1f0 << 7) | (0x0e << 3))), where);
	      break;

	    case BFD_RELOC_V850_17_PCREL:
	      bfd_putl32 (((value & 0x10000) >> (16 - 4)) | ((value & 0xfffe) << 16)
			  | (bfd_getl32 (where) & ~((0x10000 >> (16 - 4)) | (0xfffe << 16))), where);
	      break;

	    case BFD_RELOC_V850_16_PCREL:
	      bfd_putl16 ((-value & 0xfffe) | (bfd_getl16 (where + 2) & 0x0001),
			  (unsigned char *) (where + 2));
	      break;

	    case BFD_RELOC_V850_22_PCREL:
	      bfd_putl32 (((value & 0xfffe) << 16) | ((value & 0x3f0000) >> 16)
			  | (bfd_getl32 (where) & ~((0xfffe << 16) | (0x3f0000 >> 16))), where);
	      break;

	    case BFD_RELOC_V850_16_S1:
	    case BFD_RELOC_V850_LO16_S1:
	    case BFD_RELOC_V850_ZDA_15_16_OFFSET:
	    case BFD_RELOC_V850_SDA_15_16_OFFSET:
	      bfd_putl16 (value & 0xfffe, (unsigned char *) where);
	      break;

	    case BFD_RELOC_V850_16_SPLIT_OFFSET:
	    case BFD_RELOC_V850_LO16_SPLIT_OFFSET:
	    case BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET:
	    case BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET:
	      bfd_putl32 (((value << 16) & 0xfffe0000)
			  | ((value << 5) & 0x20)
			  | (bfd_getl32 (where) & ~0xfffe0020), where);
	      break;

	    case BFD_RELOC_V850_TDA_6_8_OFFSET:
	      *where = (*where & ~0x7e) | ((value >> 1) & 0x7e);
	      break;

	    case BFD_RELOC_V850_TDA_7_8_OFFSET:
	      *where = (*where & ~0x7f) | ((value >> 1) & 0x7f);
	      break;

	    case BFD_RELOC_V850_TDA_7_7_OFFSET:
	      *where = (*where & ~0x7f) | (value & 0x7f);
	      break;

	    case BFD_RELOC_V850_TDA_4_5_OFFSET:
	      *where = (*where & ~0xf) | ((value >> 1) & 0xf);
	      break;

	    case BFD_RELOC_V850_TDA_4_4_OFFSET:
	      *where = (*where & ~0xf) | (value & 0xf);
	      break;

	    case BFD_RELOC_V850_CALLT_6_7_OFFSET:
	      *where = (*where & ~0x3f) | (value & 0x3f);
	      break;

	    default:
	      abort ();
	    }
        }
    }
}

/* Parse a cons expression.  We have to handle hi(), lo(), etc
   on the v850.  */

void
parse_cons_expression_v850 (expressionS *exp)
{
  const char *errmsg;
  /* See if there's a reloc prefix like hi() we have to handle.  */
  hold_cons_reloc = v850_reloc_prefix (NULL, &errmsg);

  /* Do normal expression parsing.  */
  expression (exp);
}

/* Create a fixup for a cons expression.  If parse_cons_expression_v850
   found a reloc prefix, then we use that reloc, else we choose an
   appropriate one based on the size of the expression.  */

void
cons_fix_new_v850 (fragS *frag,
		   int where,
		   int size,
		   expressionS *exp)
{
  if (hold_cons_reloc == BFD_RELOC_UNUSED)
    {
      if (size == 4)
	hold_cons_reloc = BFD_RELOC_32;
      if (size == 2)
	hold_cons_reloc = BFD_RELOC_16;
      if (size == 1)
	hold_cons_reloc = BFD_RELOC_8;
    }

  if (exp != NULL)
    fix_new_exp (frag, where, size, exp, 0, hold_cons_reloc);
  else
    fix_new (frag, where, size, NULL, 0, 0, hold_cons_reloc);

  hold_cons_reloc = BFD_RELOC_UNUSED;
}

bfd_boolean
v850_fix_adjustable (fixS *fixP)
{
  if (fixP->fx_addsy == NULL)
    return 1;

  /* Don't adjust function names.  */
  if (S_IS_FUNCTION (fixP->fx_addsy))
    return 0;

  /* We need the symbol name for the VTABLE entries.  */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}

int
v850_force_relocation (struct fix *fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_V850_LONGCALL
      || fixP->fx_r_type == BFD_RELOC_V850_LONGJUMP)
    return 1;

  if (v850_relax
      && (fixP->fx_pcrel
	  || fixP->fx_r_type == BFD_RELOC_V850_ALIGN
	  || fixP->fx_r_type == BFD_RELOC_V850_9_PCREL
	  || fixP->fx_r_type == BFD_RELOC_V850_16_PCREL
	  || fixP->fx_r_type == BFD_RELOC_V850_17_PCREL
	  || fixP->fx_r_type == BFD_RELOC_V850_22_PCREL
	  || fixP->fx_r_type == BFD_RELOC_V850_32_PCREL
	  || fixP->fx_r_type >= BFD_RELOC_UNUSED))
    return 1;

  return generic_force_reloc (fixP);
}
@


1.63
log
@Add support for V850E3V5 architecture
@
text
@d3462 5
@


1.62
log
@	* config/tc-v850.c (md_assemble): Allow signed values for
	V850E_IMMEDIATE.

	* gas/v850/basic.exp: Allow for variations in reloc names.
	* gas/v850/split-lo16.d: Likewise.

	* gas/v850/v850e1.s: Add more tests of the PREPARE insn.
	* gas/v850/v850e1.d: Update expected disassembly.

	* v850-dis.c (get_operand_value): Sign extend V850E_IMMEDIATE
	values.
	* v850-opc.c (IMM16LO): Add V850_OPERAND_SIGNED attribute.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2009, 2010, 2011, 2012  Free Software Foundation, Inc.
d129 4
d534 1
d595 2
d660 2
a661 2
  { "bsel",        31, PROCESSOR_V850E2_ALL },
  { "cfg",          7, PROCESSOR_V850E2V3 },
d665 1
a665 1
  { "dbic",        15, PROCESSOR_V850E2_ALL },
d668 1
a668 1
  { "dbwr",        30, PROCESSOR_V850E2_ALL },
d670 12
a681 12
  { "dpa0l",       16, PROCESSOR_V850E2V3 },
  { "dpa0u",       17, PROCESSOR_V850E2V3 },
  { "dpa1l",       18, PROCESSOR_V850E2V3 },
  { "dpa1u",       19, PROCESSOR_V850E2V3 },
  { "dpa2l",       20, PROCESSOR_V850E2V3 },
  { "dpa2u",       21, PROCESSOR_V850E2V3 },
  { "dpa3l",       22, PROCESSOR_V850E2V3 },
  { "dpa3u",       23, PROCESSOR_V850E2V3 },
  { "dpa4l",       24, PROCESSOR_V850E2V3 },
  { "dpa4u",       25, PROCESSOR_V850E2V3 },
  { "dpa5l",       26, PROCESSOR_V850E2V3 },
  { "dpa5u",       27, PROCESSOR_V850E2V3 },
d683 4
a686 4
  { "eh_base",      3, PROCESSOR_V850E2V3 },
  { "eh_cfg",       1, PROCESSOR_V850E2V3 },
  { "eh_reset",     2, PROCESSOR_V850E2V3 },
  { "eiic",        13, PROCESSOR_V850E2_ALL },
d689 2
a690 2
  { "eiwr",        28, PROCESSOR_V850E2_ALL },
  { "feic",        14, PROCESSOR_V850E2_ALL },
d693 55
a747 55
  { "fewr",        29, PROCESSOR_V850E2_ALL },
  { "fpcc",         9, PROCESSOR_V850E2V3 },
  { "fpcfg",       10, PROCESSOR_V850E2V3 },
  { "fpec",        11, PROCESSOR_V850E2V3 },
  { "fpepc",        7, PROCESSOR_V850E2V3 },
  { "fpspc",       27, PROCESSOR_V850E2V3 },
  { "fpsr",         6, PROCESSOR_V850E2V3 },
  { "fpst",         8, PROCESSOR_V850E2V3 },
  { "ipa0l",        6, PROCESSOR_V850E2V3 },
  { "ipa0u",        7, PROCESSOR_V850E2V3 },
  { "ipa1l",        8, PROCESSOR_V850E2V3 },
  { "ipa1u",        9, PROCESSOR_V850E2V3 },
  { "ipa2l",       10, PROCESSOR_V850E2V3 },
  { "ipa2u",       11, PROCESSOR_V850E2V3 },
  { "ipa3l",       12, PROCESSOR_V850E2V3 },
  { "ipa3u",       13, PROCESSOR_V850E2V3 },
  { "ipa4l",       14, PROCESSOR_V850E2V3 },
  { "ipa4u",       15, PROCESSOR_V850E2V3 },
  { "mca",         24, PROCESSOR_V850E2V3 },
  { "mcc",         26, PROCESSOR_V850E2V3 },
  { "mcr",         27, PROCESSOR_V850E2V3 },
  { "mcs",         25, PROCESSOR_V850E2V3 },
  { "mpc",          1, PROCESSOR_V850E2V3 },
  { "mpm",          0, PROCESSOR_V850E2V3 },
  { "mpu10_dpa0l", 16, PROCESSOR_V850E2V3 },
  { "mpu10_dpa0u", 17, PROCESSOR_V850E2V3 },
  { "mpu10_dpa1l", 18, PROCESSOR_V850E2V3 },
  { "mpu10_dpa1u", 19, PROCESSOR_V850E2V3 },
  { "mpu10_dpa2l", 20, PROCESSOR_V850E2V3 },
  { "mpu10_dpa2u", 21, PROCESSOR_V850E2V3 },
  { "mpu10_dpa3l", 22, PROCESSOR_V850E2V3 },
  { "mpu10_dpa3u", 23, PROCESSOR_V850E2V3 },
  { "mpu10_dpa4l", 24, PROCESSOR_V850E2V3 },
  { "mpu10_dpa4u", 25, PROCESSOR_V850E2V3 },
  { "mpu10_dpa5l", 26, PROCESSOR_V850E2V3 },
  { "mpu10_dpa5u", 27, PROCESSOR_V850E2V3 },
  { "mpu10_ipa0l",  6, PROCESSOR_V850E2V3 },
  { "mpu10_ipa0u",  7, PROCESSOR_V850E2V3 },
  { "mpu10_ipa1l",  8, PROCESSOR_V850E2V3 },
  { "mpu10_ipa1u",  9, PROCESSOR_V850E2V3 },
  { "mpu10_ipa2l", 10, PROCESSOR_V850E2V3 },
  { "mpu10_ipa2u", 11, PROCESSOR_V850E2V3 },
  { "mpu10_ipa3l", 12, PROCESSOR_V850E2V3 },
  { "mpu10_ipa3u", 13, PROCESSOR_V850E2V3 },
  { "mpu10_ipa4l", 14, PROCESSOR_V850E2V3 },
  { "mpu10_ipa4u", 15, PROCESSOR_V850E2V3 },
  { "mpu10_mpc",    1, PROCESSOR_V850E2V3 },
  { "mpu10_mpm",    0, PROCESSOR_V850E2V3 },
  { "mpu10_tid",    2, PROCESSOR_V850E2V3 },
  { "mpu10_vmadr",  5, PROCESSOR_V850E2V3 },
  { "mpu10_vmecr",  3, PROCESSOR_V850E2V3 },
  { "mpu10_vmtid",  4, PROCESSOR_V850E2V3 },
  { "pid",          6, PROCESSOR_V850E2V3 },
  { "pmcr0",        4, PROCESSOR_V850E2V3 },
  { "pmis2",       14, PROCESSOR_V850E2V3 },
d749 2
a750 2
  { "scbp",        12, PROCESSOR_V850E2V3 },
  { "sccfg",       11, PROCESSOR_V850E2V3 },
d783 10
a792 10
  { "sw_base",      3, PROCESSOR_V850E2V3 },
  { "sw_cfg",       1, PROCESSOR_V850E2V3 },
  { "sw_ctl",       0, PROCESSOR_V850E2V3 },
  { "tid",          2, PROCESSOR_V850E2V3 },
  { "vmadr",        6, PROCESSOR_V850E2V3 },
  { "vmecr",        4, PROCESSOR_V850E2V3 },
  { "vmtid",        5, PROCESSOR_V850E2V3 },
  { "vsadr",        2, PROCESSOR_V850E2V3 },
  { "vsecr",        0, PROCESSOR_V850E2V3 },
  { "vstid",        1, PROCESSOR_V850E2V3 },
d831 32
a862 32
  { "eq",  0x2, PROCESSOR_V850E2V3 },	/* true.  */
  { "f",   0x0, PROCESSOR_V850E2V3 },	/* true.  */
  { "ge",  0xd, PROCESSOR_V850E2V3 },	/* false.  */
  { "gl",  0xb, PROCESSOR_V850E2V3 },	/* false.  */
  { "gle", 0x9, PROCESSOR_V850E2V3 },	/* false.  */
  { "gt",  0xf, PROCESSOR_V850E2V3 },	/* false.  */
  { "le",  0xe, PROCESSOR_V850E2V3 },	/* true.  */
  { "lt",  0xc, PROCESSOR_V850E2V3 },	/* true.  */
  { "neq", 0x2, PROCESSOR_V850E2V3 },	/* false.  */
  { "nge", 0xd, PROCESSOR_V850E2V3 },	/* true.  */
  { "ngl", 0xb, PROCESSOR_V850E2V3 },	/* true.  */
  { "ngle",0x9, PROCESSOR_V850E2V3 },	/* true.  */
  { "ngt", 0xf, PROCESSOR_V850E2V3 },	/* true.  */
  { "nle", 0xe, PROCESSOR_V850E2V3 },	/* false.  */
  { "nlt", 0xc, PROCESSOR_V850E2V3 },	/* false.  */
  { "oge", 0x5, PROCESSOR_V850E2V3 },	/* false.  */
  { "ogl", 0x3, PROCESSOR_V850E2V3 },	/* false.  */
  { "ogt", 0x7, PROCESSOR_V850E2V3 },	/* false.  */
  { "ole", 0x6, PROCESSOR_V850E2V3 },	/* true.  */
  { "olt", 0x4, PROCESSOR_V850E2V3 },	/* true.  */
  { "or",  0x1, PROCESSOR_V850E2V3 },	/* false.  */
  { "seq", 0xa, PROCESSOR_V850E2V3 },	/* true.  */
  { "sf",  0x8, PROCESSOR_V850E2V3 },	/* true.  */
  { "sne", 0xa, PROCESSOR_V850E2V3 },	/* false.  */
  { "st",  0x8, PROCESSOR_V850E2V3 },	/* false.  */
  { "t",   0x0, PROCESSOR_V850E2V3 },	/* false.  */
  { "ueq", 0x3, PROCESSOR_V850E2V3 },	/* true.  */
  { "uge", 0x4, PROCESSOR_V850E2V3 },	/* false.  */
  { "ugt", 0x6, PROCESSOR_V850E2V3 },	/* false.  */
  { "ule", 0x7, PROCESSOR_V850E2V3 },	/* true.  */
  { "ult", 0x5, PROCESSOR_V850E2V3 },	/* true.  */
  { "un",  0x1, PROCESSOR_V850E2V3 },	/* true.  */
d868 70
d1213 137
d1554 2
d1617 10
d1692 23
d1716 1
a1716 1
  if (fragP->fr_subtype == SUBYPTE_COND_9_22
d1885 17
a1901 1
  if (strncmp (TARGET_CPU, "v850e2v3", 8) == 0)
d2396 6
d2479 1
a2479 2
		      fprintf (stderr, "reloc: %d\n", reloc);
		      as_bad (_("AAARG -> unhandled constant reloc"));
d2622 2
a2623 2
		      if ((ex.X_add_number & 0xffff0000)
			  && ((ex.X_add_number & 0xffff0000) != 0xffff0000))
d2812 15
d2890 5
d2929 12
d3057 19
a3075 2
      if (strcmp (opcode->name, "br") == 0
	  || strcmp (opcode->name, "jbr") == 0)
d3077 1
a3077 1
	  if ((processor_mask & PROCESSOR_V850E2_ALL) == 0 || default_disp_size == 22)
d3099 1
a3099 1
	      || (processor_mask & PROCESSOR_V850E2_ALL) == 0)
d3101 1
a3101 1
	      if (processor_mask & PROCESSOR_V850E2V3 && !no_bcond17)
d3146 1
a3146 1
	      if (processor_mask & PROCESSOR_V850E2V3 && !no_bcond17)
d3209 6
d3302 1
@


1.61
log
@2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* Makefile.am (ALL_MACHINES): Add cpu-v850-rh850.lo.
	(ALL_MACHINES_CFILES): Add cpu-v850-rh850.c.
	* archures.c (bfd_arch_info): Add bfd_v850_rh850_arch.
	* config.bfd: Likewise.
	* configure.in: Add bfd_elf32_v850_rh850_vec.
	* cpu-v850.c: Update printed description.
	* cpu-v850_rh850.c: New file.
	* elf32-v850.c (v850_elf_check_relocs): Add support for RH850 ABI
	relocs.
	(v850_elf_perform_relocation): Likewise.
	(v850_elf_final_link_relocate): Likewise.
	(v850_elf_relocate_section): Likewise.
	(v850_elf_relax_section): Likewise.
	(v800_elf_howto_table): New.
	(v850_elf_object_p): Add support for RH850 ABI values.
	(v850_elf_final_write_processing): Likewise.
	(v850_elf_merge_private_bfd_data): Likewise.
	(v850_elf_print_private_bfd_data): Likewise.
	(v800_elf_reloc_map): New.
	(v800_elf_reloc_type_lookup): New.
	(v800_elf_reloc_name_lookup): New.
	(v800_elf_info_to_howto): New.
	(bfd_elf32_v850_rh850_vec): New.
	(bfd_arch_v850_rh850): New.
	* targets.c (_bfd_targets): Add bfd_elf32_v850_rh850_vec.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.

	* readelf.c (get_machine_flags): Add support for E_FLAG_RX_ABI.
	(guess_is_rela): Add EM_V800.
	(dump_relocations): Likewise.
	(get_machine_name): Update EM_V800.
	(get_machine_flags): Add support for RH850 ABI flags.
	(is_32bit_abs_reloc): Add support for RH850 ABI reloc.

	* config/tc-v850.c (v850_target_arch): New.
	(v850_target_format): New.
	(set_machine): Use v850_target_arch.
	(md_begin): Likewise.
	(md_show_usage): Document new switches.
	(md_parse_option): Add -mgcc-abi, -mrh850-abi, -m8byte-align and
	-m4byte-align.
	* config/tc-v850.c (TARGET_ARCH) Use v850_target_arch.
	(TARGET_FORMAT): Use v850_target_format.
	* doc/c-v850.texi: Document new options.

	* v850.h: Add RH850 ABI values.

	* Makefile.am: (ALL_EMULATION_SOURCES): Add ev850_rh850.c.
	* Makefile.in: Regenerate.
	* configure.tgt (v850*-*-*): Make v850_rh850 the default
	emulation. Add vanilla v850 as an extra emulation.
	* emulparams/v850_rh850.sh: New file.
	* scripttempl/v850_rh850.sc: New file.

	* configure.in: Add bfd_v850_rh850_arch.
	* configure: Regenerate.
	* disassemble.c (disassembler): Likewise.
@
text
@d2353 2
a2354 1
		      if (ex.X_add_number & 0xffff0000)
@


1.60
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2010, 2011  Free Software Foundation, Inc.
d41 6
d521 1
a521 1
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);
d1347 4
d1416 14
d1700 2
a1701 1
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);
d2024 1
a2024 1
  char *f;
d3247 2
a3248 1
	      bfd_putl16 (-value & 0xfffe, (unsigned char *) where);
@


1.59
log
@	* v850-dis.c (disassemble): Place square parentheses around second
	register operand of clr1, not1, set1 and tst1 instructions.

	* config/tc-v850.c (v850_insert_operand): Use a static buffer for
	the error message.

	* gas/v850/v850e1.d: Fix expected disassembly of clr1, not1, set1
	and tst1 insns.
@
text
@d1394 1
a1394 1
      processor_mask |= PROCESSOR_OPTION_EXTENSION | PROCESSOR_OPTION_ALIAS;;
@


1.58
log
@	PR gas/12755
	* config/tc-v850.c (parse_register_list): Correct error string.
@
text
@d1958 1
a1958 1
	      char buf [128];
@


1.57
log
@	* config/tc-v850.c (md_assemble): Always pass format string to
	as_warn.
	(md_apply_fix): Similarly for as_warn_where.
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2010  Free Software Foundation, Inc.
d1279 1
a1279 1
	      return _("second register should greater tahn first register");
@


1.57.2.1
log
@	PR gas/12755
	* config/tc-v850.c (parse_register_list): Correct error string.
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2010, 2011  Free Software Foundation, Inc.
d1279 1
a1279 1
	      return _("second register should be greater than first register");
@


1.56
log
@Add support for v850E2 and v850E2V3
@
text
@d2712 1
a2712 1
	as_warn (warningmsg);
d3114 1
a3114 1
	as_warn_where (fixP->fx_file, fixP->fx_line, errmsg);
@


1.55
log
@2010-03-13  Segher Boessenkool  <segher@@kernel.crashing.org>

        * config/tc-v850.c (v850_insert_operand): Handle out-of-range
        assembler constants on 64-bit hosts.
@
text
@d3 1
a3 1
   2006, 2007, 2009  Free Software Foundation, Inc.
d42 1
a42 1
static int processor_mask = -1;
d49 1
d75 49
a123 6
  /* Conditional branches.  */
  {0xff,     -0x100,    2, 1},
  {0x1fffff, -0x200000, 6, 0},
  /* Unconditional branches.  */
  {0xff,     -0x100,    2, 3},
  {0x1fffff, -0x200000, 4, 0},
d126 10
a135 1
static int  v850_relax = 0;
d519 6
a524 3
    case 0:		  processor_mask = PROCESSOR_V850;   break;
    case bfd_mach_v850e:  processor_mask = PROCESSOR_V850E;  break;
    case bfd_mach_v850e1: processor_mask = PROCESSOR_V850E;  break;
d582 3
a584 1
  { "v850e1",		set_machine,		bfd_mach_v850e1 	},
d596 39
a634 39
  { "ep",  30 },		/* ep - element ptr.  */
  { "gp",   4 },		/* gp - global ptr.  */
  { "hp",   2 },		/* hp - handler stack ptr.  */
  { "lp",  31 },		/* lp - link ptr.  */
  { "r0",   0 },
  { "r1",   1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r16", 16 },
  { "r17", 17 },
  { "r18", 18 },
  { "r19", 19 },
  { "r2",   2 },
  { "r20", 20 },
  { "r21", 21 },
  { "r22", 22 },
  { "r23", 23 },
  { "r24", 24 },
  { "r25", 25 },
  { "r26", 26 },
  { "r27", 27 },
  { "r28", 28 },
  { "r29", 29 },
  { "r3",   3 },
  { "r30", 30 },
  { "r31", 31 },
  { "r4",   4 },
  { "r5",   5 },
  { "r6",   6 },
  { "r7",   7 },
  { "r8",   8 },
  { "r9",   9 },
  { "sp",   3 },		/* sp - stack ptr.  */
  { "tp",   5 },		/* tp - text ptr.  */
  { "zero", 0 },
d642 139
a780 18
  { "asid",  23 },
  { "bpc",   22 },
  { "bpav",  24 },
  { "bpam",  25 },
  { "bpdv",  26 },
  { "bpdm",  27 },
  { "ctbp",  20 },
  { "ctpc",  16 },
  { "ctpsw", 17 },
  { "dbpc",  18 },
  { "dbpsw", 19 },
  { "dir",   21 },
  { "ecr",    4 },
  { "eipc",   0 },
  { "eipsw",  1 },
  { "fepc",   2 },
  { "fepsw",  3 },
  { "psw",    5 },
d786 2
a787 1
static const struct reg_name system_list_registers[] =
d789 23
a811 2
  {"PS",      5 },
  {"SR",      0 + 1}
d814 2
a815 2
#define SYSREGLIST_NAME_CNT					\
  (sizeof (system_list_registers) / sizeof (struct reg_name))
d817 1
a817 1
static const struct reg_name cc_names[] =
d819 32
a850 22
  { "c",  0x1 },
  { "e",  0x2 },
  { "ge", 0xe },
  { "gt", 0xf },
  { "h",  0xb },
  { "l",  0x1 },
  { "le", 0x7 },
  { "lt", 0x6 },
  { "n",  0x4 },
  { "nc", 0x9 },
  { "ne", 0xa },
  { "nh", 0x3 },
  { "nl", 0x9 },
  { "ns", 0xc },
  { "nv", 0x8 },
  { "nz", 0xa },
  { "p",  0xc },
  { "s",  0x4 },
  { "sa", 0xd },
  { "t",  0x5 },
  { "v",  0x0 },
  { "z",  0x2 },
d853 2
a854 2
#define CC_NAME_CNT					\
  (sizeof (cc_names) / sizeof (struct reg_name))
d881 1
a881 3

	  if (reg >= 0 && reg <= 31)
	    return reg;
d899 3
a901 1
	return regs[middle].value;
d936 3
a944 4
      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol  = NULL;

a946 4
  else
    {
      /* Reset the line as if we had not done anything.  */
      input_line_pointer = start;
d948 6
a953 2
      return FALSE;
    }
a960 2
	ACCEPT_LIST_NAMES is true iff the special names PS and SR may be
	accepted.
d970 1
a970 2
		      bfd_boolean accept_numbers,
		      bfd_boolean accept_list_names)
d995 1
a995 16
	  reg_number = strtol (input_line_pointer, &input_line_pointer, 10);

	  /* Make sure that the register number is allowable.  */
	  if (reg_number < 0
	      || (reg_number > 5 && reg_number < 16)
	      || reg_number > 27)
	    reg_number = -1;
	}
      else if (accept_list_names)
	{
	  c = get_symbol_end ();
	  reg_number = reg_name_search (system_list_registers,
					SYSREGLIST_NAME_CNT, name, FALSE);

	  /* Put back the delimiting char.  */
	  *input_line_pointer = c;
d999 3
a1007 4
      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol  = NULL;

a1009 4
  else
    {
      /* Reset the line as if we had not done anything.  */
      input_line_pointer = start;
d1011 6
a1016 2
      return FALSE;
    }
d1030 2
a1031 1
cc_name (expressionS *expressionP)
d1042 1
a1042 1
  reg_number = reg_name_search (cc_names, CC_NAME_CNT, name, FALSE);
d1047 15
a1067 4
      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol  = NULL;

d1070 30
a1099 1
  else
d1101 1
a1101 1
      /* Reset the line as if we had not done anything.  */
d1104 16
a1119 1
      return FALSE;
d1121 8
d1173 1
a1173 10
  static int type2_regs[32] =
  {
    19, 18, 17, 16,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0, 30, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24
  };
  static int type3_regs[32] =
  {
     3,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0, 14, 15, 13, 12,  7,  6,  5,  4, 11, 10,  9,  8
  };
a1180 2
    case 0xfff8000f: regs = type2_regs; break;
    case 0xfff8001f: regs = type3_regs; break;
a1213 35
      else if (regs == type2_regs)
	{
	  if (exp.X_add_number & 0xFFFE0000)
	    return _("high bits set in register list expression");

	  for (reg = 1; reg < 16; reg++)
	    if (exp.X_add_number & (1 << (reg - 1)))
	      {
		for (i = 0; i < 32; i++)
		  if (regs[i] == reg)
		    *insn |= (1 << i);
	      }

	  if (exp.X_add_number & (1 << 15))
	    *insn |= (1 << 3);

	  if (exp.X_add_number & (1 << 16))
	    *insn |= (1 << 19);
	}
      else /* regs == type3_regs  */
	{
	  if (exp.X_add_number & 0xFFFE0000)
	    return _("high bits set in register list expression");

	  for (reg = 16; reg < 32; reg++)
	    if (exp.X_add_number & (1 << (reg - 16)))
	      {
		for (i = 0; i < 32; i++)
		  if (regs[i] == reg)
		    *insn |= (1 << i);
	      }

	  if (exp.X_add_number & (1 << 16))
	    *insn |= (1 << 19);
	}
d1224 2
d1244 1
a1244 1
      else if (system_register_name (&exp, TRUE, TRUE))
a1249 11
	  else if (exp.X_add_number == 5)
	    {
	      if (regs == type2_regs)
		return _("PSW cannot be included in list");
	      else
		*insn |= 0x8;
	    }
	  else if (exp.X_add_number < 4)
	    *insn |= 0x80000;
	  else
	    return _("High value system registers cannot be included in list");
d1251 2
a1252 1
      else if (*input_line_pointer == '}')
d1275 5
a1279 1
	      exp2.X_add_number = exp.X_add_number;
d1301 2
a1305 2

      skip_white_space ();
d1315 4
d1333 2
a1334 1
  fprintf (stream, _("  -mv850any                 The code is generic, despite any processor specific instructions\n"));
d1336 5
d1347 13
a1359 1
    return 0;
d1370 1
a1370 1
      processor_mask = PROCESSOR_V850;
d1375 1
a1375 1
      processor_mask = PROCESSOR_V850E;
d1380 11
a1390 1
      processor_mask = PROCESSOR_V850E1;
d1392 1
a1392 1
  else if (strcmp (arg, "v850any") == 0)
d1394 9
a1402 6
      /* Tell the world that this is for any v850 chip.  */
      machine = 0;

      /* But support instructions for the extended versions.  */
      processor_mask = PROCESSOR_V850E;
      processor_mask |= PROCESSOR_V850E1;
a1430 7
  /* This code performs some nasty type punning between the
     fr_opcode field of the frag structure (a char *) and the
     fx_r_type field of the fix structure (a bfd_reloc_code_real_type)
     On a 64bit host this causes problems because these two fields
     are not the same size, but since we know that we are only
     ever storing small integers in the fields, it is safe to use
     a union to convert between them.  */
d1440 3
a1442 1
      
d1444 11
a1454 1
  if (fragP->fr_subtype == 0 || fragP->fr_subtype == 2)
d1461 25
a1485 2
  /* Out of range conditional branch.  Emit a branch around a jump.  */
  else if (fragP->fr_subtype == 1)
d1503 1
a1503 2
	       fragP->fr_offset, 1,
	       BFD_RELOC_UNUSED + opcode_converter.fx_r_type + 1);
d1506 26
a1531 2
  /* Out of range unconditional branch.  Emit a jump.  */
  else if (fragP->fr_subtype == 3)
d1535 33
d1569 26
a1594 2
	       BFD_RELOC_UNUSED + opcode_converter.fx_r_type + 1);
      fragP->fr_fix += 4;
d1613 17
a1629 1
  if (strncmp (TARGET_CPU, "v850e1", 6) == 0)
d1632 1
a1632 1
	machine = bfd_mach_v850e1;
d1634 2
a1635 2
      if (processor_mask == -1)
	processor_mask = PROCESSOR_V850E1;
d1642 2
a1643 2
      if (processor_mask == -1)
	processor_mask = PROCESSOR_V850E;
d1650 2
a1651 2
      if (processor_mask == -1)
	processor_mask = PROCESSOR_V850;
d1679 41
d1721 1
a1721 1
handle_lo16 (const struct v850_operand *operand)
d1723 14
a1736 4
  if (operand != NULL)
    {
      if (operand->bits == -1)
	return BFD_RELOC_V850_LO16_SPLIT_OFFSET;
d1738 3
a1740 9
      if (!(operand->bits == 16 && operand->shift == 16)
	  && !(operand->bits == 15 && operand->shift == 17))
	{
	  as_bad (_("lo() relocation used on an instruction which does "
		    "not support it"));
	  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
	}
    }
  return BFD_RELOC_LO16;
d1744 1
a1744 1
handle_ctoff (const struct v850_operand *operand)
d1749 8
a1756 6
  if (operand->bits != 6
      || operand->shift != 0)
    {
      as_bad (_("ctoff() relocation used on an instruction which does not support it"));
      return BFD_RELOC_64;  /* Used to indicate an error condition.  */
    }
d1758 2
a1759 1
  return BFD_RELOC_V850_CALLT_6_7_OFFSET;
d1763 1
a1763 1
handle_sdaoff (const struct v850_operand *operand)
d1768 2
a1769 2
  if (operand->bits == 15 && operand->shift == 17)
    return BFD_RELOC_V850_SDA_15_16_OFFSET;
d1771 2
a1772 2
  if (operand->bits == -1)
    return BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET;
d1774 2
a1775 6
  if (operand->bits != 16
      || operand->shift != 16)
    {
      as_bad (_("sdaoff() relocation used on an instruction which does not support it"));
      return BFD_RELOC_64;  /* Used to indicate an error condition.  */
    }
d1777 2
a1778 1
  return BFD_RELOC_V850_SDA_16_16_OFFSET;
d1782 1
a1782 1
handle_zdaoff (const struct v850_operand *operand)
d1787 2
a1788 2
  if (operand->bits == 15 && operand->shift == 17)
    return BFD_RELOC_V850_ZDA_15_16_OFFSET;
d1790 2
a1791 2
  if (operand->bits == -1)
    return BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET;
d1793 2
a1794 7
  if (operand->bits != 16
      || operand->shift != 16)
    {
      as_bad (_("zdaoff() relocation used on an instruction which does not support it"));
      /* Used to indicate an error condition.  */
      return BFD_RELOC_64;
    }
d1796 2
a1797 1
  return BFD_RELOC_V850_ZDA_16_16_OFFSET;
d1801 1
a1801 1
handle_tdaoff (const struct v850_operand *operand)
d1805 1
a1805 1
    return BFD_RELOC_V850_TDA_7_7_OFFSET;
d1807 6
a1812 1
  if (operand->bits == 6 && operand->shift == 1)
d1814 9
a1822 5
    return BFD_RELOC_V850_TDA_6_8_OFFSET;

  if (operand->bits == 4 && operand->insert != NULL)
    /* sld.hu, operand: D5-4.  */
    return BFD_RELOC_V850_TDA_4_5_OFFSET;
d1824 1
a1824 5
  if (operand->bits == 4 && operand->insert == NULL)
    /* sld.bu, operand: D4.   */
    return BFD_RELOC_V850_TDA_4_4_OFFSET;

  if (operand->bits == 16 && operand->shift == 16)
d1828 3
a1830 10
  if (operand->bits != 7)
    {
      as_bad (_("tdaoff() relocation used on an instruction which does not support it"));
      /* Used to indicate an error condition.  */
      return BFD_RELOC_64;
    }

  return  operand->insert != NULL
    ? BFD_RELOC_V850_TDA_7_8_OFFSET     /* sld.h/sst.h, operand: D8_7.  */
    : BFD_RELOC_V850_TDA_7_7_OFFSET;    /* sld.b/sst.b, operand: D7.    */
d1838 1
a1838 1
v850_reloc_prefix (const struct v850_operand *operand)
d1856 9
a1864 8
  CHECK_ ("hi0",    BFD_RELOC_HI16	   );
  CHECK_ ("hi",	    BFD_RELOC_HI16_S	   );
  CHECK_ ("lo",	    handle_lo16 (operand)  );
  CHECK_ ("sdaoff", handle_sdaoff (operand));
  CHECK_ ("zdaoff", handle_zdaoff (operand));
  CHECK_ ("tdaoff", handle_tdaoff (operand));
  CHECK_ ("hilo",   BFD_RELOC_32	   );
  CHECK_ ("ctoff",  handle_ctoff (operand) );
d1879 1
a1879 3
		     char *file,
		     unsigned int line,
		     char *str)
d1890 1
a1890 1
	      && strstr (message, "out of range") != NULL)
d1896 1
a1896 1
		   && strstr (message, "out of range") != NULL)
a1899 7
	  else if (str)
	    {
	      if (file == (char *) NULL)
		as_warn ("%s: %s", str, message);
	      else
		as_warn_where (file, line, "%s: %s", str, message);
	    }
d1902 2
a1903 4
	      if (file == (char *) NULL)
		as_warn ("%s", message);
	      else
		as_warn_where (file, line, "%s", message);
d1907 7
d1916 1
a1916 1
      if (operand->bits != 32)
d1969 4
a1972 5
	      if (str)
		sprintf (buf, "%s: ", str);
	      else
		buf[0] = 0;
	      strcat (buf, _("operand"));
d1974 5
a1978 2
	      as_bad_value_out_of_range (buf, val, (offsetT) min, (offsetT) max, file, line);
	    }
a1979 2

      insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
d2006 2
d2010 1
d2040 1
d2043 13
d2057 3
a2059 1
      if ((opcode->processors & processor_mask) == 0)
d2069 1
d2091 14
a2104 1
	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']')
d2115 1
a2115 1
	  if ((reloc = v850_reloc_prefix (operand)) != BFD_RELOC_UNUSED)
d2120 1
a2120 1
		  match = 1;
d2131 2
d2138 1
d2164 8
d2173 2
a2180 3
		      extra_data_after_insn = TRUE;
		      extra_data_len	    = 4;
		      extra_data	    = 0;
d2189 39
d2236 1
a2236 1
	      else
d2238 4
a2241 1
		  if (reloc == BFD_RELOC_32)
d2243 46
a2288 1
		      if ((operand->flags & V850E_IMMEDIATE32) == 0)
d2295 2
a2296 2
		      extra_data_len	    = 4;
		      extra_data	    = ex.X_add_number;
d2308 134
d2449 5
a2453 2
		    errmsg = _("invalid register name");
		  else if ((operand->flags & V850_NOT_R0)
d2457 1
d2459 5
a2463 4
		      /* Force an error message to be generated by
			 skipping over any following potential matches
			 for this opcode.  */
		      opcode += 3;
d2465 1
d2469 4
a2472 2
		  if (!system_register_name (&ex, TRUE, FALSE))
		    errmsg = _("invalid system register name");
d2499 4
a2502 6
		  if (!cc_name (&ex))
		    errmsg = _("invalid condition code name");
		}
	      else if (operand->flags & V850E_PUSH_POP)
		{
		  errmsg = parse_register_list (&insn, operand);
d2504 5
a2508 4
		  /* The parse_register_list() function has already done
		     everything, so fake a dummy expression.  */
		  ex.X_op	  = O_constant;
		  ex.X_add_number = 0;
d2510 1
a2510 1
	      else if (operand->flags & V850E_IMMEDIATE16)
d2512 1
a2512 5
		  expression (&ex);

		  if (ex.X_op != O_constant)
		    errmsg = _("constant expression expected");
		  else if (ex.X_add_number & 0xffff0000)
d2514 1
a2514 6
		      if (ex.X_add_number & 0xffff)
			errmsg = _("constant too big to fit into instruction");
		      else if ((insn & 0x001fffc0) == 0x00130780)
			ex.X_add_number >>= 16;
		      else
			errmsg = _("constant too big to fit into instruction");
a2515 17

		  extra_data_after_insn = TRUE;
		  extra_data_len	= 2;
		  extra_data		= ex.X_add_number;
		  ex.X_add_number	= 0;
		}
	      else if (operand->flags & V850E_IMMEDIATE32)
		{
		  expression (&ex);

		  if (ex.X_op != O_constant)
		    errmsg = _("constant expression expected");

		  extra_data_after_insn = TRUE;
		  extra_data_len	= 4;
		  extra_data		= ex.X_add_number;
		  ex.X_add_number	= 0;
d2517 2
a2518 2
	      else if (register_name (&ex)
		       && (operand->flags & V850_OPERAND_REG) == 0)
d2548 4
a2551 2
			  && (v850_operands[opindex_ptr[1]].flags
			      & V850_OPERAND_REG))
d2565 1
a2565 1
	      else if (system_register_name (&ex, FALSE, FALSE)
d2567 4
a2570 3
		errmsg = _("syntax error: system register not expected");

	      else if (cc_name (&ex)
d2572 8
a2579 2
		errmsg = _("syntax error: condition code not expected");

d2583 8
d2592 1
a2592 1
		     If we are assembling a MOV instruction and the immediate
d2594 1
a2594 1
		     fake error so that the next MOV instruction will be
d2597 3
a2599 2
		  if (((insn & 0x07e0) == 0x0200)
		      && operand->bits == 5 /* Do not match the CALLT instruction.  */
d2603 11
a2613 1
		    errmsg = _("immediate operand is too large");
d2629 1
a2629 1
		       & (V850_OPERAND_REG | V850_OPERAND_SRG)) == 0)
d2634 5
a2638 2
		  insn = v850_insert_operand (insn, operand, ex.X_add_number,
					      NULL, 0, copy_of_instruction);
d2643 1
a2643 1
					      NULL, 0, copy_of_instruction);
d2666 6
a2671 1
      match = 1;
d2676 7
d2697 5
a2701 1
	  as_bad ("%s: %s", copy_of_instruction, errmsg);
d2710 3
a2715 7
  while (ISSPACE (*str))
    ++str;

  if (*str != '\0')
    /* xgettext:c-format  */
    as_bad (_("junk at end of line: `%s'"), str);

a2726 14
      /* On a 64-bit host the size of an 'int' is not the same
	 as the size of a pointer, so we need a union to convert
	 the opindex field of the fr_cgen structure into a char *
	 so that it can be stored in the frag.  We do not have
	 to worry about loosing accuracy as we are not going to
	 be even close to the 32bit limit of the int.  */
      union
      {
	int opindex;
	char * ptr;
      }
      opindex_converter;

      opindex_converter.opindex = fixups[0].opindex;
d2730 2
a2731 1
      if (!strcmp (opcode->name, "br"))
d2733 18
a2750 6
	  f = frag_var (rs_machine_dependent, 4, 2, 2,
			fixups[0].exp.X_add_symbol,
			fixups[0].exp.X_add_number,
			opindex_converter.ptr);
	  md_number_to_chars (f, insn, insn_size);
	  md_number_to_chars (f + 2, 0, 2);
d2752 1
a2752 1
      else
d2754 91
a2844 6
	  f = frag_var (rs_machine_dependent, 6, 4, 0,
			fixups[0].exp.X_add_symbol,
			fixups[0].exp.X_add_number,
			opindex_converter.ptr);
	  md_number_to_chars (f, insn, insn_size);
	  md_number_to_chars (f + 2, 0, 4);
d2859 6
d2910 8
a2917 1
	  address = (f - frag_now->fr_literal) + insn_size - size;
d2919 9
a2927 2
	  if (reloc == BFD_RELOC_32)
	    address += 2;
d2929 1
d2940 1
d2955 1
a2955 1
		       (operand->flags & V850_OPERAND_DISP) != 0,
d2985 1
d2989 1
d3094 1
d3106 5
a3110 1
      insn = bfd_getl32 ((unsigned char *) where);
d3112 8
a3119 2
				  fixP->fx_file, fixP->fx_line, NULL);
      bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
d3128 1
a3128 5
      if (operand->bits == 22)
	fixP->fx_r_type = BFD_RELOC_V850_22_PCREL;
      else if (operand->bits == 9)
	fixP->fx_r_type = BFD_RELOC_V850_9_PCREL;
      else
d3135 10
d3152 22
a3173 21
	  && ((struct v850_operand *) fixP->tc_fix_data)->insert != NULL)
	{
	  const char * message = NULL;
	  struct v850_operand * operand = (struct v850_operand *) fixP->tc_fix_data;
	  unsigned long insn;

	  /* The variable "where" currently points at the exact point inside
	     the insn where we need to insert the value.  But we need to
	     extract the entire insn so we probably need to move "where"
	     back a few bytes.  */
	  if (fixP->fx_size == 2)
	    where -= 2;
	  else if (fixP->fx_size == 1)
	    where -= 3;

	  insn = bfd_getl32 ((unsigned char *) where);

	  /* Use the operand's insertion procedure, if present, in order to
	     make sure that the value is correctly stored in the insn.  */
	  insn = operand->insert (insn, (offsetT) value, & message);
	  /* Ignore message even if it is set.  */
d3175 2
a3176 2
	  bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	}
d3178 96
a3273 12
	{
	  if (fixP->fx_r_type == BFD_RELOC_V850_LO16_SPLIT_OFFSET)
	    bfd_putl32 (((value << 16) & 0xfffe0000)
			| ((value << 5) & 0x20)
			| (bfd_getl32 (where) & ~0xfffe0020), where);
	  else if (fixP->fx_size == 1)
	    *where = value & 0xff;
	  else if (fixP->fx_size == 2)
	    bfd_putl16 (value & 0xffff, (unsigned char *) where);
	  else if (fixP->fx_size == 4)
	    bfd_putl32 (value, (unsigned char *) where);
	}
d3276 1
a3276 1

d3283 1
d3285 1
a3285 1
  hold_cons_reloc = v850_reloc_prefix (NULL);
d3347 3
d3351 1
a3351 1
	  || fixP->fx_r_type == BFD_RELOC_V850_9_PCREL
@


1.54
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d1539 18
a1556 1
	  if (val < (offsetT) min || val > (offsetT) max)
@


1.53
log
@Remove duplicate definitions of the md_atof() function
@
text
@d3 1
a3 1
   2006, 2007  Free Software Foundation, Inc.
d480 1
a480 1
	as_warn (".longcall pseudo-op seen when not relaxing");
d482 1
a482 1
	as_warn (".longjump pseudo-op seen when not relaxing");
d489 1
a489 1
      as_bad ("bad .longcall format");
d1508 1
a1508 1
		as_warn (message);
d1510 1
a1510 1
		as_warn_where (file, line, message);
@


1.52
log
@Switch to GPLv3
@
text
@d1181 1
a1181 33
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
@


1.51
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   2006  Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.50
log
@Fixes for building on 64-bit hosts:
        * config/tc-avr.c (mod_index): New union to allow conversion
        between pointers and integers.
        (md_begin, avr_ldi_expression): Use it.
        * config/tc-i370.c (md_assemble): Add cast for argument to print
        statement.
        * config/tc-tic54x.c (subsym_substitute): Likewise.
        * config/tc-mn10200.c (md_assemble): Use a union to convert the
        opindex field of fr_cgen structure into a pointer so that it can
        be stored in a frag.
        * config/tc-mn10300.c (md_assemble): Likewise.
        * config/tc-frv.c (frv_debug_tomcat): Use %p to print pointer
        types.
        * config/tc-v850.c: Replace uses of (int) casts with correct
        types.
        * gas/tic54x/address.d: Work with 64bit hosts.
        * gas/tic54x/addrfar.d: Likewise.
        * gas/tic54x/align.d: Likewise.
        * gas/tic54x/all-opcodes.d: Likewise.
        * gas/tic54x/asg.d: Likewise.
        * gas/tic54x/cons.d: Likewise.
        * gas/tic54x/consfar.d: Likewise.
        * gas/tic54x/extaddr.d: Likewise.
        * gas/tic54x/field.d: Likewise.
        * gas/tic54x/labels.d: Likewise.
        * gas/tic54x/loop.d: Likewise.
        * gas/tic54x/lp.d: Likewise.
        * gas/tic54x/macro.d: Likewise.
        * gas/tic54x/math.d: Likewise.
        * gas/tic54x/opcodes.d: Likewise.
        * gas/tic54x/sections.d: Likewise.
       * gas/tic54x/set.d: Likewise.
       * gas/tic54x/struct.d: Likewise.
       * gas/tic54x/subsym.d: Likewise.
@
text
@a21 1
#include <stdio.h>
@


1.49
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d1224 13
d1239 2
d1245 2
a1246 1
	       fragP->fr_offset, 1, BFD_RELOC_UNUSED + (int)fragP->fr_opcode);
d1268 2
a1269 2
	       fragP->fr_offset, 1, BFD_RELOC_UNUSED +
	       (int) fragP->fr_opcode + 1);
d1277 2
a1278 2
	       fragP->fr_offset, 1, BFD_RELOC_UNUSED +
	       (int) fragP->fr_opcode + 1);
d2055 14
d2077 1
a2077 1
			(char *) fixups[0].opindex);
d2086 1
a2086 1
			(char *) fixups[0].opindex);
@


1.48
log
@Fix typo
@
text
@d2090 1
a2090 1
     md_apply_fix3.  */
d2243 1
a2243 1
md_apply_fix3 (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)
@


1.47
log
@(md_apply_fix3): Only use the insertion routine if one exists.
Ignore any error messages it may produce, just allow it to perform the insertion.
@
text
@d2344 1
a2344 1
	  insn = operand->insert (insn, (offsetT) value, message);
@


1.46
log
@* config/tc-v850,h (TC_FIX_TYPE): Define. (TC_INIT_FIX_TYPE): Define.
* config/tc-v850.c (md_assemble): When creating a fix record the operand in the
    tc_fix_data field.
    (md_apply_fix3): When applying a resolved fix use the operand's insertion
    procedure to store the value, if the operand has been recorded.
* gas/v850/split-lo16.s: Add test for a lo() pseudo reloc corrupting an ld.w
    instruction.
* gas/v850/split-lo16.d: Add expected, correct (ie not corrupt) output.
@
text
@d2324 2
a2325 1
      if (fixP->tc_fix_data != NULL)
d2327 1
d2344 2
a2345 2
	  insn = v850_insert_operand (insn, operand, (offsetT) value,
				      fixP->fx_file, fixP->fx_line, NULL);
@


1.45
log
@Update the address and phone number of the FSF
@
text
@d2128 2
d2324 36
a2359 10
      if (fixP->fx_r_type == BFD_RELOC_V850_LO16_SPLIT_OFFSET)
	bfd_putl32 (((value << 16) & 0xfffe0000)
		    | ((value << 5) & 0x20)
		    | (bfd_getl32 (where) & ~0xfffe0020), where);
      else if (fixP->fx_size == 1)
	*where = value & 0xff;
      else if (fixP->fx_size == 2)
	bfd_putl16 (value & 0xffff, (unsigned char *) where);
      else if (fixP->fx_size == 4)
	bfd_putl32 (value, (unsigned char *) where);
@


1.44
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.43
log
@update copyright dates
@
text
@d46 2
a47 1
struct reg_name {
d73 2
a74 1
const relax_typeS md_relax_table[] = {
d86 4
a89 2
#define MAX_INSN_FIXUPS (5)
struct v850_fixup {
a158 2
static void do_v850_seg PARAMS ((int, subsegT));

d160 1
a160 3
do_v850_seg (i, sub)
     int i;
     subsegT sub;
d165 1
d167 1
a167 3
    {
      subseg_set (seg->s, sub);
    }
a176 2
static void v850_seg PARAMS ((int i));

d178 1
a178 2
v850_seg (i)
     int i;
a185 2
static void v850_offset PARAMS ((int));

d187 1
a187 2
v850_offset (ignore)
     int ignore ATTRIBUTE_UNUSED;
a200 2
static void v850_comm PARAMS ((int));

d202 1
a202 2
v850_comm (area)
     int area;
d254 3
a256 5
	{
	  /* xgettext:c-format  */
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
	}
d432 1
d435 1
a458 2
static void set_machine PARAMS ((int));

d460 1
a460 2
set_machine (number)
     int number;
a472 2
static void v850_longcode PARAMS ((int));

d474 1
a474 2
v850_longcode (type)
     int type;
d539 4
a542 4
  { "ep",  30 },		/* ep - element ptr */
  { "gp",   4 },		/* gp - global ptr  */
  { "hp",   2 },		/* hp - handler stack ptr  */
  { "lp",  31 },		/* lp - link ptr  */
d575 2
a576 2
  { "sp",   3 },		/* sp - stack ptr  */
  { "tp",   5 },		/* tp - text ptr  */
a649 3
static int reg_name_search
  PARAMS ((const struct reg_name *, int, const char *, bfd_boolean));

d651 4
a654 5
reg_name_search (regs, regcount, name, accept_numbers)
     const struct reg_name *regs;
     int regcount;
     const char *name;
     bfd_boolean accept_numbers;
d666 2
a667 4
	{
	  name
	    = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
	}
a706 2
static bfd_boolean register_name PARAMS ((expressionS *));

d708 1
a708 2
register_name (expressionP)
     expressionS *expressionP;
a760 3
static bfd_boolean system_register_name
  PARAMS ((expressionS *, bfd_boolean, bfd_boolean));

d762 3
a764 4
system_register_name (expressionP, accept_numbers, accept_list_names)
     expressionS *expressionP;
     bfd_boolean accept_numbers;
     bfd_boolean accept_list_names;
d795 1
a795 3
	    {
	      reg_number = -1;
	    }
a838 2
static bfd_boolean cc_name PARAMS ((expressionS *));

d840 1
a840 2
cc_name (expressionP)
     expressionS *expressionP;
a876 2
static void skip_white_space PARAMS ((void));

d878 1
a878 1
skip_white_space ()
a909 3
static char *parse_register_list
  PARAMS ((unsigned long *, const struct v850_operand *));

d911 2
a912 3
parse_register_list (insn, operand)
     unsigned long *insn;
     const struct v850_operand *operand;
d914 2
a915 1
  static int type1_regs[32] = {
d919 2
a920 1
  static int type2_regs[32] = {
d924 2
a925 1
  static int type3_regs[32] = {
d1109 2
a1110 1
struct option md_longopts[] = {
d1117 1
a1117 2
md_show_usage (stream)
     FILE *stream;
d1130 1
a1130 3
md_parse_option (c, arg)
     int c;
     char *arg;
d1174 1
a1174 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1180 1
a1180 4
md_atof (type, litp, sizep)
     int type;
     char *litp;
     int *sizep;
d1220 3
a1222 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     fragS *fragP;
d1270 1
a1270 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d1277 1
a1277 1
md_begin ()
a1350 3
static bfd_reloc_code_real_type handle_ctoff
  PARAMS ((const struct v850_operand *));

d1352 1
a1352 2
handle_ctoff (operand)
     const struct v850_operand *operand;
a1366 3
static bfd_reloc_code_real_type handle_sdaoff
  PARAMS ((const struct v850_operand *));

d1368 1
a1368 2
handle_sdaoff (operand)
     const struct v850_operand *operand;
a1388 3
static bfd_reloc_code_real_type handle_zdaoff
  PARAMS ((const struct v850_operand *));

d1390 1
a1390 2
handle_zdaoff (operand)
     const struct v850_operand *operand;
a1411 3
static bfd_reloc_code_real_type handle_tdaoff
  PARAMS ((const struct v850_operand *));

d1413 1
a1413 2
handle_tdaoff (operand)
     const struct v850_operand *operand;
d1420 1
a1420 1
    /* sld.w/sst.w, operand: D8_6  */
d1424 1
a1424 1
    /* sld.hu, operand: D5-4  */
d1428 1
a1428 1
    /* sld.bu, operand: D4   */
d1432 1
a1432 1
    /* set1 & chums, operands: D16  */
d1443 2
a1444 2
    ? BFD_RELOC_V850_TDA_7_8_OFFSET     /* sld.h/sst.h, operand: D8_7  */
    : BFD_RELOC_V850_TDA_7_7_OFFSET;    /* sld.b/sst.b, operand: D7    */
a1450 3
static bfd_reloc_code_real_type v850_reloc_prefix
  PARAMS ((const struct v850_operand *));

d1452 1
a1452 2
v850_reloc_prefix (operand)
     const struct v850_operand *operand;
a1487 4
static unsigned long v850_insert_operand
  PARAMS ((unsigned long, const struct v850_operand *, offsetT, char *,
	   unsigned int, char *));

d1489 6
a1494 7
v850_insert_operand (insn, operand, val, file, line, str)
     unsigned long insn;
     const struct v850_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
     char *str;
d1588 1
a1588 2
md_assemble (str)
     char *str;
d1662 1
a1662 3
	    {
	      operand = &v850_operands[*opindex_ptr];
	    }
d1785 1
a1785 3
		    {
		      errmsg = _("invalid register name");
		    }
d1800 1
a1800 3
		    {
		      errmsg = _("invalid system register name");
		    }
d1828 1
a1828 3
		    {
		      errmsg = _("invalid condition code name");
		    }
d1920 2
a1921 3
		{
		  errmsg = _("syntax error: system register not expected");
		}
d1924 2
a1925 3
		{
		  errmsg = _("syntax error: condition code not expected");
		}
d1962 1
a1962 2
					      (char *) NULL, 0,
					      copy_of_instruction);
d1967 1
a1967 2
					      (char *) NULL, 0,
					      copy_of_instruction);
d2158 1
a2158 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d2162 2
a2163 2
  reloc		      = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr  = (asymbol **) xmalloc (sizeof (asymbol *));
d2184 1
a2184 1
  if (reloc->howto == (reloc_howto_type *) NULL)
d2200 1
a2200 2
v850_handle_align (frag)
     fragS * frag;
d2217 1
a2217 3
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp;
     asection *seg ATTRIBUTE_UNUSED;
d2226 1
a2226 3
v850_pcrel_from_section (fixp, section)
     fixS *fixp;
     segT section;
d2241 1
a2241 4
md_apply_fix3 (fixP, valueP, seg)
     fixS *fixP;
     valueT *valueP;
     segT seg ATTRIBUTE_UNUSED;
d2270 3
a2272 5
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("expression too complex"));
	    }
d2339 1
a2339 2
parse_cons_expression_v850 (exp)
     expressionS *exp;
d2353 4
a2356 5
cons_fix_new_v850 (frag, where, size, exp)
     fragS *frag;
     int where;
     int size;
     expressionS *exp;
d2377 1
a2377 2
v850_fix_adjustable (fixP)
     fixS *fixP;
d2395 1
a2395 2
v850_force_relocation (fixP)
     struct fix *fixP;
@


1.42
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
@


1.41
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1294 1
a1294 1
      md_number_to_chars (buffer + 2, 0x00000780, 4);
@


1.40
log
@include/elf/
	* v850.h (R_V850_LO16_SPLIT_OFFSET): New reloc.

bfd/
	* reloc.c (BFD_RELOC_V850_LO16_SPLIT_OFFSET): New bfd_reloc_code_type.
	* elf32-v850.c (v850_elf_howto_table): Add entry for
	R_V850_LO16_SPLIT_OFFSET.
	(v850_elf_reloc_map): Map it to BFD_RELOC_V850_LO16_SPLIT_OFFSET.
	(v850_elf_perform_lo16_relocation): New function, extracted from...
	(v850_elf_perform_relocation): ...here.  Use it to handle
	R_V850_LO16_SPLIT_OFFSET.
	(v850_elf_check_relocs, v850_elf_final_link_relocate): Handle
	R_V850_LO16_SPLIT_OFFSET.
	* libbfd.h, bfd-in2.h: Regenerate.

gas/
	* config/tc-v850.c (handle_lo16): New function.
	(v850_reloc_prefix): Use it to check lo().
	(md_assemble, md_apply_fix3): Handle BFD_RELOC_V850_LO16_SPLIT_OFFSET.

gas/testsuite/
	* gas/v850/split-lo16.{s,d}: New test.
	* gas/v850/v850.exp: Run it.

ld/testsuite/
	* ld-v850: New directory.
@
text
@a2027 7
#if 0
	      fprintf (stderr,
		       " insn: %x, operand %d, op: %d, add_number: %d\n",
		       insn, opindex_ptr - opcode->operands,
		       ex.X_op, ex.X_add_number);
#endif

a2406 4
#if 0
	  fprintf (stderr, "bits: %d, insn: %x\n", operand->bits, insn);
#endif

@


1.39
log
@Add support for a -g switch to GAS
@
text
@d1378 19
d1538 1
a1538 1
  CHECK_ ("lo",	    BFD_RELOC_LO16	   );
d1777 1
d2222 1
d2429 5
a2433 1
      if (fixP->fx_size == 1)
@


1.38
log
@Remove duplicate code and provide a function for generating internally consistent 'value out of range' messages
@
text
@d1172 1
a1172 6
    {
      if (c != 'a')
	/* xgettext:c-format  */
	fprintf (stderr, _("unknown command line option: -%c%s\n"), c, arg);
      return 0;
    }
d1175 2
a1176 3
    {
      warn_signed_overflows = TRUE;
    }
d1178 2
a1179 3
    {
      warn_unsigned_overflows = TRUE;
    }
d1207 1
a1207 5
    {
      /* xgettext:c-format  */
      fprintf (stderr, _("unknown command line option: -%c%s\n"), c, arg);
      return 0;
    }
@


1.37
log
@	* config/atof-tahoe.c: Fix comment typos.
	* config/m68k-parse.y: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-bout.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/te-delt88.h: Likewise.
	* config/te-delta.h: Likewise.
	* config/te-generic.h: Likewise.
	* config/te-macos.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-psos.h: Likewise.
	* config/te-sun3.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/xtensa-relax.c: Likewise.
@
text
@d1621 1
a1621 4
	      /* xgettext:c-format  */
	      const char *err =
		_("operand out of range (%s not between %ld and %ld)");
	      char buf[100];
d1633 1
a1633 5
		{
		  sprintf (buf, "%s: ", str);

		  sprint_value (buf + strlen (buf), val);
		}
d1635 2
a1636 1
		sprint_value (buf, val);
d1638 1
a1638 4
	      if (file == (char *) NULL)
		as_warn (err, buf, min, max);
	      else
		as_warn_where (file, line, err, buf, min, max);
@


1.36
log
@Add binutils support for v850e1 processor
@
text
@d940 1
a940 1
   and also parses constant epxressions whoes bits indicate the
d942 1
a942 1
   the lowest numbered permissable register in the register list,
d1498 1
a1498 1
    : BFD_RELOC_V850_TDA_7_7_OFFSET;    /* sld.b/sst.b, opreand: D7    */
d1979 1
a1979 1
		      /* If this register is actually occuring too early on
@


1.35
log
@	* config/tc-v850.c (md_assemble): When no reloc, create pcrel fixups
	only for V850_OPERAND_DISP operands.
@
text
@d482 1
d543 1
d1161 1
d1197 5
d1209 1
d1339 9
a1347 1
  if (strncmp (TARGET_CPU, "v850e", 5) == 0)
@


1.34
log
@Update .comm error messages to assume an unsigned value.
Update relaxing code to work in 64-bit address spaces.
@
text
@d200 1
a200 1
                       (offsetT) temp, (char *) 0);
d399 2
a400 2
          segT   old_sec;
          int    old_subsec;
d403 2
a404 2
          old_sec = now_seg;
          old_subsec = now_subseg;
d480 1
a480 1
    case 0:               processor_mask = PROCESSOR_V850;   break;
d498 1
a498 1
	as_warn (".longjump pseudo-op seen when not relaxing");	
d511 1
a511 1
  if (type == 1) 
d542 2
a543 2
  { "longcall",         v850_longcode,          1                       },
  { "longjump",         v850_longcode,          2                       },
d718 1
a718 1
  
d720 1
a720 1
  
d752 1
a752 1
      expressionP->X_op         = O_register;
d771 1
a771 1
  
d773 5
a777 5
        EXPRESSIONP points to an expression structure to be filled in.
        ACCEPT_NUMBERS is true iff numerical register names may be used.
        ACCEPT_LIST_NAMES is true iff the special names PS and SR may be
        accepted.
  
d840 1
a840 1
      expressionP->X_op         = O_register;
d859 1
a859 1
  
d861 1
a861 1
  
d891 1
a891 1
      expressionP->X_op         = O_constant;
d920 1
a920 1
  
d922 3
a924 3
       INSN                is the partially constructed instruction.
       OPERAND             is the operand being inserted.
  
d926 4
a929 4
        pointer to an error message is returned.  If the parse
        completes the correct bit fields in the instruction
        will be filled in.
  
d931 1
a931 1
  
d937 1
a937 1
  
a1160 1
  
d1349 1
a1349 1
            TARGET_CPU);
d1511 3
a1513 3
  CHECK_ ("hi0",    BFD_RELOC_HI16         );
  CHECK_ ("hi",     BFD_RELOC_HI16_S       );
  CHECK_ ("lo",     BFD_RELOC_LO16         );
d1517 1
a1517 1
  CHECK_ ("hilo",   BFD_RELOC_32           );
d1793 2
a1794 2
		      extra_data_len        = 4;
		      extra_data            = 0;
d1822 2
a1823 2
		      extra_data_len        = 4;
		      extra_data            = ex.X_add_number;
d1899 1
a1899 1
		  ex.X_op         = O_constant;
d1919 3
a1921 3
		  extra_data_len        = 2;
		  extra_data            = ex.X_add_number;
		  ex.X_add_number       = 0;
d1931 3
a1933 3
		  extra_data_len        = 4;
		  extra_data            = ex.X_add_number;
		  ex.X_add_number       = 0;
d2218 1
a2218 1
		       1 /* FIXME: V850_OPERAND_RELATIVE ???  */,
d2237 1
a2237 1
  reloc               = (arelent *) xmalloc (sizeof (arelent));
d2257 1
a2257 1
  reloc->howto        = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
d2287 1
a2287 1
           BFD_RELOC_V850_ALIGN);
d2372 1
a2372 1
         value, and stuff the instruction back again.
@


1.33
log
@Add pc-relative 32-bit reloc to v850 port.  Fixes ld-elf/merge test failure.
@
text
@d198 1
a198 1
   
@


1.32
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d2242 16
a2270 10

  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
    reloc->addend = fixp->fx_offset;
  else if (   fixp->fx_r_type == BFD_RELOC_V850_LONGCALL
	   || fixp->fx_r_type == BFD_RELOC_V850_LONGJUMP
           || fixp->fx_r_type == BFD_RELOC_V850_ALIGN)
    reloc->addend = fixp->fx_offset;
  else
    reloc->addend = fixp->fx_addnumber;
@


1.31
log
@Add v850e debug registers.
@
text
@a541 2
  { "file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  { "loc",		dwarf2_directive_loc,	0			},
@


1.31.2.1
log
@Add pc-relative 32-bit reloc to V850 port.  Fixes ld-elf/merge test failure.
@
text
@a2243 16

  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_V850_LONGCALL
      || fixp->fx_r_type == BFD_RELOC_V850_LONGJUMP
      || fixp->fx_r_type == BFD_RELOC_V850_ALIGN)
    reloc->addend = fixp->fx_offset;
  else
    {
      if (fixp->fx_r_type == BFD_RELOC_32
	  && fixp->fx_pcrel)
	fixp->fx_r_type = BFD_RELOC_32_PCREL;

      reloc->addend = fixp->fx_addnumber;
    }

d2257 10
@


1.30
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d522 2
a523 1
const pseudo_typeS md_pseudo_table[] = {
d553 2
a554 1
static const struct reg_name pre_defined_registers[] = {
d599 8
a606 1
static const struct reg_name system_registers[] = {
d612 1
d624 2
a625 1
static const struct reg_name system_list_registers[] = {
d633 2
a634 1
static const struct reg_name cc_names[] = {
d720 8
a727 8
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.  */
d773 12
a784 12
 *
 * in:  INPUT_LINE_POINTER points to 1st char of operand.
 *      EXPRESSIONP points to an expression structure to be filled in.
 *      ACCEPT_NUMBERS is true iff numerical register names may be used.
 *      ACCEPT_LIST_NAMES is true iff the special names PS and SR may be
 *      accepted.
 *
 * out: An expressionS structure in expressionP.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.  */
d823 1
a823 1
	      || reg_number > 20)
d861 8
a868 8
 *
 * in: INPUT_LINE_POINTER points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.  */
d922 23
a944 23
 *
 * in: INPUT_LINE_POINTER  points to 1st char of a list of registers.
 *     INSN                is the partially constructed instruction.
 *     OPERAND             is the operand being inserted.
 *
 * out: NULL if the parse completed successfully, otherwise a
 *      pointer to an error message is returned.  If the parse
 *      completes the correct bit fields in the instruction
 *      will be filled in.
 *
 * Parses register lists with the syntax:
 *
 *   { rX }
 *   { rX, rY }
 *   { rX - rY }
 *   { rX - rY, rZ }
 *   etc
 *
 * and also parses constant epxressions whoes bits indicate the
 * registers in the lists.  The LSB in the expression refers to
 * the lowest numbered permissable register in the register list,
 * and so on upwards.  System registers are considered to be very
 * high numbers.  */
a984 1

d1069 1
a1069 3
	    {
	      return _("illegal register included in list");
	    }
d1136 1
a1136 3
	{
	  break;
	}
a1359 1

@


1.29
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
a2476 4
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

d2489 1
a2489 1
  return S_FORCE_RELOC (fixP->fx_addsy);
@


1.28
log
@	* config/tc-v850.c (CHECK_): Remove token pasting operator.
@
text
@d36 2
a37 2
static boolean warn_signed_overflows   = FALSE;
static boolean warn_unsigned_overflows = FALSE;
d655 1
a655 1
  PARAMS ((const struct reg_name *, int, const char *, boolean));
d662 1
a662 1
     boolean accept_numbers;
d717 1
a717 1
static boolean register_name PARAMS ((expressionS *));
d719 1
a719 1
static boolean
d749 1
a749 1
      return true;
d756 1
a756 1
      return false;
d774 2
a775 1
static boolean system_register_name PARAMS ((expressionS *, boolean, boolean));
d777 1
a777 1
static boolean
d780 2
a781 2
     boolean accept_numbers;
     boolean accept_list_names;
d837 1
a837 1
      return true;
d844 1
a844 1
      return false;
d858 1
a858 1
static boolean cc_name PARAMS ((expressionS *));
d860 1
a860 1
static boolean
d888 1
a888 1
      return true;
d895 1
a895 1
      return false;
d1062 1
a1062 1
      else if (system_register_name (&exp, true, true))
d1492 1
a1492 1
  boolean paren_skipped = false;
d1498 1
a1498 1
      paren_skipped = true;
d1655 1
a1655 1
  boolean extra_data_after_insn = false;
d1703 1
a1703 1
      extra_data_after_insn = false;
d1789 1
a1789 1
		      extra_data_after_insn = true;
d1818 1
a1818 1
		      extra_data_after_insn = true;
d1855 1
a1855 1
		  if (!system_register_name (&ex, true, false))
d1915 1
a1915 1
		  extra_data_after_insn = true;
d1927 1
a1927 1
		  extra_data_after_insn = true;
d1978 1
a1978 1
	      else if (system_register_name (&ex, false, false)
d2152 1
a2152 1
	  extra_data_after_insn = false;
d2454 1
a2454 1
boolean
@


1.27
log
@Fix v850 .offset pseudo-op
	* config/tc-v850.c (v850_offset): Use frag_var instead of frag_now_fix
	and frag_more.
@
text
@d1501 1
a1501 1
  if (strncmp (input_line_pointer, name##"(", strlen (name) + 1) == 0)	\
@


1.26
log
@gas reloc rewrite.
@
text
@d196 1
d198 4
a201 5

  temp -= frag_now_fix ();

  if (temp > 0)
    (void) frag_more (temp);
@


1.25
log
@Add linker relaxation to v850 toolchain
@
text
@a2459 8
  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;

  /* Similarly for weak symbols.  */
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;

a2475 3
  if (fixP->fx_addsy && S_IS_WEAK (fixP->fx_addsy))
    return 1;

d2480 1
a2480 1
  if (   fixP->fx_r_type == BFD_RELOC_V850_LONGCALL
d2486 4
a2489 4
        || fixP->fx_r_type == BFD_RELOC_V850_ALIGN
        || fixP->fx_r_type == BFD_RELOC_V850_22_PCREL
        || fixP->fx_r_type == BFD_RELOC_V850_9_PCREL
        || fixP->fx_r_type >= BFD_RELOC_UNUSED))
d2492 1
a2492 1
  return 0;
@


1.24
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d81 2
d399 3
d403 3
d422 3
a481 1
    case bfd_mach_v850ea: processor_mask = PROCESSOR_V850EA; break;
d485 36
a540 1
  { "v850ea",		set_machine,		bfd_mach_v850ea 	},
d543 2
a1152 1
  fprintf (stream, _("  -mv850ea                  The code is targeted at the v850ea\n"));
d1154 2
a1188 5
  else if (strcmp (arg, "v850ea") == 0)
    {
      machine = bfd_mach_v850ea;
      processor_mask = PROCESSOR_V850EA;
    }
d1195 1
a1195 1
      processor_mask = PROCESSOR_V850EA;
d1197 2
d1323 1
a1323 6
  register const struct v850_opcode *op;

  if (strncmp (TARGET_CPU, "v850ea", 6) == 0)
    {
      if (machine == -1)
	machine = bfd_mach_v850ea;
d1325 1
a1325 4
      if (processor_mask == -1)
	processor_mask = PROCESSOR_V850EA;
    }
  else if (strncmp (TARGET_CPU, "v850e", 5) == 0)
d1790 1
a1790 2
		      extra_data            = ex.X_add_number;
		      ex.X_add_number       = 0;
d2254 4
d2264 16
d2320 2
d2329 1
d2333 1
a2333 1
    ;
d2349 1
a2407 2

  fixP->fx_addnumber = value;
d2489 12
@


1.23
log
@Fix assembly of "callt 0x3f"
@
text
@d496 1
a496 1
  { "file",		dwarf2_directive_file,	0			},
@


1.22
log
@Fix range check for immediate operand.
@
text
@d1955 4
a1958 5
		     If we are assembling a MOV instruction (or a CALLT.... :-)
		     and the immediate value does not fit into the bits
		     available then create a fake error so that the next MOV
		     instruction will be selected.  This one has a 32 bit
		     immediate field.  */
d1961 1
@


1.21
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d1964 1
a1964 1
			  || ex.X_add_number > ((1 << operand->bits) - 1)))
@


1.21.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* write.c: Delete set_segment_vma and prototype. Update all callers.

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.

	2002-09-16  Chris Demetriou  <cgd@@broadcom.com>
	* config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
	(IS_SEXT_16BIT_NUM): New macro.
	(macro_build_ldst_constoffset): New function, to build a set of
	instructions to do a load or store from a constant offset relative
	to a given register.
	(macro, s_cprestore): Use macro_build_ldst_constoffset to implement
	.cprestore pseudo-op.

	2002-09-16  Elias Athanasopoulos  <eathan@@otenet.gr>
	* dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
	(out_debug_info): Likewise.

	2002-09-13  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_assemble): Do not count FAKE operands
	when deciding if any operands have been skipped.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-09-04  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_begin): Do not insert non-BookE32
	instructions into the hash table if the target cpu is the BookE32.

	2002-08-20  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
	by zero.

	2002-08-15  Alexandre Oliva  <aoliva@@redhat.com>
	* config/tc-mips.c (macro_build_jalr): Make sure we generate
	the fix-up against on the right frag.
	(s_cpsetup): Likewise.  Parse third argument as expression, to
	handle global symbols and forward/backward labels correctly.

	2002-08-14  Nick Clifton  <nickc@@redhat.com>
	* read.c (stringer): Catch attempts to create strings in the abs
	section.

	2002-08-12  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

	2002-08-10  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.

	2002-08-06  George France <france@@handhelds.org>
	* config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
	and m21264b processor names and cpu types.
	* doc/c-alpha.texi: Documented new types.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.

	2002-08-03  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.

	2002-07-31  Momchil Velikov  <velco@@fadata.bg>
	* config/tc-v850.c (md_assemble): Fix range check for immediate
	operand.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".
@
text
@d1964 1
a1964 1
			  || ex.X_add_number > ((1 << (operand->bits - 1)) - 1)))
@


1.21.2.2
log
@	* config/tc-v850.c (CHECK_): Remove token pasting operator.
@
text
@d1464 1
a1464 1
  if (strncmp (input_line_pointer, name "(", strlen (name) + 1) == 0)	\
@


1.20
log
@	* config/tc-v850.c: Add missing prototypes amd use old-style
	function definitions.
	(AREA_ZDA, AREA_SDA, AREA_TDA): Delete.
	(sdata_section tdata_section, zdata_section, sbss_section,
	tbss_section, zbss_section, rosdata_section, rozdata_section,
	scommon_section, tcommon_section, zcommon_section,
	call_table_data_section, call_table_text_section): Delete.
	(v850_sdata, v850_tdata, v850_zdata, v850_sbss, v850_tbss,
	v850_zbss, v850_bss, v850_rosdata, v850_rozdata,
	v850_call_table_data, v850_call_table_text): Delete.
	(struct v850_seg_entry): New.
	(v850_seg_table): New.
	(SDATA_SECTION TDATA_SECTION, ZDATA_SECTION, SBSS_SECTION,
	TBSS_SECTION, ZBSS_SECTION, BSS_SECTION, ROSDATA_SECTION,
	ROZDATA_SECTION, SCOMMON_SECTION, TCOMMON_SECTION, ZCOMMON_SECTION,
	CALL_TABLE_DATA_SECTION, CALL_TABLE_TEXT_SECTION): Define.
	(do_v850_seg): New.
	(v850_seg): New.
	(v850_comm): Use do_v850_seg and v850_seg_table.  Simplify
	recording of alignment.
	(md_pseudo_table): Use v850_seg.
	(md_begin): Don't init .call_table_data and .call_table_text here.
	Set v850_seg_table bss entry.
	* config/tc-v850.h (v850_pcrel_from_section): Prototype.

	* gas/elf/elf.exp: Don't special case v850.
@
text
@d1089 1
a1089 1
CONST char *md_shortopts = "m:";
@


1.19
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
a28 4
#define AREA_ZDA 0
#define AREA_SDA 1
#define AREA_TDA 2

a80 14
static segT sdata_section = NULL;
static segT tdata_section = NULL;
static segT zdata_section = NULL;
static segT sbss_section = NULL;
static segT tbss_section = NULL;
static segT zbss_section = NULL;
static segT rosdata_section = NULL;
static segT rozdata_section = NULL;
static segT scommon_section = NULL;
static segT tcommon_section = NULL;
static segT zcommon_section = NULL;
static segT call_table_data_section = NULL;
static segT call_table_text_section = NULL;

a90 10

void
v850_sdata (int ignore ATTRIBUTE_UNUSED)
{
  obj_elf_section_change_hook ();

  subseg_set (sdata_section, (subsegT) get_absolute_expression ());

  demand_empty_rest_of_line ();
}
d92 1
a92 2
void
v850_tdata (int ignore ATTRIBUTE_UNUSED)
d94 4
a97 3
  obj_elf_section_change_hook ();

  subseg_set (tdata_section, (subsegT) get_absolute_expression ());
d99 1
a99 5
  demand_empty_rest_of_line ();
}

void
v850_zdata (int ignore ATTRIBUTE_UNUSED)
d101 36
a136 1
  obj_elf_section_change_hook ();
d138 14
a151 1
  subseg_set (zdata_section, (subsegT) get_absolute_expression ());
d153 1
a153 2
  demand_empty_rest_of_line ();
}
d155 4
a158 2
void
v850_sbss (int ignore ATTRIBUTE_UNUSED)
d160 1
a160 6
  obj_elf_section_change_hook ();

  subseg_set (sbss_section, (subsegT) get_absolute_expression ());

  demand_empty_rest_of_line ();
}
a161 3
void
v850_tbss (int ignore ATTRIBUTE_UNUSED)
{
d163 11
a173 4

  subseg_set (tbss_section, (subsegT) get_absolute_expression ());

  demand_empty_rest_of_line ();
d176 1
a176 6
void
v850_zbss (int ignore ATTRIBUTE_UNUSED)
{
  obj_elf_section_change_hook ();

  subseg_set (zbss_section, (subsegT) get_absolute_expression ());
d178 3
a180 5
  demand_empty_rest_of_line ();
}

void
v850_rosdata (int ignore ATTRIBUTE_UNUSED)
d182 1
a182 3
  obj_elf_section_change_hook ();

  subseg_set (rosdata_section, (subsegT) get_absolute_expression ());
d184 1
d188 1
a188 4
void
v850_rozdata (int ignore ATTRIBUTE_UNUSED)
{
  obj_elf_section_change_hook ();
d190 3
a192 39
  subseg_set (rozdata_section, (subsegT) get_absolute_expression ());

  demand_empty_rest_of_line ();
}

void
v850_call_table_data (int ignore ATTRIBUTE_UNUSED)
{
  obj_elf_section_change_hook ();

  subseg_set (call_table_data_section, (subsegT) get_absolute_expression ());

  demand_empty_rest_of_line ();
}

void
v850_call_table_text (int ignore ATTRIBUTE_UNUSED)
{
  obj_elf_section_change_hook ();

  subseg_set (call_table_text_section, (subsegT) get_absolute_expression ());

  demand_empty_rest_of_line ();
}

void
v850_bss (int ignore ATTRIBUTE_UNUSED)
{
  register int temp = get_absolute_expression ();

  obj_elf_section_change_hook ();

  subseg_set (bss_section, (subsegT) temp);

  demand_empty_rest_of_line ();
}

void
v850_offset (int ignore ATTRIBUTE_UNUSED)
d206 2
d312 2
a313 9
	    case AREA_SDA:
	      if (sbss_section == NULL)
		{
		  sbss_section = subseg_new (".sbss", 0);

		  bfd_set_section_flags (stdoutput, sbss_section, applicable);

		  seg_info (sbss_section)->bss = 1;
		}
d316 2
a317 9
	    case AREA_ZDA:
	      if (zbss_section == NULL)
		{
		  zbss_section = subseg_new (".zbss", 0);

		  bfd_set_section_flags (stdoutput, sbss_section, applicable);

		  seg_info (zbss_section)->bss = 1;
		}
d320 2
a321 9
	    case AREA_TDA:
	      if (tbss_section == NULL)
		{
		  tbss_section = subseg_new (".tbss", 0);

		  bfd_set_section_flags (stdoutput, tbss_section, applicable);

		  seg_info (tbss_section)->bss = 1;
		}
d341 1
a341 23
	  switch (area)
	    {
	    case AREA_SDA:
	      record_alignment (sbss_section, align);
	      obj_elf_section_change_hook ();
	      subseg_set (sbss_section, 0);
	      break;

	    case AREA_ZDA:
	      record_alignment (zbss_section, align);
	      obj_elf_section_change_hook ();
	      subseg_set (zbss_section, 0);
	      break;

	    case AREA_TDA:
	      record_alignment (tbss_section, align);
	      obj_elf_section_change_hook ();
	      subseg_set (tbss_section, 0);
	      break;

	    default:
	      abort ();
	    }
d348 2
a349 2
	    case AREA_SDA:
	      if (S_GET_SEGMENT (symbolP) == sbss_section)
d353 2
a354 2
	    case AREA_ZDA:
	      if (S_GET_SEGMENT (symbolP) == zbss_section)
d358 2
a359 2
	    case AREA_TDA:
	      if (S_GET_SEGMENT (symbolP) == tbss_section)
d375 2
a376 2
	    case AREA_SDA:
	      S_SET_SEGMENT (symbolP, sbss_section);
d379 2
a380 2
	    case AREA_ZDA:
	      S_SET_SEGMENT (symbolP, zbss_section);
d383 2
a384 2
	    case AREA_TDA:
	      S_SET_SEGMENT (symbolP, tbss_section);
d404 5
a408 48
	    case AREA_SDA:
	      if (scommon_section == NULL)
		{
		  flagword applicable =
		    bfd_applicable_section_flags (stdoutput);

		  scommon_section = subseg_new (".scommon", 0);

		  bfd_set_section_flags (stdoutput, scommon_section,
					 (applicable
		     & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
			| SEC_HAS_CONTENTS)) | SEC_IS_COMMON);
		}
	      S_SET_SEGMENT (symbolP, scommon_section);
	      break;

	    case AREA_ZDA:
	      if (zcommon_section == NULL)
		{
		  flagword applicable =
		    bfd_applicable_section_flags (stdoutput);

		  zcommon_section = subseg_new (".zcommon", 0);

		  bfd_set_section_flags (stdoutput, zcommon_section,
					 (applicable
		     & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
			| SEC_HAS_CONTENTS)) | SEC_IS_COMMON);
		}
	      S_SET_SEGMENT (symbolP, zcommon_section);
	      break;

	    case AREA_TDA:
	      if (tcommon_section == NULL)
		{
		  flagword applicable =
		    bfd_applicable_section_flags (stdoutput);

		  tcommon_section = subseg_new (".tcommon", 0);

		  bfd_set_section_flags (stdoutput, tcommon_section,
					 ((applicable
					   & (SEC_ALLOC | SEC_LOAD
					      | SEC_RELOC | SEC_DATA
					      | SEC_HAS_CONTENTS))
					  | SEC_IS_COMMON));
		}
	      S_SET_SEGMENT (symbolP, tcommon_section);
d458 5
a462 2
void
set_machine (int number)
d477 22
a498 22
  {"sdata",   v850_sdata,   0},
  {"tdata",   v850_tdata,   0},
  {"zdata",   v850_zdata,   0},
  {"sbss",    v850_sbss,    0},
  {"tbss",    v850_tbss,    0},
  {"zbss",    v850_zbss,    0},
  {"rosdata", v850_rosdata, 0},
  {"rozdata", v850_rozdata, 0},
  {"bss",     v850_bss,     0},
  {"offset",  v850_offset,  0},
  {"word",    cons,         4},
  {"zcomm",   v850_comm,    AREA_ZDA},
  {"scomm",   v850_comm,    AREA_SDA},
  {"tcomm",   v850_comm,    AREA_TDA},
  {"v850",    set_machine,  0},
  {"call_table_data", v850_call_table_data, 0},
  {"call_table_text", v850_call_table_text, 0},
  {"v850e",           set_machine,          bfd_mach_v850e},
  {"v850ea",          set_machine,          bfd_mach_v850ea},
  {"file",    dwarf2_directive_file, 0},
  {"loc",     dwarf2_directive_loc, 0},
  { NULL,     NULL,         0}
d607 3
d670 2
d727 2
d810 2
d851 2
d854 1
a854 1
skip_white_space (void)
d886 3
a1278 1
  flagword applicable;
d1327 1
d1329 1
d1331 2
a1332 15
  applicable = bfd_applicable_section_flags (stdoutput);

  call_table_data_section = subseg_new (".call_table_data", 0);
  bfd_set_section_flags (stdoutput, call_table_data_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_DATA | SEC_HAS_CONTENTS));

  call_table_text_section = subseg_new (".call_table_text", 0);
  bfd_set_section_flags (stdoutput, call_table_text_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_READONLY
				       | SEC_CODE));

  /* Restore text section as the current default.  */
  subseg_set (text_section, 0);
}
d1335 2
a1336 1
handle_ctoff (const struct v850_operand *operand)
d1351 3
d1355 2
a1356 1
handle_sdaoff (const struct v850_operand *operand)
d1377 3
d1381 2
a1382 1
handle_zdaoff (const struct v850_operand *operand)
d1404 3
d1408 2
a1409 1
handle_tdaoff (const struct v850_operand *operand)
d1447 3
d1451 2
a1452 1
v850_reloc_prefix (const struct v850_operand *operand)
d1487 4
@


1.18
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2213 1
a2213 1
     md_apply_fix.  */
d2343 4
a2346 4
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
d2349 1
a2349 1
  valueT value;
d2352 2
a2353 2
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
d2355 2
a2356 2
      fixp->fx_done = 0;
      return 1;
d2359 6
a2364 7
  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = *valuep;
d2367 2
a2368 2
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
d2370 2
a2371 2
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
d2375 1
a2375 1
	      as_bad_where (fixp->fx_file, fixp->fx_line,
d2381 1
a2381 1
  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
d2387 1
a2387 1
      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
d2395 1
a2395 1
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
d2399 1
a2399 1
				  fixp->fx_file, fixp->fx_line, NULL);
d2402 3
a2404 5
      if (fixp->fx_done)
	{
	  /* Nothing else to do here.  */
	  return 1;
	}
d2410 1
a2410 1
	fixp->fx_r_type = BFD_RELOC_V850_22_PCREL;
d2412 1
a2412 1
	fixp->fx_r_type = BFD_RELOC_V850_9_PCREL;
d2419 1
a2419 1
	  as_bad_where (fixp->fx_file, fixp->fx_line,
d2421 2
a2422 2
	  fixp->fx_done = 1;
	  return 1;
d2425 1
a2425 1
  else if (fixp->fx_done)
d2428 1
a2428 1
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
d2430 1
a2430 1
      if (fixp->fx_size == 1)
d2432 1
a2432 1
      else if (fixp->fx_size == 2)
d2434 1
a2434 1
      else if (fixp->fx_size == 4)
d2438 1
a2438 2
  fixp->fx_addnumber = value;
  return 1;
@


1.17
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d773 1
a773 1
 * out: A expressionS.
d828 1
a828 1
 * out: A expressionS structure in expressionP.
d909 1
a909 1
 * out: A expressionS.
@


1.16
log
@Update copyright date.
@
text
@a22 1
#include <ctype.h>
d24 1
d861 1
a861 1
      if (isdigit (*input_line_pointer))
d1714 1
a1714 1
  for (s = str; *s != '\0' && ! isspace (*s); s++)
d1731 1
a1731 1
  while (isspace (*str))
d2144 1
a2144 1
  while (isspace (*str))
@


1.15
log
@Fix dwarf2_emit_insn calls when frag_var breaks things.
Put back an old entry in ChangeLog-9899, deleted when ChangeLog split.
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.14
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@a1701 1
  unsigned long total_insn_size = 0;
d2152 5
a2181 1
      total_insn_size = insn_size;
a2195 2
      total_insn_size = insn_size;

a2200 2
	  total_insn_size += extra_data_len;

a2272 2

  dwarf2_emit_insn (total_insn_size);
@


1.13
log
@Fix copyright notices
@
text
@d607 2
a608 2
  {"file",    dwarf2_directive_file },
  {"loc",     dwarf2_directive_loc },
a1323 1
      fragP->fr_var = 0;
a1346 1
      fragP->fr_var = 0;
a1355 1
      fragP->fr_var = 0;
d2315 1
a2315 1
/* Assume everything will fit in two bytes, then expand as necessary.  */
d2322 1
a2322 5
  if (fragp->fr_subtype == 0)
    fragp->fr_var = 4;
  else if (fragp->fr_subtype == 2)
    fragp->fr_var = 2;
  else
d2324 2
a2325 1
  return 2;
@


1.12
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation.
@


1.12.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d607 2
a608 2
  {"file",    dwarf2_directive_file, 0},
  {"loc",     dwarf2_directive_loc, 0},
d1324 1
d1348 1
d1358 1
d1705 1
a2155 5
  /* Tie dwarf2 debug info to the address at the start of the insn.
     We can't do this after the insn has been output as the current
     frag may have been closed off.  eg. by frag_var.  */
  dwarf2_emit_insn (0);

d2181 1
d2196 2
d2203 2
d2277 2
d2318 1
a2318 1
/* Return current size of variable part of frag.  */
d2325 5
a2329 1
  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
d2331 1
a2331 2

  return md_relax_table[fragp->fr_subtype].rlx_length;
@


1.11
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-tic30.c: Fix formatting.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d2278 1
a2278 2
  if (debug_type == DEBUG_DWARF2)
    dwarf2_generate_asm_lineno (total_insn_size);
a2534 7
}

void
v850_finalize ()
{
  if (debug_type == DEBUG_DWARF2)
    dwarf2_finish ();
@


1.10
log
@* config/tc-v850.c: Support dwarf2.
* config/tc-v850.h: Ditto.

* config/tc-v850.c (cons_fix_new_v850): Don't rely on
parse_cons_expression_v850 to initialize hold_cons_reloc.
@
text
@d49 1
a49 2
struct reg_name
{
d75 1
a75 2
const relax_typeS md_relax_table[] =
{
d100 1
a100 2
struct v850_fixup
{
d587 1
a587 2
const pseudo_typeS md_pseudo_table[] =
{
d616 1
a616 2
static const struct reg_name pre_defined_registers[] =
{
d661 1
a661 2
static const struct reg_name system_registers[] =
{
d678 1
a678 2
static const struct reg_name system_list_registers[] =
{
d686 1
a686 2
static const struct reg_name cc_names[] =
{
d1188 1
a1188 2
struct option md_longopts[] =
{
d1313 3
a1315 3
  bfd *abfd ATTRIBUTE_UNUSED;
  asection *sec;
  fragS *fragP;
d1410 1
a1410 1
  v850_hash = hash_new();
@


1.9
log
@2000-08-01  Kazu Hirata  <kazu@@hxi.com>

	* config/obj-som.c: Fix formatting.
	* config/obj-ieee.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
d26 1
d36 1
a36 1
static bfd_reloc_code_real_type hold_cons_reloc;
d611 2
d1714 1
d2190 1
d2205 1
d2212 1
d2286 3
d2502 2
d2545 7
@


1.8
log
@Fix compile time warnings
@
text
@d24 1
a24 1
#include "subsegs.h"     
d31 2
a32 2
/* sign-extend a 16-bit number */
#define SEXT16(x)	((((x) & 0xffff) ^ (~ 0x7fff)) + 0x8000)
d42 1
a42 1
static int     machine = -1;
d45 1
a45 2
static int	processor_mask = -1;

d50 2
a51 2
  const char * name;
  int          value;
d54 2
a55 1
/* Generic assembler global variables which must be defined by all targets. */
d57 1
a57 1
/* Characters which always start a comment. */
d63 1
a63 1
/* Characters which may be used to separate multiple commands on a 
d67 1
a67 1
/* Characters which are used to indicate an exponent in a floating 
d71 1
a71 1
/* Characters which mean that a number is a floating point constant, 
a74 1

a84 1

d99 1
a99 1
/* fixups */
d103 2
a104 2
  expressionS              exp;
  int                      opindex;
d108 1
a108 1
struct v850_fixup fixups [MAX_INSN_FIXUPS];
a109 1

d114 2
a115 2
  obj_elf_section_change_hook();
  
d124 2
a125 2
  obj_elf_section_change_hook();
  
d127 1
a127 1
  
d134 2
a135 2
  obj_elf_section_change_hook();
  
d137 1
a137 1
  
d144 2
a145 2
  obj_elf_section_change_hook();
  
d147 1
a147 1
  
d154 2
a155 2
  obj_elf_section_change_hook();
  
d157 1
a157 1
  
d164 2
a165 2
  obj_elf_section_change_hook();
  
d167 1
a167 1
  
d174 2
a175 2
  obj_elf_section_change_hook();
  
d177 1
a177 1
  
d184 2
a185 2
  obj_elf_section_change_hook();
  
d187 1
a187 1
  
d194 2
a195 2
  obj_elf_section_change_hook();
  
d197 1
a197 1
  
d204 2
a205 2
  obj_elf_section_change_hook();
  
d207 1
a207 1
  
d216 2
a217 2
  obj_elf_section_change_hook();
  
d219 1
a219 1
   
d227 3
a229 3
  
  temp -= frag_now_fix();
  
d232 1
a232 1
  
d236 2
a237 1
/* Copied from obj_elf_common() in gas/config/obj-elf.c */
d242 7
a248 7
  char *    name;
  char      c;
  char *    p;
  int       temp;
  unsigned int       size;
  symbolS * symbolP;
  int       have_align;
d252 2
a253 2
  
  /* just after name is now '\0' */
d256 1
a256 1
  
d258 1
a258 1
  
d265 4
a268 3
  
  input_line_pointer ++;		/* skip ',' */
  
d271 1
a271 1
      /* xgettext:c-format */
d276 1
a276 1
  
d281 1
a281 1
  
d288 1
a288 1
  
d293 1
a293 1
	  /* xgettext:c-format */
d298 3
a300 3
  
  know (symbol_get_frag (symbolP) == & zero_address_frag);
  
d309 1
a309 1
  
d317 1
a317 1
	  
d324 1
a324 1
      
d327 5
a331 5
	  segT   old_sec;
	  int    old_subsec;
	  char * pfrag;
	  int    align;
	  flagword	applicable;
d335 1
a335 1
      
d337 1
a337 1
		  
d339 1
a339 1
	  
d346 1
a346 1
	      
d348 1
a348 1
	      
d352 1
a352 1
	  
d357 1
a357 1
		  
d359 1
a359 1
	      
d363 1
a363 1
	  
d368 1
a368 1
		  
d370 1
a370 1
		  
d378 1
a378 1
	      /* convert to a power of 2 alignment */
d381 1
a381 1
	      
d391 1
a391 1
	  
d396 1
a396 1
	      obj_elf_section_change_hook();
d402 1
a402 1
	      obj_elf_section_change_hook();
d408 1
a408 1
	      obj_elf_section_change_hook();
d413 1
a413 1
	      abort();
d415 1
a415 1
	  
d439 1
a439 1
	  
d445 1
a445 1
	  
d451 1
a451 1
	      
d455 1
a455 1
	      
d459 1
a459 1
	      
d461 1
a461 1
	      abort();
d463 1
a463 1
	    
d465 1
a465 1
	  obj_elf_section_change_hook();
d474 1
a474 1
	  
d480 3
a482 4
		  flagword	applicable;
		  
		  applicable = bfd_applicable_section_flags (stdoutput);
		  
d484 1
a484 1
		  
d492 1
a492 1
	      
d496 3
a498 4
		  flagword	applicable;
		  
		  applicable = bfd_applicable_section_flags (stdoutput);
		  
d500 1
a500 1
		  
d508 1
a508 1
	      
d512 3
a514 4
		  flagword	applicable;
		  
		  applicable = bfd_applicable_section_flags (stdoutput);
		  
d516 1
a516 1
		  
d518 5
a522 3
					 (applicable
		     & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
			| SEC_HAS_CONTENTS)) | SEC_IS_COMMON);
d526 1
a526 1
	      
d528 1
a528 1
	      abort();
d535 1
d539 1
d582 2
a583 2
    case 0: processor_mask = PROCESSOR_V850; break;
    case bfd_mach_v850e:  processor_mask = PROCESSOR_V850E; break;
d616 1
a616 1
/* This table is sorted. Suitable for searching by a binary search. */
d620 3
a622 3
  { "gp",   4 },		/* gp - global ptr */
  { "hp",   2 },		/* hp - handler stack ptr */
  { "lp",  31 },		/* lp - link ptr */
d655 2
a656 2
  { "sp",   3 },		/* sp - stack ptr */
  { "tp",   5 },		/* tp - text ptr */
a658 1
#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct reg_name))
d660 2
d663 1
a663 1
static const struct reg_name system_registers[] = 
d677 3
a679 1
#define SYSREG_NAME_CNT	(sizeof (system_registers) / sizeof (struct reg_name))
d686 3
a688 1
#define SYSREGLIST_NAME_CNT	(sizeof (system_list_registers) / sizeof (struct reg_name))
a714 1
#define CC_NAME_CNT	(sizeof (cc_names) / sizeof (struct reg_name))
d716 6
a721 3
/* reg_name_search does a binary search of the given register table
   to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure. */
d725 4
a728 4
     const struct reg_name * regs;
     int                     regcount;
     const char *            name;
     boolean                 accept_numbers;
d732 1
a732 1
  symbolS * symbolP;
d741 2
a742 1
	  name = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
d747 1
a747 1
	  
d754 1
a754 1
  
a772 1

d781 2
a782 2
 *	its original state.
 */
d785 1
a785 1
     expressionS * expressionP;
d787 4
a790 4
  int    reg_number;
  char * name;
  char * start;
  char   c;
d792 1
a792 1
  /* Find the spelling of the operand */
d800 5
a804 4
  * input_line_pointer = c;	/* put back the delimiting char */
  
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d809 1
a809 1
      /* make the rest nice */
d812 1
a812 1
      
d817 1
a817 1
      /* reset the line as if we had not done anything */
d819 1
a819 1
      
d826 4
a829 4
 * in:  Input_line_pointer points to 1st char of operand.
 *      expressionP points to an expression structure to be filled in.
 *      accept_numbers is true iff numerical register names may be used.
 *      accept_list_names is true iff the special names PS and SR may be 
d836 2
a837 2
 *	its original state.
 */
d840 8
a847 8
     expressionS * expressionP;
     boolean       accept_numbers;
     boolean       accept_list_names;
{
  int    reg_number;
  char * name;
  char * start;
  char   c;
d849 1
a849 1
  /* Find the spelling of the operand */
d856 3
a858 2
  * input_line_pointer = c;   /* put back the delimiting char */
  
d862 2
a863 1
      input_line_pointer   = start; /* reset input_line pointer */
d865 1
a865 1
      if (isdigit (* input_line_pointer))
d867 1
a867 1
	  reg_number = strtol (input_line_pointer, & input_line_pointer, 10);
d869 2
a870 2
	  /* Make sure that the register number is allowable. */
	  if (   reg_number < 0
d872 1
a872 2
	      || reg_number > 20
	      )
d883 2
a884 1
	  * input_line_pointer = c;   /* put back the delimiting char */
d887 3
a889 3
  
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d894 1
a894 1
      /* make the rest nice */
d902 1
a902 1
      /* reset the line as if we had not done anything */
d904 1
a904 1
      
d911 1
a911 1
 * in: Input_line_pointer points to 1st char of operand.
d917 2
a918 2
 *	its original state.
 */
d921 1
a921 1
     expressionS * expressionP;
d923 4
a926 4
  int    reg_number;
  char * name;
  char * start;
  char   c;
d928 1
a928 1
  /* Find the spelling of the operand */
d934 5
a938 4
  * input_line_pointer = c;   /* put back the delimiting char */
  
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d943 1
a943 1
      /* make the rest nice */
d951 1
a951 1
      /* reset the line as if we had not done anything */
d953 1
a953 1
      
d961 3
a963 3
  while (   * input_line_pointer == ' '
	 || * input_line_pointer == '\t')
    ++ input_line_pointer;
d968 3
a970 3
 * in: Input_line_pointer  points to 1st char of a list of registers.
 *     insn                is the partially constructed instruction.
 *     operand             is the operand being inserted.
d989 2
a990 3
 * high numbers.
 * 
 */
d992 17
a1008 10
parse_register_list
(
  unsigned long *             insn,
  const struct v850_operand * operand
)
{
  static int  type1_regs[ 32 ] = { 30,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24 };
  static int  type2_regs[ 32 ] = { 19, 18, 17, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24 };
  static int  type3_regs[ 32 ] = {  3,  2,  1,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 13, 12,  7,  6,  5,  4, 11, 10,  9,  8 };
  int *       regs;
d1011 1
a1011 2

  /* Select a register array to parse. */
d1027 2
a1028 2
  
  if (* input_line_pointer != '{')
d1032 3
a1034 3
		
      expression (& exp);
      
d1042 2
a1043 2
	  
	  for (reg = 20; reg < 32; reg ++)
d1048 1
a1048 1
		    * insn |= (1 << i);
d1055 2
a1056 2
	  
	  for (reg = 1; reg < 16; reg ++)
d1061 1
a1061 1
		    * insn |= (1 << i);
d1065 2
a1066 2
	    * insn |= (1 << 3);
	  
d1068 1
a1068 1
	    * insn |= (1 << 19);
d1070 1
a1070 1
      else /* regs == type3_regs */
d1074 2
a1075 2
	  
	  for (reg = 16; reg < 32; reg ++)
d1080 1
a1080 1
		    * insn |= (1 << i);
d1084 1
a1084 1
	    * insn |= (1 << 19);
d1090 1
a1090 1
  input_line_pointer ++;
d1096 1
a1096 1
      if (register_name (& exp))
d1098 2
a1099 2
	  int  i;
	  
d1104 1
a1104 1
	      if (regs[ i ] == exp.X_add_number)
d1106 1
a1106 1
		  * insn |= (1 << i);
d1116 1
a1116 1
      else if (system_register_name (& exp, true, true))
d1127 1
a1127 1
		* insn |= 0x8;
d1130 1
a1130 1
	    * insn |= 0x80000;
d1134 1
a1134 1
      else if (* input_line_pointer == '}')
d1136 1
a1136 1
	  input_line_pointer ++;
d1139 1
a1139 1
      else if (* input_line_pointer == ',')
d1141 1
a1141 1
	  input_line_pointer ++;
d1144 1
a1144 1
      else if (* input_line_pointer == '-')
d1146 2
a1147 2
	  /* We have encountered a range of registers: rX - rY */
	  int         j;
d1151 1
a1151 1
	  ++ input_line_pointer;
d1154 1
a1154 1
	  if (! register_name (& exp2))
d1163 2
a1164 2
	      int  i;
	  
d1169 1
a1169 1
		  if (regs[ i ] == j)
d1171 1
a1171 1
		      * insn |= (1 << i);
d1191 1
a1191 1
CONST char * md_shortopts = "m:";
a1196 1
size_t md_longopts_size = sizeof md_longopts; 
d1198 1
d1202 1
a1202 1
  FILE * stream;
d1215 2
a1216 2
     int    c;
     char * arg;
d1221 1
a1221 1
	/* xgettext:c-format */
d1251 5
a1255 2
      machine = 0;                       /* Tell the world that this is for any v850 chip.  */
      processor_mask = PROCESSOR_V850EA; /* But support instructions for the extended versions.  */
d1259 1
a1259 1
      /* xgettext:c-format */
d1263 1
a1263 1
  
d1269 1
a1269 1
  char * name ATTRIBUTE_UNUSED;
d1276 3
a1278 3
  int    type;
  char * litp;
  int *  sizep;
d1280 1
a1280 1
  int            prec;
d1282 2
a1283 2
  char *         t;
  int            i;
d1299 1
a1299 1
  
d1315 1
a1316 1
/* Very gross.  */
d1319 3
a1321 3
  bfd *      abfd ATTRIBUTE_UNUSED;
  asection * sec;
  fragS *    fragP;
d1324 1
a1324 1
  
d1336 1
a1336 1
      unsigned char *buffer = 
d1373 2
a1374 2
     asection * seg;
     valueT     addr;
d1383 3
a1385 3
  char *                              prev_name = "";
  register const struct v850_opcode * op;
  flagword                            applicable;
d1391 1
a1391 1
      
d1398 2
a1399 2
	machine        = bfd_mach_v850e;
      
d1403 1
a1403 2
  else
  if (strncmp (TARGET_CPU, "v850", 4) == 0)
d1406 2
a1407 2
	machine        = 0;
      
d1412 2
a1413 2
    /* xgettext:c-format */
    as_bad (_("Unable to determine default target processor from string: %s"), 
d1426 1
a1426 1
      if (strcmp (prev_name, op->name)) 
d1437 1
a1437 1
  
d1442 1
a1442 1
  
d1447 1
a1447 1
  
a1451 1

d1453 1
a1453 1
handle_ctoff (const struct v850_operand * operand)
d1458 1
a1458 1
  if (   operand->bits  != 6
d1464 1
a1464 1
      
d1469 1
a1469 1
handle_sdaoff (const struct v850_operand * operand)
d1471 10
a1480 5
  if (operand == NULL)                             return BFD_RELOC_V850_SDA_16_16_OFFSET;
  if (operand->bits == 15 && operand->shift == 17) return BFD_RELOC_V850_SDA_15_16_OFFSET;
  if (operand->bits == -1)                         return BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET;
  
  if (   operand->bits  != 16
d1486 1
a1486 1
  
d1491 1
a1491 1
handle_zdaoff (const struct v850_operand * operand)
d1493 8
a1500 3
  if (operand == NULL)                             return BFD_RELOC_V850_ZDA_16_16_OFFSET;
  if (operand->bits == 15 && operand->shift == 17) return BFD_RELOC_V850_ZDA_15_16_OFFSET;
  if (operand->bits == -1)                         return BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET;
d1502 1
a1502 1
  if (   operand->bits  != 16
d1506 2
a1507 1
      return BFD_RELOC_64;  /* Used to indicate an error condition.  */
d1509 1
a1509 1
  
d1514 1
a1514 1
handle_tdaoff (const struct v850_operand * operand)
d1516 20
a1535 6
  if (operand == NULL)                               return BFD_RELOC_V850_TDA_7_7_OFFSET;  /* data item, not an instruction.  */
  if (operand->bits == 6 && operand->shift == 1)     return BFD_RELOC_V850_TDA_6_8_OFFSET;  /* sld.w/sst.w, operand: D8_6  */
  if (operand->bits == 4 && operand->insert != NULL) return BFD_RELOC_V850_TDA_4_5_OFFSET;  /* sld.hu, operand: D5-4 */
  if (operand->bits == 4 && operand->insert == NULL) return BFD_RELOC_V850_TDA_4_4_OFFSET;  /* sld.bu, operand: D4   */
  if (operand->bits == 16 && operand->shift == 16)   return BFD_RELOC_V850_TDA_16_16_OFFSET; /* set1 & chums, operands: D16 */
  
d1539 2
a1540 1
      return BFD_RELOC_64;  /* Used to indicate an error condition.  */
d1542 1
a1542 1
  
d1544 2
a1545 2
    ? BFD_RELOC_V850_TDA_7_8_OFFSET     /* sld.h/sst.h, operand: D8_7 */
    : BFD_RELOC_V850_TDA_7_7_OFFSET;    /* sld.b/sst.b, opreand: D7   */
d1553 1
a1553 1
v850_reloc_prefix (const struct v850_operand * operand)
a1556 1

d1558 1
a1558 1
  if (* input_line_pointer == '(')
d1560 1
a1560 1
      ++ input_line_pointer;
d1570 4
a1573 4
  
  CHECK_ ("hi0",    BFD_RELOC_HI16);
  CHECK_ ("hi",     BFD_RELOC_HI16_S);
  CHECK_ ("lo",     BFD_RELOC_LO16);
d1577 3
a1579 3
  CHECK_ ("hilo",   BFD_RELOC_32);
  CHECK_ ("ctoff",  handle_ctoff (operand));
  
d1582 2
a1583 2
    -- input_line_pointer;
  
d1591 6
a1596 6
     unsigned long               insn;
     const struct v850_operand * operand;
     offsetT                     val;
     char *                      file;
     unsigned int                line;
     char *                      str;
d1600 3
a1602 3
      const char * message = NULL;
      
      insn = operand->insert (insn, val, & message);
d1609 1
a1609 1
	      /* skip warning... */
d1615 1
a1615 1
	      /* skip warning... */
d1637 1
a1637 1
	  long  min, max;
d1645 2
a1646 2
	      
	      min = - (1 << (operand->bits - 1));
d1651 1
a1651 1
	      
d1653 1
a1653 1
		min = - (1 << (operand->bits - 1));
d1657 1
a1657 1
	  
d1660 5
a1664 4
	      /* xgettext:c-format */
	      const char * err = _("operand out of range (%s not between %ld and %ld)");
	      char         buf[100];
	      
d1677 1
a1677 1
		  
d1682 1
a1682 1
	      
d1692 1
a1692 1
  
a1694 1

d1696 1
a1696 1
static char                 copy_of_instruction [128];
d1699 2
a1700 2
md_assemble (str) 
     char * str;
d1702 16
a1717 16
  char *                    s;
  char *                    start_of_operands;
  struct v850_opcode *      opcode;
  struct v850_opcode *      next_opcode;
  const unsigned char *     opindex_ptr;
  int                       next_opindex;
  int                       relaxable = 0;
  unsigned long             insn;
  unsigned long             insn_size;
  char *                    f;
  int                       i;
  int                       match;
  boolean                   extra_data_after_insn = false;
  unsigned                  extra_data_len = 0;
  unsigned long             extra_data = 0;
  char *		    saved_input_line_pointer;
a1718 1
  
d1720 1
a1720 1
  
d1724 1
a1724 1
  
d1728 1
a1728 1
  /* find the first opcode with the proper name */
d1732 1
a1732 1
      /* xgettext:c-format */
d1739 2
a1740 2
  while (isspace (* str))
    ++ str;
d1745 1
a1745 1
  
d1748 1
a1748 1
      const char * errmsg = NULL;
d1751 1
a1751 1
      
d1757 1
a1757 1
      
d1766 1
a1766 1
      for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr ++)
d1768 4
a1771 4
	  const struct v850_operand * operand;
	  char *                      hold;
	  expressionS                 ex;
	  bfd_reloc_code_real_type    reloc;
d1775 1
a1775 1
	      operand = & v850_operands[ * opindex_ptr ];
d1779 1
a1779 1
	      operand      = & v850_operands[ next_opindex ];
d1786 1
a1786 1
	    ++ str;
d1791 1
a1791 1
	  /* Gather the operand. */
d1794 2
a1795 2
	  
	  /* lo(), hi(), hi0(), etc... */
d1804 2
a1805 2
		 
	      expression (& ex);
d1815 1
a1815 1
		      
d1833 1
a1833 1
		        int temp = (ex.X_add_number >> 16) & 0xffff;
d1840 1
a1840 1
		    
d1847 1
a1847 1
		      
d1853 1
a1853 1
		      
d1862 4
a1865 4
		  
		  fixups[ fc ].exp     = ex;
		  fixups[ fc ].opindex = * opindex_ptr;
		  fixups[ fc ].reloc   = reloc;
d1877 1
a1877 1
		      
d1882 1
a1882 1
		      
d1886 3
a1888 3
		  fixups[ fc ].exp     = ex;
		  fixups[ fc ].opindex = * opindex_ptr;
		  fixups[ fc ].reloc   = reloc;
d1895 2
a1896 2
	      
	      if ((operand->flags & V850_OPERAND_REG) != 0) 
d1898 1
a1898 1
		  if (!register_name (& ex))
d1903 1
a1903 1
		      && ex.X_add_number == 0)
d1906 1
a1906 1
		      
d1913 1
a1913 1
	      else if ((operand->flags & V850_OPERAND_SRG) != 0) 
d1915 1
a1915 1
		  if (!system_register_name (& ex, true, false))
d1922 3
a1924 3
		  char * start = input_line_pointer;
		  char   c     = get_symbol_end ();
		  
d1933 1
a1933 1
		  
d1937 4
a1940 3
	      
		  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']')
		    ++ str;
d1943 1
a1943 1
	      else if ((operand->flags & V850_OPERAND_CC) != 0) 
d1945 1
a1945 1
		  if (!cc_name (& ex))
d1950 1
a1950 1
	      else if (operand->flags & V850E_PUSH_POP) 
d1952 2
a1953 2
		  errmsg = parse_register_list (& insn, operand);
		  
d1959 1
a1959 1
	      else if (operand->flags & V850E_IMMEDIATE16) 
d1961 1
a1961 1
		  expression (& ex);
d1974 1
a1974 1
		  
d1980 1
a1980 1
	      else if (operand->flags & V850E_IMMEDIATE32) 
d1982 2
a1983 2
		  expression (& ex);
		  
d1986 1
a1986 1
		  
d1992 1
a1992 1
	      else if (register_name (& ex)
d1996 2
a1997 2
		  int  exists = 0;
		  
d2008 1
a2008 1
		  
d2011 2
a2012 2
		  
		  * input_line_pointer = c;
d2014 2
a2015 2
		  
		  expression (& ex);
d2023 2
a2024 1
			  && (v850_operands [opindex_ptr [1]].flags & V850_OPERAND_REG))
d2029 3
a2031 3
		      /* If we created a symbol in the process of this test then
			 delete it now, so that it will not be output with the real
			 symbols... */
d2035 1
a2035 1
				       & symbol_rootP, & symbol_lastP);
d2038 1
a2038 1
	      else if (system_register_name (& ex, false, false)
d2050 1
a2050 1
		  expression (& ex);
d2060 1
a2060 1
		      && (ex.X_add_number < (- (1 << (operand->bits - 1)))
a2066 3
	      
/* fprintf (stderr, " insn: %x, operand %d, op: %d, add_number: %d\n",
   insn, opindex_ptr - opcode->operands, ex.X_op, ex.X_add_number); */
d2068 8
a2075 1
	      switch (ex.X_op) 
d2084 2
a2085 1
		  if ((operand->flags & (V850_OPERAND_REG | V850_OPERAND_SRG)) == 0)
d2106 3
a2108 3
		  fixups[ fc ].exp     = ex;
		  fixups[ fc ].opindex = * opindex_ptr;
		  fixups[ fc ].reloc   = BFD_RELOC_UNUSED;
d2125 1
a2125 1
        {
d2136 1
a2136 1
	      
d2139 1
a2139 1
	  
d2141 4
a2144 4
	  
	  if (* input_line_pointer == ']')
	    ++ input_line_pointer;
	  
d2148 1
a2148 1
        }
d2151 1
a2151 1
      
d2156 1
a2156 1
    /* xgettext:c-format */
d2161 2
a2162 2
  /* Write out the instruction. */
  
d2173 1
a2173 1
			(char *)fixups[0].opindex);
d2182 1
a2182 1
			(char *)fixups[0].opindex);
d2187 1
a2187 1
  else 
d2195 1
a2195 1
      /* Special case: 32 bit MOV */
d2198 1
a2198 1
      
d2200 1
a2200 1
      
d2206 1
a2206 1
	  
d2218 1
a2218 1
     md_apply_fix.  */  
d2221 4
a2224 4
      const struct v850_operand * operand;
      bfd_reloc_code_real_type    reloc;
      
      operand = & v850_operands[ fixups[i].opindex ];
d2227 1
a2227 1
      
d2230 5
a2234 5
	  reloc_howto_type * reloc_howto = bfd_reloc_type_lookup (stdoutput,
								  reloc);
	  int                size;
	  int                address;
	  fixS *             fixP;
d2237 2
a2238 2
	    abort();
	  
d2242 2
a2243 2
	     is this reloc actually used ? */
	  if (size != 2 && size != 4) 
d2249 2
a2250 4
	    {
	      address += 2;
	    }
	  
d2252 1
a2252 1
			      & fixups[i].exp, 
d2269 1
a2269 2
	  fix_new_exp (
		       frag_now,
d2272 1
a2272 1
		       1 /* FIXME: V850_OPERAND_RELATIVE ??? */,
d2274 1
a2274 2
						   + (int) BFD_RELOC_UNUSED)
		       );
d2281 2
a2283 3
/* If while processing a fixup, a reloc really needs to be created */
/* then it is done here.  */
                 
d2286 2
a2287 2
     asection * seg ATTRIBUTE_UNUSED;
     fixS *     fixp;
d2289 7
a2295 7
  arelent * reloc;
  
  reloc              = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr= symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address     = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto       = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
d2300 2
a2301 2
		    /* xgettext:c-format */
                    _("reloc %d not supported by object file format"),
d2305 1
a2305 1
      
d2308 2
a2309 2
  
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
d2314 1
a2314 1
  
d2319 1
d2322 2
a2323 2
     fragS * fragp;
     asection * seg ATTRIBUTE_UNUSED;
d2332 1
a2332 1
} 
d2336 2
a2337 2
     fixS * fixp;
     segT   section;
d2347 1
a2347 1
  
d2353 3
a2355 3
     fixS *   fixp;
     valueT * valuep;
     segT     seg ATTRIBUTE_UNUSED;
d2358 1
a2358 1
  char * where;
d2360 1
a2360 1
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2369 1
a2369 1
      value = * valuep;
d2373 1
a2373 1
    value = * valuep;
d2392 3
a2394 3
      int                         opindex;
      const struct v850_operand * operand;
      unsigned long               insn;
d2397 1
a2397 1
      operand = & v850_operands[ opindex ];
d2413 1
a2413 1
	  /* Nothing else to do here. */
d2417 2
a2418 2
      /* Determine a BFD reloc value based on the operand information.  
	 We are only prepared to turn a few of the operands into relocs. */
d2426 4
a2429 2
	  /* fprintf (stderr, "bits: %d, insn: %x\n", operand->bits, insn); */
	  
d2431 1
a2431 1
		       _("unresolved expression that must be resolved"));
d2442 1
a2442 1
	* where = value & 0xff;
d2448 1
a2448 1
  
a2451 1

d2455 1
d2458 1
a2458 1
  expressionS * exp;
d2470 1
d2473 1
a2473 1
     fragS * frag;
d2496 1
a2496 1
    fixS * fixP;
d2500 2
a2501 2
 
  /* Prevent all adjustments to global symbols. */
d2504 1
a2504 1
  
d2508 2
a2509 2
  
  /* Don't adjust function names */
d2513 2
a2514 2
  /* We need the symbol name for the VTABLE entries */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2517 1
a2517 1
  
d2520 1
a2520 1
 
d2523 1
a2523 1
      struct fix * fixP;
d2527 2
a2528 2
  
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2531 1
a2531 1
 
@


1.7
log
@Do not attempt to fixup relocs relative to weak symbols
@
text
@d45 1
a45 1
static unsigned int	processor_mask = -1;
d115 1
a115 1
v850_sdata (int ignore)
d125 1
a125 1
v850_tdata (int ignore)
d135 1
a135 1
v850_zdata (int ignore)
d145 1
a145 1
v850_sbss (int ignore)
d155 1
a155 1
v850_tbss (int ignore)
d165 1
a165 1
v850_zbss (int ignore)
d175 1
a175 1
v850_rosdata (int ignore)
d185 1
a185 1
v850_rozdata (int ignore)
d195 1
a195 1
v850_call_table_data (int ignore)
d205 1
a205 1
v850_call_table_text (int ignore)
d215 1
a215 1
v850_bss (int ignore)
d227 1
a227 1
v850_offset (int ignore)
d248 1
a248 1
  int       size;
d487 2
a488 1
		  bfd_set_section_flags (stdoutput, scommon_section, applicable
d490 1
a490 1
			| SEC_HAS_CONTENTS) | SEC_IS_COMMON);
d504 2
a505 1
		  bfd_set_section_flags (stdoutput, zcommon_section, applicable
d507 1
a507 1
			| SEC_HAS_CONTENTS) | SEC_IS_COMMON);
d521 2
a522 1
		  bfd_set_section_flags (stdoutput, tcommon_section, applicable
d524 1
a524 1
			| SEC_HAS_CONTENTS) | SEC_IS_COMMON);
d861 3
a863 4
		 || reg_number > 5
		 && reg_number < 16
		 || reg_number > 20
		 )
a1013 1
      int bits;
d1204 3
a1206 2
      /* xgettext:c-format */
      fprintf (stderr, _("unknown command line option: -%c%s\n"), c, arg);
d1250 1
a1250 1
  char * name;
d1300 1
a1300 1
  bfd *      abfd;
d1595 1
a1595 2
	  long    min, max;
	  offsetT test;
d1666 1
a1666 1
  int                       relaxable;
d1673 2
a1674 2
  unsigned                  extra_data_len;
  unsigned long             extra_data;
d2217 2
d2243 1
a2243 1
     asection * seg;
d2279 1
a2279 1
     asection * seg;
d2311 1
a2311 1
     segT     seg;
d2458 1
@


1.6
log
@Use symbol_get_obj() rather than accessing symbolP directly.
@
text
@d2263 1
a2263 1
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
d2293 1
d2297 1
d2299 2
a2300 6
    {
      /* The symbol is undefined/not in our section.
	 Let the linker figure it out.  */
      return 0;
    }

d2313 1
a2313 1
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2409 1
a2409 1
  expressionS *exp;
d2423 1
a2423 1
     fragS *frag;
d2443 1
d2446 1
a2446 1
    fixS *fixP;
a2447 1
 
d2454 1
d2457 1
d2463 1
a2463 1
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2466 1
a2466 1
 
d2471 2
a2472 2
v850_force_relocation (fixp)
      struct fix *fixp;
d2474 5
a2478 2
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
@


1.5
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d326 1
a326 1
      if (symbolP->local)
d438 1
a438 1
	      abort();
@


1.4
log
@	* config/tc-arc.c (get_arc_exp_reloc_type): Change uses of
	sy_value with appropriate accessor functions.
	* config/tc-arm.c (md_apply_fix3): Likewise.
	* config/tc-d10v.c (AT_WORD_P): Likewise.
	* config/tc-v850.c (reg_name_search): Likewise.
@
text
@d300 1
a300 1
  know (symbolP->sy_frag == & zero_address_frag);
d424 1
a424 1
		symbolP->sy_frag->fr_symbol = 0;
d429 1
a429 1
		symbolP->sy_frag->fr_symbol = 0;
d434 1
a434 1
		symbolP->sy_frag->fr_symbol = 0;
d441 1
a441 1
	  symbolP->sy_frag = frag_now;
@


1.3
log
@	* config/obj-ecoff.c (obj_ecoff_set_ext): Change uses of bsym to
	use symbol_get_bfdsym instead.
	* config/tc-ppc.c (md_assemble): Likewise.
	* config/tc-v850.c (v850_comm): Likewise.
@
text
@d729 1
a729 1
      if (symbolP->sy_value.X_op == O_symbol)
d731 1
a731 1
	  name = S_GET_NAME (symbolP->sy_value.X_add_symbol);
@


1.2
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d551 1
a551 1
  symbolP->bsym->flags |= BSF_OBJECT;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation.
d2246 2
a2247 1
  reloc->sym_ptr_ptr = & fixp->fx_addsy->bsym;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

