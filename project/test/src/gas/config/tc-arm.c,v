head	1.580;
access;
symbols
	binutils-2_24-branch:1.578.0.2
	binutils-2_24-branchpoint:1.578
	binutils-2_21_1:1.471.2.3
	binutils-2_23_2:1.523.2.6
	binutils-2_23_1:1.523.2.2
	binutils-2_23:1.523.2.2
	binutils-2_23-branch:1.523.0.2
	binutils-2_23-branchpoint:1.523
	binutils-2_22_branch:1.500.2.1.0.2
	binutils-2_22:1.500.2.1
	binutils-2_22-branch:1.500.0.2
	binutils-2_22-branchpoint:1.500
	binutils-2_21:1.471.2.2
	binutils-2_21-branch:1.471.0.2
	binutils-2_21-branchpoint:1.471
	binutils-2_20_1:1.403.2.3
	binutils-2_20:1.403
	binutils-arc-20081103-branch:1.361.0.6
	binutils-arc-20081103-branchpoint:1.361
	binutils-2_20-branch:1.403.0.2
	binutils-2_20-branchpoint:1.403
	dje-cgen-play1-branch:1.389.0.2
	dje-cgen-play1-branchpoint:1.389
	arc-20081103-branch:1.361.0.4
	arc-20081103-branchpoint:1.361
	binutils-2_19_1:1.361
	binutils-2_19:1.361
	binutils-2_19-branch:1.361.0.2
	binutils-2_19-branchpoint:1.361
	binutils-2_18:1.335.2.1
	binutils-2_18-branch:1.335.0.2
	binutils-2_18-branchpoint:1.335
	binutils-csl-coldfire-4_1-32:1.250.2.46
	binutils-csl-sourcerygxx-4_1-32:1.250.2.46
	binutils-csl-innovasic-fido-3_4_4-33:1.250.2.46
	binutils-csl-sourcerygxx-3_4_4-32:1.193.2.1
	binutils-csl-coldfire-4_1-30:1.250.2.44
	binutils-csl-sourcerygxx-4_1-30:1.250.2.44
	binutils-csl-coldfire-4_1-28:1.250.2.44
	binutils-csl-sourcerygxx-4_1-29:1.250.2.44
	binutils-csl-sourcerygxx-4_1-28:1.250.2.44
	binutils-csl-arm-2006q3-27:1.250.2.44
	binutils-csl-sourcerygxx-4_1-27:1.250.2.44
	binutils-csl-arm-2006q3-26:1.250.2.43
	binutils-csl-sourcerygxx-4_1-26:1.250.2.43
	binutils-csl-sourcerygxx-4_1-25:1.250.2.43
	binutils-csl-sourcerygxx-4_1-24:1.250.2.37
	binutils-csl-sourcerygxx-4_1-23:1.250.2.37
	binutils-csl-sourcerygxx-4_1-21:1.250.2.37
	binutils-csl-arm-2006q3-21:1.250.2.37
	binutils-csl-sourcerygxx-4_1-22:1.250.2.37
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.250.2.37
	binutils-csl-sourcerygxx-4_1-20:1.250.2.32
	binutils-csl-arm-2006q3-19:1.250.2.32
	binutils-csl-sourcerygxx-4_1-19:1.250.2.32
	binutils-csl-sourcerygxx-4_1-18:1.250.2.30
	binutils-csl-renesas-4_1-9:1.250.2.25
	binutils-csl-sourcerygxx-3_4_4-25:1.193.2.1
	binutils-csl-renesas-4_1-8:1.250.2.24
	binutils-csl-renesas-4_1-7:1.250.2.21
	binutils-csl-renesas-4_1-6:1.250.2.21
	binutils-csl-sourcerygxx-4_1-17:1.250.2.20
	binutils-csl-sourcerygxx-4_1-14:1.250.2.18
	binutils-csl-sourcerygxx-4_1-15:1.250.2.18
	binutils-csl-sourcerygxx-4_1-13:1.250.2.18
	binutils-2_17:1.256.2.2
	binutils-csl-sourcerygxx-4_1-12:1.250.2.18
	binutils-csl-sourcerygxx-3_4_4-21:1.250.2.18
	binutils-csl-wrs-linux-3_4_4-24:1.193.4.10
	binutils-csl-wrs-linux-3_4_4-23:1.193.4.10
	binutils-csl-sourcerygxx-4_1-9:1.250.2.16
	binutils-csl-sourcerygxx-4_1-8:1.250.2.16
	binutils-csl-sourcerygxx-4_1-7:1.250.2.16
	binutils-csl-arm-2006q1-6:1.250.2.16
	binutils-csl-sourcerygxx-4_1-6:1.250.2.16
	binutils-csl-wrs-linux-3_4_4-22:1.193.4.10
	binutils-csl-coldfire-4_1-11:1.250.2.16
	binutils-csl-sourcerygxx-3_4_4-19:1.250.2.16
	binutils-csl-coldfire-4_1-10:1.250.2.15
	binutils-csl-sourcerygxx-4_1-5:1.250.2.15
	binutils-csl-sourcerygxx-4_1-4:1.250.2.14
	binutils-csl-wrs-linux-3_4_4-21:1.193.4.10
	binutils-csl-morpho-4_1-4:1.250.2.11
	binutils-csl-sourcerygxx-3_4_4-17:1.250.2.9
	binutils-csl-wrs-linux-3_4_4-20:1.193.4.9
	binutils-2_17-branch:1.256.0.2
	binutils-2_17-branchpoint:1.256
	binutils-csl-2_17-branch:1.250.0.2
	binutils-csl-2_17-branchpoint:1.250
	binutils-csl-gxxpro-3_4-branch:1.193.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.193.2.1
	binutils-2_16_1:1.193.2.1
	binutils-csl-arm-2005q1b:1.193.4.8
	binutils-2_16:1.193
	binutils-csl-arm-2005q1a:1.193.4.4
	binutils-csl-arm-2005q1-branch:1.193.0.4
	binutils-csl-arm-2005q1-branchpoint:1.193
	binutils-2_16-branch:1.193.0.2
	binutils-2_16-branchpoint:1.193
	csl-arm-2004-q3d:1.185
	csl-arm-2004-q3:1.180
	binutils-2_15:1.163.2.1
	binutils-2_15-branchpoint:1.163
	csl-arm-2004-q1a:1.168
	csl-arm-2004-q1:1.165
	binutils-2_15-branch:1.163.0.2
	cagney_bfdfile-20040213-branch:1.162.0.2
	cagney_bfdfile-20040213-branchpoint:1.162
	cagney_bigcore-20040122-branch:1.160.0.2
	cagney_bigcore-20040122-branchpoint:1.160
	csl-arm-2003-q4:1.159
	binutils-2_14:1.140
	binutils-2_14-branch:1.140.0.2
	binutils-2_14-branchpoint:1.140
	binutils-2_13_2_1:1.124
	binutils-2_13_2:1.124
	binutils-2_13_1:1.124
	binutils-2_13:1.124
	binutils-2_13-branchpoint:1.124
	binutils-2_13-branch:1.124.0.2
	binutils-2_12_1:1.116.2.2
	binutils-2_12:1.116
	binutils-2_12-branch:1.116.0.2
	binutils-2_12-branchpoint:1.116
	cygnus_cvs_20020108_pre:1.105
	binutils-2_11_2:1.72.2.5
	binutils-2_11_1:1.72.2.5
	binutils-2_11:1.72.2.1
	x86_64versiong3:1.73
	binutils-2_11-branch:1.72.0.2
	binutils-2_10_1:1.39.2.6
	binutils-2_10:1.39.2.3
	binutils-2_10-branch:1.39.0.2
	binutils-2_10-branchpoint:1.39
	binutils_latest_snapshot:1.580
	repo-unification-2000-02-06:1.32
	binu_ss_19990721:1.12
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.580
date	2013.10.08.08.55.41;	author jbeulich;	state Exp;
branches;
next	1.579;

1.579
date	2013.10.04.15.26.17;	author ktkachov;	state Exp;
branches;
next	1.578;

1.578
date	2013.09.16.09.34.29;	author willnewton;	state Exp;
branches;
next	1.577;

1.577
date	2013.09.04.07.59.32;	author nickc;	state Exp;
branches;
next	1.576;

1.576
date	2013.08.23.07.16.56;	author willnewton;	state Exp;
branches;
next	1.575;

1.575
date	2013.07.22.09.05.04;	author ktkachov;	state Exp;
branches;
next	1.574;

1.574
date	2013.06.24.23.13.00;	author roland;	state Exp;
branches;
next	1.573;

1.573
date	2013.06.24.21.05.30;	author roland;	state Exp;
branches;
next	1.572;

1.572
date	2013.06.24.15.38.53;	author nickc;	state Exp;
branches;
next	1.571;

1.571
date	2013.06.19.13.26.04;	author ktkachov;	state Exp;
branches;
next	1.570;

1.570
date	2013.06.18.14.41.09;	author rearnsha;	state Exp;
branches;
next	1.569;

1.569
date	2013.05.28.14.58.51;	author ktkachov;	state Exp;
branches;
next	1.568;

1.568
date	2013.04.10.13.20.04;	author jbeulich;	state Exp;
branches;
next	1.567;

1.567
date	2013.04.10.13.18.32;	author jbeulich;	state Exp;
branches;
next	1.566;

1.566
date	2013.04.09.11.07.06;	author jbeulich;	state Exp;
branches;
next	1.565;

1.565
date	2013.04.09.11.05.45;	author jbeulich;	state Exp;
branches;
next	1.564;

1.564
date	2013.04.09.11.04.24;	author jbeulich;	state Exp;
branches;
next	1.563;

1.563
date	2013.04.08.11.07.38;	author jbeulich;	state Exp;
branches;
next	1.562;

1.562
date	2013.04.08.11.06.30;	author jbeulich;	state Exp;
branches;
next	1.561;

1.561
date	2013.03.28.11.00.15;	author ramana;	state Exp;
branches;
next	1.560;

1.560
date	2013.03.21.18.39.34;	author willnewton;	state Exp;
branches;
next	1.559;

1.559
date	2013.03.15.15.53.38;	author willnewton;	state Exp;
branches;
next	1.558;

1.558
date	2013.03.14.10.23.13;	author nickc;	state Exp;
branches;
next	1.557;

1.557
date	2013.03.11.11.09.30;	author ktkachov;	state Exp;
branches;
next	1.556;

1.556
date	2013.02.25.02.53.40;	author xguo;	state Exp;
branches;
next	1.555;

1.555
date	2013.02.15.10.07.45;	author nickc;	state Exp;
branches;
next	1.554;

1.554
date	2013.02.08.17.07.03;	author nickc;	state Exp;
branches;
next	1.553;

1.553
date	2013.02.08.16.57.41;	author nickc;	state Exp;
branches;
next	1.552;

1.552
date	2013.01.29.17.33.22;	author roland;	state Exp;
branches;
next	1.551;

1.551
date	2013.01.07.12.49.11;	author nickc;	state Exp;
branches;
next	1.550;

1.550
date	2013.01.02.13.38.55;	author nickc;	state Exp;
branches;
next	1.549;

1.549
date	2012.12.20.16.19.51;	author rearnsha;	state Exp;
branches;
next	1.548;

1.548
date	2012.11.28.16.52.59;	author jules;	state Exp;
branches;
next	1.547;

1.547
date	2012.11.20.17.53.45;	author roland;	state Exp;
branches;
next	1.546;

1.546
date	2012.11.09.18.07.10;	author macro;	state Exp;
branches;
next	1.545;

1.545
date	2012.10.11.15.26.16;	author rearnsha;	state Exp;
branches;
next	1.544;

1.544
date	2012.09.18.14.52.42;	author rearnsha;	state Exp;
branches;
next	1.543;

1.543
date	2012.08.24.08.14.39;	author mgretton;	state Exp;
branches;
next	1.542;

1.542
date	2012.08.24.08.14.03;	author mgretton;	state Exp;
branches;
next	1.541;

1.541
date	2012.08.24.08.13.23;	author mgretton;	state Exp;
branches;
next	1.540;

1.540
date	2012.08.24.08.12.43;	author mgretton;	state Exp;
branches;
next	1.539;

1.539
date	2012.08.24.08.11.43;	author mgretton;	state Exp;
branches;
next	1.538;

1.538
date	2012.08.24.08.11.13;	author mgretton;	state Exp;
branches;
next	1.537;

1.537
date	2012.08.24.08.09.47;	author mgretton;	state Exp;
branches;
next	1.536;

1.536
date	2012.08.24.08.09.01;	author mgretton;	state Exp;
branches;
next	1.535;

1.535
date	2012.08.24.08.07.34;	author mgretton;	state Exp;
branches;
next	1.534;

1.534
date	2012.08.24.08.06.35;	author mgretton;	state Exp;
branches;
next	1.533;

1.533
date	2012.08.24.08.03.38;	author mgretton;	state Exp;
branches;
next	1.532;

1.532
date	2012.08.24.08.02.51;	author mgretton;	state Exp;
branches;
next	1.531;

1.531
date	2012.08.24.08.02.09;	author mgretton;	state Exp;
branches;
next	1.530;

1.530
date	2012.08.24.08.01.17;	author mgretton;	state Exp;
branches;
next	1.529;

1.529
date	2012.08.24.08.00.19;	author mgretton;	state Exp;
branches;
next	1.528;

1.528
date	2012.08.24.07.58.02;	author mgretton;	state Exp;
branches;
next	1.527;

1.527
date	2012.08.24.07.57.18;	author mgretton;	state Exp;
branches;
next	1.526;

1.526
date	2012.08.24.07.54.44;	author mgretton;	state Exp;
branches;
next	1.525;

1.525
date	2012.08.24.07.52.48;	author mgretton;	state Exp;
branches;
next	1.524;

1.524
date	2012.08.24.07.50.31;	author mgretton;	state Exp;
branches;
next	1.523;

1.523
date	2012.07.24.16.38.32;	author sandra;	state Exp;
branches
	1.523.2.1;
next	1.522;

1.522
date	2012.06.29.15.15.48;	author nickc;	state Exp;
branches;
next	1.521;

1.521
date	2012.06.28.15.38.13;	author nickc;	state Exp;
branches;
next	1.520;

1.520
date	2012.06.13.14.19.00;	author nickc;	state Exp;
branches;
next	1.519;

1.519
date	2012.04.12.13.01.09;	author nickc;	state Exp;
branches;
next	1.518;

1.518
date	2012.04.12.07.46.52;	author nickc;	state Exp;
branches;
next	1.517;

1.517
date	2012.03.29.10.28.39;	author mgretton;	state Exp;
branches;
next	1.516;

1.516
date	2012.03.20.11.55.05;	author nickc;	state Exp;
branches;
next	1.515;

1.515
date	2012.03.16.14.00.35;	author mgretton;	state Exp;
branches;
next	1.514;

1.514
date	2012.03.13.16.59.55;	author roland;	state Exp;
branches;
next	1.513;

1.513
date	2011.12.21.17.07.26;	author nickc;	state Exp;
branches;
next	1.512;

1.512
date	2011.12.15.10.21.49;	author nickc;	state Exp;
branches;
next	1.511;

1.511
date	2011.12.07.16.58.34;	author mgretton;	state Exp;
branches;
next	1.510;

1.510
date	2011.12.07.16.46.34;	author mgretton;	state Exp;
branches;
next	1.509;

1.509
date	2011.12.07.16.44.55;	author mgretton;	state Exp;
branches;
next	1.508;

1.508
date	2011.12.05.15.43.52;	author rearnsha;	state Exp;
branches;
next	1.507;

1.507
date	2011.12.05.14.51.52;	author mgretton;	state Exp;
branches;
next	1.506;

1.506
date	2011.11.25.15.17.35;	author mgretton;	state Exp;
branches;
next	1.505;

1.505
date	2011.11.23.10.50.53;	author rearnsha;	state Exp;
branches;
next	1.504;

1.504
date	2011.11.07.16.20.47;	author mgretton;	state Exp;
branches;
next	1.503;

1.503
date	2011.11.02.11.13.57;	author nickc;	state Exp;
branches;
next	1.502;

1.502
date	2011.10.18.14.41.53;	author jules;	state Exp;
branches;
next	1.501;

1.501
date	2011.10.13.08.15.15;	author nickc;	state Exp;
branches;
next	1.500;

1.500
date	2011.08.03.11.35.55;	author nickc;	state Exp;
branches
	1.500.2.1;
next	1.499;

1.499
date	2011.08.01.11.27.14;	author nickc;	state Exp;
branches;
next	1.498;

1.498
date	2011.06.30.13.42.45;	author nickc;	state Exp;
branches;
next	1.497;

1.497
date	2011.06.30.12.52.58;	author nickc;	state Exp;
branches;
next	1.496;

1.496
date	2011.06.29.16.29.38;	author nickc;	state Exp;
branches;
next	1.495;

1.495
date	2011.06.21.15.34.26;	author mgretton;	state Exp;
branches;
next	1.494;

1.494
date	2011.06.13.12.50.18;	author nickc;	state Exp;
branches;
next	1.493;

1.493
date	2011.06.13.09.57.33;	author nickc;	state Exp;
branches;
next	1.492;

1.492
date	2011.06.09.09.59.33;	author rearnsha;	state Exp;
branches;
next	1.491;

1.491
date	2011.06.03.14.42.47;	author nickc;	state Exp;
branches;
next	1.490;

1.490
date	2011.06.02.15.32.08;	author nathan;	state Exp;
branches;
next	1.489;

1.489
date	2011.05.31.14.12.54;	author pbrook;	state Exp;
branches;
next	1.488;

1.488
date	2011.05.31.14.10.06;	author pbrook;	state Exp;
branches;
next	1.487;

1.487
date	2011.05.31.14.04.12;	author pbrook;	state Exp;
branches;
next	1.486;

1.486
date	2011.05.31.13.40.03;	author pbrook;	state Exp;
branches;
next	1.485;

1.485
date	2011.05.18.09.41.14;	author nickc;	state Exp;
branches;
next	1.484;

1.484
date	2011.05.12.12.41.44;	author mgretton;	state Exp;
branches;
next	1.483;

1.483
date	2011.05.11.09.25.41;	author nickc;	state Exp;
branches;
next	1.482;

1.482
date	2011.04.19.07.44.09;	author nickc;	state Exp;
branches;
next	1.481;

1.481
date	2011.04.19.07.27.28;	author nickc;	state Exp;
branches;
next	1.480;

1.480
date	2011.04.12.11.47.38;	author nickc;	state Exp;
branches;
next	1.479;

1.479
date	2011.04.11.18.49.03;	author jules;	state Exp;
branches;
next	1.478;

1.478
date	2011.03.14.16.04.12;	author rsandifo;	state Exp;
branches;
next	1.477;

1.477
date	2011.03.14.15.55.02;	author rsandifo;	state Exp;
branches;
next	1.476;

1.476
date	2011.01.18.14.10.44;	author nickc;	state Exp;
branches;
next	1.475;

1.475
date	2011.01.10.09.50.02;	author nickc;	state Exp;
branches;
next	1.474;

1.474
date	2011.01.10.08.40.17;	author nathan;	state Exp;
branches;
next	1.473;

1.473
date	2010.11.15.10.03.04;	author mgretton;	state Exp;
branches;
next	1.472;

1.472
date	2010.11.10.13.36.29;	author rsandifo;	state Exp;
branches;
next	1.471;

1.471
date	2010.10.23.18.05.08;	author mmitchel;	state Exp;
branches
	1.471.2.1;
next	1.470;

1.470
date	2010.10.06.08.22.21;	author nathan;	state Exp;
branches;
next	1.469;

1.469
date	2010.09.27.09.47.05;	author mgretton;	state Exp;
branches;
next	1.468;

1.468
date	2010.09.23.15.52.18;	author mgretton;	state Exp;
branches;
next	1.467;

1.467
date	2010.09.23.15.37.44;	author mgretton;	state Exp;
branches;
next	1.466;

1.466
date	2010.09.23.15.31.33;	author mgretton;	state Exp;
branches;
next	1.465;

1.465
date	2010.09.23.15.26.21;	author mgretton;	state Exp;
branches;
next	1.464;

1.464
date	2010.09.23.15.18.17;	author mgretton;	state Exp;
branches;
next	1.463;

1.463
date	2010.09.23.15.11.56;	author mgretton;	state Exp;
branches;
next	1.462;

1.462
date	2010.09.20.16.33.22;	author mgretton;	state Exp;
branches;
next	1.461;

1.461
date	2010.09.17.15.19.11;	author mgretton;	state Exp;
branches;
next	1.460;

1.460
date	2010.09.17.10.42.03;	author mgretton;	state Exp;
branches;
next	1.459;

1.459
date	2010.09.17.10.13.39;	author mgretton;	state Exp;
branches;
next	1.458;

1.458
date	2010.09.09.12.08.12;	author mgretton;	state Exp;
branches;
next	1.457;

1.457
date	2010.09.09.09.09.42;	author nickc;	state Exp;
branches;
next	1.456;

1.456
date	2010.09.09.07.40.11;	author nickc;	state Exp;
branches;
next	1.455;

1.455
date	2010.09.08.17.49.21;	author nathan;	state Exp;
branches;
next	1.454;

1.454
date	2010.08.25.05.59.13;	author jiez;	state Exp;
branches;
next	1.453;

1.453
date	2010.08.25.05.25.08;	author jiez;	state Exp;
branches;
next	1.452;

1.452
date	2010.07.08.22.40.26;	author rearnsha;	state Exp;
branches;
next	1.451;

1.451
date	2010.07.08.06.22.23;	author nathan;	state Exp;
branches;
next	1.450;

1.450
date	2010.07.01.10.02.44;	author mgretton;	state Exp;
branches;
next	1.449;

1.449
date	2010.06.28.14.06.56;	author amodra;	state Exp;
branches;
next	1.448;

1.448
date	2010.06.28.09.10.24;	author mgretton;	state Exp;
branches;
next	1.447;

1.447
date	2010.06.09.15.11.49;	author mgretton;	state Exp;
branches;
next	1.446;

1.446
date	2010.05.28.16.02.16;	author mgretton;	state Exp;
branches;
next	1.445;

1.445
date	2010.05.27.10.40.35;	author nickc;	state Exp;
branches;
next	1.444;

1.444
date	2010.05.13.08.15.02;	author nathan;	state Exp;
branches;
next	1.443;

1.443
date	2010.05.11.17.36.30;	author nickc;	state Exp;
branches;
next	1.442;

1.442
date	2010.04.29.14.44.14;	author nickc;	state Exp;
branches;
next	1.441;

1.441
date	2010.04.15.10.56.37;	author mgretton;	state Exp;
branches;
next	1.440;

1.440
date	2010.04.07.10.39.05;	author jiez;	state Exp;
branches;
next	1.439;

1.439
date	2010.03.19.14.43.09;	author jiez;	state Exp;
branches;
next	1.438;

1.438
date	2010.03.18.11.22.45;	author nickc;	state Exp;
branches;
next	1.437;

1.437
date	2010.03.05.10.41.04;	author pbrook;	state Exp;
branches;
next	1.436;

1.436
date	2010.02.26.15.57.57;	author jiez;	state Exp;
branches;
next	1.435;

1.435
date	2010.02.26.15.52.41;	author jiez;	state Exp;
branches;
next	1.434;

1.434
date	2010.02.26.15.49.06;	author jiez;	state Exp;
branches;
next	1.433;

1.433
date	2010.02.23.18.04.12;	author dgutson;	state Exp;
branches;
next	1.432;

1.432
date	2010.02.22.10.24.56;	author mgretton;	state Exp;
branches;
next	1.431;

1.431
date	2010.02.18.10.56.27;	author mgretton;	state Exp;
branches;
next	1.430;

1.430
date	2010.02.12.20.15.13;	author dgutson;	state Exp;
branches;
next	1.429;

1.429
date	2010.02.09.14.44.49;	author clyon;	state Exp;
branches;
next	1.428;

1.428
date	2010.01.29.16.02.39;	author nickc;	state Exp;
branches;
next	1.427;

1.427
date	2010.01.13.19.01.08;	author drow;	state Exp;
branches;
next	1.426;

1.426
date	2010.01.06.15.02.44;	author nickc;	state Exp;
branches;
next	1.425;

1.425
date	2010.01.04.23.31.03;	author dgutson;	state Exp;
branches;
next	1.424;

1.424
date	2010.01.04.22.19.03;	author dgutson;	state Exp;
branches;
next	1.423;

1.423
date	2010.01.04.00.39.28;	author dgutson;	state Exp;
branches;
next	1.422;

1.422
date	2009.12.21.12.56.41;	author ramana;	state Exp;
branches;
next	1.421;

1.421
date	2009.12.17.09.52.16;	author nickc;	state Exp;
branches;
next	1.420;

1.420
date	2009.12.11.17.44.24;	author andrewjenner;	state Exp;
branches;
next	1.419;

1.419
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.418;

1.418
date	2009.12.02.20.26.30;	author nickc;	state Exp;
branches;
next	1.417;

1.417
date	2009.11.30.14.36.21;	author nickc;	state Exp;
branches;
next	1.416;

1.416
date	2009.11.18.15.48.58;	author pbrook;	state Exp;
branches;
next	1.415;

1.415
date	2009.11.17.16.31.49;	author pbrook;	state Exp;
branches;
next	1.414;

1.414
date	2009.11.16.11.47.35;	author nickc;	state Exp;
branches;
next	1.413;

1.413
date	2009.11.03.12.37.44;	author pbrook;	state Exp;
branches;
next	1.412;

1.412
date	2009.11.02.13.44.03;	author pbrook;	state Exp;
branches;
next	1.411;

1.411
date	2009.10.29.18.01.12;	author pbrook;	state Exp;
branches;
next	1.410;

1.410
date	2009.10.29.15.37.53;	author pbrook;	state Exp;
branches;
next	1.409;

1.409
date	2009.10.28.16.50.44;	author pbrook;	state Exp;
branches;
next	1.408;

1.408
date	2009.10.18.13.33.20;	author amodra;	state Exp;
branches;
next	1.407;

1.407
date	2009.10.18.08.20.17;	author amodra;	state Exp;
branches;
next	1.406;

1.406
date	2009.10.07.14.00.06;	author nathan;	state Exp;
branches;
next	1.405;

1.405
date	2009.09.25.19.13.26;	author nickc;	state Exp;
branches;
next	1.404;

1.404
date	2009.09.07.16.34.38;	author dgutson;	state Exp;
branches;
next	1.403;

1.403
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches
	1.403.2.1;
next	1.402;

1.402
date	2009.08.10.14.42.37;	author nickc;	state Exp;
branches;
next	1.401;

1.401
date	2009.08.07.19.30.30;	author drow;	state Exp;
branches;
next	1.400;

1.400
date	2009.08.06.10.10.50;	author nickc;	state Exp;
branches;
next	1.399;

1.399
date	2009.08.04.14.56.10;	author nathan;	state Exp;
branches;
next	1.398;

1.398
date	2009.07.31.18.14.07;	author drow;	state Exp;
branches;
next	1.397;

1.397
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.396;

1.396
date	2009.07.23.12.42.07;	author nickc;	state Exp;
branches;
next	1.395;

1.395
date	2009.07.16.13.18.51;	author nathan;	state Exp;
branches;
next	1.394;

1.394
date	2009.07.14.12.54.47;	author nickc;	state Exp;
branches;
next	1.393;

1.393
date	2009.07.09.07.52.34;	author nickc;	state Exp;
branches;
next	1.392;

1.392
date	2009.07.07.16.15.30;	author nickc;	state Exp;
branches;
next	1.391;

1.391
date	2009.07.01.16.36.27;	author nickc;	state Exp;
branches;
next	1.390;

1.390
date	2009.07.01.11.44.53;	author pbrook;	state Exp;
branches;
next	1.389;

1.389
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.388;

1.388
date	2009.06.22.14.40.27;	author nickc;	state Exp;
branches;
next	1.387;

1.387
date	2009.06.18.16.36.02;	author nickc;	state Exp;
branches;
next	1.386;

1.386
date	2009.06.15.15.42.35;	author nickc;	state Exp;
branches;
next	1.385;

1.385
date	2009.05.13.16.44.56;	author andrewjenner;	state Exp;
branches;
next	1.384;

1.384
date	2009.05.05.11.41.31;	author ramana;	state Exp;
branches;
next	1.383;

1.383
date	2009.05.01.14.44.14;	author nathan;	state Exp;
branches;
next	1.382;

1.382
date	2009.05.01.13.50.10;	author jules;	state Exp;
branches;
next	1.381;

1.381
date	2009.04.02.09.43.56;	author nickc;	state Exp;
branches;
next	1.380;

1.380
date	2009.04.01.16.49.30;	author ramana;	state Exp;
branches;
next	1.379;

1.379
date	2009.04.01.14.02.55;	author nathan;	state Exp;
branches;
next	1.378;

1.378
date	2009.03.18.15.28.24;	author ams;	state Exp;
branches;
next	1.377;

1.377
date	2009.03.02.00.29.23;	author mmitchel;	state Exp;
branches;
next	1.376;

1.376
date	2009.02.24.04.30.28;	author mmitchel;	state Exp;
branches;
next	1.375;

1.375
date	2009.02.06.12.51.52;	author nickc;	state Exp;
branches;
next	1.374;

1.374
date	2009.01.29.11.56.19;	author jsm28;	state Exp;
branches;
next	1.373;

1.373
date	2009.01.29.11.52.26;	author jsm28;	state Exp;
branches;
next	1.372;

1.372
date	2009.01.29.11.50.46;	author jsm28;	state Exp;
branches;
next	1.371;

1.371
date	2009.01.29.11.48.33;	author jsm28;	state Exp;
branches;
next	1.370;

1.370
date	2009.01.29.11.46.02;	author jsm28;	state Exp;
branches;
next	1.369;

1.369
date	2009.01.26.14.36.42;	author ams;	state Exp;
branches;
next	1.368;

1.368
date	2009.01.23.17.46.21;	author nathan;	state Exp;
branches;
next	1.367;

1.367
date	2009.01.19.15.46.31;	author nickc;	state Exp;
branches;
next	1.366;

1.366
date	2009.01.16.10.26.48;	author ams;	state Exp;
branches;
next	1.365;

1.365
date	2009.01.15.18.00.49;	author ams;	state Exp;
branches;
next	1.364;

1.364
date	2009.01.15.12.33.46;	author nickc;	state Exp;
branches;
next	1.363;

1.363
date	2008.11.18.15.45.04;	author clm;	state Exp;
branches;
next	1.362;

1.362
date	2008.11.14.09.02.38;	author nickc;	state Exp;
branches;
next	1.361;

1.361
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches
	1.361.2.1;
next	1.360;

1.360
date	2008.08.12.09.58.34;	author amodra;	state Exp;
branches;
next	1.359;

1.359
date	2008.07.07.19.12.57;	author carlos;	state Exp;
branches;
next	1.358;

1.358
date	2008.06.03.14.29.07;	author pbrook;	state Exp;
branches;
next	1.357;

1.357
date	2008.05.22.17.03.55;	author pbrook;	state Exp;
branches;
next	1.356;

1.356
date	2008.05.21.08.20.16;	author nickc;	state Exp;
branches;
next	1.355;

1.355
date	2008.04.23.13.54.56;	author nickc;	state Exp;
branches;
next	1.354;

1.354
date	2008.03.28.18.13.52;	author pbrook;	state Exp;
branches;
next	1.353;

1.353
date	2008.03.27.14.12.15;	author nickc;	state Exp;
branches;
next	1.352;

1.352
date	2008.03.09.15.20.31;	author pbrook;	state Exp;
branches;
next	1.351;

1.351
date	2008.03.09.13.23.28;	author pbrook;	state Exp;
branches;
next	1.350;

1.350
date	2008.03.08.01.20.38;	author pbrook;	state Exp;
branches;
next	1.349;

1.349
date	2008.03.05.01.31.26;	author pbrook;	state Exp;
branches;
next	1.348;

1.348
date	2008.02.22.16.47.01;	author nickc;	state Exp;
branches;
next	1.347;

1.347
date	2008.02.22.15.14.44;	author nickc;	state Exp;
branches;
next	1.346;

1.346
date	2008.02.20.15.17.56;	author pbrook;	state Exp;
branches;
next	1.345;

1.345
date	2008.02.14.16.35.50;	author nickc;	state Exp;
branches;
next	1.344;

1.344
date	2007.11.06.22.17.00;	author pbrook;	state Exp;
branches;
next	1.343;

1.343
date	2007.10.18.11.49.33;	author nickc;	state Exp;
branches;
next	1.342;

1.342
date	2007.10.17.16.45.54;	author nickc;	state Exp;
branches;
next	1.341;

1.341
date	2007.10.08.15.26.42;	author nickc;	state Exp;
branches;
next	1.340;

1.340
date	2007.10.08.10.19.30;	author nickc;	state Exp;
branches;
next	1.339;

1.339
date	2007.10.08.10.14.31;	author nickc;	state Exp;
branches;
next	1.338;

1.338
date	2007.10.03.13.48.35;	author nickc;	state Exp;
branches;
next	1.337;

1.337
date	2007.08.24.16.59.16;	author drow;	state Exp;
branches;
next	1.336;

1.336
date	2007.08.09.15.11.05;	author pbrook;	state Exp;
branches;
next	1.335;

1.335
date	2007.07.14.16.19.18;	author nickc;	state Exp;
branches
	1.335.2.1;
next	1.334;

1.334
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.333;

1.333
date	2007.06.29.16.29.16;	author jsm28;	state Exp;
branches;
next	1.332;

1.332
date	2007.06.26.21.36.37;	author pbrook;	state Exp;
branches;
next	1.331;

1.331
date	2007.06.14.22.06.19;	author pbrook;	state Exp;
branches;
next	1.330;

1.330
date	2007.06.06.17.36.54;	author pbrook;	state Exp;
branches;
next	1.329;

1.329
date	2007.06.05.22.02.46;	author pbrook;	state Exp;
branches;
next	1.328;

1.328
date	2007.05.31.14.50.16;	author pbrook;	state Exp;
branches;
next	1.327;

1.327
date	2007.05.25.23.13.19;	author pbrook;	state Exp;
branches;
next	1.326;

1.326
date	2007.05.16.21.06.54;	author pbrook;	state Exp;
branches;
next	1.325;

1.325
date	2007.05.05.16.23.57;	author shinwell;	state Exp;
branches;
next	1.324;

1.324
date	2007.04.19.17.06.20;	author pbrook;	state Exp;
branches;
next	1.323;

1.323
date	2007.04.19.17.05.12;	author pbrook;	state Exp;
branches;
next	1.322;

1.322
date	2007.04.18.13.49.33;	author pbrook;	state Exp;
branches;
next	1.321;

1.321
date	2007.04.04.19.21.24;	author pbrook;	state Exp;
branches;
next	1.320;

1.320
date	2007.03.30.14.51.25;	author pbrook;	state Exp;
branches;
next	1.319;

1.319
date	2007.03.26.14.43.29;	author jules;	state Exp;
branches;
next	1.318;

1.318
date	2007.03.24.16.09.16;	author pbrook;	state Exp;
branches;
next	1.317;

1.317
date	2007.03.24.01.28.58;	author pbrook;	state Exp;
branches;
next	1.316;

1.316
date	2007.03.23.10.43.35;	author shinwell;	state Exp;
branches;
next	1.315;

1.315
date	2007.03.18.16.21.27;	author shinwell;	state Exp;
branches;
next	1.314;

1.314
date	2007.03.15.12.11.49;	author drow;	state Exp;
branches;
next	1.313;

1.313
date	2007.03.14.21.12.13;	author pbrook;	state Exp;
branches;
next	1.312;

1.312
date	2007.03.02.18.22.33;	author pbrook;	state Exp;
branches;
next	1.311;

1.311
date	2007.02.25.19.29.25;	author shinwell;	state Exp;
branches;
next	1.310;

1.310
date	2007.01.11.15.39.07;	author pbrook;	state Exp;
branches;
next	1.309;

1.309
date	2007.01.11.15.22.10;	author nickc;	state Exp;
branches;
next	1.308;

1.308
date	2007.01.04.20.08.36;	author pbrook;	state Exp;
branches;
next	1.307;

1.307
date	2007.01.04.15.32.50;	author jules;	state Exp;
branches;
next	1.306;

1.306
date	2007.01.04.04.39.53;	author pbrook;	state Exp;
branches;
next	1.305;

1.305
date	2006.12.13.16.06.37;	author pbrook;	state Exp;
branches;
next	1.304;

1.304
date	2006.12.01.16.42.26;	author pbrook;	state Exp;
branches;
next	1.303;

1.303
date	2006.11.29.17.53.39;	author pbrook;	state Exp;
branches;
next	1.302;

1.302
date	2006.11.29.16.26.56;	author pbrook;	state Exp;
branches;
next	1.301;

1.301
date	2006.11.22.17.45.55;	author drow;	state Exp;
branches;
next	1.300;

1.300
date	2006.11.14.12.21.13;	author shinwell;	state Exp;
branches;
next	1.299;

1.299
date	2006.11.10.09.32.42;	author nickc;	state Exp;
branches;
next	1.298;

1.298
date	2006.10.31.20.33.40;	author pbrook;	state Exp;
branches;
next	1.297;

1.297
date	2006.10.31.20.16.33;	author pbrook;	state Exp;
branches;
next	1.296;

1.296
date	2006.10.08.18.44.07;	author pbrook;	state Exp;
branches;
next	1.295;

1.295
date	2006.09.28.13.10.13;	author nickc;	state Exp;
branches;
next	1.294;

1.294
date	2006.09.26.12.04.44;	author jsm28;	state Exp;
branches;
next	1.293;

1.293
date	2006.09.16.16.24.28;	author pbrook;	state Exp;
branches;
next	1.292;

1.292
date	2006.09.16.00.55.33;	author pbrook;	state Exp;
branches;
next	1.291;

1.291
date	2006.09.11.14.27.32;	author nickc;	state Exp;
branches;
next	1.290;

1.290
date	2006.09.08.15.51.02;	author pbrook;	state Exp;
branches;
next	1.289;

1.289
date	2006.09.07.17.54.15;	author pbrook;	state Exp;
branches;
next	1.288;

1.288
date	2006.09.05.14.07.21;	author pbrook;	state Exp;
branches;
next	1.287;

1.287
date	2006.08.21.11.41.23;	author jsm28;	state Exp;
branches;
next	1.286;

1.286
date	2006.08.16.10.33.50;	author jules;	state Exp;
branches;
next	1.285;

1.285
date	2006.08.16.10.16.29;	author jules;	state Exp;
branches;
next	1.284;

1.284
date	2006.08.08.08.23.25;	author nickc;	state Exp;
branches;
next	1.283;

1.283
date	2006.08.06.15.04.22;	author nickc;	state Exp;
branches;
next	1.282;

1.282
date	2006.08.03.15.58.59;	author jsm28;	state Exp;
branches;
next	1.281;

1.281
date	2006.08.03.15.57.04;	author jsm28;	state Exp;
branches;
next	1.280;

1.280
date	2006.07.19.12.53.33;	author pbrook;	state Exp;
branches;
next	1.279;

1.279
date	2006.07.18.16.44.46;	author pbrook;	state Exp;
branches;
next	1.278;

1.278
date	2006.06.21.14.20.24;	author shinwell;	state Exp;
branches;
next	1.277;

1.277
date	2006.06.17.16.05.41;	author nickc;	state Exp;
branches;
next	1.276;

1.276
date	2006.06.15.11.03.01;	author shinwell;	state Exp;
branches;
next	1.275;

1.275
date	2006.06.15.10.51.28;	author jules;	state Exp;
branches;
next	1.274;

1.274
date	2006.06.07.14.32.28;	author jules;	state Exp;
branches;
next	1.273;

1.273
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.272;

1.272
date	2006.05.19.11.26.11;	author ths;	state Exp;
branches;
next	1.271;

1.271
date	2006.05.15.19.57.35;	author pbrook;	state Exp;
branches;
next	1.270;

1.270
date	2006.05.11.15.17.34;	author pbrook;	state Exp;
branches;
next	1.269;

1.269
date	2006.05.11.15.05.17;	author pbrook;	state Exp;
branches;
next	1.268;

1.268
date	2006.05.11.08.48.58;	author nickc;	state Exp;
branches;
next	1.267;

1.267
date	2006.05.09.15.13.22;	author nickc;	state Exp;
branches;
next	1.266;

1.266
date	2006.05.09.11.47.48;	author nickc;	state Exp;
branches;
next	1.265;

1.265
date	2006.05.05.18.54.44;	author jules;	state Exp;
branches;
next	1.264;

1.264
date	2006.05.04.15.40.59;	author kazu;	state Exp;
branches;
next	1.263;

1.263
date	2006.05.02.14.42.29;	author jsm28;	state Exp;
branches;
next	1.262;

1.262
date	2006.05.02.13.09.17;	author pbrook;	state Exp;
branches;
next	1.261;

1.261
date	2006.04.26.16.03.02;	author jules;	state Exp;
branches;
next	1.260;

1.260
date	2006.04.26.15.55.45;	author jules;	state Exp;
branches;
next	1.259;

1.259
date	2006.04.26.15.42.54;	author jules;	state Exp;
branches;
next	1.258;

1.258
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.257;

1.257
date	2006.04.20.12.39.51;	author pbrook;	state Exp;
branches;
next	1.256;

1.256
date	2006.04.07.15.11.19;	author pbrook;	state Exp;
branches
	1.256.2.1;
next	1.255;

1.255
date	2006.04.07.15.09.40;	author pbrook;	state Exp;
branches;
next	1.254;

1.254
date	2006.04.07.15.08.03;	author pbrook;	state Exp;
branches;
next	1.253;

1.253
date	2006.04.07.15.03.44;	author pbrook;	state Exp;
branches;
next	1.252;

1.252
date	2006.03.21.22.52.06;	author pbrook;	state Exp;
branches;
next	1.251;

1.251
date	2006.03.21.14.35.26;	author pbrook;	state Exp;
branches;
next	1.250;

1.250
date	2006.03.20.15.38.02;	author pbrook;	state Exp;
branches
	1.250.2.1;
next	1.249;

1.249
date	2006.03.20.15.14.49;	author pbrook;	state Exp;
branches;
next	1.248;

1.248
date	2006.03.17.14.03.36;	author pbrook;	state Exp;
branches;
next	1.247;

1.247
date	2006.03.16.15.08.47;	author pbrook;	state Exp;
branches;
next	1.246;

1.246
date	2006.03.10.17.20.30;	author pbrook;	state Exp;
branches;
next	1.245;

1.245
date	2006.03.07.08.39.21;	author rsandifo;	state Exp;
branches;
next	1.244;

1.244
date	2006.02.24.17.09.33;	author pbrook;	state Exp;
branches;
next	1.243;

1.243
date	2006.02.24.15.36.35;	author pbrook;	state Exp;
branches;
next	1.242;

1.242
date	2006.02.22.15.03.29;	author pbrook;	state Exp;
branches;
next	1.241;

1.241
date	2006.02.21.15.13.54;	author pbrook;	state Exp;
branches;
next	1.240;

1.240
date	2006.02.02.20.19.56;	author pbrook;	state Exp;
branches;
next	1.239;

1.239
date	2006.02.02.13.32.01;	author pbrook;	state Exp;
branches;
next	1.238;

1.238
date	2006.01.31.16.19.41;	author pbrook;	state Exp;
branches;
next	1.237;

1.237
date	2006.01.31.14.11.13;	author pbrook;	state Exp;
branches;
next	1.236;

1.236
date	2005.12.27.11.55.37;	author nickc;	state Exp;
branches;
next	1.235;

1.235
date	2005.12.12.17.03.40;	author pbrook;	state Exp;
branches;
next	1.234;

1.234
date	2005.11.15.14.29.58;	author drow;	state Exp;
branches;
next	1.233;

1.233
date	2005.11.10.09.41.13;	author nickc;	state Exp;
branches;
next	1.232;

1.232
date	2005.10.28.00.50.03;	author pbrook;	state Exp;
branches;
next	1.231;

1.231
date	2005.10.26.14.09.29;	author pbrook;	state Exp;
branches;
next	1.230;

1.230
date	2005.10.08.17.07.15;	author pbrook;	state Exp;
branches;
next	1.229;

1.229
date	2005.09.30.13.34.10;	author pbrook;	state Exp;
branches;
next	1.228;

1.228
date	2005.09.27.13.23.36;	author pbrook;	state Exp;
branches;
next	1.227;

1.227
date	2005.09.20.18.24.46;	author rth;	state Exp;
branches;
next	1.226;

1.226
date	2005.09.08.12.49.22;	author pbrook;	state Exp;
branches;
next	1.225;

1.225
date	2005.09.06.18.43.45;	author pbrook;	state Exp;
branches;
next	1.224;

1.224
date	2005.09.06.16.59.21;	author pbrook;	state Exp;
branches;
next	1.223;

1.223
date	2005.09.06.15.57.04;	author pbrook;	state Exp;
branches;
next	1.222;

1.222
date	2005.09.02.13.12.39;	author pbrook;	state Exp;
branches;
next	1.221;

1.221
date	2005.09.02.12.50.42;	author pbrook;	state Exp;
branches;
next	1.220;

1.220
date	2005.08.15.19.19.54;	author pbrook;	state Exp;
branches;
next	1.219;

1.219
date	2005.08.11.01.25.24;	author amodra;	state Exp;
branches;
next	1.218;

1.218
date	2005.08.05.12.28.21;	author pbrook;	state Exp;
branches;
next	1.217;

1.217
date	2005.08.05.12.26.28;	author pbrook;	state Exp;
branches;
next	1.216;

1.216
date	2005.08.03.09.50.42;	author nickc;	state Exp;
branches;
next	1.215;

1.215
date	2005.07.29.17.39.35;	author pbrook;	state Exp;
branches;
next	1.214;

1.214
date	2005.07.29.17.28.29;	author pbrook;	state Exp;
branches;
next	1.213;

1.213
date	2005.07.21.13.11.24;	author pbrook;	state Exp;
branches;
next	1.212;

1.212
date	2005.07.04.14.27.07;	author nickc;	state Exp;
branches;
next	1.211;

1.211
date	2005.06.30.18.33.16;	author zack;	state Exp;
branches;
next	1.210;

1.210
date	2005.06.13.15.34.37;	author zack;	state Exp;
branches;
next	1.209;

1.209
date	2005.06.07.18.03.16;	author zack;	state Exp;
branches;
next	1.208;

1.208
date	2005.06.07.17.54.15;	author zack;	state Exp;
branches;
next	1.207;

1.207
date	2005.06.04.14.06.01;	author nickc;	state Exp;
branches;
next	1.206;

1.206
date	2005.06.01.08.18.42;	author nickc;	state Exp;
branches;
next	1.205;

1.205
date	2005.05.27.07.11.43;	author zack;	state Exp;
branches;
next	1.204;

1.204
date	2005.05.18.05.40.07;	author zack;	state Exp;
branches;
next	1.203;

1.203
date	2005.05.05.07.40.56;	author nickc;	state Exp;
branches;
next	1.202;

1.202
date	2005.04.19.15.05.08;	author jbeulich;	state Exp;
branches;
next	1.201;

1.201
date	2005.03.30.17.19.29;	author jules;	state Exp;
branches;
next	1.200;

1.200
date	2005.03.30.16.22.02;	author jules;	state Exp;
branches;
next	1.199;

1.199
date	2005.03.29.16.54.21;	author drow;	state Exp;
branches;
next	1.198;

1.198
date	2005.03.29.16.29.07;	author jules;	state Exp;
branches;
next	1.197;

1.197
date	2005.03.23.15.49.02;	author jimb;	state Exp;
branches;
next	1.196;

1.196
date	2005.03.16.17.27.16;	author drow;	state Exp;
branches;
next	1.195;

1.195
date	2005.03.15.20.37.59;	author zack;	state Exp;
branches;
next	1.194;

1.194
date	2005.03.12.18.25.46;	author zack;	state Exp;
branches;
next	1.193;

1.193
date	2005.02.23.12.28.03;	author amodra;	state Exp;
branches
	1.193.2.1
	1.193.4.1;
next	1.192;

1.192
date	2005.02.17.13.46.03;	author amodra;	state Exp;
branches;
next	1.191;

1.191
date	2005.02.10.12.39.16;	author jules;	state Exp;
branches;
next	1.190;

1.190
date	2005.01.31.23.18.25;	author bje;	state Exp;
branches;
next	1.189;

1.189
date	2005.01.06.16.18.23;	author pbrook;	state Exp;
branches;
next	1.188;

1.188
date	2005.01.06.15.30.57;	author pbrook;	state Exp;
branches;
next	1.187;

1.187
date	2004.12.09.20.25.22;	author pbrook;	state Exp;
branches;
next	1.186;

1.186
date	2004.12.03.01.22.14;	author mmitchel;	state Exp;
branches;
next	1.185;

1.185
date	2004.11.04.15.54.43;	author drow;	state Exp;
branches;
next	1.184;

1.184
date	2004.10.25.12.26.01;	author nickc;	state Exp;
branches;
next	1.183;

1.183
date	2004.10.12.14.17.06;	author pbrook;	state Exp;
branches;
next	1.182;

1.182
date	2004.10.05.13.51.38;	author nickc;	state Exp;
branches;
next	1.181;

1.181
date	2004.10.01.12.59.39;	author nickc;	state Exp;
branches;
next	1.180;

1.180
date	2004.09.30.16.21.45;	author nickc;	state Exp;
branches;
next	1.179;

1.179
date	2004.09.30.15.40.06;	author nickc;	state Exp;
branches;
next	1.178;

1.178
date	2004.09.30.13.18.53;	author nickc;	state Exp;
branches;
next	1.177;

1.177
date	2004.09.17.12.34.58;	author pbrook;	state Exp;
branches;
next	1.176;

1.176
date	2004.09.13.14.14.26;	author pbrook;	state Exp;
branches;
next	1.175;

1.175
date	2004.09.03.17.15.40;	author mmitchel;	state Exp;
branches;
next	1.174;

1.174
date	2004.09.01.16.19.36;	author rearnsha;	state Exp;
branches;
next	1.173;

1.173
date	2004.09.01.16.16.44;	author rearnsha;	state Exp;
branches;
next	1.172;

1.172
date	2004.08.17.12.19.56;	author nickc;	state Exp;
branches;
next	1.171;

1.171
date	2004.08.06.16.18.07;	author pbrook;	state Exp;
branches;
next	1.170;

1.170
date	2004.07.16.22.12.26;	author rearnsha;	state Exp;
branches;
next	1.169;

1.169
date	2004.07.02.11.12.29;	author nickc;	state Exp;
branches;
next	1.168;

1.168
date	2004.04.30.10.51.12;	author nickc;	state Exp;
branches;
next	1.167;

1.167
date	2004.04.22.16.18.29;	author pbrook;	state Exp;
branches;
next	1.166;

1.166
date	2004.04.22.09.49.03;	author nickc;	state Exp;
branches;
next	1.165;

1.165
date	2004.03.30.08.53.05;	author nickc;	state Exp;
branches;
next	1.164;

1.164
date	2004.03.23.23.05.52;	author pbrook;	state Exp;
branches;
next	1.163;

1.163
date	2004.02.18.16.28.17;	author nickc;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2004.02.09.18.04.26;	author drow;	state Exp;
branches;
next	1.161;

1.161
date	2004.01.23.16.29.34;	author drow;	state Exp;
branches;
next	1.160;

1.160
date	2004.01.09.11.53.16;	author pbrook;	state Exp;
branches;
next	1.159;

1.159
date	2003.12.29.16.43.37;	author pbrook;	state Exp;
branches;
next	1.158;

1.158
date	2003.12.23.18.41.58;	author pbrook;	state Exp;
branches;
next	1.157;

1.157
date	2003.12.18.05.45.13;	author mmitchel;	state Exp;
branches;
next	1.156;

1.156
date	2003.12.16.17.44.36;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2003.12.10.12.11.26;	author pbrook;	state Exp;
branches;
next	1.154;

1.154
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches;
next	1.153;

1.153
date	2003.12.09.17.41.12;	author pbrook;	state Exp;
branches;
next	1.152;

1.152
date	2003.12.06.01.25.28;	author mmitchel;	state Exp;
branches;
next	1.151;

1.151
date	2003.11.22.02.35.29;	author kazu;	state Exp;
branches;
next	1.150;

1.150
date	2003.11.21.00.24.40;	author kazu;	state Exp;
branches;
next	1.149;

1.149
date	2003.11.14.06.55.21;	author bje;	state Exp;
branches;
next	1.148;

1.148
date	2003.11.13.14.19.00;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	2003.11.06.15.30.04;	author nickc;	state Exp;
branches;
next	1.146;

1.146
date	2003.10.21.14.20.40;	author nickc;	state Exp;
branches;
next	1.145;

1.145
date	2003.10.17.07.01.44;	author ian;	state Exp;
branches;
next	1.144;

1.144
date	2003.08.19.13.05.42;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	2003.07.23.19.30.39;	author drow;	state Exp;
branches;
next	1.142;

1.142
date	2003.06.13.15.20.26;	author rearnsha;	state Exp;
branches;
next	1.141;

1.141
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.140;

1.140
date	2003.04.02.23.31.25;	author pb;	state Exp;
branches
	1.140.2.1;
next	1.139;

1.139
date	2003.04.01.13.08.05;	author nickc;	state Exp;
branches;
next	1.138;

1.138
date	2003.03.25.20.55.58;	author nickc;	state Exp;
branches;
next	1.137;

1.137
date	2003.02.10.10.44.48;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2002.12.12.22.43.45;	author amodra;	state Exp;
branches;
next	1.134;

1.134
date	2002.12.05.11.46.50;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2002.12.03.11.27.26;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2002.11.30.08.39.42;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2002.11.29.21.00.50;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	2002.10.23.10.34.18;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	2002.09.17.19.23.00;	author nickc;	state Exp;
branches;
next	1.128;

1.128
date	2002.09.05.00.01.16;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2002.08.22.17.27.20;	author nickc;	state Exp;
branches;
next	1.126;

1.126
date	2002.08.01.16.31.16;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2002.07.30.10.56.04;	author nickc;	state Exp;
branches;
next	1.124;

1.124
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2002.05.23.12.37.57;	author nickc;	state Exp;
branches;
next	1.122;

1.122
date	2002.05.22.16.46.27;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	2002.05.14.20.40.30;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2002.05.13.11.33.07;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	2002.05.09.13.12.57;	author kazu;	state Exp;
branches;
next	1.118;

1.118
date	2002.05.02.09.11.13;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	2002.03.21.09.13.34;	author nickc;	state Exp;
branches;
next	1.116;

1.116
date	2002.01.19.14.52.01;	author rearnsha;	state Exp;
branches
	1.116.2.1;
next	1.115;

1.115
date	2002.01.19.14.25.45;	author rearnsha;	state Exp;
branches;
next	1.114;

1.114
date	2002.01.19.12.44.34;	author rearnsha;	state Exp;
branches;
next	1.113;

1.113
date	2002.01.18.17.01.53;	author rearnsha;	state Exp;
branches;
next	1.112;

1.112
date	2002.01.15.16.05.33;	author rearnsha;	state Exp;
branches;
next	1.111;

1.111
date	2002.01.15.14.43.09;	author rearnsha;	state Exp;
branches;
next	1.110;

1.110
date	2002.01.14.17.37.23;	author rearnsha;	state Exp;
branches;
next	1.109;

1.109
date	2002.01.14.15.36.30;	author rearnsha;	state Exp;
branches;
next	1.108;

1.108
date	2002.01.14.15.01.03;	author rearnsha;	state Exp;
branches;
next	1.107;

1.107
date	2002.01.11.18.00.14;	author rearnsha;	state Exp;
branches;
next	1.106;

1.106
date	2002.01.10.11.47.35;	author rearnsha;	state Exp;
branches;
next	1.105;

1.105
date	2001.12.06.10.23.20;	author rearnsha;	state Exp;
branches;
next	1.104;

1.104
date	2001.12.05.11.59.26;	author rearnsha;	state Exp;
branches;
next	1.103;

1.103
date	2001.12.04.11.28.29;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2001.11.15.21.28.54;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2001.11.02.17.25.11;	author rearnsha;	state Exp;
branches;
next	1.100;

1.100
date	2001.10.31.14.48.23;	author rearnsha;	state Exp;
branches;
next	1.99;

1.99
date	2001.10.20.22.41.09;	author hjl;	state Exp;
branches;
next	1.98;

1.98
date	2001.10.19.10.53.19;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2001.10.18.21.06.03;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2001.10.13.09.50.02;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2001.10.09.16.08.57;	author aldyh;	state Exp;
branches;
next	1.94;

1.94
date	2001.10.08.19.31.33;	author aldyh;	state Exp;
branches;
next	1.93;

1.93
date	2001.10.08.19.05.34;	author aldyh;	state Exp;
branches;
next	1.92;

1.92
date	2001.09.27.09.58.01;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	2001.09.19.05.33.22;	author hjl;	state Exp;
branches;
next	1.90;

1.90
date	2001.06.27.08.15.52;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2001.06.21.19.46.53;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2001.06.19.16.26.43;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2001.06.19.11.57.17;	author nickc;	state dead;
branches;
next	1.86;

1.86
date	2001.06.19.07.33.21;	author pb;	state Exp;
branches;
next	1.85;

1.85
date	2001.06.14.07.58.12;	author pb;	state Exp;
branches;
next	1.84;

1.84
date	2001.06.12.08.27.53;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2001.05.11.10.01.41;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2001.05.06.10.11.33;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2001.05.02.18.40.10;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2001.05.02.18.14.30;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2001.05.02.11.33.12;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	2001.04.26.15.19.21;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2001.03.25.20.32.28;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2001.03.12.23.37.39;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2001.03.06.22.33.45;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2001.02.12.13.32.25;	author pb;	state Exp;
branches;
next	1.72;

1.72
date	2001.01.19.04.35.29;	author nickc;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2001.01.11.01.40.18;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2000.12.03.06.49.21;	author kazu;	state Exp;
branches;
next	1.69;

1.69
date	2000.11.25.00.21.37;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2000.11.17.18.46.43;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2000.11.17.08.47.51;	author rth;	state Exp;
branches;
next	1.66;

1.66
date	2000.11.14.20.57.30;	author kazu;	state Exp;
branches;
next	1.65;

1.65
date	2000.11.05.19.28.57;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2000.11.02.19.32.47;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2000.11.02.15.10.57;	author pb;	state Exp;
branches;
next	1.62;

1.62
date	2000.10.27.13.55.49;	author aldyh;	state Exp;
branches;
next	1.61;

1.61
date	2000.10.25.19.15.33;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2000.09.15.01.06.52;	author kazu;	state Exp;
branches;
next	1.59;

1.59
date	2000.09.08.21.05.33;	author pb;	state Exp;
branches;
next	1.58;

1.58
date	2000.08.18.19.27.30;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2000.08.17.23.57.52;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2000.08.17.23.46.43;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2000.08.16.19.01.59;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2000.08.16.17.48.50;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2000.08.14.21.20.03;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2000.08.02.01.00.15;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2000.08.01.23.10.02;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2000.08.01.19.02.49;	author kazu;	state Exp;
branches;
next	1.49;

1.49
date	2000.07.04.05.49.04;	author aoliva;	state Exp;
branches;
next	1.48;

1.48
date	2000.06.25.17.59.21;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2000.06.09.00.00.02;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2000.06.08.19.19.23;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2000.06.02.02.52.10;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2000.06.01.19.07.54;	author scottb;	state Exp;
branches;
next	1.43;

1.43
date	2000.05.15.19.25.22;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2000.04.24.23.57.30;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2000.04.13.01.08.05;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.08.00.11.46;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2000.03.29.18.25.37;	author nickc;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2000.03.19.22.09.23;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2000.03.17.22.12.08;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2000.03.17.20.00.36;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.17.19.44.41;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2000.03.17.19.35.44;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.24.19.46.27;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.31.22.14.50;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.27.20.05.32;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	99.12.22.19.54.41;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	99.12.22.19.44.15;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	99.12.14.19.40.59;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	99.11.29.15.29.34;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	99.11.16.04.15.55;	author dlindsay;	state Exp;
branches;
next	1.25;

1.25
date	99.10.28.03.03.53;	author law;	state Exp;
branches;
next	1.24;

1.24
date	99.10.28.02.53.42;	author law;	state Exp;
branches;
next	1.23;

1.23
date	99.10.27.22.52.35;	author law;	state Exp;
branches;
next	1.22;

1.22
date	99.10.27.18.12.32;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	99.09.22.09.05.32;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	99.09.08.13.10.28;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	99.09.01.15.32.46;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	99.09.01.10.57.19;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	99.08.18.09.12.11;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	99.08.16.17.47.29;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	99.08.13.08.38.20;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	99.08.12.10.32.42;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	99.07.30.15.08.39;	author clm;	state Exp;
branches;
next	1.12;

1.12
date	99.07.15.01.33.06;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	99.07.05.07.39.01;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	99.06.22.14.35.16;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.06.21.10.03.29;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.06.21.09.11.27;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.06.21.08.08.52;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	99.06.18.01.38.26;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.06.13.06.35.48;	author drepper;	state Exp;
branches;
next	1.4;

1.4
date	99.06.10.01.59.33;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.09.50.00;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.29.10.47.18;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.523.2.1
date	2012.08.28.10.50.40;	author mgretton;	state Exp;
branches;
next	1.523.2.2;

1.523.2.2
date	2012.09.18.15.47.01;	author gingold;	state Exp;
branches;
next	1.523.2.3;

1.523.2.3
date	2012.11.20.17.58.29;	author roland;	state Exp;
branches;
next	1.523.2.4;

1.523.2.4
date	2012.12.20.16.30.17;	author rearnsha;	state Exp;
branches;
next	1.523.2.5;

1.523.2.5
date	2013.01.29.17.36.08;	author roland;	state Exp;
branches;
next	1.523.2.6;

1.523.2.6
date	2013.02.25.11.38.20;	author xguo;	state Exp;
branches;
next	1.523.2.7;

1.523.2.7
date	2013.06.24.21.06.17;	author roland;	state Exp;
branches;
next	1.523.2.8;

1.523.2.8
date	2013.06.24.23.35.21;	author roland;	state Exp;
branches;
next	1.523.2.9;

1.523.2.9
date	2013.06.24.23.36.16;	author roland;	state Exp;
branches;
next	1.523.2.10;

1.523.2.10
date	2013.06.24.23.37.03;	author roland;	state Exp;
branches;
next	;

1.500.2.1
date	2011.11.07.16.25.17;	author mgretton;	state Exp;
branches;
next	;

1.471.2.1
date	2010.11.10.15.45.31;	author rsandifo;	state Exp;
branches;
next	1.471.2.2;

1.471.2.2
date	2010.11.15.15.40.06;	author mgretton;	state Exp;
branches;
next	1.471.2.3;

1.471.2.3
date	2011.05.13.14.19.03;	author mgretton;	state Exp;
branches;
next	1.471.2.4;

1.471.2.4
date	2011.08.24.12.43.07;	author mgretton;	state Exp;
branches;
next	;

1.403.2.1
date	2009.10.18.08.21.27;	author amodra;	state Exp;
branches;
next	1.403.2.2;

1.403.2.2
date	2009.12.24.11.57.10;	author ramana;	state Exp;
branches;
next	1.403.2.3;

1.403.2.3
date	2010.02.11.15.10.30;	author clyon;	state Exp;
branches;
next	;

1.361.2.1
date	2009.04.01.15.47.37;	author nickc;	state Exp;
branches;
next	;

1.335.2.1
date	2007.08.24.16.59.22;	author drow;	state Exp;
branches;
next	;

1.256.2.1
date	2006.05.02.13.19.39;	author pbrook;	state Exp;
branches;
next	1.256.2.2;

1.256.2.2
date	2006.05.02.14.45.00;	author jsm28;	state Exp;
branches;
next	;

1.250.2.1
date	2006.03.20.20.40.57;	author pbrook;	state Exp;
branches;
next	1.250.2.2;

1.250.2.2
date	2006.03.20.20.53.13;	author pbrook;	state Exp;
branches;
next	1.250.2.3;

1.250.2.3
date	2006.03.20.20.54.38;	author pbrook;	state Exp;
branches;
next	1.250.2.4;

1.250.2.4
date	2006.03.20.20.55.46;	author pbrook;	state Exp;
branches;
next	1.250.2.5;

1.250.2.5
date	2006.03.20.23.35.40;	author pbrook;	state Exp;
branches;
next	1.250.2.6;

1.250.2.6
date	2006.03.21.22.45.46;	author pbrook;	state Exp;
branches;
next	1.250.2.7;

1.250.2.7
date	2006.04.01.22.39.54;	author pbrook;	state Exp;
branches;
next	1.250.2.8;

1.250.2.8
date	2006.04.03.00.03.33;	author jules;	state Exp;
branches;
next	1.250.2.9;

1.250.2.9
date	2006.04.07.15.46.20;	author jules;	state Exp;
branches;
next	1.250.2.10;

1.250.2.10
date	2006.04.26.16.24.25;	author jules;	state Exp;
branches;
next	1.250.2.11;

1.250.2.11
date	2006.04.26.16.30.48;	author jules;	state Exp;
branches;
next	1.250.2.12;

1.250.2.12
date	2006.05.01.16.27.16;	author pbrook;	state Exp;
branches;
next	1.250.2.13;

1.250.2.13
date	2006.05.02.14.51.29;	author jsm28;	state Exp;
branches;
next	1.250.2.14;

1.250.2.14
date	2006.05.03.14.30.24;	author pbrook;	state Exp;
branches;
next	1.250.2.15;

1.250.2.15
date	2006.05.05.18.31.28;	author jules;	state Exp;
branches;
next	1.250.2.16;

1.250.2.16
date	2006.05.15.20.46.24;	author pbrook;	state Exp;
branches;
next	1.250.2.17;

1.250.2.17
date	2006.06.15.15.25.02;	author jules;	state Exp;
branches;
next	1.250.2.18;

1.250.2.18
date	2006.06.15.15.53.10;	author shinwell;	state Exp;
branches;
next	1.250.2.19;

1.250.2.19
date	2006.07.18.16.45.51;	author pbrook;	state Exp;
branches;
next	1.250.2.20;

1.250.2.20
date	2006.07.19.13.08.20;	author pbrook;	state Exp;
branches;
next	1.250.2.21;

1.250.2.21
date	2006.08.03.16.23.01;	author jsm28;	state Exp;
branches;
next	1.250.2.22;

1.250.2.22
date	2006.08.15.10.50.38;	author shinwell;	state Exp;
branches;
next	1.250.2.23;

1.250.2.23
date	2006.08.16.10.04.14;	author jules;	state Exp;
branches;
next	1.250.2.24;

1.250.2.24
date	2006.08.16.10.37.32;	author jules;	state Exp;
branches;
next	1.250.2.25;

1.250.2.25
date	2006.08.19.16.27.35;	author jsm28;	state Exp;
branches;
next	1.250.2.26;

1.250.2.26
date	2006.09.04.15.55.35;	author pbrook;	state Exp;
branches;
next	1.250.2.27;

1.250.2.27
date	2006.09.05.14.24.01;	author jules;	state Exp;
branches;
next	1.250.2.28;

1.250.2.28
date	2006.09.05.18.17.57;	author pbrook;	state Exp;
branches;
next	1.250.2.29;

1.250.2.29
date	2006.09.05.20.23.46;	author jules;	state Exp;
branches;
next	1.250.2.30;

1.250.2.30
date	2006.09.06.16.35.21;	author pbrook;	state Exp;
branches;
next	1.250.2.31;

1.250.2.31
date	2006.09.07.20.02.44;	author pbrook;	state Exp;
branches;
next	1.250.2.32;

1.250.2.32
date	2006.09.08.22.36.13;	author pbrook;	state Exp;
branches;
next	1.250.2.33;

1.250.2.33
date	2006.09.14.13.57.36;	author jules;	state Exp;
branches;
next	1.250.2.34;

1.250.2.34
date	2006.09.14.15.28.35;	author pbrook;	state Exp;
branches;
next	1.250.2.35;

1.250.2.35
date	2006.09.14.22.33.45;	author pbrook;	state Exp;
branches;
next	1.250.2.36;

1.250.2.36
date	2006.09.18.18.29.56;	author pbrook;	state Exp;
branches;
next	1.250.2.37;

1.250.2.37
date	2006.09.19.18.44.37;	author jsm28;	state Exp;
branches;
next	1.250.2.38;

1.250.2.38
date	2006.10.24.14.06.25;	author shinwell;	state Exp;
branches;
next	1.250.2.39;

1.250.2.39
date	2006.10.25.23.28.50;	author pbrook;	state Exp;
branches;
next	1.250.2.40;

1.250.2.40
date	2006.10.26.19.31.10;	author pbrook;	state Exp;
branches;
next	1.250.2.41;

1.250.2.41
date	2006.10.26.19.41.14;	author pbrook;	state Exp;
branches;
next	1.250.2.42;

1.250.2.42
date	2006.10.26.19.44.34;	author pbrook;	state Exp;
branches;
next	1.250.2.43;

1.250.2.43
date	2006.10.26.22.18.50;	author pbrook;	state Exp;
branches;
next	1.250.2.44;

1.250.2.44
date	2006.10.31.16.46.37;	author shinwell;	state Exp;
branches;
next	1.250.2.45;

1.250.2.45
date	2006.12.01.16.45.26;	author pbrook;	state Exp;
branches;
next	1.250.2.46;

1.250.2.46
date	2006.12.13.16.07.32;	author pbrook;	state Exp;
branches;
next	;

1.193.2.1
date	2005.05.17.19.52.36;	author drow;	state Exp;
branches;
next	;

1.193.4.1
date	2005.03.28.15.30.06;	author drow;	state Exp;
branches;
next	1.193.4.2;

1.193.4.2
date	2005.03.28.15.39.04;	author drow;	state Exp;
branches;
next	1.193.4.3;

1.193.4.3
date	2005.03.29.16.38.00;	author jules;	state Exp;
branches;
next	1.193.4.4;

1.193.4.4
date	2005.03.30.17.28.25;	author jules;	state Exp;
branches;
next	1.193.4.5;

1.193.4.5
date	2005.04.26.05.31.40;	author zack;	state Exp;
branches;
next	1.193.4.6;

1.193.4.6
date	2005.04.29.17.46.01;	author zack;	state Exp;
branches;
next	1.193.4.7;

1.193.4.7
date	2005.04.30.23.36.13;	author pbrook;	state Exp;
branches;
next	1.193.4.8;

1.193.4.8
date	2005.04.30.23.50.31;	author pbrook;	state Exp;
branches;
next	1.193.4.9;

1.193.4.9
date	2006.01.17.16.40.16;	author jsm28;	state Exp;
branches;
next	1.193.4.10;

1.193.4.10
date	2006.04.28.19.10.41;	author jsm28;	state Exp;
branches;
next	;

1.163.2.1
date	2004.05.07.06.32.30;	author drow;	state Exp;
branches;
next	;

1.140.2.1
date	2003.06.13.16.34.31;	author rearnsha;	state Exp;
branches;
next	;

1.116.2.1
date	2002.03.21.09.10.53;	author nickc;	state Exp;
branches;
next	1.116.2.2;

1.116.2.2
date	2002.05.11.07.04.27;	author nickc;	state Exp;
branches;
next	;

1.72.2.1
date	2001.02.12.21.16.23;	author pb;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2001.06.07.03.15.27;	author amodra;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2001.06.13.11.49.41;	author nickc;	state Exp;
branches;
next	1.72.2.4;

1.72.2.4
date	2001.06.14.07.55.52;	author pb;	state Exp;
branches;
next	1.72.2.5;

1.72.2.5
date	2001.06.18.18.17.28;	author pb;	state Exp;
branches;
next	1.72.2.6;

1.72.2.6
date	2001.06.27.16.22.47;	author nickc;	state Exp;
branches;
next	;

1.39.2.1
date	2000.05.30.13.41.11;	author scottb;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2000.06.01.19.15.39;	author scottb;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2000.06.09.17.31.07;	author nickc;	state Exp;
branches;
next	1.39.2.4;

1.39.2.4
date	2000.09.08.21.02.54;	author pb;	state Exp;
branches;
next	1.39.2.5;

1.39.2.5
date	2000.11.01.07.24.25;	author pb;	state Exp;
branches;
next	1.39.2.6;

1.39.2.6
date	2000.11.03.17.17.00;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.580
log
@gas/
2013-10-08  Jan Beulich <jbeulich@@suse.com>

	* gas/config/tc-arm.c (do_t_push_pop): Honor inst.size_req. Simplify
	LR/PC check.

gas/testsuite/
2013-10-08  Jan Beulich <jbeulich@@suse.com>

	* gas/arm/thumb-w-good.s: Add PUSH.W and POP.W tests.
	* gas/arm/thumb-w-good.d: Update accordingly.
@
text
@/* tc-arm.c -- Assemble for the ARM
   Copyright 1994-2013 Free Software Foundation, Inc.
   Contributed by Richard Earnshaw (rwe@@pegasus.esprit.ec.org)
	Modified by David Taylor (dtaylor@@armltd.co.uk)
	Cirrus coprocessor mods by Aldy Hernandez (aldyh@@redhat.com)
	Cirrus coprocessor fixes by Petko Manolov (petkan@@nucleusys.com)
	Cirrus coprocessor fixes by Vladimir Ivanov (vladitx@@nucleusys.com)

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include <limits.h>
#include <stdarg.h>
#define	 NO_RELOC 0
#include "safe-ctype.h"
#include "subsegs.h"
#include "obstack.h"
#include "libiberty.h"
#include "opcode/arm.h"

#ifdef OBJ_ELF
#include "elf/arm.h"
#include "dw2gencfi.h"
#endif

#include "dwarf2dbg.h"

#ifdef OBJ_ELF
/* Must be at least the size of the largest unwind opcode (currently two).  */
#define ARM_OPCODE_CHUNK_SIZE 8

/* This structure holds the unwinding state.  */

static struct
{
  symbolS *	  proc_start;
  symbolS *	  table_entry;
  symbolS *	  personality_routine;
  int		  personality_index;
  /* The segment containing the function.  */
  segT		  saved_seg;
  subsegT	  saved_subseg;
  /* Opcodes generated from this function.  */
  unsigned char * opcodes;
  int		  opcode_count;
  int		  opcode_alloc;
  /* The number of bytes pushed to the stack.  */
  offsetT	  frame_size;
  /* We don't add stack adjustment opcodes immediately so that we can merge
     multiple adjustments.  We can also omit the final adjustment
     when using a frame pointer.  */
  offsetT	  pending_offset;
  /* These two fields are set by both unwind_movsp and unwind_setfp.  They
     hold the reg+offset to use when restoring sp from a frame pointer.	 */
  offsetT	  fp_offset;
  int		  fp_reg;
  /* Nonzero if an unwind_setfp directive has been seen.  */
  unsigned	  fp_used:1;
  /* Nonzero if the last opcode restores sp from fp_reg.  */
  unsigned	  sp_restored:1;
} unwind;

#endif /* OBJ_ELF */

/* Results from operand parsing worker functions.  */

typedef enum
{
  PARSE_OPERAND_SUCCESS,
  PARSE_OPERAND_FAIL,
  PARSE_OPERAND_FAIL_NO_BACKTRACK
} parse_operand_result;

enum arm_float_abi
{
  ARM_FLOAT_ABI_HARD,
  ARM_FLOAT_ABI_SOFTFP,
  ARM_FLOAT_ABI_SOFT
};

/* Types of processor to assemble for.	*/
#ifndef CPU_DEFAULT
/* The code that was here used to select a default CPU depending on compiler
   pre-defines which were only present when doing native builds, thus
   changing gas' default behaviour depending upon the build host.

   If you have a target that requires a default CPU option then the you
   should define CPU_DEFAULT here.  */
#endif

#ifndef FPU_DEFAULT
# ifdef TE_LINUX
#  define FPU_DEFAULT FPU_ARCH_FPA
# elif defined (TE_NetBSD)
#  ifdef OBJ_ELF
#   define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, but VFP order.  */
#  else
    /* Legacy a.out format.  */
#   define FPU_DEFAULT FPU_ARCH_FPA	/* Soft-float, but FPA order.  */
#  endif
# elif defined (TE_VXWORKS)
#  define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, VFP order.  */
# else
   /* For backwards compatibility, default to FPA.  */
#  define FPU_DEFAULT FPU_ARCH_FPA
# endif
#endif /* ifndef FPU_DEFAULT */

#define streq(a, b)	      (strcmp (a, b) == 0)

static arm_feature_set cpu_variant;
static arm_feature_set arm_arch_used;
static arm_feature_set thumb_arch_used;

/* Flags stored in private area of BFD structure.  */
static int uses_apcs_26	     = FALSE;
static int atpcs	     = FALSE;
static int support_interwork = FALSE;
static int uses_apcs_float   = FALSE;
static int pic_code	     = FALSE;
static int fix_v4bx	     = FALSE;
/* Warn on using deprecated features.  */
static int warn_on_deprecated = TRUE;


/* Variables that we set while parsing command-line options.  Once all
   options have been read we re-process these values to set the real
   assembly flags.  */
static const arm_feature_set *legacy_cpu = NULL;
static const arm_feature_set *legacy_fpu = NULL;

static const arm_feature_set *mcpu_cpu_opt = NULL;
static const arm_feature_set *mcpu_fpu_opt = NULL;
static const arm_feature_set *march_cpu_opt = NULL;
static const arm_feature_set *march_fpu_opt = NULL;
static const arm_feature_set *mfpu_opt = NULL;
static const arm_feature_set *object_arch = NULL;

/* Constants for known architecture features.  */
static const arm_feature_set fpu_default = FPU_DEFAULT;
static const arm_feature_set fpu_arch_vfp_v1 = FPU_ARCH_VFP_V1;
static const arm_feature_set fpu_arch_vfp_v2 = FPU_ARCH_VFP_V2;
static const arm_feature_set fpu_arch_vfp_v3 = FPU_ARCH_VFP_V3;
static const arm_feature_set fpu_arch_neon_v1 = FPU_ARCH_NEON_V1;
static const arm_feature_set fpu_arch_fpa = FPU_ARCH_FPA;
static const arm_feature_set fpu_any_hard = FPU_ANY_HARD;
static const arm_feature_set fpu_arch_maverick = FPU_ARCH_MAVERICK;
static const arm_feature_set fpu_endian_pure = FPU_ARCH_ENDIAN_PURE;

#ifdef CPU_DEFAULT
static const arm_feature_set cpu_default = CPU_DEFAULT;
#endif

static const arm_feature_set arm_ext_v1 = ARM_FEATURE (ARM_EXT_V1, 0);
static const arm_feature_set arm_ext_v2 = ARM_FEATURE (ARM_EXT_V1, 0);
static const arm_feature_set arm_ext_v2s = ARM_FEATURE (ARM_EXT_V2S, 0);
static const arm_feature_set arm_ext_v3 = ARM_FEATURE (ARM_EXT_V3, 0);
static const arm_feature_set arm_ext_v3m = ARM_FEATURE (ARM_EXT_V3M, 0);
static const arm_feature_set arm_ext_v4 = ARM_FEATURE (ARM_EXT_V4, 0);
static const arm_feature_set arm_ext_v4t = ARM_FEATURE (ARM_EXT_V4T, 0);
static const arm_feature_set arm_ext_v5 = ARM_FEATURE (ARM_EXT_V5, 0);
static const arm_feature_set arm_ext_v4t_5 =
  ARM_FEATURE (ARM_EXT_V4T | ARM_EXT_V5, 0);
static const arm_feature_set arm_ext_v5t = ARM_FEATURE (ARM_EXT_V5T, 0);
static const arm_feature_set arm_ext_v5e = ARM_FEATURE (ARM_EXT_V5E, 0);
static const arm_feature_set arm_ext_v5exp = ARM_FEATURE (ARM_EXT_V5ExP, 0);
static const arm_feature_set arm_ext_v5j = ARM_FEATURE (ARM_EXT_V5J, 0);
static const arm_feature_set arm_ext_v6 = ARM_FEATURE (ARM_EXT_V6, 0);
static const arm_feature_set arm_ext_v6k = ARM_FEATURE (ARM_EXT_V6K, 0);
static const arm_feature_set arm_ext_v6t2 = ARM_FEATURE (ARM_EXT_V6T2, 0);
static const arm_feature_set arm_ext_v6m = ARM_FEATURE (ARM_EXT_V6M, 0);
static const arm_feature_set arm_ext_v6_notm = ARM_FEATURE (ARM_EXT_V6_NOTM, 0);
static const arm_feature_set arm_ext_v6_dsp = ARM_FEATURE (ARM_EXT_V6_DSP, 0);
static const arm_feature_set arm_ext_barrier = ARM_FEATURE (ARM_EXT_BARRIER, 0);
static const arm_feature_set arm_ext_msr = ARM_FEATURE (ARM_EXT_THUMB_MSR, 0);
static const arm_feature_set arm_ext_div = ARM_FEATURE (ARM_EXT_DIV, 0);
static const arm_feature_set arm_ext_v7 = ARM_FEATURE (ARM_EXT_V7, 0);
static const arm_feature_set arm_ext_v7a = ARM_FEATURE (ARM_EXT_V7A, 0);
static const arm_feature_set arm_ext_v7r = ARM_FEATURE (ARM_EXT_V7R, 0);
static const arm_feature_set arm_ext_v7m = ARM_FEATURE (ARM_EXT_V7M, 0);
static const arm_feature_set arm_ext_v8 = ARM_FEATURE (ARM_EXT_V8, 0);
static const arm_feature_set arm_ext_m =
  ARM_FEATURE (ARM_EXT_V6M | ARM_EXT_OS | ARM_EXT_V7M, 0);
static const arm_feature_set arm_ext_mp = ARM_FEATURE (ARM_EXT_MP, 0);
static const arm_feature_set arm_ext_sec = ARM_FEATURE (ARM_EXT_SEC, 0);
static const arm_feature_set arm_ext_os = ARM_FEATURE (ARM_EXT_OS, 0);
static const arm_feature_set arm_ext_adiv = ARM_FEATURE (ARM_EXT_ADIV, 0);
static const arm_feature_set arm_ext_virt = ARM_FEATURE (ARM_EXT_VIRT, 0);

static const arm_feature_set arm_arch_any = ARM_ANY;
static const arm_feature_set arm_arch_full = ARM_FEATURE (-1, -1);
static const arm_feature_set arm_arch_t2 = ARM_ARCH_THUMB2;
static const arm_feature_set arm_arch_none = ARM_ARCH_NONE;
static const arm_feature_set arm_arch_v6m_only = ARM_ARCH_V6M_ONLY;

static const arm_feature_set arm_cext_iwmmxt2 =
  ARM_FEATURE (0, ARM_CEXT_IWMMXT2);
static const arm_feature_set arm_cext_iwmmxt =
  ARM_FEATURE (0, ARM_CEXT_IWMMXT);
static const arm_feature_set arm_cext_xscale =
  ARM_FEATURE (0, ARM_CEXT_XSCALE);
static const arm_feature_set arm_cext_maverick =
  ARM_FEATURE (0, ARM_CEXT_MAVERICK);
static const arm_feature_set fpu_fpa_ext_v1 = ARM_FEATURE (0, FPU_FPA_EXT_V1);
static const arm_feature_set fpu_fpa_ext_v2 = ARM_FEATURE (0, FPU_FPA_EXT_V2);
static const arm_feature_set fpu_vfp_ext_v1xd =
  ARM_FEATURE (0, FPU_VFP_EXT_V1xD);
static const arm_feature_set fpu_vfp_ext_v1 = ARM_FEATURE (0, FPU_VFP_EXT_V1);
static const arm_feature_set fpu_vfp_ext_v2 = ARM_FEATURE (0, FPU_VFP_EXT_V2);
static const arm_feature_set fpu_vfp_ext_v3xd = ARM_FEATURE (0, FPU_VFP_EXT_V3xD);
static const arm_feature_set fpu_vfp_ext_v3 = ARM_FEATURE (0, FPU_VFP_EXT_V3);
static const arm_feature_set fpu_vfp_ext_d32 =
  ARM_FEATURE (0, FPU_VFP_EXT_D32);
static const arm_feature_set fpu_neon_ext_v1 = ARM_FEATURE (0, FPU_NEON_EXT_V1);
static const arm_feature_set fpu_vfp_v3_or_neon_ext =
  ARM_FEATURE (0, FPU_NEON_EXT_V1 | FPU_VFP_EXT_V3);
static const arm_feature_set fpu_vfp_fp16 = ARM_FEATURE (0, FPU_VFP_EXT_FP16);
static const arm_feature_set fpu_neon_ext_fma = ARM_FEATURE (0, FPU_NEON_EXT_FMA);
static const arm_feature_set fpu_vfp_ext_fma = ARM_FEATURE (0, FPU_VFP_EXT_FMA);
static const arm_feature_set fpu_vfp_ext_armv8 =
  ARM_FEATURE (0, FPU_VFP_EXT_ARMV8);
static const arm_feature_set fpu_neon_ext_armv8 =
  ARM_FEATURE (0, FPU_NEON_EXT_ARMV8);
static const arm_feature_set fpu_crypto_ext_armv8 =
  ARM_FEATURE (0, FPU_CRYPTO_EXT_ARMV8);
static const arm_feature_set crc_ext_armv8 =
  ARM_FEATURE (0, CRC_EXT_ARMV8);

static int mfloat_abi_opt = -1;
/* Record user cpu selection for object attributes.  */
static arm_feature_set selected_cpu = ARM_ARCH_NONE;
/* Must be long enough to hold any of the names in arm_cpus.  */
static char selected_cpu_name[16];

/* Return if no cpu was selected on command-line.  */
static bfd_boolean
no_cpu_selected (void)
{
  return selected_cpu.core == arm_arch_none.core
    && selected_cpu.coproc == arm_arch_none.coproc;
}

#ifdef OBJ_ELF
# ifdef EABI_DEFAULT
static int meabi_flags = EABI_DEFAULT;
# else
static int meabi_flags = EF_ARM_EABI_UNKNOWN;
# endif

static int attributes_set_explicitly[NUM_KNOWN_OBJ_ATTRIBUTES];

bfd_boolean
arm_is_eabi (void)
{
  return (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4);
}
#endif

#ifdef OBJ_ELF
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"	*/
symbolS * GOT_symbol;
#endif

/* 0: assemble for ARM,
   1: assemble for Thumb,
   2: assemble for Thumb even though target CPU does not support thumb
      instructions.  */
static int thumb_mode = 0;
/* A value distinct from the possible values for thumb_mode that we
   can use to record whether thumb_mode has been copied into the
   tc_frag_data field of a frag.  */
#define MODE_RECORDED (1 << 4)

/* Specifies the intrinsic IT insn behavior mode.  */
enum implicit_it_mode
{
  IMPLICIT_IT_MODE_NEVER  = 0x00,
  IMPLICIT_IT_MODE_ARM    = 0x01,
  IMPLICIT_IT_MODE_THUMB  = 0x02,
  IMPLICIT_IT_MODE_ALWAYS = (IMPLICIT_IT_MODE_ARM | IMPLICIT_IT_MODE_THUMB)
};
static int implicit_it_mode = IMPLICIT_IT_MODE_ARM;

/* If unified_syntax is true, we are processing the new unified
   ARM/Thumb syntax.  Important differences from the old ARM mode:

     - Immediate operands do not require a # prefix.
     - Conditional affixes always appear at the end of the
       instruction.  (For backward compatibility, those instructions
       that formerly had them in the middle, continue to accept them
       there.)
     - The IT instruction may appear, and if it does is validated
       against subsequent conditional affixes.  It does not generate
       machine code.

   Important differences from the old Thumb mode:

     - Immediate operands do not require a # prefix.
     - Most of the V6T2 instructions are only available in unified mode.
     - The .N and .W suffixes are recognized and honored (it is an error
       if they cannot be honored).
     - All instructions set the flags if and only if they have an 's' affix.
     - Conditional affixes may be used.  They are validated against
       preceding IT instructions.  Unlike ARM mode, you cannot use a
       conditional affix except in the scope of an IT instruction.  */

static bfd_boolean unified_syntax = FALSE;

/* An immediate operand can start with #, and ld*, st*, pld operands
   can contain [ and ].  We need to tell APP not to elide whitespace
   before a [, which can appear as the first operand for pld.
   Likewise, a { can appear as the first operand for push, pop, vld*, etc.  */
const char arm_symbol_chars[] = "#[]{}";

enum neon_el_type
{
  NT_invtype,
  NT_untyped,
  NT_integer,
  NT_float,
  NT_poly,
  NT_signed,
  NT_unsigned
};

struct neon_type_el
{
  enum neon_el_type type;
  unsigned size;
};

#define NEON_MAX_TYPE_ELS 4

struct neon_type
{
  struct neon_type_el el[NEON_MAX_TYPE_ELS];
  unsigned elems;
};

enum it_instruction_type
{
   OUTSIDE_IT_INSN,
   INSIDE_IT_INSN,
   INSIDE_IT_LAST_INSN,
   IF_INSIDE_IT_LAST_INSN, /* Either outside or inside;
			      if inside, should be the last one.  */
   NEUTRAL_IT_INSN,        /* This could be either inside or outside,
			      i.e. BKPT and NOP.  */
   IT_INSN                 /* The IT insn has been parsed.  */
};

/* The maximum number of operands we need.  */
#define ARM_IT_MAX_OPERANDS 6

struct arm_it
{
  const char *	error;
  unsigned long instruction;
  int		size;
  int		size_req;
  int		cond;
  /* "uncond_value" is set to the value in place of the conditional field in
     unconditional versions of the instruction, or -1 if nothing is
     appropriate.  */
  int		uncond_value;
  struct neon_type vectype;
  /* This does not indicate an actual NEON instruction, only that
     the mnemonic accepts neon-style type suffixes.  */
  int		is_neon;
  /* Set to the opcode if the instruction needs relaxation.
     Zero if the instruction is not relaxed.  */
  unsigned long	relax;
  struct
  {
    bfd_reloc_code_real_type type;
    expressionS		     exp;
    int			     pc_rel;
  } reloc;

  enum it_instruction_type it_insn_type;

  struct
  {
    unsigned reg;
    signed int imm;
    struct neon_type_el vectype;
    unsigned present	: 1;  /* Operand present.  */
    unsigned isreg	: 1;  /* Operand was a register.  */
    unsigned immisreg	: 1;  /* .imm field is a second register.  */
    unsigned isscalar   : 1;  /* Operand is a (Neon) scalar.  */
    unsigned immisalign : 1;  /* Immediate is an alignment specifier.  */
    unsigned immisfloat : 1;  /* Immediate was parsed as a float.  */
    /* Note: we abuse "regisimm" to mean "is Neon register" in VMOV
       instructions. This allows us to disambiguate ARM <-> vector insns.  */
    unsigned regisimm   : 1;  /* 64-bit immediate, reg forms high 32 bits.  */
    unsigned isvec      : 1;  /* Is a single, double or quad VFP/Neon reg.  */
    unsigned isquad     : 1;  /* Operand is Neon quad-precision register.  */
    unsigned issingle   : 1;  /* Operand is VFP single-precision register.  */
    unsigned hasreloc	: 1;  /* Operand has relocation suffix.  */
    unsigned writeback	: 1;  /* Operand has trailing !  */
    unsigned preind	: 1;  /* Preindexed address.  */
    unsigned postind	: 1;  /* Postindexed address.  */
    unsigned negative	: 1;  /* Index register was negated.  */
    unsigned shifted	: 1;  /* Shift applied to operation.  */
    unsigned shift_kind : 3;  /* Shift operation (enum shift_kind).  */
  } operands[ARM_IT_MAX_OPERANDS];
};

static struct arm_it inst;

#define NUM_FLOAT_VALS 8

const char * fp_const[] =
{
  "0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0", 0
};

/* Number of littlenums required to hold an extended precision number.	*/
#define MAX_LITTLENUMS 6

LITTLENUM_TYPE fp_values[NUM_FLOAT_VALS][MAX_LITTLENUMS];

#define FAIL	(-1)
#define SUCCESS (0)

#define SUFF_S 1
#define SUFF_D 2
#define SUFF_E 3
#define SUFF_P 4

#define CP_T_X	 0x00008000
#define CP_T_Y	 0x00400000

#define CONDS_BIT	 0x00100000
#define LOAD_BIT	 0x00100000

#define DOUBLE_LOAD_FLAG 0x00000001

struct asm_cond
{
  const char *	 template_name;
  unsigned long  value;
};

#define COND_ALWAYS 0xE

struct asm_psr
{
  const char *   template_name;
  unsigned long  field;
};

struct asm_barrier_opt
{
  const char *    template_name;
  unsigned long   value;
  const arm_feature_set arch;
};

/* The bit that distinguishes CPSR and SPSR.  */
#define SPSR_BIT   (1 << 22)

/* The individual PSR flag bits.  */
#define PSR_c	(1 << 16)
#define PSR_x	(1 << 17)
#define PSR_s	(1 << 18)
#define PSR_f	(1 << 19)

struct reloc_entry
{
  char *                    name;
  bfd_reloc_code_real_type  reloc;
};

enum vfp_reg_pos
{
  VFP_REG_Sd, VFP_REG_Sm, VFP_REG_Sn,
  VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
};

enum vfp_ldstm_type
{
  VFP_LDSTMIA, VFP_LDSTMDB, VFP_LDSTMIAX, VFP_LDSTMDBX
};

/* Bits for DEFINED field in neon_typed_alias.  */
#define NTA_HASTYPE  1
#define NTA_HASINDEX 2

struct neon_typed_alias
{
  unsigned char        defined;
  unsigned char        index;
  struct neon_type_el  eltype;
};

/* ARM register categories.  This includes coprocessor numbers and various
   architecture extensions' registers.	*/
enum arm_reg_type
{
  REG_TYPE_RN,
  REG_TYPE_CP,
  REG_TYPE_CN,
  REG_TYPE_FN,
  REG_TYPE_VFS,
  REG_TYPE_VFD,
  REG_TYPE_NQ,
  REG_TYPE_VFSD,
  REG_TYPE_NDQ,
  REG_TYPE_NSDQ,
  REG_TYPE_VFC,
  REG_TYPE_MVF,
  REG_TYPE_MVD,
  REG_TYPE_MVFX,
  REG_TYPE_MVDX,
  REG_TYPE_MVAX,
  REG_TYPE_DSPSC,
  REG_TYPE_MMXWR,
  REG_TYPE_MMXWC,
  REG_TYPE_MMXWCG,
  REG_TYPE_XSCALE,
  REG_TYPE_RNB
};

/* Structure for a hash table entry for a register.
   If TYPE is REG_TYPE_VFD or REG_TYPE_NQ, the NEON field can point to extra
   information which states whether a vector type or index is specified (for a
   register alias created with .dn or .qn). Otherwise NEON should be NULL.  */
struct reg_entry
{
  const char *               name;
  unsigned int               number;
  unsigned char              type;
  unsigned char              builtin;
  struct neon_typed_alias *  neon;
};

/* Diagnostics used when we don't get a register of the expected type.	*/
const char * const reg_expected_msgs[] =
{
  N_("ARM register expected"),
  N_("bad or missing co-processor number"),
  N_("co-processor register expected"),
  N_("FPA register expected"),
  N_("VFP single precision register expected"),
  N_("VFP/Neon double precision register expected"),
  N_("Neon quad precision register expected"),
  N_("VFP single or double precision register expected"),
  N_("Neon double or quad precision register expected"),
  N_("VFP single, double or Neon quad precision register expected"),
  N_("VFP system register expected"),
  N_("Maverick MVF register expected"),
  N_("Maverick MVD register expected"),
  N_("Maverick MVFX register expected"),
  N_("Maverick MVDX register expected"),
  N_("Maverick MVAX register expected"),
  N_("Maverick DSPSC register expected"),
  N_("iWMMXt data register expected"),
  N_("iWMMXt control register expected"),
  N_("iWMMXt scalar register expected"),
  N_("XScale accumulator register expected"),
};

/* Some well known registers that we refer to directly elsewhere.  */
#define REG_R12	12
#define REG_SP	13
#define REG_LR	14
#define REG_PC	15

/* ARM instructions take 4bytes in the object file, Thumb instructions
   take 2:  */
#define INSN_SIZE	4

struct asm_opcode
{
  /* Basic string to match.  */
  const char * template_name;

  /* Parameters to instruction.	 */
  unsigned int operands[8];

  /* Conditional tag - see opcode_lookup.  */
  unsigned int tag : 4;

  /* Basic instruction code.  */
  unsigned int avalue : 28;

  /* Thumb-format instruction code.  */
  unsigned int tvalue;

  /* Which architecture variant provides this instruction.  */
  const arm_feature_set * avariant;
  const arm_feature_set * tvariant;

  /* Function to call to encode instruction in ARM format.  */
  void (* aencode) (void);

  /* Function to call to encode instruction in Thumb format.  */
  void (* tencode) (void);
};

/* Defines for various bits that we will want to toggle.  */
#define INST_IMMEDIATE	0x02000000
#define OFFSET_REG	0x02000000
#define HWOFFSET_IMM	0x00400000
#define SHIFT_BY_REG	0x00000010
#define PRE_INDEX	0x01000000
#define INDEX_UP	0x00800000
#define WRITE_BACK	0x00200000
#define LDM_TYPE_2_OR_3	0x00400000
#define CPSI_MMOD	0x00020000

#define LITERAL_MASK	0xf000f000
#define OPCODE_MASK	0xfe1fffff
#define V4_STR_BIT	0x00000020

#define T2_SUBS_PC_LR	0xf3de8f00

#define DATA_OP_SHIFT	21

#define T2_OPCODE_MASK	0xfe1fffff
#define T2_DATA_OP_SHIFT 21

#define A_COND_MASK         0xf0000000
#define A_PUSH_POP_OP_MASK  0x0fff0000

/* Opcodes for pushing/poping registers to/from the stack.  */
#define A1_OPCODE_PUSH    0x092d0000
#define A2_OPCODE_PUSH    0x052d0004
#define A2_OPCODE_POP     0x049d0004

/* Codes to distinguish the arithmetic instructions.  */
#define OPCODE_AND	0
#define OPCODE_EOR	1
#define OPCODE_SUB	2
#define OPCODE_RSB	3
#define OPCODE_ADD	4
#define OPCODE_ADC	5
#define OPCODE_SBC	6
#define OPCODE_RSC	7
#define OPCODE_TST	8
#define OPCODE_TEQ	9
#define OPCODE_CMP	10
#define OPCODE_CMN	11
#define OPCODE_ORR	12
#define OPCODE_MOV	13
#define OPCODE_BIC	14
#define OPCODE_MVN	15

#define T2_OPCODE_AND	0
#define T2_OPCODE_BIC	1
#define T2_OPCODE_ORR	2
#define T2_OPCODE_ORN	3
#define T2_OPCODE_EOR	4
#define T2_OPCODE_ADD	8
#define T2_OPCODE_ADC	10
#define T2_OPCODE_SBC	11
#define T2_OPCODE_SUB	13
#define T2_OPCODE_RSB	14

#define T_OPCODE_MUL 0x4340
#define T_OPCODE_TST 0x4200
#define T_OPCODE_CMN 0x42c0
#define T_OPCODE_NEG 0x4240
#define T_OPCODE_MVN 0x43c0

#define T_OPCODE_ADD_R3	0x1800
#define T_OPCODE_SUB_R3 0x1a00
#define T_OPCODE_ADD_HI 0x4400
#define T_OPCODE_ADD_ST 0xb000
#define T_OPCODE_SUB_ST 0xb080
#define T_OPCODE_ADD_SP 0xa800
#define T_OPCODE_ADD_PC 0xa000
#define T_OPCODE_ADD_I8 0x3000
#define T_OPCODE_SUB_I8 0x3800
#define T_OPCODE_ADD_I3 0x1c00
#define T_OPCODE_SUB_I3 0x1e00

#define T_OPCODE_ASR_R	0x4100
#define T_OPCODE_LSL_R	0x4080
#define T_OPCODE_LSR_R	0x40c0
#define T_OPCODE_ROR_R	0x41c0
#define T_OPCODE_ASR_I	0x1000
#define T_OPCODE_LSL_I	0x0000
#define T_OPCODE_LSR_I	0x0800

#define T_OPCODE_MOV_I8	0x2000
#define T_OPCODE_CMP_I8 0x2800
#define T_OPCODE_CMP_LR 0x4280
#define T_OPCODE_MOV_HR 0x4600
#define T_OPCODE_CMP_HR 0x4500

#define T_OPCODE_LDR_PC 0x4800
#define T_OPCODE_LDR_SP 0x9800
#define T_OPCODE_STR_SP 0x9000
#define T_OPCODE_LDR_IW 0x6800
#define T_OPCODE_STR_IW 0x6000
#define T_OPCODE_LDR_IH 0x8800
#define T_OPCODE_STR_IH 0x8000
#define T_OPCODE_LDR_IB 0x7800
#define T_OPCODE_STR_IB 0x7000
#define T_OPCODE_LDR_RW 0x5800
#define T_OPCODE_STR_RW 0x5000
#define T_OPCODE_LDR_RH 0x5a00
#define T_OPCODE_STR_RH 0x5200
#define T_OPCODE_LDR_RB 0x5c00
#define T_OPCODE_STR_RB 0x5400

#define T_OPCODE_PUSH	0xb400
#define T_OPCODE_POP	0xbc00

#define T_OPCODE_BRANCH 0xe000

#define THUMB_SIZE	2	/* Size of thumb instruction.  */
#define THUMB_PP_PC_LR 0x0100
#define THUMB_LOAD_BIT 0x0800
#define THUMB2_LOAD_BIT 0x00100000

#define BAD_ARGS	_("bad arguments to instruction")
#define BAD_SP          _("r13 not allowed here")
#define BAD_PC		_("r15 not allowed here")
#define BAD_COND	_("instruction cannot be conditional")
#define BAD_OVERLAP	_("registers may not be the same")
#define BAD_HIREG	_("lo register required")
#define BAD_THUMB32	_("instruction not supported in Thumb16 mode")
#define BAD_ADDR_MODE   _("instruction does not accept this addressing mode");
#define BAD_BRANCH	_("branch must be last instruction in IT block")
#define BAD_NOT_IT	_("instruction not allowed in IT block")
#define BAD_FPU		_("selected FPU does not support instruction")
#define BAD_OUT_IT 	_("thumb conditional instruction should be in IT block")
#define BAD_IT_COND	_("incorrect condition in IT block")
#define BAD_IT_IT 	_("IT falling in the range of a previous IT block")
#define MISSING_FNSTART	_("missing .fnstart before unwinding directive")
#define BAD_PC_ADDRESSING \
	_("cannot use register index with PC-relative addressing")
#define BAD_PC_WRITEBACK \
	_("cannot use writeback with PC-relative addressing")
#define BAD_RANGE     _("branch out of range")
#define UNPRED_REG(R)	_("using " R " results in unpredictable behaviour")

static struct hash_control * arm_ops_hsh;
static struct hash_control * arm_cond_hsh;
static struct hash_control * arm_shift_hsh;
static struct hash_control * arm_psr_hsh;
static struct hash_control * arm_v7m_psr_hsh;
static struct hash_control * arm_reg_hsh;
static struct hash_control * arm_reloc_hsh;
static struct hash_control * arm_barrier_opt_hsh;

/* Stuff needed to resolve the label ambiguity
   As:
     ...
     label:   <insn>
   may differ from:
     ...
     label:
	      <insn>  */

symbolS *  last_label_seen;
static int label_is_thumb_function_name = FALSE;

/* Literal pool structure.  Held on a per-section
   and per-sub-section basis.  */

#define MAX_LITERAL_POOL_SIZE 1024
typedef struct literal_pool
{
  expressionS	         literals [MAX_LITERAL_POOL_SIZE];
  unsigned int	         next_free_entry;
  unsigned int	         id;
  symbolS *	         symbol;
  segT		         section;
  subsegT	         sub_section;
#ifdef OBJ_ELF
  struct dwarf2_line_info locs [MAX_LITERAL_POOL_SIZE];
#endif
  struct literal_pool *  next;
} literal_pool;

/* Pointer to a linked list of literal pools.  */
literal_pool * list_of_pools = NULL;

#ifdef OBJ_ELF
#  define now_it seg_info (now_seg)->tc_segment_info_data.current_it
#else
static struct current_it now_it;
#endif

static inline int
now_it_compatible (int cond)
{
  return (cond & ~1) == (now_it.cc & ~1);
}

static inline int
conditional_insn (void)
{
  return inst.cond != COND_ALWAYS;
}

static int in_it_block (void);

static int handle_it_state (void);

static void force_automatic_it_block_close (void);

static void it_fsm_post_encode (void);

#define set_it_insn_type(type)			\
  do						\
    {						\
      inst.it_insn_type = type;			\
      if (handle_it_state () == FAIL)		\
	return;					\
    }						\
  while (0)

#define set_it_insn_type_nonvoid(type, failret) \
  do						\
    {                                           \
      inst.it_insn_type = type;			\
      if (handle_it_state () == FAIL)		\
	return failret;				\
    }						\
  while(0)

#define set_it_insn_type_last()				\
  do							\
    {							\
      if (inst.cond == COND_ALWAYS)			\
	set_it_insn_type (IF_INSIDE_IT_LAST_INSN);	\
      else						\
	set_it_insn_type (INSIDE_IT_LAST_INSN);		\
    }							\
  while (0)

/* Pure syntax.	 */

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.	 */
const char comment_chars[] = "@@";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.	*/
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant
   from exp in floating point numbers.	*/
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456  */
/* or	 0d1.2345e12  */

const char FLT_CHARS[] = "rRsSfFdDxXeEpP";

/* Prefix characters that indicate the start of an immediate
   value.  */
#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')

/* Separator character handling.  */

#define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)

static inline int
skip_past_char (char ** str, char c)
{
  /* PR gas/14987: Allow for whitespace before the expected character.  */
  skip_whitespace (*str);

  if (**str == c)
    {
      (*str)++;
      return SUCCESS;
    }
  else
    return FAIL;
}

#define skip_past_comma(str) skip_past_char (str, ',')

/* Arithmetic expressions (possibly involving symbols).	 */

/* Return TRUE if anything in the expression is a bignum.  */

static int
walk_no_bignums (symbolS * sp)
{
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;

  if (symbol_get_value_expression (sp)->X_add_symbol)
    {
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
    }

  return 0;
}

static int in_my_get_expression = 0;

/* Third argument to my_get_expression.	 */
#define GE_NO_PREFIX 0
#define GE_IMM_PREFIX 1
#define GE_OPT_PREFIX 2
/* This is a bit of a hack. Use an optional prefix, and also allow big (64-bit)
   immediates, as can be used in Neon VMVN and VMOV immediate instructions.  */
#define GE_OPT_PREFIX_BIG 3

static int
my_get_expression (expressionS * ep, char ** str, int prefix_mode)
{
  char * save_in;
  segT	 seg;

  /* In unified syntax, all prefixes are optional.  */
  if (unified_syntax)
    prefix_mode = (prefix_mode == GE_OPT_PREFIX_BIG) ? prefix_mode
		  : GE_OPT_PREFIX;

  switch (prefix_mode)
    {
    case GE_NO_PREFIX: break;
    case GE_IMM_PREFIX:
      if (!is_immediate_prefix (**str))
	{
	  inst.error = _("immediate expression requires a # prefix");
	  return FAIL;
	}
      (*str)++;
      break;
    case GE_OPT_PREFIX:
    case GE_OPT_PREFIX_BIG:
      if (is_immediate_prefix (**str))
	(*str)++;
      break;
    default: abort ();
    }

  memset (ep, 0, sizeof (expressionS));

  save_in = input_line_pointer;
  input_line_pointer = *str;
  in_my_get_expression = 1;
  seg = expression (ep);
  in_my_get_expression = 0;

  if (ep->X_op == O_illegal || ep->X_op == O_absent)
    {
      /* We found a bad or missing expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      if (inst.error == NULL)
	inst.error = (ep->X_op == O_absent
		      ? _("missing expression") :_("bad expression"));
      return 1;
    }

#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
#else
  (void) seg;
#endif

  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.	 Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (prefix_mode != GE_OPT_PREFIX_BIG
      && (ep->X_op == O_big
	  || (ep->X_add_symbol
	      && (walk_no_bignums (ep->X_add_symbol)
		  || (ep->X_op_symbol
		      && walk_no_bignums (ep->X_op_symbol))))))
    {
      inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.

   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.	However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.

   ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */

char *
md_atof (int type, char * litP, int * sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 5;
      break;

    case 'p':
    case 'P':
      prec = 5;
      break;

    default:
      *sizeP = 0;
      return _("Unrecognized or unsupported floating point constant");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }
  else
    {
      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_endian_pure))
	for (i = prec - 1; i >= 0; i--)
	  {
	    md_number_to_chars (litP, (valueT) words[i], sizeof (LITTLENUM_TYPE));
	    litP += sizeof (LITTLENUM_TYPE);
	  }
      else
	/* For a 4 byte float the order of elements in `words' is 1 0.
	   For an 8 byte float the order is 1 0 3 2.  */
	for (i = 0; i < prec; i += 2)
	  {
	    md_number_to_chars (litP, (valueT) words[i + 1],
				sizeof (LITTLENUM_TYPE));
	    md_number_to_chars (litP + sizeof (LITTLENUM_TYPE),
				(valueT) words[i], sizeof (LITTLENUM_TYPE));
	    litP += 2 * sizeof (LITTLENUM_TYPE);
	  }
    }

  return NULL;
}

/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expressionS * exp)
{
  if (in_my_get_expression)
    exp->X_op = O_illegal;
}

/* Immediate values.  */

/* Generic immediate-value read function for use in directives.
   Accepts anything that 'expression' can fold to a constant.
   *val receives the number.  */
#ifdef OBJ_ELF
static int
immediate_for_directive (int *val)
{
  expressionS exp;
  exp.X_op = O_illegal;

  if (is_immediate_prefix (*input_line_pointer))
    {
      input_line_pointer++;
      expression (&exp);
    }

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected #constant"));
      ignore_rest_of_line ();
      return FAIL;
    }
  *val = exp.X_add_number;
  return SUCCESS;
}
#endif

/* Register parsing.  */

/* Generic register parser.  CCP points to what should be the
   beginning of a register name.  If it is indeed a valid register
   name, advance CCP over it and return the reg_entry structure;
   otherwise return NULL.  Does not issue diagnostics.	*/

static struct reg_entry *
arm_reg_parse_multi (char **ccp)
{
  char *start = *ccp;
  char *p;
  struct reg_entry *reg;

  skip_whitespace (start);

#ifdef REGISTER_PREFIX
  if (*start != REGISTER_PREFIX)
    return NULL;
  start++;
#endif
#ifdef OPTIONAL_REGISTER_PREFIX
  if (*start == OPTIONAL_REGISTER_PREFIX)
    start++;
#endif

  p = start;
  if (!ISALPHA (*p) || !is_name_beginner (*p))
    return NULL;

  do
    p++;
  while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');

  reg = (struct reg_entry *) hash_find_n (arm_reg_hsh, start, p - start);

  if (!reg)
    return NULL;

  *ccp = p;
  return reg;
}

static int
arm_reg_alt_syntax (char **ccp, char *start, struct reg_entry *reg,
		    enum arm_reg_type type)
{
  /* Alternative syntaxes are accepted for a few register classes.  */
  switch (type)
    {
    case REG_TYPE_MVF:
    case REG_TYPE_MVD:
    case REG_TYPE_MVFX:
    case REG_TYPE_MVDX:
      /* Generic coprocessor register names are allowed for these.  */
      if (reg && reg->type == REG_TYPE_CN)
	return reg->number;
      break;

    case REG_TYPE_CP:
      /* For backward compatibility, a bare number is valid here.  */
      {
	unsigned long processor = strtoul (start, ccp, 10);
	if (*ccp != start && processor <= 15)
	  return processor;
      }

    case REG_TYPE_MMXWC:
      /* WC includes WCG.  ??? I'm not sure this is true for all
	 instructions that take WC registers.  */
      if (reg && reg->type == REG_TYPE_MMXWCG)
	return reg->number;
      break;

    default:
      break;
    }

  return FAIL;
}

/* As arm_reg_parse_multi, but the register must be of type TYPE, and the
   return value is the register number or FAIL.  */

static int
arm_reg_parse (char **ccp, enum arm_reg_type type)
{
  char *start = *ccp;
  struct reg_entry *reg = arm_reg_parse_multi (ccp);
  int ret;

  /* Do not allow a scalar (reg+index) to parse as a register.  */
  if (reg && reg->neon && (reg->neon->defined & NTA_HASINDEX))
    return FAIL;

  if (reg && reg->type == type)
    return reg->number;

  if ((ret = arm_reg_alt_syntax (ccp, start, reg, type)) != FAIL)
    return ret;

  *ccp = start;
  return FAIL;
}

/* Parse a Neon type specifier. *STR should point at the leading '.'
   character. Does no verification at this stage that the type fits the opcode
   properly. E.g.,

     .i32.i32.s16
     .s32.f32
     .u16

   Can all be legally parsed by this function.

   Fills in neon_type struct pointer with parsed information, and updates STR
   to point after the parsed type specifier. Returns SUCCESS if this was a legal
   type, FAIL if not.  */

static int
parse_neon_type (struct neon_type *type, char **str)
{
  char *ptr = *str;

  if (type)
    type->elems = 0;

  while (type->elems < NEON_MAX_TYPE_ELS)
    {
      enum neon_el_type thistype = NT_untyped;
      unsigned thissize = -1u;

      if (*ptr != '.')
	break;

      ptr++;

      /* Just a size without an explicit type.  */
      if (ISDIGIT (*ptr))
	goto parsesize;

      switch (TOLOWER (*ptr))
	{
	case 'i': thistype = NT_integer; break;
	case 'f': thistype = NT_float; break;
	case 'p': thistype = NT_poly; break;
	case 's': thistype = NT_signed; break;
	case 'u': thistype = NT_unsigned; break;
	case 'd':
	  thistype = NT_float;
	  thissize = 64;
	  ptr++;
	  goto done;
	default:
	  as_bad (_("unexpected character `%c' in type specifier"), *ptr);
	  return FAIL;
	}

      ptr++;

      /* .f is an abbreviation for .f32.  */
      if (thistype == NT_float && !ISDIGIT (*ptr))
	thissize = 32;
      else
	{
	parsesize:
	  thissize = strtoul (ptr, &ptr, 10);

	  if (thissize != 8 && thissize != 16 && thissize != 32
	      && thissize != 64)
	    {
	      as_bad (_("bad size %d in type specifier"), thissize);
	      return FAIL;
	    }
	}

      done:
      if (type)
	{
	  type->el[type->elems].type = thistype;
	  type->el[type->elems].size = thissize;
	  type->elems++;
	}
    }

  /* Empty/missing type is not a successful parse.  */
  if (type->elems == 0)
    return FAIL;

  *str = ptr;

  return SUCCESS;
}

/* Errors may be set multiple times during parsing or bit encoding
   (particularly in the Neon bits), but usually the earliest error which is set
   will be the most meaningful. Avoid overwriting it with later (cascading)
   errors by calling this function.  */

static void
first_error (const char *err)
{
  if (!inst.error)
    inst.error = err;
}

/* Parse a single type, e.g. ".s32", leading period included.  */
static int
parse_neon_operand_type (struct neon_type_el *vectype, char **ccp)
{
  char *str = *ccp;
  struct neon_type optype;

  if (*str == '.')
    {
      if (parse_neon_type (&optype, &str) == SUCCESS)
	{
	  if (optype.elems == 1)
	    *vectype = optype.el[0];
	  else
	    {
	      first_error (_("only one type should be specified for operand"));
	      return FAIL;
	    }
	}
      else
	{
	  first_error (_("vector type expected"));
	  return FAIL;
	}
    }
  else
    return FAIL;

  *ccp = str;

  return SUCCESS;
}

/* Special meanings for indices (which have a range of 0-7), which will fit into
   a 4-bit integer.  */

#define NEON_ALL_LANES		15
#define NEON_INTERLEAVE_LANES	14

/* Parse either a register or a scalar, with an optional type. Return the
   register number, and optionally fill in the actual type of the register
   when multiple alternatives were given (NEON_TYPE_NDQ) in *RTYPE, and
   type/index information in *TYPEINFO.  */

static int
parse_typed_reg_or_scalar (char **ccp, enum arm_reg_type type,
			   enum arm_reg_type *rtype,
			   struct neon_typed_alias *typeinfo)
{
  char *str = *ccp;
  struct reg_entry *reg = arm_reg_parse_multi (&str);
  struct neon_typed_alias atype;
  struct neon_type_el parsetype;

  atype.defined = 0;
  atype.index = -1;
  atype.eltype.type = NT_invtype;
  atype.eltype.size = -1;

  /* Try alternate syntax for some types of register. Note these are mutually
     exclusive with the Neon syntax extensions.  */
  if (reg == NULL)
    {
      int altreg = arm_reg_alt_syntax (&str, *ccp, reg, type);
      if (altreg != FAIL)
	*ccp = str;
      if (typeinfo)
	*typeinfo = atype;
      return altreg;
    }

  /* Undo polymorphism when a set of register types may be accepted.  */
  if ((type == REG_TYPE_NDQ
       && (reg->type == REG_TYPE_NQ || reg->type == REG_TYPE_VFD))
      || (type == REG_TYPE_VFSD
	  && (reg->type == REG_TYPE_VFS || reg->type == REG_TYPE_VFD))
      || (type == REG_TYPE_NSDQ
	  && (reg->type == REG_TYPE_VFS || reg->type == REG_TYPE_VFD
	      || reg->type == REG_TYPE_NQ))
      || (type == REG_TYPE_MMXWC
	  && (reg->type == REG_TYPE_MMXWCG)))
    type = (enum arm_reg_type) reg->type;

  if (type != reg->type)
    return FAIL;

  if (reg->neon)
    atype = *reg->neon;

  if (parse_neon_operand_type (&parsetype, &str) == SUCCESS)
    {
      if ((atype.defined & NTA_HASTYPE) != 0)
	{
	  first_error (_("can't redefine type for operand"));
	  return FAIL;
	}
      atype.defined |= NTA_HASTYPE;
      atype.eltype = parsetype;
    }

  if (skip_past_char (&str, '[') == SUCCESS)
    {
      if (type != REG_TYPE_VFD)
	{
	  first_error (_("only D registers may be indexed"));
	  return FAIL;
	}

      if ((atype.defined & NTA_HASINDEX) != 0)
	{
	  first_error (_("can't change index for operand"));
	  return FAIL;
	}

      atype.defined |= NTA_HASINDEX;

      if (skip_past_char (&str, ']') == SUCCESS)
	atype.index = NEON_ALL_LANES;
      else
	{
	  expressionS exp;

	  my_get_expression (&exp, &str, GE_NO_PREFIX);

	  if (exp.X_op != O_constant)
	    {
	      first_error (_("constant expression required"));
	      return FAIL;
	    }

	  if (skip_past_char (&str, ']') == FAIL)
	    return FAIL;

	  atype.index = exp.X_add_number;
	}
    }

  if (typeinfo)
    *typeinfo = atype;

  if (rtype)
    *rtype = type;

  *ccp = str;

  return reg->number;
}

/* Like arm_reg_parse, but allow allow the following extra features:
    - If RTYPE is non-zero, return the (possibly restricted) type of the
      register (e.g. Neon double or quad reg when either has been requested).
    - If this is a Neon vector type with additional type information, fill
      in the struct pointed to by VECTYPE (if non-NULL).
   This function will fault on encountering a scalar.  */

static int
arm_typed_reg_parse (char **ccp, enum arm_reg_type type,
		     enum arm_reg_type *rtype, struct neon_type_el *vectype)
{
  struct neon_typed_alias atype;
  char *str = *ccp;
  int reg = parse_typed_reg_or_scalar (&str, type, rtype, &atype);

  if (reg == FAIL)
    return FAIL;

  /* Do not allow regname(... to parse as a register.  */
  if (*str == '(')
    return FAIL;

  /* Do not allow a scalar (reg+index) to parse as a register.  */
  if ((atype.defined & NTA_HASINDEX) != 0)
    {
      first_error (_("register operand expected, but got scalar"));
      return FAIL;
    }

  if (vectype)
    *vectype = atype.eltype;

  *ccp = str;

  return reg;
}

#define NEON_SCALAR_REG(X)	((X) >> 4)
#define NEON_SCALAR_INDEX(X)	((X) & 15)

/* Parse a Neon scalar. Most of the time when we're parsing a scalar, we don't
   have enough information to be able to do a good job bounds-checking. So, we
   just do easy checks here, and do further checks later.  */

static int
parse_scalar (char **ccp, int elsize, struct neon_type_el *type)
{
  int reg;
  char *str = *ccp;
  struct neon_typed_alias atype;

  reg = parse_typed_reg_or_scalar (&str, REG_TYPE_VFD, NULL, &atype);

  if (reg == FAIL || (atype.defined & NTA_HASINDEX) == 0)
    return FAIL;

  if (atype.index == NEON_ALL_LANES)
    {
      first_error (_("scalar must have an index"));
      return FAIL;
    }
  else if (atype.index >= 64 / elsize)
    {
      first_error (_("scalar index out of range"));
      return FAIL;
    }

  if (type)
    *type = atype.eltype;

  *ccp = str;

  return reg * 16 + atype.index;
}

/* Parse an ARM register list.  Returns the bitmask, or FAIL.  */

static long
parse_reg_list (char ** strp)
{
  char * str = * strp;
  long	 range = 0;
  int	 another_range;

  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
    {
      skip_whitespace (str);

      another_range = 0;

      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;

	  str++;
	  do
	    {
	      int reg;

	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN)) == FAIL)
		{
		  first_error (_(reg_expected_msgs[REG_TYPE_RN]));
		  return FAIL;
		}

	      if (in_range)
		{
		  int i;

		  if (reg <= cur_reg)
		    {
		      first_error (_("bad range in register list"));
		      return FAIL;
		    }

		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}

	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));

	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;

	  if (skip_past_char (&str, '}') == FAIL)
	    {
	      first_error (_("missing `}'"));
	      return FAIL;
	    }
	}
      else
	{
	  expressionS exp;

	  if (my_get_expression (&exp, &str, GE_NO_PREFIX))
	    return FAIL;

	  if (exp.X_op == O_constant)
	    {
	      if (exp.X_add_number
		  != (exp.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}

	      if ((range & exp.X_add_number) != 0)
		{
		  int regno = range & exp.X_add_number;

		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}

	      range |= exp.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}

	      memcpy (&inst.reloc.exp, &exp, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
	}

      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
    }
  while (another_range);

  *strp = str;
  return range;
}

/* Types of registers in a list.  */

enum reg_list_els
{
  REGLIST_VFP_S,
  REGLIST_VFP_D,
  REGLIST_NEON_D
};

/* Parse a VFP register list.  If the string is invalid return FAIL.
   Otherwise return the number of registers, and set PBASE to the first
   register.  Parses registers of type ETYPE.
   If REGLIST_NEON_D is used, several syntax enhancements are enabled:
     - Q registers can be used to specify pairs of D registers
     - { } can be omitted from around a singleton register list
	 FIXME: This is not implemented, as it would require backtracking in
	 some cases, e.g.:
	   vtbl.8 d3,d4,d5
	 This could be done (the meaning isn't really ambiguous), but doesn't
	 fit in well with the current parsing framework.
     - 32 D registers may be used (also true for VFPv3).
   FIXME: Types are ignored in these register lists, which is probably a
   bug.  */

static int
parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)
{
  char *str = *ccp;
  int base_reg;
  int new_base;
  enum arm_reg_type regtype = (enum arm_reg_type) 0;
  int max_regs = 0;
  int count = 0;
  int warned = 0;
  unsigned long mask = 0;
  int i;

  if (skip_past_char (&str, '{') == FAIL)
    {
      inst.error = _("expecting {");
      return FAIL;
    }

  switch (etype)
    {
    case REGLIST_VFP_S:
      regtype = REG_TYPE_VFS;
      max_regs = 32;
      break;

    case REGLIST_VFP_D:
      regtype = REG_TYPE_VFD;
      break;

    case REGLIST_NEON_D:
      regtype = REG_TYPE_NDQ;
      break;
    }

  if (etype != REGLIST_VFP_S)
    {
      /* VFPv3 allows 32 D registers, except for the VFPv3-D16 variant.  */
      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_d32))
	{
	  max_regs = 32;
	  if (thumb_mode)
	    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
				    fpu_vfp_ext_d32);
	  else
	    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
				    fpu_vfp_ext_d32);
	}
      else
	max_regs = 16;
    }

  base_reg = max_regs;

  do
    {
      int setmask = 1, addregs = 1;

      new_base = arm_typed_reg_parse (&str, regtype, &regtype, NULL);

      if (new_base == FAIL)
	{
	  first_error (_(reg_expected_msgs[regtype]));
	  return FAIL;
	}

      if (new_base >= max_regs)
	{
	  first_error (_("register out of range in list"));
	  return FAIL;
	}

      /* Note: a value of 2 * n is returned for the register Q<n>.  */
      if (regtype == REG_TYPE_NQ)
	{
	  setmask = 3;
	  addregs = 2;
	}

      if (new_base < base_reg)
	base_reg = new_base;

      if (mask & (setmask << new_base))
	{
	  first_error (_("invalid register list"));
	  return FAIL;
	}

      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}

      mask |= setmask << new_base;
      count += addregs;

      if (*str == '-') /* We have the start of a range expression */
	{
	  int high_range;

	  str++;

	  if ((high_range = arm_typed_reg_parse (&str, regtype, NULL, NULL))
	      == FAIL)
	    {
	      inst.error = gettext (reg_expected_msgs[regtype]);
	      return FAIL;
	    }

	  if (high_range >= max_regs)
	    {
	      first_error (_("register out of range in list"));
	      return FAIL;
	    }

	  if (regtype == REG_TYPE_NQ)
	    high_range = high_range + 1;

	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }

	  for (new_base += addregs; new_base <= high_range; new_base += addregs)
	    {
	      if (mask & (setmask << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}

	      mask |= setmask << new_base;
	      count += addregs;
	    }
	}
    }
  while (skip_past_comma (&str) != FAIL);

  str++;

  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > max_regs)
    abort ();

  *pbase = base_reg;

  /* Final test -- the registers must be consecutive.  */
  mask >>= base_reg;
  for (i = 0; i < count; i++)
    {
      if ((mask & (1u << i)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
	}
    }

  *ccp = str;

  return count;
}

/* True if two alias types are the same.  */

static bfd_boolean
neon_alias_types_same (struct neon_typed_alias *a, struct neon_typed_alias *b)
{
  if (!a && !b)
    return TRUE;

  if (!a || !b)
    return FALSE;

  if (a->defined != b->defined)
    return FALSE;

  if ((a->defined & NTA_HASTYPE) != 0
      && (a->eltype.type != b->eltype.type
	  || a->eltype.size != b->eltype.size))
    return FALSE;

  if ((a->defined & NTA_HASINDEX) != 0
      && (a->index != b->index))
    return FALSE;

  return TRUE;
}

/* Parse element/structure lists for Neon VLD<n> and VST<n> instructions.
   The base register is put in *PBASE.
   The lane (or one of the NEON_*_LANES constants) is placed in bits [3:0] of
   the return value.
   The register stride (minus one) is put in bit 4 of the return value.
   Bits [6:5] encode the list length (minus one).
   The type of the list elements is put in *ELTYPE, if non-NULL.  */

#define NEON_LANE(X)		((X) & 0xf)
#define NEON_REG_STRIDE(X)	((((X) >> 4) & 1) + 1)
#define NEON_REGLIST_LENGTH(X)	((((X) >> 5) & 3) + 1)

static int
parse_neon_el_struct_list (char **str, unsigned *pbase,
			   struct neon_type_el *eltype)
{
  char *ptr = *str;
  int base_reg = -1;
  int reg_incr = -1;
  int count = 0;
  int lane = -1;
  int leading_brace = 0;
  enum arm_reg_type rtype = REG_TYPE_NDQ;
  const char *const incr_error = _("register stride must be 1 or 2");
  const char *const type_error = _("mismatched element/structure types in list");
  struct neon_typed_alias firsttype;

  if (skip_past_char (&ptr, '{') == SUCCESS)
    leading_brace = 1;

  do
    {
      struct neon_typed_alias atype;
      int getreg = parse_typed_reg_or_scalar (&ptr, rtype, &rtype, &atype);

      if (getreg == FAIL)
	{
	  first_error (_(reg_expected_msgs[rtype]));
	  return FAIL;
	}

      if (base_reg == -1)
	{
	  base_reg = getreg;
	  if (rtype == REG_TYPE_NQ)
	    {
	      reg_incr = 1;
	    }
	  firsttype = atype;
	}
      else if (reg_incr == -1)
	{
	  reg_incr = getreg - base_reg;
	  if (reg_incr < 1 || reg_incr > 2)
	    {
	      first_error (_(incr_error));
	      return FAIL;
	    }
	}
      else if (getreg != base_reg + reg_incr * count)
	{
	  first_error (_(incr_error));
	  return FAIL;
	}

      if (! neon_alias_types_same (&atype, &firsttype))
	{
	  first_error (_(type_error));
	  return FAIL;
	}

      /* Handle Dn-Dm or Qn-Qm syntax. Can only be used with non-indexed list
	 modes.  */
      if (ptr[0] == '-')
	{
	  struct neon_typed_alias htype;
	  int hireg, dregs = (rtype == REG_TYPE_NQ) ? 2 : 1;
	  if (lane == -1)
	    lane = NEON_INTERLEAVE_LANES;
	  else if (lane != NEON_INTERLEAVE_LANES)
	    {
	      first_error (_(type_error));
	      return FAIL;
	    }
	  if (reg_incr == -1)
	    reg_incr = 1;
	  else if (reg_incr != 1)
	    {
	      first_error (_("don't use Rn-Rm syntax with non-unit stride"));
	      return FAIL;
	    }
	  ptr++;
	  hireg = parse_typed_reg_or_scalar (&ptr, rtype, NULL, &htype);
	  if (hireg == FAIL)
	    {
	      first_error (_(reg_expected_msgs[rtype]));
	      return FAIL;
	    }
	  if (! neon_alias_types_same (&htype, &firsttype))
	    {
	      first_error (_(type_error));
	      return FAIL;
	    }
	  count += hireg + dregs - getreg;
	  continue;
	}

      /* If we're using Q registers, we can't use [] or [n] syntax.  */
      if (rtype == REG_TYPE_NQ)
	{
	  count += 2;
	  continue;
	}

      if ((atype.defined & NTA_HASINDEX) != 0)
	{
	  if (lane == -1)
	    lane = atype.index;
	  else if (lane != atype.index)
	    {
	      first_error (_(type_error));
	      return FAIL;
	    }
	}
      else if (lane == -1)
	lane = NEON_INTERLEAVE_LANES;
      else if (lane != NEON_INTERLEAVE_LANES)
	{
	  first_error (_(type_error));
	  return FAIL;
	}
      count++;
    }
  while ((count != 1 || leading_brace) && skip_past_comma (&ptr) != FAIL);

  /* No lane set by [x]. We must be interleaving structures.  */
  if (lane == -1)
    lane = NEON_INTERLEAVE_LANES;

  /* Sanity check.  */
  if (lane == -1 || base_reg == -1 || count < 1 || count > 4
      || (count > 1 && reg_incr == -1))
    {
      first_error (_("error parsing element/structure list"));
      return FAIL;
    }

  if ((count > 1 || leading_brace) && skip_past_char (&ptr, '}') == FAIL)
    {
      first_error (_("expected }"));
      return FAIL;
    }

  if (reg_incr == -1)
    reg_incr = 1;

  if (eltype)
    *eltype = firsttype.eltype;

  *pbase = base_reg;
  *str = ptr;

  return lane | ((reg_incr - 1) << 4) | ((count - 1) << 5);
}

/* Parse an explicit relocation suffix on an expression.  This is
   either nothing, or a word in parentheses.  Note that if !OBJ_ELF,
   arm_reloc_hsh contains no entries, so this function can only
   succeed if there is no () after the word.  Returns -1 on error,
   BFD_RELOC_UNUSED if there wasn't any suffix.	 */

static int
parse_reloc (char **str)
{
  struct reloc_entry *r;
  char *p, *q;

  if (**str != '(')
    return BFD_RELOC_UNUSED;

  p = *str + 1;
  q = p;

  while (*q && *q != ')' && *q != ',')
    q++;
  if (*q != ')')
    return -1;

  if ((r = (struct reloc_entry *)
       hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)
    return -1;

  *str = q + 1;
  return r->reloc;
}

/* Directives: register aliases.  */

static struct reg_entry *
insert_reg_alias (char *str, unsigned number, int type)
{
  struct reg_entry *new_reg;
  const char *name;

  if ((new_reg = (struct reg_entry *) hash_find (arm_reg_hsh, str)) != 0)
    {
      if (new_reg->builtin)
	as_warn (_("ignoring attempt to redefine built-in register '%s'"), str);

      /* Only warn about a redefinition if it's not defined as the
	 same register.	 */
      else if (new_reg->number != number || new_reg->type != type)
	as_warn (_("ignoring redefinition of register alias '%s'"), str);

      return NULL;
    }

  name = xstrdup (str);
  new_reg = (struct reg_entry *) xmalloc (sizeof (struct reg_entry));

  new_reg->name = name;
  new_reg->number = number;
  new_reg->type = type;
  new_reg->builtin = FALSE;
  new_reg->neon = NULL;

  if (hash_insert (arm_reg_hsh, name, (void *) new_reg))
    abort ();

  return new_reg;
}

static void
insert_neon_reg_alias (char *str, int number, int type,
		       struct neon_typed_alias *atype)
{
  struct reg_entry *reg = insert_reg_alias (str, number, type);

  if (!reg)
    {
      first_error (_("attempt to redefine typed alias"));
      return;
    }

  if (atype)
    {
      reg->neon = (struct neon_typed_alias *)
	  xmalloc (sizeof (struct neon_typed_alias));
      *reg->neon = *atype;
    }
}

/* Look for the .req directive.	 This is of the form:

	new_register_name .req existing_register_name

   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return TRUE.  Otherwise return FALSE.  */

static bfd_boolean
create_register_alias (char * newname, char *p)
{
  struct reg_entry *old;
  char *oldname, *nbuf;
  size_t nlen;

  /* The input scrubber ensures that whitespace after the mnemonic is
     collapsed to single spaces.  */
  oldname = p;
  if (strncmp (oldname, " .req ", 6) != 0)
    return FALSE;

  oldname += 6;
  if (*oldname == '\0')
    return FALSE;

  old = (struct reg_entry *) hash_find (arm_reg_hsh, oldname);
  if (!old)
    {
      as_warn (_("unknown register '%s' -- .req ignored"), oldname);
      return TRUE;
    }

  /* If TC_CASE_SENSITIVE is defined, then newname already points to
     the desired alias name, and p points to its end.  If not, then
     the desired alias name is in the global original_case_string.  */
#ifdef TC_CASE_SENSITIVE
  nlen = p - newname;
#else
  newname = original_case_string;
  nlen = strlen (newname);
#endif

  nbuf = (char *) alloca (nlen + 1);
  memcpy (nbuf, newname, nlen);
  nbuf[nlen] = '\0';

  /* Create aliases under the new name as stated; an all-lowercase
     version of the new name; and an all-uppercase version of the new
     name.  */
  if (insert_reg_alias (nbuf, old->number, old->type) != NULL)
    {
      for (p = nbuf; *p; p++)
	*p = TOUPPER (*p);

      if (strncmp (nbuf, newname, nlen))
	{
	  /* If this attempt to create an additional alias fails, do not bother
	     trying to create the all-lower case alias.  We will fail and issue
	     a second, duplicate error message.  This situation arises when the
	     programmer does something like:
	       foo .req r0
	       Foo .req r1
	     The second .req creates the "Foo" alias but then fails to create
	     the artificial FOO alias because it has already been created by the
	     first .req.  */
	  if (insert_reg_alias (nbuf, old->number, old->type) == NULL)
	    return TRUE;
	}

      for (p = nbuf; *p; p++)
	*p = TOLOWER (*p);

      if (strncmp (nbuf, newname, nlen))
	insert_reg_alias (nbuf, old->number, old->type);
    }

  return TRUE;
}

/* Create a Neon typed/indexed register alias using directives, e.g.:
     X .dn d5.s32[1]
     Y .qn 6.s16
     Z .dn d7
     T .dn Z[0]
   These typed registers can be used instead of the types specified after the
   Neon mnemonic, so long as all operands given have types. Types can also be
   specified directly, e.g.:
     vadd d0.s32, d1.s32, d2.s32  */

static bfd_boolean
create_neon_reg_alias (char *newname, char *p)
{
  enum arm_reg_type basetype;
  struct reg_entry *basereg;
  struct reg_entry mybasereg;
  struct neon_type ntype;
  struct neon_typed_alias typeinfo;
  char *namebuf, *nameend ATTRIBUTE_UNUSED;
  int namelen;

  typeinfo.defined = 0;
  typeinfo.eltype.type = NT_invtype;
  typeinfo.eltype.size = -1;
  typeinfo.index = -1;

  nameend = p;

  if (strncmp (p, " .dn ", 5) == 0)
    basetype = REG_TYPE_VFD;
  else if (strncmp (p, " .qn ", 5) == 0)
    basetype = REG_TYPE_NQ;
  else
    return FALSE;

  p += 5;

  if (*p == '\0')
    return FALSE;

  basereg = arm_reg_parse_multi (&p);

  if (basereg && basereg->type != basetype)
    {
      as_bad (_("bad type for register"));
      return FALSE;
    }

  if (basereg == NULL)
    {
      expressionS exp;
      /* Try parsing as an integer.  */
      my_get_expression (&exp, &p, GE_NO_PREFIX);
      if (exp.X_op != O_constant)
	{
	  as_bad (_("expression must be constant"));
	  return FALSE;
	}
      basereg = &mybasereg;
      basereg->number = (basetype == REG_TYPE_NQ) ? exp.X_add_number * 2
						  : exp.X_add_number;
      basereg->neon = 0;
    }

  if (basereg->neon)
    typeinfo = *basereg->neon;

  if (parse_neon_type (&ntype, &p) == SUCCESS)
    {
      /* We got a type.  */
      if (typeinfo.defined & NTA_HASTYPE)
	{
	  as_bad (_("can't redefine the type of a register alias"));
	  return FALSE;
	}

      typeinfo.defined |= NTA_HASTYPE;
      if (ntype.elems != 1)
	{
	  as_bad (_("you must specify a single type only"));
	  return FALSE;
	}
      typeinfo.eltype = ntype.el[0];
    }

  if (skip_past_char (&p, '[') == SUCCESS)
    {
      expressionS exp;
      /* We got a scalar index.  */

      if (typeinfo.defined & NTA_HASINDEX)
	{
	  as_bad (_("can't redefine the index of a scalar alias"));
	  return FALSE;
	}

      my_get_expression (&exp, &p, GE_NO_PREFIX);

      if (exp.X_op != O_constant)
	{
	  as_bad (_("scalar index must be constant"));
	  return FALSE;
	}

      typeinfo.defined |= NTA_HASINDEX;
      typeinfo.index = exp.X_add_number;

      if (skip_past_char (&p, ']') == FAIL)
	{
	  as_bad (_("expecting ]"));
	  return FALSE;
	}
    }

  /* If TC_CASE_SENSITIVE is defined, then newname already points to
     the desired alias name, and p points to its end.  If not, then
     the desired alias name is in the global original_case_string.  */
#ifdef TC_CASE_SENSITIVE
  namelen = nameend - newname;
#else
  newname = original_case_string;
  namelen = strlen (newname);
#endif

  namebuf = (char *) alloca (namelen + 1);
  strncpy (namebuf, newname, namelen);
  namebuf[namelen] = '\0';

  insert_neon_reg_alias (namebuf, basereg->number, basetype,
			 typeinfo.defined != 0 ? &typeinfo : NULL);

  /* Insert name in all uppercase.  */
  for (p = namebuf; *p; p++)
    *p = TOUPPER (*p);

  if (strncmp (namebuf, newname, namelen))
    insert_neon_reg_alias (namebuf, basereg->number, basetype,
			   typeinfo.defined != 0 ? &typeinfo : NULL);

  /* Insert name in all lowercase.  */
  for (p = namebuf; *p; p++)
    *p = TOLOWER (*p);

  if (strncmp (namebuf, newname, namelen))
    insert_neon_reg_alias (namebuf, basereg->number, basetype,
			   typeinfo.defined != 0 ? &typeinfo : NULL);

  return TRUE;
}

/* Should never be called, as .req goes between the alias and the
   register name, not at the beginning of the line.  */

static void
s_req (int a ATTRIBUTE_UNUSED)
{
  as_bad (_("invalid syntax for .req directive"));
}

static void
s_dn (int a ATTRIBUTE_UNUSED)
{
  as_bad (_("invalid syntax for .dn directive"));
}

static void
s_qn (int a ATTRIBUTE_UNUSED)
{
  as_bad (_("invalid syntax for .qn directive"));
}

/* The .unreq directive deletes an alias which was previously defined
   by .req.  For example:

       my_alias .req r11
       .unreq my_alias	  */

static void
s_unreq (int a ATTRIBUTE_UNUSED)
{
  char * name;
  char saved_char;

  name = input_line_pointer;

  while (*input_line_pointer != 0
	 && *input_line_pointer != ' '
	 && *input_line_pointer != '\n')
    ++input_line_pointer;

  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  if (!*name)
    as_bad (_("invalid syntax for .unreq directive"));
  else
    {
      struct reg_entry *reg = (struct reg_entry *) hash_find (arm_reg_hsh,
							      name);

      if (!reg)
	as_bad (_("unknown register alias '%s'"), name);
      else if (reg->builtin)
	as_warn (_("ignoring attempt to use .unreq on fixed register name: '%s'"),
		 name);
      else
	{
	  char * p;
	  char * nbuf;

	  hash_delete (arm_reg_hsh, name, FALSE);
	  free ((char *) reg->name);
	  if (reg->neon)
	    free (reg->neon);
	  free (reg);

	  /* Also locate the all upper case and all lower case versions.
	     Do not complain if we cannot find one or the other as it
	     was probably deleted above.  */

	  nbuf = strdup (name);
	  for (p = nbuf; *p; p++)
	    *p = TOUPPER (*p);
	  reg = (struct reg_entry *) hash_find (arm_reg_hsh, nbuf);
	  if (reg)
	    {
	      hash_delete (arm_reg_hsh, nbuf, FALSE);
	      free ((char *) reg->name);
	      if (reg->neon)
		free (reg->neon);
	      free (reg);
	    }

	  for (p = nbuf; *p; p++)
	    *p = TOLOWER (*p);
	  reg = (struct reg_entry *) hash_find (arm_reg_hsh, nbuf);
	  if (reg)
	    {
	      hash_delete (arm_reg_hsh, nbuf, FALSE);
	      free ((char *) reg->name);
	      if (reg->neon)
		free (reg->neon);
	      free (reg);
	    }

	  free (nbuf);
	}
    }

  *input_line_pointer = saved_char;
  demand_empty_rest_of_line ();
}

/* Directives: Instruction set selection.  */

#ifdef OBJ_ELF
/* This code is to handle mapping symbols as defined in the ARM ELF spec.
   (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).
   Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),
   and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */

/* Create a new mapping symbol for the transition to STATE.  */

static void
make_mapping_symbol (enum mstate state, valueT value, fragS *frag)
{
  symbolS * symbolP;
  const char * symname;
  int type;

  switch (state)
    {
    case MAP_DATA:
      symname = "$d";
      type = BSF_NO_FLAGS;
      break;
    case MAP_ARM:
      symname = "$a";
      type = BSF_NO_FLAGS;
      break;
    case MAP_THUMB:
      symname = "$t";
      type = BSF_NO_FLAGS;
      break;
    default:
      abort ();
    }

  symbolP = symbol_new (symname, now_seg, value, frag);
  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;

  switch (state)
    {
    case MAP_ARM:
      THUMB_SET_FUNC (symbolP, 0);
      ARM_SET_THUMB (symbolP, 0);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;

    case MAP_THUMB:
      THUMB_SET_FUNC (symbolP, 1);
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;

    case MAP_DATA:
    default:
      break;
    }

  /* Save the mapping symbols for future reference.  Also check that
     we do not place two mapping symbols at the same offset within a
     frag.  We'll handle overlap between frags in
     check_mapping_symbols.

     If .fill or other data filling directive generates zero sized data,
     the mapping symbol for the following code will have the same value
     as the one generated for the data filling directive.  In this case,
     we replace the old symbol with the new one at the same address.  */
  if (value == 0)
    {
      if (frag->tc_frag_data.first_map != NULL)
	{
	  know (S_GET_VALUE (frag->tc_frag_data.first_map) == 0);
	  symbol_remove (frag->tc_frag_data.first_map, &symbol_rootP, &symbol_lastP);
	}
      frag->tc_frag_data.first_map = symbolP;
    }
  if (frag->tc_frag_data.last_map != NULL)
    {
      know (S_GET_VALUE (frag->tc_frag_data.last_map) <= S_GET_VALUE (symbolP));
      if (S_GET_VALUE (frag->tc_frag_data.last_map) == S_GET_VALUE (symbolP))
	symbol_remove (frag->tc_frag_data.last_map, &symbol_rootP, &symbol_lastP);
    }
  frag->tc_frag_data.last_map = symbolP;
}

/* We must sometimes convert a region marked as code to data during
   code alignment, if an odd number of bytes have to be padded.  The
   code mapping symbol is pushed to an aligned address.  */

static void
insert_data_mapping_symbol (enum mstate state,
			    valueT value, fragS *frag, offsetT bytes)
{
  /* If there was already a mapping symbol, remove it.  */
  if (frag->tc_frag_data.last_map != NULL
      && S_GET_VALUE (frag->tc_frag_data.last_map) == frag->fr_address + value)
    {
      symbolS *symp = frag->tc_frag_data.last_map;

      if (value == 0)
	{
	  know (frag->tc_frag_data.first_map == symp);
	  frag->tc_frag_data.first_map = NULL;
	}
      frag->tc_frag_data.last_map = NULL;
      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
    }

  make_mapping_symbol (MAP_DATA, value, frag);
  make_mapping_symbol (state, value + bytes, frag);
}

static void mapping_state_2 (enum mstate state, int max_chars);

/* Set the mapping state to STATE.  Only call this when about to
   emit some STATE bytes to the file.  */

void
mapping_state (enum mstate state)
{
  enum mstate mapstate = seg_info (now_seg)->tc_segment_info_data.mapstate;

#define TRANSITION(from, to) (mapstate == (from) && state == (to))

  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;

  if (state == MAP_ARM || state == MAP_THUMB)
    /*  PR gas/12931
	All ARM instructions require 4-byte alignment.
	(Almost) all Thumb instructions require 2-byte alignment.

	When emitting instructions into any section, mark the section
	appropriately.

	Some Thumb instructions are alignment-sensitive modulo 4 bytes,
	but themselves require 2-byte alignment; this applies to some
	PC- relative forms.  However, these cases will invovle implicit
	literal pool generation or an explicit .align >=2, both of
	which will cause the section to me marked with sufficient
	alignment.  Thus, we don't handle those cases here.  */
    record_alignment (now_seg, state == MAP_ARM ? 2 : 1);

  if (TRANSITION (MAP_UNDEFINED, MAP_DATA))
    /* This case will be evaluated later in the next else.  */
    return;
  else if (TRANSITION (MAP_UNDEFINED, MAP_ARM)
	  || TRANSITION (MAP_UNDEFINED, MAP_THUMB))
    {
      /* Only add the symbol if the offset is > 0:
	 if we're at the first frag, check it's size > 0;
	 if we're not at the first frag, then for sure
	    the offset is > 0.  */
      struct frag * const frag_first = seg_info (now_seg)->frchainP->frch_root;
      const int add_symbol = (frag_now != frag_first) || (frag_now_fix () > 0);

      if (add_symbol)
	make_mapping_symbol (MAP_DATA, (valueT) 0, frag_first);
    }

  mapping_state_2 (state, 0);
#undef TRANSITION
}

/* Same as mapping_state, but MAX_CHARS bytes have already been
   allocated.  Put the mapping symbol that far back.  */

static void
mapping_state_2 (enum mstate state, int max_chars)
{
  enum mstate mapstate = seg_info (now_seg)->tc_segment_info_data.mapstate;

  if (!SEG_NORMAL (now_seg))
    return;

  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;

  seg_info (now_seg)->tc_segment_info_data.mapstate = state;
  make_mapping_symbol (state, (valueT) frag_now_fix () - max_chars, frag_now);
}
#else
#define mapping_state(x) ((void)0)
#define mapping_state_2(x, y) ((void)0)
#endif

/* Find the real, Thumb encoded start of a Thumb function.  */

#ifdef OBJ_COFF
static symbolS *
find_real_start (symbolS * symbolP)
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;

  /* This definition must agree with the one in gcc/config/arm/thumb.c.	 */
#define STUB_NAME ".real_start_of"

  if (name == NULL)
    abort ();

  /* The compiler may generate BL instructions to local labels because
     it needs to perform a branch to a far away location. These labels
     do not have a corresponding ".real_start_of" label.  We check
     both for S_IS_LOCAL and for a leading dot, to give a way to bypass
     the ".real_start_of" convention for nonlocal branches.  */
  if (S_IS_LOCAL (symbolP) || name[0] == '.')
    return symbolP;

  real_start = ACONCAT ((STUB_NAME, name, NULL));
  new_target = symbol_find (real_start);

  if (new_target == NULL)
    {
      as_warn (_("Failed to find real start of function: %s\n"), name);
      new_target = symbolP;
    }

  return new_target;
}
#endif

static void
opcode_select (int width)
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
	{
	  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v4t))
	    as_bad (_("selected processor does not support THUMB opcodes"));

	  thumb_mode = 1;
	  /* No need to force the alignment, since we will have been
	     coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
	}
      break;

    case 32:
      if (thumb_mode)
	{
	  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1))
	    as_bad (_("selected processor does not support ARM opcodes"));

	  thumb_mode = 0;

	  if (!need_pass_2)
	    frag_align (2, 0, 0);

	  record_alignment (now_seg, 1);
	}
      break;

    default:
      as_bad (_("invalid instruction size selected (%d)"), width);
    }
}

static void
s_arm (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (32);
  demand_empty_rest_of_line ();
}

static void
s_thumb (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (16);
  demand_empty_rest_of_line ();
}

static void
s_code (int unused ATTRIBUTE_UNUSED)
{
  int temp;

  temp = get_absolute_expression ();
  switch (temp)
    {
    case 16:
    case 32:
      opcode_select (temp);
      break;

    default:
      as_bad (_("invalid operand to .code directive (%d) (expecting 16 or 32)"), temp);
    }
}

static void
s_force_thumb (int ignore ATTRIBUTE_UNUSED)
{
  /* If we are not already in thumb mode go into it, EVEN if
     the target processor does not support thumb instructions.
     This is used by gcc/config/arm/lib1funcs.asm for example
     to compile interworking support functions even if the
     target processor should not support interworking.	*/
  if (! thumb_mode)
    {
      thumb_mode = 2;
      record_alignment (now_seg, 1);
    }

  demand_empty_rest_of_line ();
}

static void
s_thumb_func (int ignore ATTRIBUTE_UNUSED)
{
  s_thumb (0);

  /* The following label is the name/address of the start of a Thumb function.
     We need to know this for the interworking support.	 */
  label_is_thumb_function_name = TRUE;
}

/* Perform a .set directive, but also mark the alias as
   being a thumb function.  */

static void
s_thumb_set (int equiv)
{
  /* XXX the following is a duplicate of the code for s_set() in read.c
     We cannot just call that code as we need to get at the symbol that
     is created.  */
  char *    name;
  char	    delim;
  char *    end_name;
  symbolS * symbolP;

  /* Especial apologies for the random logic:
     This just grew, and could be parsed much more simply!
     Dean - in haste.  */
  name	    = input_line_pointer;
  delim	    = get_symbol_end ();
  end_name  = input_line_pointer;
  *end_name = delim;

  if (*input_line_pointer != ',')
    {
      *end_name = 0;
      as_bad (_("expected comma after name \"%s\""), name);
      *end_name = delim;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;
  *end_name = 0;

  if (name[0] == '.' && name[1] == '\0')
    {
      /* XXX - this should not happen to .thumb_set.  */
      abort ();
    }

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
	 for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct * listing_tail;
	  fragS * dummy_frag = (fragS * ) xmalloc (sizeof (fragS));

	  memset (dummy_frag, 0, sizeof (fragS));
	  dummy_frag->fr_type = rs_fill;
	  dummy_frag->line = listing_tail;
	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
	  dummy_frag->fr_symbol = symbolP;
	}
      else
#endif
	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF  */
    }				/* Make a new symbol.  */

  symbol_table_insert (symbolP);

  * end_name = delim;

  if (equiv
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));

  pseudo_set (symbolP);

  demand_empty_rest_of_line ();

  /* XXX Now we come to the Thumb specific bit of code.	 */

  THUMB_SET_FUNC (symbolP, 1);
  ARM_SET_THUMB (symbolP, 1);
#if defined OBJ_ELF || defined OBJ_COFF
  ARM_SET_INTERWORK (symbolP, support_interwork);
#endif
}

/* Directives: Mode selection.  */

/* .syntax [unified|divided] - choose the new unified syntax
   (same for Arm and Thumb encoding, modulo slight differences in what
   can be represented) or the old divergent syntax for each mode.  */
static void
s_syntax (int unused ATTRIBUTE_UNUSED)
{
  char *name, delim;

  name = input_line_pointer;
  delim = get_symbol_end ();

  if (!strcasecmp (name, "unified"))
    unified_syntax = TRUE;
  else if (!strcasecmp (name, "divided"))
    unified_syntax = FALSE;
  else
    {
      as_bad (_("unrecognized syntax mode \"%s\""), name);
      return;
    }
  *input_line_pointer = delim;
  demand_empty_rest_of_line ();
}

/* Directives: sectioning and alignment.  */

/* Same as s_align_ptwo but align 0 => align 2.	 */

static void
s_align (int unused ATTRIBUTE_UNUSED)
{
  int temp;
  bfd_boolean fill_p;
  long temp_fill;
  long max_alignment = 15;

  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad (_("alignment too large: %d assumed"), temp = max_alignment);
  else if (temp < 0)
    {
      as_bad (_("alignment negative. 0 assumed."));
      temp = 0;
    }

  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
      fill_p = TRUE;
    }
  else
    {
      fill_p = FALSE;
      temp_fill = 0;
    }

  if (!temp)
    temp = 2;

  /* Only make a frag if we HAVE to.  */
  if (temp && !need_pass_2)
    {
      if (!fill_p && subseg_text_p (now_seg))
	frag_align_code (temp, 0);
      else
	frag_align (temp, (int) temp_fill, 0);
    }
  demand_empty_rest_of_line ();

  record_alignment (now_seg, temp);
}

static void
s_bss (int ignore ATTRIBUTE_UNUSED)
{
  /* We don't support putting frags in the BSS segment, we fake it by
     marking in_bss, then looking at s_skip for clues.	*/
  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
s_even (int ignore ATTRIBUTE_UNUSED)
{
  /* Never make frag if expect extra pass.  */
  if (!need_pass_2)
    frag_align (1, 0, 0);

  record_alignment (now_seg, 1);

  demand_empty_rest_of_line ();
}

/* Directives: Literal pools.  */

static literal_pool *
find_literal_pool (void)
{
  literal_pool * pool;

  for (pool = list_of_pools; pool != NULL; pool = pool->next)
    {
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
    }

  return pool;
}

static literal_pool *
find_or_make_literal_pool (void)
{
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;

  pool = find_literal_pool ();

  if (pool == NULL)
    {
      /* Create a new pool.  */
      pool = (literal_pool *) xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;

      pool->next_free_entry = 0;
      pool->section	    = now_seg;
      pool->sub_section	    = now_subseg;
      pool->next	    = list_of_pools;
      pool->symbol	    = NULL;

      /* Add it to the list.  */
      list_of_pools = pool;
    }

  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
    {
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
    }

  /* Done.  */
  return pool;
}

/* Add the literal in the global 'inst'
   structure to the relevant literal pool.  */

static int
add_to_lit_pool (void)
{
  literal_pool * pool;
  unsigned int entry;

  pool = find_or_make_literal_pool ();

  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    {
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
	break;

      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_symbol)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
	  && (pool->literals[entry].X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
	break;
    }

  /* Do we need to create a new entry?	*/
  if (entry == pool->next_free_entry)
    {
      if (entry >= MAX_LITERAL_POOL_SIZE)
	{
	  inst.error = _("literal pool overflow");
	  return FAIL;
	}

      pool->literals[entry] = inst.reloc.exp;
#ifdef OBJ_ELF
      /* PR ld/12974: Record the location of the first source line to reference
	 this entry in the literal pool.  If it turns out during linking that the
	 symbol does not exist we will be able to give an accurate line number for
	 the (first use of the) missing reference.  */
      if (debug_type == DEBUG_DWARF2)
	dwarf2_where (pool->locs + entry);
#endif
      pool->next_free_entry += 1;
    }

  inst.reloc.exp.X_op	      = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4;
  inst.reloc.exp.X_add_symbol = pool->symbol;

  return SUCCESS;
}

/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */

static void
symbol_locate (symbolS *    symbolP,
	       const char * name,	/* It is copied, the caller can modify.	 */
	       segT	    segment,	/* Segment identifier (SEG_<something>).  */
	       valueT	    valu,	/* Symbol value.  */
	       fragS *	    frag)	/* Associated fragment.	 */
{
  unsigned int name_length;
  char * preserved_copy_of_name;

  name_length = strlen (name) + 1;   /* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = (char *) obstack_finish (&notes);

#ifdef tc_canonicalize_symbol_name
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
#endif

  S_SET_NAME (symbolP, preserved_copy_of_name);

  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);

  symbol_set_frag (symbolP, frag);

  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;

    if (symbol_table_frozen)
      abort ();
  }

  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);

  obj_symbol_new_hook (symbolP);

#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif

#ifdef DEBUG_SYMS
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS  */
}


static void
s_ltorg (int ignored ATTRIBUTE_UNUSED)
{
  unsigned int entry;
  literal_pool * pool;
  char sym_name[20];

  pool = find_literal_pool ();
  if (pool == NULL
      || pool->symbol == NULL
      || pool->next_free_entry == 0)
    return;

  mapping_state (MAP_DATA);

  /* Align pool as you have word accesses.
     Only make a frag if we have to.  */
  if (!need_pass_2)
    frag_align (2, 0, 0);

  record_alignment (now_seg, 2);

  sprintf (sym_name, "$$lit_\002%x", pool->id);

  symbol_locate (pool->symbol, sym_name, now_seg,
		 (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (pool->symbol);

  ARM_SET_THUMB (pool->symbol, thumb_mode);

#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (pool->symbol, support_interwork);
#endif

  for (entry = 0; entry < pool->next_free_entry; entry ++)
    {
#ifdef OBJ_ELF
      if (debug_type == DEBUG_DWARF2)
	dwarf2_gen_line_info (frag_now_fix (), pool->locs + entry);
#endif
      /* First output the expression in the instruction to the pool.  */
      emit_expr (&(pool->literals[entry]), 4); /* .word  */
    }

  /* Mark the pool as empty.  */
  pool->next_free_entry = 0;
  pool->symbol = NULL;
}

#ifdef OBJ_ELF
/* Forward declarations for functions below, in the MD interface
   section.  */
static void fix_new_arm (fragS *, int, short, expressionS *, int, int);
static valueT create_unwind_entry (int);
static void start_unwind_section (const segT, int);
static void add_unwind_opcode (valueT, int);
static void flush_pending_unwind (void);

/* Directives: Data.  */

static void
s_arm_elf_cons (int nbytes)
{
  expressionS exp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  mapping_state (MAP_DATA);
  do
    {
      int reloc;
      char *base = input_line_pointer;

      expression (& exp);

      if (exp.X_op != O_symbol)
	emit_expr (&exp, (unsigned int) nbytes);
      else
	{
	  char *before_reloc = input_line_pointer;
	  reloc = parse_reloc (&input_line_pointer);
	  if (reloc == -1)
	    {
	      as_bad (_("unrecognized relocation suffix"));
	      ignore_rest_of_line ();
	      return;
	    }
	  else if (reloc == BFD_RELOC_UNUSED)
	    emit_expr (&exp, (unsigned int) nbytes);
	  else
	    {
	      reloc_howto_type *howto = (reloc_howto_type *)
		  bfd_reloc_type_lookup (stdoutput,
					 (bfd_reloc_code_real_type) reloc);
	      int size = bfd_get_reloc_size (howto);

	      if (reloc == BFD_RELOC_ARM_PLT32)
		{
		  as_bad (_("(plt) is only valid on branch targets"));
		  reloc = BFD_RELOC_UNUSED;
		  size = 0;
		}

	      if (size > nbytes)
		as_bad (_("%s relocations do not fit in %d bytes"),
			howto->name, nbytes);
	      else
		{
		  /* We've parsed an expression stopping at O_symbol.
		     But there may be more expression left now that we
		     have parsed the relocation marker.  Parse it again.
		     XXX Surely there is a cleaner way to do this.  */
		  char *p = input_line_pointer;
		  int offset;
		  char *save_buf = (char *) alloca (input_line_pointer - base);
		  memcpy (save_buf, base, input_line_pointer - base);
		  memmove (base + (input_line_pointer - before_reloc),
			   base, before_reloc - base);

		  input_line_pointer = base + (input_line_pointer-before_reloc);
		  expression (&exp);
		  memcpy (base, save_buf, p - base);

		  offset = nbytes - size;
		  p = frag_more ((int) nbytes);
		  fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
			       size, &exp, 0, (enum bfd_reloc_code_real) reloc);
		}
	    }
	}
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer --;
  demand_empty_rest_of_line ();
}

/* Emit an expression containing a 32-bit thumb instruction.
   Implementation based on put_thumb32_insn.  */

static void
emit_thumb32_expr (expressionS * exp)
{
  expressionS exp_high = *exp;

  exp_high.X_add_number = (unsigned long)exp_high.X_add_number >> 16;
  emit_expr (& exp_high, (unsigned int) THUMB_SIZE);
  exp->X_add_number &= 0xffff;
  emit_expr (exp, (unsigned int) THUMB_SIZE);
}

/*  Guess the instruction size based on the opcode.  */

static int
thumb_insn_size (int opcode)
{
  if ((unsigned int) opcode < 0xe800u)
    return 2;
  else if ((unsigned int) opcode >= 0xe8000000u)
    return 4;
  else
    return 0;
}

static bfd_boolean
emit_insn (expressionS *exp, int nbytes)
{
  int size = 0;

  if (exp->X_op == O_constant)
    {
      size = nbytes;

      if (size == 0)
	size = thumb_insn_size (exp->X_add_number);

      if (size != 0)
	{
	  if (size == 2 && (unsigned int)exp->X_add_number > 0xffffu)
	    {
	      as_bad (_(".inst.n operand too big. "\
			"Use .inst.w instead"));
	      size = 0;
	    }
	  else
	    {
	      if (now_it.state == AUTOMATIC_IT_BLOCK)
		set_it_insn_type_nonvoid (OUTSIDE_IT_INSN, 0);
	      else
		set_it_insn_type_nonvoid (NEUTRAL_IT_INSN, 0);

	      if (thumb_mode && (size > THUMB_SIZE) && !target_big_endian)
		emit_thumb32_expr (exp);
	      else
		emit_expr (exp, (unsigned int) size);

	      it_fsm_post_encode ();
	    }
	}
      else
	as_bad (_("cannot determine Thumb instruction size. "	\
		  "Use .inst.n/.inst.w instead"));
    }
  else
    as_bad (_("constant expression required"));

  return (size != 0);
}

/* Like s_arm_elf_cons but do not use md_cons_align and
   set the mapping state to MAP_ARM/MAP_THUMB.  */

static void
s_arm_elf_inst (int nbytes)
{
  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  /* Calling mapping_state () here will not change ARM/THUMB,
     but will ensure not to be in DATA state.  */

  if (thumb_mode)
    mapping_state (MAP_THUMB);
  else
    {
      if (nbytes != 0)
	{
	  as_bad (_("width suffixes are invalid in ARM mode"));
	  ignore_rest_of_line ();
	  return;
	}

      nbytes = 4;

      mapping_state (MAP_ARM);
    }

  do
    {
      expressionS exp;

      expression (& exp);

      if (! emit_insn (& exp, nbytes))
	{
	  ignore_rest_of_line ();
	  return;
	}
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer --;
  demand_empty_rest_of_line ();
}

/* Parse a .rel31 directive.  */

static void
s_arm_rel31 (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
  char *p;
  valueT highbit;

  highbit = 0;
  if (*input_line_pointer == '1')
    highbit = 0x80000000;
  else if (*input_line_pointer != '0')
    as_bad (_("expected 0 or 1"));

  input_line_pointer++;
  if (*input_line_pointer != ',')
    as_bad (_("missing comma"));
  input_line_pointer++;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (4);
#endif

  mapping_state (MAP_DATA);

  expression (&exp);

  p = frag_more (4);
  md_number_to_chars (p, highbit, 4);
  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 1,
	       BFD_RELOC_ARM_PREL31);

  demand_empty_rest_of_line ();
}

/* Directives: AEABI stack-unwind tables.  */

/* Parse an unwind_fnstart directive.  Simply records the current location.  */

static void
s_arm_unwind_fnstart (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.proc_start)
    {
      as_bad (_("duplicate .fnstart directive"));
      return;
    }

  /* Mark the start of the function.  */
  unwind.proc_start = expr_build_dot ();

  /* Reset the rest of the unwind info.	 */
  unwind.opcode_count = 0;
  unwind.table_entry = NULL;
  unwind.personality_routine = NULL;
  unwind.personality_index = -1;
  unwind.frame_size = 0;
  unwind.fp_offset = 0;
  unwind.fp_reg = REG_SP;
  unwind.fp_used = 0;
  unwind.sp_restored = 0;
}


/* Parse a handlerdata directive.  Creates the exception handling table entry
   for the function.  */

static void
s_arm_unwind_handlerdata (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  if (unwind.table_entry)
    as_bad (_("duplicate .handlerdata directive"));

  create_unwind_entry (1);
}

/* Parse an unwind_fnend directive.  Generates the index table entry.  */

static void
s_arm_unwind_fnend (int ignored ATTRIBUTE_UNUSED)
{
  long where;
  char *ptr;
  valueT val;
  unsigned int marked_pr_dependency;

  demand_empty_rest_of_line ();

  if (!unwind.proc_start)
    {
      as_bad (_(".fnend directive without .fnstart"));
      return;
    }

  /* Add eh table entry.  */
  if (unwind.table_entry == NULL)
    val = create_unwind_entry (0);
  else
    val = 0;

  /* Add index table entry.  This is two words.	 */
  start_unwind_section (unwind.saved_seg, 1);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  ptr = frag_more (8);
  memset (ptr, 0, 8);
  where = frag_now_fix () - 8;

  /* Self relative offset of the function start.  */
  fix_new (frag_now, where, 4, unwind.proc_start, 0, 1,
	   BFD_RELOC_ARM_PREL31);

  /* Indicate dependency on EHABI-defined personality routines to the
     linker, if it hasn't been done already.  */
  marked_pr_dependency
    = seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency;
  if (unwind.personality_index >= 0 && unwind.personality_index < 3
      && !(marked_pr_dependency & (1 << unwind.personality_index)))
    {
      static const char *const name[] =
	{
	  "__aeabi_unwind_cpp_pr0",
	  "__aeabi_unwind_cpp_pr1",
	  "__aeabi_unwind_cpp_pr2"
	};
      symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
      fix_new (frag_now, where, 0, pr, 0, 1, BFD_RELOC_NONE);
      seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency
	|= 1 << unwind.personality_index;
    }

  if (val)
    /* Inline exception table entry.  */
    md_number_to_chars (ptr + 4, val, 4);
  else
    /* Self relative offset of the table entry.	 */
    fix_new (frag_now, where + 4, 4, unwind.table_entry, 0, 1,
	     BFD_RELOC_ARM_PREL31);

  /* Restore the original section.  */
  subseg_set (unwind.saved_seg, unwind.saved_subseg);

  unwind.proc_start = NULL;
}


/* Parse an unwind_cantunwind directive.  */

static void
s_arm_unwind_cantunwind (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("personality routine specified for cantunwind frame"));

  unwind.personality_index = -2;
}


/* Parse a personalityindex directive.	*/

static void
s_arm_unwind_personalityindex (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;

  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personalityindex directive"));

  expression (&exp);

  if (exp.X_op != O_constant
      || exp.X_add_number < 0 || exp.X_add_number > 15)
    {
      as_bad (_("bad personality routine number"));
      ignore_rest_of_line ();
      return;
    }

  unwind.personality_index = exp.X_add_number;

  demand_empty_rest_of_line ();
}


/* Parse a personality directive.  */

static void
s_arm_unwind_personality (int ignored ATTRIBUTE_UNUSED)
{
  char *name, *p, c;

  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personality directive"));

  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  unwind.personality_routine = symbol_find_or_make (name);
  *p = c;
  demand_empty_rest_of_line ();
}


/* Parse a directive saving core registers.  */

static void
s_arm_unwind_save_core (void)
{
  valueT op;
  long range;
  int n;

  range = parse_reg_list (&input_line_pointer);
  if (range == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  /* Turn .unwind_movsp ip followed by .unwind_save {..., ip, ...}
     into .unwind_save {..., sp...}.  We aren't bothered about the value of
     ip because it is clobbered by calls.  */
  if (unwind.sp_restored && unwind.fp_reg == 12
      && (range & 0x3000) == 0x1000)
    {
      unwind.opcode_count--;
      unwind.sp_restored = 0;
      range = (range | 0x2000) & ~0x1000;
      unwind.pending_offset = 0;
    }

  /* Pop r4-r15.  */
  if (range & 0xfff0)
    {
      /* See if we can use the short opcodes.  These pop a block of up to 8
	 registers starting with r4, plus maybe r14.  */
      for (n = 0; n < 8; n++)
	{
	  /* Break at the first non-saved register.	 */
	  if ((range & (1 << (n + 4))) == 0)
	    break;
	}
      /* See if there are any other bits set.  */
      if (n == 0 || (range & (0xfff0 << n) & 0xbff0) != 0)
	{
	  /* Use the long form.  */
	  op = 0x8000 | ((range >> 4) & 0xfff);
	  add_unwind_opcode (op, 2);
	}
      else
	{
	  /* Use the short form.  */
	  if (range & 0x4000)
	    op = 0xa8; /* Pop r14.	*/
	  else
	    op = 0xa0; /* Do not pop r14.  */
	  op |= (n - 1);
	  add_unwind_opcode (op, 1);
	}
    }

  /* Pop r0-r3.	 */
  if (range & 0xf)
    {
      op = 0xb100 | (range & 0xf);
      add_unwind_opcode (op, 2);
    }

  /* Record the number of bytes pushed.	 */
  for (n = 0; n < 16; n++)
    {
      if (range & (1 << n))
	unwind.frame_size += 4;
    }
}


/* Parse a directive saving FPA registers.  */

static void
s_arm_unwind_save_fpa (int reg)
{
  expressionS exp;
  int num_regs;
  valueT op;

  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    expression (&exp);
  else
    exp.X_op = O_illegal;

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected , <constant>"));
      ignore_rest_of_line ();
      return;
    }

  num_regs = exp.X_add_number;

  if (num_regs < 1 || num_regs > 4)
    {
      as_bad (_("number of registers must be in the range [1:4]"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  if (reg == 4)
    {
      /* Short form.  */
      op = 0xb4 | (num_regs - 1);
      add_unwind_opcode (op, 1);
    }
  else
    {
      /* Long form.  */
      op = 0xc800 | (reg << 4) | (num_regs - 1);
      add_unwind_opcode (op, 2);
    }
  unwind.frame_size += num_regs * 12;
}


/* Parse a directive saving VFP registers for ARMv6 and above.  */

static void
s_arm_unwind_save_vfp_armv6 (void)
{
  int count;
  unsigned int start;
  valueT op;
  int num_vfpv3_regs = 0;
  int num_regs_below_16;

  count = parse_vfp_reg_list (&input_line_pointer, &start, REGLIST_VFP_D);
  if (count == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  /* We always generate FSTMD/FLDMD-style unwinding opcodes (rather
     than FSTMX/FLDMX-style ones).  */

  /* Generate opcode for (VFPv3) registers numbered in the range 16 .. 31.  */
  if (start >= 16)
    num_vfpv3_regs = count;
  else if (start + count > 16)
    num_vfpv3_regs = start + count - 16;

  if (num_vfpv3_regs > 0)
    {
      int start_offset = start > 16 ? start - 16 : 0;
      op = 0xc800 | (start_offset << 4) | (num_vfpv3_regs - 1);
      add_unwind_opcode (op, 2);
    }

  /* Generate opcode for registers numbered in the range 0 .. 15.  */
  num_regs_below_16 = num_vfpv3_regs > 0 ? 16 - (int) start : count;
  gas_assert (num_regs_below_16 + num_vfpv3_regs == count);
  if (num_regs_below_16 > 0)
    {
      op = 0xc900 | (start << 4) | (num_regs_below_16 - 1);
      add_unwind_opcode (op, 2);
    }

  unwind.frame_size += count * 8;
}


/* Parse a directive saving VFP registers for pre-ARMv6.  */

static void
s_arm_unwind_save_vfp (void)
{
  int count;
  unsigned int reg;
  valueT op;

  count = parse_vfp_reg_list (&input_line_pointer, &reg, REGLIST_VFP_D);
  if (count == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  if (reg == 8)
    {
      /* Short form.  */
      op = 0xb8 | (count - 1);
      add_unwind_opcode (op, 1);
    }
  else
    {
      /* Long form.  */
      op = 0xb300 | (reg << 4) | (count - 1);
      add_unwind_opcode (op, 2);
    }
  unwind.frame_size += count * 8 + 4;
}


/* Parse a directive saving iWMMXt data registers.  */

static void
s_arm_unwind_save_mmxwr (void)
{
  int reg;
  int hi_reg;
  int i;
  unsigned mask = 0;
  valueT op;

  if (*input_line_pointer == '{')
    input_line_pointer++;

  do
    {
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);

      if (reg == FAIL)
	{
	  as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWR]));
	  goto error;
	}

      if (mask >> reg)
	as_tsktsk (_("register list not in ascending order"));
      mask |= 1 << reg;

      if (*input_line_pointer == '-')
	{
	  input_line_pointer++;
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
	  if (hi_reg == FAIL)
	    {
	      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWR]));
	      goto error;
	    }
	  else if (reg >= hi_reg)
	    {
	      as_bad (_("bad register range"));
	      goto error;
	    }
	  for (; reg < hi_reg; reg++)
	    mask |= 1 << reg;
	}
    }
  while (skip_past_comma (&input_line_pointer) != FAIL);

  skip_past_char (&input_line_pointer, '}');

  demand_empty_rest_of_line ();

  /* Generate any deferred opcodes because we're going to be looking at
     the list.	*/
  flush_pending_unwind ();

  for (i = 0; i < 16; i++)
    {
      if (mask & (1 << i))
	unwind.frame_size += 8;
    }

  /* Attempt to combine with a previous opcode.	 We do this because gcc
     likes to output separate unwind directives for a single block of
     registers.	 */
  if (unwind.opcode_count > 0)
    {
      i = unwind.opcodes[unwind.opcode_count - 1];
      if ((i & 0xf8) == 0xc0)
	{
	  i &= 7;
	  /* Only merge if the blocks are contiguous.  */
	  if (i < 6)
	    {
	      if ((mask & 0xfe00) == (1 << 9))
		{
		  mask |= ((1 << (i + 11)) - 1) & 0xfc00;
		  unwind.opcode_count--;
		}
	    }
	  else if (i == 6 && unwind.opcode_count >= 2)
	    {
	      i = unwind.opcodes[unwind.opcode_count - 2];
	      reg = i >> 4;
	      i &= 0xf;

	      op = 0xffff << (reg - 1);
	      if (reg > 0
		  && ((mask & op) == (1u << (reg - 1))))
		{
		  op = (1 << (reg + i + 1)) - 1;
		  op &= ~((1 << reg) - 1);
		  mask |= op;
		  unwind.opcode_count -= 2;
		}
	    }
	}
    }

  hi_reg = 15;
  /* We want to generate opcodes in the order the registers have been
     saved, ie. descending order.  */
  for (reg = 15; reg >= -1; reg--)
    {
      /* Save registers in blocks.  */
      if (reg < 0
	  || !(mask & (1 << reg)))
	{
	  /* We found an unsaved reg.  Generate opcodes to save the
	     preceding block.	*/
	  if (reg != hi_reg)
	    {
	      if (reg == 9)
		{
		  /* Short form.  */
		  op = 0xc0 | (hi_reg - 10);
		  add_unwind_opcode (op, 1);
		}
	      else
		{
		  /* Long form.	 */
		  op = 0xc600 | ((reg + 1) << 4) | ((hi_reg - reg) - 1);
		  add_unwind_opcode (op, 2);
		}
	    }
	  hi_reg = reg - 1;
	}
    }

  return;
error:
  ignore_rest_of_line ();
}

static void
s_arm_unwind_save_mmxwcg (void)
{
  int reg;
  int hi_reg;
  unsigned mask = 0;
  valueT op;

  if (*input_line_pointer == '{')
    input_line_pointer++;

  skip_whitespace (input_line_pointer);

  do
    {
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);

      if (reg == FAIL)
	{
	  as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWCG]));
	  goto error;
	}

      reg -= 8;
      if (mask >> reg)
	as_tsktsk (_("register list not in ascending order"));
      mask |= 1 << reg;

      if (*input_line_pointer == '-')
	{
	  input_line_pointer++;
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
	  if (hi_reg == FAIL)
	    {
	      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWCG]));
	      goto error;
	    }
	  else if (reg >= hi_reg)
	    {
	      as_bad (_("bad register range"));
	      goto error;
	    }
	  for (; reg < hi_reg; reg++)
	    mask |= 1 << reg;
	}
    }
  while (skip_past_comma (&input_line_pointer) != FAIL);

  skip_past_char (&input_line_pointer, '}');

  demand_empty_rest_of_line ();

  /* Generate any deferred opcodes because we're going to be looking at
     the list.	*/
  flush_pending_unwind ();

  for (reg = 0; reg < 16; reg++)
    {
      if (mask & (1 << reg))
	unwind.frame_size += 4;
    }
  op = 0xc700 | mask;
  add_unwind_opcode (op, 2);
  return;
error:
  ignore_rest_of_line ();
}


/* Parse an unwind_save directive.
   If the argument is non-zero, this is a .vsave directive.  */

static void
s_arm_unwind_save (int arch_v6)
{
  char *peek;
  struct reg_entry *reg;
  bfd_boolean had_brace = FALSE;

  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  /* Figure out what sort of save we have.  */
  peek = input_line_pointer;

  if (*peek == '{')
    {
      had_brace = TRUE;
      peek++;
    }

  reg = arm_reg_parse_multi (&peek);

  if (!reg)
    {
      as_bad (_("register expected"));
      ignore_rest_of_line ();
      return;
    }

  switch (reg->type)
    {
    case REG_TYPE_FN:
      if (had_brace)
	{
	  as_bad (_("FPA .unwind_save does not take a register list"));
	  ignore_rest_of_line ();
	  return;
	}
      input_line_pointer = peek;
      s_arm_unwind_save_fpa (reg->number);
      return;

    case REG_TYPE_RN:	  s_arm_unwind_save_core ();   return;
    case REG_TYPE_VFD:
      if (arch_v6)
	s_arm_unwind_save_vfp_armv6 ();
      else
	s_arm_unwind_save_vfp ();
      return;
    case REG_TYPE_MMXWR:  s_arm_unwind_save_mmxwr ();  return;
    case REG_TYPE_MMXWCG: s_arm_unwind_save_mmxwcg (); return;

    default:
      as_bad (_(".unwind_save does not support this kind of register"));
      ignore_rest_of_line ();
    }
}


/* Parse an unwind_movsp directive.  */

static void
s_arm_unwind_movsp (int ignored ATTRIBUTE_UNUSED)
{
  int reg;
  valueT op;
  int offset;

  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
  if (reg == FAIL)
    {
      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_RN]));
      ignore_rest_of_line ();
      return;
    }

  /* Optional constant.	 */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    {
      if (immediate_for_directive (&offset) == FAIL)
	return;
    }
  else
    offset = 0;

  demand_empty_rest_of_line ();

  if (reg == REG_SP || reg == REG_PC)
    {
      as_bad (_("SP and PC not permitted in .unwind_movsp directive"));
      return;
    }

  if (unwind.fp_reg != REG_SP)
    as_bad (_("unexpected .unwind_movsp directive"));

  /* Generate opcode to restore the value.  */
  op = 0x90 | reg;
  add_unwind_opcode (op, 1);

  /* Record the information for later.	*/
  unwind.fp_reg = reg;
  unwind.fp_offset = unwind.frame_size - offset;
  unwind.sp_restored = 1;
}

/* Parse an unwind_pad directive.  */

static void
s_arm_unwind_pad (int ignored ATTRIBUTE_UNUSED)
{
  int offset;

  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  if (immediate_for_directive (&offset) == FAIL)
    return;

  if (offset & 3)
    {
      as_bad (_("stack increment must be multiple of 4"));
      ignore_rest_of_line ();
      return;
    }

  /* Don't generate any opcodes, just record the details for later.  */
  unwind.frame_size += offset;
  unwind.pending_offset += offset;

  demand_empty_rest_of_line ();
}

/* Parse an unwind_setfp directive.  */

static void
s_arm_unwind_setfp (int ignored ATTRIBUTE_UNUSED)
{
  int sp_reg;
  int fp_reg;
  int offset;

  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
  if (skip_past_comma (&input_line_pointer) == FAIL)
    sp_reg = FAIL;
  else
    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);

  if (fp_reg == FAIL || sp_reg == FAIL)
    {
      as_bad (_("expected <reg>, <reg>"));
      ignore_rest_of_line ();
      return;
    }

  /* Optional constant.	 */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    {
      if (immediate_for_directive (&offset) == FAIL)
	return;
    }
  else
    offset = 0;

  demand_empty_rest_of_line ();

  if (sp_reg != REG_SP && sp_reg != unwind.fp_reg)
    {
      as_bad (_("register must be either sp or set by a previous"
		"unwind_movsp directive"));
      return;
    }

  /* Don't generate any opcodes, just record the information for later.	 */
  unwind.fp_reg = fp_reg;
  unwind.fp_used = 1;
  if (sp_reg == REG_SP)
    unwind.fp_offset = unwind.frame_size - offset;
  else
    unwind.fp_offset -= offset;
}

/* Parse an unwind_raw directive.  */

static void
s_arm_unwind_raw (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
  /* This is an arbitrary limit.	 */
  unsigned char op[16];
  int count;

  if (!unwind.proc_start)
    as_bad (MISSING_FNSTART);

  expression (&exp);
  if (exp.X_op == O_constant
      && skip_past_comma (&input_line_pointer) != FAIL)
    {
      unwind.frame_size += exp.X_add_number;
      expression (&exp);
    }
  else
    exp.X_op = O_illegal;

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected <offset>, <opcode>"));
      ignore_rest_of_line ();
      return;
    }

  count = 0;

  /* Parse the opcode.	*/
  for (;;)
    {
      if (count >= 16)
	{
	  as_bad (_("unwind opcode too long"));
	  ignore_rest_of_line ();
	}
      if (exp.X_op != O_constant || exp.X_add_number & ~0xff)
	{
	  as_bad (_("invalid unwind opcode"));
	  ignore_rest_of_line ();
	  return;
	}
      op[count++] = exp.X_add_number;

      /* Parse the next byte.  */
      if (skip_past_comma (&input_line_pointer) == FAIL)
	break;

      expression (&exp);
    }

  /* Add the opcode bytes in reverse order.  */
  while (count--)
    add_unwind_opcode (op[count], 1);

  demand_empty_rest_of_line ();
}


/* Parse a .eabi_attribute directive.  */

static void
s_arm_eabi_attribute (int ignored ATTRIBUTE_UNUSED)
{
  int tag = obj_elf_vendor_attribute (OBJ_ATTR_PROC);

  if (tag < NUM_KNOWN_OBJ_ATTRIBUTES)
    attributes_set_explicitly[tag] = 1;
}

/* Emit a tls fix for the symbol.  */

static void
s_arm_tls_descseq (int ignored ATTRIBUTE_UNUSED)
{
  char *p;
  expressionS exp;
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (4);
#endif

  /* Since we're just labelling the code, there's no need to define a
     mapping symbol.  */
  expression (&exp);
  p = obstack_next_free (&frchain_now->frch_obstack);
  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 0,
	       thumb_mode ? BFD_RELOC_ARM_THM_TLS_DESCSEQ
	       : BFD_RELOC_ARM_TLS_DESCSEQ);
}
#endif /* OBJ_ELF */

static void s_arm_arch (int);
static void s_arm_object_arch (int);
static void s_arm_cpu (int);
static void s_arm_fpu (int);
static void s_arm_arch_extension (int);

#ifdef TE_PE

static void
pe_directive_secrel (int dummy ATTRIBUTE_UNUSED)
{
  expressionS exp;

  do
    {
      expression (&exp);
      if (exp.X_op == O_symbol)
	exp.X_op = O_secrel;

      emit_expr (&exp, 4);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;
  demand_empty_rest_of_line ();
}
#endif /* TE_PE */

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* Never called because '.req' does not start a line.	 */
  { "req",	   s_req,	  0 },
  /* Following two are likewise never called.  */
  { "dn",	   s_dn,          0 },
  { "qn",          s_qn,          0 },
  { "unreq",	   s_unreq,	  0 },
  { "bss",	   s_bss,	  0 },
  { "align",	   s_align,	  0 },
  { "arm",	   s_arm,	  0 },
  { "thumb",	   s_thumb,	  0 },
  { "code",	   s_code,	  0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb_set",   s_thumb_set,	  0 },
  { "even",	   s_even,	  0 },
  { "ltorg",	   s_ltorg,	  0 },
  { "pool",	   s_ltorg,	  0 },
  { "syntax",	   s_syntax,	  0 },
  { "cpu",	   s_arm_cpu,	  0 },
  { "arch",	   s_arm_arch,	  0 },
  { "object_arch", s_arm_object_arch,	0 },
  { "fpu",	   s_arm_fpu,	  0 },
  { "arch_extension", s_arm_arch_extension, 0 },
#ifdef OBJ_ELF
  { "word",	        s_arm_elf_cons, 4 },
  { "long",	        s_arm_elf_cons, 4 },
  { "inst.n",           s_arm_elf_inst, 2 },
  { "inst.w",           s_arm_elf_inst, 4 },
  { "inst",             s_arm_elf_inst, 0 },
  { "rel31",	        s_arm_rel31,	  0 },
  { "fnstart",		s_arm_unwind_fnstart,	0 },
  { "fnend",		s_arm_unwind_fnend,	0 },
  { "cantunwind",	s_arm_unwind_cantunwind, 0 },
  { "personality",	s_arm_unwind_personality, 0 },
  { "personalityindex",	s_arm_unwind_personalityindex, 0 },
  { "handlerdata",	s_arm_unwind_handlerdata, 0 },
  { "save",		s_arm_unwind_save,	0 },
  { "vsave",		s_arm_unwind_save,	1 },
  { "movsp",		s_arm_unwind_movsp,	0 },
  { "pad",		s_arm_unwind_pad,	0 },
  { "setfp",		s_arm_unwind_setfp,	0 },
  { "unwind_raw",	s_arm_unwind_raw,	0 },
  { "eabi_attribute",	s_arm_eabi_attribute,	0 },
  { "tlsdescseq",	s_arm_tls_descseq,      0 },
#else
  { "word",	   cons, 4},

  /* These are used for dwarf.  */
  {"2byte", cons, 2},
  {"4byte", cons, 4},
  {"8byte", cons, 8},
  /* These are used for dwarf2.  */
  { "file", (void (*) (int)) dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },
  { "loc_mark_labels", dwarf2_directive_loc_mark_labels, 0 },
#endif
  { "extend",	   float_cons, 'x' },
  { "ldouble",	   float_cons, 'x' },
  { "packed",	   float_cons, 'p' },
#ifdef TE_PE
  {"secrel32", pe_directive_secrel, 0},
#endif
  { 0, 0, 0 }
};

/* Parser functions used exclusively in instruction operands.  */

/* Generic immediate-value read function for use in insn parsing.
   STR points to the beginning of the immediate (the leading #);
   VAL receives the value; if the value is outside [MIN, MAX]
   issue an error.  PREFIX_OPT is true if the immediate prefix is
   optional.  */

static int
parse_immediate (char **str, int *val, int min, int max,
		 bfd_boolean prefix_opt)
{
  expressionS exp;
  my_get_expression (&exp, str, prefix_opt ? GE_OPT_PREFIX : GE_IMM_PREFIX);
  if (exp.X_op != O_constant)
    {
      inst.error = _("constant expression required");
      return FAIL;
    }

  if (exp.X_add_number < min || exp.X_add_number > max)
    {
      inst.error = _("immediate value out of range");
      return FAIL;
    }

  *val = exp.X_add_number;
  return SUCCESS;
}

/* Less-generic immediate-value read function with the possibility of loading a
   big (64-bit) immediate, as required by Neon VMOV, VMVN and logic immediate
   instructions. Puts the result directly in inst.operands[i].  */

static int
parse_big_immediate (char **str, int i)
{
  expressionS exp;
  char *ptr = *str;

  my_get_expression (&exp, &ptr, GE_OPT_PREFIX_BIG);

  if (exp.X_op == O_constant)
    {
      inst.operands[i].imm = exp.X_add_number & 0xffffffff;
      /* If we're on a 64-bit host, then a 64-bit number can be returned using
	 O_constant.  We have to be careful not to break compilation for
	 32-bit X_add_number, though.  */
      if ((exp.X_add_number & ~(offsetT)(0xffffffffU)) != 0)
	{
	  /* X >> 32 is illegal if sizeof (exp.X_add_number) == 4.  */
	  inst.operands[i].reg = ((exp.X_add_number >> 16) >> 16) & 0xffffffff;
	  inst.operands[i].regisimm = 1;
	}
    }
  else if (exp.X_op == O_big
	   && LITTLENUM_NUMBER_OF_BITS * exp.X_add_number > 32)
    {
      unsigned parts = 32 / LITTLENUM_NUMBER_OF_BITS, j, idx = 0;

      /* Bignums have their least significant bits in
	 generic_bignum[0]. Make sure we put 32 bits in imm and
	 32 bits in reg,  in a (hopefully) portable way.  */
      gas_assert (parts != 0);

      /* Make sure that the number is not too big.
	 PR 11972: Bignums can now be sign-extended to the
	 size of a .octa so check that the out of range bits
	 are all zero or all one.  */
      if (LITTLENUM_NUMBER_OF_BITS * exp.X_add_number > 64)
	{
	  LITTLENUM_TYPE m = -1;

	  if (generic_bignum[parts * 2] != 0
	      && generic_bignum[parts * 2] != m)
	    return FAIL;

	  for (j = parts * 2 + 1; j < (unsigned) exp.X_add_number; j++)
	    if (generic_bignum[j] != generic_bignum[j-1])
	      return FAIL;
	}

      inst.operands[i].imm = 0;
      for (j = 0; j < parts; j++, idx++)
	inst.operands[i].imm |= generic_bignum[idx]
				<< (LITTLENUM_NUMBER_OF_BITS * j);
      inst.operands[i].reg = 0;
      for (j = 0; j < parts; j++, idx++)
	inst.operands[i].reg |= generic_bignum[idx]
				<< (LITTLENUM_NUMBER_OF_BITS * j);
      inst.operands[i].regisimm = 1;
    }
  else
    return FAIL;

  *str = ptr;

  return SUCCESS;
}

/* Returns the pseudo-register number of an FPA immediate constant,
   or FAIL if there isn't a valid constant here.  */

static int
parse_fpa_immediate (char ** str)
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *	 save_in;
  expressionS	 exp;
  int		 i;
  int		 j;

  /* First try and match exact strings, this is to guarantee
     that some formats will work even for cross assembly.  */

  for (i = 0; fp_const[i]; i++)
    {
      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
	{
	  char *start = *str;

	  *str += strlen (fp_const[i]);
	  if (is_end_of_line[(unsigned char) **str])
	    return i + 8;
	  *str = start;
	}
    }

  /* Just because we didn't get a match doesn't mean that the constant
     isn't valid, just that it is in a format that we don't
     automatically recognize.  Try parsing it with the standard
     expression routines.  */

  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));

  /* Look for a raw floating point number.  */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && is_end_of_line[(unsigned char) *save_in])
    {
      for (i = 0; i < NUM_FLOAT_VALS; i++)
	{
	  for (j = 0; j < MAX_LITTLENUMS; j++)
	    {
	      if (words[j] != fp_values[i][j])
		break;
	    }

	  if (j == MAX_LITTLENUMS)
	    {
	      *str = save_in;
	      return i + 8;
	    }
	}
    }

  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f").  */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
    {
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.	*/
      if (gen_to_words (words, 5, (long) 15) == 0)
	{
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}

	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i + 8;
		}
	    }
	}
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  inst.error = _("invalid FPA immediate expression");
  return FAIL;
}

/* Returns 1 if a number has "quarter-precision" float format
   0baBbbbbbc defgh000 00000000 00000000.  */

static int
is_quarter_float (unsigned imm)
{
  int bs = (imm & 0x20000000) ? 0x3e000000 : 0x40000000;
  return (imm & 0x7ffff) == 0 && ((imm & 0x7e000000) ^ bs) == 0;
}

/* Parse an 8-bit "quarter-precision" floating point number of the form:
   0baBbbbbbc defgh000 00000000 00000000.
   The zero and minus-zero cases need special handling, since they can't be
   encoded in the "quarter-precision" float format, but can nonetheless be
   loaded as integer constants.  */

static unsigned
parse_qfloat_immediate (char **ccp, int *immed)
{
  char *str = *ccp;
  char *fpnum;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  int found_fpchar = 0;

  skip_past_char (&str, '#');

  /* We must not accidentally parse an integer as a floating-point number. Make
     sure that the value we parse is not an integer by checking for special
     characters '.' or 'e'.
     FIXME: This is a horrible hack, but doing better is tricky because type
     information isn't in a very usable state at parse time.  */
  fpnum = str;
  skip_whitespace (fpnum);

  if (strncmp (fpnum, "0x", 2) == 0)
    return FAIL;
  else
    {
      for (; *fpnum != '\0' && *fpnum != ' ' && *fpnum != '\n'; fpnum++)
	if (*fpnum == '.' || *fpnum == 'e' || *fpnum == 'E')
	  {
	    found_fpchar = 1;
	    break;
	  }

      if (!found_fpchar)
	return FAIL;
    }

  if ((str = atof_ieee (str, 's', words)) != NULL)
    {
      unsigned fpword = 0;
      int i;

      /* Our FP word must be 32 bits (single-precision FP).  */
      for (i = 0; i < 32 / LITTLENUM_NUMBER_OF_BITS; i++)
	{
	  fpword <<= LITTLENUM_NUMBER_OF_BITS;
	  fpword |= words[i];
	}

      if (is_quarter_float (fpword) || (fpword & 0x7fffffff) == 0)
	*immed = fpword;
      else
	return FAIL;

      *ccp = str;

      return SUCCESS;
    }

  return FAIL;
}

/* Shift operands.  */
enum shift_kind
{
  SHIFT_LSL, SHIFT_LSR, SHIFT_ASR, SHIFT_ROR, SHIFT_RRX
};

struct asm_shift_name
{
  const char	  *name;
  enum shift_kind  kind;
};

/* Third argument to parse_shift.  */
enum parse_shift_mode
{
  NO_SHIFT_RESTRICT,		/* Any kind of shift is accepted.  */
  SHIFT_IMMEDIATE,		/* Shift operand must be an immediate.	*/
  SHIFT_LSL_OR_ASR_IMMEDIATE,	/* Shift must be LSL or ASR immediate.	*/
  SHIFT_ASR_IMMEDIATE,		/* Shift must be ASR immediate.	 */
  SHIFT_LSL_IMMEDIATE,		/* Shift must be LSL immediate.	 */
};

/* Parse a <shift> specifier on an ARM data processing instruction.
   This has three forms:

     (LSL|LSR|ASL|ASR|ROR) Rs
     (LSL|LSR|ASL|ASR|ROR) #imm
     RRX

   Note that ASL is assimilated to LSL in the instruction encoding, and
   RRX to ROR #0 (which cannot be written as such).  */

static int
parse_shift (char **str, int i, enum parse_shift_mode mode)
{
  const struct asm_shift_name *shift_name;
  enum shift_kind shift;
  char *s = *str;
  char *p = s;
  int reg;

  for (p = *str; ISALPHA (*p); p++)
    ;

  if (p == *str)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }

  shift_name = (const struct asm_shift_name *) hash_find_n (arm_shift_hsh, *str,
							    p - *str);

  if (shift_name == NULL)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }

  shift = shift_name->kind;

  switch (mode)
    {
    case NO_SHIFT_RESTRICT:
    case SHIFT_IMMEDIATE:   break;

    case SHIFT_LSL_OR_ASR_IMMEDIATE:
      if (shift != SHIFT_LSL && shift != SHIFT_ASR)
	{
	  inst.error = _("'LSL' or 'ASR' required");
	  return FAIL;
	}
      break;

    case SHIFT_LSL_IMMEDIATE:
      if (shift != SHIFT_LSL)
	{
	  inst.error = _("'LSL' required");
	  return FAIL;
	}
      break;

    case SHIFT_ASR_IMMEDIATE:
      if (shift != SHIFT_ASR)
	{
	  inst.error = _("'ASR' required");
	  return FAIL;
	}
      break;

    default: abort ();
    }

  if (shift != SHIFT_RRX)
    {
      /* Whitespace can appear here if the next thing is a bare digit.	*/
      skip_whitespace (p);

      if (mode == NO_SHIFT_RESTRICT
	  && (reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	{
	  inst.operands[i].imm = reg;
	  inst.operands[i].immisreg = 1;
	}
      else if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	return FAIL;
    }
  inst.operands[i].shift_kind = shift;
  inst.operands[i].shifted = 1;
  *str = p;
  return SUCCESS;
}

/* Parse a <shifter_operand> for an ARM data processing instruction:

      #<immediate>
      #<immediate>, <rotate>
      <Rm>
      <Rm>, <shift>

   where <shift> is defined by parse_shift above, and <rotate> is a
   multiple of 2 between 0 and 30.  Validation of immediate operands
   is deferred to md_apply_fix.  */

static int
parse_shifter_operand (char **str, int i)
{
  int value;
  expressionS exp;

  if ((value = arm_reg_parse (str, REG_TYPE_RN)) != FAIL)
    {
      inst.operands[i].reg = value;
      inst.operands[i].isreg = 1;

      /* parse_shift will override this if appropriate */
      inst.reloc.exp.X_op = O_constant;
      inst.reloc.exp.X_add_number = 0;

      if (skip_past_comma (str) == FAIL)
	return SUCCESS;

      /* Shift operation on register.  */
      return parse_shift (str, i, NO_SHIFT_RESTRICT);
    }

  if (my_get_expression (&inst.reloc.exp, str, GE_IMM_PREFIX))
    return FAIL;

  if (skip_past_comma (str) == SUCCESS)
    {
      /* #x, y -- ie explicit rotation by Y.  */
      if (my_get_expression (&exp, str, GE_NO_PREFIX))
	return FAIL;

      if (exp.X_op != O_constant || inst.reloc.exp.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return FAIL;
	}

      value = exp.X_add_number;
      if (value < 0 || value > 30 || value % 2 != 0)
	{
	  inst.error = _("invalid rotation");
	  return FAIL;
	}
      if (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 255)
	{
	  inst.error = _("invalid constant");
	  return FAIL;
	}

      /* Encode as specified.  */
      inst.operands[i].imm = inst.reloc.exp.X_add_number | value << 7;
      return SUCCESS;
    }

  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
  inst.reloc.pc_rel = 0;
  return SUCCESS;
}

/* Group relocation information.  Each entry in the table contains the
   textual name of the relocation as may appear in assembler source
   and must end with a colon.
   Along with this textual name are the relocation codes to be used if
   the corresponding instruction is an ALU instruction (ADD or SUB only),
   an LDR, an LDRS, or an LDC.  */

struct group_reloc_table_entry
{
  const char *name;
  int alu_code;
  int ldr_code;
  int ldrs_code;
  int ldc_code;
};

typedef enum
{
  /* Varieties of non-ALU group relocation.  */

  GROUP_LDR,
  GROUP_LDRS,
  GROUP_LDC
} group_reloc_type;

static struct group_reloc_table_entry group_reloc_table[] =
  { /* Program counter relative: */
    { "pc_g0_nc",
      BFD_RELOC_ARM_ALU_PC_G0_NC,	/* ALU */
      0,				/* LDR */
      0,				/* LDRS */
      0 },				/* LDC */
    { "pc_g0",
      BFD_RELOC_ARM_ALU_PC_G0,		/* ALU */
      BFD_RELOC_ARM_LDR_PC_G0,		/* LDR */
      BFD_RELOC_ARM_LDRS_PC_G0,		/* LDRS */
      BFD_RELOC_ARM_LDC_PC_G0 },	/* LDC */
    { "pc_g1_nc",
      BFD_RELOC_ARM_ALU_PC_G1_NC,	/* ALU */
      0,				/* LDR */
      0,				/* LDRS */
      0 },				/* LDC */
    { "pc_g1",
      BFD_RELOC_ARM_ALU_PC_G1,		/* ALU */
      BFD_RELOC_ARM_LDR_PC_G1, 		/* LDR */
      BFD_RELOC_ARM_LDRS_PC_G1,		/* LDRS */
      BFD_RELOC_ARM_LDC_PC_G1 },	/* LDC */
    { "pc_g2",
      BFD_RELOC_ARM_ALU_PC_G2,		/* ALU */
      BFD_RELOC_ARM_LDR_PC_G2,		/* LDR */
      BFD_RELOC_ARM_LDRS_PC_G2,		/* LDRS */
      BFD_RELOC_ARM_LDC_PC_G2 },	/* LDC */
    /* Section base relative */
    { "sb_g0_nc",
      BFD_RELOC_ARM_ALU_SB_G0_NC,	/* ALU */
      0,				/* LDR */
      0,				/* LDRS */
      0 },				/* LDC */
    { "sb_g0",
      BFD_RELOC_ARM_ALU_SB_G0,		/* ALU */
      BFD_RELOC_ARM_LDR_SB_G0,		/* LDR */
      BFD_RELOC_ARM_LDRS_SB_G0,		/* LDRS */
      BFD_RELOC_ARM_LDC_SB_G0 },	/* LDC */
    { "sb_g1_nc",
      BFD_RELOC_ARM_ALU_SB_G1_NC,	/* ALU */
      0,				/* LDR */
      0,				/* LDRS */
      0 },				/* LDC */
    { "sb_g1",
      BFD_RELOC_ARM_ALU_SB_G1,		/* ALU */
      BFD_RELOC_ARM_LDR_SB_G1, 		/* LDR */
      BFD_RELOC_ARM_LDRS_SB_G1,		/* LDRS */
      BFD_RELOC_ARM_LDC_SB_G1 },	/* LDC */
    { "sb_g2",
      BFD_RELOC_ARM_ALU_SB_G2,		/* ALU */
      BFD_RELOC_ARM_LDR_SB_G2,		/* LDR */
      BFD_RELOC_ARM_LDRS_SB_G2,		/* LDRS */
      BFD_RELOC_ARM_LDC_SB_G2 }	};	/* LDC */

/* Given the address of a pointer pointing to the textual name of a group
   relocation as may appear in assembler source, attempt to find its details
   in group_reloc_table.  The pointer will be updated to the character after
   the trailing colon.  On failure, FAIL will be returned; SUCCESS
   otherwise.  On success, *entry will be updated to point at the relevant
   group_reloc_table entry. */

static int
find_group_reloc_table_entry (char **str, struct group_reloc_table_entry **out)
{
  unsigned int i;
  for (i = 0; i < ARRAY_SIZE (group_reloc_table); i++)
    {
      int length = strlen (group_reloc_table[i].name);

      if (strncasecmp (group_reloc_table[i].name, *str, length) == 0
	  && (*str)[length] == ':')
	{
	  *out = &group_reloc_table[i];
	  *str += (length + 1);
	  return SUCCESS;
	}
    }

  return FAIL;
}

/* Parse a <shifter_operand> for an ARM data processing instruction
   (as for parse_shifter_operand) where group relocations are allowed:

      #<immediate>
      #<immediate>, <rotate>
      #:<group_reloc>:<expression>
      <Rm>
      <Rm>, <shift>

   where <group_reloc> is one of the strings defined in group_reloc_table.
   The hashes are optional.

   Everything else is as for parse_shifter_operand.  */

static parse_operand_result
parse_shifter_operand_group_reloc (char **str, int i)
{
  /* Determine if we have the sequence of characters #: or just :
     coming next.  If we do, then we check for a group relocation.
     If we don't, punt the whole lot to parse_shifter_operand.  */

  if (((*str)[0] == '#' && (*str)[1] == ':')
      || (*str)[0] == ':')
    {
      struct group_reloc_table_entry *entry;

      if ((*str)[0] == '#')
	(*str) += 2;
      else
	(*str)++;

      /* Try to parse a group relocation.  Anything else is an error.  */
      if (find_group_reloc_table_entry (str, &entry) == FAIL)
	{
	  inst.error = _("unknown group relocation");
	  return PARSE_OPERAND_FAIL_NO_BACKTRACK;
	}

      /* We now have the group relocation table entry corresponding to
	 the name in the assembler source.  Next, we parse the expression.  */
      if (my_get_expression (&inst.reloc.exp, str, GE_NO_PREFIX))
	return PARSE_OPERAND_FAIL_NO_BACKTRACK;

      /* Record the relocation type (always the ALU variant here).  */
      inst.reloc.type = (bfd_reloc_code_real_type) entry->alu_code;
      gas_assert (inst.reloc.type != 0);

      return PARSE_OPERAND_SUCCESS;
    }
  else
    return parse_shifter_operand (str, i) == SUCCESS
	   ? PARSE_OPERAND_SUCCESS : PARSE_OPERAND_FAIL;

  /* Never reached.  */
}

/* Parse a Neon alignment expression.  Information is written to
   inst.operands[i].  We assume the initial ':' has been skipped.

   align	.imm = align << 8, .immisalign=1, .preind=0  */
static parse_operand_result
parse_neon_alignment (char **str, int i)
{
  char *p = *str;
  expressionS exp;

  my_get_expression (&exp, &p, GE_NO_PREFIX);

  if (exp.X_op != O_constant)
    {
      inst.error = _("alignment must be constant");
      return PARSE_OPERAND_FAIL;
    }

  inst.operands[i].imm = exp.X_add_number << 8;
  inst.operands[i].immisalign = 1;
  /* Alignments are not pre-indexes.  */
  inst.operands[i].preind = 0;

  *str = p;
  return PARSE_OPERAND_SUCCESS;
}

/* Parse all forms of an ARM address expression.  Information is written
   to inst.operands[i] and/or inst.reloc.

   Preindexed addressing (.preind=1):

   [Rn, #offset]       .reg=Rn .reloc.exp=offset
   [Rn, +/-Rm]	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
   [Rn, +/-Rm, shift]  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
		       .shift_kind=shift .reloc.exp=shift_imm

   These three may have a trailing ! which causes .writeback to be set also.

   Postindexed addressing (.postind=1, .writeback=1):

   [Rn], #offset       .reg=Rn .reloc.exp=offset
   [Rn], +/-Rm	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
   [Rn], +/-Rm, shift  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
		       .shift_kind=shift .reloc.exp=shift_imm

   Unindexed addressing (.preind=0, .postind=0):

   [Rn], {option}      .reg=Rn .imm=option .immisreg=0

   Other:

   [Rn]{!}	       shorthand for [Rn,#0]{!}
   =immediate	       .isreg=0 .reloc.exp=immediate
   label	       .reg=PC .reloc.pc_rel=1 .reloc.exp=label

  It is the caller's responsibility to check for addressing modes not
  supported by the instruction, and to set inst.reloc.type.  */

static parse_operand_result
parse_address_main (char **str, int i, int group_relocations,
		    group_reloc_type group_type)
{
  char *p = *str;
  int reg;

  if (skip_past_char (&p, '[') == FAIL)
    {
      if (skip_past_char (&p, '=') == FAIL)
	{
	  /* Bare address - translate to PC-relative offset.  */
	  inst.reloc.pc_rel = 1;
	  inst.operands[i].reg = REG_PC;
	  inst.operands[i].isreg = 1;
	  inst.operands[i].preind = 1;
	}
      /* Otherwise a load-constant pseudo op, no special treatment needed here.  */

      if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
	return PARSE_OPERAND_FAIL;

      *str = p;
      return PARSE_OPERAND_SUCCESS;
    }

  /* PR gas/14887: Allow for whitespace after the opening bracket.  */
  skip_whitespace (p);

  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
    {
      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
      return PARSE_OPERAND_FAIL;
    }
  inst.operands[i].reg = reg;
  inst.operands[i].isreg = 1;

  if (skip_past_comma (&p) == SUCCESS)
    {
      inst.operands[i].preind = 1;

      if (*p == '+') p++;
      else if (*p == '-') p++, inst.operands[i].negative = 1;

      if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	{
	  inst.operands[i].imm = reg;
	  inst.operands[i].immisreg = 1;

	  if (skip_past_comma (&p) == SUCCESS)
	    if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
	      return PARSE_OPERAND_FAIL;
	}
      else if (skip_past_char (&p, ':') == SUCCESS)
	{
	  /* FIXME: '@@' should be used here, but it's filtered out by generic
	     code before we get to see it here. This may be subject to
	     change.  */
	  parse_operand_result result = parse_neon_alignment (&p, i);

	  if (result != PARSE_OPERAND_SUCCESS)
	    return result;
	}
      else
	{
	  if (inst.operands[i].negative)
	    {
	      inst.operands[i].negative = 0;
	      p--;
	    }

	  if (group_relocations
	      && ((*p == '#' && *(p + 1) == ':') || *p == ':'))
	    {
	      struct group_reloc_table_entry *entry;

	      /* Skip over the #: or : sequence.  */
	      if (*p == '#')
		p += 2;
	      else
		p++;

	      /* Try to parse a group relocation.  Anything else is an
		 error.  */
	      if (find_group_reloc_table_entry (&p, &entry) == FAIL)
		{
		  inst.error = _("unknown group relocation");
		  return PARSE_OPERAND_FAIL_NO_BACKTRACK;
		}

	      /* We now have the group relocation table entry corresponding to
		 the name in the assembler source.  Next, we parse the
		 expression.  */
	      if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
		return PARSE_OPERAND_FAIL_NO_BACKTRACK;

	      /* Record the relocation type.  */
	      switch (group_type)
		{
		  case GROUP_LDR:
		    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldr_code;
		    break;

		  case GROUP_LDRS:
		    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldrs_code;
		    break;

		  case GROUP_LDC:
		    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldc_code;
		    break;

		  default:
		    gas_assert (0);
		}

	      if (inst.reloc.type == 0)
		{
		  inst.error = _("this group relocation is not allowed on this instruction");
		  return PARSE_OPERAND_FAIL_NO_BACKTRACK;
		}
	    }
	  else
	    {
	      char *q = p;
	      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
		return PARSE_OPERAND_FAIL;
	      /* If the offset is 0, find out if it's a +0 or -0.  */
	      if (inst.reloc.exp.X_op == O_constant
		  && inst.reloc.exp.X_add_number == 0)
		{
		  skip_whitespace (q);
		  if (*q == '#')
		    {
		      q++;
		      skip_whitespace (q);
		    }
		  if (*q == '-')
		    inst.operands[i].negative = 1;
		}
	    }
	}
    }
  else if (skip_past_char (&p, ':') == SUCCESS)
    {
      /* FIXME: '@@' should be used here, but it's filtered out by generic code
	 before we get to see it here. This may be subject to change.  */
      parse_operand_result result = parse_neon_alignment (&p, i);

      if (result != PARSE_OPERAND_SUCCESS)
	return result;
    }

  if (skip_past_char (&p, ']') == FAIL)
    {
      inst.error = _("']' expected");
      return PARSE_OPERAND_FAIL;
    }

  if (skip_past_char (&p, '!') == SUCCESS)
    inst.operands[i].writeback = 1;

  else if (skip_past_comma (&p) == SUCCESS)
    {
      if (skip_past_char (&p, '{') == SUCCESS)
	{
	  /* [Rn], {expr} - unindexed, with option */
	  if (parse_immediate (&p, &inst.operands[i].imm,
			       0, 255, TRUE) == FAIL)
	    return PARSE_OPERAND_FAIL;

	  if (skip_past_char (&p, '}') == FAIL)
	    {
	      inst.error = _("'}' expected at end of 'option' field");
	      return PARSE_OPERAND_FAIL;
	    }
	  if (inst.operands[i].preind)
	    {
	      inst.error = _("cannot combine index with option");
	      return PARSE_OPERAND_FAIL;
	    }
	  *str = p;
	  return PARSE_OPERAND_SUCCESS;
	}
      else
	{
	  inst.operands[i].postind = 1;
	  inst.operands[i].writeback = 1;

	  if (inst.operands[i].preind)
	    {
	      inst.error = _("cannot combine pre- and post-indexing");
	      return PARSE_OPERAND_FAIL;
	    }

	  if (*p == '+') p++;
	  else if (*p == '-') p++, inst.operands[i].negative = 1;

	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	    {
	      /* We might be using the immediate for alignment already. If we
		 are, OR the register number into the low-order bits.  */
	      if (inst.operands[i].immisalign)
		inst.operands[i].imm |= reg;
	      else
		inst.operands[i].imm = reg;
	      inst.operands[i].immisreg = 1;

	      if (skip_past_comma (&p) == SUCCESS)
		if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
		  return PARSE_OPERAND_FAIL;
	    }
	  else
	    {
	      char *q = p;
	      if (inst.operands[i].negative)
		{
		  inst.operands[i].negative = 0;
		  p--;
		}
	      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
		return PARSE_OPERAND_FAIL;
	      /* If the offset is 0, find out if it's a +0 or -0.  */
	      if (inst.reloc.exp.X_op == O_constant
		  && inst.reloc.exp.X_add_number == 0)
		{
		  skip_whitespace (q);
		  if (*q == '#')
		    {
		      q++;
		      skip_whitespace (q);
		    }
		  if (*q == '-')
		    inst.operands[i].negative = 1;
		}
	    }
	}
    }

  /* If at this point neither .preind nor .postind is set, we have a
     bare [Rn]{!}, which is shorthand for [Rn,#0]{!}.  */
  if (inst.operands[i].preind == 0 && inst.operands[i].postind == 0)
    {
      inst.operands[i].preind = 1;
      inst.reloc.exp.X_op = O_constant;
      inst.reloc.exp.X_add_number = 0;
    }
  *str = p;
  return PARSE_OPERAND_SUCCESS;
}

static int
parse_address (char **str, int i)
{
  return parse_address_main (str, i, 0, GROUP_LDR) == PARSE_OPERAND_SUCCESS
	 ? SUCCESS : FAIL;
}

static parse_operand_result
parse_address_group_reloc (char **str, int i, group_reloc_type type)
{
  return parse_address_main (str, i, 1, type);
}

/* Parse an operand for a MOVW or MOVT instruction.  */
static int
parse_half (char **str)
{
  char * p;

  p = *str;
  skip_past_char (&p, '#');
  if (strncasecmp (p, ":lower16:", 9) == 0)
    inst.reloc.type = BFD_RELOC_ARM_MOVW;
  else if (strncasecmp (p, ":upper16:", 9) == 0)
    inst.reloc.type = BFD_RELOC_ARM_MOVT;

  if (inst.reloc.type != BFD_RELOC_UNUSED)
    {
      p += 9;
      skip_whitespace (p);
    }

  if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
    return FAIL;

  if (inst.reloc.type == BFD_RELOC_UNUSED)
    {
      if (inst.reloc.exp.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return FAIL;
	}
      if (inst.reloc.exp.X_add_number < 0
	  || inst.reloc.exp.X_add_number > 0xffff)
	{
	  inst.error = _("immediate value out of range");
	  return FAIL;
	}
    }
  *str = p;
  return SUCCESS;
}

/* Miscellaneous. */

/* Parse a PSR flag operand.  The value returned is FAIL on syntax error,
   or a bitmask suitable to be or-ed into the ARM msr instruction.  */
static int
parse_psr (char **str, bfd_boolean lhs)
{
  char *p;
  unsigned long psr_field;
  const struct asm_psr *psr;
  char *start;
  bfd_boolean is_apsr = FALSE;
  bfd_boolean m_profile = ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_m);

  /* PR gas/12698:  If the user has specified -march=all then m_profile will
     be TRUE, but we want to ignore it in this case as we are building for any
     CPU type, including non-m variants.  */
  if (selected_cpu.core == arm_arch_any.core)
    m_profile = FALSE;

  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
     feature for ease of use and backwards compatibility.  */
  p = *str;
  if (strncasecmp (p, "SPSR", 4) == 0)
    {
      if (m_profile)
	goto unsupported_psr;

      psr_field = SPSR_BIT;
    }
  else if (strncasecmp (p, "CPSR", 4) == 0)
    {
      if (m_profile)
	goto unsupported_psr;

      psr_field = 0;
    }
  else if (strncasecmp (p, "APSR", 4) == 0)
    {
      /* APSR[_<bits>] can be used as a synonym for CPSR[_<flags>] on ARMv7-A
	 and ARMv7-R architecture CPUs.  */
      is_apsr = TRUE;
      psr_field = 0;
    }
  else if (m_profile)
    {
      start = p;
      do
	p++;
      while (ISALNUM (*p) || *p == '_');

      if (strncasecmp (start, "iapsr", 5) == 0
	  || strncasecmp (start, "eapsr", 5) == 0
	  || strncasecmp (start, "xpsr", 4) == 0
	  || strncasecmp (start, "psr", 3) == 0)
	p = start + strcspn (start, "rR") + 1;

      psr = (const struct asm_psr *) hash_find_n (arm_v7m_psr_hsh, start,
						  p - start);

      if (!psr)
	return FAIL;

      /* If APSR is being written, a bitfield may be specified.  Note that
	 APSR itself is handled above.  */
      if (psr->field <= 3)
	{
	  psr_field = psr->field;
	  is_apsr = TRUE;
	  goto check_suffix;
	}

      *str = p;
      /* M-profile MSR instructions have the mask field set to "10", except
	 *PSR variants which modify APSR, which may use a different mask (and
	 have been handled already).  Do that by setting the PSR_f field
	 here.  */
      return psr->field | (lhs ? PSR_f : 0);
    }
  else
    goto unsupported_psr;

  p += 4;
check_suffix:
  if (*p == '_')
    {
      /* A suffix follows.  */
      p++;
      start = p;

      do
	p++;
      while (ISALNUM (*p) || *p == '_');

      if (is_apsr)
	{
	  /* APSR uses a notation for bits, rather than fields.  */
	  unsigned int nzcvq_bits = 0;
	  unsigned int g_bit = 0;
	  char *bit;

	  for (bit = start; bit != p; bit++)
	    {
	      switch (TOLOWER (*bit))
		{
		case 'n':
		  nzcvq_bits |= (nzcvq_bits & 0x01) ? 0x20 : 0x01;
		  break;

		case 'z':
		  nzcvq_bits |= (nzcvq_bits & 0x02) ? 0x20 : 0x02;
		  break;

		case 'c':
		  nzcvq_bits |= (nzcvq_bits & 0x04) ? 0x20 : 0x04;
		  break;

		case 'v':
		  nzcvq_bits |= (nzcvq_bits & 0x08) ? 0x20 : 0x08;
		  break;

		case 'q':
		  nzcvq_bits |= (nzcvq_bits & 0x10) ? 0x20 : 0x10;
		  break;

		case 'g':
		  g_bit |= (g_bit & 0x1) ? 0x2 : 0x1;
		  break;

		default:
		  inst.error = _("unexpected bit specified after APSR");
		  return FAIL;
		}
	    }

	  if (nzcvq_bits == 0x1f)
	    psr_field |= PSR_f;

	  if (g_bit == 0x1)
	    {
	      if (!ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp))
		{
		  inst.error = _("selected processor does not "
				 "support DSP extension");
		  return FAIL;
		}

	      psr_field |= PSR_s;
	    }

	  if ((nzcvq_bits & 0x20) != 0
	      || (nzcvq_bits != 0x1f && nzcvq_bits != 0)
	      || (g_bit & 0x2) != 0)
	    {
	      inst.error = _("bad bitmask specified after APSR");
	      return FAIL;
	    }
	}
      else
	{
	  psr = (const struct asm_psr *) hash_find_n (arm_psr_hsh, start,
						      p - start);
	  if (!psr)
	    goto error;

	  psr_field |= psr->field;
	}
    }
  else
    {
      if (ISALNUM (*p))
	goto error;    /* Garbage after "[CS]PSR".  */

      /* Unadorned APSR is equivalent to APSR_nzcvq/CPSR_f (for writes).  This
	 is deprecated, but allow it anyway.  */
      if (is_apsr && lhs)
	{
	  psr_field |= PSR_f;
	  as_tsktsk (_("writing to APSR without specifying a bitmask is "
		       "deprecated"));
	}
      else if (!m_profile)
	/* These bits are never right for M-profile devices: don't set them
	   (only code paths which read/write APSR reach here).  */
	psr_field |= (PSR_c | PSR_f);
    }
  *str = p;
  return psr_field;

 unsupported_psr:
  inst.error = _("selected processor does not support requested special "
		 "purpose register");
  return FAIL;

 error:
  inst.error = _("flag for {c}psr instruction expected");
  return FAIL;
}

/* Parse the flags argument to CPSI[ED].  Returns FAIL on error, or a
   value suitable for splatting into the AIF field of the instruction.	*/

static int
parse_cps_flags (char **str)
{
  int val = 0;
  int saw_a_flag = 0;
  char *s = *str;

  for (;;)
    switch (*s++)
      {
      case '\0': case ',':
	goto done;

      case 'a': case 'A': saw_a_flag = 1; val |= 0x4; break;
      case 'i': case 'I': saw_a_flag = 1; val |= 0x2; break;
      case 'f': case 'F': saw_a_flag = 1; val |= 0x1; break;

      default:
	inst.error = _("unrecognized CPS flag");
	return FAIL;
      }

 done:
  if (saw_a_flag == 0)
    {
      inst.error = _("missing CPS flags");
      return FAIL;
    }

  *str = s - 1;
  return val;
}

/* Parse an endian specifier ("BE" or "LE", case insensitive);
   returns 0 for big-endian, 1 for little-endian, FAIL for an error.  */

static int
parse_endian_specifier (char **str)
{
  int little_endian;
  char *s = *str;

  if (strncasecmp (s, "BE", 2))
    little_endian = 0;
  else if (strncasecmp (s, "LE", 2))
    little_endian = 1;
  else
    {
      inst.error = _("valid endian specifiers are be or le");
      return FAIL;
    }

  if (ISALNUM (s[2]) || s[2] == '_')
    {
      inst.error = _("valid endian specifiers are be or le");
      return FAIL;
    }

  *str = s + 2;
  return little_endian;
}

/* Parse a rotation specifier: ROR #0, #8, #16, #24.  *val receives a
   value suitable for poking into the rotate field of an sxt or sxta
   instruction, or FAIL on error.  */

static int
parse_ror (char **str)
{
  int rot;
  char *s = *str;

  if (strncasecmp (s, "ROR", 3) == 0)
    s += 3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return FAIL;
    }

  if (parse_immediate (&s, &rot, 0, 24, FALSE) == FAIL)
    return FAIL;

  switch (rot)
    {
    case  0: *str = s; return 0x0;
    case  8: *str = s; return 0x1;
    case 16: *str = s; return 0x2;
    case 24: *str = s; return 0x3;

    default:
      inst.error = _("rotation can only be 0, 8, 16, or 24");
      return FAIL;
    }
}

/* Parse a conditional code (from conds[] below).  The value returned is in the
   range 0 .. 14, or FAIL.  */
static int
parse_cond (char **str)
{
  char *q;
  const struct asm_cond *c;
  int n;
  /* Condition codes are always 2 characters, so matching up to
     3 characters is sufficient.  */
  char cond[3];

  q = *str;
  n = 0;
  while (ISALPHA (*q) && n < 3)
    {
      cond[n] = TOLOWER (*q);
      q++;
      n++;
    }

  c = (const struct asm_cond *) hash_find_n (arm_cond_hsh, cond, n);
  if (!c)
    {
      inst.error = _("condition required");
      return FAIL;
    }

  *str = q;
  return c->value;
}

/* If the given feature available in the selected CPU, mark it as used.
   Returns TRUE iff feature is available.  */
static bfd_boolean
mark_feature_used (const arm_feature_set *feature)
{
  /* Ensure the option is valid on the current architecture.  */
  if (!ARM_CPU_HAS_FEATURE (cpu_variant, *feature))
    return FALSE;

  /* Add the appropriate architecture feature for the barrier option used.
     */
  if (thumb_mode)
    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used, *feature);
  else
    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used, *feature);

  return TRUE;
}

/* Parse an option for a barrier instruction.  Returns the encoding for the
   option, or FAIL.  */
static int
parse_barrier (char **str)
{
  char *p, *q;
  const struct asm_barrier_opt *o;

  p = q = *str;
  while (ISALPHA (*q))
    q++;

  o = (const struct asm_barrier_opt *) hash_find_n (arm_barrier_opt_hsh, p,
						    q - p);
  if (!o)
    return FAIL;

  if (!mark_feature_used (&o->arch))
    return FAIL;

  *str = q;
  return o->value;
}

/* Parse the operands of a table branch instruction.  Similar to a memory
   operand.  */
static int
parse_tb (char **str)
{
  char * p = *str;
  int reg;

  if (skip_past_char (&p, '[') == FAIL)
    {
      inst.error = _("'[' expected");
      return FAIL;
    }

  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
    {
      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
      return FAIL;
    }
  inst.operands[0].reg = reg;

  if (skip_past_comma (&p) == FAIL)
    {
      inst.error = _("',' expected");
      return FAIL;
    }

  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
    {
      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
      return FAIL;
    }
  inst.operands[0].imm = reg;

  if (skip_past_comma (&p) == SUCCESS)
    {
      if (parse_shift (&p, 0, SHIFT_LSL_IMMEDIATE) == FAIL)
	return FAIL;
      if (inst.reloc.exp.X_add_number != 1)
	{
	  inst.error = _("invalid shift");
	  return FAIL;
	}
      inst.operands[0].shifted = 1;
    }

  if (skip_past_char (&p, ']') == FAIL)
    {
      inst.error = _("']' expected");
      return FAIL;
    }
  *str = p;
  return SUCCESS;
}

/* Parse the operands of a Neon VMOV instruction. See do_neon_mov for more
   information on the types the operands can take and how they are encoded.
   Up to four operands may be read; this function handles setting the
   ".present" field for each read operand itself.
   Updates STR and WHICH_OPERAND if parsing is successful and returns SUCCESS,
   else returns FAIL.  */

static int
parse_neon_mov (char **str, int *which_operand)
{
  int i = *which_operand, val;
  enum arm_reg_type rtype;
  char *ptr = *str;
  struct neon_type_el optype;

  if ((val = parse_scalar (&ptr, 8, &optype)) != FAIL)
    {
      /* Case 4: VMOV<c><q>.<size> <Dn[x]>, <Rd>.  */
      inst.operands[i].reg = val;
      inst.operands[i].isscalar = 1;
      inst.operands[i].vectype = optype;
      inst.operands[i++].present = 1;

      if (skip_past_comma (&ptr) == FAIL)
	goto wanted_comma;

      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
	goto wanted_arm;

      inst.operands[i].reg = val;
      inst.operands[i].isreg = 1;
      inst.operands[i].present = 1;
    }
  else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NSDQ, &rtype, &optype))
	   != FAIL)
    {
      /* Cases 0, 1, 2, 3, 5 (D only).  */
      if (skip_past_comma (&ptr) == FAIL)
	goto wanted_comma;

      inst.operands[i].reg = val;
      inst.operands[i].isreg = 1;
      inst.operands[i].isquad = (rtype == REG_TYPE_NQ);
      inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
      inst.operands[i].isvec = 1;
      inst.operands[i].vectype = optype;
      inst.operands[i++].present = 1;

      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
	{
	  /* Case 5: VMOV<c><q> <Dm>, <Rd>, <Rn>.
	     Case 13: VMOV <Sd>, <Rm>  */
	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  inst.operands[i].present = 1;

	  if (rtype == REG_TYPE_NQ)
	    {
	      first_error (_("can't use Neon quad register here"));
	      return FAIL;
	    }
	  else if (rtype != REG_TYPE_VFS)
	    {
	      i++;
	      if (skip_past_comma (&ptr) == FAIL)
		goto wanted_comma;
	      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
		goto wanted_arm;
	      inst.operands[i].reg = val;
	      inst.operands[i].isreg = 1;
	      inst.operands[i].present = 1;
	    }
	}
      else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NSDQ, &rtype,
					   &optype)) != FAIL)
	{
	  /* Case 0: VMOV<c><q> <Qd>, <Qm>
	     Case 1: VMOV<c><q> <Dd>, <Dm>
	     Case 8: VMOV.F32 <Sd>, <Sm>
	     Case 15: VMOV <Sd>, <Se>, <Rn>, <Rm>  */

	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);
	  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
	  inst.operands[i].isvec = 1;
	  inst.operands[i].vectype = optype;
	  inst.operands[i].present = 1;

	  if (skip_past_comma (&ptr) == SUCCESS)
	    {
	      /* Case 15.  */
	      i++;

	      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
		goto wanted_arm;

	      inst.operands[i].reg = val;
	      inst.operands[i].isreg = 1;
	      inst.operands[i++].present = 1;

	      if (skip_past_comma (&ptr) == FAIL)
		goto wanted_comma;

	      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
		goto wanted_arm;

	      inst.operands[i].reg = val;
	      inst.operands[i].isreg = 1;
	      inst.operands[i].present = 1;
	    }
	}
      else if (parse_qfloat_immediate (&ptr, &inst.operands[i].imm) == SUCCESS)
	  /* Case 2: VMOV<c><q>.<dt> <Qd>, #<float-imm>
	     Case 3: VMOV<c><q>.<dt> <Dd>, #<float-imm>
	     Case 10: VMOV.F32 <Sd>, #<imm>
	     Case 11: VMOV.F64 <Dd>, #<imm>  */
	inst.operands[i].immisfloat = 1;
      else if (parse_big_immediate (&ptr, i) == SUCCESS)
	  /* Case 2: VMOV<c><q>.<dt> <Qd>, #<imm>
	     Case 3: VMOV<c><q>.<dt> <Dd>, #<imm>  */
	;
      else
	{
	  first_error (_("expected <Rm> or <Dm> or <Qm> operand"));
	  return FAIL;
	}
    }
  else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
    {
      /* Cases 6, 7.  */
      inst.operands[i].reg = val;
      inst.operands[i].isreg = 1;
      inst.operands[i++].present = 1;

      if (skip_past_comma (&ptr) == FAIL)
	goto wanted_comma;

      if ((val = parse_scalar (&ptr, 8, &optype)) != FAIL)
	{
	  /* Case 6: VMOV<c><q>.<dt> <Rd>, <Dn[x]>  */
	  inst.operands[i].reg = val;
	  inst.operands[i].isscalar = 1;
	  inst.operands[i].present = 1;
	  inst.operands[i].vectype = optype;
	}
      else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
	{
	  /* Case 7: VMOV<c><q> <Rd>, <Rn>, <Dm>  */
	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  inst.operands[i++].present = 1;

	  if (skip_past_comma (&ptr) == FAIL)
	    goto wanted_comma;

	  if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFSD, &rtype, &optype))
	      == FAIL)
	    {
	      first_error (_(reg_expected_msgs[REG_TYPE_VFSD]));
	      return FAIL;
	    }

	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  inst.operands[i].isvec = 1;
	  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
	  inst.operands[i].vectype = optype;
	  inst.operands[i].present = 1;

	  if (rtype == REG_TYPE_VFS)
	    {
	      /* Case 14.  */
	      i++;
	      if (skip_past_comma (&ptr) == FAIL)
		goto wanted_comma;
	      if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL,
					      &optype)) == FAIL)
		{
		  first_error (_(reg_expected_msgs[REG_TYPE_VFS]));
		  return FAIL;
		}
	      inst.operands[i].reg = val;
	      inst.operands[i].isreg = 1;
	      inst.operands[i].isvec = 1;
	      inst.operands[i].issingle = 1;
	      inst.operands[i].vectype = optype;
	      inst.operands[i].present = 1;
	    }
	}
      else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL, &optype))
	       != FAIL)
	{
	  /* Case 13.  */
	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  inst.operands[i].isvec = 1;
	  inst.operands[i].issingle = 1;
	  inst.operands[i].vectype = optype;
	  inst.operands[i].present = 1;
	}
    }
  else
    {
      first_error (_("parse error"));
      return FAIL;
    }

  /* Successfully parsed the operands. Update args.  */
  *which_operand = i;
  *str = ptr;
  return SUCCESS;

 wanted_comma:
  first_error (_("expected comma"));
  return FAIL;

 wanted_arm:
  first_error (_(reg_expected_msgs[REG_TYPE_RN]));
  return FAIL;
}

/* Use this macro when the operand constraints are different
   for ARM and THUMB (e.g. ldrd).  */
#define MIX_ARM_THUMB_OPERANDS(arm_operand, thumb_operand) \
	((arm_operand) | ((thumb_operand) << 16))

/* Matcher codes for parse_operands.  */
enum operand_parse_code
{
  OP_stop,	/* end of line */

  OP_RR,	/* ARM register */
  OP_RRnpc,	/* ARM register, not r15 */
  OP_RRnpcsp,	/* ARM register, neither r15 nor r13 (a.k.a. 'BadReg') */
  OP_RRnpcb,	/* ARM register, not r15, in square brackets */
  OP_RRnpctw,	/* ARM register, not r15 in Thumb-state or with writeback,
		   optional trailing ! */
  OP_RRw,	/* ARM register, not r15, optional trailing ! */
  OP_RCP,	/* Coprocessor number */
  OP_RCN,	/* Coprocessor register */
  OP_RF,	/* FPA register */
  OP_RVS,	/* VFP single precision register */
  OP_RVD,	/* VFP double precision register (0..15) */
  OP_RND,       /* Neon double precision register (0..31) */
  OP_RNQ,	/* Neon quad precision register */
  OP_RVSD,	/* VFP single or double precision register */
  OP_RNDQ,      /* Neon double or quad precision register */
  OP_RNSDQ,	/* Neon single, double or quad precision register */
  OP_RNSC,      /* Neon scalar D[X] */
  OP_RVC,	/* VFP control register */
  OP_RMF,	/* Maverick F register */
  OP_RMD,	/* Maverick D register */
  OP_RMFX,	/* Maverick FX register */
  OP_RMDX,	/* Maverick DX register */
  OP_RMAX,	/* Maverick AX register */
  OP_RMDS,	/* Maverick DSPSC register */
  OP_RIWR,	/* iWMMXt wR register */
  OP_RIWC,	/* iWMMXt wC register */
  OP_RIWG,	/* iWMMXt wCG register */
  OP_RXA,	/* XScale accumulator register */

  OP_REGLST,	/* ARM register list */
  OP_VRSLST,	/* VFP single-precision register list */
  OP_VRDLST,	/* VFP double-precision register list */
  OP_VRSDLST,   /* VFP single or double-precision register list (& quad) */
  OP_NRDLST,    /* Neon double-precision register list (d0-d31, qN aliases) */
  OP_NSTRLST,   /* Neon element/structure list */

  OP_RNDQ_I0,   /* Neon D or Q reg, or immediate zero.  */
  OP_RVSD_I0,	/* VFP S or D reg, or immediate zero.  */
  OP_RR_RNSC,   /* ARM reg or Neon scalar.  */
  OP_RNSDQ_RNSC, /* Vector S, D or Q reg, or Neon scalar.  */
  OP_RNDQ_RNSC, /* Neon D or Q reg, or Neon scalar.  */
  OP_RND_RNSC,  /* Neon D reg, or Neon scalar.  */
  OP_VMOV,      /* Neon VMOV operands.  */
  OP_RNDQ_Ibig,	/* Neon D or Q reg, or big immediate for logic and VMVN.  */
  OP_RNDQ_I63b, /* Neon D or Q reg, or immediate for shift.  */
  OP_RIWR_I32z, /* iWMMXt wR register, or immediate 0 .. 32 for iWMMXt2.  */

  OP_I0,        /* immediate zero */
  OP_I7,	/* immediate value 0 .. 7 */
  OP_I15,	/*		   0 .. 15 */
  OP_I16,	/*		   1 .. 16 */
  OP_I16z,      /*                 0 .. 16 */
  OP_I31,	/*		   0 .. 31 */
  OP_I31w,	/*		   0 .. 31, optional trailing ! */
  OP_I32,	/*		   1 .. 32 */
  OP_I32z,	/*		   0 .. 32 */
  OP_I63,	/*		   0 .. 63 */
  OP_I63s,	/*		 -64 .. 63 */
  OP_I64,	/*		   1 .. 64 */
  OP_I64z,	/*		   0 .. 64 */
  OP_I255,	/*		   0 .. 255 */

  OP_I4b,	/* immediate, prefix optional, 1 .. 4 */
  OP_I7b,	/*			       0 .. 7 */
  OP_I15b,	/*			       0 .. 15 */
  OP_I31b,	/*			       0 .. 31 */

  OP_SH,	/* shifter operand */
  OP_SHG,	/* shifter operand with possible group relocation */
  OP_ADDR,	/* Memory address expression (any mode) */
  OP_ADDRGLDR,	/* Mem addr expr (any mode) with possible LDR group reloc */
  OP_ADDRGLDRS, /* Mem addr expr (any mode) with possible LDRS group reloc */
  OP_ADDRGLDC,  /* Mem addr expr (any mode) with possible LDC group reloc */
  OP_EXP,	/* arbitrary expression */
  OP_EXPi,	/* same, with optional immediate prefix */
  OP_EXPr,	/* same, with optional relocation suffix */
  OP_HALF,	/* 0 .. 65535 or low/high reloc.  */

  OP_CPSF,	/* CPS flags */
  OP_ENDI,	/* Endianness specifier */
  OP_wPSR,	/* CPSR/SPSR/APSR mask for msr (writing).  */
  OP_rPSR,	/* CPSR/SPSR/APSR mask for msr (reading).  */
  OP_COND,	/* conditional code */
  OP_TB,	/* Table branch.  */

  OP_APSR_RR,   /* ARM register or "APSR_nzcv".  */

  OP_RRnpc_I0,	/* ARM register or literal 0 */
  OP_RR_EXr,	/* ARM register or expression with opt. reloc suff. */
  OP_RR_EXi,	/* ARM register or expression with imm prefix */
  OP_RF_IF,	/* FPA register or immediate */
  OP_RIWR_RIWC, /* iWMMXt R or C reg */
  OP_RIWC_RIWG, /* iWMMXt wC or wCG reg */

  /* Optional operands.	 */
  OP_oI7b,	 /* immediate, prefix optional, 0 .. 7 */
  OP_oI31b,	 /*				0 .. 31 */
  OP_oI32b,      /*                             1 .. 32 */
  OP_oI32z,      /*                             0 .. 32 */
  OP_oIffffb,	 /*				0 .. 65535 */
  OP_oI255c,	 /*	  curly-brace enclosed, 0 .. 255 */

  OP_oRR,	 /* ARM register */
  OP_oRRnpc,	 /* ARM register, not the PC */
  OP_oRRnpcsp,	 /* ARM register, neither the PC nor the SP (a.k.a. BadReg) */
  OP_oRRw,	 /* ARM register, not r15, optional trailing ! */
  OP_oRND,       /* Optional Neon double precision register */
  OP_oRNQ,       /* Optional Neon quad precision register */
  OP_oRNDQ,      /* Optional Neon double or quad precision register */
  OP_oRNSDQ,	 /* Optional single, double or quad precision vector register */
  OP_oSHll,	 /* LSL immediate */
  OP_oSHar,	 /* ASR immediate */
  OP_oSHllar,	 /* LSL or ASR immediate */
  OP_oROR,	 /* ROR 0/8/16/24 */
  OP_oBARRIER_I15, /* Option argument for a barrier instruction.  */

  /* Some pre-defined mixed (ARM/THUMB) operands.  */
  OP_RR_npcsp		= MIX_ARM_THUMB_OPERANDS (OP_RR, OP_RRnpcsp),
  OP_RRnpc_npcsp	= MIX_ARM_THUMB_OPERANDS (OP_RRnpc, OP_RRnpcsp),
  OP_oRRnpc_npcsp	= MIX_ARM_THUMB_OPERANDS (OP_oRRnpc, OP_oRRnpcsp),

  OP_FIRST_OPTIONAL = OP_oI7b
};

/* Generic instruction operand parser.	This does no encoding and no
   semantic validation; it merely squirrels values away in the inst
   structure.  Returns SUCCESS or FAIL depending on whether the
   specified grammar matched.  */
static int
parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)
{
  unsigned const int *upat = pattern;
  char *backtrack_pos = 0;
  const char *backtrack_error = 0;
  int i, val = 0, backtrack_index = 0;
  enum arm_reg_type rtype;
  parse_operand_result result;
  unsigned int op_parse_code;

#define po_char_or_fail(chr)			\
  do						\
    {						\
      if (skip_past_char (&str, chr) == FAIL)	\
	goto bad_args;				\
    }						\
  while (0)

#define po_reg_or_fail(regtype)					\
  do								\
    {								\
      val = arm_typed_reg_parse (& str, regtype, & rtype,	\
				 & inst.operands[i].vectype);	\
      if (val == FAIL)						\
	{							\
	  first_error (_(reg_expected_msgs[regtype]));		\
	  goto failure;						\
	}							\
      inst.operands[i].reg = val;				\
      inst.operands[i].isreg = 1;				\
      inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\
      inst.operands[i].issingle = (rtype == REG_TYPE_VFS);	\
      inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\
			     || rtype == REG_TYPE_VFD		\
			     || rtype == REG_TYPE_NQ);		\
    }								\
  while (0)

#define po_reg_or_goto(regtype, label)				\
  do								\
    {								\
      val = arm_typed_reg_parse (& str, regtype, & rtype,	\
				 & inst.operands[i].vectype);	\
      if (val == FAIL)						\
	goto label;						\
								\
      inst.operands[i].reg = val;				\
      inst.operands[i].isreg = 1;				\
      inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\
      inst.operands[i].issingle = (rtype == REG_TYPE_VFS);	\
      inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\
			     || rtype == REG_TYPE_VFD		\
			     || rtype == REG_TYPE_NQ);		\
    }								\
  while (0)

#define po_imm_or_fail(min, max, popt)				\
  do								\
    {								\
      if (parse_immediate (&str, &val, min, max, popt) == FAIL)	\
	goto failure;						\
      inst.operands[i].imm = val;				\
    }								\
  while (0)

#define po_scalar_or_goto(elsz, label)					\
  do									\
    {									\
      val = parse_scalar (& str, elsz, & inst.operands[i].vectype);	\
      if (val == FAIL)							\
	goto label;							\
      inst.operands[i].reg = val;					\
      inst.operands[i].isscalar = 1;					\
    }									\
  while (0)

#define po_misc_or_fail(expr)			\
  do						\
    {						\
      if (expr)					\
	goto failure;				\
    }						\
  while (0)

#define po_misc_or_fail_no_backtrack(expr)		\
  do							\
    {							\
      result = expr;					\
      if (result == PARSE_OPERAND_FAIL_NO_BACKTRACK)	\
	backtrack_pos = 0;				\
      if (result != PARSE_OPERAND_SUCCESS)		\
	goto failure;					\
    }							\
  while (0)

#define po_barrier_or_imm(str)				   \
  do							   \
    {						 	   \
      val = parse_barrier (&str);			   \
      if (val == FAIL && ! ISALPHA (*str))		   \
	goto immediate;					   \
      if (val == FAIL					   \
	  /* ISB can only take SY as an option.  */	   \
	  || ((inst.instruction & 0xf0) == 0x60		   \
	       && val != 0xf))				   \
	{						   \
	   inst.error = _("invalid barrier type");	   \
	   backtrack_pos = 0;				   \
	   goto failure;				   \
	}						   \
    }							   \
  while (0)

  skip_whitespace (str);

  for (i = 0; upat[i] != OP_stop; i++)
    {
      op_parse_code = upat[i];
      if (op_parse_code >= 1<<16)
	op_parse_code = thumb ? (op_parse_code >> 16)
				: (op_parse_code & ((1<<16)-1));

      if (op_parse_code >= OP_FIRST_OPTIONAL)
	{
	  /* Remember where we are in case we need to backtrack.  */
	  gas_assert (!backtrack_pos);
	  backtrack_pos = str;
	  backtrack_error = inst.error;
	  backtrack_index = i;
	}

      if (i > 0 && (i > 1 || inst.operands[0].present))
	po_char_or_fail (',');

      switch (op_parse_code)
	{
	  /* Registers */
	case OP_oRRnpc:
	case OP_oRRnpcsp:
	case OP_RRnpc:
	case OP_RRnpcsp:
	case OP_oRR:
	case OP_RR:    po_reg_or_fail (REG_TYPE_RN);	  break;
	case OP_RCP:   po_reg_or_fail (REG_TYPE_CP);	  break;
	case OP_RCN:   po_reg_or_fail (REG_TYPE_CN);	  break;
	case OP_RF:    po_reg_or_fail (REG_TYPE_FN);	  break;
	case OP_RVS:   po_reg_or_fail (REG_TYPE_VFS);	  break;
	case OP_RVD:   po_reg_or_fail (REG_TYPE_VFD);	  break;
	case OP_oRND:
	case OP_RND:   po_reg_or_fail (REG_TYPE_VFD);	  break;
	case OP_RVC:
	  po_reg_or_goto (REG_TYPE_VFC, coproc_reg);
	  break;
	  /* Also accept generic coprocessor regs for unknown registers.  */
	  coproc_reg:
	  po_reg_or_fail (REG_TYPE_CN);
	  break;
	case OP_RMF:   po_reg_or_fail (REG_TYPE_MVF);	  break;
	case OP_RMD:   po_reg_or_fail (REG_TYPE_MVD);	  break;
	case OP_RMFX:  po_reg_or_fail (REG_TYPE_MVFX);	  break;
	case OP_RMDX:  po_reg_or_fail (REG_TYPE_MVDX);	  break;
	case OP_RMAX:  po_reg_or_fail (REG_TYPE_MVAX);	  break;
	case OP_RMDS:  po_reg_or_fail (REG_TYPE_DSPSC);	  break;
	case OP_RIWR:  po_reg_or_fail (REG_TYPE_MMXWR);	  break;
	case OP_RIWC:  po_reg_or_fail (REG_TYPE_MMXWC);	  break;
	case OP_RIWG:  po_reg_or_fail (REG_TYPE_MMXWCG);  break;
	case OP_RXA:   po_reg_or_fail (REG_TYPE_XSCALE);  break;
	case OP_oRNQ:
	case OP_RNQ:   po_reg_or_fail (REG_TYPE_NQ);      break;
	case OP_oRNDQ:
	case OP_RNDQ:  po_reg_or_fail (REG_TYPE_NDQ);     break;
	case OP_RVSD:  po_reg_or_fail (REG_TYPE_VFSD);    break;
	case OP_oRNSDQ:
	case OP_RNSDQ: po_reg_or_fail (REG_TYPE_NSDQ);    break;

	/* Neon scalar. Using an element size of 8 means that some invalid
	   scalars are accepted here, so deal with those in later code.  */
	case OP_RNSC:  po_scalar_or_goto (8, failure);    break;

	case OP_RNDQ_I0:
	  {
	    po_reg_or_goto (REG_TYPE_NDQ, try_imm0);
	    break;
	    try_imm0:
	    po_imm_or_fail (0, 0, TRUE);
	  }
	  break;

	case OP_RVSD_I0:
	  po_reg_or_goto (REG_TYPE_VFSD, try_imm0);
	  break;

	case OP_RR_RNSC:
	  {
	    po_scalar_or_goto (8, try_rr);
	    break;
	    try_rr:
	    po_reg_or_fail (REG_TYPE_RN);
	  }
	  break;

	case OP_RNSDQ_RNSC:
	  {
	    po_scalar_or_goto (8, try_nsdq);
	    break;
	    try_nsdq:
	    po_reg_or_fail (REG_TYPE_NSDQ);
	  }
	  break;

	case OP_RNDQ_RNSC:
	  {
	    po_scalar_or_goto (8, try_ndq);
	    break;
	    try_ndq:
	    po_reg_or_fail (REG_TYPE_NDQ);
	  }
	  break;

	case OP_RND_RNSC:
	  {
	    po_scalar_or_goto (8, try_vfd);
	    break;
	    try_vfd:
	    po_reg_or_fail (REG_TYPE_VFD);
	  }
	  break;

	case OP_VMOV:
	  /* WARNING: parse_neon_mov can move the operand counter, i. If we're
	     not careful then bad things might happen.  */
	  po_misc_or_fail (parse_neon_mov (&str, &i) == FAIL);
	  break;

	case OP_RNDQ_Ibig:
	  {
	    po_reg_or_goto (REG_TYPE_NDQ, try_immbig);
	    break;
	    try_immbig:
	    /* There's a possibility of getting a 64-bit immediate here, so
	       we need special handling.  */
	    if (parse_big_immediate (&str, i) == FAIL)
	      {
		inst.error = _("immediate value is out of range");
		goto failure;
	      }
	  }
	  break;

	case OP_RNDQ_I63b:
	  {
	    po_reg_or_goto (REG_TYPE_NDQ, try_shimm);
	    break;
	    try_shimm:
	    po_imm_or_fail (0, 63, TRUE);
	  }
	  break;

	case OP_RRnpcb:
	  po_char_or_fail ('[');
	  po_reg_or_fail  (REG_TYPE_RN);
	  po_char_or_fail (']');
	  break;

	case OP_RRnpctw:
	case OP_RRw:
	case OP_oRRw:
	  po_reg_or_fail (REG_TYPE_RN);
	  if (skip_past_char (&str, '!') == SUCCESS)
	    inst.operands[i].writeback = 1;
	  break;

	  /* Immediates */
	case OP_I7:	 po_imm_or_fail (  0,	   7, FALSE);	break;
	case OP_I15:	 po_imm_or_fail (  0,	  15, FALSE);	break;
	case OP_I16:	 po_imm_or_fail (  1,	  16, FALSE);	break;
	case OP_I16z:	 po_imm_or_fail (  0,     16, FALSE);   break;
	case OP_I31:	 po_imm_or_fail (  0,	  31, FALSE);	break;
	case OP_I32:	 po_imm_or_fail (  1,	  32, FALSE);	break;
	case OP_I32z:	 po_imm_or_fail (  0,     32, FALSE);   break;
	case OP_I63s:	 po_imm_or_fail (-64,	  63, FALSE);	break;
	case OP_I63:	 po_imm_or_fail (  0,     63, FALSE);   break;
	case OP_I64:	 po_imm_or_fail (  1,     64, FALSE);   break;
	case OP_I64z:	 po_imm_or_fail (  0,     64, FALSE);   break;
	case OP_I255:	 po_imm_or_fail (  0,	 255, FALSE);	break;

	case OP_I4b:	 po_imm_or_fail (  1,	   4, TRUE);	break;
	case OP_oI7b:
	case OP_I7b:	 po_imm_or_fail (  0,	   7, TRUE);	break;
	case OP_I15b:	 po_imm_or_fail (  0,	  15, TRUE);	break;
	case OP_oI31b:
	case OP_I31b:	 po_imm_or_fail (  0,	  31, TRUE);	break;
	case OP_oI32b:   po_imm_or_fail (  1,     32, TRUE);    break;
	case OP_oI32z:   po_imm_or_fail (  0,     32, TRUE);    break;
	case OP_oIffffb: po_imm_or_fail (  0, 0xffff, TRUE);	break;

	  /* Immediate variants */
	case OP_oI255c:
	  po_char_or_fail ('{');
	  po_imm_or_fail (0, 255, TRUE);
	  po_char_or_fail ('}');
	  break;

	case OP_I31w:
	  /* The expression parser chokes on a trailing !, so we have
	     to find it first and zap it.  */
	  {
	    char *s = str;
	    while (*s && *s != ',')
	      s++;
	    if (s[-1] == '!')
	      {
		s[-1] = '\0';
		inst.operands[i].writeback = 1;
	      }
	    po_imm_or_fail (0, 31, TRUE);
	    if (str == s - 1)
	      str = s;
	  }
	  break;

	  /* Expressions */
	case OP_EXPi:	EXPi:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_OPT_PREFIX));
	  break;

	case OP_EXP:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_NO_PREFIX));
	  break;

	case OP_EXPr:	EXPr:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_NO_PREFIX));
	  if (inst.reloc.exp.X_op == O_symbol)
	    {
	      val = parse_reloc (&str);
	      if (val == -1)
		{
		  inst.error = _("unrecognized relocation suffix");
		  goto failure;
		}
	      else if (val != BFD_RELOC_UNUSED)
		{
		  inst.operands[i].imm = val;
		  inst.operands[i].hasreloc = 1;
		}
	    }
	  break;

	  /* Operand for MOVW or MOVT.  */
	case OP_HALF:
	  po_misc_or_fail (parse_half (&str));
	  break;

	  /* Register or expression.  */
	case OP_RR_EXr:	  po_reg_or_goto (REG_TYPE_RN, EXPr); break;
	case OP_RR_EXi:	  po_reg_or_goto (REG_TYPE_RN, EXPi); break;

	  /* Register or immediate.  */
	case OP_RRnpc_I0: po_reg_or_goto (REG_TYPE_RN, I0);   break;
	I0:		  po_imm_or_fail (0, 0, FALSE);	      break;

	case OP_RF_IF:    po_reg_or_goto (REG_TYPE_FN, IF);   break;
	IF:
	  if (!is_immediate_prefix (*str))
	    goto bad_args;
	  str++;
	  val = parse_fpa_immediate (&str);
	  if (val == FAIL)
	    goto failure;
	  /* FPA immediates are encoded as registers 8-15.
	     parse_fpa_immediate has already applied the offset.  */
	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  break;

	case OP_RIWR_I32z: po_reg_or_goto (REG_TYPE_MMXWR, I32z); break;
	I32z:		  po_imm_or_fail (0, 32, FALSE);	  break;

	  /* Two kinds of register.  */
	case OP_RIWR_RIWC:
	  {
	    struct reg_entry *rege = arm_reg_parse_multi (&str);
	    if (!rege
		|| (rege->type != REG_TYPE_MMXWR
		    && rege->type != REG_TYPE_MMXWC
		    && rege->type != REG_TYPE_MMXWCG))
	      {
		inst.error = _("iWMMXt data or control register expected");
		goto failure;
	      }
	    inst.operands[i].reg = rege->number;
	    inst.operands[i].isreg = (rege->type == REG_TYPE_MMXWR);
	  }
	  break;

	case OP_RIWC_RIWG:
	  {
	    struct reg_entry *rege = arm_reg_parse_multi (&str);
	    if (!rege
		|| (rege->type != REG_TYPE_MMXWC
		    && rege->type != REG_TYPE_MMXWCG))
	      {
		inst.error = _("iWMMXt control register expected");
		goto failure;
	      }
	    inst.operands[i].reg = rege->number;
	    inst.operands[i].isreg = 1;
	  }
	  break;

	  /* Misc */
	case OP_CPSF:	 val = parse_cps_flags (&str);		break;
	case OP_ENDI:	 val = parse_endian_specifier (&str);	break;
	case OP_oROR:	 val = parse_ror (&str);		break;
	case OP_COND:	 val = parse_cond (&str);		break;
	case OP_oBARRIER_I15:
	  po_barrier_or_imm (str); break;
	  immediate:
	  if (parse_immediate (&str, &val, 0, 15, TRUE) == FAIL)
	    goto failure;
	  break;

	case OP_wPSR:
	case OP_rPSR:
	  po_reg_or_goto (REG_TYPE_RNB, try_psr);
	  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_virt))
	    {
	      inst.error = _("Banked registers are not available with this "
			     "architecture.");
	      goto failure;
	    }
	  break;
	  try_psr:
	  val = parse_psr (&str, op_parse_code == OP_wPSR);
	  break;

	case OP_APSR_RR:
	  po_reg_or_goto (REG_TYPE_RN, try_apsr);
	  break;
	  try_apsr:
	  /* Parse "APSR_nvzc" operand (for FMSTAT-equivalent MRS
	     instruction).  */
	  if (strncasecmp (str, "APSR_", 5) == 0)
	    {
	      unsigned found = 0;
	      str += 5;
	      while (found < 15)
		switch (*str++)
		  {
		  case 'c': found = (found & 1) ? 16 : found | 1; break;
		  case 'n': found = (found & 2) ? 16 : found | 2; break;
		  case 'z': found = (found & 4) ? 16 : found | 4; break;
		  case 'v': found = (found & 8) ? 16 : found | 8; break;
		  default: found = 16;
		  }
	      if (found != 15)
		goto failure;
	      inst.operands[i].isvec = 1;
	      /* APSR_nzcv is encoded in instructions as if it were the REG_PC.  */
	      inst.operands[i].reg = REG_PC;
	    }
	  else
	    goto failure;
	  break;

	case OP_TB:
	  po_misc_or_fail (parse_tb (&str));
	  break;

	  /* Register lists.  */
	case OP_REGLST:
	  val = parse_reg_list (&str);
	  if (*str == '^')
	    {
	      inst.operands[1].writeback = 1;
	      str++;
	    }
	  break;

	case OP_VRSLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_S);
	  break;

	case OP_VRDLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_D);
	  break;

	case OP_VRSDLST:
	  /* Allow Q registers too.  */
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
				    REGLIST_NEON_D);
	  if (val == FAIL)
	    {
	      inst.error = NULL;
	      val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
					REGLIST_VFP_S);
	      inst.operands[i].issingle = 1;
	    }
	  break;

	case OP_NRDLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
				    REGLIST_NEON_D);
	  break;

	case OP_NSTRLST:
	  val = parse_neon_el_struct_list (&str, &inst.operands[i].reg,
					   &inst.operands[i].vectype);
	  break;

	  /* Addressing modes */
	case OP_ADDR:
	  po_misc_or_fail (parse_address (&str, i));
	  break;

	case OP_ADDRGLDR:
	  po_misc_or_fail_no_backtrack (
	    parse_address_group_reloc (&str, i, GROUP_LDR));
	  break;

	case OP_ADDRGLDRS:
	  po_misc_or_fail_no_backtrack (
	    parse_address_group_reloc (&str, i, GROUP_LDRS));
	  break;

	case OP_ADDRGLDC:
	  po_misc_or_fail_no_backtrack (
	    parse_address_group_reloc (&str, i, GROUP_LDC));
	  break;

	case OP_SH:
	  po_misc_or_fail (parse_shifter_operand (&str, i));
	  break;

	case OP_SHG:
	  po_misc_or_fail_no_backtrack (
	    parse_shifter_operand_group_reloc (&str, i));
	  break;

	case OP_oSHll:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_IMMEDIATE));
	  break;

	case OP_oSHar:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_ASR_IMMEDIATE));
	  break;

	case OP_oSHllar:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_OR_ASR_IMMEDIATE));
	  break;

	default:
	  as_fatal (_("unhandled operand code %d"), op_parse_code);
	}

      /* Various value-based sanity checks and shared operations.  We
	 do not signal immediate failures for the register constraints;
	 this allows a syntax error to take precedence.	 */
      switch (op_parse_code)
	{
	case OP_oRRnpc:
	case OP_RRnpc:
	case OP_RRnpcb:
	case OP_RRw:
	case OP_oRRw:
	case OP_RRnpc_I0:
	  if (inst.operands[i].isreg && inst.operands[i].reg == REG_PC)
	    inst.error = BAD_PC;
	  break;

	case OP_oRRnpcsp:
	case OP_RRnpcsp:
	  if (inst.operands[i].isreg)
	    {
	      if (inst.operands[i].reg == REG_PC)
		inst.error = BAD_PC;
	      else if (inst.operands[i].reg == REG_SP)
		inst.error = BAD_SP;
	    }
	  break;

	case OP_RRnpctw:
	  if (inst.operands[i].isreg
	      && inst.operands[i].reg == REG_PC
	      && (inst.operands[i].writeback || thumb))
	    inst.error = BAD_PC;
	  break;

	case OP_CPSF:
	case OP_ENDI:
	case OP_oROR:
	case OP_wPSR:
	case OP_rPSR:
	case OP_COND:
	case OP_oBARRIER_I15:
	case OP_REGLST:
	case OP_VRSLST:
	case OP_VRDLST:
	case OP_VRSDLST:
	case OP_NRDLST:
	case OP_NSTRLST:
	  if (val == FAIL)
	    goto failure;
	  inst.operands[i].imm = val;
	  break;

	default:
	  break;
	}

      /* If we get here, this operand was successfully parsed.	*/
      inst.operands[i].present = 1;
      continue;

    bad_args:
      inst.error = BAD_ARGS;

    failure:
      if (!backtrack_pos)
	{
	  /* The parse routine should already have set inst.error, but set a
	     default here just in case.  */
	  if (!inst.error)
	    inst.error = _("syntax error");
	  return FAIL;
	}

      /* Do not backtrack over a trailing optional argument that
	 absorbed some text.  We will only fail again, with the
	 'garbage following instruction' error message, which is
	 probably less helpful than the current one.  */
      if (backtrack_index == i && backtrack_pos != str
	  && upat[i+1] == OP_stop)
	{
	  if (!inst.error)
	    inst.error = _("syntax error");
	  return FAIL;
	}

      /* Try again, skipping the optional argument at backtrack_pos.  */
      str = backtrack_pos;
      inst.error = backtrack_error;
      inst.operands[backtrack_index].present = 0;
      i = backtrack_index;
      backtrack_pos = 0;
    }

  /* Check that we have parsed all the arguments.  */
  if (*str != '\0' && !inst.error)
    inst.error = _("garbage following instruction");

  return inst.error ? FAIL : SUCCESS;
}

#undef po_char_or_fail
#undef po_reg_or_fail
#undef po_reg_or_goto
#undef po_imm_or_fail
#undef po_scalar_or_fail
#undef po_barrier_or_imm

/* Shorthand macro for instruction encoding functions issuing errors.  */
#define constraint(expr, err)			\
  do						\
    {						\
      if (expr)					\
	{					\
	  inst.error = err;			\
	  return;				\
	}					\
    }						\
  while (0)

/* Reject "bad registers" for Thumb-2 instructions.  Many Thumb-2
   instructions are unpredictable if these registers are used.  This
   is the BadReg predicate in ARM's Thumb-2 documentation.  */
#define reject_bad_reg(reg)				\
  do							\
   if (reg == REG_SP || reg == REG_PC)			\
     {							\
       inst.error = (reg == REG_SP) ? BAD_SP : BAD_PC;	\
       return;						\
     }							\
  while (0)

/* If REG is R13 (the stack pointer), warn that its use is
   deprecated.  */
#define warn_deprecated_sp(reg)			\
  do						\
    if (warn_on_deprecated && reg == REG_SP)	\
       as_warn (_("use of r13 is deprecated"));	\
  while (0)

/* Functions for operand encoding.  ARM, then Thumb.  */

#define rotate_left(v, n) (v << n | v >> (32 - n))

/* If VAL can be encoded in the immediate field of an ARM instruction,
   return the encoded form.  Otherwise, return FAIL.  */

static unsigned int
encode_arm_immediate (unsigned int val)
{
  unsigned int a, i;

  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */

  return FAIL;
}

/* If VAL can be encoded in the immediate field of a Thumb32 instruction,
   return the encoded form.  Otherwise, return FAIL.  */
static unsigned int
encode_thumb32_immediate (unsigned int val)
{
  unsigned int a, i;

  if (val <= 0xff)
    return val;

  for (i = 1; i <= 24; i++)
    {
      a = val >> i;
      if ((val & ~(0xff << i)) == 0)
	return ((val >> i) & 0x7f) | ((32 - i) << 7);
    }

  a = val & 0xff;
  if (val == ((a << 16) | a))
    return 0x100 | a;
  if (val == ((a << 24) | (a << 16) | (a << 8) | a))
    return 0x300 | a;

  a = val & 0xff00;
  if (val == ((a << 16) | a))
    return 0x200 | (a >> 8);

  return FAIL;
}
/* Encode a VFP SP or DP register number into inst.instruction.  */

static void
encode_arm_vfp_reg (int reg, enum vfp_reg_pos pos)
{
  if ((pos == VFP_REG_Dd || pos == VFP_REG_Dn || pos == VFP_REG_Dm)
      && reg > 15)
    {
      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_d32))
	{
	  if (thumb_mode)
	    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
				    fpu_vfp_ext_d32);
	  else
	    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
				    fpu_vfp_ext_d32);
	}
      else
	{
	  first_error (_("D register out of range for selected VFP version"));
	  return;
	}
    }

  switch (pos)
    {
    case VFP_REG_Sd:
      inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
      break;

    case VFP_REG_Sn:
      inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
      break;

    case VFP_REG_Sm:
      inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
      break;

    case VFP_REG_Dd:
      inst.instruction |= ((reg & 15) << 12) | ((reg >> 4) << 22);
      break;

    case VFP_REG_Dn:
      inst.instruction |= ((reg & 15) << 16) | ((reg >> 4) << 7);
      break;

    case VFP_REG_Dm:
      inst.instruction |= (reg & 15) | ((reg >> 4) << 5);
      break;

    default:
      abort ();
    }
}

/* Encode a <shift> in an ARM-format instruction.  The immediate,
   if any, is handled by md_apply_fix.	 */
static void
encode_arm_shift (int i)
{
  if (inst.operands[i].shift_kind == SHIFT_RRX)
    inst.instruction |= SHIFT_ROR << 5;
  else
    {
      inst.instruction |= inst.operands[i].shift_kind << 5;
      if (inst.operands[i].immisreg)
	{
	  inst.instruction |= SHIFT_BY_REG;
	  inst.instruction |= inst.operands[i].imm << 8;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
    }
}

static void
encode_arm_shifter_operand (int i)
{
  if (inst.operands[i].isreg)
    {
      inst.instruction |= inst.operands[i].reg;
      encode_arm_shift (i);
    }
  else
    {
      inst.instruction |= INST_IMMEDIATE;
      if (inst.reloc.type != BFD_RELOC_ARM_IMMEDIATE)
	inst.instruction |= inst.operands[i].imm;
    }
}

/* Subroutine of encode_arm_addr_mode_2 and encode_arm_addr_mode_3.  */
static void
encode_arm_addr_mode_common (int i, bfd_boolean is_t)
{
  /* PR 14260:
     Generate an error if the operand is not a register.  */
  constraint (!inst.operands[i].isreg,
	      _("Instruction does not support =N addresses"));

  inst.instruction |= inst.operands[i].reg << 16;

  if (inst.operands[i].preind)
    {
      if (is_t)
	{
	  inst.error = _("instruction does not accept preindexed addressing");
	  return;
	}
      inst.instruction |= PRE_INDEX;
      if (inst.operands[i].writeback)
	inst.instruction |= WRITE_BACK;

    }
  else if (inst.operands[i].postind)
    {
      gas_assert (inst.operands[i].writeback);
      if (is_t)
	inst.instruction |= WRITE_BACK;
    }
  else /* unindexed - only for coprocessor */
    {
      inst.error = _("instruction does not accept unindexed addressing");
      return;
    }

  if (((inst.instruction & WRITE_BACK) || !(inst.instruction & PRE_INDEX))
      && (((inst.instruction & 0x000f0000) >> 16)
	  == ((inst.instruction & 0x0000f000) >> 12)))
    as_warn ((inst.instruction & LOAD_BIT)
	     ? _("destination register same as write-back base")
	     : _("source register same as write-back base"));
}

/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format mode 2 load or store instruction.	 If is_t is true,
   reject forms that cannot be used with a T instruction (i.e. not
   post-indexed).  */
static void
encode_arm_addr_mode_2 (int i, bfd_boolean is_t)
{
  const bfd_boolean is_pc = (inst.operands[i].reg == REG_PC);

  encode_arm_addr_mode_common (i, is_t);

  if (inst.operands[i].immisreg)
    {
      constraint ((inst.operands[i].imm == REG_PC
		   || (is_pc && inst.operands[i].writeback)),
		  BAD_PC_ADDRESSING);
      inst.instruction |= INST_IMMEDIATE;  /* yes, this is backwards */
      inst.instruction |= inst.operands[i].imm;
      if (!inst.operands[i].negative)
	inst.instruction |= INDEX_UP;
      if (inst.operands[i].shifted)
	{
	  if (inst.operands[i].shift_kind == SHIFT_RRX)
	    inst.instruction |= SHIFT_ROR << 5;
	  else
	    {
	      inst.instruction |= inst.operands[i].shift_kind << 5;
	      inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
	    }
	}
    }
  else /* immediate offset in inst.reloc */
    {
      if (is_pc && !inst.reloc.pc_rel)
	{
	  const bfd_boolean is_load = ((inst.instruction & LOAD_BIT) != 0);

	  /* If is_t is TRUE, it's called from do_ldstt.  ldrt/strt
	     cannot use PC in addressing.
	     PC cannot be used in writeback addressing, either.  */
	  constraint ((is_t || inst.operands[i].writeback),
		      BAD_PC_ADDRESSING);

	  /* Use of PC in str is deprecated for ARMv7.  */
	  if (warn_on_deprecated
	      && !is_load
	      && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v7))
	    as_warn (_("use of PC in this instruction is deprecated"));
	}

      if (inst.reloc.type == BFD_RELOC_UNUSED)
	{
	  /* Prefer + for zero encoded value.  */
	  if (!inst.operands[i].negative)
	    inst.instruction |= INDEX_UP;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
	}
    }
}

/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format mode 3 load or store instruction.	 Reject forms that
   cannot be used with such instructions.  If is_t is true, reject
   forms that cannot be used with a T instruction (i.e. not
   post-indexed).  */
static void
encode_arm_addr_mode_3 (int i, bfd_boolean is_t)
{
  if (inst.operands[i].immisreg && inst.operands[i].shifted)
    {
      inst.error = _("instruction does not accept scaled register index");
      return;
    }

  encode_arm_addr_mode_common (i, is_t);

  if (inst.operands[i].immisreg)
    {
      constraint ((inst.operands[i].imm == REG_PC
		   || (is_t && inst.operands[i].reg == REG_PC)),
		  BAD_PC_ADDRESSING);
      constraint (inst.operands[i].reg == REG_PC && inst.operands[i].writeback,
		  BAD_PC_WRITEBACK);
      inst.instruction |= inst.operands[i].imm;
      if (!inst.operands[i].negative)
	inst.instruction |= INDEX_UP;
    }
  else /* immediate offset in inst.reloc */
    {
      constraint ((inst.operands[i].reg == REG_PC && !inst.reloc.pc_rel
		   && inst.operands[i].writeback),
		  BAD_PC_WRITEBACK);
      inst.instruction |= HWOFFSET_IMM;
      if (inst.reloc.type == BFD_RELOC_UNUSED)
	{
	  /* Prefer + for zero encoded value.  */
	  if (!inst.operands[i].negative)
	    inst.instruction |= INDEX_UP;

	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	}
    }
}

/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format instruction.  Reject all forms which cannot be encoded
   into a coprocessor load/store instruction.  If wb_ok is false,
   reject use of writeback; if unind_ok is false, reject use of
   unindexed addressing.  If reloc_override is not 0, use it instead
   of BFD_ARM_CP_OFF_IMM, unless the initial relocation is a group one
   (in which case it is preserved).  */

static int
encode_arm_cp_address (int i, int wb_ok, int unind_ok, int reloc_override)
{
  inst.instruction |= inst.operands[i].reg << 16;

  gas_assert (!(inst.operands[i].preind && inst.operands[i].postind));

  if (!inst.operands[i].preind && !inst.operands[i].postind) /* unindexed */
    {
      gas_assert (!inst.operands[i].writeback);
      if (!unind_ok)
	{
	  inst.error = _("instruction does not support unindexed addressing");
	  return FAIL;
	}
      inst.instruction |= inst.operands[i].imm;
      inst.instruction |= INDEX_UP;
      return SUCCESS;
    }

  if (inst.operands[i].preind)
    inst.instruction |= PRE_INDEX;

  if (inst.operands[i].writeback)
    {
      if (inst.operands[i].reg == REG_PC)
	{
	  inst.error = _("pc may not be used with write-back");
	  return FAIL;
	}
      if (!wb_ok)
	{
	  inst.error = _("instruction does not support writeback");
	  return FAIL;
	}
      inst.instruction |= WRITE_BACK;
    }

  if (reloc_override)
    inst.reloc.type = (bfd_reloc_code_real_type) reloc_override;
  else if ((inst.reloc.type < BFD_RELOC_ARM_ALU_PC_G0_NC
	    || inst.reloc.type > BFD_RELOC_ARM_LDC_SB_G2)
	   && inst.reloc.type != BFD_RELOC_ARM_LDR_PC_G0)
    {
      if (thumb_mode)
	inst.reloc.type = BFD_RELOC_ARM_T32_CP_OFF_IMM;
      else
	inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
    }

  /* Prefer + for zero encoded value.  */
  if (!inst.operands[i].negative)
    inst.instruction |= INDEX_UP;

  return SUCCESS;
}

/* inst.reloc.exp describes an "=expr" load pseudo-operation.
   Determine whether it can be performed with a move instruction; if
   it can, convert inst.instruction to that move instruction and
   return TRUE; if it can't, convert inst.instruction to a literal-pool
   load and return FALSE.  If this is not a valid thing to do in the
   current context, set inst.error and return TRUE.

   inst.operands[i] describes the destination register.	 */

static bfd_boolean
move_or_literal_pool (int i, bfd_boolean thumb_p, bfd_boolean mode_3)
{
  unsigned long tbit;

  if (thumb_p)
    tbit = (inst.instruction > 0xffff) ? THUMB2_LOAD_BIT : THUMB_LOAD_BIT;
  else
    tbit = LOAD_BIT;

  if ((inst.instruction & tbit) == 0)
    {
      inst.error = _("invalid pseudo operation");
      return TRUE;
    }
  if (inst.reloc.exp.X_op != O_constant && inst.reloc.exp.X_op != O_symbol)
    {
      inst.error = _("constant expression expected");
      return TRUE;
    }
  if (inst.reloc.exp.X_op == O_constant)
    {
      if (thumb_p)
	{
	  if (!unified_syntax && (inst.reloc.exp.X_add_number & ~0xFF) == 0)
	    {
	      /* This can be done with a mov(1) instruction.  */
	      inst.instruction	= T_OPCODE_MOV_I8 | (inst.operands[i].reg << 8);
	      inst.instruction |= inst.reloc.exp.X_add_number;
	      return TRUE;
	    }
	}
      else
	{
	  int value = encode_arm_immediate (inst.reloc.exp.X_add_number);
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      return TRUE;
	    }

	  value = encode_arm_immediate (~inst.reloc.exp.X_add_number);
	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      return TRUE;
	    }
	}
    }

  if (add_to_lit_pool () == FAIL)
    {
      inst.error = _("literal pool insertion failed");
      return TRUE;
    }
  inst.operands[1].reg = REG_PC;
  inst.operands[1].isreg = 1;
  inst.operands[1].preind = 1;
  inst.reloc.pc_rel = 1;
  inst.reloc.type = (thumb_p
		     ? BFD_RELOC_ARM_THUMB_OFFSET
		     : (mode_3
			? BFD_RELOC_ARM_HWLITERAL
			: BFD_RELOC_ARM_LITERAL));
  return FALSE;
}

/* Functions for instruction encoding, sorted by sub-architecture.
   First some generics; their names are taken from the conventional
   bit positions for register arguments in ARM format instructions.  */

static void
do_noargs (void)
{
}

static void
do_rd (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
}

static void
do_rd_rm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
}

static void
do_rm_rn (void)
{
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 16;
}

static void
do_rd_rn (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
}

static void
do_rn_rd (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
}

static bfd_boolean
check_obsolete (const arm_feature_set *feature, const char *msg)
{
  if (ARM_CPU_IS_ANY (cpu_variant))
    {
      as_warn ("%s", msg);
      return TRUE;
    }
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, *feature))
    {
      as_bad ("%s", msg);
      return TRUE;
    }

  return FALSE;
}

static void
do_rd_rm_rn (void)
{
  unsigned Rn = inst.operands[2].reg;
  /* Enforce restrictions on SWP instruction.  */
  if ((inst.instruction & 0x0fbfffff) == 0x01000090)
    {
      constraint (Rn == inst.operands[0].reg || Rn == inst.operands[1].reg,
		  _("Rn must not overlap other operands"));

      /* SWP{b} is obsolete for ARMv8-A, and deprecated for ARMv6* and ARMv7.
       */
      if (!check_obsolete (&arm_ext_v8,
			   _("swp{b} use is obsoleted for ARMv8 and later"))
	  && warn_on_deprecated
	  && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6))
	as_warn (_("swp{b} use is deprecated for ARMv6 and ARMv7"));
    }

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= Rn << 16;
}

static void
do_rd_rn_rm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
}

static void
do_rm_rd_rn (void)
{
  constraint ((inst.operands[2].reg == REG_PC), BAD_PC);
  constraint (((inst.reloc.exp.X_op != O_constant
		&& inst.reloc.exp.X_op != O_illegal)
	       || inst.reloc.exp.X_add_number != 0),
	      BAD_ADDR_MODE);
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_imm0 (void)
{
  inst.instruction |= inst.operands[0].imm;
}

static void
do_rd_cpaddr (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, TRUE, 0);
}

/* ARM instructions, in alphabetical order by function name (except
   that wrapper functions appear immediately after the function they
   wrap).  */

/* This is a pseudo-op of the form "adr rd, label" to be converted
   into a relative address of the form "add rd, pc, #label-.-8".  */

static void
do_adr (void)
{
  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */

  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
  inst.reloc.pc_rel = 1;
  inst.reloc.exp.X_add_number -= 8;
}

/* This is a pseudo-op of the form "adrl rd, label" to be converted
   into a relative address of the form:
   add rd, pc, #low(label-.-8)"
   add rd, rd, #high(label-.-8)"  */

static void
do_adrl (void)
{
  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */

  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type	       = BFD_RELOC_ARM_ADRL_IMMEDIATE;
  inst.reloc.pc_rel	       = 1;
  inst.size		       = INSN_SIZE * 2;
  inst.reloc.exp.X_add_number -= 8;
}

static void
do_arit (void)
{
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  encode_arm_shifter_operand (2);
}

static void
do_barrier (void)
{
  if (inst.operands[0].present)
    inst.instruction |= inst.operands[0].imm;
  else
    inst.instruction |= 0xf;
}

static void
do_bfc (void)
{
  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 7;
  inst.instruction |= (msb - 1) << 16;
}

static void
do_bfi (void)
{
  unsigned int msb;

  /* #0 in second position is alternative syntax for bfc, which is
     the same instruction but with REG_PC in the Rm field.  */
  if (!inst.operands[1].isreg)
    inst.operands[1].reg = REG_PC;

  msb = inst.operands[2].imm + inst.operands[3].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 7;
  inst.instruction |= (msb - 1) << 16;
}

static void
do_bfx (void)
{
  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
	      _("bit-field extends past end of register"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 7;
  inst.instruction |= (inst.operands[3].imm - 1) << 16;
}

/* ARM V5 breakpoint instruction (argument parse)
     BKPT <16 bit unsigned immediate>
     Instruction is not conditional.
	The bit pattern given in insns[] has the COND_ALWAYS condition,
	and it is an error if the caller tried to override that.  */

static void
do_bkpt (void)
{
  /* Top 12 of 16 bits to bits 19:8.  */
  inst.instruction |= (inst.operands[0].imm & 0xfff0) << 4;

  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= inst.operands[0].imm & 0xf;
}

static void
encode_branch (int default_reloc)
{
  if (inst.operands[0].hasreloc)
    {
      constraint (inst.operands[0].imm != BFD_RELOC_ARM_PLT32
		  && inst.operands[0].imm != BFD_RELOC_ARM_TLS_CALL,
		  _("the only valid suffixes here are '(plt)' and '(tlscall)'"));
      inst.reloc.type = inst.operands[0].imm == BFD_RELOC_ARM_PLT32
	? BFD_RELOC_ARM_PLT32
	: thumb_mode ? BFD_RELOC_ARM_THM_TLS_CALL : BFD_RELOC_ARM_TLS_CALL;
    }
  else
    inst.reloc.type = (bfd_reloc_code_real_type) default_reloc;
  inst.reloc.pc_rel = 1;
}

static void
do_branch (void)
{
#ifdef OBJ_ELF
  if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
    encode_branch (BFD_RELOC_ARM_PCREL_JUMP);
  else
#endif
    encode_branch (BFD_RELOC_ARM_PCREL_BRANCH);
}

static void
do_bl (void)
{
#ifdef OBJ_ELF
  if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
    {
      if (inst.cond == COND_ALWAYS)
	encode_branch (BFD_RELOC_ARM_PCREL_CALL);
      else
	encode_branch (BFD_RELOC_ARM_PCREL_JUMP);
    }
  else
#endif
    encode_branch (BFD_RELOC_ARM_PCREL_BRANCH);
}

/* ARM V5 branch-link-exchange instruction (argument parse)
     BLX <target_addr>		ie BLX(1)
     BLX{<condition>} <Rm>	ie BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */

static void
do_blx (void)
{
  if (inst.operands[0].isreg)
    {
      /* Arg is a register; the opcode provided by insns[] is correct.
	 It is not illegal to do "blx pc", just useless.  */
      if (inst.operands[0].reg == REG_PC)
	as_tsktsk (_("use of r15 in blx in ARM mode is not really useful"));

      inst.instruction |= inst.operands[0].reg;
    }
  else
    {
      /* Arg is an address; this instruction cannot be executed
	 conditionally, and the opcode must be adjusted.
	 We retain the BFD_RELOC_ARM_PCREL_BLX till the very end
	 where we generate out a BFD_RELOC_ARM_PCREL_CALL instead.  */
      constraint (inst.cond != COND_ALWAYS, BAD_COND);
      inst.instruction = 0xfa000000;
      encode_branch (BFD_RELOC_ARM_PCREL_BLX);
    }
}

static void
do_bx (void)
{
  bfd_boolean want_reloc;

  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));

  inst.instruction |= inst.operands[0].reg;
  /* Output R_ARM_V4BX relocations if is an EABI object that looks like
     it is for ARMv4t or earlier.  */
  want_reloc = !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5);
  if (object_arch && !ARM_CPU_HAS_FEATURE (*object_arch, arm_ext_v5))
      want_reloc = TRUE;

#ifdef OBJ_ELF
  if (EF_ARM_EABI_VERSION (meabi_flags) < EF_ARM_EABI_VER4)
#endif
    want_reloc = FALSE;

  if (want_reloc)
    inst.reloc.type = BFD_RELOC_ARM_V4BX;
}


/* ARM v5TEJ.  Jump to Jazelle code.  */

static void
do_bxj (void)
{
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  inst.instruction |= inst.operands[0].reg;
}

/* Co-processor data operation:
      CDP{cond} <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}
      CDP2	<coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}	 */
static void
do_cdp (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 20;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
  inst.instruction |= inst.operands[5].imm << 5;
}

static void
do_cmp (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_shifter_operand (1);
}

/* Transfer between coprocessor and ARM registers.
   MRC{cond} <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>{, <opcode_2>}
   MRC2
   MCR{cond}
   MCR2

   No special properties.  */

struct deprecated_coproc_regs_s
{
  unsigned cp;
  int opc1;
  unsigned crn;
  unsigned crm;
  int opc2;
  arm_feature_set deprecated;
  arm_feature_set obsoleted;
  const char *dep_msg;
  const char *obs_msg;
};

#define DEPR_ACCESS_V8 \
  N_("This coprocessor register access is deprecated in ARMv8")

/* Table of all deprecated coprocessor registers.  */
static struct deprecated_coproc_regs_s deprecated_coproc_regs[] =
{
    {15, 0, 7, 10, 5,					/* CP15DMB.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
    {15, 0, 7, 10, 4,					/* CP15DSB.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
    {15, 0, 7,  5, 4,					/* CP15ISB.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
    {14, 6, 1,  0, 0,					/* TEEHBR.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
    {14, 6, 0,  0, 0,					/* TEECR.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
};

#undef DEPR_ACCESS_V8

static const size_t deprecated_coproc_reg_count =
  sizeof (deprecated_coproc_regs) / sizeof (deprecated_coproc_regs[0]);

static void
do_co_reg (void)
{
  unsigned Rd;
  size_t i;

  Rd = inst.operands[2].reg;
  if (thumb_mode)
    {
      if (inst.instruction == 0xee000010
	  || inst.instruction == 0xfe000010)
	/* MCR, MCR2  */
	reject_bad_reg (Rd);
      else
	/* MRC, MRC2  */
	constraint (Rd == REG_SP, BAD_SP);
    }
  else
    {
      /* MCR */
      if (inst.instruction == 0xe000010)
	constraint (Rd == REG_PC, BAD_PC);
    }

    for (i = 0; i < deprecated_coproc_reg_count; ++i)
      {
	const struct deprecated_coproc_regs_s *r =
	  deprecated_coproc_regs + i;

	if (inst.operands[0].reg == r->cp
	    && inst.operands[1].imm == r->opc1
	    && inst.operands[3].reg == r->crn
	    && inst.operands[4].reg == r->crm
	    && inst.operands[5].imm == r->opc2)
	  {
	    if (! ARM_CPU_IS_ANY (cpu_variant)
		&& warn_on_deprecated
		&& ARM_CPU_HAS_FEATURE (cpu_variant, r->deprecated))
	      as_warn ("%s", r->dep_msg);
	  }
      }

  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 21;
  inst.instruction |= Rd << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
  inst.instruction |= inst.operands[5].imm << 5;
}

/* Transfer between coprocessor register and pair of ARM registers.
   MCRR{cond} <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
   MCRR2
   MRRC{cond}
   MRRC2

   Two XScale instructions are special cases of these:

     MAR{cond} acc0, <RdLo>, <RdHi> == MCRR{cond} p0, #0, <RdLo>, <RdHi>, c0
     MRA{cond} acc0, <RdLo>, <RdHi> == MRRC{cond} p0, #0, <RdLo>, <RdHi>, c0

   Result unpredictable if Rd or Rn is R15.  */

static void
do_co_reg2c (void)
{
  unsigned Rd, Rn;

  Rd = inst.operands[2].reg;
  Rn = inst.operands[3].reg;

  if (thumb_mode)
    {
      reject_bad_reg (Rd);
      reject_bad_reg (Rn);
    }
  else
    {
      constraint (Rd == REG_PC, BAD_PC);
      constraint (Rn == REG_PC, BAD_PC);
    }

  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 4;
  inst.instruction |= Rd << 12;
  inst.instruction |= Rn << 16;
  inst.instruction |= inst.operands[4].reg;
}

static void
do_cpsi (void)
{
  inst.instruction |= inst.operands[0].imm << 6;
  if (inst.operands[1].present)
    {
      inst.instruction |= CPSI_MMOD;
      inst.instruction |= inst.operands[1].imm;
    }
}

static void
do_dbg (void)
{
  inst.instruction |= inst.operands[0].imm;
}

static void
do_div (void)
{
  unsigned Rd, Rn, Rm;

  Rd = inst.operands[0].reg;
  Rn = (inst.operands[1].present
	? inst.operands[1].reg : Rd);
  Rm = inst.operands[2].reg;

  constraint ((Rd == REG_PC), BAD_PC);
  constraint ((Rn == REG_PC), BAD_PC);
  constraint ((Rm == REG_PC), BAD_PC);

  inst.instruction |= Rd << 16;
  inst.instruction |= Rn << 0;
  inst.instruction |= Rm << 8;
}

static void
do_it (void)
{
  /* There is no IT instruction in ARM mode.  We
     process it to do the validation as if in
     thumb mode, just in case the code gets
     assembled for thumb using the unified syntax.  */

  inst.size = 0;
  if (unified_syntax)
    {
      set_it_insn_type (IT_INSN);
      now_it.mask = (inst.instruction & 0xf) | 0x10;
      now_it.cc = inst.operands[0].imm;
    }
}

/* If there is only one register in the register list,
   then return its register number.  Otherwise return -1.  */
static int
only_one_reg_in_list (int range)
{
  int i = ffs (range) - 1;
  return (i > 15 || range != (1 << i)) ? -1 : i;
}

static void
encode_ldmstm(int from_push_pop_mnem)
{
  int base_reg = inst.operands[0].reg;
  int range = inst.operands[1].imm;
  int one_reg;

  inst.instruction |= base_reg << 16;
  inst.instruction |= range;

  if (inst.operands[1].writeback)
    inst.instruction |= LDM_TYPE_2_OR_3;

  if (inst.operands[0].writeback)
    {
      inst.instruction |= WRITE_BACK;
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
	{
	  /* Not allowed in LDM type 2.	 */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
	}
      else /* STM.  */
	{
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
	}
    }

  /* If PUSH/POP has only one register, then use the A2 encoding.  */
  one_reg = only_one_reg_in_list (range);
  if (from_push_pop_mnem && one_reg >= 0)
    {
      int is_push = (inst.instruction & A_PUSH_POP_OP_MASK) == A1_OPCODE_PUSH;

      inst.instruction &= A_COND_MASK;
      inst.instruction |= is_push ? A2_OPCODE_PUSH : A2_OPCODE_POP;
      inst.instruction |= one_reg << 12;
    }
}

static void
do_ldmstm (void)
{
  encode_ldmstm (/*from_push_pop_mnem=*/FALSE);
}

/* ARMv5TE load-consecutive (argument parse)
   Mode is like LDRH.

     LDRccD R, mode
     STRccD R, mode.  */

static void
do_ldrd (void)
{
  constraint (inst.operands[0].reg % 2 != 0,
	      _("first transfer register must be even"));
  constraint (inst.operands[1].present
	      && inst.operands[1].reg != inst.operands[0].reg + 1,
	      _("can only transfer two consecutive registers"));
  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));
  constraint (!inst.operands[2].isreg, _("'[' expected"));

  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg + 1;

  /* encode_arm_addr_mode_3 will diagnose overlap between the base
     register and the first register written; we have to diagnose
     overlap between the base and the second register written here.  */

  if (inst.operands[2].reg == inst.operands[1].reg
      && (inst.operands[2].writeback || inst.operands[2].postind))
    as_warn (_("base register written back, and overlaps "
	       "second transfer register"));

  if (!(inst.instruction & V4_STR_BIT))
    {
      /* For an index-register load, the index register must not overlap the
	destination (even if not write-back).  */
      if (inst.operands[2].immisreg
	      && ((unsigned) inst.operands[2].imm == inst.operands[0].reg
	      || (unsigned) inst.operands[2].imm == inst.operands[1].reg))
	as_warn (_("index register overlaps transfer register"));
    }
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_3 (2, /*is_t=*/FALSE);
}

static void
do_ldrex (void)
{
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
	      || inst.operands[1].postind || inst.operands[1].writeback
	      || inst.operands[1].immisreg || inst.operands[1].shifted
	      || inst.operands[1].negative
	      /* This can arise if the programmer has written
		   strex rN, rM, foo
		 or if they have mistakenly used a register name as the last
		 operand,  eg:
		   strex rN, rM, rX
		 It is very difficult to distinguish between these two cases
		 because "rX" might actually be a label. ie the register
		 name has been occluded by a symbol of the same name. So we
		 just generate a general 'bad addressing mode' type error
		 message and leave it up to the programmer to discover the
		 true cause and fix their mistake.  */
	      || (inst.operands[1].reg == REG_PC),
	      BAD_ADDR_MODE);

  constraint (inst.reloc.exp.X_op != O_constant
	      || inst.reloc.exp.X_add_number != 0,
	      _("offset must be zero in ARM encoding"));

  constraint ((inst.operands[1].reg == REG_PC), BAD_PC);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.reloc.type = BFD_RELOC_UNUSED;
}

static void
do_ldrexd (void)
{
  constraint (inst.operands[0].reg % 2 != 0,
	      _("even register required"));
  constraint (inst.operands[1].present
	      && inst.operands[1].reg != inst.operands[0].reg + 1,
	      _("can only load two consecutive registers"));
  /* If op 1 were present and equal to PC, this function wouldn't
     have been called in the first place.  */
  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

/* In both ARM and thumb state 'ldr pc, #imm'  with an immediate
   which is not a multiple of four is UNPREDICTABLE.  */
static void
check_ldr_r15_aligned (void)
{
  constraint (!(inst.operands[1].immisreg)
	      && (inst.operands[0].reg == REG_PC
	      && inst.operands[1].reg == REG_PC
	      && (inst.reloc.exp.X_add_number & 0x3)),
	      _("ldr to register 15 must be 4-byte alligned"));
}

static void
do_ldst (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/FALSE, /*mode_3=*/FALSE))
      return;
  encode_arm_addr_mode_2 (1, /*is_t=*/FALSE);
  check_ldr_r15_aligned ();
}

static void
do_ldstt (void)
{
  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
     reject [Rn,...].  */
  if (inst.operands[1].preind)
    {
      constraint (inst.reloc.exp.X_op != O_constant
		  || inst.reloc.exp.X_add_number != 0,
		  _("this instruction requires a post-indexed address"));

      inst.operands[1].preind = 0;
      inst.operands[1].postind = 1;
      inst.operands[1].writeback = 1;
    }
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_2 (1, /*is_t=*/TRUE);
}

/* Halfword and signed-byte load/store operations.  */

static void
do_ldstv4 (void)
{
  constraint (inst.operands[0].reg == REG_PC, BAD_PC);
  inst.instruction |= inst.operands[0].reg << 12;
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/FALSE, /*mode_3=*/TRUE))
      return;
  encode_arm_addr_mode_3 (1, /*is_t=*/FALSE);
}

static void
do_ldsttv4 (void)
{
  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
     reject [Rn,...].  */
  if (inst.operands[1].preind)
    {
      constraint (inst.reloc.exp.X_op != O_constant
		  || inst.reloc.exp.X_add_number != 0,
		  _("this instruction requires a post-indexed address"));

      inst.operands[1].preind = 0;
      inst.operands[1].postind = 1;
      inst.operands[1].writeback = 1;
    }
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_3 (1, /*is_t=*/TRUE);
}

/* Co-processor register load/store.
   Format: <LDC|STC>{cond}[L] CP#,CRd,<address>	 */
static void
do_lstc (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 12;
  encode_arm_cp_address (2, TRUE, TRUE, 0);
}

static void
do_mlas (void)
{
  /* This restriction does not apply to mls (nor to mla in v6 or later).  */
  if (inst.operands[0].reg == inst.operands[1].reg
      && !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6)
      && !(inst.instruction & 0x00400000))
    as_tsktsk (_("Rd and Rm should be different in mla"));

  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 12;
}

static void
do_mov (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_shifter_operand (1);
}

/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.	 */
static void
do_mov16 (void)
{
  bfd_vma imm;
  bfd_boolean top;

  top = (inst.instruction & 0x00400000) != 0;
  constraint (top && inst.reloc.type == BFD_RELOC_ARM_MOVW,
	      _(":lower16: not allowed this instruction"));
  constraint (!top && inst.reloc.type == BFD_RELOC_ARM_MOVT,
	      _(":upper16: not allowed instruction"));
  inst.instruction |= inst.operands[0].reg << 12;
  if (inst.reloc.type == BFD_RELOC_UNUSED)
    {
      imm = inst.reloc.exp.X_add_number;
      /* The value is in two pieces: 0:11, 16:19.  */
      inst.instruction |= (imm & 0x00000fff);
      inst.instruction |= (imm & 0x0000f000) << 4;
    }
}

static void do_vfp_nsyn_opcode (const char *);

static int
do_vfp_nsyn_mrs (void)
{
  if (inst.operands[0].isvec)
    {
      if (inst.operands[1].reg != 1)
	first_error (_("operand 1 must be FPSCR"));
      memset (&inst.operands[0], '\0', sizeof (inst.operands[0]));
      memset (&inst.operands[1], '\0', sizeof (inst.operands[1]));
      do_vfp_nsyn_opcode ("fmstat");
    }
  else if (inst.operands[1].isvec)
    do_vfp_nsyn_opcode ("fmrx");
  else
    return FAIL;

  return SUCCESS;
}

static int
do_vfp_nsyn_msr (void)
{
  if (inst.operands[0].isvec)
    do_vfp_nsyn_opcode ("fmxr");
  else
    return FAIL;

  return SUCCESS;
}

static void
do_vmrs (void)
{
  unsigned Rt = inst.operands[0].reg;

  if (thumb_mode && Rt == REG_SP)
    {
      inst.error = BAD_SP;
      return;
    }

  /* APSR_ sets isvec. All other refs to PC are illegal.  */
  if (!inst.operands[0].isvec && Rt == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* If we get through parsing the register name, we just insert the number
     generated into the instruction without further validation.  */
  inst.instruction |= (inst.operands[1].reg << 16);
  inst.instruction |= (Rt << 12);
}

static void
do_vmsr (void)
{
  unsigned Rt = inst.operands[1].reg;

  if (thumb_mode)
    reject_bad_reg (Rt);
  else if (Rt == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* If we get through parsing the register name, we just insert the number
     generated into the instruction without further validation.  */
  inst.instruction |= (inst.operands[0].reg << 16);
  inst.instruction |= (Rt << 12);
}

static void
do_mrs (void)
{
  unsigned br;

  if (do_vfp_nsyn_mrs () == SUCCESS)
    return;

  constraint (inst.operands[0].reg == REG_PC, BAD_PC);
  inst.instruction |= inst.operands[0].reg << 12;

  if (inst.operands[1].isreg)
    {
      br = inst.operands[1].reg;
      if (((br & 0x200) == 0) && ((br & 0xf0000) != 0xf000))
	as_bad (_("bad register for mrs"));
    }
  else
    {
      /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
      constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
		  != (PSR_c|PSR_f),
		  _("'APSR', 'CPSR' or 'SPSR' expected"));
      br = (15<<16) | (inst.operands[1].imm & SPSR_BIT);
    }

  inst.instruction |= br;
}

/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */

static void
do_msr (void)
{
  if (do_vfp_nsyn_msr () == SUCCESS)
    return;

  inst.instruction |= inst.operands[0].imm;
  if (inst.operands[1].isreg)
    inst.instruction |= inst.operands[1].reg;
  else
    {
      inst.instruction |= INST_IMMEDIATE;
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
    }
}

static void
do_mul (void)
{
  constraint (inst.operands[2].reg == REG_PC, BAD_PC);

  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;

  if (inst.operands[0].reg == inst.operands[1].reg
      && !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6))
    as_tsktsk (_("Rd and Rm should be different in mul"));
}

/* Long Multiply Parser
   UMULL RdLo, RdHi, Rm, Rs
   SMULL RdLo, RdHi, Rm, Rs
   UMLAL RdLo, RdHi, Rm, Rs
   SMLAL RdLo, RdHi, Rm, Rs.  */

static void
do_mull (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 8;

  /* rdhi and rdlo must be different.  */
  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rdhi and rdlo must be different"));

  /* rdhi, rdlo and rm must all be different before armv6.  */
  if ((inst.operands[0].reg == inst.operands[2].reg
      || inst.operands[1].reg == inst.operands[2].reg)
      && !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6))
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
}

static void
do_nop (void)
{
  if (inst.operands[0].present
      || ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6k))
    {
      /* Architectural NOP hints are CPSR sets with no bits selected.  */
      inst.instruction &= 0xf0000000;
      inst.instruction |= 0x0320f000;
      if (inst.operands[0].present)
	inst.instruction |= inst.operands[0].imm;
    }
}

/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>}
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

static void
do_pkhbt (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  if (inst.operands[3].present)
    encode_arm_shift (3);
}

/* ARM V6 PKHTB (Argument Parse).  */

static void
do_pkhtb (void)
{
  if (!inst.operands[3].present)
    {
      /* If the shift specifier is omitted, turn the instruction
	 into pkhbt rd, rm, rn. */
      inst.instruction &= 0xfff00010;
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg;
      inst.instruction |= inst.operands[2].reg << 16;
    }
  else
    {
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg;
      encode_arm_shift (3);
    }
}

/* ARMv5TE: Preload-Cache
   MP Extensions: Preload for write

    PLD(W) <addr_mode>

  Syntactically, like LDR with B=1, W=0, L=1.  */

static void
do_pld (void)
{
  constraint (!inst.operands[0].isreg,
	      _("'[' expected after PLD mnemonic"));
  constraint (inst.operands[0].postind,
	      _("post-indexed expression used in preload instruction"));
  constraint (inst.operands[0].writeback,
	      _("writeback used in preload instruction"));
  constraint (!inst.operands[0].preind,
	      _("unindexed addressing used in preload instruction"));
  encode_arm_addr_mode_2 (0, /*is_t=*/FALSE);
}

/* ARMv7: PLI <addr_mode>  */
static void
do_pli (void)
{
  constraint (!inst.operands[0].isreg,
	      _("'[' expected after PLI mnemonic"));
  constraint (inst.operands[0].postind,
	      _("post-indexed expression used in preload instruction"));
  constraint (inst.operands[0].writeback,
	      _("writeback used in preload instruction"));
  constraint (!inst.operands[0].preind,
	      _("unindexed addressing used in preload instruction"));
  encode_arm_addr_mode_2 (0, /*is_t=*/FALSE);
  inst.instruction &= ~PRE_INDEX;
}

static void
do_push_pop (void)
{
  inst.operands[1] = inst.operands[0];
  memset (&inst.operands[0], 0, sizeof inst.operands[0]);
  inst.operands[0].isreg = 1;
  inst.operands[0].writeback = 1;
  inst.operands[0].reg = REG_SP;
  encode_ldmstm (/*from_push_pop_mnem=*/TRUE);
}

/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
   word at the specified address and the following word
   respectively.
   Unconditionally executed.
   Error if Rn is R15.	*/

static void
do_rfe (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
}

/* ARM V6 ssat (argument parse).  */

static void
do_ssat (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= (inst.operands[1].imm - 1) << 16;
  inst.instruction |= inst.operands[2].reg;

  if (inst.operands[3].present)
    encode_arm_shift (3);
}

/* ARM V6 usat (argument parse).  */

static void
do_usat (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 16;
  inst.instruction |= inst.operands[2].reg;

  if (inst.operands[3].present)
    encode_arm_shift (3);
}

/* ARM V6 ssat16 (argument parse).  */

static void
do_ssat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= ((inst.operands[1].imm - 1) << 16);
  inst.instruction |= inst.operands[2].reg;
}

static void
do_usat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 16;
  inst.instruction |= inst.operands[2].reg;
}

/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.

   setend <endian_specifier>, where <endian_specifier> is either
   BE or LE.  */

static void
do_setend (void)
{
  if (warn_on_deprecated
      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
      as_warn (_("setend use is deprecated for ARMv8"));

  if (inst.operands[0].imm)
    inst.instruction |= 0x200;
}

static void
do_shift (void)
{
  unsigned int Rm = (inst.operands[1].present
		     ? inst.operands[1].reg
		     : inst.operands[0].reg);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= Rm;
  if (inst.operands[2].isreg)  /* Rd, {Rm,} Rs */
    {
      inst.instruction |= inst.operands[2].reg << 8;
      inst.instruction |= SHIFT_BY_REG;
      /* PR 12854: Error on extraneous shifts.  */
      constraint (inst.operands[2].shifted,
		  _("extraneous shift as part of operand to shift insn"));
    }
  else
    inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
}

static void
do_smc (void)
{
  inst.reloc.type = BFD_RELOC_ARM_SMC;
  inst.reloc.pc_rel = 0;
}

static void
do_hvc (void)
{
  inst.reloc.type = BFD_RELOC_ARM_HVC;
  inst.reloc.pc_rel = 0;
}

static void
do_swi (void)
{
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
}

/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
   SMLAxy{cond} Rd,Rm,Rs,Rn
   SMLAWy{cond} Rd,Rm,Rs,Rn
   Error if any register is R15.  */

static void
do_smla (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 12;
}

/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
   Error if any register is R15.
   Warning if Rdlo == Rdhi.  */

static void
do_smlal (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 8;

  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rdhi and rdlo must be different"));
}

/* ARM V5E (El Segundo) signed-multiply (argument parse)
   SMULxy{cond} Rd,Rm,Rs
   Error if any register is R15.  */

static void
do_smul (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
}

/* ARM V6 srs (argument parse).  The variable fields in the encoding are
   the same for both ARM and Thumb-2.  */

static void
do_srs (void)
{
  int reg;

  if (inst.operands[0].present)
    {
      reg = inst.operands[0].reg;
      constraint (reg != REG_SP, _("SRS base register must be r13"));
    }
  else
    reg = REG_SP;

  inst.instruction |= reg << 16;
  inst.instruction |= inst.operands[1].imm;
  if (inst.operands[0].writeback || inst.operands[1].writeback)
    inst.instruction |= WRITE_BACK;
}

/* ARM V6 strex (argument parse).  */

static void
do_strex (void)
{
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative
	      /* See comment in do_ldrex().  */
	      || (inst.operands[2].reg == REG_PC),
	      BAD_ADDR_MODE);

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  constraint (inst.reloc.exp.X_op != O_constant
	      || inst.reloc.exp.X_add_number != 0,
	      _("offset must be zero in ARM encoding"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.reloc.type = BFD_RELOC_UNUSED;
}

static void
do_t_strexbh (void)
{
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative,
	      BAD_ADDR_MODE);

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  do_rm_rd_rn ();
}

static void
do_strexd (void)
{
  constraint (inst.operands[1].reg % 2 != 0,
	      _("even register required"));
  constraint (inst.operands[2].present
	      && inst.operands[2].reg != inst.operands[1].reg + 1,
	      _("can only store two consecutive registers"));
  /* If op 2 were present and equal to PC, this function wouldn't
     have been called in the first place.  */
  constraint (inst.operands[1].reg == REG_LR, _("r14 not allowed here"));

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[1].reg + 1
	      || inst.operands[0].reg == inst.operands[3].reg,
	      BAD_OVERLAP);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[3].reg << 16;
}

/* ARM V8 STRL.  */
static void
do_stlex (void)
{
  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  do_rd_rm_rn ();
}

static void
do_t_stlex (void)
{
  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  do_rm_rd_rn ();
}

/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
   extends it to 32-bits, and adds the result to a value in another
   register.  You can specify a rotation by 0, 8, 16, or 24 bits
   before extracting the 16-bit value.
   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */

static void
do_sxtah (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 10;
}

/* ARM V6 SXTH.

   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */

static void
do_sxth (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 10;
}

/* VFP instructions.  In a logical order: SP variant first, monad
   before dyad, arithmetic then move then load/store.  */

static void
do_vfp_sp_monadic (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sm);
}

static void
do_vfp_sp_dyadic (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sn);
  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Sm);
}

static void
do_vfp_sp_compare_z (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
}

static void
do_vfp_dp_sp_cvt (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sm);
}

static void
do_vfp_sp_dp_cvt (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dm);
}

static void
do_vfp_reg_from_sp (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sn);
}

static void
do_vfp_reg2_from_sp2 (void)
{
  constraint (inst.operands[2].imm != 2,
	      _("only two consecutive VFP SP registers allowed here"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Sm);
}

static void
do_vfp_sp_from_reg (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sn);
  inst.instruction |= inst.operands[1].reg << 12;
}

static void
do_vfp_sp2_from_reg2 (void)
{
  constraint (inst.operands[0].imm != 2,
	      _("only two consecutive VFP SP registers allowed here"));
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sm);
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_vfp_sp_ldst (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_cp_address (1, FALSE, TRUE, 0);
}

static void
do_vfp_dp_ldst (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_cp_address (1, FALSE, TRUE, 0);
}


static void
vfp_sp_ldstm (enum vfp_ldstm_type ldstm_type)
{
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
  else
    constraint (ldstm_type != VFP_LDSTMIA,
		_("this addressing mode requires base-register writeback"));
  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sd);
  inst.instruction |= inst.operands[1].imm;
}

static void
vfp_dp_ldstm (enum vfp_ldstm_type ldstm_type)
{
  int count;

  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
  else
    constraint (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX,
		_("this addressing mode requires base-register writeback"));

  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);

  count = inst.operands[1].imm << 1;
  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    count += 1;

  inst.instruction |= count;
}

static void
do_vfp_sp_ldstmia (void)
{
  vfp_sp_ldstm (VFP_LDSTMIA);
}

static void
do_vfp_sp_ldstmdb (void)
{
  vfp_sp_ldstm (VFP_LDSTMDB);
}

static void
do_vfp_dp_ldstmia (void)
{
  vfp_dp_ldstm (VFP_LDSTMIA);
}

static void
do_vfp_dp_ldstmdb (void)
{
  vfp_dp_ldstm (VFP_LDSTMDB);
}

static void
do_vfp_xp_ldstmia (void)
{
  vfp_dp_ldstm (VFP_LDSTMIAX);
}

static void
do_vfp_xp_ldstmdb (void)
{
  vfp_dp_ldstm (VFP_LDSTMDBX);
}

static void
do_vfp_dp_rd_rm (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dm);
}

static void
do_vfp_dp_rn_rd (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dn);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);
}

static void
do_vfp_dp_rd_rn (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dn);
}

static void
do_vfp_dp_rd_rn_rm (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dn);
  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Dm);
}

static void
do_vfp_dp_rd (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
}

static void
do_vfp_dp_rm_rd_rn (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dm);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Dn);
}

/* VFPv3 instructions.  */
static void
do_vfp_sp_const (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  inst.instruction |= (inst.operands[1].imm & 0xf0) << 12;
  inst.instruction |= (inst.operands[1].imm & 0x0f);
}

static void
do_vfp_dp_const (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  inst.instruction |= (inst.operands[1].imm & 0xf0) << 12;
  inst.instruction |= (inst.operands[1].imm & 0x0f);
}

static void
vfp_conv (int srcsize)
{
  int immbits = srcsize - inst.operands[1].imm;

  if (srcsize == 16 && !(immbits >= 0 && immbits <= srcsize))
    {
      /* If srcsize is 16, inst.operands[1].imm must be in the range 0-16.
	 i.e. immbits must be in range 0 - 16.  */
      inst.error = _("immediate value out of range, expected range [0, 16]");
      return;
    }
  else if (srcsize == 32 && !(immbits >= 0 && immbits < srcsize))
    {
      /* If srcsize is 32, inst.operands[1].imm must be in the range 1-32.
	 i.e. immbits must be in range 0 - 31.  */
      inst.error = _("immediate value out of range, expected range [1, 32]");
      return;
    }

  inst.instruction |= (immbits & 1) << 5;
  inst.instruction |= (immbits >> 1);
}

static void
do_vfp_sp_conv_16 (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  vfp_conv (16);
}

static void
do_vfp_dp_conv_16 (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  vfp_conv (16);
}

static void
do_vfp_sp_conv_32 (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  vfp_conv (32);
}

static void
do_vfp_dp_conv_32 (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  vfp_conv (32);
}

/* FPA instructions.  Also in a logical order.	*/

static void
do_fpa_cmp (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}

static void
do_fpa_ldmstm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  switch (inst.operands[1].imm)
    {
    case 1: inst.instruction |= CP_T_X;		 break;
    case 2: inst.instruction |= CP_T_Y;		 break;
    case 3: inst.instruction |= CP_T_Y | CP_T_X; break;
    case 4:					 break;
    default: abort ();
    }

  if (inst.instruction & (PRE_INDEX | INDEX_UP))
    {
      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      constraint (inst.reloc.exp.X_op != O_constant
		  || inst.reloc.exp.X_add_number != 0,
		  _("this instruction does not support indexing"));

      if ((inst.instruction & PRE_INDEX) || inst.operands[2].writeback)
	inst.reloc.exp.X_add_number = 12 * inst.operands[1].imm;

      if (!(inst.instruction & INDEX_UP))
	inst.reloc.exp.X_add_number = -inst.reloc.exp.X_add_number;

      if (!(inst.instruction & PRE_INDEX) && inst.operands[2].writeback)
	{
	  inst.operands[2].preind = 0;
	  inst.operands[2].postind = 1;
	}
    }

  encode_arm_cp_address (2, TRUE, TRUE, 0);
}

/* iWMMXt instructions: strictly in alphabetical order.	 */

static void
do_iwmmxt_tandorc (void)
{
  constraint (inst.operands[0].reg != REG_PC, _("only r15 allowed here"));
}

static void
do_iwmmxt_textrc (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm;
}

static void
do_iwmmxt_textrm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].imm;
}

static void
do_iwmmxt_tinsr (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].imm;
}

static void
do_iwmmxt_tmia (void)
{
  inst.instruction |= inst.operands[0].reg << 5;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}

static void
do_iwmmxt_waligni (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 20;
}

static void
do_iwmmxt_wmerge (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 21;
}

static void
do_iwmmxt_wmov (void)
{
  /* WMOV rD, rN is an alias for WOR rD, rN, rN.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}

static void
do_iwmmxt_wldstbh (void)
{
  int reloc;
  inst.instruction |= inst.operands[0].reg << 12;
  if (thumb_mode)
    reloc = BFD_RELOC_ARM_T32_CP_OFF_IMM_S2;
  else
    reloc = BFD_RELOC_ARM_CP_OFF_IMM_S2;
  encode_arm_cp_address (1, TRUE, FALSE, reloc);
}

static void
do_iwmmxt_wldstw (void)
{
  /* RIWR_RIWC clears .isreg for a control register.  */
  if (!inst.operands[0].isreg)
    {
      constraint (inst.cond != COND_ALWAYS, BAD_COND);
      inst.instruction |= 0xf0000000;
    }

  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, TRUE, 0);
}

static void
do_iwmmxt_wldstd (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2)
      && inst.operands[1].immisreg)
    {
      inst.instruction &= ~0x1a000ff;
      inst.instruction |= (0xf << 28);
      if (inst.operands[1].preind)
	inst.instruction |= PRE_INDEX;
      if (!inst.operands[1].negative)
	inst.instruction |= INDEX_UP;
      if (inst.operands[1].writeback)
	inst.instruction |= WRITE_BACK;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.reloc.exp.X_add_number << 4;
      inst.instruction |= inst.operands[1].imm;
    }
  else
    encode_arm_cp_address (1, TRUE, FALSE, 0);
}

static void
do_iwmmxt_wshufh (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= ((inst.operands[2].imm & 0xf0) << 16);
  inst.instruction |= (inst.operands[2].imm & 0x0f);
}

static void
do_iwmmxt_wzero (void)
{
  /* WZERO reg is an alias for WANDN reg, reg, reg.  */
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[0].reg << 16;
}

static void
do_iwmmxt_wrwrwr_or_imm5 (void)
{
  if (inst.operands[2].isreg)
    do_rd_rn_rm ();
  else {
    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2),
		_("immediate operand requires iWMMXt2"));
    do_rd_rn ();
    if (inst.operands[2].imm == 0)
      {
	switch ((inst.instruction >> 20) & 0xf)
	  {
	  case 4:
	  case 5:
	  case 6:
	  case 7:
	    /* w...h wrd, wrn, #0 -> wrorh wrd, wrn, #16.  */
	    inst.operands[2].imm = 16;
	    inst.instruction = (inst.instruction & 0xff0fffff) | (0x7 << 20);
	    break;
	  case 8:
	  case 9:
	  case 10:
	  case 11:
	    /* w...w wrd, wrn, #0 -> wrorw wrd, wrn, #32.  */
	    inst.operands[2].imm = 32;
	    inst.instruction = (inst.instruction & 0xff0fffff) | (0xb << 20);
	    break;
	  case 12:
	  case 13:
	  case 14:
	  case 15:
	    {
	      /* w...d wrd, wrn, #0 -> wor wrd, wrn, wrn.  */
	      unsigned long wrn;
	      wrn = (inst.instruction >> 16) & 0xf;
	      inst.instruction &= 0xff0fff0f;
	      inst.instruction |= wrn;
	      /* Bail out here; the instruction is now assembled.  */
	      return;
	    }
	  }
      }
    /* Map 32 -> 0, etc.  */
    inst.operands[2].imm &= 0x1f;
    inst.instruction |= (0xf << 28) | ((inst.operands[2].imm & 0x10) << 4) | (inst.operands[2].imm & 0xf);
  }
}

/* Cirrus Maverick instructions.  Simple 2-, 3-, and 4-register
   operations first, then control, shift, and load/store.  */

/* Insns like "foo X,Y,Z".  */

static void
do_mav_triple (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}

/* Insns like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */

static void
do_mav_quad (void)
{
  inst.instruction |= inst.operands[0].reg << 5;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
}

/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
static void
do_mav_dspsc (void)
{
  inst.instruction |= inst.operands[1].reg << 12;
}

/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */

static void
do_mav_shift (void)
{
  int imm = inst.operands[2].imm;

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;

  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.	 */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);

  inst.instruction |= imm;
}

/* XScale instructions.	 Also sorted arithmetic before move.  */

/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */

static void
do_xsc_mia (void)
{
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}

/* Xscale move-accumulator-register (argument parse)

     MARcc   acc0,RdLo,RdHi.  */

static void
do_xsc_mar (void)
{
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

/* Xscale move-register-accumulator (argument parse)

     MRAcc   RdLo,RdHi,acc0.  */

static void
do_xsc_mra (void)
{
  constraint (inst.operands[0].reg == inst.operands[1].reg, BAD_OVERLAP);
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
}

/* Encoding functions relevant only to Thumb.  */

/* inst.operands[i] is a shifted-register operand; encode
   it into inst.instruction in the format used by Thumb32.  */

static void
encode_thumb32_shifted_operand (int i)
{
  unsigned int value = inst.reloc.exp.X_add_number;
  unsigned int shift = inst.operands[i].shift_kind;

  constraint (inst.operands[i].immisreg,
	      _("shift by register not allowed in thumb mode"));
  inst.instruction |= inst.operands[i].reg;
  if (shift == SHIFT_RRX)
    inst.instruction |= SHIFT_ROR << 4;
  else
    {
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));

      constraint (value > 32
		  || (value == 32 && (shift == SHIFT_LSL
				      || shift == SHIFT_ROR)),
		  _("shift expression is too large"));

      if (value == 0)
	shift = SHIFT_LSL;
      else if (value == 32)
	value = 0;

      inst.instruction |= shift << 4;
      inst.instruction |= (value & 0x1c) << 10;
      inst.instruction |= (value & 0x03) << 6;
    }
}


/* inst.operands[i] was set up by parse_address.  Encode it into a
   Thumb32 format load or store instruction.  Reject forms that cannot
   be used with such instructions.  If is_t is true, reject forms that
   cannot be used with a T instruction; if is_d is true, reject forms
   that cannot be used with a D instruction.  If it is a store insn,
   reject PC in Rn.  */

static void
encode_thumb32_addr_mode (int i, bfd_boolean is_t, bfd_boolean is_d)
{
  const bfd_boolean is_pc = (inst.operands[i].reg == REG_PC);

  constraint (!inst.operands[i].isreg,
	      _("Instruction does not support =N addresses"));

  inst.instruction |= inst.operands[i].reg << 16;
  if (inst.operands[i].immisreg)
    {
      constraint (is_pc, BAD_PC_ADDRESSING);
      constraint (is_t || is_d, _("cannot use register index with this instruction"));
      constraint (inst.operands[i].negative,
		  _("Thumb does not support negative register indexing"));
      constraint (inst.operands[i].postind,
		  _("Thumb does not support register post-indexing"));
      constraint (inst.operands[i].writeback,
		  _("Thumb does not support register indexing with writeback"));
      constraint (inst.operands[i].shifted && inst.operands[i].shift_kind != SHIFT_LSL,
		  _("Thumb supports only LSL in shifted register indexing"));

      inst.instruction |= inst.operands[i].imm;
      if (inst.operands[i].shifted)
	{
	  constraint (inst.reloc.exp.X_op != O_constant,
		      _("expression too complex"));
	  constraint (inst.reloc.exp.X_add_number < 0
		      || inst.reloc.exp.X_add_number > 3,
		      _("shift out of range"));
	  inst.instruction |= inst.reloc.exp.X_add_number << 4;
	}
      inst.reloc.type = BFD_RELOC_UNUSED;
    }
  else if (inst.operands[i].preind)
    {
      constraint (is_pc && inst.operands[i].writeback, BAD_PC_WRITEBACK);
      constraint (is_t && inst.operands[i].writeback,
		  _("cannot use writeback with this instruction"));
      constraint (is_pc && ((inst.instruction & THUMB2_LOAD_BIT) == 0),
		  BAD_PC_ADDRESSING);

      if (is_d)
	{
	  inst.instruction |= 0x01000000;
	  if (inst.operands[i].writeback)
	    inst.instruction |= 0x00200000;
	}
      else
	{
	  inst.instruction |= 0x00000c00;
	  if (inst.operands[i].writeback)
	    inst.instruction |= 0x00000100;
	}
      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
    }
  else if (inst.operands[i].postind)
    {
      gas_assert (inst.operands[i].writeback);
      constraint (is_pc, _("cannot use post-indexing with PC-relative addressing"));
      constraint (is_t, _("cannot use post-indexing with this instruction"));

      if (is_d)
	inst.instruction |= 0x00200000;
      else
	inst.instruction |= 0x00000900;
      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
    }
  else /* unindexed - only for coprocessor */
    inst.error = _("instruction does not accept unindexed addressing");
}

/* Table of Thumb instructions which exist in both 16- and 32-bit
   encodings (the latter only in post-V6T2 cores).  The index is the
   value used in the insns table below.  When there is more than one
   possible 16-bit encoding for the instruction, this table always
   holds variant (1).
   Also contains several pseudo-instructions used during relaxation.  */
#define T16_32_TAB				\
  X(_adc,   4140, eb400000),			\
  X(_adcs,  4140, eb500000),			\
  X(_add,   1c00, eb000000),			\
  X(_adds,  1c00, eb100000),			\
  X(_addi,  0000, f1000000),			\
  X(_addis, 0000, f1100000),			\
  X(_add_pc,000f, f20f0000),			\
  X(_add_sp,000d, f10d0000),			\
  X(_adr,   000f, f20f0000),			\
  X(_and,   4000, ea000000),			\
  X(_ands,  4000, ea100000),			\
  X(_asr,   1000, fa40f000),			\
  X(_asrs,  1000, fa50f000),			\
  X(_b,     e000, f000b000),			\
  X(_bcond, d000, f0008000),			\
  X(_bic,   4380, ea200000),			\
  X(_bics,  4380, ea300000),			\
  X(_cmn,   42c0, eb100f00),			\
  X(_cmp,   2800, ebb00f00),			\
  X(_cpsie, b660, f3af8400),			\
  X(_cpsid, b670, f3af8600),			\
  X(_cpy,   4600, ea4f0000),			\
  X(_dec_sp,80dd, f1ad0d00),			\
  X(_eor,   4040, ea800000),			\
  X(_eors,  4040, ea900000),			\
  X(_inc_sp,00dd, f10d0d00),			\
  X(_ldmia, c800, e8900000),			\
  X(_ldr,   6800, f8500000),			\
  X(_ldrb,  7800, f8100000),			\
  X(_ldrh,  8800, f8300000),			\
  X(_ldrsb, 5600, f9100000),			\
  X(_ldrsh, 5e00, f9300000),			\
  X(_ldr_pc,4800, f85f0000),			\
  X(_ldr_pc2,4800, f85f0000),			\
  X(_ldr_sp,9800, f85d0000),			\
  X(_lsl,   0000, fa00f000),			\
  X(_lsls,  0000, fa10f000),			\
  X(_lsr,   0800, fa20f000),			\
  X(_lsrs,  0800, fa30f000),			\
  X(_mov,   2000, ea4f0000),			\
  X(_movs,  2000, ea5f0000),			\
  X(_mul,   4340, fb00f000),                     \
  X(_muls,  4340, ffffffff), /* no 32b muls */	\
  X(_mvn,   43c0, ea6f0000),			\
  X(_mvns,  43c0, ea7f0000),			\
  X(_neg,   4240, f1c00000), /* rsb #0 */	\
  X(_negs,  4240, f1d00000), /* rsbs #0 */	\
  X(_orr,   4300, ea400000),			\
  X(_orrs,  4300, ea500000),			\
  X(_pop,   bc00, e8bd0000), /* ldmia sp!,... */	\
  X(_push,  b400, e92d0000), /* stmdb sp!,... */	\
  X(_rev,   ba00, fa90f080),			\
  X(_rev16, ba40, fa90f090),			\
  X(_revsh, bac0, fa90f0b0),			\
  X(_ror,   41c0, fa60f000),			\
  X(_rors,  41c0, fa70f000),			\
  X(_sbc,   4180, eb600000),			\
  X(_sbcs,  4180, eb700000),			\
  X(_stmia, c000, e8800000),			\
  X(_str,   6000, f8400000),			\
  X(_strb,  7000, f8000000),			\
  X(_strh,  8000, f8200000),			\
  X(_str_sp,9000, f84d0000),			\
  X(_sub,   1e00, eba00000),			\
  X(_subs,  1e00, ebb00000),			\
  X(_subi,  8000, f1a00000),			\
  X(_subis, 8000, f1b00000),			\
  X(_sxtb,  b240, fa4ff080),			\
  X(_sxth,  b200, fa0ff080),			\
  X(_tst,   4200, ea100f00),			\
  X(_uxtb,  b2c0, fa5ff080),			\
  X(_uxth,  b280, fa1ff080),			\
  X(_nop,   bf00, f3af8000),			\
  X(_yield, bf10, f3af8001),			\
  X(_wfe,   bf20, f3af8002),			\
  X(_wfi,   bf30, f3af8003),			\
  X(_sev,   bf40, f3af8004),                    \
  X(_sevl,  bf50, f3af8005),			\
  X(_udf,   de00, f7f0a000)

/* To catch errors in encoding functions, the codes are all offset by
   0xF800, putting them in one of the 32-bit prefix ranges, ergo undefined
   as 16-bit instructions.  */
#define X(a,b,c) T_MNEM##a
enum t16_32_codes { T16_32_OFFSET = 0xF7FF, T16_32_TAB };
#undef X

#define X(a,b,c) 0x##b
static const unsigned short thumb_op16[] = { T16_32_TAB };
#define THUMB_OP16(n) (thumb_op16[(n) - (T16_32_OFFSET + 1)])
#undef X

#define X(a,b,c) 0x##c
static const unsigned int thumb_op32[] = { T16_32_TAB };
#define THUMB_OP32(n)        (thumb_op32[(n) - (T16_32_OFFSET + 1)])
#define THUMB_SETS_FLAGS(n)  (THUMB_OP32 (n) & 0x00100000)
#undef X
#undef T16_32_TAB

/* Thumb instruction encoders, in alphabetical order.  */

/* ADDW or SUBW.  */

static void
do_t_add_sub_w (void)
{
  int Rd, Rn;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[1].reg;

  /* If Rn is REG_PC, this is ADR; if Rn is REG_SP, then this
     is the SP-{plus,minus}-immediate form of the instruction.  */
  if (Rn == REG_SP)
    constraint (Rd == REG_PC, BAD_PC);
  else
    reject_bad_reg (Rd);

  inst.instruction |= (Rn << 16) | (Rd << 8);
  inst.reloc.type = BFD_RELOC_ARM_T32_IMM12;
}

/* Parse an add or subtract instruction.  We get here with inst.instruction
   equalling any of THUMB_OPCODE_add, adds, sub, or subs.  */

static void
do_t_add_sub (void)
{
  int Rd, Rs, Rn;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */

  if (Rd == REG_PC)
    set_it_insn_type_last ();

  if (unified_syntax)
    {
      bfd_boolean flags;
      bfd_boolean narrow;
      int opcode;

      flags = (inst.instruction == T_MNEM_adds
	       || inst.instruction == T_MNEM_subs);
      if (flags)
	narrow = !in_it_block ();
      else
	narrow = in_it_block ();
      if (!inst.operands[2].isreg)
	{
	  int add;

	  constraint (Rd == REG_SP && Rs != REG_SP, BAD_SP);

	  add = (inst.instruction == T_MNEM_add
		 || inst.instruction == T_MNEM_adds);
	  opcode = 0;
	  if (inst.size_req != 4)
	    {
	      /* Attempt to use a narrow opcode, with relaxation if
		 appropriate.  */
	      if (Rd == REG_SP && Rs == REG_SP && !flags)
		opcode = add ? T_MNEM_inc_sp : T_MNEM_dec_sp;
	      else if (Rd <= 7 && Rs == REG_SP && add && !flags)
		opcode = T_MNEM_add_sp;
	      else if (Rd <= 7 && Rs == REG_PC && add && !flags)
		opcode = T_MNEM_add_pc;
	      else if (Rd <= 7 && Rs <= 7 && narrow)
		{
		  if (flags)
		    opcode = add ? T_MNEM_addis : T_MNEM_subis;
		  else
		    opcode = add ? T_MNEM_addi : T_MNEM_subi;
		}
	      if (opcode)
		{
		  inst.instruction = THUMB_OP16(opcode);
		  inst.instruction |= (Rd << 4) | Rs;
		  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
		  if (inst.size_req != 2)
		    inst.relax = opcode;
		}
	      else
		constraint (inst.size_req == 2, BAD_HIREG);
	    }
	  if (inst.size_req == 4
	      || (inst.size_req != 2 && !opcode))
	    {
	      if (Rd == REG_PC)
		{
		  constraint (add, BAD_PC);
		  constraint (Rs != REG_LR || inst.instruction != T_MNEM_subs,
			     _("only SUBS PC, LR, #const allowed"));
		  constraint (inst.reloc.exp.X_op != O_constant,
			      _("expression too complex"));
		  constraint (inst.reloc.exp.X_add_number < 0
			      || inst.reloc.exp.X_add_number > 0xff,
			     _("immediate value out of range"));
		  inst.instruction = T2_SUBS_PC_LR
				     | inst.reloc.exp.X_add_number;
		  inst.reloc.type = BFD_RELOC_UNUSED;
		  return;
		}
	      else if (Rs == REG_PC)
		{
		  /* Always use addw/subw.  */
		  inst.instruction = add ? 0xf20f0000 : 0xf2af0000;
		  inst.reloc.type = BFD_RELOC_ARM_T32_IMM12;
		}
	      else
		{
		  inst.instruction = THUMB_OP32 (inst.instruction);
		  inst.instruction = (inst.instruction & 0xe1ffffff)
				     | 0x10000000;
		  if (flags)
		    inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
		  else
		    inst.reloc.type = BFD_RELOC_ARM_T32_ADD_IMM;
		}
	      inst.instruction |= Rd << 8;
	      inst.instruction |= Rs << 16;
	    }
	}
      else
	{
	  unsigned int value = inst.reloc.exp.X_add_number;
	  unsigned int shift = inst.operands[2].shift_kind;

	  Rn = inst.operands[2].reg;
	  /* See if we can do this with a 16-bit instruction.  */
	  if (!inst.operands[2].shifted && inst.size_req != 4)
	    {
	      if (Rd > 7 || Rs > 7 || Rn > 7)
		narrow = FALSE;

	      if (narrow)
		{
		  inst.instruction = ((inst.instruction == T_MNEM_adds
				       || inst.instruction == T_MNEM_add)
				      ? T_OPCODE_ADD_R3
				      : T_OPCODE_SUB_R3);
		  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
		  return;
		}

	      if (inst.instruction == T_MNEM_add && (Rd == Rs || Rd == Rn))
		{
		  /* Thumb-1 cores (except v6-M) require at least one high
		     register in a narrow non flag setting add.  */
		  if (Rd > 7 || Rn > 7
		      || ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6t2)
		      || ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_msr))
		    {
		      if (Rd == Rn)
			{
			  Rn = Rs;
			  Rs = Rd;
			}
		      inst.instruction = T_OPCODE_ADD_HI;
		      inst.instruction |= (Rd & 8) << 4;
		      inst.instruction |= (Rd & 7);
		      inst.instruction |= Rn << 3;
		      return;
		    }
		}
	    }

	  constraint (Rd == REG_PC, BAD_PC);
	  constraint (Rd == REG_SP && Rs != REG_SP, BAD_SP);
	  constraint (Rs == REG_PC, BAD_PC);
	  reject_bad_reg (Rn);

	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  constraint (Rd == REG_SP && Rs == REG_SP && value > 3,
		      _("shift value over 3 not allowed in thumb mode"));
	  constraint (Rd == REG_SP && Rs == REG_SP && shift != SHIFT_LSL,
		      _("only LSL shift allowed in thumb mode"));
	  encode_thumb32_shifted_operand (2);
	}
    }
  else
    {
      constraint (inst.instruction == T_MNEM_adds
		  || inst.instruction == T_MNEM_subs,
		  BAD_THUMB32);

      if (!inst.operands[2].isreg) /* Rd, Rs, #imm */
	{
	  constraint ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
		      || (Rs > 7 && Rs != REG_SP && Rs != REG_PC),
		      BAD_HIREG);

	  inst.instruction = (inst.instruction == T_MNEM_add
			      ? 0x0000 : 0x8000);
	  inst.instruction |= (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	  return;
	}

      Rn = inst.operands[2].reg;
      constraint (inst.operands[2].shifted, _("unshifted register required"));

      /* We now have Rd, Rs, and Rn set to registers.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
	{
	  /* Can't do this for SUB.	 */
	  constraint (inst.instruction == T_MNEM_sub, BAD_HIREG);
	  inst.instruction = T_OPCODE_ADD_HI;
	  inst.instruction |= (Rd & 8) << 4;
	  inst.instruction |= (Rd & 7);
	  if (Rs == Rd)
	    inst.instruction |= Rn << 3;
	  else if (Rn == Rd)
	    inst.instruction |= Rs << 3;
	  else
	    constraint (1, _("dest must overlap one source register"));
	}
      else
	{
	  inst.instruction = (inst.instruction == T_MNEM_add
			      ? T_OPCODE_ADD_R3 : T_OPCODE_SUB_R3);
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
    }
}

static void
do_t_adr (void)
{
  unsigned Rd;

  Rd = inst.operands[0].reg;
  reject_bad_reg (Rd);

  if (unified_syntax && inst.size_req == 0 && Rd <= 7)
    {
      /* Defer to section relaxation.  */
      inst.relax = inst.instruction;
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd << 4;
    }
  else if (unified_syntax && inst.size_req != 2)
    {
      /* Generate a 32-bit opcode.  */
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= Rd << 8;
      inst.reloc.type = BFD_RELOC_ARM_T32_ADD_PC12;
      inst.reloc.pc_rel = 1;
    }
  else
    {
      /* Generate a 16-bit opcode.  */
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
      inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
      inst.reloc.pc_rel = 1;

      inst.instruction |= Rd << 4;
    }
}

/* Arithmetic instructions for which there is just one 16-bit
   instruction encoding, and it allows only two low registers.
   For maximal compatibility with ARM syntax, we allow three register
   operands even when Thumb-32 instructions are not available, as long
   as the first two are identical.  For instance, both "sbc r0,r1" and
   "sbc r0,r0,r1" are allowed.  */
static void
do_t_arit3 (void)
{
  int Rd, Rs, Rn;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
  Rn = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rs);
  if (inst.operands[2].isreg)
    reject_bad_reg (Rn);

  if (unified_syntax)
    {
      if (!inst.operands[2].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  bfd_boolean narrow;

	  /* See if we can do this with a 16-bit instruction.  */
	  if (THUMB_SETS_FLAGS (inst.instruction))
	    narrow = !in_it_block ();
	  else
	    narrow = in_it_block ();

	  if (Rd > 7 || Rn > 7 || Rs > 7)
	    narrow = FALSE;
	  if (inst.operands[2].shifted)
	    narrow = FALSE;
	  if (inst.size_req == 4)
	    narrow = FALSE;

	  if (narrow
	      && Rd == Rs)
	    {
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= Rd;
	      inst.instruction |= Rn << 3;
	      return;
	    }

	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted
		      && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
    }
  else
    {
      /* On its face this is a lie - the instruction does set the
	 flags.  However, the only supported mnemonic in this mode
	 says it doesn't.  */
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);

      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
		  _("unshifted register required"));
      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);
      constraint (Rd != Rs,
		  _("dest and source1 must be the same register"));

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;
      inst.instruction |= Rn << 3;
    }
}

/* Similarly, but for instructions where the arithmetic operation is
   commutative, so we can allow either of them to be different from
   the destination operand in a 16-bit instruction.  For instance, all
   three of "adc r0,r1", "adc r0,r0,r1", and "adc r0,r1,r0" are
   accepted.  */
static void
do_t_arit3c (void)
{
  int Rd, Rs, Rn;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
  Rn = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rs);
  if (inst.operands[2].isreg)
    reject_bad_reg (Rn);

  if (unified_syntax)
    {
      if (!inst.operands[2].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  bfd_boolean narrow;

	  /* See if we can do this with a 16-bit instruction.  */
	  if (THUMB_SETS_FLAGS (inst.instruction))
	    narrow = !in_it_block ();
	  else
	    narrow = in_it_block ();

	  if (Rd > 7 || Rn > 7 || Rs > 7)
	    narrow = FALSE;
	  if (inst.operands[2].shifted)
	    narrow = FALSE;
	  if (inst.size_req == 4)
	    narrow = FALSE;

	  if (narrow)
	    {
	      if (Rd == Rs)
		{
		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= Rd;
		  inst.instruction |= Rn << 3;
		  return;
		}
	      if (Rd == Rn)
		{
		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= Rd;
		  inst.instruction |= Rs << 3;
		  return;
		}
	    }

	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted
		      && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
    }
  else
    {
      /* On its face this is a lie - the instruction does set the
	 flags.  However, the only supported mnemonic in this mode
	 says it doesn't.  */
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);

      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
		  _("unshifted register required"));
      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;

      if (Rd == Rs)
	inst.instruction |= Rn << 3;
      else if (Rd == Rn)
	inst.instruction |= Rs << 3;
      else
	constraint (1, _("dest must overlap one source register"));
    }
}

static void
do_t_bfc (void)
{
  unsigned Rd;
  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  Rd = inst.operands[0].reg;
  reject_bad_reg (Rd);
  inst.instruction |= Rd << 8;
  inst.instruction |= (inst.operands[1].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[1].imm & 0x03) << 6;
  inst.instruction |= msb - 1;
}

static void
do_t_bfi (void)
{
  int Rd, Rn;
  unsigned int msb;

  Rd = inst.operands[0].reg;
  reject_bad_reg (Rd);

  /* #0 in second position is alternative syntax for bfc, which is
     the same instruction but with REG_PC in the Rm field.  */
  if (!inst.operands[1].isreg)
    Rn = REG_PC;
  else
    {
      Rn = inst.operands[1].reg;
      reject_bad_reg (Rn);
    }

  msb = inst.operands[2].imm + inst.operands[3].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
  inst.instruction |= msb - 1;
}

static void
do_t_bfx (void)
{
  unsigned Rd, Rn;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[1].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);

  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
	      _("bit-field extends past end of register"));
  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
  inst.instruction |= inst.operands[3].imm - 1;
}

/* ARM V5 Thumb BLX (argument parse)
	BLX <target_addr>	which is BLX(1)
	BLX <Rm>		which is BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.

   ??? How to take advantage of the additional two bits of displacement
   available in Thumb32 mode?  Need new relocation?  */

static void
do_t_blx (void)
{
  set_it_insn_type_last ();

  if (inst.operands[0].isreg)
    {
      constraint (inst.operands[0].reg == REG_PC, BAD_PC);
      /* We have a register, so this is BLX(2).  */
      inst.instruction |= inst.operands[0].reg << 3;
    }
  else
    {
      /* No register.  This must be BLX(1).  */
      inst.instruction = 0xf000e800;
      encode_branch (BFD_RELOC_THUMB_PCREL_BLX);
    }
}

static void
do_t_branch (void)
{
  int opcode;
  int cond;
  int reloc;

  cond = inst.cond;
  set_it_insn_type (IF_INSIDE_IT_LAST_INSN);

  if (in_it_block ())
    {
      /* Conditional branches inside IT blocks are encoded as unconditional
	 branches.  */
      cond = COND_ALWAYS;
    }
  else
    cond = inst.cond;

  if (cond != COND_ALWAYS)
    opcode = T_MNEM_bcond;
  else
    opcode = inst.instruction;

  if (unified_syntax
      && (inst.size_req == 4
	  || (inst.size_req != 2
	      && (inst.operands[0].hasreloc
		  || inst.reloc.exp.X_op == O_constant))))
    {
      inst.instruction = THUMB_OP32(opcode);
      if (cond == COND_ALWAYS)
	reloc = BFD_RELOC_THUMB_PCREL_BRANCH25;
      else
	{
	  gas_assert (cond != 0xF);
	  inst.instruction |= cond << 22;
	  reloc = BFD_RELOC_THUMB_PCREL_BRANCH20;
	}
    }
  else
    {
      inst.instruction = THUMB_OP16(opcode);
      if (cond == COND_ALWAYS)
	reloc = BFD_RELOC_THUMB_PCREL_BRANCH12;
      else
	{
	  inst.instruction |= cond << 8;
	  reloc = BFD_RELOC_THUMB_PCREL_BRANCH9;
	}
      /* Allow section relaxation.  */
      if (unified_syntax && inst.size_req != 2)
	inst.relax = opcode;
    }
  inst.reloc.type = reloc;
  inst.reloc.pc_rel = 1;
}

/* Actually do the work for Thumb state bkpt and hlt.  The only difference
   between the two is the maximum immediate allowed - which is passed in
   RANGE.  */
static void
do_t_bkpt_hlt1 (int range)
{
  constraint (inst.cond != COND_ALWAYS,
	      _("instruction is always unconditional"));
  if (inst.operands[0].present)
    {
      constraint (inst.operands[0].imm > range,
		  _("immediate value out of range"));
      inst.instruction |= inst.operands[0].imm;
    }

  set_it_insn_type (NEUTRAL_IT_INSN);
}

static void
do_t_hlt (void)
{
  do_t_bkpt_hlt1 (63);
}

static void
do_t_bkpt (void)
{
  do_t_bkpt_hlt1 (255);
}

static void
do_t_branch23 (void)
{
  set_it_insn_type_last ();
  encode_branch (BFD_RELOC_THUMB_PCREL_BRANCH23);

  /* md_apply_fix blows up with 'bl foo(PLT)' where foo is defined in
     this file.  We used to simply ignore the PLT reloc type here --
     the branch encoding is now needed to deal with TLSCALL relocs.
     So if we see a PLT reloc now, put it back to how it used to be to
     keep the preexisting behaviour.  */
  if (inst.reloc.type == BFD_RELOC_ARM_PLT32)
    inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH23;

#if defined(OBJ_COFF)
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.	*/
  if (	 inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
#endif
}

static void
do_t_bx (void)
{
  set_it_insn_type_last ();
  inst.instruction |= inst.operands[0].reg << 3;
  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.	 The reloc
     should cause the alignment to be checked once it is known.	 This is
     because BX PC only works if the instruction is word aligned.  */
}

static void
do_t_bxj (void)
{
  int Rm;

  set_it_insn_type_last ();
  Rm = inst.operands[0].reg;
  reject_bad_reg (Rm);
  inst.instruction |= Rm << 16;
}

static void
do_t_clz (void)
{
  unsigned Rd;
  unsigned Rm;

  Rd = inst.operands[0].reg;
  Rm = inst.operands[1].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rm);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rm << 16;
  inst.instruction |= Rm;
}

static void
do_t_cps (void)
{
  set_it_insn_type (OUTSIDE_IT_INSN);
  inst.instruction |= inst.operands[0].imm;
}

static void
do_t_cpsi (void)
{
  set_it_insn_type (OUTSIDE_IT_INSN);
  if (unified_syntax
      && (inst.operands[1].present || inst.size_req == 4)
      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6_notm))
    {
      unsigned int imod = (inst.instruction & 0x0030) >> 4;
      inst.instruction = 0xf3af8000;
      inst.instruction |= imod << 9;
      inst.instruction |= inst.operands[0].imm << 5;
      if (inst.operands[1].present)
	inst.instruction |= 0x100 | inst.operands[1].imm;
    }
  else
    {
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1)
		  && (inst.operands[0].imm & 4),
		  _("selected processor does not support 'A' form "
		    "of this instruction"));
      constraint (inst.operands[1].present || inst.size_req == 4,
		  _("Thumb does not support the 2-argument "
		    "form of this instruction"));
      inst.instruction |= inst.operands[0].imm;
    }
}

/* THUMB CPY instruction (argument parse).  */

static void
do_t_cpy (void)
{
  if (inst.size_req == 4)
    {
      inst.instruction = THUMB_OP32 (T_MNEM_mov);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg;
    }
  else
    {
      inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
      inst.instruction |= (inst.operands[0].reg & 0x7);
      inst.instruction |= inst.operands[1].reg << 3;
    }
}

static void
do_t_cbz (void)
{
  set_it_insn_type (OUTSIDE_IT_INSN);
  constraint (inst.operands[0].reg > 7, BAD_HIREG);
  inst.instruction |= inst.operands[0].reg;
  inst.reloc.pc_rel = 1;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH7;
}

static void
do_t_dbg (void)
{
  inst.instruction |= inst.operands[0].imm;
}

static void
do_t_div (void)
{
  unsigned Rd, Rn, Rm;

  Rd = inst.operands[0].reg;
  Rn = (inst.operands[1].present
	? inst.operands[1].reg : Rd);
  Rm = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);
  reject_bad_reg (Rm);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= Rm;
}

static void
do_t_hint (void)
{
  if (unified_syntax && inst.size_req == 4)
    inst.instruction = THUMB_OP32 (inst.instruction);
  else
    inst.instruction = THUMB_OP16 (inst.instruction);
}

static void
do_t_it (void)
{
  unsigned int cond = inst.operands[0].imm;

  set_it_insn_type (IT_INSN);
  now_it.mask = (inst.instruction & 0xf) | 0x10;
  now_it.cc = cond;
  now_it.warn_deprecated = FALSE;

  /* If the condition is a negative condition, invert the mask.  */
  if ((cond & 0x1) == 0x0)
    {
      unsigned int mask = inst.instruction & 0x000f;

      if ((mask & 0x7) == 0)
	{
	  /* No conversion needed.  */
	  now_it.block_length = 1;
	}
      else if ((mask & 0x3) == 0)
	{
	  mask ^= 0x8;
	  now_it.block_length = 2;
	}
      else if ((mask & 0x1) == 0)
	{
	  mask ^= 0xC;
	  now_it.block_length = 3;
	}
      else
	{
	  mask ^= 0xE;
	  now_it.block_length = 4;
	}

      inst.instruction &= 0xfff0;
      inst.instruction |= mask;
    }

  inst.instruction |= cond << 4;
}

/* Helper function used for both push/pop and ldm/stm.  */
static void
encode_thumb2_ldmstm (int base, unsigned mask, bfd_boolean writeback)
{
  bfd_boolean load;

  load = (inst.instruction & (1 << 20)) != 0;

  if (mask & (1 << 13))
    inst.error =  _("SP not allowed in register list");

  if ((mask & (1 << base)) != 0
      && writeback)
    inst.error = _("having the base register in the register list when "
		   "using write back is UNPREDICTABLE");

  if (load)
    {
      if (mask & (1 << 15))
	{
	  if (mask & (1 << 14))
	    inst.error = _("LR and PC should not both be in register list");
	  else
	    set_it_insn_type_last ();
	}
    }
  else
    {
      if (mask & (1 << 15))
	inst.error = _("PC not allowed in register list");
    }

  if ((mask & (mask - 1)) == 0)
    {
      /* Single register transfers implemented as str/ldr.  */
      if (writeback)
	{
	  if (inst.instruction & (1 << 23))
	    inst.instruction = 0x00000b04; /* ia! -> [base], #4 */
	  else
	    inst.instruction = 0x00000d04; /* db! -> [base, #-4]! */
	}
      else
	{
	  if (inst.instruction & (1 << 23))
	    inst.instruction = 0x00800000; /* ia -> [base] */
	  else
	    inst.instruction = 0x00000c04; /* db -> [base, #-4] */
	}

      inst.instruction |= 0xf8400000;
      if (load)
	inst.instruction |= 0x00100000;

      mask = ffs (mask) - 1;
      mask <<= 12;
    }
  else if (writeback)
    inst.instruction |= WRITE_BACK;

  inst.instruction |= mask;
  inst.instruction |= base << 16;
}

static void
do_t_ldmstm (void)
{
  /* This really doesn't seem worth it.  */
  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
	      _("expression too complex"));
  constraint (inst.operands[1].writeback,
	      _("Thumb load/store multiple does not support {reglist}^"));

  if (unified_syntax)
    {
      bfd_boolean narrow;
      unsigned mask;

      narrow = FALSE;
      /* See if we can use a 16-bit instruction.  */
      if (inst.instruction < 0xffff /* not ldmdb/stmdb */
	  && inst.size_req != 4
	  && !(inst.operands[1].imm & ~0xff))
	{
	  mask = 1 << inst.operands[0].reg;

	  if (inst.operands[0].reg <= 7)
	    {
	      if (inst.instruction == T_MNEM_stmia
		  ? inst.operands[0].writeback
		  : (inst.operands[0].writeback
		     == !(inst.operands[1].imm & mask)))
		{
		  if (inst.instruction == T_MNEM_stmia
		      && (inst.operands[1].imm & mask)
		      && (inst.operands[1].imm & (mask - 1)))
		    as_warn (_("value stored for r%d is UNKNOWN"),
			     inst.operands[0].reg);

		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= inst.operands[0].reg << 8;
		  inst.instruction |= inst.operands[1].imm;
		  narrow = TRUE;
		}
	      else if ((inst.operands[1].imm & (inst.operands[1].imm-1)) == 0)
		{
		  /* This means 1 register in reg list one of 3 situations:
		     1. Instruction is stmia, but without writeback.
		     2. lmdia without writeback, but with Rn not in
			reglist.
		     3. ldmia with writeback, but with Rn in reglist.
		     Case 3 is UNPREDICTABLE behaviour, so we handle
		     case 1 and 2 which can be converted into a 16-bit
		     str or ldr. The SP cases are handled below.  */
		  unsigned long opcode;
		  /* First, record an error for Case 3.  */
		  if (inst.operands[1].imm & mask
		      && inst.operands[0].writeback)
		    inst.error =
			_("having the base register in the register list when "
			  "using write back is UNPREDICTABLE");

		  opcode = (inst.instruction == T_MNEM_stmia ? T_MNEM_str
							     : T_MNEM_ldr);
		  inst.instruction = THUMB_OP16 (opcode);
		  inst.instruction |= inst.operands[0].reg << 3;
		  inst.instruction |= (ffs (inst.operands[1].imm)-1);
		  narrow = TRUE;
		}
	    }
	  else if (inst.operands[0] .reg == REG_SP)
	    {
	      if (inst.operands[0].writeback)
		{
		  inst.instruction =
			THUMB_OP16 (inst.instruction == T_MNEM_stmia
				    ? T_MNEM_push : T_MNEM_pop);
		  inst.instruction |= inst.operands[1].imm;
		  narrow = TRUE;
		}
	      else if ((inst.operands[1].imm & (inst.operands[1].imm-1)) == 0)
		{
		  inst.instruction =
			THUMB_OP16 (inst.instruction == T_MNEM_stmia
				    ? T_MNEM_str_sp : T_MNEM_ldr_sp);
		  inst.instruction |= ((ffs (inst.operands[1].imm)-1) << 8);
		  narrow = TRUE;
		}
	    }
	}

      if (!narrow)
	{
	  if (inst.instruction < 0xffff)
	    inst.instruction = THUMB_OP32 (inst.instruction);

	  encode_thumb2_ldmstm (inst.operands[0].reg, inst.operands[1].imm,
				inst.operands[0].writeback);
	}
    }
  else
    {
      constraint (inst.operands[0].reg > 7
		  || (inst.operands[1].imm & ~0xff), BAD_HIREG);
      constraint (inst.instruction != T_MNEM_ldmia
		  && inst.instruction != T_MNEM_stmia,
		  _("Thumb-2 instruction only valid in unified syntax"));
      if (inst.instruction == T_MNEM_stmia)
	{
	  if (!inst.operands[0].writeback)
	    as_warn (_("this instruction will write back the base register"));
	  if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
	    as_warn (_("value stored for r%d is UNKNOWN"),
		     inst.operands[0].reg);
	}
      else
	{
	  if (!inst.operands[0].writeback
	      && !(inst.operands[1].imm & (1 << inst.operands[0].reg)))
	    as_warn (_("this instruction will write back the base register"));
	  else if (inst.operands[0].writeback
		   && (inst.operands[1].imm & (1 << inst.operands[0].reg)))
	    as_warn (_("this instruction will not write back the base register"));
	}

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].imm;
    }
}

static void
do_t_ldrex (void)
{
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
	      || inst.operands[1].postind || inst.operands[1].writeback
	      || inst.operands[1].immisreg || inst.operands[1].shifted
	      || inst.operands[1].negative,
	      BAD_ADDR_MODE);

  constraint ((inst.operands[1].reg == REG_PC), BAD_PC);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
}

static void
do_t_ldrexd (void)
{
  if (!inst.operands[1].present)
    {
      constraint (inst.operands[0].reg == REG_LR,
		  _("r14 not allowed as first register "
		    "when second register is omitted"));
      inst.operands[1].reg = inst.operands[0].reg + 1;
    }
  constraint (inst.operands[0].reg == inst.operands[1].reg,
	      BAD_OVERLAP);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_t_ldst (void)
{
  unsigned long opcode;
  int Rn;

  if (inst.operands[0].isreg
      && !inst.operands[0].preind
      && inst.operands[0].reg == REG_PC)
    set_it_insn_type_last ();

  opcode = inst.instruction;
  if (unified_syntax)
    {
      if (!inst.operands[1].isreg)
	{
	  if (opcode <= 0xffff)
	    inst.instruction = THUMB_OP32 (opcode);
	  if (move_or_literal_pool (0, /*thumb_p=*/TRUE, /*mode_3=*/FALSE))
	    return;
	}
      if (inst.operands[1].isreg
	  && !inst.operands[1].writeback
	  && !inst.operands[1].shifted && !inst.operands[1].postind
	  && !inst.operands[1].negative && inst.operands[0].reg <= 7
	  && opcode <= 0xffff
	  && inst.size_req != 4)
	{
	  /* Insn may have a 16-bit form.  */
	  Rn = inst.operands[1].reg;
	  if (inst.operands[1].immisreg)
	    {
	      inst.instruction = THUMB_OP16 (opcode);
	      /* [Rn, Rik] */
	      if (Rn <= 7 && inst.operands[1].imm <= 7)
		goto op16;
	      else if (opcode != T_MNEM_ldr && opcode != T_MNEM_str)
		reject_bad_reg (inst.operands[1].imm);
	    }
	  else if ((Rn <= 7 && opcode != T_MNEM_ldrsh
		    && opcode != T_MNEM_ldrsb)
		   || ((Rn == REG_PC || Rn == REG_SP) && opcode == T_MNEM_ldr)
		   || (Rn == REG_SP && opcode == T_MNEM_str))
	    {
	      /* [Rn, #const] */
	      if (Rn > 7)
		{
		  if (Rn == REG_PC)
		    {
		      if (inst.reloc.pc_rel)
			opcode = T_MNEM_ldr_pc2;
		      else
			opcode = T_MNEM_ldr_pc;
		    }
		  else
		    {
		      if (opcode == T_MNEM_ldr)
			opcode = T_MNEM_ldr_sp;
		      else
			opcode = T_MNEM_str_sp;
		    }
		  inst.instruction = inst.operands[0].reg << 8;
		}
	      else
		{
		  inst.instruction = inst.operands[0].reg;
		  inst.instruction |= inst.operands[1].reg << 3;
		}
	      inst.instruction |= THUMB_OP16 (opcode);
	      if (inst.size_req == 2)
		inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
	      else
		inst.relax = opcode;
	      return;
	    }
	}
      /* Definitely a 32-bit variant.  */

      /* Warning for Erratum 752419.  */
      if (opcode == T_MNEM_ldr
	  && inst.operands[0].reg == REG_SP
	  && inst.operands[1].writeback == 1
	  && !inst.operands[1].immisreg)
	{
	  if (no_cpu_selected ()
	      || (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7)
		  && !ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7a)
		  && !ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7r)))
	    as_warn (_("This instruction may be unpredictable "
		       "if executed on M-profile cores "
		       "with interrupts enabled."));
	}

      /* Do some validations regarding addressing modes.  */
      if (inst.operands[1].immisreg)
	reject_bad_reg (inst.operands[1].imm);

      constraint (inst.operands[1].writeback == 1
		  && inst.operands[0].reg == inst.operands[1].reg,
		  BAD_OVERLAP);

      inst.instruction = THUMB_OP32 (opcode);
      inst.instruction |= inst.operands[0].reg << 12;
      encode_thumb32_addr_mode (1, /*is_t=*/FALSE, /*is_d=*/FALSE);
      check_ldr_r15_aligned ();
      return;
    }

  constraint (inst.operands[0].reg > 7, BAD_HIREG);

  if (inst.instruction == T_MNEM_ldrsh || inst.instruction == T_MNEM_ldrsb)
    {
      /* Only [Rn,Rm] is acceptable.  */
      constraint (inst.operands[1].reg > 7 || inst.operands[1].imm > 7, BAD_HIREG);
      constraint (!inst.operands[1].isreg || !inst.operands[1].immisreg
		  || inst.operands[1].postind || inst.operands[1].shifted
		  || inst.operands[1].negative,
		  _("Thumb does not support this addressing mode"));
      inst.instruction = THUMB_OP16 (inst.instruction);
      goto op16;
    }

  inst.instruction = THUMB_OP16 (inst.instruction);
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/TRUE, /*mode_3=*/FALSE))
      return;

  constraint (!inst.operands[1].preind
	      || inst.operands[1].shifted
	      || inst.operands[1].writeback,
	      _("Thumb does not support this addressing mode"));
  if (inst.operands[1].reg == REG_PC || inst.operands[1].reg == REG_SP)
    {
      constraint (inst.instruction & 0x0600,
		  _("byte or halfword not valid for base register"));
      constraint (inst.operands[1].reg == REG_PC
		  && !(inst.instruction & THUMB_LOAD_BIT),
		  _("r15 based store not allowed"));
      constraint (inst.operands[1].immisreg,
		  _("invalid base register for register offset"));

      if (inst.operands[1].reg == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (inst.instruction & THUMB_LOAD_BIT)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;

      inst.instruction |= inst.operands[0].reg << 8;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      return;
    }

  constraint (inst.operands[1].reg > 7, BAD_HIREG);
  if (!inst.operands[1].immisreg)
    {
      /* Immediate offset.  */
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      return;
    }

  /* Register offset.  */
  constraint (inst.operands[1].imm > 7, BAD_HIREG);
  constraint (inst.operands[1].negative,
	      _("Thumb does not support this addressing mode"));

 op16:
  switch (inst.instruction)
    {
    case T_OPCODE_STR_IW: inst.instruction = T_OPCODE_STR_RW; break;
    case T_OPCODE_STR_IH: inst.instruction = T_OPCODE_STR_RH; break;
    case T_OPCODE_STR_IB: inst.instruction = T_OPCODE_STR_RB; break;
    case T_OPCODE_LDR_IW: inst.instruction = T_OPCODE_LDR_RW; break;
    case T_OPCODE_LDR_IH: inst.instruction = T_OPCODE_LDR_RH; break;
    case T_OPCODE_LDR_IB: inst.instruction = T_OPCODE_LDR_RB; break;
    case 0x5600 /* ldrsb */:
    case 0x5e00 /* ldrsh */: break;
    default: abort ();
    }

  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 3;
  inst.instruction |= inst.operands[1].imm << 6;
}

static void
do_t_ldstd (void)
{
  if (!inst.operands[1].present)
    {
      inst.operands[1].reg = inst.operands[0].reg + 1;
      constraint (inst.operands[0].reg == REG_LR,
		  _("r14 not allowed here"));
      constraint (inst.operands[0].reg == REG_R12,
		  _("r12 not allowed here"));
    }

  if (inst.operands[2].writeback
      && (inst.operands[0].reg == inst.operands[2].reg
      || inst.operands[1].reg == inst.operands[2].reg))
    as_warn (_("base register written back, and overlaps "
	       "one of transfer registers"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  encode_thumb32_addr_mode (2, /*is_t=*/FALSE, /*is_d=*/TRUE);
}

static void
do_t_ldstt (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_thumb32_addr_mode (1, /*is_t=*/TRUE, /*is_d=*/FALSE);
}

static void
do_t_mla (void)
{
  unsigned Rd, Rn, Rm, Ra;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[1].reg;
  Rm = inst.operands[2].reg;
  Ra = inst.operands[3].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);
  reject_bad_reg (Rm);
  reject_bad_reg (Ra);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= Rm;
  inst.instruction |= Ra << 12;
}

static void
do_t_mlal (void)
{
  unsigned RdLo, RdHi, Rn, Rm;

  RdLo = inst.operands[0].reg;
  RdHi = inst.operands[1].reg;
  Rn = inst.operands[2].reg;
  Rm = inst.operands[3].reg;

  reject_bad_reg (RdLo);
  reject_bad_reg (RdHi);
  reject_bad_reg (Rn);
  reject_bad_reg (Rm);

  inst.instruction |= RdLo << 12;
  inst.instruction |= RdHi << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= Rm;
}

static void
do_t_mov_cmp (void)
{
  unsigned Rn, Rm;

  Rn = inst.operands[0].reg;
  Rm = inst.operands[1].reg;

  if (Rn == REG_PC)
    set_it_insn_type_last ();

  if (unified_syntax)
    {
      int r0off = (inst.instruction == T_MNEM_mov
		   || inst.instruction == T_MNEM_movs) ? 8 : 16;
      unsigned long opcode;
      bfd_boolean narrow;
      bfd_boolean low_regs;

      low_regs = (Rn <= 7 && Rm <= 7);
      opcode = inst.instruction;
      if (in_it_block ())
	narrow = opcode != T_MNEM_movs;
      else
	narrow = opcode != T_MNEM_movs || low_regs;
      if (inst.size_req == 4
	  || inst.operands[1].shifted)
	narrow = FALSE;

      /* MOVS PC, LR is encoded as SUBS PC, LR, #0.  */
      if (opcode == T_MNEM_movs && inst.operands[1].isreg
	  && !inst.operands[1].shifted
	  && Rn == REG_PC
	  && Rm == REG_LR)
	{
	  inst.instruction = T2_SUBS_PC_LR;
	  return;
	}

      if (opcode == T_MNEM_cmp)
	{
	  constraint (Rn == REG_PC, BAD_PC);
	  if (narrow)
	    {
	      /* In the Thumb-2 ISA, use of R13 as Rm is deprecated,
		 but valid.  */
	      warn_deprecated_sp (Rm);
	      /* R15 was documented as a valid choice for Rm in ARMv6,
		 but as UNPREDICTABLE in ARMv7.  ARM's proprietary
		 tools reject R15, so we do too.  */
	      constraint (Rm == REG_PC, BAD_PC);
	    }
	  else
	    reject_bad_reg (Rm);
	}
      else if (opcode == T_MNEM_mov
	       || opcode == T_MNEM_movs)
	{
	  if (inst.operands[1].isreg)
	    {
	      if (opcode == T_MNEM_movs)
		{
		  reject_bad_reg (Rn);
		  reject_bad_reg (Rm);
		}
	      else if (narrow)
		{
		  /* This is mov.n.  */
		  if ((Rn == REG_SP || Rn == REG_PC)
		      && (Rm == REG_SP || Rm == REG_PC))
		    {
		      as_warn (_("Use of r%u as a source register is "
				 "deprecated when r%u is the destination "
				 "register."), Rm, Rn);
		    }
		}
	      else
		{
		  /* This is mov.w.  */
		  constraint (Rn == REG_PC, BAD_PC);
		  constraint (Rm == REG_PC, BAD_PC);
		  constraint (Rn == REG_SP && Rm == REG_SP, BAD_SP);
		}
	    }
	  else
	    reject_bad_reg (Rn);
	}

      if (!inst.operands[1].isreg)
	{
	  /* Immediate operand.  */
	  if (!in_it_block () && opcode == T_MNEM_mov)
	    narrow = 0;
	  if (low_regs && narrow)
	    {
	      inst.instruction = THUMB_OP16 (opcode);
	      inst.instruction |= Rn << 8;
	      if (inst.size_req == 2)
		inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
	      else
		inst.relax = opcode;
	    }
	  else
	    {
	      inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	      inst.instruction |= Rn << r0off;
	      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	    }
	}
      else if (inst.operands[1].shifted && inst.operands[1].immisreg
	       && (inst.instruction == T_MNEM_mov
		   || inst.instruction == T_MNEM_movs))
	{
	  /* Register shifts are encoded as separate shift instructions.  */
	  bfd_boolean flags = (inst.instruction == T_MNEM_movs);

	  if (in_it_block ())
	    narrow = !flags;
	  else
	    narrow = flags;

	  if (inst.size_req == 4)
	    narrow = FALSE;

	  if (!low_regs || inst.operands[1].imm > 7)
	    narrow = FALSE;

	  if (Rn != Rm)
	    narrow = FALSE;

	  switch (inst.operands[1].shift_kind)
	    {
	    case SHIFT_LSL:
	      opcode = narrow ? T_OPCODE_LSL_R : THUMB_OP32 (T_MNEM_lsl);
	      break;
	    case SHIFT_ASR:
	      opcode = narrow ? T_OPCODE_ASR_R : THUMB_OP32 (T_MNEM_asr);
	      break;
	    case SHIFT_LSR:
	      opcode = narrow ? T_OPCODE_LSR_R : THUMB_OP32 (T_MNEM_lsr);
	      break;
	    case SHIFT_ROR:
	      opcode = narrow ? T_OPCODE_ROR_R : THUMB_OP32 (T_MNEM_ror);
	      break;
	    default:
	      abort ();
	    }

	  inst.instruction = opcode;
	  if (narrow)
	    {
	      inst.instruction |= Rn;
	      inst.instruction |= inst.operands[1].imm << 3;
	    }
	  else
	    {
	      if (flags)
		inst.instruction |= CONDS_BIT;

	      inst.instruction |= Rn << 8;
	      inst.instruction |= Rm << 16;
	      inst.instruction |= inst.operands[1].imm;
	    }
	}
      else if (!narrow)
	{
	  /* Some mov with immediate shift have narrow variants.
	     Register shifts are handled above.  */
	  if (low_regs && inst.operands[1].shifted
	      && (inst.instruction == T_MNEM_mov
		  || inst.instruction == T_MNEM_movs))
	    {
	      if (in_it_block ())
		narrow = (inst.instruction == T_MNEM_mov);
	      else
		narrow = (inst.instruction == T_MNEM_movs);
	    }

	  if (narrow)
	    {
	      switch (inst.operands[1].shift_kind)
		{
		case SHIFT_LSL: inst.instruction = T_OPCODE_LSL_I; break;
		case SHIFT_LSR: inst.instruction = T_OPCODE_LSR_I; break;
		case SHIFT_ASR: inst.instruction = T_OPCODE_ASR_I; break;
		default: narrow = FALSE; break;
		}
	    }

	  if (narrow)
	    {
	      inst.instruction |= Rn;
	      inst.instruction |= Rm << 3;
	      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	    }
	  else
	    {
	      inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= Rn << r0off;
	      encode_thumb32_shifted_operand (1);
	    }
	}
      else
	switch (inst.instruction)
	  {
	  case T_MNEM_mov:
	    /* In v4t or v5t a move of two lowregs produces unpredictable
	       results. Don't allow this.  */
	    if (low_regs)
	      {
		constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6),
			    "MOV Rd, Rs with two low registers is not "
			    "permitted on this architecture");
		ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
					arm_ext_v6);
	      }

	    inst.instruction = T_OPCODE_MOV_HR;
	    inst.instruction |= (Rn & 0x8) << 4;
	    inst.instruction |= (Rn & 0x7);
	    inst.instruction |= Rm << 3;
	    break;

	  case T_MNEM_movs:
	    /* We know we have low registers at this point.
	       Generate LSLS Rd, Rs, #0.  */
	    inst.instruction = T_OPCODE_LSL_I;
	    inst.instruction |= Rn;
	    inst.instruction |= Rm << 3;
	    break;

	  case T_MNEM_cmp:
	    if (low_regs)
	      {
		inst.instruction = T_OPCODE_CMP_LR;
		inst.instruction |= Rn;
		inst.instruction |= Rm << 3;
	      }
	    else
	      {
		inst.instruction = T_OPCODE_CMP_HR;
		inst.instruction |= (Rn & 0x8) << 4;
		inst.instruction |= (Rn & 0x7);
		inst.instruction |= Rm << 3;
	      }
	    break;
	  }
      return;
    }

  inst.instruction = THUMB_OP16 (inst.instruction);

  /* PR 10443: Do not silently ignore shifted operands.  */
  constraint (inst.operands[1].shifted,
	      _("shifts in CMP/MOV instructions are only supported in unified syntax"));

  if (inst.operands[1].isreg)
    {
      if (Rn < 8 && Rm < 8)
	{
	  /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	     since a MOV instruction produces unpredictable results.  */
	  if (inst.instruction == T_OPCODE_MOV_I8)
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;

	  inst.instruction |= Rn;
	  inst.instruction |= Rm << 3;
	}
      else
	{
	  if (inst.instruction == T_OPCODE_MOV_I8)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else
	    inst.instruction = T_OPCODE_CMP_HR;
	  do_t_cpy ();
	}
    }
  else
    {
      constraint (Rn > 7,
		  _("only lo regs allowed with immediate"));
      inst.instruction |= Rn << 8;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
    }
}

static void
do_t_mov16 (void)
{
  unsigned Rd;
  bfd_vma imm;
  bfd_boolean top;

  top = (inst.instruction & 0x00800000) != 0;
  if (inst.reloc.type == BFD_RELOC_ARM_MOVW)
    {
      constraint (top, _(":lower16: not allowed this instruction"));
      inst.reloc.type = BFD_RELOC_ARM_THUMB_MOVW;
    }
  else if (inst.reloc.type == BFD_RELOC_ARM_MOVT)
    {
      constraint (!top, _(":upper16: not allowed this instruction"));
      inst.reloc.type = BFD_RELOC_ARM_THUMB_MOVT;
    }

  Rd = inst.operands[0].reg;
  reject_bad_reg (Rd);

  inst.instruction |= Rd << 8;
  if (inst.reloc.type == BFD_RELOC_UNUSED)
    {
      imm = inst.reloc.exp.X_add_number;
      inst.instruction |= (imm & 0xf000) << 4;
      inst.instruction |= (imm & 0x0800) << 15;
      inst.instruction |= (imm & 0x0700) << 4;
      inst.instruction |= (imm & 0x00ff);
    }
}

static void
do_t_mvn_tst (void)
{
  unsigned Rn, Rm;

  Rn = inst.operands[0].reg;
  Rm = inst.operands[1].reg;

  if (inst.instruction == T_MNEM_cmp
      || inst.instruction == T_MNEM_cmn)
    constraint (Rn == REG_PC, BAD_PC);
  else
    reject_bad_reg (Rn);
  reject_bad_reg (Rm);

  if (unified_syntax)
    {
      int r0off = (inst.instruction == T_MNEM_mvn
		   || inst.instruction == T_MNEM_mvns) ? 8 : 16;
      bfd_boolean narrow;

      if (inst.size_req == 4
	  || inst.instruction > 0xffff
	  || inst.operands[1].shifted
	  || Rn > 7 || Rm > 7)
	narrow = FALSE;
      else if (inst.instruction == T_MNEM_cmn
	       || inst.instruction == T_MNEM_tst)
	narrow = TRUE;
      else if (THUMB_SETS_FLAGS (inst.instruction))
	narrow = !in_it_block ();
      else
	narrow = in_it_block ();

      if (!inst.operands[1].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  if (inst.instruction < 0xffff)
	    inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rn << r0off;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  /* See if we can do this with a 16-bit instruction.  */
	  if (narrow)
	    {
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= Rn;
	      inst.instruction |= Rm << 3;
	    }
	  else
	    {
	      constraint (inst.operands[1].shifted
			  && inst.operands[1].immisreg,
			  _("shift must be constant"));
	      if (inst.instruction < 0xffff)
		inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= Rn << r0off;
	      encode_thumb32_shifted_operand (1);
	    }
	}
    }
  else
    {
      constraint (inst.instruction > 0xffff
		  || inst.instruction == T_MNEM_mvns, BAD_THUMB32);
      constraint (!inst.operands[1].isreg || inst.operands[1].shifted,
		  _("unshifted register required"));
      constraint (Rn > 7 || Rm > 7,
		  BAD_HIREG);

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rn;
      inst.instruction |= Rm << 3;
    }
}

static void
do_t_mrs (void)
{
  unsigned Rd;

  if (do_vfp_nsyn_mrs () == SUCCESS)
    return;

  Rd = inst.operands[0].reg;
  reject_bad_reg (Rd);
  inst.instruction |= Rd << 8;

  if (inst.operands[1].isreg)
    {
      unsigned br = inst.operands[1].reg;
      if (((br & 0x200) == 0) && ((br & 0xf000) != 0xf000))
	as_bad (_("bad register for mrs"));

      inst.instruction |= br & (0xf << 16);
      inst.instruction |= (br & 0x300) >> 4;
      inst.instruction |= (br & SPSR_BIT) >> 2;
    }
  else
    {
      int flags = inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f|SPSR_BIT);

      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_m))
	{
	  /* PR gas/12698:  The constraint is only applied for m_profile.
	     If the user has specified -march=all, we want to ignore it as
	     we are building for any CPU type, including non-m variants.  */
	  bfd_boolean m_profile = selected_cpu.core != arm_arch_any.core;
	  constraint ((flags != 0) && m_profile, _("selected processor does "
						   "not support requested special purpose register"));
	}
      else
	/* mrs only accepts APSR/CPSR/SPSR/CPSR_all/SPSR_all (for non-M profile
	   devices).  */
	constraint ((flags & ~SPSR_BIT) != (PSR_c|PSR_f),
		    _("'APSR', 'CPSR' or 'SPSR' expected"));

      inst.instruction |= (flags & SPSR_BIT) >> 2;
      inst.instruction |= inst.operands[1].imm & 0xff;
      inst.instruction |= 0xf0000;
    }
}

static void
do_t_msr (void)
{
  int flags;
  unsigned Rn;

  if (do_vfp_nsyn_msr () == SUCCESS)
    return;

  constraint (!inst.operands[1].isreg,
	      _("Thumb encoding does not support an immediate here"));

  if (inst.operands[0].isreg)
    flags = (int)(inst.operands[0].reg);
  else
    flags = inst.operands[0].imm;

  if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_m))
    {
      int bits = inst.operands[0].imm & (PSR_c|PSR_x|PSR_s|PSR_f|SPSR_BIT);

      /* PR gas/12698:  The constraint is only applied for m_profile.
	 If the user has specified -march=all, we want to ignore it as
	 we are building for any CPU type, including non-m variants.  */
      bfd_boolean m_profile = selected_cpu.core != arm_arch_any.core;
      constraint (((ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp)
	   && (bits & ~(PSR_s | PSR_f)) != 0)
	  || (!ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp)
	      && bits != PSR_f)) && m_profile,
	  _("selected processor does not support requested special "
	    "purpose register"));
    }
  else
     constraint ((flags & 0xff) != 0, _("selected processor does not support "
		 "requested special purpose register"));

  Rn = inst.operands[1].reg;
  reject_bad_reg (Rn);

  inst.instruction |= (flags & SPSR_BIT) >> 2;
  inst.instruction |= (flags & 0xf0000) >> 8;
  inst.instruction |= (flags & 0x300) >> 4;
  inst.instruction |= (flags & 0xff);
  inst.instruction |= Rn << 16;
}

static void
do_t_mul (void)
{
  bfd_boolean narrow;
  unsigned Rd, Rn, Rm;

  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[0].reg;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[1].reg;
  Rm = inst.operands[2].reg;

  if (unified_syntax)
    {
      if (inst.size_req == 4
	  || (Rd != Rn
	      && Rd != Rm)
	  || Rn > 7
	  || Rm > 7)
	narrow = FALSE;
      else if (inst.instruction == T_MNEM_muls)
	narrow = !in_it_block ();
      else
	narrow = in_it_block ();
    }
  else
    {
      constraint (inst.instruction == T_MNEM_muls, BAD_THUMB32);
      constraint (Rn > 7 || Rm > 7,
		  BAD_HIREG);
      narrow = TRUE;
    }

  if (narrow)
    {
      /* 16-bit MULS/Conditional MUL.  */
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;

      if (Rd == Rn)
	inst.instruction |= Rm << 3;
      else if (Rd == Rm)
	inst.instruction |= Rn << 3;
      else
	constraint (1, _("dest must overlap one source register"));
    }
  else
    {
      constraint (inst.instruction != T_MNEM_mul,
		  _("Thumb-2 MUL must not set flags"));
      /* 32-bit MUL.  */
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= Rd << 8;
      inst.instruction |= Rn << 16;
      inst.instruction |= Rm << 0;

      reject_bad_reg (Rd);
      reject_bad_reg (Rn);
      reject_bad_reg (Rm);
    }
}

static void
do_t_mull (void)
{
  unsigned RdLo, RdHi, Rn, Rm;

  RdLo = inst.operands[0].reg;
  RdHi = inst.operands[1].reg;
  Rn = inst.operands[2].reg;
  Rm = inst.operands[3].reg;

  reject_bad_reg (RdLo);
  reject_bad_reg (RdHi);
  reject_bad_reg (Rn);
  reject_bad_reg (Rm);

  inst.instruction |= RdLo << 12;
  inst.instruction |= RdHi << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= Rm;

 if (RdLo == RdHi)
    as_tsktsk (_("rdhi and rdlo must be different"));
}

static void
do_t_nop (void)
{
  set_it_insn_type (NEUTRAL_IT_INSN);

  if (unified_syntax)
    {
      if (inst.size_req == 4 || inst.operands[0].imm > 15)
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].imm;
	}
      else
	{
	  /* PR9722: Check for Thumb2 availability before
	     generating a thumb2 nop instruction.  */
	  if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6t2))
	    {
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= inst.operands[0].imm << 4;
	    }
	  else
	    inst.instruction = 0x46c0;
	}
    }
  else
    {
      constraint (inst.operands[0].present,
		  _("Thumb does not support NOP with hints"));
      inst.instruction = 0x46c0;
    }
}

static void
do_t_neg (void)
{
  if (unified_syntax)
    {
      bfd_boolean narrow;

      if (THUMB_SETS_FLAGS (inst.instruction))
	narrow = !in_it_block ();
      else
	narrow = in_it_block ();
      if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)
	narrow = FALSE;
      if (inst.size_req == 4)
	narrow = FALSE;

      if (!narrow)
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].reg << 16;
	}
      else
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
	}
    }
  else
    {
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
}

static void
do_t_orn (void)
{
  unsigned Rd, Rn;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[1].present ? inst.operands[1].reg : Rd;

  reject_bad_reg (Rd);
  /* Rn == REG_SP is unpredictable; Rn == REG_PC is MVN.  */
  reject_bad_reg (Rn);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;

  if (!inst.operands[2].isreg)
    {
      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
    }
  else
    {
      unsigned Rm;

      Rm = inst.operands[2].reg;
      reject_bad_reg (Rm);

      constraint (inst.operands[2].shifted
		  && inst.operands[2].immisreg,
		  _("shift must be constant"));
      encode_thumb32_shifted_operand (2);
    }
}

static void
do_t_pkhbt (void)
{
  unsigned Rd, Rn, Rm;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[1].reg;
  Rm = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);
  reject_bad_reg (Rm);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= Rm;
  if (inst.operands[3].present)
    {
      unsigned int val = inst.reloc.exp.X_add_number;
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
      inst.instruction |= (val & 0x1c) << 10;
      inst.instruction |= (val & 0x03) << 6;
    }
}

static void
do_t_pkhtb (void)
{
  if (!inst.operands[3].present)
    {
      unsigned Rtmp;

      inst.instruction &= ~0x00000020;

      /* PR 10168.  Swap the Rm and Rn registers.  */
      Rtmp = inst.operands[1].reg;
      inst.operands[1].reg = inst.operands[2].reg;
      inst.operands[2].reg = Rtmp;
    }
  do_t_pkhbt ();
}

static void
do_t_pld (void)
{
  if (inst.operands[0].immisreg)
    reject_bad_reg (inst.operands[0].imm);

  encode_thumb32_addr_mode (0, /*is_t=*/FALSE, /*is_d=*/FALSE);
}

static void
do_t_push_pop (void)
{
  unsigned mask;

  constraint (inst.operands[0].writeback,
	      _("push/pop do not support {reglist}^"));
  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
	      _("expression too complex"));

  mask = inst.operands[0].imm;
  if (inst.size_req != 4 && (mask & ~0xff) == 0)
    inst.instruction = THUMB_OP16 (inst.instruction) | mask;
  else if (inst.size_req != 4
	   && (mask & ~0xff) == (1 << (inst.instruction == T_MNEM_push
				       ? REG_LR : REG_PC)))
    {
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= THUMB_PP_PC_LR;
      inst.instruction |= mask & 0xff;
    }
  else if (unified_syntax)
    {
      inst.instruction = THUMB_OP32 (inst.instruction);
      encode_thumb2_ldmstm (13, mask, TRUE);
    }
  else
    {
      inst.error = _("invalid register list to push/pop instruction");
      return;
    }
}

static void
do_t_rbit (void)
{
  unsigned Rd, Rm;

  Rd = inst.operands[0].reg;
  Rm = inst.operands[1].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rm);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rm << 16;
  inst.instruction |= Rm;
}

static void
do_t_rev (void)
{
  unsigned Rd, Rm;

  Rd = inst.operands[0].reg;
  Rm = inst.operands[1].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rm);

  if (Rd <= 7 && Rm <= 7
      && inst.size_req != 4)
    {
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;
      inst.instruction |= Rm << 3;
    }
  else if (unified_syntax)
    {
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= Rd << 8;
      inst.instruction |= Rm << 16;
      inst.instruction |= Rm;
    }
  else
    inst.error = BAD_HIREG;
}

static void
do_t_rrx (void)
{
  unsigned Rd, Rm;

  Rd = inst.operands[0].reg;
  Rm = inst.operands[1].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rm);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rm;
}

static void
do_t_rsb (void)
{
  unsigned Rd, Rs;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */

  reject_bad_reg (Rd);
  reject_bad_reg (Rs);
  if (inst.operands[2].isreg)
    reject_bad_reg (inst.operands[2].reg);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rs << 16;
  if (!inst.operands[2].isreg)
    {
      bfd_boolean narrow;

      if ((inst.instruction & 0x00100000) != 0)
	narrow = !in_it_block ();
      else
	narrow = in_it_block ();

      if (Rd > 7 || Rs > 7)
	narrow = FALSE;

      if (inst.size_req == 4 || !unified_syntax)
	narrow = FALSE;

      if (inst.reloc.exp.X_op != O_constant
	  || inst.reloc.exp.X_add_number != 0)
	narrow = FALSE;

      /* Turn rsb #0 into 16-bit neg.  We should probably do this via
	 relaxation, but it doesn't seem worth the hassle.  */
      if (narrow)
	{
	  inst.reloc.type = BFD_RELOC_UNUSED;
	  inst.instruction = THUMB_OP16 (T_MNEM_negs);
	  inst.instruction |= Rs << 3;
	  inst.instruction |= Rd;
	}
      else
	{
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
    }
  else
    encode_thumb32_shifted_operand (2);
}

static void
do_t_setend (void)
{
  if (warn_on_deprecated
      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
      as_warn (_("setend use is deprecated for ARMv8"));

  set_it_insn_type (OUTSIDE_IT_INSN);
  if (inst.operands[0].imm)
    inst.instruction |= 0x8;
}

static void
do_t_shift (void)
{
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;

  if (unified_syntax)
    {
      bfd_boolean narrow;
      int shift_kind;

      switch (inst.instruction)
	{
	case T_MNEM_asr:
	case T_MNEM_asrs: shift_kind = SHIFT_ASR; break;
	case T_MNEM_lsl:
	case T_MNEM_lsls: shift_kind = SHIFT_LSL; break;
	case T_MNEM_lsr:
	case T_MNEM_lsrs: shift_kind = SHIFT_LSR; break;
	case T_MNEM_ror:
	case T_MNEM_rors: shift_kind = SHIFT_ROR; break;
	default: abort ();
	}

      if (THUMB_SETS_FLAGS (inst.instruction))
	narrow = !in_it_block ();
      else
	narrow = in_it_block ();
      if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)
	narrow = FALSE;
      if (!inst.operands[2].isreg && shift_kind == SHIFT_ROR)
	narrow = FALSE;
      if (inst.operands[2].isreg
	  && (inst.operands[1].reg != inst.operands[0].reg
	      || inst.operands[2].reg > 7))
	narrow = FALSE;
      if (inst.size_req == 4)
	narrow = FALSE;

      reject_bad_reg (inst.operands[0].reg);
      reject_bad_reg (inst.operands[1].reg);

      if (!narrow)
	{
	  if (inst.operands[2].isreg)
	    {
	      reject_bad_reg (inst.operands[2].reg);
	      inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg << 8;
	      inst.instruction |= inst.operands[1].reg << 16;
	      inst.instruction |= inst.operands[2].reg;

	      /* PR 12854: Error on extraneous shifts.  */
	      constraint (inst.operands[2].shifted,
			  _("extraneous shift as part of operand to shift insn"));
	    }
	  else
	    {
	      inst.operands[1].shifted = 1;
	      inst.operands[1].shift_kind = shift_kind;
	      inst.instruction = THUMB_OP32 (THUMB_SETS_FLAGS (inst.instruction)
					     ? T_MNEM_movs : T_MNEM_mov);
	      inst.instruction |= inst.operands[0].reg << 8;
	      encode_thumb32_shifted_operand (1);
	      /* Prevent the incorrect generation of an ARM_IMMEDIATE fixup.  */
	      inst.reloc.type = BFD_RELOC_UNUSED;
	    }
	}
      else
	{
	  if (inst.operands[2].isreg)
	    {
	      switch (shift_kind)
		{
		case SHIFT_ASR: inst.instruction = T_OPCODE_ASR_R; break;
		case SHIFT_LSL: inst.instruction = T_OPCODE_LSL_R; break;
		case SHIFT_LSR: inst.instruction = T_OPCODE_LSR_R; break;
		case SHIFT_ROR: inst.instruction = T_OPCODE_ROR_R; break;
		default: abort ();
		}

	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[2].reg << 3;

	      /* PR 12854: Error on extraneous shifts.  */
	      constraint (inst.operands[2].shifted,
			  _("extraneous shift as part of operand to shift insn"));
	    }
	  else
	    {
	      switch (shift_kind)
		{
		case SHIFT_ASR: inst.instruction = T_OPCODE_ASR_I; break;
		case SHIFT_LSL: inst.instruction = T_OPCODE_LSL_I; break;
		case SHIFT_LSR: inst.instruction = T_OPCODE_LSR_I; break;
		default: abort ();
		}
	      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
	    }
	}
    }
  else
    {
      constraint (inst.operands[0].reg > 7
		  || inst.operands[1].reg > 7, BAD_HIREG);
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);

      if (inst.operands[2].isreg)  /* Rd, {Rs,} Rn */
	{
	  constraint (inst.operands[2].reg > 7, BAD_HIREG);
	  constraint (inst.operands[0].reg != inst.operands[1].reg,
		      _("source1 and dest must be same register"));

	  switch (inst.instruction)
	    {
	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_R; break;
	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_R; break;
	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_R; break;
	    case T_MNEM_ror: inst.instruction = T_OPCODE_ROR_R; break;
	    default: abort ();
	    }

	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[2].reg << 3;

	  /* PR 12854: Error on extraneous shifts.  */
	  constraint (inst.operands[2].shifted,
		      _("extraneous shift as part of operand to shift insn"));
	}
      else
	{
	  switch (inst.instruction)
	    {
	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_I; break;
	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_I; break;
	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_I; break;
	    case T_MNEM_ror: inst.error = _("ror #imm not supported"); return;
	    default: abort ();
	    }
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
	}
    }
}

static void
do_t_simd (void)
{
  unsigned Rd, Rn, Rm;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[1].reg;
  Rm = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);
  reject_bad_reg (Rm);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= Rm;
}

static void
do_t_simd2 (void)
{
  unsigned Rd, Rn, Rm;

  Rd = inst.operands[0].reg;
  Rm = inst.operands[1].reg;
  Rn = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);
  reject_bad_reg (Rm);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= Rm;
}

static void
do_t_smc (void)
{
  unsigned int value = inst.reloc.exp.X_add_number;
  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7a),
	      _("SMC is not permitted on this architecture"));
  constraint (inst.reloc.exp.X_op != O_constant,
	      _("expression too complex"));
  inst.reloc.type = BFD_RELOC_UNUSED;
  inst.instruction |= (value & 0xf000) >> 12;
  inst.instruction |= (value & 0x0ff0);
  inst.instruction |= (value & 0x000f) << 16;
  /* PR gas/15623: SMC instructions must be last in an IT block.  */
  set_it_insn_type_last ();
}

static void
do_t_hvc (void)
{
  unsigned int value = inst.reloc.exp.X_add_number;

  inst.reloc.type = BFD_RELOC_UNUSED;
  inst.instruction |= (value & 0x0fff);
  inst.instruction |= (value & 0xf000) << 4;
}

static void
do_t_ssat_usat (int bias)
{
  unsigned Rd, Rn;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);

  inst.instruction |= Rd << 8;
  inst.instruction |= inst.operands[1].imm - bias;
  inst.instruction |= Rn << 16;

  if (inst.operands[3].present)
    {
      offsetT shift_amount = inst.reloc.exp.X_add_number;

      inst.reloc.type = BFD_RELOC_UNUSED;

      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));

      if (shift_amount != 0)
	{
	  constraint (shift_amount > 31,
		      _("shift expression is too large"));

	  if (inst.operands[3].shift_kind == SHIFT_ASR)
	    inst.instruction |= 0x00200000;  /* sh bit.  */

	  inst.instruction |= (shift_amount & 0x1c) << 10;
	  inst.instruction |= (shift_amount & 0x03) << 6;
	}
    }
}

static void
do_t_ssat (void)
{
  do_t_ssat_usat (1);
}

static void
do_t_ssat16 (void)
{
  unsigned Rd, Rn;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);

  inst.instruction |= Rd << 8;
  inst.instruction |= inst.operands[1].imm - 1;
  inst.instruction |= Rn << 16;
}

static void
do_t_strex (void)
{
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative,
	      BAD_ADDR_MODE);

  constraint (inst.operands[2].reg == REG_PC, BAD_PC);

  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
}

static void
do_t_strexd (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[1].reg + 1;

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg
	      || inst.operands[0].reg == inst.operands[3].reg,
	      BAD_OVERLAP);

  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 16;
}

static void
do_t_sxtah (void)
{
  unsigned Rd, Rn, Rm;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[1].reg;
  Rm = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);
  reject_bad_reg (Rm);

  inst.instruction |= Rd << 8;
  inst.instruction |= Rn << 16;
  inst.instruction |= Rm;
  inst.instruction |= inst.operands[3].imm << 4;
}

static void
do_t_sxth (void)
{
  unsigned Rd, Rm;

  Rd = inst.operands[0].reg;
  Rm = inst.operands[1].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rm);

  if (inst.instruction <= 0xffff
      && inst.size_req != 4
      && Rd <= 7 && Rm <= 7
      && (!inst.operands[2].present || inst.operands[2].imm == 0))
    {
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;
      inst.instruction |= Rm << 3;
    }
  else if (unified_syntax)
    {
      if (inst.instruction <= 0xffff)
	inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= Rd << 8;
      inst.instruction |= Rm;
      inst.instruction |= inst.operands[2].imm << 4;
    }
  else
    {
      constraint (inst.operands[2].present && inst.operands[2].imm != 0,
		  _("Thumb encoding does not support rotation"));
      constraint (1, BAD_HIREG);
    }
}

static void
do_t_swi (void)
{
  /* We have to do the following check manually as ARM_EXT_OS only applies
     to ARM_EXT_V6M.  */
  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6m))
    {
      if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_os)
	  /* This only applies to the v6m howver, not later architectures.  */
	  && ! ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7))
	as_bad (_("SVC is not permitted on this architecture"));
      ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used, arm_ext_os);
    }

  inst.reloc.type = BFD_RELOC_ARM_SWI;
}

static void
do_t_tb (void)
{
  unsigned Rn, Rm;
  int half;

  half = (inst.instruction & 0x10) != 0;
  set_it_insn_type_last ();
  constraint (inst.operands[0].immisreg,
	      _("instruction requires register index"));

  Rn = inst.operands[0].reg;
  Rm = inst.operands[0].imm;

  constraint (Rn == REG_SP, BAD_SP);
  reject_bad_reg (Rm);

  constraint (!half && inst.operands[0].shifted,
	      _("instruction does not allow shifted index"));
  inst.instruction |= (Rn << 16) | Rm;
}

static void
do_t_udf (void)
{
  if (!inst.operands[0].present)
    inst.operands[0].imm = 0;

  if ((unsigned int) inst.operands[0].imm > 255 || inst.size_req == 4)
    {
      constraint (inst.size_req == 2,
                  _("immediate value out of range"));
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= (inst.operands[0].imm & 0xf000u) << 4;
      inst.instruction |= (inst.operands[0].imm & 0x0fffu) << 0;
    }
  else
    {
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].imm;
    }

  set_it_insn_type (NEUTRAL_IT_INSN);
}


static void
do_t_usat (void)
{
  do_t_ssat_usat (0);
}

static void
do_t_usat16 (void)
{
  unsigned Rd, Rn;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);

  inst.instruction |= Rd << 8;
  inst.instruction |= inst.operands[1].imm;
  inst.instruction |= Rn << 16;
}

/* Neon instruction encoder helpers.  */

/* Encodings for the different types for various Neon opcodes.  */

/* An "invalid" code for the following tables.  */
#define N_INV -1u

struct neon_tab_entry
{
  unsigned integer;
  unsigned float_or_poly;
  unsigned scalar_or_imm;
};

/* Map overloaded Neon opcodes to their respective encodings.  */
#define NEON_ENC_TAB					\
  X(vabd,	0x0000700, 0x1200d00, N_INV),		\
  X(vmax,	0x0000600, 0x0000f00, N_INV),		\
  X(vmin,	0x0000610, 0x0200f00, N_INV),		\
  X(vpadd,	0x0000b10, 0x1000d00, N_INV),		\
  X(vpmax,	0x0000a00, 0x1000f00, N_INV),		\
  X(vpmin,	0x0000a10, 0x1200f00, N_INV),		\
  X(vadd,	0x0000800, 0x0000d00, N_INV),		\
  X(vsub,	0x1000800, 0x0200d00, N_INV),		\
  X(vceq,	0x1000810, 0x0000e00, 0x1b10100),	\
  X(vcge,	0x0000310, 0x1000e00, 0x1b10080),	\
  X(vcgt,	0x0000300, 0x1200e00, 0x1b10000),	\
  /* Register variants of the following two instructions are encoded as
     vcge / vcgt with the operands reversed.  */  	\
  X(vclt,	0x0000300, 0x1200e00, 0x1b10200),	\
  X(vcle,	0x0000310, 0x1000e00, 0x1b10180),	\
  X(vfma,	N_INV, 0x0000c10, N_INV),		\
  X(vfms,	N_INV, 0x0200c10, N_INV),		\
  X(vmla,	0x0000900, 0x0000d10, 0x0800040),	\
  X(vmls,	0x1000900, 0x0200d10, 0x0800440),	\
  X(vmul,	0x0000910, 0x1000d10, 0x0800840),	\
  X(vmull,	0x0800c00, 0x0800e00, 0x0800a40), /* polynomial not float.  */ \
  X(vmlal,	0x0800800, N_INV,     0x0800240),	\
  X(vmlsl,	0x0800a00, N_INV,     0x0800640),	\
  X(vqdmlal,	0x0800900, N_INV,     0x0800340),	\
  X(vqdmlsl,	0x0800b00, N_INV,     0x0800740),	\
  X(vqdmull,	0x0800d00, N_INV,     0x0800b40),	\
  X(vqdmulh,    0x0000b00, N_INV,     0x0800c40),	\
  X(vqrdmulh,   0x1000b00, N_INV,     0x0800d40),	\
  X(vshl,	0x0000400, N_INV,     0x0800510),	\
  X(vqshl,	0x0000410, N_INV,     0x0800710),	\
  X(vand,	0x0000110, N_INV,     0x0800030),	\
  X(vbic,	0x0100110, N_INV,     0x0800030),	\
  X(veor,	0x1000110, N_INV,     N_INV),		\
  X(vorn,	0x0300110, N_INV,     0x0800010),	\
  X(vorr,	0x0200110, N_INV,     0x0800010),	\
  X(vmvn,	0x1b00580, N_INV,     0x0800030),	\
  X(vshll,	0x1b20300, N_INV,     0x0800a10), /* max shift, immediate.  */ \
  X(vcvt,       0x1b30600, N_INV,     0x0800e10), /* integer, fixed-point.  */ \
  X(vdup,       0xe800b10, N_INV,     0x1b00c00), /* arm, scalar.  */ \
  X(vld1,       0x0200000, 0x0a00000, 0x0a00c00), /* interlv, lane, dup.  */ \
  X(vst1,	0x0000000, 0x0800000, N_INV),		\
  X(vld2,	0x0200100, 0x0a00100, 0x0a00d00),	\
  X(vst2,	0x0000100, 0x0800100, N_INV),		\
  X(vld3,	0x0200200, 0x0a00200, 0x0a00e00),	\
  X(vst3,	0x0000200, 0x0800200, N_INV),		\
  X(vld4,	0x0200300, 0x0a00300, 0x0a00f00),	\
  X(vst4,	0x0000300, 0x0800300, N_INV),		\
  X(vmovn,	0x1b20200, N_INV,     N_INV),		\
  X(vtrn,	0x1b20080, N_INV,     N_INV),		\
  X(vqmovn,	0x1b20200, N_INV,     N_INV),		\
  X(vqmovun,	0x1b20240, N_INV,     N_INV),		\
  X(vnmul,      0xe200a40, 0xe200b40, N_INV),		\
  X(vnmla,      0xe100a40, 0xe100b40, N_INV),		\
  X(vnmls,      0xe100a00, 0xe100b00, N_INV),		\
  X(vfnma,      0xe900a40, 0xe900b40, N_INV),		\
  X(vfnms,      0xe900a00, 0xe900b00, N_INV),		\
  X(vcmp,	0xeb40a40, 0xeb40b40, N_INV),		\
  X(vcmpz,	0xeb50a40, 0xeb50b40, N_INV),		\
  X(vcmpe,	0xeb40ac0, 0xeb40bc0, N_INV),		\
  X(vcmpez,     0xeb50ac0, 0xeb50bc0, N_INV),		\
  X(vseleq,	0xe000a00, N_INV,     N_INV),		\
  X(vselvs,	0xe100a00, N_INV,     N_INV),		\
  X(vselge,	0xe200a00, N_INV,     N_INV),		\
  X(vselgt,	0xe300a00, N_INV,     N_INV),		\
  X(vmaxnm,	0xe800a00, 0x3000f10, N_INV),		\
  X(vminnm,	0xe800a40, 0x3200f10, N_INV),		\
  X(vcvta,	0xebc0a40, 0x3bb0000, N_INV),		\
  X(vrintr,	0xeb60a40, 0x3ba0400, N_INV),		\
  X(vrinta,	0xeb80a40, 0x3ba0400, N_INV),		\
  X(aes,	0x3b00300, N_INV,     N_INV),		\
  X(sha3op,	0x2000c00, N_INV,     N_INV),		\
  X(sha1h,	0x3b902c0, N_INV,     N_INV),           \
  X(sha2op,     0x3ba0380, N_INV,     N_INV)

enum neon_opc
{
#define X(OPC,I,F,S) N_MNEM_##OPC
NEON_ENC_TAB
#undef X
};

static const struct neon_tab_entry neon_enc_tab[] =
{
#define X(OPC,I,F,S) { (I), (F), (S) }
NEON_ENC_TAB
#undef X
};

/* Do not use these macros; instead, use NEON_ENCODE defined below.  */
#define NEON_ENC_INTEGER_(X) (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_ARMREG_(X)  (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_POLY_(X)    (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_FLOAT_(X)   (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_SCALAR_(X)  (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
#define NEON_ENC_IMMED_(X)   (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
#define NEON_ENC_INTERLV_(X) (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_LANE_(X)    (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_DUP_(X)     (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
#define NEON_ENC_SINGLE_(X) \
  ((neon_enc_tab[(X) & 0x0fffffff].integer) | ((X) & 0xf0000000))
#define NEON_ENC_DOUBLE_(X) \
  ((neon_enc_tab[(X) & 0x0fffffff].float_or_poly) | ((X) & 0xf0000000))
#define NEON_ENC_FPV8_(X) \
  ((neon_enc_tab[(X) & 0x0fffffff].integer) | ((X) & 0xf000000))

#define NEON_ENCODE(type, inst)					\
  do								\
    {								\
      inst.instruction = NEON_ENC_##type##_ (inst.instruction);	\
      inst.is_neon = 1;						\
    }								\
  while (0)

#define check_neon_suffixes						\
  do									\
    {									\
      if (!inst.error && inst.vectype.elems > 0 && !inst.is_neon)	\
	{								\
	  as_bad (_("invalid neon suffix for non neon instruction"));	\
	  return;							\
	}								\
    }									\
  while (0)

/* Define shapes for instruction operands. The following mnemonic characters
   are used in this table:

     F - VFP S<n> register
     D - Neon D<n> register
     Q - Neon Q<n> register
     I - Immediate
     S - Scalar
     R - ARM register
     L - D<n> register list

   This table is used to generate various data:
     - enumerations of the form NS_DDR to be used as arguments to
       neon_select_shape.
     - a table classifying shapes into single, double, quad, mixed.
     - a table used to drive neon_select_shape.  */

#define NEON_SHAPE_DEF			\
  X(3, (D, D, D), DOUBLE),		\
  X(3, (Q, Q, Q), QUAD),		\
  X(3, (D, D, I), DOUBLE),		\
  X(3, (Q, Q, I), QUAD),		\
  X(3, (D, D, S), DOUBLE),		\
  X(3, (Q, Q, S), QUAD),		\
  X(2, (D, D), DOUBLE),			\
  X(2, (Q, Q), QUAD),			\
  X(2, (D, S), DOUBLE),			\
  X(2, (Q, S), QUAD),			\
  X(2, (D, R), DOUBLE),			\
  X(2, (Q, R), QUAD),			\
  X(2, (D, I), DOUBLE),			\
  X(2, (Q, I), QUAD),			\
  X(3, (D, L, D), DOUBLE),		\
  X(2, (D, Q), MIXED),			\
  X(2, (Q, D), MIXED),			\
  X(3, (D, Q, I), MIXED),		\
  X(3, (Q, D, I), MIXED),		\
  X(3, (Q, D, D), MIXED),		\
  X(3, (D, Q, Q), MIXED),		\
  X(3, (Q, Q, D), MIXED),		\
  X(3, (Q, D, S), MIXED),		\
  X(3, (D, Q, S), MIXED),		\
  X(4, (D, D, D, I), DOUBLE),		\
  X(4, (Q, Q, Q, I), QUAD),		\
  X(2, (F, F), SINGLE),			\
  X(3, (F, F, F), SINGLE),		\
  X(2, (F, I), SINGLE),			\
  X(2, (F, D), MIXED),			\
  X(2, (D, F), MIXED),			\
  X(3, (F, F, I), MIXED),		\
  X(4, (R, R, F, F), SINGLE),		\
  X(4, (F, F, R, R), SINGLE),		\
  X(3, (D, R, R), DOUBLE),		\
  X(3, (R, R, D), DOUBLE),		\
  X(2, (S, R), SINGLE),			\
  X(2, (R, S), SINGLE),			\
  X(2, (F, R), SINGLE),			\
  X(2, (R, F), SINGLE)

#define S2(A,B)		NS_##A##B
#define S3(A,B,C)	NS_##A##B##C
#define S4(A,B,C,D)	NS_##A##B##C##D

#define X(N, L, C) S##N L

enum neon_shape
{
  NEON_SHAPE_DEF,
  NS_NULL
};

#undef X
#undef S2
#undef S3
#undef S4

enum neon_shape_class
{
  SC_SINGLE,
  SC_DOUBLE,
  SC_QUAD,
  SC_MIXED
};

#define X(N, L, C) SC_##C

static enum neon_shape_class neon_shape_class[] =
{
  NEON_SHAPE_DEF
};

#undef X

enum neon_shape_el
{
  SE_F,
  SE_D,
  SE_Q,
  SE_I,
  SE_S,
  SE_R,
  SE_L
};

/* Register widths of above.  */
static unsigned neon_shape_el_size[] =
{
  32,
  64,
  128,
  0,
  32,
  32,
  0
};

struct neon_shape_info
{
  unsigned els;
  enum neon_shape_el el[NEON_MAX_TYPE_ELS];
};

#define S2(A,B)		{ SE_##A, SE_##B }
#define S3(A,B,C)	{ SE_##A, SE_##B, SE_##C }
#define S4(A,B,C,D)	{ SE_##A, SE_##B, SE_##C, SE_##D }

#define X(N, L, C) { N, S##N L }

static struct neon_shape_info neon_shape_tab[] =
{
  NEON_SHAPE_DEF
};

#undef X
#undef S2
#undef S3
#undef S4

/* Bit masks used in type checking given instructions.
  'N_EQK' means the type must be the same as (or based on in some way) the key
   type, which itself is marked with the 'N_KEY' bit. If the 'N_EQK' bit is
   set, various other bits can be set as well in order to modify the meaning of
   the type constraint.  */

enum neon_type_mask
{
  N_S8   = 0x0000001,
  N_S16  = 0x0000002,
  N_S32  = 0x0000004,
  N_S64  = 0x0000008,
  N_U8   = 0x0000010,
  N_U16  = 0x0000020,
  N_U32  = 0x0000040,
  N_U64  = 0x0000080,
  N_I8   = 0x0000100,
  N_I16  = 0x0000200,
  N_I32  = 0x0000400,
  N_I64  = 0x0000800,
  N_8    = 0x0001000,
  N_16   = 0x0002000,
  N_32   = 0x0004000,
  N_64   = 0x0008000,
  N_P8   = 0x0010000,
  N_P16  = 0x0020000,
  N_F16  = 0x0040000,
  N_F32  = 0x0080000,
  N_F64  = 0x0100000,
  N_P64	 = 0x0200000,
  N_KEY  = 0x1000000, /* Key element (main type specifier).  */
  N_EQK  = 0x2000000, /* Given operand has the same type & size as the key.  */
  N_VFP  = 0x4000000, /* VFP mode: operand size must match register width.  */
  N_UNT  = 0x8000000, /* Must be explicitly untyped.  */
  N_DBL  = 0x0000001, /* If N_EQK, this operand is twice the size.  */
  N_HLF  = 0x0000002, /* If N_EQK, this operand is half the size.  */
  N_SGN  = 0x0000004, /* If N_EQK, this operand is forced to be signed.  */
  N_UNS  = 0x0000008, /* If N_EQK, this operand is forced to be unsigned.  */
  N_INT  = 0x0000010, /* If N_EQK, this operand is forced to be integer.  */
  N_FLT  = 0x0000020, /* If N_EQK, this operand is forced to be float.  */
  N_SIZ  = 0x0000040, /* If N_EQK, this operand is forced to be size-only.  */
  N_UTYP = 0,
  N_MAX_NONSPECIAL = N_P64
};

#define N_ALLMODS  (N_DBL | N_HLF | N_SGN | N_UNS | N_INT | N_FLT | N_SIZ)

#define N_SU_ALL   (N_S8 | N_S16 | N_S32 | N_S64 | N_U8 | N_U16 | N_U32 | N_U64)
#define N_SU_32    (N_S8 | N_S16 | N_S32 | N_U8 | N_U16 | N_U32)
#define N_SU_16_64 (N_S16 | N_S32 | N_S64 | N_U16 | N_U32 | N_U64)
#define N_SUF_32   (N_SU_32 | N_F32)
#define N_I_ALL    (N_I8 | N_I16 | N_I32 | N_I64)
#define N_IF_32    (N_I8 | N_I16 | N_I32 | N_F32)

/* Pass this as the first type argument to neon_check_type to ignore types
   altogether.  */
#define N_IGNORE_TYPE (N_KEY | N_EQK)

/* Select a "shape" for the current instruction (describing register types or
   sizes) from a list of alternatives. Return NS_NULL if the current instruction
   doesn't fit. For non-polymorphic shapes, checking is usually done as a
   function of operand parsing, so this function doesn't need to be called.
   Shapes should be listed in order of decreasing length.  */

static enum neon_shape
neon_select_shape (enum neon_shape shape, ...)
{
  va_list ap;
  enum neon_shape first_shape = shape;

  /* Fix missing optional operands. FIXME: we don't know at this point how
     many arguments we should have, so this makes the assumption that we have
     > 1. This is true of all current Neon opcodes, I think, but may not be
     true in the future.  */
  if (!inst.operands[1].present)
    inst.operands[1] = inst.operands[0];

  va_start (ap, shape);

  for (; shape != NS_NULL; shape = (enum neon_shape) va_arg (ap, int))
    {
      unsigned j;
      int matches = 1;

      for (j = 0; j < neon_shape_tab[shape].els; j++)
	{
	  if (!inst.operands[j].present)
	    {
	      matches = 0;
	      break;
	    }

	  switch (neon_shape_tab[shape].el[j])
	    {
	    case SE_F:
	      if (!(inst.operands[j].isreg
		    && inst.operands[j].isvec
		    && inst.operands[j].issingle
		    && !inst.operands[j].isquad))
		matches = 0;
	      break;

	    case SE_D:
	      if (!(inst.operands[j].isreg
		    && inst.operands[j].isvec
		    && !inst.operands[j].isquad
		    && !inst.operands[j].issingle))
		matches = 0;
	      break;

	    case SE_R:
	      if (!(inst.operands[j].isreg
		    && !inst.operands[j].isvec))
		matches = 0;
	      break;

	    case SE_Q:
	      if (!(inst.operands[j].isreg
		    && inst.operands[j].isvec
		    && inst.operands[j].isquad
		    && !inst.operands[j].issingle))
		matches = 0;
	      break;

	    case SE_I:
	      if (!(!inst.operands[j].isreg
		    && !inst.operands[j].isscalar))
		matches = 0;
	      break;

	    case SE_S:
	      if (!(!inst.operands[j].isreg
		    && inst.operands[j].isscalar))
		matches = 0;
	      break;

	    case SE_L:
	      break;
	    }
	  if (!matches)
	    break;
	}
      if (matches && (j >= ARM_IT_MAX_OPERANDS || !inst.operands[j].present))
	/* We've matched all the entries in the shape table, and we don't
	   have any left over operands which have not been matched.  */
	break;
    }

  va_end (ap);

  if (shape == NS_NULL && first_shape != NS_NULL)
    first_error (_("invalid instruction shape"));

  return shape;
}

/* True if SHAPE is predominantly a quadword operation (most of the time, this
   means the Q bit should be set).  */

static int
neon_quad (enum neon_shape shape)
{
  return neon_shape_class[shape] == SC_QUAD;
}

static void
neon_modify_type_size (unsigned typebits, enum neon_el_type *g_type,
		       unsigned *g_size)
{
  /* Allow modification to be made to types which are constrained to be
     based on the key element, based on bits set alongside N_EQK.  */
  if ((typebits & N_EQK) != 0)
    {
      if ((typebits & N_HLF) != 0)
	*g_size /= 2;
      else if ((typebits & N_DBL) != 0)
	*g_size *= 2;
      if ((typebits & N_SGN) != 0)
	*g_type = NT_signed;
      else if ((typebits & N_UNS) != 0)
	*g_type = NT_unsigned;
      else if ((typebits & N_INT) != 0)
	*g_type = NT_integer;
      else if ((typebits & N_FLT) != 0)
	*g_type = NT_float;
      else if ((typebits & N_SIZ) != 0)
	*g_type = NT_untyped;
    }
}

/* Return operand OPNO promoted by bits set in THISARG. KEY should be the "key"
   operand type, i.e. the single type specified in a Neon instruction when it
   is the only one given.  */

static struct neon_type_el
neon_type_promote (struct neon_type_el *key, unsigned thisarg)
{
  struct neon_type_el dest = *key;

  gas_assert ((thisarg & N_EQK) != 0);

  neon_modify_type_size (thisarg, &dest.type, &dest.size);

  return dest;
}

/* Convert Neon type and size into compact bitmask representation.  */

static enum neon_type_mask
type_chk_of_el_type (enum neon_el_type type, unsigned size)
{
  switch (type)
    {
    case NT_untyped:
      switch (size)
	{
	case 8:  return N_8;
	case 16: return N_16;
	case 32: return N_32;
	case 64: return N_64;
	default: ;
	}
      break;

    case NT_integer:
      switch (size)
	{
	case 8:  return N_I8;
	case 16: return N_I16;
	case 32: return N_I32;
	case 64: return N_I64;
	default: ;
	}
      break;

    case NT_float:
      switch (size)
	{
	case 16: return N_F16;
	case 32: return N_F32;
	case 64: return N_F64;
	default: ;
	}
      break;

    case NT_poly:
      switch (size)
	{
	case 8:  return N_P8;
	case 16: return N_P16;
	case 64: return N_P64;
	default: ;
	}
      break;

    case NT_signed:
      switch (size)
	{
	case 8:  return N_S8;
	case 16: return N_S16;
	case 32: return N_S32;
	case 64: return N_S64;
	default: ;
	}
      break;

    case NT_unsigned:
      switch (size)
	{
	case 8:  return N_U8;
	case 16: return N_U16;
	case 32: return N_U32;
	case 64: return N_U64;
	default: ;
	}
      break;

    default: ;
    }

  return N_UTYP;
}

/* Convert compact Neon bitmask type representation to a type and size. Only
   handles the case where a single bit is set in the mask.  */

static int
el_type_of_type_chk (enum neon_el_type *type, unsigned *size,
		     enum neon_type_mask mask)
{
  if ((mask & N_EQK) != 0)
    return FAIL;

  if ((mask & (N_S8 | N_U8 | N_I8 | N_8 | N_P8)) != 0)
    *size = 8;
  else if ((mask & (N_S16 | N_U16 | N_I16 | N_16 | N_F16 | N_P16)) != 0)
    *size = 16;
  else if ((mask & (N_S32 | N_U32 | N_I32 | N_32 | N_F32)) != 0)
    *size = 32;
  else if ((mask & (N_S64 | N_U64 | N_I64 | N_64 | N_F64 | N_P64)) != 0)
    *size = 64;
  else
    return FAIL;

  if ((mask & (N_S8 | N_S16 | N_S32 | N_S64)) != 0)
    *type = NT_signed;
  else if ((mask & (N_U8 | N_U16 | N_U32 | N_U64)) != 0)
    *type = NT_unsigned;
  else if ((mask & (N_I8 | N_I16 | N_I32 | N_I64)) != 0)
    *type = NT_integer;
  else if ((mask & (N_8 | N_16 | N_32 | N_64)) != 0)
    *type = NT_untyped;
  else if ((mask & (N_P8 | N_P16 | N_P64)) != 0)
    *type = NT_poly;
  else if ((mask & (N_F16 | N_F32 | N_F64)) != 0)
    *type = NT_float;
  else
    return FAIL;

  return SUCCESS;
}

/* Modify a bitmask of allowed types. This is only needed for type
   relaxation.  */

static unsigned
modify_types_allowed (unsigned allowed, unsigned mods)
{
  unsigned size;
  enum neon_el_type type;
  unsigned destmask;
  int i;

  destmask = 0;

  for (i = 1; i <= N_MAX_NONSPECIAL; i <<= 1)
    {
      if (el_type_of_type_chk (&type, &size,
			       (enum neon_type_mask) (allowed & i)) == SUCCESS)
	{
	  neon_modify_type_size (mods, &type, &size);
	  destmask |= type_chk_of_el_type (type, size);
	}
    }

  return destmask;
}

/* Check type and return type classification.
   The manual states (paraphrase): If one datatype is given, it indicates the
   type given in:
    - the second operand, if there is one
    - the operand, if there is no second operand
    - the result, if there are no operands.
   This isn't quite good enough though, so we use a concept of a "key" datatype
   which is set on a per-instruction basis, which is the one which matters when
   only one data type is written.
   Note: this function has side-effects (e.g. filling in missing operands). All
   Neon instructions should call it before performing bit encoding.  */

static struct neon_type_el
neon_check_type (unsigned els, enum neon_shape ns, ...)
{
  va_list ap;
  unsigned i, pass, key_el = 0;
  unsigned types[NEON_MAX_TYPE_ELS];
  enum neon_el_type k_type = NT_invtype;
  unsigned k_size = -1u;
  struct neon_type_el badtype = {NT_invtype, -1};
  unsigned key_allowed = 0;

  /* Optional registers in Neon instructions are always (not) in operand 1.
     Fill in the missing operand here, if it was omitted.  */
  if (els > 1 && !inst.operands[1].present)
    inst.operands[1] = inst.operands[0];

  /* Suck up all the varargs.  */
  va_start (ap, ns);
  for (i = 0; i < els; i++)
    {
      unsigned thisarg = va_arg (ap, unsigned);
      if (thisarg == N_IGNORE_TYPE)
	{
	  va_end (ap);
	  return badtype;
	}
      types[i] = thisarg;
      if ((thisarg & N_KEY) != 0)
	key_el = i;
    }
  va_end (ap);

  if (inst.vectype.elems > 0)
    for (i = 0; i < els; i++)
      if (inst.operands[i].vectype.type != NT_invtype)
	{
	  first_error (_("types specified in both the mnemonic and operands"));
	  return badtype;
	}

  /* Duplicate inst.vectype elements here as necessary.
     FIXME: No idea if this is exactly the same as the ARM assembler,
     particularly when an insn takes one register and one non-register
     operand. */
  if (inst.vectype.elems == 1 && els > 1)
    {
      unsigned j;
      inst.vectype.elems = els;
      inst.vectype.el[key_el] = inst.vectype.el[0];
      for (j = 0; j < els; j++)
	if (j != key_el)
	  inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
						  types[j]);
    }
  else if (inst.vectype.elems == 0 && els > 0)
    {
      unsigned j;
      /* No types were given after the mnemonic, so look for types specified
	 after each operand. We allow some flexibility here; as long as the
	 "key" operand has a type, we can infer the others.  */
      for (j = 0; j < els; j++)
	if (inst.operands[j].vectype.type != NT_invtype)
	  inst.vectype.el[j] = inst.operands[j].vectype;

      if (inst.operands[key_el].vectype.type != NT_invtype)
	{
	  for (j = 0; j < els; j++)
	    if (inst.operands[j].vectype.type == NT_invtype)
	      inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
						      types[j]);
	}
      else
	{
	  first_error (_("operand types can't be inferred"));
	  return badtype;
	}
    }
  else if (inst.vectype.elems != els)
    {
      first_error (_("type specifier has the wrong number of parts"));
      return badtype;
    }

  for (pass = 0; pass < 2; pass++)
    {
      for (i = 0; i < els; i++)
	{
	  unsigned thisarg = types[i];
	  unsigned types_allowed = ((thisarg & N_EQK) != 0 && pass != 0)
	    ? modify_types_allowed (key_allowed, thisarg) : thisarg;
	  enum neon_el_type g_type = inst.vectype.el[i].type;
	  unsigned g_size = inst.vectype.el[i].size;

	  /* Decay more-specific signed & unsigned types to sign-insensitive
	     integer types if sign-specific variants are unavailable.  */
	  if ((g_type == NT_signed || g_type == NT_unsigned)
	      && (types_allowed & N_SU_ALL) == 0)
	    g_type = NT_integer;

	  /* If only untyped args are allowed, decay any more specific types to
	     them. Some instructions only care about signs for some element
	     sizes, so handle that properly.  */
	  if (((types_allowed & N_UNT) == 0)
	      && ((g_size == 8 && (types_allowed & N_8) != 0)
		  || (g_size == 16 && (types_allowed & N_16) != 0)
		  || (g_size == 32 && (types_allowed & N_32) != 0)
		  || (g_size == 64 && (types_allowed & N_64) != 0)))
	    g_type = NT_untyped;

	  if (pass == 0)
	    {
	      if ((thisarg & N_KEY) != 0)
		{
		  k_type = g_type;
		  k_size = g_size;
		  key_allowed = thisarg & ~N_KEY;
		}
	    }
	  else
	    {
	      if ((thisarg & N_VFP) != 0)
		{
		  enum neon_shape_el regshape;
		  unsigned regwidth, match;

		  /* PR 11136: Catch the case where we are passed a shape of NS_NULL.  */
		  if (ns == NS_NULL)
		    {
		      first_error (_("invalid instruction shape"));
		      return badtype;
		    }
		  regshape = neon_shape_tab[ns].el[i];
		  regwidth = neon_shape_el_size[regshape];

		  /* In VFP mode, operands must match register widths. If we
		     have a key operand, use its width, else use the width of
		     the current operand.  */
		  if (k_size != -1u)
		    match = k_size;
		  else
		    match = g_size;

		  if (regwidth != match)
		    {
		      first_error (_("operand size must match register width"));
		      return badtype;
		    }
		}

	      if ((thisarg & N_EQK) == 0)
		{
		  unsigned given_type = type_chk_of_el_type (g_type, g_size);

		  if ((given_type & types_allowed) == 0)
		    {
		      first_error (_("bad type in Neon instruction"));
		      return badtype;
		    }
		}
	      else
		{
		  enum neon_el_type mod_k_type = k_type;
		  unsigned mod_k_size = k_size;
		  neon_modify_type_size (thisarg, &mod_k_type, &mod_k_size);
		  if (g_type != mod_k_type || g_size != mod_k_size)
		    {
		      first_error (_("inconsistent types in Neon instruction"));
		      return badtype;
		    }
		}
	    }
	}
    }

  return inst.vectype.el[key_el];
}

/* Neon-style VFP instruction forwarding.  */

/* Thumb VFP instructions have 0xE in the condition field.  */

static void
do_vfp_cond_or_thumb (void)
{
  inst.is_neon = 1;

  if (thumb_mode)
    inst.instruction |= 0xe0000000;
  else
    inst.instruction |= inst.cond << 28;
}

/* Look up and encode a simple mnemonic, for use as a helper function for the
   Neon-style VFP syntax.  This avoids duplication of bits of the insns table,
   etc.  It is assumed that operand parsing has already been done, and that the
   operands are in the form expected by the given opcode (this isn't necessarily
   the same as the form in which they were parsed, hence some massaging must
   take place before this function is called).
   Checks current arch version against that in the looked-up opcode.  */

static void
do_vfp_nsyn_opcode (const char *opname)
{
  const struct asm_opcode *opcode;

  opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, opname);

  if (!opcode)
    abort ();

  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant,
		thumb_mode ? *opcode->tvariant : *opcode->avariant),
	      _(BAD_FPU));

  inst.is_neon = 1;

  if (thumb_mode)
    {
      inst.instruction = opcode->tvalue;
      opcode->tencode ();
    }
  else
    {
      inst.instruction = (inst.cond << 28) | opcode->avalue;
      opcode->aencode ();
    }
}

static void
do_vfp_nsyn_add_sub (enum neon_shape rs)
{
  int is_add = (inst.instruction & 0x0fffffff) == N_MNEM_vadd;

  if (rs == NS_FFF)
    {
      if (is_add)
	do_vfp_nsyn_opcode ("fadds");
      else
	do_vfp_nsyn_opcode ("fsubs");
    }
  else
    {
      if (is_add)
	do_vfp_nsyn_opcode ("faddd");
      else
	do_vfp_nsyn_opcode ("fsubd");
    }
}

/* Check operand types to see if this is a VFP instruction, and if so call
   PFN ().  */

static int
try_vfp_nsyn (int args, void (*pfn) (enum neon_shape))
{
  enum neon_shape rs;
  struct neon_type_el et;

  switch (args)
    {
    case 2:
      rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
      et = neon_check_type (2, rs,
	N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
      break;

    case 3:
      rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
      et = neon_check_type (3, rs,
	N_EQK | N_VFP, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
      break;

    default:
      abort ();
    }

  if (et.type != NT_invtype)
    {
      pfn (rs);
      return SUCCESS;
    }

  inst.error = NULL;
  return FAIL;
}

static void
do_vfp_nsyn_mla_mls (enum neon_shape rs)
{
  int is_mla = (inst.instruction & 0x0fffffff) == N_MNEM_vmla;

  if (rs == NS_FFF)
    {
      if (is_mla)
	do_vfp_nsyn_opcode ("fmacs");
      else
	do_vfp_nsyn_opcode ("fnmacs");
    }
  else
    {
      if (is_mla)
	do_vfp_nsyn_opcode ("fmacd");
      else
	do_vfp_nsyn_opcode ("fnmacd");
    }
}

static void
do_vfp_nsyn_fma_fms (enum neon_shape rs)
{
  int is_fma = (inst.instruction & 0x0fffffff) == N_MNEM_vfma;

  if (rs == NS_FFF)
    {
      if (is_fma)
	do_vfp_nsyn_opcode ("ffmas");
      else
	do_vfp_nsyn_opcode ("ffnmas");
    }
  else
    {
      if (is_fma)
	do_vfp_nsyn_opcode ("ffmad");
      else
	do_vfp_nsyn_opcode ("ffnmad");
    }
}

static void
do_vfp_nsyn_mul (enum neon_shape rs)
{
  if (rs == NS_FFF)
    do_vfp_nsyn_opcode ("fmuls");
  else
    do_vfp_nsyn_opcode ("fmuld");
}

static void
do_vfp_nsyn_abs_neg (enum neon_shape rs)
{
  int is_neg = (inst.instruction & 0x80) != 0;
  neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_VFP | N_KEY);

  if (rs == NS_FF)
    {
      if (is_neg)
	do_vfp_nsyn_opcode ("fnegs");
      else
	do_vfp_nsyn_opcode ("fabss");
    }
  else
    {
      if (is_neg)
	do_vfp_nsyn_opcode ("fnegd");
      else
	do_vfp_nsyn_opcode ("fabsd");
    }
}

/* Encode single-precision (only!) VFP fldm/fstm instructions. Double precision
   insns belong to Neon, and are handled elsewhere.  */

static void
do_vfp_nsyn_ldm_stm (int is_dbmode)
{
  int is_ldm = (inst.instruction & (1 << 20)) != 0;
  if (is_ldm)
    {
      if (is_dbmode)
	do_vfp_nsyn_opcode ("fldmdbs");
      else
	do_vfp_nsyn_opcode ("fldmias");
    }
  else
    {
      if (is_dbmode)
	do_vfp_nsyn_opcode ("fstmdbs");
      else
	do_vfp_nsyn_opcode ("fstmias");
    }
}

static void
do_vfp_nsyn_sqrt (void)
{
  enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
  neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);

  if (rs == NS_FF)
    do_vfp_nsyn_opcode ("fsqrts");
  else
    do_vfp_nsyn_opcode ("fsqrtd");
}

static void
do_vfp_nsyn_div (void)
{
  enum neon_shape rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
  neon_check_type (3, rs, N_EQK | N_VFP, N_EQK | N_VFP,
    N_F32 | N_F64 | N_KEY | N_VFP);

  if (rs == NS_FFF)
    do_vfp_nsyn_opcode ("fdivs");
  else
    do_vfp_nsyn_opcode ("fdivd");
}

static void
do_vfp_nsyn_nmul (void)
{
  enum neon_shape rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
  neon_check_type (3, rs, N_EQK | N_VFP, N_EQK | N_VFP,
    N_F32 | N_F64 | N_KEY | N_VFP);

  if (rs == NS_FFF)
    {
      NEON_ENCODE (SINGLE, inst);
      do_vfp_sp_dyadic ();
    }
  else
    {
      NEON_ENCODE (DOUBLE, inst);
      do_vfp_dp_rd_rn_rm ();
    }
  do_vfp_cond_or_thumb ();
}

static void
do_vfp_nsyn_cmp (void)
{
  if (inst.operands[1].isreg)
    {
      enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
      neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);

      if (rs == NS_FF)
	{
	  NEON_ENCODE (SINGLE, inst);
	  do_vfp_sp_monadic ();
	}
      else
	{
	  NEON_ENCODE (DOUBLE, inst);
	  do_vfp_dp_rd_rm ();
	}
    }
  else
    {
      enum neon_shape rs = neon_select_shape (NS_FI, NS_DI, NS_NULL);
      neon_check_type (2, rs, N_F32 | N_F64 | N_KEY | N_VFP, N_EQK);

      switch (inst.instruction & 0x0fffffff)
	{
	case N_MNEM_vcmp:
	  inst.instruction += N_MNEM_vcmpz - N_MNEM_vcmp;
	  break;
	case N_MNEM_vcmpe:
	  inst.instruction += N_MNEM_vcmpez - N_MNEM_vcmpe;
	  break;
	default:
	  abort ();
	}

      if (rs == NS_FI)
	{
	  NEON_ENCODE (SINGLE, inst);
	  do_vfp_sp_compare_z ();
	}
      else
	{
	  NEON_ENCODE (DOUBLE, inst);
	  do_vfp_dp_rd ();
	}
    }
  do_vfp_cond_or_thumb ();
}

static void
nsyn_insert_sp (void)
{
  inst.operands[1] = inst.operands[0];
  memset (&inst.operands[0], '\0', sizeof (inst.operands[0]));
  inst.operands[0].reg = REG_SP;
  inst.operands[0].isreg = 1;
  inst.operands[0].writeback = 1;
  inst.operands[0].present = 1;
}

static void
do_vfp_nsyn_push (void)
{
  nsyn_insert_sp ();
  if (inst.operands[1].issingle)
    do_vfp_nsyn_opcode ("fstmdbs");
  else
    do_vfp_nsyn_opcode ("fstmdbd");
}

static void
do_vfp_nsyn_pop (void)
{
  nsyn_insert_sp ();
  if (inst.operands[1].issingle)
    do_vfp_nsyn_opcode ("fldmias");
  else
    do_vfp_nsyn_opcode ("fldmiad");
}

/* Fix up Neon data-processing instructions, ORing in the correct bits for
   ARM mode or Thumb mode and moving the encoded bit 24 to bit 28.  */

static void
neon_dp_fixup (struct arm_it* insn)
{
  unsigned int i = insn->instruction;
  insn->is_neon = 1;

  if (thumb_mode)
    {
      /* The U bit is at bit 24 by default. Move to bit 28 in Thumb mode.  */
      if (i & (1 << 24))
	i |= 1 << 28;

      i &= ~(1 << 24);

      i |= 0xef000000;
    }
  else
    i |= 0xf2000000;

  insn->instruction = i;
}

/* Turn a size (8, 16, 32, 64) into the respective bit number minus 3
   (0, 1, 2, 3).  */

static unsigned
neon_logbits (unsigned x)
{
  return ffs (x) - 4;
}

#define LOW4(R) ((R) & 0xf)
#define HI1(R) (((R) >> 4) & 1)

/* Encode insns with bit pattern:

  |28/24|23|22 |21 20|19 16|15 12|11    8|7|6|5|4|3  0|
  |  U  |x |D  |size | Rn  | Rd  |x x x x|N|Q|M|x| Rm |

  SIZE is passed in bits. -1 means size field isn't changed, in case it has a
  different meaning for some instruction.  */

static void
neon_three_same (int isquad, int ubit, int size)
{
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= (isquad != 0) << 6;
  inst.instruction |= (ubit != 0) << 24;
  if (size != -1)
    inst.instruction |= neon_logbits (size) << 20;

  neon_dp_fixup (&inst);
}

/* Encode instructions of the form:

  |28/24|23|22|21 20|19 18|17 16|15 12|11      7|6|5|4|3  0|
  |  U  |x |D |x  x |size |x  x | Rd  |x x x x x|Q|M|x| Rm |

  Don't write size if SIZE == -1.  */

static void
neon_two_same (int qbit, int ubit, int size)
{
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg);
  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
  inst.instruction |= (qbit != 0) << 6;
  inst.instruction |= (ubit != 0) << 24;

  if (size != -1)
    inst.instruction |= neon_logbits (size) << 18;

  neon_dp_fixup (&inst);
}

/* Neon instruction encoders, in approximate order of appearance.  */

static void
do_neon_dyadic_i_su (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_SU_32 | N_KEY);
  neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
}

static void
do_neon_dyadic_i64_su (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_SU_ALL | N_KEY);
  neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
}

static void
neon_imm_shift (int write_ubit, int uval, int isquad, struct neon_type_el et,
		unsigned immbits)
{
  unsigned size = et.size >> 3;
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg);
  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
  inst.instruction |= (isquad != 0) << 6;
  inst.instruction |= immbits << 16;
  inst.instruction |= (size >> 3) << 7;
  inst.instruction |= (size & 0x7) << 19;
  if (write_ubit)
    inst.instruction |= (uval != 0) << 24;

  neon_dp_fixup (&inst);
}

static void
do_neon_shl_imm (void)
{
  if (!inst.operands[2].isreg)
    {
      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
      struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_KEY | N_I_ALL);
      NEON_ENCODE (IMMED, inst);
      neon_imm_shift (FALSE, 0, neon_quad (rs), et, inst.operands[2].imm);
    }
  else
    {
      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
      struct neon_type_el et = neon_check_type (3, rs,
	N_EQK, N_SU_ALL | N_KEY, N_EQK | N_SGN);
      unsigned int tmp;

      /* VSHL/VQSHL 3-register variants have syntax such as:
	   vshl.xx Dd, Dm, Dn
	 whereas other 3-register operations encoded by neon_three_same have
	 syntax like:
	   vadd.xx Dd, Dn, Dm
	 (i.e. with Dn & Dm reversed). Swap operands[1].reg and operands[2].reg
	 here.  */
      tmp = inst.operands[2].reg;
      inst.operands[2].reg = inst.operands[1].reg;
      inst.operands[1].reg = tmp;
      NEON_ENCODE (INTEGER, inst);
      neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
    }
}

static void
do_neon_qshl_imm (void)
{
  if (!inst.operands[2].isreg)
    {
      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
      struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_ALL | N_KEY);

      NEON_ENCODE (IMMED, inst);
      neon_imm_shift (TRUE, et.type == NT_unsigned, neon_quad (rs), et,
		      inst.operands[2].imm);
    }
  else
    {
      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
      struct neon_type_el et = neon_check_type (3, rs,
	N_EQK, N_SU_ALL | N_KEY, N_EQK | N_SGN);
      unsigned int tmp;

      /* See note in do_neon_shl_imm.  */
      tmp = inst.operands[2].reg;
      inst.operands[2].reg = inst.operands[1].reg;
      inst.operands[1].reg = tmp;
      NEON_ENCODE (INTEGER, inst);
      neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
    }
}

static void
do_neon_rshl (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_SU_ALL | N_KEY);
  unsigned int tmp;

  tmp = inst.operands[2].reg;
  inst.operands[2].reg = inst.operands[1].reg;
  inst.operands[1].reg = tmp;
  neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
}

static int
neon_cmode_for_logic_imm (unsigned immediate, unsigned *immbits, int size)
{
  /* Handle .I8 pseudo-instructions.  */
  if (size == 8)
    {
      /* Unfortunately, this will make everything apart from zero out-of-range.
	 FIXME is this the intended semantics? There doesn't seem much point in
	 accepting .I8 if so.  */
      immediate |= immediate << 8;
      size = 16;
    }

  if (size >= 32)
    {
      if (immediate == (immediate & 0x000000ff))
	{
	  *immbits = immediate;
	  return 0x1;
	}
      else if (immediate == (immediate & 0x0000ff00))
	{
	  *immbits = immediate >> 8;
	  return 0x3;
	}
      else if (immediate == (immediate & 0x00ff0000))
	{
	  *immbits = immediate >> 16;
	  return 0x5;
	}
      else if (immediate == (immediate & 0xff000000))
	{
	  *immbits = immediate >> 24;
	  return 0x7;
	}
      if ((immediate & 0xffff) != (immediate >> 16))
	goto bad_immediate;
      immediate &= 0xffff;
    }

  if (immediate == (immediate & 0x000000ff))
    {
      *immbits = immediate;
      return 0x9;
    }
  else if (immediate == (immediate & 0x0000ff00))
    {
      *immbits = immediate >> 8;
      return 0xb;
    }

  bad_immediate:
  first_error (_("immediate value out of range"));
  return FAIL;
}

/* True if IMM has form 0bAAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD for bits
   A, B, C, D.  */

static int
neon_bits_same_in_bytes (unsigned imm)
{
  return ((imm & 0x000000ff) == 0 || (imm & 0x000000ff) == 0x000000ff)
	 && ((imm & 0x0000ff00) == 0 || (imm & 0x0000ff00) == 0x0000ff00)
	 && ((imm & 0x00ff0000) == 0 || (imm & 0x00ff0000) == 0x00ff0000)
	 && ((imm & 0xff000000) == 0 || (imm & 0xff000000) == 0xff000000);
}

/* For immediate of above form, return 0bABCD.  */

static unsigned
neon_squash_bits (unsigned imm)
{
  return (imm & 0x01) | ((imm & 0x0100) >> 7) | ((imm & 0x010000) >> 14)
	 | ((imm & 0x01000000) >> 21);
}

/* Compress quarter-float representation to 0b...000 abcdefgh.  */

static unsigned
neon_qfloat_bits (unsigned imm)
{
  return ((imm >> 19) & 0x7f) | ((imm >> 24) & 0x80);
}

/* Returns CMODE. IMMBITS [7:0] is set to bits suitable for inserting into
   the instruction. *OP is passed as the initial value of the op field, and
   may be set to a different value depending on the constant (i.e.
   "MOV I64, 0bAAAAAAAABBBB..." which uses OP = 1 despite being MOV not
   MVN).  If the immediate looks like a repeated pattern then also
   try smaller element sizes.  */

static int
neon_cmode_for_move_imm (unsigned immlo, unsigned immhi, int float_p,
			 unsigned *immbits, int *op, int size,
			 enum neon_el_type type)
{
  /* Only permit float immediates (including 0.0/-0.0) if the operand type is
     float.  */
  if (type == NT_float && !float_p)
    return FAIL;

  if (type == NT_float && is_quarter_float (immlo) && immhi == 0)
    {
      if (size != 32 || *op == 1)
	return FAIL;
      *immbits = neon_qfloat_bits (immlo);
      return 0xf;
    }

  if (size == 64)
    {
      if (neon_bits_same_in_bytes (immhi)
	  && neon_bits_same_in_bytes (immlo))
	{
	  if (*op == 1)
	    return FAIL;
	  *immbits = (neon_squash_bits (immhi) << 4)
		     | neon_squash_bits (immlo);
	  *op = 1;
	  return 0xe;
	}

      if (immhi != immlo)
	return FAIL;
    }

  if (size >= 32)
    {
      if (immlo == (immlo & 0x000000ff))
	{
	  *immbits = immlo;
	  return 0x0;
	}
      else if (immlo == (immlo & 0x0000ff00))
	{
	  *immbits = immlo >> 8;
	  return 0x2;
	}
      else if (immlo == (immlo & 0x00ff0000))
	{
	  *immbits = immlo >> 16;
	  return 0x4;
	}
      else if (immlo == (immlo & 0xff000000))
	{
	  *immbits = immlo >> 24;
	  return 0x6;
	}
      else if (immlo == ((immlo & 0x0000ff00) | 0x000000ff))
	{
	  *immbits = (immlo >> 8) & 0xff;
	  return 0xc;
	}
      else if (immlo == ((immlo & 0x00ff0000) | 0x0000ffff))
	{
	  *immbits = (immlo >> 16) & 0xff;
	  return 0xd;
	}

      if ((immlo & 0xffff) != (immlo >> 16))
	return FAIL;
      immlo &= 0xffff;
    }

  if (size >= 16)
    {
      if (immlo == (immlo & 0x000000ff))
	{
	  *immbits = immlo;
	  return 0x8;
	}
      else if (immlo == (immlo & 0x0000ff00))
	{
	  *immbits = immlo >> 8;
	  return 0xa;
	}

      if ((immlo & 0xff) != (immlo >> 8))
	return FAIL;
      immlo &= 0xff;
    }

  if (immlo == (immlo & 0x000000ff))
    {
      /* Don't allow MVN with 8-bit immediate.  */
      if (*op == 1)
	return FAIL;
      *immbits = immlo;
      return 0xe;
    }

  return FAIL;
}

/* Write immediate bits [7:0] to the following locations:

  |28/24|23     19|18 16|15                    4|3     0|
  |  a  |x x x x x|b c d|x x x x x x x x x x x x|e f g h|

  This function is used by VMOV/VMVN/VORR/VBIC.  */

static void
neon_write_immbits (unsigned immbits)
{
  inst.instruction |= immbits & 0xf;
  inst.instruction |= ((immbits >> 4) & 0x7) << 16;
  inst.instruction |= ((immbits >> 7) & 0x1) << 24;
}

/* Invert low-order SIZE bits of XHI:XLO.  */

static void
neon_invert_size (unsigned *xlo, unsigned *xhi, int size)
{
  unsigned immlo = xlo ? *xlo : 0;
  unsigned immhi = xhi ? *xhi : 0;

  switch (size)
    {
    case 8:
      immlo = (~immlo) & 0xff;
      break;

    case 16:
      immlo = (~immlo) & 0xffff;
      break;

    case 64:
      immhi = (~immhi) & 0xffffffff;
      /* fall through.  */

    case 32:
      immlo = (~immlo) & 0xffffffff;
      break;

    default:
      abort ();
    }

  if (xlo)
    *xlo = immlo;

  if (xhi)
    *xhi = immhi;
}

static void
do_neon_logic (void)
{
  if (inst.operands[2].present && inst.operands[2].isreg)
    {
      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
      neon_check_type (3, rs, N_IGNORE_TYPE);
      /* U bit and size field were set as part of the bitmask.  */
      NEON_ENCODE (INTEGER, inst);
      neon_three_same (neon_quad (rs), 0, -1);
    }
  else
    {
      const int three_ops_form = (inst.operands[2].present
				  && !inst.operands[2].isreg);
      const int immoperand = (three_ops_form ? 2 : 1);
      enum neon_shape rs = (three_ops_form
			    ? neon_select_shape (NS_DDI, NS_QQI, NS_NULL)
			    : neon_select_shape (NS_DI, NS_QI, NS_NULL));
      struct neon_type_el et = neon_check_type (2, rs,
	N_I8 | N_I16 | N_I32 | N_I64 | N_F32 | N_KEY, N_EQK);
      enum neon_opc opcode = (enum neon_opc) inst.instruction & 0x0fffffff;
      unsigned immbits;
      int cmode;

      if (et.type == NT_invtype)
	return;

      if (three_ops_form)
	constraint (inst.operands[0].reg != inst.operands[1].reg,
		    _("first and second operands shall be the same register"));

      NEON_ENCODE (IMMED, inst);

      immbits = inst.operands[immoperand].imm;
      if (et.size == 64)
	{
	  /* .i64 is a pseudo-op, so the immediate must be a repeating
	     pattern.  */
	  if (immbits != (inst.operands[immoperand].regisimm ?
			  inst.operands[immoperand].reg : 0))
	    {
	      /* Set immbits to an invalid constant.  */
	      immbits = 0xdeadbeef;
	    }
	}

      switch (opcode)
	{
	case N_MNEM_vbic:
	  cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
	  break;

	case N_MNEM_vorr:
	  cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
	  break;

	case N_MNEM_vand:
	  /* Pseudo-instruction for VBIC.  */
	  neon_invert_size (&immbits, 0, et.size);
	  cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
	  break;

	case N_MNEM_vorn:
	  /* Pseudo-instruction for VORR.  */
	  neon_invert_size (&immbits, 0, et.size);
	  cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
	  break;

	default:
	  abort ();
	}

      if (cmode == FAIL)
	return;

      inst.instruction |= neon_quad (rs) << 6;
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= cmode << 8;
      neon_write_immbits (immbits);

      neon_dp_fixup (&inst);
    }
}

static void
do_neon_bitfield (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
  neon_check_type (3, rs, N_IGNORE_TYPE);
  neon_three_same (neon_quad (rs), 0, -1);
}

static void
neon_dyadic_misc (enum neon_el_type ubit_meaning, unsigned types,
		  unsigned destbits)
{
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
  struct neon_type_el et = neon_check_type (3, rs, N_EQK | destbits, N_EQK,
					    types | N_KEY);
  if (et.type == NT_float)
    {
      NEON_ENCODE (FLOAT, inst);
      neon_three_same (neon_quad (rs), 0, -1);
    }
  else
    {
      NEON_ENCODE (INTEGER, inst);
      neon_three_same (neon_quad (rs), et.type == ubit_meaning, et.size);
    }
}

static void
do_neon_dyadic_if_su (void)
{
  neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);
}

static void
do_neon_dyadic_if_su_d (void)
{
  /* This version only allow D registers, but that constraint is enforced during
     operand parsing so we don't need to do anything extra here.  */
  neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);
}

static void
do_neon_dyadic_if_i_d (void)
{
  /* The "untyped" case can't happen. Do this to stop the "U" bit being
     affected if we specify unsigned args.  */
  neon_dyadic_misc (NT_untyped, N_IF_32, 0);
}

enum vfp_or_neon_is_neon_bits
{
  NEON_CHECK_CC = 1,
  NEON_CHECK_ARCH = 2,
  NEON_CHECK_ARCH8 = 4
};

/* Call this function if an instruction which may have belonged to the VFP or
   Neon instruction sets, but turned out to be a Neon instruction (due to the
   operand types involved, etc.). We have to check and/or fix-up a couple of
   things:

     - Make sure the user hasn't attempted to make a Neon instruction
       conditional.
     - Alter the value in the condition code field if necessary.
     - Make sure that the arch supports Neon instructions.

   Which of these operations take place depends on bits from enum
   vfp_or_neon_is_neon_bits.

   WARNING: This function has side effects! If NEON_CHECK_CC is used and the
   current instruction's condition is COND_ALWAYS, the condition field is
   changed to inst.uncond_value. This is necessary because instructions shared
   between VFP and Neon may be conditional for the VFP variants only, and the
   unconditional Neon version must have, e.g., 0xF in the condition field.  */

static int
vfp_or_neon_is_neon (unsigned check)
{
  /* Conditions are always legal in Thumb mode (IT blocks).  */
  if (!thumb_mode && (check & NEON_CHECK_CC))
    {
      if (inst.cond != COND_ALWAYS)
	{
	  first_error (_(BAD_COND));
	  return FAIL;
	}
      if (inst.uncond_value != -1)
	inst.instruction |= inst.uncond_value << 28;
    }

  if ((check & NEON_CHECK_ARCH)
      && !mark_feature_used (&fpu_neon_ext_v1))
    {
      first_error (_(BAD_FPU));
      return FAIL;
    }

  if ((check & NEON_CHECK_ARCH8)
      && !mark_feature_used (&fpu_neon_ext_armv8))
    {
      first_error (_(BAD_FPU));
      return FAIL;
    }

  return SUCCESS;
}

static void
do_neon_addsub_if_i (void)
{
  if (try_vfp_nsyn (3, do_vfp_nsyn_add_sub) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

  /* The "untyped" case can't happen. Do this to stop the "U" bit being
     affected if we specify unsigned args.  */
  neon_dyadic_misc (NT_untyped, N_IF_32 | N_I64, 0);
}

/* Swaps operands 1 and 2. If operand 1 (optional arg) was omitted, we want the
   result to be:
     V<op> A,B     (A is operand 0, B is operand 2)
   to mean:
     V<op> A,B,A
   not:
     V<op> A,B,B
   so handle that case specially.  */

static void
neon_exchange_operands (void)
{
  void *scratch = alloca (sizeof (inst.operands[0]));
  if (inst.operands[1].present)
    {
      /* Swap operands[1] and operands[2].  */
      memcpy (scratch, &inst.operands[1], sizeof (inst.operands[0]));
      inst.operands[1] = inst.operands[2];
      memcpy (&inst.operands[2], scratch, sizeof (inst.operands[0]));
    }
  else
    {
      inst.operands[1] = inst.operands[2];
      inst.operands[2] = inst.operands[0];
    }
}

static void
neon_compare (unsigned regtypes, unsigned immtypes, int invert)
{
  if (inst.operands[2].isreg)
    {
      if (invert)
	neon_exchange_operands ();
      neon_dyadic_misc (NT_unsigned, regtypes, N_SIZ);
    }
  else
    {
      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
      struct neon_type_el et = neon_check_type (2, rs,
	N_EQK | N_SIZ, immtypes | N_KEY);

      NEON_ENCODE (IMMED, inst);
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= neon_quad (rs) << 6;
      inst.instruction |= (et.type == NT_float) << 10;
      inst.instruction |= neon_logbits (et.size) << 18;

      neon_dp_fixup (&inst);
    }
}

static void
do_neon_cmp (void)
{
  neon_compare (N_SUF_32, N_S8 | N_S16 | N_S32 | N_F32, FALSE);
}

static void
do_neon_cmp_inv (void)
{
  neon_compare (N_SUF_32, N_S8 | N_S16 | N_S32 | N_F32, TRUE);
}

static void
do_neon_ceq (void)
{
  neon_compare (N_IF_32, N_IF_32, FALSE);
}

/* For multiply instructions, we have the possibility of 16-bit or 32-bit
   scalars, which are encoded in 5 bits, M : Rm.
   For 16-bit scalars, the register is encoded in Rm[2:0] and the index in
   M:Rm[3], and for 32-bit scalars, the register is encoded in Rm[3:0] and the
   index in M.  */

static unsigned
neon_scalar_for_mul (unsigned scalar, unsigned elsize)
{
  unsigned regno = NEON_SCALAR_REG (scalar);
  unsigned elno = NEON_SCALAR_INDEX (scalar);

  switch (elsize)
    {
    case 16:
      if (regno > 7 || elno > 3)
	goto bad_scalar;
      return regno | (elno << 3);

    case 32:
      if (regno > 15 || elno > 1)
	goto bad_scalar;
      return regno | (elno << 4);

    default:
    bad_scalar:
      first_error (_("scalar out of range for multiply instruction"));
    }

  return 0;
}

/* Encode multiply / multiply-accumulate scalar instructions.  */

static void
neon_mul_mac (struct neon_type_el et, int ubit)
{
  unsigned scalar;

  /* Give a more helpful error message if we have an invalid type.  */
  if (et.type == NT_invtype)
    return;

  scalar = neon_scalar_for_mul (inst.operands[2].reg, et.size);
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (scalar);
  inst.instruction |= HI1 (scalar) << 5;
  inst.instruction |= (et.type == NT_float) << 8;
  inst.instruction |= neon_logbits (et.size) << 20;
  inst.instruction |= (ubit != 0) << 24;

  neon_dp_fixup (&inst);
}

static void
do_neon_mac_maybe_scalar (void)
{
  if (try_vfp_nsyn (3, do_vfp_nsyn_mla_mls) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

  if (inst.operands[2].isscalar)
    {
      enum neon_shape rs = neon_select_shape (NS_DDS, NS_QQS, NS_NULL);
      struct neon_type_el et = neon_check_type (3, rs,
	N_EQK, N_EQK, N_I16 | N_I32 | N_F32 | N_KEY);
      NEON_ENCODE (SCALAR, inst);
      neon_mul_mac (et, neon_quad (rs));
    }
  else
    {
      /* The "untyped" case can't happen.  Do this to stop the "U" bit being
	 affected if we specify unsigned args.  */
      neon_dyadic_misc (NT_untyped, N_IF_32, 0);
    }
}

static void
do_neon_fmac (void)
{
  if (try_vfp_nsyn (3, do_vfp_nsyn_fma_fms) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

  neon_dyadic_misc (NT_untyped, N_IF_32, 0);
}

static void
do_neon_tst (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_8 | N_16 | N_32 | N_KEY);
  neon_three_same (neon_quad (rs), 0, et.size);
}

/* VMUL with 3 registers allows the P8 type. The scalar version supports the
   same types as the MAC equivalents. The polynomial type for this instruction
   is encoded the same as the integer type.  */

static void
do_neon_mul (void)
{
  if (try_vfp_nsyn (3, do_vfp_nsyn_mul) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

  if (inst.operands[2].isscalar)
    do_neon_mac_maybe_scalar ();
  else
    neon_dyadic_misc (NT_poly, N_I8 | N_I16 | N_I32 | N_F32 | N_P8, 0);
}

static void
do_neon_qdmulh (void)
{
  if (inst.operands[2].isscalar)
    {
      enum neon_shape rs = neon_select_shape (NS_DDS, NS_QQS, NS_NULL);
      struct neon_type_el et = neon_check_type (3, rs,
	N_EQK, N_EQK, N_S16 | N_S32 | N_KEY);
      NEON_ENCODE (SCALAR, inst);
      neon_mul_mac (et, neon_quad (rs));
    }
  else
    {
      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
      struct neon_type_el et = neon_check_type (3, rs,
	N_EQK, N_EQK, N_S16 | N_S32 | N_KEY);
      NEON_ENCODE (INTEGER, inst);
      /* The U bit (rounding) comes from bit mask.  */
      neon_three_same (neon_quad (rs), 0, et.size);
    }
}

static void
do_neon_fcmp_absolute (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
  neon_check_type (3, rs, N_EQK, N_EQK, N_F32 | N_KEY);
  /* Size field comes from bit mask.  */
  neon_three_same (neon_quad (rs), 1, -1);
}

static void
do_neon_fcmp_absolute_inv (void)
{
  neon_exchange_operands ();
  do_neon_fcmp_absolute ();
}

static void
do_neon_step (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
  neon_check_type (3, rs, N_EQK, N_EQK, N_F32 | N_KEY);
  neon_three_same (neon_quad (rs), 0, -1);
}

static void
do_neon_abs_neg (void)
{
  enum neon_shape rs;
  struct neon_type_el et;

  if (try_vfp_nsyn (2, do_vfp_nsyn_abs_neg) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

  rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  et = neon_check_type (2, rs, N_EQK, N_S8 | N_S16 | N_S32 | N_F32 | N_KEY);

  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg);
  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
  inst.instruction |= neon_quad (rs) << 6;
  inst.instruction |= (et.type == NT_float) << 10;
  inst.instruction |= neon_logbits (et.size) << 18;

  neon_dp_fixup (&inst);
}

static void
do_neon_sli (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
  int imm = inst.operands[2].imm;
  constraint (imm < 0 || (unsigned)imm >= et.size,
	      _("immediate out of range for insert"));
  neon_imm_shift (FALSE, 0, neon_quad (rs), et, imm);
}

static void
do_neon_sri (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
  int imm = inst.operands[2].imm;
  constraint (imm < 1 || (unsigned)imm > et.size,
	      _("immediate out of range for insert"));
  neon_imm_shift (FALSE, 0, neon_quad (rs), et, et.size - imm);
}

static void
do_neon_qshlu_imm (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK | N_UNS, N_S8 | N_S16 | N_S32 | N_S64 | N_KEY);
  int imm = inst.operands[2].imm;
  constraint (imm < 0 || (unsigned)imm >= et.size,
	      _("immediate out of range for shift"));
  /* Only encodes the 'U present' variant of the instruction.
     In this case, signed types have OP (bit 8) set to 0.
     Unsigned types have OP set to 1.  */
  inst.instruction |= (et.type == NT_unsigned) << 8;
  /* The rest of the bits are the same as other immediate shifts.  */
  neon_imm_shift (FALSE, 0, neon_quad (rs), et, imm);
}

static void
do_neon_qmovn (void)
{
  struct neon_type_el et = neon_check_type (2, NS_DQ,
    N_EQK | N_HLF, N_SU_16_64 | N_KEY);
  /* Saturating move where operands can be signed or unsigned, and the
     destination has the same signedness.  */
  NEON_ENCODE (INTEGER, inst);
  if (et.type == NT_unsigned)
    inst.instruction |= 0xc0;
  else
    inst.instruction |= 0x80;
  neon_two_same (0, 1, et.size / 2);
}

static void
do_neon_qmovun (void)
{
  struct neon_type_el et = neon_check_type (2, NS_DQ,
    N_EQK | N_HLF | N_UNS, N_S16 | N_S32 | N_S64 | N_KEY);
  /* Saturating move with unsigned results. Operands must be signed.  */
  NEON_ENCODE (INTEGER, inst);
  neon_two_same (0, 1, et.size / 2);
}

static void
do_neon_rshift_sat_narrow (void)
{
  /* FIXME: Types for narrowing. If operands are signed, results can be signed
     or unsigned. If operands are unsigned, results must also be unsigned.  */
  struct neon_type_el et = neon_check_type (2, NS_DQI,
    N_EQK | N_HLF, N_SU_16_64 | N_KEY);
  int imm = inst.operands[2].imm;
  /* This gets the bounds check, size encoding and immediate bits calculation
     right.  */
  et.size /= 2;

  /* VQ{R}SHRN.I<size> <Dd>, <Qm>, #0 is a synonym for
     VQMOVN.I<size> <Dd>, <Qm>.  */
  if (imm == 0)
    {
      inst.operands[2].present = 0;
      inst.instruction = N_MNEM_vqmovn;
      do_neon_qmovn ();
      return;
    }

  constraint (imm < 1 || (unsigned)imm > et.size,
	      _("immediate out of range"));
  neon_imm_shift (TRUE, et.type == NT_unsigned, 0, et, et.size - imm);
}

static void
do_neon_rshift_sat_narrow_u (void)
{
  /* FIXME: Types for narrowing. If operands are signed, results can be signed
     or unsigned. If operands are unsigned, results must also be unsigned.  */
  struct neon_type_el et = neon_check_type (2, NS_DQI,
    N_EQK | N_HLF | N_UNS, N_S16 | N_S32 | N_S64 | N_KEY);
  int imm = inst.operands[2].imm;
  /* This gets the bounds check, size encoding and immediate bits calculation
     right.  */
  et.size /= 2;

  /* VQSHRUN.I<size> <Dd>, <Qm>, #0 is a synonym for
     VQMOVUN.I<size> <Dd>, <Qm>.  */
  if (imm == 0)
    {
      inst.operands[2].present = 0;
      inst.instruction = N_MNEM_vqmovun;
      do_neon_qmovun ();
      return;
    }

  constraint (imm < 1 || (unsigned)imm > et.size,
	      _("immediate out of range"));
  /* FIXME: The manual is kind of unclear about what value U should have in
     VQ{R}SHRUN instructions, but U=0, op=0 definitely encodes VRSHR, so it
     must be 1.  */
  neon_imm_shift (TRUE, 1, 0, et, et.size - imm);
}

static void
do_neon_movn (void)
{
  struct neon_type_el et = neon_check_type (2, NS_DQ,
    N_EQK | N_HLF, N_I16 | N_I32 | N_I64 | N_KEY);
  NEON_ENCODE (INTEGER, inst);
  neon_two_same (0, 1, et.size / 2);
}

static void
do_neon_rshift_narrow (void)
{
  struct neon_type_el et = neon_check_type (2, NS_DQI,
    N_EQK | N_HLF, N_I16 | N_I32 | N_I64 | N_KEY);
  int imm = inst.operands[2].imm;
  /* This gets the bounds check, size encoding and immediate bits calculation
     right.  */
  et.size /= 2;

  /* If immediate is zero then we are a pseudo-instruction for
     VMOVN.I<size> <Dd>, <Qm>  */
  if (imm == 0)
    {
      inst.operands[2].present = 0;
      inst.instruction = N_MNEM_vmovn;
      do_neon_movn ();
      return;
    }

  constraint (imm < 1 || (unsigned)imm > et.size,
	      _("immediate out of range for narrowing operation"));
  neon_imm_shift (FALSE, 0, 0, et, et.size - imm);
}

static void
do_neon_shll (void)
{
  /* FIXME: Type checking when lengthening.  */
  struct neon_type_el et = neon_check_type (2, NS_QDI,
    N_EQK | N_DBL, N_I8 | N_I16 | N_I32 | N_KEY);
  unsigned imm = inst.operands[2].imm;

  if (imm == et.size)
    {
      /* Maximum shift variant.  */
      NEON_ENCODE (INTEGER, inst);
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= neon_logbits (et.size) << 18;

      neon_dp_fixup (&inst);
    }
  else
    {
      /* A more-specific type check for non-max versions.  */
      et = neon_check_type (2, NS_QDI,
	N_EQK | N_DBL, N_SU_32 | N_KEY);
      NEON_ENCODE (IMMED, inst);
      neon_imm_shift (TRUE, et.type == NT_unsigned, 0, et, imm);
    }
}

/* Check the various types for the VCVT instruction, and return which version
   the current instruction is.  */

#define CVT_FLAVOUR_VAR							      \
  CVT_VAR (s32_f32, N_S32, N_F32, whole_reg,   "ftosls", "ftosis", "ftosizs") \
  CVT_VAR (u32_f32, N_U32, N_F32, whole_reg,   "ftouls", "ftouis", "ftouizs") \
  CVT_VAR (f32_s32, N_F32, N_S32, whole_reg,   "fsltos", "fsitos", NULL)      \
  CVT_VAR (f32_u32, N_F32, N_U32, whole_reg,   "fultos", "fuitos", NULL)      \
  /* Half-precision conversions.  */					      \
  CVT_VAR (f32_f16, N_F32, N_F16, whole_reg,   NULL,     NULL,     NULL)      \
  CVT_VAR (f16_f32, N_F16, N_F32, whole_reg,   NULL,     NULL,     NULL)      \
  /* VFP instructions.  */						      \
  CVT_VAR (f32_f64, N_F32, N_F64, N_VFP,       NULL,     "fcvtsd", NULL)      \
  CVT_VAR (f64_f32, N_F64, N_F32, N_VFP,       NULL,     "fcvtds", NULL)      \
  CVT_VAR (s32_f64, N_S32, N_F64 | key, N_VFP, "ftosld", "ftosid", "ftosizd") \
  CVT_VAR (u32_f64, N_U32, N_F64 | key, N_VFP, "ftould", "ftouid", "ftouizd") \
  CVT_VAR (f64_s32, N_F64 | key, N_S32, N_VFP, "fsltod", "fsitod", NULL)      \
  CVT_VAR (f64_u32, N_F64 | key, N_U32, N_VFP, "fultod", "fuitod", NULL)      \
  /* VFP instructions with bitshift.  */				      \
  CVT_VAR (f32_s16, N_F32 | key, N_S16, N_VFP, "fshtos", NULL,     NULL)      \
  CVT_VAR (f32_u16, N_F32 | key, N_U16, N_VFP, "fuhtos", NULL,     NULL)      \
  CVT_VAR (f64_s16, N_F64 | key, N_S16, N_VFP, "fshtod", NULL,     NULL)      \
  CVT_VAR (f64_u16, N_F64 | key, N_U16, N_VFP, "fuhtod", NULL,     NULL)      \
  CVT_VAR (s16_f32, N_S16, N_F32 | key, N_VFP, "ftoshs", NULL,     NULL)      \
  CVT_VAR (u16_f32, N_U16, N_F32 | key, N_VFP, "ftouhs", NULL,     NULL)      \
  CVT_VAR (s16_f64, N_S16, N_F64 | key, N_VFP, "ftoshd", NULL,     NULL)      \
  CVT_VAR (u16_f64, N_U16, N_F64 | key, N_VFP, "ftouhd", NULL,     NULL)

#define CVT_VAR(C, X, Y, R, BSN, CN, ZN) \
  neon_cvt_flavour_##C,

/* The different types of conversions we can do.  */
enum neon_cvt_flavour
{
  CVT_FLAVOUR_VAR
  neon_cvt_flavour_invalid,
  neon_cvt_flavour_first_fp = neon_cvt_flavour_f32_f64
};

#undef CVT_VAR

static enum neon_cvt_flavour
get_neon_cvt_flavour (enum neon_shape rs)
{
#define CVT_VAR(C,X,Y,R,BSN,CN,ZN)			\
  et = neon_check_type (2, rs, (R) | (X), (R) | (Y));	\
  if (et.type != NT_invtype)				\
    {							\
      inst.error = NULL;				\
      return (neon_cvt_flavour_##C);			\
    }

  struct neon_type_el et;
  unsigned whole_reg = (rs == NS_FFI || rs == NS_FD || rs == NS_DF
			|| rs == NS_FF) ? N_VFP : 0;
  /* The instruction versions which take an immediate take one register
     argument, which is extended to the width of the full register. Thus the
     "source" and "destination" registers must have the same width.  Hack that
     here by making the size equal to the key (wider, in this case) operand.  */
  unsigned key = (rs == NS_QQI || rs == NS_DDI || rs == NS_FFI) ? N_KEY : 0;

  CVT_FLAVOUR_VAR;

  return neon_cvt_flavour_invalid;
#undef CVT_VAR
}

enum neon_cvt_mode
{
  neon_cvt_mode_a,
  neon_cvt_mode_n,
  neon_cvt_mode_p,
  neon_cvt_mode_m,
  neon_cvt_mode_z,
  neon_cvt_mode_x,
  neon_cvt_mode_r
};

/* Neon-syntax VFP conversions.  */

static void
do_vfp_nsyn_cvt (enum neon_shape rs, enum neon_cvt_flavour flavour)
{
  const char *opname = 0;

  if (rs == NS_DDI || rs == NS_QQI || rs == NS_FFI)
    {
      /* Conversions with immediate bitshift.  */
      const char *enc[] =
	{
#define CVT_VAR(C,A,B,R,BSN,CN,ZN) BSN,
	  CVT_FLAVOUR_VAR
	  NULL
#undef CVT_VAR
	};

      if (flavour < (int) ARRAY_SIZE (enc))
	{
	  opname = enc[flavour];
	  constraint (inst.operands[0].reg != inst.operands[1].reg,
		      _("operands 0 and 1 must be the same register"));
	  inst.operands[1] = inst.operands[2];
	  memset (&inst.operands[2], '\0', sizeof (inst.operands[2]));
	}
    }
  else
    {
      /* Conversions without bitshift.  */
      const char *enc[] =
	{
#define CVT_VAR(C,A,B,R,BSN,CN,ZN) CN,
	  CVT_FLAVOUR_VAR
	  NULL
#undef CVT_VAR
	};

      if (flavour < (int) ARRAY_SIZE (enc))
	opname = enc[flavour];
    }

  if (opname)
    do_vfp_nsyn_opcode (opname);
}

static void
do_vfp_nsyn_cvtz (void)
{
  enum neon_shape rs = neon_select_shape (NS_FF, NS_FD, NS_NULL);
  enum neon_cvt_flavour flavour = get_neon_cvt_flavour (rs);
  const char *enc[] =
    {
#define CVT_VAR(C,A,B,R,BSN,CN,ZN) ZN,
      CVT_FLAVOUR_VAR
      NULL
#undef CVT_VAR
    };

  if (flavour < (int) ARRAY_SIZE (enc) && enc[flavour])
    do_vfp_nsyn_opcode (enc[flavour]);
}

static void
do_vfp_nsyn_cvt_fpv8 (enum neon_cvt_flavour flavour,
		      enum neon_cvt_mode mode)
{
  int sz, op;
  int rm;

  set_it_insn_type (OUTSIDE_IT_INSN);

  switch (flavour)
    {
    case neon_cvt_flavour_s32_f64:
      sz = 1;
      op = 0;
      break;
    case neon_cvt_flavour_s32_f32:
      sz = 0;
      op = 1;
      break;
    case neon_cvt_flavour_u32_f64:
      sz = 1;
      op = 0;
      break;
    case neon_cvt_flavour_u32_f32:
      sz = 0;
      op = 0;
      break;
    default:
      first_error (_("invalid instruction shape"));
      return;
    }

  switch (mode)
    {
    case neon_cvt_mode_a: rm = 0; break;
    case neon_cvt_mode_n: rm = 1; break;
    case neon_cvt_mode_p: rm = 2; break;
    case neon_cvt_mode_m: rm = 3; break;
    default: first_error (_("invalid rounding mode")); return;
    }

  NEON_ENCODE (FPV8, inst);
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, sz == 1 ? VFP_REG_Dm : VFP_REG_Sm);
  inst.instruction |= sz << 8;
  inst.instruction |= op << 7;
  inst.instruction |= rm << 16;
  inst.instruction |= 0xf0000000;
  inst.is_neon = TRUE;
}

static void
do_neon_cvt_1 (enum neon_cvt_mode mode)
{
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_FFI, NS_DD, NS_QQ,
    NS_FD, NS_DF, NS_FF, NS_QD, NS_DQ, NS_NULL);
  enum neon_cvt_flavour flavour = get_neon_cvt_flavour (rs);

  /* PR11109: Handle round-to-zero for VCVT conversions.  */
  if (mode == neon_cvt_mode_z
      && ARM_CPU_HAS_FEATURE (cpu_variant, fpu_arch_vfp_v2)
      && (flavour == neon_cvt_flavour_s32_f32
	  || flavour == neon_cvt_flavour_u32_f32
	  || flavour == neon_cvt_flavour_s32_f64
	  || flavour == neon_cvt_flavour_u32_f64)
      && (rs == NS_FD || rs == NS_FF))
    {
      do_vfp_nsyn_cvtz ();
      return;
    }

  /* VFP rather than Neon conversions.  */
  if (flavour >= neon_cvt_flavour_first_fp)
    {
      if (mode == neon_cvt_mode_x || mode == neon_cvt_mode_z)
	do_vfp_nsyn_cvt (rs, flavour);
      else
	do_vfp_nsyn_cvt_fpv8 (flavour, mode);

      return;
    }

  switch (rs)
    {
    case NS_DDI:
    case NS_QQI:
      {
	unsigned immbits;
	unsigned enctab[] = { 0x0000100, 0x1000100, 0x0, 0x1000000 };

	if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
	  return;

	/* Fixed-point conversion with #0 immediate is encoded as an
	   integer conversion.  */
	if (inst.operands[2].present && inst.operands[2].imm == 0)
	  goto int_encode;
       immbits = 32 - inst.operands[2].imm;
	NEON_ENCODE (IMMED, inst);
	if (flavour != neon_cvt_flavour_invalid)
	  inst.instruction |= enctab[flavour];
	inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
	inst.instruction |= HI1 (inst.operands[0].reg) << 22;
	inst.instruction |= LOW4 (inst.operands[1].reg);
	inst.instruction |= HI1 (inst.operands[1].reg) << 5;
	inst.instruction |= neon_quad (rs) << 6;
	inst.instruction |= 1 << 21;
	inst.instruction |= immbits << 16;

	neon_dp_fixup (&inst);
      }
      break;

    case NS_DD:
    case NS_QQ:
      if (mode != neon_cvt_mode_x && mode != neon_cvt_mode_z)
	{
	  NEON_ENCODE (FLOAT, inst);
	  set_it_insn_type (OUTSIDE_IT_INSN);

	  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
	    return;

	  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
	  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
	  inst.instruction |= LOW4 (inst.operands[1].reg);
	  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
	  inst.instruction |= neon_quad (rs) << 6;
	  inst.instruction |= (flavour == neon_cvt_flavour_u32_f32) << 7;
	  inst.instruction |= mode << 8;
	  if (thumb_mode)
	    inst.instruction |= 0xfc000000;
	  else
	    inst.instruction |= 0xf0000000;
	}
      else
	{
    int_encode:
	  {
	    unsigned enctab[] = { 0x100, 0x180, 0x0, 0x080 };

	    NEON_ENCODE (INTEGER, inst);

	    if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
	      return;

	    if (flavour != neon_cvt_flavour_invalid)
	      inst.instruction |= enctab[flavour];

	    inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
	    inst.instruction |= HI1 (inst.operands[0].reg) << 22;
	    inst.instruction |= LOW4 (inst.operands[1].reg);
	    inst.instruction |= HI1 (inst.operands[1].reg) << 5;
	    inst.instruction |= neon_quad (rs) << 6;
	    inst.instruction |= 2 << 18;

	    neon_dp_fixup (&inst);
	  }
	}
      break;

    /* Half-precision conversions for Advanced SIMD -- neon.  */
    case NS_QD:
    case NS_DQ:

      if ((rs == NS_DQ)
	  && (inst.vectype.el[0].size != 16 || inst.vectype.el[1].size != 32))
	  {
	    as_bad (_("operand size must match register width"));
	    break;
	  }

      if ((rs == NS_QD)
	  && ((inst.vectype.el[0].size != 32 || inst.vectype.el[1].size != 16)))
	  {
	    as_bad (_("operand size must match register width"));
	    break;
	  }

      if (rs == NS_DQ)
	inst.instruction = 0x3b60600;
      else
	inst.instruction = 0x3b60700;

      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      neon_dp_fixup (&inst);
      break;

    default:
      /* Some VFP conversions go here (s32 <-> f32, u32 <-> f32).  */
      if (mode == neon_cvt_mode_x || mode == neon_cvt_mode_z)
	do_vfp_nsyn_cvt (rs, flavour);
      else
	do_vfp_nsyn_cvt_fpv8 (flavour, mode);
    }
}

static void
do_neon_cvtr (void)
{
  do_neon_cvt_1 (neon_cvt_mode_x);
}

static void
do_neon_cvt (void)
{
  do_neon_cvt_1 (neon_cvt_mode_z);
}

static void
do_neon_cvta (void)
{
  do_neon_cvt_1 (neon_cvt_mode_a);
}

static void
do_neon_cvtn (void)
{
  do_neon_cvt_1 (neon_cvt_mode_n);
}

static void
do_neon_cvtp (void)
{
  do_neon_cvt_1 (neon_cvt_mode_p);
}

static void
do_neon_cvtm (void)
{
  do_neon_cvt_1 (neon_cvt_mode_m);
}

static void
do_neon_cvttb_2 (bfd_boolean t, bfd_boolean to, bfd_boolean is_double)
{
  if (is_double)
    mark_feature_used (&fpu_vfp_ext_armv8);

  encode_arm_vfp_reg (inst.operands[0].reg,
		      (is_double && !to) ? VFP_REG_Dd : VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg,
		      (is_double && to) ? VFP_REG_Dm : VFP_REG_Sm);
  inst.instruction |= to ? 0x10000 : 0;
  inst.instruction |= t ? 0x80 : 0;
  inst.instruction |= is_double ? 0x100 : 0;
  do_vfp_cond_or_thumb ();
}

static void
do_neon_cvttb_1 (bfd_boolean t)
{
  enum neon_shape rs = neon_select_shape (NS_FF, NS_FD, NS_DF, NS_NULL);

  if (rs == NS_NULL)
    return;
  else if (neon_check_type (2, rs, N_F16, N_F32 | N_VFP).type != NT_invtype)
    {
      inst.error = NULL;
      do_neon_cvttb_2 (t, /*to=*/TRUE, /*is_double=*/FALSE);
    }
  else if (neon_check_type (2, rs, N_F32 | N_VFP, N_F16).type != NT_invtype)
    {
      inst.error = NULL;
      do_neon_cvttb_2 (t, /*to=*/FALSE, /*is_double=*/FALSE);
    }
  else if (neon_check_type (2, rs, N_F16, N_F64 | N_VFP).type != NT_invtype)
    {
      inst.error = NULL;
      do_neon_cvttb_2 (t, /*to=*/TRUE, /*is_double=*/TRUE);
    }
  else if (neon_check_type (2, rs, N_F64 | N_VFP, N_F16).type != NT_invtype)
    {
      inst.error = NULL;
      do_neon_cvttb_2 (t, /*to=*/FALSE, /*is_double=*/TRUE);
    }
  else
    return;
}

static void
do_neon_cvtb (void)
{
  do_neon_cvttb_1 (FALSE);
}


static void
do_neon_cvtt (void)
{
  do_neon_cvttb_1 (TRUE);
}

static void
neon_move_immediate (void)
{
  enum neon_shape rs = neon_select_shape (NS_DI, NS_QI, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_I8 | N_I16 | N_I32 | N_I64 | N_F32 | N_KEY, N_EQK);
  unsigned immlo, immhi = 0, immbits;
  int op, cmode, float_p;

  constraint (et.type == NT_invtype,
	      _("operand size must be specified for immediate VMOV"));

  /* We start out as an MVN instruction if OP = 1, MOV otherwise.  */
  op = (inst.instruction & (1 << 5)) != 0;

  immlo = inst.operands[1].imm;
  if (inst.operands[1].regisimm)
    immhi = inst.operands[1].reg;

  constraint (et.size < 32 && (immlo & ~((1 << et.size) - 1)) != 0,
	      _("immediate has bits set outside the operand size"));

  float_p = inst.operands[1].immisfloat;

  if ((cmode = neon_cmode_for_move_imm (immlo, immhi, float_p, &immbits, &op,
					et.size, et.type)) == FAIL)
    {
      /* Invert relevant bits only.  */
      neon_invert_size (&immlo, &immhi, et.size);
      /* Flip from VMOV/VMVN to VMVN/VMOV. Some immediate types are unavailable
	 with one or the other; those cases are caught by
	 neon_cmode_for_move_imm.  */
      op = !op;
      if ((cmode = neon_cmode_for_move_imm (immlo, immhi, float_p, &immbits,
					    &op, et.size, et.type)) == FAIL)
	{
	  first_error (_("immediate out of range"));
	  return;
	}
    }

  inst.instruction &= ~(1 << 5);
  inst.instruction |= op << 5;

  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= neon_quad (rs) << 6;
  inst.instruction |= cmode << 8;

  neon_write_immbits (immbits);
}

static void
do_neon_mvn (void)
{
  if (inst.operands[1].isreg)
    {
      enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);

      NEON_ENCODE (INTEGER, inst);
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= neon_quad (rs) << 6;
    }
  else
    {
      NEON_ENCODE (IMMED, inst);
      neon_move_immediate ();
    }

  neon_dp_fixup (&inst);
}

/* Encode instructions of form:

  |28/24|23|22|21 20|19 16|15 12|11    8|7|6|5|4|3  0|
  |  U  |x |D |size | Rn  | Rd  |x x x x|N|x|M|x| Rm |  */

static void
neon_mixed_length (struct neon_type_el et, unsigned size)
{
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= (et.type == NT_unsigned) << 24;
  inst.instruction |= neon_logbits (size) << 20;

  neon_dp_fixup (&inst);
}

static void
do_neon_dyadic_long (void)
{
  /* FIXME: Type checking for lengthening op.  */
  struct neon_type_el et = neon_check_type (3, NS_QDD,
    N_EQK | N_DBL, N_EQK, N_SU_32 | N_KEY);
  neon_mixed_length (et, et.size);
}

static void
do_neon_abal (void)
{
  struct neon_type_el et = neon_check_type (3, NS_QDD,
    N_EQK | N_INT | N_DBL, N_EQK, N_SU_32 | N_KEY);
  neon_mixed_length (et, et.size);
}

static void
neon_mac_reg_scalar_long (unsigned regtypes, unsigned scalartypes)
{
  if (inst.operands[2].isscalar)
    {
      struct neon_type_el et = neon_check_type (3, NS_QDS,
	N_EQK | N_DBL, N_EQK, regtypes | N_KEY);
      NEON_ENCODE (SCALAR, inst);
      neon_mul_mac (et, et.type == NT_unsigned);
    }
  else
    {
      struct neon_type_el et = neon_check_type (3, NS_QDD,
	N_EQK | N_DBL, N_EQK, scalartypes | N_KEY);
      NEON_ENCODE (INTEGER, inst);
      neon_mixed_length (et, et.size);
    }
}

static void
do_neon_mac_maybe_scalar_long (void)
{
  neon_mac_reg_scalar_long (N_S16 | N_S32 | N_U16 | N_U32, N_SU_32);
}

static void
do_neon_dyadic_wide (void)
{
  struct neon_type_el et = neon_check_type (3, NS_QQD,
    N_EQK | N_DBL, N_EQK | N_DBL, N_SU_32 | N_KEY);
  neon_mixed_length (et, et.size);
}

static void
do_neon_dyadic_narrow (void)
{
  struct neon_type_el et = neon_check_type (3, NS_QDD,
    N_EQK | N_DBL, N_EQK, N_I16 | N_I32 | N_I64 | N_KEY);
  /* Operand sign is unimportant, and the U bit is part of the opcode,
     so force the operand type to integer.  */
  et.type = NT_integer;
  neon_mixed_length (et, et.size / 2);
}

static void
do_neon_mul_sat_scalar_long (void)
{
  neon_mac_reg_scalar_long (N_S16 | N_S32, N_S16 | N_S32);
}

static void
do_neon_vmull (void)
{
  if (inst.operands[2].isscalar)
    do_neon_mac_maybe_scalar_long ();
  else
    {
      struct neon_type_el et = neon_check_type (3, NS_QDD,
	N_EQK | N_DBL, N_EQK, N_SU_32 | N_P8 | N_P64 | N_KEY);

      if (et.type == NT_poly)
	NEON_ENCODE (POLY, inst);
      else
	NEON_ENCODE (INTEGER, inst);

      /* For polynomial encoding the U bit must be zero, and the size must
	 be 8 (encoded as 0b00) or, on ARMv8 or later 64 (encoded, non
	 obviously, as 0b10).  */
      if (et.size == 64)
	{
	  /* Check we're on the correct architecture.  */
	  if (!mark_feature_used (&fpu_crypto_ext_armv8))
	    inst.error =
	      _("Instruction form not available on this architecture.");

	  et.size = 32;
	}

      neon_mixed_length (et, et.size);
    }
}

static void
do_neon_ext (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDDI, NS_QQQI, NS_NULL);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
  unsigned imm = (inst.operands[3].imm * et.size) / 8;

  constraint (imm >= (unsigned) (neon_quad (rs) ? 16 : 8),
	      _("shift out of range"));
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= neon_quad (rs) << 6;
  inst.instruction |= imm << 8;

  neon_dp_fixup (&inst);
}

static void
do_neon_rev (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_KEY);
  unsigned op = (inst.instruction >> 7) & 3;
  /* N (width of reversed regions) is encoded as part of the bitmask. We
     extract it here to check the elements to be reversed are smaller.
     Otherwise we'd get a reserved instruction.  */
  unsigned elsize = (op == 2) ? 16 : (op == 1) ? 32 : (op == 0) ? 64 : 0;
  gas_assert (elsize != 0);
  constraint (et.size >= elsize,
	      _("elements must be smaller than reversal region"));
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_dup (void)
{
  if (inst.operands[1].isscalar)
    {
      enum neon_shape rs = neon_select_shape (NS_DS, NS_QS, NS_NULL);
      struct neon_type_el et = neon_check_type (2, rs,
	N_EQK, N_8 | N_16 | N_32 | N_KEY);
      unsigned sizebits = et.size >> 3;
      unsigned dm = NEON_SCALAR_REG (inst.operands[1].reg);
      int logsize = neon_logbits (et.size);
      unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg) << logsize;

      if (vfp_or_neon_is_neon (NEON_CHECK_CC) == FAIL)
	return;

      NEON_ENCODE (SCALAR, inst);
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (dm);
      inst.instruction |= HI1 (dm) << 5;
      inst.instruction |= neon_quad (rs) << 6;
      inst.instruction |= x << 17;
      inst.instruction |= sizebits << 16;

      neon_dp_fixup (&inst);
    }
  else
    {
      enum neon_shape rs = neon_select_shape (NS_DR, NS_QR, NS_NULL);
      struct neon_type_el et = neon_check_type (2, rs,
	N_8 | N_16 | N_32 | N_KEY, N_EQK);
      /* Duplicate ARM register to lanes of vector.  */
      NEON_ENCODE (ARMREG, inst);
      switch (et.size)
	{
	case 8:  inst.instruction |= 0x400000; break;
	case 16: inst.instruction |= 0x000020; break;
	case 32: inst.instruction |= 0x000000; break;
	default: break;
	}
      inst.instruction |= LOW4 (inst.operands[1].reg) << 12;
      inst.instruction |= LOW4 (inst.operands[0].reg) << 16;
      inst.instruction |= HI1 (inst.operands[0].reg) << 7;
      inst.instruction |= neon_quad (rs) << 21;
      /* The encoding for this instruction is identical for the ARM and Thumb
	 variants, except for the condition field.  */
      do_vfp_cond_or_thumb ();
    }
}

/* VMOV has particularly many variations. It can be one of:
     0. VMOV<c><q> <Qd>, <Qm>
     1. VMOV<c><q> <Dd>, <Dm>
   (Register operations, which are VORR with Rm = Rn.)
     2. VMOV<c><q>.<dt> <Qd>, #<imm>
     3. VMOV<c><q>.<dt> <Dd>, #<imm>
   (Immediate loads.)
     4. VMOV<c><q>.<size> <Dn[x]>, <Rd>
   (ARM register to scalar.)
     5. VMOV<c><q> <Dm>, <Rd>, <Rn>
   (Two ARM registers to vector.)
     6. VMOV<c><q>.<dt> <Rd>, <Dn[x]>
   (Scalar to ARM register.)
     7. VMOV<c><q> <Rd>, <Rn>, <Dm>
   (Vector to two ARM registers.)
     8. VMOV.F32 <Sd>, <Sm>
     9. VMOV.F64 <Dd>, <Dm>
   (VFP register moves.)
    10. VMOV.F32 <Sd>, #imm
    11. VMOV.F64 <Dd>, #imm
   (VFP float immediate load.)
    12. VMOV <Rd>, <Sm>
   (VFP single to ARM reg.)
    13. VMOV <Sd>, <Rm>
   (ARM reg to VFP single.)
    14. VMOV <Rd>, <Re>, <Sn>, <Sm>
   (Two ARM regs to two VFP singles.)
    15. VMOV <Sd>, <Se>, <Rn>, <Rm>
   (Two VFP singles to two ARM regs.)

   These cases can be disambiguated using neon_select_shape, except cases 1/9
   and 3/11 which depend on the operand type too.

   All the encoded bits are hardcoded by this function.

   Cases 4, 6 may be used with VFPv1 and above (only 32-bit transfers!).
   Cases 5, 7 may be used with VFPv2 and above.

   FIXME: Some of the checking may be a bit sloppy (in a couple of cases you
   can specify a type where it doesn't make sense to, and is ignored).  */

static void
do_neon_mov (void)
{
  enum neon_shape rs = neon_select_shape (NS_RRFF, NS_FFRR, NS_DRR, NS_RRD,
    NS_QQ, NS_DD, NS_QI, NS_DI, NS_SR, NS_RS, NS_FF, NS_FI, NS_RF, NS_FR,
    NS_NULL);
  struct neon_type_el et;
  const char *ldconst = 0;

  switch (rs)
    {
    case NS_DD:  /* case 1/9.  */
      et = neon_check_type (2, rs, N_EQK, N_F64 | N_KEY);
      /* It is not an error here if no type is given.  */
      inst.error = NULL;
      if (et.type == NT_float && et.size == 64)
	{
	  do_vfp_nsyn_opcode ("fcpyd");
	  break;
	}
      /* fall through.  */

    case NS_QQ:  /* case 0/1.  */
      {
	if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
	  return;
	/* The architecture manual I have doesn't explicitly state which
	   value the U bit should have for register->register moves, but
	   the equivalent VORR instruction has U = 0, so do that.  */
	inst.instruction = 0x0200110;
	inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
	inst.instruction |= HI1 (inst.operands[0].reg) << 22;
	inst.instruction |= LOW4 (inst.operands[1].reg);
	inst.instruction |= HI1 (inst.operands[1].reg) << 5;
	inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
	inst.instruction |= HI1 (inst.operands[1].reg) << 7;
	inst.instruction |= neon_quad (rs) << 6;

	neon_dp_fixup (&inst);
      }
      break;

    case NS_DI:  /* case 3/11.  */
      et = neon_check_type (2, rs, N_EQK, N_F64 | N_KEY);
      inst.error = NULL;
      if (et.type == NT_float && et.size == 64)
	{
	  /* case 11 (fconstd).  */
	  ldconst = "fconstd";
	  goto encode_fconstd;
	}
      /* fall through.  */

    case NS_QI:  /* case 2/3.  */
      if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
	return;
      inst.instruction = 0x0800010;
      neon_move_immediate ();
      neon_dp_fixup (&inst);
      break;

    case NS_SR:  /* case 4.  */
      {
	unsigned bcdebits = 0;
	int logsize;
	unsigned dn = NEON_SCALAR_REG (inst.operands[0].reg);
	unsigned x = NEON_SCALAR_INDEX (inst.operands[0].reg);

	/* .<size> is optional here, defaulting to .32. */
	if (inst.vectype.elems == 0
	    && inst.operands[0].vectype.type == NT_invtype
	    && inst.operands[1].vectype.type == NT_invtype)
	  {
	    inst.vectype.el[0].type = NT_untyped;
	    inst.vectype.el[0].size = 32;
	    inst.vectype.elems = 1;
	  }

	et = neon_check_type (2, NS_NULL, N_8 | N_16 | N_32 | N_KEY, N_EQK);
	logsize = neon_logbits (et.size);

	constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
		    _(BAD_FPU));
	constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
		    && et.size != 32, _(BAD_FPU));
	constraint (et.type == NT_invtype, _("bad type for scalar"));
	constraint (x >= 64 / et.size, _("scalar index out of range"));

	switch (et.size)
	  {
	  case 8:  bcdebits = 0x8; break;
	  case 16: bcdebits = 0x1; break;
	  case 32: bcdebits = 0x0; break;
	  default: ;
	  }

	bcdebits |= x << logsize;

	inst.instruction = 0xe000b10;
	do_vfp_cond_or_thumb ();
	inst.instruction |= LOW4 (dn) << 16;
	inst.instruction |= HI1 (dn) << 7;
	inst.instruction |= inst.operands[1].reg << 12;
	inst.instruction |= (bcdebits & 3) << 5;
	inst.instruction |= (bcdebits >> 2) << 21;
      }
      break;

    case NS_DRR:  /* case 5 (fmdrr).  */
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2),
		  _(BAD_FPU));

      inst.instruction = 0xc400b10;
      do_vfp_cond_or_thumb ();
      inst.instruction |= LOW4 (inst.operands[0].reg);
      inst.instruction |= HI1 (inst.operands[0].reg) << 5;
      inst.instruction |= inst.operands[1].reg << 12;
      inst.instruction |= inst.operands[2].reg << 16;
      break;

    case NS_RS:  /* case 6.  */
      {
	unsigned logsize;
	unsigned dn = NEON_SCALAR_REG (inst.operands[1].reg);
	unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg);
	unsigned abcdebits = 0;

	/* .<dt> is optional here, defaulting to .32. */
	if (inst.vectype.elems == 0
	    && inst.operands[0].vectype.type == NT_invtype
	    && inst.operands[1].vectype.type == NT_invtype)
	  {
	    inst.vectype.el[0].type = NT_untyped;
	    inst.vectype.el[0].size = 32;
	    inst.vectype.elems = 1;
	  }

	et = neon_check_type (2, NS_NULL,
			      N_EQK, N_S8 | N_S16 | N_U8 | N_U16 | N_32 | N_KEY);
	logsize = neon_logbits (et.size);

	constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
		    _(BAD_FPU));
	constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
		    && et.size != 32, _(BAD_FPU));
	constraint (et.type == NT_invtype, _("bad type for scalar"));
	constraint (x >= 64 / et.size, _("scalar index out of range"));

	switch (et.size)
	  {
	  case 8:  abcdebits = (et.type == NT_signed) ? 0x08 : 0x18; break;
	  case 16: abcdebits = (et.type == NT_signed) ? 0x01 : 0x11; break;
	  case 32: abcdebits = 0x00; break;
	  default: ;
	  }

	abcdebits |= x << logsize;
	inst.instruction = 0xe100b10;
	do_vfp_cond_or_thumb ();
	inst.instruction |= LOW4 (dn) << 16;
	inst.instruction |= HI1 (dn) << 7;
	inst.instruction |= inst.operands[0].reg << 12;
	inst.instruction |= (abcdebits & 3) << 5;
	inst.instruction |= (abcdebits >> 2) << 21;
      }
      break;

    case NS_RRD:  /* case 7 (fmrrd).  */
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2),
		  _(BAD_FPU));

      inst.instruction = 0xc500b10;
      do_vfp_cond_or_thumb ();
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= LOW4 (inst.operands[2].reg);
      inst.instruction |= HI1 (inst.operands[2].reg) << 5;
      break;

    case NS_FF:  /* case 8 (fcpys).  */
      do_vfp_nsyn_opcode ("fcpys");
      break;

    case NS_FI:  /* case 10 (fconsts).  */
      ldconst = "fconsts";
      encode_fconstd:
      if (is_quarter_float (inst.operands[1].imm))
	{
	  inst.operands[1].imm = neon_qfloat_bits (inst.operands[1].imm);
	  do_vfp_nsyn_opcode (ldconst);
	}
      else
	first_error (_("immediate out of range"));
      break;

    case NS_RF:  /* case 12 (fmrs).  */
      do_vfp_nsyn_opcode ("fmrs");
      break;

    case NS_FR:  /* case 13 (fmsr).  */
      do_vfp_nsyn_opcode ("fmsr");
      break;

    /* The encoders for the fmrrs and fmsrr instructions expect three operands
       (one of which is a list), but we have parsed four.  Do some fiddling to
       make the operands what do_vfp_reg2_from_sp2 and do_vfp_sp2_from_reg2
       expect.  */
    case NS_RRFF:  /* case 14 (fmrrs).  */
      constraint (inst.operands[3].reg != inst.operands[2].reg + 1,
		  _("VFP registers must be adjacent"));
      inst.operands[2].imm = 2;
      memset (&inst.operands[3], '\0', sizeof (inst.operands[3]));
      do_vfp_nsyn_opcode ("fmrrs");
      break;

    case NS_FFRR:  /* case 15 (fmsrr).  */
      constraint (inst.operands[1].reg != inst.operands[0].reg + 1,
		  _("VFP registers must be adjacent"));
      inst.operands[1] = inst.operands[2];
      inst.operands[2] = inst.operands[3];
      inst.operands[0].imm = 2;
      memset (&inst.operands[3], '\0', sizeof (inst.operands[3]));
      do_vfp_nsyn_opcode ("fmsrr");
      break;

    case NS_NULL:
      /* neon_select_shape has determined that the instruction
	 shape is wrong and has already set the error message.  */
      break;

    default:
      abort ();
    }
}

static void
do_neon_rshift_round_imm (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_ALL | N_KEY);
  int imm = inst.operands[2].imm;

  /* imm == 0 case is encoded as VMOV for V{R}SHR.  */
  if (imm == 0)
    {
      inst.operands[2].present = 0;
      do_neon_mov ();
      return;
    }

  constraint (imm < 1 || (unsigned)imm > et.size,
	      _("immediate out of range for shift"));
  neon_imm_shift (TRUE, et.type == NT_unsigned, neon_quad (rs), et,
		  et.size - imm);
}

static void
do_neon_movl (void)
{
  struct neon_type_el et = neon_check_type (2, NS_QD,
    N_EQK | N_DBL, N_SU_32 | N_KEY);
  unsigned sizebits = et.size >> 3;
  inst.instruction |= sizebits << 19;
  neon_two_same (0, et.type == NT_unsigned, -1);
}

static void
do_neon_trn (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_KEY);
  NEON_ENCODE (INTEGER, inst);
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_zip_uzp (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_KEY);
  if (rs == NS_DD && et.size == 32)
    {
      /* Special case: encode as VTRN.32 <Dd>, <Dm>.  */
      inst.instruction = N_MNEM_vtrn;
      do_neon_trn ();
      return;
    }
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_sat_abs_neg (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_S8 | N_S16 | N_S32 | N_KEY);
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_pair_long (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_32 | N_KEY);
  /* Unsigned is encoded in OP field (bit 7) for these instruction.  */
  inst.instruction |= (et.type == NT_unsigned) << 7;
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_recip_est (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK | N_FLT, N_F32 | N_U32 | N_KEY);
  inst.instruction |= (et.type == NT_float) << 8;
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_cls (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_S8 | N_S16 | N_S32 | N_KEY);
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_clz (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_I8 | N_I16 | N_I32 | N_KEY);
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_cnt (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK | N_INT, N_8 | N_KEY);
  neon_two_same (neon_quad (rs), 1, et.size);
}

static void
do_neon_swp (void)
{
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  neon_two_same (neon_quad (rs), 1, -1);
}

static void
do_neon_tbl_tbx (void)
{
  unsigned listlenbits;
  neon_check_type (3, NS_DLD, N_EQK, N_EQK, N_8 | N_KEY);

  if (inst.operands[1].imm < 1 || inst.operands[1].imm > 4)
    {
      first_error (_("bad list length for table lookup"));
      return;
    }

  listlenbits = inst.operands[1].imm - 1;
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= listlenbits << 8;

  neon_dp_fixup (&inst);
}

static void
do_neon_ldm_stm (void)
{
  /* P, U and L bits are part of bitmask.  */
  int is_dbmode = (inst.instruction & (1 << 24)) != 0;
  unsigned offsetbits = inst.operands[1].imm * 2;

  if (inst.operands[1].issingle)
    {
      do_vfp_nsyn_ldm_stm (is_dbmode);
      return;
    }

  constraint (is_dbmode && !inst.operands[0].writeback,
	      _("writeback (!) must be used for VLDMDB and VSTMDB"));

  constraint (inst.operands[1].imm < 1 || inst.operands[1].imm > 16,
	      _("register list must contain at least 1 and at most 16 "
		"registers"));

  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[0].writeback << 21;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 12;
  inst.instruction |= HI1 (inst.operands[1].reg) << 22;

  inst.instruction |= offsetbits;

  do_vfp_cond_or_thumb ();
}

static void
do_neon_ldr_str (void)
{
  int is_ldr = (inst.instruction & (1 << 20)) != 0;

  /* Use of PC in vstr in ARM mode is deprecated in ARMv7.
     And is UNPREDICTABLE in thumb mode.  */
  if (!is_ldr
      && inst.operands[1].reg == REG_PC
      && (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v7) || thumb_mode))
    {
      if (thumb_mode)
	inst.error = _("Use of PC here is UNPREDICTABLE");
      else if (warn_on_deprecated)
	as_warn (_("Use of PC here is deprecated"));
    }

  if (inst.operands[0].issingle)
    {
      if (is_ldr)
	do_vfp_nsyn_opcode ("flds");
      else
	do_vfp_nsyn_opcode ("fsts");
    }
  else
    {
      if (is_ldr)
	do_vfp_nsyn_opcode ("fldd");
      else
	do_vfp_nsyn_opcode ("fstd");
    }
}

/* "interleave" version also handles non-interleaving register VLD1/VST1
   instructions.  */

static void
do_neon_ld_st_interleave (void)
{
  struct neon_type_el et = neon_check_type (1, NS_NULL,
					    N_8 | N_16 | N_32 | N_64);
  unsigned alignbits = 0;
  unsigned idx;
  /* The bits in this table go:
     0: register stride of one (0) or two (1)
     1,2: register list length, minus one (1, 2, 3, 4).
     3,4: <n> in instruction type, minus one (VLD<n> / VST<n>).
     We use -1 for invalid entries.  */
  const int typetable[] =
    {
      0x7,  -1, 0xa,  -1, 0x6,  -1, 0x2,  -1, /* VLD1 / VST1.  */
       -1,  -1, 0x8, 0x9,  -1,  -1, 0x3,  -1, /* VLD2 / VST2.  */
       -1,  -1,  -1,  -1, 0x4, 0x5,  -1,  -1, /* VLD3 / VST3.  */
       -1,  -1,  -1,  -1,  -1,  -1, 0x0, 0x1  /* VLD4 / VST4.  */
    };
  int typebits;

  if (et.type == NT_invtype)
    return;

  if (inst.operands[1].immisalign)
    switch (inst.operands[1].imm >> 8)
      {
      case 64: alignbits = 1; break;
      case 128:
	if (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 2
	    && NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4)
	  goto bad_alignment;
	alignbits = 2;
	break;
      case 256:
	if (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4)
	  goto bad_alignment;
	alignbits = 3;
	break;
      default:
      bad_alignment:
	first_error (_("bad alignment"));
	return;
      }

  inst.instruction |= alignbits << 4;
  inst.instruction |= neon_logbits (et.size) << 6;

  /* Bits [4:6] of the immediate in a list specifier encode register stride
     (minus 1) in bit 4, and list length in bits [5:6]. We put the <n> of
     VLD<n>/VST<n> in bits [9:8] of the initial bitmask. Suck it out here, look
     up the right value for "type" in a table based on this value and the given
     list style, then stick it back.  */
  idx = ((inst.operands[0].imm >> 4) & 7)
	| (((inst.instruction >> 8) & 3) << 3);

  typebits = typetable[idx];

  constraint (typebits == -1, _("bad list type for instruction"));
  constraint (((inst.instruction >> 8) & 3) && et.size == 64,
	      _("bad element type for instruction"));

  inst.instruction &= ~0xf00;
  inst.instruction |= typebits << 8;
}

/* Check alignment is valid for do_neon_ld_st_lane and do_neon_ld_dup.
   *DO_ALIGN is set to 1 if the relevant alignment bit should be set, 0
   otherwise. The variable arguments are a list of pairs of legal (size, align)
   values, terminated with -1.  */

static int
neon_alignment_bit (int size, int align, int *do_align, ...)
{
  va_list ap;
  int result = FAIL, thissize, thisalign;

  if (!inst.operands[1].immisalign)
    {
      *do_align = 0;
      return SUCCESS;
    }

  va_start (ap, do_align);

  do
    {
      thissize = va_arg (ap, int);
      if (thissize == -1)
	break;
      thisalign = va_arg (ap, int);

      if (size == thissize && align == thisalign)
	result = SUCCESS;
    }
  while (result != SUCCESS);

  va_end (ap);

  if (result == SUCCESS)
    *do_align = 1;
  else
    first_error (_("unsupported alignment for instruction"));

  return result;
}

static void
do_neon_ld_st_lane (void)
{
  struct neon_type_el et = neon_check_type (1, NS_NULL, N_8 | N_16 | N_32);
  int align_good, do_align = 0;
  int logsize = neon_logbits (et.size);
  int align = inst.operands[1].imm >> 8;
  int n = (inst.instruction >> 8) & 3;
  int max_el = 64 / et.size;

  if (et.type == NT_invtype)
    return;

  constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != n + 1,
	      _("bad list length"));
  constraint (NEON_LANE (inst.operands[0].imm) >= max_el,
	      _("scalar index out of range"));
  constraint (n != 0 && NEON_REG_STRIDE (inst.operands[0].imm) == 2
	      && et.size == 8,
	      _("stride of 2 unavailable when element size is 8"));

  switch (n)
    {
    case 0:  /* VLD1 / VST1.  */
      align_good = neon_alignment_bit (et.size, align, &do_align, 16, 16,
				       32, 32, -1);
      if (align_good == FAIL)
	return;
      if (do_align)
	{
	  unsigned alignbits = 0;
	  switch (et.size)
	    {
	    case 16: alignbits = 0x1; break;
	    case 32: alignbits = 0x3; break;
	    default: ;
	    }
	  inst.instruction |= alignbits << 4;
	}
      break;

    case 1:  /* VLD2 / VST2.  */
      align_good = neon_alignment_bit (et.size, align, &do_align, 8, 16, 16, 32,
				       32, 64, -1);
      if (align_good == FAIL)
	return;
      if (do_align)
	inst.instruction |= 1 << 4;
      break;

    case 2:  /* VLD3 / VST3.  */
      constraint (inst.operands[1].immisalign,
		  _("can't use alignment with this instruction"));
      break;

    case 3:  /* VLD4 / VST4.  */
      align_good = neon_alignment_bit (et.size, align, &do_align, 8, 32,
				       16, 64, 32, 64, 32, 128, -1);
      if (align_good == FAIL)
	return;
      if (do_align)
	{
	  unsigned alignbits = 0;
	  switch (et.size)
	    {
	    case 8:  alignbits = 0x1; break;
	    case 16: alignbits = 0x1; break;
	    case 32: alignbits = (align == 64) ? 0x1 : 0x2; break;
	    default: ;
	    }
	  inst.instruction |= alignbits << 4;
	}
      break;

    default: ;
    }

  /* Reg stride of 2 is encoded in bit 5 when size==16, bit 6 when size==32.  */
  if (n != 0 && NEON_REG_STRIDE (inst.operands[0].imm) == 2)
    inst.instruction |= 1 << (4 + logsize);

  inst.instruction |= NEON_LANE (inst.operands[0].imm) << (logsize + 5);
  inst.instruction |= logsize << 10;
}

/* Encode single n-element structure to all lanes VLD<n> instructions.  */

static void
do_neon_ld_dup (void)
{
  struct neon_type_el et = neon_check_type (1, NS_NULL, N_8 | N_16 | N_32);
  int align_good, do_align = 0;

  if (et.type == NT_invtype)
    return;

  switch ((inst.instruction >> 8) & 3)
    {
    case 0:  /* VLD1.  */
      gas_assert (NEON_REG_STRIDE (inst.operands[0].imm) != 2);
      align_good = neon_alignment_bit (et.size, inst.operands[1].imm >> 8,
				       &do_align, 16, 16, 32, 32, -1);
      if (align_good == FAIL)
	return;
      switch (NEON_REGLIST_LENGTH (inst.operands[0].imm))
	{
	case 1: break;
	case 2: inst.instruction |= 1 << 5; break;
	default: first_error (_("bad list length")); return;
	}
      inst.instruction |= neon_logbits (et.size) << 6;
      break;

    case 1:  /* VLD2.  */
      align_good = neon_alignment_bit (et.size, inst.operands[1].imm >> 8,
				       &do_align, 8, 16, 16, 32, 32, 64, -1);
      if (align_good == FAIL)
	return;
      constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 2,
		  _("bad list length"));
      if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
	inst.instruction |= 1 << 5;
      inst.instruction |= neon_logbits (et.size) << 6;
      break;

    case 2:  /* VLD3.  */
      constraint (inst.operands[1].immisalign,
		  _("can't use alignment with this instruction"));
      constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 3,
		  _("bad list length"));
      if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
	inst.instruction |= 1 << 5;
      inst.instruction |= neon_logbits (et.size) << 6;
      break;

    case 3:  /* VLD4.  */
      {
	int align = inst.operands[1].imm >> 8;
	align_good = neon_alignment_bit (et.size, align, &do_align, 8, 32,
					 16, 64, 32, 64, 32, 128, -1);
	if (align_good == FAIL)
	  return;
	constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4,
		    _("bad list length"));
	if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
	  inst.instruction |= 1 << 5;
	if (et.size == 32 && align == 128)
	  inst.instruction |= 0x3 << 6;
	else
	  inst.instruction |= neon_logbits (et.size) << 6;
      }
      break;

    default: ;
    }

  inst.instruction |= do_align << 4;
}

/* Disambiguate VLD<n> and VST<n> instructions, and fill in common bits (those
   apart from bits [11:4].  */

static void
do_neon_ldx_stx (void)
{
  if (inst.operands[1].isreg)
    constraint (inst.operands[1].reg == REG_PC, BAD_PC);

  switch (NEON_LANE (inst.operands[0].imm))
    {
    case NEON_INTERLEAVE_LANES:
      NEON_ENCODE (INTERLV, inst);
      do_neon_ld_st_interleave ();
      break;

    case NEON_ALL_LANES:
      NEON_ENCODE (DUP, inst);
      if (inst.instruction == N_INV)
	{
	  first_error ("only loads support such operands");
	  break;
	}
      do_neon_ld_dup ();
      break;

    default:
      NEON_ENCODE (LANE, inst);
      do_neon_ld_st_lane ();
    }

  /* L bit comes from bit mask.  */
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= inst.operands[1].reg << 16;

  if (inst.operands[1].postind)
    {
      int postreg = inst.operands[1].imm & 0xf;
      constraint (!inst.operands[1].immisreg,
		  _("post-index must be a register"));
      constraint (postreg == 0xd || postreg == 0xf,
		  _("bad register for post-index"));
      inst.instruction |= postreg;
    }
  else
    {
      constraint (inst.operands[1].immisreg, BAD_ADDR_MODE);
      constraint (inst.reloc.exp.X_op != O_constant
		  || inst.reloc.exp.X_add_number != 0,
		  BAD_ADDR_MODE);

      if (inst.operands[1].writeback)
	{
	  inst.instruction |= 0xd;
	}
      else
	inst.instruction |= 0xf;
    }

  if (thumb_mode)
    inst.instruction |= 0xf9000000;
  else
    inst.instruction |= 0xf4000000;
}

/* FP v8.  */
static void
do_vfp_nsyn_fpv8 (enum neon_shape rs)
{
  NEON_ENCODE (FPV8, inst);

  if (rs == NS_FFF)
    do_vfp_sp_dyadic ();
  else
    do_vfp_dp_rd_rn_rm ();

  if (rs == NS_DDD)
    inst.instruction |= 0x100;

  inst.instruction |= 0xf0000000;
}

static void
do_vsel (void)
{
  set_it_insn_type (OUTSIDE_IT_INSN);

  if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) != SUCCESS)
    first_error (_("invalid instruction shape"));
}

static void
do_vmaxnm (void)
{
  set_it_insn_type (OUTSIDE_IT_INSN);

  if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
    return;

  neon_dyadic_misc (NT_untyped, N_F32, 0);
}

static void
do_vrint_1 (enum neon_cvt_mode mode)
{
  enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et;

  if (rs == NS_NULL)
    return;

  et = neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
  if (et.type != NT_invtype)
    {
      /* VFP encodings.  */
      if (mode == neon_cvt_mode_a || mode == neon_cvt_mode_n
	  || mode == neon_cvt_mode_p || mode == neon_cvt_mode_m)
	set_it_insn_type (OUTSIDE_IT_INSN);

      NEON_ENCODE (FPV8, inst);
      if (rs == NS_FF)
	do_vfp_sp_monadic ();
      else
	do_vfp_dp_rd_rm ();

      switch (mode)
	{
	case neon_cvt_mode_r: inst.instruction |= 0x00000000; break;
	case neon_cvt_mode_z: inst.instruction |= 0x00000080; break;
	case neon_cvt_mode_x: inst.instruction |= 0x00010000; break;
	case neon_cvt_mode_a: inst.instruction |= 0xf0000000; break;
	case neon_cvt_mode_n: inst.instruction |= 0xf0010000; break;
	case neon_cvt_mode_p: inst.instruction |= 0xf0020000; break;
	case neon_cvt_mode_m: inst.instruction |= 0xf0030000; break;
	default: abort ();
	}

      inst.instruction |= (rs == NS_DD) << 8;
      do_vfp_cond_or_thumb ();
    }
  else
    {
      /* Neon encodings (or something broken...).  */
      inst.error = NULL;
      et = neon_check_type (2, rs, N_EQK, N_F32 | N_KEY);

      if (et.type == NT_invtype)
	return;

      set_it_insn_type (OUTSIDE_IT_INSN);
      NEON_ENCODE (FLOAT, inst);

      if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
	return;

      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= neon_quad (rs) << 6;
      switch (mode)
	{
	case neon_cvt_mode_z: inst.instruction |= 3 << 7; break;
	case neon_cvt_mode_x: inst.instruction |= 1 << 7; break;
	case neon_cvt_mode_a: inst.instruction |= 2 << 7; break;
	case neon_cvt_mode_n: inst.instruction |= 0 << 7; break;
	case neon_cvt_mode_p: inst.instruction |= 7 << 7; break;
	case neon_cvt_mode_m: inst.instruction |= 5 << 7; break;
	case neon_cvt_mode_r: inst.error = _("invalid rounding mode"); break;
	default: abort ();
	}

      if (thumb_mode)
	inst.instruction |= 0xfc000000;
      else
	inst.instruction |= 0xf0000000;
    }
}

static void
do_vrintx (void)
{
  do_vrint_1 (neon_cvt_mode_x);
}

static void
do_vrintz (void)
{
  do_vrint_1 (neon_cvt_mode_z);
}

static void
do_vrintr (void)
{
  do_vrint_1 (neon_cvt_mode_r);
}

static void
do_vrinta (void)
{
  do_vrint_1 (neon_cvt_mode_a);
}

static void
do_vrintn (void)
{
  do_vrint_1 (neon_cvt_mode_n);
}

static void
do_vrintp (void)
{
  do_vrint_1 (neon_cvt_mode_p);
}

static void
do_vrintm (void)
{
  do_vrint_1 (neon_cvt_mode_m);
}

/* Crypto v1 instructions.  */
static void
do_crypto_2op_1 (unsigned elttype, int op)
{
  set_it_insn_type (OUTSIDE_IT_INSN);

  if (neon_check_type (2, NS_QQ, N_EQK | N_UNT, elttype | N_UNT | N_KEY).type
      == NT_invtype)
    return;

  inst.error = NULL;

  NEON_ENCODE (INTEGER, inst);
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg);
  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
  if (op != -1)
    inst.instruction |= op << 6;

  if (thumb_mode)
    inst.instruction |= 0xfc000000;
  else
    inst.instruction |= 0xf0000000;
}

static void
do_crypto_3op_1 (int u, int op)
{
  set_it_insn_type (OUTSIDE_IT_INSN);

  if (neon_check_type (3, NS_QQQ, N_EQK | N_UNT, N_EQK | N_UNT,
		       N_32 | N_UNT | N_KEY).type == NT_invtype)
    return;

  inst.error = NULL;

  NEON_ENCODE (INTEGER, inst);
  neon_three_same (1, u, 8 << op);
}

static void
do_aese (void)
{
  do_crypto_2op_1 (N_8, 0);
}

static void
do_aesd (void)
{
  do_crypto_2op_1 (N_8, 1);
}

static void
do_aesmc (void)
{
  do_crypto_2op_1 (N_8, 2);
}

static void
do_aesimc (void)
{
  do_crypto_2op_1 (N_8, 3);
}

static void
do_sha1c (void)
{
  do_crypto_3op_1 (0, 0);
}

static void
do_sha1p (void)
{
  do_crypto_3op_1 (0, 1);
}

static void
do_sha1m (void)
{
  do_crypto_3op_1 (0, 2);
}

static void
do_sha1su0 (void)
{
  do_crypto_3op_1 (0, 3);
}

static void
do_sha256h (void)
{
  do_crypto_3op_1 (1, 0);
}

static void
do_sha256h2 (void)
{
  do_crypto_3op_1 (1, 1);
}

static void
do_sha256su1 (void)
{
  do_crypto_3op_1 (1, 2);
}

static void
do_sha1h (void)
{
  do_crypto_2op_1 (N_32, -1);
}

static void
do_sha1su1 (void)
{
  do_crypto_2op_1 (N_32, 0);
}

static void
do_sha256su0 (void)
{
  do_crypto_2op_1 (N_32, 1);
}

static void
do_crc32_1 (unsigned int poly, unsigned int sz)
{
  unsigned int Rd = inst.operands[0].reg;
  unsigned int Rn = inst.operands[1].reg;
  unsigned int Rm = inst.operands[2].reg;

  set_it_insn_type (OUTSIDE_IT_INSN);
  inst.instruction |= LOW4 (Rd) << (thumb_mode ? 8 : 12);
  inst.instruction |= LOW4 (Rn) << 16;
  inst.instruction |= LOW4 (Rm);
  inst.instruction |= sz << (thumb_mode ? 4 : 21);
  inst.instruction |= poly << (thumb_mode ? 20 : 9);

  if (Rd == REG_PC || Rn == REG_PC || Rm == REG_PC)
    as_warn (UNPRED_REG ("r15"));
  if (thumb_mode && (Rd == REG_SP || Rn == REG_SP || Rm == REG_SP))
    as_warn (UNPRED_REG ("r13"));
}

static void
do_crc32b (void)
{
  do_crc32_1 (0, 0);
}

static void
do_crc32h (void)
{
  do_crc32_1 (0, 1);
}

static void
do_crc32w (void)
{
  do_crc32_1 (0, 2);
}

static void
do_crc32cb (void)
{
  do_crc32_1 (1, 0);
}

static void
do_crc32ch (void)
{
  do_crc32_1 (1, 1);
}

static void
do_crc32cw (void)
{
  do_crc32_1 (1, 2);
}


/* Overall per-instruction processing.	*/

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.	We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */

static void
fix_new_arm (fragS *	   frag,
	     int	   where,
	     short int	   size,
	     expressionS * exp,
	     int	   pc_rel,
	     int	   reloc)
{
  fixS *	   new_fix;

  switch (exp->X_op)
    {
    case O_constant:
      if (pc_rel)
	{
	  /* Create an absolute valued symbol, so we have something to
	     refer to in the object file.  Unfortunately for us, gas's
	     generic expression parsing will already have folded out
	     any use of .set foo/.type foo %function that may have
	     been used to set type information of the target location,
	     that's being specified symbolically.  We have to presume
	     the user knows what they are doing.  */
	  char name[16 + 8];
	  symbolS *symbol;

	  sprintf (name, "*ABS*0x%lx", (unsigned long)exp->X_add_number);

	  symbol = symbol_find_or_make (name);
	  S_SET_SEGMENT (symbol, absolute_section);
	  symbol_set_frag (symbol, &zero_address_frag);
	  S_SET_VALUE (symbol, exp->X_add_number);
	  exp->X_op = O_symbol;
	  exp->X_add_symbol = symbol;
	  exp->X_add_number = 0;
	}
      /* FALLTHROUGH */
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel,
			     (enum bfd_reloc_code_real) reloc);
      break;

    default:
      new_fix = (fixS *) fix_new (frag, where, size, make_expr_symbol (exp), 0,
				  pc_rel, (enum bfd_reloc_code_real) reloc);
      break;
    }

  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  new_fix->tc_fix_data = thumb_mode;
}

/* Create a frg for an instruction requiring relaxation.  */
static void
output_relax_insn (void)
{
  char * to;
  symbolS *sym;
  int offset;

  /* The size of the instruction is unknown, so tie the debug info to the
     start of the instruction.  */
  dwarf2_emit_insn (0);

  switch (inst.reloc.exp.X_op)
    {
    case O_symbol:
      sym = inst.reloc.exp.X_add_symbol;
      offset = inst.reloc.exp.X_add_number;
      break;
    case O_constant:
      sym = NULL;
      offset = inst.reloc.exp.X_add_number;
      break;
    default:
      sym = make_expr_symbol (&inst.reloc.exp);
      offset = 0;
      break;
  }
  to = frag_var (rs_machine_dependent, INSN_SIZE, THUMB_SIZE,
		 inst.relax, sym, offset, NULL/*offset, opcode*/);
  md_number_to_chars (to, inst.instruction, THUMB_SIZE);
}

/* Write a 32-bit thumb instruction to buf.  */
static void
put_thumb32_insn (char * buf, unsigned long insn)
{
  md_number_to_chars (buf, insn >> 16, THUMB_SIZE);
  md_number_to_chars (buf + THUMB_SIZE, insn, THUMB_SIZE);
}

static void
output_inst (const char * str)
{
  char * to = NULL;

  if (inst.error)
    {
      as_bad ("%s -- `%s'", inst.error, str);
      return;
    }
  if (inst.relax)
    {
      output_relax_insn ();
      return;
    }
  if (inst.size == 0)
    return;

  to = frag_more (inst.size);
  /* PR 9814: Record the thumb mode into the current frag so that we know
     what type of NOP padding to use, if necessary.  We override any previous
     setting so that if the mode has changed then the NOPS that we use will
     match the encoding of the last instruction in the frag.  */
  frag_now->tc_frag_data.thumb_mode = thumb_mode | MODE_RECORDED;

  if (thumb_mode && (inst.size > THUMB_SIZE))
    {
      gas_assert (inst.size == (2 * THUMB_SIZE));
      put_thumb32_insn (to, inst.instruction);
    }
  else if (inst.size > INSN_SIZE)
    {
      gas_assert (inst.size == (2 * INSN_SIZE));
      md_number_to_chars (to, inst.instruction, INSN_SIZE);
      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
    }
  else
    md_number_to_chars (to, inst.instruction, inst.size);

  if (inst.reloc.type != BFD_RELOC_UNUSED)
    fix_new_arm (frag_now, to - frag_now->fr_literal,
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
		 inst.reloc.type);

  dwarf2_emit_insn (inst.size);
}

static char *
output_it_inst (int cond, int mask, char * to)
{
  unsigned long instruction = 0xbf00;

  mask &= 0xf;
  instruction |= mask;
  instruction |= cond << 4;

  if (to == NULL)
    {
      to = frag_more (2);
#ifdef OBJ_ELF
      dwarf2_emit_insn (2);
#endif
    }

  md_number_to_chars (to, instruction, 2);

  return to;
}

/* Tag values used in struct asm_opcode's tag field.  */
enum opcode_tag
{
  OT_unconditional,	/* Instruction cannot be conditionalized.
			   The ARM condition field is still 0xE.  */
  OT_unconditionalF,	/* Instruction cannot be conditionalized
			   and carries 0xF in its ARM condition field.  */
  OT_csuffix,		/* Instruction takes a conditional suffix.  */
  OT_csuffixF,		/* Some forms of the instruction take a conditional
			   suffix, others place 0xF where the condition field
			   would be.  */
  OT_cinfix3,		/* Instruction takes a conditional infix,
			   beginning at character index 3.  (In
			   unified mode, it becomes a suffix.)  */
  OT_cinfix3_deprecated, /* The same as OT_cinfix3.  This is used for
			    tsts, cmps, cmns, and teqs. */
  OT_cinfix3_legacy,	/* Legacy instruction takes a conditional infix at
			   character index 3, even in unified mode.  Used for
			   legacy instructions where suffix and infix forms
			   may be ambiguous.  */
  OT_csuf_or_in3,	/* Instruction takes either a conditional
			   suffix or an infix at character index 3.  */
  OT_odd_infix_unc,	/* This is the unconditional variant of an
			   instruction that takes a conditional infix
			   at an unusual position.  In unified mode,
			   this variant will accept a suffix.  */
  OT_odd_infix_0	/* Values greater than or equal to OT_odd_infix_0
			   are the conditional variants of instructions that
			   take conditional infixes in unusual positions.
			   The infix appears at character index
			   (tag - OT_odd_infix_0).  These are not accepted
			   in unified mode.  */
};

/* Subroutine of md_assemble, responsible for looking up the primary
   opcode from the mnemonic the user wrote.  STR points to the
   beginning of the mnemonic.

   This is not simply a hash table lookup, because of conditional
   variants.  Most instructions have conditional variants, which are
   expressed with a _conditional affix_ to the mnemonic.  If we were
   to encode each conditional variant as a literal string in the opcode
   table, it would have approximately 20,000 entries.

   Most mnemonics take this affix as a suffix, and in unified syntax,
   'most' is upgraded to 'all'.  However, in the divided syntax, some
   instructions take the affix as an infix, notably the s-variants of
   the arithmetic instructions.  Of those instructions, all but six
   have the infix appear after the third character of the mnemonic.

   Accordingly, the algorithm for looking up primary opcodes given
   an identifier is:

   1. Look up the identifier in the opcode table.
      If we find a match, go to step U.

   2. Look up the last two characters of the identifier in the
      conditions table.  If we find a match, look up the first N-2
      characters of the identifier in the opcode table.  If we
      find a match, go to step CE.

   3. Look up the fourth and fifth characters of the identifier in
      the conditions table.  If we find a match, extract those
      characters from the identifier, and look up the remaining
      characters in the opcode table.  If we find a match, go
      to step CM.

   4. Fail.

   U. Examine the tag field of the opcode structure, in case this is
      one of the six instructions with its conditional infix in an
      unusual place.  If it is, the tag tells us where to find the
      infix; look it up in the conditions table and set inst.cond
      accordingly.  Otherwise, this is an unconditional instruction.
      Again set inst.cond accordingly.  Return the opcode structure.

  CE. Examine the tag field to make sure this is an instruction that
      should receive a conditional suffix.  If it is not, fail.
      Otherwise, set inst.cond from the suffix we already looked up,
      and return the opcode structure.

  CM. Examine the tag field to make sure this is an instruction that
      should receive a conditional infix after the third character.
      If it is not, fail.  Otherwise, undo the edits to the current
      line of input and proceed as for case CE.  */

static const struct asm_opcode *
opcode_lookup (char **str)
{
  char *end, *base;
  char *affix;
  const struct asm_opcode *opcode;
  const struct asm_cond *cond;
  char save[2];

  /* Scan up to the end of the mnemonic, which must end in white space,
     '.' (in unified mode, or for Neon/VFP instructions), or end of string.  */
  for (base = end = *str; *end != '\0'; end++)
    if (*end == ' ' || *end == '.')
      break;

  if (end == base)
    return NULL;

  /* Handle a possible width suffix and/or Neon type suffix.  */
  if (end[0] == '.')
    {
      int offset = 2;

      /* The .w and .n suffixes are only valid if the unified syntax is in
	 use.  */
      if (unified_syntax && end[1] == 'w')
	inst.size_req = 4;
      else if (unified_syntax && end[1] == 'n')
	inst.size_req = 2;
      else
	offset = 0;

      inst.vectype.elems = 0;

      *str = end + offset;

      if (end[offset] == '.')
	{
	  /* See if we have a Neon type suffix (possible in either unified or
	     non-unified ARM syntax mode).  */
	  if (parse_neon_type (&inst.vectype, str) == FAIL)
	    return NULL;
	}
      else if (end[offset] != '\0' && end[offset] != ' ')
	return NULL;
    }
  else
    *str = end;

  /* Look for unaffixed or special-case affixed mnemonic.  */
  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
						    end - base);
  if (opcode)
    {
      /* step U */
      if (opcode->tag < OT_odd_infix_0)
	{
	  inst.cond = COND_ALWAYS;
	  return opcode;
	}

      if (warn_on_deprecated && unified_syntax)
	as_warn (_("conditional infixes are deprecated in unified syntax"));
      affix = base + (opcode->tag - OT_odd_infix_0);
      cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
      gas_assert (cond);

      inst.cond = cond->value;
      return opcode;
    }

  /* Cannot have a conditional suffix on a mnemonic of less than two
     characters.  */
  if (end - base < 3)
    return NULL;

  /* Look for suffixed mnemonic.  */
  affix = end - 2;
  cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
						    affix - base);
  if (opcode && cond)
    {
      /* step CE */
      switch (opcode->tag)
	{
	case OT_cinfix3_legacy:
	  /* Ignore conditional suffixes matched on infix only mnemonics.  */
	  break;

	case OT_cinfix3:
	case OT_cinfix3_deprecated:
	case OT_odd_infix_unc:
	  if (!unified_syntax)
	    return 0;
	  /* else fall through */

	case OT_csuffix:
	case OT_csuffixF:
	case OT_csuf_or_in3:
	  inst.cond = cond->value;
	  return opcode;

	case OT_unconditional:
	case OT_unconditionalF:
	  if (thumb_mode)
	    inst.cond = cond->value;
	  else
	    {
	      /* Delayed diagnostic.  */
	      inst.error = BAD_COND;
	      inst.cond = COND_ALWAYS;
	    }
	  return opcode;

	default:
	  return NULL;
	}
    }

  /* Cannot have a usual-position infix on a mnemonic of less than
     six characters (five would be a suffix).  */
  if (end - base < 6)
    return NULL;

  /* Look for infixed mnemonic in the usual position.  */
  affix = base + 3;
  cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
  if (!cond)
    return NULL;

  memcpy (save, affix, 2);
  memmove (affix, affix + 2, (end - affix) - 2);
  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
						    (end - base) - 2);
  memmove (affix + 2, affix, (end - affix) - 2);
  memcpy (affix, save, 2);

  if (opcode
      && (opcode->tag == OT_cinfix3
	  || opcode->tag == OT_cinfix3_deprecated
	  || opcode->tag == OT_csuf_or_in3
	  || opcode->tag == OT_cinfix3_legacy))
    {
      /* Step CM.  */
      if (warn_on_deprecated && unified_syntax
	  && (opcode->tag == OT_cinfix3
	      || opcode->tag == OT_cinfix3_deprecated))
	as_warn (_("conditional infixes are deprecated in unified syntax"));

      inst.cond = cond->value;
      return opcode;
    }

  return NULL;
}

/* This function generates an initial IT instruction, leaving its block
   virtually open for the new instructions. Eventually,
   the mask will be updated by now_it_add_mask () each time
   a new instruction needs to be included in the IT block.
   Finally, the block is closed with close_automatic_it_block ().
   The block closure can be requested either from md_assemble (),
   a tencode (), or due to a label hook.  */

static void
new_automatic_it_block (int cond)
{
  now_it.state = AUTOMATIC_IT_BLOCK;
  now_it.mask = 0x18;
  now_it.cc = cond;
  now_it.block_length = 1;
  mapping_state (MAP_THUMB);
  now_it.insn = output_it_inst (cond, now_it.mask, NULL);
  now_it.warn_deprecated = FALSE;
  now_it.insn_cond = TRUE;
}

/* Close an automatic IT block.
   See comments in new_automatic_it_block ().  */

static void
close_automatic_it_block (void)
{
  now_it.mask = 0x10;
  now_it.block_length = 0;
}

/* Update the mask of the current automatically-generated IT
   instruction. See comments in new_automatic_it_block ().  */

static void
now_it_add_mask (int cond)
{
#define CLEAR_BIT(value, nbit)  ((value) & ~(1 << (nbit)))
#define SET_BIT_VALUE(value, bitvalue, nbit)  (CLEAR_BIT (value, nbit) \
					      | ((bitvalue) << (nbit)))
  const int resulting_bit = (cond & 1);

  now_it.mask &= 0xf;
  now_it.mask = SET_BIT_VALUE (now_it.mask,
				   resulting_bit,
				  (5 - now_it.block_length));
  now_it.mask = SET_BIT_VALUE (now_it.mask,
				   1,
				   ((5 - now_it.block_length) - 1) );
  output_it_inst (now_it.cc, now_it.mask, now_it.insn);

#undef CLEAR_BIT
#undef SET_BIT_VALUE
}

/* The IT blocks handling machinery is accessed through the these functions:
     it_fsm_pre_encode ()               from md_assemble ()
     set_it_insn_type ()                optional, from the tencode functions
     set_it_insn_type_last ()           ditto
     in_it_block ()                     ditto
     it_fsm_post_encode ()              from md_assemble ()
     force_automatic_it_block_close ()  from label habdling functions

   Rationale:
     1) md_assemble () calls it_fsm_pre_encode () before calling tencode (),
	initializing the IT insn type with a generic initial value depending
	on the inst.condition.
     2) During the tencode function, two things may happen:
	a) The tencode function overrides the IT insn type by
	   calling either set_it_insn_type (type) or set_it_insn_type_last ().
	b) The tencode function queries the IT block state by
	   calling in_it_block () (i.e. to determine narrow/not narrow mode).

	Both set_it_insn_type and in_it_block run the internal FSM state
	handling function (handle_it_state), because: a) setting the IT insn
	type may incur in an invalid state (exiting the function),
	and b) querying the state requires the FSM to be updated.
	Specifically we want to avoid creating an IT block for conditional
	branches, so it_fsm_pre_encode is actually a guess and we can't
	determine whether an IT block is required until the tencode () routine
	has decided what type of instruction this actually it.
	Because of this, if set_it_insn_type and in_it_block have to be used,
	set_it_insn_type has to be called first.

	set_it_insn_type_last () is a wrapper of set_it_insn_type (type), that
	determines the insn IT type depending on the inst.cond code.
	When a tencode () routine encodes an instruction that can be
	either outside an IT block, or, in the case of being inside, has to be
	the last one, set_it_insn_type_last () will determine the proper
	IT instruction type based on the inst.cond code. Otherwise,
	set_it_insn_type can be called for overriding that logic or
	for covering other cases.

	Calling handle_it_state () may not transition the IT block state to
	OUTSIDE_IT_BLOCK immediatelly, since the (current) state could be
	still queried. Instead, if the FSM determines that the state should
	be transitioned to OUTSIDE_IT_BLOCK, a flag is marked to be closed
	after the tencode () function: that's what it_fsm_post_encode () does.

	Since in_it_block () calls the state handling function to get an
	updated state, an error may occur (due to invalid insns combination).
	In that case, inst.error is set.
	Therefore, inst.error has to be checked after the execution of
	the tencode () routine.

     3) Back in md_assemble(), it_fsm_post_encode () is called to commit
	any pending state change (if any) that didn't take place in
	handle_it_state () as explained above.  */

static void
it_fsm_pre_encode (void)
{
  if (inst.cond != COND_ALWAYS)
    inst.it_insn_type = INSIDE_IT_INSN;
  else
    inst.it_insn_type = OUTSIDE_IT_INSN;

  now_it.state_handled = 0;
}

/* IT state FSM handling function.  */

static int
handle_it_state (void)
{
  now_it.state_handled = 1;
  now_it.insn_cond = FALSE;

  switch (now_it.state)
    {
    case OUTSIDE_IT_BLOCK:
      switch (inst.it_insn_type)
	{
	case OUTSIDE_IT_INSN:
	  break;

	case INSIDE_IT_INSN:
	case INSIDE_IT_LAST_INSN:
	  if (thumb_mode == 0)
	    {
	      if (unified_syntax
		  && !(implicit_it_mode & IMPLICIT_IT_MODE_ARM))
		as_tsktsk (_("Warning: conditional outside an IT block"\
			     " for Thumb."));
	    }
	  else
	    {
	      if ((implicit_it_mode & IMPLICIT_IT_MODE_THUMB)
		  && ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2))
		{
		  /* Automatically generate the IT instruction.  */
		  new_automatic_it_block (inst.cond);
		  if (inst.it_insn_type == INSIDE_IT_LAST_INSN)
		    close_automatic_it_block ();
		}
	      else
		{
		  inst.error = BAD_OUT_IT;
		  return FAIL;
		}
	    }
	  break;

	case IF_INSIDE_IT_LAST_INSN:
	case NEUTRAL_IT_INSN:
	  break;

	case IT_INSN:
	  now_it.state = MANUAL_IT_BLOCK;
	  now_it.block_length = 0;
	  break;
	}
      break;

    case AUTOMATIC_IT_BLOCK:
      /* Three things may happen now:
	 a) We should increment current it block size;
	 b) We should close current it block (closing insn or 4 insns);
	 c) We should close current it block and start a new one (due
	 to incompatible conditions or
	 4 insns-length block reached).  */

      switch (inst.it_insn_type)
	{
	case OUTSIDE_IT_INSN:
	  /* The closure of the block shall happen immediatelly,
	     so any in_it_block () call reports the block as closed.  */
	  force_automatic_it_block_close ();
	  break;

	case INSIDE_IT_INSN:
	case INSIDE_IT_LAST_INSN:
	case IF_INSIDE_IT_LAST_INSN:
	  now_it.block_length++;

	  if (now_it.block_length > 4
	      || !now_it_compatible (inst.cond))
	    {
	      force_automatic_it_block_close ();
	      if (inst.it_insn_type != IF_INSIDE_IT_LAST_INSN)
		new_automatic_it_block (inst.cond);
	    }
	  else
	    {
	      now_it.insn_cond = TRUE;
	      now_it_add_mask (inst.cond);
	    }

	  if (now_it.state == AUTOMATIC_IT_BLOCK
	      && (inst.it_insn_type == INSIDE_IT_LAST_INSN
		  || inst.it_insn_type == IF_INSIDE_IT_LAST_INSN))
	    close_automatic_it_block ();
	  break;

	case NEUTRAL_IT_INSN:
	  now_it.block_length++;
	  now_it.insn_cond = TRUE;

	  if (now_it.block_length > 4)
	    force_automatic_it_block_close ();
	  else
	    now_it_add_mask (now_it.cc & 1);
	  break;

	case IT_INSN:
	  close_automatic_it_block ();
	  now_it.state = MANUAL_IT_BLOCK;
	  break;
	}
      break;

    case MANUAL_IT_BLOCK:
      {
	/* Check conditional suffixes.  */
	const int cond = now_it.cc ^ ((now_it.mask >> 4) & 1) ^ 1;
	int is_last;
	now_it.mask <<= 1;
	now_it.mask &= 0x1f;
	is_last = (now_it.mask == 0x10);
	now_it.insn_cond = TRUE;

	switch (inst.it_insn_type)
	  {
	  case OUTSIDE_IT_INSN:
	    inst.error = BAD_NOT_IT;
	    return FAIL;

	  case INSIDE_IT_INSN:
	    if (cond != inst.cond)
	      {
		inst.error = BAD_IT_COND;
		return FAIL;
	      }
	    break;

	  case INSIDE_IT_LAST_INSN:
	  case IF_INSIDE_IT_LAST_INSN:
	    if (cond != inst.cond)
	      {
		inst.error = BAD_IT_COND;
		return FAIL;
	      }
	    if (!is_last)
	      {
		inst.error = BAD_BRANCH;
		return FAIL;
	      }
	    break;

	  case NEUTRAL_IT_INSN:
	    /* The BKPT instruction is unconditional even in an IT block.  */
	    break;

	  case IT_INSN:
	    inst.error = BAD_IT_IT;
	    return FAIL;
	  }
      }
      break;
    }

  return SUCCESS;
}

struct depr_insn_mask
{
  unsigned long pattern;
  unsigned long mask;
  const char* description;
};

/* List of 16-bit instruction patterns deprecated in an IT block in
   ARMv8.  */
static const struct depr_insn_mask depr_it_insns[] = {
  { 0xc000, 0xc000, N_("Short branches, Undefined, SVC, LDM/STM") },
  { 0xb000, 0xb000, N_("Miscellaneous 16-bit instructions") },
  { 0xa000, 0xb800, N_("ADR") },
  { 0x4800, 0xf800, N_("Literal loads") },
  { 0x4478, 0xf478, N_("Hi-register ADD, MOV, CMP, BX, BLX using pc") },
  { 0x4487, 0xfc87, N_("Hi-register ADD, MOV, CMP using pc") },
  { 0, 0, NULL }
};

static void
it_fsm_post_encode (void)
{
  int is_last;

  if (!now_it.state_handled)
    handle_it_state ();

  if (now_it.insn_cond
      && !now_it.warn_deprecated
      && warn_on_deprecated
      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
    {
      if (inst.instruction >= 0x10000)
	{
	  as_warn (_("IT blocks containing 32-bit Thumb instructions are "
		     "deprecated in ARMv8"));
	  now_it.warn_deprecated = TRUE;
	}
      else
	{
	  const struct depr_insn_mask *p = depr_it_insns;

	  while (p->mask != 0)
	    {
	      if ((inst.instruction & p->mask) == p->pattern)
		{
		  as_warn (_("IT blocks containing 16-bit Thumb instructions "
			     "of the following class are deprecated in ARMv8: "
			     "%s"), p->description);
		  now_it.warn_deprecated = TRUE;
		  break;
		}

	      ++p;
	    }
	}

      if (now_it.block_length > 1)
	{
	  as_warn (_("IT blocks containing more than one conditional "
		     "instruction are deprecated in ARMv8"));
	  now_it.warn_deprecated = TRUE;
	}
    }

  is_last = (now_it.mask == 0x10);
  if (is_last)
    {
      now_it.state = OUTSIDE_IT_BLOCK;
      now_it.mask = 0;
    }
}

static void
force_automatic_it_block_close (void)
{
  if (now_it.state == AUTOMATIC_IT_BLOCK)
    {
      close_automatic_it_block ();
      now_it.state = OUTSIDE_IT_BLOCK;
      now_it.mask = 0;
    }
}

static int
in_it_block (void)
{
  if (!now_it.state_handled)
    handle_it_state ();

  return now_it.state != OUTSIDE_IT_BLOCK;
}

void
md_assemble (char *str)
{
  char *p = str;
  const struct asm_opcode * opcode;

  /* Align the previous label if needed.  */
  if (last_label_seen != NULL)
    {
      symbol_set_frag (last_label_seen, frag_now);
      S_SET_VALUE (last_label_seen, (valueT) frag_now_fix ());
      S_SET_SEGMENT (last_label_seen, now_seg);
    }

  memset (&inst, '\0', sizeof (inst));
  inst.reloc.type = BFD_RELOC_UNUSED;

  opcode = opcode_lookup (&p);
  if (!opcode)
    {
      /* It wasn't an instruction, but it might be a register alias of
	 the form alias .req reg, or a Neon .dn/.qn directive.  */
      if (! create_register_alias (str, p)
	  && ! create_neon_reg_alias (str, p))
	as_bad (_("bad instruction `%s'"), str);

      return;
    }

  if (warn_on_deprecated && opcode->tag == OT_cinfix3_deprecated)
    as_warn (_("s suffix on comparison instruction is deprecated"));

  /* The value which unconditional instructions should have in place of the
     condition field.  */
  inst.uncond_value = (opcode->tag == OT_csuffixF) ? 0xf : -1;

  if (thumb_mode)
    {
      arm_feature_set variant;

      variant = cpu_variant;
      /* Only allow coprocessor instructions on Thumb-2 capable devices.  */
      if (!ARM_CPU_HAS_FEATURE (variant, arm_arch_t2))
	ARM_CLEAR_FEATURE (variant, variant, fpu_any_hard);
      /* Check that this instruction is supported for this CPU.  */
      if (!opcode->tvariant
	  || (thumb_mode == 1
	      && !ARM_CPU_HAS_FEATURE (variant, *opcode->tvariant)))
	{
	  as_bad (_("selected processor does not support Thumb mode `%s'"), str);
	  return;
	}
      if (inst.cond != COND_ALWAYS && !unified_syntax
	  && opcode->tencode != do_t_branch)
	{
	  as_bad (_("Thumb does not support conditional execution"));
	  return;
	}

      if (!ARM_CPU_HAS_FEATURE (variant, arm_ext_v6t2))
	{
	  if (opcode->tencode != do_t_blx && opcode->tencode != do_t_branch23
	      && !(ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr)
		   || ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_barrier)))
	    {
	      /* Two things are addressed here.
		 1) Implicit require narrow instructions on Thumb-1.
		    This avoids relaxation accidentally introducing Thumb-2
		     instructions.
		 2) Reject wide instructions in non Thumb-2 cores.  */
	      if (inst.size_req == 0)
		inst.size_req = 2;
	      else if (inst.size_req == 4)
		{
		  as_bad (_("selected processor does not support Thumb-2 mode `%s'"), str);
		  return;
		}
	    }
	}

      inst.instruction = opcode->tvalue;

      if (!parse_operands (p, opcode->operands, /*thumb=*/TRUE))
	{
	  /* Prepare the it_insn_type for those encodings that don't set
	     it.  */
	  it_fsm_pre_encode ();

	  opcode->tencode ();

	  it_fsm_post_encode ();
	}

      if (!(inst.error || inst.relax))
	{
	  gas_assert (inst.instruction < 0xe800 || inst.instruction > 0xffff);
	  inst.size = (inst.instruction > 0xffff ? 4 : 2);
	  if (inst.size_req && inst.size_req != inst.size)
	    {
	      as_bad (_("cannot honor width suffix -- `%s'"), str);
	      return;
	    }
	}

      /* Something has gone badly wrong if we try to relax a fixed size
	 instruction.  */
      gas_assert (inst.size_req == 0 || !inst.relax);

      ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
			      *opcode->tvariant);
      /* Many Thumb-2 instructions also have Thumb-1 variants, so explicitly
	 set those bits when Thumb-2 32-bit instructions are seen.  ie.
	 anything other than bl/blx and v6-M instructions.
	 This is overly pessimistic for relaxable instructions.  */
      if (((inst.size == 4 && (inst.instruction & 0xf800e800) != 0xf000e800)
	   || inst.relax)
	  && !(ARM_CPU_HAS_FEATURE (*opcode->tvariant, arm_ext_msr)
	       || ARM_CPU_HAS_FEATURE (*opcode->tvariant, arm_ext_barrier)))
	ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
				arm_ext_v6t2);

      check_neon_suffixes;

      if (!inst.error)
	{
	  mapping_state (MAP_THUMB);
	}
    }
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1))
    {
      bfd_boolean is_bx;

      /* bx is allowed on v5 cores, and sometimes on v4 cores.  */
      is_bx = (opcode->aencode == do_bx);

      /* Check that this instruction is supported for this CPU.  */
      if (!(is_bx && fix_v4bx)
	  && !(opcode->avariant &&
	       ARM_CPU_HAS_FEATURE (cpu_variant, *opcode->avariant)))
	{
	  as_bad (_("selected processor does not support ARM mode `%s'"), str);
	  return;
	}
      if (inst.size_req)
	{
	  as_bad (_("width suffixes are invalid in ARM mode -- `%s'"), str);
	  return;
	}

      inst.instruction = opcode->avalue;
      if (opcode->tag == OT_unconditionalF)
	inst.instruction |= 0xF << 28;
      else
	inst.instruction |= inst.cond << 28;
      inst.size = INSN_SIZE;
      if (!parse_operands (p, opcode->operands, /*thumb=*/FALSE))
	{
	  it_fsm_pre_encode ();
	  opcode->aencode ();
	  it_fsm_post_encode ();
	}
      /* Arm mode bx is marked as both v4T and v5 because it's still required
	 on a hypothetical non-thumb v5 core.  */
      if (is_bx)
	ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used, arm_ext_v4t);
      else
	ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
				*opcode->avariant);

      check_neon_suffixes;

      if (!inst.error)
	{
	  mapping_state (MAP_ARM);
	}
    }
  else
    {
      as_bad (_("attempt to use an ARM instruction on a Thumb-only processor "
		"-- `%s'"), str);
      return;
    }
  output_inst (str);
}

static void
check_it_blocks_finished (void)
{
#ifdef OBJ_ELF
  asection *sect;

  for (sect = stdoutput->sections; sect != NULL; sect = sect->next)
    if (seg_info (sect)->tc_segment_info_data.current_it.state
	== MANUAL_IT_BLOCK)
      {
	as_warn (_("section '%s' finished with an open IT block."),
		 sect->name);
      }
#else
  if (now_it.state == MANUAL_IT_BLOCK)
    as_warn (_("file finished with an open IT block."));
#endif
}

/* Various frobbings of labels and their addresses.  */

void
arm_start_line_hook (void)
{
  last_label_seen = NULL;
}

void
arm_frob_label (symbolS * sym)
{
  last_label_seen = sym;

  ARM_SET_THUMB (sym, thumb_mode);

#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (sym, support_interwork);
#endif

  force_automatic_it_block_close ();

  /* Note - do not allow local symbols (.Lxxx) to be labelled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.	 Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:

		ldr  r2, [pc, .Laaa]
		lsl  r3, r3, #2
		ldr  r2, [r3, r2]
		mov  pc, r2

       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:	.word Lbbb

     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.

     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    {
      /* When the address of a Thumb function is taken the bottom
	 bit of that address should be set.  This will allow
	 interworking between Arm and Thumb functions to work
	 correctly.  */

      THUMB_SET_FUNC (sym, 1);

      label_is_thumb_function_name = FALSE;
    }

  dwarf2_emit_label (sym);
}

bfd_boolean
arm_data_in_code (void)
{
  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
    {
      *input_line_pointer = '/';
      input_line_pointer += 5;
      *input_line_pointer = 0;
      return TRUE;
    }

  return FALSE;
}

char *
arm_canonicalize_symbol_name (char * name)
{
  int len;

  if (thumb_mode && (len = strlen (name)) > 5
      && streq (name + len - 5, "/data"))
    *(name + len - 5) = 0;

  return name;
}

/* Table of all register names defined by default.  The user can
   define additional names with .req.  Note that all register names
   should appear in both upper and lowercase variants.	Some registers
   also have mixed-case names.	*/

#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, TRUE, 0 }
#define REGNUM(p,n,t) REGDEF(p##n, n, t)
#define REGNUM2(p,n,t) REGDEF(p##n, 2 * n, t)
#define REGSET(p,t) \
  REGNUM(p, 0,t), REGNUM(p, 1,t), REGNUM(p, 2,t), REGNUM(p, 3,t), \
  REGNUM(p, 4,t), REGNUM(p, 5,t), REGNUM(p, 6,t), REGNUM(p, 7,t), \
  REGNUM(p, 8,t), REGNUM(p, 9,t), REGNUM(p,10,t), REGNUM(p,11,t), \
  REGNUM(p,12,t), REGNUM(p,13,t), REGNUM(p,14,t), REGNUM(p,15,t)
#define REGSETH(p,t) \
  REGNUM(p,16,t), REGNUM(p,17,t), REGNUM(p,18,t), REGNUM(p,19,t), \
  REGNUM(p,20,t), REGNUM(p,21,t), REGNUM(p,22,t), REGNUM(p,23,t), \
  REGNUM(p,24,t), REGNUM(p,25,t), REGNUM(p,26,t), REGNUM(p,27,t), \
  REGNUM(p,28,t), REGNUM(p,29,t), REGNUM(p,30,t), REGNUM(p,31,t)
#define REGSET2(p,t) \
  REGNUM2(p, 0,t), REGNUM2(p, 1,t), REGNUM2(p, 2,t), REGNUM2(p, 3,t), \
  REGNUM2(p, 4,t), REGNUM2(p, 5,t), REGNUM2(p, 6,t), REGNUM2(p, 7,t), \
  REGNUM2(p, 8,t), REGNUM2(p, 9,t), REGNUM2(p,10,t), REGNUM2(p,11,t), \
  REGNUM2(p,12,t), REGNUM2(p,13,t), REGNUM2(p,14,t), REGNUM2(p,15,t)
#define SPLRBANK(base,bank,t) \
  REGDEF(lr_##bank, 768|((base+0)<<16), t), \
  REGDEF(sp_##bank, 768|((base+1)<<16), t), \
  REGDEF(spsr_##bank, 768|(base<<16)|SPSR_BIT, t), \
  REGDEF(LR_##bank, 768|((base+0)<<16), t), \
  REGDEF(SP_##bank, 768|((base+1)<<16), t), \
  REGDEF(SPSR_##bank, 768|(base<<16)|SPSR_BIT, t)

static const struct reg_entry reg_names[] =
{
  /* ARM integer registers.  */
  REGSET(r, RN), REGSET(R, RN),

  /* ATPCS synonyms.  */
  REGDEF(a1,0,RN), REGDEF(a2,1,RN), REGDEF(a3, 2,RN), REGDEF(a4, 3,RN),
  REGDEF(v1,4,RN), REGDEF(v2,5,RN), REGDEF(v3, 6,RN), REGDEF(v4, 7,RN),
  REGDEF(v5,8,RN), REGDEF(v6,9,RN), REGDEF(v7,10,RN), REGDEF(v8,11,RN),

  REGDEF(A1,0,RN), REGDEF(A2,1,RN), REGDEF(A3, 2,RN), REGDEF(A4, 3,RN),
  REGDEF(V1,4,RN), REGDEF(V2,5,RN), REGDEF(V3, 6,RN), REGDEF(V4, 7,RN),
  REGDEF(V5,8,RN), REGDEF(V6,9,RN), REGDEF(V7,10,RN), REGDEF(V8,11,RN),

  /* Well-known aliases.  */
  REGDEF(wr, 7,RN), REGDEF(sb, 9,RN), REGDEF(sl,10,RN), REGDEF(fp,11,RN),
  REGDEF(ip,12,RN), REGDEF(sp,13,RN), REGDEF(lr,14,RN), REGDEF(pc,15,RN),

  REGDEF(WR, 7,RN), REGDEF(SB, 9,RN), REGDEF(SL,10,RN), REGDEF(FP,11,RN),
  REGDEF(IP,12,RN), REGDEF(SP,13,RN), REGDEF(LR,14,RN), REGDEF(PC,15,RN),

  /* Coprocessor numbers.  */
  REGSET(p, CP), REGSET(P, CP),

  /* Coprocessor register numbers.  The "cr" variants are for backward
     compatibility.  */
  REGSET(c,  CN), REGSET(C, CN),
  REGSET(cr, CN), REGSET(CR, CN),

  /* ARM banked registers.  */
  REGDEF(R8_usr,512|(0<<16),RNB), REGDEF(r8_usr,512|(0<<16),RNB),
  REGDEF(R9_usr,512|(1<<16),RNB), REGDEF(r9_usr,512|(1<<16),RNB),
  REGDEF(R10_usr,512|(2<<16),RNB), REGDEF(r10_usr,512|(2<<16),RNB),
  REGDEF(R11_usr,512|(3<<16),RNB), REGDEF(r11_usr,512|(3<<16),RNB),
  REGDEF(R12_usr,512|(4<<16),RNB), REGDEF(r12_usr,512|(4<<16),RNB),
  REGDEF(SP_usr,512|(5<<16),RNB), REGDEF(sp_usr,512|(5<<16),RNB),
  REGDEF(LR_usr,512|(6<<16),RNB), REGDEF(lr_usr,512|(6<<16),RNB),

  REGDEF(R8_fiq,512|(8<<16),RNB), REGDEF(r8_fiq,512|(8<<16),RNB),
  REGDEF(R9_fiq,512|(9<<16),RNB), REGDEF(r9_fiq,512|(9<<16),RNB),
  REGDEF(R10_fiq,512|(10<<16),RNB), REGDEF(r10_fiq,512|(10<<16),RNB),
  REGDEF(R11_fiq,512|(11<<16),RNB), REGDEF(r11_fiq,512|(11<<16),RNB),
  REGDEF(R12_fiq,512|(12<<16),RNB), REGDEF(r12_fiq,512|(12<<16),RNB),
  REGDEF(SP_fiq,512|(13<<16),RNB), REGDEF(sp_fiq,512|(13<<16),RNB),
  REGDEF(LR_fiq,512|(14<<16),RNB), REGDEF(lr_fiq,512|(14<<16),RNB),
  REGDEF(SPSR_fiq,512|(14<<16)|SPSR_BIT,RNB), REGDEF(spsr_fiq,512|(14<<16)|SPSR_BIT,RNB),

  SPLRBANK(0,IRQ,RNB), SPLRBANK(0,irq,RNB),
  SPLRBANK(2,SVC,RNB), SPLRBANK(2,svc,RNB),
  SPLRBANK(4,ABT,RNB), SPLRBANK(4,abt,RNB),
  SPLRBANK(6,UND,RNB), SPLRBANK(6,und,RNB),
  SPLRBANK(12,MON,RNB), SPLRBANK(12,mon,RNB),
  REGDEF(elr_hyp,768|(14<<16),RNB), REGDEF(ELR_hyp,768|(14<<16),RNB),
  REGDEF(sp_hyp,768|(15<<16),RNB), REGDEF(SP_hyp,768|(15<<16),RNB),
  REGDEF(spsr_hyp,768|(14<<16)|SPSR_BIT,RNB),
  REGDEF(SPSR_hyp,768|(14<<16)|SPSR_BIT,RNB),

  /* FPA registers.  */
  REGNUM(f,0,FN), REGNUM(f,1,FN), REGNUM(f,2,FN), REGNUM(f,3,FN),
  REGNUM(f,4,FN), REGNUM(f,5,FN), REGNUM(f,6,FN), REGNUM(f,7, FN),

  REGNUM(F,0,FN), REGNUM(F,1,FN), REGNUM(F,2,FN), REGNUM(F,3,FN),
  REGNUM(F,4,FN), REGNUM(F,5,FN), REGNUM(F,6,FN), REGNUM(F,7, FN),

  /* VFP SP registers.	*/
  REGSET(s,VFS),  REGSET(S,VFS),
  REGSETH(s,VFS), REGSETH(S,VFS),

  /* VFP DP Registers.	*/
  REGSET(d,VFD),  REGSET(D,VFD),
  /* Extra Neon DP registers.  */
  REGSETH(d,VFD), REGSETH(D,VFD),

  /* Neon QP registers.  */
  REGSET2(q,NQ),  REGSET2(Q,NQ),

  /* VFP control registers.  */
  REGDEF(fpsid,0,VFC), REGDEF(fpscr,1,VFC), REGDEF(fpexc,8,VFC),
  REGDEF(FPSID,0,VFC), REGDEF(FPSCR,1,VFC), REGDEF(FPEXC,8,VFC),
  REGDEF(fpinst,9,VFC), REGDEF(fpinst2,10,VFC),
  REGDEF(FPINST,9,VFC), REGDEF(FPINST2,10,VFC),
  REGDEF(mvfr0,7,VFC), REGDEF(mvfr1,6,VFC),
  REGDEF(MVFR0,7,VFC), REGDEF(MVFR1,6,VFC),

  /* Maverick DSP coprocessor registers.  */
  REGSET(mvf,MVF),  REGSET(mvd,MVD),  REGSET(mvfx,MVFX),  REGSET(mvdx,MVDX),
  REGSET(MVF,MVF),  REGSET(MVD,MVD),  REGSET(MVFX,MVFX),  REGSET(MVDX,MVDX),

  REGNUM(mvax,0,MVAX), REGNUM(mvax,1,MVAX),
  REGNUM(mvax,2,MVAX), REGNUM(mvax,3,MVAX),
  REGDEF(dspsc,0,DSPSC),

  REGNUM(MVAX,0,MVAX), REGNUM(MVAX,1,MVAX),
  REGNUM(MVAX,2,MVAX), REGNUM(MVAX,3,MVAX),
  REGDEF(DSPSC,0,DSPSC),

  /* iWMMXt data registers - p0, c0-15.	 */
  REGSET(wr,MMXWR), REGSET(wR,MMXWR), REGSET(WR, MMXWR),

  /* iWMMXt control registers - p1, c0-3.  */
  REGDEF(wcid,	0,MMXWC),  REGDEF(wCID,	 0,MMXWC),  REGDEF(WCID,  0,MMXWC),
  REGDEF(wcon,	1,MMXWC),  REGDEF(wCon,	 1,MMXWC),  REGDEF(WCON,  1,MMXWC),
  REGDEF(wcssf, 2,MMXWC),  REGDEF(wCSSF, 2,MMXWC),  REGDEF(WCSSF, 2,MMXWC),
  REGDEF(wcasf, 3,MMXWC),  REGDEF(wCASF, 3,MMXWC),  REGDEF(WCASF, 3,MMXWC),

  /* iWMMXt scalar (constant/offset) registers - p1, c8-11.  */
  REGDEF(wcgr0, 8,MMXWCG),  REGDEF(wCGR0, 8,MMXWCG),  REGDEF(WCGR0, 8,MMXWCG),
  REGDEF(wcgr1, 9,MMXWCG),  REGDEF(wCGR1, 9,MMXWCG),  REGDEF(WCGR1, 9,MMXWCG),
  REGDEF(wcgr2,10,MMXWCG),  REGDEF(wCGR2,10,MMXWCG),  REGDEF(WCGR2,10,MMXWCG),
  REGDEF(wcgr3,11,MMXWCG),  REGDEF(wCGR3,11,MMXWCG),  REGDEF(WCGR3,11,MMXWCG),

  /* XScale accumulator registers.  */
  REGNUM(acc,0,XSCALE), REGNUM(ACC,0,XSCALE),
};
#undef REGDEF
#undef REGNUM
#undef REGSET

/* Table of all PSR suffixes.  Bare "CPSR" and "SPSR" are handled
   within psr_required_here.  */
static const struct asm_psr psrs[] =
{
  /* Backward compatibility notation.  Note that "all" is no longer
     truly all possible PSR bits.  */
  {"all",  PSR_c | PSR_f},
  {"flg",  PSR_f},
  {"ctl",  PSR_c},

  /* Individual flags.	*/
  {"f",	   PSR_f},
  {"c",	   PSR_c},
  {"x",	   PSR_x},
  {"s",	   PSR_s},

  /* Combinations of flags.  */
  {"fs",   PSR_f | PSR_s},
  {"fx",   PSR_f | PSR_x},
  {"fc",   PSR_f | PSR_c},
  {"sf",   PSR_s | PSR_f},
  {"sx",   PSR_s | PSR_x},
  {"sc",   PSR_s | PSR_c},
  {"xf",   PSR_x | PSR_f},
  {"xs",   PSR_x | PSR_s},
  {"xc",   PSR_x | PSR_c},
  {"cf",   PSR_c | PSR_f},
  {"cs",   PSR_c | PSR_s},
  {"cx",   PSR_c | PSR_x},
  {"fsx",  PSR_f | PSR_s | PSR_x},
  {"fsc",  PSR_f | PSR_s | PSR_c},
  {"fxs",  PSR_f | PSR_x | PSR_s},
  {"fxc",  PSR_f | PSR_x | PSR_c},
  {"fcs",  PSR_f | PSR_c | PSR_s},
  {"fcx",  PSR_f | PSR_c | PSR_x},
  {"sfx",  PSR_s | PSR_f | PSR_x},
  {"sfc",  PSR_s | PSR_f | PSR_c},
  {"sxf",  PSR_s | PSR_x | PSR_f},
  {"sxc",  PSR_s | PSR_x | PSR_c},
  {"scf",  PSR_s | PSR_c | PSR_f},
  {"scx",  PSR_s | PSR_c | PSR_x},
  {"xfs",  PSR_x | PSR_f | PSR_s},
  {"xfc",  PSR_x | PSR_f | PSR_c},
  {"xsf",  PSR_x | PSR_s | PSR_f},
  {"xsc",  PSR_x | PSR_s | PSR_c},
  {"xcf",  PSR_x | PSR_c | PSR_f},
  {"xcs",  PSR_x | PSR_c | PSR_s},
  {"cfs",  PSR_c | PSR_f | PSR_s},
  {"cfx",  PSR_c | PSR_f | PSR_x},
  {"csf",  PSR_c | PSR_s | PSR_f},
  {"csx",  PSR_c | PSR_s | PSR_x},
  {"cxf",  PSR_c | PSR_x | PSR_f},
  {"cxs",  PSR_c | PSR_x | PSR_s},
  {"fsxc", PSR_f | PSR_s | PSR_x | PSR_c},
  {"fscx", PSR_f | PSR_s | PSR_c | PSR_x},
  {"fxsc", PSR_f | PSR_x | PSR_s | PSR_c},
  {"fxcs", PSR_f | PSR_x | PSR_c | PSR_s},
  {"fcsx", PSR_f | PSR_c | PSR_s | PSR_x},
  {"fcxs", PSR_f | PSR_c | PSR_x | PSR_s},
  {"sfxc", PSR_s | PSR_f | PSR_x | PSR_c},
  {"sfcx", PSR_s | PSR_f | PSR_c | PSR_x},
  {"sxfc", PSR_s | PSR_x | PSR_f | PSR_c},
  {"sxcf", PSR_s | PSR_x | PSR_c | PSR_f},
  {"scfx", PSR_s | PSR_c | PSR_f | PSR_x},
  {"scxf", PSR_s | PSR_c | PSR_x | PSR_f},
  {"xfsc", PSR_x | PSR_f | PSR_s | PSR_c},
  {"xfcs", PSR_x | PSR_f | PSR_c | PSR_s},
  {"xsfc", PSR_x | PSR_s | PSR_f | PSR_c},
  {"xscf", PSR_x | PSR_s | PSR_c | PSR_f},
  {"xcfs", PSR_x | PSR_c | PSR_f | PSR_s},
  {"xcsf", PSR_x | PSR_c | PSR_s | PSR_f},
  {"cfsx", PSR_c | PSR_f | PSR_s | PSR_x},
  {"cfxs", PSR_c | PSR_f | PSR_x | PSR_s},
  {"csfx", PSR_c | PSR_s | PSR_f | PSR_x},
  {"csxf", PSR_c | PSR_s | PSR_x | PSR_f},
  {"cxfs", PSR_c | PSR_x | PSR_f | PSR_s},
  {"cxsf", PSR_c | PSR_x | PSR_s | PSR_f},
};

/* Table of V7M psr names.  */
static const struct asm_psr v7m_psrs[] =
{
  {"apsr",	  0 }, {"APSR",		0 },
  {"iapsr",	  1 }, {"IAPSR",	1 },
  {"eapsr",	  2 }, {"EAPSR",	2 },
  {"psr",	  3 }, {"PSR",		3 },
  {"xpsr",	  3 }, {"XPSR",		3 }, {"xPSR",	  3 },
  {"ipsr",	  5 }, {"IPSR",		5 },
  {"epsr",	  6 }, {"EPSR",		6 },
  {"iepsr",	  7 }, {"IEPSR",	7 },
  {"msp",	  8 }, {"MSP",		8 },
  {"psp",	  9 }, {"PSP",		9 },
  {"primask",	  16}, {"PRIMASK",	16},
  {"basepri",	  17}, {"BASEPRI",	17},
  {"basepri_max", 18}, {"BASEPRI_MAX",	18},
  {"basepri_max", 18}, {"BASEPRI_MASK",	18}, /* Typo, preserved for backwards compatibility.  */
  {"faultmask",	  19}, {"FAULTMASK",	19},
  {"control",	  20}, {"CONTROL",	20}
};

/* Table of all shift-in-operand names.	 */
static const struct asm_shift_name shift_names [] =
{
  { "asl", SHIFT_LSL },	 { "ASL", SHIFT_LSL },
  { "lsl", SHIFT_LSL },	 { "LSL", SHIFT_LSL },
  { "lsr", SHIFT_LSR },	 { "LSR", SHIFT_LSR },
  { "asr", SHIFT_ASR },	 { "ASR", SHIFT_ASR },
  { "ror", SHIFT_ROR },	 { "ROR", SHIFT_ROR },
  { "rrx", SHIFT_RRX },	 { "RRX", SHIFT_RRX }
};

/* Table of all explicit relocation names.  */
#ifdef OBJ_ELF
static struct reloc_entry reloc_names[] =
{
  { "got",     BFD_RELOC_ARM_GOT32   },	 { "GOT",     BFD_RELOC_ARM_GOT32   },
  { "gotoff",  BFD_RELOC_ARM_GOTOFF  },	 { "GOTOFF",  BFD_RELOC_ARM_GOTOFF  },
  { "plt",     BFD_RELOC_ARM_PLT32   },	 { "PLT",     BFD_RELOC_ARM_PLT32   },
  { "target1", BFD_RELOC_ARM_TARGET1 },	 { "TARGET1", BFD_RELOC_ARM_TARGET1 },
  { "target2", BFD_RELOC_ARM_TARGET2 },	 { "TARGET2", BFD_RELOC_ARM_TARGET2 },
  { "sbrel",   BFD_RELOC_ARM_SBREL32 },	 { "SBREL",   BFD_RELOC_ARM_SBREL32 },
  { "tlsgd",   BFD_RELOC_ARM_TLS_GD32},  { "TLSGD",   BFD_RELOC_ARM_TLS_GD32},
  { "tlsldm",  BFD_RELOC_ARM_TLS_LDM32}, { "TLSLDM",  BFD_RELOC_ARM_TLS_LDM32},
  { "tlsldo",  BFD_RELOC_ARM_TLS_LDO32}, { "TLSLDO",  BFD_RELOC_ARM_TLS_LDO32},
  { "gottpoff",BFD_RELOC_ARM_TLS_IE32},  { "GOTTPOFF",BFD_RELOC_ARM_TLS_IE32},
  { "tpoff",   BFD_RELOC_ARM_TLS_LE32},  { "TPOFF",   BFD_RELOC_ARM_TLS_LE32},
  { "got_prel", BFD_RELOC_ARM_GOT_PREL}, { "GOT_PREL", BFD_RELOC_ARM_GOT_PREL},
  { "tlsdesc", BFD_RELOC_ARM_TLS_GOTDESC},
	{ "TLSDESC", BFD_RELOC_ARM_TLS_GOTDESC},
  { "tlscall", BFD_RELOC_ARM_TLS_CALL},
	{ "TLSCALL", BFD_RELOC_ARM_TLS_CALL},
  { "tlsdescseq", BFD_RELOC_ARM_TLS_DESCSEQ},
	{ "TLSDESCSEQ", BFD_RELOC_ARM_TLS_DESCSEQ}
};
#endif

/* Table of all conditional affixes.  0xF is not defined as a condition code.  */
static const struct asm_cond conds[] =
{
  {"eq", 0x0},
  {"ne", 0x1},
  {"cs", 0x2}, {"hs", 0x2},
  {"cc", 0x3}, {"ul", 0x3}, {"lo", 0x3},
  {"mi", 0x4},
  {"pl", 0x5},
  {"vs", 0x6},
  {"vc", 0x7},
  {"hi", 0x8},
  {"ls", 0x9},
  {"ge", 0xa},
  {"lt", 0xb},
  {"gt", 0xc},
  {"le", 0xd},
  {"al", 0xe}
};

#define UL_BARRIER(L,U,CODE,FEAT) \
  { L, CODE, ARM_FEATURE (FEAT, 0) }, \
  { U, CODE, ARM_FEATURE (FEAT, 0) }

static struct asm_barrier_opt barrier_opt_names[] =
{
  UL_BARRIER ("sy",	"SY",	 0xf, ARM_EXT_BARRIER),
  UL_BARRIER ("st",	"ST",	 0xe, ARM_EXT_BARRIER),
  UL_BARRIER ("ld",	"LD",	 0xd, ARM_EXT_V8),
  UL_BARRIER ("ish",	"ISH",	 0xb, ARM_EXT_BARRIER),
  UL_BARRIER ("sh",	"SH",	 0xb, ARM_EXT_BARRIER),
  UL_BARRIER ("ishst",	"ISHST", 0xa, ARM_EXT_BARRIER),
  UL_BARRIER ("shst",	"SHST",	 0xa, ARM_EXT_BARRIER),
  UL_BARRIER ("ishld",	"ISHLD", 0x9, ARM_EXT_V8),
  UL_BARRIER ("un",	"UN",	 0x7, ARM_EXT_BARRIER),
  UL_BARRIER ("nsh",	"NSH",	 0x7, ARM_EXT_BARRIER),
  UL_BARRIER ("unst",	"UNST",	 0x6, ARM_EXT_BARRIER),
  UL_BARRIER ("nshst",	"NSHST", 0x6, ARM_EXT_BARRIER),
  UL_BARRIER ("nshld",	"NSHLD", 0x5, ARM_EXT_V8),
  UL_BARRIER ("osh",	"OSH",	 0x3, ARM_EXT_BARRIER),
  UL_BARRIER ("oshst",	"OSHST", 0x2, ARM_EXT_BARRIER),
  UL_BARRIER ("oshld",	"OSHLD", 0x1, ARM_EXT_V8)
};

#undef UL_BARRIER

/* Table of ARM-format instructions.	*/

/* Macros for gluing together operand strings.  N.B. In all cases
   other than OPS0, the trailing OP_stop comes from default
   zero-initialization of the unspecified elements of the array.  */
#define OPS0()		  { OP_stop, }
#define OPS1(a)		  { OP_##a, }
#define OPS2(a,b)	  { OP_##a,OP_##b, }
#define OPS3(a,b,c)	  { OP_##a,OP_##b,OP_##c, }
#define OPS4(a,b,c,d)	  { OP_##a,OP_##b,OP_##c,OP_##d, }
#define OPS5(a,b,c,d,e)	  { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e, }
#define OPS6(a,b,c,d,e,f) { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e,OP_##f, }

/* These macros are similar to the OPSn, but do not prepend the OP_ prefix.
   This is useful when mixing operands for ARM and THUMB, i.e. using the
   MIX_ARM_THUMB_OPERANDS macro.
   In order to use these macros, prefix the number of operands with _
   e.g. _3.  */
#define OPS_1(a)	   { a, }
#define OPS_2(a,b)	   { a,b, }
#define OPS_3(a,b,c)	   { a,b,c, }
#define OPS_4(a,b,c,d)	   { a,b,c,d, }
#define OPS_5(a,b,c,d,e)   { a,b,c,d,e, }
#define OPS_6(a,b,c,d,e,f) { a,b,c,d,e,f, }

/* These macros abstract out the exact format of the mnemonic table and
   save some repeated characters.  */

/* The normal sort of mnemonic; has a Thumb variant; takes a conditional suffix.  */
#define TxCE(mnem, op, top, nops, ops, ae, te) \
  { mnem, OPS##nops ops, OT_csuffix, 0x##op, top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* Two variants of the above - TCE for a numeric Thumb opcode, tCE for
   a T_MNEM_xyz enumerator.  */
#define TCE(mnem, aop, top, nops, ops, ae, te) \
      TxCE (mnem, aop, 0x##top, nops, ops, ae, te)
#define tCE(mnem, aop, top, nops, ops, ae, te) \
      TxCE (mnem, aop, T_MNEM##top, nops, ops, ae, te)

/* Second most common sort of mnemonic: has a Thumb variant, takes a conditional
   infix after the third character.  */
#define TxC3(mnem, op, top, nops, ops, ae, te) \
  { mnem, OPS##nops ops, OT_cinfix3, 0x##op, top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }
#define TxC3w(mnem, op, top, nops, ops, ae, te) \
  { mnem, OPS##nops ops, OT_cinfix3_deprecated, 0x##op, top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }
#define TC3(mnem, aop, top, nops, ops, ae, te) \
      TxC3 (mnem, aop, 0x##top, nops, ops, ae, te)
#define TC3w(mnem, aop, top, nops, ops, ae, te) \
      TxC3w (mnem, aop, 0x##top, nops, ops, ae, te)
#define tC3(mnem, aop, top, nops, ops, ae, te) \
      TxC3 (mnem, aop, T_MNEM##top, nops, ops, ae, te)
#define tC3w(mnem, aop, top, nops, ops, ae, te) \
      TxC3w (mnem, aop, T_MNEM##top, nops, ops, ae, te)

/* Mnemonic that cannot be conditionalized.  The ARM condition-code
   field is still 0xE.  Many of the Thumb variants can be executed
   conditionally, so this is checked separately.  */
#define TUE(mnem, op, top, nops, ops, ae, te)				\
  { mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* Same as TUE but the encoding function for ARM and Thumb modes is the same.
   Used by mnemonics that have very minimal differences in the encoding for
   ARM and Thumb variants and can be handled in a common function.  */
#define TUEc(mnem, op, top, nops, ops, en) \
  { mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \
    THUMB_VARIANT, do_##en, do_##en }

/* Mnemonic that cannot be conditionalized, and bears 0xF in its ARM
   condition code field.  */
#define TUF(mnem, op, top, nops, ops, ae, te)				\
  { mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* ARM-only variants of all the above.  */
#define CE(mnem,  op, nops, ops, ae)	\
  { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

#define C3(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

/* Legacy mnemonics that always have conditional infix after the third
   character.  */
#define CL(mnem, op, nops, ops, ae)	\
  { mnem, OPS##nops ops, OT_cinfix3_legacy, \
    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

/* Coprocessor instructions.  Isomorphic between Arm and Thumb-2.  */
#define cCE(mnem,  op, nops, ops, ae)	\
  { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }

/* Legacy coprocessor instructions where conditional infix and conditional
   suffix are ambiguous.  For consistency this includes all FPA instructions,
   not just the potentially ambiguous ones.  */
#define cCL(mnem, op, nops, ops, ae)	\
  { mnem, OPS##nops ops, OT_cinfix3_legacy, \
    0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }

/* Coprocessor, takes either a suffix or a position-3 infix
   (for an FPA corner case). */
#define C3E(mnem, op, nops, ops, ae) \
  { mnem, OPS##nops ops, OT_csuf_or_in3, \
    0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }

#define xCM_(m1, m2, m3, op, nops, ops, ae)	\
  { m1 #m2 m3, OPS##nops ops, \
    sizeof (#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof (m1) - 1, \
    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

#define CM(m1, m2, op, nops, ops, ae)	\
  xCM_ (m1,   , m2, op, nops, ops, ae),	\
  xCM_ (m1, eq, m2, op, nops, ops, ae),	\
  xCM_ (m1, ne, m2, op, nops, ops, ae),	\
  xCM_ (m1, cs, m2, op, nops, ops, ae),	\
  xCM_ (m1, hs, m2, op, nops, ops, ae),	\
  xCM_ (m1, cc, m2, op, nops, ops, ae),	\
  xCM_ (m1, ul, m2, op, nops, ops, ae),	\
  xCM_ (m1, lo, m2, op, nops, ops, ae),	\
  xCM_ (m1, mi, m2, op, nops, ops, ae),	\
  xCM_ (m1, pl, m2, op, nops, ops, ae),	\
  xCM_ (m1, vs, m2, op, nops, ops, ae),	\
  xCM_ (m1, vc, m2, op, nops, ops, ae),	\
  xCM_ (m1, hi, m2, op, nops, ops, ae),	\
  xCM_ (m1, ls, m2, op, nops, ops, ae),	\
  xCM_ (m1, ge, m2, op, nops, ops, ae),	\
  xCM_ (m1, lt, m2, op, nops, ops, ae),	\
  xCM_ (m1, gt, m2, op, nops, ops, ae),	\
  xCM_ (m1, le, m2, op, nops, ops, ae),	\
  xCM_ (m1, al, m2, op, nops, ops, ae)

#define UE(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }

#define UF(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }

/* Neon data-processing. ARM versions are unconditional with cond=0xf.
   The Thumb and ARM variants are mostly the same (bits 0-23 and 24/28), so we
   use the same encoding function for each.  */
#define NUF(mnem, op, nops, ops, enc)					\
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##op,		\
    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }

/* Neon data processing, version which indirects through neon_enc_tab for
   the various overloaded versions of opcodes.  */
#define nUF(mnem, op, nops, ops, enc)					\
  { #mnem, OPS##nops ops, OT_unconditionalF, N_MNEM##op, N_MNEM##op,	\
    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }

/* Neon insn with conditional suffix for the ARM version, non-overloaded
   version.  */
#define NCE_tag(mnem, op, nops, ops, enc, tag)				\
  { #mnem, OPS##nops ops, tag, 0x##op, 0x##op, ARM_VARIANT,		\
    THUMB_VARIANT, do_##enc, do_##enc }

#define NCE(mnem, op, nops, ops, enc)					\
   NCE_tag (mnem, op, nops, ops, enc, OT_csuffix)

#define NCEF(mnem, op, nops, ops, enc)					\
    NCE_tag (mnem, op, nops, ops, enc, OT_csuffixF)

/* Neon insn with conditional suffix for the ARM version, overloaded types.  */
#define nCE_tag(mnem, op, nops, ops, enc, tag)				\
  { #mnem, OPS##nops ops, tag, N_MNEM##op, N_MNEM##op,		\
    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }

#define nCE(mnem, op, nops, ops, enc)					\
   nCE_tag (mnem, op, nops, ops, enc, OT_csuffix)

#define nCEF(mnem, op, nops, ops, enc)					\
    nCE_tag (mnem, op, nops, ops, enc, OT_csuffixF)

#define do_0 0

static const struct asm_opcode insns[] =
{
#define ARM_VARIANT    & arm_ext_v1 /* Core ARM Instructions.  */
#define THUMB_VARIANT  & arm_ext_v4t
 tCE("and",	0000000, _and,     3, (RR, oRR, SH), arit, t_arit3c),
 tC3("ands",	0100000, _ands,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE("eor",	0200000, _eor,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3("eors",	0300000, _eors,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE("sub",	0400000, _sub,	   3, (RR, oRR, SH), arit, t_add_sub),
 tC3("subs",	0500000, _subs,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCE("add",	0800000, _add,	   3, (RR, oRR, SHG), arit, t_add_sub),
 tC3("adds",	0900000, _adds,	   3, (RR, oRR, SHG), arit, t_add_sub),
 tCE("adc",	0a00000, _adc,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3("adcs",	0b00000, _adcs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE("sbc",	0c00000, _sbc,	   3, (RR, oRR, SH), arit, t_arit3),
 tC3("sbcs",	0d00000, _sbcs,	   3, (RR, oRR, SH), arit, t_arit3),
 tCE("orr",	1800000, _orr,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3("orrs",	1900000, _orrs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE("bic",	1c00000, _bic,	   3, (RR, oRR, SH), arit, t_arit3),
 tC3("bics",	1d00000, _bics,	   3, (RR, oRR, SH), arit, t_arit3),

 /* The p-variants of tst/cmp/cmn/teq (below) are the pre-V6 mechanism
    for setting PSR flag bits.  They are obsolete in V6 and do not
    have Thumb equivalents. */
 tCE("tst",	1100000, _tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tC3w("tsts",	1100000, _tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
  CL("tstp",	110f000,     	   2, (RR, SH),      cmp),
 tCE("cmp",	1500000, _cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
 tC3w("cmps",	1500000, _cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
  CL("cmpp",	150f000,     	   2, (RR, SH),      cmp),
 tCE("cmn",	1700000, _cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tC3w("cmns",	1700000, _cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
  CL("cmnp",	170f000,     	   2, (RR, SH),      cmp),

 tCE("mov",	1a00000, _mov,	   2, (RR, SH),      mov,  t_mov_cmp),
 tC3("movs",	1b00000, _movs,	   2, (RR, SH),      mov,  t_mov_cmp),
 tCE("mvn",	1e00000, _mvn,	   2, (RR, SH),      mov,  t_mvn_tst),
 tC3("mvns",	1f00000, _mvns,	   2, (RR, SH),      mov,  t_mvn_tst),

 tCE("ldr",	4100000, _ldr,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tC3("ldrb",	4500000, _ldrb,	   2, (RRnpc_npcsp, ADDRGLDR),ldst, t_ldst),
 tCE("str",	4000000, _str,	   _2, (MIX_ARM_THUMB_OPERANDS (OP_RR,
								OP_RRnpc),
					OP_ADDRGLDR),ldst, t_ldst),
 tC3("strb",	4400000, _strb,	   2, (RRnpc_npcsp, ADDRGLDR),ldst, t_ldst),

 tCE("stm",	8800000, _stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3("stmia",	8800000, _stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3("stmea",	8800000, _stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tCE("ldm",	8900000, _ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3("ldmia",	8900000, _ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3("ldmfd",	8900000, _ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),

 TCE("swi",	f000000, df00,     1, (EXPi),        swi, t_swi),
 TCE("svc",	f000000, df00,     1, (EXPi),        swi, t_swi),
 tCE("b",	a000000, _b,	   1, (EXPr),	     branch, t_branch),
 TCE("bl",	b000000, f000f800, 1, (EXPr),	     bl, t_branch23),

  /* Pseudo ops.  */
 tCE("adr",	28f0000, _adr,	   2, (RR, EXP),     adr,  t_adr),
  C3(adrl,	28f0000,           2, (RR, EXP),     adrl),
 tCE("nop",	1a00000, _nop,	   1, (oI255c),	     nop,  t_nop),
 tCE("udf",	7f000f0, _udf,     1, (oIffffb),     bkpt, t_udf),

  /* Thumb-compatibility pseudo ops.  */
 tCE("lsl",	1a00000, _lsl,	   3, (RR, oRR, SH), shift, t_shift),
 tC3("lsls",	1b00000, _lsls,	   3, (RR, oRR, SH), shift, t_shift),
 tCE("lsr",	1a00020, _lsr,	   3, (RR, oRR, SH), shift, t_shift),
 tC3("lsrs",	1b00020, _lsrs,	   3, (RR, oRR, SH), shift, t_shift),
 tCE("asr",	1a00040, _asr,	   3, (RR, oRR, SH), shift, t_shift),
 tC3("asrs",      1b00040, _asrs,     3, (RR, oRR, SH), shift, t_shift),
 tCE("ror",	1a00060, _ror,	   3, (RR, oRR, SH), shift, t_shift),
 tC3("rors",	1b00060, _rors,	   3, (RR, oRR, SH), shift, t_shift),
 tCE("neg",	2600000, _neg,	   2, (RR, RR),      rd_rn, t_neg),
 tC3("negs",	2700000, _negs,	   2, (RR, RR),      rd_rn, t_neg),
 tCE("push",	92d0000, _push,     1, (REGLST),	     push_pop, t_push_pop),
 tCE("pop",	8bd0000, _pop,	   1, (REGLST),	     push_pop, t_push_pop),

 /* These may simplify to neg.  */
 TCE("rsb",	0600000, ebc00000, 3, (RR, oRR, SH), arit, t_rsb),
 TC3("rsbs",	0700000, ebd00000, 3, (RR, oRR, SH), arit, t_rsb),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6

 TCE("cpy",       1a00000, 4600,     2, (RR, RR),      rd_rm, t_cpy),

 /* V1 instructions with no Thumb analogue prior to V6T2.  */
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6t2

 TCE("teq",	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
 TC3w("teqs",	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
  CL("teqp",	130f000,           2, (RR, SH),      cmp),

 TC3("ldrt",	4300000, f8500e00, 2, (RRnpc_npcsp, ADDR),ldstt, t_ldstt),
 TC3("ldrbt",	4700000, f8100e00, 2, (RRnpc_npcsp, ADDR),ldstt, t_ldstt),
 TC3("strt",	4200000, f8400e00, 2, (RR_npcsp, ADDR),   ldstt, t_ldstt),
 TC3("strbt",	4600000, f8000e00, 2, (RRnpc_npcsp, ADDR),ldstt, t_ldstt),

 TC3("stmdb",	9000000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3("stmfd",     9000000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),

 TC3("ldmdb",	9100000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3("ldmea",	9100000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),

 /* V1 instructions with no Thumb analogue at all.  */
  CE("rsc",	0e00000,	   3, (RR, oRR, SH), arit),
  C3(rscs,	0f00000,	   3, (RR, oRR, SH), arit),

  C3(stmib,	9800000,	   2, (RRw, REGLST), ldmstm),
  C3(stmfa,	9800000,	   2, (RRw, REGLST), ldmstm),
  C3(stmda,	8000000,	   2, (RRw, REGLST), ldmstm),
  C3(stmed,	8000000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmib,	9900000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmed,	9900000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmda,	8100000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmfa,	8100000,	   2, (RRw, REGLST), ldmstm),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v2	/* ARM 2 - multiplies.	*/
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v4t

 tCE("mul",	0000090, _mul,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
 tC3("muls",	0100090, _muls,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6t2

 TCE("mla",	0200090, fb000000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
  C3(mlas,	0300090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas),

  /* Generic coprocessor instructions.	*/
 TCE("cdp",	e000000, ee000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TCE("ldc",	c100000, ec100000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TC3("ldcl",	c500000, ec500000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TCE("stc",	c000000, ec000000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TC3("stcl",	c400000, ec400000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TCE("mcr",	e000010, ee000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TCE("mrc",	e100010, ee100010, 6, (RCP, I7b, APSR_RR, RCN, RCN, oI7b),   co_reg, co_reg),

#undef  ARM_VARIANT
#define ARM_VARIANT  & arm_ext_v2s /* ARM 3 - swp instructions.  */

  CE("swp",	1000090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),
  C3(swpb,	1400090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v3	/* ARM 6 Status register instructions.	*/
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_msr

 TCE("mrs",	1000000, f3e08000, 2, (RRnpc, rPSR), mrs, t_mrs),
 TCE("msr",	120f000, f3808000, 2, (wPSR, RR_EXi), msr, t_msr),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v3m	 /* ARM 7M long multiplies.  */
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6t2

 TCE("smull",	0c00090, fb800000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM("smull","s",	0d00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE("umull",	0800090, fba00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM("umull","s",	0900090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE("smlal",	0e00090, fbc00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM("smlal","s",	0f00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE("umlal",	0a00090, fbe00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM("umlal","s",	0b00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v4	/* ARM Architecture 4.	*/
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v4t

 tC3("ldrh",	01000b0, _ldrh,     2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
 tC3("strh",	00000b0, _strh,     2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
 tC3("ldrsh",	01000f0, _ldrsh,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
 tC3("ldrsb",	01000d0, _ldrsb,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
 tC3("ldsh",	01000f0, _ldrsh,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
 tC3("ldsb",	01000d0, _ldrsb,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),

#undef  ARM_VARIANT
#define ARM_VARIANT  & arm_ext_v4t_5

  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.	 */
 TCE("bx",	12fff10, 4700, 1, (RR),	bx, t_bx),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v5 /*  ARM Architecture 5T.	 */
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v5t

  /* Note: blx has 2 variants; the .value coded here is for
     BLX(2).  Only this variant has conditional execution.  */
 TCE("blx",	12fff30, 4780, 1, (RR_EXr),			    blx,  t_blx),
 TUE("bkpt",	1200070, be00, 1, (oIffffb),			    bkpt, t_bkpt),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6t2

 TCE("clz",	16f0f10, fab0f080, 2, (RRnpc, RRnpc),		        rd_rm,  t_clz),
 TUF("ldc2",	c100000, fc100000, 3, (RCP, RCN, ADDRGLDC),	        lstc,	lstc),
 TUF("ldc2l",	c500000, fc500000, 3, (RCP, RCN, ADDRGLDC),		        lstc,	lstc),
 TUF("stc2",	c000000, fc000000, 3, (RCP, RCN, ADDRGLDC),	        lstc,	lstc),
 TUF("stc2l",	c400000, fc400000, 3, (RCP, RCN, ADDRGLDC),		        lstc,	lstc),
 TUF("cdp2",	e000000, fe000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TUF("mcr2",	e000010, fe000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TUF("mrc2",	e100010, fe100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v5exp /*  ARM Architecture 5TExP.  */
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v5exp

 TCE("smlabb",	1000080, fb100000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE("smlatb",	10000a0, fb100020, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE("smlabt",	10000c0, fb100010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE("smlatt",	10000e0, fb100030, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE("smlawb",	1200080, fb300000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE("smlawt",	12000c0, fb300010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE("smlalbb",	1400080, fbc00080, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE("smlaltb",	14000a0, fbc000a0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE("smlalbt",	14000c0, fbc00090, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE("smlaltt",	14000e0, fbc000b0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),

 TCE("smulbb",	1600080, fb10f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE("smultb",	16000a0, fb10f020, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE("smulbt",	16000c0, fb10f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE("smultt",	16000e0, fb10f030, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE("smulwb",	12000a0, fb30f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE("smulwt",	12000e0, fb30f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE("qadd",	1000050, fa80f080, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd2),
 TCE("qdadd",	1400050, fa80f090, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd2),
 TCE("qsub",	1200050, fa80f0a0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd2),
 TCE("qdsub",	1600050, fa80f0b0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd2),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v5e /*  ARM Architecture 5TE.  */
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6t2

 TUF("pld",	450f000, f810f000, 1, (ADDR),		     pld,  t_pld),
 TC3("ldrd",	00000d0, e8500000, 3, (RRnpc_npcsp, oRRnpc_npcsp, ADDRGLDRS),
     ldrd, t_ldstd),
 TC3("strd",	00000f0, e8400000, 3, (RRnpc_npcsp, oRRnpc_npcsp,
				       ADDRGLDRS), ldrd, t_ldstd),

 TCE("mcrr",	c400000, ec400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TCE("mrrc",	c500000, ec500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),

#undef  ARM_VARIANT
#define ARM_VARIANT  & arm_ext_v5j /*  ARM Architecture 5TEJ.  */

 TCE("bxj",	12fff20, f3c08f00, 1, (RR),			  bxj, t_bxj),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v6 /*  ARM V6.  */
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6

 TUF("cpsie",     1080000, b660,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 TUF("cpsid",     10c0000, b670,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 tCE("rev",       6bf0f30, _rev,      2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE("rev16",     6bf0fb0, _rev16,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE("revsh",     6ff0fb0, _revsh,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE("sxth",      6bf0070, _sxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE("uxth",      6ff0070, _uxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE("sxtb",      6af0070, _sxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE("uxtb",      6ef0070, _uxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 TUF("setend",    1010000, b650,     1, (ENDI),                     setend, t_setend),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6t2

 TCE("ldrex",	1900f9f, e8500f00, 2, (RRnpc_npcsp, ADDR),	  ldrex, t_ldrex),
 TCE("strex",	1800f90, e8400000, 3, (RRnpc_npcsp, RRnpc_npcsp, ADDR),
				      strex,  t_strex),
 TUF("mcrr2",	c400000, fc400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TUF("mrrc2",	c500000, fc500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),

 TCE("ssat",	6a00010, f3000000, 4, (RRnpc, I32, RRnpc, oSHllar),ssat,   t_ssat),
 TCE("usat",	6e00010, f3800000, 4, (RRnpc, I31, RRnpc, oSHllar),usat,   t_usat),

/*  ARM V6 not included in V7M.  */
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6_notm
 TUF("rfeia",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
 TUF("rfe",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfeib,	9900a00,           1, (RRw),			   rfe),
  UF(rfeda,	8100a00,           1, (RRw),			   rfe),
 TUF("rfedb",	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TUF("rfefd",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfefa,	8100a00,           1, (RRw),			   rfe),
 TUF("rfeea",	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
  UF(rfeed,	9900a00,           1, (RRw),			   rfe),
 TUF("srsia",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
 TUF("srs",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
 TUF("srsea",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
  UF(srsib,	9c00500,           2, (oRRw, I31w),		   srs),
  UF(srsfa,	9c00500,           2, (oRRw, I31w),		   srs),
  UF(srsda,	8400500,	   2, (oRRw, I31w),		   srs),
  UF(srsed,	8400500,	   2, (oRRw, I31w),		   srs),
 TUF("srsdb",	9400500, e800c000, 2, (oRRw, I31w),		   srs,  srs),
 TUF("srsfd",	9400500, e800c000, 2, (oRRw, I31w),		   srs,  srs),

/*  ARM V6 not included in V7M (eg. integer SIMD).  */
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6_dsp
 TUF("cps",	1020000, f3af8100, 1, (I31b),			  imm0, t_cps),
 TCE("pkhbt",	6800010, eac00000, 4, (RRnpc, RRnpc, RRnpc, oSHll),   pkhbt, t_pkhbt),
 TCE("pkhtb",	6800050, eac00020, 4, (RRnpc, RRnpc, RRnpc, oSHar),   pkhtb, t_pkhtb),
 TCE("qadd16",	6200f10, fa90f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("qadd8",	6200f90, fa80f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("qasx",	6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for QASX.  */
 TCE("qaddsubx",6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("qsax",	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for QSAX.  */
 TCE("qsubaddx",6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("qsub16",	6200f70, fad0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("qsub8",	6200ff0, fac0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("sadd16",	6100f10, fa90f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("sadd8",	6100f90, fa80f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("sasx",	6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for SASX.  */
 TCE("saddsubx",6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("shadd16",	6300f10, fa90f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("shadd8",	6300f90, fa80f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("shasx",   6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for SHASX.  */
 TCE("shaddsubx", 6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("shsax",     6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for SHSAX.  */
 TCE("shsubaddx", 6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("shsub16",	6300f70, fad0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("shsub8",	6300ff0, fac0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("ssax",	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for SSAX.  */
 TCE("ssubaddx",6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("ssub16",	6100f70, fad0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("ssub8",	6100ff0, fac0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uadd16",	6500f10, fa90f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uadd8",	6500f90, fa80f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uasx",	6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for UASX.  */
 TCE("uaddsubx",6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uhadd16",	6700f10, fa90f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uhadd8",	6700f90, fa80f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uhasx",   6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for UHASX.  */
 TCE("uhaddsubx", 6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uhsax",     6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for UHSAX.  */
 TCE("uhsubaddx", 6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uhsub16",	6700f70, fad0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uhsub8",	6700ff0, fac0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uqadd16",	6600f10, fa90f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uqadd8",	6600f90, fa80f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uqasx",   6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for UQASX.  */
 TCE("uqaddsubx", 6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uqsax",     6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for UQSAX.  */
 TCE("uqsubaddx", 6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uqsub16",	6600f70, fad0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("uqsub8",	6600ff0, fac0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("usub16",	6500f70, fad0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("usax",	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 /* Old name for USAX.  */
 TCE("usubaddx",6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("usub8",	6500ff0, fac0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("sxtah",	6b00070, fa00f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE("sxtab16",	6800070, fa20f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE("sxtab",	6a00070, fa40f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE("sxtb16",	68f0070, fa2ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE("uxtah",	6f00070, fa10f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE("uxtab16",	6c00070, fa30f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE("uxtab",	6e00070, fa50f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE("uxtb16",	6cf0070, fa3ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE("sel",	6800fb0, faa0f080, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE("smlad",	7000010, fb200000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE("smladx",	7000030, fb200010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE("smlald",	7400010, fbc000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE("smlaldx",	7400030, fbc000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE("smlsd",	7000050, fb400000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE("smlsdx",	7000070, fb400010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE("smlsld",	7400050, fbd000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE("smlsldx",	7400070, fbd000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE("smmla",	7500010, fb500000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE("smmlar",	7500030, fb500010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE("smmls",	75000d0, fb600000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE("smmlsr",	75000f0, fb600010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE("smmul",	750f010, fb50f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE("smmulr",	750f030, fb50f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE("smuad",	700f010, fb20f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE("smuadx",	700f030, fb20f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE("smusd",	700f050, fb40f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE("smusdx",	700f070, fb40f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE("ssat16",	6a00f30, f3200000, 3, (RRnpc, I16, RRnpc),	   ssat16, t_ssat16),
 TCE("umaal",	0400090, fbe00060, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,  t_mlal),
 TCE("usad8",	780f010, fb70f000, 3, (RRnpc, RRnpc, RRnpc),	   smul,   t_simd),
 TCE("usada8",	7800010, fb700000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla,   t_mla),
 TCE("usat16",	6e00f30, f3a00000, 3, (RRnpc, I15, RRnpc),	   usat16, t_usat16),

#undef  ARM_VARIANT
#define ARM_VARIANT   & arm_ext_v6k
#undef  THUMB_VARIANT
#define THUMB_VARIANT & arm_ext_v6k

 tCE("yield",	320f001, _yield,    0, (), noargs, t_hint),
 tCE("wfe",	320f002, _wfe,      0, (), noargs, t_hint),
 tCE("wfi",	320f003, _wfi,      0, (), noargs, t_hint),
 tCE("sev",	320f004, _sev,      0, (), noargs, t_hint),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6_notm
 TCE("ldrexd",	1b00f9f, e8d0007f, 3, (RRnpc_npcsp, oRRnpc_npcsp, RRnpcb),
				      ldrexd, t_ldrexd),
 TCE("strexd",	1a00f90, e8c00070, 4, (RRnpc_npcsp, RRnpc_npcsp, oRRnpc_npcsp,
				       RRnpcb), strexd, t_strexd),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6t2
 TCE("ldrexb",	1d00f9f, e8d00f4f, 2, (RRnpc_npcsp,RRnpcb),
     rd_rn,  rd_rn),
 TCE("ldrexh",	1f00f9f, e8d00f5f, 2, (RRnpc_npcsp, RRnpcb),
     rd_rn,  rd_rn),
 TCE("strexb",	1c00f90, e8c00f40, 3, (RRnpc_npcsp, RRnpc_npcsp, ADDR),
     strex, t_strexbh),
 TCE("strexh",	1e00f90, e8c00f50, 3, (RRnpc_npcsp, RRnpc_npcsp, ADDR),
     strex, t_strexbh),
 TUF("clrex",	57ff01f, f3bf8f2f, 0, (),			      noargs, noargs),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_sec
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_sec

 TCE("smc",	1600070, f7f08000, 1, (EXPi), smc, t_smc),

#undef	ARM_VARIANT
#define	ARM_VARIANT    & arm_ext_virt
#undef	THUMB_VARIANT
#define	THUMB_VARIANT    & arm_ext_virt

 TCE("hvc",	1400070, f7e08000, 1, (EXPi), hvc, t_hvc),
 TCE("eret",	160006e, f3de8f00, 0, (), noargs, noargs),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v6t2
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v6t2

 TCE("bfc",	7c0001f, f36f0000, 3, (RRnpc, I31, I32),	   bfc, t_bfc),
 TCE("bfi",	7c00010, f3600000, 4, (RRnpc, RRnpc_I0, I31, I32), bfi, t_bfi),
 TCE("sbfx",	7a00050, f3400000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),
 TCE("ubfx",	7e00050, f3c00000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),

 TCE("mls",	0600090, fb000010, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
 TCE("movw",	3000000, f2400000, 2, (RRnpc, HALF),		    mov16, t_mov16),
 TCE("movt",	3400000, f2c00000, 2, (RRnpc, HALF),		    mov16, t_mov16),
 TCE("rbit",	6ff0f30, fa90f0a0, 2, (RR, RR),			    rd_rm, t_rbit),

 TC3("ldrht",	03000b0, f8300e00, 2, (RRnpc_npcsp, ADDR), ldsttv4, t_ldstt),
 TC3("ldrsht",	03000f0, f9300e00, 2, (RRnpc_npcsp, ADDR), ldsttv4, t_ldstt),
 TC3("ldrsbt",	03000d0, f9100e00, 2, (RRnpc_npcsp, ADDR), ldsttv4, t_ldstt),
 TC3("strht",	02000b0, f8200e00, 2, (RRnpc_npcsp, ADDR), ldsttv4, t_ldstt),

 /* Thumb-only instructions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT NULL
  TUE("cbnz",     0,           b900,     2, (RR, EXP), 0, t_cbz),
  TUE("cbz",      0,           b100,     2, (RR, EXP), 0, t_cbz),

 /* ARM does not really have an IT instruction, so always allow it.
    The opcode is copied from Thumb in order to allow warnings in
    -mimplicit-it=[never | arm] modes.  */
#undef  ARM_VARIANT
#define ARM_VARIANT  & arm_ext_v1

 TUE("it",        bf08,        bf08,     1, (COND),   it,    t_it),
 TUE("itt",       bf0c,        bf0c,     1, (COND),   it,    t_it),
 TUE("ite",       bf04,        bf04,     1, (COND),   it,    t_it),
 TUE("ittt",      bf0e,        bf0e,     1, (COND),   it,    t_it),
 TUE("itet",      bf06,        bf06,     1, (COND),   it,    t_it),
 TUE("itte",      bf0a,        bf0a,     1, (COND),   it,    t_it),
 TUE("itee",      bf02,        bf02,     1, (COND),   it,    t_it),
 TUE("itttt",     bf0f,        bf0f,     1, (COND),   it,    t_it),
 TUE("itett",     bf07,        bf07,     1, (COND),   it,    t_it),
 TUE("ittet",     bf0b,        bf0b,     1, (COND),   it,    t_it),
 TUE("iteet",     bf03,        bf03,     1, (COND),   it,    t_it),
 TUE("ittte",     bf0d,        bf0d,     1, (COND),   it,    t_it),
 TUE("itete",     bf05,        bf05,     1, (COND),   it,    t_it),
 TUE("ittee",     bf09,        bf09,     1, (COND),   it,    t_it),
 TUE("iteee",     bf01,        bf01,     1, (COND),   it,    t_it),
 /* ARM/Thumb-2 instructions with no Thumb-1 equivalent.  */
 TC3("rrx",       01a00060, ea4f0030, 2, (RR, RR), rd_rm, t_rrx),
 TC3("rrxs",      01b00060, ea5f0030, 2, (RR, RR), rd_rm, t_rrx),

 /* Thumb2 only instructions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT  NULL

 TCE("addw",	0, f2000000, 3, (RR, RR, EXPi), 0, t_add_sub_w),
 TCE("subw",	0, f2a00000, 3, (RR, RR, EXPi), 0, t_add_sub_w),
 TCE("orn",       0, ea600000, 3, (RR, oRR, SH),  0, t_orn),
 TCE("orns",      0, ea700000, 3, (RR, oRR, SH),  0, t_orn),
 TCE("tbb",       0, e8d0f000, 1, (TB), 0, t_tb),
 TCE("tbh",       0, e8d0f010, 1, (TB), 0, t_tb),

 /* Hardware division instructions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_adiv
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_div

 TCE("sdiv",	710f010, fb90f0f0, 3, (RR, oRR, RR), div, t_div),
 TCE("udiv",	730f010, fbb0f0f0, 3, (RR, oRR, RR), div, t_div),

 /* ARM V6M/V7 instructions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_barrier
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_barrier

 TUF("dmb",	57ff050, f3bf8f50, 1, (oBARRIER_I15), barrier, barrier),
 TUF("dsb",	57ff040, f3bf8f40, 1, (oBARRIER_I15), barrier, barrier),
 TUF("isb",	57ff060, f3bf8f60, 1, (oBARRIER_I15), barrier, barrier),

 /* ARM V7 instructions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_v7
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_v7

 TUF("pli",	450f000, f910f000, 1, (ADDR),	  pli,	    t_pld),
 TCE("dbg",	320f0f0, f3af80f0, 1, (I15),	  dbg,	    t_dbg),

#undef  ARM_VARIANT
#define ARM_VARIANT    & arm_ext_mp
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & arm_ext_mp

 TUF("pldw",	410f000, f830f000, 1, (ADDR),	pld,	t_pld),

 /* AArchv8 instructions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT   & arm_ext_v8
#undef  THUMB_VARIANT
#define THUMB_VARIANT & arm_ext_v8

 tCE("sevl",	320f005, _sevl,    0, (),		noargs,	t_hint),
 TUE("hlt",	1000070, ba80,     1, (oIffffb),	bkpt,	t_hlt),
 TCE("ldaex",	1900e9f, e8d00fef, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
 TCE("ldaexd",	1b00e9f, e8d000ff, 3, (RRnpc, oRRnpc, RRnpcb),
							ldrexd, t_ldrexd),
 TCE("ldaexb",	1d00e9f, e8d00fcf, 2, (RRnpc,RRnpcb),	rd_rn,  rd_rn),
 TCE("ldaexh",	1f00e9f, e8d00fdf, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("stlex",	1800e90, e8c00fe0, 3, (RRnpc, RRnpc, RRnpcb),
							stlex,  t_stlex),
 TCE("stlexd",	1a00e90, e8c000f0, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb),
							strexd, t_strexd),
 TCE("stlexb",	1c00e90, e8c00fc0, 3, (RRnpc, RRnpc, RRnpcb),
							stlex, t_stlex),
 TCE("stlexh",	1e00e90, e8c00fd0, 3, (RRnpc, RRnpc, RRnpcb),
							stlex, t_stlex),
 TCE("lda",	1900c9f, e8d00faf, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
 TCE("ldab",	1d00c9f, e8d00f8f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("ldah",	1f00c9f, e8d00f9f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("stl",	180fc90, e8c00faf, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
 TCE("stlb",	1c0fc90, e8c00f8f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
 TCE("stlh",	1e0fc90, e8c00f9f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),

 /* ARMv8 T32 only.  */
#undef  ARM_VARIANT
#define ARM_VARIANT  NULL
 TUF("dcps1",	0,	 f78f8001, 0, (),	noargs, noargs),
 TUF("dcps2",	0,	 f78f8002, 0, (),	noargs, noargs),
 TUF("dcps3",	0,	 f78f8003, 0, (),	noargs, noargs),

  /* FP for ARMv8.  */
#undef  ARM_VARIANT
#define ARM_VARIANT   & fpu_vfp_ext_armv8
#undef  THUMB_VARIANT
#define THUMB_VARIANT & fpu_vfp_ext_armv8

  nUF(vseleq, _vseleq, 3, (RVSD, RVSD, RVSD),		vsel),
  nUF(vselvs, _vselvs, 3, (RVSD, RVSD, RVSD),		vsel),
  nUF(vselge, _vselge, 3, (RVSD, RVSD, RVSD),		vsel),
  nUF(vselgt, _vselgt, 3, (RVSD, RVSD, RVSD),		vsel),
  nUF(vmaxnm, _vmaxnm, 3, (RNSDQ, oRNSDQ, RNSDQ),	vmaxnm),
  nUF(vminnm, _vminnm, 3, (RNSDQ, oRNSDQ, RNSDQ),	vmaxnm),
  nUF(vcvta,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvta),
  nUF(vcvtn,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtn),
  nUF(vcvtp,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtp),
  nUF(vcvtm,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtm),
  nCE(vrintr, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintr),
  nCE(vrintz, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintz),
  nCE(vrintx, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintx),
  nUF(vrinta, _vrinta, 2, (RNSDQ, oRNSDQ),		vrinta),
  nUF(vrintn, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintn),
  nUF(vrintp, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintp),
  nUF(vrintm, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintm),

  /* Crypto v1 extensions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT & fpu_crypto_ext_armv8
#undef  THUMB_VARIANT
#define THUMB_VARIANT & fpu_crypto_ext_armv8

  nUF(aese, _aes, 2, (RNQ, RNQ), aese),
  nUF(aesd, _aes, 2, (RNQ, RNQ), aesd),
  nUF(aesmc, _aes, 2, (RNQ, RNQ), aesmc),
  nUF(aesimc, _aes, 2, (RNQ, RNQ), aesimc),
  nUF(sha1c, _sha3op, 3, (RNQ, RNQ, RNQ), sha1c),
  nUF(sha1p, _sha3op, 3, (RNQ, RNQ, RNQ), sha1p),
  nUF(sha1m, _sha3op, 3, (RNQ, RNQ, RNQ), sha1m),
  nUF(sha1su0, _sha3op, 3, (RNQ, RNQ, RNQ), sha1su0),
  nUF(sha256h, _sha3op, 3, (RNQ, RNQ, RNQ), sha256h),
  nUF(sha256h2, _sha3op, 3, (RNQ, RNQ, RNQ), sha256h2),
  nUF(sha256su1, _sha3op, 3, (RNQ, RNQ, RNQ), sha256su1),
  nUF(sha1h, _sha1h, 2, (RNQ, RNQ), sha1h),
  nUF(sha1su1, _sha2op, 2, (RNQ, RNQ), sha1su1),
  nUF(sha256su0, _sha2op, 2, (RNQ, RNQ), sha256su0),

#undef  ARM_VARIANT
#define ARM_VARIANT   & crc_ext_armv8
#undef  THUMB_VARIANT
#define THUMB_VARIANT & crc_ext_armv8
  TUEc("crc32b", 1000040, fac0f080, 3, (RR, oRR, RR), crc32b),
  TUEc("crc32h", 1200040, fac0f090, 3, (RR, oRR, RR), crc32h),
  TUEc("crc32w", 1400040, fac0f0a0, 3, (RR, oRR, RR), crc32w),
  TUEc("crc32cb",1000240, fad0f080, 3, (RR, oRR, RR), crc32cb),
  TUEc("crc32ch",1200240, fad0f090, 3, (RR, oRR, RR), crc32ch),
  TUEc("crc32cw",1400240, fad0f0a0, 3, (RR, oRR, RR), crc32cw),

#undef  ARM_VARIANT
#define ARM_VARIANT  & fpu_fpa_ext_v1  /* Core FPA instruction set (V1).  */
#undef  THUMB_VARIANT
#define THUMB_VARIANT NULL

 cCE("wfs",	e200110, 1, (RR),	     rd),
 cCE("rfs",	e300110, 1, (RR),	     rd),
 cCE("wfc",	e400110, 1, (RR),	     rd),
 cCE("rfc",	e500110, 1, (RR),	     rd),

 cCL("ldfs",	c100100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL("ldfd",	c108100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL("ldfe",	c500100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL("ldfp",	c508100, 2, (RF, ADDRGLDC),  rd_cpaddr),

 cCL("stfs",	c000100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL("stfd",	c008100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL("stfe",	c400100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL("stfp",	c408100, 2, (RF, ADDRGLDC),  rd_cpaddr),

 cCL("mvfs",	e008100, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfsp",	e008120, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfsm",	e008140, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfsz",	e008160, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfd",	e008180, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfdp",	e0081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfdm",	e0081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfdz",	e0081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfe",	e088100, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfep",	e088120, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfem",	e088140, 2, (RF, RF_IF),     rd_rm),
 cCL("mvfez",	e088160, 2, (RF, RF_IF),     rd_rm),

 cCL("mnfs",	e108100, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfsp",	e108120, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfsm",	e108140, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfsz",	e108160, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfd",	e108180, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfdp",	e1081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfdm",	e1081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfdz",	e1081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfe",	e188100, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfep",	e188120, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfem",	e188140, 2, (RF, RF_IF),     rd_rm),
 cCL("mnfez",	e188160, 2, (RF, RF_IF),     rd_rm),

 cCL("abss",	e208100, 2, (RF, RF_IF),     rd_rm),
 cCL("abssp",	e208120, 2, (RF, RF_IF),     rd_rm),
 cCL("abssm",	e208140, 2, (RF, RF_IF),     rd_rm),
 cCL("abssz",	e208160, 2, (RF, RF_IF),     rd_rm),
 cCL("absd",	e208180, 2, (RF, RF_IF),     rd_rm),
 cCL("absdp",	e2081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("absdm",	e2081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("absdz",	e2081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("abse",	e288100, 2, (RF, RF_IF),     rd_rm),
 cCL("absep",	e288120, 2, (RF, RF_IF),     rd_rm),
 cCL("absem",	e288140, 2, (RF, RF_IF),     rd_rm),
 cCL("absez",	e288160, 2, (RF, RF_IF),     rd_rm),

 cCL("rnds",	e308100, 2, (RF, RF_IF),     rd_rm),
 cCL("rndsp",	e308120, 2, (RF, RF_IF),     rd_rm),
 cCL("rndsm",	e308140, 2, (RF, RF_IF),     rd_rm),
 cCL("rndsz",	e308160, 2, (RF, RF_IF),     rd_rm),
 cCL("rndd",	e308180, 2, (RF, RF_IF),     rd_rm),
 cCL("rnddp",	e3081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("rnddm",	e3081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("rnddz",	e3081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("rnde",	e388100, 2, (RF, RF_IF),     rd_rm),
 cCL("rndep",	e388120, 2, (RF, RF_IF),     rd_rm),
 cCL("rndem",	e388140, 2, (RF, RF_IF),     rd_rm),
 cCL("rndez",	e388160, 2, (RF, RF_IF),     rd_rm),

 cCL("sqts",	e408100, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtsp",	e408120, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtsm",	e408140, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtsz",	e408160, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtd",	e408180, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtdp",	e4081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtdm",	e4081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtdz",	e4081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("sqte",	e488100, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtep",	e488120, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtem",	e488140, 2, (RF, RF_IF),     rd_rm),
 cCL("sqtez",	e488160, 2, (RF, RF_IF),     rd_rm),

 cCL("logs",	e508100, 2, (RF, RF_IF),     rd_rm),
 cCL("logsp",	e508120, 2, (RF, RF_IF),     rd_rm),
 cCL("logsm",	e508140, 2, (RF, RF_IF),     rd_rm),
 cCL("logsz",	e508160, 2, (RF, RF_IF),     rd_rm),
 cCL("logd",	e508180, 2, (RF, RF_IF),     rd_rm),
 cCL("logdp",	e5081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("logdm",	e5081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("logdz",	e5081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("loge",	e588100, 2, (RF, RF_IF),     rd_rm),
 cCL("logep",	e588120, 2, (RF, RF_IF),     rd_rm),
 cCL("logem",	e588140, 2, (RF, RF_IF),     rd_rm),
 cCL("logez",	e588160, 2, (RF, RF_IF),     rd_rm),

 cCL("lgns",	e608100, 2, (RF, RF_IF),     rd_rm),
 cCL("lgnsp",	e608120, 2, (RF, RF_IF),     rd_rm),
 cCL("lgnsm",	e608140, 2, (RF, RF_IF),     rd_rm),
 cCL("lgnsz",	e608160, 2, (RF, RF_IF),     rd_rm),
 cCL("lgnd",	e608180, 2, (RF, RF_IF),     rd_rm),
 cCL("lgndp",	e6081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("lgndm",	e6081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("lgndz",	e6081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("lgne",	e688100, 2, (RF, RF_IF),     rd_rm),
 cCL("lgnep",	e688120, 2, (RF, RF_IF),     rd_rm),
 cCL("lgnem",	e688140, 2, (RF, RF_IF),     rd_rm),
 cCL("lgnez",	e688160, 2, (RF, RF_IF),     rd_rm),

 cCL("exps",	e708100, 2, (RF, RF_IF),     rd_rm),
 cCL("expsp",	e708120, 2, (RF, RF_IF),     rd_rm),
 cCL("expsm",	e708140, 2, (RF, RF_IF),     rd_rm),
 cCL("expsz",	e708160, 2, (RF, RF_IF),     rd_rm),
 cCL("expd",	e708180, 2, (RF, RF_IF),     rd_rm),
 cCL("expdp",	e7081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("expdm",	e7081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("expdz",	e7081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("expe",	e788100, 2, (RF, RF_IF),     rd_rm),
 cCL("expep",	e788120, 2, (RF, RF_IF),     rd_rm),
 cCL("expem",	e788140, 2, (RF, RF_IF),     rd_rm),
 cCL("expdz",	e788160, 2, (RF, RF_IF),     rd_rm),

 cCL("sins",	e808100, 2, (RF, RF_IF),     rd_rm),
 cCL("sinsp",	e808120, 2, (RF, RF_IF),     rd_rm),
 cCL("sinsm",	e808140, 2, (RF, RF_IF),     rd_rm),
 cCL("sinsz",	e808160, 2, (RF, RF_IF),     rd_rm),
 cCL("sind",	e808180, 2, (RF, RF_IF),     rd_rm),
 cCL("sindp",	e8081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("sindm",	e8081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("sindz",	e8081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("sine",	e888100, 2, (RF, RF_IF),     rd_rm),
 cCL("sinep",	e888120, 2, (RF, RF_IF),     rd_rm),
 cCL("sinem",	e888140, 2, (RF, RF_IF),     rd_rm),
 cCL("sinez",	e888160, 2, (RF, RF_IF),     rd_rm),

 cCL("coss",	e908100, 2, (RF, RF_IF),     rd_rm),
 cCL("cossp",	e908120, 2, (RF, RF_IF),     rd_rm),
 cCL("cossm",	e908140, 2, (RF, RF_IF),     rd_rm),
 cCL("cossz",	e908160, 2, (RF, RF_IF),     rd_rm),
 cCL("cosd",	e908180, 2, (RF, RF_IF),     rd_rm),
 cCL("cosdp",	e9081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("cosdm",	e9081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("cosdz",	e9081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("cose",	e988100, 2, (RF, RF_IF),     rd_rm),
 cCL("cosep",	e988120, 2, (RF, RF_IF),     rd_rm),
 cCL("cosem",	e988140, 2, (RF, RF_IF),     rd_rm),
 cCL("cosez",	e988160, 2, (RF, RF_IF),     rd_rm),

 cCL("tans",	ea08100, 2, (RF, RF_IF),     rd_rm),
 cCL("tansp",	ea08120, 2, (RF, RF_IF),     rd_rm),
 cCL("tansm",	ea08140, 2, (RF, RF_IF),     rd_rm),
 cCL("tansz",	ea08160, 2, (RF, RF_IF),     rd_rm),
 cCL("tand",	ea08180, 2, (RF, RF_IF),     rd_rm),
 cCL("tandp",	ea081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("tandm",	ea081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("tandz",	ea081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("tane",	ea88100, 2, (RF, RF_IF),     rd_rm),
 cCL("tanep",	ea88120, 2, (RF, RF_IF),     rd_rm),
 cCL("tanem",	ea88140, 2, (RF, RF_IF),     rd_rm),
 cCL("tanez",	ea88160, 2, (RF, RF_IF),     rd_rm),

 cCL("asns",	eb08100, 2, (RF, RF_IF),     rd_rm),
 cCL("asnsp",	eb08120, 2, (RF, RF_IF),     rd_rm),
 cCL("asnsm",	eb08140, 2, (RF, RF_IF),     rd_rm),
 cCL("asnsz",	eb08160, 2, (RF, RF_IF),     rd_rm),
 cCL("asnd",	eb08180, 2, (RF, RF_IF),     rd_rm),
 cCL("asndp",	eb081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("asndm",	eb081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("asndz",	eb081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("asne",	eb88100, 2, (RF, RF_IF),     rd_rm),
 cCL("asnep",	eb88120, 2, (RF, RF_IF),     rd_rm),
 cCL("asnem",	eb88140, 2, (RF, RF_IF),     rd_rm),
 cCL("asnez",	eb88160, 2, (RF, RF_IF),     rd_rm),

 cCL("acss",	ec08100, 2, (RF, RF_IF),     rd_rm),
 cCL("acssp",	ec08120, 2, (RF, RF_IF),     rd_rm),
 cCL("acssm",	ec08140, 2, (RF, RF_IF),     rd_rm),
 cCL("acssz",	ec08160, 2, (RF, RF_IF),     rd_rm),
 cCL("acsd",	ec08180, 2, (RF, RF_IF),     rd_rm),
 cCL("acsdp",	ec081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("acsdm",	ec081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("acsdz",	ec081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("acse",	ec88100, 2, (RF, RF_IF),     rd_rm),
 cCL("acsep",	ec88120, 2, (RF, RF_IF),     rd_rm),
 cCL("acsem",	ec88140, 2, (RF, RF_IF),     rd_rm),
 cCL("acsez",	ec88160, 2, (RF, RF_IF),     rd_rm),

 cCL("atns",	ed08100, 2, (RF, RF_IF),     rd_rm),
 cCL("atnsp",	ed08120, 2, (RF, RF_IF),     rd_rm),
 cCL("atnsm",	ed08140, 2, (RF, RF_IF),     rd_rm),
 cCL("atnsz",	ed08160, 2, (RF, RF_IF),     rd_rm),
 cCL("atnd",	ed08180, 2, (RF, RF_IF),     rd_rm),
 cCL("atndp",	ed081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("atndm",	ed081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("atndz",	ed081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("atne",	ed88100, 2, (RF, RF_IF),     rd_rm),
 cCL("atnep",	ed88120, 2, (RF, RF_IF),     rd_rm),
 cCL("atnem",	ed88140, 2, (RF, RF_IF),     rd_rm),
 cCL("atnez",	ed88160, 2, (RF, RF_IF),     rd_rm),

 cCL("urds",	ee08100, 2, (RF, RF_IF),     rd_rm),
 cCL("urdsp",	ee08120, 2, (RF, RF_IF),     rd_rm),
 cCL("urdsm",	ee08140, 2, (RF, RF_IF),     rd_rm),
 cCL("urdsz",	ee08160, 2, (RF, RF_IF),     rd_rm),
 cCL("urdd",	ee08180, 2, (RF, RF_IF),     rd_rm),
 cCL("urddp",	ee081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("urddm",	ee081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("urddz",	ee081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("urde",	ee88100, 2, (RF, RF_IF),     rd_rm),
 cCL("urdep",	ee88120, 2, (RF, RF_IF),     rd_rm),
 cCL("urdem",	ee88140, 2, (RF, RF_IF),     rd_rm),
 cCL("urdez",	ee88160, 2, (RF, RF_IF),     rd_rm),

 cCL("nrms",	ef08100, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmsp",	ef08120, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmsm",	ef08140, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmsz",	ef08160, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmd",	ef08180, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmdp",	ef081a0, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmdm",	ef081c0, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmdz",	ef081e0, 2, (RF, RF_IF),     rd_rm),
 cCL("nrme",	ef88100, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmep",	ef88120, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmem",	ef88140, 2, (RF, RF_IF),     rd_rm),
 cCL("nrmez",	ef88160, 2, (RF, RF_IF),     rd_rm),

 cCL("adfs",	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfsp",	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfsm",	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfsz",	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfd",	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfdp",	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfdm",	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfdz",	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfe",	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfep",	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfem",	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("adfez",	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("sufs",	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufsp",	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufsm",	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufsz",	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufd",	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufdp",	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufdm",	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufdz",	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufe",	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufep",	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufem",	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("sufez",	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("rsfs",	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfsp",	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfsm",	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfsz",	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfd",	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfdp",	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfdm",	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfdz",	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfe",	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfep",	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfem",	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rsfez",	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("mufs",	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufsp",	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufsm",	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufsz",	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufd",	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufdp",	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufdm",	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufdz",	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufe",	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufep",	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufem",	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("mufez",	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("dvfs",	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfsp",	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfsm",	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfsz",	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfd",	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfdp",	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfdm",	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfdz",	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfe",	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfep",	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfem",	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("dvfez",	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("rdfs",	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfsp",	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfsm",	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfsz",	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfd",	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfdp",	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfdm",	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfdz",	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfe",	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfep",	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfem",	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rdfez",	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("pows",	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powsp",	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powsm",	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powsz",	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powd",	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powdp",	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powdm",	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powdz",	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powe",	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powep",	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powem",	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("powez",	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("rpws",	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwsp",	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwsm",	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwsz",	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwd",	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwdp",	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwdm",	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwdz",	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwe",	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwep",	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwem",	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rpwez",	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("rmfs",	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfsp",	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfsm",	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfsz",	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfd",	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfdp",	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfdm",	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfdz",	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfe",	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfep",	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfem",	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("rmfez",	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("fmls",	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmlsp",	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmlsm",	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmlsz",	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmld",	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmldp",	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmldm",	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmldz",	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmle",	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmlep",	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmlem",	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fmlez",	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("fdvs",	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvsp",	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvsm",	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvsz",	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvd",	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvdp",	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvdm",	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvdz",	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdve",	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvep",	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvem",	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("fdvez",	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("frds",	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frdsp",	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frdsm",	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frdsz",	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frdd",	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frddp",	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frddm",	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frddz",	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frde",	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frdep",	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frdem",	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("frdez",	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL("pols",	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("polsp",	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("polsm",	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("polsz",	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("pold",	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("poldp",	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("poldm",	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("poldz",	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("pole",	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("polep",	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("polem",	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL("polez",	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCE("cmf",	e90f110, 2, (RF, RF_IF),     fpa_cmp),
 C3E("cmfe",	ed0f110, 2, (RF, RF_IF),     fpa_cmp),
 cCE("cnf",	eb0f110, 2, (RF, RF_IF),     fpa_cmp),
 C3E("cnfe",	ef0f110, 2, (RF, RF_IF),     fpa_cmp),

 cCL("flts",	e000110, 2, (RF, RR),	     rn_rd),
 cCL("fltsp",	e000130, 2, (RF, RR),	     rn_rd),
 cCL("fltsm",	e000150, 2, (RF, RR),	     rn_rd),
 cCL("fltsz",	e000170, 2, (RF, RR),	     rn_rd),
 cCL("fltd",	e000190, 2, (RF, RR),	     rn_rd),
 cCL("fltdp",	e0001b0, 2, (RF, RR),	     rn_rd),
 cCL("fltdm",	e0001d0, 2, (RF, RR),	     rn_rd),
 cCL("fltdz",	e0001f0, 2, (RF, RR),	     rn_rd),
 cCL("flte",	e080110, 2, (RF, RR),	     rn_rd),
 cCL("fltep",	e080130, 2, (RF, RR),	     rn_rd),
 cCL("fltem",	e080150, 2, (RF, RR),	     rn_rd),
 cCL("fltez",	e080170, 2, (RF, RR),	     rn_rd),

  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
 cCE("fix",	e100110, 2, (RR, RF),	     rd_rm),
 cCL("fixp",	e100130, 2, (RR, RF),	     rd_rm),
 cCL("fixm",	e100150, 2, (RR, RF),	     rd_rm),
 cCL("fixz",	e100170, 2, (RR, RF),	     rd_rm),
 cCL("fixsp",	e100130, 2, (RR, RF),	     rd_rm),
 cCL("fixsm",	e100150, 2, (RR, RF),	     rd_rm),
 cCL("fixsz",	e100170, 2, (RR, RF),	     rd_rm),
 cCL("fixdp",	e100130, 2, (RR, RF),	     rd_rm),
 cCL("fixdm",	e100150, 2, (RR, RF),	     rd_rm),
 cCL("fixdz",	e100170, 2, (RR, RF),	     rd_rm),
 cCL("fixep",	e100130, 2, (RR, RF),	     rd_rm),
 cCL("fixem",	e100150, 2, (RR, RF),	     rd_rm),
 cCL("fixez",	e100170, 2, (RR, RF),	     rd_rm),

  /* Instructions that were new with the real FPA, call them V2.  */
#undef  ARM_VARIANT
#define ARM_VARIANT  & fpu_fpa_ext_v2

 cCE("lfm",	c100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCL("lfmfd",	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCL("lfmea",	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCE("sfm",	c000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCL("sfmfd",	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCL("sfmea",	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),

#undef  ARM_VARIANT
#define ARM_VARIANT  & fpu_vfp_ext_v1xd  /* VFP V1xD (single precision).  */

  /* Moves and type conversions.  */
 cCE("fcpys",	eb00a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("fmrs",	e100a10, 2, (RR, RVS),	      vfp_reg_from_sp),
 cCE("fmsr",	e000a10, 2, (RVS, RR),	      vfp_sp_from_reg),
 cCE("fmstat",	ef1fa10, 0, (),		      noargs),
 cCE("vmrs",	ef00a10, 2, (APSR_RR, RVC),   vmrs),
 cCE("vmsr",	ee00a10, 2, (RVC, RR),        vmsr),
 cCE("fsitos",	eb80ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("fuitos",	eb80a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("ftosis",	ebd0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("ftosizs",	ebd0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("ftouis",	ebc0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("ftouizs",	ebc0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("fmrx",	ef00a10, 2, (RR, RVC),	      rd_rn),
 cCE("fmxr",	ee00a10, 2, (RVC, RR),	      rn_rd),

  /* Memory operations.	 */
 cCE("flds",	d100a00, 2, (RVS, ADDRGLDC),  vfp_sp_ldst),
 cCE("fsts",	d000a00, 2, (RVS, ADDRGLDC),  vfp_sp_ldst),
 cCE("fldmias",	c900a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmia),
 cCE("fldmfds",	c900a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmia),
 cCE("fldmdbs",	d300a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmdb),
 cCE("fldmeas",	d300a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmdb),
 cCE("fldmiax",	c900b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmia),
 cCE("fldmfdx",	c900b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmia),
 cCE("fldmdbx",	d300b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmdb),
 cCE("fldmeax",	d300b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmdb),
 cCE("fstmias",	c800a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmia),
 cCE("fstmeas",	c800a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmia),
 cCE("fstmdbs",	d200a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmdb),
 cCE("fstmfds",	d200a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmdb),
 cCE("fstmiax",	c800b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmia),
 cCE("fstmeax",	c800b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmia),
 cCE("fstmdbx",	d200b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmdb),
 cCE("fstmfdx",	d200b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmdb),

  /* Monadic operations.  */
 cCE("fabss",	eb00ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("fnegs",	eb10a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("fsqrts",	eb10ac0, 2, (RVS, RVS),	      vfp_sp_monadic),

  /* Dyadic operations.	 */
 cCE("fadds",	e300a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("fsubs",	e300a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("fmuls",	e200a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("fdivs",	e800a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("fmacs",	e000a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("fmscs",	e100a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("fnmuls",	e200a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("fnmacs",	e000a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("fnmscs",	e100a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),

  /* Comparisons.  */
 cCE("fcmps",	eb40a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("fcmpzs",	eb50a40, 1, (RVS),	      vfp_sp_compare_z),
 cCE("fcmpes",	eb40ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE("fcmpezs",	eb50ac0, 1, (RVS),	      vfp_sp_compare_z),

 /* Double precision load/store are still present on single precision
    implementations.  */
 cCE("fldd",	d100b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
 cCE("fstd",	d000b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
 cCE("fldmiad",	c900b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmia),
 cCE("fldmfdd",	c900b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmia),
 cCE("fldmdbd",	d300b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fldmead",	d300b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fstmiad",	c800b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmia),
 cCE("fstmead",	c800b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmia),
 cCE("fstmdbd",	d200b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fstmfdd",	d200b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmdb),

#undef  ARM_VARIANT
#define ARM_VARIANT  & fpu_vfp_ext_v1 /* VFP V1 (Double precision).  */

  /* Moves and type conversions.  */
 cCE("fcpyd",	eb00b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE("fcvtds",	eb70ac0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
 cCE("fcvtsd",	eb70bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
 cCE("fmdhr",	e200b10, 2, (RVD, RR),	      vfp_dp_rn_rd),
 cCE("fmdlr",	e000b10, 2, (RVD, RR),	      vfp_dp_rn_rd),
 cCE("fmrdh",	e300b10, 2, (RR, RVD),	      vfp_dp_rd_rn),
 cCE("fmrdl",	e100b10, 2, (RR, RVD),	      vfp_dp_rd_rn),
 cCE("fsitod",	eb80bc0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
 cCE("fuitod",	eb80b40, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
 cCE("ftosid",	ebd0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
 cCE("ftosizd",	ebd0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
 cCE("ftouid",	ebc0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
 cCE("ftouizd",	ebc0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),

  /* Monadic operations.  */
 cCE("fabsd",	eb00bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE("fnegd",	eb10b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE("fsqrtd",	eb10bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),

  /* Dyadic operations.	 */
 cCE("faddd",	e300b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("fsubd",	e300b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("fmuld",	e200b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("fdivd",	e800b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("fmacd",	e000b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("fmscd",	e100b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("fnmuld",	e200b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("fnmacd",	e000b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("fnmscd",	e100b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),

  /* Comparisons.  */
 cCE("fcmpd",	eb40b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE("fcmpzd",	eb50b40, 1, (RVD),	      vfp_dp_rd),
 cCE("fcmped",	eb40bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE("fcmpezd",	eb50bc0, 1, (RVD),	      vfp_dp_rd),

#undef  ARM_VARIANT
#define ARM_VARIANT  & fpu_vfp_ext_v2

 cCE("fmsrr",	c400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),
 cCE("fmrrs",	c500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),
 cCE("fmdrr",	c400b10, 3, (RVD, RR, RR),    vfp_dp_rm_rd_rn),
 cCE("fmrrd",	c500b10, 3, (RR, RR, RVD),    vfp_dp_rd_rn_rm),

/* Instructions which may belong to either the Neon or VFP instruction sets.
   Individual encoder functions perform additional architecture checks.  */
#undef  ARM_VARIANT
#define ARM_VARIANT    & fpu_vfp_ext_v1xd
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & fpu_vfp_ext_v1xd

  /* These mnemonics are unique to VFP.  */
 NCE(vsqrt,     0,       2, (RVSD, RVSD),       vfp_nsyn_sqrt),
 NCE(vdiv,      0,       3, (RVSD, RVSD, RVSD), vfp_nsyn_div),
 nCE(vnmul,     _vnmul,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vnmla,     _vnmla,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vnmls,     _vnmls,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vcmp,      _vcmp,    2, (RVSD, RVSD_I0),    vfp_nsyn_cmp),
 nCE(vcmpe,     _vcmpe,   2, (RVSD, RVSD_I0),    vfp_nsyn_cmp),
 NCE(vpush,     0,       1, (VRSDLST),          vfp_nsyn_push),
 NCE(vpop,      0,       1, (VRSDLST),          vfp_nsyn_pop),
 NCE(vcvtz,     0,       2, (RVSD, RVSD),       vfp_nsyn_cvtz),

  /* Mnemonics shared by Neon and VFP.  */
 nCEF(vmul,     _vmul,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mul),
 nCEF(vmla,     _vmla,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),
 nCEF(vmls,     _vmls,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),

 nCEF(vadd,     _vadd,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),
 nCEF(vsub,     _vsub,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),

 NCEF(vabs,     1b10300, 2, (RNSDQ, RNSDQ), neon_abs_neg),
 NCEF(vneg,     1b10380, 2, (RNSDQ, RNSDQ), neon_abs_neg),

 NCE(vldm,      c900b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
 NCE(vldmia,    c900b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
 NCE(vldmdb,    d100b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
 NCE(vstm,      c800b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
 NCE(vstmia,    c800b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
 NCE(vstmdb,    d000b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
 NCE(vldr,      d100b00, 2, (RVSD, ADDRGLDC), neon_ldr_str),
 NCE(vstr,      d000b00, 2, (RVSD, ADDRGLDC), neon_ldr_str),

 nCEF(vcvt,     _vcvt,   3, (RNSDQ, RNSDQ, oI32z), neon_cvt),
 nCEF(vcvtr,    _vcvt,   2, (RNSDQ, RNSDQ), neon_cvtr),
 NCEF(vcvtb,	eb20a40, 2, (RVSD, RVSD), neon_cvtb),
 NCEF(vcvtt,	eb20a40, 2, (RVSD, RVSD), neon_cvtt),


  /* NOTE: All VMOV encoding is special-cased!  */
 NCE(vmov,      0,       1, (VMOV), neon_mov),
 NCE(vmovq,     0,       1, (VMOV), neon_mov),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & fpu_neon_ext_v1
#undef  ARM_VARIANT
#define ARM_VARIANT    & fpu_neon_ext_v1

  /* Data processing with three registers of the same length.  */
  /* integer ops, valid types S8 S16 S32 U8 U16 U32.  */
 NUF(vaba,      0000710, 3, (RNDQ, RNDQ,  RNDQ), neon_dyadic_i_su),
 NUF(vabaq,     0000710, 3, (RNQ,  RNQ,   RNQ),  neon_dyadic_i_su),
 NUF(vhadd,     0000000, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
 NUF(vhaddq,    0000000, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
 NUF(vrhadd,    0000100, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
 NUF(vrhaddq,   0000100, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
 NUF(vhsub,     0000200, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
 NUF(vhsubq,    0000200, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
  /* integer ops, valid types S8 S16 S32 S64 U8 U16 U32 U64.  */
 NUF(vqadd,     0000010, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
 NUF(vqaddq,    0000010, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
 NUF(vqsub,     0000210, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
 NUF(vqsubq,    0000210, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
 NUF(vrshl,     0000500, 3, (RNDQ, oRNDQ, RNDQ), neon_rshl),
 NUF(vrshlq,    0000500, 3, (RNQ,  oRNQ,  RNQ),  neon_rshl),
 NUF(vqrshl,    0000510, 3, (RNDQ, oRNDQ, RNDQ), neon_rshl),
 NUF(vqrshlq,   0000510, 3, (RNQ,  oRNQ,  RNQ),  neon_rshl),
  /* If not immediate, fall back to neon_dyadic_i64_su.
     shl_imm should accept I8 I16 I32 I64,
     qshl_imm should accept S8 S16 S32 S64 U8 U16 U32 U64.  */
 nUF(vshl,      _vshl,    3, (RNDQ, oRNDQ, RNDQ_I63b), neon_shl_imm),
 nUF(vshlq,     _vshl,    3, (RNQ,  oRNQ,  RNDQ_I63b), neon_shl_imm),
 nUF(vqshl,     _vqshl,   3, (RNDQ, oRNDQ, RNDQ_I63b), neon_qshl_imm),
 nUF(vqshlq,    _vqshl,   3, (RNQ,  oRNQ,  RNDQ_I63b), neon_qshl_imm),
  /* Logic ops, types optional & ignored.  */
 nUF(vand,      _vand,    3, (RNDQ, oRNDQ, RNDQ_Ibig), neon_logic),
 nUF(vandq,     _vand,    3, (RNQ,  oRNQ,  RNDQ_Ibig), neon_logic),
 nUF(vbic,      _vbic,    3, (RNDQ, oRNDQ, RNDQ_Ibig), neon_logic),
 nUF(vbicq,     _vbic,    3, (RNQ,  oRNQ,  RNDQ_Ibig), neon_logic),
 nUF(vorr,      _vorr,    3, (RNDQ, oRNDQ, RNDQ_Ibig), neon_logic),
 nUF(vorrq,     _vorr,    3, (RNQ,  oRNQ,  RNDQ_Ibig), neon_logic),
 nUF(vorn,      _vorn,    3, (RNDQ, oRNDQ, RNDQ_Ibig), neon_logic),
 nUF(vornq,     _vorn,    3, (RNQ,  oRNQ,  RNDQ_Ibig), neon_logic),
 nUF(veor,      _veor,    3, (RNDQ, oRNDQ, RNDQ),      neon_logic),
 nUF(veorq,     _veor,    3, (RNQ,  oRNQ,  RNQ),       neon_logic),
  /* Bitfield ops, untyped.  */
 NUF(vbsl,      1100110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
 NUF(vbslq,     1100110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
 NUF(vbit,      1200110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
 NUF(vbitq,     1200110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
 NUF(vbif,      1300110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
 NUF(vbifq,     1300110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
  /* Int and float variants, types S8 S16 S32 U8 U16 U32 F32.  */
 nUF(vabd,      _vabd,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vabdq,     _vabd,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
 nUF(vmax,      _vmax,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vmaxq,     _vmax,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
 nUF(vmin,      _vmin,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vminq,     _vmin,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
  /* Comparisons. Types S8 S16 S32 U8 U16 U32 F32. Non-immediate versions fall
     back to neon_dyadic_if_su.  */
 nUF(vcge,      _vcge,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp),
 nUF(vcgeq,     _vcge,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp),
 nUF(vcgt,      _vcgt,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp),
 nUF(vcgtq,     _vcgt,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp),
 nUF(vclt,      _vclt,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp_inv),
 nUF(vcltq,     _vclt,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp_inv),
 nUF(vcle,      _vcle,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp_inv),
 nUF(vcleq,     _vcle,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp_inv),
  /* Comparison. Type I8 I16 I32 F32.  */
 nUF(vceq,      _vceq,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_ceq),
 nUF(vceqq,     _vceq,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_ceq),
  /* As above, D registers only.  */
 nUF(vpmax,     _vpmax,   3, (RND, oRND, RND), neon_dyadic_if_su_d),
 nUF(vpmin,     _vpmin,   3, (RND, oRND, RND), neon_dyadic_if_su_d),
  /* Int and float variants, signedness unimportant.  */
 nUF(vmlaq,     _vmla,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
 nUF(vmlsq,     _vmls,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
 nUF(vpadd,     _vpadd,   3, (RND,  oRND,  RND),       neon_dyadic_if_i_d),
  /* Add/sub take types I8 I16 I32 I64 F32.  */
 nUF(vaddq,     _vadd,    3, (RNQ,  oRNQ,  RNQ),  neon_addsub_if_i),
 nUF(vsubq,     _vsub,    3, (RNQ,  oRNQ,  RNQ),  neon_addsub_if_i),
  /* vtst takes sizes 8, 16, 32.  */
 NUF(vtst,      0000810, 3, (RNDQ, oRNDQ, RNDQ), neon_tst),
 NUF(vtstq,     0000810, 3, (RNQ,  oRNQ,  RNQ),  neon_tst),
  /* VMUL takes I8 I16 I32 F32 P8.  */
 nUF(vmulq,     _vmul,     3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mul),
  /* VQD{R}MULH takes S16 S32.  */
 nUF(vqdmulh,   _vqdmulh,  3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
 nUF(vqdmulhq,  _vqdmulh,  3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
 nUF(vqrdmulh,  _vqrdmulh, 3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
 nUF(vqrdmulhq, _vqrdmulh, 3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
 NUF(vacge,     0000e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute),
 NUF(vacgeq,    0000e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute),
 NUF(vacgt,     0200e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute),
 NUF(vacgtq,    0200e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute),
 NUF(vaclt,     0200e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
 NUF(vacltq,    0200e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
 NUF(vacle,     0000e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
 NUF(vacleq,    0000e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
 NUF(vrecps,    0000f10,  3, (RNDQ, oRNDQ, RNDQ), neon_step),
 NUF(vrecpsq,   0000f10,  3, (RNQ,  oRNQ,  RNQ),  neon_step),
 NUF(vrsqrts,   0200f10,  3, (RNDQ, oRNDQ, RNDQ), neon_step),
 NUF(vrsqrtsq,  0200f10,  3, (RNQ,  oRNQ,  RNQ),  neon_step),

  /* Two address, int/float. Types S8 S16 S32 F32.  */
 NUF(vabsq,     1b10300, 2, (RNQ,  RNQ),      neon_abs_neg),
 NUF(vnegq,     1b10380, 2, (RNQ,  RNQ),      neon_abs_neg),

  /* Data processing with two registers and a shift amount.  */
  /* Right shifts, and variants with rounding.
     Types accepted S8 S16 S32 S64 U8 U16 U32 U64.  */
 NUF(vshr,      0800010, 3, (RNDQ, oRNDQ, I64z), neon_rshift_round_imm),
 NUF(vshrq,     0800010, 3, (RNQ,  oRNQ,  I64z), neon_rshift_round_imm),
 NUF(vrshr,     0800210, 3, (RNDQ, oRNDQ, I64z), neon_rshift_round_imm),
 NUF(vrshrq,    0800210, 3, (RNQ,  oRNQ,  I64z), neon_rshift_round_imm),
 NUF(vsra,      0800110, 3, (RNDQ, oRNDQ, I64),  neon_rshift_round_imm),
 NUF(vsraq,     0800110, 3, (RNQ,  oRNQ,  I64),  neon_rshift_round_imm),
 NUF(vrsra,     0800310, 3, (RNDQ, oRNDQ, I64),  neon_rshift_round_imm),
 NUF(vrsraq,    0800310, 3, (RNQ,  oRNQ,  I64),  neon_rshift_round_imm),
  /* Shift and insert. Sizes accepted 8 16 32 64.  */
 NUF(vsli,      1800510, 3, (RNDQ, oRNDQ, I63), neon_sli),
 NUF(vsliq,     1800510, 3, (RNQ,  oRNQ,  I63), neon_sli),
 NUF(vsri,      1800410, 3, (RNDQ, oRNDQ, I64), neon_sri),
 NUF(vsriq,     1800410, 3, (RNQ,  oRNQ,  I64), neon_sri),
  /* QSHL{U} immediate accepts S8 S16 S32 S64 U8 U16 U32 U64.  */
 NUF(vqshlu,    1800610, 3, (RNDQ, oRNDQ, I63), neon_qshlu_imm),
 NUF(vqshluq,   1800610, 3, (RNQ,  oRNQ,  I63), neon_qshlu_imm),
  /* Right shift immediate, saturating & narrowing, with rounding variants.
     Types accepted S16 S32 S64 U16 U32 U64.  */
 NUF(vqshrn,    0800910, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow),
 NUF(vqrshrn,   0800950, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow),
  /* As above, unsigned. Types accepted S16 S32 S64.  */
 NUF(vqshrun,   0800810, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow_u),
 NUF(vqrshrun,  0800850, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow_u),
  /* Right shift narrowing. Types accepted I16 I32 I64.  */
 NUF(vshrn,     0800810, 3, (RND, RNQ, I32z), neon_rshift_narrow),
 NUF(vrshrn,    0800850, 3, (RND, RNQ, I32z), neon_rshift_narrow),
  /* Special case. Types S8 S16 S32 U8 U16 U32. Handles max shift variant.  */
 nUF(vshll,     _vshll,   3, (RNQ, RND, I32),  neon_shll),
  /* CVT with optional immediate for fixed-point variant.  */
 nUF(vcvtq,     _vcvt,    3, (RNQ, RNQ, oI32b), neon_cvt),

 nUF(vmvn,      _vmvn,    2, (RNDQ, RNDQ_Ibig), neon_mvn),
 nUF(vmvnq,     _vmvn,    2, (RNQ,  RNDQ_Ibig), neon_mvn),

  /* Data processing, three registers of different lengths.  */
  /* Dyadic, long insns. Types S8 S16 S32 U8 U16 U32.  */
 NUF(vabal,     0800500, 3, (RNQ, RND, RND),  neon_abal),
 NUF(vabdl,     0800700, 3, (RNQ, RND, RND),  neon_dyadic_long),
 NUF(vaddl,     0800000, 3, (RNQ, RND, RND),  neon_dyadic_long),
 NUF(vsubl,     0800200, 3, (RNQ, RND, RND),  neon_dyadic_long),
  /* If not scalar, fall back to neon_dyadic_long.
     Vector types as above, scalar types S16 S32 U16 U32.  */
 nUF(vmlal,     _vmlal,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
 nUF(vmlsl,     _vmlsl,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
  /* Dyadic, widening insns. Types S8 S16 S32 U8 U16 U32.  */
 NUF(vaddw,     0800100, 3, (RNQ, oRNQ, RND), neon_dyadic_wide),
 NUF(vsubw,     0800300, 3, (RNQ, oRNQ, RND), neon_dyadic_wide),
  /* Dyadic, narrowing insns. Types I16 I32 I64.  */
 NUF(vaddhn,    0800400, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
 NUF(vraddhn,   1800400, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
 NUF(vsubhn,    0800600, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
 NUF(vrsubhn,   1800600, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
  /* Saturating doubling multiplies. Types S16 S32.  */
 nUF(vqdmlal,   _vqdmlal, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
 nUF(vqdmlsl,   _vqdmlsl, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
 nUF(vqdmull,   _vqdmull, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
  /* VMULL. Vector types S8 S16 S32 U8 U16 U32 P8, scalar types
     S16 S32 U16 U32.  */
 nUF(vmull,     _vmull,   3, (RNQ, RND, RND_RNSC), neon_vmull),

  /* Extract. Size 8.  */
 NUF(vext,      0b00000, 4, (RNDQ, oRNDQ, RNDQ, I15), neon_ext),
 NUF(vextq,     0b00000, 4, (RNQ,  oRNQ,  RNQ,  I15), neon_ext),

  /* Two registers, miscellaneous.  */
  /* Reverse. Sizes 8 16 32 (must be < size in opcode).  */
 NUF(vrev64,    1b00000, 2, (RNDQ, RNDQ),     neon_rev),
 NUF(vrev64q,   1b00000, 2, (RNQ,  RNQ),      neon_rev),
 NUF(vrev32,    1b00080, 2, (RNDQ, RNDQ),     neon_rev),
 NUF(vrev32q,   1b00080, 2, (RNQ,  RNQ),      neon_rev),
 NUF(vrev16,    1b00100, 2, (RNDQ, RNDQ),     neon_rev),
 NUF(vrev16q,   1b00100, 2, (RNQ,  RNQ),      neon_rev),
  /* Vector replicate. Sizes 8 16 32.  */
 nCE(vdup,      _vdup,    2, (RNDQ, RR_RNSC),  neon_dup),
 nCE(vdupq,     _vdup,    2, (RNQ,  RR_RNSC),  neon_dup),
  /* VMOVL. Types S8 S16 S32 U8 U16 U32.  */
 NUF(vmovl,     0800a10, 2, (RNQ, RND),       neon_movl),
  /* VMOVN. Types I16 I32 I64.  */
 nUF(vmovn,     _vmovn,   2, (RND, RNQ),       neon_movn),
  /* VQMOVN. Types S16 S32 S64 U16 U32 U64.  */
 nUF(vqmovn,    _vqmovn,  2, (RND, RNQ),       neon_qmovn),
  /* VQMOVUN. Types S16 S32 S64.  */
 nUF(vqmovun,   _vqmovun, 2, (RND, RNQ),       neon_qmovun),
  /* VZIP / VUZP. Sizes 8 16 32.  */
 NUF(vzip,      1b20180, 2, (RNDQ, RNDQ),     neon_zip_uzp),
 NUF(vzipq,     1b20180, 2, (RNQ,  RNQ),      neon_zip_uzp),
 NUF(vuzp,      1b20100, 2, (RNDQ, RNDQ),     neon_zip_uzp),
 NUF(vuzpq,     1b20100, 2, (RNQ,  RNQ),      neon_zip_uzp),
  /* VQABS / VQNEG. Types S8 S16 S32.  */
 NUF(vqabs,     1b00700, 2, (RNDQ, RNDQ),     neon_sat_abs_neg),
 NUF(vqabsq,    1b00700, 2, (RNQ,  RNQ),      neon_sat_abs_neg),
 NUF(vqneg,     1b00780, 2, (RNDQ, RNDQ),     neon_sat_abs_neg),
 NUF(vqnegq,    1b00780, 2, (RNQ,  RNQ),      neon_sat_abs_neg),
  /* Pairwise, lengthening. Types S8 S16 S32 U8 U16 U32.  */
 NUF(vpadal,    1b00600, 2, (RNDQ, RNDQ),     neon_pair_long),
 NUF(vpadalq,   1b00600, 2, (RNQ,  RNQ),      neon_pair_long),
 NUF(vpaddl,    1b00200, 2, (RNDQ, RNDQ),     neon_pair_long),
 NUF(vpaddlq,   1b00200, 2, (RNQ,  RNQ),      neon_pair_long),
  /* Reciprocal estimates. Types U32 F32.  */
 NUF(vrecpe,    1b30400, 2, (RNDQ, RNDQ),     neon_recip_est),
 NUF(vrecpeq,   1b30400, 2, (RNQ,  RNQ),      neon_recip_est),
 NUF(vrsqrte,   1b30480, 2, (RNDQ, RNDQ),     neon_recip_est),
 NUF(vrsqrteq,  1b30480, 2, (RNQ,  RNQ),      neon_recip_est),
  /* VCLS. Types S8 S16 S32.  */
 NUF(vcls,      1b00400, 2, (RNDQ, RNDQ),     neon_cls),
 NUF(vclsq,     1b00400, 2, (RNQ,  RNQ),      neon_cls),
  /* VCLZ. Types I8 I16 I32.  */
 NUF(vclz,      1b00480, 2, (RNDQ, RNDQ),     neon_clz),
 NUF(vclzq,     1b00480, 2, (RNQ,  RNQ),      neon_clz),
  /* VCNT. Size 8.  */
 NUF(vcnt,      1b00500, 2, (RNDQ, RNDQ),     neon_cnt),
 NUF(vcntq,     1b00500, 2, (RNQ,  RNQ),      neon_cnt),
  /* Two address, untyped.  */
 NUF(vswp,      1b20000, 2, (RNDQ, RNDQ),     neon_swp),
 NUF(vswpq,     1b20000, 2, (RNQ,  RNQ),      neon_swp),
  /* VTRN. Sizes 8 16 32.  */
 nUF(vtrn,      _vtrn,    2, (RNDQ, RNDQ),     neon_trn),
 nUF(vtrnq,     _vtrn,    2, (RNQ,  RNQ),      neon_trn),

  /* Table lookup. Size 8.  */
 NUF(vtbl,      1b00800, 3, (RND, NRDLST, RND), neon_tbl_tbx),
 NUF(vtbx,      1b00840, 3, (RND, NRDLST, RND), neon_tbl_tbx),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & fpu_vfp_v3_or_neon_ext
#undef  ARM_VARIANT
#define ARM_VARIANT    & fpu_vfp_v3_or_neon_ext

  /* Neon element/structure load/store.  */
 nUF(vld1,      _vld1,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst1,      _vst1,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld2,      _vld2,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst2,      _vst2,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld3,      _vld3,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst3,      _vst3,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld4,      _vld4,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst4,      _vst4,    2, (NSTRLST, ADDR),  neon_ldx_stx),

#undef  THUMB_VARIANT
#define THUMB_VARIANT & fpu_vfp_ext_v3xd
#undef  ARM_VARIANT
#define ARM_VARIANT   & fpu_vfp_ext_v3xd
 cCE("fconsts",   eb00a00, 2, (RVS, I255),      vfp_sp_const),
 cCE("fshtos",    eba0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE("fsltos",    eba0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE("fuhtos",    ebb0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE("fultos",    ebb0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE("ftoshs",    ebe0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE("ftosls",    ebe0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE("ftouhs",    ebf0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE("ftouls",    ebf0ac0, 2, (RVS, I32),       vfp_sp_conv_32),

#undef  THUMB_VARIANT
#define THUMB_VARIANT  & fpu_vfp_ext_v3
#undef  ARM_VARIANT
#define ARM_VARIANT    & fpu_vfp_ext_v3

 cCE("fconstd",   eb00b00, 2, (RVD, I255),      vfp_dp_const),
 cCE("fshtod",    eba0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE("fsltod",    eba0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE("fuhtod",    ebb0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE("fultod",    ebb0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE("ftoshd",    ebe0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE("ftosld",    ebe0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE("ftouhd",    ebf0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE("ftould",    ebf0bc0, 2, (RVD, I32),       vfp_dp_conv_32),

#undef  ARM_VARIANT
#define ARM_VARIANT    & fpu_vfp_ext_fma
#undef  THUMB_VARIANT
#define THUMB_VARIANT  & fpu_vfp_ext_fma
 /* Mnemonics shared by Neon and VFP.  These are included in the
    VFP FMA variant; NEON and VFP FMA always includes the NEON
    FMA instructions.  */
 nCEF(vfma,     _vfma,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_fmac),
 nCEF(vfms,     _vfms,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_fmac),
 /* ffmas/ffmad/ffmss/ffmsd are dummy mnemonics to satisfy gas;
    the v form should always be used.  */
 cCE("ffmas",	ea00a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("ffnmas",	ea00a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE("ffmad",	ea00b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE("ffnmad",	ea00b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 nCE(vfnma,     _vfnma,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vfnms,     _vfnms,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),

#undef THUMB_VARIANT
#undef  ARM_VARIANT
#define ARM_VARIANT  & arm_cext_xscale /* Intel XScale extensions.  */

 cCE("mia",	e200010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE("miaph",	e280010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE("miabb",	e2c0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE("miabt",	e2d0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE("miatb",	e2e0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE("miatt",	e2f0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE("mar",	c400000, 3, (RXA, RRnpc, RRnpc), xsc_mar),
 cCE("mra",	c500000, 3, (RRnpc, RRnpc, RXA), xsc_mra),

#undef  ARM_VARIANT
#define ARM_VARIANT  & arm_cext_iwmmxt /* Intel Wireless MMX technology.  */

 cCE("tandcb",	e13f130, 1, (RR),		    iwmmxt_tandorc),
 cCE("tandch",	e53f130, 1, (RR),		    iwmmxt_tandorc),
 cCE("tandcw",	e93f130, 1, (RR),		    iwmmxt_tandorc),
 cCE("tbcstb",	e400010, 2, (RIWR, RR),		    rn_rd),
 cCE("tbcsth",	e400050, 2, (RIWR, RR),		    rn_rd),
 cCE("tbcstw",	e400090, 2, (RIWR, RR),		    rn_rd),
 cCE("textrcb",	e130170, 2, (RR, I7),		    iwmmxt_textrc),
 cCE("textrch",	e530170, 2, (RR, I7),		    iwmmxt_textrc),
 cCE("textrcw",	e930170, 2, (RR, I7),		    iwmmxt_textrc),
 cCE("textrmub",e100070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmuh",e500070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmuw",e900070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmsb",e100078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmsh",e500078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmsw",e900078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("tinsrb",	e600010, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
 cCE("tinsrh",	e600050, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
 cCE("tinsrw",	e600090, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
 cCE("tmcr",	e000110, 2, (RIWC_RIWG, RR),	    rn_rd),
 cCE("tmcrr",	c400000, 3, (RIWR, RR, RR),	    rm_rd_rn),
 cCE("tmia",	e200010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE("tmiaph",	e280010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE("tmiabb",	e2c0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE("tmiabt",	e2d0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE("tmiatb",	e2e0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE("tmiatt",	e2f0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE("tmovmskb",e100030, 2, (RR, RIWR),		    rd_rn),
 cCE("tmovmskh",e500030, 2, (RR, RIWR),		    rd_rn),
 cCE("tmovmskw",e900030, 2, (RR, RIWR),		    rd_rn),
 cCE("tmrc",	e100110, 2, (RR, RIWC_RIWG),	    rd_rn),
 cCE("tmrrc",	c500000, 3, (RR, RR, RIWR),	    rd_rn_rm),
 cCE("torcb",	e13f150, 1, (RR),		    iwmmxt_tandorc),
 cCE("torch",	e53f150, 1, (RR),		    iwmmxt_tandorc),
 cCE("torcw",	e93f150, 1, (RR),		    iwmmxt_tandorc),
 cCE("waccb",	e0001c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wacch",	e4001c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("waccw",	e8001c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("waddbss",	e300180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waddb",	e000180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waddbus",	e100180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waddhss",	e700180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waddh",	e400180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waddhus",	e500180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waddwss",	eb00180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waddw",	e800180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waddwus",	e900180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("waligni",	e000020, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_waligni),
 cCE("walignr0",e800020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("walignr1",e900020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("walignr2",ea00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("walignr3",eb00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wand",	e200000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wandn",	e300000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wavg2b",	e800000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wavg2br",	e900000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wavg2h",	ec00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wavg2hr",	ed00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpeqb",	e000060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpeqh",	e400060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpeqw",	e800060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtub",e100060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtuh",e500060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtuw",e900060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtsb",e300060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtsh",e700060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtsw",eb00060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wldrb",	c100000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
 cCE("wldrh",	c500000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
 cCE("wldrw",	c100100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
 cCE("wldrd",	c500100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
 cCE("wmacs",	e600100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmacsz",	e700100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmacu",	e400100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmacuz",	e500100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmadds",	ea00100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmaddu",	e800100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmaxsb",	e200160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmaxsh",	e600160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmaxsw",	ea00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmaxub",	e000160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmaxuh",	e400160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmaxuw",	e800160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wminsb",	e300160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wminsh",	e700160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wminsw",	eb00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wminub",	e100160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wminuh",	e500160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wminuw",	e900160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmov",	e000000, 2, (RIWR, RIWR),	    iwmmxt_wmov),
 cCE("wmulsm",	e300100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmulsl",	e200100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmulum",	e100100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wmulul",	e000100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wor",	e000000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackhss",e700080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackhus",e500080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackwss",eb00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackwus",e900080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackdss",ef00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackdus",ed00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wrorh",	e700040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wrorhg",	e700148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wrorw",	eb00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wrorwg",	eb00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wrord",	ef00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wrordg",	ef00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wsadb",	e000120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsadbz",	e100120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsadh",	e400120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsadhz",	e500120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wshufh",	e0001e0, 3, (RIWR, RIWR, I255),	    iwmmxt_wshufh),
 cCE("wsllh",	e500040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wsllhg",	e500148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wsllw",	e900040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wsllwg",	e900148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wslld",	ed00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wslldg",	ed00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wsrah",	e400040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wsrahg",	e400148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wsraw",	e800040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wsrawg",	e800148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wsrad",	ec00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wsradg",	ec00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wsrlh",	e600040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wsrlhg",	e600148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wsrlw",	ea00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wsrlwg",	ea00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wsrld",	ee00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE("wsrldg",	ee00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE("wstrb",	c000000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
 cCE("wstrh",	c400000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
 cCE("wstrw",	c000100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
 cCE("wstrd",	c400100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
 cCE("wsubbss",	e3001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsubb",	e0001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsubbus",	e1001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsubhss",	e7001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsubh",	e4001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsubhus",	e5001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsubwss",	eb001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsubw",	e8001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wsubwus",	e9001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wunpckehub",e0000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckehuh",e4000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckehuw",e8000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckehsb",e2000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckehsh",e6000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckehsw",ea000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckihb", e1000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wunpckihh", e5000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wunpckihw", e9000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wunpckelub",e0000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckeluh",e4000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckeluw",e8000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckelsb",e2000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckelsh",e6000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckelsw",ea000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE("wunpckilb", e1000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wunpckilh", e5000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wunpckilw", e9000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wxor",	e100000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wzero",	e300000, 1, (RIWR),		    iwmmxt_wzero),

#undef  ARM_VARIANT
#define ARM_VARIANT  & arm_cext_iwmmxt2 /* Intel Wireless MMX technology, version 2.  */

 cCE("torvscb",   e12f190, 1, (RR),		    iwmmxt_tandorc),
 cCE("torvsch",   e52f190, 1, (RR),		    iwmmxt_tandorc),
 cCE("torvscw",   e92f190, 1, (RR),		    iwmmxt_tandorc),
 cCE("wabsb",     e2001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE("wabsh",     e6001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE("wabsw",     ea001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE("wabsdiffb", e1001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wabsdiffh", e5001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wabsdiffw", e9001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("waddbhusl", e2001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("waddbhusm", e6001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("waddhc",    e600180, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("waddwc",    ea00180, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("waddsubhx", ea001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wavg4",	e400000, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wavg4r",    e500000, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmaddsn",   ee00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmaddsx",   eb00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmaddun",   ec00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmaddux",   e900100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmerge",    e000080, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_wmerge),
 cCE("wmiabb",    e0000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiabt",    e1000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiatb",    e2000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiatt",    e3000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiabbn",   e4000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiabtn",   e5000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiatbn",   e6000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiattn",   e7000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiawbb",   e800120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiawbt",   e900120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiawtb",   ea00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiawtt",   eb00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiawbbn",  ec00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiawbtn",  ed00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiawtbn",  ee00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmiawttn",  ef00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmulsmr",   ef00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmulumr",   ed00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmulwumr",  ec000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmulwsmr",  ee000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmulwum",   ed000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmulwsm",   ef000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wmulwl",    eb000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmiabb",   e8000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmiabt",   e9000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmiatb",   ea000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmiatt",   eb000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmiabbn",  ec000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmiabtn",  ed000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmiatbn",  ee000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmiattn",  ef000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmulm",    e100080, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmulmr",   e300080, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmulwm",   ec000e0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wqmulwmr",  ee000e0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE("wsubaddhx", ed001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),

#undef  ARM_VARIANT
#define ARM_VARIANT  & arm_cext_maverick /* Cirrus Maverick instructions.  */

 cCE("cfldrs",	c100400, 2, (RMF, ADDRGLDC),	      rd_cpaddr),
 cCE("cfldrd",	c500400, 2, (RMD, ADDRGLDC),	      rd_cpaddr),
 cCE("cfldr32",	c100500, 2, (RMFX, ADDRGLDC),	      rd_cpaddr),
 cCE("cfldr64",	c500500, 2, (RMDX, ADDRGLDC),	      rd_cpaddr),
 cCE("cfstrs",	c000400, 2, (RMF, ADDRGLDC),	      rd_cpaddr),
 cCE("cfstrd",	c400400, 2, (RMD, ADDRGLDC),	      rd_cpaddr),
 cCE("cfstr32",	c000500, 2, (RMFX, ADDRGLDC),	      rd_cpaddr),
 cCE("cfstr64",	c400500, 2, (RMDX, ADDRGLDC),	      rd_cpaddr),
 cCE("cfmvsr",	e000450, 2, (RMF, RR),		      rn_rd),
 cCE("cfmvrs",	e100450, 2, (RR, RMF),		      rd_rn),
 cCE("cfmvdlr",	e000410, 2, (RMD, RR),		      rn_rd),
 cCE("cfmvrdl",	e100410, 2, (RR, RMD),		      rd_rn),
 cCE("cfmvdhr",	e000430, 2, (RMD, RR),		      rn_rd),
 cCE("cfmvrdh",	e100430, 2, (RR, RMD),		      rd_rn),
 cCE("cfmv64lr",e000510, 2, (RMDX, RR),		      rn_rd),
 cCE("cfmvr64l",e100510, 2, (RR, RMDX),		      rd_rn),
 cCE("cfmv64hr",e000530, 2, (RMDX, RR),		      rn_rd),
 cCE("cfmvr64h",e100530, 2, (RR, RMDX),		      rd_rn),
 cCE("cfmval32",e200440, 2, (RMAX, RMFX),	      rd_rn),
 cCE("cfmv32al",e100440, 2, (RMFX, RMAX),	      rd_rn),
 cCE("cfmvam32",e200460, 2, (RMAX, RMFX),	      rd_rn),
 cCE("cfmv32am",e100460, 2, (RMFX, RMAX),	      rd_rn),
 cCE("cfmvah32",e200480, 2, (RMAX, RMFX),	      rd_rn),
 cCE("cfmv32ah",e100480, 2, (RMFX, RMAX),	      rd_rn),
 cCE("cfmva32",	e2004a0, 2, (RMAX, RMFX),	      rd_rn),
 cCE("cfmv32a",	e1004a0, 2, (RMFX, RMAX),	      rd_rn),
 cCE("cfmva64",	e2004c0, 2, (RMAX, RMDX),	      rd_rn),
 cCE("cfmv64a",	e1004c0, 2, (RMDX, RMAX),	      rd_rn),
 cCE("cfmvsc32",e2004e0, 2, (RMDS, RMDX),	      mav_dspsc),
 cCE("cfmv32sc",e1004e0, 2, (RMDX, RMDS),	      rd),
 cCE("cfcpys",	e000400, 2, (RMF, RMF),		      rd_rn),
 cCE("cfcpyd",	e000420, 2, (RMD, RMD),		      rd_rn),
 cCE("cfcvtsd",	e000460, 2, (RMD, RMF),		      rd_rn),
 cCE("cfcvtds",	e000440, 2, (RMF, RMD),		      rd_rn),
 cCE("cfcvt32s",e000480, 2, (RMF, RMFX),	      rd_rn),
 cCE("cfcvt32d",e0004a0, 2, (RMD, RMFX),	      rd_rn),
 cCE("cfcvt64s",e0004c0, 2, (RMF, RMDX),	      rd_rn),
 cCE("cfcvt64d",e0004e0, 2, (RMD, RMDX),	      rd_rn),
 cCE("cfcvts32",e100580, 2, (RMFX, RMF),	      rd_rn),
 cCE("cfcvtd32",e1005a0, 2, (RMFX, RMD),	      rd_rn),
 cCE("cftruncs32",e1005c0, 2, (RMFX, RMF),	      rd_rn),
 cCE("cftruncd32",e1005e0, 2, (RMFX, RMD),	      rd_rn),
 cCE("cfrshl32",e000550, 3, (RMFX, RMFX, RR),	      mav_triple),
 cCE("cfrshl64",e000570, 3, (RMDX, RMDX, RR),	      mav_triple),
 cCE("cfsh32",	e000500, 3, (RMFX, RMFX, I63s),	      mav_shift),
 cCE("cfsh64",	e200500, 3, (RMDX, RMDX, I63s),	      mav_shift),
 cCE("cfcmps",	e100490, 3, (RR, RMF, RMF),	      rd_rn_rm),
 cCE("cfcmpd",	e1004b0, 3, (RR, RMD, RMD),	      rd_rn_rm),
 cCE("cfcmp32",	e100590, 3, (RR, RMFX, RMFX),	      rd_rn_rm),
 cCE("cfcmp64",	e1005b0, 3, (RR, RMDX, RMDX),	      rd_rn_rm),
 cCE("cfabss",	e300400, 2, (RMF, RMF),		      rd_rn),
 cCE("cfabsd",	e300420, 2, (RMD, RMD),		      rd_rn),
 cCE("cfnegs",	e300440, 2, (RMF, RMF),		      rd_rn),
 cCE("cfnegd",	e300460, 2, (RMD, RMD),		      rd_rn),
 cCE("cfadds",	e300480, 3, (RMF, RMF, RMF),	      rd_rn_rm),
 cCE("cfaddd",	e3004a0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
 cCE("cfsubs",	e3004c0, 3, (RMF, RMF, RMF),	      rd_rn_rm),
 cCE("cfsubd",	e3004e0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
 cCE("cfmuls",	e100400, 3, (RMF, RMF, RMF),	      rd_rn_rm),
 cCE("cfmuld",	e100420, 3, (RMD, RMD, RMD),	      rd_rn_rm),
 cCE("cfabs32",	e300500, 2, (RMFX, RMFX),	      rd_rn),
 cCE("cfabs64",	e300520, 2, (RMDX, RMDX),	      rd_rn),
 cCE("cfneg32",	e300540, 2, (RMFX, RMFX),	      rd_rn),
 cCE("cfneg64",	e300560, 2, (RMDX, RMDX),	      rd_rn),
 cCE("cfadd32",	e300580, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE("cfadd64",	e3005a0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
 cCE("cfsub32",	e3005c0, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE("cfsub64",	e3005e0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
 cCE("cfmul32",	e100500, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE("cfmul64",	e100520, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
 cCE("cfmac32",	e100540, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE("cfmsc32",	e100560, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE("cfmadd32",e000600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
 cCE("cfmsub32",e100600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
 cCE("cfmadda32", e200600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
 cCE("cfmsuba32", e300600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
};
#undef ARM_VARIANT
#undef THUMB_VARIANT
#undef TCE
#undef TUE
#undef TUF
#undef TCC
#undef cCE
#undef cCL
#undef C3E
#undef CE
#undef CM
#undef UE
#undef UF
#undef UT
#undef NUF
#undef nUF
#undef NCE
#undef nCE
#undef OPS0
#undef OPS1
#undef OPS2
#undef OPS3
#undef OPS4
#undef OPS5
#undef OPS6
#undef do_0

/* MD interface: bits in the object file.  */

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).	*/

void
md_number_to_chars (char * buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

static valueT
md_chars_to_number (char * buf, int n)
{
  valueT result = 0;
  unsigned char * where = (unsigned char *) buf;

  if (target_big_endian)
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (*where++ & 255);
	}
    }
  else
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (where[n] & 255);
	}
    }

  return result;
}

/* MD interface: Sections.  */

/* Calculate the maximum variable size (i.e., excluding fr_fix)
   that an rs_machine_dependent frag may reach.  */

unsigned int
arm_frag_max_var (fragS *fragp)
{
  /* We only use rs_machine_dependent for variable-size Thumb instructions,
     which are either THUMB_SIZE (2) or INSN_SIZE (4).

     Note that we generate relaxable instructions even for cases that don't
     really need it, like an immediate that's a trivial constant.  So we're
     overestimating the instruction size for some of those cases.  Rather
     than putting more intelligence here, it would probably be better to
     avoid generating a relaxation frag in the first place when it can be
     determined up front that a short instruction will suffice.  */

  gas_assert (fragp->fr_type == rs_machine_dependent);
  return INSN_SIZE;
}

/* Estimate the size of a frag before relaxing.  Assume everything fits in
   2 bytes.  */

int
md_estimate_size_before_relax (fragS * fragp,
			       segT    segtype ATTRIBUTE_UNUSED)
{
  fragp->fr_var = 2;
  return 2;
}

/* Convert a machine dependent frag.  */

void
md_convert_frag (bfd *abfd, segT asec ATTRIBUTE_UNUSED, fragS *fragp)
{
  unsigned long insn;
  unsigned long old_op;
  char *buf;
  expressionS exp;
  fixS *fixp;
  int reloc_type;
  int pc_rel;
  int opcode;

  buf = fragp->fr_literal + fragp->fr_fix;

  old_op = bfd_get_16(abfd, buf);
  if (fragp->fr_symbol)
    {
      exp.X_op = O_symbol;
      exp.X_add_symbol = fragp->fr_symbol;
    }
  else
    {
      exp.X_op = O_constant;
    }
  exp.X_add_number = fragp->fr_offset;
  opcode = fragp->fr_subtype;
  switch (opcode)
    {
    case T_MNEM_ldr_pc:
    case T_MNEM_ldr_pc2:
    case T_MNEM_ldr_sp:
    case T_MNEM_str_sp:
    case T_MNEM_ldr:
    case T_MNEM_ldrb:
    case T_MNEM_ldrh:
    case T_MNEM_str:
    case T_MNEM_strb:
    case T_MNEM_strh:
      if (fragp->fr_var == 4)
	{
	  insn = THUMB_OP32 (opcode);
	  if ((old_op >> 12) == 4 || (old_op >> 12) == 9)
	    {
	      insn |= (old_op & 0x700) << 4;
	    }
	  else
	    {
	      insn |= (old_op & 7) << 12;
	      insn |= (old_op & 0x38) << 13;
	    }
	  insn |= 0x00000c00;
	  put_thumb32_insn (buf, insn);
	  reloc_type = BFD_RELOC_ARM_T32_OFFSET_IMM;
	}
      else
	{
	  reloc_type = BFD_RELOC_ARM_THUMB_OFFSET;
	}
      pc_rel = (opcode == T_MNEM_ldr_pc2);
      break;
    case T_MNEM_adr:
      if (fragp->fr_var == 4)
	{
	  insn = THUMB_OP32 (opcode);
	  insn |= (old_op & 0xf0) << 4;
	  put_thumb32_insn (buf, insn);
	  reloc_type = BFD_RELOC_ARM_T32_ADD_PC12;
	}
      else
	{
	  reloc_type = BFD_RELOC_ARM_THUMB_ADD;
	  exp.X_add_number -= 4;
	}
      pc_rel = 1;
      break;
    case T_MNEM_mov:
    case T_MNEM_movs:
    case T_MNEM_cmp:
    case T_MNEM_cmn:
      if (fragp->fr_var == 4)
	{
	  int r0off = (opcode == T_MNEM_mov
		       || opcode == T_MNEM_movs) ? 0 : 8;
	  insn = THUMB_OP32 (opcode);
	  insn = (insn & 0xe1ffffff) | 0x10000000;
	  insn |= (old_op & 0x700) << r0off;
	  put_thumb32_insn (buf, insn);
	  reloc_type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  reloc_type = BFD_RELOC_ARM_THUMB_IMM;
	}
      pc_rel = 0;
      break;
    case T_MNEM_b:
      if (fragp->fr_var == 4)
	{
	  insn = THUMB_OP32(opcode);
	  put_thumb32_insn (buf, insn);
	  reloc_type = BFD_RELOC_THUMB_PCREL_BRANCH25;
	}
      else
	reloc_type = BFD_RELOC_THUMB_PCREL_BRANCH12;
      pc_rel = 1;
      break;
    case T_MNEM_bcond:
      if (fragp->fr_var == 4)
	{
	  insn = THUMB_OP32(opcode);
	  insn |= (old_op & 0xf00) << 14;
	  put_thumb32_insn (buf, insn);
	  reloc_type = BFD_RELOC_THUMB_PCREL_BRANCH20;
	}
      else
	reloc_type = BFD_RELOC_THUMB_PCREL_BRANCH9;
      pc_rel = 1;
      break;
    case T_MNEM_add_sp:
    case T_MNEM_add_pc:
    case T_MNEM_inc_sp:
    case T_MNEM_dec_sp:
      if (fragp->fr_var == 4)
	{
	  /* ??? Choose between add and addw.  */
	  insn = THUMB_OP32 (opcode);
	  insn |= (old_op & 0xf0) << 4;
	  put_thumb32_insn (buf, insn);
	  if (opcode == T_MNEM_add_pc)
	    reloc_type = BFD_RELOC_ARM_T32_IMM12;
	  else
	    reloc_type = BFD_RELOC_ARM_T32_ADD_IMM;
	}
      else
	reloc_type = BFD_RELOC_ARM_THUMB_ADD;
      pc_rel = 0;
      break;

    case T_MNEM_addi:
    case T_MNEM_addis:
    case T_MNEM_subi:
    case T_MNEM_subis:
      if (fragp->fr_var == 4)
	{
	  insn = THUMB_OP32 (opcode);
	  insn |= (old_op & 0xf0) << 4;
	  insn |= (old_op & 0xf) << 16;
	  put_thumb32_insn (buf, insn);
	  if (insn & (1 << 20))
	    reloc_type = BFD_RELOC_ARM_T32_ADD_IMM;
	  else
	    reloc_type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	reloc_type = BFD_RELOC_ARM_THUMB_ADD;
      pc_rel = 0;
      break;
    default:
      abort ();
    }
  fixp = fix_new_exp (fragp, fragp->fr_fix, fragp->fr_var, &exp, pc_rel,
		      (enum bfd_reloc_code_real) reloc_type);
  fixp->fx_file = fragp->fr_file;
  fixp->fx_line = fragp->fr_line;
  fragp->fr_fix += fragp->fr_var;
}

/* Return the size of a relaxable immediate operand instruction.
   SHIFT and SIZE specify the form of the allowable immediate.  */
static int
relax_immediate (fragS *fragp, int size, int shift)
{
  offsetT offset;
  offsetT mask;
  offsetT low;

  /* ??? Should be able to do better than this.  */
  if (fragp->fr_symbol)
    return 4;

  low = (1 << shift) - 1;
  mask = (1 << (shift + size)) - (1 << shift);
  offset = fragp->fr_offset;
  /* Force misaligned offsets to 32-bit variant.  */
  if (offset & low)
    return 4;
  if (offset & ~mask)
    return 4;
  return 2;
}

/* Get the address of a symbol during relaxation.  */
static addressT
relaxed_symbol_addr (fragS *fragp, long stretch)
{
  fragS *sym_frag;
  addressT addr;
  symbolS *sym;

  sym = fragp->fr_symbol;
  sym_frag = symbol_get_frag (sym);
  know (S_GET_SEGMENT (sym) != absolute_section
	|| sym_frag == &zero_address_frag);
  addr = S_GET_VALUE (sym) + fragp->fr_offset;

  /* If frag has yet to be reached on this pass, assume it will
     move by STRETCH just as we did.  If this is not so, it will
     be because some frag between grows, and that will force
     another pass.  */

  if (stretch != 0
      && sym_frag->relax_marker != fragp->relax_marker)
    {
      fragS *f;

      /* Adjust stretch for any alignment frag.  Note that if have
	 been expanding the earlier code, the symbol may be
	 defined in what appears to be an earlier frag.  FIXME:
	 This doesn't handle the fr_subtype field, which specifies
	 a maximum number of bytes to skip when doing an
	 alignment.  */
      for (f = fragp; f != NULL && f != sym_frag; f = f->fr_next)
	{
	  if (f->fr_type == rs_align || f->fr_type == rs_align_code)
	    {
	      if (stretch < 0)
		stretch = - ((- stretch)
			     & ~ ((1 << (int) f->fr_offset) - 1));
	      else
		stretch &= ~ ((1 << (int) f->fr_offset) - 1);
	      if (stretch == 0)
		break;
	    }
	}
      if (f != NULL)
	addr += stretch;
    }

  return addr;
}

/* Return the size of a relaxable adr pseudo-instruction or PC-relative
   load.  */
static int
relax_adr (fragS *fragp, asection *sec, long stretch)
{
  addressT addr;
  offsetT val;

  /* Assume worst case for symbols not known to be in the same section.  */
  if (fragp->fr_symbol == NULL
      || !S_IS_DEFINED (fragp->fr_symbol)
      || sec != S_GET_SEGMENT (fragp->fr_symbol)
      || S_IS_WEAK (fragp->fr_symbol))
    return 4;

  val = relaxed_symbol_addr (fragp, stretch);
  addr = fragp->fr_address + fragp->fr_fix;
  addr = (addr + 4) & ~3;
  /* Force misaligned targets to 32-bit variant.  */
  if (val & 3)
    return 4;
  val -= addr;
  if (val < 0 || val > 1020)
    return 4;
  return 2;
}

/* Return the size of a relaxable add/sub immediate instruction.  */
static int
relax_addsub (fragS *fragp, asection *sec)
{
  char *buf;
  int op;

  buf = fragp->fr_literal + fragp->fr_fix;
  op = bfd_get_16(sec->owner, buf);
  if ((op & 0xf) == ((op >> 4) & 0xf))
    return relax_immediate (fragp, 8, 0);
  else
    return relax_immediate (fragp, 3, 0);
}

/* Return TRUE iff the definition of symbol S could be pre-empted
   (overridden) at link or load time.  */
static bfd_boolean
symbol_preemptible (symbolS *s)
{
  /* Weak symbols can always be pre-empted.  */
  if (S_IS_WEAK (s))
    return TRUE;

  /* Non-global symbols cannot be pre-empted. */
  if (! S_IS_EXTERNAL (s))
    return FALSE;

#ifdef OBJ_ELF
  /* In ELF, a global symbol can be marked protected, or private.  In that
     case it can't be pre-empted (other definitions in the same link unit
     would violate the ODR).  */
  if (ELF_ST_VISIBILITY (S_GET_OTHER (s)) > STV_DEFAULT)
    return FALSE;
#endif

  /* Other global symbols might be pre-empted.  */
  return TRUE;
}

/* Return the size of a relaxable branch instruction.  BITS is the
   size of the offset field in the narrow instruction.  */

static int
relax_branch (fragS *fragp, asection *sec, int bits, long stretch)
{
  addressT addr;
  offsetT val;
  offsetT limit;

  /* Assume worst case for symbols not known to be in the same section.  */
  if (!S_IS_DEFINED (fragp->fr_symbol)
      || sec != S_GET_SEGMENT (fragp->fr_symbol)
      || S_IS_WEAK (fragp->fr_symbol))
    return 4;

#ifdef OBJ_ELF
  /* A branch to a function in ARM state will require interworking.  */
  if (S_IS_DEFINED (fragp->fr_symbol)
      && ARM_IS_FUNC (fragp->fr_symbol))
      return 4;
#endif

  if (symbol_preemptible (fragp->fr_symbol))
    return 4;

  val = relaxed_symbol_addr (fragp, stretch);
  addr = fragp->fr_address + fragp->fr_fix + 4;
  val -= addr;

  /* Offset is a signed value *2 */
  limit = 1 << bits;
  if (val >= limit || val < -limit)
    return 4;
  return 2;
}


/* Relax a machine dependent frag.  This returns the amount by which
   the current size of the frag should change.  */

int
arm_relax_frag (asection *sec, fragS *fragp, long stretch)
{
  int oldsize;
  int newsize;

  oldsize = fragp->fr_var;
  switch (fragp->fr_subtype)
    {
    case T_MNEM_ldr_pc2:
      newsize = relax_adr (fragp, sec, stretch);
      break;
    case T_MNEM_ldr_pc:
    case T_MNEM_ldr_sp:
    case T_MNEM_str_sp:
      newsize = relax_immediate (fragp, 8, 2);
      break;
    case T_MNEM_ldr:
    case T_MNEM_str:
      newsize = relax_immediate (fragp, 5, 2);
      break;
    case T_MNEM_ldrh:
    case T_MNEM_strh:
      newsize = relax_immediate (fragp, 5, 1);
      break;
    case T_MNEM_ldrb:
    case T_MNEM_strb:
      newsize = relax_immediate (fragp, 5, 0);
      break;
    case T_MNEM_adr:
      newsize = relax_adr (fragp, sec, stretch);
      break;
    case T_MNEM_mov:
    case T_MNEM_movs:
    case T_MNEM_cmp:
    case T_MNEM_cmn:
      newsize = relax_immediate (fragp, 8, 0);
      break;
    case T_MNEM_b:
      newsize = relax_branch (fragp, sec, 11, stretch);
      break;
    case T_MNEM_bcond:
      newsize = relax_branch (fragp, sec, 8, stretch);
      break;
    case T_MNEM_add_sp:
    case T_MNEM_add_pc:
      newsize = relax_immediate (fragp, 8, 2);
      break;
    case T_MNEM_inc_sp:
    case T_MNEM_dec_sp:
      newsize = relax_immediate (fragp, 7, 2);
      break;
    case T_MNEM_addi:
    case T_MNEM_addis:
    case T_MNEM_subi:
    case T_MNEM_subis:
      newsize = relax_addsub (fragp, sec);
      break;
    default:
      abort ();
    }

  fragp->fr_var = newsize;
  /* Freeze wide instructions that are at or before the same location as
     in the previous pass.  This avoids infinite loops.
     Don't freeze them unconditionally because targets may be artificially
     misaligned by the expansion of preceding frags.  */
  if (stretch <= 0 && newsize > 2)
    {
      md_convert_frag (sec->owner, sec, fragp);
      frag_wane (fragp);
    }

  return newsize - oldsize;
}

/* Round up a section size to the appropriate boundary.	 */

valueT
md_section_align (segT	 segment ATTRIBUTE_UNUSED,
		  valueT size)
{
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
    {
      /* For a.out, force the section size to be aligned.  If we don't do
	 this, BFD will align it for us, but it will not write out the
	 final bytes of the section.  This may be a bug in BFD, but it is
	 easier to fix it here since that is how the other a.out targets
	 work.  */
      int align;

      align = bfd_get_section_alignment (stdoutput, segment);
      size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
    }
#endif

  return size;
}

/* This is called from HANDLE_ALIGN in write.c.	 Fill in the contents
   of an rs_align_code fragment.  */

void
arm_handle_align (fragS * fragP)
{
  static char const arm_noop[2][2][4] =
    {
      {  /* ARMv1 */
	{0x00, 0x00, 0xa0, 0xe1},  /* LE */
	{0xe1, 0xa0, 0x00, 0x00},  /* BE */
      },
      {  /* ARMv6k */
	{0x00, 0xf0, 0x20, 0xe3},  /* LE */
	{0xe3, 0x20, 0xf0, 0x00},  /* BE */
      },
    };
  static char const thumb_noop[2][2][2] =
    {
      {  /* Thumb-1 */
	{0xc0, 0x46},  /* LE */
	{0x46, 0xc0},  /* BE */
      },
      {  /* Thumb-2 */
	{0x00, 0xbf},  /* LE */
	{0xbf, 0x00}   /* BE */
      }
    };
  static char const wide_thumb_noop[2][4] =
    {  /* Wide Thumb-2 */
      {0xaf, 0xf3, 0x00, 0x80},  /* LE */
      {0xf3, 0xaf, 0x80, 0x00},  /* BE */
    };

  unsigned bytes, fix, noop_size;
  char * p;
  const char * noop;
  const char *narrow_noop = NULL;
#ifdef OBJ_ELF
  enum mstate state;
#endif

  if (fragP->fr_type != rs_align_code)
    return;

  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;

  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;

  gas_assert ((fragP->tc_frag_data.thumb_mode & MODE_RECORDED) != 0);

  if (fragP->tc_frag_data.thumb_mode & (~ MODE_RECORDED))
    {
      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6t2))
	{
	  narrow_noop = thumb_noop[1][target_big_endian];
	  noop = wide_thumb_noop[target_big_endian];
	}
      else
	noop = thumb_noop[0][target_big_endian];
      noop_size = 2;
#ifdef OBJ_ELF
      state = MAP_THUMB;
#endif
    }
  else
    {
      noop = arm_noop[ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6k) != 0]
		     [target_big_endian];
      noop_size = 4;
#ifdef OBJ_ELF
      state = MAP_ARM;
#endif
    }

  fragP->fr_var = noop_size;

  if (bytes & (noop_size - 1))
    {
      fix = bytes & (noop_size - 1);
#ifdef OBJ_ELF
      insert_data_mapping_symbol (state, fragP->fr_fix, fragP, fix);
#endif
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }

  if (narrow_noop)
    {
      if (bytes & noop_size)
	{
	  /* Insert a narrow noop.  */
	  memcpy (p, narrow_noop, noop_size);
	  p += noop_size;
	  bytes -= noop_size;
	  fix += noop_size;
	}

      /* Use wide noops for the remainder */
      noop_size = 4;
    }

  while (bytes >= noop_size)
    {
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
    }

  fragP->fr_fix += fix;
}

/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */

void
arm_frag_align_code (int n, int max)
{
  char * p;

  /* We assume that there will never be a requirement
     to support alignments greater than MAX_MEM_FOR_RS_ALIGN_CODE bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    {
      char err_msg[128];

      sprintf (err_msg,
	_("alignments greater than %d bytes not supported in .text sections."),
	MAX_MEM_FOR_RS_ALIGN_CODE + 1);
      as_fatal ("%s", err_msg);
    }

  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;
}

/* Perform target specific initialisation of a frag.
   Note - despite the name this initialisation is not done when the frag
   is created, but only when its type is assigned.  A frag can be created
   and used a long time before its type is set, so beware of assuming that
   this initialisationis performed first.  */

#ifndef OBJ_ELF
void
arm_init_frag (fragS * fragP, int max_chars ATTRIBUTE_UNUSED)
{
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data.thumb_mode = thumb_mode | MODE_RECORDED;
}

#else /* OBJ_ELF is defined.  */
void
arm_init_frag (fragS * fragP, int max_chars)
{
  /* If the current ARM vs THUMB mode has not already
     been recorded into this frag then do so now.  */
  if ((fragP->tc_frag_data.thumb_mode & MODE_RECORDED) == 0)
    {
      fragP->tc_frag_data.thumb_mode = thumb_mode | MODE_RECORDED;

      /* Record a mapping symbol for alignment frags.  We will delete this
	 later if the alignment ends up empty.  */
      switch (fragP->fr_type)
	{
	  case rs_align:
	  case rs_align_test:
	  case rs_fill:
	    mapping_state_2 (MAP_DATA, max_chars);
	    break;
	  case rs_align_code:
	    mapping_state_2 (thumb_mode ? MAP_THUMB : MAP_ARM, max_chars);
	    break;
	  default:
	    break;
	}
    }
}

/* When we change sections we need to issue a new mapping symbol.  */

void
arm_elf_change_section (void)
{
  /* Link an unlinked unwind index table section to the .text section.	*/
  if (elf_section_type (now_seg) == SHT_ARM_EXIDX
      && elf_linked_to_section (now_seg) == NULL)
    elf_linked_to_section (now_seg) = text_section;
}

int
arm_elf_section_type (const char * str, size_t len)
{
  if (len == 5 && strncmp (str, "exidx", 5) == 0)
    return SHT_ARM_EXIDX;

  return -1;
}

/* Code to deal with unwinding tables.	*/

static void add_unwind_adjustsp (offsetT);

/* Generate any deferred unwind frame offset.  */

static void
flush_pending_unwind (void)
{
  offsetT offset;

  offset = unwind.pending_offset;
  unwind.pending_offset = 0;
  if (offset != 0)
    add_unwind_adjustsp (offset);
}

/* Add an opcode to this list for this function.  Two-byte opcodes should
   be passed as op[0] << 8 | op[1].  The list of opcodes is built in reverse
   order.  */

static void
add_unwind_opcode (valueT op, int length)
{
  /* Add any deferred stack adjustment.	 */
  if (unwind.pending_offset)
    flush_pending_unwind ();

  unwind.sp_restored = 0;

  if (unwind.opcode_count + length > unwind.opcode_alloc)
    {
      unwind.opcode_alloc += ARM_OPCODE_CHUNK_SIZE;
      if (unwind.opcodes)
	unwind.opcodes = (unsigned char *) xrealloc (unwind.opcodes,
						     unwind.opcode_alloc);
      else
	unwind.opcodes = (unsigned char *) xmalloc (unwind.opcode_alloc);
    }
  while (length > 0)
    {
      length--;
      unwind.opcodes[unwind.opcode_count] = op & 0xff;
      op >>= 8;
      unwind.opcode_count++;
    }
}

/* Add unwind opcodes to adjust the stack pointer.  */

static void
add_unwind_adjustsp (offsetT offset)
{
  valueT op;

  if (offset > 0x200)
    {
      /* We need at most 5 bytes to hold a 32-bit value in a uleb128.  */
      char bytes[5];
      int n;
      valueT o;

      /* Long form: 0xb2, uleb128.  */
      /* This might not fit in a word so add the individual bytes,
	 remembering the list is built in reverse order.  */
      o = (valueT) ((offset - 0x204) >> 2);
      if (o == 0)
	add_unwind_opcode (0, 1);

      /* Calculate the uleb128 encoding of the offset.	*/
      n = 0;
      while (o)
	{
	  bytes[n] = o & 0x7f;
	  o >>= 7;
	  if (o)
	    bytes[n] |= 0x80;
	  n++;
	}
      /* Add the insn.	*/
      for (; n; n--)
	add_unwind_opcode (bytes[n - 1], 1);
      add_unwind_opcode (0xb2, 1);
    }
  else if (offset > 0x100)
    {
      /* Two short opcodes.  */
      add_unwind_opcode (0x3f, 1);
      op = (offset - 0x104) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset > 0)
    {
      /* Short opcode.	*/
      op = (offset - 4) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset < 0)
    {
      offset = -offset;
      while (offset > 0x100)
	{
	  add_unwind_opcode (0x7f, 1);
	  offset -= 0x100;
	}
      op = ((offset - 4) >> 2) | 0x40;
      add_unwind_opcode (op, 1);
    }
}

/* Finish the list of unwind opcodes for this function.	 */
static void
finish_unwind_opcodes (void)
{
  valueT op;

  if (unwind.fp_used)
    {
      /* Adjust sp as necessary.  */
      unwind.pending_offset += unwind.fp_offset - unwind.frame_size;
      flush_pending_unwind ();

      /* After restoring sp from the frame pointer.  */
      op = 0x90 | unwind.fp_reg;
      add_unwind_opcode (op, 1);
    }
  else
    flush_pending_unwind ();
}


/* Start an exception table entry.  If idx is nonzero this is an index table
   entry.  */

static void
start_unwind_section (const segT text_seg, int idx)
{
  const char * text_name;
  const char * prefix;
  const char * prefix_once;
  const char * group_name;
  size_t prefix_len;
  size_t text_len;
  char * sec_name;
  size_t sec_name_len;
  int type;
  int flags;
  int linkonce;

  if (idx)
    {
      prefix = ELF_STRING_ARM_unwind;
      prefix_once = ELF_STRING_ARM_unwind_once;
      type = SHT_ARM_EXIDX;
    }
  else
    {
      prefix = ELF_STRING_ARM_unwind_info;
      prefix_once = ELF_STRING_ARM_unwind_info_once;
      type = SHT_PROGBITS;
    }

  text_name = segment_name (text_seg);
  if (streq (text_name, ".text"))
    text_name = "";

  if (strncmp (text_name, ".gnu.linkonce.t.",
	       strlen (".gnu.linkonce.t.")) == 0)
    {
      prefix = prefix_once;
      text_name += strlen (".gnu.linkonce.t.");
    }

  prefix_len = strlen (prefix);
  text_len = strlen (text_name);
  sec_name_len = prefix_len + text_len;
  sec_name = (char *) xmalloc (sec_name_len + 1);
  memcpy (sec_name, prefix, prefix_len);
  memcpy (sec_name + prefix_len, text_name, text_len);
  sec_name[prefix_len + text_len] = '\0';

  flags = SHF_ALLOC;
  linkonce = 0;
  group_name = 0;

  /* Handle COMDAT group.  */
  if (prefix != prefix_once && (text_seg->flags & SEC_LINK_ONCE) != 0)
    {
      group_name = elf_group_name (text_seg);
      if (group_name == NULL)
	{
	  as_bad (_("Group section `%s' has no group signature"),
		  segment_name (text_seg));
	  ignore_rest_of_line ();
	  return;
	}
      flags |= SHF_GROUP;
      linkonce = 1;
    }

  obj_elf_change_section (sec_name, type, flags, 0, group_name, linkonce, 0);

  /* Set the section link for index tables.  */
  if (idx)
    elf_linked_to_section (now_seg) = text_seg;
}


/* Start an unwind table entry.	 HAVE_DATA is nonzero if we have additional
   personality routine data.  Returns zero, or the index table value for
   and inline entry.  */

static valueT
create_unwind_entry (int have_data)
{
  int size;
  addressT where;
  char *ptr;
  /* The current word of data.	*/
  valueT data;
  /* The number of bytes left in this word.  */
  int n;

  finish_unwind_opcodes ();

  /* Remember the current text section.	 */
  unwind.saved_seg = now_seg;
  unwind.saved_subseg = now_subseg;

  start_unwind_section (now_seg, 0);

  if (unwind.personality_routine == NULL)
    {
      if (unwind.personality_index == -2)
	{
	  if (have_data)
	    as_bad (_("handlerdata in cantunwind frame"));
	  return 1; /* EXIDX_CANTUNWIND.  */
	}

      /* Use a default personality routine if none is specified.  */
      if (unwind.personality_index == -1)
	{
	  if (unwind.opcode_count > 3)
	    unwind.personality_index = 1;
	  else
	    unwind.personality_index = 0;
	}

      /* Space for the personality routine entry.  */
      if (unwind.personality_index == 0)
	{
	  if (unwind.opcode_count > 3)
	    as_bad (_("too many unwind opcodes for personality routine 0"));

	  if (!have_data)
	    {
	      /* All the data is inline in the index table.  */
	      data = 0x80;
	      n = 3;
	      while (unwind.opcode_count > 0)
		{
		  unwind.opcode_count--;
		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
		  n--;
		}

	      /* Pad with "finish" opcodes.  */
	      while (n--)
		data = (data << 8) | 0xb0;

	      return data;
	    }
	  size = 0;
	}
      else
	/* We get two opcodes "free" in the first word.	 */
	size = unwind.opcode_count - 2;
    }
  else
    {
      gas_assert (unwind.personality_index == -1);

      /* An extra byte is required for the opcode count.	*/
      size = unwind.opcode_count + 1;
    }

  size = (size + 3) >> 2;
  if (size > 0xff)
    as_bad (_("too many unwind opcodes"));

  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
  unwind.table_entry = expr_build_dot ();

  /* Allocate the table entry.	*/
  ptr = frag_more ((size << 2) + 4);
  /* PR 13449: Zero the table entries in case some of them are not used.  */
  memset (ptr, 0, (size << 2) + 4);
  where = frag_now_fix () - ((size << 2) + 4);

  switch (unwind.personality_index)
    {
    case -1:
      /* ??? Should this be a PLT generating relocation?  */
      /* Custom personality routine.  */
      fix_new (frag_now, where, 4, unwind.personality_routine, 0, 1,
	       BFD_RELOC_ARM_PREL31);

      where += 4;
      ptr += 4;

      /* Set the first byte to the number of additional words.	*/
      data = size > 0 ? size - 1 : 0;
      n = 3;
      break;

    /* ABI defined personality routines.  */
    case 0:
      /* Three opcodes bytes are packed into the first word.  */
      data = 0x80;
      n = 3;
      break;

    case 1:
    case 2:
      /* The size and first two opcode bytes go in the first word.  */
      data = ((0x80 + unwind.personality_index) << 8) | size;
      n = 2;
      break;

    default:
      /* Should never happen.  */
      abort ();
    }

  /* Pack the opcodes into words (MSB first), reversing the list at the same
     time.  */
  while (unwind.opcode_count > 0)
    {
      if (n == 0)
	{
	  md_number_to_chars (ptr, data, 4);
	  ptr += 4;
	  n = 4;
	  data = 0;
	}
      unwind.opcode_count--;
      n--;
      data = (data << 8) | unwind.opcodes[unwind.opcode_count];
    }

  /* Finish off the last word.	*/
  if (n < 4)
    {
      /* Pad with "finish" opcodes.  */
      while (n--)
	data = (data << 8) | 0xb0;

      md_number_to_chars (ptr, data, 4);
    }

  if (!have_data)
    {
      /* Add an empty descriptor if there is no user-specified data.   */
      ptr = frag_more (4);
      md_number_to_chars (ptr, 0, 4);
    }

  return 0;
}


/* Initialize the DWARF-2 unwind information for this procedure.  */

void
tc_arm_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (REG_SP, 0);
}
#endif /* OBJ_ELF */

/* Convert REGNAME to a DWARF-2 register number.  */

int
tc_arm_regname_to_dw2regnum (char *regname)
{
  int reg = arm_reg_parse (&regname, REG_TYPE_RN);

  if (reg == FAIL)
    return -1;

  return reg;
}

#ifdef TE_PE
void
tc_pe_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
{
  expressionS exp;

  exp.X_op = O_secrel;
  exp.X_add_symbol = symbol;
  exp.X_add_number = 0;
  emit_expr (&exp, size);
}
#endif

/* MD interface: Symbol and relocation handling.  */

/* Return the address within the segment that a PC-relative fixup is
   relative to.  For ARM, PC-relative fixups applied to instructions
   are generally relative to the location of the fixup plus 8 bytes.
   Thumb branches are offset by 4, and Thumb loads relative to PC
   require special handling.  */

long
md_pcrel_from_section (fixS * fixP, segT seg)
{
  offsetT base = fixP->fx_where + fixP->fx_frag->fr_address;

  /* If this is pc-relative and we are going to emit a relocation
     then we just want to put out any pipeline compensation that the linker
     will need.  Otherwise we want to use the calculated base.
     For WinCE we skip the bias for externals as well, since this
     is how the MS ARM-CE assembler behaves and we want to be compatible.  */
  if (fixP->fx_pcrel
      && ((fixP->fx_addsy && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	  || (arm_force_relocation (fixP)
#ifdef TE_WINCE
	      && !S_IS_EXTERNAL (fixP->fx_addsy)
#endif
	      )))
    base = 0;


  switch (fixP->fx_r_type)
    {
      /* PC relative addressing on the Thumb is slightly odd as the
	 bottom two bits of the PC are forced to zero for the
	 calculation.  This happens *after* application of the
	 pipeline offset.  However, Thumb adrl already adjusts for
	 this, so we need not do it again.  */
    case BFD_RELOC_ARM_THUMB_ADD:
      return base & ~3;

    case BFD_RELOC_ARM_THUMB_OFFSET:
    case BFD_RELOC_ARM_T32_OFFSET_IMM:
    case BFD_RELOC_ARM_T32_ADD_PC12:
    case BFD_RELOC_ARM_T32_CP_OFF_IMM:
      return (base + 4) & ~3;

      /* Thumb branches are simply offset by +4.  */
    case BFD_RELOC_THUMB_PCREL_BRANCH7:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
      return base + 4;

    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      if (fixP->fx_addsy
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && ARM_IS_FUNC (fixP->fx_addsy)
	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
	base = fixP->fx_where + fixP->fx_frag->fr_address;
       return base + 4;

      /* BLX is like branches above, but forces the low two bits of PC to
	 zero.  */
    case BFD_RELOC_THUMB_PCREL_BLX:
      if (fixP->fx_addsy
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && THUMB_IS_FUNC (fixP->fx_addsy)
	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
	base = fixP->fx_where + fixP->fx_frag->fr_address;
      return (base + 4) & ~3;

      /* ARM mode branches are offset by +8.  However, the Windows CE
	 loader expects the relocation not to take this into account.  */
    case BFD_RELOC_ARM_PCREL_BLX:
      if (fixP->fx_addsy
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && ARM_IS_FUNC (fixP->fx_addsy)
	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
	base = fixP->fx_where + fixP->fx_frag->fr_address;
      return base + 8;

    case BFD_RELOC_ARM_PCREL_CALL:
      if (fixP->fx_addsy
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && THUMB_IS_FUNC (fixP->fx_addsy)
	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
	base = fixP->fx_where + fixP->fx_frag->fr_address;
      return base + 8;

    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_JUMP:
    case BFD_RELOC_ARM_PLT32:
#ifdef TE_WINCE
      /* When handling fixups immediately, because we have already
	 discovered the value of a symbol, or the address of the frag involved
	 we must account for the offset by +8, as the OS loader will never see the reloc.
	 see fixup_segment() in write.c
	 The S_IS_EXTERNAL test handles the case of global symbols.
	 Those need the calculated base, not just the pipe compensation the linker will need.  */
      if (fixP->fx_pcrel
	  && fixP->fx_addsy != NULL
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && (S_IS_EXTERNAL (fixP->fx_addsy) || !arm_force_relocation (fixP)))
	return base + 8;
      return base;
#else
      return base + 8;
#endif


      /* ARM mode loads relative to PC are also offset by +8.  Unlike
	 branches, the Windows CE loader *does* expect the relocation
	 to take this into account.  */
    case BFD_RELOC_ARM_OFFSET_IMM:
    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_CP_OFF_IMM:
      return base + 8;


      /* Other PC-relative relocations are un-offset.  */
    default:
      return base;
    }
}

/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
   Otherwise we have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
{
#ifdef OBJ_ELF
  if (name[0] == '_' && name[1] == 'G'
      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad (_("GOT already in the symbol table"));

	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, & zero_address_frag);
	}

      return GOT_symbol;
    }
#endif

  return NULL;
}

/* Subroutine of md_apply_fix.	 Check to see if an immediate can be
   computed as two separate immediate values, added together.  We
   already know that this value cannot be computed by just one ARM
   instruction.	 */

static unsigned int
validate_immediate_twopart (unsigned int   val,
			    unsigned int * highpart)
{
  unsigned int a;
  unsigned int i;

  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
      {
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;
	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    gas_assert (a & 0xff000000);
	    * highpart = (a >> 24) | ((i + 8) << 7);
	  }

	return (a & 0xff) | (i << 7);
      }

  return FAIL;
}

static int
validate_offset_imm (unsigned int val, int hwse)
{
  if ((hwse && val > 255) || val > 4095)
    return FAIL;
  return val;
}

/* Subroutine of md_apply_fix.	 Do those data_ops which can take a
   negative immediate constant by altering the instruction.  A bit of
   a hack really.
	MOV <-> MVN
	AND <-> BIC
	ADC <-> SBC
	by inverting the second operand, and
	ADD <-> SUB
	CMP <-> CMN
	by negating the second operand.	 */

static int
negate_data_op (unsigned long * instruction,
		unsigned long	value)
{
  int op, new_inst;
  unsigned long negated, inverted;

  negated = encode_arm_immediate (-value);
  inverted = encode_arm_immediate (~value);

  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
  switch (op)
    {
      /* First negates.	 */
    case OPCODE_SUB:		 /* ADD <-> SUB	 */
      new_inst = OPCODE_ADD;
      value = negated;
      break;

    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
      value = negated;
      break;

    case OPCODE_CMP:		 /* CMP <-> CMN	 */
      new_inst = OPCODE_CMN;
      value = negated;
      break;

    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
      value = negated;
      break;

      /* Now Inverted ops.  */
    case OPCODE_MOV:		 /* MOV <-> MVN	 */
      new_inst = OPCODE_MVN;
      value = inverted;
      break;

    case OPCODE_MVN:
      new_inst = OPCODE_MOV;
      value = inverted;
      break;

    case OPCODE_AND:		 /* AND <-> BIC	 */
      new_inst = OPCODE_BIC;
      value = inverted;
      break;

    case OPCODE_BIC:
      new_inst = OPCODE_AND;
      value = inverted;
      break;

    case OPCODE_ADC:		  /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
      value = inverted;
      break;

    case OPCODE_SBC:
      new_inst = OPCODE_ADC;
      value = inverted;
      break;

      /* We cannot do anything.	 */
    default:
      return FAIL;
    }

  if (value == (unsigned) FAIL)
    return FAIL;

  *instruction &= OPCODE_MASK;
  *instruction |= new_inst << DATA_OP_SHIFT;
  return value;
}

/* Like negate_data_op, but for Thumb-2.   */

static unsigned int
thumb32_negate_data_op (offsetT *instruction, unsigned int value)
{
  int op, new_inst;
  int rd;
  unsigned int negated, inverted;

  negated = encode_thumb32_immediate (-value);
  inverted = encode_thumb32_immediate (~value);

  rd = (*instruction >> 8) & 0xf;
  op = (*instruction >> T2_DATA_OP_SHIFT) & 0xf;
  switch (op)
    {
      /* ADD <-> SUB.  Includes CMP <-> CMN.  */
    case T2_OPCODE_SUB:
      new_inst = T2_OPCODE_ADD;
      value = negated;
      break;

    case T2_OPCODE_ADD:
      new_inst = T2_OPCODE_SUB;
      value = negated;
      break;

      /* ORR <-> ORN.  Includes MOV <-> MVN.  */
    case T2_OPCODE_ORR:
      new_inst = T2_OPCODE_ORN;
      value = inverted;
      break;

    case T2_OPCODE_ORN:
      new_inst = T2_OPCODE_ORR;
      value = inverted;
      break;

      /* AND <-> BIC.  TST has no inverted equivalent.  */
    case T2_OPCODE_AND:
      new_inst = T2_OPCODE_BIC;
      if (rd == 15)
	value = FAIL;
      else
	value = inverted;
      break;

    case T2_OPCODE_BIC:
      new_inst = T2_OPCODE_AND;
      value = inverted;
      break;

      /* ADC <-> SBC  */
    case T2_OPCODE_ADC:
      new_inst = T2_OPCODE_SBC;
      value = inverted;
      break;

    case T2_OPCODE_SBC:
      new_inst = T2_OPCODE_ADC;
      value = inverted;
      break;

      /* We cannot do anything.	 */
    default:
      return FAIL;
    }

  if (value == (unsigned int)FAIL)
    return FAIL;

  *instruction &= T2_OPCODE_MASK;
  *instruction |= new_inst << T2_DATA_OP_SHIFT;
  return value;
}

/* Read a 32-bit thumb instruction from buf.  */
static unsigned long
get_thumb32_insn (char * buf)
{
  unsigned long insn;
  insn = md_chars_to_number (buf, THUMB_SIZE) << 16;
  insn |= md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);

  return insn;
}


/* We usually want to set the low bit on the address of thumb function
   symbols.  In particular .word foo - . should have the low bit set.
   Generic code tries to fold the difference of two symbols to
   a constant.  Prevent this and force a relocation when the first symbols
   is a thumb function.  */

bfd_boolean
arm_optimize_expr (expressionS *l, operatorT op, expressionS *r)
{
  if (op == O_subtract
      && l->X_op == O_symbol
      && r->X_op == O_symbol
      && THUMB_IS_FUNC (l->X_add_symbol))
    {
      l->X_op = O_subtract;
      l->X_op_symbol = r->X_add_symbol;
      l->X_add_number -= r->X_add_number;
      return TRUE;
    }

  /* Process as normal.  */
  return FALSE;
}

/* Encode Thumb2 unconditional branches and calls. The encoding
   for the 2 are identical for the immediate values.  */

static void
encode_thumb2_b_bl_offset (char * buf, offsetT value)
{
#define T2I1I2MASK  ((1 << 13) | (1 << 11))
  offsetT newval;
  offsetT newval2;
  addressT S, I1, I2, lo, hi;

  S = (value >> 24) & 0x01;
  I1 = (value >> 23) & 0x01;
  I2 = (value >> 22) & 0x01;
  hi = (value >> 12) & 0x3ff;
  lo = (value >> 1) & 0x7ff;
  newval   = md_chars_to_number (buf, THUMB_SIZE);
  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
  newval  |= (S << 10) | hi;
  newval2 &=  ~T2I1I2MASK;
  newval2 |= (((I1 ^ S) << 13) | ((I2 ^ S) << 11) | lo) ^ T2I1I2MASK;
  md_number_to_chars (buf, newval, THUMB_SIZE);
  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
}

void
md_apply_fix (fixS *	fixP,
	       valueT * valP,
	       segT	seg)
{
  offsetT	 value = * valP;
  offsetT	 newval;
  unsigned int	 newimm;
  unsigned long	 temp;
  int		 sign;
  char *	 buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  gas_assert (fixP->fx_r_type <= BFD_RELOC_UNUSED);

  /* Note whether this will delete the relocation.  */

  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
    fixP->fx_done = 1;

  /* On a 64-bit host, silently truncate 'value' to 32 bits for
     consistency with the behaviour on 32-bit hosts.  Remember value
     for emit_reloc.  */
  value &= 0xffffffff;
  value ^= 0x80000000;
  value -= 0x80000000;

  *valP = value;
  fixP->fx_addnumber = value;

  /* Same treatment for fixP->fx_offset.  */
  fixP->fx_offset &= 0xffffffff;
  fixP->fx_offset ^= 0x80000000;
  fixP->fx_offset -= 0x80000000;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_NONE:
      /* This will need to go in the object file.  */
      fixP->fx_done = 0;
      break;

    case BFD_RELOC_ARM_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;

      if (fixP->fx_addsy)
	{
	  const char *msg = 0;

	  if (! S_IS_DEFINED (fixP->fx_addsy))
	    msg = _("undefined symbol %s used as an immediate value");
	  else if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
	    msg = _("symbol %s is in a different section");
	  else if (S_IS_WEAK (fixP->fx_addsy))
	    msg = _("symbol %s is weak and may be overridden later");

	  if (msg)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    msg, S_GET_NAME (fixP->fx_addsy));
	      break;
	    }
	}

      temp = md_chars_to_number (buf, INSN_SIZE);

      /* If the offset is negative, we should use encoding A2 for ADR.  */
      if ((temp & 0xfff0000) == 0x28f0000 && value < 0)
	newimm = negate_data_op (&temp, value);
      else
	{
	  newimm = encode_arm_immediate (value);

	  /* If the instruction will fail, see if we can fix things up by
	     changing the opcode.  */
	  if (newimm == (unsigned int) FAIL)
	    newimm = negate_data_op (&temp, value);
	}

      if (newimm == (unsigned int) FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}

      newimm |= (temp & 0xfffff000);
      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      {
	unsigned int highpart = 0;
	unsigned int newinsn  = 0xe1a00000; /* nop.  */

	if (fixP->fx_addsy)
	  {
	    const char *msg = 0;

	    if (! S_IS_DEFINED (fixP->fx_addsy))
	      msg = _("undefined symbol %s used as an immediate value");
	    else if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
	      msg = _("symbol %s is in a different section");
	    else if (S_IS_WEAK (fixP->fx_addsy))
	      msg = _("symbol %s is weak and may be overridden later");

	    if (msg)
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      msg, S_GET_NAME (fixP->fx_addsy));
		break;
	      }
	  }

	newimm = encode_arm_immediate (value);
	temp = md_chars_to_number (buf, INSN_SIZE);

	/* If the instruction will fail, see if we can fix things up by
	   changing the opcode.	 */
	if (newimm == (unsigned int) FAIL
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
	  {
	    /* No ?  OK - try using two ADD instructions to generate
	       the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);

	    /* Yes - then make sure that the second instruction is
	       also an add.  */
	    if (newimm != (unsigned int) FAIL)
	      newinsn = temp;
	    /* Still No ?  Try using a negated value.  */
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
	    /* Otherwise - give up.  */
	    else
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
			      (long) value);
		break;
	      }

	    /* Replace the first operand in the 2nd instruction (which
	       is the PC) with the destination register.  We have
	       already added in the PC in the first instruction and we
	       do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
	    newinsn |= ((newinsn & 0x0f000) << 4);
	  }

	newimm |= (temp & 0xfffff000);
	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);

	highpart |= (newinsn & 0xfffff000);
	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
      }
      break;

    case BFD_RELOC_ARM_OFFSET_IMM:
      if (!fixP->fx_done && seg->use_rela_p)
	value = 0;

    case BFD_RELOC_ARM_LITERAL:
      sign = value > 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 0) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_LITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad immediate value for offset (%ld)"),
			  (long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      if (value == 0)
	newval &= 0xfffff000;
      else
	{
	  newval &= 0xff7ff000;
	  newval |= value | (sign ? INDEX_UP : 0);
	}
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
      sign = value > 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 1) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad immediate value for 8-bit offset (%ld)"),
			  (long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      if (value == 0)
	newval &= 0xfffff0f0;
      else
	{
	  newval &= 0xff7ff0f0;
	  newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
	}
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_T32_OFFSET_U8:
      if (value < 0 || value > 1020 || value % 4 != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("bad immediate value for offset (%ld)"), (long) value);
      value /= 4;

      newval = md_chars_to_number (buf+2, THUMB_SIZE);
      newval |= value;
      md_number_to_chars (buf+2, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_T32_OFFSET_IMM:
      /* This is a complicated relocation used for all varieties of Thumb32
	 load/store instruction with immediate offset:

	 1110 100P u1WL NNNN XXXX YYYY iiii iiii - +/-(U) pre/post(P) 8-bit,
						   *4, optional writeback(W)
						   (doubleword load/store)

	 1111 100S uTTL 1111 XXXX iiii iiii iiii - +/-(U) 12-bit PC-rel
	 1111 100S 0TTL NNNN XXXX 1Pu1 iiii iiii - +/-(U) pre/post(P) 8-bit
	 1111 100S 0TTL NNNN XXXX 1110 iiii iiii - positive 8-bit (T instruction)
	 1111 100S 1TTL NNNN XXXX iiii iiii iiii - positive 12-bit
	 1111 100S 0TTL NNNN XXXX 1100 iiii iiii - negative 8-bit

	 Uppercase letters indicate bits that are already encoded at
	 this point.  Lowercase letters are our problem.  For the
	 second block of instructions, the secondary opcode nybble
	 (bits 8..11) is present, and bit 23 is zero, even if this is
	 a PC-relative operation.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      newval <<= 16;
      newval |= md_chars_to_number (buf+THUMB_SIZE, THUMB_SIZE);

      if ((newval & 0xf0000000) == 0xe0000000)
	{
	  /* Doubleword load/store: 8-bit offset, scaled by 4.  */
	  if (value >= 0)
	    newval |= (1 << 23);
	  else
	    value = -value;
	  if (value % 4 != 0)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset not a multiple of 4"));
	      break;
	    }
	  value /= 4;
	  if (value > 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
	}
      else if ((newval & 0x000f0000) == 0x000f0000)
	{
	  /* PC-relative, 12-bit offset.  */
	  if (value >= 0)
	    newval |= (1 << 23);
	  else
	    value = -value;
	  if (value > 0xfff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xfff;
	}
      else if ((newval & 0x00000100) == 0x00000100)
	{
	  /* Writeback: 8-bit, +/- offset.  */
	  if (value >= 0)
	    newval |= (1 << 9);
	  else
	    value = -value;
	  if (value > 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
	}
      else if ((newval & 0x00000f00) == 0x00000e00)
	{
	  /* T-instruction: positive 8-bit offset.  */
	  if (value < 0 || value > 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
	  newval |= value;
	}
      else
	{
	  /* Positive 12-bit or negative 8-bit offset.  */
	  int limit;
	  if (value >= 0)
	    {
	      newval |= (1 << 23);
	      limit = 0xfff;
	    }
	  else
	    {
	      value = -value;
	      limit = 0xff;
	    }
	  if (value > limit)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~limit;
	}

      newval |= value;
      md_number_to_chars (buf, (newval >> 16) & 0xffff, THUMB_SIZE);
      md_number_to_chars (buf + THUMB_SIZE, newval & 0xffff, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_SHIFT_IMM:
      newval = md_chars_to_number (buf, INSN_SIZE);
      if (((unsigned long) value) > 32
	  || (value == 32
	      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("shift expression is too large"));
	  break;
	}

      if (value == 0)
	/* Shifts of zero must be done as lsl.	*/
	newval &= ~0x60;
      else if (value == 32)
	value = 0;
      newval &= 0xfffff07f;
      newval |= (value & 0x1f) << 7;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_T32_IMMEDIATE:
    case BFD_RELOC_ARM_T32_ADD_IMM:
    case BFD_RELOC_ARM_T32_IMM12:
    case BFD_RELOC_ARM_T32_ADD_PC12:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;

      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
	}

      newval = md_chars_to_number (buf, THUMB_SIZE);
      newval <<= 16;
      newval |= md_chars_to_number (buf+2, THUMB_SIZE);

      newimm = FAIL;
      if (fixP->fx_r_type == BFD_RELOC_ARM_T32_IMMEDIATE
	  || fixP->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM)
	{
	  newimm = encode_thumb32_immediate (value);
	  if (newimm == (unsigned int) FAIL)
	    newimm = thumb32_negate_data_op (&newval, value);
	}
      if (fixP->fx_r_type != BFD_RELOC_ARM_T32_IMMEDIATE
	  && newimm == (unsigned int) FAIL)
	{
	  /* Turn add/sum into addw/subw.  */
	  if (fixP->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM)
	    newval = (newval & 0xfeffffff) | 0x02000000;
	  /* No flat 12-bit imm encoding for addsw/subsw.  */
	  if ((newval & 0x00100000) == 0)
	    {
	      /* 12 bit immediate for addw/subw.  */
	      if (value < 0)
		{
		  value = -value;
		  newval ^= 0x00a00000;
		}
	      if (value > 0xfff)
		newimm = (unsigned int) FAIL;
	      else
		newimm = value;
	    }
	}

      if (newimm == (unsigned int)FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}

      newval |= (newimm & 0x800) << 15;
      newval |= (newimm & 0x700) << 4;
      newval |= (newimm & 0x0ff);

      md_number_to_chars (buf,   (valueT) ((newval >> 16) & 0xffff), THUMB_SIZE);
      md_number_to_chars (buf+2, (valueT) (newval & 0xffff), THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_SMC:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid smc expression"));
      newval = md_chars_to_number (buf, INSN_SIZE);
      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_HVC:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid hvc expression"));
      newval = md_chars_to_number (buf, INSN_SIZE);
      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SWI:
      if (fixP->tc_fix_data != 0)
	{
	  if (((unsigned long) value) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= value;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      else
	{
	  if (((unsigned long) value) > 0x00ffffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval |= value;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_MULTI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid expression in load/store multiple"));
      newval = value | md_chars_to_number (buf, INSN_SIZE);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PCREL_CALL:

      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t)
	  && fixP->fx_addsy
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && THUMB_IS_FUNC (fixP->fx_addsy))
	/* Flip the bl to blx. This is a simple flip
	   bit here because we generate PCREL_CALL for
	   unconditional bls.  */
	{
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval = newval | 0x10000000;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	  temp = 1;
	  fixP->fx_done = 1;
	}
      else
	temp = 3;
      goto arm_branch_common;

    case BFD_RELOC_ARM_PCREL_JUMP:
      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t)
	  && fixP->fx_addsy
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && THUMB_IS_FUNC (fixP->fx_addsy))
	{
	  /* This would map to a bl<cond>, b<cond>,
	     b<always> to a Thumb function. We
	     need to force a relocation for this particular
	     case.  */
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  fixP->fx_done = 0;
	}

    case BFD_RELOC_ARM_PLT32:
#endif
    case BFD_RELOC_ARM_PCREL_BRANCH:
      temp = 3;
      goto arm_branch_common;

    case BFD_RELOC_ARM_PCREL_BLX:

      temp = 1;
      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t)
	  && fixP->fx_addsy
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && ARM_IS_FUNC (fixP->fx_addsy))
	{
	  /* Flip the blx to a bl and warn.  */
	  const char *name = S_GET_NAME (fixP->fx_addsy);
	  newval = 0xeb000000;
	  as_warn_where (fixP->fx_file, fixP->fx_line,
			 _("blx to '%s' an ARM ISA state function changed to bl"),
			  name);
	  md_number_to_chars (buf, newval, INSN_SIZE);
	  temp = 3;
	  fixP->fx_done = 1;
	}

#ifdef OBJ_ELF
       if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
	 fixP->fx_r_type = BFD_RELOC_ARM_PCREL_CALL;
#endif

    arm_branch_common:
      /* We are going to store value (shifted right by two) in the
	 instruction, in a 24 bit, signed field.  Bits 26 through 32 either
	 all clear or all set and bit 0 must be clear.  For B/BL bit 1 must
	 also be be clear.  */
      if (value & temp)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("misaligned branch destination"));
      if ((value & (offsetT)0xfe000000) != (offsetT)0
	  && (value & (offsetT)0xfe000000) != (offsetT)0xfe000000)
	as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval |= (value >> 2) & 0x00ffffff;
	  /* Set the H bit on BLX instructions.  */
	  if (temp == 1)
	    {
	      if (value & 2)
		newval |= 0x01000000;
	      else
		newval &= ~0x01000000;
	    }
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH7: /* CBZ */
      /* CBZ can only branch forward.  */

      /* Attempts to use CBZ to branch to the next instruction
	 (which, strictly speaking, are prohibited) will be turned into
	 no-ops.

	 FIXME: It may be better to remove the instruction completely and
	 perform relaxation.  */
      if (value == -2)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval = 0xbf00; /* NOP encoding T1 */
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      else
	{
	  if (value & ~0x7e)
	    as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);

	  if (fixP->fx_done || !seg->use_rela_p)
	    {
	      newval = md_chars_to_number (buf, THUMB_SIZE);
	      newval |= ((value & 0x3e) << 2) | ((value & 0x40) << 3);
	      md_number_to_chars (buf, newval, THUMB_SIZE);
	    }
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.	*/
      if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= (value & 0x1ff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
      if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= (value & 0xfff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH20:
      if (fixP->fx_addsy
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && ARM_IS_FUNC (fixP->fx_addsy)
	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
	{
	  /* Force a relocation for a branch 20 bits wide.  */
	  fixP->fx_done = 0;
	}
      if ((value & ~0x1fffff) && ((value & ~0x0fffff) != ~0x0fffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("conditional branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT newval2;
	  addressT S, J1, J2, lo, hi;

	  S  = (value & 0x00100000) >> 20;
	  J2 = (value & 0x00080000) >> 19;
	  J1 = (value & 0x00040000) >> 18;
	  hi = (value & 0x0003f000) >> 12;
	  lo = (value & 0x00000ffe) >> 1;

	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (S << 10) | hi;
	  newval2 |= (J1 << 13) | (J2 << 11) | lo;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BLX:
      /* If there is a blx from a thumb state function to
	 another thumb function flip this to a bl and warn
	 about it.  */

      if (fixP->fx_addsy
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && THUMB_IS_FUNC (fixP->fx_addsy))
	{
	  const char *name = S_GET_NAME (fixP->fx_addsy);
	  as_warn_where (fixP->fx_file, fixP->fx_line,
			 _("blx to Thumb func '%s' from Thumb ISA state changed to bl"),
			 name);
	  newval = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval = newval | 0x1000;
	  md_number_to_chars (buf+THUMB_SIZE, newval, THUMB_SIZE);
	  fixP->fx_r_type = BFD_RELOC_THUMB_PCREL_BRANCH23;
	  fixP->fx_done = 1;
	}


      goto thumb_bl_common;

    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      /* A bl from Thumb state ISA to an internal ARM state function
	 is converted to a blx.  */
      if (fixP->fx_addsy
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
	  && ARM_IS_FUNC (fixP->fx_addsy)
	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
	{
	  newval = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval = newval & ~0x1000;
	  md_number_to_chars (buf+THUMB_SIZE, newval, THUMB_SIZE);
	  fixP->fx_r_type = BFD_RELOC_THUMB_PCREL_BLX;
	  fixP->fx_done = 1;
	}

    thumb_bl_common:

      if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	/* For a BLX instruction, make sure that the relocation is rounded up
	   to a word boundary.  This follows the semantics of the instruction
	   which specifies that bit 1 of the target address will come from bit
	   1 of the base address.  */
	value = (value + 3) & ~ 3;

#ifdef OBJ_ELF
       if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4
	   && fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	 fixP->fx_r_type = BFD_RELOC_THUMB_PCREL_BRANCH23;
#endif

      if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	{
	  if (!(ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2)))
	    as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);
	  else if ((value & ~0x1ffffff)
		   && ((value & ~0x1ffffff) != ~0x1ffffff))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("Thumb2 branch out of range"));
	}

      if (fixP->fx_done || !seg->use_rela_p)
	encode_thumb2_b_bl_offset (buf, value);

      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH25:
      if ((value & ~0x0ffffff) && ((value & ~0x0ffffff) != ~0x0ffffff))
	as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);

      if (fixP->fx_done || !seg->use_rela_p)
	  encode_thumb2_b_bl_offset (buf, value);

      break;

    case BFD_RELOC_8:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, value, 1);
      break;

    case BFD_RELOC_16:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, value, 2);
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_TLS_CALL:
    case BFD_RELOC_ARM_THM_TLS_CALL:
    case BFD_RELOC_ARM_TLS_DESCSEQ:
    case BFD_RELOC_ARM_THM_TLS_DESCSEQ:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      break;

    case BFD_RELOC_ARM_TLS_GOTDESC:
    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
    case BFD_RELOC_ARM_TLS_LDO32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* fall through */

    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, 0, 4);
      break;

    case BFD_RELOC_ARM_GOT_PREL:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, value, 4);
      break;

    case BFD_RELOC_ARM_TARGET2:
      /* TARGET2 is not partial-inplace, so we need to write the
	 addend here for REL targets, because it won't be written out
	 during reloc processing later.  */
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, fixP->fx_offset, 4);
      break;
#endif

    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_32_PCREL:
#ifdef TE_PE
    case BFD_RELOC_32_SECREL:
#endif
      if (fixP->fx_done || !seg->use_rela_p)
#ifdef TE_WINCE
	/* For WinCE we only do this for pcrel fixups.  */
	if (fixP->fx_done || fixP->fx_pcrel)
#endif
	  md_number_to_chars (buf, value, 4);
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PREL31:
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, 4) & 0x80000000;
	  if ((value ^ (value >> 1)) & 0x40000000)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("rel31 relocation overflow"));
	    }
	  newval |= value & 0x7fffffff;
	  md_number_to_chars (buf, newval, 4);
	}
      break;
#endif

    case BFD_RELOC_ARM_CP_OFF_IMM:
    case BFD_RELOC_ARM_T32_CP_OFF_IMM:
      if (value < -1023 || value > 1023 || (value & 3))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("co-processor offset out of range"));
    cp_off_common:
      sign = value > 0;
      if (value < 0)
	value = -value;
      if (fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM
	  || fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM_S2)
	newval = md_chars_to_number (buf, INSN_SIZE);
      else
	newval = get_thumb32_insn (buf);
      if (value == 0)
	newval &= 0xffffff00;
      else
	{
	  newval &= 0xff7fff00;
	  newval |= (value >> 2) | (sign ? INDEX_UP : 0);
	}
      if (fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM
	  || fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM_S2)
	md_number_to_chars (buf, newval, INSN_SIZE);
      else
	put_thumb32_insn (buf, newval);
      break;

    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
    case BFD_RELOC_ARM_T32_CP_OFF_IMM_S2:
      if (value < -255 || value > 255)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("co-processor offset out of range"));
      value *= 4;
      goto cp_off_common;

    case BFD_RELOC_ARM_THUMB_OFFSET:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      /* Exactly what ranges, and where the offset is inserted depends
	 on the type of instruction, we can establish this from the
	 top 4 bits.  */
      switch (newval >> 12)
	{
	case 4: /* PC load.  */
	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
	     forced to zero for these loads; md_pcrel_from has already
	     compensated for this.  */
	  if (value & 3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, target not word aligned (0x%08lX)"),
			  (((unsigned long) fixP->fx_frag->fr_address
			    + (unsigned long) fixP->fx_where) & ~3)
			  + (unsigned long) value);

	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);

	  newval |= value >> 2;
	  break;

	case 9: /* SP load/store.  */
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value >> 2;
	  break;

	case 6: /* Word load/store.  */
	  if (value & ~0x7c)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 4; /* 6 - 2.  */
	  break;

	case 7: /* Byte load/store.  */
	  if (value & ~0x1f)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 6;
	  break;

	case 8: /* Halfword load/store.	 */
	  if (value & ~0x3e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 5; /* 6 - 1.  */
	  break;

	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"Unable to process relocation for thumb opcode: %lx",
			(unsigned long) newval);
	  break;
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_ADD:
      /* This is a complicated relocation, since we use it for all of
	 the following immediate relocations:

	    3bit ADD/SUB
	    8bit ADD/SUB
	    9bit ADD/SUB SP word-aligned
	   10bit ADD PC/SP word-aligned

	 The type of instruction being processed is encoded in the
	 instruction field:

	   0x8000  SUB
	   0x00F0  Rd
	   0x000F  Rs
      */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	int rd = (newval >> 4) & 0xf;
	int rs = newval & 0xf;
	int subtract = !!(newval & 0x8000);

	/* Check for HI regs, only very restricted cases allowed:
	   Adjusting SP, and using PC or SP to get an address.	*/
	if ((rd > 7 && (rd != REG_SP || rs != REG_SP))
	    || (rs > 7 && rs != REG_SP && rs != REG_PC))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid Hi register with immediate"));

	/* If value is negative, choose the opposite instruction.  */
	if (value < 0)
	  {
	    value = -value;
	    subtract = !subtract;
	    if (value < 0)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	  }

	if (rd == REG_SP)
	  {
	    if (value & ~0x1fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for stack address calculation"));
	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	    newval |= value >> 2;
	  }
	else if (rs == REG_PC || rs == REG_SP)
	  {
	    if (subtract || value & ~0x3fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for address calculation (value = 0x%08lX)"),
			    (unsigned long) value);
	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
	    newval |= rd << 8;
	    newval |= value >> 2;
	  }
	else if (rs == rd)
	  {
	    if (value & ~0xff)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	    newval |= (rd << 8) | value;
	  }
	else
	  {
	    if (value & ~0x7)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	    newval |= rd | (rs << 3) | (value << 6);
	  }
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_IMM:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      if (value < 0 || value > 255)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid immediate: %ld is out of range"),
		      (long) value);
      newval |= value;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_SHIFT:
      /* 5bit shift value (0..32).  LSL cannot take 32.	 */
      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf83f;
      temp = newval & 0xf800;
      if (value < 0 || value > 32 || (value == 32 && temp == T_OPCODE_LSL_I))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid shift value: %ld"), (long) value);
      /* Shifts of zero must be encoded as LSL.	 */
      if (value == 0)
	newval = (newval & 0x003f) | T_OPCODE_LSL_I;
      /* Shifts of 32 are encoded as zero.  */
      else if (value == 32)
	value = 0;
      newval |= value << 6;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    case BFD_RELOC_ARM_MOVW:
    case BFD_RELOC_ARM_MOVT:
    case BFD_RELOC_ARM_THUMB_MOVW:
    case BFD_RELOC_ARM_THUMB_MOVT:
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  /* REL format relocations are limited to a 16-bit addend.  */
	  if (!fixP->fx_done)
	    {
	      if (value < -0x8000 || value > 0x7fff)
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("offset out of range"));
	    }
	  else if (fixP->fx_r_type == BFD_RELOC_ARM_MOVT
		   || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT)
	    {
	      value >>= 16;
	    }

	  if (fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVW
	      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT)
	    {
	      newval = get_thumb32_insn (buf);
	      newval &= 0xfbf08f00;
	      newval |= (value & 0xf000) << 4;
	      newval |= (value & 0x0800) << 15;
	      newval |= (value & 0x0700) << 4;
	      newval |= (value & 0x00ff);
	      put_thumb32_insn (buf, newval);
	    }
	  else
	    {
	      newval = md_chars_to_number (buf, 4);
	      newval &= 0xfff0f000;
	      newval |= value & 0x0fff;
	      newval |= (value & 0xf000) << 4;
	      md_number_to_chars (buf, newval, 4);
	    }
	}
      return;

   case BFD_RELOC_ARM_ALU_PC_G0_NC:
   case BFD_RELOC_ARM_ALU_PC_G0:
   case BFD_RELOC_ARM_ALU_PC_G1_NC:
   case BFD_RELOC_ARM_ALU_PC_G1:
   case BFD_RELOC_ARM_ALU_PC_G2:
   case BFD_RELOC_ARM_ALU_SB_G0_NC:
   case BFD_RELOC_ARM_ALU_SB_G0:
   case BFD_RELOC_ARM_ALU_SB_G1_NC:
   case BFD_RELOC_ARM_ALU_SB_G1:
   case BFD_RELOC_ARM_ALU_SB_G2:
     gas_assert (!fixP->fx_done);
     if (!seg->use_rela_p)
       {
	 bfd_vma insn;
	 bfd_vma encoded_addend;
	 bfd_vma addend_abs = abs (value);

	 /* Check that the absolute value of the addend can be
	    expressed as an 8-bit constant plus a rotation.  */
	 encoded_addend = encode_arm_immediate (addend_abs);
	 if (encoded_addend == (unsigned int) FAIL)
	   as_bad_where (fixP->fx_file, fixP->fx_line,
			 _("the offset 0x%08lX is not representable"),
			 (unsigned long) addend_abs);

	 /* Extract the instruction.  */
	 insn = md_chars_to_number (buf, INSN_SIZE);

	 /* If the addend is positive, use an ADD instruction.
	    Otherwise use a SUB.  Take care not to destroy the S bit.  */
	 insn &= 0xff1fffff;
	 if (value < 0)
	   insn |= 1 << 22;
	 else
	   insn |= 1 << 23;

	 /* Place the encoded addend into the first 12 bits of the
	    instruction.  */
	 insn &= 0xfffff000;
	 insn |= encoded_addend;

	 /* Update the instruction.  */
	 md_number_to_chars (buf, insn, INSN_SIZE);
       }
     break;

    case BFD_RELOC_ARM_LDR_PC_G0:
    case BFD_RELOC_ARM_LDR_PC_G1:
    case BFD_RELOC_ARM_LDR_PC_G2:
    case BFD_RELOC_ARM_LDR_SB_G0:
    case BFD_RELOC_ARM_LDR_SB_G1:
    case BFD_RELOC_ARM_LDR_SB_G2:
      gas_assert (!fixP->fx_done);
      if (!seg->use_rela_p)
	{
	  bfd_vma insn;
	  bfd_vma addend_abs = abs (value);

	  /* Check that the absolute value of the addend can be
	     encoded in 12 bits.  */
	  if (addend_abs >= 0x1000)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad offset 0x%08lX (only 12 bits available for the magnitude)"),
			  (unsigned long) addend_abs);

	  /* Extract the instruction.  */
	  insn = md_chars_to_number (buf, INSN_SIZE);

	  /* If the addend is negative, clear bit 23 of the instruction.
	     Otherwise set it.  */
	  if (value < 0)
	    insn &= ~(1 << 23);
	  else
	    insn |= 1 << 23;

	  /* Place the absolute value of the addend into the first 12 bits
	     of the instruction.  */
	  insn &= 0xfffff000;
	  insn |= addend_abs;

	  /* Update the instruction.  */
	  md_number_to_chars (buf, insn, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_LDRS_PC_G0:
    case BFD_RELOC_ARM_LDRS_PC_G1:
    case BFD_RELOC_ARM_LDRS_PC_G2:
    case BFD_RELOC_ARM_LDRS_SB_G0:
    case BFD_RELOC_ARM_LDRS_SB_G1:
    case BFD_RELOC_ARM_LDRS_SB_G2:
      gas_assert (!fixP->fx_done);
      if (!seg->use_rela_p)
	{
	  bfd_vma insn;
	  bfd_vma addend_abs = abs (value);

	  /* Check that the absolute value of the addend can be
	     encoded in 8 bits.  */
	  if (addend_abs >= 0x100)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad offset 0x%08lX (only 8 bits available for the magnitude)"),
			  (unsigned long) addend_abs);

	  /* Extract the instruction.  */
	  insn = md_chars_to_number (buf, INSN_SIZE);

	  /* If the addend is negative, clear bit 23 of the instruction.
	     Otherwise set it.  */
	  if (value < 0)
	    insn &= ~(1 << 23);
	  else
	    insn |= 1 << 23;

	  /* Place the first four bits of the absolute value of the addend
	     into the first 4 bits of the instruction, and the remaining
	     four into bits 8 .. 11.  */
	  insn &= 0xfffff0f0;
	  insn |= (addend_abs & 0xf) | ((addend_abs & 0xf0) << 4);

	  /* Update the instruction.  */
	  md_number_to_chars (buf, insn, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_LDC_PC_G0:
    case BFD_RELOC_ARM_LDC_PC_G1:
    case BFD_RELOC_ARM_LDC_PC_G2:
    case BFD_RELOC_ARM_LDC_SB_G0:
    case BFD_RELOC_ARM_LDC_SB_G1:
    case BFD_RELOC_ARM_LDC_SB_G2:
      gas_assert (!fixP->fx_done);
      if (!seg->use_rela_p)
	{
	  bfd_vma insn;
	  bfd_vma addend_abs = abs (value);

	  /* Check that the absolute value of the addend is a multiple of
	     four and, when divided by four, fits in 8 bits.  */
	  if (addend_abs & 0x3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad offset 0x%08lX (must be word-aligned)"),
			  (unsigned long) addend_abs);

	  if ((addend_abs >> 2) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad offset 0x%08lX (must be an 8-bit number of words)"),
			  (unsigned long) addend_abs);

	  /* Extract the instruction.  */
	  insn = md_chars_to_number (buf, INSN_SIZE);

	  /* If the addend is negative, clear bit 23 of the instruction.
	     Otherwise set it.  */
	  if (value < 0)
	    insn &= ~(1 << 23);
	  else
	    insn |= 1 << 23;

	  /* Place the addend (divided by four) into the first eight
	     bits of the instruction.  */
	  insn &= 0xfffffff0;
	  insn |= addend_abs >> 2;

	  /* Update the instruction.  */
	  md_number_to_chars (buf, insn, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_V4BX:
      /* This will need to go in the object file.  */
      fixP->fx_done = 0;
      break;

    case BFD_RELOC_UNUSED:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
    }
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (asection *section, fixS *fixp)
{
  arelent * reloc;
  bfd_reloc_code_real_type code;

  reloc = (arelent *) xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  if (fixp->fx_pcrel)
    {
      if (section->use_rela_p)
	fixp->fx_offset -= md_pcrel_from_section (fixp, section);
      else
	fixp->fx_offset = reloc->address;
    }
  reloc->addend = fixp->fx_offset;

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_8:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_8_PCREL;
	  break;
	}

    case BFD_RELOC_16:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_16_PCREL;
	  break;
	}

    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_32_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_MOVW:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_ARM_MOVW_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_MOVT:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_ARM_MOVT_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_THUMB_MOVW:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_ARM_THUMB_MOVW_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_THUMB_MOVT:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_ARM_THUMB_MOVT_PCREL;
	  break;
	}

    case BFD_RELOC_NONE:
    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_RVA:
    case BFD_RELOC_THUMB_PCREL_BRANCH7:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
#ifdef TE_PE
    case BFD_RELOC_32_SECREL:
#endif
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_THUMB_PCREL_BLX:
#ifdef OBJ_ELF
      if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
	code = BFD_RELOC_THUMB_PCREL_BRANCH23;
      else
#endif
	code = BFD_RELOC_THUMB_PCREL_BLX;
      break;

    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_HWLITERAL:
      /* If this is called then the a literal has
	 been referenced across a section boundary.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("literal referenced across section boundary"));
      return NULL;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_TLS_CALL:
    case BFD_RELOC_ARM_THM_TLS_CALL:
    case BFD_RELOC_ARM_TLS_DESCSEQ:
    case BFD_RELOC_ARM_THM_TLS_DESCSEQ:
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_GOT_PREL:
    case BFD_RELOC_ARM_PLT32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_ARM_PREL31:
    case BFD_RELOC_ARM_TARGET2:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_LDO32:
    case BFD_RELOC_ARM_PCREL_CALL:
    case BFD_RELOC_ARM_PCREL_JUMP:
    case BFD_RELOC_ARM_ALU_PC_G0_NC:
    case BFD_RELOC_ARM_ALU_PC_G0:
    case BFD_RELOC_ARM_ALU_PC_G1_NC:
    case BFD_RELOC_ARM_ALU_PC_G1:
    case BFD_RELOC_ARM_ALU_PC_G2:
    case BFD_RELOC_ARM_LDR_PC_G0:
    case BFD_RELOC_ARM_LDR_PC_G1:
    case BFD_RELOC_ARM_LDR_PC_G2:
    case BFD_RELOC_ARM_LDRS_PC_G0:
    case BFD_RELOC_ARM_LDRS_PC_G1:
    case BFD_RELOC_ARM_LDRS_PC_G2:
    case BFD_RELOC_ARM_LDC_PC_G0:
    case BFD_RELOC_ARM_LDC_PC_G1:
    case BFD_RELOC_ARM_LDC_PC_G2:
    case BFD_RELOC_ARM_ALU_SB_G0_NC:
    case BFD_RELOC_ARM_ALU_SB_G0:
    case BFD_RELOC_ARM_ALU_SB_G1_NC:
    case BFD_RELOC_ARM_ALU_SB_G1:
    case BFD_RELOC_ARM_ALU_SB_G2:
    case BFD_RELOC_ARM_LDR_SB_G0:
    case BFD_RELOC_ARM_LDR_SB_G1:
    case BFD_RELOC_ARM_LDR_SB_G2:
    case BFD_RELOC_ARM_LDRS_SB_G0:
    case BFD_RELOC_ARM_LDRS_SB_G1:
    case BFD_RELOC_ARM_LDRS_SB_G2:
    case BFD_RELOC_ARM_LDC_SB_G0:
    case BFD_RELOC_ARM_LDC_SB_G1:
    case BFD_RELOC_ARM_LDC_SB_G2:
    case BFD_RELOC_ARM_V4BX:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_TLS_GOTDESC:
    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
      /* BFD will include the symbol's address in the addend.
	 But we don't want that, so subtract it out again here.  */
      if (!S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= (*reloc->sym_ptr_ptr)->value;
      code = fixp->fx_r_type;
      break;
#endif

    case BFD_RELOC_ARM_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal relocation (type: IMMEDIATE) not fixed up"));
      return NULL;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("ADRL used for a symbol not defined in the same file"));
      return NULL;

    case BFD_RELOC_ARM_OFFSET_IMM:
      if (section->use_rela_p)
	{
	  code = fixp->fx_r_type;
	  break;
	}

      if (fixp->fx_addsy != NULL
	  && !S_IS_DEFINED (fixp->fx_addsy)
	  && S_IS_LOCAL (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("undefined local label `%s'"),
			S_GET_NAME (fixp->fx_addsy));
	  return NULL;
	}

      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
      return NULL;

    default:
      {
	char * type;

	switch (fixp->fx_r_type)
	  {
	  case BFD_RELOC_NONE:		   type = "NONE";	  break;
	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
	  case BFD_RELOC_ARM_SHIFT_IMM:	   type = "SHIFT_IMM";	  break;
	  case BFD_RELOC_ARM_SMC:	   type = "SMC";	  break;
	  case BFD_RELOC_ARM_SWI:	   type = "SWI";	  break;
	  case BFD_RELOC_ARM_MULTI:	   type = "MULTI";	  break;
	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";	  break;
	  case BFD_RELOC_ARM_T32_OFFSET_IMM: type = "T32_OFFSET_IMM"; break;
	  case BFD_RELOC_ARM_T32_CP_OFF_IMM: type = "T32_CP_OFF_IMM"; break;
	  case BFD_RELOC_ARM_THUMB_ADD:	   type = "THUMB_ADD";	  break;
	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
	  case BFD_RELOC_ARM_THUMB_IMM:	   type = "THUMB_IMM";	  break;
	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
	  default:			   type = _("<unknown>"); break;
	  }
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("cannot represent %s relocation in this object file format"),
		      type);
	return NULL;
      }
    }

#ifdef OBJ_ELF
  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_ARM_GOTPC;
      reloc->addend = fixp->fx_offset = reloc->address;
    }
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }

  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  return reloc;
}

/* This fix_new is called by cons via TC_CONS_FIX_NEW.	*/

void
cons_fix_new_arm (fragS *	frag,
		  int		where,
		  int		size,
		  expressionS * exp)
{
  bfd_reloc_code_real_type type;
  int pcrel = 0;

  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
  switch (size)
    {
    case 1:
      type = BFD_RELOC_8;
      break;
    case 2:
      type = BFD_RELOC_16;
      break;
    case 4:
    default:
      type = BFD_RELOC_32;
      break;
    case 8:
      type = BFD_RELOC_64;
      break;
    }

#ifdef TE_PE
  if (exp->X_op == O_secrel)
  {
    exp->X_op = O_symbol;
    type = BFD_RELOC_32_SECREL;
  }
#endif

  fix_new_exp (frag, where, (int) size, exp, pcrel, type);
}

#if defined (OBJ_COFF)
void
arm_validate_fix (fixS * fixP)
{
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.	*/
  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
      && fixP->fx_addsy != NULL
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! THUMB_IS_FUNC (fixP->fx_addsy))
    {
      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
    }
}
#endif


int
arm_force_relocation (struct fix * fixp)
{
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixp->fx_r_type == BFD_RELOC_RVA)
    return 1;
#endif

  /* In case we have a call or a branch to a function in ARM ISA mode from
     a thumb function or vice-versa force the relocation. These relocations
     are cleared off for some cores that might have blx and simple transformations
     are possible.  */

#ifdef OBJ_ELF
  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_ARM_PCREL_JUMP:
    case BFD_RELOC_ARM_PCREL_CALL:
    case BFD_RELOC_THUMB_PCREL_BLX:
      if (THUMB_IS_FUNC (fixp->fx_addsy))
	return 1;
      break;

    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      if (ARM_IS_FUNC (fixp->fx_addsy))
	return 1;
      break;

    default:
      break;
    }
#endif

  /* Resolve these relocations even if the symbol is extern or weak.
     Technically this is probably wrong due to symbol preemption.
     In practice these relocations do not have enough range to be useful
     at dynamic link time, and some code (e.g. in the Linux kernel)
     expects these references to be resolved.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM8
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM_S2
      || fixp->fx_r_type == BFD_RELOC_ARM_THUMB_OFFSET
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_IMM12
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_ADD_PC12
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_CP_OFF_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_CP_OFF_IMM_S2)
    return 0;

  /* Always leave these relocations for the linker.  */
  if ((fixp->fx_r_type >= BFD_RELOC_ARM_ALU_PC_G0_NC
       && fixp->fx_r_type <= BFD_RELOC_ARM_LDC_SB_G2)
      || fixp->fx_r_type == BFD_RELOC_ARM_LDR_PC_G0)
    return 1;

  /* Always generate relocations against function symbols.  */
  if (fixp->fx_r_type == BFD_RELOC_32
      && fixp->fx_addsy
      && (symbol_get_bfdsym (fixp->fx_addsy)->flags & BSF_FUNCTION))
    return 1;

  return generic_force_reloc (fixp);
}

#if defined (OBJ_ELF) || defined (OBJ_COFF)
/* Relocations against function names must be left unadjusted,
   so that the linker can use this information to generate interworking
   stubs.  The MIPS version of this function
   also prevents relocations that are mips-16 specific, but I do not
   know why it does this.

   FIXME:
   There is one other problem that ought to be addressed here, but
   which currently is not:  Taking the address of a label (rather
   than a function) and then later jumping to that address.  Such
   addresses also ought to have their bottom bit set (assuming that
   they reside in Thumb code), but at the moment they will not.	 */

bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_addsy == NULL)
    return 1;

  /* Preserve relocations against symbols with function type.  */
  if (symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_FUNCTION)
    return FALSE;

  if (THUMB_IS_FUNC (fixP->fx_addsy)
      && fixP->fx_subsy == NULL)
    return FALSE;

  /* We need the symbol name for the VTABLE entries.  */
  if (	 fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return FALSE;

  /* Don't allow symbols to be discarded on GOT related relocs.	 */
  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GD32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_IE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDM32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDO32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GOTDESC
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_CALL
      || fixP->fx_r_type == BFD_RELOC_ARM_THM_TLS_CALL
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_DESCSEQ
      || fixP->fx_r_type == BFD_RELOC_ARM_THM_TLS_DESCSEQ
      || fixP->fx_r_type == BFD_RELOC_ARM_TARGET2)
    return FALSE;

  /* Similarly for group relocations.  */
  if ((fixP->fx_r_type >= BFD_RELOC_ARM_ALU_PC_G0_NC
       && fixP->fx_r_type <= BFD_RELOC_ARM_LDC_SB_G2)
      || fixP->fx_r_type == BFD_RELOC_ARM_LDR_PC_G0)
    return FALSE;

  /* MOVW/MOVT REL relocations have limited offsets, so keep the symbols.  */
  if (fixP->fx_r_type == BFD_RELOC_ARM_MOVW
      || fixP->fx_r_type == BFD_RELOC_ARM_MOVT
      || fixP->fx_r_type == BFD_RELOC_ARM_MOVW_PCREL
      || fixP->fx_r_type == BFD_RELOC_ARM_MOVT_PCREL
      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVW
      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT
      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVW_PCREL
      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT_PCREL)
    return FALSE;

  return TRUE;
}
#endif /* defined (OBJ_ELF) || defined (OBJ_COFF) */

#ifdef OBJ_ELF

const char *
elf32_arm_target_format (void)
{
#ifdef TE_SYMBIAN
  return (target_big_endian
	  ? "elf32-bigarm-symbian"
	  : "elf32-littlearm-symbian");
#elif defined (TE_VXWORKS)
  return (target_big_endian
	  ? "elf32-bigarm-vxworks"
	  : "elf32-littlearm-vxworks");
#elif defined (TE_NACL)
  return (target_big_endian
	  ? "elf32-bigarm-nacl"
	  : "elf32-littlearm-nacl");
#else
  if (target_big_endian)
    return "elf32-bigarm";
  else
    return "elf32-littlearm";
#endif
}

void
armelf_frob_symbol (symbolS * symp,
		    int *     puntp)
{
  elf_frob_symbol (symp, puntp);
}
#endif

/* MD interface: Finalization.	*/

void
arm_cleanup (void)
{
  literal_pool * pool;

  /* Ensure that all the IT blocks are properly closed.  */
  check_it_blocks_finished ();

  for (pool = list_of_pools; pool; pool = pool->next)
    {
      /* Put it at the end of the relevant section.  */
      subseg_set (pool->section, pool->sub_section);
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
      s_ltorg (0);
    }
}

#ifdef OBJ_ELF
/* Remove any excess mapping symbols generated for alignment frags in
   SEC.  We may have created a mapping symbol before a zero byte
   alignment; remove it if there's a mapping symbol after the
   alignment.  */
static void
check_mapping_symbols (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
		       void *dummy ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  fragS *fragp;

  if (seginfo == NULL || seginfo->frchainP == NULL)
    return;

  for (fragp = seginfo->frchainP->frch_root;
       fragp != NULL;
       fragp = fragp->fr_next)
    {
      symbolS *sym = fragp->tc_frag_data.last_map;
      fragS *next = fragp->fr_next;

      /* Variable-sized frags have been converted to fixed size by
	 this point.  But if this was variable-sized to start with,
	 there will be a fixed-size frag after it.  So don't handle
	 next == NULL.  */
      if (sym == NULL || next == NULL)
	continue;

      if (S_GET_VALUE (sym) < next->fr_address)
	/* Not at the end of this frag.  */
	continue;
      know (S_GET_VALUE (sym) == next->fr_address);

      do
	{
	  if (next->tc_frag_data.first_map != NULL)
	    {
	      /* Next frag starts with a mapping symbol.  Discard this
		 one.  */
	      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
	      break;
	    }

	  if (next->fr_next == NULL)
	    {
	      /* This mapping symbol is at the end of the section.  Discard
		 it.  */
	      know (next->fr_fix == 0 && next->fr_var == 0);
	      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
	      break;
	    }

	  /* As long as we have empty frags without any mapping symbols,
	     keep looking.  */
	  /* If the next frag is non-empty and does not start with a
	     mapping symbol, then this mapping symbol is required.  */
	  if (next->fr_address != next->fr_next->fr_address)
	    break;

	  next = next->fr_next;
	}
      while (next != NULL);
    }
}
#endif

/* Adjust the symbol table.  This marks Thumb symbols as distinct from
   ARM ones.  */

void
arm_adjust_symtab (void)
{
#ifdef OBJ_COFF
  symbolS * sym;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  if (THUMB_IS_FUNC (sym))
	    {
	      /* Mark the symbol as a Thumb function.  */
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!	 */
		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);

	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
	      else
		as_bad (_("%s: unexpected function type: %d"),
			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
	    }
	  else switch (S_GET_STORAGE_CLASS (sym))
	    {
	    case C_EXT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
	      break;
	    case C_STAT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
	      break;
	    case C_LABEL:
	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
	      break;
	    default:
	      /* Do nothing.  */
	      break;
	    }
	}

      if (ARM_IS_INTERWORK (sym))
	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
    }
#endif
#ifdef OBJ_ELF
  symbolS * sym;
  char	    bind;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  elf_symbol_type * elf_sym;

	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	  bind = ELF_ST_BIND (elf_sym->internal_elf_sym.st_info);

	  if (! bfd_is_arm_special_symbol_name (elf_sym->symbol.name,
		BFD_ARM_SPECIAL_SYM_TYPE_ANY))
	    {
	      /* If it's a .thumb_func, declare it as so,
		 otherwise tag label as .code 16.  */
	      if (THUMB_IS_FUNC (sym))
		elf_sym->internal_elf_sym.st_target_internal
		  = ST_BRANCH_TO_THUMB;
	      else if (EF_ARM_EABI_VERSION (meabi_flags) < EF_ARM_EABI_VER4)
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_16BIT);
	    }
	}
    }

  /* Remove any overlapping mapping symbols generated by alignment frags.  */
  bfd_map_over_sections (stdoutput, check_mapping_symbols, (char *) 0);
  /* Now do generic ELF adjustments.  */
  elf_adjust_symtab ();
#endif
}

/* MD interface: Initialization.  */

static void
set_constant_flonums (void)
{
  int i;

  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
}

/* Auto-select Thumb mode if it's the only available instruction set for the
   given architecture.  */

static void
autoselect_thumb_from_cpu_variant (void)
{
  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1))
    opcode_select (16);
}

void
md_begin (void)
{
  unsigned mach;
  unsigned int i;

  if (	 (arm_ops_hsh = hash_new ()) == NULL
      || (arm_cond_hsh = hash_new ()) == NULL
      || (arm_shift_hsh = hash_new ()) == NULL
      || (arm_psr_hsh = hash_new ()) == NULL
      || (arm_v7m_psr_hsh = hash_new ()) == NULL
      || (arm_reg_hsh = hash_new ()) == NULL
      || (arm_reloc_hsh = hash_new ()) == NULL
      || (arm_barrier_opt_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    hash_insert (arm_ops_hsh, insns[i].template_name, (void *) (insns + i));
  for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
    hash_insert (arm_cond_hsh, conds[i].template_name, (void *) (conds + i));
  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
    hash_insert (arm_shift_hsh, shift_names[i].name, (void *) (shift_names + i));
  for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
    hash_insert (arm_psr_hsh, psrs[i].template_name, (void *) (psrs + i));
  for (i = 0; i < sizeof (v7m_psrs) / sizeof (struct asm_psr); i++)
    hash_insert (arm_v7m_psr_hsh, v7m_psrs[i].template_name,
		 (void *) (v7m_psrs + i));
  for (i = 0; i < sizeof (reg_names) / sizeof (struct reg_entry); i++)
    hash_insert (arm_reg_hsh, reg_names[i].name, (void *) (reg_names + i));
  for (i = 0;
       i < sizeof (barrier_opt_names) / sizeof (struct asm_barrier_opt);
       i++)
    hash_insert (arm_barrier_opt_hsh, barrier_opt_names[i].template_name,
		 (void *) (barrier_opt_names + i));
#ifdef OBJ_ELF
  for (i = 0; i < ARRAY_SIZE (reloc_names); i++)
    {
      struct reloc_entry * entry = reloc_names + i;

      if (arm_is_eabi() && entry->reloc == BFD_RELOC_ARM_PLT32)
	/* This makes encode_branch() use the EABI versions of this relocation.  */
	entry->reloc = BFD_RELOC_UNUSED;

      hash_insert (arm_reloc_hsh, entry->name, (void *) entry);
    }
#endif

  set_constant_flonums ();

  /* Set the cpu variant based on the command-line options.  We prefer
     -mcpu= over -march= if both are set (as for GCC); and we prefer
     -mfpu= over any other way of setting the floating point unit.
     Use of legacy options with new options are faulted.  */
  if (legacy_cpu)
    {
      if (mcpu_cpu_opt || march_cpu_opt)
	as_bad (_("use of old and new-style options to set CPU type"));

      mcpu_cpu_opt = legacy_cpu;
    }
  else if (!mcpu_cpu_opt)
    mcpu_cpu_opt = march_cpu_opt;

  if (legacy_fpu)
    {
      if (mfpu_opt)
	as_bad (_("use of old and new-style options to set FPU type"));

      mfpu_opt = legacy_fpu;
    }
  else if (!mfpu_opt)
    {
#if !(defined (EABI_DEFAULT) || defined (TE_LINUX) \
	|| defined (TE_NetBSD) || defined (TE_VXWORKS))
      /* Some environments specify a default FPU.  If they don't, infer it
	 from the processor.  */
      if (mcpu_fpu_opt)
	mfpu_opt = mcpu_fpu_opt;
      else
	mfpu_opt = march_fpu_opt;
#else
      mfpu_opt = &fpu_default;
#endif
    }

  if (!mfpu_opt)
    {
      if (mcpu_cpu_opt != NULL)
	mfpu_opt = &fpu_default;
      else if (mcpu_fpu_opt != NULL && ARM_CPU_HAS_FEATURE (*mcpu_fpu_opt, arm_ext_v5))
	mfpu_opt = &fpu_arch_vfp_v2;
      else
	mfpu_opt = &fpu_arch_fpa;
    }

#ifdef CPU_DEFAULT
  if (!mcpu_cpu_opt)
    {
      mcpu_cpu_opt = &cpu_default;
      selected_cpu = cpu_default;
    }
#else
  if (mcpu_cpu_opt)
    selected_cpu = *mcpu_cpu_opt;
  else
    mcpu_cpu_opt = &arm_arch_any;
#endif

  ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);

  autoselect_thumb_from_cpu_variant ();

  arm_arch_used = thumb_arch_used = arm_arch_none;

#if defined OBJ_COFF || defined OBJ_ELF
  {
    unsigned int flags = 0;

#if defined OBJ_ELF
    flags = meabi_flags;

    switch (meabi_flags)
      {
      case EF_ARM_EABI_UNKNOWN:
#endif
	/* Set the flags in the private structure.  */
	if (uses_apcs_26)      flags |= F_APCS26;
	if (support_interwork) flags |= F_INTERWORK;
	if (uses_apcs_float)   flags |= F_APCS_FLOAT;
	if (pic_code)	       flags |= F_PIC;
	if (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_any_hard))
	  flags |= F_SOFT_FLOAT;

	switch (mfloat_abi_opt)
	  {
	  case ARM_FLOAT_ABI_SOFT:
	  case ARM_FLOAT_ABI_SOFTFP:
	    flags |= F_SOFT_FLOAT;
	    break;

	  case ARM_FLOAT_ABI_HARD:
	    if (flags & F_SOFT_FLOAT)
	      as_bad (_("hard-float conflicts with specified fpu"));
	    break;
	  }

	/* Using pure-endian doubles (even if soft-float).	*/
	if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_endian_pure))
	  flags |= F_VFP_FLOAT;

#if defined OBJ_ELF
	if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_arch_maverick))
	    flags |= EF_ARM_MAVERICK_FLOAT;
	break;

      case EF_ARM_EABI_VER4:
      case EF_ARM_EABI_VER5:
	/* No additional flags to set.	*/
	break;

      default:
	abort ();
      }
#endif
    bfd_set_private_flags (stdoutput, flags);

    /* We have run out flags in the COFF header to encode the
       status of ATPCS support, so instead we create a dummy,
       empty, debug section called .arm.atpcs.	*/
    if (atpcs)
      {
	asection * sec;

	sec = bfd_make_section (stdoutput, ".arm.atpcs");

	if (sec != NULL)
	  {
	    bfd_set_section_flags
	      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);
	    bfd_set_section_size (stdoutput, sec, 0);
	    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);
	  }
      }
  }
#endif

  /* Record the CPU type as well.  */
  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2))
    mach = bfd_mach_arm_iWMMXt2;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt))
    mach = bfd_mach_arm_iWMMXt;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_xscale))
    mach = bfd_mach_arm_XScale;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_maverick))
    mach = bfd_mach_arm_ep9312;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v5e))
    mach = bfd_mach_arm_5TE;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v5))
    {
      if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v4t))
	mach = bfd_mach_arm_5T;
      else
	mach = bfd_mach_arm_5;
    }
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v4))
    {
      if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v4t))
	mach = bfd_mach_arm_4T;
      else
	mach = bfd_mach_arm_4;
    }
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v3m))
    mach = bfd_mach_arm_3M;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v3))
    mach = bfd_mach_arm_3;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v2s))
    mach = bfd_mach_arm_2a;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v2))
    mach = bfd_mach_arm_2;
  else
    mach = bfd_mach_arm_unknown;

  bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
}

/* Command line processing.  */

/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.

      This routine is somewhat complicated by the need for backwards
      compatibility (since older releases of gcc can't be changed).
      The new options try to make the interface as compatible as
      possible with GCC.

      New options (supported) are:

	      -mcpu=<cpu name>		 Assemble for selected processor
	      -march=<architecture name> Assemble for selected architecture
	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
	      -EB/-mbig-endian		 Big-endian
	      -EL/-mlittle-endian	 Little-endian
	      -k			 Generate PIC code
	      -mthumb			 Start in Thumb mode
	      -mthumb-interwork		 Code supports ARM/Thumb interworking

	      -m[no-]warn-deprecated     Warn about deprecated features

      For now we will also provide support for:

	      -mapcs-32			 32-bit Program counter
	      -mapcs-26			 26-bit Program counter
	      -macps-float		 Floats passed in FP registers
	      -mapcs-reentrant		 Reentrant code
	      -matpcs
      (sometime these will probably be replaced with -mapcs=<list of options>
      and -matpcs=<list of options>)

      The remaining options are only supported for back-wards compatibility.
      Cpu variants, the arm part is optional:
	      -m[arm]1		      Currently not supported.
	      -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
	      -m[arm]3		      Arm 3 processor
	      -m[arm]6[xx],	      Arm 6 processors
	      -m[arm]7[xx][t][[d]m]   Arm 7 processors
	      -m[arm]8[10]	      Arm 8 processors
	      -m[arm]9[20][tdmi]      Arm 9 processors
	      -mstrongarm[110[0]]     StrongARM processors
	      -mxscale		      XScale processors
	      -m[arm]v[2345[t[e]]]    Arm architectures
	      -mall		      All (except the ARM1)
      FP variants:
	      -mfpa10, -mfpa11	      FPA10 and 11 co-processor instructions
	      -mfpe-old		      (No float load/store multiples)
	      -mvfpxd		      VFP Single precision
	      -mvfp		      All VFP
	      -mno-fpu		      Disable all floating point instructions

      The following CPU names are recognized:
	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.

      */

const char * md_shortopts = "m:k";

#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#define OPTION_EL (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#else
#define OPTION_EL (OPTION_MD_BASE + 1)
#endif
#endif
#define OPTION_FIX_V4BX (OPTION_MD_BASE + 2)

struct option md_longopts[] =
{
#ifdef OPTION_EB
  {"EB", no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL", no_argument, NULL, OPTION_EL},
#endif
  {"fix-v4bx", no_argument, NULL, OPTION_FIX_V4BX},
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

struct arm_option_table
{
  char *option;		/* Option name to match.  */
  char *help;		/* Help information.  */
  int  *var;		/* Variable to change.	*/
  int	value;		/* What to change it to.  */
  char *deprecated;	/* If non-null, print this message.  */
};

struct arm_option_table arm_opts[] =
{
  {"k",	     N_("generate PIC code"),	   &pic_code,	 1, NULL},
  {"mthumb", N_("assemble Thumb code"),	   &thumb_mode,	 1, NULL},
  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
   &support_interwork, 1, NULL},
  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
   1, NULL},
  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 0,
   NULL},

  /* These are recognized by the assembler, but have no affect on code.	 */
  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},

  {"mwarn-deprecated", NULL, &warn_on_deprecated, 1, NULL},
  {"mno-warn-deprecated", N_("do not warn on use of deprecated feature"),
   &warn_on_deprecated, 0, NULL},
  {NULL, NULL, NULL, 0, NULL}
};

struct arm_legacy_option_table
{
  char *option;				/* Option name to match.  */
  const arm_feature_set	**var;		/* Variable to change.	*/
  const arm_feature_set	value;		/* What to change it to.  */
  char *deprecated;			/* If non-null, print this message.  */
};

const struct arm_legacy_option_table arm_legacy_opts[] =
{
  /* DON'T add any new processors to this list -- we want the whole list
     to go away...  Add them to the processors table instead.  */
  {"marm1",	 &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm110")},
  {"mstrongarm1100", &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1100")},
  {"mstrongarm1110", &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1110")},
  {"mxscale",	 &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 &legacy_cpu, ARM_ANY,	       N_("use -mcpu=all")},

  /* Architecture variants -- don't add any more to this list either.  */
  {"mv2",	 &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},

  /* Floating point variants -- don't add any more to this list either.	 */
  {"mfpe-old", &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  &legacy_fpu, ARM_ARCH_NONE,
   N_("use either -mfpu=softfpa or -mfpu=softvfp")},

  {NULL, NULL, ARM_ARCH_NONE, NULL}
};

struct arm_cpu_option_table
{
  char *name;
  size_t name_len;
  const arm_feature_set	value;
  /* For some CPUs we assume an FPU unless the user explicitly sets
     -mfpu=...	*/
  const arm_feature_set	default_fpu;
  /* The canonical name of the CPU, or NULL to use NAME converted to upper
     case.  */
  const char *canonical_name;
};

/* This list should, at a minimum, contain all the cpu names
   recognized by GCC.  */
#define ARM_CPU_OPT(N, V, DF, CN) { N, sizeof (N) - 1, V, DF, CN }
static const struct arm_cpu_option_table arm_cpus[] =
{
  ARM_CPU_OPT ("all",		ARM_ANY,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm250",	ARM_ARCH_V2S,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm600",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm610",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm620",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7dm",	ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7di",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7dmi",	ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm700",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm700i",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm710",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm710t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm720",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm720t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm740t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm710c",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7100",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7500",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7500fe",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7tdmi",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm7tdmi-s",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm810",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("strongarm",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm920",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    "ARM920T"),
  ARM_CPU_OPT ("arm920t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm922t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm940t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
  ARM_CPU_OPT ("arm9tdmi",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,	  NULL),
  ARM_CPU_OPT ("fa526",		ARM_ARCH_V4,	 FPU_ARCH_FPA,	  NULL),
  ARM_CPU_OPT ("fa626",		ARM_ARCH_V4,	 FPU_ARCH_FPA,	  NULL),
  /* For V5 or later processors we default to using VFP; but the user
     should really set the FPU type explicitly.	 */
  ARM_CPU_OPT ("arm9e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm9e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm926ej",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, "ARM926EJ-S"),
  ARM_CPU_OPT ("arm926ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, "ARM926EJ-S"),
  ARM_CPU_OPT ("arm926ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm946e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM946E-S"),
  ARM_CPU_OPT ("arm946e-s",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm966e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM966E-S"),
  ARM_CPU_OPT ("arm966e-s",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm968e-s",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm10t",	ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL),
  ARM_CPU_OPT ("arm10tdmi",	ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL),
  ARM_CPU_OPT ("arm10e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm1020",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM1020E"),
  ARM_CPU_OPT ("arm1020t",	ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL),
  ARM_CPU_OPT ("arm1020e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm1022e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm1026ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2,
								 "ARM1026EJ-S"),
  ARM_CPU_OPT ("arm1026ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("fa606te",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("fa616te",	ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("fa626te",	ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("fmp626",	ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("fa726te",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm1136js",	ARM_ARCH_V6,	 FPU_NONE,	  "ARM1136J-S"),
  ARM_CPU_OPT ("arm1136j-s",	ARM_ARCH_V6,	 FPU_NONE,	  NULL),
  ARM_CPU_OPT ("arm1136jfs",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2,
								 "ARM1136JF-S"),
  ARM_CPU_OPT ("arm1136jf-s",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("mpcore",	ARM_ARCH_V6K,	 FPU_ARCH_VFP_V2, "MPCore"),
  ARM_CPU_OPT ("mpcorenovfp",	ARM_ARCH_V6K,	 FPU_NONE,	  "MPCore"),
  ARM_CPU_OPT ("arm1156t2-s",	ARM_ARCH_V6T2,	 FPU_NONE,	  NULL),
  ARM_CPU_OPT ("arm1156t2f-s",	ARM_ARCH_V6T2,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("arm1176jz-s",	ARM_ARCH_V6ZK,	 FPU_NONE,	  NULL),
  ARM_CPU_OPT ("arm1176jzf-s",	ARM_ARCH_V6ZK,	 FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("cortex-a5",	ARM_ARCH_V7A_MP_SEC,
						 FPU_NONE,	  "Cortex-A5"),
  ARM_CPU_OPT ("cortex-a7",	ARM_ARCH_V7A_IDIV_MP_SEC_VIRT,
						 FPU_ARCH_NEON_VFP_V4,
								  "Cortex-A7"),
  ARM_CPU_OPT ("cortex-a8",	ARM_ARCH_V7A_SEC,
						 ARM_FEATURE (0, FPU_VFP_V3
							| FPU_NEON_EXT_V1),
								  "Cortex-A8"),
  ARM_CPU_OPT ("cortex-a9",	ARM_ARCH_V7A_MP_SEC,
						 ARM_FEATURE (0, FPU_VFP_V3
							| FPU_NEON_EXT_V1),
								  "Cortex-A9"),
  ARM_CPU_OPT ("cortex-a12",	ARM_ARCH_V7A_IDIV_MP_SEC_VIRT,
						 FPU_ARCH_NEON_VFP_V4,
								  "Cortex-A12"),
  ARM_CPU_OPT ("cortex-a15",	ARM_ARCH_V7A_IDIV_MP_SEC_VIRT,
						 FPU_ARCH_NEON_VFP_V4,
								  "Cortex-A15"),
  ARM_CPU_OPT ("cortex-a53",    ARM_ARCH_V8A,    FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
								  "Cortex-A53"),
  ARM_CPU_OPT ("cortex-a57",    ARM_ARCH_V8A,    FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
								  "Cortex-A57"),
  ARM_CPU_OPT ("cortex-r4",	ARM_ARCH_V7R,	 FPU_NONE,	  "Cortex-R4"),
  ARM_CPU_OPT ("cortex-r4f",	ARM_ARCH_V7R,	 FPU_ARCH_VFP_V3D16,
								  "Cortex-R4F"),
  ARM_CPU_OPT ("cortex-r5",	ARM_ARCH_V7R_IDIV,
						 FPU_NONE,	  "Cortex-R5"),
  ARM_CPU_OPT ("cortex-r7",	ARM_ARCH_V7R_IDIV,
						 FPU_ARCH_VFP_V3D16,
								  "Cortex-R7"),
  ARM_CPU_OPT ("cortex-m4",	ARM_ARCH_V7EM,	 FPU_NONE,	  "Cortex-M4"),
  ARM_CPU_OPT ("cortex-m3",	ARM_ARCH_V7M,	 FPU_NONE,	  "Cortex-M3"),
  ARM_CPU_OPT ("cortex-m1",	ARM_ARCH_V6SM,	 FPU_NONE,	  "Cortex-M1"),
  ARM_CPU_OPT ("cortex-m0",	ARM_ARCH_V6SM,	 FPU_NONE,	  "Cortex-M0"),
  ARM_CPU_OPT ("cortex-m0plus",	ARM_ARCH_V6SM,	 FPU_NONE,	  "Cortex-M0+"),
  /* ??? XSCALE is really an architecture.  */
  ARM_CPU_OPT ("xscale",	ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2, NULL),
  /* ??? iwmmxt is not a processor.  */
  ARM_CPU_OPT ("iwmmxt",	ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("iwmmxt2",	ARM_ARCH_IWMMXT2,FPU_ARCH_VFP_V2, NULL),
  ARM_CPU_OPT ("i80200",	ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2, NULL),
  /* Maverick */
  ARM_CPU_OPT ("ep9312",	ARM_FEATURE (ARM_AEXT_V4T, ARM_CEXT_MAVERICK),
						 FPU_ARCH_MAVERICK, "ARM920T"),
  /* Marvell processors.  */
  ARM_CPU_OPT ("marvell-pj4",   ARM_FEATURE (ARM_AEXT_V7A | ARM_EXT_MP | ARM_EXT_SEC, 0),
						FPU_ARCH_VFP_V3D16, NULL),

  { NULL, 0, ARM_ARCH_NONE, ARM_ARCH_NONE, NULL }
};
#undef ARM_CPU_OPT

struct arm_arch_option_table
{
  char *name;
  size_t name_len;
  const arm_feature_set	value;
  const arm_feature_set	default_fpu;
};

/* This list should, at a minimum, contain all the architecture names
   recognized by GCC.  */
#define ARM_ARCH_OPT(N, V, DF) { N, sizeof (N) - 1, V, DF }
static const struct arm_arch_option_table arm_archs[] =
{
  ARM_ARCH_OPT ("all",		ARM_ANY,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv1",	ARM_ARCH_V1,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv2",	ARM_ARCH_V2,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv2a",	ARM_ARCH_V2S,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv2s",	ARM_ARCH_V2S,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv3",	ARM_ARCH_V3,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv3m",	ARM_ARCH_V3M,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv4",	ARM_ARCH_V4,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv4xm",	ARM_ARCH_V4xM,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv4t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv4txm",	ARM_ARCH_V4TxM,	 FPU_ARCH_FPA),
  ARM_ARCH_OPT ("armv5",	ARM_ARCH_V5,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv5t",	ARM_ARCH_V5T,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv5txm",	ARM_ARCH_V5TxM,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv5te",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv5texp",	ARM_ARCH_V5TExP, FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv5tej",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6",	ARM_ARCH_V6,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6j",	ARM_ARCH_V6,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6k",	ARM_ARCH_V6K,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6z",	ARM_ARCH_V6Z,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6zk",	ARM_ARCH_V6ZK,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6t2",	ARM_ARCH_V6T2,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6kt2",	ARM_ARCH_V6KT2,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6zt2",	ARM_ARCH_V6ZT2,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6zkt2",	ARM_ARCH_V6ZKT2, FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6-m",	ARM_ARCH_V6M,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv6s-m",	ARM_ARCH_V6SM,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv7",	ARM_ARCH_V7,	 FPU_ARCH_VFP),
  /* The official spelling of the ARMv7 profile variants is the dashed form.
     Accept the non-dashed form for compatibility with old toolchains.  */
  ARM_ARCH_OPT ("armv7a",	ARM_ARCH_V7A,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv7r",	ARM_ARCH_V7R,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv7m",	ARM_ARCH_V7M,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv7-a",	ARM_ARCH_V7A,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv7-r",	ARM_ARCH_V7R,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv7-m",	ARM_ARCH_V7M,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv7e-m",	ARM_ARCH_V7EM,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("armv8-a",	ARM_ARCH_V8A,	 FPU_ARCH_VFP),
  ARM_ARCH_OPT ("xscale",	ARM_ARCH_XSCALE, FPU_ARCH_VFP),
  ARM_ARCH_OPT ("iwmmxt",	ARM_ARCH_IWMMXT, FPU_ARCH_VFP),
  ARM_ARCH_OPT ("iwmmxt2",	ARM_ARCH_IWMMXT2,FPU_ARCH_VFP),
  { NULL, 0, ARM_ARCH_NONE, ARM_ARCH_NONE }
};
#undef ARM_ARCH_OPT

/* ISA extensions in the co-processor and main instruction set space.  */
struct arm_option_extension_value_table
{
  char *name;
  size_t name_len;
  const arm_feature_set value;
  const arm_feature_set allowed_archs;
};

/* The following table must be in alphabetical order with a NULL last entry.
   */
#define ARM_EXT_OPT(N, V, AA) { N, sizeof (N) - 1, V, AA }
static const struct arm_option_extension_value_table arm_extensions[] =
{
  ARM_EXT_OPT ("crc",  ARCH_CRC_ARMV8, ARM_FEATURE (ARM_EXT_V8, 0)),
  ARM_EXT_OPT ("crypto", FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
				   ARM_FEATURE (ARM_EXT_V8, 0)),
  ARM_EXT_OPT ("fp",     FPU_ARCH_VFP_ARMV8,
				   ARM_FEATURE (ARM_EXT_V8, 0)),
  ARM_EXT_OPT ("idiv",	ARM_FEATURE (ARM_EXT_ADIV | ARM_EXT_DIV, 0),
				   ARM_FEATURE (ARM_EXT_V7A | ARM_EXT_V7R, 0)),
  ARM_EXT_OPT ("iwmmxt",ARM_FEATURE (0, ARM_CEXT_IWMMXT),	ARM_ANY),
  ARM_EXT_OPT ("iwmmxt2",
			ARM_FEATURE (0, ARM_CEXT_IWMMXT2),	ARM_ANY),
  ARM_EXT_OPT ("maverick",
			ARM_FEATURE (0, ARM_CEXT_MAVERICK),	ARM_ANY),
  ARM_EXT_OPT ("mp",	ARM_FEATURE (ARM_EXT_MP, 0),
				   ARM_FEATURE (ARM_EXT_V7A | ARM_EXT_V7R, 0)),
  ARM_EXT_OPT ("simd",   FPU_ARCH_NEON_VFP_ARMV8,
				   ARM_FEATURE (ARM_EXT_V8, 0)),
  ARM_EXT_OPT ("os",	ARM_FEATURE (ARM_EXT_OS, 0),
				   ARM_FEATURE (ARM_EXT_V6M, 0)),
  ARM_EXT_OPT ("sec",	ARM_FEATURE (ARM_EXT_SEC, 0),
				   ARM_FEATURE (ARM_EXT_V6K | ARM_EXT_V7A, 0)),
  ARM_EXT_OPT ("virt",	ARM_FEATURE (ARM_EXT_VIRT | ARM_EXT_ADIV
				     | ARM_EXT_DIV, 0),
				   ARM_FEATURE (ARM_EXT_V7A, 0)),
  ARM_EXT_OPT ("xscale",ARM_FEATURE (0, ARM_CEXT_XSCALE),	ARM_ANY),
  { NULL, 0, ARM_ARCH_NONE, ARM_ARCH_NONE }
};
#undef ARM_EXT_OPT

/* ISA floating-point and Advanced SIMD extensions.  */
struct arm_option_fpu_value_table
{
  char *name;
  const arm_feature_set value;
};

/* This list should, at a minimum, contain all the fpu names
   recognized by GCC.  */
static const struct arm_option_fpu_value_table arm_fpus[] =
{
  {"softfpa",		FPU_NONE},
  {"fpe",		FPU_ARCH_FPE},
  {"fpe2",		FPU_ARCH_FPE},
  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
  {"fpa",		FPU_ARCH_FPA},
  {"fpa10",		FPU_ARCH_FPA},
  {"fpa11",		FPU_ARCH_FPA},
  {"arm7500fe",		FPU_ARCH_FPA},
  {"softvfp",		FPU_ARCH_VFP},
  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
  {"vfp",		FPU_ARCH_VFP_V2},
  {"vfp9",		FPU_ARCH_VFP_V2},
  {"vfp3",              FPU_ARCH_VFP_V3}, /* For backwards compatbility.  */
  {"vfp10",		FPU_ARCH_VFP_V2},
  {"vfp10-r0",		FPU_ARCH_VFP_V1},
  {"vfpxd",		FPU_ARCH_VFP_V1xD},
  {"vfpv2",		FPU_ARCH_VFP_V2},
  {"vfpv3",		FPU_ARCH_VFP_V3},
  {"vfpv3-fp16",	FPU_ARCH_VFP_V3_FP16},
  {"vfpv3-d16",		FPU_ARCH_VFP_V3D16},
  {"vfpv3-d16-fp16",	FPU_ARCH_VFP_V3D16_FP16},
  {"vfpv3xd",		FPU_ARCH_VFP_V3xD},
  {"vfpv3xd-fp16",	FPU_ARCH_VFP_V3xD_FP16},
  {"arm1020t",		FPU_ARCH_VFP_V1},
  {"arm1020e",		FPU_ARCH_VFP_V2},
  {"arm1136jfs",	FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	FPU_ARCH_VFP_V2},
  {"maverick",		FPU_ARCH_MAVERICK},
  {"neon",              FPU_ARCH_VFP_V3_PLUS_NEON_V1},
  {"neon-fp16",		FPU_ARCH_NEON_FP16},
  {"vfpv4",		FPU_ARCH_VFP_V4},
  {"vfpv4-d16",		FPU_ARCH_VFP_V4D16},
  {"fpv4-sp-d16",	FPU_ARCH_VFP_V4_SP_D16},
  {"neon-vfpv4",	FPU_ARCH_NEON_VFP_V4},
  {"fp-armv8",		FPU_ARCH_VFP_ARMV8},
  {"neon-fp-armv8",	FPU_ARCH_NEON_VFP_ARMV8},
  {"crypto-neon-fp-armv8",
			FPU_ARCH_CRYPTO_NEON_VFP_ARMV8},
  {NULL,		ARM_ARCH_NONE}
};

struct arm_option_value_table
{
  char *name;
  long value;
};

static const struct arm_option_value_table arm_float_abis[] =
{
  {"hard",	ARM_FLOAT_ABI_HARD},
  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
  {"soft",	ARM_FLOAT_ABI_SOFT},
  {NULL,	0}
};

#ifdef OBJ_ELF
/* We only know how to output GNU and ver 4/5 (AAELF) formats.  */
static const struct arm_option_value_table arm_eabis[] =
{
  {"gnu",	EF_ARM_EABI_UNKNOWN},
  {"4",		EF_ARM_EABI_VER4},
  {"5",		EF_ARM_EABI_VER5},
  {NULL,	0}
};
#endif

struct arm_long_option_table
{
  char * option;		/* Substring to match.	*/
  char * help;			/* Help information.  */
  int (* func) (char * subopt);	/* Function to decode sub-option.  */
  char * deprecated;		/* If non-null, print this message.  */
};

static bfd_boolean
arm_parse_extension (char *str, const arm_feature_set **opt_p)
{
  arm_feature_set *ext_set = (arm_feature_set *)
      xmalloc (sizeof (arm_feature_set));

  /* We insist on extensions being specified in alphabetical order, and with
     extensions being added before being removed.  We achieve this by having
     the global ARM_EXTENSIONS table in alphabetical order, and using the
     ADDING_VALUE variable to indicate whether we are adding an extension (1)
     or removing it (0) and only allowing it to change in the order
     -1 -> 1 -> 0.  */
  const struct arm_option_extension_value_table * opt = NULL;
  int adding_value = -1;

  /* Copy the feature set, so that we can modify it.  */
  *ext_set = **opt_p;
  *opt_p = ext_set;

  while (str != NULL && *str != 0)
    {
      char *ext;
      size_t len;

      if (*str != '+')
	{
	  as_bad (_("invalid architectural extension"));
	  return FALSE;
	}

      str++;
      ext = strchr (str, '+');

      if (ext != NULL)
	len = ext - str;
      else
	len = strlen (str);

      if (len >= 2 && strncmp (str, "no", 2) == 0)
	{
	  if (adding_value != 0)
	    {
	      adding_value = 0;
	      opt = arm_extensions;
	    }

	  len -= 2;
	  str += 2;
	}
      else if (len > 0)
	{
	  if (adding_value == -1)
	    {
	      adding_value = 1;
	      opt = arm_extensions;
	    }
	  else if (adding_value != 1)
	    {
	      as_bad (_("must specify extensions to add before specifying "
			"those to remove"));
	      return FALSE;
	    }
	}

      if (len == 0)
	{
	  as_bad (_("missing architectural extension"));
	  return FALSE;
	}

      gas_assert (adding_value != -1);
      gas_assert (opt != NULL);

      /* Scan over the options table trying to find an exact match. */
      for (; opt->name != NULL; opt++)
	if (opt->name_len == len && strncmp (opt->name, str, len) == 0)
	  {
	    /* Check we can apply the extension to this architecture.  */
	    if (!ARM_CPU_HAS_FEATURE (*ext_set, opt->allowed_archs))
	      {
		as_bad (_("extension does not apply to the base architecture"));
		return FALSE;
	      }

	    /* Add or remove the extension.  */
	    if (adding_value)
	      ARM_MERGE_FEATURE_SETS (*ext_set, *ext_set, opt->value);
	    else
	      ARM_CLEAR_FEATURE (*ext_set, *ext_set, opt->value);

	    break;
	  }

      if (opt->name == NULL)
	{
	  /* Did we fail to find an extension because it wasn't specified in
	     alphabetical order, or because it does not exist?  */

	  for (opt = arm_extensions; opt->name != NULL; opt++)
	    if (opt->name_len == len && strncmp (opt->name, str, len) == 0)
	      break;

	  if (opt->name == NULL)
	    as_bad (_("unknown architectural extension `%s'"), str);
	  else
	    as_bad (_("architectural extensions must be specified in "
		      "alphabetical order"));

	  return FALSE;
	}
      else
	{
	  /* We should skip the extension we've just matched the next time
	     round.  */
	  opt++;
	}

      str = ext;
    };

  return TRUE;
}

static bfd_boolean
arm_parse_cpu (char *str)
{
  const struct arm_cpu_option_table *opt;
  char *ext = strchr (str, '+');
  size_t len;

  if (ext != NULL)
    len = ext - str;
  else
    len = strlen (str);

  if (len == 0)
    {
      as_bad (_("missing cpu name `%s'"), str);
      return FALSE;
    }

  for (opt = arm_cpus; opt->name != NULL; opt++)
    if (opt->name_len == len && strncmp (opt->name, str, len) == 0)
      {
	mcpu_cpu_opt = &opt->value;
	mcpu_fpu_opt = &opt->default_fpu;
	if (opt->canonical_name)
	  strcpy (selected_cpu_name, opt->canonical_name);
	else
	  {
	    size_t i;

	    for (i = 0; i < len; i++)
	      selected_cpu_name[i] = TOUPPER (opt->name[i]);
	    selected_cpu_name[i] = 0;
	  }

	if (ext != NULL)
	  return arm_parse_extension (ext, &mcpu_cpu_opt);

	return TRUE;
      }

  as_bad (_("unknown cpu `%s'"), str);
  return FALSE;
}

static bfd_boolean
arm_parse_arch (char *str)
{
  const struct arm_arch_option_table *opt;
  char *ext = strchr (str, '+');
  size_t len;

  if (ext != NULL)
    len = ext - str;
  else
    len = strlen (str);

  if (len == 0)
    {
      as_bad (_("missing architecture name `%s'"), str);
      return FALSE;
    }

  for (opt = arm_archs; opt->name != NULL; opt++)
    if (opt->name_len == len && strncmp (opt->name, str, len) == 0)
      {
	march_cpu_opt = &opt->value;
	march_fpu_opt = &opt->default_fpu;
	strcpy (selected_cpu_name, opt->name);

	if (ext != NULL)
	  return arm_parse_extension (ext, &march_cpu_opt);

	return TRUE;
      }

  as_bad (_("unknown architecture `%s'\n"), str);
  return FALSE;
}

static bfd_boolean
arm_parse_fpu (char * str)
{
  const struct arm_option_fpu_value_table * opt;

  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfpu_opt = &opt->value;
	return TRUE;
      }

  as_bad (_("unknown floating point format `%s'\n"), str);
  return FALSE;
}

static bfd_boolean
arm_parse_float_abi (char * str)
{
  const struct arm_option_value_table * opt;

  for (opt = arm_float_abis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfloat_abi_opt = opt->value;
	return TRUE;
      }

  as_bad (_("unknown floating point abi `%s'\n"), str);
  return FALSE;
}

#ifdef OBJ_ELF
static bfd_boolean
arm_parse_eabi (char * str)
{
  const struct arm_option_value_table *opt;

  for (opt = arm_eabis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	meabi_flags = opt->value;
	return TRUE;
      }
  as_bad (_("unknown EABI `%s'\n"), str);
  return FALSE;
}
#endif

static bfd_boolean
arm_parse_it_mode (char * str)
{
  bfd_boolean ret = TRUE;

  if (streq ("arm", str))
    implicit_it_mode = IMPLICIT_IT_MODE_ARM;
  else if (streq ("thumb", str))
    implicit_it_mode = IMPLICIT_IT_MODE_THUMB;
  else if (streq ("always", str))
    implicit_it_mode = IMPLICIT_IT_MODE_ALWAYS;
  else if (streq ("never", str))
    implicit_it_mode = IMPLICIT_IT_MODE_NEVER;
  else
    {
      as_bad (_("unknown implicit IT mode `%s', should be "\
		"arm, thumb, always, or never."), str);
      ret = FALSE;
    }

  return ret;
}

struct arm_long_option_table arm_long_opts[] =
{
  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
   arm_parse_cpu, NULL},
  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
   arm_parse_arch, NULL},
  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
   arm_parse_fpu, NULL},
  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
   arm_parse_float_abi, NULL},
#ifdef OBJ_ELF
  {"meabi=", N_("<ver>\t\t  assemble for eabi version <ver>"),
   arm_parse_eabi, NULL},
#endif
  {"mimplicit-it=", N_("<mode>\t  controls implicit insertion of IT instructions"),
   arm_parse_it_mode, NULL},
  {NULL, NULL, 0, NULL}
};

int
md_parse_option (int c, char * arg)
{
  struct arm_option_table *opt;
  const struct arm_legacy_option_table *fopt;
  struct arm_long_option_table *lopt;

  switch (c)
    {
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif

#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif

    case OPTION_FIX_V4BX:
      fix_v4bx = TRUE;
      break;

    case 'a':
      /* Listing option.  Just ignore these, we don't support additional
	 ones.	*/
      return 0;

    default:
      for (opt = arm_opts; opt->option != NULL; opt++)
	{
	  if (c == opt->option[0]
	      && ((arg == NULL && opt->option[1] == 0)
		  || streq (arg, opt->option + 1)))
	    {
	      /* If the option is deprecated, tell the user.  */
	      if (warn_on_deprecated && opt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(opt->deprecated));

	      if (opt->var != NULL)
		*opt->var = opt->value;

	      return 1;
	    }
	}

      for (fopt = arm_legacy_opts; fopt->option != NULL; fopt++)
	{
	  if (c == fopt->option[0]
	      && ((arg == NULL && fopt->option[1] == 0)
		  || streq (arg, fopt->option + 1)))
	    {
	      /* If the option is deprecated, tell the user.  */
	      if (warn_on_deprecated && fopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(fopt->deprecated));

	      if (fopt->var != NULL)
		*fopt->var = &fopt->value;

	      return 1;
	    }
	}

      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
	{
	  /* These options are expected to have an argument.  */
	  if (c == lopt->option[0]
	      && arg != NULL
	      && strncmp (arg, lopt->option + 1,
			  strlen (lopt->option + 1)) == 0)
	    {
	      /* If the option is deprecated, tell the user.  */
	      if (warn_on_deprecated && lopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
			   _(lopt->deprecated));

	      /* Call the sup-option parser.  */
	      return lopt->func (arg + strlen (lopt->option) - 1);
	    }
	}

      return 0;
    }

  return 1;
}

void
md_show_usage (FILE * fp)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  fprintf (fp, _(" ARM-specific assembler options:\n"));

  for (opt = arm_opts; opt->option != NULL; opt++)
    if (opt->help != NULL)
      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));

  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
    if (lopt->help != NULL)
      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));

#ifdef OPTION_EB
  fprintf (fp, _("\
  -EB                     assemble code for a big-endian cpu\n"));
#endif

#ifdef OPTION_EL
  fprintf (fp, _("\
  -EL                     assemble code for a little-endian cpu\n"));
#endif

  fprintf (fp, _("\
  --fix-v4bx              Allow BX in ARMv4 code\n"));
}


#ifdef OBJ_ELF
typedef struct
{
  int val;
  arm_feature_set flags;
} cpu_arch_ver_table;

/* Mapping from CPU features to EABI CPU arch values.  Table must be sorted
   least features first.  */
static const cpu_arch_ver_table cpu_arch_ver[] =
{
    {1, ARM_ARCH_V4},
    {2, ARM_ARCH_V4T},
    {3, ARM_ARCH_V5},
    {3, ARM_ARCH_V5T},
    {4, ARM_ARCH_V5TE},
    {5, ARM_ARCH_V5TEJ},
    {6, ARM_ARCH_V6},
    {9, ARM_ARCH_V6K},
    {7, ARM_ARCH_V6Z},
    {11, ARM_ARCH_V6M},
    {12, ARM_ARCH_V6SM},
    {8, ARM_ARCH_V6T2},
    {10, ARM_ARCH_V7A_IDIV_MP_SEC_VIRT},
    {10, ARM_ARCH_V7R},
    {10, ARM_ARCH_V7M},
    {14, ARM_ARCH_V8A},
    {0, ARM_ARCH_NONE}
};

/* Set an attribute if it has not already been set by the user.  */
static void
aeabi_set_attribute_int (int tag, int value)
{
  if (tag < 1
      || tag >= NUM_KNOWN_OBJ_ATTRIBUTES
      || !attributes_set_explicitly[tag])
    bfd_elf_add_proc_attr_int (stdoutput, tag, value);
}

static void
aeabi_set_attribute_string (int tag, const char *value)
{
  if (tag < 1
      || tag >= NUM_KNOWN_OBJ_ATTRIBUTES
      || !attributes_set_explicitly[tag])
    bfd_elf_add_proc_attr_string (stdoutput, tag, value);
}

/* Set the public EABI object attributes.  */
static void
aeabi_set_public_attributes (void)
{
  int arch;
  char profile;
  int virt_sec = 0;
  int fp16_optional = 0;
  arm_feature_set flags;
  arm_feature_set tmp;
  const cpu_arch_ver_table *p;

  /* Choose the architecture based on the capabilities of the requested cpu
     (if any) and/or the instructions actually used.  */
  ARM_MERGE_FEATURE_SETS (flags, arm_arch_used, thumb_arch_used);
  ARM_MERGE_FEATURE_SETS (flags, flags, *mfpu_opt);
  ARM_MERGE_FEATURE_SETS (flags, flags, selected_cpu);

  if (ARM_CPU_HAS_FEATURE (arm_arch_used, arm_arch_any))
    ARM_MERGE_FEATURE_SETS (flags, flags, arm_ext_v1);

  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, arm_arch_any))
    ARM_MERGE_FEATURE_SETS (flags, flags, arm_ext_v4t);

  /* Allow the user to override the reported architecture.  */
  if (object_arch)
    {
      ARM_CLEAR_FEATURE (flags, flags, arm_arch_any);
      ARM_MERGE_FEATURE_SETS (flags, flags, *object_arch);
    }

  /* We need to make sure that the attributes do not identify us as v6S-M
     when the only v6S-M feature in use is the Operating System Extensions.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_os))
      if (!ARM_CPU_HAS_FEATURE (flags, arm_arch_v6m_only))
	ARM_CLEAR_FEATURE (flags, flags, arm_ext_os);

  tmp = flags;
  arch = 0;
  for (p = cpu_arch_ver; p->val; p++)
    {
      if (ARM_CPU_HAS_FEATURE (tmp, p->flags))
	{
	  arch = p->val;
	  ARM_CLEAR_FEATURE (tmp, tmp, p->flags);
	}
    }

  /* The table lookup above finds the last architecture to contribute
     a new feature.  Unfortunately, Tag13 is a subset of the union of
     v6T2 and v7-M, so it is never seen as contributing a new feature.
     We can not search for the last entry which is entirely used,
     because if no CPU is specified we build up only those flags
     actually used.  Perhaps we should separate out the specified
     and implicit cases.  Avoid taking this path for -march=all by
     checking for contradictory v7-A / v7-M features.  */
  if (arch == 10
      && !ARM_CPU_HAS_FEATURE (flags, arm_ext_v7a)
      && ARM_CPU_HAS_FEATURE (flags, arm_ext_v7m)
      && ARM_CPU_HAS_FEATURE (flags, arm_ext_v6_dsp))
    arch = 13;

  /* Tag_CPU_name.  */
  if (selected_cpu_name[0])
    {
      char *q;

      q = selected_cpu_name;
      if (strncmp (q, "armv", 4) == 0)
	{
	  int i;

	  q += 4;
	  for (i = 0; q[i]; i++)
	    q[i] = TOUPPER (q[i]);
	}
      aeabi_set_attribute_string (Tag_CPU_name, q);
    }

  /* Tag_CPU_arch.  */
  aeabi_set_attribute_int (Tag_CPU_arch, arch);

  /* Tag_CPU_arch_profile.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v7a))
    profile = 'A';
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v7r))
    profile = 'R';
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_m))
    profile = 'M';
  else
    profile = '\0';

  if (profile != '\0')
    aeabi_set_attribute_int (Tag_CPU_arch_profile, profile);

  /* Tag_ARM_ISA_use.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v1)
      || arch == 0)
    aeabi_set_attribute_int (Tag_ARM_ISA_use, 1);

  /* Tag_THUMB_ISA_use.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v4t)
      || arch == 0)
    aeabi_set_attribute_int (Tag_THUMB_ISA_use,
	ARM_CPU_HAS_FEATURE (flags, arm_arch_t2) ? 2 : 1);

  /* Tag_VFP_arch.  */
  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_armv8))
    aeabi_set_attribute_int (Tag_VFP_arch, 7);
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_fma))
    aeabi_set_attribute_int (Tag_VFP_arch,
			     ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_d32)
			     ? 5 : 6);
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_d32))
    {
      fp16_optional = 1;
      aeabi_set_attribute_int (Tag_VFP_arch, 3);
    }
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v3xd))
    {
      aeabi_set_attribute_int (Tag_VFP_arch, 4);
      fp16_optional = 1;
    }
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v2))
    aeabi_set_attribute_int (Tag_VFP_arch, 2);
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1)
	   || ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1xd))
    aeabi_set_attribute_int (Tag_VFP_arch, 1);

  /* Tag_ABI_HardFP_use.  */
  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1xd)
      && !ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1))
    aeabi_set_attribute_int (Tag_ABI_HardFP_use, 1);

  /* Tag_WMMX_arch.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_cext_iwmmxt2))
    aeabi_set_attribute_int (Tag_WMMX_arch, 2);
  else if (ARM_CPU_HAS_FEATURE (flags, arm_cext_iwmmxt))
    aeabi_set_attribute_int (Tag_WMMX_arch, 1);

  /* Tag_Advanced_SIMD_arch (formerly Tag_NEON_arch).  */
  if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_armv8))
    aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 3);
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_v1))
    {
      if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_fma))
	{
	  aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 2);
	}
      else
	{
	  aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 1);
	  fp16_optional = 1;
	}
    }

  /* Tag_VFP_HP_extension (formerly Tag_NEON_FP16_arch).  */
  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_fp16) && fp16_optional)
    aeabi_set_attribute_int (Tag_VFP_HP_extension, 1);

  /* Tag_DIV_use.

     We set Tag_DIV_use to two when integer divide instructions have been used
     in ARM state, or when Thumb integer divide instructions have been used,
     but we have no architecture profile set, nor have we any ARM instructions.

     For ARMv8 we set the tag to 0 as integer divide is implied by the base
     architecture.

     For new architectures we will have to check these tests.  */
  gas_assert (arch <= TAG_CPU_ARCH_V8);
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v8))
    aeabi_set_attribute_int (Tag_DIV_use, 0);
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_adiv)
	   || (profile == '\0'
	       && ARM_CPU_HAS_FEATURE (flags, arm_ext_div)
	       && !ARM_CPU_HAS_FEATURE (arm_arch_used, arm_arch_any)))
    aeabi_set_attribute_int (Tag_DIV_use, 2);

  /* Tag_MP_extension_use.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_mp))
    aeabi_set_attribute_int (Tag_MPextension_use, 1);

  /* Tag Virtualization_use.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_sec))
    virt_sec |= 1;
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_virt))
    virt_sec |= 2;
  if (virt_sec != 0)
    aeabi_set_attribute_int (Tag_Virtualization_use, virt_sec);
}

/* Add the default contents for the .ARM.attributes section.  */
void
arm_md_end (void)
{
  if (EF_ARM_EABI_VERSION (meabi_flags) < EF_ARM_EABI_VER4)
    return;

  aeabi_set_public_attributes ();
}
#endif /* OBJ_ELF */


/* Parse a .cpu directive.  */

static void
s_arm_cpu (int ignored ATTRIBUTE_UNUSED)
{
  const struct arm_cpu_option_table *opt;
  char *name;
  char saved_char;

  name = input_line_pointer;
  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
    input_line_pointer++;
  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  /* Skip the first "all" entry.  */
  for (opt = arm_cpus + 1; opt->name != NULL; opt++)
    if (streq (opt->name, name))
      {
	mcpu_cpu_opt = &opt->value;
	selected_cpu = opt->value;
	if (opt->canonical_name)
	  strcpy (selected_cpu_name, opt->canonical_name);
	else
	  {
	    int i;
	    for (i = 0; opt->name[i]; i++)
	      selected_cpu_name[i] = TOUPPER (opt->name[i]);

	    selected_cpu_name[i] = 0;
	  }
	ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
	*input_line_pointer = saved_char;
	demand_empty_rest_of_line ();
	return;
      }
  as_bad (_("unknown cpu `%s'"), name);
  *input_line_pointer = saved_char;
  ignore_rest_of_line ();
}


/* Parse a .arch directive.  */

static void
s_arm_arch (int ignored ATTRIBUTE_UNUSED)
{
  const struct arm_arch_option_table *opt;
  char saved_char;
  char *name;

  name = input_line_pointer;
  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
    input_line_pointer++;
  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  /* Skip the first "all" entry.  */
  for (opt = arm_archs + 1; opt->name != NULL; opt++)
    if (streq (opt->name, name))
      {
	mcpu_cpu_opt = &opt->value;
	selected_cpu = opt->value;
	strcpy (selected_cpu_name, opt->name);
	ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
	*input_line_pointer = saved_char;
	demand_empty_rest_of_line ();
	return;
      }

  as_bad (_("unknown architecture `%s'\n"), name);
  *input_line_pointer = saved_char;
  ignore_rest_of_line ();
}


/* Parse a .object_arch directive.  */

static void
s_arm_object_arch (int ignored ATTRIBUTE_UNUSED)
{
  const struct arm_arch_option_table *opt;
  char saved_char;
  char *name;

  name = input_line_pointer;
  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
    input_line_pointer++;
  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  /* Skip the first "all" entry.  */
  for (opt = arm_archs + 1; opt->name != NULL; opt++)
    if (streq (opt->name, name))
      {
	object_arch = &opt->value;
	*input_line_pointer = saved_char;
	demand_empty_rest_of_line ();
	return;
      }

  as_bad (_("unknown architecture `%s'\n"), name);
  *input_line_pointer = saved_char;
  ignore_rest_of_line ();
}

/* Parse a .arch_extension directive.  */

static void
s_arm_arch_extension (int ignored ATTRIBUTE_UNUSED)
{
  const struct arm_option_extension_value_table *opt;
  char saved_char;
  char *name;
  int adding_value = 1;

  name = input_line_pointer;
  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
    input_line_pointer++;
  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  if (strlen (name) >= 2
      && strncmp (name, "no", 2) == 0)
    {
      adding_value = 0;
      name += 2;
    }

  for (opt = arm_extensions; opt->name != NULL; opt++)
    if (streq (opt->name, name))
      {
	if (!ARM_CPU_HAS_FEATURE (*mcpu_cpu_opt, opt->allowed_archs))
	  {
	    as_bad (_("architectural extension `%s' is not allowed for the "
		      "current base architecture"), name);
	    break;
	  }

	if (adding_value)
	  ARM_MERGE_FEATURE_SETS (selected_cpu, selected_cpu, opt->value);
	else
	  ARM_CLEAR_FEATURE (selected_cpu, selected_cpu, opt->value);

	mcpu_cpu_opt = &selected_cpu;
	ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
	*input_line_pointer = saved_char;
	demand_empty_rest_of_line ();
	return;
      }

  if (opt->name == NULL)
    as_bad (_("unknown architecture extension `%s'\n"), name);

  *input_line_pointer = saved_char;
  ignore_rest_of_line ();
}

/* Parse a .fpu directive.  */

static void
s_arm_fpu (int ignored ATTRIBUTE_UNUSED)
{
  const struct arm_option_fpu_value_table *opt;
  char saved_char;
  char *name;

  name = input_line_pointer;
  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
    input_line_pointer++;
  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (streq (opt->name, name))
      {
	mfpu_opt = &opt->value;
	ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
	*input_line_pointer = saved_char;
	demand_empty_rest_of_line ();
	return;
      }

  as_bad (_("unknown floating point format `%s'\n"), name);
  *input_line_pointer = saved_char;
  ignore_rest_of_line ();
}

/* Copy symbol information.  */

void
arm_copy_symbol_attributes (symbolS *dest, symbolS *src)
{
  ARM_GET_FLAG (dest) = ARM_GET_FLAG (src);
}

#ifdef OBJ_ELF
/* Given a symbolic attribute NAME, return the proper integer value.
   Returns -1 if the attribute is not known.  */

int
arm_convert_symbolic_attribute (const char *name)
{
  static const struct
  {
    const char * name;
    const int    tag;
  }
  attribute_table[] =
    {
      /* When you modify this table you should
	 also modify the list in doc/c-arm.texi.  */
#define T(tag) {#tag, tag}
      T (Tag_CPU_raw_name),
      T (Tag_CPU_name),
      T (Tag_CPU_arch),
      T (Tag_CPU_arch_profile),
      T (Tag_ARM_ISA_use),
      T (Tag_THUMB_ISA_use),
      T (Tag_FP_arch),
      T (Tag_VFP_arch),
      T (Tag_WMMX_arch),
      T (Tag_Advanced_SIMD_arch),
      T (Tag_PCS_config),
      T (Tag_ABI_PCS_R9_use),
      T (Tag_ABI_PCS_RW_data),
      T (Tag_ABI_PCS_RO_data),
      T (Tag_ABI_PCS_GOT_use),
      T (Tag_ABI_PCS_wchar_t),
      T (Tag_ABI_FP_rounding),
      T (Tag_ABI_FP_denormal),
      T (Tag_ABI_FP_exceptions),
      T (Tag_ABI_FP_user_exceptions),
      T (Tag_ABI_FP_number_model),
      T (Tag_ABI_align_needed),
      T (Tag_ABI_align8_needed),
      T (Tag_ABI_align_preserved),
      T (Tag_ABI_align8_preserved),
      T (Tag_ABI_enum_size),
      T (Tag_ABI_HardFP_use),
      T (Tag_ABI_VFP_args),
      T (Tag_ABI_WMMX_args),
      T (Tag_ABI_optimization_goals),
      T (Tag_ABI_FP_optimization_goals),
      T (Tag_compatibility),
      T (Tag_CPU_unaligned_access),
      T (Tag_FP_HP_extension),
      T (Tag_VFP_HP_extension),
      T (Tag_ABI_FP_16bit_format),
      T (Tag_MPextension_use),
      T (Tag_DIV_use),
      T (Tag_nodefaults),
      T (Tag_also_compatible_with),
      T (Tag_conformance),
      T (Tag_T2EE_use),
      T (Tag_Virtualization_use),
      /* We deliberately do not include Tag_MPextension_use_legacy.  */
#undef T
    };
  unsigned int i;

  if (name == NULL)
    return -1;

  for (i = 0; i < ARRAY_SIZE (attribute_table); i++)
    if (streq (name, attribute_table[i].name))
      return attribute_table[i].tag;

  return -1;
}


/* Apply sym value for relocations only in the case that
   they are for local symbols and you have the respective
   architectural feature for blx and simple switches.  */
int
arm_apply_sym_value (struct fix * fixP)
{
  if (fixP->fx_addsy
      && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t)
      && !S_FORCE_RELOC (fixP->fx_addsy, TRUE))
    {
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_ARM_PCREL_BLX:
	case BFD_RELOC_THUMB_PCREL_BRANCH23:
	  if (ARM_IS_FUNC (fixP->fx_addsy))
	    return 1;
	  break;

	case BFD_RELOC_ARM_PCREL_CALL:
	case BFD_RELOC_THUMB_PCREL_BLX:
	  if (THUMB_IS_FUNC (fixP->fx_addsy))
	      return 1;
	  break;

	default:
	  break;
	}

    }
  return 0;
}
#endif /* OBJ_ELF */
@


1.579
log
@[gas/]
2013-10-04  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* config/tc-arm.c (do_t_mvn_tst): Use narrow form for tst when
	possible.


[gas/testsuite/]
2013-10-04  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* gas/arm/thumb2_it.s: Add test for narrow tst.
	* gas/arm/thumb2_it.d: Update expected output.
	* gas/arm/thumb2_it_auto.d: Likewise.
@
text
@d11675 1
a11675 1
  if ((mask & ~0xff) == 0)
d11677 3
a11679 4
  else if ((inst.instruction == T_MNEM_push
	    && (mask & ~0xff) == 1 << REG_LR)
	   || (inst.instruction == T_MNEM_pop
	       && (mask & ~0xff) == 1 << REG_PC))
@


1.578
log
@gas/config/tc-arm.c: Fix parsing of NEON load/store element sizes.

The existing code would accept VLD2.64 and similar undefined
instructions.

gas/ChangeLog:

2013-09-16  Will Newton  <will.newton@@linaro.org>

	* config/tc-arm.c (do_neon_ld_st_interleave): Add constraint
	disallowing element size 64 with interleave other than 1.

gas/testsuite/ChangeLog:

2013-09-16  Will Newton  <will.newton@@linaro.org>

	* gas/arm/neon-ldst-es.d: Add VLD1.64 instructions.
	* gas/arm/neon-ldst-es.s: Likewise.
	* testsuite/gas/arm/neon-ldst-es-bad.d: New file.
	* testsuite/gas/arm/neon-ldst-es-bad.l: Likewise.
	* testsuite/gas/arm/neon-ldst-es-bad.s: Likewise.
@
text
@d11270 2
a11271 1
      else if (inst.instruction == T_MNEM_cmn)
@


1.577
log
@	PR gas/15914

	* config/tc-arm.c (T16_32_TAB): Add _udf.
	(do_t_udf): New function.
	(insns): Add "udf".

	* gas/arm/udf-bad.s: New file.
	* gas/arm/udf-bad.d: New file.
	* gas/arm/udf-bad.l: New file.
	* gas/arm/udf.s: New file.
	* gas/arm/udf.d: New file.
	* gas/arm/udf.l: New file.

	* arm-dis.c (arm_opcodes): Add udf.
	(thumb_opcodes): Use "udf" mnemonic rather than UNDEFINED_INSTRUCTION.
	(thumb32_opcodes): Add udf.w.
	(print_insn_thumb32): Handle %H as the thumb32_opcodes comment says.
@
text
@d15786 2
@


1.576
log
@gas/config/tc-arm.c: Improve validation of NEON addressing modes.

NEON vector load and store instructions do not accept immediates
or pre-indexed base plus offset addressing modes, so make sure that
the assembler enforces this.

gas/ChangeLog:

2013-08-23  Will Newton  <will.newton@@linaro.org>

	* config/tc-arm.c (do_neon_ldx_stx): Add extra constraints
	for pre-indexed addressing modes.
	* testsuite/gas/arm/neon-addressing-bad.l: Add test for
	VLDn and VSTn instructions.
	* testsuite/gas/arm/neon-addressing-bad.s: Likewise.

gas/testsuite/ChangeLog:

2013-08-23  Will Newton  <will.newton@@linaro.org>

	* testsuite/gas/arm/neon-addressing-bad.l: Add test for
	VLDn and VSTn instructions.
	* testsuite/gas/arm/neon-addressing-bad.s: Likewise.
@
text
@d9566 2
a9567 1
  X(_sevl,  bf50, f3af8005)
d12223 24
d17997 2
a17998 2
#define ARM_VARIANT &arm_ext_v1 /* Core ARM Instructions.  */
#define THUMB_VARIANT &arm_ext_v4t
d18057 1
d18208 3
a18210 3
#define ARM_VARIANT  & arm_ext_v5exp /*  ARM Architecture 5TExP.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v5exp
d18239 3
a18241 3
#define ARM_VARIANT  & arm_ext_v5e /*  ARM Architecture 5TE.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6t2
d18317 1
a18317 1
 TCE("qaddsubx",	6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18320 1
a18320 1
 TCE("qsubaddx",	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18327 1
a18327 1
 TCE("saddsubx",	6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18330 1
a18330 1
 TCE("shasx",     6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18333 1
a18333 1
 TCE("shsax",      6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18340 1
a18340 1
 TCE("ssubaddx",	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18347 1
a18347 1
 TCE("uaddsubx",	6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18350 1
a18350 1
 TCE("uhasx",     6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18360 1
a18360 1
 TCE("uqasx",     6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18371 1
a18371 1
 TCE("usubaddx",	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d18437 1
a18437 1
#undef THUMB_VARIANT
d18451 1
a18451 1
#define ARM_VARIANT  & arm_ext_v6t2
d18471 1
a18471 1
#undef ARM_VARIANT
d18540 1
a18540 1
#undef ARM_VARIANT
d18542 1
a18542 1
#undef THUMB_VARIANT
d18576 1
a18576 1
#undef ARM_VARIANT
d18584 1
a18584 1
#define ARM_VARIANT & fpu_vfp_ext_armv8
d18628 1
a18628 1
#define ARM_VARIANT & crc_ext_armv8
d19502 3
a19504 3
#define THUMB_VARIANT &fpu_vfp_ext_v3xd
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v3xd
d19515 1
a19515 1
#undef THUMB_VARIANT
d19530 4
a19533 4
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_fma
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_ext_fma
d19573 6
a19578 6
 cCE("textrmub",	e100070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmuh",	e500070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmuw",	e900070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmsb",	e100078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmsh",	e500078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE("textrmsw",	e900078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
d19590 3
a19592 3
 cCE("tmovmskb",	e100030, 2, (RR, RIWR),		    rd_rn),
 cCE("tmovmskh",	e500030, 2, (RR, RIWR),		    rd_rn),
 cCE("tmovmskw",	e900030, 2, (RR, RIWR),		    rd_rn),
d19611 4
a19614 4
 cCE("walignr0",	e800020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("walignr1",	e900020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("walignr2",	ea00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("walignr3",	eb00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d19624 6
a19629 6
 cCE("wcmpgtub",	e100060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtuh",	e500060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtuw",	e900060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtsb",	e300060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtsh",	e700060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wcmpgtsw",	eb00060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d19658 6
a19663 6
 cCE("wpackhss",	e700080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackhus",	e500080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackwss",	eb00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackwus",	e900080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackdss",	ef00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE("wpackdus",	ed00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d19805 10
a19814 10
 cCE("cfmv64lr",	e000510, 2, (RMDX, RR),		      rn_rd),
 cCE("cfmvr64l",	e100510, 2, (RR, RMDX),		      rd_rn),
 cCE("cfmv64hr",	e000530, 2, (RMDX, RR),		      rn_rd),
 cCE("cfmvr64h",	e100530, 2, (RR, RMDX),		      rd_rn),
 cCE("cfmval32",	e200440, 2, (RMAX, RMFX),	      rd_rn),
 cCE("cfmv32al",	e100440, 2, (RMFX, RMAX),	      rd_rn),
 cCE("cfmvam32",	e200460, 2, (RMAX, RMFX),	      rd_rn),
 cCE("cfmv32am",	e100460, 2, (RMFX, RMAX),	      rd_rn),
 cCE("cfmvah32",	e200480, 2, (RMAX, RMFX),	      rd_rn),
 cCE("cfmv32ah",	e100480, 2, (RMFX, RMAX),	      rd_rn),
d19819 2
a19820 2
 cCE("cfmvsc32",	e2004e0, 2, (RMDS, RMDX),	      mav_dspsc),
 cCE("cfmv32sc",	e1004e0, 2, (RMDX, RMDS),	      rd),
d19825 6
a19830 6
 cCE("cfcvt32s",	e000480, 2, (RMF, RMFX),	      rd_rn),
 cCE("cfcvt32d",	e0004a0, 2, (RMD, RMFX),	      rd_rn),
 cCE("cfcvt64s",	e0004c0, 2, (RMF, RMDX),	      rd_rn),
 cCE("cfcvt64d",	e0004e0, 2, (RMD, RMDX),	      rd_rn),
 cCE("cfcvts32",	e100580, 2, (RMFX, RMF),	      rd_rn),
 cCE("cfcvtd32",	e1005a0, 2, (RMFX, RMD),	      rd_rn),
d19833 2
a19834 2
 cCE("cfrshl32",	e000550, 3, (RMFX, RMFX, RR),	      mav_triple),
 cCE("cfrshl64",	e000570, 3, (RMDX, RMDX, RR),	      mav_triple),
d19863 2
a19864 2
 cCE("cfmadd32",	e000600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
 cCE("cfmsub32",	e100600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
@


1.575
log
@2013-07-22  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* config/tc-arm.c (s_arm_arch_extension): Improve error message
	for invalid extension.
@
text
@d16011 1
a16011 1
  else if (inst.operands[1].writeback)
d16013 11
a16023 1
      inst.instruction |= 0xd;
a16024 2
  else
    inst.instruction |= 0xf;
@


1.574
log
@gas/
	* config/tc-arm.c (parse_reg_list): Use skip_past_char for '}',
	so it skips whitespace before it.
	(s_arm_unwind_save_mmxwr, s_arm_unwind_save_mmxwcg): Likewise.

gas/testsuite/
	* gas/arm/macro-vld1.s: Add a case with whitespace before '}'.
	* gas/arm/macro-vld1.d: Update.
@
text
@d25021 1
a25021 1
    as_bad (_("unknown architecture `%s'\n"), name);
@


1.573
log
@gas/
	* config/tc-arm.c (arm_symbol_chars): Include '{' and '}'.
	(arm_reg_parse_multi): Skip whitespace first.
	(parse_reg_list): Likewise.
	(parse_vfp_reg_list): Likewise.
	(s_arm_unwind_save_mmxwcg): Likewise.

gas/testsuite/
	* gas/arm/macro-pld.s: Add a 'push {r0}' case.
	* gas/arm/macro-pld.d: Update expected output.
	* gas/arm/macro-vld1.s: New file.
	* gas/arm/macro-vld1.d: New file.
@
text
@d1644 1
a1644 1
	  if (*str++ != '}')
d3938 1
a3938 2
  if (*input_line_pointer == '}')
    input_line_pointer++;
d4072 1
a4072 2
  if (*input_line_pointer == '}')
    input_line_pointer++;
@


1.572
log
@	PR gas/15623
	* config/tc-arm.c (do_t_smc): Mark as ending an IT block.
@
text
@d326 3
a328 2
   before a [, which can appear as the first operand for pld.  */
const char arm_symbol_chars[] = "#[]";
d361 1
a361 1
                              if inside, should be the last one.  */
d363 1
a363 1
                              i.e. BKPT and NOP.  */
d829 1
a829 1
        return;					\
d838 1
a838 1
        return failret;				\
d846 1
a846 1
        set_it_insn_type (IF_INSIDE_IT_LAST_INSN);	\
d848 1
a848 1
        set_it_insn_type (INSIDE_IT_LAST_INSN);		\
d943 1
a943 1
                  : GE_OPT_PREFIX;
d1004 1
a1004 1
          || (ep->X_add_symbol
d1006 1
a1006 1
	          || (ep->X_op_symbol
d1162 2
d1193 1
a1193 1
                    enum arm_reg_type type)
d1296 5
a1300 5
        case 'd':
          thistype = NT_float;
          thissize = 64;
          ptr++;
          goto done;
d1317 3
a1319 3
              && thissize != 64)
            {
              as_bad (_("bad size %d in type specifier"), thissize);
d1326 2
a1327 2
        {
          type->el[type->elems].type = thistype;
d1364 14
a1377 14
        {
          if (optype.elems == 1)
            *vectype = optype.el[0];
          else
            {
              first_error (_("only one type should be specified for operand"));
              return FAIL;
            }
        }
      else
        {
          first_error (_("vector type expected"));
          return FAIL;
        }
d1400 2
a1401 2
                           enum arm_reg_type *rtype,
                           struct neon_typed_alias *typeinfo)
d1419 1
a1419 1
        *ccp = str;
d1421 1
a1421 1
        *typeinfo = atype;
d1429 1
a1429 1
          && (reg->type == REG_TYPE_VFS || reg->type == REG_TYPE_VFD))
d1431 2
a1432 2
          && (reg->type == REG_TYPE_VFS || reg->type == REG_TYPE_VFD
              || reg->type == REG_TYPE_NQ))
d1446 4
a1449 4
        {
          first_error (_("can't redefine type for operand"));
          return FAIL;
        }
d1457 4
a1460 4
        {
          first_error (_("only D registers may be indexed"));
          return FAIL;
        }
d1463 4
a1466 4
        {
          first_error (_("can't change index for operand"));
          return FAIL;
        }
d1471 1
a1471 1
        atype.index = NEON_ALL_LANES;
d1473 2
a1474 2
        {
          expressionS exp;
d1476 1
a1476 1
          my_get_expression (&exp, &str, GE_NO_PREFIX);
d1478 5
a1482 5
          if (exp.X_op != O_constant)
            {
              first_error (_("constant expression required"));
              return FAIL;
            }
d1484 2
a1485 2
          if (skip_past_char (&str, ']') == FAIL)
            return FAIL;
d1487 2
a1488 2
          atype.index = exp.X_add_number;
        }
d1511 1
a1511 1
                     enum arm_reg_type *rtype, struct neon_type_el *vectype)
d1589 2
d1720 5
a1724 5
         FIXME: This is not implemented, as it would require backtracking in
         some cases, e.g.:
           vtbl.8 d3,d4,d5
         This could be done (the meaning isn't really ambiguous), but doesn't
         fit in well with the current parsing framework.
d1742 1
a1742 1
  if (*str != '{')
a1747 2
  str++;

d1768 9
a1776 9
        {
          max_regs = 32;
          if (thumb_mode)
            ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
                                    fpu_vfp_ext_d32);
          else
            ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
                                    fpu_vfp_ext_d32);
        }
d1778 1
a1778 1
        max_regs = 16;
d1796 4
a1799 4
        {
          first_error (_("register out of range in list"));
          return FAIL;
        }
d1803 4
a1806 4
        {
          setmask = 3;
          addregs = 2;
        }
d1833 1
a1833 1
              == FAIL)
d1839 5
a1843 5
          if (high_range >= max_regs)
            {
              first_error (_("register out of range in list"));
              return FAIL;
            }
d1845 2
a1846 2
          if (regtype == REG_TYPE_NQ)
            high_range = high_range + 1;
d1909 1
a1909 1
          || a->eltype.size != b->eltype.size))
d1933 1
a1933 1
                           struct neon_type_el *eltype)
d1955 4
a1958 4
        {
          first_error (_(reg_expected_msgs[rtype]));
          return FAIL;
        }
d1961 8
a1968 8
        {
          base_reg = getreg;
          if (rtype == REG_TYPE_NQ)
            {
              reg_incr = 1;
            }
          firsttype = atype;
        }
d1970 8
a1977 8
        {
          reg_incr = getreg - base_reg;
          if (reg_incr < 1 || reg_incr > 2)
            {
              first_error (_(incr_error));
              return FAIL;
            }
        }
d1979 4
a1982 4
        {
          first_error (_(incr_error));
          return FAIL;
        }
d1985 4
a1988 4
        {
          first_error (_(type_error));
          return FAIL;
        }
d1991 1
a1991 1
         modes.  */
d1993 32
a2024 32
        {
          struct neon_typed_alias htype;
          int hireg, dregs = (rtype == REG_TYPE_NQ) ? 2 : 1;
          if (lane == -1)
            lane = NEON_INTERLEAVE_LANES;
          else if (lane != NEON_INTERLEAVE_LANES)
            {
              first_error (_(type_error));
              return FAIL;
            }
          if (reg_incr == -1)
            reg_incr = 1;
          else if (reg_incr != 1)
            {
              first_error (_("don't use Rn-Rm syntax with non-unit stride"));
              return FAIL;
            }
          ptr++;
          hireg = parse_typed_reg_or_scalar (&ptr, rtype, NULL, &htype);
          if (hireg == FAIL)
            {
              first_error (_(reg_expected_msgs[rtype]));
              return FAIL;
            }
          if (! neon_alias_types_same (&htype, &firsttype))
            {
              first_error (_(type_error));
              return FAIL;
            }
          count += hireg + dregs - getreg;
          continue;
        }
d2028 4
a2031 4
        {
          count += 2;
          continue;
        }
d2034 9
a2042 9
        {
          if (lane == -1)
            lane = atype.index;
          else if (lane != atype.index)
            {
              first_error (_(type_error));
              return FAIL;
            }
        }
d2044 1
a2044 1
        lane = NEON_INTERLEAVE_LANES;
d2046 4
a2049 4
        {
          first_error (_(type_error));
          return FAIL;
        }
d2153 1
a2153 1
                       struct neon_typed_alias *atype)
d2166 1
a2166 1
          xmalloc (sizeof (struct neon_typed_alias));
d2303 4
a2306 4
        {
          as_bad (_("expression must be constant"));
          return FALSE;
        }
d2309 1
a2309 1
                                                  : exp.X_add_number;
d2320 4
a2323 4
        {
          as_bad (_("can't redefine the type of a register alias"));
          return FALSE;
        }
d2327 4
a2330 4
        {
          as_bad (_("you must specify a single type only"));
          return FALSE;
        }
d2340 4
a2343 4
        {
          as_bad (_("can't redefine the index of a scalar alias"));
          return FALSE;
        }
d2348 4
a2351 4
        {
          as_bad (_("scalar index must be constant"));
          return FALSE;
        }
d2357 4
a2360 4
        {
          as_bad (_("expecting ]"));
          return FALSE;
        }
d2378 1
a2378 1
                         typeinfo.defined != 0 ? &typeinfo : NULL);
d2386 1
a2386 1
                           typeinfo.defined != 0 ? &typeinfo : NULL);
d2394 1
a2394 1
                           typeinfo.defined != 0 ? &typeinfo : NULL);
d2447 1
a2447 1
                                                              name);
d2461 2
a2462 2
          if (reg->neon)
            free (reg->neon);
d2650 1
a2650 1
          || TRANSITION (MAP_UNDEFINED, MAP_THUMB))
d2653 3
a2655 3
         if we're at the first frag, check it's size > 0;
         if we're not at the first frag, then for sure
            the offset is > 0.  */
d2660 1
a2660 1
        make_mapping_symbol (MAP_DATA, (valueT) 0, frag_first);
d3287 2
a3288 2
                  bfd_reloc_type_lookup (stdoutput,
                                         (bfd_reloc_code_real_type) reloc);
d4036 2
d4142 1
a4142 1
        s_arm_unwind_save_vfp_armv6 ();
d4144 1
a4144 1
        s_arm_unwind_save_vfp ();
d4535 1
a4535 1
          /* X >> 32 is illegal if sizeof (exp.X_add_number) == 4.  */
d4546 2
a4547 2
         generic_bignum[0]. Make sure we put 32 bits in imm and
         32 bits in reg,  in a (hopefully) portable way.  */
d4569 2
a4570 2
        inst.operands[i].imm |= generic_bignum[idx]
                                << (LITTLENUM_NUMBER_OF_BITS * j);
d4573 2
a4574 2
        inst.operands[i].reg |= generic_bignum[idx]
                                << (LITTLENUM_NUMBER_OF_BITS * j);
d4715 5
a4719 5
        if (*fpnum == '.' || *fpnum == 'e' || *fpnum == 'E')
          {
            found_fpchar = 1;
            break;
          }
d4722 1
a4722 1
        return FAIL;
d4732 4
a4735 4
        {
          fpword <<= LITTLENUM_NUMBER_OF_BITS;
          fpword |= words[i];
        }
d4738 1
a4738 1
        *immed = fpword;
d4740 1
a4740 1
        return FAIL;
d4801 1
a4801 1
                                                            p - *str);
d5029 5
a5033 5
        {
          *out = &group_reloc_table[i];
          *str += (length + 1);
          return SUCCESS;
        }
d5066 1
a5066 1
        (*str) += 2;
d5068 1
a5068 1
        (*str)++;
d5072 4
a5075 4
        {
          inst.error = _("unknown group relocation");
          return PARSE_OPERAND_FAIL_NO_BACKTRACK;
        }
d5078 1
a5078 1
         the name in the assembler source.  Next, we parse the expression.  */
d5080 1
a5080 1
        return PARSE_OPERAND_FAIL_NO_BACKTRACK;
d5090 1
a5090 1
           ? PARSE_OPERAND_SUCCESS : PARSE_OPERAND_FAIL;
d5156 1
a5156 1
                    group_reloc_type group_type)
d5230 5
a5234 5
              /* Skip over the #: or : sequence.  */
              if (*p == '#')
                p += 2;
              else
                p++;
d5237 1
a5237 1
                 error.  */
d5246 1
a5246 1
                 expression.  */
d5251 17
a5267 17
              switch (group_type)
                {
                  case GROUP_LDR:
	            inst.reloc.type = (bfd_reloc_code_real_type) entry->ldr_code;
                    break;

                  case GROUP_LDRS:
	            inst.reloc.type = (bfd_reloc_code_real_type) entry->ldrs_code;
                    break;

                  case GROUP_LDC:
	            inst.reloc.type = (bfd_reloc_code_real_type) entry->ldc_code;
                    break;

                  default:
                    gas_assert (0);
                }
d5269 1
a5269 1
              if (inst.reloc.type == 0)
d5274 2
a5275 2
            }
          else
d5353 6
a5358 6
              /* We might be using the immediate for alignment already. If we
                 are, OR the register number into the low-order bits.  */
              if (inst.operands[i].immisalign)
	        inst.operands[i].imm |= reg;
              else
                inst.operands[i].imm = reg;
d5408 1
a5408 1
         ? SUCCESS : FAIL;
d5515 1
a5515 1
                                                  p - start);
d5561 1
a5561 1
	        {
d5598 1
a5598 1
	        {
d5616 1
a5616 1
        {
d5618 1
a5618 1
                                                      p - start);
d5620 1
a5620 1
            goto error;
d5631 1
a5631 1
         is deprecated, but allow it anyway.  */
d5819 1
a5819 1
                                                    q - p);
d5909 1
a5909 1
        goto wanted_comma;
d5912 1
a5912 1
        goto wanted_arm;
d5919 1
a5919 1
           != FAIL)
d5923 1
a5923 1
        goto wanted_comma;
d5934 24
a5957 24
        {
          /* Case 5: VMOV<c><q> <Dm>, <Rd>, <Rn>.
             Case 13: VMOV <Sd>, <Rm>  */
          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].present = 1;

          if (rtype == REG_TYPE_NQ)
            {
              first_error (_("can't use Neon quad register here"));
              return FAIL;
            }
          else if (rtype != REG_TYPE_VFS)
            {
              i++;
              if (skip_past_comma (&ptr) == FAIL)
                goto wanted_comma;
              if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
                goto wanted_arm;
              inst.operands[i].reg = val;
              inst.operands[i].isreg = 1;
              inst.operands[i].present = 1;
            }
        }
d5959 38
a5996 38
                                           &optype)) != FAIL)
        {
          /* Case 0: VMOV<c><q> <Qd>, <Qm>
             Case 1: VMOV<c><q> <Dd>, <Dm>
             Case 8: VMOV.F32 <Sd>, <Sm>
             Case 15: VMOV <Sd>, <Se>, <Rn>, <Rm>  */

          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].isquad = (rtype == REG_TYPE_NQ);
          inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
          inst.operands[i].isvec = 1;
          inst.operands[i].vectype = optype;
          inst.operands[i].present = 1;

          if (skip_past_comma (&ptr) == SUCCESS)
            {
              /* Case 15.  */
              i++;

              if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
                goto wanted_arm;

              inst.operands[i].reg = val;
              inst.operands[i].isreg = 1;
              inst.operands[i++].present = 1;

              if (skip_past_comma (&ptr) == FAIL)
                goto wanted_comma;

              if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
                goto wanted_arm;

              inst.operands[i].reg = val;
              inst.operands[i].isreg = 1;
              inst.operands[i].present = 1;
            }
        }
d5998 5
a6002 5
          /* Case 2: VMOV<c><q>.<dt> <Qd>, #<float-imm>
             Case 3: VMOV<c><q>.<dt> <Dd>, #<float-imm>
             Case 10: VMOV.F32 <Sd>, #<imm>
             Case 11: VMOV.F64 <Dd>, #<imm>  */
        inst.operands[i].immisfloat = 1;
d6004 8
a6011 8
          /* Case 2: VMOV<c><q>.<dt> <Qd>, #<imm>
             Case 3: VMOV<c><q>.<dt> <Dd>, #<imm>  */
        ;
      else
        {
          first_error (_("expected <Rm> or <Dm> or <Qm> operand"));
          return FAIL;
        }
d6021 1
a6021 1
        goto wanted_comma;
d6024 7
a6030 7
        {
          /* Case 6: VMOV<c><q>.<dt> <Rd>, <Dn[x]>  */
          inst.operands[i].reg = val;
          inst.operands[i].isscalar = 1;
          inst.operands[i].present = 1;
          inst.operands[i].vectype = optype;
        }
d6032 43
a6074 43
        {
          /* Case 7: VMOV<c><q> <Rd>, <Rn>, <Dm>  */
          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i++].present = 1;

          if (skip_past_comma (&ptr) == FAIL)
            goto wanted_comma;

          if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFSD, &rtype, &optype))
              == FAIL)
            {
              first_error (_(reg_expected_msgs[REG_TYPE_VFSD]));
              return FAIL;
            }

          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].isvec = 1;
          inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
          inst.operands[i].vectype = optype;
          inst.operands[i].present = 1;

          if (rtype == REG_TYPE_VFS)
            {
              /* Case 14.  */
              i++;
              if (skip_past_comma (&ptr) == FAIL)
                goto wanted_comma;
              if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL,
                                              &optype)) == FAIL)
                {
                  first_error (_(reg_expected_msgs[REG_TYPE_VFS]));
                  return FAIL;
                }
              inst.operands[i].reg = val;
              inst.operands[i].isreg = 1;
              inst.operands[i].isvec = 1;
              inst.operands[i].issingle = 1;
              inst.operands[i].vectype = optype;
              inst.operands[i].present = 1;
            }
        }
d6076 10
a6085 10
               != FAIL)
        {
          /* Case 13.  */
          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].isvec = 1;
          inst.operands[i].issingle = 1;
          inst.operands[i].vectype = optype;
          inst.operands[i].present = 1;
        }
d6261 1
a6261 1
        goto bad_args;				\
d6269 1
a6269 1
  			         & inst.operands[i].vectype);	\
d6271 4
a6274 4
        {							\
          first_error (_(reg_expected_msgs[regtype]));		\
          goto failure;						\
        }							\
d6280 2
a6281 2
                             || rtype == REG_TYPE_VFD		\
                             || rtype == REG_TYPE_NQ);		\
d6298 1
a6298 1
                             || rtype == REG_TYPE_VFD		\
d6395 1
a6395 1
        case OP_oRND:
d6414 1
a6414 1
        case OP_oRNQ:
d6416 1
a6416 1
        case OP_oRNDQ:
d6418 86
a6503 86
        case OP_RVSD:  po_reg_or_fail (REG_TYPE_VFSD);    break;
        case OP_oRNSDQ:
        case OP_RNSDQ: po_reg_or_fail (REG_TYPE_NSDQ);    break;

        /* Neon scalar. Using an element size of 8 means that some invalid
           scalars are accepted here, so deal with those in later code.  */
        case OP_RNSC:  po_scalar_or_goto (8, failure);    break;

        case OP_RNDQ_I0:
          {
            po_reg_or_goto (REG_TYPE_NDQ, try_imm0);
            break;
            try_imm0:
            po_imm_or_fail (0, 0, TRUE);
          }
          break;

        case OP_RVSD_I0:
          po_reg_or_goto (REG_TYPE_VFSD, try_imm0);
          break;

        case OP_RR_RNSC:
          {
            po_scalar_or_goto (8, try_rr);
            break;
            try_rr:
            po_reg_or_fail (REG_TYPE_RN);
          }
          break;

        case OP_RNSDQ_RNSC:
          {
            po_scalar_or_goto (8, try_nsdq);
            break;
            try_nsdq:
            po_reg_or_fail (REG_TYPE_NSDQ);
          }
          break;

        case OP_RNDQ_RNSC:
          {
            po_scalar_or_goto (8, try_ndq);
            break;
            try_ndq:
            po_reg_or_fail (REG_TYPE_NDQ);
          }
          break;

        case OP_RND_RNSC:
          {
            po_scalar_or_goto (8, try_vfd);
            break;
            try_vfd:
            po_reg_or_fail (REG_TYPE_VFD);
          }
          break;

        case OP_VMOV:
          /* WARNING: parse_neon_mov can move the operand counter, i. If we're
             not careful then bad things might happen.  */
          po_misc_or_fail (parse_neon_mov (&str, &i) == FAIL);
          break;

        case OP_RNDQ_Ibig:
          {
            po_reg_or_goto (REG_TYPE_NDQ, try_immbig);
            break;
            try_immbig:
            /* There's a possibility of getting a 64-bit immediate here, so
               we need special handling.  */
            if (parse_big_immediate (&str, i) == FAIL)
              {
                inst.error = _("immediate value is out of range");
                goto failure;
              }
          }
          break;

        case OP_RNDQ_I63b:
          {
            po_reg_or_goto (REG_TYPE_NDQ, try_shimm);
            break;
            try_shimm:
            po_imm_or_fail (0, 63, TRUE);
          }
          break;
d6523 1
a6523 1
        case OP_I16z:	 po_imm_or_fail (  0,     16, FALSE);   break;
d6526 1
a6526 1
        case OP_I32z:	 po_imm_or_fail (  0,     32, FALSE);   break;
d6528 3
a6530 3
        case OP_I63:	 po_imm_or_fail (  0,     63, FALSE);   break;
        case OP_I64:	 po_imm_or_fail (  1,     64, FALSE);   break;
        case OP_I64z:	 po_imm_or_fail (  0,     64, FALSE);   break;
d6539 2
a6540 2
        case OP_oI32b:   po_imm_or_fail (  1,     32, TRUE);    break;
        case OP_oI32z:   po_imm_or_fail (  0,     32, TRUE);    break;
d6669 1
a6669 1
            goto failure;
d6686 22
a6707 22
        case OP_APSR_RR:
          po_reg_or_goto (REG_TYPE_RN, try_apsr);
          break;
          try_apsr:
          /* Parse "APSR_nvzc" operand (for FMSTAT-equivalent MRS
             instruction).  */
          if (strncasecmp (str, "APSR_", 5) == 0)
            {
              unsigned found = 0;
              str += 5;
              while (found < 15)
                switch (*str++)
                  {
                  case 'c': found = (found & 1) ? 16 : found | 1; break;
                  case 'n': found = (found & 2) ? 16 : found | 2; break;
                  case 'z': found = (found & 4) ? 16 : found | 4; break;
                  case 'v': found = (found & 8) ? 16 : found | 8; break;
                  default: found = 16;
                  }
              if (found != 15)
                goto failure;
              inst.operands[i].isvec = 1;
d6710 4
a6713 4
            }
          else
            goto failure;
          break;
d6737 17
a6753 17
        case OP_VRSDLST:
          /* Allow Q registers too.  */
          val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
                                    REGLIST_NEON_D);
          if (val == FAIL)
            {
              inst.error = NULL;
              val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
                                        REGLIST_VFP_S);
              inst.operands[i].issingle = 1;
            }
          break;

        case OP_NRDLST:
          val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
                                    REGLIST_NEON_D);
          break;
d6756 3
a6758 3
          val = parse_neon_el_struct_list (&str, &inst.operands[i].reg,
                                           &inst.operands[i].vectype);
          break;
d6767 1
a6767 1
            parse_address_group_reloc (&str, i, GROUP_LDR));
d6772 1
a6772 1
            parse_address_group_reloc (&str, i, GROUP_LDRS));
d6777 1
a6777 1
            parse_address_group_reloc (&str, i, GROUP_LDC));
d6786 1
a6786 1
            parse_shifter_operand_group_reloc (&str, i));
d6848 3
a6850 3
        case OP_VRSDLST:
        case OP_NRDLST:
        case OP_NSTRLST:
d7000 13
a7012 13
        {
          if (thumb_mode)
            ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
                                    fpu_vfp_ext_d32);
          else
            ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
                                    fpu_vfp_ext_d32);
        }
      else
        {
          first_error (_("D register out of range for selected VFP version"));
          return;
        }
d7278 2
a7279 2
            || inst.reloc.type > BFD_RELOC_ARM_LDC_SB_G2)
           && inst.reloc.type != BFD_RELOC_ARM_LDR_PC_G0)
d7282 1
a7282 1
        inst.reloc.type = BFD_RELOC_ARM_T32_CP_OFF_IMM;
d7284 1
a7284 1
        inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
d7827 1
a7827 1
	        && warn_on_deprecated
d8225 1
a8225 1
        first_error (_("operand 1 must be FPSCR"));
d9003 1
a9003 1
         i.e. immbits must be in range 0 - 16.  */
d9010 1
a9010 1
         i.e. immbits must be in range 0 - 31.  */
d9652 1
a9652 1
	         appropriate.  */
d10156 1
a10156 1
         branches.  */
d10457 6
a10462 6
        {
          if (mask & (1 << 14))
            inst.error = _("LR and PC should not both be in register list");
          else
            set_it_insn_type_last ();
        }
d10530 1
a10530 1
	        {
d10547 1
a10547 1
		        reglist.
d10574 1
a10574 1
			            ? T_MNEM_push : T_MNEM_pop);
d10576 1
a10576 1
	          narrow = TRUE;
d10582 1
a10582 1
			            ? T_MNEM_str_sp : T_MNEM_ldr_sp);
d10584 1
a10584 1
	          narrow = TRUE;
d10750 2
a10751 2
	          && !ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7a)
	          && !ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7r)))
d10860 1
a10860 1
                  _("r12 not allowed here"));
d10867 1
a10867 1
               "one of transfer registers"));
d11393 2
a11394 2
         If the user has specified -march=all, we want to ignore it as
         we are building for any CPU type, including non-m variants.  */
d11397 5
a11401 5
           && (bits & ~(PSR_s | PSR_f)) != 0)
          || (!ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp)
              && bits != PSR_f)) && m_profile,
          _("selected processor does not support requested special "
            "purpose register"));
d11795 1
a11795 1
         relaxation, but it doesn't seem worth the hassle.  */
d12608 54
a12661 54
        {
          if (!inst.operands[j].present)
            {
              matches = 0;
              break;
            }

          switch (neon_shape_tab[shape].el[j])
            {
            case SE_F:
              if (!(inst.operands[j].isreg
                    && inst.operands[j].isvec
                    && inst.operands[j].issingle
                    && !inst.operands[j].isquad))
                matches = 0;
              break;

            case SE_D:
              if (!(inst.operands[j].isreg
                    && inst.operands[j].isvec
                    && !inst.operands[j].isquad
                    && !inst.operands[j].issingle))
                matches = 0;
              break;

            case SE_R:
              if (!(inst.operands[j].isreg
                    && !inst.operands[j].isvec))
                matches = 0;
              break;

            case SE_Q:
              if (!(inst.operands[j].isreg
                    && inst.operands[j].isvec
                    && inst.operands[j].isquad
                    && !inst.operands[j].issingle))
                matches = 0;
              break;

            case SE_I:
              if (!(!inst.operands[j].isreg
                    && !inst.operands[j].isscalar))
                matches = 0;
              break;

            case SE_S:
              if (!(!inst.operands[j].isreg
                    && inst.operands[j].isscalar))
                matches = 0;
              break;

            case SE_L:
              break;
            }
d12664 1
a12664 1
        }
d12668 1
a12668 1
        break;
d12690 1
a12690 1
                       unsigned *g_size)
d12703 1
a12703 1
        *g_type = NT_unsigned;
d12705 1
a12705 1
        *g_type = NT_integer;
d12707 1
a12707 1
        *g_type = NT_float;
d12709 1
a12709 1
        *g_type = NT_untyped;
d12738 7
a12744 7
        {
        case 8:  return N_8;
        case 16: return N_16;
        case 32: return N_32;
        case 64: return N_64;
        default: ;
        }
d12749 7
a12755 7
        {
        case 8:  return N_I8;
        case 16: return N_I16;
        case 32: return N_I32;
        case 64: return N_I64;
        default: ;
        }
d12760 1
a12760 1
        {
d12762 4
a12765 4
        case 32: return N_F32;
        case 64: return N_F64;
        default: ;
        }
d12770 3
a12772 3
        {
        case 8:  return N_P8;
        case 16: return N_P16;
d12774 2
a12775 2
        default: ;
        }
d12780 7
a12786 7
        {
        case 8:  return N_S8;
        case 16: return N_S16;
        case 32: return N_S32;
        case 64: return N_S64;
        default: ;
        }
d12791 7
a12797 7
        {
        case 8:  return N_U8;
        case 16: return N_U16;
        case 32: return N_U32;
        case 64: return N_U64;
        default: ;
        }
d12811 1
a12811 1
                     enum neon_type_mask mask)
d12861 5
a12865 5
                               (enum neon_type_mask) (allowed & i)) == SUCCESS)
        {
          neon_modify_type_size (mods, &type, &size);
          destmask |= type_chk_of_el_type (type, size);
        }
d12905 4
a12908 4
        {
          va_end (ap);
          return badtype;
        }
d12911 1
a12911 1
        key_el = i;
d12918 4
a12921 4
        {
          first_error (_("types specified in both the mnemonic and operands"));
          return badtype;
        }
d12933 3
a12935 3
        if (j != key_el)
          inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
                                                  types[j]);
d12941 2
a12942 2
         after each operand. We allow some flexibility here; as long as the
         "key" operand has a type, we can infer the others.  */
d12944 2
a12945 2
        if (inst.operands[j].vectype.type != NT_invtype)
          inst.vectype.el[j] = inst.operands[j].vectype;
d12948 11
a12958 11
        {
          for (j = 0; j < els; j++)
            if (inst.operands[j].vectype.type == NT_invtype)
              inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
                                                      types[j]);
        }
      else
        {
          first_error (_("operand types can't be inferred"));
          return badtype;
        }
d12969 6
a12974 6
        {
          unsigned thisarg = types[i];
          unsigned types_allowed = ((thisarg & N_EQK) != 0 && pass != 0)
            ? modify_types_allowed (key_allowed, thisarg) : thisarg;
          enum neon_el_type g_type = inst.vectype.el[i].type;
          unsigned g_size = inst.vectype.el[i].size;
d12976 1
a12976 1
          /* Decay more-specific signed & unsigned types to sign-insensitive
d12978 1
a12978 1
          if ((g_type == NT_signed || g_type == NT_unsigned)
d12982 1
a12982 1
          /* If only untyped args are allowed, decay any more specific types to
d12985 1
a12985 1
          if (((types_allowed & N_UNT) == 0)
d12992 15
a13006 15
          if (pass == 0)
            {
              if ((thisarg & N_KEY) != 0)
                {
                  k_type = g_type;
                  k_size = g_size;
                  key_allowed = thisarg & ~N_KEY;
                }
            }
          else
            {
              if ((thisarg & N_VFP) != 0)
                {
                  enum neon_shape_el regshape;
                  unsigned regwidth, match;
d13014 21
a13034 2
                  regshape = neon_shape_tab[ns].el[i];
                  regwidth = neon_shape_el_size[regshape];
d13036 19
a13054 38
                  /* In VFP mode, operands must match register widths. If we
                     have a key operand, use its width, else use the width of
                     the current operand.  */
                  if (k_size != -1u)
                    match = k_size;
                  else
                    match = g_size;

                  if (regwidth != match)
                    {
                      first_error (_("operand size must match register width"));
                      return badtype;
                    }
                }

              if ((thisarg & N_EQK) == 0)
                {
                  unsigned given_type = type_chk_of_el_type (g_type, g_size);

                  if ((given_type & types_allowed) == 0)
                    {
	              first_error (_("bad type in Neon instruction"));
	              return badtype;
                    }
                }
              else
                {
                  enum neon_el_type mod_k_type = k_type;
                  unsigned mod_k_size = k_size;
                  neon_modify_type_size (thisarg, &mod_k_type, &mod_k_size);
                  if (g_type != mod_k_type || g_size != mod_k_size)
                    {
                      first_error (_("inconsistent types in Neon instruction"));
                      return badtype;
                    }
                }
            }
        }
d13094 2
a13095 2
                thumb_mode ? *opcode->tvariant : *opcode->avariant),
              _(BAD_FPU));
d13119 1
a13119 1
        do_vfp_nsyn_opcode ("fadds");
d13121 1
a13121 1
        do_vfp_nsyn_opcode ("fsubs");
d13126 1
a13126 1
        do_vfp_nsyn_opcode ("faddd");
d13128 1
a13128 1
        do_vfp_nsyn_opcode ("fsubd");
d13146 1
a13146 1
        N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
d13152 1
a13152 1
        N_EQK | N_VFP, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
d13177 1
a13177 1
        do_vfp_nsyn_opcode ("fmacs");
d13179 1
a13179 1
        do_vfp_nsyn_opcode ("fnmacs");
d13184 1
a13184 1
        do_vfp_nsyn_opcode ("fmacd");
d13186 1
a13186 1
        do_vfp_nsyn_opcode ("fnmacd");
d13198 1
a13198 1
        do_vfp_nsyn_opcode ("ffmas");
d13200 1
a13200 1
        do_vfp_nsyn_opcode ("ffnmas");
d13205 1
a13205 1
        do_vfp_nsyn_opcode ("ffmad");
d13207 1
a13207 1
        do_vfp_nsyn_opcode ("ffnmad");
d13229 1
a13229 1
        do_vfp_nsyn_opcode ("fnegs");
d13231 1
a13231 1
        do_vfp_nsyn_opcode ("fabss");
d13236 1
a13236 1
        do_vfp_nsyn_opcode ("fnegd");
d13238 1
a13238 1
        do_vfp_nsyn_opcode ("fabsd");
d13252 1
a13252 1
        do_vfp_nsyn_opcode ("fldmdbs");
d13254 1
a13254 1
        do_vfp_nsyn_opcode ("fldmias");
d13259 1
a13259 1
        do_vfp_nsyn_opcode ("fstmdbs");
d13261 1
a13261 1
        do_vfp_nsyn_opcode ("fstmias");
d13319 9
a13327 9
        {
          NEON_ENCODE (SINGLE, inst);
          do_vfp_sp_monadic ();
        }
      else
        {
          NEON_ENCODE (DOUBLE, inst);
          do_vfp_dp_rd_rm ();
        }
d13335 10
a13344 10
        {
        case N_MNEM_vcmp:
          inst.instruction += N_MNEM_vcmpz - N_MNEM_vcmp;
          break;
        case N_MNEM_vcmpe:
          inst.instruction += N_MNEM_vcmpez - N_MNEM_vcmpe;
          break;
        default:
          abort ();
        }
d13347 9
a13355 9
        {
          NEON_ENCODE (SINGLE, inst);
          do_vfp_sp_compare_z ();
        }
      else
        {
          NEON_ENCODE (DOUBLE, inst);
          do_vfp_dp_rd ();
        }
d13404 1
a13404 1
        i |= 1 << 28;
d13498 1
a13498 1
                unsigned immbits)
d13529 1
a13529 1
        N_EQK, N_SU_ALL | N_KEY, N_EQK | N_SGN);
d13533 6
a13538 6
           vshl.xx Dd, Dm, Dn
         whereas other 3-register operations encoded by neon_three_same have
         syntax like:
           vadd.xx Dd, Dn, Dm
         (i.e. with Dn & Dm reversed). Swap operands[1].reg and operands[2].reg
         here.  */
d13557 1
a13557 1
                      inst.operands[2].imm);
d13563 1
a13563 1
        N_EQK, N_SU_ALL | N_KEY, N_EQK | N_SGN);
d13596 2
a13597 2
         FIXME is this the intended semantics? There doesn't seem much point in
         accepting .I8 if so.  */
d13652 3
a13654 3
         && ((imm & 0x0000ff00) == 0 || (imm & 0x0000ff00) == 0x0000ff00)
         && ((imm & 0x00ff0000) == 0 || (imm & 0x00ff0000) == 0x00ff0000)
         && ((imm & 0xff000000) == 0 || (imm & 0xff000000) == 0xff000000);
d13663 1
a13663 1
         | ((imm & 0x01000000) >> 21);
d13694 1
a13694 1
        return FAIL;
d13856 1
a13856 1
        N_I8 | N_I16 | N_I32 | N_I64 | N_F32 | N_KEY, N_EQK);
d13862 1
a13862 1
        return;
d13884 24
a13907 24
        {
        case N_MNEM_vbic:
          cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
          break;

        case N_MNEM_vorr:
          cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
          break;

        case N_MNEM_vand:
          /* Pseudo-instruction for VBIC.  */
          neon_invert_size (&immbits, 0, et.size);
          cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
          break;

        case N_MNEM_vorn:
          /* Pseudo-instruction for VORR.  */
          neon_invert_size (&immbits, 0, et.size);
          cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
          break;

        default:
          abort ();
        }
d13910 1
a13910 1
        return;
d13932 1
a13932 1
                  unsigned destbits)
d13936 1
a13936 1
                                            types | N_KEY);
d14004 4
a14007 4
        {
          first_error (_(BAD_COND));
          return FAIL;
        }
d14009 1
a14009 1
        inst.instruction |= inst.uncond_value << 28;
d14076 1
a14076 1
        neon_exchange_operands ();
d14083 1
a14083 1
        N_EQK | N_SIZ, immtypes | N_KEY);
d14132 1
a14132 1
        goto bad_scalar;
d14137 1
a14137 1
        goto bad_scalar;
d14186 1
a14186 1
        N_EQK, N_EQK, N_I16 | N_I32 | N_F32 | N_KEY);
d14245 1
a14245 1
        N_EQK, N_EQK, N_S16 | N_S32 | N_KEY);
d14253 1
a14253 1
        N_EQK, N_EQK, N_S16 | N_S32 | N_KEY);
d14318 1
a14318 1
              _("immediate out of range for insert"));
d14330 1
a14330 1
              _("immediate out of range for insert"));
d14342 1
a14342 1
              _("immediate out of range for shift"));
d14399 1
a14399 1
              _("immediate out of range"));
d14426 1
a14426 1
              _("immediate out of range"));
d14463 1
a14463 1
              _("immediate out of range for narrowing operation"));
d14491 1
a14491 1
        N_EQK | N_DBL, N_SU_32 | N_KEY);
d14551 1
a14551 1
                        || rs == NS_FF) ? N_VFP : 0;
d14586 1
a14586 1
        {
d14591 1
a14591 1
        };
d14594 7
a14600 7
        {
          opname = enc[flavour];
          constraint (inst.operands[0].reg != inst.operands[1].reg,
                      _("operands 0 and 1 must be the same register"));
          inst.operands[1] = inst.operands[2];
          memset (&inst.operands[2], '\0', sizeof (inst.operands[2]));
        }
d14606 1
a14606 1
        {
d14611 1
a14611 1
        };
d14614 1
a14614 1
        opname = enc[flavour];
d14725 2
a14726 2
        unsigned immbits;
        unsigned enctab[] = { 0x0000100, 0x1000100, 0x0, 0x1000000 };
d14728 2
a14729 2
        if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
          return;
d14731 4
a14734 4
        /* Fixed-point conversion with #0 immediate is encoded as an
           integer conversion.  */
        if (inst.operands[2].present && inst.operands[2].imm == 0)
          goto int_encode;
d14736 10
a14745 10
        NEON_ENCODE (IMMED, inst);
        if (flavour != neon_cvt_flavour_invalid)
          inst.instruction |= enctab[flavour];
        inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
        inst.instruction |= HI1 (inst.operands[0].reg) << 22;
        inst.instruction |= LOW4 (inst.operands[1].reg);
        inst.instruction |= HI1 (inst.operands[1].reg) << 5;
        inst.instruction |= neon_quad (rs) << 6;
        inst.instruction |= 1 << 21;
        inst.instruction |= immbits << 16;
d14747 1
a14747 1
        neon_dp_fixup (&inst);
d14818 1
a14818 1
        inst.instruction = 0x3b60600;
d14944 1
a14944 1
              _("operand size must be specified for immediate VMOV"));
d14954 1
a14954 1
              _("immediate has bits set outside the operand size"));
d14959 1
a14959 1
                                        et.size, et.type)) == FAIL)
d14964 2
a14965 2
         with one or the other; those cases are caught by
         neon_cmode_for_move_imm.  */
d14969 4
a14972 4
        {
          first_error (_("immediate out of range"));
          return;
        }
d15052 1
a15052 1
        N_EQK | N_DBL, N_EQK, regtypes | N_KEY);
d15059 1
a15059 1
        N_EQK | N_DBL, N_EQK, scalartypes | N_KEY);
d15104 1
a15104 1
        N_EQK | N_DBL, N_EQK, N_SU_32 | N_P8 | N_P64 | N_KEY);
d15107 1
a15107 1
        NEON_ENCODE (POLY, inst);
d15109 1
a15109 1
        NEON_ENCODE (INTEGER, inst);
d15163 1
a15163 1
              _("elements must be smaller than reversal region"));
d15174 1
a15174 1
        N_EQK, N_8 | N_16 | N_32 | N_KEY);
d15181 1
a15181 1
        return;
d15198 1
a15198 1
        N_8 | N_16 | N_32 | N_KEY, N_EQK);
d15202 6
a15207 6
        {
        case 8:  inst.instruction |= 0x400000; break;
        case 16: inst.instruction |= 0x000020; break;
        case 32: inst.instruction |= 0x000000; break;
        default: break;
        }
d15213 1
a15213 1
         variants, except for the condition field.  */
d15275 4
a15278 4
        {
          do_vfp_nsyn_opcode ("fcpyd");
          break;
        }
d15283 13
a15295 13
        if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
          return;
        /* The architecture manual I have doesn't explicitly state which
           value the U bit should have for register->register moves, but
           the equivalent VORR instruction has U = 0, so do that.  */
        inst.instruction = 0x0200110;
        inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
        inst.instruction |= HI1 (inst.operands[0].reg) << 22;
        inst.instruction |= LOW4 (inst.operands[1].reg);
        inst.instruction |= HI1 (inst.operands[1].reg) << 5;
        inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
        inst.instruction |= HI1 (inst.operands[1].reg) << 7;
        inst.instruction |= neon_quad (rs) << 6;
d15297 1
a15297 1
        neon_dp_fixup (&inst);
d15305 5
a15309 5
        {
          /* case 11 (fconstd).  */
          ldconst = "fconstd";
          goto encode_fconstd;
        }
d15314 1
a15314 1
        return;
d15322 4
a15325 4
        unsigned bcdebits = 0;
        int logsize;
        unsigned dn = NEON_SCALAR_REG (inst.operands[0].reg);
        unsigned x = NEON_SCALAR_INDEX (inst.operands[0].reg);
d15337 9
a15345 2
        et = neon_check_type (2, NS_NULL, N_8 | N_16 | N_32 | N_KEY, N_EQK);
        logsize = neon_logbits (et.size);
d15347 17
a15363 24
        constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
                    _(BAD_FPU));
        constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
                    && et.size != 32, _(BAD_FPU));
        constraint (et.type == NT_invtype, _("bad type for scalar"));
        constraint (x >= 64 / et.size, _("scalar index out of range"));

        switch (et.size)
          {
          case 8:  bcdebits = 0x8; break;
          case 16: bcdebits = 0x1; break;
          case 32: bcdebits = 0x0; break;
          default: ;
          }

        bcdebits |= x << logsize;

        inst.instruction = 0xe000b10;
        do_vfp_cond_or_thumb ();
        inst.instruction |= LOW4 (dn) << 16;
        inst.instruction |= HI1 (dn) << 7;
        inst.instruction |= inst.operands[1].reg << 12;
        inst.instruction |= (bcdebits & 3) << 5;
        inst.instruction |= (bcdebits >> 2) << 21;
d15369 1
a15369 1
                  _(BAD_FPU));
d15381 4
a15384 4
        unsigned logsize;
        unsigned dn = NEON_SCALAR_REG (inst.operands[1].reg);
        unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg);
        unsigned abcdebits = 0;
d15398 8
a15405 1
        logsize = neon_logbits (et.size);
d15407 16
a15422 23
        constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
                    _(BAD_FPU));
        constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
                    && et.size != 32, _(BAD_FPU));
        constraint (et.type == NT_invtype, _("bad type for scalar"));
        constraint (x >= 64 / et.size, _("scalar index out of range"));

        switch (et.size)
          {
          case 8:  abcdebits = (et.type == NT_signed) ? 0x08 : 0x18; break;
          case 16: abcdebits = (et.type == NT_signed) ? 0x01 : 0x11; break;
          case 32: abcdebits = 0x00; break;
          default: ;
          }

        abcdebits |= x << logsize;
        inst.instruction = 0xe100b10;
        do_vfp_cond_or_thumb ();
        inst.instruction |= LOW4 (dn) << 16;
        inst.instruction |= HI1 (dn) << 7;
        inst.instruction |= inst.operands[0].reg << 12;
        inst.instruction |= (abcdebits & 3) << 5;
        inst.instruction |= (abcdebits >> 2) << 21;
d15428 1
a15428 1
                  _(BAD_FPU));
d15446 4
a15449 4
        {
          inst.operands[1].imm = neon_qfloat_bits (inst.operands[1].imm);
          do_vfp_nsyn_opcode (ldconst);
        }
d15451 1
a15451 1
        first_error (_("immediate out of range"));
d15468 1
a15468 1
                  _("VFP registers must be adjacent"));
d15476 1
a15476 1
                  _("VFP registers must be adjacent"));
d15510 1
a15510 1
              _("immediate out of range for shift"));
d15512 1
a15512 1
                  et.size - imm);
d15652 1
a15652 1
              _("writeback (!) must be used for VLDMDB and VSTMDB"));
d15655 2
a15656 2
              _("register list must contain at least 1 and at most 16 "
                "registers"));
d15688 1
a15688 1
        do_vfp_nsyn_opcode ("flds");
d15690 1
a15690 1
        do_vfp_nsyn_opcode ("fsts");
d15695 1
a15695 1
        do_vfp_nsyn_opcode ("fldd");
d15697 1
a15697 1
        do_vfp_nsyn_opcode ("fstd");
d15708 1
a15708 1
                                            N_8 | N_16 | N_32 | N_64);
d15733 1
a15733 1
        if (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 2
d15735 3
a15737 3
          goto bad_alignment;
        alignbits = 2;
        break;
d15739 4
a15742 4
        if (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4)
          goto bad_alignment;
        alignbits = 3;
        break;
d15745 2
a15746 2
        first_error (_("bad alignment"));
        return;
d15758 1
a15758 1
        | (((inst.instruction >> 8) & 3) << 3);
d15791 1
a15791 1
        break;
d15795 1
a15795 1
        result = SUCCESS;
d15823 1
a15823 1
              _("bad list length"));
d15825 1
a15825 1
              _("scalar index out of range"));
d15827 2
a15828 2
              && et.size == 8,
              _("stride of 2 unavailable when element size is 8"));
d15834 1
a15834 1
                                       32, 32, -1);
d15836 1
a15836 1
        return;
d15838 10
a15847 10
        {
          unsigned alignbits = 0;
          switch (et.size)
            {
            case 16: alignbits = 0x1; break;
            case 32: alignbits = 0x3; break;
            default: ;
            }
          inst.instruction |= alignbits << 4;
        }
d15852 1
a15852 1
                                       32, 64, -1);
d15854 1
a15854 1
        return;
d15856 1
a15856 1
        inst.instruction |= 1 << 4;
d15861 1
a15861 1
                  _("can't use alignment with this instruction"));
d15866 1
a15866 1
                                       16, 64, 32, 64, 32, 128, -1);
d15868 1
a15868 1
        return;
d15870 11
a15880 11
        {
          unsigned alignbits = 0;
          switch (et.size)
            {
            case 8:  alignbits = 0x1; break;
            case 16: alignbits = 0x1; break;
            case 32: alignbits = (align == 64) ? 0x1 : 0x2; break;
            default: ;
            }
          inst.instruction |= alignbits << 4;
        }
d15910 1
a15910 1
                                       &do_align, 16, 16, 32, 32, -1);
d15912 1
a15912 1
        return;
d15914 5
a15918 5
        {
        case 1: break;
        case 2: inst.instruction |= 1 << 5; break;
        default: first_error (_("bad list length")); return;
        }
d15924 1
a15924 1
                                       &do_align, 8, 16, 16, 32, 32, 64, -1);
d15926 1
a15926 1
        return;
d15928 1
a15928 1
                  _("bad list length"));
d15930 1
a15930 1
        inst.instruction |= 1 << 5;
d15936 1
a15936 1
                  _("can't use alignment with this instruction"));
d15938 1
a15938 1
                  _("bad list length"));
d15940 1
a15940 1
        inst.instruction |= 1 << 5;
d15946 13
a15958 13
        int align = inst.operands[1].imm >> 8;
        align_good = neon_alignment_bit (et.size, align, &do_align, 8, 32,
                                         16, 64, 32, 64, 32, 128, -1);
        if (align_good == FAIL)
          return;
        constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4,
                    _("bad list length"));
        if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
          inst.instruction |= 1 << 5;
        if (et.size == 32 && align == 128)
          inst.instruction |= 0x3 << 6;
        else
          inst.instruction |= neon_logbits (et.size) << 6;
d16008 1
a16008 1
                  _("post-index must be a register"));
d16010 1
a16010 1
                  _("bad register for post-index"));
d16392 6
a16397 6
             refer to in the object file.  Unfortunately for us, gas's
             generic expression parsing will already have folded out
             any use of .set foo/.type foo %function that may have
             been used to set type information of the target location,
             that's being specified symbolically.  We have to presume
             the user knows what they are doing.  */
d16416 1
a16416 1
                             (enum bfd_reloc_code_real) reloc);
d16421 1
a16421 1
                                  pc_rel, (enum bfd_reloc_code_real) reloc);
d16548 2
a16549 2
                           suffix, others place 0xF where the condition field
                           would be.  */
d16649 1
a16649 1
         use.  */
d16655 1
a16655 1
        offset = 0;
d16664 2
a16665 2
             non-unified ARM syntax mode).  */
          if (parse_neon_type (&inst.vectype, str) == FAIL)
d16667 1
a16667 1
        }
d16669 1
a16669 1
        return NULL;
d16676 1
a16676 1
                                                    end - base);
d16705 1
a16705 1
                                                    affix - base);
d16723 1
a16723 1
        case OT_csuffixF:
d16759 1
a16759 1
                                                    (end - base) - 2);
d16821 1
a16821 1
                                              | ((bitvalue) << (nbit)))
d16826 2
a16827 2
                                   resulting_bit,
                                  (5 - now_it.block_length));
d16829 2
a16830 2
                                   1,
                                   ((5 - now_it.block_length) - 1) );
d16847 2
a16848 2
        initializing the IT insn type with a generic initial value depending
        on the inst.condition.
d16850 36
a16885 36
        a) The tencode function overrides the IT insn type by
           calling either set_it_insn_type (type) or set_it_insn_type_last ().
        b) The tencode function queries the IT block state by
           calling in_it_block () (i.e. to determine narrow/not narrow mode).

        Both set_it_insn_type and in_it_block run the internal FSM state
        handling function (handle_it_state), because: a) setting the IT insn
        type may incur in an invalid state (exiting the function),
        and b) querying the state requires the FSM to be updated.
        Specifically we want to avoid creating an IT block for conditional
        branches, so it_fsm_pre_encode is actually a guess and we can't
        determine whether an IT block is required until the tencode () routine
        has decided what type of instruction this actually it.
        Because of this, if set_it_insn_type and in_it_block have to be used,
        set_it_insn_type has to be called first.

        set_it_insn_type_last () is a wrapper of set_it_insn_type (type), that
        determines the insn IT type depending on the inst.cond code.
        When a tencode () routine encodes an instruction that can be
        either outside an IT block, or, in the case of being inside, has to be
        the last one, set_it_insn_type_last () will determine the proper
        IT instruction type based on the inst.cond code. Otherwise,
        set_it_insn_type can be called for overriding that logic or
        for covering other cases.

        Calling handle_it_state () may not transition the IT block state to
        OUTSIDE_IT_BLOCK immediatelly, since the (current) state could be
        still queried. Instead, if the FSM determines that the state should
        be transitioned to OUTSIDE_IT_BLOCK, a flag is marked to be closed
        after the tencode () function: that's what it_fsm_post_encode () does.

        Since in_it_block () calls the state handling function to get an
        updated state, an error may occur (due to invalid insns combination).
        In that case, inst.error is set.
        Therefore, inst.error has to be checked after the execution of
        the tencode () routine.
d16888 2
a16889 2
        any pending state change (if any) that didn't take place in
        handle_it_state () as explained above.  */
d17182 1
a17182 1
          && ! create_neon_reg_alias (str, p))
d17242 4
a17245 4
        {
          /* Prepare the it_insn_type for those encodings that don't set
             it.  */
          it_fsm_pre_encode ();
d17247 1
a17247 1
          opcode->tencode ();
d17249 2
a17250 2
          it_fsm_post_encode ();
        }
d17264 1
a17264 1
         instruction.  */
d17315 5
a17319 5
        {
          it_fsm_pre_encode ();
          opcode->aencode ();
          it_fsm_post_encode ();
        }
d17321 1
a17321 1
         on a hypothetical non-thumb v5 core.  */
d17733 1
a17733 1
  	{ "TLSDESC", BFD_RELOC_ARM_TLS_GOTDESC},
d17735 1
a17735 1
  	{ "TLSCALL", BFD_RELOC_ARM_TLS_CALL},
d17737 1
a17737 1
  	{ "TLSDESCSEQ", BFD_RELOC_ARM_TLS_DESCSEQ}
d20523 2
a20524 2
        _("alignments greater than %d bytes not supported in .text sections."),
        MAX_MEM_FOR_RS_ALIGN_CODE + 1);
d20635 1
a20635 1
                                                     unwind.opcode_alloc);
d21065 2
a21066 2
 	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
 	base = fixP->fx_where + fixP->fx_frag->fr_address;
d21075 3
a21077 3
 	  && THUMB_IS_FUNC (fixP->fx_addsy)
 	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
 	base = fixP->fx_where + fixP->fx_frag->fr_address;
d21086 3
a21088 3
 	  && ARM_IS_FUNC (fixP->fx_addsy)
 	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
 	base = fixP->fx_where + fixP->fx_frag->fr_address;
d21095 3
a21097 3
 	  && THUMB_IS_FUNC (fixP->fx_addsy)
 	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
 	base = fixP->fx_where + fixP->fx_frag->fr_address;
d21105 1
a21105 1
         discovered the value of a symbol, or the address of the frag involved
d21107 3
a21109 3
         see fixup_segment() in write.c
         The S_IS_EXTERNAL test handles the case of global symbols.
         Those need the calculated base, not just the pipe compensation the linker will need.  */
d21677 1
a21677 1
	                                           *4, optional writeback(W)
d21988 1
a21988 1
         fixP->fx_r_type = BFD_RELOC_ARM_PCREL_CALL;
d22023 2
a22024 2
         (which, strictly speaking, are prohibited) will be turned into
         no-ops.
d22039 1
a22039 1
          if (fixP->fx_done || !seg->use_rela_p)
d22220 1
a22220 1
        md_number_to_chars (buf, value, 4);
d22225 2
a22226 2
         addend here for REL targets, because it won't be written out
         during reloc processing later.  */
d22531 8
a22538 8
         bfd_vma insn;
         bfd_vma encoded_addend;
         bfd_vma addend_abs = abs (value);

         /* Check that the absolute value of the addend can be
            expressed as an 8-bit constant plus a rotation.  */
         encoded_addend = encode_arm_immediate (addend_abs);
         if (encoded_addend == (unsigned int) FAIL)
d22540 2
a22541 2
	                 _("the offset 0x%08lX is not representable"),
                         (unsigned long) addend_abs);
d22543 2
a22544 2
         /* Extract the instruction.  */
         insn = md_chars_to_number (buf, INSN_SIZE);
d22546 12
a22557 12
         /* If the addend is positive, use an ADD instruction.
            Otherwise use a SUB.  Take care not to destroy the S bit.  */
         insn &= 0xff1fffff;
         if (value < 0)
           insn |= 1 << 22;
         else
           insn |= 1 << 23;

         /* Place the encoded addend into the first 12 bits of the
            instruction.  */
         insn &= 0xfffff000;
         insn |= encoded_addend;
d22559 2
a22560 2
         /* Update the instruction.  */
         md_number_to_chars (buf, insn, INSN_SIZE);
d22572 7
a22578 7
        {
          bfd_vma insn;
          bfd_vma addend_abs = abs (value);

          /* Check that the absolute value of the addend can be
             encoded in 12 bits.  */
          if (addend_abs >= 0x1000)
d22580 12
a22591 2
	  	          _("bad offset 0x%08lX (only 12 bits available for the magnitude)"),
                          (unsigned long) addend_abs);
d22593 4
a22596 2
          /* Extract the instruction.  */
          insn = md_chars_to_number (buf, INSN_SIZE);
d22598 3
a22600 15
          /* If the addend is negative, clear bit 23 of the instruction.
             Otherwise set it.  */
          if (value < 0)
            insn &= ~(1 << 23);
          else
            insn |= 1 << 23;

          /* Place the absolute value of the addend into the first 12 bits
             of the instruction.  */
          insn &= 0xfffff000;
          insn |= addend_abs;

          /* Update the instruction.  */
          md_number_to_chars (buf, insn, INSN_SIZE);
        }
d22611 7
a22617 7
        {
          bfd_vma insn;
          bfd_vma addend_abs = abs (value);

          /* Check that the absolute value of the addend can be
             encoded in 8 bits.  */
          if (addend_abs >= 0x100)
d22619 2
a22620 2
	  	          _("bad offset 0x%08lX (only 8 bits available for the magnitude)"),
                          (unsigned long) addend_abs);
d22622 2
a22623 2
          /* Extract the instruction.  */
          insn = md_chars_to_number (buf, INSN_SIZE);
d22625 16
a22640 16
          /* If the addend is negative, clear bit 23 of the instruction.
             Otherwise set it.  */
          if (value < 0)
            insn &= ~(1 << 23);
          else
            insn |= 1 << 23;

          /* Place the first four bits of the absolute value of the addend
             into the first 4 bits of the instruction, and the remaining
             four into bits 8 .. 11.  */
          insn &= 0xfffff0f0;
          insn |= (addend_abs & 0xf) | ((addend_abs & 0xf0) << 4);

          /* Update the instruction.  */
          md_number_to_chars (buf, insn, INSN_SIZE);
        }
d22651 7
a22657 7
        {
          bfd_vma insn;
          bfd_vma addend_abs = abs (value);

          /* Check that the absolute value of the addend is a multiple of
             four and, when divided by four, fits in 8 bits.  */
          if (addend_abs & 0x3)
d22659 2
a22660 2
	  	          _("bad offset 0x%08lX (must be word-aligned)"),
                          (unsigned long) addend_abs);
d22662 1
a22662 1
          if ((addend_abs >> 2) > 0xff)
d22664 5
a22668 2
	  	          _("bad offset 0x%08lX (must be an 8-bit number of words)"),
                          (unsigned long) addend_abs);
d22670 11
a22680 2
          /* Extract the instruction.  */
          insn = md_chars_to_number (buf, INSN_SIZE);
d22682 3
a22684 15
          /* If the addend is negative, clear bit 23 of the instruction.
             Otherwise set it.  */
          if (value < 0)
            insn &= ~(1 << 23);
          else
            insn |= 1 << 23;

          /* Place the addend (divided by four) into the first eight
             bits of the instruction.  */
          insn &= 0xfffffff0;
          insn |= addend_abs >> 2;

          /* Update the instruction.  */
          md_number_to_chars (buf, insn, INSN_SIZE);
        }
d23412 1
a23412 1
                 (void *) (v7m_psrs + i));
d23971 1
a23971 1
                                                        | FPU_NEON_EXT_V1),
d23975 1
a23975 1
                                                        | FPU_NEON_EXT_V1),
d23984 1
a23984 1
	                                                          "Cortex-A53"),
d23986 1
a23986 1
	                                                          "Cortex-A57"),
d24011 1
a24011 1
	       					FPU_ARCH_VFP_V3D16, NULL),
d24101 1
a24101 1
                        ARM_FEATURE (0, ARM_CEXT_MAVERICK),	ARM_ANY),
d24470 1
a24470 1
                "arm, thumb, always, or never."), str);
d24702 1
a24702 1
        ARM_CLEAR_FEATURE (flags, flags, arm_ext_os);
d24793 1
a24793 1
           || ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1xd))
@


1.571
log
@2013-06-19  Greta Yorsh  <Greta.Yorsh@@arm.com>

	* config/tc-arm.c (arm_cpus): Add support for Cortex-A12.
@
text
@d12016 2
@


1.570
log
@	* config/tc-arm.c (symbol_preemptible): New function.
	(relax_branch): Use it.
@
text
@d23970 3
@


1.569
log
@gas/
2013-05-28  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* config/tc-arm.c (it_fsm_post_encode): Improve
	warning messages about deprecated IT block formats.

gas/testsuite
2013-05-28  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* gas/arm/armv8-a-bad.l: Update expected warning message.
	* gas/arm/armv8-a-it-bad.l: Likewise.
@
text
@d20218 24
d20260 1
d20264 1
d20266 1
a20266 4
  /* PR 12532.  Global symbols with default visibility might
     be preempted, so do not relax relocations to them.  */
  if ((ELF_ST_VISIBILITY (S_GET_OTHER (fragp->fr_symbol)) == STV_DEFAULT)
      && (! S_IS_LOCAL (fragp->fr_symbol)))
a20267 1
#endif
@


1.568
log
@gas/
2013-04-10  Jan Beulich <jbeulich@@suse.com>

	* gas/config/tc-arm.c (encode_arm_addr_mode_3): Only reject base
	register being PC when is_t or writeback, and use distinct
	diagnostic for the latter case.

gas/testsuite/
2013-04-10  Jan Beulich <jbeulich@@suse.com>

	* gas/testsuite/gas/arm/ldst-pc.s: Add index, non-writeback
	forms of various loads and stores with PC as base.
	* gas/testsuite/gas/arm/ldst-pc.d: Update accordingly.
@
text
@d17093 1
a17093 1
	  as_warn (_("it blocks containing wide Thumb instructions are "
d17105 1
a17105 1
		  as_warn (_("it blocks containing 16-bit Thumb intsructions "
d17118 2
a17119 2
	  as_warn (_("it blocks of more than one conditional instruction are "
		     "deprecated in ARMv8"));
@


1.567
log
@gas/
2013-04-10  Jan Beulich <jbeulich@@suse.com>

	* gas/config/tc-arm.c (parse_operands): Re-write
	po_barrier_or_imm().
	(do_barrier): Remove bogus constraint().
	(do_t_barrier): Remove.

gas/testsuite/
2013-04-10  Jan Beulich <jbeulich@@suse.com>

	* gas/arm/barrier-bad.d: Change title.
	* gas/arm/barrier-bad.s: Add immediate form of ISB and DSB as
	well as one symbolic form of DSB.
	* gas/arm/barrier-bad.l: Update accordingly.
	* gas/arm/barrier-bad-thumb.d: Adjust title. Use barrier-bad.s as
	source. Pass -mthumb to gas.
	* gas/arm/barrier-bad-thumb.l: Remove.
	* gas/arm/barrier-bad-thumb.s: Remove.
	* gas/arm/barrier-thumb.d: Adjust title. Use barrier.s as source.
	Pass -mthumb to gas.
	* gas/arm/barrier-thumb.s: Remove.
@
text
@d7199 1
a7199 1
		   || inst.operands[i].reg == REG_PC),
d7201 2
@


1.566
log
@gas/
2013-04-09  Jan Beulich <jbeulich@@suse.com>

	* gas/config/tc-arm.c (do_vmrs): Accept all control registers.
	Use local variable Rt in more places.
	(do_vmsr): Accept all control registers.

gas/testsuite/
2013-04-09  Jan Beulich <jbeulich@@suse.com>

	* gas/arm/vfp1xD.s: Add VMRS/VMSR tests with FPINST, FPINST2,
	and C15.
	* gas/arm/vfp1xD.d: Update accordingly.
@
text
@d6341 6
a6346 1
      if (val == FAIL)					   \
d6348 3
a6350 14
	  if (ISALPHA (*str))				   \
	      goto failure;				   \
	  else						   \
	      goto immediate;				   \
	}						   \
      else						   \
	{						   \
	  if ((inst.instruction & 0xf0) == 0x60		   \
	      && val != 0xf)				   \
	    {						   \
	       /* ISB can only take SY as an option.  */   \
	       inst.error = _("invalid barrier type");	   \
	       goto failure;				   \
	    }						   \
d7538 1
a7538 7
    {
      constraint ((inst.instruction & 0xf0) != 0x40
		  && inst.operands[0].imm > 0xf
		  && inst.operands[0].imm < 0x0,
		  _("bad barrier type"));
      inst.instruction |= inst.operands[0].imm;
    }
a10041 15
do_t_barrier (void)
{
  if (inst.operands[0].present)
    {
      constraint ((inst.instruction & 0xf0) != 0x40
		  && inst.operands[0].imm > 0xf
		  && inst.operands[0].imm < 0x0,
		  _("bad barrier type"));
      inst.instruction |= inst.operands[0].imm;
    }
  else
    inst.instruction |= 0xf;
}

static void
d18486 3
a18488 3
 TUF("dmb",	57ff050, f3bf8f50, 1, (oBARRIER_I15), barrier,  t_barrier),
 TUF("dsb",	57ff040, f3bf8f40, 1, (oBARRIER_I15), barrier,  t_barrier),
 TUF("isb",	57ff060, f3bf8f60, 1, (oBARRIER_I15), barrier,  t_barrier),
@


1.565
log
@gas/
2013-04-09  Jan Beulich <jbeulich@@suse.com>

	* gas/config/tc-arm.c (do_neon_mov): Fake an instruction suffix
	if there was none specified for moves between scalar and core
	register.

gas/testsuite/
2013-04-09  Jan Beulich <jbeulich@@suse.com>

	* gas/arm/neon-omit.s: Add tests for suffix less VMOV.
	* gas/arm/neon-omit.d: Update accordingly.
@
text
@d8259 1
a8259 1
  if (thumb_mode && inst.operands[0].reg == REG_SP)
d8266 1
a8266 1
  if (!inst.operands[0].isvec && inst.operands[0].reg == REG_PC)
d8272 3
a8274 13
  switch (inst.operands[1].reg)
    {
    case 0: /* FPSID */
    case 1: /* FPSCR */
    case 6: /* MVFR1 */
    case 7: /* MVFR0 */
    case 8: /* FPEXC */
      inst.instruction |= (inst.operands[1].reg << 16);
      break;
    default:
      first_error (_("operand 1 must be a VFP extension System Register"));
    }

d8291 3
a8293 11
  switch (inst.operands[0].reg)
    {
    case 0: /* FPSID  */
    case 1: /* FPSCR  */
    case 8: /* FPEXC */
      inst.instruction |= (inst.operands[0].reg << 16);
      break;
    default:
      first_error (_("operand 0 must be FPSID or FPSCR pr FPEXC"));
    }

@


1.564
log
@gas/
2013-04-09  Jan Beulich <jbeulich@@suse.com>

	* gas/config/tc-arm.c (do_neon_ldx_stx): Reject VSTn in the
	NEON_ALL_LANES case.

gas/testsuite/
2013-04-09  Jan Beulich <jbeulich@@suse.com>

	* gas/arm/neon-addressing-bad.s: Add test for further invalid VST
	operands.
	* gas/arm/neon-addressing-bad.l: Update accordingly.
@
text
@d15363 10
d15422 10
@


1.563
log
@gas/
2013-04-08  Jan Beulich <jbeulich@@suse.com>

	* gas/config/tc-arm.c (do_neon_ldr_str): Correct disgnostics for
	PC-relative VSTR.
@
text
@d16002 5
@


1.562
log
@gas/
2013-04-08  Jan Beulich <jbeulich@@suse.com>

	* gas/config/tc-arm.c (reg_names): Convert duplicate SP_fiq
	entry to sp_fiq.
@
text
@d15695 3
a15697 1
      if (!thumb_mode && warn_on_deprecated)
a15698 2
      else
	inst.error = _("Use of PC here is UNPREDICTABLE");
@


1.561
log
@Add support for Cortex-A53 and Cortex-A57.
@
text
@d17541 1
a17541 1
  REGDEF(SP_fiq,512|(13<<16),RNB), REGDEF(SP_fiq,512|(13<<16),RNB),
@


1.560
log
@gas/ChangeLog:

2013-03-21  Will Newton  <will.newton@@linaro.org>

	* config/tc-arm.c (encode_thumb32_addr_mode): Emit an error for all
	pc-relative str instructions in Thumb mode.

gas/testsuite/ChangeLog:

2013-03-21  Will Newton  <will.newton@@linaro.org>

	* gas/arm/thumb2_relax.d: Strip out invalid pc-relative strs.
	* gas/arm/thumb2_relax.s: Likewise.
	* gas/arm/thumb32.d: Likewise.
	* gas/arm/thumb32.l: Likewise.
	* gas/arm/thumb32.s: Likewise.
	* gas/arm/thumb2_str-bad.d: New file.
	* gas/arm/thumb2_str-bad.l: Likewise.
	* gas/arm/thumb2_str-bad.s: Likewise.
@
text
@d23969 4
@


1.559
log
@
gas/ChangeLog:

2013-03-12  Will Newton  <will.newton@@linaro.org>

	* config/tc-arm.c (do_neon_ldr_str): Fix error check for PC register
	in vstr in Thumb mode for pre-ARMv7 cores.

gas/testsuite/ChangeLog:

2013-03-12  Will Newton  <will.newton@@linaro.org>

	* gas/arm/vstr-thumb-bad.d: Assemble with -mcpu=arm1156t2f-s.
@
text
@d9474 2
a9475 2
      constraint (is_pc && ((inst.instruction & THUMB2_LOAD_BIT) == 0)
		  && !inst.reloc.pc_rel, BAD_PC_ADDRESSING);
@


1.558
log
@	PR gas/15273
	* config/tc-arm.c (do_co_reg): Do not call check_obsolete with a
	NULL message, instead just check ARM_CPU_IS_ANY directly.
@
text
@d15693 1
a15693 1
      && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v7))
@


1.557
log
@Add support for AArch32 CRC instruction in ARMv8.

gas/ChangeLog
2013-03-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* config/tc-arm.c (crc_ext_armv8): New feature set.
	(UNPRED_REG): New macro.
	(do_crc32_1): New function.
	(do_crc32b, do_crc32h, do_crc32w, do_crc32cb,
	do_crc32ch, do_crc32cw): Likewise.
	(TUEc): New macro.
	(insns): Add entries for crc32 mnemonics.
	(arm_extensions): Add entry for crc.

include/opcode/ChangeLog
2013-03-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* arm.h (CRC_EXT_ARMV8): New constant.
	(ARCH_CRC_ARMV8): New macro.

opcodes/ChangeLog
2013-03-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* arm-dis.c (arm_opcodes): Add entries for CRC instructions.
	(thumb32_opcodes): Likewise.
	(print_insn_thumb32): Handle 'S' control char.

gas/testsuite/ChangeLog
2013-03-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* gas/arm/crc32-bad.d: New file.
	* gas/arm/crc32-bad.l: Likewise.
	* gas/arm/crc32-bad.s: Likewise.
	* gas/arm/crc32.d: Likewise.
	* gas/arm/crc32.s: Likewise.
@
text
@d7831 1
a7831 1
	    if (!check_obsolete (&r->obsoleted, r->obs_msg)
@


1.556
log
@2013-02-25  Terry Guo  <terry.guo@@arm.com>

	* config/tc-arm.c (arm_cpus): Add cortex-r7 entry.
	* doc/c-arm.texi: Add cortex-r7 and missing cortex-r5 to
	list of accepted CPUs.
@
text
@d241 2
d753 1
d16320 57
d17862 7
d18607 11
d24072 1
@


1.555
log
@        * gas/arm/neon-vmov-bad.d: New file.
        * gas/arm/neon-vmov-bad.s: Likewise.
        * gas/arm/neon-vmov-bad.l: Likewise.

        * config/tc-arm.c (do_neon_mov): Break on NS_NULL.
@
text
@d23896 3
@


1.554
log
@Fix snafu.
@
text
@d15497 5
@


1.553
log
@* gas/config/tc-arm.c (arm_cpus): Add support for mcpu=marvell-pj4 core.
@
text
@d23906 1
a23906 1
  ARM_CPU_OPT ("marvell-pj4",   ARM_FEATURE (ARM_AEXT_V7A|ARM_EXT_MP|ARM_EXT_SEC),
@


1.552
log
@gas/
	* config/tc-arm.c (md_apply_fix): Use as_bad_where for "bad
	immediate value for 8-bit offset" error so it shows line info.
@
text
@d2 1
a2 3
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
d23904 5
a23908 2
						 FPU_ARCH_MAVERICK,
								  "ARM920T"),
@


1.551
log
@	PR gas/14887
	* config/tc-arm.c (skip_past_char): Skip whitespace before the
	anticipated character.
	* config/tc-arm.c (parse_address_main): Delete skip of whitespace
	here as it is no longer needed.

	PR gas/14887
	* gas/arm/neon-ldst-es.s: Add more whitespace.
@
text
@d890 1
a890 1
  
d21552 3
a21554 2
	    as_bad (_("bad immediate value for 8-bit offset (%ld)"),
		    (long) value);
@


1.550
log
@	PR gas/14987
	* gas/arm/neon-ldst-es.s: Add whitespace test.
	* gas/arm/neon-ldst-es.d: Update expected disassembly.

	* config/tc-arm.c (parse_address_main): Skip whitespace before a
	closing bracket.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d888 3
d5174 3
a5299 3
  /* PR gas/14987: Allow for whitespace before the closing bracket.  */
  skip_whitespace (p);

@


1.549
log
@2012-12-20  Greta Yorsh  <Greta.Yorsh@@arm.com>

	* config/tc-arm.c (rfefa,rfeea,rfeed): Fix encoding.
	(rfe,srs,srsea,srsfa,srsed,srsfd): Add missing mnemonics.

	* gas/arm/srs-t2.s: Add tests for missing srs modes.
	* gas/arm/srs-t2.l: Update expected output.
	* gas/arm/srs-arm.s: Add tests for missing srs modes.
	* gas/arm/srs-arm.l: Update expected output.
	* gas/arm/archv6.s: Add tests for missing rfe modes.
	* gas/arm/archv6.d: Update expected output.
@
text
@d5294 3
@


1.548
log
@    gas/
    * config/tc-arm.c (md_apply_fix): Fix conversion of BL to BLX for
    local targets in Thumb mode.

    gas/testsuite/
    * gas/arm/bl-local-2.s: New test.
    * gas/arm/bl-local-2.d: New.
@
text
@d18192 1
d18197 3
a18199 3
  UF(rfefa,	9900a00,           1, (RRw),			   rfe),
  UF(rfeea,	8100a00,           1, (RRw),			   rfe),
 TUF("rfeed",	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
d18201 2
d18204 1
d18206 1
d18208 1
@


1.547
log
@gas/
	* config/tc-arm.c (arm_symbol_chars): New variable.
	* config/tc-arm.h (tc_symbol_chars): New macro, defined to that.

gas/testsuite/
	* gas/arm/macro-pld.s: New file.
	* gas/arm/macro-pld.d: New file.
@
text
@d22043 7
a22055 7
      if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	/* For a BLX instruction, make sure that the relocation is rounded up
	   to a word boundary.  This follows the semantics of the instruction
	   which specifies that bit 1 of the target address will come from bit
	   1 of the base address.  */
	value = (value + 1) & ~ 1;

@


1.546
log
@	* read.h (s_vendor_attribute): Move to...
	* config/obj-elf.h (obj_elf_vendor_attribute): ... here.
	* read.c (potable): Remove "gnu_attribute".
	(skip_whitespace, skip_past_char, skip_past_comma): Delete, move
	to config/obj-elf.c.
	(s_vendor_attribute): Delete, move to obj_elf_vendor_attribute
	in config/obj-elf.c.
	(s_gnu_attribute): Delete, move to obj_elf_gnu_attribute in
	config/obj-elf.c.
	* config/obj-elf.c (elf_pseudo_table): Add "gnu_attribute".
	(skip_whitespace, skip_past_char, skip_past_comma): New, moved
	from read.c.
	(obj_elf_vendor_attribute): New, moved from s_vendor_attribute
	in read.c.
	(obj_elf_gnu_attribute): New, moved from s_gnu_attribute in
	read.c.
	* config/tc-arm.c (s_arm_eabi_attribute): Rename
	s_vendor_attribute to obj_elf_vendor_attribute.
	* config/tc-tic6x.c (s_tic6x_c6xabi_attribute): Likewise.
@
text
@d324 5
d10233 1
a10233 1
   between the two is the maximum immediate allowed - which is passed in 
d14668 1
a14668 1
do_vfp_nsyn_cvt_fpv8 (enum neon_cvt_flavour flavour, 
d14728 3
a14730 3
      && (flavour == neon_cvt_flavour_s32_f32 
	  || flavour == neon_cvt_flavour_u32_f32 
	  || flavour == neon_cvt_flavour_s32_f64 
@


1.545
log
@2012-10-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* config/tc-arm.c: Change condition code insertion for
	lds[hb] instructions from after the 2nd character to after the 3rd.
	(tCM): Remove macro.
	(TxCM): Likewise.
	(TxCM_): Likewise.
	(TCM): Likewise.

2012-10-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* gas/arm/ldgesb-bad.d: New file.
	* gas/arm/ldgesb-bad.l: Likewise.
	* gas/arm/ldgesb-bad.s: Likewise.
	* gas/arm/ldgesh-bad.d: Likewise.
	* gas/arm/ldgesh-bad.l: Likewise.
	* gas/arm/ldgesh-bad.s: Likewise.
	* gas/arm/ldsgeb.d: Likewise.
	* gas/arm/ldsgeb.s: Likewise.
	* gas/arm/ldsgeb.l: Likewise.
	* gas/arm/ldsgeh.d: Likewise.
	* gas/arm/ldsgeh.s: Likewise.
	* gas/arm/ldsgeh.l: Likewise.
@
text
@d4339 1
a4339 1
  int tag = s_vendor_attribute (OBJ_ATTR_PROC);
@


1.544
log
@2012-09-18  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>
opcodes:
	* arm-dis.c: Changed ldra and strl-form mnemonics
	to lda and stl-form.
gas:
	* config/tc-arm.c: Changed ldra and strl-form mnemonics
	to lda and stl-form for armv8.
gas/testsuite:
	* gas/arm/armv8-a-bad.l: Updated for changed mnemonics.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.
	* gas/arm/inst.s: Added test for ldrt encoding compatibly with ldralt.
	* gas/arm/inst.d: Updated.
@
text
@a17780 32
/* Mnemonic with a conditional infix in an unusual place.  Each and every variant has to
   appear in the condition table.  */
#define TxCM_(m1, m2, m3, op, top, nops, ops, ae, te)	\
  { m1 #m2 m3, OPS##nops ops, sizeof (#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof (m1) - 1, \
    0x##op, top, ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##te }

#define TxCM(m1, m2, op, top, nops, ops, ae, te)	\
  TxCM_ (m1,   , m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, eq, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, ne, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, cs, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, hs, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, cc, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, ul, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, lo, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, mi, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, pl, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, vs, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, vc, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, hi, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, ls, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, ge, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, lt, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, gt, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, le, m2, op, top, nops, ops, ae, te),	\
  TxCM_ (m1, al, m2, op, top, nops, ops, ae, te)

#define TCM(m1,m2, aop, top, nops, ops, ae, te)		\
      TxCM (m1,m2, aop, 0x##top, nops, ops, ae, te)
#define tCM(m1,m2, aop, top, nops, ops, ae, te)		\
      TxCM (m1,m2, aop, T_MNEM##top, nops, ops, ae, te)

d18072 2
a18073 2
 tCM("ld","sh",	01000f0, _ldrsh,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
 tCM("ld","sb",	01000d0, _ldrsb,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
a19751 1
#undef TCM
@


1.543
log
@	* gas/config/tc-arm.c (ARM_ENC_TAB): Add sha1h and sha2op entries.
	(do_sha1h): New function.
	(do_sha1su1): Likewise.
	(do_sha256su0): Likewise.
	(insns): Add 2 operand SHA instructions.
	* gas/testsuite/gas/arm/armv8-a+crypto.s: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+crypto.d: Likewise.
	* opcodes/arm-dis.c (neon_opcodes): Add 2 operand sha instructions.
@
text
@d8741 1
a8741 1
do_strlex (void)
d8750 1
a8750 1
do_t_strlex (void)
d18479 2
a18480 2
 TCE("ldraex",	1900e9f, e8d00fef, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
 TCE("ldraexd",	1b00e9f, e8d000ff, 3, (RRnpc, oRRnpc, RRnpcb),
d18482 5
a18486 5
 TCE("ldraexb",	1d00e9f, e8d00fcf, 2, (RRnpc,RRnpcb),	rd_rn,  rd_rn),
 TCE("ldraexh",	1f00e9f, e8d00fdf, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("strlex",	1800e90, e8c00fe0, 3, (RRnpc, RRnpc, RRnpcb),
							strlex,  t_strlex),
 TCE("strlexd",	1a00e90, e8c000f0, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb),
d18488 10
a18497 10
 TCE("strlexb",	1c00e90, e8c00fc0, 3, (RRnpc, RRnpc, RRnpcb),
							strlex, t_strlex),
 TCE("strlexh",	1e00e90, e8c00fd0, 3, (RRnpc, RRnpc, RRnpcb),
							strlex, t_strlex),
 TCE("ldra",	1900c9f, e8d00faf, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
 TCE("ldrab",	1d00c9f, e8d00f8f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("ldrah",	1f00c9f, e8d00f9f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("strl",	180fc90, e8c00faf, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
 TCE("strlb",	1c0fc90, e8c00f8f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
 TCE("strlh",	1e0fc90, e8c00f9f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
@


1.542
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add sha3op entry.
	(do_crypto_3op_1): New function.
	(do_sha1c): Likewise.
	(do_sha1p): Likewise.
	(do_sha1m): Likewise.
	(do_sha1su0): Likewise.
	(do_sha256h): Likewise.
	(do_sha256h2): Likewise.
	(do_sha256su1): Likewise.
	(insns): Add SHA 3 operand instructions.
	* gas/testsuite/gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+crypto.s: Likewise.
	* opcodes/arm-dis.c (neon_opcodes): Add SHA 3-operand instructions.
@
text
@d12355 3
a12357 1
  X(sha3op,	0x2000c00, N_INV,     N_INV)
d16285 18
d18547 3
@


1.541
log
@	* gas/config/tc-arm.c (neon_type_mask): Add P64 type.
	(type_chk_of_el_type): Handle P64 type.
	(el_type_of_type_chk): Likewise.
	(do_neon_vmull): Handle VMULL.P64.
	* gas/testsuite/gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+crypto.s: Likewise.
	* opcodes/arm-dis.c (neon_opcodes): Handle VMULL.P64.
@
text
@d12354 2
a12355 1
  X(aes,	0x3b00300, N_INV,     N_INV)
d16204 15
d16242 23
d16266 17
d18520 7
a18526 1

@


1.540
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add aes entry.
	(neon_type_mask): Add N_UNT.
	(neon_check_type): Don't always decay typed to untyped sizes.
	(do_crypto_2op_1): New function.
	(do_aese): Likewise.
	(do_aesd): Likewise.
	(do_aesmc.8): Likewise.
	(do_aesimc.8): Likewise.
	(insns): Add AES instructions.
	* gas/testsuite/gas/arm/armv8-a+crypto.d: New testcase.
	* gas/testsuite/gas/arm/armv8-a+crypto.s: Likewise.
	* opcodes/arm-dis.c (neon_opcodes): Add support for AES instructions.
@
text
@d12573 1
d12586 1
a12586 1
  N_MAX_NONSPECIAL = N_F64
d12794 1
d12843 1
a12843 1
  else if ((mask & (N_S64 | N_U64 | N_I64 | N_64 | N_F64)) != 0)
d12856 1
a12856 1
  else if ((mask & (N_P8 | N_P16)) != 0)
d15125 2
a15126 1
        N_EQK | N_DBL, N_EQK, N_SU_32 | N_P8 | N_KEY);
d15131 14
a15144 2
      /* For polynomial encoding, size field must be 0b00 and the U bit must be
         zero. Should be OK as-is.  */
@


1.539
log
@	* gas/config/tc-arm.c (el_type_type_check): Add handling for 16-bit
	floating point types.
	(do_neon_cvttb_2): New function.
	(do_neon_cvttb_1): Likewise.
	(do_neon_cvtb): Refactor to use do_neon_cvttb_1.
	(do_neon_cvtt): Likewise.
	* gas/testsuite/gas/arm/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/arm/half-prec-vfpv3.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add support for HP/DP
	conversions.
@
text
@d12353 2
a12354 1
  X(vrinta,	0xeb80a40, 0x3ba0400, N_INV)
d12576 1
d13004 5
a13008 4
          if ((g_size == 8 && (types_allowed & N_8) != 0)
	      || (g_size == 16 && (types_allowed & N_16) != 0)
	      || (g_size == 32 && (types_allowed & N_32) != 0)
	      || (g_size == 64 && (types_allowed & N_64) != 0))
d16161 51
d18439 12
@


1.538
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add vrint entries.
	(neon_cvt_mode): Add neon_cvt_mode_r.
	(do_vrint_1): New function.
	(do_vrint_x): Likewise.
	(do_vrint_z): Likewise.
	(do_vrint_r): Likewise.
	(do_vrint_a): Likewise.
	(do_vrint_n): Likewise.
	(do_vrint_p): Likewise.
	(do_vrint_m): Likewise.
	(insns): Add VRINT instructions.
	* gas/testsuite/gas/arm/armv8-a+fpv5.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+fpv5.s: Likewise.
	* gas/testsuite/gas/arm/armv8-a+simdv3.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a+simdv3.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add VRINT.
	(neon_opcodes): Likewise.
@
text
@d12835 1
a12835 1
  else if ((mask & (N_S16 | N_U16 | N_I16 | N_16 | N_P16)) != 0)
d12854 1
a12854 1
  else if ((mask & (N_F32 | N_F64)) != 0)
d14891 1
a14891 1
do_neon_cvtb (void)
d14893 12
a14904 1
  inst.instruction = 0xeb20a40;
d14906 4
a14909 9
  /* The sizes are attached to the mnemonic.  */
  if (inst.vectype.el[0].type != NT_invtype
      && inst.vectype.el[0].size == 16)
    inst.instruction |= 0x00010000;

  /* Programmer's syntax: the sizes are attached to the operands.  */
  else if (inst.operands[0].vectype.type != NT_invtype
	   && inst.operands[0].vectype.size == 16)
    inst.instruction |= 0x00010000;
d14911 30
a14940 3
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sm);
  do_vfp_cond_or_thumb ();
d14947 1
a14947 2
  do_neon_cvtb ();
  inst.instruction |= 0x80;
d18993 2
a18994 2
 nCEF(vcvtb,	_vcvt,	 2, (RVS, RVS), neon_cvtb),
 nCEF(vcvtt,	_vcvt,	 2, (RVS, RVS), neon_cvtt),
@


1.537
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add vcvta entry.
	(neon_cvt_mode): New enumeration.
	(do_vfp_nsyn_cvt_fpv8): New function.
	(do_neon_cvt_1): Add support for new conversions.
	(do_neon_cvtr): Use neon_cvt_mode enumerator.
	(do_neon_cvt): Likewise.
	(do_neon_cvta): New function.
	(do_neon_cvtn): Likewise.
	(do_neon_cvtp): Likewise.
	(do_neon_cvtm): Likewise.
	(insns): Add new VCVT instructions.
	* gas/testsuite/gas/arm/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/arm/armv8-a+simd.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a+simd.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add support for new VCVT
	variants.
	(neon_opcodes): Likewise.
@
text
@d12351 3
a12353 1
  X(vcvta,	0xebc0a40, 0x3bb0000, N_INV)
d14587 2
a14588 1
  neon_cvt_mode_x
d16007 119
d18345 7
@


1.536
log
@	* gas/config/tc-arm.c (CVT_FLAVOUR_VAR): New define.
	(CVT_VAR): New helper define.
	(neon_cvt_flavour): New enumeration, function renamed...
	(get_neon_cvt_flavour): ...to this.
	(do_vfp_nsyn_cvt): Update to use new neon_cvt_flavour.
	(do_vfp_nsyn_cvtz): Likewise.
	(do_neon_cvt_1): Likewise.
@
text
@d12350 2
a12351 1
  X(vminnm,	0xe800a40, 0x3200f10, N_INV)
d14578 10
d14652 52
a14703 1
do_neon_cvt_1 (bfd_boolean round_to_zero ATTRIBUTE_UNUSED)
d14710 1
a14710 1
  if (round_to_zero
d14725 5
a14729 1
      do_vfp_nsyn_cvt (rs, flavour);
d14766 22
d14789 2
a14790 2
      {
        unsigned enctab[] = { 0x100, 0x180, 0x0, 0x080 };
d14792 1
a14792 1
        NEON_ENCODE (INTEGER, inst);
d14794 2
a14795 2
        if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
          return;
d14797 2
a14798 2
        if (flavour != neon_cvt_flavour_invalid)
	   inst.instruction |= enctab[flavour];
d14800 6
a14805 6
        inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
        inst.instruction |= HI1 (inst.operands[0].reg) << 22;
        inst.instruction |= LOW4 (inst.operands[1].reg);
        inst.instruction |= HI1 (inst.operands[1].reg) << 5;
        inst.instruction |= neon_quad (rs) << 6;
        inst.instruction |= 2 << 18;
d14807 4
a14810 3
        neon_dp_fixup (&inst);
      }
    break;
d14844 4
a14847 1
      do_vfp_nsyn_cvt (rs, flavour);
d14854 1
a14854 1
  do_neon_cvt_1 (FALSE);
d14860 25
a14884 1
  do_neon_cvt_1 (TRUE);
d18219 4
@


1.535
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add vmaxnm, vminnm entries.
	(vfp_or_neon_is_neon_bits): Add NEON_CHECK_ARCH8 enumerator.
	(vfp_or_neon_is_neon): Add check for SIMD for ARMv8.
	(do_maxnm): New function.
	(insns): Add vmaxnm, vminnm entries.
	* gas/testsuite/gas/testsuite/gas/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/testsuite/gas/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/testsuite/gas/armv8-a+simd.d: New testcase.
	* gas/testsuite/gas/testsuite/gas/armv8-a+simd.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add VMAXNM/VMINNM.
	(neon_opcodes): Likewise.
@
text
@d14513 40
a14552 2
static int
neon_cvt_flavour (enum neon_shape rs)
d14554 6
a14559 6
#define CVT_VAR(C,X,Y)							\
  et = neon_check_type (2, rs, whole_reg | (X), whole_reg | (Y));	\
  if (et.type != NT_invtype)						\
    {									\
      inst.error = NULL;						\
      return (C);							\
d14561 1
d14571 1
a14571 26
  CVT_VAR (0, N_S32, N_F32);
  CVT_VAR (1, N_U32, N_F32);
  CVT_VAR (2, N_F32, N_S32);
  CVT_VAR (3, N_F32, N_U32);
  /* Half-precision conversions.  */
  CVT_VAR (4, N_F32, N_F16);
  CVT_VAR (5, N_F16, N_F32);

  whole_reg = N_VFP;

  /* VFP instructions.  */
  CVT_VAR (6, N_F32, N_F64);
  CVT_VAR (7, N_F64, N_F32);
  CVT_VAR (8, N_S32, N_F64 | key);
  CVT_VAR (9, N_U32, N_F64 | key);
  CVT_VAR (10, N_F64 | key, N_S32);
  CVT_VAR (11, N_F64 | key, N_U32);
  /* VFP instructions with bitshift.  */
  CVT_VAR (12, N_F32 | key, N_S16);
  CVT_VAR (13, N_F32 | key, N_U16);
  CVT_VAR (14, N_F64 | key, N_S16);
  CVT_VAR (15, N_F64 | key, N_U16);
  CVT_VAR (16, N_S16, N_F32 | key);
  CVT_VAR (17, N_U16, N_F32 | key);
  CVT_VAR (18, N_S16, N_F64 | key);
  CVT_VAR (19, N_U16, N_F64 | key);
d14573 1
a14573 1
  return -1;
d14580 1
a14580 1
do_vfp_nsyn_cvt (enum neon_shape rs, int flavour)
d14589 4
a14592 20
          "ftosls",
          "ftouls",
          "fsltos",
          "fultos",
          NULL,
          NULL,
	  NULL,
	  NULL,
          "ftosld",
          "ftould",
          "fsltod",
          "fultod",
          "fshtos",
          "fuhtos",
          "fshtod",
          "fuhtod",
          "ftoshs",
          "ftouhs",
          "ftoshd",
          "ftouhd"
d14595 1
a14595 1
      if (flavour >= 0 && flavour < (int) ARRAY_SIZE (enc))
d14609 4
a14612 12
          "ftosis",
          "ftouis",
          "fsitos",
          "fuitos",
	  "NULL",
	  "NULL",
          "fcvtsd",
          "fcvtds",
          "ftosid",
          "ftouid",
          "fsitod",
          "fuitod"
d14615 1
a14615 1
      if (flavour >= 0 && flavour < (int) ARRAY_SIZE (enc))
d14627 1
a14627 1
  int flavour = neon_cvt_flavour (rs);
d14630 4
a14633 10
      "ftosizs",
      "ftouizs",
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      "ftosizd",
      "ftouizd"
d14636 1
a14636 1
  if (flavour >= 0 && flavour < (int) ARRAY_SIZE (enc) && enc[flavour])
d14645 1
a14645 1
  int flavour = neon_cvt_flavour (rs);
d14650 4
a14653 1
      && (flavour == 0 || flavour == 1 || flavour == 8 || flavour == 9)
d14661 1
a14661 1
  if (flavour >= 6)
d14684 1
a14684 1
        if (flavour != -1)
d14709 2
a14710 2
        if (flavour != -1)
          inst.instruction |= enctab[flavour];
@


1.534
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add entries for VSEL.
	(NEON_ENC_FPV8_): New define.
	(do_vfp_nsyn_fpv8): New function.
	(do_vsel): Likewise.
	(insns): Add VSEL instructions.
	* gas/testsuite/gas/arm/armv8-a+fp.d: New testcase.
	* gas/testsuite/gas/arm/armv8-a+fp.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add VSEL.
	(print_insn_coprocessor): Add new %<>c bitfield format
	specifier.
@
text
@d12348 3
a12350 1
  X(vselgt,	0xe300a00, N_INV,     N_INV)
d13987 2
a13988 1
  NEON_CHECK_ARCH = 2
d14026 8
a14033 1
      && !ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1))
d15887 14
d18114 2
@


1.533
log
@	* gas/config/tc-arm.c (do_rm_rn): New function.
	(do_strlex): Likewise.
	(do_t_strlex): Likewise.
	(insns): Add support for LDRA/STRL instructions.
	* gas/testsuite/gas/arm/armv8-a-bad.l: Update testcase.
	* gas/testsuite/gas/arm/armv8-a-bad.s: Likewise.
	* gas/testsuite/gas/arm/armv8-a.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a.s: Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Add LDRA/STRL instructions.
	(thumb32_opcodes): Likewise.
	(print_arm_insn): Add support for %<>T formatter.
@
text
@d12344 5
a12348 1
  X(vcmpez,     0xeb50ac0, 0xeb50bc0, N_INV)
d12378 2
d15850 27
d18080 11
@


1.532
log
@	* gas/config/tc-arm.c (do_t_bkpt_hlt1): New function.
	(do_t_hlt): New function.
	(do_t_bkpt): Use do_t_bkpt_hlt1.
	(insns): Add HLT.
	* gas/testsuite/gas/arm/armv8-a-bad.l: Update for HLT.
	* gas/testsuite/gas/arm/armv8-a-bad.s: Likewise.
	* gas/testsuite/gas/arm/armv8-a.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a.s: Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Add HLT.
	(thumb_opcodes): Likewise.
@
text
@d7386 7
d8739 19
d18020 19
@


1.531
log
@	* gas/config/tc-arm.c (insns): Add DCPS instruction.
	* gas/testsuite/gas/arm/armv8-a.d: Update.
	* gas/testsuite/gas/arm/armv8-a.s: Likewise.
	* opcodes/arm-dis.c (thumb32_opcodes): Add DCPS instruction.
@
text
@d10201 3
d10205 1
a10205 1
do_t_bkpt (void)
d10211 1
a10211 1
      constraint (inst.operands[0].imm > 255,
a10213 1
      set_it_insn_type (NEUTRAL_IT_INSN);
d10215 14
d17993 1
d17995 1
@


1.530
log
@	* gas/config/tc-arm.c (T16_32_TAB): Add _sevl.
	(insns): Add SEVL.
	* gas/testsuite/gas/arm/armv8-a.s: New testcase.
	* gas/testsuite/gas/arm/armv8-a.d: Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Add SEVL.
	(thumb_opcodes): Likewise.
	(thumb32_opcodes): Likewise.
@
text
@d17978 6
@


1.529
log
@	* gas/config/tc-arm.c (asm_barrier_opt): Add arch field.
	(mark_feature_used): New function.
	(parse_barrier): Check specified option is valid for the
	specified architecture.
	(UL_BARRIER): New macro.
	(barrier_opt_names): Update for new barrier options.
	* gas/testsuite/gas/arm/armv8-a-barrier.s: New testcase.
	* gas/testsuite/gas/arm/armv8-a-barrier-arm.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a-barrier-thumb.d: Likewise.
	* opcodes/arm-dis.c (data_barrier_option): New function.
	(print_insn_arm): Use data_barrier_option.
	(print_insn_thumb32): Use data_barrier_option.
@
text
@d9552 2
a9553 1
  X(_sev,   bf40, f3af8004),
d17970 8
d17980 2
@


1.528
log
@	* gas/config/tc-arm.c (do_setend): Warn on deprecated SETEND.
	(do_t_setend): Likewise.
	* gas/testsuite/gas/arm/armv8-a-bad.l: Update
	* gas/testsuite/gas/arm/armv8-a-bad.s: Likewise.
@
text
@d464 3
a466 2
  const char *   template_name;
  unsigned long  value;
d5770 19
d5806 3
d17196 4
d17202 16
a17217 12
  { "sy",    0xf }, { "SY",    0xf },
  { "un",    0x7 }, { "UN",    0x7 },
  { "st",    0xe }, { "ST",    0xe },
  { "unst",  0x6 }, { "UNST",  0x6 },
  { "ish",   0xb }, { "ISH",   0xb },
  { "sh",    0xb }, { "SH",    0xb },
  { "ishst", 0xa }, { "ISHST", 0xa },
  { "shst",  0xa }, { "SHST",  0xa },
  { "nsh",   0x7 }, { "NSH",   0x7 },
  { "nshst", 0x6 }, { "NSHST", 0x6 },
  { "osh",   0x3 }, { "OSH",   0x3 },
  { "oshst", 0x2 }, { "OSHST", 0x2 }
d17220 2
@


1.527
log
@	* gas/config/tc-arm.c (do_t_it): Fully initialise now_it.
	(new_automatic_it_block): Likewise.
	(handle_it_block): Record whether current instruction is
	conditionally executed.
	* gas/config/tc-arm.c (depr_insn_mask): New structure.
	(depr_it_insns): New variable.
	(it_fsm_post_encode): Warn on deprecated uses.
	* gas/config/tc-arm.h (current_it): Add new fields.
	* gas/testsuite/gas/arm/armv8-a-it-bad.d: New testcase.
	* gas/testsuite/gas/arm/armv8-a-it-bad.l: Likewise.
	* gas/testsuite/gas/arm/armv8-a-it-bad.s: Likewise.
	* gas/testsuite/gas/arm/ldr-t-bad.s: Update testcase.
	* gas/testsuite/gas/arm/ldr-t.d: Likewise.
	* gas/testsuite/gas/arm/ldr-t.s: Likewise.
	* gas/testsuite/gas/arm/neon-cond-bad-inc.s: Likewise.
	* gas/testsuite/gas/arm/sp-pc-validations-bad-t: Likewise.
	* gas/testsuite/gas/arm/vfp-fma-inc.s: Likewise.
	* gas/testsuite/gas/arm/vfp-neon-syntax-inc.s: Likewise.
@
text
@d8531 4
d11776 4
@


1.526
log
@	* gas/config/tc-arm.c (deprecated_coproc_regs_s): New structure.
	(deprecated_coproc_regs): New variable.
	(deprecated_coproc_reg_count): Likewise.
	(do_co_reg): Error on obsolete & warn on deprecated registers.
	* gas/testsuite/gas/arm/armv8-a-bad.l: Update testcase.
	* gas/testsuite/gas/arm/armv8-a-bad.s: Likewise.
@
text
@d10359 1
d10367 4
a10370 1
	/* no conversion needed */;
d10372 4
a10375 1
	mask ^= 0x8;
d10377 4
a10380 1
	mask ^= 0xC;
d10382 4
a10385 1
	mask ^= 0xE;
d16203 2
d16312 1
d16390 1
d16402 1
d16425 1
d16470 19
d16497 38
@


1.525
log
@	* gas/config/tc-arm.c (check_obsolete): New function.
	(do_rd_rm_rn): Check swp{b} for obsoletion.
	* gas/testsuite/gas/arm/armv8-a-bad.d: New testcase.
	* gas/testsuite/gas/arm/armv8-a-bad.l: Likewise.
	* gas/testsuite/gas/arm/armv8-a-bad.s: Likewise.
	* gas/testsuite/gas/arm/depr-swp.l: Update for change in expected output.
	* gas/testsuite/gas/arm/depr-swp.s: Add additional test.
	* include/opcode/arm.h (ARM_CPU_IS_ANY): New define.
@
text
@d7713 41
d7758 1
d7778 17
@


1.524
log
@	* bfd/elf32-arm.c (v8): New array.
	(tag_cpu_arch_combine): Add support for ARMv8 attributes.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(VFP_VERSION_COUNT): New define.
	* binutils/readelf.c (arm_attr_tag_CPU_arch): Update for ARMv8.
	(arm_attr_tag_FP_arch): Likewise.
	(arm_attr_tag_Advanced_SIMD_arch): Likewise.
	* gas/config/tc-arm.h (arm_ext_v8): New variable.
	(fpu_vfp_ext_armv8): Likewise.
	(fpu_neon_ext_armv8): Likewise.
	(fpu_crypto_ext_armv8): Likewise.
	(arm_archs): Add armv8-a.
	(arm_extensions): Add crypto, fp, and simd.
	(arm_fpus): Add fp-armv8, neon-fp-armv8, crypto-neon-fp-armv8.
	(cpu_arch_ver): Add support for ARMv8.
	(aeabi_set_public_sttributes): Likewise.
	* gas/doc/c-arm.texi (ARM Options): Document new architecture and
	extension options for ARMv8.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for change in expected
	output.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a+crypto.d: New testcase.
	* gas/testsuite/gas/arm/attr-march-armv8-a+fp.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a+simd.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a.d: Likewise.
	* include/elf/arm.h (TAG_CPU_ARCH_V8): New define.
	(MAX_TAG_CPU_ARCH): Update.
	* include/opcode/arm.h (ARM_EXT_V8): New define.
	(FPU_VFP_EXT_ARMV8): Likewise.
	(FPU_NEON_EXT_ARMV8): Likewise.
	(FPU_CRYPTO_EXT_ARMV8): Likewise.
	(ARM_AEXT_V8A): Likewise.
	(FPU_VFP_ARMV8): Likwise.
	(FPU_NEON_ARMV8): Likewise.
	(FPU_CRYPTO_ARMV8): Likewise.
	(FPU_ARCH_VFP_ARMV8): Likewise.
	(FPU_ARCH_NEON_VFP_ARMV8): Likewise.
	(FPU_ARCH_CRYPTO_NEON_VFP_ARMV8): Likewise.
	(ARM_ARCH_V8A): Likwise.
	(ARM_ARCH_V8A_FP): Likewise.
	(ARM_ARCH_V8A_SIMD): Likewise.
	(ARM_ARCH_V8A_CRYPTO): Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp: Add new testcases.
	* ld/testsuite/ld-arm/attr-merge-vfp-3.d: Update for change in expected
	output.
	* ld/testsuite/ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-7.d: New testcase.
	* ld/testsuite/ld-arm/attr-merge-vfp-7r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-armv8-hard.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-armv8.s: Likewise.
@
text
@d7376 17
d7403 8
a7410 4
      /* SWP{b} is deprecated for ARMv6* and ARMv7.  */
      if (warn_on_deprecated
	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6))
	as_warn (_("swp{b} use is deprecated for this architecture"));
a7411 1
    }
@


1.523
log
@2012-07-24  Sandra Loosemore  <sandra@@codesourcery.com>
	    Jie Zhang  <jzhang918@@gmail.com>

	gas/
	* config/tc-arm.c (md_apply_fix): Use encoding A2 of ADR
	if offset is negative.

	gas/testsuite/
	* gas/arm/adr.d: New test.
	* gas/arm/adr.s: New test.
@
text
@d198 1
d237 6
d23198 1
d23220 4
d23233 2
d23292 4
d23770 1
a23770 1
    {10, ARM_ARCH_V7A},
d23773 1
d23803 1
d23903 3
a23905 1
  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_fma))
d23910 4
a23913 1
    aeabi_set_attribute_int (Tag_VFP_arch, 3);
d23915 4
a23918 1
    aeabi_set_attribute_int (Tag_VFP_arch, 4);
d23937 14
a23950 4
  if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_v1))
    aeabi_set_attribute_int
      (Tag_Advanced_SIMD_arch, (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_fma)
				? 2 : 1));
d23953 1
a23953 1
  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_fp16))
d23962 3
d23966 7
a23972 5
  gas_assert (arch <= TAG_CPU_ARCH_V7E_M);
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_adiv)
      || (profile == '\0'
	  && ARM_CPU_HAS_FEATURE (flags, arm_ext_div)
	  && !ARM_CPU_HAS_FEATURE (arm_arch_used, arm_arch_any)))
@


1.523.2.1
log
@	Apply mainline patches

bfd/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* elf32-arm.c (v8): New array.
	(tag_cpu_arch_combine): Add support for ARMv8 attributes.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(VFP_VERSION_COUNT): New define.

gas/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (ARM_ENC_TAB): Add sha1h and sha2op entries.
	(do_sha1h): New function.
	(do_sha1su1): Likewise.
	(do_sha256su0): Likewise.
	(insns): Add 2 operand SHA instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add sha3op entry.
	(do_crypto_3op_1): New function.
	(do_sha1c): Likewise.
	(do_sha1p): Likewise.
	(do_sha1m): Likewise.
	(do_sha1su0): Likewise.
	(do_sha256h): Likewise.
	(do_sha256h2): Likewise.
	(do_sha256su1): Likewise.
	(insns): Add SHA 3 operand instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (neon_type_mask): Add P64 type.
	(type_chk_of_el_type): Handle P64 type.
	(el_type_of_type_chk): Likewise.
	(do_neon_vmull): Handle VMULL.P64.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add aes entry.
	(neon_type_mask): Add N_UNT.
	(neon_check_type): Don't always decay typed to untyped sizes.
	(do_crypto_2op_1): New function.
	(do_aese): Likewise.
	(do_aesd): Likewise.
	(do_aesmc.8): Likewise.
	(do_aesimc.8): Likewise.
	(insns): Add AES instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (el_type_type_check): Add handling for 16-bit
	floating point types.
	(do_neon_cvttb_2): New function.
	(do_neon_cvttb_1): Likewise.
	(do_neon_cvtb): Refactor to use do_neon_cvttb_1.
	(do_neon_cvtt): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vrint entries.
	(neon_cvt_mode): Add neon_cvt_mode_r.
	(do_vrint_1): New function.
	(do_vrint_x): Likewise.
	(do_vrint_z): Likewise.
	(do_vrint_r): Likewise.
	(do_vrint_a): Likewise.
	(do_vrint_n): Likewise.
	(do_vrint_p): Likewise.
	(do_vrint_m): Likewise.
	(insns): Add VRINT instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vcvta entry.
	(neon_cvt_mode): New enumeration.
	(do_vfp_nsyn_cvt_fpv8): New function.
	(do_neon_cvt_1): Add support for new conversions.
	(do_neon_cvtr): Use neon_cvt_mode enumerator.
	(do_neon_cvt): Likewise.
	(do_neon_cvta): New function.
	(do_neon_cvtn): Likewise.
	(do_neon_cvtp): Likewise.
	(do_neon_cvtm): Likewise.
	(insns): Add new VCVT instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm>
	* config/tc-arm.c (CVT_FLAVOUR_VAR): New define.
	(CVT_VAR): New helper define.
	(neon_cvt_flavour): New enumeration, function renamed...
	(get_neon_cvt_flavour): ...to this.
	(do_vfp_nsyn_cvt): Update to use new neon_cvt_flavour.
	(do_vfp_nsyn_cvtz): Likewise.
	(do_neon_cvt_1): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vmaxnm, vminnm entries.
	(vfp_or_neon_is_neon_bits): Add NEON_CHECK_ARCH8 enumerator.
	(vfp_or_neon_is_neon): Add check for SIMD for ARMv8.
	(do_maxnm): New function.
	(insns): Add vmaxnm, vminnm entries.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add entries for VSEL.
	(NEON_ENC_FPV8_): New define.
	(do_vfp_nsyn_fpv8): New function.
	(do_vsel): Likewise.
	(insns): Add VSEL instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_rm_rn): New function.
	(do_strlex): Likewise.
	(do_t_strlex): Likewise.
	(insns): Add support for LDRA/STRL instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_t_bkpt_hlt1): New function.
	(do_t_hlt): New function.
	(do_t_bkpt): Use do_t_bkpt_hlt1.
	(insns): Add HLT.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (insns): Add DCPS instruction.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (T16_32_TAB): Add _sevl.
	(insns): Add SEVL.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (asm_barrier_opt): Add arch field.
	(mark_feature_used): New function.
	(parse_barrier): Check specified option is valid for the
	specified architecture.
	(UL_BARRIER): New macro.
	(barrier_opt_names): Update for new barrier options.

	2012-08-24  Matthew Gretton-Dann <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_setend): Warn on deprecated SETEND.
	(do_t_setend): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_t_it): Fully initialise now_it.
	(new_automatic_it_block): Likewise.
	(handle_it_block): Record whether current instruction is
	conditionally executed.
	* config/tc-arm.c (depr_insn_mask): New structure.
	(depr_it_insns): New variable.
	(it_fsm_post_encode): Warn on deprecated uses.
	* config/tc-arm.h (current_it): Add new fields.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (deprecated_coproc_regs_s): New structure.
	(deprecated_coproc_regs): New variable.
	(deprecated_coproc_reg_count): Likewise.
	(do_co_reg): Error on obsolete & warn on deprecated registers.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (check_obsolete): New function.
	(do_rd_rm_rn): Check swp{b} for obsoletion.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.h (arm_ext_v8): New variable.
	(fpu_vfp_ext_armv8): Likewise.
	(fpu_neon_ext_armv8): Likewise.
	(fpu_crypto_ext_armv8): Likewise.
	(arm_archs): Add armv8-a.
	(arm_extensions): Add crypto, fp, and simd.
	(arm_fpus): Add fp-armv8, neon-fp-armv8, crypto-neon-fp-armv8.
	(cpu_arch_ver): Add support for ARMv8.
	(aeabi_set_public_sttributes): Likewise.
	* doc/c-arm.texi (ARM Options): Document new architecture and
	extension options for ARMv8.

gas/testsuite/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.s: Update testcase.
	* gas/arm/armv8-a+crypto.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: New testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: Update testcase.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/half-prec-vfpv3.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fpv5.d: Update testcase.
	* gas/arm/armv8-a+fpv5.s: Likewise.
	* gas/arm/armv8-a+simdv3.d: Likewise.
	* gas/arm/armv8-a+simdv3.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: Update testcase.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/armv8-a+simd.d: Likewise.
	* gas/arm/armv8-a+simd.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/testsuite/gas/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/armv8-a+simd.d: New testcase.
	* gas/testsuite/gas/armv8-a+simd.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: New testcase.
	* gas/arm/armv8-a+fp.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update testcase.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update for HLT.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a.d: Update.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a.s: New testcase.
	* gas/arm/armv8-a.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-barrier.s: New testcase.
	* gas/arm/armv8-a-barrier-arm.d: Likewise.
	* gas/arm/armv8-a-barrier-thumb.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update
	* gas/arm/armv8-a-bad.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-it-bad.d: New testcase.
	* gas/arm/armv8-a-it-bad.l: Likewise.
	* gas/arm/armv8-a-it-bad.s: Likewise.
	* gas/arm/ldr-t-bad.s: Update testcase.
	* gas/arm/ldr-t.d: Likewise.
	* gas/arm/ldr-t.s: Likewise.
	* gas/arm/neon-cond-bad-inc.s: Likewise.
	* gas/arm/sp-pc-validations-bad-t: Likewise.
	* gas/arm/vfp-fma-inc.s: Likewise.
	* gas/arm/vfp-neon-syntax-inc.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update testcase.
	* gas/arm/armv8-a-bad.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.d: New testcase.
	* gas/arm/armv8-a-bad.l: Likewise.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/depr-swp.l: Update for change in expected output.
	* gas/arm/depr-swp.s: Add additional test.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/attr-march-all.d: Update for change in expected
	output.
	* gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/arm/attr-march-armv8-a+crypto.d: New testcase.
	* gas/arm/attr-march-armv8-a+fp.d: Likewise.
	* gas/arm/attr-march-armv8-a+simd.d: Likewise.
	* gas/arm/attr-march-armv8-a.d: Likewise.

include/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* opcode/arm.h (ARM_CPU_IS_ANY): New define.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* elf/arm.h (TAG_CPU_ARCH_V8): New define.
	(MAX_TAG_CPU_ARCH): Update.
	* opcode/arm.h (ARM_EXT_V8): New define.
	(FPU_VFP_EXT_ARMV8): Likewise.
	(FPU_NEON_EXT_ARMV8): Likewise.
	(FPU_CRYPTO_EXT_ARMV8): Likewise.
	(ARM_AEXT_V8A): Likewise.
	(FPU_VFP_ARMV8): Likwise.
	(FPU_NEON_ARMV8): Likewise.
	(FPU_CRYPTO_ARMV8): Likewise.
	(FPU_ARCH_VFP_ARMV8): Likewise.
	(FPU_ARCH_NEON_VFP_ARMV8): Likewise.
	(FPU_ARCH_CRYPTO_NEON_VFP_ARMV8): Likewise.
	(ARM_ARCH_V8A): Likwise.
	(ARM_ARCH_V8A_FP): Likewise.
	(ARM_ARCH_V8A_SIMD): Likewise.
	(ARM_ARCH_V8A_CRYPTO): Likewise.

ld/testsuite/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* ld-arm/arm-elf.exp: Add new testcases.
	* ld-arm/attr-merge-vfp-3.d: Update for change in expected
	output.
	* ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld-arm/attr-merge-vfp-4.d: Likewise.
	* ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld-arm/attr-merge-vfp-7.d: New testcase.
	* ld-arm/attr-merge-vfp-7r.d: Likewise.
	* ld-arm/attr-merge-vfp-armv8-hard.s: Likewise.
	* ld-arm/attr-merge-vfp-armv8.s: Likewise.

opcodes/
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add 2 operand sha instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add SHA 3-operand instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Handle VMULL.P64.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add support for AES instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add support for HP/DP
	conversions.

	2012-08-24  Matthew  Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VRINT.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add support for new VCVT
	variants.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VMAXNM/VMINNM.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VSEL.
	(print_insn_coprocessor): Add new %<>c bitfield format
	specifier.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add LDRA/STRL instructions.
	(thumb32_opcodes): Likewise.
	(print_arm_insn): Add support for %<>T formatter.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add HLT.
	(thumb_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (thumb32_opcodes): Add DCPS instruction.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add SEVL.
	(thumb_opcodes): Likewise.
	(thumb32_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (data_barrier_option): New function.
	(print_insn_arm): Use data_barrier_option.
	(print_insn_thumb32): Use data_barrier_option.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com
	* arm-dis.c (COND_UNCOND): New constant.
	(print_insn_coprocessor): Add support for %u format specifier.
	(print_insn_neon): Likewise.
@
text
@a197 1
static const arm_feature_set arm_ext_v8 = ARM_FEATURE (ARM_EXT_V8, 0);
a235 6
static const arm_feature_set fpu_vfp_ext_armv8 =
  ARM_FEATURE (0, FPU_VFP_EXT_ARMV8);
static const arm_feature_set fpu_neon_ext_armv8 =
  ARM_FEATURE (0, FPU_NEON_EXT_ARMV8);
static const arm_feature_set fpu_crypto_ext_armv8 =
  ARM_FEATURE (0, FPU_CRYPTO_EXT_ARMV8);
d457 2
a458 3
  const char *    template_name;
  unsigned long   value;
  const arm_feature_set arch;
a5761 19
/* If the given feature available in the selected CPU, mark it as used.
   Returns TRUE iff feature is available.  */
static bfd_boolean
mark_feature_used (const arm_feature_set *feature)
{
  /* Ensure the option is valid on the current architecture.  */
  if (!ARM_CPU_HAS_FEATURE (cpu_variant, *feature))
    return FALSE;

  /* Add the appropriate architecture feature for the barrier option used.
     */
  if (thumb_mode)
    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used, *feature);
  else
    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used, *feature);

  return TRUE;
}

a5778 3
  if (!mark_feature_used (&o->arch))
    return FAIL;

a7355 7
do_rm_rn (void)
{
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 16;
}

static void
a7368 17
static bfd_boolean
check_obsolete (const arm_feature_set *feature, const char *msg)
{
  if (ARM_CPU_IS_ANY (cpu_variant))
    {
      as_warn ("%s", msg);
      return TRUE;
    }
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, *feature))
    {
      as_bad ("%s", msg);
      return TRUE;
    }

  return FALSE;
}

d7379 5
a7383 7
      /* SWP{b} is obsolete for ARMv8-A, and deprecated for ARMv6* and ARMv7.
       */
      if (!check_obsolete (&arm_ext_v8,
			   _("swp{b} use is obsoleted for ARMv8 and later"))
	  && warn_on_deprecated
	  && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6))
	as_warn (_("swp{b} use is deprecated for ARMv6 and ARMv7"));
a7384 1

a7685 41
struct deprecated_coproc_regs_s
{
  unsigned cp;
  int opc1;
  unsigned crn;
  unsigned crm;
  int opc2;
  arm_feature_set deprecated;
  arm_feature_set obsoleted;
  const char *dep_msg;
  const char *obs_msg;
};

#define DEPR_ACCESS_V8 \
  N_("This coprocessor register access is deprecated in ARMv8")

/* Table of all deprecated coprocessor registers.  */
static struct deprecated_coproc_regs_s deprecated_coproc_regs[] =
{
    {15, 0, 7, 10, 5,					/* CP15DMB.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
    {15, 0, 7, 10, 4,					/* CP15DSB.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
    {15, 0, 7,  5, 4,					/* CP15ISB.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
    {14, 6, 1,  0, 0,					/* TEEHBR.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
    {14, 6, 0,  0, 0,					/* TEECR.  */
     ARM_FEATURE (ARM_EXT_V8, 0), ARM_FEATURE (0, 0),
     DEPR_ACCESS_V8, NULL},
};

#undef DEPR_ACCESS_V8

static const size_t deprecated_coproc_reg_count =
  sizeof (deprecated_coproc_regs) / sizeof (deprecated_coproc_regs[0]);

a7689 1
  size_t i;
a7708 17
    for (i = 0; i < deprecated_coproc_reg_count; ++i)
      {
	const struct deprecated_coproc_regs_s *r =
	  deprecated_coproc_regs + i;

	if (inst.operands[0].reg == r->cp
	    && inst.operands[1].imm == r->opc1
	    && inst.operands[3].reg == r->crn
	    && inst.operands[4].reg == r->crm
	    && inst.operands[5].imm == r->opc2)
	  {
	    if (!check_obsolete (&r->obsoleted, r->obs_msg)
	        && warn_on_deprecated
		&& ARM_CPU_HAS_FEATURE (cpu_variant, r->deprecated))
	      as_warn ("%s", r->dep_msg);
	  }
      }
a8444 4
  if (warn_on_deprecated
      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
      as_warn (_("setend use is deprecated for ARMv8"));

a8618 19
/* ARM V8 STRL.  */
static void
do_strlex (void)
{
  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  do_rd_rm_rn ();
}

static void
do_t_strlex (void)
{
  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  do_rm_rd_rn ();
}

d9439 1
a9439 2
  X(_sev,   bf40, f3af8004),                    \
  X(_sevl,  bf50, f3af8005)
a10086 3
/* Actually do the work for Thumb state bkpt and hlt.  The only difference
   between the two is the maximum immediate allowed - which is passed in 
   RANGE.  */
d10088 1
a10088 1
do_t_bkpt_hlt1 (int range)
d10094 1
a10094 1
      constraint (inst.operands[0].imm > range,
d10097 1
a10098 14

  set_it_insn_type (NEUTRAL_IT_INSN);
}

static void
do_t_hlt (void)
{
  do_t_bkpt_hlt1 (63);
}

static void
do_t_bkpt (void)
{
  do_t_bkpt_hlt1 (255);
a10272 1
  now_it.warn_deprecated = FALSE;
d10280 1
a10280 4
	{
	  /* No conversion needed.  */
	  now_it.block_length = 1;
	}
d10282 1
a10282 4
	{
	  mask ^= 0x8;
	  now_it.block_length = 2;
	}
d10284 1
a10284 4
	{
	  mask ^= 0xC;
	  now_it.block_length = 3;
	}
d10286 1
a10286 4
	{
	  mask ^= 0xE;
	  now_it.block_length = 4;
	}
a11672 4
  if (warn_on_deprecated
      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
      as_warn (_("setend use is deprecated for ARMv8"));

d12171 1
a12171 14
  X(vcmpez,     0xeb50ac0, 0xeb50bc0, N_INV),		\
  X(vseleq,	0xe000a00, N_INV,     N_INV),		\
  X(vselvs,	0xe100a00, N_INV,     N_INV),		\
  X(vselge,	0xe200a00, N_INV,     N_INV),		\
  X(vselgt,	0xe300a00, N_INV,     N_INV),		\
  X(vmaxnm,	0xe800a00, 0x3000f10, N_INV),		\
  X(vminnm,	0xe800a40, 0x3200f10, N_INV),		\
  X(vcvta,	0xebc0a40, 0x3bb0000, N_INV),		\
  X(vrintr,	0xeb60a40, 0x3ba0400, N_INV),		\
  X(vrinta,	0xeb80a40, 0x3ba0400, N_INV),		\
  X(aes,	0x3b00300, N_INV,     N_INV),		\
  X(sha3op,	0x2000c00, N_INV,     N_INV),		\
  X(sha1h,	0x3b902c0, N_INV,     N_INV),           \
  X(sha2op,     0x3ba0380, N_INV,     N_INV)
a12200 2
#define NEON_ENC_FPV8_(X) \
  ((neon_enc_tab[(X) & 0x0fffffff].integer) | ((X) & 0xf000000))
a12387 1
  N_P64	 = 0x0200000,
a12390 1
  N_UNT  = 0x8000000, /* Must be explicitly untyped.  */
d12399 1
a12399 1
  N_MAX_NONSPECIAL = N_P64
a12606 1
	case 64: return N_P64;
d12651 1
a12651 1
  else if ((mask & (N_S16 | N_U16 | N_I16 | N_16 | N_F16 | N_P16)) != 0)
d12655 1
a12655 1
  else if ((mask & (N_S64 | N_U64 | N_I64 | N_64 | N_F64 | N_P64)) != 0)
d12668 1
a12668 1
  else if ((mask & (N_P8 | N_P16 | N_P64)) != 0)
d12670 1
a12670 1
  else if ((mask & (N_F16 | N_F32 | N_F64)) != 0)
d12818 4
a12821 5
          if (((types_allowed & N_UNT) == 0)
	      && ((g_size == 8 && (types_allowed & N_8) != 0)
		  || (g_size == 16 && (types_allowed & N_16) != 0)
		  || (g_size == 32 && (types_allowed & N_32) != 0)
		  || (g_size == 64 && (types_allowed & N_64) != 0)))
d13806 1
a13806 2
  NEON_CHECK_ARCH = 2,
  NEON_CHECK_ARCH8 = 4
d13844 1
a13844 8
      && !mark_feature_used (&fpu_neon_ext_v1))
    {
      first_error (_(BAD_FPU));
      return FAIL;
    }

  if ((check & NEON_CHECK_ARCH8)
      && !mark_feature_used (&fpu_neon_ext_armv8))
d14324 2
a14325 40
#define CVT_FLAVOUR_VAR							      \
  CVT_VAR (s32_f32, N_S32, N_F32, whole_reg,   "ftosls", "ftosis", "ftosizs") \
  CVT_VAR (u32_f32, N_U32, N_F32, whole_reg,   "ftouls", "ftouis", "ftouizs") \
  CVT_VAR (f32_s32, N_F32, N_S32, whole_reg,   "fsltos", "fsitos", NULL)      \
  CVT_VAR (f32_u32, N_F32, N_U32, whole_reg,   "fultos", "fuitos", NULL)      \
  /* Half-precision conversions.  */					      \
  CVT_VAR (f32_f16, N_F32, N_F16, whole_reg,   NULL,     NULL,     NULL)      \
  CVT_VAR (f16_f32, N_F16, N_F32, whole_reg,   NULL,     NULL,     NULL)      \
  /* VFP instructions.  */						      \
  CVT_VAR (f32_f64, N_F32, N_F64, N_VFP,       NULL,     "fcvtsd", NULL)      \
  CVT_VAR (f64_f32, N_F64, N_F32, N_VFP,       NULL,     "fcvtds", NULL)      \
  CVT_VAR (s32_f64, N_S32, N_F64 | key, N_VFP, "ftosld", "ftosid", "ftosizd") \
  CVT_VAR (u32_f64, N_U32, N_F64 | key, N_VFP, "ftould", "ftouid", "ftouizd") \
  CVT_VAR (f64_s32, N_F64 | key, N_S32, N_VFP, "fsltod", "fsitod", NULL)      \
  CVT_VAR (f64_u32, N_F64 | key, N_U32, N_VFP, "fultod", "fuitod", NULL)      \
  /* VFP instructions with bitshift.  */				      \
  CVT_VAR (f32_s16, N_F32 | key, N_S16, N_VFP, "fshtos", NULL,     NULL)      \
  CVT_VAR (f32_u16, N_F32 | key, N_U16, N_VFP, "fuhtos", NULL,     NULL)      \
  CVT_VAR (f64_s16, N_F64 | key, N_S16, N_VFP, "fshtod", NULL,     NULL)      \
  CVT_VAR (f64_u16, N_F64 | key, N_U16, N_VFP, "fuhtod", NULL,     NULL)      \
  CVT_VAR (s16_f32, N_S16, N_F32 | key, N_VFP, "ftoshs", NULL,     NULL)      \
  CVT_VAR (u16_f32, N_U16, N_F32 | key, N_VFP, "ftouhs", NULL,     NULL)      \
  CVT_VAR (s16_f64, N_S16, N_F64 | key, N_VFP, "ftoshd", NULL,     NULL)      \
  CVT_VAR (u16_f64, N_U16, N_F64 | key, N_VFP, "ftouhd", NULL,     NULL)

#define CVT_VAR(C, X, Y, R, BSN, CN, ZN) \
  neon_cvt_flavour_##C,

/* The different types of conversions we can do.  */
enum neon_cvt_flavour
{
  CVT_FLAVOUR_VAR
  neon_cvt_flavour_invalid,
  neon_cvt_flavour_first_fp = neon_cvt_flavour_f32_f64
};

#undef CVT_VAR

static enum neon_cvt_flavour
get_neon_cvt_flavour (enum neon_shape rs)
d14327 6
a14332 6
#define CVT_VAR(C,X,Y,R,BSN,CN,ZN)			\
  et = neon_check_type (2, rs, (R) | (X), (R) | (Y));	\
  if (et.type != NT_invtype)				\
    {							\
      inst.error = NULL;				\
      return (neon_cvt_flavour_##C);			\
a14333 1

d14343 26
a14368 1
  CVT_FLAVOUR_VAR;
d14370 1
a14370 1
  return neon_cvt_flavour_invalid;
a14373 11
enum neon_cvt_mode
{
  neon_cvt_mode_a,
  neon_cvt_mode_n,
  neon_cvt_mode_p,
  neon_cvt_mode_m,
  neon_cvt_mode_z,
  neon_cvt_mode_x,
  neon_cvt_mode_r
};

d14377 1
a14377 1
do_vfp_nsyn_cvt (enum neon_shape rs, enum neon_cvt_flavour flavour)
d14386 20
a14405 4
#define CVT_VAR(C,A,B,R,BSN,CN,ZN) BSN,
	  CVT_FLAVOUR_VAR
	  NULL
#undef CVT_VAR
d14408 1
a14408 1
      if (flavour < (int) ARRAY_SIZE (enc))
d14422 12
a14433 4
#define CVT_VAR(C,A,B,R,BSN,CN,ZN) CN,
	  CVT_FLAVOUR_VAR
	  NULL
#undef CVT_VAR
d14436 1
a14436 1
      if (flavour < (int) ARRAY_SIZE (enc))
d14448 1
a14448 1
  enum neon_cvt_flavour flavour = get_neon_cvt_flavour (rs);
d14451 10
a14460 4
#define CVT_VAR(C,A,B,R,BSN,CN,ZN) ZN,
      CVT_FLAVOUR_VAR
      NULL
#undef CVT_VAR
d14463 1
a14463 1
  if (flavour < (int) ARRAY_SIZE (enc) && enc[flavour])
d14468 1
a14468 52
do_vfp_nsyn_cvt_fpv8 (enum neon_cvt_flavour flavour, 
		      enum neon_cvt_mode mode)
{
  int sz, op;
  int rm;

  set_it_insn_type (OUTSIDE_IT_INSN);

  switch (flavour)
    {
    case neon_cvt_flavour_s32_f64:
      sz = 1;
      op = 0;
      break;
    case neon_cvt_flavour_s32_f32:
      sz = 0;
      op = 1;
      break;
    case neon_cvt_flavour_u32_f64:
      sz = 1;
      op = 0;
      break;
    case neon_cvt_flavour_u32_f32:
      sz = 0;
      op = 0;
      break;
    default:
      first_error (_("invalid instruction shape"));
      return;
    }

  switch (mode)
    {
    case neon_cvt_mode_a: rm = 0; break;
    case neon_cvt_mode_n: rm = 1; break;
    case neon_cvt_mode_p: rm = 2; break;
    case neon_cvt_mode_m: rm = 3; break;
    default: first_error (_("invalid rounding mode")); return;
    }

  NEON_ENCODE (FPV8, inst);
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, sz == 1 ? VFP_REG_Dm : VFP_REG_Sm);
  inst.instruction |= sz << 8;
  inst.instruction |= op << 7;
  inst.instruction |= rm << 16;
  inst.instruction |= 0xf0000000;
  inst.is_neon = TRUE;
}

static void
do_neon_cvt_1 (enum neon_cvt_mode mode)
d14472 1
a14472 1
  enum neon_cvt_flavour flavour = get_neon_cvt_flavour (rs);
d14475 1
a14475 1
  if (mode == neon_cvt_mode_z
d14477 1
a14477 4
      && (flavour == neon_cvt_flavour_s32_f32 
	  || flavour == neon_cvt_flavour_u32_f32 
	  || flavour == neon_cvt_flavour_s32_f64 
	  || flavour == neon_cvt_flavour_u32_f64)
d14485 1
a14485 1
  if (flavour >= neon_cvt_flavour_first_fp)
d14487 1
a14487 5
      if (mode == neon_cvt_mode_x || mode == neon_cvt_mode_z)
	do_vfp_nsyn_cvt (rs, flavour);
      else
	do_vfp_nsyn_cvt_fpv8 (flavour, mode);

d14508 1
a14508 1
        if (flavour != neon_cvt_flavour_invalid)
a14523 22
      if (mode != neon_cvt_mode_x && mode != neon_cvt_mode_z)
	{
	  NEON_ENCODE (FLOAT, inst);
	  set_it_insn_type (OUTSIDE_IT_INSN);

	  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
	    return;

	  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
	  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
	  inst.instruction |= LOW4 (inst.operands[1].reg);
	  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
	  inst.instruction |= neon_quad (rs) << 6;
	  inst.instruction |= (flavour == neon_cvt_flavour_u32_f32) << 7;
	  inst.instruction |= mode << 8;
	  if (thumb_mode)
	    inst.instruction |= 0xfc000000;
	  else
	    inst.instruction |= 0xf0000000;
	}
      else
	{
d14525 2
a14526 2
	  {
	    unsigned enctab[] = { 0x100, 0x180, 0x0, 0x080 };
d14528 1
a14528 1
	    NEON_ENCODE (INTEGER, inst);
d14530 2
a14531 2
	    if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
	      return;
d14533 2
a14534 2
	    if (flavour != neon_cvt_flavour_invalid)
	      inst.instruction |= enctab[flavour];
d14536 6
a14541 6
	    inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
	    inst.instruction |= HI1 (inst.operands[0].reg) << 22;
	    inst.instruction |= LOW4 (inst.operands[1].reg);
	    inst.instruction |= HI1 (inst.operands[1].reg) << 5;
	    inst.instruction |= neon_quad (rs) << 6;
	    inst.instruction |= 2 << 18;
d14543 3
a14545 4
	    neon_dp_fixup (&inst);
	  }
	}
      break;
d14579 1
a14579 4
      if (mode == neon_cvt_mode_x || mode == neon_cvt_mode_z)
	do_vfp_nsyn_cvt (rs, flavour);
      else
	do_vfp_nsyn_cvt_fpv8 (flavour, mode);
d14586 1
a14586 1
  do_neon_cvt_1 (neon_cvt_mode_x);
d14592 1
a14592 1
  do_neon_cvt_1 (neon_cvt_mode_z);
d14596 1
a14596 1
do_neon_cvta (void)
d14598 1
a14598 2
  do_neon_cvt_1 (neon_cvt_mode_a);
}
d14600 9
a14608 5
static void
do_neon_cvtn (void)
{
  do_neon_cvt_1 (neon_cvt_mode_n);
}
d14610 2
a14611 25
static void
do_neon_cvtp (void)
{
  do_neon_cvt_1 (neon_cvt_mode_p);
}

static void
do_neon_cvtm (void)
{
  do_neon_cvt_1 (neon_cvt_mode_m);
}

static void
do_neon_cvttb_2 (bfd_boolean t, bfd_boolean to, bfd_boolean is_double)
{
  if (is_double)
    mark_feature_used (&fpu_vfp_ext_armv8);

  encode_arm_vfp_reg (inst.operands[0].reg,
		      (is_double && !to) ? VFP_REG_Dd : VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg,
		      (is_double && to) ? VFP_REG_Dm : VFP_REG_Sm);
  inst.instruction |= to ? 0x10000 : 0;
  inst.instruction |= t ? 0x80 : 0;
  inst.instruction |= is_double ? 0x100 : 0;
a14614 37
static void
do_neon_cvttb_1 (bfd_boolean t)
{
  enum neon_shape rs = neon_select_shape (NS_FF, NS_FD, NS_DF, NS_NULL);

  if (rs == NS_NULL)
    return;
  else if (neon_check_type (2, rs, N_F16, N_F32 | N_VFP).type != NT_invtype)
    {
      inst.error = NULL;
      do_neon_cvttb_2 (t, /*to=*/TRUE, /*is_double=*/FALSE);
    }
  else if (neon_check_type (2, rs, N_F32 | N_VFP, N_F16).type != NT_invtype)
    {
      inst.error = NULL;
      do_neon_cvttb_2 (t, /*to=*/FALSE, /*is_double=*/FALSE);
    }
  else if (neon_check_type (2, rs, N_F16, N_F64 | N_VFP).type != NT_invtype)
    {
      inst.error = NULL;
      do_neon_cvttb_2 (t, /*to=*/TRUE, /*is_double=*/TRUE);
    }
  else if (neon_check_type (2, rs, N_F64 | N_VFP, N_F16).type != NT_invtype)
    {
      inst.error = NULL;
      do_neon_cvttb_2 (t, /*to=*/FALSE, /*is_double=*/TRUE);
    }
  else
    return;
}

static void
do_neon_cvtb (void)
{
  do_neon_cvttb_1 (FALSE);
}

d14619 2
a14620 1
  do_neon_cvttb_1 (TRUE);
d14793 1
a14793 2
        N_EQK | N_DBL, N_EQK, N_SU_32 | N_P8 | N_P64 | N_KEY);

d14798 2
a14799 14

      /* For polynomial encoding the U bit must be zero, and the size must
	 be 8 (encoded as 0b00) or, on ARMv8 or later 64 (encoded, non
	 obviously, as 0b10).  */
      if (et.size == 64)
	{
	  /* Check we're on the correct architecture.  */
	  if (!mark_feature_used (&fpu_crypto_ext_armv8))
	    inst.error =
	      _("Instruction form not available on this architecture.");

	  et.size = 32;
	}

a15670 284

/* FP v8.  */
static void
do_vfp_nsyn_fpv8 (enum neon_shape rs)
{
  NEON_ENCODE (FPV8, inst);

  if (rs == NS_FFF)
    do_vfp_sp_dyadic ();
  else
    do_vfp_dp_rd_rn_rm ();

  if (rs == NS_DDD)
    inst.instruction |= 0x100;

  inst.instruction |= 0xf0000000;
}

static void
do_vsel (void)
{
  set_it_insn_type (OUTSIDE_IT_INSN);

  if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) != SUCCESS)
    first_error (_("invalid instruction shape"));
}

static void
do_vmaxnm (void)
{
  set_it_insn_type (OUTSIDE_IT_INSN);

  if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
    return;

  neon_dyadic_misc (NT_untyped, N_F32, 0);
}

static void
do_vrint_1 (enum neon_cvt_mode mode)
{
  enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_QQ, NS_NULL);
  struct neon_type_el et;

  if (rs == NS_NULL)
    return;

  et = neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
  if (et.type != NT_invtype)
    {
      /* VFP encodings.  */
      if (mode == neon_cvt_mode_a || mode == neon_cvt_mode_n
	  || mode == neon_cvt_mode_p || mode == neon_cvt_mode_m)
	set_it_insn_type (OUTSIDE_IT_INSN);

      NEON_ENCODE (FPV8, inst);
      if (rs == NS_FF)
	do_vfp_sp_monadic ();
      else
	do_vfp_dp_rd_rm ();

      switch (mode)
	{
	case neon_cvt_mode_r: inst.instruction |= 0x00000000; break;
	case neon_cvt_mode_z: inst.instruction |= 0x00000080; break;
	case neon_cvt_mode_x: inst.instruction |= 0x00010000; break;
	case neon_cvt_mode_a: inst.instruction |= 0xf0000000; break;
	case neon_cvt_mode_n: inst.instruction |= 0xf0010000; break;
	case neon_cvt_mode_p: inst.instruction |= 0xf0020000; break;
	case neon_cvt_mode_m: inst.instruction |= 0xf0030000; break;
	default: abort ();
	}

      inst.instruction |= (rs == NS_DD) << 8;
      do_vfp_cond_or_thumb ();
    }
  else
    {
      /* Neon encodings (or something broken...).  */
      inst.error = NULL;
      et = neon_check_type (2, rs, N_EQK, N_F32 | N_KEY);

      if (et.type == NT_invtype)
	return;

      set_it_insn_type (OUTSIDE_IT_INSN);
      NEON_ENCODE (FLOAT, inst);

      if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
	return;

      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= neon_quad (rs) << 6;
      switch (mode)
	{
	case neon_cvt_mode_z: inst.instruction |= 3 << 7; break;
	case neon_cvt_mode_x: inst.instruction |= 1 << 7; break;
	case neon_cvt_mode_a: inst.instruction |= 2 << 7; break;
	case neon_cvt_mode_n: inst.instruction |= 0 << 7; break;
	case neon_cvt_mode_p: inst.instruction |= 7 << 7; break;
	case neon_cvt_mode_m: inst.instruction |= 5 << 7; break;
	case neon_cvt_mode_r: inst.error = _("invalid rounding mode"); break;
	default: abort ();
	}

      if (thumb_mode)
	inst.instruction |= 0xfc000000;
      else
	inst.instruction |= 0xf0000000;
    }
}

static void
do_vrintx (void)
{
  do_vrint_1 (neon_cvt_mode_x);
}

static void
do_vrintz (void)
{
  do_vrint_1 (neon_cvt_mode_z);
}

static void
do_vrintr (void)
{
  do_vrint_1 (neon_cvt_mode_r);
}

static void
do_vrinta (void)
{
  do_vrint_1 (neon_cvt_mode_a);
}

static void
do_vrintn (void)
{
  do_vrint_1 (neon_cvt_mode_n);
}

static void
do_vrintp (void)
{
  do_vrint_1 (neon_cvt_mode_p);
}

static void
do_vrintm (void)
{
  do_vrint_1 (neon_cvt_mode_m);
}

/* Crypto v1 instructions.  */
static void
do_crypto_2op_1 (unsigned elttype, int op)
{
  set_it_insn_type (OUTSIDE_IT_INSN);

  if (neon_check_type (2, NS_QQ, N_EQK | N_UNT, elttype | N_UNT | N_KEY).type
      == NT_invtype)
    return;

  inst.error = NULL;

  NEON_ENCODE (INTEGER, inst);
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg);
  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
  if (op != -1)
    inst.instruction |= op << 6;

  if (thumb_mode)
    inst.instruction |= 0xfc000000;
  else
    inst.instruction |= 0xf0000000;
}

static void
do_crypto_3op_1 (int u, int op)
{
  set_it_insn_type (OUTSIDE_IT_INSN);

  if (neon_check_type (3, NS_QQQ, N_EQK | N_UNT, N_EQK | N_UNT,
		       N_32 | N_UNT | N_KEY).type == NT_invtype)
    return;

  inst.error = NULL;

  NEON_ENCODE (INTEGER, inst);
  neon_three_same (1, u, 8 << op);
}

static void
do_aese (void)
{
  do_crypto_2op_1 (N_8, 0);
}

static void
do_aesd (void)
{
  do_crypto_2op_1 (N_8, 1);
}

static void
do_aesmc (void)
{
  do_crypto_2op_1 (N_8, 2);
}

static void
do_aesimc (void)
{
  do_crypto_2op_1 (N_8, 3);
}

static void
do_sha1c (void)
{
  do_crypto_3op_1 (0, 0);
}

static void
do_sha1p (void)
{
  do_crypto_3op_1 (0, 1);
}

static void
do_sha1m (void)
{
  do_crypto_3op_1 (0, 2);
}

static void
do_sha1su0 (void)
{
  do_crypto_3op_1 (0, 3);
}

static void
do_sha256h (void)
{
  do_crypto_3op_1 (1, 0);
}

static void
do_sha256h2 (void)
{
  do_crypto_3op_1 (1, 1);
}

static void
do_sha256su1 (void)
{
  do_crypto_3op_1 (1, 2);
}

static void
do_sha1h (void)
{
  do_crypto_2op_1 (N_32, -1);
}

static void
do_sha1su1 (void)
{
  do_crypto_2op_1 (N_32, 0);
}

static void
do_sha256su0 (void)
{
  do_crypto_2op_1 (N_32, 1);
}
a16103 2
  now_it.warn_deprecated = FALSE;
  now_it.insn_cond = TRUE;
a16210 1
  now_it.insn_cond = FALSE;
a16287 1
	      now_it.insn_cond = TRUE;
a16298 1
	  now_it.insn_cond = TRUE;
a16320 1
	now_it.insn_cond = TRUE;
a16364 19
struct depr_insn_mask
{
  unsigned long pattern;
  unsigned long mask;
  const char* description;
};

/* List of 16-bit instruction patterns deprecated in an IT block in
   ARMv8.  */
static const struct depr_insn_mask depr_it_insns[] = {
  { 0xc000, 0xc000, N_("Short branches, Undefined, SVC, LDM/STM") },
  { 0xb000, 0xb000, N_("Miscellaneous 16-bit instructions") },
  { 0xa000, 0xb800, N_("ADR") },
  { 0x4800, 0xf800, N_("Literal loads") },
  { 0x4478, 0xf478, N_("Hi-register ADD, MOV, CMP, BX, BLX using pc") },
  { 0x4487, 0xfc87, N_("Hi-register ADD, MOV, CMP using pc") },
  { 0, 0, NULL }
};

a16372 38
  if (now_it.insn_cond
      && !now_it.warn_deprecated
      && warn_on_deprecated
      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
    {
      if (inst.instruction >= 0x10000)
	{
	  as_warn (_("it blocks containing wide Thumb instructions are "
		     "deprecated in ARMv8"));
	  now_it.warn_deprecated = TRUE;
	}
      else
	{
	  const struct depr_insn_mask *p = depr_it_insns;

	  while (p->mask != 0)
	    {
	      if ((inst.instruction & p->mask) == p->pattern)
		{
		  as_warn (_("it blocks containing 16-bit Thumb intsructions "
			     "of the following class are deprecated in ARMv8: "
			     "%s"), p->description);
		  now_it.warn_deprecated = TRUE;
		  break;
		}

	      ++p;
	    }
	}

      if (now_it.block_length > 1)
	{
	  as_warn (_("it blocks of more than one conditional instruction are "
		     "deprecated in ARMv8"));
	  now_it.warn_deprecated = TRUE;
	}
    }

a17002 4
#define UL_BARRIER(L,U,CODE,FEAT) \
  { L, CODE, ARM_FEATURE (FEAT, 0) }, \
  { U, CODE, ARM_FEATURE (FEAT, 0) }

d17005 12
a17016 16
  UL_BARRIER ("sy",	"SY",	 0xf, ARM_EXT_BARRIER),
  UL_BARRIER ("st",	"ST",	 0xe, ARM_EXT_BARRIER),
  UL_BARRIER ("ld",	"LD",	 0xd, ARM_EXT_V8),
  UL_BARRIER ("ish",	"ISH",	 0xb, ARM_EXT_BARRIER),
  UL_BARRIER ("sh",	"SH",	 0xb, ARM_EXT_BARRIER),
  UL_BARRIER ("ishst",	"ISHST", 0xa, ARM_EXT_BARRIER),
  UL_BARRIER ("shst",	"SHST",	 0xa, ARM_EXT_BARRIER),
  UL_BARRIER ("ishld",	"ISHLD", 0x9, ARM_EXT_V8),
  UL_BARRIER ("un",	"UN",	 0x7, ARM_EXT_BARRIER),
  UL_BARRIER ("nsh",	"NSH",	 0x7, ARM_EXT_BARRIER),
  UL_BARRIER ("unst",	"UNST",	 0x6, ARM_EXT_BARRIER),
  UL_BARRIER ("nshst",	"NSHST", 0x6, ARM_EXT_BARRIER),
  UL_BARRIER ("nshld",	"NSHLD", 0x5, ARM_EXT_V8),
  UL_BARRIER ("osh",	"OSH",	 0x3, ARM_EXT_BARRIER),
  UL_BARRIER ("oshst",	"OSHST", 0x2, ARM_EXT_BARRIER),
  UL_BARRIER ("oshld",	"OSHLD", 0x1, ARM_EXT_V8)
a17018 2
#undef UL_BARRIER

a17765 80
 /* AArchv8 instructions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT   & arm_ext_v8
#undef  THUMB_VARIANT
#define THUMB_VARIANT & arm_ext_v8

 tCE("sevl",	320f005, _sevl,    0, (),		noargs,	t_hint),
 TUE("hlt",	1000070, ba80,     1, (oIffffb),	bkpt,	t_hlt),
 TCE("ldraex",	1900e9f, e8d00fef, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
 TCE("ldraexd",	1b00e9f, e8d000ff, 3, (RRnpc, oRRnpc, RRnpcb),
							ldrexd, t_ldrexd),
 TCE("ldraexb",	1d00e9f, e8d00fcf, 2, (RRnpc,RRnpcb),	rd_rn,  rd_rn),
 TCE("ldraexh",	1f00e9f, e8d00fdf, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("strlex",	1800e90, e8c00fe0, 3, (RRnpc, RRnpc, RRnpcb),
							strlex,  t_strlex),
 TCE("strlexd",	1a00e90, e8c000f0, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb),
							strexd, t_strexd),
 TCE("strlexb",	1c00e90, e8c00fc0, 3, (RRnpc, RRnpc, RRnpcb),
							strlex, t_strlex),
 TCE("strlexh",	1e00e90, e8c00fd0, 3, (RRnpc, RRnpc, RRnpcb),
							strlex, t_strlex),
 TCE("ldra",	1900c9f, e8d00faf, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
 TCE("ldrab",	1d00c9f, e8d00f8f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("ldrah",	1f00c9f, e8d00f9f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("strl",	180fc90, e8c00faf, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
 TCE("strlb",	1c0fc90, e8c00f8f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
 TCE("strlh",	1e0fc90, e8c00f9f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),

 /* ARMv8 T32 only.  */
#undef ARM_VARIANT
#define ARM_VARIANT  NULL
 TUF("dcps1",	0,	 f78f8001, 0, (),	noargs, noargs),
 TUF("dcps2",	0,	 f78f8002, 0, (),	noargs, noargs),
 TUF("dcps3",	0,	 f78f8003, 0, (),	noargs, noargs),

  /* FP for ARMv8.  */
#undef  ARM_VARIANT
#define ARM_VARIANT & fpu_vfp_ext_armv8
#undef  THUMB_VARIANT
#define THUMB_VARIANT & fpu_vfp_ext_armv8

  nUF(vseleq, _vseleq, 3, (RVSD, RVSD, RVSD),		vsel),
  nUF(vselvs, _vselvs, 3, (RVSD, RVSD, RVSD),		vsel),
  nUF(vselge, _vselge, 3, (RVSD, RVSD, RVSD),		vsel),
  nUF(vselgt, _vselgt, 3, (RVSD, RVSD, RVSD),		vsel),
  nUF(vmaxnm, _vmaxnm, 3, (RNSDQ, oRNSDQ, RNSDQ),	vmaxnm),
  nUF(vminnm, _vminnm, 3, (RNSDQ, oRNSDQ, RNSDQ),	vmaxnm),
  nUF(vcvta,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvta),
  nUF(vcvtn,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtn),
  nUF(vcvtp,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtp),
  nUF(vcvtm,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtm),
  nCE(vrintr, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintr),
  nCE(vrintz, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintz),
  nCE(vrintx, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintx),
  nUF(vrinta, _vrinta, 2, (RNSDQ, oRNSDQ),		vrinta),
  nUF(vrintn, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintn),
  nUF(vrintp, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintp),
  nUF(vrintm, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintm),

  /* Crypto v1 extensions.  */
#undef  ARM_VARIANT
#define ARM_VARIANT & fpu_crypto_ext_armv8
#undef  THUMB_VARIANT
#define THUMB_VARIANT & fpu_crypto_ext_armv8

  nUF(aese, _aes, 2, (RNQ, RNQ), aese),
  nUF(aesd, _aes, 2, (RNQ, RNQ), aesd),
  nUF(aesmc, _aes, 2, (RNQ, RNQ), aesmc),
  nUF(aesimc, _aes, 2, (RNQ, RNQ), aesimc),
  nUF(sha1c, _sha3op, 3, (RNQ, RNQ, RNQ), sha1c),
  nUF(sha1p, _sha3op, 3, (RNQ, RNQ, RNQ), sha1p),
  nUF(sha1m, _sha3op, 3, (RNQ, RNQ, RNQ), sha1m),
  nUF(sha1su0, _sha3op, 3, (RNQ, RNQ, RNQ), sha1su0),
  nUF(sha256h, _sha3op, 3, (RNQ, RNQ, RNQ), sha256h),
  nUF(sha256h2, _sha3op, 3, (RNQ, RNQ, RNQ), sha256h2),
  nUF(sha256su1, _sha3op, 3, (RNQ, RNQ, RNQ), sha256su1),
  nUF(sha1h, _sha1h, 2, (RNQ, RNQ), sha1h),
  nUF(sha1su1, _sha2op, 2, (RNQ, RNQ), sha1su1),
  nUF(sha256su0, _sha2op, 2, (RNQ, RNQ), sha256su0),

a17767 2
#undef  THUMB_VARIANT
#define THUMB_VARIANT NULL
d18372 2
a18373 2
 NCEF(vcvtb,	eb20a40, 2, (RVSD, RVSD), neon_cvtb),
 NCEF(vcvtt,	eb20a40, 2, (RVSD, RVSD), neon_cvtt),
a23190 1
  ARM_ARCH_OPT ("armv8-a",	ARM_ARCH_V8A,	 FPU_ARCH_VFP),
a23211 4
  ARM_EXT_OPT ("crypto", FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
				   ARM_FEATURE (ARM_EXT_V8, 0)),
  ARM_EXT_OPT ("fp",     FPU_ARCH_VFP_ARMV8,
				   ARM_FEATURE (ARM_EXT_V8, 0)),
a23220 2
  ARM_EXT_OPT ("simd",   FPU_ARCH_NEON_VFP_ARMV8,
				   ARM_FEATURE (ARM_EXT_V8, 0)),
a23277 4
  {"fp-armv8",		FPU_ARCH_VFP_ARMV8},
  {"neon-fp-armv8",	FPU_ARCH_NEON_VFP_ARMV8},
  {"crypto-neon-fp-armv8",
			FPU_ARCH_CRYPTO_NEON_VFP_ARMV8},
d23752 1
a23752 1
    {10, ARM_ARCH_V7A_IDIV_MP_SEC_VIRT},
a23754 1
    {14, ARM_ARCH_V8A},
a23783 1
  int fp16_optional = 0;
d23883 1
a23883 3
  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_armv8))
    aeabi_set_attribute_int (Tag_VFP_arch, 7);
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_fma))
d23888 1
a23888 4
    {
      fp16_optional = 1;
      aeabi_set_attribute_int (Tag_VFP_arch, 3);
    }
d23890 1
a23890 4
    {
      aeabi_set_attribute_int (Tag_VFP_arch, 4);
      fp16_optional = 1;
    }
d23909 4
a23912 14
  if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_armv8))
    aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 3);
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_v1))
    {
      if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_fma))
	{
	  aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 2);
	}
      else
	{
	  aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 1);
	  fp16_optional = 1;
	}
    }
d23915 1
a23915 1
  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_fp16) && fp16_optional)
a23923 3
     For ARMv8 we set the tag to 0 as integer divide is implied by the base
     architecture.

d23925 5
a23929 7
  gas_assert (arch <= TAG_CPU_ARCH_V8);
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v8))
    aeabi_set_attribute_int (Tag_DIV_use, 0);
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_adiv)
	   || (profile == '\0'
	       && ARM_CPU_HAS_FEATURE (flags, arm_ext_div)
	       && !ARM_CPU_HAS_FEATURE (arm_arch_used, arm_arch_any)))
@


1.523.2.2
log
@gas/
2012-09-18  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* config/tc-arm.c: Changed ldra and strl-form mnemonics
	to lda and stl-form for armv8.

gas/testsuite/
2012-09-18  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* gas/arm/armv8-a-bad.l: Updated for changed mnemonics.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.
	* gas/arm/inst.s: Added test for ldrt encoding compatibly with ldralt.
	* gas/arm/inst.d: Updated.

opcodes/
2012-09-18  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

        * arm-dis.c: Changed ldra and strl-form mnemonics
	to lda and stl-form.
@
text
@d8741 1
a8741 1
do_stlex (void)
d8750 1
a8750 1
do_t_stlex (void)
d18479 2
a18480 2
 TCE("ldaex",	1900e9f, e8d00fef, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
 TCE("ldaexd",	1b00e9f, e8d000ff, 3, (RRnpc, oRRnpc, RRnpcb),
d18482 5
a18486 5
 TCE("ldaexb",	1d00e9f, e8d00fcf, 2, (RRnpc,RRnpcb),	rd_rn,  rd_rn),
 TCE("ldaexh",	1f00e9f, e8d00fdf, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("stlex",	1800e90, e8c00fe0, 3, (RRnpc, RRnpc, RRnpcb),
							stlex,  t_stlex),
 TCE("stlexd",	1a00e90, e8c000f0, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb),
d18488 10
a18497 10
 TCE("stlexb",	1c00e90, e8c00fc0, 3, (RRnpc, RRnpc, RRnpcb),
							stlex, t_stlex),
 TCE("stlexh",	1e00e90, e8c00fd0, 3, (RRnpc, RRnpc, RRnpcb),
							stlex, t_stlex),
 TCE("lda",	1900c9f, e8d00faf, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
 TCE("ldab",	1d00c9f, e8d00f8f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("ldah",	1f00c9f, e8d00f9f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
 TCE("stl",	180fc90, e8c00faf, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
 TCE("stlb",	1c0fc90, e8c00f8f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
 TCE("stlh",	1e0fc90, e8c00f9f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
@


1.523.2.3
log
@gas/
	* config/tc-arm.c (arm_symbol_chars): New variable.
	* config/tc-arm.h (tc_symbol_chars): New macro, defined to that.

gas/testsuite/
	* gas/arm/macro-pld.s: New file.
	* gas/arm/macro-pld.d: New file.
@
text
@a323 5
/* An immediate operand can start with #, and ld*, st*, pld operands
   can contain [ and ].  We need to tell APP not to elide whitespace
   before a [, which can appear as the first operand for pld.  */
const char arm_symbol_chars[] = "#[]";

d10228 1
a10228 1
   between the two is the maximum immediate allowed - which is passed in
d14663 1
a14663 1
do_vfp_nsyn_cvt_fpv8 (enum neon_cvt_flavour flavour,
d14723 3
a14725 3
      && (flavour == neon_cvt_flavour_s32_f32
	  || flavour == neon_cvt_flavour_u32_f32
	  || flavour == neon_cvt_flavour_s32_f64
@


1.523.2.4
log
@2012-12-20  Greta Yorsh  <Greta.Yorsh@@arm.com>

	* config/tc-arm.c (rfefa,rfeea,rfeed): Fix encoding.
	(rfe,srs,srsea,srsfa,srsed,srsfd): Add missing mnemonics.

	* gas/arm/srs-t2.s: Add tests for missing srs modes.
	* gas/arm/srs-t2.l: Update expected output.
	* gas/arm/srs-arm.s: Add tests for missing srs modes.
	* gas/arm/srs-arm.l: Update expected output.
	* gas/arm/archv6.s: Add tests for missing rfe modes.
	* gas/arm/archv6.d: Update expected output.
@
text
@a18223 1
 TUF("rfe",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
d18228 3
a18230 3
  UF(rfefa,	8100a00,           1, (RRw),			   rfe),
 TUF("rfeea",	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
  UF(rfeed,	9900a00,           1, (RRw),			   rfe),
a18231 2
 TUF("srs",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
 TUF("srsea",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
a18232 1
  UF(srsfa,	9c00500,           2, (oRRw, I31w),		   srs),
a18233 1
  UF(srsed,	8400500,	   2, (oRRw, I31w),		   srs),
a18234 1
 TUF("srsfd",	9400500, e800c000, 2, (oRRw, I31w),		   srs,  srs),
@


1.523.2.5
log
@gas/
	* config/tc-arm.c (md_apply_fix): Use as_bad_where for "bad
	immediate value for 8-bit offset" error so it shows line info.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
d21579 2
a21580 3
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad immediate value for 8-bit offset (%ld)"),
			  (long) value);
@


1.523.2.6
log
@	Apply mainline patches
	2013-02-25  Terry Guo  <terry.guo@@arm.com>
	* config/tc-arm.c (arm_cpus): Add cortex-r7 entry.
	* doc/c-arm.texi: Add cortex-r7 and missing cortex-r5 to
	list of accepted CPUs.
@
text
@a23919 3
  ARM_CPU_OPT ("cortex-r7",	ARM_ARCH_V7R_IDIV,
						 FPU_ARCH_VFP_V3D16,
								  "Cortex-R7"),
@


1.523.2.7
log
@gas/
	* config/tc-arm.c (arm_symbol_chars): Include '{' and '}'.
	(arm_reg_parse_multi): Skip whitespace first.
	(parse_reg_list): Likewise.
	(parse_vfp_reg_list): Likewise.
	(s_arm_unwind_save_mmxwcg): Likewise.

gas/testsuite/
	* gas/arm/macro-pld.s: Add a 'push {r0}' case.
	* gas/arm/macro-pld.d: Update expected output.
	* gas/arm/macro-vld1.s: New file.
	* gas/arm/macro-vld1.d: New file.
@
text
@d326 2
a327 3
   before a [, which can appear as the first operand for pld.
   Likewise, a { can appear as the first operand for push, pop, vld*, etc.  */
const char arm_symbol_chars[] = "#[]{}";
a1156 2
  skip_whitespace (start);

a1581 2
      skip_whitespace (str);

d1733 1
a1733 1
  if (skip_past_char (&str, '{') == FAIL)
d1739 2
a4028 2
  skip_whitespace (input_line_pointer);

@


1.523.2.8
log
@gas/
	PR gas/14987
	* config/tc-arm.c (parse_address_main): Skip whitespace before a
	closing bracket.

gas/testsuite/
	PR gas/14987
	* gas/arm/neon-ldst-es.s: Add whitespace test.
	* gas/arm/neon-ldst-es.d: Update expected disassembly.
@
text
@a5298 3
  /* PR gas/14987: Allow for whitespace before the closing bracket.  */
  skip_whitespace (p);

@


1.523.2.9
log
@gas/
	PR gas/14887
	* config/tc-arm.c (skip_past_char): Skip whitespace before the
	anticipated character.
	* config/tc-arm.c (parse_address_main): Delete skip of whitespace
	here as it is no longer needed.

gas/testsuite/
	PR gas/14887
	* gas/arm/neon-ldst-es.s: Add more whitespace.
@
text
@a888 3
  /* PR gas/14987: Allow for whitespace before the expected character.  */
  skip_whitespace (*str);
  
a5175 3
  /* PR gas/14887: Allow for whitespace after the opening bracket.  */
  skip_whitespace (p);

d5299 3
@


1.523.2.10
log
@gas/
	* config/tc-arm.c (parse_reg_list): Use skip_past_char for '}',
	so it skips whitespace before it.
	(s_arm_unwind_save_mmxwr, s_arm_unwind_save_mmxwcg): Likewise.

gas/testsuite/
	* gas/arm/macro-vld1.s: Add a case with whitespace before '}'.
	* gas/arm/macro-vld1.d: Update.
@
text
@d1643 1
a1643 1
	  if (skip_past_char (&str, '}') == FAIL)
d3937 2
a3938 1
  skip_past_char (&input_line_pointer, '}');
d4072 2
a4073 1
  skip_past_char (&input_line_pointer, '}');
@


1.522
log
@	PR gas/14263
	* config/tc-arm.c (parse_operands): Initialise val.
@
text
@a20639 1
      newimm = encode_arm_immediate (value);
d20642 14
a20655 4
      /* If the instruction will fail, see if we can fix things up by
	 changing the opcode.  */
      if (newimm == (unsigned int) FAIL
	  && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
@


1.521
log
@	PR gas/14260
	* config/tc-arm.c (encode_arm_addr_mode_common): Generate an error
	message if literal pool addressing is used.

	* gas/arm/ldr-t-bad.s: Add test of bogus use of literal pool
	addressing.
	* gas/arm/ldr-t-bad.l: Update expected assembler error message
	output.
@
text
@d6205 1
a6205 1
  int i, val, backtrack_index = 0;
@


1.520
log
@	PR gas/12698
	* config/tc-arm.c (do_t_mrs): Do not require an m-profile
	architecure when assembling for all archiectures.
	(do_t_msr): Likewise.
@
text
@d7045 5
a7049 1
  gas_assert (inst.operands[i].isreg);
d21276 2
a21277 2
       if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4 &&
	   fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
d21288 9
a21296 9
       if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	 {
	   if (!(ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2)))
	     as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);
	   else if ((value & ~0x1ffffff)
		    && ((value & ~0x1ffffff) != ~0x1ffffff))
	     as_bad_where (fixP->fx_file, fixP->fx_line,
			   _("Thumb2 branch out of range"));
	 }
@


1.519
log
@	* elf32-arm.c (elf32_arm_nacl_plt0_entry, elf32_arm_nacl_plt_entry):
	New variables.
	(struct elf32_arm_link_hash_table): New member `nacl_p'.
	(elf32_arm_link_hash_table_create): Initialize it.
	(elf32_arm_nacl_link_hash_table_create): New function.
	(arm_movw_immediate, arm_movt_immediate): New functions.
	(elf32_arm_populate_plt_entry): Test HTAB->nacl_p.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_output_plt_map_1): Likewise.
	(bfd_elf32_littlearm_nacl_vec, bfd_elf32_bigarm_nacl_vec):
	New backend vector stanza.
	(elf32_arm_nacl_modify_segment_map): New function.
	* config.bfd: Handle arm-*-nacl*, armeb-*-nacl*.
	* targets.c: Support bfd_elf32_{big,little}_nacl_vec.
	* configure.in: Likewise.
	(bfd_elf32_bigarm_nacl_vec): Add elf-nacl.lo here.
	(bfd_elf32_littlearm_nacl_vec): Likewise.
	(bfd_elf32_bigarm_vec, bfd_elf32_littlearm_vec): Likewise.
	(bfd_elf32_bigarm_symbian_vec): Likewise.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	(bfd_elf32_bigarm_vxworks_vec): Likewise.
	(bfd_elf32_littlearm_vxworks_vec): Likewise.
	* configure: Regenerated.

	* configure.tgt (arm-*-nacl*): Match it.
	* config/te-nacl.h (FPU_DEFAULT, EABI_DEFAULT): Define.
	(LOCAL_LABELS_DOLLAR): Define.
	* config/tc-arm.c (elf32_arm_target_format) [TE_NACL]:
	Use nacl format variants.

	* gas/elf/elf.exp (run_elf_list_test): Treat arm-*-nacl* targets
	as -armeabi.

	* gas/arm/any-idiv.d: Match *-*-nacl* targets too.
	* gas/arm/arch4t.d: Likewise.
	* gas/arm/arch4t-eabi.d: Likewise.
	* gas/arm/attr-any-armv4t.d: Likewise.
	* gas/arm/attr-any-thumbv6.d: Likewise.
	* gas/arm/attr-cpu-directive.d: Likewise.
	* gas/arm/attr-default.d: Likewise.
	* gas/arm/attr-march-all.d: Likewise.
	* gas/arm/attr-march-armv1.d: Likewise.
	* gas/arm/attr-march-armv2a.d: Likewise.
	* gas/arm/attr-march-armv2.d: Likewise.
	* gas/arm/attr-march-armv2s.d: Likewise.
	* gas/arm/attr-march-armv3.d: Likewise.
	* gas/arm/attr-march-armv3m.d: Likewise.
	* gas/arm/attr-march-armv4.d: Likewise.
	* gas/arm/attr-march-armv4t.d: Likewise.
	* gas/arm/attr-march-armv4txm.d: Likewise.
	* gas/arm/attr-march-armv4xm.d: Likewise.
	* gas/arm/attr-march-armv5.d: Likewise.
	* gas/arm/attr-march-armv5t.d: Likewise.
	* gas/arm/attr-march-armv5te.d: Likewise.
	* gas/arm/attr-march-armv5tej.d: Likewise.
	* gas/arm/attr-march-armv5texp.d: Likewise.
	* gas/arm/attr-march-armv5txm.d: Likewise.
	* gas/arm/attr-march-armv6.d: Likewise.
	* gas/arm/attr-march-armv6j.d: Likewise.
	* gas/arm/attr-march-armv6k.d: Likewise.
	* gas/arm/attr-march-armv6k+sec.d: Likewise.
	* gas/arm/attr-march-armv6kt2.d: Likewise.
	* gas/arm/attr-march-armv6-m.d: Likewise.
	* gas/arm/attr-march-armv6-m+os.d: Likewise.
	* gas/arm/attr-march-armv6s-m.d: Likewise.
	* gas/arm/attr-march-armv6t2.d: Likewise.
	* gas/arm/attr-march-armv6z.d: Likewise.
	* gas/arm/attr-march-armv6zk.d: Likewise.
	* gas/arm/attr-march-armv6zkt2.d: Likewise.
	* gas/arm/attr-march-armv6zt2.d: Likewise.
	* gas/arm/attr-march-armv7-a.d: Likewise.
	* gas/arm/attr-march-armv7a.d: Likewise.
	* gas/arm/attr-march-armv7-a+idiv.d: Likewise.
	* gas/arm/attr-march-armv7-a+mp.d: Likewise.
	* gas/arm/attr-march-armv7-a+sec.d: Likewise.
	* gas/arm/attr-march-armv7-a+sec+virt.d: Likewise.
	* gas/arm/attr-march-armv7-a+virt.d: Likewise.
	* gas/arm/attr-march-armv7.d: Likewise.
	* gas/arm/attr-march-armv7em.d: Likewise.
	* gas/arm/attr-march-armv7-m.d: Likewise.
	* gas/arm/attr-march-armv7m.d: Likewise.
	* gas/arm/attr-march-armv7-r.d: Likewise.
	* gas/arm/attr-march-armv7r.d: Likewise.
	* gas/arm/attr-march-armv7-r+mp.d: Likewise.
	* gas/arm/attr-march-iwmmxt2.d: Likewise.
	* gas/arm/attr-march-iwmmxt.d: Likewise.
	* gas/arm/attr-march-xscale.d: Likewise.
	* gas/arm/attr-mcpu.d: Likewise.
	* gas/arm/attr-mfpu-arm1020e.d: Likewise.
	* gas/arm/attr-mfpu-arm1020t.d: Likewise.
	* gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
	* gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
	* gas/arm/attr-mfpu-arm7500fe.d: Likewise.
	* gas/arm/attr-mfpu-fpa10.d: Likewise.
	* gas/arm/attr-mfpu-fpa11.d: Likewise.
	* gas/arm/attr-mfpu-fpa.d: Likewise.
	* gas/arm/attr-mfpu-fpe2.d: Likewise.
	* gas/arm/attr-mfpu-fpe3.d: Likewise.
	* gas/arm/attr-mfpu-fpe.d: Likewise.
	* gas/arm/attr-mfpu-maverick.d: Likewise.
	* gas/arm/attr-mfpu-neon.d: Likewise.
	* gas/arm/attr-mfpu-neon-fp16.d: Likewise.
	* gas/arm/attr-mfpu-softfpa.d: Likewise.
	* gas/arm/attr-mfpu-softvfp.d: Likewise.
	* gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
	* gas/arm/attr-mfpu-vfp10.d: Likewise.
	* gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
	* gas/arm/attr-mfpu-vfp3.d: Likewise.
	* gas/arm/attr-mfpu-vfp9.d: Likewise.
	* gas/arm/attr-mfpu-vfp.d: Likewise.
	* gas/arm/attr-mfpu-vfpv2.d: Likewise.
	* gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
	* gas/arm/attr-mfpu-vfpv3.d: Likewise.
	* gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/arm/attr-mfpu-vfpxd.d: Likewise.
	* gas/arm/attr-names.d: Likewise.
	* gas/arm/attr-order.d: Likewise.
	* gas/arm/attr-override-cpu-directive.d: Likewise.
	* gas/arm/attr-override-mcpu.d: Likewise.
	* gas/arm/got_prel.d: Likewise.
	* gas/arm/mapdir.d: Likewise.
	* gas/arm/mapmisc.d: Likewise.
	* gas/arm/mapsecs.d: Likewise.
	* gas/arm/mapshort-eabi.d: Likewise.
	* gas/arm/mapshort-elf.d: Likewise.
	* gas/arm/mov-highregs-any.d: Likewise.
	* gas/arm/mov-lowregs-any.d: Likewise.
	* gas/arm/pr12198-1.d: Likewise.
	* gas/arm/pr12198-2.d: Likewise.
	* gas/arm/thumb.d: Likewise.
	* gas/arm/thumb-eabi.d: Likewise.
	* gas/arm/thumbrel.d: Likewise.

	* configure.tgt (arm*-*-nacl*, arm*b-*-nacl*): Handle them.
	* emulparams/armelf_nacl.sh: New file.
	* emulparams/armelfb_nacl.sh: New file.
	* Makefile.am (ALL_EMULATION_SOURCES): Add earmelf_nacl.c
	and earmelfb_nacl.c here.
	(earmelf_nacl.c, earmelfb_nacl.c): New targets.
	* Makefile.in: Regenerated.

	* ld-arm/arm-elf.exp (armelftests): Split out into ...
	(armelftests_common, armelftests_nonacl): ... these two.
	(armeabitests): Split out into ...
	(armeabitests_common, armeabitests_nonacl): ... these two.
	Omit _nonacl sets for arm*-*-nacl* targets.

	* ld-arm/farcall-mix.d: Don't match exact addresses, only symbolic ones.
	* ld-arm/farcall-mix2.d: Likewise.
	* ld-arm/farcall-group.d: Likewise.

	* ld-arm/tls-gdesc-got.d: Match variant file formats too.
	Accept some variation in exact addresses.

	* ld-arm/thumb2-b-interwork.d: Match variant file formats too.
	Fix regexps not to care about exact addresses where not relevant.

	* ld-arm/thumb2-bl-undefweak.d: Match any hex strings, not any
	strings of particular exact lengths.
	* ld-arm/thumb2-bl-undefweak1.d: Likewise.

	* ld-arm/arm-app.r: Match variant file formats too.
	* ld-arm/arm-app-abs32.r: Likewise.
	* ld-arm/arm-lib.d: Likewise.
	* ld-arm/arm-lib.r: Likewise.
	* ld-arm/arm-static-app.r: Likewise.
	* ld-arm/armv4-bx.d: Likewise.
	* ld-arm/data-only-map.d: Likewise.
	* ld-arm/group-relocs.d: Likewise.
	* ld-arm/jump19.d: Likewise.
	* ld-arm/reloc-boundaries.d: Likewise.
	* ld-arm/thumb1-bl.d: Likewise.
	* ld-arm/thumb2-bl.d: Likewise.
	* ld-arm/tls-app.d: Likewise.
	* ld-arm/tls-app.r: Likewise.
	* ld-arm/tls-gdierelax.d: Likewise.
	* ld-arm/tls-gdierelax2.d: Likewise.
	* ld-arm/tls-gdlerelax.d: Likewise.
	* ld-arm/tls-lib.d: Likewise.
	* ld-arm/tls-lib.r: Likewise.
	* ld-arm/tls-mixed.r: Likewise.
	* ld-arm/vfp11-fix-none.d: Likewise.
	* ld-arm/vfp11-fix-scalar.d: Likewise.
	* ld-arm/vfp11-fix-vector.d: Likewise.
	* ld-arm/arm-static-app.d: Likewise.
	Fix regexps not to care about exact number of leading spaces.
	* ld-arm/arm-app-abs32.d: Likewise.
	* ld-arm/fix-arm1176-off.d: Likewise.
	* ld-arm/fix-arm1176-on.d: Likewise.

	* ld-arm/arm-elf.exp: Treat nacl targets like eabi targets.
@
text
@d11204 8
a11211 2
	constraint (flags != 0, _("selected processor does not support "
        	    "requested special purpose register"));
d11245 10
a11254 6
      constraint ((ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp)
		   && (bits & ~(PSR_s | PSR_f)) != 0)
		  || (!ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp)
		      && bits != PSR_f),
		  _("selected processor does not support requested special "
		    "purpose register"));
@


1.518
log
@	* config/tc-arm.c (only_one_reg_in_list): New function.
	(encode_ldmstm): Ditto.
	(do_ldmstm): Use a different encoding when pushing or poping
	a single register.
	(A_COND_MASK): New macro.
	(A_PUSH_POP_OP_MASK): Ditto.
	(A1_OPCODE_PUSH): Ditto.
	(A2_OPCODE_PUSH): Ditto.
	(A2_OPCODE_POP): Ditto.

	* gas/arm/push-pop.d: New testcase.
	* gas/arm/push-pop.s: Ditto.
	* gas/arm/stm-ldm.d: Ditto.
	* gas/arm/stm-ldm.s: Ditto.
@
text
@d22287 4
@


1.517
log
@2012-03-29  Terry Guo  <terry.guo@@arm.com>

	* gas/config/tc-arm.c (arm_cpus): Add cortex-m0plus.
	* gas/doc/c-arm.texi (ARM Options): Document -mcpu=cortex-m0plus.
@
text
@d625 8
d7806 9
d7816 1
a7816 1
do_ldmstm (void)
d7820 1
d7853 17
d8371 1
a8371 1
  do_ldmstm ();
@


1.516
log
@	* config/tc-arm.c (do_vmrs): Accept priviledged mode VFP system
	registers.
	(do_vmsr): Likewise.
	(arm_opcode_insns): Do not default to using the FPSCR register in
	the VMRS and VMSR registers.

	* gas/arm/vfp1xD.s: Add tests of the VMSR ad VMRS instructions in
	priviledged modes.
	* gas/arm/vfp1xD.d: Update expected output.
@
text
@d23063 1
@


1.515
log
@	* gas/config/tc-arm.c (aeabi_set_public_attributes): Correct
	handling of Tag_DIV_use.
	* gas/testsuite/gas/testsuite/gas/arm/any-idiv.d: New testcase.
	* gas/testsuite/gas/testsuite/gas/arm/any-idiv.s: Likewise.
	* gas/testsuite/gas/arm/attr-any-armv4t.d: Update expected output.
	* gas/testsuite/gas/arm/attr-any-thumbv6.d: Likewise.
	* gas/testsuite/gas/arm/attr-cpu-directive.d: Likewise.
	* gas/testsuite/gas/arm/attr-default.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv1.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv2a.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv2s.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv3.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv3m.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv4.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv4t.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv4txm.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv4xm.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv5.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv5t.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv5te.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv5tej.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv5texp.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv5txm.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6-m+os.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6-m.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6j.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6k+sec.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6k.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6kt2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6s-m.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6t2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6z.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6zk.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6zkt2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6zt2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv7-a+mp.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv7-a+sec.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv7-a.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv7.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv7a.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-iwmmxt.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-iwmmxt2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-xscale.d: Likewise.
	* gas/testsuite/gas/arm/attr-mcpu.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1020e.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1020t.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm7500fe.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-fpa.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-fpa10.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-fpa11.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-fpe.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-fpe2.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-fpe3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-maverick.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-neon-fp16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-neon.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-softfpa.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-softvfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp10.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp9.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv2.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpxd.d: Likewise.
	* gas/testsuite/gas/arm/attr-order.d: Likewise.
	* gas/testsuite/gas/arm/attr-override-cpu-directive.d: Likewise.
	* gas/testsuite/gas/arm/attr-override-mcpu.d: Likewise.
	* gas/testsuite/gas/arm/eabi_attr_1.d: Likewise.
	* gas/testsuite/gas/arm/mov-highregs-any.d: Likewise.
	* gas/testsuite/gas/arm/mov-lowregs-any.d: Likewise.
	* gas/testsuite/gas/arm/pr12198-1.d: Likewise.
	* gas/testsuite/gas/arm/pr12198-2.d: Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp: Add new testcases.
	* ld/testsuite/ld-arm/attr-merge-2.attr: Update ouput.
	* ld/testsuite/ld-arm/attr-merge-2a.s: Remove Tag_DIV_use test.
	* ld/testsuite/ld-arm/attr-merge-2b.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-3.attr: Updated expected output.
	* ld/testsuite/ld-arm/attr-merge-4.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-5.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-6.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-arch-1.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-arch-2.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-unknown-2.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-unknown-2r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-unknown-3.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-1.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-1r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-2.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-2r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-3.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-6.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-6r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-00.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-02.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-04.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-20.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-22.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-40.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-44.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-0.s: New testcase.
	* ld/testsuite/ld-arm/attr-merge-div-00.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-01-m3.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-01.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-02.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-1.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-10-m3.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-10.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-11.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-12.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-120.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-2.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-20.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-21.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-div-22.d: Likewise.
@
text
@d8105 12
a8116 2
  if (inst.operands[1].reg != 1)
    first_error (_("operand 1 must be FPSCR"));
d8134 10
a8143 2
  if (inst.operands[0].reg != 1)
    first_error (_("operand 0 must be FPSCR"));
d18168 2
a18169 2
 cCE("vmrs",	ef10a10, 2, (APSR_RR, RVC),   vmrs),
 cCE("vmsr",	ee10a10, 2, (RVC, RR),        vmsr),
@


1.514
log
@gas/
2012-03-12  Roland McGrath  <mcgrathr@@google.com>

	* config/tc-arm.c (arm_frag_max_var): New function.
	* config/tc-arm.h: Declare it.
	(md_frag_max_var): New macro.

	* config/tc-i386.c (i386_frag_max_var): New function.
	* config/tc-i386.h: Declare it.
	(md_frag_max_var): New macro.

	* doc/as.texinfo (Bundle directives): New node.
	(Pseudo Ops): Add it to the menu.
	* NEWS: Mention new feature.
	* read.c [md_frag_max_var] (HANDLE_BUNDLE): New macro.
	[HANDLE_BUNDLE] (bundle_align_p2): New variable.
	[HANDLE_BUNDLE] (bundle_lock_frchain, bundle_lock_frag): New variables.
	[HANDLE_BUNDLE] (start_bundle, pending_bundle_size, finish_bundle):
	New functions.
	(assemble_one): New function if [HANDLE_BUNDLE], #define directly
	to md_assembly if not.
	(read_a_source_file): Call assemble_one in place of md_assemble.
	(read_a_source_file) [HANDLE_BUNDLE]: Check for unterminated
	.bundle_lock at end of processing.
	[HANDLE_BUNDLE] (s_bundle_align_mode, s_bundle_lock, s_bundle_unlock):
	New functions.
	[HANDLE_BUNDLE] (potable): Add their entries.
	* read.h: Declare new functions.

gas/testsuite/
2012-03-12  Roland McGrath  <mcgrathr@@google.com>

	* gas/i386/bundle-bad.s: New file.
	* gas/i386/bundle-bad.d: New file.
	* gas/i386/bundle-bad.l: New file.
	* gas/i386/i386.exp: Run it.

	* gas/arm/bundle.s: New file.
	* gas/arm/bundle.d: New file.
	* gas/arm/bundle-lock.s: New file.
	* gas/arm/bundle-lock.d: New file.

	* gas/i386/bundle.s: New file.
	* gas/i386/bundle.d: New file.
	* gas/i386/x86-64-bundle.s: New file.
	* gas/i386/x86-64-bundle.d: New file.
	* gas/i386/bundle-lock.s: New file.
	* gas/i386/bundle-lock.d: New file.
	* gas/i386/i386.exp: Run them.
@
text
@d23701 1
d23779 1
a23779 1
    aeabi_set_attribute_int (Tag_CPU_arch_profile, 'A');
d23781 1
a23781 1
    aeabi_set_attribute_int (Tag_CPU_arch_profile, 'R');
d23783 6
a23788 1
    aeabi_set_attribute_int (Tag_CPU_arch_profile, 'M');
d23837 12
a23848 2
  /* Tag_DIV_use.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_adiv))
a23849 4
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_div))
    aeabi_set_attribute_int (Tag_DIV_use, 0);
  else
    aeabi_set_attribute_int (Tag_DIV_use, 1);
@


1.513
log
@	PR gas/13449
	* config/tc-arm.c (create_unwind_entry): Zero allocated table
	entries.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d101 1
a101 1
   pre-defines which were only present when doing native builds, thus 
d5067 1
a5067 1
   
d5180 1
a5180 1
	  
d5268 1
a5268 1
      
d5451 1
a5451 1
	
d5524 1
a5524 1
	  
d5544 1
a5544 1
		
d5548 1
a5548 1
		
d5552 1
a5552 1
		
d5558 1
a5558 1
	  
d5561 1
a5561 1
	  
d5573 1
a5573 1
	  
d6066 1
a6066 1
  OP_RRnpctw,	/* ARM register, not r15 in Thumb-state or with writeback, 
d6623 1
a6623 1
	case OP_wPSR:	 
d6783 2
a6784 2
	  if (inst.operands[i].isreg 
	      && inst.operands[i].reg == REG_PC 
d8091 1
a8091 1
  
d8115 1
a8115 1
  
d8815 2
a8816 2
  if (srcsize == 16 && !(immbits >= 0 && immbits <= srcsize)) 
    {  
d8822 1
a8822 1
  else if (srcsize == 32 && !(immbits >= 0 && immbits < srcsize)) 
d10049 1
a10049 1
  
d10356 1
a10356 1
    		    inst.error = 
d10359 2
a10360 2
		    
		  opcode = (inst.instruction == T_MNEM_stmia ? T_MNEM_str 
d10372 1
a10372 1
		  inst.instruction = 
d10380 1
a10380 1
		  inst.instruction = 
d10937 1
a10937 1
		ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used, 
d15259 1
a15259 1
  if (!is_ldr 
d16716 1
a16716 1
  REGDEF(spsr_hyp,768|(14<<16)|SPSR_BIT,RNB), 
d19001 20
d19592 1
a19592 1
      sprintf (err_msg, 
d20497 1
a20497 1
  lo = (value >> 1) & 0x7ff; 
d20614 1
a20614 1
	
d23240 2
a23241 2
     extensions being added before being removed.  We achieve this by having 
     the global ARM_EXTENSIONS table in alphabetical order, and using the 
d23243 1
a23243 1
     or removing it (0) and only allowing it to change in the order 
d23826 1
a23826 1
  
@


1.512
log
@	* frv.opc (parse_uhi16): Fix handling of %hi operator on 64-bit
	hosts.

	* cgen-asm.c (cgen_parse_signed_integer): Add code to handle the
	sign extension of negative values on a 64-bit host.
	* frv-asm.c: Regenerate.

	* gas/frv/immediates.s: New test file - checks assembly of
	constant values.
	* gas/frv/immediates.d: Expected disassmbly.
	* gas/frv/allinsn.exp: Run the new test.
@
text
@d19947 2
@


1.511
log
@2011-12-07  Sameera Deshpande  <sameera.deshpande@@arm.com>

	* gas/config/tc-arm.c (do_t_ldstd): Warn for unpredictable cases.
	* gas/testsuite/gas/arm/thumb2_ldstd_unpredictable.d: New testcase.
	* gas/testsuite/gas/arm/thumb2_ldstd_unpredictable.l: Likewise.
	* gas/testsuite/gas/arm/thumb2_ldstd_unpredictable.s: Likewise.
	* gas/testsuite/gas/testsuite/gas/arm/sp-pc-validations-bad-t.l: Update
	testcase.
	* gas/testsuite/gas/testsuite/gas/arm/sp-pc-validations-bad-t.s: Likewise.
@
text
@d3543 1
d19930 6
a19935 2
    /* An extra byte is required for the opcode count.	*/
    size = unwind.opcode_count + 1;
d19961 1
a19961 1
      data = size - 1;
@


1.510
log
@	* gas/config/tc-arm.c (ARM_IT_MAX_OPERANDS): New define.
	(arm_it): Use ARM_IT_MAX_OPERANDS.
	(neon_select_shape): Ensure we have matched all	operands.
	* gas/testsuite/gas/arm/neon-suffix-bad.l: Add testcase.
	* gas/testsuite/gas/arm/neon-suffix-bad.s: Likewise.
@
text
@d566 1
d10658 2
d10661 7
@


1.509
log
@	* gas/config/tc-arm.c (parse_neon_mov): Update which_operand
	correctly.
@
text
@d354 3
d408 1
a408 1
  } operands[6];
d12421 3
a12423 1
      if (matches)
@


1.508
log
@	* tc-arm.c (aeabi_set_public_attributes): Correctly set
	Tag_ARM_ISA_use and Tag_Thumb_ISA_use.

	* gas/arm/attr-any-armv4t.d: New test.
	* gas/arm/attr-any-armv4t.s: New file.
	* gas/arm/attr-any-thumbv6.d: New test.
	* gas/arm/attr-any-thumbv6.s: New file.
@
text
@d5934 1
a5934 1
              inst.operands[i++].present = 1;
d6024 1
a6024 1
          inst.operands[i++].present = 1;
@


1.507
log
@	* gas/config/tc-arm.c (arm_cpu_option_table): Add name_len field.
	(arm_arch_option_table): Likewise.
	(arm_option_extension_value_table): Likewise.
	(ARM_CPU_OPT): New define.
	(ARM_ARCH_OPT): Likewise.
	(ARM_EXT_OPT): Likewise.
	(arm_cpus): Use ARM_CPU_OPT to initialize.
	(arm_archs): Use ARM_ARCH_OPT to initialize.
	(arm_extensions): Use ARM_EXT_OPT to initialize.
	(arm_parse_extension): Ensure option string matching matches
	the whole string.
	(arm_parse_cpu): Likewise.
	(arm_parse_arch): Likewise.
	* gas/testsuite/gas/arm/cmdline-bad-arch.d: New test case.
	* gas/testsuite/gas/arm/cmdline-bad-cpu.d: Likewise.
@
text
@d23669 8
a23676 1
  /*Allow the user to override the reported architecture.  */
@


1.506
log
@	* gas/config/tc-arm.c (do_t_mov_cmp): Allow MOV lowreg, lowreg when no CPU
	is specified.
	* gas/testsuite/gas/arm/mov-highregs-any.d: New testcase.
	* gas/testsuite/gas/arm/mov-highregs-any.s: Likewise.
	* gas/testsuite/gas/arm/mov-lowregs-any.d: Likewise.
	* gas/testsuite/gas/arm/mov-lowregs-any.s: Likewise.
@
text
@d22877 1
d22889 1
d22892 46
a22937 46
  {"all",		ARM_ANY,	 FPU_ARCH_FPA,    NULL},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA,    NULL},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA,    NULL},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA,    NULL},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA,    NULL},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL},
  {"arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm7tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm7tdmi-s",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL},
  {"arm810",		ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL},
  {"strongarm",		ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL},
  {"strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL},
  {"strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL},
  {"strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL},
  {"strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL},
  {"arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm920",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    "ARM920T"},
  {"arm920t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm922t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm940t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL},
  {"arm9tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,	  NULL},
  {"fa526",		ARM_ARCH_V4,	 FPU_ARCH_FPA,	  NULL},
  {"fa626",		ARM_ARCH_V4,	 FPU_ARCH_FPA,	  NULL},
d22940 45
a22984 43
  {"arm9e-r0",		ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL},
  {"arm9e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"arm926ej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, "ARM926EJ-S"},
  {"arm926ejs",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, "ARM926EJ-S"},
  {"arm926ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, NULL},
  {"arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL},
  {"arm946e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM946E-S"},
  {"arm946e-s",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL},
  {"arm966e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM966E-S"},
  {"arm966e-s",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"arm968e-s",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"arm10t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL},
  {"arm10tdmi",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL},
  {"arm10e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"arm1020",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM1020E"},
  {"arm1020t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL},
  {"arm1020e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"arm1022e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"arm1026ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, "ARM1026EJ-S"},
  {"arm1026ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, NULL},
  {"fa606te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"fa616te",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL},
  {"fa626te",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL},
  {"fmp626",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL},
  {"fa726te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL},
  {"arm1136js",		ARM_ARCH_V6,	 FPU_NONE,	  "ARM1136J-S"},
  {"arm1136j-s",	ARM_ARCH_V6,	 FPU_NONE,	  NULL},
  {"arm1136jfs",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2, "ARM1136JF-S"},
  {"arm1136jf-s",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2, NULL},
  {"mpcore",		ARM_ARCH_V6K,	 FPU_ARCH_VFP_V2, "MPCore"},
  {"mpcorenovfp",	ARM_ARCH_V6K,	 FPU_NONE,	  "MPCore"},
  {"arm1156t2-s",	ARM_ARCH_V6T2,	 FPU_NONE,	  NULL},
  {"arm1156t2f-s",	ARM_ARCH_V6T2,	 FPU_ARCH_VFP_V2, NULL},
  {"arm1176jz-s",	ARM_ARCH_V6ZK,	 FPU_NONE,	  NULL},
  {"arm1176jzf-s",	ARM_ARCH_V6ZK,	 FPU_ARCH_VFP_V2, NULL},
  {"cortex-a5",		ARM_ARCH_V7A_MP_SEC, 
					 FPU_NONE,	  "Cortex-A5"},
  {"cortex-a7",		ARM_ARCH_V7A_IDIV_MP_SEC_VIRT,
    					 FPU_ARCH_NEON_VFP_V4,
					 		  "Cortex-A7"},
  {"cortex-a8",		ARM_ARCH_V7A_SEC,
					 ARM_FEATURE (0, FPU_VFP_V3
d22986 3
a22988 3
                                                          "Cortex-A8"},
  {"cortex-a9",		ARM_ARCH_V7A_MP_SEC,
					 ARM_FEATURE (0, FPU_VFP_V3
d22990 13
a23002 13
                                                          "Cortex-A9"},
  {"cortex-a15",	ARM_ARCH_V7A_IDIV_MP_SEC_VIRT,
					 FPU_ARCH_NEON_VFP_V4,
                                                          "Cortex-A15"},
  {"cortex-r4",		ARM_ARCH_V7R,	 FPU_NONE,	  "Cortex-R4"},
  {"cortex-r4f",	ARM_ARCH_V7R,	 FPU_ARCH_VFP_V3D16,
  							  "Cortex-R4F"},
  {"cortex-r5",		ARM_ARCH_V7R_IDIV,
					 FPU_NONE,	  "Cortex-R5"},
  {"cortex-m4",		ARM_ARCH_V7EM,	 FPU_NONE,	  "Cortex-M4"},
  {"cortex-m3",		ARM_ARCH_V7M,	 FPU_NONE,	  "Cortex-M3"},
  {"cortex-m1",		ARM_ARCH_V6SM,	 FPU_NONE,	  "Cortex-M1"},
  {"cortex-m0",		ARM_ARCH_V6SM,	 FPU_NONE,	  "Cortex-M0"},
d23004 1
a23004 1
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2, NULL},
d23006 3
a23008 3
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2, NULL},
  {"iwmmxt2",		ARM_ARCH_IWMMXT2,FPU_ARCH_VFP_V2, NULL},
  {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2, NULL},
d23010 4
a23013 2
  {"ep9312",	ARM_FEATURE (ARM_AEXT_V4T, ARM_CEXT_MAVERICK), FPU_ARCH_MAVERICK, "ARM920T"},
  {NULL,		ARM_ARCH_NONE,	 ARM_ARCH_NONE, NULL}
d23015 1
d23020 1
d23027 1
d23030 29
a23058 29
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"armv1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"armv2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"armv2a",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv2s",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv3",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"armv3m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"armv4",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"armv4xm",		ARM_ARCH_V4xM,	 FPU_ARCH_FPA},
  {"armv4t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"armv4txm",		ARM_ARCH_V4TxM,	 FPU_ARCH_FPA},
  {"armv5",		ARM_ARCH_V5,	 FPU_ARCH_VFP},
  {"armv5t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP},
  {"armv5txm",		ARM_ARCH_V5TxM,	 FPU_ARCH_VFP},
  {"armv5te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP},
  {"armv5texp",		ARM_ARCH_V5TExP, FPU_ARCH_VFP},
  {"armv5tej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP},
  {"armv6",		ARM_ARCH_V6,	 FPU_ARCH_VFP},
  {"armv6j",		ARM_ARCH_V6,	 FPU_ARCH_VFP},
  {"armv6k",		ARM_ARCH_V6K,	 FPU_ARCH_VFP},
  {"armv6z",		ARM_ARCH_V6Z,	 FPU_ARCH_VFP},
  {"armv6zk",		ARM_ARCH_V6ZK,	 FPU_ARCH_VFP},
  {"armv6t2",		ARM_ARCH_V6T2,	 FPU_ARCH_VFP},
  {"armv6kt2",		ARM_ARCH_V6KT2,	 FPU_ARCH_VFP},
  {"armv6zt2",		ARM_ARCH_V6ZT2,	 FPU_ARCH_VFP},
  {"armv6zkt2",		ARM_ARCH_V6ZKT2, FPU_ARCH_VFP},
  {"armv6-m",		ARM_ARCH_V6M,	 FPU_ARCH_VFP},
  {"armv6s-m",		ARM_ARCH_V6SM,	 FPU_ARCH_VFP},
  {"armv7",		ARM_ARCH_V7,	 FPU_ARCH_VFP},
d23061 11
a23071 11
  {"armv7a",		ARM_ARCH_V7A,	 FPU_ARCH_VFP},
  {"armv7r",		ARM_ARCH_V7R,	 FPU_ARCH_VFP},
  {"armv7m",		ARM_ARCH_V7M,	 FPU_ARCH_VFP},
  {"armv7-a",		ARM_ARCH_V7A,	 FPU_ARCH_VFP},
  {"armv7-r",		ARM_ARCH_V7R,	 FPU_ARCH_VFP},
  {"armv7-m",		ARM_ARCH_V7M,	 FPU_ARCH_VFP},
  {"armv7e-m",		ARM_ARCH_V7EM,	 FPU_ARCH_VFP},
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
  {"iwmmxt2",		ARM_ARCH_IWMMXT2,FPU_ARCH_VFP},
  {NULL,		ARM_ARCH_NONE,	 ARM_ARCH_NONE}
d23073 1
d23079 1
d23086 1
d23089 18
a23106 15
  {"idiv",	ARM_FEATURE (ARM_EXT_ADIV | ARM_EXT_DIV, 0),
				   ARM_FEATURE (ARM_EXT_V7A | ARM_EXT_V7R, 0)},
  {"iwmmxt",	ARM_FEATURE (0, ARM_CEXT_IWMMXT),	ARM_ANY},
  {"iwmmxt2",	ARM_FEATURE (0, ARM_CEXT_IWMMXT2),	ARM_ANY},
  {"maverick",	ARM_FEATURE (0, ARM_CEXT_MAVERICK),	ARM_ANY},
  {"mp",	ARM_FEATURE (ARM_EXT_MP, 0),
		     ARM_FEATURE (ARM_EXT_V7A | ARM_EXT_V7R, 0)},
  {"os",	ARM_FEATURE (ARM_EXT_OS, 0),
    				   ARM_FEATURE (ARM_EXT_V6M, 0)},
  {"sec",	ARM_FEATURE (ARM_EXT_SEC, 0),
    		     ARM_FEATURE (ARM_EXT_V6K | ARM_EXT_V7A, 0)},
  {"virt",	ARM_FEATURE (ARM_EXT_VIRT | ARM_EXT_ADIV | ARM_EXT_DIV, 0),
				   ARM_FEATURE (ARM_EXT_V7A, 0)},
  {"xscale",	ARM_FEATURE (0, ARM_CEXT_XSCALE),	ARM_ANY},
  {NULL,	ARM_ARCH_NONE,			  ARM_ARCH_NONE}
d23108 1
d23192 1
a23192 1
arm_parse_extension (char * str, const arm_feature_set **opt_p)
d23212 2
a23213 2
      char * ext;
      size_t optlen;
d23225 1
a23225 1
	optlen = ext - str;
d23227 1
a23227 1
	optlen = strlen (str);
d23229 1
a23229 2
      if (optlen >= 2
	  && strncmp (str, "no", 2) == 0)
d23237 1
a23237 1
	  optlen -= 2;
d23240 1
a23240 1
      else if (optlen > 0)
d23255 1
a23255 1
      if (optlen == 0)
d23266 1
a23266 2
	if (strncmp (opt->name, str, optlen) == 0
	    && strlen (opt->name) == optlen)
d23290 1
a23290 1
	    if (strncmp (opt->name, str, optlen) == 0)
d23315 1
a23315 1
arm_parse_cpu (char * str)
d23317 3
a23319 3
  const struct arm_cpu_option_table * opt;
  char * ext = strchr (str, '+');
  int optlen;
d23322 1
a23322 1
    optlen = ext - str;
d23324 1
a23324 1
    optlen = strlen (str);
d23326 1
a23326 1
  if (optlen == 0)
d23333 1
a23333 1
    if (strncmp (opt->name, str, optlen) == 0)
d23341 1
a23341 1
	    int i;
d23343 1
a23343 1
	    for (i = 0; i < optlen; i++)
d23359 1
a23359 1
arm_parse_arch (char * str)
d23363 1
a23363 1
  int optlen;
d23366 1
a23366 1
    optlen = ext - str;
d23368 1
a23368 1
    optlen = strlen (str);
d23370 1
a23370 1
  if (optlen == 0)
d23377 1
a23377 1
    if (strncmp (opt->name, str, optlen) == 0)
d23843 1
@


1.505
log
@2011-11-23  Thomas Klein  <th.r.klein@@web.de>

	* config/tc-arm.c (do_t_mov_cmp): Prevent emitting code for MOV
	with two low register at arch v4t or v5t when assember using
	unified syntax.
@
text
@d10917 10
a10926 4
	       results. Don't allow this.*/
	    constraint (low_regs && !ARM_CPU_HAS_FEATURE (selected_cpu,
			arm_ext_v6),"MOV Rd, Rs with two low registers is not "
			"permitted on this architecture");
@


1.504
log
@	* gas/config/tc-arm.c (arm_cpus): Add cortex-a7 entry.
	* gas/doc/c-arm.texi (ARM Options): Add cortex-a7 to list of accepted
	CPUs.
@
text
@d10916 5
@


1.503
log
@	* config/tc-arm.c (md_begin): Remove ARM_PLT32 reloc associated
	with the (PLT) instruction suffix when operating in eabi mode.
	* doc/c-arm.texi (ARM_Relocations): Extend description of (PLT)
	suffix.

	* gas/arm/pic.d: Update expected output.
@
text
@d22965 3
@


1.502
log
@    Jie Zhang  <jie@@codesourcery.com>
    Julian Brown  <julian@@codesourcery.com>

    gas/
    * config/tc-arm.c (parse_shifter_operand): Fix handling
    of explicit rotation.
    (encode_arm_shifter_operand): Likewise.

    gas/testsuite/
    * gas/arm/adrl.d: Adjust.
    * gas/arm/immed2.d: New test.
    * gas/arm/immed2.s: New test.

    ld/testsuite/
    * ld-arm/cortex-a8-fix-b-plt.d: Adjust.
    * ld-arm/cortex-a8-fix-bcc-plt.d: Adjust.
    * ld-arm/cortex-a8-fix-bl-plt.d: Adjust.
    * ld-arm/cortex-a8-fix-bl-rel-plt.d: Adjust.
    * ld-arm/cortex-a8-fix-blx-plt.d: Adjust.
    * ld-arm/ifunc-1.dd: Adjust.
    * ld-arm/ifunc-2.dd: Adjust.
    * ld-arm/ifunc-3.dd: Adjust.
    * ld-arm/ifunc-4.dd: Adjust.
    * ld-arm/ifunc-5.dd: Adjust.
    * ld-arm/ifunc-6.dd: Adjust.
    * ld-arm/ifunc-7.dd: Adjust.
    * ld-arm/ifunc-8.dd: Adjust.
    * ld-arm/ifunc-9.dd: Adjust.
    * ld-arm/ifunc-10.dd: Adjust.
    * ld-arm/ifunc-14.dd: Adjust.
    * ld-arm/ifunc-15.dd: Adjust.
    * ld-arm/ifunc-16.dd: Adjust.

    opcodes/
    * arm-dis.c (print_insn_arm): Explicitly specify rotation
    if needed.
@
text
@d35 1
a35 1

d2057 1
d22424 10
a22433 2
  for (i = 0; i < sizeof (reloc_names) / sizeof (struct reloc_entry); i++)
    hash_insert (arm_reloc_hsh, reloc_names[i].name, (void *) (reloc_names + i));
@


1.501
log
@	* config/tc-arm.c (check_ldr_r15_aligned): New.
	(do_ldst): Warn in upredictable cases.
	(do_t_ldst): Likewise.
	(insns): Update accordingly.

	* gas/arm/ldr-bad.s: New testcase.
	* gas/arm/ldr-bad.l: Likewise.
	* gas/arm/ldr-bad.d: Likewise.
	* gas/arm/ldr.s: Likewise.
	* gas/arm/ldr.d: Likewise.
	* gas/arm/ldr-t-bad.s: Likewise.
	* gas/arm/ldr-t-bad.l: Likewise.
	* gas/arm/ldr-t-bad.d: Likewise.
	* gas/arm/ldr-t.s: Likewise.
	* gas/arm/ldr-t.d: Likewise.
	* gas/arm/sp-pc-usage-t.s: Correct.
	* gas/arm/sp-pc-usage-t.d: Update accordingly.
@
text
@d4887 3
a4889 4
      /* Convert to decoded value.  md_apply_fix will put it back.  */
      inst.reloc.exp.X_add_number
	= (((inst.reloc.exp.X_add_number << (32 - value))
	    | (inst.reloc.exp.X_add_number >> value)) & 0xffffffff);
d7020 5
a7024 1
    inst.instruction |= INST_IMMEDIATE;
@


1.500
log
@	* config/tc-arm.c (do_t_strexbh): New.
	(insns): Update accordingly.

	* gas/arm/strex-bad-t.d: New testcase.
	* gas/arm/strex-bad-t.s: Likewise.
	* gas/arm/strex-bad-t.l: Likewise.
	* gas/arm/strex-t.s: Likewise.
	* gas/arm/strex-t.d: Likewise.
@
text
@d7918 12
d7938 1
d10549 1
a10549 2
      if (inst.operands[1].immisreg && opcode != T_MNEM_ldr
	  && opcode != T_MNEM_str)
d10552 4
d10559 1
@


1.500.2.1
log
@	Apply mainline patches
	2011-11-07  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/config/tc-arm.c (arm_cpus): Add cortex-a7 entry.
	* gas/doc/c-arm.texi (ARM Options): Add cortex-a7 to list of accepted
	CPUs.
@
text
@a22935 3
  {"cortex-a7",		ARM_ARCH_V7A_IDIV_MP_SEC_VIRT,
    					 FPU_ARCH_NEON_VFP_V4,
					 		  "Cortex-A7"},
@


1.499
log
@	PR ld/12974
	* config/tc-arm.c (literal_pool): Add locs field.
	(add_to_lit_pool): Initialise the locs entry for the new literal.
	(s_ltorg): Generate a DWARF2 line number entry for each emitted
	literal pool entry.
@
text
@d8504 15
d17534 1
a17534 1
     strex, rm_rd_rn),
d17536 1
a17536 1
     strex, rm_rd_rn), 
@


1.498
log
@	* gas/arm/addthumb2err.s: New test file.
	* gas/arm/addthumb2err.d: Test control file.
	* gas/arm/addthumb2err.l: Expected error messages.

	* config/tc-arm.c (do_t_add_sub): Only allow LSL shifts of less
	than 4 in Thumb mode.
@
text
@d762 3
d3080 8
d3185 8
a3192 2
    /* First output the expression in the instruction to the pool.  */
    emit_expr (&(pool->literals[entry]), 4); /* .word  */
@


1.497
log
@	PR gas/12848
	* config/tc-arm.c (BAD_RANGE): New error message define.
	(md_apply_fix): Use it.
	Fix range check for thumb branch instructions.
@
text
@d9477 3
d9530 4
@


1.496
log
@	PR gas/12931
	* config/tc-arm.c (mapping_state): When changing to ARM or THUMB
	state set the minimum required alignment of the section.
@
text
@d727 1
d20948 1
a20948 2
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d20984 1
a20984 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
		          _("branch out of range"));
d20997 1
a20997 2
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d21009 1
a21009 2
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d21029 1
a21029 1
      if ((value & ~0x1fffff) && ((value & ~0x1fffff) != ~0x1fffff))
a21053 1

a21077 1

a21107 1

d21109 8
a21116 13
	{
	  if (!(ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2)))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("branch out of range"));
	    }
	  else if ((value & ~0x1ffffff)
		   && ((value & ~0x1ffffff) != ~0x1ffffff))
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Thumb2 branch out of range"));
	      }
	}
d21124 2
a21125 3
      if ((value & ~0x1ffffff) && ((value & ~0x1ffffff) != ~0x1ffffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
@


1.495
log
@2011-06-21  Sameera Deshpande  <sameera.deshpande@@arm.com>
	* gas/config/tc-arm.c (vfp_conv): Add check on range of immediate operand
	in vcvt instruction between floating-point and fixed-point.
	(operand_parse_code): Add "OP_oI32z".
	(parse_operands): OP_oI32z case added.
	* gas/testsuite/gas/arm/vcvt-bad.d: New test.
	* gas/testsuite/gas/arm/vcvt-bad.l: Likewise.
	* gas/testsuite/gas/arm/vcvt-bad.s: Likewise.
	* gas/testsuite/gas/arm/vcvt.d: Likewise.
	* gas/testsuite/gas/arm/vcvt.s: Likewise.
@
text
@d2592 18
a2609 1
  else if (TRANSITION (MAP_UNDEFINED, MAP_DATA))
@


1.494
log
@PR gas/12854
Add additional checks for extraneous shifts and extra tests in the testsuite.
@
text
@d6121 1
d6451 1
d8741 17
a8757 1
  unsigned immbits = srcsize - inst.operands[1].imm;
d18198 1
a18198 1
 nCEF(vcvt,     _vcvt,   3, (RNSDQ, RNSDQ, oI32b), neon_cvt),
@


1.493
log
@	PR gas/12854
	* gas/arm/shift-bad.s: New test.
	* gas/arm/shift-bad.l: Expcted error output.
	* gas/arm/shift-bad.s: New control file.

	* config/tc-arm.c (do_shift): Do not allow shift operations at the
	end of a register based shift insn.
	(do_t_shift): Likewise.
@
text
@d11573 4
d11616 4
@


1.492
log
@2011-06-09  James Greenhalgh  <james.greenhalgh@@arm.com>

	* config/tc-arm.c (do_ldrd): Warn in unpredictable cases.

2011-06-09  James Greenhalgh  <james.greenhalgh@@arm.com>

	* gas/arm/ldrd-unpredicatble.d: New testcase.
	* gas/arm/ldrd-unpredicatble.s: Likewise.
	* gas/arm/ldrd-unpredicatble.l: Likewise.
@
text
@d8346 3
d11541 4
@


1.491
log
@	PR gas/12698
	* config/tc-arm.c (parse_psr): Set m_profile to false when
	assembling for any architecture.
@
text
@d7801 1
a7801 1
	      _("first destination register must be even"));
d7804 1
a7804 1
	      _("can only load two consecutive registers"));
d7811 10
a7820 1
  if (inst.instruction & LOAD_BIT)
a7821 9
      /* encode_arm_addr_mode_3 will diagnose overlap between the base
	 register and the first register written; we have to diagnose
	 overlap between the base and the second register written here.	 */

      if (inst.operands[2].reg == inst.operands[1].reg
	  && (inst.operands[2].writeback || inst.operands[2].postind))
	as_warn (_("base register written back, and overlaps "
		   "second destination register"));

d7823 5
a7827 5
	 destination (even if not write-back).	*/
      else if (inst.operands[2].immisreg
	       && ((unsigned) inst.operands[2].imm == inst.operands[0].reg
		   || (unsigned) inst.operands[2].imm == inst.operands[1].reg))
	as_warn (_("index register overlaps destination register"));
a7828 1

@


1.490
log
@	gas/
	* config/tc-arm.c (parse_address_main): Handle -0 offsets.
	(encode_arm_addr_mode_2): Set default sign of zero here ...
	(encode_arm_addr_mode_3): ... and here.
	(encode_arm_cp_address): ... and here.
	(md_apply_fix): Use default sign of zero here.

	gas/testsuite/
	* gas/arm/inst.d: Adjust for signed zero offsets.
	* gas/arm/ldst-offset0.d: New test.
	* gas/arm/ldst-offset0.s: New test.
	* gas/arm/offset-1.d: New test.
	* gas/arm/offset-1.s: New test.

	ld/testsuite/
	Adjust tests for zero offset formatting.
	* ld-arm/cortex-a8-fix-bcc-plt.d: Adjust.
	* ld-arm/farcall-arm-arm-pic-veneer.d: Adjust.
	* ld-arm/farcall-arm-thumb.d: Adjust.
	* ld-arm/farcall-group-size2.d: Adjust.
	* ld-arm/farcall-group.d: Adjust.
	* ld-arm/farcall-mix.d: Adjust.
	* ld-arm/farcall-mix2.d: Adjust.
	* ld-arm/farcall-mixed-lib-v4t.d: Adjust.
	* ld-arm/farcall-mixed-lib.d: Adjust.
	* ld-arm/farcall-thumb-arm-blx-pic-veneer.d: Adjust.
	* ld-arm/farcall-thumb-arm-pic-veneer.d: Adjust.
	* ld-arm/farcall-thumb-thumb.d: Adjust.
	* ld-arm/ifunc-10.dd: Adjust.
	* ld-arm/ifunc-3.dd: Adjust.
	* ld-arm/ifunc-4.dd: Adjust.
	* ld-arm/ifunc-5.dd: Adjust.
	* ld-arm/ifunc-6.dd: Adjust.
	* ld-arm/ifunc-7.dd: Adjust.
	* ld-arm/ifunc-8.dd: Adjust.
	* ld-arm/jump-reloc-veneers-long.d: Adjust.
	* ld-arm/tls-longplt-lib.d: Adjust.
	* ld-arm/tls-thumb1.d: Adjust.

	opcodes/
	* arm-dis.c (print_insn_coprocessor): Explicitly print #-0
	as address offset.
	(print_arm_address): Likewise. Elide positive #0 appropriately.
	(print_insn_arm): Likewise.
@
text
@d5398 6
@


1.489
log
@2011-05-31  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_cpus): Add Cortex-R5.
	(arm_extensions): Allow idiv on ARMv7-R.
	* doc/c-arm.text: Update idiv extension restrictions.

	gas/testsuite/
	* gas/arm/arm-idiv-bad.d: New test.
	* gas/arm/arm-idiv-bad.s: New test.
	* gas/arm/arm-idiv-bad.l: New test.
	* gas/arm/arm-idiv.d: New test.
	* gas/arm/arm-idiv.s: New test.

	include/
	* opcode/arm.h (ARM_ARCH_V7R_IDIV): Define.
@
text
@d5203 18
a5220 2
	    if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	      return PARSE_OPERAND_FAIL;
d5294 1
d5302 13
d7071 6
a7076 1
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d7112 7
a7118 1
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
d7180 4
d20495 1
a20495 1
      sign = value >= 0;
d20513 7
a20519 2
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
d20525 1
a20525 1
      sign = value >= 0;
d20542 7
a20548 2
      newval &= 0xff7ff0f0;
      newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
d21175 1
a21175 1
      sign = value >= 0;
d21183 7
a21189 2
      newval &= 0xff7fff00;
      newval |= (value >> 2) | (sign ? INDEX_UP : 0);
@


1.488
log
@2011-05-31  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_force_relocation): Resolve all pc-relative
	loads.

	gas/testsuite/
	* gas/arm/ldr-global.d: New test.
	* gas/arm/ldr-global.s: New test.
@
text
@d22808 2
d22893 1
a22893 1
				   ARM_FEATURE (ARM_EXT_V7A, 0)},
@


1.487
log
@2011-05-31  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_t_branch): Avoid relaxing branches to constant
	addresses.

	gas/testsuite/
	* arm/t2-branch-global.d: New test.
	* arm/t2-branch-global.s: New test.
@
text
@d21898 5
a21902 1
  /* Resolve these relocations even if the symbol is extern or weak.  */
d21905 1
d21907 3
d21913 4
a21916 1
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_ADD_PC12)
@


1.486
log
@2011-05-31  Paul Brook  <paul@@codesourcery.com>
	Nathan Sidwell  <nathan@@codesourcery.com>

	gas/
	* config/tc-arm.c (fix_new_arm): Create an absolute symbol for
	pc-relative fixes to constants.
	* config/tc-arm.h (TC_FORCE_RELOCATATION_ABS): Define.

	ld/testsuite/
	* ld-arm/abs-call-1.d: New.
	* ld-arm/abs-call-1.s: New.
	* ld-arm/arm-elf.exp: Add it.
@
text
@d9848 3
a9850 1
	  || (inst.size_req != 2 && inst.operands[0].hasreloc)))
@


1.485
log
@	* config/tc-arm.c (s_unreq): Reword warning message to make it
	easier to translate.
	* config/tc-ia64.c (md_show_usage): Add note for translators.
	* configure.in (ALL_LINGUAS): Add "fi".
	* configure: Regenerate.
@
text
@d15437 23
@


1.484
log
@	PR gas/12715
	* gas/config/tc-arm.c (parse_big_immediate):  Fix parsing of 64-bit
	immediates on 32-bit hosts.
	* gas/testsuite/gas/arm/neon-const.s: Add testcase for 64-bit Neon constants.
	* gas/testsuite/gas/arm/neon-const.d: Likewise.
@
text
@d2415 1
a2415 1
	as_warn (_("ignoring attempt to undefine built-in register '%s'"),
@


1.483
log
@	* config/tc-arm.c(do_t_ldst): Warn on loading into sp with
	writeback for appropriate cores/arch.
	* testsuite/gas/arm/ld-sp-warn-cortex-m3.d: New test.
	* testsuite/gas/arm/ld-sp-warn-cortex-m3.l: New test.
	* testsuite/gas/arm/ld-sp-warn-cortex-m4.d: New test.
	* testsuite/gas/arm/ld-sp-warn-cortex-m4.l: New test.
	* testsuite/gas/arm/ld-sp-warn-v7.d: New test.
	* testsuite/gas/arm/ld-sp-warn-v7.l: New test.
	* testsuite/gas/arm/ld-sp-warn-v7a.d: New test.
	* testsuite/gas/arm/ld-sp-warn-v7a.l: New test.
	* testsuite/gas/arm/ld-sp-warn-v7e-m.l: New test.
	* testsuite/gas/arm/ld-sp-warn-v7em.d: New test.
	* testsuite/gas/arm/ld-sp-warn-v7m.d: New test.
	* testsuite/gas/arm/ld-sp-warn-v7m.l: New test.
	* testsuite/gas/arm/ld-sp-warn-v7r.d: New test.
	* testsuite/gas/arm/ld-sp-warn-v7r.l: New test.
	* testsuite/gas/arm/ld-sp-warn.s: New test.
@
text
@d4462 1
a4462 1
      if ((exp.X_add_number & ~0xffffffffl) != 0)
@


1.482
log
@	* config/tc-arm.c (v7m_psrs): Revert previous delta.

	* gas/arm/mrs-msr-thumb-v7e-m.s: Restore name of basepri_max
	register.
	* gas/arm/mrs-msr-thumb-v7e-m.d: Likewise.
	* gas/arm/arch7.d: Likewise.
	* gas/arm/arch7.s: Likewise.

	* arm-dis.c: Revert previous reversion.
@
text
@d242 9
d10390 15
@


1.481
log
@	* gas/arm/arch7.s: Fix typo basepri_max should be basepri_mask.
	* gas/arm/mrs-msr-thumb-v7e-m.s: Likewise.
	* gas/arm/arch7.d: Update expected disassembly.
	* gas/arm/attr-march-armv7.d: Remove Microcontroller tag.
	* gas/arm/blx-bad.d: Only run for ELF based targets.
	* gas/arm/mrs-msr-thumb-v6t2.d: Likewise.
	* gas/arm/vldm-arm.d: Likewise.
	* gas/arm/mrs-msr-thumb-v7-m.d: Likewise.
	Remove qualifiers from PSR and IAPSR regsiter names.
	* gas/arm/mrs-msr-thumb-v7e-m.d: Likewise.
	* gas/arm/thumb2_bcond.d: Update expected disassembly to allow for
	relaxing of branch insns.
	* gas/arm/thumb32.d: Fix whitespace problems in disassembly.

	* config/tc-arm.c (parse_psr): Use selected_cpu not cpu_variant to
	detect M-profile targets.
	(do_t_swi): Exclude v7 and higher variants from arm_ext_os test.
	(v7m_psrs): Fix typo: basepri_max should be basepri_mask.

	* arm-dis.c (psr_name): Revert previous delta.

	* arm.h (ARM_AEXT_V7_ARM): Remove ARM_EXT_OS from bitmask.
@
text
@d16637 2
a16638 2
  {"basepri_max", 18}, {"BASEPRI_MAX",	18}, /* Typo, preserved for backwards compatibility.  */
  {"basepri_mask",18}, {"BASEPRI_MASK",	18},
@


1.480
log
@	PR gas/12532
	* config/tc-arm.c (relax_branch): Do not relax branches to
	preemptable global symbols.
@
text
@d5357 1
a5357 1
  bfd_boolean m_profile = ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_m);
d11763 3
a11765 1
      if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_os))
d16637 2
a16638 1
  {"basepri_max", 18}, {"BASEPRI_MAX",	18},
@


1.479
log
@    gas/
    * config/tc-arm.c (parse_psr): Add LHS argument. Improve support
    for *APSR bitmasks.
    (operand_parse_code): Replace OP_PSR with OP_wPSR and OP_rPSR.
    Remove OP_RVC_PSR.
    (parse_operands): Likewise.
    (do_mrs): Tweak error message for constraint.
    (do_t_mrs): Update constraints for changes to APSR support.
    (do_t_msr): Likewise. Don't set PSR_f flag here.
    (psrs): Remove "g", "nzcvq", "nzcvqg".
    (insns): Tweak entries for msr and mrs instructions.

    opcodes/
    * arm-dis.c (psr_name): Fix typo for BASEPRI_MAX.
    (print_insn_thumb32): Add APSR bitmask support.

    gas/testsuite/
    * gas/arm/mrs-msr-thumb-v7-m.s: New.
    * gas/arm/mrs-msr-thumb-v7-m.d: New.
    * gas/arm/mrs-msr-thumb-v7-m-bad.d: New.
    * gas/arm/mrs-msr-thumb-v7-m-bad.l: New.
    * gas/arm/mrs-msr-thumb-v7-m-bad.s: New.
    * gas/arm/mrs-msr-thumb-v7e-m.d: New.
    * gas/arm/mrs-msr-thumb-v7e-m.s: New.
    * gas/arm/mrs-msr-arm-v7-a-bad.d: New.
    * gas/arm/mrs-msr-arm-v7-a-bad.l: New.
    * gas/arm/mrs-msr-arm-v7-a-bad.s: New.
    * gas/arm/mrs-msr-arm-v7-a.d: New.
    * gas/arm/mrs-msr-arm-v7-a.s: New.
    * gas/arm/mrs-msr-arm-v6.d: New.
    * gas/arm/mrs-msr-arm-v6.s: New.
    * gas/arm/mrs-msr-thumb-v6t2.d: New.
    * gas/arm/mrs-msr-thumb-v6t2.s: New.
    * gas/arm/arch7.d: Fix typo in disassembly for BASEPRI_MAX,
    bitmasks for IAPSR etc.
    * gas/arm/arch7.s: Specify bitmask for APSR writes.
    * gas/arm/archv6m.s: Likewise.
    * msr-imm-bad.l: Tweak expected disassembly in error message.
    * msr-reg-bad.l: Likewise.
    * msr-imm.d: Tweak expected disassembly.
    * msr-reg.d: Likewise.
    * msr-reg-thumb.d: Likewise.
    * msr-imm.s: Specify bitmask on APSR writes.
    * msr-reg.s: Add comment about deprecated usage.
@
text
@d19078 6
@


1.478
log
@include/elf/
	* arm.h (R_ARM_IRELATIVE): New relocation.

bfd/
	* reloc.c (BFD_RELOC_ARM_IRELATIVE): New relocation.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_howto_table_2): Rename existing definition
	to elf32_arm_howto_table_3 and replace with a single R_ARM_IRELATIVE
	entry.
	(elf32_arm_howto_from_type): Update accordingly.
	(elf32_arm_reloc_map): Map BFD_RELOC_ARM_IRELATIVE to R_ARM_IRELATIVE.
	(elf32_arm_reloc_name_lookup): Handle elf32_arm_howto_table_3.
	(arm_plt_info): New structure, split out from elf32_arm_link_hash_entry
	with an extra noncall_refcount field.
	(arm_local_iplt_info): New structure.
	(elf_arm_obj_tdata): Add local_iplt.
	(elf32_arm_local_iplt): New accessor macro.
	(elf32_arm_link_hash_entry): Replace plt_thumb_refcount,
	plt_maybe_thumb_refcount and plt_got_offset with an arm_plt_info.
	Change tls_type to a bitfield and add is_iplt.
	(elf32_arm_link_hash_newfunc): Update accordingly.
	(elf32_arm_allocate_local_sym_info): New function.
	(elf32_arm_create_local_iplt): Likewise.
	(elf32_arm_get_plt_info): Likewise.
	(elf32_arm_plt_needs_thumb_stub_p): Likewise.
	(elf32_arm_get_local_dynreloc_list): Likewise.
	(create_ifunc_sections): Likewise.
	(elf32_arm_copy_indirect_symbol): Update after the changes to
	elf32_arm_link_hash_entry.  Assert the is_iplt has not yet been set.
	(arm_type_of_stub): Add an st_type argument.  Use elf32_arm_get_plt_info
	to get PLT information.  Assert that all STT_GNU_IFUNC references
	are turned into PLT references.
	(arm_build_one_stub): Pass the symbol type to
	elf32_arm_final_link_relocate.
	(elf32_arm_size_stubs): Pass the symbol type to arm_type_of_stub.
	(elf32_arm_allocate_irelocs): New function.
	(elf32_arm_add_dynreloc): In static objects, use .rel.iplt for
	all R_ARM_IRELATIVE.
	(elf32_arm_allocate_plt_entry): New function.
	(elf32_arm_populate_plt_entry): Likewise.
	(elf32_arm_final_link_relocate): Add an st_type parameter.
	Set srelgot to null for static objects.  Use separate variables
	to record which st_value and st_type should be used when generating
	a dynamic relocation.  Use elf32_arm_get_plt_info to find the
	symbol's PLT information, setting has_iplt_entry, splt,
	plt_offset and gotplt_offset accordingly.  Check whether
	STT_GNU_IFUNC symbols should resolve to an .iplt entry, and change
	the relocation target accordingly.  Broaden assert to include
	.iplts.  Don't set sreloc for static relocations.  Assert that
	we only generate dynamic R_ARM_RELATIVE relocations for R_ARM_ABS32
	and R_ARM_ABS32_NOI.  Generate R_ARM_IRELATIVE relocations instead
	of R_ARM_RELATIVE relocations if the target is an STT_GNU_IFUNC
	symbol.  Pass the symbol type to arm_type_of_stub.  Conditionally
	resolve GOT references to the .igot.plt entry.
	(elf32_arm_relocate_section): Update the call to
	elf32_arm_final_link_relocate.
	(elf32_arm_gc_sweep_hook): Use elf32_arm_get_plt_info to get PLT
	information.  Treat R_ARM_REL32 and R_ARM_REL32_NOI as call
	relocations in shared libraries and relocatable executables.
	Count non-call PLT references.  Use elf32_arm_get_local_dynreloc_list
	to get the list of dynamic relocations for a local symbol.
	(elf32_arm_check_relocs): Always create ifunc sections.  Set isym
	at the same time as setting h.  Use elf32_arm_allocate_local_sym_info
	to allocate local symbol information.  Treat R_ARM_REL32 and
	R_ARM_REL32_NOI as call relocations in shared libraries and
	relocatable executables.  Record PLT information for local
	STT_GNU_IFUNC functions as well as global functions.   Count
	non-call PLT references.  Use elf32_arm_get_local_dynreloc_list
	to get the list of dynamic relocations for a local symbol.
	(elf32_arm_adjust_dynamic_symbol): Handle STT_GNU_IFUNC symbols.
	Don't remove STT_GNU_IFUNC PLTs unless all references have been
	removed.  Update after the changes to elf32_arm_link_hash_entry.
	(allocate_dynrelocs_for_symbol): Decide whether STT_GNU_IFUNC PLT
	entries should live in .plt or .iplt.  Check whether the .igot.plt
	and .got entries can be combined.  Use elf32_arm_allocate_plt_entry
	to allocate .plt and .(i)got.plt entries.  Detect which .got
	entries will need R_ARM_IRELATIVE relocations and use
	elf32_arm_allocate_irelocs to allocate them.  Likewise other
	non-.got dynamic relocations.
	(elf32_arm_size_dynamic_sections): Allocate .iplt, .igot.plt
	and dynamic relocations for local STT_GNU_IFUNC symbols.
	Check whether the .igot.plt and .got entries can be combined.
	Detect which .got entries will need R_ARM_IRELATIVE relocations
	and use elf32_arm_allocate_irelocs to allocate them.  Use stashed
	section pointers intead of strcmp checks.  Handle iplt and igotplt.
	(elf32_arm_finish_dynamic_symbol): Use elf32_arm_populate_plt_entry
	to fill in .plt, .got.plt and .rel(a).plt entries.  Point
	STT_GNU_IFUNC symbols at an .iplt entry if non-call relocations
	resolve to it.
	(elf32_arm_output_plt_map_1): New function, split out from
	elf32_arm_output_plt_map.  Handle .iplt entries.  Use
	elf32_arm_plt_needs_thumb_stub_p.
	(elf32_arm_output_plt_map): Call it.
	(elf32_arm_output_arch_local_syms): Add mapping symbols for
	local .iplt entries.
	(elf32_arm_swap_symbol_in): Handle Thumb STT_GNU_IFUNC symbols.
	(elf32_arm_swap_symbol_out): Likewise.
	(elf32_arm_add_symbol_hook): New function.
	(elf_backend_add_symbol_hook): Define for all targets.

opcodes/
	* arm-dis.c (get_sym_code_type): Treat STT_GNU_IFUNCs as code.

gas/
	* config/tc-arm.c (md_pcrel_from_section): Use S_FORCE_RELOC to
	determine whether a relocation is needed.
	(md_apply_fix, arm_apply_sym_value): Likewise.

ld/testsuite/
	* ld-arm/ifunc-1.s, ld-arm/ifunc-1.dd, ld-arm/ifunc-1.gd,
	ld-arm/ifunc-1.rd, ld-arm/ifunc-2.s, ld-arm/ifunc-2.dd,
	ld-arm/ifunc-2.gd, ld-arm/ifunc-2.rd, ld-arm/ifunc-3.s,
	ld-arm/ifunc-3.dd, ld-arm/ifunc-3.gd, ld-arm/ifunc-3.rd,
	ld-arm/ifunc-4.s, ld-arm/ifunc-4.dd, ld-arm/ifunc-4.gd,
	ld-arm/ifunc-4.rd, ld-arm/ifunc-5.s, ld-arm/ifunc-5.dd,
	ld-arm/ifunc-5.gd, ld-arm/ifunc-5.rd, ld-arm/ifunc-6.s,
	ld-arm/ifunc-6.dd, ld-arm/ifunc-6.gd, ld-arm/ifunc-6.rd,
	ld-arm/ifunc-7.s, ld-arm/ifunc-7.dd, ld-arm/ifunc-7.gd,
	ld-arm/ifunc-7.rd, ld-arm/ifunc-8.s, ld-arm/ifunc-8.dd,
	ld-arm/ifunc-8.gd, ld-arm/ifunc-8.rd, ld-arm/ifunc-9.s,
	ld-arm/ifunc-9.dd, ld-arm/ifunc-9.gd, ld-arm/ifunc-9.rd,
	ld-arm/ifunc-10.s, ld-arm/ifunc-10.dd, ld-arm/ifunc-10.gd,
	ld-arm/ifunc-10.rd, ld-arm/ifunc-11.s, ld-arm/ifunc-11.dd,
	ld-arm/ifunc-11.gd, ld-arm/ifunc-11.rd, ld-arm/ifunc-12.s,
	ld-arm/ifunc-12.dd, ld-arm/ifunc-12.gd, ld-arm/ifunc-12.rd,
	ld-arm/ifunc-13.s, ld-arm/ifunc-13.dd, ld-arm/ifunc-13.gd,
	ld-arm/ifunc-13.rd, ld-arm/ifunc-14.s, ld-arm/ifunc-14.dd,
	ld-arm/ifunc-14.gd, ld-arm/ifunc-14.rd, ld-arm/ifunc-15.s,
	ld-arm/ifunc-15.dd, ld-arm/ifunc-15.gd, ld-arm/ifunc-15.rd,
	ld-arm/ifunc-16.s, ld-arm/ifunc-16.dd, ld-arm/ifunc-16.gd,
	ld-arm/ifunc-16.rd, ld-arm/ifunc-dynamic.ld,
	ld-arm/ifunc-static.ld: New tests.
	* ld-arm/farcall-group.d, ld-arm/farcall-group-size2.d,
	ld-arm/farcall-mixed-lib-v4t.d, ld-arm/farcall-mixed-lib.d: Update
	for new stub hashes.
	* ld-arm/arm-elf.exp: Run them.
@
text
@d5350 1
a5350 1
parse_psr (char **str)
d5356 2
d5363 21
a5383 6
    psr_field = SPSR_BIT;
  else if (strncasecmp (p, "CPSR", 4) == 0 
	   || (strncasecmp (p, "APSR", 4) == 0
	       && !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_m)))
    psr_field = 0;
  else
d5390 6
d5398 1
d5402 9
d5412 5
a5416 1
      return psr->field;
d5418 2
d5422 1
d5433 70
a5502 4
      psr = (const struct asm_psr *) hash_find_n (arm_psr_hsh, start,
                                                  p - start);
      if (!psr)
	goto error;
d5504 2
a5505 1
      psr_field |= psr->field;
d5512 12
a5523 1
      psr_field |= (PSR_c | PSR_f);
d5528 5
d6058 2
a6059 1
  OP_PSR,	/* CPSR/SPSR mask for msr */
a6062 1
  OP_RVC_PSR,	/* CPSR/SPSR mask for msr, or VFP control register.  */
a6527 1
	case OP_PSR:	 val = parse_psr (&str);		break;
d6536 2
a6537 5
        case OP_RVC_PSR:
          po_reg_or_goto (REG_TYPE_VFC, try_banked_reg);
          inst.operands[i].isvec = 1;  /* Mark VFP control reg as vector.  */
          break;
	  try_banked_reg:
d6546 3
a6548 3
          try_psr:
          val = parse_psr (&str);
          break;
d6705 2
a6706 2
	case OP_PSR:
        case OP_RVC_PSR:
d8034 1
a8034 1
		  _("'CPSR' or 'SPSR' expected"));
d10950 8
a10957 15
      if (flags == 0)
	{
	  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_m),
		      _("selected processor does not support "
			"requested special purpose register"));
	}
      else
	{
	  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1),
		      _("selected processor does not support "
			"requested special purpose register"));
	  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
	  constraint ((flags & ~SPSR_BIT) != (PSR_c|PSR_f),
		      _("'CPSR' or 'SPSR' expected"));
	}
d10982 1
a10982 1
  if (flags & ~0xff)
d10984 8
a10991 3
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1),
		  _("selected processor does not support "
		    "requested special purpose register"));
d10994 2
a10995 6
    {
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_m),
		  _("selected processor does not support "
		    "requested special purpose register"));
      flags |= PSR_f;
    }
a16555 1
  {"g",	   PSR_s},
a16617 4

  /* APSR flags */
  {"nzcvq", PSR_f},
  {"nzcvqg", PSR_s | PSR_f}
d17066 2
a17067 2
 TCE("mrs",	1000000, f3e08000, 2, (APSR_RR, RVC_PSR), mrs, t_mrs),
 TCE("msr",	120f000, f3808000, 2, (RVC_PSR, RR_EXi), msr, t_msr),
@


1.477
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d19753 1
a19753 1
	  && (!S_IS_EXTERNAL (fixP->fx_addsy))
d19764 1
a19764 1
	  && (!S_IS_EXTERNAL (fixP->fx_addsy))
d19775 1
a19775 1
	  && (!S_IS_EXTERNAL (fixP->fx_addsy))
d19784 1
a19784 1
	  && (!S_IS_EXTERNAL (fixP->fx_addsy))
d20598 1
a20598 1
	  && !S_IS_EXTERNAL (fixP->fx_addsy)
d20618 1
a20618 1
	  && !S_IS_EXTERNAL (fixP->fx_addsy)
d20641 1
a20641 1
	  && !S_IS_EXTERNAL (fixP->fx_addsy)
d20749 1
a20749 2
	  && !S_IS_EXTERNAL (fixP->fx_addsy)
	  && S_IS_DEFINED (fixP->fx_addsy)
d20787 1
a20787 2
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && !S_IS_EXTERNAL (fixP->fx_addsy)
d20811 1
a20811 2
	  && !S_IS_EXTERNAL (fixP->fx_addsy)
	  && S_IS_DEFINED (fixP->fx_addsy)
d23716 1
a23716 1
      && !S_IS_EXTERNAL (fixP->fx_addsy))
@


1.476
log
@	* config/tc-arm.c (arm_cpus): Add Faraday ARMv5TE compatible
	cores: fa606te, fa616te, fmp626.  Modify the VFP of fa626te.
	* doc/c-arm.texi (ARM Options): Add -mcpu={fa606te, fa616te,
	fmp626} options.
@
text
@d22014 2
a22015 2
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_TFUNC);
@


1.475
log
@	* config/tc-arm.c (s_arm_tls_desceq): Move code into ELF-only
	part of the file.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010
d22603 4
a22606 1
  {"fa626te",		ARM_ARCH_V5TE,	 FPU_NONE,	  NULL},
@


1.474
log
@	bfd/
	* reloc.c (BFD_RELOC_ARM_TLS_GOTDESC, BFD_RELOC_ARM_TLS_CALL,
	BFD_RELOC_ARM_THM_TLS_CALL, BFD_RELOC_ARM_TLS_DESCSEQ,
	BFD_RELOC_ARM_THM_TLS_DESCSEQ, BFD_RELOC_ARM_TLS_DESC): New
	relocations.
	* libbfd.h: Rebuilt.
	* bfd-in2.h: Rebuilt.
	* elf32-arm.c (elf32_arm_howto_table_1): Add new relocations.
	(elf32_arm_reloc_map): Likewise.
	(tls_trampoline, dl_tlsdesc_lazy_trampoline): New PLT templates.
	(elf32_arm_stub_long_branch_any_tls_pic,
	elf32_arm_stub_long_branch_v4t_thumb_tls_pic): New stub templates.
	(DEF_STUBS): Add new stubs.
	(struct_elf_arm_obj_data): Add local_tlsdesc_gotent field.
	(elf32_arm_local_tlsdesc_gotent): New.
	(GOT_TLS_GDESC): New mask.
	(GOT_TLS_GD_ANY): Define.
	(struct elf32_arm_link_hash_entry): Add tlsdesc_got field.
	(elf32_arm_compute_jump_table_size): New.
	(struct elf32_arm_link_hash_table): Add next_tls_desc_index,
	num_tls_desc, dt_tlsdesc_plt, dt_tlsdesc_got, tls_trampoline,
	sgotplt_jump_table_size fields.
	(elf32_arm_link_hash_newfunc): Initialize tlsdesc_got field.
	(elf32_arm_link_hash_table_create): Initialize new fields.
	(arm_type_of_stub): Check TLS desc relocs too.
	(elf32_arm_stub_name): TLS desc relocs can be shared.
	(elf32_arm_tls_transition): Determine relaxation.
	(arm_stub_required_alignment): Add tls stubs.
	(elf32_arm_size_stubs): Likewise.
	(elf32_arm_tls_relax): Perform TLS relaxing.
	(elf32_arm_final_link_relocate): Process TLS DESC relocations.
	(IS_ARM_TLS_GNU_RELOC): New.
	(IS_ARM_TLS_RELOC): Use it.
	(elf32_arm_relocate_section): Perform TLS relaxing.
	(elf32_arm_check_relocs): Anticipate TLS relaxing, process tls
	desc relocations.
	(allocate_dynrelocs): Allocate tls desc relcoations.
	(elf32_arm_output_arch_local_syms): Emit tls trampoline mapping
	symbols.
	(elf32_arm_size_dynamic_sections): Allocate tls trampolines and
	got slots.
	(elf32_arm_always_size_sections): New. Create _TLS_MODULE_BASE
	symbol.
	(elf32_arm_finish_dynamic_symbol): Adjust.
	(arm_put_trampoline): New.
	(elf32_arm_finish_dynamic_sections): Emit new dynamic tags and tls
	trampolines.
	(elf_backend_always_size_sections): Define.

	include/elf/
	* arm.h (R_ARM_TLS_DESC, R_ARM_TLS_GOTDESC, R_ARM_TLS_CALL,
	R_ARM_TLS_DESCSEQ, T_ARM_THM_TLS_CALL, R_ARM_THM_TLS_DESCSEQ): New
	relocations.

	gas/
	* doc/c-arm.texi: Document TLSDESC and TLSCALL relocations, and
	.tlsdescseq directive.
	* config/tc-arm.c (arm_typed_reg_parse): Check for potential reloc
	following a symbol.
	(s_arm_tls_descseq): New directive.
	(md_pseudo_table): Add it.
	(encode_branch): Allow TLS_CALL relocs too.
	(do_t_blx, do_t_branch23): Use encode_branch.
	(reloc_names): Add tlsdesc and tlscall.
	(md_apply_fix): Process tls desc relocations.
	(tc_gen_reloc): Likewise.
	(arm_fix_adjustable): Likewise.

	gas/testsuite/
	* gas/arm/tls.s: Add tlsdesc tests.
	* gas/arm/tls.d: Adjust.

	ld/testsuite/
	* ld-arm/arm-elf.exp: Added tests for new TLS handling
	relocations.
	* ld-arm/tls-descrelax-be32.d: New.
	* ld-arm/tls-descrelax-be32.s: New.
	* ld-arm/tls-descrelax-be8.d: New.
	* ld-arm/tls-descrelax-be8.s: New.
	* ld-arm/tls-descrelax-v7.d: New.
	* ld-arm/tls-descrelax-v7.s: New.
	* ld-arm/tls-descrelax.d: New.
	* ld-arm/tls-descrelax.s: New.
	* ld-arm/tls-descseq.d: New.
	* ld-arm/tls-descseq.r: New.
	* ld-arm/tls-descseq.s: New.
	* ld-arm/tls-gdesc-got.d: New.
	* ld-arm/tls-gdesc-got.s: New.
	* ld-arm/tls-gdesc-nlazy.g: New.
	* ld-arm/tls-gdesc-nlazy.s: New.
	* ld-arm/tls-gdesc.d: New.
	* ld-arm/tls-gdesc.r: New.
	* ld-arm/tls-gdesc.s: New.
	* ld-arm/tls-gdierelax.d: New.
	* ld-arm/tls-gdierelax.s: New.
	* ld-arm/tls-gdierelax2.d: New.
	* ld-arm/tls-gdierelax2.s: New.
	* ld-arm/tls-gdlerelax.d: New.
	* ld-arm/tls-gdlerelax.s: New.
	* ld-arm/tls-lib-loc.d: New.
	* ld-arm/tls-lib-loc.r: New.
	* ld-arm/tls-lib-loc.s: New.
	* ld-arm/tls-longplt-lib.d: New.
	* ld-arm/tls-longplt-lib.s: New.
	* ld-arm/tls-longplt.d: New.
	* ld-arm/tls-longplt.s: New.
	* ld-arm/tls-mixed.r: New.
	* ld-arm/tls-mixed.s: New.
	* ld-arm/tls-thumb1.d: New.
	* ld-arm/tls-thumb1.s: New.
	* ld-arm/arm-elf.exp: New.
@
text
@a4277 1
#endif /* OBJ_ELF */
d4302 1
@


1.473
log
@	PR gas/12198
	* gas/config/tc-arm.c (arm_arch_v6m_only): New variable.
	(aeabi_set_public_attributes): Ensure we only set the Operating System
	Extension when we are on an M-profile core.
	* gas/testsuite/gas/arm/pr12198-1.d: New test.
	* gas/testsuite/gas/arm/pr12918-1.s: Likewise.
	* gas/testsuite/gas/arm/pr12198-2.d: Likewise.
	* gas/testsuite/gas/arm/pr12918-2.s: Likewise.
	* include/opcode/arm.h (ARM_AEXT_V6M_ONLY): New define.
	(ARM_AEXT_V6M): Rewrite in terms of ARM_AEXT_V6M_ONLY.
	(ARM_ARCH_V6M_ONLY): New define.
@
text
@d1475 4
d4280 24
d4383 1
d7313 6
a7318 3
      constraint (inst.operands[0].imm != BFD_RELOC_ARM_PLT32,
		  _("the only suffix valid here is '(plt)'"));
      inst.reloc.type  = BFD_RELOC_ARM_PLT32;
d9690 1
a9690 2
      inst.reloc.type = BFD_RELOC_THUMB_PCREL_BLX;
      inst.reloc.pc_rel = 1;
d9768 9
a9776 2
  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
  inst.reloc.pc_rel = 1;
d16558 7
a16564 1
  { "got_prel", BFD_RELOC_ARM_GOT_PREL}, { "GOT_PREL", BFD_RELOC_ARM_GOT_PREL}
d20882 8
d21491 4
d21540 1
d21802 5
@


1.472
log
@gas/
	* config/tc-arm.c (do_t_branch): Treat (PLT) branches as wide.

gas/testsuite/
	* gas/arm/plt-1.s, gas/arm/plt-1.d: New test.
@
text
@d210 1
d23236 6
@


1.471
log
@2010-10-23  Mark Mitchell  <mark@@codesourcery.com>

	* config/obj-elf.c (elf_adjust_symtab): New.  Move group section
	processing here from elf_frob_file.  Ensure that group signature
	symbols have the name of the group.
	(elf_frob_file): Move group section processing to
	elf_adjust_symtab.
	* config/obj-elf.h (elf_adjust_symtab): Declare.
	(obj_adjust_symtab): Define.
	* config/tc-arm.c (arm_adjust_symtab): Call elf_adjust_symtab.

2010-10-23  Mark Mitchell  <mark@@codesourcery.com>

	* gas/elf/elf.exp: Add group0c test.
	* gas/elf/group0c.d: New.
	* gas/elf/group0a.d: Expect ".group" for the name of group
	sections.
	* gas/elf/group0b.d: Likewise.
	* gas/elf/group1a.d: Likewise.
	* gas/elf/group1b.d: Likewise.
	* gas/elf/groupautoa.d: Likewise.
	* gas/elf/groupautob.d: Likewise.
	* gas/elf/section4.d: Likewise.
	* gas/ia64/group-1.d: Likewise.  Adjust hard-coded constants.

2010-10-22  Mark Mitchell  <mark@@codesourcery.com>

	* binutils-all/group-5.d: Expect ".group" for the name of group
	sections.
	* binutils-all/strip-2.d: Likewise.

2010-10-23  Mark Mitchell  <mark@@codesourcery.com>

	* ld-elf/group10.d: Expect ".group" for the name of group
	sections.
	* ld-elf/group2.d: Likewise.
	* ld-elf/group7.d: Likewise.
@
text
@d2216 1
a2216 1
  char *namebuf, *nameend;
d9686 3
a9688 1
  if (unified_syntax && inst.size_req == 4)
@


1.471.2.1
log
@gas/
	* config/tc-arm.c (do_t_branch): Treat (PLT) branches as wide.

gas/testsuite/
	* gas/arm/plt-1.s, gas/arm/plt-1.d: New test.
@
text
@d2216 1
a2216 1
  char *namebuf, *nameend ATTRIBUTE_UNUSED;
d9686 1
a9686 3
  if (unified_syntax
      && (inst.size_req == 4
	  || (inst.size_req != 2 && inst.operands[0].hasreloc)))
@


1.471.2.2
log
@	PR gas/12198
	* gas/config/tc-arm.c (arm_arch_v6m_only): New variable.
	(aeabi_set_public_attributes): Ensure we only set the Operating System
	Extension when we are on an M-profile core.
	* gas/testsuite/gas/arm/pr12198-1.d: New test.
	* gas/testsuite/gas/arm/pr12918-1.s: Likewise.
	* gas/testsuite/gas/arm/pr12198-2.d: Likewise.
	* gas/testsuite/gas/arm/pr12918-2.s: Likewise.
	* include/opcode/arm.h (ARM_AEXT_V6M_ONLY): New define.
	(ARM_AEXT_V6M): Rewrite in terms of ARM_AEXT_V6M_ONLY.
	(ARM_ARCH_V6M_ONLY): New define.
@
text
@a209 1
static const arm_feature_set arm_arch_v6m_only = ARM_ARCH_V6M_ONLY;
a23234 6
  /* We need to make sure that the attributes do not identify us as v6S-M
     when the only v6S-M feature in use is the Operating System Extensions.  */
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_os))
      if (!ARM_CPU_HAS_FEATURE (flags, arm_arch_v6m_only))
        ARM_CLEAR_FEATURE (flags, flags, arm_ext_os);

@


1.471.2.3
log
@	Apply from mainline.
	2011-05-12  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	PR gas/12715
	* gas/config/tc-arm.c (parse_big_immediate):  Fix parsing of 64-bit
	immediates on 32-bit hosts.
	* gas/testsuite/gas/arm/neon-const.s: Add testcase for 64-bit Neon constants.
	* gas/testsuite/gas/arm/neon-const.d: Likewise.
@
text
@d4424 1
a4424 1
      if ((exp.X_add_number & ~(offsetT)(0xffffffffU)) != 0)
@


1.471.2.4
log
@	Backport from mainline.
	2011-04-18  Julian Brown  <julian@@codesourcery.com>
	            Nick Clifton  <nickc@@redhat.com>
	* gas/config/tc-arm.c (do_t_swi): Exclude v7 and higher variants from
	arm_ext_os test.
@
text
@d11612 1
a11612 3
      if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_os)
         /* This only applies to the v6m howver, not later architectures.  */
         && ! ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7))
@


1.470
log
@	bfd/
	* elf32-arm.c (elf32_arm_stub_long_branch_any_arm_pic,
	elf32_arm_stub_long_branch_any_arm_pic): Use a consistent name for
	ip/r12.
	(arm_type_of_stub): Remove superfluous braces.

	gas/
	* config/tc-arm.c (encode_branch): Remove superfluous braces.
	(do_t_branch): Move reloc setting to end of routine.
@
text
@d21960 2
@


1.469
log
@2010-09-27  Tejas Belagod  <tejas.belagod@@arm.com>

	* gas/config/tc-arm.c (do_neon_ldr_str): Deprecate ARM-mode PC-relative
	VSTR, issue an error in THUMB mode.
	* opcodes/arm_dis.c (print_insn_coprocessor): Apply off-by-alignment
	correction to unaligned PCs while printing comment.
	* gas/testsuite/gas/arm/vldr.s: New test for pc-relative VLDR disassembly comment.
	* gas/testsuite/gas/arm/vldr.d: Likewise.
	* gas/testsuite/gas/arm/vstr-bad.s: New test for PC-relative VSTR.
	* gas/testsuite/gas/arm/vstr-thumb-bad.l: Likewise.
	* gas/testsuite/gas/arm/vstr-thumb-bad.d: Likewise.
	* gas/testsuite/gas/arm/vstr-arm-bad.l: Likewise.
	* gas/testsuite/gas/arm/vstr-arm-bad.d: Likewise.
@
text
@d7288 1
a7288 3
    {
      inst.reloc.type = (bfd_reloc_code_real_type) default_reloc;
    }
d9667 1
d9690 1
a9690 1
	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH25;
d9695 1
a9695 1
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH20;
d9702 1
a9702 1
	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
d9706 1
a9706 1
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
d9712 1
a9712 1

@


1.468
log
@	* bfd/bfd-in2.h (BFD_RELOC_ARM_HVC): New enum value.
	* gas/config/tc-arm.c (arm_ext_virt): New variable.
	(arm_reg_type): Add REG_TYPE_RNB for banked registers.
	(reg_entry): Allow registers to be larger than a byte.
	(reg_alias): Fix type warning.
	(parse_operands): Parse banked registers when appropriate.
	(do_mrs): Add support for Virtualization Extensions.
	(do_hvc): New function.
	(do_t_mrs): Add support for Virtualization Extensions.
	(do_t_msr): Likewise.
	(do_t_hvc): New function.
	(SPLRBANK): New define.
	(reg_names): Add banked registers.
	(insns): Add support for Virtualization Extensions.
	(md_apply_fixup): Likewise.
	(arm_cpus): -mcpu=cortex-a15 implies the Virtualization Extensions.
	(arm_extensions): Add 'virt' extension.
	(aeabi_set_public_attributes): Add support for Virtualization
	Extensions.
	* gas/doc/c-arm.texi: Document 'virt' extension.
	* gas/testsuite/gas/arm/armv7-a+virt.d: New test.
	* gas/testsuite/gas/arm/armv7-a+virt.s: Likewise.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for Virtualization Extensions.
	* gas/testsuite/gas/arm/attr-march-armv7-a+sec+virt.d: New test.
	* gas/testsuite/gas/arm/attr-march-armv7-a+virt.d: Likewise.
	* include/opcode/arm.h (ARM_EXT_VIRT): New define.
	(ARM_ARCH_V7A_IDIV_MP_SEC): Rename...
	(ARM_ARCH_V7A_IDIV_MP_SEC_VIRT): ...to this and include Virtualization
	Extensions.
	* opcodes/arm-dis.c (arm_opcodes): Add Virtualiztion Extensions support.
	(thumb32_opcodes): Likewise.
	(banked_regname): New function.
	(print_insn_arm): Add Virtualization Extensions support.
	(print_insn_thumb32): Likewise.
@
text
@d14888 12
@


1.467
log
@	* gas/config/tc-arm.c (arm_ext_adiv): New variable.
	(do_div): New function.
	(insns): Accept UDIV and SDIV in ARM state.
	(arm_cpus): The cortex-a15 option has all current v7-A extensions.
	(arm_extensions): Add 'idiv' extension.
	(aeabi_set_public_attributes): Update Tag_DIV_use values for the
	Integer Divide extension.
	* gas/doc/c-arm.texi: Document the idiv extension.
	* gas/testsuite/gas/arm/armv7-a+idiv.d: New test.
	* gas/testsuite/gas/arm/armv7-a+idiv.s: Likewise.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for Integer divide extension.
	* gas/testsuite/gas/arm/attr-march-armv7-a+idiv.d: New test.
	* include/opcode/arm.h (ARM_AEXT_ADIV): New define.
	(ARM_ARCH_V7A_IDIV_MP_SEC): Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Support disassembly of UDIV and SDIV in
	ARM state.
@
text
@d204 1
d510 1
d520 1
a520 1
  unsigned char              number;
d2067 1
a2067 1
insert_reg_alias (char *str, int number, int type)
d6385 1
a6385 1
          po_reg_or_goto (REG_TYPE_VFC, try_psr);
d6388 9
d7865 2
a7869 4
  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
  constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
	      != (PSR_c|PSR_f),
	      _("'CPSR' or 'SPSR' expected"));
d7872 17
a7888 1
  inst.instruction |= (inst.operands[1].imm & SPSR_BIT);
d8150 7
a10768 1
  int flags;
d10773 5
a10777 2
  flags = inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f|SPSR_BIT);
  if (flags == 0)
d10779 7
a10785 3
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_m),
		  _("selected processor does not support "
		    "requested special purpose register"));
d10789 1
a10789 7
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1),
		  _("selected processor does not support "
		    "requested special purpose register"));
      /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
      constraint ((flags & ~SPSR_BIT) != (PSR_c|PSR_f),
		  _("'CPSR' or 'SPSR' expected"));
    }
d10791 15
a10805 2
  Rd = inst.operands[0].reg;
  reject_bad_reg (Rd);
d10807 4
a10810 3
  inst.instruction |= Rd << 8;
  inst.instruction |= (flags & SPSR_BIT) >> 2;
  inst.instruction |= inst.operands[1].imm & 0xff;
d10824 6
a10829 1
  flags = inst.operands[0].imm;
d10848 2
a10849 1
  inst.instruction |= (flags & ~SPSR_BIT) >> 8;
d11445 10
d16250 7
d16287 28
d16900 1
a16900 1
 TCE("mrs",	10f0000, f3ef8000, 2, (APSR_RR, RVC_PSR), mrs, t_mrs),
d17188 8
d20497 9
d22547 1
a22547 1
  {"cortex-a15",	ARM_ARCH_V7A_IDIV_MP_SEC,
d22646 2
d23203 1
d23334 5
a23338 1
    aeabi_set_attribute_int (Tag_Virtualization_use, 1);
@


1.466
log
@	* config/tc-arm.c (arm_ext_v6m): New variable.
	(arm_ext_m): Add support for OS extension.
	(arm_ext_os): New variable.
	(do_t_swi): In v6-M ensure we have the OS extension.
	(arm_cpus): The cortex-m1 and cortex-m0 options have the OS
	extension by default.
	(arm_archs): Add armv6s-m.
	(arm_extensions): Add 'os' extension.
	(cpu_arch_ver): Add support for v6S-M.
	* gas/doc/c-arm.texi: Document the OS Extension, and v6-m and v6s-m
	architecture options.
	* gas/testsuite/gas/arm/archv6s-m-bad.d: New test.
	* gas/testsuite/gas/arm/archv6s-m-bad.l: Likewise.
	* gas/testsuite/gas/arm/archv6s-m.d: Likewise.
	* gas/testsuite/gas/arm/archv6s-m.s: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6-m+os.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6s-m.d: Likewise.
	* include/opcode/arm.h (ARM_EXT_OS): New define.
	(ARM_AEXT_V6SM): Likewise.
	(ARM_ARCH_V6SM): Likewise.
@
text
@d203 1
d7496 19
d17153 3
a17155 1
 /* Thumb-2 hardware division instructions (R and M profiles only).  */
d17159 2
a17160 2
 TCE("sdiv",	0, fb90f0f0, 3, (RR, oRR, RR), 0, t_div),
 TCE("udiv",	0, fbb0f0f0, 3, (RR, oRR, RR), 0, t_div),
d22433 2
a22434 2
  {"cortex-a15",	ARM_ARCH_V7A_MP_SEC,
    					 FPU_ARCH_NEON_VFP_V4,
d22521 2
d23204 3
a23206 1
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_div))
a23207 3
  /* Fill this in when gas supports v7a sdiv/udiv.
    else if (... v7a with div extension used ...)
      aeabi_set_attribute_int (Tag_DIV_use, 2);  */
@


1.465
log
@	* gas/config/tc-arm.c (arm_ext_v6z): Remove.
	(arm_ext_sec): New variable.
	(do_t_smc): In Thumb state SMC requires v7-A.
	(insns): Make SMC depend on Security Extensions.
	(arm_cpus): All -mcpu=cortex-a* options have the Security Extensions.
	(arm_extensions): Add 'sec' extension.
	(cpu_arch_ver): Reorder.
	(aeabi_set_public_attributes): Emit Tag_Virtualization_use as
	appropriate.
	* gas/doc/c-arm.texi: Document Security Extensions.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for Security Extensions..
	* gas/testsuite/gas/arm/attr-march-armv6k+sec.d: New test.
	* gas/testsuite/gas/arm/attr-march-armv6z.d: Update for Security Extensions.
	* gas/testsuite/gas/arm/attr-march-armv6zk.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6zkt2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6zt2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv7-a+sec.d: New test.
	* gas/testsuite/gas/arm/attr-mcpu.d: Update for Security Extensions.
	* gas/testsuite/gas/arm/thumb32.d: Likewise.
	* gas/testsuite/gas/arm/thumb32.s: Likewise.
	* include/opcode/arm.h (ARM_EXT_V6Z): Remove.
	(ARM_EXT_SEC): New define.
	(ARM_AEXT_V6Z): Use Security Extensions.
	(ARM_AEXT_V6ZK): Likeiwse.
	(ARM_AEXT_V6ZT2): Likewise.
	(ARM_AEXT_V6ZKT2): Likewise.
	(ARM_AEXT_V7_ARM): Base v7 does not have Security Extensions.
	(ARM_ARCH_V7A_SEC): New define.
	(ARM_ARCH_V7A_MP): Rename...
	(ARM_ARCH_V7A_MP_SEC): ...to this and add Security Extensions.
	* ld/testsuite/ld-arm/attr-merge-6.attr: Update for Security Extensions.
	* ld/testsuite/ld-arm/attr-merge-7.attr: Likewise.
	* opcodes/arm-dis.c (arm_opcodes): SMC implies Security Extensions.
	(thumb32_opcodes): Likewise.
@
text
@d188 1
d199 1
a199 1
  ARM_FEATURE (ARM_EXT_V6M | ARM_EXT_V7M, 0);
d202 1
d11524 9
d22419 2
a22420 2
  {"cortex-m1",		ARM_ARCH_V6M,	 FPU_NONE,	  "Cortex-M1"},
  {"cortex-m0",		ARM_ARCH_V6M,	 FPU_NONE,	  "Cortex-M0"},
d22470 1
d22504 2
d23031 1
@


1.464
log
@	* gas/config/tc-arm.c (arm_ext_mp): Add.
	(do_pld): Update comment.
	(insns): Add support for pldw.
	(arm_cpus): Update cortex-a5, cortex-a9, and cortex-a15 to support
	MP extension.
	(arm_extensions): Add 'mp' extension.
	(aeabi_set_public_attributes): Emit correct build attribute when
	MP extension is enabled.
	* gas/doc/c-arm.texi: Update for MP extensions.
	* gas/testsuite/gas/arm/arch7a-mp.d: Add.
	* gas/testsuite/gas/arm/arch7ar-mp.s: Likewise.
	* gas/testsuite/gas/arm/arch7r-mp.d: Likewise.
	* gas/testsuite/gas/arm/armv2-mp-bad.d: Likewise.
	* gas/testsuite/gas/arm/armv2-mp-bad.l: Likewise.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for MP extension.
	* gas/testsuite/gas/arm/attr-march-armv7-a+mp.d: Add.
	* gas/testsuite/gas/arm/attr-march-armv7-r+mp.d: Likewise.
	* include/opcode/arm.h (ARM_EXT_MP): Add.
	(ARM_ARCH_V7A_MP): Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Add support for pldw.
	(thumb32_opcodes): Likewise.
@
text
@a186 1
static const arm_feature_set arm_ext_v6z = ARM_FEATURE (ARM_EXT_V6Z, 0);
d200 1
d11360 2
d17054 3
a17056 1
#define ARM_VARIANT  & arm_ext_v6z
d17062 2
d22390 4
a22393 2
  {"cortex-a5",		ARM_ARCH_V7A_MP, FPU_NONE,	  "Cortex-A5"},
  {"cortex-a8",		ARM_ARCH_V7A,	 ARM_FEATURE (0, FPU_VFP_V3
d22396 2
a22397 1
  {"cortex-a9",		ARM_ARCH_V7A_MP, ARM_FEATURE (0, FPU_VFP_V3
d22400 2
a22401 1
  {"cortex-a15",	ARM_ARCH_V7A_MP, FPU_ARCH_NEON_VFP_V4,
d22492 2
d23014 1
a23015 1
    {9, ARM_ARCH_V6K},
d23176 4
@


1.463
log
@	* gas/config/tc-arm.c (md_pseduo_table): Add .arch_extension directive.
	(arm_option_extension_value_table): Add.
	(arm_extensions): Change type.
	(arm_option_cpu_table): Rename...
	(arm_option_fpu_table): ...to this.
	(arm_fpus): Change type.
	(arm_parse_extension): Enforce alphabetical order.  Allow
	extensions to be removed.
	(arm_parse_arch): Allow extensions to be specified with -march.
	(s_arm_arch_extension): Add.
	(s_arm_fpu): Update for type changes.
	* gas/doc/c-arm.texi: Document changes to infrastructure.
@
text
@d200 1
d7959 1
d7961 1
a7961 1
    PLD <addr_mode>
d17142 7
d22384 1
a22384 1
  {"cortex-a5",		ARM_ARCH_V7A,	 FPU_NONE,	  "Cortex-A5"},
d22388 1
a22388 1
  {"cortex-a9",		ARM_ARCH_V7A,	 ARM_FEATURE (0, FPU_VFP_V3
d22391 1
a22391 1
  {"cortex-a15",	ARM_ARCH_V7A,	 FPU_ARCH_NEON_VFP_V4,
d22480 2
d22483 1
a22483 1
  {NULL,	ARM_ARCH_NONE,				ARM_ARCH_NONE}
d23160 4
@


1.462
log
@	* gas/config/tc-arm.c (arm_cpus): Correct canonical names for Cortex CPUs.
	* gas/testsuite/gas/arm/attr-cpu-directive.d: Update test for change in canonical
	CPU name.
	* gas/testsuite/gas/arm/attr-mcpu.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-6.attr: Update tests for change in canonical
	CPU name.
	* ld/testsuite/ld-arm/attr-merge-7.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-2.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-arch-2.attr: Likewise.
@
text
@d4273 1
d4327 1
d22456 2
a22457 2
/* ISA extensions in the co-processor space.  */
struct arm_option_cpu_value_table
d22461 1
d22464 13
a22476 1
static const struct arm_option_cpu_value_table arm_extensions[] =
d22478 2
a22479 5
  {"maverick",		ARM_FEATURE (0, ARM_CEXT_MAVERICK)},
  {"xscale",		ARM_FEATURE (0, ARM_CEXT_XSCALE)},
  {"iwmmxt",		ARM_FEATURE (0, ARM_CEXT_IWMMXT)},
  {"iwmmxt2",		ARM_FEATURE (0, ARM_CEXT_IWMMXT2)},
  {NULL,		ARM_ARCH_NONE}
d22484 1
a22484 1
static const struct arm_option_cpu_value_table arm_fpus[] =
d22562 9
a22576 1
      const struct arm_option_cpu_value_table * opt;
d22578 1
a22578 1
      int optlen;
d22594 27
d22627 7
a22633 2
      for (opt = arm_extensions; opt->name != NULL; opt++)
	if (strncmp (opt->name, str, optlen) == 0)
d22635 13
a22647 1
	    ARM_MERGE_FEATURE_SETS (*ext_set, *ext_set, opt->value);
d22653 13
a22665 1
	  as_bad (_("unknown architectural extension `%s'"), str);
d22668 6
d22744 1
a22744 1
    if (streq (opt->name, str))
d22763 1
a22763 1
  const struct arm_option_cpu_value_table * opt;
d23268 52
d23325 1
a23325 1
  const struct arm_option_cpu_value_table *opt;
@


1.461
log
@2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* config/tc-arm.c (do_t_ldmstm): Add logic to handle single-register
	list for ldm/stm.

2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* gas/arm/thumb2_ldmstm.d: Change single-register stmia to use 16-bit
	str encoding instead of str.w.  Likewise for ldmia.
	* gas/arm/thumb2_ldmstm.s: Change stmia comment.  Add tests for T1
	ldmia-to-ldr.
@
text
@d22367 2
a22368 2
  {"mpcore",		ARM_ARCH_V6K,	 FPU_ARCH_VFP_V2, NULL},
  {"mpcorenovfp",	ARM_ARCH_V6K,	 FPU_NONE,	  NULL},
d22373 1
a22373 1
  {"cortex-a5",		ARM_ARCH_V7A,	 FPU_NONE,	  NULL},
d22376 1
a22376 1
                                                          NULL},
d22379 1
a22379 1
                                                          NULL},
d22382 7
a22388 6
  {"cortex-r4",		ARM_ARCH_V7R,	 FPU_NONE,	  NULL},
  {"cortex-r4f",	ARM_ARCH_V7R,	 FPU_ARCH_VFP_V3D16,	  NULL},
  {"cortex-m4",		ARM_ARCH_V7EM,	 FPU_NONE,	  NULL},
  {"cortex-m3",		ARM_ARCH_V7M,	 FPU_NONE,	  NULL},
  {"cortex-m1",		ARM_ARCH_V6M,	 FPU_NONE,	  NULL},
  {"cortex-m0",		ARM_ARCH_V6M,	 FPU_NONE,	  NULL},
@


1.460
log
@2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* config/tc-arm.c (parse_psr): Add condition for matching "APSR" on
	non-M-arch cpus.
	(psrs): Add entry for PSR flags, g, nzcvq, nzcvqg.

2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* gas/arm/msr-reg.s: New file.
	* gas/arm/msr-reg.d: Likewise.
	* gas/arm/msr-imm.s: Likewise.
	* gas/arm/msr-imm.d: Likewise.
	* gas/arm/msr-imm-bad.d: Likewise.
	* gas/arm/msr-imm-bad.l: Likewise.
	* gas/arm/msr-reg-bad.d: Likewise.
	* gas/arm/msr-imm-bad.d: Likewise.
	* gas/arm/msr-reg-thumb.d: Likewise.
	* gas/arm/arch7.s: Add tests for xpsr.
	* gas/arm/arch7.d: Likewise.
@
text
@d9946 3
a9948 2
	  if (inst.operands[0].reg <= 7
	      && (inst.instruction == T_MNEM_stmia
d9951 38
a9988 12
		     == !(inst.operands[1].imm & mask))))
	    {
	      if (inst.instruction == T_MNEM_stmia
		  && (inst.operands[1].imm & mask)
		  && (inst.operands[1].imm & (mask - 1)))
		as_warn (_("value stored for r%d is UNKNOWN"),
			 inst.operands[0].reg);

	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg << 8;
	      inst.instruction |= inst.operands[1].imm;
	      narrow = TRUE;
d9990 1
a9990 2
	  else if (inst.operands[0] .reg == REG_SP
		   && inst.operands[0].writeback)
d9992 16
a10007 4
	      inst.instruction = THUMB_OP16 (inst.instruction == T_MNEM_stmia
					     ? T_MNEM_push : T_MNEM_pop);
	      inst.instruction |= inst.operands[1].imm;
	      narrow = TRUE;
@


1.459
log
@2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* config/tc-arm.c (insns): Change MRC entry to accept APSR_RR instead
	of just RR.

2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* gas/arm/copro.s: Add test for APSR_nzcv as a MRC operand.
	* gas/arm/copro.d: Change pc in MRC to disassemble as APSR_nzcv.  Also
	add disassembly for test added in copro.s

2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* arm_dis.c (coprocessor_opcodes): Add MRC entry for APSR_nzcv.
@
text
@d5324 3
a5326 1
  else if (strncasecmp (p, "CPSR", 4) == 0)
d16219 2
d16282 4
@


1.458
log
@	* gas/config/tc-arm.c (arm_cpus): Add cortex-a15 entry.
	* gas/doc/c-arm.texi: Document -mcpu=cortex-a15.
@
text
@d16707 1
a16707 1
 TCE("mrc",	e100010, ee100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
@


1.457
log
@        * config/tc-arm.c (md_apply_fix): Check if widened add, sub are
        flag-setting and handle accordingly.

        * gas/arm/addsw-bad.s: New file.
        * gas/arm/addsw-bad.l: New file.
        * gas/arm/addsw-bad.d: New file.
@
text
@d22334 2
@


1.456
log
@        PR gas/11972
        * config/tc-arm.c (parse_big_immediate): Allow for bignums being
        extended to the size of a .octa.
@
text
@d20255 2
a20256 3

	  /* 12 bit immediate for addw/subw.  */
	  if (value < 0)
d20258 10
a20267 2
	      value = -value;
	      newval ^= 0x00a00000;
a20268 4
	  if (value > 0xfff)
	    newimm = (unsigned int) FAIL;
	  else
	    newimm = value;
@


1.455
log
@	* config/tc-arm.c (create_neon_reg_alias): Deal with case
	sensitivity.
@
text
@d4423 1
a4423 2
           && LITTLENUM_NUMBER_OF_BITS * exp.X_add_number > 32
           && LITTLENUM_NUMBER_OF_BITS * exp.X_add_number <= 64)
d4426 1
d4431 18
@


1.454
log
@	* config/tc-arm.c (encode_arm_addr_mode_2): Fix comment.
@
text
@d2306 4
d2311 5
@


1.453
log
@	* config/tc-arm.c (encode_arm_addr_mode_2): Fix
	BAD_PC_ADDRESSING condition.

	testsuite/
	* gas/arm/ldst-pc.d: New test.
	* gas/arm/ldst-pc.s: New test.
	* gas/arm/sp-pc-validations-bad.s: `str r0,[pc,#4]' is valid.
	* gas/arm/sp-pc-validations-bad.l: Adjust accordingly.
@
text
@d6829 1
a6829 1
	  /* Use of PC in str is deprecated for ARMv7-A.  */
@


1.452
log
@2010-07-08 Tejas Belagod <tejas.belagod@@arm.com>

	gas/testsuite
	* gas/arm/barrier.s: New file.
	* gas/arm/barrier.d: New file.
	* gas/arm/barrier-thumb.s: New file.
	* gas/arm/barrier-thumb.d: New file.
	* gas/arm/barrier-bad.s: New file.
	* gas/arm/barrier-bad.d: New file.
	* gas/arm/barrier-bad.l: New file.
	* gas/arm/barrier-bad-thumb.s: New file.
	* gas/arm/barrier-bad-thumb.d: New file.
	* gas/arm/barrier-bad-thumb.l: New file.

	gas/config
	* tc-arm.c (OP_oBARRIER): Remove.
	(OP_oBARRIER_I15): Add.
	(po_barrier_or_imm): Add macro.
	(parse_operands): Improve OP_oBARRIER_I15 operand parsing.
	(do_barrier): Check correct immediate range.
	(do_t_barrier): Likewise.
	(barrier_opt_names): Add entries for more symbolic operands.
	(insns): Replace OP_oBARRIER with OP_oBARRIER_I15 for barriers.

	opcodes/
	* arm-dis.c (print_insn_arm): Add cases for printing more
	symbolic operands.
	(print_insn_thumb32): Likewise.
@
text
@d6822 5
a6826 4
	  /* BAD_PC_ADDRESSING Condition =
	       is_load => is_t
	     which becomes !is_load || is_t.  */
	  constraint ((!is_load || is_t),
d6828 6
@


1.451
log
@	* config/tc-arm.c (tc_gen_reloc): Add BFD_RELOC_ARM_T32_OFFSET_IMM
	error message.

	testsuite/
	* gas/arm/reloc-bad.d: New.
	* gas/arm/reloc-bad.s: New.
	* gas/arm/reloc-bad.l: New.
@
text
@d5901 1
a5901 1
  OP_oBARRIER,	 /* Option argument for a barrier instruction.  */
d6011 24
d6340 6
a6345 1
	case OP_oBARRIER:val = parse_barrier (&str);		break;
d6513 1
a6513 1
	case OP_oBARRIER:
d6578 1
d7157 2
a7158 1
		  && inst.operands[0].imm != 0xf,
d9465 2
a9466 1
		  && inst.operands[0].imm != 0xf,
d16318 12
a16329 4
  { "sy",   0xf },
  { "un",   0x7 },
  { "st",   0xe },
  { "unst", 0x6 }
d17045 3
a17047 3
 TUF("dmb",	57ff050, f3bf8f50, 1, (oBARRIER), barrier,  t_barrier),
 TUF("dsb",	57ff040, f3bf8f40, 1, (oBARRIER), barrier,  t_barrier),
 TUF("isb",	57ff060, f3bf8f60, 1, (oBARRIER), barrier,  t_barrier),
@


1.450
log
@	* gas/config/tc-arm.c (do_t_mov_cmp): Fix reporting of unpredictable and
	deprecated mov register instructions.
	* gas/testsuite/gas/arm/thumb2_bad_reg.s: Update mov register tests.
	* gas/testsuite/gas/arm/thumb2_bad_reg.l: Likewise.
@
text
@d21238 1
@


1.449
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d10276 18
a10293 3
	      else if ((Rn == REG_SP || Rn == REG_PC)
		       && (Rm == REG_SP || Rm == REG_PC))
		reject_bad_reg (Rm);
@


1.448
log
@	* gas/config/tc-arm.c (parse_neon_alignment): New function.
	(parse_address_main): Fix Neon load/store alignment parsing.
	* gas/testsuite/gas/arm/neon-ldst-align-bad.l: Update for Neon alignment syntax fix.
	* gas/testsuite/gas/arm/neon-ldst-align-bad.s: Likewise.
	* gas/testsuite/gas/arm/neon-ldst-es.d: Likewise.
	* gas/testsuite/gas/arm/neon-ldst-es.s: Likewise.
	* opcodes/arm-disc.c (parse_insn_neon):  Fix Neon alignment syntax.
@
text
@d945 2
a1885 1
  int addregs = 1;
a1909 1
              addregs = 2;
@


1.447
log
@	* gas/config/tc-arm.c (operand_parse_code): Add OP_RRnpctw enum
	value.
	(parse_operands): Add support for OP_RRnpctw.
	(insns): Update floating-point load/store multiples so the
	first register is of type OP_RRnpctw.
	* gas/testsuite/gas/arm/vldm-arm.d: New test.
	* gas/testsuite/gas/arm/vldm-thumb-bad.d: Likewise.
	* gas/testsuite/gas/arm/vldm-thumb-bad.l: Likewise.
	* gas/testsuite/gas/arm/vldm.s: Likewise.
	* gas/testsuite/gas/arm/vldmw-arm-bad.d: Likewise.
	* gas/testsuite/gas/arm/vldmw-bad.l: Likewise.
	* gas/testsuite/gad/arm-vldmw-bad.s: Likewise.
	* gas/testsuite/gas/arm/vldmw-thumb-bad.d: Likewise.
@
text
@d4951 27
d5061 9
a5069 16
        {
          /* FIXME: '@@' should be used here, but it's filtered out by generic
             code before we get to see it here. This may be subject to
             change.  */
          expressionS exp;
          my_get_expression (&exp, &p, GE_NO_PREFIX);
          if (exp.X_op != O_constant)
            {
              inst.error = _("alignment must be constant");
              return PARSE_OPERAND_FAIL;
            }
          inst.operands[i].imm = exp.X_add_number << 8;
          inst.operands[i].immisalign = 1;
          /* Alignments are not pre-indexes.  */
          inst.operands[i].preind = 0;
        }
d5133 9
@


1.446
log
@	* gas/config/tc-arm.c (do_t_mov_cmp): In unified syntax encode movs as
	lsls and not adds.
	* gas/testsuite/gas/arm/thumb2_it_auto.d: Update for change in movs encoding.
	gas/arm/thumb2_it.d: Likewise.
	gas/arm/thumb32.d: Likewise.
@
text
@d5762 2
d6133 1
d6442 7
d17439 16
a17454 16
 cCE("fldmias",	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
 cCE("fldmfds",	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
 cCE("fldmdbs",	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
 cCE("fldmeas",	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
 cCE("fldmiax",	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
 cCE("fldmfdx",	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
 cCE("fldmdbx",	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
 cCE("fldmeax",	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
 cCE("fstmias",	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
 cCE("fstmeas",	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
 cCE("fstmdbs",	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
 cCE("fstmfds",	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
 cCE("fstmiax",	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
 cCE("fstmeax",	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
 cCE("fstmdbx",	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
 cCE("fstmfdx",	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
d17482 8
a17489 8
 cCE("fldmiad",	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE("fldmfdd",	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE("fldmdbd",	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fldmead",	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fstmiad",	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE("fstmead",	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE("fstmdbd",	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fstmfdd",	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
d17569 6
a17574 6
 NCE(vldm,      c900b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vldmia,    c900b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vldmdb,    d100b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vstm,      c800b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vstmia,    c800b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vstmdb,    d000b00, 2, (RRw, VRSDLST), neon_ldm_stm),
@


1.445
log
@        * config/tc-arm.c (encode_thumb2_ldmstm): Make warning about
        writeback when base register is in register list an error, and
        correct check.
        (do_t_ldmstm): Change warnings.

        * gas/arm/thumb2_ldmstm.d: Add new testcases.
        * gas/arm/thumb2_ldmstm.s: Likeiwse.
        * gas/arm/thumb2_ldmstm_bad.d: Add testcases to check for
        UNPREDICTABLE ldm/stm.
        * gas/arm/thumb2_ldmstm_bad.l: Likewise.
        * gas/arm/thumb2_ldmstm_bad.s: Likewise.
@
text
@d10372 2
a10373 2
	       Generate ADD Rd, Rs, #0.  */
	    inst.instruction = T_OPCODE_ADD_I3;
@


1.444
log
@	* config/tc-arm.c (md_assemble): Clarify current mode in error
	messages about unsupported instructions.
	(UT): Delete #define.
	(insns): Adjust cbnz, cbz appropriately.
testsuite:
	* gas/arm/armv1-bad.l: Adjust expected error text.
	* gas/arm/arch7em-bad.l: Likewise.
	* gas/arm/arch7m-bad.l: Likewise.
	* gas/arm/thumb-w-bad.l: Likewise.
	* gas/arm/arm7-bad.d: New.
	* gas/arm/arm7-bad.l: New.
	* gas/arm/arm7-bad.s: New.
@
text
@d9763 6
a9777 5

      if ((mask & (1 << base)) != 0
	  && writeback)
	as_warn (_("base register should not be in register list "
		   "when written back"));
a9782 3

      if (mask & (1 << base))
	as_warn (_("value stored for r%d is UNPREDICTABLE"), base);
d9848 1
a9848 1
		as_warn (_("value stored for r%d is UNPREDICTABLE"),
d9888 1
a9888 1
	    as_warn (_("value stored for r%d is UNPREDICTABLE"),
@


1.443
log
@2010-05-10  Andrew Stubbs  <ams@@codesourcery.com>

        gas/
        * config/tc-arm.c (aeabi_set_public_attributes): Set Tag_DIV_use.

        gas/testsuite/
        * gas/arm/attr-cpu-directive.d: Add Tag_DIV_use.
        * gas/arm/attr-default.d: Likewise.
        * gas/arm/attr-march-armv1.d: Likewise.
        * gas/arm/attr-march-armv2.d: Likewise.
        * gas/arm/attr-march-armv2a.d: Likewise.
        * gas/arm/attr-march-armv2s.d: Likewise.
        * gas/arm/attr-march-armv3.d: Likewise.
        * gas/arm/attr-march-armv3m.d: Likewise.
        * gas/arm/attr-march-armv4.d: Likewise.
        * gas/arm/attr-march-armv4t.d: Likewise.
        * gas/arm/attr-march-armv4txm.d: Likewise.
        * gas/arm/attr-march-armv4xm.d: Likewise.
        * gas/arm/attr-march-armv5.d: Likewise.
        * gas/arm/attr-march-armv5t.d: Likewise.
        * gas/arm/attr-march-armv5te.d: Likewise.
        * gas/arm/attr-march-armv5tej.d: Likewise.
        * gas/arm/attr-march-armv5texp.d: Likewise.
        * gas/arm/attr-march-armv5txm.d: Likewise.
        * gas/arm/attr-march-armv6-m.d: Likewise.
        * gas/arm/attr-march-armv6.d: Likewise.
        * gas/arm/attr-march-armv6j.d: Likewise.
        * gas/arm/attr-march-armv6k.d: Likewise.
        * gas/arm/attr-march-armv6kt2.d: Likewise.
        * gas/arm/attr-march-armv6t2.d: Likewise.
        * gas/arm/attr-march-armv6z.d: Likewise.
        * gas/arm/attr-march-armv6zk.d: Likewise.
        * gas/arm/attr-march-armv6zkt2.d: Likewise.
        * gas/arm/attr-march-armv6zt2.d: Likewise.
        * gas/arm/attr-march-armv7-a.d: Likewise.
        * gas/arm/attr-march-armv7.d: Likewise.
        * gas/arm/attr-march-armv7a.d: Likewise.
        * gas/arm/attr-march-iwmmxt.d: Likewise.
        * gas/arm/attr-march-iwmmxt2.d: Likewise.
        * gas/arm/attr-march-marvell-f.d: Likewise.
        * gas/arm/attr-march-xscale.d: Likewise.
        * gas/arm/attr-mcpu.d: Likewise.
        * gas/arm/attr-mfpu-arm1020e.d: Likewise.
        * gas/arm/attr-mfpu-arm1020t.d: Likewise.
        * gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
        * gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
        * gas/arm/attr-mfpu-arm7500fe.d: Likewise.
        * gas/arm/attr-mfpu-fpa.d: Likewise.
        * gas/arm/attr-mfpu-fpa10.d: Likewise.
        * gas/arm/attr-mfpu-fpa11.d: Likewise.
        * gas/arm/attr-mfpu-fpe.d: Likewise.
        * gas/arm/attr-mfpu-fpe2.d: Likewise.
        * gas/arm/attr-mfpu-fpe3.d: Likewise.
        * gas/arm/attr-mfpu-maverick.d: Likewise.
        * gas/arm/attr-mfpu-neon-fp16.d: Likewise.
        * gas/arm/attr-mfpu-neon.d: Likewise.
        * gas/arm/attr-mfpu-softfpa.d: Likewise.
        * gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
        * gas/arm/attr-mfpu-softvfp.d: Likewise.
        * gas/arm/attr-mfpu-vfp.d: Likewise.
        * gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
        * gas/arm/attr-mfpu-vfp10.d: Likewise.
        * gas/arm/attr-mfpu-vfp3.d: Likewise.
        * gas/arm/attr-mfpu-vfp9.d: Likewise.
        * gas/arm/attr-mfpu-vfpv2.d: Likewise.
        * gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
        * gas/arm/attr-mfpu-vfpv3.d: Likewise.
        * gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
        * gas/arm/attr-mfpu-vfpv4.d: Likewise.
        * gas/arm/attr-mfpu-vfpxd.d: Likewise.
        * gas/arm/attr-order.d: Likewise.
        * gas/arm/attr-override-cpu-directive.d: Likewise.
        * gas/arm/attr-override-mcpu.d: Likewise.
        * gas/arm/eabi_attr_1.d: Likewise.

        ld/testsuite/
        * ld-arm/attr-merge-2.attr: Add Tag_DIV_use.
        * ld-arm/attr-merge-2a.s: Likewise.
        * ld-arm/attr-merge-2b.s: Likewise.
        * ld-arm/attr-merge-3a.s: Likewise.
        * ld-arm/attr-merge-3b.s: Likewise.
        * ld-arm/attr-merge-4.attr: Likewise.
        * ld-arm/attr-merge-5.attr: Likewise.
        * ld-arm/attr-merge-6.attr: Likewise.
        * ld-arm/attr-merge-7.attr: Likewise.
        * ld-arm/attr-merge-arch-1.attr: Likewise.
        * ld-arm/attr-merge-arch-2.attr: Likewise.
        * ld-arm/attr-merge-unknown-2.d: Likewise.
        * ld-arm/attr-merge-unknown-2r.d: Likewise.
        * ld-arm/attr-merge-unknown-3.d: Likewise.
        * ld-arm/attr-merge-vfp-1.d: Likewise.
        * ld-arm/attr-merge-vfp-1r.d: Likewise.
        * ld-arm/attr-merge-vfp-2.d: Likewise.
        * ld-arm/attr-merge-vfp-2r.d: Likewise.
        * ld-arm/attr-merge-vfp-3.d: Likewise.
        * ld-arm/attr-merge-vfp-3r.d: Likewise.
        * ld-arm/attr-merge-vfp-4.d: Likewise.
        * ld-arm/attr-merge-vfp-4r.d: Likewise.
        * ld-arm/attr-merge-vfp-5.d: Likewise.
        * ld-arm/attr-merge-vfp-5r.d: Likewise.
        * ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-00.d: Likewise.
        * ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-02.d: Likewise.
        * ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-04.d: Likewise.
        * ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-20.d: Likewise.
        * ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-22.d: Likewise.
        * ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-40.d: Likewise.
        * ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-44.d: Likewise.
        * ld-arm/attr-merge.attr: Likewise.

2010-04-07  Jie Zhang  <jie@@codesourcery.com>

        gas/
        * config/tc-arm.c (aeabi_set_public_attributes): Set
        Tag_ABI_HardFP_use to 1 if a single precision FPU is selected.

        gas/testsuite/
        * gas/arm/attr-mfpu-vfpxd.d: New test.

        bfd/
        * elf32-arm.c (elf32_arm_merge_eabi_attributes): Merge
        Tag_ABI_HardFP_use correctly.

        ld/testsuite/
        * ld-arm/attr-merge-vfp-6.d: New test.
        * ld-arm/attr-merge-vfp-6r.d: New test.
        * ld-arm/attr-merge-vfpv3xd.s: New test.
        * ld-arm/arm-elf.exp: Add attr-merge-vfp-6 and attr-merge-vfp-6r.

2010-05-11  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>

        * arm-dis.c (thumb_opcodes): Update ldmia entry to use new %W
        format.
        (print_insn_thumb16): Add support for new %W format.

        * gas/arm/thumb32.d: Fix expected disassembly of ldmia
          instruction.
@
text
@d15722 1
a15722 1
	  as_bad (_("selected processor does not support `%s'"), str);
d15747 1
a15747 1
		  as_bad (_("selected processor does not support `%s'"), str);
d15813 1
a15813 1
	  as_bad (_("selected processor does not support `%s'"), str);
a16441 3
/* Thumb-only, unconditional.  */
#define UT(mnem,  op, nops, ops, te) TUE (mnem,  0, op, nops, ops, 0, te)

d16898 5
a16902 2
  UT("cbnz",      b900,    2, (RR, EXP), t_cbz),
  UT("cbz",       b100,    2, (RR, EXP), t_cbz),
@


1.442
log
@        * write.c (fixup_segment): Do not assume we know the section a
        defined weak symbol is in.
        * config/tc-arm.c (relax_adr, relax_branch, md_apply_fix): Treat
        weak symbols as not known to be in the same section, even if they
        are defined.

        * gas/arm/weakdef-1.s: New.
        * gas/arm/weakdef-1.d: New.
        * gas/arm/weakdef-2.s: New.
        * gas/arm/weakdef-2.d: New.
        * gas/arm/weakdef-2.l: New.
@
text
@d22859 5
d22879 9
@


1.441
log
@	* ld/testsuite/ld-arm/attr-merge-2.attr: Update for changes in attribute output.
	* ld/testsuite/ld-arm/attr-merge-3.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-1.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-1r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-2.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-2r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-3.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4.d: Likeiwse.
	* ld/testsuite/ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-00.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-02.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-04.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-20.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-22.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-40.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-44.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge.attr: Likewise.
	* binutils/readelf.c (arm_attr_tag_FP_arch): Rename from arm_attr_tag_VFP_arch.
	(arm_attr_tag_ABI_align8_needed): Remove.
	(arm_attr_tag_ABI_align8_preserved): Remove.
	(arm_attr_tag_ABI_HardFP_use): Update text strings.
	(arm_attr_public_tags): Add strings for ABI v2.08 attribute tags.
	(display_arm_attribute): Add decoding of ABI v2.08 attributes.
	* include/elf/arm.h (Tag_FP_arch, Tag_ABI_align_needed, Tag_ABI_align_preserved,
	Tag_FP_HP_extension): Add new ABI attribute tags.
	* gas/config/tc-arm.c (arm_convert_symbolic_attribute): Add support for
	new tag names in v2.08 of ARM ABI.
	* gas/doc/c-arm.texi: Document new tag names in ABI.
	* gas/testsuite/gas/arm/attr-mcpu.d: Update for new attribute tag names.
	* gas/testsuite/gas/arm/attr-mfpu-arm1020e.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1020t.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-neon-fp16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-neon.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp10.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp9.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv2.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpxd.d: Likewise.
	* gas/testsuite/gas/arm/attr-names.d: Add test to make sure all attribute names
	are recognised.
	* gas/testsuite/gas/arm/attr-names.s: Likewise.
@
text
@d18533 2
a18534 1
      || sec != S_GET_SEGMENT (fragp->fr_symbol))
d18577 2
a18578 1
      || sec != S_GET_SEGMENT (fragp->fr_symbol))
d19789 1
a19789 2
      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
d19791 8
a19798 5
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
	}
d19800 6
a19805 7
      if (fixP->fx_addsy
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("symbol %s is in a different section"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
d19831 1
a19831 2
	if (fixP->fx_addsy
	    && ! S_IS_DEFINED (fixP->fx_addsy))
d19833 8
a19840 5
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("undefined symbol %s used as an immediate value"),
			  S_GET_NAME (fixP->fx_addsy));
	    break;
	  }
d19842 6
a19847 7
	if (fixP->fx_addsy
	    && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	  {
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("symbol %s is in a different section"),
			  S_GET_NAME (fixP->fx_addsy));
	    break;
d19849 1
a19849 1

@


1.440
log
@	* config/tc-arm.c (make_mapping_symbol): Handle the case
	that multiple mapping symbols have the same value 0.

	testsuite/
	* gas/arm/mapmisc.s: Test multiple mapping symbols have
	the same value 0.
@
text
@d23050 1
d23065 1
d23067 1
d23077 1
@


1.439
log
@	* config/tc-arm.c (make_mapping_symbol): Hanle the case
	that two mapping symbols have the same value.

	testsuite/
	* gas/arm/mapmisc.s: Add the test case for two mapping
	symbols having the same value.
	* gas/arm/mapmisc.d: Likewise.
@
text
@d2496 6
a2501 1
     check_mapping_symbols.  */
d2504 5
a2508 1
      know (frag->tc_frag_data.first_map == NULL);
a2513 4
      /* If .fill or other data filling directive generates zero sized data,
	 the mapping symbol for the following code will have the same value
	 as the one generated for the data filling directive.  In this case,
	 we replace the old symbol with the new one at the same address.  */
@


1.438
log
@bfd/
2010-03-15  Wei Guozhi  <carrot@@google.com>

       PR gas/11323
       * bfd-in2.h (enum bfd_reloc_code_real): New BFD_RELOC_GOT_PREL type.
       * elf32-arm.c (elf32_arm_reloc_map): BFD_RELOC_GOT_PREL to
       R_ARM_GOT_PREL map.
       * libbfd.h (bfd_reloc_code_real_names): BFD_RELOC_GOT_PREL name.
       * reloc.c (comments): Document the new relocation.

gas/
2010-03-15  Wei Guozhi  <carrot@@google.com>

       PR gas/11323
       * config/tc-arm.c (reloc_names): New relocation names.
       (md_apply_fix): New case for BFD_RELOC_ARM_GOT_PREL.
       (tc_gen_reloc): New case for BFD_RELOC_ARM_GOT_PREL.
       * doc/c-arm.texi (ARM-Relocations): Document the new relocation.

gas/testsuite
2010-03-15  Wei Guozhi  <carrot@@google.com>

       PR gas/11323
       * gas/arm/got_prel.s: New test case.
       * gas/arm/got_prel.d: Likewise.
@
text
@d2503 9
a2511 1
    know (S_GET_VALUE (frag->tc_frag_data.last_map) < S_GET_VALUE (symbolP));
@


1.437
log
@2010-03-05  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_cpu_option_table): Add cortex-m4.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009
d16194 2
a16195 1
  { "tpoff",   BFD_RELOC_ARM_TLS_LE32},  { "TPOFF",   BFD_RELOC_ARM_TLS_LE32}
d20481 6
a20486 1
      
d21071 1
@


1.436
log
@	* config/tc-arm.c (do_t_strexd): Remove
	operand[1] != operand[2] contraint.

	testsuite/
	* gas/arm/thumb32.s, gas/arm/thumb32.d: Add a new test
	for strexd.
	* gas/arm/thumb32.l: Adjust.
@
text
@d22182 1
@


1.435
log
@	* config/tc-arm.c (neon_select_shape): No need to match
	the remaining operands in the shape when one operand does
	not match.
@
text
@d11278 1
a11278 2
	      || inst.operands[0].reg == inst.operands[3].reg
	      || inst.operands[1].reg == inst.operands[2].reg,
@


1.434
log
@2010-02-26  Jie Zhang  <jie@@codesourcery.com>

	* config/tc-arm.c (do_neon_ld_st_interleave): Reject bad
	alignment.

	testsuite/
	* gas/arm/neon-ldst-align-bad.d: New test.
	* gas/arm/neon-ldst-align-bad.l: New test.
	* gas/arm/neon-ldst-align-bad.s: New test.
@
text
@d11793 2
@


1.433
log
@    gas/
    * config/tc-arm.c (do_rd_rm_rn): Added warning.

    gas/testsuite/
    * gas/arm/depr-swp.d: New test case.
    * gas/arm/depr-swp.s: New file.
    * gas/arm/depr-swp.l: New file.
@
text
@d14665 2
a14666 1
        if (NEON_REGLIST_LENGTH (inst.operands[0].imm) == 3)
d14671 1
a14671 1
        if (NEON_REGLIST_LENGTH (inst.operands[0].imm) == 3)
@


1.432
log
@	PR 9861
	* gas/config/tc-arm.c (CPU_DEFAULT): Do not define based upon build
	compiler's predefines.
@
text
@d6973 10
a6982 2
    constraint (Rn == inst.operands[0].reg || Rn == inst.operands[1].reg,
		_("Rn must not overlap other operands"));
@


1.431
log
@	* bfd/elf32-arm.c (elf32_arm_merge_eabi_attributes): Add support for
	merging Tag_DIV_use, Tag_MPextension_use, and
	Tag_MPextension_use_legacy tags.
	* binutils/readelf.c (arm_attr_tag_Advanced_SIMD_arch): Add
	description of newly permitted attribute values.
	(arm_attr_tag_Virtualization_use): Likewise.
	(arm_attr_tag_DIV_use): Add description of new attribute.
	(arm_attr_tag_MPextension_use_legacy): Likewise.
	* gas/config/tc-arm.c (arm_convert_symbolic_attribute):
	Add Tag_DIV_use.
	* gas/doc/c-arm.texi: Likewise.
	* gas/testsuite/gas/arm/attr-order.d: Fix test for new names for
	attribute values.
	* include/elf/arm.h (Tag_MPextension_use): Renumber.
	(Tag_DIV_use): Add.
	(Tag_MPextension_use_legacy): Likewise.
	* ld/testsuite/ld-arm/attr-merge-3.attr: Fix test for new attribute
	values.
	* ld/testsuite/ld-arm/attr-merge-3b.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-unknown-1.d: Fix test now that 42
	is a recognised attribute ID.
	* ld/testsuite/ld-arm/attr-merge-unknown-1.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-6.attr: New test.
	* ld/testsuite/ld-arm/attr-merge-6a.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-6b.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7a.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7b.s: Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp: Run the new tests.
@
text
@d100 6
a105 7
#if defined __XSCALE__
#define CPU_DEFAULT	ARM_ARCH_XSCALE
#else
#if defined __thumb__
#define CPU_DEFAULT	ARM_ARCH_V5T
#endif
#endif
@


1.430
log
@	gas/
	* config/tc-arm.c (asm_opcode): operands type
	change.
	(BAD_PC_ADDRESSING): New macro message.
	(BAD_PC_WRITEBACK): Likewise.
	(MIX_ARM_THUMB_OPERANDS): New macro.
	(operand_parse_code): Added enum values.
	(parse_operands): Added thumb/arm distinction,
	plus new enum values handling.
	(encode_arm_addr_mode_2): Validations enhanced.
	(encode_arm_addr_mode_3): Likewise.
	(do_rm_rd_rn): Likewise.
	(encode_thumb32_addr_mode): Likewise.
	(do_t_ldrex): Likewise.
	(do_t_ldst): Likewise.
	(do_t_strex): Likewise.
	(md_assemble): Call parse_operands with
	a new parameter.
	(OPS_1): New macro.
	(OPS_2): Likewise.
	(OPS_3): Likewise.
	(OPS_4): Likewise.
	(OPS_5): Likewise.
	(OPS_6): Likewise.
	(insns): Updated insns operands.

	gas/testsuite/
	* gas/arm/sp-pc-validations-bad.d: New testcase.
	* gas/arm/sp-pc-validations-bad.l: New file.
	* gas/arm/sp-pc-validations-bad.s: New file.
	* gas/arm/sp-pc-validations-bad-t.d: New testcase.
	* gas/arm/sp-pc-validations-bad-t.l: New file.
	* gas/arm/sp-pc-validations-bad-t.s: New file.
	* gas/arm/sp-pc-usage-t.d: Removed invalid insns.
	* gas/arm/sp-pc-usage-t.s: Likewise.
	* gas/arm/unpredictable.d: Likewise.
	* gas/arm/unpredictable.s: Likewise.
	* gas/arm/thumb2_bcond.d: Added test.
	* gas/arm/thumb2_bcond.s: Likewise.
@
text
@d23046 2
d23053 1
a23053 1
      T (Tag_MPextension_use)
@


1.429
log
@2010-02-08  Christophe Lyon  <christophe.lyon@@st.com>

	gas/
	* config/tc-arm.c (md_pcrel_from_section): Keep base to zero for
	non-local branches (BFD_RELOC_THUMB_PCREL_BRANCH23,
	BFD_RELOC_THUMB_PCREL_BLX, BFD_RELOC_ARM_PCREL_BLX,
	BFD_RELOC_ARM_PCREL_CALL)

	gas/testsuite/
	* gas/arm/branch-reloc.s, gas/arm/branch-reloc.d,
	gas/arm/branch-reloc.l: New tests and expected results with all
	variants of call: ARM/Thumb, local/global, inter/intra-section,
	using BL/BLX.
@
text
@d562 1
a562 1
  unsigned char operands[8];
d708 4
d5736 5
d5748 1
d5848 1
d5860 5
d5873 1
a5873 1
parse_operands (char *str, const unsigned char *pattern)
d5875 1
a5875 1
  unsigned const char *upat = pattern;
d5881 1
d5972 6
a5977 1
      if (upat[i] >= OP_FIRST_OPTIONAL)
d5989 1
a5989 1
      switch (upat[i])
d5993 1
d5995 1
d6398 1
a6398 1
	  as_fatal (_("unhandled operand code %d"), upat[i]);
d6404 1
a6404 1
      switch (upat[i])
d6416 11
d6712 2
d6718 3
d6738 10
d6771 3
d6780 3
d6992 5
d7487 2
d8738 2
a8739 1
   that cannot be used with a D instruction.  */
d8744 1
a8744 1
  bfd_boolean is_pc = (inst.operands[i].reg == REG_PC);
d8752 1
a8752 1
      constraint (is_pc, _("cannot use register index with PC-relative addressing"));
d8777 1
a8777 2
      constraint (is_pc && inst.operands[i].writeback,
		  _("cannot use writeback with PC-relative addressing"));
d8780 2
d9898 2
d9959 2
d10000 6
d11255 2
d15733 1
a15733 1
      if (!parse_operands (p, opcode->operands))
d15806 1
a15806 1
      if (!parse_operands (p, opcode->operands))
d16230 12
d16462 5
a16466 3
 tC3("ldrb",	4500000, _ldrb,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tCE("str",	4000000, _str,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tC3("strb",	4400000, _strb,	   2, (RR, ADDRGLDR),ldst, t_ldst),
d16516 4
a16519 4
 TC3("ldrt",	4300000, f8500e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3("ldrbt",	4700000, f8100e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3("strt",	4200000, f8400e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3("strbt",	4600000, f8000e00, 2, (RR, ADDR),    ldstt, t_ldstt),
d16596 6
a16601 6
 tC3("ldrh",	01000b0, _ldrh,     2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3("strh",	00000b0, _strh,     2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3("ldrsh",	01000f0, _ldrsh,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3("ldrsb",	01000d0, _ldrsb,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tCM("ld","sh",	01000f0, _ldrsh,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tCM("ld","sb",	01000d0, _ldrsb,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
d16670 4
a16673 2
 TC3("ldrd",	00000d0, e8500000, 3, (RRnpc, oRRnpc, ADDRGLDRS), ldrd, t_ldstd),
 TC3("strd",	00000f0, e8400000, 3, (RRnpc, oRRnpc, ADDRGLDRS), ldrd, t_ldstd),
d16702 3
a16704 2
 TCE("ldrex",	1900f9f, e8500f00, 2, (RRnpc, ADDR),		  ldrex, t_ldrex),
 TCE("strex",	1800f90, e8400000, 3, (RRnpc, RRnpc, ADDR),	   strex,  t_strex),
d16838 4
a16841 3

 TCE("ldrexd",	1b00f9f, e8d0007f, 3, (RRnpc, oRRnpc, RRnpcb),        ldrexd, t_ldrexd),
 TCE("strexd",	1a00f90, e8c00070, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb), strexd, t_strexd),
d16845 8
a16852 5

 TCE("ldrexb",	1d00f9f, e8d00f4f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE("ldrexh",	1f00f9f, e8d00f5f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE("strexb",	1c00f90, e8c00f40, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TCE("strexh",	1e00f90, e8c00f50, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
d16873 4
a16876 4
 TC3("ldrht",	03000b0, f8300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3("ldrsht",	03000f0, f9300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3("ldrsbt",	03000d0, f9100e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3("strht",	02000b0, f8200e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
@


1.428
log
@        PR 11136
        * config/tc-arm.c (neon_check_type): Handle a neon_shape value of
        NS_NULL.
        * gas/arm/neon-omit.s: Add instruction that causes crash.
        * gas/arm/neon-omit.d: Add expected disassembly.
@
text
@d19243 3
a19245 1
       if (fixP->fx_addsy
d19253 4
a19256 2
     case BFD_RELOC_THUMB_PCREL_BLX:
       if (fixP->fx_addsy
d19265 3
a19267 1
       if (fixP->fx_addsy
d19271 1
a19271 1
       return base + 8;
d19273 4
a19276 2
      case BFD_RELOC_ARM_PCREL_CALL:
       if (fixP->fx_addsy
d19280 1
a19280 1
       return base + 8;
@


1.427
log
@	gas/
	* config/tc-arm.c (do_t_nop): Correct check for Thumb-2 NOP.

	gas/testsuite/
	* gas/arm/thumb-nop.d, gas/arm/thumb-nop.s: New test.
	* gas/arm/relax_branch_align.d: Expect a default NOP instruction.
	* gas/arm/vfp1_t2.d, gas/arm/vfp1xD_t2.d: Specify a CPU with
	Thumb-2.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Assemble Cortex-A8 tests with
	-mcpu=cortex-a8.
@
text
@d12046 11
a12056 2
                  enum neon_shape_el regshape = neon_shape_tab[ns].el[i];
                  unsigned regwidth = neon_shape_el_size[regshape], match;
a12204 2
  else
    inst.error = NULL;
d12206 1
@


1.426
log
@    * arm-dis.c (print_insn): Fixed search for next
    symbol and data dumping condition, and the
    initial mapping symbol state.

    * gas/arm/dis-data.d: New test case.
    * gas/arm/dis-data.s: New file.
@
text
@d10626 1
a10626 1
	  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2))
@


1.425
log
@2010-01-04  Daniel Gutson  <dgutson@@codesourcery.com>

        gas/
        * config/tc-arm.c (do_neon_logic): Accept imm value
        in the third operand too.
        (operand_parse_code): OP_RNDQ_IMVNb renamed to
        OP_RNDQ_Ibig.
        (parse_operands): OP_NILO case removed, applied renaming.
        (insns): Neon shape changed for some logic instructions.

        gas/testsuite/
        * gas/arm/neon-logic.d: New test case.
        * gas/arm/neon-logic.s: New file.
@
text
@d13669 1
a13669 1
do_neon_cvt (void)
d13675 10
d13785 12
d17441 2
a17442 1
 nCEF(vcvt,     _vcvt,    3, (RNSDQ, RNSDQ, oI32b), neon_cvt),
@


1.424
log
@2010-01-04  Daniel Gutson  <dgutson@@codesourcery.com>
    gas/
    * config/tc-arm.c (do_neon_ldx_stx): Added
    validation for vector load/store insns.

    gas/testsuite/
    * gas/arm/neon-addressing-bad.d: New test case.
    * gas/arm/neon-addressing-bad.s: New file.
    * gas/arm/neon-addressing-bad.l: New file.
@
text
@a5770 1
  OP_NILO,      /* Neon immediate/logic operands 2 or 2+3. (VBIC, VORR...)  */
d5778 1
a5778 1
  OP_RNDQ_IMVNb,/* Neon D or Q reg, or immediate good for VMVN.  */
a6009 30
        /* WARNING: We can expand to two operands here. This has the potential
           to totally confuse the backtracking mechanism! It will be OK at
           least as long as we don't try to use optional args as well,
           though.  */
        case OP_NILO:
          {
            po_reg_or_goto (REG_TYPE_NDQ, try_imm);
	    inst.operands[i].present = 1;
            i++;
            skip_past_comma (&str);
            po_reg_or_goto (REG_TYPE_NDQ, one_reg_only);
            break;
            one_reg_only:
            /* Optional register operand was omitted. Unfortunately, it's in
               operands[i-1] and we need it to be in inst.operands[i]. Fix that
               here (this is a bit grotty).  */
            inst.operands[i] = inst.operands[i-1];
            inst.operands[i-1].present = 0;
            break;
            try_imm:
	    /* There's a possibility of getting a 64-bit immediate here, so
	       we need special handling.  */
	    if (parse_big_immediate (&str, i) == FAIL)
	      {
		inst.error = _("immediate value is out of range");
		goto failure;
	      }
          }
          break;

d6065 1
a6065 1
        case OP_RNDQ_IMVNb:
d6067 1
a6067 1
            po_reg_or_goto (REG_TYPE_NDQ, try_mvnimm);
d6069 1
a6069 1
            try_mvnimm:
d12882 6
a12887 1
      enum neon_shape rs = neon_select_shape (NS_DI, NS_QI, NS_NULL);
d12897 4
d12903 1
a12903 1
      immbits = inst.operands[1].imm;
d12908 2
a12909 2
	  if (immbits != (inst.operands[1].regisimm ?
			  inst.operands[1].reg : 0))
d17460 10
a17469 10
 nUF(vand,      _vand,    2, (RNDQ, NILO),        neon_logic),
 nUF(vandq,     _vand,    2, (RNQ,  NILO),        neon_logic),
 nUF(vbic,      _vbic,    2, (RNDQ, NILO),        neon_logic),
 nUF(vbicq,     _vbic,    2, (RNQ,  NILO),        neon_logic),
 nUF(vorr,      _vorr,    2, (RNDQ, NILO),        neon_logic),
 nUF(vorrq,     _vorr,    2, (RNQ,  NILO),        neon_logic),
 nUF(vorn,      _vorn,    2, (RNDQ, NILO),        neon_logic),
 nUF(vornq,     _vorn,    2, (RNQ,  NILO),        neon_logic),
 nUF(veor,      _veor,    3, (RNDQ, oRNDQ, RNDQ), neon_logic),
 nUF(veorq,     _veor,    3, (RNQ,  oRNQ,  RNQ),  neon_logic),
d17568 2
a17569 2
 nUF(vmvn,      _vmvn,    2, (RNDQ, RNDQ_IMVNb), neon_mvn),
 nUF(vmvnq,     _vmvn,    2, (RNQ,  RNDQ_IMVNb), neon_mvn),
@


1.423
log
@2010-01-03  Daniel Gutson  <dgutson@@codesourcery.com>

    gas/
    * config/tc-arm.c (struct arm_it): New flag 'is_neon'.
    (NEON_ENC_*): Macros renamed to _NEON_ENC_*.
    (NEON_ENCODE): New macro.
    (check_neon_suffixes): New macro.
    (do_vfp_cond_or_thumb): Set the 'is_neon' flag.
    (do_vfp_nsyn_opcode): Likewise.
    (do_vfp_nsyn_nmul): Use the new 'NEON_ENCODE' macro.
    (do_vfp_nsyn_cmp): Likewise.
    (do_neon_shl_imm): Likewise.
    (do_neon_qshl_imm): Likewise.
    (neon_dyadic_misc): Likewise.
    (do_neon_mac_maybe_scalar): Likewise.
    (do_neon_qdmulh): Likewise.
    (do_neon_qmovn): Likewise.
    (do_neon_qmovun): Likewise.
    (do_neon_movn): Likewise.
    (neon_mac_reg_scalar_long): Likewise.
    (do_neon_vmull): Likewise.
    (do_neon_trn): Likewise.
    (do_neon_ldx_stx): Likewise.
    (neon_dp_fixup): Changed signature and set the flag.
    (neon_three_same): Call the above with new signature.
    (neon_two_same): Likewise.
    (neon_imm_shift): Likewise.
    (neon_mul_mac): Likewise.
    (do_neon_abs_neg): Likewise.
    (neon_mixed_length): Likewise.
    (do_neon_ext): Likewise.
    (do_neon_mov): Likewise.
    (do_neon_tbl_tbx): Likewise.
    (do_neon_logic): Likewise, and use the new 'NEON_ENCODE' macro.
    (neon_compare): Likewise.
    (do_neon_shll): Likewise.
    (do_neon_cvt): Likewise.
    (do_neon_mvn): Likewise.
    (do_neon_dup): Likewise.
    (md_assemble): Call check_neon_suffixes ().

    gas/testsuite/
    * gas/arm/neon-suffix-bad.d: New test case.
    * gas/arm/neon-suffix-bad.s: New file.
    * gas/arm/neon-suffix-bad.l: New file.
@
text
@d14813 3
@


1.422
log
@Fix Thumb2 bl range options.

2009-12-21  Ramana Radhakrishnan  <ramana.radhakrishnan@@arm.com>
            Richard Earnshaw  <richard.earnshaw@@arm.com>

        * config/tc-arm.c (encode_thumb2_b_bl_offset): New. Refactored
        from md_apply_fix.
        (md_apply_fix): Fixup range checks for Thumb2 version
        of unconditional calls. Call encode_thumb2_b_bl_offset for
        unconditional branches / function calls.
@
text
@d352 3
d11431 11
a11441 10
#define NEON_ENC_INTEGER(X) (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_ARMREG(X)  (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_POLY(X)    (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_FLOAT(X)   (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_SCALAR(X)  (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
#define NEON_ENC_IMMED(X)   (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
#define NEON_ENC_INTERLV(X) (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_LANE(X)    (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_DUP(X)     (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
#define NEON_ENC_SINGLE(X) \
d11443 1
a11443 1
#define NEON_ENC_DOUBLE(X) \
d11446 19
d12130 2
d12160 2
d12363 1
a12363 1
      inst.instruction = NEON_ENC_SINGLE (inst.instruction);
d12368 1
a12368 1
      inst.instruction = NEON_ENC_DOUBLE (inst.instruction);
d12384 1
a12384 1
          inst.instruction = NEON_ENC_SINGLE (inst.instruction);
d12389 1
a12389 1
          inst.instruction = NEON_ENC_DOUBLE (inst.instruction);
d12412 1
a12412 1
          inst.instruction = NEON_ENC_SINGLE (inst.instruction);
d12417 1
a12417 1
          inst.instruction = NEON_ENC_DOUBLE (inst.instruction);
d12458 2
a12459 2
static unsigned
neon_dp_fixup (unsigned i)
d12461 3
d12477 1
a12477 1
  return i;
d12514 1
a12514 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d12537 1
a12537 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d12576 1
a12576 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d12586 1
a12586 1
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
d12606 1
a12606 1
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d12619 1
a12619 1
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
d12634 1
a12634 1
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d12908 1
a12908 1
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d12923 1
a12923 1
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
d12973 1
a12973 1
      inst.instruction = neon_dp_fixup (inst.instruction);
d12994 1
a12994 1
      inst.instruction = NEON_ENC_FLOAT (inst.instruction);
d12999 1
a12999 1
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13132 1
a13132 1
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
d13141 1
a13141 1
      inst.instruction = neon_dp_fixup (inst.instruction);
d13217 1
a13217 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d13234 1
a13234 1
      inst.instruction = NEON_ENC_SCALAR (inst.instruction);
d13293 1
a13293 1
      inst.instruction = NEON_ENC_SCALAR (inst.instruction);
d13301 1
a13301 1
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13354 1
a13354 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d13405 1
a13405 1
  inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13419 1
a13419 1
  inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13485 1
a13485 1
  inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13525 1
a13525 1
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13532 1
a13532 1
      inst.instruction = neon_dp_fixup (inst.instruction);
d13539 1
a13539 1
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
d13720 1
a13720 1
        inst.instruction = NEON_ENC_IMMED (inst.instruction);
d13731 1
a13731 1
        inst.instruction = neon_dp_fixup (inst.instruction);
d13741 1
a13741 1
        inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13756 1
a13756 1
        inst.instruction = neon_dp_fixup (inst.instruction);
d13787 1
a13787 1
      inst.instruction = neon_dp_fixup (inst.instruction);
d13883 1
a13883 1
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13892 1
a13892 1
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
d13896 1
a13896 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d13916 1
a13916 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d13943 1
a13943 1
      inst.instruction = NEON_ENC_SCALAR (inst.instruction);
d13950 1
a13950 1
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d13996 1
a13996 1
        inst.instruction = NEON_ENC_POLY (inst.instruction);
d13998 1
a13998 1
        inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d14024 1
a14024 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d14060 1
a14060 1
      inst.instruction = NEON_ENC_SCALAR (inst.instruction);
d14069 1
a14069 1
      inst.instruction = neon_dp_fixup (inst.instruction);
d14077 1
a14077 1
      inst.instruction = NEON_ENC_ARMREG (inst.instruction);
d14174 1
a14174 1
        inst.instruction = neon_dp_fixup (inst.instruction);
d14194 1
a14194 1
      inst.instruction = neon_dp_fixup (inst.instruction);
d14383 1
a14383 1
  inst.instruction = NEON_ENC_INTEGER (inst.instruction);
d14487 1
a14487 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d14816 1
a14816 1
      inst.instruction = NEON_ENC_INTERLV (inst.instruction);
d14821 1
a14821 1
      inst.instruction = NEON_ENC_DUP (inst.instruction);
d14826 1
a14826 1
      inst.instruction = NEON_ENC_LANE (inst.instruction);
d15684 2
d15731 3
@


1.421
log
@        PR binutils/10924
        * config/tc-arm.c (do_ldstv4): Do not allow r15 as the destination
        register.
        (do_mrs): Likewise.
        (do_mul): Likewise.

        * arm-dis.c: Add support for %<>ru and %<>rU formats to enforce
        unique register numbers.  Extend support for %<>R format to
        thumb32 and coprocessor instructions.

        * gas/arm/unpredictable.s: Add more unpredictable instructions.
        * gas/arm/unpredictable.d: Add expected disassemblies.
@
text
@d19539 25
a20255 4
      if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

d20263 16
d20280 1
a20280 2
	{
	  offsetT newval2;
a20281 7
	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (value & 0x7fffff) >> 12;
	  newval2 |= (value & 0xfff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
	}
d20290 1
a20290 3
	{
	  offsetT newval2;
	  addressT S, I1, I2, lo, hi;
a20291 16
	  S  = (value & 0x01000000) >> 24;
	  I1 = (value & 0x00800000) >> 23;
	  I2 = (value & 0x00400000) >> 22;
	  hi = (value & 0x003ff000) >> 12;
	  lo = (value & 0x00000ffe) >> 1;

	  I1 = !(I1 ^ S);
	  I2 = !(I2 ^ S);

	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (S << 10) | hi;
	  newval2 |= (I1 << 13) | (I2 << 11) | lo;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
	}
@


1.420
log
@       * config/tc-arm.c (arm_init_frag): Set thumb MODE_RECORDED flag for
       non-elf.
       (arm_handle_align): Re-enable assert for non-elf.
@
text
@d7509 1
d7675 1
d7704 2
@


1.419
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@a18579 1
#ifdef OBJ_ELF
a18580 1
#endif
d18686 1
a18686 1
  fragP->tc_frag_data.thumb_mode = thumb_mode;
@


1.418
log
@        PR gas/11013
        * arm-dis.c (thumb32_opc): Adjust disassembly of QADD, QDADD, QSUB
        and QDSUB.

        * gas/arm/arch7em.d: Update expected disassembly.
        * gas/arm/thumb32.d: Likewise.

        * config/tc-arm.c (do_t_simd2): New function.
        (insns): Use do_t_simd2 for QADD, QDADD, QSUB and QDSUB.
@
text
@d1055 1
a1055 1
md_operand (expressionS * expr)
d1058 1
a1058 1
    expr->X_op = O_illegal;
d1586 1
a1586 1
	  expressionS expr;
d1588 1
a1588 1
	  if (my_get_expression (&expr, &str, GE_NO_PREFIX))
d1591 1
a1591 1
	  if (expr.X_op == O_constant)
d1593 2
a1594 2
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
d1600 1
a1600 1
	      if ((range & expr.X_add_number) != 0)
d1602 1
a1602 1
		  int regno = range & expr.X_add_number;
d1611 1
a1611 1
	      range |= expr.X_add_number;
d1621 1
a1621 1
	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
d4714 1
a4714 1
  expressionS expr;
d4738 1
a4738 1
      if (my_get_expression (&expr, str, GE_NO_PREFIX))
d4741 1
a4741 1
      if (expr.X_op != O_constant || inst.reloc.exp.X_op != O_constant)
d4747 1
a4747 1
      value = expr.X_add_number;
d14166 1
a14166 3
        struct neon_type_el et = neon_check_type (2, NS_NULL,
          N_8 | N_16 | N_32 | N_KEY, N_EQK);
        int logsize = neon_logbits (et.size);
d14170 3
d14214 1
a14214 3
        struct neon_type_el et = neon_check_type (2, NS_NULL,
          N_EQK, N_S8 | N_S16 | N_U8 | N_U16 | N_32 | N_KEY);
        unsigned logsize = neon_logbits (et.size);
d14219 4
d19132 1
a19132 1
  expressionS expr;
d19134 4
a19137 4
  expr.X_op = O_secrel;
  expr.X_add_symbol = symbol;
  expr.X_add_number = 0;
  emit_expr (&expr, size);
d22608 1
a22608 1
      char *p;
d22610 2
a22611 2
      p = selected_cpu_name;
      if (strncmp (p, "armv", 4) == 0)
d22615 3
a22617 3
	  p += 4;
	  for (i = 0; p[i]; i++)
	    p[i] = TOUPPER (p[i]);
d22619 1
a22619 1
      aeabi_set_attribute_string (Tag_CPU_name, p);
@


1.417
log
@        PR gas/11032
        * config/tc-arm.c (relax_adr): Cope with a frag with no symbol.
@
text
@d11106 18
d16515 4
a16518 4
 TCE("qadd",	1000050, fa80f080, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd),
 TCE("qdadd",	1400050, fa80f090, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd),
 TCE("qsub",	1200050, fa80f0a0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd),
 TCE("qdsub",	1600050, fa80f0b0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd),
@


1.416
log
@2009-11-18  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_fpus): Add fpv4-sp-d16.
	(aeabi_set_public_attributes): Correctly mark VFPv3xD.

	include/opcode/
	* arm.h (FPU_VFP_V4_SP_D16, FPU_ARCH_VFP_V4_SP_D16): Define.
@
text
@d4975 1
a4975 1
	  /* bare address - translate to PC-relative offset */
d4981 1
a4981 1
      /* else a load-constant pseudo op, no special treatment needed here */
d18338 2
a18339 1
  if (!S_IS_DEFINED (fragp->fr_symbol)
@


1.415
log
@2009-11-17  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	gas/
	* doc/c-arm.texi: Document .arch armv7e-m.
	* config/tc-arm.c (arm_ext_v6_dsp, arm_ext_v7m): New.
	(insns): Put Thumb versions of v5TExP instructions into
	arm_ext_v5exp also.  Move some Thumb variants from
	arm_ext_v6_notm to arm_ext_v6_dsp.
	(arm_archs): Add armv7e-m architecture.
	(aeabi_set_public_attributes): Handle -march=armv7e-m.

	gas/testsuite/
	* gas/arm/attr-march-armv7em.d: New test.
	* gas/arm/arch7em-bad.d: New test.
	* gas/arm/arch7em-bad.l: New test.
	* gas/arm/arch7em.d: New test.
	* gas/arm/arch7em.s: New test.

	include/elf/
	* arm.h (TAG_CPU_ARCH_V7E_M): Define.

	include/opcode/
	* arm.h (ARM_EXT_V6_DSP): Define.
	(ARM_AEXT_V6T2, ARM_AEXT_NOTM): Include ARM_EXT_V6_DSP.
	(ARM_AEXT_V7EM, ARM_ARCH_V7EM): Define.

	binutils/
	* readelf.c (arm_attr_tag_CPU_arch): Add v7E-M.

	bfd/
	* elf32-arm.c (using_thumb_only, arch_has_arm_nop,
	arch_has_thumb2_nop): Handle TAG_CPU_ARCH_V7E_M.
	(tag_cpu_arch_combine): Ditto. Correct MAX_TAG_CPU_ARCH test.
@
text
@d22105 1
d22629 1
a22629 1
  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v3))
@


1.414
log
@        * config/tc-arm.c (parse_operands): Encode APSR_nzcv as r15.
        (do_vmrs): New function.
        (do_vmsr): New function.
        (insns): Add vmrs and vmsr.

        * gas/arm/vfp1xD.s: Add vmrs and vmsr instructions.
        * gas/arm/vfp1xD.d: Update expected disassembly.
@
text
@d191 1
d198 1
d16473 2
d16504 2
d16546 1
a16546 1
/*  ARM V6 not included in V7M (eg. integer SIMD).  */
d16549 12
d16562 3
a16627 8
 TUF("rfeia",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfeib,	9900a00,           1, (RRw),			   rfe),
  UF(rfeda,	8100a00,           1, (RRw),			   rfe),
 TUF("rfedb",	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TUF("rfefd",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfefa,	9900a00,           1, (RRw),			   rfe),
  UF(rfeea,	8100a00,           1, (RRw),			   rfe),
 TUF("rfeed",	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
a16654 4
 TUF("srsia",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
  UF(srsib,	9c00500,           2, (oRRw, I31w),		   srs),
  UF(srsda,	8400500,	   2, (oRRw, I31w),		   srs),
 TUF("srsdb",	9400500, e800c000, 2, (oRRw, I31w),		   srs,  srs),
d22046 1
d22568 14
@


1.413
log
@2009-11-03  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_vfp_nsyn_mla_mls): Fix vmls excoding.

	gas/testsuite/
	* gas/arm/vfp-neon-syntax.d: Update expected results.
	* gas/arm/vfp-neon-syntax_t2.d: Update expected results.
@
text
@d6306 2
d7620 43
d17216 2
@


1.412
log
@2009-11-02  Paul Brook  <paul@@codesourcery.com>

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add new attr-merge-vfp tests.
	* ld-arm/attr-merge-vfp-1.d: New test.
	* ld-arm/attr-merge-vfp-1r.d: New test.
	* ld-arm/attr-merge-vfp-2.d: New test.
	* ld-arm/attr-merge-vfp-2r.d: New test.
	* ld-arm/attr-merge-vfp-3.d: New test.
	* ld-arm/attr-merge-vfp-3r.d: New test.
	* ld-arm/attr-merge-vfp-4.d: New test.
	* ld-arm/attr-merge-vfp-4r.d: New test.
	* ld-arm/attr-merge-vfp-5.d: New test.
	* ld-arm/attr-merge-vfp-5r.d: New test.
	* ld-arm/attr-merge-vfp-2.s: New test.
	* ld-arm/attr-merge-vfp-3.s: New test.
	* ld-arm/attr-merge-vfp-3-d16.s: New test.
	* ld-arm/attr-merge-vfp-4.s: New test.
	* ld-arm/attr-merge-vfp-4-d16.s: New test.

	gas/
	* doc/c-arm.texi: Document new -mfpu options.
	* config/tc-arm.c (fpu_vfp_ext_v3xd, fpu_vfp_fp16, fpu_neon_ext_fma,
	fpu_vfp_ext_fma): New.
	(NEON_ENC_TAB): Add vfma, vfms, vfnma and vfnms.
	(do_vfp_nsyn_fma_fms, do_neon_fmac): New functions.
	(insns): Move double precision load/store.  Split out double
	precision VFPv3 instrucitons.  Add VFPv4 instructions.
	(arm_fpus): Add VFPv3-FP16, VFPv3xD and VFPv4 variants.
	(aeabi_set_public_attributes): Set VFPv4 variants

	gas/testsuite/
	* gas/arm/attr-mfpu-vfpv4.d: New test.
	* gas/arm/attr-mfpu-vfpv4-d16.d: New test.
	* gas/arm/neon-fma-cov.d: New test.
	* gas/arm/neon-fma-cov.s: New test.
	* gas/arm/vfp-fma-inc.s: New test.
	* gas/arm/vfp-fma-arm.d: New test.
	* gas/arm/vfp-fma-arm.s: New test.
	* gas/arm/vfp-fma-thumb.d: New test.
	* gas/arm/vfp-fma-thumb.s: New test.
	* gas/arm/vfma1.d: New test.
	* gas/arm/vfma1.s: New test.
	* gas/arm/vfpv3xd.d: New test.
	* gas/arm/vfpv3xd.s: New test.

	include/opcode/
	* arm.h (FPU_VFP_EXT_V3xD, FPU_VFP_EXT_FP16, FPU_NEON_EXT_FMA,
	FPU_VFP_EXT_FMA, FPU_VFP_V3xD, FPU_VFP_V4D16, FPU_VFP_V4): Define.
	(FPU_ARCH_VFP_V3D16_FP16, FPU_ARCH_VFP_V3_FP16, FPU_ARCH_VFP_V3xD,
	FPU_ARCH_VFP_V3xD_FP16, FPU_ARCH_VFP_V4, FPU_ARCH_VFP_V4D16,
	FPU_ARCH_NEON_VFP_V4): Define.

	binutils/
	* readelf.c (arm_attr_tag_VFP_arch): Add VFPv4 and VFPv4-D16.

	bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Handle VFPv4
	attributes.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Update to use new feature flags.
	Add VFPv4 instructions.
@
text
@d12147 1
a12147 1
        do_vfp_nsyn_opcode ("fmscs");
d12154 1
a12154 1
        do_vfp_nsyn_opcode ("fmscd");
@


1.411
log
@2009-10-29  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (neon_tab_entry): Fix VNMLA/VNMLS opcodes.

	gas/testsuite/
	* gas/arm/vfp-neon-syntax.d: Update expected results.
	* gas/arm/vfp-neon-syntax_t2.d: Update expected results.
@
text
@d219 1
d226 3
a228 1
static const arm_feature_set fpu_neon_fp16 = ARM_FEATURE (0, FPU_NEON_FP16);
d11299 2
d11338 2
d12159 21
d13147 12
d17222 13
a17252 12
  /* Memory operations.	 */
 cCE("fldd",	d100b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
 cCE("fstd",	d000b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
 cCE("fldmiad",	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE("fldmfdd",	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE("fldmdbd",	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fldmead",	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fstmiad",	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE("fstmead",	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE("fstmdbd",	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE("fstmfdd",	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),

d17579 14
a17596 1
 cCE("fconsts",   eb00a00, 2, (RVS, I255),      vfp_sp_const),
a17597 1
 cCE("fshtos",    eba0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
a17598 1
 cCE("fsltos",    eba0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
a17599 1
 cCE("fuhtos",    ebb0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
a17600 1
 cCE("fultos",    ebb0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
a17601 1
 cCE("ftoshs",    ebe0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
a17602 1
 cCE("ftosls",    ebe0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
a17603 1
 cCE("ftouhs",    ebf0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
a17604 1
 cCE("ftouls",    ebf0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
d17607 18
d22034 1
d22036 3
d22046 3
d22527 1
d22530 1
d22538 1
d22543 1
d22549 1
d22551 5
a22555 1
  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_d32))
d22564 1
d22570 1
d22573 4
a22576 1
    aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 1);
d22578 1
a22578 1
  if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_fp16))
@


1.410
log
@2009-10-29  Paul Brook  <paul@@codesourcery.com>

	gas/
	* doc/c-arm.texi: Document ARM -mcpu=cortex-a5.
	* config/arm/tc-arm.c (arm_cpu_option_table): Add cortex-a5.
@
text
@d11331 2
a11332 2
  X(vnmla,      0xe000a40, 0xe000b40, N_INV),		\
  X(vnmls,      0xe100a40, 0xe100b40, N_INV),		\
@


1.409
log
@2009-10-28  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (opcode_lookup): Allow VFP/NEON type suffixes
	unconditionally.
@
text
@d21856 1
@


1.408
log
@	* as.h (know): Don't define as empty.
	* config/tc-arm.c (make_mapping_symbol): Revert last patch.
@
text
@a14957 3
  bfd_boolean neon_supported;

  neon_supported = ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1);
d14960 1
a14960 1
     '.' (in unified mode, or for Neon instructions), or end of string.  */
d14962 1
a14962 1
    if (*end == ' ' || ((unified_syntax || neon_supported) && *end == '.'))
@


1.407
log
@	* config/tc-arm.c (make_mapping_symbol): Add braces to avoid empty body
	in release builds.
@
text
@d2492 1
a2492 3
    {
      know (S_GET_VALUE (frag->tc_frag_data.last_map) < S_GET_VALUE (symbolP));
    }
@


1.406
log
@	* config/tc-arm.c (mapping_state, mapping_state_2): Make dummy
	versions slightly more than nothing.
@
text
@d2492 3
a2494 1
    know (S_GET_VALUE (frag->tc_frag_data.last_map) < S_GET_VALUE (symbolP));
@


1.405
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d2580 2
a2581 2
#define mapping_state(x) /* nothing */
#define mapping_state_2(x, y) /* nothing */
@


1.404
log
@9-09-07  Daniel Gutson  <dgutson@@codesourcery.com>

        * config/tc-arm.c (arm_cpus): cortex-r4f CPU added.
        * doc/c-arm.texi: cortex-r4f CPU added.
@
text
@d1370 1
a1370 1
    type = reg->type;
d1664 1
a1664 1
  enum arm_reg_type regtype = 0;
d2039 2
a2040 1
  if ((r = hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)
d2097 2
a2098 1
      reg->neon = xmalloc (sizeof (struct neon_typed_alias));
d2127 1
a2127 1
  old = hash_find (arm_reg_hsh, oldname);
d2144 1
a2144 1
  nbuf = alloca (nlen + 1);
d2296 1
a2296 1
  namebuf = alloca (namelen + 1);
d2369 2
a2370 1
      struct reg_entry *reg = hash_find (arm_reg_hsh, name);
d2395 1
a2395 1
	  reg = hash_find (arm_reg_hsh, nbuf);
d2407 1
a2407 1
	  reg = hash_find (arm_reg_hsh, nbuf);
d2768 1
a2768 1
	  fragS * dummy_frag = xmalloc (sizeof (fragS));
d2937 1
a2937 1
      pool = xmalloc (sizeof (* pool));
d3031 1
a3031 1
  preserved_copy_of_name = obstack_finish (&notes);
d3165 3
a3167 1
	      reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, reloc);
d3188 1
a3188 1
		  char *save_buf = alloca (input_line_pointer - base);
d3200 1
a3200 1
			       size, &exp, 0, reloc);
d4631 2
a4632 1
  shift_name = hash_find_n (arm_shift_hsh, *str, p - *str);
d4915 1
a4915 1
      inst.reloc.type = entry->alu_code;
d5063 1
a5063 1
	            inst.reloc.type = entry->ldr_code;
d5067 1
a5067 1
	            inst.reloc.type = entry->ldrs_code;
d5071 1
a5071 1
	            inst.reloc.type = entry->ldc_code;
d5177 1
a5177 1
  return parse_address_main (str, i, 0, 0) == PARSE_OPERAND_SUCCESS
d5253 2
a5254 1
      psr = hash_find_n (arm_v7m_psr_hsh, start, p - start);
d5273 2
a5274 1
      psr = hash_find_n (arm_psr_hsh, start, p - start);
d5415 1
a5415 1
  c = hash_find_n (arm_cond_hsh, cond, n);
d5438 2
a5439 1
  o = hash_find_n (arm_barrier_opt_hsh, p, q - p);
d6801 1
a6801 1
    inst.reloc.type = reloc_override;
d7106 1
a7106 1
      inst.reloc.type = default_reloc;
d8729 77
a8805 77
  X(adc,   4140, eb400000),			\
  X(adcs,  4140, eb500000),			\
  X(add,   1c00, eb000000),			\
  X(adds,  1c00, eb100000),			\
  X(addi,  0000, f1000000),			\
  X(addis, 0000, f1100000),			\
  X(add_pc,000f, f20f0000),			\
  X(add_sp,000d, f10d0000),			\
  X(adr,   000f, f20f0000),			\
  X(and,   4000, ea000000),			\
  X(ands,  4000, ea100000),			\
  X(asr,   1000, fa40f000),			\
  X(asrs,  1000, fa50f000),			\
  X(b,     e000, f000b000),			\
  X(bcond, d000, f0008000),			\
  X(bic,   4380, ea200000),			\
  X(bics,  4380, ea300000),			\
  X(cmn,   42c0, eb100f00),			\
  X(cmp,   2800, ebb00f00),			\
  X(cpsie, b660, f3af8400),			\
  X(cpsid, b670, f3af8600),			\
  X(cpy,   4600, ea4f0000),			\
  X(dec_sp,80dd, f1ad0d00),			\
  X(eor,   4040, ea800000),			\
  X(eors,  4040, ea900000),			\
  X(inc_sp,00dd, f10d0d00),			\
  X(ldmia, c800, e8900000),			\
  X(ldr,   6800, f8500000),			\
  X(ldrb,  7800, f8100000),			\
  X(ldrh,  8800, f8300000),			\
  X(ldrsb, 5600, f9100000),			\
  X(ldrsh, 5e00, f9300000),			\
  X(ldr_pc,4800, f85f0000),			\
  X(ldr_pc2,4800, f85f0000),			\
  X(ldr_sp,9800, f85d0000),			\
  X(lsl,   0000, fa00f000),			\
  X(lsls,  0000, fa10f000),			\
  X(lsr,   0800, fa20f000),			\
  X(lsrs,  0800, fa30f000),			\
  X(mov,   2000, ea4f0000),			\
  X(movs,  2000, ea5f0000),			\
  X(mul,   4340, fb00f000),                     \
  X(muls,  4340, ffffffff), /* no 32b muls */	\
  X(mvn,   43c0, ea6f0000),			\
  X(mvns,  43c0, ea7f0000),			\
  X(neg,   4240, f1c00000), /* rsb #0 */	\
  X(negs,  4240, f1d00000), /* rsbs #0 */	\
  X(orr,   4300, ea400000),			\
  X(orrs,  4300, ea500000),			\
  X(pop,   bc00, e8bd0000), /* ldmia sp!,... */	\
  X(push,  b400, e92d0000), /* stmdb sp!,... */	\
  X(rev,   ba00, fa90f080),			\
  X(rev16, ba40, fa90f090),			\
  X(revsh, bac0, fa90f0b0),			\
  X(ror,   41c0, fa60f000),			\
  X(rors,  41c0, fa70f000),			\
  X(sbc,   4180, eb600000),			\
  X(sbcs,  4180, eb700000),			\
  X(stmia, c000, e8800000),			\
  X(str,   6000, f8400000),			\
  X(strb,  7000, f8000000),			\
  X(strh,  8000, f8200000),			\
  X(str_sp,9000, f84d0000),			\
  X(sub,   1e00, eba00000),			\
  X(subs,  1e00, ebb00000),			\
  X(subi,  8000, f1a00000),			\
  X(subis, 8000, f1b00000),			\
  X(sxtb,  b240, fa4ff080),			\
  X(sxth,  b200, fa0ff080),			\
  X(tst,   4200, ea100f00),			\
  X(uxtb,  b2c0, fa5ff080),			\
  X(uxth,  b280, fa1ff080),			\
  X(nop,   bf00, f3af8000),			\
  X(yield, bf10, f3af8001),			\
  X(wfe,   bf20, f3af8002),			\
  X(wfi,   bf30, f3af8003),			\
  X(sev,   bf40, f3af8004),
d8810 1
a8810 1
#define X(a,b,c) T_MNEM_##a
d11581 1
a11581 1
  for (; shape != NS_NULL; shape = va_arg (ap, int))
d11834 2
a11835 1
      if (el_type_of_type_chk (&type, &size, allowed & i) == SUCCESS)
d12050 1
a12050 1
  opcode = hash_find (arm_ops_hsh, opname);
d12789 1
a12789 1
      enum neon_opc opcode = inst.instruction & 0x0fffffff;
d14740 2
a14741 1
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
d14745 2
a14746 2
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
d15003 2
a15004 1
  opcode = hash_find_n (arm_ops_hsh, base, end - base);
d15017 1
a15017 1
      cond = hash_find_n (arm_cond_hsh, affix, 2);
d15031 3
a15033 2
  cond = hash_find_n (arm_cond_hsh, affix, 2);
  opcode = hash_find_n (arm_ops_hsh, base, affix - base);
d15080 1
a15080 1
  cond = hash_find_n (arm_cond_hsh, affix, 2);
d15086 2
a15087 1
  opcode = hash_find_n (arm_ops_hsh, base, (end - base) - 2);
d16003 1
a16003 1
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, top, ARM_VARIANT, \
d16011 1
a16011 1
      TxCE (mnem, aop, T_MNEM_##top, nops, ops, ae, te)
d16016 1
a16016 1
  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, top, ARM_VARIANT, \
d16019 1
a16019 1
  { #mnem, OPS##nops ops, OT_cinfix3_deprecated, 0x##op, top, ARM_VARIANT, \
d16026 1
a16026 1
      TxC3 (mnem, aop, T_MNEM_##top, nops, ops, ae, te)
d16028 1
a16028 1
      TxC3w (mnem, aop, T_MNEM_##top, nops, ops, ae, te)
d16033 1
a16033 1
  { #m1 #m2 #m3, OPS##nops ops, sizeof (#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof (#m1) - 1, \
d16060 1
a16060 1
      TxCM (m1,m2, aop, T_MNEM_##top, nops, ops, ae, te)
d16066 1
a16066 1
  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \
d16072 1
a16072 1
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##top, ARM_VARIANT, \
d16077 1
a16077 1
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
d16085 1
a16085 1
  { #mnem, OPS##nops ops, OT_cinfix3_legacy, \
d16090 1
a16090 1
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }
d16096 1
a16096 1
  { #mnem, OPS##nops ops, OT_cinfix3_legacy, \
d16102 1
a16102 1
  { #mnem, OPS##nops ops, OT_csuf_or_in3, \
d16106 2
a16107 2
  { #m1 #m2 #m3, OPS##nops ops, \
    sizeof (#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof (#m1) - 1, \
d16147 1
a16147 1
  { #mnem, OPS##nops ops, OT_unconditionalF, N_MNEM_##op, N_MNEM_##op,	\
d16164 1
a16164 1
  { #mnem, OPS##nops ops, tag, N_MNEM_##op, N_MNEM_##op,		\
d16182 16
a16197 16
 tCE(and,	0000000, and,      3, (RR, oRR, SH), arit, t_arit3c),
 tC3(ands,	0100000, ands,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(eor,	0200000, eor,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(eors,	0300000, eors,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(sub,	0400000, sub,	   3, (RR, oRR, SH), arit, t_add_sub),
 tC3(subs,	0500000, subs,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCE(add,	0800000, add,	   3, (RR, oRR, SHG), arit, t_add_sub),
 tC3(adds,	0900000, adds,	   3, (RR, oRR, SHG), arit, t_add_sub),
 tCE(adc,	0a00000, adc,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(adcs,	0b00000, adcs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(sbc,	0c00000, sbc,	   3, (RR, oRR, SH), arit, t_arit3),
 tC3(sbcs,	0d00000, sbcs,	   3, (RR, oRR, SH), arit, t_arit3),
 tCE(orr,	1800000, orr,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(orrs,	1900000, orrs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(bic,	1c00000, bic,	   3, (RR, oRR, SH), arit, t_arit3),
 tC3(bics,	1d00000, bics,	   3, (RR, oRR, SH), arit, t_arit3),
d16202 31
a16232 31
 tCE(tst,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tC3w(tsts,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
  CL(tstp,	110f000,     	   2, (RR, SH),      cmp),
 tCE(cmp,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
 tC3w(cmps,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
  CL(cmpp,	150f000,     	   2, (RR, SH),      cmp),
 tCE(cmn,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tC3w(cmns,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
  CL(cmnp,	170f000,     	   2, (RR, SH),      cmp),

 tCE(mov,	1a00000, mov,	   2, (RR, SH),      mov,  t_mov_cmp),
 tC3(movs,	1b00000, movs,	   2, (RR, SH),      mov,  t_mov_cmp),
 tCE(mvn,	1e00000, mvn,	   2, (RR, SH),      mov,  t_mvn_tst),
 tC3(mvns,	1f00000, mvns,	   2, (RR, SH),      mov,  t_mvn_tst),

 tCE(ldr,	4100000, ldr,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tC3(ldrb,	4500000, ldrb,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tCE(str,	4000000, str,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tC3(strb,	4400000, strb,	   2, (RR, ADDRGLDR),ldst, t_ldst),

 tCE(stm,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(stmia,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(stmea,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tCE(ldm,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(ldmia,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(ldmfd,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),

 TCE(swi,	f000000, df00,     1, (EXPi),        swi, t_swi),
 TCE(svc,	f000000, df00,     1, (EXPi),        swi, t_swi),
 tCE(b,		a000000, b,	   1, (EXPr),	     branch, t_branch),
 TCE(bl,	b000000, f000f800, 1, (EXPr),	     bl, t_branch23),
d16235 1
a16235 1
 tCE(adr,	28f0000, adr,	   2, (RR, EXP),     adr,  t_adr),
d16237 1
a16237 1
 tCE(nop,	1a00000, nop,	   1, (oI255c),	     nop,  t_nop),
d16240 12
a16251 12
 tCE(lsl,	1a00000, lsl,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(lsls,	1b00000, lsls,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(lsr,	1a00020, lsr,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(lsrs,	1b00020, lsrs,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(asr,	1a00040, asr,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(asrs,      1b00040, asrs,     3, (RR, oRR, SH), shift, t_shift),
 tCE(ror,	1a00060, ror,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(rors,	1b00060, rors,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(neg,	2600000, neg,	   2, (RR, RR),      rd_rn, t_neg),
 tC3(negs,	2700000, negs,	   2, (RR, RR),      rd_rn, t_neg),
 tCE(push,	92d0000, push,     1, (REGLST),	     push_pop, t_push_pop),
 tCE(pop,	8bd0000, pop,	   1, (REGLST),	     push_pop, t_push_pop),
d16254 2
a16255 2
 TCE(rsb,	0600000, ebc00000, 3, (RR, oRR, SH), arit, t_rsb),
 TC3(rsbs,	0700000, ebd00000, 3, (RR, oRR, SH), arit, t_rsb),
d16260 1
a16260 1
 TCE(cpy,       1a00000, 4600,     2, (RR, RR),      rd_rm, t_cpy),
d16266 8
a16273 8
 TCE(teq,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
 TC3w(teqs,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
  CL(teqp,	130f000,           2, (RR, SH),      cmp),

 TC3(ldrt,	4300000, f8500e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(ldrbt,	4700000, f8100e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(strt,	4200000, f8400e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(strbt,	4600000, f8000e00, 2, (RR, ADDR),    ldstt, t_ldstt),
d16275 2
a16276 2
 TC3(stmdb,	9000000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(stmfd,     9000000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
d16278 2
a16279 2
 TC3(ldmdb,	9100000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(ldmea,	9100000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
d16282 1
a16282 1
  CE(rsc,	0e00000,	   3, (RR, oRR, SH), arit),
d16299 2
a16300 2
 tCE(mul,	0000090, mul,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
 tC3(muls,	0100090, muls,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
d16305 1
a16305 1
 TCE(mla,	0200090, fb000000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
d16309 7
a16315 7
 TCE(cdp,	e000000, ee000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TCE(ldc,	c100000, ec100000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TC3(ldcl,	c500000, ec500000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TCE(stc,	c000000, ec000000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TC3(stcl,	c400000, ec400000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TCE(mcr,	e000010, ee000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TCE(mrc,	e100010, ee100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
d16320 1
a16320 1
  CE(swp,	1000090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),
d16328 2
a16329 2
 TCE(mrs,	10f0000, f3ef8000, 2, (APSR_RR, RVC_PSR), mrs, t_mrs),
 TCE(msr,	120f000, f3808000, 2, (RVC_PSR, RR_EXi), msr, t_msr),
d16336 8
a16343 8
 TCE(smull,	0c00090, fb800000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(smull,s,	0d00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(umull,	0800090, fba00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(umull,s,	0900090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(smlal,	0e00090, fbc00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(smlal,s,	0f00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(umlal,	0a00090, fbe00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(umlal,s,	0b00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
d16350 6
a16355 6
 tC3(ldrh,	01000b0, ldrh,     2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3(strh,	00000b0, strh,     2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3(ldrsh,	01000f0, ldrsh,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3(ldrsb,	01000d0, ldrsb,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tCM(ld,sh,	01000f0, ldrsh,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tCM(ld,sb,	01000d0, ldrsb,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
d16363 1
a16363 1
 TCE(bx,	12fff10, 4700, 1, (RR),	bx, t_bx),
d16372 2
a16373 2
 TCE(blx,	12fff30, 4780, 1, (RR_EXr),			    blx,  t_blx),
 TUE(bkpt,	1200070, be00, 1, (oIffffb),			    bkpt, t_bkpt),
d16378 8
a16385 8
 TCE(clz,	16f0f10, fab0f080, 2, (RRnpc, RRnpc),		        rd_rm,  t_clz),
 TUF(ldc2,	c100000, fc100000, 3, (RCP, RCN, ADDRGLDC),	        lstc,	lstc),
 TUF(ldc2l,	c500000, fc500000, 3, (RCP, RCN, ADDRGLDC),		        lstc,	lstc),
 TUF(stc2,	c000000, fc000000, 3, (RCP, RCN, ADDRGLDC),	        lstc,	lstc),
 TUF(stc2l,	c400000, fc400000, 3, (RCP, RCN, ADDRGLDC),		        lstc,	lstc),
 TUF(cdp2,	e000000, fe000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TUF(mcr2,	e000010, fe000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TUF(mrc2,	e100010, fe100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
d16390 25
a16414 25
 TCE(smlabb,	1000080, fb100000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlatb,	10000a0, fb100020, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlabt,	10000c0, fb100010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlatt,	10000e0, fb100030, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE(smlawb,	1200080, fb300000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlawt,	12000c0, fb300010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE(smlalbb,	1400080, fbc00080, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlaltb,	14000a0, fbc000a0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlalbt,	14000c0, fbc00090, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlaltt,	14000e0, fbc000b0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),

 TCE(smulbb,	1600080, fb10f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smultb,	16000a0, fb10f020, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smulbt,	16000c0, fb10f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smultt,	16000e0, fb10f030, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE(smulwb,	12000a0, fb30f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smulwt,	12000e0, fb30f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE(qadd,	1000050, fa80f080, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd),
 TCE(qdadd,	1400050, fa80f090, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd),
 TCE(qsub,	1200050, fa80f0a0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd),
 TCE(qdsub,	1600050, fa80f0b0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd),
d16419 3
a16421 3
 TUF(pld,	450f000, f810f000, 1, (ADDR),		     pld,  t_pld),
 TC3(ldrd,	00000d0, e8500000, 3, (RRnpc, oRRnpc, ADDRGLDRS), ldrd, t_ldstd),
 TC3(strd,	00000f0, e8400000, 3, (RRnpc, oRRnpc, ADDRGLDRS), ldrd, t_ldstd),
d16423 2
a16424 2
 TCE(mcrr,	c400000, ec400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TCE(mrrc,	c500000, ec500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
d16429 1
a16429 1
 TCE(bxj,	12fff20, f3c08f00, 1, (RR),			  bxj, t_bxj),
d16436 10
a16445 10
 TUF(cpsie,     1080000, b660,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 TUF(cpsid,     10c0000, b670,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 tCE(rev,       6bf0f30, rev,      2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(rev16,     6bf0fb0, rev16,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(revsh,     6ff0fb0, revsh,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(sxth,      6bf0070, sxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(uxth,      6ff0070, uxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(sxtb,      6af0070, sxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(uxtb,      6ef0070, uxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 TUF(setend,    1010000, b650,     1, (ENDI),                     setend, t_setend),
d16450 4
a16453 4
 TCE(ldrex,	1900f9f, e8500f00, 2, (RRnpc, ADDR),		  ldrex, t_ldrex),
 TCE(strex,	1800f90, e8400000, 3, (RRnpc, RRnpc, ADDR),	   strex,  t_strex),
 TUF(mcrr2,	c400000, fc400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TUF(mrrc2,	c500000, fc500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
d16455 2
a16456 2
 TCE(ssat,	6a00010, f3000000, 4, (RRnpc, I32, RRnpc, oSHllar),ssat,   t_ssat),
 TCE(usat,	6e00010, f3800000, 4, (RRnpc, I31, RRnpc, oSHllar),usat,   t_usat),
d16462 6
a16467 6
 TUF(cps,	1020000, f3af8100, 1, (I31b),			  imm0, t_cps),
 TCE(pkhbt,	6800010, eac00000, 4, (RRnpc, RRnpc, RRnpc, oSHll),   pkhbt, t_pkhbt),
 TCE(pkhtb,	6800050, eac00020, 4, (RRnpc, RRnpc, RRnpc, oSHar),   pkhtb, t_pkhtb),
 TCE(qadd16,	6200f10, fa90f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qadd8,	6200f90, fa80f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qasx,	6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16469 2
a16470 2
 TCE(qaddsubx,	6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsax,	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16472 6
a16477 6
 TCE(qsubaddx,	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsub16,	6200f70, fad0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsub8,	6200ff0, fac0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sadd16,	6100f10, fa90f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sadd8,	6100f90, fa80f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sasx,	6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16479 4
a16482 4
 TCE(saddsubx,	6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shadd16,	6300f10, fa90f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shadd8,	6300f90, fa80f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shasx,     6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16484 2
a16485 2
 TCE(shaddsubx, 6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsax,      6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16487 4
a16490 4
 TCE(shsubaddx, 6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsub16,	6300f70, fad0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsub8,	6300ff0, fac0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssax,	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16492 6
a16497 6
 TCE(ssubaddx,	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssub16,	6100f70, fad0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssub8,	6100ff0, fac0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uadd16,	6500f10, fa90f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uadd8,	6500f90, fa80f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uasx,	6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16499 4
a16502 4
 TCE(uaddsubx,	6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhadd16,	6700f10, fa90f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhadd8,	6700f90, fa80f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhasx,     6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16504 2
a16505 2
 TCE(uhaddsubx, 6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsax,     6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16507 6
a16512 6
 TCE(uhsubaddx, 6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsub16,	6700f70, fad0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsub8,	6700ff0, fac0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqadd16,	6600f10, fa90f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqadd8,	6600f90, fa80f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqasx,     6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16514 2
a16515 2
 TCE(uqaddsubx, 6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsax,     6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16517 5
a16521 5
 TCE(uqsubaddx, 6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsub16,	6600f70, fad0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsub8,	6600ff0, fac0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usub16,	6500f70, fad0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usax,	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d16523 3
a16525 3
 TCE(usubaddx,	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usub8,	6500ff0, fac0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TUF(rfeia,	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
d16528 2
a16529 2
 TUF(rfedb,	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TUF(rfefd,	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
d16532 29
a16560 29
 TUF(rfeed,	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TCE(sxtah,	6b00070, fa00f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtab16,	6800070, fa20f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtab,	6a00070, fa40f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtb16,	68f0070, fa2ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE(uxtah,	6f00070, fa10f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtab16,	6c00070, fa30f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtab,	6e00070, fa50f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtb16,	6cf0070, fa3ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE(sel,	6800fb0, faa0f080, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(smlad,	7000010, fb200000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smladx,	7000030, fb200010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlald,	7400010, fbc000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlaldx,	7400030, fbc000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlsd,	7000050, fb400000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlsdx,	7000070, fb400010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlsld,	7400050, fbd000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlsldx,	7400070, fbd000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smmla,	7500010, fb500000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmlar,	7500030, fb500010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmls,	75000d0, fb600000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmlsr,	75000f0, fb600010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmul,	750f010, fb50f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smmulr,	750f030, fb50f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smuad,	700f010, fb20f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smuadx,	700f030, fb20f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smusd,	700f050, fb40f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smusdx,	700f070, fb40f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TUF(srsia,	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
d16563 6
a16568 6
 TUF(srsdb,	9400500, e800c000, 2, (oRRw, I31w),		   srs,  srs),
 TCE(ssat16,	6a00f30, f3200000, 3, (RRnpc, I16, RRnpc),	   ssat16, t_ssat16),
 TCE(umaal,	0400090, fbe00060, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,  t_mlal),
 TCE(usad8,	780f010, fb70f000, 3, (RRnpc, RRnpc, RRnpc),	   smul,   t_simd),
 TCE(usada8,	7800010, fb700000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla,   t_mla),
 TCE(usat16,	6e00f30, f3a00000, 3, (RRnpc, I15, RRnpc),	   usat16, t_usat16),
d16575 4
a16578 4
 tCE(yield,	320f001, yield,    0, (), noargs, t_hint),
 tCE(wfe,	320f002, wfe,      0, (), noargs, t_hint),
 tCE(wfi,	320f003, wfi,      0, (), noargs, t_hint),
 tCE(sev,	320f004, sev,      0, (), noargs, t_hint),
d16583 2
a16584 2
 TCE(ldrexd,	1b00f9f, e8d0007f, 3, (RRnpc, oRRnpc, RRnpcb),        ldrexd, t_ldrexd),
 TCE(strexd,	1a00f90, e8c00070, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb), strexd, t_strexd),
d16589 5
a16593 5
 TCE(ldrexb,	1d00f9f, e8d00f4f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE(ldrexh,	1f00f9f, e8d00f5f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE(strexb,	1c00f90, e8c00f40, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TCE(strexh,	1e00f90, e8c00f50, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TUF(clrex,	57ff01f, f3bf8f2f, 0, (),			      noargs, noargs),
d16598 1
a16598 1
 TCE(smc,	1600070, f7f08000, 1, (EXPi), smc, t_smc),
d16603 14
a16616 14
 TCE(bfc,	7c0001f, f36f0000, 3, (RRnpc, I31, I32),	   bfc, t_bfc),
 TCE(bfi,	7c00010, f3600000, 4, (RRnpc, RRnpc_I0, I31, I32), bfi, t_bfi),
 TCE(sbfx,	7a00050, f3400000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),
 TCE(ubfx,	7e00050, f3c00000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),

 TCE(mls,	0600090, fb000010, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
 TCE(movw,	3000000, f2400000, 2, (RRnpc, HALF),		    mov16, t_mov16),
 TCE(movt,	3400000, f2c00000, 2, (RRnpc, HALF),		    mov16, t_mov16),
 TCE(rbit,	6ff0f30, fa90f0a0, 2, (RR, RR),			    rd_rm, t_rbit),

 TC3(ldrht,	03000b0, f8300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(ldrsht,	03000f0, f9300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(ldrsbt,	03000d0, f9100e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(strht,	02000b0, f8200e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
d16618 2
a16619 2
  UT(cbnz,      b900,    2, (RR, EXP), t_cbz),
  UT(cbz,       b100,    2, (RR, EXP), t_cbz),
d16627 15
a16641 15
 TUE(it,        bf08,        bf08,     1, (COND),   it,    t_it),
 TUE(itt,       bf0c,        bf0c,     1, (COND),   it,    t_it),
 TUE(ite,       bf04,        bf04,     1, (COND),   it,    t_it),
 TUE(ittt,      bf0e,        bf0e,     1, (COND),   it,    t_it),
 TUE(itet,      bf06,        bf06,     1, (COND),   it,    t_it),
 TUE(itte,      bf0a,        bf0a,     1, (COND),   it,    t_it),
 TUE(itee,      bf02,        bf02,     1, (COND),   it,    t_it),
 TUE(itttt,     bf0f,        bf0f,     1, (COND),   it,    t_it),
 TUE(itett,     bf07,        bf07,     1, (COND),   it,    t_it),
 TUE(ittet,     bf0b,        bf0b,     1, (COND),   it,    t_it),
 TUE(iteet,     bf03,        bf03,     1, (COND),   it,    t_it),
 TUE(ittte,     bf0d,        bf0d,     1, (COND),   it,    t_it),
 TUE(itete,     bf05,        bf05,     1, (COND),   it,    t_it),
 TUE(ittee,     bf09,        bf09,     1, (COND),   it,    t_it),
 TUE(iteee,     bf01,        bf01,     1, (COND),   it,    t_it),
d16643 2
a16644 2
 TC3(rrx,       01a00060, ea4f0030, 2, (RR, RR), rd_rm, t_rrx),
 TC3(rrxs,      01b00060, ea5f0030, 2, (RR, RR), rd_rm, t_rrx),
d16650 6
a16655 6
 TCE(addw,	0, f2000000, 3, (RR, RR, EXPi), 0, t_add_sub_w),
 TCE(subw,	0, f2a00000, 3, (RR, RR, EXPi), 0, t_add_sub_w),
 TCE(orn,       0, ea600000, 3, (RR, oRR, SH),  0, t_orn),
 TCE(orns,      0, ea700000, 3, (RR, oRR, SH),  0, t_orn),
 TCE(tbb,       0, e8d0f000, 1, (TB), 0, t_tb),
 TCE(tbh,       0, e8d0f010, 1, (TB), 0, t_tb),
d16661 2
a16662 2
 TCE(sdiv,	0, fb90f0f0, 3, (RR, oRR, RR), 0, t_div),
 TCE(udiv,	0, fbb0f0f0, 3, (RR, oRR, RR), 0, t_div),
d16670 3
a16672 3
 TUF(dmb,	57ff050, f3bf8f50, 1, (oBARRIER), barrier,  t_barrier),
 TUF(dsb,	57ff040, f3bf8f40, 1, (oBARRIER), barrier,  t_barrier),
 TUF(isb,	57ff060, f3bf8f60, 1, (oBARRIER), barrier,  t_barrier),
d16680 2
a16681 2
 TUF(pli,	450f000, f910f000, 1, (ADDR),	  pli,	    t_pld),
 TCE(dbg,	320f0f0, f3af80f0, 1, (I15),	  dbg,	    t_dbg),
d16686 409
a17094 409
 cCE(wfs,	e200110, 1, (RR),	     rd),
 cCE(rfs,	e300110, 1, (RR),	     rd),
 cCE(wfc,	e400110, 1, (RR),	     rd),
 cCE(rfc,	e500110, 1, (RR),	     rd),

 cCL(ldfs,	c100100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(ldfd,	c108100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(ldfe,	c500100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(ldfp,	c508100, 2, (RF, ADDRGLDC),  rd_cpaddr),

 cCL(stfs,	c000100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(stfd,	c008100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(stfe,	c400100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(stfp,	c408100, 2, (RF, ADDRGLDC),  rd_cpaddr),

 cCL(mvfs,	e008100, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfsp,	e008120, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfsm,	e008140, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfsz,	e008160, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfd,	e008180, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfdp,	e0081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfdm,	e0081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfdz,	e0081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfe,	e088100, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfep,	e088120, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfem,	e088140, 2, (RF, RF_IF),     rd_rm),
 cCL(mvfez,	e088160, 2, (RF, RF_IF),     rd_rm),

 cCL(mnfs,	e108100, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfsp,	e108120, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfsm,	e108140, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfsz,	e108160, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfd,	e108180, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfdp,	e1081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfdm,	e1081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfdz,	e1081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfe,	e188100, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfep,	e188120, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfem,	e188140, 2, (RF, RF_IF),     rd_rm),
 cCL(mnfez,	e188160, 2, (RF, RF_IF),     rd_rm),

 cCL(abss,	e208100, 2, (RF, RF_IF),     rd_rm),
 cCL(abssp,	e208120, 2, (RF, RF_IF),     rd_rm),
 cCL(abssm,	e208140, 2, (RF, RF_IF),     rd_rm),
 cCL(abssz,	e208160, 2, (RF, RF_IF),     rd_rm),
 cCL(absd,	e208180, 2, (RF, RF_IF),     rd_rm),
 cCL(absdp,	e2081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(absdm,	e2081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(absdz,	e2081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(abse,	e288100, 2, (RF, RF_IF),     rd_rm),
 cCL(absep,	e288120, 2, (RF, RF_IF),     rd_rm),
 cCL(absem,	e288140, 2, (RF, RF_IF),     rd_rm),
 cCL(absez,	e288160, 2, (RF, RF_IF),     rd_rm),

 cCL(rnds,	e308100, 2, (RF, RF_IF),     rd_rm),
 cCL(rndsp,	e308120, 2, (RF, RF_IF),     rd_rm),
 cCL(rndsm,	e308140, 2, (RF, RF_IF),     rd_rm),
 cCL(rndsz,	e308160, 2, (RF, RF_IF),     rd_rm),
 cCL(rndd,	e308180, 2, (RF, RF_IF),     rd_rm),
 cCL(rnddp,	e3081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(rnddm,	e3081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(rnddz,	e3081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(rnde,	e388100, 2, (RF, RF_IF),     rd_rm),
 cCL(rndep,	e388120, 2, (RF, RF_IF),     rd_rm),
 cCL(rndem,	e388140, 2, (RF, RF_IF),     rd_rm),
 cCL(rndez,	e388160, 2, (RF, RF_IF),     rd_rm),

 cCL(sqts,	e408100, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtsp,	e408120, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtsm,	e408140, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtsz,	e408160, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtd,	e408180, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtdp,	e4081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtdm,	e4081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtdz,	e4081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(sqte,	e488100, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtep,	e488120, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtem,	e488140, 2, (RF, RF_IF),     rd_rm),
 cCL(sqtez,	e488160, 2, (RF, RF_IF),     rd_rm),

 cCL(logs,	e508100, 2, (RF, RF_IF),     rd_rm),
 cCL(logsp,	e508120, 2, (RF, RF_IF),     rd_rm),
 cCL(logsm,	e508140, 2, (RF, RF_IF),     rd_rm),
 cCL(logsz,	e508160, 2, (RF, RF_IF),     rd_rm),
 cCL(logd,	e508180, 2, (RF, RF_IF),     rd_rm),
 cCL(logdp,	e5081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(logdm,	e5081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(logdz,	e5081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(loge,	e588100, 2, (RF, RF_IF),     rd_rm),
 cCL(logep,	e588120, 2, (RF, RF_IF),     rd_rm),
 cCL(logem,	e588140, 2, (RF, RF_IF),     rd_rm),
 cCL(logez,	e588160, 2, (RF, RF_IF),     rd_rm),

 cCL(lgns,	e608100, 2, (RF, RF_IF),     rd_rm),
 cCL(lgnsp,	e608120, 2, (RF, RF_IF),     rd_rm),
 cCL(lgnsm,	e608140, 2, (RF, RF_IF),     rd_rm),
 cCL(lgnsz,	e608160, 2, (RF, RF_IF),     rd_rm),
 cCL(lgnd,	e608180, 2, (RF, RF_IF),     rd_rm),
 cCL(lgndp,	e6081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(lgndm,	e6081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(lgndz,	e6081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(lgne,	e688100, 2, (RF, RF_IF),     rd_rm),
 cCL(lgnep,	e688120, 2, (RF, RF_IF),     rd_rm),
 cCL(lgnem,	e688140, 2, (RF, RF_IF),     rd_rm),
 cCL(lgnez,	e688160, 2, (RF, RF_IF),     rd_rm),

 cCL(exps,	e708100, 2, (RF, RF_IF),     rd_rm),
 cCL(expsp,	e708120, 2, (RF, RF_IF),     rd_rm),
 cCL(expsm,	e708140, 2, (RF, RF_IF),     rd_rm),
 cCL(expsz,	e708160, 2, (RF, RF_IF),     rd_rm),
 cCL(expd,	e708180, 2, (RF, RF_IF),     rd_rm),
 cCL(expdp,	e7081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(expdm,	e7081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(expdz,	e7081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(expe,	e788100, 2, (RF, RF_IF),     rd_rm),
 cCL(expep,	e788120, 2, (RF, RF_IF),     rd_rm),
 cCL(expem,	e788140, 2, (RF, RF_IF),     rd_rm),
 cCL(expdz,	e788160, 2, (RF, RF_IF),     rd_rm),

 cCL(sins,	e808100, 2, (RF, RF_IF),     rd_rm),
 cCL(sinsp,	e808120, 2, (RF, RF_IF),     rd_rm),
 cCL(sinsm,	e808140, 2, (RF, RF_IF),     rd_rm),
 cCL(sinsz,	e808160, 2, (RF, RF_IF),     rd_rm),
 cCL(sind,	e808180, 2, (RF, RF_IF),     rd_rm),
 cCL(sindp,	e8081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(sindm,	e8081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(sindz,	e8081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(sine,	e888100, 2, (RF, RF_IF),     rd_rm),
 cCL(sinep,	e888120, 2, (RF, RF_IF),     rd_rm),
 cCL(sinem,	e888140, 2, (RF, RF_IF),     rd_rm),
 cCL(sinez,	e888160, 2, (RF, RF_IF),     rd_rm),

 cCL(coss,	e908100, 2, (RF, RF_IF),     rd_rm),
 cCL(cossp,	e908120, 2, (RF, RF_IF),     rd_rm),
 cCL(cossm,	e908140, 2, (RF, RF_IF),     rd_rm),
 cCL(cossz,	e908160, 2, (RF, RF_IF),     rd_rm),
 cCL(cosd,	e908180, 2, (RF, RF_IF),     rd_rm),
 cCL(cosdp,	e9081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(cosdm,	e9081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(cosdz,	e9081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(cose,	e988100, 2, (RF, RF_IF),     rd_rm),
 cCL(cosep,	e988120, 2, (RF, RF_IF),     rd_rm),
 cCL(cosem,	e988140, 2, (RF, RF_IF),     rd_rm),
 cCL(cosez,	e988160, 2, (RF, RF_IF),     rd_rm),

 cCL(tans,	ea08100, 2, (RF, RF_IF),     rd_rm),
 cCL(tansp,	ea08120, 2, (RF, RF_IF),     rd_rm),
 cCL(tansm,	ea08140, 2, (RF, RF_IF),     rd_rm),
 cCL(tansz,	ea08160, 2, (RF, RF_IF),     rd_rm),
 cCL(tand,	ea08180, 2, (RF, RF_IF),     rd_rm),
 cCL(tandp,	ea081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(tandm,	ea081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(tandz,	ea081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(tane,	ea88100, 2, (RF, RF_IF),     rd_rm),
 cCL(tanep,	ea88120, 2, (RF, RF_IF),     rd_rm),
 cCL(tanem,	ea88140, 2, (RF, RF_IF),     rd_rm),
 cCL(tanez,	ea88160, 2, (RF, RF_IF),     rd_rm),

 cCL(asns,	eb08100, 2, (RF, RF_IF),     rd_rm),
 cCL(asnsp,	eb08120, 2, (RF, RF_IF),     rd_rm),
 cCL(asnsm,	eb08140, 2, (RF, RF_IF),     rd_rm),
 cCL(asnsz,	eb08160, 2, (RF, RF_IF),     rd_rm),
 cCL(asnd,	eb08180, 2, (RF, RF_IF),     rd_rm),
 cCL(asndp,	eb081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(asndm,	eb081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(asndz,	eb081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(asne,	eb88100, 2, (RF, RF_IF),     rd_rm),
 cCL(asnep,	eb88120, 2, (RF, RF_IF),     rd_rm),
 cCL(asnem,	eb88140, 2, (RF, RF_IF),     rd_rm),
 cCL(asnez,	eb88160, 2, (RF, RF_IF),     rd_rm),

 cCL(acss,	ec08100, 2, (RF, RF_IF),     rd_rm),
 cCL(acssp,	ec08120, 2, (RF, RF_IF),     rd_rm),
 cCL(acssm,	ec08140, 2, (RF, RF_IF),     rd_rm),
 cCL(acssz,	ec08160, 2, (RF, RF_IF),     rd_rm),
 cCL(acsd,	ec08180, 2, (RF, RF_IF),     rd_rm),
 cCL(acsdp,	ec081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(acsdm,	ec081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(acsdz,	ec081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(acse,	ec88100, 2, (RF, RF_IF),     rd_rm),
 cCL(acsep,	ec88120, 2, (RF, RF_IF),     rd_rm),
 cCL(acsem,	ec88140, 2, (RF, RF_IF),     rd_rm),
 cCL(acsez,	ec88160, 2, (RF, RF_IF),     rd_rm),

 cCL(atns,	ed08100, 2, (RF, RF_IF),     rd_rm),
 cCL(atnsp,	ed08120, 2, (RF, RF_IF),     rd_rm),
 cCL(atnsm,	ed08140, 2, (RF, RF_IF),     rd_rm),
 cCL(atnsz,	ed08160, 2, (RF, RF_IF),     rd_rm),
 cCL(atnd,	ed08180, 2, (RF, RF_IF),     rd_rm),
 cCL(atndp,	ed081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(atndm,	ed081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(atndz,	ed081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(atne,	ed88100, 2, (RF, RF_IF),     rd_rm),
 cCL(atnep,	ed88120, 2, (RF, RF_IF),     rd_rm),
 cCL(atnem,	ed88140, 2, (RF, RF_IF),     rd_rm),
 cCL(atnez,	ed88160, 2, (RF, RF_IF),     rd_rm),

 cCL(urds,	ee08100, 2, (RF, RF_IF),     rd_rm),
 cCL(urdsp,	ee08120, 2, (RF, RF_IF),     rd_rm),
 cCL(urdsm,	ee08140, 2, (RF, RF_IF),     rd_rm),
 cCL(urdsz,	ee08160, 2, (RF, RF_IF),     rd_rm),
 cCL(urdd,	ee08180, 2, (RF, RF_IF),     rd_rm),
 cCL(urddp,	ee081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(urddm,	ee081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(urddz,	ee081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(urde,	ee88100, 2, (RF, RF_IF),     rd_rm),
 cCL(urdep,	ee88120, 2, (RF, RF_IF),     rd_rm),
 cCL(urdem,	ee88140, 2, (RF, RF_IF),     rd_rm),
 cCL(urdez,	ee88160, 2, (RF, RF_IF),     rd_rm),

 cCL(nrms,	ef08100, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmsp,	ef08120, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmsm,	ef08140, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmsz,	ef08160, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmd,	ef08180, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmdp,	ef081a0, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmdm,	ef081c0, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmdz,	ef081e0, 2, (RF, RF_IF),     rd_rm),
 cCL(nrme,	ef88100, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmep,	ef88120, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmem,	ef88140, 2, (RF, RF_IF),     rd_rm),
 cCL(nrmez,	ef88160, 2, (RF, RF_IF),     rd_rm),

 cCL(adfs,	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfsp,	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfsm,	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfsz,	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfd,	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfdp,	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfdm,	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfdz,	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfe,	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfep,	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfem,	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(adfez,	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(sufs,	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufsp,	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufsm,	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufsz,	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufd,	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufdp,	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufdm,	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufdz,	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufe,	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufep,	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufem,	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(sufez,	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(rsfs,	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfsp,	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfsm,	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfsz,	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfd,	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfdp,	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfdm,	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfdz,	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfe,	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfep,	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfem,	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rsfez,	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(mufs,	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufsp,	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufsm,	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufsz,	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufd,	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufdp,	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufdm,	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufdz,	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufe,	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufep,	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufem,	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(mufez,	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(dvfs,	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfsp,	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfsm,	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfsz,	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfd,	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfdp,	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfdm,	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfdz,	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfe,	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfep,	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfem,	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(dvfez,	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(rdfs,	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfsp,	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfsm,	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfsz,	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfd,	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfdp,	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfdm,	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfdz,	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfe,	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfep,	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfem,	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rdfez,	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(pows,	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powsp,	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powsm,	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powsz,	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powd,	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powdp,	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powdm,	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powdz,	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powe,	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powep,	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powem,	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(powez,	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(rpws,	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwsp,	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwsm,	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwsz,	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwd,	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwdp,	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwdm,	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwdz,	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwe,	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwep,	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwem,	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rpwez,	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(rmfs,	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfsp,	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfsm,	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfsz,	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfd,	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfdp,	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfdm,	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfdz,	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfe,	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfep,	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfem,	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(rmfez,	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(fmls,	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmlsp,	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmlsm,	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmlsz,	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmld,	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmldp,	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmldm,	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmldz,	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmle,	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmlep,	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmlem,	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fmlez,	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(fdvs,	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvsp,	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvsm,	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvsz,	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvd,	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvdp,	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvdm,	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvdz,	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdve,	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvep,	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvem,	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(fdvez,	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(frds,	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frdsp,	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frdsm,	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frdsz,	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frdd,	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frddp,	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frddm,	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frddz,	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frde,	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frdep,	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frdem,	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(frdez,	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCL(pols,	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(polsp,	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(polsm,	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(polsz,	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(pold,	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(poldp,	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(poldm,	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(poldz,	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(pole,	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(polep,	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(polem,	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cCL(polez,	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cCE(cmf,	e90f110, 2, (RF, RF_IF),     fpa_cmp),
 C3E(cmfe,	ed0f110, 2, (RF, RF_IF),     fpa_cmp),
 cCE(cnf,	eb0f110, 2, (RF, RF_IF),     fpa_cmp),
 C3E(cnfe,	ef0f110, 2, (RF, RF_IF),     fpa_cmp),

 cCL(flts,	e000110, 2, (RF, RR),	     rn_rd),
 cCL(fltsp,	e000130, 2, (RF, RR),	     rn_rd),
 cCL(fltsm,	e000150, 2, (RF, RR),	     rn_rd),
 cCL(fltsz,	e000170, 2, (RF, RR),	     rn_rd),
 cCL(fltd,	e000190, 2, (RF, RR),	     rn_rd),
 cCL(fltdp,	e0001b0, 2, (RF, RR),	     rn_rd),
 cCL(fltdm,	e0001d0, 2, (RF, RR),	     rn_rd),
 cCL(fltdz,	e0001f0, 2, (RF, RR),	     rn_rd),
 cCL(flte,	e080110, 2, (RF, RR),	     rn_rd),
 cCL(fltep,	e080130, 2, (RF, RR),	     rn_rd),
 cCL(fltem,	e080150, 2, (RF, RR),	     rn_rd),
 cCL(fltez,	e080170, 2, (RF, RR),	     rn_rd),
d17101 13
a17113 13
 cCE(fix,	e100110, 2, (RR, RF),	     rd_rm),
 cCL(fixp,	e100130, 2, (RR, RF),	     rd_rm),
 cCL(fixm,	e100150, 2, (RR, RF),	     rd_rm),
 cCL(fixz,	e100170, 2, (RR, RF),	     rd_rm),
 cCL(fixsp,	e100130, 2, (RR, RF),	     rd_rm),
 cCL(fixsm,	e100150, 2, (RR, RF),	     rd_rm),
 cCL(fixsz,	e100170, 2, (RR, RF),	     rd_rm),
 cCL(fixdp,	e100130, 2, (RR, RF),	     rd_rm),
 cCL(fixdm,	e100150, 2, (RR, RF),	     rd_rm),
 cCL(fixdz,	e100170, 2, (RR, RF),	     rd_rm),
 cCL(fixep,	e100130, 2, (RR, RF),	     rd_rm),
 cCL(fixem,	e100150, 2, (RR, RF),	     rd_rm),
 cCL(fixez,	e100170, 2, (RR, RF),	     rd_rm),
d17119 6
a17124 6
 cCE(lfm,	c100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCL(lfmfd,	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCL(lfmea,	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCE(sfm,	c000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCL(sfmfd,	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cCL(sfmea,	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),
d17130 12
a17141 12
 cCE(fcpys,	eb00a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(fmrs,	e100a10, 2, (RR, RVS),	      vfp_reg_from_sp),
 cCE(fmsr,	e000a10, 2, (RVS, RR),	      vfp_sp_from_reg),
 cCE(fmstat,	ef1fa10, 0, (),		      noargs),
 cCE(fsitos,	eb80ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(fuitos,	eb80a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(ftosis,	ebd0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(ftosizs,	ebd0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(ftouis,	ebc0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(ftouizs,	ebc0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(fmrx,	ef00a10, 2, (RR, RVC),	      rd_rn),
 cCE(fmxr,	ee00a10, 2, (RVC, RR),	      rn_rd),
d17144 18
a17161 18
 cCE(flds,	d100a00, 2, (RVS, ADDRGLDC),  vfp_sp_ldst),
 cCE(fsts,	d000a00, 2, (RVS, ADDRGLDC),  vfp_sp_ldst),
 cCE(fldmias,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
 cCE(fldmfds,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
 cCE(fldmdbs,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
 cCE(fldmeas,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
 cCE(fldmiax,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
 cCE(fldmfdx,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
 cCE(fldmdbx,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
 cCE(fldmeax,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
 cCE(fstmias,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
 cCE(fstmeas,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
 cCE(fstmdbs,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
 cCE(fstmfds,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
 cCE(fstmiax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
 cCE(fstmeax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
 cCE(fstmdbx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
 cCE(fstmfdx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
d17164 3
a17166 3
 cCE(fabss,	eb00ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(fnegs,	eb10a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(fsqrts,	eb10ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
d17169 9
a17177 9
 cCE(fadds,	e300a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE(fsubs,	e300a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE(fmuls,	e200a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE(fdivs,	e800a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE(fmacs,	e000a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE(fmscs,	e100a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE(fnmuls,	e200a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE(fnmacs,	e000a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
 cCE(fnmscs,	e100a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
d17180 4
a17183 4
 cCE(fcmps,	eb40a40, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(fcmpzs,	eb50a40, 1, (RVS),	      vfp_sp_compare_z),
 cCE(fcmpes,	eb40ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
 cCE(fcmpezs,	eb50ac0, 1, (RVS),	      vfp_sp_compare_z),
d17189 13
a17201 13
 cCE(fcpyd,	eb00b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fcvtds,	eb70ac0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
 cCE(fcvtsd,	eb70bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
 cCE(fmdhr,	e200b10, 2, (RVD, RR),	      vfp_dp_rn_rd),
 cCE(fmdlr,	e000b10, 2, (RVD, RR),	      vfp_dp_rn_rd),
 cCE(fmrdh,	e300b10, 2, (RR, RVD),	      vfp_dp_rd_rn),
 cCE(fmrdl,	e100b10, 2, (RR, RVD),	      vfp_dp_rd_rn),
 cCE(fsitod,	eb80bc0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
 cCE(fuitod,	eb80b40, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
 cCE(ftosid,	ebd0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
 cCE(ftosizd,	ebd0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
 cCE(ftouid,	ebc0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
 cCE(ftouizd,	ebc0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
d17204 10
a17213 10
 cCE(fldd,	d100b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
 cCE(fstd,	d000b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
 cCE(fldmiad,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE(fldmfdd,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE(fldmdbd,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE(fldmead,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE(fstmiad,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE(fstmead,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
 cCE(fstmdbd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
 cCE(fstmfdd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
d17216 3
a17218 3
 cCE(fabsd,	eb00bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fnegd,	eb10b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fsqrtd,	eb10bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
d17221 9
a17229 9
 cCE(faddd,	e300b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fsubd,	e300b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fmuld,	e200b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fdivd,	e800b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fmacd,	e000b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fmscd,	e100b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fnmuld,	e200b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fnmacd,	e000b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fnmscd,	e100b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
d17232 4
a17235 4
 cCE(fcmpd,	eb40b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fcmpzd,	eb50b40, 1, (RVD),	      vfp_dp_rd),
 cCE(fcmped,	eb40bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fcmpezd,	eb50bc0, 1, (RVD),	      vfp_dp_rd),
d17240 4
a17243 4
 cCE(fmsrr,	c400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),
 cCE(fmrrs,	c500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),
 cCE(fmdrr,	c400b10, 3, (RVD, RR, RR),    vfp_dp_rm_rd_rn),
 cCE(fmrrd,	c500b10, 3, (RR, RR, RVD),    vfp_dp_rd_rn_rm),
d17255 5
a17259 5
 nCE(vnmul,     vnmul,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vnmla,     vnmla,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vnmls,     vnmls,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vcmp,      vcmp,    2, (RVSD, RVSD_I0),    vfp_nsyn_cmp),
 nCE(vcmpe,     vcmpe,   2, (RVSD, RVSD_I0),    vfp_nsyn_cmp),
d17265 3
a17267 3
 nCEF(vmul,     vmul,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mul),
 nCEF(vmla,     vmla,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),
 nCEF(vmls,     vmls,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),
d17269 2
a17270 2
 nCEF(vadd,     vadd,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),
 nCEF(vsub,     vsub,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),
d17284 3
a17286 3
 nCEF(vcvt,     vcvt,    3, (RNSDQ, RNSDQ, oI32b), neon_cvt),
 nCEF(vcvtb,	vcvt,	 2, (RVS, RVS), neon_cvtb),
 nCEF(vcvtt,	vcvt,	 2, (RVS, RVS), neon_cvtt),
d17320 4
a17323 4
 nUF(vshl,      vshl,    3, (RNDQ, oRNDQ, RNDQ_I63b), neon_shl_imm),
 nUF(vshlq,     vshl,    3, (RNQ,  oRNQ,  RNDQ_I63b), neon_shl_imm),
 nUF(vqshl,     vqshl,   3, (RNDQ, oRNDQ, RNDQ_I63b), neon_qshl_imm),
 nUF(vqshlq,    vqshl,   3, (RNQ,  oRNQ,  RNDQ_I63b), neon_qshl_imm),
d17325 10
a17334 10
 nUF(vand,      vand,    2, (RNDQ, NILO),        neon_logic),
 nUF(vandq,     vand,    2, (RNQ,  NILO),        neon_logic),
 nUF(vbic,      vbic,    2, (RNDQ, NILO),        neon_logic),
 nUF(vbicq,     vbic,    2, (RNQ,  NILO),        neon_logic),
 nUF(vorr,      vorr,    2, (RNDQ, NILO),        neon_logic),
 nUF(vorrq,     vorr,    2, (RNQ,  NILO),        neon_logic),
 nUF(vorn,      vorn,    2, (RNDQ, NILO),        neon_logic),
 nUF(vornq,     vorn,    2, (RNQ,  NILO),        neon_logic),
 nUF(veor,      veor,    3, (RNDQ, oRNDQ, RNDQ), neon_logic),
 nUF(veorq,     veor,    3, (RNQ,  oRNQ,  RNQ),  neon_logic),
d17343 6
a17348 6
 nUF(vabd,      vabd,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vabdq,     vabd,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
 nUF(vmax,      vmax,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vmaxq,     vmax,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
 nUF(vmin,      vmin,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vminq,     vmin,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
d17351 8
a17358 8
 nUF(vcge,      vcge,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp),
 nUF(vcgeq,     vcge,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp),
 nUF(vcgt,      vcgt,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp),
 nUF(vcgtq,     vcgt,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp),
 nUF(vclt,      vclt,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp_inv),
 nUF(vcltq,     vclt,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp_inv),
 nUF(vcle,      vcle,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp_inv),
 nUF(vcleq,     vcle,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp_inv),
d17360 2
a17361 2
 nUF(vceq,      vceq,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_ceq),
 nUF(vceqq,     vceq,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_ceq),
d17363 2
a17364 2
 nUF(vpmax,     vpmax,   3, (RND, oRND, RND), neon_dyadic_if_su_d),
 nUF(vpmin,     vpmin,   3, (RND, oRND, RND), neon_dyadic_if_su_d),
d17366 3
a17368 3
 nUF(vmlaq,     vmla,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
 nUF(vmlsq,     vmls,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
 nUF(vpadd,     vpadd,   3, (RND,  oRND,  RND),       neon_dyadic_if_i_d),
d17370 2
a17371 2
 nUF(vaddq,     vadd,    3, (RNQ,  oRNQ,  RNQ),  neon_addsub_if_i),
 nUF(vsubq,     vsub,    3, (RNQ,  oRNQ,  RNQ),  neon_addsub_if_i),
d17376 1
a17376 1
 nUF(vmulq,     vmul,     3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mul),
d17378 4
a17381 4
 nUF(vqdmulh,   vqdmulh,  3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
 nUF(vqdmulhq,  vqdmulh,  3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
 nUF(vqrdmulh,  vqrdmulh, 3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
 nUF(vqrdmulhq, vqrdmulh, 3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
d17429 1
a17429 1
 nUF(vshll,     vshll,   3, (RNQ, RND, I32),  neon_shll),
d17431 1
a17431 1
 nUF(vcvtq,     vcvt,    3, (RNQ, RNQ, oI32b), neon_cvt),
d17433 2
a17434 2
 nUF(vmvn,      vmvn,    2, (RNDQ, RNDQ_IMVNb), neon_mvn),
 nUF(vmvnq,     vmvn,    2, (RNQ,  RNDQ_IMVNb), neon_mvn),
d17444 2
a17445 2
 nUF(vmlal,     vmlal,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
 nUF(vmlsl,     vmlsl,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
d17455 3
a17457 3
 nUF(vqdmlal,   vqdmlal, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
 nUF(vqdmlsl,   vqdmlsl, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
 nUF(vqdmull,   vqdmull, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
d17460 1
a17460 1
 nUF(vmull,     vmull,   3, (RNQ, RND, RND_RNSC), neon_vmull),
d17475 2
a17476 2
 nCE(vdup,      vdup,    2, (RNDQ, RR_RNSC),  neon_dup),
 nCE(vdupq,     vdup,    2, (RNQ,  RR_RNSC),  neon_dup),
d17480 1
a17480 1
 nUF(vmovn,     vmovn,   2, (RND, RNQ),       neon_movn),
d17482 1
a17482 1
 nUF(vqmovn,    vqmovn,  2, (RND, RNQ),       neon_qmovn),
d17484 1
a17484 1
 nUF(vqmovun,   vqmovun, 2, (RND, RNQ),       neon_qmovun),
d17518 2
a17519 2
 nUF(vtrn,      vtrn,    2, (RNDQ, RNDQ),     neon_trn),
 nUF(vtrnq,     vtrn,    2, (RNQ,  RNQ),      neon_trn),
d17531 8
a17538 8
 nUF(vld1,      vld1,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst1,      vst1,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld2,      vld2,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst2,      vst2,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld3,      vld3,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst3,      vst3,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld4,      vld4,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst4,      vst4,    2, (NSTRLST, ADDR),  neon_ldx_stx),
d17545 18
a17562 18
 cCE(fconsts,   eb00a00, 2, (RVS, I255),      vfp_sp_const),
 cCE(fconstd,   eb00b00, 2, (RVD, I255),      vfp_dp_const),
 cCE(fshtos,    eba0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE(fshtod,    eba0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE(fsltos,    eba0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE(fsltod,    eba0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE(fuhtos,    ebb0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE(fuhtod,    ebb0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE(fultos,    ebb0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE(fultod,    ebb0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE(ftoshs,    ebe0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE(ftoshd,    ebe0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE(ftosls,    ebe0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE(ftosld,    ebe0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE(ftouhs,    ebf0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE(ftouhd,    ebf0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE(ftouls,    ebf0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE(ftould,    ebf0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
d17568 8
a17575 8
 cCE(mia,	e200010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE(miaph,	e280010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE(miabb,	e2c0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE(miabt,	e2d0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE(miatb,	e2e0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE(miatt,	e2f0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
 cCE(mar,	c400000, 3, (RXA, RRnpc, RRnpc), xsc_mar),
 cCE(mra,	c500000, 3, (RRnpc, RRnpc, RXA), xsc_mra),
d17580 162
a17741 162
 cCE(tandcb,	e13f130, 1, (RR),		    iwmmxt_tandorc),
 cCE(tandch,	e53f130, 1, (RR),		    iwmmxt_tandorc),
 cCE(tandcw,	e93f130, 1, (RR),		    iwmmxt_tandorc),
 cCE(tbcstb,	e400010, 2, (RIWR, RR),		    rn_rd),
 cCE(tbcsth,	e400050, 2, (RIWR, RR),		    rn_rd),
 cCE(tbcstw,	e400090, 2, (RIWR, RR),		    rn_rd),
 cCE(textrcb,	e130170, 2, (RR, I7),		    iwmmxt_textrc),
 cCE(textrch,	e530170, 2, (RR, I7),		    iwmmxt_textrc),
 cCE(textrcw,	e930170, 2, (RR, I7),		    iwmmxt_textrc),
 cCE(textrmub,	e100070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE(textrmuh,	e500070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE(textrmuw,	e900070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE(textrmsb,	e100078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE(textrmsh,	e500078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE(textrmsw,	e900078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
 cCE(tinsrb,	e600010, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
 cCE(tinsrh,	e600050, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
 cCE(tinsrw,	e600090, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
 cCE(tmcr,	e000110, 2, (RIWC_RIWG, RR),	    rn_rd),
 cCE(tmcrr,	c400000, 3, (RIWR, RR, RR),	    rm_rd_rn),
 cCE(tmia,	e200010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE(tmiaph,	e280010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE(tmiabb,	e2c0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE(tmiabt,	e2d0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE(tmiatb,	e2e0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE(tmiatt,	e2f0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
 cCE(tmovmskb,	e100030, 2, (RR, RIWR),		    rd_rn),
 cCE(tmovmskh,	e500030, 2, (RR, RIWR),		    rd_rn),
 cCE(tmovmskw,	e900030, 2, (RR, RIWR),		    rd_rn),
 cCE(tmrc,	e100110, 2, (RR, RIWC_RIWG),	    rd_rn),
 cCE(tmrrc,	c500000, 3, (RR, RR, RIWR),	    rd_rn_rm),
 cCE(torcb,	e13f150, 1, (RR),		    iwmmxt_tandorc),
 cCE(torch,	e53f150, 1, (RR),		    iwmmxt_tandorc),
 cCE(torcw,	e93f150, 1, (RR),		    iwmmxt_tandorc),
 cCE(waccb,	e0001c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wacch,	e4001c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(waccw,	e8001c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(waddbss,	e300180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waddb,	e000180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waddbus,	e100180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waddhss,	e700180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waddh,	e400180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waddhus,	e500180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waddwss,	eb00180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waddw,	e800180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waddwus,	e900180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(waligni,	e000020, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_waligni),
 cCE(walignr0,	e800020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(walignr1,	e900020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(walignr2,	ea00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(walignr3,	eb00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wand,	e200000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wandn,	e300000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wavg2b,	e800000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wavg2br,	e900000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wavg2h,	ec00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wavg2hr,	ed00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpeqb,	e000060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpeqh,	e400060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpeqw,	e800060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpgtub,	e100060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpgtuh,	e500060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpgtuw,	e900060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpgtsb,	e300060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpgtsh,	e700060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wcmpgtsw,	eb00060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wldrb,	c100000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
 cCE(wldrh,	c500000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
 cCE(wldrw,	c100100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
 cCE(wldrd,	c500100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
 cCE(wmacs,	e600100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmacsz,	e700100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmacu,	e400100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmacuz,	e500100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmadds,	ea00100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmaddu,	e800100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmaxsb,	e200160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmaxsh,	e600160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmaxsw,	ea00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmaxub,	e000160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmaxuh,	e400160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmaxuw,	e800160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wminsb,	e300160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wminsh,	e700160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wminsw,	eb00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wminub,	e100160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wminuh,	e500160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wminuw,	e900160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmov,	e000000, 2, (RIWR, RIWR),	    iwmmxt_wmov),
 cCE(wmulsm,	e300100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmulsl,	e200100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmulum,	e100100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wmulul,	e000100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wor,	e000000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wpackhss,	e700080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wpackhus,	e500080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wpackwss,	eb00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wpackwus,	e900080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wpackdss,	ef00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wpackdus,	ed00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wrorh,	e700040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wrorhg,	e700148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wrorw,	eb00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wrorwg,	eb00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wrord,	ef00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wrordg,	ef00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wsadb,	e000120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsadbz,	e100120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsadh,	e400120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsadhz,	e500120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wshufh,	e0001e0, 3, (RIWR, RIWR, I255),	    iwmmxt_wshufh),
 cCE(wsllh,	e500040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wsllhg,	e500148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wsllw,	e900040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wsllwg,	e900148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wslld,	ed00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wslldg,	ed00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wsrah,	e400040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wsrahg,	e400148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wsraw,	e800040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wsrawg,	e800148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wsrad,	ec00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wsradg,	ec00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wsrlh,	e600040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wsrlhg,	e600148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wsrlw,	ea00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wsrlwg,	ea00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wsrld,	ee00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
 cCE(wsrldg,	ee00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
 cCE(wstrb,	c000000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
 cCE(wstrh,	c400000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
 cCE(wstrw,	c000100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
 cCE(wstrd,	c400100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
 cCE(wsubbss,	e3001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsubb,	e0001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsubbus,	e1001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsubhss,	e7001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsubh,	e4001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsubhus,	e5001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsubwss,	eb001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsubw,	e8001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wsubwus,	e9001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wunpckehub,e0000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckehuh,e4000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckehuw,e8000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckehsb,e2000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckehsh,e6000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckehsw,ea000c0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckihb, e1000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wunpckihh, e5000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wunpckihw, e9000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wunpckelub,e0000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckeluh,e4000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckeluw,e8000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckelsb,e2000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckelsh,e6000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckelsw,ea000e0, 2, (RIWR, RIWR),	    rd_rn),
 cCE(wunpckilb, e1000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wunpckilh, e5000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wunpckilw, e9000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wxor,	e100000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
 cCE(wzero,	e300000, 1, (RIWR),		    iwmmxt_wzero),
d17746 57
a17802 57
 cCE(torvscb,   e12f190, 1, (RR),		    iwmmxt_tandorc),
 cCE(torvsch,   e52f190, 1, (RR),		    iwmmxt_tandorc),
 cCE(torvscw,   e92f190, 1, (RR),		    iwmmxt_tandorc),
 cCE(wabsb,     e2001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE(wabsh,     e6001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE(wabsw,     ea001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE(wabsdiffb, e1001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wabsdiffh, e5001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wabsdiffw, e9001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddbhusl, e2001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddbhusm, e6001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddhc,    e600180, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddwc,    ea00180, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddsubhx, ea001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wavg4,	e400000, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wavg4r,    e500000, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmaddsn,   ee00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmaddsx,   eb00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmaddun,   ec00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmaddux,   e900100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmerge,    e000080, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_wmerge),
 cCE(wmiabb,    e0000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiabt,    e1000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiatb,    e2000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiatt,    e3000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiabbn,   e4000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiabtn,   e5000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiatbn,   e6000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiattn,   e7000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawbb,   e800120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawbt,   e900120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawtb,   ea00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawtt,   eb00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawbbn,  ec00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawbtn,  ed00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawtbn,  ee00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawttn,  ef00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulsmr,   ef00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulumr,   ed00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwumr,  ec000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwsmr,  ee000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwum,   ed000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwsm,   ef000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwl,    eb000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiabb,   e8000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiabt,   e9000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiatb,   ea000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiatt,   eb000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiabbn,  ec000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiabtn,  ed000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiatbn,  ee000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiattn,  ef000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmulm,    e100080, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmulmr,   e300080, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmulwm,   ec000e0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmulwmr,  ee000e0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wsubaddhx, ed001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
d17807 76
a17882 76
 cCE(cfldrs,	c100400, 2, (RMF, ADDRGLDC),	      rd_cpaddr),
 cCE(cfldrd,	c500400, 2, (RMD, ADDRGLDC),	      rd_cpaddr),
 cCE(cfldr32,	c100500, 2, (RMFX, ADDRGLDC),	      rd_cpaddr),
 cCE(cfldr64,	c500500, 2, (RMDX, ADDRGLDC),	      rd_cpaddr),
 cCE(cfstrs,	c000400, 2, (RMF, ADDRGLDC),	      rd_cpaddr),
 cCE(cfstrd,	c400400, 2, (RMD, ADDRGLDC),	      rd_cpaddr),
 cCE(cfstr32,	c000500, 2, (RMFX, ADDRGLDC),	      rd_cpaddr),
 cCE(cfstr64,	c400500, 2, (RMDX, ADDRGLDC),	      rd_cpaddr),
 cCE(cfmvsr,	e000450, 2, (RMF, RR),		      rn_rd),
 cCE(cfmvrs,	e100450, 2, (RR, RMF),		      rd_rn),
 cCE(cfmvdlr,	e000410, 2, (RMD, RR),		      rn_rd),
 cCE(cfmvrdl,	e100410, 2, (RR, RMD),		      rd_rn),
 cCE(cfmvdhr,	e000430, 2, (RMD, RR),		      rn_rd),
 cCE(cfmvrdh,	e100430, 2, (RR, RMD),		      rd_rn),
 cCE(cfmv64lr,	e000510, 2, (RMDX, RR),		      rn_rd),
 cCE(cfmvr64l,	e100510, 2, (RR, RMDX),		      rd_rn),
 cCE(cfmv64hr,	e000530, 2, (RMDX, RR),		      rn_rd),
 cCE(cfmvr64h,	e100530, 2, (RR, RMDX),		      rd_rn),
 cCE(cfmval32,	e200440, 2, (RMAX, RMFX),	      rd_rn),
 cCE(cfmv32al,	e100440, 2, (RMFX, RMAX),	      rd_rn),
 cCE(cfmvam32,	e200460, 2, (RMAX, RMFX),	      rd_rn),
 cCE(cfmv32am,	e100460, 2, (RMFX, RMAX),	      rd_rn),
 cCE(cfmvah32,	e200480, 2, (RMAX, RMFX),	      rd_rn),
 cCE(cfmv32ah,	e100480, 2, (RMFX, RMAX),	      rd_rn),
 cCE(cfmva32,	e2004a0, 2, (RMAX, RMFX),	      rd_rn),
 cCE(cfmv32a,	e1004a0, 2, (RMFX, RMAX),	      rd_rn),
 cCE(cfmva64,	e2004c0, 2, (RMAX, RMDX),	      rd_rn),
 cCE(cfmv64a,	e1004c0, 2, (RMDX, RMAX),	      rd_rn),
 cCE(cfmvsc32,	e2004e0, 2, (RMDS, RMDX),	      mav_dspsc),
 cCE(cfmv32sc,	e1004e0, 2, (RMDX, RMDS),	      rd),
 cCE(cfcpys,	e000400, 2, (RMF, RMF),		      rd_rn),
 cCE(cfcpyd,	e000420, 2, (RMD, RMD),		      rd_rn),
 cCE(cfcvtsd,	e000460, 2, (RMD, RMF),		      rd_rn),
 cCE(cfcvtds,	e000440, 2, (RMF, RMD),		      rd_rn),
 cCE(cfcvt32s,	e000480, 2, (RMF, RMFX),	      rd_rn),
 cCE(cfcvt32d,	e0004a0, 2, (RMD, RMFX),	      rd_rn),
 cCE(cfcvt64s,	e0004c0, 2, (RMF, RMDX),	      rd_rn),
 cCE(cfcvt64d,	e0004e0, 2, (RMD, RMDX),	      rd_rn),
 cCE(cfcvts32,	e100580, 2, (RMFX, RMF),	      rd_rn),
 cCE(cfcvtd32,	e1005a0, 2, (RMFX, RMD),	      rd_rn),
 cCE(cftruncs32,e1005c0, 2, (RMFX, RMF),	      rd_rn),
 cCE(cftruncd32,e1005e0, 2, (RMFX, RMD),	      rd_rn),
 cCE(cfrshl32,	e000550, 3, (RMFX, RMFX, RR),	      mav_triple),
 cCE(cfrshl64,	e000570, 3, (RMDX, RMDX, RR),	      mav_triple),
 cCE(cfsh32,	e000500, 3, (RMFX, RMFX, I63s),	      mav_shift),
 cCE(cfsh64,	e200500, 3, (RMDX, RMDX, I63s),	      mav_shift),
 cCE(cfcmps,	e100490, 3, (RR, RMF, RMF),	      rd_rn_rm),
 cCE(cfcmpd,	e1004b0, 3, (RR, RMD, RMD),	      rd_rn_rm),
 cCE(cfcmp32,	e100590, 3, (RR, RMFX, RMFX),	      rd_rn_rm),
 cCE(cfcmp64,	e1005b0, 3, (RR, RMDX, RMDX),	      rd_rn_rm),
 cCE(cfabss,	e300400, 2, (RMF, RMF),		      rd_rn),
 cCE(cfabsd,	e300420, 2, (RMD, RMD),		      rd_rn),
 cCE(cfnegs,	e300440, 2, (RMF, RMF),		      rd_rn),
 cCE(cfnegd,	e300460, 2, (RMD, RMD),		      rd_rn),
 cCE(cfadds,	e300480, 3, (RMF, RMF, RMF),	      rd_rn_rm),
 cCE(cfaddd,	e3004a0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
 cCE(cfsubs,	e3004c0, 3, (RMF, RMF, RMF),	      rd_rn_rm),
 cCE(cfsubd,	e3004e0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
 cCE(cfmuls,	e100400, 3, (RMF, RMF, RMF),	      rd_rn_rm),
 cCE(cfmuld,	e100420, 3, (RMD, RMD, RMD),	      rd_rn_rm),
 cCE(cfabs32,	e300500, 2, (RMFX, RMFX),	      rd_rn),
 cCE(cfabs64,	e300520, 2, (RMDX, RMDX),	      rd_rn),
 cCE(cfneg32,	e300540, 2, (RMFX, RMFX),	      rd_rn),
 cCE(cfneg64,	e300560, 2, (RMDX, RMDX),	      rd_rn),
 cCE(cfadd32,	e300580, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE(cfadd64,	e3005a0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
 cCE(cfsub32,	e3005c0, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE(cfsub64,	e3005e0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
 cCE(cfmul32,	e100500, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE(cfmul64,	e100520, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
 cCE(cfmac32,	e100540, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE(cfmsc32,	e100560, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
 cCE(cfmadd32,	e000600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
 cCE(cfmsub32,	e100600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
 cCE(cfmadda32, e200600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
 cCE(cfmsuba32, e300600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
d18132 1
a18132 1
		      reloc_type);
d18634 2
a18635 2
	unwind.opcodes = xrealloc (unwind.opcodes,
				   unwind.opcode_alloc);
d18637 1
a18637 1
	unwind.opcodes = xmalloc (unwind.opcode_alloc);
d18776 1
a18776 1
  sec_name = xmalloc (sec_name_len + 1);
d20647 1
a20647 1
  reloc = xmalloc (sizeof (arelent));
d20649 1
a20649 1
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
d22019 2
a22020 1
  arm_feature_set *ext_set = xmalloc (sizeof (arm_feature_set));
@


1.403
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d21852 1
@


1.403.2.1
log
@	* config/tc-arm.c (make_mapping_symbol): Add braces to avoid empty body
	in release builds.
@
text
@d2489 1
a2489 3
    {
      know (S_GET_VALUE (frag->tc_frag_data.last_map) < S_GET_VALUE (symbolP));
    }
@


1.403.2.2
log
@Fix bls for Thumb2

2009-12-24  Ramana Radhakrishnan  <ramana.radhakrishnan@@arm.com>

        Backport from trunk:
	2009-12-21  Ramana Radhakrishnan  <ramana.radhakrishnan@@arm.com>
	            Richard Earnshaw  <richard.earnshaw@@arm.com>

        * config/tc-arm.c (encode_thumb2_b_bl_offset): New. Refactored
        from md_apply_fix.
        (md_apply_fix): Fixup range checks for Thumb2 version
        of unconditional calls. Call encode_thumb2_b_bl_offset for
        unconditional branches / function calls.
@
text
@a19385 25
/* Encode Thumb2 unconditional branches and calls. The encoding
   for the 2 are identical for the immediate values.  */

static void
encode_thumb2_b_bl_offset (char * buf, offsetT value)
{
#define T2I1I2MASK  ((1 << 13) | (1 << 11))
  offsetT newval;
  offsetT newval2;
  addressT S, I1, I2, lo, hi;

  S = (value >> 24) & 0x01;
  I1 = (value >> 23) & 0x01;
  I2 = (value >> 22) & 0x01;
  hi = (value >> 12) & 0x3ff;
  lo = (value >> 1) & 0x7ff; 
  newval   = md_chars_to_number (buf, THUMB_SIZE);
  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
  newval  |= (S << 10) | hi;
  newval2 &=  ~T2I1I2MASK;
  newval2 |= (((I1 ^ S) << 13) | ((I2 ^ S) << 11) | lo) ^ T2I1I2MASK;
  md_number_to_chars (buf, newval, THUMB_SIZE);
  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
}

d20078 4
a20088 18
       if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	 {
	   if (!(ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2)))
	     {
	       as_bad_where (fixP->fx_file, fixP->fx_line,
			     _("branch out of range"));
	     }
	   else  if ((value & ~0x1ffffff)
		     && ((value & ~0x1ffffff) != ~0x1ffffff))
	       {
		 as_bad_where (fixP->fx_file, fixP->fx_line,
			     _("Thumb2 branch out of range"));
	       }
	 }

       if (fixP->fx_done || !seg->use_rela_p)
	 encode_thumb2_b_bl_offset (buf, value);

d20109 18
a20126 1
	  encode_thumb2_b_bl_offset (buf, value);
@


1.403.2.3
log
@2010-02-08  Christophe Lyon  <christophe.lyon@@st.com>

	gas/
	* config/tc-arm.c (md_pcrel_from_section): Keep base to zero for
	non-local branches (BFD_RELOC_THUMB_PCREL_BRANCH23,
	BFD_RELOC_THUMB_PCREL_BLX, BFD_RELOC_ARM_PCREL_BLX,
	BFD_RELOC_ARM_PCREL_CALL)

	gas/testsuite/
	* gas/arm/branch-reloc.s, gas/arm/branch-reloc.d,
	gas/arm/branch-reloc.l: New tests and expected results with all
	variants of call: ARM/Thumb, local/global, inter/intra-section,
	using BL/BLX.
@
text
@a19043 2
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && (!S_IS_EXTERNAL (fixP->fx_addsy))
a19052 2
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && (!S_IS_EXTERNAL (fixP->fx_addsy))
a19061 2
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && (!S_IS_EXTERNAL (fixP->fx_addsy))
a19068 2
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
	  && (!S_IS_EXTERNAL (fixP->fx_addsy))
@


1.402
log
@        * config/tc-arm.c (do_t_add_sub_w): Fixed constraints.

        gas/testsuite/
        * gas/arm/sp-pc-usage-t.d: New test case.
        * gas/arm/sp-pc-usage-t.s: New file.
@
text
@d418 1
a418 1
  const char *	 template;
d426 1
a426 1
  const char *   template;
d432 1
a432 1
  const char *   template;
d551 1
a551 1
  const char * template;
d2051 1
a2051 1
  struct reg_entry *new;
d2054 1
a2054 1
  if ((new = hash_find (arm_reg_hsh, str)) != 0)
d2056 1
a2056 1
      if (new->builtin)
d2061 1
a2061 1
      else if (new->number != number || new->type != type)
d2068 1
a2068 1
  new = xmalloc (sizeof (struct reg_entry));
d2070 5
a2074 5
  new->name = name;
  new->number = number;
  new->type = type;
  new->builtin = FALSE;
  new->neon = NULL;
d2076 1
a2076 1
  if (hash_insert (arm_reg_hsh, name, (void *) new))
d2079 1
a2079 1
  return new;
d21299 1
a21299 1
    hash_insert (arm_ops_hsh, insns[i].template, (void *) (insns + i));
d21301 1
a21301 1
    hash_insert (arm_cond_hsh, conds[i].template, (void *) (conds + i));
d21305 1
a21305 1
    hash_insert (arm_psr_hsh, psrs[i].template, (void *) (psrs + i));
d21307 2
a21308 1
    hash_insert (arm_v7m_psr_hsh, v7m_psrs[i].template, (void *) (v7m_psrs + i));
d21314 1
a21314 1
    hash_insert (arm_barrier_opt_hsh, barrier_opt_names[i].template,
@


1.401
log
@	gas/
	* config/tc-arm.c (marked_pr_dependency, mapstate): Delete global
	variables.
	(mapping_state): Use the section's mapstate.
	(mapping_state_2): Likewise.  Skip special sections.
	(s_arm_unwind_fnend): Use the section's marked_pr_dependency.
	(arm_elf_change_section): Do not set deleted globals.
	* config/tc-arm.h (struct arm_segment_info_type): Document
	marked_pr_dependency.

	gas/testsuite/
	* gas/arm/mapping2.s: Test code after .ident.
@
text
@d8829 6
a8834 3
  /* If Rn is REG_PC, this is ADR; if Rn is REG_SP, then this is the
     SP-{plus,minute}-immediate form of the instruction.  */
  reject_bad_reg (Rd);
d10270 5
d18427 1
d18429 1
@


1.400
log
@        * config/tc-arm.c (md_assemble): Call mapping_state from inside a
        block in case it is a null macro.
@
text
@a79 5
/* Bit N indicates that an R_ARM_NONE relocation has been output for
   __aeabi_unwind_cpp_prN already if set. This enables dependencies to be
   emitted only once per section, to save unnecessary bloat.  */
static unsigned int marked_pr_dependency = 0;

a2429 2
static enum mstate mapstate = MAP_UNDEFINED;

d2528 2
d2563 5
a2572 1
  mapstate = state;
d3423 1
d3453 2
a3465 1
      marked_pr_dependency |= 1 << unwind.personality_index;
d3467 1
a3467 1
	= marked_pr_dependency;
a18560 2
  segment_info_type *seginfo;

a18564 7

  if (!SEG_NORMAL (now_seg))
    return;

  seginfo = seg_info (now_seg);
  marked_pr_dependency = seginfo->tc_segment_info_data.marked_pr_dependency;
  mapstate = seginfo->tc_segment_info_data.mapstate;
@


1.399
log
@	* config/tc-arm.c (my_get_expression): Detect missing expressions.

	testsuite/
	* gas/arm/missing.s: New.
	* gas/arm/missing.d: New.
	* gas/arm/missing.l: New.
@
text
@d15523 3
a15525 1
	mapping_state (MAP_THUMB);
d15568 3
a15570 1
	mapping_state (MAP_ARM);
@


1.398
log
@	binutils/testsuite/
	* binutils-all/arm/thumb2-cond.s: Use instructions instead of
	.short.

	gas/
	* config/obj-elf.c (obj_elf_ident): Notify section change to the hook.
	* config/tc-arm.c (make_mapping_symbol): New function, from
	mapping_state.  Save mapping symbols in the frag.
	(insert_data_mapping_symbol): New.
	(mapping_state): Use make_mapping_symbol, improve state transitions.
	(mapping_state_2): New.  Provide dummy definition.
	(opcode_select): Do not call mapping_state.
	(s_bss): Call md_elf_section_change_hook instead of mapping_state.
	(output_inst): Update use of tc_frag_data.
	(new_automatic_it_block): Call mapping_state before emitting the
	IT instruction.
	(md_assemble): Move mapping_state to just before outputting the
	new instruction.
	(arm_handle_align): Update use of tc_frag_data.
	Call insert_data_mapping_symbol.
	(arm_init_frag): Update use of tc_frag_data.  Call
	mapping_state_2.
	(arm_elf_change_section): Always update the mapping symbol FSM state.
	(check_mapping_symbols): New function.
	(arm_adjust_symtab): Use check_mapping_symbols.
	* config/tc-arm.h (struct arm_frag_type): New.
	(TC_FRAG_TYPE): Change to struct arm_frag_type.
	(TC_FRAG_INIT): Pass max_chars.
	(arm_init_frag): Update prototype.

	gas/testsuite/
	* gas/arm/mapdir.d, gas/arm/mapdir.s: New files.
	* gas/arm/mapping.d: Adapted to new symbols generation.
	* gas/arm/mapping2.d: New test case.
	* gas/arm/mapping2.s: New file.
	* gas/arm/mapping3.d: New test case.
	* gas/arm/mapping3.s: New file.
	* gas/arm/mapping4.d: New test case.
	* gas/arm/mapping4.s: New file.
	* gas/arm/mapshort-eabi.d: Adapted to new symbols generation.
	* gas/elf/section2.e-armeabi: Adapted to new symbols generation.
@
text
@d916 1
a916 1
  if (ep->X_op == O_illegal)
d918 1
a918 1
      /* We found a bad expression in md_operand().  */
d922 2
a923 1
	inst.error = _("bad expression");
@


1.397
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d2436 4
a2439 2
void
mapping_state (enum mstate state)
a2444 7
  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;

  mapstate = state;

a2458 2
    case MAP_UNDEFINED:
      return;
d2463 1
a2463 4
  seg_info (now_seg)->tc_segment_info_data.mapstate = state;

  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (symbolP);
d2482 73
a2554 1
      return;
d2556 19
d2578 1
a2633 1
      mapping_state (MAP_THUMB);
a2648 1
      mapping_state (MAP_ARM);
d2887 4
a2890 1
  mapping_state (MAP_DATA);
d14797 1
a14797 1
  frag_now->tc_frag_data = thumb_mode | MODE_RECORDED;
d15101 1
a15479 1
      mapping_state (MAP_THUMB);
d15520 3
a15544 1
      mapping_state (MAP_ARM);
d15564 2
d18399 3
d18413 1
a18413 1
  gas_assert ((fragP->tc_frag_data & MODE_RECORDED) != 0);
d18415 1
a18415 1
  if (fragP->tc_frag_data & (~ MODE_RECORDED))
d18425 3
d18434 3
d18444 3
d18514 1
d18516 9
a18524 1
arm_init_frag (fragS * fragP)
d18528 20
a18547 2
  if ((fragP->tc_frag_data & MODE_RECORDED) == 0)
    fragP->tc_frag_data = thumb_mode | MODE_RECORDED;
a18549 1
#ifdef OBJ_ELF
a18554 1
  flagword flags;
a18564 6
  flags = bfd_get_section_flags (stdoutput, now_seg);

  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;

d18566 1
a18567 1
  marked_pr_dependency = seginfo->tc_segment_info_data.marked_pr_dependency;
d21106 67
d21247 3
@


1.396
log
@Oops - forgot to commit this part of a previous delta:

        * config/tc-arm.c (arm_frag_align_code): Replace hard coded
        constant with MAX_MEM_FOR_RS_ALIGN_CODE.
@
text
@d1878 2
a1879 2
  const char *const incr_error = "register stride must be 1 or 2";
  const char *const type_error = "mismatched element/structure types in list";
d18396 1
a18396 1
      as_fatal (err_msg);
@


1.395
log
@	gas/
	* config/tc-arm.c (md_apply_fix <BFD_RELOC_ARM_TARGET2>): Write
	the offset for REL targets here.

	gas/testsuite/
	* gas/arm/target-reloc-1.s: New.
	* gas/arm/target-reloc-1.d: New.

	ld/testsuite/
	* ld-arm/arm-target2.s: Add addend cases.
	* ld-arm/arm-target2-rel.d: Adjust.
	* ld-arm/arm-target2-abs.d: Adjust.
	* ld-arm/arm-target2-got-rel.d: Adjust.
@
text
@d18388 1
a18388 1
     to support alignments greater than 32 bytes.  */
d18390 8
a18397 1
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
@


1.394
log
@    gas/
    * config/tc-arm.c (md_assemble): Added validation.

    gas/testsuite
    * gas/arm/thumb-w-bad.d: New test case.
    * gas/arm/thumb-w-bad.l: New file.
    * gas/arm/thumb-w-bad.s: New file.
    * gas/arm/thumb-w-good.d: New test case.
    * gas/arm/thumb-w-good.s: New file.
@
text
@d20017 4
d20022 3
d20026 1
a20026 1
	md_number_to_chars (buf, 0, 4);
@


1.393
log
@        * config/tc-arm.c (it_fsm_post_encode): New forward declaration.
        (set_it_insn_type_nonvoid): New macro.
        (emit_thumb32_expr): New function.
        (thumb_insn_size): New function.
        (emit_insn): New function.
        (s_arm_elf_inst): New function.
        (md_pseudo_table): New pseudo-opcode entries added.
        * doc/c-arm.texi: New directive added.

        * gas/arm/inst-po.d: New testcase.
        * gas/arm/inst-po.s: New file.
        * gas/arm/inst-po-2.d: New testcase.
        * gas/arm/inst-po-2.s: New file.
        * gas/arm/inst-po-2.l: New file.
        * gas/arm/inst-po-3.d: New testcase.
        * gas/arm/inst-po-3.s: New file.
        * gas/arm/inst-po-be.d: New testcase.
@
text
@d15375 1
a15375 1
      if (!ARM_CPU_HAS_FEATURE (variant, arm_ext_v6t2) && !inst.size_req)
a15376 2
	  /* Implicit require narrow instructions on Thumb-1.  This avoids
	     relaxation accidentally introducing Thumb-2 instructions.  */
d15378 16
a15393 3
	      && !(ARM_CPU_HAS_FEATURE (*opcode->tvariant, arm_ext_msr)
		   || ARM_CPU_HAS_FEATURE (*opcode->tvariant, arm_ext_barrier)))
	    inst.size_req = 2;
@


1.392
log
@gas/
    * config/tc-arm.c (insns): Fix encoding for torvsc.

gas/testsuite/
    * gas/arm/iwmmxt2.d: Fix insn pattern for torvsc,
    add patterns for waddsubhx.
    * gas/arm/iwmmxt2.s: Add tests for waddsubhx.

opcodes/
    * arm-dis.c (coprocessor_opcodes): Fix mask for waddbhus.
@
text
@d423 2
a424 2
  const char *	template;
  unsigned long value;
d431 2
a432 2
  const char *template;
  unsigned long field;
d437 2
a438 2
  const char *template;
  unsigned long value;
d452 2
a453 2
  char *name;
  bfd_reloc_code_real_type reloc;
d473 3
a475 3
  unsigned char defined;
  unsigned char index;
  struct neon_type_el eltype;
d511 5
a515 5
  const char        *name;
  unsigned char      number;
  unsigned char      type;
  unsigned char      builtin;
  struct neon_typed_alias *neon;
d519 1
a519 1
const char *const reg_expected_msgs[] =
d556 1
a556 1
  const char *template;
d571 2
a572 2
  const arm_feature_set *avariant;
  const arm_feature_set *tvariant;
d706 8
a713 8
static struct hash_control *arm_ops_hsh;
static struct hash_control *arm_cond_hsh;
static struct hash_control *arm_shift_hsh;
static struct hash_control *arm_psr_hsh;
static struct hash_control *arm_v7m_psr_hsh;
static struct hash_control *arm_reg_hsh;
static struct hash_control *arm_reloc_hsh;
static struct hash_control *arm_barrier_opt_hsh;
d733 7
a739 7
  expressionS	 literals [MAX_LITERAL_POOL_SIZE];
  unsigned int	 next_free_entry;
  unsigned int	 id;
  symbolS *	 symbol;
  segT		 section;
  subsegT	 sub_section;
  struct literal_pool * next;
d769 2
d780 9
d845 1
d1830 1
a1830 1
static int
d1834 1
a1834 1
    return 1;
d1837 1
a1837 1
    return 0;
d1840 1
a1840 1
    return 0;
d1845 1
a1845 1
    return 0;
d1849 1
a1849 1
    return 0;
d1851 1
a1851 1
  return 1;
d1921 1
a1921 1
      if (!neon_alias_types_same (&atype, &firsttype))
d1954 1
a1954 1
          if (!neon_alias_types_same (&htype, &firsttype))
d2193 1
a2193 1
static int
d2216 1
a2216 1
    return 0;
d2221 1
a2221 1
    return 0;
d2228 1
a2228 1
      return 0;
d2239 1
a2239 1
          return 0;
d2256 1
a2256 1
          return 0;
d2263 1
a2263 1
          return 0;
d2276 1
a2276 1
          return 0;
d2284 1
a2284 1
          return 0;
d2293 1
a2293 1
          return 0;
d2321 1
a2321 1
  return 1;
d2326 1
d3124 121
d3296 1
a3296 1
      as_bad(_("duplicate .fnstart directive"));
d3324 1
a3324 1
    as_bad(MISSING_FNSTART);
d3345 1
a3345 1
      as_bad(_(".fnend directive without .fnstart"));
d3407 1
a3407 1
    as_bad(MISSING_FNSTART);
d3424 1
a3424 1
    as_bad(MISSING_FNSTART);
d3453 1
a3453 1
    as_bad(MISSING_FNSTART);
d3892 1
a3892 1
    as_bad(MISSING_FNSTART);
d3952 1
a3952 1
    as_bad(MISSING_FNSTART);
d4000 1
a4000 1
    as_bad(MISSING_FNSTART);
d4029 1
a4029 1
    as_bad(MISSING_FNSTART);
d4082 1
a4082 1
    as_bad(MISSING_FNSTART);
d4204 6
a4209 3
  { "word",	   s_arm_elf_cons, 4 },
  { "long",	   s_arm_elf_cons, 4 },
  { "rel31",	   s_arm_rel31,	  0 },
d6724 3
a6726 3
   return 1; if it can't, convert inst.instruction to a literal-pool
   load and return 0.  If this is not a valid thing to do in the
   current context, set inst.error and return 1.
d6730 1
a6730 1
static int
d6743 1
a6743 1
      return 1;
d6748 1
a6748 1
      return 1;
d6759 1
a6759 1
	      return 1;
d6771 1
a6771 1
	      return 1;
d6781 1
a6781 1
	      return 1;
d6789 1
a6789 1
      return 1;
d6800 1
a6800 1
  return 0;
d8711 1
a8711 1
  X(sev,   bf40, f3af8004), 
d8727 2
a8728 2
#define THUMB_OP32(n) (thumb_op32[(n) - (T16_32_OFFSET + 1)])
#define THUMB_SETS_FLAGS(n) (THUMB_OP32 (n) & 0x00100000)
d8735 1
d8895 1
a8895 1
	  
d9095 1
a9095 1
  
d9918 1
a9918 1
  
d10251 1
a10251 1
  
d10385 1
a10385 1
  
d10731 1
a10731 1
  
d10840 1
a10840 1
					    
d11002 1
a11002 1
  
d11087 3
a11089 2
		     
  if (inst.instruction <= 0xffff && inst.size_req != 4
d11132 1
a11132 1
  
d11431 2
a11432 2
  N_KEY  = 0x1000000, /* key element (main type specifier).  */
  N_EQK  = 0x2000000, /* given operand has the same type & size as the key.  */
d11434 7
a11440 7
  N_DBL  = 0x0000001, /* if N_EQK, this operand is twice the size.  */
  N_HLF  = 0x0000002, /* if N_EQK, this operand is half the size.  */
  N_SGN  = 0x0000004, /* if N_EQK, this operand is forced to be signed.  */
  N_UNS  = 0x0000008, /* if N_EQK, this operand is forced to be unsigned.  */
  N_INT  = 0x0000010, /* if N_EQK, this operand is forced to be integer.  */
  N_FLT  = 0x0000020, /* if N_EQK, this operand is forced to be float.  */
  N_SIZ  = 0x0000040, /* if N_EQK, this operand is forced to be size-only.  */
d14865 1
a14865 1
    return 0;
d14890 1
a14890 1
	    return 0;
d14893 1
a14893 1
        return 0;
d14922 1
a14922 1
    return 0;
d14953 1
a14953 3
	    {
	      inst.cond = cond->value;
	    }
d14956 1
a14956 1
	      /* delayed diagnostic */
d14963 1
a14963 1
	  return 0;
d14970 1
a14970 1
    return 0;
d14976 1
a14976 1
    return 0;
d14990 1
a14990 1
      /* step CM */
d15000 1
a15000 1
  return 0;
d15040 1
a15041 1
  const int resulting_bit = (cond & 1);
a15052 1

d15139 1
a15139 1
	      if (unified_syntax 
d15338 2
a15339 2
      if (!create_register_alias (str, p)
          && !create_neon_reg_alias (str, p))
d15564 1
a15564 1
int
d15572 1
a15572 1
      return 1;
d15575 1
a15575 1
  return 0;
d16131 3
a16133 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6
d16137 3
a16139 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6t2
d16168 5
a16172 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v2	/* ARM 2 - multiplies.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v4t
d16176 3
a16178 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6t2
d16191 3
a16193 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v2s /* ARM 3 - swp instructions.  */
d16197 5
a16201 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v3	/* ARM 6 Status register instructions.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_msr
d16205 5
a16209 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v3m	 /* ARM 7M long multiplies.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6t2
d16219 5
a16223 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v4	/* ARM Architecture 4.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v4t
d16231 3
a16233 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v4t_5
d16239 5
a16243 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v5 /*  ARM Architecture 5T.	 */
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v5t
d16249 3
a16251 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6t2
d16261 3
a16263 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v5exp /*  ARM Architecture 5TExP.  */
d16290 3
a16292 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v5e /*  ARM Architecture 5TE.  */
d16300 3
a16302 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v5j /*  ARM Architecture 5TEJ.  */
d16305 5
a16309 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v6 /*  ARM V6.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6
d16321 3
a16323 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6t2
d16333 3
a16335 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6_notm
d16444 5
a16448 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v6k
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6k
d16454 3
a16456 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6_notm
d16460 3
a16462 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6t2
d16469 3
a16471 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v6z
d16474 3
a16476 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v6t2
d16494 7
a16500 5
 /* ARM does not really have an IT instruction, so always allow it. The opcode
    is copied from Thumb in order to allow warnings
    in -mimplicit-it=[never | arm] modes.  */
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v1
d16521 2
a16522 2
#undef ARM_VARIANT
#define ARM_VARIANT NULL
d16532 3
a16534 2
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_div
d16539 5
a16543 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_barrier
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_barrier
d16549 5
a16553 4
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v7
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v7
d16557 3
a16559 2
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_fpa_ext_v1  /* Core FPA instruction set (V1).  */
d16990 3
a16992 2
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_fpa_ext_v2
d17000 3
a17002 2
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v1xd  /* VFP V1xD (single precision).  */
d17059 3
a17061 2
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v1 /* VFP V1 (Double precision).  */
d17111 3
a17113 2
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v2
d17121 5
a17125 4
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v1xd
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_ext_v1xd
d17167 5
a17171 4
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_neon_ext_v1
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_neon_ext_v1
d17399 5
a17403 4
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_v3_or_neon_ext
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_v3_or_neon_ext
d17414 5
a17418 4
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_ext_v3
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v3
d17439 3
a17441 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_cext_xscale /* Intel XScale extensions.	 */
d17451 3
a17453 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_cext_iwmmxt /* Intel Wireless MMX technology.  */
d17617 3
a17619 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_cext_iwmmxt2 /* Intel Wireless MMX technology, version 2.  */
d17678 3
a17680 2
#undef ARM_VARIANT
#define ARM_VARIANT &arm_cext_maverick /* Cirrus Maverick instructions.	*/
d18296 1
a18296 1
  
d18331 1
a18331 1
  
d18333 1
a18333 1
  
d18990 1
a18990 1
  return 0;
d19222 2
a19223 1
int
d19234 1
a19234 1
      return 1;
d19236 1
d19238 1
a19238 1
  return 0;
d20869 1
a20869 1
    return 0;
d20873 1
a20873 1
    return 0;
d20878 1
a20878 1
    return 0;
d20890 1
a20890 1
    return 0;
d20896 1
a20896 1
    return 0;
d20907 1
a20907 1
    return 0;
d20909 1
a20909 1
  return 1;
d21780 1
a21780 1
static int
d21798 1
a21798 1
	  return 0;
d21812 1
a21812 1
	  return 0;
d21825 1
a21825 1
	  return 0;
d21831 1
a21831 1
  return 1;
d21834 1
a21834 1
static int
d21849 1
a21849 1
      return 0;
d21862 1
d21871 1
a21871 1
	return 1;
d21875 1
a21875 1
  return 0;
d21878 1
a21878 1
static int
d21893 1
a21893 1
      return 0;
d21906 1
a21906 1
	return 1;
d21910 1
a21910 1
  return 0;
d21913 1
a21913 1
static int
d21922 1
a21922 1
	return 1;
d21926 1
a21926 1
  return 0;
d21929 1
a21929 1
static int
d21938 1
a21938 1
	return 1;
d21942 1
a21942 1
  return 0;
d21946 1
a21946 1
static int
d21955 1
a21955 1
	return 1;
d21958 1
a21958 1
  return 0;
d21962 1
a21962 1
static int
d21965 1
a21965 1
  int ret = 1;
d21979 1
a21979 1
      ret = 0;
d22480 1
a22480 1
    if (strcmp (name, attribute_table[i].name) == 0)
@


1.391
log
@        PR 10168
        * config/tc-arm.c (do_t_pkhtb): Swap Rm and Rn when encoding as
        PKHBT.
        * gas/arm/thumb32.d: Fix expected disassembly of PKHTB insn.
@
text
@d17445 3
a17447 3
 cCE(torvscb,   e13f190, 1, (RR),		    iwmmxt_tandorc),
 cCE(torvsch,   e53f190, 1, (RR),		    iwmmxt_tandorc),
 cCE(torvscw,   e93f190, 1, (RR),		    iwmmxt_tandorc),
@


1.390
log
@2009-07-01  Paul Brook <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (MISSING_FNSTART): Define.
	(s_arm_unwind_fnstart): Diagnose duplicate directive.
	(s_arm_unwind_handlerdata, s_arm_unwind_fnend, s_arm_unwind_fnend,
	s_arm_unwind_cantunwind, s_arm_unwind_personalityindex,
	s_arm_unwind_personality, s_arm_unwind_save, s_arm_unwind_movsp,
	s_arm_unwind_pad, s_arm_unwind_setfp, s_arm_unwind_raw): Error if
	not inside function unwinding region.

	gas/testsuite/
	* gas/arm/fp-save.s: Add .fnstart and .fnend directives.
@
text
@d10482 10
a10491 1
    inst.instruction &= ~0x00000020;
@


1.389
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d704 1
d3160 6
d3189 3
d3209 6
d3261 2
d3272 3
d3289 3
d3318 3
d3757 3
d3817 3
d3865 3
d3894 3
d3947 3
@


1.388
log
@        * config/tc-arm.c (implicit_it_mode): New enum.
        (implicit_it_mode): New global.
        (it_instruction_type): New enum.
        (arm_parse_it_mode): New function.
        (arm_long_opts): New option added.
        (arm_it): New field.
        (it_state): New enum.
        (now_it): New macro.
        (check_it_blocks_finished): New function.
        (insns[]): Use the IT Thumb opcodes for ARM too.
        (arm_cleanup): Call check_it_blocks_finished.
        (now_it_compatible): New function.
        (conditional_insn): New function.
        (set_it_insn_type): New macro.
        (set_it_insn_type_last): New macro.
        (do_it): Call automatic IT machinery functions.
        (do_t_add_sub): Likewise
        (do_t_arit3): Likewise.
        (do_t_arit3c): Likewise.
        (do_t_blx): Likewise.
        (do_t_branch): Likewise.
        (do_t_bkpt): Likewise.
        (do_t_branch23): Likewise.
        (do_t_bx): Likewise.
        (do_t_bxj): Likewise.
        (do_t_cps): Likewise.
        (do_t_cpsi): Likewise.
        (do_t_cbz): Likewise.
        (do_t_it): Likewise.
        (encode_thumb2_ldmstm): Likewise.
        (do_t_ldst): Likewise.
        (do_t_mov_cmp): Likewise.
        (do_t_mvn_tst): Likewise.
        (do_t_mul): Likewise.
        (do_t_neg): Likewise.
        (do_t_setend): Likewise.
        (do_t_shift): Likewise.
        (do_t_tb): Likewise.
        (output_it_inst): New function.
        (new_automatic_it_block): New function.
        (close_automatic_it_block): New function.
        (now_it_add_mask): New function.
        (it_fsm_pre_encode): New function.
        (handle_it_state): New function.
        (it_fsm_post_encode): New function.
        (force_automatic_it_block_close): New function.
        (in_it_block): New function.
        (md_assemble): Call automatic IT block machinery functions.
        (arm_frob_label): Likewise.
        (arm_opts): New element.
        * config/tc-arm.h (it_state): New enum.
        (current_it): New struct.
        (arm_segment_info_type): New member added.
        * doc/c-arm.texi: New option -mimplicit-it documented.

        * gas/arm/arm-it-auto.d: New test.
        * gas/arm/arm-it-auto.s: New file.
        * gas/arm/arm-it-auto-2.d: New test case.
        * gas/arm/arm-it-auto-2.s: New file.
        * gas/arm/arm-it-auto-3.d: New test case.
        * gas/arm/arm-it-auto-3.s: New file.
        * gas/arm/arm-it-bad.d: New test case.
        * gas/arm/arm-it-bad.l: New file.
        * gas/arm/arm-it-bad.s: New file.
        * gas/arm/arm-it-bad-2.d: New test case.
        * gas/arm/arm-it-bad-2.l: New file.
        * gas/arm/arm-it-bad-2.s: New file.
        * gas/arm/arm-it-bad-3.d: New test case.
        * gas/arm/arm-it-bad-3.l: New file.
        * gas/arm/arm-it-bad-3.s: New file.
        * gas/arm/thumb2_it_auto.d: New test.
        * gas/arm/thumb2_it_bad.l: Error message updated.
        * gas/arm/thumb2_it_bad_auto.d: New test.
        * gas/arm/thumb2_it.d: Comment added.
        * gas/arm/thumb2_it_bad.d: Comment added.
@
text
@d3471 1
a3471 1
  assert (num_regs_below_16 + num_vfpv3_regs == count);
d4128 1
a4128 1
      assert (parts != 0);
d4646 1
a4646 1
      assert (inst.reloc.type != 0);
d4805 1
a4805 1
                    assert (0);
d5678 1
a5678 1
	  assert (!backtrack_pos);
d6383 1
a6383 1
  assert (inst.operands[i].isreg);
d6400 1
a6400 1
      assert (inst.operands[i].writeback);
d6494 1
a6494 1
  assert (!(inst.operands[i].preind && inst.operands[i].postind));
d6498 1
a6498 1
      assert (!inst.operands[i].writeback);
d8435 1
a8435 1
      assert (inst.operands[i].writeback);
d9141 1
a9141 1
	  assert (cond != 0xF);
d11405 1
a11405 1
  assert ((thisarg & N_EQK) != 0);
d13606 1
a13606 1
  assert (elsize != 0);
d14312 1
a14312 1
      assert (NEON_REG_STRIDE (inst.operands[0].imm) != 2);
d14528 1
a14528 1
      assert (inst.size == (2 * THUMB_SIZE));
d14533 1
a14533 1
      assert (inst.size == (2 * INSN_SIZE));
d14723 1
a14723 1
      assert (cond);
d15214 1
a15214 1
	  assert (inst.instruction < 0xe800 || inst.instruction > 0xffff);
d15225 1
a15225 1
      assert (inst.size_req == 0 || !inst.relax);
d18085 1
a18085 1
  assert ((fragP->tc_frag_data & MODE_RECORDED) != 0);
d18795 1
a18795 1
	    assert (a & 0xff000000);
d19024 1
a19024 1
  assert (fixP->fx_r_type <= BFD_RELOC_UNUSED);
d20074 1
a20074 1
     assert (!fixP->fx_done);
d20116 1
a20116 1
      assert (!fixP->fx_done);
d20155 1
a20155 1
      assert (!fixP->fx_done);
d20195 1
a20195 1
      assert (!fixP->fx_done);
a22288 2


@


1.387
log
@        PR 10169
        * gas/tc-arm.c (do_t_ssat): Move common code from here...
        (do_t_usat): ... and here to...
        (do_t_ssat_usat): New function: ... here.  Add code to check that
        the shift value, if present, is in range.

        * gas/arm/thumb2_bad_reg.s: Add tests for SSAT and USAT with an
        out of range shift.
        * gas/arm/thumb2_bad_reg.l: Update expected error messages.
@
text
@d268 10
d328 12
d362 2
d701 3
d725 1
a725 1

d744 43
a786 4
/* State variables for IT block handling.  */
static bfd_boolean current_it_mask = 0;
static int current_cc;

d1500 1
d5138 1
a5138 1
      cond[n] = TOLOWER(*q);
d5586 10
a5595 9
#define po_char_or_fail(chr) do {		\
  if (skip_past_char (&str, chr) == FAIL)	\
    goto bad_args;				\
} while (0)

#define po_reg_or_fail(regtype) do {				\
  val = arm_typed_reg_parse (&str, regtype, &rtype,		\
  			     &inst.operands[i].vectype);	\
  if (val == FAIL)						\
d5597 14
a5610 2
      first_error (_(reg_expected_msgs[regtype]));		\
      goto failure;						\
d5612 9
a5620 14
  inst.operands[i].reg = val;					\
  inst.operands[i].isreg = 1;					\
  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\
  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);		\
  inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\
                            || rtype == REG_TYPE_VFD		\
                            || rtype == REG_TYPE_NQ);		\
} while (0)

#define po_reg_or_goto(regtype, label) do {			\
  val = arm_typed_reg_parse (&str, regtype, &rtype,		\
                             &inst.operands[i].vectype);	\
  if (val == FAIL)						\
    goto label;							\
d5622 48
a5669 35
  inst.operands[i].reg = val;					\
  inst.operands[i].isreg = 1;					\
  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\
  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);		\
  inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\
                            || rtype == REG_TYPE_VFD		\
                            || rtype == REG_TYPE_NQ);		\
} while (0)

#define po_imm_or_fail(min, max, popt) do {			\
  if (parse_immediate (&str, &val, min, max, popt) == FAIL)	\
    goto failure;						\
  inst.operands[i].imm = val;					\
} while (0)

#define po_scalar_or_goto(elsz, label) do {			\
  val = parse_scalar (&str, elsz, &inst.operands[i].vectype);	\
  if (val == FAIL)						\
    goto label;							\
  inst.operands[i].reg = val;					\
  inst.operands[i].isscalar = 1;				\
} while (0)

#define po_misc_or_fail(expr) do {		\
  if (expr)					\
    goto failure;				\
} while (0)

#define po_misc_or_fail_no_backtrack(expr) do {	\
  result = expr;				\
  if (result == PARSE_OPERAND_FAIL_NO_BACKTRACK)\
    backtrack_pos = 0;				\
  if (result != PARSE_OPERAND_SUCCESS)		\
    goto failure;				\
} while (0)
d5935 1
a5935 1
	  /* Register or expression */
d5939 1
a5939 1
	  /* Register or immediate */
d5960 1
a5960 1
	  /* Two kinds of register */
d6039 1
a6039 1
	  /* Register lists */
d6211 1
a6211 1

d6213 2
a6214 2
#define constraint(expr, err) do {		\
  if (expr)					\
d6216 5
a6220 2
      inst.error = err;				\
      return;					\
d6222 1
a6222 1
} while (0)
d7054 4
a7057 1
     process it but do not generate code for it.  */
d7059 6
d8585 3
d8597 1
a8597 1
	narrow = (current_it_mask == 0);
d8599 1
a8599 1
	narrow = (current_it_mask != 0);
d8851 1
a8851 1
	    narrow = current_it_mask == 0;
d8853 1
a8853 1
	    narrow = current_it_mask != 0;
d8939 1
a8939 1
	    narrow = current_it_mask == 0;
d8941 1
a8941 1
	    narrow = current_it_mask != 0;
d9094 2
a9095 1
  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
d9117 4
a9120 1
  if (current_it_mask)
a9124 2
      /* A branch must be the last instruction in an IT block.  */
      constraint (current_it_mask != 0x10, BAD_BRANCH);
d9174 1
d9181 1
a9181 1
  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
d9202 1
a9202 1
  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
d9214 1
a9214 1
  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
d9240 1
a9240 1
  constraint (current_it_mask, BAD_NOT_IT);
d9247 1
a9247 1
  constraint (current_it_mask, BAD_NOT_IT);
d9294 1
a9294 1
  constraint (current_it_mask, BAD_NOT_IT);
d9340 3
a9342 3
  constraint (current_it_mask, BAD_NOT_IT);
  current_it_mask = (inst.instruction & 0xf) | 0x10;
  current_cc = cond;
d9377 7
a9383 3
      if (mask & (1 << 14)
	  && mask & (1 << 15))
	inst.error = _("LR and PC should not both be in register list");
d9559 5
d9784 3
d9797 1
a9797 1
      if (current_it_mask)
d9852 1
a9852 1
	  if (current_it_mask == 0 && opcode == T_MNEM_mov)
d9878 1
a9878 1
	  if (current_it_mask)
d9934 1
a9934 1
	      if (current_it_mask)
d10096 1
a10096 1
	narrow = (current_it_mask == 0);
d10098 1
a10098 1
	narrow = (current_it_mask != 0);
d10237 1
a10237 1
	narrow = (current_it_mask == 0);
d10239 1
a10239 1
	narrow = (current_it_mask != 0);
d10264 2
a10265 2
      constraint(inst.instruction != T_MNEM_mul,
		 _("Thumb-2 MUL must not set flags"));
d10305 2
d10343 1
a10343 1
	narrow = (current_it_mask == 0);
d10345 1
a10345 1
	narrow = (current_it_mask != 0);
d10569 1
a10569 1
	narrow = (current_it_mask == 0);
d10571 1
a10571 1
	narrow = (current_it_mask != 0);
d10605 1
a10605 1
  constraint (current_it_mask, BAD_NOT_IT);
d10635 1
a10635 1
	narrow = (current_it_mask == 0);
d10637 1
a10637 1
	narrow = (current_it_mask != 0);
d10936 1
a10936 1
  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
d11001 1
a11001 1
     vcge / vcgt with the operands reversed. */  	\
d14548 22
d14815 314
d15193 2
a15194 2
	      && !(ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr)
		   || ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_barrier)))
a15197 21
      /* Check conditional suffixes.  */
      if (current_it_mask)
	{
	  int cond;
	  cond = current_cc ^ ((current_it_mask >> 4) & 1) ^ 1;
	  current_it_mask <<= 1;
	  current_it_mask &= 0x1f;
	  /* The BKPT instruction is unconditional even in an IT block.  */
	  if (!inst.error
	      && cond != inst.cond && opcode->tencode != do_t_bkpt)
	    {
	      as_bad (_("incorrect condition in IT block"));
	      return;
	    }
	}
      else if (inst.cond != COND_ALWAYS && opcode->tencode != do_t_branch)
	{
	  as_bad (_("thumb conditional instruction not in IT block"));
	  return;
	}

d15202 4
a15205 1
	opcode->tencode ();
d15207 4
a15210 3
      /* Clear current_it_mask at the end of an IT block.  */
      if (current_it_mask == 0x10)
	current_it_mask = 0;
d15235 2
a15236 2
	  && !(ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr)
	       || ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_barrier)))
d15269 5
a15273 1
	opcode->aencode ();
d15291 19
d15329 2
d15696 1
a15696 1
       TxCE(mnem, aop, 0x##top, nops, ops, ae, te)
d15698 1
a15698 1
       TxCE(mnem, aop, T_MNEM_##top, nops, ops, ae, te)
d15709 1
a15709 1
       TxC3(mnem, aop, 0x##top, nops, ops, ae, te)
d15711 1
a15711 1
       TxC3w(mnem, aop, 0x##top, nops, ops, ae, te)
d15713 1
a15713 1
       TxC3(mnem, aop, T_MNEM_##top, nops, ops, ae, te)
d15715 1
a15715 1
       TxC3w(mnem, aop, T_MNEM_##top, nops, ops, ae, te)
d15720 1
a15720 1
  { #m1 #m2 #m3, OPS##nops ops, sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \
d15724 19
a15742 19
  TxCM_(m1,   , m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, eq, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ne, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, cs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, hs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, cc, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ul, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, lo, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, mi, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, pl, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, vs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, vc, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, hi, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ls, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ge, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, lt, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, gt, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, le, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, al, m2, op, top, nops, ops, ae, te)
d15745 3
a15747 3
       TxCM(m1,m2, aop, 0x##top, nops, ops, ae, te)
#define tCM(m1,m2, aop, top, nops, ops, ae, te)			\
       TxCM(m1,m2, aop, T_MNEM_##top, nops, ops, ae, te)
d15794 1
a15794 1
    sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \
d15798 19
a15816 19
  xCM_(m1,   , m2, op, nops, ops, ae),	\
  xCM_(m1, eq, m2, op, nops, ops, ae),	\
  xCM_(m1, ne, m2, op, nops, ops, ae),	\
  xCM_(m1, cs, m2, op, nops, ops, ae),	\
  xCM_(m1, hs, m2, op, nops, ops, ae),	\
  xCM_(m1, cc, m2, op, nops, ops, ae),	\
  xCM_(m1, ul, m2, op, nops, ops, ae),	\
  xCM_(m1, lo, m2, op, nops, ops, ae),	\
  xCM_(m1, mi, m2, op, nops, ops, ae),	\
  xCM_(m1, pl, m2, op, nops, ops, ae),	\
  xCM_(m1, vs, m2, op, nops, ops, ae),	\
  xCM_(m1, vc, m2, op, nops, ops, ae),	\
  xCM_(m1, hi, m2, op, nops, ops, ae),	\
  xCM_(m1, ls, m2, op, nops, ops, ae),	\
  xCM_(m1, ge, m2, op, nops, ops, ae),	\
  xCM_(m1, lt, m2, op, nops, ops, ae),	\
  xCM_(m1, gt, m2, op, nops, ops, ae),	\
  xCM_(m1, le, m2, op, nops, ops, ae),	\
  xCM_(m1, al, m2, op, nops, ops, ae)
d15844 1
a15844 1
  NCE_tag(mnem, op, nops, ops, enc, OT_csuffix)
d15847 1
a15847 1
  NCE_tag(mnem, op, nops, ops, enc, OT_csuffixF)
d15855 1
a15855 1
  nCE_tag(mnem, op, nops, ops, enc, OT_csuffix)
d15858 1
a15858 1
  nCE_tag(mnem, op, nops, ops, enc, OT_csuffixF)
d15863 1
a15863 1
#define UT(mnem,  op, nops, ops, te) TUE(mnem,  0, op, nops, ops, 0, te)
d16285 3
a16287 1
 /* ARM does not really have an IT instruction, so always allow it.  */
d16290 15
a16304 15
 TUE(it,        0,        bf08,     1, (COND),   it,    t_it),
 TUE(itt,       0,        bf0c,     1, (COND),   it,    t_it),
 TUE(ite,       0,        bf04,     1, (COND),   it,    t_it),
 TUE(ittt,      0,        bf0e,     1, (COND),   it,    t_it),
 TUE(itet,      0,        bf06,     1, (COND),   it,    t_it),
 TUE(itte,      0,        bf0a,     1, (COND),   it,    t_it),
 TUE(itee,      0,        bf02,     1, (COND),   it,    t_it),
 TUE(itttt,     0,        bf0f,     1, (COND),   it,    t_it),
 TUE(itett,     0,        bf07,     1, (COND),   it,    t_it),
 TUE(ittet,     0,        bf0b,     1, (COND),   it,    t_it),
 TUE(iteet,     0,        bf03,     1, (COND),   it,    t_it),
 TUE(ittte,     0,        bf0d,     1, (COND),   it,    t_it),
 TUE(itete,     0,        bf05,     1, (COND),   it,    t_it),
 TUE(ittee,     0,        bf09,     1, (COND),   it,    t_it),
 TUE(iteee,     0,        bf01,     1, (COND),   it,    t_it),
a20714 4
/* A good place to do this, although this was probably not intended
   for this kind of use.  We need to dump the literal pool before
   references are made to a null symbol pointer.  */

d20720 3
d21395 1
a21395 1
  {"cortex-a8",		ARM_ARCH_V7A,	 ARM_FEATURE(0, FPU_VFP_V3
d21398 1
a21398 1
  {"cortex-a9",		ARM_ARCH_V7A,	 ARM_FEATURE(0, FPU_VFP_V3
d21412 1
a21412 1
  {"ep9312",	ARM_FEATURE(ARM_AEXT_V4T, ARM_CEXT_MAVERICK), FPU_ARCH_MAVERICK, "ARM920T"},
d21732 23
d21769 2
@


1.386
log
@        PR 10186
        * arm-dis.c (thumb32_opcodes): Fix binary value of SEV.W
        instruction.

        * gas/arm/thumb32.d: Fix expected binary value of SEV.W instruction.

        * config/tc-arm.c (T16_32_TAB): Fix binary value of SEV.W
        instruction.
@
text
@d10657 1
a10657 1
do_t_ssat (void)
d10668 1
a10668 1
  inst.instruction |= inst.operands[1].imm - 1;
d10673 4
d10680 1
a10680 1
      if (inst.reloc.exp.X_add_number != 0)
d10682 3
d10686 4
a10689 3
	    inst.instruction |= 0x00200000;  /* sh bit */
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x1c) << 10;
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x03) << 6;
a10690 1
      inst.reloc.type = BFD_RELOC_UNUSED;
d10693 6
d10834 1
a10834 26
  unsigned Rd, Rn;

  Rd = inst.operands[0].reg;
  Rn = inst.operands[2].reg;

  reject_bad_reg (Rd);
  reject_bad_reg (Rn);

  inst.instruction |= Rd << 8;
  inst.instruction |= inst.operands[1].imm;
  inst.instruction |= Rn << 16;

  if (inst.operands[3].present)
    {
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
      if (inst.reloc.exp.X_add_number != 0)
	{
	  if (inst.operands[3].shift_kind == SHIFT_ASR)
	    inst.instruction |= 0x00200000;  /* sh bit */

	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x1c) << 10;
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x03) << 6;
	}
      inst.reloc.type = BFD_RELOC_UNUSED;
    }
@


1.385
log
@    * config/tc-arm.c: Move as.h to start of file.
@
text
@d8432 1
a8432 1
  X(sev,   bf40, f3af9004), /* typo, 8004? */
@


1.384
log
@Fix local branches for bl and blx.
@
text
@d28 1
a31 1
#include "as.h"
@


1.383
log
@	* config/tc-armlinux-eabi.h (FPU_DEFAULT): Default to plain VFP.
	* config/tc-armeabi.h (FPU_DEFAULT): Likewise.
	* config/tc-arm.c (md_begin): If FPU_DEFAULT is set, don't infer
	the default FPU from the processor.
testsuite/
	* gas/arm/attr-mcpu.d: Add -mfpu=neon.
	* gas/arm/mapmisc.d: Correct expected output for .double and
	.dcb.d.
@
text
@d6738 1
a6738 1
      inst.reloc.type	= BFD_RELOC_ARM_PLT32;
d6797 3
a6799 1
	 conditionally, and the opcode must be adjusted.  */
d6802 1
a6802 6
#ifdef OBJ_ELF
      if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
	encode_branch (BFD_RELOC_ARM_PCREL_CALL);
      else
#endif
	encode_branch (BFD_RELOC_ARM_PCREL_BLX);
d17461 6
d18191 1
a18212 1
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
d18216 7
d18225 5
a18229 1
    case BFD_RELOC_THUMB_PCREL_BLX:
d18234 14
a18248 1
    case BFD_RELOC_ARM_PCREL_CALL:
a18249 1
    case BFD_RELOC_ARM_PCREL_BLX:
d18268 1
d19012 16
a19027 3
      newval = md_chars_to_number (buf, INSN_SIZE);
      if ((newval & 0xf0000000) == 0xf0000000)
	temp = 1;
d19033 14
d19054 1
d19056 22
d19164 10
d19199 25
d19225 25
d20102 1
d20111 28
d20619 1
a20619 1
	      
d21777 33
d21811 2
@


1.382
log
@	gas/
	* config/tc-arm.c (do_t_blx): Always use BFD_RELOC_THUMB_PCREL_BLX.
	(md_pcrel_from_section): Align address for BLX.
	(tc_gen_reloc): Change BFD_RELOC_THUMB_PCREL_BLX relocations to
	BFD_RELOC_THUMB_PCREL_BRANCH23 for EABI v4+.
@
text
@d20277 2
a20278 1
#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined (TE_VXWORKS))
@


1.381
log
@        * config/tc-arm.c (arm_cpus): Add entry for ARM Cortex-M0.
        * doc/c-arm.texi: Added codes for processors ARM Cortex-M0 and
        Cortex-M1.
@
text
@d9005 1
a9005 6
#ifdef OBJ_ELF
      if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH23;
      else
#endif
	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BLX;
d18211 4
d18216 1
a18216 1
      return base + 4;
a19738 1
    case BFD_RELOC_THUMB_PCREL_BLX:
d19747 9
@


1.380
log
@2009-04-01  Ramana Radhakrishnan  <ramana.radhakrishnan@@arm.com>

	* config/tc-arm.c (arm_validate_fix): Define only for OBJ_COFF.
	(find_real_start): Likewise.
	* config/tc-arm.h (TC_VALIDATE_FIX): Likewise
@
text
@d20777 1
@


1.379
log
@	* config/tc-arm.c (do_nop): Generate v6k nops whenever possible.
	(arm_handle_align): Generate v6k ARM, thumb2 wide & narrow nops
	whenever possible.

	testsuite/
	* gas/arm/align.s, gas/arm/align.d: New.
	* gas/arm/thumb32.d, gas/arm/arch6zk.d, gas/arm/arch6zk.s,
	arm/thumb2_relax.d: Adjust for align changes.
@
text
@d2420 1
d2453 1
d9087 1
d9098 1
d19940 1
a19940 1
#if defined OBJ_COFF || defined OBJ_ELF
@


1.378
log
@2009-03-18  Andrew Stubbs  <ams@@codesourcery.com>

	gas/
	* config/tc-arm.c (md_apply_fix): Check BFD_RELOC_ARM_IMMEDIATE and
	BFD_RELOC_ARM_ADRL_IMMEDIATE value is in the correct section.
	Check BFD_RELOC_ARM_ADRL_IMMEDIATE has a defined symbol.

	gas/testsuites/
	* gas/arm/adr-invalid.d: New file.
	* gas/arm/adr-invalid.l: New file.
	* gas/arm/adr-invalid.s: New file.
@
text
@d7319 2
a7320 1
  if (inst.operands[0].present)
d7324 3
a7326 1
      inst.instruction |= 0x0320f000 + inst.operands[0].imm;
d17586 29
a17614 6
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };

  int bytes, fix, noop_size;
d17617 1
d17633 5
a17637 2
      if (target_big_endian)
	noop = thumb_bigend_noop;
d17639 2
a17640 2
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
d17644 3
a17646 5
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
d17648 3
a17650 1

d17659 15
a17682 1
  fragP->fr_var = noop_size;
@


1.377
log
@	* config/tc-arm.c (md_assemble): Allow barrier instructions on
	ARMv6-M cores.

	* gas/arm/archv6m.s: Add dmb, dsb, and isb.
	* gas/arm/archv6m.d: Likewise.
@
text
@d18540 9
d18572 18
@


1.376
log
@	* config/tc-arm.c (warn_deprecated_sp): New macro.
	(do_t_mov_cmp): Permit R13 as the second
	argument to "cmp.n".

	* gas/arm/thumb2_bad_reg.s: Update to allow R13 as second argument
	for CMP.
	* gas/arm/thumb2_bad_reg.l: Adjust accordingly.
@
text
@d14750 2
a14751 1
	      && !ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr))
d14809 2
a14810 1
	  && !ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr))
@


1.375
log
@        PR 9814
        * config/tc-arm.c (MODE_RECORDED): New define.
        (output_inst): Record the thumb_mode in the current frag.
        (arm_handle_align): Ignore the MODE_RECORDED bit in tc_frag_data.
        (arm_init_frag): Only set the tc_frag_data field if it has not
        already been set.
@
text
@d6143 8
d9701 12
a9712 1
	  reject_bad_reg (Rm);
@


1.374
log
@gas:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* config/tc-arm.c (BAD_SP): Define.
	(s_arm_unwind_fnstart): Use REG_SP.
	(s_arm_unwind_setfp): Likewise.
	(reject_bad_reg): New macro.
	(do_co_reg): Check for bad registers.
	(do_co_reg2c): Likewise.
	(do_srs): Use REG_SP.
	(do_t_add_sub): Check for bad registers.
	(do_t_adr): Likewise.
	(do_t_arit3): Likewise.
	(do_t_arit3c): Likewise.
	(do_t_bfc): Likewise.
	(do_t_bfi): Likewise.
	(do_t_bfx): Likewise.
	(do_t_blx): Likewise.
	(do_t_bx): Likewise.
	(do_t_bxj): Likewise.
	(do_t_clz): Likewise.
	(do_t_div): Likewise.
	(do_t_mla): Likewise.
	(do_t_mlal): Likewise.
	(do_t_mov_cmp): Likewise.
	(do_t_mov16): Likewise.
	(do_t_mvn_tst): Likewise.
	(do_t_mrs): Likewise.
	(do_t_msr): Likewise.
	(do_t_mul): Likewise.
	(do_t_mull): Likewise.
	(do_t_orn): Likewise.
	(do_t_pkhbt): Likewise.
	(do_t_pld): Likewise.
	(do_t_rbit): Likewise.
	(do_t_rev): Likewise.
	(do_t_rrx): Likewise.
	(do_t_rsb): Likewise.
	(do_t_shift): Likewise.
	(do_t_simd): Likewise.
	(do_t_ssat): Likewise.
	(do_t_ssat16): Likewise.
	(do_t_sxtah): Likewise.
	(do_t_sxth): Likewise.
	(do_t_tb): Likewise.
	(do_t_usat): Likewise.
	(do_t_usat16): Likewise.
	(nysn_insert_sp): Use REG_SP.

gas/testsuite:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* gas/arm/copro.s: Avoid using r15 where not permitted.
	* gas/arm/copro.d: Adjust accordingly.
	* gas/arm/thumb2_bad_reg.s: New.
	* gas/arm/thumb2_bad_reg.l: Likewise.
	* gas/arm/thumb2_bad_reg.d: Likewise.
@
text
@d263 4
d14394 5
d17581 3
a17583 1
  if (fragP->tc_frag_data)
d17643 5
a17647 1
/* Perform target specific initialisation of a frag.  */
d17652 4
a17655 2
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
@


1.373
log
@gas:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* config/tc-arm.c (do_t_orn): New function.
	(do_t_rrx): Likewise.
	(insns): Add orn and rrx.

gas/testsuite:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* gas/arm/thumb32.s: Add tests for orn and rrx.
	* gas/arm/thumb32.d: Adjust accordingly.
	* gas/arm/thumb32.l: Likewise.
	* gas/arm/thumb2_invert.s: Add tests for orn and orr.
	* gas/arm/thumb2_invert.d: Adjust accordingly.
	* gas/arm/tcompat.s: Add tests for rrx.
	* gas/arm/tcompat.d: Adjust accordingly.
@
text
@d663 1
d3096 1
a3096 1
  unwind.fp_reg = 13;
d3809 1
a3809 1
  if (sp_reg != 13 && sp_reg != unwind.fp_reg)
d3819 1
a3819 1
  if (sp_reg == 13)
d6127 12
d6863 21
d6886 1
a6886 1
  inst.instruction |= inst.operands[2].reg << 12;
d6908 16
d6926 2
a6927 2
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
d7557 1
a7557 1
      constraint (reg != 13, _("SRS base register must be r13"));
d7560 1
a7560 1
    reg = 13;
d8450 4
a8453 1
  constraint (Rd == 15, _("PC not allowed as destination"));
d8487 2
d8525 1
d8598 6
d8662 6
a8667 1
  if (unified_syntax && inst.size_req == 0 && inst.operands[0].reg <= 7)
d8672 1
a8672 1
      inst.instruction |= inst.operands[0].reg << 4;
d8678 1
a8678 1
      inst.instruction |= inst.operands[0].reg << 8;
d8690 1
a8690 1
      inst.instruction |= inst.operands[0].reg << 4;
d8711 5
d8798 5
d8901 1
d8906 3
a8908 1
  inst.instruction |= inst.operands[0].reg << 8;
d8917 1
d8920 3
d8926 6
a8931 1
    inst.operands[1].reg = REG_PC;
d8937 2
a8938 2
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
d8947 8
d8957 2
a8958 2
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
d8979 5
a8983 2
    /* We have a register, so this is BLX(2).  */
    inst.instruction |= inst.operands[0].reg << 3;
d9095 2
d9098 3
a9100 4
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  inst.instruction |= inst.operands[0].reg << 16;
d9106 12
a9117 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
d9193 14
a9206 5
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
d9611 16
a9626 4
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 12;
d9632 16
a9647 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
d9653 5
d9666 1
a9666 1
      low_regs = (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7);
d9679 2
a9680 2
	  && inst.operands[0].reg == REG_PC
	  && inst.operands[1].reg == REG_LR)
d9686 23
d9717 1
a9717 1
	      inst.instruction |= inst.operands[0].reg << 8;
d9727 1
a9727 1
	      inst.instruction |= inst.operands[0].reg << r0off;
d9749 1
a9749 1
	  if (inst.operands[0].reg != inst.operands[1].reg)
d9773 1
a9773 1
	      inst.instruction |= inst.operands[0].reg;
d9781 2
a9782 2
	      inst.instruction |= inst.operands[0].reg << 8;
	      inst.instruction |= inst.operands[1].reg << 16;
d9813 2
a9814 2
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
d9820 1
a9820 1
	      inst.instruction |= inst.operands[0].reg << r0off;
d9829 3
a9831 3
	    inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
	    inst.instruction |= (inst.operands[0].reg & 0x7);
	    inst.instruction |= inst.operands[1].reg << 3;
d9838 2
a9839 2
	    inst.instruction |= inst.operands[0].reg;
	    inst.instruction |= inst.operands[1].reg << 3;
d9846 2
a9847 2
		inst.instruction |= inst.operands[0].reg;
		inst.instruction |= inst.operands[1].reg << 3;
d9852 3
a9854 3
		inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
		inst.instruction |= (inst.operands[0].reg & 0x7);
		inst.instruction |= inst.operands[1].reg << 3;
d9864 1
a9864 1
      if (inst.operands[0].reg < 8 && inst.operands[1].reg < 8)
d9873 2
a9874 2
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
d9887 1
a9887 1
      constraint (inst.operands[0].reg > 7,
d9889 1
a9889 1
      inst.instruction |= inst.operands[0].reg << 8;
d9897 1
d9913 4
a9916 1
  inst.instruction |= inst.operands[0].reg << 8;
d9930 12
d9951 1
a9951 1
	  || inst.operands[0].reg > 7 || inst.operands[1].reg > 7)
d9967 1
a9967 1
	  inst.instruction |= inst.operands[0].reg << r0off;
d9976 2
a9977 2
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
d9986 1
a9986 1
	      inst.instruction |= inst.operands[0].reg << r0off;
d9997 1
a9997 1
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
d10001 2
a10002 2
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
d10009 1
d10032 4
a10035 1
  inst.instruction |= inst.operands[0].reg << 8;
d10044 1
d10065 4
d10072 1
a10072 1
  inst.instruction |= inst.operands[1].reg << 16;
d10079 1
d10084 4
d10091 4
a10094 4
	  || (inst.operands[0].reg != inst.operands[1].reg
	      && inst.operands[0].reg != inst.operands[2].reg)
	  || inst.operands[1].reg > 7
	  || inst.operands[2].reg > 7)
d10104 1
a10104 1
      constraint (inst.operands[1].reg > 7 || inst.operands[2].reg > 7,
d10113 1
a10113 1
      inst.instruction |= inst.operands[0].reg;
d10115 4
a10118 4
      if (inst.operands[0].reg == inst.operands[1].reg)
	inst.instruction |= inst.operands[2].reg << 3;
      else if (inst.operands[0].reg == inst.operands[2].reg)
	inst.instruction |= inst.operands[1].reg << 3;
d10128 7
a10134 3
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg << 0;
d10141 16
a10156 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
d10158 1
a10158 1
  if (inst.operands[0].reg == inst.operands[1].reg)
d10242 4
d10259 1
d10271 13
a10283 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
d10305 3
d10348 11
a10358 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
d10364 9
a10372 1
  if (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7
d10376 2
a10377 2
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
d10382 3
a10384 3
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[1].reg;
d10398 3
d10408 1
a10408 1
  int Rd, Rs;
d10415 5
d10507 3
d10514 1
d10607 13
a10619 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
d10637 9
a10645 1
  inst.instruction |= inst.operands[0].reg << 8;
d10647 1
a10647 1
  inst.instruction |= inst.operands[2].reg << 16;
d10668 9
a10676 1
  inst.instruction |= inst.operands[0].reg << 8;
d10678 1
a10678 1
  inst.instruction |= inst.operands[2].reg << 16;
d10717 13
a10729 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
d10736 8
d10745 1
a10745 1
      && inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7
d10749 2
a10750 2
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
d10756 2
a10757 2
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg;
d10777 1
d10784 7
a10790 2
  constraint (inst.operands[0].imm == 15,
	      _("PC is not a valid index register"));
d10793 1
a10793 1
  inst.instruction |= (inst.operands[0].reg << 16) | inst.operands[0].imm;
d10799 9
a10807 1
  inst.instruction |= inst.operands[0].reg << 8;
d10809 1
a10809 1
  inst.instruction |= inst.operands[2].reg << 16;
d10830 9
a10838 1
  inst.instruction |= inst.operands[0].reg << 8;
d10840 1
a10840 1
  inst.instruction |= inst.operands[2].reg << 16;
d11882 1
a11882 1
  inst.operands[0].reg = 13;
@


1.372
log
@gas:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* config/tc-arm.c (insns): Add qasx, qsax, shasx, shsax, ssax,
	uasx, uhasx, uhsx, uqasx, uqsax, usax.

gas/testsuite:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* gas/arm/thumb32.s (qadd): Add tests for them.
	* gas/arm/thumb32.d: Adjust accordingly.
@
text
@d10018 29
d10140 12
d15478 18
a15495 15
 TUE(it,        0, bf08, 1, (COND),    it, t_it),
 TUE(itt,       0, bf0c, 1, (COND),    it, t_it),
 TUE(ite,       0, bf04, 1, (COND),    it, t_it),
 TUE(ittt,      0, bf0e, 1, (COND),    it, t_it),
 TUE(itet,      0, bf06, 1, (COND),    it, t_it),
 TUE(itte,      0, bf0a, 1, (COND),    it, t_it),
 TUE(itee,      0, bf02, 1, (COND),    it, t_it),
 TUE(itttt,     0, bf0f, 1, (COND),    it, t_it),
 TUE(itett,     0, bf07, 1, (COND),    it, t_it),
 TUE(ittet,     0, bf0b, 1, (COND),    it, t_it),
 TUE(iteet,     0, bf03, 1, (COND),    it, t_it),
 TUE(ittte,     0, bf0d, 1, (COND),    it, t_it),
 TUE(itete,     0, bf05, 1, (COND),    it, t_it),
 TUE(ittee,     0, bf09, 1, (COND),    it, t_it),
 TUE(iteee,     0, bf01, 1, (COND),    it, t_it),
d15503 2
@


1.371
log
@gas:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* config/tc-arm.c (insns): Correct encoding of qadd, qdadd, qsub,
	qdsub in Thumb-2 mode.

gas/testsuite:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* gas/arm/thumb32.s (qadd): Add qadd, qdadd, qsub, and qdsub.
	* gas/arm/thumb32.d: Likewise.

opcodes:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* arm-dis.c (thumb32_opcodes): Correct decoding for qadd, qdadd,
	qsub, and qdsub.
@
text
@d15286 2
d15289 3
a15293 1
 TCE(qsubaddx,	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d15296 2
d15301 2
d15304 3
d15309 3
a15311 1
 TCE(shsubaddx, 6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
a15313 1
 TCE(ssubaddx,	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d15316 2
d15321 2
d15324 3
a15328 1
 TCE(uhsubaddx, 6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d15331 2
d15334 3
a15338 1
 TCE(uqsubaddx, 6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
d15340 3
a15343 1
 TCE(usubaddx,	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
@


1.370
log
@gas:
2009-01-29  Paul Brook  <paul@@codesourcery.com>
            Mark Mitchell  <mark@@codesourcery.com>

	* config/tc-arm.c (do_t_mul): In Thumb-2 mode, use 16-bit encoding
	of MUL when possible.

gas/testsuite:
2009-01-29  Paul Brook  <paul@@codesourcery.com>
            Mark Mitchell  <mark@@codesourcery.com>

	* gas/arm/thumb2_mul.s: New file.
	* gas/arm/thumb2_mul.d: Likewise.
	* gas/arm/thumb2_mul-bad.s: Likewise.
	* gas/arm/thumb2_mul-bad.d: Likewise.
	* gas/arm/thumb2_mul-bad.l: Likewise.
	* gas/arm/t16-bad.s: Add tests for"mul" with high registers.
	* gas/arm/t16-bad.l: Update accordingly.
@
text
@d15235 4
a15238 4
 TCE(qadd,	1000050, fa80f080, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qdadd,	1400050, fa80f090, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qsub,	1200050, fa80f0a0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qdsub,	1600050, fa80f0b0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
@


1.369
log
@2009-01-26  Andrew Stubbs  <ams@@codesourcery.com>

	gas/
	* config/tc-arm.c (attributes_set_explicitly): New array.
	(s_arm_eabi_attribute): Check return value from s_vendor_attribute.
	(cpu_arch): Add ARM_ARCH_V5T.
	(aeabi_set_attribute_int): New function.
	(aeabi_set_attribute_string): New function.
	(aeabi_set_public_attributes): Set attributes according to the user's
	intentions, rather than the actual state of the binary.
	Use aeabi_set_attribute_int and aeabi_set_attribute_string instead of
	bfd_elf_add_proc_attr_int and bfd_elf_add_proc_attr_string.
	Support WMMXv2. Use attribute names instead of numbers.
	* read.c (s_vendor_attribute): Change return type to int.
	Return the tag number that was set.
	* read.h (s_vendor_attribute): Change return type to int.

	gas/testsuite/
	* gas/arm/attr-cpu-directive.d: New file.
	* gas/arm/attr-cpu-directive.s: New file.
	* gas/arm/attr-default.d: New file.
	* gas/arm/attr-march-all.d: New file.
	* gas/arm/attr-march-armv1.d: New file.
	* gas/arm/attr-march-armv2.d: New file.
	* gas/arm/attr-march-armv2a.d: New file.
	* gas/arm/attr-march-armv2s.d: New file.
	* gas/arm/attr-march-armv3.d: New file.
	* gas/arm/attr-march-armv3m.d: New file.
	* gas/arm/attr-march-armv4.d: New file.
	* gas/arm/attr-march-armv4t.d: New file.
	* gas/arm/attr-march-armv4txm.d: New file.
	* gas/arm/attr-march-armv4xm.d: New file.
	* gas/arm/attr-march-armv5.d: New file.
	* gas/arm/attr-march-armv5t.d: New file.
	* gas/arm/attr-march-armv5te.d: New file.
	* gas/arm/attr-march-armv5tej.d: New file.
	* gas/arm/attr-march-armv5texp.d: New file.
	* gas/arm/attr-march-armv5txm.d: New file.
	* gas/arm/attr-march-armv6-m.d: New file.
	* gas/arm/attr-march-armv6.d: New file.
	* gas/arm/attr-march-armv6j.d: New file.
	* gas/arm/attr-march-armv6k.d: New file.
	* gas/arm/attr-march-armv6kt2.d: New file.
	* gas/arm/attr-march-armv6t2.d: New file.
	* gas/arm/attr-march-armv6z.d: New file.
	* gas/arm/attr-march-armv6zk.d: New file.
	* gas/arm/attr-march-armv6zkt2.d: New file.
	* gas/arm/attr-march-armv6zt2.d: New file.
	* gas/arm/attr-march-armv7-a.d: New file.
	* gas/arm/attr-march-armv7-m.d: New file.
	* gas/arm/attr-march-armv7-r.d: New file.
	* gas/arm/attr-march-armv7.d: New file.
	* gas/arm/attr-march-armv7a.d: New file.
	* gas/arm/attr-march-armv7m.d: New file.
	* gas/arm/attr-march-armv7r.d: New file.
	* gas/arm/attr-march-iwmmxt.d: New file.
	* gas/arm/attr-march-iwmmxt2.d: New file.
	* gas/arm/attr-march-xscale.d: New file.
	* gas/arm/attr-mcpu.d: New file.
	* gas/arm/attr-mfpu-arm1020e.d: New file.
	* gas/arm/attr-mfpu-arm1020t.d: New file.
	* gas/arm/attr-mfpu-arm1136jf-s.d: New file.
	* gas/arm/attr-mfpu-arm1136jfs.d: New file.
	* gas/arm/attr-mfpu-arm7500fe.d: New file.
	* gas/arm/attr-mfpu-fpa.d: New file.
	* gas/arm/attr-mfpu-fpa10.d: New file.
	* gas/arm/attr-mfpu-fpa11.d: New file.
	* gas/arm/attr-mfpu-fpe.d: New file.
	* gas/arm/attr-mfpu-fpe2.d: New file.
	* gas/arm/attr-mfpu-fpe3.d: New file.
	* gas/arm/attr-mfpu-maverick.d: New file.
	* gas/arm/attr-mfpu-neon-fp16.d: New file.
	* gas/arm/attr-mfpu-neon.d: New file.
	* gas/arm/attr-mfpu-softfpa.d: New file.
	* gas/arm/attr-mfpu-softvfp+vfp.d: New file.
	* gas/arm/attr-mfpu-softvfp.d: New file.
	* gas/arm/attr-mfpu-vfp.d: New file.
	* gas/arm/attr-mfpu-vfp10-r0.d: New file.
	* gas/arm/attr-mfpu-vfp10.d: New file.
	* gas/arm/attr-mfpu-vfp3.d: New file.
	* gas/arm/attr-mfpu-vfp9.d: New file.
	* gas/arm/attr-mfpu-vfpv2.d: New file.
	* gas/arm/attr-mfpu-vfpv3-d16.d: New file.
	* gas/arm/attr-mfpu-vfpv3.d: New file.
	* gas/arm/attr-mfpu-vfpxd.d: New file.
	* gas/arm/attr-order.d: Update Tag_ARM_ISA_use and Tag_THUMB_ISA_use.
	* gas/arm/attr-override-cpu-directive.d: New file.
	* gas/arm/attr-override-cpu-directive.s: New file.
	* gas/arm/attr-override-mcpu.d: New file.
	* gas/arm/attr-override-mcpu.s: New file.
	* gas/arm/blank.s: New file.
	* gas/arm/eabi_attr_1.d: Update Tag_ARM_ISA_use and Tag_THUMB_ISA_use.

	ld/testsuite/
	* ld-arm/attr-merge-3.attr: Update following gas change.
	* ld-arm/attr-merge-2.attr: Update Tag_ARM_ISA_use and
	Tag_THUMB_ISA_use following gas changes.
	* ld-arm/attr-merge-4.attr: Likewise.
	* ld-arm/attr-merge-5.attr: Likewise.
	* ld-arm/attr-merge-arch-1.attr: Likewise.
	* ld-arm/attr-merge-arch-2.attr: Likewise.
	* ld-arm/attr-merge-unknown-2.d: Likewise.
	* ld-arm/attr-merge-unknown-2r.d: Likewise.
	* ld-arm/attr-merge-unknown-3.d: Likewise.
	* ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-00.d: Likewise.
	* ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-02.d: Likewise.
	* ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-04.d: Likewise.
	* ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-20.d: Likewise.
	* ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-22.d: Likewise.
	* ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-40.d: Likewise.
	* ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-44.d: Likewise.
	* ld-arm/attr-merge.attr: Likewise.
@
text
@d9882 2
d9887 1
a9887 2
  /* There is no 32-bit MULS and no 16-bit MUL. */
  if (unified_syntax && inst.instruction == T_MNEM_mul)
d9889 10
a9898 4
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg << 0;
d9902 2
a9903 3
      constraint (!unified_syntax
		  && inst.instruction == T_MNEM_muls, BAD_THUMB32);
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
d9905 2
d9908 3
d9921 10
@


1.368
log
@	* doc/c-arm.texi (): Document -mwarn-deprecated.
	* config/tc-arm.c (WARN_DEPRECATED): Remove.  Replace with ...
	(warn_on_deprecated): ... this.
	(opcode_lookup, md_assemble): Check it before warning.
	(arm_opts): Add m[no-]warn-deprecated.
	(md_parse_option): Replace WARN_DEPRECATED with
	warn_on_deprecated.
@
text
@d244 2
d3889 4
a3892 1
  s_vendor_attribute (OBJ_ATTR_PROC);
d20724 1
d20738 19
d20803 1
a20803 1
      bfd_elf_add_proc_attr_string (stdoutput, 5, p);
d20806 1
a20806 1
  bfd_elf_add_proc_attr_int (stdoutput, 6, arch);
d20809 1
a20809 1
    bfd_elf_add_proc_attr_int (stdoutput, 7, 'A');
d20811 1
a20811 1
    bfd_elf_add_proc_attr_int (stdoutput, 7, 'R');
d20813 1
a20813 1
    bfd_elf_add_proc_attr_int (stdoutput, 7, 'M');
d20815 3
a20817 2
  if (ARM_CPU_HAS_FEATURE (arm_arch_used, arm_arch_full))
    bfd_elf_add_proc_attr_int (stdoutput, 8, 1);
d20819 4
a20822 3
  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, arm_arch_full))
    bfd_elf_add_proc_attr_int (stdoutput, 9,
	ARM_CPU_HAS_FEATURE (thumb_arch_used, arm_arch_t2) ? 2 : 1);
d20824 9
a20832 14
  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_d32)
      || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_d32))
    bfd_elf_add_proc_attr_int (stdoutput, 10, 4);
  else if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v3)
      || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_v3))
    bfd_elf_add_proc_attr_int (stdoutput, 10, 3);
  else if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v2)
           || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_v2))
    bfd_elf_add_proc_attr_int (stdoutput, 10, 2);
  else if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v1)
           || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_v1)
           || ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v1xd)
           || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_v1xd))
    bfd_elf_add_proc_attr_int (stdoutput, 10, 1);
d20834 5
a20838 4
  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, arm_cext_iwmmxt)
      || ARM_CPU_HAS_FEATURE (arm_arch_used, arm_cext_iwmmxt))
    bfd_elf_add_proc_attr_int (stdoutput, 11, 1);
  /* Tag_NEON_arch.  */
d20840 2
a20841 2
    bfd_elf_add_proc_attr_int (stdoutput, 12, 1);
  /* Tag_NEON_FP16_arch.  */
d20843 1
a20843 1
    bfd_elf_add_proc_attr_int (stdoutput, 36, 1);
@


1.367
log
@* gas/arm/attr-syntax.d: Do not run for non-ELF based ARM targets.
        * config/tc-arm.h (CONVERT_SYMBOLIC_ATTRIBUTE): Only define for
        ELF format ARM targets.
        * config/tc-arm.c (arm_convert_symbolic_attribute): Likewise.
@
text
@a44 2
#define WARN_DEPRECATED 1

d145 3
d14166 1
a14166 1
      if (unified_syntax)
d14250 1
a14250 1
      if (unified_syntax
d14291 1
a14291 1
  if (opcode->tag == OT_cinfix3_deprecated)
d19906 2
d20005 4
a20619 1
#if WARN_DEPRECATED
d20621 1
a20621 1
	      if (opt->deprecated != NULL)
a20623 1
#endif
a20637 1
#if WARN_DEPRECATED
d20639 1
a20639 1
	      if (fopt->deprecated != NULL)
a20641 1
#endif
a20657 1
#if WARN_DEPRECATED
d20659 1
a20659 1
	      if (lopt->deprecated != NULL)
a20661 1
#endif
@


1.366
log
@2009-01-16  Andrew Stubbs  <ams@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_copy_symbol_attributes): New function.
	* config/tc-arm.h (arm_copy_symbol_attributes): New prototype.
	(CONVERT_SYMBOLIC_ATTRIBUTE): New define.
	* read.c (s_vendor_attribute): Add support for symbolic tag names.
	Improve string parser.
	* doc/c-arm.texi (ARM Machine Directives): Document
	.eabi_attribute symbolic tag names.

	gas/testsuite/
	* gas/arm/attr-syntax.d: New file.
	* gas/arm/attr-syntax.s: New file.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008
d12730 1
d16032 1
a16032 1
 
a20938 1

d20970 1
d20977 1
d20980 1
d20984 9
d20994 38
a21031 45
  /* When you modify this table you should also
     modify the list in doc/c-arm.texi.  */
  static const struct {
    const char *name;
    const int tag;
  } attribute_table[] = {
      T(Tag_CPU_raw_name),
      T(Tag_CPU_name),
      T(Tag_CPU_arch),
      T(Tag_CPU_arch_profile),
      T(Tag_ARM_ISA_use),
      T(Tag_THUMB_ISA_use),
      T(Tag_VFP_arch),
      T(Tag_WMMX_arch),
      T(Tag_Advanced_SIMD_arch),
      T(Tag_PCS_config),
      T(Tag_ABI_PCS_R9_use),
      T(Tag_ABI_PCS_RW_data),
      T(Tag_ABI_PCS_RO_data),
      T(Tag_ABI_PCS_GOT_use),
      T(Tag_ABI_PCS_wchar_t),
      T(Tag_ABI_FP_rounding),
      T(Tag_ABI_FP_denormal),
      T(Tag_ABI_FP_exceptions),
      T(Tag_ABI_FP_user_exceptions),
      T(Tag_ABI_FP_number_model),
      T(Tag_ABI_align8_needed),
      T(Tag_ABI_align8_preserved),
      T(Tag_ABI_enum_size),
      T(Tag_ABI_HardFP_use),
      T(Tag_ABI_VFP_args),
      T(Tag_ABI_WMMX_args),
      T(Tag_ABI_optimization_goals),
      T(Tag_ABI_FP_optimization_goals),
      T(Tag_compatibility),
      T(Tag_CPU_unaligned_access),
      T(Tag_VFP_HP_extension),
      T(Tag_ABI_FP_16bit_format),
      T(Tag_nodefaults),
      T(Tag_also_compatible_with),
      T(Tag_conformance),
      T(Tag_T2EE_use),
      T(Tag_Virtualization_use),
      T(Tag_MPextension_use)
  };
d21033 1
d21039 1
a21039 1
  for (i = 0; i < ARRAY_SIZE(attribute_table); i++)
d21045 1
@


1.365
log
@2009-01-15  Andrew Stubbs  <ams@@codesourcery.com>
	    Julian Brown   <julian@@codesourcery.com>

	bfd/
	* elf-bfd.h (NUM_KNOWN_OBJ_ATTRIBUTES): Set to 71 to include all known
	ARM attributes in ABI 2.07.
	* elf32-arm.c (get_secondary_compatible_arch): New function.
	(set_secondary_compatible_arch): New function.
	(tag_cpu_arch_combine): New function.
	(elf32_arm_copy_one_eabi_other_attribute): Delete function.
	(elf32_arm_copy_eabi_other_attribute_list): Delete function.
	(elf32_arm_merge_eabi_attributes): Rename order_312 to order_021 to
	make it fit with order_01243.
	Add support for Tag_also_compatible_with,
	Tag_CPU_unaligned_access, Tag_T2EE_use, Tag_Virtualization_use,
	Tag_MPextension_use, Tag_nodefaults and Tag_conformance.
	Improve/tidy up support for Tag_CPU_raw_name, Tag_CPU_name,
	Tag_CPU_arch, Tag_ABI_HardFP_use, Tag_VFP_HP_extension,
	Tag_ABI_FP_denormal, Tag_ABI_PCS_GOT_use, Tag_ABI_align8_needed,
	Tag_VFP_arch and Tag_ABI_FP_16bit_format.
	Rework the way unknown attributes are handled.
	Defer errors until all attributes have been processed.

	gas/
	* config/tc-arm.c (cpu_arch): Change ARM_ARCH_V6M to 11.

	include/elf/
	* arm.h (TAG_CPU_ARCH_V6_M, TAG_CPU_ARCH_V6S_M): New defines.
	(MAX_TAG_CPU_ARCH, TAG_CPU_ARCH_V4T_PLUS_V6_M): New defines.
	(Tag_NEON_arch): Rename to Tag_Advanced_SIMD_arch to match ARM ABI
	version 2.07.
	(Tag_undefined39, Tag_nodefaults): New enum values.
	(Tag_also_compatible_with, Tag_T2EE_use): Likewise.
	(Tag_conformance, Tag_Virtualization_use): Likewise.
	(Tag_undefined69, Tag_MPextension_use): Likewise.
@
text
@d20975 64
@


1.364
log
@        PR 9722
        * config/tc-arm.c (do_t_nop): Check for availability of Thumb2
        instructions before generating a Thumb2 nop.

        * gas/testsuite/gas/arm/archv6m.d: Update expected NOP opcode.
        * gas/testsuite/gas/arm/pr9722.s: New test.
        * gas/testsuite/gas/arm/pr9722.d: Expected disassembly.
@
text
@d20722 1
a20722 1
    {9, ARM_ARCH_V6M},
@


1.363
log
@Add support for ARM half-precision conversion instructions.
@
text
@d9930 9
a9938 2
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].imm << 4;
@


1.362
log
@        PR 7026
        * config/tc-arm.c: Ensure that all uses of as_bad have a
        formatting string.
@
text
@d229 1
d10686 31
a10716 30
  N_S8   = 0x000001,
  N_S16  = 0x000002,
  N_S32  = 0x000004,
  N_S64  = 0x000008,
  N_U8   = 0x000010,
  N_U16  = 0x000020,
  N_U32  = 0x000040,
  N_U64  = 0x000080,
  N_I8   = 0x000100,
  N_I16  = 0x000200,
  N_I32  = 0x000400,
  N_I64  = 0x000800,
  N_8    = 0x001000,
  N_16   = 0x002000,
  N_32   = 0x004000,
  N_64   = 0x008000,
  N_P8   = 0x010000,
  N_P16  = 0x020000,
  N_F32  = 0x040000,
  N_F64  = 0x080000,
  N_KEY  = 0x100000, /* key element (main type specifier).  */
  N_EQK  = 0x200000, /* given operand has the same type & size as the key.  */
  N_VFP  = 0x400000, /* VFP mode: operand size must match register width.  */
  N_DBL  = 0x000001, /* if N_EQK, this operand is twice the size.  */
  N_HLF  = 0x000002, /* if N_EQK, this operand is half the size.  */
  N_SGN  = 0x000004, /* if N_EQK, this operand is forced to be signed.  */
  N_UNS  = 0x000008, /* if N_EQK, this operand is forced to be unsigned.  */
  N_INT  = 0x000010, /* if N_EQK, this operand is forced to be integer.  */
  N_FLT  = 0x000020, /* if N_EQK, this operand is forced to be float.  */
  N_SIZ  = 0x000040, /* if N_EQK, this operand is forced to be size-only.  */
d10910 1
d12604 3
d12611 6
a12616 6
  CVT_VAR (4, N_F32, N_F64);
  CVT_VAR (5, N_F64, N_F32);
  CVT_VAR (6, N_S32, N_F64 | key);
  CVT_VAR (7, N_U32, N_F64 | key);
  CVT_VAR (8, N_F64 | key, N_S32);
  CVT_VAR (9, N_F64 | key, N_U32);
d12618 8
a12625 8
  CVT_VAR (10, N_F32 | key, N_S16);
  CVT_VAR (11, N_F32 | key, N_U16);
  CVT_VAR (12, N_F64 | key, N_S16);
  CVT_VAR (13, N_F64 | key, N_U16);
  CVT_VAR (14, N_S16, N_F32 | key);
  CVT_VAR (15, N_U16, N_F32 | key);
  CVT_VAR (16, N_S16, N_F64 | key);
  CVT_VAR (17, N_U16, N_F64 | key);
d12649 2
d12683 2
d12714 2
a12722 1

d12727 1
a12727 1
    NS_FD, NS_DF, NS_FF, NS_NULL);
d12731 1
a12731 1
  if (flavour >= 4)
d12793 30
d12830 28
d16022 3
d20333 1
d20807 1
a20807 2
  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_neon_ext_v1)
      || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_neon_ext_v1))
d20809 3
@


1.361
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d3459 1
a3459 1
	  as_bad (_(reg_expected_msgs[REG_TYPE_MMXWR]));
d3473 1
a3473 1
	      as_bad (_(reg_expected_msgs[REG_TYPE_MMXWR]));
d3591 1
a3591 1
	  as_bad (_(reg_expected_msgs[REG_TYPE_MMXWCG]));
d3606 1
a3606 1
	      as_bad (_(reg_expected_msgs[REG_TYPE_MMXWCG]));
d3712 1
a3712 1
      as_bad (_(reg_expected_msgs[REG_TYPE_RN]));
@


1.361.2.1
log
@        * Import this patch:

        2008-11-14  Peter Jansen  <pwjansen@@yahoo.com>

        PR 7026
        * config/tc-arm.c: Ensure that all uses of as_bad have a
        formatting string.
@
text
@d3459 1
a3459 1
	  as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWR]));
d3473 1
a3473 1
	      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWR]));
d3591 1
a3591 1
	  as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWCG]));
d3606 1
a3606 1
	      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWCG]));
d3712 1
a3712 1
      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_RN]));
@


1.360
log
@	* config/tc-arm.c (s_unreq): Adjust hash_delete call.
	* config/tc-ia64.c (dot_rot): Likewise.
@
text
@d1991 1
a1991 1
  if (hash_insert (arm_reg_hsh, name, (PTR) new))
d19605 1
a19605 1
    hash_insert (arm_ops_hsh, insns[i].template, (PTR) (insns + i));
d19607 1
a19607 1
    hash_insert (arm_cond_hsh, conds[i].template, (PTR) (conds + i));
d19609 1
a19609 1
    hash_insert (arm_shift_hsh, shift_names[i].name, (PTR) (shift_names + i));
d19611 1
a19611 1
    hash_insert (arm_psr_hsh, psrs[i].template, (PTR) (psrs + i));
d19613 1
a19613 1
    hash_insert (arm_v7m_psr_hsh, v7m_psrs[i].template, (PTR) (v7m_psrs + i));
d19615 1
a19615 1
    hash_insert (arm_reg_hsh, reg_names[i].name, (PTR) (reg_names + i));
d19620 1
a19620 1
		 (PTR) (barrier_opt_names + i));
d19623 1
a19623 1
    hash_insert (arm_reloc_hsh, reloc_names[i].name, (PTR) (reloc_names + i));
@


1.359
log
@
gas/

2008-07-07  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (arm_fix_adjustable): Don't adjust MOVW/MOVT
	relocations.

gas/testsuite/

2008-07-07  Paul Brook  <paul@@codesourcery.com>

	* gas/arm/movw-local.d: New test.
	* gas/arm/movw-local.s: New test.
@
text
@d2293 1
a2293 1
	  hash_delete (arm_reg_hsh, name);
d2309 1
a2309 1
	      hash_delete (arm_reg_hsh, nbuf);
d2321 1
a2321 1
	      hash_delete (arm_reg_hsh, nbuf);
@


1.358
log
@2008-06-03  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_t_rbit): Populate both rm fields.
	gas/testsuite/
	* gas/arm/thumb32.d: Update expected output.
@
text
@d19423 11
@


1.357
log
@2008-05-22  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (parse_cond): Covert to lowercase before matching.
@
text
@d10051 1
@


1.356
log
@        * config/tc-arm.c (arm_cpus): Add Faraday ARMv4 and ARMv5TE
        compatible cores: fa526, fa626, fa626te, fa726te.
        * doc/c-arm.texi (ARM Opts): Add -mcpu={fa526, fa626, fa626te,
        fa726te} options.
@
text
@d5046 1
a5046 1
  char *p, *q;
d5048 4
d5053 8
a5060 3
  p = q = *str;
  while (ISALPHA (*q))
    q++;
d5062 1
a5062 1
  c = hash_find_n (arm_cond_hsh, p, q - p);
@


1.355
log
@        * config/obj-elf.c (obj_elf_section_type): Add prototype
        before obj_elf_section_word and add 'warn' arg.
        (obj_elf_section_word): Add type pointer arg, and if no #SECTION
        is matched, try checking for #SECTION_TYPE.
        (obj_elf_section): Adjust for new args.
        (obj_elf_type_name): New function.
        (obj_elf_type): Call it, and accept STT_foo number strings
        in .type statements as output by SunPRO compiler.
@
text
@d20085 2
d20110 2
d20468 1
a20468 1
  {"meabi=", N_("<ver>\t  assemble for eabi version <ver>"),
@


1.354
log
@2008-03-28  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (parse_neon_mov): Parse register before immediate
	to avoid spurious symbols.
@
text
@d9822 1
a9822 1
		    "requested special purpose register %x"));
@


1.353
log
@            * config/tc-arm.c (do_neon_cvt): Move variable declarations to
            start of block.
            (do_neon_ext): Fix sign of comparison.
@
text
@a5211 10
      else if (parse_qfloat_immediate (&ptr, &inst.operands[i].imm) == SUCCESS)
          /* Case 2: VMOV<c><q>.<dt> <Qd>, #<float-imm>
             Case 3: VMOV<c><q>.<dt> <Dd>, #<float-imm>
             Case 10: VMOV.F32 <Sd>, #<imm>
             Case 11: VMOV.F64 <Dd>, #<imm>  */
        inst.operands[i].immisfloat = 1;
      else if (parse_big_immediate (&ptr, i) == SUCCESS)
          /* Case 2: VMOV<c><q>.<dt> <Qd>, #<imm>
             Case 3: VMOV<c><q>.<dt> <Dd>, #<imm>  */
        ;
d5251 10
@


1.352
log
@2008-03-09  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_cpu_option_table): Add cortex-a9.
	* doc/c-arm.texi: Add cortex-a9.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007
d12721 3
d12731 1
a12731 2
        unsigned immbits = 32 - inst.operands[2].imm;
        unsigned enctab[] = { 0x0000100, 0x1000100, 0x0, 0x1000000 };
d12966 3
a12968 1
  constraint (imm >= (neon_quad (rs) ? 16 : 8), _("shift out of range"));
@


1.351
log
@2008-03-09  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Handle new
	Tag_VFP_arch values.

	binutils/
	* readelf.c (arm_attr_tag_VFP_arch): Add "VFPv3-D16".

	gas/
	* config/tc-arm.c (fpu_vfp_ext_d32): New vairable.
	(parse_vfp_reg_list, encode_arm_vfp_reg): Use it.
	(arm_option_cpu_value): Add vfpv3-d16, vfpv2 and vfpv3.
	(aeabi_set_public_attributes): Handle Tag_VFP_arch=VFPV3-D16.
	* doc/c-arm.texi: Document new ARM FPU variants.

	gas/testsuite/
	* gas/arm/vfpv3-d16-bad.d: New test.
	* gas/arm/vfpv3-d16-bad.l: New test.

	include/opcode/
	* arm.h (FPU_VFP_EXT_D32, FPU_VFP_V3D16, FPU_ARCH_VFP_V3D16): Define.
@
text
@d20117 3
@


1.350
log
@2008-03-07  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_howto_table_1): Fix bitmasks for MOVW and
	MOVT relocations.
	(elf32_arm_final_link_relocate): Fix off by one MOVW/MOVT sign
	extension.
	(elf32_arm_relocate_section): Handle MOVW and MOVT
	relocations.  Improve safety check for other weird relocations.
	(elf32_arm_check_relocs): Only set h->needs_plt for branch/call
	relocations.

	gas/
	* config/tc-arm.c (md_apply_fix): Use correct offset range.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Add movw-merge and arm-app-movw.
	* ld-arm/arm-app-movw.s: New test.
	* ld-arm/arm-app.r: Update expected output.
	* ld-arm/movw-merge.d: New test.
	* ld-arm/movw-merge.s: New test.
@
text
@d224 2
d1612 2
a1613 2
      /* VFPv3 allows 32 D registers.  */
      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v3))
d1618 1
a1618 1
                                    fpu_vfp_ext_v3);
d1621 1
a1621 1
                                    fpu_vfp_ext_v3);
d6166 1
a6166 1
      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v3))
d6170 1
a6170 1
                                    fpu_vfp_ext_v3);
d6173 1
a6173 1
                                    fpu_vfp_ext_v3);
d20216 1
a20216 1
  {"vfp3",              FPU_ARCH_VFP_V3},
d20220 3
d20683 4
a20686 1
  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v3)
@


1.349
log
@2008-03-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_ext_barrier, arm_ext_msr): New.
	(arm_ext_v7m): Rename...
	(arm_ext_m): ... to this.  Include v6-M.
	(do_t_add_sub): Allow narrow low-reg non flag setting adds.
	(do_t_mrs, do_t_msr, aeabi_set_public_attributes): Use arm_ext_m.
	(md_assemble): Allow wide msr instructions.
	(insns): Add classifications for v6-m instructions.
	(arm_cpu_option_table): Add cortex-m1.
	(arm_arch_option_table): Add armv6-m.
	(cpu_arch): Add ARM_ARCH_V6M.  Fix numbering of other v6 variants.

	gas/testsuite/
	* gas/arm/archv6m.d: New test.
	* gas/arm/archv6m.s: New test.
	* gas/arm/t16-bad.s: Test low register non flag setting add.
	* gas/arm/t16-bad.l: Update expected output.

	include/opcode/
	* arm.h (ARM_EXT_V6M, ARM_EXT_BARRIER, ARM_EXT_THUMB_MSR): Define.
	(ARM_AEXT_V6T2, ARM_AEXT_V7_ARM, ARM_AEXT_V7M): Use new flags.
	(ARM_AEXT_V6M, ARM_ARCH_V6M): Define.
@
text
@d18807 1
a18807 1
	      if (value < -0x1000 || value > 0xffff)
@


1.348
log
@        * config/tc-arm.c (do_bx): Only test EF_ARM_EABI_VERSION on ELF
        targeted ARM ports, otherwise just skip generating the reloc.
@
text
@d195 2
d201 2
a202 1
static const arm_feature_set arm_ext_v7m = ARM_FEATURE (ARM_EXT_V7M, 0);
d8503 1
a8503 1
	      if (inst.instruction == T_MNEM_add)
d8505 5
a8509 1
		  if (Rd == Rs)
d8511 5
a8521 9
		  /* ... because addition is commutative! */
		  else if (Rd == Rn)
		    {
		      inst.instruction = T_OPCODE_ADD_HI;
		      inst.instruction |= (Rd & 8) << 4;
		      inst.instruction |= (Rd & 7);
		      inst.instruction |= Rs << 3;
		      return;
		    }
d9812 1
a9812 1
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7m),
d9850 1
a9850 1
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7m),
d14231 2
a14232 1
	  if (opcode->tencode != do_t_blx && opcode->tencode != do_t_branch23)
d14286 1
a14286 1
	 anything other than bl/blx.
d14288 3
a14290 2
      if ((inst.size == 4 && (inst.instruction & 0xf800e800) != 0xf000e800)
	  || inst.relax)
d15036 2
d15043 2
d15324 9
a15339 3
 TUF(dmb,	57ff050, f3bf8f50, 1, (oBARRIER), barrier,  t_barrier),
 TUF(dsb,	57ff040, f3bf8f40, 1, (oBARRIER), barrier,  t_barrier),
 TUF(isb,	57ff060, f3bf8f60, 1, (oBARRIER), barrier,  t_barrier),
d20117 1
d20166 1
d20604 3
a20606 2
    {8, ARM_ARCH_V6K},
    {9, ARM_ARCH_V6T2},
d20668 1
a20668 1
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v7m))
@


1.347
log
@        * config/tc-arm.c (do_bx): Only test EF_ARM_EABI_VERSION on ELF
        targeted ARM ports.
@
text
@d6778 1
a6779 1
#endif
@


1.346
log
@2008-02-20  Paul Brook  <paul@@codesourcery.com>

	ld/
	* emultempl/armelf.em (OPTION_FIX_V4BX_INTERWORKING): Define.
	(PARSE_AND_LIST_LONGOPTS): Add fix-v4bx-interworking.
	(PARSE_AND_LIST_OPTIONS): Ditto.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_FIX_V4BX_INTERWORKING.
	* emulparams/armelf.sh (OTHER_TEXT_SECTIONS): Add .v4_bx.
	* emulparams/armelf_linux.sh (OTHER_TEXT_SECTIONS): Ditto.
	* emulparams/armnto.sh (OTHER_TEXT_SECTIONS): Ditto.
	* ld.texinfo: Document --fix-v4bx-interworking.

	ld/testsuite/
	* ld-arm/armv4-bx.d: New test.
	* ld-arm/armv4-bx.s: New test.
	* ld-arm/arm.ld: Add .v4bx.
	* ld-arm/arm-elf.exp: Add armv4-bx.

	gas/testsuite/
	* gas/arm/thumb.d: Exclude EABI targets.
	* gas/arm/arch4t.d: Exclude EABI targts.
	* gas/arm/v4bx.d: New test.
	* gas/arm/v4bx.s: New test.
	* gas/arm/thumb-eabi.d: New test.
	* gas/arm/arch4t-eabi.d: New test.

	gas/
	* config/tc-arm.c (fix_v4bx): New variable.
	(do_bx): Generate V4BX relocations.
	(md_assemble): Allow bx on v4 codes when fix_v4bx.
	(md_apply_fix): Handle BFD_RELOC_ARM_V4BX.
	(tc_gen_reloc): Ditto.
	(OPTION_FIX_V4BX): Define.
	(md_longopts): Add fix-v4bx.
	(md_parse_option): Handle OPTION_FIX_V4BX.
	(md_show_usage): Document --fix-v4bx.
	* doc/c-arm.texi: Document --fix-v4bx.

	bfd/
	* reloc.c: Add BFD_RELOC_ARM_V4BX.
	* elf32-arm.c (elf32_arm_reloc_map): Add BFD_RELOC_ARM_V4BX.
	(ARM_BX_GLUE_SECTION_NAME, ARM_BX_GLUE_SECTION_NAME): Define.
	(elf32_arm_link_hash_table): Add bx_glue_size and bx_glue_offset.
	Update comment for fix_v4bx.
	(elf32_arm_link_hash_table_create): Zero bx_glue_size and
	bx_glue_offset.
	(ARM_BX_VENEER_SIZE, armbx1_tst_insn, armbx2_moveq_insn,
	armbx3_bx_insn): New.
	(bfd_elf32_arm_allocate_interworking_sections): Allocate BX veneer
	section.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Ditto.
	(bfd_elf32_arm_process_before_allocation): Record BX veneers.
	(record_arm_bx_glue, elf32_arm_bx_glue): New functions.
	(elf32_arm_final_link_relocate): Handle BX veneers.
	(elf32_arm_output_arch_local_syms): Output mapping symbol for .v4_bx.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d6776 1
d6779 1
@


1.345
log
@        PR gas/5712
        * config/tc-arm.c (s_arm_unwind_save): Advance the input line
        pointer past the comma after parsing a floating point register
        name.

        * gas/arm/fp-save.s: New test.
        * gas/arm/fp-save.d: Expected disassembly.
@
text
@d146 1
d6764 2
d6770 11
d14289 5
d14295 3
a14297 2
      if (!opcode->avariant ||
	  !ARM_CPU_HAS_FEATURE (cpu_variant, *opcode->avariant))
d14319 1
a14319 2
      if (ARM_CPU_HAS_FEATURE (*opcode->avariant, arm_ext_v4t)
	  || ARM_CPU_HAS_FEATURE (*opcode->avariant, arm_ext_v5))
d18991 5
d19146 1
d19834 1
d19844 1
d20460 4
d20561 3
@


1.344
log
@2007-11-06  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_mull): Allow overlapping Rm for armv6.

	gas/testsuite/
	* gas/arm/mul-overlap.s: Add umull and smlal.
	* gas/arm/mul-overlap.l: Update expected results.
@
text
@d3673 1
@


1.343
log
@PR gas/5174
* config/tc-arm.c: Fix formatting and spelling errors.
* gas.pot: Regenerate.
@
text
@d7205 6
a7210 3
  /* rdhi, rdlo and rm must all be different.  */
  if (inst.operands[0].reg == inst.operands[1].reg
      || inst.operands[0].reg == inst.operands[2].reg
d7212 1
@


1.342
log
@Remove duplicate definitions of the md_atof() function
@
text
@d237 1
a237 1
arm_is_eabi(void)
d679 1
a679 2
	      <insn>
*/
a704 1

d1226 1
a1226 1
  
d1228 1
a1228 1
  
d1287 1
a1287 1
  
d1298 1
a1298 1
    
d1306 1
a1306 1
    
d1335 1
a1335 1
  
d1338 1
a1338 1
  
d1341 1
a1341 1
  
d1343 1
a1343 1
  
d1352 1
a1352 2
   This function will fault on encountering a scalar.
*/
d1393 1
a1393 1
  
d1395 1
a1395 1
  
d1398 1
a1398 1
  
d1409 1
a1409 1
  
d1412 1
a1412 1
  
d1414 1
a1414 1
  
d1594 1
a1594 1
    
d1598 1
a1598 1
    
d1634 1
a1634 1
 
d1640 1
a1640 1
 
d1740 1
a1740 1
    
d1746 1
a1746 1
  
d1755 1
a1755 1
  
d1786 1
a1786 1
  
d1789 1
a1789 1
  
d1800 1
a1800 1
      
d1831 1
a1831 1
      
d1867 1
a1867 1
      
d1874 1
a1874 1
      
d1895 1
a1895 1
  
d1899 1
a1899 1
  
d1913 1
a1913 1
  
d1922 1
a1922 1
  
d1987 1
a1987 1
  
d1996 1
a1996 1
  
d2002 1
a2002 1
  
d2072 1
a2072 1
	     the artifical FOO alias because it has already been created by the
d2096 1
a2096 2
     vadd d0.s32, d1.s32, d2.s32
*/
d2108 1
a2108 1
  
d2113 1
a2113 1
  
d2115 1
a2115 1
  
d2122 1
a2122 1
  
d2124 1
a2124 1
  
d2127 1
a2127 1
  
d2163 1
a2163 1
      
d2172 1
a2172 1
  
d2177 1
a2177 1
    
d2183 1
a2183 1
    
d2185 1
a2185 1
    
d2191 1
a2191 1
      
d2194 1
a2194 1
    
d2206 1
a2206 1
  
d2209 1
a2209 1
    
d2213 1
a2213 1
  
d2217 1
a2217 1
  
d2221 1
a2221 1
  
d2225 1
a2225 1
  
d2296 1
a2296 1
	  
d2780 1
a2780 1
   structure to the relevent literal pool.  */
d3138 6
a3143 5
      static const char *const name[] = {
	"__aeabi_unwind_cpp_pr0",
	"__aeabi_unwind_cpp_pr1",
	"__aeabi_unwind_cpp_pr2"
      };
d3543 1
a3543 1
	     preceeding block.	*/
d3890 1
a3890 1
pe_directive_secrel (int dummy ATTRIBUTE_UNUSED) 
d4053 1
a4053 1
  
d4173 1
a4173 1
  
d4175 1
a4175 1
  
d4198 1
a4198 1
  
d4203 1
a4203 1
      
d4210 1
a4210 1
      
d4217 1
a4217 1
      
d4220 1
a4220 1
  
d4501 2
a4502 2
      if (strncasecmp (group_reloc_table[i].name, *str, length) == 0 &&
          (*str)[length] == ':')
d4676 2
a4677 3
	  if (group_relocations &&
              ((*p == '#' && *(p + 1) == ':') || *p == ':'))

d4834 1
a4834 1
  
d4837 1
a4837 1
  if (strncasecmp (p, ":lower16:", 9) == 0) 
d4845 1
a4845 1
      skip_whitespace(p);
d5103 1
a5103 1
  
d5146 1
a5146 1
  
d5157 1
a5157 1
      
d5160 1
a5160 1
      
d5171 1
a5171 1
      
d5230 1
a5230 1
          
d5242 1
a5242 1
              
d5245 1
a5245 1
              
d5248 1
a5248 1
              
d5266 1
a5266 1
      
d5269 1
a5269 1
      
d5284 1
a5284 1
          
d5287 1
a5287 1
          
d5301 1
a5301 1
          
d5345 1
a5345 1
  wanted_comma:
d5348 2
a5349 2
  
  wanted_arm:
d6055 1
a6055 1
	     defaut here just in case.  */
d6192 1
a6192 1
    
d6196 1
a6196 1
    
d6483 1
a6483 1
/* Functions for instruction encoding, sorted by subarchitecture.
d6831 1
a6831 1
   Result unpredicatable if Rd or Rn is R15.  */
d6926 1
a6926 1
  
d7127 1
a7127 1
    
a7806 1

a7854 1

d8005 1
a8005 1
	  case 7: 
d9139 1
a9139 1
      mask = ffs(mask) - 1;
d9203 2
a9204 2
	  encode_thumb2_ldmstm(inst.operands[0].reg, inst.operands[1].imm,
			       inst.operands[0].writeback);
d9299 1
a9299 1
	      /* [Rn, Ri] */
d9360 1
a9360 1
     
a9437 1
			    
d9554 1
a9554 1
	      abort();
d9801 1
a9801 1
    
d9981 1
a9981 1
  
d10002 1
a10002 1
      encode_thumb2_ldmstm(13, mask, TRUE);
d10169 1
a10169 1
	  
d10208 1
a10208 1
	  
d10403 1
a10403 1
  
d10415 1
a10415 1
  
d10513 1
a10513 1
   
d10518 1
a10518 2
     - a table used to drive neon_select_shape.
*/
d10716 1
a10716 1
  
d10781 1
a10781 1
  
d10823 1
a10823 1
  
d10832 1
a10832 1
  
d10834 1
a10834 1
  
d10911 1
a10911 1
  
d10950 1
a10950 1
  
d10964 1
a10964 1
  
d10966 1
a10966 1
  
d10975 1
a10975 1
  
d11129 1
a11129 1
            
d11183 1
a11183 1
  
d11242 1
a11242 1
    
d11268 1
a11268 1
  
d11344 1
a11344 1
      
d11357 1
a11357 1
  
d11370 1
a11370 1
  
d11391 1
a11391 1
      
d11419 1
a11419 1
     
d11476 1
a11476 1
      
d11478 1
a11478 1
      
d11483 1
a11483 1
  
d11503 1
a11503 1
  
d11520 1
a11520 1
  
d11749 1
a11749 1
   MVN).  If the immediate looks like a repeated parttern then also
d11926 1
a11926 1
      
d11929 1
a11929 1
      
d11950 1
a11950 1
        
d11954 1
a11954 1
        
d11960 1
a11960 1
        
d11966 1
a11966 1
        
d11979 1
a11979 1
      
d12072 1
a12072 1
  
d12079 1
a12079 1
  
d12147 1
a12147 1
      
d12188 1
a12188 1
    
d12212 1
a12212 1
  
d12331 1
a12331 1
  
d12340 1
a12340 1
  
d12348 1
a12348 1
  
d12429 1
a12429 1
  
d12439 1
a12439 1
  
d12493 1
a12493 1
  
d12503 1
a12503 1
  
d12526 1
a12526 1
      
d12560 1
a12560 1
  
d12565 1
a12565 1
  
d12567 1
a12567 1
  
d12584 1
a12584 1
  
d12595 1
a12595 1
  
d12808 1
a12808 1
      
d12828 1
a12828 3
  |  U  |x |D |size | Rn  | Rd  |x x x x|N|x|M|x| Rm |

*/
d12841 1
a12841 1
  
d12947 1
a12947 1
  
d12992 1
a12992 1
      
d13048 1
a13048 1
  
d13051 1
a13051 1
   
d13053 1
a13053 1
   
d13056 1
a13056 1
   
d13058 1
a13058 2
   can specify a type where it doesn't make sense to, and is ignored).
*/
d13101 1
a13101 1
        
d13120 1
a13120 1
    
d13156 1
a13156 1
    
d13168 1
a13168 1
    
d13203 1
a13203 1
    
d13215 1
a13215 1
    
d13219 1
a13219 1
    
d13231 1
a13231 1
    
d13235 1
a13235 1
    
d13239 1
a13239 1
    
d13251 1
a13251 1
    
d13261 1
a13261 1
    
d13392 1
a13392 1
  
d13398 1
a13398 1
  
d13407 1
a13407 1
  
d13437 1
a13437 1
  
d13445 1
a13445 1
  
d13521 1
a13521 1
  
d13538 1
a13538 1
    
d13544 1
a13544 1
      
d13565 1
a13565 1
    
d13578 1
a13578 1
  
d13581 1
a13581 1
  
d13589 1
a13589 1
  
d13649 1
a13649 1
      
d13740 1
a13740 1
    
d13745 1
a13745 1
    
d13755 1
a13755 1
  
d13770 2
a13771 2
    inst.instruction |= 0xf; 
  
a13776 1

d13867 3
a13869 2
  if (inst.relax) {
      output_relax_insn();
d13871 1
a13871 1
  }
d13994 1
a13994 1
  
d14010 1
a14010 1
      
d14024 1
a14024 1
      if (end[offset] == '.')      
d14329 1
a14329 1
  /* Note - do not allow local symbols (.Lxxx) to be labeled
d16587 2
a16588 1
  if (fragp->fr_symbol) {
d16591 3
a16593 1
  } else {
d16595 1
a16595 1
  }
d16612 1
a16612 1
	  insn = THUMB_OP32(opcode);
d16730 1
a16730 1
      abort();
d16765 1
a16765 1
relaxed_symbol_addr(fragS *fragp, long stretch)
d16822 1
a16822 1
  if (!S_IS_DEFINED(fragp->fr_symbol)
d16826 1
a16826 1
  val = relaxed_symbol_addr(fragp, stretch);
d16865 1
a16865 1
  if (!S_IS_DEFINED(fragp->fr_symbol)
d16869 1
a16869 1
  val = relaxed_symbol_addr(fragp, stretch);
d16894 1
a16894 1
      newsize = relax_adr(fragp, sec, stretch);
d16899 1
a16899 1
      newsize = relax_immediate(fragp, 8, 2);
d16903 1
a16903 1
      newsize = relax_immediate(fragp, 5, 2);
d16907 1
a16907 1
      newsize = relax_immediate(fragp, 5, 1);
d16911 1
a16911 1
      newsize = relax_immediate(fragp, 5, 0);
d16914 1
a16914 1
      newsize = relax_adr(fragp, sec, stretch);
d16920 1
a16920 1
      newsize = relax_immediate(fragp, 8, 0);
d16923 1
a16923 1
      newsize = relax_branch(fragp, sec, 11, stretch);
d16926 1
a16926 1
      newsize = relax_branch(fragp, sec, 8, stretch);
d16943 1
a16943 1
      abort();
d16949 2
a16950 2
     Don't freeze them unconditionally because targets may be artificialy
     misaligned by the expansion of preceeding frags.  */
d16954 1
a16954 1
      frag_wane(fragp);
d17119 1
a17119 1
/* Cenerate and deferred unwind frame offset.  */
d17317 1
a17317 1
  /* Set the setion link for index tables.  */
d17351 1
a17351 1
	    as_bad (_("handerdata in cantunwind frame"));
d17535 1
a17535 1
  if (fixP->fx_pcrel 
d17578 1
a17578 1
      /* When handling fixups immediately, because we have already 
d17903 1
a17903 1
     consistency with the behavior on 32-bit hosts.  Remember value
d17907 1
a17907 1
  value -= 0x80000000; 
d18838 2
a18839 2
   
         /* Update the instruction.  */  
d18877 2
a18878 2
    
          /* Update the instruction.  */  
d18917 2
a18918 2
    
          /* Update the instruction.  */  
d18961 2
a18962 2
    
          /* Update the instruction.  */  
d19406 1
a19406 1
      /* Put it at the end of the relevent section.  */
d20253 1
a20253 1
	  as_bad (_("unknown architectural extnsion `%s'"), str);
d20287 1
a20287 1
	  strcpy(selected_cpu_name, opt->canonical_name);
d20329 1
a20329 1
	strcpy(selected_cpu_name, opt->name);
d20592 1
a20592 1
      if (strncmp(p, "armv", 4) == 0)
d20595 1
a20595 1
	  
d20662 1
a20662 1
  while (*input_line_pointer && !ISSPACE(*input_line_pointer))
d20674 1
a20674 1
	  strcpy(selected_cpu_name, opt->canonical_name);
d20703 1
a20703 1
  while (*input_line_pointer && !ISSPACE(*input_line_pointer))
d20714 1
a20714 1
	strcpy(selected_cpu_name, opt->name);
d20737 1
a20737 1
  while (*input_line_pointer && !ISSPACE(*input_line_pointer))
d20768 1
a20768 1
  while (*input_line_pointer && !ISSPACE(*input_line_pointer))
d20772 1
a20772 1
  
@


1.341
log
@PR gas/5121 gas/5122 gas/5123 gas/5124 gas/5125 gas/5126 gas/5129 gas/5131 gas/5132 gas/5137 gas/5143
* Makefile.am (CFILES): Add cgen.c
  (TARGET_CPU_CFILES): Add tc-iq2000.c, tc-maxq.c, tc-mt.c, tc-tic4x.c and xtensa-relax.c.
  (TARGET_CPU_HFILES): Add tc-iq2000.h, tc-maxq.h, tc-mt.h, tc-tic4x.h and xtensa-relax.h.
  (TARG_ENV_HFILES): Remove te-aux.h, te-delta.h, te-delt88.h, te-ic960.h, te-linux.h.
   Add te-aix5.h, te-armeabi.h, te-freebsd.h, te-gnu.h, te-interix.h, te-vxworks.h.
  (CONFIG_ATOF_CFILES): New variable.
  (POTFILES): Add CONFIG_ATOF_CFILES to dependencies.  Fix typo with dependency upon TARG_ENV_HFILES.
  (DEPTC): Do not put "#include opcodes/<foo>-desc.h" into cgen-desc.h when foo-desc.h does not exit.
   Run make dep-am.
* Makefile.in: Regenerate.
* doc/Makefile.in: Regenerate.
* po/POTFILES.in: Regenerate.
* po/es.po: Regenerate.
* po/fr.po: Regenerate.
* po/gas.pot: Regenerate.
* po/rw.po: Regenerate.
* po/tr.po: Regenerate.
* config/obj-elf.c (obj_elf_vtable_inherit): Allow for translation of error messages.
* config/obj-som.c: Likewise.
* config/tc-arc.c: Likewise.
* config/tc-arm.c: Likewise.
* config/tc-bfin.c: Likewise.
* config/tc-frv.c: Likewise.
@
text
@d909 1
a909 1
      prec = 6;
d914 1
a914 1
      prec = 6;
d919 1
a919 1
      return _("bad call to MD_ATOF()");
d925 1
a925 1
  *sizeP = prec * 2;
d931 2
a932 2
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
d940 2
a941 2
	    md_number_to_chars (litP, (valueT) words[i], 2);
	    litP += 2;
d948 5
a952 3
	    md_number_to_chars (litP, (valueT) words[i + 1], 2);
	    md_number_to_chars (litP + 2, (valueT) words[i], 2);
	    litP += 4;
d956 1
a956 1
  return 0;
@


1.340
log
@PR gas/5134
* config/tc-arm.c (md_apply_fix): Likewise.
@
text
@d2433 1
a2433 1
      as_warn ("Failed to find real start of function: %s\n", name);
d6006 1
a6006 1
	  as_fatal ("unhandled operand code %d", upat[i]);
d6617 1
a6617 1
		  "bad barrier type");
d7015 2
a7016 2
      constraint (inst.reloc.exp.X_op != O_constant ||
		  inst.reloc.exp.X_add_number != 0,
d7046 2
a7047 2
      constraint (inst.reloc.exp.X_op != O_constant ||
		  inst.reloc.exp.X_add_number != 0,
d8776 1
a8776 1
		  "bad barrier type");
d17312 1
a17312 1
	  as_bad ("Group section `%s' has no group signature",
d17630 1
a17630 1
	    as_bad ("GOT already in the symbol table");
@


1.339
log
@PR gas/5133
* config/tc-arm.c (md_apply_fix): Correct error message
@
text
@d18774 1
a18774 1
				_("offset too big"));
@


1.338
log
@PR gas/5089  * config/tc-arm.c (s_arm_unwind_handlerdata): Fix spelling typo.
PR gas/5090    (md_assemble): Fix spelling typo.
@
text
@d18735 1
a18735 1
		      _("invalid immediate: %ld is too large"),
@


1.337
log
@2007-08-24  Aurelien Jarno  <aurel32@@debian.org>

	* config/tc-arm.c (md_apply_fix): Cast bfd_vma values to long
	before printing them.
@
text
@d3101 1
a3101 1
    as_bad (_("dupicate .handlerdata directive"));
d14237 1
a14237 1
	  as_bad (_("thumb conditional instrunction not in IT block"));
@


1.336
log
@2007-08-09  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (relaxed_symbol_addr): Compensate for alignment.

	gas/testsuite/
	* gas/arm/relax_load_align.d: new test.
	* gas/arm/relax_load_align.s: new test.
@
text
@d18827 1
a18827 1
                         addend_abs);
d18867 1
a18867 1
                          addend_abs);
d18906 1
a18906 1
                          addend_abs);
d18946 1
a18946 1
                          addend_abs);
d18951 1
a18951 1
                          addend_abs);
@


1.335
log
@* config/tc-arm.c (create_register_alias): Return a boolean rather than an integer.
  Check the return value of insert_reg_alias and do not continue to create aliases once an insertion has failed.
  (s_unreq): Delete the all-upper-case and all-lower-case alternatives as well.
* testsuite/gas/arm/arm.s: Add tests for re-aliasing a previously removed alias.
* testsuite/gas/arm/arm.l: Add new expected warning message.
@
text
@d16790 25
a16814 1
    addr += stretch;
@


1.335.2.1
log
@2007-08-24  Aurelien Jarno  <aurel32@@debian.org>

	* config/tc-arm.c (md_apply_fix): Cast bfd_vma values to long
	before printing them.
@
text
@d18803 1
a18803 1
                         (unsigned long) addend_abs);
d18843 1
a18843 1
                          (unsigned long) addend_abs);
d18882 1
a18882 1
                          (unsigned long) addend_abs);
d18922 1
a18922 1
                          (unsigned long) addend_abs);
d18927 1
a18927 1
                          (unsigned long) addend_abs);
@


1.334
log
@Switch to GPLv3
@
text
@d1974 1
a1974 1
      return 0;
d2016 1
a2016 1
   handle any error here, return non-zero.  Otherwise return zero.  */
d2018 1
a2018 1
static int
d2029 1
a2029 1
    return 0;
d2033 1
a2033 1
    return 0;
d2039 1
a2039 1
      return 1;
d2059 4
a2062 1
  insert_reg_alias (nbuf, old->number, old->type);
d2064 14
a2077 2
  for (p = nbuf; *p; p++)
    *p = TOUPPER (*p);
d2079 2
a2080 2
  if (strncmp (nbuf, newname, nlen))
    insert_reg_alias (nbuf, old->number, old->type);
d2082 3
a2084 5
  for (p = nbuf; *p; p++)
    *p = TOLOWER (*p);

  if (strncmp (nbuf, newname, nlen))
    insert_reg_alias (nbuf, old->number, old->type);
d2086 1
a2086 1
  return 1;
d2286 3
d2294 31
@


1.333
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d3 1
a3 1
   2004, 2005, 2006
d15 1
a15 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.332
log
@2007-06-26  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (parse_operands): Accept generic coprocessor regs
	for OP_RVC.
	(reg_names): Add fpinst, pfinst2, mvfr0 and mvfr1.

	gas/testsuite/
	* gas/arm/vfp1xD.d: Add new fmrx/fmxr tests.
	* gas/arm/vfp1xD.s: Ditto.
	* gas/arm/vfp1xD_t2.d: Ditto.
	* gas/arm/vfp1xD_t2.s: Ditto.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Add fmxr/fmrx mvfr0/mvfr1.
@
text
@d3832 1
a3832 78
  expressionS exp;
  bfd_boolean is_string;
  int tag;
  unsigned int i = 0;
  char *s = NULL;
  char saved_char;

  expression (& exp);
  if (exp.X_op != O_constant)
    goto bad;

  tag = exp.X_add_number;
  if (tag == 4 || tag == 5 || tag == 32 || (tag > 32 && (tag & 1) != 0))
    is_string = 1;
  else
    is_string = 0;

  if (skip_past_comma (&input_line_pointer) == FAIL)
    goto bad;
  if (tag == 32 || !is_string)
    {
      expression (& exp);
      if (exp.X_op != O_constant)
	{
	  as_bad (_("expected numeric constant"));
	  ignore_rest_of_line ();
	  return;
	}
      i = exp.X_add_number;
    }
  if (tag == Tag_compatibility
      && skip_past_comma (&input_line_pointer) == FAIL)
    {
      as_bad (_("expected comma"));
      ignore_rest_of_line ();
      return;
    }
  if (is_string)
    {
      skip_whitespace(input_line_pointer);
      if (*input_line_pointer != '"')
	goto bad_string;
      input_line_pointer++;
      s = input_line_pointer;
      while (*input_line_pointer && *input_line_pointer != '"')
	input_line_pointer++;
      if (*input_line_pointer != '"')
	goto bad_string;
      saved_char = *input_line_pointer;
      *input_line_pointer = 0;
    }
  else
    {
      s = NULL;
      saved_char = 0;
    }
  
  if (tag == Tag_compatibility)
    elf32_arm_add_eabi_attr_compat (stdoutput, i, s);
  else if (is_string)
    elf32_arm_add_eabi_attr_string (stdoutput, tag, s);
  else
    elf32_arm_add_eabi_attr_int (stdoutput, tag, i);

  if (s)
    {
      *input_line_pointer = saved_char;
      input_line_pointer++;
    }
  demand_empty_rest_of_line ();
  return;
bad_string:
  as_bad (_("bad string constant"));
  ignore_rest_of_line ();
  return;
bad:
  as_bad (_("expected <tag> , <value>"));
  ignore_rest_of_line ();
d20535 1
a20535 1
      elf32_arm_add_eabi_attr_string (stdoutput, 5, p);
d20538 1
a20538 1
  elf32_arm_add_eabi_attr_int (stdoutput, 6, arch);
d20541 1
a20541 1
    elf32_arm_add_eabi_attr_int (stdoutput, 7, 'A');
d20543 1
a20543 1
    elf32_arm_add_eabi_attr_int (stdoutput, 7, 'R');
d20545 1
a20545 1
    elf32_arm_add_eabi_attr_int (stdoutput, 7, 'M');
d20548 1
a20548 1
    elf32_arm_add_eabi_attr_int (stdoutput, 8, 1);
d20551 1
a20551 1
    elf32_arm_add_eabi_attr_int (stdoutput, 9,
d20556 1
a20556 1
    elf32_arm_add_eabi_attr_int (stdoutput, 10, 3);
d20559 1
a20559 1
    elf32_arm_add_eabi_attr_int (stdoutput, 10, 2);
d20564 1
a20564 1
    elf32_arm_add_eabi_attr_int (stdoutput, 10, 1);
d20568 1
a20568 1
    elf32_arm_add_eabi_attr_int (stdoutput, 11, 1);
d20572 1
a20572 1
    elf32_arm_add_eabi_attr_int (stdoutput, 12, 1);
d20575 1
a20575 1
/* Add the .ARM.attributes section.  */
a20578 5
  segT s;
  char *p;
  addressT addr;
  offsetT size;
  
a20582 6
  size = elf32_arm_eabi_attr_size (stdoutput);
  s = subseg_new (".ARM.attributes", 0);
  bfd_set_section_flags (stdoutput, s, SEC_READONLY | SEC_DATA);
  addr = frag_now_fix ();
  p = frag_more (size);
  elf32_arm_set_eabi_attr_contents (stdoutput, (bfd_byte *)p, size);
@


1.331
log
@2007-06-14  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_t_mov_cmp): Handle shift by register and
	narrow shift by immediate.

	gas/testsuite/
	* gas/arm/thumb32.s: Add tests for shift instructions.
	* gas/arm/thumb32.d: Ditto.
@
text
@d5615 7
a5621 1
	case OP_RVC:   po_reg_or_fail (REG_TYPE_VFC);	  break;
d14515 4
@


1.330
log
@2007-06-06  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (s_align): Pad code sections appropriately.

	gas/testsuite/
	* gas/arm/thumb.d: Update expected output.
	* gas/arm/thumb2_relax.d: Ditto.
@
text
@d9547 55
d9604 35
a9638 3
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << r0off;
	  encode_thumb32_shifted_operand (1);
@


1.329
log
@2007-06-05  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (insns): Correct Thumb-2 ldrd/strd opcodes.

	gas/testsuite/
	* gas/arm/thumb32.d: Add writeback addressing mode tests.
	* gas/arm/thumb32.s: Update expected output.

	opcodes/
	* arm-dis.c (thumb32_opcodes): Display writeback ldrd/strd addresses.
@
text
@d2616 1
d2633 1
d2636 4
a2639 1
    temp_fill = 0;
d2646 6
a2651 1
    frag_align (temp, (int) temp_fill, 0);
@


1.328
log
@2007-05-31  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (insns): Allow strex on M profile cores.
@
text
@d15020 2
a15021 2
 TC3(ldrd,	00000d0, e9500000, 3, (RRnpc, oRRnpc, ADDRGLDRS), ldrd, t_ldstd),
 TC3(strd,	00000f0, e9400000, 3, (RRnpc, oRRnpc, ADDRGLDRS), ldrd, t_ldstd),
@


1.327
log
@2007-03-25  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (T2_SUBS_PC_LR): Define.
	(do_t_add_sub): Correctly encode subs pc, lr, #const.
	(do_t_mov_cmp): Correctly encode movs pc, lr.

	gas/testsulte/
	* gas/arm/thumb32.s: Add tests for subs pc, lr.
	* gas/arm/thumb32.d: Change error-output: to stderr:.
	Update expected output.
@
text
@d15048 1
a15136 1
 TCE(strex,	1800f90, e8400000, 3, (RRnpc, RRnpc, ADDR),	   strex,  t_strex),
@


1.326
log
@2007-05-16  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (v7m_psrs): Add uppercase PSR names and xpsr.
@
text
@d558 2
d8444 15
a8458 1
	      if (Rs == REG_PC)
d9505 10
@


1.325
log
@	gas/
	* config/tc-arm.c (md_apply_fix): Generate more accurate
	diagnostic when 8-bit immediate range is exceeded for
	BFD_RELOC_ARM_OFFSET_IMM8.
@
text
@d14502 15
a14516 14
  {"apsr",	0 },
  {"iapsr",	1 },
  {"eapsr",	2 },
  {"psr",	3 },
  {"ipsr",	5 },
  {"epsr",	6 },
  {"iepsr",	7 },
  {"msp",	8 },
  {"psp",	9 },
  {"primask",	16},
  {"basepri",	17},
  {"basepri_max", 18},
  {"faultmask",	19},
  {"control",	20}
@


1.324
log
@2007-04-19  Paul Brook  <paul@@codesourcery.com>

	gas/testsuite/
	* gas/arm/thumb1_unified.d: New test.
	* gas/arm/thumb1_unified.s: New test.

	gas/
	* config/tc-arm.c (md_assemble): Only allow 16-bit instructions on
	Thumb-1.  Add sanity check for bogus relaxations.
@
text
@d17925 1
a17925 1
	    as_bad (_("bad immediate value for half-word offset (%ld)"),
@


1.323
log
@2007-04-19  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (insns): Allow rsb and rsbs on Thumb-1.
@
text
@d14113 8
d14162 5
@


1.322
log
@2007-04-18  Paul Brook  <paul@@codesourcery.com>

	gas/testsuite/
	* gas/arm/thumb2_add.s: Add rsb #0 test.
	* gas/arm/thumb2_add.d: Update expected output.

	gas/
	* config/tc-arm.c (do_t_rsb): Use 16-bit encoding when possible.
@
text
@d14830 4
a14840 2
 TCE(rsb,	0600000, ebc00000, 3, (RR, oRR, SH), arit, t_rsb),
 TC3(rsbs,	0700000, ebd00000, 3, (RR, oRR, SH), arit, t_rsb),
@


1.321
log
@2007-04-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_neon_ext): Enforce immediate range.
	(insns): Use I15 for vext.

	gas/testsute/
	* gas/arm/neon-cov.s: Add new vext test.
	* gas/arm/neon-cov.d: Ditto.
@
text
@d9959 31
a9989 2
      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
@


1.320
log
@2007-03-30  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (encode_thumb2_ldmstm): New function.
	(do_t_ldmstm): Generate 16-bit push/pop.  Use encode_thumb2_ldmstm.
	(do_t_push_pop):  Use encode_thumb2_ldmstm.

	gas/testsuite/
	* gas/arm/thumb2_ldmstm.d: New test.
	* gas/arm/thumb2_ldmstm.s: New test.
@
text
@d12818 1
d15931 2
a15932 2
 NUF(vext,      0b00000, 4, (RNDQ, oRNDQ, RNDQ, I7), neon_ext),
 NUF(vextq,     0b00000, 4, (RNQ,  oRNQ,  RNQ,  I7), neon_ext),
@


1.319
log
@	* config/tc-arm.c (arm_it): Add immisfloat field.
	(parse_qfloat_immediate): Disallow integer syntax for floating-point
	immediates. Fix hex immediates, handle 0.0 and -0.0 specially.
	(parse_neon_mov): Set immisfloat bit for operand if it parsed as a
	float.
	(neon_cmode_for_move_imm): Reject non-float immediates for float
	operands.
	(neon_move_immediate): Pass immisfloat bit to neon_cmode_for_move_imm.
@
text
@d9089 62
d9162 4
d9169 1
a9169 6
	  && inst.operands[0].reg <= 7
	  && !(inst.operands[1].imm & ~0xff)
	  && (inst.instruction == T_MNEM_stmia
	      ? inst.operands[0].writeback
	      : (inst.operands[0].writeback
		 == !(inst.operands[1].imm & (1 << inst.operands[0].reg)))))
d9171 1
a9171 5
	  if (inst.instruction == T_MNEM_stmia
	      && (inst.operands[1].imm & (1 << inst.operands[0].reg))
	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
	    as_warn (_("value stored for r%d is UNPREDICTABLE"),
		     inst.operands[0].reg);
d9173 9
a9181 13
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].imm;
	}
      else
	{
	  if (inst.operands[1].imm & (1 << 13))
	    as_warn (_("SP should not be in register list"));
	  if (inst.instruction == T_MNEM_stmia)
	    {
	      if (inst.operands[1].imm & (1 << 15))
		as_warn (_("PC should not be in register list"));
	      if (inst.operands[1].imm & (1 << inst.operands[0].reg))
d9184 5
d9190 2
a9191 1
	  else
d9193 4
a9196 7
	      if (inst.operands[1].imm & (1 << 14)
		  && inst.operands[1].imm & (1 << 15))
		as_warn (_("LR and PC should not both be in register list"));
	      if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
		  && inst.operands[0].writeback)
		as_warn (_("base register should not be in register list "
			   "when written back"));
d9198 4
d9204 3
a9206 4
	  inst.instruction |= inst.operands[0].reg << 16;
	  inst.instruction |= inst.operands[1].imm;
	  if (inst.operands[0].writeback)
	    inst.instruction |= WRITE_BACK;
d9895 1
a9895 1
    inst.instruction = THUMB_OP16 (inst.instruction);
d9903 1
a9903 1
      mask &= 0xff;
d9907 2
a9908 25
      if (mask & (1 << 13))
	inst.error =  _("SP not allowed in register list");
      if (inst.instruction == T_MNEM_push)
	{
	  if (mask & (1 << 15))
	    inst.error = _("PC not allowed in register list");
	}
      else
	{
	  if (mask & (1 << 14)
	      && mask & (1 << 15))
	    inst.error = _("LR and PC should not both be in register list");
	}
      if ((mask & (mask - 1)) == 0)
	{
	  /* Single register push/pop implemented as str/ldr.  */
	  if (inst.instruction == T_MNEM_push)
	    inst.instruction = 0xf84d0d04; /* str reg, [sp, #-4]! */
	  else
	    inst.instruction = 0xf85d0b04; /* ldr reg, [sp], #4 */
	  mask = ffs(mask) - 1;
	  mask <<= 12;
	}
      else
	inst.instruction = THUMB_OP32 (inst.instruction);
a9914 2

  inst.instruction |= mask;
@


1.318
log
@2007-03-24  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (do_t_ldmstm): Error on Thumb-2 addressing modes.
@
text
@d336 1
d4181 3
a4183 3
   The minus-zero case needs special handling, since it can't be encoded in the
   "quarter-precision" float format, but can nonetheless be loaded as an integer
   constant.  */
d4189 1
d4191 1
d4195 23
d4230 1
a4230 1
      if (is_quarter_float (fpword) || fpword == 0x80000000)
d5230 1
a5230 1
        ;
d11597 9
a11605 3
neon_cmode_for_move_imm (unsigned immlo, unsigned immhi, unsigned *immbits,
                         int *op, int size, enum neon_el_type type)
{
d12601 1
a12601 1
  int op, cmode;
d12616 3
a12618 1
  if ((cmode = neon_cmode_for_move_imm (immlo, immhi, &immbits, &op,
d12627 2
a12628 2
      if ((cmode = neon_cmode_for_move_imm (immlo, immhi, &immbits, &op,
                                            et.size, et.type)) == FAIL)
@


1.317
log
@2007-03-24  Paul Brook  <paul@@codesourcery.com>
	Mark Shinwell  <shinwell@@codesourcery.com>

	gas/
	* config/tc-arm.c (operand_parse_code): Add OP_oRRw.
	(parse_operands): Don't expect comma if first operand missing.
	Handle OP_oRRw.
	(do_srs): Encode register number, checking it is r13.  Update comment.
	(insns): Update SRS entries to take a register.

	gas/testsuite/
	* gas/arm/archv6.s: Add new SRS tests.
	* gas/arm/archv6.d: Update expected output.
	* gas/arm/thumb32.s: Add new SRS tests.
	* gas/arm/thumb32.d: Update expected output.
	* gas/arm/srs-t2.d: New.
	* gas/arm/srs-t2.l: New.
	* gas/arm/srs-t2.s: New.
	* gas/arm/srs-arm.d: New.
	* gas/arm/srs-arm.l: New.
	* gas/arm/srs-arm.s: New.

	opcodes/
	* arm-dis.c (arm_opcodes): Print SRS base register.
@
text
@d9128 3
@


1.316
log
@	gas/
	* config/tc-arm.c (md_apply_fix): Turn CZB instructions that
	attempt to jump to the next instruction into NOPs.
@
text
@d5455 1
d5560 1
a5560 1
      if (i > 0)
d5716 1
d6004 1
d7442 2
a7443 1
/* ARM V6 srs (argument parse).	 */
d7448 13
a7460 2
  inst.instruction |= inst.operands[0].imm;
  if (inst.operands[0].writeback)
d14988 4
a14991 4
 TUF(srsia,	8cd0500, e980c000, 1, (I31w),			   srs,  srs),
  UF(srsib,	9cd0500,           1, (I31w),			   srs),
  UF(srsda,	84d0500,	   1, (I31w),			   srs),
 TUF(srsdb,	94d0500, e800c000, 1, (I31w),			   srs,  srs),
@


1.315
log
@	gas/
	* config/tc-arm.c (do_mul): Don't warn about overlapping
	Rd and Rm operands when assembling for v6 or above.
	Correctly capitalize register names in the messages.
	(do_mlas): Likewise.  Delete spurious blank line.

	gas/testsuite/
	* gas/arm/mul-overlap.s: New.
	* gas/arm/mul-overlap.d: New.
	* gas/arm/mul-overlap.l: New.
	* gas/arm/mul-overlap-v6.s: New.
	* gas/arm/mul-overlap-v6.d: New.
@
text
@a18103 3
      if (value & ~0x7e)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d18105 7
a18111 1
      if (fixP->fx_done || !seg->use_rela_p)
d18114 1
a18114 1
	  newval |= ((value & 0x3e) << 2) | ((value & 0x40) << 3);
d18117 13
@


1.314
log
@	gas/
	* config/tc-arm.c (arm_copy_symbol_attributes): New.
	* config/tc-arm.h (arm_copy_symbol_attributes): Declare.
	(TC_COPY_SYMBOL_ATTRIBUTES): Define.
	* gas/symbols.c (copy_symbol_attributes): Use
	TC_COPY_SYMBOL_ATTRIBUTES.

	gas/testsuite/
	* gas/arm/thumbver.d, gas/arm/thumbver.s: New test.
@
text
@d7054 1
a7054 2
  /* This restriction does not apply to mls (nor to mla in v6, but
     that's hard to detect at present).	 */
d7056 1
d7058 1
a7058 1
    as_tsktsk (_("rd and rm should be different in mla"));
a7063 1

d7171 3
a7173 2
  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rd and rm should be different in mul"));
@


1.313
log
@2007-03-14  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (T16_32_TAB): Fix dec_sp encoding.

	gas/testsuite/
	* gas/arm/thumb2_add.d: Add tests using sp.
	* gas/arm/thumb2_add.s: Ditto.
@
text
@d20530 6
@


1.312
log
@2007-03-02  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (relax_immediate): Always return positive values.
	(relaxed_symbol_addr): New function.
	(relax_adr, relax_branch): Use it.
	(arm_relax_frag): Pass stretch argument.  Adjust infinite loop check.

	gas/testsuite/
	* gas/arm/relax_branch_align.d: New test.
	* gas/arm/relax_branch_align.s: New test.
@
text
@d8247 1
a8247 1
  X(dec_sp,80dd, f1bd0d00),			\
@


1.311
log
@	* config/tc-arm.c (do_vfp_nsyn_pop): Use fldmias/fldmiad.
@
text
@d16528 1
a16528 1
    return -4;
d16534 26
d16563 1
a16563 1
relax_adr (fragS *fragp, asection *sec)
d16573 1
a16573 1
  val = S_GET_VALUE(fragp->fr_symbol) + fragp->fr_offset;
d16576 1
a16576 3
  /* Fix the insn as the 4-byte version if the target address is not
     sufficiently aligned.  This is prevents an infinite loop when two
     instructions have contradictory range/alignment requirements.  */
d16578 1
a16578 1
    return -4;
d16605 1
a16605 1
relax_branch (fragS *fragp, asection *sec, int bits)
d16616 1
a16616 1
  val = S_GET_VALUE(fragp->fr_symbol) + fragp->fr_offset;
d16632 1
a16632 1
arm_relax_frag (asection *sec, fragS *fragp, long stretch ATTRIBUTE_UNUSED)
d16641 1
a16641 1
      newsize = relax_adr(fragp, sec);
d16661 1
a16661 1
      newsize = relax_adr(fragp, sec);
d16670 1
a16670 1
      newsize = relax_branch(fragp, sec, 11);
d16673 1
a16673 1
      newsize = relax_branch(fragp, sec, 8);
d16692 7
a16698 1
  if (newsize < 0)
a16699 1
      fragp->fr_var = -newsize;
a16701 1
      return -(newsize + oldsize);
d16703 1
a16703 1
  fragp->fr_var = newsize;
@


1.310
log
@2007-01-11  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_t_add_sub): Use Rd and Rs.

	gas/testsuite/
	* gas/arm/thumb2_add.d: Add test for missing operand.
	* gas/arm/thumb2_add.s: Ditto.
@
text
@d11260 1
a11260 1
    do_vfp_nsyn_opcode ("fldmdbs");
d11262 1
a11262 1
    do_vfp_nsyn_opcode ("fldmdbd");
@


1.309
log
@PR gas/3707
* config/tc-arm.c (md_begin): Cope with an NULL mcpu_fpu_opt variable.
@
text
@d8417 2
a8418 2
	      inst.instruction |= inst.operands[0].reg << 8;
	      inst.instruction |= inst.operands[1].reg << 16;
@


1.308
log
@2007-01-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_cpsi): Set mmod bit for 2 argument form.
	gas/testsuite/
	* gas/arm/archv6.s: Add more cpsie tests.
	* gas/arm/archv6.d: Ditto.
	opcodes/
	* arm-dis.c (arm_opcodes): Fix cpsie and cpsid entries.
@
text
@d19294 1
a19294 1
      if (!mcpu_cpu_opt)
d19296 1
a19296 1
      else if (ARM_CPU_HAS_FEATURE (*mcpu_fpu_opt, arm_ext_v5))
@


1.307
log
@	* config/tc-arm.c (do_neon_shl_imm): Swap rN, rM.
	(do_neon_qshl_imm): Likewise.
	(do_neon_rshl): New function. Handle rounding variants of
	v{q}shl-by-register.
	(insns): Use do_neon_rshl for vrshl, vqrshl.
@
text
@d551 1
d6832 5
a6836 1
  inst.instruction |= inst.operands[1].imm;
@


1.306
log
@2007-01-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (NEON_ENC_TAB): Fix encoding of vclt, vcle, vaclt
	and vacle.

	gas/testsuite/
	* gas/arm/neon-cov.d: Adjust expected output.
	* gas/arm/neon-omit.s: Add tests for vcgt and vcle.  Reorder vacle
	and vacle.
	* gas/arm/neon-omit.d: Adjust expected output.
@
text
@d11396 12
d11420 1
d11430 6
d11441 14
d15689 4
a15692 4
 NUF(vrshl,     0000500, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
 NUF(vrshlq,    0000500, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
 NUF(vqrshl,    0000510, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
 NUF(vqrshlq,   0000510, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
@


1.305
log
@2006-12-13  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_arch_option_table): Add v7-{a,r,m}.
	* doc/c-arm.texi: Fix spelling of ARMv7 profile variants.
@
text
@d10225 2
a10226 2
  X(vclt,	0x0000310, 0x1000e00, 0x1b10200),	\
  X(vcle,	0x0000300, 0x1200e00, 0x1b10180),	\
d15729 4
a15732 4
 NUF(vaclt,     0000e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
 NUF(vacltq,    0000e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
 NUF(vacle,     0200e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
 NUF(vacleq,    0200e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
@


1.304
log
@2006-12-01  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_force_relocation): Return 1 for relocs against
	function symbols.

	gas/testsuite/
	* gas/arm/thumbrel.s: New test.
	* gas/arm/thumbrel.d: New test.
@
text
@d19782 2
d19787 3
@


1.303
log
@2006-11-29  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_is_eabi): New function.
	* config/tc-arm.h (arm_is_eabi): New prototype.
	(THUMB_IS_FUNC): Use ELF function type for EABI objects.
	* doc/c-arm.texi (.thumb_func): Update documentation.
@
text
@d18965 6
@


1.302
log
@2006-11-29  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_vfp_sp_const, do_vfp_dp_const): Fix operans
	encoding.

	gas/testsuite/
	* gas/arm/vfpv3-const-conv.s: Improve test coverage.
	* gas/arm/vfpv3-const-conv.d: Adjust expected output.
	* gas/arm/vfp-neon-syntax_t2.d: Ditto.
	* gas/arm/vfp-neon-syntax.d: Ditto.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Fix bitfields for fconstd/fconstd.
@
text
@d235 6
@


1.301
log
@opcodes/
	* arm-dis.c (last_is_thumb): Delete.
	(enum map_type, last_type): New.
	(print_insn_data): New.
	(get_sym_code_type): Take MAP_TYPE argument.  Check the type of
	the right symbol.  Handle $d.
	(print_insn): Check for mapping symbols even without a normal
	symbol.  Adjust searching.  If $d is found see how much data
	to print.  Handle data.
gas/
	* config/tc-arm.h (md_cons_align): Define.
	(mapping_state): New prototype.
	* config/tc-arm.c (mapping_state): Make global.
gas/testsuite/
	* gas/arm/arm7t.d, gas/arm/neon-ldst-rm.d, gas/arm/thumb2_pool.d,
	gas/arm/tls.d: Update for $d support.
	* gas/arm/mapshort.d, gas/arm/mapshort.s: New test.
	* gas/elf/section2.e-armeabi: Update.
	* gas/elf/section2.e-armelf: New file.
	* gas/elf/elf.exp: Use it.
ld/testsuite/
	* ld-arm/mixed-app.d, ld-arm/tls-app.d, ld-arm/tls-lib.d: Update
	for $d support.
@
text
@d7722 2
a7723 2
  inst.instruction |= (inst.operands[1].imm & 15) << 16;
  inst.instruction |= (inst.operands[1].imm >> 4);
d7730 2
a7731 2
  inst.instruction |= (inst.operands[1].imm & 15) << 16;
  inst.instruction |= (inst.operands[1].imm >> 4);
@


1.300
log
@	gas/
	* config/tc-arm.c (do_t_czb): Rename to do_t_cbz.
	(insns): Adjust accordingly.
	(md_apply_fix): Alter comments to use CBZ instead of CZB.
@
text
@d2285 1
a2285 1
static void
@


1.299
log
@* config/tc-arm.c (arm_fix_adjustable) [OBJ_COFF]: Delete.
  (arm_fix_adjustable) [OBJ_ELF]: Use it on coff targets too.
* gas/arm/local_label_coff.s: New test.
* gas/arm/local_label_coff.d: New test.
* gas/arm/local_label_elf.s: New test.
* gas/arm/local_label_elf.d: New test.
* gas/arm/local_label_wince.s: New test.
* gas/arm/local_label_wince.d: New test.
@
text
@d8973 1
a8973 1
do_t_czb (void)
d14983 2
a14984 2
  UT(cbnz,      b900,    2, (RR, EXP), t_czb),
  UT(cbz,       b100,    2, (RR, EXP), t_czb),
d18030 2
a18031 2
    case BFD_RELOC_THUMB_PCREL_BRANCH7: /* CZB */
      /* CZB can only branch forward.  */
@


1.298
log
@2006-10-31  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_adjust_symtab): Don't use STT_ARM_16BIT
	for EABIv4.
@
text
@d18962 1
a18962 30
#ifdef OBJ_COFF
bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  /* This is a little hack to help the gas/arm/adrl.s test.  It prevents
     local labels from being added to the output symbol table when they
     are used with the ADRL pseudo op.  The ADRL relocation should always
     be resolved before the binbary is emitted, so it is safe to say that
     it is adjustable.  */
  if (fixP->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 1;

  /* This is a hack for the gas/all/redef2.s test.  This test causes symbols
     to be cloned, and without this test relocs would still be generated
     against the original, pre-cloned symbol.  Such symbols would not appear
     in the symbol table however, and so a valid reloc could not be
     generated.  So check to see if the fixup is against a symbol which has
     been removed from the symbol chain, and if it is, then allow it to be
     adjusted into a reloc against a section symbol. */
  if (fixP->fx_addsy != NULL
      && ! S_IS_LOCAL (fixP->fx_addsy)
      && symbol_next (fixP->fx_addsy) == NULL
      && symbol_next (fixP->fx_addsy) == symbol_previous (fixP->fx_addsy))
    return 1;
  
  return 0;
}
#endif

#ifdef OBJ_ELF
d19015 3
@


1.297
log
@2006-10-31  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (object_arch): New variable.
	(s_arm_object_arch): New function.
	(md_pseudo_table): Add object_arch.
	(aeabi_set_public_attributes): Obey object_arch.
	* doc/c-arm.texi: Document .object_arch.
@
text
@d19162 1
a19162 1
	      else
@


1.296
log
@2006-10-08  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (parse_big_immediate): 64-bit host fix.
	(parse_operands): Use parse_big_immediate for OP_NILO.
	(neon_cmode_for_logic_imm): Try smaller element sizes.
	(neon_cmode_for_move_imm): Ditto.
	(do_neon_logic): Handle .i64 pseudo-op.

	gas/testsuite/
	* testsuite/gas/arm/neon-cov.s: Test pseudo-instruction forms of
	vmov, vmvn and logic immediate instructions.
	* testsuite/gas/arm/neon-cov.d: ditto.
@
text
@d158 1
d3894 1
d3948 1
d20242 7
a20248 1
    
d20412 31
@


1.295
log
@* config/tc-arm.c (md_apply_fix): do not clear write_back bit
* gas/arm/iwmmxt-wldstbh.s: New file.
* gas/arm/iwmmxt-wldstbh.d: New file.
@
text
@d4016 1
a4016 1
   big (64-bit) immediate, as required by Neon VMOV and VMVN immediate
d4028 12
a4039 1
    inst.operands[i].imm = exp.X_add_number;
d5609 7
a5615 2
            /* Immediate gets verified properly later, so accept any now.  */
            po_imm_or_fail (INT_MIN, INT_MAX, TRUE);
d11416 2
a11417 2
  /* Handle .I8 and .I64 as pseudo-instructions.  */
  switch (size)
a11418 1
    case 8:
d11424 27
a11450 9
      break;
    case 64:
      /* Similarly, anything other than zero will be replicated in bits [63:32],
         which probably isn't want we want if we specified .I64.  */
      if (immediate != 0)
        goto bad_immediate;
      size = 32;
      break;
    default: ;
d11456 1
a11456 1
      return (size == 16) ? 0x9 : 0x1;
d11461 1
a11461 11
      return (size == 16) ? 0xb : 0x3;
    }
  else if (immediate == (immediate & 0x00ff0000))
    {
      *immbits = immediate >> 16;
      return 0x5;
    }
  else if (immediate == (immediate & 0xff000000))
    {
      *immbits = immediate >> 24;
      return 0x7;
d11502 2
a11503 1
   MVN).  */
d11516 2
a11517 2
  else if (size == 64 && neon_bits_same_in_bytes (immhi)
      && neon_bits_same_in_bytes (immlo))
d11519 13
a11531 7
      /* Check this one first so we don't have to bother with immhi in later
         tests.  */
      if (*op == 1)
        return FAIL;
      *immbits = (neon_squash_bits (immhi) << 4) | neon_squash_bits (immlo);
      *op = 1;
      return 0xe;
d11533 2
a11534 3
  else if (immhi != 0)
    return FAIL;
  else if (immlo == (immlo & 0x000000ff))
d11536 34
a11569 7
      /* 64-bit case was already handled. Don't allow MVN with 8-bit
         immediate.  */
      if ((size != 8 && size != 16 && size != 32)
          || (size == 8 && *op == 1))
        return FAIL;
      *immbits = immlo;
      return (size == 8) ? 0xe : (size == 16) ? 0x8 : 0x0;
d11571 2
a11572 1
  else if (immlo == (immlo & 0x0000ff00))
d11574 14
a11587 4
      if (size != 16 && size != 32)
        return FAIL;
      *immbits = immlo >> 8;
      return (size == 16) ? 0xa : 0x2;
d11589 2
a11590 1
  else if (immlo == (immlo & 0x00ff0000))
d11592 5
a11596 25
      if (size != 32)
        return FAIL;
      *immbits = immlo >> 16;
      return 0x4;
    }
  else if (immlo == (immlo & 0xff000000))
    {
      if (size != 32)
        return FAIL;
      *immbits = immlo >> 24;
      return 0x6;
    }
  else if (immlo == ((immlo & 0x0000ff00) | 0x000000ff))
    {
      if (size != 32)
        return FAIL;
      *immbits = (immlo >> 8) & 0xff;
      return 0xc;
    }
  else if (immlo == ((immlo & 0x00ff0000) | 0x0000ffff))
    {
      if (size != 32)
        return FAIL;
      *immbits = (immlo >> 16) & 0xff;
      return 0xd;
d11679 13
d11695 1
a11695 2
          cmode = neon_cmode_for_logic_imm (inst.operands[1].imm, &immbits,
                                            et.size);
d11699 1
a11699 2
          cmode = neon_cmode_for_logic_imm (inst.operands[1].imm, &immbits,
                                            et.size);
a11703 1
          immbits = inst.operands[1].imm;
a11709 1
          immbits = inst.operands[1].imm;
@


1.294
log
@bfd/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* archures.c: Add definition for bfd_mach_arm_iWMMXt2.
	* cpu-arm.c (processors): Add bfd_mach_arm_iWMMXt2.
	(arch_info_struct, bfd_arm_update_notes): Likewise.
	(architectures): Likewise.
	(bfd_arm_merge_machines): Check for iWMMXt2.
	* bfd-in2.h: Rebuild.

gas/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* config/tc-arm.c (arm_cext_iwmmxt2): New.
	(enum operand_parse_code): New code OP_RIWR_I32z.
	(parse_operands): Handle OP_RIWR_I32z.
	(do_iwmmxt_wmerge): New function.
	(do_iwmmxt_wldstd): Handle iwmmxt2 case where second operand is
	a register.
	(do_iwmmxt_wrwrwr_or_imm5): New function.
	(insns): Mark instructions as RIWR_I32z as appropriate.
	Also add torvsc<b,h,w>, wabs<b,h,w>, wabsdiff<b,h,w>,
	waddbhus<l,m>, waddhc, waddwc, waddsubhx, wavg4{r}, wmaddu{x,n},
	wmadds{x,n}, wmerge, wmiaxy{n}, wmiawxy{n}, wmul<sm,um>{r},
	wmulw<um,sm,l>{r}, wqmiaxy{n}, wqmulm{r}, wqmulwm{r}, wsubaddhx.
	(md_begin): Handle IWMMXT2.
	(arm_cpus): Add iwmmxt2.
	(arm_extensions): Likewise.
	(arm_archs): Likewise.

gas/testsuite/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* gas/arm/iwmmxt2.s: New file.
	* gas/arm/iwmmxt2.d: New file.

include/opcode/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* arm.h (ARM_CEXT_IWMMXT2, ARM_ARCH_IWMMXT2): Define.

opcodes/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* arm-dis.c (coprocessor_opcodes): The X-qualifier to WMADD may
	only be used with the default multiply-add operation, so if N is
	set, don't bother printing X.  Add new iwmmxt instructions.
	(IWMMXT_INSN_COUNT): Update.
	(iwmmxt_wwssnames): Qualify "wwss" names at index 2, 6, 10 and 14
	with a 'c' suffix.
	(print_insn_coprocessor): Check for iWMMXt2.  Handle format
	specifiers 'r', 'i'.
@
text
@a18164 2
      if (value == 0)
	newval &= ~WRITE_BACK;
@


1.293
log
@2006-09-16  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (s_arm_unwind_movsp): Add offset argument.
	* doc/c-arm.texi (movsp): Document offset argument.

	gas/testsuite/
	* gas/arm/unwind.s: Test two argument form of .movsp.
	* gas/arm/unwind.d: Update expected output.
	* gas/arm/unwind_vxworks.d: Ditto.
@
text
@d204 2
d5376 1
d5799 3
d7850 9
d7897 17
a7913 1
  encode_arm_cp_address (1, TRUE, FALSE, 0);
d7933 50
d15953 1
a15953 1
 cCE(wrorh,	e700040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15955 1
a15955 1
 cCE(wrorw,	eb00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15957 1
a15957 1
 cCE(wrord,	ef00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15964 1
a15964 1
 cCE(wsllh,	e500040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15966 1
a15966 1
 cCE(wsllw,	e900040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15968 1
a15968 1
 cCE(wslld,	ed00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15970 1
a15970 1
 cCE(wsrah,	e400040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15972 1
a15972 1
 cCE(wsraw,	e800040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15974 1
a15974 1
 cCE(wsrad,	ec00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15976 1
a15976 1
 cCE(wsrlh,	e600040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15978 1
a15978 1
 cCE(wsrlw,	ea00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d15980 1
a15980 1
 cCE(wsrld,	ee00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
d16017 60
d19312 3
a19314 1
  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt))
d19693 1
d19743 1
d19759 1
@


1.292
log
@2006-09-16  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (thumb32_negate_data_op): Consistently use
	unsigned int to avoid 64-bit host problems.
@
text
@d3631 1
d3640 10
d3667 1
a3667 1
  unwind.fp_offset = unwind.frame_size;
@


1.291
log
@PR gas/3172
* config/tc-arm.c (parse_typed_reg_or_scalar): Accept wCg class registers
  as a sub-class of wC registers.
@
text
@d17239 1
a17239 1
thumb32_negate_data_op (offsetT *instruction, offsetT value)
d17243 1
a17243 1
  offsetT negated, inverted;
d17304 1
a17304 1
  if (value == FAIL)
@


1.290
log
@2006-09-08  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (insns): Allow ARM IT pseudo-insn on all cores.

	gas/testsuite/
	* gas/arm/arm-it.s: New test.
	* gas/arm/arm-it.d: New test.
@
text
@d1264 3
a1266 1
              || reg->type == REG_TYPE_NQ)))
@


1.289
log
@2006-09-07  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (parse_operands): Mark operand as present.

	gas/testsuite/
	* gas/arm/neon-omit.s: Test three-argument variants.
	* gas/arm/neon-omit.d: Update expected output.
@
text
@d14831 3
a14833 1
 /* ARM does not really have an IT instruction.  */
@


1.288
log
@2006-09-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_neon_dyadic_if_i): Remove.
	(do_neon_dyadic_if_i_d): Avoid setting U bit.
	(do_neon_mac_maybe_scalar): Ditto.
	(do_neon_dyadic_narrow): Force operand type to NT_integer.
	(insns): Remove out of date comments.

	gas/testsuite/
	* gas/arm/neon-cov.s: Test .u and .s aliases for .i suffixes.
	* gas/arm/neon-cov.d: Adjust expected output.

	opcodes/
	* arm-dis.c (neon_opcode): Fix suffix on VMOVN.
@
text
@d5569 1
@


1.287
log
@gas:
	* config/tc-arm.c (s_arm_unwind_save_mmxwr): Correct condition for
	merging with previous long opcode.

gas/testsuite:
	* gas/arm/unwind.s: Test not merging iWMMXt register save with
	previous long opcode.
	* gas/arm/unwind.d, gas/arm/unwind_vxworks.d: Update.
@
text
@a11620 6
do_neon_dyadic_if_i (void)
{
  neon_dyadic_misc (NT_unsigned, N_IF_32, 0);
}

static void
d11623 3
a11625 1
  neon_dyadic_misc (NT_unsigned, N_IF_32, 0);
d11840 5
a11844 1
    do_neon_dyadic_if_i ();
d12495 3
d15539 1
a15539 1
  /* Comparison. Type I8 I16 I32 F32. Non-immediate -> neon_dyadic_if_i.  */
a15545 1
  /* If not scalar, fall back to neon_dyadic_if_i.  */
@


1.286
log
@	* config/tc-arm.c (md_assemble): Improve diagnostic when attempting
	to use ARM instructions on non-ARM-supporting cores.
	(autoselect_thumb_from_cpu_variant): New function. Switch on Thumb
	mode automatically based on cpu variant.
	(md_begin): Call above function.
@
text
@d3451 1
a3451 1
		  || ((mask & op) == (1u << (reg - 1))))
@


1.285
log
@	* config/tc-arm.c (opcode_lookup): Allow Neon type suffixes to be
	recognized in non-unified syntax mode.
@
text
@d13847 1
a13847 1
  else
d13880 6
d18966 10
d19076 2
@


1.284
log
@* config/tc-arm.c (WARN_DEPRECATED): Enable.
@
text
@d13585 3
d13590 1
a13590 1
     '.' (in unified mode only), or end of string.  */
d13592 1
a13592 1
    if (*end == ' ' || (unified_syntax && *end == '.'))
d13603 3
a13605 1
      if (end[1] == 'w')
d13607 1
a13607 1
      else if (end[1] == 'n')
d13618 2
a13619 1
	  /* See if we have a Neon type suffix.  */
@


1.283
log
@* bfd.c (bfd_get_sign_extend_vma): Add cases for pe-arm-little and pei-arm-little.
* coff-arm.c (coff_arm_rtype_to_howto) [COFF_WITH_PE]: Handle ARM_SECREL.
  (coff_arm_reloc_type_lookup): Map BFD_RELOC_32_SECREL to  ARM_SECREL.
* pe-arm.c [COFF_SECTION_ALIGNMENT_ENTRIES]: Define.
* pei-arm.c [TARGET_UNDERSCORE]: Define for ARM_WINCE like in pe-arm.c.
  [COFF_SECTION_ALIGNMENT_ENTRIES]: Define.

* config/tc-arm.c: Move "dwarf2dbg.h" inclusion out of OBJ_ELF only block.
  (pe_directive_secrel) [TE_PE]: New function.
  (md_pseudo_table) [!OBJ_ELF]: Handle 2byte, 4byte, 8byte, file, loc, loc_mark_labels.
  [TE_PE]: Handle secrel32.
  (output_relax_insn): Remove OBJ_ELF around dwarf2_emit_insn call.
  (output_inst): Remove OBJ_ELF around dwarf2_emit_insn call.
  (arm_frob_label): Remove OBJ_ELF around dwarf2_emit_label call.
  (md_section_align): Only round section sizes here for AOUT targets.
  (tc_arm_regname_to_dw2regnum): Move out for OBJ_ELF only block.
  (tc_pe_dwarf2_emit_offset): New function.
  (md_apply_fix) [TE_PE]: Handle BFD_RELOC_32_SECREL.
  (cons_fix_new_arm): Handle O_secrel.
* config/tc-arm.h : Move DWARF2_LINE_MIN_INSN_LENGTH, DWARF2_DEFAULT_RETURN_COLUMN and DWARF2_CIE_DATA_ALIGNMENT out of OBJ_ELF only block.
  [TE_PE]: Define O_secrel, TC_DWARF2_EMIT_OFFSET, and declare tc_pe_dwarf2_emit_offset.

* ld-pe/pe.exp: Enable tests on arm-wince-pe.
* ld-pe/secrel.d: Adjust test to work on arm-wince-pe too.
@
text
@d45 1
a45 2
/* XXX Set this to 1 after the next binutils release.  */
#define WARN_DEPRECATED 0
@


1.282
log
@gas:
	* config/tc-arm.c (parse_operands): Handle invalid register name
	for OP_RIWR_RIWC.

gas/testsuite:
	* gas/arm/iwmmxt-bad.s: Test invalid register names for wldrw and
	wstrw.
	* gas/arm/iwmmxt-bad.l: Update.
@
text
@a39 1
#include "dwarf2dbg.h"
d43 2
d3882 22
d3952 9
d3965 3
a13418 1
#ifdef OBJ_ELF
a13421 1
#endif
a13488 1
#ifdef OBJ_ELF
a13489 1
#endif
a13939 1
#ifdef OBJ_ELF
a13940 1
#endif
d16411 15
a16425 1
#ifdef OBJ_ELF
a16426 4
#else
  /* Round all sects to multiple of 4.	*/
  return (size + 3) & ~3;
#endif
d16926 10
d16949 1
a16949 2
/* Initialize the DWARF-2 unwind information for this procedure.  */

d16951 1
a16951 1
tc_arm_frame_initial_instructions (void)
d16953 6
a16958 1
  cfi_add_CFA_def_cfa (REG_SP, 0);
d16960 1
a16960 2
#endif /* OBJ_ELF */

d17952 3
d18493 3
d18678 8
@


1.281
log
@gas:
	* config/tc-arm.c (enum operand_parse_code): Add OP_RIWC_RIWG.
	(parse_operands): Handle it.
	(insns): Use it for tmcr and tmrc.

gas/testsuite:
	* gas/arm/iwmmxt.s: Test tmcr and tmrc with wcgr registers.
	* gas/arm/iwmmxt.d: Update.
@
text
@d5752 4
a5755 3
	    if (rege->type != REG_TYPE_MMXWR
		&& rege->type != REG_TYPE_MMXWC
		&& rege->type != REG_TYPE_MMXWCG)
@


1.280
log
@2006-07-19  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (insns): Fix rbit Arm opcode.
	gas/testsuite/
	* gas/arm/archv6t2.d: Adjust expected output for rbit.
	opcodes/
	* armd-dis.c (arm_opcodes): Fix rbit opcode.
@
text
@d5373 1
d5764 15
d15731 1
a15731 1
 cCE(tmcr,	e000110, 2, (RIWC, RR),		    rn_rd),
d15742 1
a15742 1
 cCE(tmrc,	e100110, 2, (RR, RIWC),		    rd_rn),
@


1.279
log
@2006-07-18  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_T32_ADD_IMM.

	gas/
	* tc-arm.c (do_t_add_sub): Use addw/subw when source is PC.
	(md_convert_frag): Use correct reloc for add_pc.  Use
	BFD_RELOC_ARM_T32_ADD_IMM for normal add/sum.
	(md_apply_fix): Handle BFD_RELOC_ARM_T32_ADD_IMM.
	(arm_force_relocation): Handle BFD_RELOC_ARM_T32_ADD_IMM.

	gas/testsuite/
	* gas/arm/thumb2_add.d: New test.
	* gas/arm/thumb2_add.s: New test.
@
text
@d14761 1
a14761 1
 TCE(rbit,	3ff0f30, fa90f0a0, 2, (RR, RR),			    rd_rm, t_rbit),
@


1.278
log
@gas/
	* config/tc-arm.c (s_arm_unwind_save_vfp_armv6): New.  Parse
	a directive saving VFP registers for ARMv6 or later.
	(s_arm_unwind_save): Add parameter arch_v6 and call
	s_arm_unwind_save_vfp or s_arm_unwind_save_vfp_armv6 as
	appropriate.
	(md_pseudo_table): Add entry for new "vsave" directive.
	* doc/c-arm.texi: Correct error in example for "save"
	directive (fstmdf -> fstmdx).  Also document "vsave" directive.
@
text
@d8189 4
a8195 4
	      int add;

	      add = (inst.instruction == T_MNEM_add
		     || inst.instruction == T_MNEM_adds);
d8225 16
a8240 3
	      /* ??? Convert large immediates to addw/subw.  */
	      inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
a8242 1
	      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
d16151 4
a16154 1
	  reloc_type = BFD_RELOC_ARM_T32_IMMEDIATE;
d16171 4
a16174 1
	  reloc_type = BFD_RELOC_ARM_T32_IMMEDIATE;
d17582 1
d17603 3
a17605 2
      /* FUTURE: Implement analogue of negate_data_op for T32.  */
      if (fixP->fx_r_type == BFD_RELOC_ARM_T32_IMMEDIATE)
d17611 2
a17612 1
      else
d17614 4
d18636 1
@


1.277
log
@(enum parse_operand_result): Move outside of #ifdef OBJ_ELF so that non-ELF
targeted ARM ports can build.
@
text
@d3277 51
a3327 1
/* Parse a directive saving VFP registers.  */
d3565 2
a3566 1
/* Parse an unwind_save directive.  */
d3569 1
a3569 1
s_arm_unwind_save (int ignored ATTRIBUTE_UNUSED)
d3606 6
a3611 1
    case REG_TYPE_VFD:	   s_arm_unwind_save_vfp ();	return;
d3921 1
@


1.276
log
@	* include/elf/arm.h: Correct names of R_ARM_LDC_G{0,1,2}
	to R_ARM_LDC_SB_G{0,1,2} respectively.

bfd/
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (R_ARM_ALU_PC_G0_NC, R_ARM_ALU_PC_G0,
	R_ARM_ALU_PC_G1_NC, R_ARM_ALU_PC_G1, R_ARM_ALU_PC_G2,
	R_ARM_LDR_PC_G1, R_ARM_LDR_PC_G2, R_ARM_LDRS_PC_G0,
	R_ARM_LDRS_PC_G1, R_ARM_LDRS_PC_G2, R_ARM_LDC_PC_G0,
	R_ARM_LDC_PC_G1, R_ARM_LDC_PC_G2, R_ARM_ALU_SB_G0_NC,
	R_ARM_ALU_SB_G0, R_ARM_ALU_SB_G1_NC, R_ARM_ALU_SB_G1,
	R_ARM_ALU_SB_G2, R_ARM_LDR_SB_G0, R_ARM_LDR_SB_G1,
	R_ARM_LDR_SB_G2, R_ARM_LDRS_SB_G0, R_ARM_LDRS_SB_G1,
	R_ARM_LDRS_SB_G2, R_ARM_LDC_SB_G0, R_ARM_LDC_SB_G1,
	R_ARM_LDC_SB_G2): New relocation types.
	(R_ARM_PC13): Rename to AAELF name R_ARM_LDR_PC_G0 and
	adjust HOWTO entry to be consistent with R_ARM_LDR_PC_G1
	and friends.
	(elf32_arm_howto_table_3): Delete; contents merged into
	elf32_arm_howto_table_2.
	(elf32_arm_howto_from_type): Adjust correspondingly.
	(elf32_arm_reloc_map): Extend with the above relocations.
	(calculate_group_reloc_mask): New function.
	(identify_add_or_sub): New function.
	(elf32_arm_final_link_relocate): Support for the above
	relocations.
	* reloc.c: Add enumeration entries for BFD_RELOC_ARM_...
	codes to correspond to the above relocations.

gas/
	* config/tc-arm.c (enum parse_operand_result): New.
	(struct group_reloc_table_entry): New.
	(enum group_reloc_type): New.
	(group_reloc_table): New array.
	(find_group_reloc_table_entry): New function.
	(parse_shifter_operand_group_reloc): New function.
	(parse_address_main): New function, incorporating code
	from the old parse_address function.  To be used via...
	(parse_address): wrapper for parse_address_main; and
	(parse_address_group_reloc): new function, likewise.
	(enum operand_parse_code): New codes OP_SHG, OP_ADDRGLDR,
	OP_ADDRGLDRS, OP_ADDRGLDC.
	(parse_operands): Support for these new operand codes.
	New macro po_misc_or_fail_no_backtrack.
	(encode_arm_cp_address): Preserve group relocations.
	(insns): Modify to use the above operand codes where group
	relocations are permitted.
	(md_apply_fix): Handle the group relocations
	ALU_PC_G0_NC through LDC_SB_G2.
	(tc_gen_reloc): Likewise.
	(arm_force_relocation): Leave group relocations for the linker.
	(arm_fix_adjustable): Likewise.

gas/testsuite/
	* gas/arm/group-reloc-alu.d: New test.
	* gas/arm/group-reloc-alu-encoding-bad.d: New test.
	* gas/arm/group-reloc-alu-encoding-bad.l: New test.
	* gas/arm/group-reloc-alu-encoding-bad.s: New test.
	* gas/arm/group-reloc-alu-parsing-bad.d: New test.
	* gas/arm/group-reloc-alu-parsing-bad.l: New test.
	* gas/arm/group-reloc-alu-parsing-bad.s: New test.
	* gas/arm/group-reloc-alu.s: New test.
	* gas/arm/group-reloc-ldc.d: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldc.s: New test.
	* gas/arm/group-reloc-ldr.d: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldr.s: New test.
	* gas/arm/group-reloc-ldrs.d: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldrs.s: New test.

ld/testsuite/
	* ld-arm/group-relocs-alu-bad.d: New test.
	* ld-arm/group-relocs-alu-bad.s: New test.
	* ld-arm/group-relocs.d: New test.
	* ld-arm/group-relocs-ldc-bad.d: New test.
	* ld-arm/group-relocs-ldc-bad.s: New test.
	* ld-arm/group-relocs-ldr-bad.d: New test.
	* ld-arm/group-relocs-ldr-bad.s: New test.
	* ld-arm/group-relocs-ldrs-bad.d: New test.
	* ld-arm/group-relocs-ldrs-bad.s: New test.
	* ld-arm/group-relocs.s: New test.
	* ld-arm/arm-elf.exp: Wire in new tests.
@
text
@d82 7
a97 7
/* Bit N indicates that an R_ARM_NONE relocation has been output for
   __aeabi_unwind_cpp_prN already if set. This enables dependencies to be
   emitted only once per section, to save unnecessary bloat.  */
static unsigned int marked_pr_dependency = 0;

#endif /* OBJ_ELF */

@


1.275
log
@	* config/tc-arm.c (do_vfp_nsyn_ldr_str): Remove, fold into...
	(do_neon_ldr_str): Always defer to VFP encoding routines, which handle
	relocs properly.
@
text
@d82 9
d4273 162
d4467 3
a4469 2
static int
parse_address (char **str, int i)
d4487 1
a4487 1
	return FAIL;
d4490 1
a4490 1
      return SUCCESS;
d4496 1
a4496 1
      return FAIL;
d4515 1
a4515 1
	      return FAIL;
d4527 1
a4527 1
              return FAIL;
d4541 55
a4595 2
	  if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	    return FAIL;
d4602 1
a4602 1
      return FAIL;
d4615 1
a4615 1
	    return FAIL;
d4620 1
a4620 1
	      return FAIL;
d4625 1
a4625 1
	      return FAIL;
d4628 1
a4628 1
	  return SUCCESS;
d4638 1
a4638 1
	      return FAIL;
d4656 1
a4656 1
		  return FAIL;
d4666 1
a4666 1
		return FAIL;
d4680 14
a4693 1
  return SUCCESS;
d5292 1
d5294 3
d5351 1
d5409 8
d5799 15
d5818 5
d6176 2
a6177 1
   of BFD_ARM_CP_OFF_IMM.  */
d6219 10
a6228 4
  else if (thumb_mode)
    inst.reloc.type = BFD_RELOC_ARM_T32_CP_OFF_IMM;
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
d14321 2
a14322 2
 tCE(add,	0800000, add,	   3, (RR, oRR, SH), arit, t_add_sub),
 tC3(adds,	0900000, adds,	   3, (RR, oRR, SH), arit, t_add_sub),
d14350 4
a14353 4
 tCE(ldr,	4100000, ldr,	   2, (RR, ADDR),    ldst, t_ldst),
 tC3(ldrb,	4500000, ldrb,	   2, (RR, ADDR),    ldst, t_ldst),
 tCE(str,	4000000, str,	   2, (RR, ADDR),    ldst, t_ldst),
 tC3(strb,	4400000, strb,	   2, (RR, ADDR),    ldst, t_ldst),
d14437 4
a14440 4
 TCE(ldc,	c100000, ec100000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TC3(ldcl,	c500000, ec500000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCE(stc,	c000000, ec000000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TC3(stcl,	c400000, ec400000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
d14469 6
a14474 6
 tC3(ldrh,	01000b0, ldrh,     2, (RR, ADDR), ldstv4, t_ldst),
 tC3(strh,	00000b0, strh,     2, (RR, ADDR), ldstv4, t_ldst),
 tC3(ldrsh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tC3(ldrsb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ld,sh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ld,sb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),
d14495 4
a14498 4
 TUF(ldc2,	c100000, fc100000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(ldc2l,	c500000, fc500000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(stc2,	c000000, fc000000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(stc2l,	c400000, fc400000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
d14534 2
a14535 2
 TC3(ldrd,	00000d0, e9500000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),
 TC3(strd,	00000f0, e9400000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),
d14751 9
a14759 9
 cCL(ldfs,	c100100, 2, (RF, ADDR),	     rd_cpaddr),
 cCL(ldfd,	c108100, 2, (RF, ADDR),	     rd_cpaddr),
 cCL(ldfe,	c500100, 2, (RF, ADDR),	     rd_cpaddr),
 cCL(ldfp,	c508100, 2, (RF, ADDR),	     rd_cpaddr),

 cCL(stfs,	c000100, 2, (RF, ADDR),	     rd_cpaddr),
 cCL(stfd,	c008100, 2, (RF, ADDR),	     rd_cpaddr),
 cCL(stfe,	c400100, 2, (RF, ADDR),	     rd_cpaddr),
 cCL(stfp,	c408100, 2, (RF, ADDR),	     rd_cpaddr),
d15202 2
a15203 2
 cCE(flds,	d100a00, 2, (RVS, ADDR),      vfp_sp_ldst),
 cCE(fsts,	d000a00, 2, (RVS, ADDR),      vfp_sp_ldst),
d15261 2
a15262 2
 cCE(fldd,	d100b00, 2, (RVD, ADDR),      vfp_dp_ldst),
 cCE(fstd,	d000b00, 2, (RVD, ADDR),      vfp_dp_ldst),
d15336 2
a15337 2
 NCE(vldr,      d100b00, 2, (RVSD, ADDR), neon_ldr_str),
 NCE(vstr,      d000b00, 2, (RVSD, ADDR), neon_ldr_str),
d15793 8
a15800 8
 cCE(cfldrs,	c100400, 2, (RMF, ADDR),	      rd_cpaddr),
 cCE(cfldrd,	c500400, 2, (RMD, ADDR),	      rd_cpaddr),
 cCE(cfldr32,	c100500, 2, (RMFX, ADDR),	      rd_cpaddr),
 cCE(cfldr64,	c500500, 2, (RMDX, ADDR),	      rd_cpaddr),
 cCE(cfstrs,	c000400, 2, (RMF, ADDR),	      rd_cpaddr),
 cCE(cfstrd,	c400400, 2, (RMD, ADDR),	      rd_cpaddr),
 cCE(cfstr32,	c000500, 2, (RMFX, ADDR),	      rd_cpaddr),
 cCE(cfstr64,	c400500, 2, (RMDX, ADDR),	      rd_cpaddr),
d17199 1
d18075 169
d18363 28
d18559 6
d18642 6
@


1.274
log
@	* config/tc-arm.c (stdarg.h): include.
	(arm_it): Add uncond_value field. Add isvec and issingle to operand
	array.
	(arm_reg_type): Add REG_TYPE_VFSD (single or double VFP reg) and
	REG_TYPE_NSDQ (single, double or quad vector reg).
	(reg_expected_msgs): Update.
	(BAD_FPU): Add macro for unsupported FPU instruction error.
	(parse_neon_type): Support 'd' as an alias for .f64.
	(parse_typed_reg_or_scalar): Support REG_TYPE_VFSD, REG_TYPE_NSDQ
	sets of registers.
	(parse_vfp_reg_list): Don't update first arg on error.
	(parse_neon_mov): Support extra syntax for VFP moves.
	(operand_parse_code): Add OP_RVSD, OP_RNSDQ, OP_VRSDLST, OP_RVSD_IO,
	OP_RNSDQ_RNSC, OP_RVC_PSR, OP_APSR_RR, OP_oRNSDQ.
	(parse_operands): Support isvec, issingle operands fields, new parse
	codes above.
	(do_vfp_nsyn_mrs, do_vfp_nsyn_msr): New functions. Support VFP mrs,
	msr variants.
	(do_mrs, do_msr, do_t_mrs, do_t_msr): Add support for above.
	(NEON_ENC_TAB): Add vnmul, vnmla, vnmls, vcmp, vcmpz, vcmpe, vcmpez.
	(NEON_ENC_SINGLE, NEON_ENC_DOUBLE): Define macros.
	(NEON_SHAPE_DEF): New macro. Define table of possible instruction
	shapes.
	(neon_shape): Redefine in terms of above.
	(neon_shape_class): New enumeration, table of shape classes.
	(neon_shape_el): New enumeration. One element of a shape.
	(neon_shape_el_size): Register widths of above, where appropriate.
	(neon_shape_info): New struct. Info for shape table.
	(neon_shape_tab): New array.
	(neon_type_mask): Add N_F64, N_VFP. Update N_MAX_NONSPECIAL.
	(neon_check_shape): Rewrite as...
	(neon_select_shape): New function to classify instruction shapes,
	driven by new table neon_shape_tab array.
	(neon_quad): New function. Return 1 if shape should set Q flag in
	instructions (or equivalent), 0 otherwise.
	(type_chk_of_el_type): Support F64.
	(el_type_of_type_chk): Likewise.
	(neon_check_type): Add support for VFP type checking (VFP data
	elements fill their containing registers).
	(do_vfp_cond_or_thumb): Fill in condition field in ARM mode, or 0xE
	in thumb mode for VFP instructions.
	(do_vfp_nsyn_opcode): New function. Look up the opcode in argument,
	and encode the current instruction as if it were that opcode.
	(try_vfp_nsyn): New. If this looks like a VFP instruction with ARGS
	arguments, call function in PFN.
	(do_vfp_nsyn_add_sub, do_vfp_nsyn_mla_mls, do_vfp_nsyn_mul)
	(do_vfp_nsyn_abs_neg, do_vfp_nsyn_ldm_stm, do_vfp_nsyn_ldr_str)
	(do_vfp_nsyn_sqrt, do_vfp_nsyn_div, do_vfp_nsyn_nmul)
	(do_vfp_nsyn_cmp, nsyn_insert_sp, do_vfp_nsyn_push)
	(do_vfp_nsyn_pop, do_vfp_nsyn_cvt, do_vfp_nsyn_cvtz): New functions.
	Redirect Neon-syntax VFP instructions to VFP instruction handlers.
	(do_neon_dyadic_i_su, do_neon_dyadic_i64_su, do_neon_shl_imm)
	(do_neon_qshl_imm, do_neon_logic, do_neon_bitfield)
	(neon_dyadic_misc, neon_compare, do_neon_tst, do_neon_qdmulh)
	(do_neon_fcmp_absolute, do_neon_step, do_neon_sli, do_neon_sri)
	(do_neon_qshlu_imm, neon_move_immediate, do_neon_mvn, do_neon_ext)
	(do_neon_rev, do_neon_dup, do_neon_rshift_round_imm, do_neon_trn)
	(do_neon_zip_uzp, do_neon_sat_abs_neg, do_neon_pair_long)
	(do_neon_recip_est, do_neon_cls, do_neon_clz, do_neon_cnt)
	(do_neon_swp): Use neon_select_shape not neon_check_shape. Use
	neon_quad.
	(vfp_or_neon_is_neon): New function. Call if a mnemonic shared
	between VFP and Neon turns out to belong to Neon. Perform
	architecture check and fill in condition field if appropriate.
	(do_neon_addsub_if_i, do_neon_mac_maybe_scalar, do_neon_abs_neg)
	(do_neon_cvt): Add support for VFP variants of instructions.
	(neon_cvt_flavour): Extend to cover VFP conversions.
	(do_neon_mov): Rewrite to use neon_select_shape. Add support for VFP
	vmov variants.
	(do_neon_ldr_str): Handle single-precision VFP load/store.
	(do_neon_ld_st_interleave, do_neon_ld_st_lane, do_neon_ld_dup): Use
	NS_NULL not NS_IGNORE.
	(opcode_tag): Add OT_csuffixF for operands which either take a
	conditional suffix, or have 0xF in the condition field.
	(md_assemble): Add support for OT_csuffixF.
	(NCE): Replace macro with...
	(NCE_tag, NCE, NCEF): New macros.
	(nCE): Replace macro with...
	(nCE_tag, nCE, nCEF): New macros.
	(insns): Add support for VFP insns or VFP versions of insns msr,
	mrs, vsqrt, vdiv, vnmul, vnmla, vnmls, vcmp, vcmpe, vpush, vpop,
	vcvtz, vmul, vmla, vmls, vadd, vsub, vabs, vneg, vldm, vldmia,
	vldbdb, vstm, vstmia, vstmdb, vldr, vstr, vcvt, vmov. Group shared
	VFP/Neon insns together.
@
text
@a10616 9
do_vfp_nsyn_ldr_str (int is_ldr)
{
  if (is_ldr)
    do_vfp_nsyn_opcode ("flds");
  else
    do_vfp_nsyn_opcode ("fsts");
}

static void
a12637 2
  unsigned offsetbits;
  int offset_up = 1;
d12642 4
a12645 17
      do_vfp_nsyn_ldr_str (is_ldr);
      return;
    }

  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  
  constraint (inst.reloc.pc_rel && !is_ldr,
              _("PC-relative addressing unavailable with VSTR"));
  
  constraint (!inst.reloc.pc_rel && inst.reloc.exp.X_op != O_constant,
              _("Immediate value must be a constant"));
  
  if (inst.reloc.exp.X_add_number < 0)
    {
      offset_up = 0;
      offsetbits = -inst.reloc.exp.X_add_number / 4;
a12647 19
    offsetbits = inst.reloc.exp.X_add_number / 4;
  
  /* FIXME: Does this catch everything?  */
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
              || inst.operands[1].postind || inst.operands[1].writeback
              || inst.operands[1].immisreg || inst.operands[1].shifted,
              BAD_ADDR_MODE);
  constraint ((inst.operands[1].imm & 3) != 0,
              _("Offset must be a multiple of 4"));
  constraint (offsetbits != (offsetbits & 0xff),
              _("Immediate offset out of range"));

  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= offsetbits & 0xff;
  inst.instruction |= offset_up << 23;
  
  do_vfp_cond_or_thumb ();

  if (inst.reloc.pc_rel)
d12649 2
a12650 2
      if (thumb_mode)
        inst.reloc.type = BFD_RELOC_ARM_T32_CP_OFF_IMM;
d12652 1
a12652 1
        inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
a12653 2
  else
    inst.reloc.type = BFD_RELOC_UNUSED;
@


1.273
log
@remove some duplicate #include's.
@
text
@d29 1
d293 4
d321 1
d323 1
d432 1
d434 1
d471 1
d473 1
d639 1
d1119 5
d1147 1
d1248 8
a1255 3
  /* Undo polymorphism for Neon D and Q registers.  */
  if (type == REG_TYPE_NDQ
      && (reg->type == REG_TYPE_NQ || reg->type == REG_TYPE_VFD))
d1545 1
a1545 1
parse_vfp_reg_list (char **str, unsigned int *pbase, enum reg_list_els etype)
d1547 1
d1557 1
a1557 1
  if (**str != '{')
d1563 1
a1563 1
  (*str)++;
d1604 1
a1604 1
      new_base = arm_typed_reg_parse (str, regtype, &regtype, NULL);
d1643 1
a1643 1
      if (**str == '-') /* We have the start of a range expression */
d1647 1
a1647 1
	  (*str)++;
d1649 1
a1649 1
	  if ((high_range = arm_typed_reg_parse (str, regtype, NULL, NULL))
d1684 1
a1684 1
  while (skip_past_comma (str) != FAIL);
d1686 1
a1686 1
  (*str)++;
d1705 2
d4763 2
a4764 3
   Note particularly the abuse of ".regisimm" to signify a Neon register.
   Up to three operands may be read; this function handles setting the
   ".present" field for each operand itself.
d4794 1
a4794 1
  else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NDQ, &rtype, &optype))
d4804 2
d4811 2
a4812 2
          /* Case 5: VMOV<c><q> <Dm>, <Rd>, <Rn>.  */
          inst.operands[i-1].regisimm = 1;
d4815 1
a4815 1
          inst.operands[i++].present = 1;
d4822 11
a4832 7
          if (skip_past_comma (&ptr) == FAIL)
            goto wanted_comma;
          if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
            goto wanted_arm;
          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].present = 1;
a4834 1
        {
d4836 4
a4839 4
             Case 3: VMOV<c><q>.<dt> <Dd>, #<float-imm>  */
          if (!thumb_mode && (inst.instruction & 0xf0000000) != 0xe0000000)
            goto bad_cond;
        }
a4840 1
        {
d4843 3
a4845 5
          if (!thumb_mode && (inst.instruction & 0xf0000000) != 0xe0000000)
            goto bad_cond;
        }
      else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NDQ, &rtype, &optype))
               != FAIL)
d4848 3
a4850 3
             Case 1: VMOV<c><q> <Dd>, <Dm>  */
          if (!thumb_mode && (inst.instruction & 0xf0000000) != 0xe0000000)
            goto bad_cond;
d4855 2
d4859 23
d4917 1
a4917 1
          if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFD, NULL, &optype))
d4920 1
a4920 1
              first_error (_(reg_expected_msgs[REG_TYPE_VFD]));
d4926 2
a4927 1
          inst.operands[i].regisimm = 1;
d4930 31
a4980 4

  bad_cond:
  first_error (_("instruction cannot be conditionalized"));
  return FAIL;
d4999 1
d5001 1
d5018 1
d5024 1
d5026 1
d5066 3
d5087 1
d5126 4
d5141 4
d5211 3
d5252 4
d5265 9
d5463 35
d5520 13
d5586 1
d5592 1
d6660 32
d6695 3
d6713 3
d7393 1
d9061 4
d9092 3
d9742 8
a9749 1
  X(vqmovun,	0x1b20240, N_INV,     N_INV)
d9774 4
d9779 2
a9780 3
/* Shapes for instruction operands. Some (e.g. NS_DDD_QQQ) represent multiple
   shapes which an instruction can accept. The following mnemonic characters
   are used in the tag names for this enumeration:
d9782 1
d9789 6
d9797 48
d9847 47
a9893 34
  NS_DDD_QQQ,
  NS_DDD,
  NS_QQQ,
  NS_DDI_QQI,
  NS_DDI,
  NS_QQI,
  NS_DDS_QQS,
  NS_DDS,
  NS_QQS,
  NS_DD_QQ,
  NS_DD,
  NS_QQ,
  NS_DS_QS,
  NS_DS,
  NS_QS,
  NS_DR_QR,
  NS_DR,
  NS_QR,
  NS_DI_QI,
  NS_DI,
  NS_QI,
  NS_DLD,
  NS_DQ,
  NS_QD,
  NS_DQI,
  NS_QDI,
  NS_QDD,
  NS_QDS,
  NS_QQD,
  NS_DQQ,
  NS_DDDI_QQQI,
  NS_DDDI,
  NS_QQQI,
  NS_IGNORE
d9896 22
d9945 4
a9948 2
  N_KEY  = 0x080000, /* key element (main type specifier).  */
  N_EQK  = 0x100000, /* given operand has the same type & size as the key.  */
d9957 1
a9957 1
  N_MAX_NONSPECIAL = N_F32
d9973 5
a9977 3
/* Check the shape of a Neon instruction (sizes of registers). Returns the more
   specific shape when there are two alternatives. For non-polymorphic shapes,
   checking is done during operand parsing, so is not implemented here.  */
d9980 1
a9980 1
neon_check_shape (enum neon_shape req)
d9982 2
a9983 5
#define RR(X) (inst.operands[(X)].isreg)
#define RD(X) (inst.operands[(X)].isreg && !inst.operands[(X)].isquad)
#define RQ(X) (inst.operands[(X)].isreg && inst.operands[(X)].isquad)
#define IM(X) (!inst.operands[(X)].isreg && !inst.operands[(X)].isscalar)
#define SC(X) (!inst.operands[(X)].isreg && inst.operands[(X)].isscalar)
d9992 1
a9992 25
  switch (req)
      {
    case NS_DDD_QQQ:
      {
        if (RD(0) && RD(1) && RD(2))
          return NS_DDD;
        else if (RQ(0) && RQ(1) && RQ(2))
          return NS_QQQ;
        else
          first_error (_("expected <Qd>, <Qn>, <Qm> or <Dd>, <Dn>, <Dm> "
                         "operands"));
      }
      break;
    
    case NS_DDI_QQI:
      {
        if (RD(0) && RD(1) && IM(2))
          return NS_DDI;
        else if (RQ(0) && RQ(1) && IM(2))
          return NS_QQI;
        else
          first_error (_("expected <Qd>, <Qn>, #<imm> or <Dd>, <Dn>, #<imm> "
                         "operands"));
      }
        break;
d9994 62
a10055 10
    case NS_DDDI_QQQI:
      {
        if (RD(0) && RD(1) && RD(2) && IM(3))
          return NS_DDDI;
        if (RQ(0) && RQ(1) && RQ(2) && IM(3))
          return NS_QQQI;
        else
          first_error (_("expected <Qd>, <Qn>, <Qm>, #<imm> or "
                         "<Dd>, <Dn>, <Dm>, #<imm> operands"));
      }
d10057 1
d10059 4
a10062 33
    case NS_DDS_QQS:
      {
        if (RD(0) && RD(1) && SC(2))
          return NS_DDS;
        else if (RQ(0) && RQ(1) && SC(2))
          return NS_QQS;
        else
          first_error (_("expected <Qd>, <Qn>, <Dm[x]> or <Dd>, <Dn>, <Dm[x]> "
                         "operands"));
      }
      break;
  
    case NS_DD_QQ:
      {
        if (RD(0) && RD(1))
          return NS_DD;
        else if (RQ(0) && RQ(1))
          return NS_QQ;
        else
          first_error (_("expected <Qd>, <Qm> or <Dd>, <Dm> operands"));
      }
      break;
  
    case NS_DS_QS:
      {
        if (RD(0) && SC(1))
          return NS_DS;
        else if (RQ(0) && SC(1))
          return NS_QS;
        else
          first_error (_("expected <Qd>, <Dm[x]> or <Dd>, <Dm[x]> operands"));
      }
      break;
d10064 2
a10065 10
    case NS_DR_QR:
      {
        if (RD(0) && RR(1))
          return NS_DR;
        else if (RQ(0) && RR(1))
          return NS_QR;
        else
          first_error (_("expected <Qd>, <Rm> or <Dd>, <Rm> operands"));
      }
      break;
d10067 2
a10068 14
    case NS_DI_QI:
      {
        if (RD(0) && IM(1))
          return NS_DI;
        else if (RQ(0) && IM(1))
          return NS_QI;
        else
          first_error (_("expected <Qd>, #<imm> or <Dd>, #<imm> operands"));
      }
      break;
   
    default:
      abort ();
    }
d10070 4
a10073 6
  return req;
#undef RR
#undef RD
#undef RQ
#undef IM
#undef SC
d10075 1
a10075 1
  
d10147 6
a10152 2
      if (size == 32)
        return N_F32;
d10208 1
a10208 1
  else if ((mask & (N_S64 | N_U64 | N_I64 | N_64)) != 0)
d10223 1
a10223 1
  else if ((mask & N_F32) != 0)
d10266 1
a10266 2
   Neon instructions should call it before performing bit encoding.
*/
d10387 20
d10435 3
a10437 2
/* Fix up Neon data-processing instructions, ORing in the correct bits for
   ARM mode or Thumb mode and moving the encoded bit 24 to bit 28.  */
d10439 2
a10440 2
static unsigned
neon_dp_fixup (unsigned i)
d10443 1
a10443 9
    {
      /* The U bit is at bit 24 by default. Move to bit 28 in Thumb mode.  */
      if (i & (1 << 24))
        i |= 1 << 28;
      
      i &= ~(1 << 24);
      
      i |= 0xef000000;
    }
d10445 1
a10445 3
    i |= 0xf2000000;
  
  return i;
d10448 7
a10454 2
/* Turn a size (8, 16, 32, 64) into the respective bit number minus 3
   (0, 1, 2, 3).  */
d10456 2
a10457 2
static unsigned
neon_logbits (unsigned x)
d10459 3
a10461 2
  return ffs (x) - 4;
}
d10463 2
a10464 2
#define LOW4(R) ((R) & 0xf)
#define HI1(R) (((R) >> 4) & 1)
d10466 3
a10468 1
/* Encode insns with bit pattern:
d10470 11
a10480 5
  |28/24|23|22 |21 20|19 16|15 12|11    8|7|6|5|4|3  0|
  |  U  |x |D  |size | Rn  | Rd  |x x x x|N|Q|M|x| Rm |
  
  SIZE is passed in bits. -1 means size field isn't changed, in case it has a
  different meaning for some instruction.  */
d10483 1
a10483 1
neon_three_same (int isquad, int ubit, int size)
d10485 324
a10808 13
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= (isquad != 0) << 6;
  inst.instruction |= (ubit != 0) << 24;
  if (size != -1)
    inst.instruction |= neon_logbits (size) << 20;
  
  inst.instruction = neon_dp_fixup (inst.instruction);
}
d10838 1
a10838 1
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d10841 1
a10841 1
  neon_three_same (rs == NS_QQQ, et.type == NT_unsigned, et.size);
d10847 1
a10847 1
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d10850 1
a10850 1
  neon_three_same (rs == NS_QQQ, et.type == NT_unsigned, et.size);
d10877 1
a10877 1
      enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
d10880 1
a10880 1
      neon_imm_shift (FALSE, 0, rs == NS_QQI, et, inst.operands[2].imm);
d10884 1
a10884 1
      enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d10888 1
a10888 1
      neon_three_same (rs == NS_QQQ, et.type == NT_unsigned, et.size);
d10897 1
a10897 1
      enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
d10900 1
a10900 1
      neon_imm_shift (TRUE, et.type == NT_unsigned, rs == NS_QQI, et,
d10905 1
a10905 1
      enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d10909 1
a10909 1
      neon_three_same (rs == NS_QQQ, et.type == NT_unsigned, et.size);
d11127 1
a11127 1
      enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d11131 1
a11131 1
      neon_three_same (rs == NS_QQQ, 0, -1);
d11135 3
a11137 3
      enum neon_shape rs = neon_check_shape (NS_DI_QI);
      struct neon_type_el et = neon_check_type (1, rs, N_I8 | N_I16 | N_I32
                                                | N_I64 | N_F32);
d11180 1
a11180 1
      inst.instruction |= (rs == NS_QI) << 6;
d11193 1
a11193 1
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d11195 1
a11195 1
  neon_three_same (rs == NS_QQQ, 0, -1);
d11202 1
a11202 1
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d11208 1
a11208 1
      neon_three_same (rs == NS_QQQ, 0, -1);
d11213 1
a11213 1
      neon_three_same (rs == NS_QQQ, et.type == ubit_meaning, et.size);
d11243 50
d11296 6
d11345 1
a11345 1
      enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
d11354 1
a11354 1
      inst.instruction |= (rs == NS_QQI) << 6;
d11440 6
d11448 1
a11448 1
      enum neon_shape rs = neon_check_shape (NS_DDS_QQS);
d11452 1
a11452 1
      neon_mul_mac (et, rs == NS_QQS);
d11461 1
a11461 1
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d11464 1
a11464 1
  neon_three_same (rs == NS_QQQ, 0, et.size);
d11474 6
d11491 1
a11491 1
      enum neon_shape rs = neon_check_shape (NS_DDS_QQS);
d11495 1
a11495 1
      neon_mul_mac (et, rs == NS_QQS);
d11499 1
a11499 1
      enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d11504 1
a11504 1
      neon_three_same (rs == NS_QQQ, 0, et.size);
d11511 1
a11511 1
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d11514 1
a11514 1
  neon_three_same (rs == NS_QQQ, 1, -1);
d11527 1
a11527 1
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
d11529 1
a11529 1
  neon_three_same (rs == NS_QQQ, 0, -1);
d11535 12
a11546 3
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_S8 | N_S16 | N_S32 | N_F32 | N_KEY);
d11551 1
a11551 1
  inst.instruction |= (rs == NS_QQ) << 6;
d11561 1
a11561 1
  enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
d11567 1
a11567 1
  neon_imm_shift (FALSE, 0, rs == NS_QQI, et, imm);
d11573 1
a11573 1
  enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
d11579 1
a11579 1
  neon_imm_shift (FALSE, 0, rs == NS_QQI, et, et.size - imm);
d11585 1
a11585 1
  enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
d11596 1
a11596 1
  neon_imm_shift (FALSE, 0, rs == NS_QQI, et, imm);
d11745 1
a11745 1
/* Check the various types for the VCVT instruction, and return the one that
d11751 6
a11756 6
#define CVT_VAR(C,X,Y)				\
  et = neon_check_type (2, rs, (X), (Y));	\
  if (et.type != NT_invtype)			\
    {						\
      inst.error = NULL;			\
      return (C);				\
d11759 7
d11772 19
d11795 87
d11885 9
a11893 18
  /* Fixed-point conversion with #0 immediate is encoded as an integer
     conversion.  */
  if (inst.operands[2].present && inst.operands[2].imm != 0)
    {
      enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
      int flavour = neon_cvt_flavour (rs);
      unsigned immbits = 32 - inst.operands[2].imm;
      unsigned enctab[] = { 0x0000100, 0x1000100, 0x0, 0x1000000 };
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
      if (flavour != -1)
        inst.instruction |= enctab[flavour];
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= (rs == NS_QQI) << 6;
      inst.instruction |= 1 << 21;
      inst.instruction |= immbits << 16;
d11895 2
a11896 1
  else
d11898 55
a11952 12
      enum neon_shape rs = neon_check_shape (NS_DD_QQ);
      int flavour = neon_cvt_flavour (rs);
      unsigned enctab[] = { 0x100, 0x180, 0x0, 0x080 };
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      if (flavour != -1)
        inst.instruction |= enctab[flavour];
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= (rs == NS_QQ) << 6;
      inst.instruction |= 2 << 18;
a11953 1
  inst.instruction = neon_dp_fixup (inst.instruction);
d11959 3
a11961 3
  enum neon_shape rs = neon_check_shape (NS_DI_QI);
  struct neon_type_el et = neon_check_type (1, rs,
    N_I8 | N_I16 | N_I32 | N_I64 | N_F32);
d11965 3
d12000 1
a12000 1
  inst.instruction |= (rs == NS_QI) << 6;
d12011 1
a12011 1
      enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12018 1
a12018 1
      inst.instruction |= (rs == NS_QQ) << 6;
d12137 1
a12137 1
  enum neon_shape rs = neon_check_shape (NS_DDDI_QQQI);
d12147 1
a12147 1
  inst.instruction |= (rs == NS_QQQI) << 6;
d12156 1
a12156 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12167 1
a12167 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12175 1
a12175 1
      enum neon_shape rs = neon_check_shape (NS_DS_QS);
d12182 4
d12191 1
a12191 1
      inst.instruction |= (rs == NS_QS) << 6;
d12199 3
a12201 4
      enum neon_shape rs = neon_check_shape (NS_DR_QR);
      struct neon_type_el et = neon_check_type (1, rs,
        N_8 | N_16 | N_32 | N_KEY);
      unsigned save_cond = inst.instruction & 0xf0000000;
d12214 1
a12214 1
      inst.instruction |= (rs == NS_QR) << 21;
d12217 1
a12217 4
      if (thumb_mode)
        inst.instruction |= 0xe0000000;
      else
        inst.instruction |= save_cond;
d12236 14
d12251 2
a12252 4
   We should have just enough information to be able to disambiguate most of
   these, apart from "Two ARM registers to vector" and "Vector to two ARM
   registers" cases. For these, abuse the .regisimm operand field to signify a
   Neon register.
d12266 5
a12270 4
  int nargs = inst.operands[0].present + inst.operands[1].present
              + inst.operands[2].present;
  unsigned save_cond = thumb_mode ? 0xe0000000 : inst.instruction & 0xf0000000;
  const char *vfp_vers = "selected FPU does not support instruction";
d12272 1
a12272 1
  switch (nargs)
d12274 5
a12278 3
    case 2:
      /* Cases 0, 1, 2, 3, 4, 6.  */
      if (inst.operands[1].isscalar)
d12280 4
a12283 14
          /* Case 6.  */
          struct neon_type_el et = neon_check_type (2, NS_IGNORE,
            N_EQK, N_S8 | N_S16 | N_U8 | N_U16 | N_32 | N_KEY);
          unsigned logsize = neon_logbits (et.size);
          unsigned dn = NEON_SCALAR_REG (inst.operands[1].reg);
          unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg);
          unsigned abcdebits = 0;

          constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
                      _(vfp_vers));
          constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
                      && et.size != 32, _(vfp_vers));
          constraint (et.type == NT_invtype, _("bad type for scalar"));
          constraint (x >= 64 / et.size, _("scalar index out of range"));
d12285 15
a12299 7
          switch (et.size)
            {
            case 8:  abcdebits = (et.type == NT_signed) ? 0x08 : 0x18; break;
            case 16: abcdebits = (et.type == NT_signed) ? 0x01 : 0x11; break;
            case 32: abcdebits = 0x00; break;
            default: ;
            }
d12301 12
a12312 8
          abcdebits |= x << logsize;
          inst.instruction = save_cond;
          inst.instruction |= 0xe100b10;
          inst.instruction |= LOW4 (dn) << 16;
          inst.instruction |= HI1 (dn) << 7;
          inst.instruction |= inst.operands[0].reg << 12;
          inst.instruction |= (abcdebits & 3) << 5;
          inst.instruction |= (abcdebits >> 2) << 21;
d12314 73
a12386 19
      else if (inst.operands[1].isreg)
        {
          /* Cases 0, 1, 4.  */
          if (inst.operands[0].isscalar)
            {
              /* Case 4.  */
              unsigned bcdebits = 0;
              struct neon_type_el et = neon_check_type (2, NS_IGNORE,
                N_8 | N_16 | N_32 | N_KEY, N_EQK);
              int logsize = neon_logbits (et.size);
              unsigned dn = NEON_SCALAR_REG (inst.operands[0].reg);
              unsigned x = NEON_SCALAR_INDEX (inst.operands[0].reg);

              constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
                          _(vfp_vers));
              constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
                          && et.size != 32, _(vfp_vers));
              constraint (et.type == NT_invtype, _("bad type for scalar"));
              constraint (x >= 64 / et.size, _("scalar index out of range"));
d12388 7
a12394 7
              switch (et.size)
                {
                case 8:  bcdebits = 0x8; break;
                case 16: bcdebits = 0x1; break;
                case 32: bcdebits = 0x0; break;
                default: ;
                }
d12396 9
a12404 35
              bcdebits |= x << logsize;
              inst.instruction = save_cond;
              inst.instruction |= 0xe000b10;
              inst.instruction |= LOW4 (dn) << 16;
              inst.instruction |= HI1 (dn) << 7;
              inst.instruction |= inst.operands[1].reg << 12;
              inst.instruction |= (bcdebits & 3) << 5;
              inst.instruction |= (bcdebits >> 2) << 21;
            }
          else
            {
              /* Cases 0, 1.  */
              enum neon_shape rs = neon_check_shape (NS_DD_QQ);
              /* The architecture manual I have doesn't explicitly state which
                 value the U bit should have for register->register moves, but
                 the equivalent VORR instruction has U = 0, so do that.  */
              inst.instruction = 0x0200110;
              inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
              inst.instruction |= HI1 (inst.operands[0].reg) << 22;
              inst.instruction |= LOW4 (inst.operands[1].reg);
              inst.instruction |= HI1 (inst.operands[1].reg) << 5;
              inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
              inst.instruction |= HI1 (inst.operands[1].reg) << 7;
              inst.instruction |= (rs == NS_QQ) << 6;
              
              inst.instruction = neon_dp_fixup (inst.instruction);
            }
        }
      else
        {
          /* Cases 2, 3.  */
          inst.instruction = 0x0800010;
          neon_move_immediate ();
          inst.instruction = neon_dp_fixup (inst.instruction);
        }
d12407 1
a12407 2
    case 3:
      /* Cases 5, 7.  */
d12409 1
a12409 1
                  _(vfp_vers));
d12411 16
a12426 1
      if (inst.operands[0].regisimm)
d12428 2
a12429 7
          /* Case 5.  */
          inst.instruction = save_cond;
          inst.instruction |= 0xc400b10;
          inst.instruction |= LOW4 (inst.operands[0].reg);
          inst.instruction |= HI1 (inst.operands[0].reg) << 5;
          inst.instruction |= inst.operands[1].reg << 12;
          inst.instruction |= inst.operands[2].reg << 16;
d12432 31
a12462 9
        {
          /* Case 7.  */
          inst.instruction = save_cond;
          inst.instruction |= 0xc500b10;
          inst.instruction |= inst.operands[0].reg << 12;
          inst.instruction |= inst.operands[1].reg << 16;
          inst.instruction |= LOW4 (inst.operands[2].reg);
          inst.instruction |= HI1 (inst.operands[2].reg) << 5;
        }
d12473 1
a12473 1
  enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
d12487 1
a12487 1
  neon_imm_shift (TRUE, et.type == NT_unsigned, rs == NS_QQI, et,
d12504 1
a12504 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12508 1
a12508 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12514 1
a12514 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12524 1
a12524 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12530 1
a12530 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12533 1
a12533 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12539 1
a12539 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12543 1
a12543 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12549 1
a12549 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12553 1
a12553 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12559 1
a12559 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12562 1
a12562 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12568 1
a12568 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12571 1
a12571 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12577 1
a12577 1
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
d12580 1
a12580 1
  neon_two_same (rs == NS_QQ, 1, et.size);
d12586 2
a12587 2
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  neon_two_same (rs == NS_QQ, 1, -1);
d12621 6
d12641 1
a12641 2
  if (thumb_mode)
    inst.instruction |= 0xe0000000;
d12651 6
d12688 1
a12688 2
  if (thumb_mode)
    inst.instruction |= 0xe0000000;
d12707 1
a12707 1
  struct neon_type_el et = neon_check_type (1, NS_IGNORE,
d12811 1
a12811 1
  struct neon_type_el et = neon_check_type (1, NS_IGNORE, N_8 | N_16 | N_32);
d12898 1
a12898 1
  struct neon_type_el et = neon_check_type (1, NS_IGNORE, N_8 | N_16 | N_32);
d13150 3
d13321 1
d13413 4
d14052 4
d14057 4
a14060 2
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x##op, ARM_VARIANT,	\
    THUMB_VARIANT, do_##enc, do_##enc }
d14063 4
d14068 4
a14071 2
  { #mnem, OPS##nops ops, OT_csuffix, N_MNEM_##op, N_MNEM_##op,		\
    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }
d14218 2
a14219 2
 TCE(mrs,	10f0000, f3ef8000, 2, (RR, PSR),     mrs, t_mrs),
 TCE(msr,	120f000, f3808000, 2, (PSR, RR_EXi), msr, t_msr),
d15068 44
a15184 1
 nUF(vmla,      vmla,    3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_mac_maybe_scalar),
a15185 1
 nUF(vmls,      vmls,    3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_mac_maybe_scalar),
a15188 1
 nUF(vadd,      vadd,    3, (RNDQ, oRNDQ, RNDQ), neon_addsub_if_i),
a15189 1
 nUF(vsub,      vsub,    3, (RNDQ, oRNDQ, RNDQ), neon_addsub_if_i),
d15195 1
a15195 2
 nUF(vmul,      vmul,    3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_mul),
 nUF(vmulq,     vmul,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mul),
a15214 1
 NUF(vabs,      1b10300, 2, (RNDQ, RNDQ),     neon_abs_neg),
a15215 1
 NUF(vneg,      1b10380, 2, (RNDQ, RNDQ),     neon_abs_neg),
d15250 1
a15250 9
 nUF(vcvt,      vcvt,    3, (RNDQ, RNDQ, oI32b), neon_cvt),
 nUF(vcvtq,     vcvt,    3, (RNQ,  RNQ,  oI32b), neon_cvt),

  /* One register and an immediate value. All encoding special-cased!  */
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_ext_v1
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v1
 NCE(vmov,      0,       1, (VMOV),             neon_mov),
a15251 5
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_neon_ext_v1
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_neon_ext_v1
 NCE(vmovq,     0,       1, (VMOV),             neon_mov),
a15344 15
#define THUMB_VARIANT &fpu_vfp_ext_v1xd
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v1xd

  /* Load/store instructions. Available in Neon or VFPv3.  */
 NCE(vldm,      c900b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vldmia,    c900b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vldmdb,    d100b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vstm,      c800b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vstmia,    c800b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vstmdb,    d000b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vldr,      d100b00, 2, (RND, ADDR),      neon_ldr_str),
 NCE(vstr,      d000b00, 2, (RND, ADDR),      neon_ldr_str),

#undef THUMB_VARIANT
a15347 1

a15361 1

@


1.272
log
@	* config/tc-arm.c, config/tc-arm.h (tc_arm_regname_to_dw2regnum):
	Un-constify string argument.
	* config/tc-i386.c, config/tc-i386.h (tc_x86_regname_to_dw2regnum):
	Likewise.
	* config/tc-m68k.c, config/tc-m68k.h (tc_m68k_regname_to_dw2regnum):
	Likewise.
	* config/tc-ppc.c, config/tc-ppc.h (tc_ppc_regname_to_dw2regnum):
	Likewise.
	* config/tc-s390.c, config/tc-s390.h (tc_s390_regname_to_dw2regnum):
	Likewise.
	* config/tc-sh.c, config/tc-sh.h (sh_regname_to_dw2regnum):
	Likewise.
	* config/tc-sparc.c, config/tc-sparc.h (sparc_regname_to_dw2regnum):
	Likewise.
-------------------------------------------------------------------
@
text
@d3 1
a3 1
   2004, 2005
a27 1
#include <string.h>
a31 3

/* Need TARGET_CPU.  */
#include "config.h"
a33 2
#include "symbols.h"
#include "listing.h"
@


1.271
log
@2006-05-15  Paul Brook  <paul@@codesourcery.com>

bfd/
	* cpu-arm.c (bfd_is_arm_mapping_symbol_name): Rename ...
	(bfd_is_arm_special_symbol_name): ... to this.  Add type argument.
	Check symbol name is of specified type.
	* elf32-arm.c (elf32_arm_is_target_special_symbol,
	arm_elf_find_function, elf32_arm_output_symbol_hook): Use
	bfd_is_arm_special_symbol_name.
	* bfd-in.h (BFD_ARM_SPECIAL_SYM_TYPE_MAP,
	BFD_ARM_SPECIAL_SYM_TYPE_TAG, BFD_ARM_SPECIAL_SYM_TYPE_OTHER,
	BFD_ARM_SPECIAL_SYM_TYPE_ANY): Define.
	(bfd_is_arm_mapping_symbol_name): Remove prototype.
	(bfd_is_arm_special_symbol_name): Add prototype.
	* bfd-in2.h: Regenerate.
gas/
	* config/tc-arm.c (arm_adjust_symtab): Use
	bfd_is_arm_special_symbol_name.
ld/testsuite/
	* ld-arm/arm-be8.d: New test.
	* ld-arm/arm-be8.s: New test.
	* ld-arm/arm-elf.exp: Add arm-be8.
@
text
@d15604 1
a15604 1
tc_arm_regname_to_dw2regnum (const char *regname)
d15606 1
a15606 1
  int reg = arm_reg_parse ((char **) &regname, REG_TYPE_RN);
@


1.270
log
@2006-05-11  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (elf32_arm_reloc_map): Add MOVW and MOVT relocs.
	(elf32_arm_final_link_relocate): Handle MOVW and MOVT relocs.
	(elf32_arm_gc_sweep_hook, elf32_arm_check_relocs): Ditto.
	* reloc.c: Ditto.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
gas/
	* config/tc-arm.c (parse_half): New function.
	(operand_parse_code): Remove OP_Iffff.  Add OP_HALF.
	(parse_operands): Ditto.
	(do_mov16): Reject invalid relocations.
	(do_t_mov16): Ditto.  Use Thumb reloc numbers.
	(insns): Replace Iffff with HALF.
	(md_apply_fix): Add MOVW and MOVT relocs.
	(tc_gen_reloc): Ditto.
	* doc/c-arm.texi: Document relocation operators
ld/testsuite/
	* ld-arm/arm-elf.exp: Add arm-movwt.
	* ld-arm/arm-movwt.d: New test.
	* ld-arm/arm-movwt.s: New test.
	* ld-arm/arm.ld: Add .far.
@
text
@d17356 2
a17357 1
	  if (! bfd_is_arm_mapping_symbol_name (elf_sym->symbol.name))
@


1.269
log
@2006-05-11  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (arm_fix_adjustable): Return 0 for function symbols.
gas/testsuite/
	* gas/arm/local_function.d: New test.
	* gas/arm/local_function.s: New test.
@
text
@d4438 40
a4967 1
  OP_Iffff,	/*		   0 .. 65535 */
d4979 1
a5239 1
	case OP_Iffff:	 po_imm_or_fail (  0, 0xffff, FALSE);	break;
d5305 5
d6485 16
a6500 4
  inst.instruction |= inst.operands[0].reg << 12;
  /* The value is in two pieces: 0:11, 16:19.  */
  inst.instruction |= (inst.operands[1].imm & 0x00000fff);
  inst.instruction |= (inst.operands[1].imm & 0x0000f000) << 4;
d8768 15
d8784 8
a8791 4
  inst.instruction |= (inst.operands[1].imm & 0xf000) << 4;
  inst.instruction |= (inst.operands[1].imm & 0x0800) << 15;
  inst.instruction |= (inst.operands[1].imm & 0x0700) << 4;
  inst.instruction |= (inst.operands[1].imm & 0x00ff);
d13503 2
a13504 2
 TCE(movw,	3000000, f2400000, 2, (RRnpc, Iffff),		    mov16, t_mov16),
 TCE(movt,	3400000, f2c00000, 2, (RRnpc, Iffff),		    mov16, t_mov16),
d16839 41
d16934 28
@


1.268
log
@Apply fixes to allow arm WinCE toolchain to produce working executables.
@
text
@d17056 3
a17058 3
/* Relocations against Thumb function names must be left unadjusted,
   so that the linker can use this information to correctly set the
   bottom bit of their addresses.  The MIPS version of this function
d17075 4
@


1.267
log
@Revised test (that is not O(n2)) for checking for orphaned cloned symbols
@
text
@d15564 3
a15566 1
     will need.  Otherwise we want to use the calculated base.  */
d15569 5
a15573 1
	  || arm_force_relocation (fixP)))
d15610 11
d16532 5
a16536 1
	md_number_to_chars (buf, value, 4);
@


1.266
log
@* config/tc-arm.c (arm_fix_adjustable): For COFF, convert fixups against
   symbols which are not going to be placed into the symbol table.
* coffcode.h (coff_write_relocs): Produce an error message if a an
   out-of-range symbol index is detected in a reloc.
@
text
@d17019 1
a17019 1
     against the original pre-cloned symbol.  Such symbols would not appear
d17024 5
a17028 10
  if (fixP->fx_addsy != NULL)
    {
      symbolS * sym;

      for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
	if (sym == fixP->fx_addsy)
	  break;
      if (sym == NULL)
	return 1;
    }
@


1.265
log
@	* config/tc-arm.c (parse_vfp_reg_list): Improve register bounds
	checking.
	(do_neon_mov): Enable several VMOV variants for VFP. Add suitable
	architecture version checks.
	(insns): Allow overlapping instructions to be used in VFP mode.
@
text
@a17005 6
/* This is a little hack to help the gas/arm/adrl.s test.  It prevents
   local labels from being added to the output symbol table when they
   are used with the ADRL pseudo op.  The ADRL relocation should always
   be resolved before the binbary is emitted, so it is safe to say that
   it is adjustable.  */

d17009 5
d17016 19
@


1.264
log
@gas/
	* config/tc-arm.c (opcode_tag): Add OT_cinfix3_deprecated.
	(opcode_lookup): Issue a warning for opcode with
	OT_cinfix3_deprecated.  Otherwise treat OT_cinfix3_deprecated
	identical to OT_cinfix3.
	(TxC3w, TC3w, tC3w): New.
	(insns): Use tC3w and TC3w for comparison instructions with
	's' suffix.

gas/testsuite
	* gas/arm/armv1.d (error-output): New.
	* gas/arm/armv1.l: New.
	* gas/arm/thumb32.d (error-output): New.
	* gas/arm/thumb32.l: New.
@
text
@d1556 9
a1577 6
      break;
    
    case REGLIST_NEON_D:
      regtype = REG_TYPE_NDQ;
      max_regs = 32;
      break;
d1594 6
d1638 6
d11321 3
d11334 1
d11350 4
d11387 4
d11441 3
d14188 4
d14193 5
d14292 1
a14292 1
#define THUMB_VARIANT &fpu_vfp_v3_or_neon_ext
d14294 1
a14294 1
#define ARM_VARIANT &fpu_vfp_v3_or_neon_ext
d14306 5
@


1.263
log
@	* config/tc-arm.c (do_iwmmxt_wldstbh): Don't multiply offset by 4
	here.
	(md_apply_fix3): Multiply offset by 4 here for
	BFD_RELOC_ARM_CP_OFF_IMM_S2 and BFD_RELOC_ARM_T32_CP_OFF_IMM_S2.

testsuite:
	* gas/arm/iwmmxt.s: Increase offsets for wstrb and wstrh.
	* gas/arm/iwmmxt.d: Update expected results.
	* gas/arm/iwmmxt-bad2.s: Test wstrb, wstrh, wldrb and wldrh.
	* gas/arm/iwmmxt-bad2.l: Update expected error messages.
@
text
@d12114 2
d12272 1
d12319 5
a12323 2
  if (opcode && (opcode->tag == OT_cinfix3 || opcode->tag == OT_csuf_or_in3
		 || opcode->tag == OT_cinfix3_legacy))
d12326 3
a12328 1
      if (unified_syntax && opcode->tag == OT_cinfix3)
d12367 3
d12871 3
d12876 2
d12880 2
d13044 1
a13044 1
 tC3(tsts,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
d13047 1
a13047 1
 tC3(cmps,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
d13050 1
a13050 1
 tC3(cmns,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
d13104 1
a13104 1
 TC3(teqs,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
@


1.262
log
@2006-05-02  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Set thumb funciton bit
	for R_ARM_REL32.
gas/
	* config/tc-arm.c (arm_optimize_expr): New function.
	* config/tc-arm.h (md_optimize_expr): Define
	(arm_optimize_expr): Add prototype.
	(TC_FORCE_RELOCATION_SUB_SAME): Define.
ld/testsuite/
	* ld-arm/arm-elf.exp: Add thumb-rel32.
	* ld-arm/thumb-rel32.d: New test.
	* ld-arm/thumb-rel32.s: New test.
@
text
@a7189 1
  inst.reloc.exp.X_add_number *= 4;
d16502 1
@


1.261
log
@	* gas/config/tc-arm.c (neon_is_quarter_float): Move, and rename to...
	(is_quarter_float): Rename from above. Simplify slightly.
	(parse_qfloat_immediate): Parse a "quarter precision" floating-point
	number.
	(parse_neon_mov): Parse floating-point constants.
	(neon_qfloat_bits): Fix encoding.
	(neon_cmode_for_move_imm): Tweak to use floating-point encoding in
	preference to integer encoding when using the F32 type.
@
text
@d15814 23
@


1.260
log
@	* config/tc-arm.c (neon_el_type): Make NT_invtype be the zero (so
	zero-initialising structures containing it will lead to invalid types).
	(arm_it): Add vectype to each operand.
	(NTA_HASTYPE, NTA_HASINDEX): Constants used in neon_typed_alias
	defined field.
	(neon_typed_alias): New structure. Extra information for typed
	register aliases.
	(reg_entry): Add neon type info field.
	(arm_reg_parse): Remove RTYPE argument (revert to previous arguments).
	Break out alternative syntax for coprocessor registers, etc. into...
	(arm_reg_alt_syntax): New function. Alternate syntax handling broken
	out from arm_reg_parse.
	(parse_neon_type): Move. Return SUCCESS/FAIL.
	(first_error): New function. Call to ensure first error which occurs is
	reported.
	(parse_neon_operand_type): Parse exactly one type.
	(NEON_ALL_LANES, NEON_INTERLEAVE_LANES): Move.
	(parse_typed_reg_or_scalar): New function. Handle core of both
	arm_typed_reg_parse and parse_scalar.
	(arm_typed_reg_parse): Parse a register with an optional type.
	(NEON_SCALAR_REG, NEON_SCALAR_INDEX): Extract parts of parse_scalar
	result.
	(parse_scalar): Parse a Neon scalar with optional type.
	(parse_reg_list): Use first_error.
	(parse_vfp_reg_list): Use arm_typed_reg_parse instead of arm_reg_parse.
	(neon_alias_types_same): New function. Return true if two (alias) types
	are the same.
	(parse_neon_el_struct_list): Use parse_typed_reg_or_scalar. Return type
	of elements.
	(insert_reg_alias): Return new reg_entry not void.
	(insert_neon_reg_alias): New function. Insert type/index information as
	well as register for alias.
	(create_neon_reg_alias): New function. Parse .dn/.qn directives and
	make typed register aliases accordingly.
	(s_dn, s_qn): New functions. Handle incorrectly used .dn/.qn at start
	of line.
	(s_unreq): Delete type information if present.
	(s_arm_unwind_save_mmxwr): Remove arg 3 from arm_reg_parse calls.
	(s_arm_unwind_save_mmxwcg): Likewise.
	(s_arm_unwind_movsp): Likewise.
	(s_arm_unwind_setfp): Likewise.
	(parse_shift): Likewise.
	(parse_shifter_operand): Likewise.
	(parse_address): Likewise.
	(parse_tb): Likewise.
	(tc_arm_regname_to_dw2regnum): Likewise.
	(md_pseudo_table): Add dn, qn.
	(parse_neon_mov): Handle typed operands.
	(parse_operands): Likewise.
	(neon_type_mask): Add N_SIZ.
	(N_ALLMODS): New macro.
	(neon_check_shape): Fix typo in NS_DDD_QQQ case. Use first_error.
	(el_type_of_type_chk): Add some safeguards.
	(modify_types_allowed): Fix logic bug.
	(neon_check_type): Handle operands with types.
	(neon_three_same): Remove redundant optional arg handling.
	(do_neon_dyadic_i64_su, do_neon_shl_imm, do_neon_qshl_imm)
	(do_neon_logic, do_neon_qdmulh, do_neon_fcmp_absolute)
	(do_neon_step): Adjust accordingly.
	(neon_cmode_for_logic_imm): Use first_error.
	(do_neon_bitfield): Call neon_check_type.
	(neon_dyadic): Rename to...
	(neon_dyadic_misc): ...this. New name for neon_dyadic. Add bitfield
	to allow modification of type of the destination.
	(do_neon_dyadic_if_su, do_neon_dyadic_if_i, do_neon_dyadic_if_i_d)
	(do_neon_addsub_if_i, do_neon_mul): Adjust accordingly.
	(do_neon_compare): Make destination be an untyped bitfield.
	(neon_scalar_for_mul): Use NEON_SCALAR_REG, NEON_SCALAR_INDEX.
	(neon_mul_mac): Return early in case of errors.
	(neon_move_immediate): Use first_error.
	(neon_mac_reg_scalar_long): Fix type to include scalar.
	(do_neon_dup): Likewise.
	(do_neon_mov): Likewise (in several places).
	(do_neon_tbl_tbx): Fix type.
	(do_neon_ld_st_interleave, neon_alignment_bit, do_neon_ld_st_lane)
	(do_neon_ld_dup): Exit early in case of errors and/or use
	first_error.
	(opcode_lookup): Update for parse_neon_type returning SUCCESS/FAIL.
	Handle .dn/.qn directives.
	(REGDEF): Add zero for reg_entry neon field.
@
text
@d3997 49
d4754 7
d10273 1
a10273 14
/* Returns 1 if a number has "quarter-precision" float format
   0baBbbbbbc defgh000 00000000 00000000.  */

static int
neon_is_quarter_float (unsigned imm)
{
  int b = (imm & 0x20000000) != 0;
  int bs = (b << 25) | (b << 26) | (b << 27) | (b << 28) | (b << 29)
           | ((!b) << 30);
  return (imm & 0x81ffffff) == (imm & 0x81f80000)
         && ((imm & 0x7e000000) ^ bs) == 0;
}

/* Compress above representation to 0b...000 abcdefgh.  */
d10278 1
a10278 1
  return ((imm >> 19) & 0x7f) | (imm >> 24);
d10289 1
a10289 1
                         int *op, int size)
d10291 8
a10298 1
  if (size == 64 && neon_bits_same_in_bytes (immhi)
a10355 7
  else if (neon_is_quarter_float (immlo))
    {
      if (size != 32 || *op == 1)
        return FAIL;
      *immbits = neon_qfloat_bits (immlo);
      return 0xf;
    }
d11042 1
a11042 1
                                        et.size)) == FAIL)
d11051 1
a11051 1
                                            et.size)) == FAIL)
@


1.259
log
@	* config/tc-arm.c (limits.h): Include.
	(fpu_arch_vfp_v3, fpu_vfp_ext_v3, fpu_neon_ext_v1)
	(fpu_vfp_v3_or_neon_ext): Declare constants.
	(neon_el_type): New enumeration of types for Neon vector elements.
	(neon_type_el): New struct. Define type and size of a vector element.
	(NEON_MAX_TYPE_ELS): Define constant. The maximum number of types per
	instruction.
	(neon_type): Define struct. The type of an instruction.
	(arm_it): Add 'vectype' for the current instruction.
	(isscalar, immisalign, regisimm, isquad): New predicates for operands.
	(vfp_sp_reg_pos): Rename to...
	(vfp_reg_pos): ...this, and add VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
	tags.
	(arm_reg_type): Add REG_TYPE_NQ (Neon Q register) and REG_TYPE_NDQ
	(Neon D or Q register).
	(reg_expected_msgs): Sync with above. Allow VFD to mean VFP or Neon D
	register.
	(GE_OPT_PREFIX_BIG): Define constant, for use in...
	(my_get_expression): Allow above constant as argument to accept
	64-bit constants with optional prefix.
	(arm_reg_parse): Add extra argument to return the specific type of
	register in when either a D or Q register (REG_TYPE_NDQ) is
	requested. Can be NULL.
	(parse_scalar): New function. Parse Neon scalar (vector reg and index).
	(parse_reg_list): Update for new arm_reg_parse args.
	(parse_vfp_reg_list): Allow parsing of Neon D/Q register lists.
	(parse_neon_el_struct_list): New function. Parse element/structure
	register lists for VLD<n>/VST<n> instructions.
	(s_arm_unwind_save_vfp): Update for new parse_vfp_reg_list args.
	(s_arm_unwind_save_mmxwr): Likewise.
	(s_arm_unwind_save_mmxwcg): Likewise.
	(s_arm_unwind_movsp): Likewise.
	(s_arm_unwind_setfp): Likewise.
	(parse_big_immediate): New function. Parse an immediate, which may be
	64 bits wide. Put results in inst.operands[i].
	(parse_shift): Update for new arm_reg_parse args.
	(parse_address): Likewise. Add parsing of alignment specifiers.
	(parse_neon_mov): Parse the operands of a VMOV instruction.
	(operand_parse_code): Add OP_RND, OP_RNQ, OP_RNDQ, OP_RNSC, OP_NRDLST,
	OP_NSTRLST, OP_NILO, OP_RNDQ_I0, OP_RR_RNSC, OP_RNDQ_RNSC, OP_RND_RNSC,
	OP_VMOV, OP_RNDQ_IMVNb, OP_RNDQ_I63b, OP_I0, OP_I16z, OP_I32z, OP_I64,
	OP_I64z, OP_oI32b, OP_oRND, OP_oRNQ, OP_oRNDQ.
	(parse_operands): Handle new codes above.
	(encode_arm_vfp_sp_reg): Rename to...
	(encode_arm_vfp_reg): ...this. Handle D regs (0-31) too. Complain if
	selected VFP version only supports D0-D15.
	(do_vfp_sp_monadic, do_vfp_sp_dyadic, do_vfp_sp_compare_z)
	(do_vfp_dp_sp_cvt, do_vfp_reg_from_sp, do_vfp_reg2_from_sp2)
	(do_vfp_sp_from_reg, do_vfp_sp2_from_reg2, do_vfp_sp_ldst)
	(do_vfp_dp_ldst, vfp_sp_ldstm, vfp_dp_ldstm): Update for new
	encode_arm_vfp_reg name, and allow 32 D regs.
	(do_vfp_dp_rd_rm, do_vfp_dp_rn_rd, do_vfp_dp_rd_rn, do_vfp_dp_rd_rn_rm)
	(do_vfp_rm_rd_rn): New functions to encode VFP insns allowing 32 D
	regs.
	(do_vfp_sp_const, do_vfp_dp_const, vfp_conv, do_vfp_sp_conv_16)
	(do_vfp_dp_conv_16, do_vfp_sp_conv_32, do_vfp_dp_conv_32): Handle
	constant-load and conversion insns introduced with VFPv3.
	(neon_tab_entry): New struct.
	(NEON_ENC_TAB): Bit patterns for overloaded Neon instructions, and
	those which are the targets of pseudo-instructions.
	(neon_opc): Enumerate opcodes, use as indices into...
	(neon_enc_tab): ...this. Hold data from NEON_ENC_TAB.
	(NEON_ENC_INTEGER, NEON_ENC_ARMREG, NEON_ENC_POLY, NEON_ENC_FLOAT)
	(NEON_ENC_SCALAR, NEON_ENC_IMMED, NEON_ENC_INTERLV, NEON_ENC_LANE)
	(NEON_ENC_DUP): Define meaningful helper macros to look up values in
	neon_enc_tab.
	(neon_shape): Enumerate shapes (permitted register widths, etc.) for
	Neon instructions.
	(neon_type_mask): New. Compact type representation for type checking.
	(N_SU_ALL, N_SU_32, N_SU_16_64, N_SUF_32, N_I_ALL, N_IF_32): Common
	permitted type combinations.
	(N_IGNORE_TYPE): New macro.
	(neon_check_shape): New function. Check an instruction shape for
	multiple alternatives. Return the specific shape for the current
	instruction.
	(neon_modify_type_size): New function. Modify a vector type and size,
	depending on the bit mask in argument 1.
	(neon_type_promote): New function. Convert a given "key" type (of an
	operand) into the correct type for a different operand, based on a bit
	mask.
	(type_chk_of_el_type): New function. Convert a type and size into the
	compact representation used for type checking.
	(el_type_of_type_ckh): New function. Reverse of above (only when a
	single bit is set in the bit mask).
	(modify_types_allowed): New function. Alter a mask of allowed types
	based on a bit mask of modifications.
	(neon_check_type): New function. Check the type of the current
	instruction against the variable argument list. The "key" type of the
	instruction is returned.
	(neon_dp_fixup): New function. Fill in and modify instruction bits for
	a Neon data-processing instruction depending on whether we're in ARM
	mode or Thumb-2 mode.
	(neon_logbits): New function.
	(neon_three_same, neon_two_same, do_neon_dyadic_i_su)
	(do_neon_dyadic_i64_su, neon_imm_shift, do_neon_shl_imm)
	(do_neon_qshl_imm, neon_cmode_for_logic_imm, neon_bits_same_in_bytes)
	(neon_squash_bits, neon_is_quarter_float, neon_qfloat_bits)
	(neon_cmode_for_move_imm, neon_write_immbits, neon_invert_size)
	(do_neon_logic, do_neon_bitfield, neon_dyadic, do_neon_dyadic_if_su)
	(do_neon_dyadic_if_su_d, do_neon_dyadic_if_i, do_neon_dyadic_if_i_d)
	(do_neon_addsub_if_i, neon_exchange_operands, neon_compare)
	(do_neon_cmp, do_neon_cmp_inv, do_neon_ceq, neon_scalar_for_mul)
	(neon_mul_mac, do_neon_mac_maybe_scalar, do_neon_tst, do_neon_mul)
	(do_neon_qdmulh, do_neon_fcmp_absolute, do_neon_fcmp_absolute_inv)
	(do_neon_step, do_neon_abs_neg, do_neon_sli, do_neon_sri)
	(do_neon_qshlu_imm, do_neon_qmovn, do_neon_qmovun)
	(do_neon_rshift_sat_narrow, do_neon_rshift_sat_narrow_u, do_neon_movn)
	(do_neon_rshift_narrow, do_neon_shll, neon_cvt_flavour, do_neon_cvt)
	(neon_move_immediate, do_neon_mvn, neon_mixed_length)
	(do_neon_dyadic_long, do_neon_abal, neon_mac_reg_scalar_long)
	(do_neon_mac_maybe_scalar_long, do_neon_dyadic_wide, do_neon_vmull)
	(do_neon_ext, do_neon_rev, do_neon_dup, do_neon_mov)
	(do_neon_rshift_round_imm, do_neon_movl, do_neon_trn, do_neon_zip_uzp)
	(do_neon_sat_abs_neg, do_neon_pair_long, do_neon_recip_est)
	(do_neon_cls, do_neon_clz, do_neon_cnt, do_neon_swp, do_neon_tbl_tbx)
	(do_neon_ldm_stm, do_neon_ldr_str, do_neon_ld_st_interleave)
	(neon_alignment_bit, do_neon_ld_st_lane, do_neon_ld_dup)
	(do_neon_ldx_stx): New functions. Neon bit encoding and encoding
	helpers.
	(parse_neon_type): New function. Parse Neon type specifier.
	(opcode_lookup): Allow parsing of Neon type specifiers.
	(REGNUM2, REGSETH, REGSET2): New macros.
	(reg_names): Add new VFPv3 and Neon registers.
	(NUF, nUF, NCE, nCE): New macros for opcode table.
	(insns): More VFP registers allowed in fcpyd, fmdhr, fmdlr, fmrdh,
	fmrdl, fabsd, fnegd, fsqrtd, faddd, fsubd, fmuld, fdivd, fmacd, fmscd,
	fnmuld, fnmacd, fnmscd, fcmpd, fcmpzd, fcmped, fcmpezd, fmdrr, fmrrd.
	Add Neon instructions vaba, vhadd, vrhadd, vhsub, vqadd, vqsub, vrshl,
	vqrshl, vshl, vqshl{u}, vand, vbic, vorr, vorn, veor, vbsl, vbit, vbif,
	vabd, vmax, vmin, vcge, vcgt, vclt, vcle, vceq, vpmax, vpmin, vmla,
	vmls, vpadd, vadd, vsub, vtst, vmul, vqdmulh, vqrdmulh, vacge, vacgt,
	vaclt, vacle, vrecps, vrsqrts, vabs, vneg, v{r}shr,  v{r}sra, vsli,
	vsri, vqshrn, vq{r}shr{u}n, v{r}shrn, vshll, vcvt, vmov, vmvn, vabal,
	vabdl, vaddl, vsubl, vmlal, vmlsl, vaddw, vsubw, v{r}addhn, v{r}subhn,
	vqdmlal, vqdmlsl, vqdmull, vmull, vext, vrev64, vrev32, vrev16, vdup,
	vmovl, v{q}movn, vzip, vuzp, vqabs, vqneg, vpadal, vpaddl, vrecpe,
	vrsqrte, vcls, vclz, vcnt, vswp, vtrn, vtbl, vtbx, vldm, vstm, vldr,
	vstr, vld[1234], vst[1234], fconst[sd], f[us][lh]to[sd],
	fto[us][lh][sd].
	(tc_arm_regname_to_dw2regnum): Update for arm_reg_parse args.
	(arm_cpu_option_table): Add Neon and VFPv3 to Cortex-A8.
	(arm_option_cpu_value): Add vfp3 and neon.
	(aeabi_set_public_attributes): Support VFPv3 and NEON attributes. Fix
	VFPv1 attribute.
@
text
@d268 1
d274 1
a274 2
  NT_unsigned,
  NT_invtype
d313 1
d409 11
d445 4
a448 1
/* Structure for a hash table entry for a register.  */
d451 5
a455 4
  const char   *name;
  unsigned char number;
  unsigned char type;
  unsigned char builtin;
a1007 5
/* As above, but the register must be of type TYPE, and the return
   value is the register number or FAIL.
   If RTYPE is non-zero, return the (possibly restricted) type of the
   register (e.g. Neon double or quad reg when either has been requested).  */

d1009 2
a1010 1
arm_reg_parse (char **ccp, enum arm_reg_type type, enum arm_reg_type *rtype)
a1011 14
  char *start = *ccp;
  struct reg_entry *reg = arm_reg_parse_multi (ccp);

  /* Undo polymorphism for Neon D and Q registers.  */
  if (reg && type == REG_TYPE_NDQ
      && (reg->type == REG_TYPE_NQ || reg->type == REG_TYPE_VFD))
    type = reg->type;

  if (rtype)
    *rtype = type;

  if (reg && reg->type == type)
    return reg->number;

d1043 23
d1070 273
d1348 1
a1348 1
parse_scalar (char **ccp, int elsize)
d1350 1
a1350 1
  int regno, elno;
d1352 1
a1352 1
  expressionS exp;
d1354 1
a1354 2
  if ((regno = arm_reg_parse (&str, REG_TYPE_VFD, NULL)) == FAIL)
    return FAIL;
d1356 1
a1356 1
  if (skip_past_char (&str, '[') == FAIL)
d1359 1
a1359 2
  my_get_expression (&exp, &str, GE_NO_PREFIX);
  if (exp.X_op != O_constant)
d1361 1
a1361 1
      inst.error = _("constant expression required");
d1364 1
a1364 3
  elno = exp.X_add_number;
  
  if (elno >= 64 / elsize)
d1366 1
a1366 1
      inst.error = _("scalar index out of range");
d1370 2
a1371 2
  if (skip_past_char (&str, ']') == FAIL)
    return FAIL;
a1372 1
  /* Parsed scalar successfully. Skip over it.  */
d1375 1
a1375 1
  return (regno * 8) + elno;
d1401 1
a1401 1
	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN, NULL)) == FAIL)
d1403 1
a1403 1
		  inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
d1413 1
a1413 1
		      inst.error = _("bad range in register list");
d1444 1
a1444 1
	      inst.error = _("missing `}'");
d1523 3
a1525 1
     - 32 D registers may be used (also true for VFPv3).  */
d1582 3
a1584 1
      new_base = arm_reg_parse (str, regtype, &regtype);
d1587 1
a1587 1
	  inst.error = gettext (reg_expected_msgs[regtype]);
d1590 1
a1590 1

d1603 1
a1603 1
	  inst.error = _("invalid register list");
d1622 2
a1623 1
	  if ((high_range = arm_reg_parse (str, regtype, NULL)) == FAIL)
d1675 26
d1703 1
a1703 1
   The lane (or one of the #defined constants below) is placed in bits [3:0] of
d1706 2
a1707 1
   Bits [6:5] encode the list length (minus one).  */
a1708 2
#define NEON_ALL_LANES		15
#define NEON_INTERLEAVE_LANES	14
d1710 1
a1710 1
#define NEON_REG_STRIDE(X)	(((X) & (1 << 4)) ? 2 : 1)
d1714 2
a1715 1
parse_neon_el_struct_list (char **str, unsigned *pbase)
d1727 1
d1734 3
a1736 1
      int getreg = arm_reg_parse (&ptr, rtype, &rtype);
d1739 1
a1739 1
          inst.error = _(reg_expected_msgs[rtype]);
d1751 1
d1758 1
a1758 1
              inst.error = _(incr_error);
d1764 7
a1770 1
          inst.error = _(incr_error);
d1778 1
d1784 1
a1784 1
              inst.error = _(type_error);
d1791 1
a1791 1
              inst.error = _("don't use Rn-Rm syntax with non-unit stride");
d1795 1
a1795 1
          hireg = arm_reg_parse (&ptr, rtype, NULL);
d1798 6
a1803 1
              inst.error = _(reg_expected_msgs[rtype]);
d1817 1
a1817 1
      if (skip_past_char (&ptr, '[') == SUCCESS)
d1819 3
a1821 1
          if (skip_past_char (&ptr, ']') == SUCCESS)
d1823 2
a1824 30
              if (lane == -1)
                lane = NEON_ALL_LANES;
              else if (lane != NEON_ALL_LANES)
                {
                  inst.error = _(type_error);
                  return FAIL;
                }
            }
          else
            {
              expressionS exp;
              my_get_expression (&exp, &ptr, GE_NO_PREFIX);
              if (exp.X_op != O_constant)
                {
                  inst.error = _("constant expression required");
                  return FAIL;
                }
              if (lane == -1)
                lane = exp.X_add_number;
              else if (lane != exp.X_add_number)
                {
                  inst.error = _(type_error);
                  return FAIL;
                }
              
              if (skip_past_char (&ptr, ']') == FAIL)
                {
                  inst.error = _("expected ]");
                  return FAIL;
                }
d1831 1
a1831 1
          inst.error = _(type_error);
d1846 1
a1846 1
      inst.error = _("error parsing element/structure list");
d1852 1
a1852 1
      inst.error = _("expected }");
d1859 3
d1899 1
a1899 1
static void
d1915 1
a1915 1
      return;
d1925 1
d1929 21
d2017 142
d2167 12
d2216 2
d3284 1
a3284 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR, NULL);
d3299 1
a3299 1
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR, NULL);
d3416 1
a3416 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG, NULL);
d3432 1
a3432 1
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG, NULL);
d3530 1
a3530 1
  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN, NULL);
d3591 1
a3591 1
  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN, NULL);
d3595 1
a3595 1
    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN, NULL);
d3791 3
d4095 1
a4095 1
	  && (reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) != FAIL)
d4126 1
a4126 1
  if ((value = arm_reg_parse (str, REG_TYPE_RN, NULL)) != FAIL)
d4237 1
a4237 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) == FAIL)
d4252 1
a4252 1
      if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) != FAIL)
d4335 1
a4335 1
	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) != FAIL)
d4596 1
a4596 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) == FAIL)
d4609 1
a4609 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) == FAIL)
d4651 1
d4653 1
a4653 1
  if ((val = parse_scalar (&ptr, 8)) != FAIL)
d4658 1
d4664 1
a4664 1
      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) == FAIL)
d4671 2
a4672 1
  else if ((val = arm_reg_parse (&ptr, REG_TYPE_NDQ, &rtype)) != FAIL)
d4681 1
d4684 1
a4684 1
      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) != FAIL)
d4694 1
a4694 1
              inst.error = _("can't use Neon quad register here");
d4699 1
a4699 1
          if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) == FAIL)
d4712 2
a4713 1
      else if ((val = arm_reg_parse (&ptr, REG_TYPE_NDQ, &rtype)) != FAIL)
d4723 1
d4728 1
a4728 1
          inst.error = _("expected <Rm> or <Dm> or <Qm> operand");
d4732 1
a4732 1
  else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) != FAIL)
d4742 1
a4742 1
      if ((val = parse_scalar (&ptr, 8)) != FAIL)
d4748 1
d4750 1
a4750 1
      else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) != FAIL)
d4760 2
a4761 1
          if ((val = arm_reg_parse (&ptr, REG_TYPE_VFD, NULL)) == FAIL)
d4763 1
a4763 1
              inst.error = _(reg_expected_msgs[REG_TYPE_VFD]);
d4770 1
d4776 1
a4776 1
      inst.error = _("parse error");
d4786 1
a4786 1
  inst.error = _("expected comma");
d4790 1
a4790 1
  inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
d4794 1
a4794 1
  inst.error = _("instruction cannot be conditionalized");
d4921 11
a4931 10
#define po_reg_or_fail(regtype) do {			\
  val = arm_reg_parse (&str, regtype, &rtype);		\
  if (val == FAIL)					\
    {							\
      inst.error = _(reg_expected_msgs[regtype]);	\
      goto failure;					\
    }							\
  inst.operands[i].reg = val;				\
  inst.operands[i].isreg = 1;				\
  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);	\
d4934 9
a4942 8
#define po_reg_or_goto(regtype, label) do {		\
  val = arm_reg_parse (&str, regtype, &rtype);		\
  if (val == FAIL)					\
    goto label;						\
							\
  inst.operands[i].reg = val;				\
  inst.operands[i].isreg = 1;				\
  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);	\
d4951 6
a4956 6
#define po_scalar_or_goto(elsz, label) do {	\
  val = parse_scalar (&str, elsz);		\
  if (val == FAIL)				\
    goto label;					\
  inst.operands[i].reg = val;			\
  inst.operands[i].isscalar = 1;		\
d5269 2
a5270 1
          val = parse_neon_el_struct_list (&str, &inst.operands[i].reg);
d5458 1
a5458 1
          inst.error = _("D register out of range for selected VFP version");
d9505 1
d9510 2
d9549 1
a9549 1
        else if (RQ(0) && RQ(1) && RQ(1))
d9552 2
a9553 2
          inst.error = _("expected <Qd>, <Qn>, <Qm> or <Dd>, <Dn>, <Dm> "
                         "operands");
d9564 2
a9565 2
          inst.error = _("expected <Qd>, <Qn>, #<imm> or <Dd>, <Dn>, #<imm> "
                         "operands");
d9576 2
a9577 2
          inst.error = _("expected <Qd>, <Qn>, <Qm>, #<imm> or "
                         "<Dd>, <Dn>, <Dm>, #<imm> operands");
d9588 2
a9589 2
          inst.error = _("expected <Qd>, <Qn>, <Dm[x]> or <Dd>, <Dn>, <Dm[x]> "
                         "operands");
d9600 1
a9600 1
          inst.error = _("expected <Qd>, <Qm> or <Dd>, <Dm> operands");
d9611 1
a9611 1
          inst.error = _("expected <Qd>, <Dm[x]> or <Dd>, <Dm[x]> operands");
d9622 1
a9622 1
          inst.error = _("expected <Qd>, <Rm> or <Dd>, <Rm> operands");
d9633 1
a9633 1
          inst.error = _("expected <Qd>, #<imm> or <Dd>, #<imm> operands");
d9669 2
d9764 1
a9764 1
static void
d9768 3
d9773 1
a9773 1
  if ((mask & (N_S16 | N_U16 | N_I16 | N_16 | N_P16)) != 0)
d9775 1
a9775 1
  if ((mask & (N_S32 | N_U32 | N_I32 | N_32 | N_F32)) != 0)
d9777 1
a9777 1
  if ((mask & (N_S64 | N_U64 | N_I64 | N_64)) != 0)
d9779 3
d9784 1
a9784 1
  if ((mask & (N_U8 | N_U16 | N_U32 | N_U64)) != 0)
d9786 1
a9786 1
  if ((mask & (N_I8 | N_I16 | N_I32 | N_I64)) != 0)
d9788 1
a9788 1
  if ((mask & (N_8 | N_16 | N_32 | N_64)) != 0)
d9790 1
a9790 1
  if ((mask & (N_P8 | N_P16)) != 0)
d9792 1
a9792 1
  if ((mask & N_F32) != 0)
d9794 4
d9815 5
a9819 3
      el_type_of_type_chk (&type, &size, allowed & i);
      neon_modify_type_size (mods, &type, &size);
      destmask |= type_chk_of_el_type (type, size);
d9870 8
d9888 15
d9904 9
a9912 3
          if (j != key_el)
            inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
                                                    types[j]);
d9917 1
a9917 1
      inst.error = _("type specifier has the wrong number of parts");
d9963 1
a9963 1
	              inst.error = _("bad type in Neon instruction");
d9974 1
a9974 1
                      inst.error = _("inconsistent types in Neon instruction");
d10028 1
a10028 1
neon_three_same (int first_optional, int isquad, int ubit, int size)
a10029 4
  /* FIXME optional argument handling.  */
  if (first_optional && !inst.operands[0].present)
    inst.operands[0].reg = inst.operands[1].reg;

d10075 1
a10075 1
  neon_three_same (TRUE, rs == NS_QQQ, et.type == NT_unsigned, et.size);
d10084 1
a10084 1
  neon_three_same (TRUE, rs == NS_QQQ, et.type == NT_unsigned, et.size);
d10122 1
a10122 1
      neon_three_same (TRUE, rs == NS_QQQ, et.type == NT_unsigned, et.size);
d10143 1
a10143 1
      neon_three_same (TRUE, rs == NS_QQQ, et.type == NT_unsigned, et.size);
d10192 1
a10192 1
  inst.error = _("immediate value out of range");
d10378 1
a10378 1
      neon_three_same (TRUE, rs == NS_QQQ, 0, -1);
d10441 2
a10442 2
  /* FIXME: Check that no type was given.  */
  neon_three_same (FALSE, rs == NS_QQQ, 0, -1);
d10446 2
a10447 1
neon_dyadic (enum neon_el_type ubit_meaning, unsigned types)
d10450 2
a10451 1
  struct neon_type_el et = neon_check_type (3, rs, N_EQK, N_EQK, types | N_KEY);
d10455 1
a10455 1
      neon_three_same (TRUE, rs == NS_QQQ, 0, -1);
d10460 1
a10460 1
      neon_three_same (TRUE, rs == NS_QQQ, et.type == ubit_meaning, et.size);
d10467 1
a10467 1
  neon_dyadic (NT_unsigned, N_SUF_32);
d10475 1
a10475 1
  neon_dyadic (NT_unsigned, N_SUF_32);
d10481 1
a10481 1
  neon_dyadic (NT_unsigned, N_IF_32);
d10487 1
a10487 1
  neon_dyadic (NT_unsigned, N_IF_32);
d10495 1
a10495 1
  neon_dyadic (NT_untyped, N_IF_32 | N_I64);
d10532 1
a10532 1
      neon_dyadic (NT_unsigned, regtypes);
d10537 2
a10538 1
      struct neon_type_el et = neon_check_type (2, rs, N_EQK, immtypes | N_KEY);
d10580 2
a10581 2
  unsigned regno = scalar >> 3;
  unsigned elno = scalar & 7;
d10597 1
a10597 1
      as_bad (_("Scalar out of range for multiply instruction"));
d10608 7
a10614 1
  unsigned scalar = neon_scalar_for_mul (inst.operands[2].reg, et.size);
d10649 1
a10649 1
  neon_three_same (TRUE, rs == NS_QQQ, 0, et.size);
d10662 1
a10662 1
    neon_dyadic (NT_poly, N_I8 | N_I16 | N_I32 | N_F32 | N_P8);
d10683 1
a10683 1
      neon_three_same (TRUE, rs == NS_QQQ, 0, et.size);
d10693 1
a10693 1
  neon_three_same (TRUE, rs == NS_QQQ, 1, -1);
d10708 1
a10708 1
  neon_three_same (TRUE, rs == NS_QQQ, 0, -1);
d11010 1
a11010 1
          inst.error = _("immediate out of range");
d11093 2
a11094 2
      struct neon_type_el et = neon_check_type (2, NS_QDS,
        N_EQK | N_DBL, regtypes | N_KEY);
d11196 2
a11197 1
      struct neon_type_el et = neon_check_type (1, rs, N_8 | N_16 | N_32);
d11199 1
a11199 1
      unsigned dm = inst.operands[1].reg >> 3;
d11201 1
a11201 1
      unsigned x = (inst.operands[1].reg & 7) << logsize;
d11216 2
a11217 1
      struct neon_type_el et = neon_check_type (1, rs, N_8 | N_16 | N_32);
d11282 2
a11283 2
          struct neon_type_el et = neon_check_type (1, NS_IGNORE,
            N_S8 | N_S16 | N_U8 | N_U16 | N_32);
d11285 2
a11286 2
          unsigned dn = inst.operands[1].reg >> 3;
          unsigned x = inst.operands[1].reg & 7;
d11289 1
d11316 2
a11317 2
              struct neon_type_el et = neon_check_type (1, NS_IGNORE,
                                                        N_8 | N_16 | N_32);
d11319 2
a11320 2
              unsigned dn = inst.operands[0].reg >> 3;
              unsigned x = inst.operands[0].reg & 7;
d11322 1
d11523 1
a11523 1
  neon_check_type (1, NS_DLD, N_8);
d11527 1
a11527 1
      inst.error = _("bad list length for table lookup");
d11644 3
d11663 1
a11663 1
        inst.error = _("bad alignment");
d11722 1
a11722 1
    inst.error = _("unsupported alignment for instruction");
d11737 3
d11820 3
d11835 1
a11835 1
        default: inst.error = _("bad list length"); return;
a12060 79
/* Parse a Neon type specifier. *STR should point at the leading '.'
   character. Does no verification at this stage that the type fits the opcode
   properly. E.g.,

     .i32.i32.s16
     .s32.f32
     .u16

   Can all be legally parsed by this function.

   Fills in neon_type struct pointer with parsed information, and updates STR
   to point after the parsed type specifier. Returns TRUE if this was a legal
   type, FALSE if not.  */

static bfd_boolean
parse_neon_type (struct neon_type *type, char **str)
{
  char *ptr = *str;

  if (type)
    type->elems = 0;

  while (type->elems < NEON_MAX_TYPE_ELS)
    {
      enum neon_el_type thistype = NT_untyped;
      unsigned thissize = -1u;

      if (*ptr != '.')
	break;

      ptr++;

      /* Just a size without an explicit type.  */
      if (ISDIGIT (*ptr))
	goto parsesize;

      switch (*ptr)
	{
	case 'i': thistype = NT_integer; break;
	case 'f': thistype = NT_float; break;
	case 'p': thistype = NT_poly; break;
	case 's': thistype = NT_signed; break;
	case 'u': thistype = NT_unsigned; break;
	default:
	  as_bad (_("Unexpected character `%c' in type specifier"), *ptr);
	  return 0;
	}

      ptr++;

      /* .f is an abbreviation for .f32.  */
      if (thistype == NT_float && !ISDIGIT (*ptr))
	thissize = 32;
      else
	{
	parsesize:
	  thissize = strtoul (ptr, &ptr, 10);

	  if (thissize != 8 && thissize != 16 && thissize != 32
              && thissize != 64)
            {
              as_bad (_("Bad size %d in type specifier"), thissize);
	      return 0;
	    }
	}

      if (type)
        {
          type->el[type->elems].type = thistype;
	  type->el[type->elems].size = thissize;
	  type->elems++;
	}
    }

  *str = ptr;

  return 1;
}

d12179 1
a12179 1
          if (!parse_neon_type (&inst.vectype, str))
d12309 3
a12311 2
	 the form alias .req reg.  */
      if (!create_register_alias (str, p))
d12526 1
a12526 1
#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, TRUE }
d15427 1
a15427 1
  int reg = arm_reg_parse ((char **) &regname, REG_TYPE_RN, NULL);
@


1.258
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d29 1
d159 2
d212 4
d266 25
d298 1
d316 6
d397 1
a397 1
enum vfp_sp_reg_pos
d399 2
a400 1
  VFP_REG_Sd, VFP_REG_Sm, VFP_REG_Sn
d418 2
d450 3
a452 1
  N_("VFP double precision register expected"),
d738 3
d750 2
a751 1
    prefix_mode = GE_OPT_PREFIX;
d765 1
d807 6
a812 5
  if (ep->X_op == O_big
      || (ep->X_add_symbol
	  && (walk_no_bignums (ep->X_add_symbol)
	      || (ep->X_op_symbol
		  && walk_no_bignums (ep->X_op_symbol)))))
d993 3
a995 1
   value is the register number or FAIL.  */
d998 1
a998 1
arm_reg_parse (char **ccp, enum arm_reg_type type)
d1003 8
d1049 40
d1112 1
a1112 1
	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN)) == FAIL)
d1214 9
d1225 10
a1234 1
   register.  Double precision registers are matched if DP is nonzero.	*/
d1237 1
a1237 1
parse_vfp_reg_list (char **str, unsigned int *pbase, int dp)
d1241 2
a1242 2
  int regtype;
  int max_regs;
d1249 4
a1252 1
    return FAIL;
d1256 1
a1256 1
  if (dp)
d1258 6
d1265 17
a1281 5
      max_regs = 16;
    }
  else
    {
      regtype = REG_TYPE_VFS;
d1283 1
d1290 2
a1291 1
      new_base = arm_reg_parse (str, regtype);
d1298 7
d1308 1
a1308 1
      if (mask & (1 << new_base))
d1320 2
a1321 2
      mask |= 1 << new_base;
      count++;
d1329 1
a1329 1
	  if ((high_range = arm_reg_parse (str, regtype)) == FAIL)
d1335 3
d1344 1
a1344 1
	  for (new_base++; new_base <= high_range; new_base++)
d1346 1
a1346 1
	      if (mask & (1 << new_base))
d1352 2
a1353 2
	      mask |= 1 << new_base;
	      count++;
d1381 174
d2751 1
a2751 1
  count = parse_vfp_reg_list (&input_line_pointer, &reg, 1);
d2793 1
a2793 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
d2808 1
a2808 1
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
d2925 1
a2925 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
d2941 1
a2941 1
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
d3039 1
a3039 1
  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
d3100 1
a3100 1
  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
d3104 1
a3104 1
    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
d3371 41
d3601 1
a3601 1
	  && (reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
d3632 1
a3632 1
  if ((value = arm_reg_parse (str, REG_TYPE_RN)) != FAIL)
d3743 1
a3743 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
d3758 1
a3758 1
      if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
d3767 17
d3841 1
a3841 1
	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
d3843 6
a3848 1
	      inst.operands[i].imm = reg;
d4102 1
a4102 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
d4115 1
a4115 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
d4143 152
d4308 5
a4312 1
  OP_RVD,	/* VFP double precision register */
d4328 2
d4331 10
d4344 1
d4348 2
d4351 2
d4382 1
d4388 3
d4411 1
d4419 1
a4419 1
  val = arm_reg_parse (&str, regtype);			\
d4427 1
d4430 8
a4437 7
#define po_reg_or_goto(regtype, label) do {	\
  val = arm_reg_parse (&str, regtype);		\
  if (val == FAIL)				\
    goto label;					\
						\
  inst.operands[i].reg = val;			\
  inst.operands[i].isreg = 1;			\
d4446 8
d4487 2
d4500 98
d4615 1
d4618 1
d4620 3
d4632 1
d4751 1
a4751 1
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, 0);
d4755 1
a4755 1
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, 1);
d4758 9
d4815 2
d4874 1
d4933 1
a4933 1
/* Encode a VFP SP register number into inst.instruction.  */
d4936 1
a4936 1
encode_arm_vfp_sp_reg (int reg, enum vfp_sp_reg_pos pos)
d4938 19
d4971 12
d6270 2
a6271 2
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sm);
d6277 3
a6279 3
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sn);
  encode_arm_vfp_sp_reg (inst.operands[2].reg, VFP_REG_Sm);
d6285 1
a6285 1
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
d6291 2
a6292 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sm);
d6298 2
a6299 2
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  inst.instruction |= inst.operands[1].reg;
d6306 1
a6306 1
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sn);
d6316 1
a6316 1
  encode_arm_vfp_sp_reg (inst.operands[2].reg, VFP_REG_Sm);
d6322 1
a6322 1
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sn);
d6331 1
a6331 1
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sm);
d6339 1
a6339 1
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
d6346 1
a6346 1
  inst.instruction |= inst.operands[0].reg << 12;
d6360 1
a6360 1
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sd);
d6376 1
a6376 1
  inst.instruction |= inst.operands[1].reg << 12;
d6420 97
a8822 2

/* Overall per-instruction processing.	*/
d8824 6
a8829 6
/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.	We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */
d8831 1
a8831 7
static void
fix_new_arm (fragS *	   frag,
	     int	   where,
	     short int	   size,
	     expressionS * exp,
	     int	   pc_rel,
	     int	   reloc)
d8833 56
a8888 1
  fixS *	   new_fix;
d8890 6
a8895 8
  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;
d8897 6
a8902 5
    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
    }
d8904 21
a8924 4
  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  new_fix->tc_fix_data = thumb_mode;
}
d8926 2483
a11408 3
/* Create a frg for an instruction requiring relaxation.  */
static void
output_relax_insn (void)
d11491 79
d11669 1
a11669 1
  /* Handle a possible width suffix.  */
d11672 3
a11674 1
      if (end[1] == 'w' && (end[2] == ' ' || end[2] == '\0'))
d11676 1
a11676 1
      else if (end[1] == 'n' && (end[2] == ' ' || end[2] == '\0'))
d11679 1
a11679 1
	return 0;
d11681 12
a11692 1
      *str = end + 2;
d12036 1
d12042 10
d12090 2
a12091 11
  REGSET(s,VFS),
  REGNUM(s,16,VFS), REGNUM(s,17,VFS), REGNUM(s,18,VFS), REGNUM(s,19,VFS),
  REGNUM(s,20,VFS), REGNUM(s,21,VFS), REGNUM(s,22,VFS), REGNUM(s,23,VFS),
  REGNUM(s,24,VFS), REGNUM(s,25,VFS), REGNUM(s,26,VFS), REGNUM(s,27,VFS),
  REGNUM(s,28,VFS), REGNUM(s,29,VFS), REGNUM(s,30,VFS), REGNUM(s,31,VFS),

  REGSET(S,VFS),
  REGNUM(S,16,VFS), REGNUM(S,17,VFS), REGNUM(S,18,VFS), REGNUM(S,19,VFS),
  REGNUM(S,20,VFS), REGNUM(S,21,VFS), REGNUM(S,22,VFS), REGNUM(S,23,VFS),
  REGNUM(S,24,VFS), REGNUM(S,25,VFS), REGNUM(S,26,VFS), REGNUM(S,27,VFS),
  REGNUM(S,28,VFS), REGNUM(S,29,VFS), REGNUM(S,30,VFS), REGNUM(S,31,VFS),
d12094 6
a12099 1
  REGSET(d,VFD), REGSET(D,VFS),
d12438 24
d13402 1
a13402 1
 cCE(fcpyd,	eb00b40, 2, (RVD, RVD),	      rd_rm),
d13405 4
a13408 4
 cCE(fmdhr,	e200b10, 2, (RVD, RR),	      rn_rd),
 cCE(fmdlr,	e000b10, 2, (RVD, RR),	      rn_rd),
 cCE(fmrdh,	e300b10, 2, (RR, RVD),	      rd_rn),
 cCE(fmrdl,	e100b10, 2, (RR, RVD),	      rd_rn),
d13429 3
a13431 3
 cCE(fabsd,	eb00bc0, 2, (RVD, RVD),	      rd_rm),
 cCE(fnegd,	eb10b40, 2, (RVD, RVD),	      rd_rm),
 cCE(fsqrtd,	eb10bc0, 2, (RVD, RVD),	      rd_rm),
d13434 9
a13442 9
 cCE(faddd,	e300b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
 cCE(fsubd,	e300b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
 cCE(fmuld,	e200b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
 cCE(fdivd,	e800b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
 cCE(fmacd,	e000b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
 cCE(fmscd,	e100b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
 cCE(fnmuld,	e200b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
 cCE(fnmacd,	e000b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
 cCE(fnmscd,	e100b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
d13445 4
a13448 4
 cCE(fcmpd,	eb40b40, 2, (RVD, RVD),	      rd_rm),
 cCE(fcmpzd,	eb50b40, 1, (RVD),	      rd),
 cCE(fcmped,	eb40bc0, 2, (RVD, RVD),	      rd_rm),
 cCE(fcmpezd,	eb50bc0, 1, (RVD),	      rd),
d13454 250
a13703 2
 cCE(fmdrr,	c400b10, 3, (RVD, RR, RR),    rm_rd_rn),
 cCE(fmrrd,	c500b10, 3, (RR, RR, RVD),    rd_rn_rm),
d13705 45
d14020 4
d14935 1
a14935 1
  int reg = arm_reg_parse ((char **) &regname, REG_TYPE_RN);
d17127 3
a17129 1
  {"cortex-a8",		ARM_ARCH_V7A,	 FPU_ARCH_VFP_V2, NULL},
d17219 1
d17228 1
d17624 1
a17624 1
  
d17669 5
a17673 2
  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_arch_vfp_v2)
      || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_arch_vfp_v2))
d17675 4
a17678 2
  else if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_arch_vfp_v1)
	   || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_arch_vfp_v1))
d17684 4
@


1.257
log
@2005-04-20  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (s_arm_arch, s_arm_cpu, s_arm_fpu): Enable for
	all targets.
	(md_pseudo_table): Enable .arch, .cpu and .fpu for all targets.
gas/testsuite/
	* gas/arm/arch7.d: Remove skip.
	* gas/arm/svc.d: Ditto.
	* gas/arm/thumb2_bcond.d: Ditto.
	* gas/arm/thumb2_it_bad.d: Ditto.
@
text
@d2505 1
a2505 1
  /* Generate any deferred opcodes becuuse we're going to be looking at
d2638 1
a2638 1
  /* Generate any deferred opcodes becuuse we're going to be looking at
d2821 1
a2821 1
  /* This is an arbitary limit.	 */
d4573 1
a4573 1
  /* Enforce resutrictions on SWP instruction.  */
d8435 1
a8435 1
	 set those bits when Thumb-2 32-bit instuctions are seen.  ie.
d10897 1
a10897 1
      /* Adjust sp as neccessary.  */
@


1.256
log
@2006-04-07  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (parse_operands): Set default error message.
@
text
@d2959 1
a2963 1
#endif /* OBJ_ELF */
d2988 3
a3005 3
  { "cpu",		s_arm_cpu,		0 },
  { "arch",		s_arm_arch,		0 },
  { "fpu",		s_arm_fpu,		0 },
d13912 1
a14018 1
#endif /* OBJ_ELF */
@


1.256.2.1
log
@2006-05-02  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Set thumb funciton bit
	for R_ARM_REL32.
gas/
	* config/tc-arm.c (arm_optimize_expr): New function.
	* config/tc-arm.h (md_optimize_expr): Define
	(arm_optimize_expr): Add prototype.
	(TC_FORCE_RELOCATION_SUB_SAME): Define.
ld/testsuite/
	* ld-arm/arm-elf.exp: Add thumb-rel32.
	* ld-arm/thumb-rel32.d: New test.
	* ld-arm/thumb-rel32.s: New test.
@
text
@a11493 23

/* We usually want to set the low bit on the address of thumb function
   symbols.  In particular .word foo - . should have the low bit set.
   Generic code tries to fold the difference of two symbols to
   a constant.  Prevent this and force a relocation when the first symbols
   is a thumb function.  */
int
arm_optimize_expr (expressionS *l, operatorT op, expressionS *r)
{
  if (op == O_subtract
      && l->X_op == O_symbol
      && r->X_op == O_symbol
      && THUMB_IS_FUNC (l->X_add_symbol))
    {
      l->X_op = O_subtract;
      l->X_op_symbol = r->X_add_symbol;
      l->X_add_number -= r->X_add_number;
      return 1;
    }
  /* Process as normal.  */
  return 0;
}

@


1.256.2.2
log
@	* config/tc-arm.c (do_iwmmxt_wldstbh): Don't multiply offset by 4
	here.
	(md_apply_fix3): Multiply offset by 4 here for
	BFD_RELOC_ARM_CP_OFF_IMM_S2 and BFD_RELOC_ARM_T32_CP_OFF_IMM_S2.

testsuite:
	* gas/arm/iwmmxt.s: Increase offsets for wstrb and wstrh.
	* gas/arm/iwmmxt.d: Update expected results.
	* gas/arm/iwmmxt-bad2.s: Test wstrb, wstrh, wldrb and wldrh.
	* gas/arm/iwmmxt-bad2.l: Update expected error messages.
@
text
@d5806 1
a12182 1
      value *= 4;
@


1.255
log
@2006-04-07  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (parse_tb): Set inst.error before returning FAIL.
@
text
@d4142 7
a4148 1
	return FAIL;
d4156 5
a4160 1
	return FAIL;
@


1.254
log
@2006-04-07  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (md_apply_fix): Set H bit on blx instruction.
gas/testsuite/
	* gas/arm/blx-local.d: New test.
	* gas/arm/blx-local.d: New test.
@
text
@d3709 4
a3712 1
    return FAIL;
d3722 4
a3725 1
    return FAIL;
@


1.253
log
@2006-04-07  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (THUMB2_LOAD_BIT): Define.
	(move_or_literal_pool): Handle Thumb-2 instructions.
	(do_t_ldst): Call move_or_literal_pool for =N addressing modes.
gas/testsuite/
	* gas/arm/thumb2_pool.d: New test.
	* gas/arm/thumb2_pool.s: New test.
@
text
@d11930 8
@


1.252
log
@2006-03-21  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (md_apply_fix): Fix typo in offset mask.
@
text
@d563 1
d4447 8
a4454 1
  if ((inst.instruction & (thumb_p ? THUMB_LOAD_BIT : LOAD_BIT)) == 0)
d4468 1
a4468 1
	  if ((inst.reloc.exp.X_add_number & ~0xFF) == 0)
d5976 1
a5976 1
	      _("Thumb does not support the ldr =N pseudo-operation"));
d6990 7
@


1.251
log
@2006-03-21  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (insns): Correct opcodes for ldrbt and strbt.
gas/testsuite/
	* gas/arm/thumb32.d: Correct expected output.
@
text
@d11928 1
a11928 1
	  newval |= ((value & 0x2e) << 2) | ((value & 0x40) << 3);
@


1.250
log
@2006-03-20  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (BAD_BRANCH, BAD_NOT_IT): Define.
	(do_t_branch): Encode branches inside IT blocks as unconditional.
	(do_t_cps): New function.
	(do_t_blx, do_t_bkpt, do_t_branch23, do_t_bx, do_t_bxj, do_t_cpsi,
	do_t_czb, do_t_it, do_t_setend, do_t_tb): Add IT constaints.
	(opcode_lookup): Allow conditional suffixes on all instructions in
	Thumb mode.
	(md_assemble): Advance condexec state before checking for errors.
	(insns): Use do_t_cps.
gas/testsuite/
	* gas/arm/thumb2_bcond.d: New test.
	* gas/arm/thumb2_bcond.s: New test.
	* gas/arm/thumb2_it_bad.d: New test.
	* gas/arm/thumb2_it_bad.l: New test.
	* gas/arm/thumb2_it_bad.s: New test.
@
text
@d9037 1
a9037 1
 TC3(ldrbt,	4700000, f8300e00, 2, (RR, ADDR),    ldstt, t_ldstt),
d9039 1
a9039 1
 TC3(strbt,	4600000, f8200e00, 2, (RR, ADDR),    ldstt, t_ldstt),
@


1.250.2.1
log
@2006-03-20  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (THUMB2_LOAD_BIT): Define.
	(move_or_literal_pool): Handle Thumb-2 instructions.
	(do_t_ldst): Call move_or_literal_pool for =N addressing modes.
gas/testsuite/
	* gas/arm/thumb2_pool.d: New test.
	* gas/arm/thumb2_pool.s: New test.
@
text
@a562 1
#define THUMB2_LOAD_BIT 0x00100000
d4446 1
a4446 8
  unsigned long tbit;

  if (thumb_p)
    tbit = (inst.instruction > 0xffff) ? THUMB2_LOAD_BIT : THUMB_LOAD_BIT;
  else
    tbit = LOAD_BIT;

  if ((inst.instruction & tbit) == 0)
d4460 1
a4460 1
	  if (!unified_syntax && (inst.reloc.exp.X_add_number & ~0xFF) == 0)
d5968 1
a5968 1
	      _("Instruction does not support =N addresses"));
a6981 7
      if (!inst.operands[1].isreg)
	{
	  if (opcode <= 0xffff)
	    inst.instruction = THUMB_OP32 (opcode);
	  if (move_or_literal_pool (0, /*thumb_p=*/TRUE, /*mode_3=*/FALSE))
	    return;
	}
@


1.250.2.2
log
@2006-03-20  Paul Brook  <paul@@codesourcery.com>

	* gas/config/tc-arm.c (md_apply_fix): Set H bit on blx instruction.

	* gas/testsuite/gas/arm/blx-local.d: New test.
	* gas/testsuite/gas/arm/blx-local.d: New test.
@
text
@a11929 8
	  /* Set the H bit on BLX instructions.  */
	  if (temp == 1)
	    {
	      if (value & 2)
		newval |= 0x01000000;
	      else
		newval &= ~0x01000000;
	    }
@


1.250.2.3
log
@2006-03-20  Paul Brook  <paul@@codesourcery.com>

	* gas/config/tc-arm.c (parse_tb): Set inst.error before returning FAIL.
@
text
@d3709 1
a3709 4
    {
      inst.error = _("'[' expected");
      return FAIL;
    }
d3719 1
a3719 4
    {
      inst.error = _("',' expected");
      return FAIL;
    }
@


1.250.2.4
log
@2006-03-20  Paul Brook  <paul@@codesourcery.com>

	* gas/config/tc-arm.c (parse_operands): Set default error message.
@
text
@d4142 1
a4142 7
	{
	  /* The parse routine should already have set inst.error, but set a
	     defaut here just in case.  */
	  if (!inst.error)
	    inst.error = _("syntax error");
	  return FAIL;
	}
d4150 1
a4150 5
	{
	  if (!inst.error)
	    inst.error = _("syntax error");
	  return FAIL;
	}
@


1.250.2.5
log
@2006-03-20  Paul Brook  <paul@@codesourcery.com>

	* gas/config/tc-arm.c (insns): Correct opcodes for ldrbt and strbt.
	* gas/testsuite/gas/arm/thumb32.d: Correct expected output.
@
text
@d9068 1
a9068 1
 TC3(ldrbt,	4700000, f8100e00, 2, (RR, ADDR),    ldstt, t_ldstt),
d9070 1
a9070 1
 TC3(strbt,	4600000, f8000e00, 2, (RR, ADDR),    ldstt, t_ldstt),
@


1.250.2.6
log
@2006-03-21  Paul Brook  <paul@@codesourcery.com>

	* gas/config/tc-arm.c (md_apply_fix): Fix typo in offset mask.
@
text
@d11967 1
a11967 1
	  newval |= ((value & 0x3e) << 2) | ((value & 0x40) << 3);
@


1.250.2.7
log
@2005-04-01  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (arm_fix_adjustable): Return 0 for function symbols.
@
text
@d12617 3
a12619 3
/* Relocations against function names must be left unadjusted,
   so that the linker can use this information to generate interworking
   stubs.  The MIPS version of this function
a12635 4
  /* Preserve relocations against symbols with function type.  */
  if (symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_FUNCTION)
    return 0;

@


1.250.2.8
log
@	* binutils/readelf.c (arm_attr_tag_VFP_arch): Add VFPv3.

	* gas/config/tc-arm.c (limits.h): Include.
	(fpu_arch_vfp_v3, fpu_vfp_ext_v3, fpu_neon_ext_v1)
	(fpu_vfp_v3_or_neon_ext): Declare constants.
	(neon_el_type): New enumeration of types for Neon vector elements.
	(neon_type_el): New struct. Define type and size of a vector element.
   	(NEON_MAX_TYPE_ELS): Define constant. The maximum number of types per
	instruction.
	(neon_type): Define struct. The type of an instruction.
	(arm_it): Add 'vectype' for the current instruction.
	(isscalar, immisalign, regisimm, isquad): New predicates for operands.
	(vfp_sp_reg_pos): Rename to...
	(vfp_reg_pos): ...this, and add VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
	tags.
	(arm_reg_type): Add REG_TYPE_NQ (Neon Q register) and REG_TYPE_NDQ
	(Neon D or Q register).
	(reg_expected_msgs): Sync with above. Allow VFD to mean VFP or Neon
	D register.
	(GE_OPT_PREFIX_BIG): Define constant, for use in...
	(my_get_expression): Allow above constant as argument to accept
	64-bit constants with optional prefix.
	(arm_reg_parse): Add extra argument to return the specific type of
	register in when either a D or Q register (REG_TYPE_NDQ) is requested.
	Can be NULL.
	(parse_scalar): New function. Parse Neon scalar (vector reg and index).
	(parse_reg_list): Update for new arm_reg_parse args.
	(parse_vfp_reg_list): Allow parsing of Neon D/Q register lists.
	(parse_neon_el_struct_list): New function. Parse element/structure
	register lists for VLD<n>/VST<n> instructions.
	(s_arm_unwind_save_vfp): Update for new parse_vfp_reg_list args.
	(s_arm_unwind_save_mmxwr): Likewise.
	(s_arm_unwind_save_mmxwcg): Likewise.
	(s_arm_unwind_movsp): Likewise.
	(s_arm_unwind_setfp): Likewise.
	(parse_big_immediate): New function. Parse an immediate, which may
	be 64 bits wide. Put results in inst.operands[i].
	(parse_shift): Update for new arm_reg_parse args.
	(parse_address): Likewise. Add parsing of alignment specifiers.
	(parse_neon_mov): Parse the operands of a VMOV instruction.
	(operand_parse_code): Add OP_RND, OP_RNQ, OP_RNDQ, OP_RNSC,
	OP_NRDLST, OP_NSTRLST, OP_NILO, OP_RNDQ_I0, OP_RR_RNSC,
	OP_RNDQ_RNSC, OP_RND_RNSC, OP_VMOV, OP_RNDQ_IMVNb, OP_RNDQ_I63b,
	OP_I0, OP_I16z, OP_I32z, OP_I64, OP_I64z, OP_oI32b, OP_oRND,
	OP_oRNQ, OP_oRNDQ.
	(parse_operands): Handle new codes above.
	(encode_arm_vfp_sp_reg): Rename to...
	(encode_arm_vfp_reg): ...this. Handle D regs (0-31) too. Complain if
	selected VFP version only supports D0-D15.
	(do_vfp_sp_monadic, do_vfp_sp_dyadic, do_vfp_sp_compare_z)
	(do_vfp_dp_sp_cvt, do_vfp_reg_from_sp, do_vfp_reg2_from_sp2)
	(do_vfp_sp_from_reg, do_vfp_sp2_from_reg2, do_vfp_sp_ldst)
	(do_vfp_dp_ldst, vfp_sp_ldstm, vfp_dp_ldstm): Update for new
	encode_arm_vfp_reg name, and allow 32 D regs.
	(do_vfp_dp_rd_rm, do_vfp_dp_rn_rd, do_vfp_dp_rd_rn)
	(do_vfp_dp_rd_rn_rm, do_vfp_rm_rd_rn): New functions to encode VFP
	insns allowing 32 D regs.
	(do_vfp_sp_const, do_vfp_dp_const, vfp_conv, do_vfp_sp_conv_16)
	(do_vfp_dp_conv_16, do_vfp_sp_conv_32, do_vfp_dp_conv_32): Handle
	constant-load and conversion insns introduced with VFPv3.
	(neon_tab_entry): New struct.
	(NEON_ENC_TAB): Bit patterns for overloaded Neon instructions, and
	those which are the targets of pseudo-instructions.
	(neon_opc): Enumerate opcodes, use as indices into...
	(neon_enc_tab): ...this. Hold data from NEON_ENC_TAB.
	(NEON_ENC_INTEGER, NEON_ENC_ARMREG, NEON_ENC_POLY, NEON_ENC_FLOAT)
	(NEON_ENC_SCALAR, NEON_ENC_IMMED, NEON_ENC_INTERLV, NEON_ENC_LANE)
	(NEON_ENC_DUP): Define meaningful helper macros to look up values in
	neon_enc_tab.
	(neon_shape): Enumerate shapes (permitted register widths, etc.) for
	Neon instructions.
	(neon_type_mask): New. Compact type representation for type
	checking.
	(N_SU_ALL, N_SU_32, N_SU_16_64, N_SUF_32, N_I_ALL, N_IF_32): Common
	permitted type combinations.
	(N_IGNORE_TYPE): New macro.
	(neon_check_shape): New function. Check an instruction shape for
	multiple alternatives. Return the specific shape for the current
	instruction.
	(neon_modify_type_size): New function. Modify a vector type and
	size, depending on the bit mask in argument 1.
	(neon_type_promote): New function. Convert a given "key" type (of an
	operand) into the correct type for a different operand, based on a bit
	mask.
	(type_chk_of_el_type): New function. Convert a type and size into the
	compact representation used for type checking.
	(el_type_of_type_ckh): New function. Reverse of above (only when a
	single bit is set in the bit mask).
	(modify_types_allowed): New function. Alter a mask of allowed types
	based on a bit mask of modifications.
	(neon_check_type): New function. Check the type of the current
	instruction against the variable argument list. The "key" type of the
	instruction is returned.
	(neon_dp_fixup): New function. Fill in and modify instruction bits for
	a Neon data-processing instruction depending on whether we're in ARM
	mode or Thumb-2 mode.
	(neon_logbits): New function.
	(neon_three_same, neon_two_same, do_neon_dyadic_i_su)
	(do_neon_dyadic_i64_su, neon_imm_shift, do_neon_shl_imm)
	(do_neon_qshl_imm, neon_cmode_for_logic_imm)
	(neon_bits_same_in_bytes, neon_squash_bits, neon_is_quarter_float)
	(neon_qfloat_bits, neon_cmode_for_move_imm, neon_write_immbits)
	(neon_invert_size, do_neon_logic, do_neon_bitfield, neon_dyadic)
	(do_neon_dyadic_if_su, do_neon_dyadic_if_su_d, do_neon_dyadic_if_i)
	(do_neon_dyadic_if_i_d, do_neon_addsub_if_i, neon_exchange_operands)
	(neon_compare, do_neon_cmp, do_neon_cmp_inv, do_neon_ceq)
	(neon_scalar_for_mul, neon_mul_mac, do_neon_mac_maybe_scalar)
	(do_neon_tst, do_neon_mul, do_neon_qdmulh, do_neon_fcmp_absolute)
	(do_neon_fcmp_absolute_inv, do_neon_step, do_neon_abs_neg)
	(do_neon_sli, do_neon_sri, do_neon_qshlu_imm, do_neon_qmovn)
	(do_neon_qmovun, do_neon_rshift_sat_narrow)
	(do_neon_rshift_sat_narrow_u, do_neon_movn, do_neon_rshift_narrow)
	(do_neon_shll, neon_cvt_flavour, do_neon_cvt, neon_move_immediate)
	(do_neon_mvn, neon_mixed_length, do_neon_dyadic_long, do_neon_abal)
	(neon_mac_reg_scalar_long, do_neon_mac_maybe_scalar_long)
	(do_neon_dyadic_wide, do_neon_vmull, do_neon_ext, do_neon_rev)
	(do_neon_dup, do_neon_mov, do_neon_rshift_round_imm, do_neon_movl)
	(do_neon_trn, do_neon_zip_uzp, do_neon_sat_abs_neg)
	(do_neon_pair_long, do_neon_recip_est, do_neon_cls, do_neon_clz)
	(do_neon_cnt, do_neon_swp, do_neon_tbl_tbx, do_neon_ldm_stm)
	(do_neon_ldr_str, do_neon_ld_st_interleave, neon_alignment_bit)
	(do_neon_ld_st_lane, do_neon_ld_dup, do_neon_ldx_stx): New
	functions. Neon bit encoding and encoding helpers.
	(parse_neon_type): New function. Parse Neon type specifier.
	(opcode_lookup): Allow parsing of Neon type specifiers.
	(REGNUM2, REGSETH, REGSET2): New macros.
	(reg_names): Add new VFPv3 and Neon registers.
	(NUF, nUF, NCE, nCE): New macros for opcode table.
	(insns): More VFP registers allowed in fcpyd, fmdhr, fmdlr, fmrdh,
	fmrdl, fabsd, fnegd, fsqrtd, faddd, fsubd, fmuld, fdivd, fmacd,
	fmscd, fnmuld, fnmacd, fnmscd, fcmpd, fcmpzd, fcmped, fcmpezd,
	fmdrr, fmrrd. Add Neon instructions vaba, vhadd, vrhadd, vhsub,
	vqadd, vqsub, vrshl, vqrshl, vshl, vqshl{u}, vand, vbic, vorr, vorn,
	veor, vbsl, vbit, vbif, vabd, vmax, vmin, vcge, vcgt, vclt, vcle,
	vceq, vpmax, vpmin, vmla, vmls, vpadd, vadd, vsub, vtst, vmul,
	vqdmulh, vqrdmulh, vacge, vacgt, vaclt, vacle, vrecps, vrsqrts,
	vabs, vneg, v{r}shr,  v{r}sra, vsli, vsri, vqshrn, vq{r}shr{u}n,
	v{r}shrn, vshll, vcvt, vmov, vmvn, vabal, vabdl, vaddl, vsubl,
	vmlal, vmlsl, vaddw, vsubw, v{r}addhn, v{r}subhn, vqdmlal, vqdmlsl,
	vqdmull, vmull, vext, vrev64, vrev32, vrev16, vdup, vmovl, v{q}movn,
	vzip, vuzp, vqabs, vqneg, vpadal, vpaddl, vrecpe, vrsqrte, vcls,
	vclz, vcnt, vswp, vtrn, vtbl, vtbx, vldm, vstm, vldr, vstr,
	vld[1234], vst[1234], fconst[sd], f[us][lh]to[sd], fto[us][lh][sd].
	(tc_arm_regname_to_dw2regnum): Update for arm_reg_parse args.
	(arm_cpu_option_table): Add Neon and VFPv3 to Cortex-A8.
	(arm_option_cpu_value): Add vfp3 and neon.
	(aeabi_set_public_attributes): Support VFPv3 and NEON attributes.
	Fix VFPv1 attribute.

	* gas/testsuite/gas/arm/copro.s: Avoid ldcl which encodes as a bad Neon
	instruction.
	* gas/testsuite/gas/arm/copro.d: Update accordingly.
	* gas/testsuite/gas/arm/neon-cond.s: New test. Conditional Neon opcodes
	in ARM mode.
	* gas/testsuite/gas/arm/neon-cond.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-cov.s: New test. Coverage of Neon
	instructions.
	* gas/testsuite/gas/arm/neon-cov.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-ldst-es.s: New test. Element and structure
	loads and stores.
	* gas/testsuite/gas/arm/neon-ldst-es.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-ldst-rm.s: New test. Single and multiple
	register loads and stores.
	* gas/testsuite/gas/arm/neon-ldst-rm.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-omit.s: New test. Omission of optional
	operands.
	* gas/testsuite/gas/arm/neon-omit.d: Expected results of above.
	* gas/testsuite/gas/arm/vfp1.d: Expect Neon syntax for some VFP
	instructions.
	* gas/testsuite/gas/arm/vfp1_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp1xD.d: Likewise.
	* gas/testsuite/gas/arm/vfp1xD_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp2.d: Likewise.
	* gas/testsuite/gas/arm/vfp2_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp3-32drs.s: New test. Extended D register
	range for VFP instructions.
	* gas/testsuite/gas/arm/vfp3-32drs.d: Expected results of above.
	* gas/testsuite/gas/arm/vfp3-const-conv.s: New test. VFPv3
	constant-load and conversion instructions.
	* gas/testsuite/gas/arm/vfp3-const-conv.d: Expected results of above.

	* include/opcode/arm.h (FPU_VFP_EXT_V3): Define constant.
	(FPU_NEON_EXT_V1): Likewise.
	(FPU_VFP_HARD): Update.
	(FPU_VFP_V3): Define macro.
	(FPU_ARCH_VFP_V3, FPU_ARCH_VFP_V3_PLUS_NEON_V1): Define macros.

	* opcodes/arm-dis.c (coprocessor_opcodes): Add %A, %B, %k,
	convert %<code>[zy] into %[zy]<code>.  Expand meaning of
	%<bitfield>['`?].
	Add unified load/store instruction names.
	(neon_opcode_table): New.
	(arm_opcodes): Expand meaning of %<bitfield>['`?].
	(arm_decode_bitfield): New.
	(print_insn_coprocessor): Add pc argument. Add %A & %B specifiers.
	Use arm_decode_bitfield and adjust numeric specifiers.
	Adjust %z & %y.
	(print_insn_neon): New.
	(print_insn_arm): Adjust print_insn_coprocessor call. Call
	print_insn_neon. Use arm_decode_bitfield and adjust numeric specifiers.
	(print_insn_thumb32): Likewise.
@
text
@a28 1
#include <limits.h>
a157 2
static const arm_feature_set fpu_arch_vfp_v3 = FPU_ARCH_VFP_V3;
static const arm_feature_set fpu_arch_neon_v1 = FPU_ARCH_NEON_V1;
a208 4
static const arm_feature_set fpu_vfp_ext_v3 = ARM_FEATURE (0, FPU_VFP_EXT_V3);
static const arm_feature_set fpu_neon_ext_v1 = ARM_FEATURE (0, FPU_NEON_EXT_V1);
static const arm_feature_set fpu_vfp_v3_or_neon_ext =
  ARM_FEATURE (0, FPU_NEON_EXT_V1 | FPU_VFP_EXT_V3);
a258 25
enum neon_el_type
{
  NT_untyped,
  NT_integer,
  NT_float,
  NT_poly,
  NT_signed,
  NT_unsigned,
  NT_invtype
};

struct neon_type_el
{
  enum neon_el_type type;
  unsigned size;
};

#define NEON_MAX_TYPE_ELS 4

struct neon_type
{
  struct neon_type_el el[NEON_MAX_TYPE_ELS];
  unsigned elems;
};

a265 1
  struct neon_type vectype;
a282 6
    unsigned isscalar   : 1;  /* Operand is a (Neon) scalar.  */
    unsigned immisalign : 1;  /* Immediate is an alignment specifier.  */
    /* Note: we abuse "regisimm" to mean "is Neon register" in VMOV
       instructions. This allows us to disambiguate ARM <-> vector insns.  */
    unsigned regisimm   : 1;  /* 64-bit immediate, reg forms high 32 bits.  */
    unsigned isquad     : 1;  /* Operand is Neon quad-precision register.  */
d358 1
a358 1
enum vfp_reg_pos
d360 1
a360 2
  VFP_REG_Sd, VFP_REG_Sm, VFP_REG_Sn,
  VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
a377 2
  REG_TYPE_NQ,
  REG_TYPE_NDQ,
d408 1
a408 3
  N_("VFP/Neon double precision register expected"),
  N_("Neon quad precision register expected"),
  N_("Neon double or quad precision register expected"),
a693 3
/* This is a bit of a hack. Use an optional prefix, and also allow big (64-bit)
   immediates, as can be used in Neon VMVN and VMOV immediate instructions.  */
#define GE_OPT_PREFIX_BIG 3
d703 1
a703 2
    prefix_mode = (prefix_mode == GE_OPT_PREFIX_BIG) ? prefix_mode
                  : GE_OPT_PREFIX;
a716 1
    case GE_OPT_PREFIX_BIG:
d758 5
a762 6
  if (prefix_mode != GE_OPT_PREFIX_BIG
      && (ep->X_op == O_big
          || (ep->X_add_symbol
	      && (walk_no_bignums (ep->X_add_symbol)
	          || (ep->X_op_symbol
		      && walk_no_bignums (ep->X_op_symbol))))))
d943 1
a943 3
   value is the register number or FAIL.
   If RTYPE is non-zero, return the (possibly restricted) type of the
   register (e.g. Neon double or quad reg when either has been requested).  */
d946 1
a946 1
arm_reg_parse (char **ccp, enum arm_reg_type type, enum arm_reg_type *rtype)
a950 8
  /* Undo polymorphism for Neon D and Q registers.  */
  if (reg && type == REG_TYPE_NDQ
      && (reg->type == REG_TYPE_NQ || reg->type == REG_TYPE_VFD))
    type = reg->type;

  if (rtype)
    *rtype = type;

a988 40
/* Parse a Neon scalar. Most of the time when we're parsing a scalar, we don't
   have enough information to be able to do a good job bounds-checking. So, we
   just do easy checks here, and do further checks later.  */

static int
parse_scalar (char **ccp, int elsize)
{
  int regno, elno;
  char *str = *ccp;
  expressionS exp;
  
  if ((regno = arm_reg_parse (&str, REG_TYPE_VFD, NULL)) == FAIL)
    return FAIL;
  
  if (skip_past_char (&str, '[') == FAIL)
    return FAIL;
  
  my_get_expression (&exp, &str, GE_NO_PREFIX);
  if (exp.X_op != O_constant)
    {
      inst.error = _("constant expression required");
      return FAIL;
    }
  elno = exp.X_add_number;
  
  if (elno >= 64 / elsize)
    {
      inst.error = _("scalar index out of range");
      return FAIL;
    }
  
  if (skip_past_char (&str, ']') == FAIL)
    return FAIL;
  
  /* Parsed scalar successfully. Skip over it.  */
  *ccp = str;
  
  return (regno * 8) + elno;
}

d1012 1
a1012 1
	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN, NULL)) == FAIL)
a1113 9
/* Types of registers in a list.  */

enum reg_list_els
{
  REGLIST_VFP_S,
  REGLIST_VFP_D,
  REGLIST_NEON_D
};

d1116 1
a1116 10
   register.  Parses registers of type ETYPE.
   If REGLIST_NEON_D is used, several syntax enhancements are enabled:
     - Q registers can be used to specify pairs of D registers
     - { } can be omitted from around a singleton register list
         FIXME: This is not implemented, as it would require backtracking in
         some cases, e.g.:
           vtbl.8 d3,d4,d5
         This could be done (the meaning isn't really ambiguous), but doesn't
         fit in well with the current parsing framework.
     - 32 D registers may be used (also true for VFPv3).  */
d1119 1
a1119 1
parse_vfp_reg_list (char **str, unsigned int *pbase, enum reg_list_els etype)
d1123 2
a1124 2
  enum arm_reg_type regtype = 0;
  int max_regs = 0;
d1131 1
a1131 4
    {
      inst.error = _("expecting {");
      return FAIL;
    }
d1135 6
a1140 1
  switch (etype)
a1141 1
    case REGLIST_VFP_S:
a1143 23
      break;
    
    case REGLIST_VFP_D:
      regtype = REG_TYPE_VFD;
      /* VFPv3 allows 32 D registers.  */
      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v3))
        {
          max_regs = 32;
          if (thumb_mode)
            ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
                                    fpu_vfp_ext_v3);
          else
            ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
                                    fpu_vfp_ext_v3);
        }
      else
        max_regs = 16;
      break;
    
    case REGLIST_NEON_D:
      regtype = REG_TYPE_NDQ;
      max_regs = 32;
      break;
d1150 1
a1150 2
      int setmask = 1, addregs = 1;
      new_base = arm_reg_parse (str, regtype, &regtype);
a1156 7
      /* Note: a value of 2 * n is returned for the register Q<n>.  */
      if (regtype == REG_TYPE_NQ)
        {
          setmask = 3;
          addregs = 2;
        }

d1160 1
a1160 1
      if (mask & (setmask << new_base))
d1172 2
a1173 2
      mask |= setmask << new_base;
      count += addregs;
d1181 1
a1181 1
	  if ((high_range = arm_reg_parse (str, regtype, NULL)) == FAIL)
a1186 3
          if (regtype == REG_TYPE_NQ)
            high_range = high_range + 1;

d1193 1
a1193 1
	  for (new_base += addregs; new_base <= high_range; new_base += addregs)
d1195 1
a1195 1
	      if (mask & (setmask << new_base))
d1201 2
a1202 2
	      mask |= setmask << new_base;
	      count += addregs;
a1229 174
/* Parse element/structure lists for Neon VLD<n> and VST<n> instructions.
   The base register is put in *PBASE.
   The lane (or one of the #defined constants below) is placed in bits [3:0] of
   the return value.
   The register stride (minus one) is put in bit 4 of the return value.
   Bits [6:5] encode the list length (minus one).  */

#define NEON_ALL_LANES		15
#define NEON_INTERLEAVE_LANES	14
#define NEON_LANE(X)		((X) & 0xf)
#define NEON_REG_STRIDE(X)	(((X) & (1 << 4)) ? 2 : 1)
#define NEON_REGLIST_LENGTH(X)	((((X) >> 5) & 3) + 1)

static int
parse_neon_el_struct_list (char **str, unsigned *pbase)
{
  char *ptr = *str;
  int base_reg = -1;
  int reg_incr = -1;
  int count = 0;
  int lane = -1;
  int leading_brace = 0;
  enum arm_reg_type rtype = REG_TYPE_NDQ;
  int addregs = 1;
  const char *const incr_error = "register stride must be 1 or 2";
  const char *const type_error = "mismatched element/structure types in list";
  
  if (skip_past_char (&ptr, '{') == SUCCESS)
    leading_brace = 1;
  
  do
    {
      int getreg = arm_reg_parse (&ptr, rtype, &rtype);
      if (getreg == FAIL)
        {
          inst.error = _(reg_expected_msgs[rtype]);
          return FAIL;
        }
      
      if (base_reg == -1)
        {
          base_reg = getreg;
          if (rtype == REG_TYPE_NQ)
            {
              reg_incr = 1;
              addregs = 2;
            }
        }
      else if (reg_incr == -1)
        {
          reg_incr = getreg - base_reg;
          if (reg_incr < 1 || reg_incr > 2)
            {
              inst.error = _(incr_error);
              return FAIL;
            }
        }
      else if (getreg != base_reg + reg_incr * count)
        {
          inst.error = _(incr_error);
          return FAIL;
        }
      
      /* Handle Dn-Dm or Qn-Qm syntax. Can only be used with non-indexed list
         modes.  */
      if (ptr[0] == '-')
        {
          int hireg, dregs = (rtype == REG_TYPE_NQ) ? 2 : 1;
          if (lane == -1)
            lane = NEON_INTERLEAVE_LANES;
          else if (lane != NEON_INTERLEAVE_LANES)
            {
              inst.error = _(type_error);
              return FAIL;
            }
          if (reg_incr == -1)
            reg_incr = 1;
          else if (reg_incr != 1)
            {
              inst.error = _("don't use Rn-Rm syntax with non-unit stride");
              return FAIL;
            }
          ptr++;
          hireg = arm_reg_parse (&ptr, rtype, NULL);
          if (hireg == FAIL)
            {
              inst.error = _(reg_expected_msgs[rtype]);
              return FAIL;
            }
          count += hireg + dregs - getreg;
          continue;
        }
      
      /* If we're using Q registers, we can't use [] or [n] syntax.  */
      if (rtype == REG_TYPE_NQ)
        {
          count += 2;
          continue;
        }
      
      if (skip_past_char (&ptr, '[') == SUCCESS)
        {
          if (skip_past_char (&ptr, ']') == SUCCESS)
            {
              if (lane == -1)
                lane = NEON_ALL_LANES;
              else if (lane != NEON_ALL_LANES)
                {
                  inst.error = _(type_error);
                  return FAIL;
                }
            }
          else
            {
              expressionS exp;
              my_get_expression (&exp, &ptr, GE_NO_PREFIX);
              if (exp.X_op != O_constant)
                {
                  inst.error = _("constant expression required");
                  return FAIL;
                }
              if (lane == -1)
                lane = exp.X_add_number;
              else if (lane != exp.X_add_number)
                {
                  inst.error = _(type_error);
                  return FAIL;
                }
              
              if (skip_past_char (&ptr, ']') == FAIL)
                {
                  inst.error = _("expected ]");
                  return FAIL;
                }
            }
        }
      else if (lane == -1)
        lane = NEON_INTERLEAVE_LANES;
      else if (lane != NEON_INTERLEAVE_LANES)
        {
          inst.error = _(type_error);
          return FAIL;
        }
      count++;
    }
  while ((count != 1 || leading_brace) && skip_past_comma (&ptr) != FAIL);
  
  /* No lane set by [x]. We must be interleaving structures.  */
  if (lane == -1)
    lane = NEON_INTERLEAVE_LANES;
  
  /* Sanity check.  */
  if (lane == -1 || base_reg == -1 || count < 1 || count > 4
      || (count > 1 && reg_incr == -1))
    {
      inst.error = _("error parsing element/structure list");
      return FAIL;
    }

  if ((count > 1 || leading_brace) && skip_past_char (&ptr, '}') == FAIL)
    {
      inst.error = _("expected }");
      return FAIL;
    }
  
  if (reg_incr == -1)
    reg_incr = 1;

  *pbase = base_reg;
  *str = ptr;
  
  return lane | ((reg_incr - 1) << 4) | ((count - 1) << 5);
}

d2426 1
a2426 1
  count = parse_vfp_reg_list (&input_line_pointer, &reg, REGLIST_VFP_D);
d2468 1
a2468 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR, NULL);
d2483 1
a2483 1
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR, NULL);
d2600 1
a2600 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG, NULL);
d2616 1
a2616 1
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG, NULL);
d2714 1
a2714 1
  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN, NULL);
d2775 1
a2775 1
  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN, NULL);
d2779 1
a2779 1
    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN, NULL);
a3045 41
/* Less-generic immediate-value read function with the possibility of loading a
   big (64-bit) immediate, as required by Neon VMOV and VMVN immediate
   instructions. Puts the result directly in inst.operands[i].  */

static int
parse_big_immediate (char **str, int i)
{
  expressionS exp;
  char *ptr = *str;

  my_get_expression (&exp, &ptr, GE_OPT_PREFIX_BIG);

  if (exp.X_op == O_constant)
    inst.operands[i].imm = exp.X_add_number;
  else if (exp.X_op == O_big
           && LITTLENUM_NUMBER_OF_BITS * exp.X_add_number > 32
           && LITTLENUM_NUMBER_OF_BITS * exp.X_add_number <= 64)
    {
      unsigned parts = 32 / LITTLENUM_NUMBER_OF_BITS, j, idx = 0;
      /* Bignums have their least significant bits in
         generic_bignum[0]. Make sure we put 32 bits in imm and
         32 bits in reg,  in a (hopefully) portable way.  */
      assert (parts != 0);
      inst.operands[i].imm = 0;
      for (j = 0; j < parts; j++, idx++)
        inst.operands[i].imm |= generic_bignum[idx]
                                << (LITTLENUM_NUMBER_OF_BITS * j);
      inst.operands[i].reg = 0;
      for (j = 0; j < parts; j++, idx++)
        inst.operands[i].reg |= generic_bignum[idx]
                                << (LITTLENUM_NUMBER_OF_BITS * j);
      inst.operands[i].regisimm = 1;
    }
  else
    return FAIL;
  
  *str = ptr;

  return SUCCESS;
}

d3235 1
a3235 1
	  && (reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) != FAIL)
d3266 1
a3266 1
  if ((value = arm_reg_parse (str, REG_TYPE_RN, NULL)) != FAIL)
d3377 1
a3377 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) == FAIL)
d3392 1
a3392 1
      if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) != FAIL)
a3400 17
      else if (skip_past_char (&p, ':') == SUCCESS)
        {
          /* FIXME: '@@' should be used here, but it's filtered out by generic
             code before we get to see it here. This may be subject to
             change.  */
          expressionS exp;
          my_get_expression (&exp, &p, GE_NO_PREFIX);
          if (exp.X_op != O_constant)
            {
              inst.error = _("alignment must be constant");
              return FAIL;
            }
          inst.operands[i].imm = exp.X_add_number << 8;
          inst.operands[i].immisalign = 1;
          /* Alignments are not pre-indexes.  */
          inst.operands[i].preind = 0;
        }
d3458 1
a3458 1
	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) != FAIL)
d3460 1
a3460 6
              /* We might be using the immediate for alignment already. If we
                 are, OR the register number into the low-order bits.  */
              if (inst.operands[i].immisalign)
	        inst.operands[i].imm |= reg;
              else
                inst.operands[i].imm = reg;
d3714 1
a3714 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) == FAIL)
d3727 1
a3727 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN, NULL)) == FAIL)
a3754 152
/* Parse the operands of a Neon VMOV instruction. See do_neon_mov for more
   information on the types the operands can take and how they are encoded.
   Note particularly the abuse of ".regisimm" to signify a Neon register.
   Up to three operands may be read; this function handles setting the
   ".present" field for each operand itself.
   Updates STR and WHICH_OPERAND if parsing is successful and returns SUCCESS,
   else returns FAIL.  */

static int
parse_neon_mov (char **str, int *which_operand)
{
  int i = *which_operand, val;
  enum arm_reg_type rtype;
  char *ptr = *str;
  
  if ((val = parse_scalar (&ptr, 8)) != FAIL)
    {
      /* Case 4: VMOV<c><q>.<size> <Dn[x]>, <Rd>.  */
      inst.operands[i].reg = val;
      inst.operands[i].isscalar = 1;
      inst.operands[i++].present = 1;

      if (skip_past_comma (&ptr) == FAIL)
        goto wanted_comma;
      
      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) == FAIL)
        goto wanted_arm;
      
      inst.operands[i].reg = val;
      inst.operands[i].isreg = 1;
      inst.operands[i].present = 1;
    }
  else if ((val = arm_reg_parse (&ptr, REG_TYPE_NDQ, &rtype)) != FAIL)
    {
      /* Cases 0, 1, 2, 3, 5 (D only).  */
      if (skip_past_comma (&ptr) == FAIL)
        goto wanted_comma;
      
      inst.operands[i].reg = val;
      inst.operands[i].isreg = 1;
      inst.operands[i].isquad = (rtype == REG_TYPE_NQ);
      inst.operands[i++].present = 1;

      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) != FAIL)
        {
          /* Case 5: VMOV<c><q> <Dm>, <Rd>, <Rn>.  */
          inst.operands[i-1].regisimm = 1;
          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i++].present = 1;

          if (rtype == REG_TYPE_NQ)
            {
              inst.error = _("can't use Neon quad register here");
              return FAIL;
            }
          if (skip_past_comma (&ptr) == FAIL)
            goto wanted_comma;
          if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) == FAIL)
            goto wanted_arm;
          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].present = 1;
        }
      else if (parse_big_immediate (&ptr, i) == SUCCESS)
        {
          /* Case 2: VMOV<c><q>.<dt> <Qd>, #<imm>
             Case 3: VMOV<c><q>.<dt> <Dd>, #<imm>  */
          if (!thumb_mode && (inst.instruction & 0xf0000000) != 0xe0000000)
            goto bad_cond;
        }
      else if ((val = arm_reg_parse (&ptr, REG_TYPE_NDQ, &rtype)) != FAIL)
        {
          /* Case 0: VMOV<c><q> <Qd>, <Qm>
             Case 1: VMOV<c><q> <Dd>, <Dm>  */
          if (!thumb_mode && (inst.instruction & 0xf0000000) != 0xe0000000)
            goto bad_cond;

          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].isquad = (rtype == REG_TYPE_NQ);
          inst.operands[i].present = 1;
        }
      else
        {
          inst.error = _("expected <Rm> or <Dm> or <Qm> operand");
          return FAIL;
        }
    }
  else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) != FAIL)
    {
      /* Cases 6, 7.  */
      inst.operands[i].reg = val;
      inst.operands[i].isreg = 1;
      inst.operands[i++].present = 1;
      
      if (skip_past_comma (&ptr) == FAIL)
        goto wanted_comma;
      
      if ((val = parse_scalar (&ptr, 8)) != FAIL)
        {
          /* Case 6: VMOV<c><q>.<dt> <Rd>, <Dn[x]>  */
          inst.operands[i].reg = val;
          inst.operands[i].isscalar = 1;
          inst.operands[i].present = 1;
        }
      else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN, NULL)) != FAIL)
        {
          /* Case 7: VMOV<c><q> <Rd>, <Rn>, <Dm>  */
          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i++].present = 1;
          
          if (skip_past_comma (&ptr) == FAIL)
            goto wanted_comma;
          
          if ((val = arm_reg_parse (&ptr, REG_TYPE_VFD, NULL)) == FAIL)
            {
              inst.error = _(reg_expected_msgs[REG_TYPE_VFD]);
              return FAIL;
            }

          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].regisimm = 1;
          inst.operands[i].present = 1;
        }
    }
  else
    {
      inst.error = _("parse error");
      return FAIL;
    }

  /* Successfully parsed the operands. Update args.  */
  *which_operand = i;
  *str = ptr;
  return SUCCESS;

  wanted_comma:
  inst.error = _("expected comma");
  return FAIL;
  
  wanted_arm:
  inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
  return FAIL;

  bad_cond:
  inst.error = _("instruction cannot be conditionalized");
  return FAIL;
}

d3768 1
a3768 5
  OP_RVD,	/* VFP double precision register (0..15) */
  OP_RND,       /* Neon double precision register (0..31) */
  OP_RNQ,	/* Neon quad precision register */
  OP_RNDQ,      /* Neon double or quad precision register */
  OP_RNSC,      /* Neon scalar D[X] */
a3783 2
  OP_NRDLST,    /* Neon double-precision register list (d0-d31, qN aliases) */
  OP_NSTRLST,   /* Neon element/structure list */
a3784 10
  OP_NILO,      /* Neon immediate/logic operands 2 or 2+3. (VBIC, VORR...)  */
  OP_RNDQ_I0,   /* Neon D or Q reg, or immediate zero.  */
  OP_RR_RNSC,   /* ARM reg or Neon scalar.  */
  OP_RNDQ_RNSC, /* Neon D or Q reg, or Neon scalar.  */
  OP_RND_RNSC,  /* Neon D reg, or Neon scalar.  */
  OP_VMOV,      /* Neon VMOV operands.  */
  OP_RNDQ_IMVNb,/* Neon D or Q reg, or immediate good for VMVN.  */
  OP_RNDQ_I63b, /* Neon D or Q reg, or immediate for shift.  */

  OP_I0,        /* immediate zero */
a3787 1
  OP_I16z,      /*                 0 .. 16 */
a3790 2
  OP_I32z,	/*		   0 .. 32 */
  OP_I63,	/*		   0 .. 63 */
a3791 2
  OP_I64,	/*		   1 .. 64 */
  OP_I64z,	/*		   0 .. 64 */
a3820 1
  OP_oI32b,      /*                             1 .. 32 */
a3825 3
  OP_oRND,       /* Optional Neon double precision register */
  OP_oRNQ,       /* Optional Neon quad precision register */
  OP_oRNDQ,      /* Optional Neon double or quad precision register */
a3845 1
  enum arm_reg_type rtype;
d3853 1
a3853 1
  val = arm_reg_parse (&str, regtype, &rtype);		\
a3860 1
  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);	\
d3863 7
a3869 8
#define po_reg_or_goto(regtype, label) do {		\
  val = arm_reg_parse (&str, regtype, &rtype);		\
  if (val == FAIL)					\
    goto label;						\
							\
  inst.operands[i].reg = val;				\
  inst.operands[i].isreg = 1;				\
  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);	\
a3877 8
#define po_scalar_or_goto(elsz, label) do {	\
  val = parse_scalar (&str, elsz);		\
  if (val == FAIL)				\
    goto label;					\
  inst.operands[i].reg = val;			\
  inst.operands[i].isscalar = 1;		\
} while (0)

a3910 2
        case OP_oRND:
	case OP_RND:   po_reg_or_fail (REG_TYPE_VFD);	  break;
a3921 98
        case OP_oRNQ:
	case OP_RNQ:   po_reg_or_fail (REG_TYPE_NQ);      break;
        case OP_oRNDQ:
	case OP_RNDQ:  po_reg_or_fail (REG_TYPE_NDQ);     break;

        /* Neon scalar. Using an element size of 8 means that some invalid
           scalars are accepted here, so deal with those in later code.  */
        case OP_RNSC:  po_scalar_or_goto (8, failure);    break;

        /* WARNING: We can expand to two operands here. This has the potential
           to totally confuse the backtracking mechanism! It will be OK at
           least as long as we don't try to use optional args as well,
           though.  */
        case OP_NILO:
          {
            po_reg_or_goto (REG_TYPE_NDQ, try_imm);
            i++;
            skip_past_comma (&str);
            po_reg_or_goto (REG_TYPE_NDQ, one_reg_only);
            break;
            one_reg_only:
            /* Optional register operand was omitted. Unfortunately, it's in
               operands[i-1] and we need it to be in inst.operands[i]. Fix that
               here (this is a bit grotty).  */
            inst.operands[i] = inst.operands[i-1];
            inst.operands[i-1].present = 0;
            break;
            try_imm:
            /* Immediate gets verified properly later, so accept any now.  */
            po_imm_or_fail (INT_MIN, INT_MAX, TRUE);
          }
          break;

        case OP_RNDQ_I0:
          {
            po_reg_or_goto (REG_TYPE_NDQ, try_imm0);
            break;
            try_imm0:
            po_imm_or_fail (0, 0, TRUE);
          }
          break;

        case OP_RR_RNSC:
          {
            po_scalar_or_goto (8, try_rr);
            break;
            try_rr:
            po_reg_or_fail (REG_TYPE_RN);
          }
          break;

        case OP_RNDQ_RNSC:
          {
            po_scalar_or_goto (8, try_ndq);
            break;
            try_ndq:
            po_reg_or_fail (REG_TYPE_NDQ);
          }
          break;

        case OP_RND_RNSC:
          {
            po_scalar_or_goto (8, try_vfd);
            break;
            try_vfd:
            po_reg_or_fail (REG_TYPE_VFD);
          }
          break;

        case OP_VMOV:
          /* WARNING: parse_neon_mov can move the operand counter, i. If we're
             not careful then bad things might happen.  */
          po_misc_or_fail (parse_neon_mov (&str, &i) == FAIL);
          break;

        case OP_RNDQ_IMVNb:
          {
            po_reg_or_goto (REG_TYPE_NDQ, try_mvnimm);
            break;
            try_mvnimm:
            /* There's a possibility of getting a 64-bit immediate here, so
               we need special handling.  */
            if (parse_big_immediate (&str, i) == FAIL)
              {
                inst.error = _("immediate value is out of range");
                goto failure;
              }
          }
          break;

        case OP_RNDQ_I63b:
          {
            po_reg_or_goto (REG_TYPE_NDQ, try_shimm);
            break;
            try_shimm:
            po_imm_or_fail (0, 63, TRUE);
          }
          break;
a3938 1
        case OP_I16z:	 po_imm_or_fail (  0,     16, FALSE);   break;
a3940 1
        case OP_I32z:	 po_imm_or_fail (  0,     32, FALSE);   break;
a3941 3
        case OP_I63:	 po_imm_or_fail (  0,     63, FALSE);   break;
        case OP_I64:	 po_imm_or_fail (  1,     64, FALSE);   break;
        case OP_I64z:	 po_imm_or_fail (  0,     64, FALSE);   break;
a3950 1
        case OP_oI32b:   po_imm_or_fail (  1,     32, TRUE);    break;
d4069 1
a4069 1
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_S);
d4073 1
a4073 1
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_D);
a4075 9
        case OP_NRDLST:
          val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
                                    REGLIST_NEON_D);
          break;

	case OP_NSTRLST:
          val = parse_neon_el_struct_list (&str, &inst.operands[i].reg);
          break;

a4123 2
        case OP_NRDLST:
        case OP_NSTRLST:
a4180 1
#undef po_scalar_or_fail
d4239 1
a4239 1
/* Encode a VFP SP or DP register number into inst.instruction.  */
d4242 1
a4242 1
encode_arm_vfp_reg (int reg, enum vfp_reg_pos pos)
a4243 19
  if ((pos == VFP_REG_Dd || pos == VFP_REG_Dn || pos == VFP_REG_Dm)
      && reg > 15)
    {
      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v3))
        {
          if (thumb_mode)
            ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
                                    fpu_vfp_ext_v3);
          else
            ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
                                    fpu_vfp_ext_v3);
        }
      else
        {
          inst.error = _("D register out of range for selected VFP version");
          return;
        }
    }

a4257 12
    case VFP_REG_Dd:
      inst.instruction |= ((reg & 15) << 12) | ((reg >> 4) << 22);
      break;
    
    case VFP_REG_Dn:
      inst.instruction |= ((reg & 15) << 16) | ((reg >> 4) << 7);
      break;
    
    case VFP_REG_Dm:
      inst.instruction |= (reg & 15) | ((reg >> 4) << 5);
      break;

d5545 2
a5546 2
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sm);
d5552 3
a5554 3
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sn);
  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Sm);
d5560 1
a5560 1
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
d5566 2
a5567 2
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sm);
d5573 2
a5574 2
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dm);
d5581 1
a5581 1
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sn);
d5591 1
a5591 1
  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Sm);
d5597 1
a5597 1
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sn);
d5606 1
a5606 1
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sm);
d5614 1
a5614 1
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
d5621 1
a5621 1
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
d5635 1
a5635 1
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sd);
d5651 1
a5651 1
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);
a5694 97

static void
do_vfp_dp_rd_rm (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dm);
}

static void
do_vfp_dp_rn_rd (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dn);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);
}

static void
do_vfp_dp_rd_rn (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dn);
}

static void
do_vfp_dp_rd_rn_rm (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dn);
  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Dm);
}

static void
do_vfp_dp_rd (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
}

static void
do_vfp_dp_rm_rd_rn (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dm);
  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);
  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Dn);
}

/* VFPv3 instructions.  */
static void
do_vfp_sp_const (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  inst.instruction |= (inst.operands[1].imm & 15) << 16;
  inst.instruction |= (inst.operands[1].imm >> 4);
}

static void
do_vfp_dp_const (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  inst.instruction |= (inst.operands[1].imm & 15) << 16;
  inst.instruction |= (inst.operands[1].imm >> 4);
}

static void
vfp_conv (int srcsize)
{
  unsigned immbits = srcsize - inst.operands[1].imm;
  inst.instruction |= (immbits & 1) << 5;
  inst.instruction |= (immbits >> 1);
}

static void
do_vfp_sp_conv_16 (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  vfp_conv (16);
}

static void
do_vfp_dp_conv_16 (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  vfp_conv (16);
}

static void
do_vfp_sp_conv_32 (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
  vfp_conv (32);
}

static void
do_vfp_dp_conv_32 (void)
{
  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
  vfp_conv (32);
}

d8001 2
d8004 6
a8009 3
/* Neon instruction encoder helpers.  */
  
/* Encodings for the different types for various Neon opcodes.  */
d8011 7
a8017 4
/* An "invalid" code for the following tables.  */
#define N_INV -1u

struct neon_tab_entry
d8019 1
a8019 56
  unsigned integer;
  unsigned float_or_poly;
  unsigned scalar_or_imm;
};
  
/* Map overloaded Neon opcodes to their respective encodings.  */
#define NEON_ENC_TAB					\
  X(vabd,	0x0000700, 0x1200d00, N_INV),		\
  X(vmax,	0x0000600, 0x0000f00, N_INV),		\
  X(vmin,	0x0000610, 0x0200f00, N_INV),		\
  X(vpadd,	0x0000b10, 0x1000d00, N_INV),		\
  X(vpmax,	0x0000a00, 0x1000f00, N_INV),		\
  X(vpmin,	0x0000a10, 0x1200f00, N_INV),		\
  X(vadd,	0x0000800, 0x0000d00, N_INV),		\
  X(vsub,	0x1000800, 0x0200d00, N_INV),		\
  X(vceq,	0x1000810, 0x0000e00, 0x1b10100),	\
  X(vcge,	0x0000310, 0x1000e00, 0x1b10080),	\
  X(vcgt,	0x0000300, 0x1200e00, 0x1b10000),	\
  /* Register variants of the following two instructions are encoded as
     vcge / vcgt with the operands reversed. */  	\
  X(vclt,	0x0000310, 0x1000e00, 0x1b10200),	\
  X(vcle,	0x0000300, 0x1200e00, 0x1b10180),	\
  X(vmla,	0x0000900, 0x0000d10, 0x0800040),	\
  X(vmls,	0x1000900, 0x0200d10, 0x0800440),	\
  X(vmul,	0x0000910, 0x1000d10, 0x0800840),	\
  X(vmull,	0x0800c00, 0x0800e00, 0x0800a40), /* polynomial not float.  */ \
  X(vmlal,	0x0800800, N_INV,     0x0800240),	\
  X(vmlsl,	0x0800a00, N_INV,     0x0800640),	\
  X(vqdmlal,	0x0800900, N_INV,     0x0800340),	\
  X(vqdmlsl,	0x0800b00, N_INV,     0x0800740),	\
  X(vqdmull,	0x0800d00, N_INV,     0x0800b40),	\
  X(vqdmulh,    0x0000b00, N_INV,     0x0800c40),	\
  X(vqrdmulh,   0x1000b00, N_INV,     0x0800d40),	\
  X(vshl,	0x0000400, N_INV,     0x0800510),	\
  X(vqshl,	0x0000410, N_INV,     0x0800710),	\
  X(vand,	0x0000110, N_INV,     0x0800030),	\
  X(vbic,	0x0100110, N_INV,     0x0800030),	\
  X(veor,	0x1000110, N_INV,     N_INV),		\
  X(vorn,	0x0300110, N_INV,     0x0800010),	\
  X(vorr,	0x0200110, N_INV,     0x0800010),	\
  X(vmvn,	0x1b00580, N_INV,     0x0800030),	\
  X(vshll,	0x1b20300, N_INV,     0x0800a10), /* max shift, immediate.  */ \
  X(vcvt,       0x1b30600, N_INV,     0x0800e10), /* integer, fixed-point.  */ \
  X(vdup,       0xe800b10, N_INV,     0x1b00c00), /* arm, scalar.  */ \
  X(vld1,       0x0200000, 0x0a00000, 0x0a00c00), /* interlv, lane, dup.  */ \
  X(vst1,	0x0000000, 0x0800000, N_INV),		\
  X(vld2,	0x0200100, 0x0a00100, 0x0a00d00),	\
  X(vst2,	0x0000100, 0x0800100, N_INV),		\
  X(vld3,	0x0200200, 0x0a00200, 0x0a00e00),	\
  X(vst3,	0x0000200, 0x0800200, N_INV),		\
  X(vld4,	0x0200300, 0x0a00300, 0x0a00f00),	\
  X(vst4,	0x0000300, 0x0800300, N_INV),		\
  X(vmovn,	0x1b20200, N_INV,     N_INV),		\
  X(vtrn,	0x1b20080, N_INV,     N_INV),		\
  X(vqmovn,	0x1b20200, N_INV,     N_INV),		\
  X(vqmovun,	0x1b20240, N_INV,     N_INV)
d8021 8
a8028 6
enum neon_opc
{
#define X(OPC,I,F,S) N_MNEM_##OPC
NEON_ENC_TAB
#undef X
};
d8030 5
a8034 6
static const struct neon_tab_entry neon_enc_tab[] =
{
#define X(OPC,I,F,S) { (I), (F), (S) }
NEON_ENC_TAB
#undef X
};
d8036 4
a8039 21
#define NEON_ENC_INTEGER(X) (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_ARMREG(X)  (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_POLY(X)    (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_FLOAT(X)   (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_SCALAR(X)  (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
#define NEON_ENC_IMMED(X)   (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
#define NEON_ENC_INTERLV(X) (neon_enc_tab[(X) & 0x0fffffff].integer)
#define NEON_ENC_LANE(X)    (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
#define NEON_ENC_DUP(X)     (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)

/* Shapes for instruction operands. Some (e.g. NS_DDD_QQQ) represent multiple
   shapes which an instruction can accept. The following mnemonic characters
   are used in the tag names for this enumeration:

     D - Neon D<n> register
     Q - Neon Q<n> register
     I - Immediate
     S - Scalar
     R - ARM register
     L - D<n> register list
*/
d8041 3
a8043 1
enum neon_shape
d8045 1
a8045 2483
  NS_DDD_QQQ,
  NS_DDD,
  NS_QQQ,
  NS_DDI_QQI,
  NS_DDI,
  NS_QQI,
  NS_DDS_QQS,
  NS_DDS,
  NS_QQS,
  NS_DD_QQ,
  NS_DD,
  NS_QQ,
  NS_DS_QS,
  NS_DS,
  NS_QS,
  NS_DR_QR,
  NS_DR,
  NS_QR,
  NS_DI_QI,
  NS_DI,
  NS_QI,
  NS_DLD,
  NS_DQ,
  NS_QD,
  NS_DQI,
  NS_QDI,
  NS_QDD,
  NS_QDS,
  NS_QQD,
  NS_DQQ,
  NS_DDDI_QQQI,
  NS_DDDI,
  NS_QQQI,
  NS_IGNORE
};

/* Bit masks used in type checking given instructions.
  'N_EQK' means the type must be the same as (or based on in some way) the key
   type, which itself is marked with the 'N_KEY' bit. If the 'N_EQK' bit is
   set, various other bits can be set as well in order to modify the meaning of
   the type constraint.  */

enum neon_type_mask
{
  N_S8   = 0x000001,
  N_S16  = 0x000002,
  N_S32  = 0x000004,
  N_S64  = 0x000008,
  N_U8   = 0x000010,
  N_U16  = 0x000020,
  N_U32  = 0x000040,
  N_U64  = 0x000080,
  N_I8   = 0x000100,
  N_I16  = 0x000200,
  N_I32  = 0x000400,
  N_I64  = 0x000800,
  N_8    = 0x001000,
  N_16   = 0x002000,
  N_32   = 0x004000,
  N_64   = 0x008000,
  N_P8   = 0x010000,
  N_P16  = 0x020000,
  N_F32  = 0x040000,
  N_KEY  = 0x080000, /* key element (main type specifier).  */
  N_EQK  = 0x100000, /* given operand has the same type & size as the key.  */
  N_DBL  = 0x000001, /* if N_EQK, this operand is twice the size.  */
  N_HLF  = 0x000002, /* if N_EQK, this operand is half the size.  */
  N_SGN  = 0x000004, /* if N_EQK, this operand is forced to be signed.  */
  N_UNS  = 0x000008, /* if N_EQK, this operand is forced to be unsigned.  */
  N_INT  = 0x000010, /* if N_EQK, this operand is forced to be integer.  */
  N_FLT  = 0x000020, /* if N_EQK, this operand is forced to be float.  */
  N_UTYP = 0,
  N_MAX_NONSPECIAL = N_F32
};

#define N_SU_ALL   (N_S8 | N_S16 | N_S32 | N_S64 | N_U8 | N_U16 | N_U32 | N_U64)
#define N_SU_32    (N_S8 | N_S16 | N_S32 | N_U8 | N_U16 | N_U32)
#define N_SU_16_64 (N_S16 | N_S32 | N_S64 | N_U16 | N_U32 | N_U64)
#define N_SUF_32   (N_SU_32 | N_F32)
#define N_I_ALL    (N_I8 | N_I16 | N_I32 | N_I64)
#define N_IF_32    (N_I8 | N_I16 | N_I32 | N_F32)

/* Pass this as the first type argument to neon_check_type to ignore types
   altogether.  */
#define N_IGNORE_TYPE (N_KEY | N_EQK)

/* Check the shape of a Neon instruction (sizes of registers). Returns the more
   specific shape when there are two alternatives. For non-polymorphic shapes,
   checking is done during operand parsing, so is not implemented here.  */

static enum neon_shape
neon_check_shape (enum neon_shape req)
{
#define RR(X) (inst.operands[(X)].isreg)
#define RD(X) (inst.operands[(X)].isreg && !inst.operands[(X)].isquad)
#define RQ(X) (inst.operands[(X)].isreg && inst.operands[(X)].isquad)
#define IM(X) (!inst.operands[(X)].isreg && !inst.operands[(X)].isscalar)
#define SC(X) (!inst.operands[(X)].isreg && inst.operands[(X)].isscalar)

  /* Fix missing optional operands. FIXME: we don't know at this point how
     many arguments we should have, so this makes the assumption that we have
     > 1. This is true of all current Neon opcodes, I think, but may not be
     true in the future.  */
  if (!inst.operands[1].present)
    inst.operands[1] = inst.operands[0];

  switch (req)
      {
    case NS_DDD_QQQ:
      {
        if (RD(0) && RD(1) && RD(2))
          return NS_DDD;
        else if (RQ(0) && RQ(1) && RQ(1))
          return NS_QQQ;
        else
          inst.error = _("expected <Qd>, <Qn>, <Qm> or <Dd>, <Dn>, <Dm> "
                         "operands");
      }
      break;
    
    case NS_DDI_QQI:
      {
        if (RD(0) && RD(1) && IM(2))
          return NS_DDI;
        else if (RQ(0) && RQ(1) && IM(2))
          return NS_QQI;
        else
          inst.error = _("expected <Qd>, <Qn>, #<imm> or <Dd>, <Dn>, #<imm> "
                         "operands");
      }
        break;
  
    case NS_DDDI_QQQI:
      {
        if (RD(0) && RD(1) && RD(2) && IM(3))
          return NS_DDDI;
        if (RQ(0) && RQ(1) && RQ(2) && IM(3))
          return NS_QQQI;
        else
          inst.error = _("expected <Qd>, <Qn>, <Qm>, #<imm> or "
                         "<Dd>, <Dn>, <Dm>, #<imm> operands");
      }
        break;
  
    case NS_DDS_QQS:
      {
        if (RD(0) && RD(1) && SC(2))
          return NS_DDS;
        else if (RQ(0) && RQ(1) && SC(2))
          return NS_QQS;
        else
          inst.error = _("expected <Qd>, <Qn>, <Dm[x]> or <Dd>, <Dn>, <Dm[x]> "
                         "operands");
      }
      break;
  
    case NS_DD_QQ:
      {
        if (RD(0) && RD(1))
          return NS_DD;
        else if (RQ(0) && RQ(1))
          return NS_QQ;
        else
          inst.error = _("expected <Qd>, <Qm> or <Dd>, <Dm> operands");
      }
      break;
  
    case NS_DS_QS:
      {
        if (RD(0) && SC(1))
          return NS_DS;
        else if (RQ(0) && SC(1))
          return NS_QS;
        else
          inst.error = _("expected <Qd>, <Dm[x]> or <Dd>, <Dm[x]> operands");
      }
      break;

    case NS_DR_QR:
      {
        if (RD(0) && RR(1))
          return NS_DR;
        else if (RQ(0) && RR(1))
          return NS_QR;
        else
          inst.error = _("expected <Qd>, <Rm> or <Dd>, <Rm> operands");
      }
      break;

    case NS_DI_QI:
      {
        if (RD(0) && IM(1))
          return NS_DI;
        else if (RQ(0) && IM(1))
          return NS_QI;
        else
          inst.error = _("expected <Qd>, #<imm> or <Dd>, #<imm> operands");
      }
      break;
   
    default:
      abort ();
    }

  return req;
#undef RR
#undef RD
#undef RQ
#undef IM
#undef SC
}
  
static void
neon_modify_type_size (unsigned typebits, enum neon_el_type *g_type,
                       unsigned *g_size)
{
  /* Allow modification to be made to types which are constrained to be
     based on the key element, based on bits set alongside N_EQK.  */
  if ((typebits & N_EQK) != 0)
    {
      if ((typebits & N_HLF) != 0)
	*g_size /= 2;
      else if ((typebits & N_DBL) != 0)
	*g_size *= 2;
      if ((typebits & N_SGN) != 0)
	*g_type = NT_signed;
      else if ((typebits & N_UNS) != 0)
        *g_type = NT_unsigned;
      else if ((typebits & N_INT) != 0)
        *g_type = NT_integer;
      else if ((typebits & N_FLT) != 0)
        *g_type = NT_float;
    }
}
  
/* Return operand OPNO promoted by bits set in THISARG. KEY should be the "key"
   operand type, i.e. the single type specified in a Neon instruction when it
   is the only one given.  */

static struct neon_type_el
neon_type_promote (struct neon_type_el *key, unsigned thisarg)
{
  struct neon_type_el dest = *key;
  
  assert ((thisarg & N_EQK) != 0);
  
  neon_modify_type_size (thisarg, &dest.type, &dest.size);

  return dest;
}

/* Convert Neon type and size into compact bitmask representation.  */

static enum neon_type_mask
type_chk_of_el_type (enum neon_el_type type, unsigned size)
{
  switch (type)
    {
    case NT_untyped:
      switch (size)
        {
        case 8:  return N_8;
        case 16: return N_16;
        case 32: return N_32;
        case 64: return N_64;
        default: ;
        }
      break;

    case NT_integer:
      switch (size)
        {
        case 8:  return N_I8;
        case 16: return N_I16;
        case 32: return N_I32;
        case 64: return N_I64;
        default: ;
        }
      break;

    case NT_float:
      if (size == 32)
        return N_F32;
      break;

    case NT_poly:
      switch (size)
        {
        case 8:  return N_P8;
        case 16: return N_P16;
        default: ;
        }
      break;

    case NT_signed:
      switch (size)
        {
        case 8:  return N_S8;
        case 16: return N_S16;
        case 32: return N_S32;
        case 64: return N_S64;
        default: ;
        }
      break;

    case NT_unsigned:
      switch (size)
        {
        case 8:  return N_U8;
        case 16: return N_U16;
        case 32: return N_U32;
        case 64: return N_U64;
        default: ;
        }
      break;

    default: ;
    }
  
  return N_UTYP;
}

/* Convert compact Neon bitmask type representation to a type and size. Only
   handles the case where a single bit is set in the mask.  */

static void
el_type_of_type_chk (enum neon_el_type *type, unsigned *size,
                     enum neon_type_mask mask)
{
  if ((mask & (N_S8 | N_U8 | N_I8 | N_8 | N_P8)) != 0)
    *size = 8;
  if ((mask & (N_S16 | N_U16 | N_I16 | N_16 | N_P16)) != 0)
    *size = 16;
  if ((mask & (N_S32 | N_U32 | N_I32 | N_32 | N_F32)) != 0)
    *size = 32;
  if ((mask & (N_S64 | N_U64 | N_I64 | N_64)) != 0)
    *size = 64;
  if ((mask & (N_S8 | N_S16 | N_S32 | N_S64)) != 0)
    *type = NT_signed;
  if ((mask & (N_U8 | N_U16 | N_U32 | N_U64)) != 0)
    *type = NT_unsigned;
  if ((mask & (N_I8 | N_I16 | N_I32 | N_I64)) != 0)
    *type = NT_integer;
  if ((mask & (N_8 | N_16 | N_32 | N_64)) != 0)
    *type = NT_untyped;
  if ((mask & (N_P8 | N_P16)) != 0)
    *type = NT_poly;
  if ((mask & N_F32) != 0)
    *type = NT_float;
}

/* Modify a bitmask of allowed types. This is only needed for type
   relaxation.  */

static unsigned
modify_types_allowed (unsigned allowed, unsigned mods)
{
  unsigned size;
  enum neon_el_type type;
  unsigned destmask;
  int i;
  
  destmask = 0;
  
  for (i = 1; i <= N_MAX_NONSPECIAL; i <<= 1)
    {
      el_type_of_type_chk (&type, &size, allowed & i);
      neon_modify_type_size (mods, &type, &size);
      destmask |= type_chk_of_el_type (type, size);
    }
  
  return destmask;
}

/* Check type and return type classification.
   The manual states (paraphrase): If one datatype is given, it indicates the
   type given in:
    - the second operand, if there is one
    - the operand, if there is no second operand
    - the result, if there are no operands.
   This isn't quite good enough though, so we use a concept of a "key" datatype
   which is set on a per-instruction basis, which is the one which matters when
   only one data type is written.
   Note: this function has side-effects (e.g. filling in missing operands). All
   Neon instructions should call it before performing bit encoding.
*/

static struct neon_type_el
neon_check_type (unsigned els, enum neon_shape ns, ...)
{
  va_list ap;
  unsigned i, pass, key_el = 0;
  unsigned types[NEON_MAX_TYPE_ELS];
  enum neon_el_type k_type = NT_invtype;
  unsigned k_size = -1u;
  struct neon_type_el badtype = {NT_invtype, -1};
  unsigned key_allowed = 0;

  /* Optional registers in Neon instructions are always (not) in operand 1.
     Fill in the missing operand here, if it was omitted.  */
  if (els > 1 && !inst.operands[1].present)
    inst.operands[1] = inst.operands[0];

  /* Suck up all the varargs.  */
  va_start (ap, ns);
  for (i = 0; i < els; i++)
    {
      unsigned thisarg = va_arg (ap, unsigned);
      if (thisarg == N_IGNORE_TYPE)
        {
          va_end (ap);
          return badtype;
        }
      types[i] = thisarg;
      if ((thisarg & N_KEY) != 0)
        key_el = i;
    }
  va_end (ap);

  /* Duplicate inst.vectype elements here as necessary.
     FIXME: No idea if this is exactly the same as the ARM assembler,
     particularly when an insn takes one register and one non-register
     operand. */
  if (inst.vectype.elems == 1 && els > 1)
    {
      unsigned j;
      inst.vectype.elems = els;
      inst.vectype.el[key_el] = inst.vectype.el[0];
      for (j = 0; j < els; j++)
        {
          if (j != key_el)
            inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
                                                    types[j]);
        }
    }
  else if (inst.vectype.elems != els)
    {
      inst.error = _("type specifier has the wrong number of parts");
      return badtype;
    }

  for (pass = 0; pass < 2; pass++)
    {
      for (i = 0; i < els; i++)
        {
          unsigned thisarg = types[i];
          unsigned types_allowed = ((thisarg & N_EQK) != 0 && pass != 0)
            ? modify_types_allowed (key_allowed, thisarg) : thisarg;
          enum neon_el_type g_type = inst.vectype.el[i].type;
          unsigned g_size = inst.vectype.el[i].size;

          /* Decay more-specific signed & unsigned types to sign-insensitive
	     integer types if sign-specific variants are unavailable.  */
          if ((g_type == NT_signed || g_type == NT_unsigned)
	      && (types_allowed & N_SU_ALL) == 0)
	    g_type = NT_integer;

          /* If only untyped args are allowed, decay any more specific types to
	     them. Some instructions only care about signs for some element
	     sizes, so handle that properly.  */
          if ((g_size == 8 && (types_allowed & N_8) != 0)
	      || (g_size == 16 && (types_allowed & N_16) != 0)
	      || (g_size == 32 && (types_allowed & N_32) != 0)
	      || (g_size == 64 && (types_allowed & N_64) != 0))
	    g_type = NT_untyped;

          if (pass == 0)
            {
              if ((thisarg & N_KEY) != 0)
                {
                  k_type = g_type;
                  k_size = g_size;
                  key_allowed = thisarg & ~N_KEY;
                }
            }
          else
            {
              if ((thisarg & N_EQK) == 0)
                {
                  unsigned given_type = type_chk_of_el_type (g_type, g_size);

                  if ((given_type & types_allowed) == 0)
                    {
	              inst.error = _("bad type in Neon instruction");
	              return badtype;
                    }
                }
              else
                {
                  enum neon_el_type mod_k_type = k_type;
                  unsigned mod_k_size = k_size;
                  neon_modify_type_size (thisarg, &mod_k_type, &mod_k_size);
                  if (g_type != mod_k_type || g_size != mod_k_size)
                    {
                      inst.error = _("inconsistent types in Neon instruction");
                      return badtype;
                    }
                }
            }
        }
    }

  return inst.vectype.el[key_el];
}

/* Fix up Neon data-processing instructions, ORing in the correct bits for
   ARM mode or Thumb mode and moving the encoded bit 24 to bit 28.  */

static unsigned
neon_dp_fixup (unsigned i)
{
  if (thumb_mode)
    {
      /* The U bit is at bit 24 by default. Move to bit 28 in Thumb mode.  */
      if (i & (1 << 24))
        i |= 1 << 28;
      
      i &= ~(1 << 24);
      
      i |= 0xef000000;
    }
  else
    i |= 0xf2000000;
  
  return i;
}

/* Turn a size (8, 16, 32, 64) into the respective bit number minus 3
   (0, 1, 2, 3).  */

static unsigned
neon_logbits (unsigned x)
{
  return ffs (x) - 4;
}

#define LOW4(R) ((R) & 0xf)
#define HI1(R) (((R) >> 4) & 1)

/* Encode insns with bit pattern:

  |28/24|23|22 |21 20|19 16|15 12|11    8|7|6|5|4|3  0|
  |  U  |x |D  |size | Rn  | Rd  |x x x x|N|Q|M|x| Rm |
  
  SIZE is passed in bits. -1 means size field isn't changed, in case it has a
  different meaning for some instruction.  */

static void
neon_three_same (int first_optional, int isquad, int ubit, int size)
{
  /* FIXME optional argument handling.  */
  if (first_optional && !inst.operands[0].present)
    inst.operands[0].reg = inst.operands[1].reg;

  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= (isquad != 0) << 6;
  inst.instruction |= (ubit != 0) << 24;
  if (size != -1)
    inst.instruction |= neon_logbits (size) << 20;
  
  inst.instruction = neon_dp_fixup (inst.instruction);
}

/* Encode instructions of the form:

  |28/24|23|22|21 20|19 18|17 16|15 12|11      7|6|5|4|3  0|
  |  U  |x |D |x  x |size |x  x | Rd  |x x x x x|Q|M|x| Rm |

  Don't write size if SIZE == -1.  */

static void
neon_two_same (int qbit, int ubit, int size)
{
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg);
  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
  inst.instruction |= (qbit != 0) << 6;
  inst.instruction |= (ubit != 0) << 24;

  if (size != -1)
    inst.instruction |= neon_logbits (size) << 18;

  inst.instruction = neon_dp_fixup (inst.instruction);
}

/* Neon instruction encoders, in approximate order of appearance.  */

static void
do_neon_dyadic_i_su (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_SU_32 | N_KEY);
  neon_three_same (TRUE, rs == NS_QQQ, et.type == NT_unsigned, et.size);
}

static void
do_neon_dyadic_i64_su (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_SU_ALL | N_KEY);
  neon_three_same (TRUE, rs == NS_QQQ, et.type == NT_unsigned, et.size);
}

static void
neon_imm_shift (int write_ubit, int uval, int isquad, struct neon_type_el et,
                unsigned immbits)
{
  unsigned size = et.size >> 3;
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg);
  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
  inst.instruction |= (isquad != 0) << 6;
  inst.instruction |= immbits << 16;
  inst.instruction |= (size >> 3) << 7;
  inst.instruction |= (size & 0x7) << 19;
  if (write_ubit)
    inst.instruction |= (uval != 0) << 24;

  inst.instruction = neon_dp_fixup (inst.instruction);
}

static void
do_neon_shl_imm (void)
{
  if (!inst.operands[2].isreg)
    {
      enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
      struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_KEY | N_I_ALL);
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
      neon_imm_shift (FALSE, 0, rs == NS_QQI, et, inst.operands[2].imm);
    }
  else
    {
      enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
      struct neon_type_el et = neon_check_type (3, rs,
        N_EQK, N_SU_ALL | N_KEY, N_EQK | N_SGN);
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      neon_three_same (TRUE, rs == NS_QQQ, et.type == NT_unsigned, et.size);
    }
}

static void
do_neon_qshl_imm (void)
{
  if (!inst.operands[2].isreg)
    {
      enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
      struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_ALL | N_KEY);
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
      neon_imm_shift (TRUE, et.type == NT_unsigned, rs == NS_QQI, et,
                      inst.operands[2].imm);
    }
  else
    {
      enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
      struct neon_type_el et = neon_check_type (3, rs,
        N_EQK, N_SU_ALL | N_KEY, N_EQK | N_SGN);
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      neon_three_same (TRUE, rs == NS_QQQ, et.type == NT_unsigned, et.size);
    }
}

static int
neon_cmode_for_logic_imm (unsigned immediate, unsigned *immbits, int size)
{
  /* Handle .I8 and .I64 as pseudo-instructions.  */
  switch (size)
    {
    case 8:
      /* Unfortunately, this will make everything apart from zero out-of-range.
         FIXME is this the intended semantics? There doesn't seem much point in
         accepting .I8 if so.  */
      immediate |= immediate << 8;
      size = 16;
      break;
    case 64:
      /* Similarly, anything other than zero will be replicated in bits [63:32],
         which probably isn't want we want if we specified .I64.  */
      if (immediate != 0)
        goto bad_immediate;
      size = 32;
      break;
    default: ;
    }

  if (immediate == (immediate & 0x000000ff))
    {
      *immbits = immediate;
      return (size == 16) ? 0x9 : 0x1;
    }
  else if (immediate == (immediate & 0x0000ff00))
    {
      *immbits = immediate >> 8;
      return (size == 16) ? 0xb : 0x3;
    }
  else if (immediate == (immediate & 0x00ff0000))
    {
      *immbits = immediate >> 16;
      return 0x5;
    }
  else if (immediate == (immediate & 0xff000000))
    {
      *immbits = immediate >> 24;
      return 0x7;
    }

  bad_immediate:
  inst.error = _("immediate value out of range");
  return FAIL;
}

/* True if IMM has form 0bAAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD for bits
   A, B, C, D.  */

static int
neon_bits_same_in_bytes (unsigned imm)
{
  return ((imm & 0x000000ff) == 0 || (imm & 0x000000ff) == 0x000000ff)
         && ((imm & 0x0000ff00) == 0 || (imm & 0x0000ff00) == 0x0000ff00)
         && ((imm & 0x00ff0000) == 0 || (imm & 0x00ff0000) == 0x00ff0000)
         && ((imm & 0xff000000) == 0 || (imm & 0xff000000) == 0xff000000);
}

/* For immediate of above form, return 0bABCD.  */

static unsigned
neon_squash_bits (unsigned imm)
{
  return (imm & 0x01) | ((imm & 0x0100) >> 7) | ((imm & 0x010000) >> 14)
         | ((imm & 0x01000000) >> 21);
}

/* Returns 1 if a number has "quarter-precision" float format
   0baBbbbbbc defgh000 00000000 00000000.  */

static int
neon_is_quarter_float (unsigned imm)
{
  int b = (imm & 0x20000000) != 0;
  int bs = (b << 25) | (b << 26) | (b << 27) | (b << 28) | (b << 29)
           | ((!b) << 30);
  return (imm & 0x81ffffff) == (imm & 0x81f80000)
         && ((imm & 0x7e000000) ^ bs) == 0;
}

/* Compress above representation to 0b...000 abcdefgh.  */

static unsigned
neon_qfloat_bits (unsigned imm)
{
  return ((imm >> 19) & 0x7f) | (imm >> 24);
}

/* Returns CMODE. IMMBITS [7:0] is set to bits suitable for inserting into
   the instruction. *OP is passed as the initial value of the op field, and
   may be set to a different value depending on the constant (i.e.
   "MOV I64, 0bAAAAAAAABBBB..." which uses OP = 1 despite being MOV not
   MVN).  */

static int
neon_cmode_for_move_imm (unsigned immlo, unsigned immhi, unsigned *immbits,
                         int *op, int size)
{
  if (size == 64 && neon_bits_same_in_bytes (immhi)
      && neon_bits_same_in_bytes (immlo))
    {
      /* Check this one first so we don't have to bother with immhi in later
         tests.  */
      if (*op == 1)
        return FAIL;
      *immbits = (neon_squash_bits (immhi) << 4) | neon_squash_bits (immlo);
      *op = 1;
      return 0xe;
    }
  else if (immhi != 0)
    return FAIL;
  else if (immlo == (immlo & 0x000000ff))
    {
      /* 64-bit case was already handled. Don't allow MVN with 8-bit
         immediate.  */
      if ((size != 8 && size != 16 && size != 32)
          || (size == 8 && *op == 1))
        return FAIL;
      *immbits = immlo;
      return (size == 8) ? 0xe : (size == 16) ? 0x8 : 0x0;
    }
  else if (immlo == (immlo & 0x0000ff00))
    {
      if (size != 16 && size != 32)
        return FAIL;
      *immbits = immlo >> 8;
      return (size == 16) ? 0xa : 0x2;
    }
  else if (immlo == (immlo & 0x00ff0000))
    {
      if (size != 32)
        return FAIL;
      *immbits = immlo >> 16;
      return 0x4;
    }
  else if (immlo == (immlo & 0xff000000))
    {
      if (size != 32)
        return FAIL;
      *immbits = immlo >> 24;
      return 0x6;
    }
  else if (immlo == ((immlo & 0x0000ff00) | 0x000000ff))
    {
      if (size != 32)
        return FAIL;
      *immbits = (immlo >> 8) & 0xff;
      return 0xc;
    }
  else if (immlo == ((immlo & 0x00ff0000) | 0x0000ffff))
    {
      if (size != 32)
        return FAIL;
      *immbits = (immlo >> 16) & 0xff;
      return 0xd;
    }
  else if (neon_is_quarter_float (immlo))
    {
      if (size != 32 || *op == 1)
        return FAIL;
      *immbits = neon_qfloat_bits (immlo);
      return 0xf;
    }

  return FAIL;
}

/* Write immediate bits [7:0] to the following locations:

  |28/24|23     19|18 16|15                    4|3     0|
  |  a  |x x x x x|b c d|x x x x x x x x x x x x|e f g h|

  This function is used by VMOV/VMVN/VORR/VBIC.  */

static void
neon_write_immbits (unsigned immbits)
{
  inst.instruction |= immbits & 0xf;
  inst.instruction |= ((immbits >> 4) & 0x7) << 16;
  inst.instruction |= ((immbits >> 7) & 0x1) << 24;
}

/* Invert low-order SIZE bits of XHI:XLO.  */

static void
neon_invert_size (unsigned *xlo, unsigned *xhi, int size)
{
  unsigned immlo = xlo ? *xlo : 0;
  unsigned immhi = xhi ? *xhi : 0;

  switch (size)
    {
    case 8:
      immlo = (~immlo) & 0xff;
      break;

    case 16:
      immlo = (~immlo) & 0xffff;
      break;

    case 64:
      immhi = (~immhi) & 0xffffffff;
      /* fall through.  */

    case 32:
      immlo = (~immlo) & 0xffffffff;
      break;

    default:
      abort ();
    }

  if (xlo)
    *xlo = immlo;

  if (xhi)
    *xhi = immhi;
}

static void
do_neon_logic (void)
{
  if (inst.operands[2].present && inst.operands[2].isreg)
    {
      enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
      neon_check_type (3, rs, N_IGNORE_TYPE);
      /* U bit and size field were set as part of the bitmask.  */
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      neon_three_same (TRUE, rs == NS_QQQ, 0, -1);
    }
  else
    {
      enum neon_shape rs = neon_check_shape (NS_DI_QI);
      struct neon_type_el et = neon_check_type (1, rs, N_I8 | N_I16 | N_I32
                                                | N_I64 | N_F32);
      enum neon_opc opcode = inst.instruction & 0x0fffffff;
      unsigned immbits;
      int cmode;
      
      if (et.type == NT_invtype)
        return;
      
      inst.instruction = NEON_ENC_IMMED (inst.instruction);

      switch (opcode)
        {
        case N_MNEM_vbic:
          cmode = neon_cmode_for_logic_imm (inst.operands[1].imm, &immbits,
                                            et.size);
          break;
        
        case N_MNEM_vorr:
          cmode = neon_cmode_for_logic_imm (inst.operands[1].imm, &immbits,
                                            et.size);
          break;
        
        case N_MNEM_vand:
          /* Pseudo-instruction for VBIC.  */
          immbits = inst.operands[1].imm;
          neon_invert_size (&immbits, 0, et.size);
          cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
          break;
        
        case N_MNEM_vorn:
          /* Pseudo-instruction for VORR.  */
          immbits = inst.operands[1].imm;
          neon_invert_size (&immbits, 0, et.size);
          cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
          break;
        
        default:
          abort ();
        }

      if (cmode == FAIL)
        return;

      inst.instruction |= (rs == NS_QI) << 6;
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= cmode << 8;
      neon_write_immbits (immbits);
      
      inst.instruction = neon_dp_fixup (inst.instruction);
    }
}

static void
do_neon_bitfield (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
  /* FIXME: Check that no type was given.  */
  neon_three_same (FALSE, rs == NS_QQQ, 0, -1);
}

static void
neon_dyadic (enum neon_el_type ubit_meaning, unsigned types)
{
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
  struct neon_type_el et = neon_check_type (3, rs, N_EQK, N_EQK, types | N_KEY);
  if (et.type == NT_float)
    {
      inst.instruction = NEON_ENC_FLOAT (inst.instruction);
      neon_three_same (TRUE, rs == NS_QQQ, 0, -1);
    }
  else
    {
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      neon_three_same (TRUE, rs == NS_QQQ, et.type == ubit_meaning, et.size);
    }
}

static void
do_neon_dyadic_if_su (void)
{
  neon_dyadic (NT_unsigned, N_SUF_32);
}

static void
do_neon_dyadic_if_su_d (void)
{
  /* This version only allow D registers, but that constraint is enforced during
     operand parsing so we don't need to do anything extra here.  */
  neon_dyadic (NT_unsigned, N_SUF_32);
}

static void
do_neon_dyadic_if_i (void)
{
  neon_dyadic (NT_unsigned, N_IF_32);
}

static void
do_neon_dyadic_if_i_d (void)
{
  neon_dyadic (NT_unsigned, N_IF_32);
}

static void
do_neon_addsub_if_i (void)
{
  /* The "untyped" case can't happen. Do this to stop the "U" bit being
     affected if we specify unsigned args.  */
  neon_dyadic (NT_untyped, N_IF_32 | N_I64);
}

/* Swaps operands 1 and 2. If operand 1 (optional arg) was omitted, we want the
   result to be:
     V<op> A,B     (A is operand 0, B is operand 2)
   to mean:
     V<op> A,B,A
   not:
     V<op> A,B,B
   so handle that case specially.  */

static void
neon_exchange_operands (void)
{
  void *scratch = alloca (sizeof (inst.operands[0]));
  if (inst.operands[1].present)
    {
      /* Swap operands[1] and operands[2].  */
      memcpy (scratch, &inst.operands[1], sizeof (inst.operands[0]));
      inst.operands[1] = inst.operands[2];
      memcpy (&inst.operands[2], scratch, sizeof (inst.operands[0]));
    }
  else
    {
      inst.operands[1] = inst.operands[2];
      inst.operands[2] = inst.operands[0];
    }
}

static void
neon_compare (unsigned regtypes, unsigned immtypes, int invert)
{
  if (inst.operands[2].isreg)
    {
      if (invert)
        neon_exchange_operands ();
      neon_dyadic (NT_unsigned, regtypes);
    }
  else
    {
      enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
      struct neon_type_el et = neon_check_type (2, rs, N_EQK, immtypes | N_KEY);

      inst.instruction = NEON_ENC_IMMED (inst.instruction);
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= (rs == NS_QQI) << 6;
      inst.instruction |= (et.type == NT_float) << 10;
      inst.instruction |= neon_logbits (et.size) << 18;
      
      inst.instruction = neon_dp_fixup (inst.instruction);
    }
}

static void
do_neon_cmp (void)
{
  neon_compare (N_SUF_32, N_S8 | N_S16 | N_S32 | N_F32, FALSE);
}

static void
do_neon_cmp_inv (void)
{
  neon_compare (N_SUF_32, N_S8 | N_S16 | N_S32 | N_F32, TRUE);
}

static void
do_neon_ceq (void)
{
  neon_compare (N_IF_32, N_IF_32, FALSE);
}

/* For multiply instructions, we have the possibility of 16-bit or 32-bit
   scalars, which are encoded in 5 bits, M : Rm.
   For 16-bit scalars, the register is encoded in Rm[2:0] and the index in
   M:Rm[3], and for 32-bit scalars, the register is encoded in Rm[3:0] and the
   index in M.  */

static unsigned
neon_scalar_for_mul (unsigned scalar, unsigned elsize)
{
  unsigned regno = scalar >> 3;
  unsigned elno = scalar & 7;

  switch (elsize)
    {
    case 16:
      if (regno > 7 || elno > 3)
        goto bad_scalar;
      return regno | (elno << 3);
    
    case 32:
      if (regno > 15 || elno > 1)
        goto bad_scalar;
      return regno | (elno << 4);

    default:
    bad_scalar:
      as_bad (_("Scalar out of range for multiply instruction"));
    }

  return 0;
}

/* Encode multiply / multiply-accumulate scalar instructions.  */

static void
neon_mul_mac (struct neon_type_el et, int ubit)
{
  unsigned scalar = neon_scalar_for_mul (inst.operands[2].reg, et.size);
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (scalar);
  inst.instruction |= HI1 (scalar) << 5;
  inst.instruction |= (et.type == NT_float) << 8;
  inst.instruction |= neon_logbits (et.size) << 20;
  inst.instruction |= (ubit != 0) << 24;

  inst.instruction = neon_dp_fixup (inst.instruction);
}

static void
do_neon_mac_maybe_scalar (void)
{
  if (inst.operands[2].isscalar)
    {
      enum neon_shape rs = neon_check_shape (NS_DDS_QQS);
      struct neon_type_el et = neon_check_type (3, rs,
        N_EQK, N_EQK, N_I16 | N_I32 | N_F32 | N_KEY);
      inst.instruction = NEON_ENC_SCALAR (inst.instruction);
      neon_mul_mac (et, rs == NS_QQS);
    }
  else
    do_neon_dyadic_if_i ();
}

static void
do_neon_tst (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_8 | N_16 | N_32 | N_KEY);
  neon_three_same (TRUE, rs == NS_QQQ, 0, et.size);
}

/* VMUL with 3 registers allows the P8 type. The scalar version supports the
   same types as the MAC equivalents. The polynomial type for this instruction
   is encoded the same as the integer type.  */

static void
do_neon_mul (void)
{
  if (inst.operands[2].isscalar)
    do_neon_mac_maybe_scalar ();
  else
    neon_dyadic (NT_poly, N_I8 | N_I16 | N_I32 | N_F32 | N_P8);
}

static void
do_neon_qdmulh (void)
{
  if (inst.operands[2].isscalar)
    {
      enum neon_shape rs = neon_check_shape (NS_DDS_QQS);
      struct neon_type_el et = neon_check_type (3, rs,
        N_EQK, N_EQK, N_S16 | N_S32 | N_KEY);
      inst.instruction = NEON_ENC_SCALAR (inst.instruction);
      neon_mul_mac (et, rs == NS_QQS);
    }
  else
    {
      enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
      struct neon_type_el et = neon_check_type (3, rs,
        N_EQK, N_EQK, N_S16 | N_S32 | N_KEY);
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      /* The U bit (rounding) comes from bit mask.  */
      neon_three_same (TRUE, rs == NS_QQQ, 0, et.size);
    }
}

static void
do_neon_fcmp_absolute (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
  neon_check_type (3, rs, N_EQK, N_EQK, N_F32 | N_KEY);
  /* Size field comes from bit mask.  */
  neon_three_same (TRUE, rs == NS_QQQ, 1, -1);
}

static void
do_neon_fcmp_absolute_inv (void)
{
  neon_exchange_operands ();
  do_neon_fcmp_absolute ();
}

static void
do_neon_step (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDD_QQQ);
  neon_check_type (3, rs, N_EQK, N_EQK, N_F32 | N_KEY);
  neon_three_same (TRUE, rs == NS_QQQ, 0, -1);
}

static void
do_neon_abs_neg (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_S8 | N_S16 | N_S32 | N_F32 | N_KEY);
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg);
  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
  inst.instruction |= (rs == NS_QQ) << 6;
  inst.instruction |= (et.type == NT_float) << 10;
  inst.instruction |= neon_logbits (et.size) << 18;
  
  inst.instruction = neon_dp_fixup (inst.instruction);
}

static void
do_neon_sli (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
  int imm = inst.operands[2].imm;
  constraint (imm < 0 || (unsigned)imm >= et.size,
              _("immediate out of range for insert"));
  neon_imm_shift (FALSE, 0, rs == NS_QQI, et, imm);
}

static void
do_neon_sri (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
  int imm = inst.operands[2].imm;
  constraint (imm < 1 || (unsigned)imm > et.size,
              _("immediate out of range for insert"));
  neon_imm_shift (FALSE, 0, rs == NS_QQI, et, et.size - imm);
}

static void
do_neon_qshlu_imm (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK | N_UNS, N_S8 | N_S16 | N_S32 | N_S64 | N_KEY);
  int imm = inst.operands[2].imm;
  constraint (imm < 0 || (unsigned)imm >= et.size,
              _("immediate out of range for shift"));
  /* Only encodes the 'U present' variant of the instruction.
     In this case, signed types have OP (bit 8) set to 0.
     Unsigned types have OP set to 1.  */
  inst.instruction |= (et.type == NT_unsigned) << 8;
  /* The rest of the bits are the same as other immediate shifts.  */
  neon_imm_shift (FALSE, 0, rs == NS_QQI, et, imm);
}

static void
do_neon_qmovn (void)
{
  struct neon_type_el et = neon_check_type (2, NS_DQ,
    N_EQK | N_HLF, N_SU_16_64 | N_KEY);
  /* Saturating move where operands can be signed or unsigned, and the
     destination has the same signedness.  */
  inst.instruction = NEON_ENC_INTEGER (inst.instruction);
  if (et.type == NT_unsigned)
    inst.instruction |= 0xc0;
  else
    inst.instruction |= 0x80;
  neon_two_same (0, 1, et.size / 2);
}

static void
do_neon_qmovun (void)
{
  struct neon_type_el et = neon_check_type (2, NS_DQ,
    N_EQK | N_HLF | N_UNS, N_S16 | N_S32 | N_S64 | N_KEY);
  /* Saturating move with unsigned results. Operands must be signed.  */
  inst.instruction = NEON_ENC_INTEGER (inst.instruction);
  neon_two_same (0, 1, et.size / 2);
}

static void
do_neon_rshift_sat_narrow (void)
{
  /* FIXME: Types for narrowing. If operands are signed, results can be signed
     or unsigned. If operands are unsigned, results must also be unsigned.  */
  struct neon_type_el et = neon_check_type (2, NS_DQI,
    N_EQK | N_HLF, N_SU_16_64 | N_KEY);
  int imm = inst.operands[2].imm;
  /* This gets the bounds check, size encoding and immediate bits calculation
     right.  */
  et.size /= 2;
  
  /* VQ{R}SHRN.I<size> <Dd>, <Qm>, #0 is a synonym for
     VQMOVN.I<size> <Dd>, <Qm>.  */
  if (imm == 0)
    {
      inst.operands[2].present = 0;
      inst.instruction = N_MNEM_vqmovn;
      do_neon_qmovn ();
      return;
    }
  
  constraint (imm < 1 || (unsigned)imm > et.size,
              _("immediate out of range"));
  neon_imm_shift (TRUE, et.type == NT_unsigned, 0, et, et.size - imm);
}

static void
do_neon_rshift_sat_narrow_u (void)
{
  /* FIXME: Types for narrowing. If operands are signed, results can be signed
     or unsigned. If operands are unsigned, results must also be unsigned.  */
  struct neon_type_el et = neon_check_type (2, NS_DQI,
    N_EQK | N_HLF | N_UNS, N_S16 | N_S32 | N_S64 | N_KEY);
  int imm = inst.operands[2].imm;
  /* This gets the bounds check, size encoding and immediate bits calculation
     right.  */
  et.size /= 2;

  /* VQSHRUN.I<size> <Dd>, <Qm>, #0 is a synonym for
     VQMOVUN.I<size> <Dd>, <Qm>.  */
  if (imm == 0)
    {
      inst.operands[2].present = 0;
      inst.instruction = N_MNEM_vqmovun;
      do_neon_qmovun ();
      return;
    }

  constraint (imm < 1 || (unsigned)imm > et.size,
              _("immediate out of range"));
  /* FIXME: The manual is kind of unclear about what value U should have in
     VQ{R}SHRUN instructions, but U=0, op=0 definitely encodes VRSHR, so it
     must be 1.  */
  neon_imm_shift (TRUE, 1, 0, et, et.size - imm);
}

static void
do_neon_movn (void)
{
  struct neon_type_el et = neon_check_type (2, NS_DQ,
    N_EQK | N_HLF, N_I16 | N_I32 | N_I64 | N_KEY);
  inst.instruction = NEON_ENC_INTEGER (inst.instruction);
  neon_two_same (0, 1, et.size / 2);
}

static void
do_neon_rshift_narrow (void)
{
  struct neon_type_el et = neon_check_type (2, NS_DQI,
    N_EQK | N_HLF, N_I16 | N_I32 | N_I64 | N_KEY);
  int imm = inst.operands[2].imm;
  /* This gets the bounds check, size encoding and immediate bits calculation
     right.  */
  et.size /= 2;
  
  /* If immediate is zero then we are a pseudo-instruction for
     VMOVN.I<size> <Dd>, <Qm>  */
  if (imm == 0)
    {
      inst.operands[2].present = 0;
      inst.instruction = N_MNEM_vmovn;
      do_neon_movn ();
      return;
    }
  
  constraint (imm < 1 || (unsigned)imm > et.size,
              _("immediate out of range for narrowing operation"));
  neon_imm_shift (FALSE, 0, 0, et, et.size - imm);
}

static void
do_neon_shll (void)
{
  /* FIXME: Type checking when lengthening.  */
  struct neon_type_el et = neon_check_type (2, NS_QDI,
    N_EQK | N_DBL, N_I8 | N_I16 | N_I32 | N_KEY);
  unsigned imm = inst.operands[2].imm;

  if (imm == et.size)
    {
      /* Maximum shift variant.  */
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= neon_logbits (et.size) << 18;
      
      inst.instruction = neon_dp_fixup (inst.instruction);
    }
  else
    {
      /* A more-specific type check for non-max versions.  */
      et = neon_check_type (2, NS_QDI,
        N_EQK | N_DBL, N_SU_32 | N_KEY);
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
      neon_imm_shift (TRUE, et.type == NT_unsigned, 0, et, imm);
    }
}

/* Check the various types for the VCVT instruction, and return the one that
   the current instruction is.  */

static int
neon_cvt_flavour (enum neon_shape rs)
{
#define CVT_VAR(C,X,Y)				\
  et = neon_check_type (2, rs, (X), (Y));	\
  if (et.type != NT_invtype)			\
    {						\
      inst.error = NULL;			\
      return (C);				\
    }
  struct neon_type_el et;
  
  CVT_VAR (0, N_S32, N_F32);
  CVT_VAR (1, N_U32, N_F32);
  CVT_VAR (2, N_F32, N_S32);
  CVT_VAR (3, N_F32, N_U32);
  
  return -1;
#undef CVT_VAR
}

static void
do_neon_cvt (void)
{
  /* Fixed-point conversion with #0 immediate is encoded as an integer
     conversion.  */
  if (inst.operands[2].present && inst.operands[2].imm != 0)
    {
      enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
      int flavour = neon_cvt_flavour (rs);
      unsigned immbits = 32 - inst.operands[2].imm;
      unsigned enctab[] = { 0x0000100, 0x1000100, 0x0, 0x1000000 };
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
      if (flavour != -1)
        inst.instruction |= enctab[flavour];
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= (rs == NS_QQI) << 6;
      inst.instruction |= 1 << 21;
      inst.instruction |= immbits << 16;
    }
  else
    {
      enum neon_shape rs = neon_check_shape (NS_DD_QQ);
      int flavour = neon_cvt_flavour (rs);
      unsigned enctab[] = { 0x100, 0x180, 0x0, 0x080 };
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      if (flavour != -1)
        inst.instruction |= enctab[flavour];
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= (rs == NS_QQ) << 6;
      inst.instruction |= 2 << 18;
    }
  inst.instruction = neon_dp_fixup (inst.instruction);
}

static void
neon_move_immediate (void)
{
  enum neon_shape rs = neon_check_shape (NS_DI_QI);
  struct neon_type_el et = neon_check_type (1, rs,
    N_I8 | N_I16 | N_I32 | N_I64 | N_F32);
  unsigned immlo, immhi = 0, immbits;
  int op, cmode;

  /* We start out as an MVN instruction if OP = 1, MOV otherwise.  */
  op = (inst.instruction & (1 << 5)) != 0;

  immlo = inst.operands[1].imm;
  if (inst.operands[1].regisimm)
    immhi = inst.operands[1].reg;

  constraint (et.size < 32 && (immlo & ~((1 << et.size) - 1)) != 0,
              _("immediate has bits set outside the operand size"));

  if ((cmode = neon_cmode_for_move_imm (immlo, immhi, &immbits, &op,
                                        et.size)) == FAIL)
    {
      /* Invert relevant bits only.  */
      neon_invert_size (&immlo, &immhi, et.size);
      /* Flip from VMOV/VMVN to VMVN/VMOV. Some immediate types are unavailable
         with one or the other; those cases are caught by
         neon_cmode_for_move_imm.  */
      op = !op;
      if ((cmode = neon_cmode_for_move_imm (immlo, immhi, &immbits, &op,
                                            et.size)) == FAIL)
        {
          inst.error = _("immediate out of range");
          return;
        }
    }

  inst.instruction &= ~(1 << 5);
  inst.instruction |= op << 5;

  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= (rs == NS_QI) << 6;
  inst.instruction |= cmode << 8;

  neon_write_immbits (immbits);
}

static void
do_neon_mvn (void)
{
  if (inst.operands[1].isreg)
    {
      enum neon_shape rs = neon_check_shape (NS_DD_QQ);
      
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (inst.operands[1].reg);
      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
      inst.instruction |= (rs == NS_QQ) << 6;
    }
  else
    {
      inst.instruction = NEON_ENC_IMMED (inst.instruction);
      neon_move_immediate ();
    }

  inst.instruction = neon_dp_fixup (inst.instruction);
}

/* Encode instructions of form:

  |28/24|23|22|21 20|19 16|15 12|11    8|7|6|5|4|3  0|
  |  U  |x |D |size | Rn  | Rd  |x x x x|N|x|M|x| Rm |

*/

static void
neon_mixed_length (struct neon_type_el et, unsigned size)
{
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= (et.type == NT_unsigned) << 24;
  inst.instruction |= neon_logbits (size) << 20;
  
  inst.instruction = neon_dp_fixup (inst.instruction);
}

static void
do_neon_dyadic_long (void)
{
  /* FIXME: Type checking for lengthening op.  */
  struct neon_type_el et = neon_check_type (3, NS_QDD,
    N_EQK | N_DBL, N_EQK, N_SU_32 | N_KEY);
  neon_mixed_length (et, et.size);
}

static void
do_neon_abal (void)
{
  struct neon_type_el et = neon_check_type (3, NS_QDD,
    N_EQK | N_INT | N_DBL, N_EQK, N_SU_32 | N_KEY);
  neon_mixed_length (et, et.size);
}

static void
neon_mac_reg_scalar_long (unsigned regtypes, unsigned scalartypes)
{
  if (inst.operands[2].isscalar)
    {
      struct neon_type_el et = neon_check_type (2, NS_QDS,
        N_EQK | N_DBL, regtypes | N_KEY);
      inst.instruction = NEON_ENC_SCALAR (inst.instruction);
      neon_mul_mac (et, et.type == NT_unsigned);
    }
  else
    {
      struct neon_type_el et = neon_check_type (3, NS_QDD,
        N_EQK | N_DBL, N_EQK, scalartypes | N_KEY);
      inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      neon_mixed_length (et, et.size);
    }
}

static void
do_neon_mac_maybe_scalar_long (void)
{
  neon_mac_reg_scalar_long (N_S16 | N_S32 | N_U16 | N_U32, N_SU_32);
}

static void
do_neon_dyadic_wide (void)
{
  struct neon_type_el et = neon_check_type (3, NS_QQD,
    N_EQK | N_DBL, N_EQK | N_DBL, N_SU_32 | N_KEY);
  neon_mixed_length (et, et.size);
}

static void
do_neon_dyadic_narrow (void)
{
  struct neon_type_el et = neon_check_type (3, NS_QDD,
    N_EQK | N_DBL, N_EQK, N_I16 | N_I32 | N_I64 | N_KEY);
  neon_mixed_length (et, et.size / 2);
}

static void
do_neon_mul_sat_scalar_long (void)
{
  neon_mac_reg_scalar_long (N_S16 | N_S32, N_S16 | N_S32);
}

static void
do_neon_vmull (void)
{
  if (inst.operands[2].isscalar)
    do_neon_mac_maybe_scalar_long ();
  else
    {
      struct neon_type_el et = neon_check_type (3, NS_QDD,
        N_EQK | N_DBL, N_EQK, N_SU_32 | N_P8 | N_KEY);
      if (et.type == NT_poly)
        inst.instruction = NEON_ENC_POLY (inst.instruction);
      else
        inst.instruction = NEON_ENC_INTEGER (inst.instruction);
      /* For polynomial encoding, size field must be 0b00 and the U bit must be
         zero. Should be OK as-is.  */
      neon_mixed_length (et, et.size);
    }
}

static void
do_neon_ext (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDDI_QQQI);
  struct neon_type_el et = neon_check_type (3, rs,
    N_EQK, N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
  unsigned imm = (inst.operands[3].imm * et.size) / 8;
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= (rs == NS_QQQI) << 6;
  inst.instruction |= imm << 8;
  
  inst.instruction = neon_dp_fixup (inst.instruction);
}

static void
do_neon_rev (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_KEY);
  unsigned op = (inst.instruction >> 7) & 3;
  /* N (width of reversed regions) is encoded as part of the bitmask. We
     extract it here to check the elements to be reversed are smaller.
     Otherwise we'd get a reserved instruction.  */
  unsigned elsize = (op == 2) ? 16 : (op == 1) ? 32 : (op == 0) ? 64 : 0;
  assert (elsize != 0);
  constraint (et.size >= elsize,
              _("elements must be smaller than reversal region"));
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_dup (void)
{
  if (inst.operands[1].isscalar)
    {
      enum neon_shape rs = neon_check_shape (NS_DS_QS);
      struct neon_type_el et = neon_check_type (1, rs, N_8 | N_16 | N_32);
      unsigned sizebits = et.size >> 3;
      unsigned dm = inst.operands[1].reg >> 3;
      int logsize = neon_logbits (et.size);
      unsigned x = (inst.operands[1].reg & 7) << logsize;
      inst.instruction = NEON_ENC_SCALAR (inst.instruction);
      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
      inst.instruction |= LOW4 (dm);
      inst.instruction |= HI1 (dm) << 5;
      inst.instruction |= (rs == NS_QS) << 6;
      inst.instruction |= x << 17;
      inst.instruction |= sizebits << 16;
      
      inst.instruction = neon_dp_fixup (inst.instruction);
    }
  else
    {
      enum neon_shape rs = neon_check_shape (NS_DR_QR);
      struct neon_type_el et = neon_check_type (1, rs, N_8 | N_16 | N_32);
      unsigned save_cond = inst.instruction & 0xf0000000;
      /* Duplicate ARM register to lanes of vector.  */
      inst.instruction = NEON_ENC_ARMREG (inst.instruction);
      switch (et.size)
        {
        case 8:  inst.instruction |= 0x400000; break;
        case 16: inst.instruction |= 0x000020; break;
        case 32: inst.instruction |= 0x000000; break;
        default: break;
        }
      inst.instruction |= LOW4 (inst.operands[1].reg) << 12;
      inst.instruction |= LOW4 (inst.operands[0].reg) << 16;
      inst.instruction |= HI1 (inst.operands[0].reg) << 7;
      inst.instruction |= (rs == NS_QR) << 21;
      /* The encoding for this instruction is identical for the ARM and Thumb
         variants, except for the condition field.  */
      if (thumb_mode)
        inst.instruction |= 0xe0000000;
      else
        inst.instruction |= save_cond;
    }
}

/* VMOV has particularly many variations. It can be one of:
     0. VMOV<c><q> <Qd>, <Qm>
     1. VMOV<c><q> <Dd>, <Dm>
   (Register operations, which are VORR with Rm = Rn.)
     2. VMOV<c><q>.<dt> <Qd>, #<imm>
     3. VMOV<c><q>.<dt> <Dd>, #<imm>
   (Immediate loads.)
     4. VMOV<c><q>.<size> <Dn[x]>, <Rd>
   (ARM register to scalar.)
     5. VMOV<c><q> <Dm>, <Rd>, <Rn>
   (Two ARM registers to vector.)
     6. VMOV<c><q>.<dt> <Rd>, <Dn[x]>
   (Scalar to ARM register.)
     7. VMOV<c><q> <Rd>, <Rn>, <Dm>
   (Vector to two ARM registers.)
  
   We should have just enough information to be able to disambiguate most of
   these, apart from "Two ARM registers to vector" and "Vector to two ARM
   registers" cases. For these, abuse the .regisimm operand field to signify a
   Neon register.
   
   All the encoded bits are hardcoded by this function.
   
   FIXME: Some of the checking may be a bit sloppy (in a couple of cases you
   can specify a type where it doesn't make sense to, and is ignored).
*/

static void
do_neon_mov (void)
{
  int nargs = inst.operands[0].present + inst.operands[1].present
              + inst.operands[2].present;
  unsigned save_cond = thumb_mode ? 0xe0000000 : inst.instruction & 0xf0000000;

  switch (nargs)
    {
    case 2:
      /* Cases 0, 1, 2, 3, 4, 6.  */
      if (inst.operands[1].isscalar)
        {
          /* Case 6.  */
          struct neon_type_el et = neon_check_type (1, NS_IGNORE,
            N_S8 | N_S16 | N_U8 | N_U16 | N_32);
          unsigned logsize = neon_logbits (et.size);
          unsigned dn = inst.operands[1].reg >> 3;
          unsigned x = inst.operands[1].reg & 7;
          unsigned abcdebits = 0;

          constraint (x >= 64 / et.size, _("scalar index out of range"));

          switch (et.size)
            {
            case 8:  abcdebits = (et.type == NT_signed) ? 0x08 : 0x18; break;
            case 16: abcdebits = (et.type == NT_signed) ? 0x01 : 0x11; break;
            case 32: abcdebits = 0x00; break;
            default: ;
            }

          abcdebits |= x << logsize;
          inst.instruction = save_cond;
          inst.instruction |= 0xe100b10;
          inst.instruction |= LOW4 (dn) << 16;
          inst.instruction |= HI1 (dn) << 7;
          inst.instruction |= inst.operands[0].reg << 12;
          inst.instruction |= (abcdebits & 3) << 5;
          inst.instruction |= (abcdebits >> 2) << 21;
        }
      else if (inst.operands[1].isreg)
        {
          /* Cases 0, 1, 4.  */
          if (inst.operands[0].isscalar)
            {
              /* Case 4.  */
              unsigned bcdebits = 0;
              struct neon_type_el et = neon_check_type (1, NS_IGNORE,
                                                        N_8 | N_16 | N_32);
              int logsize = neon_logbits (et.size);
              unsigned dn = inst.operands[0].reg >> 3;
              unsigned x = inst.operands[0].reg & 7;

              constraint (x >= 64 / et.size, _("scalar index out of range"));

              switch (et.size)
                {
                case 8:  bcdebits = 0x8; break;
                case 16: bcdebits = 0x1; break;
                case 32: bcdebits = 0x0; break;
                default: ;
                }

              bcdebits |= x << logsize;
              inst.instruction = save_cond;
              inst.instruction |= 0xe000b10;
              inst.instruction |= LOW4 (dn) << 16;
              inst.instruction |= HI1 (dn) << 7;
              inst.instruction |= inst.operands[1].reg << 12;
              inst.instruction |= (bcdebits & 3) << 5;
              inst.instruction |= (bcdebits >> 2) << 21;
            }
          else
            {
              /* Cases 0, 1.  */
              enum neon_shape rs = neon_check_shape (NS_DD_QQ);
              /* The architecture manual I have doesn't explicitly state which
                 value the U bit should have for register->register moves, but
                 the equivalent VORR instruction has U = 0, so do that.  */
              inst.instruction = 0x0200110;
              inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
              inst.instruction |= HI1 (inst.operands[0].reg) << 22;
              inst.instruction |= LOW4 (inst.operands[1].reg);
              inst.instruction |= HI1 (inst.operands[1].reg) << 5;
              inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
              inst.instruction |= HI1 (inst.operands[1].reg) << 7;
              inst.instruction |= (rs == NS_QQ) << 6;
              
              inst.instruction = neon_dp_fixup (inst.instruction);
            }
        }
      else
        {
          /* Cases 2, 3.  */
          inst.instruction = 0x0800010;
          neon_move_immediate ();
          inst.instruction = neon_dp_fixup (inst.instruction);
        }
      break;
    
    case 3:
      /* Cases 5, 7.  */
      if (inst.operands[0].regisimm)
        {
          /* Case 5.  */
          inst.instruction = save_cond;
          inst.instruction |= 0xc400b10;
          inst.instruction |= LOW4 (inst.operands[0].reg);
          inst.instruction |= HI1 (inst.operands[0].reg) << 5;
          inst.instruction |= inst.operands[1].reg << 12;
          inst.instruction |= inst.operands[2].reg << 16;
        }
      else
        {
          /* Case 7.  */
          inst.instruction = save_cond;
          inst.instruction |= 0xc500b10;
          inst.instruction |= inst.operands[0].reg << 12;
          inst.instruction |= inst.operands[1].reg << 16;
          inst.instruction |= LOW4 (inst.operands[2].reg);
          inst.instruction |= HI1 (inst.operands[2].reg) << 5;
        }
      break;
    
    default:
      abort ();
    }
}

static void
do_neon_rshift_round_imm (void)
{
  enum neon_shape rs = neon_check_shape (NS_DDI_QQI);
  struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_ALL | N_KEY);
  int imm = inst.operands[2].imm;

  /* imm == 0 case is encoded as VMOV for V{R}SHR.  */
  if (imm == 0)
    {
      inst.operands[2].present = 0;
      do_neon_mov ();
      return;
    }

  constraint (imm < 1 || (unsigned)imm > et.size,
              _("immediate out of range for shift"));
  neon_imm_shift (TRUE, et.type == NT_unsigned, rs == NS_QQI, et,
                  et.size - imm);
}

static void
do_neon_movl (void)
{
  struct neon_type_el et = neon_check_type (2, NS_QD,
    N_EQK | N_DBL, N_SU_32 | N_KEY);
  unsigned sizebits = et.size >> 3;
  inst.instruction |= sizebits << 19;
  neon_two_same (0, et.type == NT_unsigned, -1);
}

static void
do_neon_trn (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_KEY);
  inst.instruction = NEON_ENC_INTEGER (inst.instruction);
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_zip_uzp (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_8 | N_16 | N_32 | N_KEY);
  if (rs == NS_DD && et.size == 32)
    {
      /* Special case: encode as VTRN.32 <Dd>, <Dm>.  */
      inst.instruction = N_MNEM_vtrn;
      do_neon_trn ();
      return;
    }
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_sat_abs_neg (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_S8 | N_S16 | N_S32 | N_KEY);
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_pair_long (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_32 | N_KEY);
  /* Unsigned is encoded in OP field (bit 7) for these instruction.  */
  inst.instruction |= (et.type == NT_unsigned) << 7;
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_recip_est (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK | N_FLT, N_F32 | N_U32 | N_KEY);
  inst.instruction |= (et.type == NT_float) << 8;
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_cls (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_S8 | N_S16 | N_S32 | N_KEY);
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_clz (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK, N_I8 | N_I16 | N_I32 | N_KEY);
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_cnt (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  struct neon_type_el et = neon_check_type (2, rs,
    N_EQK | N_INT, N_8 | N_KEY);
  neon_two_same (rs == NS_QQ, 1, et.size);
}

static void
do_neon_swp (void)
{
  enum neon_shape rs = neon_check_shape (NS_DD_QQ);
  neon_two_same (rs == NS_QQ, 1, -1);
}

static void
do_neon_tbl_tbx (void)
{
  unsigned listlenbits;
  neon_check_type (1, NS_DLD, N_8);
  
  if (inst.operands[1].imm < 1 || inst.operands[1].imm > 4)
    {
      inst.error = _("bad list length for table lookup");
      return;
    }
  
  listlenbits = inst.operands[1].imm - 1;
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= listlenbits << 8;
  
  inst.instruction = neon_dp_fixup (inst.instruction);
}

static void
do_neon_ldm_stm (void)
{
  /* P, U and L bits are part of bitmask.  */
  int is_dbmode = (inst.instruction & (1 << 24)) != 0;
  unsigned offsetbits = inst.operands[1].imm * 2;

  constraint (is_dbmode && !inst.operands[0].writeback,
              _("writeback (!) must be used for VLDMDB and VSTMDB"));

  constraint (inst.operands[1].imm < 1 || inst.operands[1].imm > 16,
              _("register list must contain at least 1 and at most 16 "
                "registers"));

  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[0].writeback << 21;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 12;
  inst.instruction |= HI1 (inst.operands[1].reg) << 22;

  inst.instruction |= offsetbits;
  
  if (thumb_mode)
    inst.instruction |= 0xe0000000;
}

static void
do_neon_ldr_str (void)
{
  unsigned offsetbits;
  int offset_up = 1;
  int is_ldr = (inst.instruction & (1 << 20)) != 0;
  
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  
  constraint (inst.reloc.pc_rel && !is_ldr,
              _("PC-relative addressing unavailable with VSTR"));
  
  constraint (!inst.reloc.pc_rel && inst.reloc.exp.X_op != O_constant,
              _("Immediate value must be a constant"));
  
  if (inst.reloc.exp.X_add_number < 0)
    {
      offset_up = 0;
      offsetbits = -inst.reloc.exp.X_add_number / 4;
    }
  else
    offsetbits = inst.reloc.exp.X_add_number / 4;
  
  /* FIXME: Does this catch everything?  */
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
              || inst.operands[1].postind || inst.operands[1].writeback
              || inst.operands[1].immisreg || inst.operands[1].shifted,
              BAD_ADDR_MODE);
  constraint ((inst.operands[1].imm & 3) != 0,
              _("Offset must be a multiple of 4"));
  constraint (offsetbits != (offsetbits & 0xff),
              _("Immediate offset out of range"));

  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= offsetbits & 0xff;
  inst.instruction |= offset_up << 23;
  
  if (thumb_mode)
    inst.instruction |= 0xe0000000;

  if (inst.reloc.pc_rel)
    {
      if (thumb_mode)
        inst.reloc.type = BFD_RELOC_ARM_T32_CP_OFF_IMM;
      else
        inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
    }
  else
    inst.reloc.type = BFD_RELOC_UNUSED;
}

/* "interleave" version also handles non-interleaving register VLD1/VST1
   instructions.  */

static void
do_neon_ld_st_interleave (void)
{
  struct neon_type_el et = neon_check_type (1, NS_IGNORE,
                                            N_8 | N_16 | N_32 | N_64);
  unsigned alignbits = 0;
  unsigned idx;
  /* The bits in this table go:
     0: register stride of one (0) or two (1)
     1,2: register list length, minus one (1, 2, 3, 4).
     3,4: <n> in instruction type, minus one (VLD<n> / VST<n>).
     We use -1 for invalid entries.  */
  const int typetable[] =
    {
      0x7,  -1, 0xa,  -1, 0x6,  -1, 0x2,  -1, /* VLD1 / VST1.  */
       -1,  -1, 0x8, 0x9,  -1,  -1, 0x3,  -1, /* VLD2 / VST2.  */
       -1,  -1,  -1,  -1, 0x4, 0x5,  -1,  -1, /* VLD3 / VST3.  */
       -1,  -1,  -1,  -1,  -1,  -1, 0x0, 0x1  /* VLD4 / VST4.  */
    };
  int typebits;

  if (inst.operands[1].immisalign)
    switch (inst.operands[1].imm >> 8)
      {
      case 64: alignbits = 1; break;
      case 128:
        if (NEON_REGLIST_LENGTH (inst.operands[0].imm) == 3)
          goto bad_alignment;
        alignbits = 2;
        break;
      case 256:
        if (NEON_REGLIST_LENGTH (inst.operands[0].imm) == 3)
          goto bad_alignment;
        alignbits = 3;
        break;
      default:
      bad_alignment:
        inst.error = _("bad alignment");
        return;
      }

  inst.instruction |= alignbits << 4;
  inst.instruction |= neon_logbits (et.size) << 6;

  /* Bits [4:6] of the immediate in a list specifier encode register stride
     (minus 1) in bit 4, and list length in bits [5:6]. We put the <n> of
     VLD<n>/VST<n> in bits [9:8] of the initial bitmask. Suck it out here, look
     up the right value for "type" in a table based on this value and the given
     list style, then stick it back.  */
  idx = ((inst.operands[0].imm >> 4) & 7)
        | (((inst.instruction >> 8) & 3) << 3);

  typebits = typetable[idx];
  
  constraint (typebits == -1, _("bad list type for instruction"));

  inst.instruction &= ~0xf00;
  inst.instruction |= typebits << 8;
}

/* Check alignment is valid for do_neon_ld_st_lane and do_neon_ld_dup.
   *DO_ALIGN is set to 1 if the relevant alignment bit should be set, 0
   otherwise. The variable arguments are a list of pairs of legal (size, align)
   values, terminated with -1.  */

static int
neon_alignment_bit (int size, int align, int *do_align, ...)
{
  va_list ap;
  int result = FAIL, thissize, thisalign;
    
  if (!inst.operands[1].immisalign)
    {
      *do_align = 0;
      return SUCCESS;
    }
      
  va_start (ap, do_align);

  do
    {
      thissize = va_arg (ap, int);
      if (thissize == -1)
        break;
      thisalign = va_arg (ap, int);

      if (size == thissize && align == thisalign)
        result = SUCCESS;
    }
  while (result != SUCCESS);

  va_end (ap);

  if (result == SUCCESS)
    *do_align = 1;
  else
    inst.error = _("unsupported alignment for instruction");
    
  return result;
}

static void
do_neon_ld_st_lane (void)
{
  struct neon_type_el et = neon_check_type (1, NS_IGNORE, N_8 | N_16 | N_32);
  int align_good, do_align = 0;
  int logsize = neon_logbits (et.size);
  int align = inst.operands[1].imm >> 8;
  int n = (inst.instruction >> 8) & 3;
  int max_el = 64 / et.size;
  
  constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != n + 1,
              _("bad list length"));
  constraint (NEON_LANE (inst.operands[0].imm) >= max_el,
              _("scalar index out of range"));
  constraint (n != 0 && NEON_REG_STRIDE (inst.operands[0].imm) == 2
              && et.size == 8,
              _("stride of 2 unavailable when element size is 8"));
  
  switch (n)
    {
    case 0:  /* VLD1 / VST1.  */
      align_good = neon_alignment_bit (et.size, align, &do_align, 16, 16,
                                       32, 32, -1);
      if (align_good == FAIL)
        return;
      if (do_align)
        {
          unsigned alignbits = 0;
          switch (et.size)
            {
            case 16: alignbits = 0x1; break;
            case 32: alignbits = 0x3; break;
            default: ;
            }
          inst.instruction |= alignbits << 4;
        }
      break;

    case 1:  /* VLD2 / VST2.  */
      align_good = neon_alignment_bit (et.size, align, &do_align, 8, 16, 16, 32,
                                       32, 64, -1);
      if (align_good == FAIL)
        return;
      if (do_align)
        inst.instruction |= 1 << 4;
      break;

    case 2:  /* VLD3 / VST3.  */
      constraint (inst.operands[1].immisalign,
                  _("can't use alignment with this instruction"));
      break;

    case 3:  /* VLD4 / VST4.  */
      align_good = neon_alignment_bit (et.size, align, &do_align, 8, 32,
                                       16, 64, 32, 64, 32, 128, -1);
      if (align_good == FAIL)
        return;
      if (do_align)
        {
          unsigned alignbits = 0;
          switch (et.size)
            {
            case 8:  alignbits = 0x1; break;
            case 16: alignbits = 0x1; break;
            case 32: alignbits = (align == 64) ? 0x1 : 0x2; break;
            default: ;
            }
          inst.instruction |= alignbits << 4;
        }
      break;

    default: ;
    }

  /* Reg stride of 2 is encoded in bit 5 when size==16, bit 6 when size==32.  */
  if (n != 0 && NEON_REG_STRIDE (inst.operands[0].imm) == 2)
    inst.instruction |= 1 << (4 + logsize);
      
  inst.instruction |= NEON_LANE (inst.operands[0].imm) << (logsize + 5);
  inst.instruction |= logsize << 10;
}

/* Encode single n-element structure to all lanes VLD<n> instructions.  */

static void
do_neon_ld_dup (void)
{
  struct neon_type_el et = neon_check_type (1, NS_IGNORE, N_8 | N_16 | N_32);
  int align_good, do_align = 0;

  switch ((inst.instruction >> 8) & 3)
    {
    case 0:  /* VLD1.  */
      assert (NEON_REG_STRIDE (inst.operands[0].imm) != 2);
      align_good = neon_alignment_bit (et.size, inst.operands[1].imm >> 8,
                                       &do_align, 16, 16, 32, 32, -1);
      if (align_good == FAIL)
        return;
      switch (NEON_REGLIST_LENGTH (inst.operands[0].imm))
        {
        case 1: break;
        case 2: inst.instruction |= 1 << 5; break;
        default: inst.error = _("bad list length"); return;
        }
      inst.instruction |= neon_logbits (et.size) << 6;
      break;

    case 1:  /* VLD2.  */
      align_good = neon_alignment_bit (et.size, inst.operands[1].imm >> 8,
                                       &do_align, 8, 16, 16, 32, 32, 64, -1);
      if (align_good == FAIL)
        return;
      constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 2,
                  _("bad list length"));
      if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
        inst.instruction |= 1 << 5;
      inst.instruction |= neon_logbits (et.size) << 6;
      break;

    case 2:  /* VLD3.  */
      constraint (inst.operands[1].immisalign,
                  _("can't use alignment with this instruction"));
      constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 3,
                  _("bad list length"));
      if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
        inst.instruction |= 1 << 5;
      inst.instruction |= neon_logbits (et.size) << 6;
      break;

    case 3:  /* VLD4.  */
      {
        int align = inst.operands[1].imm >> 8;
        align_good = neon_alignment_bit (et.size, align, &do_align, 8, 32,
                                         16, 64, 32, 64, 32, 128, -1);
        if (align_good == FAIL)
          return;
        constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4,
                    _("bad list length"));
        if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
          inst.instruction |= 1 << 5;
        if (et.size == 32 && align == 128)
          inst.instruction |= 0x3 << 6;
        else
          inst.instruction |= neon_logbits (et.size) << 6;
      }
      break;

    default: ;
    }

  inst.instruction |= do_align << 4;
}

/* Disambiguate VLD<n> and VST<n> instructions, and fill in common bits (those
   apart from bits [11:4].  */

static void
do_neon_ldx_stx (void)
{
  switch (NEON_LANE (inst.operands[0].imm))
    {
    case NEON_INTERLEAVE_LANES:
      inst.instruction = NEON_ENC_INTERLV (inst.instruction);
      do_neon_ld_st_interleave ();
      break;
    
    case NEON_ALL_LANES:
      inst.instruction = NEON_ENC_DUP (inst.instruction);
      do_neon_ld_dup ();
      break;
    
    default:
      inst.instruction = NEON_ENC_LANE (inst.instruction);
      do_neon_ld_st_lane ();
    }

  /* L bit comes from bit mask.  */
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= inst.operands[1].reg << 16;
  
  if (inst.operands[1].postind)
    {
      int postreg = inst.operands[1].imm & 0xf;
      constraint (!inst.operands[1].immisreg,
                  _("post-index must be a register"));
      constraint (postreg == 0xd || postreg == 0xf,
                  _("bad register for post-index"));
      inst.instruction |= postreg;
    }
  else if (inst.operands[1].writeback)
    {
      inst.instruction |= 0xd;
    }
  else
    inst.instruction |= 0xf; 
  
  if (thumb_mode)
    inst.instruction |= 0xf9000000;
  else
    inst.instruction |= 0xf4000000;
}


/* Overall per-instruction processing.	*/

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.	We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */

static void
fix_new_arm (fragS *	   frag,
	     int	   where,
	     short int	   size,
	     expressionS * exp,
	     int	   pc_rel,
	     int	   reloc)
{
  fixS *	   new_fix;

  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;

    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
    }

  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  new_fix->tc_fix_data = thumb_mode;
}

/* Create a frg for an instruction requiring relaxation.  */
static void
output_relax_insn (void)
{
  char * to;
a8125 79
/* Parse a Neon type specifier. *STR should point at the leading '.'
   character. Does no verification at this stage that the type fits the opcode
   properly. E.g.,

     .i32.i32.s16
     .s32.f32
     .u16

   Can all be legally parsed by this function.

   Fills in neon_type struct pointer with parsed information, and updates STR
   to point after the parsed type specifier. Returns TRUE if this was a legal
   type, FALSE if not.  */

static bfd_boolean
parse_neon_type (struct neon_type *type, char **str)
{
  char *ptr = *str;

  if (type)
    type->elems = 0;

  while (type->elems < NEON_MAX_TYPE_ELS)
    {
      enum neon_el_type thistype = NT_untyped;
      unsigned thissize = -1u;

      if (*ptr != '.')
	break;

      ptr++;

      /* Just a size without an explicit type.  */
      if (ISDIGIT (*ptr))
	goto parsesize;

      switch (*ptr)
	{
	case 'i': thistype = NT_integer; break;
	case 'f': thistype = NT_float; break;
	case 'p': thistype = NT_poly; break;
	case 's': thistype = NT_signed; break;
	case 'u': thistype = NT_unsigned; break;
	default:
	  as_bad (_("Unexpected character `%c' in type specifier"), *ptr);
	  return 0;
	}

      ptr++;

      /* .f is an abbreviation for .f32.  */
      if (thistype == NT_float && !ISDIGIT (*ptr))
	thissize = 32;
      else
	{
	parsesize:
	  thissize = strtoul (ptr, &ptr, 10);

	  if (thissize != 8 && thissize != 16 && thissize != 32
              && thissize != 64)
            {
              as_bad (_("Bad size %d in type specifier"), thissize);
	      return 0;
	    }
	}

      if (type)
        {
          type->el[type->elems].type = thistype;
	  type->el[type->elems].size = thissize;
	  type->elems++;
	}
    }

  *str = ptr;

  return 1;
}

d8225 1
a8225 1
  /* Handle a possible width suffix and/or Neon type suffix.  */
d8228 1
a8228 3
      int offset = 2;
      
      if (end[1] == 'w')
d8230 1
a8230 1
      else if (end[1] == 'n')
d8233 1
a8233 1
        offset = 0;
d8235 1
a8235 12
      inst.vectype.elems = 0;

      *str = end + offset;

      if (end[offset] == '.')      
	{
	  /* See if we have a Neon type suffix.  */
          if (!parse_neon_type (&inst.vectype, str))
	    return 0;
        }
      else if (end[offset] != '\0' && end[offset] != ' ')
        return 0;
a8578 1
#define REGNUM2(p,n,t) REGDEF(p##n, 2 * n, t)
a8583 10
#define REGSETH(p,t) \
  REGNUM(p,16,t), REGNUM(p,17,t), REGNUM(p,18,t), REGNUM(p,19,t), \
  REGNUM(p,20,t), REGNUM(p,21,t), REGNUM(p,22,t), REGNUM(p,23,t), \
  REGNUM(p,24,t), REGNUM(p,25,t), REGNUM(p,26,t), REGNUM(p,27,t), \
  REGNUM(p,28,t), REGNUM(p,29,t), REGNUM(p,30,t), REGNUM(p,31,t)
#define REGSET2(p,t) \
  REGNUM2(p, 0,t), REGNUM2(p, 1,t), REGNUM2(p, 2,t), REGNUM2(p, 3,t), \
  REGNUM2(p, 4,t), REGNUM2(p, 5,t), REGNUM2(p, 6,t), REGNUM2(p, 7,t), \
  REGNUM2(p, 8,t), REGNUM2(p, 9,t), REGNUM2(p,10,t), REGNUM2(p,11,t), \
  REGNUM2(p,12,t), REGNUM2(p,13,t), REGNUM2(p,14,t), REGNUM2(p,15,t)
d8622 11
a8632 2
  REGSET(s,VFS),  REGSET(S,VFS),
  REGSETH(s,VFS), REGSETH(S,VFS),
d8635 1
a8635 6
  REGSET(d,VFD),  REGSET(D,VFD),
  /* Extra Neon DP registers.  */
  REGSETH(d,VFD), REGSETH(D,VFD),

  /* Neon QP registers.  */
  REGSET2(q,NQ),  REGSET2(Q,NQ),
a8973 24
/* Neon data-processing. ARM versions are unconditional with cond=0xf.
   The Thumb and ARM variants are mostly the same (bits 0-23 and 24/28), so we
   use the same encoding function for each.  */
#define NUF(mnem, op, nops, ops, enc)					\
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##op,		\
    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }

/* Neon data processing, version which indirects through neon_enc_tab for
   the various overloaded versions of opcodes.  */
#define nUF(mnem, op, nops, ops, enc)					\
  { #mnem, OPS##nops ops, OT_unconditionalF, N_MNEM_##op, N_MNEM_##op,	\
    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }

/* Neon insn with conditional suffix for the ARM version, non-overloaded
   version.  */
#define NCE(mnem, op, nops, ops, enc)					\
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x##op, ARM_VARIANT,	\
    THUMB_VARIANT, do_##enc, do_##enc }

/* Neon insn with conditional suffix for the ARM version, overloaded types.  */
#define nCE(mnem, op, nops, ops, enc)					\
  { #mnem, OPS##nops ops, OT_csuffix, N_MNEM_##op, N_MNEM_##op,		\
    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }

d9914 1
a9914 1
 cCE(fcpyd,	eb00b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
d9917 4
a9920 4
 cCE(fmdhr,	e200b10, 2, (RVD, RR),	      vfp_dp_rn_rd),
 cCE(fmdlr,	e000b10, 2, (RVD, RR),	      vfp_dp_rn_rd),
 cCE(fmrdh,	e300b10, 2, (RR, RVD),	      vfp_dp_rd_rn),
 cCE(fmrdl,	e100b10, 2, (RR, RVD),	      vfp_dp_rd_rn),
d9941 3
a9943 3
 cCE(fabsd,	eb00bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fnegd,	eb10b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fsqrtd,	eb10bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
d9946 9
a9954 9
 cCE(faddd,	e300b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fsubd,	e300b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fmuld,	e200b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fdivd,	e800b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fmacd,	e000b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fmscd,	e100b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fnmuld,	e200b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fnmacd,	e000b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
 cCE(fnmscd,	e100b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
d9957 4
a9960 4
 cCE(fcmpd,	eb40b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fcmpzd,	eb50b40, 1, (RVD),	      vfp_dp_rd),
 cCE(fcmped,	eb40bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
 cCE(fcmpezd,	eb50bc0, 1, (RVD),	      vfp_dp_rd),
d9966 2
a9967 250
 cCE(fmdrr,	c400b10, 3, (RVD, RR, RR),    vfp_dp_rm_rd_rn),
 cCE(fmrrd,	c500b10, 3, (RR, RR, RVD),    vfp_dp_rd_rn_rm),

#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_neon_ext_v1
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_neon_ext_v1
  /* Data processing with three registers of the same length.  */
  /* integer ops, valid types S8 S16 S32 U8 U16 U32.  */
 NUF(vaba,      0000710, 3, (RNDQ, RNDQ,  RNDQ), neon_dyadic_i_su),
 NUF(vabaq,     0000710, 3, (RNQ,  RNQ,   RNQ),  neon_dyadic_i_su),
 NUF(vhadd,     0000000, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
 NUF(vhaddq,    0000000, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
 NUF(vrhadd,    0000100, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
 NUF(vrhaddq,   0000100, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
 NUF(vhsub,     0000200, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
 NUF(vhsubq,    0000200, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
  /* integer ops, valid types S8 S16 S32 S64 U8 U16 U32 U64.  */
 NUF(vqadd,     0000010, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
 NUF(vqaddq,    0000010, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
 NUF(vqsub,     0000210, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
 NUF(vqsubq,    0000210, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
 NUF(vrshl,     0000500, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
 NUF(vrshlq,    0000500, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
 NUF(vqrshl,    0000510, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
 NUF(vqrshlq,   0000510, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
  /* If not immediate, fall back to neon_dyadic_i64_su.
     shl_imm should accept I8 I16 I32 I64,
     qshl_imm should accept S8 S16 S32 S64 U8 U16 U32 U64.  */
 nUF(vshl,      vshl,    3, (RNDQ, oRNDQ, RNDQ_I63b), neon_shl_imm),
 nUF(vshlq,     vshl,    3, (RNQ,  oRNQ,  RNDQ_I63b), neon_shl_imm),
 nUF(vqshl,     vqshl,   3, (RNDQ, oRNDQ, RNDQ_I63b), neon_qshl_imm),
 nUF(vqshlq,    vqshl,   3, (RNQ,  oRNQ,  RNDQ_I63b), neon_qshl_imm),
  /* Logic ops, types optional & ignored.  */
 nUF(vand,      vand,    2, (RNDQ, NILO),        neon_logic),
 nUF(vandq,     vand,    2, (RNQ,  NILO),        neon_logic),
 nUF(vbic,      vbic,    2, (RNDQ, NILO),        neon_logic),
 nUF(vbicq,     vbic,    2, (RNQ,  NILO),        neon_logic),
 nUF(vorr,      vorr,    2, (RNDQ, NILO),        neon_logic),
 nUF(vorrq,     vorr,    2, (RNQ,  NILO),        neon_logic),
 nUF(vorn,      vorn,    2, (RNDQ, NILO),        neon_logic),
 nUF(vornq,     vorn,    2, (RNQ,  NILO),        neon_logic),
 nUF(veor,      veor,    3, (RNDQ, oRNDQ, RNDQ), neon_logic),
 nUF(veorq,     veor,    3, (RNQ,  oRNQ,  RNQ),  neon_logic),
  /* Bitfield ops, untyped.  */
 NUF(vbsl,      1100110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
 NUF(vbslq,     1100110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
 NUF(vbit,      1200110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
 NUF(vbitq,     1200110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
 NUF(vbif,      1300110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
 NUF(vbifq,     1300110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
  /* Int and float variants, types S8 S16 S32 U8 U16 U32 F32.  */
 nUF(vabd,      vabd,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vabdq,     vabd,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
 nUF(vmax,      vmax,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vmaxq,     vmax,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
 nUF(vmin,      vmin,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
 nUF(vminq,     vmin,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
  /* Comparisons. Types S8 S16 S32 U8 U16 U32 F32. Non-immediate versions fall
     back to neon_dyadic_if_su.  */
 nUF(vcge,      vcge,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp),
 nUF(vcgeq,     vcge,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp),
 nUF(vcgt,      vcgt,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp),
 nUF(vcgtq,     vcgt,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp),
 nUF(vclt,      vclt,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp_inv),
 nUF(vcltq,     vclt,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp_inv),
 nUF(vcle,      vcle,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp_inv),
 nUF(vcleq,     vcle,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp_inv),
  /* Comparison. Type I8 I16 I32 F32. Non-immediate -> neon_dyadic_if_i.  */
 nUF(vceq,      vceq,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_ceq),
 nUF(vceqq,     vceq,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_ceq),
  /* As above, D registers only.  */
 nUF(vpmax,     vpmax,   3, (RND, oRND, RND), neon_dyadic_if_su_d),
 nUF(vpmin,     vpmin,   3, (RND, oRND, RND), neon_dyadic_if_su_d),
  /* Int and float variants, signedness unimportant.  */
  /* If not scalar, fall back to neon_dyadic_if_i.  */
 nUF(vmla,      vmla,    3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_mac_maybe_scalar),
 nUF(vmlaq,     vmla,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
 nUF(vmls,      vmls,    3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_mac_maybe_scalar),
 nUF(vmlsq,     vmls,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
 nUF(vpadd,     vpadd,   3, (RND,  oRND,  RND),       neon_dyadic_if_i_d),
  /* Add/sub take types I8 I16 I32 I64 F32.  */
 nUF(vadd,      vadd,    3, (RNDQ, oRNDQ, RNDQ), neon_addsub_if_i),
 nUF(vaddq,     vadd,    3, (RNQ,  oRNQ,  RNQ),  neon_addsub_if_i),
 nUF(vsub,      vsub,    3, (RNDQ, oRNDQ, RNDQ), neon_addsub_if_i),
 nUF(vsubq,     vsub,    3, (RNQ,  oRNQ,  RNQ),  neon_addsub_if_i),
  /* vtst takes sizes 8, 16, 32.  */
 NUF(vtst,      0000810, 3, (RNDQ, oRNDQ, RNDQ), neon_tst),
 NUF(vtstq,     0000810, 3, (RNQ,  oRNQ,  RNQ),  neon_tst),
  /* VMUL takes I8 I16 I32 F32 P8.  */
 nUF(vmul,      vmul,    3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_mul),
 nUF(vmulq,     vmul,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mul),
  /* VQD{R}MULH takes S16 S32.  */
 nUF(vqdmulh,   vqdmulh,  3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
 nUF(vqdmulhq,  vqdmulh,  3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
 nUF(vqrdmulh,  vqrdmulh, 3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
 nUF(vqrdmulhq, vqrdmulh, 3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
 NUF(vacge,     0000e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute),
 NUF(vacgeq,    0000e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute),
 NUF(vacgt,     0200e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute),
 NUF(vacgtq,    0200e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute),
 NUF(vaclt,     0000e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
 NUF(vacltq,    0000e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
 NUF(vacle,     0200e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
 NUF(vacleq,    0200e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
 NUF(vrecps,    0000f10,  3, (RNDQ, oRNDQ, RNDQ), neon_step),
 NUF(vrecpsq,   0000f10,  3, (RNQ,  oRNQ,  RNQ),  neon_step),
 NUF(vrsqrts,   0200f10,  3, (RNDQ, oRNDQ, RNDQ), neon_step),
 NUF(vrsqrtsq,  0200f10,  3, (RNQ,  oRNQ,  RNQ),  neon_step),

  /* Two address, int/float. Types S8 S16 S32 F32.  */
 NUF(vabs,      1b10300, 2, (RNDQ, RNDQ),     neon_abs_neg),
 NUF(vabsq,     1b10300, 2, (RNQ,  RNQ),      neon_abs_neg),
 NUF(vneg,      1b10380, 2, (RNDQ, RNDQ),     neon_abs_neg),
 NUF(vnegq,     1b10380, 2, (RNQ,  RNQ),      neon_abs_neg),

  /* Data processing with two registers and a shift amount.  */
  /* Right shifts, and variants with rounding.
     Types accepted S8 S16 S32 S64 U8 U16 U32 U64.  */
 NUF(vshr,      0800010, 3, (RNDQ, oRNDQ, I64z), neon_rshift_round_imm),
 NUF(vshrq,     0800010, 3, (RNQ,  oRNQ,  I64z), neon_rshift_round_imm),
 NUF(vrshr,     0800210, 3, (RNDQ, oRNDQ, I64z), neon_rshift_round_imm),
 NUF(vrshrq,    0800210, 3, (RNQ,  oRNQ,  I64z), neon_rshift_round_imm),
 NUF(vsra,      0800110, 3, (RNDQ, oRNDQ, I64),  neon_rshift_round_imm),
 NUF(vsraq,     0800110, 3, (RNQ,  oRNQ,  I64),  neon_rshift_round_imm),
 NUF(vrsra,     0800310, 3, (RNDQ, oRNDQ, I64),  neon_rshift_round_imm),
 NUF(vrsraq,    0800310, 3, (RNQ,  oRNQ,  I64),  neon_rshift_round_imm),
  /* Shift and insert. Sizes accepted 8 16 32 64.  */
 NUF(vsli,      1800510, 3, (RNDQ, oRNDQ, I63), neon_sli),
 NUF(vsliq,     1800510, 3, (RNQ,  oRNQ,  I63), neon_sli),
 NUF(vsri,      1800410, 3, (RNDQ, oRNDQ, I64), neon_sri),
 NUF(vsriq,     1800410, 3, (RNQ,  oRNQ,  I64), neon_sri),
  /* QSHL{U} immediate accepts S8 S16 S32 S64 U8 U16 U32 U64.  */
 NUF(vqshlu,    1800610, 3, (RNDQ, oRNDQ, I63), neon_qshlu_imm),
 NUF(vqshluq,   1800610, 3, (RNQ,  oRNQ,  I63), neon_qshlu_imm),
  /* Right shift immediate, saturating & narrowing, with rounding variants.
     Types accepted S16 S32 S64 U16 U32 U64.  */
 NUF(vqshrn,    0800910, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow),
 NUF(vqrshrn,   0800950, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow),
  /* As above, unsigned. Types accepted S16 S32 S64.  */
 NUF(vqshrun,   0800810, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow_u),
 NUF(vqrshrun,  0800850, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow_u),
  /* Right shift narrowing. Types accepted I16 I32 I64.  */
 NUF(vshrn,     0800810, 3, (RND, RNQ, I32z), neon_rshift_narrow),
 NUF(vrshrn,    0800850, 3, (RND, RNQ, I32z), neon_rshift_narrow),
  /* Special case. Types S8 S16 S32 U8 U16 U32. Handles max shift variant.  */
 nUF(vshll,     vshll,   3, (RNQ, RND, I32),  neon_shll),
  /* CVT with optional immediate for fixed-point variant.  */
 nUF(vcvt,      vcvt,    3, (RNDQ, RNDQ, oI32b), neon_cvt),
 nUF(vcvtq,     vcvt,    3, (RNQ,  RNQ,  oI32b), neon_cvt),

  /* One register and an immediate value. All encoding special-cased!  */
 NCE(vmov,      0,       1, (VMOV),             neon_mov),
 NCE(vmovq,     0,       1, (VMOV),             neon_mov),
 nUF(vmvn,      vmvn,    2, (RNDQ, RNDQ_IMVNb), neon_mvn),
 nUF(vmvnq,     vmvn,    2, (RNQ,  RNDQ_IMVNb), neon_mvn),

  /* Data processing, three registers of different lengths.  */
  /* Dyadic, long insns. Types S8 S16 S32 U8 U16 U32.  */
 NUF(vabal,     0800500, 3, (RNQ, RND, RND),  neon_abal),
 NUF(vabdl,     0800700, 3, (RNQ, RND, RND),  neon_dyadic_long),
 NUF(vaddl,     0800000, 3, (RNQ, RND, RND),  neon_dyadic_long),
 NUF(vsubl,     0800200, 3, (RNQ, RND, RND),  neon_dyadic_long),
  /* If not scalar, fall back to neon_dyadic_long.
     Vector types as above, scalar types S16 S32 U16 U32.  */
 nUF(vmlal,     vmlal,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
 nUF(vmlsl,     vmlsl,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
  /* Dyadic, widening insns. Types S8 S16 S32 U8 U16 U32.  */
 NUF(vaddw,     0800100, 3, (RNQ, oRNQ, RND), neon_dyadic_wide),
 NUF(vsubw,     0800300, 3, (RNQ, oRNQ, RND), neon_dyadic_wide),
  /* Dyadic, narrowing insns. Types I16 I32 I64.  */
 NUF(vaddhn,    0800400, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
 NUF(vraddhn,   1800400, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
 NUF(vsubhn,    0800600, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
 NUF(vrsubhn,   1800600, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
  /* Saturating doubling multiplies. Types S16 S32.  */
 nUF(vqdmlal,   vqdmlal, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
 nUF(vqdmlsl,   vqdmlsl, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
 nUF(vqdmull,   vqdmull, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
  /* VMULL. Vector types S8 S16 S32 U8 U16 U32 P8, scalar types
     S16 S32 U16 U32.  */
 nUF(vmull,     vmull,   3, (RNQ, RND, RND_RNSC), neon_vmull),

  /* Extract. Size 8.  */
 NUF(vext,      0b00000, 4, (RNDQ, oRNDQ, RNDQ, I7), neon_ext),
 NUF(vextq,     0b00000, 4, (RNQ,  oRNQ,  RNQ,  I7), neon_ext),

  /* Two registers, miscellaneous.  */
  /* Reverse. Sizes 8 16 32 (must be < size in opcode).  */
 NUF(vrev64,    1b00000, 2, (RNDQ, RNDQ),     neon_rev),
 NUF(vrev64q,   1b00000, 2, (RNQ,  RNQ),      neon_rev),
 NUF(vrev32,    1b00080, 2, (RNDQ, RNDQ),     neon_rev),
 NUF(vrev32q,   1b00080, 2, (RNQ,  RNQ),      neon_rev),
 NUF(vrev16,    1b00100, 2, (RNDQ, RNDQ),     neon_rev),
 NUF(vrev16q,   1b00100, 2, (RNQ,  RNQ),      neon_rev),
  /* Vector replicate. Sizes 8 16 32.  */
 nCE(vdup,      vdup,    2, (RNDQ, RR_RNSC),  neon_dup),
 nCE(vdupq,     vdup,    2, (RNQ,  RR_RNSC),  neon_dup),
  /* VMOVL. Types S8 S16 S32 U8 U16 U32.  */
 NUF(vmovl,     0800a10, 2, (RNQ, RND),       neon_movl),
  /* VMOVN. Types I16 I32 I64.  */
 nUF(vmovn,     vmovn,   2, (RND, RNQ),       neon_movn),
  /* VQMOVN. Types S16 S32 S64 U16 U32 U64.  */
 nUF(vqmovn,    vqmovn,  2, (RND, RNQ),       neon_qmovn),
  /* VQMOVUN. Types S16 S32 S64.  */
 nUF(vqmovun,   vqmovun, 2, (RND, RNQ),       neon_qmovun),
  /* VZIP / VUZP. Sizes 8 16 32.  */
 NUF(vzip,      1b20180, 2, (RNDQ, RNDQ),     neon_zip_uzp),
 NUF(vzipq,     1b20180, 2, (RNQ,  RNQ),      neon_zip_uzp),
 NUF(vuzp,      1b20100, 2, (RNDQ, RNDQ),     neon_zip_uzp),
 NUF(vuzpq,     1b20100, 2, (RNQ,  RNQ),      neon_zip_uzp),
  /* VQABS / VQNEG. Types S8 S16 S32.  */
 NUF(vqabs,     1b00700, 2, (RNDQ, RNDQ),     neon_sat_abs_neg),
 NUF(vqabsq,    1b00700, 2, (RNQ,  RNQ),      neon_sat_abs_neg),
 NUF(vqneg,     1b00780, 2, (RNDQ, RNDQ),     neon_sat_abs_neg),
 NUF(vqnegq,    1b00780, 2, (RNQ,  RNQ),      neon_sat_abs_neg),
  /* Pairwise, lengthening. Types S8 S16 S32 U8 U16 U32.  */
 NUF(vpadal,    1b00600, 2, (RNDQ, RNDQ),     neon_pair_long),
 NUF(vpadalq,   1b00600, 2, (RNQ,  RNQ),      neon_pair_long),
 NUF(vpaddl,    1b00200, 2, (RNDQ, RNDQ),     neon_pair_long),
 NUF(vpaddlq,   1b00200, 2, (RNQ,  RNQ),      neon_pair_long),
  /* Reciprocal estimates. Types U32 F32.  */
 NUF(vrecpe,    1b30400, 2, (RNDQ, RNDQ),     neon_recip_est),
 NUF(vrecpeq,   1b30400, 2, (RNQ,  RNQ),      neon_recip_est),
 NUF(vrsqrte,   1b30480, 2, (RNDQ, RNDQ),     neon_recip_est),
 NUF(vrsqrteq,  1b30480, 2, (RNQ,  RNQ),      neon_recip_est),
  /* VCLS. Types S8 S16 S32.  */
 NUF(vcls,      1b00400, 2, (RNDQ, RNDQ),     neon_cls),
 NUF(vclsq,     1b00400, 2, (RNQ,  RNQ),      neon_cls),
  /* VCLZ. Types I8 I16 I32.  */
 NUF(vclz,      1b00480, 2, (RNDQ, RNDQ),     neon_clz),
 NUF(vclzq,     1b00480, 2, (RNQ,  RNQ),      neon_clz),
  /* VCNT. Size 8.  */
 NUF(vcnt,      1b00500, 2, (RNDQ, RNDQ),     neon_cnt),
 NUF(vcntq,     1b00500, 2, (RNQ,  RNQ),      neon_cnt),
  /* Two address, untyped.  */
 NUF(vswp,      1b20000, 2, (RNDQ, RNDQ),     neon_swp),
 NUF(vswpq,     1b20000, 2, (RNQ,  RNQ),      neon_swp),
  /* VTRN. Sizes 8 16 32.  */
 nUF(vtrn,      vtrn,    2, (RNDQ, RNDQ),     neon_trn),
 nUF(vtrnq,     vtrn,    2, (RNQ,  RNQ),      neon_trn),

  /* Table lookup. Size 8.  */
 NUF(vtbl,      1b00800, 3, (RND, NRDLST, RND), neon_tbl_tbx),
 NUF(vtbx,      1b00840, 3, (RND, NRDLST, RND), neon_tbl_tbx),

#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_v3_or_neon_ext
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_v3_or_neon_ext
a9968 45
  /* Load/store instructions. Available in Neon or VFPv3.  */
 NCE(vldm,      c900b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vldmia,    c900b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vldmdb,    d100b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vstm,      c800b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vstmia,    c800b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vstmdb,    d000b00, 2, (RRw, NRDLST),    neon_ldm_stm),
 NCE(vldr,      d100b00, 2, (RND, ADDR),      neon_ldr_str),
 NCE(vstr,      d000b00, 2, (RND, ADDR),      neon_ldr_str),

  /* Neon element/structure load/store.  */
 nUF(vld1,      vld1,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst1,      vst1,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld2,      vld2,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst2,      vst2,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld3,      vld3,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst3,      vst3,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vld4,      vld4,    2, (NSTRLST, ADDR),  neon_ldx_stx),
 nUF(vst4,      vst4,    2, (NSTRLST, ADDR),  neon_ldx_stx),

#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_ext_v3
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v3

 cCE(fconsts,   eb00a00, 2, (RVS, I255),      vfp_sp_const),
 cCE(fconstd,   eb00b00, 2, (RVD, I255),      vfp_dp_const),
 cCE(fshtos,    eba0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE(fshtod,    eba0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE(fsltos,    eba0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE(fsltod,    eba0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE(fuhtos,    ebb0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE(fuhtod,    ebb0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE(fultos,    ebb0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE(fultod,    ebb0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE(ftoshs,    ebe0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE(ftoshd,    ebe0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE(ftosls,    ebe0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE(ftosld,    ebe0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
 cCE(ftouhs,    ebf0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
 cCE(ftouhd,    ebf0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
 cCE(ftouls,    ebf0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
 cCE(ftould,    ebf0bc0, 2, (RVD, I32),       vfp_dp_conv_32),

#undef THUMB_VARIANT
a10238 4
#undef NUF
#undef nUF
#undef NCE
#undef nCE
d11150 1
a11150 1
  int reg = arm_reg_parse ((char **) &regname, REG_TYPE_RN, NULL);
d13346 1
a13346 3
  {"cortex-a8",		ARM_ARCH_V7A,	 ARM_FEATURE(0, FPU_VFP_V3
                                                        | FPU_NEON_EXT_V1),
                                                          NULL},
a13435 1
  {"vfp3",              FPU_ARCH_VFP_V3},
a13443 1
  {"neon",              FPU_ARCH_VFP_V3_PLUS_NEON_V1},
d13839 1
a13839 1
    
d13884 2
a13885 5
  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v3)
      || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_v3))
    elf32_arm_add_eabi_attr_int (stdoutput, 10, 3);
  else if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v2)
           || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_v2))
d13887 2
a13888 4
  else if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v1)
           || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_v1)
           || ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_vfp_ext_v1xd)
           || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_vfp_ext_v1xd))
a13893 4
  /* Tag_NEON_arch.  */
  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, fpu_neon_ext_v1)
      || ARM_CPU_HAS_FEATURE (arm_arch_used, fpu_neon_ext_v1))
    elf32_arm_add_eabi_attr_int (stdoutput, 12, 1);
@


1.250.2.9
log
@
	* gas/config/tc-arm.c (neon_el_type): Make NT_invtype be the zero (so
	zero-initialising structures containing it will lead to invalid
	types).
	(arm_it): Add vectype to each operand.
	(NTA_HASTYPE, NTA_HASINDEX): Constants used in neon_typed_alias
	defined field.
	(neon_typed_alias): New structure. Extra information for typed
	register aliases.
	(reg_entry): Add neon type info field.
	(arm_reg_parse): Remove RTYPE argument (revert to previous arguments).
	Break out alternative syntax for coprocessor registers, etc. into...
	(arm_reg_alt_syntax): New function. Alternate syntax handling broken
	out from arm_reg_parse.
	(parse_neon_type): Move. Return SUCCESS/FAIL.
	(first_error): New function. Call to ensure first error which occurs
	is reported.
	(parse_neon_operand_type): Parse exactly one type.
	(NEON_ALL_LANES, NEON_INTERLEAVE_LANES): Move.
	(parse_typed_reg_or_scalar): New function. Handle core of both
	arm_typed_reg_parse and parse_scalar.
	(arm_typed_reg_parse): Parse a register with an optional type.
	(NEON_SCALAR_REG, NEON_SCALAR_INDEX): Extract parts of parse_scalar
	result.
	(parse_scalar): Parse a Neon scalar with optional type.
	(parse_reg_list): Use first_error.
	(parse_vfp_reg_list): Use arm_typed_reg_parse instead of arm_reg_parse.
	(neon_alias_types_same): New function. Return true if two (alias) types
	are the same.
	(parse_neon_el_struct_list): Use parse_typed_reg_or_scalar. Return type
	of elements.
	(insert_reg_alias): Return new reg_entry not void.
	(insert_neon_reg_alias): New function. Insert type/index information as
	well as register for alias.
	(create_neon_reg_alias): New function. Parse .dn/.qn directives and
	make typed register aliases accordingly.
	(s_dn, s_qn): New functions. Handle incorrectly used .dn/.qn at start
	of line.
	(s_unreq): Delete type information if present.
	(s_arm_unwind_save_mmxwr): Remove arg 3 from arm_reg_parse calls.
	(s_arm_unwind_save_mmxwcg): Likewise.
	(s_arm_unwind_movsp): Likewise.
	(s_arm_unwind_setfp): Likewise.
	(parse_shift): Likewise.
	(parse_shifter_operand): Likewise.
	(parse_address): Likewise.
	(parse_tb): Likewise.
	(tc_arm_regname_to_dw2regnum): Likewise.
	(md_pseudo_table): Add dn, qn.
	(parse_neon_mov): Handle typed operands.
	(parse_operands): Likewise.
	(neon_type_mask): Add N_SIZ.
	(N_ALLMODS): New macro.
	(neon_check_shape): Fix typo in NS_DDD_QQQ case. Use first_error.
	(el_type_of_type_chk): Add some safeguards.
	(modify_types_allowed): Fix logic bug.
	(neon_check_type): Handle operands with types.
	(neon_three_same): Remove redundant optional arg handling.
	(do_neon_dyadic_i64_su, do_neon_shl_imm, do_neon_qshl_imm)
	(do_neon_logic, do_neon_qdmulh, do_neon_fcmp_absolute)
	(do_neon_step): Adjust accordingly.
	(neon_cmode_for_logic_imm): Use first_error.
	(do_neon_bitfield): Call neon_check_type.
	(neon_dyadic): Rename to...
	(neon_dyadic_misc): ...this. New name for neon_dyadic. Add bitfield to
	allow modification of type of the destination.
	(do_neon_dyadic_if_su, do_neon_dyadic_if_i, do_neon_dyadic_if_i_d)
	(do_neon_addsub_if_i, do_neon_mul): Adjust accordingly.
	(do_neon_compare): Make destination be an untyped bitfield.
	(neon_scalar_for_mul): Use NEON_SCALAR_REG, NEON_SCALAR_INDEX.
	(neon_mul_mac): Return early in case of errors.
	(neon_move_immediate): Use first_error.
	(neon_mac_reg_scalar_long): Fix type to include scalar.
	(do_neon_dup): Likewise.
	(do_neon_mov): Likewise (in several places).
	(do_neon_tbl_tbx): Fix type.
	(do_neon_ld_st_interleave, neon_alignment_bit, do_neon_ld_st_lane)
	(do_neon_ld_dup): Exit early in case of errors and/or use first_error.
	(opcode_lookup): Update for parse_neon_type returning SUCCESS/FAIL.
	Handle .dn/.qn directives.
	(REGDEF): Add zero for reg_entry neon field.

	* gas/testsuite/gas/arm/neon-psyn.s: Basic test of programmers syntax.
	* gas/testsuite/gas/arm/neon-psyn.d: Expected output of above.
@
text
@a267 1
  NT_invtype,
d273 2
a274 1
  NT_unsigned
a312 1
    struct neon_type_el vectype;
a407 11
/* Bits for DEFINED field in neon_typed_alias.  */
#define NTA_HASTYPE  1
#define NTA_HASINDEX 2

struct neon_typed_alias
{
  unsigned char defined;
  unsigned char index;
  struct neon_type_el eltype;
};

d433 1
a433 4
/* Structure for a hash table entry for a register.
   If TYPE is REG_TYPE_VFD or REG_TYPE_NQ, the NEON field can point to extra
   information which states whether a vector type or index is specified (for a
   register alias created with .dn or .qn). Otherwise NEON should be NULL.  */
d436 4
a439 5
  const char        *name;
  unsigned char      number;
  unsigned char      type;
  unsigned char      builtin;
  struct neon_typed_alias *neon;
d992 5
d998 1
a998 2
arm_reg_alt_syntax (char **ccp, char *start, struct reg_entry *reg,
                    enum arm_reg_type type)
d1000 14
a1044 23
  return FAIL;
}

/* As arm_reg_parse_multi, but the register must be of type TYPE, and the
   return value is the register number or FAIL.  */

static int
arm_reg_parse (char **ccp, enum arm_reg_type type)
{
  char *start = *ccp;
  struct reg_entry *reg = arm_reg_parse_multi (ccp);
  int ret;

  /* Do not allow a scalar (reg+index) to parse as a register.  */
  if (reg && reg->neon && (reg->neon->defined & NTA_HASINDEX))
    return FAIL;

  if (reg && reg->type == type)
    return reg->number;

  if ((ret = arm_reg_alt_syntax (ccp, start, reg, type)) != FAIL)
    return ret;

a1048 273
/* Parse a Neon type specifier. *STR should point at the leading '.'
   character. Does no verification at this stage that the type fits the opcode
   properly. E.g.,

     .i32.i32.s16
     .s32.f32
     .u16

   Can all be legally parsed by this function.

   Fills in neon_type struct pointer with parsed information, and updates STR
   to point after the parsed type specifier. Returns SUCCESS if this was a legal
   type, FAIL if not.  */

static int
parse_neon_type (struct neon_type *type, char **str)
{
  char *ptr = *str;

  if (type)
    type->elems = 0;

  while (type->elems < NEON_MAX_TYPE_ELS)
    {
      enum neon_el_type thistype = NT_untyped;
      unsigned thissize = -1u;

      if (*ptr != '.')
	break;

      ptr++;

      /* Just a size without an explicit type.  */
      if (ISDIGIT (*ptr))
	goto parsesize;

      switch (TOLOWER (*ptr))
	{
	case 'i': thistype = NT_integer; break;
	case 'f': thistype = NT_float; break;
	case 'p': thistype = NT_poly; break;
	case 's': thistype = NT_signed; break;
	case 'u': thistype = NT_unsigned; break;
	default:
	  as_bad (_("unexpected character `%c' in type specifier"), *ptr);
	  return FAIL;
	}

      ptr++;

      /* .f is an abbreviation for .f32.  */
      if (thistype == NT_float && !ISDIGIT (*ptr))
	thissize = 32;
      else
	{
	parsesize:
	  thissize = strtoul (ptr, &ptr, 10);

	  if (thissize != 8 && thissize != 16 && thissize != 32
              && thissize != 64)
            {
              as_bad (_("bad size %d in type specifier"), thissize);
	      return FAIL;
	    }
	}

      if (type)
        {
          type->el[type->elems].type = thistype;
	  type->el[type->elems].size = thissize;
	  type->elems++;
	}
    }

  /* Empty/missing type is not a successful parse.  */
  if (type->elems == 0)
    return FAIL;

  *str = ptr;

  return SUCCESS;
}

/* Errors may be set multiple times during parsing or bit encoding
   (particularly in the Neon bits), but usually the earliest error which is set
   will be the most meaningful. Avoid overwriting it with later (cascading)
   errors by calling this function.  */

static void
first_error (const char *err)
{
  if (!inst.error)
    inst.error = err;
}

/* Parse a single type, e.g. ".s32", leading period included.  */
static int
parse_neon_operand_type (struct neon_type_el *vectype, char **ccp)
{
  char *str = *ccp;
  struct neon_type optype;

  if (*str == '.')
    {
      if (parse_neon_type (&optype, &str) == SUCCESS)
        {
          if (optype.elems == 1)
            *vectype = optype.el[0];
          else
            {
              first_error (_("only one type should be specified for operand"));
              return FAIL;
            }
        }
      else
        {
          first_error (_("vector type expected"));
          return FAIL;
        }
    }
  else
    return FAIL;
  
  *ccp = str;
  
  return SUCCESS;
}

/* Special meanings for indices (which have a range of 0-7), which will fit into
   a 4-bit integer.  */

#define NEON_ALL_LANES		15
#define NEON_INTERLEAVE_LANES	14

/* Parse either a register or a scalar, with an optional type. Return the
   register number, and optionally fill in the actual type of the register
   when multiple alternatives were given (NEON_TYPE_NDQ) in *RTYPE, and
   type/index information in *TYPEINFO.  */

static int
parse_typed_reg_or_scalar (char **ccp, enum arm_reg_type type,
                           enum arm_reg_type *rtype,
                           struct neon_typed_alias *typeinfo)
{
  char *str = *ccp;
  struct reg_entry *reg = arm_reg_parse_multi (&str);
  struct neon_typed_alias atype;
  struct neon_type_el parsetype;

  atype.defined = 0;
  atype.index = -1;
  atype.eltype.type = NT_invtype;
  atype.eltype.size = -1;

  /* Try alternate syntax for some types of register. Note these are mutually
     exclusive with the Neon syntax extensions.  */
  if (reg == NULL)
    {
      int altreg = arm_reg_alt_syntax (&str, *ccp, reg, type);
      if (altreg != FAIL)
        *ccp = str;
      if (typeinfo)
        *typeinfo = atype;
      return altreg;
    }

  /* Undo polymorphism for Neon D and Q registers.  */
  if (type == REG_TYPE_NDQ
      && (reg->type == REG_TYPE_NQ || reg->type == REG_TYPE_VFD))
    type = reg->type;

  if (type != reg->type)
    return FAIL;

  if (reg->neon)
    atype = *reg->neon;
  
  if (parse_neon_operand_type (&parsetype, &str) == SUCCESS)
    {
      if ((atype.defined & NTA_HASTYPE) != 0)
        {
          first_error (_("can't redefine type for operand"));
          return FAIL;
        }
      atype.defined |= NTA_HASTYPE;
      atype.eltype = parsetype;
    }
    
  if (skip_past_char (&str, '[') == SUCCESS)
    {
      if (type != REG_TYPE_VFD)
        {
          first_error (_("only D registers may be indexed"));
          return FAIL;
        }
    
      if ((atype.defined & NTA_HASINDEX) != 0)
        {
          first_error (_("can't change index for operand"));
          return FAIL;
        }

      atype.defined |= NTA_HASINDEX;

      if (skip_past_char (&str, ']') == SUCCESS)
        atype.index = NEON_ALL_LANES;
      else
        {
          expressionS exp;

          my_get_expression (&exp, &str, GE_NO_PREFIX);

          if (exp.X_op != O_constant)
            {
              first_error (_("constant expression required"));
              return FAIL;
            }

          if (skip_past_char (&str, ']') == FAIL)
            return FAIL;

          atype.index = exp.X_add_number;
        }
    }
  
  if (typeinfo)
    *typeinfo = atype;
  
  if (rtype)
    *rtype = type;
  
  *ccp = str;
  
  return reg->number;
}

/* Like arm_reg_parse, but allow allow the following extra features:
    - If RTYPE is non-zero, return the (possibly restricted) type of the
      register (e.g. Neon double or quad reg when either has been requested).
    - If this is a Neon vector type with additional type information, fill
      in the struct pointed to by VECTYPE (if non-NULL).
   This function will fault on encountering a scalar.
*/

static int
arm_typed_reg_parse (char **ccp, enum arm_reg_type type,
                     enum arm_reg_type *rtype, struct neon_type_el *vectype)
{
  struct neon_typed_alias atype;
  char *str = *ccp;
  int reg = parse_typed_reg_or_scalar (&str, type, rtype, &atype);

  if (reg == FAIL)
    return FAIL;

  /* Do not allow a scalar (reg+index) to parse as a register.  */
  if ((atype.defined & NTA_HASINDEX) != 0)
    {
      first_error (_("register operand expected, but got scalar"));
      return FAIL;
    }

  if (vectype)
    *vectype = atype.eltype;

  *ccp = str;

  return reg;
}

#define NEON_SCALAR_REG(X)	((X) >> 4)
#define NEON_SCALAR_INDEX(X)	((X) & 15)

d1054 1
a1054 1
parse_scalar (char **ccp, int elsize, struct neon_type_el *type)
d1056 1
a1056 1
  int reg;
d1058 1
a1058 1
  struct neon_typed_alias atype;
d1060 2
a1061 1
  reg = parse_typed_reg_or_scalar (&str, REG_TYPE_VFD, NULL, &atype);
d1063 1
a1063 1
  if (reg == FAIL || (atype.defined & NTA_HASINDEX) == 0)
d1066 2
a1067 1
  if (atype.index == NEON_ALL_LANES)
d1069 1
a1069 1
      first_error (_("scalar must have an index"));
d1072 3
a1074 1
  else if (atype.index >= 64 / elsize)
d1076 1
a1076 1
      first_error (_("scalar index out of range"));
d1080 2
a1081 2
  if (type)
    *type = atype.eltype;
d1083 1
d1086 1
a1086 1
  return reg * 16 + atype.index;
d1112 1
a1112 1
	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN)) == FAIL)
d1114 1
a1114 1
		  first_error (_(reg_expected_msgs[REG_TYPE_RN]));
d1124 1
a1124 1
		      first_error (_("bad range in register list"));
d1155 1
a1155 1
	      first_error (_("missing `}'"));
d1234 1
a1234 3
     - 32 D registers may be used (also true for VFPv3).
   FIXME: Types are ignored in these register lists, which is probably a
   bug.  */
d1291 1
a1291 3

      new_base = arm_typed_reg_parse (str, regtype, &regtype, NULL);

d1294 1
a1294 1
	  first_error (_(reg_expected_msgs[regtype]));
d1297 1
a1297 1
 
d1310 1
a1310 1
	  first_error (_("invalid register list"));
d1329 1
a1329 2
	  if ((high_range = arm_typed_reg_parse (str, regtype, NULL, NULL))
              == FAIL)
a1380 26
/* True if two alias types are the same.  */

static int
neon_alias_types_same (struct neon_typed_alias *a, struct neon_typed_alias *b)
{
  if (!a && !b)
    return 1;
    
  if (!a || !b)
    return 0;

  if (a->defined != b->defined)
    return 0;
  
  if ((a->defined & NTA_HASTYPE) != 0
      && (a->eltype.type != b->eltype.type
          || a->eltype.size != b->eltype.size))
    return 0;

  if ((a->defined & NTA_HASINDEX) != 0
      && (a->index != b->index))
    return 0;
  
  return 1;
}

d1383 1
a1383 1
   The lane (or one of the NEON_*_LANES constants) is placed in bits [3:0] of
d1386 1
a1386 2
   Bits [6:5] encode the list length (minus one).
   The type of the list elements is put in *ELTYPE, if non-NULL.  */
d1388 2
d1391 1
a1391 1
#define NEON_REG_STRIDE(X)	((((X) >> 4) & 1) + 1)
d1395 1
a1395 2
parse_neon_el_struct_list (char **str, unsigned *pbase,
                           struct neon_type_el *eltype)
a1406 1
  struct neon_typed_alias firsttype;
d1413 1
a1413 3
      struct neon_typed_alias atype;
      int getreg = parse_typed_reg_or_scalar (&ptr, rtype, &rtype, &atype);

d1416 1
a1416 1
          first_error (_(reg_expected_msgs[rtype]));
a1427 1
          firsttype = atype;
d1434 1
a1434 1
              first_error (_(incr_error));
d1440 1
a1440 7
          first_error (_(incr_error));
          return FAIL;
        }

      if (!neon_alias_types_same (&atype, &firsttype))
        {
          first_error (_(type_error));
a1447 1
          struct neon_typed_alias htype;
d1453 1
a1453 1
              first_error (_(type_error));
d1460 1
a1460 1
              first_error (_("don't use Rn-Rm syntax with non-unit stride"));
d1464 1
a1464 1
          hireg = parse_typed_reg_or_scalar (&ptr, rtype, NULL, &htype);
d1467 1
a1467 6
              first_error (_(reg_expected_msgs[rtype]));
              return FAIL;
            }
          if (!neon_alias_types_same (&htype, &firsttype))
            {
              first_error (_(type_error));
d1481 1
a1481 1
      if ((atype.defined & NTA_HASINDEX) != 0)
d1483 11
a1493 3
          if (lane == -1)
            lane = atype.index;
          else if (lane != atype.index)
d1495 20
a1514 2
              first_error (_(type_error));
              return FAIL;
d1521 1
a1521 1
          first_error (_(type_error));
d1536 1
a1536 1
      first_error (_("error parsing element/structure list"));
d1542 1
a1542 1
      first_error (_("expected }"));
a1548 3
  if (eltype)
    *eltype = firsttype.eltype;

d1586 1
a1586 1
static struct reg_entry *
d1602 1
a1602 1
      return 0;
a1611 1
  new->neon = NULL;
a1614 21
  
  return new;
}

static void
insert_neon_reg_alias (char *str, int number, int type,
                       struct neon_typed_alias *atype)
{
  struct reg_entry *reg = insert_reg_alias (str, number, type);
  
  if (!reg)
    {
      first_error (_("attempt to redefine typed alias"));
      return;
    }
  
  if (atype)
    {
      reg->neon = xmalloc (sizeof (struct neon_typed_alias));
      *reg->neon = *atype;
    }
a1681 142
/* Create a Neon typed/indexed register alias using directives, e.g.:
     X .dn d5.s32[1]
     Y .qn 6.s16
     Z .dn d7
     T .dn Z[0]
   These typed registers can be used instead of the types specified after the
   Neon mnemonic, so long as all operands given have types. Types can also be
   specified directly, e.g.:
     vadd d0.s32, d1.s32, d2.s32
*/

static int
create_neon_reg_alias (char *newname, char *p)
{
  enum arm_reg_type basetype;
  struct reg_entry *basereg;
  struct reg_entry mybasereg;
  struct neon_type ntype;
  struct neon_typed_alias typeinfo;
  char *namebuf, *nameend;
  int namelen;
  
  typeinfo.defined = 0;
  typeinfo.eltype.type = NT_invtype;
  typeinfo.eltype.size = -1;
  typeinfo.index = -1;
  
  nameend = p;
  
  if (strncmp (p, " .dn ", 5) == 0)
    basetype = REG_TYPE_VFD;
  else if (strncmp (p, " .qn ", 5) == 0)
    basetype = REG_TYPE_NQ;
  else
    return 0;
  
  p += 5;
  
  if (*p == '\0')
    return 0;
  
  basereg = arm_reg_parse_multi (&p);

  if (basereg && basereg->type != basetype)
    {
      as_bad (_("bad type for register"));
      return 0;
    }

  if (basereg == NULL)
    {
      expressionS exp;
      /* Try parsing as an integer.  */
      my_get_expression (&exp, &p, GE_NO_PREFIX);
      if (exp.X_op != O_constant)
        {
          as_bad (_("expression must be constant"));
          return 0;
        }
      basereg = &mybasereg;
      basereg->number = (basetype == REG_TYPE_NQ) ? exp.X_add_number * 2
                                                  : exp.X_add_number;
      basereg->neon = 0;
    }

  if (basereg->neon)
    typeinfo = *basereg->neon;

  if (parse_neon_type (&ntype, &p) == SUCCESS)
    {
      /* We got a type.  */
      if (typeinfo.defined & NTA_HASTYPE)
        {
          as_bad (_("can't redefine the type of a register alias"));
          return 0;
        }
      
      typeinfo.defined |= NTA_HASTYPE;
      if (ntype.elems != 1)
        {
          as_bad (_("you must specify a single type only"));
          return 0;
        }
      typeinfo.eltype = ntype.el[0];
    }
  
  if (skip_past_char (&p, '[') == SUCCESS)
    {
      expressionS exp;
      /* We got a scalar index.  */
    
      if (typeinfo.defined & NTA_HASINDEX)
        {
          as_bad (_("can't redefine the index of a scalar alias"));
          return 0;
        }
    
      my_get_expression (&exp, &p, GE_NO_PREFIX);
    
      if (exp.X_op != O_constant)
        {
          as_bad (_("scalar index must be constant"));
          return 0;
        }
      
      typeinfo.defined |= NTA_HASINDEX;
      typeinfo.index = exp.X_add_number;
    
      if (skip_past_char (&p, ']') == FAIL)
        {
          as_bad (_("expecting ]"));
          return 0;
        }
    }

  namelen = nameend - newname;
  namebuf = alloca (namelen + 1);
  strncpy (namebuf, newname, namelen);
  namebuf[namelen] = '\0';
  
  insert_neon_reg_alias (namebuf, basereg->number, basetype,
                         typeinfo.defined != 0 ? &typeinfo : NULL);
    
  /* Insert name in all uppercase.  */
  for (p = namebuf; *p; p++)
    *p = TOUPPER (*p);
  
  if (strncmp (namebuf, newname, namelen))
    insert_neon_reg_alias (namebuf, basereg->number, basetype,
                           typeinfo.defined != 0 ? &typeinfo : NULL);
  
  /* Insert name in all lowercase.  */
  for (p = namebuf; *p; p++)
    *p = TOLOWER (*p);
  
  if (strncmp (namebuf, newname, namelen))
    insert_neon_reg_alias (namebuf, basereg->number, basetype,
                           typeinfo.defined != 0 ? &typeinfo : NULL);
  
  return 1;
}

a1689 12
static void
s_dn (int a ATTRIBUTE_UNUSED)
{
  as_bad (_("invalid syntax for .dn directive"));
}

static void
s_qn (int a ATTRIBUTE_UNUSED)
{
  as_bad (_("invalid syntax for .qn directive"));
}

a1726 2
          if (reg->neon)
            free (reg->neon);
d2793 1
a2793 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
d2808 1
a2808 1
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
d2925 1
a2925 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
d2941 1
a2941 1
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
d3039 1
a3039 1
  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
d3100 1
a3100 1
  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
d3104 1
a3104 1
    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
a3299 3
  /* Following two are likewise never called.  */
  { "dn",	   s_dn,          0 },
  { "qn",          s_qn,          0 },
d3601 1
a3601 1
	  && (reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
d3632 1
a3632 1
  if ((value = arm_reg_parse (str, REG_TYPE_RN)) != FAIL)
d3743 1
a3743 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
d3758 1
a3758 1
      if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
d3841 1
a3841 1
	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
d4102 1
a4102 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
d4115 1
a4115 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
a4156 1
  struct neon_type_el optype;
d4158 1
a4158 1
  if ((val = parse_scalar (&ptr, 8, &optype)) != FAIL)
a4162 1
      inst.operands[i].vectype = optype;
d4168 1
a4168 1
      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
d4175 1
a4175 2
  else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NDQ, &rtype, &optype))
           != FAIL)
a4183 1
      inst.operands[i].vectype = optype;
d4186 1
a4186 1
      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
d4196 1
a4196 1
              first_error (_("can't use Neon quad register here"));
d4201 1
a4201 1
          if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
d4214 1
a4214 2
      else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NDQ, &rtype, &optype))
               != FAIL)
a4223 1
          inst.operands[i].vectype = optype;
d4228 1
a4228 1
          first_error (_("expected <Rm> or <Dm> or <Qm> operand"));
d4232 1
a4232 1
  else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
d4242 1
a4242 1
      if ((val = parse_scalar (&ptr, 8, &optype)) != FAIL)
a4247 1
          inst.operands[i].vectype = optype;
d4249 1
a4249 1
      else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
d4259 1
a4259 2
          if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFD, NULL, &optype))
              == FAIL)
d4261 1
a4261 1
              first_error (_(reg_expected_msgs[REG_TYPE_VFD]));
a4267 1
          inst.operands[i].vectype = optype;
d4273 1
a4273 1
      first_error (_("parse error"));
d4283 1
a4283 1
  first_error (_("expected comma"));
d4287 1
a4287 1
  first_error (_(reg_expected_msgs[REG_TYPE_RN]));
d4291 1
a4291 1
  first_error (_("instruction cannot be conditionalized"));
d4418 10
a4427 11
#define po_reg_or_fail(regtype) do {				\
  val = arm_typed_reg_parse (&str, regtype, &rtype,		\
  			     &inst.operands[i].vectype);	\
  if (val == FAIL)						\
    {								\
      first_error (_(reg_expected_msgs[regtype]));		\
      goto failure;						\
    }								\
  inst.operands[i].reg = val;					\
  inst.operands[i].isreg = 1;					\
  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\
d4430 8
a4437 9
#define po_reg_or_goto(regtype, label) do {			\
  val = arm_typed_reg_parse (&str, regtype, &rtype,		\
                             &inst.operands[i].vectype);	\
  if (val == FAIL)						\
    goto label;							\
								\
  inst.operands[i].reg = val;					\
  inst.operands[i].isreg = 1;					\
  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\
d4446 6
a4451 6
#define po_scalar_or_goto(elsz, label) do {			\
  val = parse_scalar (&str, elsz, &inst.operands[i].vectype);	\
  if (val == FAIL)						\
    goto label;							\
  inst.operands[i].reg = val;					\
  inst.operands[i].isscalar = 1;				\
d4764 1
a4764 2
          val = parse_neon_el_struct_list (&str, &inst.operands[i].reg,
                                           &inst.operands[i].vectype);
d4952 1
a4952 1
          first_error (_("D register out of range for selected VFP version"));
a8998 1
  N_SIZ  = 0x000040, /* if N_EQK, this operand is forced to be size-only.  */
a9002 2
#define N_ALLMODS  (N_DBL | N_HLF | N_SGN | N_UNS | N_INT | N_FLT | N_SIZ)

d9040 1
a9040 1
        else if (RQ(0) && RQ(1) && RQ(2))
d9043 2
a9044 2
          first_error (_("expected <Qd>, <Qn>, <Qm> or <Dd>, <Dn>, <Dm> "
                         "operands"));
d9055 2
a9056 2
          first_error (_("expected <Qd>, <Qn>, #<imm> or <Dd>, <Dn>, #<imm> "
                         "operands"));
d9067 2
a9068 2
          first_error (_("expected <Qd>, <Qn>, <Qm>, #<imm> or "
                         "<Dd>, <Dn>, <Dm>, #<imm> operands"));
d9079 2
a9080 2
          first_error (_("expected <Qd>, <Qn>, <Dm[x]> or <Dd>, <Dn>, <Dm[x]> "
                         "operands"));
d9091 1
a9091 1
          first_error (_("expected <Qd>, <Qm> or <Dd>, <Dm> operands"));
d9102 1
a9102 1
          first_error (_("expected <Qd>, <Dm[x]> or <Dd>, <Dm[x]> operands"));
d9113 1
a9113 1
          first_error (_("expected <Qd>, <Rm> or <Dd>, <Rm> operands"));
d9124 1
a9124 1
          first_error (_("expected <Qd>, #<imm> or <Dd>, #<imm> operands"));
a9159 2
      else if ((typebits & N_SIZ) != 0)
        *g_type = NT_untyped;
d9253 1
a9253 1
static int
a9256 3
  if ((mask & N_EQK) != 0)
    return FAIL;

d9259 1
a9259 1
  else if ((mask & (N_S16 | N_U16 | N_I16 | N_16 | N_P16)) != 0)
d9261 1
a9261 1
  else if ((mask & (N_S32 | N_U32 | N_I32 | N_32 | N_F32)) != 0)
d9263 1
a9263 1
  else if ((mask & (N_S64 | N_U64 | N_I64 | N_64)) != 0)
a9264 3
  else
    return FAIL;

d9267 1
a9267 1
  else if ((mask & (N_U8 | N_U16 | N_U32 | N_U64)) != 0)
d9269 1
a9269 1
  else if ((mask & (N_I8 | N_I16 | N_I32 | N_I64)) != 0)
d9271 1
a9271 1
  else if ((mask & (N_8 | N_16 | N_32 | N_64)) != 0)
d9273 1
a9273 1
  else if ((mask & (N_P8 | N_P16)) != 0)
d9275 1
a9275 1
  else if ((mask & N_F32) != 0)
a9276 4
  else
    return FAIL;
  
  return SUCCESS;
d9294 3
a9296 5
      if (el_type_of_type_chk (&type, &size, allowed & i) == SUCCESS)
        {
          neon_modify_type_size (mods, &type, &size);
          destmask |= type_chk_of_el_type (type, size);
        }
a9346 8
  if (inst.vectype.elems > 0)
    for (i = 0; i < els; i++)
      if (inst.operands[i].vectype.type != NT_invtype)
        {
          first_error (_("types specified in both the mnemonic and operands"));
          return badtype;
        }

a9356 15
        if (j != key_el)
          inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
                                                  types[j]);
    }
  else if (inst.vectype.elems == 0 && els > 0)
    {
      unsigned j;
      /* No types were given after the mnemonic, so look for types specified
         after each operand. We allow some flexibility here; as long as the
         "key" operand has a type, we can infer the others.  */
      for (j = 0; j < els; j++)
        if (inst.operands[j].vectype.type != NT_invtype)
          inst.vectype.el[j] = inst.operands[j].vectype;

      if (inst.operands[key_el].vectype.type != NT_invtype)
d9358 3
a9360 9
          for (j = 0; j < els; j++)
            if (inst.operands[j].vectype.type == NT_invtype)
              inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
                                                      types[j]);
        }
      else
        {
          first_error (_("operand types can't be inferred"));
          return badtype;
d9365 1
a9365 1
      first_error (_("type specifier has the wrong number of parts"));
d9411 1
a9411 1
	              first_error (_("bad type in Neon instruction"));
d9422 1
a9422 1
                      first_error (_("inconsistent types in Neon instruction"));
d9476 1
a9476 1
neon_three_same (int isquad, int ubit, int size)
d9478 4
d9527 1
a9527 1
  neon_three_same (rs == NS_QQQ, et.type == NT_unsigned, et.size);
d9536 1
a9536 1
  neon_three_same (rs == NS_QQQ, et.type == NT_unsigned, et.size);
d9574 1
a9574 1
      neon_three_same (rs == NS_QQQ, et.type == NT_unsigned, et.size);
d9595 1
a9595 1
      neon_three_same (rs == NS_QQQ, et.type == NT_unsigned, et.size);
d9644 1
a9644 1
  first_error (_("immediate value out of range"));
d9830 1
a9830 1
      neon_three_same (rs == NS_QQQ, 0, -1);
d9893 2
a9894 2
  neon_check_type (3, rs, N_IGNORE_TYPE);
  neon_three_same (rs == NS_QQQ, 0, -1);
d9898 1
a9898 2
neon_dyadic_misc (enum neon_el_type ubit_meaning, unsigned types,
                  unsigned destbits)
d9901 1
a9901 2
  struct neon_type_el et = neon_check_type (3, rs, N_EQK | destbits, N_EQK,
                                            types | N_KEY);
d9905 1
a9905 1
      neon_three_same (rs == NS_QQQ, 0, -1);
d9910 1
a9910 1
      neon_three_same (rs == NS_QQQ, et.type == ubit_meaning, et.size);
d9917 1
a9917 1
  neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);
d9925 1
a9925 1
  neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);
d9931 1
a9931 1
  neon_dyadic_misc (NT_unsigned, N_IF_32, 0);
d9937 1
a9937 1
  neon_dyadic_misc (NT_unsigned, N_IF_32, 0);
d9945 1
a9945 1
  neon_dyadic_misc (NT_untyped, N_IF_32 | N_I64, 0);
d9982 1
a9982 1
      neon_dyadic_misc (NT_unsigned, regtypes, N_SIZ);
d9987 1
a9987 2
      struct neon_type_el et = neon_check_type (2, rs,
        N_EQK | N_SIZ, immtypes | N_KEY);
d10029 2
a10030 2
  unsigned regno = NEON_SCALAR_REG (scalar);
  unsigned elno = NEON_SCALAR_INDEX (scalar);
d10046 1
a10046 1
      first_error (_("scalar out of range for multiply instruction"));
d10057 1
a10057 7
  unsigned scalar;

  /* Give a more helpful error message if we have an invalid type.  */
  if (et.type == NT_invtype)
    return;
  
  scalar = neon_scalar_for_mul (inst.operands[2].reg, et.size);
d10092 1
a10092 1
  neon_three_same (rs == NS_QQQ, 0, et.size);
d10105 1
a10105 1
    neon_dyadic_misc (NT_poly, N_I8 | N_I16 | N_I32 | N_F32 | N_P8, 0);
d10126 1
a10126 1
      neon_three_same (rs == NS_QQQ, 0, et.size);
d10136 1
a10136 1
  neon_three_same (rs == NS_QQQ, 1, -1);
d10151 1
a10151 1
  neon_three_same (rs == NS_QQQ, 0, -1);
d10453 1
a10453 1
          first_error (_("immediate out of range"));
d10536 2
a10537 2
      struct neon_type_el et = neon_check_type (3, NS_QDS,
        N_EQK | N_DBL, N_EQK, regtypes | N_KEY);
d10639 1
a10639 2
      struct neon_type_el et = neon_check_type (2, rs,
        N_EQK, N_8 | N_16 | N_32 | N_KEY);
d10641 1
a10641 1
      unsigned dm = NEON_SCALAR_REG (inst.operands[1].reg);
d10643 1
a10643 1
      unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg) << logsize;
d10658 1
a10658 2
      struct neon_type_el et = neon_check_type (1, rs,
        N_8 | N_16 | N_32 | N_KEY);
d10723 2
a10724 2
          struct neon_type_el et = neon_check_type (2, NS_IGNORE,
            N_EQK, N_S8 | N_S16 | N_U8 | N_U16 | N_32 | N_KEY);
d10726 2
a10727 2
          unsigned dn = NEON_SCALAR_REG (inst.operands[1].reg);
          unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg);
a10729 1
          constraint (et.type == NT_invtype, _("bad type for scalar"));
d10756 2
a10757 2
              struct neon_type_el et = neon_check_type (2, NS_IGNORE,
                N_8 | N_16 | N_32 | N_KEY, N_EQK);
d10759 2
a10760 2
              unsigned dn = NEON_SCALAR_REG (inst.operands[0].reg);
              unsigned x = NEON_SCALAR_INDEX (inst.operands[0].reg);
a10761 1
              constraint (et.type == NT_invtype, _("bad type for scalar"));
d10962 1
a10962 1
  neon_check_type (3, NS_DLD, N_EQK, N_EQK, N_8 | N_KEY);
d10966 1
a10966 1
      first_error (_("bad list length for table lookup"));
a11082 3
  if (et.type == NT_invtype)
    return;

d11099 1
a11099 1
        first_error (_("bad alignment"));
d11158 1
a11158 1
    first_error (_("unsupported alignment for instruction"));
a11172 3
  if (et.type == NT_invtype)
    return;
  
a11252 3
  if (et.type == NT_invtype)
    return;

d11265 1
a11265 1
        default: first_error (_("bad list length")); return;
d11491 79
d11688 1
a11688 1
          if (parse_neon_type (&inst.vectype, str) == FAIL)
d11818 2
a11819 3
	 the form alias .req reg, or a Neon .dn/.qn directive.  */
      if (!create_register_alias (str, p)
          && !create_neon_reg_alias (str, p))
d12034 1
a12034 1
#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, TRUE, 0 }
d14935 1
a14935 1
  int reg = arm_reg_parse ((char **) &regname, REG_TYPE_RN);
@


1.250.2.10
log
@	* gas/config/tc-arm.c (neon_is_quarter_float): Move, and rename to...
	(is_quarter_float): Rename from above. Simplify slightly.
	(parse_qfloat_immediate): Parse a "quarter precision" floating-point
	number.
	(parse_neon_mov): Parse floating-point constants.
	(neon_qfloat_bits): Fix encoding.
	(neon_cmode_for_move_imm): Tweak to use floating-point encoding in
	preference to integer encoding when using the F32 type.

   	* gas/testsuite/gas/arm/neon-const.s: New testcase. Neon floating-point
	constants.
	* gas/testsuite/gas/arm/neon-const.d: Expected output of above.
	* gas/testsuite/gas/arm/neon-cov.d: Expect floating-point disassembly
	for VMOV.F32.

   	* opcodes/arm-dis.c (print_insn_neon): Disassemble floating-point
	constant VMOV.
@
text
@a3996 49
/* Returns 1 if a number has "quarter-precision" float format
   0baBbbbbbc defgh000 00000000 00000000.  */

static int
is_quarter_float (unsigned imm)
{
  int bs = (imm & 0x20000000) ? 0x3e000000 : 0x40000000;
  return (imm & 0x7ffff) == 0 && ((imm & 0x7e000000) ^ bs) == 0;
}

/* Parse an 8-bit "quarter-precision" floating point number of the form:
   0baBbbbbbc defgh000 00000000 00000000.
   The minus-zero case needs special handling, since it can't be encoded in the
   "quarter-precision" float format, but can nonetheless be loaded as an integer
   constant.  */

static unsigned
parse_qfloat_immediate (char **ccp, int *immed)
{
  char *str = *ccp;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  
  skip_past_char (&str, '#');
  
  if ((str = atof_ieee (str, 's', words)) != NULL)
    {
      unsigned fpword = 0;
      int i;
      
      /* Our FP word must be 32 bits (single-precision FP).  */
      for (i = 0; i < 32 / LITTLENUM_NUMBER_OF_BITS; i++)
        {
          fpword <<= LITTLENUM_NUMBER_OF_BITS;
          fpword |= words[i];
        }
      
      if (is_quarter_float (fpword) || fpword == 0x80000000)
        *immed = fpword;
      else
        return FAIL;

      *ccp = str;
      
      return SUCCESS;
    }
  
  return FAIL;
}

a4704 7
      else if (parse_qfloat_immediate (&ptr, &inst.operands[i].imm) == SUCCESS)
        {
          /* Case 2: VMOV<c><q>.<dt> <Qd>, #<float-imm>
             Case 3: VMOV<c><q>.<dt> <Dd>, #<float-imm>  */
          if (!thumb_mode && (inst.instruction & 0xf0000000) != 0xe0000000)
            goto bad_cond;
        }
d10217 14
a10230 1
/* Compress quarter-float representation to 0b...000 abcdefgh.  */
d10235 1
a10235 1
  return ((imm >> 19) & 0x7f) | ((imm >> 24) & 0x80);
d10246 1
a10246 1
                         int *op, int size, enum neon_el_type type)
d10248 1
a10248 8
  if (type == NT_float && is_quarter_float (immlo) && immhi == 0)
    {
      if (size != 32 || *op == 1)
        return FAIL;
      *immbits = neon_qfloat_bits (immlo);
      return 0xf;
    }
  else if (size == 64 && neon_bits_same_in_bytes (immhi)
d10306 7
d10999 1
a10999 1
                                        et.size, et.type)) == FAIL)
d11008 1
a11008 1
                                            et.size, et.type)) == FAIL)
@


1.250.2.11
log
@	* gas/config/tc-arm.c (parse_vfp_reg_list): Improve register bounds
	checking.
	(do_neon_mov): Enable several VMOV variants for VFP. Add suitable
	architecture version checks.
	(insns): Allow overlapping instructions to be used in VFP mode.

   	* gas/testsuite/gas/arm/vfp-neon-overlap.s: New test. Overlapping
	VFP/Neon instructions.
	* gas/testsuite/gas/arm/vfp-neon-overlap.d: Expected output of above.
	* gas/testsuite/gas/arm/vfp1xD.d: Test for fldmx/fstmx.
	* gas/testsuite/gas/arm/vfp1xD_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfpv3-32drs.d: Likewise.

   	* opcodes/arm-dis.c (coprocessor_opcodes): Don't interpret fldmx/fstmx
	as vldm/vstm.
@
text
@a1555 9
      break;
    
    case REGLIST_NEON_D:
      regtype = REG_TYPE_NDQ;
      break;
    }

  if (etype != REGLIST_VFP_S)
    {
d1569 6
a1590 6
      if (new_base >= max_regs)
        {
          first_error (_("register out of range in list"));
          return FAIL;
        }
 
a1628 6
          if (high_range >= max_regs)
            {
              first_error (_("register out of range in list"));
              return FAIL;
            }

a11306 3
   Cases 4, 6 may be used with VFPv1 and above (only 32-bit transfers!).
   Cases 5, 7 may be used with VFPv2 and above.
   
a11316 1
  const char *vfp_vers = "selected FPU does not support instruction";
a11331 4
          constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
                      _(vfp_vers));
          constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
                      && et.size != 32, _(vfp_vers));
a11364 4
              constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
                          _(vfp_vers));
              constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
                          && et.size != 32, _(vfp_vers));
a11414 3
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2),
                  _(vfp_vers));

a14140 4
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_ext_v1
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v1
a14141 5

#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_neon_ext_v1
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_neon_ext_v1
d14236 1
a14236 1
#define THUMB_VARIANT &fpu_vfp_ext_v1xd
d14238 1
a14238 1
#define ARM_VARIANT &fpu_vfp_ext_v1xd
a14249 5
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_v3_or_neon_ext
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_v3_or_neon_ext

@


1.250.2.12
log
@2006-05-01  Paul Brook  <paul@@codesourcery.com>

	* bfd/elf32-arm.c (elf32_arm_final_link_relocate): Set thumb funciton
	bit for R_ARM_REL32.
	* gas/config/tc-arm.c (arm_optimize_expr): New function.
	* gas/config/tc-arm.h (md_optimize_expr): Define
	(arm_optimize_expr): Add prototype.
	(TC_FORCE_RELOCATION_SUB_SAME): Define.
	* ld/testsuite/ld-arm/arm-elf.exp: Add thumb-rel32.
	* ld/testsuite/ld-arm/thumb-rel32.d: New test.
	* ld/testsuite/ld-arm/thumb-rel32.s: New test.
@
text
@a15857 23

/* We usually want to set the low bit on the address of thumb function
   symbols.  In particular .word foo - . should have the low bit set.
   Generic code tries to fold the difference of two symbols to
   a constant.  Prevent this and force a relocation when the first symbols
   is a thumb function.  */
int
arm_optimize_expr (expressionS *l, operatorT op, expressionS *r)
{
  if (op == O_subtract
      && l->X_op == O_symbol
      && r->X_op == O_symbol
      && THUMB_IS_FUNC (l->X_add_symbol))
    {
      l->X_op = O_subtract;
      l->X_op_symbol = r->X_add_symbol;
      l->X_add_number -= r->X_add_number;
      return 1;
    }
  /* Process as normal.  */
  return 0;
}

@


1.250.2.13
log
@	* gas/config/tc-arm.c (do_iwmmxt_wldstbh): Don't multiply offset
	by 4 here.
	(md_apply_fix3): Multiply offset by 4 here for
	BFD_RELOC_ARM_CP_OFF_IMM_S2 and BFD_RELOC_ARM_T32_CP_OFF_IMM_S2.
	* gas/testsuite/gas/arm/iwmmxt.s: Increase offsets for wstrb and
	wstrh.
	* gas/testsuite/gas/arm/iwmmxt.d: Update expected results.
	* gas/testsuite/gas/arm/iwmmxt-bad2.s: Test wstrb, wstrh, wldrb
	and wldrh.
	* gas/testsuite/gas/arm/iwmmxt-bad2.l: Update expected error
	messages.
@
text
@d7205 1
a16546 1
      value *= 4;
@


1.250.2.14
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>

	* bfd/elf32-arm.c (elf32_arm_reloc_map): Add MOVW and MOVT relocs.
	(elf32_arm_final_link_relocate): Handle MOVW and MOVT relocs.
	(elf32_arm_gc_sweep_hook, elf32_arm_check_relocs): Ditto.
	* bfd/reloc.c: Ditto.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/libbfd.h: Regenerate.
	* bfd/libcoff.h: Regenerate.
	* gas/config/tc-arm.c (parse_half): New function.
	(operand_parse_code): Remove OP_Iffff.  Add OP_HALF.
	(parse_operands): Ditto.
	(do_mov16): Reject invalid relocations.
	(do_t_mov16): Ditto.  Use Thumb reloc numbers.
	(insns): Replace Iffff with HALF.
	(md_apply_fix): Add MOVW and MOVT relocs.
	(tc_gen_reloc): Ditto.
	* gas/doc/c-arm.texi: Document relocation operators
	* ld/testsuite/ld-arm/arm-elf.exp: Add arm-movwt.
	* ld/testsuite/ld-arm/arm-movwt.d: New test.
	* ld/testsuite/ld-arm/arm-movwt.s: New test.
	* ld/testsuite/ld-arm/arm.ld: Add .far.
@
text
@a4437 40
/* Parse an operand for a MOVW or MOVT instruction.  */
static int
parse_half (char **str)
{
  char * p;
  
  p = *str;
  skip_past_char (&p, '#');
  if (strncasecmp (p, ":lower16:", 9) == 0) 
    inst.reloc.type = BFD_RELOC_ARM_MOVW;
  else if (strncasecmp (p, ":upper16:", 9) == 0)
    inst.reloc.type = BFD_RELOC_ARM_MOVT;

  if (inst.reloc.type != BFD_RELOC_UNUSED)
    {
      p += 9;
      skip_whitespace(p);
    }

  if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
    return FAIL;

  if (inst.reloc.type == BFD_RELOC_UNUSED)
    {
      if (inst.reloc.exp.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return FAIL;
	}
      if (inst.reloc.exp.X_add_number < 0
	  || inst.reloc.exp.X_add_number > 0xffff)
	{
	  inst.error = _("immediate value out of range");
	  return FAIL;
	}
    }
  *str = p;
  return SUCCESS;
}

d4928 1
a4939 1
  OP_HALF,	/* 0 .. 65535 or low/high reloc.  */
d5200 1
a5265 5
	  /* Operand for MOVW or MOVT.  */
	case OP_HALF:
	  po_misc_or_fail (parse_half (&str));
	  break;

d6441 4
a6444 16
  bfd_vma imm;
  bfd_boolean top;

  top = (inst.instruction & 0x00400000) != 0;
  constraint (top && inst.reloc.type == BFD_RELOC_ARM_MOVW,
	      _(":lower16: not allowed this instruction"));
  constraint (!top && inst.reloc.type == BFD_RELOC_ARM_MOVT,
	      _(":upper16: not allowed instruction"));
  inst.instruction |= inst.operands[0].reg << 12;
  if (inst.reloc.type == BFD_RELOC_UNUSED)
    {
      imm = inst.reloc.exp.X_add_number;
      /* The value is in two pieces: 0:11, 16:19.  */
      inst.instruction |= (imm & 0x00000fff);
      inst.instruction |= (imm & 0x0000f000) << 4;
    }
a8711 15
  bfd_vma imm;
  bfd_boolean top;

  top = (inst.instruction & 0x00800000) != 0;
  if (inst.reloc.type == BFD_RELOC_ARM_MOVW)
    {
      constraint (top, _(":lower16: not allowed this instruction"));
      inst.reloc.type = BFD_RELOC_ARM_THUMB_MOVW;
    }
  else if (inst.reloc.type == BFD_RELOC_ARM_MOVT)
    {
      constraint (!top, _(":upper16: not allowed this instruction"));
      inst.reloc.type = BFD_RELOC_ARM_THUMB_MOVT;
    }

d8713 4
a8716 8
  if (inst.reloc.type == BFD_RELOC_UNUSED)
    {
      imm = inst.reloc.exp.X_add_number;
      inst.instruction |= (imm & 0xf000) << 4;
      inst.instruction |= (imm & 0x0800) << 15;
      inst.instruction |= (imm & 0x0700) << 4;
      inst.instruction |= (imm & 0x00ff);
    }
d13410 2
a13411 2
 TCE(movw,	3000000, f2400000, 2, (RRnpc, HALF),		    mov16, t_mov16),
 TCE(movt,	3400000, f2c00000, 2, (RRnpc, HALF),		    mov16, t_mov16),
a16724 41
    case BFD_RELOC_ARM_MOVW:
    case BFD_RELOC_ARM_MOVT:
    case BFD_RELOC_ARM_THUMB_MOVW:
    case BFD_RELOC_ARM_THUMB_MOVT:
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  /* REL format relocations are limited to a 16-bit addend.  */
	  if (!fixP->fx_done)
	    {
	      if (value < -0x1000 || value > 0xffff)
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("offset too big"));
	    }
	  else if (fixP->fx_r_type == BFD_RELOC_ARM_MOVT
		   || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT)
	    {
	      value >>= 16;
	    }

	  if (fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVW
	      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT)
	    {
	      newval = get_thumb32_insn (buf);
	      newval &= 0xfbf08f00;
	      newval |= (value & 0xf000) << 4;
	      newval |= (value & 0x0800) << 15;
	      newval |= (value & 0x0700) << 4;
	      newval |= (value & 0x00ff);
	      put_thumb32_insn (buf, newval);
	    }
	  else
	    {
	      newval = md_chars_to_number (buf, 4);
	      newval &= 0xfff0f000;
	      newval |= value & 0x0fff;
	      newval |= (value & 0xf000) << 4;
	      md_number_to_chars (buf, newval, 4);
	    }
	}
      return;

a16778 28
    case BFD_RELOC_ARM_MOVW:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_ARM_MOVW_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_MOVT:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_ARM_MOVT_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_THUMB_MOVW:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_ARM_THUMB_MOVW_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_THUMB_MOVT:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_ARM_THUMB_MOVT_PCREL;
	  break;
	}

@


1.250.2.15
log
@	* gas/config/tc-arm.c (stdarg.h): include.
	(arm_it): Add uncond_value field. Add isvec and issingle to operand
	array.
	(arm_reg_type): Add REG_TYPE_VFSD (single or double VFP reg) and
	REG_TYPE_NSDQ (single, double or quad vector reg).
	(reg_expected_msgs): Update.
	(BAD_FPU): Add macro for unsupported FPU instruction error.
	(parse_neon_type): Support 'd' as an alias for .f64.
	(parse_typed_reg_or_scalar): Support REG_TYPE_VFSD, REG_TYPE_NSDQ
	sets of registers.
	(parse_vfp_reg_list): Don't update first arg on error.
	(parse_neon_mov): Support extra syntax for VFP moves.
	(operand_parse_code): Add OP_RVSD, OP_RNSDQ, OP_VRSDLST, OP_RVSD_IO,
	OP_RNSDQ_RNSC, OP_RVC_PSR, OP_APSR_RR, OP_oRNSDQ.
	(parse_operands): Support isvec, issingle operands fields, new parse
	codes above.
	(do_vfp_nsyn_mrs, do_vfp_nsyn_msr): New functions. Support VFP mrs,
	msr variants.
	(do_mrs, do_msr, do_t_mrs, do_t_msr): Add support for above.
	(NEON_ENC_TAB): Add vnmul, vnmla, vnmls, vcmp, vcmpz, vcmpe, vcmpez.
	(NEON_ENC_SINGLE, NEON_ENC_DOUBLE): Define macros.
	(NEON_SHAPE_DEF): New macro. Define table of possible instruction
	shapes.
	(neon_shape): Redefine in terms of above.
	(neon_shape_class): New enumeration, table of shape classes.
	(neon_shape_el): New enumeration. One element of a shape.
	(neon_shape_el_size): Register widths of above, where appropriate.
	(neon_shape_info): New struct. Info for shape table.
	(neon_shape_tab): New array.
	(neon_type_mask): Add N_F64, N_VFP. Update N_MAX_NONSPECIAL.
	(neon_check_shape): Rewrite as...
	(neon_select_shape): New function to classify instruction shapes,
	driven by new table neon_shape_tab array.
	(neon_quad): New function. Return 1 if shape should set Q flag in
	instructions (or equivalent), 0 otherwise.
	(type_chk_of_el_type): Support F64.
	(el_type_of_type_chk): Likewise.
	(neon_check_type): Add support for VFP type checking (VFP data
	elements fill their containing registers).
	(do_vfp_cond_or_thumb): Fill in condition field in ARM mode, or 0xE
	in thumb mode for VFP instructions.
	(do_vfp_nsyn_opcode): New function. Look up the opcode in argument,
	and encode the current instruction as if it were that opcode.
	(try_vfp_nsyn): New. If this looks like a VFP instruction with ARGS
	arguments, call function in PFN.
	(do_vfp_nsyn_add_sub, do_vfp_nsyn_mla_mls, do_vfp_nsyn_mul)
	(do_vfp_nsyn_abs_neg, do_vfp_nsyn_ldm_stm, do_vfp_nsyn_ldr_str)
	(do_vfp_nsyn_sqrt, do_vfp_nsyn_div, do_vfp_nsyn_nmul)
	(do_vfp_nsyn_cmp, nsyn_insert_sp, do_vfp_nsyn_push)
	(do_vfp_nsyn_pop, do_vfp_nsyn_cvt, do_vfp_nsyn_cvtz): New functions.
	Redirect Neon-syntax VFP instructions to VFP instruction handlers.
	(do_neon_dyadic_i_su, do_neon_dyadic_i64_su, do_neon_shl_imm)
	(do_neon_qshl_imm, do_neon_logic, do_neon_bitfield)
	(neon_dyadic_misc, neon_compare, do_neon_tst, do_neon_qdmulh)
	(do_neon_fcmp_absolute, do_neon_step, do_neon_sli, do_neon_sri)
	(do_neon_qshlu_imm, neon_move_immediate, do_neon_mvn, do_neon_ext)
	(do_neon_rev, do_neon_dup, do_neon_rshift_round_imm, do_neon_trn)
	(do_neon_zip_uzp, do_neon_sat_abs_neg, do_neon_pair_long)
	(do_neon_recip_est, do_neon_cls, do_neon_clz, do_neon_cnt)
	(do_neon_swp): Use neon_select_shape not neon_check_shape. Use
	neon_quad.
	(vfp_or_neon_is_neon): New function. Call if a mnemonic shared
	between VFP and Neon turns out to belong to Neon. Perform
	architecture check and fill in condition field if appropriate.
	(do_neon_addsub_if_i, do_neon_mac_maybe_scalar, do_neon_abs_neg)
	(do_neon_cvt): Add support for VFP variants of instructions.
	(neon_cvt_flavour): Extend to cover VFP conversions.
	(do_neon_mov): Rewrite to use neon_select_shape. Add support for VFP
	vmov variants.
	(do_neon_ldr_str): Handle single-precision VFP load/store.
	(do_neon_ld_st_interleave, do_neon_ld_st_lane, do_neon_ld_dup): Use
	NS_NULL not NS_IGNORE.
	(opcode_tag): Add OT_csuffixF for operands which either take a
	conditional suffix, or have 0xF in the condition field.
	(md_assemble): Add support for OT_csuffixF.
	(NCE): Replace macro with...
	(NCE_tag, NCE, NCEF): New macros.
	(nCE): Replace macro with...
	(nCE_tag, nCE, nCEF): New macros.
	(insns): Add support for VFP insns or VFP versions of insns msr, mrs,
	vsqrt, vdiv, vnmul, vnmla, vnmls, vcmp, vcmpe, vpush, vpop, vcvtz,
	vmul, vmla, vmls, vadd, vsub, vabs, vneg, vldm, vldmia, vldbdb, vstm,
	vstmia, vstmdb, vldr, vstr, vcvt, vmov. Group shared VFP/Neon insns
	together.

	* gas/testsuite/gas/arm/itblock.s: New file. Helper macro for making
	all-true IT blocks.
	* gas/testsuite/gas/arm/neon-cond-bad-inc.s: New test. Make sure
	unconditional Neon instructions are rejected...
	* gas/testsuite/gas/arm/neon-cond-bad.s: In ARM mode, and...
	* gas/testsuite/gas/arm/neon-cond-bad_t2.s: Accepted in Thumb mode
	(with IT).
	* gas/testsuite/gas/arm/neon-cond-bad.l: Expected error output in ARM
	mode.
	* gas/testsuite/gas/arm/neon-cond-bad.d: Control ARM mode test.
	* gas/testsuite/gas/arm/neon-cond-bad_t2.d: Expected output in Thumb
	mode.
	* gas/testsuite/gas/arm/vfp-neon-syntax-inc.s: Test VFP Neon-style
	syntax.
	* gas/testsuite/gas/arm/vfp-neon-syntax.s: ...in ARM mode.
	* gas/testsuite/gas/arm/vfp-neon-syntax_t2.s: ...and Thumb mode.
	* gas/testsuite/gas/arm/vfp-neon-syntax.d: Expected output in ARM mode.
	* gas/testsuite/gas/arm/vfp-neon-syntax_t2.d: Expected output in Thumb
	mode.
@
text
@a29 1
#include <stdarg.h>
a297 4
  /* "uncond_value" is set to the value in place of the conditional field in
     unconditional versions of the instruction, or -1 if nothing is
     appropriate.  */
  int		uncond_value;
a321 1
    unsigned isvec      : 1;  /* Is a single, double or quad VFP/Neon reg.  */
a322 1
    unsigned issingle   : 1;  /* Operand is VFP single-precision register.  */
a430 1
  REG_TYPE_VFSD,
a431 1
  REG_TYPE_NSDQ,
a467 1
  N_("VFP single or double precision register expected"),
a468 1
  N_("VFP single, double or Neon quad precision register expected"),
a633 1
#define BAD_FPU		_("selected FPU does not support instruction")
a1112 5
        case 'd':
          thistype = NT_float;
          thissize = 64;
          ptr++;
          goto done;
a1135 1
      done:
d1236 3
a1238 8
  /* Undo polymorphism when a set of register types may be accepted.  */
  if ((type == REG_TYPE_NDQ
       && (reg->type == REG_TYPE_NQ || reg->type == REG_TYPE_VFD))
      || (type == REG_TYPE_VFSD
          && (reg->type == REG_TYPE_VFS || reg->type == REG_TYPE_VFD))
      || (type == REG_TYPE_NSDQ
          && (reg->type == REG_TYPE_VFS || reg->type == REG_TYPE_VFD
              || reg->type == REG_TYPE_NQ)))
d1528 1
a1528 1
parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)
a1529 1
  char *str = *ccp;
d1539 1
a1539 1
  if (*str != '{')
d1545 1
a1545 1
  str++;
d1586 1
a1586 1
      new_base = arm_typed_reg_parse (&str, regtype, &regtype, NULL);
d1625 1
a1625 1
      if (*str == '-') /* We have the start of a range expression */
d1629 1
a1629 1
	  str++;
d1631 1
a1631 1
	  if ((high_range = arm_typed_reg_parse (&str, regtype, NULL, NULL))
d1666 1
a1666 1
  while (skip_past_comma (&str) != FAIL);
d1668 1
a1668 1
  str++;
a1686 2
  *ccp = str;

d4743 3
a4745 2
   Up to four operands may be read; this function handles setting the
   ".present" field for each read operand itself.
d4775 1
a4775 1
  else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NSDQ, &rtype, &optype))
a4784 2
      inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
      inst.operands[i].isvec = 1;
d4790 2
a4791 2
          /* Case 5: VMOV<c><q> <Dm>, <Rd>, <Rn>.
             Case 13: VMOV <Sd>, <Rm>  */
d4794 1
a4794 1
          inst.operands[i].present = 1;
d4801 7
a4807 11
          else if (rtype != REG_TYPE_VFS)
            {
              i++;
              if (skip_past_comma (&ptr) == FAIL)
                goto wanted_comma;
              if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
                goto wanted_arm;
              inst.operands[i].reg = val;
              inst.operands[i].isreg = 1;
              inst.operands[i].present = 1;
            }
d4810 1
d4812 4
a4815 4
             Case 3: VMOV<c><q>.<dt> <Dd>, #<float-imm>
             Case 10: VMOV.F32 <Sd>, #<imm>
             Case 11: VMOV.F64 <Dd>, #<imm>  */
        ;
d4817 1
d4820 5
a4824 3
        ;
      else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NSDQ, &rtype,
                                           &optype)) != FAIL)
d4827 3
a4829 3
             Case 1: VMOV<c><q> <Dd>, <Dm>
             Case 8: VMOV.F32 <Sd>, <Sm>
             Case 15: VMOV <Sd>, <Se>, <Rn>, <Rm>  */
a4833 2
          inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
          inst.operands[i].isvec = 1;
a4835 23
          
          if (skip_past_comma (&ptr) == SUCCESS)
            {
              /* Case 15.  */
              i++;

              if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
                goto wanted_arm;

              inst.operands[i].reg = val;
              inst.operands[i].isreg = 1;
              inst.operands[i++].present = 1;
              
              if (skip_past_comma (&ptr) == FAIL)
                goto wanted_comma;
              
              if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
                goto wanted_arm;
              
              inst.operands[i].reg = val;
              inst.operands[i].isreg = 1;
              inst.operands[i++].present = 1;
            }
d4871 1
a4871 1
          if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFSD, &rtype, &optype))
d4874 1
a4874 1
              first_error (_(reg_expected_msgs[REG_TYPE_VFSD]));
d4880 1
a4880 2
          inst.operands[i].isvec = 1;
          inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
a4882 31
          
          if (rtype == REG_TYPE_VFS)
            {
              /* Case 14.  */
              i++;
              if (skip_past_comma (&ptr) == FAIL)
                goto wanted_comma;
              if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL,
                                              &optype)) == FAIL)
                {
                  first_error (_(reg_expected_msgs[REG_TYPE_VFS]));
                  return FAIL;
                }
              inst.operands[i].reg = val;
              inst.operands[i].isreg = 1;
              inst.operands[i].isvec = 1;
              inst.operands[i].issingle = 1;
              inst.operands[i].vectype = optype;
              inst.operands[i].present = 1;
            }
        }
      else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL, &optype))
               != FAIL)
        {
          /* Case 13.  */
          inst.operands[i].reg = val;
          inst.operands[i].isreg = 1;
          inst.operands[i].isvec = 1;
          inst.operands[i].issingle = 1;
          inst.operands[i].vectype = optype;
          inst.operands[i++].present = 1;
d4903 4
a4924 1
  OP_RVSD,	/* VFP single or double precision register */
a4925 1
  OP_RNSDQ,	/* Neon single, double or quad precision register */
a4941 1
  OP_VRSDLST,   /* VFP single or double-precision register list (& quad) */
a4946 1
  OP_RVSD_I0,	/* VFP S or D reg, or immediate zero.  */
a4947 1
  OP_RNSDQ_RNSC, /* Vector S, D or Q reg, or Neon scalar.  */
a4986 3
  OP_RVC_PSR,	/* CPSR/SPSR mask for msr, or VFP control register.  */
  OP_APSR_RR,   /* ARM register or "APSR_nzcv".  */

a5004 1
  OP_oRNSDQ,	 /* Optional single, double or quad precision vector register */
a5042 4
  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);		\
  inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\
                            || rtype == REG_TYPE_VFD		\
                            || rtype == REG_TYPE_NQ);		\
a5053 4
  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);		\
  inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\
                            || rtype == REG_TYPE_VFD		\
                            || rtype == REG_TYPE_NQ);		\
a5119 3
        case OP_RVSD:  po_reg_or_fail (REG_TYPE_VFSD);    break;
        case OP_oRNSDQ:
        case OP_RNSDQ: po_reg_or_fail (REG_TYPE_NSDQ);    break;
a5157 4
        case OP_RVSD_I0:
          po_reg_or_goto (REG_TYPE_VFSD, try_imm0);
          break;

a5166 9
        case OP_RNSDQ_RNSC:
          {
            po_scalar_or_goto (8, try_nsdq);
            break;
            try_nsdq:
            po_reg_or_fail (REG_TYPE_NSDQ);
          }
          break;

a5355 35
        case OP_RVC_PSR:
          po_reg_or_goto (REG_TYPE_VFC, try_psr);
          inst.operands[i].isvec = 1;  /* Mark VFP control reg as vector.  */
          break;
          try_psr:
          val = parse_psr (&str);
          break;

        case OP_APSR_RR:
          po_reg_or_goto (REG_TYPE_RN, try_apsr);
          break;
          try_apsr:
          /* Parse "APSR_nvzc" operand (for FMSTAT-equivalent MRS
             instruction).  */
          if (strncasecmp (str, "APSR_", 5) == 0)
            {
              unsigned found = 0;
              str += 5;
              while (found < 15)
                switch (*str++)
                  {
                  case 'c': found = (found & 1) ? 16 : found | 1; break;
                  case 'n': found = (found & 2) ? 16 : found | 2; break;
                  case 'z': found = (found & 4) ? 16 : found | 4; break;
                  case 'v': found = (found & 8) ? 16 : found | 8; break;
                  default: found = 16;
                  }
              if (found != 15)
                goto failure;
              inst.operands[i].isvec = 1;
            }
          else
            goto failure;
          break;

a5377 13
        case OP_VRSDLST:
          /* Allow Q registers too.  */
          val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
                                    REGLIST_NEON_D);
          if (val == FAIL)
            {
              inst.error = NULL;
              val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
                                        REGLIST_VFP_S);
              inst.operands[i].issingle = 1;
            }
          break;

a5430 1
        case OP_RVC_PSR:
a5435 1
        case OP_VRSDLST:
a6502 32
static void do_vfp_nsyn_opcode (const char *);

static int
do_vfp_nsyn_mrs (void)
{
  if (inst.operands[0].isvec)
    {
      if (inst.operands[1].reg != 1)
        first_error (_("operand 1 must be FPSCR"));
      memset (&inst.operands[0], '\0', sizeof (inst.operands[0]));
      memset (&inst.operands[1], '\0', sizeof (inst.operands[1]));
      do_vfp_nsyn_opcode ("fmstat");
    }
  else if (inst.operands[1].isvec)
    do_vfp_nsyn_opcode ("fmrx");
  else
    return FAIL;
    
  return SUCCESS;
}

static int
do_vfp_nsyn_msr (void)
{
  if (inst.operands[0].isvec)
    do_vfp_nsyn_opcode ("fmxr");
  else
    return FAIL;

  return SUCCESS;
}

a6505 3
  if (do_vfp_nsyn_mrs () == SUCCESS)
    return;

a6520 3
  if (do_vfp_nsyn_msr () == SUCCESS)
    return;

a7197 1

a8864 4

  if (do_vfp_nsyn_mrs () == SUCCESS)
    return;

a8891 3
  if (do_vfp_nsyn_msr () == SUCCESS)
    return;

d9539 1
a9539 8
  X(vqmovun,	0x1b20240, N_INV,     N_INV),		\
  X(vnmul,      0xe200a40, 0xe200b40, N_INV),		\
  X(vnmla,      0xe000a40, 0xe000b40, N_INV),		\
  X(vnmls,      0xe100a40, 0xe100b40, N_INV),		\
  X(vcmp,	0xeb40a40, 0xeb40b40, N_INV),		\
  X(vcmpz,	0xeb50a40, 0xeb50b40, N_INV),		\
  X(vcmpe,	0xeb40ac0, 0xeb40bc0, N_INV),		\
  X(vcmpez,     0xeb50ac0, 0xeb50bc0, N_INV)
a9563 4
#define NEON_ENC_SINGLE(X) \
  ((neon_enc_tab[(X) & 0x0fffffff].integer) | ((X) & 0xf0000000))
#define NEON_ENC_DOUBLE(X) \
  ((neon_enc_tab[(X) & 0x0fffffff].float_or_poly) | ((X) & 0xf0000000))
d9565 3
a9567 2
/* Define shapes for instruction operands. The following mnemonic characters
   are used in this table:
a9568 1
     F - VFP S<n> register
a9574 6
   
   This table is used to generate various data:
     - enumerations of the form NS_DDR to be used as arguments to
       neon_select_shape.
     - a table classifying shapes into single, double, quad, mixed.
     - a table used to drive neon_select_shape.
a9576 48
#define NEON_SHAPE_DEF			\
  X(3, (D, D, D), DOUBLE),		\
  X(3, (Q, Q, Q), QUAD),		\
  X(3, (D, D, I), DOUBLE),		\
  X(3, (Q, Q, I), QUAD),		\
  X(3, (D, D, S), DOUBLE),		\
  X(3, (Q, Q, S), QUAD),		\
  X(2, (D, D), DOUBLE),			\
  X(2, (Q, Q), QUAD),			\
  X(2, (D, S), DOUBLE),			\
  X(2, (Q, S), QUAD),			\
  X(2, (D, R), DOUBLE),			\
  X(2, (Q, R), QUAD),			\
  X(2, (D, I), DOUBLE),			\
  X(2, (Q, I), QUAD),			\
  X(3, (D, L, D), DOUBLE),		\
  X(2, (D, Q), MIXED),			\
  X(2, (Q, D), MIXED),			\
  X(3, (D, Q, I), MIXED),		\
  X(3, (Q, D, I), MIXED),		\
  X(3, (Q, D, D), MIXED),		\
  X(3, (D, Q, Q), MIXED),		\
  X(3, (Q, Q, D), MIXED),		\
  X(3, (Q, D, S), MIXED),		\
  X(3, (D, Q, S), MIXED),		\
  X(4, (D, D, D, I), DOUBLE),		\
  X(4, (Q, Q, Q, I), QUAD),		\
  X(2, (F, F), SINGLE),			\
  X(3, (F, F, F), SINGLE),		\
  X(2, (F, I), SINGLE),			\
  X(2, (F, D), MIXED),			\
  X(2, (D, F), MIXED),			\
  X(3, (F, F, I), MIXED),		\
  X(4, (R, R, F, F), SINGLE),		\
  X(4, (F, F, R, R), SINGLE),		\
  X(3, (D, R, R), DOUBLE),		\
  X(3, (R, R, D), DOUBLE),		\
  X(2, (S, R), SINGLE),			\
  X(2, (R, S), SINGLE),			\
  X(2, (F, R), SINGLE),			\
  X(2, (R, F), SINGLE)

#define S2(A,B)		NS_##A##B
#define S3(A,B,C)	NS_##A##B##C
#define S4(A,B,C,D)	NS_##A##B##C##D

#define X(N, L, C) S##N L

d9579 34
a9612 47
  NEON_SHAPE_DEF,
  NS_NULL
};

#undef X
#undef S2
#undef S3
#undef S4

enum neon_shape_class
{
  SC_SINGLE,
  SC_DOUBLE,
  SC_QUAD,
  SC_MIXED
};

#define X(N, L, C) SC_##C

static enum neon_shape_class neon_shape_class[] =
{
  NEON_SHAPE_DEF
};

#undef X

enum neon_shape_el
{
  SE_F,
  SE_D,
  SE_Q,
  SE_I,
  SE_S,
  SE_R,
  SE_L
};

/* Register widths of above.  */
static unsigned neon_shape_el_size[] =
{
  32,
  64,
  128,
  0,
  32,
  32,
  0
a9614 22
struct neon_shape_info
{
  unsigned els;
  enum neon_shape_el el[NEON_MAX_TYPE_ELS];
};

#define S2(A,B)		{ SE_##A, SE_##B }
#define S3(A,B,C)	{ SE_##A, SE_##B, SE_##C }
#define S4(A,B,C,D)	{ SE_##A, SE_##B, SE_##C, SE_##D }

#define X(N, L, C) { N, S##N L }

static struct neon_shape_info neon_shape_tab[] =
{
  NEON_SHAPE_DEF
};

#undef X
#undef S2
#undef S3
#undef S4

d9642 2
a9643 4
  N_F64  = 0x080000,
  N_KEY  = 0x100000, /* key element (main type specifier).  */
  N_EQK  = 0x200000, /* given operand has the same type & size as the key.  */
  N_VFP  = 0x400000, /* VFP mode: operand size must match register width.  */
d9652 1
a9652 1
  N_MAX_NONSPECIAL = N_F64
d9668 3
a9670 5
/* Select a "shape" for the current instruction (describing register types or
   sizes) from a list of alternatives. Return NS_NULL if the current instruction
   doesn't fit. For non-polymorphic shapes, checking is usually done as a
   function of operand parsing, so this function doesn't need to be called.
   Shapes should be listed in order of decreasing length.  */
d9673 1
a9673 1
neon_select_shape (enum neon_shape shape, ...)
d9675 5
a9679 2
  va_list ap;
  enum neon_shape first_shape = shape;
d9688 25
a9712 1
  va_start (ap, shape);
d9714 10
a9723 62
  for (; shape != NS_NULL; shape = va_arg (ap, int))
    {
      unsigned j;
      int matches = 1;

      for (j = 0; j < neon_shape_tab[shape].els; j++)
        {
          if (!inst.operands[j].present)
            {
              matches = 0;
              break;
            }

          switch (neon_shape_tab[shape].el[j])
            {
            case SE_F:
              if (!(inst.operands[j].isreg
                    && inst.operands[j].isvec
                    && inst.operands[j].issingle
                    && !inst.operands[j].isquad))
                matches = 0;
              break;

            case SE_D:
              if (!(inst.operands[j].isreg
                    && inst.operands[j].isvec
                    && !inst.operands[j].isquad
                    && !inst.operands[j].issingle))
                matches = 0;
              break;

            case SE_R:
              if (!(inst.operands[j].isreg
                    && !inst.operands[j].isvec))
                matches = 0;
              break;

            case SE_Q:
              if (!(inst.operands[j].isreg
                    && inst.operands[j].isvec
                    && inst.operands[j].isquad
                    && !inst.operands[j].issingle))
                matches = 0;
              break;

            case SE_I:
              if (!(!inst.operands[j].isreg
                    && !inst.operands[j].isscalar))
                matches = 0;
              break;

            case SE_S:
              if (!(!inst.operands[j].isreg
                    && inst.operands[j].isscalar))
                matches = 0;
              break;

            case SE_L:
              break;
            }
        }
      if (matches)
a9724 1
    }
d9726 33
a9758 1
  va_end (ap);
d9760 10
a9769 2
  if (shape == NS_NULL && first_shape != NS_NULL)
    first_error (_("invalid instruction shape"));
d9771 14
a9784 2
  return shape;
}
d9786 6
a9791 7
/* True if SHAPE is predominantly a quadword operation (most of the time, this
   means the Q bit should be set).  */

static int
neon_quad (enum neon_shape shape)
{
  return neon_shape_class[shape] == SC_QUAD;
d9793 1
a9793 1

d9865 2
a9866 6
      switch (size)
        {
        case 32: return N_F32;
        case 64: return N_F64;
        default: ;
        }
d9922 1
a9922 1
  else if ((mask & (N_S64 | N_U64 | N_I64 | N_64 | N_F64)) != 0)
d9937 1
a9937 1
  else if ((mask & (N_F32 | N_F64)) != 0)
d9980 2
a9981 1
   Neon instructions should call it before performing bit encoding.  */
a10101 20
              if ((thisarg & N_VFP) != 0)
                {
                  enum neon_shape_el regshape = neon_shape_tab[ns].el[i];
                  unsigned regwidth = neon_shape_el_size[regshape], match;

                  /* In VFP mode, operands must match register widths. If we
                     have a key operand, use its width, else use the width of
                     the current operand.  */
                  if (k_size != -1u)
                    match = k_size;
                  else
                    match = g_size;

                  if (regwidth != match)
                    {
                      first_error (_("operand size must match register width"));
                      return badtype;
                    }
                }
            
d10130 2
a10131 1
/* Neon-style VFP instruction forwarding.  */
d10133 2
a10134 4
/* Thumb VFP instructions have 0xE in the condition field.  */

static void
do_vfp_cond_or_thumb (void)
d10137 9
a10145 1
    inst.instruction |= 0xe0000000;
d10147 3
a10149 1
    inst.instruction |= inst.cond << 28;
d10152 2
a10153 7
/* Look up and encode a simple mnemonic, for use as a helper function for the
   Neon-style VFP syntax.  This avoids duplication of bits of the insns table,
   etc.  It is assumed that operand parsing has already been done, and that the
   operands are in the form expected by the given opcode (this isn't necessarily
   the same as the form in which they were parsed, hence some massaging must
   take place before this function is called).
   Checks current arch version against that in the looked-up opcode.  */
d10155 2
a10156 2
static void
do_vfp_nsyn_opcode (const char *opname)
d10158 2
a10159 3
  const struct asm_opcode *opcode;
  
  opcode = hash_find (arm_ops_hsh, opname);
d10161 2
a10162 2
  if (!opcode)
    abort ();
d10164 1
a10164 3
  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant,
                thumb_mode ? *opcode->tvariant : *opcode->avariant),
              _(BAD_FPU));
d10166 5
a10170 11
  if (thumb_mode)
    {
      inst.instruction = opcode->tvalue;
      opcode->tencode ();
    }
  else
    {
      inst.instruction = (inst.cond << 28) | opcode->avalue;
      opcode->aencode ();
    }
}
d10173 1
a10173 1
do_vfp_nsyn_add_sub (enum neon_shape rs)
d10175 15
a10189 1
  int is_add = (inst.instruction & 0x0fffffff) == N_MNEM_vadd;
d10191 1
a10191 326
  if (rs == NS_FFF)
    {
      if (is_add)
        do_vfp_nsyn_opcode ("fadds");
      else
        do_vfp_nsyn_opcode ("fsubs");
    }
  else
    {
      if (is_add)
        do_vfp_nsyn_opcode ("faddd");
      else
        do_vfp_nsyn_opcode ("fsubd");
    }
}

/* Check operand types to see if this is a VFP instruction, and if so call
   PFN ().  */

static int
try_vfp_nsyn (int args, void (*pfn) (enum neon_shape))
{
  enum neon_shape rs;
  struct neon_type_el et;

  switch (args)
    {
    case 2:
      rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
      et = neon_check_type (2, rs,
        N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
      break;
    
    case 3:
      rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
      et = neon_check_type (3, rs,
        N_EQK | N_VFP, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
      break;

    default:
      abort ();
    }

  if (et.type != NT_invtype)
    {
      pfn (rs);
      return SUCCESS;
    }
  else
    inst.error = NULL;

  return FAIL;
}

static void
do_vfp_nsyn_mla_mls (enum neon_shape rs)
{
  int is_mla = (inst.instruction & 0x0fffffff) == N_MNEM_vmla;
  
  if (rs == NS_FFF)
    {
      if (is_mla)
        do_vfp_nsyn_opcode ("fmacs");
      else
        do_vfp_nsyn_opcode ("fmscs");
    }
  else
    {
      if (is_mla)
        do_vfp_nsyn_opcode ("fmacd");
      else
        do_vfp_nsyn_opcode ("fmscd");
    }
}

static void
do_vfp_nsyn_mul (enum neon_shape rs)
{
  if (rs == NS_FFF)
    do_vfp_nsyn_opcode ("fmuls");
  else
    do_vfp_nsyn_opcode ("fmuld");
}

static void
do_vfp_nsyn_abs_neg (enum neon_shape rs)
{
  int is_neg = (inst.instruction & 0x80) != 0;
  neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_VFP | N_KEY);

  if (rs == NS_FF)
    {
      if (is_neg)
        do_vfp_nsyn_opcode ("fnegs");
      else
        do_vfp_nsyn_opcode ("fabss");
    }
  else
    {
      if (is_neg)
        do_vfp_nsyn_opcode ("fnegd");
      else
        do_vfp_nsyn_opcode ("fabsd");
    }
}

/* Encode single-precision (only!) VFP fldm/fstm instructions. Double precision
   insns belong to Neon, and are handled elsewhere.  */

static void
do_vfp_nsyn_ldm_stm (int is_dbmode)
{
  int is_ldm = (inst.instruction & (1 << 20)) != 0;
  if (is_ldm)
    {
      if (is_dbmode)
        do_vfp_nsyn_opcode ("fldmdbs");
      else
        do_vfp_nsyn_opcode ("fldmias");
    }
  else
    {
      if (is_dbmode)
        do_vfp_nsyn_opcode ("fstmdbs");
      else
        do_vfp_nsyn_opcode ("fstmias");
    }
}

static void
do_vfp_nsyn_ldr_str (int is_ldr)
{
  if (is_ldr)
    do_vfp_nsyn_opcode ("flds");
  else
    do_vfp_nsyn_opcode ("fsts");
}

static void
do_vfp_nsyn_sqrt (void)
{
  enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
  neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
      
  if (rs == NS_FF)
    do_vfp_nsyn_opcode ("fsqrts");
  else
    do_vfp_nsyn_opcode ("fsqrtd");
}

static void
do_vfp_nsyn_div (void)
{
  enum neon_shape rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
  neon_check_type (3, rs, N_EQK | N_VFP, N_EQK | N_VFP,
    N_F32 | N_F64 | N_KEY | N_VFP);
  
  if (rs == NS_FFF)
    do_vfp_nsyn_opcode ("fdivs");
  else
    do_vfp_nsyn_opcode ("fdivd");
}

static void
do_vfp_nsyn_nmul (void)
{
  enum neon_shape rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
  neon_check_type (3, rs, N_EQK | N_VFP, N_EQK | N_VFP,
    N_F32 | N_F64 | N_KEY | N_VFP);
  
  if (rs == NS_FFF)
    {
      inst.instruction = NEON_ENC_SINGLE (inst.instruction);
      do_vfp_sp_dyadic ();
    }
  else
    {
      inst.instruction = NEON_ENC_DOUBLE (inst.instruction);
      do_vfp_dp_rd_rn_rm ();
    }
  do_vfp_cond_or_thumb ();
}

static void
do_vfp_nsyn_cmp (void)
{
  if (inst.operands[1].isreg)
    {
      enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
      neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
      
      if (rs == NS_FF)
        {
          inst.instruction = NEON_ENC_SINGLE (inst.instruction);
          do_vfp_sp_monadic ();
        }
      else
        {
          inst.instruction = NEON_ENC_DOUBLE (inst.instruction);
          do_vfp_dp_rd_rm ();
        }
    }
  else
    {
      enum neon_shape rs = neon_select_shape (NS_FI, NS_DI, NS_NULL);
      neon_check_type (2, rs, N_F32 | N_F64 | N_KEY | N_VFP, N_EQK);

      switch (inst.instruction & 0x0fffffff)
        {
        case N_MNEM_vcmp:
          inst.instruction += N_MNEM_vcmpz - N_MNEM_vcmp;
          break;
        case N_MNEM_vcmpe:
          inst.instruction += N_MNEM_vcmpez - N_MNEM_vcmpe;
          break;
        default:
          abort ();
        }
     
      if (rs == NS_FI)
        {
          inst.instruction = NEON_ENC_SINGLE (inst.instruction);
          do_vfp_sp_compare_z ();
        }
      else
        {
          inst.instruction = NEON_ENC_DOUBLE (inst.instruction);
          do_vfp_dp_rd ();
        }
    }
  do_vfp_cond_or_thumb ();
}

static void
nsyn_insert_sp (void)
{
  inst.operands[1] = inst.operands[0];
  memset (&inst.operands[0], '\0', sizeof (inst.operands[0]));
  inst.operands[0].reg = 13;
  inst.operands[0].isreg = 1;
  inst.operands[0].writeback = 1;
  inst.operands[0].present = 1;
}

static void
do_vfp_nsyn_push (void)
{
  nsyn_insert_sp ();
  if (inst.operands[1].issingle)
    do_vfp_nsyn_opcode ("fstmdbs");
  else
    do_vfp_nsyn_opcode ("fstmdbd");
}

static void
do_vfp_nsyn_pop (void)
{
  nsyn_insert_sp ();
  if (inst.operands[1].issingle)
    do_vfp_nsyn_opcode ("fldmdbs");
  else
    do_vfp_nsyn_opcode ("fldmdbd");
}

/* Fix up Neon data-processing instructions, ORing in the correct bits for
   ARM mode or Thumb mode and moving the encoded bit 24 to bit 28.  */

static unsigned
neon_dp_fixup (unsigned i)
{
  if (thumb_mode)
    {
      /* The U bit is at bit 24 by default. Move to bit 28 in Thumb mode.  */
      if (i & (1 << 24))
        i |= 1 << 28;
      
      i &= ~(1 << 24);
      
      i |= 0xef000000;
    }
  else
    i |= 0xf2000000;
  
  return i;
}

/* Turn a size (8, 16, 32, 64) into the respective bit number minus 3
   (0, 1, 2, 3).  */

static unsigned
neon_logbits (unsigned x)
{
  return ffs (x) - 4;
}

#define LOW4(R) ((R) & 0xf)
#define HI1(R) (((R) >> 4) & 1)

/* Encode insns with bit pattern:

  |28/24|23|22 |21 20|19 16|15 12|11    8|7|6|5|4|3  0|
  |  U  |x |D  |size | Rn  | Rd  |x x x x|N|Q|M|x| Rm |
  
  SIZE is passed in bits. -1 means size field isn't changed, in case it has a
  different meaning for some instruction.  */

static void
neon_three_same (int isquad, int ubit, int size)
{
  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
  inst.instruction |= LOW4 (inst.operands[2].reg);
  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
  inst.instruction |= (isquad != 0) << 6;
  inst.instruction |= (ubit != 0) << 24;
  if (size != -1)
    inst.instruction |= neon_logbits (size) << 20;
  
  inst.instruction = neon_dp_fixup (inst.instruction);
}

/* Encode instructions of the form:

  |28/24|23|22|21 20|19 18|17 16|15 12|11      7|6|5|4|3  0|
d10217 1
a10217 1
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10220 1
a10220 1
  neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
d10226 1
a10226 1
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10229 1
a10229 1
  neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
d10256 1
a10256 1
      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
d10259 1
a10259 1
      neon_imm_shift (FALSE, 0, neon_quad (rs), et, inst.operands[2].imm);
d10263 1
a10263 1
      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10267 1
a10267 1
      neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
d10276 1
a10276 1
      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
d10279 1
a10279 1
      neon_imm_shift (TRUE, et.type == NT_unsigned, neon_quad (rs), et,
d10284 1
a10284 1
      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10288 1
a10288 1
      neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
d10506 1
a10506 1
      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10510 1
a10510 1
      neon_three_same (neon_quad (rs), 0, -1);
d10514 3
a10516 3
      enum neon_shape rs = neon_select_shape (NS_DI, NS_QI, NS_NULL);
      struct neon_type_el et = neon_check_type (2, rs,
        N_I8 | N_I16 | N_I32 | N_I64 | N_F32 | N_KEY, N_EQK);
d10559 1
a10559 1
      inst.instruction |= neon_quad (rs) << 6;
d10572 1
a10572 1
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10574 1
a10574 1
  neon_three_same (neon_quad (rs), 0, -1);
d10581 1
a10581 1
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10587 1
a10587 1
      neon_three_same (neon_quad (rs), 0, -1);
d10592 1
a10592 1
      neon_three_same (neon_quad (rs), et.type == ubit_meaning, et.size);
a10621 50
enum vfp_or_neon_is_neon_bits
{
  NEON_CHECK_CC = 1,
  NEON_CHECK_ARCH = 2
};

/* Call this function if an instruction which may have belonged to the VFP or
   Neon instruction sets, but turned out to be a Neon instruction (due to the
   operand types involved, etc.). We have to check and/or fix-up a couple of
   things:

     - Make sure the user hasn't attempted to make a Neon instruction
       conditional.
     - Alter the value in the condition code field if necessary.
     - Make sure that the arch supports Neon instructions.

   Which of these operations take place depends on bits from enum
   vfp_or_neon_is_neon_bits.

   WARNING: This function has side effects! If NEON_CHECK_CC is used and the
   current instruction's condition is COND_ALWAYS, the condition field is
   changed to inst.uncond_value. This is necessary because instructions shared
   between VFP and Neon may be conditional for the VFP variants only, and the
   unconditional Neon version must have, e.g., 0xF in the condition field.  */

static int
vfp_or_neon_is_neon (unsigned check)
{
  /* Conditions are always legal in Thumb mode (IT blocks).  */
  if (!thumb_mode && (check & NEON_CHECK_CC))
    {
      if (inst.cond != COND_ALWAYS)
        {
          first_error (_(BAD_COND));
          return FAIL;
        }
      if (inst.uncond_value != -1)
        inst.instruction |= inst.uncond_value << 28;
    }
  
  if ((check & NEON_CHECK_ARCH)
      && !ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1))
    {
      first_error (_(BAD_FPU));
      return FAIL;
    }
  
  return SUCCESS;
}

a10624 6
  if (try_vfp_nsyn (3, do_vfp_nsyn_add_sub) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

d10668 1
a10668 1
      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
d10677 1
a10677 1
      inst.instruction |= neon_quad (rs) << 6;
a10762 6
  if (try_vfp_nsyn (3, do_vfp_nsyn_mla_mls) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

d10765 1
a10765 1
      enum neon_shape rs = neon_select_shape (NS_DDS, NS_QQS, NS_NULL);
d10769 1
a10769 1
      neon_mul_mac (et, neon_quad (rs));
d10778 1
a10778 1
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10781 1
a10781 1
  neon_three_same (neon_quad (rs), 0, et.size);
a10790 6
  if (try_vfp_nsyn (3, do_vfp_nsyn_mul) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

d10802 1
a10802 1
      enum neon_shape rs = neon_select_shape (NS_DDS, NS_QQS, NS_NULL);
d10806 1
a10806 1
      neon_mul_mac (et, neon_quad (rs));
d10810 1
a10810 1
      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10815 1
a10815 1
      neon_three_same (neon_quad (rs), 0, et.size);
d10822 1
a10822 1
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10825 1
a10825 1
  neon_three_same (neon_quad (rs), 1, -1);
d10838 1
a10838 1
  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
d10840 1
a10840 1
  neon_three_same (neon_quad (rs), 0, -1);
d10846 3
a10848 12
  enum neon_shape rs;
  struct neon_type_el et;
  
  if (try_vfp_nsyn (2, do_vfp_nsyn_abs_neg) == SUCCESS)
    return;

  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
    return;

  rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  et = neon_check_type (2, rs, N_EQK, N_S8 | N_S16 | N_S32 | N_F32 | N_KEY);
  
d10853 1
a10853 1
  inst.instruction |= neon_quad (rs) << 6;
d10863 1
a10863 1
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
d10869 1
a10869 1
  neon_imm_shift (FALSE, 0, neon_quad (rs), et, imm);
d10875 1
a10875 1
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
d10881 1
a10881 1
  neon_imm_shift (FALSE, 0, neon_quad (rs), et, et.size - imm);
d10887 1
a10887 1
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
d10898 1
a10898 1
  neon_imm_shift (FALSE, 0, neon_quad (rs), et, imm);
d11047 1
a11047 1
/* Check the various types for the VCVT instruction, and return which version
d11053 6
a11058 6
#define CVT_VAR(C,X,Y)							\
  et = neon_check_type (2, rs, whole_reg | (X), whole_reg | (Y));	\
  if (et.type != NT_invtype)						\
    {									\
      inst.error = NULL;						\
      return (C);							\
a11060 7
  unsigned whole_reg = (rs == NS_FFI || rs == NS_FD || rs == NS_DF
                        || rs == NS_FF) ? N_VFP : 0;
  /* The instruction versions which take an immediate take one register
     argument, which is extended to the width of the full register. Thus the
     "source" and "destination" registers must have the same width.  Hack that
     here by making the size equal to the key (wider, in this case) operand.  */
  unsigned key = (rs == NS_QQI || rs == NS_DDI || rs == NS_FFI) ? N_KEY : 0;
a11066 19
  whole_reg = N_VFP;
  
  /* VFP instructions.  */
  CVT_VAR (4, N_F32, N_F64);
  CVT_VAR (5, N_F64, N_F32);
  CVT_VAR (6, N_S32, N_F64 | key);
  CVT_VAR (7, N_U32, N_F64 | key);
  CVT_VAR (8, N_F64 | key, N_S32);
  CVT_VAR (9, N_F64 | key, N_U32);
  /* VFP instructions with bitshift.  */
  CVT_VAR (10, N_F32 | key, N_S16);
  CVT_VAR (11, N_F32 | key, N_U16);
  CVT_VAR (12, N_F64 | key, N_S16);
  CVT_VAR (13, N_F64 | key, N_U16);
  CVT_VAR (14, N_S16, N_F32 | key);
  CVT_VAR (15, N_U16, N_F32 | key);
  CVT_VAR (16, N_S16, N_F64 | key);
  CVT_VAR (17, N_U16, N_F64 | key);
  
a11070 2
/* Neon-syntax VFP conversions.  */

d11072 1
a11072 1
do_vfp_nsyn_cvt (enum neon_shape rs, int flavour)
d11074 18
a11091 35
  const char *opname = 0;
  
  if (rs == NS_DDI || rs == NS_QQI || rs == NS_FFI)
    {
      /* Conversions with immediate bitshift.  */
      const char *enc[] =
        {
          "ftosls",
          "ftouls",
          "fsltos",
          "fultos",
          NULL,
          NULL,
          "ftosld",
          "ftould",
          "fsltod",
          "fultod",
          "fshtos",
          "fuhtos",
          "fshtod",
          "fuhtod",
          "ftoshs",
          "ftouhs",
          "ftoshd",
          "ftouhd"
        };

      if (flavour >= 0 && flavour < (int) ARRAY_SIZE (enc))
        {
          opname = enc[flavour];
          constraint (inst.operands[0].reg != inst.operands[1].reg,
                      _("operands 0 and 1 must be the same register"));
          inst.operands[1] = inst.operands[2];
          memset (&inst.operands[2], '\0', sizeof (inst.operands[2]));
        }
d11095 12
a11106 115
      /* Conversions without bitshift.  */
      const char *enc[] =
        {
          "ftosis",
          "ftouis",
          "fsitos",
          "fuitos",
          "fcvtsd",
          "fcvtds",
          "ftosid",
          "ftouid",
          "fsitod",
          "fuitod"
        };

      if (flavour >= 0 && flavour < (int) ARRAY_SIZE (enc))
        opname = enc[flavour];
    }

  if (opname)
    do_vfp_nsyn_opcode (opname);
}

static void
do_vfp_nsyn_cvtz (void)
{
  enum neon_shape rs = neon_select_shape (NS_FF, NS_FD, NS_NULL);
  int flavour = neon_cvt_flavour (rs);
  const char *enc[] =
    {
      "ftosizs",
      "ftouizs",
      NULL,
      NULL,
      NULL,
      NULL,
      "ftosizd",
      "ftouizd"
    };

  if (flavour >= 0 && flavour < (int) ARRAY_SIZE (enc) && enc[flavour])
    do_vfp_nsyn_opcode (enc[flavour]);
}

static void
do_neon_cvt (void)
{
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_FFI, NS_DD, NS_QQ,
    NS_FD, NS_DF, NS_FF, NS_NULL);
  int flavour = neon_cvt_flavour (rs);

  /* VFP rather than Neon conversions.  */
  if (flavour >= 4)
    {
      do_vfp_nsyn_cvt (rs, flavour);
      return;
    }

  switch (rs)
    {
    case NS_DDI:
    case NS_QQI:
      {
        if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
          return;

        /* Fixed-point conversion with #0 immediate is encoded as an
           integer conversion.  */
        if (inst.operands[2].present && inst.operands[2].imm == 0)
          goto int_encode;
        unsigned immbits = 32 - inst.operands[2].imm;
        unsigned enctab[] = { 0x0000100, 0x1000100, 0x0, 0x1000000 };
        inst.instruction = NEON_ENC_IMMED (inst.instruction);
        if (flavour != -1)
          inst.instruction |= enctab[flavour];
        inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
        inst.instruction |= HI1 (inst.operands[0].reg) << 22;
        inst.instruction |= LOW4 (inst.operands[1].reg);
        inst.instruction |= HI1 (inst.operands[1].reg) << 5;
        inst.instruction |= neon_quad (rs) << 6;
        inst.instruction |= 1 << 21;
        inst.instruction |= immbits << 16;

        inst.instruction = neon_dp_fixup (inst.instruction);
      }
      break;

    case NS_DD:
    case NS_QQ:
    int_encode:
      {
        unsigned enctab[] = { 0x100, 0x180, 0x0, 0x080 };

        inst.instruction = NEON_ENC_INTEGER (inst.instruction);

        if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
          return;

        if (flavour != -1)
          inst.instruction |= enctab[flavour];

        inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
        inst.instruction |= HI1 (inst.operands[0].reg) << 22;
        inst.instruction |= LOW4 (inst.operands[1].reg);
        inst.instruction |= HI1 (inst.operands[1].reg) << 5;
        inst.instruction |= neon_quad (rs) << 6;
        inst.instruction |= 2 << 18;

        inst.instruction = neon_dp_fixup (inst.instruction);
      }
    break;

    default:
      /* Some VFP conversions go here (s32 <-> f32, u32 <-> f32).  */
      do_vfp_nsyn_cvt (rs, flavour);
d11108 1
d11114 3
a11116 3
  enum neon_shape rs = neon_select_shape (NS_DI, NS_QI, NS_NULL);
  struct neon_type_el et = neon_check_type (2, rs,
    N_I8 | N_I16 | N_I32 | N_I64 | N_F32 | N_KEY, N_EQK);
a11119 3
  constraint (et.type == NT_invtype,
              _("operand size must be specified for immediate VMOV"));

d11152 1
a11152 1
  inst.instruction |= neon_quad (rs) << 6;
d11163 1
a11163 1
      enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11170 1
a11170 1
      inst.instruction |= neon_quad (rs) << 6;
d11289 1
a11289 1
  enum neon_shape rs = neon_select_shape (NS_DDDI, NS_QQQI, NS_NULL);
d11299 1
a11299 1
  inst.instruction |= neon_quad (rs) << 6;
d11308 1
a11308 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11319 1
a11319 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11327 1
a11327 1
      enum neon_shape rs = neon_select_shape (NS_DS, NS_QS, NS_NULL);
a11333 4

      if (vfp_or_neon_is_neon (NEON_CHECK_CC) == FAIL)
        return;

d11339 1
a11339 1
      inst.instruction |= neon_quad (rs) << 6;
d11347 4
a11350 3
      enum neon_shape rs = neon_select_shape (NS_DR, NS_QR, NS_NULL);
      struct neon_type_el et = neon_check_type (2, rs,
        N_8 | N_16 | N_32 | N_KEY, N_EQK);
d11363 1
a11363 1
      inst.instruction |= neon_quad (rs) << 21;
d11366 4
a11369 1
      do_vfp_cond_or_thumb ();
a11387 14
     8. VMOV.F32 <Sd>, <Sm>
     9. VMOV.F64 <Dd>, <Dm>
   (VFP register moves.)
    10. VMOV.F32 <Sd>, #imm
    11. VMOV.F64 <Dd>, #imm
   (VFP float immediate load.)
    12. VMOV <Rd>, <Sm>
   (VFP single to ARM reg.)
    13. VMOV <Sd>, <Rm>
   (ARM reg to VFP single.)
    14. VMOV <Rd>, <Re>, <Sn>, <Sm>
   (Two ARM regs to two VFP singles.)
    15. VMOV <Sd>, <Se>, <Rn>, <Rm>
   (Two VFP singles to two ARM regs.)
d11389 4
a11392 2
   These cases can be disambiguated using neon_select_shape, except cases 1/9
   and 3/11 which depend on the operand type too.
d11406 4
a11409 5
  enum neon_shape rs = neon_select_shape (NS_RRFF, NS_FFRR, NS_DRR, NS_RRD,
    NS_QQ, NS_DD, NS_QI, NS_DI, NS_SR, NS_RS, NS_FF, NS_FI, NS_RF, NS_FR,
    NS_NULL);
  struct neon_type_el et;
  const char *ldconst = 0;
d11411 1
a11411 1
  switch (rs)
d11413 3
a11415 5
    case NS_DD:  /* case 1/9.  */
      et = neon_check_type (2, rs, N_EQK, N_F64 | N_KEY);
      /* It is not an error here if no type is given.  */
      inst.error = NULL;
      if (et.type == NT_float && et.size == 64)
d11417 31
a11447 2
          do_vfp_nsyn_opcode ("fcpyd");
          break;
d11449 19
a11467 1
      /* fall through.  */
d11469 7
a11475 15
    case NS_QQ:  /* case 0/1.  */
      {
        if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
          return;
        /* The architecture manual I have doesn't explicitly state which
           value the U bit should have for register->register moves, but
           the equivalent VORR instruction has U = 0, so do that.  */
        inst.instruction = 0x0200110;
        inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
        inst.instruction |= HI1 (inst.operands[0].reg) << 22;
        inst.instruction |= LOW4 (inst.operands[1].reg);
        inst.instruction |= HI1 (inst.operands[1].reg) << 5;
        inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
        inst.instruction |= HI1 (inst.operands[1].reg) << 7;
        inst.instruction |= neon_quad (rs) << 6;
d11477 29
a11505 8
        inst.instruction = neon_dp_fixup (inst.instruction);
      }
      break;
        
    case NS_DI:  /* case 3/11.  */
      et = neon_check_type (2, rs, N_EQK, N_F64 | N_KEY);
      inst.error = NULL;
      if (et.type == NT_float && et.size == 64)
d11507 4
a11510 3
          /* case 11 (fconstd).  */
          ldconst = "fconstd";
          goto encode_fconstd;
a11511 8
      /* fall through.  */

    case NS_QI:  /* case 2/3.  */
      if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
        return;
      inst.instruction = 0x0800010;
      neon_move_immediate ();
      inst.instruction = neon_dp_fixup (inst.instruction);
d11514 2
a11515 84
    case NS_SR:  /* case 4.  */
      {
        unsigned bcdebits = 0;
        struct neon_type_el et = neon_check_type (2, NS_NULL,
          N_8 | N_16 | N_32 | N_KEY, N_EQK);
        int logsize = neon_logbits (et.size);
        unsigned dn = NEON_SCALAR_REG (inst.operands[0].reg);
        unsigned x = NEON_SCALAR_INDEX (inst.operands[0].reg);

        constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
                    _(BAD_FPU));
        constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
                    && et.size != 32, _(BAD_FPU));
        constraint (et.type == NT_invtype, _("bad type for scalar"));
        constraint (x >= 64 / et.size, _("scalar index out of range"));

        switch (et.size)
          {
          case 8:  bcdebits = 0x8; break;
          case 16: bcdebits = 0x1; break;
          case 32: bcdebits = 0x0; break;
          default: ;
          }

        bcdebits |= x << logsize;

        inst.instruction = 0xe000b10;
        do_vfp_cond_or_thumb ();
        inst.instruction |= LOW4 (dn) << 16;
        inst.instruction |= HI1 (dn) << 7;
        inst.instruction |= inst.operands[1].reg << 12;
        inst.instruction |= (bcdebits & 3) << 5;
        inst.instruction |= (bcdebits >> 2) << 21;
      }
      break;
    
    case NS_DRR:  /* case 5 (fmdrr).  */
      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2),
                  _(BAD_FPU));

      inst.instruction = 0xc400b10;
      do_vfp_cond_or_thumb ();
      inst.instruction |= LOW4 (inst.operands[0].reg);
      inst.instruction |= HI1 (inst.operands[0].reg) << 5;
      inst.instruction |= inst.operands[1].reg << 12;
      inst.instruction |= inst.operands[2].reg << 16;
      break;
    
    case NS_RS:  /* case 6.  */
      {
        struct neon_type_el et = neon_check_type (2, NS_NULL,
          N_EQK, N_S8 | N_S16 | N_U8 | N_U16 | N_32 | N_KEY);
        unsigned logsize = neon_logbits (et.size);
        unsigned dn = NEON_SCALAR_REG (inst.operands[1].reg);
        unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg);
        unsigned abcdebits = 0;

        constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
                    _(BAD_FPU));
        constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
                    && et.size != 32, _(BAD_FPU));
        constraint (et.type == NT_invtype, _("bad type for scalar"));
        constraint (x >= 64 / et.size, _("scalar index out of range"));

        switch (et.size)
          {
          case 8:  abcdebits = (et.type == NT_signed) ? 0x08 : 0x18; break;
          case 16: abcdebits = (et.type == NT_signed) ? 0x01 : 0x11; break;
          case 32: abcdebits = 0x00; break;
          default: ;
          }

        abcdebits |= x << logsize;
        inst.instruction = 0xe100b10;
        do_vfp_cond_or_thumb ();
        inst.instruction |= LOW4 (dn) << 16;
        inst.instruction |= HI1 (dn) << 7;
        inst.instruction |= inst.operands[0].reg << 12;
        inst.instruction |= (abcdebits & 3) << 5;
        inst.instruction |= (abcdebits >> 2) << 21;
      }
      break;
    
    case NS_RRD:  /* case 7 (fmrrd).  */
d11517 1
a11517 1
                  _(BAD_FPU));
d11519 1
a11519 16
      inst.instruction = 0xc500b10;
      do_vfp_cond_or_thumb ();
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= LOW4 (inst.operands[2].reg);
      inst.instruction |= HI1 (inst.operands[2].reg) << 5;
      break;
    
    case NS_FF:  /* case 8 (fcpys).  */
      do_vfp_nsyn_opcode ("fcpys");
      break;
    
    case NS_FI:  /* case 10 (fconsts).  */
      ldconst = "fconsts";
      encode_fconstd:
      if (is_quarter_float (inst.operands[1].imm))
d11521 7
a11527 2
          inst.operands[1].imm = neon_qfloat_bits (inst.operands[1].imm);
          do_vfp_nsyn_opcode (ldconst);
d11530 9
a11538 31
        first_error (_("immediate out of range"));
      break;
    
    case NS_RF:  /* case 12 (fmrs).  */
      do_vfp_nsyn_opcode ("fmrs");
      break;
    
    case NS_FR:  /* case 13 (fmsr).  */
      do_vfp_nsyn_opcode ("fmsr");
      break;
    
    /* The encoders for the fmrrs and fmsrr instructions expect three operands
       (one of which is a list), but we have parsed four.  Do some fiddling to
       make the operands what do_vfp_reg2_from_sp2 and do_vfp_sp2_from_reg2
       expect.  */
    case NS_RRFF:  /* case 14 (fmrrs).  */
      constraint (inst.operands[3].reg != inst.operands[2].reg + 1,
                  _("VFP registers must be adjacent"));
      inst.operands[2].imm = 2;
      memset (&inst.operands[3], '\0', sizeof (inst.operands[3]));
      do_vfp_nsyn_opcode ("fmrrs");
      break;
    
    case NS_FFRR:  /* case 15 (fmsrr).  */
      constraint (inst.operands[1].reg != inst.operands[0].reg + 1,
                  _("VFP registers must be adjacent"));
      inst.operands[1] = inst.operands[2];
      inst.operands[2] = inst.operands[3];
      inst.operands[0].imm = 2;
      memset (&inst.operands[3], '\0', sizeof (inst.operands[3]));
      do_vfp_nsyn_opcode ("fmsrr");
d11549 1
a11549 1
  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
d11563 1
a11563 1
  neon_imm_shift (TRUE, et.type == NT_unsigned, neon_quad (rs), et,
d11580 1
a11580 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11584 1
a11584 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11590 1
a11590 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11600 1
a11600 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11606 1
a11606 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11609 1
a11609 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11615 1
a11615 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11619 1
a11619 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11625 1
a11625 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11629 1
a11629 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11635 1
a11635 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11638 1
a11638 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11644 1
a11644 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11647 1
a11647 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11653 1
a11653 1
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
d11656 1
a11656 1
  neon_two_same (neon_quad (rs), 1, et.size);
d11662 2
a11663 2
  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
  neon_two_same (neon_quad (rs), 1, -1);
a11696 6
  if (inst.operands[1].issingle)
    {
      do_vfp_nsyn_ldm_stm (is_dbmode);
      return;
    }

d11711 2
a11712 1
  do_vfp_cond_or_thumb ();
a11721 6
  if (inst.operands[0].issingle)
    {
      do_vfp_nsyn_ldr_str (is_ldr);
      return;
    }

d11753 2
a11754 1
  do_vfp_cond_or_thumb ();
d11773 1
a11773 1
  struct neon_type_el et = neon_check_type (1, NS_NULL,
d11877 1
a11877 1
  struct neon_type_el et = neon_check_type (1, NS_NULL, N_8 | N_16 | N_32);
d11964 1
a11964 1
  struct neon_type_el et = neon_check_type (1, NS_NULL, N_8 | N_16 | N_32);
a12215 3
  OT_csuffixF,		/* Some forms of the instruction take a conditional
                           suffix, others place 0xF where the condition field
                           would be.  */
a12380 1
        case OT_csuffixF:
a12463 4
  /* The value which unconditional instructions should have in place of the
     condition field.  */
  inst.uncond_value = (opcode->tag == OT_csuffixF) ? 0xf : -1;

d13092 2
a13093 2
#define NCE_tag(mnem, op, nops, ops, enc, tag)				\
  { #mnem, OPS##nops ops, tag, 0x##op, 0x##op, ARM_VARIANT,		\
a13095 6
#define NCE(mnem, op, nops, ops, enc)					\
  NCE_tag(mnem, op, nops, ops, enc, OT_csuffix)

#define NCEF(mnem, op, nops, ops, enc)					\
  NCE_tag(mnem, op, nops, ops, enc, OT_csuffixF)

d13097 2
a13098 2
#define nCE_tag(mnem, op, nops, ops, enc, tag)				\
  { #mnem, OPS##nops ops, tag, N_MNEM_##op, N_MNEM_##op,		\
a13100 6
#define nCE(mnem, op, nops, ops, enc)					\
  nCE_tag(mnem, op, nops, ops, enc, OT_csuffix)

#define nCEF(mnem, op, nops, ops, enc)					\
  nCE_tag(mnem, op, nops, ops, enc, OT_csuffixF)

d13246 2
a13247 2
 TCE(mrs,	10f0000, f3ef8000, 2, (APSR_RR, RVC_PSR), mrs, t_mrs),
 TCE(msr,	120f000, f3808000, 2, (RVC_PSR, RR_EXi), msr, t_msr),
a14095 44
/* Instructions which may belong to either the Neon or VFP instruction sets.
   Individual encoder functions perform additional architecture checks.  */
#undef ARM_VARIANT
#define ARM_VARIANT &fpu_vfp_ext_v1xd
#undef THUMB_VARIANT
#define THUMB_VARIANT &fpu_vfp_ext_v1xd
  /* These mnemonics are unique to VFP.  */
 NCE(vsqrt,     0,       2, (RVSD, RVSD),       vfp_nsyn_sqrt),
 NCE(vdiv,      0,       3, (RVSD, RVSD, RVSD), vfp_nsyn_div),
 nCE(vnmul,     vnmul,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vnmla,     vnmla,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vnmls,     vnmls,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
 nCE(vcmp,      vcmp,    2, (RVSD, RVSD_I0),    vfp_nsyn_cmp),
 nCE(vcmpe,     vcmpe,   2, (RVSD, RVSD_I0),    vfp_nsyn_cmp),
 NCE(vpush,     0,       1, (VRSDLST),          vfp_nsyn_push),
 NCE(vpop,      0,       1, (VRSDLST),          vfp_nsyn_pop),
 NCE(vcvtz,     0,       2, (RVSD, RVSD),       vfp_nsyn_cvtz),

  /* Mnemonics shared by Neon and VFP.  */
 nCEF(vmul,     vmul,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mul),
 nCEF(vmla,     vmla,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),
 nCEF(vmls,     vmls,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),

 nCEF(vadd,     vadd,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),
 nCEF(vsub,     vsub,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),

 NCEF(vabs,     1b10300, 2, (RNSDQ, RNSDQ), neon_abs_neg),
 NCEF(vneg,     1b10380, 2, (RNSDQ, RNSDQ), neon_abs_neg),

 NCE(vldm,      c900b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vldmia,    c900b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vldmdb,    d100b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vstm,      c800b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vstmia,    c800b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vstmdb,    d000b00, 2, (RRw, VRSDLST), neon_ldm_stm),
 NCE(vldr,      d100b00, 2, (RVSD, ADDR), neon_ldr_str),
 NCE(vstr,      d000b00, 2, (RVSD, ADDR), neon_ldr_str),

 nCEF(vcvt,     vcvt,    3, (RNSDQ, RNSDQ, oI32b), neon_cvt),

  /* NOTE: All VMOV encoding is special-cased!  */
 NCE(vmov,      0,       1, (VMOV), neon_mov),
 NCE(vmovq,     0,       1, (VMOV), neon_mov),

d14169 1
d14171 1
d14175 1
d14177 1
d14183 2
a14184 1
 nUF(vmulq,     vmul,     3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mul),
d14204 1
d14206 1
d14241 9
a14249 1
 nUF(vcvtq,     vcvt,    3, (RNQ, RNQ, oI32b), neon_cvt),
d14251 5
d14349 15
d14367 1
d14382 1
@


1.250.2.16
log
@2006-05-15  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	* bfd/cpu-arm.c (bfd_is_arm_mapping_symbol_name): Rename ...
	(bfd_is_arm_special_symbol_name): ... to this.  Add type argument.
	Check symbol name is of specified type.
	* bfd/elf32-arm.c (elf32_arm_is_target_special_symbol,
	arm_elf_find_function, elf32_arm_output_symbol_hook): Use
	bfd_is_arm_special_symbol_name.
	* bfd/bfd-in.h (BFD_ARM_SPECIAL_SYM_TYPE_MAP,
	BFD_ARM_SPECIAL_SYM_TYPE_TAG, BFD_ARM_SPECIAL_SYM_TYPE_OTHER,
	BFD_ARM_SPECIAL_SYM_TYPE_ANY): Define.
	(bfd_is_arm_mapping_symbol_name): Remove prototype.
	(bfd_is_arm_special_symbol_name): Add prototype.
	* bfd/bfd-in2.h: Regenerate.
	* gas/config/tc-arm.c (arm_adjust_symtab): Use
	bfd_is_arm_special_symbol_name.
	* ld/testsuite/ld-arm/arm-be8.d: New test.
	* ld/testsuite/ld-arm/arm-be8.s: New test.
	* ld/testsuite/ld-arm/arm-elf.exp: Add arm-be8.
@
text
@d18271 1
a18271 2
	  if (! bfd_is_arm_special_symbol_name (elf_sym->symbol.name,
		BFD_ARM_SPECIAL_SYM_TYPE_ANY))
@


1.250.2.17
log
@	gas/
	* config/tc-arm.c (do_vfp_nsyn_ldr_str): Remove, fold into...
	(do_neon_ldr_str): Always defer to VFP encoding routines, which handle
	relocs properly.
@
text
@d10623 9
d12653 2
d12659 17
a12675 4
      if (is_ldr)
        do_vfp_nsyn_opcode ("flds");
      else
        do_vfp_nsyn_opcode ("fsts");
d12678 19
d12698 2
a12699 2
      if (is_ldr)
        do_vfp_nsyn_opcode ("fldd");
d12701 1
a12701 1
        do_vfp_nsyn_opcode ("fstd");
d12703 2
@


1.250.2.18
log
@Support for ARM "group relocations" numbers 4, and 57 through 83.

	* include/elf/arm.h: Correct names of R_ARM_LDC_G{0,1,2}
	to R_ARM_LDC_SB_G{0,1,2} respectively.

	bfd/
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (R_ARM_ALU_PC_G0_NC, R_ARM_ALU_PC_G0,
	R_ARM_ALU_PC_G1_NC, R_ARM_ALU_PC_G1, R_ARM_ALU_PC_G2,
	R_ARM_LDR_PC_G1, R_ARM_LDR_PC_G2, R_ARM_LDRS_PC_G0,
	R_ARM_LDRS_PC_G1, R_ARM_LDRS_PC_G2, R_ARM_LDC_PC_G0,
	R_ARM_LDC_PC_G1, R_ARM_LDC_PC_G2, R_ARM_ALU_SB_G0_NC,
	R_ARM_ALU_SB_G0, R_ARM_ALU_SB_G1_NC, R_ARM_ALU_SB_G1,
	R_ARM_ALU_SB_G2, R_ARM_LDR_SB_G0, R_ARM_LDR_SB_G1,
	R_ARM_LDR_SB_G2, R_ARM_LDRS_SB_G0, R_ARM_LDRS_SB_G1,
	R_ARM_LDRS_SB_G2, R_ARM_LDC_SB_G0, R_ARM_LDC_SB_G1,
	R_ARM_LDC_SB_G2): New relocation types.
	(R_ARM_PC13): Rename to AAELF name R_ARM_LDR_PC_G0 and
	adjust HOWTO entry to be consistent with R_ARM_LDR_PC_G1
	and friends.
	(elf32_arm_howto_table_3): Delete; contents merged into
	elf32_arm_howto_table_2.
	(elf32_arm_howto_from_type): Adjust correspondingly.
	(elf32_arm_reloc_map): Extend with the above relocations.
	(calculate_group_reloc_mask): New function.
	(identify_add_or_sub): New function.
	(elf32_arm_final_link_relocate): Support for the above
	relocations.
	* reloc.c: Add enumeration entries for BFD_RELOC_ARM_...
	codes to correspond to the above relocations.

	gas/
	* config/tc-arm.c (enum parse_operand_result): New.
	(struct group_reloc_table_entry): New.
	(enum group_reloc_type): New.
	(group_reloc_table): New array.
	(find_group_reloc_table_entry): New function.
	(parse_shifter_operand_group_reloc): New function.
	(parse_address_main): New function, incorporating code
	from the old parse_address function.  To be used via...
	(parse_address): wrapper for parse_address_main; and
	(parse_address_group_reloc): new function, likewise.
	(enum operand_parse_code): New codes OP_SHG, OP_ADDRGLDR,
	OP_ADDRGLDRS, OP_ADDRGLDC.
	(parse_operands): Support for these new operand codes.
	New macro po_misc_or_fail_no_backtrack.
	(encode_arm_cp_address): Preserve group relocations.
	(insns): Modify to use the above operand codes where group
	relocations are permitted.
	(md_apply_fix): Handle the group relocations
	ALU_PC_G0_NC through LDC_SB_G2.
	(tc_gen_reloc): Likewise.
	(arm_force_relocation): Leave group relocations for the linker.
	(arm_fix_adjustable): Likewise.

	gas/testsuite/
	* gas/arm/group-reloc-alu.d: New test.
	* gas/arm/group-reloc-alu-encoding-bad.d: New test.
	* gas/arm/group-reloc-alu-encoding-bad.l: New test.
	* gas/arm/group-reloc-alu-encoding-bad.s: New test.
	* gas/arm/group-reloc-alu-parsing-bad.d: New test.
	* gas/arm/group-reloc-alu-parsing-bad.l: New test.
	* gas/arm/group-reloc-alu-parsing-bad.s: New test.
	* gas/arm/group-reloc-alu.s: New test.
	* gas/arm/group-reloc-ldc.d: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldc.s: New test.
	* gas/arm/group-reloc-ldr.d: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldr.s: New test.
	* gas/arm/group-reloc-ldrs.d: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldrs.s: New test.

	ld/testsuite/
	* ld-arm/group-relocs-alu-bad.d: New test.
	* ld-arm/group-relocs-alu-bad.s: New test.
	* ld-arm/group-relocs.d: New test.
	* ld-arm/group-relocs-ldc-bad.d: New test.
	* ld-arm/group-relocs-ldc-bad.s: New test.
	* ld-arm/group-relocs-ldr-bad.d: New test.
	* ld-arm/group-relocs-ldr-bad.s: New test.
	* ld-arm/group-relocs-ldrs-bad.d: New test.
	* ld-arm/group-relocs-ldrs-bad.s: New test.
	* ld-arm/group-relocs.s: New test.
	* ld-arm/arm-elf.exp: Wire in new tests.
@
text
@a87 9
/* Results from operand parsing worker functions.  */

typedef enum
{
  PARSE_OPERAND_SUCCESS,
  PARSE_OPERAND_FAIL,
  PARSE_OPERAND_FAIL_NO_BACKTRACK
} parse_operand_result;

a4269 162
/* Group relocation information.  Each entry in the table contains the
   textual name of the relocation as may appear in assembler source
   and must end with a colon.
   Along with this textual name are the relocation codes to be used if
   the corresponding instruction is an ALU instruction (ADD or SUB only),
   an LDR, an LDRS, or an LDC.  */

struct group_reloc_table_entry
{
  const char *name;
  int alu_code;
  int ldr_code;
  int ldrs_code;
  int ldc_code;
};

typedef enum
{
  /* Varieties of non-ALU group relocation.  */

  GROUP_LDR,
  GROUP_LDRS,
  GROUP_LDC
} group_reloc_type;

static struct group_reloc_table_entry group_reloc_table[] =
  { /* Program counter relative: */
    { "pc_g0_nc",
      BFD_RELOC_ARM_ALU_PC_G0_NC,	/* ALU */
      0,				/* LDR */
      0,				/* LDRS */
      0 },				/* LDC */
    { "pc_g0",
      BFD_RELOC_ARM_ALU_PC_G0,		/* ALU */
      BFD_RELOC_ARM_LDR_PC_G0,		/* LDR */
      BFD_RELOC_ARM_LDRS_PC_G0,		/* LDRS */
      BFD_RELOC_ARM_LDC_PC_G0 },	/* LDC */
    { "pc_g1_nc",
      BFD_RELOC_ARM_ALU_PC_G1_NC,	/* ALU */
      0,				/* LDR */
      0,				/* LDRS */
      0 },				/* LDC */
    { "pc_g1",
      BFD_RELOC_ARM_ALU_PC_G1,		/* ALU */
      BFD_RELOC_ARM_LDR_PC_G1, 		/* LDR */
      BFD_RELOC_ARM_LDRS_PC_G1,		/* LDRS */
      BFD_RELOC_ARM_LDC_PC_G1 },	/* LDC */
    { "pc_g2",
      BFD_RELOC_ARM_ALU_PC_G2,		/* ALU */
      BFD_RELOC_ARM_LDR_PC_G2,		/* LDR */
      BFD_RELOC_ARM_LDRS_PC_G2,		/* LDRS */
      BFD_RELOC_ARM_LDC_PC_G2 },	/* LDC */
    /* Section base relative */
    { "sb_g0_nc",
      BFD_RELOC_ARM_ALU_SB_G0_NC,	/* ALU */
      0,				/* LDR */
      0,				/* LDRS */
      0 },				/* LDC */
    { "sb_g0",
      BFD_RELOC_ARM_ALU_SB_G0,		/* ALU */
      BFD_RELOC_ARM_LDR_SB_G0,		/* LDR */
      BFD_RELOC_ARM_LDRS_SB_G0,		/* LDRS */
      BFD_RELOC_ARM_LDC_SB_G0 },	/* LDC */
    { "sb_g1_nc",
      BFD_RELOC_ARM_ALU_SB_G1_NC,	/* ALU */
      0,				/* LDR */
      0,				/* LDRS */
      0 },				/* LDC */
    { "sb_g1",
      BFD_RELOC_ARM_ALU_SB_G1,		/* ALU */
      BFD_RELOC_ARM_LDR_SB_G1, 		/* LDR */
      BFD_RELOC_ARM_LDRS_SB_G1,		/* LDRS */
      BFD_RELOC_ARM_LDC_SB_G1 },	/* LDC */
    { "sb_g2",
      BFD_RELOC_ARM_ALU_SB_G2,		/* ALU */
      BFD_RELOC_ARM_LDR_SB_G2,		/* LDR */
      BFD_RELOC_ARM_LDRS_SB_G2,		/* LDRS */
      BFD_RELOC_ARM_LDC_SB_G2 }	};	/* LDC */

/* Given the address of a pointer pointing to the textual name of a group
   relocation as may appear in assembler source, attempt to find its details
   in group_reloc_table.  The pointer will be updated to the character after
   the trailing colon.  On failure, FAIL will be returned; SUCCESS
   otherwise.  On success, *entry will be updated to point at the relevant
   group_reloc_table entry. */

static int
find_group_reloc_table_entry (char **str, struct group_reloc_table_entry **out)
{
  unsigned int i;
  for (i = 0; i < ARRAY_SIZE (group_reloc_table); i++)
    {
      int length = strlen (group_reloc_table[i].name);

      if (strncasecmp (group_reloc_table[i].name, *str, length) == 0 &&
          (*str)[length] == ':')
        {
          *out = &group_reloc_table[i];
          *str += (length + 1);
          return SUCCESS;
        }
    }

  return FAIL;
}

/* Parse a <shifter_operand> for an ARM data processing instruction
   (as for parse_shifter_operand) where group relocations are allowed:

      #<immediate>
      #<immediate>, <rotate>
      #:<group_reloc>:<expression>
      <Rm>
      <Rm>, <shift>

   where <group_reloc> is one of the strings defined in group_reloc_table.
   The hashes are optional.

   Everything else is as for parse_shifter_operand.  */

static parse_operand_result
parse_shifter_operand_group_reloc (char **str, int i)
{
  /* Determine if we have the sequence of characters #: or just :
     coming next.  If we do, then we check for a group relocation.
     If we don't, punt the whole lot to parse_shifter_operand.  */

  if (((*str)[0] == '#' && (*str)[1] == ':')
      || (*str)[0] == ':')
    {
      struct group_reloc_table_entry *entry;

      if ((*str)[0] == '#')
        (*str) += 2;
      else
        (*str)++;

      /* Try to parse a group relocation.  Anything else is an error.  */
      if (find_group_reloc_table_entry (str, &entry) == FAIL)
        {
          inst.error = _("unknown group relocation");
          return PARSE_OPERAND_FAIL_NO_BACKTRACK;
        }

      /* We now have the group relocation table entry corresponding to
         the name in the assembler source.  Next, we parse the expression.  */
      if (my_get_expression (&inst.reloc.exp, str, GE_NO_PREFIX))
        return PARSE_OPERAND_FAIL_NO_BACKTRACK;

      /* Record the relocation type (always the ALU variant here).  */
      inst.reloc.type = entry->alu_code;
      assert (inst.reloc.type != 0);

      return PARSE_OPERAND_SUCCESS;
    }
  else
    return parse_shifter_operand (str, i) == SUCCESS
           ? PARSE_OPERAND_SUCCESS : PARSE_OPERAND_FAIL;

  /* Never reached.  */
}

d4302 2
a4303 3
static parse_operand_result
parse_address_main (char **str, int i, int group_relocations,
                    group_reloc_type group_type)
d4321 1
a4321 1
	return PARSE_OPERAND_FAIL;
d4324 1
a4324 1
      return PARSE_OPERAND_SUCCESS;
d4330 1
a4330 1
      return PARSE_OPERAND_FAIL;
d4349 1
a4349 1
	      return PARSE_OPERAND_FAIL;
d4361 1
a4361 1
              return PARSE_OPERAND_FAIL;
d4375 2
a4376 55

	  if (group_relocations &&
              ((*p == '#' && *(p + 1) == ':') || *p == ':'))

	    {
	      struct group_reloc_table_entry *entry;

              /* Skip over the #: or : sequence.  */
              if (*p == '#')
                p += 2;
              else
                p++;

	      /* Try to parse a group relocation.  Anything else is an
                 error.  */
	      if (find_group_reloc_table_entry (&p, &entry) == FAIL)
		{
		  inst.error = _("unknown group relocation");
		  return PARSE_OPERAND_FAIL_NO_BACKTRACK;
		}

	      /* We now have the group relocation table entry corresponding to
		 the name in the assembler source.  Next, we parse the
                 expression.  */
	      if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
		return PARSE_OPERAND_FAIL_NO_BACKTRACK;

	      /* Record the relocation type.  */
              switch (group_type)
                {
                  case GROUP_LDR:
	            inst.reloc.type = entry->ldr_code;
                    break;

                  case GROUP_LDRS:
	            inst.reloc.type = entry->ldrs_code;
                    break;

                  case GROUP_LDC:
	            inst.reloc.type = entry->ldc_code;
                    break;

                  default:
                    assert (0);
                }

              if (inst.reloc.type == 0)
		{
		  inst.error = _("this group relocation is not allowed on this instruction");
		  return PARSE_OPERAND_FAIL_NO_BACKTRACK;
		}
            }
          else
	    if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	      return PARSE_OPERAND_FAIL;
d4383 1
a4383 1
      return PARSE_OPERAND_FAIL;
d4396 1
a4396 1
	    return PARSE_OPERAND_FAIL;
d4401 1
a4401 1
	      return PARSE_OPERAND_FAIL;
d4406 1
a4406 1
	      return PARSE_OPERAND_FAIL;
d4409 1
a4409 1
	  return PARSE_OPERAND_SUCCESS;
d4419 1
a4419 1
	      return PARSE_OPERAND_FAIL;
d4437 1
a4437 1
		  return PARSE_OPERAND_FAIL;
d4447 1
a4447 1
		return PARSE_OPERAND_FAIL;
d4461 1
a4461 14
  return PARSE_OPERAND_SUCCESS;
}

static int
parse_address (char **str, int i)
{
  return parse_address_main (str, i, 0, 0) == PARSE_OPERAND_SUCCESS
         ? SUCCESS : FAIL;
}

static parse_operand_result
parse_address_group_reloc (char **str, int i, group_reloc_type type)
{
  return parse_address_main (str, i, 1, type);
a5059 1
  OP_SHG,	/* shifter operand with possible group relocation */
a5060 3
  OP_ADDRGLDR,	/* Mem addr expr (any mode) with possible LDR group reloc */
  OP_ADDRGLDRS, /* Mem addr expr (any mode) with possible LDRS group reloc */
  OP_ADDRGLDC,  /* Mem addr expr (any mode) with possible LDC group reloc */
a5114 1
  parse_operand_result result;
a5171 8
#define po_misc_or_fail_no_backtrack(expr) do {	\
  result = expr;				\
  if (result == PARSE_OPERAND_FAIL_NO_BACKTRACK)\
    backtrack_pos = 0;				\
  if (result != PARSE_OPERAND_SUCCESS)		\
    goto failure;				\
} while (0)

a5553 15
	case OP_ADDRGLDR:
	  po_misc_or_fail_no_backtrack (
            parse_address_group_reloc (&str, i, GROUP_LDR));
	  break;

	case OP_ADDRGLDRS:
	  po_misc_or_fail_no_backtrack (
            parse_address_group_reloc (&str, i, GROUP_LDRS));
	  break;

	case OP_ADDRGLDC:
	  po_misc_or_fail_no_backtrack (
            parse_address_group_reloc (&str, i, GROUP_LDC));
	  break;

a5557 5
	case OP_SHG:
	  po_misc_or_fail_no_backtrack (
            parse_shifter_operand_group_reloc (&str, i));
	  break;

d5911 1
a5911 2
   of BFD_ARM_CP_OFF_IMM, unless the initial relocation is a group one
   (in which case it is preserved).  */
d5953 4
a5956 10
  else if ((inst.reloc.type < BFD_RELOC_ARM_ALU_PC_G0_NC
            || inst.reloc.type > BFD_RELOC_ARM_LDC_SB_G2)
           && inst.reloc.type != BFD_RELOC_ARM_LDR_PC_G0)
    {
      if (thumb_mode)
        inst.reloc.type = BFD_RELOC_ARM_T32_CP_OFF_IMM;
      else
        inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
    }

d14031 2
a14032 2
 tCE(add,	0800000, add,	   3, (RR, oRR, SHG), arit, t_add_sub),
 tC3(adds,	0900000, adds,	   3, (RR, oRR, SHG), arit, t_add_sub),
d14060 4
a14063 4
 tCE(ldr,	4100000, ldr,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tC3(ldrb,	4500000, ldrb,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tCE(str,	4000000, str,	   2, (RR, ADDRGLDR),ldst, t_ldst),
 tC3(strb,	4400000, strb,	   2, (RR, ADDRGLDR),ldst, t_ldst),
d14147 4
a14150 4
 TCE(ldc,	c100000, ec100000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TC3(ldcl,	c500000, ec500000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TCE(stc,	c000000, ec000000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
 TC3(stcl,	c400000, ec400000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
d14179 6
a14184 6
 tC3(ldrh,	01000b0, ldrh,     2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3(strh,	00000b0, strh,     2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3(ldrsh,	01000f0, ldrsh,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tC3(ldrsb,	01000d0, ldrsb,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tCM(ld,sh,	01000f0, ldrsh,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
 tCM(ld,sb,	01000d0, ldrsb,    2, (RR, ADDRGLDRS), ldstv4, t_ldst),
d14205 4
a14208 4
 TUF(ldc2,	c100000, fc100000, 3, (RCP, RCN, ADDRGLDC),	        lstc,	lstc),
 TUF(ldc2l,	c500000, fc500000, 3, (RCP, RCN, ADDRGLDC),		        lstc,	lstc),
 TUF(stc2,	c000000, fc000000, 3, (RCP, RCN, ADDRGLDC),	        lstc,	lstc),
 TUF(stc2l,	c400000, fc400000, 3, (RCP, RCN, ADDRGLDC),		        lstc,	lstc),
d14244 2
a14245 2
 TC3(ldrd,	00000d0, e9500000, 3, (RRnpc, oRRnpc, ADDRGLDRS), ldrd, t_ldstd),
 TC3(strd,	00000f0, e9400000, 3, (RRnpc, oRRnpc, ADDRGLDRS), ldrd, t_ldstd),
d14461 9
a14469 9
 cCL(ldfs,	c100100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(ldfd,	c108100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(ldfe,	c500100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(ldfp,	c508100, 2, (RF, ADDRGLDC),  rd_cpaddr),

 cCL(stfs,	c000100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(stfd,	c008100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(stfe,	c400100, 2, (RF, ADDRGLDC),  rd_cpaddr),
 cCL(stfp,	c408100, 2, (RF, ADDRGLDC),  rd_cpaddr),
d14912 2
a14913 2
 cCE(flds,	d100a00, 2, (RVS, ADDRGLDC),  vfp_sp_ldst),
 cCE(fsts,	d000a00, 2, (RVS, ADDRGLDC),  vfp_sp_ldst),
d14971 2
a14972 2
 cCE(fldd,	d100b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
 cCE(fstd,	d000b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
d15046 2
a15047 2
 NCE(vldr,      d100b00, 2, (RVSD, ADDRGLDC), neon_ldr_str),
 NCE(vstr,      d000b00, 2, (RVSD, ADDRGLDC), neon_ldr_str),
d15503 8
a15510 8
 cCE(cfldrs,	c100400, 2, (RMF, ADDRGLDC),	      rd_cpaddr),
 cCE(cfldrd,	c500400, 2, (RMD, ADDRGLDC),	      rd_cpaddr),
 cCE(cfldr32,	c100500, 2, (RMFX, ADDRGLDC),	      rd_cpaddr),
 cCE(cfldr64,	c500500, 2, (RMDX, ADDRGLDC),	      rd_cpaddr),
 cCE(cfstrs,	c000400, 2, (RMF, ADDRGLDC),	      rd_cpaddr),
 cCE(cfstrd,	c400400, 2, (RMD, ADDRGLDC),	      rd_cpaddr),
 cCE(cfstr32,	c000500, 2, (RMFX, ADDRGLDC),	      rd_cpaddr),
 cCE(cfstr64,	c400500, 2, (RMDX, ADDRGLDC),	      rd_cpaddr),
a16891 1

a17762 169
   case BFD_RELOC_ARM_ALU_PC_G0_NC:
   case BFD_RELOC_ARM_ALU_PC_G0:
   case BFD_RELOC_ARM_ALU_PC_G1_NC:
   case BFD_RELOC_ARM_ALU_PC_G1:
   case BFD_RELOC_ARM_ALU_PC_G2:
   case BFD_RELOC_ARM_ALU_SB_G0_NC:
   case BFD_RELOC_ARM_ALU_SB_G0:
   case BFD_RELOC_ARM_ALU_SB_G1_NC:
   case BFD_RELOC_ARM_ALU_SB_G1:
   case BFD_RELOC_ARM_ALU_SB_G2:
     assert (!fixP->fx_done);
     if (!seg->use_rela_p)
       {
         bfd_vma insn;
         bfd_vma encoded_addend;
         bfd_vma addend_abs = abs (value);

         /* Check that the absolute value of the addend can be
            expressed as an 8-bit constant plus a rotation.  */
         encoded_addend = encode_arm_immediate (addend_abs);
         if (encoded_addend == (unsigned int) FAIL)
	   as_bad_where (fixP->fx_file, fixP->fx_line,
	                 _("the offset 0x%08lX is not representable"),
                         addend_abs);

         /* Extract the instruction.  */
         insn = md_chars_to_number (buf, INSN_SIZE);

         /* If the addend is positive, use an ADD instruction.
            Otherwise use a SUB.  Take care not to destroy the S bit.  */
         insn &= 0xff1fffff;
         if (value < 0)
           insn |= 1 << 22;
         else
           insn |= 1 << 23;

         /* Place the encoded addend into the first 12 bits of the
            instruction.  */
         insn &= 0xfffff000;
         insn |= encoded_addend;
   
         /* Update the instruction.  */  
         md_number_to_chars (buf, insn, INSN_SIZE);
       }
     break;

    case BFD_RELOC_ARM_LDR_PC_G0:
    case BFD_RELOC_ARM_LDR_PC_G1:
    case BFD_RELOC_ARM_LDR_PC_G2:
    case BFD_RELOC_ARM_LDR_SB_G0:
    case BFD_RELOC_ARM_LDR_SB_G1:
    case BFD_RELOC_ARM_LDR_SB_G2:
      assert (!fixP->fx_done);
      if (!seg->use_rela_p)
        {
          bfd_vma insn;
          bfd_vma addend_abs = abs (value);

          /* Check that the absolute value of the addend can be
             encoded in 12 bits.  */
          if (addend_abs >= 0x1000)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
	  	          _("bad offset 0x%08lX (only 12 bits available for the magnitude)"),
                          addend_abs);

          /* Extract the instruction.  */
          insn = md_chars_to_number (buf, INSN_SIZE);

          /* If the addend is negative, clear bit 23 of the instruction.
             Otherwise set it.  */
          if (value < 0)
            insn &= ~(1 << 23);
          else
            insn |= 1 << 23;

          /* Place the absolute value of the addend into the first 12 bits
             of the instruction.  */
          insn &= 0xfffff000;
          insn |= addend_abs;
    
          /* Update the instruction.  */  
          md_number_to_chars (buf, insn, INSN_SIZE);
        }
      break;

    case BFD_RELOC_ARM_LDRS_PC_G0:
    case BFD_RELOC_ARM_LDRS_PC_G1:
    case BFD_RELOC_ARM_LDRS_PC_G2:
    case BFD_RELOC_ARM_LDRS_SB_G0:
    case BFD_RELOC_ARM_LDRS_SB_G1:
    case BFD_RELOC_ARM_LDRS_SB_G2:
      assert (!fixP->fx_done);
      if (!seg->use_rela_p)
        {
          bfd_vma insn;
          bfd_vma addend_abs = abs (value);

          /* Check that the absolute value of the addend can be
             encoded in 8 bits.  */
          if (addend_abs >= 0x100)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
	  	          _("bad offset 0x%08lX (only 8 bits available for the magnitude)"),
                          addend_abs);

          /* Extract the instruction.  */
          insn = md_chars_to_number (buf, INSN_SIZE);

          /* If the addend is negative, clear bit 23 of the instruction.
             Otherwise set it.  */
          if (value < 0)
            insn &= ~(1 << 23);
          else
            insn |= 1 << 23;

          /* Place the first four bits of the absolute value of the addend
             into the first 4 bits of the instruction, and the remaining
             four into bits 8 .. 11.  */
          insn &= 0xfffff0f0;
          insn |= (addend_abs & 0xf) | ((addend_abs & 0xf0) << 4);
    
          /* Update the instruction.  */  
          md_number_to_chars (buf, insn, INSN_SIZE);
        }
      break;

    case BFD_RELOC_ARM_LDC_PC_G0:
    case BFD_RELOC_ARM_LDC_PC_G1:
    case BFD_RELOC_ARM_LDC_PC_G2:
    case BFD_RELOC_ARM_LDC_SB_G0:
    case BFD_RELOC_ARM_LDC_SB_G1:
    case BFD_RELOC_ARM_LDC_SB_G2:
      assert (!fixP->fx_done);
      if (!seg->use_rela_p)
        {
          bfd_vma insn;
          bfd_vma addend_abs = abs (value);

          /* Check that the absolute value of the addend is a multiple of
             four and, when divided by four, fits in 8 bits.  */
          if (addend_abs & 0x3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
	  	          _("bad offset 0x%08lX (must be word-aligned)"),
                          addend_abs);

          if ((addend_abs >> 2) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
	  	          _("bad offset 0x%08lX (must be an 8-bit number of words)"),
                          addend_abs);

          /* Extract the instruction.  */
          insn = md_chars_to_number (buf, INSN_SIZE);

          /* If the addend is negative, clear bit 23 of the instruction.
             Otherwise set it.  */
          if (value < 0)
            insn &= ~(1 << 23);
          else
            insn |= 1 << 23;

          /* Place the addend (divided by four) into the first eight
             bits of the instruction.  */
          insn &= 0xfffffff0;
          insn |= addend_abs >> 2;
    
          /* Update the instruction.  */  
          md_number_to_chars (buf, insn, INSN_SIZE);
        }
      break;

a17881 28
    case BFD_RELOC_ARM_ALU_PC_G0_NC:
    case BFD_RELOC_ARM_ALU_PC_G0:
    case BFD_RELOC_ARM_ALU_PC_G1_NC:
    case BFD_RELOC_ARM_ALU_PC_G1:
    case BFD_RELOC_ARM_ALU_PC_G2:
    case BFD_RELOC_ARM_LDR_PC_G0:
    case BFD_RELOC_ARM_LDR_PC_G1:
    case BFD_RELOC_ARM_LDR_PC_G2:
    case BFD_RELOC_ARM_LDRS_PC_G0:
    case BFD_RELOC_ARM_LDRS_PC_G1:
    case BFD_RELOC_ARM_LDRS_PC_G2:
    case BFD_RELOC_ARM_LDC_PC_G0:
    case BFD_RELOC_ARM_LDC_PC_G1:
    case BFD_RELOC_ARM_LDC_PC_G2:
    case BFD_RELOC_ARM_ALU_SB_G0_NC:
    case BFD_RELOC_ARM_ALU_SB_G0:
    case BFD_RELOC_ARM_ALU_SB_G1_NC:
    case BFD_RELOC_ARM_ALU_SB_G1:
    case BFD_RELOC_ARM_ALU_SB_G2:
    case BFD_RELOC_ARM_LDR_SB_G0:
    case BFD_RELOC_ARM_LDR_SB_G1:
    case BFD_RELOC_ARM_LDR_SB_G2:
    case BFD_RELOC_ARM_LDRS_SB_G0:
    case BFD_RELOC_ARM_LDRS_SB_G1:
    case BFD_RELOC_ARM_LDRS_SB_G2:
    case BFD_RELOC_ARM_LDC_SB_G0:
    case BFD_RELOC_ARM_LDC_SB_G1:
    case BFD_RELOC_ARM_LDC_SB_G2:
a18049 6
  /* Always leave these relocations for the linker.  */
  if ((fixp->fx_r_type >= BFD_RELOC_ARM_ALU_PC_G0_NC
       && fixp->fx_r_type <= BFD_RELOC_ARM_LDC_SB_G2)
      || fixp->fx_r_type == BFD_RELOC_ARM_LDR_PC_G0)
    return 1;

a18113 6
  /* Similarly for group relocations.  */
  if ((fixP->fx_r_type >= BFD_RELOC_ARM_ALU_PC_G0_NC
       && fixP->fx_r_type <= BFD_RELOC_ARM_LDC_SB_G2)
      || fixP->fx_r_type == BFD_RELOC_ARM_LDR_PC_G0)
    return 0;

@


1.250.2.19
log
@2006-07-18  Paul Brook  <paul@@codesourcery.com>

	Merge from mainline.
	bfd/
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_T32_ADD_IMM.

	gas/
	* tc-arm.c (do_t_add_sub): Use addw/subw when source is PC.
	(md_convert_frag): Use correct reloc for add_pc.  Use
	BFD_RELOC_ARM_T32_ADD_IMM for normal add/sum.
	(md_apply_fix): Handle BFD_RELOC_ARM_T32_ADD_IMM.
	(arm_force_relocation): Handle BFD_RELOC_ARM_T32_ADD_IMM.

	gas/testsuite/
	* gas/arm/thumb2_add.d: New test.
	* gas/arm/thumb2_add.s: New test.
@
text
@a8137 4
	  int add;

	  add = (inst.instruction == T_MNEM_add
		 || inst.instruction == T_MNEM_adds);
d8141 4
d8174 3
a8176 16
	      if (Rs == REG_PC)
		{
		  /* Always use addw/subw.  */
		  inst.instruction = add ? 0xf20f0000 : 0xf2af0000;
		  inst.reloc.type = BFD_RELOC_ARM_T32_IMM12;
		}
	      else
		{
		  inst.instruction = THUMB_OP32 (inst.instruction);
		  inst.instruction = (inst.instruction & 0xe1ffffff)
				     | 0x10000000;
		  if (flags)
		    inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
		  else
		    inst.reloc.type = BFD_RELOC_ARM_T32_ADD_IMM;
		}
d8179 1
d16070 1
a16070 4
	  if (opcode == T_MNEM_add_pc)
	    reloc_type = BFD_RELOC_ARM_T32_IMM12;
	  else
	    reloc_type = BFD_RELOC_ARM_T32_ADD_IMM;
d16087 1
a16087 4
	  if (insn & (1 << 20))
	    reloc_type = BFD_RELOC_ARM_T32_ADD_IMM;
	  else
	    reloc_type = BFD_RELOC_ARM_T32_IMMEDIATE;
a17477 1
    case BFD_RELOC_ARM_T32_ADD_IMM:
d17498 2
a17499 3
      newimm = FAIL;
      if (fixP->fx_r_type == BFD_RELOC_ARM_T32_IMMEDIATE
	  || fixP->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM)
d17505 1
a17505 2
      if (fixP->fx_r_type != BFD_RELOC_ARM_T32_IMMEDIATE
	  && newimm == (unsigned int) FAIL)
a17506 4
	  /* Turn add/sum into addw/subw.  */
	  if (fixP->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM)
	    newval = (newval & 0xfeffffff) | 0x02000000;

a18520 1
      || fixp->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM
@


1.250.2.20
log
@2006-07-19  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	gas/
	* config/tc-arm.c (insns): Fix rbit Arm opcode.
	gas/testsuite/
	* gas/arm/archv6t2.d: Adjust expected output for rbit.
	opcodes/
	* armd-dis.c (arm_opcodes): Fix rbit opcode.
@
text
@d14692 1
a14692 1
 TCE(rbit,	6ff0f30, fa90f0a0, 2, (RR, RR),			    rd_rm, t_rbit),
@


1.250.2.21
log
@	Backport from mainline.

	gas/
	* config/tc-arm.c (parse_operands): Handle invalid register name
	for OP_RIWR_RIWC.

	gas/testsuite/
	* gas/arm/iwmmxt-bad.s: Test invalid register names for wldrw and
	wstrw.
	* gas/arm/iwmmxt-bad.l: Update.

	gas/
	* config/tc-arm.c (enum operand_parse_code): Add OP_RIWC_RIWG.
	(parse_operands): Handle it.
	(insns): Use it for tmcr and tmrc.

	gas/testsuite/
	* gas/arm/iwmmxt.s: Test tmcr and tmrc with wcgr registers.
	* gas/arm/iwmmxt.d: Update.
@
text
@a5321 1
  OP_RIWC_RIWG, /* iWMMXt wC or wCG reg */
d5700 3
a5702 4
	    if (!rege
		|| (rege->type != REG_TYPE_MMXWR
		    && rege->type != REG_TYPE_MMXWC
		    && rege->type != REG_TYPE_MMXWCG))
a5711 15
	case OP_RIWC_RIWG:
	  {
	    struct reg_entry *rege = arm_reg_parse_multi (&str);
	    if (!rege
		|| (rege->type != REG_TYPE_MMXWC
		    && rege->type != REG_TYPE_MMXWCG))
	      {
		inst.error = _("iWMMXt control register expected");
		goto failure;
	      }
	    inst.operands[i].reg = rege->number;
	    inst.operands[i].isreg = 1;
	  }
	  break;

d15646 1
a15646 1
 cCE(tmcr,	e000110, 2, (RIWC_RIWG, RR),	    rn_rd),
d15657 1
a15657 1
 cCE(tmrc,	e100110, 2, (RR, RIWC_RIWG),	    rd_rn),
@


1.250.2.22
log
@        * config/tc-arm.c (s_arm_unwind_save_vfp_armv6): New.  Parse
        a directive saving VFP registers for ARMv6 or later.
        (s_arm_unwind_save): Add parameter arch_v6 and call
        s_arm_unwind_save_vfp or s_arm_unwind_save_vfp_armv6 as
        appropriate.
        (md_pseudo_table): Add entry for new "vsave" directive.
        * doc/c-arm.texi: Correct error in example for "save"
        directive (fstmdf -> fstmdx).  Also document "vsave" directive.
@
text
@d3283 1
a3283 51
/* Parse a directive saving VFP registers for ARMv6 and above.  */

static void
s_arm_unwind_save_vfp_armv6 (void)
{
  int count;
  unsigned int start;
  valueT op;
  int num_vfpv3_regs = 0;
  int num_regs_below_16;

  count = parse_vfp_reg_list (&input_line_pointer, &start, REGLIST_VFP_D);
  if (count == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  /* We always generate FSTMD/FLDMD-style unwinding opcodes (rather
     than FSTMX/FLDMX-style ones).  */

  /* Generate opcode for (VFPv3) registers numbered in the range 16 .. 31.  */
  if (start >= 16)
    num_vfpv3_regs = count;
  else if (start + count > 16)
    num_vfpv3_regs = start + count - 16;

  if (num_vfpv3_regs > 0)
    {
      int start_offset = start > 16 ? start - 16 : 0;
      op = 0xc800 | (start_offset << 4) | (num_vfpv3_regs - 1);
      add_unwind_opcode (op, 2);
    }

  /* Generate opcode for registers numbered in the range 0 .. 15.  */
  num_regs_below_16 = num_vfpv3_regs > 0 ? 16 - (int) start : count;
  assert (num_regs_below_16 + num_vfpv3_regs == count);
  if (num_regs_below_16 > 0)
    {
      op = 0xc900 | (start << 4) | (num_regs_below_16 - 1);
      add_unwind_opcode (op, 2);
    }

  unwind.frame_size += count * 8;
}


/* Parse a directive saving VFP registers for pre-ARMv6.  */
d3521 1
a3521 2
/* Parse an unwind_save directive.
   If the argument is non-zero, this is a .vsave directive.  */
d3524 1
a3524 1
s_arm_unwind_save (int arch_v6)
d3561 1
a3561 6
    case REG_TYPE_VFD:
      if (arch_v6)
        s_arm_unwind_save_vfp_armv6 ();
      else
        s_arm_unwind_save_vfp ();
      return;
a3867 1
  { "vsave",		s_arm_unwind_save,	1 },
@


1.250.2.23
log
@	* config/tc-arm.c (opcode_lookup): Allow Neon type suffixes to be
	recognized in non-unified syntax mode.
@
text
@a13558 3
  bfd_boolean neon_supported;
  
  neon_supported = ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1);
d13561 1
a13561 1
     '.' (in unified mode, or for Neon instructions), or end of string.  */
d13563 1
a13563 1
    if (*end == ' ' || ((unified_syntax || neon_supported) && *end == '.'))
d13574 1
a13574 3
      /* The .w and .n suffixes are only valid if the unified syntax is in
         use.  */
      if (unified_syntax && end[1] == 'w')
d13576 1
a13576 1
      else if (unified_syntax && end[1] == 'n')
d13587 1
a13587 2
	  /* See if we have a Neon type suffix (possible in either unified or
             non-unified ARM syntax mode).  */
@


1.250.2.24
log
@	gas/
	* config/tc-arm.c (md_assemble): Improve diagnostic when attempting
	to use ARM instructions on non-ARM-supporting cores.
	(autoselect_thumb_from_cpu_variant): New function. Switch on Thumb
	mode automatically based on cpu variant.
	(md_begin): Call above function.

	gas/testsuite/
	* gas/arm/noarm.s: Add test for disabled ARM insns.
	* gas/arm/noarm.d: Drive test for above.
	* gas/arm/noarm.l: Expected error output.
@
text
@d13812 1
a13812 1
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1))
a13844 6
  else
    {
      as_bad (_("attempt to use an ARM instruction on a Thumb-only processor "
		"-- `%s'"), str);
      return;
    }
a18848 10
/* Auto-select Thumb mode if it's the only available instruction set for the
   given architecture.  */

static void
autoselect_thumb_from_cpu_variant (void)
{
  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1))
    opcode_select (16);
}

a18948 2
  autoselect_thumb_from_cpu_variant ();

@


1.250.2.25
log
@	gas/
	* config/tc-arm.c (s_arm_unwind_save_mmxwr): Correct condition for
	merging with previous long opcode.

	gas/testsuite/
	* gas/arm/unwind.s: Test not merging iWMMXt register save with
	previous long opcode.
	* gas/arm/unwind.d, gas/arm/unwind_vxworks.d: Update.
@
text
@d3457 1
a3457 1
		  && ((mask & op) == (1u << (reg - 1))))
@


1.250.2.26
log
@2006-09-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_neon_dyadic_if_i): Remove.
	(do_neon_dyadic_if_i_d): Avoid setting U bit.
	(do_neon_mac_maybe_scalar): Ditto.
	(do_neon_dyadic_narrow): Force operand type to NT_integer.
	(insns): Remove out of date comments.

	gas/testsuite/
	* gas/arm/neon-cov.s: Test .u and .s aliases for .i suffixes.
	* gas/arm/neon-cov.d: Adjust expected output.

	opcodes/
	* arm-dis.c (neon_opcode): Fix suffix on VMOVN.
@
text
@d11593 6
d11601 1
a11601 3
  /* The "untyped" case can't happen. Do this to stop the "U" bit being
     affected if we specify unsigned args.  */
  neon_dyadic_misc (NT_untyped, N_IF_32, 0);
d11816 1
a11816 5
    {
      /* The "untyped" case can't happen.  Do this to stop the "U" bit being
	 affected if we specify unsigned args.  */
      neon_dyadic_misc (NT_untyped, N_IF_32, 0);
    }
a12466 3
  /* Operand sign is unimportant, and the U bit is part of the opcode,
     so force the operand type to integer.  */
  et.type = NT_integer;
d15496 1
a15496 1
  /* Comparison. Type I8 I16 I32 F32.  */
d15503 1
@


1.250.2.27
log
@	gas/
	* config/tc-arm.c (parse_qfloat_immediate): Disallow integer syntax for
	floating-point immediates.
@
text
@a4123 1
  char *fpnum = str;
a4124 1
  int found_fpchar = 0;
a4127 21
  /* We must not accidentally parse an integer as a floating-point number. Make
     sure that the value we parse is not an integer by checking for special
     characters '.' or 'e'.
     FIXME: This is a horrible hack, but doing better is tricky because type
     information isn't in a very usable state at parse time.  A better solution
     should be implemented as part of the fix for allowing the full range of
     pseudo-instructions to be used in VMOV, etc.  */
  skip_whitespace (fpnum);
  if (strncmp (fpnum, "0x", 2) != 0)
    {
      for (; *fpnum != '\0' && *fpnum != ' ' && *fpnum != '\n'; fpnum++)
        if (*fpnum == '.' || *fpnum == 'e' || *fpnum == 'E')
          {
            found_fpchar = 1;
            break;
          }

      if (!found_fpchar)
        return FAIL;
    }
  
@


1.250.2.28
log
@2006-09-05  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (NEON_ENC_TAB): Fix encoding of vclt, vcle, vaclt
	and vacle.

	gas/testsuite/
	* gas/arm/neon-cov.d: Adjust expected output.
	* gas/arm/neon-omit.s: Add tests for vcgt and vcle.  Reorder vacle
	and vacle.
	* gas/arm/neon-omit.d: Adjust expected output.
@
text
@d10100 2
a10101 2
  X(vclt,	0x0000300, 0x1200e00, 0x1b10200),	\
  X(vcle,	0x0000310, 0x1000e00, 0x1b10180),	\
d15549 4
a15552 4
 NUF(vaclt,     0200e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
 NUF(vacltq,    0200e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
 NUF(vacle,     0000e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
 NUF(vacleq,    0000e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
@


1.250.2.29
log
@	gas/
	* config/tc-arm.c (parse_qfloat_immediate): Fix hex immediates,
	handle 0.0 and -0.0 specially.

	gas/testsuite/
	* gas/arm/neon-const.s: Use FP syntax for 0/-0.
	* gas/arm/vfp-neon-syntax-inc.s: Likewise, for 1.
@
text
@d4116 3
a4118 3
   The zero and minus-zero cases need special handling, since they can't be
   encoded in the "quarter-precision" float format, but can nonetheless be
   loaded as integer constants.  */
d4124 1
a4124 1
  char *fpnum;
a4136 1
  fpnum = str;
d4138 1
a4138 4

  if (strncmp (fpnum, "0x", 2) == 0)
    return FAIL;
  else
d4163 1
a4163 1
      if (is_quarter_float (fpword) || (fpword & 0x7fffffff) == 0)
@


1.250.2.30
log
@2006-09-06  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (parse_operands): Mark operand as present.

	gas/testsuite/
	* gas/arm/neon-omit.s: Test three-argument variants.
	* gas/arm/neon-omit.d: Update expected output.
@
text
@a5567 1
	    inst.operands[i].present = 1;
@


1.250.2.31
log
@2006-09-07  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (insns): Allow ARM IT pseudo-insn on all cores.

	gas/testsuite/
	* gas/arm/arm-it.s: New test.
	* gas/arm/arm-it.d: New test.
@
text
@d14818 1
a14818 3
 /* ARM does not really have an IT instruction, so always allow it.  */
#undef ARM_VARIANT
#define ARM_VARIANT &arm_ext_v1
@


1.250.2.32
log
@2006-09-08  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (object_arch): New variable.
	(s_arm_object_arch): New function.
	(md_pseudo_table): Add object_arch.
	(aeabi_set_public_attributes): Obey object_arch.
	* doc/c-arm.texi: Document .object_arch.
@
text
@a163 1
static const arm_feature_set *object_arch = NULL;
a3882 1
static void s_arm_object_arch (int);
a3930 1
  { "object_arch",	s_arm_object_arch,	0 },
d19941 1
a19941 7
  /*Allow the user to override the reported architecture.  */
  if (object_arch)
    {
      ARM_CLEAR_FEATURE (flags, flags, arm_arch_any);
      ARM_MERGE_FEATURE_SETS (flags, flags, *object_arch);
    }

a20103 31
/* Parse a .object_arch directive.  */

static void
s_arm_object_arch (int ignored ATTRIBUTE_UNUSED)
{
  const struct arm_arch_option_table *opt;
  char saved_char;
  char *name;

  name = input_line_pointer;
  while (*input_line_pointer && !ISSPACE(*input_line_pointer))
    input_line_pointer++;
  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  /* Skip the first "all" entry.  */
  for (opt = arm_archs + 1; opt->name != NULL; opt++)
    if (streq (opt->name, name))
      {
	object_arch = &opt->value;
	*input_line_pointer = saved_char;
	demand_empty_rest_of_line ();
	return;
      }

  as_bad (_("unknown architecture `%s'\n"), name);
  *input_line_pointer = saved_char;
  ignore_rest_of_line ();
}


@


1.250.2.33
log
@	gas/
	* config/tc-arm.c (parse_immediate): Add BOUNDED parameter, rename
	to...
	(parse_immediate_maybe_bounded): This. Only bounds-check if BOUNDED
	is true.
	(parse_immediate_bounded): New function, with same arguments and
	semantics as previous parse_immediate.
	(parse_immediate_unbounded): New function. Parse an unbounded
	integer (with sizeof (exp.X_add_number)).
	(parse_big_immediate): Allow for 64-bit exp.X_add_number when
	parsing 64-bit immediates.
	(parse_address_main): Use parse_immediate_bounded not
	parse_immediate.
	(parse_ror): Likewise.
	(parse_operands): Likewise. For Neon immediates, use
	parse_immediate_unbounded. Add new local po_imm_unb_or_fail macro.
@
text
@d3949 2
a3950 2
   VAL receives the value; if the value is outside [MIN, MAX] and BOUNDED is
   true, it issue an error.  PREFIX_OPT is true if the immediate prefix is
d3954 2
a3955 2
parse_immediate_maybe_bounded (char **str, int *val, bfd_boolean bounded,
			       int min, int max, bfd_boolean prefix_opt)
d3965 1
a3965 1
  if (bounded && (exp.X_add_number < min || exp.X_add_number > max))
a3974 13
static int
parse_immediate_bounded (char **str, int *val, int min, int max,
			 bfd_boolean prefix_opt)
{
  return parse_immediate_maybe_bounded (str, val, TRUE, min, max, prefix_opt);
}

static int
parse_immediate_unbounded (char **str, int *val, bfd_boolean prefix_opt)
{
  return parse_immediate_maybe_bounded (str, val, FALSE, 0, 0, prefix_opt);
}

d3988 1
a3988 12
    {
      inst.operands[i].imm = exp.X_add_number & 0xffffffff;
      /* If we're on a 64-bit host, then a 64-bit number can be returned using
	 O_constant.  We have to be careful not to break compilation for
	 32-bit X_add_number, though.  */
      if ((exp.X_add_number & ~0xffffffffl) != 0)
	{
          /* X >> 32 is illegal if sizeof (exp.X_add_number) == 4.  */
	  inst.operands[i].reg = ((exp.X_add_number >> 16) >> 16) & 0xffffffff;
	  inst.operands[i].regisimm = 1;
	}
    }
d4706 2
a4707 2
	  if (parse_immediate_bounded (&p, &inst.operands[i].imm,
				       0, 255, TRUE) == FAIL)
d4978 1
a4978 1
  if (parse_immediate_bounded (&s, &rot, 0, 24, FALSE) == FAIL)
d5485 1
a5485 7
  if (parse_immediate_bounded (&str, &val, min, max, popt) == FAIL) \
    goto failure;						\
  inst.operands[i].imm = val;					\
} while (0)

#define po_imm_unb_or_fail(popt) do {				\
  if (parse_immediate_unbounded (&str, &val, popt) == FAIL)	\
d5585 1
a5585 1
            po_imm_unb_or_fail (TRUE);
a6033 1
#undef po_imm_unb_or_fail
@


1.250.2.34
log
@2006-09-14  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (thumb32_negate_data_op): Consistently use
	unsigned int to avoid 64-bit host problems.
@
text
@d17218 1
a17218 1
thumb32_negate_data_op (offsetT *instruction, unsigned int value)
d17222 1
a17222 1
  unsigned int negated, inverted;
d17283 1
a17283 1
  if (value == (unsigned int)FAIL)
@


1.250.2.35
log
@2006-09-14  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (s_arm_unwind_movsp): Add offset argument.
	* doc/c-arm.texi (movsp): Document offset argument.
@
text
@a3635 1
  int offset;
a3643 10

  /* Optional constant.	 */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    {
      if (immediate_for_directive (&offset) == FAIL)
	return;
    }
  else
    offset = 0;

d3661 1
a3661 1
  unwind.fp_offset = unwind.frame_size - offset;
@


1.250.2.36
log
@2006-09-18  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (parse_immediate_maybe_bounded): Rename back...
	(parse_immediate): ... to this.  Revert earlier changes.
	(parse_immediate_bounded): Remove.
	(parse_immediate_unbounded): Remove.
	(parse_address_main): Revert earlier changes.
	(parse_ror): Ditto.
	(po_imm_unb_or_fail): Remove.
	(neon_cmode_for_logic_imm): Try smaller element sizes.
	(neon_cmode_for_move_imm): Ditto.
	(do_neon_logic): Handle .i64 pseudo-op.

	gas/testsuite/
	* testsuite/gas/arm/neon-cov.s: Test pseudo-instruction forms of
	vmov, vmvn and logic immediate instructions.
	* testsuite/gas/arm/neon-cov.d: ditto.
@
text
@d3960 2
a3961 2
   VAL receives the value; if the value is outside [MIN, MAX]
   issue an error.  PREFIX_OPT is true if the immediate prefix is
d3965 2
a3966 2
parse_immediate (char **str, int *val, int min, int max,
		 bfd_boolean prefix_opt)
d3976 1
a3976 1
  if (exp.X_add_number < min || exp.X_add_number > max)
d3986 13
d4000 1
a4000 1
   big (64-bit) immediate, as required by Neon VMOV, VMVN and logic immediate
d4741 2
a4742 2
	  if (parse_immediate (&p, &inst.operands[i].imm,
			       0, 255, TRUE) == FAIL)
d5013 1
a5013 1
  if (parse_immediate (&s, &rot, 0, 24, FALSE) == FAIL)
d5520 7
a5526 1
  if (parse_immediate (&str, &val, min, max, popt) == FAIL)	\
d5625 2
a5626 7
            /* There's a possibility of getting a 64-bit immediate here, so
               we need special handling.  */
            if (parse_big_immediate (&str, i) == FAIL)
              {
                inst.error = _("immediate value is out of range");
                goto failure;
              }
d6075 1
d11350 2
a11351 2
  /* Handle .I8 pseudo-instructions.  */
  if (size == 8)
d11353 1
d11359 9
a11367 27
    }

  if (size >= 32)
    {
      if (immediate == (immediate & 0x000000ff))
	{
	  *immbits = immediate;
	  return 0x1;
	}
      else if (immediate == (immediate & 0x0000ff00))
	{
	  *immbits = immediate >> 8;
	  return 0x3;
	}
      else if (immediate == (immediate & 0x00ff0000))
	{
	  *immbits = immediate >> 16;
	  return 0x5;
	}
      else if (immediate == (immediate & 0xff000000))
	{
	  *immbits = immediate >> 24;
	  return 0x7;
	}
      if ((immediate & 0xffff) != (immediate >> 16))
	goto bad_immediate;
      immediate &= 0xffff;
d11373 1
a11373 1
      return 0x9;
d11378 11
a11388 1
      return 0xb;
d11429 1
a11429 2
   MVN).  If the immediate looks like a repeated parttern then also
   try smaller element sizes.  */
d11442 31
a11472 2

  if (size == 64)
d11474 4
a11477 13
      if (neon_bits_same_in_bytes (immhi)
	  && neon_bits_same_in_bytes (immlo))
	{
	  if (*op == 1)
	    return FAIL;
	  *immbits = (neon_squash_bits (immhi) << 4)
		     | neon_squash_bits (immlo);
	  *op = 1;
	  return 0xe;
	}

      if (immhi != immlo)
	return FAIL;
d11479 1
a11479 2

  if (size >= 32)
d11481 4
a11484 34
      if (immlo == (immlo & 0x000000ff))
	{
	  *immbits = immlo;
	  return 0x0;
	}
      else if (immlo == (immlo & 0x0000ff00))
	{
	  *immbits = immlo >> 8;
	  return 0x2;
	}
      else if (immlo == (immlo & 0x00ff0000))
	{
	  *immbits = immlo >> 16;
	  return 0x4;
	}
      else if (immlo == (immlo & 0xff000000))
	{
	  *immbits = immlo >> 24;
	  return 0x6;
	}
      else if (immlo == ((immlo & 0x0000ff00) | 0x000000ff))
	{
	  *immbits = (immlo >> 8) & 0xff;
	  return 0xc;
	}
      else if (immlo == ((immlo & 0x00ff0000) | 0x0000ffff))
	{
	  *immbits = (immlo >> 16) & 0xff;
	  return 0xd;
	}

      if ((immlo & 0xffff) != (immlo >> 16))
	return FAIL;
      immlo &= 0xffff;
d11486 1
a11486 2

  if (size >= 16)
d11488 4
a11491 14
      if (immlo == (immlo & 0x000000ff))
	{
	  *immbits = immlo;
	  return 0x8;
	}
      else if (immlo == (immlo & 0x0000ff00))
	{
	  *immbits = immlo >> 8;
	  return 0xa;
	}

      if ((immlo & 0xff) != (immlo >> 8))
	return FAIL;
      immlo &= 0xff;
d11493 1
a11493 2

  if (immlo == (immlo & 0x000000ff))
d11495 4
a11498 5
      /* Don't allow MVN with 8-bit immediate.  */
      if (*op == 1)
	return FAIL;
      *immbits = immlo;
      return 0xe;
a11580 13
      immbits = inst.operands[1].imm;
      if (et.size == 64)
	{
	  /* .i64 is a pseudo-op, so the immediate must be a repeating
	     pattern.  */
	  if (immbits != (inst.operands[1].regisimm ?
			  inst.operands[1].reg : 0))
	    {
	      /* Set immbits to an invalid constant.  */
	      immbits = 0xdeadbeef;
	    }
	}

d11584 2
a11585 1
          cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
d11589 2
a11590 1
          cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
d11595 1
d11602 1
@


1.250.2.37
log
@2006-09-19  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	bfd/
	* archures.c: Add definition for bfd_mach_arm_iWMMXt2.
	* cpu-arm.c (processors): Add bfd_mach_arm_iWMMXt2.
	(arch_info_struct, bfd_arm_update_notes): Likewise.
	(architectures): Likewise.
	(bfd_arm_merge_machines): Check for iWMMXt2.
	* bfd-in2.h: Rebuild.

	gas/
	* config/tc-arm.c (enum operand_parse_code): New code OP_RIWR_I32z.
	(parse_operands): Handle OP_RIWR_I32z.
	(do_iwmmxt_wmerge): New function.
	(do_iwmmxt_wldstd): Handle iwmmxt2 case where second operand is
	a register.
	(do_iwmmxt_wrwrwr_or_imm5): New function.
	(insns): Mark instructions as RIWR_I32z as appropriate.
	Also add torvsc<b,h,w>, wabs<b,h,w>, wabsdiff<b,h,w>,
	waddbhus<l,m>, waddhc, waddwc, waddsubhx, wavg4{r}, wmaddu{x,n},
	wmadds{x,n}, wmerge, wmiaxy{n}, wmiawxy{n}, wmul<sm,um>{r},
	wmulw<um,sm,l>{r}, wqmiaxy{n}, wqmulm{r}, wqmulwm{r}, wsubaddhx.
	(md_begin): Handle IWMMXT2.
	(arm_cpus): Add iwmmxt2.
	(arm_extensions): Likewise.
	(arm_archs): Likewise.

	gas/testsuite/
	* gas/arm/iwmmxt2.s: New file.
	* gas/arm/iwmmxt2.d: New file.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): The X-qualifier to WMADD may
	only be used with the default multiply-add operation, so if N is
	set, don't bother printing X.  Add new iwmmxt instructions.
	(IWMMXT_INSN_COUNT): Update.
	(iwmmxt_wwssnames): Qualify "wwss" names at index 2, 6, 10 and 14
	with a 'c' suffix.
	(print_insn_coprocessor): Check for iWMMXt2.  Handle format
	specifiers 'r', 'i'.
@
text
@a210 2
static const arm_feature_set arm_cext_iwmmxt2 =
  ARM_FEATURE (0, ARM_CEXT_IWMMXT2);
a5384 1
  OP_RIWR_I32z, /* iWMMXt wR register, or immediate 0 .. 32 for iWMMXt2.  */
a5811 3
	case OP_RIWR_I32z: po_reg_or_goto (REG_TYPE_MMXWR, I32z); break;
	I32z:		  po_imm_or_fail (0, 32, FALSE);	  break;

a7859 9
do_iwmmxt_wmerge (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 21;
}

static void
d7898 1
a7898 17
  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2)
      && inst.operands[1].immisreg)
    {
      inst.instruction &= ~0x1a000ff;
      inst.instruction |= (0xf << 28);
      if (inst.operands[1].preind)
	inst.instruction |= PRE_INDEX;
      if (!inst.operands[1].negative)
	inst.instruction |= INDEX_UP;
      if (inst.operands[1].writeback)
	inst.instruction |= WRITE_BACK;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.reloc.exp.X_add_number << 4;
      inst.instruction |= inst.operands[1].imm;
    }
  else
    encode_arm_cp_address (1, TRUE, FALSE, 0);
a7917 50

static void
do_iwmmxt_wrwrwr_or_imm5 (void)
{
  if (inst.operands[2].isreg)
    do_rd_rn_rm ();
  else {
    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2),
		_("immediate operand requires iWMMXt2"));
    do_rd_rn ();
    if (inst.operands[2].imm == 0)
      {
	switch ((inst.instruction >> 20) & 0xf)
	  {
	  case 4:
	  case 5:
	  case 6:
	  case 7: 
	    /* w...h wrd, wrn, #0 -> wrorh wrd, wrn, #16.  */
	    inst.operands[2].imm = 16;
	    inst.instruction = (inst.instruction & 0xff0fffff) | (0x7 << 20);
	    break;
	  case 8:
	  case 9:
	  case 10:
	  case 11:
	    /* w...w wrd, wrn, #0 -> wrorw wrd, wrn, #32.  */
	    inst.operands[2].imm = 32;
	    inst.instruction = (inst.instruction & 0xff0fffff) | (0xb << 20);
	    break;
	  case 12:
	  case 13:
	  case 14:
	  case 15:
	    {
	      /* w...d wrd, wrn, #0 -> wor wrd, wrn, wrn.  */
	      unsigned long wrn;
	      wrn = (inst.instruction >> 16) & 0xf;
	      inst.instruction &= 0xff0fff0f;
	      inst.instruction |= wrn;
	      /* Bail out here; the instruction is now assembled.  */
	      return;
	    }
	  }
      }
    /* Map 32 -> 0, etc.  */
    inst.operands[2].imm &= 0x1f;
    inst.instruction |= (0xf << 28) | ((inst.operands[2].imm & 0x10) << 4) | (inst.operands[2].imm & 0xf);
  }
}
d15917 1
a15917 1
 cCE(wrorh,	e700040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15919 1
a15919 1
 cCE(wrorw,	eb00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15921 1
a15921 1
 cCE(wrord,	ef00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15928 1
a15928 1
 cCE(wsllh,	e500040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15930 1
a15930 1
 cCE(wsllw,	e900040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15932 1
a15932 1
 cCE(wslld,	ed00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15934 1
a15934 1
 cCE(wsrah,	e400040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15936 1
a15936 1
 cCE(wsraw,	e800040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15938 1
a15938 1
 cCE(wsrad,	ec00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15940 1
a15940 1
 cCE(wsrlh,	e600040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15942 1
a15942 1
 cCE(wsrlw,	ea00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
d15944 1
a15944 1
 cCE(wsrld,	ee00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
a15980 60
#define ARM_VARIANT &arm_cext_iwmmxt2 /* Intel Wireless MMX technology, version 2.  */
 cCE(torvscb,   e13f190, 1, (RR),		    iwmmxt_tandorc),
 cCE(torvsch,   e53f190, 1, (RR),		    iwmmxt_tandorc),
 cCE(torvscw,   e93f190, 1, (RR),		    iwmmxt_tandorc),
 cCE(wabsb,     e2001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE(wabsh,     e6001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE(wabsw,     ea001c0, 2, (RIWR, RIWR),           rd_rn),
 cCE(wabsdiffb, e1001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wabsdiffh, e5001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wabsdiffw, e9001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddbhusl, e2001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddbhusm, e6001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddhc,    e600180, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddwc,    ea00180, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(waddsubhx, ea001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wavg4,	e400000, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wavg4r,    e500000, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmaddsn,   ee00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmaddsx,   eb00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmaddun,   ec00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmaddux,   e900100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmerge,    e000080, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_wmerge),
 cCE(wmiabb,    e0000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiabt,    e1000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiatb,    e2000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiatt,    e3000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiabbn,   e4000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiabtn,   e5000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiatbn,   e6000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiattn,   e7000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawbb,   e800120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawbt,   e900120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawtb,   ea00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawtt,   eb00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawbbn,  ec00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawbtn,  ed00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawtbn,  ee00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmiawttn,  ef00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulsmr,   ef00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulumr,   ed00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwumr,  ec000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwsmr,  ee000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwum,   ed000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwsm,   ef000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wmulwl,    eb000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiabb,   e8000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiabt,   e9000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiatb,   ea000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiatt,   eb000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiabbn,  ec000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiabtn,  ed000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiatbn,  ee000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmiattn,  ef000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmulm,    e100080, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmulmr,   e300080, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmulwm,   ec000e0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wqmulwmr,  ee000e0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
 cCE(wsubaddhx, ed001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),

#undef ARM_VARIANT
d19145 1
a19145 3
  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2))
    mach = bfd_mach_arm_iWMMXt2;
  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt))
a19523 1
  {"iwmmxt2",		ARM_ARCH_IWMMXT2,FPU_ARCH_VFP_V2, NULL},
a19572 1
  {"iwmmxt2",		ARM_ARCH_IWMMXT2,FPU_ARCH_VFP},
a19587 1
  {"iwmmxt2",		ARM_FEATURE (0, ARM_CEXT_IWMMXT2)},
@


1.250.2.38
log
@        gas/
        * config/tc-arm.c (md_apply_fix): Turn CZB instructions that
        attempt to jump to the next instruction into NOPs.
@
text
@d17977 3
d17981 1
a17981 4
      /* Attempts to use CZB to branch to the next instruction
	 (which, strictly speaking, are prohibited) will be turned into
	 no-ops.  */
      if (value == -2)
d17984 1
a17984 1
	  newval = 0xbf00; /* NOP encoding T1 */
a17986 13
      else
	{
	  if (value & ~0x7e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
		          _("branch out of range"));

          if (fixP->fx_done || !seg->use_rela_p)
	    {
	      newval = md_chars_to_number (buf, THUMB_SIZE);
	      newval |= ((value & 0x3e) << 2) | ((value & 0x40) << 3);
	      md_number_to_chars (buf, newval, THUMB_SIZE);
	    }
	}
@


1.250.2.39
log
@2006-10-25  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_vfp_sp_const, do_vfp_dp_const): Fix operans
	encoding.

	gas/testsuite/
	* gas/arm/vfpv3-const-conv.s: Improve test coverage.
	* gas/arm/vfpv3-const-conv.d: Adjust expected output.
	* gas/arm/vfp-neon-syntax_t2.d: Ditto.
	* gas/arm/vfp-neon-syntax.d: Ditto.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Fix bitfields for fconstd/fconstd.
@
text
@d7719 2
a7720 2
  inst.instruction |= (inst.operands[1].imm & 0xf0) << 12;
  inst.instruction |= (inst.operands[1].imm & 0x0f);
d7727 2
a7728 2
  inst.instruction |= (inst.operands[1].imm & 0xf0) << 12;
  inst.instruction |= (inst.operands[1].imm & 0x0f);
@


1.250.2.40
log
@2006-10-26  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_neon_ext): Enforce immediate range.
	(insns): Use I15 for vext.

	gas/testsute/
	* gas/arm/neon-cov.s: Add new vext test.
	* gas/arm/neon-cov.d: Ditto.
@
text
@a12684 1
  constraint (imm >= 8 * neon_quad (rs), _("shift out of range"));
d15785 2
a15786 2
 NUF(vext,      0b00000, 4, (RNDQ, oRNDQ, RNDQ, I15), neon_ext),
 NUF(vextq,     0b00000, 4, (RNQ,  oRNQ,  RNQ,  I15), neon_ext),
@


1.250.2.41
log
@2006-10-26  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_adjust_symtab): Don't use STT_ARM_16BIT
	for EABIv4.
@
text
@d19092 1
a19092 1
	      else if (EF_ARM_EABI_VERSION (meabi_flags) < EF_ARM_EABI_VER4)
@


1.250.2.42
log
@2006-10-26  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_is_eabi): New function.
	* config/tc-arm.h (arm_is_eabi): New prototype.
	(THUMB_IS_FUNC): Use ELF function type for EABI objects.
	* doc/c-arm.texi (.thumb_func): Update documentation.
@
text
@a240 6

bfd_boolean
arm_is_eabi(void)
{
  return (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4);
}
@


1.250.2.43
log
@2006-10-26  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_neon_ext): Fix constraint.
@
text
@d12691 1
a12691 1
  constraint (imm >= (neon_quad (rs) ? 16 : 8), _("shift out of range"));
@


1.250.2.44
log
@        gas/
        * config/tc-arm.c (do_t_czb): Rename to do_t_cbz.
        (insns): Adjust accordingly.
        (md_apply_fix): Alter comments to use CBZ instead of CZB.
@
text
@d8976 1
a8976 1
do_t_cbz (void)
d14975 2
a14976 2
  UT(cbnz,      b900,    2, (RR, EXP), t_cbz),
  UT(cbz,       b100,    2, (RR, EXP), t_cbz),
d17982 2
a17983 2
    case BFD_RELOC_THUMB_PCREL_BRANCH7: /* CBZ */
      /* CBZ can only branch forward.  */
d17985 1
a17985 1
      /* Attempts to use CBZ to branch to the next instruction
@


1.250.2.45
log
@2006-12-01  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	gas/
	* config/tc-arm.c (arm_force_relocation): Return 1 for relocs against
	function symbols.

	gas/testsuite/
	* gas/arm/thumbrel.s: New test.
	* gas/arm/thumbrel.d: New test.
@
text
@a18907 6
  /* Always generate relocations against function symbols.  */
  if (fixp->fx_r_type == BFD_RELOC_32
      && fixp->fx_addsy
      && (symbol_get_bfdsym (fixp->fx_addsy)->flags & BSF_FUNCTION))
    return 1;

@


1.250.2.46
log
@2006-12-13  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	gas/
	* config/tc-arm.c (arm_arch_option_table): Add v7-{a,r,m}.
	* doc/c-arm.texi: Fix spelling of ARMv7 profile variants.
@
text
@a19737 2
  /* The official spelling of the ARMv7 profile variants is the dashed form.
     Accept the non-dashed form for compatibility with old toolchains.  */
a19740 3
  {"armv7-a",		ARM_ARCH_V7A,	 FPU_ARCH_VFP},
  {"armv7-r",		ARM_ARCH_V7R,	 FPU_ARCH_VFP},
  {"armv7-m",		ARM_ARCH_V7M,	 FPU_ARCH_VFP},
@


1.249
log
@2006-03-20  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (output_relax_insn): Call dwarf2_emit_insn before
	outputting the insn.
@
text
@d571 2
d6602 1
d6624 14
a6637 1
  if (inst.cond != COND_ALWAYS)
d6645 1
a6645 1
      if (inst.cond == COND_ALWAYS)
d6649 2
a6650 2
	  assert (inst.cond != 0xF);
	  inst.instruction |= inst.cond << 22;
d6657 1
a6657 1
      if (inst.cond == COND_ALWAYS)
d6661 1
a6661 1
	  inst.instruction |= inst.cond << 8;
d6675 2
d6688 1
d6707 1
d6717 1
d6733 7
d6742 1
d6789 1
d6826 1
d7661 1
d7930 3
a7936 2
  constraint (half && !inst.operands[0].shifted,
	      _("instruction requires shifted index"));
d8261 10
a8270 3
	  /* delayed diagnostic */
	  inst.error = BAD_COND;
	  inst.cond = COND_ALWAYS;
d8365 5
a8369 1
	  if (cond != inst.cond)
a8373 2
	  current_it_mask <<= 1;
	  current_it_mask &= 0x1f;
d8869 2
a8870 1
   field is still 0xE.  */
d9208 1
a9208 1
 TUF(cps,	1020000, f3af8100, 1, (I31b),			  imm0, imm0),
@


1.248
log
@2006-03-17  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (insns): Add ldm and stm.
gas/testsuite/
	* gas/arm/thumb32.d: Add ldm and stm tests.
	* gas/arm/thumb32.s: Ditto.
@
text
@d7985 6
a8008 4

#ifdef OBJ_ELF
  dwarf2_emit_insn (INSN_SIZE);
#endif
@


1.247
log
@2006-03-16  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (insns): Add "svc".
gas/testsuite/
	* gas/arm/svc.d: New test.
	* gas/arm/svc.s: New test.
	* gas/arm/inst.d: Accept svc mnemonic.
	* gas/arm/thumb.d: Ditto.
	* gas/arm/wince_inst.d: Ditto.
opcodes/
	* arm-dis.c (arm_opcodes): Rename swi to svc.
	(thumb_opcodes): Ditto.
@
text
@d8947 1
d8950 1
@


1.246
log
@2006-03-10  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (INTERWORK_FLAG): Handle EABIv5.
	(elf32_arm_print_private_bfd_data): Ditto.
binutils/
	* readelf.c (decode_ARM_machine_flags):  Handle EABIv5.
gas/
	* config/tc-arm.c (md_begin): Handle EABIv5.
	(arm_eabis): Add EF_ARM_EABI_VER5.
	* doc/c-arm.texi: Document -meabi=5.
include/elf/
	* arm.h (EF_ARM_EABI_VER5): Define.
@
text
@d8953 1
@


1.245
log
@bfd/
	* configure.in (bfd_elf32_bigarm_vec): Include elf-vxworks.lo.
	(bfd_elf32_bigarm_symbian_vec): Likewise.
	(bfd_elf32_bigarm_vxworks_vec): Likewise.
	(bfd_elf32_littlearm_vec): Likewise.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	(bfd_elf32_littlearm_vxworks_vec): Likewise.
	* configure: Regenerate.
	* elf32-arm.c: Include libiberty.h and elf-vxworks.h.
	(RELOC_SECTION, RELOC_SIZE, SWAP_RELOC_IN, SWAP_RELOC_OUT): New macros.
	(elf32_arm_vxworks_bed): Add forward declaration.
	(elf32_arm_howto_table_1): Fix the masks for R_ASM_ABS12.
	(elf32_arm_vxworks_exec_plt0_entry): New table.
	(elf32_arm_vxworks_exec_plt_entry): Likewise.
	(elf32_arm_vxworks_shared_plt_entry): Likewise.
	(elf32_arm_link_hash_table): Add vxworks_p and srelplt2 fields.
	(reloc_section_p): New function.
	(create_got_section): Use RELOC_SECTION.
	(elf32_arm_create_dynamic_sections): Likewise.  Call
	elf_vxworks_create_dynamic_sections for VxWorks targets.
	Choose between the two possible values of plt_header_size
	and plt_entry_size.
	(elf32_arm_link_hash_table_create): Initialize vxworks_p and srelplt2.
	(elf32_arm_abs12_reloc): New function.
	(elf32_arm_final_link_relocate): Call it.  Allow the creation of
	dynamic R_ARM_ABS12 relocs on VxWorks.  Use reloc_section_p,
	RELOC_SIZE, SWAP_RELOC_OUT and RELOC_SECTION.  Initialize the
	r_addend fields of relocs.  On rela targets, skip any code that
	adjusts in-place addends.  When using _bfd_link_final_relocate
	to perform a final relocation, pass rel->r_addend as the addend
	argument.
	(elf32_arm_merge_private_bfd_data): If one of the bfds is a VxWorks
	object, ignore flags that are not standard on VxWorks.
	(elf32_arm_check_relocs): Allow the creation of dynamic R_ARM_ABS12
	relocs on VxWorks.  Use reloc_section_p.
	(elf32_arm_adjust_dynamic_symbol): Use RELOC_SECTION and RELOC_SIZE.
	(allocate_dynrelocs): Use RELOC_SIZE.  Account for the size of
	.rela.plt.unloaded relocs on VxWorks targets.
	(elf32_arm_size_dynamic_sections): Use RELOC_SIZE.  Check for
	.rela.plt.unloaded as well as .rel(a).plt.  Add DT_RELA* tags
	instead of DT_REL* tags on RELA targets.
	(elf32_arm_finish_dynamic_symbol): Use RELOC_SECTION, RELOC_SIZE
	and SWAP_RELOC_OUT.  Initialize r_addend fields.  Handle VxWorks
	PLT entries.  Do not make _GLOBAL_OFFSET_TABLE_ absolute on VxWorks.
	(elf32_arm_finish_dynamic_sections): Use RELOC_SECTION, RELOC_SIZE
	and SWAP_RELOC_OUT.  Initialize r_addend fields.  Handle DT_RELASZ
	like DT_RELSZ.  Handle the VxWorks form of initial PLT entry.
	Correct the .rela.plt.unreloaded symbol indexes.
	(elf32_arm_output_symbol_hook): Call the VxWorks version of this
	hook on VxWorks targets.
	(elf32_arm_vxworks_link_hash_table_create): Set vxworks_p to true.
	Minor formatting tweak.
	(elf32_arm_vxworks_final_write_processing): New function.
	(elf_backend_add_symbol_hook): Override for VxWorks and reset
	for Symbian.
	(elf_backend_final_write_processing): Likewise.
	(elf_backend_emit_relocs): Likewise.
	(elf_backend_want_plt_sym): Likewise.
	(ELF_MAXPAGESIZE): Likewise.
	(elf_backend_may_use_rel_p): Minor formatting tweak.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elf_backend_rela_normal): Likewise.
	* Makefile.in (elf32-arm.lo): Depend on elf-vxworks.h.

gas/
	* config/tc-arm.c (md_apply_fix): Install a value of zero into a
	BFD_RELOC_ARM_OFFSET_IMM field if we're going to generate a RELA
	R_ARM_ABS12 reloc.
	(tc_gen_reloc): Keep the original fx_offset for RELA pc-relative
	relocs, but adjust by md_pcrel_from_section.  Create R_ARM_ABS12
	relocations for BFD_RELOC_ARM_OFFSET_IMM on RELA targets.

gas/testsuite/
	* gas/arm/abs12.s, gas/arm/abs12.d: New test.
	* gas/arm/pic.d: Skip for *-*-vxworks*...
	* gas/arm/pic_vxworks.d: ...use this version instead.
	* gas/arm/unwind_vxworks.d: Fix expected output.

ld/
	* emulparams/armelf_vxworks.sh: Include vxworks.sh.
	(MAXPAGESIZE): Define.
	* emulparams/vxworks.sh: Undefine.
	* Makefile.am (earmelf_vxworks.c): Depend on vxworks.sh and vxworks.em.
	* Makefile.in: Regenerate.

ld/testsuite/
	* ld-arm/vxworks1.dd, ld-arm/vxworks1.ld, ld-arm/vxworks1-lib.dd,
	* ld-arm/vxworks1-lib.nd, ld-arm/vxworks1-lib.rd,
	* ld-arm/vxworks1-lib.s, ld-arm/vxworks1.rd, ld-arm/vxworks1.s,
	* ld-arm/vxworks1-static.d, ld-arm/vxworks2.s, ld-arm/vxworks2.sd,
	* ld-arm/vxworks2-static.sd: New tests.
	* ld-arm/arm-elf.exp: Run them.
@
text
@d12854 1
d13371 1
a13371 1
/* We only know how to output GNU and ver 4 (AAELF) formats.  */
d13376 1
@


1.244
log
@Check in correct version of previous patch.
@
text
@d11538 3
d12262 1
a12262 2
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED,
	      fixS *	 fixp)
d12274 6
a12279 1
    fixp->fx_offset = reloc->address;
d12367 6
@


1.243
log
@2006-02-24  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/arm/tc-arm.c (arm_ext_v6_notm, arm_ext_div, arm_ext_v7,
	arm_ext_v7a, arm_ext_v7r, arm_ext_v7m): New variables.
	(struct asm_barrier_opt): Define.
	(arm_v7m_psr_hsh, arm_barrier_opt_hsh): New variables.
	(parse_psr): Accept V7M psr names.
	(parse_barrier): New function.
	(enum operand_parse_code): Add OP_oBARRIER.
	(parse_operands): Implement OP_oBARRIER.
	(do_barrier): New function.
	(do_dbg, do_pli, do_t_barrier, do_t_dbg, do_t_div): New functions.
	(do_t_cpsi): Add V7M restrictions.
	(do_t_mrs, do_t_msr): Validate V7M variants.
	(md_assemble): Check for NULL variants.
	(v7m_psrs, barrier_opt_names): New tables.
	(insns): Add V7 instructions.  Mark V6 instructions absent from V7M.
	(md_begin): Initialize arm_v7m_psr_hsh and arm_barrier_opt_hsh.
	(arm_cpu_option_table): Add Cortex-M3, R4 and A8.
	(arm_arch_option_table): Add armv7, armv7a, armv7r and armv7m.
	(struct cpu_arch_ver_table): Define.
	(cpu_arch_ver): New.
	(aeabi_set_public_attributes): Use cpu_arch_ver.  Set
	Tag_CPU_arch_profile.
	* doc/c-arm.texi: Document new cpu and arch options.
gas/testsuite/
	* gas/arm/thumb32.d: Fix expected msr and mrs output.
	* gas/arm/arch7.d: New test.
	* gas/arm/arch7.s: New test.
	* gas/arm/arch7m-bad.l: New test.
	* gas/arm/arch7m-bad.d: New test.
	* gas/arm/arch7m-bad.s: New test.
include/opcode/
	* arm.h: Add V7 feature bits.
opcodes/
	* arm-dis.c (arm_opcodes): Add V7 instructions.
	(thumb32_opcodes): Ditto.  Handle V7M MSR/MRS variants.
	(print_arm_address): New function.
	(print_insn_arm): Use it.  Add 'P' and 'U' cases.
	(psr_name): New function.
	(print_insn_thumb32): Add 'U', 'C' and 'D' cases.
@
text
@d9255 5
a9266 5
#undef THUMB_VARIANT
#define THUMB_VARIANT &arm_ext_v6_notm
 TCE(ldrexd,	1b00f9f, e8d0007f, 3, (RRnpc, oRRnpc, RRnpcb),        ldrexd, t_ldrexd),
 TCE(strexd,	1a00f90, e8c00070, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb), strexd, t_strexd),

@


1.242
log
@2005-02-22  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (do_pld): Remove incorrect write to
	inst.instruction.
	(encode_thumb32_addr_mode): Use correct operand.
gas/testsuite/
	* gas/arm/thumb32.d: Fix expected pld opcode.
@
text
@d185 6
d337 6
d576 1
d579 1
d3498 2
d3504 1
a3504 1
  if (*p == 's' || *p == 'S')
d3506 1
a3506 1
  else if (*p == 'c' || *p == 'C')
d3509 9
a3517 1
    goto error;
d3519 3
a3521 4
  p++;
  if (strncasecmp (p, "PSR", 3) != 0)
    goto error;
  p += 3;
d3523 1
a3526 3
      const struct asm_psr *psr;
      char *start;

d3677 20
d3821 1
d4043 1
d4111 1
d4633 14
d4875 6
d5251 16
d6528 14
d6715 2
a6716 1
      && (inst.operands[1].present || inst.size_req == 4))
d6727 5
a6731 1
      constraint (inst.operands[1].present,
d6767 16
d7329 18
a7346 4
  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
  constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
	      != (PSR_c|PSR_f),
	      _("'CPSR' or 'SPSR' expected"));
d7348 2
a7349 1
  inst.instruction |= (inst.operands[1].imm & SPSR_BIT) >> 2;
d7355 2
d7359 17
a7375 2
  inst.instruction |= (inst.operands[0].imm & SPSR_BIT) >> 2;
  inst.instruction |= (inst.operands[0].imm & ~SPSR_BIT) >> 8;
d8304 3
a8306 2
      if (thumb_mode == 1
	  && !ARM_CPU_HAS_FEATURE (variant, *opcode->tvariant))
d8371 2
a8372 1
      if (!ARM_CPU_HAS_FEATURE (cpu_variant, *opcode->avariant))
d8678 19
d8746 8
a9149 1
 TUF(cps,	1020000, f3af8100, 1, (I31b),			  imm0, imm0),
d9153 8
a9237 1
 TCE(ssat,	6a00010, f3000000, 4, (RRnpc, I32, RRnpc, oSHllar),ssat,   t_ssat),
a9242 1
 TCE(usat,	6e00010, f3800000, 4, (RRnpc, I31, RRnpc, oSHllar),usat,   t_usat),
a9257 1
 TCE(ldrexd,	1b00f9f, e8d0007f, 3, (RRnpc, oRRnpc, RRnpcb),        ldrexd, t_ldrexd),
d9260 5
a9265 1
 TUF(clrex,	57ff01f, f3bf8f2f, 0, (),			      noargs, noargs),
d9316 17
d12707 1
d12709 2
a12710 1
      || (arm_reloc_hsh = hash_new ()) == NULL)
d12721 2
d12725 5
d13241 3
d13291 4
d13694 25
d13725 2
d13733 11
a13743 19
  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v6t2))
    arch = 8;
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v6z))
    arch = 7;
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v6k))
    arch = 9;
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v6))
    arch = 6;
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v5e))
    arch = 4;
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v5)
	   || ARM_CPU_HAS_FEATURE (flags, arm_ext_v5t))
    arch = 3;
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v4t))
    arch = 2;
  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v4))
    arch = 1;
  else
    arch = 0;
d13763 7
@


1.241
log
@2006-02-21  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (md_apply_fix): Fix off-by-one errors.
@
text
@a5183 1
  inst.instruction |= inst.operands[0].reg;
d5902 1
a5902 1
      inst.instruction |= inst.operands[1].imm;
d5918 1
a5918 1
      constraint (is_t && inst.operands[1].writeback,
@


1.240
log
@2006-02-02  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (do_shift): Remove Thumb-1 constraint.
@
text
@d11434 1
a11434 1
	  if (value >= 0xff)
d11449 1
a11449 1
	  if (value >= 0xfff)
d11464 1
a11464 1
	  if (value >= 0xff)
d11475 1
a11475 1
	  if (value < 0 || value >= 0xff)
@


1.239
log
@2005-02-02  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (T2_OPCODE_MASK, T2_DATA_OP_SHIFT, T2_OPCODE_AND,
	T2_OPCODE_BIC, T2_OPCODE_ORR, T2_OPCODE_ORN, T2_OPCODE_EOR,
	T2_OPCODE_ADD, T2_OPCODE_ADC, T2_OPCODE_SBC, T2_OPCODE_SUB,
	T2_OPCODE_RSB): Define.
	(thumb32_negate_data_op): New function.
	(md_apply_fix): Use it.
gas/testsuite/
	* gas/arm/thumb2_invert.d: New test.
	* gas/arm/thumb2_invert.s: New test.
@
text
@a5280 2
      constraint (inst.operands[0].reg != Rm,
		  _("source1 and dest must be same register"));
@


1.238
log
@2006-01-31  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (arm_reg_parse): Check if reg is non-NULL.
gas/testsuite/
	* gas/testsuite/gas/arm/iwmmxt-bad.s: Add check for bad register name.
	* gas/testsuite/gas/arm/iwmmxt-bad.l: Ditto.
@
text
@d463 3
d484 11
d11130 76
d11558 5
a11562 1
	newimm = encode_thumb32_immediate (value);
@


1.237
log
@2006-01-31  Paul Brook  <paul@@codesourcery.com>
	Richard Earnshaw <rearnsha@@arm.com>

	* gas/config/tc-arm.c: Use arm_feature_set.
	(arm_ext_*, arm_arch_full, arm_arch_t2, arm_arch_none,
	arm_cext_iwmmxt, arm_cext_xscale, arm_cext_maverick, fpu_fpa_ext_v1,
	fpu_fpa_ext_v2, fpu_vfp_ext_v1xd, fpu_vfp_ext_v1, fpu_vfp_ext_v2):
	New variables.
	(insns): Use them.
	(md_atof, opcode_select, opcode_select, md_assemble, md_assemble,
	md_begin, arm_parse_extension, arm_parse_cpu, arm_parse_arch,
	arm_parse_fpu, arm_parse_float_abi, aeabi_set_public_attributes,
	s_arm_cpu, s_arm_arch, s_arm_fpu): Use macros for accessing CPU
	feature flags.
	(arm_legacy_option_table, arm_option_cpu_value_table): New types.
	(arm_opts): Move old cpu/arch options from here...
	(arm_legacy_opts): ... to here.
	(md_parse_option): Search arm_legacy_opts.
	(arm_cpus, arm_archs, arm_extensions, arm_fpus)
	(arm_float_abis, arm_eabis): Make const.

	* include/opcode/arm.h: Use ARM_CPU_FEATURE.
	(ARM_AEXT_*, FPU_ENDIAN_PURE, FPU_VFP_HARD): New.
	(arm_feature_set): Change to a structure.
	(ARM_CPU_HAS_FEATURE, ARM_MERGE_FEATURE_SETS, ARM_CLEAR_FEATURE,
	ARM_FEATURE): New macros.
@
text
@d931 1
a931 1
      if (reg->type == REG_TYPE_CN)
d946 1
a946 1
      if (reg->type == REG_TYPE_MMXWCG)
@


1.236
log
@PR 1300
* config/tc-arm.c (md_apply_fix): Fix casts to match type in printf format.
@
text
@a100 11
#define ARM_1		ARM_ARCH_V1
#define ARM_2		ARM_ARCH_V2
#define ARM_3		ARM_ARCH_V2S
#define ARM_250		ARM_ARCH_V2S
#define ARM_6		ARM_ARCH_V3
#define ARM_7		ARM_ARCH_V3
#define ARM_8		ARM_ARCH_V4
#define ARM_9		ARM_ARCH_V4T
#define ARM_STRONG	ARM_ARCH_V4
#define ARM_CPU_MASK	0x0000000f		/* XXX? */

d103 1
a103 1
#define CPU_DEFAULT	(ARM_ARCH_XSCALE)
d106 1
a106 1
#define CPU_DEFAULT	(ARM_ARCH_V5T)
d131 3
a133 3
static unsigned long cpu_variant;
static unsigned long arm_arch_used;
static unsigned long thumb_arch_used;
d145 58
a202 2
static int legacy_cpu = -1;
static int legacy_fpu = -1;
a203 5
static int mcpu_cpu_opt = -1;
static int mcpu_fpu_opt = -1;
static int march_cpu_opt = -1;
static int march_fpu_opt = -1;
static int mfpu_opt = -1;
d205 2
a206 3
/* Record user cpu selection for object attributes.
   Zero if no default or user specified CPU.  */
static int selected_cpu = -1;
d437 2
a438 2
  unsigned long avariant;
  unsigned long tvariant;
d812 1
a812 1
      if (cpu_variant & FPU_ARCH_VFP)
d1495 1
a1495 1
	  if (! (cpu_variant & ARM_EXT_V4T))
d1509 1
a1509 1
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
d8139 1
a8139 1
      unsigned long variant;
d8143 2
a8144 2
      if ((variant & ARM_EXT_V6T2) == 0)
	variant &= ARM_ANY;
d8146 2
a8147 1
      if (thumb_mode == 1 && (opcode->tvariant & variant) == 0)
d8198 2
a8199 1
      thumb_arch_used |= opcode->tvariant;
d8201 1
a8201 1
         set those bits when Thumb-2 32-bit instuctions are seen.  ie.
d8206 2
a8207 1
	thumb_arch_used |= ARM_EXT_V6T2;
d8212 1
a8212 1
      if ((opcode->avariant & cpu_variant) == 0)
d8234 3
a8236 2
      if (opcode->avariant == (ARM_EXT_V4T | ARM_EXT_V5))
	arm_arch_used |= ARM_EXT_V4T;
d8238 2
a8239 1
	arm_arch_used |= opcode->avariant;
d8718 2
a8719 2
#define ARM_VARIANT ARM_EXT_V1 /* Core ARM Instructions.  */
#define THUMB_VARIANT ARM_EXT_V4T
d8789 1
a8789 1
#define THUMB_VARIANT ARM_EXT_V6
d8794 1
a8794 1
#define THUMB_VARIANT ARM_EXT_V6T2
d8826 1
a8826 1
#define ARM_VARIANT ARM_EXT_V2	/* ARM 2 - multiplies.	*/
d8828 1
a8828 1
#define THUMB_VARIANT ARM_EXT_V4T
d8833 1
a8833 1
#define THUMB_VARIANT ARM_EXT_V6T2
d8847 1
a8847 1
#define ARM_VARIANT ARM_EXT_V2S /* ARM 3 - swp instructions.  */
d8852 1
a8852 1
#define ARM_VARIANT ARM_EXT_V3	/* ARM 6 Status register instructions.	*/
d8857 1
a8857 1
#define ARM_VARIANT ARM_EXT_V3M	 /* ARM 7M long multiplies.  */
d8868 1
a8868 1
#define ARM_VARIANT ARM_EXT_V4	/* ARM Architecture 4.	*/
d8870 1
a8870 1
#define THUMB_VARIANT ARM_EXT_V4T
d8879 1
a8879 1
#define ARM_VARIANT ARM_EXT_V4T|ARM_EXT_V5
d8886 1
a8886 1
#define ARM_VARIANT ARM_EXT_V5 /*  ARM Architecture 5T.	 */
d8888 1
a8888 1
#define THUMB_VARIANT ARM_EXT_V5T
d8895 1
a8895 1
#define THUMB_VARIANT ARM_EXT_V6T2
d8906 1
a8906 1
#define ARM_VARIANT ARM_EXT_V5ExP /*  ARM Architecture 5TExP.  */
d8934 1
a8934 1
#define ARM_VARIANT ARM_EXT_V5E /*  ARM Architecture 5TE.  */
d8943 1
a8943 1
#define ARM_VARIANT ARM_EXT_V5J /*  ARM Architecture 5TEJ.  */
d8947 1
a8947 1
#define ARM_VARIANT ARM_EXT_V6 /*  ARM V6.  */
d8949 1
a8949 1
#define THUMB_VARIANT ARM_EXT_V6
d8962 1
a8962 1
#define THUMB_VARIANT ARM_EXT_V6T2
d9054 1
a9054 1
#define ARM_VARIANT ARM_EXT_V6K
d9056 1
a9056 1
#define THUMB_VARIANT ARM_EXT_V6K
d9063 1
a9063 1
#define THUMB_VARIANT ARM_EXT_V6T2
d9073 1
a9073 1
#define ARM_VARIANT ARM_EXT_V6Z
d9077 1
a9077 1
#define ARM_VARIANT ARM_EXT_V6T2
d9114 1
a9114 1
#define ARM_VARIANT 0
d9122 1
a9122 1
#define ARM_VARIANT FPU_FPA_EXT_V1  /* Core FPA instruction set (V1).  */
d9554 1
a9554 1
#define ARM_VARIANT FPU_FPA_EXT_V2
d9563 1
a9563 1
#define ARM_VARIANT FPU_VFP_EXT_V1xD  /* VFP V1xD (single precision).  */
d9621 1
a9621 1
#define ARM_VARIANT FPU_VFP_EXT_V1 /* VFP V1 (Double precision).  */
d9672 1
a9672 1
#define ARM_VARIANT FPU_VFP_EXT_V2
d9679 1
a9679 1
#define ARM_VARIANT ARM_CEXT_XSCALE /* Intel XScale extensions.	 */
d9690 1
a9690 1
#define ARM_VARIANT ARM_CEXT_IWMMXT /* Intel Wireless MMX technology.  */
d9855 1
a9855 1
#define ARM_VARIANT ARM_CEXT_MAVERICK /* Cirrus Maverick instructions.	*/
d12440 1
a12440 1
  if (legacy_cpu != -1)
d12442 1
a12442 1
      if (mcpu_cpu_opt != -1 || march_cpu_opt != -1)
d12447 1
a12447 1
  else if (mcpu_cpu_opt == -1)
d12450 1
a12450 1
  if (legacy_fpu != -1)
d12452 1
a12452 1
      if (mfpu_opt != -1)
d12457 1
a12457 1
  else if (mfpu_opt == -1)
d12462 1
a12462 1
      if (mcpu_fpu_opt != -1)
d12467 1
a12467 1
      mfpu_opt = FPU_DEFAULT;
d12471 1
a12471 1
  if (mfpu_opt == -1)
d12473 4
a12476 4
      if (mcpu_cpu_opt == -1)
	mfpu_opt = FPU_DEFAULT;
      else if (mcpu_cpu_opt & ARM_EXT_V5)
	mfpu_opt = FPU_ARCH_VFP_V2;
d12478 1
a12478 1
	mfpu_opt = FPU_ARCH_FPA;
d12482 1
a12482 4
  if (mcpu_cpu_opt == -1)
    selected_cpu = mcpu_cpu_opt = CPU_DEFAULT;
#else
  if (mcpu_cpu_opt == -1)
d12484 2
a12485 2
      mcpu_cpu_opt = ARM_ANY;
      selected_cpu = 0;
d12487 3
d12491 1
a12491 1
    selected_cpu = mcpu_cpu_opt;
d12494 1
a12494 1
  cpu_variant = mcpu_cpu_opt | mfpu_opt;
d12496 1
a12496 1
  arm_arch_used = thumb_arch_used = 0;
d12514 1
a12514 2
	if ((cpu_variant & FPU_ANY) == FPU_NONE
	     || (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
d12530 2
a12531 2
	/* Using VFP conventions (even if soft-float).	*/
	if (cpu_variant & FPU_VFP_EXT_NONE)
d12535 1
a12535 1
	if (cpu_variant & FPU_ARCH_MAVERICK)
d12570 1
a12570 21
  switch (cpu_variant & ARM_CPU_MASK)
    {
    case ARM_2:
      mach = bfd_mach_arm_2;
      break;

    case ARM_3:			/* Also ARM_250.  */
      mach = bfd_mach_arm_2a;
      break;

    case ARM_6:			/* Also ARM_7.	*/
      mach = bfd_mach_arm_3;
      break;

    default:
      mach = bfd_mach_arm_unknown;
      break;
    }

  /* Catch special cases.  */
  if (cpu_variant & ARM_CEXT_IWMMXT)
d12572 1
a12572 1
  else if (cpu_variant & ARM_CEXT_XSCALE)
d12574 1
a12574 1
  else if (cpu_variant & ARM_CEXT_MAVERICK)
d12576 1
a12576 1
  else if (cpu_variant & ARM_EXT_V5E)
d12578 1
a12578 1
  else if (cpu_variant & ARM_EXT_V5)
d12580 1
a12580 1
      if (cpu_variant & ARM_EXT_V4T)
d12585 1
a12585 1
  else if (cpu_variant & ARM_EXT_V4)
d12587 1
a12587 1
      if (cpu_variant & ARM_EXT_V4T)
d12592 1
a12592 1
  else if (cpu_variant & ARM_EXT_V3M)
d12594 8
d12723 10
d12734 2
d12738 70
a12807 70
  {"marm1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", NULL, &legacy_cpu, ARM_ARCH_V4,
d12809 1
a12809 1
  {"mstrongarm1100", NULL, &legacy_cpu, ARM_ARCH_V4,
d12811 1
a12811 1
  {"mstrongarm1110", NULL, &legacy_cpu, ARM_ARCH_V4,
d12813 3
a12815 3
  {"mxscale",	 NULL, &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 NULL, &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 NULL, &legacy_cpu, ARM_ANY,	  N_("use -mcpu=all")},
d12818 18
a12835 18
  {"mv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
d12838 4
a12841 4
  {"mfpe-old", NULL, &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  NULL, &legacy_fpu, 0,
d12844 1
a12844 1
  {NULL, NULL, NULL, 0, NULL}
d12850 1
a12850 1
  int	value;
d12853 1
a12853 1
  int	default_fpu;
d12861 1
a12861 1
static struct arm_cpu_option_table arm_cpus[] =
d12946 2
a12947 2
  {"ep9312",	ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_ARCH_MAVERICK, "ARM920T"},
  {NULL, 0, 0, NULL}
d12953 2
a12954 2
  int	value;
  int	default_fpu;
d12959 1
a12959 1
static struct arm_arch_option_table arm_archs[] =
d12989 1
a12989 1
  {NULL, 0, 0}
d12993 1
a12993 1
struct arm_option_value_table
d12996 1
a12996 1
  int value;
d12999 1
a12999 1
static struct arm_option_value_table arm_extensions[] =
d13001 4
a13004 4
  {"maverick",		ARM_CEXT_MAVERICK},
  {"xscale",		ARM_CEXT_XSCALE},
  {"iwmmxt",		ARM_CEXT_IWMMXT},
  {NULL,		0}
d13009 1
a13009 1
static struct arm_option_value_table arm_fpus[] =
d13031 7
a13037 1
  {NULL, 0}
d13040 1
a13040 1
static struct arm_option_value_table arm_float_abis[] =
d13045 1
a13045 1
  {NULL, 0}
d13050 1
a13050 1
static struct arm_option_value_table arm_eabis[] =
d13054 1
a13054 1
  {NULL, 0}
d13067 1
a13067 1
arm_parse_extension (char * str, int * opt_p)
d13069 6
d13077 1
a13077 1
      struct arm_option_value_table * opt;
d13104 1
a13104 1
	    *opt_p |= opt->value;
d13123 1
a13123 1
  struct arm_cpu_option_table * opt;
d13141 2
a13142 2
	mcpu_cpu_opt = opt->value;
	mcpu_fpu_opt = opt->default_fpu;
d13166 1
a13166 1
  struct arm_arch_option_table *opt;
d13184 2
a13185 2
	march_cpu_opt = opt->value;
	march_fpu_opt = opt->default_fpu;
d13201 1
a13201 1
  struct arm_option_value_table * opt;
d13206 1
a13206 1
	mfpu_opt = opt->value;
d13217 1
a13217 1
  struct arm_option_value_table * opt;
d13234 1
a13234 1
  struct arm_option_value_table *opt;
d13268 1
d13311 20
d13391 1
a13391 1
  int flags;
d13395 4
a13398 2
  flags = selected_cpu | mfpu_opt | arm_arch_used | thumb_arch_used;
  if (flags & ARM_EXT_V6T2)
d13400 1
a13400 1
  else if (flags & ARM_EXT_V6Z)
d13402 1
a13402 1
  else if (flags & ARM_EXT_V6K)
d13404 1
a13404 1
  else if (flags & ARM_EXT_V6)
d13406 1
a13406 1
  else if (flags & ARM_EXT_V5E)
d13408 2
a13409 1
  else if (flags & (ARM_EXT_V5 | ARM_EXT_V5T))
d13411 1
a13411 1
  else if (flags & ARM_EXT_V4T)
d13413 1
a13413 1
  else if (flags & ARM_EXT_V4)
d13437 1
a13437 1
  if (arm_arch_used)
d13440 1
a13440 1
  if (thumb_arch_used)
d13442 1
a13442 1
				 (thumb_arch_used & ARM_EXT_V6T2) ? 2 : 1);
d13444 2
a13445 1
  if ((arm_arch_used | thumb_arch_used) & FPU_ARCH_VFP_V2)
d13447 2
a13448 1
  else if ((arm_arch_used | thumb_arch_used) & FPU_ARCH_VFP_V1)
d13451 2
a13452 1
  if ((arm_arch_used | thumb_arch_used) & ARM_CEXT_IWMMXT)
d13483 1
a13483 1
  struct arm_cpu_option_table *opt;
d13497 2
a13498 2
	mcpu_cpu_opt = opt->value;
	selected_cpu = mcpu_cpu_opt;
d13508 1
a13508 1
	cpu_variant = mcpu_cpu_opt | mfpu_opt;
d13524 1
a13524 1
  struct arm_arch_option_table *opt;
d13538 2
a13539 2
	mcpu_cpu_opt = opt->value;
	selected_cpu = mcpu_cpu_opt;
d13541 1
a13541 1
	cpu_variant = mcpu_cpu_opt | mfpu_opt;
d13558 1
a13558 1
  struct arm_option_value_table *opt;
d13571 2
a13572 2
	mfpu_opt = opt->value;
	cpu_variant = mcpu_cpu_opt | mfpu_opt;
@


1.235
log
@2005-12-12  Paul Brook  <paul@@codesourcery.com>

bfd/
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_reloc_map): Add BFD_RELOC_ARM_PCREL_CALL and
	BFD_RELOC_ARM_PCREL_JUMP.
	(check_use_blx): New function.
	(bfd_elf32_arm_process_before_allocation): Don't allocate glue if
	using BLX.
	(elf32_arm_final_link_relocate): Perform bl<->blx conversion for
	R_ARM_CALL and R_ARM_THM.
	(elf32_arm_get_eabi_attr_int): New function.
	(elf32_arm_size_dynamic_sections): Call check_use_blx.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_PCREL_CALL and BFD_RELOC_ARM_PCREL_JUMP.
gas/
	* config/tc-arm.c (do_branch): Generate EABI branch relocations.
	(do_bl): New function.
	(do_blx): Generate BFD_RELOC_ARM_PCREL_CALL relocation.
	(do_t_blx): Generate BFD_RELOC_THUMB_PCREL_BRANCH23.
	(insns): Use do_bl.
	(md_pcrel_from_section): Add BFD_RELOC_ARM_PCREL_CALL and
	BFD_RELOC_ARM_PCREL_JUMP.
	(md_apply_fix): Merge BFD_RELOC_ARM_PCREL_BRANCH and
	BFD_RELOC_ARM_PCREL_BLX cases.  Handle BFD_RELOC_ARM_PCREL_CALL and
	BFD_RELOC_ARM_PCREL_JUMP.
	(tc_gen_reloc): Handle BFD_RELOC_ARM_PCREL_CALL and
	BFD_RELOC_ARM_PCREL_JUMP.
	gas/testsuite/
	* gas/arm/pic.d: Allow R_ARM_CALL relocations.
include/elf/
	* arm.h (elf32_arm_get_eabi_attr_int): Add prototype.
ld/testsuite/
	* ld-arm/arm-call.d: New test.
	* ld-arm/arm-call1.s: New file.
	* ld-arm/arm-call1.s: New file.
	* ld-arm/arm-elf.exp: Add arm-call and mixed-app-v5.
	* ld-arm/arm.ld: Add .glue_7 and .ARM.attribues.
	* ld-arm/mixed-app-v5.d: New file.
	* ld-arm/mixed-app.r: Tweak expected output.
@
text
@d11750 3
a11752 2
			  (((unsigned int) fixP->fx_frag->fr_address
			    + (unsigned int) fixP->fx_where) & ~3) + value);
@


1.234
log
@gas/
	* config/tc-arm.c (s_arm_unwind_save_core): Don't emit an extra
	opcode if r4-r15 are not saved.
gas/testsuite/
	* gas/arm/unwind.s, gas/arm/unwind.d, gas/arm/unwind_vxworks.d: Add
	a test for saving only the low registers.
@
text
@d4613 22
a4634 1
  encode_branch (BFD_RELOC_ARM_PCREL_BRANCH);
d4663 6
a4668 1
      encode_branch (BFD_RELOC_ARM_PCREL_BLX);
d6463 6
a6468 1
      inst.reloc.type	= BFD_RELOC_THUMB_PCREL_BLX;
d8723 1
a8723 1
 TCE(bl,	b000000, f000f800, 1, (EXPr),	     branch, t_branch23),
d10883 2
a11492 1
    case BFD_RELOC_ARM_PCREL_BRANCH:
d11494 9
d11505 3
d11509 3
d11513 4
a11516 3
	 instruction, in a 24 bit, signed field.  Bits 0 and 1 must be
	 clear, and bits 26 through 32 either all clear or all set. */
      if (value & 0x00000003)
a11531 24
    case BFD_RELOC_ARM_PCREL_BLX:
      /* BLX allows bit 1 to be set in the branch destination, since
	 it targets a Thumb instruction which is only required to be
	 aligned modulo 2.  Other constraints are as for B/BL.  */
      if (value & 0x00000001)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("misaligned BLX destination"));
      if ((value & (offsetT)0xfe000000) != (offsetT)0
	  && (value & (offsetT)0xfe000000) != (offsetT)0xfe000000)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT hbit;
	  hbit   = (value >> 1) & 1;
	  value  = (value >> 2) & 0x00ffffff;

	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval |= value | hbit << 24;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

d11996 2
@


1.233
log
@* config/tc-arm.c (BAD_ADDR_MODE): Define.
  (arm_reg_parse_multi): Return NULL rather than FAIL.
  (arm_reg_parse): Fix comment, the function returns FAIL rather than NULL if
    it is unable to parse the register name.
  (do_ldrex): Use BAD_ADDR_MODE.
    Change error message for PC-relative addressing.
  (do_strex): Likewise.
  (do_t_ldrex): Use BAD_ADDR_MODE.
  (do_t_strex): Likewise.
* gas/arm/archv6t2-bad.s: Add tests of badly composed ldrex and	strex
    instructions.
* gas/arm/archv6t2-bad.l: Add expected error messages.
* gas/arm/r15-bad.l: Adjust error messages for r15 usage in ldrex and strex
    instructions.
@
text
@d2252 2
a2253 3
  /* See if we can use the short opcodes.  These pop a block of upto 8
     registers starting with r4, plus maybe r14.  */
  for (n = 0; n < 8; n++)
d2255 15
a2269 16
      /* Break at the first non-saved register.	 */
      if ((range & (1 << (n + 4))) == 0)
	break;
    }
  /* See if there are any other bits set.  */
  if (n == 0 || (range & (0xfff0 << n) & 0xbff0) != 0)
    {
      /* Use the long form.  */
      op = 0x8000 | ((range >> 4) & 0xfff);
      add_unwind_opcode (op, 2);
    }
  else
    {
      /* Use the short form.  */
      if (range & 0x4000)
	op = 0xa8; /* Pop r14.	*/
d2271 9
a2279 3
	op = 0xa0; /* Do not pop r14.  */
      op |= (n - 1);
      add_unwind_opcode (op, 1);
@


1.232
log
@2005-10-28  Paul Brook  <paul@@codesourcery.com>

	* config/tc-arm.c (aeabi_set_public_attributes): Use selected_cpu
	instead of mcpu_cpu_opt.
@
text
@d505 1
d847 1
a847 1
    return FAIL;
d873 1
a873 1
   value is the register number or NULL.  */
d4829 14
a4842 4
	      || inst.operands[1].negative,
	      _("instruction does not accept this addressing mode"));

  constraint (inst.operands[1].reg == REG_PC, BAD_PC);
d5282 4
a5285 4
	      || inst.operands[2].negative,
	      _("instruction does not accept this addressing mode"));

  constraint (inst.operands[2].reg == REG_PC, BAD_PC);
d6717 1
a6717 1
	      _("instruction does not accept this addressing mode"));
d7592 1
a7592 1
	      _("instruction does not accept this addressing mode"));
@


1.231
log
@2005-10-26  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (insns): Correct "sel" entry.
gas/testsuite/
	* gas/arm/archv6.d: Adjust expected output.
opcodes/
	* arm-dis.c (arm_opcodes): Correct "sel" entry.
@
text
@d13277 1
a13277 1
  flags = mcpu_cpu_opt | arm_arch_used | thumb_arch_used;
@


1.230
log
@2005-10-08  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c: Move #include "elf/arm.h" after libbfd.h.
	(NUM_KNOWN_ATTRIBUTES): Define.
	(aeabi_attribute, aeabi_attribute_list): Define.
	(elf32_arm_obj_tdata): Add known_eabi_attributes and
	other_eabi_attributes.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, attr_strdup, elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_compat, copy_eabi_attributes,
	elf32_arm_merge_eabi_attributes): New functions.
	(elf32_arm_copy_private_bfd_data): Copy EABI object attributes.
	(elf32_arm_fake_sections): Handle .ARM.attributes.
	(elf32_arm_parse_attributes): New function.
	(elf32_arm_section_from_shdr): Use it.
	(bfd_elf32_bfd_final_link): Define.
gas/
	* config/tc-arm.c: Don't provide fallback default for CPU_DEFAULT.
	(arm_arch_used, thumb_arch_used, selected_cpu, selected_cpu_name):
	New variables.
	(arm_cpu_option_table): Add canonical_name.
	(arm_cpus): Populate canonical_name field.
	(s_arm_eabi_attribute, s_arm_arch, s_arm_cpu, s_arm_fpu,
	aeabi_set_public_attributes, arm_md_end): New functions.
	(md_pseudo_table): Add "cpu", "arch", "fpu" and "eabi_attribute".
	(md_assemble): Set thumb_arch_used and arm_arch_used.
	(md_begin): Set defaut cpu if CPU_DEFAULT not defined.
	* config/tc-arm.h (md_end): Define.
	* doc/c-arm.texi: Document .cpu, .arch, .fpu and .eabi_attribute.
gas/testsuite/
	* gas/arm/eabi_attr_1.s: New test.
	* gas/arm/eabi_attr_1.d: New test.
	* gas/arm/arm7t.d: Only disassemble code sections.
	* gas/arm/bignum1.d: Ignore Arm object attribute sections.
	* gas/arm/mapping.d: Ditto.
	* gas/arm/unwind.d: Ditto.
	* gas/elf/section0.d: Ditto.
	* gas/elf/section1.d: Ditto.
	* gas/elf/elf.exp: Set target_machine for Arm EABI based targets.
	* gas/elf/section2.e-armeabi: New file.
include/elf/
	* arm.h: Add prototypes for BFD object attribute routines.
ld/testsuite/
	* ld-arm/arm-rel31.d: Ignore Arm object attribute sections.
	* ld-arm/arm-target1-abs.d: Ditto.
	* ld-arm/arm-target1-rel.d: Ditto.
	* ld-arm/arm-target2-abs.d: Ditto.
	* ld-arm/arm-target2-got-rel.d: Ditto.
	* ld-arm/arm-target2-rel.d: Ditto.
@
text
@d8931 1
a8931 1
 TCE(sel,	68000b0, faa0f080, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
@


1.229
log
@2005-09-30  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (opcode_tag): Add OT_cinfix3_legacy.
	(opcode_lookup): Handle OT_cinfix3_legacy.  Revert earlier change for
	normal infix conditions.
	(C3E): Include Thumb-2 definition.
	(CL, cCL): Define.
	(insns): Use them for legacy mnemonics.
gas/testsuite/
	* gas/arm/fpa-mem.s: Remove incorrect comments.
	* gas/arm/fpa-mem.d: Update expected results.
@
text
@a117 2
#else
#define CPU_DEFAULT	ARM_ANY
d143 2
d165 5
d2798 90
d2928 4
d8112 8
d8144 6
d12395 4
d12400 7
a12406 1
    mcpu_cpu_opt = CPU_DEFAULT;
d12410 2
d12769 3
d12778 44
a12821 44
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi-s",	ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm810",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm922t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm940t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm9tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
d12824 31
a12854 31
  {"arm9e-r0",		ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm9e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm926ej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ejs",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm946e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm946e-s",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm966e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm966e-s",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm968e-s",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm10t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm10tdmi",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm10e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm1020e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1022e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1026ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1026ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1136js",		ARM_ARCH_V6,	 FPU_NONE},
  {"arm1136j-s",	ARM_ARCH_V6,	 FPU_NONE},
  {"arm1136jfs",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2},
  {"mpcore",		ARM_ARCH_V6K,	 FPU_ARCH_VFP_V2},
  {"mpcorenovfp",	ARM_ARCH_V6K,	 FPU_NONE},
  {"arm1156t2-s",	ARM_ARCH_V6T2,	 FPU_NONE},
  {"arm1156t2f-s",	ARM_ARCH_V6T2,	 FPU_ARCH_VFP_V2},
  {"arm1176jz-s",	ARM_ARCH_V6ZK,	 FPU_NONE},
  {"arm1176jzf-s",	ARM_ARCH_V6ZK,	 FPU_ARCH_VFP_V2},
d12856 1
a12856 1
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
d12858 2
a12859 2
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2},
  {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
d12861 2
a12862 2
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_ARCH_MAVERICK},
  {NULL, 0, 0}
d13046 9
a13083 1

d13089 1
d13265 195
@


1.228
log
@2005-09-27  Paul Brook  <paul@@codesourcery.com>

	* config/arm.c (arm_cpus): Add more cpu names.
	* doc/c-arm.texi: Document them.
@
text
@d7729 4
d7734 1
a7734 2
			   suffix or an infix at character index 3.
			   (In unified mode, a suffix only.  */
d7806 1
d7867 4
a7872 2
	  /* Some mnemonics are ambiguous between infix and suffix
	     conditions.  Disambiguate based on assembly syntax.  */
d7874 1
a7874 1
	    break;
d7902 11
a7912 10
  if (cond)
    {
      char save[2];
      memcpy (save, affix, 2);
      memmove (affix, affix + 2, (end - affix) - 2);
      opcode = hash_find_n (arm_ops_hsh, base, (end - base) - 2);
      memmove (affix + 2, affix, (end - affix) - 2);
      memcpy (affix, save, 2);
    }
  if (opcode && (opcode->tag == OT_cinfix3 || opcode->tag == OT_csuf_or_in3))
d7915 1
a7915 1
      if (unified_syntax)
d8453 6
d8463 12
a8474 2
#define cC3(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }
a8512 5
/* ARM-only, takes either a suffix or a position-3 infix
   (for an FPA corner case). */
#define C3E(mnem, op, nops, ops, ae) \
  { #mnem, OPS##nops ops, OT_csuf_or_in3, 0x##op, 0, ARM_VARIANT, 0, do_##ae, 0 }

d8539 1
a8539 1
  C3(tstp,	110f000,     	   2, (RR, SH),      cmp),
d8542 1
a8542 1
  C3(cmpp,	150f000,     	   2, (RR, SH),      cmp),
d8545 1
a8545 1
  C3(cmnp,	170f000,     	   2, (RR, SH),      cmp),
d8596 1
a8596 1
  C3(teqp,	130f000,           2, (RR, SH),      cmp),
d8925 386
a9310 386
 cC3(ldfs,	c100100, 2, (RF, ADDR),	     rd_cpaddr),
 cC3(ldfd,	c108100, 2, (RF, ADDR),	     rd_cpaddr),
 cC3(ldfe,	c500100, 2, (RF, ADDR),	     rd_cpaddr),
 cC3(ldfp,	c508100, 2, (RF, ADDR),	     rd_cpaddr),

 cC3(stfs,	c000100, 2, (RF, ADDR),	     rd_cpaddr),
 cC3(stfd,	c008100, 2, (RF, ADDR),	     rd_cpaddr),
 cC3(stfe,	c400100, 2, (RF, ADDR),	     rd_cpaddr),
 cC3(stfp,	c408100, 2, (RF, ADDR),	     rd_cpaddr),

 cC3(mvfs,	e008100, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfsp,	e008120, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfsm,	e008140, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfsz,	e008160, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfd,	e008180, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfdp,	e0081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfdm,	e0081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfdz,	e0081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfe,	e088100, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfep,	e088120, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfem,	e088140, 2, (RF, RF_IF),     rd_rm),
 cC3(mvfez,	e088160, 2, (RF, RF_IF),     rd_rm),

 cC3(mnfs,	e108100, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfsp,	e108120, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfsm,	e108140, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfsz,	e108160, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfd,	e108180, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfdp,	e1081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfdm,	e1081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfdz,	e1081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfe,	e188100, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfep,	e188120, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfem,	e188140, 2, (RF, RF_IF),     rd_rm),
 cC3(mnfez,	e188160, 2, (RF, RF_IF),     rd_rm),

 cC3(abss,	e208100, 2, (RF, RF_IF),     rd_rm),
 cC3(abssp,	e208120, 2, (RF, RF_IF),     rd_rm),
 cC3(abssm,	e208140, 2, (RF, RF_IF),     rd_rm),
 cC3(abssz,	e208160, 2, (RF, RF_IF),     rd_rm),
 cC3(absd,	e208180, 2, (RF, RF_IF),     rd_rm),
 cC3(absdp,	e2081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(absdm,	e2081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(absdz,	e2081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(abse,	e288100, 2, (RF, RF_IF),     rd_rm),
 cC3(absep,	e288120, 2, (RF, RF_IF),     rd_rm),
 cC3(absem,	e288140, 2, (RF, RF_IF),     rd_rm),
 cC3(absez,	e288160, 2, (RF, RF_IF),     rd_rm),

 cC3(rnds,	e308100, 2, (RF, RF_IF),     rd_rm),
 cC3(rndsp,	e308120, 2, (RF, RF_IF),     rd_rm),
 cC3(rndsm,	e308140, 2, (RF, RF_IF),     rd_rm),
 cC3(rndsz,	e308160, 2, (RF, RF_IF),     rd_rm),
 cC3(rndd,	e308180, 2, (RF, RF_IF),     rd_rm),
 cC3(rnddp,	e3081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(rnddm,	e3081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(rnddz,	e3081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(rnde,	e388100, 2, (RF, RF_IF),     rd_rm),
 cC3(rndep,	e388120, 2, (RF, RF_IF),     rd_rm),
 cC3(rndem,	e388140, 2, (RF, RF_IF),     rd_rm),
 cC3(rndez,	e388160, 2, (RF, RF_IF),     rd_rm),

 cC3(sqts,	e408100, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtsp,	e408120, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtsm,	e408140, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtsz,	e408160, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtd,	e408180, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtdp,	e4081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtdm,	e4081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtdz,	e4081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(sqte,	e488100, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtep,	e488120, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtem,	e488140, 2, (RF, RF_IF),     rd_rm),
 cC3(sqtez,	e488160, 2, (RF, RF_IF),     rd_rm),

 cC3(logs,	e508100, 2, (RF, RF_IF),     rd_rm),
 cC3(logsp,	e508120, 2, (RF, RF_IF),     rd_rm),
 cC3(logsm,	e508140, 2, (RF, RF_IF),     rd_rm),
 cC3(logsz,	e508160, 2, (RF, RF_IF),     rd_rm),
 cC3(logd,	e508180, 2, (RF, RF_IF),     rd_rm),
 cC3(logdp,	e5081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(logdm,	e5081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(logdz,	e5081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(loge,	e588100, 2, (RF, RF_IF),     rd_rm),
 cC3(logep,	e588120, 2, (RF, RF_IF),     rd_rm),
 cC3(logem,	e588140, 2, (RF, RF_IF),     rd_rm),
 cC3(logez,	e588160, 2, (RF, RF_IF),     rd_rm),

 cC3(lgns,	e608100, 2, (RF, RF_IF),     rd_rm),
 cC3(lgnsp,	e608120, 2, (RF, RF_IF),     rd_rm),
 cC3(lgnsm,	e608140, 2, (RF, RF_IF),     rd_rm),
 cC3(lgnsz,	e608160, 2, (RF, RF_IF),     rd_rm),
 cC3(lgnd,	e608180, 2, (RF, RF_IF),     rd_rm),
 cC3(lgndp,	e6081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(lgndm,	e6081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(lgndz,	e6081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(lgne,	e688100, 2, (RF, RF_IF),     rd_rm),
 cC3(lgnep,	e688120, 2, (RF, RF_IF),     rd_rm),
 cC3(lgnem,	e688140, 2, (RF, RF_IF),     rd_rm),
 cC3(lgnez,	e688160, 2, (RF, RF_IF),     rd_rm),

 cC3(exps,	e708100, 2, (RF, RF_IF),     rd_rm),
 cC3(expsp,	e708120, 2, (RF, RF_IF),     rd_rm),
 cC3(expsm,	e708140, 2, (RF, RF_IF),     rd_rm),
 cC3(expsz,	e708160, 2, (RF, RF_IF),     rd_rm),
 cC3(expd,	e708180, 2, (RF, RF_IF),     rd_rm),
 cC3(expdp,	e7081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(expdm,	e7081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(expdz,	e7081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(expe,	e788100, 2, (RF, RF_IF),     rd_rm),
 cC3(expep,	e788120, 2, (RF, RF_IF),     rd_rm),
 cC3(expem,	e788140, 2, (RF, RF_IF),     rd_rm),
 cC3(expdz,	e788160, 2, (RF, RF_IF),     rd_rm),

 cC3(sins,	e808100, 2, (RF, RF_IF),     rd_rm),
 cC3(sinsp,	e808120, 2, (RF, RF_IF),     rd_rm),
 cC3(sinsm,	e808140, 2, (RF, RF_IF),     rd_rm),
 cC3(sinsz,	e808160, 2, (RF, RF_IF),     rd_rm),
 cC3(sind,	e808180, 2, (RF, RF_IF),     rd_rm),
 cC3(sindp,	e8081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(sindm,	e8081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(sindz,	e8081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(sine,	e888100, 2, (RF, RF_IF),     rd_rm),
 cC3(sinep,	e888120, 2, (RF, RF_IF),     rd_rm),
 cC3(sinem,	e888140, 2, (RF, RF_IF),     rd_rm),
 cC3(sinez,	e888160, 2, (RF, RF_IF),     rd_rm),

 cC3(coss,	e908100, 2, (RF, RF_IF),     rd_rm),
 cC3(cossp,	e908120, 2, (RF, RF_IF),     rd_rm),
 cC3(cossm,	e908140, 2, (RF, RF_IF),     rd_rm),
 cC3(cossz,	e908160, 2, (RF, RF_IF),     rd_rm),
 cC3(cosd,	e908180, 2, (RF, RF_IF),     rd_rm),
 cC3(cosdp,	e9081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(cosdm,	e9081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(cosdz,	e9081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(cose,	e988100, 2, (RF, RF_IF),     rd_rm),
 cC3(cosep,	e988120, 2, (RF, RF_IF),     rd_rm),
 cC3(cosem,	e988140, 2, (RF, RF_IF),     rd_rm),
 cC3(cosez,	e988160, 2, (RF, RF_IF),     rd_rm),

 cC3(tans,	ea08100, 2, (RF, RF_IF),     rd_rm),
 cC3(tansp,	ea08120, 2, (RF, RF_IF),     rd_rm),
 cC3(tansm,	ea08140, 2, (RF, RF_IF),     rd_rm),
 cC3(tansz,	ea08160, 2, (RF, RF_IF),     rd_rm),
 cC3(tand,	ea08180, 2, (RF, RF_IF),     rd_rm),
 cC3(tandp,	ea081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(tandm,	ea081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(tandz,	ea081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(tane,	ea88100, 2, (RF, RF_IF),     rd_rm),
 cC3(tanep,	ea88120, 2, (RF, RF_IF),     rd_rm),
 cC3(tanem,	ea88140, 2, (RF, RF_IF),     rd_rm),
 cC3(tanez,	ea88160, 2, (RF, RF_IF),     rd_rm),

 cC3(asns,	eb08100, 2, (RF, RF_IF),     rd_rm),
 cC3(asnsp,	eb08120, 2, (RF, RF_IF),     rd_rm),
 cC3(asnsm,	eb08140, 2, (RF, RF_IF),     rd_rm),
 cC3(asnsz,	eb08160, 2, (RF, RF_IF),     rd_rm),
 cC3(asnd,	eb08180, 2, (RF, RF_IF),     rd_rm),
 cC3(asndp,	eb081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(asndm,	eb081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(asndz,	eb081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(asne,	eb88100, 2, (RF, RF_IF),     rd_rm),
 cC3(asnep,	eb88120, 2, (RF, RF_IF),     rd_rm),
 cC3(asnem,	eb88140, 2, (RF, RF_IF),     rd_rm),
 cC3(asnez,	eb88160, 2, (RF, RF_IF),     rd_rm),

 cC3(acss,	ec08100, 2, (RF, RF_IF),     rd_rm),
 cC3(acssp,	ec08120, 2, (RF, RF_IF),     rd_rm),
 cC3(acssm,	ec08140, 2, (RF, RF_IF),     rd_rm),
 cC3(acssz,	ec08160, 2, (RF, RF_IF),     rd_rm),
 cC3(acsd,	ec08180, 2, (RF, RF_IF),     rd_rm),
 cC3(acsdp,	ec081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(acsdm,	ec081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(acsdz,	ec081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(acse,	ec88100, 2, (RF, RF_IF),     rd_rm),
 cC3(acsep,	ec88120, 2, (RF, RF_IF),     rd_rm),
 cC3(acsem,	ec88140, 2, (RF, RF_IF),     rd_rm),
 cC3(acsez,	ec88160, 2, (RF, RF_IF),     rd_rm),

 cC3(atns,	ed08100, 2, (RF, RF_IF),     rd_rm),
 cC3(atnsp,	ed08120, 2, (RF, RF_IF),     rd_rm),
 cC3(atnsm,	ed08140, 2, (RF, RF_IF),     rd_rm),
 cC3(atnsz,	ed08160, 2, (RF, RF_IF),     rd_rm),
 cC3(atnd,	ed08180, 2, (RF, RF_IF),     rd_rm),
 cC3(atndp,	ed081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(atndm,	ed081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(atndz,	ed081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(atne,	ed88100, 2, (RF, RF_IF),     rd_rm),
 cC3(atnep,	ed88120, 2, (RF, RF_IF),     rd_rm),
 cC3(atnem,	ed88140, 2, (RF, RF_IF),     rd_rm),
 cC3(atnez,	ed88160, 2, (RF, RF_IF),     rd_rm),

 cC3(urds,	ee08100, 2, (RF, RF_IF),     rd_rm),
 cC3(urdsp,	ee08120, 2, (RF, RF_IF),     rd_rm),
 cC3(urdsm,	ee08140, 2, (RF, RF_IF),     rd_rm),
 cC3(urdsz,	ee08160, 2, (RF, RF_IF),     rd_rm),
 cC3(urdd,	ee08180, 2, (RF, RF_IF),     rd_rm),
 cC3(urddp,	ee081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(urddm,	ee081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(urddz,	ee081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(urde,	ee88100, 2, (RF, RF_IF),     rd_rm),
 cC3(urdep,	ee88120, 2, (RF, RF_IF),     rd_rm),
 cC3(urdem,	ee88140, 2, (RF, RF_IF),     rd_rm),
 cC3(urdez,	ee88160, 2, (RF, RF_IF),     rd_rm),

 cC3(nrms,	ef08100, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmsp,	ef08120, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmsm,	ef08140, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmsz,	ef08160, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmd,	ef08180, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmdp,	ef081a0, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmdm,	ef081c0, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmdz,	ef081e0, 2, (RF, RF_IF),     rd_rm),
 cC3(nrme,	ef88100, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmep,	ef88120, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmem,	ef88140, 2, (RF, RF_IF),     rd_rm),
 cC3(nrmez,	ef88160, 2, (RF, RF_IF),     rd_rm),

 cC3(adfs,	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfsp,	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfsm,	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfsz,	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfd,	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfdp,	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfdm,	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfdz,	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfe,	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfep,	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfem,	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(adfez,	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(sufs,	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufsp,	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufsm,	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufsz,	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufd,	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufdp,	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufdm,	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufdz,	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufe,	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufep,	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufem,	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(sufez,	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(rsfs,	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfsp,	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfsm,	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfsz,	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfd,	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfdp,	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfdm,	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfdz,	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfe,	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfep,	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfem,	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rsfez,	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(mufs,	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufsp,	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufsm,	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufsz,	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufd,	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufdp,	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufdm,	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufdz,	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufe,	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufep,	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufem,	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(mufez,	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(dvfs,	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfsp,	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfsm,	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfsz,	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfd,	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfdp,	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfdm,	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfdz,	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfe,	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfep,	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfem,	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(dvfez,	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(rdfs,	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfsp,	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfsm,	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfsz,	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfd,	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfdp,	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfdm,	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfdz,	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfe,	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfep,	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfem,	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rdfez,	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(pows,	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powsp,	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powsm,	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powsz,	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powd,	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powdp,	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powdm,	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powdz,	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powe,	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powep,	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powem,	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(powez,	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(rpws,	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwsp,	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwsm,	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwsz,	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwd,	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwdp,	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwdm,	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwdz,	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwe,	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwep,	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwem,	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rpwez,	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(rmfs,	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfsp,	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfsm,	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfsz,	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfd,	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfdp,	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfdm,	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfdz,	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfe,	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfep,	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfem,	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(rmfez,	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(fmls,	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmlsp,	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmlsm,	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmlsz,	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmld,	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmldp,	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmldm,	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmldz,	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmle,	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmlep,	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmlem,	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fmlez,	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(fdvs,	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvsp,	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvsm,	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvsz,	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvd,	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvdp,	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvdm,	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvdz,	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdve,	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvep,	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvem,	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(fdvez,	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(frds,	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frdsp,	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frdsm,	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frdsz,	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frdd,	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frddp,	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frddm,	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frddz,	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frde,	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frdep,	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frdem,	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(frdez,	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),

 cC3(pols,	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(polsp,	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(polsm,	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(polsz,	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(pold,	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(poldp,	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(poldm,	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(poldz,	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(pole,	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(polep,	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(polem,	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
 cC3(polez,	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),
d9317 12
a9328 12
 cC3(flts,	e000110, 2, (RF, RR),	     rn_rd),
 cC3(fltsp,	e000130, 2, (RF, RR),	     rn_rd),
 cC3(fltsm,	e000150, 2, (RF, RR),	     rn_rd),
 cC3(fltsz,	e000170, 2, (RF, RR),	     rn_rd),
 cC3(fltd,	e000190, 2, (RF, RR),	     rn_rd),
 cC3(fltdp,	e0001b0, 2, (RF, RR),	     rn_rd),
 cC3(fltdm,	e0001d0, 2, (RF, RR),	     rn_rd),
 cC3(fltdz,	e0001f0, 2, (RF, RR),	     rn_rd),
 cC3(flte,	e080110, 2, (RF, RR),	     rn_rd),
 cC3(fltep,	e080130, 2, (RF, RR),	     rn_rd),
 cC3(fltem,	e080150, 2, (RF, RR),	     rn_rd),
 cC3(fltez,	e080170, 2, (RF, RR),	     rn_rd),
d9336 12
a9347 12
 cC3(fixp,	e100130, 2, (RR, RF),	     rd_rm),
 cC3(fixm,	e100150, 2, (RR, RF),	     rd_rm),
 cC3(fixz,	e100170, 2, (RR, RF),	     rd_rm),
 cC3(fixsp,	e100130, 2, (RR, RF),	     rd_rm),
 cC3(fixsm,	e100150, 2, (RR, RF),	     rd_rm),
 cC3(fixsz,	e100170, 2, (RR, RF),	     rd_rm),
 cC3(fixdp,	e100130, 2, (RR, RF),	     rd_rm),
 cC3(fixdm,	e100150, 2, (RR, RF),	     rd_rm),
 cC3(fixdz,	e100170, 2, (RR, RF),	     rd_rm),
 cC3(fixep,	e100130, 2, (RR, RF),	     rd_rm),
 cC3(fixem,	e100150, 2, (RR, RF),	     rd_rm),
 cC3(fixez,	e100170, 2, (RR, RF),	     rd_rm),
d9353 2
a9354 2
 cC3(lfmfd,	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cC3(lfmea,	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
d9356 2
a9357 2
 cC3(sfmfd,	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
 cC3(sfmea,	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),
d9738 2
a9739 1
#undef cC3
@


1.227
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d12684 1
d12687 2
d12690 1
d12695 1
d12704 2
@


1.226
log
@2005-09-08  Paul Brook  <paul@@codesourcery.com>

bfd/
	* reloc.c: Rename BFD_RELOC_ARM_SMI to BFD_RELOC_ARM_SMC.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
opcodes/
	* arm-dis.c (arm_opcodes, thumb32_opcodes): Rename smi to smc.
gas/
	* config/tc-arm.c (do_smi, do_t_smi): Rename ...
	(do_smc, do_t_smc): ... to this.
	(insns): Remane smi to smc.
	(md_apply_fix, tc_gen_reloc): Rename BFD_RELOC_ARM_SMI to
	BFD_RELOC_ARM_SMC.
gas/testsuite/
	* gas/arm/arch6zk.d: Rename smi to smc.
	* gas/arm/arch6zk.s: Ditto.
	* gas/arm/thumb32.d: Ditto.
	* gas/arm/thumb32.s: Ditto.
@
text
@d8095 4
@


1.225
log
@Remove duplicated chunk in previous patch.
@
text
@d5098 1
a5098 1
do_smi (void)
d5100 1
a5100 1
  inst.reloc.type = BFD_RELOC_ARM_SMI;
d7433 1
a7433 1
do_t_smi (void)
d8849 1
a8849 1
 TCE(smi,	1600070, f7f08000, 1, (EXPi), smi, t_smi),
d11271 1
a11271 1
    case BFD_RELOC_ARM_SMI:
d11274 1
a11274 1
		      _("invalid smi expression"));
d11869 1
a11869 1
	  case BFD_RELOC_ARM_SMI:	   type = "SMI";	  break;
@


1.224
log
@2005-09-06  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (arm_it): Add relax field.
	(T16_32_TAB): Add addi, addis, add_pc, add_sp, dec_sp, inc_sp,
	b, bcond, ldr_pc, ldr_pc2, ldr_sp, str_sp, subi, subis.
	(do_t_add_sub, do_t_addr, do_t_branch, do_t_ldst,
	do_t_mov_cmp): Allow relaxation.
	(output_relax_insn): New function.
	(put_thumb32_insn): New function.
	(output_inst): Use new functions.
	(md_assemble): Don't throw error on relaxable instructions.
	(insns): Change "b" entry from TCE(...) to tCE(...).
	(md_estimate_size_before_relax): Return 2.
	(md_convert_frag, relax_immediate, relax_adr, relax_addsub,
	relax_branch, arm_relax_frag): New functions.
	(arm_force_relocation): Return 0 for Thumb-2 immediate operand
	relocations.
	* config/tc-arm.h (md_convert_frag): Remove definition.
	(md_relax_frag): Define.
	(arm_relax_frag): Add prototype.
gas/testsuite/
	* gas/arm/thumb2_relax.d: New test.
	* gas/arm/thumb2_relax.s: New test.
	* gas/arm/thumb32.d: Adjust expected results to include relaxation.
	* gas/arm/thumb32.s: Tweak for better coverage of relaxable
	instructions.  Remove load/store tests.
@
text
@a10898 8
/* Write a 32-bit thumb instruction to buf.  */
static void
put_thumb32_insn (char * buf, unsigned long insn)
{
  md_number_to_chars (buf, insn >> 16, THUMB_SIZE);
  md_number_to_chars (buf + THUMB_SIZE, insn, THUMB_SIZE);
}

@


1.223
log
@2005-09-02  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (do_rn_rd): Enforce SWP operand constraints.
gas/testsuite/
	* gas/arm/arm3-bad.s: New test.
	* gas/arm/arm3-bad.d: New test.
	* gas/arm/arm3.s: Avoid illegal instructions.
	* gas/arm/arm3.d: Ditto.
@
text
@d216 3
d5765 2
a5766 1
   holds variant (1).  */
d5772 4
d5781 2
d5790 1
d5793 1
d5800 3
d5830 1
d5833 2
d5896 10
d5908 43
a5950 9
	  /* ??? Convert large immediates to addw/subw.  */
	  /* ??? 16-bit adds with small immediates.  */
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].reg << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
a5957 7
	      bfd_boolean narrow;

	      if (inst.instruction == T_MNEM_adds
		  || inst.instruction == T_MNEM_subs)
		narrow = (current_it_mask == 0);
	      else
		narrow = (current_it_mask != 0);
d6050 8
a6057 1
  if (unified_syntax && inst.size_req != 2)
d6059 1
a6059 2
      /* Always generate a 32-bit opcode;
	 section relaxation will shrink it later if possible.  */
d6067 1
d6331 7
a6337 1
  if (unified_syntax && inst.size_req != 2)
d6339 1
d6341 1
a6341 4
	{
	  inst.instruction = 0xf000b000;
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH25;
	}
d6345 1
a6345 1
	  inst.instruction = (inst.cond << 22) | 0xf0008000;
d6351 1
d6356 1
a6356 1
	  inst.instruction = 0xd000 | (inst.cond << 8);
d6359 3
d6635 4
d6641 2
a6642 3
      /* Generation of 16-bit instructions for anything other than
	 Rd, [Rn, Ri] is deferred to section relaxation time.  */
      if (inst.operands[1].isreg && inst.operands[1].immisreg
d6645 2
a6646 2
	  && inst.operands[1].reg <= 7 && inst.operands[1].imm <= 7
	  && inst.instruction <= 0xffff)
d6648 45
a6692 2
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  goto op16;
d6694 2
a6695 2

      inst.instruction = THUMB_OP32 (inst.instruction);
d6827 1
d6832 1
d6834 1
a6834 1
	narrow = inst.instruction != T_MNEM_movs;
d6836 1
a6836 1
	narrow = inst.instruction != T_MNEM_movs || low_regs;
d6843 19
a6861 6
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << r0off;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
d7635 40
d7685 4
d7697 1
a7697 2
      md_number_to_chars (to, inst.instruction >> 16, THUMB_SIZE);
      md_number_to_chars (to + THUMB_SIZE, inst.instruction, THUMB_SIZE);
d7996 1
a7996 1
      if (!inst.error)
d8541 1
a8541 1
 TCE(b,		a000000, e000,	   1, (EXPr),	     branch, t_branch),
d9777 3
d9781 1
a9781 1
md_estimate_size_before_relax (fragS * fragP ATTRIBUTE_UNUSED,
d9784 331
a10114 2
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
d11985 4
a11988 1
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
@


1.222
log
@2005-09-02  Paul Brook  <paul@@codesourcery.com>

bfd/
	* libbdf.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_T32_CP_OFF_IMM and
	BFD_RELOC_ARM_T32_CP_OFF_IMM_S2.
gas/
	* config/tc-arm.c (encode_arm_cp_address): Use
	BFD_RELOC_ARM_T32_CP_OFF_IMM in thumb mode.
	(do_iwmmxt_wldstbh): Use BFD_RELOC_ARM_T32_CP_OFF_IMM_S2 in thumb
	mode.
	(md_assemble): Only allow coprocessor instructions when Thumb-2 is
	available.
	(cCE, cC3): Define.
	(insns): Use them for coprocessor instructions.
	(md_pcrel_from_section): Handle BFD_RELOC_ARM_T32_CP_OFF_IMM.
	(get_thumb32_insn): New function.
	(put_thumb32_insn): New function.
	(md_apply_fix): Handle BFD_RELOC_ARM_T32_CP_OFF_IMM and
	BFD_RELOC_ARM_T32_CP_OFF_IMM_S2.
gas/testsuite/
	* gas/arm/vfp-bad_t2.d, gas/arm/vfp-bad_t2.l, arm/vfp-bad_t2.s,
	gas/arm/vfp1_t2.d, gas/arm/vfp1_t2.s, gas/arm/vfp1xD_t2.d,
	gas/arm/vfp1xD_t2.s, gas/arm/vfp2_t2.d, gas/arm/vfp2_t2.s): New files.
opcodes/
	* arm-dis.c (coprocessor_opcodes): New.
	(arm_opcodes, thumb32_opcodes): Remove coprocessor insns.
	(print_insn_coprocessor): New function.
	(print_insn_arm): Use print_insn_coprocessor.  Remove coprocessor
	format characters.
	(print_insn_thumb32): Use print_insn_coprocessor.
@
text
@d4342 5
d4349 1
a4349 1
  inst.instruction |= inst.operands[2].reg << 16;
@


1.221
log
@2005-09-02  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (opcode_lookup): Look for infix opcode when
	incorrect suffix matches.
gas/testsuite/
	* gas/arm/fpa-mem.d: Test "stfpls".
	* gas/arm/fpa-mem.s: Ditto.
@
text
@d4221 2
d5500 1
d5503 5
a5507 1
  encode_arm_cp_address (1, TRUE, FALSE, BFD_RELOC_ARM_CP_OFF_IMM_S2);
d7769 6
d7776 1
a7776 1
      if (thumb_mode == 1 && (opcode->tvariant & cpu_variant) == 0)
d8263 7
d8719 391
a9109 391
  CE(wfs,	e200110, 1, (RR),	     rd),
  CE(rfs,	e300110, 1, (RR),	     rd),
  CE(wfc,	e400110, 1, (RR),	     rd),
  CE(rfc,	e500110, 1, (RR),	     rd),

  C3(ldfs,	c100100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfd,	c108100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfe,	c500100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfp,	c508100, 2, (RF, ADDR),	     rd_cpaddr),

  C3(stfs,	c000100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfd,	c008100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfe,	c400100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfp,	c408100, 2, (RF, ADDR),	     rd_cpaddr),

  C3(mvfs,	e008100, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsp,	e008120, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsm,	e008140, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsz,	e008160, 2, (RF, RF_IF),     rd_rm),
  C3(mvfd,	e008180, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdp,	e0081a0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdm,	e0081c0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdz,	e0081e0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfe,	e088100, 2, (RF, RF_IF),     rd_rm),
  C3(mvfep,	e088120, 2, (RF, RF_IF),     rd_rm),
  C3(mvfem,	e088140, 2, (RF, RF_IF),     rd_rm),
  C3(mvfez,	e088160, 2, (RF, RF_IF),     rd_rm),

  C3(mnfs,	e108100, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsp,	e108120, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsm,	e108140, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsz,	e108160, 2, (RF, RF_IF),     rd_rm),
  C3(mnfd,	e108180, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdp,	e1081a0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdm,	e1081c0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdz,	e1081e0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfe,	e188100, 2, (RF, RF_IF),     rd_rm),
  C3(mnfep,	e188120, 2, (RF, RF_IF),     rd_rm),
  C3(mnfem,	e188140, 2, (RF, RF_IF),     rd_rm),
  C3(mnfez,	e188160, 2, (RF, RF_IF),     rd_rm),

  C3(abss,	e208100, 2, (RF, RF_IF),     rd_rm),
  C3(abssp,	e208120, 2, (RF, RF_IF),     rd_rm),
  C3(abssm,	e208140, 2, (RF, RF_IF),     rd_rm),
  C3(abssz,	e208160, 2, (RF, RF_IF),     rd_rm),
  C3(absd,	e208180, 2, (RF, RF_IF),     rd_rm),
  C3(absdp,	e2081a0, 2, (RF, RF_IF),     rd_rm),
  C3(absdm,	e2081c0, 2, (RF, RF_IF),     rd_rm),
  C3(absdz,	e2081e0, 2, (RF, RF_IF),     rd_rm),
  C3(abse,	e288100, 2, (RF, RF_IF),     rd_rm),
  C3(absep,	e288120, 2, (RF, RF_IF),     rd_rm),
  C3(absem,	e288140, 2, (RF, RF_IF),     rd_rm),
  C3(absez,	e288160, 2, (RF, RF_IF),     rd_rm),

  C3(rnds,	e308100, 2, (RF, RF_IF),     rd_rm),
  C3(rndsp,	e308120, 2, (RF, RF_IF),     rd_rm),
  C3(rndsm,	e308140, 2, (RF, RF_IF),     rd_rm),
  C3(rndsz,	e308160, 2, (RF, RF_IF),     rd_rm),
  C3(rndd,	e308180, 2, (RF, RF_IF),     rd_rm),
  C3(rnddp,	e3081a0, 2, (RF, RF_IF),     rd_rm),
  C3(rnddm,	e3081c0, 2, (RF, RF_IF),     rd_rm),
  C3(rnddz,	e3081e0, 2, (RF, RF_IF),     rd_rm),
  C3(rnde,	e388100, 2, (RF, RF_IF),     rd_rm),
  C3(rndep,	e388120, 2, (RF, RF_IF),     rd_rm),
  C3(rndem,	e388140, 2, (RF, RF_IF),     rd_rm),
  C3(rndez,	e388160, 2, (RF, RF_IF),     rd_rm),

  C3(sqts,	e408100, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsp,	e408120, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsm,	e408140, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsz,	e408160, 2, (RF, RF_IF),     rd_rm),
  C3(sqtd,	e408180, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdp,	e4081a0, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdm,	e4081c0, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdz,	e4081e0, 2, (RF, RF_IF),     rd_rm),
  C3(sqte,	e488100, 2, (RF, RF_IF),     rd_rm),
  C3(sqtep,	e488120, 2, (RF, RF_IF),     rd_rm),
  C3(sqtem,	e488140, 2, (RF, RF_IF),     rd_rm),
  C3(sqtez,	e488160, 2, (RF, RF_IF),     rd_rm),

  C3(logs,	e508100, 2, (RF, RF_IF),     rd_rm),
  C3(logsp,	e508120, 2, (RF, RF_IF),     rd_rm),
  C3(logsm,	e508140, 2, (RF, RF_IF),     rd_rm),
  C3(logsz,	e508160, 2, (RF, RF_IF),     rd_rm),
  C3(logd,	e508180, 2, (RF, RF_IF),     rd_rm),
  C3(logdp,	e5081a0, 2, (RF, RF_IF),     rd_rm),
  C3(logdm,	e5081c0, 2, (RF, RF_IF),     rd_rm),
  C3(logdz,	e5081e0, 2, (RF, RF_IF),     rd_rm),
  C3(loge,	e588100, 2, (RF, RF_IF),     rd_rm),
  C3(logep,	e588120, 2, (RF, RF_IF),     rd_rm),
  C3(logem,	e588140, 2, (RF, RF_IF),     rd_rm),
  C3(logez,	e588160, 2, (RF, RF_IF),     rd_rm),

  C3(lgns,	e608100, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsp,	e608120, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsm,	e608140, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsz,	e608160, 2, (RF, RF_IF),     rd_rm),
  C3(lgnd,	e608180, 2, (RF, RF_IF),     rd_rm),
  C3(lgndp,	e6081a0, 2, (RF, RF_IF),     rd_rm),
  C3(lgndm,	e6081c0, 2, (RF, RF_IF),     rd_rm),
  C3(lgndz,	e6081e0, 2, (RF, RF_IF),     rd_rm),
  C3(lgne,	e688100, 2, (RF, RF_IF),     rd_rm),
  C3(lgnep,	e688120, 2, (RF, RF_IF),     rd_rm),
  C3(lgnem,	e688140, 2, (RF, RF_IF),     rd_rm),
  C3(lgnez,	e688160, 2, (RF, RF_IF),     rd_rm),

  C3(exps,	e708100, 2, (RF, RF_IF),     rd_rm),
  C3(expsp,	e708120, 2, (RF, RF_IF),     rd_rm),
  C3(expsm,	e708140, 2, (RF, RF_IF),     rd_rm),
  C3(expsz,	e708160, 2, (RF, RF_IF),     rd_rm),
  C3(expd,	e708180, 2, (RF, RF_IF),     rd_rm),
  C3(expdp,	e7081a0, 2, (RF, RF_IF),     rd_rm),
  C3(expdm,	e7081c0, 2, (RF, RF_IF),     rd_rm),
  C3(expdz,	e7081e0, 2, (RF, RF_IF),     rd_rm),
  C3(expe,	e788100, 2, (RF, RF_IF),     rd_rm),
  C3(expep,	e788120, 2, (RF, RF_IF),     rd_rm),
  C3(expem,	e788140, 2, (RF, RF_IF),     rd_rm),
  C3(expdz,	e788160, 2, (RF, RF_IF),     rd_rm),

  C3(sins,	e808100, 2, (RF, RF_IF),     rd_rm),
  C3(sinsp,	e808120, 2, (RF, RF_IF),     rd_rm),
  C3(sinsm,	e808140, 2, (RF, RF_IF),     rd_rm),
  C3(sinsz,	e808160, 2, (RF, RF_IF),     rd_rm),
  C3(sind,	e808180, 2, (RF, RF_IF),     rd_rm),
  C3(sindp,	e8081a0, 2, (RF, RF_IF),     rd_rm),
  C3(sindm,	e8081c0, 2, (RF, RF_IF),     rd_rm),
  C3(sindz,	e8081e0, 2, (RF, RF_IF),     rd_rm),
  C3(sine,	e888100, 2, (RF, RF_IF),     rd_rm),
  C3(sinep,	e888120, 2, (RF, RF_IF),     rd_rm),
  C3(sinem,	e888140, 2, (RF, RF_IF),     rd_rm),
  C3(sinez,	e888160, 2, (RF, RF_IF),     rd_rm),

  C3(coss,	e908100, 2, (RF, RF_IF),     rd_rm),
  C3(cossp,	e908120, 2, (RF, RF_IF),     rd_rm),
  C3(cossm,	e908140, 2, (RF, RF_IF),     rd_rm),
  C3(cossz,	e908160, 2, (RF, RF_IF),     rd_rm),
  C3(cosd,	e908180, 2, (RF, RF_IF),     rd_rm),
  C3(cosdp,	e9081a0, 2, (RF, RF_IF),     rd_rm),
  C3(cosdm,	e9081c0, 2, (RF, RF_IF),     rd_rm),
  C3(cosdz,	e9081e0, 2, (RF, RF_IF),     rd_rm),
  C3(cose,	e988100, 2, (RF, RF_IF),     rd_rm),
  C3(cosep,	e988120, 2, (RF, RF_IF),     rd_rm),
  C3(cosem,	e988140, 2, (RF, RF_IF),     rd_rm),
  C3(cosez,	e988160, 2, (RF, RF_IF),     rd_rm),

  C3(tans,	ea08100, 2, (RF, RF_IF),     rd_rm),
  C3(tansp,	ea08120, 2, (RF, RF_IF),     rd_rm),
  C3(tansm,	ea08140, 2, (RF, RF_IF),     rd_rm),
  C3(tansz,	ea08160, 2, (RF, RF_IF),     rd_rm),
  C3(tand,	ea08180, 2, (RF, RF_IF),     rd_rm),
  C3(tandp,	ea081a0, 2, (RF, RF_IF),     rd_rm),
  C3(tandm,	ea081c0, 2, (RF, RF_IF),     rd_rm),
  C3(tandz,	ea081e0, 2, (RF, RF_IF),     rd_rm),
  C3(tane,	ea88100, 2, (RF, RF_IF),     rd_rm),
  C3(tanep,	ea88120, 2, (RF, RF_IF),     rd_rm),
  C3(tanem,	ea88140, 2, (RF, RF_IF),     rd_rm),
  C3(tanez,	ea88160, 2, (RF, RF_IF),     rd_rm),

  C3(asns,	eb08100, 2, (RF, RF_IF),     rd_rm),
  C3(asnsp,	eb08120, 2, (RF, RF_IF),     rd_rm),
  C3(asnsm,	eb08140, 2, (RF, RF_IF),     rd_rm),
  C3(asnsz,	eb08160, 2, (RF, RF_IF),     rd_rm),
  C3(asnd,	eb08180, 2, (RF, RF_IF),     rd_rm),
  C3(asndp,	eb081a0, 2, (RF, RF_IF),     rd_rm),
  C3(asndm,	eb081c0, 2, (RF, RF_IF),     rd_rm),
  C3(asndz,	eb081e0, 2, (RF, RF_IF),     rd_rm),
  C3(asne,	eb88100, 2, (RF, RF_IF),     rd_rm),
  C3(asnep,	eb88120, 2, (RF, RF_IF),     rd_rm),
  C3(asnem,	eb88140, 2, (RF, RF_IF),     rd_rm),
  C3(asnez,	eb88160, 2, (RF, RF_IF),     rd_rm),

  C3(acss,	ec08100, 2, (RF, RF_IF),     rd_rm),
  C3(acssp,	ec08120, 2, (RF, RF_IF),     rd_rm),
  C3(acssm,	ec08140, 2, (RF, RF_IF),     rd_rm),
  C3(acssz,	ec08160, 2, (RF, RF_IF),     rd_rm),
  C3(acsd,	ec08180, 2, (RF, RF_IF),     rd_rm),
  C3(acsdp,	ec081a0, 2, (RF, RF_IF),     rd_rm),
  C3(acsdm,	ec081c0, 2, (RF, RF_IF),     rd_rm),
  C3(acsdz,	ec081e0, 2, (RF, RF_IF),     rd_rm),
  C3(acse,	ec88100, 2, (RF, RF_IF),     rd_rm),
  C3(acsep,	ec88120, 2, (RF, RF_IF),     rd_rm),
  C3(acsem,	ec88140, 2, (RF, RF_IF),     rd_rm),
  C3(acsez,	ec88160, 2, (RF, RF_IF),     rd_rm),

  C3(atns,	ed08100, 2, (RF, RF_IF),     rd_rm),
  C3(atnsp,	ed08120, 2, (RF, RF_IF),     rd_rm),
  C3(atnsm,	ed08140, 2, (RF, RF_IF),     rd_rm),
  C3(atnsz,	ed08160, 2, (RF, RF_IF),     rd_rm),
  C3(atnd,	ed08180, 2, (RF, RF_IF),     rd_rm),
  C3(atndp,	ed081a0, 2, (RF, RF_IF),     rd_rm),
  C3(atndm,	ed081c0, 2, (RF, RF_IF),     rd_rm),
  C3(atndz,	ed081e0, 2, (RF, RF_IF),     rd_rm),
  C3(atne,	ed88100, 2, (RF, RF_IF),     rd_rm),
  C3(atnep,	ed88120, 2, (RF, RF_IF),     rd_rm),
  C3(atnem,	ed88140, 2, (RF, RF_IF),     rd_rm),
  C3(atnez,	ed88160, 2, (RF, RF_IF),     rd_rm),

  C3(urds,	ee08100, 2, (RF, RF_IF),     rd_rm),
  C3(urdsp,	ee08120, 2, (RF, RF_IF),     rd_rm),
  C3(urdsm,	ee08140, 2, (RF, RF_IF),     rd_rm),
  C3(urdsz,	ee08160, 2, (RF, RF_IF),     rd_rm),
  C3(urdd,	ee08180, 2, (RF, RF_IF),     rd_rm),
  C3(urddp,	ee081a0, 2, (RF, RF_IF),     rd_rm),
  C3(urddm,	ee081c0, 2, (RF, RF_IF),     rd_rm),
  C3(urddz,	ee081e0, 2, (RF, RF_IF),     rd_rm),
  C3(urde,	ee88100, 2, (RF, RF_IF),     rd_rm),
  C3(urdep,	ee88120, 2, (RF, RF_IF),     rd_rm),
  C3(urdem,	ee88140, 2, (RF, RF_IF),     rd_rm),
  C3(urdez,	ee88160, 2, (RF, RF_IF),     rd_rm),

  C3(nrms,	ef08100, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsp,	ef08120, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsm,	ef08140, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsz,	ef08160, 2, (RF, RF_IF),     rd_rm),
  C3(nrmd,	ef08180, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdp,	ef081a0, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdm,	ef081c0, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdz,	ef081e0, 2, (RF, RF_IF),     rd_rm),
  C3(nrme,	ef88100, 2, (RF, RF_IF),     rd_rm),
  C3(nrmep,	ef88120, 2, (RF, RF_IF),     rd_rm),
  C3(nrmem,	ef88140, 2, (RF, RF_IF),     rd_rm),
  C3(nrmez,	ef88160, 2, (RF, RF_IF),     rd_rm),

  C3(adfs,	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsp,	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsm,	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsz,	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfd,	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdp,	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdm,	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdz,	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfe,	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfep,	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfem,	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfez,	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(sufs,	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsp,	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsm,	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsz,	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufd,	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdp,	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdm,	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdz,	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufe,	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufep,	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufem,	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufez,	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rsfs,	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsp,	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsm,	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsz,	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfd,	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdp,	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdm,	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdz,	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfe,	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfep,	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfem,	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfez,	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(mufs,	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsp,	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsm,	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsz,	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufd,	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdp,	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdm,	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdz,	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufe,	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufep,	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufem,	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufez,	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(dvfs,	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsp,	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsm,	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsz,	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfd,	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdp,	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdm,	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdz,	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfe,	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfep,	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfem,	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfez,	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rdfs,	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsp,	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsm,	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsz,	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfd,	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdp,	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdm,	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdz,	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfe,	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfep,	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfem,	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfez,	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(pows,	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsp,	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsm,	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsz,	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powd,	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdp,	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdm,	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdz,	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powe,	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powep,	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powem,	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powez,	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rpws,	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsp,	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsm,	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsz,	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwd,	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdp,	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdm,	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdz,	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwe,	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwep,	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwem,	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwez,	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rmfs,	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsp,	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsm,	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsz,	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfd,	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdp,	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdm,	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdz,	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfe,	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfep,	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfem,	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfez,	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(fmls,	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsp,	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsm,	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsz,	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmld,	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldp,	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldm,	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldz,	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmle,	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlep,	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlem,	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlez,	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(fdvs,	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsp,	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsm,	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsz,	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvd,	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdp,	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdm,	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdz,	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdve,	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvep,	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvem,	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvez,	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(frds,	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsp,	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsm,	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsz,	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdd,	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddp,	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddm,	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddz,	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frde,	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdep,	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdem,	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdez,	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(pols,	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsp,	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsm,	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsz,	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(pold,	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldp,	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldm,	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldz,	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(pole,	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polep,	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polem,	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polez,	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),
d9111 1
a9111 1
  CE(cmf,	e90f110, 2, (RF, RF_IF),     fpa_cmp),
d9113 1
a9113 1
  CE(cnf,	eb0f110, 2, (RF, RF_IF),     fpa_cmp),
d9116 12
a9127 12
  C3(flts,	e000110, 2, (RF, RR),	     rn_rd),
  C3(fltsp,	e000130, 2, (RF, RR),	     rn_rd),
  C3(fltsm,	e000150, 2, (RF, RR),	     rn_rd),
  C3(fltsz,	e000170, 2, (RF, RR),	     rn_rd),
  C3(fltd,	e000190, 2, (RF, RR),	     rn_rd),
  C3(fltdp,	e0001b0, 2, (RF, RR),	     rn_rd),
  C3(fltdm,	e0001d0, 2, (RF, RR),	     rn_rd),
  C3(fltdz,	e0001f0, 2, (RF, RR),	     rn_rd),
  C3(flte,	e080110, 2, (RF, RR),	     rn_rd),
  C3(fltep,	e080130, 2, (RF, RR),	     rn_rd),
  C3(fltem,	e080150, 2, (RF, RR),	     rn_rd),
  C3(fltez,	e080170, 2, (RF, RR),	     rn_rd),
d9134 13
a9146 13
  CE(fix,	e100110, 2, (RR, RF),	     rd_rm),
  C3(fixp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixsp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixsm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixsz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixdp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixdm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixdz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixep,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixem,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixez,	e100170, 2, (RR, RF),	     rd_rm),
d9151 6
a9156 6
  CE(lfm,	c100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(lfmfd,	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(lfmea,	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  CE(sfm,	c000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(sfmfd,	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(sfmea,	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),
d9161 12
a9172 12
  CE(fcpys,	eb00a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fmrs,	e100a10, 2, (RR, RVS),	      vfp_reg_from_sp),
  CE(fmsr,	e000a10, 2, (RVS, RR),	      vfp_sp_from_reg),
  CE(fmstat,	ef1fa10, 0, (),		      noargs),
  CE(fsitos,	eb80ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fuitos,	eb80a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftosis,	ebd0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftosizs,	ebd0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftouis,	ebc0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftouizs,	ebc0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fmrx,	ef00a10, 2, (RR, RVC),	      rd_rn),
  CE(fmxr,	ee00a10, 2, (RVC, RR),	      rn_rd),
d9175 18
a9192 18
  CE(flds,	d100a00, 2, (RVS, ADDR),      vfp_sp_ldst),
  CE(fsts,	d000a00, 2, (RVS, ADDR),      vfp_sp_ldst),
  CE(fldmias,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fldmfds,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fldmdbs,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fldmeas,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fldmiax,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fldmfdx,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fldmdbx,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fldmeax,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fstmias,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fstmeas,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fstmdbs,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fstmfds,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fstmiax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fstmeax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fstmdbx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fstmfdx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
d9195 3
a9197 3
  CE(fabss,	eb00ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fnegs,	eb10a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fsqrts,	eb10ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
d9200 9
a9208 9
  CE(fadds,	e300a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fsubs,	e300a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmuls,	e200a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fdivs,	e800a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmacs,	e000a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmscs,	e100a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmuls,	e200a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmacs,	e000a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmscs,	e100a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
d9211 4
a9214 4
  CE(fcmps,	eb40a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fcmpzs,	eb50a40, 1, (RVS),	      vfp_sp_compare_z),
  CE(fcmpes,	eb40ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fcmpezs,	eb50ac0, 1, (RVS),	      vfp_sp_compare_z),
d9219 13
a9231 13
  CE(fcpyd,	eb00b40, 2, (RVD, RVD),	      rd_rm),
  CE(fcvtds,	eb70ac0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(fcvtsd,	eb70bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(fmdhr,	e200b10, 2, (RVD, RR),	      rn_rd),
  CE(fmdlr,	e000b10, 2, (RVD, RR),	      rn_rd),
  CE(fmrdh,	e300b10, 2, (RR, RVD),	      rd_rn),
  CE(fmrdl,	e100b10, 2, (RR, RVD),	      rd_rn),
  CE(fsitod,	eb80bc0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(fuitod,	eb80b40, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(ftosid,	ebd0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftosizd,	ebd0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftouid,	ebc0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftouizd,	ebc0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
d9234 10
a9243 10
  CE(fldd,	d100b00, 2, (RVD, ADDR),      vfp_dp_ldst),
  CE(fstd,	d000b00, 2, (RVD, ADDR),      vfp_dp_ldst),
  CE(fldmiad,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fldmfdd,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fldmdbd,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fldmead,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fstmiad,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fstmead,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fstmdbd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fstmfdd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
d9246 3
a9248 3
  CE(fabsd,	eb00bc0, 2, (RVD, RVD),	      rd_rm),
  CE(fnegd,	eb10b40, 2, (RVD, RVD),	      rd_rm),
  CE(fsqrtd,	eb10bc0, 2, (RVD, RVD),	      rd_rm),
d9251 9
a9259 9
  CE(faddd,	e300b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fsubd,	e300b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmuld,	e200b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fdivd,	e800b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmacd,	e000b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmscd,	e100b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmuld,	e200b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmacd,	e000b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmscd,	e100b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
d9262 4
a9265 4
  CE(fcmpd,	eb40b40, 2, (RVD, RVD),	      rd_rm),
  CE(fcmpzd,	eb50b40, 1, (RVD),	      rd),
  CE(fcmped,	eb40bc0, 2, (RVD, RVD),	      rd_rm),
  CE(fcmpezd,	eb50bc0, 1, (RVD),	      rd),
d9269 4
a9272 4
  CE(fmsrr,	c400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),
  CE(fmrrs,	c500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),
  CE(fmdrr,	c400b10, 3, (RVD, RR, RR),    rm_rd_rn),
  CE(fmrrd,	c500b10, 3, (RR, RR, RVD),    rd_rn_rm),
d9276 8
a9283 8
  CE(mia,	e200010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miaph,	e280010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miabb,	e2c0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miabt,	e2d0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miatb,	e2e0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miatt,	e2f0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(mar,	c400000, 3, (RXA, RRnpc, RRnpc), xsc_mar),
  CE(mra,	c500000, 3, (RRnpc, RRnpc, RXA), xsc_mra),
d9287 162
a9448 162
  CE(tandcb,	e13f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tandch,	e53f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tandcw,	e93f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tbcstb,	e400010, 2, (RIWR, RR),		    rn_rd),
  CE(tbcsth,	e400050, 2, (RIWR, RR),		    rn_rd),
  CE(tbcstw,	e400090, 2, (RIWR, RR),		    rn_rd),
  CE(textrcb,	e130170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrch,	e530170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrcw,	e930170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrmub,	e100070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmuh,	e500070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmuw,	e900070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsb,	e100078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsh,	e500078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsw,	e900078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(tinsrb,	e600010, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tinsrh,	e600050, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tinsrw,	e600090, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tmcr,	e000110, 2, (RIWC, RR),		    rn_rd),
  CE(tmcrr,	c400000, 3, (RIWR, RR, RR),	    rm_rd_rn),
  CE(tmia,	e200010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiaph,	e280010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiabb,	e2c0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiabt,	e2d0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiatb,	e2e0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiatt,	e2f0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmovmskb,	e100030, 2, (RR, RIWR),		    rd_rn),
  CE(tmovmskh,	e500030, 2, (RR, RIWR),		    rd_rn),
  CE(tmovmskw,	e900030, 2, (RR, RIWR),		    rd_rn),
  CE(tmrc,	e100110, 2, (RR, RIWC),		    rd_rn),
  CE(tmrrc,	c500000, 3, (RR, RR, RIWR),	    rd_rn_rm),
  CE(torcb,	e13f150, 1, (RR),		    iwmmxt_tandorc),
  CE(torch,	e53f150, 1, (RR),		    iwmmxt_tandorc),
  CE(torcw,	e93f150, 1, (RR),		    iwmmxt_tandorc),
  CE(waccb,	e0001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wacch,	e4001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(waccw,	e8001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(waddbss,	e300180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddb,	e000180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddbus,	e100180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddhss,	e700180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddh,	e400180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddhus,	e500180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddwss,	eb00180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddw,	e800180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddwus,	e900180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waligni,	e000020, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_waligni),
  CE(walignr0,	e800020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr1,	e900020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr2,	ea00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr3,	eb00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wand,	e200000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wandn,	e300000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2b,	e800000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2br,	e900000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2h,	ec00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2hr,	ed00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqb,	e000060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqh,	e400060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqw,	e800060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtub,	e100060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtuh,	e500060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtuw,	e900060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsb,	e300060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsh,	e700060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsw,	eb00060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wldrb,	c100000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wldrh,	c500000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wldrw,	c100100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
  CE(wldrd,	c500100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
  CE(wmacs,	e600100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacsz,	e700100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacu,	e400100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacuz,	e500100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmadds,	ea00100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaddu,	e800100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsb,	e200160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsh,	e600160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsw,	ea00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxub,	e000160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxuh,	e400160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxuw,	e800160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsb,	e300160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsh,	e700160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsw,	eb00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminub,	e100160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminuh,	e500160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminuw,	e900160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmov,	e000000, 2, (RIWR, RIWR),	    iwmmxt_wmov),
  CE(wmulsm,	e300100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulsl,	e200100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulum,	e100100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulul,	e000100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wor,	e000000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackhss,	e700080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackhus,	e500080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackwss,	eb00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackwus,	e900080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackdss,	ef00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackdus,	ed00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorh,	e700040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorhg,	e700148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wrorw,	eb00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorwg,	eb00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wrord,	ef00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrordg,	ef00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsadb,	e000120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadbz,	e100120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadh,	e400120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadhz,	e500120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wshufh,	e0001e0, 3, (RIWR, RIWR, I255),	    iwmmxt_wshufh),
  CE(wsllh,	e500040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsllhg,	e500148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsllw,	e900040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsllwg,	e900148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wslld,	ed00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wslldg,	ed00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrah,	e400040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrahg,	e400148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsraw,	e800040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrawg,	e800148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrad,	ec00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsradg,	ec00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrlh,	e600040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrlhg,	e600148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrlw,	ea00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrlwg,	ea00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrld,	ee00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrldg,	ee00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wstrb,	c000000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wstrh,	c400000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wstrw,	c000100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
  CE(wstrd,	c400100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
  CE(wsubbss,	e3001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubb,	e0001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubbus,	e1001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubhss,	e7001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubh,	e4001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubhus,	e5001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubwss,	eb001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubw,	e8001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubwus,	e9001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckehub,e0000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehuh,e4000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehuw,e8000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsb,e2000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsh,e6000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsw,ea000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckihb, e1000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckihh, e5000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckihw, e9000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckelub,e0000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckeluh,e4000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckeluw,e8000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsb,e2000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsh,e6000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsw,ea000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckilb, e1000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckilh, e5000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckilw, e9000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wxor,	e100000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wzero,	e300000, 1, (RIWR),		    iwmmxt_wzero),
d9452 76
a9527 76
  CE(cfldrs,	c100400, 2, (RMF, ADDR),	      rd_cpaddr),
  CE(cfldrd,	c500400, 2, (RMD, ADDR),	      rd_cpaddr),
  CE(cfldr32,	c100500, 2, (RMFX, ADDR),	      rd_cpaddr),
  CE(cfldr64,	c500500, 2, (RMDX, ADDR),	      rd_cpaddr),
  CE(cfstrs,	c000400, 2, (RMF, ADDR),	      rd_cpaddr),
  CE(cfstrd,	c400400, 2, (RMD, ADDR),	      rd_cpaddr),
  CE(cfstr32,	c000500, 2, (RMFX, ADDR),	      rd_cpaddr),
  CE(cfstr64,	c400500, 2, (RMDX, ADDR),	      rd_cpaddr),
  CE(cfmvsr,	e000450, 2, (RMF, RR),		      rn_rd),
  CE(cfmvrs,	e100450, 2, (RR, RMF),		      rd_rn),
  CE(cfmvdlr,	e000410, 2, (RMD, RR),		      rn_rd),
  CE(cfmvrdl,	e100410, 2, (RR, RMD),		      rd_rn),
  CE(cfmvdhr,	e000430, 2, (RMD, RR),		      rn_rd),
  CE(cfmvrdh,	e100430, 2, (RR, RMD),		      rd_rn),
  CE(cfmv64lr,	e000510, 2, (RMDX, RR),		      rn_rd),
  CE(cfmvr64l,	e100510, 2, (RR, RMDX),		      rd_rn),
  CE(cfmv64hr,	e000530, 2, (RMDX, RR),		      rn_rd),
  CE(cfmvr64h,	e100530, 2, (RR, RMDX),		      rd_rn),
  CE(cfmval32,	e200440, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32al,	e100440, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmvam32,	e200460, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32am,	e100460, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmvah32,	e200480, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32ah,	e100480, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmva32,	e2004a0, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32a,	e1004a0, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmva64,	e2004c0, 2, (RMAX, RMDX),	      rd_rn),
  CE(cfmv64a,	e1004c0, 2, (RMDX, RMAX),	      rd_rn),
  CE(cfmvsc32,	e2004e0, 2, (RMDS, RMDX),	      mav_dspsc),
  CE(cfmv32sc,	e1004e0, 2, (RMDX, RMDS),	      rd),
  CE(cfcpys,	e000400, 2, (RMF, RMF),		      rd_rn),
  CE(cfcpyd,	e000420, 2, (RMD, RMD),		      rd_rn),
  CE(cfcvtsd,	e000460, 2, (RMD, RMF),		      rd_rn),
  CE(cfcvtds,	e000440, 2, (RMF, RMD),		      rd_rn),
  CE(cfcvt32s,	e000480, 2, (RMF, RMFX),	      rd_rn),
  CE(cfcvt32d,	e0004a0, 2, (RMD, RMFX),	      rd_rn),
  CE(cfcvt64s,	e0004c0, 2, (RMF, RMDX),	      rd_rn),
  CE(cfcvt64d,	e0004e0, 2, (RMD, RMDX),	      rd_rn),
  CE(cfcvts32,	e100580, 2, (RMFX, RMF),	      rd_rn),
  CE(cfcvtd32,	e1005a0, 2, (RMFX, RMD),	      rd_rn),
  CE(cftruncs32,e1005c0, 2, (RMFX, RMF),	      rd_rn),
  CE(cftruncd32,e1005e0, 2, (RMFX, RMD),	      rd_rn),
  CE(cfrshl32,	e000550, 3, (RMFX, RMFX, RR),	      mav_triple),
  CE(cfrshl64,	e000570, 3, (RMDX, RMDX, RR),	      mav_triple),
  CE(cfsh32,	e000500, 3, (RMFX, RMFX, I63s),	      mav_shift),
  CE(cfsh64,	e200500, 3, (RMDX, RMDX, I63s),	      mav_shift),
  CE(cfcmps,	e100490, 3, (RR, RMF, RMF),	      rd_rn_rm),
  CE(cfcmpd,	e1004b0, 3, (RR, RMD, RMD),	      rd_rn_rm),
  CE(cfcmp32,	e100590, 3, (RR, RMFX, RMFX),	      rd_rn_rm),
  CE(cfcmp64,	e1005b0, 3, (RR, RMDX, RMDX),	      rd_rn_rm),
  CE(cfabss,	e300400, 2, (RMF, RMF),		      rd_rn),
  CE(cfabsd,	e300420, 2, (RMD, RMD),		      rd_rn),
  CE(cfnegs,	e300440, 2, (RMF, RMF),		      rd_rn),
  CE(cfnegd,	e300460, 2, (RMD, RMD),		      rd_rn),
  CE(cfadds,	e300480, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfaddd,	e3004a0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfsubs,	e3004c0, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfsubd,	e3004e0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfmuls,	e100400, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfmuld,	e100420, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfabs32,	e300500, 2, (RMFX, RMFX),	      rd_rn),
  CE(cfabs64,	e300520, 2, (RMDX, RMDX),	      rd_rn),
  CE(cfneg32,	e300540, 2, (RMFX, RMFX),	      rd_rn),
  CE(cfneg64,	e300560, 2, (RMDX, RMDX),	      rd_rn),
  CE(cfadd32,	e300580, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfadd64,	e3005a0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfsub32,	e3005c0, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfsub64,	e3005e0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfmul32,	e100500, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmul64,	e100520, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfmac32,	e100540, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmsc32,	e100560, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmadd32,	e000600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
  CE(cfmsub32,	e100600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
  CE(cfmadda32, e200600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
  CE(cfmsuba32, e300600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
d9536 2
d10174 1
d10377 19
d11027 1
d11035 6
a11040 1
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
d11044 5
a11048 1
      md_number_to_chars (buf, newval, INSN_SIZE);
d11052 1
d11370 1
@


1.220
log
@2005-08-15  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (do_t_mov_cmp): Fix encoding of i16-bit conditional
	instructions.
	(do_t_mvn_tst, do_t_neg, do_t_shift): Ditto.
gas/testsuite/
	* gas/arm/thumb2_it.s: Add more instruction variants.
	* gas/arm/thumb2_it.d: Ditto.
@
text
@d7679 2
d7682 1
a7682 1
	    return 0;
@


1.219
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d6699 12
d6720 1
a6720 4
      else if (inst.size_req == 4
	       || inst.operands[1].shifted
	       || (inst.instruction == T_MNEM_movs
		   && (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)))
d6745 1
a6745 1
	    if (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7)
d6813 14
d6840 1
a6840 6
	  if (inst.instruction < 0xffff
	      && THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[1].shifted
	      && inst.operands[0].reg <= 7
	      && inst.operands[1].reg <= 7
	      && inst.size_req != 4)
d6968 12
a6979 3
      if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7
	  || !THUMB_SETS_FLAGS (inst.instruction)
	  || inst.size_req == 4)
d7157 32
a7188 6
      if (inst.operands[0].reg > 7
	  || inst.operands[1].reg > 7
	  || !THUMB_SETS_FLAGS (inst.instruction)
	  || (!inst.operands[2].isreg && inst.instruction == T_MNEM_rors)
	  || (inst.operands[2].isreg && inst.operands[1].reg != inst.operands[0].reg)
	  || inst.size_req == 4)
d7200 1
a7200 13
	      switch (inst.instruction)
		{
		case T_MNEM_asr:
		case T_MNEM_asrs: inst.operands[1].shift_kind = SHIFT_ASR; break;
		case T_MNEM_lsl:
		case T_MNEM_lsls: inst.operands[1].shift_kind = SHIFT_LSL; break;
		case T_MNEM_lsr:
		case T_MNEM_lsrs: inst.operands[1].shift_kind = SHIFT_LSR; break;
		case T_MNEM_ror:
		case T_MNEM_rors: inst.operands[1].shift_kind = SHIFT_ROR; break;
		default: abort ();
		}
	      
d7213 1
a7213 1
	      switch (inst.instruction)
d7215 4
a7218 4
		case T_MNEM_asrs: inst.instruction = T_OPCODE_ASR_R; break;
		case T_MNEM_lsls: inst.instruction = T_OPCODE_LSL_R; break;
		case T_MNEM_lsrs: inst.instruction = T_OPCODE_LSR_R; break;
		case T_MNEM_rors: inst.instruction = T_OPCODE_ROR_R; break;
d7227 1
a7227 1
	      switch (inst.instruction)
d7229 3
a7231 3
		case T_MNEM_asrs: inst.instruction = T_OPCODE_ASR_I; break;
		case T_MNEM_lsls: inst.instruction = T_OPCODE_LSL_I; break;
		case T_MNEM_lsrs: inst.instruction = T_OPCODE_LSR_I; break;
@


1.218
log
@2005-08-05  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (current_it_mask, current_cc): New variables.
	(do_t_add_sub): Use correct encodings inside IT block.
	(do_t_arit3c): Ditto.
	(do_t_it): Simplify logic.  Set current_it_mask and current_cc.
	(md_assemble): Verify conditional suffixes agains IT blocks.
gas/testsuite/
	* gas/arm/thumb32.s: Use correct conditional suffixes inside IT
	blocks.
	* gas/arm/thumb2_it.d, gas/arm/thumb2_it.s: New test.
@
text
@a177 3
/* Size of relocation record.  */
const int md_reloc_size = 8;

@


1.217
log
@2005-08-05  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (encode_thumb32_immediate): Only accept shifted
	constants.
	(encode_thumb32_shifted_operand): Prohibit register shifts.
	(encode_thumb32_addr_mode): Fix typo.
	(insns): Correct thumb2 ldm and stm opcodes.
gas/testsuite/
	* gas/arm/thumb32.d: Update ldm/stm dests.
	* gas/arm/thumb32.s: Ditto.
@
text
@d538 5
d5871 2
d5887 11
a5897 3
	      if (Rd <= 7 && Rn <= 7 && Rn <= 7
		  && (inst.instruction == T_MNEM_adds
		      || inst.instruction == T_MNEM_subs))
d5899 2
a5900 1
		  inst.instruction = (inst.instruction == T_MNEM_adds
d6037 2
d6040 13
a6052 3
	  if (THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[2].shifted
	      && inst.size_req != 4
d6120 2
d6123 13
a6135 3
	  if (THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[2].shifted
	      && inst.size_req != 4)
d6406 5
a6413 1
      inst.instruction &= 0xfff0;
d6418 3
a6420 3
	mask = (~(mask & 0x8) & 0x8) | 0x4;
      else if ((mask & 1) == 0)
	mask = (~(mask & 0xC) & 0xC) | 0x2;
d6422 1
a6422 1
	mask = (~(mask & 0xE) & 0xE) | 0x1;
d6424 2
a6425 1
      inst.instruction |= (mask & 0xF);
d7735 19
d7760 4
@


1.216
log
@config/tc-arm.c (do_iwmmxt_wldstd): Correct the offset range for WLDRD/WSTRD
  instruction.
gas/arm/iwmmxt-bad2.s: New file: Check for error messages about erroneous
  offsets in iwmmxt instructions.  Cannot be part of iwmmxt-bad.s because
  the errors there stop the assembler before it gets to check the offsets
  in instructions.
gas/arm/iwmmxt-bad2.d: New file.
gas/arm/iwmmxt-bad2.l: New file: Expected error messages.
gas/arm/iwmmxt.s: Change the offset values of the WLDRD, WSTRD and WSTRW
  instructions to be larger than +/-255.
gas/arm/iwmmxt.d: Fix the expected results for these instructions.
@
text
@d3992 1
a3992 1
  if (val <= 255)
d3995 1
a3995 1
  for (i = 0; i < 32; i++)
d3997 3
a3999 3
      a = rotate_left (val, i);
      if (a >= 128 && a <= 255)
	return (a & 0x7f) | (i << 7);
d5640 2
d5700 2
a5701 1
	  constraint (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 3,
d5703 1
a5703 1
	  inst.instruction |= inst.reloc.exp.X_op << 4;
d8274 2
a8275 2
 TC3(stmdb,	9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(stmfd,     9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
d8277 2
a8278 2
 TC3(ldmdb,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(ldmea,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
@


1.215
log
@2005-07-29  Paul Brook  <paul@@codesourcery.com>

bfd/
	* reloc.c: Add BFD_RELOC_ARM_T32_ADD_PC12.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* config/tc-arm.c (T16_32_TAB): Add "addr". Fix encoding of push and
	pop.
	(do_t_addr): Implement 32-bit variant.
	(do_t_push_pop): Make some errors warnings.  Handle single register
	32-bit case.
	(insns): Use tCE for adr.
	(md_pcrel_from_section): Handle BFD_RELOC_ARM_T32_ADD_PC12.
	(md_apply_fix): Ditto.
gas/testsuite/
	* gas/arm/thumb32.d: Fix expected output for writeback addressing
	modes.  Add single high reg push/pop test.
	* gas/asm/thumb32.s: Add single high reg push/pop test.
opcodes/
	* arm-dis.c: Fix disassebly of thumb2 writeback addressing modes.
@
text
@d5519 1
a5519 1
  encode_arm_cp_address (1, TRUE, FALSE, BFD_RELOC_ARM_CP_OFF_IMM_S2);
@


1.214
log
@2005-07-29  Paul Brook  <paul@@codesourcery.com>

bfd/
	* reloc.c (BFD_RELOC_ARM_T32_IMM12): Add.
	* bfd-in2.h: Regeenrate.
	* libbfd.h: Regenerate.
gas/
	* config/tc-arm.c (parse_tb): New function.
	(enum operand_parse_code): Add OP_TB.
	(parse_operands): Handle OP_TB.
	(do_t_add_sub_w, do_t_tb): New functions.
	(insns): Add entries for addw, subw, tbb and tbh.
	(md_apply_fix): Handle BFD_RELOC_ARM_T32_IMM12.
gas/testsuite/
	* gas/arm/thumb32.s: Add tests for addw, subw, tbb and tbh.
	* gas/arm/thumb32.d: Ditto.
opcodes/
	* arm-dis.c (thumb32_opc): Fix addressing mode for tbh.
	(print_insn_thumb32): Fix decoding of thumb2 'I' operands.
@
text
@d5751 1
d5785 2
a5786 2
  X(pop,   bc00, e8ad0000), /* ldmia sp!,... */	\
  X(push,  b400, e8bd0000), /* stmia sp!,... */	\
d5967 15
a5981 3
  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;
d5983 2
a5984 1
  inst.instruction |= inst.operands[0].reg << 4;
d6965 2
d6972 2
a6973 1
  if ((inst.operands[0].imm & ~0xff) == 0)
d6976 1
a6976 1
	    && (inst.operands[0].imm & ~0xff) == 1 << REG_LR)
d6978 1
a6978 1
	       && (inst.operands[0].imm & ~0xff) == 1 << REG_PC))
d6982 1
a6982 1
      inst.operands[0].imm &= 0xff;
d6986 2
a6987 2
      if (inst.operands[1].imm & (1 << 13))
	as_warn (_("SP should not be in register list"));
d6990 2
a6991 2
	  if (inst.operands[1].imm & (1 << 15))
	    as_warn (_("PC should not be in register list"));
d6995 13
a7007 3
	  if (inst.operands[1].imm & (1 << 14)
	      && inst.operands[1].imm & (1 << 15))
	    as_warn (_("LR and PC should not both be in register list"));
d7009 2
a7010 2

      inst.instruction = THUMB_OP32 (inst.instruction);
d7018 1
a7018 1
  inst.instruction |= inst.operands[0].imm;
d8235 1
a8235 1
 TCE(adr,	28f0000, 000f,	   2, (RR, EXP),     adr,  t_adr),
d10040 1
d10563 1
d10582 4
a10585 1
      if (fixP->fx_r_type == BFD_RELOC_ARM_T32_IMM12)
d10587 6
a10597 2
      else
	newimm = encode_thumb32_immediate (value);
a10598 1
      /* FUTURE: Implement analogue of negate_data_op for T32.  */
@


1.213
log
@2005-07-21  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (encode_thumb32_addr_mode): Don't set
	inst.reloc.pc_rel.
gas/testsuite/
	* gas/arm/thumb32.s: Add tests for [pc, #imm] addressing modes.
	* gas/arm/thumb32.d: Ditto.
@
text
@d3494 49
d3598 1
d3840 4
d5831 14
d7295 15
d8550 9
d10534 1
d10553 9
a10561 1
      newimm = encode_thumb32_immediate (value);
@


1.212
log
@Fix compile time warning messages about signed/unsigned conflicts reported
by GCC 4.0
@
text
@a5669 1
      inst.reloc.pc_rel = is_pc;
@


1.211
log
@gas:
	* config/tc-arm.c (T_OPCODE_BRANCH, encode_arm_addr_mode_2)
	(encode_arm_addr_mode_3, encode_arm_cp_address, do_blx, do_t_blx)
	(do_t_branch, insns [b, bl]): Don't encode pipeline offset.
	(s_arm_elf_cons): Disallow use of (plt) suffix.
	(do_adrl): Adjust X_add_number unconditionally.
	(md_pcrel_from): Rename md_pcrel_from_section, add second segT
	argument.  Handle all adjustment for pipeline offset here.
	(md_apply_fix): No need to undo work of md_pcrel_from.  No
	need to extract pre-encoded pipeline adjustments from various
	branch instructions.  Generally, assume instructions are already
	all-bits-zero in the field being fixed up.  Remove all OBJ_ELF
	special cases.  Handle BFD_RELOC_ARM_PLT32 like
	BFD_RELOC_ARM_PCREL_BRANCH.
	(tc_gen_reloc): Remove OBJ_ELF special case.
	* config/tc-arm.c: Define MD_PCREL_FROM_SECTION.

gas/testsuite:
	* gas/arm/arm.exp: Don't special case ldconst, arm7t, or copro
	for *-wince-*.
	* gas/arm/wince_arm7t.d, gas/arm/wince_copro.d
	* gas/arm/wince_ldconst.d: Delete.
@
text
@d229 11
a239 11
    unsigned imm;
    unsigned present	: 1;  /* operand present */
    unsigned isreg	: 1;  /* operand was a register */
    unsigned immisreg	: 1;  /* .imm field is a second register */
    unsigned hasreloc	: 1;  /* operand has relocation suffix */
    unsigned writeback	: 1;  /* operand has trailing ! */
    unsigned preind	: 1;  /* preindexed address */
    unsigned postind	: 1;  /* postindexed address */
    unsigned negative	: 1;  /* index register was negated */
    unsigned shifted	: 1;  /* shift applied to operation */
    unsigned shift_kind : 3;  /* shift operation (enum shift_kind) */
d1038 1
a1038 1
parse_vfp_reg_list (char **str, int *pbase, int dp)
d2338 1
a2338 1
  int reg;
d3249 1
a3249 1
				       0, 255, TRUE) == FAIL)
d3577 1
a3577 1
parse_operands (char *str, const char *pattern)
d4648 2
a4649 2
	       && (inst.operands[2].imm == inst.operands[0].reg
		   || inst.operands[2].imm == inst.operands[1].reg))
@


1.210
log
@gas:
	* config/tc-arm.c (find_real_start): Check S_IS_LOCAL on
	symbolP as well as for names with a leading dot.  Use ACONCAT.
	(md_apply_fix): For branch relocations, only replace value
	with fixP->fx_offset (under #ifdef OBJ_ELF) when !fixP->fx_done.
	(arm_force_relocation): Remove #ifdef OBJ_ELF case.
	* config/tc-arm.h (LOCAL_LABEL): Remove unnecessary parentheses.
	(LOCAL_LABEL_PREFIX): Don't define.
gas/testsuite:
	* gas/arm/thumb.s: Only branch to labels defined in this file.
	* gas/arm/thumb.d, gas/arm/thumb32.d: Adjust expected output.
@
text
@d488 1
a488 1
#define T_OPCODE_BRANCH 0xe7fe
d1973 7
d1981 1
a1981 1
		as_bad ("%s relocations do not fit in %d bytes",
a4084 2
      if (inst.reloc.pc_rel)
	inst.reloc.exp.X_add_number -= 8;  /* pipeline offset */
a4114 2
      if (inst.reloc.pc_rel)
	inst.reloc.exp.X_add_number -= 8;  /* pipeline offset */
a4166 2
  if (inst.reloc.pc_rel)
    inst.reloc.exp.X_add_number -= 8;
a4332 3
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
#endif
d4334 1
a4349 3
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
#endif
d4352 1
a4431 1
      inst.reloc.pc_rel = 0;
a4435 1
      inst.reloc.pc_rel = 1;
d4437 1
d4471 1
a4471 1
      inst.instruction = 0xfafffffe;
d6127 1
a6127 1
      inst.instruction = 0xf7ffeffe;
d6140 1
a6140 1
	  inst.instruction = 0xf7ffbffe;
d6146 1
a6146 1
	  inst.instruction = (inst.cond << 22) | 0xf43faffe;
d6156 1
a6156 1
	  inst.instruction = 0xd0fe | (inst.cond << 8);
d8122 2
a8123 8
#ifdef TE_WINCE
  /* XXX This is the wrong place to do this.  Think multi-arch.	 */
 TCE(b,		a000000, e7fe,	     1, (EXPr),	    branch, t_branch),
 TCE(bl,	b000000, f7fffffe,   1, (EXPr),	    branch, t_branch23),
#else
 TCE(b,		afffffe, e7fe,	     1, (EXPr),	    branch, t_branch),
 TCE(bl,	bfffffe, f7fffffe,   1, (EXPr),	    branch, t_branch23),
#endif
d8126 3
a8128 3
 TCE(adr,	28f0000, 000f,	   2, (RR, EXP),    adr,  t_adr),
  C3(adrl,	28f0000,           2, (RR, EXP),    adrl),
 tCE(nop,	1a00000, nop,	   1, (oI255c),	    nop,  t_nop),
d8136 1
a8136 1
 tC3(asrs,     1b00040, asrs,     3, (RR, oRR, SH), shift, t_shift),
d8146 1
a8146 1
 TCE(cpy,       1a00000, 4600,     2, (RR, RR),          rd_rm, t_cpy),
d8163 1
a8163 1
 TC3(stmfd,    9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
d9891 5
a9895 2
/* The knowledge of the PC's pipeline offset is built into the insns
   themselves.	*/
d9898 1
a9898 1
md_pcrel_from (fixS * fixP)
d9900 9
a9908 4
  if (fixP->fx_addsy
      && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section
      && fixP->fx_subsy == NULL)
    return 0;
a9909 4
  /* PC relative addressing on the Thumb is slightly odd as the bottom
     two bits of the PC are forced to zero for the calculation.  This
     happens *after* application of the pipeline offset.  However,
     Thumb adrl already adjusts for this, so we need not do it again.  */
d9912 5
d9918 1
a9918 1
      return (fixP->fx_where + fixP->fx_frag->fr_address) & ~3;
d9922 1
a9922 1
      return (fixP->fx_where + fixP->fx_frag->fr_address + 4) & ~3;
d9924 9
a9932 3
    default:
      break;
    }
d9934 5
d9940 1
a9940 3
  /* The pattern was adjusted to accommodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accommodation.	*/
  return fixP->fx_where + fixP->fx_frag->fr_address + 8;
d9942 1
a9942 1
  return fixP->fx_where + fixP->fx_frag->fr_address;
d9944 16
a10141 11
  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo its effects here.  */
  if (fixP->fx_pcrel)
    {
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
    }

a10301 1
      newval &= 0xff00;
a10471 1
      newval &= 0xfbff8f00;
d10484 1
a10484 1
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xfff000f0;
d10495 1
a10495 1
	  newval = md_chars_to_number (buf, THUMB_SIZE) & 0xff00;
d10504 1
a10504 1
	  newval = md_chars_to_number (buf, INSN_SIZE) & 0xff000000;
a10518 5
      newval = md_chars_to_number (buf, INSN_SIZE);

      /* Sign-extend a 24-bit number.  */
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)

d10520 1
a10520 2
      if (!fixP->fx_done)
	value = fixP->fx_offset;
d10524 7
a10530 42
	 instruction, in a 24 bit, signed field  Thus we need to check
	 that none of the top 8 bits of the shifted value (top 7 bits of
	 the unshifted, unsigned value) are set, or that they are all set.  */
      if ((value & ~ ((offsetT) 0x1ffffff)) != 0
	  && ((value & ~ ((offsetT) 0x1ffffff)) != ~ ((offsetT) 0x1ffffff)))
	{
#ifdef OBJ_ELF
	  /* Normally we would be stuck at this point, since we cannot store
	     the absolute address that is the destination of the branch in the
	     24 bits of the branch instruction.	 If however, we happen to know
	     that the destination of the branch is in the same section as the
	     branch instruction itself, then we can compute the relocation for
	     ourselves and not have to bother the linker with it.

	     FIXME: The test for OBJ_ELF is only here because I have not
	     worked out how to do this for OBJ_COFF.  */
	  if (fixP->fx_addsy != NULL
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
	    {
	      /* Get pc relative value to go into the branch.  */
	      value = * valP;

	      /* Permit a backward branch provided that enough bits
		 are set.  Allow a forwards branch, provided that
		 enough bits are clear.	 */
	      if (   (value & ~ ((offsetT) 0x1ffffff)) == ~ ((offsetT) 0x1ffffff)
		  || (value & ~ ((offsetT) 0x1ffffff)) == 0)
		fixP->fx_done = 1;
	    }

	  if (! fixP->fx_done)
#endif
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("GAS can't handle same-section branch dest >= 0x04000000"));
	}

      value >>= 2;
      value += SEXT24 (newval);

      if (    (value & ~ ((offsetT) 0xffffff)) != 0
	  && ((value & ~ ((offsetT) 0xffffff)) != ~ ((offsetT) 0xffffff)))
d10532 1
a10532 1
		      _("out of range branch"));
d10534 1
a10534 1
      if (seg->use_rela_p && !fixP->fx_done)
d10536 3
a10538 7
	  /* Must unshift the value before storing it in the addend.  */
	  value <<= 2;
#ifdef OBJ_ELF
	  fixP->fx_offset = value;
#endif
	  fixP->fx_addnumber = value;
	  newval = newval & 0xff000000;
a10539 3
      else
	  newval = (value & 0x00ffffff) | (newval & 0xff000000);
      md_number_to_chars (buf, newval, INSN_SIZE);
d10543 10
a10552 3
      {
	offsetT hbit;
	newval = md_chars_to_number (buf, INSN_SIZE);
d10554 5
a10558 7
#ifdef OBJ_ELF
	if (!fixP->fx_done)
	  value = fixP->fx_offset;
#endif
	hbit   = (value >> 1) & 1;
	value  = (value >> 2) & 0x00ffffff;
	value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;
d10560 4
a10563 16
	if (seg->use_rela_p && !fixP->fx_done)
	  {
	    /* Must sign-extend and unshift the value before storing
	       it in the addend.  */
	    value = SEXT24 (value);
	    value = (value << 2) | hbit;
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xfe000000;
	  }
	else
	  newval = value | (newval & 0xfe000000) | (hbit << 24);
	md_number_to_chars (buf, newval, INSN_SIZE);
      }
d10567 4
a10570 9
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = ((newval & 0x00f8) >> 2) | (newval & 0x0200) >> 3;
	/* This one does not have the offset encoded in the pattern.  */
	value = value + diff - 4;
	/* CZB can only branch forward.  */
	if (value & ~0x7e)
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
d10572 3
a10574 9
	newval &= 0xfd07;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
d10576 2
a10577 2
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
d10581 3
a10583 5
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0xff) << 1;
	if (diff & 0x100)
	  diff |= ~0xff;
d10585 6
a10590 16
	value += diff;
	if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xff00;
	  }
	else
	  newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
d10594 3
a10596 5
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0x7ff) << 1;
	if (diff & 0x800)
	  diff |= ~0x7ff;
d10598 6
a10603 16
	value += diff;
	if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	  }
	else
	  newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
d10607 3
a10609 3
      {
	offsetT newval2;
	addressT diff, S, J1, J2, lo, hi;
d10611 4
a10614 2
	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
d10616 13
a10628 38
	S  = !(newval & 0x0400);  /* flipped - 0=negative */
	hi = (newval  & 0x003f);
	J1 = (newval2 & 0x2000) >> 13;
	J2 = (newval2 & 0x0800) >> 11;
	lo = (newval2 & 0x07ff);

	diff = ((S << 20) | (J2 << 19) | (J1 << 18) | (hi << 12) | (lo << 1));
	diff -= (1 << 20);  /* sign extend */
	value += diff;

	if ((value & ~0x1fffff) && ((value & ~0x1fffff) != ~0x1fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("conditional branch out of range"));

	newval  = newval  & 0xfbc0;
	newval2 = newval2 & 0xd000;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
	  {
	    S  = (value & 0x00100000) >> 20;
	    J2 = (value & 0x00080000) >> 19;
	    J1 = (value & 0x00040000) >> 18;
	    hi = (value & 0x0003f000) >> 12;
	    lo = (value & 0x00000ffe) >> 1;

	    newval  = newval  | (S << 10) | hi;
	    newval2 = newval2 | (J1 << 13) | (J2 << 11) | lo;
	  }

	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
d10633 3
a10635 3
      {
	offsetT newval2;
	addressT diff;
d10637 19
a10655 10
	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	if (diff & 0x400000)
	  diff |= ~0x3fffff;
#ifdef OBJ_ELF
	if (!fixP->fx_done)
	  value = fixP->fx_offset;
#endif
	value += diff;
d10657 4
a10660 3
	if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch with link out of range"));
d10662 4
a10665 6
	if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  value = (value + 1) & ~ 1;
d10667 16
a10682 17
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	    newval2 = newval2 & 0xf800;
	  }
	else
	  {
	    newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
	    newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	  }
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
d10686 1
a10686 3
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
a10687 61
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 1);
	}
#endif
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH25:
      {
	offsetT newval2;
	addressT diff, S, I1, I2, lo, hi;

	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);

	S  = (newval  & 0x0400) >> 10;
	hi = (newval  & 0x03ff);
	I1 = (newval2 & 0x2000) >> 13;
	I2 = (newval2 & 0x0800) >> 11;
	lo = (newval2 & 0x07ff);

	I1 = !(I1 ^ S);
	I2 = !(I2 ^ S);
	S  = !S;

	diff = ((S << 24) | (I1 << 23) | (I2 << 22) | (hi << 12) | (lo << 1));
	diff -= (1 << 24);  /* sign extend */
	value += diff;

	if ((value & ~0x1ffffff) && ((value & ~0x1ffffff) != ~0x1ffffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));

	newval  = newval  & 0xf800;
	newval2 = newval2 & 0xd000;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
	  {
	    S  = (value & 0x01000000) >> 24;
	    I1 = (value & 0x00800000) >> 23;
	    I2 = (value & 0x00400000) >> 22;
	    hi = (value & 0x003ff000) >> 12;
	    lo = (value & 0x00000ffe) >> 1;

	    I1 = !(I1 ^ S);
	    I2 = !(I2 ^ S);

	    newval  = newval  | (S << 10) | hi;
	    newval2 = newval2 | (I1 << 13) | (I2 << 11) | lo;
	  }
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
d10691 1
a10691 3
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
a10692 7
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 2);
	}
#endif
d10707 2
a10708 3
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      md_number_to_chars (buf, 0, 4);
d10718 1
a10718 3
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
a10719 7
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 4);
	}
#endif
d10724 1
a10724 1
      if (fixP->fx_done || fixP->fx_pcrel)
a10735 4

    case BFD_RELOC_ARM_PLT32:
      /* It appears the instruction is fully prepared at this point.  */
      break;
d10957 2
a10958 7
  /* @@@@ Why fx_addnumber sometimes and fx_offset other times?  */
#ifndef OBJ_ELF
  if (fixp->fx_pcrel == 0)
    reloc->addend = fixp->fx_offset;
  else
    reloc->addend = fixp->fx_offset = reloc->address;
#else  /* OBJ_ELF */
a10959 1
#endif
@


1.209
log
@Revert accidental commit
@
text
@d1417 6
a1422 4
  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.	*/
  if (name[0] == '.')
d1425 1
a1425 3
  real_start = malloc (strlen (name) + strlen (STUB_NAME) + 1);
  sprintf (real_start, "%s%s", STUB_NAME, name);

a1433 2
  free (real_start);

d10514 2
a10515 1
      value = fixP->fx_offset;
d10585 2
a10586 1
	value = fixP->fx_offset;
d10745 2
a10746 1
	value = fixP->fx_offset;
a11356 7
#ifdef OBJ_ELF
  if (fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;
#endif
@


1.208
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d1417 3
a1419 5
  /* The compiler may generate BL instructions to local labels because
     it needs to perform a branch to a far away location. These labels
     do not have a corresponding ".real_start_of" label.  To accomodate
     hand-written assembly, we don't insist on a leading ".L", just a
     leading dot.  */
d10516 1
a10516 2
      if (!fixP->fx_done)
	value = fixP->fx_offset;
d10586 1
a10586 2
	if (!fixP->fx_done)
	  value = fixP->fx_offset;
d10745 1
a10745 2
	if (!fixP->fx_done)
	  value = fixP->fx_offset;
d11356 7
@


1.207
log
@(CE, C3, CM, UE, UF): Redefine without reference to their Thumb-enabled
equivalents.
@
text
@d1417 5
a1421 3
  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.	*/
d3076 1
a3076 1
   is deferred to md_apply_fix3.  */
d3127 1
a3127 1
      /* Convert to decoded value.  md_apply_fix3 will put it back.  */
d3982 1
a3982 1
   if any, is handled by md_apply_fix3.	 */
d9968 1
a9968 1
/* Subroutine of md_apply_fix3.	 Check to see if an immediate can be
d10015 1
a10015 1
/* Subroutine of md_apply_fix3.	 Do those data_ops which can take a
d10105 1
a10105 1
md_apply_fix3 (fixS *	fixP,
d10518 2
a10519 1
      value = fixP->fx_offset;
d10589 2
a10590 1
	value = fixP->fx_offset;
d10749 2
a10750 1
	value = fixP->fx_offset;
a11360 7
#ifdef OBJ_ELF
  if (fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;
#endif
@


1.206
log
@(TxCE, TxC3, TxCM, TUE, TUF): Remove redundant test for the presence of thumb
version of the parsing functions since they must always exist and the test
generates a compile time warning message.
@
text
@d8030 38
a8067 5
#define CE(mnem,  op, nops, ops, ae) TCE(mnem,  op, 0, nops, ops, ae, 0)
#define C3(mnem,  op, nops, ops, ae) TC3(mnem,  op, 0, nops, ops, ae, 0)
#define CM(m1,m2, op, nops, ops, ae) TCM(m1,m2, op, 0, nops, ops, ae, 0)
#define UE(mnem,  op, nops, ops, ae) TUE(mnem,  op, 0, nops, ops, ae, 0)
#define UF(mnem,  op, nops, ops, ae) TUF(mnem,  op, 0, nops, ops, ae, 0)
@


1.205
log
@	* config/tc-arm.h (TC_FIX_TYPE): Change to int.
	(TC_INIT_FIX_DATA): Initialize to 0, not NULL.
	* config/tc-arm.c (fix_new_arm): Remove now-unnecessary cast.
	(md_apply_fix3): Delete fix_is_thumb variable; refer to
	fixP->tc_fix_data directly in the sole place it was used.
	Explicitly truncate value, *valP, fixP->fx_addnumber, and
	fixP->fx_offset to 32 bits, for consistent behavior between 32-
	and 64-bit hosts.
@
text
@d7966 1
a7966 1
    do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
d7979 1
a7979 1
    do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
d7989 1
a7989 1
    0x##op, top, ARM_VARIANT, do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
d8021 1
a8021 1
    do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
d8027 1
a8027 1
    do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
@


1.204
log
@include/elf:
	* arm.h: Import complete list of official relocation names
	and numbers from AAELF.  Define FAKE_RELOCs for old names.
	Remove a few old names no longer used anywhere.

bfd:
	* elf32-arm.c: Wherever possible, use official reloc names
	from AAELF.
	(elf32_arm_howto_table, elf32_arm_tls_gd32_howto)
	(elf32_arm_tls_ldo32_howto, elf32_arm_tls_ldm32_howto)
	(elf32_arm_tls_le32_howto, elf32_arm_tls_ie32_howto)
	(elf32_arm_vtinherit_howto, elf32_arm_vtentry_howto)
	(elf32_arm_pc11_howto, elf32_arm_thm_pc9_howto, elf32_arm_got_prel)
	(elf32_arm_r_howto): Replace with elf32_arm_howto_table_1,
	elf32_arm_howto_table_2, and elf32_arm_howto_table_3.
	Add many new relocations from AAELF.
	(elf32_arm_howto_from_type): Update to match.
	(elf32_arm_reloc_map): Add entries for R_ARM_THM_JUMP24,
	R_ARM_THM_JUMP11, R_ARM_THM_JUMP19, R_ARM_THM_JUMP8,
	R_ARM_THM_JUMP6, R_ARM_GNU_VTINHERIT, and R_ARM_GNU_VTENTRY.
	(elf32_arm_reloc_type_lookup): Use elf32_arm_howto_from_type.
	(elf32_arm_final_link_relocate): Add support for
	R_ARM_THM_JUMP24, R_ARM_THM_JUMP19, R_ARM_THM_JUMP6.  Remove
	case entries redundant with default.

	* reloc.c: Reorganize ARM relocations.  Add Thumb
	assembler-internal relocations BFD_RELOC_ARM_T32_OFFSET_U8,
	BFD_RELOC_ARM_T32_OFFSET_IMM, BFD_RELOC_ARM_T32_IMMEDIATE.
	Add visible relocations BFD_RELOC_THUMB_PCREL_BRANCH7,
	BFD_RELOC_THUMB_BRANCH20, BFD_RELOC_THUMB_BRANCH25.
	Delete unused relocations BFD_RELOC_ARM_GOT12, BFD_RELOC_ARM_COPY.
	* bfd-in2.h, libbfd.h: Regenerate.

opcodes:
	* arm-dis.c (thumb_opcodes): Add disassembly for V6T2 16-bit
	instructions.  Adjust disassembly of some opcodes to match
	unified syntax.
	(thumb32_opcodes): New table.
	(print_insn_thumb): Rename print_insn_thumb16; don't handle
	two-halfword branches here.
	(print_insn_thumb32): New function.
	(print_insn): Choose among print_insn_arm, print_insn_thumb16,
	and print_insn_thumb32.  Be consistent about order of
	halfwords when printing 32-bit instructions.

gas:
	* hash.c (hash_lookup): Add len parameter.  All callers changed.
	(hash_find_n): New interface.
	* hash.h: Prototype hash_find_n.
	* sb.c: Include as.h.
	(scrub_from_sb, sb_to_scrub, scrub_position): New statics.
	(sb_scrub_and_add_sb): New interface.
	* sb.h: Prototype sb_scrub_and_add_sb.
	* input-scrub.c (input_scrub_include_sb): Use sb_scrub_and_add_sb.

	* config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Remove
	reference to BFD_RELOC_ARM_GOT12 which is never generated.
	* config/tc-arm.c: Rewrite, adding Thumb-2 support.

gas/testsuite:
	* gas/arm/arm.exp: Convert all existing "gas_test" tests to
	"run_dump_test" tests.  Run more tests unconditionally.  Run new tests.
	* gas/arm/arch4t.s, gas/arm/arch6zk.s, gas/arm/arm3.s, gas/arm/arm6.s
	* gas/arm/arm7dm.s, gas/arm/bignum1.s, gas/arm/float.s
	* gas/arm/immed.s, gas/arm/iwmmxt.s, gas/arm/offset.s, gas/arm/thumb.s:
	Adjust to work as a dump test.
	* gas/arm/arch4t.d, gas/arm/arch6zk.d, gas/arm/arm3.d, gas/arm/arm6.d
	* gas/arm/arm7dm.d, gas/arm/bignum1.d, gas/arm/float.d
	* gas/arm/immed.d, gas/arm/iwmmxt.d, gas/arm/offset.d, gas/arm/thumb.d:
	New files.

	* gas/arm/armv1-bad.l, gas/arm/armv1-bad.s: Remove tests for
	diagnostics that don't happen in the first pass anymore.

	* gas/arm/iwmmxt-bad.l, gas/arm/r15-bad.l, gas/arm/req.l
	* gas/arm/vfp-bad.l:
	Update expected diagnostics.
	* gas/arm/pic.d: Update expected reloc name.
	* gas/arm/thumbv6.d: CPY no longer appears in disassembly.
	* gas/arm/r15-bad.s: Avoid two-argument mul.
	* gas/arm/req.s: Adjust comments.
	* gas/arm/maverick.d, gas/arm/maverick.s: Avoid inappropriate
	use of PC.

	* gas/arm/macro-1.d, gas/arm/macro1.s
	* gas/arm/t16-bad.l, gas/arm/t16-bad.s
	* gas/arm/tcompat.d, gas/arm/tcompat.s
	* gas/arm/tcompat2.d, gas/arm/tcompat2.s
	* gas/arm/thumb32.d, gas/arm/thumb32.s
	New test pair.

ld/testsuite:
	* ld-arm/mixed-app.d: Adjust expected disassembly a little.
@
text
@d7300 1
a7300 1
  new_fix->tc_fix_data = (PTR) thumb_mode;
a10079 3
  /* The double cast here prevents warnings about converting a pointer
     to an integer of different size.  We know the value is 0, 1, or 2.	 */
  int		 fix_is_thumb = (int) (size_t) fixP->tc_fix_data;
d10098 8
a10105 1
  /* Remember value for emit_reloc.  */
d10108 5
d10448 1
a10448 1
      if (fix_is_thumb)
@


1.203
log
@Make -mlittle-endian switch set the target_big_endian variable to false.
@
text
@d20 1
a20 1
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d29 1
a29 1
#define  NO_RELOC 0
d59 4
a62 4
  symbolS *       proc_start;
  symbolS *       table_entry;
  symbolS *       personality_routine;
  int             personality_index;
d64 2
a65 2
  segT            saved_seg;
  subsegT         saved_subseg;
d68 2
a69 2
  int             opcode_count;
  int             opcode_alloc;
d71 1
a71 1
  offsetT         frame_size;
d75 1
a75 1
  offsetT         pending_offset;
d77 3
a79 3
     hold the reg+offset to use when restoring sp from a frame pointer.  */
  offsetT         fp_offset;
  int             fp_reg;
d81 1
a81 1
  unsigned        fp_used:1;
d83 1
a83 1
  unsigned        sp_restored:1;
d100 1
a100 1
/* Types of processor to assemble for.  */
d110 1
a110 1
#define ARM_CPU_MASK	0x0000000f              /* XXX? */
d117 1
a117 1
#define CPU_DEFAULT 	(ARM_ARCH_V5T)
d119 1
a119 1
#define CPU_DEFAULT 	ARM_ANY
d142 1
a142 2
#define streq(a, b)           (strcmp (a, b) == 0)
#define skip_whitespace(str)  while (*(str) == ' ') ++(str)
d147 2
a148 2
static int uses_apcs_26      = FALSE;
static int atpcs             = FALSE;
d151 1
a151 1
static int pic_code          = FALSE;
a172 29
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "@@";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.  */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant
   from exp in floating point numbers.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456  */
/* or    0d1.2345e12  */

const char FLT_CHARS[] = "rRsSfFdDxXeEpP";

/* Prefix characters that indicate the start of an immediate
   value.  */
#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')

d174 1
a174 1
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
d187 24
a210 4
typedef struct arm_fix
{
  int thumb_mode;
} arm_fix_data;
d214 1
a214 1
  const char *  error;
d216 3
a218 1
  int           size;
d222 2
a223 2
    expressionS              exp;
    int                      pc_rel;
a224 1
};
d226 15
a240 48
struct arm_it inst;

enum asm_shift_index
{
  SHIFT_LSL = 0,
  SHIFT_LSR,
  SHIFT_ASR,
  SHIFT_ROR,
  SHIFT_RRX
};

struct asm_shift_properties
{
  enum asm_shift_index index;
  unsigned long        bit_field;
  unsigned int         allows_0  : 1;
  unsigned int         allows_32 : 1;
};

static const struct asm_shift_properties shift_properties [] =
{
  { SHIFT_LSL, 0,    1, 0},
  { SHIFT_LSR, 0x20, 0, 1},
  { SHIFT_ASR, 0x40, 0, 1},
  { SHIFT_ROR, 0x60, 0, 0},
  { SHIFT_RRX, 0x60, 0, 0}
};

struct asm_shift_name
{
  const char *                        name;
  const struct asm_shift_properties * properties;
};

static const struct asm_shift_name shift_names [] =
{
  { "asl", shift_properties + SHIFT_LSL },
  { "lsl", shift_properties + SHIFT_LSL },
  { "lsr", shift_properties + SHIFT_LSR },
  { "asr", shift_properties + SHIFT_ASR },
  { "ror", shift_properties + SHIFT_ROR },
  { "rrx", shift_properties + SHIFT_RRX },
  { "ASL", shift_properties + SHIFT_LSL },
  { "LSL", shift_properties + SHIFT_LSL },
  { "LSR", shift_properties + SHIFT_LSR },
  { "ASR", shift_properties + SHIFT_ASR },
  { "ROR", shift_properties + SHIFT_ROR },
  { "RRX", shift_properties + SHIFT_RRX }
d243 1
a243 10
/* Any kind of shift is accepted.  */
#define NO_SHIFT_RESTRICT 1
/* The shift operand must be an immediate value, not a register.  */
#define SHIFT_IMMEDIATE	  0
/* The shift must be LSL or ASR and the operand must be an immediate.  */
#define SHIFT_LSL_OR_ASR_IMMEDIATE 2
/* The shift must be ASR and the operand must be an immediate.  */
#define SHIFT_ASR_IMMEDIATE 3
/* The shift must be LSL and the operand must be an immediate.  */
#define SHIFT_LSL_IMMEDIATE 4
d252 1
a252 1
/* Number of littlenums required to hold an extended precision number.  */
a259 4
/* Whether a Co-processor load/store operation accepts write-back forms.  */
#define CP_WB_OK 1
#define CP_NO_WB 0

d265 2
a266 5
#define CP_T_X   0x00008000
#define CP_T_Y   0x00400000
#define CP_T_Pre 0x01000000
#define CP_T_UD  0x00800000
#define CP_T_WB  0x00200000
d268 2
a269 2
#define CONDS_BIT        0x00100000
#define LOAD_BIT         0x00100000
d275 1
a275 1
  const char *  template;
d279 1
a279 22
#define COND_ALWAYS 0xe0000000
#define COND_MASK   0xf0000000

static const struct asm_cond conds[] =
{
  {"eq", 0x00000000},
  {"ne", 0x10000000},
  {"cs", 0x20000000}, {"hs", 0x20000000},
  {"cc", 0x30000000}, {"ul", 0x30000000}, {"lo", 0x30000000},
  {"mi", 0x40000000},
  {"pl", 0x50000000},
  {"vs", 0x60000000},
  {"vc", 0x70000000},
  {"hi", 0x80000000},
  {"ls", 0x90000000},
  {"ge", 0xa0000000},
  {"lt", 0xb0000000},
  {"gt", 0xc0000000},
  {"le", 0xd0000000},
  {"al", 0xe0000000},
  {"nv", 0xf0000000}
};
a283 1
  bfd_boolean cpsr;
d290 5
a294 2
/* How many bits to shift the PSR_xxx bits up by.  */
#define PSR_SHIFT  16
d296 1
a296 6
#define PSR_c   (1 << 0)
#define PSR_x   (1 << 1)
#define PSR_s   (1 << 2)
#define PSR_f   (1 << 3)

static const struct asm_psr psrs[] =
d298 2
a299 171
  {"CPSR",	TRUE,  PSR_c | PSR_f},
  {"CPSR_all",	TRUE,  PSR_c | PSR_f},
  {"SPSR",	FALSE, PSR_c | PSR_f},
  {"SPSR_all",	FALSE, PSR_c | PSR_f},
  {"CPSR_flg",	TRUE,  PSR_f},
  {"CPSR_f",    TRUE,  PSR_f},
  {"SPSR_flg",	FALSE, PSR_f},
  {"SPSR_f",    FALSE, PSR_f},
  {"CPSR_c",	TRUE,  PSR_c},
  {"CPSR_ctl",	TRUE,  PSR_c},
  {"SPSR_c",	FALSE, PSR_c},
  {"SPSR_ctl",	FALSE, PSR_c},
  {"CPSR_x",    TRUE,  PSR_x},
  {"CPSR_s",    TRUE,  PSR_s},
  {"SPSR_x",    FALSE, PSR_x},
  {"SPSR_s",    FALSE, PSR_s},
  /* Combinations of flags.  */
  {"CPSR_fs",	TRUE, PSR_f | PSR_s},
  {"CPSR_fx",	TRUE, PSR_f | PSR_x},
  {"CPSR_fc",	TRUE, PSR_f | PSR_c},
  {"CPSR_sf",	TRUE, PSR_s | PSR_f},
  {"CPSR_sx",	TRUE, PSR_s | PSR_x},
  {"CPSR_sc",	TRUE, PSR_s | PSR_c},
  {"CPSR_xf",	TRUE, PSR_x | PSR_f},
  {"CPSR_xs",	TRUE, PSR_x | PSR_s},
  {"CPSR_xc",	TRUE, PSR_x | PSR_c},
  {"CPSR_cf",	TRUE, PSR_c | PSR_f},
  {"CPSR_cs",	TRUE, PSR_c | PSR_s},
  {"CPSR_cx",	TRUE, PSR_c | PSR_x},
  {"CPSR_fsx",	TRUE, PSR_f | PSR_s | PSR_x},
  {"CPSR_fsc",	TRUE, PSR_f | PSR_s | PSR_c},
  {"CPSR_fxs",	TRUE, PSR_f | PSR_x | PSR_s},
  {"CPSR_fxc",	TRUE, PSR_f | PSR_x | PSR_c},
  {"CPSR_fcs",	TRUE, PSR_f | PSR_c | PSR_s},
  {"CPSR_fcx",	TRUE, PSR_f | PSR_c | PSR_x},
  {"CPSR_sfx",	TRUE, PSR_s | PSR_f | PSR_x},
  {"CPSR_sfc",	TRUE, PSR_s | PSR_f | PSR_c},
  {"CPSR_sxf",	TRUE, PSR_s | PSR_x | PSR_f},
  {"CPSR_sxc",	TRUE, PSR_s | PSR_x | PSR_c},
  {"CPSR_scf",	TRUE, PSR_s | PSR_c | PSR_f},
  {"CPSR_scx",	TRUE, PSR_s | PSR_c | PSR_x},
  {"CPSR_xfs",	TRUE, PSR_x | PSR_f | PSR_s},
  {"CPSR_xfc",	TRUE, PSR_x | PSR_f | PSR_c},
  {"CPSR_xsf",	TRUE, PSR_x | PSR_s | PSR_f},
  {"CPSR_xsc",	TRUE, PSR_x | PSR_s | PSR_c},
  {"CPSR_xcf",	TRUE, PSR_x | PSR_c | PSR_f},
  {"CPSR_xcs",	TRUE, PSR_x | PSR_c | PSR_s},
  {"CPSR_cfs",	TRUE, PSR_c | PSR_f | PSR_s},
  {"CPSR_cfx",	TRUE, PSR_c | PSR_f | PSR_x},
  {"CPSR_csf",	TRUE, PSR_c | PSR_s | PSR_f},
  {"CPSR_csx",	TRUE, PSR_c | PSR_s | PSR_x},
  {"CPSR_cxf",	TRUE, PSR_c | PSR_x | PSR_f},
  {"CPSR_cxs",	TRUE, PSR_c | PSR_x | PSR_s},
  {"CPSR_fsxc",	TRUE, PSR_f | PSR_s | PSR_x | PSR_c},
  {"CPSR_fscx",	TRUE, PSR_f | PSR_s | PSR_c | PSR_x},
  {"CPSR_fxsc",	TRUE, PSR_f | PSR_x | PSR_s | PSR_c},
  {"CPSR_fxcs",	TRUE, PSR_f | PSR_x | PSR_c | PSR_s},
  {"CPSR_fcsx",	TRUE, PSR_f | PSR_c | PSR_s | PSR_x},
  {"CPSR_fcxs",	TRUE, PSR_f | PSR_c | PSR_x | PSR_s},
  {"CPSR_sfxc",	TRUE, PSR_s | PSR_f | PSR_x | PSR_c},
  {"CPSR_sfcx",	TRUE, PSR_s | PSR_f | PSR_c | PSR_x},
  {"CPSR_sxfc",	TRUE, PSR_s | PSR_x | PSR_f | PSR_c},
  {"CPSR_sxcf",	TRUE, PSR_s | PSR_x | PSR_c | PSR_f},
  {"CPSR_scfx",	TRUE, PSR_s | PSR_c | PSR_f | PSR_x},
  {"CPSR_scxf",	TRUE, PSR_s | PSR_c | PSR_x | PSR_f},
  {"CPSR_xfsc",	TRUE, PSR_x | PSR_f | PSR_s | PSR_c},
  {"CPSR_xfcs",	TRUE, PSR_x | PSR_f | PSR_c | PSR_s},
  {"CPSR_xsfc",	TRUE, PSR_x | PSR_s | PSR_f | PSR_c},
  {"CPSR_xscf",	TRUE, PSR_x | PSR_s | PSR_c | PSR_f},
  {"CPSR_xcfs",	TRUE, PSR_x | PSR_c | PSR_f | PSR_s},
  {"CPSR_xcsf",	TRUE, PSR_x | PSR_c | PSR_s | PSR_f},
  {"CPSR_cfsx",	TRUE, PSR_c | PSR_f | PSR_s | PSR_x},
  {"CPSR_cfxs",	TRUE, PSR_c | PSR_f | PSR_x | PSR_s},
  {"CPSR_csfx",	TRUE, PSR_c | PSR_s | PSR_f | PSR_x},
  {"CPSR_csxf",	TRUE, PSR_c | PSR_s | PSR_x | PSR_f},
  {"CPSR_cxfs",	TRUE, PSR_c | PSR_x | PSR_f | PSR_s},
  {"CPSR_cxsf",	TRUE, PSR_c | PSR_x | PSR_s | PSR_f},
  {"SPSR_fs",	FALSE, PSR_f | PSR_s},
  {"SPSR_fx",	FALSE, PSR_f | PSR_x},
  {"SPSR_fc",	FALSE, PSR_f | PSR_c},
  {"SPSR_sf",	FALSE, PSR_s | PSR_f},
  {"SPSR_sx",	FALSE, PSR_s | PSR_x},
  {"SPSR_sc",	FALSE, PSR_s | PSR_c},
  {"SPSR_xf",	FALSE, PSR_x | PSR_f},
  {"SPSR_xs",	FALSE, PSR_x | PSR_s},
  {"SPSR_xc",	FALSE, PSR_x | PSR_c},
  {"SPSR_cf",	FALSE, PSR_c | PSR_f},
  {"SPSR_cs",	FALSE, PSR_c | PSR_s},
  {"SPSR_cx",	FALSE, PSR_c | PSR_x},
  {"SPSR_fsx",	FALSE, PSR_f | PSR_s | PSR_x},
  {"SPSR_fsc",	FALSE, PSR_f | PSR_s | PSR_c},
  {"SPSR_fxs",	FALSE, PSR_f | PSR_x | PSR_s},
  {"SPSR_fxc",	FALSE, PSR_f | PSR_x | PSR_c},
  {"SPSR_fcs",	FALSE, PSR_f | PSR_c | PSR_s},
  {"SPSR_fcx",	FALSE, PSR_f | PSR_c | PSR_x},
  {"SPSR_sfx",	FALSE, PSR_s | PSR_f | PSR_x},
  {"SPSR_sfc",	FALSE, PSR_s | PSR_f | PSR_c},
  {"SPSR_sxf",	FALSE, PSR_s | PSR_x | PSR_f},
  {"SPSR_sxc",	FALSE, PSR_s | PSR_x | PSR_c},
  {"SPSR_scf",	FALSE, PSR_s | PSR_c | PSR_f},
  {"SPSR_scx",	FALSE, PSR_s | PSR_c | PSR_x},
  {"SPSR_xfs",	FALSE, PSR_x | PSR_f | PSR_s},
  {"SPSR_xfc",	FALSE, PSR_x | PSR_f | PSR_c},
  {"SPSR_xsf",	FALSE, PSR_x | PSR_s | PSR_f},
  {"SPSR_xsc",	FALSE, PSR_x | PSR_s | PSR_c},
  {"SPSR_xcf",	FALSE, PSR_x | PSR_c | PSR_f},
  {"SPSR_xcs",	FALSE, PSR_x | PSR_c | PSR_s},
  {"SPSR_cfs",	FALSE, PSR_c | PSR_f | PSR_s},
  {"SPSR_cfx",	FALSE, PSR_c | PSR_f | PSR_x},
  {"SPSR_csf",	FALSE, PSR_c | PSR_s | PSR_f},
  {"SPSR_csx",	FALSE, PSR_c | PSR_s | PSR_x},
  {"SPSR_cxf",	FALSE, PSR_c | PSR_x | PSR_f},
  {"SPSR_cxs",	FALSE, PSR_c | PSR_x | PSR_s},
  {"SPSR_fsxc",	FALSE, PSR_f | PSR_s | PSR_x | PSR_c},
  {"SPSR_fscx",	FALSE, PSR_f | PSR_s | PSR_c | PSR_x},
  {"SPSR_fxsc",	FALSE, PSR_f | PSR_x | PSR_s | PSR_c},
  {"SPSR_fxcs",	FALSE, PSR_f | PSR_x | PSR_c | PSR_s},
  {"SPSR_fcsx",	FALSE, PSR_f | PSR_c | PSR_s | PSR_x},
  {"SPSR_fcxs",	FALSE, PSR_f | PSR_c | PSR_x | PSR_s},
  {"SPSR_sfxc",	FALSE, PSR_s | PSR_f | PSR_x | PSR_c},
  {"SPSR_sfcx",	FALSE, PSR_s | PSR_f | PSR_c | PSR_x},
  {"SPSR_sxfc",	FALSE, PSR_s | PSR_x | PSR_f | PSR_c},
  {"SPSR_sxcf",	FALSE, PSR_s | PSR_x | PSR_c | PSR_f},
  {"SPSR_scfx",	FALSE, PSR_s | PSR_c | PSR_f | PSR_x},
  {"SPSR_scxf",	FALSE, PSR_s | PSR_c | PSR_x | PSR_f},
  {"SPSR_xfsc",	FALSE, PSR_x | PSR_f | PSR_s | PSR_c},
  {"SPSR_xfcs",	FALSE, PSR_x | PSR_f | PSR_c | PSR_s},
  {"SPSR_xsfc",	FALSE, PSR_x | PSR_s | PSR_f | PSR_c},
  {"SPSR_xscf",	FALSE, PSR_x | PSR_s | PSR_c | PSR_f},
  {"SPSR_xcfs",	FALSE, PSR_x | PSR_c | PSR_f | PSR_s},
  {"SPSR_xcsf",	FALSE, PSR_x | PSR_c | PSR_s | PSR_f},
  {"SPSR_cfsx",	FALSE, PSR_c | PSR_f | PSR_s | PSR_x},
  {"SPSR_cfxs",	FALSE, PSR_c | PSR_f | PSR_x | PSR_s},
  {"SPSR_csfx",	FALSE, PSR_c | PSR_s | PSR_f | PSR_x},
  {"SPSR_csxf",	FALSE, PSR_c | PSR_s | PSR_x | PSR_f},
  {"SPSR_cxfs",	FALSE, PSR_c | PSR_x | PSR_f | PSR_s},
  {"SPSR_cxsf",	FALSE, PSR_c | PSR_x | PSR_s | PSR_f},
};

enum wreg_type
  {
    IWMMXT_REG_WR = 0,
    IWMMXT_REG_WC = 1,
    IWMMXT_REG_WR_OR_WC = 2,
    IWMMXT_REG_WCG
  };

enum iwmmxt_insn_type
{
  check_rd,
  check_wr,
  check_wrwr,
  check_wrwrwr,
  check_wrwrwcg,
  check_tbcst,
  check_tmovmsk,
  check_tmia,
  check_tmcrr,
  check_tmrrc,
  check_tmcr,
  check_tmrc,
  check_tinsr,
  check_textrc,
  check_waligni,
  check_textrm,
  check_wshufh
};

enum vfp_dp_reg_pos
{
  VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
d312 3
a314 8
/* VFP system registers.  */
struct vfp_reg
{
  const char *name;
  unsigned long regno;
};

static const struct vfp_reg vfp_regs[] =
d316 17
a332 6
  {"fpsid", 0x00000000},
  {"FPSID", 0x00000000},
  {"fpscr", 0x00010000},
  {"FPSCR", 0x00010000},
  {"fpexc", 0x00080000},
  {"FPEXC", 0x00080000}
d338 26
a363 3
  const char * name;
  int          number;
  bfd_boolean  builtin;
d367 2
a368 2
#define REG_SP  13
#define REG_LR  14
a370 210
#define wr_register(reg)  ((reg ^ WR_PREFIX) >= 0 && (reg ^ WR_PREFIX) <= 15)
#define wc_register(reg)  ((reg ^ WC_PREFIX) >= 0 && (reg ^ WC_PREFIX) <= 15)
#define wcg_register(reg) ((reg ^ WC_PREFIX) >= 8 && (reg ^ WC_PREFIX) <= 11)

/* These are the standard names.  Users can add aliases with .req.
   and delete them with .unreq.  */

/* Integer Register Numbers.  */
static const struct reg_entry rn_table[] =
{
  {"r0",  0, TRUE},  {"r1",  1, TRUE},      {"r2",  2, TRUE},      {"r3",  3, TRUE},
  {"r4",  4, TRUE},  {"r5",  5, TRUE},      {"r6",  6, TRUE},      {"r7",  7, TRUE},
  {"r8",  8, TRUE},  {"r9",  9, TRUE},      {"r10", 10, TRUE},     {"r11", 11, TRUE},
  {"r12", 12, TRUE}, {"r13", REG_SP, TRUE}, {"r14", REG_LR, TRUE}, {"r15", REG_PC, TRUE},
  /* ATPCS Synonyms.  */
  {"a1",  0, TRUE},  {"a2",  1, TRUE},      {"a3",  2, TRUE},      {"a4",  3, TRUE},
  {"v1",  4, TRUE},  {"v2",  5, TRUE},      {"v3",  6, TRUE},      {"v4",  7, TRUE},
  {"v5",  8, TRUE},  {"v6",  9, TRUE},      {"v7",  10, TRUE},     {"v8",  11, TRUE},
  /* Well-known aliases.  */
  {"wr",  7, TRUE},  {"sb",  9, TRUE},      {"sl",  10, TRUE},     {"fp",  11, TRUE},
  {"ip",  12, TRUE}, {"sp",  REG_SP, TRUE}, {"lr",  REG_LR, TRUE}, {"pc",  REG_PC, TRUE},
  {NULL, 0, TRUE}
};

#define WR_PREFIX 0x200
#define WC_PREFIX 0x400

static const struct reg_entry iwmmxt_table[] =
{
  /* Intel Wireless MMX technology register names.  */
  {  "wr0", 0x0 | WR_PREFIX, TRUE},   {"wr1", 0x1 | WR_PREFIX, TRUE},
  {  "wr2", 0x2 | WR_PREFIX, TRUE},   {"wr3", 0x3 | WR_PREFIX, TRUE},
  {  "wr4", 0x4 | WR_PREFIX, TRUE},   {"wr5", 0x5 | WR_PREFIX, TRUE},
  {  "wr6", 0x6 | WR_PREFIX, TRUE},   {"wr7", 0x7 | WR_PREFIX, TRUE},
  {  "wr8", 0x8 | WR_PREFIX, TRUE},   {"wr9", 0x9 | WR_PREFIX, TRUE},
  { "wr10", 0xa | WR_PREFIX, TRUE},  {"wr11", 0xb | WR_PREFIX, TRUE},
  { "wr12", 0xc | WR_PREFIX, TRUE},  {"wr13", 0xd | WR_PREFIX, TRUE},
  { "wr14", 0xe | WR_PREFIX, TRUE},  {"wr15", 0xf | WR_PREFIX, TRUE},
  { "wcid", 0x0 | WC_PREFIX, TRUE},  {"wcon", 0x1 | WC_PREFIX, TRUE},
  {"wcssf", 0x2 | WC_PREFIX, TRUE}, {"wcasf", 0x3 | WC_PREFIX, TRUE},
  {"wcgr0", 0x8 | WC_PREFIX, TRUE}, {"wcgr1", 0x9 | WC_PREFIX, TRUE},
  {"wcgr2", 0xa | WC_PREFIX, TRUE}, {"wcgr3", 0xb | WC_PREFIX, TRUE},

  {  "wR0", 0x0 | WR_PREFIX, TRUE},   {"wR1", 0x1 | WR_PREFIX, TRUE},
  {  "wR2", 0x2 | WR_PREFIX, TRUE},   {"wR3", 0x3 | WR_PREFIX, TRUE},
  {  "wR4", 0x4 | WR_PREFIX, TRUE},   {"wR5", 0x5 | WR_PREFIX, TRUE},
  {  "wR6", 0x6 | WR_PREFIX, TRUE},   {"wR7", 0x7 | WR_PREFIX, TRUE},
  {  "wR8", 0x8 | WR_PREFIX, TRUE},   {"wR9", 0x9 | WR_PREFIX, TRUE},
  { "wR10", 0xa | WR_PREFIX, TRUE},  {"wR11", 0xb | WR_PREFIX, TRUE},
  { "wR12", 0xc | WR_PREFIX, TRUE},  {"wR13", 0xd | WR_PREFIX, TRUE},
  { "wR14", 0xe | WR_PREFIX, TRUE},  {"wR15", 0xf | WR_PREFIX, TRUE},
  { "wCID", 0x0 | WC_PREFIX, TRUE},  {"wCon", 0x1 | WC_PREFIX, TRUE},
  {"wCSSF", 0x2 | WC_PREFIX, TRUE}, {"wCASF", 0x3 | WC_PREFIX, TRUE},
  {"wCGR0", 0x8 | WC_PREFIX, TRUE}, {"wCGR1", 0x9 | WC_PREFIX, TRUE},
  {"wCGR2", 0xa | WC_PREFIX, TRUE}, {"wCGR3", 0xb | WC_PREFIX, TRUE},
  {NULL, 0, TRUE}
};

/* Co-processor Numbers.  */
static const struct reg_entry cp_table[] =
{
  {"p0",  0, TRUE},  {"p1",  1, TRUE},  {"p2",  2, TRUE},  {"p3", 3, TRUE},
  {"p4",  4, TRUE},  {"p5",  5, TRUE},  {"p6",  6, TRUE},  {"p7", 7, TRUE},
  {"p8",  8, TRUE},  {"p9",  9, TRUE},  {"p10", 10, TRUE}, {"p11", 11, TRUE},
  {"p12", 12, TRUE}, {"p13", 13, TRUE}, {"p14", 14, TRUE}, {"p15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* Co-processor Register Numbers.  */
static const struct reg_entry cn_table[] =
{
  {"c0",   0, TRUE},  {"c1",   1, TRUE},  {"c2",   2, TRUE},  {"c3",   3, TRUE},
  {"c4",   4, TRUE},  {"c5",   5, TRUE},  {"c6",   6, TRUE},  {"c7",   7, TRUE},
  {"c8",   8, TRUE},  {"c9",   9, TRUE},  {"c10",  10, TRUE}, {"c11",  11, TRUE},
  {"c12",  12, TRUE}, {"c13",  13, TRUE}, {"c14",  14, TRUE}, {"c15",  15, TRUE},
  /* Not really valid, but kept for back-wards compatibility.  */
  {"cr0",  0, TRUE},  {"cr1",  1, TRUE},  {"cr2",  2, TRUE},  {"cr3",  3, TRUE},
  {"cr4",  4, TRUE},  {"cr5",  5, TRUE},  {"cr6",  6, TRUE},  {"cr7",  7, TRUE},
  {"cr8",  8, TRUE},  {"cr9",  9, TRUE},  {"cr10", 10, TRUE}, {"cr11", 11, TRUE},
  {"cr12", 12, TRUE}, {"cr13", 13, TRUE}, {"cr14", 14, TRUE}, {"cr15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* FPA Registers.  */
static const struct reg_entry fn_table[] =
{
  {"f0", 0, TRUE},   {"f1", 1, TRUE},   {"f2", 2, TRUE},   {"f3", 3, TRUE},
  {"f4", 4, TRUE},   {"f5", 5, TRUE},   {"f6", 6, TRUE},   {"f7", 7, TRUE},
  {NULL, 0, TRUE}
};

/* VFP SP Registers.  */
static const struct reg_entry sn_table[] =
{
  {"s0",  0, TRUE},  {"s1",  1, TRUE},  {"s2",  2, TRUE},  {"s3", 3, TRUE},
  {"s4",  4, TRUE},  {"s5",  5, TRUE},  {"s6",  6, TRUE},  {"s7", 7, TRUE},
  {"s8",  8, TRUE},  {"s9",  9, TRUE},  {"s10", 10, TRUE}, {"s11", 11, TRUE},
  {"s12", 12, TRUE}, {"s13", 13, TRUE}, {"s14", 14, TRUE}, {"s15", 15, TRUE},
  {"s16", 16, TRUE}, {"s17", 17, TRUE}, {"s18", 18, TRUE}, {"s19", 19, TRUE},
  {"s20", 20, TRUE}, {"s21", 21, TRUE}, {"s22", 22, TRUE}, {"s23", 23, TRUE},
  {"s24", 24, TRUE}, {"s25", 25, TRUE}, {"s26", 26, TRUE}, {"s27", 27, TRUE},
  {"s28", 28, TRUE}, {"s29", 29, TRUE}, {"s30", 30, TRUE}, {"s31", 31, TRUE},
  {NULL, 0, TRUE}
};

/* VFP DP Registers.  */
static const struct reg_entry dn_table[] =
{
  {"d0",  0, TRUE},  {"d1",  1, TRUE},  {"d2",  2, TRUE},  {"d3", 3, TRUE},
  {"d4",  4, TRUE},  {"d5",  5, TRUE},  {"d6",  6, TRUE},  {"d7", 7, TRUE},
  {"d8",  8, TRUE},  {"d9",  9, TRUE},  {"d10", 10, TRUE}, {"d11", 11, TRUE},
  {"d12", 12, TRUE}, {"d13", 13, TRUE}, {"d14", 14, TRUE}, {"d15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* Maverick DSP coprocessor registers.  */
static const struct reg_entry mav_mvf_table[] =
{
  {"mvf0",  0, TRUE},  {"mvf1",  1, TRUE},  {"mvf2",  2, TRUE},  {"mvf3",  3, TRUE},
  {"mvf4",  4, TRUE},  {"mvf5",  5, TRUE},  {"mvf6",  6, TRUE},  {"mvf7",  7, TRUE},
  {"mvf8",  8, TRUE},  {"mvf9",  9, TRUE},  {"mvf10", 10, TRUE}, {"mvf11", 11, TRUE},
  {"mvf12", 12, TRUE}, {"mvf13", 13, TRUE}, {"mvf14", 14, TRUE}, {"mvf15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvd_table[] =
{
  {"mvd0",  0, TRUE},  {"mvd1",  1, TRUE},  {"mvd2",  2, TRUE},  {"mvd3",  3, TRUE},
  {"mvd4",  4, TRUE},  {"mvd5",  5, TRUE},  {"mvd6",  6, TRUE},  {"mvd7",  7, TRUE},
  {"mvd8",  8, TRUE},  {"mvd9",  9, TRUE},  {"mvd10", 10, TRUE}, {"mvd11", 11, TRUE},
  {"mvd12", 12, TRUE}, {"mvd13", 13, TRUE}, {"mvd14", 14, TRUE}, {"mvd15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvfx_table[] =
{
  {"mvfx0",  0, TRUE},  {"mvfx1",  1, TRUE},  {"mvfx2",  2, TRUE},  {"mvfx3",  3, TRUE},
  {"mvfx4",  4, TRUE},  {"mvfx5",  5, TRUE},  {"mvfx6",  6, TRUE},  {"mvfx7",  7, TRUE},
  {"mvfx8",  8, TRUE},  {"mvfx9",  9, TRUE},  {"mvfx10", 10, TRUE}, {"mvfx11", 11, TRUE},
  {"mvfx12", 12, TRUE}, {"mvfx13", 13, TRUE}, {"mvfx14", 14, TRUE}, {"mvfx15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvdx_table[] =
{
  {"mvdx0",  0, TRUE},  {"mvdx1",  1, TRUE},  {"mvdx2",  2, TRUE},  {"mvdx3",  3, TRUE},
  {"mvdx4",  4, TRUE},  {"mvdx5",  5, TRUE},  {"mvdx6",  6, TRUE},  {"mvdx7",  7, TRUE},
  {"mvdx8",  8, TRUE},  {"mvdx9",  9, TRUE},  {"mvdx10", 10, TRUE}, {"mvdx11", 11, TRUE},
  {"mvdx12", 12, TRUE}, {"mvdx13", 13, TRUE}, {"mvdx14", 14, TRUE}, {"mvdx15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvax_table[] =
{
  {"mvax0", 0, TRUE}, {"mvax1", 1, TRUE}, {"mvax2", 2, TRUE}, {"mvax3", 3, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_dspsc_table[] =
{
  {"dspsc", 0, TRUE},
  {NULL, 0, TRUE}
};

struct reg_map
{
  const struct reg_entry * names;
  int                      max_regno;
  struct hash_control *    htab;
  const char *             expected;
};

struct reg_map all_reg_maps[] =
{
  {rn_table,        15, NULL, N_("ARM register expected")},
  {cp_table,        15, NULL, N_("bad or missing co-processor number")},
  {cn_table,        15, NULL, N_("co-processor register expected")},
  {fn_table,         7, NULL, N_("FPA register expected")},
  {sn_table,	    31, NULL, N_("VFP single precision register expected")},
  {dn_table,	    15, NULL, N_("VFP double precision register expected")},
  {mav_mvf_table,   15, NULL, N_("Maverick MVF register expected")},
  {mav_mvd_table,   15, NULL, N_("Maverick MVD register expected")},
  {mav_mvfx_table,  15, NULL, N_("Maverick MVFX register expected")},
  {mav_mvdx_table,  15, NULL, N_("Maverick MVDX register expected")},
  {mav_mvax_table,   3, NULL, N_("Maverick MVAX register expected")},
  {mav_dspsc_table,  0, NULL, N_("Maverick DSPSC register expected")},
  {iwmmxt_table,    23, NULL, N_("Intel Wireless MMX technology register expected")},
};

/* Enumeration matching entries in table above.  */
enum arm_reg_type
{
  REG_TYPE_RN = 0,
#define REG_TYPE_FIRST REG_TYPE_RN
  REG_TYPE_CP = 1,
  REG_TYPE_CN = 2,
  REG_TYPE_FN = 3,
  REG_TYPE_SN = 4,
  REG_TYPE_DN = 5,
  REG_TYPE_MVF = 6,
  REG_TYPE_MVD = 7,
  REG_TYPE_MVFX = 8,
  REG_TYPE_MVDX = 9,
  REG_TYPE_MVAX = 10,
  REG_TYPE_DSPSC = 11,
  REG_TYPE_IWMMXT = 12,

  REG_TYPE_MAX = 13
};

d373 1
a373 19
#define INSN_SIZE       4

/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
#define MAV_MODE1	0x100c

/* "INSN<cond> X,Y" where X:bit16, Y:bit12.  */
#define MAV_MODE2	0x0c10

/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
#define MAV_MODE3	0x100c

/* "INSN<cond> X,Y,Z" where X:16, Y:0, Z:12.  */
#define MAV_MODE4	0x0c0010

/* "INSN<cond> X,Y,Z" where X:12, Y:16, Z:0.  */
#define MAV_MODE5	0x00100c

/* "INSN<cond> W,X,Y,Z" where W:5, X:12, Y:16, Z:0.  */
#define MAV_MODE6	0x00100c05
d378 7
a384 1
  const char * template;
d387 1
a387 1
  unsigned long value;
d389 2
a390 3
  /* Offset into the template where the condition code (if any) will be.
     If zero, then the instruction is never conditional.  */
  unsigned cond_offset;
d393 2
a394 1
  unsigned long variant;
d396 5
a400 2
  /* Function to call to parse args.  */
  void (* parms) (char *);
d406 1
a406 1
#define HWOFFSET_IMM    0x00400000
d457 2
a458 1
#define T_OPCODE_LSR_R  0x40c0
a490 18
#define THUMB_REG_LO	0x1
#define THUMB_REG_HI	0x2
#define THUMB_REG_ANY	0x3

#define THUMB_H1	0x0080
#define THUMB_H2	0x0040

#define THUMB_ASR 0
#define THUMB_LSL 1
#define THUMB_LSR 2

#define THUMB_MOVE 0
#define THUMB_COMPARE 1
#define THUMB_CPY 2

#define THUMB_LOAD 0
#define THUMB_STORE 1

d492 1
d494 13
a506 32
/* These three are used for immediate shifts, do not alter.  */
#define THUMB_WORD 2
#define THUMB_HALFWORD 1
#define THUMB_BYTE 0

struct thumb_opcode
{
  /* Basic string to match.  */
  const char * template;

  /* Basic instruction code.  */
  unsigned long value;

  int size;

  /* Which CPU variants this exists for.  */
  unsigned long variant;

  /* Function to call to parse args.  */
  void (* parms) (char *);
};

#define BAD_ARGS 	_("bad arguments to instruction")
#define BAD_PC 		_("r15 not allowed here")
#define BAD_COND 	_("instruction is not conditional")
#define ERR_NO_ACCUM	_("acc0 expected")

static struct hash_control * arm_ops_hsh   = NULL;
static struct hash_control * arm_tops_hsh  = NULL;
static struct hash_control * arm_cond_hsh  = NULL;
static struct hash_control * arm_shift_hsh = NULL;
static struct hash_control * arm_psr_hsh   = NULL;
d515 1
a515 1
              <insn>
a520 4
/* Literal Pool stuff.  */

#define MAX_LITERAL_POOL_SIZE 1024

d524 1
d527 6
a532 6
  expressionS    literals [MAX_LITERAL_POOL_SIZE];
  unsigned int   next_free_entry;
  unsigned int   id;
  symbolS *      symbol;
  segT           section;
  subsegT        sub_section;
d538 21
d560 3
a562 4
static literal_pool *
find_literal_pool (void)
{
  literal_pool * pool;
d564 1
a564 6
  for (pool = list_of_pools; pool != NULL; pool = pool->next)
    {
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
    }
d566 3
a568 2
  return pool;
}
d570 1
a570 6
static literal_pool *
find_or_make_literal_pool (void)
{
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;
d572 1
a572 1
  pool = find_literal_pool ();
d574 4
a577 1
  if (pool == NULL)
d579 9
a587 4
      /* Create a new pool.  */
      pool = xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;
d589 1
a589 5
      pool->next_free_entry = 0;
      pool->section         = now_seg;
      pool->sub_section     = now_subseg;
      pool->next            = list_of_pools;
      pool->symbol          = NULL;
d591 5
a595 3
      /* Add it to the list.  */
      list_of_pools = pool;
    }
d597 1
a597 2
  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
d599 3
a601 3
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
d604 1
a604 2
  /* Done.  */
  return pool;
d607 6
a612 2
/* Add the literal in the global 'inst'
   structure to the relevent literal pool.  */
d615 1
a615 1
add_to_lit_pool (void)
d617 2
a618 15
  literal_pool * pool;
  unsigned int entry;

  pool = find_or_make_literal_pool ();

  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    {
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
	break;
d620 3
a622 10
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
          && (inst.reloc.exp.X_op == O_symbol)
          && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
          && (pool->literals[entry].X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
          && (pool->literals[entry].X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
        break;
    }
d624 1
a624 2
  /* Do we need to create a new entry?  */
  if (entry == pool->next_free_entry)
d626 3
a628 1
      if (entry >= MAX_LITERAL_POOL_SIZE)
d630 1
a630 1
	  inst.error = _("literal pool overflow");
d633 26
d660 11
a670 2
      pool->literals[entry] = inst.reloc.exp;
      pool->next_free_entry += 1;
d672 1
d674 14
a687 3
  inst.reloc.exp.X_op         = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4 - 8;
  inst.reloc.exp.X_add_symbol = pool->symbol;
d689 3
a691 1
  return SUCCESS;
d694 13
a706 2
/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */
d708 2
a709 6
static void
symbol_locate (symbolS *    symbolP,
	       const char * name,	/* It is copied, the caller can modify.  */
	       segT         segment,	/* Segment identifier (SEG_<something>).  */
	       valueT       valu,	/* Symbol value.  */
	       fragS *      frag)	/* Associated fragment.  */
d711 25
a735 2
  unsigned int name_length;
  char * preserved_copy_of_name;
d737 4
a740 3
  name_length = strlen (name) + 1;   /* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = obstack_finish (&notes);
d742 4
a745 4
#ifdef tc_canonicalize_symbol_name
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
#endif
d747 4
a750 1
  S_SET_NAME (symbolP, preserved_copy_of_name);
d752 26
a777 3
  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);
d779 2
a780 1
  symbol_set_frag (symbolP, frag);
d782 8
a789 3
  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;
d791 1
a791 3
    if (symbol_table_frozen)
      abort ();
  }
d793 9
a801 1
  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);
d803 5
a807 1
  obj_symbol_new_hook (symbolP);
d809 9
a817 2
#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
d820 1
a820 4
#ifdef DEBUG_SYMS
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS  */
}
d822 4
a825 2
/* Check that an immediate is valid.
   If so, convert it to the right format.  */
d827 2
a828 2
static unsigned int
validate_immediate (unsigned int val)
d830 21
a850 2
  unsigned int a;
  unsigned int i;
d852 1
a852 1
#define rotate_left(v, n) (v << n | v >> (32 - n))
d854 2
a855 3
  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */
d857 2
a858 1
  return FAIL;
d861 2
a862 3
/* Check to see if an immediate can be computed as two separate immediate
   values, added together.  We already know that this value cannot be
   computed by just one ARM instruction.  */
d864 2
a865 3
static unsigned int
validate_immediate_twopart (unsigned int   val,
			    unsigned int * highpart)
d867 17
a883 2
  unsigned int a;
  unsigned int i;
d885 2
a886 2
  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
d888 11
a898 17
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;
	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    assert (a & 0xff000000);
	    * highpart = (a >> 24) | ((i + 8) << 7);
	  }
d900 3
a902 2
	return (a & 0xff) | (i << 7);
      }
d904 1
d908 3
a910 2
static int
validate_offset_imm (unsigned int val, int hwse)
d912 3
a914 4
  if ((hwse && val > 255) || val > 4095)
    return FAIL;
  return val;
}
d916 4
a919 6

#ifdef OBJ_ELF
/* This code is to handle mapping symbols as defined in the ARM ELF spec.
   (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).
   Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),
   and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */
d921 4
a924 1
static enum mstate mapstate = MAP_UNDEFINED;
d926 4
a929 6
static void
mapping_state (enum mstate state)
{
  symbolS * symbolP;
  const char * symname;
  int type;
d931 5
a935 4
  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;
d937 3
a939 1
  mapstate = state;
d941 5
a945 19
  switch (state)
    {
    case MAP_DATA:
      symname = "$d";
      type = BSF_NO_FLAGS;
      break;
    case MAP_ARM:
      symname = "$a";
      type = BSF_NO_FLAGS;
      break;
    case MAP_THUMB:
      symname = "$t";
      type = BSF_NO_FLAGS;
      break;
    case MAP_UNDEFINED:
      return;
    default:
      abort ();
    }
d947 11
a957 1
  seg_info (now_seg)->tc_segment_info_data.mapstate = state;
d959 5
a963 3
  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (symbolP);
  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;
d965 6
a970 7
  switch (state)
    {
    case MAP_ARM:
      THUMB_SET_FUNC (symbolP, 0);
      ARM_SET_THUMB (symbolP, 0);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
d972 9
a980 5
    case MAP_THUMB:
      THUMB_SET_FUNC (symbolP, 1);
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
d982 2
a983 5
    case MAP_DATA:
    default:
      return;
    }
}
d985 8
a992 1
/* When we change sections we need to issue a new mapping symbol.  */
d994 3
a996 5
void
arm_elf_change_section (void)
{
  flagword flags;
  segment_info_type *seginfo;
d998 6
a1003 4
  /* Link an unlinked unwind index table section to the .text section.  */
  if (elf_section_type (now_seg) == SHT_ARM_EXIDX
      && elf_linked_to_section (now_seg) == NULL)
    elf_linked_to_section (now_seg) = text_section;
d1005 9
a1013 2
  if (!SEG_NORMAL (now_seg))
    return;
d1015 5
a1019 1
  flags = bfd_get_section_flags (stdoutput, now_seg);
d1021 7
a1027 3
  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;
d1029 2
a1030 3
  seginfo = seg_info (now_seg);
  mapstate = seginfo->tc_segment_info_data.mapstate;
  marked_pr_dependency = seginfo->tc_segment_info_data.marked_pr_dependency;
d1033 3
a1035 14
int
arm_elf_section_type (const char * str, size_t len)
{
  if (len == 5 && strncmp (str, "exidx", 5) == 0)
    return SHT_ARM_EXIDX;

  return -1;
}
#else
#define mapping_state(a)
#endif /* OBJ_ELF */

/* arm_reg_parse () := if it looks like a register, return its token and
   advance the pointer.  */
d1038 1
a1038 1
arm_reg_parse (char ** ccp, struct hash_control * htab)
d1040 8
a1047 4
  char * start = * ccp;
  char   c;
  char * p;
  struct reg_entry * reg;
d1049 1
a1049 12
#ifdef REGISTER_PREFIX
  if (*start != REGISTER_PREFIX)
    return FAIL;
  p = start + 1;
#else
  p = start;
#ifdef OPTIONAL_REGISTER_PREFIX
  if (*p == OPTIONAL_REGISTER_PREFIX)
    p++, start++;
#endif
#endif
  if (!ISALPHA (*p) || !is_name_beginner (*p))
d1052 1
a1052 3
  c = *p++;
  while (ISALPHA (c) || ISDIGIT (c) || c == '_')
    c = *p++;
d1054 6
a1059 5
  *--p = 0;
  reg = (struct reg_entry *) hash_find (htab, start);
  *p = c;

  if (reg)
d1061 2
a1062 2
      *ccp = p;
      return reg->number;
d1065 1
a1065 2
  return FAIL;
}
d1067 8
a1074 3
/* Search for the following register name in each of the possible reg name
   tables.  Return the classification if found, or REG_TYPE_MAX if not
   present.  */
d1076 2
a1077 4
static enum arm_reg_type
arm_reg_parse_any (char *cp)
{
  int i;
d1079 1
a1079 14
  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    if (arm_reg_parse (&cp, all_reg_maps[i].htab) != FAIL)
      return (enum arm_reg_type) i;

  return REG_TYPE_MAX;
}

static void
opcode_select (int width)
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
d1081 2
a1082 7
	  if (! (cpu_variant & ARM_EXT_V4T))
	    as_bad (_("selected processor does not support THUMB opcodes"));

	  thumb_mode = 1;
	  /* No need to force the alignment, since we will have been
             coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
a1083 2
      mapping_state (MAP_THUMB);
      break;
d1085 1
a1085 2
    case 32:
      if (thumb_mode)
d1087 3
a1089 2
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
	    as_bad (_("selected processor does not support ARM opcodes"));
d1091 2
a1092 1
	  thumb_mode = 0;
d1094 40
a1133 2
	  if (!need_pass_2)
	    frag_align (2, 0, 0);
d1135 8
a1142 1
	  record_alignment (now_seg, 1);
d1144 90
a1233 2
      mapping_state (MAP_ARM);
      break;
d1235 5
a1239 2
    default:
      as_bad (_("invalid instruction size selected (%d)"), width);
d1241 33
d1276 2
d1288 1
a1288 1
       .unreq my_alias    */
a1295 1
  skip_whitespace (input_line_pointer);
d1306 3
a1308 1
  if (*name)
d1310 1
a1310 1
      enum arm_reg_type req_type = arm_reg_parse_any (name);
d1312 6
a1317 1
      if (req_type != REG_TYPE_MAX)
d1319 3
a1321 31
	  char *temp_name = name;
	  int req_no = arm_reg_parse (&temp_name, all_reg_maps[req_type].htab);

	  if (req_no != FAIL)
	    {
	      struct reg_entry *req_entry;

	      /* Check to see if this alias is a builtin one.  */
	      req_entry = hash_delete (all_reg_maps[req_type].htab, name);

	      if (!req_entry)
		as_bad (_("unreq: missing hash entry for \"%s\""), name);
	      else if (req_entry->builtin)
		/* FIXME: We are deleting a built in register alias which
		   points to a const data structure, so we only need to
		   free up the memory used by the key in the hash table.
		   Unfortunately we have not recorded this value, so this
		   is a memory leak.  */
		  /* FIXME: Should we issue a warning message ?  */
		;
	      else
		{
		  /* Deleting a user defined alias.  We need to free the
		     key and the value, but fortunately the key is the same
		     as the value->name field.  */
		  free ((char *) req_entry->name);
		  free (req_entry);
		}
	    }
          else
            as_bad (_(".unreq: unrecognized symbol \"%s\""), name);
a1322 2
      else
        as_bad (_(".unreq: unrecognized symbol \"%s\""), name);
a1323 2
  else
    as_bad (_("invalid syntax for .unreq directive"));
d1329 1
a1329 16
static void
s_bss (int ignore ATTRIBUTE_UNUSED)
{
  /* We don't support putting frags in the BSS segment, we fake it by
     marking in_bss, then looking at s_skip for clues.  */
  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
  mapping_state (MAP_DATA);
}

static void
s_even (int ignore ATTRIBUTE_UNUSED)
{
  /* Never make frag if expect extra pass.  */
  if (!need_pass_2)
    frag_align (1, 0, 0);
d1331 5
a1335 1
  record_alignment (now_seg, 1);
d1337 1
a1337 2
  demand_empty_rest_of_line ();
}
d1340 1
a1340 1
s_ltorg (int ignored ATTRIBUTE_UNUSED)
d1342 3
a1344 3
  unsigned int entry;
  literal_pool * pool;
  char sym_name[20];
d1346 3
a1348 4
  pool = find_literal_pool ();
  if (pool == NULL
      || pool->symbol == NULL
      || pool->next_free_entry == 0)
d1351 1
a1351 1
  mapping_state (MAP_DATA);
d1353 19
a1371 4
  /* Align pool as you have word accesses.
     Only make a frag if we have to.  */
  if (!need_pass_2)
    frag_align (2, 0, 0);
d1373 1
a1373 1
  record_alignment (now_seg, 2);
d1375 3
a1377 1
  sprintf (sym_name, "$$lit_\002%x", pool->id);
d1379 7
a1385 3
  symbol_locate (pool->symbol, sym_name, now_seg,
		 (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (pool->symbol);
d1387 5
a1391 1
  ARM_SET_THUMB (pool->symbol, thumb_mode);
d1393 7
a1399 2
#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (pool->symbol, support_interwork);
d1402 14
a1415 3
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    /* First output the expression in the instruction to the pool.  */
    emit_expr (&(pool->literals[entry]), 4); /* .word  */
d1417 5
a1421 4
  /* Mark the pool as empty.  */
  pool->next_free_entry = 0;
  pool->symbol = NULL;
}
d1423 2
a1424 1
/* Same as s_align_ptwo but align 0 => align 2.  */
d1426 1
a1426 6
static void
s_align (int unused ATTRIBUTE_UNUSED)
{
  int temp;
  long temp_fill;
  long max_alignment = 15;
d1428 1
a1428 4
  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad (_("alignment too large: %d assumed"), temp = max_alignment);
  else if (temp < 0)
d1430 2
a1431 2
      as_bad (_("alignment negative. 0 assumed."));
      temp = 0;
d1434 9
a1442 1
  if (*input_line_pointer == ',')
d1444 32
a1475 2
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
d1477 1
a1477 2
  else
    temp_fill = 0;
d1479 6
a1484 2
  if (!temp)
    temp = 2;
d1486 4
a1489 3
  /* Only make a frag if we HAVE to.  */
  if (temp && !need_pass_2)
    frag_align (temp, (int) temp_fill, 0);
d1491 1
d1493 16
a1508 1
  record_alignment (now_seg, temp);
d1518 1
a1518 1
     target processor should not support interworking.  */
a1521 1

d1531 1
a1531 2
  if (! thumb_mode)
    opcode_select (16);
d1534 1
a1534 1
     We need to know this for the interworking support.  */
a1535 2

  demand_empty_rest_of_line ();
d1548 1
a1548 1
  char      delim;
d1555 2
a1556 2
  name      = input_line_pointer;
  delim     = get_symbol_end ();
a1559 2
  SKIP_WHITESPACE ();

d1584 1
a1584 1
         for this symbol.  */
d1619 1
a1619 1
  /* XXX Now we come to the Thumb specific bit of code.  */
d1628 5
d1634 1
a1634 1
s_arm (int ignore ATTRIBUTE_UNUSED)
d1636 15
a1650 1
  opcode_select (32);
d1654 3
a1656 6
static void
s_thumb (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (16);
  demand_empty_rest_of_line ();
}
d1659 1
a1659 1
s_code (int unused ATTRIBUTE_UNUSED)
d1662 2
d1666 3
a1668 1
  switch (temp)
d1670 3
a1672 4
    case 16:
    case 32:
      opcode_select (temp);
      break;
d1674 4
a1677 2
    default:
      as_bad (_("invalid operand to .code directive (%d) (expecting 16 or 32)"), temp);
d1679 12
d1694 1
a1694 1
end_of_line (char * str)
d1696 5
a1700 4
  skip_whitespace (str);

  if (*str != '\0' && !inst.error)
    inst.error = _("garbage following instruction");
d1703 2
a1704 2
static int
skip_past_comma (char ** str)
d1706 3
a1708 2
  char * p = * str, c;
  int comma = 0;
d1710 1
a1710 6
  while ((c = *p) == ' ' || c == ',')
    {
      p++;
      if (c == ',' && comma++)
	return FAIL;
    }
d1712 1
a1712 5
  if (c == '\0')
    return FAIL;

  *str = p;
  return comma ? SUCCESS : FAIL;
d1715 1
a1715 1
/* Return TRUE if anything in the expression is a bignum.  */
d1717 2
a1718 2
static int
walk_no_bignums (symbolS * sp)
d1720 1
a1720 2
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;
d1722 1
a1722 1
  if (symbol_get_value_expression (sp)->X_add_symbol)
d1724 3
a1726 3
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
d1729 1
a1729 1
  return 0;
d1732 2
a1733 4
static int in_my_get_expression = 0;

static int
my_get_expression (expressionS * ep, char ** str)
d1735 3
a1737 2
  char * save_in;
  segT   seg;
d1739 1
a1739 5
  save_in = input_line_pointer;
  input_line_pointer = *str;
  in_my_get_expression = 1;
  seg = expression (ep);
  in_my_get_expression = 0;
d1741 1
a1741 1
  if (ep->X_op == O_illegal)
d1743 10
a1752 5
      /* We found a bad expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
d1754 2
a1755 11
#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad_segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
a1756 1
#endif
d1758 2
a1759 8
  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.  Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (ep->X_op == O_big
      || (ep->X_add_symbol
	  && (walk_no_bignums (ep->X_add_symbol)
	      || (ep->X_op_symbol
		  && walk_no_bignums (ep->X_op_symbol)))))
d1761 3
a1763 4
      inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
d1766 2
a1767 3
  *str = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
d1770 2
a1771 4
/* A standard register must be given at this point.
   SHIFT is the place to put it in inst.instruction.
   Restores input start point on error.
   Returns the reg#, or FAIL.  */
d1774 1
a1774 1
reg_required_here (char ** str, int shift)
d1776 4
a1779 3
  static char buff [128]; /* XXX  */
  int         reg;
  char *      start = * str;
d1781 2
a1782 1
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_RN].htab)) != FAIL)
d1784 17
a1800 3
      if (shift >= 0)
	inst.instruction |= reg << shift;
      return reg;
d1803 12
a1814 2
  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;
d1816 3
a1818 4
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  sprintf (buff, _("register expected, not '%.100s'"), start);
  inst.error = buff;
d1820 1
a1820 1
  return FAIL;
d1823 12
a1834 5
/* A Intel Wireless MMX technology register
   must be given at this point.
   Shift is the place to put it in inst.instruction.
   Restores input start point on err.
   Returns the reg#, or FAIL.  */
d1836 3
a1838 40
static int
wreg_required_here (char ** str,
		    int shift,
		    enum wreg_type reg_type)
{
  static char buff [128];
  int    reg;
  char * start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_IWMMXT].htab)) != FAIL)
    {
      if (wr_register (reg)
	  && (reg_type == IWMMXT_REG_WR || reg_type == IWMMXT_REG_WR_OR_WC))
        {
          if (shift >= 0)
            inst.instruction |= (reg ^ WR_PREFIX) << shift;
          return reg;
        }
      else if (wc_register (reg)
	       && (reg_type == IWMMXT_REG_WC || reg_type == IWMMXT_REG_WR_OR_WC))
        {
          if (shift >= 0)
            inst.instruction |= (reg ^ WC_PREFIX) << shift;
          return reg;
        }
      else if ((wcg_register (reg) && reg_type == IWMMXT_REG_WCG))
        {
          if (shift >= 0)
            inst.instruction |= ((reg ^ WC_PREFIX) - 8) << shift;
          return reg;
        }
    }

  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;

  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  sprintf (buff, _("Intel Wireless MMX technology register expected, not '%.100s'"), start);
  inst.error = buff;
d1840 4
a1843 2
  return FAIL;
}
d1845 1
a1845 7
static const struct asm_psr *
arm_psr_parse (char ** ccp)
{
  char * start = * ccp;
  char   c;
  char * p;
  const struct asm_psr * psr;
d1847 3
a1849 1
  p = start;
d1851 1
a1851 6
  /* Skip to the end of the next word in the input stream.  */
  do
    {
      c = *p++;
    }
  while (ISALPHA (c) || c == '_');
d1853 3
a1855 2
  /* Terminate the word.  */
  *--p = 0;
d1857 3
a1859 6
  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
     feature for ease of use and backwards compatibility.  */
  if (!strncmp (start, "cpsr", 4))
    strncpy (start, "CPSR", 4);
  else if (!strncmp (start, "spsr", 4))
    strncpy (start, "SPSR", 4);
d1861 1
a1861 2
  /* Now locate the word in the psr hash table.  */
  psr = (const struct asm_psr *) hash_find (arm_psr_hsh, start);
d1863 1
a1863 2
  /* Restore the input stream.  */
  *p = c;
d1865 3
a1867 3
  /* If we found a valid match, advance the
     stream pointer past the end of the word.  */
  *ccp = p;
d1869 3
a1871 1
  return psr;
a1873 1
/* Parse the input looking for a PSR flag.  */
d1875 2
a1876 2
static int
psr_required_here (char ** str)
d1878 9
a1886 2
  char * start = * str;
  const struct asm_psr * psr;
d1888 8
a1895 1
  psr = arm_psr_parse (str);
d1897 5
a1901 5
  if (psr)
    {
      /* If this is the SPSR that is being modified, set the R bit.  */
      if (! psr->cpsr)
	inst.instruction |= SPSR_BIT;
d1903 1
a1903 2
      /* Set the psr flags in the MSR instruction.  */
      inst.instruction |= psr->field << PSR_SHIFT;
d1905 3
a1907 2
      return SUCCESS;
    }
d1909 3
a1911 3
  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  inst.error = _("flag for {c}psr instruction expected");
d1913 3
a1915 3
  /* Restore the start point.  */
  *str = start;
  return FAIL;
d1918 13
a1930 2
static int
co_proc_number (char ** str)
d1932 11
a1942 2
  int processor, pchar;
  char *start;
d1944 3
a1946 2
  skip_whitespace (*str);
  start = *str;
d1948 2
a1949 5
  /* The data sheet seems to imply that just a number on its own is valid
     here, but the RISC iX assembler seems to accept a prefix 'p'.  We will
     accept either.  */
  if ((processor = arm_reg_parse (str, all_reg_maps[REG_TYPE_CP].htab))
      == FAIL)
d1951 4
a1954 1
      *str = start;
d1956 3
a1958 2
      pchar = *(*str)++;
      if (pchar >= '0' && pchar <= '9')
d1960 11
a1970 2
	  processor = pchar - '0';
	  if (**str >= '0' && **str <= '9')
d1972 7
a1978 2
	      processor = processor * 10 + *(*str)++ - '0';
	      if (processor > 15)
d1980 19
a1998 2
		  inst.error = _("illegal co-processor number");
		  return FAIL;
a2001 5
      else
	{
	  inst.error = all_reg_maps[REG_TYPE_CP].expected;
	  return FAIL;
	}
d2003 1
d2005 3
a2007 2
  inst.instruction |= processor << 8;
  return SUCCESS;
d2010 5
a2014 2
static int
cp_opc_expr (char ** str, int where, int length)
d2016 18
a2033 1
  expressionS expr;
d2035 3
a2037 1
  skip_whitespace (* str);
d2039 1
a2039 1
  memset (&expr, '\0', sizeof (expr));
d2041 1
a2041 7
  if (my_get_expression (&expr, str))
    return FAIL;
  if (expr.X_op != O_constant)
    {
      inst.error = _("bad or missing expression");
      return FAIL;
    }
d2043 4
a2046 5
  if ((expr.X_add_number & ((1 << length) - 1)) != expr.X_add_number)
    {
      inst.error = _("immediate co-processor expression too large");
      return FAIL;
    }
d2048 1
a2048 2
  inst.instruction |= expr.X_add_number << where;
  return SUCCESS;
d2051 1
a2051 5
static int
cp_reg_required_here (char ** str, int where)
{
  int    reg;
  char * start = *str;
d2053 1
a2053 5
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_CN].htab)) != FAIL)
    {
      inst.instruction |= reg << where;
      return reg;
    }
d2055 6
a2060 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = all_reg_maps[REG_TYPE_CN].expected;
d2062 10
a2071 3
  /* Restore the start point.  */
  *str = start;
  return FAIL;
a2073 5
static int
fp_reg_required_here (char ** str, int where)
{
  int    reg;
  char * start = * str;
d2075 2
a2076 5
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_FN].htab)) != FAIL)
    {
      inst.instruction |= reg << where;
      return reg;
    }
d2078 6
a2083 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = all_reg_maps[REG_TYPE_FN].expected;
d2085 1
a2085 3
  /* Restore the start point.  */
  *str = start;
  return FAIL;
d2088 4
a2091 2
static int
cp_address_offset (char ** str)
d2093 3
a2095 1
  int offset;
d2097 1
a2097 1
  skip_whitespace (* str);
d2099 5
a2103 5
  if (! is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return FAIL;
    }
d2105 4
a2108 1
  (*str)++;
d2110 2
a2111 2
  if (my_get_expression (& inst.reloc.exp, str))
    return FAIL;
d2113 8
a2120 1
  if (inst.reloc.exp.X_op == O_constant)
d2122 11
a2132 1
      offset = inst.reloc.exp.X_add_number;
d2134 3
a2136 19
      if (offset & 3)
	{
	  inst.error = _("co-processor address must be word aligned");
	  return FAIL;
	}

      if (offset > 1023 || offset < -1023)
	{
	  inst.error = _("offset too large");
	  return FAIL;
	}

      if (offset >= 0)
	inst.instruction |= INDEX_UP;
      else
	offset = -offset;

      inst.instruction |= offset >> 2;
    }
d2138 3
a2140 1
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
d2142 2
a2143 1
  return SUCCESS;
a2145 6
static int
cp_address_required_here (char ** str, int wb_ok)
{
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;
d2147 1
a2147 3
  if (*p == '[')
    {
      int reg;
d2149 6
a2154 2
      p++;
      skip_whitespace (p);
d2156 2
a2157 2
      if ((reg = reg_required_here (& p, 16)) == FAIL)
	return FAIL;
a2158 1
      skip_whitespace (p);
d2160 1
a2160 3
      if (*p == ']')
	{
	  p++;
d2162 4
a2165 1
	  skip_whitespace (p);
d2167 2
a2168 10
	  if (*p == '\0')
	    {
	      /* As an extension to the official ARM syntax we allow:
		   [Rn]
	         as a short hand for:
		   [Rn,#0]  */
	      inst.instruction |= PRE_INDEX | INDEX_UP;
	      *str = p;
	      return SUCCESS;
	    }
d2170 1
a2170 5
	  if (skip_past_comma (& p) == FAIL)
	    {
	      inst.error = _("comma expected after closing square bracket");
	      return FAIL;
	    }
d2172 7
a2178 1
	  skip_whitespace (p);
d2180 1
a2180 6
	  if (*p == '#')
	    {
	      if (wb_ok)
		{
		  /* [Rn], #expr  */
		  write_back = WRITE_BACK;
d2182 2
a2183 5
		  if (reg == REG_PC)
		    {
		      inst.error = _("pc may not be used in post-increment");
		      return FAIL;
		    }
a2184 9
		  if (cp_address_offset (& p) == FAIL)
		    return FAIL;
		}
	      else
		pre_inc = PRE_INDEX | INDEX_UP;
	    }
	  else if (*p == '{')
	    {
	      int option;
d2186 1
a2186 2
	      /* [Rn], {<expr>}  */
	      p++;
d2188 4
a2191 1
	      skip_whitespace (p);
d2193 2
a2194 2
	      if (my_get_expression (& inst.reloc.exp, & p))
		return FAIL;
d2196 7
a2202 3
	      if (inst.reloc.exp.X_op == O_constant)
		{
		  option = inst.reloc.exp.X_add_number;
a2203 5
		  if (option > 255 || option < 0)
		    {
		      inst.error = _("'option' field too large");
		      return FAIL;
		    }
d2205 1
a2205 1
		  skip_whitespace (p);
d2207 6
a2212 27
		  if (*p != '}')
		    {
		      inst.error = _("'}' expected at end of 'option' field");
		      return FAIL;
		    }
		  else
		    {
		      p++;
		      inst.instruction |= option;
		      inst.instruction |= INDEX_UP;
		    }
		}
	      else
		{
		  inst.error = _("non-constant expressions for 'option' field not supported");
		  return FAIL;
		}
	    }
	  else
	    {
	      inst.error = _("# or { expected after comma");
	      return FAIL;
	    }
	}
      else
	{
	  /* '['Rn, #expr']'[!]  */
d2214 7
a2220 5
	  if (skip_past_comma (& p) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return FAIL;
	    }
d2222 1
a2222 1
	  pre_inc = PRE_INDEX;
d2224 11
a2234 2
	  if (cp_address_offset (& p) == FAIL)
	    return FAIL;
d2236 14
a2249 22
	  skip_whitespace (p);

	  if (*p++ != ']')
	    {
	      inst.error = _("missing ]");
	      return FAIL;
	    }

	  skip_whitespace (p);

	  if (wb_ok && *p == '!')
	    {
	      if (reg == REG_PC)
		{
		  inst.error = _("pc may not be used with write-back");
		  return FAIL;
		}

	      p++;
	      write_back = WRITE_BACK;
	    }
	}
d2253 8
a2260 2
      if (my_get_expression (&inst.reloc.exp, &p))
	return FAIL;
d2262 5
a2266 5
      inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust.  */
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = PRE_INDEX;
d2269 6
a2274 3
  inst.instruction |= write_back | pre_inc;
  *str = p;
  return SUCCESS;
d2277 5
a2281 2
static int
cp_byte_address_offset (char ** str)
d2283 3
a2285 1
  int offset;
d2287 5
a2291 1
  skip_whitespace (* str);
d2293 1
a2293 1
  if (! is_immediate_prefix (**str))
d2295 3
a2297 2
      inst.error = _("immediate expression expected");
      return FAIL;
d2300 1
a2300 1
  (*str)++;
d2302 1
a2302 4
  if (my_get_expression (& inst.reloc.exp, str))
    return FAIL;

  if (inst.reloc.exp.X_op == O_constant)
d2304 3
a2306 14
      offset = inst.reloc.exp.X_add_number;

      if (offset > 255 || offset < -255)
        {
          inst.error = _("offset too large");
          return FAIL;
        }

      if (offset >= 0)
        inst.instruction |= INDEX_UP;
      else
        offset = -offset;

      inst.instruction |= offset;
a2307 2
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM_S2;
d2309 1
a2309 2
  return SUCCESS;
}
d2311 1
a2311 8
static int
cp_byte_address_required_here (char ** str)
{
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;

  if (*p == '[')
d2313 3
a2315 68
      int reg;

      p++;
      skip_whitespace (p);

      if ((reg = reg_required_here (& p, 16)) == FAIL)
        return FAIL;

      skip_whitespace (p);

      if (*p == ']')
        {
          p++;

          if (skip_past_comma (& p) == SUCCESS)
            {
              /* [Rn], #expr */
              write_back = WRITE_BACK;

              if (reg == REG_PC)
                {
                  inst.error = _("pc may not be used in post-increment");
                  return FAIL;
                }

              if (cp_byte_address_offset (& p) == FAIL)
                return FAIL;
            }
          else
            pre_inc = PRE_INDEX | INDEX_UP;
        }
      else
        {
          /* '['Rn, #expr']'[!] */

          if (skip_past_comma (& p) == FAIL)
            {
              inst.error = _("pre-indexed expression expected");
              return FAIL;
            }

          pre_inc = PRE_INDEX;

          if (cp_byte_address_offset (& p) == FAIL)
            return FAIL;

          skip_whitespace (p);

          if (*p++ != ']')
            {
              inst.error = _("missing ]");
              return FAIL;
            }

          skip_whitespace (p);

          if (*p == '!')
            {
              if (reg == REG_PC)
                {
                  inst.error = _("pc may not be used with write-back");
                  return FAIL;
                }

              p++;
              write_back = WRITE_BACK;
            }
        }
d2319 6
a2324 2
      if (my_get_expression (&inst.reloc.exp, &p))
        return FAIL;
a2325 6
      inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM_S2;
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust.  */
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = PRE_INDEX;
    }
d2327 1
a2327 4
  inst.instruction |= write_back | pre_inc;
  *str = p;
  return SUCCESS;
}
d2330 1
a2330 1
do_nop (char * str)
d2332 6
a2337 2
  skip_whitespace (str);
  if (*str == '{')
d2339 3
a2341 24
      str++;

      if (my_get_expression (&inst.reloc.exp, &str))
	inst.reloc.exp.X_op = O_illegal;
      else
	{
	  skip_whitespace (str);
	  if (*str == '}')
	    str++;
	  else
	    inst.reloc.exp.X_op = O_illegal;
	}

      if (inst.reloc.exp.X_op != O_constant
	  || inst.reloc.exp.X_add_number > 255
	  || inst.reloc.exp.X_add_number < 0)
	{
	  inst.error = _("Invalid NOP hint");
	  return;
	}

      /* Arcitectural NOP hints are CPSR sets with no bits selected.  */
      inst.instruction &= 0xf0000000;
      inst.instruction |= 0x0320f000 + inst.reloc.exp.X_add_number;
d2344 1
a2344 2
  end_of_line (str);
}
d2346 1
a2346 16
static void
do_empty (char * str)
{
  /* Do nothing really.  */
  end_of_line (str);
}

static void
do_mrs (char * str)
{
  int skip = 0;

  /* Only one syntax.  */
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
d2348 3
a2350 2
      inst.error = BAD_ARGS;
      return;
a2351 20

  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = _("comma expected after register name");
      return;
    }

  skip_whitespace (str);

  if (   streq (str, "CPSR")
      || streq (str, "SPSR")
	 /* Lower case versions for backwards compatibility.  */
      || streq (str, "cpsr")
      || streq (str, "spsr"))
    skip = 4;

  /* This is for backwards compatibility with older toolchains.  */
  else if (   streq (str, "cpsr_all")
	   || streq (str, "spsr_all"))
    skip = 8;
d2354 3
a2356 2
      inst.error = _("CPSR or SPSR expected");
      return;
d2358 2
a2360 6
  if (* str == 's' || * str == 'S')
    inst.instruction |= SPSR_BIT;
  str += skip;

  end_of_line (str);
}
d2362 1
a2362 3
/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */
d2365 1
a2365 1
do_msr (char * str)
d2367 5
a2371 1
  skip_whitespace (str);
d2373 2
a2374 2
  if (psr_required_here (& str) == FAIL)
    return;
d2376 1
a2376 1
  if (skip_past_comma (& str) == FAIL)
d2378 1
a2378 3
      inst.error = _("comma missing after psr flags");
      return;
    }
d2380 5
a2384 1
  skip_whitespace (str);
d2386 3
a2388 6
  if (reg_required_here (& str, 0) != FAIL)
    {
      inst.error = NULL;
      end_of_line (str);
      return;
    }
d2390 17
a2406 5
  if (! is_immediate_prefix (* str))
    {
      inst.error =
	_("only a register or immediate value can follow a psr flag");
      return;
d2408 1
d2410 2
a2411 2
  str ++;
  inst.error = NULL;
d2413 1
a2413 6
  if (my_get_expression (& inst.reloc.exp, & str))
    {
      inst.error =
	_("only a register or immediate value can follow a psr flag");
      return;
    }
d2415 3
a2417 1
  inst.instruction |= INST_IMMEDIATE;
d2419 1
a2419 1
  if (inst.reloc.exp.X_add_symbol)
d2421 2
a2422 2
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
d2424 5
a2428 1
  else
d2430 2
a2431 3
      unsigned value = validate_immediate (inst.reloc.exp.X_add_number);

      if (value == (unsigned) FAIL)
d2433 26
a2458 2
	  inst.error = _("invalid constant");
	  return;
d2460 1
d2462 28
a2489 1
      inst.instruction |= value;
d2492 3
a2494 2
  inst.error = NULL;
  end_of_line (str);
a2496 6
/* Long Multiply Parser
   UMULL RdLo, RdHi, Rm, Rs
   SMULL RdLo, RdHi, Rm, Rs
   UMLAL RdLo, RdHi, Rm, Rs
   SMLAL RdLo, RdHi, Rm, Rs.  */

d2498 1
a2498 1
do_mull (char * str)
d2500 4
a2503 1
  int rdlo, rdhi, rm, rs;
d2505 2
a2506 2
  /* Only one format "rdlo, rdhi, rm, rs".  */
  skip_whitespace (str);
d2508 1
a2508 1
  if ((rdlo = reg_required_here (&str, 12)) == FAIL)
d2510 30
a2539 2
      inst.error = BAD_ARGS;
      return;
d2541 1
d2543 2
a2544 6
  if (skip_past_comma (&str) == FAIL
      || (rdhi = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d2546 1
a2546 6
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d2548 3
a2550 3
  /* rdhi, rdlo and rm must all be different.  */
  if (rdlo == rdhi || rdlo == rm || rdhi == rm)
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
d2552 1
a2552 2
  if (skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
d2554 2
a2555 2
      inst.error = BAD_ARGS;
      return;
d2557 6
a2563 5
  if (rdhi == REG_PC || rdhi == REG_PC || rdhi == REG_PC || rdhi == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d2565 1
a2565 2
  end_of_line (str);
}
d2568 1
a2568 1
do_mul (char * str)
d2570 3
a2572 1
  int rd, rm;
d2574 2
a2575 2
  /* Only one format "rd, rm, rs".  */
  skip_whitespace (str);
d2577 1
a2577 1
  if ((rd = reg_required_here (&str, 16)) == FAIL)
d2579 2
a2580 2
      inst.error = BAD_ARGS;
      return;
d2583 1
a2583 5
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d2585 1
a2585 2
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
d2587 2
a2588 1
      inst.error = BAD_ARGS;
d2592 1
a2592 1
  if (rm == REG_PC)
d2594 8
a2601 1
      inst.error = BAD_PC;
a2602 1
    }
d2604 4
a2607 2
  if (rm == rd)
    as_tsktsk (_("rd and rm should be different in mul"));
d2609 3
a2611 5
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
d2613 1
a2614 5
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d2616 1
a2616 2
  end_of_line (str);
}
d2619 1
a2619 1
do_mlas (char * str, bfd_boolean is_mls)
d2621 2
a2622 1
  int rd, rm;
d2624 2
a2625 4
  /* Only one format "rd, rm, rs, rn".  */
  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 16)) == FAIL)
d2627 2
a2628 1
      inst.error = BAD_ARGS;
d2631 1
d2633 1
a2633 1
  if (rd == REG_PC)
d2635 1
a2635 1
      inst.error = BAD_PC;
d2639 14
a2652 6
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d2654 4
a2657 5
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d2659 2
a2660 4
  /* This restriction does not apply to mls (nor to mla in v6, but
     that's hard to detect at present).  */
  if (rm == rd && !is_mls)
    as_tsktsk (_("rd and rm should be different in mla"));
d2662 1
a2662 4
  if (skip_past_comma (&str) == FAIL
      || (rd = reg_required_here (&str, 8)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 12)) == FAIL)
d2664 2
a2665 1
      inst.error = BAD_ARGS;
d2669 3
a2671 5
  if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d2673 1
a2673 1
  end_of_line (str);
d2676 2
d2679 1
a2679 1
do_mla (char *str)
d2681 3
a2683 2
  do_mlas (str, FALSE);
}
d2685 5
a2689 5
static void
do_mls (char *str)
{
  do_mlas (str, TRUE);
}
d2691 6
a2696 3
/* Expects *str -> the characters "acc0", possibly with leading blanks.
   Advances *str to the next non-alphanumeric.
   Returns 0, or else FAIL (in which case sets inst.error).
d2698 8
a2705 2
  (In a future XScale, there may be accumulators other than zero.
  At that time this routine and its callers can be upgraded to suit.)  */
d2707 1
a2707 7
static int
accum0_required_here (char ** str)
{
  static char buff [128];	/* Note the address is taken.  Hence, static.  */
  char * p = * str;
  char   c;
  int result = 0;		/* The accum number.  */
d2709 1
a2709 10
  skip_whitespace (p);

  *str = p;			/* Advance caller's string pointer too.  */
  c = *p++;
  while (ISALNUM (c))
    c = *p++;

  *--p = 0;			/* Aap nul into input buffer at non-alnum.  */

  if (! ( streq (*str, "acc0") || streq (*str, "ACC0")))
d2711 3
a2713 3
      sprintf (buff, _("acc0 expected, not '%.100s'"), *str);
      inst.error = buff;
      result = FAIL;
d2716 7
a2722 3
  *p = c;			/* Unzap.  */
  *str = p;			/* Caller's string pointer to after match.  */
  return result;
d2725 4
a2728 2
static int
ldst_extend_v4 (char ** str)
d2730 4
a2733 1
  int add = INDEX_UP;
d2735 3
a2737 1
  switch (**str)
d2739 5
a2743 5
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;
d2745 6
a2750 3
      if (inst.reloc.exp.X_op == O_constant)
	{
	  int value = inst.reloc.exp.X_add_number;
d2752 1
a2752 5
	  if (value < -255 || value > 255)
	    {
	      inst.error = _("address offset too large");
	      return FAIL;
	    }
d2754 7
a2760 10
	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
	    }

	  /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0.  */
	  inst.instruction |= (add | HWOFFSET_IMM
			       | ((value >> 4) << 8) | (value & 0xF));
d2762 1
a2762 1
      else
d2764 3
a2766 3
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	  inst.reloc.pc_rel = 0;
d2768 1
a2768 1
      return SUCCESS;
d2770 3
a2772 3
    case '-':
      add = 0;
      /* Fall through.  */
d2774 2
a2775 3
    case '+':
      (*str)++;
      /* Fall through.  */
d2777 3
a2779 3
    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;
d2781 1
a2781 3
      inst.instruction |= add;
      return SUCCESS;
    }
d2783 1
d2785 48
a2832 4
/* Expects **str -> after a comma. May be leading blanks.
   Advances *str, recognizing a load  mode, and setting inst.instruction.
   Returns rn, or else FAIL (in which case may set inst.error
   and not advance str)
d2834 5
a2838 1
   Note: doesn't know Rd, so no err checks that require such knowledge.  */
d2841 2
a2842 1
ld_mode_required_here (char ** string)
d2844 7
a2850 3
  char * str = * string;
  int    rn;
  int    pre_inc = 0;
d2852 5
a2856 1
  skip_whitespace (str);
d2858 3
a2860 3
  if (* str == '[')
    {
      str++;
d2862 2
a2863 1
      skip_whitespace (str);
d2865 8
a2872 2
      if ((rn = reg_required_here (& str, 16)) == FAIL)
	return FAIL;
d2874 2
a2875 1
      skip_whitespace (str);
d2877 3
a2879 1
      if (* str == ']')
d2881 1
a2881 11
	  str ++;

	  if (skip_past_comma (& str) == SUCCESS)
	    {
	      /* [Rn],... (post inc) */
	      if (ldst_extend_v4 (&str) == FAIL)
		return FAIL;
	    }
	  else 	      /* [Rn] */
	    {
	      skip_whitespace (str);
d2883 4
a2886 9
	      if (* str == '!')
		{
		  str ++;
		  inst.instruction |= WRITE_BACK;
		}

	      inst.instruction |= INDEX_UP | HWOFFSET_IMM;
	      pre_inc = 1;
	    }
d2888 1
a2888 7
      else	  /* [Rn,...] */
	{
	  if (skip_past_comma (& str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return FAIL;
	    }
d2890 4
a2893 1
	  pre_inc = 1;
d2895 1
a2895 2
	  if (ldst_extend_v4 (&str) == FAIL)
	    return FAIL;
d2897 7
a2903 3
	  skip_whitespace (str);

	  if (* str ++ != ']')
d2905 2
a2906 2
	      inst.error = _("missing ]");
	      return FAIL;
d2909 1
a2909 3
	  skip_whitespace (str);

	  if (* str == '!')
d2911 2
a2912 2
	      str ++;
	      inst.instruction |= WRITE_BACK;
d2916 8
a2923 5
  else if (* str == '=')	/* ldr's "r,=label" syntax */
    /* We should never reach here, because <text> = <expression> is
       caught gas/read.c read_a_source_file() as a .set operation.  */
    return FAIL;
  else				/* PC +- 8 bit immediate offset.  */
d2925 11
a2935 2
      if (my_get_expression (& inst.reloc.exp, & str))
	return FAIL;
d2937 8
a2944 8
      inst.instruction            |= HWOFFSET_IMM;	/* The I bit.  */
      inst.reloc.type              = BFD_RELOC_ARM_OFFSET_IMM8;
      inst.reloc.exp.X_add_number -= 8;  		/* PC rel adjust.  */
      inst.reloc.pc_rel            = 1;
      inst.instruction            |= (REG_PC << 16);

      rn = REG_PC;
      pre_inc = 1;
d2947 4
a2950 4
  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  * string = str;

  return rn;
d2953 5
a2957 4
/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
   SMLAxy{cond} Rd,Rm,Rs,Rn
   SMLAWy{cond} Rd,Rm,Rs,Rn
   Error if any register is R15.  */
d2959 1
a2959 2
static void
do_smla (char * str)
d2961 3
a2963 1
  int rd, rm, rs, rn;
d2965 9
a2973 1
  skip_whitespace (str);
d2975 2
a2976 8
  if ((rd = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d2978 3
a2980 2
  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;
d2982 2
a2983 3
  else
    end_of_line (str);
}
d2985 2
a2986 7
/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
   Error if any register is R15.
   Warning if Rdlo == Rdhi.  */

static void
do_smlal (char * str)
d2988 5
a2992 1
  int rdlo, rdhi, rm, rs;
d2994 2
a2995 1
  skip_whitespace (str);
d2997 1
a2997 7
  if ((rdlo = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rdhi = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
d2999 2
a3000 2
      inst.error = BAD_ARGS;
      return;
d3003 3
a3005 1
  if (rdlo == REG_PC || rdhi == REG_PC || rm == REG_PC || rs == REG_PC)
d3007 2
a3008 2
      inst.error = BAD_PC;
      return;
d3011 1
a3011 2
  if (rdlo == rdhi)
    as_tsktsk (_("rdhi and rdlo must be different"));
d3013 4
a3016 2
  end_of_line (str);
}
d3018 7
a3024 3
/* ARM V5E (El Segundo) signed-multiply (argument parse)
   SMULxy{cond} Rd,Rm,Rs
   Error if any register is R15.  */
d3026 7
a3032 4
static void
do_smul (char * str)
{
  int rd, rm, rs;
d3034 7
a3040 1
  skip_whitespace (str);
d3042 2
a3043 6
  if ((rd = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
    inst.error = BAD_ARGS;
d3045 4
a3048 2
  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;
d3050 13
a3062 2
  else
    end_of_line (str);
d3065 1
a3065 3
/* ARM V5E (El Segundo) saturating-add/subtract (argument parse)
   Q[D]{ADD,SUB}{cond} Rd,Rm,Rn
   Error if any register is R15.  */
d3067 4
a3070 4
static void
do_qadd (char * str)
{
  int rd, rm, rn;
d3072 3
a3074 1
  skip_whitespace (str);
d3076 5
a3080 6
  if ((rd = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;
d3082 4
a3085 2
  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;
d3087 3
a3089 3
  else
    end_of_line (str);
}
d3091 2
a3092 3
/* ARM V5E (el Segundo)
   MCRRcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
   MRRCcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
d3094 3
a3096 2
   These are equivalent to the XScale instructions MAR and MRA,
   respectively, when coproc == 0, opcode == 0, and CRm == 0.
d3098 2
a3099 1
   Result unpredicatable if Rd or Rn is R15.  */
d3101 5
a3105 4
static void
do_co_reg2c (char * str)
{
  int rd, rn;
d3107 5
a3111 1
  skip_whitespace (str);
d3113 11
a3123 6
  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3125 4
a3128 6
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 4, 4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3131 4
a3134 7
  if (skip_past_comma (& str) == FAIL
      || (rd = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3136 2
a3137 7
  if (skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 16)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3139 1
a3139 4
  /* Unpredictable result if rd or rn is R15.  */
  if (rd == REG_PC || rn == REG_PC)
    as_tsktsk
      (_("Warning: instruction unpredictable when using r15"));
d3141 4
a3144 7
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3146 1
a3146 2
  end_of_line (str);
}
d3148 1
a3148 4
/* ARM V5 count-leading-zeroes instruction (argument parse)
     CLZ{<cond>} <Rd>, <Rm>
     Condition defaults to COND_ALWAYS.
     Error if Rd or Rm are R15.  */
d3150 4
a3153 4
static void
do_clz (char * str)
{
  int rd, rm;
d3155 1
a3155 1
  skip_whitespace (str);
d3157 1
a3157 4
  if (((rd = reg_required_here (& str, 12)) == FAIL)
      || (skip_past_comma (& str) == FAIL)
      || ((rm = reg_required_here (& str, 0)) == FAIL))
    inst.error = BAD_ARGS;
d3159 1
a3159 2
  else if (rd == REG_PC || rm == REG_PC )
    inst.error = BAD_PC;
d3161 3
a3163 3
  else
    end_of_line (str);
}
d3165 2
a3166 5
/* ARM V5 (argument parse)
     LDC2{L} <coproc>, <CRd>, <addressing mode>
     STC2{L} <coproc>, <CRd>, <addressing mode>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as LDC/STC.  */
d3168 2
a3169 2
static void
do_lstc2 (char * str)
d3171 2
a3172 1
  skip_whitespace (str);
d3174 1
a3174 1
  if (co_proc_number (& str) == FAIL)
d3176 15
a3190 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d3192 2
a3193 2
  else if (skip_past_comma (& str) == FAIL
	   || cp_reg_required_here (& str, 12) == FAIL)
d3195 2
a3196 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d3198 4
a3201 2
  else if (skip_past_comma (& str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
d3203 1
a3203 6
      if (! inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}
d3205 2
a3206 4
/* ARM V5 (argument parse)
     CDP2 <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as CDP.  */
d3208 4
a3211 4
static void
do_cdp2 (char * str)
{
  skip_whitespace (str);
d3213 14
a3226 5
  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3229 1
a3229 2
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 20,4) == FAIL)
d3231 2
a3232 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3235 4
a3238 2
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 12) == FAIL)
d3240 30
a3269 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3271 2
a3272 7
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3274 4
a3277 7
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3279 14
a3292 7
  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
d3296 10
a3305 1
  end_of_line (str);
d3308 1
a3308 5
/* ARM V5 (argument parse)
     MCR2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     MRC2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as MCR/MRC.  */
d3310 4
a3313 2
static void
do_co_reg2 (char * str)
d3315 23
a3337 1
  skip_whitespace (str);
d3339 2
a3340 6
  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3342 3
a3344 7
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 21, 3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3346 3
a3348 7
  if (skip_past_comma (& str) == FAIL
      || reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3350 1
a3350 6
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3352 1
a3352 3

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
d3354 2
a3355 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3357 1
a3357 8
  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
d3359 2
d3362 3
a3364 1
  end_of_line (str);
d3367 5
a3371 2
static void
do_bx (char * str)
d3373 13
a3385 1
  int reg;
d3387 4
a3390 1
  skip_whitespace (str);
d3392 2
a3393 1
  if ((reg = reg_required_here (&str, 0)) == FAIL)
d3395 2
a3396 2
      inst.error = BAD_ARGS;
      return;
d3399 2
a3400 5
  /* Note - it is not illegal to do a "bx pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));

  end_of_line (str);
d3403 2
a3404 1
/* ARM v5TEJ.  Jump to Jazelle code.  */
d3406 2
a3407 2
static void
do_bxj (char * str)
d3409 2
a3410 1
  int reg;
d3412 9
a3420 1
  skip_whitespace (str);
d3422 1
a3422 1
  if ((reg = reg_required_here (&str, 0)) == FAIL)
d3424 2
a3425 2
      inst.error = BAD_ARGS;
      return;
d3428 2
a3429 5
  /* Note - it is not illegal to do a "bxj pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  end_of_line (str);
d3432 3
a3434 1
/* ARM V6 umaal (argument parse).  */
d3436 2
a3437 2
static void
do_umaal (char * str)
d3439 2
a3440 1
  int rdlo, rdhi, rm, rs;
d3442 3
a3444 8
  skip_whitespace (str);
  if ((rdlo = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rdhi = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
d3446 2
a3447 2
      inst.error = BAD_ARGS;
      return;
d3450 4
a3453 1
  if (rdlo == REG_PC || rdhi == REG_PC || rm == REG_PC || rs == REG_PC)
d3455 8
a3462 2
      inst.error = BAD_PC;
      return;
a3463 2

  end_of_line (str);
d3466 7
a3472 1
/* ARM V6 strex (argument parse).  */
d3474 3
a3476 4
static void
do_strex (char * str)
{
  int rd, rm, rn;
d3478 2
a3479 6
  /* Parse Rd, Rm,.  */
  skip_whitespace (str);
  if ((rd = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL)
d3481 2
a3482 12
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  if (rd == rm)
    {
      inst.error = _("Rd equal to Rm or Rn yields unpredictable results");
      return;
d3485 8
a3492 4
  /* Skip past '['.  */
  if ((strlen (str) >= 1)
      && strncmp (str, "[", 1) == 0)
    str += 1;
d3494 166
a3659 1
  skip_whitespace (str);
d3661 30
a3690 17
  /* Parse Rn.  */
  if ((rn = reg_required_here (& str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  if (rd == rn)
    {
      inst.error = _("Rd equal to Rm or Rn yields unpredictable results");
      return;
    }
  skip_whitespace (str);
d3692 17
a3708 4
  /* Skip past ']'.  */
  if ((strlen (str) >= 1)
      && strncmp (str, "]", 1) == 0)
    str += 1;
d3710 5
a3714 2
  end_of_line (str);
}
d3716 4
a3719 1
/* KIND indicates what kind of shifts are accepted.  */
d3721 18
a3738 6
static int
decode_shift (char ** str, int kind)
{
  const struct asm_shift_name * shift;
  char * p;
  char   c;
d3740 21
a3760 1
  skip_whitespace (* str);
d3762 15
a3776 2
  for (p = * str; ISALPHA (* p); p ++)
    ;
d3778 16
a3793 5
  if (p == * str)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }
d3795 3
a3797 4
  c = * p;
  * p = '\0';
  shift = (const struct asm_shift_name *) hash_find (arm_shift_hsh, * str);
  * p = c;
d3799 3
a3801 5
  if (shift == NULL)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }
d3803 4
a3806 1
  assert (shift->properties->index == shift_properties[shift->properties->index].index);
d3808 3
a3810 19
  if (kind == SHIFT_LSL_OR_ASR_IMMEDIATE
      && shift->properties->index != SHIFT_LSL
      && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'LSL' or 'ASR' required");
      return FAIL;
    }
  else if (kind == SHIFT_LSL_IMMEDIATE
	   && shift->properties->index != SHIFT_LSL)
    {
      inst.error = _("'LSL' required");
      return FAIL;
    }
  else if (kind == SHIFT_ASR_IMMEDIATE
	   && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'ASR' required");
      return FAIL;
    }
d3812 3
a3814 6
  if (shift->properties->index == SHIFT_RRX)
    {
      * str = p;
      inst.instruction |= shift->properties->bit_field;
      return SUCCESS;
    }
d3816 3
a3818 1
  skip_whitespace (p);
d3820 3
a3822 14
  if (kind == NO_SHIFT_RESTRICT && reg_required_here (& p, 8) != FAIL)
    {
      inst.instruction |= shift->properties->bit_field | SHIFT_BY_REG;
      * str = p;
      return SUCCESS;
    }
  else if (! is_immediate_prefix (* p))
    {
      inst.error = (NO_SHIFT_RESTRICT
		    ? _("shift requires register or #expression")
		    : _("shift requires #expression"));
      * str = p;
      return FAIL;
    }
d3824 3
a3826 2
  inst.error = NULL;
  p ++;
d3828 13
a3840 2
  if (my_get_expression (& inst.reloc.exp, & p))
    return FAIL;
d3842 12
a3853 4
  /* Validate some simple #expressions.  */
  if (inst.reloc.exp.X_op == O_constant)
    {
      unsigned num = inst.reloc.exp.X_add_number;
d3855 2
a3856 23
      /* Reject operations greater than 32.  */
      if (num > 32
	  /* Reject a shift of 0 unless the mode allows it.  */
	  || (num == 0 && shift->properties->allows_0 == 0)
	  /* Reject a shift of 32 unless the mode allows it.  */
	  || (num == 32 && shift->properties->allows_32 == 0)
	  )
	{
	  /* As a special case we allow a shift of zero for
	     modes that do not support it to be recoded as an
	     logical shift left of zero (ie nothing).  We warn
	     about this though.  */
	  if (num == 0)
	    {
	      as_warn (_("shift of 0 ignored."));
	      shift = & shift_names[0];
	      assert (shift->properties->index == SHIFT_LSL);
	    }
	  else
	    {
	      inst.error = _("invalid immediate shift");
	      return FAIL;
	    }
d3859 6
a3864 4
      /* Shifts of 32 are encoded as 0, for those shifts that
	 support it.  */
      if (num == 32)
	num = 0;
d3866 3
a3868 8
      inst.instruction |= (num << 7) | shift->properties->bit_field;
    }
  else
    {
      inst.reloc.type   = BFD_RELOC_ARM_SHIFT_IMM;
      inst.reloc.pc_rel = 0;
      inst.instruction |= shift->properties->bit_field;
    }
d3870 7
a3876 3
  * str = p;
  return SUCCESS;
}
d3878 7
a3884 5
static void
do_sat (char ** str, int bias)
{
  int rd, rm;
  expressionS expr;
d3886 3
a3888 1
  skip_whitespace (*str);
d3890 2
a3891 12
  /* Parse <Rd>, field.  */
  if ((rd = reg_required_here (str, 12)) == FAIL
      || skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d3893 13
a3905 30
  /* Parse #<immed>,  field.  */
  if (is_immediate_prefix (**str))
    (*str)++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number + bias < 0
      || expr.X_add_number + bias > 31)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  inst.instruction |= (expr.X_add_number + bias) << 16;
  if (skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d3907 1
a3907 11
  /* Parse <Rm> field.  */
  if ((rm = reg_required_here (str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d3909 1
a3909 3
  if (skip_past_comma (str) == SUCCESS)
    decode_shift (str, SHIFT_LSL_OR_ASR_IMMEDIATE);
}
d3911 2
a3912 1
/* ARM V6 ssat (argument parse).  */
d3914 2
a3915 2
static void
do_ssat (char * str)
d3917 1
a3917 3
  do_sat (&str, /*bias=*/-1);
  end_of_line (str);
}
d3919 3
a3921 1
/* ARM V6 usat (argument parse).  */
d3923 1
a3923 5
static void
do_usat (char * str)
{
  do_sat (&str, /*bias=*/0);
  end_of_line (str);
d3926 4
a3929 2
static void
do_sat16 (char ** str, int bias)
d3931 1
a3931 2
  int rd, rm;
  expressionS expr;
d3933 2
a3934 1
  skip_whitespace (*str);
d3936 1
a3936 3
  /* Parse the <Rd> field.  */
  if ((rd = reg_required_here (str, 12)) == FAIL
      || skip_past_comma (str) == FAIL)
d3938 3
a3940 2
      inst.error = BAD_ARGS;
      return;
d3942 19
a3960 1
  if (rd == REG_PC)
d3962 7
a3968 3
      inst.error = BAD_PC;
      return;
    }
d3970 3
a3972 30
  /* Parse #<immed>, field.  */
  if (is_immediate_prefix (**str))
    (*str)++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number + bias < 0
      || expr.X_add_number + bias > 15)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  inst.instruction |= (expr.X_add_number + bias) << 16;
  if (skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d3974 2
a3975 10
  /* Parse <Rm> field.  */
  if ((rm = reg_required_here (str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
d3979 2
a3980 2
/* ARM V6 ssat16 (argument parse).  */

d3982 1
a3982 1
do_ssat16 (char * str)
d3984 13
a3996 2
  do_sat16 (&str, /*bias=*/-1);
  end_of_line (str);
d4000 1
a4000 1
do_usat16 (char * str)
d4002 7
a4008 2
  do_sat16 (&str, /*bias=*/0);
  end_of_line (str);
d4011 1
d4013 1
a4013 1
do_cps_mode (char ** str)
d4015 2
a4016 1
  expressionS expr;
d4018 1
a4018 3
  skip_whitespace (*str);

  if (! is_immediate_prefix (**str))
d4020 8
a4027 3
      inst.error = _("immediate expression expected");
      return;
    }
a4028 5
  (*str)++; /* Strip off the immediate signifier.  */
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
d4030 1
a4030 2

  if (expr.X_op != O_constant)
d4032 3
a4034 2
      inst.error = _("constant expression expected");
      return;
d4036 1
a4036 4

  /* The mode is a 5 bit field.  Valid values are 0-31.  */
  if (((unsigned) expr.X_add_number) > 31
      || (inst.reloc.exp.X_add_number) < 0)
d4038 1
a4038 1
      inst.error = _("invalid constant");
d4042 6
a4047 1
  inst.instruction |= expr.X_add_number;
d4050 4
a4053 2
/* ARM V6 srs (argument parse).  */

d4055 1
a4055 1
do_srs (char * str)
d4057 20
a4076 9
  char *exclam;
  skip_whitespace (str);
  exclam = strchr (str, '!');
  if (exclam)
    *exclam = '\0';
  do_cps_mode (&str);
  if (exclam)
    *exclam = '!';
  if (*str == '!')
d4078 4
a4081 2
      inst.instruction |= WRITE_BACK;
      str++;
a4082 1
  end_of_line (str);
d4085 5
a4089 2
/* ARM V6 SMMUL (argument parse).  */

d4091 1
a4091 1
do_smmul (char * str)
d4093 1
a4093 8
  int rd, rm, rs;

  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
d4095 1
a4095 1
      inst.error = BAD_ARGS;
d4099 3
a4101 3
  if (   rd == REG_PC
      || rm == REG_PC
      || rs == REG_PC)
d4103 11
a4113 2
      inst.error = BAD_PC;
      return;
a4114 2

  end_of_line (str);
d4117 6
a4122 1
/* ARM V6 SMLALD (argument parse).  */
d4124 2
a4125 2
static void
do_smlald (char * str)
d4127 1
a4127 1
  int rdlo, rdhi, rm, rs;
d4129 3
a4131 8
  skip_whitespace (str);
  if ((rdlo = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rdhi = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
d4133 9
a4141 2
      inst.error = BAD_ARGS;
      return;
d4144 4
a4147 4
  if (   rdlo == REG_PC
      || rdhi == REG_PC
      || rm == REG_PC
      || rs == REG_PC)
d4149 11
a4159 2
      inst.error = BAD_PC;
      return;
d4162 7
a4168 1
  end_of_line (str);
d4171 6
a4176 2
/* ARM V6 SMLAD (argument parse).  Signed multiply accumulate dual.
   smlad{x}{<cond>} Rd, Rm, Rs, Rn */
d4178 4
a4181 2
static void
do_smlad (char * str)
d4183 33
a4215 1
  int rd, rm, rs, rn;
d4217 10
a4226 11
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 12)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
d4229 1
a4229 4
  if (   rd == REG_PC
      || rn == REG_PC
      || rs == REG_PC
      || rm == REG_PC)
d4231 2
a4232 2
      inst.error = BAD_PC;
      return;
d4234 10
a4243 2

  end_of_line (str);
d4246 3
a4248 1
/* Returns true if the endian-specifier indicates big-endianness.  */
d4250 2
a4251 2
static int
do_endian_specifier (char * str)
d4253 1
a4253 1
  int big_endian = 0;
d4255 5
a4259 12
  skip_whitespace (str);
  if (strlen (str) < 2)
    inst.error = _("missing endian specifier");
  else if (strncasecmp (str, "BE", 2) == 0)
    {
      str += 2;
      big_endian = 1;
    }
  else if (strncasecmp (str, "LE", 2) == 0)
    str += 2;
  else
    inst.error = _("valid endian specifiers are be or le");
d4261 6
a4266 1
  end_of_line (str);
d4268 5
a4272 1
  return big_endian;
d4275 6
a4280 2
/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.
d4282 7
a4288 2
   setend <endian_specifier>, where <endian_specifier> is either
   BE or LE.  */
d4291 1
a4291 1
do_setend (char * str)
d4293 3
a4295 2
  if (do_endian_specifier (str))
    inst.instruction |= 0x200;
d4298 7
a4304 1
/* ARM V6 SXTH.
d4306 5
a4310 3
   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */
d4313 1
a4313 1
do_sxth (char * str)
d4315 3
a4317 6
  int rd, rm;
  expressionS expr;
  int rotation_clear_mask = 0xfffff3ff;
  int rotation_eight_mask = 0x00000400;
  int rotation_sixteen_mask = 0x00000800;
  int rotation_twenty_four_mask = 0x00000c00;
d4319 3
a4321 8
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d4323 2
a4324 5
  else if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d4326 4
a4329 2
  /* Zero out the rotation field.  */
  inst.instruction &= rotation_clear_mask;
d4331 8
a4338 6
  /* Check for lack of optional rotation field.  */
  if (skip_past_comma (&str) == FAIL)
    {
      end_of_line (str);
      return;
    }
d4340 4
a4343 9
  /* Move past 'ROR'.  */
  skip_whitespace (str);
  if (strncasecmp (str, "ROR", 3) == 0)
    str += 3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return;
    }
d4345 4
a4348 9
  /* Get the immediate constant.  */
  skip_whitespace (str);
  if (is_immediate_prefix (* str))
    str++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
d4350 9
a4358 5
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }
d4360 9
a4368 5
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
d4370 11
a4380 8
  switch (expr.X_add_number)
    {
    case 0:
      /* Rotation field has already been zeroed.  */
      break;
    case 8:
      inst.instruction |= rotation_eight_mask;
      break;
d4382 4
a4385 3
    case 16:
      inst.instruction |= rotation_sixteen_mask;
      break;
d4387 4
a4390 3
    case 24:
      inst.instruction |= rotation_twenty_four_mask;
      break;
d4392 9
a4400 4
    default:
      inst.error = _("rotation can be 8, 16, 24 or 0 when field is ommited");
      break;
    }
d4402 9
a4410 1
  end_of_line (str);
d4413 5
a4417 7
/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
   extends it to 32-bits, and adds the result to a value in another
   register.  You can specify a rotation by 0, 8, 16, or 24 bits
   before extracting the 16-bit value.
   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */
d4420 1
a4420 1
do_sxtah (char * str)
d4422 6
a4427 6
  int rd, rn, rm;
  expressionS expr;
  int rotation_clear_mask = 0xfffff3ff;
  int rotation_eight_mask = 0x00000400;
  int rotation_sixteen_mask = 0x00000800;
  int rotation_twenty_four_mask = 0x00000c00;
d4429 4
a4432 6
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
d4434 4
a4437 2
      inst.error = BAD_ARGS;
      return;
d4439 1
a4439 2

  else if (rd == REG_PC || rn == REG_PC || rm == REG_PC)
d4441 2
a4442 2
      inst.error = BAD_PC;
      return;
d4444 7
d4452 7
a4458 2
  /* Zero out the rotation field.  */
  inst.instruction &= rotation_clear_mask;
d4460 4
a4463 2
  /* Check for lack of optional rotation field.  */
  if (skip_past_comma (&str) == FAIL)
d4465 4
a4468 3
      end_of_line (str);
      return;
    }
d4470 1
a4470 8
  /* Move past 'ROR'.  */
  skip_whitespace (str);
  if (strncasecmp (str, "ROR", 3) == 0)
    str += 3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return;
a4471 5

  /* Get the immediate constant.  */
  skip_whitespace (str);
  if (is_immediate_prefix (* str))
    str++;
d4474 5
a4478 2
      inst.error = _("immediate expression expected");
      return;
d4480 1
d4482 5
a4486 5
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }
d4488 2
a4489 5
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
a4490 5
  switch (expr.X_add_number)
    {
    case 0:
      /* Rotation field has already been zeroed.  */
      break;
d4492 1
a4492 3
    case 8:
      inst.instruction |= rotation_eight_mask;
      break;
d4494 5
a4498 3
    case 16:
      inst.instruction |= rotation_sixteen_mask;
      break;
d4500 2
a4501 3
    case 24:
      inst.instruction |= rotation_twenty_four_mask;
      break;
d4503 28
a4530 4
    default:
      inst.error = _("rotation can be 8, 16, 24 or 0 when field is ommited");
      break;
    }
d4532 9
a4540 1
  end_of_line (str);
d4543 12
d4556 9
a4564 5
/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
   word at the specified address and the following word
   respectively.
   Unconditionally executed.
   Error if Rn is R15.  */
d4567 1
a4567 1
do_rfe (char * str)
d4569 3
a4571 1
  int rn;
d4573 7
a4579 1
  skip_whitespace (str);
d4581 5
a4585 2
  if ((rn = reg_required_here (&str, 16)) == FAIL)
    return;
d4587 2
a4588 5
  if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d4590 2
a4591 1
  skip_whitespace (str);
d4593 1
a4593 1
  if (*str == '!')
d4596 21
a4616 1
      str++;
a4617 1
  end_of_line (str);
d4620 5
a4624 5
/* ARM V6 REV (Byte Reverse Word) reverses the byte order in a 32-bit
   register (argument parse).
   REV{<cond>} Rd, Rm.
   Condition defaults to COND_ALWAYS.
   Error if Rd or Rm are R15.  */
d4627 1
a4627 1
do_rev (char * str)
d4629 7
a4635 1
  int rd, rm;
d4637 8
a4644 1
  skip_whitespace (str);
d4646 4
a4649 4
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    inst.error = BAD_ARGS;
d4651 7
a4657 2
  else if (rd == REG_PC || rm == REG_PC)
    inst.error = BAD_PC;
d4659 2
a4660 2
  else
    end_of_line (str);
a4662 5
/* ARM V6 Perform Two Sixteen Bit Integer Additions. (argument parse).
   QADD16{<cond>} <Rd>, <Rn>, <Rm>
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

d4664 1
a4664 1
do_qadd16 (char * str)
d4666 5
a4670 1
  int rd, rm, rn;
d4672 5
a4676 1
  skip_whitespace (str);
d4678 4
a4681 6
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    inst.error = BAD_ARGS;
d4683 11
a4693 2
  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;
d4695 2
a4696 2
  else
    end_of_line (str);
d4700 1
a4700 1
do_pkh_core (char * str, int shift)
d4702 3
a4704 10
  int rd, rn, rm;

  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL)
      || ((rn = reg_required_here (&str, 16)) == FAIL)
      || (skip_past_comma (&str) == FAIL)
      || ((rm = reg_required_here (&str, 0)) == FAIL))
    {
      inst.error = BAD_ARGS;
d4706 2
a4707 1
    }
d4709 6
a4714 1
  else if (rd == REG_PC || rn == REG_PC || rm == REG_PC)
d4716 3
a4718 3
      inst.error = BAD_PC;
      return;
    }
d4720 3
a4722 13
  /* Check for optional shift immediate constant.  */
  if (skip_past_comma (&str) == FAIL)
    {
      if (shift == SHIFT_ASR_IMMEDIATE)
	{
	  /* If the shift specifier is ommited, turn the instruction
	     into pkhbt rd, rm, rn.  First, switch the instruction
	     code, and clear the rn and rm fields.  */
	  inst.instruction &= 0xfff0f010;
	  /* Now, re-encode the registers.  */
	  inst.instruction |= (rm << 16) | rn;
	}
      return;
d4724 2
a4725 2

  decode_shift (&str, shift);
d4728 1
a4728 4
/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>}
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */
d4731 1
a4731 1
do_pkhbt (char * str)
d4733 5
a4737 1
  do_pkh_core (str, SHIFT_LSL_IMMEDIATE);
d4740 18
a4757 1
/* ARM V6 PKHTB (Argument Parse).  */
d4759 2
d4762 1
a4762 1
do_pkhtb (char * str)
d4764 3
a4766 1
  do_pkh_core (str, SHIFT_ASR_IMMEDIATE);
a4768 6
/* ARM V6 Load Register Exclusive instruction (argument parse).
   LDREX{,B,D,H}{<cond>} <Rd, [<Rn>]
   Condition defaults to COND_ALWAYS.
   Error if Rd or Rn are R15.
   See ARMARMv6 A4.1.27: LDREX.  */

d4770 1
a4770 1
do_ldrex (char * str)
d4772 5
a4776 1
  int rd, rn;
d4778 4
a4781 1
  skip_whitespace (str);
d4783 1
a4783 13
  /* Parse Rd.  */
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  skip_whitespace (str);
d4785 6
a4790 5
  /* Skip past '['.  */
  if ((strlen (str) >= 1)
      &&strncmp (str, "[", 1) == 0)
    str += 1;
  skip_whitespace (str);
d4792 9
a4800 12
  /* Parse Rn.  */
  if ((rn = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  skip_whitespace (str);
d4802 9
a4810 6
  /* Skip past ']'.  */
  if ((strlen (str) >= 1)
      && strncmp (str, "]", 1) == 0)
    str += 1;

  end_of_line (str);
d4813 3
a4815 2
/* ARM V6 change processor state instruction (argument parse)
      CPS, CPSIE, CSPID .  */
d4818 1
a4818 1
do_cps (char * str)
d4820 9
a4828 2
  do_cps_mode (&str);
  end_of_line (str);
d4832 1
a4832 1
do_cps_flags (char ** str, int thumb_p)
d4834 5
a4838 12
  struct cps_flag
  {
    char character;
    unsigned long arm_value;
    unsigned long thumb_value;
  };
  static struct cps_flag flag_table[] =
  {
    {'a', 0x100, 0x4 },
    {'i', 0x080, 0x2 },
    {'f', 0x040, 0x1 }
  };
d4840 3
a4842 1
  int saw_a_flag = 0;
d4844 5
a4848 1
  skip_whitespace (*str);
d4850 7
a4856 5
  /* Get the a, f and i flags.  */
  while (**str && **str != ',')
    {
      struct cps_flag *p;
      struct cps_flag *q = flag_table + sizeof (flag_table)/sizeof (*p);
d4858 5
a4862 17
      for (p = flag_table; p < q; ++p)
	if (strncasecmp (*str, &p->character, 1) == 0)
	  {
	    inst.instruction |= (thumb_p ? p->thumb_value : p->arm_value);
	    saw_a_flag = 1;
	    break;
	  }
      if (p == q)
	{
	  inst.error = _("unrecognized flag");
	  return;
	}
      (*str)++;
    }

  if (!saw_a_flag)
    inst.error = _("no 'a', 'i', or 'f' flags for 'cps'");
d4866 1
a4866 1
do_cpsi (char * str)
d4868 1
a4868 3
  do_cps_flags (&str, /*thumb_p=*/0);

  if (skip_past_comma (&str) == SUCCESS)
d4870 3
a4872 2
      skip_whitespace (str);
      do_cps_mode (&str);
a4873 1
  end_of_line (str);
d4876 4
a4879 1
/* ARM V6T2 bitfield manipulation instructions.  */
d4881 2
a4882 2
static int
five_bit_unsigned_immediate (char **str)
d4884 8
a4891 1
  expressionS expr;
d4893 4
a4896 2
  skip_whitespace (*str);
  if (!is_immediate_prefix (**str))
d4898 6
a4903 2
      inst.error = _("immediate expression expected");
      return -1;
d4905 1
a4905 12
  (*str)++;
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return -1;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return -1;
    }
  if (expr.X_add_number < 0 || expr.X_add_number > 32)
d4907 4
a4910 2
      inst.error = _("immediate value out of range");
      return -1;
a4911 2
  
  return expr.X_add_number;
d4914 6
d4921 1
a4921 1
bfci_lsb_and_width (char *str)
d4923 22
a4944 1
  int lsb, width;
d4946 5
a4950 2
  if ((lsb = five_bit_unsigned_immediate (&str)) == -1)
    return;
d4952 7
a4958 7
  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if ((width = five_bit_unsigned_immediate (&str)) == -1)
    return;
d4960 1
a4960 1
  end_of_line (str);
d4962 6
a4967 10
  if (width == 0 || lsb == 32)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  else if (width + lsb > 32)
    {
      inst.error = _("bit-field extends past end of register");
      return;
    }
d4969 2
a4970 3
  /* Convert to LSB/MSB and write to register.  */
  inst.instruction |= lsb << 7;
  inst.instruction |= (width + lsb - 1) << 16;
d4973 2
d4976 1
a4976 1
do_bfc (char *str)
d4978 7
a4984 1
  int rd;
d4986 1
a4986 13
  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d4988 6
a4993 1
  bfci_lsb_and_width (str);
d4997 1
a4997 1
do_bfi (char *str)
d4999 4
a5002 1
  int rd, rm;
d5004 2
a5005 13
  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d5007 2
a5008 41
  /* Rm.  Accept #0 in this position as an alternative syntax for bfc.  */
  skip_whitespace (str);
  if (is_immediate_prefix (*str))
    {
      expressionS expr;
      str++;
      if (my_get_expression (&expr, &str))
	{
	  inst.error = _("bad expression");
	  return;
	}
      if (expr.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return;
	}
      if (expr.X_add_number != 0)
	{
	  inst.error = _("immediate value out of range");
	  return;
	}
      inst.instruction |= 0x0000000f;  /* Rm = PC -> bfc, not bfi.  */
    }
  else
    {
      if ((rm = reg_required_here (&str, 0)) == FAIL)
	{
	  inst.error = BAD_ARGS;
	  return;
	}
      else if (rm == REG_PC)
	{
	  inst.error = BAD_PC;
	  return;
	}
    }
  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d5010 5
a5014 1
  bfci_lsb_and_width (str);
d5018 1
a5018 1
do_bfx (char *str)
d5020 3
a5022 1
  int lsb, width;
d5024 3
a5026 4
  /* Rd.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL)
d5028 4
a5031 2
      inst.error = BAD_ARGS;
      return;
d5033 3
d5037 6
a5042 8
  /* Rm.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 0) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d5044 6
a5049 2
  if ((lsb = five_bit_unsigned_immediate (&str)) == -1)
    return;
d5051 4
a5054 7
  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if ((width = five_bit_unsigned_immediate (&str)) == -1)
    return;
d5056 8
a5063 1
  end_of_line (str);
d5065 4
a5068 14
  if (width == 0 || lsb == 32)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  else if (width + lsb > 32)
    {
      inst.error = _("bit-field extends past end of register");
      return;
    }

  inst.instruction |= lsb << 7;
  inst.instruction |= (width - 1) << 16;
}
d5071 1
a5071 1
do_rbit (char *str)
d5073 4
a5076 8
  /* Rd.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d5078 3
a5080 7
  /* Rm.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 0) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d5082 3
a5084 2
  end_of_line (str);
}
a5085 1
/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.  */
d5087 1
a5087 1
do_mov16 (char *str)
d5089 4
a5092 2
  int rd;
  expressionS expr;
d5094 1
a5094 13
  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d5096 7
a5102 23
  /* Imm16.  */
  skip_whitespace (str);
  if (!is_immediate_prefix (*str))
    {
      inst.error = _("immediate expression expected");
      return;
    }
  str++;
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number < 0 || expr.X_add_number > 65535)
    {
      inst.error = _("immediate value out of range");
      return;
    }
d5104 1
a5104 1
  end_of_line (str);
d5106 22
a5127 3
  /* The value is in two pieces: 0:11, 16:19.  */
  inst.instruction |= (expr.X_add_number & 0x00000fff);
  inst.instruction |= (expr.X_add_number & 0x0000f000) << 4;
a5128 4
  

/* THUMB V5 breakpoint instruction (argument parse)
	BKPT <immed_8>.  */
d5131 1
a5131 1
do_t_bkpt (char * str)
d5133 18
a5150 2
  expressionS expr;
  unsigned long number;
d5152 7
a5158 1
  skip_whitespace (str);
d5160 8
a5167 13
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str ++;

  memset (& expr, '\0', sizeof (expr));
  if (my_get_expression (& expr, & str)
      || (expr.X_op != O_constant
	  /* As a convenience we allow 'bkpt' without an operand.  */
	  && expr.X_op != O_absent))
    {
      inst.error = _("bad expression");
      return;
    }
d5169 1
a5169 1
  number = expr.X_add_number;
d5171 3
a5173 6
  /* Check it fits an 8 bit unsigned.  */
  if (number != (number & 0xff))
    {
      inst.error = _("immediate value out of range");
      return;
    }
d5175 10
a5184 1
  inst.instruction |= number;
d5186 5
a5190 1
  end_of_line (str);
d5193 2
a5194 3
#ifdef OBJ_ELF
static bfd_reloc_code_real_type
arm_parse_reloc (void)
d5196 4
a5199 28
  char         id [16];
  char *       ip;
  unsigned int i;
  static struct
  {
    char * str;
    int    len;
    bfd_reloc_code_real_type reloc;
  }
  reloc_map[] =
  {
#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }
    MAP ("(got)",    BFD_RELOC_ARM_GOT32),
    MAP ("(gotoff)", BFD_RELOC_ARM_GOTOFF),
    /* ScottB: Jan 30, 1998 - Added support for parsing "var(PLT)"
       branch instructions generated by GCC for PLT relocs.  */
    MAP ("(plt)",    BFD_RELOC_ARM_PLT32),
    MAP ("(target1)", BFD_RELOC_ARM_TARGET1),
    MAP ("(sbrel)", BFD_RELOC_ARM_SBREL32),
    MAP ("(target2)", BFD_RELOC_ARM_TARGET2),
    MAP ("(tlsgd)", BFD_RELOC_ARM_TLS_GD32),
    MAP ("(tlsldm)", BFD_RELOC_ARM_TLS_LDM32),
    MAP ("(tlsldo)", BFD_RELOC_ARM_TLS_LDO32),
    MAP ("(gottpoff)", BFD_RELOC_ARM_TLS_IE32),
    MAP ("(tpoff)", BFD_RELOC_ARM_TLS_LE32),
    { NULL, 0,         BFD_RELOC_UNUSED }
#undef MAP
  };
d5201 5
a5205 4
  for (i = 0, ip = input_line_pointer;
       i < sizeof (id) && (ISALNUM (*ip) || ISPUNCT (*ip));
       i++, ip++)
    id[i] = TOLOWER (*ip);
d5207 6
a5212 3
  for (i = 0; reloc_map[i].str; i++)
    if (strncmp (id, reloc_map[i].str, reloc_map[i].len) == 0)
      break;
d5214 6
a5219 1
  input_line_pointer += reloc_map[i].len;
d5221 5
a5225 1
  return reloc_map[i].reloc;
a5226 1
#endif
d5228 9
a5236 4
/* ARM V5 branch-link-exchange (argument parse) for BLX(1) only.
   Expects inst.instruction is set for BLX(1).
   Note: this is cloned from do_branch, and the reloc changed to be a
	new one that can cope with setting one extra bit (the H bit).  */
d5239 1
a5239 1
do_branch25 (char * str)
d5241 3
a5243 2
  if (my_get_expression (& inst.reloc.exp, & str))
    return;
d5245 9
a5253 3
#ifdef OBJ_ELF
  {
    char * save_in;
d5255 6
a5260 2
    /* ScottB: February 5, 1998 */
    /* Check to see of PLT32 reloc required for the instruction.  */
d5262 5
a5266 30
    /* arm_parse_reloc() works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;

    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BLX;
	inst.reloc.pc_rel = 1;
      }

    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BLX;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF */

  end_of_line (str);
a5268 7
/* ARM V5 branch-link-exchange instruction (argument parse)
     BLX <target_addr>		ie BLX(1)
     BLX{<condition>} <Rm>	ie BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */
d5271 1
a5271 1
do_blx (char * str)
d5273 2
a5274 17
  char * mystr = str;
  int rm;

  skip_whitespace (mystr);
  rm = reg_required_here (& mystr, 0);

  /* The above may set inst.error.  Ignore his opinion.  */
  inst.error = 0;

  if (rm != FAIL)
    {
      /* Arg is a register.
	 Use the condition code our caller put in inst.instruction.
	 Pass ourselves off as a BX with a funny opcode.  */
      inst.instruction |= 0x012fff30;
      do_bx (str);
    }
d5276 5
a5280 14
    {
      /* This must be is BLX <target address>, no condition allowed.  */
      if (inst.instruction != COND_ALWAYS)
	{
	  inst.error = BAD_COND;
	  return;
	}

      inst.instruction = 0xfafffffe;

      /* Process like a B/BL, but with a different reloc.
	 Note that B/BL expecte fffffe, not 0, offset in the opcode table.  */
      do_branch25 (str);
    }
a5282 7
/* ARM V5 Thumb BLX (argument parse)
	BLX <target_addr>	which is BLX(1)
	BLX <Rm>		which is BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the tinsns[].value is not used, and the code here zaps values
	into inst.instruction.	*/

d5284 1
a5284 1
do_t_blx (char * str)
d5286 1
a5286 5
  char * mystr = str;
  int rm;

  skip_whitespace (mystr);
  inst.instruction = 0x4780;
d5288 2
a5289 11
  /* Note that this call is to the ARM register recognizer.  BLX(2)
     uses the ARM register space, not the Thumb one, so a call to
     thumb_reg() would be wrong.  */
  rm = reg_required_here (& mystr, 3);
  inst.error = 0;

  if (rm != FAIL)
    {
      /* It's BLX(2).  The .instruction was zapped with rm & is final.  */
      inst.size = 2;
    }
d5291 2
a5292 4
    {
      /* No ARM register.  This must be BLX(1).  Change the .instruction.  */
      inst.instruction = 0xf7ffeffe;
      inst.size = 4;
d5294 2
a5295 2
      if (my_get_expression (& inst.reloc.exp, & mystr))
	return;
d5297 3
a5299 3
      inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BLX;
      inst.reloc.pc_rel = 1;
    }
d5301 1
a5301 1
  end_of_line (mystr);
d5304 5
a5308 5
/* ARM V5 breakpoint instruction (argument parse)
     BKPT <16 bit unsigned immediate>
     Instruction is not conditional.
	The bit pattern given in insns[] has the COND_ALWAYS condition,
	and it is an error if the caller tried to override that.  */
d5311 1
a5311 1
do_bkpt (char * str)
d5313 2
a5314 2
  expressionS expr;
  unsigned long number;
d5316 5
a5320 1
  skip_whitespace (str);
d5322 5
a5326 14
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (* str))
    str++;

  memset (& expr, '\0', sizeof (expr));

  if (my_get_expression (& expr, & str)
      || (expr.X_op != O_constant
	  /* As a convenience we allow 'bkpt' without an operand.  */
	  && expr.X_op != O_absent))
    {
      inst.error = _("bad expression");
      return;
    }
d5328 4
a5331 16
  number = expr.X_add_number;

  /* Check it fits a 16 bit unsigned.  */
  if (number != (number & 0xffff))
    {
      inst.error = _("immediate value out of range");
      return;
    }

  /* Top 12 of 16 bits to bits 19:8.  */
  inst.instruction |= (number & 0xfff0) << 4;

  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= number & 0xf;

  end_of_line (str);
a5333 2
/* THUMB CPS instruction (argument parse).  */

d5335 1
a5335 1
do_t_cps (char * str)
d5337 1
a5337 2
  do_cps_flags (&str, /*thumb_p=*/1);
  end_of_line (str);
d5339 2
d5342 2
a5343 8
/* Parse and validate that a register is of the right form, this saves
   repeated checking of this information in many similar cases.
   Unlike the 32-bit case we do not insert the register into the opcode
   here, since the position is often unknown until the full instruction
   has been parsed.  */

static int
thumb_reg (char ** strp, int hi_lo)
d5345 2
a5346 28
  int reg;

  if ((reg = reg_required_here (strp, -1)) == FAIL)
    return FAIL;

  switch (hi_lo)
    {
    case THUMB_REG_LO:
      if (reg > 7)
	{
	  inst.error = _("lo register required");
	  return FAIL;
	}
      break;

    case THUMB_REG_HI:
      if (reg < 8)
	{
	  inst.error = _("hi register required");
	  return FAIL;
	}
      break;

    default:
      break;
    }

  return reg;
d5350 1
a5350 1
thumb_mov_compare (char * str, int move)
d5352 2
a5353 6
  int Rd, Rs = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
d5355 5
a5359 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d5362 1
a5362 1
  if (move != THUMB_CPY && is_immediate_prefix (*str))
d5364 7
a5370 42
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  if (Rs != FAIL)
    {
      if (move != THUMB_CPY && Rs < 8 && Rd < 8)
	{
	  if (move == THUMB_MOVE)
	    /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	       since a MOV instruction produces unpredictable results.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;
	  inst.instruction |= Rd | (Rs << 3);
	}
      else
	{
	  if (move == THUMB_MOVE)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else if (move != THUMB_CPY)
	    inst.instruction = T_OPCODE_CMP_HR;

	  if (Rd > 7)
	    inst.instruction |= THUMB_H1;

	  if (Rs > 7)
	    inst.instruction |= THUMB_H2;

	  inst.instruction |= (Rd & 7) | ((Rs & 7) << 3);
	}
    }
  else
    {
      if (Rd > 7)
	{
	  inst.error = _("only lo regs allowed with immediate");
	  return;
	}
d5372 2
a5373 4
      if (move == THUMB_MOVE)
	inst.instruction = T_OPCODE_MOV_I8;
      else
	inst.instruction = T_OPCODE_CMP_I8;
d5375 2
a5376 1
      inst.instruction |= Rd << 8;
d5378 1
a5378 3
      if (inst.reloc.exp.X_op != O_constant)
	inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
      else
d5380 2
a5381 9
	  unsigned value = inst.reloc.exp.X_add_number;

	  if (value > 255)
	    {
	      inst.error = _("invalid immediate");
	      return;
	    }

	  inst.instruction |= value;
d5385 1
a5385 1
  end_of_line (str);
d5387 2
a5388 2

/* THUMB CPY instruction (argument parse).  */
d5391 1
a5391 1
do_t_cpy (char * str)
d5393 1
a5393 1
  thumb_mov_compare (str, THUMB_CPY);
a5395 2
/* THUMB SETEND instruction (argument parse).  */

d5397 1
a5397 1
do_t_setend (char * str)
d5399 2
a5400 2
  if (do_endian_specifier (str))
    inst.instruction |= 0x8;
d5403 2
a5404 6
/* Parse INSN_TYPE insn STR having a possible IMMEDIATE_SIZE immediate.  */

static unsigned long
check_iwmmxt_insn (char * str,
		   enum iwmmxt_insn_type insn_type,
		   int immediate_size)
d5406 3
a5408 176
  int reg = 0;
  const char *  inst_error;
  expressionS expr;
  unsigned long number;

  inst_error = inst.error;
  if (!inst.error)
    inst.error = BAD_ARGS;
  skip_whitespace (str);

  switch (insn_type)
    {
    case check_rd:
      if ((reg = reg_required_here (&str, 12)) == FAIL)
	return FAIL;
      break;

    case check_wr:
       if ((wreg_required_here (&str, 0, IWMMXT_REG_WR)) == FAIL)
	 return FAIL;
       break;

    case check_wrwr:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;

    case check_wrwrwr:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;

    case check_wrwrwcg:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WCG) == FAIL))
	return FAIL;
      break;

    case check_tbcst:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;

    case check_tmovmsk:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;

    case check_tmia:
      if ((wreg_required_here (&str, 5, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 0) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;

    case check_tmcrr:
      if ((wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 16) == FAIL))
	return FAIL;
      break;

    case check_tmrrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 16) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;

    case check_tmcr:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WC) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;

    case check_tmrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WC) == FAIL))
	return FAIL;
      break;

    case check_tinsr:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;

    case check_textrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;

    case check_waligni:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;

    case check_textrm:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;

    case check_wshufh:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
    }

  if (immediate_size == 0)
    {
      end_of_line (str);
      inst.error = inst_error;
      return reg;
    }
  else
    {
      skip_whitespace (str);

      /* Allow optional leading '#'.  */
      if (is_immediate_prefix (* str))
        str++;

      memset (& expr, '\0', sizeof (expr));

      if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
        {
          inst.error = _("bad or missing expression");
          return FAIL;
        }

      number = expr.X_add_number;

      if (number != (number & immediate_size))
        {
          inst.error = _("immediate value out of range");
          return FAIL;
        }
      end_of_line (str);
      inst.error = inst_error;
      return number;
    }
d5412 1
a5412 1
do_iwmmxt_byte_addr (char * str)
d5414 3
a5416 24
  int op = (inst.instruction & 0x300) >> 8;
  int reg;

  inst.instruction &= ~0x300;
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;

  skip_whitespace (str);

  if ((reg = wreg_required_here (&str, 12, IWMMXT_REG_WR_OR_WC)) == FAIL
      || skip_past_comma (& str) == FAIL
      || cp_byte_address_required_here (&str) == FAIL)
    {
      if (! inst.error)
        inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);

  if (wc_register (reg))
    {
      as_bad (_("non-word size not supported with control register"));
      inst.instruction |=  0xf0000100;
      inst.instruction &= ~0x00400000;
    }
d5420 1
a5420 1
do_iwmmxt_tandc (char * str)
d5422 3
a5424 6
  int reg;

  reg = check_iwmmxt_insn (str, check_rd, 0);

  if (reg != REG_PC && !inst.error)
    inst.error = _("only r15 allowed here");
d5428 1
a5428 1
do_iwmmxt_tbcst (char * str)
d5430 4
a5433 1
  check_iwmmxt_insn (str, check_tbcst, 0);
d5437 1
a5437 1
do_iwmmxt_textrc (char * str)
d5439 4
a5442 6
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_textrc, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= number & 0x7;
d5446 1
a5446 1
do_iwmmxt_textrm (char * str)
d5448 3
a5450 6
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_textrm, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= number & 0x7;
d5454 1
a5454 1
do_iwmmxt_tinsr (char * str)
d5456 6
a5461 4
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_tinsr, 7)) == (unsigned long) FAIL)
    return;
d5463 2
a5464 1
  inst.instruction |= number & 0x7;
d5468 1
a5468 1
do_iwmmxt_tmcr (char * str)
d5470 2
a5471 1
  check_iwmmxt_insn (str, check_tmcr, 0);
d5475 1
a5475 1
do_iwmmxt_tmcrr (char * str)
d5477 4
a5480 1
  check_iwmmxt_insn (str, check_tmcrr, 0);
d5484 1
a5484 1
do_iwmmxt_tmia (char * str)
d5486 4
a5489 1
  check_iwmmxt_insn (str, check_tmia, 0);
d5491 3
d5495 1
a5495 5
static void
do_iwmmxt_tmovmsk (char * str)
{
  check_iwmmxt_insn (str, check_tmovmsk, 0);
}
d5498 1
a5498 1
do_iwmmxt_tmrc (char * str)
d5500 3
a5502 1
  check_iwmmxt_insn (str, check_tmrc, 0);
d5505 2
a5506 5
static void
do_iwmmxt_tmrrc (char * str)
{
  check_iwmmxt_insn (str, check_tmrrc, 0);
}
d5509 1
a5509 1
do_iwmmxt_torc (char * str)
d5511 4
a5514 1
  check_iwmmxt_insn (str, check_rd, 0);
d5517 1
d5519 1
a5519 1
do_iwmmxt_waligni (char * str)
d5521 1
a5521 6
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_waligni, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((number & 0x7) << 20);
d5524 3
a5526 8
static void
do_iwmmxt_wmov (char * str)
{
  if (check_iwmmxt_insn (str, check_wrwr, 0) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((inst.instruction >> 16) & 0xf);
}
d5529 1
a5529 1
do_iwmmxt_word_addr (char * str)
d5531 1
a5531 2
  int op = (inst.instruction & 0x300) >> 8;
  int reg;
d5533 2
a5534 2
  inst.instruction &= ~0x300;
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;
d5536 4
a5539 1
  skip_whitespace (str);
d5541 4
a5544 9
  if ((reg = wreg_required_here (&str, 12, IWMMXT_REG_WR_OR_WC)) == FAIL
      || skip_past_comma (& str) == FAIL
      || cp_address_required_here (& str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
        inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
d5546 4
a5549 10
  if (wc_register (reg))
    {
      if ((inst.instruction & COND_MASK) != COND_ALWAYS)
	as_bad (_("conditional execution not supported with control register"));
      if (op != 2)
	as_bad (_("non-word size not supported with control register"));
      inst.instruction |=  0xf0000100;
      inst.instruction &= ~0x00400000;
    }
}
d5552 1
a5552 1
do_iwmmxt_wrwr (char * str)
d5554 2
a5555 1
  check_iwmmxt_insn (str, check_wrwr, 0);
d5558 3
a5560 5
static void
do_iwmmxt_wrwrwcg (char * str)
{
  check_iwmmxt_insn (str, check_wrwrwcg, 0);
}
d5563 1
a5563 1
do_iwmmxt_wrwrwr (char * str)
d5565 2
a5566 1
  check_iwmmxt_insn (str, check_wrwrwr, 0);
d5569 1
a5569 4
static void
do_iwmmxt_wshufh (char * str)
{
  unsigned long number;
d5571 1
a5571 5
  if ((number = check_iwmmxt_insn (str, check_wshufh, 0xff)) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((number & 0xf0) << 16) | (number & 0xf);
}
d5574 1
a5574 1
do_iwmmxt_wzero (char * str)
d5576 3
a5578 4
  if (check_iwmmxt_insn (str, check_wr, 0) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((inst.instruction & 0xf) << 12) | ((inst.instruction & 0xf) << 16);
d5580 2
d5583 2
a5584 4
/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */
d5587 1
a5587 1
do_xsc_mia (char * str)
d5589 2
a5590 2
  int rs;
  int rm;
d5592 7
a5598 2
  if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;
d5600 4
a5603 3
  else if (skip_past_comma (& str) == FAIL
	   || (rm = reg_required_here (& str, 0)) == FAIL)
    inst.error = BAD_ARGS;
d5605 4
a5608 3
  else if (skip_past_comma (& str) == FAIL
	   || (rs = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d5610 4
a5613 6
  /* inst.instruction has now been zapped with both rm and rs.  */
  else if (rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rm or rs is R15.  */

  else
    end_of_line (str);
a5615 1
/* Xscale move-accumulator-register (argument parse)
d5617 5
a5621 1
     MARcc   acc0,RdLo,RdHi.  */
d5624 1
a5624 1
do_xsc_mar (char * str)
d5626 1
a5626 1
  int rdlo, rdhi;
d5628 2
a5629 2
  if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;
d5631 13
a5643 3
  else if (skip_past_comma (& str) == FAIL
	   || (rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d5645 136
a5780 3
  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;
d5782 1
a5782 3
  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */
d5784 2
a5785 3
  else
    end_of_line (str);
}
d5787 9
a5795 1
/* Xscale move-register-accumulator (argument parse)
d5797 28
a5824 1
     MRAcc   RdLo,RdHi,acc0.  */
d5826 35
a5860 5
static void
do_xsc_mra (char * str)
{
  int rdlo;
  int rdhi;
d5862 5
a5866 1
  skip_whitespace (str);
d5868 6
a5873 2
  if ((rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d5875 2
a5876 3
  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;
d5878 23
a5900 3
  else if  (skip_past_comma (& str) == FAIL
	    || accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;
d5902 6
a5907 3
  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == rdhi)
    inst.error = BAD_ARGS;	/* Undefined result if 2 writes to same reg.  */
d5909 1
a5909 4
  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */
  else
    end_of_line (str);
d5912 8
a5919 2
static int
ldst_extend (char ** str)
d5921 33
a5953 1
  int add = INDEX_UP;
d5955 11
a5965 1
  switch (**str)
d5967 10
a5976 5
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;
d5978 5
a5982 3
      if (inst.reloc.exp.X_op == O_constant)
	{
	  int value = inst.reloc.exp.X_add_number;
d5984 9
a5992 5
	  if (value < -4095 || value > 4095)
	    {
	      inst.error = _("address offset too large");
	      return FAIL;
	    }
d5994 5
a5998 5
	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
	    }
d6000 11
a6010 1
	  inst.instruction |= add | value;
d6014 29
a6042 2
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
	  inst.reloc.pc_rel = 0;
d6044 7
a6050 1
      return SUCCESS;
d6052 3
a6054 3
    case '-':
      add = 0;
      /* Fall through.  */
d6056 2
a6057 3
    case '+':
      (*str)++;
      /* Fall through.  */
d6059 8
a6066 3
    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;
d6068 11
a6078 6
      inst.instruction |= add | OFFSET_REG;
      if (skip_past_comma (str) == SUCCESS)
	return decode_shift (str, SHIFT_IMMEDIATE);

      return SUCCESS;
    }
d6081 4
a6084 1
/* ARMv5TE: Preload-Cache
d6086 4
a6089 1
    PLD <addr_mode>
d6091 10
a6100 1
  Syntactically, like LDR with B=1, W=0, L=1.  */
d6103 1
a6103 1
do_pld (char * str)
d6105 15
a6119 1
  int rd;
d6121 2
a6122 1
  skip_whitespace (str);
d6124 7
a6130 1
  if (* str != '[')
d6132 4
a6135 2
      inst.error = _("'[' expected after PLD mnemonic");
      return;
d6137 1
d6139 4
a6142 9
  ++str;
  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 16)) == FAIL)
    return;

  skip_whitespace (str);

  if (*str == ']')
d6144 1
a6144 6
      /* [Rn], ... ?  */
      ++str;
      skip_whitespace (str);

      /* Post-indexed addressing is not allowed with PLD.  */
      if (skip_past_comma (&str) == SUCCESS)
d6146 2
a6147 3
	  inst.error
	    = _("post-indexed expression used in preload instruction");
	  return;
d6149 1
a6149 1
      else if (*str == '!') /* [Rn]! */
d6151 3
a6153 2
	  inst.error = _("writeback used in preload instruction");
	  ++str;
a6154 2
      else /* [Rn] */
	inst.instruction |= INDEX_UP | PRE_INDEX;
d6156 1
a6156 1
  else /* [Rn, ...] */
d6158 3
a6160 1
      if (skip_past_comma (& str) == FAIL)
d6162 2
a6163 2
	  inst.error = _("pre-indexed expression expected");
	  return;
d6165 1
d6167 2
a6168 2
      if (ldst_extend (&str) == FAIL)
	return;
d6170 10
a6179 1
      skip_whitespace (str);
d6181 5
a6185 5
      if (* str != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}
d6187 11
a6197 2
      ++ str;
      skip_whitespace (str);
d6199 8
a6206 5
      if (* str == '!') /* [Rn]! */
	{
	  inst.error = _("writeback used in preload instruction");
	  ++ str;
	}
d6208 5
a6212 2
      inst.instruction |= PRE_INDEX;
    }
d6214 1
a6214 1
  end_of_line (str);
d6217 7
a6223 5
/* ARMv5TE load-consecutive (argument parse)
   Mode is like LDRH.

     LDRccD R, mode
     STRccD R, mode.  */
d6226 1
a6226 1
do_ldrd (char * str)
d6228 2
a6229 6
  int rd;
  int rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 12)) == FAIL)
d6231 6
a6236 2
      inst.error = BAD_ARGS;
      return;
d6238 1
a6238 3

  if (skip_past_comma (& str) == FAIL
      || (rn = ld_mode_required_here (& str)) == FAIL)
d6240 4
a6243 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6245 3
d6249 4
a6252 2
  /* inst.instruction has now been zapped with Rd and the addressing mode.  */
  if (rd & 1)		/* Unpredictable result if Rd is odd.  */
d6254 3
a6256 2
      inst.error = _("destination register must be even");
      return;
d6258 1
a6258 2

  if (rd == REG_LR)
d6260 3
a6262 2
      inst.error = _("r14 not allowed here");
      return;
d6264 10
d6275 8
a6282 4
  if (((rd == rn) || (rd + 1 == rn))
      && ((inst.instruction & WRITE_BACK)
	  || (!(inst.instruction & PRE_INDEX))))
    as_warn (_("pre/post-indexing used when modified address register is destination"));
d6284 5
a6288 4
  /* For an index-register load, the index register must not overlap the
     destination (even if not write-back).  */
  if ((inst.instruction & V4_STR_BIT) == 0
      && (inst.instruction & HWOFFSET_IMM) == 0)
d6290 11
a6300 1
      int rm = inst.instruction & 0x0000000f;
d6302 1
a6302 2
      if (rm == rd || (rm == rd + 1))
	as_warn (_("ldrd destination registers must not overlap index register"));
d6305 1
a6305 1
  end_of_line (str);
d6308 2
a6309 5
/* Returns the index into fp_values of a floating point number,
   or -1 if not in the table.  */

static int
my_get_float_expression (char ** str)
d6311 5
a6315 5
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *         save_in;
  expressionS    exp;
  int            i;
  int            j;
d6317 17
a6333 1
  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));
d6335 5
a6339 5
  /* Look for a raw floating point number.  */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && is_end_of_line[(unsigned char) *save_in])
    {
      for (i = 0; i < NUM_FLOAT_VALS; i++)
d6341 3
a6343 1
	  for (j = 0; j < MAX_LITTLENUMS; j++)
d6345 5
a6349 2
	      if (words[j] != fp_values[i][j])
		break;
d6351 1
a6351 2

	  if (j == MAX_LITTLENUMS)
d6353 7
a6359 2
	      *str = save_in;
	      return i;
d6361 6
d6369 1
a6369 8

  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f").  */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
d6371 12
a6382 3
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.  */
      if (gen_to_words (words, 5, (long) 15) == 0)
d6384 7
a6390 7
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}
d6392 14
a6405 9
	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i;
		}
	    }
	}
    }
d6407 3
a6409 3
  *str = input_line_pointer;
  input_line_pointer = save_in;
  return -1;
d6412 2
a6413 4
/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expressionS * expr)
d6415 1
a6415 1
  if (in_my_get_expression)
d6417 4
a6420 3
      expr->X_op = O_illegal;
      if (inst.error == NULL)
	inst.error = _("bad expression");
d6422 6
d6430 16
a6445 9
/* Do those data_ops which can take a negative immediate constant
   by altering the instruction.  A bit of a hack really.
        MOV <-> MVN
        AND <-> BIC
        ADC <-> SBC
        by inverting the second operand, and
        ADD <-> SUB
        CMP <-> CMN
        by negating the second operand.  */
d6447 5
a6451 6
static int
negate_data_op (unsigned long * instruction,
		unsigned long   value)
{
  int op, new_inst;
  unsigned long negated, inverted;
d6453 1
a6453 2
  negated = validate_immediate (-value);
  inverted = validate_immediate (~value);
d6455 1
a6455 2
  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
  switch (op)
d6457 14
a6470 5
      /* First negates.  */
    case OPCODE_SUB:             /* ADD <-> SUB  */
      new_inst = OPCODE_ADD;
      value = negated;
      break;
d6472 13
a6484 4
    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
      value = negated;
      break;
d6486 6
a6491 4
    case OPCODE_CMP:             /* CMP <-> CMN  */
      new_inst = OPCODE_CMN;
      value = negated;
      break;
d6493 4
a6496 4
    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
      value = negated;
      break;
d6498 9
a6506 5
      /* Now Inverted ops.  */
    case OPCODE_MOV:             /* MOV <-> MVN  */
      new_inst = OPCODE_MVN;
      value = inverted;
      break;
d6508 4
a6511 4
    case OPCODE_MVN:
      new_inst = OPCODE_MOV;
      value = inverted;
      break;
d6513 13
a6525 4
    case OPCODE_AND:             /* AND <-> BIC  */
      new_inst = OPCODE_BIC;
      value = inverted;
      break;
d6527 4
a6530 4
    case OPCODE_BIC:
      new_inst = OPCODE_AND;
      value = inverted;
      break;
d6532 8
a6539 13
    case OPCODE_ADC:              /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
      value = inverted;
      break;

    case OPCODE_SBC:
      new_inst = OPCODE_ADC;
      value = inverted;
      break;

      /* We cannot do anything.  */
    default:
      return FAIL;
d6541 5
d6547 6
a6552 2
  if (value == (unsigned) FAIL)
    return FAIL;
d6554 7
a6560 3
  *instruction &= OPCODE_MASK;
  *instruction |= new_inst << DATA_OP_SHIFT;
  return value;
d6563 2
a6564 2
static int
data_op2 (char ** str)
d6566 5
a6570 2
  int value;
  expressionS expr;
d6572 34
a6605 1
  skip_whitespace (* str);
d6607 7
a6613 5
  if (reg_required_here (str, 0) != FAIL)
    {
      if (skip_past_comma (str) == SUCCESS)
	/* Shift operation on register.  */
	return decode_shift (str, NO_SHIFT_RESTRICT);
d6615 17
a6631 1
      return SUCCESS;
d6633 3
a6635 1
  else
d6637 1
a6637 2
      /* Immediate expression.  */
      if (is_immediate_prefix (**str))
d6639 6
a6644 2
	  (*str)++;
	  inst.error = NULL;
d6646 7
a6652 8
	  if (my_get_expression (&inst.reloc.exp, str))
	    return FAIL;

	  if (inst.reloc.exp.X_add_symbol)
	    {
	      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
	      inst.reloc.pc_rel = 0;
	    }
d6654 2
a6655 48
	    {
	      if (skip_past_comma (str) == SUCCESS)
		{
		  /* #x, y -- ie explicit rotation by Y.  */
		  if (my_get_expression (&expr, str))
		    return FAIL;

		  if (expr.X_op != O_constant)
		    {
		      inst.error = _("constant expression expected");
		      return FAIL;
		    }

		  /* Rotate must be a multiple of 2.  */
		  if (((unsigned) expr.X_add_number) > 30
		      || (expr.X_add_number & 1) != 0
		      || ((unsigned) inst.reloc.exp.X_add_number) > 255)
		    {
		      inst.error = _("invalid constant");
		      return FAIL;
		    }
		  inst.instruction |= INST_IMMEDIATE;
		  inst.instruction |= inst.reloc.exp.X_add_number;
		  inst.instruction |= expr.X_add_number << 7;
		  return SUCCESS;
		}

	      /* Implicit rotation, select a suitable one.  */
	      value = validate_immediate (inst.reloc.exp.X_add_number);

	      if (value == FAIL)
		{
		  /* Can't be done.  Perhaps the code reads something like
		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be OK.  */
		  if ((value = negate_data_op (&inst.instruction,
					       inst.reloc.exp.X_add_number))
		      == FAIL)
		    {
		      inst.error = _("invalid constant");
		      return FAIL;
		    }
		}

	      inst.instruction |= value;
	    }

	  inst.instruction |= INST_IMMEDIATE;
	  return SUCCESS;
d6657 7
a6663 4

      (*str)++;
      inst.error = _("register or shift expression expected");
      return FAIL;
d6667 2
a6668 2
static int
fp_op2 (char ** str)
d6670 6
a6675 1
  skip_whitespace (* str);
d6677 4
a6680 3
  if (fp_reg_required_here (str, 0) != FAIL)
    return SUCCESS;
  else
d6682 3
a6684 2
      /* Immediate expression.  */
      if (*((*str)++) == '#')
d6686 17
a6702 10
	  int i;

	  inst.error = NULL;

	  skip_whitespace (* str);

	  /* First try and match exact strings, this is to guarantee
	     that some formats will work even for cross assembly.  */

	  for (i = 0; fp_const[i]; i++)
d6704 3
a6706 12
	      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
		{
		  char *start = *str;

		  *str += strlen (fp_const[i]);
		  if (is_end_of_line[(unsigned char) **str])
		    {
		      inst.instruction |= i + 8;
		      return SUCCESS;
		    }
		  *str = start;
		}
d6708 1
a6708 6

	  /* Just because we didn't get a match doesn't mean that the
	     constant isn't valid, just that it is in a format that we
	     don't automatically recognize.  Try parsing it with
	     the standard expression routines.  */
	  if ((i = my_get_float_expression (str)) >= 0)
d6710 7
a6716 2
	      inst.instruction |= i + 8;
	      return SUCCESS;
d6718 10
d6729 3
a6731 6
	  inst.error = _("invalid floating point immediate expression");
	  return FAIL;
	}
      inst.error =
	_("floating point register or immediate expression expected");
      return FAIL;
d6736 1
a6736 1
do_arit (char * str)
d6738 7
a6744 1
  skip_whitespace (str);
d6746 8
a6753 12
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
d6757 1
a6757 1
do_adr (char * str)
d6759 2
a6760 3
  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-8".  */
  skip_whitespace (str);
d6762 2
a6763 3
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d6765 4
a6768 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6770 6
d6777 2
a6778 7
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
#endif
  inst.reloc.pc_rel = 1;
d6780 7
a6786 1
  end_of_line (str);
d6790 1
a6790 1
do_adrl (char * str)
d6792 4
a6795 4
  /* This is a pseudo-op of the form "adrl rd, label" to be converted
     into a relative address of the form:
     add rd, pc, #low(label-.-8)"
     add rd, rd, #high(label-.-8)"  */
d6797 3
a6799 1
  skip_whitespace (str);
d6801 17
a6817 3
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d6819 3
a6821 4
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
a6822 10

  end_of_line (str);
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type              = BFD_RELOC_ARM_ADRL_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
#endif
  inst.reloc.pc_rel            = 1;
  inst.size                    = INSN_SIZE * 2;
d6826 1
a6826 1
do_cmp (char * str)
d6828 1
a6828 3
  skip_whitespace (str);

  if (reg_required_here (&str, 16) == FAIL)
d6830 24
a6853 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6855 1
d6857 7
a6863 2
  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
d6865 5
a6869 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6871 9
d6881 4
a6884 1
  end_of_line (str);
d6888 1
a6888 1
do_mov (char * str)
d6890 4
a6893 1
  skip_whitespace (str);
d6895 6
a6900 1
  if (reg_required_here (&str, 12) == FAIL)
d6902 3
a6904 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6906 15
d6922 3
a6924 2
  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
d6926 1
a6926 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6930 1
a6930 1
  end_of_line (str);
d6934 1
a6934 1
do_ldst (char * str)
d6936 3
a6938 3
  int pre_inc = 0;
  int conflict_reg;
  int value;
d6940 5
a6944 3
  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (&str, 12)) == FAIL)
d6946 3
a6948 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6950 1
a6950 2

  if (skip_past_comma (&str) == FAIL)
d6952 4
a6955 2
      inst.error = _("address expected");
      return;
d6957 3
d6961 4
a6964 3
  if (*str == '[')
    {
      int reg;
d6966 4
a6969 1
      str++;
d6971 10
a6980 1
      skip_whitespace (str);
d6982 6
a6987 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d6989 5
a6993 2
      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);
d6995 15
a7009 15
      skip_whitespace (str);

      if (*str == ']')
	{
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend (&str) == FAIL)
		return;
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
d7013 2
a7014 4
	      /* [Rn]  */
	      skip_whitespace (str);

	      if (*str == '!')
d7016 9
a7024 6
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
d7026 7
a7032 3

	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
d7037 1
a7037 2
	  /* [Rn,...]  */
	  if (skip_past_comma (&str) == FAIL)
d7039 11
a7049 2
	      inst.error = _("pre-indexed expression expected");
	      return;
d7051 1
a7051 8

	  pre_inc = 1;
	  if (ldst_extend (&str) == FAIL)
	    return;

	  skip_whitespace (str);

	  if (*str++ != ']')
d7053 10
a7062 2
	      inst.error = _("missing ]");
	      return;
d7064 7
d7072 5
a7076 1
	  skip_whitespace (str);
d7078 1
a7078 1
	  if (*str == '!')
d7080 5
a7084 6
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	      str++;
	      inst.instruction |= WRITE_BACK;
d7086 3
d7090 1
a7090 4
    }
  else if (*str == '=')
    {
      if ((inst.instruction & LOAD_BIT) == 0)
d7092 11
a7102 2
	  inst.error = _("invalid pseudo operation");
	  return;
d7104 10
d7115 11
a7125 2
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d7127 6
a7132 1
      skip_whitespace (str);
d7134 4
a7137 2
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d7139 1
a7139 2
      if (inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
d7141 4
a7144 2
	  inst.error = _("constant expression expected");
	  return;
d7146 3
d7150 7
a7156 3
      if (inst.reloc.exp.X_op == O_constant)
	{
	  value = validate_immediate (inst.reloc.exp.X_add_number);
d7158 8
a7165 10
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MOV << DATA_OP_SHIFT));
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
d7167 5
a7171 1
	  value = validate_immediate (~inst.reloc.exp.X_add_number);
d7173 5
a7177 11
	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MVN << DATA_OP_SHIFT));
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
	}
d7179 5
a7183 7
      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
	  return;
	}
d7185 5
a7189 10
      /* Change the instruction exp to point to the pool.  */
      inst.reloc.type = BFD_RELOC_ARM_LITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d7191 7
a7197 12
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
#ifndef TE_WINCE
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
#endif
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }

  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  end_of_line (str);
d7201 1
a7201 1
do_ldstt (char * str)
d7203 3
a7205 5
  int conflict_reg;

  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d7207 3
a7209 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d7211 1
a7211 2

  if (skip_past_comma (& str) == FAIL)
d7213 5
a7217 2
      inst.error = _("address expected");
      return;
d7219 1
a7219 2

  if (*str == '[')
d7221 5
a7225 1
      int reg;
d7227 5
a7231 1
      str++;
d7233 6
a7238 1
      skip_whitespace (str);
d7240 8
a7247 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d7249 6
a7254 6
      /* ldrt/strt always use post-indexed addressing, so if the base is
	 the same as Rd, we warn.  */
      if (conflict_reg == reg)
	as_warn (_("%s register same as write-back base"),
		 ((inst.instruction & LOAD_BIT)
		  ? _("destination") : _("source")));
d7256 9
a7264 1
      skip_whitespace (str);
d7266 6
a7271 3
      if (*str == ']')
	{
	  str ++;
d7273 9
a7281 10
	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend (&str) == FAIL)
		return;
	    }
	  else
	    {
	      /* [Rn]  */
	      skip_whitespace (str);
d7283 8
a7290 3
	      /* Skip a write-back '!'.  */
	      if (*str == '!')
		str++;
d7292 4
a7295 13
	      inst.instruction |= INDEX_UP;
	    }
	}
      else
	{
	  inst.error = _("post-indexed expression expected");
	  return;
	}
    }
  else
    {
      inst.error = _("post-indexed expression expected");
      return;
d7298 3
a7300 1
  end_of_line (str);
a7302 2
/* Halfword and signed-byte load/store operations.  */

d7304 1
a7304 1
do_ldstv4 (char * str)
d7306 1
a7306 3
  int pre_inc = 0;
  int conflict_reg;
  int value;
d7308 1
a7308 3
  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d7310 1
a7310 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d7313 4
d7318 1
a7318 1
  if (skip_past_comma (& str) == FAIL)
d7320 3
a7322 2
      inst.error = _("address expected");
      return;
d7324 1
a7324 2

  if (*str == '[')
d7326 6
a7331 1
      int reg;
d7333 4
a7336 1
      str++;
d7338 4
a7341 1
      skip_whitespace (str);
d7343 91
a7433 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d7435 12
a7446 2
      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);
d7448 4
a7451 1
      skip_whitespace (str);
d7453 6
a7458 1
      if (*str == ']')
d7460 3
a7462 1
	  str ++;
d7464 9
a7472 14
	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend_v4 (&str) == FAIL)
		return;
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	    }
	  else
	    {
	      /* [Rn]  */
	      inst.instruction |= HWOFFSET_IMM;
d7474 4
a7477 1
	      skip_whitespace (str);
d7479 26
a7504 9
	      if (*str == '!')
		{
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
		}
d7506 2
a7507 3
	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
	    }
d7509 6
a7514 8
      else
	{
	  /* [Rn,...]  */
	  if (skip_past_comma (&str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return;
	    }
d7516 17
a7532 3
	  pre_inc = 1;
	  if (ldst_extend_v4 (&str) == FAIL)
	    return;
d7534 3
a7536 1
	  skip_whitespace (str);
d7538 2
a7539 5
	  if (*str++ != ']')
	    {
	      inst.error = _("missing ]");
	      return;
	    }
d7541 5
a7545 1
	  skip_whitespace (str);
d7547 6
a7552 10
	  if (*str == '!')
	    {
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	      str++;
	      inst.instruction |= WRITE_BACK;
	    }
	}
a7553 7
  else if (*str == '=')
    {
      if ((inst.instruction & LOAD_BIT) == 0)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}
d7555 2
a7556 3
      /* XXX Does this work correctly for half-word/byte ops?  */
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d7558 7
a7564 1
      skip_whitespace (str);
d7566 2
a7567 2
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d7569 4
a7572 2
      if (inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
d7574 1
a7574 1
	  inst.error = _("constant expression expected");
d7577 2
a7578 2

      if (inst.reloc.exp.X_op == O_constant)
d7580 3
a7582 1
	  value = validate_immediate (inst.reloc.exp.X_add_number);
d7584 2
a7585 9
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
d7587 2
a7588 1
	  value = validate_immediate (~ inst.reloc.exp.X_add_number);
d7590 5
a7594 1
	  if (value != FAIL)
d7596 1
a7596 5
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
d7600 10
a7609 3

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
d7611 1
a7611 2
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
d7615 9
a7623 6
      /* Change the instruction exp to point to the pool.  */
      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
d7625 2
a7626 4
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d7628 1
a7628 10
      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
#ifndef TE_WINCE
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
#endif
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
d7630 4
a7633 2
  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  end_of_line (str);
d7636 2
a7637 2
static void
do_ldsttv4 (char * str)
d7639 14
a7652 1
  int conflict_reg;
d7654 14
a7667 1
  skip_whitespace (str);
d7669 10
a7678 1
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d7680 8
a7687 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d7689 1
d7691 4
a7694 1
  if (skip_past_comma (& str) == FAIL)
d7696 4
a7699 2
      inst.error = _("address expected");
      return;
d7702 2
a7703 3
  if (*str == '[')
    {
      int reg;
d7705 4
a7708 1
      str++;
d7710 3
a7712 1
      skip_whitespace (str);
d7714 29
a7742 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d7744 3
a7746 6
      /* ldrt/strt always use post-indexed addressing, so if the base is
	 the same as Rd, we warn.  */
      if (conflict_reg == reg)
	as_warn (_("%s register same as write-back base"),
		 ((inst.instruction & LOAD_BIT)
		  ? _("destination") : _("source")));
d7748 2
a7749 1
      skip_whitespace (str);
d7751 2
a7752 3
      if (*str == ']')
	{
	  str ++;
d7754 65
a7818 10
	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend_v4 (&str) == FAIL)
		return;
	    }
	  else
	    {
	      /* [Rn]  */
	      skip_whitespace (str);
d7820 77
a7896 3
	      /* Skip a write-back '!'.  */
	      if (*str == '!')
		str++;
d7898 10
a7907 14
	      inst.instruction |= (INDEX_UP|HWOFFSET_IMM);
	    }
	}
      else
	{
	  inst.error = _("post-indexed expression expected");
	  return;
	}
    }
  else
    {
      inst.error = _("post-indexed expression expected");
      return;
    }
d7909 17
a7925 2
  end_of_line (str);
}
d7927 117
d8045 1
a8045 2
static long
reg_list (char ** strp)
d8047 46
a8092 3
  char * str = * strp;
  long   range = 0;
  int    another_range;
d8094 9
a8102 4
  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
    {
      another_range = 0;
d8104 108
a8211 4
      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;
d8213 6
a8218 4
	  str++;
	  do
	    {
	      int reg;
d8220 638
a8857 1
	      skip_whitespace (str);
d8859 18
a8876 2
	      if ((reg = reg_required_here (& str, -1)) == FAIL)
		return FAIL;
d8878 9
a8886 3
	      if (in_range)
		{
		  int i;
d8888 35
a8922 5
		  if (reg <= cur_reg)
		    {
		      inst.error = _("bad range in register list");
		      return FAIL;
		    }
d8924 15
a8938 11
		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}
d8940 5
a8944 5
	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));
d8946 28
a8973 7
	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;
	  skip_whitespace (str);
d8975 15
a8989 9
	  if (*str++ != '}')
	    {
	      inst.error = _("missing `}'");
	      return FAIL;
	    }
	}
      else
	{
	  expressionS expr;
d8991 290
a9280 2
	  if (my_get_expression (&expr, &str))
	    return FAIL;
d9282 6
a9287 8
	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}
d9289 8
a9296 3
	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;
d9298 5
a9302 6
		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}
d9304 6
a9309 14
	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}

	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
d9311 4
a9314 4

      skip_whitespace (str);

      if (*str == '|' || *str == '+')
d9316 2
a9317 2
	  str++;
	  another_range = 1;
a9319 1
  while (another_range);
d9321 25
a9345 2
  *strp = str;
  return range;
d9348 5
a9352 2
static void
do_ldmstm (char * str)
d9354 4
a9357 2
  int base_reg;
  long range;
d9359 3
a9361 1
  skip_whitespace (str);
d9363 1
a9363 1
  if ((base_reg = reg_required_here (&str, 16)) == FAIL)
d9366 3
a9368 5
  if (base_reg == REG_PC)
    {
      inst.error = _("r15 not allowed as base register");
      return;
    }
d9370 2
a9371 1
  skip_whitespace (str);
d9373 1
a9373 1
  if (*str == '!')
d9375 5
a9379 2
      inst.instruction |= WRITE_BACK;
      str++;
d9381 1
a9381 3

  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
d9383 5
a9387 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9390 1
a9390 1
  if (*str == '^')
d9392 4
a9395 2
      str++;
      inst.instruction |= LDM_TYPE_2_OR_3;
d9398 1
a9398 1
  if (inst.instruction & WRITE_BACK)
d9400 4
a9403 21
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
	{
	  /* Not allowed in LDM type 2.  */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
	}
      else /* STM.  */
	{
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
	}
d9406 2
a9407 2
  inst.instruction |= range;
  end_of_line (str);
d9410 5
a9414 2
static void
do_smi (char * str)
d9416 6
a9421 1
  skip_whitespace (str);
d9423 9
a9431 3
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str++;
d9433 1
a9433 2
  if (my_get_expression (& inst.reloc.exp, & str))
    return;
d9435 5
a9439 3
  inst.reloc.type = BFD_RELOC_ARM_SMI;
  inst.reloc.pc_rel = 0;
  end_of_line (str);
d9442 5
a9446 2
static void
do_swi (char * str)
d9448 10
a9457 1
  skip_whitespace (str);
d9459 1
a9459 3
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str++;
d9461 2
a9462 1
  if (my_get_expression (& inst.reloc.exp, & str))
d9465 3
a9467 3
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
  end_of_line (str);
d9470 2
a9471 2
static void
do_swap (char * str)
d9473 2
a9474 1
  int reg;
d9476 4
a9479 1
  skip_whitespace (str);
d9481 1
a9481 2
  if ((reg = reg_required_here (&str, 12)) == FAIL)
    return;
d9483 1
a9483 5
  if (reg == REG_PC)
    {
      inst.error = _("r15 not allowed in swap");
      return;
    }
d9485 4
a9488 7
  if (skip_past_comma (&str) == FAIL
      || (reg = reg_required_here (&str, 0)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9490 5
a9494 5
  if (reg == REG_PC)
    {
      inst.error = _("r15 not allowed in swap");
      return;
    }
d9496 3
a9498 6
  if (skip_past_comma (&str) == FAIL
      || *str++ != '[')
    {
      inst.error = BAD_ARGS;
      return;
    }
d9500 6
a9505 1
  skip_whitespace (str);
d9507 1
a9507 2
  if ((reg = reg_required_here (&str, 16)) == FAIL)
    return;
d9509 1
a9509 1
  if (reg == REG_PC)
d9511 6
a9516 2
      inst.error = BAD_PC;
      return;
d9518 1
a9518 4

  skip_whitespace (str);

  if (*str++ != ']')
d9520 4
a9523 2
      inst.error = _("missing ]");
      return;
a9524 2

  end_of_line (str);
d9527 1
a9527 42
static void
do_branch (char * str)
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;

#ifdef OBJ_ELF
  {
    char * save_in;

    /* ScottB: February 5, 1998 - Check to see of PLT32 reloc
       required for the instruction.  */

    /* arm_parse_reloc () works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;
    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
	inst.reloc.pc_rel = 1;
      }
    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF  */

  end_of_line (str);
}
d9530 1
a9530 1
do_cdp (char * str)
d9532 1
a9532 3
  /* Co-processor data operation.
     Format: CDP{cond} CP#,<expr>,CRd,CRn,CRm{,<expr>}  */
  skip_whitespace (str);
d9534 1
a9534 1
  if (co_proc_number (&str) == FAIL)
d9536 4
a9539 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9541 6
a9546 7
  if (skip_past_comma (&str) == FAIL
      || cp_opc_expr (&str, 20,4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9548 14
a9561 6
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9563 1
a9563 3

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
d9565 4
a9568 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9570 1
a9570 3

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
d9572 3
a9574 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9576 1
a9576 2

  if (skip_past_comma (&str) == SUCCESS)
d9578 2
a9579 1
      if (cp_opc_expr (&str, 5, 3) == FAIL)
d9581 2
a9582 3
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
d9584 2
a9586 2

  end_of_line (str);
d9589 1
d9591 1
a9591 1
do_lstc (char * str)
d9593 1
a9593 2
  /* Co-processor register load/store.
     Format: <LDC|STC{cond}[L] CP#,CRd,<address>  */
d9595 1
a9595 3
  skip_whitespace (str);

  if (co_proc_number (&str) == FAIL)
d9597 3
a9599 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9601 3
a9603 6
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9605 3
a9608 7
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9610 2
a9611 2
  end_of_line (str);
}
d9614 1
a9614 1
do_co_reg (char * str)
d9616 11
a9626 2
  /* Co-processor register transfer.
     Format: <MCR|MRC>{cond} CP#,<expr1>,Rd,CRn,CRm{,<expr2>}  */
d9628 1
a9628 3
  skip_whitespace (str);

  if (co_proc_number (&str) == FAIL)
d9630 3
a9632 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9634 1
a9634 3

  if (skip_past_comma (&str) == FAIL
      || cp_opc_expr (&str, 21, 3) == FAIL)
d9636 3
a9638 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9641 6
a9646 2
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
d9648 2
a9649 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9652 7
a9658 7
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9660 3
a9662 7
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9664 2
a9665 1
  if (skip_past_comma (&str) == SUCCESS)
d9667 2
a9668 1
      if (cp_opc_expr (&str, 5, 3) == FAIL)
d9670 3
a9672 2
	  if (!inst.error)
	    inst.error = BAD_ARGS;
d9675 2
d9679 5
a9683 1
  end_of_line (str);
a9685 5
static void
do_fpa_ctrl (char * str)
{
  /* FP control registers.
     Format: <WFS|RFS|WFC|RFC>{cond} Rn  */
d9687 3
a9689 1
  skip_whitespace (str);
d9691 10
a9700 6
  if (reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9702 1
a9702 2
  end_of_line (str);
}
d9704 3
a9706 4
static void
do_fpa_ldst (char * str)
{
  skip_whitespace (str);
d9708 1
a9708 6
  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9710 1
a9710 2
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
d9712 6
a9717 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9719 14
a9732 2
  end_of_line (str);
}
d9734 11
a9744 4
static void
do_fpa_ldmstm (char * str)
{
  int num_regs;
d9746 3
a9748 1
  skip_whitespace (str);
d9750 7
a9756 5
  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9758 15
d9774 1
a9774 3
  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d9776 5
a9780 4
      if (! inst.error)
	inst.error = _("constant expression expected");
      return;
    }
d9782 2
a9783 5
  if (inst.reloc.exp.X_op != O_constant)
    {
      inst.error = _("constant value required for number of registers");
      return;
    }
d9785 4
a9788 1
  num_regs = inst.reloc.exp.X_add_number;
d9790 6
a9795 5
  if (num_regs < 1 || num_regs > 4)
    {
      inst.error = _("number of registers must be in the range [1:4]");
      return;
    }
a9796 2
  switch (num_regs)
    {
a9797 2
      inst.instruction |= CP_T_X;
      break;
d9799 3
a9801 6
      inst.instruction |= CP_T_Y;
      break;
    case 3:
      inst.instruction |= CP_T_Y | CP_T_X;
      break;
    case 4:
d9803 1
d9805 1
d9809 3
a9811 1
  if (inst.instruction & (CP_T_Pre | CP_T_UD)) /* ea/fd format.  */
d9813 1
a9813 10
      int reg;
      int write_back;
      int offset;

      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      if (skip_past_comma (&str) == FAIL
	  || *str != '[')
d9815 4
a9818 3
	  if (! inst.error)
	    inst.error = BAD_ARGS;
	  return;
d9820 3
a9822 62

      str++;
      skip_whitespace (str);

      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      skip_whitespace (str);

      if (*str != ']')
	{
	  inst.error = BAD_ARGS;
	  return;
	}

      str++;
      if (*str == '!')
	{
	  write_back = 1;
	  str++;
	  if (reg == REG_PC)
	    {
	      inst.error =
		_("r15 not allowed as base register with write-back");
	      return;
	    }
	}
      else
	write_back = 0;

      if (inst.instruction & CP_T_Pre)
	{
	  /* Pre-decrement.  */
	  offset = 3 * num_regs;
	  if (write_back)
	    inst.instruction |= CP_T_WB;
	}
      else
	{
	  /* Post-increment.  */
	  if (write_back)
	    {
	      inst.instruction |= CP_T_WB;
	      offset = 3 * num_regs;
	    }
	  else
	    {
	      /* No write-back, so convert this into a standard pre-increment
		 instruction -- aesthetically more pleasing.  */
	      inst.instruction |= CP_T_Pre | CP_T_UD;
	      offset = 0;
	    }
	}

      inst.instruction |= offset;
    }
  else if (skip_past_comma (&str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9825 2
a9826 9
  end_of_line (str);
}

static void
do_fpa_dyadic (char * str)
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 12) == FAIL)
d9828 3
a9830 4
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9832 1
a9832 6
  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9835 1
a9835 2
  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
d9837 3
a9839 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9842 1
a9842 1
  end_of_line (str);
d9845 4
a9848 2
static void
do_fpa_monadic (char * str)
d9850 1
a9850 1
  skip_whitespace (str);
d9852 2
a9853 6
  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9855 2
a9856 7
  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9858 1
a9858 2
  end_of_line (str);
}
d9860 2
a9861 2
static void
do_fpa_cmp (char * str)
d9863 3
a9865 1
  skip_whitespace (str);
a9866 6
  if (fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9868 1
a9868 7
  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9870 2
a9871 2
  end_of_line (str);
}
d9873 2
a9874 2
static void
do_fpa_from_reg (char * str)
d9876 4
a9879 1
  skip_whitespace (str);
d9881 5
a9885 1
  if (fp_reg_required_here (&str, 16) == FAIL)
d9887 6
a9892 4
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9894 2
a9895 6
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9898 7
a9904 1
  end_of_line (str);
d9907 5
a9911 2
static void
do_fpa_to_reg (char * str)
d9913 8
a9920 1
  skip_whitespace (str);
d9922 3
a9924 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d9926 1
a9926 6
  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 0) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9928 1
d9930 1
a9930 1
  end_of_line (str);
d9933 4
a9936 1
/* Encode a VFP SP register number.  */
d9938 3
a9940 2
static void
vfp_sp_encode_reg (int reg, enum vfp_sp_reg_pos pos)
d9942 2
a9943 5
  switch (pos)
    {
    case VFP_REG_Sd:
      inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
      break;
d9945 20
a9964 3
    case VFP_REG_Sn:
      inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
      break;
d9966 2
a9967 3
    case VFP_REG_Sm:
      inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
      break;
d9969 1
a9969 3
    default:
      abort ();
    }
d9973 1
a9973 2
vfp_sp_reg_required_here (char ** str,
			  enum vfp_sp_reg_pos pos)
d9975 4
a9978 8
  int    reg;
  char * start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab)) != FAIL)
    {
      vfp_sp_encode_reg (reg, pos);
      return reg;
    }
d9980 10
a9989 8
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_SN].expected);

  /* Restore the start point.  */
  *str = start;
  return FAIL;
}
d9992 2
a9993 2
vfp_dp_reg_required_here (char ** str,
			  enum vfp_dp_reg_pos pos)
d9995 2
a9996 2
  int    reg;
  char * start = *str;
d9998 5
a10002 1
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab)) != FAIL)
d10004 5
a10008 5
      switch (pos)
	{
	case VFP_REG_Dd:
	  inst.instruction |= reg << 12;
	  break;
d10010 4
a10013 3
	case VFP_REG_Dn:
	  inst.instruction |= reg << 16;
	  break;
d10015 4
a10018 3
	case VFP_REG_Dm:
	  inst.instruction |= reg << 0;
	  break;
d10020 4
a10023 5
	default:
	  abort ();
	}
      return reg;
    }
d10025 5
a10029 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_DN].expected);
d10031 4
a10034 4
  /* Restore the start point.  */
  *str = start;
  return FAIL;
}
d10036 4
a10039 4
static void
do_vfp_sp_monadic (char * str)
{
  skip_whitespace (str);
d10041 4
a10044 2
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;
d10046 4
a10049 7
  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10051 4
a10054 2
  end_of_line (str);
}
d10056 3
a10058 14
static void
do_vfp_dp_monadic (char * str)
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d10061 2
a10062 2
  end_of_line (str);
}
d10064 3
a10066 19
static void
do_vfp_sp_dyadic (char * str)
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
d10069 4
a10072 2
static void
do_vfp_dp_dyadic (char * str)
d10074 9
a10082 1
  skip_whitespace (str);
d10084 1
a10084 2
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;
d10086 3
a10088 9
  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10090 4
a10093 13
  end_of_line (str);
}

static void
do_vfp_reg_from_sp (char * str)
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
d10095 4
a10098 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d10101 2
a10102 2
  end_of_line (str);
}
d10104 1
a10104 23
/* Parse a VFP register list.  If the string is invalid return FAIL.
   Otherwise return the number of registers, and set PBASE to the first
   register.  Double precision registers are matched if DP is nonzero.  */

static int
vfp_parse_reg_list (char **str, int *pbase, int dp)
{
  int base_reg;
  int new_base;
  int regtype;
  int max_regs;
  int count = 0;
  int warned = 0;
  unsigned long mask = 0;
  int i;

  if (**str != '{')
    return FAIL;

  (*str)++;
  skip_whitespace (*str);

  if (dp)
d10106 4
a10109 8
      regtype = REG_TYPE_DN;
      max_regs = 16;
    }
  else
    {
      regtype = REG_TYPE_SN;
      max_regs = 32;
    }
d10111 5
a10115 1
  base_reg = max_regs;
d10117 2
a10118 4
  do
    {
      new_base = arm_reg_parse (str, all_reg_maps[regtype].htab);
      if (new_base == FAIL)
d10120 4
a10123 2
	  inst.error = _(all_reg_maps[regtype].expected);
	  return FAIL;
d10126 2
a10127 2
      if (new_base < base_reg)
	base_reg = new_base;
d10129 4
a10132 1
      if (mask & (1 << new_base))
d10134 4
a10137 2
	  inst.error = _("invalid register list");
	  return FAIL;
d10140 3
a10142 5
      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}
d10144 4
a10147 2
      mask |= 1 << new_base;
      count++;
d10149 2
a10150 1
      skip_whitespace (*str);
d10152 8
a10159 3
      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;
d10161 15
a10175 1
	  (*str)++;
d10177 15
a10191 7
	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[regtype].htab))
	      == FAIL)
	    {
	      inst.error = _(all_reg_maps[regtype].expected);
	      return FAIL;
	    }
d10193 3
a10195 5
	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }
d10197 2
a10198 7
	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}
d10200 10
a10209 3
	      mask |= 1 << new_base;
	      count++;
	    }
a10210 2
    }
  while (skip_past_comma (str) != FAIL);
d10212 5
a10216 1
  (*str)++;
d10218 3
a10220 3
  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > max_regs)
    abort ();
d10222 2
a10223 1
  *pbase = base_reg;
d10225 1
a10225 5
  /* Final test -- the registers must be consecutive.  */
  mask >>= base_reg;
  for (i = 0; i < count; i++)
    {
      if ((mask & (1u << i)) == 0)
d10227 7
a10233 2
	  inst.error = _("non-contiguous register range");
	  return FAIL;
a10234 1
    }
d10236 5
a10240 2
  return count;
}
d10242 5
a10246 4
static void
do_vfp_reg2_from_sp2 (char * str)
{
  int reg;
d10248 28
a10275 1
  skip_whitespace (str);
d10277 86
a10362 9
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10364 4
a10367 7
  /* We require exactly two consecutive SP registers.  */
  if (vfp_parse_reg_list (&str, &reg, 0) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
    }
  vfp_sp_encode_reg (reg, VFP_REG_Sm);
d10369 10
a10378 2
  end_of_line (str);
}
d10380 9
a10388 4
static void
do_vfp_sp_from_reg (char * str)
{
  skip_whitespace (str);
d10390 5
a10394 2
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
    return;
d10396 8
a10403 7
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10405 3
a10407 2
  end_of_line (str);
}
d10409 1
a10409 4
static void
do_vfp_sp2_from_reg2 (char * str)
{
  int reg;
d10411 8
a10418 1
  skip_whitespace (str);
d10420 4
a10423 7
  /* We require exactly two consecutive SP registers.  */
  if (vfp_parse_reg_list (&str, &reg, 0) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
    }
  vfp_sp_encode_reg (reg, VFP_REG_Sm);
d10425 3
a10427 9
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10429 8
a10436 2
  end_of_line (str);
}
d10438 20
a10457 4
static void
do_vfp_reg_from_dp (char * str)
{
  skip_whitespace (str);
d10459 7
a10465 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d10467 2
a10468 7
  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10470 2
a10471 2
  end_of_line (str);
}
d10473 3
a10475 4
static void
do_vfp_reg2_from_dp (char * str)
{
  skip_whitespace (str);
d10477 14
a10490 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d10492 8
a10499 9
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10501 7
a10507 2
  end_of_line (str);
}
d10509 5
a10513 4
static void
do_vfp_dp_from_reg (char * str)
{
  skip_whitespace (str);
d10515 2
a10516 2
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
    return;
d10518 4
a10521 7
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10523 1
a10523 49
  end_of_line (str);
}

static void
do_vfp_dp_from_reg2 (char * str)
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static const struct vfp_reg *
vfp_psr_parse (char ** str)
{
  char *start = *str;
  char  c;
  char *p;
  const struct vfp_reg *vreg;

  p = start;

  /* Find the end of the current token.  */
  do
    {
      c = *p++;
    }
  while (ISALPHA (c));

  /* Mark it.  */
  *--p = 0;

  for (vreg = vfp_regs + 0;
       vreg < vfp_regs + sizeof (vfp_regs) / sizeof (struct vfp_reg);
       vreg++)
    {
      if (streq (start, vreg->name))
d10525 7
a10531 3
	  *p = c;
	  *str = p;
	  return vreg;
d10533 4
a10536 1
    }
d10538 4
a10541 3
  *p = c;
  return NULL;
}
d10543 6
a10548 5
static int
vfp_psr_required_here (char ** str)
{
  char *start = *str;
  const struct vfp_reg *vreg;
d10550 17
a10566 1
  vreg = vfp_psr_parse (str);
d10568 10
a10577 5
  if (vreg)
    {
      inst.instruction |= vreg->regno;
      return SUCCESS;
    }
d10579 13
a10591 1
  inst.error = _("VFP system register expected");
d10593 6
a10598 3
  *str = start;
  return FAIL;
}
d10600 17
a10616 4
static void
do_vfp_reg_from_ctrl (char * str)
{
  skip_whitespace (str);
d10618 6
a10623 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d10625 17
a10641 7
  if (skip_past_comma (&str) == FAIL
      || vfp_psr_required_here (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10643 4
a10646 2
  end_of_line (str);
}
d10648 2
a10649 4
static void
do_vfp_ctrl_from_reg (char * str)
{
  skip_whitespace (str);
d10651 5
a10655 2
  if (vfp_psr_required_here (&str) == FAIL)
    return;
d10657 3
a10659 7
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10661 3
a10663 2
  end_of_line (str);
}
d10665 16
a10680 4
static void
do_vfp_sp_ldst (char * str)
{
  skip_whitespace (str);
d10682 3
a10684 6
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10686 4
a10689 7
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10691 5
a10695 2
  end_of_line (str);
}
d10697 9
a10705 4
static void
do_vfp_dp_ldst (char * str)
{
  skip_whitespace (str);
d10707 3
a10709 6
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10711 6
a10716 7
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10718 18
a10735 2
  end_of_line (str);
}
d10737 13
d10751 4
a10754 5
static void
vfp_sp_ldstm (char * str, enum vfp_ldstm_type ldstm_type)
{
  int count;
  int reg;
d10756 2
a10757 1
  skip_whitespace (str);
d10759 9
a10767 2
  if (reg_required_here (&str, 16) == FAIL)
    return;
d10769 3
a10771 1
  skip_whitespace (str);
d10773 3
a10775 10
  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA)
    {
      inst.error = _("this addressing mode requires base-register writeback");
      return;
    }
d10777 16
a10792 8
  if (skip_past_comma (&str) == FAIL
      || (count = vfp_parse_reg_list (&str, &reg, 0)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
  vfp_sp_encode_reg (reg, VFP_REG_Sd);
d10794 2
a10795 3
  inst.instruction |= count;
  end_of_line (str);
}
d10797 7
a10803 5
static void
vfp_dp_ldstm (char * str, enum vfp_ldstm_type ldstm_type)
{
  int count;
  int reg;
d10805 13
a10817 1
  skip_whitespace (str);
d10819 8
a10826 2
  if (reg_required_here (&str, 16) == FAIL)
    return;
d10828 8
a10835 1
  skip_whitespace (str);
d10837 18
a10854 10
  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX)
    {
      inst.error = _("this addressing mode requires base-register writeback");
      return;
    }
d10856 14
a10869 7
  if (skip_past_comma (&str) == FAIL
      || (count = vfp_parse_reg_list (&str, &reg, 1)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10871 4
a10874 3
  count <<= 1;
  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    count += 1;
d10876 14
a10889 3
  inst.instruction |= (reg << 12) | count;
  end_of_line (str);
}
d10891 5
a10895 5
static void
do_vfp_sp_ldstmia (char * str)
{
  vfp_sp_ldstm (str, VFP_LDSTMIA);
}
d10897 16
a10912 5
static void
do_vfp_sp_ldstmdb (char * str)
{
  vfp_sp_ldstm (str, VFP_LDSTMDB);
}
d10914 4
a10917 5
static void
do_vfp_dp_ldstmia (char * str)
{
  vfp_dp_ldstm (str, VFP_LDSTMIA);
}
d10919 2
a10920 5
static void
do_vfp_dp_ldstmdb (char * str)
{
  vfp_dp_ldstm (str, VFP_LDSTMDB);
}
d10922 7
a10928 5
static void
do_vfp_xp_ldstmia (char *str)
{
  vfp_dp_ldstm (str, VFP_LDSTMIAX);
}
d10930 7
a10936 5
static void
do_vfp_xp_ldstmdb (char * str)
{
  vfp_dp_ldstm (str, VFP_LDSTMDBX);
}
d10938 7
a10944 4
static void
do_vfp_sp_compare_z (char * str)
{
  skip_whitespace (str);
d10946 7
a10952 6
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10954 8
a10961 2
  end_of_line (str);
}
d10963 3
a10965 4
static void
do_vfp_dp_compare_z (char * str)
{
  skip_whitespace (str);
d10967 4
a10970 6
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10972 2
a10973 2
  end_of_line (str);
}
d10975 9
a10983 4
static void
do_vfp_dp_sp_cvt (char * str)
{
  skip_whitespace (str);
d10985 6
a10990 2
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;
d10992 9
a11000 7
  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d11002 37
a11038 2
  end_of_line (str);
}
d11040 9
a11048 4
static void
do_vfp_sp_dp_cvt (char * str)
{
  skip_whitespace (str);
d11050 16
a11065 2
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;
d11067 3
a11069 5
  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
d11071 5
a11076 2

  end_of_line (str);
d11079 2
a11080 1
/* Thumb specific routines.  */
d11082 3
a11084 5
/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode
   was SUB.  */

static void
thumb_add_sub (char * str, int subtract)
d11086 2
a11087 1
  int Rd, Rs, Rn = FAIL;
d11089 1
a11089 1
  skip_whitespace (str);
d11091 3
a11093 7
  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d11095 4
a11098 7
  if (is_immediate_prefix (*str))
    {
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
d11100 4
a11103 3
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d11105 1
a11105 20
      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
    }

  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
  if (Rn != FAIL)
d11107 2
a11108 2
      /* All register format.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
d11110 2
a11111 22
	  if (Rs != Rd)
	    {
	      inst.error = _("dest and source1 must be the same register");
	      return;
	    }

	  /* Can't do this for SUB.  */
	  if (subtract)
	    {
	      inst.error = _("subtract valid only on lo regs");
	      return;
	    }

	  inst.instruction = (T_OPCODE_ADD_HI
			      | (Rd > 7 ? THUMB_H1 : 0)
			      | (Rn > 7 ? THUMB_H2 : 0));
	  inst.instruction |= (Rd & 7) | ((Rn & 7) << 3);
	}
      else
	{
	  inst.instruction = subtract ? T_OPCODE_SUB_R3 : T_OPCODE_ADD_R3;
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
a11112 4
    }
  else
    {
      /* Immediate expression, now things start to get nasty.  */
d11114 2
a11115 4
      /* First deal with HI regs, only very restricted cases allowed:
	 Adjusting SP, and using PC or SP to get an address.  */
      if ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
	  || (Rs > 7 && Rs != REG_SP && Rs != REG_PC))
d11117 2
a11118 2
	  inst.error = _("invalid Hi register with immediate");
	  return;
d11121 2
a11122 1
      if (inst.reloc.exp.X_op != O_constant)
d11124 2
a11125 5
	  /* Value isn't known yet, all we can do is store all the fragments
	     we know about in the instruction and let the reloc hacking
	     work it all out.  */
	  inst.instruction = (subtract ? 0x8000 : 0) | (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
a11126 3
      else
	{
	  int offset = inst.reloc.exp.X_add_number;
d11128 15
a11142 2
	  if (subtract)
	    offset = - offset;
d11144 7
a11150 4
	  if (offset < 0)
	    {
	      offset = - offset;
	      subtract = 1;
d11152 13
a11164 11
	      /* Quick check, in case offset is MIN_INT.  */
	      if (offset < 0)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	    }
	  /* Note - you cannot convert a subtract of 0 into an
	     add of 0 because the carry flag is set differently.  */
	  else if (offset > 0)
	    subtract = 0;
d11166 10
a11175 44
	  if (Rd == REG_SP)
	    {
	      if (offset & ~0x1fc)
		{
		  inst.error = _("invalid immediate value for stack adjust");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	      inst.instruction |= offset >> 2;
	    }
	  else if (Rs == REG_PC || Rs == REG_SP)
	    {
	      if (subtract
		  || (offset & ~0x3fc))
		{
		  inst.error = _("invalid immediate for address calculation");
		  return;
		}
	      inst.instruction = (Rs == REG_PC ? T_OPCODE_ADD_PC
				  : T_OPCODE_ADD_SP);
	      inst.instruction |= (Rd << 8) | (offset >> 2);
	    }
	  else if (Rs == Rd)
	    {
	      if (offset & ~0xff)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	      inst.instruction |= (Rd << 8) | offset;
	    }
	  else
	    {
	      if (offset & ~0x7)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	      inst.instruction |= Rd | (Rs << 3) | (offset << 6);
	    }
	}
    }
d11177 4
a11180 2
  end_of_line (str);
}
d11182 4
a11185 4
static void
thumb_shift (char * str, int shift)
{
  int Rd, Rs, Rn = FAIL;
d11187 10
a11196 1
  skip_whitespace (str);
d11198 3
a11200 7
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d11202 24
a11225 7
  if (is_immediate_prefix (*str))
    {
      /* Two operand immediate format, set Rs to Rd.  */
      Rs = Rd;
      str ++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d11227 5
a11231 1
  else
d11233 2
a11234 18
      if ((Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
d11236 1
d11238 1
a11238 2
  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
d11240 1
a11240 1
  if (Rn != FAIL)
d11242 4
a11245 14
      if (Rs != Rd)
	{
	  inst.error = _("source1 and dest must be same register");
	  return;
	}

      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_R; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_R; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_R; break;
	}

      inst.instruction |= Rd | (Rn << 3);
a11246 8
  else
    {
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_I; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_I; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_I; break;
	}
d11248 4
a11251 9
      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, create a dummy reloc and let reloc
	     hacking fix it up.  */
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	}
      else
	{
	  unsigned shift_value = inst.reloc.exp.X_add_number;
d11253 2
a11254 5
	  if (shift_value > 32 || (shift_value == 32 && shift == THUMB_LSL))
	    {
	      inst.error = _("invalid immediate for shift");
	      return;
	    }
d11256 1
a11256 3
	  /* Shifts of zero are handled by converting to LSL.  */
	  if (shift_value == 0)
	    inst.instruction = T_OPCODE_LSL_I;
d11258 8
a11265 3
	  /* Shifts of 32 are encoded as a shift of zero.  */
	  if (shift_value == 32)
	    shift_value = 0;
d11267 17
a11283 4
	  inst.instruction |= shift_value << 6;
	}

      inst.instruction |= Rd | (Rs << 3);
d11286 1
a11286 1
  end_of_line (str);
d11289 3
a11291 2
static void
thumb_load_store (char * str, int load_store, int size)
d11293 8
a11300 6
  int Rd, Rb, Ro = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
d11302 1
a11302 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d11304 2
d11307 14
a11320 5
  if (*str == '[')
    {
      str++;
      if ((Rb = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d11322 5
a11326 16
      if (skip_past_comma (&str) != FAIL)
	{
	  if (is_immediate_prefix (*str))
	    {
	      str++;
	      if (my_get_expression (&inst.reloc.exp, &str))
		return;
	    }
	  else if ((Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	    return;
	}
      else
	{
	  inst.reloc.exp.X_op = O_constant;
	  inst.reloc.exp.X_add_number = 0;
	}
d11328 2
a11329 14
      if (*str != ']')
	{
	  inst.error = _("expected ']'");
	  return;
	}
      str++;
    }
  else if (*str == '=')
    {
      if (load_store != THUMB_LOAD)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}
d11331 6
a11336 2
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d11338 8
a11345 1
      skip_whitespace (str);
d11347 6
a11352 2
      if (my_get_expression (& inst.reloc.exp, & str))
	return;
d11354 6
a11359 1
      end_of_line (str);
d11361 5
a11365 6
      if (   inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = "Constant expression expected";
	  return;
	}
d11367 3
a11369 4
      if (inst.reloc.exp.X_op == O_constant
	  && ((inst.reloc.exp.X_add_number & ~0xFF) == 0))
	{
	  /* This can be done with a mov instruction.  */
d11371 4
a11374 4
	  inst.instruction  = T_OPCODE_MOV_I8 | (Rd << 8);
	  inst.instruction |= inst.reloc.exp.X_add_number;
	  return;
	}
d11376 11
a11386 7
      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = "literal pool insertion failed";
	  return;
	}
d11388 2
a11389 5
      inst.reloc.type   = BFD_RELOC_ARM_THUMB_OFFSET;
      inst.reloc.pc_rel = 1;
      inst.instruction  = T_OPCODE_LDR_PC | (Rd << 8);
      /* Adjust ARM pipeline offset to Thumb.  */
      inst.reloc.exp.X_add_number += 4;
d11391 14
a11404 2
      return;
    }
d11406 3
a11408 3
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d11410 7
a11416 7
      inst.instruction = T_OPCODE_LDR_PC | (Rd << 8);
      inst.reloc.pc_rel = 1;
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset.  */
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      end_of_line (str);
      return;
    }
d11418 1
a11418 17
  if (Rb == REG_PC || Rb == REG_SP)
    {
      if (size != THUMB_WORD)
	{
	  inst.error = _("byte or halfword not valid for base register");
	  return;
	}
      else if (Rb == REG_PC && load_store != THUMB_LOAD)
	{
	  inst.error = _("r15 based store not allowed");
	  return;
	}
      else if (Ro != FAIL)
	{
	  inst.error = _("invalid base register for register offset");
	  return;
	}
d11420 3
a11422 6
      if (Rb == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (load_store == THUMB_LOAD)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;
d11424 28
a11451 2
      inst.instruction |= Rd << 8;
      if (inst.reloc.exp.X_op == O_constant)
d11453 6
a11458 1
	  unsigned offset = inst.reloc.exp.X_add_number;
d11460 7
a11466 1
	  if (offset & ~0x3fc)
d11468 12
a11479 2
	      inst.error = _("invalid offset");
	      return;
d11481 1
d11483 2
a11484 4
	  inst.instruction |= offset >> 2;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
d11486 6
a11491 1
  else if (Rb > 7)
d11493 3
a11495 15
      inst.error = _("invalid base register in load/store");
      return;
    }
  else if (Ro == FAIL)
    {
      /* Immediate offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IW : T_OPCODE_STR_IW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IH : T_OPCODE_STR_IH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IB : T_OPCODE_STR_IB);
d11497 2
a11498 1
      inst.instruction |= Rd | (Rb << 3);
d11500 1
a11500 5
      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~(0x1f << size))
d11502 8
a11509 2
	      inst.error = _("invalid offset");
	      return;
a11510 1
	  inst.instruction |= (offset >> size) << 6;
a11511 2
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
d11513 4
a11516 12
  else
    {
      /* Register offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RW : T_OPCODE_STR_RW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RH : T_OPCODE_STR_RH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RB : T_OPCODE_STR_RB);
d11518 4
a11521 2
      inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
    }
d11523 3
a11525 1
  end_of_line (str);
d11528 5
a11532 1
/* A register must be given at this point.
d11534 7
a11540 1
   Shift is the place to put it in inst.instruction.
d11542 14
a11555 2
   Restores input start point on err.
   Returns the reg#, or FAIL.  */
d11557 1
a11557 5
static int
mav_reg_required_here (char ** str, int shift, enum arm_reg_type regtype)
{
  int   reg;
  char *start = *str;
d11559 5
a11563 1
  if ((reg = arm_reg_parse (str, all_reg_maps[regtype].htab)) != FAIL)
d11565 2
a11566 2
      if (shift >= 0)
	inst.instruction |= reg << shift;
d11568 1
a11568 1
      return reg;
d11570 7
d11578 15
a11592 2
  /* Restore the start point.  */
  *str = start;
d11594 1
a11594 5
  /* Try generic coprocessor name if applicable.  */
  if (regtype == REG_TYPE_MVF ||
      regtype == REG_TYPE_MVD ||
      regtype == REG_TYPE_MVFX ||
      regtype == REG_TYPE_MVDX)
d11596 7
a11602 4
      if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_CN].htab)) != FAIL)
	{
	  if (shift >= 0)
	    inst.instruction |= reg << shift;
d11604 2
a11605 2
	  return reg;
	}
d11607 1
a11607 3
      /* Restore the start point.  */
      *str = start;
    }
d11609 3
a11611 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[regtype].expected);
d11613 2
a11614 2
  return FAIL;
}
d11616 12
a11627 1
/* Cirrus Maverick Instructions.  */
d11629 6
a11634 1
/* Isnsn like "foo X,Y".  */
d11636 5
a11640 7
static void
do_mav_binops (char * str,
	       int mode,
	       enum arm_reg_type reg0,
	       enum arm_reg_type reg1)
{
  int shift0, shift1;
d11642 3
a11644 2
  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
d11646 4
a11649 1
  skip_whitespace (str);
d11651 3
a11653 10
  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}
d11655 5
a11659 1
/* Isnsn like "foo X,Y,Z".  */
d11661 6
a11666 8
static void
do_mav_triple (char * str,
	       int mode,
	       enum arm_reg_type reg0,
	       enum arm_reg_type reg1,
	       enum arm_reg_type reg2)
{
  int shift0, shift1, shift2;
d11668 1
a11668 3
  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;
d11670 10
a11679 1
  skip_whitespace (str);
d11681 2
a11682 5
  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL)
d11684 3
a11686 6
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}
d11688 3
a11690 1
/* Wrapper functions.  */
d11692 3
a11694 5
static void
do_mav_binops_1a (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVF);
}
d11696 4
a11699 5
static void
do_mav_binops_1b (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVD);
}
d11701 25
a11725 5
static void
do_mav_binops_1c (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVDX);
}
d11727 1
a11727 4
static void
do_mav_binops_1d (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVF);
d11730 1
a11730 5
static void
do_mav_binops_1e (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVD);
}
d11732 3
a11734 5
static void
do_mav_binops_1f (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVF);
}
d11736 4
a11739 5
static void
do_mav_binops_1g (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVD);
}
d11741 1
a11741 5
static void
do_mav_binops_1h (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVFX);
}
d11743 8
a11750 5
static void
do_mav_binops_1i (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVFX);
}
d11752 1
a11752 5
static void
do_mav_binops_1j (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVDX);
}
d11754 7
a11760 5
static void
do_mav_binops_1k (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVDX);
}
d11762 19
a11780 5
static void
do_mav_binops_1l (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVF);
}
d11782 8
a11789 5
static void
do_mav_binops_1m (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVD);
}
d11791 1
a11791 5
static void
do_mav_binops_1n (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVFX);
}
d11793 1
a11793 5
static void
do_mav_binops_1o (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVDX, REG_TYPE_MVDX);
}
d11795 10
a11804 5
static void
do_mav_binops_2a (char * str)
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVF, REG_TYPE_RN);
}
d11806 1
a11806 2
static void
do_mav_binops_2b (char * str)
d11808 8
a11815 2
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVD, REG_TYPE_RN);
}
d11817 1
a11817 5
static void
do_mav_binops_2c (char * str)
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVDX, REG_TYPE_RN);
}
d11819 1
a11819 2
static void
do_mav_binops_3a (char * str)
d11821 6
a11826 2
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVFX);
}
d11828 1
a11828 2
static void
do_mav_binops_3b (char * str)
d11830 13
a11842 2
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVFX, REG_TYPE_MVAX);
}
d11844 3
a11846 5
static void
do_mav_binops_3c (char * str)
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVDX);
}
d11848 80
a11927 5
static void
do_mav_binops_3d (char * str)
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVDX, REG_TYPE_MVAX);
}
d11929 19
a11947 5
static void
do_mav_triple_4a (char * str)
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_RN);
}
d11949 6
a11954 5
static void
do_mav_triple_4b (char * str)
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_RN);
}
d11956 2
a11957 5
static void
do_mav_triple_5a (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVF, REG_TYPE_MVF);
}
d11959 1
a11959 2
static void
do_mav_triple_5b (char * str)
d11961 6
a11966 2
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVD, REG_TYPE_MVD);
}
d11968 3
a11970 2
static void
do_mav_triple_5c (char * str)
d11972 79
a12050 2
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVFX, REG_TYPE_MVFX);
}
d12052 1
a12052 2
static void
do_mav_triple_5d (char * str)
d12054 4
a12057 2
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVDX, REG_TYPE_MVDX);
}
d12059 3
a12061 2
static void
do_mav_triple_5e (char * str)
d12063 30
a12092 5735
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVF, REG_TYPE_MVF, REG_TYPE_MVF);
}

static void
do_mav_triple_5f (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVD, REG_TYPE_MVD, REG_TYPE_MVD);
}

static void
do_mav_triple_5g (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_triple_5h (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

/* Isnsn like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */

static void
do_mav_quad (char * str,
	     int mode,
	     enum arm_reg_type reg0,
	     enum arm_reg_type reg1,
	     enum arm_reg_type reg2,
	     enum arm_reg_type reg3)
{
  int shift0, shift1, shift2, shift3;

  shift0= mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;
  shift3 = (mode >> 24) & 0xff;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift3, reg3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}

static void
do_mav_quad_6a (char * str)
{
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVFX, REG_TYPE_MVFX,
	       REG_TYPE_MVFX);
}

static void
do_mav_quad_6b (char * str)
{
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVAX, REG_TYPE_MVFX,
	       REG_TYPE_MVFX);
}

/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
static void
do_mav_dspsc_1 (char * str)
{
  skip_whitespace (str);

  /* cfmvsc32.  */
  if (mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
    }

  end_of_line (str);
}

/* cfmv32sc<cond> MVDX[15:0],DSPSC.  */
static void
do_mav_dspsc_2 (char * str)
{
  skip_whitespace (str);

  /* cfmv32sc.  */
  if (mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
    }

  end_of_line (str);
}

/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */

static void
do_mav_shift (char * str,
	      enum arm_reg_type reg0,
	      enum arm_reg_type reg1)
{
  int error;
  int imm, neg = 0;

  skip_whitespace (str);

  error = 0;

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 16, reg1) == FAIL
      || skip_past_comma  (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* Calculate the immediate operand.
     The operand is a 7bit signed number.  */
  skip_whitespace (str);

  if (*str == '#')
    ++str;

  if (!ISDIGIT (*str) && *str != '-')
    {
      inst.error = _("expecting immediate, 7bit operand");
      return;
    }

  if (*str == '-')
    {
      neg = 1;
      ++str;
    }

  for (imm = 0; *str && ISDIGIT (*str); ++str)
    imm = imm * 10 + *str - '0';

  if (imm > 64)
    {
      inst.error = _("immediate out of range");
      return;
    }

  /* Make negative imm's into 7bit signed numbers.  */
  if (neg)
    {
      imm = -imm;
      imm &= 0x0000007f;
    }

  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.  */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);

  inst.instruction |= imm;
  end_of_line (str);
}

static void
do_mav_shift_1 (char * str)
{
  do_mav_shift (str, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_shift_2 (char * str)
{
  do_mav_shift (str, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static int
mav_parse_offset (char ** str, int * negative)
{
  char * p = *str;
  int offset;

  *negative = 0;

  skip_whitespace (p);

  if (*p == '#')
    ++p;

  if (*p == '-')
    {
      *negative = 1;
      ++p;
    }

  if (!ISDIGIT (*p))
    {
      inst.error = _("offset expected");
      return 0;
    }

  for (offset = 0; *p && ISDIGIT (*p); ++p)
    offset = offset * 10 + *p - '0';

  if (offset > 0x3fc)
    {
      inst.error = _("offset out of range");
      return 0;
    }
  if (offset & 0x3)
    {
      inst.error = _("offset not a multiple of 4");
      return 0;
    }

  *str = p;

  return *negative ? -offset : offset;
}

/* Maverick load/store instructions.
  <insn><cond> CRd,[Rn,<offset>]{!}.
  <insn><cond> CRd,[Rn],<offset>.  */

static void
do_mav_ldst (char * str, enum arm_reg_type reg0)
{
  int offset, negative;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || reg_required_here (&str, 16) == FAIL)
    goto fail_ldst;

  if (skip_past_comma (&str) == SUCCESS)
    {
      /* You are here: "<offset>]{!}".  */
      inst.instruction |= PRE_INDEX;

      offset = mav_parse_offset (&str, &negative);

      if (inst.error)
	return;

      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}

      if (*str == '!')
	{
	  inst.instruction |= WRITE_BACK;
	  ++str;
	}
    }
  else
    {
      /* You are here: "], <offset>".  */
      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}

      if (skip_past_comma (&str) == FAIL
	  || (offset = mav_parse_offset (&str, &negative), inst.error))
	goto fail_ldst;

      inst.instruction |= CP_T_WB; /* Post indexed, set bit W.  */
    }

  if (negative)
    offset = -offset;
  else
    inst.instruction |= CP_T_UD; /* Positive, so set bit U.  */

  inst.instruction |= offset >> 2;
  end_of_line (str);
  return;

fail_ldst:
  if (!inst.error)
     inst.error = BAD_ARGS;
}

static void
do_mav_ldst_1 (char * str)
{
  do_mav_ldst (str, REG_TYPE_MVF);
}

static void
do_mav_ldst_2 (char * str)
{
  do_mav_ldst (str, REG_TYPE_MVD);
}

static void
do_mav_ldst_3 (char * str)
{
  do_mav_ldst (str, REG_TYPE_MVFX);
}

static void
do_mav_ldst_4 (char * str)
{
  do_mav_ldst (str, REG_TYPE_MVDX);
}

static void
do_t_nop (char * str)
{
  /* Do nothing.  */
  end_of_line (str);
}

/* Handle the Format 4 instructions that do not have equivalents in other
   formats.  That is, ADC, AND, EOR, SBC, ROR, TST, NEG, CMN, ORR, MUL,
   BIC and MVN.  */

static void
do_t_arit (char * str)
{
  int Rd, Rs, Rn;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) != FAIL)
    {
      /* Three operand format not allowed for TST, CMN, NEG and MVN.
	 (It isn't allowed for CMP either, but that isn't handled by this
	 function.)  */
      if (inst.instruction == T_OPCODE_TST
	  || inst.instruction == T_OPCODE_CMN
	  || inst.instruction == T_OPCODE_NEG
	  || inst.instruction == T_OPCODE_MVN)
	{
	  inst.error = BAD_ARGS;
	  return;
	}

      if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (Rs != Rd)
	{
	  inst.error = _("dest and source1 must be the same register");
	  return;
	}
      Rs = Rn;
    }

  if (inst.instruction == T_OPCODE_MUL
      && Rs == Rd)
    as_tsktsk (_("Rs and Rd must be different in MUL"));

  inst.instruction |= Rd | (Rs << 3);
  end_of_line (str);
}

static void
do_t_add (char * str)
{
  thumb_add_sub (str, 0);
}

static void
do_t_asr (char * str)
{
  thumb_shift (str, THUMB_ASR);
}

static void
do_t_branch9 (char * str)
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}

static void
do_t_branch12 (char * str)
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}

/* Find the real, Thumb encoded start of a Thumb function.  */

static symbolS *
find_real_start (symbolS * symbolP)
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;

  /* This definition must agree with the one in gcc/config/arm/thumb.c.  */
#define STUB_NAME ".real_start_of"

  if (name == NULL)
    abort ();

  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.  */
  if (name[0] == '.')
    return symbolP;

  real_start = malloc (strlen (name) + strlen (STUB_NAME) + 1);
  sprintf (real_start, "%s%s", STUB_NAME, name);

  new_target = symbol_find (real_start);

  if (new_target == NULL)
    {
      as_warn ("Failed to find real start of function: %s\n", name);
      new_target = symbolP;
    }

  free (real_start);

  return new_target;
}

static void
do_t_branch23 (char * str)
{
  if (my_get_expression (& inst.reloc.exp, & str))
    return;

  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
  inst.reloc.pc_rel = 1;
  end_of_line (str);

  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (   inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
}

static void
do_t_bx (char * str)
{
  int reg;

  skip_whitespace (str);

  if ((reg = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  /* This sets THUMB_H2 from the top bit of reg.  */
  inst.instruction |= reg << 3;

  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.  The reloc
     should cause the alignment to be checked once it is known.  This is
     because BX PC only works if the instruction is word aligned.  */

  end_of_line (str);
}

static void
do_t_compare (char * str)
{
  thumb_mov_compare (str, THUMB_COMPARE);
}

static void
do_t_ldmstm (char * str)
{
  int Rb;
  long range;

  skip_whitespace (str);

  if ((Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    return;

  if (*str != '!')
    as_warn (_("inserted missing '!': load/store multiple always writes back base register"));
  else
    str++;

  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (inst.reloc.type != BFD_RELOC_UNUSED)
    {
      /* This really doesn't seem worth it.  */
      inst.reloc.type = BFD_RELOC_UNUSED;
      inst.error = _("expression too complex");
      return;
    }

  if (range & ~0xff)
    {
      inst.error = _("only lo-regs valid in load/store multiple");
      return;
    }

  inst.instruction |= (Rb << 8) | range;
  end_of_line (str);
}

static void
do_t_ldr (char * str)
{
  thumb_load_store (str, THUMB_LOAD, THUMB_WORD);
}

static void
do_t_ldrb (char * str)
{
  thumb_load_store (str, THUMB_LOAD, THUMB_BYTE);
}

static void
do_t_ldrh (char * str)
{
  thumb_load_store (str, THUMB_LOAD, THUMB_HALFWORD);
}

static void
do_t_lds (char * str)
{
  int Rd, Rb, Ro;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || (Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || *str++ != ']')
    {
      if (! inst.error)
	inst.error = _("syntax: ldrs[b] Rd, [Rb, Ro]");
      return;
    }

  inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
  end_of_line (str);
}

static void
do_t_lsl (char * str)
{
  thumb_shift (str, THUMB_LSL);
}

static void
do_t_lsr (char * str)
{
  thumb_shift (str, THUMB_LSR);
}

static void
do_t_mov (char * str)
{
  thumb_mov_compare (str, THUMB_MOVE);
}

static void
do_t_push_pop (char * str)
{
  long range;

  skip_whitespace (str);

  if ((range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (inst.reloc.type != BFD_RELOC_UNUSED)
    {
      /* This really doesn't seem worth it.  */
      inst.reloc.type = BFD_RELOC_UNUSED;
      inst.error = _("expression too complex");
      return;
    }

  if (range & ~0xff)
    {
      if ((inst.instruction == T_OPCODE_PUSH
	   && (range & ~0xff) == 1 << REG_LR)
	  || (inst.instruction == T_OPCODE_POP
	      && (range & ~0xff) == 1 << REG_PC))
	{
	  inst.instruction |= THUMB_PP_PC_LR;
	  range &= 0xff;
	}
      else
	{
	  inst.error = _("invalid register list to push/pop instruction");
	  return;
	}
    }

  inst.instruction |= range;
  end_of_line (str);
}

static void
do_t_str (char * str)
{
  thumb_load_store (str, THUMB_STORE, THUMB_WORD);
}

static void
do_t_strb (char * str)
{
  thumb_load_store (str, THUMB_STORE, THUMB_BYTE);
}

static void
do_t_strh (char * str)
{
  thumb_load_store (str, THUMB_STORE, THUMB_HALFWORD);
}

static void
do_t_sub (char * str)
{
  thumb_add_sub (str, 1);
}

static void
do_t_swi (char * str)
{
  skip_whitespace (str);

  if (my_get_expression (&inst.reloc.exp, &str))
    return;

  inst.reloc.type = BFD_RELOC_ARM_SWI;
  end_of_line (str);
}

static void
do_t_adr (char * str)
{
  int reg;

  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-4".  */
  skip_whitespace (str);

  /* Store Rd in temporary location inside instruction.  */
  if ((reg = reg_required_here (&str, 4)) == FAIL
      || (reg > 7)  /* For Thumb reg must be r0..r7.  */
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;
  inst.instruction |= REG_PC; /* Rd is already placed into the instruction.  */

  end_of_line (str);
}

static void
insert_reg (const struct reg_entry * r,
	    struct hash_control * htab)
{
  int    len  = strlen (r->name) + 2;
  char * buf  = xmalloc (len);
  char * buf2 = xmalloc (len);
  int    i    = 0;

#ifdef REGISTER_PREFIX
  buf[i++] = REGISTER_PREFIX;
#endif

  strcpy (buf + i, r->name);

  for (i = 0; buf[i]; i++)
    buf2[i] = TOUPPER (buf[i]);

  buf2[i] = '\0';

  hash_insert (htab, buf,  (PTR) r);
  hash_insert (htab, buf2, (PTR) r);
}

static void
build_reg_hsh (struct reg_map * map)
{
  const struct reg_entry *r;

  if ((map->htab = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  for (r = map->names; r->name != NULL; r++)
    insert_reg (r, map->htab);
}

static void
insert_reg_alias (char * str,
		  int regnum,
		  struct hash_control *htab)
{
  const char * error;
  struct reg_entry * new = xmalloc (sizeof (struct reg_entry));
  const char * name = xmalloc (strlen (str) + 1);

  strcpy ((char *) name, str);

  new->name = name;
  new->number = regnum;
  new->builtin = FALSE;

  error = hash_insert (htab, name, (PTR) new);
  if (error)
    {
      as_bad (_("failed to create an alias for %s, reason: %s"),
	    str, error);
      free ((char *) name);
      free (new);
    }
}

/* Look for the .req directive.  This is of the form:

   	new_register_name .req existing_register_name

   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return non-zero.  Otherwise return zero.  */

static int
create_register_alias (char * newname, char * p)
{
  char * q;
  char c;

  q = p;
  skip_whitespace (q);

  c = *p;
  *p = '\0';

  if (*q && !strncmp (q, ".req ", 5))
    {
      char *copy_of_str;
      char *r;

#ifndef IGNORE_OPCODE_CASE
      newname = original_case_string;
#endif
      copy_of_str = newname;

      q += 4;
      skip_whitespace (q);

      for (r = q; *r != '\0'; r++)
	if (*r == ' ')
	  break;

      if (r != q)
	{
	  enum arm_reg_type new_type, old_type;
	  int old_regno;
	  char d = *r;

	  *r = '\0';
	  old_type = arm_reg_parse_any (q);
	  *r = d;

	  new_type = arm_reg_parse_any (newname);

	  if (new_type == REG_TYPE_MAX)
	    {
	      if (old_type != REG_TYPE_MAX)
		{
		  old_regno = arm_reg_parse (&q, all_reg_maps[old_type].htab);
		  insert_reg_alias (newname, old_regno,
				    all_reg_maps[old_type].htab);
		}
	      else
		as_warn (_("register '%s' does not exist\n"), q);
	    }
	  else if (old_type == REG_TYPE_MAX)
	    {
	      as_warn (_("ignoring redefinition of register alias '%s' to non-existant register '%s'"),
		       copy_of_str, q);
	    }
	  else
	    {
	      /* Do not warn about redefinitions to the same alias.  */
	      if (new_type != old_type
		  || (arm_reg_parse (&q, all_reg_maps[old_type].htab)
		      != arm_reg_parse (&q, all_reg_maps[new_type].htab)))
		as_warn (_("ignoring redefinition of register alias '%s'"),
			 copy_of_str);

	    }
	}
      else
	as_warn (_("ignoring incomplete .req pseuso op"));

      *p = c;
      return 1;
    }

  *p = c;
  return 0;
}

static void
set_constant_flonums (void)
{
  int i;

  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
}


static const struct asm_opcode insns[] =
{
  /* Core ARM Instructions.  */
  {"and",        0xe0000000, 3,  ARM_EXT_V1,       do_arit},
  {"ands",       0xe0100000, 3,  ARM_EXT_V1,       do_arit},
  {"eor",        0xe0200000, 3,  ARM_EXT_V1,       do_arit},
  {"eors",       0xe0300000, 3,  ARM_EXT_V1,       do_arit},
  {"sub",        0xe0400000, 3,  ARM_EXT_V1,       do_arit},
  {"subs",       0xe0500000, 3,  ARM_EXT_V1,       do_arit},
  {"rsb",        0xe0600000, 3,  ARM_EXT_V1,       do_arit},
  {"rsbs",       0xe0700000, 3,  ARM_EXT_V1,       do_arit},
  {"add",        0xe0800000, 3,  ARM_EXT_V1,       do_arit},
  {"adds",       0xe0900000, 3,  ARM_EXT_V1,       do_arit},
  {"adc",        0xe0a00000, 3,  ARM_EXT_V1,       do_arit},
  {"adcs",       0xe0b00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbc",        0xe0c00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbcs",       0xe0d00000, 3,  ARM_EXT_V1,       do_arit},
  {"rsc",        0xe0e00000, 3,  ARM_EXT_V1,       do_arit},
  {"rscs",       0xe0f00000, 3,  ARM_EXT_V1,       do_arit},
  {"orr",        0xe1800000, 3,  ARM_EXT_V1,       do_arit},
  {"orrs",       0xe1900000, 3,  ARM_EXT_V1,       do_arit},
  {"bic",        0xe1c00000, 3,  ARM_EXT_V1,       do_arit},
  {"bics",       0xe1d00000, 3,  ARM_EXT_V1,       do_arit},

  {"tst",        0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tsts",       0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tstp",       0xe110f000, 3,  ARM_EXT_V1,       do_cmp},
  {"teq",        0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqs",       0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqp",       0xe130f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmp",        0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmps",       0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmpp",       0xe150f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmn",        0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmns",       0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmnp",       0xe170f000, 3,  ARM_EXT_V1,       do_cmp},

  {"mov",        0xe1a00000, 3,  ARM_EXT_V1,       do_mov},
  {"movs",       0xe1b00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvn",        0xe1e00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvns",       0xe1f00000, 3,  ARM_EXT_V1,       do_mov},

  {"ldr",        0xe4100000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrb",       0xe4500000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrt",       0xe4300000, 3,  ARM_EXT_V1,       do_ldstt},
  {"ldrbt",      0xe4700000, 3,  ARM_EXT_V1,       do_ldstt},
  {"str",        0xe4000000, 3,  ARM_EXT_V1,       do_ldst},
  {"strb",       0xe4400000, 3,  ARM_EXT_V1,       do_ldst},
  {"strt",       0xe4200000, 3,  ARM_EXT_V1,       do_ldstt},
  {"strbt",      0xe4600000, 3,  ARM_EXT_V1,       do_ldstt},

  {"stmia",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmib",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmda",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmdb",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfd",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfa",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmea",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmed",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},

  {"ldmia",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmib",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmda",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmdb",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfd",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfa",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmea",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmed",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},

  {"swi",        0xef000000, 3,  ARM_EXT_V1,       do_swi},
#ifdef TE_WINCE
  /* XXX This is the wrong place to do this.  Think multi-arch.  */
  {"bl",         0xeb000000, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xea000000, 1,  ARM_EXT_V1,       do_branch},
#else
  {"bl",         0xebfffffe, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xeafffffe, 1,  ARM_EXT_V1,       do_branch},
#endif

  /* Pseudo ops.  */
  {"adr",        0xe28f0000, 3,  ARM_EXT_V1,       do_adr},
  {"adrl",       0xe28f0000, 3,  ARM_EXT_V1,       do_adrl},
  {"nop",        0xe1a00000, 3,  ARM_EXT_V1,       do_nop},

  /* ARM 2 multiplies.  */
  {"mul",        0xe0000090, 3,  ARM_EXT_V2,       do_mul},
  {"muls",       0xe0100090, 3,  ARM_EXT_V2,       do_mul},
  {"mla",        0xe0200090, 3,  ARM_EXT_V2,       do_mla},
  {"mlas",       0xe0300090, 3,  ARM_EXT_V2,       do_mla},

  /* Generic coprocessor instructions.  */
  {"cdp",        0xee000000, 3,  ARM_EXT_V2,       do_cdp},
  {"ldc",        0xec100000, 3,  ARM_EXT_V2,       do_lstc},
  {"ldcl",       0xec500000, 3,  ARM_EXT_V2,       do_lstc},
  {"stc",        0xec000000, 3,  ARM_EXT_V2,       do_lstc},
  {"stcl",       0xec400000, 3,  ARM_EXT_V2,       do_lstc},
  {"mcr",        0xee000010, 3,  ARM_EXT_V2,       do_co_reg},
  {"mrc",        0xee100010, 3,  ARM_EXT_V2,       do_co_reg},

  /* ARM 3 - swp instructions.  */
  {"swp",        0xe1000090, 3,  ARM_EXT_V2S,      do_swap},
  {"swpb",       0xe1400090, 3,  ARM_EXT_V2S,      do_swap},

  /* ARM 6 Status register instructions.  */
  {"mrs",        0xe10f0000, 3,  ARM_EXT_V3,       do_mrs},
  {"msr",        0xe120f000, 3,  ARM_EXT_V3,       do_msr},
  /* ScottB: our code uses     0xe128f000 for msr.
     NickC:  but this is wrong because the bits 16 through 19 are
             handled by the PSR_xxx defines above.  */

  /* ARM 7M long multiplies.  */
  {"smull",      0xe0c00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smulls",     0xe0d00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umull",      0xe0800090, 5,  ARM_EXT_V3M,      do_mull},
  {"umulls",     0xe0900090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlal",      0xe0e00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlals",     0xe0f00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlal",      0xe0a00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlals",     0xe0b00090, 5,  ARM_EXT_V3M,      do_mull},

  /* ARM Architecture 4.  */
  {"ldrh",       0xe01000b0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsh",      0xe01000f0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsb",      0xe01000d0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"strh",       0xe00000b0, 3,  ARM_EXT_V4,       do_ldstv4},

  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.  */
  {"bx",         0xe12fff10, 2,  ARM_EXT_V4T | ARM_EXT_V5, do_bx},

  /*  ARM Architecture 5T.  */
  /* Note: blx has 2 variants, so the .value is set dynamically.
     Only one of the variants has conditional execution.  */
  {"blx",        0xe0000000, 3,  ARM_EXT_V5,       do_blx},
  {"clz",        0xe16f0f10, 3,  ARM_EXT_V5,       do_clz},
  {"bkpt",       0xe1200070, 0,  ARM_EXT_V5,       do_bkpt},
  {"ldc2",       0xfc100000, 0,  ARM_EXT_V5,       do_lstc2},
  {"ldc2l",      0xfc500000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2",       0xfc000000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2l",      0xfc400000, 0,  ARM_EXT_V5,       do_lstc2},
  {"cdp2",       0xfe000000, 0,  ARM_EXT_V5,       do_cdp2},
  {"mcr2",       0xfe000010, 0,  ARM_EXT_V5,       do_co_reg2},
  {"mrc2",       0xfe100010, 0,  ARM_EXT_V5,       do_co_reg2},

  /*  ARM Architecture 5TExP.  */
  {"smlabb",     0xe1000080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatb",     0xe10000a0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlabt",     0xe10000c0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatt",     0xe10000e0, 6,  ARM_EXT_V5ExP,    do_smla},

  {"smlawb",     0xe1200080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlawt",     0xe12000c0, 6,  ARM_EXT_V5ExP,    do_smla},

  {"smlalbb",    0xe1400080, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltb",    0xe14000a0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlalbt",    0xe14000c0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltt",    0xe14000e0, 7,  ARM_EXT_V5ExP,    do_smlal},

  {"smulbb",     0xe1600080, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultb",     0xe16000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulbt",     0xe16000c0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultt",     0xe16000e0, 6,  ARM_EXT_V5ExP,    do_smul},

  {"smulwb",     0xe12000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulwt",     0xe12000e0, 6,  ARM_EXT_V5ExP,    do_smul},

  {"qadd",       0xe1000050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdadd",      0xe1400050, 5,  ARM_EXT_V5ExP,    do_qadd},
  {"qsub",       0xe1200050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdsub",      0xe1600050, 5,  ARM_EXT_V5ExP,    do_qadd},

  /*  ARM Architecture 5TE.  */
  {"pld",        0xf450f000, 0,  ARM_EXT_V5E,      do_pld},
  {"ldrd",       0xe00000d0, 3,  ARM_EXT_V5E,      do_ldrd},
  {"strd",       0xe00000f0, 3,  ARM_EXT_V5E,      do_ldrd},

  {"mcrr",       0xec400000, 4,  ARM_EXT_V5E,      do_co_reg2c},
  {"mrrc",       0xec500000, 4,  ARM_EXT_V5E,      do_co_reg2c},

  /*  ARM Architecture 5TEJ.  */
  {"bxj",	 0xe12fff20, 3,  ARM_EXT_V5J,	   do_bxj},

  /*  ARM V6.  */
  { "cps",       0xf1020000, 0,  ARM_EXT_V6,       do_cps},
  { "cpsie",     0xf1080000, 0,  ARM_EXT_V6,       do_cpsi},
  { "cpsid",     0xf10C0000, 0,  ARM_EXT_V6,       do_cpsi},
  { "ldrex",     0xe1900f9f, 5,  ARM_EXT_V6,       do_ldrex},
  { "mcrr2",     0xfc400000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "mrrc2",     0xfc500000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "pkhbt",     0xe6800010, 5,  ARM_EXT_V6,       do_pkhbt},
  { "pkhtb",     0xe6800050, 5,  ARM_EXT_V6,       do_pkhtb},
  { "qadd16",    0xe6200f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "qadd8",     0xe6200f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "qaddsubx",  0xe6200f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "qsub16",    0xe6200f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "qsub8",     0xe6200ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "qsubaddx",  0xe6200f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "sadd16",    0xe6100f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "sadd8",     0xe6100f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "saddsubx",  0xe6100f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "shadd16",   0xe6300f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "shadd8",    0xe6300f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "shaddsubx", 0xe6300f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "shsub16",   0xe6300f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "shsub8",    0xe6300ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "shsubaddx", 0xe6300f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "ssub16",    0xe6100f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "ssub8",     0xe6100ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "ssubaddx",  0xe6100f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "uadd16",    0xe6500f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "uadd8",     0xe6500f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "uaddsubx",  0xe6500f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "uhadd16",   0xe6700f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhadd8",    0xe6700f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhaddsubx", 0xe6700f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uhsub16",   0xe6700f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhsub8",    0xe6700ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhsubaddx", 0xe6700f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqadd16",   0xe6600f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqadd8",    0xe6600f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqaddsubx", 0xe6600f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqsub16",   0xe6600f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqsub8",    0xe6600ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqsubaddx", 0xe6600f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "usub16",    0xe6500f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "usub8",     0xe6500ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "usubaddx",  0xe6500f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "rev",       0xe6bf0f30, 3,  ARM_EXT_V6,       do_rev},
  { "rev16",     0xe6bf0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "revsh",     0xe6ff0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "rfeia",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeib",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeda",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfedb",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefd",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefa",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeea",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeed",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "sxtah",     0xe6b00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxtab16",   0xe6800070, 7,  ARM_EXT_V6,       do_sxtah},
  { "sxtab",     0xe6a00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxth",      0xe6bf0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sxtb16",    0xe68f0070, 6,  ARM_EXT_V6,       do_sxth},
  { "sxtb",      0xe6af0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtah",     0xe6f00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxtab16",   0xe6c00070, 7,  ARM_EXT_V6,       do_sxtah},
  { "uxtab",     0xe6e00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxth",      0xe6ff0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtb16",    0xe6cf0070, 6,  ARM_EXT_V6,       do_sxth},
  { "uxtb",      0xe6ef0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sel",       0xe68000b0, 3,  ARM_EXT_V6,       do_qadd16},
  { "setend",    0xf1010000, 0,  ARM_EXT_V6,       do_setend},
  { "smlad",     0xe7000010, 5,  ARM_EXT_V6,       do_smlad},
  { "smladx",    0xe7000030, 6,  ARM_EXT_V6,       do_smlad},
  { "smlald",    0xe7400010, 6,  ARM_EXT_V6,       do_smlald},
  { "smlaldx",   0xe7400030, 7,  ARM_EXT_V6,       do_smlald},
  { "smlsd",     0xe7000050, 5,  ARM_EXT_V6,       do_smlad},
  { "smlsdx",    0xe7000070, 6,  ARM_EXT_V6,       do_smlad},
  { "smlsld",    0xe7400050, 6,  ARM_EXT_V6,       do_smlald},
  { "smlsldx",   0xe7400070, 7,  ARM_EXT_V6,       do_smlald},
  { "smmla",     0xe7500010, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlar",    0xe7500030, 6,  ARM_EXT_V6,       do_smlad},
  { "smmls",     0xe75000d0, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlsr",    0xe75000f0, 6,  ARM_EXT_V6,       do_smlad},
  { "smmul",     0xe750f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smmulr",    0xe750f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smuad",     0xe700f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smuadx",    0xe700f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smusd",     0xe700f050, 5,  ARM_EXT_V6,       do_smmul},
  { "smusdx",    0xe700f070, 6,  ARM_EXT_V6,       do_smmul},
  { "srsia",     0xf8cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsib",     0xf9cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsda",     0xf84d0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsdb",     0xf94d0500, 0,  ARM_EXT_V6,       do_srs},
  { "ssat",      0xe6a00010, 4,  ARM_EXT_V6,       do_ssat},
  { "ssat16",    0xe6a00f30, 6,  ARM_EXT_V6,       do_ssat16},
  { "strex",     0xe1800f90, 5,  ARM_EXT_V6,       do_strex},
  { "umaal",     0xe0400090, 5,  ARM_EXT_V6,       do_umaal},
  { "usad8",     0xe780f010, 5,  ARM_EXT_V6,       do_smmul},
  { "usada8",    0xe7800010, 6,  ARM_EXT_V6,       do_smlad},
  { "usat",      0xe6e00010, 4,  ARM_EXT_V6,       do_usat},
  { "usat16",    0xe6e00f30, 6,  ARM_EXT_V6,       do_usat16},

  /*  ARM V6K.  */
  { "clrex",     0xf57ff01f, 0,  ARM_EXT_V6K,      do_empty},
  { "ldrexb",    0xe1d00f9f, 6,  ARM_EXT_V6K,      do_ldrex},
  { "ldrexd",    0xe1b00f9f, 6,  ARM_EXT_V6K,      do_ldrex},
  { "ldrexh",    0xe1f00f9f, 6,  ARM_EXT_V6K,      do_ldrex},
  { "sev",       0xe320f004, 3,  ARM_EXT_V6K,      do_empty},
  { "strexb",    0xe1c00f90, 6,  ARM_EXT_V6K,      do_strex},
  { "strexd",    0xe1a00f90, 6,  ARM_EXT_V6K,      do_strex},
  { "strexh",    0xe1e00f90, 6,  ARM_EXT_V6K,      do_strex},
  { "wfe",       0xe320f002, 3,  ARM_EXT_V6K,      do_empty},
  { "wfi",       0xe320f003, 3,  ARM_EXT_V6K,      do_empty},
  { "yield",     0xe320f001, 5,  ARM_EXT_V6K,      do_empty},

  /*  ARM V6Z.  */
  { "smi",       0xe1600070, 3,  ARM_EXT_V6Z,      do_smi},

  /*  ARM V6T2.  */
  { "bfc",       0xe7c0001f, 3,  ARM_EXT_V6T2,     do_bfc},
  { "bfi",       0xe7c00010, 3,  ARM_EXT_V6T2,     do_bfi},
  { "mls",       0xe0600090, 3,  ARM_EXT_V6T2,     do_mls},
  { "movw",      0xe3000000, 4,  ARM_EXT_V6T2,     do_mov16},
  { "movt",      0xe3400000, 4,  ARM_EXT_V6T2,     do_mov16},
  { "rbit",      0xe3ff0f30, 4,  ARM_EXT_V6T2,     do_rbit},
  { "sbfx",      0xe7a00050, 4,  ARM_EXT_V6T2,     do_bfx},
  { "ubfx",      0xe7e00050, 4,  ARM_EXT_V6T2,     do_bfx},

  { "ldrht",     0xe03000b0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "ldrsht",    0xe03000f0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "ldrsbt",    0xe03000d0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "strht",     0xe02000b0, 3,  ARM_EXT_V6T2,     do_ldsttv4},

  /* Core FPA instruction set (V1).  */
  {"wfs",        0xee200110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfs",        0xee300110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"wfc",        0xee400110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfc",        0xee500110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},

  {"ldfs",       0xec100100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfd",       0xec108100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfe",       0xec500100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfp",       0xec508100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},

  {"stfs",       0xec000100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfd",       0xec008100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfe",       0xec400100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfp",       0xec408100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},

  {"mvfs",       0xee008100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsp",      0xee008120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsm",      0xee008140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsz",      0xee008160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfd",       0xee008180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdp",      0xee0081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdm",      0xee0081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdz",      0xee0081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfe",       0xee088100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfep",      0xee088120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfem",      0xee088140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfez",      0xee088160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"mnfs",       0xee108100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsp",      0xee108120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsm",      0xee108140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsz",      0xee108160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfd",       0xee108180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdp",      0xee1081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdm",      0xee1081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdz",      0xee1081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfe",       0xee188100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfep",      0xee188120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfem",      0xee188140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfez",      0xee188160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"abss",       0xee208100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssp",      0xee208120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssm",      0xee208140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssz",      0xee208160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absd",       0xee208180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdp",      0xee2081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdm",      0xee2081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdz",      0xee2081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abse",       0xee288100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absep",      0xee288120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absem",      0xee288140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absez",      0xee288160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"rnds",       0xee308100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsp",      0xee308120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsm",      0xee308140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsz",      0xee308160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndd",       0xee308180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddp",      0xee3081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddm",      0xee3081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddz",      0xee3081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnde",       0xee388100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndep",      0xee388120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndem",      0xee388140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndez",      0xee388160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"sqts",       0xee408100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsp",      0xee408120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsm",      0xee408140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsz",      0xee408160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtd",       0xee408180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdp",      0xee4081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdm",      0xee4081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdz",      0xee4081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqte",       0xee488100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtep",      0xee488120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtem",      0xee488140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtez",      0xee488160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"logs",       0xee508100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsp",      0xee508120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsm",      0xee508140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsz",      0xee508160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logd",       0xee508180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdp",      0xee5081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdm",      0xee5081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdz",      0xee5081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"loge",       0xee588100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logep",      0xee588120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logem",      0xee588140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logez",      0xee588160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"lgns",       0xee608100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsp",      0xee608120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsm",      0xee608140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsz",      0xee608160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnd",       0xee608180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndp",      0xee6081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndm",      0xee6081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndz",      0xee6081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgne",       0xee688100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnep",      0xee688120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnem",      0xee688140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnez",      0xee688160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"exps",       0xee708100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsp",      0xee708120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsm",      0xee708140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsz",      0xee708160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expd",       0xee708180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdp",      0xee7081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdm",      0xee7081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee7081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expe",       0xee788100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expep",      0xee788120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expem",      0xee788140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee788160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"sins",       0xee808100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsp",      0xee808120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsm",      0xee808140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsz",      0xee808160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sind",       0xee808180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindp",      0xee8081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindm",      0xee8081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindz",      0xee8081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sine",       0xee888100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinep",      0xee888120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinem",      0xee888140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinez",      0xee888160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"coss",       0xee908100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossp",      0xee908120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossm",      0xee908140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossz",      0xee908160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosd",       0xee908180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdp",      0xee9081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdm",      0xee9081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdz",      0xee9081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cose",       0xee988100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosep",      0xee988120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosem",      0xee988140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosez",      0xee988160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"tans",       0xeea08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansp",      0xeea08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansm",      0xeea08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansz",      0xeea08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tand",       0xeea08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandp",      0xeea081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandm",      0xeea081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandz",      0xeea081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tane",       0xeea88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanep",      0xeea88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanem",      0xeea88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanez",      0xeea88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"asns",       0xeeb08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsp",      0xeeb08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsm",      0xeeb08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsz",      0xeeb08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnd",       0xeeb08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndp",      0xeeb081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndm",      0xeeb081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndz",      0xeeb081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asne",       0xeeb88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnep",      0xeeb88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnem",      0xeeb88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnez",      0xeeb88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"acss",       0xeec08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssp",      0xeec08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssm",      0xeec08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssz",      0xeec08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsd",       0xeec08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdp",      0xeec081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdm",      0xeec081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdz",      0xeec081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acse",       0xeec88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsep",      0xeec88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsem",      0xeec88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsez",      0xeec88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"atns",       0xeed08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsp",      0xeed08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsm",      0xeed08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsz",      0xeed08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnd",       0xeed08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndp",      0xeed081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndm",      0xeed081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndz",      0xeed081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atne",       0xeed88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnep",      0xeed88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnem",      0xeed88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnez",      0xeed88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"urds",       0xeee08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsp",      0xeee08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsm",      0xeee08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsz",      0xeee08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdd",       0xeee08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddp",      0xeee081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddm",      0xeee081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddz",      0xeee081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urde",       0xeee88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdep",      0xeee88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdem",      0xeee88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdez",      0xeee88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"nrms",       0xeef08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsp",      0xeef08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsm",      0xeef08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsz",      0xeef08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmd",       0xeef08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdp",      0xeef081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdm",      0xeef081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdz",      0xeef081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrme",       0xeef88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmep",      0xeef88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmem",      0xeef88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmez",      0xeef88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"adfs",       0xee000100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsp",      0xee000120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsm",      0xee000140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsz",      0xee000160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfd",       0xee000180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdp",      0xee0001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdm",      0xee0001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdz",      0xee0001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfe",       0xee080100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfep",      0xee080120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfem",      0xee080140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfez",      0xee080160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"sufs",       0xee200100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsp",      0xee200120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsm",      0xee200140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsz",      0xee200160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufd",       0xee200180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdp",      0xee2001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdm",      0xee2001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdz",      0xee2001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufe",       0xee280100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufep",      0xee280120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufem",      0xee280140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufez",      0xee280160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rsfs",       0xee300100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsp",      0xee300120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsm",      0xee300140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsz",      0xee300160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfd",       0xee300180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdp",      0xee3001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdm",      0xee3001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdz",      0xee3001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfe",       0xee380100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfep",      0xee380120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfem",      0xee380140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfez",      0xee380160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"mufs",       0xee100100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsp",      0xee100120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsm",      0xee100140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsz",      0xee100160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufd",       0xee100180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdp",      0xee1001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdm",      0xee1001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdz",      0xee1001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufe",       0xee180100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufep",      0xee180120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufem",      0xee180140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufez",      0xee180160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"dvfs",       0xee400100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsp",      0xee400120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsm",      0xee400140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsz",      0xee400160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfd",       0xee400180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdp",      0xee4001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdm",      0xee4001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdz",      0xee4001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfe",       0xee480100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfep",      0xee480120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfem",      0xee480140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfez",      0xee480160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rdfs",       0xee500100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsp",      0xee500120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsm",      0xee500140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsz",      0xee500160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfd",       0xee500180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdp",      0xee5001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdm",      0xee5001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdz",      0xee5001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfe",       0xee580100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfep",      0xee580120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfem",      0xee580140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfez",      0xee580160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"pows",       0xee600100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsp",      0xee600120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsm",      0xee600140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsz",      0xee600160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powd",       0xee600180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdp",      0xee6001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdm",      0xee6001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdz",      0xee6001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powe",       0xee680100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powep",      0xee680120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powem",      0xee680140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powez",      0xee680160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rpws",       0xee700100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsp",      0xee700120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsm",      0xee700140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsz",      0xee700160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwd",       0xee700180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdp",      0xee7001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdm",      0xee7001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdz",      0xee7001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwe",       0xee780100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwep",      0xee780120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwem",      0xee780140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwez",      0xee780160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rmfs",       0xee800100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsp",      0xee800120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsm",      0xee800140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsz",      0xee800160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfd",       0xee800180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdp",      0xee8001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdm",      0xee8001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdz",      0xee8001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfe",       0xee880100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfep",      0xee880120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfem",      0xee880140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfez",      0xee880160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"fmls",       0xee900100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsp",      0xee900120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsm",      0xee900140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsz",      0xee900160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmld",       0xee900180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldp",      0xee9001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldm",      0xee9001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldz",      0xee9001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmle",       0xee980100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlep",      0xee980120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlem",      0xee980140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlez",      0xee980160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"fdvs",       0xeea00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsp",      0xeea00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsm",      0xeea00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsz",      0xeea00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvd",       0xeea00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdp",      0xeea001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdm",      0xeea001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdz",      0xeea001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdve",       0xeea80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvep",      0xeea80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvem",      0xeea80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvez",      0xeea80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"frds",       0xeeb00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsp",      0xeeb00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsm",      0xeeb00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsz",      0xeeb00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdd",       0xeeb00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddp",      0xeeb001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddm",      0xeeb001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddz",      0xeeb001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frde",       0xeeb80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdep",      0xeeb80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdem",      0xeeb80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdez",      0xeeb80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"pols",       0xeec00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsp",      0xeec00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsm",      0xeec00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsz",      0xeec00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pold",       0xeec00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldp",      0xeec001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldm",      0xeec001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldz",      0xeec001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pole",       0xeec80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polep",      0xeec80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polem",      0xeec80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polez",      0xeec80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"cmf",        0xee90f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cmfe",       0xeed0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnf",        0xeeb0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  /* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should
     not be an optional suffix, but part of the instruction.  To be
     compatible, we accept either.  */
  {"cmfe",       0xeed0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},

  {"flts",       0xee000110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsp",      0xee000130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsm",      0xee000150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsz",      0xee000170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltd",       0xee000190, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdp",      0xee0001b0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdm",      0xee0001d0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdz",      0xee0001f0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"flte",       0xee080110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltep",      0xee080130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltem",      0xee080150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltez",      0xee080170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},

  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
  {"fix",        0xee100110, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixp",       0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixm",       0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixz",       0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixep",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixem",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixez",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},

  /* Instructions that were new with the real FPA, call them V2.  */
  {"lfm",        0xec100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmfd",      0xec900200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmea",      0xed100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfm",        0xec000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmfd",      0xed000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmea",      0xec800200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},

  /* VFP V1xD (single precision).  */
  /* Moves and type conversions.  */
  {"fcpys",   0xeeb00a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrs",    0xee100a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_sp},
  {"fmsr",    0xee000a10, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_from_reg},
  {"fmstat",  0xeef1fa10, 6, FPU_VFP_EXT_V1xD, do_empty},
  {"fsitos",  0xeeb80ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fuitos",  0xeeb80a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosis",  0xeebd0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosizs", 0xeebd0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouis",  0xeebc0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouizs", 0xeebc0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrx",    0xeef00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_ctrl},
  {"fmxr",    0xeee00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_ctrl_from_reg},

  /* Memory operations.  */
  {"flds",    0xed100a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fsts",    0xed000a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fldmias", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmfds", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmdbs", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmeas", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmiax", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmfdx", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmdbx", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fldmeax", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmias", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmeas", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmdbs", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmfds", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmiax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmeax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmdbx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmfdx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},

  /* Monadic operations.  */
  {"fabss",   0xeeb00ac0, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fnegs",   0xeeb10a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fsqrts",  0xeeb10ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},

  /* Dyadic operations.  */
  {"fadds",   0xee300a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fsubs",   0xee300a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmuls",   0xee200a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fdivs",   0xee800a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmacs",   0xee000a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmscs",   0xee100a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmuls",  0xee200a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmacs",  0xee000a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmscs",  0xee100a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},

  /* Comparisons.  */
  {"fcmps",   0xeeb40a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpzs",  0xeeb50a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},
  {"fcmpes",  0xeeb40ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpezs", 0xeeb50ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},

  /* VFP V1 (Double precision).  */
  /* Moves and type conversions.  */
  {"fcpyd",   0xeeb00b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcvtds",  0xeeb70ac0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fcvtsd",  0xeeb70bc0, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"fmdhr",   0xee200b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmdlr",   0xee000b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmrdh",   0xee300b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fmrdl",   0xee100b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fsitod",  0xeeb80bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fuitod",  0xeeb80b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"ftosid",  0xeebd0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftosizd", 0xeebd0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouid",  0xeebc0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouizd", 0xeebc0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},

  /* Memory operations.  */
  {"fldd",    0xed100b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fstd",    0xed000b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fldmiad", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmfdd", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmdbd", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fldmead", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmiad", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmead", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmdbd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmfdd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},

  /* Monadic operations.  */
  {"fabsd",   0xeeb00bc0, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fnegd",   0xeeb10b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fsqrtd",  0xeeb10bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},

  /* Dyadic operations.  */
  {"faddd",   0xee300b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fsubd",   0xee300b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmuld",   0xee200b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fdivd",   0xee800b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmacd",   0xee000b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmscd",   0xee100b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmuld",  0xee200b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmacd",  0xee000b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmscd",  0xee100b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},

  /* Comparisons.  */
  {"fcmpd",   0xeeb40b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpzd",  0xeeb50b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},
  {"fcmped",  0xeeb40bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpezd", 0xeeb50bc0, 7, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},

  /* VFP V2.  */
  {"fmsrr",   0xec400a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp2_from_reg2},
  {"fmrrs",   0xec500a10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_sp2},
  {"fmdrr",   0xec400b10, 5, FPU_VFP_EXT_V2,   do_vfp_dp_from_reg2},
  {"fmrrd",   0xec500b10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_dp},

  /* Intel XScale extensions to ARM V5 ISA.  (All use CP0).  */
  {"mia",        0xee200010, 3,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miaph",      0xee280010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabb",      0xee2c0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabt",      0xee2d0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatb",      0xee2e0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatt",      0xee2f0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"mar",        0xec400000, 3,  ARM_CEXT_XSCALE,   do_xsc_mar},
  {"mra",        0xec500000, 3,  ARM_CEXT_XSCALE,   do_xsc_mra},

  /* Intel Wireless MMX technology instructions.  */
  {"tandcb",     0xee130130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandch",     0xee530130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandcw",     0xee930130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tbcstb",     0xee400010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcsth",     0xee400050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcstw",     0xee400090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"textrcb",    0xee130170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrch",    0xee530170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrcw",    0xee930170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrmub",   0xee100070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuh",   0xee500070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuw",   0xee900070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsb",   0xee100078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsh",   0xee500078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsw",   0xee900078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"tinsrb",     0xee600010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrh",     0xee600050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrw",     0xee600090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tmcr",       0xee000110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmcr},
  {"tmcrr",      0xec400000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmcrr},
  {"tmia",       0xee200010, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiaph",     0xee280010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabb",     0xee2c0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabt",     0xee2d0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatb",     0xee2e0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatt",     0xee2f0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmovmskb",   0xee100030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskh",   0xee500030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskw",   0xee900030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmrc",       0xee100110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmrc},
  {"tmrrc",      0xec500000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmrrc},
  {"torcb",      0xee130150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torch",      0xee530150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torcw",      0xee930150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"waccb",      0xee0001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wacch",      0xee4001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waccw",      0xee8001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waddbss",    0xee300180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddb",      0xee000180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddbus",    0xee100180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhss",    0xee700180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddh",      0xee400180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhus",    0xee500180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwss",    0xeeb00180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddw",      0xee800180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwus",    0xee900180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waligni",    0xee000020, 7, ARM_CEXT_IWMMXT, do_iwmmxt_waligni},
  {"walignr0",   0xee800020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr1",   0xee900020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr2",   0xeea00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr3",   0xeeb00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wand",       0xee200000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wandn",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2b",     0xee800000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2br",    0xee900000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2h",     0xeec00000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2hr",    0xeed00000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqb",    0xee000060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqh",    0xee400060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqw",    0xee800060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtub",   0xee100060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuh",   0xee500060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuw",   0xee900060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsb",   0xee300060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsh",   0xee700060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsw",   0xeeb00060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wldrb",      0xec100000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrh",      0xec100100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrw",      0xec100200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wldrd",      0xec100300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wmacs",      0xee600100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacsz",     0xee700100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacu",      0xee400100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacuz",     0xee500100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmadds",     0xeea00100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaddu",     0xee800100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsb",     0xee200160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsh",     0xee600160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsw",     0xeea00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxub",     0xee000160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuh",     0xee400160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuw",     0xee800160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsb",     0xee300160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsh",     0xee700160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsw",     0xeeb00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminub",     0xee100160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuh",     0xee500160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuw",     0xee900160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmov",       0xee000000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wmov},
  {"wmulsm",     0xee300100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulsl",     0xee200100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulum",     0xee100100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulul",     0xee000100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wor",        0xee000000, 3, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhss",   0xee700080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhus",   0xee500080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwss",   0xeeb00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwus",   0xee900080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdss",   0xeef00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdus",   0xeed00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorh",      0xee700040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorhg",     0xee700148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrorw",      0xeeb00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorwg",     0xeeb00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrord",      0xeef00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrordg",     0xeef00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsadb",      0xee000120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadbz",     0xee100120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadh",      0xee400120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadhz",     0xee500120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wshufh",     0xee0001e0, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wshufh},
  {"wsllh",      0xee500040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllhg",     0xee500148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsllw",      0xee900040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllwg",     0xee900148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wslld",      0xeed00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wslldg",     0xeed00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrah",      0xee400040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrahg",     0xee400148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsraw",      0xee800040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrawg",     0xee800148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrad",      0xeec00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsradg",     0xeec00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlh",      0xee600040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlhg",     0xee600148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlw",      0xeea00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlwg",     0xeea00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrld",      0xeee00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrldg",     0xeee00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wstrb",      0xec000000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrh",      0xec000100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrw",      0xec000200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wstrd",      0xec000300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wsubbss",    0xee3001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubb",      0xee0001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubbus",    0xee1001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhss",    0xee7001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubh",      0xee4001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhus",    0xee5001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwss",    0xeeb001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubw",      0xee8001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwus",    0xee9001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckehub", 0xee0000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuh", 0xee4000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuw", 0xee8000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsb", 0xee2000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsh", 0xee6000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsw", 0xeea000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckihb",  0xee1000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihh",  0xee5000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihw",  0xee9000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckelub", 0xee0000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluh", 0xee4000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluw", 0xee8000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsb", 0xee2000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsh", 0xee6000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsw", 0xeea000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckilb",  0xee1000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilh",  0xee5000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilw",  0xee9000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wxor",       0xee100000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wzero",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wzero},

  /* Cirrus Maverick instructions.  */
  {"cfldrs",     0xec100400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfldrd",     0xec500400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfldr32",    0xec100500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfldr64",    0xec500500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfstrs",     0xec000400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfstrd",     0xec400400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfstr32",    0xec000500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfstr64",    0xec400500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfmvsr",     0xee000450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_2a},
  {"cfmvrs",     0xee100450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1a},
  {"cfmvdlr",    0xee000410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdl",    0xee100410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmvdhr",    0xee000430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdh",    0xee100430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmv64lr",   0xee000510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64l",   0xee100510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmv64hr",   0xee000530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64h",   0xee100530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmval32",   0xee200440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32al",   0xee100440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvam32",   0xee200460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32am",   0xee100460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvah32",   0xee200480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32ah",   0xee100480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva32",    0xee2004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32a",    0xee1004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva64",    0xee2004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3c},
  {"cfmv64a",    0xee1004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3d},
  {"cfmvsc32",   0xee2004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_1},
  {"cfmv32sc",   0xee1004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_2},
  {"cfcpys",     0xee000400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfcpyd",     0xee000420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfcvtsd",    0xee000460, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1f},
  {"cfcvtds",    0xee000440, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1g},
  {"cfcvt32s",   0xee000480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1h},
  {"cfcvt32d",   0xee0004a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1i},
  {"cfcvt64s",   0xee0004c0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1j},
  {"cfcvt64d",   0xee0004e0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1k},
  {"cfcvts32",   0xee100580, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cfcvtd32",   0xee1005a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cftruncs32", 0xee1005c0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cftruncd32", 0xee1005e0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cfrshl32",   0xee000550, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4a},
  {"cfrshl64",   0xee000570, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4b},
  {"cfsh32",     0xee000500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_1},
  {"cfsh64",     0xee200500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_2},
  {"cfcmps",     0xee100490, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5a},
  {"cfcmpd",     0xee1004b0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5b},
  {"cfcmp32",    0xee100590, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5c},
  {"cfcmp64",    0xee1005b0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5d},
  {"cfabss",     0xee300400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfabsd",     0xee300420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfnegs",     0xee300440, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfnegd",     0xee300460, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfadds",     0xee300480, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfaddd",     0xee3004a0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfsubs",     0xee3004c0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfsubd",     0xee3004e0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfmuls",     0xee100400, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfmuld",     0xee100420, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfabs32",    0xee300500, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfabs64",    0xee300520, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfneg32",    0xee300540, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfneg64",    0xee300560, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfadd32",    0xee300580, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfadd64",    0xee3005a0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfsub32",    0xee3005c0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfsub64",    0xee3005e0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmul32",    0xee100500, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmul64",    0xee100520, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmac32",    0xee100540, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmsc32",    0xee100560, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmadd32",   0xee000600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmsub32",   0xee100600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmadda32",  0xee200600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
  {"cfmsuba32",  0xee300600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
};

/* Iterate over the base tables to create the instruction patterns.  */

static void
build_arm_ops_hsh (void)
{
  unsigned int i;
  unsigned int j;
  static struct obstack insn_obstack;

  obstack_begin (&insn_obstack, 4000);

  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    {
      const struct asm_opcode *insn = insns + i;

      if (insn->cond_offset != 0)
	{
	  /* Insn supports conditional execution.  Build the varaints
	     and insert them in the hash table.  */
	  for (j = 0; j < sizeof (conds) / sizeof (struct asm_cond); j++)
	    {
	      unsigned len = strlen (insn->template);
	      struct asm_opcode *new;
	      char *template;

	      new = obstack_alloc (&insn_obstack, sizeof (struct asm_opcode));
	      /* All condition codes are two characters.  */
	      template = obstack_alloc (&insn_obstack, len + 3);

	      strncpy (template, insn->template, insn->cond_offset);
	      strcpy (template + insn->cond_offset, conds[j].template);
	      if (len > insn->cond_offset)
		strcpy (template + insn->cond_offset + 2,
			insn->template + insn->cond_offset);
	      new->template = template;
	      new->cond_offset = 0;
	      new->variant = insn->variant;
	      new->parms = insn->parms;
	      new->value = (insn->value & ~COND_MASK) | conds[j].value;

	      hash_insert (arm_ops_hsh, new->template, (PTR) new);
	    }
	}
      /* Finally, insert the unconditional insn in the table directly;
	 no need to build a copy.  */
      hash_insert (arm_ops_hsh, insn->template, (PTR) insn);
    }
}


static const struct thumb_opcode tinsns[] =
{
  /* Thumb v1 (ARMv4T).  */
  {"adc",	0x4140,		2,	ARM_EXT_V4T, do_t_arit},
  {"add",	0x0000,		2,	ARM_EXT_V4T, do_t_add},
  {"and",	0x4000,		2,	ARM_EXT_V4T, do_t_arit},
  {"asr",	0x0000,		2,	ARM_EXT_V4T, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_EXT_V4T, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_EXT_V4T, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_EXT_V4T, do_t_branch23},
  {"bx",	0x4700,		2,	ARM_EXT_V4T, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_EXT_V4T, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_EXT_V4T, do_t_compare},
  {"eor",	0x4040,		2,	ARM_EXT_V4T, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_EXT_V4T, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_EXT_V4T, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_EXT_V4T, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_EXT_V4T, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_EXT_V4T, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_EXT_V4T, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_EXT_V4T, do_t_arit},
  {"orr",	0x4300,		2,	ARM_EXT_V4T, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_EXT_V4T, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_EXT_V4T, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_EXT_V4T, do_t_str},
  {"strb",	0x0000,		2,	ARM_EXT_V4T, do_t_strb},
  {"strh",	0x0000,		2,	ARM_EXT_V4T, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_EXT_V4T, do_t_swi},
  {"sub",	0x0000,		2,	ARM_EXT_V4T, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_EXT_V4T, do_t_arit},
  /* Pseudo ops:  */
  {"adr",       0x0000,         2,      ARM_EXT_V4T, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_EXT_V4T, do_t_nop},      /* mov r8,r8  */
  /* Thumb v2 (ARMv5T).  */
  {"blx",	0,		0,	ARM_EXT_V5T, do_t_blx},
  {"bkpt",	0xbe00,		2,	ARM_EXT_V5T, do_t_bkpt},

  /* ARM V6.  */
  {"cpsie",	0xb660,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpsid",     0xb670,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpy",	0x4600,		2,	ARM_EXT_V6,  do_t_cpy},
  {"rev",	0xba00,		2,	ARM_EXT_V6,  do_t_arit},
  {"rev16",	0xba40,		2,	ARM_EXT_V6,  do_t_arit},
  {"revsh",	0xbac0,		2,	ARM_EXT_V6,  do_t_arit},
  {"setend",	0xb650,		2,	ARM_EXT_V6,  do_t_setend},
  {"sxth",	0xb200,		2,	ARM_EXT_V6,  do_t_arit},
  {"sxtb",	0xb240,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxth",	0xb280,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxtb",	0xb2c0,		2,	ARM_EXT_V6,  do_t_arit},

  /* ARM V6K.  */
  {"sev",	0xbf40,		2,	ARM_EXT_V6K, do_empty},
  {"wfe",	0xbf20,		2,	ARM_EXT_V6K, do_empty},
  {"wfi",	0xbf30,		2,	ARM_EXT_V6K, do_empty},
  {"yield",	0xbf10,		2,	ARM_EXT_V6K, do_empty},
};

void
md_begin (void)
{
  unsigned mach;
  unsigned int i;

  if (   (arm_ops_hsh = hash_new ()) == NULL
      || (arm_tops_hsh = hash_new ()) == NULL
      || (arm_cond_hsh = hash_new ()) == NULL
      || (arm_shift_hsh = hash_new ()) == NULL
      || (arm_psr_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  build_arm_ops_hsh ();
  for (i = 0; i < sizeof (tinsns) / sizeof (struct thumb_opcode); i++)
    hash_insert (arm_tops_hsh, tinsns[i].template, (PTR) (tinsns + i));
  for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
    hash_insert (arm_cond_hsh, conds[i].template, (PTR) (conds + i));
  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
    hash_insert (arm_shift_hsh, shift_names[i].name, (PTR) (shift_names + i));
  for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
    hash_insert (arm_psr_hsh, psrs[i].template, (PTR) (psrs + i));

  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    build_reg_hsh (all_reg_maps + i);

  set_constant_flonums ();

  /* Set the cpu variant based on the command-line options.  We prefer
     -mcpu= over -march= if both are set (as for GCC); and we prefer
     -mfpu= over any other way of setting the floating point unit.
     Use of legacy options with new options are faulted.  */
  if (legacy_cpu != -1)
    {
      if (mcpu_cpu_opt != -1 || march_cpu_opt != -1)
	as_bad (_("use of old and new-style options to set CPU type"));

      mcpu_cpu_opt = legacy_cpu;
    }
  else if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = march_cpu_opt;

  if (legacy_fpu != -1)
    {
      if (mfpu_opt != -1)
	as_bad (_("use of old and new-style options to set FPU type"));

      mfpu_opt = legacy_fpu;
    }
  else if (mfpu_opt == -1)
    {
#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined (TE_VXWORKS)) 
      /* Some environments specify a default FPU.  If they don't, infer it
	 from the processor.  */
      if (mcpu_fpu_opt != -1)
	mfpu_opt = mcpu_fpu_opt;
      else
	mfpu_opt = march_fpu_opt;
#else
      mfpu_opt = FPU_DEFAULT;
#endif
    }

  if (mfpu_opt == -1)
    {
      if (mcpu_cpu_opt == -1)
	mfpu_opt = FPU_DEFAULT;
      else if (mcpu_cpu_opt & ARM_EXT_V5)
	mfpu_opt = FPU_ARCH_VFP_V2;
      else
	mfpu_opt = FPU_ARCH_FPA;
    }

  if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = CPU_DEFAULT;

  cpu_variant = mcpu_cpu_opt | mfpu_opt;

#if defined OBJ_COFF || defined OBJ_ELF
  {
    unsigned int flags = 0;

#if defined OBJ_ELF
    flags = meabi_flags;

    switch (meabi_flags)
      {
      case EF_ARM_EABI_UNKNOWN:
#endif
	/* Set the flags in the private structure.  */
	if (uses_apcs_26)      flags |= F_APCS26;
	if (support_interwork) flags |= F_INTERWORK;
	if (uses_apcs_float)   flags |= F_APCS_FLOAT;
	if (pic_code)          flags |= F_PIC;
	if ((cpu_variant & FPU_ANY) == FPU_NONE
	     || (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
	  flags |= F_SOFT_FLOAT;

	switch (mfloat_abi_opt)
	  {
	  case ARM_FLOAT_ABI_SOFT:
	  case ARM_FLOAT_ABI_SOFTFP:
	    flags |= F_SOFT_FLOAT;
	    break;

	  case ARM_FLOAT_ABI_HARD:
	    if (flags & F_SOFT_FLOAT)
	      as_bad (_("hard-float conflicts with specified fpu"));
	    break;
	  }

	/* Using VFP conventions (even if soft-float).  */
	if (cpu_variant & FPU_VFP_EXT_NONE)
	  flags |= F_VFP_FLOAT;

#if defined OBJ_ELF
	if (cpu_variant & FPU_ARCH_MAVERICK)
	    flags |= EF_ARM_MAVERICK_FLOAT;
	break;

      case EF_ARM_EABI_VER4:
	/* No additional flags to set.  */
	break;

      default:
	abort ();
      }
#endif
    bfd_set_private_flags (stdoutput, flags);

    /* We have run out flags in the COFF header to encode the
       status of ATPCS support, so instead we create a dummy,
       empty, debug section called .arm.atpcs.  */
    if (atpcs)
      {
	asection * sec;

	sec = bfd_make_section (stdoutput, ".arm.atpcs");

	if (sec != NULL)
	  {
	    bfd_set_section_flags
	      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);
	    bfd_set_section_size (stdoutput, sec, 0);
	    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);
	  }
      }
  }
#endif

  /* Record the CPU type as well.  */
  switch (cpu_variant & ARM_CPU_MASK)
    {
    case ARM_2:
      mach = bfd_mach_arm_2;
      break;

    case ARM_3: 		/* Also ARM_250.  */
      mach = bfd_mach_arm_2a;
      break;

    case ARM_6:			/* Also ARM_7.  */
      mach = bfd_mach_arm_3;
      break;

    default:
      mach = bfd_mach_arm_unknown;
      break;
    }

  /* Catch special cases.  */
  if (cpu_variant & ARM_CEXT_IWMMXT)
    mach = bfd_mach_arm_iWMMXt;
  else if (cpu_variant & ARM_CEXT_XSCALE)
    mach = bfd_mach_arm_XScale;
  else if (cpu_variant & ARM_CEXT_MAVERICK)
    mach = bfd_mach_arm_ep9312;
  else if (cpu_variant & ARM_EXT_V5E)
    mach = bfd_mach_arm_5TE;
  else if (cpu_variant & ARM_EXT_V5)
    {
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_5T;
      else
	mach = bfd_mach_arm_5;
    }
  else if (cpu_variant & ARM_EXT_V4)
    {
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_4T;
      else
	mach = bfd_mach_arm_4;
    }
  else if (cpu_variant & ARM_EXT_V3M)
    mach = bfd_mach_arm_3M;

  bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
}

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).  */

void
md_number_to_chars (char * buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

static valueT
md_chars_to_number (char * buf, int n)
{
  valueT result = 0;
  unsigned char * where = (unsigned char *) buf;

  if (target_big_endian)
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (*where++ & 255);
	}
    }
  else
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (where[n] & 255);
	}
    }

  return result;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.

   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.  However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.

   ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */

char *
md_atof (int type, char * litP, int * sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * 2;

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      if (cpu_variant & FPU_ARCH_VFP)
	for (i = prec - 1; i >= 0; i--)
	  {
	    md_number_to_chars (litP, (valueT) words[i], 2);
	    litP += 2;
	  }
      else
	/* For a 4 byte float the order of elements in `words' is 1 0.
	   For an 8 byte float the order is 1 0 3 2.  */
	for (i = 0; i < prec; i += 2)
	  {
	    md_number_to_chars (litP, (valueT) words[i + 1], 2);
	    md_number_to_chars (litP + 2, (valueT) words[i], 2);
	    litP += 4;
	  }
    }

  return 0;
}

/* The knowledge of the PC's pipeline offset is built into the insns
   themselves.  */

long
md_pcrel_from (fixS * fixP)
{
  if (fixP->fx_addsy
      && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section
      && fixP->fx_subsy == NULL)
    return 0;

  if (fixP->fx_pcrel && (fixP->fx_r_type == BFD_RELOC_ARM_THUMB_ADD))
    {
      /* PC relative addressing on the Thumb is slightly odd
	 as the bottom two bits of the PC are forced to zero
	 for the calculation.  */
      return (fixP->fx_where + fixP->fx_frag->fr_address) & ~3;
    }

#ifdef TE_WINCE
  /* The pattern was adjusted to accommodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accommodation.  */
  return fixP->fx_where + fixP->fx_frag->fr_address + 8;
#else
  return fixP->fx_where + fixP->fx_frag->fr_address;
#endif
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT   segment ATTRIBUTE_UNUSED,
		  valueT size)
{
#ifdef OBJ_ELF
  return size;
#else
  /* Round all sects to multiple of 4.  */
  return (size + 3) & ~3;
#endif
}

/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
   Otherwise we have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
{
#ifdef OBJ_ELF
  if (name[0] == '_' && name[1] == 'G'
      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");

	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, & zero_address_frag);
	}

      return GOT_symbol;
    }
#endif

  return 0;
}

void
md_apply_fix3 (fixS *   fixP,
	       valueT * valP,
	       segT     seg)
{
  offsetT        value = * valP;
  offsetT        newval;
  unsigned int   newimm;
  unsigned long  temp;
  int            sign;
  char *         buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  arm_fix_data * arm_data = (arm_fix_data *) fixP->tc_fix_data;

  assert (fixP->fx_r_type <= BFD_RELOC_UNUSED);

  /* Note whether this will delete the relocation.  */
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
    fixP->fx_done = 1;

  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo it's effects here.  */
  if (fixP->fx_pcrel)
    {
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
    }

  /* Remember value for emit_reloc.  */
  fixP->fx_addnumber = value;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_NONE:
      /* This will need to go in the object file.  */
      fixP->fx_done = 0;
      break;
  
    case BFD_RELOC_ARM_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;

      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
	}

      newimm = validate_immediate (value);
      temp = md_chars_to_number (buf, INSN_SIZE);

      /* If the instruction will fail, see if we can fix things up by
	 changing the opcode.  */
      if (newimm == (unsigned int) FAIL
	  && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}

      newimm |= (temp & 0xfffff000);
      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      {
	unsigned int highpart = 0;
	unsigned int newinsn  = 0xe1a00000; /* nop.  */

	newimm = validate_immediate (value);
	temp = md_chars_to_number (buf, INSN_SIZE);

	/* If the instruction will fail, see if we can fix things up by
	   changing the opcode.  */
	if (newimm == (unsigned int) FAIL
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
	  {
	    /* No ?  OK - try using two ADD instructions to generate
               the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);

	    /* Yes - then make sure that the second instruction is
               also an add.  */
	    if (newimm != (unsigned int) FAIL)
	      newinsn = temp;
	    /* Still No ?  Try using a negated value.  */
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
	    /* Otherwise - give up.  */
	    else
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
			      (long) value);
		break;
	      }

	    /* Replace the first operand in the 2nd instruction (which
	       is the PC) with the destination register.  We have
	       already added in the PC in the first instruction and we
	       do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
	    newinsn |= ((newinsn & 0x0f000) << 4);
	  }

	newimm |= (temp & 0xfffff000);
	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);

	highpart |= (newinsn & 0xfffff000);
	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
      }
      break;

    case BFD_RELOC_ARM_OFFSET_IMM:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 0) == FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("bad immediate value for offset (%ld)"),
			(long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 1) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad (_("bad immediate value for half-word offset (%ld)"),
		    (long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff0f0;
      newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_LITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 0) == FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid literal constant: pool needs to be closer"));
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SHIFT_IMM:
      newval = md_chars_to_number (buf, INSN_SIZE);
      if (((unsigned long) value) > 32
	  || (value == 32
	      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("shift expression is too large"));
	  break;
	}

      if (value == 0)
	/* Shifts of zero must be done as lsl.  */
	newval &= ~0x60;
      else if (value == 32)
	value = 0;
      newval &= 0xfffff07f;
      newval |= (value & 0x1f) << 7;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SMI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid smi expression"));
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xfff000f0;
      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SWI:
      if (arm_data->thumb_mode)
	{
	  if (((unsigned long) value) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, THUMB_SIZE) & 0xff00;
	  newval |= value;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      else
	{
	  if (((unsigned long) value) > 0x00ffffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, INSN_SIZE) & 0xff000000;
	  newval |= value;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_MULTI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid expression in load/store multiple"));
      newval = value | md_chars_to_number (buf, INSN_SIZE);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_PCREL_BRANCH:
      newval = md_chars_to_number (buf, INSN_SIZE);

      /* Sign-extend a 24-bit number.  */
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)

#ifdef OBJ_ELF
      value = fixP->fx_offset;
#endif

      /* We are going to store value (shifted right by two) in the
	 instruction, in a 24 bit, signed field.  Thus we need to check
	 that none of the top 8 bits of the shifted value (top 7 bits of
         the unshifted, unsigned value) are set, or that they are all set.  */
      if ((value & ~ ((offsetT) 0x1ffffff)) != 0
	  && ((value & ~ ((offsetT) 0x1ffffff)) != ~ ((offsetT) 0x1ffffff)))
	{
#ifdef OBJ_ELF
	  /* Normally we would be stuck at this point, since we cannot store
	     the absolute address that is the destination of the branch in the
	     24 bits of the branch instruction.  If however, we happen to know
	     that the destination of the branch is in the same section as the
	     branch instruction itself, then we can compute the relocation for
	     ourselves and not have to bother the linker with it.

	     FIXME: The test for OBJ_ELF is only here because I have not
	     worked out how to do this for OBJ_COFF.  */
	  if (fixP->fx_addsy != NULL
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
	    {
	      /* Get pc relative value to go into the branch.  */
	      value = * valP;

	      /* Permit a backward branch provided that enough bits
		 are set.  Allow a forwards branch, provided that
		 enough bits are clear.  */
	      if (   (value & ~ ((offsetT) 0x1ffffff)) == ~ ((offsetT) 0x1ffffff)
		  || (value & ~ ((offsetT) 0x1ffffff)) == 0)
		fixP->fx_done = 1;
	    }

	  if (! fixP->fx_done)
#endif
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("GAS can't handle same-section branch dest >= 0x04000000"));
	}

      value >>= 2;
      value += SEXT24 (newval);

      if (    (value & ~ ((offsetT) 0xffffff)) != 0
	  && ((value & ~ ((offsetT) 0xffffff)) != ~ ((offsetT) 0xffffff)))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("out of range branch"));

      if (seg->use_rela_p && !fixP->fx_done)
	{
	  /* Must unshift the value before storing it in the addend.  */
	  value <<= 2;
#ifdef OBJ_ELF
	  fixP->fx_offset = value;
#endif
	  fixP->fx_addnumber = value;
	  newval = newval & 0xff000000;
	}
      else
	  newval = (value & 0x00ffffff) | (newval & 0xff000000);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_PCREL_BLX:
      {
	offsetT hbit;
	newval = md_chars_to_number (buf, INSN_SIZE);

#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	hbit   = (value >> 1) & 1;
	value  = (value >> 2) & 0x00ffffff;
	value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;

	if (seg->use_rela_p && !fixP->fx_done)
	  {
	    /* Must sign-extend and unshift the value before storing
	       it in the addend.  */
	    value = SEXT24 (value);
	    value = (value << 2) | hbit;
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xfe000000;
	  }
	else
	  newval = value | (newval & 0xfe000000) | (hbit << 24);
	md_number_to_chars (buf, newval, INSN_SIZE);
      }
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0xff) << 1;
	if (diff & 0x100)
	  diff |= ~0xff;

	value += diff;
	if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xff00;
	  }
	else
	  newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0x7ff) << 1;
	if (diff & 0x800)
	  diff |= ~0x7ff;

	value += diff;
	if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	  }
	else
	  newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      {
	offsetT newval2;
	addressT diff;

	newval  = md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	if (diff & 0x400000)
	  diff |= ~0x3fffff;
#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	value += diff;

	if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch with link out of range"));

	if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  value = (value + 1) & ~ 1;

	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	    newval2 = newval2 & 0xf800;
	  }
	else
	  {
	    newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
	    newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	  }
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;

    case BFD_RELOC_8:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 1);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 1);
	}
#endif
      break;

    case BFD_RELOC_16:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 2);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 2);
	}
#endif
      break;

#ifdef OBJ_ELF
     case BFD_RELOC_ARM_TLS_GD32:
     case BFD_RELOC_ARM_TLS_LE32:
     case BFD_RELOC_ARM_TLS_IE32:
     case BFD_RELOC_ARM_TLS_LDM32:
     case BFD_RELOC_ARM_TLS_LDO32:
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
	/* fall through */

    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_TARGET2:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      md_number_to_chars (buf, 0, 4);
      break;
#endif

    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_32_PCREL:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 4);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 4);
	}
#endif
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PREL31:
      if (fixP->fx_done || fixP->fx_pcrel)
	{
	  newval = md_chars_to_number (buf, 4) & 0x80000000;
	  if ((value ^ (value >> 1)) & 0x40000000)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("rel31 relocation overflow"));
	    }
	  newval |= value & 0x7fffffff;
	  md_number_to_chars (buf, newval, 4);
	}
      break;

    case BFD_RELOC_ARM_PLT32:
      /* It appears the instruction is fully prepared at this point.  */
      break;
#endif

    case BFD_RELOC_ARM_CP_OFF_IMM:
      sign = value >= 0;
      if (value < -1023 || value > 1023 || (value & 3))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("illegal value for co-processor offset"));
      if (value < 0)
	value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= (value >> 2) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
      sign = value >= 0;
      if (value < -255 || value > 255)
        as_bad_where (fixP->fx_file, fixP->fx_line,
                      _("Illegal value for co-processor offset"));
      if (value < 0)
        value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= value | (sign ?  INDEX_UP : 0);
      md_number_to_chars (buf, newval , INSN_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_OFFSET:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      /* Exactly what ranges, and where the offset is inserted depends
	 on the type of instruction, we can establish this from the
	 top 4 bits.  */
      switch (newval >> 12)
	{
	case 4: /* PC load.  */
	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
	     forced to zero for these loads, so we will need to round
	     up the offset if the instruction address is not word
	     aligned (since the final address produced must be, and
	     we can only describe word-aligned immediate offsets).  */

	  if ((fixP->fx_frag->fr_address + fixP->fx_where + value) & 3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, target not word aligned (0x%08X)"),
			  (unsigned int) (fixP->fx_frag->fr_address
					  + fixP->fx_where + value));

	  if ((value + 2) & ~0x3fe)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);

	  /* Round up, since pc will be rounded down.  */
	  newval |= (value + 2) >> 2;
	  break;

	case 9: /* SP load/store.  */
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value >> 2;
	  break;

	case 6: /* Word load/store.  */
	  if (value & ~0x7c)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 4; /* 6 - 2.  */
	  break;

	case 7: /* Byte load/store.  */
	  if (value & ~0x1f)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 6;
	  break;

	case 8: /* Halfword load/store.  */
	  if (value & ~0x3e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 5; /* 6 - 1.  */
	  break;

	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"Unable to process relocation for thumb opcode: %lx",
			(unsigned long) newval);
	  break;
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_ADD:
      /* This is a complicated relocation, since we use it for all of
         the following immediate relocations:

	    3bit ADD/SUB
	    8bit ADD/SUB
	    9bit ADD/SUB SP word-aligned
	   10bit ADD PC/SP word-aligned

         The type of instruction being processed is encoded in the
         instruction field:

	   0x8000  SUB
	   0x00F0  Rd
	   0x000F  Rs
      */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	int rd = (newval >> 4) & 0xf;
	int rs = newval & 0xf;
	int subtract = newval & 0x8000;

	if (rd == REG_SP)
	  {
	    if (value & ~0x1fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for stack address calculation"));
	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	    newval |= value >> 2;
	  }
	else if (rs == REG_PC || rs == REG_SP)
	  {
	    if (subtract ||
		value & ~0x3fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for address calculation (value = 0x%08lX)"),
			    (unsigned long) value);
	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
	    newval |= rd << 8;
	    newval |= value >> 2;
	  }
	else if (rs == rd)
	  {
	    if (value & ~0xff)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid 8bit immediate"));
	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	    newval |= (rd << 8) | value;
	  }
	else
	  {
	    if (value & ~0x7)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid 3bit immediate"));
	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	    newval |= rd | (rs << 3) | (value << 6);
	  }
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_IMM:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      switch (newval >> 11)
	{
	case 0x04: /* 8bit immediate MOV.  */
	case 0x05: /* 8bit immediate CMP.  */
	  if (value < 0 || value > 255)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid immediate: %ld is too large"),
			  (long) value);
	  newval |= value;
	  break;

	default:
	  abort ();
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_SHIFT:
      /* 5bit shift value (0..31).  */
      if (value < 0 || value > 31)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("illegal Thumb shift value: %ld"), (long) value);
      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf03f;
      newval |= value << 6;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    case BFD_RELOC_UNUSED:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
    }
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED,
	      fixS *     fixp)
{
  arelent * reloc;
  bfd_reloc_code_real_type code;

  reloc = xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* @@@@ Why fx_addnumber sometimes and fx_offset other times?  */
#ifndef OBJ_ELF
  if (fixp->fx_pcrel == 0)
    reloc->addend = fixp->fx_offset;
  else
    reloc->addend = fixp->fx_offset = reloc->address;
#else  /* OBJ_ELF */
  reloc->addend = fixp->fx_offset;
#endif

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_8:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_8_PCREL;
	  break;
	}

    case BFD_RELOC_16:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_16_PCREL;
	  break;
	}

    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_32_PCREL;
	  break;
	}

    case BFD_RELOC_NONE:
    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_RVA:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_HWLITERAL:
      /* If this is called then the a literal has
	 been referenced across a section boundary.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("literal referenced across section boundary"));
      return NULL;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_PLT32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_ARM_PREL31:
    case BFD_RELOC_ARM_TARGET2:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_LDO32:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
      /* BFD will include the symbol's address in the addend.  
	 But we don't want that, so subtract it out again here.  */
      if (!S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= (*reloc->sym_ptr_ptr)->value;
      code = fixp->fx_r_type;
      break;
#endif

    case BFD_RELOC_ARM_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal relocation (type: IMMEDIATE) not fixed up"));
      return NULL;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("ADRL used for a symbol not defined in the same file"));
      return NULL;

    case BFD_RELOC_ARM_OFFSET_IMM:
      if (fixp->fx_addsy != NULL
	  && !S_IS_DEFINED (fixp->fx_addsy)
	  && S_IS_LOCAL (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("undefined local label `%s'"),
			S_GET_NAME (fixp->fx_addsy));
	  return NULL;
	}

      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
      return NULL;

    default:
      {
	char * type;

	switch (fixp->fx_r_type)
	  {
	  case BFD_RELOC_NONE:		   type = "NONE";         break;
	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
	  case BFD_RELOC_ARM_SHIFT_IMM:    type = "SHIFT_IMM";    break;
	  case BFD_RELOC_ARM_SMI:          type = "SMI";          break;
	  case BFD_RELOC_ARM_SWI:          type = "SWI";          break;
	  case BFD_RELOC_ARM_MULTI:        type = "MULTI";        break;
	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";   break;
	  case BFD_RELOC_ARM_THUMB_ADD:    type = "THUMB_ADD";    break;
	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
	  case BFD_RELOC_ARM_THUMB_IMM:    type = "THUMB_IMM";    break;
	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
	  default:                         type = _("<unknown>"); break;
	  }
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("cannot represent %s relocation in this object file format"),
		      type);
	return NULL;
      }
    }

#ifdef OBJ_ELF
  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_ARM_GOTPC;
      reloc->addend = fixp->fx_offset = reloc->address;
    }
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }

  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  return reloc;
}

int
md_estimate_size_before_relax (fragS * fragP ATTRIBUTE_UNUSED,
			       segT    segtype ATTRIBUTE_UNUSED)
{
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
}

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.  We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */

static void
fix_new_arm (fragS *       frag,
	     int           where,
	     short int     size,
	     expressionS * exp,
	     int           pc_rel,
	     int           reloc)
{
  fixS *           new_fix;
  arm_fix_data *   arm_data;

  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;

    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
    }

  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  arm_data = obstack_alloc (& notes, sizeof (arm_fix_data));
  new_fix->tc_fix_data = (PTR) arm_data;
  arm_data->thumb_mode = thumb_mode;
}

static void
output_inst (const char * str)
{
  char * to = NULL;

  if (inst.error)
    {
      as_bad ("%s -- `%s'", inst.error, str);
      return;
    }

  to = frag_more (inst.size);

  if (thumb_mode && (inst.size > THUMB_SIZE))
    {
      assert (inst.size == (2 * THUMB_SIZE));
      md_number_to_chars (to, inst.instruction >> 16, THUMB_SIZE);
      md_number_to_chars (to + THUMB_SIZE, inst.instruction, THUMB_SIZE);
    }
  else if (inst.size > INSN_SIZE)
    {
      assert (inst.size == (2 * INSN_SIZE));
      md_number_to_chars (to, inst.instruction, INSN_SIZE);
      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
    }
  else
    md_number_to_chars (to, inst.instruction, inst.size);

  if (inst.reloc.type != BFD_RELOC_UNUSED)
    fix_new_arm (frag_now, to - frag_now->fr_literal,
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
		 inst.reloc.type);

#ifdef OBJ_ELF
  dwarf2_emit_insn (inst.size);
#endif
}

void
md_assemble (char * str)
{
  char  c;
  char *p;
  char *start;

  /* Align the previous label if needed.  */
  if (last_label_seen != NULL)
    {
      symbol_set_frag (last_label_seen, frag_now);
      S_SET_VALUE (last_label_seen, (valueT) frag_now_fix ());
      S_SET_SEGMENT (last_label_seen, now_seg);
    }

  memset (&inst, '\0', sizeof (inst));
  inst.reloc.type = BFD_RELOC_UNUSED;

  skip_whitespace (str);

  /* Scan up to the end of the op-code, which must end in white space or
     end of string.  */
  for (start = p = str; *p != '\0'; p++)
    if (*p == ' ')
      break;

  if (p == str)
    {
      as_bad (_("no operator -- statement `%s'\n"), str);
      return;
    }

  if (thumb_mode)
    {
      const struct thumb_opcode * opcode;

      c = *p;
      *p = '\0';
      opcode = (const struct thumb_opcode *) hash_find (arm_tops_hsh, str);
      *p = c;

      if (opcode)
	{
	  /* Check that this instruction is supported for this CPU.  */
	  if (thumb_mode == 1 && (opcode->variant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }

	  mapping_state (MAP_THUMB);
	  inst.instruction = opcode->value;
	  inst.size = opcode->size;
	  opcode->parms (p);
	  output_inst (str);
	  return;
	}
    }
  else
    {
      const struct asm_opcode * opcode;

      c = *p;
      *p = '\0';
      opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, str);
      *p = c;

      if (opcode)
	{
	  /* Check that this instruction is supported for this CPU.  */
	  if ((opcode->variant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }

          mapping_state (MAP_ARM);
	  inst.instruction = opcode->value;
	  inst.size = INSN_SIZE;
	  opcode->parms (p);
	  output_inst (str);
	  return;
	}
    }

  /* It wasn't an instruction, but it might be a register alias of the form
     alias .req reg.  */
  if (create_register_alias (str, p))
    return;

  as_bad (_("bad instruction `%s'"), start);
}

/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.

      This routine is somewhat complicated by the need for backwards
      compatibility (since older releases of gcc can't be changed).
      The new options try to make the interface as compatible as
      possible with GCC.

      New options (supported) are:

	      -mcpu=<cpu name>		 Assemble for selected processor
	      -march=<architecture name> Assemble for selected architecture
	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
	      -EB/-mbig-endian		 Big-endian
	      -EL/-mlittle-endian	 Little-endian
	      -k			 Generate PIC code
	      -mthumb			 Start in Thumb mode
	      -mthumb-interwork		 Code supports ARM/Thumb interworking

      For now we will also provide support for:

	      -mapcs-32			 32-bit Program counter
	      -mapcs-26			 26-bit Program counter
	      -macps-float		 Floats passed in FP registers
	      -mapcs-reentrant		 Reentrant code
	      -matpcs
      (sometime these will probably be replaced with -mapcs=<list of options>
      and -matpcs=<list of options>)

      The remaining options are only supported for back-wards compatibility.
      Cpu variants, the arm part is optional:
              -m[arm]1                Currently not supported.
              -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
              -m[arm]3                Arm 3 processor
              -m[arm]6[xx],           Arm 6 processors
              -m[arm]7[xx][t][[d]m]   Arm 7 processors
              -m[arm]8[10]            Arm 8 processors
              -m[arm]9[20][tdmi]      Arm 9 processors
              -mstrongarm[110[0]]     StrongARM processors
              -mxscale                XScale processors
              -m[arm]v[2345[t[e]]]    Arm architectures
              -mall                   All (except the ARM1)
      FP variants:
              -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions
              -mfpe-old               (No float load/store multiples)
	      -mvfpxd		      VFP Single precision
	      -mvfp		      All VFP
              -mno-fpu                Disable all floating point instructions

      The following CPU names are recognized:
	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.

      */

const char * md_shortopts = "m:k";

#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#define OPTION_EL (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#else
#define OPTION_EL (OPTION_MD_BASE + 1)
#endif
#endif

struct option md_longopts[] =
{
#ifdef OPTION_EB
  {"EB", no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL", no_argument, NULL, OPTION_EL},
#endif
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

struct arm_option_table
{
  char *option;		/* Option name to match.  */
  char *help;		/* Help information.  */
  int  *var;		/* Variable to change.  */
  int   value;		/* What to change it to.  */
  char *deprecated;	/* If non-null, print this message.  */
};

struct arm_option_table arm_opts[] =
{
  {"k",      N_("generate PIC code"),      &pic_code,    1, NULL},
  {"mthumb", N_("assemble Thumb code"),    &thumb_mode,  1, NULL},
  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
   &support_interwork, 1, NULL},
  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
   1, NULL},
  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 0,
   NULL},

  /* These are recognized by the assembler, but have no affect on code.  */
  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},

  /* DON'T add any new processors to this list -- we want the whole list
     to go away...  Add them to the processors table instead.  */
  {"marm1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm110")},
  {"mstrongarm1100", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1100")},
  {"mstrongarm1110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1110")},
  {"mxscale",	 NULL, &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 NULL, &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 NULL, &legacy_cpu, ARM_ANY,      N_("use -mcpu=all")},

  /* Architecture variants -- don't add any more to this list either.  */
  {"mv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},

  /* Floating point variants -- don't add any more to this list either.  */
  {"mfpe-old", NULL, &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  NULL, &legacy_fpu, 0,
   N_("use either -mfpu=softfpa or -mfpu=softvfp")},

  {NULL, NULL, NULL, 0, NULL}
};

struct arm_cpu_option_table
{
  char *name;
  int   value;
  /* For some CPUs we assume an FPU unless the user explicitly sets
     -mfpu=...  */
  int   default_fpu;
};

/* This list should, at a minimum, contain all the cpu names
   recognized by GCC.  */
static struct arm_cpu_option_table arm_cpus[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi-s",	ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm810",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm922t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm940t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm9tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  /* For V5 or later processors we default to using VFP; but the user
     should really set the FPU type explicitly.  */
  {"arm9e-r0",		ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm9e",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2},
  {"arm926ej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ejs",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm946e",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2},
  {"arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm966e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm10t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm10e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm1020e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1026ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1026ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1136js",		ARM_ARCH_V6,     FPU_NONE},
  {"arm1136j-s",	ARM_ARCH_V6,     FPU_NONE},
  {"arm1136jfs",	ARM_ARCH_V6,     FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	ARM_ARCH_V6,     FPU_ARCH_VFP_V2},
  {"mpcore",		ARM_ARCH_V6K,    FPU_ARCH_VFP_V2},
  {"mpcorenovfp",	ARM_ARCH_V6K,    FPU_NONE},
  {"arm1176jz-s",	ARM_ARCH_V6ZK,   FPU_NONE},
  {"arm1176jzf-s",	ARM_ARCH_V6ZK,   FPU_ARCH_VFP_V2},
  /* ??? XSCALE is really an architecture.  */
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* ??? iwmmxt is not a processor.  */
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2},
  {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* Maverick */
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_ARCH_MAVERICK},
  {NULL, 0, 0}
};

struct arm_arch_option_table
{
  char *name;
  int   value;
  int   default_fpu;
};

/* This list should, at a minimum, contain all the architecture names
   recognized by GCC.  */
static struct arm_arch_option_table arm_archs[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"armv1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"armv2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"armv2a",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv2s",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv3",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"armv3m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"armv4",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"armv4xm",		ARM_ARCH_V4xM,	 FPU_ARCH_FPA},
  {"armv4t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"armv4txm",		ARM_ARCH_V4TxM,	 FPU_ARCH_FPA},
  {"armv5",		ARM_ARCH_V5,	 FPU_ARCH_VFP},
  {"armv5t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP},
  {"armv5txm",		ARM_ARCH_V5TxM,	 FPU_ARCH_VFP},
  {"armv5te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP},
  {"armv5texp",		ARM_ARCH_V5TExP, FPU_ARCH_VFP},
  {"armv5tej",		ARM_ARCH_V5TEJ,  FPU_ARCH_VFP},
  {"armv6",             ARM_ARCH_V6,     FPU_ARCH_VFP},
  {"armv6j",            ARM_ARCH_V6,     FPU_ARCH_VFP},
  {"armv6k",            ARM_ARCH_V6K,    FPU_ARCH_VFP},
  {"armv6z",            ARM_ARCH_V6Z,    FPU_ARCH_VFP},
  {"armv6zk",           ARM_ARCH_V6ZK,   FPU_ARCH_VFP},
  {"armv6t2",		ARM_ARCH_V6T2,   FPU_ARCH_VFP},
  {"armv6kt2",		ARM_ARCH_V6KT2,  FPU_ARCH_VFP},
  {"armv6zt2",		ARM_ARCH_V6ZT2,  FPU_ARCH_VFP},
  {"armv6zkt2",		ARM_ARCH_V6ZKT2, FPU_ARCH_VFP},
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
  {NULL, 0, 0}
};

/* ISA extensions in the co-processor space.  */
struct arm_arch_extension_table
{
  char *name;
  int value;
};

static struct arm_arch_extension_table arm_extensions[] =
{
  {"maverick",		ARM_CEXT_MAVERICK},
  {"xscale",		ARM_CEXT_XSCALE},
  {"iwmmxt",		ARM_CEXT_IWMMXT},
  {NULL,		0}
};

struct arm_fpu_option_table
{
  char *name;
  int   value;
};

/* This list should, at a minimum, contain all the fpu names
   recognized by GCC.  */
static struct arm_fpu_option_table arm_fpus[] =
{
  {"softfpa",		FPU_NONE},
  {"fpe",		FPU_ARCH_FPE},
  {"fpe2",		FPU_ARCH_FPE},
  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
  {"fpa",		FPU_ARCH_FPA},
  {"fpa10",		FPU_ARCH_FPA},
  {"fpa11",		FPU_ARCH_FPA},
  {"arm7500fe",		FPU_ARCH_FPA},
  {"softvfp",		FPU_ARCH_VFP},
  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
  {"vfp",		FPU_ARCH_VFP_V2},
  {"vfp9",		FPU_ARCH_VFP_V2},
  {"vfp10",		FPU_ARCH_VFP_V2},
  {"vfp10-r0",		FPU_ARCH_VFP_V1},
  {"vfpxd",		FPU_ARCH_VFP_V1xD},
  {"arm1020t",		FPU_ARCH_VFP_V1},
  {"arm1020e",		FPU_ARCH_VFP_V2},
  {"arm1136jfs",	FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	FPU_ARCH_VFP_V2},
  {"maverick",		FPU_ARCH_MAVERICK},
  {NULL, 0}
};

struct arm_float_abi_option_table
{
  char *name;
  int value;
};

static struct arm_float_abi_option_table arm_float_abis[] =
{
  {"hard",	ARM_FLOAT_ABI_HARD},
  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
  {"soft",	ARM_FLOAT_ABI_SOFT},
  {NULL, 0}
};

struct arm_eabi_option_table
{
  char *name;
  unsigned int value;
};

#ifdef OBJ_ELF
/* We only know how to output GNU and ver 4 (AAELF) formats.  */
static struct arm_eabi_option_table arm_eabis[] =
{
  {"gnu",	EF_ARM_EABI_UNKNOWN},
  {"4",		EF_ARM_EABI_VER4},
  {NULL, 0}
};
#endif

struct arm_long_option_table
{
  char * option;		/* Substring to match.  */
  char * help;			/* Help information.  */
  int (* func) (char * subopt);	/* Function to decode sub-option.  */
  char * deprecated;		/* If non-null, print this message.  */
};

static int
arm_parse_extension (char * str, int * opt_p)
{
  while (str != NULL && *str != 0)
    {
      struct arm_arch_extension_table * opt;
      char * ext;
      int optlen;

      if (*str != '+')
	{
	  as_bad (_("invalid architectural extension"));
	  return 0;
	}

      str++;
      ext = strchr (str, '+');

      if (ext != NULL)
	optlen = ext - str;
      else
	optlen = strlen (str);

      if (optlen == 0)
	{
	  as_bad (_("missing architectural extension"));
	  return 0;
	}

      for (opt = arm_extensions; opt->name != NULL; opt++)
	if (strncmp (opt->name, str, optlen) == 0)
	  {
	    *opt_p |= opt->value;
	    break;
	  }

      if (opt->name == NULL)
	{
	  as_bad (_("unknown architectural extnsion `%s'"), str);
	  return 0;
	}

      str = ext;
    };

  return 1;
}

static int
arm_parse_cpu (char * str)
{
  struct arm_cpu_option_table * opt;
  char * ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);

  if (optlen == 0)
    {
      as_bad (_("missing cpu name `%s'"), str);
      return 0;
    }

  for (opt = arm_cpus; opt->name != NULL; opt++)
    if (strncmp (opt->name, str, optlen) == 0)
      {
	mcpu_cpu_opt = opt->value;
	mcpu_fpu_opt = opt->default_fpu;

	if (ext != NULL)
	  return arm_parse_extension (ext, &mcpu_cpu_opt);

	return 1;
      }

  as_bad (_("unknown cpu `%s'"), str);
  return 0;
}

static int
arm_parse_arch (char * str)
{
  struct arm_arch_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);

  if (optlen == 0)
    {
      as_bad (_("missing architecture name `%s'"), str);
      return 0;
    }


  for (opt = arm_archs; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	march_cpu_opt = opt->value;
	march_fpu_opt = opt->default_fpu;

	if (ext != NULL)
	  return arm_parse_extension (ext, &march_cpu_opt);

	return 1;
      }

  as_bad (_("unknown architecture `%s'\n"), str);
  return 0;
}

static int
arm_parse_fpu (char * str)
{
  struct arm_fpu_option_table * opt;

  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfpu_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point format `%s'\n"), str);
  return 0;
}

static int
arm_parse_float_abi (char * str)
{
  struct arm_float_abi_option_table * opt;

  for (opt = arm_float_abis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfloat_abi_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point abi `%s'\n"), str);
  return 0;
}

#ifdef OBJ_ELF
static int
arm_parse_eabi (char * str)
{
  struct arm_eabi_option_table *opt;

  for (opt = arm_eabis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	meabi_flags = opt->value;
	return 1;
      }
  as_bad (_("unknown EABI `%s'\n"), str);
  return 0;
}
#endif

struct arm_long_option_table arm_long_opts[] =
{
  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
   arm_parse_cpu, NULL},
  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
   arm_parse_arch, NULL},
  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
   arm_parse_fpu, NULL},
  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
   arm_parse_float_abi, NULL},
#ifdef OBJ_ELF
  {"meabi=", N_("<ver>\t  assemble for eabi version <ver>"),
   arm_parse_eabi, NULL},
#endif
  {NULL, NULL, 0, NULL}
};

int
md_parse_option (int c, char * arg)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  switch (c)
    {
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif

#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif

    case 'a':
      /* Listing option.  Just ignore these, we don't support additional
	 ones.  */
      return 0;

    default:
      for (opt = arm_opts; opt->option != NULL; opt++)
	{
	  if (c == opt->option[0]
	      && ((arg == NULL && opt->option[1] == 0)
		  || streq (arg, opt->option + 1)))
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (opt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(opt->deprecated));
#endif

	      if (opt->var != NULL)
		*opt->var = opt->value;

	      return 1;
	    }
	}

      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
	{
	  /* These options are expected to have an argument.  */
	  if (c == lopt->option[0]
	      && arg != NULL
	      && strncmp (arg, lopt->option + 1,
			  strlen (lopt->option + 1)) == 0)
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (lopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
			   _(lopt->deprecated));
#endif

	      /* Call the sup-option parser.  */
	      return lopt->func (arg + strlen (lopt->option) - 1);
	    }
	}

      return 0;
    }

  return 1;
}

void
md_show_usage (FILE * fp)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  fprintf (fp, _(" ARM-specific assembler options:\n"));

  for (opt = arm_opts; opt->option != NULL; opt++)
    if (opt->help != NULL)
      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));

  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
    if (lopt->help != NULL)
      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));

#ifdef OPTION_EB
  fprintf (fp, _("\
  -EB                     assemble code for a big-endian cpu\n"));
#endif

#ifdef OPTION_EL
  fprintf (fp, _("\
  -EL                     assemble code for a little-endian cpu\n"));
#endif
}

/* This fix_new is called by cons via TC_CONS_FIX_NEW.  */

void
cons_fix_new_arm (fragS *       frag,
		  int           where,
		  int           size,
		  expressionS * exp)
{
  bfd_reloc_code_real_type type;
  int pcrel = 0;

  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
  switch (size)
    {
    case 1:
      type = BFD_RELOC_8;
      break;
    case 2:
      type = BFD_RELOC_16;
      break;
    case 4:
    default:
      type = BFD_RELOC_32;
      break;
    case 8:
      type = BFD_RELOC_64;
      break;
    }

  fix_new_exp (frag, where, (int) size, exp, pcrel, type);
}

/* A good place to do this, although this was probably not intended
   for this kind of use.  We need to dump the literal pool before
   references are made to a null symbol pointer.  */

void
arm_cleanup (void)
{
  literal_pool * pool;

  for (pool = list_of_pools; pool; pool = pool->next)
    {
      /* Put it at the end of the relevent section.  */
      subseg_set (pool->section, pool->sub_section);
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
      s_ltorg (0);
    }
}

void
arm_start_line_hook (void)
{
  last_label_seen = NULL;
}

void
arm_frob_label (symbolS * sym)
{
  last_label_seen = sym;

  ARM_SET_THUMB (sym, thumb_mode);

#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (sym, support_interwork);
#endif

  /* Note - do not allow local symbols (.Lxxx) to be labeled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.  Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:

                ldr  r2, [pc, .Laaa]
                lsl  r3, r3, #2
                ldr  r2, [r3, r2]
                mov  pc, r2

       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:   .word Lbbb

     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.

     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    {
      /* When the address of a Thumb function is taken the bottom
	 bit of that address should be set.  This will allow
	 interworking between Arm and Thumb functions to work
	 correctly.  */

      THUMB_SET_FUNC (sym, 1);

      label_is_thumb_function_name = FALSE;
    }
}

/* Adjust the symbol table.  This marks Thumb symbols as distinct from
   ARM ones.  */

void
arm_adjust_symtab (void)
{
#ifdef OBJ_COFF
  symbolS * sym;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  if (THUMB_IS_FUNC (sym))
	    {
	      /* Mark the symbol as a Thumb function.  */
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!  */
		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);

	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
	      else
		as_bad (_("%s: unexpected function type: %d"),
			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
	    }
	  else switch (S_GET_STORAGE_CLASS (sym))
	    {
	    case C_EXT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
	      break;
	    case C_STAT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
	      break;
	    case C_LABEL:
	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
	      break;
	    default:
	      /* Do nothing.  */
	      break;
	    }
	}

      if (ARM_IS_INTERWORK (sym))
	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
    }
#endif
#ifdef OBJ_ELF
  symbolS * sym;
  char      bind;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  elf_symbol_type * elf_sym;

	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	  bind = ELF_ST_BIND (elf_sym->internal_elf_sym.st_info);

	  if (! bfd_is_arm_mapping_symbol_name (elf_sym->symbol.name))
	    { 
	      /* If it's a .thumb_func, declare it as so,
		 otherwise tag label as .code 16.  */
	      if (THUMB_IS_FUNC (sym))
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_TFUNC);
	      else
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_16BIT);
	    }
	}
    }
#endif
}

int
arm_data_in_code (void)
{
  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
    {
      *input_line_pointer = '/';
      input_line_pointer += 5;
      *input_line_pointer = 0;
      return 1;
    }

  return 0;
}

char *
arm_canonicalize_symbol_name (char * name)
{
  int len;

  if (thumb_mode && (len = strlen (name)) > 5
      && streq (name + len - 5, "/data"))
    *(name + len - 5) = 0;

  return name;
}

#if defined OBJ_COFF || defined OBJ_ELF
void
arm_validate_fix (fixS * fixP)
{
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
      && fixP->fx_addsy != NULL
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! THUMB_IS_FUNC (fixP->fx_addsy))
    {
      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
    }
}
#endif

int
arm_force_relocation (struct fix * fixp)
{
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixp->fx_r_type == BFD_RELOC_RVA)
    return 1;
#endif
#ifdef OBJ_ELF
  if (fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;
#endif

  /* Resolve these relocations even if the symbol is extern or weak.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 0;

  return generic_force_reloc (fixp);
}

#ifdef OBJ_COFF
/* This is a little hack to help the gas/arm/adrl.s test.  It prevents
   local labels from being added to the output symbol table when they
   are used with the ADRL pseudo op.  The ADRL relocation should always
   be resolved before the binbary is emitted, so it is safe to say that
   it is adjustable.  */

bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 1;
  return 0;
}
#endif

#ifdef OBJ_ELF
/* Relocations against Thumb function names must be left unadjusted,
   so that the linker can use this information to correctly set the
   bottom bit of their addresses.  The MIPS version of this function
   also prevents relocations that are mips-16 specific, but I do not
   know why it does this.

   FIXME:
   There is one other problem that ought to be addressed here, but
   which currently is not:  Taking the address of a label (rather
   than a function) and then later jumping to that address.  Such
   addresses also ought to have their bottom bit set (assuming that
   they reside in Thumb code), but at the moment they will not.  */

bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_addsy == NULL)
    return 1;

  if (THUMB_IS_FUNC (fixP->fx_addsy)
      && fixP->fx_subsy == NULL)
    return 0;

  /* We need the symbol name for the VTABLE entries.  */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  /* Don't allow symbols to be discarded on GOT related relocs.  */
  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GD32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_IE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDM32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDO32
      || fixP->fx_r_type == BFD_RELOC_ARM_TARGET2)
    return 0;

  return 1;
}

const char *
elf32_arm_target_format (void)
{
#ifdef TE_SYMBIAN
  return (target_big_endian
	  ? "elf32-bigarm-symbian"
	  : "elf32-littlearm-symbian");
#elif defined (TE_VXWORKS)
  return (target_big_endian
	  ? "elf32-bigarm-vxworks"
	  : "elf32-littlearm-vxworks");
#else
  if (target_big_endian)
    return "elf32-bigarm";
  else
    return "elf32-littlearm";
#endif
}

void
armelf_frob_symbol (symbolS * symp,
		    int *     puntp)
{
  elf_frob_symbol (symp, puntp);
}

static void
s_arm_elf_cons (int nbytes)
{
  expressionS exp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  mapping_state (MAP_DATA);
  do
    {
      bfd_reloc_code_real_type reloc;
      char *sym_start;
      int sym_len;

      sym_start = input_line_pointer;
      expression (& exp);
      sym_len = input_line_pointer - sym_start;

      if (exp.X_op == O_symbol
	  && * input_line_pointer == '('
	  && (reloc = arm_parse_reloc ()) != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  int size = bfd_get_reloc_size (howto);

	  if (size > nbytes)
	    as_bad ("%s relocations do not fit in %d bytes",
		    howto->name, nbytes);
	  else
	    {
	      char *p;
	      int offset = nbytes - size;
	      char *saved_buf = alloca (sym_len), *saved_input;

	      /* We've parsed an expression stopping at O_symbol.  But there
		 may be more expression left now that we have parsed the
		 relocation marker.  Parse it again.  */
	      saved_input = input_line_pointer - sym_len;
	      memcpy (saved_buf, saved_input, sym_len);
	      memmove (saved_input, sym_start, sym_len);
	      input_line_pointer = saved_input;
	      expression (& exp);
	      memcpy (saved_input, saved_buf, sym_len);
	      assert (input_line_pointer >= saved_input + sym_len);

	      p = frag_more ((int) nbytes);
	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer --;
  demand_empty_rest_of_line ();
}


/* Parse a .rel31 directive.  */

static void
s_arm_rel31 (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
  char *p;
  valueT highbit;

  SKIP_WHITESPACE ();

  highbit = 0;
  if (*input_line_pointer == '1')
    highbit = 0x80000000;
  else if (*input_line_pointer != '0')
    as_bad (_("expected 0 or 1"));

  input_line_pointer++;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    as_bad (_("missing comma"));
  input_line_pointer++;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (4);
#endif

  mapping_state (MAP_DATA);

  expression (&exp);

  p = frag_more (4);
  md_number_to_chars (p, highbit, 4);
  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 1,
	       BFD_RELOC_ARM_PREL31);

  demand_empty_rest_of_line ();
}

/* Code to deal with unwinding tables.  */

static void add_unwind_adjustsp (offsetT);

/* Switch to section NAME and create section if necessary.  It's
   rather ugly that we have to manipulate input_line_pointer but I
   don't see any other way to accomplish the same thing without
   changing obj-elf.c (which may be the Right Thing, in the end).
   Copied from tc-ia64.c.  */

static void
set_section (char *name)
{
  char *saved_input_line_pointer;

  saved_input_line_pointer = input_line_pointer;
  input_line_pointer = name;
  obj_elf_section (0);
  input_line_pointer = saved_input_line_pointer;
}

/* Cenerate and deferred unwind frame offset.  */

static void
flush_pending_unwind (void)
{
  offsetT offset;

  offset = unwind.pending_offset;
  unwind.pending_offset = 0;
  if (offset != 0)
    add_unwind_adjustsp (offset);
}

/* Add an opcode to this list for this function.  Two-byte opcodes should
   be passed as op[0] << 8 | op[1].  The list of opcodes is built in reverse
   order.  */

static void
add_unwind_opcode (valueT op, int length)
{
  /* Add any deferred stack adjustment.  */
  if (unwind.pending_offset)
    flush_pending_unwind ();

  unwind.sp_restored = 0;

  if (unwind.opcode_count + length > unwind.opcode_alloc)
    {
      unwind.opcode_alloc += ARM_OPCODE_CHUNK_SIZE;
      if (unwind.opcodes)
	unwind.opcodes = xrealloc (unwind.opcodes,
				   unwind.opcode_alloc);
      else
	unwind.opcodes = xmalloc (unwind.opcode_alloc);
    }
  while (length > 0)
    {
      length--;
      unwind.opcodes[unwind.opcode_count] = op & 0xff;
      op >>= 8;
      unwind.opcode_count++;
    }
}

/* Add unwind opcodes to adjust the stack pointer.  */

static void
add_unwind_adjustsp (offsetT offset)
{
  valueT op;

  if (offset > 0x200)
    {
      /* We need at most 5 bytes to hold a 32-bit value in a uleb128.  */
      char bytes[5];
      int n;
      valueT o;

      /* Long form: 0xb2, uleb128.  */
      /* This might not fit in a word so add the individual bytes,
	 remembering the list is built in reverse order.  */
      o = (valueT) ((offset - 0x204) >> 2);
      if (o == 0)
	add_unwind_opcode (0, 1);

      /* Calculate the uleb128 encoding of the offset.  */
      n = 0;
      while (o)
	{
	  bytes[n] = o & 0x7f;
	  o >>= 7;
	  if (o)
	    bytes[n] |= 0x80;
	  n++;
	}
      /* Add the insn.  */
      for (; n; n--)
	add_unwind_opcode (bytes[n - 1], 1);
      add_unwind_opcode (0xb2, 1);
    }
  else if (offset > 0x100)
    {
      /* Two short opcodes.  */
      add_unwind_opcode (0x3f, 1);
      op = (offset - 0x104) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset > 0)
    {
      /* Short opcode.  */
      op = (offset - 4) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset < 0)
    {
      offset = -offset;
      while (offset > 0x100)
	{
	  add_unwind_opcode (0x7f, 1);
	  offset -= 0x100;
	}
      op = ((offset - 4) >> 2) | 0x40;
      add_unwind_opcode (op, 1);
    }
}

/* Finish the list of unwind opcodes for this function.  */
static void
finish_unwind_opcodes (void)
{
  valueT op;

  if (unwind.fp_used)
    {
      /* Adjust sp as neccessary.  */
      unwind.pending_offset += unwind.fp_offset - unwind.frame_size;
      flush_pending_unwind ();

      /* After restoring sp from the frame pointer.  */
      op = 0x90 | unwind.fp_reg;
      add_unwind_opcode (op, 1);
    }
  else
    flush_pending_unwind ();
}


/* Start an exception table entry.  If idx is nonzero this is an index table
   entry.  */

static void
start_unwind_section (const segT text_seg, int idx)
{
  const char * text_name;
  const char * prefix;
  const char * prefix_once;
  size_t prefix_len;
  size_t text_len;
  char * sec_name;
  size_t sec_name_len;

  if (idx)
    {
      prefix = ELF_STRING_ARM_unwind;
      prefix_once = ELF_STRING_ARM_unwind_once;
    }
  else
    {
      prefix = ELF_STRING_ARM_unwind_info;
      prefix_once = ELF_STRING_ARM_unwind_info_once;
    }

  text_name = segment_name (text_seg);
  if (streq (text_name, ".text"))
    text_name = "";

  if (strncmp (text_name, ".gnu.linkonce.t.",
	       strlen (".gnu.linkonce.t.")) == 0)
    {
      prefix = prefix_once;
      text_name += strlen (".gnu.linkonce.t.");
    }

  prefix_len = strlen (prefix);
  text_len = strlen (text_name);
  sec_name_len = prefix_len + text_len;
  sec_name = alloca (sec_name_len + 1);
  memcpy (sec_name, prefix, prefix_len);
  memcpy (sec_name + prefix_len, text_name, text_len);
  sec_name[prefix_len + text_len] = '\0';

  /* Handle COMDAT group.  */
  if (prefix != prefix_once && (text_seg->flags & SEC_LINK_ONCE) != 0)
    {
      char *section;
      size_t len, group_name_len;
      const char *group_name = elf_group_name (text_seg);

      if (group_name == NULL)
        {
          as_bad ("Group section `%s' has no group signature",
                  segment_name (text_seg));
          ignore_rest_of_line ();
          return;
        }
      /* We have to construct a fake section directive.  */
      group_name_len = strlen (group_name);
      if (idx)
	prefix_len = 13;
      else
	prefix_len = 16;

      len = (sec_name_len
             + prefix_len             /* ,"aG",%sectiontype,  */
             + group_name_len         /* ,group_name  */
             + 7);                    /* ,comdat  */

      section = alloca (len + 1);
      memcpy (section, sec_name, sec_name_len);
      if (idx)
	  memcpy (section + sec_name_len, ",\"aG\",%exidx,", 13);
      else
	  memcpy (section + sec_name_len, ",\"aG\",%progbits,", 16);
      memcpy (section + sec_name_len + prefix_len, group_name, group_name_len);
      memcpy (section + len - 7, ",comdat", 7);
      section [len] = '\0';
      set_section (section);
    }
  else
    {
      set_section (sec_name);
      bfd_set_section_flags (stdoutput, now_seg,
			     SEC_LOAD | SEC_ALLOC | SEC_READONLY);
    }

  /* Set the setion link for index tables.  */
  if (idx)
    elf_linked_to_section (now_seg) = text_seg;
}


/* Start an unwind table entry.  HAVE_DATA is nonzero if we have additional
   personality routine data.  Returns zero, or the index table value for
   and inline entry.  */

static valueT
create_unwind_entry (int have_data)
{
  int size;
  addressT where;
  char *ptr;
  /* The current word of data.  */
  valueT data;
  /* The number of bytes left in this word.  */
  int n;

  finish_unwind_opcodes ();

  /* Remember the current text section.  */
  unwind.saved_seg = now_seg;
  unwind.saved_subseg = now_subseg;

  start_unwind_section (now_seg, 0);

  if (unwind.personality_routine == NULL)
    {
      if (unwind.personality_index == -2)
	{
	  if (have_data)
	    as_bad (_("handerdata in cantunwind frame"));
	  return 1; /* EXIDX_CANTUNWIND.  */
	}

      /* Use a default personality routine if none is specified.  */
      if (unwind.personality_index == -1)
	{
	  if (unwind.opcode_count > 3)
	    unwind.personality_index = 1;
	  else
	    unwind.personality_index = 0;
	}

      /* Space for the personality routine entry.  */
      if (unwind.personality_index == 0)
	{
	  if (unwind.opcode_count > 3)
	    as_bad (_("too many unwind opcodes for personality routine 0"));

	  if (!have_data)
	    {
	      /* All the data is inline in the index table.  */
	      data = 0x80;
	      n = 3;
	      while (unwind.opcode_count > 0)
		{
		  unwind.opcode_count--;
		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
		  n--;
		}

	      /* Pad with "finish" opcodes.  */
	      while (n--)
		data = (data << 8) | 0xb0;

	      return data;
	    }
	  size = 0;
	}
      else
	/* We get two opcodes "free" in the first word.  */
	size = unwind.opcode_count - 2;
    }
  else
    /* An extra byte is required for the opcode count.  */
    size = unwind.opcode_count + 1;

  size = (size + 3) >> 2;
  if (size > 0xff)
    as_bad (_("too many unwind opcodes"));

  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
  unwind.table_entry = expr_build_dot ();

  /* Allocate the table entry.  */
  ptr = frag_more ((size << 2) + 4);
  where = frag_now_fix () - ((size << 2) + 4);

  switch (unwind.personality_index)
    {
    case -1:
      /* ??? Should this be a PLT generating relocation?  */
      /* Custom personality routine.  */
      fix_new (frag_now, where, 4, unwind.personality_routine, 0, 1,
	       BFD_RELOC_ARM_PREL31);

      where += 4;
      ptr += 4;

      /* Set the first byte to the number of additional words.  */
      data = size - 1;
      n = 3;
      break;

    /* ABI defined personality routines.  */
    case 0:
      /* Three opcodes bytes are packed into the first word.  */
      data = 0x80;
      n = 3;
      break;

    case 1:
    case 2:
      /* The size and first two opcode bytes go in the first word.  */
      data = ((0x80 + unwind.personality_index) << 8) | size;
      n = 2;
      break;

    default:
      /* Should never happen.  */
      abort ();
    }

  /* Pack the opcodes into words (MSB first), reversing the list at the same
     time.  */
  while (unwind.opcode_count > 0)
    {
      if (n == 0)
	{
	  md_number_to_chars (ptr, data, 4);
	  ptr += 4;
	  n = 4;
	  data = 0;
	}
      unwind.opcode_count--;
      n--;
      data = (data << 8) | unwind.opcodes[unwind.opcode_count];
    }

  /* Finish off the last word.  */
  if (n < 4)
    {
      /* Pad with "finish" opcodes.  */
      while (n--)
	data = (data << 8) | 0xb0;

      md_number_to_chars (ptr, data, 4);
    }

  if (!have_data)
    {
      /* Add an empty descriptor if there is no user-specified data.   */
      ptr = frag_more (4);
      md_number_to_chars (ptr, 0, 4);
    }

  return 0;
}


/* Parse an unwind_fnstart directive.  Simply records the current location.  */

static void
s_arm_unwind_fnstart (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  /* Mark the start of the function.  */
  unwind.proc_start = expr_build_dot ();

  /* Reset the rest of the unwind info.  */
  unwind.opcode_count = 0;
  unwind.table_entry = NULL;
  unwind.personality_routine = NULL;
  unwind.personality_index = -1;
  unwind.frame_size = 0;
  unwind.fp_offset = 0;
  unwind.fp_reg = 13;
  unwind.fp_used = 0;
  unwind.sp_restored = 0;
}


/* Parse a handlerdata directive.  Creates the exception handling table entry
   for the function.  */

static void
s_arm_unwind_handlerdata (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.table_entry)
    as_bad (_("dupicate .handlerdata directive"));

  create_unwind_entry (1);
}

/* Parse an unwind_fnend directive.  Generates the index table entry.  */

static void
s_arm_unwind_fnend (int ignored ATTRIBUTE_UNUSED)
{
  long where;
  char *ptr;
  valueT val;

  demand_empty_rest_of_line ();

  /* Add eh table entry.  */
  if (unwind.table_entry == NULL)
    val = create_unwind_entry (0);
  else
    val = 0;

  /* Add index table entry.  This is two words.  */
  start_unwind_section (unwind.saved_seg, 1);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  ptr = frag_more (8);
  where = frag_now_fix () - 8;

  /* Self relative offset of the function start.  */
  fix_new (frag_now, where, 4, unwind.proc_start, 0, 1,
	   BFD_RELOC_ARM_PREL31);

  /* Indicate dependency on EHABI-defined personality routines to the
     linker, if it hasn't been done already.  */
  if (unwind.personality_index >= 0 && unwind.personality_index < 3)
    {
      char *name[] = { "__aeabi_unwind_cpp_pr0",
		       "__aeabi_unwind_cpp_pr1",
		       "__aeabi_unwind_cpp_pr2" };
      if (!(marked_pr_dependency & (1 << unwind.personality_index)))
	{
	  symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
	  fix_new (frag_now, where, 0, pr, 0, 1, BFD_RELOC_NONE);
	  marked_pr_dependency |= 1 << unwind.personality_index;
	  seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency
	    = marked_pr_dependency;
        }
    }

  if (val)
    /* Inline exception table entry.  */
    md_number_to_chars (ptr + 4, val, 4);
  else
    /* Self relative offset of the table entry.  */
    fix_new (frag_now, where + 4, 4, unwind.table_entry, 0, 1,
	     BFD_RELOC_ARM_PREL31);

  /* Restore the original section.  */
  subseg_set (unwind.saved_seg, unwind.saved_subseg);
}


/* Parse an unwind_cantunwind directive.  */

static void
s_arm_unwind_cantunwind (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("personality routine specified for cantunwind frame"));

  unwind.personality_index = -2;
}


/* Parse a personalityindex directive.  */

static void
s_arm_unwind_personalityindex (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personalityindex directive"));

  SKIP_WHITESPACE ();

  expression (&exp);

  if (exp.X_op != O_constant
      || exp.X_add_number < 0 || exp.X_add_number > 15)
    {
      as_bad (_("bad personality routine number"));
      ignore_rest_of_line ();
      return;
    }

  unwind.personality_index = exp.X_add_number;

  demand_empty_rest_of_line ();
}


/* Parse a personality directive.  */

static void
s_arm_unwind_personality (int ignored ATTRIBUTE_UNUSED)
{
  char *name, *p, c;

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personality directive"));

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  unwind.personality_routine = symbol_find_or_make (name);
  *p = c;
  SKIP_WHITESPACE ();
  demand_empty_rest_of_line ();
}


/* Parse a directive saving core registers.  */

static void
s_arm_unwind_save_core (void)
{
  valueT op;
  long range;
  int n;

  SKIP_WHITESPACE ();
  range = reg_list (&input_line_pointer);
  if (range == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  /* Turn .unwind_movsp ip followed by .unwind_save {..., ip, ...}
     into .unwind_save {..., sp...}.  We aren't bothered about the value of
     ip because it is clobbered by calls.  */
  if (unwind.sp_restored && unwind.fp_reg == 12
      && (range & 0x3000) == 0x1000)
    {
      unwind.opcode_count--;
      unwind.sp_restored = 0;
      range = (range | 0x2000) & ~0x1000;
      unwind.pending_offset = 0;
    }

  /* See if we can use the short opcodes.  These pop a block of upto 8
     registers starting with r4, plus maybe r14.  */
  for (n = 0; n < 8; n++)
    {
      /* Break at the first non-saved register.  */
      if ((range & (1 << (n + 4))) == 0)
	break;
    }
  /* See if there are any other bits set.  */
  if (n == 0 || (range & (0xfff0 << n) & 0xbff0) != 0)
    {
      /* Use the long form.  */
      op = 0x8000 | ((range >> 4) & 0xfff);
      add_unwind_opcode (op, 2);
    }
  else
    {
      /* Use the short form.  */
      if (range & 0x4000)
	op = 0xa8; /* Pop r14.  */
      else
	op = 0xa0; /* Do not pop r14.  */
      op |= (n - 1);
      add_unwind_opcode (op, 1);
    }

  /* Pop r0-r3.  */
  if (range & 0xf)
    {
      op = 0xb100 | (range & 0xf);
      add_unwind_opcode (op, 2);
    }

  /* Record the number of bytes pushed.  */
  for (n = 0; n < 16; n++)
    {
      if (range & (1 << n))
	unwind.frame_size += 4;
    }
}


/* Parse a directive saving FPA registers.  */

static void
s_arm_unwind_save_fpa (int reg)
{
  expressionS exp;
  int num_regs;
  valueT op;

  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    expression (&exp);
  else
    exp.X_op = O_illegal;

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected , <constant>"));
      ignore_rest_of_line ();
      return;
    }

  num_regs = exp.X_add_number;

  if (num_regs < 1 || num_regs > 4)
    {
      as_bad (_("number of registers must be in the range [1:4]"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  if (reg == 4)
    {
      /* Short form.  */
      op = 0xb4 | (num_regs - 1);
      add_unwind_opcode (op, 1);
    }
  else
    {
      /* Long form.  */
      op = 0xc800 | (reg << 4) | (num_regs - 1);
      add_unwind_opcode (op, 2);
    }
  unwind.frame_size += num_regs * 12;
}


/* Parse a directive saving VFP registers.  */

static void
s_arm_unwind_save_vfp (void)
{
  int count;
  int reg;
  valueT op;

  count = vfp_parse_reg_list (&input_line_pointer, &reg, 1);
  if (count == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  if (reg == 8)
    {
      /* Short form.  */
      op = 0xb8 | (count - 1);
      add_unwind_opcode (op, 1);
    }
  else
    {
      /* Long form.  */
      op = 0xb300 | (reg << 4) | (count - 1);
      add_unwind_opcode (op, 2);
    }
  unwind.frame_size += count * 8 + 4;
}


/* Parse a directive saving iWMMXt registers.  */

static void
s_arm_unwind_save_wmmx (void)
{
  int reg;
  int hi_reg;
  int i;
  unsigned wcg_mask;
  unsigned wr_mask;
  valueT op;

  if (*input_line_pointer == '{')
    input_line_pointer++;

  wcg_mask = 0;
  wr_mask = 0;
  do
    {
      reg = arm_reg_parse (&input_line_pointer,
			   all_reg_maps[REG_TYPE_IWMMXT].htab);

      if (wr_register (reg))
	{
	  i = reg & ~WR_PREFIX;
	  if (wr_mask >> i)
	    as_tsktsk (_("register list not in ascending order"));
	  wr_mask |= 1 << i;
	}
      else if (wcg_register (reg))
	{
	  i = (reg & ~WC_PREFIX) - 8;
	  if (wcg_mask >> i)
	    as_tsktsk (_("register list not in ascending order"));
	  wcg_mask |= 1 << i;
	}
      else
	{
	  as_bad (_("expected wr or wcgr"));
	  goto error;
	}

      SKIP_WHITESPACE ();
      if (*input_line_pointer == '-')
	{
	  hi_reg = arm_reg_parse (&input_line_pointer,
				  all_reg_maps[REG_TYPE_IWMMXT].htab);
	  if (wr_register (reg) && wr_register (hi_reg))
	    {
	      for (; reg < hi_reg; reg++)
		wr_mask |= 1 << (reg & ~WR_PREFIX);
	    }
	  else if (wcg_register (reg) && wcg_register (hi_reg))
	    {
	      for (; reg < hi_reg; reg++)
		wcg_mask |= 1 << ((reg & ~WC_PREFIX) - 8);
	    }
	  else
	    {
	      as_bad (_("bad register range"));
	      goto error;
	    }
	}
    }
  while (skip_past_comma (&input_line_pointer) != FAIL);

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '}')
    input_line_pointer++;

  demand_empty_rest_of_line ();

  if (wr_mask && wcg_mask)
    {
      as_bad (_("inconsistent register types"));
      goto error;
    }

  /* Generate any deferred opcodes becuuse we're going to be looking at
     the list.  */
  flush_pending_unwind ();

  if (wcg_mask)
    {
      for (i = 0; i < 16; i++)
	{
	  if (wcg_mask & (1 << i))
	    unwind.frame_size += 4;
	}
      op = 0xc700 | wcg_mask;
      add_unwind_opcode (op, 2);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (wr_mask & (1 << i))
	    unwind.frame_size += 8;
	}
      /* Attempt to combine with a previous opcode.  We do this because gcc
	 likes to output separate unwind directives for a single block of
	 registers.  */
      if (unwind.opcode_count > 0)
	{
	  i = unwind.opcodes[unwind.opcode_count - 1];
	  if ((i & 0xf8) == 0xc0)
	    {
	      i &= 7;
	      /* Only merge if the blocks are contiguous.  */
	      if (i < 6)
		{
		  if ((wr_mask & 0xfe00) == (1 << 9))
		    {
		      wr_mask |= ((1 << (i + 11)) - 1) & 0xfc00;
		      unwind.opcode_count--;
		    }
		}
	      else if (i == 6 && unwind.opcode_count >= 2)
		{
		  i = unwind.opcodes[unwind.opcode_count - 2];
		  reg = i >> 4;
		  i &= 0xf;

		  op = 0xffff << (reg - 1);
		  if (reg > 0
		      || ((wr_mask & op) == (1u << (reg - 1))))
		    {
		      op = (1 << (reg + i + 1)) - 1;
		      op &= ~((1 << reg) - 1);
		      wr_mask |= op;
		      unwind.opcode_count -= 2;
		    }
		}
	    }
	}

      hi_reg = 15;
      /* We want to generate opcodes in the order the registers have been
	 saved, ie. descending order.  */
      for (reg = 15; reg >= -1; reg--)
	{
	  /* Save registers in blocks.  */
	  if (reg < 0
	      || !(wr_mask & (1 << reg)))
	    {
	      /* We found an unsaved reg.  Generate opcodes to save the
		 preceeding block.  */
	      if (reg != hi_reg)
		{
		  if (reg == 9)
		    {
		      /* Short form.  */
		      op = 0xc0 | (hi_reg - 10);
		      add_unwind_opcode (op, 1);
		    }
		  else
		    {
		      /* Long form.  */
		      op = 0xc600 | ((reg + 1) << 4) | ((hi_reg - reg) - 1);
		      add_unwind_opcode (op, 2);
		    }
		}
	      hi_reg = reg - 1;
	    }
	}
    }
  return;
error:
  ignore_rest_of_line ();
}


/* Parse an unwind_save directive.  */

static void
s_arm_unwind_save (int ignored ATTRIBUTE_UNUSED)
{
  char *saved_ptr;
  int reg;

  /* Figure out what sort of save we have.  */
  SKIP_WHITESPACE ();
  saved_ptr = input_line_pointer;

  reg = arm_reg_parse (&input_line_pointer, all_reg_maps[REG_TYPE_FN].htab);
  if (reg != FAIL)
    {
      s_arm_unwind_save_fpa (reg);
      return;
    }

  if (*input_line_pointer == '{')
    input_line_pointer++;

  SKIP_WHITESPACE ();

  reg = arm_reg_parse (&input_line_pointer, all_reg_maps[REG_TYPE_RN].htab);
  if (reg != FAIL)
    {
      input_line_pointer = saved_ptr;
      s_arm_unwind_save_core ();
      return;
    }

  reg = arm_reg_parse (&input_line_pointer, all_reg_maps[REG_TYPE_DN].htab);
  if (reg != FAIL)
    {
      input_line_pointer = saved_ptr;
      s_arm_unwind_save_vfp ();
      return;
    }

  reg = arm_reg_parse (&input_line_pointer,
		       all_reg_maps[REG_TYPE_IWMMXT].htab);
  if (reg != FAIL)
    {
      input_line_pointer = saved_ptr;
      s_arm_unwind_save_wmmx ();
      return;
    }

  /* TODO: Maverick registers.  */
  as_bad (_("unrecognised register"));
}


/* Parse an unwind_movsp directive.  */
d12094 2
a12095 2
static void
s_arm_unwind_movsp (int ignored ATTRIBUTE_UNUSED)
d12097 3
a12099 2
  int reg;
  valueT op;
d12101 7
a12107 8
  SKIP_WHITESPACE ();
  reg = reg_required_here (&input_line_pointer, -1);
  if (reg == FAIL)
    {
      as_bad (_("ARM register expected"));
      ignore_rest_of_line ();
      return;
    }
d12109 26
a12134 6
  if (reg == 13 || reg == 15)
    {
      as_bad (_("r%d not permitted in .unwind_movsp directive"), reg);
      ignore_rest_of_line ();
      return;
    }
d12136 7
a12142 2
  if (unwind.fp_reg != 13)
    as_bad (_("unexpected .unwind_movsp directive"));
d12144 9
a12152 3
  /* Generate opcode to restore the value.  */
  op = 0x90 | reg;
  add_unwind_opcode (op, 1);
d12154 7
a12160 9
  /* Record the information for later.  */
  unwind.fp_reg = reg;
  unwind.fp_offset = unwind.frame_size;
  unwind.sp_restored = 1;
  demand_empty_rest_of_line ();
}


/* Parse #<number>.  */
d12163 1
a12163 1
require_hashconst (int * val)
d12165 5
a12169 1
  expressionS exp;
d12171 5
a12175 8
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '#')
    {
      input_line_pointer++;
      expression (&exp);
    }
  else
    exp.X_op = O_illegal;
d12177 2
a12178 9
  if (exp.X_op != O_constant)
    {
      as_bad (_("expected #constant"));
      ignore_rest_of_line ();
      return FAIL;
    }
  *val = exp.X_add_number;
  return SUCCESS;
}
d12180 4
a12183 1
/* Parse an unwind_pad directive.  */
d12185 5
a12189 4
static void
s_arm_unwind_pad (int ignored ATTRIBUTE_UNUSED)
{
  int offset;
d12191 6
a12196 2
  if (require_hashconst (&offset) == FAIL)
    return;
d12198 5
a12202 6
  if (offset & 3)
    {
      as_bad (_("stack increment must be multiple of 4"));
      ignore_rest_of_line ();
      return;
    }
d12204 2
a12205 3
  /* Don't generate any opcodes, just record the details for later.  */
  unwind.frame_size += offset;
  unwind.pending_offset += offset;
d12207 1
a12207 1
  demand_empty_rest_of_line ();
d12210 2
a12211 4
/* Parse an unwind_setfp directive.  */

static void
s_arm_unwind_setfp (int ignored ATTRIBUTE_UNUSED)
d12213 3
a12215 3
  int sp_reg;
  int fp_reg;
  int offset;
d12217 2
a12218 3
  fp_reg = reg_required_here (&input_line_pointer, -1);
  if (skip_past_comma (&input_line_pointer) == FAIL)
    sp_reg = FAIL;
d12220 1
a12220 1
    sp_reg = reg_required_here (&input_line_pointer, -1);
d12222 1
a12222 1
  if (fp_reg == FAIL || sp_reg == FAIL)
d12224 2
a12225 3
      as_bad (_("expected <reg>, <reg>"));
      ignore_rest_of_line ();
      return;
d12228 5
a12232 8
  /* Optonal constant.  */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    {
      if (require_hashconst (&offset) == FAIL)
	return;
    }
  else
    offset = 0;
d12234 2
a12235 1
  demand_empty_rest_of_line ();
d12237 2
a12238 6
  if (sp_reg != 13 && sp_reg != unwind.fp_reg)
    {
      as_bad (_("register must be either sp or set by a previous"
		"unwind_movsp directive"));
      return;
    }
d12240 2
a12241 7
  /* Don't generate any opcodes, just record the information for later.  */
  unwind.fp_reg = fp_reg;
  unwind.fp_used = 1;
  if (sp_reg == 13)
    unwind.fp_offset = unwind.frame_size - offset;
  else
    unwind.fp_offset -= offset;
d12244 2
a12245 4
/* Parse an unwind_raw directive.  */

static void
s_arm_unwind_raw (int ignored ATTRIBUTE_UNUSED)
d12247 3
a12249 4
  expressionS exp;
  /* This is an arbitary limit.  */
  unsigned char op[16];
  int count;
d12251 2
a12252 8
  SKIP_WHITESPACE ();
  expression (&exp);
  if (exp.X_op == O_constant
      && skip_past_comma (&input_line_pointer) != FAIL)
    {
      unwind.frame_size += exp.X_add_number;
      expression (&exp);
    }
d12254 1
a12254 1
    exp.X_op = O_illegal;
d12256 1
a12256 1
  if (exp.X_op != O_constant)
d12258 2
a12259 3
      as_bad (_("expected <offset>, <opcode>"));
      ignore_rest_of_line ();
      return;
a12261 1
  count = 0;
d12263 5
a12267 15
  /* Parse the opcode.  */
  for (;;)
    {
      if (count >= 16)
	{
	  as_bad (_("unwind opcode too long"));
	  ignore_rest_of_line ();
	}
      if (exp.X_op != O_constant || exp.X_add_number & ~0xff)
	{
	  as_bad (_("invalid unwind opcode"));
	  ignore_rest_of_line ();
	  return;
	}
      op[count++] = exp.X_add_number;
d12269 2
a12270 3
      /* Parse the next byte.  */
      if (skip_past_comma (&input_line_pointer) == FAIL)
	break;
d12272 2
a12273 2
      expression (&exp);
    }
d12275 3
a12277 3
  /* Add the opcode bytes in reverse order.  */
  while (count--)
    add_unwind_opcode (op[count], 1);
d12279 4
a12282 2
  demand_empty_rest_of_line ();
}
d12284 6
a12289 1
#endif /* OBJ_ELF */
d12291 3
a12293 2
/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */
d12295 2
a12296 2
void
arm_handle_align (fragS * fragP)
d12298 1
a12298 4
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };
d12300 6
a12305 3
  int bytes, fix, noop_size;
  char * p;
  const char * noop;
d12307 3
a12309 2
  if (fragP->fr_type != rs_align_code)
    return;
d12311 5
a12315 3
  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;
d12317 10
a12326 2
  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;
d12328 16
a12343 16
  if (fragP->tc_frag_data)
    {
      if (target_big_endian)
	noop = thumb_bigend_noop;
      else
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
    }
  else
    {
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
    }
d12345 5
a12349 7
  if (bytes & (noop_size - 1))
    {
      fix = bytes & (noop_size - 1);
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }
d12351 1
a12351 1
  while (bytes >= noop_size)
d12353 5
a12357 5
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
    }
d12359 5
a12363 3
  fragP->fr_fix += fix;
  fragP->fr_var = noop_size;
}
d12365 4
a12368 2
/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */
d12370 13
a12382 4
void
arm_frag_align_code (int n, int max)
{
  char * p;
d12384 2
a12385 4
  /* We assume that there will never be a requirement
     to support alignments greater than 32 bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
d12387 3
a12389 9
  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;
}
d12391 14
a12404 1
/* Perform target specific initialisation of a frag.  */
d12406 4
a12409 6
void
arm_init_frag (fragS * fragP)
{
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
}
d12411 2
a12412 1
#ifdef OBJ_ELF
d12414 2
a12415 1
/* Convert REGNAME to a DWARF-2 register number.  */
d12417 2
a12418 2
int
tc_arm_regname_to_dw2regnum (const char *regname)
d12420 2
a12421 1
  unsigned int i;
d12423 1
a12423 3
  for (i = 0; rn_table[i].name; i++)
    if (streq (regname, rn_table[i].name))
      return rn_table[i].number;
d12425 3
a12427 2
  return -1;
}
d12429 3
a12431 1
/* Initialize the DWARF-2 unwind information for this procedure.  */
d12433 3
a12435 5
void
tc_arm_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (REG_SP, 0);
}
d12438 3
a12440 39
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* Never called because '.req' does not start a line.  */
  { "req",         s_req,         0 },
  { "unreq",       s_unreq,       0 },
  { "bss",         s_bss,         0 },
  { "align",       s_align,       0 },
  { "arm",         s_arm,         0 },
  { "thumb",       s_thumb,       0 },
  { "code",        s_code,        0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb_set",   s_thumb_set,   0 },
  { "even",        s_even,        0 },
  { "ltorg",       s_ltorg,       0 },
  { "pool",        s_ltorg,       0 },
#ifdef OBJ_ELF
  { "word",        s_arm_elf_cons, 4 },
  { "long",        s_arm_elf_cons, 4 },
  { "rel31",       s_arm_rel31,   0 },
  { "fnstart",		s_arm_unwind_fnstart,	0 },
  { "fnend",		s_arm_unwind_fnend,	0 },
  { "cantunwind",	s_arm_unwind_cantunwind, 0 },
  { "personality",	s_arm_unwind_personality, 0 },
  { "personalityindex",	s_arm_unwind_personalityindex, 0 },
  { "handlerdata",	s_arm_unwind_handlerdata, 0 },
  { "save",		s_arm_unwind_save,	0 },
  { "movsp",		s_arm_unwind_movsp,	0 },
  { "pad",		s_arm_unwind_pad,	0 },
  { "setfp",		s_arm_unwind_setfp,	0 },
  { "unwind_raw",	s_arm_unwind_raw,	0 },
#else
  { "word",        cons, 4},
d12442 1
a12442 5
  { "extend",      float_cons, 'x' },
  { "ldouble",     float_cons, 'x' },
  { "packed",      float_cons, 'p' },
  { 0, 0, 0 }
};
@


1.202
log
@gas/
2005-04-19  Jan Beulich  <jbeulich@@novell.com>

	* symbols.h (symbol_find_base): Remove prototype.
	* symbols.c (save_symbol_name): Remove code section conditional upon
	STRIP_UNDERSCORE.
	(symbol_find): Remove.
	(symbol_find_base): Rename to symbol_find.
	* subsegs.c (section_symbol): Replace use of symbol_find_base with
	symbol_find.
	* config/obj-coff.c (tag_insert): Remove code section conditional
	upon STRIP_UNDERSCORE.
	(obj_coff_def): Likewise.
	(obj_coff_endef): Replace use of symbol_find_base with symbol_find.
	(coff_frob_symbol): Likewise.
	(yank_symbols): Likewise.
	(c_section_symbol): Likewise.
	* config/obj-coff.h (DO_NOT_STRIP): Remove.
	* config/tc-arm.c (symbol_locate): Remove code section conditional
	upon STRIP_UNDERSCORE.
	* config/tc-h8300.h (DO_NOT_STRIP): Remove.
	* config/tc-h8500.h (DO_NOT_STRIP): Remove.
	* config/tc-sh.h (DO_NOT_STRIP): Remove.
	* config/tc-w65.h (DO_NOT_STRIP): Remove.
	* config/tc-z8k.h (DO_NOT_STRIP): Remove.
@
text
@d25 2
a26 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d12873 1
a12873 1
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 1,
@


1.201
log
@	* bfd/bfd-in.h (bfd_is_arm_mapping_symbol_name): Rename from
	bfd_elf32_is_arm_mapping_symbol_name.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/cpu-arm.c (bfd_is_arm_mapping_symbol_name): Rename from
	bfd_elf32_is_arm_mapping_symbol_name.
	* bfd/elf32-arm.c (elf32_arm_is_target_special_symbol): Rename
	bfd_elf32_is_arm_mapping_symbol_name to bfd_is_arm_mapping_symbol_name.
	(arm_elf_find_function): Likewise.
	(elf32_arm_output_symbol_hook): Likewise.
	* gas/config/tc-arm.c (arm_adjust_symtab): Likewise.
@
text
@a1139 4
#ifdef STRIP_UNDERSCORE
  if (preserved_copy_of_name[0] == '_')
    preserved_copy_of_name++;
#endif
@


1.200
log
@	* bfd/bfd-in.h (bfd_elf32_is_arm_mapping_symbol_name): Add prototype.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c (elf32_arm_is_target_special_symbol): Rename call to
	bfd_elf32_is_arm_mapping_symbol_name.
	(elf32_arm_output_symbol_hook): Likewise.
	(arm_elf_find_function): Likewise, and include STT_NOTYPE in test for
	mapping symbols.
	(is_arm_mapping_symbol_name): Function moved from here...
	* bfd/cpu-arm.c (bfd_elf32_is_arm_mapping_symbol_name): ...to here,
	renamed and made global.
	* gas/config/tc-arm.c (mapping_state): Change documentation in function
	comment to cross-reference spec instead. Change type of mapping symbols
	to BSF_NO_TYPE.
	(arm_adjust_symtab): Don't change type of mapping symbols here.
	* gas/testsuite/gas/arm/mapping.d: Update expected output.
	* ld/testsuite/ld-arm/arm-app-abs32.d: Likewise.
	* ld/testsuite/ld-arm/arm-app.d: Likewise.
	* ld/testsuite/ld-arm/mixed-app.d: Likewise.
@
text
@d13672 1
a13672 1
	  if (! bfd_elf32_is_arm_mapping_symbol_name (elf_sym->symbol.name))
@


1.199
log
@bfd/
	* bfd-in2.h, libbfd.h: Regenerated.
	* reloc.c: Add ARM TLS relocations.
	* elf32-arm.c (elf32_arm_howto_table): Add dynamic TLS
	relocations.
	(elf32_arm_tls_gd32_howto, elf32_arm_tls_ldo32_howto)
	(elf32_arm_tls_ldm32_howto, elf32_arm_tls_le32_howto)
	(elf32_arm_tls_ie32_howto): New.
	(elf32_arm_howto_from_type): Support TLS relocations.
	(elf32_arm_reloc_map): Likewise.
	(elf32_arm_reloc_type_lookup): Likewise.
	(TCB_SIZE): Define.
	(struct elf32_arm_obj_tdata): New.
	(elf32_arm_tdata, elf32_arm_local_got_tls_type): Define.
	(elf32_arm_mkobject): New function.
	(struct elf32_arm_relocs_copied): Add pc_count.
	(elf32_arm_hash_entry, GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD)
	(GOT_TLS_IE): Define.
	(struct elf32_arm_link_hash_table): Add tls_ldm_got.
	(elf32_arm_link_hash_newfunc): Initialize tls_type.
	(elf32_arm_copy_indirect_symbol): Copy pc_count and tls_type.
	(elf32_arm_link_hash_table_create): Initialize tls_ldm_got.
	(dtpoff_base, tpoff): New functions.
	(elf32_arm_final_link_relocate): Handle TLS relocations.
	(IS_ARM_TLS_RELOC): Define.
	(elf32_arm_relocate_section): Warn about TLS mismatches.
	(elf32_arm_gc_sweep_hook): Handle TLS relocations and pc_count.
	(elf32_arm_check_relocs): Detect invalid symbol indexes.  Handle
	TLS relocations and pc_count.
	(elf32_arm_adjust_dynamic_symbol): Check non_got_ref.
	(allocate_dynrelocs): Handle TLS.  Bind REL32 relocs to local
	calls.
	(elf32_arm_size_dynamic_sections): Handle TLS.
	(elf32_arm_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject): Define.
gas/
	* config/tc-arm.c (arm_parse_reloc): Add TLS relocations.
	(md_apply_fix3): Mark TLS symbols.
	(tc_gen_reloc): Handle TLS relocations.
	(arm_fix_adjustable): Ignore TLS relocations.
	(s_arm_elf_cons): Support expressions after decorated symbols.
gas/testuite/
	* gas/arm/tls.s, gas/arm/tls.d: New files.
	* gas/arm/arm.exp: Run TLS test.
include/elf/
	* arm.h: Add TLS relocations.
ld/testsuite/
	* ld-arm/tls-lib.s, ld-arm/tls-lib.d, ld-arm/tls-lib.r,
	ld-arm/tls-app.s, ld-arm/tls-app.d, ld-arm/tls-app.r: New files.
	* ld-arm/arm-lib.ld, ld-arm/arm-dyn.ld: Increase data segment
	alignment.
	* ld-arm/arm-elf.exp: Run TLS tests.
@
text
@d1246 3
a1248 72
   (This text is taken from version B-02 of the spec):

      4.4.7 Mapping and tagging symbols

      A section of an ARM ELF file can contain a mixture of ARM code,
      Thumb code, and data.  There are inline transitions between code
      and data at literal pool boundaries. There can also be inline
      transitions between ARM code and Thumb code, for example in
      ARM-Thumb inter-working veneers.  Linkers, machine-level
      debuggers, profiling tools, and disassembly tools need to map
      images accurately. For example, setting an ARM breakpoint on a
      Thumb location, or in a literal pool, can crash the program
      being debugged, ruining the debugging session.

      ARM ELF entities are mapped (see section 4.4.7.1 below) and
      tagged (see section 4.4.7.2 below) using local symbols (with
      binding STB_LOCAL).  To assist consumers, mapping and tagging
      symbols should be collated first in the symbol table, before
      other symbols with binding STB_LOCAL.

      To allow properly collated mapping and tagging symbols to be
      skipped by consumers that have no interest in them, the first
      such symbol should have the name $m and its st_value field equal
      to the total number of mapping and tagging symbols (including
      the $m) in the symbol table.

      4.4.7.1 Mapping symbols

      $a    Labels the first byte of a sequence of ARM instructions.
            Its type is STT_FUNC.

      $d    Labels the first byte of a sequence of data items.
            Its type is STT_OBJECT.

      $t    Labels the first byte of a sequence of Thumb instructions.
            Its type is STT_FUNC.

      This list of mapping symbols may be extended in the future.

      Section-relative mapping symbols

      Mapping symbols defined in a section define a sequence of
      half-open address intervals that cover the address range of the
      section. Each interval starts at the address defined by a
      mapping symbol, and continues up to, but not including, the
      address defined by the next (in address order) mapping symbol or
      the end of the section. A corollary is that there must be a
      mapping symbol defined at the beginning of each section.
      Consumers can ignore the size of a section-relative mapping
      symbol. Producers can set it to 0.

      Absolute mapping symbols

      Because of the need to crystallize a Thumb address with the
      Thumb-bit set, absolute symbol of type STT_FUNC (symbols of type
      STT_FUNC defined in section SHN_ABS) need to be mapped with $a
      or $t.

      The extent of a mapping symbol defined in SHN_ABS is [st_value,
      st_value + st_size), or [st_value, st_value + 1) if st_size = 0,
      where [x, y) denotes the half-open address range from x,
      inclusive, to y, exclusive.

      In the absence of a mapping symbol, a consumer can interpret a
      function symbol with an odd value as the Thumb code address
      obtained by clearing the least significant bit of the
      value. This interpretation is deprecated, and it may not work in
      the future.

   Note - the Tagging symbols ($b, $f, $p $m) have been dropped from
   the EABI (which is still under development), so they are not
   implemented here.  */
d1270 1
a1270 1
      type = BSF_OBJECT;
d1274 1
a1274 1
      type = BSF_FUNCTION;
d1278 1
a1278 1
      type = BSF_FUNCTION;
d13672 11
a13682 8
	  /* If it's a .thumb_func, declare it as so,
	     otherwise tag label as .code 16.  */
	  if (THUMB_IS_FUNC (sym))
	    elf_sym->internal_elf_sym.st_info =
	      ELF_ST_INFO (bind, STT_ARM_TFUNC);
	  else
	    elf_sym->internal_elf_sym.st_info =
	      ELF_ST_INFO (bind, STT_ARM_16BIT);
@


1.198
log
@	* gas/config/tc-arm.c (marked_pr_dependency): New bitmap, bit N
	indicates whether personality routine index N has been output for this
	section.
	(mapping_state): tc_segment_info_data now struct not enum.
	(arm_elf_change_section): Likewise, and marked_pr_dependency is now
	handled on section change.
	(create_unwind_entry): Previous code to output dependency removed.
	(s_arm_unwind_fnend): Output dependency if it hasn't been done already
	for this section.
	* gas/config/tc-arm.h (TC_SEGMENT_INFO_TYPE): Redefined as struct
	arm_segment_info_type.
	(arm_segment_info_type): New struct.
	* gas/testsuite/gas/arm/unwind.d: Update expected output.
@
text
@d4884 5
d12232 8
d12563 12
d13871 5
d13931 2
d13934 1
d13936 1
d13950 1
a13950 1
	      char *p = frag_more ((int) nbytes);
d13952 12
d13965 1
@


1.197
log
@* config/tc-arm.c (arm_adjust_symtab): Fetch elf_sym's binding
attributes properly.
@
text
@d86 5
d1355 1
a1355 1
  seg_info (now_seg)->tc_segment_info_data = state;
d1387 1
d1403 3
a1405 1
  mapstate = seg_info (now_seg)->tc_segment_info_data;
a14313 7
      /* Indicate dependency to linker.  */
        {
          char *name = "__aeabi_unwind_cpp_pr0";
	  symbolS *pr = symbol_find_or_make (name);
	  fix_new (frag_now, where, 4, pr, 0, 1, BFD_RELOC_NONE);
	}

d14327 1
a14327 1
      goto emit_reloc;
a14333 11
      goto emit_reloc;

    emit_reloc:
      {
	/* Indicate dependency to linker.  */
	char *name[] = { "__aeabi_unwind_cpp_pr0",
	                 "__aeabi_unwind_cpp_pr1",
			 "__aeabi_unwind_cpp_pr2" };
	symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
	fix_new (frag_now, where, 4, pr, 0, 1, BFD_RELOC_NONE);
      }
d14442 17
@


1.196
log
@	* configure.tgt: Set emulation for arm-*-eabi*.
	* config/tc-arm.c (meabi_flags): Check EABI_DEFAULT.
	* config/te-armeabi.h: New file.
	* config/te-armlinuxeabi.h (EABI_DEFAULT): Define.
	* config/te-symbian.h: Include "te-armeabi.h".
@
text
@d13706 1
a13706 1
	  bind = ELF_ST_BIND (elf_sym);
@


1.195
log
@	* config/tc-arm.c (do_mla): Rename to do_mlas, take second
	is_mls parameter; do not diagnose Rm==Rd when is_mls.
	(do_mla, do_mls, five_bit_unsigned_immediate, bfci_lsb_and_width)
	(do_bfc, do_bfi, do_bfx, do_rbit, do_mov16, do_ldsttv4): New functions.
	(insns): Add ARMv6T2 instructions:
	bfc bfi mls movw movt rbit sbfx ubfx ldrht ldrsht ldrsbt strht.
	(arm_archs): Add V6T2 variants.
testsuite:
	* gas/arm/archv6t2.d, gas/arm/archv6t2.s: New dump test.
	* gas/arm/archv6t2-bad.l, gas/arm/archv6t2-bad.l: New errors test.
	* gas/arm/arm.exp: Run them.
@
text
@d162 3
d166 1
@


1.194
log
@gas:
	* config/tc-arm.c (tinsns): Add ARMv6K instructions sev, wfe,
	wfi, yield.
opcodes:
	* arm-dis.c (thumb_opcodes): Add ARMv6K instructions nop, sev,
	wfe, wfi, yield.
gas/testsuite:
	* gas/arm/thumbv6k.d, gas/arm/thumbv6k.s: New dump test.
	* gas/arm/arm.exp: Run it.
@
text
@d2817 1
a2817 1
do_mla (char * str)
d2849 3
a2851 1
  if (rm == rd)
d2872 12
d4529 280
d6814 78
d10389 15
d13153 4
@


1.193
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d10953 6
@


1.193.2.1
log
@	Backport from mainline:
	2005-05-05  Nick Clifton  <nickc@@redhat.com>
	* config/tc-arm.c (arm_opts): Make -mlittle-endian switch set
	the target_big_endian variable to false.
@
text
@d12516 1
a12516 1
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 0,
@


1.193.4.1
log
@Backport ARM patches from HEAD to binutils-csl-arm-2005q1-branch.
@
text
@a161 3
# ifdef EABI_DEFAULT
static int meabi_flags = EABI_DEFAULT;
# else
a162 1
# endif
d2817 1
a2817 1
do_mlas (char * str, bfd_boolean is_mls)
d2849 1
a2849 3
  /* This restriction does not apply to mls (nor to mla in v6, but
     that's hard to detect at present).  */
  if (rm == rd && !is_mls)
a2869 12
static void
do_mla (char *str)
{
  do_mlas (str, FALSE);
}

static void
do_mls (char *str)
{
  do_mlas (str, TRUE);
}

a4514 280
/* ARM V6T2 bitfield manipulation instructions.  */

static int
five_bit_unsigned_immediate (char **str)
{
  expressionS expr;

  skip_whitespace (*str);
  if (!is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return -1;
    }
  (*str)++;
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return -1;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return -1;
    }
  if (expr.X_add_number < 0 || expr.X_add_number > 32)
    {
      inst.error = _("immediate value out of range");
      return -1;
    }
  
  return expr.X_add_number;
}

static void
bfci_lsb_and_width (char *str)
{
  int lsb, width;

  if ((lsb = five_bit_unsigned_immediate (&str)) == -1)
    return;

  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if ((width = five_bit_unsigned_immediate (&str)) == -1)
    return;

  end_of_line (str);

  if (width == 0 || lsb == 32)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  else if (width + lsb > 32)
    {
      inst.error = _("bit-field extends past end of register");
      return;
    }

  /* Convert to LSB/MSB and write to register.  */
  inst.instruction |= lsb << 7;
  inst.instruction |= (width + lsb - 1) << 16;
}

static void
do_bfc (char *str)
{
  int rd;

  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  bfci_lsb_and_width (str);
}

static void
do_bfi (char *str)
{
  int rd, rm;

  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Rm.  Accept #0 in this position as an alternative syntax for bfc.  */
  skip_whitespace (str);
  if (is_immediate_prefix (*str))
    {
      expressionS expr;
      str++;
      if (my_get_expression (&expr, &str))
	{
	  inst.error = _("bad expression");
	  return;
	}
      if (expr.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return;
	}
      if (expr.X_add_number != 0)
	{
	  inst.error = _("immediate value out of range");
	  return;
	}
      inst.instruction |= 0x0000000f;  /* Rm = PC -> bfc, not bfi.  */
    }
  else
    {
      if ((rm = reg_required_here (&str, 0)) == FAIL)
	{
	  inst.error = BAD_ARGS;
	  return;
	}
      else if (rm == REG_PC)
	{
	  inst.error = BAD_PC;
	  return;
	}
    }
  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  bfci_lsb_and_width (str);
}

static void
do_bfx (char *str)
{
  int lsb, width;

  /* Rd.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Rm.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 0) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if ((lsb = five_bit_unsigned_immediate (&str)) == -1)
    return;

  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if ((width = five_bit_unsigned_immediate (&str)) == -1)
    return;

  end_of_line (str);

  if (width == 0 || lsb == 32)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  else if (width + lsb > 32)
    {
      inst.error = _("bit-field extends past end of register");
      return;
    }

  inst.instruction |= lsb << 7;
  inst.instruction |= (width - 1) << 16;
}

static void
do_rbit (char *str)
{
  /* Rd.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Rm.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 0) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.  */
static void
do_mov16 (char *str)
{
  int rd;
  expressionS expr;

  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Imm16.  */
  skip_whitespace (str);
  if (!is_immediate_prefix (*str))
    {
      inst.error = _("immediate expression expected");
      return;
    }
  str++;
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number < 0 || expr.X_add_number > 65535)
    {
      inst.error = _("immediate value out of range");
      return;
    }

  end_of_line (str);

  /* The value is in two pieces: 0:11, 16:19.  */
  inst.instruction |= (expr.X_add_number & 0x00000fff);
  inst.instruction |= (expr.X_add_number & 0x0000f000) << 4;
}
  

a6519 78
static void
do_ldsttv4 (char * str)
{
  int conflict_reg;

  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("address expected");
      return;
    }

  if (*str == '[')
    {
      int reg;

      str++;

      skip_whitespace (str);

      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      /* ldrt/strt always use post-indexed addressing, so if the base is
	 the same as Rd, we warn.  */
      if (conflict_reg == reg)
	as_warn (_("%s register same as write-back base"),
		 ((inst.instruction & LOAD_BIT)
		  ? _("destination") : _("source")));

      skip_whitespace (str);

      if (*str == ']')
	{
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend_v4 (&str) == FAIL)
		return;
	    }
	  else
	    {
	      /* [Rn]  */
	      skip_whitespace (str);

	      /* Skip a write-back '!'.  */
	      if (*str == '!')
		str++;

	      inst.instruction |= (INDEX_UP|HWOFFSET_IMM);
	    }
	}
      else
	{
	  inst.error = _("post-indexed expression expected");
	  return;
	}
    }
  else
    {
      inst.error = _("post-indexed expression expected");
      return;
    }

  end_of_line (str);
}


a10016 15
  /*  ARM V6T2.  */
  { "bfc",       0xe7c0001f, 3,  ARM_EXT_V6T2,     do_bfc},
  { "bfi",       0xe7c00010, 3,  ARM_EXT_V6T2,     do_bfi},
  { "mls",       0xe0600090, 3,  ARM_EXT_V6T2,     do_mls},
  { "movw",      0xe3000000, 4,  ARM_EXT_V6T2,     do_mov16},
  { "movt",      0xe3400000, 4,  ARM_EXT_V6T2,     do_mov16},
  { "rbit",      0xe3ff0f30, 4,  ARM_EXT_V6T2,     do_rbit},
  { "sbfx",      0xe7a00050, 4,  ARM_EXT_V6T2,     do_bfx},
  { "ubfx",      0xe7e00050, 4,  ARM_EXT_V6T2,     do_bfx},

  { "ldrht",     0xe03000b0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "ldrsht",    0xe03000f0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "ldrsbt",    0xe03000d0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "strht",     0xe02000b0, 3,  ARM_EXT_V6T2,     do_ldsttv4},

a10952 6

  /* ARM V6K.  */
  {"sev",	0xbf40,		2,	ARM_EXT_V6K, do_empty},
  {"wfe",	0xbf20,		2,	ARM_EXT_V6K, do_empty},
  {"wfi",	0xbf30,		2,	ARM_EXT_V6K, do_empty},
  {"yield",	0xbf10,		2,	ARM_EXT_V6K, do_empty},
a12759 4
  {"armv6t2",		ARM_ARCH_V6T2,   FPU_ARCH_VFP},
  {"armv6kt2",		ARM_ARCH_V6KT2,  FPU_ARCH_VFP},
  {"armv6zt2",		ARM_ARCH_V6ZT2,  FPU_ARCH_VFP},
  {"armv6zkt2",		ARM_ARCH_V6ZKT2, FPU_ARCH_VFP},
d13305 1
a13305 1
	  bind = ELF_ST_BIND (elf_sym->internal_elf_sym.st_info);
@


1.193.4.2
log
@	* bfd/bfd-in2.h, libbfd.h: Regenerated.
	* bfd/reloc.c: Add ARM TLS relocations.
	* bfd/elf32-arm.c (elf32_arm_howto_table): Add dynamic TLS
	relocations.
	(elf32_arm_tls_gd32_howto, elf32_arm_tls_ldo32_howto)
	(elf32_arm_tls_ldm32_howto, elf32_arm_tls_le32_howto)
	(elf32_arm_tls_ie32_howto): New.
	(elf32_arm_howto_from_type): Support TLS relocations.
	(elf32_arm_reloc_map): Likewise.
	(elf32_arm_reloc_type_lookup): Likewise.
	(TCB_SIZE): Define.
	(struct elf32_arm_obj_tdata): New.
	(elf32_arm_tdata, elf32_arm_local_got_tls_type): Define.
	(elf32_arm_mkobject): New function.
	(struct elf32_arm_relocs_copied): Add pc_count.
	(elf32_arm_hash_entry, GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD)
	(GOT_TLS_IE): Define.
	(struct elf32_arm_link_hash_table): Add tls_ldm_got.
	(elf32_arm_link_hash_newfunc): Initialize tls_type.
	(elf32_arm_copy_indirect_symbol): Copy pc_count and tls_type.
	(elf32_arm_link_hash_table_create): Initialize tls_ldm_got.
	(dtpoff_base, tpoff): New functions.
	(elf32_arm_final_link_relocate): Handle TLS relocations.
	(IS_ARM_TLS_RELOC): Define.
	(elf32_arm_relocate_section): Warn about TLS mismatches.
	(elf32_arm_gc_sweep_hook): Handle TLS relocations and pc_count.
	(elf32_arm_check_relocs): Detect invalid symbol indexes.  Handle
	TLS relocations and pc_count.
	(elf32_arm_adjust_dynamic_symbol): Check non_got_ref.
	(allocate_dynrelocs): Handle TLS.  Bind REL32 relocs to local
	calls.
	(elf32_arm_size_dynamic_sections): Handle TLS.
	(elf32_arm_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject): Define.

	* gas/config/tc-arm.c (arm_parse_reloc): Add TLS relocations.
	(md_apply_fix3): Mark TLS symbols.
	(tc_gen_reloc): Handle TLS relocations.
	(arm_fix_adjustable): Ignore TLS relocations.
	(s_arm_elf_cons): Support expressions after decorated symbols.

	* gas/testsuite/gas/arm/tls.s, gas/testsuite/gas/arm/tls.d: New files.
	* gas/testsuite/gas/arm/arm.exp: Run TLS test.

	* include/elf/arm.h: Add TLS relocations.

	* ld/testsuite/ld-arm/tls-lib.s, ld/testsuite/ld-arm/tls-lib.d,
	ld/testsuite/ld-arm/tls-lib.r, ld/testsuite/ld-arm/tls-app.s,
	ld/testsuite/ld-arm/tls-app.d, ld/testsuite/ld-arm/tls-app.r: New files.
	* ld/testsuite/ld-arm/arm-lib.ld, ld/testsuite/ld-arm/arm-dyn.ld:
	Increase data segment alignment.
	* ld/testsuite/ld-arm/arm-elf.exp: Run TLS tests.
@
text
@a4875 5
    MAP ("(tlsgd)", BFD_RELOC_ARM_TLS_GD32),
    MAP ("(tlsldm)", BFD_RELOC_ARM_TLS_LDM32),
    MAP ("(tlsldo)", BFD_RELOC_ARM_TLS_LDO32),
    MAP ("(gottpoff)", BFD_RELOC_ARM_TLS_IE32),
    MAP ("(tpoff)", BFD_RELOC_ARM_TLS_LE32),
a12218 8
     case BFD_RELOC_ARM_TLS_GD32:
     case BFD_RELOC_ARM_TLS_LE32:
     case BFD_RELOC_ARM_TLS_IE32:
     case BFD_RELOC_ARM_TLS_LDM32:
     case BFD_RELOC_ARM_TLS_LDO32:
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
	/* fall through */

a12541 12
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_LDO32:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
      /* BFD will include the symbol's address in the addend.  
	 But we don't want that, so subtract it out again here.  */
      if (!S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= (*reloc->sym_ptr_ptr)->value;
a13837 5
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GD32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_IE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDM32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDO32
a13892 2
      char *sym_start;
      int sym_len;
a13893 1
      sym_start = input_line_pointer;
a13894 1
      sym_len = input_line_pointer - sym_start;
d13908 1
a13908 1
	      char *p;
a13909 12
	      char *saved_buf = alloca (sym_len), *saved_input;

	      /* We've parsed an expression stopping at O_symbol.  But there
		 may be more expression left now that we have parsed the
		 relocation marker.  Parse it again.  */
	      saved_input = input_line_pointer - sym_len;
	      memcpy (saved_buf, saved_input, sym_len);
	      memmove (saved_input, sym_start, sym_len);
	      input_line_pointer = saved_input;
	      expression (& exp);
	      memcpy (saved_input, saved_buf, sym_len);
	      assert (input_line_pointer >= saved_input + sym_len);
a13910 1
	      p = frag_more ((int) nbytes);
@


1.193.4.3
log
@	* gas/config/tc-arm.c (marked_pr_dependency): New bitmap, bit N
	indicates whether personality routine index N has been output for this
	section.
	(mapping_state): tc_segment_info_data now struct not enum.
	(arm_elf_change_section): Likewise, and marked_pr_dependency is now
	handled on section change.
	(create_unwind_entry): Previous code to output dependency removed.
	(s_arm_unwind_fnend): Output dependency if it hasn't been done already
	for this section.
	* gas/config/tc-arm.h (TC_SEGMENT_INFO_TYPE): Redefined as struct
	arm_segment_info_type.
	(arm_segment_info_type): New struct.
	* gas/testsuite/gas/arm/unwind.d: Update expected output.
@
text
@a85 5
/* Bit N indicates that an R_ARM_NONE relocation has been output for
   __aeabi_unwind_cpp_prN already if set. This enables dependencies to be
   emitted only once per section, to save unnecessary bloat.  */
static unsigned int marked_pr_dependency = 0;

d1350 1
a1350 1
  seg_info (now_seg)->tc_segment_info_data.mapstate = state;
a1381 1
  segment_info_type *seginfo;
d1397 1
a1397 3
  seginfo = seg_info (now_seg);
  mapstate = seginfo->tc_segment_info_data.mapstate;
  marked_pr_dependency = seginfo->tc_segment_info_data.marked_pr_dependency;
d14353 7
d14373 1
a14373 1
      break;
d14380 11
a14498 17
  /* Indicate dependency on EHABI-defined personality routines to the
     linker, if it hasn't been done already.  */
  if (unwind.personality_index >= 0 && unwind.personality_index < 3)
    {
      char *name[] = { "__aeabi_unwind_cpp_pr0",
		       "__aeabi_unwind_cpp_pr1",
		       "__aeabi_unwind_cpp_pr2" };
      if (!(marked_pr_dependency & (1 << unwind.personality_index)))
	{
	  symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
	  fix_new (frag_now, where, 0, pr, 0, 1, BFD_RELOC_NONE);
	  marked_pr_dependency |= 1 << unwind.personality_index;
	  seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency
	    = marked_pr_dependency;
        }
    }

@


1.193.4.4
log
@	* bfd/bfd-in.h (bfd_is_arm_mapping_symbol_name): Add prototype.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c (elf32_arm_is_target_special_symbol): Rename call to
	bfd_is_arm_mapping_symbol_name.
	(elf32_arm_output_symbol_hook): Likewise.
	(arm_elf_find_function): Likewise, and include STT_NOTYPE in test for
	mapping symbols.
	(is_arm_mapping_symbol_name): Function moved from here...
	* bfd/cpu-arm.c (bfd_is_arm_mapping_symbol_name): ...to here,
	renamed and made global.
	* gas/config/tc-arm.c (mapping_state): Change documentation in
	function comment to cross-reference spec instead. Change type of
	mapping symbols to BSF_NO_TYPE.
	(arm_adjust_symtab): Don't change type of mapping symbols here.
	* gas/testsuite/gas/arm/mapping.d: Update expected output.
	* ld/testsuite/ld-arm/arm-app-abs32.d: Likewise.
	* ld/testsuite/ld-arm/arm-app.d: Likewise.
	* ld/testsuite/ld-arm/mixed-app.d: Likewise.
@
text
@d1246 72
a1317 3
   (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).
   Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),
   and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */
d1339 1
a1339 1
      type = BSF_NO_FLAGS;
d1343 1
a1343 1
      type = BSF_NO_FLAGS;
d1347 1
a1347 1
      type = BSF_NO_FLAGS;
d13741 8
a13748 11
	  if (! bfd_is_arm_mapping_symbol_name (elf_sym->symbol.name))
	    { 
	      /* If it's a .thumb_func, declare it as so,
		 otherwise tag label as .code 16.  */
	      if (THUMB_IS_FUNC (sym))
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_TFUNC);
	      else
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_16BIT);
	    }
@


1.193.4.5
log
@	Thumb32 assembler.

	* include/elf/arm.h: Import full set of relocation names from
	latest AAELF.  Make the primary name of all relocations be the one
	AAELF specifies.  Provide aliases under the traditional names.
	Kill FIRST_INVALID_RELOC_* and LAST_INVALID_RELOC_*.
	* bfd/reloc.c: Reorganize ARM relocations.  Remove ARM relocations
	that are never generated.  Document more of the relocations.  Add
	relocations for Thumb32.
	* bfd/libbfd.h, bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c: Reorganize howto tables.  Implement Thumb32
	relocations.
	* ld/testsuite/ld-arm/mixed-app.d: Adjust expectations for
	renamed relocations.

	* gas/hash.c (hash_find_n): New interface.
	* gas/hash.h: Prototype it.

	* gas/config/tc-arm.c: Rewrite and reorganize.  Implement 32-bit
	Thumb instructions.
	* gas/testsuite/gas/arm: Convert all "gas_test" style tests to
	"run_dump_test" style tests, for more thorough testing.  Make
	adjustments to expectations where necessary.
	* gas/testsuite/gas/arm/t16-bad.s, gas/testsuite/gas/arm/tcompat.s
	* gas/testsuite/gas/arm/tcompat2.s, gas/testsuite/gas/arm/thumb32.s:
	New test cases.

	* opcodes/arm-dis.c: Add support for Thumb32 instructions and
	16-bit V6T2 instructions.
@
text
@d20 1
a20 1
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
d29 1
a29 1
#define	 NO_RELOC 0
d59 4
a62 4
  symbolS *	  proc_start;
  symbolS *	  table_entry;
  symbolS *	  personality_routine;
  int		  personality_index;
d64 2
a65 2
  segT		  saved_seg;
  subsegT	  saved_subseg;
d68 2
a69 2
  int		  opcode_count;
  int		  opcode_alloc;
d71 1
a71 1
  offsetT	  frame_size;
d75 1
a75 1
  offsetT	  pending_offset;
d77 3
a79 3
     hold the reg+offset to use when restoring sp from a frame pointer.	 */
  offsetT	  fp_offset;
  int		  fp_reg;
d81 1
a81 1
  unsigned	  fp_used:1;
d83 1
a83 1
  unsigned	  sp_restored:1;
d100 1
a100 1
/* Types of processor to assemble for.	*/
d110 1
a110 1
#define ARM_CPU_MASK	0x0000000f		/* XXX? */
d117 1
a117 1
#define CPU_DEFAULT	(ARM_ARCH_V5T)
d119 1
a119 1
#define CPU_DEFAULT	ARM_ANY
d142 2
a143 1
#define streq(a, b)	      (strcmp (a, b) == 0)
d148 2
a149 2
static int uses_apcs_26	     = FALSE;
static int atpcs	     = FALSE;
d152 1
a152 1
static int pic_code	     = FALSE;
d174 29
d204 1
a204 1
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"	*/
d217 4
a220 7
/* If "thumb32_mode" is not true, we are processing old-style
   Thumb assembly.  Most importantly, that means that a large number
   of arithmetic mnemonics set the flags even though they don't have
   an 's' suffix.  Note that encoders for instructions that only exist
   in V6T2 or later, ignore thumb32_mode.  */

static bfd_boolean thumb32_mode = FALSE;
d224 1
a224 1
  const char *	error;
d226 1
a226 2
  int		size;
  int		size_req;
d230 2
a231 2
    expressionS		     exp;
    int			     pc_rel;
d233 12
d246 37
a282 15
  struct
  {
    unsigned reg;
    unsigned imm;
    unsigned present	: 1;  /* operand present */
    unsigned isreg	: 1;  /* operand was a register */
    unsigned immisreg	: 1;  /* .imm field is a second register */
    unsigned hasreloc	: 1;  /* operand has relocation suffix */
    unsigned writeback	: 1;  /* operand has trailing ! */
    unsigned preind	: 1;  /* preindexed address */
    unsigned postind	: 1;  /* postindexed address */
    unsigned negative	: 1;  /* index register was negated */
    unsigned shifted	: 1;  /* shift applied to operation */
    unsigned shift_kind : 3;  /* shift operation (enum shift_kind) */
  } operands[6];
d285 10
a294 1
static struct arm_it inst;
d303 1
a303 1
/* Number of littlenums required to hold an extended precision number.	*/
d311 4
d320 5
a324 2
#define CP_T_X	 0x00008000
#define CP_T_Y	 0x00400000
d326 2
a327 2
#define CONDS_BIT	 0x00100000
#define LOAD_BIT	 0x00100000
d333 1
a333 1
  const char *	template;
d340 20
d363 1
d370 177
a546 5
/* The individual PSR flag bits.  */
#define PSR_c	(1 << 16)
#define PSR_x	(1 << 17)
#define PSR_s	(1 << 18)
#define PSR_f	(1 << 19)
d548 1
a548 1
struct reloc_entry
d550 1
a550 2
  char *name;
  bfd_reloc_code_real_type reloc;
d563 8
a570 3
/* ARM register categories.  This includes coprocessor numbers and various
   architecture extensions' registers.	*/
enum arm_reg_type
d572 6
a577 17
  REG_TYPE_RN,
  REG_TYPE_CP,
  REG_TYPE_CN,
  REG_TYPE_FN,
  REG_TYPE_VFS,
  REG_TYPE_VFD,
  REG_TYPE_VFC,
  REG_TYPE_MVF,
  REG_TYPE_MVD,
  REG_TYPE_MVFX,
  REG_TYPE_MVDX,
  REG_TYPE_MVAX,
  REG_TYPE_DSPSC,
  REG_TYPE_MMXWR,
  REG_TYPE_MMXWC,
  REG_TYPE_MMXWCG,
  REG_TYPE_XSCALE,
d583 3
a585 26
  const char   *name;
  unsigned char number;
  unsigned char type;
  unsigned char builtin;
};

/* Diagnostics used when we don't get a register of the expected type.	*/
const char *const reg_expected_msgs[] =
{
  N_("ARM register expected"),
  N_("bad or missing co-processor number"),
  N_("co-processor register expected"),
  N_("FPA register expected"),
  N_("VFP single precision register expected"),
  N_("VFP double precision register expected"),
  N_("VFP system register expected"),
  N_("Maverick MVF register expected"),
  N_("Maverick MVD register expected"),
  N_("Maverick MVFX register expected"),
  N_("Maverick MVDX register expected"),
  N_("Maverick MVAX register expected"),
  N_("Maverick DSPSC register expected"),
  N_("iWMMXt data register expected"),
  N_("iWMMXt control register expected"),
  N_("iWMMXt scalar register expected"),
  N_("XScale accumulator register expected"),
d589 2
a590 2
#define REG_SP	13
#define REG_LR	14
d593 210
d805 19
a823 1
#define INSN_SIZE	4
d828 1
a828 4
  const char *template;

  /* Parameters to instruction.	 */
  unsigned char operands[8];
d831 1
a831 1
  unsigned long avalue;
d833 3
a835 2
  /* Thumb-format instruction code.  */
  unsigned long tvalue;
d838 1
a838 2
  unsigned long avariant;
  unsigned long tvariant;
d840 2
a841 5
  /* Function to call to encode instruction in ARM format.  */
  void (* aencode) (void);

  /* Function to call to encode instruction in Thumb format.  */
  void (* tencode) (void);
d847 1
a847 1
#define HWOFFSET_IMM	0x00400000
d898 1
a898 2
#define T_OPCODE_LSR_R	0x40c0
#define T_OPCODE_ROR_R	0x41c0
d931 18
a949 1
#define THUMB_LOAD_BIT 0x0800
d951 32
a982 13
#define BAD_ARGS	_("bad arguments to instruction")
#define BAD_PC		_("r15 not allowed here")
#define BAD_COND	_("instruction cannot be conditional")
#define BAD_OVERLAP	_("registers may not be the same")
#define BAD_HIREG	_("lo register required")
#define BAD_THUMB32	_("instruction not supported in Thumb16 mode")

static struct hash_control *arm_ops_hsh;
static struct hash_control *arm_cond_hsh;
static struct hash_control *arm_shift_hsh;
static struct hash_control *arm_psr_hsh;
static struct hash_control *arm_reg_hsh;
static struct hash_control *arm_reloc_hsh;
d991 1
a991 1
	      <insn>
d997 4
a1003 1
#define MAX_LITERAL_POOL_SIZE 1024
d1006 6
a1011 6
  expressionS	 literals [MAX_LITERAL_POOL_SIZE];
  unsigned int	 next_free_entry;
  unsigned int	 id;
  symbolS *	 symbol;
  segT		 section;
  subsegT	 sub_section;
a1016 2

/* Pure syntax.	 */
d1018 4
a1021 3
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.	 */
const char comment_chars[] = "@@";
d1023 6
a1028 8
/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.	*/
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";
d1030 2
a1031 1
const char line_separator_chars[] = ";";
d1033 6
a1038 3
/* Chars that can be used to separate mant
   from exp in floating point numbers.	*/
const char EXP_CHARS[] = "eE";
d1040 1
a1040 3
/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456  */
/* or	 0d1.2345e12  */
d1042 6
a1047 1
const char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d1049 5
a1053 3
/* Prefix characters that indicate the start of an immediate
   value.  */
#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')
d1055 3
a1057 1
/* Separator character handling.  */
d1059 2
a1060 6
#define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)

static inline int
skip_past_char (char ** str, char c)
{
  if (**str == c)
d1062 3
a1064 2
      (*str)++;
      return SUCCESS;
d1066 3
a1068 2
  else
    return FAIL;
a1069 1
#define skip_past_comma(str) skip_past_char (str, ',')
d1071 2
a1072 3
/* Arithmetic expressions (possibly involving symbols).	 */

/* Return TRUE if anything in the expression is a bignum.  */
d1075 1
a1075 1
walk_no_bignums (symbolS * sp)
d1077 4
a1080 2
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;
d1082 2
a1083 1
  if (symbol_get_value_expression (sp)->X_add_symbol)
d1085 17
a1101 3
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
d1104 2
a1105 17
  return 0;
}

static int in_my_get_expression = 0;

/* Third argument to my_get_expression.	 */
#define GE_NO_PREFIX 0
#define GE_IMM_PREFIX 1
#define GE_OPT_PREFIX 2

static int
my_get_expression (expressionS * ep, char ** str, int prefix_mode)
{
  char * save_in;
  segT	 seg;

  switch (prefix_mode)
d1107 1
a1107 3
    case GE_NO_PREFIX: break;
    case GE_IMM_PREFIX:
      if (!is_immediate_prefix (**str))
d1109 1
a1109 1
	  inst.error = _("immediate expression requires a # prefix");
a1111 8
      (*str)++;
      break;
    case GE_OPT_PREFIX:
      if (is_immediate_prefix (**str))
	(*str)++;
      break;
    default: abort ();
    }
d1113 2
a1114 16
  memset (ep, 0, sizeof (expressionS));

  save_in = input_line_pointer;
  input_line_pointer = *str;
  in_my_get_expression = 1;
  seg = expression (ep);
  in_my_get_expression = 0;

  if (ep->X_op == O_illegal)
    {
      /* We found a bad expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      if (inst.error == NULL)
	inst.error = _("bad expression");
      return 1;
d1117 3
a1119 13
#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
#endif
d1121 1
a1121 18
  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.	 Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (ep->X_op == O_big
      || (ep->X_add_symbol
	  && (walk_no_bignums (ep->X_add_symbol)
	      || (ep->X_op_symbol
		  && walk_no_bignums (ep->X_op_symbol)))))
    {
      inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
d1124 2
a1125 4
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.
d1127 9
a1135 6
   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.	However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.
d1137 7
a1143 1
   ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */
d1145 4
a1148 7
char *
md_atof (int type, char * litP, int * sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int i;
d1150 1
a1150 8
  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;
d1152 3
a1154 6
    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;
d1156 1
a1156 4
    case 'x':
    case 'X':
      prec = 6;
      break;
d1158 3
a1160 4
    case 'p':
    case 'P':
      prec = 6;
      break;
d1162 3
a1164 4
    default:
      *sizeP = 0;
      return _("bad call to MD_ATOF()");
    }
d1166 1
a1166 4
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * 2;
d1168 1
a1168 26
  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      if (cpu_variant & FPU_ARCH_VFP)
	for (i = prec - 1; i >= 0; i--)
	  {
	    md_number_to_chars (litP, (valueT) words[i], 2);
	    litP += 2;
	  }
      else
	/* For a 4 byte float the order of elements in `words' is 1 0.
	   For an 8 byte float the order is 1 0 3 2.  */
	for (i = 0; i < prec; i += 2)
	  {
	    md_number_to_chars (litP, (valueT) words[i + 1], 2);
	    md_number_to_chars (litP + 2, (valueT) words[i], 2);
	    litP += 4;
	  }
    }
d1170 3
a1172 2
  return 0;
}
d1174 3
a1176 7
/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expressionS * expr)
{
  if (in_my_get_expression)
    expr->X_op = O_illegal;
d1179 2
a1180 1
/* Immediate values.  */
d1182 2
a1183 6
/* Generic immediate-value read function for use in directives.
   Accepts anything that 'expression' can fold to a constant.
   *val receives the number.  */
#ifdef OBJ_ELF
static int
immediate_for_directive (int *val)
d1185 4
a1188 2
  expressionS exp;
  exp.X_op = O_illegal;
d1190 3
a1192 5
  if (is_immediate_prefix (*input_line_pointer))
    {
      input_line_pointer++;
      expression (&exp);
    }
d1194 1
a1194 8
  if (exp.X_op != O_constant)
    {
      as_bad (_("expected #constant"));
      ignore_rest_of_line ();
      return FAIL;
    }
  *val = exp.X_add_number;
  return SUCCESS;
a1195 1
#endif
d1197 3
a1199 1
/* Register parsing.  */
d1201 3
a1203 7
/* Generic register parser.  CCP points to what should be the
   beginning of a register name.  If it is indeed a valid register
   name, advance CCP over it and return the reg_entry structure;
   otherwise return NULL.  Does not issue diagnostics.	*/

static struct reg_entry *
arm_reg_parse_multi (char **ccp)
d1205 2
a1206 3
  char *start = *ccp;
  char *p;
  struct reg_entry *reg;
d1208 20
a1227 9
#ifdef REGISTER_PREFIX
  if (*start != REGISTER_PREFIX)
    return FAIL;
  start++;
#endif
#ifdef OPTIONAL_REGISTER_PREFIX
  if (*start == OPTIONAL_REGISTER_PREFIX)
    start++;
#endif
d1229 2
a1230 3
  p = start;
  if (!ISALPHA (*p) || !is_name_beginner (*p))
    return NULL;
d1232 1
a1232 11
  do
    p++;
  while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');

  reg = (struct reg_entry *) hash_find_n (arm_reg_hsh, start, p - start);

  if (!reg)
    return NULL;

  *ccp = p;
  return reg;
a1234 3
/* As above, but the register must be of type TYPE, and the return
   value is the register number or NULL.  */

d1236 1
a1236 1
arm_reg_parse (char **ccp, enum arm_reg_type type)
d1238 4
a1241 2
  char *start = *ccp;
  struct reg_entry *reg = arm_reg_parse_multi (ccp);
d1243 6
a1248 2
  if (reg && reg->type == type)
    return reg->number;
d1250 1
a1250 11
  /* Alternative syntaxes are accepted for a few register classes.  */
  switch (type)
    {
    case REG_TYPE_MVF:
    case REG_TYPE_MVD:
    case REG_TYPE_MVFX:
    case REG_TYPE_MVDX:
      /* Generic coprocessor register names are allowed for these.  */
      if (reg->type == REG_TYPE_CN)
	return reg->number;
      break;
d1252 6
a1257 7
    case REG_TYPE_CP:
      /* For backward compatibility, a bare number is valid here.  */
      {
	unsigned long processor = strtoul (start, ccp, 10);
	if (*ccp != start && processor <= 15)
	  return processor;
      }
d1259 20
a1278 5
    case REG_TYPE_MMXWC:
      /* WC includes WCG.  ??? I'm not sure this is true for all
	 instructions that take WC registers.  */
      if (reg->type == REG_TYPE_MMXWCG)
	return reg->number;
d1280 2
a1281 1

d1283 1
a1283 1
      break;
d1286 1
a1286 3
  *ccp = start;
  return FAIL;
}
d1288 3
a1290 7
/* Parse an ARM register list.  Returns the bitmask, or FAIL.  */
static long
parse_reg_list (char ** strp)
{
  char * str = * strp;
  long	 range = 0;
  int	 another_range;
d1292 1
a1292 2
  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
d1294 5
a1298 1
      another_range = 0;
d1300 5
a1304 4
      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;
d1306 5
a1310 4
	  str++;
	  do
	    {
	      int reg;
d1312 1
a1312 5
	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN)) == FAIL)
		{
		  inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
		  return FAIL;
		}
d1314 5
a1318 3
	      if (in_range)
		{
		  int i;
d1320 4
a1323 5
		  if (reg <= cur_reg)
		    {
		      inst.error = _("bad range in register list");
		      return FAIL;
		    }
d1325 2
a1326 11
		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}
d1328 1
a1328 5
	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));
d1330 3
a1332 6
	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;
d1334 4
a1337 9
	  if (*str++ != '}')
	    {
	      inst.error = _("missing `}'");
	      return FAIL;
	    }
	}
      else
	{
	  expressionS expr;
d1339 5
a1343 2
	  if (my_get_expression (&expr, &str, GE_NO_PREFIX))
	    return FAIL;
d1345 8
a1352 8
	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}
d1354 7
a1360 3
	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;
d1362 13
a1374 6
		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}
d1376 3
a1378 9
	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}
d1380 3
a1382 5
	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
	}
d1384 4
a1387 5
      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
a1388 1
  while (another_range);
d1390 1
a1390 2
  *strp = str;
  return range;
d1393 3
a1395 3
/* Parse a VFP register list.  If the string is invalid return FAIL.
   Otherwise return the number of registers, and set PBASE to the first
   register.  Double precision registers are matched if DP is nonzero.	*/
d1397 2
a1398 2
static int
parse_vfp_reg_list (char **str, int *pbase, int dp)
a1399 7
  int base_reg;
  int new_base;
  int regtype;
  int max_regs;
  int count = 0;
  int warned = 0;
  unsigned long mask = 0;
d1402 3
a1404 2
  if (**str != '{')
    return FAIL;
d1406 2
a1407 1
  (*str)++;
d1409 4
a1412 1
  if (dp)
d1414 5
a1418 8
      regtype = REG_TYPE_VFD;
      max_regs = 16;
    }
  else
    {
      regtype = REG_TYPE_VFS;
      max_regs = 32;
    }
d1420 7
a1426 1
  base_reg = max_regs;
d1428 2
a1429 4
  do
    {
      new_base = arm_reg_parse (str, regtype);
      if (new_base == FAIL)
d1431 2
a1432 3
	  inst.error = gettext (reg_expected_msgs[regtype]);
	  return FAIL;
	}
d1434 1
a1434 2
      if (new_base < base_reg)
	base_reg = new_base;
d1436 2
a1437 5
      if (mask & (1 << new_base))
	{
	  inst.error = _("invalid register list");
	  return FAIL;
	}
d1439 1
a1439 4
      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
d1441 2
d1444 4
a1447 2
      mask |= 1 << new_base;
      count++;
d1449 11
a1459 3
      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;
d1461 5
a1465 1
	  (*str)++;
d1467 2
a1468 5
	  if ((high_range = arm_reg_parse (str, regtype)) == FAIL)
	    {
	      inst.error = gettext (reg_expected_msgs[regtype]);
	      return FAIL;
	    }
d1470 4
a1473 5
	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }
d1475 2
a1476 7
	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}
d1478 3
a1480 6
	      mask |= 1 << new_base;
	      count++;
	    }
	}
    }
  while (skip_past_comma (str) != FAIL);
d1482 4
a1485 1
  (*str)++;
d1487 3
a1489 3
  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > max_regs)
    abort ();
d1491 2
a1492 1
  *pbase = base_reg;
d1494 21
a1514 8
  /* Final test -- the registers must be consecutive.  */
  mask >>= base_reg;
  for (i = 0; i < count; i++)
    {
      if ((mask & (1u << i)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
d1516 2
d1519 2
d1522 2
a1523 1
  return count;
d1526 2
a1527 7
/* Parse an explicit relocation suffix on an expression.  This is
   either nothing, or a word in parentheses.  Note that if !OBJ_ELF,
   arm_reloc_hsh contains no entries, so this function can only
   succeed if there is no () after the word.  Returns -1 on error,
   BFD_RELOC_UNUSED if there wasn't any suffix.	 */
static int
parse_reloc (char **str)
d1529 6
a1534 2
  struct reloc_entry *r;
  char *p, *q;
d1536 6
a1541 2
  if (**str != '(')
    return BFD_RELOC_UNUSED;
d1543 1
a1543 2
  p = *str + 1;
  q = p;
d1545 1
a1545 10
  while (*q && *q != ')' && *q != ',')
    q++;
  if (*q != ')')
    return -1;

  if ((r = hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)
    return -1;

  *str = q + 1;
  return r->reloc;
a1547 2
/* Directives: register aliases.  */

d1549 1
a1549 1
insert_reg_alias (char *str, int number, int type)
d1551 11
a1561 2
  struct reg_entry *new;
  const char *name;
d1563 4
a1566 4
  if ((new = hash_find (arm_reg_hsh, str)) != 0)
    {
      if (new->builtin)
	as_warn (_("ignoring attempt to redefine built-in register '%s'"), str);
d1568 1
a1568 4
      /* Only warn about a redefinition if it's not defined as the
	 same register.	 */
      else if (new->number != number || new->type != type)
	as_warn (_("ignoring redefinition of register alias '%s'"), str);
d1570 1
a1570 2
      return;
    }
d1572 3
a1574 2
  name = xstrdup (str);
  new = xmalloc (sizeof (struct reg_entry));
d1576 1
a1576 4
  new->name = name;
  new->number = number;
  new->type = type;
  new->builtin = FALSE;
d1578 3
a1580 3
  if (hash_insert (arm_reg_hsh, name, (PTR) new))
    abort ();
}
d1582 3
a1584 1
/* Look for the .req directive.	 This is of the form:
d1586 4
a1589 1
	new_register_name .req existing_register_name
d1591 1
a1591 2
   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return non-zero.  Otherwise return zero.  */
d1593 2
a1594 2
static int
create_register_alias (char * newname, char *p)
d1596 3
a1598 9
  struct reg_entry *old;
  char *oldname, *nbuf;
  size_t nlen;

  /* The input scrubber ensures that whitespace after the mnemonic is
     collapsed to single spaces.  */
  oldname = p;
  if (strncmp (oldname, " .req ", 6) != 0)
    return 0;
d1600 8
a1607 3
  oldname += 6;
  if (*oldname == '\0')
    return 0;
d1609 1
a1609 2
  old = hash_find (arm_reg_hsh, oldname);
  if (!old)
d1611 2
a1612 2
      as_warn (_("unknown register '%s' -- .req ignored"), oldname);
      return 1;
d1614 2
d1617 2
a1618 9
  /* If TC_CASE_SENSITIVE is defined, then newname already points to
     the desired alias name, and p points to its end.  If not, then
     the desired alias name is in the global original_case_string.  */
#ifdef TC_CASE_SENSITIVE
  nlen = p - newname;
#else
  newname = original_case_string;
  nlen = strlen (newname);
#endif
d1620 4
a1623 3
  nbuf = alloca (nlen + 1);
  memcpy (nbuf, newname, nlen);
  nbuf[nlen] = '\0';
d1625 1
a1625 18
  /* Create aliases under the new name as stated; an all-lowercase
     version of the new name; and an all-uppercase version of the new
     name.  */
  insert_reg_alias (nbuf, old->number, old->type);

  for (p = nbuf; *p; p++)
    *p = TOUPPER (*p);

  if (strncmp (nbuf, newname, nlen))
    insert_reg_alias (nbuf, old->number, old->type);

  for (p = nbuf; *p; p++)
    *p = TOLOWER (*p);

  if (strncmp (nbuf, newname, nlen))
    insert_reg_alias (nbuf, old->number, old->type);

  return 1;
a1627 2
/* Should never be called, as .req goes between the alias and the
   register name, not at the beginning of the line.  */
d1629 1
a1629 1
s_req (int a ATTRIBUTE_UNUSED)
d1631 8
a1638 2
  as_bad (_("invalid syntax for .req directive"));
}
d1640 2
a1641 2
/* The .unreq directive deletes an alias which was previously defined
   by .req.  For example:
d1643 2
a1644 2
       my_alias .req r11
       .unreq my_alias	  */
d1647 1
a1647 1
s_unreq (int a ATTRIBUTE_UNUSED)
d1649 2
a1650 2
  char * name;
  char saved_char;
d1652 3
a1654 28
  name = input_line_pointer;

  while (*input_line_pointer != 0
	 && *input_line_pointer != ' '
	 && *input_line_pointer != '\n')
    ++input_line_pointer;

  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  if (!*name)
    as_bad (_("invalid syntax for .unreq directive"));
  else
    {
      struct reg_entry *reg = hash_find (arm_reg_hsh, name);

      if (!reg)
	as_bad (_("unknown register alias '%s'"), name);
      else if (reg->builtin)
	as_warn (_("ignoring attempt to undefine built-in register '%s'"),
		 name);
      else
	{
	  hash_delete (arm_reg_hsh, name);
	  free ((char *) reg->name);
	  free (reg);
	}
    }
a1655 1
  *input_line_pointer = saved_char;
d1659 2
a1660 9
/* Directives: Instruction set selection.  */

#ifdef OBJ_ELF
/* This code is to handle mapping symbols as defined in the ARM ELF spec.
   (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).
   Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),
   and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */

static enum mstate mapstate = MAP_UNDEFINED;
d1663 1
a1663 1
mapping_state (enum mstate state)
d1665 6
a1671 2
  const char * symname;
  int type;
d1673 7
a1679 4
  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;
d1681 1
a1681 1
  mapstate = state;
d1683 1
a1683 1
  switch (state)
d1685 13
a1697 15
    case MAP_DATA:
      symname = "$d";
      type = BSF_NO_FLAGS;
      break;
    case MAP_ARM:
      symname = "$a";
      type = BSF_NO_FLAGS;
      break;
    case MAP_THUMB:
      symname = "$t";
      type = BSF_NO_FLAGS;
      break;
    case MAP_UNDEFINED:
      return;
    default:
d1701 2
a1702 7
  seg_info (now_seg)->tc_segment_info_data.mapstate = state;

  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (symbolP);
  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;

  switch (state)
d1704 8
a1711 5
    case MAP_ARM:
      THUMB_SET_FUNC (symbolP, 0);
      ARM_SET_THUMB (symbolP, 0);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
d1713 7
a1719 13
    case MAP_THUMB:
      THUMB_SET_FUNC (symbolP, 1);
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;

    case MAP_DATA:
    default:
      return;
    }
}
#else
#define mapping_state(x) /* nothing */
d1721 1
d1723 5
a1727 1
/* Find the real, Thumb encoded start of a Thumb function.  */
d1729 1
a1729 6
static symbolS *
find_real_start (symbolS * symbolP)
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;
d1731 1
a1731 2
  /* This definition must agree with the one in gcc/config/arm/thumb.c.	 */
#define STUB_NAME ".real_start_of"
d1733 4
a1736 2
  if (name == NULL)
    abort ();
d1738 1
a1738 5
  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.	*/
  if (name[0] == '.')
    return symbolP;
d1740 1
a1740 2
  real_start = malloc (strlen (name) + strlen (STUB_NAME) + 1);
  sprintf (real_start, "%s%s", STUB_NAME, name);
d1742 1
a1742 1
  new_target = symbol_find (real_start);
d1744 5
a1748 50
  if (new_target == NULL)
    {
      as_warn ("Failed to find real start of function: %s\n", name);
      new_target = symbolP;
    }

  free (real_start);

  return new_target;
}

static void
opcode_select (int width)
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
	{
	  if (! (cpu_variant & ARM_EXT_V4T))
	    as_bad (_("selected processor does not support THUMB opcodes"));

	  thumb_mode = 1;
	  thumb32_mode = FALSE;
	  /* No need to force the alignment, since we will have been
	     coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_THUMB);
      break;

    case 32:
      if (thumb_mode)
	{
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
	    as_bad (_("selected processor does not support ARM opcodes"));

	  thumb_mode = 0;

	  if (!need_pass_2)
	    frag_align (2, 0, 0);

	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_ARM);
      break;

    default:
      as_bad (_("invalid instruction size selected (%d)"), width);
    }
a1765 10
s_thumb32 (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (16);
  if (! (cpu_variant & ARM_EXT_V6T2))
    as_bad (_("selected processor does not support 32-bit Thumb opcodes"));
  thumb32_mode = TRUE;
  demand_empty_rest_of_line ();
}

static void
d1784 1
a1784 1
s_force_thumb (int ignore ATTRIBUTE_UNUSED)
d1786 1
a1786 9
  /* If we are not already in thumb mode go into it, EVEN if
     the target processor does not support thumb instructions.
     This is used by gcc/config/arm/lib1funcs.asm for example
     to compile interworking support functions even if the
     target processor should not support interworking.	*/
  if (! thumb_mode)
    {
      thumb_mode = 2;
      thumb32_mode = FALSE;
d1788 2
a1789 4
      record_alignment (now_seg, 1);
    }

  demand_empty_rest_of_line ();
d1792 2
a1793 2
static void
s_thumb_func (int ignore ATTRIBUTE_UNUSED)
d1795 9
a1803 1
  s_thumb (0);
d1805 5
a1809 3
  /* The following label is the name/address of the start of a Thumb function.
     We need to know this for the interworking support.	 */
  label_is_thumb_function_name = TRUE;
d1812 4
a1815 2
static void
s_thumb32_func (int ignore ATTRIBUTE_UNUSED)
d1817 2
a1818 1
  s_thumb32 (0);
d1820 8
a1827 3
  /* The following label is the name/address of the start of a Thumb function.
     We need to know this for the interworking support.	 */
  label_is_thumb_function_name = TRUE;
d1830 1
a1830 2
/* Perform a .set directive, but also mark the alias as
   being a thumb function.  */
d1832 2
a1833 2
static void
s_thumb_set (int equiv)
d1835 2
a1836 7
  /* XXX the following is a duplicate of the code for s_set() in read.c
     We cannot just call that code as we need to get at the symbol that
     is created.  */
  char *    name;
  char	    delim;
  char *    end_name;
  symbolS * symbolP;
d1838 5
a1842 7
  /* Especial apologies for the random logic:
     This just grew, and could be parsed much more simply!
     Dean - in haste.  */
  name	    = input_line_pointer;
  delim	    = get_symbol_end ();
  end_name  = input_line_pointer;
  *end_name = delim;
d1844 1
a1844 1
  if (*input_line_pointer != ',')
d1846 4
a1849 5
      *end_name = 0;
      as_bad (_("expected comma after name \"%s\""), name);
      *end_name = delim;
      ignore_rest_of_line ();
      return;
d1852 13
a1864 2
  input_line_pointer++;
  *end_name = 0;
d1866 8
a1873 1
  if (name[0] == '.' && name[1] == '\0')
d1875 4
a1878 2
      /* XXX - this should not happen to .thumb_set.  */
      abort ();
d1881 4
a1884 11
  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
	 for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct * listing_tail;
	  fragS * dummy_frag = xmalloc (sizeof (fragS));
d1886 4
a1889 9
	  memset (dummy_frag, 0, sizeof (fragS));
	  dummy_frag->fr_type = rs_fill;
	  dummy_frag->line = listing_tail;
	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
	  dummy_frag->fr_symbol = symbolP;
	}
      else
#endif
	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
d1891 6
a1896 5
#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF  */
    }				/* Make a new symbol.  */
d1898 6
a1903 1
  symbol_table_insert (symbolP);
d1905 2
a1906 1
  * end_name = delim;
d1908 4
a1911 4
  if (equiv
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
d1913 2
a1914 1
  pseudo_set (symbolP);
d1916 5
a1920 1
  demand_empty_rest_of_line ();
d1922 40
a1961 1
  /* XXX Now we come to the Thumb specific bit of code.	 */
d1963 1
a1963 5
  THUMB_SET_FUNC (symbolP, 1);
  ARM_SET_THUMB (symbolP, 1);
#if defined OBJ_ELF || defined OBJ_COFF
  ARM_SET_INTERWORK (symbolP, support_interwork);
#endif
d1966 7
a1972 1
/* Directives: sectioning and alignment.  */
d1974 1
a1974 1
/* Same as s_align_ptwo but align 0 => align 2.	 */
d1976 2
a1977 11
static void
s_align (int unused ATTRIBUTE_UNUSED)
{
  int temp;
  long temp_fill;
  long max_alignment = 15;

  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad (_("alignment too large: %d assumed"), temp = max_alignment);
  else if (temp < 0)
d1979 1
a1979 2
      as_bad (_("alignment negative. 0 assumed."));
      temp = 0;
d1981 11
d1993 2
a1994 7
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
    }
  else
    temp_fill = 0;
d1996 2
a1997 2
  if (!temp)
    temp = 2;
d1999 3
a2001 4
  /* Only make a frag if we HAVE to.  */
  if (temp && !need_pass_2)
    frag_align (temp, (int) temp_fill, 0);
  demand_empty_rest_of_line ();
d2003 1
a2003 1
  record_alignment (now_seg, temp);
d2006 4
a2009 2
static void
s_bss (int ignore ATTRIBUTE_UNUSED)
d2011 24
a2034 5
  /* We don't support putting frags in the BSS segment, we fake it by
     marking in_bss, then looking at s_skip for clues.	*/
  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
  mapping_state (MAP_DATA);
d2037 2
a2038 2
static void
s_even (int ignore ATTRIBUTE_UNUSED)
d2040 13
a2052 3
  /* Never make frag if expect extra pass.  */
  if (!need_pass_2)
    frag_align (1, 0, 0);
d2054 20
a2073 1
  record_alignment (now_seg, 1);
d2075 2
a2076 1
  demand_empty_rest_of_line ();
d2079 8
a2086 1
/* Directives: Literal pools.  */
d2088 7
a2094 4
static literal_pool *
find_literal_pool (void)
{
  literal_pool * pool;
d2096 1
a2096 1
  for (pool = list_of_pools; pool != NULL; pool = pool->next)
d2098 2
a2099 3
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
d2102 2
a2103 1
  return pool;
d2106 2
a2107 2
static literal_pool *
find_or_make_literal_pool (void)
d2109 2
a2110 3
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;
d2112 5
a2116 1
  pool = find_literal_pool ();
d2118 3
a2120 6
  if (pool == NULL)
    {
      /* Create a new pool.  */
      pool = xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;
d2122 4
a2125 5
      pool->next_free_entry = 0;
      pool->section	    = now_seg;
      pool->sub_section	    = now_subseg;
      pool->next	    = list_of_pools;
      pool->symbol	    = NULL;
d2127 5
a2131 3
      /* Add it to the list.  */
      list_of_pools = pool;
    }
d2133 1
a2133 2
  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
d2135 2
a2136 3
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
d2139 7
a2145 2
  /* Done.  */
  return pool;
a2147 3
/* Add the literal in the global 'inst'
   structure to the relevent literal pool.  */

d2149 1
a2149 1
add_to_lit_pool (void)
d2151 1
a2151 2
  literal_pool * pool;
  unsigned int entry;
d2153 1
a2153 1
  pool = find_or_make_literal_pool ();
d2155 1
a2155 2
  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
d2157 5
a2161 7
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
	break;
d2163 2
a2164 10
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_symbol)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
	  && (pool->literals[entry].X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
	break;
    }
d2166 1
a2166 2
  /* Do we need to create a new entry?	*/
  if (entry == pool->next_free_entry)
d2168 9
a2176 1
      if (entry >= MAX_LITERAL_POOL_SIZE)
d2178 1
a2178 1
	  inst.error = _("literal pool overflow");
d2182 6
a2187 2
      pool->literals[entry] = inst.reloc.exp;
      pool->next_free_entry += 1;
d2189 2
a2190 4

  inst.reloc.exp.X_op	      = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4;
  inst.reloc.exp.X_add_symbol = pool->symbol;
d2195 6
a2200 2
/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */
d2202 3
a2204 9
static void
symbol_locate (symbolS *    symbolP,
	       const char * name,	/* It is copied, the caller can modify.	 */
	       segT	    segment,	/* Segment identifier (SEG_<something>).  */
	       valueT	    valu,	/* Symbol value.  */
	       fragS *	    frag)	/* Associated fragment.	 */
{
  unsigned int name_length;
  char * preserved_copy_of_name;
d2206 2
a2207 3
  name_length = strlen (name) + 1;   /* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = obstack_finish (&notes);
d2209 2
a2210 4
#ifdef tc_canonicalize_symbol_name
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
#endif
d2212 1
a2212 1
  S_SET_NAME (symbolP, preserved_copy_of_name);
d2214 3
a2216 3
  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);
d2218 1
a2218 1
  symbol_set_frag (symbolP, frag);
d2220 25
a2244 3
  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;
d2246 5
a2250 3
    if (symbol_table_frozen)
      abort ();
  }
d2252 9
a2260 1
  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);
d2262 2
a2263 1
  obj_symbol_new_hook (symbolP);
d2265 1
a2265 3
#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif
d2267 2
a2268 4
#ifdef DEBUG_SYMS
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS  */
}
d2270 3
d2274 5
a2278 6
static void
s_ltorg (int ignored ATTRIBUTE_UNUSED)
{
  unsigned int entry;
  literal_pool * pool;
  char sym_name[20];
d2280 1
a2280 5
  pool = find_literal_pool ();
  if (pool == NULL
      || pool->symbol == NULL
      || pool->next_free_entry == 0)
    return;
d2282 27
a2308 1
  mapping_state (MAP_DATA);
d2310 5
a2314 4
  /* Align pool as you have word accesses.
     Only make a frag if we have to.  */
  if (!need_pass_2)
    frag_align (2, 0, 0);
d2316 1
a2316 1
  record_alignment (now_seg, 2);
d2318 2
a2319 1
  sprintf (sym_name, "$$lit_\002%x", pool->id);
d2321 1
a2321 3
  symbol_locate (pool->symbol, sym_name, now_seg,
		 (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (pool->symbol);
d2323 5
a2327 1
  ARM_SET_THUMB (pool->symbol, thumb_mode);
d2329 1
a2329 3
#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (pool->symbol, support_interwork);
#endif
d2331 7
a2337 3
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    /* First output the expression in the instruction to the pool.  */
    emit_expr (&(pool->literals[entry]), 4); /* .word  */
d2339 9
a2347 4
  /* Mark the pool as empty.  */
  pool->next_free_entry = 0;
  pool->symbol = NULL;
}
d2349 6
a2354 8
#ifdef OBJ_ELF
/* Forward declarations for functions below, in the MD interface
   section.  */
static void fix_new_arm (fragS *, int, short, expressionS *, int, int);
static valueT create_unwind_entry (int);
static void start_unwind_section (const segT, int);
static void add_unwind_opcode (valueT, int);
static void flush_pending_unwind (void);
d2356 4
a2359 1
/* Directives: Data.  */
d2361 2
a2362 2
static void
s_arm_elf_cons (int nbytes)
d2364 1
a2364 1
  expressionS exp;
d2366 1
a2366 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
d2368 1
a2368 1
  if (is_it_end_of_statement ())
d2370 2
a2371 2
      demand_empty_rest_of_line ();
      return;
d2374 4
a2377 3
#ifdef md_cons_align
  md_cons_align (nbytes);
#endif
d2379 1
a2379 2
  mapping_state (MAP_DATA);
  do
d2381 1
a2381 2
      int reloc;
      char *base = input_line_pointer;
d2383 5
a2387 1
      expression (& exp);
d2389 2
a2390 2
      if (exp.X_op != O_symbol)
	emit_expr (&exp, (unsigned int) nbytes);
d2392 1
a2392 15
	{
	  char *before_reloc = input_line_pointer;
	  reloc = parse_reloc (&input_line_pointer);
	  if (reloc == -1)
	    {
	      as_bad (_("unrecognized relocation suffix"));
	      ignore_rest_of_line ();
	      return;
	    }
	  else if (reloc == BFD_RELOC_UNUSED)
	    emit_expr (&exp, (unsigned int) nbytes);
	  else
	    {
	      reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, reloc);
	      int size = bfd_get_reloc_size (howto);
d2394 1
a2394 27
	      if (size > nbytes)
		as_bad ("%s relocations do not fit in %d bytes",
			howto->name, nbytes);
	      else
		{
		  /* We've parsed an expression stopping at O_symbol.
		     But there may be more expression left now that we
		     have parsed the relocation marker.  Parse it again.
		     XXX Surely there is a cleaner way to do this.  */
		  char *p = input_line_pointer;
		  int offset;
		  char *save_buf = alloca (input_line_pointer - base);
		  memcpy (save_buf, base, input_line_pointer - base);
		  memmove (base + (input_line_pointer - before_reloc),
			   base, before_reloc - base);

		  input_line_pointer = base + (input_line_pointer-before_reloc);
		  expression (&exp);
		  memcpy (base, save_buf, p - base);

		  offset = nbytes - size;
		  p = frag_more ((int) nbytes);
		  fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
			       size, &exp, 0, reloc);
		}
	    }
	}
d2396 2
a2397 1
  while (*input_line_pointer++ == ',');
d2399 1
a2399 3
  /* Put terminator back into stream.  */
  input_line_pointer --;
  demand_empty_rest_of_line ();
d2402 2
a2403 5

/* Parse a .rel31 directive.  */

static void
s_arm_rel31 (int ignored ATTRIBUTE_UNUSED)
d2405 3
a2407 3
  expressionS exp;
  char *p;
  valueT highbit;
d2409 3
a2411 5
  highbit = 0;
  if (*input_line_pointer == '1')
    highbit = 0x80000000;
  else if (*input_line_pointer != '0')
    as_bad (_("expected 0 or 1"));
d2413 2
a2414 4
  input_line_pointer++;
  if (*input_line_pointer != ',')
    as_bad (_("missing comma"));
  input_line_pointer++;
d2416 2
a2417 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
d2419 1
a2419 3
#ifdef md_cons_align
  md_cons_align (4);
#endif
d2421 63
a2483 1
  mapping_state (MAP_DATA);
d2485 6
a2490 1
  expression (&exp);
d2492 3
a2494 6
  p = frag_more (4);
  md_number_to_chars (p, highbit, 4);
  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 1,
	       BFD_RELOC_ARM_PREL31);

  demand_empty_rest_of_line ();
a2496 4
/* Directives: AEABI stack-unwind tables.  */

/* Parse an unwind_fnstart directive.  Simply records the current location.  */

d2498 1
a2498 1
s_arm_unwind_fnstart (int ignored ATTRIBUTE_UNUSED)
d2500 15
a2514 3
  demand_empty_rest_of_line ();
  /* Mark the start of the function.  */
  unwind.proc_start = expr_build_dot ();
d2516 7
a2522 11
  /* Reset the rest of the unwind info.	 */
  unwind.opcode_count = 0;
  unwind.table_entry = NULL;
  unwind.personality_routine = NULL;
  unwind.personality_index = -1;
  unwind.frame_size = 0;
  unwind.fp_offset = 0;
  unwind.fp_reg = 13;
  unwind.fp_used = 0;
  unwind.sp_restored = 0;
}
d2524 4
d2529 2
a2530 2
/* Parse a handlerdata directive.  Creates the exception handling table entry
   for the function.  */
d2533 1
a2533 1
s_arm_unwind_handlerdata (int ignored ATTRIBUTE_UNUSED)
d2535 2
a2536 5
  demand_empty_rest_of_line ();
  if (unwind.table_entry)
    as_bad (_("dupicate .handlerdata directive"));

  create_unwind_entry (1);
a2538 2
/* Parse an unwind_fnend directive.  Generates the index table entry.  */

d2540 1
a2540 1
s_arm_unwind_fnend (int ignored ATTRIBUTE_UNUSED)
d2542 4
a2545 3
  long where;
  char *ptr;
  valueT val;
d2547 5
a2551 1
  demand_empty_rest_of_line ();
d2553 5
a2557 5
  /* Add eh table entry.  */
  if (unwind.table_entry == NULL)
    val = create_unwind_entry (0);
  else
    val = 0;
d2559 1
a2559 4
  /* Add index table entry.  This is two words.	 */
  start_unwind_section (unwind.saved_seg, 1);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
d2561 12
a2572 11
  ptr = frag_more (8);
  where = frag_now_fix () - 8;

  /* Self relative offset of the function start.  */
  fix_new (frag_now, where, 4, unwind.proc_start, 0, 1,
	   BFD_RELOC_ARM_PREL31);

  /* Indicate dependency on EHABI-defined personality routines to the
     linker, if it hasn't been done already.  */
  if (unwind.personality_index >= 0 && unwind.personality_index < 3
      && !(marked_pr_dependency & (1 << unwind.personality_index)))
d2574 2
a2575 10
      static const char *const name[] = {
	"__aeabi_unwind_cpp_pr0",
	"__aeabi_unwind_cpp_pr1",
	"__aeabi_unwind_cpp_pr2"
      };
      symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
      fix_new (frag_now, where, 0, pr, 0, 1, BFD_RELOC_NONE);
      marked_pr_dependency |= 1 << unwind.personality_index;
      seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency
	= marked_pr_dependency;
d2578 3
a2580 7
  if (val)
    /* Inline exception table entry.  */
    md_number_to_chars (ptr + 4, val, 4);
  else
    /* Self relative offset of the table entry.	 */
    fix_new (frag_now, where + 4, 4, unwind.table_entry, 0, 1,
	     BFD_RELOC_ARM_PREL31);
d2582 1
a2582 2
  /* Restore the original section.  */
  subseg_set (unwind.saved_seg, unwind.saved_subseg);
d2585 3
a2587 2

/* Parse an unwind_cantunwind directive.  */
d2590 1
a2590 1
s_arm_unwind_cantunwind (int ignored ATTRIBUTE_UNUSED)
d2592 1
a2592 3
  demand_empty_rest_of_line ();
  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("personality routine specified for cantunwind frame"));
d2594 2
a2595 2
  unwind.personality_index = -2;
}
d2597 5
d2603 1
a2603 1
/* Parse a personalityindex directive.	*/
d2605 6
a2610 4
static void
s_arm_unwind_personalityindex (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
d2612 6
a2617 2
  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personalityindex directive"));
d2619 2
a2620 1
  expression (&exp);
d2622 1
a2622 2
  if (exp.X_op != O_constant
      || exp.X_add_number < 0 || exp.X_add_number > 15)
d2624 2
a2625 2
      as_bad (_("bad personality routine number"));
      ignore_rest_of_line ();
d2629 1
a2629 1
  unwind.personality_index = exp.X_add_number;
d2631 8
a2638 2
  demand_empty_rest_of_line ();
}
d2640 5
d2646 2
a2647 9
/* Parse a personality directive.  */

static void
s_arm_unwind_personality (int ignored ATTRIBUTE_UNUSED)
{
  char *name, *p, c;

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personality directive"));
d2649 2
a2650 6
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  unwind.personality_routine = symbol_find_or_make (name);
  *p = c;
  demand_empty_rest_of_line ();
d2653 5
a2657 2

/* Parse a directive saving core registers.  */
d2660 1
a2660 1
s_arm_unwind_save_core (void)
d2662 4
a2665 3
  valueT op;
  long range;
  int n;
d2667 1
a2667 2
  range = parse_reg_list (&input_line_pointer);
  if (range == FAIL)
d2669 1
a2669 2
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
d2673 2
a2674 7
  demand_empty_rest_of_line ();

  /* Turn .unwind_movsp ip followed by .unwind_save {..., ip, ...}
     into .unwind_save {..., sp...}.  We aren't bothered about the value of
     ip because it is clobbered by calls.  */
  if (unwind.sp_restored && unwind.fp_reg == 12
      && (range & 0x3000) == 0x1000)
d2676 2
a2677 4
      unwind.opcode_count--;
      unwind.sp_restored = 0;
      range = (range | 0x2000) & ~0x1000;
      unwind.pending_offset = 0;
d2680 2
a2681 3
  /* See if we can use the short opcodes.  These pop a block of upto 8
     registers starting with r4, plus maybe r14.  */
  for (n = 0; n < 8; n++)
d2683 2
a2684 3
      /* Break at the first non-saved register.	 */
      if ((range & (1 << (n + 4))) == 0)
	break;
d2686 7
a2692 2
  /* See if there are any other bits set.  */
  if (n == 0 || (range & (0xfff0 << n) & 0xbff0) != 0)
d2694 2
a2695 13
      /* Use the long form.  */
      op = 0x8000 | ((range >> 4) & 0xfff);
      add_unwind_opcode (op, 2);
    }
  else
    {
      /* Use the short form.  */
      if (range & 0x4000)
	op = 0xa8; /* Pop r14.	*/
      else
	op = 0xa0; /* Do not pop r14.  */
      op |= (n - 1);
      add_unwind_opcode (op, 1);
d2698 1
a2698 2
  /* Pop r0-r3.	 */
  if (range & 0xf)
d2700 2
a2701 2
      op = 0xb100 | (range & 0xf);
      add_unwind_opcode (op, 2);
d2704 1
a2704 6
  /* Record the number of bytes pushed.	 */
  for (n = 0; n < 16; n++)
    {
      if (range & (1 << n))
	unwind.frame_size += 4;
    }
a2706 3

/* Parse a directive saving FPA registers.  */

d2708 1
a2708 1
s_arm_unwind_save_fpa (int reg)
d2710 4
a2713 3
  expressionS exp;
  int num_regs;
  valueT op;
d2715 5
a2719 5
  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    expression (&exp);
  else
    exp.X_op = O_illegal;
d2721 1
a2721 1
  if (exp.X_op != O_constant)
d2723 1
a2723 2
      as_bad (_("expected , <constant>"));
      ignore_rest_of_line ();
d2727 6
a2732 1
  num_regs = exp.X_add_number;
d2734 1
a2734 1
  if (num_regs < 1 || num_regs > 4)
d2736 1
a2736 2
      as_bad (_("number of registers must be in the range [1:4]"));
      ignore_rest_of_line ();
d2740 2
a2741 1
  demand_empty_rest_of_line ();
d2743 2
a2744 1
  if (reg == 4)
d2746 2
a2747 3
      /* Short form.  */
      op = 0xb4 | (num_regs - 1);
      add_unwind_opcode (op, 1);
d2749 2
a2750 1
  else
d2752 2
a2753 3
      /* Long form.  */
      op = 0xc800 | (reg << 4) | (num_regs - 1);
      add_unwind_opcode (op, 2);
d2755 2
a2756 1
  unwind.frame_size += num_regs * 12;
d2759 13
d2773 5
a2777 1
/* Parse a directive saving VFP registers.  */
d2779 6
a2784 6
static void
s_arm_unwind_save_vfp (void)
{
  int count;
  int reg;
  valueT op;
d2786 1
a2786 2
  count = parse_vfp_reg_list (&input_line_pointer, &reg, 1);
  if (count == FAIL)
d2788 1
a2788 2
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
d2792 4
a2795 1
  demand_empty_rest_of_line ();
d2797 4
a2800 1
  if (reg == 8)
d2802 2
a2803 3
      /* Short form.  */
      op = 0xb8 | (count - 1);
      add_unwind_opcode (op, 1);
d2805 2
a2806 1
  else
d2808 2
a2809 3
      /* Long form.  */
      op = 0xb300 | (reg << 4) | (count - 1);
      add_unwind_opcode (op, 2);
d2811 2
a2812 1
  unwind.frame_size += count * 8 + 4;
d2815 5
a2819 2

/* Parse a directive saving iWMMXt data registers.  */
d2822 1
a2822 1
s_arm_unwind_save_mmxwr (void)
d2824 9
a2832 5
  int reg;
  int hi_reg;
  int i;
  unsigned mask = 0;
  valueT op;
d2834 7
a2840 2
  if (*input_line_pointer == '{')
    input_line_pointer++;
d2842 1
a2842 3
  do
    {
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
d2844 4
a2847 5
      if (reg == FAIL)
	{
	  as_bad (_(reg_expected_msgs[REG_TYPE_MMXWR]));
	  goto error;
	}
d2849 1
a2849 3
      if (mask >> reg)
	as_tsktsk (_("register list not in ascending order"));
      mask |= 1 << reg;
d2851 26
a2876 1
      if (*input_line_pointer == '-')
d2878 3
a2880 3
	  input_line_pointer++;
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
	  if (hi_reg == FAIL)
d2882 2
a2883 2
	      as_bad (_(reg_expected_msgs[REG_TYPE_MMXWR]));
	      goto error;
d2885 2
a2886 1
	  else if (reg >= hi_reg)
d2888 2
a2889 2
	      as_bad (_("bad register range"));
	      goto error;
d2891 11
a2901 2
	  for (; reg < hi_reg; reg++)
	    mask |= 1 << reg;
d2903 16
d2920 6
a2925 1
  while (skip_past_comma (&input_line_pointer) != FAIL);
d2927 1
a2927 2
  if (*input_line_pointer == '}')
    input_line_pointer++;
d2929 6
a2934 1
  demand_empty_rest_of_line ();
d2936 1
a2936 3
  /* Generate any deferred opcodes becuuse we're going to be looking at
     the list.	*/
  flush_pending_unwind ();
d2938 1
a2938 1
  for (i = 0; i < 16; i++)
d2940 8
a2947 3
      if (mask & (1 << i))
	unwind.frame_size += 8;
    }
d2949 1
a2949 7
  /* Attempt to combine with a previous opcode.	 We do this because gcc
     likes to output separate unwind directives for a single block of
     registers.	 */
  if (unwind.opcode_count > 0)
    {
      i = unwind.opcodes[unwind.opcode_count - 1];
      if ((i & 0xf8) == 0xc0)
d2951 3
a2953 3
	  i &= 7;
	  /* Only merge if the blocks are contiguous.  */
	  if (i < 6)
d2955 3
a2957 5
	      if ((mask & 0xfe00) == (1 << 9))
		{
		  mask |= ((1 << (i + 11)) - 1) & 0xfc00;
		  unwind.opcode_count--;
		}
d2959 1
a2959 1
	  else if (i == 6 && unwind.opcode_count >= 2)
d2961 3
a2963 7
	      i = unwind.opcodes[unwind.opcode_count - 2];
	      reg = i >> 4;
	      i &= 0xf;

	      op = 0xffff << (reg - 1);
	      if (reg > 0
		  || ((mask & op) == (1u << (reg - 1))))
d2965 2
a2966 4
		  op = (1 << (reg + i + 1)) - 1;
		  op &= ~((1 << reg) - 1);
		  mask |= op;
		  unwind.opcode_count -= 2;
d2968 3
d2973 3
a2975 14
    }

  hi_reg = 15;
  /* We want to generate opcodes in the order the registers have been
     saved, ie. descending order.  */
  for (reg = 15; reg >= -1; reg--)
    {
      /* Save registers in blocks.  */
      if (reg < 0
	  || !(mask & (1 << reg)))
	{
	  /* We found an unsaved reg.  Generate opcodes to save the
	     preceeding block.	*/
	  if (reg != hi_reg)
d2977 2
a2978 12
	      if (reg == 9)
		{
		  /* Short form.  */
		  op = 0xc0 | (hi_reg - 10);
		  add_unwind_opcode (op, 1);
		}
	      else
		{
		  /* Long form.	 */
		  op = 0xc600 | ((reg + 1) << 4) | ((hi_reg - reg) - 1);
		  add_unwind_opcode (op, 2);
		}
a2979 3
	  hi_reg = reg - 1;
	}
    }
d2981 1
a2981 4
  return;
error:
  ignore_rest_of_line ();
}
d2983 2
a2984 7
static void
s_arm_unwind_save_mmxwcg (void)
{
  int reg;
  int hi_reg;
  unsigned mask = 0;
  valueT op;
d2986 1
a2986 2
  if (*input_line_pointer == '{')
    input_line_pointer++;
d2988 5
a2992 9
  do
    {
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);

      if (reg == FAIL)
	{
	  as_bad (_(reg_expected_msgs[REG_TYPE_MMXWCG]));
	  goto error;
	}
d2994 1
a2994 4
      reg -= 8;
      if (mask >> reg)
	as_tsktsk (_("register list not in ascending order"));
      mask |= 1 << reg;
d2996 1
a2996 10
      if (*input_line_pointer == '-')
	{
	  input_line_pointer++;
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
	  if (hi_reg == FAIL)
	    {
	      as_bad (_(reg_expected_msgs[REG_TYPE_MMXWCG]));
	      goto error;
	    }
	  else if (reg >= hi_reg)
d2998 2
a2999 2
	      as_bad (_("bad register range"));
	      goto error;
a3000 2
	  for (; reg < hi_reg; reg++)
	    mask |= 1 << reg;
d3003 8
a3010 1
  while (skip_past_comma (&input_line_pointer) != FAIL);
d3012 5
a3016 2
  if (*input_line_pointer == '}')
    input_line_pointer++;
d3018 3
a3020 1
  demand_empty_rest_of_line ();
d3022 2
a3023 3
  /* Generate any deferred opcodes becuuse we're going to be looking at
     the list.	*/
  flush_pending_unwind ();
d3025 1
a3025 10
  for (reg = 0; reg < 16; reg++)
    {
      if (mask & (1 << reg))
	unwind.frame_size += 4;
    }
  op = 0xc700 | mask;
  add_unwind_opcode (op, 2);
  return;
error:
  ignore_rest_of_line ();
d3028 4
a3031 2

/* Parse an unwind_save directive.  */
d3034 1
a3034 1
s_arm_unwind_save (int ignored ATTRIBUTE_UNUSED)
d3036 19
a3054 3
  char *peek;
  struct reg_entry *reg;
  bfd_boolean had_brace = FALSE;
d3056 4
a3059 2
  /* Figure out what sort of save we have.  */
  peek = input_line_pointer;
d3061 4
a3064 5
  if (*peek == '{')
    {
      had_brace = TRUE;
      peek++;
    }
d3066 1
a3066 1
  reg = arm_reg_parse_multi (&peek);
d3068 7
a3074 1
  if (!reg)
d3076 1
a3076 2
      as_bad (_("register expected"));
      ignore_rest_of_line ();
d3080 1
a3080 1
  switch (reg->type)
d3082 1
a3082 8
    case REG_TYPE_FN:
      if (had_brace)
	{
	  as_bad (_("FPA .unwind_save does not take a register list"));
	  ignore_rest_of_line ();
	  return;
	}
      s_arm_unwind_save_fpa (reg->number);
d3084 1
d3086 2
a3087 4
    case REG_TYPE_RN:	  s_arm_unwind_save_core ();   return;
    case REG_TYPE_VFD:	   s_arm_unwind_save_vfp ();	return;
    case REG_TYPE_MMXWR:  s_arm_unwind_save_mmxwr ();  return;
    case REG_TYPE_MMXWCG: s_arm_unwind_save_mmxwcg (); return;
d3089 1
a3089 4
    default:
      as_bad (_(".unwind_save does not support this kind of register"));
      ignore_rest_of_line ();
    }
d3092 3
a3094 2

/* Parse an unwind_movsp directive.  */
d3097 1
a3097 1
s_arm_unwind_movsp (int ignored ATTRIBUTE_UNUSED)
d3099 1
a3099 2
  int reg;
  valueT op;
d3101 1
a3101 14
  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
  if (reg == FAIL)
    {
      as_bad (_(reg_expected_msgs[REG_TYPE_RN]));
      ignore_rest_of_line ();
      return;
    }
  demand_empty_rest_of_line ();

  if (reg == REG_SP || reg == REG_PC)
    {
      as_bad (_("SP and PC not permitted in .unwind_movsp directive"));
      return;
    }
d3103 6
a3108 2
  if (unwind.fp_reg != REG_SP)
    as_bad (_("unexpected .unwind_movsp directive"));
d3110 2
a3111 3
  /* Generate opcode to restore the value.  */
  op = 0x90 | reg;
  add_unwind_opcode (op, 1);
d3113 2
a3114 4
  /* Record the information for later.	*/
  unwind.fp_reg = reg;
  unwind.fp_offset = unwind.frame_size;
  unwind.sp_restored = 1;
d3117 3
a3119 1
/* Parse an unwind_pad directive.  */
d3122 1
a3122 1
s_arm_unwind_pad (int ignored ATTRIBUTE_UNUSED)
d3124 1
a3124 1
  int offset;
d3126 1
a3126 2
  if (immediate_for_directive (&offset) == FAIL)
    return;
d3128 6
a3133 6
  if (offset & 3)
    {
      as_bad (_("stack increment must be multiple of 4"));
      ignore_rest_of_line ();
      return;
    }
d3135 2
a3136 3
  /* Don't generate any opcodes, just record the details for later.  */
  unwind.frame_size += offset;
  unwind.pending_offset += offset;
d3138 2
a3139 1
  demand_empty_rest_of_line ();
d3142 8
a3149 1
/* Parse an unwind_setfp directive.  */
d3152 1
a3152 1
s_arm_unwind_setfp (int ignored ATTRIBUTE_UNUSED)
d3154 10
a3163 3
  int sp_reg;
  int fp_reg;
  int offset;
d3165 7
a3171 5
  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
  if (skip_past_comma (&input_line_pointer) == FAIL)
    sp_reg = FAIL;
  else
    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
d3173 2
a3174 1
  if (fp_reg == FAIL || sp_reg == FAIL)
d3176 2
a3177 2
      as_bad (_("expected <reg>, <reg>"));
      ignore_rest_of_line ();
d3181 2
a3182 2
  /* Optional constant.	 */
  if (skip_past_comma (&input_line_pointer) != FAIL)
d3184 3
a3186 2
      if (immediate_for_directive (&offset) == FAIL)
	return;
a3187 2
  else
    offset = 0;
d3189 4
a3192 1
  demand_empty_rest_of_line ();
d3194 2
a3195 1
  if (sp_reg != 13 && sp_reg != unwind.fp_reg)
d3197 2
a3198 2
      as_bad (_("register must be either sp or set by a previous"
		"unwind_movsp directive"));
d3202 23
a3224 5
  /* Don't generate any opcodes, just record the information for later.	 */
  unwind.fp_reg = fp_reg;
  unwind.fp_used = 1;
  if (sp_reg == 13)
    unwind.fp_offset = unwind.frame_size - offset;
d3226 1
a3226 1
    unwind.fp_offset -= offset;
d3229 5
a3233 1
/* Parse an unwind_raw directive.  */
d3236 1
a3236 1
s_arm_unwind_raw (int ignored ATTRIBUTE_UNUSED)
d3238 1
a3238 4
  expressionS exp;
  /* This is an arbitary limit.	 */
  unsigned char op[16];
  int count;
d3240 13
a3252 3
  expression (&exp);
  if (exp.X_op == O_constant
      && skip_past_comma (&input_line_pointer) != FAIL)
d3254 2
a3255 2
      unwind.frame_size += exp.X_add_number;
      expression (&exp);
d3258 35
a3292 1
    exp.X_op = O_illegal;
d3294 2
a3295 1
  if (exp.X_op != O_constant)
d3297 2
a3298 2
      as_bad (_("expected <offset>, <opcode>"));
      ignore_rest_of_line ();
d3302 7
a3308 1
  count = 0;
d3310 1
a3310 2
  /* Parse the opcode.	*/
  for (;;)
d3312 1
a3312 1
      if (count >= 16)
d3314 2
a3315 7
	  as_bad (_("unwind opcode too long"));
	  ignore_rest_of_line ();
	}
      if (exp.X_op != O_constant || exp.X_add_number & ~0xff)
	{
	  as_bad (_("invalid unwind opcode"));
	  ignore_rest_of_line ();
a3317 7
      op[count++] = exp.X_add_number;

      /* Parse the next byte.  */
      if (skip_past_comma (&input_line_pointer) == FAIL)
	break;

      expression (&exp);
d3320 1
a3320 5
  /* Add the opcode bytes in reverse order.  */
  while (count--)
    add_unwind_opcode (op[count], 1);

  demand_empty_rest_of_line ();
a3321 1
#endif /* OBJ_ELF */
d3323 5
a3327 5
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */
d3329 2
a3330 1
const pseudo_typeS md_pseudo_table[] =
d3332 1
a3332 41
  /* Never called because '.req' does not start a line.	 */
  { "req",	   s_req,	  0 },
  { "unreq",	   s_unreq,	  0 },
  { "bss",	   s_bss,	  0 },
  { "align",	   s_align,	  0 },
  { "arm",	   s_arm,	  0 },
  { "thumb",	   s_thumb,	  0 },
  { "thumb32",     s_thumb32,	  0 },
  { "code",	   s_code,	  0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb32_func",s_thumb32_func,0 },
  { "thumb_set",   s_thumb_set,	  0 },
  { "even",	   s_even,	  0 },
  { "ltorg",	   s_ltorg,	  0 },
  { "pool",	   s_ltorg,	  0 },
#ifdef OBJ_ELF
  { "word",	   s_arm_elf_cons, 4 },
  { "long",	   s_arm_elf_cons, 4 },
  { "rel31",	   s_arm_rel31,	  0 },
  { "fnstart",		s_arm_unwind_fnstart,	0 },
  { "fnend",		s_arm_unwind_fnend,	0 },
  { "cantunwind",	s_arm_unwind_cantunwind, 0 },
  { "personality",	s_arm_unwind_personality, 0 },
  { "personalityindex",	s_arm_unwind_personalityindex, 0 },
  { "handlerdata",	s_arm_unwind_handlerdata, 0 },
  { "save",		s_arm_unwind_save,	0 },
  { "movsp",		s_arm_unwind_movsp,	0 },
  { "pad",		s_arm_unwind_pad,	0 },
  { "setfp",		s_arm_unwind_setfp,	0 },
  { "unwind_raw",	s_arm_unwind_raw,	0 },
#else
  { "word",	   cons, 4},
#endif
  { "extend",	   float_cons, 'x' },
  { "ldouble",	   float_cons, 'x' },
  { "packed",	   float_cons, 'p' },
  { 0, 0, 0 }
};

/* Parser functions used exclusively in instruction operands.  */
d3334 6
a3339 5
/* Generic immediate-value read function for use in insn parsing.
   STR points to the beginning of the immediate (the leading #);
   VAL receives the value; if the value is outside [MIN, MAX]
   issue an error.  PREFIX_OPT is true if the immediate prefix is
   optional.  */
d3341 2
a3342 7
static int
parse_immediate (char **str, int *val, int min, int max,
		 bfd_boolean prefix_opt)
{
  expressionS exp;
  my_get_expression (&exp, str, prefix_opt ? GE_OPT_PREFIX : GE_IMM_PREFIX);
  if (exp.X_op != O_constant)
d3344 3
a3346 2
      inst.error = _("constant expression required");
      return FAIL;
d3349 2
a3350 1
  if (exp.X_add_number < min || exp.X_add_number > max)
d3352 3
a3354 2
      inst.error = _("immediate value out of range");
      return FAIL;
d3357 2
a3358 20
  *val = exp.X_add_number;
  return SUCCESS;
}

/* Returns the pseudo-register number of an FPA immediate constant,
   or FAIL if there isn't a valid constant here.  */

static int
parse_fpa_immediate (char ** str)
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *	 save_in;
  expressionS	 exp;
  int		 i;
  int		 j;

  /* First try and match exact strings, this is to guarantee
     that some formats will work even for cross assembly.  */

  for (i = 0; fp_const[i]; i++)
d3360 3
a3362 9
      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
	{
	  char *start = *str;

	  *str += strlen (fp_const[i]);
	  if (is_end_of_line[(unsigned char) **str])
	    return i + 8;
	  *str = start;
	}
d3365 2
a3366 10
  /* Just because we didn't get a match doesn't mean that the constant
     isn't valid, just that it is in a format that we don't
     automatically recognize.  Try parsing it with the standard
     expression routines.  */

  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));

  /* Look for a raw floating point number.  */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && is_end_of_line[(unsigned char) *save_in])
d3368 3
a3370 14
      for (i = 0; i < NUM_FLOAT_VALS; i++)
	{
	  for (j = 0; j < MAX_LITTLENUMS; j++)
	    {
	      if (words[j] != fp_values[i][j])
		break;
	    }

	  if (j == MAX_LITTLENUMS)
	    {
	      *str = save_in;
	      return i + 8;
	    }
	}
d3373 1
a3373 7
  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f").  */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
d3375 1
a3375 3
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.	*/
      if (gen_to_words (words, 5, (long) 15) == 0)
d3377 3
a3379 15
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}

	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i + 8;
		}
	    }
d3383 1
a3383 4
  *str = input_line_pointer;
  input_line_pointer = save_in;
  inst.error = _("invalid FPA immediate expression");
  return FAIL;
d3386 2
a3387 2
/* Shift operands.  */
enum shift_kind
d3389 1
a3389 2
  SHIFT_LSL, SHIFT_LSR, SHIFT_ASR, SHIFT_ROR, SHIFT_RRX
};
d3391 1
a3391 5
struct asm_shift_name
{
  const char	  *name;
  enum shift_kind  kind;
};
d3393 5
a3397 9
/* Third argument to parse_shift.  */
enum parse_shift_mode
{
  NO_SHIFT_RESTRICT,		/* Any kind of shift is accepted.  */
  SHIFT_IMMEDIATE,		/* Shift operand must be an immediate.	*/
  SHIFT_LSL_OR_ASR_IMMEDIATE,	/* Shift must be LSL or ASR immediate.	*/
  SHIFT_ASR_IMMEDIATE,		/* Shift must be ASR immediate.	 */
  SHIFT_LSL_IMMEDIATE,		/* Shift must be LSL immediate.	 */
};
d3399 3
a3401 2
/* Parse a <shift> specifier on an ARM data processing instruction.
   This has three forms:
d3403 2
a3404 3
     (LSL|LSR|ASL|ASR|ROR) Rs
     (LSL|LSR|ASL|ASR|ROR) #imm
     RRX
d3406 1
a3406 2
   Note that ASL is assimilated to LSL in the instruction encoding, and
   RRX to ROR #0 (which cannot be written as such).  */
d3408 2
a3409 2
static int
parse_shift (char **str, int i, enum parse_shift_mode mode)
a3410 4
  const struct asm_shift_name *shift_name;
  enum shift_kind shift;
  char *s = *str;
  char *p = s;
d3413 1
a3413 2
  for (p = *str; ISALPHA (*p); p++)
    ;
d3415 1
a3415 1
  if (p == *str)
d3417 2
a3418 2
      inst.error = _("shift expression expected");
      return FAIL;
d3421 13
a3433 1
  shift_name = hash_find_n (arm_shift_hsh, *str, p - *str);
d3435 8
a3442 1
  if (shift_name == NULL)
d3444 2
a3445 2
      inst.error = _("shift expression expected");
      return FAIL;
d3448 1
a3448 3
  shift = shift_name->kind;

  switch (mode)
d3450 3
a3452 2
    case NO_SHIFT_RESTRICT:
    case SHIFT_IMMEDIATE:   break;
d3454 2
a3455 7
    case SHIFT_LSL_OR_ASR_IMMEDIATE:
      if (shift != SHIFT_LSL && shift != SHIFT_ASR)
	{
	  inst.error = _("'LSL' or 'ASR' required");
	  return FAIL;
	}
      break;
d3457 1
a3457 7
    case SHIFT_LSL_IMMEDIATE:
      if (shift != SHIFT_LSL)
	{
	  inst.error = _("'LSL' required");
	  return FAIL;
	}
      break;
d3459 4
a3462 7
    case SHIFT_ASR_IMMEDIATE:
      if (shift != SHIFT_ASR)
	{
	  inst.error = _("'ASR' required");
	  return FAIL;
	}
      break;
d3464 9
a3472 1
    default: abort ();
d3474 17
d3492 12
a3503 1
  if (shift != SHIFT_RRX)
d3505 2
a3506 11
      /* Whitespace can appear here if the next thing is a bare digit.	*/
      skip_whitespace (p);

      if (mode == NO_SHIFT_RESTRICT
	  && (reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	{
	  inst.operands[i].imm = reg;
	  inst.operands[i].immisreg = 1;
	}
      else if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	return FAIL;
d3508 1
a3508 5
  inst.operands[i].shift_kind = shift;
  inst.operands[i].shifted = 1;
  *str = p;
  return SUCCESS;
}
d3510 4
a3513 1
/* Parse a <shifter_operand> for an ARM data processing instruction:
d3515 2
a3516 4
      #<immediate>
      #<immediate>, <rotate>
      <Rm>
      <Rm>, <shift>
d3518 1
a3518 3
   where <shift> is defined by parse_shift above, and <rotate> is a
   multiple of 2 between 0 and 30.  Validation of immediate operands
   is deferred to md_apply_fix3.  */
d3521 1
a3521 1
parse_shifter_operand (char **str, int i)
d3523 3
a3525 2
  int value;
  expressionS expr;
d3527 1
a3527 4
  if ((value = arm_reg_parse (str, REG_TYPE_RN)) != FAIL)
    {
      inst.operands[i].reg = value;
      inst.operands[i].isreg = 1;
d3529 2
a3530 3
      /* parse_shift will override this if appropriate */
      inst.reloc.exp.X_op = O_constant;
      inst.reloc.exp.X_add_number = 0;
d3532 4
a3535 5
      if (skip_past_comma (str) == FAIL)
	return SUCCESS;

      /* Shift operation on register.  */
      return parse_shift (str, i, NO_SHIFT_RESTRICT);
d3538 4
a3541 2
  if (my_get_expression (&inst.reloc.exp, str, GE_IMM_PREFIX))
    return FAIL;
d3543 1
a3543 1
  if (skip_past_comma (str) == SUCCESS)
d3545 3
a3547 3
      /* #x, y -- ie explicit rotation by Y.  */
      if (my_get_expression (&expr, str, GE_NO_PREFIX))
	return FAIL;
d3549 1
a3549 5
      if (expr.X_op != O_constant || inst.reloc.exp.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return FAIL;
	}
d3551 19
a3569 11
      value = expr.X_add_number;
      if (value < 0 || value > 30 || value % 2 != 0)
	{
	  inst.error = _("invalid rotation");
	  return FAIL;
	}
      if (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 255)
	{
	  inst.error = _("invalid constant");
	  return FAIL;
	}
d3571 5
a3575 4
      /* Convert to decoded value.  md_apply_fix3 will put it back.  */
      inst.reloc.exp.X_add_number
	= (((inst.reloc.exp.X_add_number << (32 - value))
	    | (inst.reloc.exp.X_add_number >> value)) & 0xffffffff);
d3578 1
a3578 4
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
  inst.reloc.pc_rel = 0;
  return SUCCESS;
}
d3580 14
a3593 2
/* Parse all forms of an ARM address expression.  Information is written
   to inst.operands[i] and/or inst.reloc.
d3595 2
a3596 1
   Preindexed addressing (.preind=1):
d3598 2
a3599 4
   [Rn, #offset]       .reg=Rn .reloc.exp=offset
   [Rn, +/-Rm]	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
   [Rn, +/-Rm, shift]  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
		       .shift_kind=shift .reloc.exp=shift_imm
d3601 4
a3604 1
   These three may have a trailing ! which causes .writeback to be set also.
d3606 24
a3629 1
   Postindexed addressing (.postind=1, .writeback=1):
d3631 4
a3634 4
   [Rn], #offset       .reg=Rn .reloc.exp=offset
   [Rn], +/-Rm	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
   [Rn], +/-Rm, shift  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
		       .shift_kind=shift .reloc.exp=shift_imm
d3636 8
a3643 1
   Unindexed addressing (.preind=0, .postind=0):
d3645 3
a3647 1
   [Rn], {option}      .reg=Rn .imm=option .immisreg=0
d3649 5
a3653 1
   Other:
d3655 1
a3655 3
   [Rn]{!}	       shorthand for [Rn,#0]{!}
   =immediate	       .isreg=0 .reloc.exp=immediate
   label	       .reg=PC .reloc.pc_rel=1 .reloc.exp=label
d3657 12
a3668 2
  It is the caller's responsibility to check for addressing modes not
  supported by the instruction, and to set inst.reloc.type.  */
d3670 20
a3689 7
static int
parse_address (char **str, int i)
{
  char *p = *str;
  int reg;

  if (skip_past_char (&p, '[') == FAIL)
d3691 2
a3692 15
      if (skip_past_char (&p, '=') == FAIL)
	{
	  /* bare address - translate to PC-relative offset */
	  inst.reloc.pc_rel = 1;
	  inst.operands[i].reg = REG_PC;
	  inst.operands[i].isreg = 1;
	  inst.operands[i].preind = 1;
	}
      /* else a load-constant pseudo op, no special treatment needed here */

      if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
	return FAIL;

      *str = p;
      return SUCCESS;
d3694 2
a3695 2

  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
d3697 2
a3698 2
      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
      return FAIL;
a3699 2
  inst.operands[i].reg = reg;
  inst.operands[i].isreg = 1;
d3701 2
a3702 1
  if (skip_past_comma (&p) == SUCCESS)
d3704 2
a3705 24
      inst.operands[i].preind = 1;

      if (*p == '+') p++;
      else if (*p == '-') p++, inst.operands[i].negative = 1;

      if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	{
	  inst.operands[i].imm = reg;
	  inst.operands[i].immisreg = 1;

	  if (skip_past_comma (&p) == SUCCESS)
	    if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
	      return FAIL;
	}
      else
	{
	  if (inst.operands[i].negative)
	    {
	      inst.operands[i].negative = 0;
	      p--;
	    }
	  if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	    return FAIL;
	}
d3707 1
a3707 2

  if (skip_past_char (&p, ']') == FAIL)
d3709 2
a3710 2
      inst.error = _("']' expected");
      return FAIL;
d3713 12
a3724 2
  if (skip_past_char (&p, '!') == SUCCESS)
    inst.operands[i].writeback = 1;
d3726 1
a3726 8
  else if (skip_past_comma (&p) == SUCCESS)
    {
      if (skip_past_char (&p, '{') == SUCCESS)
	{
	  /* [Rn], {expr} - unindexed, with option */
	  if (parse_immediate (&p, &inst.operands[i].imm,
				       0, 255, TRUE) == FAIL)
	    return FAIL;
d3728 6
a3733 17
	  if (skip_past_char (&p, '}') == FAIL)
	    {
	      inst.error = _("'}' expected at end of 'option' field");
	      return FAIL;
	    }
	  if (inst.operands[i].preind)
	    {
	      inst.error = _("cannot combine index with option");
	      return FAIL;
	    }
	  *str = p;
	  return SUCCESS;
	}
      else
	{
	  inst.operands[i].postind = 1;
	  inst.operands[i].writeback = 1;
d3735 5
a3739 5
	  if (inst.operands[i].preind)
	    {
	      inst.error = _("cannot combine pre- and post-indexing");
	      return FAIL;
	    }
d3741 1
a3741 2
	  if (*p == '+') p++;
	  else if (*p == '-') p++, inst.operands[i].negative = 1;
d3743 12
a3754 4
	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	    {
	      inst.operands[i].imm = reg;
	      inst.operands[i].immisreg = 1;
d3756 29
a3784 15
	      if (skip_past_comma (&p) == SUCCESS)
		if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
		  return FAIL;
	    }
	  else
	    {
	      if (inst.operands[i].negative)
		{
		  inst.operands[i].negative = 0;
		  p--;
		}
	      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
		return FAIL;
	    }
	}
d3787 10
a3796 7
  /* If at this point neither .preind nor .postind is set, we have a
     bare [Rn]{!}, which is shorthand for [Rn,#0]{!}.  */
  if (inst.operands[i].preind == 0 && inst.operands[i].postind == 0)
    {
      inst.operands[i].preind = 1;
      inst.reloc.exp.X_op = O_constant;
      inst.reloc.exp.X_add_number = 0;
a3797 2
  *str = p;
  return SUCCESS;
d3800 1
a3800 1
/* Miscellaneous. */
d3802 2
a3803 4
/* Parse a PSR flag operand.  The value returned is FAIL on syntax error,
   or a bitmask suitable to be or-ed into the ARM msr instruction.  */
static int
parse_psr (char **str)
d3805 3
a3807 2
  char *p;
  unsigned long psr_field;
d3809 6
a3814 20
  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
     feature for ease of use and backwards compatibility.  */
  p = *str;
  if (*p == 's' || *p == 'S')
    psr_field = SPSR_BIT;
  else if (*p == 'c' || *p == 'C')
    psr_field = 0;
  else
    goto error;

  p++;
  if (strncasecmp (p, "PSR", 3) != 0)
    goto error;
  p += 3;

  if (*p == '_')
    {
      /* A suffix follows.  */
      const struct asm_psr *psr;
      char *start;
d3816 4
a3819 2
      p++;
      start = p;
d3821 1
a3821 3
      do
	p++;
      while (ISALNUM (*p) || *p == '_');
d3823 5
a3827 3
      psr = hash_find_n (arm_psr_hsh, start, p - start);
      if (!psr)
	goto error;
d3829 5
a3833 1
      psr_field |= psr->field;
d3835 2
a3836 1
  else
d3838 3
a3840 2
      if (ISALNUM (*p))
	goto error;    /* Garbage after "[CS]PSR".  */
d3842 6
a3847 1
      psr_field |= (PSR_c | PSR_f);
a3848 2
  *str = p;
  return psr_field;
d3850 1
a3850 3
 error:
  inst.error = _("flag for {c}psr instruction expected");
  return FAIL;
d3853 1
a3853 2
/* Parse the flags argument to CPSI[ED].  Returns FAIL on error, or a
   value suitable for splatting into the AIF field of the instruction.	*/
d3855 2
a3856 2
static int
parse_cps_flags (char **str)
d3858 15
a3872 3
  int val = 0;
  int saw_a_flag = 0;
  char *s = *str;
d3874 1
a3874 5
  for (;;)
    switch (*s++)
      {
      case '\0': case ',':
	goto done;
d3876 4
a3879 3
      case 'a': case 'A': saw_a_flag = 1; val |= 0x4; break;
      case 'i': case 'I': saw_a_flag = 1; val |= 0x2; break;
      case 'f': case 'F': saw_a_flag = 1; val |= 0x1; break;
d3881 10
a3890 4
      default:
	inst.error = _("unrecognized CPS flag");
	return FAIL;
      }
d3892 3
a3894 2
 done:
  if (saw_a_flag == 0)
d3896 2
a3897 2
      inst.error = _("missing CPS flags");
      return FAIL;
d3900 1
a3900 2
  *str = s - 1;
  return val;
d3903 1
a3903 2
/* Parse an endian specifier ("BE" or "LE", case insensitive);
   returns 0 for big-endian, 1 for little-endian, FAIL for an error.  */
d3905 2
a3906 2
static int
parse_endian_specifier (char **str)
d3908 1
a3908 2
  int little_endian;
  char *s = *str;
d3910 8
a3917 5
  if (strncasecmp (s, "BE", 2))
    little_endian = 0;
  else if (strncasecmp (s, "LE", 2))
    little_endian = 1;
  else
d3919 2
a3920 2
      inst.error = _("valid endian specifiers are be or le");
      return FAIL;
d3923 4
a3926 1
  if (ISALNUM (s[2]) || s[2] == '_')
d3928 2
a3929 2
      inst.error = _("valid endian specifiers are be or le");
      return FAIL;
d3932 1
a3932 2
  *str = s + 2;
  return little_endian;
d3935 2
a3936 3
/* Parse a rotation specifier: ROR #0, #8, #16, #24.  *val receives a
   value suitable for poking into the rotate field of an sxt or sxta
   instruction, or FAIL on error.  */
d3938 2
a3939 2
static int
parse_ror (char **str)
d3941 1
a3941 2
  int rot;
  char *s = *str;
d3943 8
a3950 3
  if (strncasecmp (s, "ROR", 3) == 0)
    s += 3;
  else
d3952 2
a3953 2
      inst.error = _("missing rotation field after comma");
      return FAIL;
d3956 4
a3959 4
  if (parse_immediate (&s, &rot, 0, 24, FALSE) == FAIL)
    return FAIL;

  switch (rot)
d3961 3
a3963 4
    case  0: *str = s; return 0x0;
    case  8: *str = s; return 0x1;
    case 16: *str = s; return 0x2;
    case 24: *str = s; return 0x3;
d3965 1
a3965 4
    default:
      inst.error = _("rotation can only be 0, 8, 16, or 24");
      return FAIL;
    }
d3968 2
a3969 2
/* Parse a conditional code (from conds[] below).  The value returned is in the
   range 0 .. 14, or FAIL.  */
d3971 1
a3971 1
parse_cond (char **str)
d3973 1
a3973 2
  char *p, *q;
  const struct asm_cond *c;
d3975 4
a3978 6
  p = q = *str;
  while (ISALPHA (*q))
    q++;

  c = hash_find_n (arm_cond_hsh, p, q - p);
  if (!c)
d3980 2
a3981 2
      inst.error = _("condition required");
      return FAIL;
d3983 4
d3988 3
a3990 2
  *str = q;
  return c->value;
d3993 8
a4000 2
/* Matcher codes for parse_operands.  */
enum operand_parse_code
d4002 3
a4004 1
  OP_stop,	/* end of line */
d4006 1
a4006 166
  OP_RR,	/* ARM register */
  OP_RRnpc,	/* ARM register, not r15 */
  OP_RRnpcb,	/* ARM register, not r15, in square brackets */
  OP_RRw,	/* ARM register, not r15, optional trailing ! */
  OP_RCP,	/* Coprocessor number */
  OP_RCN,	/* Coprocessor register */
  OP_RF,	/* FPA register */
  OP_RVS,	/* VFP single precision register */
  OP_RVD,	/* VFP double precision register */
  OP_RVC,	/* VFP control register */
  OP_RMF,	/* Maverick F register */
  OP_RMD,	/* Maverick D register */
  OP_RMFX,	/* Maverick FX register */
  OP_RMDX,	/* Maverick DX register */
  OP_RMAX,	/* Maverick AX register */
  OP_RMDS,	/* Maverick DSPSC register */
  OP_RIWR,	/* iWMMXt wR register */
  OP_RIWC,	/* iWMMXt wC register */
  OP_RIWG,	/* iWMMXt wCG register */
  OP_RXA,	/* XScale accumulator register */

  OP_REGLST,	/* ARM register list */
  OP_VRSLST,	/* VFP single-precision register list */
  OP_VRDLST,	/* VFP double-precision register list */

  OP_I7,	/* immediate value 0 .. 7 */
  OP_I15,	/*		   0 .. 15 */
  OP_I16,	/*		   1 .. 16 */
  OP_I31,	/*		   0 .. 31 */
  OP_I31w,	/*		   0 .. 31, optional trailing ! */
  OP_I32,	/*		   1 .. 32 */
  OP_I63s,	/*		 -64 .. 63 */
  OP_I255,	/*		   0 .. 255 */
  OP_Iffff,	/*		   0 .. 65535 */

  OP_I4b,	/* immediate, prefix optional, 1 .. 4 */
  OP_I7b,	/*			       0 .. 7 */
  OP_I15b,	/*			       0 .. 15 */
  OP_I31b,	/*			       0 .. 31 */

  OP_SH,	/* shifter operand */
  OP_ADDR,	/* Memory address expression (any mode) */
  OP_EXP,	/* arbitrary expression */
  OP_EXPi,	/* same, with optional immediate prefix */
  OP_EXPr,	/* same, with optional relocation suffix */

  OP_CPSF,	/* CPS flags */
  OP_ENDI,	/* Endianness specifier */
  OP_PSR,	/* CPSR/SPSR mask for msr */
  OP_COND,	/* conditional code */

  OP_RRnpc_I0,	/* ARM register or literal 0 */
  OP_RR_EXr,	/* ARM register or expression with opt. reloc suff. */
  OP_RR_EXi,	/* ARM register or expression with imm prefix */
  OP_RF_IF,	/* FPA register or immediate */
  OP_RIWR_RIWC, /* iWMMXt R or C reg */

  /* Optional operands.	 */
  OP_oI7b,	 /* immediate, prefix optional, 0 .. 7 */
  OP_oI31b,	 /*				0 .. 31 */
  OP_oIffffb,	 /*				0 .. 65535 */
  OP_oI255c,	 /*	  curly-brace enclosed, 0 .. 255 */

  OP_oRR,	 /* ARM register */
  OP_oRRnpc,	 /* ARM register, not the PC */
  OP_oSHll,	 /* LSL immediate */
  OP_oSHar,	 /* ASR immediate */
  OP_oSHllar,	 /* LSL or ASR immediate */
  OP_oROR,	 /* ROR 0/8/16/24 */

  OP_FIRST_OPTIONAL = OP_oI7b
};

/* Generic instruction operand parser.	This does no encoding and no
   semantic validation; it merely squirrels values away in the inst
   structure.  Returns SUCCESS or FAIL depending on whether the
   specified grammar matched.  */
static int
parse_operands (char *str, const char *pattern)
{
  unsigned const char *upat = pattern;
  char *backtrack_pos = 0;
  const char *backtrack_error = 0;
  int i, val, backtrack_index = 0;

#define po_char_or_fail(chr) do {		\
  if (skip_past_char (&str, chr) == FAIL)	\
    goto bad_args;				\
} while (0)

#define po_reg_or_fail(regtype) do {			\
  val = arm_reg_parse (&str, regtype);			\
  if (val == FAIL)					\
    {							\
      inst.error = _(reg_expected_msgs[regtype]);	\
      goto failure;					\
    }							\
  inst.operands[i].reg = val;				\
  inst.operands[i].isreg = 1;				\
} while (0)

#define po_reg_or_goto(regtype, label) do {	\
  val = arm_reg_parse (&str, regtype);		\
  if (val == FAIL)				\
    goto label;					\
						\
  inst.operands[i].reg = val;			\
  inst.operands[i].isreg = 1;			\
} while (0)

#define po_imm_or_fail(min, max, popt) do {			\
  if (parse_immediate (&str, &val, min, max, popt) == FAIL)	\
    goto failure;						\
  inst.operands[i].imm = val;					\
} while (0)

#define po_misc_or_fail(expr) do {		\
  if (expr)					\
    goto failure;				\
} while (0)

  skip_whitespace (str);

  for (i = 0; upat[i] != OP_stop; i++)
    {
      if (upat[i] >= OP_FIRST_OPTIONAL)
	{
	  /* Remember where we are in case we need to backtrack.  */
	  assert (!backtrack_pos);
	  backtrack_pos = str;
	  backtrack_error = inst.error;
	  backtrack_index = i;
	}

      if (i > 0)
	po_char_or_fail (',');

      switch (upat[i])
	{
	  /* Registers */
	case OP_oRRnpc:
	case OP_RRnpc:
	case OP_oRR:
	case OP_RR:    po_reg_or_fail (REG_TYPE_RN);	  break;
	case OP_RCP:   po_reg_or_fail (REG_TYPE_CP);	  break;
	case OP_RCN:   po_reg_or_fail (REG_TYPE_CN);	  break;
	case OP_RF:    po_reg_or_fail (REG_TYPE_FN);	  break;
	case OP_RVS:   po_reg_or_fail (REG_TYPE_VFS);	  break;
	case OP_RVD:   po_reg_or_fail (REG_TYPE_VFD);	  break;
	case OP_RVC:   po_reg_or_fail (REG_TYPE_VFC);	  break;
	case OP_RMF:   po_reg_or_fail (REG_TYPE_MVF);	  break;
	case OP_RMD:   po_reg_or_fail (REG_TYPE_MVD);	  break;
	case OP_RMFX:  po_reg_or_fail (REG_TYPE_MVFX);	  break;
	case OP_RMDX:  po_reg_or_fail (REG_TYPE_MVDX);	  break;
	case OP_RMAX:  po_reg_or_fail (REG_TYPE_MVAX);	  break;
	case OP_RMDS:  po_reg_or_fail (REG_TYPE_DSPSC);	  break;
	case OP_RIWR:  po_reg_or_fail (REG_TYPE_MMXWR);	  break;
	case OP_RIWC:  po_reg_or_fail (REG_TYPE_MMXWC);	  break;
	case OP_RIWG:  po_reg_or_fail (REG_TYPE_MMXWCG);  break;
	case OP_RXA:   po_reg_or_fail (REG_TYPE_XSCALE);  break;

	case OP_RRnpcb:
	  po_char_or_fail ('[');
	  po_reg_or_fail  (REG_TYPE_RN);
	  po_char_or_fail (']');
	  break;
d4008 3
a4010 5
	case OP_RRw:
	  po_reg_or_fail (REG_TYPE_RN);
	  if (skip_past_char (&str, '!') == SUCCESS)
	    inst.operands[i].writeback = 1;
	  break;
d4012 9
a4020 24
	  /* Immediates */
	case OP_I7:	 po_imm_or_fail (  0,	   7, FALSE);	break;
	case OP_I15:	 po_imm_or_fail (  0,	  15, FALSE);	break;
	case OP_I16:	 po_imm_or_fail (  1,	  16, FALSE);	break;
	case OP_I31:	 po_imm_or_fail (  0,	  31, FALSE);	break;
	case OP_I32:	 po_imm_or_fail (  1,	  32, FALSE);	break;
	case OP_I63s:	 po_imm_or_fail (-64,	  63, FALSE);	break;
	case OP_I255:	 po_imm_or_fail (  0,	 255, FALSE);	break;
	case OP_Iffff:	 po_imm_or_fail (  0, 0xffff, FALSE);	break;

	case OP_I4b:	 po_imm_or_fail (  1,	   4, TRUE);	break;
	case OP_oI7b:
	case OP_I7b:	 po_imm_or_fail (  0,	   7, TRUE);	break;
	case OP_I15b:	 po_imm_or_fail (  0,	  15, TRUE);	break;
	case OP_oI31b:
	case OP_I31b:	 po_imm_or_fail (  0,	  31, TRUE);	break;
	case OP_oIffffb: po_imm_or_fail (  0, 0xffff, TRUE);	break;

	  /* Immediate variants */
	case OP_oI255c:
	  po_char_or_fail ('{');
	  po_imm_or_fail (0, 255, TRUE);
	  po_char_or_fail ('}');
	  break;
d4022 8
a4029 17
	case OP_I31w:
	  /* The expression parser chokes on a trailing !, so we have
	     to find it first and zap it.  */
	  {
	    char *s = str;
	    while (*s && *s != ',')
	      s++;
	    if (s[-1] == '!')
	      {
		s[-1] = '\0';
		inst.operands[i].writeback = 1;
	      }
	    po_imm_or_fail (0, 31, TRUE);
	    if (str == s - 1)
	      str = s;
	  }
	  break;
d4031 5
a4035 5
	  /* Expressions */
	case OP_EXPi:	EXPi:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_OPT_PREFIX));
	  break;
d4037 2
a4038 4
	case OP_EXP:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_NO_PREFIX));
	  break;
d4040 6
a4045 18
	case OP_EXPr:	EXPr:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_NO_PREFIX));
	  if (inst.reloc.exp.X_op == O_symbol)
	    {
	      val = parse_reloc (&str);
	      if (val == -1)
		{
		  inst.error = _("unrecognized relocation suffix");
		  goto failure;
		}
	      else if (val != BFD_RELOC_UNUSED)
		{
		  inst.operands[i].imm = val;
		  inst.operands[i].hasreloc = 1;
		}
	    }
	  break;
d4047 9
a4055 21
	  /* Register or expression */
	case OP_RR_EXr:	  po_reg_or_goto (REG_TYPE_RN, EXPr); break;
	case OP_RR_EXi:	  po_reg_or_goto (REG_TYPE_RN, EXPi); break;

	  /* Register or immediate */
	case OP_RRnpc_I0: po_reg_or_goto (REG_TYPE_RN, I0);   break;
	I0:		  po_imm_or_fail (0, 0, FALSE);	      break;

	case OP_RF_IF:    po_reg_or_goto (REG_TYPE_FN, IF);   break;
	IF:
	  if (!is_immediate_prefix (*str))
	    goto bad_args;
	  str++;
	  val = parse_fpa_immediate (&str);
	  if (val == FAIL)
	    goto failure;
	  /* FPA immediates are encoded as registers 8-15.
	     parse_fpa_immediate has already applied the offset.  */
	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  break;
d4057 9
a4065 15
	  /* Two kinds of register */
	case OP_RIWR_RIWC:
	  {
	    struct reg_entry *rege = arm_reg_parse_multi (&str);
	    if (rege->type != REG_TYPE_MMXWR
		&& rege->type != REG_TYPE_MMXWC
		&& rege->type != REG_TYPE_MMXWCG)
	      {
		inst.error = _("iWMMXt data or control register expected");
		goto failure;
	      }
	    inst.operands[i].reg = rege->number;
	    inst.operands[i].isreg = (rege->type == REG_TYPE_MMXWR);
	  }
	  break;
d4067 5
a4071 16
	  /* Misc */
	case OP_CPSF:	 val = parse_cps_flags (&str);		break;
	case OP_ENDI:	 val = parse_endian_specifier (&str);	break;
	case OP_oROR:	 val = parse_ror (&str);		break;
	case OP_PSR:	 val = parse_psr (&str);		break;
	case OP_COND:	 val = parse_cond (&str);		break;

	  /* Register lists */
	case OP_REGLST:
	  val = parse_reg_list (&str);
	  if (*str == '^')
	    {
	      inst.operands[1].writeback = 1;
	      str++;
	    }
	  break;
d4073 5
a4077 3
	case OP_VRSLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, 0);
	  break;
d4079 8
a4086 3
	case OP_VRDLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, 1);
	  break;
d4088 3
a4090 4
	  /* Addressing modes */
	case OP_ADDR:
	  po_misc_or_fail (parse_address (&str, i));
	  break;
d4092 3
a4094 3
	case OP_SH:
	  po_misc_or_fail (parse_shifter_operand (&str, i));
	  break;
d4096 4
a4099 3
	case OP_oSHll:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_IMMEDIATE));
	  break;
d4101 2
a4102 3
	case OP_oSHar:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_ASR_IMMEDIATE));
	  break;
d4104 7
a4110 3
	case OP_oSHllar:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_OR_ASR_IMMEDIATE));
	  break;
d4112 9
a4120 3
	default:
	  as_fatal ("unhandled operand code %d", upat[i]);
	}
d4122 10
a4131 13
      /* Various value-based sanity checks and shared operations.  We
	 do not signal immediate failures for the register constraints;
	 this allows a syntax error to take precedence.	 */
      switch (upat[i])
	{
	case OP_oRRnpc:
	case OP_RRnpc:
	case OP_RRnpcb:
	case OP_RRw:
	case OP_RRnpc_I0:
	  if (inst.operands[i].isreg && inst.operands[i].reg == REG_PC)
	    inst.error = BAD_PC;
	  break;
d4133 5
a4137 12
	case OP_CPSF:
	case OP_ENDI:
	case OP_oROR:
	case OP_PSR:
	case OP_COND:
	case OP_REGLST:
	case OP_VRSLST:
	case OP_VRDLST:
	  if (val == FAIL)
	    goto failure;
	  inst.operands[i].imm = val;
	  break;
d4139 2
a4140 3
	default:
	  break;
	}
d4142 6
a4147 3
      /* If we get here, this operand was successfully parsed.	*/
      inst.operands[i].present = 1;
      continue;
d4149 9
a4157 2
    bad_args:
      inst.error = BAD_ARGS;
d4159 9
a4167 3
    failure:
      if (!backtrack_pos)
	return FAIL;
d4169 5
a4173 7
      /* Do not backtrack over a trailing optional argument that
	 absorbed some text.  We will only fail again, with the
	 'garbage following instruction' error message, which is
	 probably less helpful than the current one.  */
      if (backtrack_index == i && backtrack_pos != str
	  && upat[i+1] == OP_stop)
	return FAIL;
d4175 4
a4178 6
      /* Try again, skipping the optional argument at backtrack_pos.  */
      str = backtrack_pos;
      inst.error = backtrack_error;
      inst.operands[backtrack_index].present = 0;
      i = backtrack_index;
      backtrack_pos = 0;
d4181 5
a4185 3
  /* Check that we have parsed all the arguments.  */
  if (*str != '\0' && !inst.error)
    inst.error = _("garbage following instruction");
d4187 3
a4189 2
  return inst.error ? FAIL : SUCCESS;
}
d4191 3
a4193 13
#undef po_char_or_fail
#undef po_reg_or_fail
#undef po_reg_or_goto
#undef po_imm_or_fail

/* Shorthand macro for instruction encoding functions issuing errors.  */
#define constraint(expr, err) do {		\
  if (expr)					\
    {						\
      inst.error = err;				\
      return;					\
    }						\
} while (0)
d4195 3
a4197 1
/* Functions for operand encoding.  ARM, then Thumb.  */
d4199 4
a4202 1
#define rotate_left(v, n) (v << n | v >> (32 - n))
d4204 2
a4205 2
/* If VAL can be encoded in the immediate field of an ARM instruction,
   return the encoded form.  Otherwise, return FAIL.  */
a4206 4
static unsigned int
encode_arm_immediate (unsigned int val)
{
  unsigned int a, i;
d4208 5
a4212 3
  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */
d4214 4
a4217 2
  return FAIL;
}
d4219 1
a4219 6
/* If VAL can be encoded in the immediate field of a Thumb32 instruction,
   return the encoded form.  Otherwise, return FAIL.  */
static unsigned int
encode_thumb32_immediate (unsigned int val)
{
  unsigned int a, i;
d4221 2
a4222 2
  if (val <= 255)
    return val;
d4224 1
a4224 1
  for (i = 0; i < 32; i++)
d4226 2
a4227 3
      a = rotate_left (val, i);
      if (a >= 128 && a <= 255)
	return (a & 0x7f) | (i << 7);
d4230 1
a4230 5
  a = val & 0xff;
  if (val == ((a << 16) | a))
    return 0x100 | a;
  if (val == ((a << 24) | (a << 16) | (a << 8) | a))
    return 0x300 | a;
d4232 7
a4238 3
  a = val & 0xff00;
  if (val == ((a << 16) | a))
    return 0x200 | (a >> 8);
d4240 5
a4244 3
  return FAIL;
}
/* Encode a VFP SP register number into inst.instruction.  */
d4247 1
a4247 1
encode_arm_vfp_sp_reg (int reg, enum vfp_sp_reg_pos pos)
d4249 1
a4249 5
  switch (pos)
    {
    case VFP_REG_Sd:
      inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
      break;
d4251 1
a4251 3
    case VFP_REG_Sn:
      inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
      break;
d4253 4
a4256 3
    case VFP_REG_Sm:
      inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
      break;
d4258 2
a4259 4
    default:
      abort ();
    }
}
a4260 7
/* Encode a <shift> in an ARM-format instruction.  The immediate,
   if any, is handled by md_apply_fix3.	 */
static void
encode_arm_shift (int i)
{
  if (inst.operands[i].shift_kind == SHIFT_RRX)
    inst.instruction |= SHIFT_ROR << 5;
d4262 1
a4262 10
    {
      inst.instruction |= inst.operands[i].shift_kind << 5;
      if (inst.operands[i].immisreg)
	{
	  inst.instruction |= SHIFT_BY_REG;
	  inst.instruction |= inst.operands[i].imm << 8;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
    }
d4265 5
d4271 1
a4271 1
encode_arm_shifter_operand (int i)
d4273 14
a4286 5
  if (inst.operands[i].isreg)
    {
      inst.instruction |= inst.operands[i].reg;
      encode_arm_shift (i);
    }
d4288 1
a4288 1
    inst.instruction |= INST_IMMEDIATE;
a4290 1
/* Subroutine of encode_arm_addr_mode_2 and encode_arm_addr_mode_3.  */
d4292 1
a4292 1
encode_arm_addr_mode_common (int i, bfd_boolean is_t)
d4294 1
a4294 2
  assert (inst.operands[i].isreg);
  inst.instruction |= inst.operands[i].reg << 16;
d4296 6
a4301 1
  if (inst.operands[i].preind)
d4303 3
a4305 8
      if (is_t)
	{
	  inst.error = _("instruction does not accept preindexed addressing");
	  return;
	}
      inst.instruction |= PRE_INDEX;
      if (inst.operands[i].writeback)
	inst.instruction |= WRITE_BACK;
d4307 1
a4307 2
    }
  else if (inst.operands[i].postind)
d4309 2
a4310 3
      assert (inst.operands[i].writeback);
      if (is_t)
	inst.instruction |= WRITE_BACK;
d4312 3
a4314 1
  else /* unindexed - only for coprocessor */
d4316 9
a4324 1
      inst.error = _("instruction does not accept unindexed addressing");
d4328 1
a4328 6
  if (((inst.instruction & WRITE_BACK) || !(inst.instruction & PRE_INDEX))
      && (((inst.instruction & 0x000f0000) >> 16)
	  == ((inst.instruction & 0x0000f000) >> 12)))
    as_warn ((inst.instruction & LOAD_BIT)
	     ? _("destination register same as write-back base")
	     : _("source register same as write-back base"));
d4331 5
a4335 4
/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format mode 2 load or store instruction.	 If is_t is true,
   reject forms that cannot be used with a T instruction (i.e. not
   post-indexed).  */
d4337 1
a4337 1
encode_arm_addr_mode_2 (int i, bfd_boolean is_t)
d4339 4
a4342 1
  encode_arm_addr_mode_common (i, is_t);
d4344 4
a4347 24
  if (inst.operands[i].immisreg)
    {
      inst.instruction |= INST_IMMEDIATE;  /* yes, this is backwards */
      inst.instruction |= inst.operands[i].imm;
      if (!inst.operands[i].negative)
	inst.instruction |= INDEX_UP;
      if (inst.operands[i].shifted)
	{
	  if (inst.operands[i].shift_kind == SHIFT_RRX)
	    inst.instruction |= SHIFT_ROR << 5;
	  else
	    {
	      inst.instruction |= inst.operands[i].shift_kind << 5;
	      inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
	    }
	}
    }
  else /* immediate offset in inst.reloc */
    {
      if (inst.reloc.type == BFD_RELOC_UNUSED)
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
      if (inst.reloc.pc_rel)
	inst.reloc.exp.X_add_number -= 8;  /* pipeline offset */
    }
d4350 6
a4355 5
/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format mode 3 load or store instruction.	 Reject forms that
   cannot be used with such instructions.  If is_t is true, reject
   forms that cannot be used with a T instruction (i.e. not
   post-indexed).  */
d4357 1
a4357 1
encode_arm_addr_mode_3 (int i, bfd_boolean is_t)
d4359 7
a4365 1
  if (inst.operands[i].immisreg && inst.operands[i].shifted)
d4367 1
a4367 1
      inst.error = _("instruction does not accept scaled register index");
d4370 6
d4377 5
a4381 1
  encode_arm_addr_mode_common (i, is_t);
d4383 2
a4384 1
  if (inst.operands[i].immisreg)
d4386 2
a4387 3
      inst.instruction |= inst.operands[i].imm;
      if (!inst.operands[i].negative)
	inst.instruction |= INDEX_UP;
d4389 1
a4389 1
  else /* immediate offset in inst.reloc */
d4391 2
a4392 5
      inst.instruction |= HWOFFSET_IMM;
      if (inst.reloc.type == BFD_RELOC_UNUSED)
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
      if (inst.reloc.pc_rel)
	inst.reloc.exp.X_add_number -= 8;  /* pipeline offset */
d4394 8
d4404 9
a4412 6
/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format instruction.  Reject all forms which cannot be encoded
   into a coprocessor load/store instruction.  If wb_ok is false,
   reject use of writeback; if unind_ok is false, reject use of
   unindexed addressing.  If reloc_override is not 0, use it instead
   of BFD_ARM_CP_OFF_IMM.  */
d4414 2
a4415 2
static int
encode_arm_cp_address (int i, int wb_ok, int unind_ok, int reloc_override)
d4417 12
a4428 1
  inst.instruction |= inst.operands[i].reg << 16;
d4430 3
a4432 1
  assert (!(inst.operands[i].preind && inst.operands[i].postind));
d4434 2
a4435 1
  if (!inst.operands[i].preind && !inst.operands[i].postind) /* unindexed */
d4437 11
a4447 2
      assert (!inst.operands[i].writeback);
      if (!unind_ok)
d4449 2
a4450 2
	  inst.error = _("instruction does not support unindexed addressing");
	  return FAIL;
d4452 1
a4452 3
      inst.instruction |= inst.operands[i].imm;
      inst.instruction |= INDEX_UP;
      return SUCCESS;
d4455 8
a4462 2
  if (inst.operands[i].preind)
    inst.instruction |= PRE_INDEX;
d4464 1
a4464 1
  if (inst.operands[i].writeback)
d4466 2
a4467 11
      if (inst.operands[i].reg == REG_PC)
	{
	  inst.error = _("pc may not be used with write-back");
	  return FAIL;
	}
      if (!wb_ok)
	{
	  inst.error = _("instruction does not support writeback");
	  return FAIL;
	}
      inst.instruction |= WRITE_BACK;
d4469 1
a4469 8

  if (reloc_override)
    inst.reloc.type = reloc_override;
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
  if (inst.reloc.pc_rel)
    inst.reloc.exp.X_add_number -= 8;
  return SUCCESS;
d4472 1
a4472 8
/* inst.reloc.exp describes an "=expr" load pseudo-operation.
   Determine whether it can be performed with a move instruction; if
   it can, convert inst.instruction to that move instruction and
   return 1; if it can't, convert inst.instruction to a literal-pool
   load and return 0.  If this is not a valid thing to do in the
   current context, set inst.error and return 1.

   inst.operands[i] describes the destination register.	 */
d4475 1
a4475 1
move_or_literal_pool (int i, bfd_boolean thumb_p, bfd_boolean mode_3)
d4477 4
a4480 1
  if ((inst.instruction & (thumb_p ? THUMB_LOAD_BIT : LOAD_BIT)) == 0)
d4482 2
a4483 2
      inst.error = _("invalid pseudo operation");
      return 1;
d4485 2
a4486 1
  if (inst.reloc.exp.X_op != O_constant && inst.reloc.exp.X_op != O_symbol)
d4488 2
a4489 2
      inst.error = _("constant expression expected");
      return 1;
d4491 1
a4491 1
  if (inst.reloc.exp.X_op == O_constant)
d4493 2
a4494 32
      if (thumb_p)
	{
	  if ((inst.reloc.exp.X_add_number & ~0xFF) == 0)
	    {
	      /* This can be done with a mov(1) instruction.  */
	      inst.instruction	= T_OPCODE_MOV_I8 | (inst.operands[i].reg << 8);
	      inst.instruction |= inst.reloc.exp.X_add_number;
	      return 1;
	    }
	}
      else
	{
	  int value = encode_arm_immediate (inst.reloc.exp.X_add_number);
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      return 1;
	    }

	  value = encode_arm_immediate (~inst.reloc.exp.X_add_number);
	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      return 1;
	    }
	}
d4496 1
a4496 2

  if (add_to_lit_pool () == FAIL)
d4498 2
a4499 2
      inst.error = _("literal pool insertion failed");
      return 1;
d4501 2
a4502 10
  inst.operands[1].reg = REG_PC;
  inst.operands[1].isreg = 1;
  inst.operands[1].preind = 1;
  inst.reloc.pc_rel = 1;
  inst.reloc.type = (thumb_p
		     ? BFD_RELOC_ARM_THUMB_OFFSET
		     : (mode_3
			? BFD_RELOC_ARM_HWLITERAL
			: BFD_RELOC_ARM_LITERAL));
  return 0;
a4504 4
/* Functions for instruction encoding, sorted by subarchitecture.
   First some generics; their names are taken from the conventional
   bit positions for register arguments in ARM format instructions.  */

d4506 1
a4506 1
do_noargs (void)
d4508 1
a4508 1
}
d4510 2
a4511 5
static void
do_rd (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
}
d4513 7
a4519 6
static void
do_rd_rm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
}
d4521 1
a4521 6
static void
do_rd_rn (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
}
d4523 10
a4532 6
static void
do_rn_rd (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
}
d4534 3
a4536 6
static void
do_rd_rm_rn (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 16;
d4540 1
a4540 1
do_rd_rn_rm (void)
d4542 1
a4542 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
}
d4544 13
a4556 13
static void
do_rm_rd_rn (void)
{
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_imm0 (void)
{
  inst.instruction |= inst.operands[0].imm;
}
d4558 1
a4558 5
static void
do_rd_cpaddr (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, TRUE, 0);
a4560 7
/* ARM instructions, in alphabetical order by function name (except
   that wrapper functions appear immediately after the function they
   wrap).  */

/* This is a pseudo-op of the form "adr rd, label" to be converted
   into a relative address of the form "add rd, pc, #label-.-8".  */

d4562 1
a4562 1
do_adr (void)
d4564 1
a4564 1
  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */
d4566 13
a4578 8
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
#endif
  inst.reloc.pc_rel = 1;
}
d4580 41
a4620 9
/* This is a pseudo-op of the form "adrl rd, label" to be converted
   into a relative address of the form:
   add rd, pc, #low(label-.-8)"
   add rd, rd, #high(label-.-8)"  */

static void
do_adrl (void)
{
  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */
d4622 1
a4622 8
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type	       = BFD_RELOC_ARM_ADRL_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
#endif
  inst.reloc.pc_rel	       = 1;
  inst.size		       = INSN_SIZE * 2;
d4626 1
a4626 1
do_arit (void)
d4628 1
a4628 6
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  encode_arm_shifter_operand (2);
}
d4630 8
a4637 11
static void
do_bfc (void)
{
  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 7;
  inst.instruction |= (msb - 1) << 16;
}
d4639 8
a4646 4
static void
do_bfi (void)
{
  unsigned int msb;
d4648 2
a4649 4
  /* #0 in second position is alternative syntax for bfc, which is
     the same instruction but with REG_PC in the Rm field.  */
  if (!inst.operands[1].isreg)
    inst.operands[1].reg = REG_PC;
d4651 7
a4657 9
  msb = inst.operands[2].imm + inst.operands[3].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 7;
  inst.instruction |= (msb - 1) << 16;
}
d4659 1
a4659 26
static void
do_bfx (void)
{
  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
	      _("bit-field extends past end of register"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 7;
  inst.instruction |= (inst.operands[3].imm - 1) << 16;
}

/* ARM V5 breakpoint instruction (argument parse)
     BKPT <16 bit unsigned immediate>
     Instruction is not conditional.
	The bit pattern given in insns[] has the COND_ALWAYS condition,
	and it is an error if the caller tried to override that.  */

static void
do_bkpt (void)
{
  /* Top 12 of 16 bits to bits 19:8.  */
  inst.instruction |= (inst.operands[0].imm & 0xfff0) << 4;

  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= inst.operands[0].imm & 0xf;
}
d4661 1
a4661 4
static void
encode_branch (int default_reloc)
{
  if (inst.operands[0].hasreloc)
d4663 2
a4664 4
      constraint (inst.operands[0].imm != BFD_RELOC_ARM_PLT32,
		  _("the only suffix valid here is '(plt)'"));
      inst.reloc.type	= BFD_RELOC_ARM_PLT32;
      inst.reloc.pc_rel = 0;
d4666 1
a4666 1
  else
d4668 2
a4669 2
      inst.reloc.type = default_reloc;
      inst.reloc.pc_rel = 1;
a4670 1
}
d4672 2
a4673 4
static void
do_branch (void)
{
  encode_branch (BFD_RELOC_ARM_PCREL_BRANCH);
a4675 8
/* ARM V5 branch-link-exchange instruction (argument parse)
     BLX <target_addr>		ie BLX(1)
     BLX{<condition>} <Rm>	ie BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */

d4677 1
a4677 1
do_blx (void)
d4679 4
a4682 1
  if (inst.operands[0].isreg)
d4684 3
a4686 4
      /* Arg is a register; the opcode provided by insns[] is correct.
	 It is not illegal to do "blx pc", just useless.  */
      if (inst.operands[0].reg == REG_PC)
	as_tsktsk (_("use of r15 in blx in ARM mode is not really useful"));
d4688 3
a4690 3
      inst.instruction |= inst.operands[0].reg;
    }
  else
d4692 2
a4693 5
      /* Arg is an address; this instruction cannot be executed
	 conditionally, and the opcode must be adjusted.  */
      constraint ((inst.instruction & COND_MASK) != COND_ALWAYS, BAD_COND);
      inst.instruction = 0xfafffffe;
      encode_branch (BFD_RELOC_ARM_PCREL_BLX);
d4695 2
d4699 1
d4701 1
a4701 1
do_bx (void)
d4703 2
a4704 2
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));
d4706 43
a4748 1
  inst.instruction |= inst.operands[0].reg;
d4750 1
d4752 2
a4753 2

/* ARM v5TEJ.  Jump to Jazelle code.  */
d4756 1
a4756 1
do_bxj (void)
d4758 29
a4786 2
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));
d4788 1
a4788 1
  inst.instruction |= inst.operands[0].reg;
d4791 3
a4793 5
/* Co-processor data operation:
      CDP{cond} <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}
      CDP2	<coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}	 */
static void
do_cdp (void)
d4795 39
a4833 7
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 20;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
  inst.instruction |= inst.operands[5].imm << 5;
}
d4835 1
a4835 5
static void
do_cmp (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_shifter_operand (1);
d4837 1
d4839 4
a4842 7
/* Transfer between coprocessor and ARM registers.
   MRC{cond} <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>{, <opcode_2>}
   MRC2
   MCR{cond}
   MCR2

   No special properties.  */
d4845 1
a4845 1
do_co_reg (void)
d4847 2
a4848 7
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 21;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
  inst.instruction |= inst.operands[5].imm << 5;
}
d4850 3
a4852 5
/* Transfer between coprocessor register and pair of ARM registers.
   MCRR{cond} <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
   MCRR2
   MRRC{cond}
   MRRC2
d4854 2
a4855 1
   Two XScale instructions are special cases of these:
d4857 21
a4877 2
     MAR{cond} acc0, <RdLo>, <RdHi> == MCRR{cond} p0, #0, <RdLo>, <RdHi>, c0
     MRA{cond} acc0, <RdLo>, <RdHi> == MRRC{cond} p0, #0, <RdLo>, <RdHi>, c0
d4879 6
a4884 1
   Result unpredicatable if Rd or Rn is R15.  */
d4886 1
a4886 8
static void
do_co_reg2c (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 4;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
d4889 7
a4895 6
static void
do_cpsi (void)
{
  inst.instruction |= inst.operands[0].imm << 6;
  inst.instruction |= inst.operands[1].imm;
}
d4898 1
a4898 1
do_ldmstm (void)
d4900 2
a4901 2
  int base_reg = inst.operands[0].reg;
  int range = inst.operands[1].imm;
d4903 2
a4904 2
  inst.instruction |= base_reg << 16;
  inst.instruction |= range;
d4906 2
a4907 2
  if (inst.operands[1].writeback)
    inst.instruction |= LDM_TYPE_2_OR_3;
d4909 9
a4917 1
  if (inst.operands[0].writeback)
d4919 2
a4920 3
      inst.instruction |= WRITE_BACK;
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
d4922 2
a4923 17
	  /* Not allowed in LDM type 2.	 */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
	}
      else /* STM.  */
	{
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
d4925 6
d4934 6
a4939 5
/* ARMv5TE load-consecutive (argument parse)
   Mode is like LDRH.

     LDRccD R, mode
     STRccD R, mode.  */
d4942 1
a4942 1
do_ldrd (void)
d4944 5
a4948 7
  constraint (inst.operands[0].reg % 2 != 0,
	      _("first destination register must be even"));
  constraint (inst.operands[1].present
	      && inst.operands[1].reg != inst.operands[0].reg + 1,
	      _("can only load two consecutive registers"));
  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));
  constraint (!inst.operands[2].isreg, _("'[' expected"));
d4950 12
a4961 4
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg + 1;
  
  if (inst.instruction & LOAD_BIT)
d4963 3
a4965 3
      /* encode_arm_addr_mode_3 will diagnose overlap between the base
	 register and the first register written; we have to diagnose
	 overlap between the base and the second register written here.	 */
d4967 2
a4968 4
      if (inst.operands[2].reg == inst.operands[1].reg
	  && (inst.operands[2].writeback || inst.operands[2].postind))
	as_warn (_("base register written back, and overlaps "
		   "second destination register"));
d4970 2
a4971 6
      /* For an index-register load, the index register must not overlap the
	 destination (even if not write-back).	*/
      else if (inst.operands[2].immisreg
	       && (inst.operands[2].imm == inst.operands[0].reg
		   || inst.operands[2].imm == inst.operands[1].reg))
	as_warn (_("index register overlaps destination register"));
d4974 1
a4974 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_3 (2, /*is_t=*/FALSE);
d4977 6
d4984 1
a4984 1
do_ldrex (void)
d4986 19
a5004 5
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
	      || inst.operands[1].postind || inst.operands[1].writeback
	      || inst.operands[1].immisreg || inst.operands[1].shifted
	      || inst.operands[1].negative,
	      _("instruction does not accept this addressing mode"));
d5006 1
a5006 1
  constraint (inst.operands[1].reg == REG_PC, BAD_PC);
d5008 6
a5013 3
  constraint (inst.reloc.exp.X_op != O_constant
	      || inst.reloc.exp.X_add_number != 0,
	      _("offset must be zero in ARM encoding"));
d5015 2
a5016 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.reloc.type = BFD_RELOC_UNUSED;
}
d5018 2
a5019 11
static void
do_ldrexd (void)
{
  constraint (inst.operands[0].reg % 2 != 0,
	      _("even register required"));
  constraint (inst.operands[1].present
	      && inst.operands[1].reg != inst.operands[0].reg + 1,
	      _("can only load two consecutive registers"));
  /* If op 1 were present and equal to PC, this function wouldn't
     have been called in the first place.  */
  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));
d5021 1
a5021 2
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
d5024 2
d5027 1
a5027 1
do_ldst (void)
d5029 2
a5030 5
  inst.instruction |= inst.operands[0].reg << 12;
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/FALSE, /*mode_3=*/FALSE))
      return;
  encode_arm_addr_mode_2 (1, /*is_t=*/FALSE);
d5033 8
a5040 2
static void
do_ldstt (void)
d5042 6
a5047 3
  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
     reject [Rn,...].  */
  if (inst.operands[1].preind)
d5049 15
a5063 3
      constraint (inst.reloc.exp.X_op != O_constant ||
		  inst.reloc.exp.X_add_number != 0,
		  _("this instruction requires a post-indexed address"));
d5065 2
a5066 3
      inst.operands[1].preind = 0;
      inst.operands[1].postind = 1;
      inst.operands[1].writeback = 1;
d5068 2
a5069 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_2 (1, /*is_t=*/TRUE);
a5071 2
/* Halfword and signed-byte load/store operations.  */

d5073 1
a5073 1
do_ldstv4 (void)
d5075 9
a5083 3
  inst.instruction |= inst.operands[0].reg << 12;
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/FALSE, /*mode_3=*/TRUE))
d5085 10
a5094 2
  encode_arm_addr_mode_3 (1, /*is_t=*/FALSE);
}
d5096 1
a5096 6
static void
do_ldsttv4 (void)
{
  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
     reject [Rn,...].  */
  if (inst.operands[1].preind)
d5098 16
a5113 3
      constraint (inst.reloc.exp.X_op != O_constant ||
		  inst.reloc.exp.X_add_number != 0,
		  _("this instruction requires a post-indexed address"));
d5115 8
a5122 3
      inst.operands[1].preind = 0;
      inst.operands[1].postind = 1;
      inst.operands[1].writeback = 1;
d5124 14
a5137 3
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_3 (1, /*is_t=*/TRUE);
}
d5139 5
a5143 9
/* Co-processor register load/store.
   Format: <LDC|STC>{cond}[L] CP#,CRd,<address>	 */
static void
do_lstc (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 12;
  encode_arm_cp_address (2, TRUE, TRUE, 0);
}
d5145 5
a5149 8
static void
do_mlas (void)
{
  /* This restriction does not apply to mls (nor to mla in v6, but
     that's hard to detect at present).	 */
  if (inst.operands[0].reg == inst.operands[1].reg
      && !(inst.instruction & 0x00400000))
    as_tsktsk (_("rd and rm should be different in mla"));
d5151 3
a5153 4
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 12;
d5155 1
d5158 2
d5161 1
a5161 1
do_mov (void)
d5163 1
a5163 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_shifter_operand (1);
d5166 2
a5167 1
/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.	 */
d5169 1
a5169 1
do_mov16 (void)
d5171 2
a5172 4
  inst.instruction |= inst.operands[0].reg << 12;
  /* The value is in two pieces: 0:11, 16:19.  */
  inst.instruction |= (inst.operands[1].imm & 0x00000fff);
  inst.instruction |= (inst.operands[1].imm & 0x0000f000) << 4;
d5175 6
a5180 2
static void
do_mrs (void)
d5182 4
a5185 7
  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
  constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
	      != (PSR_c|PSR_f),
	      _("'CPSR' or 'SPSR' expected"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= (inst.operands[1].imm & SPSR_BIT);
}
d5187 4
a5190 3
/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */
d5192 1
a5192 7
static void
do_msr (void)
{
  inst.instruction |= inst.operands[0].imm;
  if (inst.operands[1].isreg)
    inst.instruction |= inst.operands[1].reg;
  else
d5194 4
a5197 5
      inst.instruction |= INST_IMMEDIATE;
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
    }
}
d5199 11
a5209 8
static void
do_mul (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
d5211 8
a5218 3
  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rd and rm should be different in mul"));
}
d5220 8
a5227 5
/* Long Multiply Parser
   UMULL RdLo, RdHi, Rm, Rs
   SMULL RdLo, RdHi, Rm, Rs
   UMLAL RdLo, RdHi, Rm, Rs
   SMLAL RdLo, RdHi, Rm, Rs.  */
d5229 6
a5234 7
static void
do_mull (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 8;
d5236 6
a5241 6
  /* rdhi, rdlo and rm must all be different.  */
  if (inst.operands[0].reg == inst.operands[1].reg
      || inst.operands[0].reg == inst.operands[2].reg
      || inst.operands[1].reg == inst.operands[2].reg)
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
}
d5243 8
a5250 10
static void
do_nop (void)
{
  if (inst.operands[0].present)
    {
      /* Architectural NOP hints are CPSR sets with no bits selected.  */
      inst.instruction &= 0xf0000000;
      inst.instruction |= 0x0320f000 + inst.operands[0].imm;
    }
}
d5252 8
a5259 4
/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>}
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */
d5261 8
a5268 9
static void
do_pkhbt (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  if (inst.operands[3].present)
    encode_arm_shift (3);
}
d5270 6
a5275 1
/* ARM V6 PKHTB (Argument Parse).  */
d5277 6
a5282 20
static void
do_pkhtb (void)
{
  if (!inst.operands[3].present)
    {
      /* If the shift specifier is omitted, turn the instruction
	 into pkhbt rd, rm, rn. */
      inst.instruction &= 0xfff00010;
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg;
      inst.instruction |= inst.operands[2].reg << 16;
    }
  else
    {
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg;
      encode_arm_shift (3);
    }
}
d5284 7
a5290 1
/* ARMv5TE: Preload-Cache
d5292 5
a5296 1
    PLD <addr_mode>
d5298 9
a5306 1
  Syntactically, like LDR with B=1, W=0, L=1.  */
d5308 7
a5314 14
static void
do_pld (void)
{
  constraint (!inst.operands[0].isreg,
	      _("'[' expected after PLD mnemonic"));
  constraint (inst.operands[0].postind,
	      _("post-indexed expression used in preload instruction"));
  constraint (inst.operands[0].writeback,
	      _("writeback used in preload instruction"));
  constraint (!inst.operands[0].preind,
	      _("unindexed addressing used in preload instruction"));
  inst.instruction |= inst.operands[0].reg;
  encode_arm_addr_mode_2 (0, /*is_t=*/FALSE);
}
d5316 8
a5323 10
static void
do_push_pop (void)
{
  inst.operands[1] = inst.operands[0];
  memset (&inst.operands[0], 0, sizeof inst.operands[0]);
  inst.operands[0].isreg = 1;
  inst.operands[0].writeback = 1;
  inst.operands[0].reg = REG_SP;
  do_ldmstm ();
}
d5325 9
a5333 15
/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
   word at the specified address and the following word
   respectively.
   Unconditionally executed.
   Error if Rn is R15.	*/

static void
do_rfe (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
}

/* ARM V6 ssat (argument parse).  */
d5335 3
a5337 6
static void
do_ssat (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= (inst.operands[1].imm - 1) << 16;
  inst.instruction |= inst.operands[2].reg;
d5339 1
a5339 3
  if (inst.operands[3].present)
    encode_arm_shift (3);
}
d5341 5
a5345 1
/* ARM V6 usat (argument parse).  */
d5347 1
a5347 6
static void
do_usat (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 16;
  inst.instruction |= inst.operands[2].reg;
d5349 9
a5357 2
  if (inst.operands[3].present)
    encode_arm_shift (3);
a5359 2
/* ARM V6 ssat16 (argument parse).  */

d5361 1
a5361 1
do_ssat16 (void)
d5363 2
a5364 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= ((inst.operands[1].imm - 1) << 16);
  inst.instruction |= inst.operands[2].reg;
}
d5366 2
a5367 7
static void
do_usat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 16;
  inst.instruction |= inst.operands[2].reg;
}
d5369 1
a5369 19
/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.

   setend <endian_specifier>, where <endian_specifier> is either
   BE or LE.  */

static void
do_setend (void)
{
  if (inst.operands[0].imm)
    inst.instruction |= 0x200;
}

static void
do_shift (void)
{
  unsigned int Rm = (inst.operands[1].present
		     ? inst.operands[1].reg
		     : inst.operands[0].reg);
d5371 3
a5373 3
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= Rm;
  if (inst.operands[2].isreg)  /* Rd, {Rm,} Rs */
d5375 2
a5376 4
      constraint (inst.operands[0].reg != Rm,
		  _("source1 and dest must be same register"));
      inst.instruction |= inst.operands[2].reg << 8;
      inst.instruction |= SHIFT_BY_REG;
d5379 1
a5379 2
    inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
}
d5381 6
a5386 5
static void
do_smi (void)
{
  inst.reloc.type = BFD_RELOC_ARM_SMI;
  inst.reloc.pc_rel = 0;
d5390 1
a5390 1
do_swi (void)
d5392 1
a5392 3
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
}
d5394 1
a5394 4
/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
   SMLAxy{cond} Rd,Rm,Rs,Rn
   SMLAWy{cond} Rd,Rm,Rs,Rn
   Error if any register is R15.  */
d5396 2
a5397 7
static void
do_smla (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 12;
a5399 5
/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
   Error if any register is R15.
   Warning if Rdlo == Rdhi.  */

d5401 1
a5401 1
do_smlal (void)
d5403 1
a5403 7
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 8;

  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rdhi and rdlo must be different"));
a5405 4
/* ARM V5E (El Segundo) signed-multiply (argument parse)
   SMULxy{cond} Rd,Rm,Rs
   Error if any register is R15.  */

d5407 1
a5407 1
do_smul (void)
d5409 1
a5409 4
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
}
d5411 2
a5412 1
/* ARM V6 srs (argument parse).	 */
d5414 1
a5414 6
static void
do_srs (void)
{
  inst.instruction |= inst.operands[0].imm;
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
a5416 2
/* ARM V6 strex (argument parse).  */

d5418 1
a5418 1
do_strex (void)
d5420 4
a5423 20
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative,
	      _("instruction does not accept this addressing mode"));

  constraint (inst.operands[2].reg == REG_PC, BAD_PC);

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  constraint (inst.reloc.exp.X_op != O_constant
	      || inst.reloc.exp.X_add_number != 0,
	      _("offset must be zero in ARM encoding"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.reloc.type = BFD_RELOC_UNUSED;
}
d5425 1
a5425 20
static void
do_strexd (void)
{
  constraint (inst.operands[1].reg % 2 != 0,
	      _("even register required"));
  constraint (inst.operands[2].present
	      && inst.operands[2].reg != inst.operands[1].reg + 1,
	      _("can only store two consecutive registers"));
  /* If op 2 were present and equal to PC, this function wouldn't
     have been called in the first place.  */
  constraint (inst.operands[1].reg == REG_LR, _("r14 not allowed here"));

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[1].reg + 1
	      || inst.operands[0].reg == inst.operands[3].reg,
	      BAD_OVERLAP);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[3].reg << 16;
a5427 8
/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
   extends it to 32-bits, and adds the result to a value in another
   register.  You can specify a rotation by 0, 8, 16, or 24 bits
   before extracting the 16-bit value.
   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */

d5429 1
a5429 1
do_sxtah (void)
d5431 1
a5431 5
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 10;
}
d5433 2
a5434 1
/* ARM V6 SXTH.
d5436 1
a5436 10
   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */

static void
do_sxth (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 10;
a5437 3

/* VFP instructions.  In a logical order: SP variant first, monad
   before dyad, arithmetic then move then load/store.  */
d5440 1
a5440 1
do_vfp_sp_monadic (void)
d5442 1
a5442 2
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sm);
d5446 1
a5446 1
do_vfp_sp_dyadic (void)
d5448 1
a5448 3
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sn);
  encode_arm_vfp_sp_reg (inst.operands[2].reg, VFP_REG_Sm);
d5452 1
a5452 1
do_vfp_sp_compare_z (void)
d5454 1
a5454 1
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
d5458 1
a5458 1
do_vfp_dp_sp_cvt (void)
d5460 1
a5460 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sm);
d5464 1
a5464 1
do_vfp_sp_dp_cvt (void)
d5466 1
a5466 2
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  inst.instruction |= inst.operands[1].reg;
d5470 1
a5470 1
do_vfp_reg_from_sp (void)
d5472 1
a5472 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sn);
d5476 1
a5476 1
do_vfp_reg2_from_sp2 (void)
d5478 1
a5478 5
  constraint (inst.operands[2].imm != 2,
	      _("only two consecutive VFP SP registers allowed here"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  encode_arm_vfp_sp_reg (inst.operands[2].reg, VFP_REG_Sm);
d5482 1
a5482 1
do_vfp_sp_from_reg (void)
d5484 1
a5484 3
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sn);
  inst.instruction |= inst.operands[1].reg << 12;
}
d5486 2
a5487 9
static void
do_vfp_sp2_from_reg2 (void)
{
  constraint (inst.operands[0].imm != 2,
	      _("only two consecutive VFP SP registers allowed here"));
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sm);
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}
d5489 1
a5489 5
static void
do_vfp_sp_ldst (void)
{
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_cp_address (1, FALSE, TRUE, 0);
d5493 1
a5493 1
do_vfp_dp_ldst (void)
d5495 2
a5496 3
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, FALSE, TRUE, 0);
}
d5498 1
a5498 12

static void
vfp_sp_ldstm (enum vfp_ldstm_type ldstm_type)
{
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
  else
    constraint (ldstm_type != VFP_LDSTMIA,
		_("this addressing mode requires base-register writeback"));
  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sd);
  inst.instruction |= inst.operands[1].imm;
d5502 1
a5502 1
vfp_dp_ldstm (enum vfp_ldstm_type ldstm_type)
d5504 2
a5505 1
  int count;
d5507 2
a5508 5
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
  else
    constraint (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX,
		_("this addressing mode requires base-register writeback"));
d5510 1
a5510 2
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
d5512 9
a5520 3
  count = inst.operands[1].imm << 1;
  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    count += 1;
d5522 9
a5530 1
  inst.instruction |= count;
d5534 1
a5534 1
do_vfp_sp_ldstmia (void)
d5536 1
a5536 1
  vfp_sp_ldstm (VFP_LDSTMIA);
d5540 1
a5540 1
do_vfp_sp_ldstmdb (void)
d5542 1
a5542 1
  vfp_sp_ldstm (VFP_LDSTMDB);
d5546 1
a5546 1
do_vfp_dp_ldstmia (void)
d5548 1
a5548 1
  vfp_dp_ldstm (VFP_LDSTMIA);
d5552 1
a5552 1
do_vfp_dp_ldstmdb (void)
d5554 6
a5559 1
  vfp_dp_ldstm (VFP_LDSTMDB);
d5563 1
a5563 1
do_vfp_xp_ldstmia (void)
d5565 2
a5566 2
  vfp_dp_ldstm (VFP_LDSTMIAX);
}
d5568 1
a5568 4
static void
do_vfp_xp_ldstmdb (void)
{
  vfp_dp_ldstm (VFP_LDSTMDBX);
a5569 2

/* FPA instructions.  Also in a logical order.	*/
d5571 4
a5574 6
static void
do_fpa_cmp (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}
d5577 1
a5577 1
do_fpa_ldmstm (void)
d5579 2
a5580 9
  inst.instruction |= inst.operands[0].reg << 12;
  switch (inst.operands[1].imm)
    {
    case 1: inst.instruction |= CP_T_X;		 break;
    case 2: inst.instruction |= CP_T_Y;		 break;
    case 3: inst.instruction |= CP_T_Y | CP_T_X; break;
    case 4:					 break;
    default: abort ();
    }
d5582 2
a5583 9
  if (inst.instruction & (PRE_INDEX | INDEX_UP))
    {
      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      constraint (inst.reloc.exp.X_op != O_constant
		  || inst.reloc.exp.X_add_number != 0,
		  _("this instruction does not support indexing"));
d5585 3
a5587 2
      if ((inst.instruction & PRE_INDEX) || inst.operands[2].writeback)
	inst.reloc.exp.X_add_number = 12 * inst.operands[1].imm;
d5589 3
a5591 2
      if (!(inst.instruction & INDEX_UP))
	inst.reloc.exp.X_add_number = -inst.reloc.exp.X_add_number;
d5593 3
a5595 6
      if (!(inst.instruction & PRE_INDEX) && inst.operands[2].writeback)
	{
	  inst.operands[2].preind = 0;
	  inst.operands[2].postind = 1;
	}
    }
d5597 2
a5598 1
  encode_arm_cp_address (2, TRUE, TRUE, 0);
a5599 2

/* iWMMXt instructions: strictly in alphabetical order.	 */
d5601 1
a5601 5
static void
do_iwmmxt_tandorc (void)
{
  constraint (inst.operands[0].reg != REG_PC, _("only r15 allowed here"));
}
d5603 1
a5603 6
static void
do_iwmmxt_textrc (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm;
}
d5606 1
a5606 1
do_iwmmxt_textrm (void)
d5608 1
a5608 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].imm;
}
d5610 2
a5611 7
static void
do_iwmmxt_tinsr (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].imm;
}
d5613 3
a5615 7
static void
do_iwmmxt_tmia (void)
{
  inst.instruction |= inst.operands[0].reg << 5;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}
d5617 3
a5619 8
static void
do_iwmmxt_waligni (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 20;
}
d5621 3
a5623 8
static void
do_iwmmxt_wmov (void)
{
  /* WMOV rD, rN is an alias for WOR rD, rN, rN.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}
d5625 2
a5626 6
static void
do_iwmmxt_wldstbh (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.reloc.exp.X_add_number *= 4;
  encode_arm_cp_address (1, TRUE, FALSE, BFD_RELOC_ARM_CP_OFF_IMM_S2);
d5629 1
a5629 9
static void
do_iwmmxt_wldstw (void)
{
  /* RIWR_RIWC clears .isreg for a control register.  */
  if (!inst.operands[0].isreg)
    {
      constraint ((inst.instruction & COND_MASK) != COND_ALWAYS, BAD_COND);
      inst.instruction |= 0xf0000000;
    }
d5631 1
a5631 3
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, TRUE, 0);
}
d5634 1
a5634 1
do_iwmmxt_wldstd (void)
d5636 4
a5639 3
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, FALSE, BFD_RELOC_ARM_CP_OFF_IMM_S2);
}
d5641 2
a5642 8
static void
do_iwmmxt_wshufh (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= ((inst.operands[2].imm & 0xf0) << 16);
  inst.instruction |= (inst.operands[2].imm & 0x0f);
}
d5644 3
a5646 11
static void
do_iwmmxt_wzero (void)
{
  /* WZERO reg is an alias for WANDN reg, reg, reg.  */
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[0].reg << 16;
}

/* Cirrus Maverick instructions.  Simple 2-, 3-, and 4-register
   operations first, then control, shift, and load/store.  */
d5648 3
a5650 1
/* Insns like "foo X,Y,Z".  */
d5652 3
a5654 7
static void
do_mav_triple (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}
d5656 4
a5659 10
/* Insns like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */

static void
do_mav_quad (void)
{
  inst.instruction |= inst.operands[0].reg << 5;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
d5662 2
a5663 3
/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
static void
do_mav_dspsc (void)
d5665 1
a5665 2
  inst.instruction |= inst.operands[1].reg << 12;
}
d5667 7
a5673 3
/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */
d5675 3
a5677 4
static void
do_mav_shift (void)
{
  int imm = inst.operands[2].imm;
d5679 5
a5683 2
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
d5685 5
a5689 4
  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.	 */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);
d5691 8
a5698 4
  inst.instruction |= imm;
}

/* XScale instructions.	 Also sorted arithmetic before move.  */
d5700 3
a5702 4
/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */
d5704 3
a5706 6
static void
do_xsc_mia (void)
{
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}
d5708 3
a5710 1
/* Xscale move-accumulator-register (argument parse)
d5712 3
a5714 1
     MARcc   acc0,RdLo,RdHi.  */
d5716 2
a5717 5
static void
do_xsc_mar (void)
{
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
d5720 3
a5722 1
/* Xscale move-register-accumulator (argument parse)
d5724 1
a5724 1
     MRAcc   RdLo,RdHi,acc0.  */
d5727 1
a5727 1
do_xsc_mra (void)
d5729 1
a5729 6
  constraint (inst.operands[0].reg == inst.operands[1].reg, BAD_OVERLAP);
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
}

/* Encoding functions relevant only to Thumb.  */
d5731 1
a5731 8
/* inst.operands[i] is a shifted-register operand; encode
   it into inst.instruction in the format used by Thumb32.  */

static void
encode_thumb32_shifted_operand (int i)
{
  unsigned int value = inst.reloc.exp.X_add_number;
  unsigned int shift = inst.operands[i].shift_kind;
d5733 1
a5733 4
  inst.instruction |= inst.operands[i].reg;
  if (shift == SHIFT_RRX)
    inst.instruction |= SHIFT_ROR << 4;
  else
d5735 2
a5736 16
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));

      constraint (value > 32
		  || (value == 32 && (shift == SHIFT_LSL
				      || shift == SHIFT_ROR)),
		  _("shift expression is too large"));

      if (value == 0)
	shift = SHIFT_LSL;
      else if (value == 32)
	value = 0;

      inst.instruction |= shift << 4;
      inst.instruction |= (value & 0x1c) << 10;
      inst.instruction |= (value & 0x03) << 6;
a5737 1
}
d5739 2
d5742 2
a5743 5
/* inst.operands[i] was set up by parse_address.  Encode it into a
   Thumb32 format load or store instruction.  Reject forms that cannot
   be used with such instructions.  If is_t is true, reject forms that
   cannot be used with a T instruction; if is_d is true, reject forms
   that cannot be used with a D instruction.  */
d5745 1
a5745 4
static void
encode_thumb32_addr_mode (int i, bfd_boolean is_t, bfd_boolean is_d)
{
  bfd_boolean is_pc = (inst.operands[i].reg == REG_PC);
d5747 1
a5747 5
  constraint (!inst.operands[i].isreg,
	      _("Thumb does not support the ldr =N pseudo-operation"));

  inst.instruction |= inst.operands[i].reg << 16;
  if (inst.operands[i].immisreg)
d5749 3
a5751 10
      constraint (is_pc, _("cannot use register index with PC-relative addressing"));
      constraint (is_t || is_d, _("cannot use register index with this instruction"));
      constraint (inst.operands[i].negative,
		  _("Thumb does not support negative register indexing"));
      constraint (inst.operands[i].postind,
		  _("Thumb does not support register post-indexing"));
      constraint (inst.operands[i].writeback,
		  _("Thumb does not support register indexing with writeback"));
      constraint (inst.operands[i].shifted && inst.operands[i].shift_kind != SHIFT_LSL,
		  _("Thumb supports only LSL in shifted register indexing"));
d5753 8
a5760 2
      inst.instruction |= inst.operands[1].imm;
      if (inst.operands[i].shifted)
d5762 2
a5763 5
	  constraint (inst.reloc.exp.X_op != O_constant,
		      _("expression too complex"));
	  constraint (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 3,
		      _("shift out of range"));
	  inst.instruction |= inst.reloc.exp.X_op << 4;
d5765 2
a5766 1
      inst.reloc.type = BFD_RELOC_UNUSED;
d5768 1
a5768 142
  else if (inst.operands[i].preind)
    {
      constraint (is_pc && inst.operands[i].writeback,
		  _("cannot use writeback with PC-relative addressing"));
      constraint (is_t && inst.operands[1].writeback,
		  _("cannot use writeback with this instruction"));

      if (is_d)
	{
	  inst.instruction |= 0x01000000;
	  if (inst.operands[i].writeback)
	    inst.instruction |= 0x00200000;
	}
      else
	{
	  inst.instruction |= 0x00000c00;
	  if (inst.operands[i].writeback)
	    inst.instruction |= 0x00000100;
	}
      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
    }
  else if (inst.operands[i].postind)
    {
      assert (inst.operands[i].writeback);
      constraint (is_pc, _("cannot use post-indexing with PC-relative addressing"));
      constraint (is_t, _("cannot use post-indexing with this instruction"));

      if (is_d)
	inst.instruction |= 0x00200000;
      else
	inst.instruction |= 0x00000900;
      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
    }
  else /* unindexed - only for coprocessor */
    inst.error = _("instruction does not accept unindexed addressing");
}

/* Table of Thumb instructions which exist in both 16- and 32-bit
   encodings (the latter only in post-V6T2 cores).  The index is the
   value used in the insns table below.  When there is more than one
   possible 16-bit encoding for the instruction, this table always
   holds variant (1).  */
#define T16_32_TAB				\
  X(adc,   4140, eb400000),			\
  X(adcs,  4140, eb500000),			\
  X(add,   1c00, eb000000),			\
  X(adds,  1c00, eb100000),			\
  X(and,   4000, ea000000),			\
  X(ands,  4000, ea100000),			\
  X(asr,   1000, fa40f000),			\
  X(asrs,  1000, fa50f000),			\
  X(bic,   4380, ea200000),			\
  X(bics,  4380, ea300000),			\
  X(blx,   4780, f000c000),			\
  X(cmn,   42c0, eb100f00),			\
  X(cmp,   2800, ebb00f00),			\
  X(cpsie, b660, f3af8400),			\
  X(cpsid, b670, f3af8600),			\
  X(cpy,   4600, ea4f0000),			\
  X(eor,   4040, ea800000),			\
  X(eors,  4040, ea900000),			\
  X(ldmia, c800, e8900000),			\
  X(ldr,   6800, f8500000),			\
  X(ldrb,  7800, f8100000),			\
  X(ldrh,  8800, f8300000),			\
  X(ldrsb, 5600, f9100000),			\
  X(ldrsh, 5e00, f9300000),			\
  X(lsl,   0000, fa00f000),			\
  X(lsls,  0000, fa10f000),			\
  X(lsr,   0800, fa20f000),			\
  X(lsrs,  0800, fa30f000),			\
  X(mov,   2000, ea4f0000),			\
  X(movs,  2000, ea5f0000),			\
  X(mul,   4340, fb00f000),                     \
  X(muls,  4340, ffffffff), /* no 32b muls */	\
  X(mvn,   43c0, ea6f0000),			\
  X(mvns,  43c0, ea7f0000),			\
  X(neg,   4240, f1c00000), /* rsb #0 */	\
  X(negs,  4240, f1d00000), /* rsbs #0 */	\
  X(orr,   4300, ea400000),			\
  X(orrs,  4300, ea500000),			\
  X(pop,   bc00, e8ad0000), /* ldmia sp!,... */	\
  X(push,  b400, e8bd0000), /* stmia sp!,... */	\
  X(rev,   ba00, fa90f080),			\
  X(rev16, ba40, fa90f090),			\
  X(revsh, bac0, fa90f0b0),			\
  X(ror,   41c0, fa60f000),			\
  X(rors,  41c0, fa70f000),			\
  X(sbc,   4180, eb600000),			\
  X(sbcs,  4180, eb700000),			\
  X(stmia, c000, e8800000),			\
  X(str,   6000, f8400000),			\
  X(strb,  7000, f8000000),			\
  X(strh,  8000, f8200000),			\
  X(sub,   1e00, eba00000),			\
  X(subs,  1e00, ebb00000),			\
  X(sxtb,  b240, fa4ff080),			\
  X(sxth,  b200, fa0ff080),			\
  X(tst,   4200, ea100f00),			\
  X(uxtb,  b2c0, fa5ff080),			\
  X(uxth,  b280, fa1ff080),			\
  X(nop,   bf00, f3af8000),			\
  X(yield, bf10, f3af8001),			\
  X(wfe,   bf20, f3af8002),			\
  X(wfi,   bf30, f3af8003),			\
  X(sev,   bf40, f3af9004), /* typo, 8004? */

/* To catch errors in encoding functions, the codes are all offset by
   0xF800, putting them in one of the 32-bit prefix ranges, ergo undefined
   as 16-bit instructions.  */
#define X(a,b,c) T_MNEM_##a
enum t16_32_codes { T16_32_OFFSET = 0xF7FF, T16_32_TAB };
#undef X

#define X(a,b,c) 0x##b
static const unsigned short thumb_op16[] = { T16_32_TAB };
#define THUMB_OP16(n) (thumb_op16[(n) - (T16_32_OFFSET + 1)])
#undef X

#define X(a,b,c) 0x##c
static const unsigned int thumb_op32[] = { T16_32_TAB };
#define THUMB_OP32(n) (thumb_op32[(n) - (T16_32_OFFSET + 1)])
#define THUMB_SETS_FLAGS(n) (THUMB_OP32 (n) & 0x00100000)
#undef X
#undef T16_32_TAB

/* Thumb instruction encoders, in alphabetical order.  */

/* Parse an add or subtract instruction.  We get here with inst.instruction
   equalling any of THUMB_OPCODE_add, adds, sub, or subs.  */

static void
do_t_add_sub (void)
{
  int Rd, Rs, Rn;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */

  if (thumb32_mode)
d5770 1
a5770 1
      if (!inst.operands[2].isreg)
d5772 2
a5773 7
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].reg << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
a5774 16
      else
	{
	  Rn = inst.operands[2].reg;
	  /* See if we can do this with a 16-bit instruction.  */
	  if (!inst.operands[2].shifted && inst.size_req != 4)
	    {
	      if (Rd <= 7 && Rn <= 7 && Rn <= 7
		  && (inst.instruction == T_MNEM_adds
		      || inst.instruction == T_MNEM_subs))
		{
		  inst.instruction = (inst.instruction == T_MNEM_adds
				      ? T_OPCODE_ADD_R3
				      : T_OPCODE_SUB_R3);
		  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
		  return;
		}
d5776 4
a5779 35
	      if (inst.instruction == T_MNEM_add)
		{
		  if (Rd == Rs)
		    {
		      inst.instruction = T_OPCODE_ADD_HI;
		      inst.instruction |= (Rd & 8) << 4;
		      inst.instruction |= (Rd & 7);
		      inst.instruction |= Rn << 3;
		      return;
		    }
		  /* ... because addition is commutative! */
		  else if (Rd == Rn)
		    {
		      inst.instruction = T_OPCODE_ADD_HI;
		      inst.instruction |= (Rd & 8) << 4;
		      inst.instruction |= (Rd & 7);
		      inst.instruction |= Rs << 3;
		      return;
		    }
		}
	    }
	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
    }
  else
    {
      constraint (inst.instruction == T_MNEM_adds
		  || inst.instruction == T_MNEM_subs,
		  BAD_THUMB32);
d5781 1
a5781 1
      if (!inst.operands[2].isreg) /* Rd, Rs, #imm */
d5783 1
a5783 8
	  constraint ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
		      || (Rs > 7 && Rs != REG_SP && Rs != REG_PC),
		      BAD_HIREG);

	  inst.instruction = (inst.instruction == T_MNEM_add
			      ? 0x0000 : 0x8000);
	  inst.instruction |= (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
d5787 2
a5788 2
      Rn = inst.operands[2].reg;
      constraint (inst.operands[2].shifted, _("unshifted register required"));
d5790 1
a5790 2
      /* We now have Rd, Rs, and Rn set to registers.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
d5792 2
a5793 17
	  /* Can't do this for SUB.	 */
	  constraint (inst.instruction == T_MNEM_sub, BAD_HIREG);
	  inst.instruction = T_OPCODE_ADD_HI;
	  inst.instruction |= (Rd & 8) << 4;
	  inst.instruction |= (Rd & 7);
	  if (Rs == Rd)
	    inst.instruction |= Rn << 3;
	  else if (Rn == Rd)
	    inst.instruction |= Rs << 3;
	  else
	    constraint (1, _("dest must overlap one source register"));
	}
      else
	{
	  inst.instruction = (inst.instruction == T_MNEM_add
			      ? T_OPCODE_ADD_R3 : T_OPCODE_SUB_R3);
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
d5795 2
d5798 2
d5802 6
d5809 1
a5809 1
do_t_adr (void)
d5811 2
a5812 3
  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;
d5814 1
a5814 2
  inst.instruction |= inst.operands[0].reg << 4;
}
d5816 5
a5820 10
/* Arithmetic instructions for which there is just one 16-bit
   instruction encoding, and it allows only two low registers.
   For maximal compatibility with ARM syntax, we allow three register
   operands even when Thumb-32 instructions are not available, as long
   as the first two are identical.  For instance, both "sbc r0,r1" and
   "sbc r0,r0,r1" are allowed.  */
static void
do_t_arit3 (void)
{
  int Rd, Rs, Rn;
d5822 7
a5828 31
  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
  Rn = inst.operands[2].reg;

  if (thumb32_mode)
    {
      if (!inst.operands[2].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  /* See if we can do this with a 16-bit instruction.  */
	  if (THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[2].shifted
	      && inst.size_req != 4
	      && Rd == Rs)
	    {
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= Rd;
	      inst.instruction |= Rn << 3;
	      return;
	    }
d5830 5
a5834 9
	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted
		      && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
d5836 2
a5837 1
  else
d5839 3
a5841 4
      /* On its face this is a lie - the instruction does set the
	 flags.  However, the only supported mnemonic in this mode
	 says it doesn't.  */
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
d5843 11
a5853 5
      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
		  _("unshifted register required"));
      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);
      constraint (Rd != Rs,
		  _("dest and source1 must be the same register"));
d5855 2
a5856 3
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;
      inst.instruction |= Rn << 3;
d5858 2
d5862 5
a5866 7
/* Similarly, but for instructions where the arithmetic operation is
   commutative, so we can allow either of them to be different from
   the destination operand in a 16-bit instruction.  For instance, all
   three of "adc r0,r1", "adc r0,r0,r1", and "adc r0,r1,r0" are
   accepted.  */
static void
do_t_arit3c (void)
d5868 5
a5872 1
  int Rd, Rs, Rn;
d5874 1
a5874 5
  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
  Rn = inst.operands[2].reg;
d5876 3
a5878 1
  if (thumb32_mode)
d5880 1
a5880 1
      if (!inst.operands[2].isreg)
d5882 11
a5892 7
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
d5894 13
a5906 1
      else
d5908 1
a5908 4
	  /* See if we can do this with a 16-bit instruction.  */
	  if (THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[2].shifted
	      && inst.size_req != 4)
d5910 1
a5910 1
	      if (Rd == Rs)
d5912 2
a5913 4
		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= Rd;
		  inst.instruction |= Rn << 3;
		  return;
d5915 2
a5916 1
	      if (Rd == Rn)
d5918 3
a5920 4
		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= Rd;
		  inst.instruction |= Rs << 3;
		  return;
a5922 9

	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted
		      && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
a5924 6
  else
    {
      /* On its face this is a lie - the instruction does set the
	 flags.  However, the only supported mnemonic in this mode
	 says it doesn't.  */
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
d5926 4
a5929 3
      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
		  _("unshifted register required"));
      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);
d5931 10
a5940 9
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;

      if (Rd == Rs)
	inst.instruction |= Rn << 3;
      else if (Rd == Rn)
	inst.instruction |= Rn << 3;
      else
	constraint (1, _("dest must overlap one source register"));
d5944 13
a5956 2
static void
do_t_bfc (void)
d5958 2
a5959 9
  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[1].imm & 0x03) << 6;
  inst.instruction |= msb - 1;
}
d5961 2
a5962 4
static void
do_t_bfi (void)
{
  unsigned int msb;
d5964 8
a5971 4
  /* #0 in second position is alternative syntax for bfc, which is
     the same instruction but with REG_PC in the Rm field.  */
  if (!inst.operands[1].isreg)
    inst.operands[1].reg = REG_PC;
d5973 4
a5976 10
  msb = inst.operands[2].imm + inst.operands[3].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
  inst.instruction |= msb - 1;
}
d5978 4
a5981 11
static void
do_t_bfx (void)
{
  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
	      _("bit-field extends past end of register"));
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
  inst.instruction |= inst.operands[3].imm - 1;
}
d5983 15
a5997 6
/* ARM V5 Thumb BLX (argument parse)
	BLX <target_addr>	which is BLX(1)
	BLX <Rm>		which is BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
d5999 4
a6002 2
   ??? How to take advantage of the additional two bits of displacement
   available in Thumb32 mode?  Need new relocation?  */
d6004 4
a6007 14
static void
do_t_blx (void)
{
  if (inst.operands[0].isreg)
    /* We have a register, so this is BLX(2).  */
    inst.instruction |= inst.operands[0].reg << 3;
  else
    {
      /* No register.  This must be BLX(1).  */
      inst.instruction = 0xf7ffeffe;
      inst.reloc.type	= BFD_RELOC_THUMB_PCREL_BLX;
      inst.reloc.pc_rel = 1;
    }
}
d6009 4
a6012 23
static void
do_t_branch (void)
{
  if (thumb32_mode && inst.size_req != 2)
    {
      if (inst.instruction == T_OPCODE_BRANCH)
	{
	  inst.instruction = 0xf7ffbffe;
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH25;
	}
      else
	{
	  int cond = inst.instruction & 0x0f00;
	  constraint (cond == 0xE00 || cond == 0xF00,
		      _("invalid condition for wide conditional branch"));
	  inst.instruction = (cond << 14) | 0xf43faffe;
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH20;
	}
    }
  else
    inst.reloc.type = (inst.instruction == T_OPCODE_BRANCH
		       ? BFD_RELOC_THUMB_PCREL_BRANCH12
		       : BFD_RELOC_THUMB_PCREL_BRANCH9);
d6014 4
a6017 2
  inst.reloc.pc_rel = 1;
}
d6019 3
a6021 8
static void
do_t_bkpt (void)
{
  if (inst.operands[0].present)
    {
      constraint (inst.operands[0].imm > 255,
		  _("immediate value out of range"));
      inst.instruction |= inst.operands[0].imm;
a6022 1
}
d6024 2
a6025 5
static void
do_t_branch23 (void)
{
  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
  inst.reloc.pc_rel = 1;
d6027 3
a6029 10
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.	*/
  if (	 inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
d6032 2
a6033 2
static void
do_t_bx (void)
d6035 2
a6036 11
  inst.instruction |= inst.operands[0].reg << 3;
  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.	 The reloc
     should cause the alignment to be checked once it is known.	 This is
     because BX PC only works if the instruction is word aligned.  */
}

static void
do_t_bxj (void)
{
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));
d6038 1
a6038 2
  inst.instruction |= inst.operands[0].reg << 16;
}
d6040 5
a6044 7
static void
do_t_clz (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}
d6046 1
a6046 12
static void
do_t_cpsi (void)
{
  if (thumb32_mode
      && (inst.operands[1].present || inst.size_req == 4))
    {
      unsigned int imod = (inst.instruction & 0x0030) >> 4;
      inst.instruction = 0xf3af8000;
      inst.instruction |= imod << 9;
      inst.instruction |= inst.operands[0].imm << 5;
      if (inst.operands[1].present)
	inst.instruction |= 0x100 | inst.operands[1].imm;
d6050 21
a6070 6
      constraint (inst.operands[1].present,
		  _("Thumb does not support the 2-argument "
		    "form of this instruction"));
      inst.instruction |= inst.operands[0].imm;
    }
}
d6072 5
a6076 1
/* THUMB CPY instruction (argument parse).  */
d6078 13
a6090 16
static void
do_t_cpy (void)
{
  if (inst.size_req == 4)
    {
      inst.instruction = THUMB_OP32 (T_MNEM_mov);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg;
    }
  else
    {
      inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
      inst.instruction |= (inst.operands[0].reg & 0x7);
      inst.instruction |= inst.operands[1].reg << 3;
    }
}
d6092 2
a6093 8
static void
do_t_czb (void)
{
  constraint (inst.operands[0].reg > 7, BAD_HIREG);
  inst.instruction |= inst.operands[0].reg;
  inst.reloc.pc_rel = 1;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH7;
}
d6095 12
a6106 8
static void
do_t_hint (void)
{
  if (thumb32_mode && inst.size_req == 4)
    inst.instruction = THUMB_OP32 (inst.instruction);
  else
    inst.instruction = THUMB_OP16 (inst.instruction);
}
d6108 2
a6109 8
static void
do_t_it (void)
{
  unsigned int cond = inst.operands[0].imm;
  if ((cond & 0x1) == 0x0)
    {
      unsigned int mask = inst.instruction & 0x000f;
      inst.instruction &= 0xfff0;
d6111 3
a6113 8
      if ((mask & 0x7) == 0)
	/* no conversion needed */;
      else if ((mask & 0x3) == 0)
	mask = (~(mask & 0x8) & 0x8) | 0x4;
      else if ((mask & 1) == 0)
	mask = (~(mask & 0xC) & 0xC) | 0x2;
      else
	mask = (~(mask & 0xE) & 0xE) | 0x1;
d6115 3
a6117 1
      inst.instruction |= (mask & 0xF);
a6118 2

  inst.instruction |= cond << 4;
d6121 2
a6122 2
static void
do_t_ldmstm (void)
d6124 1
a6124 5
  /* This really doesn't seem worth it.  */
  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
	      _("expression too complex"));
  constraint (inst.operands[1].writeback,
	      _("Thumb load/store multiple does not support {reglist}^"));
d6126 3
a6128 1
  if (thumb32_mode)
d6130 2
a6131 9
      /* See if we can use a 16-bit instruction.  */
      if (inst.instruction < 0xffff /* not ldmdb/stmdb */
	  && inst.size_req != 4
	  && inst.operands[0].reg <= 7
	  && !(inst.operands[1].imm & ~0xff)
	  && (inst.instruction == T_MNEM_stmia
	      ? inst.operands[0].writeback
	      : (inst.operands[0].writeback
		 == !(inst.operands[1].imm & (1 << inst.operands[0].reg)))))
d6133 1
a6133 5
	  if (inst.instruction == T_MNEM_stmia
	      && (inst.operands[1].imm & (1 << inst.operands[0].reg))
	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
	    as_warn (_("value stored for r%d is UNPREDICTABLE"),
		     inst.operands[0].reg);
d6135 8
a6142 9
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].imm;
	}
      else
	{
	  if (inst.operands[1].imm & (1 << 13))
	    as_warn (_("SP should not be in register list"));
	  if (inst.instruction == T_MNEM_stmia)
d6144 12
a6155 5
	      if (inst.operands[1].imm & (1 << 15))
		as_warn (_("PC should not be in register list"));
	      if (inst.operands[1].imm & (1 << inst.operands[0].reg))
		as_warn (_("value stored for r%d is UNPREDICTABLE"),
			 inst.operands[0].reg);
d6157 6
a6162 1
	  else
d6164 2
a6165 7
	      if (inst.operands[1].imm & (1 << 14)
		  && inst.operands[1].imm & (1 << 15))
		as_warn (_("LR and PC should not both be in register list"));
	      if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
		  && inst.operands[0].writeback)
		as_warn (_("base register should not be in register list "
			   "when written back"));
d6167 3
a6169 6
	  if (inst.instruction < 0xffff)
	    inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 16;
	  inst.instruction |= inst.operands[1].imm;
	  if (inst.operands[0].writeback)
	    inst.instruction |= WRITE_BACK;
d6171 3
a6173 27
    }
  else
    {
      constraint (inst.operands[0].reg > 7
		  || (inst.operands[1].imm & ~0xff), BAD_HIREG);
      if (inst.instruction == T_MNEM_stmia)
	{
	  if (!inst.operands[0].writeback)
	    as_warn (_("this instruction will write back the base register"));
	  if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
	    as_warn (_("value stored for r%d is UNPREDICTABLE"),
		     inst.operands[0].reg);
	}
      else
	{
	  if (!inst.operands[0].writeback
	      && !(inst.operands[1].imm & (1 << inst.operands[0].reg)))
	    as_warn (_("this instruction will write back the base register"));
	  else if (inst.operands[0].writeback
		   && (inst.operands[1].imm & (1 << inst.operands[0].reg)))
	    as_warn (_("this instruction will not write back the base register"));
	}

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].imm;
d6178 1
a6178 1
do_t_ldrex (void)
d6180 12
a6191 5
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
	      || inst.operands[1].postind || inst.operands[1].writeback
	      || inst.operands[1].immisreg || inst.operands[1].shifted
	      || inst.operands[1].negative,
	      _("instruction does not accept this addressing mode"));
d6193 1
a6193 3
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
d6197 1
a6197 1
do_t_ldrexd (void)
d6199 7
a6205 1
  if (!inst.operands[1].present)
d6207 3
a6209 4
      constraint (inst.operands[0].reg == REG_LR,
		  _("r14 not allowed as first register "
		    "when second register is omitted"));
      inst.operands[1].reg = inst.operands[0].reg + 1;
a6210 2
  constraint (inst.operands[0].reg == inst.operands[1].reg,
	      BAD_OVERLAP);
d6212 9
a6220 3
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
d6224 1
a6224 1
do_t_ldst (void)
d6226 10
a6235 1
  if (thumb32_mode)
d6237 2
a6238 11
      /* Generation of 16-bit instructions for anything other than
	 Rd, [Rn, Ri] is deferred to section relaxation time.  */
      if (inst.operands[1].isreg && inst.operands[1].immisreg
	  && !inst.operands[1].shifted && !inst.operands[1].postind
	  && !inst.operands[1].negative && inst.operands[0].reg <= 7
	  && inst.operands[1].reg <= 7 && inst.operands[1].imm <= 7
	  && inst.instruction <= 0xffff)
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  goto op16;
	}
a6239 3
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 12;
      encode_thumb32_addr_mode (1, /*is_t=*/FALSE, /*is_d=*/FALSE);
d6243 10
a6252 1
  constraint (inst.operands[0].reg > 7, BAD_HIREG);
d6254 4
a6257 16
  if (inst.instruction == T_MNEM_ldrsh || inst.instruction == T_MNEM_ldrsb)
    {
      /* Only [Rn,Rm] is acceptable.  */
      constraint (inst.operands[1].reg > 7 || inst.operands[1].imm > 7, BAD_HIREG);
      constraint (!inst.operands[1].isreg || !inst.operands[1].immisreg
		  || inst.operands[1].postind || inst.operands[1].shifted
		  || inst.operands[1].negative,
		  _("Thumb does not support this addressing mode"));
      inst.instruction = THUMB_OP16 (inst.instruction);
      goto op16;
    }
     
  inst.instruction = THUMB_OP16 (inst.instruction);
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/TRUE, /*mode_3=*/FALSE))
      return;
d6259 1
a6259 5
  constraint (!inst.operands[1].preind
	      || inst.operands[1].shifted
	      || inst.operands[1].writeback,
	      _("Thumb does not support this addressing mode"));
  if (inst.operands[1].reg == REG_PC || inst.operands[1].reg == REG_SP)
d6261 2
a6262 19
      constraint (inst.instruction & 0x0600,
		  _("byte or halfword not valid for base register"));
      constraint (inst.operands[1].reg == REG_PC
		  && !(inst.instruction & THUMB_LOAD_BIT),
		  _("r15 based store not allowed"));
      constraint (inst.operands[1].immisreg,
		  _("invalid base register for register offset"));

      if (inst.operands[1].reg == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (inst.instruction & THUMB_LOAD_BIT)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;

      inst.instruction |= inst.operands[0].reg << 8;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      if (inst.reloc.pc_rel)
	inst.reloc.exp.X_add_number -= 4;  /* pipeline offset */
d6266 2
a6267 2
  constraint (inst.operands[1].reg > 7, BAD_HIREG);
  if (!inst.operands[1].immisreg)
d6269 2
a6270 4
      /* Immediate offset.  */
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
d6274 7
a6280 4
  /* Register offset.  */
  constraint (inst.operands[1].imm > 7, BAD_HIREG);
  constraint (inst.operands[1].negative,
	      _("Thumb does not support this addressing mode"));
d6282 1
a6282 2
 op16:
  switch (inst.instruction)
d6284 3
a6286 9
    case T_OPCODE_STR_IW: inst.instruction = T_OPCODE_STR_RW; break;
    case T_OPCODE_STR_IH: inst.instruction = T_OPCODE_STR_RH; break;
    case T_OPCODE_STR_IB: inst.instruction = T_OPCODE_STR_RB; break;
    case T_OPCODE_LDR_IW: inst.instruction = T_OPCODE_LDR_RW; break;
    case T_OPCODE_LDR_IH: inst.instruction = T_OPCODE_LDR_RH; break;
    case T_OPCODE_LDR_IB: inst.instruction = T_OPCODE_LDR_RB; break;
    case 0x5600 /* ldrsb */:
    case 0x5e00 /* ldrsh */: break;
    default: abort ();
d6289 2
a6290 9
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 3;
  inst.instruction |= inst.operands[1].imm << 6;
}

static void
do_t_ldstd (void)
{
  if (!inst.operands[1].present)
d6292 3
a6294 3
      inst.operands[1].reg = inst.operands[0].reg + 1;
      constraint (inst.operands[0].reg == REG_LR,
		  _("r14 not allowed here"));
a6295 5
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  encode_thumb32_addr_mode (2, /*is_t=*/FALSE, /*is_d=*/TRUE);
			    
}
d6297 1
a6297 5
static void
do_t_ldstt (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_thumb32_addr_mode (1, /*is_t=*/TRUE, /*is_d=*/FALSE);
d6301 1
a6301 1
do_t_mla (void)
d6303 3
a6305 5
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 12;
}
d6307 1
a6307 8
static void
do_t_mlal (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
}
d6309 1
a6309 4
static void
do_t_mov_cmp (void)
{
  if (thumb32_mode)
d6311 2
a6312 54
      int r0off = (inst.instruction == T_MNEM_mov
		   || inst.instruction == T_MNEM_movs) ? 8 : 16;
      if (!inst.operands[1].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << r0off;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else if (inst.size_req == 4
	       || inst.operands[1].shifted
	       || (inst.instruction == T_MNEM_movs
		   && (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)))
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << r0off;
	  encode_thumb32_shifted_operand (1);
	}
      else
	switch (inst.instruction)
	  {
	  case T_MNEM_mov:
	    inst.instruction = T_OPCODE_MOV_HR;
	    inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
	    inst.instruction |= (inst.operands[0].reg & 0x7);
	    inst.instruction |= inst.operands[1].reg << 3;
	    break;

	  case T_MNEM_movs:
	    /* We know we have low registers at this point.
	       Generate ADD Rd, Rs, #0.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	    inst.instruction |= inst.operands[0].reg;
	    inst.instruction |= inst.operands[1].reg << 3;
	    break;

	  case T_MNEM_cmp:
	    if (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7)
	      {
		inst.instruction = T_OPCODE_CMP_LR;
		inst.instruction |= inst.operands[0].reg;
		inst.instruction |= inst.operands[1].reg << 3;
	      }
	    else
	      {
		inst.instruction = T_OPCODE_CMP_HR;
		inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
		inst.instruction |= (inst.operands[0].reg & 0x7);
		inst.instruction |= inst.operands[1].reg << 3;
	      }
	    break;
	  }
d6316 1
a6316 2
  inst.instruction = THUMB_OP16 (inst.instruction);
  if (inst.operands[1].isreg)
d6318 3
a6320 8
      if (inst.operands[0].reg < 8 && inst.operands[1].reg < 8)
	{
	  /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	     since a MOV instruction produces unpredictable results.  */
	  if (inst.instruction == T_OPCODE_MOV_I8)
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;
d6322 1
a6322 13
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
	}
      else
	{
	  if (inst.instruction == T_OPCODE_MOV_I8)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else
	    inst.instruction = T_OPCODE_CMP_HR;
	  do_t_cpy ();
	}
    }
  else
d6324 11
a6334 6
      constraint (inst.operands[0].reg > 7,
		  _("only lo regs allowed with immediate"));
      inst.instruction |= inst.operands[0].reg << 8;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
    }
}
d6336 1
a6336 9
static void
do_t_mov16 (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & 0xf000) << 4;
  inst.instruction |= (inst.operands[1].imm & 0x0800) << 15;
  inst.instruction |= (inst.operands[1].imm & 0x0700) << 4;
  inst.instruction |= (inst.operands[1].imm & 0x00ff);
}
d6338 1
a6338 8
static void
do_t_mvn_tst (void)
{
  if (thumb32_mode)
    {
      int r0off = (inst.instruction == T_MNEM_mvn
		   || inst.instruction == T_MNEM_mvns) ? 8 : 16;
      if (!inst.operands[1].isreg)
d6340 3
a6342 17
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  if (inst.instruction < 0xffff)
	    inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << r0off;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  /* See if we can do this with a 16-bit instruction.  */
	  if (inst.instruction < 0xffff
	      && THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[1].shifted
	      && inst.operands[0].reg <= 7
	      && inst.operands[1].reg <= 7
	      && inst.size_req != 4)
d6344 7
a6350 3
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
d6354 15
a6368 7
	      constraint (inst.operands[1].shifted
			  && inst.operands[1].immisreg,
			  _("shift must be constant"));
	      if (inst.instruction < 0xffff)
		inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg << r0off;
	      encode_thumb32_shifted_operand (1);
d6371 8
a6378 9
    }
  else
    {
      constraint (inst.instruction > 0xffff
		  || inst.instruction == T_MNEM_mvns, BAD_THUMB32);
      constraint (!inst.operands[1].isreg || inst.operands[1].shifted,
		  _("unshifted register required"));
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);
d6380 3
a6382 5
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
}
d6384 1
a6384 10
static void
do_t_mrs (void)
{
  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
  constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
	      != (PSR_c|PSR_f),
	      _("'CPSR' or 'SPSR' expected"));
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & SPSR_BIT) >> 2;
}
d6386 5
a6390 9
static void
do_t_msr (void)
{
  constraint (!inst.operands[1].isreg,
	      _("Thumb encoding does not support an immediate here"));
  inst.instruction |= (inst.operands[0].imm & SPSR_BIT) >> 2;
  inst.instruction |= (inst.operands[0].imm & ~SPSR_BIT) >> 8;
  inst.instruction |= inst.operands[1].reg << 16;
}
d6392 1
a6392 5
static void
do_t_mul (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[0].reg;
d6394 10
a6403 7
  /* There is no 32-bit MULS and no 16-bit MUL. */
  if (thumb32_mode && inst.instruction == T_MNEM_mul)
    {
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg << 0;
d6405 1
a6405 1
  else
d6407 5
a6411 7
      constraint (!thumb32_mode
		  && inst.instruction == T_MNEM_muls, BAD_THUMB32);
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7, BAD_HIREG);
      constraint (inst.operands[0].reg != inst.operands[2].reg,
		  _("dest and source2 must be the same register"));
      if (inst.operands[0].reg == inst.operands[1].reg)
	as_tsktsk (_("dest and source must be different in MUL"));
d6413 2
a6414 5
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
}
d6416 1
a6416 7
static void
do_t_mull (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
d6418 2
a6419 3
  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rdhi and rdlo must be different"));
}
d6421 2
a6422 6
static void
do_t_nop (void)
{
  if (thumb32_mode)
    {
      if (inst.size_req == 4 || inst.operands[0].imm > 15)
d6424 2
a6425 2
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].imm;
d6427 2
a6428 1
      else
d6430 25
a6454 2
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].imm << 4;
a6455 8
    }
  else
    {
      constraint (inst.operands[0].present,
		  _("Thumb does not support NOP with hints"));
      inst.instruction = 0x46c0;
    }
}
d6457 2
a6458 8
static void
do_t_neg (void)
{
  if (thumb32_mode)
    {
      if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7
	  || !THUMB_SETS_FLAGS (inst.instruction)
	  || inst.size_req == 4)
d6460 3
a6462 9
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].reg << 16;
	}
      else
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
d6464 6
d6473 2
a6474 3
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
d6476 8
a6483 3
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
a6484 1
}
d6486 2
a6487 14
static void
do_t_pkhbt (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  if (inst.operands[3].present)
    {
      unsigned int val = inst.reloc.exp.X_add_number;
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
      inst.instruction |= (val & 0x1c) << 10;
      inst.instruction |= (val & 0x03) << 6;
    }
d6491 1
a6491 1
do_t_pkhtb (void)
d6493 1
a6493 4
  if (!inst.operands[3].present)
    inst.instruction &= ~0x00000020;
  do_t_pkhbt ();
}
d6495 1
a6495 5
static void
do_t_pld (void)
{
  encode_thumb32_addr_mode (0, /*is_t=*/FALSE, /*is_d=*/FALSE);
}
d6497 6
a6502 7
static void
do_t_push_pop (void)
{
  constraint (inst.operands[0].writeback,
	      _("push/pop do not support {reglist}^"));
  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
	      _("expression too complex"));
d6504 1
a6504 6
  if ((inst.operands[0].imm & ~0xff) == 0)
    inst.instruction = THUMB_OP16 (inst.instruction);
  else if ((inst.instruction == T_MNEM_push
	    && (inst.operands[0].imm & ~0xff) == 1 << REG_LR)
	   || (inst.instruction == T_MNEM_pop
	       && (inst.operands[0].imm & ~0xff) == 1 << REG_PC))
d6506 2
a6507 3
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= THUMB_PP_PC_LR;
      inst.operands[0].imm &= 0xff;
d6509 2
a6510 1
  else if (thumb32_mode)
d6512 19
a6530 3
      if (inst.operands[1].imm & (1 << 13))
	as_warn (_("SP should not be in register list"));
      if (inst.instruction == T_MNEM_push)
d6532 19
a6550 2
	  if (inst.operands[1].imm & (1 << 15))
	    as_warn (_("PC should not be in register list"));
d6554 2
a6555 3
	  if (inst.operands[1].imm & (1 << 14)
	      && inst.operands[1].imm & (1 << 15))
	    as_warn (_("LR and PC should not both be in register list"));
a6556 2

      inst.instruction = THUMB_OP32 (inst.instruction);
d6560 1
a6560 1
      inst.error = _("invalid register list to push/pop instruction");
d6564 1
a6564 1
  inst.instruction |= inst.operands[0].imm;
d6567 2
d6570 1
a6570 1
do_t_rbit (void)
d6572 5
a6576 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
}
d6578 1
a6578 5
static void
do_t_rev (void)
{
  if (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7
      && inst.size_req != 4)
d6580 3
a6582 3
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
d6584 2
a6585 1
  else if (thumb32_mode)
d6587 2
a6588 4
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[1].reg;
a6589 3
  else
    inst.error = BAD_HIREG;
}
d6591 7
a6597 4
static void
do_t_rsb (void)
{
  int Rd, Rs;
d6599 2
a6600 4
  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
d6602 2
a6603 10
  inst.instruction |= Rd << 8;
  inst.instruction |= Rs << 16;
  if (!inst.operands[2].isreg)
    {
      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
    }
  else
    encode_thumb32_shifted_operand (2);
}
d6605 1
a6605 6
static void
do_t_setend (void)
{
  if (inst.operands[0].imm)
    inst.instruction |= 0x8;
}
d6607 3
a6609 5
static void
do_t_shift (void)
{
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;
d6611 9
a6619 15
  if (thumb32_mode)
    {
      if (inst.operands[0].reg > 7
	  || inst.operands[1].reg > 7
	  || !THUMB_SETS_FLAGS (inst.instruction)
	  || (!inst.operands[2].isreg && inst.instruction == T_MNEM_rors)
	  || (inst.operands[2].isreg && inst.operands[1].reg != inst.operands[0].reg)
	  || inst.size_req == 4)
	{
	  if (inst.operands[2].isreg)
	    {
	      inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg << 8;
	      inst.instruction |= inst.operands[1].reg << 16;
	      inst.instruction |= inst.operands[2].reg;
d6623 6
a6628 2
	      inst.operands[1].shifted = 1;
	      switch (inst.instruction)
d6630 6
a6635 9
		case T_MNEM_asr:
		case T_MNEM_asrs: inst.operands[1].shift_kind = SHIFT_ASR; break;
		case T_MNEM_lsl:
		case T_MNEM_lsls: inst.operands[1].shift_kind = SHIFT_LSL; break;
		case T_MNEM_lsr:
		case T_MNEM_lsrs: inst.operands[1].shift_kind = SHIFT_LSR; break;
		case T_MNEM_ror:
		case T_MNEM_rors: inst.operands[1].shift_kind = SHIFT_ROR; break;
		default: abort ();
d6637 3
a6639 7
	      
	      inst.instruction = THUMB_OP32 (THUMB_SETS_FLAGS (inst.instruction)
					     ? T_MNEM_movs : T_MNEM_mov);
	      inst.instruction |= inst.operands[0].reg << 8;
	      encode_thumb32_shifted_operand (1);
	      /* Prevent the incorrect generation of an ARM_IMMEDIATE fixup.  */
	      inst.reloc.type = BFD_RELOC_UNUSED;
d6644 14
a6657 1
	  if (inst.operands[2].isreg)
d6659 2
a6660 11
	      switch (inst.instruction)
		{
		case T_MNEM_asrs: inst.instruction = T_OPCODE_ASR_R; break;
		case T_MNEM_lsls: inst.instruction = T_OPCODE_LSL_R; break;
		case T_MNEM_lsrs: inst.instruction = T_OPCODE_LSR_R; break;
		case T_MNEM_rors: inst.instruction = T_OPCODE_ROR_R; break;
		default: abort ();
		}
	  
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[2].reg << 3;
d6662 4
a6665 1
	  else
d6667 6
a6672 10
	      switch (inst.instruction)
		{
		case T_MNEM_asrs: inst.instruction = T_OPCODE_ASR_I; break;
		case T_MNEM_lsls: inst.instruction = T_OPCODE_LSL_I; break;
		case T_MNEM_lsrs: inst.instruction = T_OPCODE_LSR_I; break;
		default: abort ();
		}
	      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
d6676 1
a6676 1
  else
d6678 5
a6682 3
      constraint (inst.operands[0].reg > 7
		  || inst.operands[1].reg > 7, BAD_HIREG);
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
d6684 17
a6700 1
      if (inst.operands[2].isreg)  /* Rd, {Rs,} Rn */
d6702 13
a6714 3
	  constraint (inst.operands[2].reg > 7, BAD_HIREG);
	  constraint (inst.operands[0].reg != inst.operands[1].reg,
		      _("source1 and dest must be same register"));
d6716 1
a6716 1
	  switch (inst.instruction)
d6718 6
a6723 5
	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_R; break;
	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_R; break;
	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_R; break;
	    case T_MNEM_ror: inst.instruction = T_OPCODE_ROR_R; break;
	    default: abort ();
a6724 3
	  
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[2].reg << 3;
d6726 3
a6728 1
      else
d6730 3
a6732 11
	  switch (inst.instruction)
	    {
	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_I; break;
	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_I; break;
	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_I; break;
	    case T_MNEM_ror: inst.error = _("ror #imm not supported"); return;
	    default: abort ();
	    }
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
d6734 22
d6757 3
d6763 1
a6763 1
do_t_simd (void)
d6765 1
a6765 4
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
}
d6767 8
a6774 11
static void
do_t_smi (void)
{
  unsigned int value = inst.reloc.exp.X_add_number;
  constraint (inst.reloc.exp.X_op != O_constant,
	      _("expression too complex"));
  inst.reloc.type = BFD_RELOC_UNUSED;
  inst.instruction |= (value & 0xf000) >> 12;
  inst.instruction |= (value & 0x0ff0);
  inst.instruction |= (value & 0x000f) << 16;
}
d6776 5
a6780 6
static void
do_t_ssat (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm - 1;
  inst.instruction |= inst.operands[2].reg << 16;
d6782 1
a6782 1
  if (inst.operands[3].present)
d6784 5
a6788 2
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
d6790 35
a6824 1
      if (inst.reloc.exp.X_add_number != 0)
d6826 2
a6827 4
	  if (inst.operands[3].shift_kind == SHIFT_ASR)
	    inst.instruction |= 0x00200000;  /* sh bit */
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x1c) << 10;
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x03) << 6;
a6828 1
      inst.reloc.type = BFD_RELOC_UNUSED;
d6830 7
d6839 3
a6841 2
static void
do_t_ssat16 (void)
d6843 92
a6934 4
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm - 1;
  inst.instruction |= inst.operands[2].reg << 16;
}
d6936 9
a6944 8
static void
do_t_strex (void)
{
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative,
	      _("instruction does not accept this addressing mode"));
d6946 5
a6950 5
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
}
d6952 1
a6952 5
static void
do_t_strexd (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[1].reg + 1;
d6954 7
a6960 5
  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg
	      || inst.operands[0].reg == inst.operands[3].reg
	      || inst.operands[1].reg == inst.operands[2].reg,
	      BAD_OVERLAP);
d6962 2
a6963 4
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 16;
d6967 1
a6967 1
do_t_sxtah (void)
d6969 7
a6975 5
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 4;
}
d6977 1
a6977 6
static void
do_t_sxth (void)
{
  if (inst.instruction <= 0xffff && inst.size_req != 4
      && inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7
      && (!inst.operands[2].present || inst.operands[2].imm == 0))
d6979 2
a6980 3
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
d6982 4
a6985 1
  else if (thumb32_mode)
d6987 2
a6988 5
      if (inst.instruction <= 0xffff)
	inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg;
      inst.instruction |= inst.operands[2].imm << 4;
d6990 3
a6992 1
  else
d6994 3
a6996 3
      constraint (inst.operands[2].present && inst.operands[2].imm != 0,
		  _("Thumb encoding does not support rotation"));
      constraint (1, BAD_HIREG);
a6997 1
}
d6999 5
a7003 12
static void
do_t_swi (void)
{
  inst.reloc.type = BFD_RELOC_ARM_SWI;
}

static void
do_t_usat (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm;
  inst.instruction |= inst.operands[2].reg << 16;
d7005 1
a7005 1
  if (inst.operands[3].present)
d7007 12
a7018 3
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
      if (inst.reloc.exp.X_add_number != 0)
d7020 7
a7026 5
	  if (inst.operands[3].shift_kind == SHIFT_ASR)
	    inst.instruction |= 0x00200000;  /* sh bit */

	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x1c) << 10;
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x03) << 6;
a7027 1
      inst.reloc.type = BFD_RELOC_UNUSED;
d7029 3
d7035 1
a7035 1
do_t_usat16 (void)
d7037 12
a7048 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm;
  inst.instruction |= inst.operands[2].reg << 16;
a7049 9

/* Overall per-instruction processing.	*/

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.	We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */
d7052 1
a7052 6
fix_new_arm (fragS *	   frag,
	     int	   where,
	     short int	   size,
	     expressionS * exp,
	     int	   pc_rel,
	     int	   reloc)
d7054 1
a7054 1
  fixS *	   new_fix;
d7056 3
a7058 8
  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;
d7060 2
a7061 5
    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
    }
d7063 3
a7065 3
  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  new_fix->tc_fix_data = (PTR) thumb_mode;
d7069 1
a7069 1
output_inst (const char * str)
d7071 6
a7076 1
  char * to = NULL;
d7078 1
a7078 1
  if (inst.error)
d7080 1
a7080 1
      as_bad ("%s -- `%s'", inst.error, str);
d7084 7
a7090 1
  to = frag_more (inst.size);
d7092 1
a7092 1
  if (thumb_mode && (inst.size > THUMB_SIZE))
d7094 20
a7113 3
      assert (inst.size == (2 * THUMB_SIZE));
      md_number_to_chars (to, inst.instruction >> 16, THUMB_SIZE);
      md_number_to_chars (to + THUMB_SIZE, inst.instruction, THUMB_SIZE);
d7115 4
a7118 1
  else if (inst.size > INSN_SIZE)
d7120 2
a7121 3
      assert (inst.size == (2 * INSN_SIZE));
      md_number_to_chars (to, inst.instruction, INSN_SIZE);
      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
a7122 2
  else
    md_number_to_chars (to, inst.instruction, inst.size);
d7124 8
a7131 4
  if (inst.reloc.type != BFD_RELOC_UNUSED)
    fix_new_arm (frag_now, to - frag_now->fr_literal,
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
		 inst.reloc.type);
d7134 34
a7167 2
  dwarf2_emit_insn (inst.size);
#endif
d7170 2
a7171 2
void
md_assemble (char * str)
d7173 10
a7182 2
  char *p;
  const struct asm_opcode * opcode;
d7184 2
a7185 2
  /* Align the previous label if needed.  */
  if (last_label_seen != NULL)
d7187 3
a7189 3
      symbol_set_frag (last_label_seen, frag_now);
      S_SET_VALUE (last_label_seen, (valueT) frag_now_fix ());
      S_SET_SEGMENT (last_label_seen, now_seg);
d7192 7
a7198 2
  memset (&inst, '\0', sizeof (inst));
  inst.reloc.type = BFD_RELOC_UNUSED;
d7200 7
a7206 5
  /* Scan up to the end of the op-code, which must end in white space or
     end of string.  */
  for (p = str; *p != '\0'; p++)
    if (*p == ' ' || (thumb32_mode && *p == '.'))
      break;
d7208 2
a7209 1
  if (p == str)
d7211 2
a7212 1
      as_bad (_("no operator -- statement `%s'\n"), str);
d7216 1
a7216 2
  opcode = hash_find_n (arm_ops_hsh, str, p - str);
  if (opcode)
d7218 1
a7218 1
      if (thumb_mode)
d7220 5
a7224 8
	  /* Check that this instruction is supported for this CPU.  */
	  if (thumb_mode == 1 && (opcode->tvariant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }
	  mapping_state (MAP_THUMB);
	  inst.instruction = opcode->tvalue;
d7226 2
a7227 14
	  /* Check for .W or .N suffix.  */
	  if (thumb32_mode && p[0] == '.')
	    {
	      if (p[1] == 'w')
		inst.size_req = 4;
	      else if (p[1] == 'n')
		inst.size_req = 2;
	      else
		{
		  as_bad (_("unrecognized width suffix -- `%s'"), str);
		  return;
		}
	      p += 2;
	    }
d7229 5
a7233 2
	  if (!parse_operands (p, opcode->operands))
	    opcode->tencode ();
d7235 1
a7235 19
	  if (!inst.error)
	    {
	      assert (inst.instruction < 0xe800 || inst.instruction > 0xffff);
	      inst.size = (inst.instruction > 0xffff ? 4 : 2);
	      if (inst.size_req && inst.size_req != inst.size)
		{
		  as_bad (_("cannot honor width suffix -- `%s'"), str);
		  return;
		}
	    }
	}
      else
	{
	  /* Check that this instruction is supported for this CPU.  */
	  if ((opcode->avariant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }
d7237 4
a7240 7
	  mapping_state (MAP_ARM);
	  inst.instruction = opcode->avalue;
	  inst.size = INSN_SIZE;
	  if (!parse_operands (p, opcode->operands))
	    opcode->aencode ();
	}
      output_inst (str);
d7244 7
a7250 4
  /* It wasn't an instruction, but it might be a register alias of the form
     alias .req reg.  */
  if (create_register_alias (str, p))
    return;
d7252 7
a7258 4
  as_bad (_("bad instruction `%s'"), str);
}

/* Various frobbings of labels and their addresses.  */
d7260 1
a7260 4
void
arm_start_line_hook (void)
{
  last_label_seen = NULL;
d7263 2
a7264 2
void
arm_frob_label (symbolS * sym)
d7266 2
a7267 1
  last_label_seen = sym;
d7269 1
a7269 1
  ARM_SET_THUMB (sym, thumb_mode);
d7271 6
a7276 3
#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (sym, support_interwork);
#endif
d7278 7
a7284 6
  /* Note - do not allow local symbols (.Lxxx) to be labeled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.	 Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:
d7286 7
a7292 4
		ldr  r2, [pc, .Laaa]
		lsl  r3, r3, #2
		ldr  r2, [r3, r2]
		mov  pc, r2
d7294 7
a7300 9
       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:	.word Lbbb

     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.
d7302 2
a7303 10
     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
d7305 3
a7307 8
      /* When the address of a Thumb function is taken the bottom
	 bit of that address should be set.  This will allow
	 interworking between Arm and Thumb functions to work
	 correctly.  */

      THUMB_SET_FUNC (sym, 1);

      label_is_thumb_function_name = FALSE;
a7308 1
}
d7310 1
a7310 4
int
arm_data_in_code (void)
{
  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
d7312 6
a7317 4
      *input_line_pointer = '/';
      input_line_pointer += 5;
      *input_line_pointer = 0;
      return 1;
d7320 1
a7320 1
  return 0;
d7323 2
a7324 2
char *
arm_canonicalize_symbol_name (char * name)
d7326 4
a7329 1
  int len;
d7331 6
a7336 3
  if (thumb_mode && (len = strlen (name)) > 5
      && streq (name + len - 5, "/data"))
    *(name + len - 5) = 0;
d7338 1
a7338 1
  return name;
a7339 27

/* Table of all register names defined by default.  The user can
   define additional names with .req.  Note that all register names
   should appear in both upper and lowercase variants.	Some registers
   also have mixed-case names.	*/

#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, TRUE }
#define REGNUM(p,n,t) REGDEF(p##n, n, t)
#define REGSET(p,t) \
  REGNUM(p, 0,t), REGNUM(p, 1,t), REGNUM(p, 2,t), REGNUM(p, 3,t), \
  REGNUM(p, 4,t), REGNUM(p, 5,t), REGNUM(p, 6,t), REGNUM(p, 7,t), \
  REGNUM(p, 8,t), REGNUM(p, 9,t), REGNUM(p,10,t), REGNUM(p,11,t), \
  REGNUM(p,12,t), REGNUM(p,13,t), REGNUM(p,14,t), REGNUM(p,15,t)

static const struct reg_entry reg_names[] =
{
  /* ARM integer registers.  */
  REGSET(r, RN), REGSET(R, RN),

  /* ATPCS synonyms.  */
  REGDEF(a1,0,RN), REGDEF(a2,1,RN), REGDEF(a3, 2,RN), REGDEF(a4, 3,RN),
  REGDEF(v1,4,RN), REGDEF(v2,5,RN), REGDEF(v3, 6,RN), REGDEF(v4, 7,RN),
  REGDEF(v5,8,RN), REGDEF(v6,9,RN), REGDEF(v7,10,RN), REGDEF(v8,11,RN),

  REGDEF(A1,0,RN), REGDEF(A2,1,RN), REGDEF(A3, 2,RN), REGDEF(A4, 3,RN),
  REGDEF(V1,4,RN), REGDEF(V2,5,RN), REGDEF(V3, 6,RN), REGDEF(V4, 7,RN),
  REGDEF(V5,8,RN), REGDEF(V6,9,RN), REGDEF(V7,10,RN), REGDEF(V8,11,RN),
d7341 4
a7344 3
  /* Well-known aliases.  */
  REGDEF(wr, 7,RN), REGDEF(sb, 9,RN), REGDEF(sl,10,RN), REGDEF(fp,11,RN),
  REGDEF(ip,12,RN), REGDEF(sp,13,RN), REGDEF(lr,14,RN), REGDEF(pc,15,RN),
d7346 6
a7351 2
  REGDEF(WR, 7,RN), REGDEF(SB, 9,RN), REGDEF(SL,10,RN), REGDEF(FP,11,RN),
  REGDEF(IP,12,RN), REGDEF(SP,13,RN), REGDEF(LR,14,RN), REGDEF(PC,15,RN),
d7353 7
a7359 2
  /* Coprocessor numbers.  */
  REGSET(p, CP), REGSET(P, CP),
d7361 2
a7362 65
  /* Coprocessor register numbers.  The "cr" variants are for backward
     compatibility.  */
  REGSET(c,  CN), REGSET(C, CN),
  REGSET(cr, CN), REGSET(CR, CN),

  /* FPA registers.  */
  REGNUM(f,0,FN), REGNUM(f,1,FN), REGNUM(f,2,FN), REGNUM(f,3,FN),
  REGNUM(f,4,FN), REGNUM(f,5,FN), REGNUM(f,6,FN), REGNUM(f,7, FN),

  REGNUM(F,0,FN), REGNUM(F,1,FN), REGNUM(F,2,FN), REGNUM(F,3,FN),
  REGNUM(F,4,FN), REGNUM(F,5,FN), REGNUM(F,6,FN), REGNUM(F,7, FN),

  /* VFP SP registers.	*/
  REGSET(s,VFS),
  REGNUM(s,16,VFS), REGNUM(s,17,VFS), REGNUM(s,18,VFS), REGNUM(s,19,VFS),
  REGNUM(s,20,VFS), REGNUM(s,21,VFS), REGNUM(s,22,VFS), REGNUM(s,23,VFS),
  REGNUM(s,24,VFS), REGNUM(s,25,VFS), REGNUM(s,26,VFS), REGNUM(s,27,VFS),
  REGNUM(s,28,VFS), REGNUM(s,29,VFS), REGNUM(s,30,VFS), REGNUM(s,31,VFS),

  REGSET(S,VFS),
  REGNUM(S,16,VFS), REGNUM(S,17,VFS), REGNUM(S,18,VFS), REGNUM(S,19,VFS),
  REGNUM(S,20,VFS), REGNUM(S,21,VFS), REGNUM(S,22,VFS), REGNUM(S,23,VFS),
  REGNUM(S,24,VFS), REGNUM(S,25,VFS), REGNUM(S,26,VFS), REGNUM(S,27,VFS),
  REGNUM(S,28,VFS), REGNUM(S,29,VFS), REGNUM(S,30,VFS), REGNUM(S,31,VFS),

  /* VFP DP Registers.	*/
  REGSET(d,VFD), REGSET(D,VFS),

  /* VFP control registers.  */
  REGDEF(fpsid,0,VFC), REGDEF(fpscr,1,VFC), REGDEF(fpexc,8,VFC),
  REGDEF(FPSID,0,VFC), REGDEF(FPSCR,1,VFC), REGDEF(FPEXC,8,VFC),

  /* Maverick DSP coprocessor registers.  */
  REGSET(mvf,MVF),  REGSET(mvd,MVD),  REGSET(mvfx,MVFX),  REGSET(mvdx,MVDX),
  REGSET(MVF,MVF),  REGSET(MVD,MVD),  REGSET(MVFX,MVFX),  REGSET(MVDX,MVDX),

  REGNUM(mvax,0,MVAX), REGNUM(mvax,1,MVAX),
  REGNUM(mvax,2,MVAX), REGNUM(mvax,3,MVAX),
  REGDEF(dspsc,0,DSPSC),

  REGNUM(MVAX,0,MVAX), REGNUM(MVAX,1,MVAX),
  REGNUM(MVAX,2,MVAX), REGNUM(MVAX,3,MVAX),
  REGDEF(DSPSC,0,DSPSC),

  /* iWMMXt data registers - p0, c0-15.	 */
  REGSET(wr,MMXWR), REGSET(wR,MMXWR), REGSET(WR, MMXWR),

  /* iWMMXt control registers - p1, c0-3.  */
  REGDEF(wcid,	0,MMXWC),  REGDEF(wCID,	 0,MMXWC),  REGDEF(WCID,  0,MMXWC),
  REGDEF(wcon,	1,MMXWC),  REGDEF(wCon,	 1,MMXWC),  REGDEF(WCON,  1,MMXWC),
  REGDEF(wcssf, 2,MMXWC),  REGDEF(wCSSF, 2,MMXWC),  REGDEF(WCSSF, 2,MMXWC),
  REGDEF(wcasf, 3,MMXWC),  REGDEF(wCASF, 3,MMXWC),  REGDEF(WCASF, 3,MMXWC),

  /* iWMMXt scalar (constant/offset) registers - p1, c8-11.  */
  REGDEF(wcgr0, 8,MMXWCG),  REGDEF(wCGR0, 8,MMXWCG),  REGDEF(WCGR0, 8,MMXWCG),
  REGDEF(wcgr1, 9,MMXWCG),  REGDEF(wCGR1, 9,MMXWCG),  REGDEF(WCGR1, 9,MMXWCG),
  REGDEF(wcgr2,10,MMXWCG),  REGDEF(wCGR2,10,MMXWCG),  REGDEF(WCGR2,10,MMXWCG),
  REGDEF(wcgr3,11,MMXWCG),  REGDEF(wCGR3,11,MMXWCG),  REGDEF(WCGR3,11,MMXWCG),

  /* XScale accumulator registers.  */
  REGNUM(acc,0,XSCALE), REGNUM(ACC,0,XSCALE),
};
#undef REGDEF
#undef REGNUM
#undef REGSET
d7364 2
a7365 3
/* Table of all PSR suffixes.  Bare "CPSR" and "SPSR" are handled
   within psr_required_here.  */
static const struct asm_psr psrs[] =
d7367 1
a7367 73
  /* Backward compatibility notation.  Note that "all" is no longer
     truly all possible PSR bits.  */
  {"all",  PSR_c | PSR_f},
  {"flg",  PSR_f},
  {"ctl",  PSR_c},

  /* Individual flags.	*/
  {"f",	   PSR_f},
  {"c",	   PSR_c},
  {"x",	   PSR_x},
  {"s",	   PSR_s},
  /* Combinations of flags.  */
  {"fs",   PSR_f | PSR_s},
  {"fx",   PSR_f | PSR_x},
  {"fc",   PSR_f | PSR_c},
  {"sf",   PSR_s | PSR_f},
  {"sx",   PSR_s | PSR_x},
  {"sc",   PSR_s | PSR_c},
  {"xf",   PSR_x | PSR_f},
  {"xs",   PSR_x | PSR_s},
  {"xc",   PSR_x | PSR_c},
  {"cf",   PSR_c | PSR_f},
  {"cs",   PSR_c | PSR_s},
  {"cx",   PSR_c | PSR_x},
  {"fsx",  PSR_f | PSR_s | PSR_x},
  {"fsc",  PSR_f | PSR_s | PSR_c},
  {"fxs",  PSR_f | PSR_x | PSR_s},
  {"fxc",  PSR_f | PSR_x | PSR_c},
  {"fcs",  PSR_f | PSR_c | PSR_s},
  {"fcx",  PSR_f | PSR_c | PSR_x},
  {"sfx",  PSR_s | PSR_f | PSR_x},
  {"sfc",  PSR_s | PSR_f | PSR_c},
  {"sxf",  PSR_s | PSR_x | PSR_f},
  {"sxc",  PSR_s | PSR_x | PSR_c},
  {"scf",  PSR_s | PSR_c | PSR_f},
  {"scx",  PSR_s | PSR_c | PSR_x},
  {"xfs",  PSR_x | PSR_f | PSR_s},
  {"xfc",  PSR_x | PSR_f | PSR_c},
  {"xsf",  PSR_x | PSR_s | PSR_f},
  {"xsc",  PSR_x | PSR_s | PSR_c},
  {"xcf",  PSR_x | PSR_c | PSR_f},
  {"xcs",  PSR_x | PSR_c | PSR_s},
  {"cfs",  PSR_c | PSR_f | PSR_s},
  {"cfx",  PSR_c | PSR_f | PSR_x},
  {"csf",  PSR_c | PSR_s | PSR_f},
  {"csx",  PSR_c | PSR_s | PSR_x},
  {"cxf",  PSR_c | PSR_x | PSR_f},
  {"cxs",  PSR_c | PSR_x | PSR_s},
  {"fsxc", PSR_f | PSR_s | PSR_x | PSR_c},
  {"fscx", PSR_f | PSR_s | PSR_c | PSR_x},
  {"fxsc", PSR_f | PSR_x | PSR_s | PSR_c},
  {"fxcs", PSR_f | PSR_x | PSR_c | PSR_s},
  {"fcsx", PSR_f | PSR_c | PSR_s | PSR_x},
  {"fcxs", PSR_f | PSR_c | PSR_x | PSR_s},
  {"sfxc", PSR_s | PSR_f | PSR_x | PSR_c},
  {"sfcx", PSR_s | PSR_f | PSR_c | PSR_x},
  {"sxfc", PSR_s | PSR_x | PSR_f | PSR_c},
  {"sxcf", PSR_s | PSR_x | PSR_c | PSR_f},
  {"scfx", PSR_s | PSR_c | PSR_f | PSR_x},
  {"scxf", PSR_s | PSR_c | PSR_x | PSR_f},
  {"xfsc", PSR_x | PSR_f | PSR_s | PSR_c},
  {"xfcs", PSR_x | PSR_f | PSR_c | PSR_s},
  {"xsfc", PSR_x | PSR_s | PSR_f | PSR_c},
  {"xscf", PSR_x | PSR_s | PSR_c | PSR_f},
  {"xcfs", PSR_x | PSR_c | PSR_f | PSR_s},
  {"xcsf", PSR_x | PSR_c | PSR_s | PSR_f},
  {"cfsx", PSR_c | PSR_f | PSR_s | PSR_x},
  {"cfxs", PSR_c | PSR_f | PSR_x | PSR_s},
  {"csfx", PSR_c | PSR_s | PSR_f | PSR_x},
  {"csxf", PSR_c | PSR_s | PSR_x | PSR_f},
  {"cxfs", PSR_c | PSR_x | PSR_f | PSR_s},
  {"cxsf", PSR_c | PSR_x | PSR_s | PSR_f},
};
d7369 1
a7369 10
/* Table of all shift-in-operand names.	 */
static const struct asm_shift_name shift_names [] =
{
  { "asl", SHIFT_LSL },	 { "ASL", SHIFT_LSL },
  { "lsl", SHIFT_LSL },	 { "LSL", SHIFT_LSL },
  { "lsr", SHIFT_LSR },	 { "LSR", SHIFT_LSR },
  { "asr", SHIFT_ASR },	 { "ASR", SHIFT_ASR },
  { "ror", SHIFT_ROR },	 { "ROR", SHIFT_ROR },
  { "rrx", SHIFT_RRX },	 { "RRX", SHIFT_RRX }
};
d7371 6
a7376 17
/* Table of all explicit relocation names.  */
#ifdef OBJ_ELF
static struct reloc_entry reloc_names[] =
{
  { "got",     BFD_RELOC_ARM_GOT32   },	 { "GOT",     BFD_RELOC_ARM_GOT32   },
  { "gotoff",  BFD_RELOC_ARM_GOTOFF  },	 { "GOTOFF",  BFD_RELOC_ARM_GOTOFF  },
  { "plt",     BFD_RELOC_ARM_PLT32   },	 { "PLT",     BFD_RELOC_ARM_PLT32   },
  { "target1", BFD_RELOC_ARM_TARGET1 },	 { "TARGET1", BFD_RELOC_ARM_TARGET1 },
  { "target2", BFD_RELOC_ARM_TARGET2 },	 { "TARGET2", BFD_RELOC_ARM_TARGET2 },
  { "sbrel",   BFD_RELOC_ARM_SBREL32 },	 { "SBREL",   BFD_RELOC_ARM_SBREL32 },
  { "tlsgd",   BFD_RELOC_ARM_TLS_GD32},  { "TLSGD",   BFD_RELOC_ARM_TLS_GD32},
  { "tlsldm",  BFD_RELOC_ARM_TLS_LDM32}, { "TLSLDM",  BFD_RELOC_ARM_TLS_LDM32},
  { "tlsldo",  BFD_RELOC_ARM_TLS_LDO32}, { "TLSLDO",  BFD_RELOC_ARM_TLS_LDO32},
  { "gottpoff",BFD_RELOC_ARM_TLS_IE32},  { "GOTTPOFF",BFD_RELOC_ARM_TLS_IE32},
  { "tpoff",   BFD_RELOC_ARM_TLS_LE32},  { "TPOFF",   BFD_RELOC_ARM_TLS_LE32}
};
#endif
d7378 8
a7385 122
/* Table of all conditional suffixes.  0xF is not defined as a condition code.  */
static const struct asm_cond conds[] =
{
  {"eq", 0x0},
  {"ne", 0x1},
  {"cs", 0x2}, {"hs", 0x2},
  {"cc", 0x3}, {"ul", 0x3}, {"lo", 0x3},
  {"mi", 0x4},
  {"pl", 0x5},
  {"vs", 0x6},
  {"vc", 0x7},
  {"hi", 0x8},
  {"ls", 0x9},
  {"ge", 0xa},
  {"lt", 0xb},
  {"gt", 0xc},
  {"le", 0xd},
  {"al", 0xe}
};

/* Table of ARM-format instructions.	*/

/* Macros for gluing together operand strings.	*/
#define OPS0()		  { OP_stop, }
#define OPS1(a)		  { OP_##a, }
#define OPS2(a,b)	  { OP_##a,OP_##b, }
#define OPS3(a,b,c)	  { OP_##a,OP_##b,OP_##c, }
#define OPS4(a,b,c,d)	  { OP_##a,OP_##b,OP_##c,OP_##d, }
#define OPS5(a,b,c,d,e)	  { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e, }
#define OPS6(a,b,c,d,e,f) { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e,OP_##f, }

/* These macros assemble the conditional variants of each instruction
   from its bare form.	*/

#define TxCE(mnem, op, top, nops, ops, ae, te)				\
  { #mnem,	OPS##nops ops, 0xe##op, top,     ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##te }, \
  { #mnem "eq", OPS##nops ops, 0x0##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "ne", OPS##nops ops, 0x1##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "cs", OPS##nops ops, 0x2##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "hs", OPS##nops ops, 0x2##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "cc", OPS##nops ops, 0x3##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "ul", OPS##nops ops, 0x3##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "lo", OPS##nops ops, 0x3##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "mi", OPS##nops ops, 0x4##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "pl", OPS##nops ops, 0x5##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "vs", OPS##nops ops, 0x6##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "vc", OPS##nops ops, 0x7##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "hi", OPS##nops ops, 0x8##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "ls", OPS##nops ops, 0x9##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "ge", OPS##nops ops, 0xa##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "lt", OPS##nops ops, 0xb##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "gt", OPS##nops ops, 0xc##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "le", OPS##nops ops, 0xd##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
  { #mnem "al", OPS##nops ops, 0xe##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }

#define TCE(mnem, aop, top, nops, ops, ae, te) \
       TxCE(mnem, aop, 0x##top, nops, ops, ae, te)
#define tCE(mnem, aop, top, nops, ops, ae, te) \
       TxCE(mnem, aop, T_MNEM_##top, nops, ops, ae, te)

#define TCC(mnem, op, tu, t1, t2, nops, ops, ae, te)			\
  { #mnem,	OPS##nops ops,0xe##op,0x##tu,       ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "eq", OPS##nops ops,0x0##op,0x##t1##0##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "ne", OPS##nops ops,0x1##op,0x##t1##1##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "cs", OPS##nops ops,0x2##op,0x##t1##2##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "hs", OPS##nops ops,0x2##op,0x##t1##2##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "cc", OPS##nops ops,0x3##op,0x##t1##3##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "ul", OPS##nops ops,0x3##op,0x##t1##3##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "lo", OPS##nops ops,0x3##op,0x##t1##3##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "mi", OPS##nops ops,0x4##op,0x##t1##4##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "pl", OPS##nops ops,0x5##op,0x##t1##5##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "vs", OPS##nops ops,0x6##op,0x##t1##6##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "vc", OPS##nops ops,0x7##op,0x##t1##7##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "hi", OPS##nops ops,0x8##op,0x##t1##8##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "ls", OPS##nops ops,0x9##op,0x##t1##9##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "ge", OPS##nops ops,0xa##op,0x##t1##a##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "lt", OPS##nops ops,0xb##op,0x##t1##b##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "gt", OPS##nops ops,0xc##op,0x##t1##c##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "le", OPS##nops ops,0xd##op,0x##t1##d##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }, \
  { #mnem "al", OPS##nops ops,0xe##op,0x##t1##e##t2,ARM_VARIANT,THUMB_VARIANT,do_##ae,do_##te }

#define TxCM(m1, m2, op, top, nops, ops, ae, te)				\
 { #m1	    #m2, OPS##nops ops, 0xe##op, top,     ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##te }, \
 { #m1 "eq" #m2, OPS##nops ops, 0x0##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "ne" #m2, OPS##nops ops, 0x1##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "cs" #m2, OPS##nops ops, 0x2##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "hs" #m2, OPS##nops ops, 0x2##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "cc" #m2, OPS##nops ops, 0x3##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "ul" #m2, OPS##nops ops, 0x3##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "lo" #m2, OPS##nops ops, 0x3##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "mi" #m2, OPS##nops ops, 0x4##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "pl" #m2, OPS##nops ops, 0x5##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "vs" #m2, OPS##nops ops, 0x6##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "vc" #m2, OPS##nops ops, 0x7##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "hi" #m2, OPS##nops ops, 0x8##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "ls" #m2, OPS##nops ops, 0x9##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "ge" #m2, OPS##nops ops, 0xa##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "lt" #m2, OPS##nops ops, 0xb##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "gt" #m2, OPS##nops ops, 0xc##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "le" #m2, OPS##nops ops, 0xd##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }, \
 { #m1 "al" #m2, OPS##nops ops, 0xe##op, 0,       ARM_VARIANT, 0,             do_##ae, 0       }

#define TCM(m1,m2, aop, top, nops, ops, ae, te)		\
       TxCM(m1,m2, aop, 0x##top, nops, ops, ae, te)
#define tCM(m1,m2, aop, top, nops, ops, ae, te)			\
       TxCM(m1,m2, aop, T_MNEM_##top, nops, ops, ae, te)

#define TUE(mnem, op, top, nops, ops, ae, te)				\
  { #mnem, OPS##nops ops, 0xe##op, 0x##top, ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##te }

#define TUF(mnem, op, top, nops, ops, ae, te)				\
  { #mnem, OPS##nops ops, 0xf##op, 0x##top, ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##te }

#define CE(mnem,  op, nops, ops, ae) TCE(mnem,  op, 0, nops, ops, ae, 0)
#define CM(m1,m2, op, nops, ops, ae) TCM(m1,m2, op, 0, nops, ops, ae, 0)
#define UE(mnem,  op, nops, ops, ae) TUE(mnem,  op, 0, nops, ops, ae, 0)
#define UF(mnem,  op, nops, ops, ae) TUF(mnem,  op, 0, nops, ops, ae, 0)
#define do_0 0

/* unconditional Thumb-only */
#define UT(mnem,  op, nops, ops, te) \
  { #mnem, OPS##nops ops, 0, 0x##op, 0, THUMB_VARIANT, 0, do_##te }
d7387 5
d7393 1
a7393 48
static const struct asm_opcode insns[] =
{
#define ARM_VARIANT ARM_EXT_V1 /* Core ARM Instructions.  */
#define THUMB_VARIANT ARM_EXT_V4T
 tCE(and,	0000000, and,      3, (RR, oRR, SH), arit, t_arit3c),
 tCM(and,s,	0100000, ands,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(eor,	0200000, eor,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCM(eor,s,	0300000, eors,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(sub,	0400000, sub,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCM(sub,s,	0500000, subs,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCE(add,	0800000, add,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCM(add,s,	0900000, adds,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCE(adc,	0a00000, adc,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCM(adc,s,	0b00000, adcs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(sbc,	0c00000, sbc,	   3, (RR, oRR, SH), arit, t_arit3),
 tCM(sbc,s,	0d00000, sbcs,	   3, (RR, oRR, SH), arit, t_arit3),
 tCE(orr,	1800000, orr,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCM(orr,s,	1900000, orrs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(bic,	1c00000, bic,	   3, (RR, oRR, SH), arit, t_arit3),
 tCM(bic,s,	1d00000, bics,	   3, (RR, oRR, SH), arit, t_arit3),

 /* The p-variants of tst/cmp/cmn/teq (below) are the pre-V6 mechanism
    for setting PSR flag bits.  They are obsolete in V6 and do not
    have Thumb equivalents. */
 tCE(tst,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tCM(tst,s,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
  CM(tst,p,	110f000,     	   2, (RR, SH),      cmp),
 tCE(cmp,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
 tCM(cmp,s,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
  CM(cmp,p,	150f000,     	   2, (RR, SH),      cmp),
 tCE(cmn,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tCM(cmn,s,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
  CM(cmn,p,	170f000,     	   2, (RR, SH),      cmp),

 tCE(mov,	1a00000, mov,	   2, (RR, SH),      mov,  t_mov_cmp),
 tCM(mov,s,	1b00000, movs,	   2, (RR, SH),      mov,  t_mov_cmp),
 tCE(mvn,	1e00000, mvn,	   2, (RR, SH),      mov,  t_mvn_tst),
 tCM(mvn,s,	1f00000, mvns,	   2, (RR, SH),      mov,  t_mvn_tst),

 tCE(ldr,	4100000, ldr,	   2, (RR, ADDR),    ldst, t_ldst),
 tCM(ldr,b,	4500000, ldrb,	   2, (RR, ADDR),    ldst, t_ldst),
 tCE(str,	4000000, str,	   2, (RR, ADDR),    ldst, t_ldst),
 tCM(str,b,	4400000, strb,	   2, (RR, ADDR),    ldst, t_ldst),

 tCM(stm,ia,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tCM(stm,ea,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tCM(ldm,ia,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tCM(ldm,fd,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
d7395 5
a7399 9
 TCE(swi,	f000000, df00,     1, (EXPi),        swi, t_swi),
#ifdef TE_WINCE
  /* XXX This is the wrong place to do this.  Think multi-arch.	 */
 TCC(b,		a000000, e7fe, d,fe, 1, (EXPr),	    branch, t_branch),
 TCE(bl,	b000000, f7fffffe,   1, (EXPr),	    branch, t_branch23),
#else
 TCC(b,		afffffe, e7fe, d,fe, 1, (EXPr),	    branch, t_branch),
 TCE(bl,	bfffffe, f7fffffe,   1, (EXPr),	    branch, t_branch23),
#endif
d7401 16
a7416 108
  /* Pseudo ops.  */
 TCE(adr,	28f0000, 000f,	   2, (RR, EXP),    adr,  t_adr),
  CM(adr,l,	28f0000,           2, (RR, EXP),    adrl),
 tCE(nop,	1a00000, nop,	   1, (oI255c),	    nop,  t_nop),

  /* Thumb-compatibility pseudo ops.  */
 tCE(lsl,	1a00000, lsl,	   3, (RR, oRR, SH), shift, t_shift),
 tCM(lsl,s,	1b00000, lsls,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(lsr,	1a00020, lsr,	   3, (RR, oRR, SH), shift, t_shift),
 tCM(lsr,s,	1b00020, lsrs,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(asr,	1a00040, asr,	   3, (RR, oRR, SH), shift, t_shift),
 tCM(asr,s,     1b00040, asrs,     3, (RR, oRR, SH), shift, t_shift),
 tCE(ror,	1a00060, ror,	   3, (RR, oRR, SH), shift, t_shift),
 tCM(ror,s,	1b00060, rors,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(neg,	2600000, neg,	   2, (RR, RR),      rd_rn, t_neg),
 tCM(neg,s,	2700000, negs,	   2, (RR, RR),      rd_rn, t_neg),
 tCE(push,	92d0000, push,     1, (REGLST),	     push_pop, t_push_pop),
 tCE(pop,	8bd0000, pop,	   1, (REGLST),	     push_pop, t_push_pop),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6
 TCE(cpy,       1a00000, 4600,     2, (RR, RR),          rd_rm, t_cpy),

 /* V1 instructions with no Thumb analogue prior to V6T2.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(rsb,	0600000, ebc00000, 3, (RR, oRR, SH), arit, t_rsb),
 TCM(rsb,s,	0700000, ebd00000, 3, (RR, oRR, SH), arit, t_rsb),
 TCE(teq,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
 TCM(teq,s,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
  CM(teq,p,	130f000,           2, (RR, SH),      cmp),

 TCM(ldr,t,	4300000, f8500e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TCM(ldr,bt,	4700000, f8300e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TCM(str,t,	4200000, f8400e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TCM(str,bt,	4600000, f8200e00, 2, (RR, ADDR),    ldstt, t_ldstt),

 TCM(stm,db,	9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TCM(stm,fd,    9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),

 TCM(ldm,db,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TCM(ldm,ea,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),

 /* V1 instructions with no Thumb analogue at all.  */
  CE(rsc,	0e00000,	   3, (RR, oRR, SH), arit),
  CM(rsc,s,	0f00000,	   3, (RR, oRR, SH), arit),

  CM(stm,ib,	9800000,	   2, (RRw, REGLST), ldmstm),
  CM(stm,fa,	9800000,	   2, (RRw, REGLST), ldmstm),
  CM(stm,da,	8000000,	   2, (RRw, REGLST), ldmstm),
  CM(stm,ed,	8000000,	   2, (RRw, REGLST), ldmstm),
  CM(ldm,ib,	9900000,	   2, (RRw, REGLST), ldmstm),
  CM(ldm,ed,	9900000,	   2, (RRw, REGLST), ldmstm),
  CM(ldm,da,	8100000,	   2, (RRw, REGLST), ldmstm),
  CM(ldm,fa,	8100000,	   2, (RRw, REGLST), ldmstm),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V2	/* ARM 2 - multiplies.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V4T
 tCE(mul,	0000090, mul,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
 tCM(mul,s,	0100090, muls,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(mla,	0200090, fb000000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
  CM(mla,s,	0300090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas),

  /* Generic coprocessor instructions.	*/
 TCE(cdp,	e000000, ee000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TCE(ldc,	c100000, ec100000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCM(ldc,l,	c500000, ec500000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCE(stc,	c000000, ec000000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCM(stc,l,	c400000, ec400000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCE(mcr,	e000010, ee000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TCE(mrc,	e100010, ee100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V2S /* ARM 3 - swp instructions.  */
  CE(swp,	1000090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),
  CM(swp,b,	1400090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V3	/* ARM 6 Status register instructions.	*/
 TCE(mrs,	10f0000, f3ef8000, 2, (RR, PSR),     mrs, t_mrs),
 TCE(msr,	120f000, f3808000, 2, (PSR, RR_EXi), msr, t_msr),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V3M	 /* ARM 7M long multiplies.  */
 TCE(smull,	0c00090, fb800000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(smull,s,	0d00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(umull,	0800090, fba00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(umull,s,	0900090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(smlal,	0e00090, fbc00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(smlal,s,	0f00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(umlal,	0a00090, fbe00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(umlal,s,	0b00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V4	/* ARM Architecture 4.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V4T
 tCM(ldr,h,	01000b0, ldrh,     2, (RR, ADDR), ldstv4, t_ldst),
 tCM(str,h,	00000b0, strh,     2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ldr,sh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ldr,sb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ld,sh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ld,sb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),
d7418 5
a7422 6
#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V4T|ARM_EXT_V5
  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.	 */
 TCE(bx,	12fff10, 4700, 1, (RR),	bx, t_bx),
d7424 11
a7434 629
#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5 /*  ARM Architecture 5T.	 */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V5T
  /* Note: blx has 2 variants; the .value coded here is for
     BLX(2).  Only this variant has conditional execution.  */
 TCE(blx,	12fff30, 4780, 1, (RR_EXr),			    blx,  t_blx),
 TUE(bkpt,	1200070, be00, 1, (oIffffb),			    bkpt, t_bkpt),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(clz,	16f0f10, fab0f080, 2, (RRnpc, RRnpc),		        rd_rm,  t_clz),
 TUF(ldc2,	c100000, fc100000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(ldc2l,	c500000, fc500000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(stc2,	c000000, fc000000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(stc2l,	c400000, fc400000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(cdp2,	e000000, fe000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TUF(mcr2,	e000010, fe000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TUF(mrc2,	e100010, fe100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5ExP /*  ARM Architecture 5TExP.  */
 TCE(smlabb,	1000080, fb100000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlatb,	10000a0, fb100020, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlabt,	10000c0, fb100010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlatt,	10000e0, fb100030, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE(smlawb,	1200080, fb300000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlawt,	12000c0, fb300010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE(smlalbb,	1400080, fbc00080, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlaltb,	14000a0, fbc000a0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlalbt,	14000c0, fbc00090, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlaltt,	14000e0, fbc000b0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),

 TCE(smulbb,	1600080, fb10f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smultb,	16000a0, fb10f020, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smulbt,	16000c0, fb10f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smultt,	16000e0, fb10f030, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE(smulwb,	12000a0, fb30f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smulwt,	12000e0, fb30f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE(qadd,	1000050, fa80f080, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qdadd,	1400050, fa80f090, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qsub,	1200050, fa80f0a0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qdsub,	1600050, fa80f0b0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5E /*  ARM Architecture 5TE.  */
 TUF(pld,	450f000, f810f000, 1, (ADDR),		     pld,  t_pld),
 TCM(ldr,d,	00000d0, e9500000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),
 TCM(str,d,	00000f0, e9400000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),

 TCE(mcrr,	c400000, ec400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TCE(mrrc,	c500000, ec500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5J /*  ARM Architecture 5TEJ.  */
 TCE(bxj,	12fff20, f3c08f00, 1, (RR),			  bxj, t_bxj),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6 /*  ARM V6.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6
 TUF(cpsie,     1080000, b660,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 TUF(cpsid,     10c0000, b670,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 tCE(rev,       6bf0f30, rev,      2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(rev16,     6bf0fb0, rev16,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(revsh,     6ff0fb0, revsh,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(sxth,      6bf0070, sxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(uxth,      6ff0070, uxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(sxtb,      6af0070, sxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(uxtb,      6ef0070, uxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 TUF(setend,    1010000, b650,     1, (ENDI),                     setend, t_setend),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TUF(cps,	1020000, f3af8100, 1, (I31b),			  imm0, imm0),
 TCE(ldrex,	1900f9f, e8500f00, 2, (RRnpc, ADDR),		  ldrex, t_ldrex),
 TUF(mcrr2,	c400000, fc400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TUF(mrrc2,	c500000, fc500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TCE(pkhbt,	6800010, eac00000, 4, (RRnpc, RRnpc, RRnpc, oSHll),   pkhbt, t_pkhbt),
 TCE(pkhtb,	6800050, eac00020, 4, (RRnpc, RRnpc, RRnpc, oSHar),   pkhtb, t_pkhtb),
 TCE(qadd16,	6200f10, fa90f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qadd8,	6200f90, fa80f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qaddsubx,	6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsub16,	6200f70, fad0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsub8,	6200ff0, fac0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsubaddx,	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sadd16,	6100f10, fa90f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sadd8,	6100f90, fa80f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(saddsubx,	6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shadd16,	6300f10, fa90f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shadd8,	6300f90, fa80f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shaddsubx, 6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsub16,	6300f70, fad0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsub8,	6300ff0, fac0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsubaddx, 6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssub16,	6100f70, fad0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssub8,	6100ff0, fac0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssubaddx,	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uadd16,	6500f10, fa90f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uadd8,	6500f90, fa80f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uaddsubx,	6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhadd16,	6700f10, fa90f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhadd8,	6700f90, fa80f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhaddsubx, 6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsub16,	6700f70, fad0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsub8,	6700ff0, fac0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsubaddx, 6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqadd16,	6600f10, fa90f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqadd8,	6600f90, fa80f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqaddsubx, 6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsub16,	6600f70, fad0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsub8,	6600ff0, fac0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsubaddx, 6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usub16,	6500f70, fad0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usub8,	6500ff0, fac0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usubaddx,	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TUF(rfeia,	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfeib,	9900a00,           1, (RRw),			   rfe),
  UF(rfeda,	8100a00,           1, (RRw),			   rfe),
 TUF(rfedb,	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TUF(rfefd,	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfefa,	9900a00,           1, (RRw),			   rfe),
  UF(rfeea,	8100a00,           1, (RRw),			   rfe),
 TUF(rfeed,	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TCE(sxtah,	6b00070, fa00f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtab16,	6800070, fa20f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtab,	6a00070, fa40f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtb16,	68f0070, fa2ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE(uxtah,	6f00070, fa10f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtab16,	6c00070, fa30f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtab,	6e00070, fa50f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtb16,	6cf0070, fa3ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE(sel,	68000b0, faa0f080, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(smlad,	7000010, fb200000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smladx,	7000030, fb200010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlald,	7400010, fbc000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlaldx,	7400030, fbc000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlsd,	7000050, fb400000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlsdx,	7000070, fb400010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlsld,	7400050, fbd000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlsldx,	7400070, fbd000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smmla,	7500010, fb500000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmlar,	7500030, fb500010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmls,	75000d0, fb600000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmlsr,	75000f0, fb600010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmul,	750f010, fb50f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smmulr,	750f030, fb50f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smuad,	700f010, fb20f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smuadx,	700f030, fb20f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smusd,	700f050, fb40f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smusdx,	700f070, fb40f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TUF(srsia,	8cd0500, e980c000, 1, (I31w),			   srs,  srs),
  UF(srsib,	9cd0500,           1, (I31w),			   srs),
  UF(srsda,	84d0500,	   1, (I31w),			   srs),
 TUF(srsdb,	94d0500, e800c000, 1, (I31w),			   srs,  srs),
 TCE(ssat,	6a00010, f3000000, 4, (RRnpc, I32, RRnpc, oSHllar),ssat,   t_ssat),
 TCE(ssat16,	6a00f30, f3200000, 3, (RRnpc, I16, RRnpc),	   ssat16, t_ssat16),
 TCE(strex,	1800f90, e8400000, 3, (RRnpc, RRnpc, ADDR),	   strex,  t_strex),
 TCE(umaal,	0400090, fbe00060, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,  t_mlal),
 TCE(usad8,	780f010, fb70f000, 3, (RRnpc, RRnpc, RRnpc),	   smul,   t_simd),
 TCE(usada8,	7800010, fb700000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla,   t_mla),
 TCE(usat,	6e00010, f3800000, 4, (RRnpc, I31, RRnpc, oSHllar),usat,   t_usat),
 TCE(usat16,	6e00f30, f3a00000, 3, (RRnpc, I15, RRnpc),	   usat16, t_usat16),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6K
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6K
 tCE(yield,	320f001, yield,    0, (), noargs, t_hint),
 tCE(wfe,	320f002, wfe,      0, (), noargs, t_hint),
 tCE(wfi,	320f003, wfi,      0, (), noargs, t_hint),
 tCE(sev,	320f004, sev,      0, (), noargs, t_hint),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(ldrexb,	1d00f9f, e8d00f4f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE(ldrexh,	1f00f9f, e8d00f5f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE(ldrexd,	1b00f9f, e8d0007f, 3, (RRnpc, oRRnpc, RRnpcb),        ldrexd, t_ldrexd),
 TCE(strexb,	1c00f90, e8c00f40, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TCE(strexh,	1e00f90, e8c00f50, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TCE(strexd,	1a00f90, e8c00070, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb), strexd, t_strexd),
 TUF(clrex,	57ff01f, f3bf8f2f, 0, (),			      noargs, noargs),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6Z
 TCE(smi,	1600070, f7f08000, 1, (EXPi), smi, t_smi),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6T2
 TCE(bfc,	7c0001f, f36f0000, 3, (RRnpc, I31, I32),	   bfc, t_bfc),
 TCE(bfi,	7c00010, f3600000, 4, (RRnpc, RRnpc_I0, I31, I32), bfi, t_bfi),
 TCE(sbfx,	7a00050, f3400000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),
 TCE(ubfx,	7e00050, f3c00000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),

 TCE(mls,	0600090, fb000010, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
 TCE(movw,	3000000, f2400000, 2, (RRnpc, Iffff),		    mov16, t_mov16),
 TCE(movt,	3400000, f2c00000, 2, (RRnpc, Iffff),		    mov16, t_mov16),
 TCE(rbit,	3ff0f30, fa90f0a0, 2, (RR, RR),			    rd_rm, t_rbit),

 TCM(ldr,ht,	03000b0, f8300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TCM(ldr,sht,	03000f0, f9300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TCM(ldr,sbt,	03000d0, f9100e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TCM(str,ht,	02000b0, f8200e00, 2, (RR, ADDR), ldsttv4, t_ldstt),

  UT(czbne,     b900,    2, (RR, EXP), t_czb),
  UT(czbeq,     b100,    2, (RR, EXP), t_czb),
  UT(it,        bf08,    1, (COND),    t_it),
  UT(itt,       bf0c,    1, (COND),    t_it),
  UT(ite,       bf04,    1, (COND),    t_it),
  UT(ittt,      bf0e,    1, (COND),    t_it),
  UT(itet,      bf06,    1, (COND),    t_it),
  UT(itte,      bf0a,    1, (COND),    t_it),
  UT(itee,      bf02,    1, (COND),    t_it),
  UT(itttt,     bf0f,    1, (COND),    t_it),
  UT(itett,     bf07,    1, (COND),    t_it),
  UT(ittet,     bf0b,    1, (COND),    t_it),
  UT(iteet,     bf03,    1, (COND),    t_it),
  UT(ittte,     bf0d,    1, (COND),    t_it),
  UT(itete,     bf05,    1, (COND),    t_it),
  UT(ittee,     bf09,    1, (COND),    t_it),
  UT(iteee,     bf01,    1, (COND),    t_it),

#undef ARM_VARIANT
#define ARM_VARIANT FPU_FPA_EXT_V1  /* Core FPA instruction set (V1).  */
  CE(wfs,	e200110, 1, (RR),	     rd),
  CE(rfs,	e300110, 1, (RR),	     rd),
  CE(wfc,	e400110, 1, (RR),	     rd),
  CE(rfc,	e500110, 1, (RR),	     rd),

  CM(ldf,s,	c100100, 2, (RF, ADDR),	     rd_cpaddr),
  CM(ldf,d,	c108100, 2, (RF, ADDR),	     rd_cpaddr),
  CM(ldf,e,	c500100, 2, (RF, ADDR),	     rd_cpaddr),
  CM(ldf,p,	c508100, 2, (RF, ADDR),	     rd_cpaddr),

  CM(stf,s,	c000100, 2, (RF, ADDR),	     rd_cpaddr),
  CM(stf,d,	c008100, 2, (RF, ADDR),	     rd_cpaddr),
  CM(stf,e,	c400100, 2, (RF, ADDR),	     rd_cpaddr),
  CM(stf,p,	c408100, 2, (RF, ADDR),	     rd_cpaddr),

  CM(mvf,s,	e008100, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,sp,	e008120, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,sm,	e008140, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,sz,	e008160, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,d,	e008180, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,dp,	e0081a0, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,dm,	e0081c0, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,dz,	e0081e0, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,e,	e088100, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,ep,	e088120, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,em,	e088140, 2, (RF, RF_IF),     rd_rm),
  CM(mvf,ez,	e088160, 2, (RF, RF_IF),     rd_rm),

  CM(mnf,s,	e108100, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,sp,	e108120, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,sm,	e108140, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,sz,	e108160, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,d,	e108180, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,dp,	e1081a0, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,dm,	e1081c0, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,dz,	e1081e0, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,e,	e188100, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,ep,	e188120, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,em,	e188140, 2, (RF, RF_IF),     rd_rm),
  CM(mnf,ez,	e188160, 2, (RF, RF_IF),     rd_rm),

  CM(abs,s,	e208100, 2, (RF, RF_IF),     rd_rm),
  CM(abs,sp,	e208120, 2, (RF, RF_IF),     rd_rm),
  CM(abs,sm,	e208140, 2, (RF, RF_IF),     rd_rm),
  CM(abs,sz,	e208160, 2, (RF, RF_IF),     rd_rm),
  CM(abs,d,	e208180, 2, (RF, RF_IF),     rd_rm),
  CM(abs,dp,	e2081a0, 2, (RF, RF_IF),     rd_rm),
  CM(abs,dm,	e2081c0, 2, (RF, RF_IF),     rd_rm),
  CM(abs,dz,	e2081e0, 2, (RF, RF_IF),     rd_rm),
  CM(abs,e,	e288100, 2, (RF, RF_IF),     rd_rm),
  CM(abs,ep,	e288120, 2, (RF, RF_IF),     rd_rm),
  CM(abs,em,	e288140, 2, (RF, RF_IF),     rd_rm),
  CM(abs,ez,	e288160, 2, (RF, RF_IF),     rd_rm),

  CM(rnd,s,	e308100, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,sp,	e308120, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,sm,	e308140, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,sz,	e308160, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,d,	e308180, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,dp,	e3081a0, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,dm,	e3081c0, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,dz,	e3081e0, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,e,	e388100, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,ep,	e388120, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,em,	e388140, 2, (RF, RF_IF),     rd_rm),
  CM(rnd,ez,	e388160, 2, (RF, RF_IF),     rd_rm),

  CM(sqt,s,	e408100, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,sp,	e408120, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,sm,	e408140, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,sz,	e408160, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,d,	e408180, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,dp,	e4081a0, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,dm,	e4081c0, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,dz,	e4081e0, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,e,	e488100, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,ep,	e488120, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,em,	e488140, 2, (RF, RF_IF),     rd_rm),
  CM(sqt,ez,	e488160, 2, (RF, RF_IF),     rd_rm),

  CM(log,s,	e508100, 2, (RF, RF_IF),     rd_rm),
  CM(log,sp,	e508120, 2, (RF, RF_IF),     rd_rm),
  CM(log,sm,	e508140, 2, (RF, RF_IF),     rd_rm),
  CM(log,sz,	e508160, 2, (RF, RF_IF),     rd_rm),
  CM(log,d,	e508180, 2, (RF, RF_IF),     rd_rm),
  CM(log,dp,	e5081a0, 2, (RF, RF_IF),     rd_rm),
  CM(log,dm,	e5081c0, 2, (RF, RF_IF),     rd_rm),
  CM(log,dz,	e5081e0, 2, (RF, RF_IF),     rd_rm),
  CM(log,e,	e588100, 2, (RF, RF_IF),     rd_rm),
  CM(log,ep,	e588120, 2, (RF, RF_IF),     rd_rm),
  CM(log,em,	e588140, 2, (RF, RF_IF),     rd_rm),
  CM(log,ez,	e588160, 2, (RF, RF_IF),     rd_rm),

  CM(lgn,s,	e608100, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,sp,	e608120, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,sm,	e608140, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,sz,	e608160, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,d,	e608180, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,dp,	e6081a0, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,dm,	e6081c0, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,dz,	e6081e0, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,e,	e688100, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,ep,	e688120, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,em,	e688140, 2, (RF, RF_IF),     rd_rm),
  CM(lgn,ez,	e688160, 2, (RF, RF_IF),     rd_rm),

  CM(exp,s,	e708100, 2, (RF, RF_IF),     rd_rm),
  CM(exp,sp,	e708120, 2, (RF, RF_IF),     rd_rm),
  CM(exp,sm,	e708140, 2, (RF, RF_IF),     rd_rm),
  CM(exp,sz,	e708160, 2, (RF, RF_IF),     rd_rm),
  CM(exp,d,	e708180, 2, (RF, RF_IF),     rd_rm),
  CM(exp,dp,	e7081a0, 2, (RF, RF_IF),     rd_rm),
  CM(exp,dm,	e7081c0, 2, (RF, RF_IF),     rd_rm),
  CM(exp,dz,	e7081e0, 2, (RF, RF_IF),     rd_rm),
  CM(exp,e,	e788100, 2, (RF, RF_IF),     rd_rm),
  CM(exp,ep,	e788120, 2, (RF, RF_IF),     rd_rm),
  CM(exp,em,	e788140, 2, (RF, RF_IF),     rd_rm),
  CM(exp,dz,	e788160, 2, (RF, RF_IF),     rd_rm),

  CM(sin,s,	e808100, 2, (RF, RF_IF),     rd_rm),
  CM(sin,sp,	e808120, 2, (RF, RF_IF),     rd_rm),
  CM(sin,sm,	e808140, 2, (RF, RF_IF),     rd_rm),
  CM(sin,sz,	e808160, 2, (RF, RF_IF),     rd_rm),
  CM(sin,d,	e808180, 2, (RF, RF_IF),     rd_rm),
  CM(sin,dp,	e8081a0, 2, (RF, RF_IF),     rd_rm),
  CM(sin,dm,	e8081c0, 2, (RF, RF_IF),     rd_rm),
  CM(sin,dz,	e8081e0, 2, (RF, RF_IF),     rd_rm),
  CM(sin,e,	e888100, 2, (RF, RF_IF),     rd_rm),
  CM(sin,ep,	e888120, 2, (RF, RF_IF),     rd_rm),
  CM(sin,em,	e888140, 2, (RF, RF_IF),     rd_rm),
  CM(sin,ez,	e888160, 2, (RF, RF_IF),     rd_rm),

  CM(cos,s,	e908100, 2, (RF, RF_IF),     rd_rm),
  CM(cos,sp,	e908120, 2, (RF, RF_IF),     rd_rm),
  CM(cos,sm,	e908140, 2, (RF, RF_IF),     rd_rm),
  CM(cos,sz,	e908160, 2, (RF, RF_IF),     rd_rm),
  CM(cos,d,	e908180, 2, (RF, RF_IF),     rd_rm),
  CM(cos,dp,	e9081a0, 2, (RF, RF_IF),     rd_rm),
  CM(cos,dm,	e9081c0, 2, (RF, RF_IF),     rd_rm),
  CM(cos,dz,	e9081e0, 2, (RF, RF_IF),     rd_rm),
  CM(cos,e,	e988100, 2, (RF, RF_IF),     rd_rm),
  CM(cos,ep,	e988120, 2, (RF, RF_IF),     rd_rm),
  CM(cos,em,	e988140, 2, (RF, RF_IF),     rd_rm),
  CM(cos,ez,	e988160, 2, (RF, RF_IF),     rd_rm),

  CM(tan,s,	ea08100, 2, (RF, RF_IF),     rd_rm),
  CM(tan,sp,	ea08120, 2, (RF, RF_IF),     rd_rm),
  CM(tan,sm,	ea08140, 2, (RF, RF_IF),     rd_rm),
  CM(tan,sz,	ea08160, 2, (RF, RF_IF),     rd_rm),
  CM(tan,d,	ea08180, 2, (RF, RF_IF),     rd_rm),
  CM(tan,dp,	ea081a0, 2, (RF, RF_IF),     rd_rm),
  CM(tan,dm,	ea081c0, 2, (RF, RF_IF),     rd_rm),
  CM(tan,dz,	ea081e0, 2, (RF, RF_IF),     rd_rm),
  CM(tan,e,	ea88100, 2, (RF, RF_IF),     rd_rm),
  CM(tan,ep,	ea88120, 2, (RF, RF_IF),     rd_rm),
  CM(tan,em,	ea88140, 2, (RF, RF_IF),     rd_rm),
  CM(tan,ez,	ea88160, 2, (RF, RF_IF),     rd_rm),

  CM(asn,s,	eb08100, 2, (RF, RF_IF),     rd_rm),
  CM(asn,sp,	eb08120, 2, (RF, RF_IF),     rd_rm),
  CM(asn,sm,	eb08140, 2, (RF, RF_IF),     rd_rm),
  CM(asn,sz,	eb08160, 2, (RF, RF_IF),     rd_rm),
  CM(asn,d,	eb08180, 2, (RF, RF_IF),     rd_rm),
  CM(asn,dp,	eb081a0, 2, (RF, RF_IF),     rd_rm),
  CM(asn,dm,	eb081c0, 2, (RF, RF_IF),     rd_rm),
  CM(asn,dz,	eb081e0, 2, (RF, RF_IF),     rd_rm),
  CM(asn,e,	eb88100, 2, (RF, RF_IF),     rd_rm),
  CM(asn,ep,	eb88120, 2, (RF, RF_IF),     rd_rm),
  CM(asn,em,	eb88140, 2, (RF, RF_IF),     rd_rm),
  CM(asn,ez,	eb88160, 2, (RF, RF_IF),     rd_rm),

  CM(acs,s,	ec08100, 2, (RF, RF_IF),     rd_rm),
  CM(acs,sp,	ec08120, 2, (RF, RF_IF),     rd_rm),
  CM(acs,sm,	ec08140, 2, (RF, RF_IF),     rd_rm),
  CM(acs,sz,	ec08160, 2, (RF, RF_IF),     rd_rm),
  CM(acs,d,	ec08180, 2, (RF, RF_IF),     rd_rm),
  CM(acs,dp,	ec081a0, 2, (RF, RF_IF),     rd_rm),
  CM(acs,dm,	ec081c0, 2, (RF, RF_IF),     rd_rm),
  CM(acs,dz,	ec081e0, 2, (RF, RF_IF),     rd_rm),
  CM(acs,e,	ec88100, 2, (RF, RF_IF),     rd_rm),
  CM(acs,ep,	ec88120, 2, (RF, RF_IF),     rd_rm),
  CM(acs,em,	ec88140, 2, (RF, RF_IF),     rd_rm),
  CM(acs,ez,	ec88160, 2, (RF, RF_IF),     rd_rm),

  CM(atn,s,	ed08100, 2, (RF, RF_IF),     rd_rm),
  CM(atn,sp,	ed08120, 2, (RF, RF_IF),     rd_rm),
  CM(atn,sm,	ed08140, 2, (RF, RF_IF),     rd_rm),
  CM(atn,sz,	ed08160, 2, (RF, RF_IF),     rd_rm),
  CM(atn,d,	ed08180, 2, (RF, RF_IF),     rd_rm),
  CM(atn,dp,	ed081a0, 2, (RF, RF_IF),     rd_rm),
  CM(atn,dm,	ed081c0, 2, (RF, RF_IF),     rd_rm),
  CM(atn,dz,	ed081e0, 2, (RF, RF_IF),     rd_rm),
  CM(atn,e,	ed88100, 2, (RF, RF_IF),     rd_rm),
  CM(atn,ep,	ed88120, 2, (RF, RF_IF),     rd_rm),
  CM(atn,em,	ed88140, 2, (RF, RF_IF),     rd_rm),
  CM(atn,ez,	ed88160, 2, (RF, RF_IF),     rd_rm),

  CM(urd,s,	ee08100, 2, (RF, RF_IF),     rd_rm),
  CM(urd,sp,	ee08120, 2, (RF, RF_IF),     rd_rm),
  CM(urd,sm,	ee08140, 2, (RF, RF_IF),     rd_rm),
  CM(urd,sz,	ee08160, 2, (RF, RF_IF),     rd_rm),
  CM(urd,d,	ee08180, 2, (RF, RF_IF),     rd_rm),
  CM(urd,dp,	ee081a0, 2, (RF, RF_IF),     rd_rm),
  CM(urd,dm,	ee081c0, 2, (RF, RF_IF),     rd_rm),
  CM(urd,dz,	ee081e0, 2, (RF, RF_IF),     rd_rm),
  CM(urd,e,	ee88100, 2, (RF, RF_IF),     rd_rm),
  CM(urd,ep,	ee88120, 2, (RF, RF_IF),     rd_rm),
  CM(urd,em,	ee88140, 2, (RF, RF_IF),     rd_rm),
  CM(urd,ez,	ee88160, 2, (RF, RF_IF),     rd_rm),

  CM(nrm,s,	ef08100, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,sp,	ef08120, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,sm,	ef08140, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,sz,	ef08160, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,d,	ef08180, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,dp,	ef081a0, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,dm,	ef081c0, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,dz,	ef081e0, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,e,	ef88100, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,ep,	ef88120, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,em,	ef88140, 2, (RF, RF_IF),     rd_rm),
  CM(nrm,ez,	ef88160, 2, (RF, RF_IF),     rd_rm),

  CM(adf,s,	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,sp,	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,sm,	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,sz,	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,d,	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,dp,	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,dm,	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,dz,	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,e,	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,ep,	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,em,	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(adf,ez,	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(suf,s,	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,sp,	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,sm,	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,sz,	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,d,	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,dp,	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,dm,	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,dz,	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,e,	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,ep,	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,em,	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(suf,ez,	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(rsf,s,	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,sp,	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,sm,	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,sz,	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,d,	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,dp,	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,dm,	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,dz,	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,e,	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,ep,	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,em,	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rsf,ez,	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(muf,s,	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,sp,	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,sm,	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,sz,	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,d,	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,dp,	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,dm,	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,dz,	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,e,	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,ep,	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,em,	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(muf,ez,	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(dvf,s,	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,sp,	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,sm,	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,sz,	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,d,	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,dp,	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,dm,	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,dz,	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,e,	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,ep,	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,em,	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(dvf,ez,	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(rdf,s,	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,sp,	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,sm,	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,sz,	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,d,	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,dp,	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,dm,	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,dz,	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,e,	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,ep,	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,em,	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rdf,ez,	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(pow,s,	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,sp,	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,sm,	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,sz,	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,d,	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,dp,	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,dm,	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,dz,	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,e,	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,ep,	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,em,	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pow,ez,	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(rpw,s,	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,sp,	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,sm,	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,sz,	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,d,	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,dp,	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,dm,	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,dz,	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,e,	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,ep,	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,em,	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rpw,ez,	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(rmf,s,	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,sp,	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,sm,	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,sz,	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,d,	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,dp,	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,dm,	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,dz,	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,e,	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,ep,	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,em,	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(rmf,ez,	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(fml,s,	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,sp,	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,sm,	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,sz,	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,d,	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,dp,	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,dm,	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,dz,	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,e,	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,ep,	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,em,	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fml,ez,	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(fdv,s,	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,sp,	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,sm,	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,sz,	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,d,	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,dp,	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,dm,	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,dz,	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,e,	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,ep,	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,em,	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(fdv,ez,	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(frd,s,	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,sp,	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,sm,	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,sz,	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,d,	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,dp,	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,dm,	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,dz,	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,e,	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,ep,	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,em,	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(frd,ez,	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CM(pol,s,	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,sp,	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,sm,	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,sz,	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,d,	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,dp,	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,dm,	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,dz,	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,e,	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,ep,	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,em,	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  CM(pol,ez,	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CE(cmf,	e90f110, 2, (RF, RF_IF),     fpa_cmp),
  CM(cmf,e,	ed0f110, 2, (RF, RF_IF),     fpa_cmp),
  CE(cnf,	eb0f110, 2, (RF, RF_IF),     fpa_cmp),
  CM(cnf,e,	ef0f110, 2, (RF, RF_IF),     fpa_cmp),
  /* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should
     not be an optional suffix, but part of the instruction.  To be
     compatible, we accept either.  */
  CE(cmfe,	ed0f110, 2, (RF, RF_IF),     fpa_cmp),
  CE(cnfe,	ef0f110, 2, (RF, RF_IF),     fpa_cmp),
d7436 2
a7437 12
  CM(flt,s,	e000110, 2, (RF, RR),	     rn_rd),
  CM(flt,sp,	e000130, 2, (RF, RR),	     rn_rd),
  CM(flt,sm,	e000150, 2, (RF, RR),	     rn_rd),
  CM(flt,sz,	e000170, 2, (RF, RR),	     rn_rd),
  CM(flt,d,	e000190, 2, (RF, RR),	     rn_rd),
  CM(flt,dp,	e0001b0, 2, (RF, RR),	     rn_rd),
  CM(flt,dm,	e0001d0, 2, (RF, RR),	     rn_rd),
  CM(flt,dz,	e0001f0, 2, (RF, RR),	     rn_rd),
  CM(flt,e,	e080110, 2, (RF, RR),	     rn_rd),
  CM(flt,ep,	e080130, 2, (RF, RR),	     rn_rd),
  CM(flt,em,	e080150, 2, (RF, RR),	     rn_rd),
  CM(flt,ez,	e080170, 2, (RF, RR),	     rn_rd),
d7439 2
a7440 18
  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
  CE(fix,	e100110, 2, (RR, RF),	     rd_rm),
  CM(fix,p,	e100130, 2, (RR, RF),	     rd_rm),
  CM(fix,m,	e100150, 2, (RR, RF),	     rd_rm),
  CM(fix,z,	e100170, 2, (RR, RF),	     rd_rm),
  CM(fix,sp,	e100130, 2, (RR, RF),	     rd_rm),
  CM(fix,sm,	e100150, 2, (RR, RF),	     rd_rm),
  CM(fix,sz,	e100170, 2, (RR, RF),	     rd_rm),
  CM(fix,dp,	e100130, 2, (RR, RF),	     rd_rm),
  CM(fix,dm,	e100150, 2, (RR, RF),	     rd_rm),
  CM(fix,dz,	e100170, 2, (RR, RF),	     rd_rm),
  CM(fix,ep,	e100130, 2, (RR, RF),	     rd_rm),
  CM(fix,em,	e100150, 2, (RR, RF),	     rd_rm),
  CM(fix,ez,	e100170, 2, (RR, RF),	     rd_rm),
d7442 1
a7442 9
  /* Instructions that were new with the real FPA, call them V2.  */
#undef ARM_VARIANT
#define ARM_VARIANT FPU_FPA_EXT_V2
  CE(lfm,	c100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  CM(lfm,fd,	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  CM(lfm,ea,	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  CE(sfm,	c000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  CM(sfm,fd,	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  CM(sfm,ea,	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),
d7444 5
a7448 35
#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V1xD  /* VFP V1xD (single precision).  */
  /* Moves and type conversions.  */
  CE(fcpys,	eb00a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fmrs,	e100a10, 2, (RR, RVS),	      vfp_reg_from_sp),
  CE(fmsr,	e000a10, 2, (RVS, RR),	      vfp_sp_from_reg),
  CE(fmstat,	ef1fa10, 0, (),		      noargs),
  CE(fsitos,	eb80ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fuitos,	eb80a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftosis,	ebd0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftosizs,	ebd0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftouis,	ebc0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftouizs,	ebc0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fmrx,	ef00a10, 2, (RR, RVC),	      rd_rn),
  CE(fmxr,	ee00a10, 2, (RVC, RR),	      rn_rd),

  /* Memory operations.	 */
  CE(flds,	d100a00, 2, (RVS, ADDR),      vfp_sp_ldst),
  CE(fsts,	d000a00, 2, (RVS, ADDR),      vfp_sp_ldst),
  CE(fldmias,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fldmfds,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fldmdbs,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fldmeas,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fldmiax,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fldmfdx,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fldmdbx,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fldmeax,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fstmias,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fstmeas,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fstmdbs,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fstmfds,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fstmiax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fstmeax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fstmdbx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fstmfdx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
d7450 14
a7463 15
  /* Monadic operations.  */
  CE(fabss,	eb00ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fnegs,	eb10a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fsqrts,	eb10ac0, 2, (RVS, RVS),	      vfp_sp_monadic),

  /* Dyadic operations.	 */
  CE(fadds,	e300a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fsubs,	e300a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmuls,	e200a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fdivs,	e800a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmacs,	e000a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmscs,	e100a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmuls,	e200a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmacs,	e000a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmscs,	e100a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
d7465 23
a7487 5
  /* Comparisons.  */
  CE(fcmps,	eb40a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fcmpzs,	eb50a40, 1, (RVS),	      vfp_sp_compare_z),
  CE(fcmpes,	eb40ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fcmpezs,	eb50ac0, 1, (RVS),	      vfp_sp_compare_z),
d7489 9
a7497 28
#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V1 /* VFP V1 (Double precision).  */
  /* Moves and type conversions.  */
  CE(fcpyd,	eb00b40, 2, (RVD, RVD),	      rd_rm),
  CE(fcvtds,	eb70ac0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(fcvtsd,	eb70bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(fmdhr,	e200b10, 2, (RVD, RR),	      rn_rd),
  CE(fmdlr,	e000b10, 2, (RVD, RR),	      rn_rd),
  CE(fmrdh,	e300b10, 2, (RR, RVD),	      rd_rn),
  CE(fmrdl,	e100b10, 2, (RR, RVD),	      rd_rn),
  CE(fsitod,	eb80bc0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(fuitod,	eb80b40, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(ftosid,	ebd0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftosizd,	ebd0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftouid,	ebc0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftouizd,	ebc0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),

  /* Memory operations.	 */
  CE(fldd,	d100b00, 2, (RVD, ADDR),      vfp_dp_ldst),
  CE(fstd,	d000b00, 2, (RVD, ADDR),      vfp_dp_ldst),
  CE(fldmiad,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fldmfdd,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fldmdbd,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fldmead,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fstmiad,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fstmead,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fstmdbd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fstmfdd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
d7499 2
a7500 15
  /* Monadic operations.  */
  CE(fabsd,	eb00bc0, 2, (RVD, RVD),	      rd_rm),
  CE(fnegd,	eb10b40, 2, (RVD, RVD),	      rd_rm),
  CE(fsqrtd,	eb10bc0, 2, (RVD, RVD),	      rd_rm),

  /* Dyadic operations.	 */
  CE(faddd,	e300b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fsubd,	e300b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmuld,	e200b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fdivd,	e800b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmacd,	e000b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmscd,	e100b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmuld,	e200b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmacd,	e000b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmscd,	e100b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
d7502 2
a7503 300
  /* Comparisons.  */
  CE(fcmpd,	eb40b40, 2, (RVD, RVD),	      rd_rm),
  CE(fcmpzd,	eb50b40, 1, (RVD),	      rd),
  CE(fcmped,	eb40bc0, 2, (RVD, RVD),	      rd_rm),
  CE(fcmpezd,	eb50bc0, 1, (RVD),	      rd),

#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V2
  CE(fmsrr,	c400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),
  CE(fmrrs,	c500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),
  CE(fmdrr,	c400b10, 3, (RVD, RR, RR),    rm_rd_rn),
  CE(fmrrd,	c500b10, 3, (RR, RR, RVD),    rd_rn_rm),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_XSCALE /* Intel XScale extensions.	 */
  CE(mia,	e200010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miaph,	e280010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miabb,	e2c0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miabt,	e2d0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miatb,	e2e0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miatt,	e2f0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(mar,	c400000, 3, (RXA, RRnpc, RRnpc), xsc_mar),
  CE(mra,	c500000, 3, (RRnpc, RRnpc, RXA), xsc_mra),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_IWMMXT /* Intel Wireless MMX technology.  */
  CE(tandcb,	e13f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tandch,	e53f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tandcw,	e93f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tbcstb,	e400010, 2, (RIWR, RR),		    rn_rd),
  CE(tbcsth,	e400050, 2, (RIWR, RR),		    rn_rd),
  CE(tbcstw,	e400090, 2, (RIWR, RR),		    rn_rd),
  CE(textrcb,	e130170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrch,	e530170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrcw,	e930170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrmub,	e100070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmuh,	e500070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmuw,	e900070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsb,	e100078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsh,	e500078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsw,	e900078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(tinsrb,	e600010, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tinsrh,	e600050, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tinsrw,	e600090, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tmcr,	e000110, 2, (RIWC, RR),		    rn_rd),
  CE(tmcrr,	c400000, 3, (RIWR, RR, RR),	    rm_rd_rn),
  CE(tmia,	e200010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiaph,	e280010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiabb,	e2c0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiabt,	e2d0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiatb,	e2e0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiatt,	e2f0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmovmskb,	e100030, 2, (RR, RIWR),		    rd_rn),
  CE(tmovmskh,	e500030, 2, (RR, RIWR),		    rd_rn),
  CE(tmovmskw,	e900030, 2, (RR, RIWR),		    rd_rn),
  CE(tmrc,	e100110, 2, (RR, RIWC),		    rd_rn),
  CE(tmrrc,	c500000, 3, (RR, RR, RIWR),	    rd_rn_rm),
  CE(torcb,	e13f150, 1, (RR),		    iwmmxt_tandorc),
  CE(torch,	e53f150, 1, (RR),		    iwmmxt_tandorc),
  CE(torcw,	e93f150, 1, (RR),		    iwmmxt_tandorc),
  CE(waccb,	e0001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wacch,	e4001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(waccw,	e8001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(waddbss,	e300180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddb,	e000180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddbus,	e100180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddhss,	e700180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddh,	e400180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddhus,	e500180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddwss,	eb00180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddw,	e800180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddwus,	e900180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waligni,	e000020, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_waligni),
  CE(walignr0,	e800020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr1,	e900020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr2,	ea00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr3,	eb00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wand,	e200000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wandn,	e300000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2b,	e800000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2br,	e900000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2h,	ec00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2hr,	ed00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqb,	e000060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqh,	e400060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqw,	e800060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtub,	e100060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtuh,	e500060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtuw,	e900060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsb,	e300060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsh,	e700060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsw,	eb00060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wldrb,	c100000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wldrh,	c500000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wldrw,	c100100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
  CE(wldrd,	c500100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
  CE(wmacs,	e600100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacsz,	e700100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacu,	e400100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacuz,	e500100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmadds,	ea00100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaddu,	e800100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsb,	e200160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsh,	e600160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsw,	ea00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxub,	e000160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxuh,	e400160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxuw,	e800160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsb,	e300160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsh,	e700160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsw,	eb00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminub,	e100160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminuh,	e500160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminuw,	e900160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmov,	e000000, 2, (RIWR, RIWR),	    iwmmxt_wmov),
  CE(wmulsm,	e300100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulsl,	e200100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulum,	e100100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulul,	e000100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wor,	e000000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackhss,	e700080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackhus,	e500080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackwss,	eb00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackwus,	e900080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackdss,	ef00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackdus,	ed00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorh,	e700040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorhg,	e700148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wrorw,	eb00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorwg,	eb00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wrord,	ef00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrordg,	ef00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsadb,	e000120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadbz,	e100120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadh,	e400120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadhz,	e500120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wshufh,	e0001e0, 3, (RIWR, RIWR, I255),	    iwmmxt_wshufh),
  CE(wsllh,	e500040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsllhg,	e500148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsllw,	e900040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsllwg,	e900148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wslld,	ed00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wslldg,	ed00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrah,	e400040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrahg,	e400148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsraw,	e800040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrawg,	e800148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrad,	ec00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsradg,	ec00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrlh,	e600040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrlhg,	e600148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrlw,	ea00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrlwg,	ea00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrld,	ee00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrldg,	ee00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wstrb,	c000000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wstrh,	c400000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wstrw,	c000100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
  CE(wstrd,	c400100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
  CE(wsubbss,	e3001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubb,	e0001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubbus,	e1001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubhss,	e7001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubh,	e4001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubhus,	e5001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubwss,	eb001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubw,	e8001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubwus,	e9001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckehub,e0000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehuh,e4000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehuw,e8000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsb,e2000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsh,e6000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsw,ea000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckihb, e1000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckihh, e5000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckihw, e9000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckelub,e0000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckeluh,e4000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckeluw,e8000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsb,e2000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsh,e6000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsw,ea000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckilb, e1000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckilh, e5000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckilw, e9000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wxor,	e100000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wzero,	e300000, 1, (RIWR),		    iwmmxt_wzero),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_MAVERICK /* Cirrus Maverick instructions.	*/
  CE(cfldrs,	c100400, 2, (RMF, ADDR),	      rd_cpaddr),
  CE(cfldrd,	c500400, 2, (RMD, ADDR),	      rd_cpaddr),
  CE(cfldr32,	c100500, 2, (RMFX, ADDR),	      rd_cpaddr),
  CE(cfldr64,	c500500, 2, (RMDX, ADDR),	      rd_cpaddr),
  CE(cfstrs,	c000400, 2, (RMF, ADDR),	      rd_cpaddr),
  CE(cfstrd,	c400400, 2, (RMD, ADDR),	      rd_cpaddr),
  CE(cfstr32,	c000500, 2, (RMFX, ADDR),	      rd_cpaddr),
  CE(cfstr64,	c400500, 2, (RMDX, ADDR),	      rd_cpaddr),
  CE(cfmvsr,	e000450, 2, (RMF, RR),		      rn_rd),
  CE(cfmvrs,	e100450, 2, (RR, RMF),		      rd_rn),
  CE(cfmvdlr,	e000410, 2, (RMD, RR),		      rn_rd),
  CE(cfmvrdl,	e100410, 2, (RR, RMD),		      rd_rn),
  CE(cfmvdhr,	e000430, 2, (RMD, RR),		      rn_rd),
  CE(cfmvrdh,	e100430, 2, (RR, RMD),		      rd_rn),
  CE(cfmv64lr,	e000510, 2, (RMDX, RR),		      rn_rd),
  CE(cfmvr64l,	e100510, 2, (RR, RMDX),		      rd_rn),
  CE(cfmv64hr,	e000530, 2, (RMDX, RR),		      rn_rd),
  CE(cfmvr64h,	e100530, 2, (RR, RMDX),		      rd_rn),
  CE(cfmval32,	e200440, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32al,	e100440, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmvam32,	e200460, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32am,	e100460, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmvah32,	e200480, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32ah,	e100480, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmva32,	e2004a0, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32a,	e1004a0, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmva64,	e2004c0, 2, (RMAX, RMDX),	      rd_rn),
  CE(cfmv64a,	e1004c0, 2, (RMDX, RMAX),	      rd_rn),
  CE(cfmvsc32,	e2004e0, 2, (RMDS, RMDX),	      mav_dspsc),
  CE(cfmv32sc,	e1004e0, 2, (RMDX, RMDS),	      rd),
  CE(cfcpys,	e000400, 2, (RMF, RMF),		      rd_rn),
  CE(cfcpyd,	e000420, 2, (RMD, RMD),		      rd_rn),
  CE(cfcvtsd,	e000460, 2, (RMD, RMF),		      rd_rn),
  CE(cfcvtds,	e000440, 2, (RMF, RMD),		      rd_rn),
  CE(cfcvt32s,	e000480, 2, (RMF, RMFX),	      rd_rn),
  CE(cfcvt32d,	e0004a0, 2, (RMD, RMFX),	      rd_rn),
  CE(cfcvt64s,	e0004c0, 2, (RMF, RMDX),	      rd_rn),
  CE(cfcvt64d,	e0004e0, 2, (RMD, RMDX),	      rd_rn),
  CE(cfcvts32,	e100580, 2, (RMFX, RMF),	      rd_rn),
  CE(cfcvtd32,	e1005a0, 2, (RMFX, RMD),	      rd_rn),
  CE(cftruncs32,e1005c0, 2, (RMFX, RMF),	      rd_rn),
  CE(cftruncd32,e1005e0, 2, (RMFX, RMD),	      rd_rn),
  CE(cfrshl32,	e000550, 3, (RMFX, RMFX, RR),	      mav_triple),
  CE(cfrshl64,	e000570, 3, (RMDX, RMDX, RR),	      mav_triple),
  CE(cfsh32,	e000500, 3, (RMFX, RMFX, I63s),	      mav_shift),
  CE(cfsh64,	e200500, 3, (RMDX, RMDX, I63s),	      mav_shift),
  CE(cfcmps,	e100490, 3, (RR, RMF, RMF),	      rd_rn_rm),
  CE(cfcmpd,	e1004b0, 3, (RR, RMD, RMD),	      rd_rn_rm),
  CE(cfcmp32,	e100590, 3, (RR, RMFX, RMFX),	      rd_rn_rm),
  CE(cfcmp64,	e1005b0, 3, (RR, RMDX, RMDX),	      rd_rn_rm),
  CE(cfabss,	e300400, 2, (RMF, RMF),		      rd_rn),
  CE(cfabsd,	e300420, 2, (RMD, RMD),		      rd_rn),
  CE(cfnegs,	e300440, 2, (RMF, RMF),		      rd_rn),
  CE(cfnegd,	e300460, 2, (RMD, RMD),		      rd_rn),
  CE(cfadds,	e300480, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfaddd,	e3004a0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfsubs,	e3004c0, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfsubd,	e3004e0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfmuls,	e100400, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfmuld,	e100420, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfabs32,	e300500, 2, (RMFX, RMFX),	      rd_rn),
  CE(cfabs64,	e300520, 2, (RMDX, RMDX),	      rd_rn),
  CE(cfneg32,	e300540, 2, (RMFX, RMFX),	      rd_rn),
  CE(cfneg64,	e300560, 2, (RMDX, RMDX),	      rd_rn),
  CE(cfadd32,	e300580, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfadd64,	e3005a0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfsub32,	e3005c0, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfsub64,	e3005e0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfmul32,	e100500, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmul64,	e100520, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfmac32,	e100540, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmsc32,	e100560, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmadd32,	e000600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
  CE(cfmsub32,	e100600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
  CE(cfmadda32, e200600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
  CE(cfmsuba32, e300600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
};
#undef ARM_VARIANT
#undef THUMB_VARIANT
#undef TCE
#undef TCM
#undef TUE
#undef TUF
#undef TCC
#undef CE
#undef CM
#undef UE
#undef UF
#undef UT
#undef OPS0
#undef OPS1
#undef OPS2
#undef OPS3
#undef OPS4
#undef OPS5
#undef OPS6
#undef do_0

/* MD interface: bits in the object file.  */

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).	*/

void
md_number_to_chars (char * buf, valueT val, int n)
d7505 1
a7505 5
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}
d7507 6
a7512 5
static valueT
md_chars_to_number (char * buf, int n)
{
  valueT result = 0;
  unsigned char * where = (unsigned char *) buf;
d7514 2
a7515 1
  if (target_big_endian)
d7517 3
a7519 5
      while (n--)
	{
	  result <<= 8;
	  result |= (*where++ & 255);
	}
d7521 3
a7523 1
  else
d7525 3
a7527 5
      while (n--)
	{
	  result <<= 8;
	  result |= (where[n] & 255);
	}
d7530 1
a7530 1
  return result;
d7533 4
a7536 1
/* MD interface: Sections.  */
d7538 6
a7543 7
int
md_estimate_size_before_relax (fragS * fragP ATTRIBUTE_UNUSED,
			       segT    segtype ATTRIBUTE_UNUSED)
{
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
}
d7545 7
a7551 1
/* Round up a section size to the appropriate boundary.	 */
d7553 1
a7553 10
valueT
md_section_align (segT	 segment ATTRIBUTE_UNUSED,
		  valueT size)
{
#ifdef OBJ_ELF
  return size;
#else
  /* Round all sects to multiple of 4.	*/
  return (size + 3) & ~3;
#endif
d7556 2
a7557 5
/* This is called from HANDLE_ALIGN in write.c.	 Fill in the contents
   of an rs_align_code fragment.  */

void
arm_handle_align (fragS * fragP)
d7559 1
a7559 4
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };
d7561 6
a7566 3
  int bytes, fix, noop_size;
  char * p;
  const char * noop;
d7568 7
a7574 2
  if (fragP->fr_type != rs_align_code)
    return;
d7576 2
a7577 3
  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;
d7579 4
a7582 2
  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;
d7584 1
a7584 1
  if (fragP->tc_frag_data)
d7586 3
a7588 5
      if (target_big_endian)
	noop = thumb_bigend_noop;
      else
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
d7590 3
a7592 1
  else
d7594 3
a7596 5
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
d7599 10
a7608 7
  if (bytes & (noop_size - 1))
    {
      fix = bytes & (noop_size - 1);
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }
d7610 2
a7611 1
  while (bytes >= noop_size)
d7613 3
a7615 4
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
d7618 1
a7618 2
  fragP->fr_fix += fix;
  fragP->fr_var = noop_size;
d7621 1
a7621 2
/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */
d7623 2
a7624 2
void
arm_frag_align_code (int n, int max)
d7626 9
a7634 1
  char * p;
d7636 3
a7638 4
  /* We assume that there will never be a requirement
     to support alignments greater than 32 bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
d7640 3
a7642 8
  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;
d7645 3
a7647 4
/* Perform target specific initialisation of a frag.  */

void
arm_init_frag (fragS * fragP)
d7649 2
a7650 3
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
}
d7652 5
a7656 2
#ifdef OBJ_ELF
/* When we change sections we need to issue a new mapping symbol.  */
d7658 3
a7660 5
void
arm_elf_change_section (void)
{
  flagword flags;
  segment_info_type *seginfo;
d7662 4
a7665 4
  /* Link an unlinked unwind index table section to the .text section.	*/
  if (elf_section_type (now_seg) == SHT_ARM_EXIDX
      && elf_linked_to_section (now_seg) == NULL)
    elf_linked_to_section (now_seg) = text_section;
d7667 6
a7672 2
  if (!SEG_NORMAL (now_seg))
    return;
d7674 21
a7694 1
  flags = bfd_get_section_flags (stdoutput, now_seg);
d7696 3
a7698 3
  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;
d7700 3
a7702 3
  seginfo = seg_info (now_seg);
  mapstate = seginfo->tc_segment_info_data.mapstate;
  marked_pr_dependency = seginfo->tc_segment_info_data.marked_pr_dependency;
d7705 2
a7706 2
int
arm_elf_section_type (const char * str, size_t len)
d7708 1
a7708 2
  if (len == 5 && strncmp (str, "exidx", 5) == 0)
    return SHT_ARM_EXIDX;
d7710 2
a7711 4
  return -1;
}

/* Code to deal with unwinding tables.	*/
d7713 7
a7719 1
static void add_unwind_adjustsp (offsetT);
d7721 2
a7722 1
/* Cenerate and deferred unwind frame offset.  */
d7725 1
a7725 1
flush_pending_unwind (void)
d7727 12
a7738 1
  offsetT offset;
d7740 1
a7740 4
  offset = unwind.pending_offset;
  unwind.pending_offset = 0;
  if (offset != 0)
    add_unwind_adjustsp (offset);
a7742 4
/* Add an opcode to this list for this function.  Two-byte opcodes should
   be passed as op[0] << 8 | op[1].  The list of opcodes is built in reverse
   order.  */

d7744 1
a7744 1
add_unwind_opcode (valueT op, int length)
d7746 1
a7746 3
  /* Add any deferred stack adjustment.	 */
  if (unwind.pending_offset)
    flush_pending_unwind ();
d7748 2
a7749 1
  unwind.sp_restored = 0;
d7751 4
a7754 1
  if (unwind.opcode_count + length > unwind.opcode_alloc)
d7756 3
a7758 13
      unwind.opcode_alloc += ARM_OPCODE_CHUNK_SIZE;
      if (unwind.opcodes)
	unwind.opcodes = xrealloc (unwind.opcodes,
				   unwind.opcode_alloc);
      else
	unwind.opcodes = xmalloc (unwind.opcode_alloc);
    }
  while (length > 0)
    {
      length--;
      unwind.opcodes[unwind.opcode_count] = op & 0xff;
      op >>= 8;
      unwind.opcode_count++;
d7760 2
a7763 2
/* Add unwind opcodes to adjust the stack pointer.  */

d7765 1
a7765 1
add_unwind_adjustsp (offsetT offset)
d7767 1
a7767 1
  valueT op;
d7769 2
a7770 13
  if (offset > 0x200)
    {
      /* We need at most 5 bytes to hold a 32-bit value in a uleb128.  */
      char bytes[5];
      int n;
      valueT o;

      /* Long form: 0xb2, uleb128.  */
      /* This might not fit in a word so add the individual bytes,
	 remembering the list is built in reverse order.  */
      o = (valueT) ((offset - 0x204) >> 2);
      if (o == 0)
	add_unwind_opcode (0, 1);
d7772 4
a7775 16
      /* Calculate the uleb128 encoding of the offset.	*/
      n = 0;
      while (o)
	{
	  bytes[n] = o & 0x7f;
	  o >>= 7;
	  if (o)
	    bytes[n] |= 0x80;
	  n++;
	}
      /* Add the insn.	*/
      for (; n; n--)
	add_unwind_opcode (bytes[n - 1], 1);
      add_unwind_opcode (0xb2, 1);
    }
  else if (offset > 0x100)
d7777 3
a7779 21
      /* Two short opcodes.  */
      add_unwind_opcode (0x3f, 1);
      op = (offset - 0x104) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset > 0)
    {
      /* Short opcode.	*/
      op = (offset - 4) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset < 0)
    {
      offset = -offset;
      while (offset > 0x100)
	{
	  add_unwind_opcode (0x7f, 1);
	  offset -= 0x100;
	}
      op = ((offset - 4) >> 2) | 0x40;
      add_unwind_opcode (op, 1);
d7781 2
a7784 1
/* Finish the list of unwind opcodes for this function.	 */
d7786 1
a7786 1
finish_unwind_opcodes (void)
d7788 4
a7791 1
  valueT op;
d7793 2
a7794 1
  if (unwind.fp_used)
d7796 4
a7799 3
      /* Adjust sp as neccessary.  */
      unwind.pending_offset += unwind.fp_offset - unwind.frame_size;
      flush_pending_unwind ();
d7801 1
a7801 6
      /* After restoring sp from the frame pointer.  */
      op = 0x90 | unwind.fp_reg;
      add_unwind_opcode (op, 1);
    }
  else
    flush_pending_unwind ();
d7804 15
d7820 2
a7821 2
/* Start an exception table entry.  If idx is nonzero this is an index table
   entry.  */
d7823 2
a7824 14
static void
start_unwind_section (const segT text_seg, int idx)
{
  const char * text_name;
  const char * prefix;
  const char * prefix_once;
  const char * group_name;
  size_t prefix_len;
  size_t text_len;
  char * sec_name;
  size_t sec_name_len;
  int type;
  int flags;
  int linkonce;
d7826 1
a7826 1
  if (idx)
d7828 2
a7829 3
      prefix = ELF_STRING_ARM_unwind;
      prefix_once = ELF_STRING_ARM_unwind_once;
      type = SHT_ARM_EXIDX;
d7833 2
a7834 3
      prefix = ELF_STRING_ARM_unwind_info;
      prefix_once = ELF_STRING_ARM_unwind_info_once;
      type = SHT_PROGBITS;
d7837 1
a7837 3
  text_name = segment_name (text_seg);
  if (streq (text_name, ".text"))
    text_name = "";
d7839 1
a7839 2
  if (strncmp (text_name, ".gnu.linkonce.t.",
	       strlen (".gnu.linkonce.t.")) == 0)
d7841 6
a7846 3
      prefix = prefix_once;
      text_name += strlen (".gnu.linkonce.t.");
    }
d7848 2
a7849 7
  prefix_len = strlen (prefix);
  text_len = strlen (text_name);
  sec_name_len = prefix_len + text_len;
  sec_name = xmalloc (sec_name_len + 1);
  memcpy (sec_name, prefix, prefix_len);
  memcpy (sec_name + prefix_len, text_name, text_len);
  sec_name[prefix_len + text_len] = '\0';
d7851 5
a7855 3
  flags = SHF_ALLOC;
  linkonce = 0;
  group_name = 0;
d7857 1
a7857 5
  /* Handle COMDAT group.  */
  if (prefix != prefix_once && (text_seg->flags & SEC_LINK_ONCE) != 0)
    {
      group_name = elf_group_name (text_seg);
      if (group_name == NULL)
d7859 2
a7860 4
	  as_bad ("Group section `%s' has no group signature",
		  segment_name (text_seg));
	  ignore_rest_of_line ();
	  return;
a7861 3
      flags |= SHF_GROUP;
      linkonce = 1;
    }
d7863 2
a7864 1
  obj_elf_change_section (sec_name, type, flags, 0, group_name, linkonce, 0);
d7866 1
a7866 4
  /* Set the setion link for index tables.  */
  if (idx)
    elf_linked_to_section (now_seg) = text_seg;
}
d7868 3
d7872 1
a7872 3
/* Start an unwind table entry.	 HAVE_DATA is nonzero if we have additional
   personality routine data.  Returns zero, or the index table value for
   and inline entry.  */
d7874 7
a7880 10
static valueT
create_unwind_entry (int have_data)
{
  int size;
  addressT where;
  char *ptr;
  /* The current word of data.	*/
  valueT data;
  /* The number of bytes left in this word.  */
  int n;
d7882 5
a7886 1
  finish_unwind_opcodes ();
d7888 20
a7907 3
  /* Remember the current text section.	 */
  unwind.saved_seg = now_seg;
  unwind.saved_subseg = now_subseg;
d7909 1
a7909 1
  start_unwind_section (now_seg, 0);
d7911 3
a7913 1
  if (unwind.personality_routine == NULL)
d7915 1
a7915 1
      if (unwind.personality_index == -2)
d7917 2
a7918 3
	  if (have_data)
	    as_bad (_("handerdata in cantunwind frame"));
	  return 1; /* EXIDX_CANTUNWIND.  */
d7920 1
d7922 2
a7923 8
      /* Use a default personality routine if none is specified.  */
      if (unwind.personality_index == -1)
	{
	  if (unwind.opcode_count > 3)
	    unwind.personality_index = 1;
	  else
	    unwind.personality_index = 0;
	}
d7925 4
a7928 5
      /* Space for the personality routine entry.  */
      if (unwind.personality_index == 0)
	{
	  if (unwind.opcode_count > 3)
	    as_bad (_("too many unwind opcodes for personality routine 0"));
d7930 1
a7930 11
	  if (!have_data)
	    {
	      /* All the data is inline in the index table.  */
	      data = 0x80;
	      n = 3;
	      while (unwind.opcode_count > 0)
		{
		  unwind.opcode_count--;
		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
		  n--;
		}
d7932 9
a7940 3
	      /* Pad with "finish" opcodes.  */
	      while (n--)
		data = (data << 8) | 0xb0;
d7942 5
a7946 7
	      return data;
	    }
	  size = 0;
	}
      else
	/* We get two opcodes "free" in the first word.	 */
	size = unwind.opcode_count - 2;
d7948 1
a7948 3
  else
    /* An extra byte is required for the opcode count.	*/
    size = unwind.opcode_count + 1;
d7950 2
a7951 3
  size = (size + 3) >> 2;
  if (size > 0xff)
    as_bad (_("too many unwind opcodes"));
d7953 4
a7956 3
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
  unwind.table_entry = expr_build_dot ();
d7958 2
a7959 3
  /* Allocate the table entry.	*/
  ptr = frag_more ((size << 2) + 4);
  where = frag_now_fix () - ((size << 2) + 4);
d7961 2
a7962 1
  switch (unwind.personality_index)
d7964 4
a7967 5
    case -1:
      /* ??? Should this be a PLT generating relocation?  */
      /* Custom personality routine.  */
      fix_new (frag_now, where, 4, unwind.personality_routine, 0, 1,
	       BFD_RELOC_ARM_PREL31);
d7969 2
a7970 2
      where += 4;
      ptr += 4;
d7972 4
a7975 4
      /* Set the first byte to the number of additional words.	*/
      data = size - 1;
      n = 3;
      break;
d7977 1
a7977 6
    /* ABI defined personality routines.  */
    case 0:
      /* Three opcodes bytes are packed into the first word.  */
      data = 0x80;
      n = 3;
      break;
d7979 5
a7983 10
    case 1:
    case 2:
      /* The size and first two opcode bytes go in the first word.  */
      data = ((0x80 + unwind.personality_index) << 8) | size;
      n = 2;
      break;

    default:
      /* Should never happen.  */
      abort ();
d7985 1
d7987 4
a7990 3
  /* Pack the opcodes into words (MSB first), reversing the list at the same
     time.  */
  while (unwind.opcode_count > 0)
d7992 3
a7994 10
      if (n == 0)
	{
	  md_number_to_chars (ptr, data, 4);
	  ptr += 4;
	  n = 4;
	  data = 0;
	}
      unwind.opcode_count--;
      n--;
      data = (data << 8) | unwind.opcodes[unwind.opcode_count];
d7997 7
a8003 6
  /* Finish off the last word.	*/
  if (n < 4)
    {
      /* Pad with "finish" opcodes.  */
      while (n--)
	data = (data << 8) | 0xb0;
d8005 2
a8006 2
      md_number_to_chars (ptr, data, 4);
    }
d8008 2
a8009 1
  if (!have_data)
d8011 3
a8013 3
      /* Add an empty descriptor if there is no user-specified data.   */
      ptr = frag_more (4);
      md_number_to_chars (ptr, 0, 4);
d8016 1
a8016 1
  return 0;
d8019 4
a8022 1
/* Convert REGNAME to a DWARF-2 register number.  */
d8024 2
a8025 4
int
tc_arm_regname_to_dw2regnum (const char *regname)
{
  int reg = arm_reg_parse ((char **) &regname, REG_TYPE_RN);
d8027 9
a8035 2
  if (reg == FAIL)
    return -1;
d8037 1
a8037 1
  return reg;
d8040 2
a8041 4
/* Initialize the DWARF-2 unwind information for this procedure.  */

void
tc_arm_frame_initial_instructions (void)
d8043 1
a8043 3
  cfi_add_CFA_def_cfa (REG_SP, 0);
}
#endif /* OBJ_ELF */
d8045 2
d8048 7
a8054 1
/* MD interface: Symbol and relocation handling.  */
d8056 2
a8057 2
/* The knowledge of the PC's pipeline offset is built into the insns
   themselves.	*/
d8059 2
a8060 2
long
md_pcrel_from (fixS * fixP)
d8062 4
a8065 4
  if (fixP->fx_addsy
      && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section
      && fixP->fx_subsy == NULL)
    return 0;
d8067 4
a8070 1
  if (fixP->fx_pcrel && (fixP->fx_r_type == BFD_RELOC_ARM_THUMB_ADD))
d8072 3
a8074 4
      /* PC relative addressing on the Thumb is slightly odd
	 as the bottom two bits of the PC are forced to zero
	 for the calculation.  */
      return (fixP->fx_where + fixP->fx_frag->fr_address) & ~3;
d8077 1
a8077 7
#ifdef TE_WINCE
  /* The pattern was adjusted to accommodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accommodation.	*/
  return fixP->fx_where + fixP->fx_frag->fr_address + 8;
#else
  return fixP->fx_where + fixP->fx_frag->fr_address;
#endif
d8080 19
a8098 2
/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
   Otherwise we have no need to default values of symbols.  */
d8100 3
a8102 6
symbolS *
md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
{
#ifdef OBJ_ELF
  if (name[0] == '_' && name[1] == 'G'
      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
d8104 1
a8104 1
      if (!GOT_symbol)
d8106 15
a8120 2
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");
d8122 1
a8122 3
	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, & zero_address_frag);
	}
d8124 4
a8127 1
      return GOT_symbol;
a8128 1
#endif
d8130 4
a8133 1
  return 0;
d8136 4
a8139 4
/* Subroutine of md_apply_fix3.	 Check to see if an immediate can be
   computed as two separate immediate values, added together.  We
   already know that this value cannot be computed by just one ARM
   instruction.	 */
d8141 2
a8142 6
static unsigned int
validate_immediate_twopart (unsigned int   val,
			    unsigned int * highpart)
{
  unsigned int a;
  unsigned int i;
d8144 7
a8150 23
  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
      {
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;
	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    assert (a & 0xff000000);
	    * highpart = (a >> 24) | ((i + 8) << 7);
	  }

	return (a & 0xff) | (i << 7);
      }
d8152 1
a8152 1
  return FAIL;
d8155 2
a8156 2
static int
validate_offset_imm (unsigned int val, int hwse)
d8158 14
a8171 3
  if ((hwse && val > 255) || val > 4095)
    return FAIL;
  return val;
d8174 2
a8175 14
/* Subroutine of md_apply_fix3.	 Do those data_ops which can take a
   negative immediate constant by altering the instruction.  A bit of
   a hack really.
	MOV <-> MVN
	AND <-> BIC
	ADC <-> SBC
	by inverting the second operand, and
	ADD <-> SUB
	CMP <-> CMN
	by negating the second operand.	 */

static int
negate_data_op (unsigned long * instruction,
		unsigned long	value)
d8177 1
a8177 2
  int op, new_inst;
  unsigned long negated, inverted;
d8179 6
a8184 2
  negated = encode_arm_immediate (-value);
  inverted = encode_arm_immediate (~value);
d8186 2
a8187 2
  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
  switch (op)
d8189 7
a8195 5
      /* First negates.	 */
    case OPCODE_SUB:		 /* ADD <-> SUB	 */
      new_inst = OPCODE_ADD;
      value = negated;
      break;
d8197 4
a8200 4
    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
      value = negated;
      break;
d8202 6
a8207 4
    case OPCODE_CMP:		 /* CMP <-> CMN	 */
      new_inst = OPCODE_CMN;
      value = negated;
      break;
d8209 7
a8215 4
    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
      value = negated;
      break;
d8217 2
a8218 5
      /* Now Inverted ops.  */
    case OPCODE_MOV:		 /* MOV <-> MVN	 */
      new_inst = OPCODE_MVN;
      value = inverted;
      break;
a8219 4
    case OPCODE_MVN:
      new_inst = OPCODE_MOV;
      value = inverted;
      break;
d8221 5
a8225 4
    case OPCODE_AND:		 /* AND <-> BIC	 */
      new_inst = OPCODE_BIC;
      value = inverted;
      break;
d8227 1
a8227 4
    case OPCODE_BIC:
      new_inst = OPCODE_AND;
      value = inverted;
      break;
d8229 2
a8230 4
    case OPCODE_ADC:		  /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
      value = inverted;
      break;
d8232 1
a8232 4
    case OPCODE_SBC:
      new_inst = OPCODE_ADC;
      value = inverted;
      break;
d8234 9
a8242 3
      /* We cannot do anything.	 */
    default:
      return FAIL;
d8245 8
a8252 2
  if (value == (unsigned) FAIL)
    return FAIL;
d8254 2
a8255 3
  *instruction &= OPCODE_MASK;
  *instruction |= new_inst << DATA_OP_SHIFT;
  return value;
d8258 2
a8259 4
void
md_apply_fix3 (fixS *	fixP,
	       valueT * valP,
	       segT	seg)
d8261 4
a8264 9
  offsetT	 value = * valP;
  offsetT	 newval;
  unsigned int	 newimm;
  unsigned long	 temp;
  int		 sign;
  char *	 buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  /* The double cast here prevents warnings about converting a pointer
     to an integer of different size.  We know the value is 0, 1, or 2.	 */
  int		 fix_is_thumb = (int) (size_t) fixP->tc_fix_data;
d8266 2
a8267 1
  assert (fixP->fx_r_type <= BFD_RELOC_UNUSED);
d8269 1
a8269 3
  /* Note whether this will delete the relocation.  */
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
    fixP->fx_done = 1;
d8271 6
a8276 4
  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo it's effects here.  */
  if (fixP->fx_pcrel)
d8278 2
a8279 4
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
d8282 7
a8288 2
  /* Remember value for emit_reloc.  */
  fixP->fx_addnumber = value;
d8290 3
a8292 6
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_NONE:
      /* This will need to go in the object file.  */
      fixP->fx_done = 0;
      break;
d8294 3
a8296 5
    case BFD_RELOC_ARM_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;
d8298 5
a8302 8
      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
	}
d8304 5
a8308 2
      newimm = encode_arm_immediate (value);
      temp = md_chars_to_number (buf, INSN_SIZE);
d8310 5
a8314 10
      /* If the instruction will fail, see if we can fix things up by
	 changing the opcode.  */
      if (newimm == (unsigned int) FAIL
	  && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}
d8316 5
a8320 3
      newimm |= (temp & 0xfffff000);
      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
      break;
d8322 5
a8326 4
    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      {
	unsigned int highpart = 0;
	unsigned int newinsn  = 0xe1a00000; /* nop.  */
d8328 5
a8332 2
	newimm = encode_arm_immediate (value);
	temp = md_chars_to_number (buf, INSN_SIZE);
d8334 4
a8337 8
	/* If the instruction will fail, see if we can fix things up by
	   changing the opcode.	 */
	if (newimm == (unsigned int) FAIL
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
	  {
	    /* No ?  OK - try using two ADD instructions to generate
	       the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);
d8339 6
a8344 15
	    /* Yes - then make sure that the second instruction is
	       also an add.  */
	    if (newimm != (unsigned int) FAIL)
	      newinsn = temp;
	    /* Still No ?  Try using a negated value.  */
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
	    /* Otherwise - give up.  */
	    else
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
			      (long) value);
		break;
	      }
d8346 2
a8347 7
	    /* Replace the first operand in the 2nd instruction (which
	       is the PC) with the destination register.  We have
	       already added in the PC in the first instruction and we
	       do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
	    newinsn |= ((newinsn & 0x0f000) << 4);
	  }
d8349 4
a8352 2
	newimm |= (temp & 0xfffff000);
	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
d8354 33
a8386 4
	highpart |= (newinsn & 0xfffff000);
	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
      }
      break;
d8388 2
a8389 3
    case BFD_RELOC_ARM_OFFSET_IMM:
    case BFD_RELOC_ARM_LITERAL:
      sign = value >= 0;
d8391 7
a8397 2
      if (value < 0)
	value = - value;
d8399 2
a8400 11
      if (validate_offset_imm (value, 0) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_LITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad immediate value for offset (%ld)"),
			  (long) value);
	  break;
	}
d8402 1
a8402 5
      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8404 2
a8405 3
    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
      sign = value >= 0;
d8407 4
a8410 2
      if (value < 0)
	value = - value;
d8412 1
a8412 10
      if (validate_offset_imm (value, 1) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad (_("bad immediate value for half-word offset (%ld)"),
		    (long) value);
	  break;
	}
d8414 7
a8420 5
      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff0f0;
      newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8422 11
a8432 5
    case BFD_RELOC_ARM_T32_OFFSET_U8:
      if (value < 0 || value > 1020 || value % 4 != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("bad immediate value for offset (%ld)"), (long) value);
      value /= 4;
d8434 16
a8449 28
      newval = md_chars_to_number (buf+2, THUMB_SIZE);
      newval &= 0xff00;
      newval |= value;
      md_number_to_chars (buf+2, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_T32_OFFSET_IMM:
      /* This is a complicated relocation used for all varieties of Thumb32
	 load/store instruction with immediate offset:

	 1110 100P u1WL NNNN XXXX YYYY iiii iiii - +/-(U) pre/post(P) 8-bit,
	                                           *4, optional writeback(W)
						   (doubleword load/store)

	 1111 100S uTTL 1111 XXXX iiii iiii iiii - +/-(U) 12-bit PC-rel
	 1111 100S 0TTL NNNN XXXX 1Pu1 iiii iiii - +/-(U) pre/post(P) 8-bit
	 1111 100S 0TTL NNNN XXXX 1110 iiii iiii - positive 8-bit (T instruction)
	 1111 100S 1TTL NNNN XXXX iiii iiii iiii - positive 12-bit
	 1111 100S 0TTL NNNN XXXX 1100 iiii iiii - negative 8-bit

	 Uppercase letters indicate bits that are already encoded at
	 this point.  Lowercase letters are our problem.  For the
	 second block of instructions, the secondary opcode nybble
	 (bits 8..11) is present, and bit 23 is zero, even if this is
	 a PC-relative operation.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      newval <<= 16;
      newval |= md_chars_to_number (buf+THUMB_SIZE, THUMB_SIZE);
d8451 6
a8456 1
      if ((newval & 0xf0000000) == 0xe0000000)
d8458 1
a8458 6
	  /* Doubleword load/store: 8-bit offset, scaled by 4.  */
	  if (value >= 0)
	    newval |= (1 << 23);
	  else
	    value = -value;
	  if (value % 4 != 0)
d8460 2
a8461 3
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset not a multiple of 4"));
	      break;
d8463 3
a8465 2
	  value /= 4;
	  if (value >= 0xff)
d8467 2
a8468 3
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
d8470 5
a8474 1
	  newval &= ~0xff;
d8476 1
a8476 1
      else if ((newval & 0x0000f000) == 0x0000f0000)
d8478 2
a8479 12
	  /* PC-relative, 12-bit offset.  */
	  if (value >= 0)
	    newval |= (1 << 23);
	  else
	    value = -value;
	  if (value >= 0xfff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xfff;
d8481 9
a8489 1
      else if ((newval & 0x00000100) == 0x00000100)
d8491 2
a8492 12
	  /* Writeback: 8-bit, +/- offset.  */
	  if (value >= 0)
	    newval |= (1 << 9);
	  else
	    value = -value;
	  if (value >= 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
d8494 2
a8495 1
      else if ((newval & 0x00000f00) == 0x00000e00)
d8497 5
a8501 9
	  /* T-instruction: positive 8-bit offset.  */
	  if (value < 0 || value >= 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
	  newval |= value;
d8505 33
a8537 3
	  /* Positive 12-bit or negative 8-bit offset.  */
	  int limit;
	  if (value >= 0)
d8539 9
a8547 2
	      newval |= (1 << 23);
	      limit = 0xfff;
d8549 1
a8549 1
	  else
d8551 7
a8557 2
	      value = -value;
	      limit = 0xff;
d8559 1
a8559 1
	  if (value > limit)
d8561 7
a8567 3
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
a8568 1
	  newval &= ~limit;
d8570 4
d8575 4
a8578 4
      newval |= value;
      md_number_to_chars (buf, (newval >> 16) & 0xffff, THUMB_SIZE);
      md_number_to_chars (buf + THUMB_SIZE, newval & 0xffff, THUMB_SIZE);
      break;
d8580 1
a8580 10
    case BFD_RELOC_ARM_SHIFT_IMM:
      newval = md_chars_to_number (buf, INSN_SIZE);
      if (((unsigned long) value) > 32
	  || (value == 32
	      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("shift expression is too large"));
	  break;
	}
d8582 7
a8588 9
      if (value == 0)
	/* Shifts of zero must be done as lsl.	*/
	newval &= ~0x60;
      else if (value == 32)
	value = 0;
      newval &= 0xfffff07f;
      newval |= (value & 0x1f) << 7;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8590 12
a8601 5
    case BFD_RELOC_ARM_T32_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;
d8603 8
a8610 2
      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
d8612 3
a8614 4
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
d8616 3
d8620 2
a8621 3
      newval = md_chars_to_number (buf, THUMB_SIZE);
      newval <<= 16;
      newval |= md_chars_to_number (buf+2, THUMB_SIZE);
d8623 7
a8629 1
      newimm = encode_thumb32_immediate (value);
d8631 1
a8631 2
      /* FUTURE: Implement analogue of negate_data_op for T32.  */
      if (newimm == (unsigned int)FAIL)
d8633 3
a8635 4
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
d8638 10
a8647 17
      newval &= 0xfbff8f00;
      newval |= (newimm & 0x800) << 15;
      newval |= (newimm & 0x700) << 4;
      newval |= (newimm & 0x0ff);

      md_number_to_chars (buf,   (valueT) ((newval >> 16) & 0xffff), THUMB_SIZE);
      md_number_to_chars (buf+2, (valueT) (newval & 0xffff), THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_SMI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid smi expression"));
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xfff000f0;
      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8649 1
a8649 2
    case BFD_RELOC_ARM_SWI:
      if (fix_is_thumb)
d8651 3
a8653 6
	  if (((unsigned long) value) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, THUMB_SIZE) & 0xff00;
	  newval |= value;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
d8657 7
a8663 8
	  if (((unsigned long) value) > 0x00ffffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, INSN_SIZE) & 0xff000000;
	  newval |= value;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;
d8665 3
a8667 7
    case BFD_RELOC_ARM_MULTI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid expression in load/store multiple"));
      newval = value | md_chars_to_number (buf, INSN_SIZE);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8669 3
a8671 2
    case BFD_RELOC_ARM_PCREL_BRANCH:
      newval = md_chars_to_number (buf, INSN_SIZE);
d8673 23
a8695 2
      /* Sign-extend a 24-bit number.  */
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)
d8697 5
a8701 3
#ifdef OBJ_ELF
      value = fixP->fx_offset;
#endif
d8703 1
a8703 6
      /* We are going to store value (shifted right by two) in the
	 instruction, in a 24 bit, signed field  Thus we need to check
	 that none of the top 8 bits of the shifted value (top 7 bits of
	 the unshifted, unsigned value) are set, or that they are all set.  */
      if ((value & ~ ((offsetT) 0x1ffffff)) != 0
	  && ((value & ~ ((offsetT) 0x1ffffff)) != ~ ((offsetT) 0x1ffffff)))
d8705 1
a8705 13
#ifdef OBJ_ELF
	  /* Normally we would be stuck at this point, since we cannot store
	     the absolute address that is the destination of the branch in the
	     24 bits of the branch instruction.	 If however, we happen to know
	     that the destination of the branch is in the same section as the
	     branch instruction itself, then we can compute the relocation for
	     ourselves and not have to bother the linker with it.

	     FIXME: The test for OBJ_ELF is only here because I have not
	     worked out how to do this for OBJ_COFF.  */
	  if (fixP->fx_addsy != NULL
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
d8707 3
a8709 9
	      /* Get pc relative value to go into the branch.  */
	      value = * valP;

	      /* Permit a backward branch provided that enough bits
		 are set.  Allow a forwards branch, provided that
		 enough bits are clear.	 */
	      if (   (value & ~ ((offsetT) 0x1ffffff)) == ~ ((offsetT) 0x1ffffff)
		  || (value & ~ ((offsetT) 0x1ffffff)) == 0)
		fixP->fx_done = 1;
d8711 8
d8720 13
a8732 4
	  if (! fixP->fx_done)
#endif
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("GAS can't handle same-section branch dest >= 0x04000000"));
d8735 7
a8741 2
      value >>= 2;
      value += SEXT24 (newval);
d8743 1
a8743 4
      if (    (value & ~ ((offsetT) 0xffffff)) != 0
	  && ((value & ~ ((offsetT) 0xffffff)) != ~ ((offsetT) 0xffffff)))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("out of range branch"));
d8745 2
a8746 1
      if (seg->use_rela_p && !fixP->fx_done)
d8748 2
a8749 7
	  /* Must unshift the value before storing it in the addend.  */
	  value <<= 2;
#ifdef OBJ_ELF
	  fixP->fx_offset = value;
#endif
	  fixP->fx_addnumber = value;
	  newval = newval & 0xff000000;
a8750 4
      else
	  newval = (value & 0x00ffffff) | (newval & 0xff000000);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8752 9
a8760 4
    case BFD_RELOC_ARM_PCREL_BLX:
      {
	offsetT hbit;
	newval = md_chars_to_number (buf, INSN_SIZE);
d8762 7
a8768 6
#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	hbit   = (value >> 1) & 1;
	value  = (value >> 2) & 0x00ffffff;
	value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;
d8770 5
a8774 17
	if (seg->use_rela_p && !fixP->fx_done)
	  {
	    /* Must sign-extend and unshift the value before storing
	       it in the addend.  */
	    value = SEXT24 (value);
	    value = (value << 2) | hbit;
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xfe000000;
	  }
	else
	  newval = value | (newval & 0xfe000000) | (hbit << 24);
	md_number_to_chars (buf, newval, INSN_SIZE);
      }
      break;
d8776 6
a8781 10
    case BFD_RELOC_THUMB_PCREL_BRANCH7: /* CZB */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = ((newval & 0x00f8) >> 2) | (newval & 0x0200) >> 3;
	/* This one does not have the offset encoded in the pattern.  */
	value = value + diff - 4;
	/* CZB can only branch forward.  */
	if (value & ~0x7e)
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
d8783 7
a8789 13
	newval &= 0xfd07;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
	  newval |= ((value & 0x2e) << 2) | ((value & 0x40) << 3);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d8791 17
a8807 6
    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.	*/
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0xff) << 1;
	if (diff & 0x100)
	  diff |= ~0xff;
d8809 6
a8814 17
	value += diff;
	if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xff00;
	  }
	else
	  newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d8816 4
a8819 6
    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0x7ff) << 1;
	if (diff & 0x800)
	  diff |= ~0x7ff;
d8821 5
a8825 17
	value += diff;
	if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	  }
	else
	  newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d8827 22
a8848 4
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
      {
	offsetT newval2;
	addressT diff, S, J1, J2, lo, hi;
d8850 1
a8850 2
	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
d8852 3
a8854 5
	S  = !(newval & 0x0400);  /* flipped - 0=negative */
	hi = (newval  & 0x003f);
	J1 = (newval2 & 0x2000) >> 13;
	J2 = (newval2 & 0x0800) >> 11;
	lo = (newval2 & 0x07ff);
d8856 22
a8877 3
	diff = ((S << 20) | (J2 << 19) | (J1 << 18) | (hi << 12) | (lo << 1));
	diff -= (1 << 20);  /* sign extend */
	value += diff;
d8879 2
a8880 3
	if ((value & ~0x1fffff) && ((value & ~0x1fffff) != ~0x1fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("conditional branch out of range"));
d8882 2
a8883 16
	newval  = newval  & 0xfbc0;
	newval2 = newval2 & 0xd000;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
	  {
	    S  = (value & 0x00100000) >> 20;
	    J2 = (value & 0x00080000) >> 19;
	    J1 = (value & 0x00040000) >> 18;
	    hi = (value & 0x0003f000) >> 12;
	    lo = (value & 0x00000ffe) >> 1;
d8885 1
a8885 3
	    newval  = newval  | (S << 10) | hi;
	    newval2 = newval2 | (J1 << 13) | (J2 << 11) | lo;
	  }
d8887 1
a8887 4
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;
d8889 2
a8890 5
    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      {
	offsetT newval2;
	addressT diff;
d8892 5
a8896 9
	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	if (diff & 0x400000)
	  diff |= ~0x3fffff;
#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	value += diff;
d8898 4
a8901 3
	if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch with link out of range"));
d8903 2
a8904 6
	if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  value = (value + 1) & ~ 1;
d8906 2
a8907 18
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	    newval2 = newval2 & 0xf800;
	  }
	else
	  {
	    newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
	    newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	  }
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;
d8909 7
a8915 7
    case BFD_RELOC_8:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 1);
#ifdef OBJ_ELF
      else
d8917 4
a8920 2
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 1);
a8921 2
#endif
      break;
d8923 3
a8925 4
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
      {
	offsetT newval2;
	addressT diff, S, I1, I2, lo, hi;
d8927 3
a8929 2
	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
d8931 2
a8932 9
	S  = (newval  & 0x0400) >> 10;
	hi = (newval  & 0x03ff);
	I1 = (newval2 & 0x2000) >> 13;
	I2 = (newval2 & 0x0800) >> 11;
	lo = (newval2 & 0x07ff);

	I1 = !(I1 ^ S);
	I2 = !(I2 ^ S);
	S  = !S;
d8934 1
a8934 3
	diff = ((S << 24) | (I1 << 23) | (I2 << 22) | (hi << 12) | (lo << 1));
	diff -= (1 << 24);  /* sign extend */
	value += diff;
d8936 1
a8936 3
	if ((value & ~0x1ffffff) && ((value & ~0x1ffffff) != ~0x1ffffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
d8938 7
a8944 16
	newval  = newval  & 0xf800;
	newval2 = newval2 & 0xd000;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
	  {
	    S  = (value & 0x01000000) >> 24;
	    I1 = (value & 0x00800000) >> 23;
	    I2 = (value & 0x00400000) >> 22;
	    hi = (value & 0x003ff000) >> 12;
	    lo = (value & 0x00000ffe) >> 1;
d8946 2
a8947 2
	    I1 = !(I1 ^ S);
	    I2 = !(I2 ^ S);
d8949 1
a8949 7
	    newval  = newval  | (S << 10) | hi;
	    newval2 = newval2 | (I1 << 13) | (I2 << 11) | lo;
	  }
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;
d8951 10
a8960 13
    case BFD_RELOC_16:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 2);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 2);
	}
#endif
      break;
d8962 1
a8962 8
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
    case BFD_RELOC_ARM_TLS_LDO32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* fall through */
d8964 8
a8971 8
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_TARGET2:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      md_number_to_chars (buf, 0, 4);
      break;
#endif
d8973 3
a8975 18
    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_32_PCREL:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 4);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 4);
	}
#endif
      break;
d8977 1
a8977 14
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PREL31:
      if (fixP->fx_done || fixP->fx_pcrel)
	{
	  newval = md_chars_to_number (buf, 4) & 0x80000000;
	  if ((value ^ (value >> 1)) & 0x40000000)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("rel31 relocation overflow"));
	    }
	  newval |= value & 0x7fffffff;
	  md_number_to_chars (buf, newval, 4);
	}
      break;
d8979 12
a8990 4
    case BFD_RELOC_ARM_PLT32:
      /* It appears the instruction is fully prepared at this point.  */
      break;
#endif
d8992 1
a8992 14
    case BFD_RELOC_ARM_CP_OFF_IMM:
      if (value < -1023 || value > 1023 || (value & 3))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("co-processor offset out of range"));
    cp_off_common:
      sign = value >= 0;
      if (value < 0)
	value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= (value >> 2) | (sign ? INDEX_UP : 0);
      if (value == 0)
	newval &= ~WRITE_BACK;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8994 5
a8998 5
    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
      if (value < -255 || value > 255)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("co-processor offset out of range"));
      goto cp_off_common;
d9000 5
a9004 13
    case BFD_RELOC_ARM_THUMB_OFFSET:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      /* Exactly what ranges, and where the offset is inserted depends
	 on the type of instruction, we can establish this from the
	 top 4 bits.  */
      switch (newval >> 12)
	{
	case 4: /* PC load.  */
	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
	     forced to zero for these loads, so we will need to round
	     up the offset if the instruction address is not word
	     aligned (since the final address produced must be, and
	     we can only describe word-aligned immediate offsets).  */
d9006 5
a9010 5
	  if (value & 3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, target not word aligned (0x%08lX)"),
			  (((unsigned int) fixP->fx_frag->fr_address
			    + (unsigned int) fixP->fx_where) & ~3) + value);
d9012 5
a9016 4
	  if ((value + 2) & ~0x3fe)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
d9018 5
a9022 3
	  /* Round up, since pc will be rounded down.  */
	  newval |= (value + 2) >> 2;
	  break;
d9024 5
a9028 7
	case 9: /* SP load/store.  */
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value >> 2;
	  break;
d9030 5
a9034 7
	case 6: /* Word load/store.  */
	  if (value & ~0x7c)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 4; /* 6 - 2.  */
	  break;
d9036 5
a9040 7
	case 7: /* Byte load/store.  */
	  if (value & ~0x1f)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 6;
	  break;
d9042 5
a9046 7
	case 8: /* Halfword load/store.	 */
	  if (value & ~0x3e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 5; /* 6 - 1.  */
	  break;
d9048 5
a9052 8
	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"Unable to process relocation for thumb opcode: %lx",
			(unsigned long) newval);
	  break;
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9054 5
a9058 3
    case BFD_RELOC_ARM_THUMB_ADD:
      /* This is a complicated relocation, since we use it for all of
	 the following immediate relocations:
d9060 17
a9076 4
	    3bit ADD/SUB
	    8bit ADD/SUB
	    9bit ADD/SUB SP word-aligned
	   10bit ADD PC/SP word-aligned
d9078 5
a9082 2
	 The type of instruction being processed is encoded in the
	 instruction field:
d9084 5
a9088 9
	   0x8000  SUB
	   0x00F0  Rd
	   0x000F  Rs
      */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	int rd = (newval >> 4) & 0xf;
	int rs = newval & 0xf;
	int subtract = !!(newval & 0x8000);
d9090 5
a9094 6
	/* Check for HI regs, only very restricted cases allowed:
	   Adjusting SP, and using PC or SP to get an address.	*/
	if ((rd > 7 && (rd != REG_SP || rs != REG_SP))
	    || (rs > 7 && rs != REG_SP && rs != REG_PC))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid Hi register with immediate"));
d9096 5
a9100 9
	/* If value is negative, choose the opposite instruction.  */
	if (value < 0)
	  {
	    value = -value;
	    subtract = !subtract;
	    if (value < 0)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	  }
d9102 5
a9106 37
	if (rd == REG_SP)
	  {
	    if (value & ~0x1fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for stack address calculation"));
	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	    newval |= value >> 2;
	  }
	else if (rs == REG_PC || rs == REG_SP)
	  {
	    if (subtract || value & ~0x3fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for address calculation (value = 0x%08lX)"),
			    (unsigned long) value);
	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
	    newval |= rd << 8;
	    newval |= value >> 2;
	  }
	else if (rs == rd)
	  {
	    if (value & ~0xff)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	    newval |= (rd << 8) | value;
	  }
	else
	  {
	    if (value & ~0x7)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	    newval |= rd | (rs << 3) | (value << 6);
	  }
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9108 5
a9112 9
    case BFD_RELOC_ARM_THUMB_IMM:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      if (value < 0 || value > 255)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid immediate: %ld is too large"),
		      (long) value);
      newval |= value;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9114 5
a9118 16
    case BFD_RELOC_ARM_THUMB_SHIFT:
      /* 5bit shift value (0..32).  LSL cannot take 32.	 */
      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf83f;
      temp = newval & 0xf800;
      if (value < 0 || value > 32 || (value == 32 && temp == T_OPCODE_LSL_I))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid shift value: %ld"), (long) value);
      /* Shifts of zero must be encoded as LSL.	 */
      if (value == 0)
	newval = (newval & 0x003f) | T_OPCODE_LSL_I;
      /* Shifts of 32 are encoded as zero.  */
      else if (value == 32)
	value = 0;
      newval |= value << 6;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9120 5
a9124 4
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;
d9126 4
a9129 5
    case BFD_RELOC_UNUSED:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
    }
d9132 5
a9136 2
/* Translate internal representation of relocation info to BFD target
   format.  */
d9138 2
a9139 3
arelent *
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED,
	      fixS *	 fixp)
d9141 2
a9142 2
  arelent * reloc;
  bfd_reloc_code_real_type code;
d9144 5
a9148 1
  reloc = xmalloc (sizeof (arelent));
d9150 5
a9154 3
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
d9156 5
a9160 9
  /* @@@@ Why fx_addnumber sometimes and fx_offset other times?  */
#ifndef OBJ_ELF
  if (fixp->fx_pcrel == 0)
    reloc->addend = fixp->fx_offset;
  else
    reloc->addend = fixp->fx_offset = reloc->address;
#else  /* OBJ_ELF */
  reloc->addend = fixp->fx_offset;
#endif
d9162 5
a9166 8
  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_8:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_8_PCREL;
	  break;
	}
d9168 5
a9172 6
    case BFD_RELOC_16:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_16_PCREL;
	  break;
	}
d9174 5
a9178 6
    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_32_PCREL;
	  break;
	}
d9180 5
a9184 15
    case BFD_RELOC_NONE:
    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_RVA:
    case BFD_RELOC_THUMB_PCREL_BRANCH7:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      code = fixp->fx_r_type;
      break;
d9186 2
a9187 7
    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_HWLITERAL:
      /* If this is called then the a literal has
	 been referenced across a section boundary.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("literal referenced across section boundary"));
      return NULL;
d9189 14
a9202 13
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_PLT32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_ARM_PREL31:
    case BFD_RELOC_ARM_TARGET2:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_LDO32:
      code = fixp->fx_r_type;
      break;
d9204 1
a9204 10
    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
      /* BFD will include the symbol's address in the addend.
	 But we don't want that, so subtract it out again here.  */
      if (!S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= (*reloc->sym_ptr_ptr)->value;
      code = fixp->fx_r_type;
      break;
#endif
d9206 14
a9219 4
    case BFD_RELOC_ARM_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal relocation (type: IMMEDIATE) not fixed up"));
      return NULL;
d9221 6
a9226 4
    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("ADRL used for a symbol not defined in the same file"));
      return NULL;
d9228 6
a9233 10
    case BFD_RELOC_ARM_OFFSET_IMM:
      if (fixp->fx_addsy != NULL
	  && !S_IS_DEFINED (fixp->fx_addsy)
	  && S_IS_LOCAL (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("undefined local label `%s'"),
			S_GET_NAME (fixp->fx_addsy));
	  return NULL;
	}
d9235 5
a9239 3
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
      return NULL;
d9241 7
a9247 3
    default:
      {
	char * type;
d9249 63
a9311 20
	switch (fixp->fx_r_type)
	  {
	  case BFD_RELOC_NONE:		   type = "NONE";	  break;
	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
	  case BFD_RELOC_ARM_SHIFT_IMM:	   type = "SHIFT_IMM";	  break;
	  case BFD_RELOC_ARM_SMI:	   type = "SMI";	  break;
	  case BFD_RELOC_ARM_SWI:	   type = "SWI";	  break;
	  case BFD_RELOC_ARM_MULTI:	   type = "MULTI";	  break;
	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";	  break;
	  case BFD_RELOC_ARM_THUMB_ADD:	   type = "THUMB_ADD";	  break;
	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
	  case BFD_RELOC_ARM_THUMB_IMM:	   type = "THUMB_IMM";	  break;
	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
	  default:			   type = _("<unknown>"); break;
	  }
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("cannot represent %s relocation in this object file format"),
		      type);
	return NULL;
      }
d9314 1
a9314 4
#ifdef OBJ_ELF
  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
d9316 2
a9317 2
      code = BFD_RELOC_ARM_GOTPC;
      reloc->addend = fixp->fx_offset = reloc->address;
a9318 1
#endif
d9320 8
a9327 1
  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
d9329 2
a9330 1
  if (reloc->howto == NULL)
d9332 2
a9333 4
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
d9336 8
a9343 4
  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;
d9345 4
a9348 1
  return reloc;
d9351 5
a9355 1
/* This fix_new is called by cons via TC_CONS_FIX_NEW.	*/
d9357 2
a9358 5
void
cons_fix_new_arm (fragS *	frag,
		  int		where,
		  int		size,
		  expressionS * exp)
d9360 15
a9374 2
  bfd_reloc_code_real_type type;
  int pcrel = 0;
d9376 1
a9376 3
  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
  switch (size)
d9378 2
a9379 13
    case 1:
      type = BFD_RELOC_8;
      break;
    case 2:
      type = BFD_RELOC_16;
      break;
    case 4:
    default:
      type = BFD_RELOC_32;
      break;
    case 8:
      type = BFD_RELOC_64;
      break;
d9382 2
a9383 2
  fix_new_exp (frag, where, (int) size, exp, pcrel, type);
}
d9385 6
a9390 12
#if defined OBJ_COFF || defined OBJ_ELF
void
arm_validate_fix (fixS * fixP)
{
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.	*/
  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
      && fixP->fx_addsy != NULL
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! THUMB_IS_FUNC (fixP->fx_addsy))
d9392 2
a9393 1
      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
d9395 4
a9399 1
#endif
d9401 6
a9406 2
int
arm_force_relocation (struct fix * fixp)
d9408 3
a9410 11
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixp->fx_r_type == BFD_RELOC_RVA)
    return 1;
#endif
#ifdef OBJ_ELF
  if (fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;
#endif
d9412 5
a9416 5
  /* Resolve these relocations even if the symbol is extern or weak.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 0;
d9418 4
a9421 2
  return generic_force_reloc (fixp);
}
d9423 1
a9423 6
#ifdef OBJ_COFF
/* This is a little hack to help the gas/arm/adrl.s test.  It prevents
   local labels from being added to the output symbol table when they
   are used with the ADRL pseudo op.  The ADRL relocation should always
   be resolved before the binbary is emitted, so it is safe to say that
   it is adjustable.  */
d9425 2
a9426 8
bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 1;
  return 0;
}
#endif
d9428 5
a9432 6
#ifdef OBJ_ELF
/* Relocations against Thumb function names must be left unadjusted,
   so that the linker can use this information to correctly set the
   bottom bit of their addresses.  The MIPS version of this function
   also prevents relocations that are mips-16 specific, but I do not
   know why it does this.
d9434 14
a9447 6
   FIXME:
   There is one other problem that ought to be addressed here, but
   which currently is not:  Taking the address of a label (rather
   than a function) and then later jumping to that address.  Such
   addresses also ought to have their bottom bit set (assuming that
   they reside in Thumb code), but at the moment they will not.	 */
d9449 3
a9451 5
bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_addsy == NULL)
    return 1;
d9453 2
a9454 3
  if (THUMB_IS_FUNC (fixP->fx_addsy)
      && fixP->fx_subsy == NULL)
    return 0;
d9456 4
a9459 4
  /* We need the symbol name for the VTABLE entries.  */
  if (	 fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;
d9461 3
a9463 11
  /* Don't allow symbols to be discarded on GOT related relocs.	 */
  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GD32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_IE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDM32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDO32
      || fixP->fx_r_type == BFD_RELOC_ARM_TARGET2)
    return 0;
d9465 3
a9467 1
  return 1;
d9470 2
a9471 2
const char *
elf32_arm_target_format (void)
d9473 1
a9473 14
#ifdef TE_SYMBIAN
  return (target_big_endian
	  ? "elf32-bigarm-symbian"
	  : "elf32-littlearm-symbian");
#elif defined (TE_VXWORKS)
  return (target_big_endian
	  ? "elf32-bigarm-vxworks"
	  : "elf32-littlearm-vxworks");
#else
  if (target_big_endian)
    return "elf32-bigarm";
  else
    return "elf32-littlearm";
#endif
d9476 2
a9477 3
void
armelf_frob_symbol (symbolS * symp,
		    int *     puntp)
d9479 1
a9479 1
  elf_frob_symbol (symp, puntp);
a9480 1
#endif
d9482 5
a9486 1
/* MD interface: Finalization.	*/
d9488 5
a9492 3
/* A good place to do this, although this was probably not intended
   for this kind of use.  We need to dump the literal pool before
   references are made to a null symbol pointer.  */
d9494 2
a9495 2
void
arm_cleanup (void)
d9497 7
a9503 1
  literal_pool * pool;
d9505 10
a9514 1
  for (pool = list_of_pools; pool; pool = pool->next)
d9516 2
a9517 6
      /* Put it at the end of the relevent section.  */
      subseg_set (pool->section, pool->sub_section);
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
      s_ltorg (0);
a9518 1
}
d9520 1
a9520 10
/* Adjust the symbol table.  This marks Thumb symbols as distinct from
   ARM ones.  */

void
arm_adjust_symtab (void)
{
#ifdef OBJ_COFF
  symbolS * sym;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
d9522 7
a9528 1
      if (ARM_IS_THUMB (sym))
d9530 2
a9531 28
	  if (THUMB_IS_FUNC (sym))
	    {
	      /* Mark the symbol as a Thumb function.  */
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!	 */
		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);

	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
	      else
		as_bad (_("%s: unexpected function type: %d"),
			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
	    }
	  else switch (S_GET_STORAGE_CLASS (sym))
	    {
	    case C_EXT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
	      break;
	    case C_STAT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
	      break;
	    case C_LABEL:
	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
	      break;
	    default:
	      /* Do nothing.  */
	      break;
	    }
d9534 2
a9535 7
      if (ARM_IS_INTERWORK (sym))
	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
    }
#endif
#ifdef OBJ_ELF
  symbolS * sym;
  char	    bind;
d9537 1
a9537 3
  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
d9539 5
a9543 1
	  elf_symbol_type * elf_sym;
d9545 3
a9547 2
	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	  bind = ELF_ST_BIND (elf_sym->internal_elf_sym.st_info);
d9549 2
a9550 14
	  if (! bfd_is_arm_mapping_symbol_name (elf_sym->symbol.name))
	    {
	      /* If it's a .thumb_func, declare it as so,
		 otherwise tag label as .code 16.  */
	      if (THUMB_IS_FUNC (sym))
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_TFUNC);
	      else
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_16BIT);
	    }
	}
    }
#endif
d9553 5
a9557 1
/* MD interface: Initialization.  */
d9560 1
a9560 1
set_constant_flonums (void)
d9562 2
a9563 1
  int i;
d9565 8
a9572 3
  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
d9575 2
a9576 2
void
md_begin (void)
d9578 6
a9583 2
  unsigned mach;
  unsigned int i;
d9585 1
a9585 7
  if (	 (arm_ops_hsh = hash_new ()) == NULL
      || (arm_cond_hsh = hash_new ()) == NULL
      || (arm_shift_hsh = hash_new ()) == NULL
      || (arm_psr_hsh = hash_new ()) == NULL
      || (arm_reg_hsh = hash_new ()) == NULL
      || (arm_reloc_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));
d9587 6
a9592 14
  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    hash_insert (arm_ops_hsh, insns[i].template, (PTR) (insns + i));
  for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
    hash_insert (arm_cond_hsh, conds[i].template, (PTR) (conds + i));
  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
    hash_insert (arm_shift_hsh, shift_names[i].name, (PTR) (shift_names + i));
  for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
    hash_insert (arm_psr_hsh, psrs[i].template, (PTR) (psrs + i));
  for (i = 0; i < sizeof (reg_names) / sizeof (struct reg_entry); i++)
    hash_insert (arm_reg_hsh, reg_names[i].name, (PTR) (reg_names + i));
#ifdef OBJ_ELF
  for (i = 0; i < sizeof (reloc_names) / sizeof (struct reloc_entry); i++)
    hash_insert (arm_reloc_hsh, reloc_names[i].name, (PTR) (reloc_names + i));
#endif
d9594 2
a9595 1
  set_constant_flonums ();
d9597 2
a9598 8
  /* Set the cpu variant based on the command-line options.  We prefer
     -mcpu= over -march= if both are set (as for GCC); and we prefer
     -mfpu= over any other way of setting the floating point unit.
     Use of legacy options with new options are faulted.  */
  if (legacy_cpu != -1)
    {
      if (mcpu_cpu_opt != -1 || march_cpu_opt != -1)
	as_bad (_("use of old and new-style options to set CPU type"));
d9600 5
a9604 4
      mcpu_cpu_opt = legacy_cpu;
    }
  else if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = march_cpu_opt;
d9606 2
a9607 4
  if (legacy_fpu != -1)
    {
      if (mfpu_opt != -1)
	as_bad (_("use of old and new-style options to set FPU type"));
d9609 1
a9609 15
      mfpu_opt = legacy_fpu;
    }
  else if (mfpu_opt == -1)
    {
#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined (TE_VXWORKS))
      /* Some environments specify a default FPU.  If they don't, infer it
	 from the processor.  */
      if (mcpu_fpu_opt != -1)
	mfpu_opt = mcpu_fpu_opt;
      else
	mfpu_opt = march_fpu_opt;
#else
      mfpu_opt = FPU_DEFAULT;
#endif
    }
d9611 1
a9611 1
  if (mfpu_opt == -1)
d9613 2
a9614 6
      if (mcpu_cpu_opt == -1)
	mfpu_opt = FPU_DEFAULT;
      else if (mcpu_cpu_opt & ARM_EXT_V5)
	mfpu_opt = FPU_ARCH_VFP_V2;
      else
	mfpu_opt = FPU_ARCH_FPA;
d9617 1
a9617 2
  if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = CPU_DEFAULT;
d9619 2
a9620 1
  cpu_variant = mcpu_cpu_opt | mfpu_opt;
d9622 5
a9626 3
#if defined OBJ_COFF || defined OBJ_ELF
  {
    unsigned int flags = 0;
d9628 3
a9630 2
#if defined OBJ_ELF
    flags = meabi_flags;
d9632 11
a9642 12
    switch (meabi_flags)
      {
      case EF_ARM_EABI_UNKNOWN:
#endif
	/* Set the flags in the private structure.  */
	if (uses_apcs_26)      flags |= F_APCS26;
	if (support_interwork) flags |= F_INTERWORK;
	if (uses_apcs_float)   flags |= F_APCS_FLOAT;
	if (pic_code)	       flags |= F_PIC;
	if ((cpu_variant & FPU_ANY) == FPU_NONE
	     || (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
	  flags |= F_SOFT_FLOAT;
d9644 4
a9647 6
	switch (mfloat_abi_opt)
	  {
	  case ARM_FLOAT_ABI_SOFT:
	  case ARM_FLOAT_ABI_SOFTFP:
	    flags |= F_SOFT_FLOAT;
	    break;
d9649 1
a9649 5
	  case ARM_FLOAT_ABI_HARD:
	    if (flags & F_SOFT_FLOAT)
	      as_bad (_("hard-float conflicts with specified fpu"));
	    break;
	  }
d9651 2
a9652 3
	/* Using VFP conventions (even if soft-float).	*/
	if (cpu_variant & FPU_VFP_EXT_NONE)
	  flags |= F_VFP_FLOAT;
d9654 2
a9655 4
#if defined OBJ_ELF
	if (cpu_variant & FPU_ARCH_MAVERICK)
	    flags |= EF_ARM_MAVERICK_FLOAT;
	break;
d9657 3
a9659 3
      case EF_ARM_EABI_VER4:
	/* No additional flags to set.	*/
	break;
d9661 2
a9662 5
      default:
	abort ();
      }
#endif
    bfd_set_private_flags (stdoutput, flags);
d9664 5
a9668 6
    /* We have run out flags in the COFF header to encode the
       status of ATPCS support, so instead we create a dummy,
       empty, debug section called .arm.atpcs.	*/
    if (atpcs)
      {
	asection * sec;
d9670 5
a9674 1
	sec = bfd_make_section (stdoutput, ".arm.atpcs");
d9676 60
a9735 10
	if (sec != NULL)
	  {
	    bfd_set_section_flags
	      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);
	    bfd_set_section_size (stdoutput, sec, 0);
	    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);
	  }
      }
  }
#endif
d9737 7
a9743 2
  /* Record the CPU type as well.  */
  switch (cpu_variant & ARM_CPU_MASK)
d9745 26
a9770 3
    case ARM_2:
      mach = bfd_mach_arm_2;
      break;
d9772 4
a9775 3
    case ARM_3:			/* Also ARM_250.  */
      mach = bfd_mach_arm_2a;
      break;
d9777 1
a9777 3
    case ARM_6:			/* Also ARM_7.	*/
      mach = bfd_mach_arm_3;
      break;
d9779 5
a9783 3
    default:
      mach = bfd_mach_arm_unknown;
      break;
d9786 1
a9786 10
  /* Catch special cases.  */
  if (cpu_variant & ARM_CEXT_IWMMXT)
    mach = bfd_mach_arm_iWMMXt;
  else if (cpu_variant & ARM_CEXT_XSCALE)
    mach = bfd_mach_arm_XScale;
  else if (cpu_variant & ARM_CEXT_MAVERICK)
    mach = bfd_mach_arm_ep9312;
  else if (cpu_variant & ARM_EXT_V5E)
    mach = bfd_mach_arm_5TE;
  else if (cpu_variant & ARM_EXT_V5)
d9788 4
a9791 4
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_5T;
      else
	mach = bfd_mach_arm_5;
d9793 2
a9794 1
  else if (cpu_variant & ARM_EXT_V4)
d9796 8
a9803 2
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_4T;
d9805 4
a9808 1
	mach = bfd_mach_arm_4;
a9809 2
  else if (cpu_variant & ARM_EXT_V3M)
    mach = bfd_mach_arm_3M;
d9811 14
a9824 1
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
d9827 5
a9831 1
/* Command line processing.  */
d9833 5
a9837 3
/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.
d9839 4
a9842 4
      This routine is somewhat complicated by the need for backwards
      compatibility (since older releases of gcc can't be changed).
      The new options try to make the interface as compatible as
      possible with GCC.
d9844 2
a9845 1
      New options (supported) are:
d9847 3
a9849 8
	      -mcpu=<cpu name>		 Assemble for selected processor
	      -march=<architecture name> Assemble for selected architecture
	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
	      -EB/-mbig-endian		 Big-endian
	      -EL/-mlittle-endian	 Little-endian
	      -k			 Generate PIC code
	      -mthumb			 Start in Thumb mode
	      -mthumb-interwork		 Code supports ARM/Thumb interworking
d9851 4
a9854 1
      For now we will also provide support for:
d9856 3
a9858 7
	      -mapcs-32			 32-bit Program counter
	      -mapcs-26			 26-bit Program counter
	      -macps-float		 Floats passed in FP registers
	      -mapcs-reentrant		 Reentrant code
	      -matpcs
      (sometime these will probably be replaced with -mapcs=<list of options>
      and -matpcs=<list of options>)
d9860 10
a9869 19
      The remaining options are only supported for back-wards compatibility.
      Cpu variants, the arm part is optional:
	      -m[arm]1		      Currently not supported.
	      -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
	      -m[arm]3		      Arm 3 processor
	      -m[arm]6[xx],	      Arm 6 processors
	      -m[arm]7[xx][t][[d]m]   Arm 7 processors
	      -m[arm]8[10]	      Arm 8 processors
	      -m[arm]9[20][tdmi]      Arm 9 processors
	      -mstrongarm[110[0]]     StrongARM processors
	      -mxscale		      XScale processors
	      -m[arm]v[2345[t[e]]]    Arm architectures
	      -mall		      All (except the ARM1)
      FP variants:
	      -mfpa10, -mfpa11	      FPA10 and 11 co-processor instructions
	      -mfpe-old		      (No float load/store multiples)
	      -mvfpxd		      VFP Single precision
	      -mvfp		      All VFP
	      -mno-fpu		      Disable all floating point instructions
d9871 4
a9874 8
      The following CPU names are recognized:
	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.
d9876 2
a9877 1
      */
d9879 8
a9886 1
const char * md_shortopts = "m:k";
d9888 2
a9889 9
#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#define OPTION_EL (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#else
#define OPTION_EL (OPTION_MD_BASE + 1)
#endif
d9892 13
a9904 1
struct option md_longopts[] =
d9906 4
a9909 8
#ifdef OPTION_EB
  {"EB", no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL", no_argument, NULL, OPTION_EL},
#endif
  {NULL, no_argument, NULL, 0}
};
d9911 3
a9913 1
size_t md_longopts_size = sizeof (md_longopts);
d9915 4
a9918 1
struct arm_option_table
d9920 26
a9945 6
  char *option;		/* Option name to match.  */
  char *help;		/* Help information.  */
  int  *var;		/* Variable to change.	*/
  int	value;		/* What to change it to.  */
  char *deprecated;	/* If non-null, print this message.  */
};
d9947 2
a9948 1
struct arm_option_table arm_opts[] =
d9950 21
a9970 13
  {"k",	     N_("generate PIC code"),	   &pic_code,	 1, NULL},
  {"mthumb", N_("assemble Thumb code"),	   &thumb_mode,	 1, NULL},
  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
   &support_interwork, 1, NULL},
  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
   1, NULL},
  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 1,
   NULL},
d9972 3
a9974 3
  /* These are recognized by the assembler, but have no affect on code.	 */
  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},
d9976 36
a10011 80
  /* DON'T add any new processors to this list -- we want the whole list
     to go away...  Add them to the processors table instead.  */
  {"marm1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm110")},
  {"mstrongarm1100", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1100")},
  {"mstrongarm1110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1110")},
  {"mxscale",	 NULL, &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 NULL, &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 NULL, &legacy_cpu, ARM_ANY,	  N_("use -mcpu=all")},
d10013 4
a10016 19
  /* Architecture variants -- don't add any more to this list either.  */
  {"mv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
d10018 3
a10020 6
  /* Floating point variants -- don't add any more to this list either.	 */
  {"mfpe-old", NULL, &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  NULL, &legacy_fpu, 0,
   N_("use either -mfpu=softfpa or -mfpu=softvfp")},
d10022 3
a10024 2
  {NULL, NULL, NULL, 0, NULL}
};
d10026 2
a10027 1
struct arm_cpu_option_table
d10029 6
a10034 6
  char *name;
  int	value;
  /* For some CPUs we assume an FPU unless the user explicitly sets
     -mfpu=...	*/
  int	default_fpu;
};
d10036 2
a10037 3
/* This list should, at a minimum, contain all the cpu names
   recognized by GCC.  */
static struct arm_cpu_option_table arm_cpus[] =
d10039 1120
a11158 78
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi-s",	ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm810",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm922t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm940t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm9tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  /* For V5 or later processors we default to using VFP; but the user
     should really set the FPU type explicitly.	 */
  {"arm9e-r0",		ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm9e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm926ej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ejs",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm946e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm966e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm10t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm10e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm1020e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1026ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1026ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1136js",		ARM_ARCH_V6,	 FPU_NONE},
  {"arm1136j-s",	ARM_ARCH_V6,	 FPU_NONE},
  {"arm1136jfs",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2},
  {"mpcore",		ARM_ARCH_V6K,	 FPU_ARCH_VFP_V2},
  {"mpcorenovfp",	ARM_ARCH_V6K,	 FPU_NONE},
  {"arm1176jz-s",	ARM_ARCH_V6ZK,	 FPU_NONE},
  {"arm1176jzf-s",	ARM_ARCH_V6ZK,	 FPU_ARCH_VFP_V2},
  /* ??? XSCALE is really an architecture.  */
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* ??? iwmmxt is not a processor.  */
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2},
  {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* Maverick */
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_ARCH_MAVERICK},
  {NULL, 0, 0}
d11161 4
a11164 1
struct arm_arch_option_table
d11166 9
a11174 4
  char *name;
  int	value;
  int	default_fpu;
};
d11176 3727
a14902 3
/* This list should, at a minimum, contain all the architecture names
   recognized by GCC.  */
static struct arm_arch_option_table arm_archs[] =
d14904 11
a14914 30
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"armv1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"armv2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"armv2a",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv2s",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv3",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"armv3m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"armv4",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"armv4xm",		ARM_ARCH_V4xM,	 FPU_ARCH_FPA},
  {"armv4t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"armv4txm",		ARM_ARCH_V4TxM,	 FPU_ARCH_FPA},
  {"armv5",		ARM_ARCH_V5,	 FPU_ARCH_VFP},
  {"armv5t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP},
  {"armv5txm",		ARM_ARCH_V5TxM,	 FPU_ARCH_VFP},
  {"armv5te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP},
  {"armv5texp",		ARM_ARCH_V5TExP, FPU_ARCH_VFP},
  {"armv5tej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP},
  {"armv6",		ARM_ARCH_V6,	 FPU_ARCH_VFP},
  {"armv6j",		ARM_ARCH_V6,	 FPU_ARCH_VFP},
  {"armv6k",		ARM_ARCH_V6K,	 FPU_ARCH_VFP},
  {"armv6z",		ARM_ARCH_V6Z,	 FPU_ARCH_VFP},
  {"armv6zk",		ARM_ARCH_V6ZK,	 FPU_ARCH_VFP},
  {"armv6t2",		ARM_ARCH_V6T2,	 FPU_ARCH_VFP},
  {"armv6kt2",		ARM_ARCH_V6KT2,	 FPU_ARCH_VFP},
  {"armv6zt2",		ARM_ARCH_V6ZT2,	 FPU_ARCH_VFP},
  {"armv6zkt2",		ARM_ARCH_V6ZKT2, FPU_ARCH_VFP},
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
  {NULL, 0, 0}
};
d14916 6
a14921 6
/* ISA extensions in the co-processor space.  */
struct arm_option_value_table
{
  char *name;
  int value;
};
d14923 2
a14924 7
static struct arm_option_value_table arm_extensions[] =
{
  {"maverick",		ARM_CEXT_MAVERICK},
  {"xscale",		ARM_CEXT_XSCALE},
  {"iwmmxt",		ARM_CEXT_IWMMXT},
  {NULL,		0}
};
d14926 3
a14928 26
/* This list should, at a minimum, contain all the fpu names
   recognized by GCC.  */
static struct arm_option_value_table arm_fpus[] =
{
  {"softfpa",		FPU_NONE},
  {"fpe",		FPU_ARCH_FPE},
  {"fpe2",		FPU_ARCH_FPE},
  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
  {"fpa",		FPU_ARCH_FPA},
  {"fpa10",		FPU_ARCH_FPA},
  {"fpa11",		FPU_ARCH_FPA},
  {"arm7500fe",		FPU_ARCH_FPA},
  {"softvfp",		FPU_ARCH_VFP},
  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
  {"vfp",		FPU_ARCH_VFP_V2},
  {"vfp9",		FPU_ARCH_VFP_V2},
  {"vfp10",		FPU_ARCH_VFP_V2},
  {"vfp10-r0",		FPU_ARCH_VFP_V1},
  {"vfpxd",		FPU_ARCH_VFP_V1xD},
  {"arm1020t",		FPU_ARCH_VFP_V1},
  {"arm1020e",		FPU_ARCH_VFP_V2},
  {"arm1136jfs",	FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	FPU_ARCH_VFP_V2},
  {"maverick",		FPU_ARCH_MAVERICK},
  {NULL, 0}
};
d14930 6
a14935 7
static struct arm_option_value_table arm_float_abis[] =
{
  {"hard",	ARM_FLOAT_ABI_HARD},
  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
  {"soft",	ARM_FLOAT_ABI_SOFT},
  {NULL, 0}
};
a14936 9
#ifdef OBJ_ELF
/* We only know how to output GNU and ver 4 (AAELF) formats.  */
static struct arm_option_value_table arm_eabis[] =
{
  {"gnu",	EF_ARM_EABI_UNKNOWN},
  {"4",		EF_ARM_EABI_VER4},
  {NULL, 0}
};
#endif
d14938 1
a14938 7
struct arm_long_option_table
{
  char * option;		/* Substring to match.	*/
  char * help;			/* Help information.  */
  int (* func) (char * subopt);	/* Function to decode sub-option.  */
  char * deprecated;		/* If non-null, print this message.  */
};
d14941 1
a14941 1
arm_parse_extension (char * str, int * opt_p)
d14943 4
a14946 1
  while (str != NULL && *str != 0)
d14948 5
a14952 3
      struct arm_option_value_table * opt;
      char * ext;
      int optlen;
d14954 9
a14962 5
      if (*str != '+')
	{
	  as_bad (_("invalid architectural extension"));
	  return 0;
	}
d14964 1
a14964 2
      str++;
      ext = strchr (str, '+');
d14966 4
a14969 4
      if (ext != NULL)
	optlen = ext - str;
      else
	optlen = strlen (str);
d14971 2
a14972 5
      if (optlen == 0)
	{
	  as_bad (_("missing architectural extension"));
	  return 0;
	}
d14974 6
a14979 6
      for (opt = arm_extensions; opt->name != NULL; opt++)
	if (strncmp (opt->name, str, optlen) == 0)
	  {
	    *opt_p |= opt->value;
	    break;
	  }
d14981 3
a14983 5
      if (opt->name == NULL)
	{
	  as_bad (_("unknown architectural extnsion `%s'"), str);
	  return 0;
	}
d14985 2
a14986 2
      str = ext;
    };
d14988 1
a14988 2
  return 1;
}
d14990 2
a14991 2
static int
arm_parse_cpu (char * str)
d14993 3
a14995 3
  struct arm_cpu_option_table * opt;
  char * ext = strchr (str, '+');
  int optlen;
d14997 3
a14999 2
  if (ext != NULL)
    optlen = ext - str;
d15001 1
a15001 1
    optlen = strlen (str);
d15003 1
a15003 1
  if (optlen == 0)
d15005 3
a15007 2
      as_bad (_("missing cpu name `%s'"), str);
      return 0;
d15010 8
a15017 5
  for (opt = arm_cpus; opt->name != NULL; opt++)
    if (strncmp (opt->name, str, optlen) == 0)
      {
	mcpu_cpu_opt = opt->value;
	mcpu_fpu_opt = opt->default_fpu;
d15019 1
a15019 2
	if (ext != NULL)
	  return arm_parse_extension (ext, &mcpu_cpu_opt);
d15021 6
a15026 2
	return 1;
      }
d15028 7
a15034 2
  as_bad (_("unknown cpu `%s'"), str);
  return 0;
d15037 4
a15040 2
static int
arm_parse_arch (char * str)
d15042 4
a15045 3
  struct arm_arch_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;
d15047 8
a15054 2
  if (ext != NULL)
    optlen = ext - str;
d15056 1
a15056 1
    optlen = strlen (str);
d15058 1
a15058 1
  if (optlen == 0)
d15060 3
a15062 2
      as_bad (_("missing architecture name `%s'"), str);
      return 0;
d15065 21
d15087 2
a15088 5
  for (opt = arm_archs; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	march_cpu_opt = opt->value;
	march_fpu_opt = opt->default_fpu;
d15090 3
a15092 2
	if (ext != NULL)
	  return arm_parse_extension (ext, &march_cpu_opt);
d15094 1
a15094 5
	return 1;
      }

  as_bad (_("unknown architecture `%s'\n"), str);
  return 0;
d15097 1
a15097 4
static int
arm_parse_fpu (char * str)
{
  struct arm_option_value_table * opt;
d15099 2
a15100 6
  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfpu_opt = opt->value;
	return 1;
      }
d15102 2
a15103 6
  as_bad (_("unknown floating point format `%s'\n"), str);
  return 0;
}

static int
arm_parse_float_abi (char * str)
d15105 4
a15108 1
  struct arm_option_value_table * opt;
d15110 3
a15112 6
  for (opt = arm_float_abis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfloat_abi_opt = opt->value;
	return 1;
      }
d15114 2
a15115 3
  as_bad (_("unknown floating point abi `%s'\n"), str);
  return 0;
}
d15117 3
a15119 5
#ifdef OBJ_ELF
static int
arm_parse_eabi (char * str)
{
  struct arm_option_value_table *opt;
d15121 2
a15122 10
  for (opt = arm_eabis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	meabi_flags = opt->value;
	return 1;
      }
  as_bad (_("unknown EABI `%s'\n"), str);
  return 0;
}
#endif
d15124 16
a15139 16
struct arm_long_option_table arm_long_opts[] =
{
  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
   arm_parse_cpu, NULL},
  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
   arm_parse_arch, NULL},
  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
   arm_parse_fpu, NULL},
  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
   arm_parse_float_abi, NULL},
#ifdef OBJ_ELF
  {"meabi=", N_("<ver>\t  assemble for eabi version <ver>"),
   arm_parse_eabi, NULL},
#endif
  {NULL, NULL, 0, NULL}
};
d15141 7
a15147 5
int
md_parse_option (int c, char * arg)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;
d15149 1
a15149 1
  switch (c)
d15151 5
a15155 5
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif
d15157 3
a15159 5
#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif
d15161 2
a15162 4
    case 'a':
      /* Listing option.  Just ignore these, we don't support additional
	 ones.	*/
      return 0;
d15164 4
a15167 13
    default:
      for (opt = arm_opts; opt->option != NULL; opt++)
	{
	  if (c == opt->option[0]
	      && ((arg == NULL && opt->option[1] == 0)
		  || streq (arg, opt->option + 1)))
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (opt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(opt->deprecated));
#endif
d15169 4
a15172 2
	      if (opt->var != NULL)
		*opt->var = opt->value;
d15174 9
a15182 3
	      return 1;
	    }
	}
d15184 1
a15184 14
      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
	{
	  /* These options are expected to have an argument.  */
	  if (c == lopt->option[0]
	      && arg != NULL
	      && strncmp (arg, lopt->option + 1,
			  strlen (lopt->option + 1)) == 0)
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (lopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
			   _(lopt->deprecated));
#endif
d15186 6
a15191 4
	      /* Call the sup-option parser.  */
	      return lopt->func (arg + strlen (lopt->option) - 1);
	    }
	}
d15193 1
a15193 2
      return 0;
    }
d15195 1
a15195 2
  return 1;
}
d15197 2
a15198 2
void
md_show_usage (FILE * fp)
d15200 1
a15200 2
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;
d15202 3
a15204 1
  fprintf (fp, _(" ARM-specific assembler options:\n"));
d15206 2
a15207 3
  for (opt = arm_opts; opt->option != NULL; opt++)
    if (opt->help != NULL)
      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));
d15209 1
a15209 3
  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
    if (lopt->help != NULL)
      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));
d15211 5
a15215 3
#ifdef OPTION_EB
  fprintf (fp, _("\
  -EB                     assemble code for a big-endian cpu\n"));
d15218 39
a15256 3
#ifdef OPTION_EL
  fprintf (fp, _("\
  -EL                     assemble code for a little-endian cpu\n"));
d15258 5
a15262 1
}
@


1.193.4.6
log
@	* gas/sb.c: Include as.h.
	(sb_to_scrub, scrub_position, scrub_from_sb): New statics.
	(sb_scrub_and_add_sb): New interface.
	* gas/sb.h: Declare sb_scrub_and_add_sb.
	* gas/input-scrub.c (input_scrub_include_sb): Use it.

	* gas/config/tc-arm.c (do_t_arit3c): Correct typo in expression.
	(do_t_mul): Allow dest to equal either source1 or source2 in
	16-bit form; do not complain about dest == source1 in any
	case.

	* gas/testsuite/gas/arm/tcompat2.s: Test both dest==source1 and
	dest==source2 for commutative arithmetic instructions.
	* gas/testsuite/gas/arm/tcompat2.d: Update to match.
	* gas/testsuite/gas/arm/t16-bad.l: Adjust expected diagnostic.
	* gas/testsuite/gas/arm/macro1.s, gas/arm/macro1.d: New test pair.
	* gas/testsuite/gas/arm/arm.exp: Run it.
@
text
@d6028 1
a6028 1
	inst.instruction |= Rs << 3;
d6738 5
a6742 2
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);
d6746 1
a6746 7

      if (inst.operands[0].reg == inst.operands[1].reg)
	inst.instruction |= inst.operands[2].reg << 3;
      else if (inst.operands[0].reg == inst.operands[2].reg)
	inst.instruction |= inst.operands[1].reg << 3;
      else
	constraint (1, _("dest must overlap one source register"));
@


1.193.4.7
log
@2005-05-01  Zack Weinberg  <zack@@codesourcery.com>

	* gas/config/tc-arm.c (encode_thumb32_addr_mode): Set inst.reloc.pc_rel
	if is_pc.
	(T16_32_TAB): Delete unused entry for BLX.
	(do_t_ldst): Don't offset inst.reloc.exp.X_add_number for PC-relative
	addressing.
	(md_pcrel_from): Report the adjusted PC for
	BFD_RELOC_ARM_THUMB_OFFSET and BFD_RELOC_ARM_T32_OFFSET_IMM.
	(md_apply_fix3): Correct bitmasks for BFD_RELOC_ARM_T32_OFFSET_IMM.
	Do not round up value for PC-relative BFD_RELOC_ARM_THUMB_OFFSET.

	* gas/testsuite/gas/arm/thumb.s: Test PC-relative ldr more thoroughly.
	* gas/testsuite/gas/arm/thumb.d: Update to match.

	* gas/testsuite/gas/arm/thumb32.s: Properly align labels that
	will be targeted by blx instructions.
	* gas/testsuite/gas/arm/thumb32.d: Update to match.  Correct
	expected dissassembly of PC-relative ldr.

	* gas/testsuite/gas/arm/macro1.s: Add leading label and
	trailing padding for a.out compatibility.
	* gas/testsuite/gas/arm/macro1.d: Update to match.
	* gas/testsuite/gas/arm/tcompat2.s: Add trailing padding for a.out
	compatibility.
	* gas/testsuite/gas/arm/tcompat2.d: Update to match.

	* opcodes/arm-dis.c (print_insn_thumb32): Reorganize %a and %A
	handling.  Call info->print_address_func when %a/%A are applied
	to a PC-relative instruction.
@
text
@a5641 1
      inst.reloc.pc_rel = is_pc;
d5675 1
d6457 2
d9667 1
a9667 5
  /* PC relative addressing on the Thumb is slightly odd as the bottom
     two bits of the PC are forced to zero for the calculation.  This
     happens *after* application of the pipeline offset.  However,
     Thumb adrl already adjusts for this, so we need not do it again.  */
  switch (fixP->fx_r_type)
d9669 3
a9671 1
    case BFD_RELOC_ARM_THUMB_ADD:
a9672 7

    case BFD_RELOC_ARM_THUMB_OFFSET:
    case BFD_RELOC_ARM_T32_OFFSET_IMM:
      return (fixP->fx_where + fixP->fx_frag->fr_address + 4) & ~3;

    default:
      break;
d9869 1
a9869 1
     so we have to undo its effects here.  */
d10076 1
a10076 1
      else if ((newval & 0x000f0000) == 0x000f0000)
d10683 5
a10687 2
	     forced to zero for these loads; md_pcrel_from has already
	     compensated for this.  */
d10694 1
a10694 1
	  if (value & ~0x3fc)
d10699 2
a10700 1
	  newval |= value >> 2;
@


1.193.4.8
log
@2005-05-01  Zack Weinberg  <zack@@codesourcery.com>

	* gas/config/tc-arm.c (thumb32_mode): Rename unified_syntax.
	All uses changed to match.
	(COND_ALWAYS): Don't offset.
	(COND_MASK): Delete.
	(struct arm_it): Add cond field.
	(struct asm_opcode): Add tag field.  Change some fields to
	unsigned int and/or to bitfields.
	(my_get_expression): If unified_syntax, always treat the
	prefix as optional.
	(s_thumb32, s_thumb32_func): Delete.
	(opcode_select, s_force_thumb): Don't set thumb32_mode.
	(s_syntax): New function.
	(md_pseudo_table): Update to match.
	(do_blx, do_iwmmxt_wldstw): Look at inst.cond, not
	inst.instruction, for the condition.
	(do_it): New function.
	(do_t_branch): Get the condition from inst.cond and patch it
	into the appropriate place.
	(output_inst): If inst.size == 0, output nothing, but do issue
	a diagnostic if any.
	(enum opcode_tag): New set of constants.
	(opcode_lookup): New function.
	(md_assemble): Use opcode_lookup.  Restructure a little.
	(conds, OPS0): Adjust comment.
	(TxCE, TxCM, TUE, TUF): Rewrite.
	(TCC): Delete.
	(TxC3, TC3, tC3, TxCM_, C3, C3E): New notational macros.

	(insns): Use TC3, tC3, or C3, as appropriate, for all
	instructions where the conditional infix appears after the
	third letter of the mnemonic.  Use TCE for 'b'.  Use C3E for
	'cmfe' and 'cnfe'.  Change 'czbne' to 'cbnz', 'czbeq' to 'cbz'.
	Use TUE, with a dummy ARM opcode, for all variants of 'it'.

	* opcodes/arm-dis.c: Change 'czbne' to 'cbnz', 'czbeq' to 'cbz'.

	* gas/testsuite/gas/arm/thumb.d: bal.n is no longer
	distinguishable from b.n.
	* gas/testsuite/gas/arm/thumb32.d: Likewise.  Change 'czbne'
	to 'cbnz', 'czbeq' to 'cbz'.
	* gas/testsuite/gas/arm/thumb32.s: Use .syntax unified.
	Change 'czbne' to 'cbnz', 'czbeq' to 'cbz'.
@
text
@d187 5
a191 2
/* If unified_syntax is true, we are processing the new unified
   ARM/Thumb syntax.  Important differences from the old ARM mode:
d193 1
a193 21
     - Immediate operands do not require a # prefix.
     - Conditional affixes always appear at the end of the
       instruction.  (For backward compatibility, those instructions
       that formerly had them in the middle, continue to accept them
       there.)
     - The IT instruction may appear, and if it does is validated
       against subsequent conditional affixes.  It does not generate
       machine code.

   Important differences from the old Thumb mode:

     - Immediate operands do not require a # prefix.
     - Most of the V6T2 instructions are only available in unified mode.
     - The .N and .W suffixes are recognized and honored (it is an error
       if they cannot be honored).
     - All instructions set the flags if and only if they have an 's' affix.
     - Conditional affixes may be used.  They are validated against
       preceding IT instructions.  Unlike ARM mode, you cannot use a
       conditional affix except in the scope of an IT instruction.  */

static bfd_boolean unified_syntax = FALSE;
a200 1
  int		cond;
d261 2
a262 1
#define COND_ALWAYS 0xE
a365 3
  /* Conditional tag - see opcode_lookup.  */
  unsigned int tag : 4;

d367 1
a367 1
  unsigned int avalue : 28;
d370 1
a370 1
  unsigned int tvalue;
a599 4
  /* In unified syntax, all prefixes are optional.  */
  if (unified_syntax)
    prefix_mode = GE_OPT_PREFIX;

d1427 1
d1471 10
d1509 2
d1527 10
a1626 26
/* Directives: Mode selection.  */

/* .syntax [unified|divided] - choose the new unified syntax
   (same for Arm and Thumb encoding, modulo slight differences in what
   can be represented) or the old divergent syntax for each mode.  */
static void
s_syntax (int unused ATTRIBUTE_UNUSED)
{
  char *name, delim;

  name = input_line_pointer;
  delim = get_symbol_end ();

  if (!strcasecmp (name, "unified"))
    unified_syntax = TRUE;
  else if (!strcasecmp (name, "divided"))
    unified_syntax = FALSE;
  else
    {
      as_bad (_("unrecognized syntax mode \"%s\""), name);
      return;
    }
  *input_line_pointer = delim;
  demand_empty_rest_of_line ();
}

d2773 1
d2777 1
a2781 1
  { "syntax",	   s_syntax,	  0 },
d4450 1
a4450 1
      constraint (inst.cond != COND_ALWAYS, BAD_COND);
a4547 8
do_it (void)
{
  /* There is no IT instruction in ARM mode.  We
     process it but do not generate code for it.  */
  inst.size = 0;
}

static void
d5425 1
a5425 1
      constraint (inst.cond != COND_ALWAYS, BAD_COND);
d5763 1
a5763 1
  if (unified_syntax)
d5895 1
a5895 1
  if (unified_syntax)
d5966 1
a5966 1
  if (unified_syntax)
d6108 1
a6108 1
  if (unified_syntax && inst.size_req != 2)
d6110 1
a6110 1
      if (inst.cond == COND_ALWAYS)
d6117 4
a6120 2
	  assert (inst.cond != 0xF);
	  inst.instruction = (inst.cond << 22) | 0xf43faffe;
d6125 3
a6127 9
    {
      if (inst.cond == COND_ALWAYS)
	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
      else
	{
	  inst.instruction = 0xd0fe | (inst.cond << 8);
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
	}
    }
d6190 1
a6190 1
  if (unified_syntax
d6240 1
a6240 1
  if (unified_syntax && inst.size_req == 4)
d6279 1
a6279 1
  if (unified_syntax)
d6395 1
a6395 1
  if (unified_syntax)
d6537 1
a6537 1
  if (unified_syntax)
d6642 1
a6642 1
  if (unified_syntax)
d6725 1
a6725 1
  if (unified_syntax && inst.instruction == T_MNEM_mul)
d6734 1
a6734 1
      constraint (!unified_syntax
d6766 1
a6766 1
  if (unified_syntax)
d6790 1
a6790 1
  if (unified_syntax)
d6868 1
a6868 1
  else if (unified_syntax)
d6912 1
a6912 1
  else if (unified_syntax)
d6957 1
a6957 1
  if (unified_syntax)
d7173 1
a7173 1
  else if (unified_syntax)
a7274 2
  if (inst.size == 0)
    return;
a7302 198
/* Tag values used in struct asm_opcode's tag field.  */
enum opcode_tag
{
  OT_unconditional,	/* Instruction cannot be conditionalized.
			   The ARM condition field is still 0xE.  */
  OT_unconditionalF,	/* Instruction cannot be conditionalized
			   and carries 0xF in its ARM condition field.  */
  OT_csuffix,		/* Instruction takes a conditional suffix.  */
  OT_cinfix3,		/* Instruction takes a conditional infix,
			   beginning at character index 3.  (In
			   unified mode, it becomes a suffix.)  */
  OT_csuf_or_in3,	/* Instruction takes either a conditional
			   suffix or an infix at character index 3.
			   (In unified mode, a suffix only.  */
  OT_odd_infix_unc,	/* This is the unconditional variant of an
			   instruction that takes a conditional infix
			   at an unusual position.  In unified mode,
			   this variant will accept a suffix.  */
  OT_odd_infix_0	/* Values greater than or equal to OT_odd_infix_0
			   are the conditional variants of instructions that
			   take conditional infixes in unusual positions.
			   The infix appears at character index
			   (tag - OT_odd_infix_0).  These are not accepted
			   in unified mode.  */
};

/* Subroutine of md_assemble, responsible for looking up the primary
   opcode from the mnemonic the user wrote.  STR points to the
   beginning of the mnemonic.

   This is not simply a hash table lookup, because of conditional
   variants.  Most instructions have conditional variants, which are
   expressed with a _conditional affix_ to the mnemonic.  If we were
   to encode each conditional variant as a literal string in the opcode
   table, it would have approximately 20,000 entries.

   Most mnemonics take this affix as a suffix, and in unified syntax,
   'most' is upgraded to 'all'.  However, in the divided syntax, some
   instructions take the affix as an infix, notably the s-variants of
   the arithmetic instructions.  Of those instructions, all but six
   have the infix appear after the third character of the mnemonic.

   Accordingly, the algorithm for looking up primary opcodes given
   an identifier is:

   1. Look up the identifier in the opcode table.
      If we find a match, go to step U.

   2. Look up the last two characters of the identifier in the
      conditions table.  If we find a match, look up the first N-2
      characters of the identifier in the opcode table.  If we
      find a match, go to step CE.

   3. Look up the fourth and fifth characters of the identifier in
      the conditions table.  If we find a match, extract those
      characters from the identifier, and look up the remaining
      characters in the opcode table.  If we find a match, go
      to step CM.

   4. Fail.

   U. Examine the tag field of the opcode structure, in case this is
      one of the six instructions with its conditional infix in an
      unusual place.  If it is, the tag tells us where to find the
      infix; look it up in the conditions table and set inst.cond
      accordingly.  Otherwise, this is an unconditional instruction.
      Again set inst.cond accordingly.  Return the opcode structure.

  CE. Examine the tag field to make sure this is an instruction that
      should receive a conditional suffix.  If it is not, fail.
      Otherwise, set inst.cond from the suffix we already looked up,
      and return the opcode structure.

  CM. Examine the tag field to make sure this is an instruction that
      should receive a conditional infix after the third character.
      If it is not, fail.  Otherwise, undo the edits to the current
      line of input and proceed as for case CE.  */

static const struct asm_opcode *
opcode_lookup (char **str)
{
  char *end, *base;
  char *affix;
  const struct asm_opcode *opcode;
  const struct asm_cond *cond;

  /* Scan up to the end of the mnemonic, which must end in white space,
     '.' (in unified mode only), or end of string.  */
  for (base = end = *str; *end != '\0'; end++)
    if (*end == ' ' || (unified_syntax && *end == '.'))
      break;

  if (end == base)
    return 0;

  /* Handle a possible width suffix.  */
  if (end[0] == '.')
    {
      if (end[1] == 'w' && (end[2] == ' ' || end[2] == '\0'))
	inst.size_req = 4;
      else if (end[1] == 'n' && (end[2] == ' ' || end[2] == '\0'))
	inst.size_req = 2;
      else
	return 0;

      *str = end + 2;
    }
  else
    *str = end;

  /* Look for unaffixed or special-case affixed mnemonic.  */
  opcode = hash_find_n (arm_ops_hsh, base, end - base);
  if (opcode)
    {
      /* step U */
      if (opcode->tag < OT_odd_infix_0)
	{
	  inst.cond = COND_ALWAYS;
	  return opcode;
	}

      if (unified_syntax)
	as_warn (_("conditional infixes are deprecated in unified syntax"));
      affix = base + (opcode->tag - OT_odd_infix_0);
      cond = hash_find_n (arm_cond_hsh, affix, 2);
      assert (cond);

      inst.cond = cond->value;
      return opcode;
    }

  /* Cannot have a conditional suffix on a mnemonic of less than two
     characters.  */
  if (end - base < 3)
    return 0;

  /* Look for suffixed mnemonic.  */
  affix = end - 2;
  cond = hash_find_n (arm_cond_hsh, affix, 2);
  opcode = hash_find_n (arm_ops_hsh, base, affix - base);
  if (opcode && cond)
    {
      /* step CE */
      switch (opcode->tag)
	{
	case OT_cinfix3:
	case OT_odd_infix_unc:
	  if (!unified_syntax)
	    return 0;
	  /* else fall through */

	case OT_csuffix:
	case OT_csuf_or_in3:
	  inst.cond = cond->value;
	  return opcode;

	case OT_unconditional:
	case OT_unconditionalF:
	  /* delayed diagnostic */
	  inst.error = BAD_COND;
	  inst.cond = COND_ALWAYS;
	  return opcode;

	default:
	  return 0;
	}
    }

  /* Cannot have a usual-position infix on a mnemonic of less than
     six characters (five would be a suffix).  */
  if (end - base < 6)
    return 0;

  /* Look for infixed mnemonic in the usual position.  */
  affix = base + 3;
  cond = hash_find_n (arm_cond_hsh, affix, 2);
  if (cond)
    {
      char save[2];
      memcpy (save, affix, 2);
      memmove (affix, affix + 2, (end - affix) - 2);
      opcode = hash_find_n (arm_ops_hsh, base, (end - base) - 2);
      memmove (affix + 2, affix, (end - affix) - 2);
      memcpy (affix, save, 2);
    }
  if (opcode && (opcode->tag == OT_cinfix3 || opcode->tag == OT_csuf_or_in3))
    {
      /* step CM */
      if (unified_syntax)
	as_warn (_("conditional infixes are deprecated in unified syntax"));

      inst.cond = cond->value;
      return opcode;
    }

  return 0;
}

d7304 1
a7304 1
md_assemble (char *str)
d7306 1
a7306 1
  char *p = str;
d7320 7
a7326 2
  opcode = opcode_lookup (&p);
  if (!opcode)
d7328 1
a7328 5
      /* It wasn't an instruction, but it might be a register alias of
	 the form alias .req reg.  */
      if (!create_register_alias (str, p))
	as_bad (_("bad instruction `%s'"), str);

d7332 2
a7333 1
  if (thumb_mode)
d7335 1
a7335 2
      /* Check that this instruction is supported for this CPU.  */
      if (thumb_mode == 1 && (opcode->tvariant & cpu_variant) == 0)
d7337 8
a7344 3
	  as_bad (_("selected processor does not support `%s'"), str);
	  return;
	}
d7346 14
a7359 2
      mapping_state (MAP_THUMB);
      inst.instruction = opcode->tvalue;
d7361 2
a7362 2
      if (!parse_operands (p, opcode->operands))
	opcode->tencode ();
d7364 12
a7375 1
      if (!inst.error)
d7377 2
a7378 3
	  assert (inst.instruction < 0xe800 || inst.instruction > 0xffff);
	  inst.size = (inst.instruction > 0xffff ? 4 : 2);
	  if (inst.size_req && inst.size_req != inst.size)
d7380 1
a7380 1
	      as_bad (_("cannot honor width suffix -- `%s'"), str);
d7383 6
d7390 2
a7392 13
  else
    {
      /* Check that this instruction is supported for this CPU.  */
      if ((opcode->avariant & cpu_variant) == 0)
	{
	  as_bad (_("selected processor does not support `%s'"), str);
	  return;
	}
      if (inst.size_req)
	{
	  as_bad (_("width suffixes are invalid in ARM mode -- `%s'"), str);
	  return;
	}
d7394 6
a7399 11
      mapping_state (MAP_ARM);
      inst.instruction = opcode->avalue;
      if (opcode->tag == OT_unconditionalF)
	inst.instruction |= 0xF << 28;
      else
	inst.instruction |= inst.cond << 28;
      inst.size = INSN_SIZE;
      if (!parse_operands (p, opcode->operands))
	opcode->aencode ();
    }
  output_inst (str);
d7701 1
a7701 1
/* Table of all conditional affixes.  0xF is not defined as a condition code.  */
d7723 1
a7723 3
/* Macros for gluing together operand strings.  N.B. In all cases
   other than OPS0, the trailing OP_stop comes from default
   zero-initialization of the unspecified elements of the array.  */
d7732 2
a7733 2
/* These macros abstract out the exact format of the mnemonic table and
   save some repeated characters.  */
d7735 20
a7754 4
/* The normal sort of mnemonic; has a Thumb variant; takes a conditional suffix.  */
#define TxCE(mnem, op, top, nops, ops, ae, te) \
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, top, ARM_VARIANT, \
    do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
a7755 2
/* Two variants of the above - TCE for a numeric Thumb opcode, tCE for
   a T_MNEM_xyz enumerator.  */
d7761 41
a7801 36
/* Second most common sort of mnemonic: has a Thumb variant, takes a conditional
   infix after the third character.  */
#define TxC3(mnem, op, top, nops, ops, ae, te) \
  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, top, ARM_VARIANT, \
    do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
#define TC3(mnem, aop, top, nops, ops, ae, te) \
       TxC3(mnem, aop, 0x##top, nops, ops, ae, te)
#define tC3(mnem, aop, top, nops, ops, ae, te) \
       TxC3(mnem, aop, T_MNEM_##top, nops, ops, ae, te)

/* Mnemonic with a conditional infix in an unusual place.  Each and every variant has to
   appear in the condition table.  */
#define TxCM_(m1, m2, m3, op, top, nops, ops, ae, te)	\
  { #m1 #m2 #m3, OPS##nops ops, sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \
    0x##op, top, ARM_VARIANT, do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }

#define TxCM(m1, m2, op, top, nops, ops, ae, te)	\
  TxCM_(m1,   , m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, eq, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ne, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, cs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, hs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, cc, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ul, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, lo, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, mi, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, pl, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, vs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, vc, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, hi, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ls, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ge, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, lt, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, gt, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, le, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, al, m2, op, top, nops, ops, ae, te)
a7807 2
/* Mnemonic that cannot be conditionalized.  The ARM condition-code
   field is still 0xE.  */
d7809 1
a7809 2
  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \
    do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
a7810 2
/* Mnemonic that cannot be conditionalized, and bears 0xF in its ARM
   condition code field.  */
d7812 1
a7812 2
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##top, ARM_VARIANT, \
    do_##te ? THUMB_VARIANT : 0, do_##ae, do_##te }
a7813 1
/* ARM-only variants of all the above.  */
a7814 1
#define C3(mnem,  op, nops, ops, ae) TC3(mnem,  op, 0, nops, ops, ae, 0)
d7820 3
a7822 2
/* Thumb-only, unconditional.  */
#define UT(mnem,  op, nops, ops, te) TUE(mnem,  0, op, nops, ops, 0, te)
a7823 4
/* ARM-only, takes either a suffix or a position-3 infix
   (for an FPA corner case). */
#define C3E(mnem, op, nops, ops, ae) \
  { #mnem, OPS##nops ops, OT_csuf_or_in3, 0x##op, 0, ARM_VARIANT, 0, do_##ae, 0 }
d7830 1
a7830 1
 tC3(ands,	0100000, ands,	   3, (RR, oRR, SH), arit, t_arit3c),
d7832 1
a7832 1
 tC3(eors,	0300000, eors,	   3, (RR, oRR, SH), arit, t_arit3c),
d7834 1
a7834 1
 tC3(subs,	0500000, subs,	   3, (RR, oRR, SH), arit, t_add_sub),
d7836 1
a7836 1
 tC3(adds,	0900000, adds,	   3, (RR, oRR, SH), arit, t_add_sub),
d7838 1
a7838 1
 tC3(adcs,	0b00000, adcs,	   3, (RR, oRR, SH), arit, t_arit3c),
d7840 1
a7840 1
 tC3(sbcs,	0d00000, sbcs,	   3, (RR, oRR, SH), arit, t_arit3),
d7842 1
a7842 1
 tC3(orrs,	1900000, orrs,	   3, (RR, oRR, SH), arit, t_arit3c),
d7844 1
a7844 1
 tC3(bics,	1d00000, bics,	   3, (RR, oRR, SH), arit, t_arit3),
d7850 2
a7851 2
 tC3(tsts,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
  C3(tstp,	110f000,     	   2, (RR, SH),      cmp),
d7853 2
a7854 2
 tC3(cmps,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
  C3(cmpp,	150f000,     	   2, (RR, SH),      cmp),
d7856 2
a7857 2
 tC3(cmns,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
  C3(cmnp,	170f000,     	   2, (RR, SH),      cmp),
d7860 1
a7860 1
 tC3(movs,	1b00000, movs,	   2, (RR, SH),      mov,  t_mov_cmp),
d7862 1
a7862 1
 tC3(mvns,	1f00000, mvns,	   2, (RR, SH),      mov,  t_mvn_tst),
d7865 1
a7865 1
 tC3(ldrb,	4500000, ldrb,	   2, (RR, ADDR),    ldst, t_ldst),
d7867 1
a7867 1
 tC3(strb,	4400000, strb,	   2, (RR, ADDR),    ldst, t_ldst),
d7869 4
a7872 4
 tC3(stmia,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(stmea,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(ldmia,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(ldmfd,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
d7877 1
a7877 1
 TCE(b,		a000000, e7fe,	     1, (EXPr),	    branch, t_branch),
d7880 1
a7880 1
 TCE(b,		afffffe, e7fe,	     1, (EXPr),	    branch, t_branch),
d7886 1
a7886 1
  C3(adrl,	28f0000,           2, (RR, EXP),    adrl),
d7891 1
a7891 1
 tC3(lsls,	1b00000, lsls,	   3, (RR, oRR, SH), shift, t_shift),
d7893 1
a7893 1
 tC3(lsrs,	1b00020, lsrs,	   3, (RR, oRR, SH), shift, t_shift),
d7895 1
a7895 1
 tC3(asrs,     1b00040, asrs,     3, (RR, oRR, SH), shift, t_shift),
d7897 1
a7897 1
 tC3(rors,	1b00060, rors,	   3, (RR, oRR, SH), shift, t_shift),
d7899 1
a7899 1
 tC3(negs,	2700000, negs,	   2, (RR, RR),      rd_rn, t_neg),
d7911 1
a7911 1
 TC3(rsbs,	0700000, ebd00000, 3, (RR, oRR, SH), arit, t_rsb),
d7913 2
a7914 2
 TC3(teqs,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
  C3(teqp,	130f000,           2, (RR, SH),      cmp),
d7916 4
a7919 4
 TC3(ldrt,	4300000, f8500e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(ldrbt,	4700000, f8300e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(strt,	4200000, f8400e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(strbt,	4600000, f8200e00, 2, (RR, ADDR),    ldstt, t_ldstt),
d7921 2
a7922 2
 TC3(stmdb,	9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(stmfd,    9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
d7924 2
a7925 2
 TC3(ldmdb,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(ldmea,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
d7929 1
a7929 1
  C3(rscs,	0f00000,	   3, (RR, oRR, SH), arit),
d7931 8
a7938 8
  C3(stmib,	9800000,	   2, (RRw, REGLST), ldmstm),
  C3(stmfa,	9800000,	   2, (RRw, REGLST), ldmstm),
  C3(stmda,	8000000,	   2, (RRw, REGLST), ldmstm),
  C3(stmed,	8000000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmib,	9900000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmed,	9900000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmda,	8100000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmfa,	8100000,	   2, (RRw, REGLST), ldmstm),
d7945 1
a7945 1
 tC3(muls,	0100090, muls,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
d7950 1
a7950 1
  C3(mlas,	0300090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas),
d7955 1
a7955 1
 TC3(ldcl,	c500000, ec500000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
d7957 1
a7957 1
 TC3(stcl,	c400000, ec400000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
d7964 1
a7964 1
  C3(swpb,	1400090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),
d7986 4
a7989 4
 tC3(ldrh,	01000b0, ldrh,     2, (RR, ADDR), ldstv4, t_ldst),
 tC3(strh,	00000b0, strh,     2, (RR, ADDR), ldstv4, t_ldst),
 tC3(ldrsh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tC3(ldrsb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),
d8051 2
a8052 2
 TC3(ldrd,	00000d0, e9500000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),
 TC3(strd,	00000f0, e9400000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),
d8203 22
a8224 23
 TC3(ldrht,	03000b0, f8300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(ldrsht,	03000f0, f9300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(ldrsbt,	03000d0, f9100e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(strht,	02000b0, f8200e00, 2, (RR, ADDR), ldsttv4, t_ldstt),

  UT(cbnz,      b900,    2, (RR, EXP), t_czb),
  UT(cbz,       b100,    2, (RR, EXP), t_czb),
 /* ARM does not really have an IT instruction.  */
 TUE(it,        0, bf08, 1, (COND),    it, t_it),
 TUE(itt,       0, bf0c, 1, (COND),    it, t_it),
 TUE(ite,       0, bf04, 1, (COND),    it, t_it),
 TUE(ittt,      0, bf0e, 1, (COND),    it, t_it),
 TUE(itet,      0, bf06, 1, (COND),    it, t_it),
 TUE(itte,      0, bf0a, 1, (COND),    it, t_it),
 TUE(itee,      0, bf02, 1, (COND),    it, t_it),
 TUE(itttt,     0, bf0f, 1, (COND),    it, t_it),
 TUE(itett,     0, bf07, 1, (COND),    it, t_it),
 TUE(ittet,     0, bf0b, 1, (COND),    it, t_it),
 TUE(iteet,     0, bf03, 1, (COND),    it, t_it),
 TUE(ittte,     0, bf0d, 1, (COND),    it, t_it),
 TUE(itete,     0, bf05, 1, (COND),    it, t_it),
 TUE(ittee,     0, bf09, 1, (COND),    it, t_it),
 TUE(iteee,     0, bf01, 1, (COND),    it, t_it),
d8233 386
a8618 386
  C3(ldfs,	c100100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfd,	c108100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfe,	c500100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfp,	c508100, 2, (RF, ADDR),	     rd_cpaddr),

  C3(stfs,	c000100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfd,	c008100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfe,	c400100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfp,	c408100, 2, (RF, ADDR),	     rd_cpaddr),

  C3(mvfs,	e008100, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsp,	e008120, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsm,	e008140, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsz,	e008160, 2, (RF, RF_IF),     rd_rm),
  C3(mvfd,	e008180, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdp,	e0081a0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdm,	e0081c0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdz,	e0081e0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfe,	e088100, 2, (RF, RF_IF),     rd_rm),
  C3(mvfep,	e088120, 2, (RF, RF_IF),     rd_rm),
  C3(mvfem,	e088140, 2, (RF, RF_IF),     rd_rm),
  C3(mvfez,	e088160, 2, (RF, RF_IF),     rd_rm),

  C3(mnfs,	e108100, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsp,	e108120, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsm,	e108140, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsz,	e108160, 2, (RF, RF_IF),     rd_rm),
  C3(mnfd,	e108180, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdp,	e1081a0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdm,	e1081c0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdz,	e1081e0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfe,	e188100, 2, (RF, RF_IF),     rd_rm),
  C3(mnfep,	e188120, 2, (RF, RF_IF),     rd_rm),
  C3(mnfem,	e188140, 2, (RF, RF_IF),     rd_rm),
  C3(mnfez,	e188160, 2, (RF, RF_IF),     rd_rm),

  C3(abss,	e208100, 2, (RF, RF_IF),     rd_rm),
  C3(abssp,	e208120, 2, (RF, RF_IF),     rd_rm),
  C3(abssm,	e208140, 2, (RF, RF_IF),     rd_rm),
  C3(abssz,	e208160, 2, (RF, RF_IF),     rd_rm),
  C3(absd,	e208180, 2, (RF, RF_IF),     rd_rm),
  C3(absdp,	e2081a0, 2, (RF, RF_IF),     rd_rm),
  C3(absdm,	e2081c0, 2, (RF, RF_IF),     rd_rm),
  C3(absdz,	e2081e0, 2, (RF, RF_IF),     rd_rm),
  C3(abse,	e288100, 2, (RF, RF_IF),     rd_rm),
  C3(absep,	e288120, 2, (RF, RF_IF),     rd_rm),
  C3(absem,	e288140, 2, (RF, RF_IF),     rd_rm),
  C3(absez,	e288160, 2, (RF, RF_IF),     rd_rm),

  C3(rnds,	e308100, 2, (RF, RF_IF),     rd_rm),
  C3(rndsp,	e308120, 2, (RF, RF_IF),     rd_rm),
  C3(rndsm,	e308140, 2, (RF, RF_IF),     rd_rm),
  C3(rndsz,	e308160, 2, (RF, RF_IF),     rd_rm),
  C3(rndd,	e308180, 2, (RF, RF_IF),     rd_rm),
  C3(rnddp,	e3081a0, 2, (RF, RF_IF),     rd_rm),
  C3(rnddm,	e3081c0, 2, (RF, RF_IF),     rd_rm),
  C3(rnddz,	e3081e0, 2, (RF, RF_IF),     rd_rm),
  C3(rnde,	e388100, 2, (RF, RF_IF),     rd_rm),
  C3(rndep,	e388120, 2, (RF, RF_IF),     rd_rm),
  C3(rndem,	e388140, 2, (RF, RF_IF),     rd_rm),
  C3(rndez,	e388160, 2, (RF, RF_IF),     rd_rm),

  C3(sqts,	e408100, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsp,	e408120, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsm,	e408140, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsz,	e408160, 2, (RF, RF_IF),     rd_rm),
  C3(sqtd,	e408180, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdp,	e4081a0, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdm,	e4081c0, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdz,	e4081e0, 2, (RF, RF_IF),     rd_rm),
  C3(sqte,	e488100, 2, (RF, RF_IF),     rd_rm),
  C3(sqtep,	e488120, 2, (RF, RF_IF),     rd_rm),
  C3(sqtem,	e488140, 2, (RF, RF_IF),     rd_rm),
  C3(sqtez,	e488160, 2, (RF, RF_IF),     rd_rm),

  C3(logs,	e508100, 2, (RF, RF_IF),     rd_rm),
  C3(logsp,	e508120, 2, (RF, RF_IF),     rd_rm),
  C3(logsm,	e508140, 2, (RF, RF_IF),     rd_rm),
  C3(logsz,	e508160, 2, (RF, RF_IF),     rd_rm),
  C3(logd,	e508180, 2, (RF, RF_IF),     rd_rm),
  C3(logdp,	e5081a0, 2, (RF, RF_IF),     rd_rm),
  C3(logdm,	e5081c0, 2, (RF, RF_IF),     rd_rm),
  C3(logdz,	e5081e0, 2, (RF, RF_IF),     rd_rm),
  C3(loge,	e588100, 2, (RF, RF_IF),     rd_rm),
  C3(logep,	e588120, 2, (RF, RF_IF),     rd_rm),
  C3(logem,	e588140, 2, (RF, RF_IF),     rd_rm),
  C3(logez,	e588160, 2, (RF, RF_IF),     rd_rm),

  C3(lgns,	e608100, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsp,	e608120, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsm,	e608140, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsz,	e608160, 2, (RF, RF_IF),     rd_rm),
  C3(lgnd,	e608180, 2, (RF, RF_IF),     rd_rm),
  C3(lgndp,	e6081a0, 2, (RF, RF_IF),     rd_rm),
  C3(lgndm,	e6081c0, 2, (RF, RF_IF),     rd_rm),
  C3(lgndz,	e6081e0, 2, (RF, RF_IF),     rd_rm),
  C3(lgne,	e688100, 2, (RF, RF_IF),     rd_rm),
  C3(lgnep,	e688120, 2, (RF, RF_IF),     rd_rm),
  C3(lgnem,	e688140, 2, (RF, RF_IF),     rd_rm),
  C3(lgnez,	e688160, 2, (RF, RF_IF),     rd_rm),

  C3(exps,	e708100, 2, (RF, RF_IF),     rd_rm),
  C3(expsp,	e708120, 2, (RF, RF_IF),     rd_rm),
  C3(expsm,	e708140, 2, (RF, RF_IF),     rd_rm),
  C3(expsz,	e708160, 2, (RF, RF_IF),     rd_rm),
  C3(expd,	e708180, 2, (RF, RF_IF),     rd_rm),
  C3(expdp,	e7081a0, 2, (RF, RF_IF),     rd_rm),
  C3(expdm,	e7081c0, 2, (RF, RF_IF),     rd_rm),
  C3(expdz,	e7081e0, 2, (RF, RF_IF),     rd_rm),
  C3(expe,	e788100, 2, (RF, RF_IF),     rd_rm),
  C3(expep,	e788120, 2, (RF, RF_IF),     rd_rm),
  C3(expem,	e788140, 2, (RF, RF_IF),     rd_rm),
  C3(expdz,	e788160, 2, (RF, RF_IF),     rd_rm),

  C3(sins,	e808100, 2, (RF, RF_IF),     rd_rm),
  C3(sinsp,	e808120, 2, (RF, RF_IF),     rd_rm),
  C3(sinsm,	e808140, 2, (RF, RF_IF),     rd_rm),
  C3(sinsz,	e808160, 2, (RF, RF_IF),     rd_rm),
  C3(sind,	e808180, 2, (RF, RF_IF),     rd_rm),
  C3(sindp,	e8081a0, 2, (RF, RF_IF),     rd_rm),
  C3(sindm,	e8081c0, 2, (RF, RF_IF),     rd_rm),
  C3(sindz,	e8081e0, 2, (RF, RF_IF),     rd_rm),
  C3(sine,	e888100, 2, (RF, RF_IF),     rd_rm),
  C3(sinep,	e888120, 2, (RF, RF_IF),     rd_rm),
  C3(sinem,	e888140, 2, (RF, RF_IF),     rd_rm),
  C3(sinez,	e888160, 2, (RF, RF_IF),     rd_rm),

  C3(coss,	e908100, 2, (RF, RF_IF),     rd_rm),
  C3(cossp,	e908120, 2, (RF, RF_IF),     rd_rm),
  C3(cossm,	e908140, 2, (RF, RF_IF),     rd_rm),
  C3(cossz,	e908160, 2, (RF, RF_IF),     rd_rm),
  C3(cosd,	e908180, 2, (RF, RF_IF),     rd_rm),
  C3(cosdp,	e9081a0, 2, (RF, RF_IF),     rd_rm),
  C3(cosdm,	e9081c0, 2, (RF, RF_IF),     rd_rm),
  C3(cosdz,	e9081e0, 2, (RF, RF_IF),     rd_rm),
  C3(cose,	e988100, 2, (RF, RF_IF),     rd_rm),
  C3(cosep,	e988120, 2, (RF, RF_IF),     rd_rm),
  C3(cosem,	e988140, 2, (RF, RF_IF),     rd_rm),
  C3(cosez,	e988160, 2, (RF, RF_IF),     rd_rm),

  C3(tans,	ea08100, 2, (RF, RF_IF),     rd_rm),
  C3(tansp,	ea08120, 2, (RF, RF_IF),     rd_rm),
  C3(tansm,	ea08140, 2, (RF, RF_IF),     rd_rm),
  C3(tansz,	ea08160, 2, (RF, RF_IF),     rd_rm),
  C3(tand,	ea08180, 2, (RF, RF_IF),     rd_rm),
  C3(tandp,	ea081a0, 2, (RF, RF_IF),     rd_rm),
  C3(tandm,	ea081c0, 2, (RF, RF_IF),     rd_rm),
  C3(tandz,	ea081e0, 2, (RF, RF_IF),     rd_rm),
  C3(tane,	ea88100, 2, (RF, RF_IF),     rd_rm),
  C3(tanep,	ea88120, 2, (RF, RF_IF),     rd_rm),
  C3(tanem,	ea88140, 2, (RF, RF_IF),     rd_rm),
  C3(tanez,	ea88160, 2, (RF, RF_IF),     rd_rm),

  C3(asns,	eb08100, 2, (RF, RF_IF),     rd_rm),
  C3(asnsp,	eb08120, 2, (RF, RF_IF),     rd_rm),
  C3(asnsm,	eb08140, 2, (RF, RF_IF),     rd_rm),
  C3(asnsz,	eb08160, 2, (RF, RF_IF),     rd_rm),
  C3(asnd,	eb08180, 2, (RF, RF_IF),     rd_rm),
  C3(asndp,	eb081a0, 2, (RF, RF_IF),     rd_rm),
  C3(asndm,	eb081c0, 2, (RF, RF_IF),     rd_rm),
  C3(asndz,	eb081e0, 2, (RF, RF_IF),     rd_rm),
  C3(asne,	eb88100, 2, (RF, RF_IF),     rd_rm),
  C3(asnep,	eb88120, 2, (RF, RF_IF),     rd_rm),
  C3(asnem,	eb88140, 2, (RF, RF_IF),     rd_rm),
  C3(asnez,	eb88160, 2, (RF, RF_IF),     rd_rm),

  C3(acss,	ec08100, 2, (RF, RF_IF),     rd_rm),
  C3(acssp,	ec08120, 2, (RF, RF_IF),     rd_rm),
  C3(acssm,	ec08140, 2, (RF, RF_IF),     rd_rm),
  C3(acssz,	ec08160, 2, (RF, RF_IF),     rd_rm),
  C3(acsd,	ec08180, 2, (RF, RF_IF),     rd_rm),
  C3(acsdp,	ec081a0, 2, (RF, RF_IF),     rd_rm),
  C3(acsdm,	ec081c0, 2, (RF, RF_IF),     rd_rm),
  C3(acsdz,	ec081e0, 2, (RF, RF_IF),     rd_rm),
  C3(acse,	ec88100, 2, (RF, RF_IF),     rd_rm),
  C3(acsep,	ec88120, 2, (RF, RF_IF),     rd_rm),
  C3(acsem,	ec88140, 2, (RF, RF_IF),     rd_rm),
  C3(acsez,	ec88160, 2, (RF, RF_IF),     rd_rm),

  C3(atns,	ed08100, 2, (RF, RF_IF),     rd_rm),
  C3(atnsp,	ed08120, 2, (RF, RF_IF),     rd_rm),
  C3(atnsm,	ed08140, 2, (RF, RF_IF),     rd_rm),
  C3(atnsz,	ed08160, 2, (RF, RF_IF),     rd_rm),
  C3(atnd,	ed08180, 2, (RF, RF_IF),     rd_rm),
  C3(atndp,	ed081a0, 2, (RF, RF_IF),     rd_rm),
  C3(atndm,	ed081c0, 2, (RF, RF_IF),     rd_rm),
  C3(atndz,	ed081e0, 2, (RF, RF_IF),     rd_rm),
  C3(atne,	ed88100, 2, (RF, RF_IF),     rd_rm),
  C3(atnep,	ed88120, 2, (RF, RF_IF),     rd_rm),
  C3(atnem,	ed88140, 2, (RF, RF_IF),     rd_rm),
  C3(atnez,	ed88160, 2, (RF, RF_IF),     rd_rm),

  C3(urds,	ee08100, 2, (RF, RF_IF),     rd_rm),
  C3(urdsp,	ee08120, 2, (RF, RF_IF),     rd_rm),
  C3(urdsm,	ee08140, 2, (RF, RF_IF),     rd_rm),
  C3(urdsz,	ee08160, 2, (RF, RF_IF),     rd_rm),
  C3(urdd,	ee08180, 2, (RF, RF_IF),     rd_rm),
  C3(urddp,	ee081a0, 2, (RF, RF_IF),     rd_rm),
  C3(urddm,	ee081c0, 2, (RF, RF_IF),     rd_rm),
  C3(urddz,	ee081e0, 2, (RF, RF_IF),     rd_rm),
  C3(urde,	ee88100, 2, (RF, RF_IF),     rd_rm),
  C3(urdep,	ee88120, 2, (RF, RF_IF),     rd_rm),
  C3(urdem,	ee88140, 2, (RF, RF_IF),     rd_rm),
  C3(urdez,	ee88160, 2, (RF, RF_IF),     rd_rm),

  C3(nrms,	ef08100, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsp,	ef08120, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsm,	ef08140, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsz,	ef08160, 2, (RF, RF_IF),     rd_rm),
  C3(nrmd,	ef08180, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdp,	ef081a0, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdm,	ef081c0, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdz,	ef081e0, 2, (RF, RF_IF),     rd_rm),
  C3(nrme,	ef88100, 2, (RF, RF_IF),     rd_rm),
  C3(nrmep,	ef88120, 2, (RF, RF_IF),     rd_rm),
  C3(nrmem,	ef88140, 2, (RF, RF_IF),     rd_rm),
  C3(nrmez,	ef88160, 2, (RF, RF_IF),     rd_rm),

  C3(adfs,	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsp,	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsm,	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsz,	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfd,	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdp,	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdm,	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdz,	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfe,	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfep,	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfem,	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfez,	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(sufs,	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsp,	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsm,	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsz,	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufd,	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdp,	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdm,	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdz,	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufe,	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufep,	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufem,	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufez,	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rsfs,	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsp,	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsm,	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsz,	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfd,	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdp,	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdm,	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdz,	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfe,	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfep,	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfem,	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfez,	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(mufs,	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsp,	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsm,	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsz,	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufd,	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdp,	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdm,	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdz,	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufe,	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufep,	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufem,	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufez,	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(dvfs,	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsp,	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsm,	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsz,	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfd,	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdp,	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdm,	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdz,	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfe,	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfep,	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfem,	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfez,	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rdfs,	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsp,	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsm,	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsz,	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfd,	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdp,	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdm,	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdz,	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfe,	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfep,	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfem,	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfez,	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(pows,	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsp,	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsm,	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsz,	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powd,	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdp,	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdm,	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdz,	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powe,	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powep,	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powem,	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powez,	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rpws,	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsp,	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsm,	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsz,	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwd,	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdp,	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdm,	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdz,	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwe,	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwep,	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwem,	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwez,	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rmfs,	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsp,	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsm,	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsz,	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfd,	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdp,	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdm,	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdz,	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfe,	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfep,	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfem,	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfez,	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(fmls,	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsp,	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsm,	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsz,	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmld,	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldp,	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldm,	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldz,	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmle,	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlep,	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlem,	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlez,	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(fdvs,	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsp,	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsm,	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsz,	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvd,	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdp,	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdm,	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdz,	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdve,	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvep,	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvem,	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvez,	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(frds,	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsp,	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsm,	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsz,	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdd,	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddp,	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddm,	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddz,	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frde,	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdep,	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdem,	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdez,	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(pols,	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsp,	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsm,	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsz,	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(pold,	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldp,	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldm,	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldz,	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(pole,	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polep,	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polem,	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polez,	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),
d8621 1
a8621 1
 C3E(cmfe,	ed0f110, 2, (RF, RF_IF),     fpa_cmp),
d8623 19
a8641 14
 C3E(cnfe,	ef0f110, 2, (RF, RF_IF),     fpa_cmp),

  C3(flts,	e000110, 2, (RF, RR),	     rn_rd),
  C3(fltsp,	e000130, 2, (RF, RR),	     rn_rd),
  C3(fltsm,	e000150, 2, (RF, RR),	     rn_rd),
  C3(fltsz,	e000170, 2, (RF, RR),	     rn_rd),
  C3(fltd,	e000190, 2, (RF, RR),	     rn_rd),
  C3(fltdp,	e0001b0, 2, (RF, RR),	     rn_rd),
  C3(fltdm,	e0001d0, 2, (RF, RR),	     rn_rd),
  C3(fltdz,	e0001f0, 2, (RF, RR),	     rn_rd),
  C3(flte,	e080110, 2, (RF, RR),	     rn_rd),
  C3(fltep,	e080130, 2, (RF, RR),	     rn_rd),
  C3(fltem,	e080150, 2, (RF, RR),	     rn_rd),
  C3(fltez,	e080170, 2, (RF, RR),	     rn_rd),
d8649 12
a8660 12
  C3(fixp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixsp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixsm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixsz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixdp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixdm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixdz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixep,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixem,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixez,	e100170, 2, (RR, RF),	     rd_rm),
d8666 2
a8667 2
  C3(lfmfd,	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(lfmea,	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
d8669 2
a8670 2
  C3(sfmfd,	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(sfmea,	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),
@


1.193.4.9
log
@	Backport:
	2005-08-02  Khem Raj  <kraj@@mvista.com>

	* config/tc-arm.c (do_iwmmxt_wldstd): Correct the offset range for
	WLDRD/WSTRD instruction.

	2005-08-03  Nick Clifton  <nickc@@redhat.com>

	* gas/arm/iwmmxt-bad2.s: New file: Check for error messages about
	erroneous offsets in iwmmxt instructions.  Cannot be part of
	iwmmxt-bad.s because the errors there stop the assembler before it
	gets to check the offsets in instructions.
	* gas/arm/iwmmxt-bad2.d: New file.
	* gas/arm/iwmmxt-bad2.l: New file: Expected error messages.

	2005-08-02  Khem Raj  <kraj@@mvista.com>

	* gas/arm/iwmmxt.s: Change the offset values of the WLDRD, WSTRD
	and WSTRW instructions to be larger than +/-255.
	* gas/arm/iwmmxt.d: Fix the expected results for these
	instructions.
@
text
@d5471 1
a5471 1
  encode_arm_cp_address (1, TRUE, FALSE, 0);
@


1.193.4.10
log
@	* gas/config/tc-arm.c (do_iwmmxt_wldstbh): Don't multiply offset
	by 4 here.
	(md_apply_fix3): Multiply offset by 4 here for
	BFD_RELOC_ARM_CP_OFF_IMM_S2.
	* gas/testsuite/gas/arm/arm.exp: Run iwmmxt-bad2.
	* gas/testsuite/gas/arm/iwmmxt.s: Increase offsets for wstrb and
	wstrh.
	* gas/testsuite/gas/arm/iwmmxt.d: Update expected results.
	* gas/testsuite/gas/arm/iwmmxt-bad2.s: Test wstrb, wstrh, wldrb
	and wldrh.
	* gas/testsuite/gas/arm/iwmmxt-bad2.l: Update expected error
	messages.
@
text
@d5449 1
a10888 1
      value *= 4;
@


1.192
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d13819 1
a13819 1
  unsigned char *ptr;
d14028 1
a14028 1
  unsigned char *ptr;
@


1.191
log
@	* config/tc-arm.c (do_t_ldmstm): Change BFD_RELOC_NONE to
	BFD_RELOC_UNUSED.
	(do_t_push_pop): Likewise.
	(md_assemble): Likewise.
	(md_apply_fix3): Handle BFD_RELOC_NONE correctly, make BFD_RELOC_UNUSED
	same as previous meaning of BFD_RELOC_NONE.
	(create_unwind_entry): Output dependency on the required personality
	routines.
	testsuite/gas/arm/unwind.d: Alter expected output to include dependency
	on __aeabi_unwind_cpp_pr[01].
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005
d4554 1
d4595 1
d11033 1
a11043 1
#if defined OBJ_COFF || defined OBJ_ELF
d11069 1
a11069 1
#endif
a11082 1
#if defined OBJ_COFF || defined OBJ_ELF
d11102 1
a11103 1
  }
@


1.190
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d9372 1
a9372 1
  if (inst.reloc.type != BFD_RELOC_NONE)
d9375 1
a9375 1
      inst.reloc.type = BFD_RELOC_NONE;
d9464 1
a9464 1
  if (inst.reloc.type != BFD_RELOC_NONE)
d9467 1
a9467 1
      inst.reloc.type = BFD_RELOC_NONE;
d11364 1
a11364 1
  assert (fixP->fx_r_type < BFD_RELOC_UNUSED);
d11386 5
d12058 1
a12058 1
    case BFD_RELOC_NONE:
d12114 1
d12179 1
d12303 1
a12303 1
  if (inst.reloc.type != BFD_RELOC_NONE)
d12329 1
a12329 1
  inst.reloc.type = BFD_RELOC_NONE;
d13903 8
a13919 1
    /* TODO: Emit R_ARM_NONE to the personality routine.  */
d13924 1
a13924 1
      break;
d13931 11
@


1.189
log
@2005-01-06  Paul Brook  <paul@@codesourcery.com>

bfd/
	* config.bfd: Add entry for arm-*-vxworks and arm-*-windiss.
	* configure.in: Add bfd_elf32_{big,little}arm_vxworks_vec.
	* configure: Regenerate.
	* elf32-arm.c: Add VxWorks target bfd.
	(USE_REL): Remove.
	(elf32_arm_link_hash_table): Add use_rel.
	(elf32_arm_link_hash_table_create, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section): Replace USE_REL with runtime check.
	Correct offset calculation for RELA case.
	(elf_backend_may_use_rel_p, elf_backend_may_use_rela_p,
	elf_backend_default_use_rela_p, elf_backend_rela_normal): Define.
	(elf32_arm_vxworks_link_hash_table_create): New function.
	* targets.c (bfd_elf32_bigarm_vxworks_vec): Add declaration.
	(bfd_elf32_littlearm_vxworks_vec): Ditto.
	(_bfd_target_vector): Add bfd_elf32_{big,little}arm_vxworks_vec.
gas/
	* config/tc-arm.c (FPU_DEFAULT): Define for TE_VXWORKS.
	(md_begin): Handle TE_VXWORKS for FP defaults.
	(md_apply_fix3): Correct rela offsets.
	(elf32_arm_target_format): Add VxWorks targets.
ld/
	* Makefie.am: Add earmelf_vxworks.
	* Makefile.in: Regenerate.
	* configure.tgt: Make arm-*-vxworks a separate case.
	* emulparams/armelf_vxworks.sh: New function.
@
text
@a2685 12
#if 0  /* The first edition of the ARM architecture manual stated that
	  writing anything other than the flags with an immediate operation
	  had UNPREDICTABLE effects.  This constraint was removed in the
	  second edition of the specification.  */
  if ((cpu_variant & ARM_EXT_V5) != ARM_EXT_V5
      && inst.instruction & ((PSR_c | PSR_x | PSR_s) << PSR_SHIFT))
    {
      inst.error = _("immediate value cannot be used to set this field");
      return;
    }
#endif

a10872 49
#if 0 /* Suppressed - for now.  */
#if defined OBJ_ELF || defined OBJ_COFF

#ifdef OBJ_ELF
#define arm_Note Elf_External_Note
#else
typedef struct
{
  unsigned char	namesz[4];	/* Size of entry's owner string.  */
  unsigned char	descsz[4];	/* Size of the note descriptor.  */
  unsigned char	type[4];	/* Interpretation of the descriptor.  */
  char		name[1];	/* Start of the name+desc data.  */
} arm_Note;
#endif

/* The description is kept to a fix sized in order to make updating
   it and merging it easier.  */
#define ARM_NOTE_DESCRIPTION_LENGTH	8

static void
arm_add_note (const char * name,
	      const char * description,
	      unsigned int type)
{
  arm_Note     note ATTRIBUTE_UNUSED;
  char *       p;
  unsigned int name_len;

  name_len = (strlen (name) + 1 + 3) & ~3;

  p = frag_more (sizeof (note.namesz));
  md_number_to_chars (p, (valueT) name_len, sizeof (note.namesz));

  p = frag_more (sizeof (note.descsz));
  md_number_to_chars (p, (valueT) ARM_NOTE_DESCRIPTION_LENGTH, sizeof (note.descsz));

  p = frag_more (sizeof (note.type));
  md_number_to_chars (p, (valueT) type, sizeof (note.type));

  p = frag_more (name_len);
  strcpy (p, name);

  p = frag_more (ARM_NOTE_DESCRIPTION_LENGTH);
  strncpy (p, description, ARM_NOTE_DESCRIPTION_LENGTH);
  frag_align (2, 0, 0);
}
#endif
#endif

a11149 56
#if 0 /* Suppressed - for now.  */
#if defined (OBJ_ELF) || defined (OBJ_COFF)

  /* Create a .note section to fully identify this arm binary.  */

#define NOTE_ARCH_STRING 	"arch: "

#if defined OBJ_COFF && ! defined NT_VERSION
#define NT_VERSION  1
#define NT_ARCH     2
#endif

  {
    segT current_seg = now_seg;
    subsegT current_subseg = now_subseg;
    asection * arm_arch;
    const char * arch_string;

    arm_arch = bfd_make_section_old_way (stdoutput, ARM_NOTE_SECTION);

#ifdef OBJ_COFF
    bfd_set_section_flags (stdoutput, arm_arch,
			   SEC_DATA | SEC_ALLOC | SEC_LOAD | SEC_LINK_ONCE \
			   | SEC_HAS_CONTENTS);
#else
    bfd_set_section_flags (stdoutput, arm_arch,
			   SEC_READONLY | SEC_HAS_CONTENTS);
#endif
    arm_arch->output_section = arm_arch;
    subseg_set (arm_arch, 0);

    switch (mach)
      {
      default:
      case bfd_mach_arm_unknown: arch_string = "unknown"; break;
      case bfd_mach_arm_2:       arch_string = "armv2"; break;
      case bfd_mach_arm_2a:      arch_string = "armv2a"; break;
      case bfd_mach_arm_3:       arch_string = "armv3"; break;
      case bfd_mach_arm_3M:      arch_string = "armv3M"; break;
      case bfd_mach_arm_4:       arch_string = "armv4"; break;
      case bfd_mach_arm_4T:      arch_string = "armv4t"; break;
      case bfd_mach_arm_5:       arch_string = "armv5"; break;
      case bfd_mach_arm_5T:      arch_string = "armv5t"; break;
      case bfd_mach_arm_5TE:     arch_string = "armv5te"; break;
      case bfd_mach_arm_XScale:  arch_string = "XScale"; break;
      case bfd_mach_arm_ep9312:  arch_string = "ep9312"; break;
      case bfd_mach_arm_iWMMXt:  arch_string = "iWMMXt"; break;
      }

    arm_add_note (NOTE_ARCH_STRING, arch_string, NT_ARCH);

    subseg_set (current_seg, current_subseg);
  }
#endif
#endif /* Suppressed code.  */

a11366 6
#if 0
  /* Patch from REarnshaw to JDavis (disabled for the moment, since it
     doesn't work fully.)  */
  if ((fixP->fx_addsy == 0 || symbol_constant_p (fixP->fx_addsy))
      && !fixP->fx_pcrel)
#else
a11367 1
#endif
a12312 6
  /* Align the instruction.
     This may not be the right thing to do but ...  */
#if 0
  arm_align (2, 0);
#endif

@


1.188
log
@	* config/tc-arm.c (arm_cpus): Correct arch field for arm1026ej-s.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d129 2
d11065 1
a11065 1
#if !(defined (TE_LINUX) || defined (TE_NetBSD))
d11770 12
a11781 1
      newval = (value & 0x00ffffff) | (newval & 0xff000000);
d11796 15
a11810 1
	newval = value | (newval & 0xfe000000) | (hbit << 24);
d11826 10
a11835 1
	newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
d11851 10
a11860 1
	newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
a11884 2
	newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
	newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
d11890 16
a11905 1
	  newval2 = (newval2 + 1) & ~ 1;
d11912 2
d11926 2
d11943 2
d11955 2
d13572 4
@


1.187
log
@	* config/tc-arm.c (s_arm_unwind_fnend): Use R_ARM_PREL31 relocation
	for function start.
	* testsuite/gas/arm/unwind.d: Expect R_ARM_PREL31 relocations.
@
text
@d12762 2
a12763 2
  {"arm1026ejs",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1026ej-s",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
@


1.186
log
@	* Makefile.am (TARG_ENV_HFILES): Add te-armlinuxeabi.h.
	* configure.in: Use it for arm*-*-linux-gnueabi*.
	* config/tc-arm.c: Allow emulation file to set FPU_DEFAULT.
	* config/te-armlinuxeabi.h: New file.
	* Makefile.in: Regenerated.
	* aclocal.m4: Likewise.
	* configure: Likewise.
	* doc/Makefile.in: Regenerated.
@
text
@d14082 1
a14082 1
	   BFD_RELOC_32);
@


1.185
log
@./
	* configure.in (arm-*-oabi*, thumb-*-oabi*): Remove.
	* configure: Regenerated.
bfd/
	* Makefile.am (BFD32_BACKENDS, BFD32_BACKENDS_CFILES): Replace
	elfarm-nabi with elf32-arm.  Remove elfarm-oabi.
	(elf32-arm.lo): Replace elfarm-nabi.lo rule.  Remove elf32-arm.h
	dependency.
	* config.bfd: Move arm-*-oabi* and thumb-*-oabi* from obsolete list
	to a new removed list.  Remove normal configuration stanzas.
	* configure.in: (bfd_elf32_bigarm_vec, bfd_elf32_bigarm_symbian_vec)
	(bfd_elf32_littlearm_symbian_vec, bfd_elf32_littlearm_vec): Replace
	elfarm-nabi.lo with elf32-arm.lo.
	(bfd_elf32_bigarm_oabi_vec, bfd_elf32_littlearm_oabi_vec): Remove.
	* elf32-arm.c: Renamed from elfarm-nabi.c.  Inline elf32-arm.h.
	* elf32-arm.h: Remove.
	* elfarm-oabi.c: Remove.
	* targets.c (_bfd_target_vector): Remove bfd_elf32_bigarm_oabi_vec
	and bfd_elf32_littlearm_oabi_vec.
	* aclocal.m4, Makefile.in, configure, doc/Makefile.in: Regenerated.
gas/
	* configure.in: Remove arm-*-oabi and thumb-*-oabi.
	* config/tc-arm.c (target_oabi): Delete.
	(md_apply_fix3, elf32_arm_target_format): Remove target_oabi checks.
	(arm_opts): Remove moabi.
	* doc/as.texinfo (Overview): Remove documentation of -moabi.
	* doc/c-arm.texi (ARM Options): Likewise.
	* configure: Regenerated.
ld/
	* Makefile.am (ALL_EMULATIONS): Remove earmelf_oabi.o.
	(earmelf_oabi.c): Remove rule.
	* configure.tgt: Remove arm-*-oabi and thumb-*-oabi.
	* emulparams/armelf_oabi.sh, emultempl/armelf_oabi.em: Delete files.
	* Makefile.in: Regenerated.
@
text
@a117 14
#ifdef TE_LINUX
#define FPU_DEFAULT FPU_ARCH_FPA
#endif

#ifdef TE_NetBSD
#ifdef OBJ_ELF
#define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, but VFP order.  */
#else
/* Legacy a.out format.  */
#define FPU_DEFAULT FPU_ARCH_FPA	/* Soft-float, but FPA order.  */
#endif
#endif

/* For backwards compatibility we default to the FPA.  */
d119 14
a132 2
#define FPU_DEFAULT FPU_ARCH_FPA
#endif
@


1.184
log
@Add ARM CFI support
@
text
@a139 1
static int target_oabi = 0;
d11501 1
a11501 9
	{
	  if (target_oabi
	      && (fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
		  || fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
		  ))
	    value = 0;
	  else
	    value += md_pcrel_from (fixP);
	}
d11720 1
a11720 2
      if (! target_oabi)
	value = fixP->fx_offset;
d11738 3
a11740 5
	     FIXME: The tests for OBJ_ELF and ! target_oabi are only here
	     because I have not worked out how to do this for OBJ_COFF or
	     target_oabi.  */
	  if (! target_oabi
	      && fixP->fx_addsy != NULL
d11779 1
a11779 2
	if (! target_oabi)
	  value = fixP->fx_offset;
d11858 1
a11858 1
      else if (!target_oabi)
d11870 1
a11870 1
      else if (!target_oabi)
d11895 1
a11895 1
      else if (!target_oabi)
a12565 1
  {"moabi",  N_("use old ABI (ELF only)"), &target_oabi, 1, NULL},
d13509 1
a13509 6
    {
      if (target_oabi)
	return "elf32-bigarm-oabi";
      else
	return "elf32-bigarm";
    }
d13511 1
a13511 6
    {
      if (target_oabi)
	return "elf32-littlearm-oabi";
      else
	return "elf32-littlearm";
    }
@


1.183
log
@2004-10-12  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.h: Support EABI version 4 objects.
binutils/
	* readelf.c (decode_ARM_machine_flags): Support EABI version 4.
gas/
	* config/tc-arm.c (md_begin): Change EF_ARM_EABI_VER3 to
	EF_ARM_EABI_VER4.
	(arm_eabis): Ditto.
	* doc/c-arm.texi: Document that we actually support -meabi=4, not
	-meabi=3.
include/
	* elf/arm.h (EF_ARM_EABI_VER4): Define.
@
text
@d44 1
d14863 25
@


1.182
log
@Add support for generating ARM unwind tables.
@
text
@d11133 1
a11133 1
      case EF_ARM_EABI_VER3:
d12904 1
a12904 1
/* We only know hot to output GNU and ver 3 (AAELF) formats.  */
d12908 1
a12908 1
  {"3",		EF_ARM_EABI_VER3},
@


1.181
log
@The patch below adds binutils support for the SHT_ARM_EXIDX, as defined by
 the ARM EABI.
@
text
@d46 1
a46 1
/* XXX Set this to 1 after the next binutils release */
d49 37
d7310 24
d7339 1
a7339 1
  char *start = *str;
d7343 1
a7343 17
      switch (pos)
	{
	case VFP_REG_Sd:
	  inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
	  break;

	case VFP_REG_Sn:
	  inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
	  break;

	case VFP_REG_Sm:
	  inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
	  break;

	default:
	  abort ();
	}
d7493 3
a7495 3
/* Parse and encode a VFP SP register list, storing the initial
   register in position POS and returning the range as the result.  If
   the string is invalid return FAIL (an invalid range).  */
d7497 2
a7498 2
static long
vfp_sp_reg_list (char ** str, enum vfp_sp_reg_pos pos)
d7500 1
a7500 2
  long range = 0;
  int base_reg = 0;
d7502 2
a7503 1
  long base_bits = 0;
d7505 1
a7505 1
  long tempinst;
d7507 1
a7507 1
  int warned = 0;
d7515 12
a7526 1
  tempinst = inst.instruction;
d7530 2
a7531 6
      inst.instruction = 0;

      if ((new_base = vfp_sp_reg_required_here (str, pos)) == FAIL)
	return FAIL;

      if (count == 0 || base_reg > new_base)
d7533 2
a7534 2
	  base_reg = new_base;
	  base_bits = inst.instruction;
d7537 3
d7564 1
a7564 1
	       = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab))
d7567 1
a7567 1
	      inst.error = _(all_reg_maps[REG_TYPE_SN].expected);
a7591 6
  if (**str != '}')
    {
      inst.error = _("invalid register list");
      return FAIL;
    }

a7593 2
  range = count;

d7595 1
a7595 1
  if (count == 0 || count > 32)
d7598 2
d7601 2
a7602 1
  while (count--)
d7604 1
a7604 1
      if ((mask & (1 << base_reg++)) == 0)
d7611 1
a7611 2
  inst.instruction = tempinst | base_bits;
  return range;
d7617 2
d7632 1
a7632 1
  if (vfp_sp_reg_list (&str, VFP_REG_Sm) != 2)
d7637 1
d7664 2
d7669 1
a7669 1
  if (vfp_sp_reg_list (&str, VFP_REG_Sm) != 2)
d7674 1
a7908 111
static long
vfp_dp_reg_list (char ** str)
{
  long range = 0;
  int base_reg = 0;
  int new_base;
  int count = 0;
  long tempinst;
  unsigned long mask = 0;
  int warned = 0;

  if (**str != '{')
    return FAIL;

  (*str)++;
  skip_whitespace (*str);

  tempinst = inst.instruction;

  do
    {
      inst.instruction = 0;

      if ((new_base = vfp_dp_reg_required_here (str, VFP_REG_Dd)) == FAIL)
	return FAIL;

      if (count == 0 || base_reg > new_base)
	{
	  base_reg = new_base;
	  range = inst.instruction;
	}

      if (mask & (1 << new_base))
	{
	  inst.error = _("invalid register list");
	  return FAIL;
	}

      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}

      mask |= 1 << new_base;
      count++;

      skip_whitespace (*str);

      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;

	  (*str)++;

	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab))
	      == FAIL)
	    {
	      inst.error = _(all_reg_maps[REG_TYPE_DN].expected);
	      return FAIL;
	    }

	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }

	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}

	      mask |= 1 << new_base;
	      count++;
	    }
	}
    }
  while (skip_past_comma (str) != FAIL);

  if (**str != '}')
    {
      inst.error = _("invalid register list");
      return FAIL;
    }

  (*str)++;

  range |= 2 * count;

  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > 16)
    abort ();

  /* Final test -- the registers must be consecutive.  */
  while (count--)
    {
      if ((mask & (1 << base_reg++)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
	}
    }

  inst.instruction = tempinst;
  return range;
}
d7913 2
a7914 1
  long range;
d7935 1
a7935 1
      || (range = vfp_sp_reg_list (&str, VFP_REG_Sd)) == FAIL)
d7941 1
d7943 1
a7943 1
  inst.instruction |= range;
d7950 2
a7951 1
  long range;
d7972 1
a7972 1
      || (range = vfp_dp_reg_list (&str)) == FAIL)
d7979 1
d7981 1
a7981 1
    range += 1;
d7983 1
a7983 1
  inst.instruction |= range;
d10022 1
a10022 1
  
d13643 1122
d14888 11
@


1.180
log
@Apply Paul Brook's patch to implement armv6k instructions
@
text
@d1341 5
d1357 9
@


1.179
log
@Use ISO C90 semantics
@
text
@d2503 35
d4354 1
a4354 1
   LDREX{<cond>} <Rd, [<Rn>]
d6673 17
d9846 1
a9846 1
  {"nop",        0xe1a00000, 3,  ARM_EXT_V1,       do_empty},
d10048 16
d11721 9
d12284 1
d12821 4
d12865 3
@


1.178
log
@(mav_reg_required_here): Allow REG_TYPE_CN as alternative when REG_TYPE_MVF,
REG_TYPE_MVD, REG_TYPE_MVFX or REG_TYPE_MVDX is expected.
@
text
@d712 4
a715 4
  const struct reg_entry *names;
  int max_regno;
  struct hash_control *htab;
  const char *expected;
a755 282
/* Functions called by parser.  */
/* ARM instructions.  */
static void do_arit		PARAMS ((char *));
static void do_cmp		PARAMS ((char *));
static void do_mov		PARAMS ((char *));
static void do_ldst		PARAMS ((char *));
static void do_ldstt		PARAMS ((char *));
static void do_ldmstm		PARAMS ((char *));
static void do_branch		PARAMS ((char *));
static void do_swi		PARAMS ((char *));

/* Pseudo Op codes.  */
static void do_adr		PARAMS ((char *));
static void do_adrl		PARAMS ((char *));
static void do_empty		PARAMS ((char *));

/* ARM v2.  */
static void do_mul		PARAMS ((char *));
static void do_mla		PARAMS ((char *));

/* ARM v2S.  */
static void do_swap		PARAMS ((char *));

/* ARM v3.  */
static void do_msr		PARAMS ((char *));
static void do_mrs		PARAMS ((char *));

/* ARM v3M.  */
static void do_mull		PARAMS ((char *));

/* ARM v4.  */
static void do_ldstv4		PARAMS ((char *));

/* ARM v4T.  */
static void do_bx               PARAMS ((char *));

/* ARM v5T.  */
static void do_blx		PARAMS ((char *));
static void do_bkpt		PARAMS ((char *));
static void do_clz		PARAMS ((char *));
static void do_lstc2		PARAMS ((char *));
static void do_cdp2		PARAMS ((char *));
static void do_co_reg2		PARAMS ((char *));

/* ARM v5TExP.  */
static void do_smla		PARAMS ((char *));
static void do_smlal		PARAMS ((char *));
static void do_smul		PARAMS ((char *));
static void do_qadd		PARAMS ((char *));

/* ARM v5TE.  */
static void do_pld		PARAMS ((char *));
static void do_ldrd		PARAMS ((char *));
static void do_co_reg2c		PARAMS ((char *));

/* ARM v5TEJ.  */
static void do_bxj		PARAMS ((char *));

/* ARM V6. */
static void do_cps              PARAMS ((char *));
static void do_cpsi             PARAMS ((char *));
static void do_ldrex            PARAMS ((char *));
static void do_pkhbt            PARAMS ((char *));
static void do_pkhtb            PARAMS ((char *));
static void do_qadd16           PARAMS ((char *));
static void do_rev              PARAMS ((char *));
static void do_rfe              PARAMS ((char *));
static void do_sxtah            PARAMS ((char *));
static void do_sxth             PARAMS ((char *));
static void do_setend           PARAMS ((char *));
static void do_smlad            PARAMS ((char *));
static void do_smlald           PARAMS ((char *));
static void do_smmul            PARAMS ((char *));
static void do_ssat             PARAMS ((char *));
static void do_usat             PARAMS ((char *));
static void do_srs              PARAMS ((char *));
static void do_ssat16           PARAMS ((char *));
static void do_usat16           PARAMS ((char *));
static void do_strex            PARAMS ((char *));
static void do_umaal            PARAMS ((char *));

static void do_cps_mode         PARAMS ((char **));
static void do_cps_flags        PARAMS ((char **, int));
static int do_endian_specifier  PARAMS ((char *));
static void do_pkh_core         PARAMS ((char *, int));
static void do_sat              PARAMS ((char **, int));
static void do_sat16            PARAMS ((char **, int));

/* Coprocessor Instructions.  */
static void do_cdp		PARAMS ((char *));
static void do_lstc		PARAMS ((char *));
static void do_co_reg		PARAMS ((char *));

/* FPA instructions.  */
static void do_fpa_ctrl		PARAMS ((char *));
static void do_fpa_ldst		PARAMS ((char *));
static void do_fpa_ldmstm	PARAMS ((char *));
static void do_fpa_dyadic	PARAMS ((char *));
static void do_fpa_monadic	PARAMS ((char *));
static void do_fpa_cmp		PARAMS ((char *));
static void do_fpa_from_reg	PARAMS ((char *));
static void do_fpa_to_reg	PARAMS ((char *));

/* VFP instructions.  */
static void do_vfp_sp_monadic	PARAMS ((char *));
static void do_vfp_dp_monadic	PARAMS ((char *));
static void do_vfp_sp_dyadic	PARAMS ((char *));
static void do_vfp_dp_dyadic	PARAMS ((char *));
static void do_vfp_reg_from_sp  PARAMS ((char *));
static void do_vfp_sp_from_reg  PARAMS ((char *));
static void do_vfp_reg2_from_sp2 PARAMS ((char *));
static void do_vfp_sp2_from_reg2 PARAMS ((char *));
static void do_vfp_reg_from_dp  PARAMS ((char *));
static void do_vfp_reg2_from_dp PARAMS ((char *));
static void do_vfp_dp_from_reg  PARAMS ((char *));
static void do_vfp_dp_from_reg2 PARAMS ((char *));
static void do_vfp_reg_from_ctrl PARAMS ((char *));
static void do_vfp_ctrl_from_reg PARAMS ((char *));
static void do_vfp_sp_ldst	PARAMS ((char *));
static void do_vfp_dp_ldst	PARAMS ((char *));
static void do_vfp_sp_ldstmia	PARAMS ((char *));
static void do_vfp_sp_ldstmdb	PARAMS ((char *));
static void do_vfp_dp_ldstmia	PARAMS ((char *));
static void do_vfp_dp_ldstmdb	PARAMS ((char *));
static void do_vfp_xp_ldstmia	PARAMS ((char *));
static void do_vfp_xp_ldstmdb	PARAMS ((char *));
static void do_vfp_sp_compare_z	PARAMS ((char *));
static void do_vfp_dp_compare_z	PARAMS ((char *));
static void do_vfp_dp_sp_cvt	PARAMS ((char *));
static void do_vfp_sp_dp_cvt	PARAMS ((char *));

/* XScale.  */
static void do_xsc_mia		PARAMS ((char *));
static void do_xsc_mar		PARAMS ((char *));
static void do_xsc_mra		PARAMS ((char *));

/* Maverick.  */
static void do_mav_binops	PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_binops_1a	PARAMS ((char *));
static void do_mav_binops_1b	PARAMS ((char *));
static void do_mav_binops_1c	PARAMS ((char *));
static void do_mav_binops_1d	PARAMS ((char *));
static void do_mav_binops_1e	PARAMS ((char *));
static void do_mav_binops_1f	PARAMS ((char *));
static void do_mav_binops_1g	PARAMS ((char *));
static void do_mav_binops_1h	PARAMS ((char *));
static void do_mav_binops_1i	PARAMS ((char *));
static void do_mav_binops_1j	PARAMS ((char *));
static void do_mav_binops_1k	PARAMS ((char *));
static void do_mav_binops_1l	PARAMS ((char *));
static void do_mav_binops_1m	PARAMS ((char *));
static void do_mav_binops_1n	PARAMS ((char *));
static void do_mav_binops_1o	PARAMS ((char *));
static void do_mav_binops_2a	PARAMS ((char *));
static void do_mav_binops_2b	PARAMS ((char *));
static void do_mav_binops_2c	PARAMS ((char *));
static void do_mav_binops_3a	PARAMS ((char *));
static void do_mav_binops_3b	PARAMS ((char *));
static void do_mav_binops_3c	PARAMS ((char *));
static void do_mav_binops_3d	PARAMS ((char *));
static void do_mav_triple	PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_triple_4a	PARAMS ((char *));
static void do_mav_triple_4b	PARAMS ((char *));
static void do_mav_triple_5a	PARAMS ((char *));
static void do_mav_triple_5b	PARAMS ((char *));
static void do_mav_triple_5c	PARAMS ((char *));
static void do_mav_triple_5d	PARAMS ((char *));
static void do_mav_triple_5e	PARAMS ((char *));
static void do_mav_triple_5f	PARAMS ((char *));
static void do_mav_triple_5g	PARAMS ((char *));
static void do_mav_triple_5h	PARAMS ((char *));
static void do_mav_quad		PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_quad_6a	PARAMS ((char *));
static void do_mav_quad_6b	PARAMS ((char *));
static void do_mav_dspsc_1	PARAMS ((char *));
static void do_mav_dspsc_2	PARAMS ((char *));
static void do_mav_shift	PARAMS ((char *, enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_shift_1	PARAMS ((char *));
static void do_mav_shift_2	PARAMS ((char *));
static void do_mav_ldst		PARAMS ((char *, enum arm_reg_type));
static void do_mav_ldst_1	PARAMS ((char *));
static void do_mav_ldst_2	PARAMS ((char *));
static void do_mav_ldst_3	PARAMS ((char *));
static void do_mav_ldst_4	PARAMS ((char *));

static int mav_reg_required_here	PARAMS ((char **, int,
						 enum arm_reg_type));
static int mav_parse_offset	PARAMS ((char **, int *));

static void fix_new_arm		PARAMS ((fragS *, int, short, expressionS *,
					 int, int));
static int arm_reg_parse	PARAMS ((char **, struct hash_control *));
static enum arm_reg_type arm_reg_parse_any PARAMS ((char *));
static const struct asm_psr * arm_psr_parse PARAMS ((char **));
static void symbol_locate	PARAMS ((symbolS *, const char *, segT, valueT,
					 fragS *));
static int add_to_lit_pool	PARAMS ((void));
static unsigned validate_immediate PARAMS ((unsigned));
static unsigned validate_immediate_twopart PARAMS ((unsigned int,
						    unsigned int *));
static int validate_offset_imm	PARAMS ((unsigned int, int));
static void opcode_select	PARAMS ((int));
static void end_of_line		PARAMS ((char *));
static int reg_required_here	PARAMS ((char **, int));
static int psr_required_here	PARAMS ((char **));
static int co_proc_number	PARAMS ((char **));
static int cp_opc_expr		PARAMS ((char **, int, int));
static int cp_reg_required_here	PARAMS ((char **, int));
static int fp_reg_required_here	PARAMS ((char **, int));
static int vfp_sp_reg_required_here PARAMS ((char **, enum vfp_sp_reg_pos));
static int vfp_dp_reg_required_here PARAMS ((char **, enum vfp_dp_reg_pos));
static void vfp_sp_ldstm	PARAMS ((char *, enum vfp_ldstm_type));
static void vfp_dp_ldstm	PARAMS ((char *, enum vfp_ldstm_type));
static long vfp_sp_reg_list	PARAMS ((char **, enum vfp_sp_reg_pos));
static long vfp_dp_reg_list	PARAMS ((char **));
static int vfp_psr_required_here PARAMS ((char **str));
static const struct vfp_reg *vfp_psr_parse PARAMS ((char **str));
static int cp_address_offset	PARAMS ((char **));
static int cp_address_required_here	PARAMS ((char **, int));
static int my_get_float_expression	PARAMS ((char **));
static int skip_past_comma	PARAMS ((char **));
static int walk_no_bignums	PARAMS ((symbolS *));
static int negate_data_op	PARAMS ((unsigned long *, unsigned long));
static int data_op2		PARAMS ((char **));
static int fp_op2		PARAMS ((char **));
static long reg_list		PARAMS ((char **));
static void thumb_load_store	PARAMS ((char *, int, int));
static int decode_shift		PARAMS ((char **, int));
static int ldst_extend		PARAMS ((char **));
static int ldst_extend_v4		PARAMS ((char **));
static void thumb_add_sub	PARAMS ((char *, int));
static void insert_reg		PARAMS ((const struct reg_entry *,
					 struct hash_control *));
static void thumb_shift		PARAMS ((char *, int));
static void thumb_mov_compare	PARAMS ((char *, int));
static void build_arm_ops_hsh	PARAMS ((void));
static void set_constant_flonums	PARAMS ((void));
static valueT md_chars_to_number	PARAMS ((char *, int));
static void build_reg_hsh	PARAMS ((struct reg_map *));
static void insert_reg_alias	PARAMS ((char *, int, struct hash_control *));
static int create_register_alias	PARAMS ((char *, char *));
static void output_inst		PARAMS ((const char *));
static int accum0_required_here PARAMS ((char **));
static int ld_mode_required_here PARAMS ((char **));
static void do_branch25         PARAMS ((char *));
static symbolS * find_real_start PARAMS ((symbolS *));
#ifdef OBJ_ELF
static bfd_reloc_code_real_type	arm_parse_reloc PARAMS ((void));
#endif

static int wreg_required_here   PARAMS ((char **, int, enum wreg_type));
static void do_iwmmxt_byte_addr PARAMS ((char *));
static void do_iwmmxt_tandc     PARAMS ((char *));
static void do_iwmmxt_tbcst     PARAMS ((char *));
static void do_iwmmxt_textrc    PARAMS ((char *));
static void do_iwmmxt_textrm    PARAMS ((char *));
static void do_iwmmxt_tinsr     PARAMS ((char *));
static void do_iwmmxt_tmcr      PARAMS ((char *));
static void do_iwmmxt_tmcrr     PARAMS ((char *));
static void do_iwmmxt_tmia      PARAMS ((char *));
static void do_iwmmxt_tmovmsk   PARAMS ((char *));
static void do_iwmmxt_tmrc      PARAMS ((char *));
static void do_iwmmxt_tmrrc     PARAMS ((char *));
static void do_iwmmxt_torc      PARAMS ((char *));
static void do_iwmmxt_waligni   PARAMS ((char *));
static void do_iwmmxt_wmov      PARAMS ((char *));
static void do_iwmmxt_word_addr PARAMS ((char *));
static void do_iwmmxt_wrwr      PARAMS ((char *));
static void do_iwmmxt_wrwrwcg   PARAMS ((char *));
static void do_iwmmxt_wrwrwr    PARAMS ((char *));
static void do_iwmmxt_wshufh    PARAMS ((char *));
static void do_iwmmxt_wzero     PARAMS ((char *));
static int cp_byte_address_offset         PARAMS ((char **));
static int cp_byte_address_required_here  PARAMS ((char **));

d794 1
a794 1
  void (* parms) PARAMS ((char *));
d797 13
a809 23
static const struct asm_opcode insns[] =
{
  /* Core ARM Instructions.  */
  {"and",        0xe0000000, 3,  ARM_EXT_V1,       do_arit},
  {"ands",       0xe0100000, 3,  ARM_EXT_V1,       do_arit},
  {"eor",        0xe0200000, 3,  ARM_EXT_V1,       do_arit},
  {"eors",       0xe0300000, 3,  ARM_EXT_V1,       do_arit},
  {"sub",        0xe0400000, 3,  ARM_EXT_V1,       do_arit},
  {"subs",       0xe0500000, 3,  ARM_EXT_V1,       do_arit},
  {"rsb",        0xe0600000, 3,  ARM_EXT_V1,       do_arit},
  {"rsbs",       0xe0700000, 3,  ARM_EXT_V1,       do_arit},
  {"add",        0xe0800000, 3,  ARM_EXT_V1,       do_arit},
  {"adds",       0xe0900000, 3,  ARM_EXT_V1,       do_arit},
  {"adc",        0xe0a00000, 3,  ARM_EXT_V1,       do_arit},
  {"adcs",       0xe0b00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbc",        0xe0c00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbcs",       0xe0d00000, 3,  ARM_EXT_V1,       do_arit},
  {"rsc",        0xe0e00000, 3,  ARM_EXT_V1,       do_arit},
  {"rscs",       0xe0f00000, 3,  ARM_EXT_V1,       do_arit},
  {"orr",        0xe1800000, 3,  ARM_EXT_V1,       do_arit},
  {"orrs",       0xe1900000, 3,  ARM_EXT_V1,       do_arit},
  {"bic",        0xe1c00000, 3,  ARM_EXT_V1,       do_arit},
  {"bics",       0xe1d00000, 3,  ARM_EXT_V1,       do_arit},
d811 1
a811 12
  {"tst",        0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tsts",       0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tstp",       0xe110f000, 3,  ARM_EXT_V1,       do_cmp},
  {"teq",        0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqs",       0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqp",       0xe130f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmp",        0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmps",       0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmpp",       0xe150f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmn",        0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmns",       0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmnp",       0xe170f000, 3,  ARM_EXT_V1,       do_cmp},
d813 17
a829 4
  {"mov",        0xe1a00000, 3,  ARM_EXT_V1,       do_mov},
  {"movs",       0xe1b00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvn",        0xe1e00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvns",       0xe1f00000, 3,  ARM_EXT_V1,       do_mov},
d831 5
a835 8
  {"ldr",        0xe4100000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrb",       0xe4500000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrt",       0xe4300000, 3,  ARM_EXT_V1,       do_ldstt},
  {"ldrbt",      0xe4700000, 3,  ARM_EXT_V1,       do_ldstt},
  {"str",        0xe4000000, 3,  ARM_EXT_V1,       do_ldst},
  {"strb",       0xe4400000, 3,  ARM_EXT_V1,       do_ldst},
  {"strt",       0xe4200000, 3,  ARM_EXT_V1,       do_ldstt},
  {"strbt",      0xe4600000, 3,  ARM_EXT_V1,       do_ldstt},
d837 11
a847 8
  {"stmia",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmib",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmda",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmdb",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfd",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfa",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmea",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmed",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},
d849 6
a854 8
  {"ldmia",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmib",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmda",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmdb",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfd",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfa",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmea",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmed",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},
d856 5
a860 9
  {"swi",        0xef000000, 3,  ARM_EXT_V1,       do_swi},
#ifdef TE_WINCE
  /* XXX This is the wrong place to do this.  Think multi-arch.  */
  {"bl",         0xeb000000, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xea000000, 1,  ARM_EXT_V1,       do_branch},
#else
  {"bl",         0xebfffffe, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xeafffffe, 1,  ARM_EXT_V1,       do_branch},
#endif
d862 15
a876 4
  /* Pseudo ops.  */
  {"adr",        0xe28f0000, 3,  ARM_EXT_V1,       do_adr},
  {"adrl",       0xe28f0000, 3,  ARM_EXT_V1,       do_adrl},
  {"nop",        0xe1a00000, 3,  ARM_EXT_V1,       do_empty},
d878 2
a879 5
  /* ARM 2 multiplies.  */
  {"mul",        0xe0000090, 3,  ARM_EXT_V2,       do_mul},
  {"muls",       0xe0100090, 3,  ARM_EXT_V2,       do_mul},
  {"mla",        0xe0200090, 3,  ARM_EXT_V2,       do_mla},
  {"mlas",       0xe0300090, 3,  ARM_EXT_V2,       do_mla},
d881 1
a881 8
  /* Generic coprocessor instructions.  */
  {"cdp",        0xee000000, 3,  ARM_EXT_V2,       do_cdp},
  {"ldc",        0xec100000, 3,  ARM_EXT_V2,       do_lstc},
  {"ldcl",       0xec500000, 3,  ARM_EXT_V2,       do_lstc},
  {"stc",        0xec000000, 3,  ARM_EXT_V2,       do_lstc},
  {"stcl",       0xec400000, 3,  ARM_EXT_V2,       do_lstc},
  {"mcr",        0xee000010, 3,  ARM_EXT_V2,       do_co_reg},
  {"mrc",        0xee100010, 3,  ARM_EXT_V2,       do_co_reg},
d883 4
a886 3
  /* ARM 3 - swp instructions.  */
  {"swp",        0xe1000090, 3,  ARM_EXT_V2S,      do_swap},
  {"swpb",       0xe1400090, 3,  ARM_EXT_V2S,      do_swap},
d888 2
a889 6
  /* ARM 6 Status register instructions.  */
  {"mrs",        0xe10f0000, 3,  ARM_EXT_V3,       do_mrs},
  {"msr",        0xe120f000, 3,  ARM_EXT_V3,       do_msr},
  /* ScottB: our code uses     0xe128f000 for msr.
     NickC:  but this is wrong because the bits 16 through 19 are
             handled by the PSR_xxx defines above.  */
d891 3
a893 9
  /* ARM 7M long multiplies.  */
  {"smull",      0xe0c00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smulls",     0xe0d00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umull",      0xe0800090, 5,  ARM_EXT_V3M,      do_mull},
  {"umulls",     0xe0900090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlal",      0xe0e00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlals",     0xe0f00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlal",      0xe0a00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlals",     0xe0b00090, 5,  ARM_EXT_V3M,      do_mull},
d895 3
a897 5
  /* ARM Architecture 4.  */
  {"ldrh",       0xe01000b0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsh",      0xe01000f0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsb",      0xe01000d0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"strh",       0xe00000b0, 3,  ARM_EXT_V4,       do_ldstv4},
d899 2
a900 4
  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.  */
  {"bx",         0xe12fff10, 2,  ARM_EXT_V4T | ARM_EXT_V5, do_bx},
d902 1
a902 13
  /*  ARM Architecture 5T.  */
  /* Note: blx has 2 variants, so the .value is set dynamically.
     Only one of the variants has conditional execution.  */
  {"blx",        0xe0000000, 3,  ARM_EXT_V5,       do_blx},
  {"clz",        0xe16f0f10, 3,  ARM_EXT_V5,       do_clz},
  {"bkpt",       0xe1200070, 0,  ARM_EXT_V5,       do_bkpt},
  {"ldc2",       0xfc100000, 0,  ARM_EXT_V5,       do_lstc2},
  {"ldc2l",      0xfc500000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2",       0xfc000000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2l",      0xfc400000, 0,  ARM_EXT_V5,       do_lstc2},
  {"cdp2",       0xfe000000, 0,  ARM_EXT_V5,       do_cdp2},
  {"mcr2",       0xfe000010, 0,  ARM_EXT_V5,       do_co_reg2},
  {"mrc2",       0xfe100010, 0,  ARM_EXT_V5,       do_co_reg2},
d904 4
a907 5
  /*  ARM Architecture 5TExP.  */
  {"smlabb",     0xe1000080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatb",     0xe10000a0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlabt",     0xe10000c0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatt",     0xe10000e0, 6,  ARM_EXT_V5ExP,    do_smla},
d909 4
a912 2
  {"smlawb",     0xe1200080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlawt",     0xe12000c0, 6,  ARM_EXT_V5ExP,    do_smla},
d914 2
a915 4
  {"smlalbb",    0xe1400080, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltb",    0xe14000a0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlalbt",    0xe14000c0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltt",    0xe14000e0, 7,  ARM_EXT_V5ExP,    do_smlal},
d917 1
a917 4
  {"smulbb",     0xe1600080, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultb",     0xe16000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulbt",     0xe16000c0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultt",     0xe16000e0, 6,  ARM_EXT_V5ExP,    do_smul},
d919 2
a920 2
  {"smulwb",     0xe12000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulwt",     0xe12000e0, 6,  ARM_EXT_V5ExP,    do_smul},
d922 3
a924 4
  {"qadd",       0xe1000050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdadd",      0xe1400050, 5,  ARM_EXT_V5ExP,    do_qadd},
  {"qsub",       0xe1200050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdsub",      0xe1600050, 5,  ARM_EXT_V5ExP,    do_qadd},
d926 4
a929 4
  /*  ARM Architecture 5TE.  */
  {"pld",        0xf450f000, 0,  ARM_EXT_V5E,      do_pld},
  {"ldrd",       0xe00000d0, 3,  ARM_EXT_V5E,      do_ldrd},
  {"strd",       0xe00000f0, 3,  ARM_EXT_V5E,      do_ldrd},
d931 5
a935 2
  {"mcrr",       0xec400000, 4,  ARM_EXT_V5E,      do_co_reg2c},
  {"mrrc",       0xec500000, 4,  ARM_EXT_V5E,      do_co_reg2c},
d937 9
a945 2
  /*  ARM Architecture 5TEJ.  */
  {"bxj",	 0xe12fff20, 3,  ARM_EXT_V5J,	   do_bxj},
d947 4
a950 100
  /*  ARM V6.  */
  { "cps",       0xf1020000, 0,  ARM_EXT_V6,       do_cps},
  { "cpsie",     0xf1080000, 0,  ARM_EXT_V6,       do_cpsi},
  { "cpsid",     0xf10C0000, 0,  ARM_EXT_V6,       do_cpsi},
  { "ldrex",     0xe1900f9f, 5,  ARM_EXT_V6,       do_ldrex},
  { "mcrr2",     0xfc400000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "mrrc2",     0xfc500000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "pkhbt",     0xe6800010, 5,  ARM_EXT_V6,       do_pkhbt},
  { "pkhtb",     0xe6800050, 5,  ARM_EXT_V6,       do_pkhtb},
  { "qadd16",    0xe6200f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "qadd8",     0xe6200f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "qaddsubx",  0xe6200f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "qsub16",    0xe6200f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "qsub8",     0xe6200ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "qsubaddx",  0xe6200f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "sadd16",    0xe6100f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "sadd8",     0xe6100f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "saddsubx",  0xe6100f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "shadd16",   0xe6300f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "shadd8",    0xe6300f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "shaddsubx", 0xe6300f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "shsub16",   0xe6300f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "shsub8",    0xe6300ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "shsubaddx", 0xe6300f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "ssub16",    0xe6100f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "ssub8",     0xe6100ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "ssubaddx",  0xe6100f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "uadd16",    0xe6500f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "uadd8",     0xe6500f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "uaddsubx",  0xe6500f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "uhadd16",   0xe6700f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhadd8",    0xe6700f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhaddsubx", 0xe6700f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uhsub16",   0xe6700f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhsub8",    0xe6700ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhsubaddx", 0xe6700f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqadd16",   0xe6600f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqadd8",    0xe6600f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqaddsubx", 0xe6600f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqsub16",   0xe6600f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqsub8",    0xe6600ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqsubaddx", 0xe6600f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "usub16",    0xe6500f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "usub8",     0xe6500ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "usubaddx",  0xe6500f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "rev",       0xe6bf0f30, 3,  ARM_EXT_V6,       do_rev},
  { "rev16",     0xe6bf0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "revsh",     0xe6ff0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "rfeia",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeib",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeda",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfedb",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefd",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefa",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeea",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeed",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "sxtah",     0xe6b00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxtab16",   0xe6800070, 7,  ARM_EXT_V6,       do_sxtah},
  { "sxtab",     0xe6a00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxth",      0xe6bf0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sxtb16",    0xe68f0070, 6,  ARM_EXT_V6,       do_sxth},
  { "sxtb",      0xe6af0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtah",     0xe6f00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxtab16",   0xe6c00070, 7,  ARM_EXT_V6,       do_sxtah},
  { "uxtab",     0xe6e00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxth",      0xe6ff0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtb16",    0xe6cf0070, 6,  ARM_EXT_V6,       do_sxth},
  { "uxtb",      0xe6ef0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sel",       0xe68000b0, 3,  ARM_EXT_V6,       do_qadd16},
  { "setend",    0xf1010000, 0,  ARM_EXT_V6,       do_setend},
  { "smlad",     0xe7000010, 5,  ARM_EXT_V6,       do_smlad},
  { "smladx",    0xe7000030, 6,  ARM_EXT_V6,       do_smlad},
  { "smlald",    0xe7400010, 6,  ARM_EXT_V6,       do_smlald},
  { "smlaldx",   0xe7400030, 7,  ARM_EXT_V6,       do_smlald},
  { "smlsd",     0xe7000050, 5,  ARM_EXT_V6,       do_smlad},
  { "smlsdx",    0xe7000070, 6,  ARM_EXT_V6,       do_smlad},
  { "smlsld",    0xe7400050, 6,  ARM_EXT_V6,       do_smlald},
  { "smlsldx",   0xe7400070, 7,  ARM_EXT_V6,       do_smlald},
  { "smmla",     0xe7500010, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlar",    0xe7500030, 6,  ARM_EXT_V6,       do_smlad},
  { "smmls",     0xe75000d0, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlsr",    0xe75000f0, 6,  ARM_EXT_V6,       do_smlad},
  { "smmul",     0xe750f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smmulr",    0xe750f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smuad",     0xe700f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smuadx",    0xe700f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smusd",     0xe700f050, 5,  ARM_EXT_V6,       do_smmul},
  { "smusdx",    0xe700f070, 6,  ARM_EXT_V6,       do_smmul},
  { "srsia",     0xf8cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsib",     0xf9cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsda",     0xf84d0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsdb",     0xf94d0500, 0,  ARM_EXT_V6,       do_srs},
  { "ssat",      0xe6a00010, 4,  ARM_EXT_V6,       do_ssat},
  { "ssat16",    0xe6a00f30, 6,  ARM_EXT_V6,       do_ssat16},
  { "strex",     0xe1800f90, 5,  ARM_EXT_V6,       do_strex},
  { "umaal",     0xe0400090, 5,  ARM_EXT_V6,       do_umaal},
  { "usad8",     0xe780f010, 5,  ARM_EXT_V6,       do_smmul},
  { "usada8",    0xe7800010, 6,  ARM_EXT_V6,       do_smlad},
  { "usat",      0xe6e00010, 4,  ARM_EXT_V6,       do_usat},
  { "usat16",    0xe6e00f30, 6,  ARM_EXT_V6,       do_usat16},
d952 1
a952 5
  /* Core FPA instruction set (V1).  */
  {"wfs",        0xee200110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfs",        0xee300110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"wfc",        0xee400110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfc",        0xee500110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
d954 2
a955 4
  {"ldfs",       0xec100100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfd",       0xec108100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfe",       0xec500100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfp",       0xec508100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
d957 10
a966 4
  {"stfs",       0xec000100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfd",       0xec008100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfe",       0xec400100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfp",       0xec408100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
d968 2
a969 12
  {"mvfs",       0xee008100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsp",      0xee008120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsm",      0xee008140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsz",      0xee008160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfd",       0xee008180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdp",      0xee0081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdm",      0xee0081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdz",      0xee0081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfe",       0xee088100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfep",      0xee088120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfem",      0xee088140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfez",      0xee088160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d971 4
a974 12
  {"mnfs",       0xee108100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsp",      0xee108120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsm",      0xee108140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsz",      0xee108160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfd",       0xee108180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdp",      0xee1081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdm",      0xee1081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdz",      0xee1081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfe",       0xee188100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfep",      0xee188120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfem",      0xee188140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfez",      0xee188160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d976 6
a981 12
  {"abss",       0xee208100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssp",      0xee208120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssm",      0xee208140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssz",      0xee208160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absd",       0xee208180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdp",      0xee2081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdm",      0xee2081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdz",      0xee2081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abse",       0xee288100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absep",      0xee288120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absem",      0xee288140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absez",      0xee288160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d983 2
a984 12
  {"rnds",       0xee308100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsp",      0xee308120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsm",      0xee308140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsz",      0xee308160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndd",       0xee308180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddp",      0xee3081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddm",      0xee3081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddz",      0xee3081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnde",       0xee388100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndep",      0xee388120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndem",      0xee388140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndez",      0xee388160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d986 6
a991 12
  {"sqts",       0xee408100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsp",      0xee408120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsm",      0xee408140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsz",      0xee408160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtd",       0xee408180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdp",      0xee4081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdm",      0xee4081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdz",      0xee4081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqte",       0xee488100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtep",      0xee488120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtem",      0xee488140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtez",      0xee488160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d993 1
a993 12
  {"logs",       0xee508100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsp",      0xee508120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsm",      0xee508140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsz",      0xee508160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logd",       0xee508180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdp",      0xee5081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdm",      0xee5081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdz",      0xee5081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"loge",       0xee588100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logep",      0xee588120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logem",      0xee588140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logez",      0xee588160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d995 16
a1010 12
  {"lgns",       0xee608100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsp",      0xee608120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsm",      0xee608140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsz",      0xee608160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnd",       0xee608180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndp",      0xee6081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndm",      0xee6081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndz",      0xee6081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgne",       0xee688100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnep",      0xee688120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnem",      0xee688140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnez",      0xee688160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1012 7
a1018 12
  {"exps",       0xee708100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsp",      0xee708120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsm",      0xee708140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsz",      0xee708160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expd",       0xee708180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdp",      0xee7081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdm",      0xee7081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee7081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expe",       0xee788100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expep",      0xee788120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expem",      0xee788140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee788160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1020 3
a1022 12
  {"sins",       0xee808100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsp",      0xee808120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsm",      0xee808140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsz",      0xee808160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sind",       0xee808180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindp",      0xee8081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindm",      0xee8081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindz",      0xee8081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sine",       0xee888100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinep",      0xee888120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinem",      0xee888140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinez",      0xee888160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1024 2
a1025 12
  {"coss",       0xee908100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossp",      0xee908120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossm",      0xee908140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossz",      0xee908160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosd",       0xee908180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdp",      0xee9081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdm",      0xee9081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdz",      0xee9081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cose",       0xee988100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosep",      0xee988120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosem",      0xee988140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosez",      0xee988160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1027 5
a1031 12
  {"tans",       0xeea08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansp",      0xeea08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansm",      0xeea08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansz",      0xeea08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tand",       0xeea08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandp",      0xeea081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandm",      0xeea081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandz",      0xeea081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tane",       0xeea88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanep",      0xeea88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanem",      0xeea88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanez",      0xeea88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1033 1
a1033 12
  {"asns",       0xeeb08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsp",      0xeeb08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsm",      0xeeb08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsz",      0xeeb08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnd",       0xeeb08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndp",      0xeeb081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndm",      0xeeb081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndz",      0xeeb081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asne",       0xeeb88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnep",      0xeeb88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnem",      0xeeb88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnez",      0xeeb88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1035 10
a1044 12
  {"acss",       0xeec08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssp",      0xeec08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssm",      0xeec08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssz",      0xeec08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsd",       0xeec08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdp",      0xeec081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdm",      0xeec081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdz",      0xeec081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acse",       0xeec88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsep",      0xeec88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsem",      0xeec88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsez",      0xeec88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1046 10
a1055 12
  {"atns",       0xeed08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsp",      0xeed08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsm",      0xeed08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsz",      0xeed08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnd",       0xeed08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndp",      0xeed081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndm",      0xeed081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndz",      0xeed081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atne",       0xeed88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnep",      0xeed88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnem",      0xeed88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnez",      0xeed88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1057 8
a1064 12
  {"urds",       0xeee08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsp",      0xeee08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsm",      0xeee08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsz",      0xeee08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdd",       0xeee08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddp",      0xeee081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddm",      0xeee081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddz",      0xeee081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urde",       0xeee88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdep",      0xeee88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdem",      0xeee88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdez",      0xeee88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1066 3
a1068 12
  {"nrms",       0xeef08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsp",      0xeef08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsm",      0xeef08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsz",      0xeef08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmd",       0xeef08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdp",      0xeef081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdm",      0xeef081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdz",      0xeef081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrme",       0xeef88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmep",      0xeef88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmem",      0xeef88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmez",      0xeef88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
d1070 3
a1072 12
  {"adfs",       0xee000100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsp",      0xee000120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsm",      0xee000140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsz",      0xee000160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfd",       0xee000180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdp",      0xee0001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdm",      0xee0001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdz",      0xee0001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfe",       0xee080100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfep",      0xee080120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfem",      0xee080140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfez",      0xee080160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1074 2
a1075 12
  {"sufs",       0xee200100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsp",      0xee200120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsm",      0xee200140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsz",      0xee200160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufd",       0xee200180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdp",      0xee2001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdm",      0xee2001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdz",      0xee2001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufe",       0xee280100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufep",      0xee280120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufem",      0xee280140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufez",      0xee280160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1077 2
a1078 12
  {"rsfs",       0xee300100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsp",      0xee300120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsm",      0xee300140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsz",      0xee300160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfd",       0xee300180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdp",      0xee3001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdm",      0xee3001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdz",      0xee3001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfe",       0xee380100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfep",      0xee380120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfem",      0xee380140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfez",      0xee380160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1080 9
a1088 12
  {"mufs",       0xee100100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsp",      0xee100120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsm",      0xee100140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsz",      0xee100160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufd",       0xee100180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdp",      0xee1001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdm",      0xee1001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdz",      0xee1001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufe",       0xee180100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufep",      0xee180120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufem",      0xee180140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufez",      0xee180160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1090 7
a1096 12
  {"dvfs",       0xee400100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsp",      0xee400120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsm",      0xee400140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsz",      0xee400160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfd",       0xee400180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdp",      0xee4001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdm",      0xee4001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdz",      0xee4001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfe",       0xee480100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfep",      0xee480120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfem",      0xee480140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfez",      0xee480160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1098 4
a1101 12
  {"rdfs",       0xee500100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsp",      0xee500120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsm",      0xee500140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsz",      0xee500160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfd",       0xee500180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdp",      0xee5001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdm",      0xee5001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdz",      0xee5001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfe",       0xee580100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfep",      0xee580120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfem",      0xee580140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfez",      0xee580160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1103 1
a1103 12
  {"pows",       0xee600100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsp",      0xee600120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsm",      0xee600140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsz",      0xee600160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powd",       0xee600180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdp",      0xee6001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdm",      0xee6001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdz",      0xee6001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powe",       0xee680100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powep",      0xee680120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powem",      0xee680140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powez",      0xee680160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1105 3
a1107 12
  {"rpws",       0xee700100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsp",      0xee700120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsm",      0xee700140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsz",      0xee700160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwd",       0xee700180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdp",      0xee7001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdm",      0xee7001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdz",      0xee7001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwe",       0xee780100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwep",      0xee780120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwem",      0xee780140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwez",      0xee780160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1109 1
a1109 12
  {"rmfs",       0xee800100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsp",      0xee800120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsm",      0xee800140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsz",      0xee800160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfd",       0xee800180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdp",      0xee8001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdm",      0xee8001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdz",      0xee8001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfe",       0xee880100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfep",      0xee880120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfem",      0xee880140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfez",      0xee880160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1111 3
a1113 12
  {"fmls",       0xee900100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsp",      0xee900120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsm",      0xee900140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsz",      0xee900160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmld",       0xee900180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldp",      0xee9001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldm",      0xee9001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldz",      0xee9001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmle",       0xee980100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlep",      0xee980120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlem",      0xee980140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlez",      0xee980160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1115 3
a1117 12
  {"fdvs",       0xeea00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsp",      0xeea00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsm",      0xeea00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsz",      0xeea00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvd",       0xeea00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdp",      0xeea001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdm",      0xeea001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdz",      0xeea001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdve",       0xeea80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvep",      0xeea80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvem",      0xeea80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvez",      0xeea80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1119 1
a1119 12
  {"frds",       0xeeb00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsp",      0xeeb00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsm",      0xeeb00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsz",      0xeeb00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdd",       0xeeb00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddp",      0xeeb001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddm",      0xeeb001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddz",      0xeeb001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frde",       0xeeb80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdep",      0xeeb80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdem",      0xeeb80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdez",      0xeeb80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1121 1
a1121 12
  {"pols",       0xeec00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsp",      0xeec00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsm",      0xeec00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsz",      0xeec00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pold",       0xeec00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldp",      0xeec001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldm",      0xeec001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldz",      0xeec001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pole",       0xeec80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polep",      0xeec80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polem",      0xeec80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polez",      0xeec80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
d1123 3
a1125 9
  {"cmf",        0xee90f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cmfe",       0xeed0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnf",        0xeeb0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  /* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should
     not be an optional suffix, but part of the instruction.  To be
     compatible, we accept either.  */
  {"cmfe",       0xeed0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},
d1127 4
a1130 12
  {"flts",       0xee000110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsp",      0xee000130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsm",      0xee000150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsz",      0xee000170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltd",       0xee000190, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdp",      0xee0001b0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdm",      0xee0001d0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdz",      0xee0001f0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"flte",       0xee080110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltep",      0xee080130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltem",      0xee080150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltez",      0xee080170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
d1132 2
a1133 18
  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
  {"fix",        0xee100110, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixp",       0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixm",       0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixz",       0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixep",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixem",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixez",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
d1135 5
a1139 7
  /* Instructions that were new with the real FPA, call them V2.  */
  {"lfm",        0xec100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmfd",      0xec900200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmea",      0xed100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfm",        0xec000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmfd",      0xed000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmea",      0xec800200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
d1141 1
a1141 14
  /* VFP V1xD (single precision).  */
  /* Moves and type conversions.  */
  {"fcpys",   0xeeb00a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrs",    0xee100a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_sp},
  {"fmsr",    0xee000a10, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_from_reg},
  {"fmstat",  0xeef1fa10, 6, FPU_VFP_EXT_V1xD, do_empty},
  {"fsitos",  0xeeb80ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fuitos",  0xeeb80a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosis",  0xeebd0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosizs", 0xeebd0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouis",  0xeebc0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouizs", 0xeebc0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrx",    0xeef00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_ctrl},
  {"fmxr",    0xeee00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_ctrl_from_reg},
d1143 3
a1145 19
  /* Memory operations.  */
  {"flds",    0xed100a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fsts",    0xed000a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fldmias", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmfds", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmdbs", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmeas", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmiax", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmfdx", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmdbx", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fldmeax", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmias", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmeas", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmdbs", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmfds", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmiax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmeax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmdbx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmfdx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
d1147 2
a1148 4
  /* Monadic operations.  */
  {"fabss",   0xeeb00ac0, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fnegs",   0xeeb10a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fsqrts",  0xeeb10ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
d1150 3
a1152 10
  /* Dyadic operations.  */
  {"fadds",   0xee300a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fsubs",   0xee300a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmuls",   0xee200a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fdivs",   0xee800a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmacs",   0xee000a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmscs",   0xee100a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmuls",  0xee200a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmacs",  0xee000a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmscs",  0xee100a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
d1154 6
a1159 5
  /* Comparisons.  */
  {"fcmps",   0xeeb40a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpzs",  0xeeb50a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},
  {"fcmpes",  0xeeb40ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpezs", 0xeeb50ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},
d1161 19
a1179 880
  /* VFP V1 (Double precision).  */
  /* Moves and type conversions.  */
  {"fcpyd",   0xeeb00b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcvtds",  0xeeb70ac0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fcvtsd",  0xeeb70bc0, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"fmdhr",   0xee200b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmdlr",   0xee000b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmrdh",   0xee300b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fmrdl",   0xee100b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fsitod",  0xeeb80bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fuitod",  0xeeb80b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"ftosid",  0xeebd0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftosizd", 0xeebd0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouid",  0xeebc0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouizd", 0xeebc0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},

  /* Memory operations.  */
  {"fldd",    0xed100b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fstd",    0xed000b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fldmiad", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmfdd", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmdbd", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fldmead", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmiad", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmead", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmdbd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmfdd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},

  /* Monadic operations.  */
  {"fabsd",   0xeeb00bc0, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fnegd",   0xeeb10b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fsqrtd",  0xeeb10bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},

  /* Dyadic operations.  */
  {"faddd",   0xee300b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fsubd",   0xee300b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmuld",   0xee200b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fdivd",   0xee800b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmacd",   0xee000b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmscd",   0xee100b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmuld",  0xee200b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmacd",  0xee000b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmscd",  0xee100b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},

  /* Comparisons.  */
  {"fcmpd",   0xeeb40b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpzd",  0xeeb50b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},
  {"fcmped",  0xeeb40bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpezd", 0xeeb50bc0, 7, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},

  /* VFP V2.  */
  {"fmsrr",   0xec400a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp2_from_reg2},
  {"fmrrs",   0xec500a10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_sp2},
  {"fmdrr",   0xec400b10, 5, FPU_VFP_EXT_V2,   do_vfp_dp_from_reg2},
  {"fmrrd",   0xec500b10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_dp},

  /* Intel XScale extensions to ARM V5 ISA.  (All use CP0).  */
  {"mia",        0xee200010, 3,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miaph",      0xee280010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabb",      0xee2c0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabt",      0xee2d0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatb",      0xee2e0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatt",      0xee2f0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"mar",        0xec400000, 3,  ARM_CEXT_XSCALE,   do_xsc_mar},
  {"mra",        0xec500000, 3,  ARM_CEXT_XSCALE,   do_xsc_mra},

  /* Intel Wireless MMX technology instructions.  */
  {"tandcb",     0xee130130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandch",     0xee530130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandcw",     0xee930130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tbcstb",     0xee400010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcsth",     0xee400050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcstw",     0xee400090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"textrcb",    0xee130170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrch",    0xee530170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrcw",    0xee930170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrmub",   0xee100070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuh",   0xee500070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuw",   0xee900070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsb",   0xee100078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsh",   0xee500078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsw",   0xee900078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"tinsrb",     0xee600010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrh",     0xee600050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrw",     0xee600090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tmcr",       0xee000110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmcr},
  {"tmcrr",      0xec400000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmcrr},
  {"tmia",       0xee200010, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiaph",     0xee280010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabb",     0xee2c0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabt",     0xee2d0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatb",     0xee2e0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatt",     0xee2f0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmovmskb",   0xee100030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskh",   0xee500030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskw",   0xee900030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmrc",       0xee100110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmrc},
  {"tmrrc",      0xec500000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmrrc},
  {"torcb",      0xee130150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torch",      0xee530150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torcw",      0xee930150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"waccb",      0xee0001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wacch",      0xee4001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waccw",      0xee8001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waddbss",    0xee300180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddb",      0xee000180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddbus",    0xee100180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhss",    0xee700180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddh",      0xee400180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhus",    0xee500180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwss",    0xeeb00180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddw",      0xee800180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwus",    0xee900180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waligni",    0xee000020, 7, ARM_CEXT_IWMMXT, do_iwmmxt_waligni},
  {"walignr0",   0xee800020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr1",   0xee900020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr2",   0xeea00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr3",   0xeeb00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wand",       0xee200000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wandn",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2b",     0xee800000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2br",    0xee900000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2h",     0xeec00000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2hr",    0xeed00000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqb",    0xee000060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqh",    0xee400060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqw",    0xee800060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtub",   0xee100060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuh",   0xee500060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuw",   0xee900060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsb",   0xee300060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsh",   0xee700060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsw",   0xeeb00060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wldrb",      0xec100000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrh",      0xec100100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrw",      0xec100200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wldrd",      0xec100300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wmacs",      0xee600100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacsz",     0xee700100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacu",      0xee400100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacuz",     0xee500100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmadds",     0xeea00100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaddu",     0xee800100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsb",     0xee200160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsh",     0xee600160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsw",     0xeea00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxub",     0xee000160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuh",     0xee400160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuw",     0xee800160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsb",     0xee300160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsh",     0xee700160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsw",     0xeeb00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminub",     0xee100160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuh",     0xee500160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuw",     0xee900160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmov",       0xee000000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wmov},
  {"wmulsm",     0xee300100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulsl",     0xee200100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulum",     0xee100100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulul",     0xee000100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wor",        0xee000000, 3, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhss",   0xee700080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhus",   0xee500080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwss",   0xeeb00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwus",   0xee900080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdss",   0xeef00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdus",   0xeed00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorh",      0xee700040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorhg",     0xee700148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrorw",      0xeeb00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorwg",     0xeeb00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrord",      0xeef00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrordg",     0xeef00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsadb",      0xee000120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadbz",     0xee100120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadh",      0xee400120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadhz",     0xee500120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wshufh",     0xee0001e0, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wshufh},
  {"wsllh",      0xee500040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllhg",     0xee500148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsllw",      0xee900040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllwg",     0xee900148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wslld",      0xeed00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wslldg",     0xeed00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrah",      0xee400040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrahg",     0xee400148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsraw",      0xee800040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrawg",     0xee800148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrad",      0xeec00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsradg",     0xeec00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlh",      0xee600040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlhg",     0xee600148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlw",      0xeea00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlwg",     0xeea00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrld",      0xeee00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrldg",     0xeee00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wstrb",      0xec000000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrh",      0xec000100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrw",      0xec000200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wstrd",      0xec000300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wsubbss",    0xee3001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubb",      0xee0001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubbus",    0xee1001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhss",    0xee7001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubh",      0xee4001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhus",    0xee5001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwss",    0xeeb001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubw",      0xee8001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwus",    0xee9001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckehub", 0xee0000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuh", 0xee4000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuw", 0xee8000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsb", 0xee2000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsh", 0xee6000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsw", 0xeea000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckihb",  0xee1000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihh",  0xee5000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihw",  0xee9000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckelub", 0xee0000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluh", 0xee4000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluw", 0xee8000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsb", 0xee2000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsh", 0xee6000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsw", 0xeea000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckilb",  0xee1000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilh",  0xee5000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilw",  0xee9000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wxor",       0xee100000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wzero",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wzero},

  /* Cirrus Maverick instructions.  */
  {"cfldrs",     0xec100400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfldrd",     0xec500400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfldr32",    0xec100500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfldr64",    0xec500500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfstrs",     0xec000400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfstrd",     0xec400400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfstr32",    0xec000500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfstr64",    0xec400500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfmvsr",     0xee000450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_2a},
  {"cfmvrs",     0xee100450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1a},
  {"cfmvdlr",    0xee000410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdl",    0xee100410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmvdhr",    0xee000430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdh",    0xee100430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmv64lr",   0xee000510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64l",   0xee100510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmv64hr",   0xee000530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64h",   0xee100530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmval32",   0xee200440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32al",   0xee100440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvam32",   0xee200460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32am",   0xee100460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvah32",   0xee200480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32ah",   0xee100480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva32",    0xee2004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32a",    0xee1004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva64",    0xee2004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3c},
  {"cfmv64a",    0xee1004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3d},
  {"cfmvsc32",   0xee2004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_1},
  {"cfmv32sc",   0xee1004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_2},
  {"cfcpys",     0xee000400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfcpyd",     0xee000420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfcvtsd",    0xee000460, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1f},
  {"cfcvtds",    0xee000440, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1g},
  {"cfcvt32s",   0xee000480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1h},
  {"cfcvt32d",   0xee0004a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1i},
  {"cfcvt64s",   0xee0004c0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1j},
  {"cfcvt64d",   0xee0004e0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1k},
  {"cfcvts32",   0xee100580, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cfcvtd32",   0xee1005a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cftruncs32", 0xee1005c0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cftruncd32", 0xee1005e0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cfrshl32",   0xee000550, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4a},
  {"cfrshl64",   0xee000570, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4b},
  {"cfsh32",     0xee000500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_1},
  {"cfsh64",     0xee200500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_2},
  {"cfcmps",     0xee100490, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5a},
  {"cfcmpd",     0xee1004b0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5b},
  {"cfcmp32",    0xee100590, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5c},
  {"cfcmp64",    0xee1005b0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5d},
  {"cfabss",     0xee300400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfabsd",     0xee300420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfnegs",     0xee300440, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfnegd",     0xee300460, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfadds",     0xee300480, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfaddd",     0xee3004a0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfsubs",     0xee3004c0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfsubd",     0xee3004e0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfmuls",     0xee100400, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfmuld",     0xee100420, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfabs32",    0xee300500, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfabs64",    0xee300520, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfneg32",    0xee300540, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfneg64",    0xee300560, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfadd32",    0xee300580, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfadd64",    0xee3005a0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfsub32",    0xee3005c0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfsub64",    0xee3005e0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmul32",    0xee100500, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmul64",    0xee100520, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmac32",    0xee100540, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmsc32",    0xee100560, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmadd32",   0xee000600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmsub32",   0xee100600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmadda32",  0xee200600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
  {"cfmsuba32",  0xee300600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
};

/* Defines for various bits that we will want to toggle.  */
#define INST_IMMEDIATE	0x02000000
#define OFFSET_REG	0x02000000
#define HWOFFSET_IMM    0x00400000
#define SHIFT_BY_REG	0x00000010
#define PRE_INDEX	0x01000000
#define INDEX_UP	0x00800000
#define WRITE_BACK	0x00200000
#define LDM_TYPE_2_OR_3	0x00400000

#define LITERAL_MASK	0xf000f000
#define OPCODE_MASK	0xfe1fffff
#define V4_STR_BIT	0x00000020

#define DATA_OP_SHIFT	21

/* Codes to distinguish the arithmetic instructions.  */
#define OPCODE_AND	0
#define OPCODE_EOR	1
#define OPCODE_SUB	2
#define OPCODE_RSB	3
#define OPCODE_ADD	4
#define OPCODE_ADC	5
#define OPCODE_SBC	6
#define OPCODE_RSC	7
#define OPCODE_TST	8
#define OPCODE_TEQ	9
#define OPCODE_CMP	10
#define OPCODE_CMN	11
#define OPCODE_ORR	12
#define OPCODE_MOV	13
#define OPCODE_BIC	14
#define OPCODE_MVN	15

/* Thumb v1 (ARMv4T).  */
static void do_t_nop		PARAMS ((char *));
static void do_t_arit		PARAMS ((char *));
static void do_t_add		PARAMS ((char *));
static void do_t_asr		PARAMS ((char *));
static void do_t_branch9	PARAMS ((char *));
static void do_t_branch12	PARAMS ((char *));
static void do_t_branch23	PARAMS ((char *));
static void do_t_bx		PARAMS ((char *));
static void do_t_compare	PARAMS ((char *));
static void do_t_ldmstm		PARAMS ((char *));
static void do_t_ldr		PARAMS ((char *));
static void do_t_ldrb		PARAMS ((char *));
static void do_t_ldrh		PARAMS ((char *));
static void do_t_lds		PARAMS ((char *));
static void do_t_lsl		PARAMS ((char *));
static void do_t_lsr		PARAMS ((char *));
static void do_t_mov		PARAMS ((char *));
static void do_t_push_pop	PARAMS ((char *));
static void do_t_str		PARAMS ((char *));
static void do_t_strb		PARAMS ((char *));
static void do_t_strh		PARAMS ((char *));
static void do_t_sub		PARAMS ((char *));
static void do_t_swi		PARAMS ((char *));
static void do_t_adr		PARAMS ((char *));

/* Thumb v2 (ARMv5T).  */
static void do_t_blx		PARAMS ((char *));
static void do_t_bkpt		PARAMS ((char *));

/* ARM V6.  */
static void do_t_cps            PARAMS ((char *));
static void do_t_cpy            PARAMS ((char *));
static void do_t_setend         PARAMS ((char *));;

#define T_OPCODE_MUL 0x4340
#define T_OPCODE_TST 0x4200
#define T_OPCODE_CMN 0x42c0
#define T_OPCODE_NEG 0x4240
#define T_OPCODE_MVN 0x43c0

#define T_OPCODE_ADD_R3	0x1800
#define T_OPCODE_SUB_R3 0x1a00
#define T_OPCODE_ADD_HI 0x4400
#define T_OPCODE_ADD_ST 0xb000
#define T_OPCODE_SUB_ST 0xb080
#define T_OPCODE_ADD_SP 0xa800
#define T_OPCODE_ADD_PC 0xa000
#define T_OPCODE_ADD_I8 0x3000
#define T_OPCODE_SUB_I8 0x3800
#define T_OPCODE_ADD_I3 0x1c00
#define T_OPCODE_SUB_I3 0x1e00

#define T_OPCODE_ASR_R	0x4100
#define T_OPCODE_LSL_R	0x4080
#define T_OPCODE_LSR_R  0x40c0
#define T_OPCODE_ASR_I	0x1000
#define T_OPCODE_LSL_I	0x0000
#define T_OPCODE_LSR_I	0x0800

#define T_OPCODE_MOV_I8	0x2000
#define T_OPCODE_CMP_I8 0x2800
#define T_OPCODE_CMP_LR 0x4280
#define T_OPCODE_MOV_HR 0x4600
#define T_OPCODE_CMP_HR 0x4500

#define T_OPCODE_LDR_PC 0x4800
#define T_OPCODE_LDR_SP 0x9800
#define T_OPCODE_STR_SP 0x9000
#define T_OPCODE_LDR_IW 0x6800
#define T_OPCODE_STR_IW 0x6000
#define T_OPCODE_LDR_IH 0x8800
#define T_OPCODE_STR_IH 0x8000
#define T_OPCODE_LDR_IB 0x7800
#define T_OPCODE_STR_IB 0x7000
#define T_OPCODE_LDR_RW 0x5800
#define T_OPCODE_STR_RW 0x5000
#define T_OPCODE_LDR_RH 0x5a00
#define T_OPCODE_STR_RH 0x5200
#define T_OPCODE_LDR_RB 0x5c00
#define T_OPCODE_STR_RB 0x5400

#define T_OPCODE_PUSH	0xb400
#define T_OPCODE_POP	0xbc00

#define T_OPCODE_BRANCH 0xe7fe

static int thumb_reg		PARAMS ((char ** str, int hi_lo));

#define THUMB_SIZE	2	/* Size of thumb instruction.  */
#define THUMB_REG_LO	0x1
#define THUMB_REG_HI	0x2
#define THUMB_REG_ANY	0x3

#define THUMB_H1	0x0080
#define THUMB_H2	0x0040

#define THUMB_ASR 0
#define THUMB_LSL 1
#define THUMB_LSR 2

#define THUMB_MOVE 0
#define THUMB_COMPARE 1
#define THUMB_CPY 2

#define THUMB_LOAD 0
#define THUMB_STORE 1

#define THUMB_PP_PC_LR 0x0100

/* These three are used for immediate shifts, do not alter.  */
#define THUMB_WORD 2
#define THUMB_HALFWORD 1
#define THUMB_BYTE 0

struct thumb_opcode
{
  /* Basic string to match.  */
  const char * template;

  /* Basic instruction code.  */
  unsigned long value;

  int size;

  /* Which CPU variants this exists for.  */
  unsigned long variant;

  /* Function to call to parse args.  */
  void (* parms) PARAMS ((char *));
};

static const struct thumb_opcode tinsns[] =
{
  /* Thumb v1 (ARMv4T).  */
  {"adc",	0x4140,		2,	ARM_EXT_V4T, do_t_arit},
  {"add",	0x0000,		2,	ARM_EXT_V4T, do_t_add},
  {"and",	0x4000,		2,	ARM_EXT_V4T, do_t_arit},
  {"asr",	0x0000,		2,	ARM_EXT_V4T, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_EXT_V4T, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_EXT_V4T, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_EXT_V4T, do_t_branch23},
  {"bx",	0x4700,		2,	ARM_EXT_V4T, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_EXT_V4T, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_EXT_V4T, do_t_compare},
  {"eor",	0x4040,		2,	ARM_EXT_V4T, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_EXT_V4T, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_EXT_V4T, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_EXT_V4T, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_EXT_V4T, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_EXT_V4T, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_EXT_V4T, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_EXT_V4T, do_t_arit},
  {"orr",	0x4300,		2,	ARM_EXT_V4T, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_EXT_V4T, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_EXT_V4T, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_EXT_V4T, do_t_str},
  {"strb",	0x0000,		2,	ARM_EXT_V4T, do_t_strb},
  {"strh",	0x0000,		2,	ARM_EXT_V4T, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_EXT_V4T, do_t_swi},
  {"sub",	0x0000,		2,	ARM_EXT_V4T, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_EXT_V4T, do_t_arit},
  /* Pseudo ops:  */
  {"adr",       0x0000,         2,      ARM_EXT_V4T, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_EXT_V4T, do_t_nop},      /* mov r8,r8  */
  /* Thumb v2 (ARMv5T).  */
  {"blx",	0,		0,	ARM_EXT_V5T, do_t_blx},
  {"bkpt",	0xbe00,		2,	ARM_EXT_V5T, do_t_bkpt},

  /* ARM V6.  */
  {"cpsie",	0xb660,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpsid",     0xb670,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpy",	0x4600,		2,	ARM_EXT_V6,  do_t_cpy},
  {"rev",	0xba00,		2,	ARM_EXT_V6,  do_t_arit},
  {"rev16",	0xba40,		2,	ARM_EXT_V6,  do_t_arit},
  {"revsh",	0xbac0,		2,	ARM_EXT_V6,  do_t_arit},
  {"setend",	0xb650,		2,	ARM_EXT_V6,  do_t_setend},
  {"sxth",	0xb200,		2,	ARM_EXT_V6,  do_t_arit},
  {"sxtb",	0xb240,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxth",	0xb280,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxtb",	0xb2c0,		2,	ARM_EXT_V6,  do_t_arit},
};

#define BAD_ARGS 	_("bad arguments to instruction")
#define BAD_PC 		_("r15 not allowed here")
#define BAD_COND 	_("instruction is not conditional")
#define ERR_NO_ACCUM	_("acc0 expected")

static struct hash_control * arm_ops_hsh   = NULL;
static struct hash_control * arm_tops_hsh  = NULL;
static struct hash_control * arm_cond_hsh  = NULL;
static struct hash_control * arm_shift_hsh = NULL;
static struct hash_control * arm_psr_hsh   = NULL;

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */

static void s_req PARAMS ((int));
static void s_unreq PARAMS ((int));
static void s_align PARAMS ((int));
static void s_bss PARAMS ((int));
static void s_even PARAMS ((int));
static void s_ltorg PARAMS ((int));
static void s_arm PARAMS ((int));
static void s_thumb PARAMS ((int));
static void s_code PARAMS ((int));
static void s_force_thumb PARAMS ((int));
static void s_thumb_func PARAMS ((int));
static void s_thumb_set PARAMS ((int));
#ifdef OBJ_ELF
static void s_arm_elf_cons PARAMS ((int));
static void s_arm_rel31 (int nbytes);
#endif

static int my_get_expression PARAMS ((expressionS *, char **));

const pseudo_typeS md_pseudo_table[] =
{
  /* Never called because '.req' does not start a line.  */
  { "req",         s_req,         0 },
  { "unreq",       s_unreq,       0 },
  { "bss",         s_bss,         0 },
  { "align",       s_align,       0 },
  { "arm",         s_arm,         0 },
  { "thumb",       s_thumb,       0 },
  { "code",        s_code,        0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb_set",   s_thumb_set,   0 },
  { "even",        s_even,        0 },
  { "ltorg",       s_ltorg,       0 },
  { "pool",        s_ltorg,       0 },
#ifdef OBJ_ELF
  { "word",        s_arm_elf_cons, 4 },
  { "long",        s_arm_elf_cons, 4 },
  { "rel31",       s_arm_rel31,   0 },
#else
  { "word",        cons, 4},
#endif
  { "extend",      float_cons, 'x' },
  { "ldouble",     float_cons, 'x' },
  { "packed",      float_cons, 'p' },
  { 0, 0, 0 }
};

/* Other internal functions.  */
static int arm_parse_extension PARAMS ((char *, int *));
static int arm_parse_cpu PARAMS ((char *));
static int arm_parse_arch PARAMS ((char *));
static int arm_parse_fpu PARAMS ((char *));
static int arm_parse_float_abi PARAMS ((char *));
#ifdef OBJ_ELF
static int arm_parse_eabi PARAMS ((char *));
#endif
#if 0 /* Suppressed - for now.  */
#if defined OBJ_COFF || defined OBJ_ELF
static void arm_add_note PARAMS ((const char *, const char *, unsigned int));
#endif
#endif

/* Stuff needed to resolve the label ambiguity
   As:
     ...
     label:   <insn>
   may differ from:
     ...
     label:
              <insn>
*/

symbolS *  last_label_seen;
static int label_is_thumb_function_name = FALSE;

/* Literal Pool stuff.  */

#define MAX_LITERAL_POOL_SIZE 1024

/* Literal pool structure.  Held on a per-section
   and per-sub-section basis.  */
typedef struct literal_pool
{
  expressionS    literals [MAX_LITERAL_POOL_SIZE];
  unsigned int   next_free_entry;
  unsigned int   id;
  symbolS *      symbol;
  segT           section;
  subsegT        sub_section;
  struct literal_pool * next;
} literal_pool;

/* Pointer to a linked list of literal pools.  */
literal_pool * list_of_pools = NULL;

static literal_pool * find_literal_pool PARAMS ((void));
static literal_pool * find_or_make_literal_pool PARAMS ((void));

static literal_pool *
find_literal_pool ()
{
  literal_pool * pool;

  for (pool = list_of_pools; pool != NULL; pool = pool->next)
    {
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
    }

  return pool;
}

static literal_pool *
find_or_make_literal_pool ()
{
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;

  pool = find_literal_pool ();

  if (pool == NULL)
    {
      /* Create a new pool.  */
      pool = (literal_pool *) xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;

      pool->next_free_entry = 0;
      pool->section         = now_seg;
      pool->sub_section     = now_subseg;
      pool->next            = list_of_pools;
      pool->symbol          = NULL;

      /* Add it to the list.  */
      list_of_pools = pool;
    }

  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
    {
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
    }

  /* Done.  */
  return pool;
}

/* Add the literal in the global 'inst'
   structure to the relevent literal pool.  */
static int
add_to_lit_pool ()
{
  literal_pool * pool;
  unsigned int entry;

  pool = find_or_make_literal_pool ();

  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    {
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
	break;

      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
          && (inst.reloc.exp.X_op == O_symbol)
          && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
          && (pool->literals[entry].X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
          && (pool->literals[entry].X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
        break;
    }

  /* Do we need to create a new entry?  */
  if (entry == pool->next_free_entry)
    {
      if (entry >= MAX_LITERAL_POOL_SIZE)
	{
	  inst.error = _("literal pool overflow");
	  return FAIL;
	}

      pool->literals[entry] = inst.reloc.exp;
      pool->next_free_entry += 1;
    }

  inst.reloc.exp.X_op         = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4 - 8;
  inst.reloc.exp.X_add_symbol = pool->symbol;

  return SUCCESS;
}

/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */

static void
symbol_locate (symbolP, name, segment, valu, frag)
     symbolS *    symbolP;
     const char * name;		/* It is copied, the caller can modify.  */
     segT         segment;	/* Segment identifier (SEG_<something>).  */
     valueT       valu;		/* Symbol value.  */
     fragS *      frag;		/* Associated fragment.  */
{
  unsigned int name_length;
  char * preserved_copy_of_name;

  name_length = strlen (name) + 1;   /* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = obstack_finish (&notes);
#ifdef STRIP_UNDERSCORE
  if (preserved_copy_of_name[0] == '_')
    preserved_copy_of_name++;
#endif

#ifdef tc_canonicalize_symbol_name
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
#endif

  S_SET_NAME (symbolP, preserved_copy_of_name);

  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);

  symbol_set_frag (symbolP, frag);

  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;
    if (symbol_table_frozen)
      abort ();
  }

  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);

  obj_symbol_new_hook (symbolP);

#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif

#ifdef DEBUG_SYMS
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS  */
}

/* Check that an immediate is valid.
   If so, convert it to the right format.  */

static unsigned int
validate_immediate (val)
     unsigned int val;
{
  unsigned int a;
  unsigned int i;

#define rotate_left(v, n) (v << n | v >> (32 - n))

  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */

  return FAIL;
}

/* Check to see if an immediate can be computed as two separate immediate
   values, added together.  We already know that this value cannot be
   computed by just one ARM instruction.  */

static unsigned int
validate_immediate_twopart (val, highpart)
     unsigned int   val;
     unsigned int * highpart;
{
  unsigned int a;
  unsigned int i;

  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
      {
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;
	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    assert (a & 0xff000000);
	    * highpart = (a >> 24) | ((i + 8) << 7);
d1189 1
a1189 3
validate_offset_imm (val, hwse)
     unsigned int val;
     int hwse;
d1303 1
a1303 1
      return;     
d1313 1
a1313 1
  
d1321 1
a1321 1
      
d1324 88
a1411 8
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
      
    case MAP_DATA:
    default:
      return;
    }
d1414 18
a1431 1
/* When we change sections we need to issue a new mapping symbol.  */
d1433 5
a1437 4
void
arm_elf_change_section (void)
{
  flagword flags;
d1439 1
a1439 2
  if (!SEG_NORMAL (now_seg))
    return;
d1441 2
a1442 1
  flags = bfd_get_section_flags (stdoutput, now_seg);
d1444 4
a1447 3
  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;
d1449 3
a1451 1
  mapstate = seg_info (now_seg)->tc_segment_info_data;
a1452 4
#else
#define mapping_state(a)
#endif /* OBJ_ELF */

d1455 1
a1455 2
s_req (a)
     int a ATTRIBUTE_UNUSED;
d1469 1
a1469 1
  char *name;
d1532 1
a1532 2
s_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1542 1
a1542 2
s_even (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1554 1
a1554 2
s_ltorg (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1599 1
a1599 2
s_align (unused)
     int unused ATTRIBUTE_UNUSED;
d1601 2
a1602 2
  register int temp;
  register long temp_fill;
d1634 1
a1634 2
s_force_thumb (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1652 1
a1652 2
s_thumb_func (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1668 1
a1668 2
s_thumb_set (equiv)
     int equiv;
d1673 4
a1676 4
  register char *    name;
  register char      delim;
  register char *    end_name;
  register symbolS * symbolP;
d1716 1
a1716 1
	  fragS * dummy_frag = (fragS *) xmalloc (sizeof (fragS));
d1757 1
a1757 43
opcode_select (width)
     int width;
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
	{
	  if (! (cpu_variant & ARM_EXT_V4T))
	    as_bad (_("selected processor does not support THUMB opcodes"));

	  thumb_mode = 1;
	  /* No need to force the alignment, since we will have been
             coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_THUMB);
      break;

    case 32:
      if (thumb_mode)
	{
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
	    as_bad (_("selected processor does not support ARM opcodes"));

	  thumb_mode = 0;

	  if (!need_pass_2)
	    frag_align (2, 0, 0);

	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_ARM);
      break;

    default:
      as_bad (_("invalid instruction size selected (%d)"), width);
    }
}

static void
s_arm (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1764 1
a1764 2
s_thumb (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1771 1
a1771 2
s_code (unused)
     int unused ATTRIBUTE_UNUSED;
d1773 1
a1773 1
  register int temp;
d1789 1
a1789 2
end_of_line (str)
     char *str;
d1798 1
a1798 2
skip_past_comma (str)
     char ** str;
d1817 74
d1897 1
a1897 3
reg_required_here (str, shift)
     char ** str;
     int     shift;
d1928 3
a1930 4
wreg_required_here (str, shift, reg_type)
     char ** str;
     int     shift;
     enum wreg_type reg_type;
d1972 1
a1972 2
arm_psr_parse (ccp)
     register char ** ccp;
d2014 1
a2014 2
psr_required_here (str)
     char ** str;
d2043 1
a2043 2
co_proc_number (str)
     char **str;
d2085 1
a2085 4
cp_opc_expr (str, where, length)
     char ** str;
     int where;
     int length;
d2112 1
a2112 3
cp_reg_required_here (str, where)
     char ** str;
     int     where;
d2133 1
a2133 3
fp_reg_required_here (str, where)
     char ** str;
     int     where;
d2154 1
a2154 2
cp_address_offset (str)
     char ** str;
d2201 1
a2201 3
cp_address_required_here (str, wb_ok)
     char ** str;
     int wb_ok;
a2227 1
		 
a2228 1
		   
a2229 1

d2235 1
a2235 1
	  
d2308 1
a2308 1
	      return FAIL;	      
d2367 1
a2367 2
cp_byte_address_offset (str)
     char ** str;
d2380 1
a2380 1
  
d2383 1
a2383 1
  
d2387 1
a2387 1
      
d2408 1
a2408 2
cp_byte_address_required_here (str)
     char ** str;
d2429 1
a2429 1
          
d2434 1
a2434 1
              
d2458 1
a2458 1
          
d2503 1
a2503 2
do_empty (str)
     char * str;
d2510 1
a2510 2
do_mrs (str)
     char *str;
d2531 2
a2532 2
  if (   strcmp (str, "CPSR") == 0
      || strcmp (str, "SPSR") == 0
d2534 2
a2535 2
      || strcmp (str, "cpsr") == 0
      || strcmp (str, "spsr") == 0)
d2539 2
a2540 2
  else if (   strcmp (str, "cpsr_all") == 0
	   || strcmp (str, "spsr_all") == 0)
d2560 1
a2560 2
do_msr (str)
     char * str;
d2642 1
a2642 2
do_mull (str)
     char * str;
d2690 1
a2690 2
do_mul (str)
     char * str;
d2742 1
a2742 2
do_mla (str)
     char * str;
d2803 1
a2803 2
accum0_required_here (str)
     char ** str;
d2831 59
d2898 1
a2898 2
ld_mode_required_here (string)
     char ** string;
d3002 1
a3002 2
do_smla (str)
     char *        str;
d3030 1
a3030 2
do_smlal (str)
     char *        str;
d3065 1
a3065 2
do_smul (str)
     char *        str;
d3090 1
a3090 2
do_qadd (str)
     char *        str;
d3120 1
a3120 2
do_co_reg2c (str)
     char *        str;
d3179 1
a3179 2
do_clz (str)
     char *        str;
d3204 1
a3204 2
do_lstc2 (str)
     char *        str;
d3235 1
a3235 2
do_cdp2 (str)
     char *        str;
d3298 1
a3298 2
do_co_reg2 (str)
     char *        str;
d3348 22
a3369 2
	}
    }
d3375 1
d3377 1
a3377 2
do_bxj (str)
     char * str;
d3396 1
a3396 1
/* ARM V6 umaal (argument parse). */
d3399 1
a3399 2
do_umaal (str)
     char *str;
a3400 1

d3413 1
a3413 1
      return;      
d3425 1
a3425 1
/* ARM V6 strex (argument parse). */
d3427 2
a3428 3
static void 
do_strex (str)
     char *str;
d3432 1
a3432 1
  /* Parse Rd, Rm,. */
d3453 2
a3454 2
  /* Skip past '['. */
  if ((strlen (str) >= 1) 
d3456 3
a3458 2
    str+=1;
  skip_whitespace (str);  
d3460 1
a3460 1
  /* Parse Rn. */
d3476 1
a3476 1
  skip_whitespace (str);  
d3478 2
a3479 2
  /* Skip past ']'. */
  if ((strlen (str) >= 1) 
d3481 2
a3482 2
    str+=1;
  
d3486 1
a3486 1
/* ARM V6 ssat (argument parse). */
d3488 2
a3489 3
static void
do_ssat (str)
     char* str;
d3491 112
a3602 3
  do_sat (&str, /*bias=*/-1);
  end_of_line (str);
}
d3604 8
a3611 1
/* ARM V6 usat (argument parse). */
d3613 2
a3614 6
static void
do_usat (str)
     char* str;
{
  do_sat (&str, /*bias=*/0);
  end_of_line (str);
d3618 1
a3618 3
do_sat (str, bias)
     char **str;
     int    bias;
d3624 2
a3625 2
  
  /* Parse <Rd>, field. */
d3638 1
a3638 1
  /* Parse #<immed>,  field. */
d3669 1
a3669 1
  /* Parse <Rm> field. */
d3685 1
a3685 1
/* ARM V6 ssat16 (argument parse). */
d3688 1
a3688 2
do_ssat16 (str)
     char *str;
d3690 1
a3690 1
  do_sat16 (&str, /*bias=*/-1);
d3694 2
d3697 1
a3697 2
do_usat16 (str)
     char *str;
d3699 1
a3699 1
  do_sat16 (&str, /*bias=*/0);
d3704 1
a3704 3
do_sat16 (str, bias)
     char **str;
     int bias;
d3711 1
a3711 1
  /* Parse the <Rd> field. */
d3724 1
a3724 1
  /* Parse #<immed>, field. */
d3755 1
a3755 1
  /* Parse <Rm> field. */
d3768 54
a3821 1
/* ARM V6 srs (argument parse). */
d3824 1
a3824 2
do_srs (str)
     char* str;
d3834 1
a3834 1
  if (*str == '!') 
d3842 1
a3842 1
/* ARM V6 SMMUL (argument parse). */
d3845 1
a3845 2
do_smmul (str)
     char* str;
d3848 1
a3848 1
  
d3860 1
a3860 1
  if (rd == REG_PC 
a3868 1
  
d3871 1
a3871 1
/* ARM V6 SMLALD (argument parse). */
d3874 1
a3874 2
do_smlald (str)
    char* str;
d3877 1
d3891 2
a3892 2
  if (rdlo == REG_PC 
      || rdhi == REG_PC 
d3903 1
a3903 1
/* ARM V6 SMLAD (argument parse).  Signed multiply accumulate dual. 
d3906 2
a3907 3
static void 
do_smlad (str)
     char *str;
d3910 1
a3910 1
  
d3923 3
a3925 3
  
  if (rd == REG_PC 
      || rn == REG_PC 
a3933 14
} 

/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.

   setend <endian_specifier>, where <endian_specifier> is either 
   BE or LE. */

static void 
do_setend (str)
     char *str;
{
  if (do_endian_specifier (str))
    inst.instruction |= 0x200;
d3939 1
a3939 2
do_endian_specifier (str)
     char *str;
d3961 13
d3978 1
a3978 1
   Error if any register uses R15. */
d3980 2
a3981 3
static void 
do_sxth (str)
     char *str;
d3989 1
a3989 1
  
d4004 2
a4005 2
  
  /* Zero out the rotation field. */
d4007 2
a4008 2
  
  /* Check for lack of optional rotation field. */
d4014 2
a4015 2
  
  /* Move past 'ROR'. */
d4018 1
a4018 1
    str+=3;
d4024 2
a4025 2
  
  /* Get the immediate constant. */
d4034 1
a4034 1
  
d4046 2
a4047 2
  
  switch (expr.X_add_number) 
d4050 1
a4050 1
      /* Rotation field has already been zeroed. */
d4059 1
a4059 1
      
a4069 1
  
d4078 1
a4078 1
   Error if any register uses R15. */
d4080 2
a4081 3
static void 
do_sxtah (str)
     char *str;
d4089 1
a4089 1
  
d4106 2
a4107 2
  
  /* Zero out the rotation field. */
d4109 2
a4110 2
  
  /* Check for lack of optional rotation field. */
d4116 2
a4117 2
  
  /* Move past 'ROR'. */
d4120 1
a4120 1
    str+=3;
d4126 2
a4127 2
  
  /* Get the immediate constant. */
d4136 1
a4136 1
  
d4148 2
a4149 2
  
  switch (expr.X_add_number) 
d4152 1
a4152 1
      /* Rotation field has already been zeroed. */
d4162 1
a4162 1
      
a4172 1
  
d4174 1
a4174 1
   
d4178 1
a4178 1
   respectively. 
d4180 1
a4180 2
   Error if Rn is R15.   
*/
d4183 1
a4183 2
do_rfe (str)
     char *str;
d4188 1
a4188 1
  
d4199 1
a4199 1
  
d4212 1
a4212 1
   Error if Rd or Rm are R15. */ 
d4215 1
a4215 2
do_rev (str)
     char* str;
d4234 1
a4234 1
   QADD16{<cond>} <Rd>, <Rn>, <Rm>  
d4239 1
a4239 2
do_qadd16 (str) 
     char* str;
d4252 2
a4253 20
  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>} 
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

static void 
do_pkhbt (str)
     char* str;
{
  do_pkh_core (str, SHIFT_LSL_IMMEDIATE);
}

/* ARM V6 PKHTB (Argument Parse). */
d4255 2
a4256 5
static void 
do_pkhtb (str)
     char* str;
{
  do_pkh_core (str, SHIFT_ASR_IMMEDIATE);
d4260 1
a4260 3
do_pkh_core (str, shift)
     char* str;
     int shift;
d4281 2
a4282 2
  /* Check for optional shift immediate constant. */
  if (skip_past_comma (&str) == FAIL) 
d4299 19
d4321 2
a4322 3
   Error if Rd or Rn are R15. 
   See ARMARMv6 A4.1.27: LDREX. */

d4325 1
a4325 2
do_ldrex (str)
     char * str;
d4331 1
a4331 1
  /* Parse Rd. */
d4343 1
a4343 1
  skip_whitespace (str);  
d4345 2
a4346 2
  /* Skip past '['. */
  if ((strlen (str) >= 1) 
d4348 2
a4349 2
    str+=1;
  skip_whitespace (str);  
d4351 1
a4351 1
  /* Parse Rn. */
d4362 1
a4362 1
  skip_whitespace (str);  
d4364 2
a4365 2
  /* Skip past ']'. */
  if ((strlen (str) >= 1) 
d4367 2
a4368 2
    str+=1;
  
d4373 1
a4373 1
      CPS, CPSIE, CSPID . */
d4376 1
a4376 2
do_cps (str)
     char * str;
d4383 1
a4383 2
do_cpsi (str)
     char * str;
d4385 2
a4386 54
  do_cps_flags (&str, /*thumb_p=*/0);

  if (skip_past_comma (&str) == SUCCESS)
    {
      skip_whitespace (str);
      do_cps_mode (&str);
    }
  end_of_line (str);
}

static void
do_cps_mode (str)
     char **str;
{
  expressionS expr;

  skip_whitespace (*str);

  if (! is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return;
    }

  (*str)++; /* Strip off the immediate signifier. */
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }

  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  
  /* The mode is a 5 bit field.  Valid values are 0-31. */
  if (((unsigned) expr.X_add_number) > 31
      || (inst.reloc.exp.X_add_number) < 0)
    {
      inst.error = _("invalid constant");
      return;
    }
  
  inst.instruction |= expr.X_add_number;
}

static void
do_cps_flags (str, thumb_p)
     char **str;
     int    thumb_p;
{
  struct cps_flag { 
d4391 2
a4392 1
  static struct cps_flag flag_table[] = {
d4402 1
a4402 1
  /* Get the a, f and i flags. */
d4407 1
d4422 2
a4423 1
  if (!saw_a_flag) 
d4427 13
d4444 1
a4444 2
do_t_bkpt (str)
     char * str;
d4479 41
d4526 1
a4526 2
do_branch25 (str)
     char *        str;
d4579 1
a4579 2
do_blx (str)
     char *        str;
d4623 1
a4623 2
do_t_blx (str)
     char * str;
d4665 1
a4665 2
do_bkpt (str)
     char *        str;
d4699 132
a4830 2
  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= number & 0xf;
d4832 3
a4834 4
  end_of_line (str);
}

/* THUMB CPS instruction (argument parse).  */
a4835 5
static void
do_t_cps (str)
     char *str;
{
  do_cps_flags (&str, /*thumb_p=*/1);
d4842 1
a4842 2
do_t_cpy (str)
     char *str;
d4850 1
a4850 2
do_t_setend (str)
     char *str;
a4855 2
static unsigned long check_iwmmxt_insn PARAMS ((char *, enum iwmmxt_insn_type, int));

d4859 3
a4861 4
check_iwmmxt_insn (str, insn_type, immediate_size)
     char * str;
     enum iwmmxt_insn_type insn_type;
     int immediate_size;
d4879 1
a4879 1
      
d4884 1
a4884 1
       
d4891 1
a4891 1
      
d4900 1
a4900 1
      
d4909 1
a4909 1
      
d4916 1
a4916 1
      
d4923 1
a4923 1
      
d4932 1
a4932 1
      
d4941 1
a4941 1
      
d4950 1
a4950 1
      
d4957 1
a4957 1
      
d4964 1
a4964 1
      
d4972 1
a4972 1
      
d4978 1
a4978 1
      
d4988 1
a4988 1
      
d4996 1
a4996 1
      
d5005 1
a5005 1
  
d5014 3
a5016 3
      skip_whitespace (str);      
  
      /* Allow optional leading '#'. */
d5021 1
a5021 1
  
d5027 1
a5027 1
  
d5029 1
a5029 1
  
d5042 1
a5042 2
do_iwmmxt_byte_addr (str)
     char * str;
d5048 1
a5048 1
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;  
d5071 1
a5071 2
do_iwmmxt_tandc (str)
     char * str;
d5082 1
a5082 2
do_iwmmxt_tbcst (str)
     char * str;
d5088 1
a5088 2
do_iwmmxt_textrc (str)
     char * str;
d5099 1
a5099 2
do_iwmmxt_textrm (str)
     char * str;
d5110 1
a5110 2
do_iwmmxt_tinsr (str)
     char * str;
d5121 1
a5121 2
do_iwmmxt_tmcr (str)
     char * str;
d5127 1
a5127 2
do_iwmmxt_tmcrr (str)
     char * str;
d5133 1
a5133 2
do_iwmmxt_tmia (str)
     char * str;
d5139 1
a5139 2
do_iwmmxt_tmovmsk (str)
     char * str;
d5145 1
a5145 2
do_iwmmxt_tmrc (str)
     char * str;
d5151 1
a5151 2
do_iwmmxt_tmrrc (str)
     char * str;
d5157 1
a5157 2
do_iwmmxt_torc (str)
     char * str;
d5163 1
a5163 2
do_iwmmxt_waligni (str)
     char * str;
d5174 1
a5174 2
do_iwmmxt_wmov (str)
     char * str;
d5178 1
a5178 1
  
d5183 1
a5183 2
do_iwmmxt_word_addr (str)
     char * str;
d5189 1
a5189 1
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;  
d5215 1
a5215 2
do_iwmmxt_wrwr (str)
     char * str;
d5221 1
a5221 2
do_iwmmxt_wrwrwcg (str)
     char * str;
d5227 1
a5227 2
do_iwmmxt_wrwrwr (str)
     char * str;
d5233 1
a5233 2
do_iwmmxt_wshufh (str)
     char * str;
d5244 1
a5244 2
do_iwmmxt_wzero (str)
     char * str;
d5258 1
a5258 2
do_xsc_mia (str)
     char * str;
d5287 1
a5287 2
do_xsc_mar (str)
     char * str;
d5315 1
a5315 2
do_xsc_mra (str)
     char * str;
d5343 58
d5408 1
a5408 2
do_pld (str)
     char * str;
d5490 1
a5490 2
do_ldrd (str)
     char * str;
d5547 1
a5547 2
my_get_float_expression (str)
     char ** str;
d5612 4
a5615 5
/* Return TRUE if anything in the expression is a bignum.  */

static int
walk_no_bignums (sp)
     symbolS * sp;
d5617 1
a5617 4
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;

  if (symbol_get_value_expression (sp)->X_add_symbol)
d5619 3
a5621 3
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
a5622 2

  return 0;
d5625 9
a5633 1
static int in_my_get_expression = 0;
d5636 2
a5637 3
my_get_expression (ep, str)
     expressionS * ep;
     char ** str;
d5639 2
a5640 2
  char * save_in;
  segT   seg;
d5642 2
a5643 5
  save_in = input_line_pointer;
  input_line_pointer = *str;
  in_my_get_expression = 1;
  seg = expression (ep);
  in_my_get_expression = 0;
d5645 2
a5646 1
  if (ep->X_op == O_illegal)
d5648 51
a5698 5
      /* We found a bad expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
d5700 3
a5702 11
#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad_segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
a5703 1
#endif
d5705 2
a5706 14
  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.  Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (ep->X_op == O_big
      || (ep->X_add_symbol
	  && (walk_no_bignums (ep->X_add_symbol)
	      || (ep->X_op_symbol
		  && walk_no_bignums (ep->X_op_symbol)))))
    {
      inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
d5708 3
a5710 3
  *str = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
d5713 2
a5714 5
/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expr)
     expressionS *expr;
d5716 14
a5729 1
  if (in_my_get_expression)
d5731 5
a5735 5
      expr->X_op = O_illegal;
      if (inst.error == NULL)
	inst.error = _("bad expression");
    }
}
d5737 2
a5738 1
/* KIND indicates what kind of shifts are accepted.  */
d5740 12
a5751 8
static int
decode_shift (str, kind)
     char ** str;
     int     kind;
{
  const struct asm_shift_name * shift;
  char * p;
  char   c;
d5753 5
a5757 1
  skip_whitespace (* str);
d5759 13
a5771 2
  for (p = * str; ISALPHA (* p); p ++)
    ;
d5773 2
a5774 5
  if (p == * str)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }
d5776 12
a5787 4
  c = * p;
  * p = '\0';
  shift = (const struct asm_shift_name *) hash_find (arm_shift_hsh, * str);
  * p = c;
d5789 2
a5790 5
  if (shift == NULL)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }
d5792 3
a5794 1
  assert (shift->properties->index == shift_properties[shift->properties->index].index);
d5796 2
a5797 5
  if (kind == SHIFT_LSL_OR_ASR_IMMEDIATE
      && shift->properties->index != SHIFT_LSL
      && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'LSL' or 'ASR' required");
d5800 1
a5800 19
  else if (kind == SHIFT_LSL_IMMEDIATE
	   && shift->properties->index != SHIFT_LSL)
    {
      inst.error = _("'LSL' required");
      return FAIL;
    }
  else if (kind == SHIFT_ASR_IMMEDIATE
	   && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'ASR' required");
      return FAIL;
    }
    
  if (shift->properties->index == SHIFT_RRX)
    {
      * str = p;
      inst.instruction |= shift->properties->bit_field;
      return SUCCESS;
    }
d5802 4
a5805 1
  skip_whitespace (p);
d5807 3
a5809 1
  if (kind == NO_SHIFT_RESTRICT && reg_required_here (& p, 8) != FAIL)
d5811 4
a5814 12
      inst.instruction |= shift->properties->bit_field | SHIFT_BY_REG;
      * str = p;
      return SUCCESS;
    }
  else if (! is_immediate_prefix (* p))
    {
      inst.error = (NO_SHIFT_RESTRICT
		    ? _("shift requires register or #expression")
		    : _("shift requires #expression"));
      * str = p;
      return FAIL;
    }
d5816 1
a5816 2
  inst.error = NULL;
  p ++;
d5818 1
a5818 2
  if (my_get_expression (& inst.reloc.exp, & p))
    return FAIL;
d5820 2
a5821 4
  /* Validate some simple #expressions.  */
  if (inst.reloc.exp.X_op == O_constant)
    {
      unsigned num = inst.reloc.exp.X_add_number;
d5823 1
a5823 13
      /* Reject operations greater than 32.  */
      if (num > 32
	  /* Reject a shift of 0 unless the mode allows it.  */
	  || (num == 0 && shift->properties->allows_0 == 0)
	  /* Reject a shift of 32 unless the mode allows it.  */
	  || (num == 32 && shift->properties->allows_32 == 0)
	  )
	{
	  /* As a special case we allow a shift of zero for
	     modes that do not support it to be recoded as an
	     logical shift left of zero (ie nothing).  We warn
	     about this though.  */
	  if (num == 0)
d5825 12
a5836 3
	      as_warn (_("shift of 0 ignored."));
	      shift = & shift_names[0];
	      assert (shift->properties->index == SHIFT_LSL);
d5838 6
a5843 1
	  else
d5845 2
a5846 2
	      inst.error = _("invalid immediate shift");
	      return FAIL;
d5848 3
d5852 5
d5858 4
a5861 4
      /* Shifts of 32 are encoded as 0, for those shifts that
	 support it.  */
      if (num == 32)
	num = 0;
d5863 9
a5871 1
      inst.instruction |= (num << 7) | shift->properties->bit_field;
d5873 14
a5886 1
  else
d5888 3
a5890 3
      inst.reloc.type   = BFD_RELOC_ARM_SHIFT_IMM;
      inst.reloc.pc_rel = 0;
      inst.instruction |= shift->properties->bit_field;
d5893 9
a5901 2
  * str = p;
  return SUCCESS;
d5904 2
a5905 14
/* Do those data_ops which can take a negative immediate constant
   by altering the instruction.  A bit of a hack really.
        MOV <-> MVN
        AND <-> BIC
        ADC <-> SBC
        by inverting the second operand, and
        ADD <-> SUB
        CMP <-> CMN
        by negating the second operand.  */

static int
negate_data_op (instruction, value)
     unsigned long * instruction;
     unsigned long   value;
d5907 4
a5910 2
  int op, new_inst;
  unsigned long negated, inverted;
d5912 1
a5912 2
  negated = validate_immediate (-value);
  inverted = validate_immediate (~value);
d5914 3
a5916 2
  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
  switch (op)
d5918 2
a5919 5
      /* First negates.  */
    case OPCODE_SUB:             /* ADD <-> SUB  */
      new_inst = OPCODE_ADD;
      value = negated;
      break;
d5921 2
a5922 4
    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
      value = negated;
      break;
d5924 10
a5933 4
    case OPCODE_CMP:             /* CMP <-> CMN  */
      new_inst = OPCODE_CMN;
      value = negated;
      break;
d5935 4
a5938 4
    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
      value = negated;
      break;
d5940 6
a5945 5
      /* Now Inverted ops.  */
    case OPCODE_MOV:             /* MOV <-> MVN  */
      new_inst = OPCODE_MVN;
      value = inverted;
      break;
d5947 7
a5953 4
    case OPCODE_MVN:
      new_inst = OPCODE_MOV;
      value = inverted;
      break;
d5955 2
a5956 4
    case OPCODE_AND:             /* AND <-> BIC  */
      new_inst = OPCODE_BIC;
      value = inverted;
      break;
d5958 4
a5961 4
    case OPCODE_BIC:
      new_inst = OPCODE_AND;
      value = inverted;
      break;
d5963 6
a5968 4
    case OPCODE_ADC:              /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
      value = inverted;
      break;
d5970 6
a5975 8
    case OPCODE_SBC:
      new_inst = OPCODE_ADC;
      value = inverted;
      break;

      /* We cannot do anything.  */
    default:
      return FAIL;
d5978 1
a5978 6
  if (value == (unsigned) FAIL)
    return FAIL;

  *instruction &= OPCODE_MASK;
  *instruction |= new_inst << DATA_OP_SHIFT;
  return value;
d5981 2
a5982 3
static int
data_op2 (str)
     char ** str;
d5984 2
a5986 1
  expressionS expr;
d5988 1
a5988 1
  skip_whitespace (* str);
d5990 1
a5990 1
  if (reg_required_here (str, 0) != FAIL)
d5992 4
a5995 3
      if (skip_past_comma (str) == SUCCESS)
	/* Shift operation on register.  */
	return decode_shift (str, NO_SHIFT_RESTRICT);
d5997 4
a6000 1
      return SUCCESS;
d6002 2
a6003 1
  else
d6005 15
a6019 2
      /* Immediate expression.  */
      if (is_immediate_prefix (**str))
d6021 1
a6021 2
	  (*str)++;
	  inst.error = NULL;
d6023 1
a6023 4
	  if (my_get_expression (&inst.reloc.exp, str))
	    return FAIL;

	  if (inst.reloc.exp.X_add_symbol)
d6025 7
a6031 2
	      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
	      inst.reloc.pc_rel = 0;
d6035 4
a6038 1
	      if (skip_past_comma (str) == SUCCESS)
d6040 20
a6059 3
		  /* #x, y -- ie explicit rotation by Y.  */
		  if (my_get_expression (&expr, str))
		    return FAIL;
d6061 3
a6063 5
		  if (expr.X_op != O_constant)
		    {
		      inst.error = _("constant expression expected");
		      return FAIL;
		    }
d6065 1
a6065 13
		  /* Rotate must be a multiple of 2.  */
		  if (((unsigned) expr.X_add_number) > 30
		      || (expr.X_add_number & 1) != 0
		      || ((unsigned) inst.reloc.exp.X_add_number) > 255)
		    {
		      inst.error = _("invalid constant");
		      return FAIL;
		    }
		  inst.instruction |= INST_IMMEDIATE;
		  inst.instruction |= inst.reloc.exp.X_add_number;
		  inst.instruction |= expr.X_add_number << 7;
		  return SUCCESS;
		}
d6067 5
a6071 2
	      /* Implicit rotation, select a suitable one.  */
	      value = validate_immediate (inst.reloc.exp.X_add_number);
d6073 1
a6073 12
	      if (value == FAIL)
		{
		  /* Can't be done.  Perhaps the code reads something like
		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be OK.  */
		  if ((value = negate_data_op (&inst.instruction,
					       inst.reloc.exp.X_add_number))
		      == FAIL)
		    {
		      inst.error = _("invalid constant");
		      return FAIL;
		    }
		}
d6075 8
a6082 1
	      inst.instruction |= value;
d6084 9
d6094 2
a6095 3
	  inst.instruction |= INST_IMMEDIATE;
	  return SUCCESS;
	}
d6097 1
a6097 5
      (*str)++;
      inst.error = _("register or shift expression expected");
      return FAIL;
    }
}
d6099 2
a6100 5
static int
fp_op2 (str)
     char ** str;
{
  skip_whitespace (* str);
d6102 2
a6103 6
  if (fp_reg_required_here (str, 0) != FAIL)
    return SUCCESS;
  else
    {
      /* Immediate expression.  */
      if (*((*str)++) == '#')
d6105 3
a6107 1
	  int i;
d6109 3
a6111 1
	  inst.error = NULL;
d6113 1
a6113 6
	  skip_whitespace (* str);

	  /* First try and match exact strings, this is to guarantee
	     that some formats will work even for cross assembly.  */

	  for (i = 0; fp_const[i]; i++)
d6115 8
a6122 3
	      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
		{
		  char *start = *str;
d6124 1
a6124 9
		  *str += strlen (fp_const[i]);
		  if (is_end_of_line[(unsigned char) **str])
		    {
		      inst.instruction |= i + 8;
		      return SUCCESS;
		    }
		  *str = start;
		}
	    }
d6126 1
a6126 5
	  /* Just because we didn't get a match doesn't mean that the
	     constant isn't valid, just that it is in a format that we
	     don't automatically recognize.  Try parsing it with
	     the standard expression routines.  */
	  if ((i = my_get_float_expression (str)) >= 0)
d6128 7
a6134 2
	      inst.instruction |= i + 8;
	      return SUCCESS;
d6136 1
d6138 6
a6143 2
	  inst.error = _("invalid floating point immediate expression");
	  return FAIL;
a6144 5
      inst.error =
	_("floating point register or immediate expression expected");
      return FAIL;
    }
}
d6146 5
a6150 15
static void
do_arit (str)
     char * str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6152 1
a6152 15

  end_of_line (str);
}

static void
do_adr (str)
     char * str;
{
  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-8".  */
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d6154 2
a6155 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6157 1
a6157 3
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
d6159 2
a6160 1
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
d6162 4
a6165 1
  inst.reloc.pc_rel = 1;
d6167 1
d6172 1
a6172 2
do_adrl (str)
     char * str;
d6174 1
a6174 4
  /* This is a pseudo-op of the form "adrl rd, label" to be converted
     into a relative address of the form:
     add rd, pc, #low(label-.-8)"
     add rd, rd, #high(label-.-8)"  */
d6178 1
a6178 3
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
a6181 1

d6185 1
a6185 18
  end_of_line (str);
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type              = BFD_RELOC_ARM_ADRL_IMMEDIATE;
#ifndef TE_WINCE  
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
#endif
  inst.reloc.pc_rel            = 1;
  inst.size                    = INSN_SIZE * 2;
}

static void
do_cmp (str)
     char * str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 16) == FAIL)
d6187 1
a6187 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6191 1
a6191 2
  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
d6193 1
a6193 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6195 1
a6195 2
  end_of_line (str);
}
d6197 1
a6197 5
static void
do_mov (str)
     char * str;
{
  skip_whitespace (str);
d6199 2
a6200 6
  if (reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6202 6
a6207 7
  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6209 1
a6209 2
  end_of_line (str);
}
d6211 1
a6211 15
static int
ldst_extend (str)
     char ** str;
{
  int add = INDEX_UP;

  switch (**str)
    {
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;

      if (inst.reloc.exp.X_op == O_constant)
d6213 1
a6213 1
	  int value = inst.reloc.exp.X_add_number;
d6215 1
a6215 1
	  if (value < -4095 || value > 4095)
d6217 3
a6219 2
	      inst.error = _("address offset too large");
	      return FAIL;
d6221 8
d6230 1
a6230 4
	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
a6231 2

	  inst.instruction |= add | value;
d6235 2
a6236 2
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
	  inst.reloc.pc_rel = 0;
d6238 6
a6243 5
      return SUCCESS;

    case '-':
      add = 0;
      /* Fall through.  */
d6245 2
a6246 3
    case '+':
      (*str)++;
      /* Fall through.  */
d6248 1
a6248 11
    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;

      inst.instruction |= add | OFFSET_REG;
      if (skip_past_comma (str) == SUCCESS)
	return decode_shift (str, SHIFT_IMMEDIATE);

      return SUCCESS;
    }
}
d6251 1
a6251 2
do_ldst (str)
     char *        str;
d6259 1
a6259 1
  if ((conflict_reg = reg_required_here (&str, 12)) == FAIL)
d6266 1
a6266 1
  if (skip_past_comma (&str) == FAIL)
d6295 1
a6295 1
	      if (ldst_extend (&str) == FAIL)
d6305 2
d6333 1
a6333 1
	  if (ldst_extend (&str) == FAIL)
d6365 1
d6389 1
a6389 2
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MOV << DATA_OP_SHIFT));
d6395 1
a6395 1
	  value = validate_immediate (~inst.reloc.exp.X_add_number);
d6401 1
a6401 2
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MVN << DATA_OP_SHIFT));
d6417 2
a6418 1
      inst.reloc.type = BFD_RELOC_ARM_LITERAL;
d6428 2
a6429 1
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d6443 2
a6444 3
static void
do_ldstt (str)
     char *        str;
d6446 8
a6453 1
  int conflict_reg;
d6455 4
a6458 1
  skip_whitespace (str);
d6460 4
a6463 6
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6465 1
a6465 5
  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("address expected");
      return;
    }
d6467 2
a6468 3
  if (*str == '[')
    {
      int reg;
d6470 3
a6472 1
      str++;
d6474 5
a6478 1
      skip_whitespace (str);
d6480 11
a6490 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d6492 5
a6496 6
      /* ldrt/strt always use post-indexed addressing, so if the base is
	 the same as Rd, we warn.  */
      if (conflict_reg == reg)
	as_warn (_("%s register same as write-back base"),
		 ((inst.instruction & LOAD_BIT)
		  ? _("destination") : _("source")));
d6498 7
a6504 1
      skip_whitespace (str);
d6506 7
a6512 1
      if (*str == ']')
d6514 4
a6517 1
	  str ++;
d6519 1
a6519 1
	  if (skip_past_comma (&str) == SUCCESS)
d6521 19
a6539 3
	      /* [Rn],... (post inc)  */
	      if (ldst_extend (&str) == FAIL)
		return;
d6543 5
a6547 2
	      /* [Rn]  */
	      skip_whitespace (str);
d6549 3
a6551 5
	      /* Skip a write-back '!'.  */
	      if (*str == '!')
		str++;

	      inst.instruction |= INDEX_UP;
d6554 4
a6557 1
      else
d6559 2
a6560 2
	  inst.error = _("post-indexed expression expected");
	  return;
d6563 1
a6563 5
  else
    {
      inst.error = _("post-indexed expression expected");
      return;
    }
d6565 2
a6566 1
  end_of_line (str);
d6569 2
a6570 3
static int
ldst_extend_v4 (str)
     char ** str;
d6572 7
a6578 1
  int add = INDEX_UP;
d6580 1
a6580 1
  switch (**str)
d6582 5
a6586 5
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;
d6588 5
a6592 3
      if (inst.reloc.exp.X_op == O_constant)
	{
	  int value = inst.reloc.exp.X_add_number;
d6594 7
a6600 5
	  if (value < -255 || value > 255)
	    {
	      inst.error = _("address offset too large");
	      return FAIL;
	    }
d6602 5
a6606 5
	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
	    }
d6608 12
a6619 4
	  /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0.  */
	  inst.instruction |= (add | HWOFFSET_IMM
			       | ((value >> 4) << 8) | (value & 0xF));
d6621 1
a6621 1
      else
d6623 7
a6629 3
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	  inst.reloc.pc_rel = 0;
d6631 5
a6635 1
      return SUCCESS;
d6637 4
a6640 3
    case '-':
      add = 0;
      /* Fall through.  */
d6642 3
a6644 3
    case '+':
      (*str)++;
      /* Fall through.  */
d6646 2
a6647 3
    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;
d6649 3
a6651 3
      inst.instruction |= add;
      return SUCCESS;
    }
a6653 1
/* Halfword and signed-byte load/store operations.  */
d6655 1
a6655 2
do_ldstv4 (str)
     char *        str;
d6657 1
a6657 3
  int pre_inc = 0;
  int conflict_reg;
  int value;
d6661 11
a6671 1
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d6678 1
a6678 1
  if (skip_past_comma (& str) == FAIL)
d6680 1
a6680 1
      inst.error = _("address expected");
d6684 2
a6685 1
  if (*str == '[')
d6687 3
a6689 1
      int reg;
d6691 1
a6691 1
      str++;
d6693 2
a6694 1
      skip_whitespace (str);
d6696 5
a6700 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d6702 1
a6702 2
      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);
d6704 4
a6707 70
      skip_whitespace (str);

      if (*str == ']')
	{
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend_v4 (&str) == FAIL)
		return;
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	    }
	  else
	    {
	      /* [Rn]  */
	      inst.instruction |= HWOFFSET_IMM;

	      skip_whitespace (str);

	      if (*str == '!')
		{
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
		}

	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
	    }
	}
      else
	{
	  /* [Rn,...]  */
	  if (skip_past_comma (&str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return;
	    }

	  pre_inc = 1;
	  if (ldst_extend_v4 (&str) == FAIL)
	    return;

	  skip_whitespace (str);

	  if (*str++ != ']')
	    {
	      inst.error = _("missing ]");
	      return;
	    }

	  skip_whitespace (str);

	  if (*str == '!')
	    {
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	      str++;
	      inst.instruction |= WRITE_BACK;
	    }
	}
a6708 7
  else if (*str == '=')
    {
      if ((inst.instruction & LOAD_BIT) == 0)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}
d6710 2
a6711 3
      /* XXX Does this work correctly for half-word/byte ops?  */
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d6713 5
a6717 1
      skip_whitespace (str);
d6719 3
a6721 2
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d6723 2
a6724 6
      if (inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = _("constant expression expected");
	  return;
	}
d6726 26
a6751 57
      if (inst.reloc.exp.X_op == O_constant)
	{
	  value = validate_immediate (inst.reloc.exp.X_add_number);

	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }

	  value = validate_immediate (~ inst.reloc.exp.X_add_number);

	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
	}

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
	  return;
	}

      /* Change the instruction exp to point to the pool.  */
      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
#ifndef TE_WINCE
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
#endif
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
a6752 1
  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
d6756 2
a6757 3
static long
reg_list (strp)
     char ** strp;
d6759 3
a6761 3
  char * str = * strp;
  long   range = 0;
  int    another_range;
d6763 1
a6763 2
  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
d6765 4
a6768 1
      another_range = 0;
d6770 7
a6776 4
      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;
d6778 7
a6784 4
	  str++;
	  do
	    {
	      int reg;
d6786 7
a6792 1
	      skip_whitespace (str);
d6794 7
a6800 2
	      if ((reg = reg_required_here (& str, -1)) == FAIL)
		return FAIL;
d6802 7
a6808 41
	      if (in_range)
		{
		  int i;

		  if (reg <= cur_reg)
		    {
		      inst.error = _("bad range in register list");
		      return FAIL;
		    }

		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}

	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));

	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;
	  skip_whitespace (str);

	  if (*str++ != '}')
	    {
	      inst.error = _("missing `}'");
	      return FAIL;
	    }
d6810 1
a6810 3
      else
	{
	  expressionS expr;
d6812 2
a6813 2
	  if (my_get_expression (&expr, &str))
	    return FAIL;
d6815 5
a6819 8
	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}
d6821 1
a6821 3
	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;
d6823 6
a6828 6
		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}
d6830 7
a6836 9
	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}
d6838 6
a6843 13
	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
	}

      skip_whitespace (str);

      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
a6844 1
  while (another_range);
d6846 1
a6846 2
  *strp = str;
  return range;
d6850 1
a6850 2
do_ldmstm (str)
     char * str;
d6852 2
a6853 2
  int base_reg;
  long range;
d6857 6
a6862 2
  if ((base_reg = reg_required_here (&str, 16)) == FAIL)
    return;
d6864 2
a6865 1
  if (base_reg == REG_PC)
d6867 2
a6868 1
      inst.error = _("r15 not allowed as base register");
d6872 2
a6873 3
  skip_whitespace (str);

  if (*str == '!')
d6875 3
a6877 2
      inst.instruction |= WRITE_BACK;
      str++;
d6881 1
a6881 1
      || (range = reg_list (&str)) == FAIL)
d6883 1
a6883 1
      if (! inst.error)
d6888 2
a6889 1
  if (*str == '^')
d6891 3
a6893 2
      str++;
      inst.instruction |= LDM_TYPE_2_OR_3;
d6896 1
a6896 1
  if (inst.instruction & WRITE_BACK)
d6898 1
a6898 2
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
d6900 3
a6902 17
	  /* Not allowed in LDM type 2.  */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
	}
      else /* STM.  */
	{
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
a6905 1
  inst.instruction |= range;
d6910 1
a6910 2
do_swi (str)
     char * str;
d6912 3
d6917 6
a6922 6
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str++;

  if (my_get_expression (& inst.reloc.exp, & str))
    return;
a6923 2
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
d6928 1
a6928 2
do_swap (str)
     char * str;
a6929 2
  int reg;

d6932 1
a6932 4
  if ((reg = reg_required_here (&str, 12)) == FAIL)
    return;

  if (reg == REG_PC)
d6934 2
a6935 1
      inst.error = _("r15 not allowed in swap");
d6940 1
a6940 1
      || (reg = reg_required_here (&str, 0)) == FAIL)
d6947 11
a6957 1
  if (reg == REG_PC)
d6959 2
a6960 1
      inst.error = _("r15 not allowed in swap");
d6964 1
d6966 1
a6966 1
      || *str++ != '[')
d6968 2
a6969 1
      inst.error = BAD_ARGS;
d6973 5
a6977 1
  skip_whitespace (str);
d6979 1
a6979 2
  if ((reg = reg_required_here (&str, 16)) == FAIL)
    return;
d6981 1
a6981 1
  if (reg == REG_PC)
d6983 1
a6983 1
      inst.error = BAD_PC;
d6987 1
a6987 3
  skip_whitespace (str);

  if (*str++ != ']')
d6989 13
a7001 2
      inst.error = _("missing ]");
      return;
d7004 5
a7008 2
  end_of_line (str);
}
d7010 11
a7020 6
static void
do_branch (str)
     char * str;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
d7022 2
a7023 3
#ifdef OBJ_ELF
  {
    char * save_in;
d7025 2
a7026 2
    /* ScottB: February 5, 1998 - Check to see of PLT32 reloc
       required for the instruction.  */
d7028 1
a7028 26
    /* arm_parse_reloc () works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;
    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
	inst.reloc.pc_rel = 1;
      }
    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF  */
d7030 5
a7034 2
  end_of_line (str);
}
d7036 14
a7049 5
static void
do_bx (str)
     char * str;
{
  int reg;
d7051 23
a7073 1
  skip_whitespace (str);
d7075 4
a7078 1
  if ((reg = reg_required_here (&str, 0)) == FAIL)
d7080 2
a7081 1
      inst.error = BAD_ARGS;
a7084 4
  /* Note - it is not illegal to do a "bx pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));

d7089 1
a7089 2
do_cdp (str)
     char * str;
a7090 2
  /* Co-processor data operation.
     Format: CDP{cond} CP#,<expr>,CRd,CRn,CRm{,<expr>}  */
d7093 1
a7093 1
  if (co_proc_number (&str) == FAIL)
d7095 1
a7095 1
      if (!inst.error)
d7101 1
a7101 1
      || cp_opc_expr (&str, 20,4) == FAIL)
d7103 1
a7103 1
      if (!inst.error)
d7109 1
a7109 1
      || cp_reg_required_here (&str, 12) == FAIL)
d7111 1
a7111 1
      if (!inst.error)
d7116 9
a7124 2
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
d7126 1
a7126 1
      if (!inst.error)
d7132 1
a7132 1
      || cp_reg_required_here (&str, 0) == FAIL)
d7134 1
a7134 1
      if (!inst.error)
a7138 10
  if (skip_past_comma (&str) == SUCCESS)
    {
      if (cp_opc_expr (&str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

d7143 1
a7143 2
do_lstc (str)
     char * str;
a7144 3
  /* Co-processor register load/store.
     Format: <LDC|STC{cond}[L] CP#,CRd,<address>  */

d7147 1
a7147 9
  if (co_proc_number (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
d7149 1
a7149 1
      if (!inst.error)
d7155 1
a7155 1
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
d7166 1
a7166 2
do_co_reg (str)
     char * str;
a7167 3
  /* Co-processor register transfer.
     Format: <MCR|MRC>{cond} CP#,<expr1>,Rd,CRn,CRm{,<expr2>}  */

d7170 1
a7170 1
  if (co_proc_number (&str) == FAIL)
d7172 1
a7172 1
      if (!inst.error)
d7178 1
a7178 1
      || cp_opc_expr (&str, 21, 3) == FAIL)
d7180 1
a7180 1
      if (!inst.error)
d7185 11
d7197 1
a7197 1
      || reg_required_here (&str, 12) == FAIL)
d7199 1
a7199 1
      if (!inst.error)
d7204 11
a7214 2
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
d7216 18
a7233 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d7236 15
a7250 7
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d7252 1
a7252 1
  if (skip_past_comma (&str) == SUCCESS)
d7254 1
a7254 1
      if (cp_opc_expr (&str, 5, 3) == FAIL)
d7256 14
a7269 3
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
d7271 1
d7274 7
a7280 1
  end_of_line (str);
d7284 1
a7284 2
do_fpa_ctrl (str)
     char * str;
d7286 1
a7286 2
  /* FP control registers.
     Format: <WFS|RFS|WFC|RFC>{cond} Rn  */
d7288 2
a7289 1
  skip_whitespace (str);
d7291 2
a7292 1
  if (reg_required_here (&str, 12) == FAIL)
d7294 1
a7294 1
      if (!inst.error)
d7303 1
a7303 2
do_fpa_ldst (str)
     char * str;
d7307 5
a7311 1
  if (fp_reg_required_here (&str, 12) == FAIL)
d7313 1
a7313 1
      if (!inst.error)
d7318 11
d7330 3
a7332 1
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
d7334 1
a7334 1
      if (!inst.error)
d7343 1
a7343 2
do_fpa_ldmstm (str)
     char * str;
d7345 1
a7345 1
  int num_regs;
d7347 2
a7348 1
  skip_whitespace (str);
d7350 4
a7353 1
  if (fp_reg_required_here (&str, 12) == FAIL)
d7360 11
a7370 1
  /* Get Number of registers to transfer.  */
d7372 1
a7372 1
      || my_get_expression (&inst.reloc.exp, &str))
d7375 1
a7375 1
	inst.error = _("constant expression expected");
d7379 24
a7402 5
  if (inst.reloc.exp.X_op != O_constant)
    {
      inst.error = _("constant value required for number of registers");
      return;
    }
d7404 1
a7404 1
  num_regs = inst.reloc.exp.X_add_number;
d7406 1
a7406 1
  if (num_regs < 1 || num_regs > 4)
d7408 4
a7411 3
      inst.error = _("number of registers must be in the range [1:4]");
      return;
    }
d7413 5
a7417 16
  switch (num_regs)
    {
    case 1:
      inst.instruction |= CP_T_X;
      break;
    case 2:
      inst.instruction |= CP_T_Y;
      break;
    case 3:
      inst.instruction |= CP_T_Y | CP_T_X;
      break;
    case 4:
      break;
    default:
      abort ();
    }
d7419 5
a7423 5
  if (inst.instruction & (CP_T_Pre | CP_T_UD)) /* ea/fd format.  */
    {
      int reg;
      int write_back;
      int offset;
d7425 1
a7425 6
      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      if (skip_past_comma (&str) == FAIL
	  || *str != '[')
d7427 2
a7428 3
	  if (! inst.error)
	    inst.error = BAD_ARGS;
	  return;
d7431 2
a7432 2
      str++;
      skip_whitespace (str);
d7434 1
a7434 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d7436 3
a7438 1
      skip_whitespace (str);
d7440 1
a7440 5
      if (*str != ']')
	{
	  inst.error = BAD_ARGS;
	  return;
	}
d7442 3
a7444 6
      str++;
      if (*str == '!')
	{
	  write_back = 1;
	  str++;
	  if (reg == REG_PC)
d7446 2
a7447 3
	      inst.error =
		_("r15 not allowed as base register with write-back");
	      return;
a7448 3
	}
      else
	write_back = 0;
d7450 1
a7450 11
      if (inst.instruction & CP_T_Pre)
	{
	  /* Pre-decrement.  */
	  offset = 3 * num_regs;
	  if (write_back)
	    inst.instruction |= CP_T_WB;
	}
      else
	{
	  /* Post-increment.  */
	  if (write_back)
d7452 2
a7453 2
	      inst.instruction |= CP_T_WB;
	      offset = 3 * num_regs;
d7455 2
a7456 1
	  else
d7458 8
a7465 4
	      /* No write-back, so convert this into a standard pre-increment
		 instruction -- aesthetically more pleasing.  */
	      inst.instruction |= CP_T_Pre | CP_T_UD;
	      offset = 0;
d7468 2
d7471 4
a7474 1
      inst.instruction |= offset;
d7476 11
a7486 2
  else if (skip_past_comma (&str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
d7488 5
a7492 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d7495 2
a7496 1
  end_of_line (str);
d7500 1
a7500 2
do_fpa_dyadic (str)
     char * str;
d7504 4
a7507 1
  if (fp_reg_required_here (&str, 12) == FAIL)
d7514 2
a7515 2
  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 16) == FAIL)
d7518 1
a7518 2
	inst.error = BAD_ARGS;
      return;
d7521 11
d7533 1
a7533 1
      || fp_op2 (&str) == FAIL)
d7544 1
a7544 2
do_fpa_monadic (str)
     char * str;
d7548 2
a7549 1
  if (fp_reg_required_here (&str, 12) == FAIL)
d7552 1
a7552 2
	inst.error = BAD_ARGS;
      return;
d7556 3
a7558 1
      || fp_op2 (&str) == FAIL)
d7569 1
a7569 2
do_fpa_cmp (str)
     char * str;
d7573 5
a7577 1
  if (fp_reg_required_here (&str, 16) == FAIL)
d7584 11
d7596 3
a7598 1
      || fp_op2 (&str) == FAIL)
d7609 1
a7609 2
do_fpa_from_reg (str)
     char * str;
d7613 2
a7614 6
  if (fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d7628 1
a7628 2
do_fpa_to_reg (str)
     char * str;
d7632 1
a7632 1
  if (reg_required_here (&str, 12) == FAIL)
d7636 3
a7638 1
      || fp_reg_required_here (&str, 0) == FAIL)
d7648 2
a7649 4
static int
vfp_sp_reg_required_here (str, pos)
     char **str;
     enum vfp_sp_reg_pos pos;
a7650 1
  int    reg;
d7652 5
d7658 2
a7659 1
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab)) != FAIL)
d7661 1
a7661 18
      switch (pos)
	{
	case VFP_REG_Sd:
	  inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
	  break;

	case VFP_REG_Sn:
	  inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
	  break;

	case VFP_REG_Sm:
	  inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
	  break;

	default:
	  abort ();
	}
      return reg;
d7663 1
d7665 2
a7666 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_SN].expected);
d7668 3
a7670 14
  /* Restore the start point.  */
  *str = start;
  return FAIL;
}

static int
vfp_dp_reg_required_here (str, pos)
     char **str;
     enum vfp_dp_reg_pos pos;
{
  int   reg;
  char *start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab)) != FAIL)
d7672 1
a7672 1
      switch (pos)
d7674 3
a7676 14
	case VFP_REG_Dd:
	  inst.instruction |= reg << 12;
	  break;

	case VFP_REG_Dn:
	  inst.instruction |= reg << 16;
	  break;

	case VFP_REG_Dm:
	  inst.instruction |= reg << 0;
	  break;

	default:
	  abort ();
a7677 1
      return reg;
d7680 2
a7681 7
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_DN].expected);

  /* Restore the start point.  */
  *str = start;
  return FAIL;
d7684 2
a7685 3
static void
do_vfp_sp_monadic (str)
     char *str;
d7687 2
a7688 1
  skip_whitespace (str);
d7690 1
a7690 2
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;
d7692 1
a7692 2
  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
d7694 2
a7695 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d7698 4
a7701 1
  end_of_line (str);
d7705 1
a7705 2
do_vfp_dp_monadic (str)
     char *str;
d7709 1
a7709 1
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
d7713 1
a7713 1
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
d7724 1
a7724 2
do_vfp_sp_dyadic (str)
     char *str;
d7728 1
a7728 1
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
d7732 1
a7732 3
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
d7743 1
a7743 2
do_vfp_dp_dyadic (str)
     char *str;
d7747 1
a7747 7
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
d7749 1
a7749 1
      if (! inst.error)
a7753 12
  end_of_line (str);
}

static void
do_vfp_reg_from_sp (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

d7755 1
a7755 1
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
d7757 1
a7757 1
      if (! inst.error)
d7766 1
a7766 2
do_vfp_reg2_from_sp2 (str)
     char *str;
d7770 1
a7770 4
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL)
d7772 1
a7772 1
      if (! inst.error)
d7777 2
a7778 2
  /* We require exactly two consecutive SP registers.  */
  if (vfp_sp_reg_list (&str, VFP_REG_Sm) != 2)
d7780 3
a7782 2
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
d7788 2
a7789 3
static void
do_vfp_sp_from_reg (str)
     char *str;
d7791 13
a7803 1
  skip_whitespace (str);
d7805 1
a7805 2
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
    return;
d7807 1
a7807 2
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
d7809 41
a7849 4
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d7851 5
a7855 2
  end_of_line (str);
}
d7857 7
a7863 5
static void
do_vfp_sp2_from_reg2 (str)
     char *str;
{
  skip_whitespace (str);
d7865 4
a7868 5
  /* We require exactly two consecutive SP registers.  */
  if (vfp_sp_reg_list (&str, VFP_REG_Sm) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
d7870 1
d7872 1
a7872 4
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
d7874 2
a7875 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d7878 1
a7878 2
  end_of_line (str);
}
d7880 1
a7880 5
static void
do_vfp_reg_from_dp (str)
     char *str;
{
  skip_whitespace (str);
d7882 3
a7884 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d7886 2
a7887 2
  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
d7889 5
a7893 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d7896 2
a7897 1
  end_of_line (str);
d7901 1
a7901 2
do_vfp_reg2_from_dp (str)
     char *str;
d7903 2
d7907 1
a7907 1
  if (reg_required_here (&str, 12) == FAIL)
d7910 13
d7924 1
a7924 3
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
d7926 1
a7926 1
      if (! inst.error)
d7931 1
d7936 1
a7936 2
do_vfp_dp_from_reg (str)
     char *str;
d7938 2
d7942 1
a7942 1
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
d7945 13
d7959 1
a7959 1
      || reg_required_here (&str, 12) == FAIL)
d7961 1
a7961 1
      if (! inst.error)
d7966 4
d7974 1
a7974 2
do_vfp_dp_from_reg2 (str)
     char *str;
d7976 2
a7977 1
  skip_whitespace (str);
d7979 5
a7983 12
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d7985 4
a7988 1
  end_of_line (str);
d7991 2
a7992 3
static const struct vfp_reg *
vfp_psr_parse (str)
     char **str;
d7994 2
a7995 4
  char *start = *str;
  char  c;
  char *p;
  const struct vfp_reg *vreg;
d7997 5
a8001 1
  p = start;
d8003 4
a8006 24
  /* Find the end of the current token.  */
  do
    {
      c = *p++;
    }
  while (ISALPHA (c));

  /* Mark it.  */
  *--p = 0;

  for (vreg = vfp_regs + 0;
       vreg < vfp_regs + sizeof (vfp_regs) / sizeof (struct vfp_reg);
       vreg++)
    {
      if (strcmp (start, vreg->name) == 0)
	{
	  *p = c;
	  *str = p;
	  return vreg;
	}
    }

  *p = c;
  return NULL;
d8009 2
a8010 3
static int
vfp_psr_required_here (str)
     char **str;
d8012 1
a8012 2
  char *start = *str;
  const struct vfp_reg *vreg;
d8014 1
a8014 3
  vreg = vfp_psr_parse (str);

  if (vreg)
d8016 3
a8018 2
      inst.instruction |= vreg->regno;
      return SUCCESS;
d8021 1
a8021 4
  inst.error = _("VFP system register expected");

  *str = start;
  return FAIL;
d8025 1
a8025 2
do_vfp_reg_from_ctrl (str)
     char *str;
d8029 1
a8029 5
  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_psr_required_here (&str) == FAIL)
d8031 1
a8031 1
      if (! inst.error)
d8040 1
a8040 2
do_vfp_ctrl_from_reg (str)
     char *str;
d8044 1
a8044 1
  if (vfp_psr_required_here (&str) == FAIL)
d8048 1
a8048 1
      || reg_required_here (&str, 12) == FAIL)
d8059 1
a8059 2
do_vfp_sp_ldst (str)
     char *str;
d8064 1
a8064 5
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d8067 1
a8067 1
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
d8069 1
a8069 1
      if (!inst.error)
d8077 5
d8083 1
a8083 2
do_vfp_dp_ldst (str)
     char *str;
d8085 2
d8089 2
a8090 1
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
d8092 1
a8092 1
      if (!inst.error)
d8097 1
a8097 2
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
d8099 4
a8102 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d8104 4
d8109 16
a8124 2
  end_of_line (str);
}
d8126 3
a8128 26
/* Parse and encode a VFP SP register list, storing the initial
   register in position POS and returning the range as the result.  If
   the string is invalid return FAIL (an invalid range).  */
static long
vfp_sp_reg_list (str, pos)
     char **str;
     enum vfp_sp_reg_pos pos;
{
  long range = 0;
  int base_reg = 0;
  int new_base;
  long base_bits = 0;
  int count = 0;
  long tempinst;
  unsigned long mask = 0;
  int warned = 0;

  if (**str != '{')
    return FAIL;

  (*str)++;
  skip_whitespace (*str);

  tempinst = inst.instruction;

  do
d8130 8
a8137 1
      inst.instruction = 0;
d8139 6
a8144 2
      if ((new_base = vfp_sp_reg_required_here (str, pos)) == FAIL)
	return FAIL;
d8146 6
a8151 1
      if (count == 0 || base_reg > new_base)
d8153 2
a8154 2
	  base_reg = new_base;
	  base_bits = inst.instruction;
d8156 4
d8161 4
a8164 1
      if (mask & (1 << new_base))
d8166 2
a8167 2
	  inst.error = _("invalid register list");
	  return FAIL;
d8170 1
a8170 1
      if ((mask >> new_base) != 0 && ! warned)
d8172 5
a8176 2
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
d8178 3
d8182 2
a8183 2
      mask |= 1 << new_base;
      count++;
d8185 4
a8188 1
      skip_whitespace (*str);
d8190 11
a8200 3
      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;
d8202 21
a8222 8
	  (*str)++;

	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab))
	      == FAIL)
	    {
	      inst.error = _(all_reg_maps[REG_TYPE_SN].expected);
	      return FAIL;
d8224 1
a8224 2

	  if (high_range <= new_base)
d8226 7
a8232 2
	      inst.error = _("register range not in ascending order");
	      return FAIL;
d8234 1
a8234 2

	  for (new_base++; new_base <= high_range; new_base++)
d8236 1
a8236 1
	      if (mask & (1 << new_base))
d8238 2
a8239 2
		  inst.error = _("invalid register list");
		  return FAIL;
d8241 2
a8242 3

	      mask |= 1 << new_base;
	      count++;
a8245 1
  while (skip_past_comma (str) != FAIL);
d8247 2
a8248 5
  if (**str != '}')
    {
      inst.error = _("invalid register list");
      return FAIL;
    }
d8250 4
a8253 1
  (*str)++;
d8255 1
a8255 1
  range = count;
d8257 7
a8263 3
  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > 32)
    abort ();
d8265 9
a8273 2
  /* Final test -- the registers must be consecutive.  */
  while (count--)
d8275 11
a8285 1
      if ((mask & (1 << base_reg++)) == 0)
d8287 3
a8289 2
	  inst.error = _("non-contiguous register range");
	  return FAIL;
d8291 2
d8295 2
a8296 3
  inst.instruction = tempinst | base_bits;
  return range;
}
d8298 1
a8298 21
static long
vfp_dp_reg_list (str)
     char **str;
{
  long range = 0;
  int base_reg = 0;
  int new_base;
  int count = 0;
  long tempinst;
  unsigned long mask = 0;
  int warned = 0;

  if (**str != '{')
    return FAIL;

  (*str)++;
  skip_whitespace (*str);

  tempinst = inst.instruction;

  do
d8300 5
a8304 1
      inst.instruction = 0;
d8306 1
a8306 4
      if ((new_base = vfp_dp_reg_required_here (str, VFP_REG_Dd)) == FAIL)
	return FAIL;

      if (count == 0 || base_reg > new_base)
d8308 3
a8310 2
	  base_reg = new_base;
	  range = inst.instruction;
d8313 5
a8317 1
      if (mask & (1 << new_base))
d8319 3
a8321 2
	  inst.error = _("invalid register list");
	  return FAIL;
d8324 1
a8324 1
      if ((mask >> new_base) != 0 && ! warned)
d8326 3
a8328 2
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
d8330 1
a8330 7

      mask |= 1 << new_base;
      count++;

      skip_whitespace (*str);

      if (**str == '-') /* We have the start of a range expression */
d8332 1
a8332 1
	  int high_range;
d8334 1
a8334 5
	  (*str)++;

	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab))
	      == FAIL)
d8336 2
a8337 2
	      inst.error = _(all_reg_maps[REG_TYPE_DN].expected);
	      return FAIL;
d8340 3
a8342 5
	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }
d8344 3
a8346 7
	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}
d8348 1
a8348 3
	      mask |= 1 << new_base;
	      count++;
	    }
a8349 2
    }
  while (skip_past_comma (str) != FAIL);
d8351 1
a8351 4
  if (**str != '}')
    {
      inst.error = _("invalid register list");
      return FAIL;
d8354 2
a8355 1
  (*str)++;
d8357 4
a8360 1
  range |= 2 * count;
d8362 1
a8362 3
  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > 16)
    abort ();
d8364 2
a8365 2
  /* Final test -- the registers must be consecutive.  */
  while (count--)
d8367 3
a8369 5
      if ((mask & (1 << base_reg++)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
	}
d8372 5
a8376 3
  inst.instruction = tempinst;
  return range;
}
d8378 16
a8393 6
static void
vfp_sp_ldstm (str, ldstm_type)
     char *str;
     enum vfp_ldstm_type ldstm_type;
{
  long range;
d8395 14
a8408 1
  skip_whitespace (str);
d8410 2
a8411 2
  if (reg_required_here (&str, 16) == FAIL)
    return;
d8413 1
a8413 1
  skip_whitespace (str);
d8415 2
a8416 10
  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA)
    {
      inst.error = _("this addressing mode requires base-register writeback");
      return;
    }
d8418 1
a8418 7
  if (skip_past_comma (&str) == FAIL
      || (range = vfp_sp_reg_list (&str, VFP_REG_Sd)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d8420 6
a8425 3
  inst.instruction |= range;
  end_of_line (str);
}
d8427 4
a8430 6
static void
vfp_dp_ldstm (str, ldstm_type)
     char *str;
     enum vfp_ldstm_type ldstm_type;
{
  long range;
d8432 4
a8435 1
  skip_whitespace (str);
d8437 7
a8443 2
  if (reg_required_here (&str, 16) == FAIL)
    return;
d8445 5
a8449 1
  skip_whitespace (str);
d8451 1
a8451 4
  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
d8453 1
a8453 1
  else if (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX)
d8455 8
a8462 1
      inst.error = _("this addressing mode requires base-register writeback");
d8466 1
a8466 2
  if (skip_past_comma (&str) == FAIL
      || (range = vfp_dp_reg_list (&str)) == FAIL)
d8468 15
a8482 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d8484 6
a8489 2
  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    range += 1;
d8491 4
a8494 3
  inst.instruction |= range;
  end_of_line (str);
}
d8496 5
a8500 6
static void
do_vfp_sp_ldstmia (str)
     char *str;
{
  vfp_sp_ldstm (str, VFP_LDSTMIA);
}
d8502 6
a8507 42
static void
do_vfp_sp_ldstmdb (str)
     char *str;
{
  vfp_sp_ldstm (str, VFP_LDSTMDB);
}

static void
do_vfp_dp_ldstmia (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMIA);
}

static void
do_vfp_dp_ldstmdb (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMDB);
}

static void
do_vfp_xp_ldstmia (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMIAX);
}

static void
do_vfp_xp_ldstmdb (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMDBX);
}

static void
do_vfp_sp_compare_z (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
d8509 1
a8509 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d8512 12
d8525 1
a8525 2
  end_of_line (str);
}
d8527 3
a8529 5
static void
do_vfp_dp_compare_z (str)
     char *str;
{
  skip_whitespace (str);
d8531 11
a8541 1
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
d8543 12
a8554 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d8560 1
a8560 5
static void
do_vfp_dp_sp_cvt (str)
     char *str;
{
  skip_whitespace (str);
d8562 1
a8562 2
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;
d8564 2
a8565 7
  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d8567 2
a8568 6
  end_of_line (str);
}

static void
do_vfp_sp_dp_cvt (str)
     char *str;
d8570 2
a8571 1
  skip_whitespace (str);
d8573 1
a8573 5
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
d8575 2
a8576 15
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

/* Thumb specific routines.  */

/* Parse and validate that a register is of the right form, this saves
   repeated checking of this information in many similar cases.
   Unlike the 32-bit case we do not insert the register into the opcode
   here, since the position is often unknown until the full instruction
   has been parsed.  */
d8578 2
a8579 6
static int
thumb_reg (strp, hi_lo)
     char ** strp;
     int     hi_lo;
{
  int reg;
d8581 2
a8582 2
  if ((reg = reg_required_here (strp, -1)) == FAIL)
    return FAIL;
d8584 5
a8588 1
  switch (hi_lo)
d8590 1
a8590 2
    case THUMB_REG_LO:
      if (reg > 7)
d8592 2
a8593 4
	  inst.error = _("lo register required");
	  return FAIL;
	}
      break;
d8595 1
a8595 5
    case THUMB_REG_HI:
      if (reg < 8)
	{
	  inst.error = _("hi register required");
	  return FAIL;
a8596 1
      break;
d8598 2
a8599 2
    default:
      break;
d8602 5
a8606 1
  return reg;
d8609 3
a8611 2
/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode
   was SUB.  */
d8614 4
a8617 3
thumb_add_sub (str, subtract)
     char * str;
     int    subtract;
d8619 4
a8622 1
  int Rd, Rs, Rn = FAIL;
d8626 3
a8628 2
  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
d8630 1
a8630 1
      if (! inst.error)
a8631 1
      return;
d8633 3
d8637 22
a8658 1
  if (is_immediate_prefix (*str))
d8660 2
a8661 4
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d8664 2
a8665 3
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d8667 1
a8667 16
      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
    }
d8669 5
a8673 12
  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
  if (Rn != FAIL)
    {
      /* All register format.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
	{
	  if (Rs != Rd)
	    {
	      inst.error = _("dest and source1 must be the same register");
	      return;
	    }
d8675 5
a8679 6
	  /* Can't do this for SUB.  */
	  if (subtract)
	    {
	      inst.error = _("subtract valid only on lo regs");
	      return;
	    }
d8681 5
a8685 14
	  inst.instruction = (T_OPCODE_ADD_HI
			      | (Rd > 7 ? THUMB_H1 : 0)
			      | (Rn > 7 ? THUMB_H2 : 0));
	  inst.instruction |= (Rd & 7) | ((Rn & 7) << 3);
	}
      else
	{
	  inst.instruction = subtract ? T_OPCODE_SUB_R3 : T_OPCODE_ADD_R3;
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
    }
  else
    {
      /* Immediate expression, now things start to get nasty.  */
d8687 5
a8691 8
      /* First deal with HI regs, only very restricted cases allowed:
	 Adjusting SP, and using PC or SP to get an address.  */
      if ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
	  || (Rs > 7 && Rs != REG_SP && Rs != REG_PC))
	{
	  inst.error = _("invalid Hi register with immediate");
	  return;
	}
d8693 5
a8697 11
      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, all we can do is store all the fragments
	     we know about in the instruction and let the reloc hacking
	     work it all out.  */
	  inst.instruction = (subtract ? 0x8000 : 0) | (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	}
      else
	{
	  int offset = inst.reloc.exp.X_add_number;
d8699 5
a8703 2
	  if (subtract)
	    offset = - offset;
d8705 5
a8709 4
	  if (offset < 0)
	    {
	      offset = - offset;
	      subtract = 1;
d8711 5
a8715 11
	      /* Quick check, in case offset is MIN_INT.  */
	      if (offset < 0)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	    }
	  /* Note - you cannot convert a subtract of 0 into an
	     add of 0 because the carry flag is set differently.  */
	  else if (offset > 0)
	    subtract = 0;
d8717 5
a8721 44
	  if (Rd == REG_SP)
	    {
	      if (offset & ~0x1fc)
		{
		  inst.error = _("invalid immediate value for stack adjust");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	      inst.instruction |= offset >> 2;
	    }
	  else if (Rs == REG_PC || Rs == REG_SP)
	    {
	      if (subtract
		  || (offset & ~0x3fc))
		{
		  inst.error = _("invalid immediate for address calculation");
		  return;
		}
	      inst.instruction = (Rs == REG_PC ? T_OPCODE_ADD_PC
				  : T_OPCODE_ADD_SP);
	      inst.instruction |= (Rd << 8) | (offset >> 2);
	    }
	  else if (Rs == Rd)
	    {
	      if (offset & ~0xff)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	      inst.instruction |= (Rd << 8) | offset;
	    }
	  else
	    {
	      if (offset & ~0x7)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	      inst.instruction |= Rd | (Rs << 3) | (offset << 6);
	    }
	}
    }
d8723 4
a8726 1
  end_of_line (str);
d8730 1
a8730 3
thumb_shift (str, shift)
     char * str;
     int    shift;
d8732 2
a8733 1
  int Rd, Rs, Rn = FAIL;
d8735 5
a8739 1
  skip_whitespace (str);
d8741 5
a8745 7
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d8747 5
a8751 12
  if (is_immediate_prefix (*str))
    {
      /* Two operand immediate format, set Rs to Rd.  */
      Rs = Rd;
      str ++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
d8753 5
a8757 16
      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
    }
d8759 5
a8763 2
  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
d8765 5
a8769 7
  if (Rn != FAIL)
    {
      if (Rs != Rd)
	{
	  inst.error = _("source1 and dest must be same register");
	  return;
	}
d8771 5
a8775 6
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_R; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_R; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_R; break;
	}
d8777 5
a8781 10
      inst.instruction |= Rd | (Rn << 3);
    }
  else
    {
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_I; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_I; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_I; break;
	}
d8783 5
a8787 9
      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, create a dummy reloc and let reloc
	     hacking fix it up.  */
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	}
      else
	{
	  unsigned shift_value = inst.reloc.exp.X_add_number;
d8789 5
a8793 5
	  if (shift_value > 32 || (shift_value == 32 && shift == THUMB_LSL))
	    {
	      inst.error = _("invalid immediate for shift");
	      return;
	    }
d8795 5
a8799 3
	  /* Shifts of zero are handled by converting to LSL.  */
	  if (shift_value == 0)
	    inst.instruction = T_OPCODE_LSL_I;
d8801 5
a8805 3
	  /* Shifts of 32 are encoded as a shift of zero.  */
	  if (shift_value == 32)
	    shift_value = 0;
d8807 5
a8811 2
	  inst.instruction |= shift_value << 6;
	}
d8813 5
a8817 2
      inst.instruction |= Rd | (Rs << 3);
    }
d8819 4
a8822 1
  end_of_line (str);
d8826 1
a8826 3
thumb_mov_compare (str, move)
     char * str;
     int    move;
d8828 2
a8829 1
  int Rd, Rs = FAIL;
d8831 5
a8835 1
  skip_whitespace (str);
d8837 5
a8841 7
  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d8843 5
a8847 8
  if (move != THUMB_CPY && is_immediate_prefix (*str))
    {
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;
d8849 5
a8853 18
  if (Rs != FAIL)
    {
      if (move != THUMB_CPY && Rs < 8 && Rd < 8)
	{
	  if (move == THUMB_MOVE)
	    /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	       since a MOV instruction produces unpredictable results.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;
	  inst.instruction |= Rd | (Rs << 3);
	}
      else
	{
	  if (move == THUMB_MOVE)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else if (move != THUMB_CPY)
	    inst.instruction = T_OPCODE_CMP_HR;
d8855 5
a8859 2
	  if (Rd > 7)
	    inst.instruction |= THUMB_H1;
d8861 2
a8862 2
	  if (Rs > 7)
	    inst.instruction |= THUMB_H2;
d8864 9
a8872 10
	  inst.instruction |= (Rd & 7) | ((Rs & 7) << 3);
	}
    }
  else
    {
      if (Rd > 7)
	{
	  inst.error = _("only lo regs allowed with immediate");
	  return;
	}
d8874 4
a8877 4
      if (move == THUMB_MOVE)
	inst.instruction = T_OPCODE_MOV_I8;
      else
	inst.instruction = T_OPCODE_CMP_I8;
d8879 1
a8879 1
      inst.instruction |= Rd << 8;
d8881 10
a8890 14
      if (inst.reloc.exp.X_op != O_constant)
	inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
      else
	{
	  unsigned value = inst.reloc.exp.X_add_number;

	  if (value > 255)
	    {
	      inst.error = _("invalid immediate");
	      return;
	    }

	  inst.instruction |= value;
	}
d8892 3
d8896 5
a8900 1
  end_of_line (str);
d8904 1
a8904 4
thumb_load_store (str, load_store, size)
     char * str;
     int    load_store;
     int    size;
d8906 3
a8908 1
  int Rd, Rb, Ro = FAIL;
d8910 4
d8916 4
a8919 2
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
d8921 1
a8921 1
      if (! inst.error)
d8923 1
d8927 2
a8928 5
  if (*str == '[')
    {
      str++;
      if ((Rb = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d8930 5
a8934 16
      if (skip_past_comma (&str) != FAIL)
	{
	  if (is_immediate_prefix (*str))
	    {
	      str++;
	      if (my_get_expression (&inst.reloc.exp, &str))
		return;
	    }
	  else if ((Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	    return;
	}
      else
	{
	  inst.reloc.exp.X_op = O_constant;
	  inst.reloc.exp.X_add_number = 0;
	}
d8936 4
a8939 8
      if (*str != ']')
	{
	  inst.error = _("expected ']'");
	  return;
	}
      str++;
    }
  else if (*str == '=')
d8941 2
a8942 5
      if (load_store != THUMB_LOAD)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}
d8944 2
a8945 2
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d8947 2
a8948 1
      skip_whitespace (str);
d8950 3
a8952 2
      if (my_get_expression (& inst.reloc.exp, & str))
	return;
d8954 7
a8960 1
      end_of_line (str);
d8962 1
a8962 6
      if (   inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = "Constant expression expected";
	  return;
	}
d8964 1
a8964 4
      if (inst.reloc.exp.X_op == O_constant
	  && ((inst.reloc.exp.X_add_number & ~0xFF) == 0))
	{
	  /* This can be done with a mov instruction.  */
d8966 9
a8974 4
	  inst.instruction  = T_OPCODE_MOV_I8 | (Rd << 8);
	  inst.instruction |= inst.reloc.exp.X_add_number;
	  return;
	}
d8976 3
a8978 7
      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = "literal pool insertion failed";
	  return;
	}
d8980 2
a8981 5
      inst.reloc.type   = BFD_RELOC_ARM_THUMB_OFFSET;
      inst.reloc.pc_rel = 1;
      inst.instruction  = T_OPCODE_LDR_PC | (Rd << 8);
      /* Adjust ARM pipeline offset to Thumb.  */
      inst.reloc.exp.X_add_number += 4;
d8983 1
a8983 3
      return;
    }
  else
d8985 1
a8985 8
      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      inst.instruction = T_OPCODE_LDR_PC | (Rd << 8);
      inst.reloc.pc_rel = 1;
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset.  */
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      end_of_line (str);
d8989 1
a8989 1
  if (Rb == REG_PC || Rb == REG_SP)
d8991 3
a8993 15
      if (size != THUMB_WORD)
	{
	  inst.error = _("byte or halfword not valid for base register");
	  return;
	}
      else if (Rb == REG_PC && load_store != THUMB_LOAD)
	{
	  inst.error = _("r15 based store not allowed");
	  return;
	}
      else if (Ro != FAIL)
	{
	  inst.error = _("invalid base register for register offset");
	  return;
	}
d8995 2
a8996 6
      if (Rb == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (load_store == THUMB_LOAD)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;
d8998 1
a8998 17
      inst.instruction |= Rd << 8;
      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~0x3fc)
	    {
	      inst.error = _("invalid offset");
	      return;
	    }

	  inst.instruction |= offset >> 2;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else if (Rb > 7)
d9000 1
a9000 1
      inst.error = _("invalid base register in load/store");
d9003 3
a9005 1
  else if (Ro == FAIL)
d9007 3
a9009 10
      /* Immediate offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IW : T_OPCODE_STR_IW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IH : T_OPCODE_STR_IH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IB : T_OPCODE_STR_IB);
d9011 4
a9014 1
      inst.instruction |= Rd | (Rb << 3);
d9016 3
a9018 3
      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;
d9020 5
a9024 22
	  if (offset & ~(0x1f << size))
	    {
	      inst.error = _("invalid offset");
	      return;
	    }
	  inst.instruction |= (offset >> size) << 6;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else
    {
      /* Register offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RW : T_OPCODE_STR_RW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RH : T_OPCODE_STR_RH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RB : T_OPCODE_STR_RB);
d9026 4
a9029 4
      inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
    }

  end_of_line (str);
d9032 5
a9036 1
/* A register must be given at this point.
d9038 1
a9038 1
   Shift is the place to put it in inst.instruction.
d9040 1
a9040 2
   Restores input start point on err.
   Returns the reg#, or FAIL.  */
d9042 2
a9043 8
static int
mav_reg_required_here (str, shift, regtype)
     char ** str;
     int shift;
     enum arm_reg_type regtype;
{
  int   reg;
  char *start = *str;
d9045 1
a9045 1
  if ((reg = arm_reg_parse (str, all_reg_maps[regtype].htab)) != FAIL)
d9047 3
a9049 2
      if (shift >= 0)
	inst.instruction |= reg << shift;
d9051 4
a9054 1
      return reg;
d9057 2
a9058 2
  /* Restore the start point.  */
  *str = start;
d9060 6
a9065 5
  /* Try generic coprocessor name if applicable.  */
  if (regtype == REG_TYPE_MVF ||
      regtype == REG_TYPE_MVD ||
      regtype == REG_TYPE_MVFX ||
      regtype == REG_TYPE_MVDX)
d9067 2
a9068 10
      if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_CN].htab)) != FAIL)
	{
	  if (shift >= 0)
	    inst.instruction |= reg << shift;

	  return reg;
	}

      /* Restore the start point.  */
      *str = start;
d9071 1
a9071 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[regtype].expected);
d9073 1
a9073 1
  return FAIL;
d9076 3
a9078 3
/* Cirrus Maverick Instructions.  */

/* Wrapper functions.  */
d9081 1
a9081 2
do_mav_binops_1a (str)
     char * str;
d9083 1
a9083 2
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVF);
}
d9085 1
a9085 6
static void
do_mav_binops_1b (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVD);
}
d9087 5
a9091 6
static void
do_mav_binops_1c (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVDX);
}
d9093 4
a9096 6
static void
do_mav_binops_1d (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVF);
}
d9098 1
a9098 6
static void
do_mav_binops_1e (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVD);
}
d9100 2
a9101 6
static void
do_mav_binops_1f (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVF);
}
d9103 5
a9107 6
static void
do_mav_binops_1g (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVD);
}
d9109 14
a9122 6
static void
do_mav_binops_1h (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVFX);
}
d9124 3
a9126 6
static void
do_mav_binops_1i (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVFX);
}
d9128 2
a9129 6
static void
do_mav_binops_1j (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVDX);
}
d9131 4
a9134 6
static void
do_mav_binops_1k (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVDX);
}
d9136 3
a9138 6
static void
do_mav_binops_1l (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVF);
}
d9140 3
a9142 5
static void
do_mav_binops_1m (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVD);
d9146 1
a9146 2
do_mav_binops_1n (str)
     char * str;
d9148 1
a9148 1
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVFX);
d9152 1
a9152 2
do_mav_binops_1o (str)
     char * str;
d9154 1
a9154 1
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVDX, REG_TYPE_MVDX);
d9158 1
a9158 2
do_mav_binops_2a (str)
     char * str;
d9160 1
a9160 1
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVF, REG_TYPE_RN);
d9164 1
a9164 2
do_mav_binops_2b (str)
     char * str;
d9166 1
a9166 1
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVD, REG_TYPE_RN);
d9170 1
a9170 2
do_mav_binops_2c (str)
     char * str;
d9172 2
a9173 1
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVDX, REG_TYPE_RN);
d9176 3
a9178 6
static void
do_mav_binops_3a (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVFX);
}
d9181 1
a9181 2
do_mav_binops_3b (str)
     char * str;
d9183 1
a9183 2
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVFX, REG_TYPE_MVAX);
}
d9185 1
a9185 6
static void
do_mav_binops_3c (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVDX);
}
d9187 7
a9193 6
static void
do_mav_binops_3d (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVDX, REG_TYPE_MVAX);
}
d9195 13
a9207 6
static void
do_mav_triple_4a (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_RN);
}
d9209 2
a9210 6
static void
do_mav_triple_4b (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_RN);
}
d9212 7
a9218 6
static void
do_mav_triple_5a (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVF, REG_TYPE_MVF);
}
d9220 3
a9222 6
static void
do_mav_triple_5b (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVD, REG_TYPE_MVD);
}
d9224 2
a9225 5
static void
do_mav_triple_5c (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVFX, REG_TYPE_MVFX);
d9229 1
a9229 2
do_mav_triple_5d (str)
     char * str;
d9231 1
a9231 8
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static void
do_mav_triple_5e (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVF, REG_TYPE_MVF, REG_TYPE_MVF);
d9235 1
a9235 2
do_mav_triple_5f (str)
     char * str;
d9237 1
a9237 1
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVD, REG_TYPE_MVD, REG_TYPE_MVD);
d9241 1
a9241 2
do_mav_triple_5g (str)
     char * str;
d9243 5
a9247 1
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_MVFX);
d9251 1
a9251 2
do_mav_triple_5h (str)
     char * str;
d9253 5
a9257 1
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_MVDX);
d9260 4
a9263 3
static void
do_mav_quad_6a (str)
     char * str;
d9265 30
a9294 2
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVFX, REG_TYPE_MVFX,
	       REG_TYPE_MVFX);
d9298 1
a9298 2
do_mav_quad_6b (str)
     char * str;
d9300 17
a9316 2
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVAX, REG_TYPE_MVFX,
	       REG_TYPE_MVFX);
a9318 1
/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
d9320 1
a9320 2
do_mav_dspsc_1 (str)
     char * str;
d9322 2
d9326 5
a9330 7
  /* cfmvsc32.  */
  if (mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
d9332 3
a9334 2
      return;
    }
a9338 1
/* cfmv32sc<cond> MVDX[15:0],DSPSC.  */
d9340 7
a9346 2
do_mav_dspsc_2 (str)
     char * str;
d9348 3
d9353 10
a9362 4
  /* cfmv32sc.  */
  if (mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL)
d9364 1
a9364 1
      if (!inst.error)
d9366 10
d9377 3
d9383 1
d9388 1
a9388 2
do_mav_shift_1 (str)
     char * str;
d9390 1
a9390 1
  do_mav_shift (str, REG_TYPE_MVFX, REG_TYPE_MVFX);
d9394 1
a9394 2
do_mav_shift_2 (str)
     char * str;
d9396 1
a9396 1
  do_mav_shift (str, REG_TYPE_MVDX, REG_TYPE_MVDX);
d9400 1
a9400 2
do_mav_ldst_1 (str)
     char * str;
d9402 1
a9402 1
  do_mav_ldst (str, REG_TYPE_MVF);
d9406 1
a9406 2
do_mav_ldst_2 (str)
     char * str;
d9408 19
a9426 1
  do_mav_ldst (str, REG_TYPE_MVD);
d9430 1
a9430 2
do_mav_ldst_3 (str)
     char * str;
d9432 1
a9432 1
  do_mav_ldst (str, REG_TYPE_MVFX);
d9436 1
a9436 2
do_mav_ldst_4 (str)
     char * str;
d9438 1
a9438 1
  do_mav_ldst (str, REG_TYPE_MVDX);
d9441 5
a9445 1
/* Isnsn like "foo X,Y".  */
d9448 1
a9448 5
do_mav_binops (str, mode, reg0, reg1)
     char * str;
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
d9450 1
a9450 4
  int shift0, shift1;

  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
d9454 1
a9454 3
  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL)
d9456 1
a9456 1
      if (!inst.error)
d9458 1
a9459 3
  else
    end_of_line (str);
}
d9461 7
a9467 1
/* Isnsn like "foo X,Y,Z".  */
d9469 1
a9469 21
static void
do_mav_triple (str, mode, reg0, reg1, reg2)
     char * str;
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
     enum arm_reg_type reg2;
{
  int shift0, shift1, shift2;

  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL)
d9471 13
a9483 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d9485 3
a9487 2
  else
    end_of_line (str);
d9490 5
a9494 2
/* Isnsn like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */
d9497 1
a9497 7
do_mav_quad (str, mode, reg0, reg1, reg2, reg3)
     char * str;
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
     enum arm_reg_type reg2;
     enum arm_reg_type reg3;
d9499 2
a9500 1
  int shift0, shift1, shift2, shift3;
d9502 5
a9506 4
  shift0= mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;
  shift3 = (mode >> 24) & 0xff;
d9508 4
a9511 15
  skip_whitespace (str);

  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift3, reg3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
d9514 11
a9524 3
/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */
d9527 1
a9527 4
do_mav_shift (str, reg0, reg1)
     char * str;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
d9529 1
a9529 2
  int error;
  int imm, neg = 0;
d9531 2
d9535 3
a9537 3
  error = 0;

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
d9539 1
a9539 2
      || mav_reg_required_here (&str, 16, reg1) == FAIL
      || skip_past_comma  (&str) == FAIL)
d9546 4
a9549 3
  /* Calculate the immediate operand.
     The operand is a 7bit signed number.  */
  skip_whitespace (str);
d9551 2
a9552 2
  if (*str == '#')
    ++str;
d9554 8
a9561 5
  if (!ISDIGIT (*str) && *str != '-')
    {
      inst.error = _("expecting immediate, 7bit operand");
      return;
    }
d9563 3
a9565 5
  if (*str == '-')
    {
      neg = 1;
      ++str;
    }
d9567 1
a9567 2
  for (imm = 0; *str && ISDIGIT (*str); ++str)
    imm = imm * 10 + *str - '0';
d9569 2
a9570 5
  if (imm > 64)
    {
      inst.error = _("immediate out of range");
      return;
    }
d9572 1
a9572 6
  /* Make negative imm's into 7bit signed numbers.  */
  if (neg)
    {
      imm = -imm;
      imm &= 0x0000007f;
    }
d9574 2
a9575 7
  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.  */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);

  inst.instruction |= imm;
  end_of_line (str);
d9578 2
a9579 4
static int
mav_parse_offset (str, negative)
     char ** str;
     int *negative;
d9581 1
a9581 2
  char * p = *str;
  int offset;
d9583 2
a9584 1
  *negative = 0;
d9586 3
a9588 1
  skip_whitespace (p);
d9590 8
a9597 2
  if (*p == '#')
    ++p;
d9599 1
a9599 5
  if (*p == '-')
    {
      *negative = 1;
      ++p;
    }
d9601 3
a9603 5
  if (!ISDIGIT (*p))
    {
      inst.error = _("offset expected");
      return 0;
    }
d9605 2
a9606 4
  for (offset = 0; *p && ISDIGIT (*p); ++p)
    offset = offset * 10 + *p - '0';

  if (offset > 0x3fc)
d9608 4
a9611 7
      inst.error = _("offset out of range");
      return 0;
    }
  if (offset & 0x3)
    {
      inst.error = _("offset not a multiple of 4");
      return 0;
d9613 1
d9615 1
a9615 1
  *str = p;
d9617 1
a9617 2
  return *negative ? -offset : offset;
}
d9619 2
a9620 3
/* Maverick load/store instructions.
  <insn><cond> CRd,[Rn,<offset>]{!}.
  <insn><cond> CRd,[Rn],<offset>.  */
d9622 2
a9623 4
static void
do_mav_ldst (str, reg0)
     char * str;
     enum arm_reg_type reg0;
d9625 2
a9626 1
  int offset, negative;
d9628 2
a9629 1
  skip_whitespace (str);
d9631 2
a9632 5
  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || reg_required_here (&str, 16) == FAIL)
    goto fail_ldst;
d9634 1
a9634 1
  if (skip_past_comma (&str) == SUCCESS)
d9636 2
a9637 2
      /* You are here: "<offset>]{!}".  */
      inst.instruction |= PRE_INDEX;
d9639 4
a9642 1
      offset = mav_parse_offset (&str, &negative);
d9644 2
a9645 2
      if (inst.error)
	return;
d9647 3
a9649 5
      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}
d9651 1
a9651 1
      if (*str == '!')
d9653 3
a9655 12
	  inst.instruction |= WRITE_BACK;
	  ++str;
	}
    }
  else
    {
      /* You are here: "], <offset>".  */
      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}
d9657 3
a9659 3
      if (skip_past_comma (&str) == FAIL
	  || (offset = mav_parse_offset (&str, &negative), inst.error))
	goto fail_ldst;
d9661 1
a9661 2
      inst.instruction |= CP_T_WB; /* Post indexed, set bit W.  */
    }
d9663 24
a9686 33
  if (negative)
    offset = -offset;
  else
    inst.instruction |= CP_T_UD; /* Positive, so set bit U.  */

  inst.instruction |= offset >> 2;
  end_of_line (str);
  return;

fail_ldst:
  if (!inst.error)
     inst.error = BAD_ARGS;
}

static void
do_t_nop (str)
     char * str;
{
  /* Do nothing.  */
  end_of_line (str);
}

/* Handle the Format 4 instructions that do not have equivalents in other
   formats.  That is, ADC, AND, EOR, SBC, ROR, TST, NEG, CMN, ORR, MUL,
   BIC and MVN.  */

static void
do_t_arit (str)
     char * str;
{
  int Rd, Rs, Rn;

  skip_whitespace (str);
d9688 1
a9688 20
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) != FAIL)
    {
      /* Three operand format not allowed for TST, CMN, NEG and MVN.
	 (It isn't allowed for CMP either, but that isn't handled by this
	 function.)  */
      if (inst.instruction == T_OPCODE_TST
	  || inst.instruction == T_OPCODE_CMN
	  || inst.instruction == T_OPCODE_NEG
	  || inst.instruction == T_OPCODE_MVN)
	{
	  inst.error = BAD_ARGS;
	  return;
d9690 2
d9693 2
a9694 9
      if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (Rs != Rd)
	{
	  inst.error = _("dest and source1 must be the same register");
	  return;
	}
      Rs = Rn;
d9697 2
a9698 6
  if (inst.instruction == T_OPCODE_MUL
      && Rs == Rd)
    as_tsktsk (_("Rs and Rd must be different in MUL"));

  inst.instruction |= Rd | (Rs << 3);
  end_of_line (str);
d9702 1
a9702 2
do_t_add (str)
     char * str;
d9704 5
a9708 1
  thumb_add_sub (str, 0);
d9711 2
a9712 3
static void
do_t_asr (str)
     char * str;
d9714 39
a9752 2
  thumb_shift (str, THUMB_ASR);
}
d9754 8
a9761 10
static void
do_t_branch9 (str)
     char * str;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}
d9763 8
a9770 10
static void
do_t_branch12 (str)
     char * str;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}
d9772 8
a9779 1
/* Find the real, Thumb encoded start of a Thumb function.  */
d9781 9
a9789 7
static symbolS *
find_real_start (symbolP)
     symbolS * symbolP;
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;
d9791 4
a9794 2
  /* This definition must agree with the one in gcc/config/arm/thumb.c.  */
#define STUB_NAME ".real_start_of"
d9796 5
a9800 2
  if (name == NULL)
    abort ();
d9802 8
a9809 5
  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.  */
  if (name[0] == '.')
    return symbolP;
d9811 3
a9813 2
  real_start = malloc (strlen (name) + strlen (STUB_NAME) + 1);
  sprintf (real_start, "%s%s", STUB_NAME, name);
d9815 6
a9820 1
  new_target = symbol_find (real_start);
d9822 9
a9830 5
  if (new_target == NULL)
    {
      as_warn ("Failed to find real start of function: %s\n", name);
      new_target = symbolP;
    }
d9832 5
a9836 1
  free (real_start);
d9838 4
a9841 2
  return new_target;
}
d9843 13
a9855 6
static void
do_t_branch23 (str)
     char * str;
{
  if (my_get_expression (& inst.reloc.exp, & str))
    return;
d9857 5
a9861 3
  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
d9863 2
a9864 11
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (   inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
}
d9866 4
a9869 5
static void
do_t_bx (str)
     char * str;
{
  int reg;
d9871 4
a9874 1
  skip_whitespace (str);
d9876 2
a9877 2
  if ((reg = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;
d9879 4
a9882 2
  /* This sets THUMB_H2 from the top bit of reg.  */
  inst.instruction |= reg << 3;
d9884 4
a9887 3
  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.  The reloc
     should cause the alignment to be checked once it is known.  This is
     because BX PC only works if the instruction is word aligned.  */
d9889 2
a9890 2
  end_of_line (str);
}
d9892 2
a9893 6
static void
do_t_compare (str)
     char * str;
{
  thumb_mov_compare (str, THUMB_COMPARE);
}
d9895 100
a9994 6
static void
do_t_ldmstm (str)
     char * str;
{
  int Rb;
  long range;
d9996 5
a10000 1
  skip_whitespace (str);
d10002 4
a10005 2
  if ((Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    return;
d10007 4
a10010 4
  if (*str != '!')
    as_warn (_("inserted missing '!': load/store multiple always writes back base register"));
  else
    str++;
d10012 12
a10023 7
  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10025 12
a10036 7
  if (inst.reloc.type != BFD_RELOC_NONE)
    {
      /* This really doesn't seem worth it.  */
      inst.reloc.type = BFD_RELOC_NONE;
      inst.error = _("expression too complex");
      return;
    }
d10038 12
a10049 5
  if (range & ~0xff)
    {
      inst.error = _("only lo-regs valid in load/store multiple");
      return;
    }
d10051 12
a10062 3
  inst.instruction |= (Rb << 8) | range;
  end_of_line (str);
}
d10064 12
a10075 6
static void
do_t_ldr (str)
     char * str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_WORD);
}
d10077 12
a10088 6
static void
do_t_ldrb (str)
     char * str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_BYTE);
}
d10090 12
a10101 6
static void
do_t_ldrh (str)
     char * str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_HALFWORD);
}
d10103 12
a10114 5
static void
do_t_lds (str)
     char * str;
{
  int Rd, Rb, Ro;
d10116 12
a10127 1
  skip_whitespace (str);
d10129 12
a10140 12
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || (Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || *str++ != ']')
    {
      if (! inst.error)
	inst.error = _("syntax: ldrs[b] Rd, [Rb, Ro]");
      return;
    }
d10142 12
a10153 3
  inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
  end_of_line (str);
}
d10155 12
a10166 6
static void
do_t_lsl (str)
     char * str;
{
  thumb_shift (str, THUMB_LSL);
}
d10168 12
a10179 6
static void
do_t_lsr (str)
     char * str;
{
  thumb_shift (str, THUMB_LSR);
}
d10181 12
a10192 6
static void
do_t_mov (str)
     char * str;
{
  thumb_mov_compare (str, THUMB_MOVE);
}
d10194 12
a10205 5
static void
do_t_push_pop (str)
     char * str;
{
  long range;
d10207 12
a10218 1
  skip_whitespace (str);
d10220 12
a10231 6
  if ((range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10233 12
a10244 7
  if (inst.reloc.type != BFD_RELOC_NONE)
    {
      /* This really doesn't seem worth it.  */
      inst.reloc.type = BFD_RELOC_NONE;
      inst.error = _("expression too complex");
      return;
    }
d10246 12
a10257 16
  if (range & ~0xff)
    {
      if ((inst.instruction == T_OPCODE_PUSH
	   && (range & ~0xff) == 1 << REG_LR)
	  || (inst.instruction == T_OPCODE_POP
	      && (range & ~0xff) == 1 << REG_PC))
	{
	  inst.instruction |= THUMB_PP_PC_LR;
	  range &= 0xff;
	}
      else
	{
	  inst.error = _("invalid register list to push/pop instruction");
	  return;
	}
    }
d10259 12
a10270 3
  inst.instruction |= range;
  end_of_line (str);
}
d10272 12
a10283 6
static void
do_t_str (str)
     char * str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_WORD);
}
d10285 12
a10296 6
static void
do_t_strb (str)
     char * str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_BYTE);
}
d10298 12
a10309 6
static void
do_t_strh (str)
     char * str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_HALFWORD);
}
d10311 12
a10322 6
static void
do_t_sub (str)
     char * str;
{
  thumb_add_sub (str, 1);
}
d10324 12
a10335 5
static void
do_t_swi (str)
     char * str;
{
  skip_whitespace (str);
d10337 12
a10348 2
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
d10350 12
a10361 3
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  end_of_line (str);
}
d10363 12
a10374 5
static void
do_t_adr (str)
     char * str;
{
  int reg;
d10376 12
a10387 3
  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-4".  */
  skip_whitespace (str);
d10389 9
a10397 10
  /* Store Rd in temporary location inside instruction.  */
  if ((reg = reg_required_here (&str, 4)) == FAIL
      || (reg > 7)  /* For Thumb reg must be r0..r7.  */
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10399 12
a10410 4
  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;
  inst.instruction |= REG_PC; /* Rd is already placed into the instruction.  */
d10412 18
a10429 2
  end_of_line (str);
}
d10431 7
a10437 9
static void
insert_reg (r, htab)
     const struct reg_entry *r;
     struct hash_control *htab;
{
  int    len  = strlen (r->name) + 2;
  char * buf  = (char *) xmalloc (len);
  char * buf2 = (char *) xmalloc (len);
  int    i    = 0;
d10439 14
a10452 3
#ifdef REGISTER_PREFIX
  buf[i++] = REGISTER_PREFIX;
#endif
d10454 19
a10472 1
  strcpy (buf + i, r->name);
d10474 4
a10477 2
  for (i = 0; buf[i]; i++)
    buf2[i] = TOUPPER (buf[i]);
d10479 10
a10488 1
  buf2[i] = '\0';
d10490 5
a10494 12
  hash_insert (htab, buf,  (PTR) r);
  hash_insert (htab, buf2, (PTR) r);
}

static void
build_reg_hsh (map)
     struct reg_map *map;
{
  const struct reg_entry *r;

  if ((map->htab = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));
d10496 15
a10510 3
  for (r = map->names; r->name != NULL; r++)
    insert_reg (r, map->htab);
}
d10512 11
a10522 15
static void
insert_reg_alias (str, regnum, htab)
     char *str;
     int regnum;
     struct hash_control *htab;
{
  const char *error;
  struct reg_entry *new = xmalloc (sizeof (struct reg_entry));
  const char *name = xmalloc (strlen (str) + 1);
  
  strcpy ((char *) name, str);
  
  new->name = name;
  new->number = regnum;
  new->builtin = FALSE;
d10524 4
a10527 9
  error = hash_insert (htab, name, (PTR) new);
  if (error)
    {
      as_bad (_("failed to create an alias for %s, reason: %s"),
	    str, error);
      free ((char *) name);
      free (new);
    }
}
d10529 10
a10538 1
/* Look for the .req directive.  This is of the form:
d10540 5
a10544 1
   	new_register_name .req existing_register_name
d10546 5
a10550 9
   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return non-zero.  Otherwise return zero.  */
static int
create_register_alias (newname, p)
     char *newname;
     char *p;
{
  char *q;
  char c;
d10552 9
a10560 2
  q = p;
  skip_whitespace (q);
d10562 163
a10724 7
  c = *p;
  *p = '\0';

  if (*q && !strncmp (q, ".req ", 5))
    {
      char *copy_of_str;
      char *r;
d10726 78
a10803 4
#ifndef IGNORE_OPCODE_CASE
      newname = original_case_string;
#endif
      copy_of_str = newname;
d10805 1
a10805 66
      q += 4;
      skip_whitespace (q);

      for (r = q; *r != '\0'; r++)
	if (*r == ' ')
	  break;

      if (r != q)
	{
	  enum arm_reg_type new_type, old_type;
	  int old_regno;
	  char d = *r;

	  *r = '\0';
	  old_type = arm_reg_parse_any (q);
	  *r = d;

	  new_type = arm_reg_parse_any (newname);

	  if (new_type == REG_TYPE_MAX)
	    {
	      if (old_type != REG_TYPE_MAX)
		{
		  old_regno = arm_reg_parse (&q, all_reg_maps[old_type].htab);
		  insert_reg_alias (newname, old_regno,
				    all_reg_maps[old_type].htab);
		}
	      else
		as_warn (_("register '%s' does not exist\n"), q);
	    }
	  else if (old_type == REG_TYPE_MAX)
	    {
	      as_warn (_("ignoring redefinition of register alias '%s' to non-existant register '%s'"),
		       copy_of_str, q);
	    }
	  else
	    {
	      /* Do not warn about redefinitions to the same alias.  */
	      if (new_type != old_type
		  || (arm_reg_parse (&q, all_reg_maps[old_type].htab)
		      != arm_reg_parse (&q, all_reg_maps[new_type].htab)))
		as_warn (_("ignoring redefinition of register alias '%s'"),
			 copy_of_str);

	    }
	}
      else
	as_warn (_("ignoring incomplete .req pseuso op"));

      *p = c;
      return 1;
    }
  
  *p = c;
  return 0;
}

static void
set_constant_flonums ()
{
  int i;

  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
}
a10806 1
/* Iterate over the base tables to create the instruction patterns.  */
d10808 1
a10808 1
build_arm_ops_hsh ()
d10858 110
a10967 10
#define arm_Note Elf_External_Note
#else
typedef struct
{
  unsigned char	namesz[4];	/* Size of entry's owner string.  */
  unsigned char	descsz[4];	/* Size of the note descriptor.  */
  unsigned char	type[4];	/* Interpretation of the descriptor.  */
  char		name[1];	/* Start of the name+desc data.  */
} arm_Note;
#endif
d10969 13
a10981 34
/* The description is kept to a fix sized in order to make updating
   it and merging it easier.  */
#define ARM_NOTE_DESCRIPTION_LENGTH	8

static void
arm_add_note (name, description, type)
     const char * name;
     const char * description;
     unsigned int type;
{
  arm_Note     note ATTRIBUTE_UNUSED;
  char *       p;
  unsigned int name_len;

  name_len = (strlen (name) + 1 + 3) & ~3;
  
  p = frag_more (sizeof (note.namesz));
  md_number_to_chars (p, (valueT) name_len, sizeof (note.namesz));

  p = frag_more (sizeof (note.descsz));
  md_number_to_chars (p, (valueT) ARM_NOTE_DESCRIPTION_LENGTH, sizeof (note.descsz));

  p = frag_more (sizeof (note.type));
  md_number_to_chars (p, (valueT) type, sizeof (note.type));

  p = frag_more (name_len);
  strcpy (p, name);

  p = frag_more (ARM_NOTE_DESCRIPTION_LENGTH);
  strncpy (p, description, ARM_NOTE_DESCRIPTION_LENGTH);
  frag_align (2, 0, 0);
}
#endif
#endif
d10984 1
a10984 1
md_begin ()
d11191 1
a11191 1
  
d11226 1
a11226 1
      case bfd_mach_arm_iWMMXt:  arch_string = "iWMMXt"; break;	
d11235 1
a11235 1
  
d11247 1
a11247 4
md_number_to_chars (buf, val, n)
     char * buf;
     valueT val;
     int    n;
d11256 1
a11256 3
md_chars_to_number (buf, n)
     char * buf;
     int    n;
d11296 1
a11296 4
md_atof (type, litP, sizeP)
     char   type;
     char * litP;
     int *  sizeP;
d11373 1
a11373 2
md_pcrel_from (fixP)
     fixS * fixP;
d11400 2
a11401 3
md_section_align (segment, size)
     segT   segment ATTRIBUTE_UNUSED;
     valueT size;
d11415 1
a11415 2
md_undefined_symbol (name)
     char * name ATTRIBUTE_UNUSED;
a11436 60
/* arm_reg_parse () := if it looks like a register, return its token and
   advance the pointer.  */

static int
arm_reg_parse (ccp, htab)
     register char ** ccp;
     struct hash_control *htab;
{
  char * start = * ccp;
  char   c;
  char * p;
  struct reg_entry * reg;

#ifdef REGISTER_PREFIX
  if (*start != REGISTER_PREFIX)
    return FAIL;
  p = start + 1;
#else
  p = start;
#ifdef OPTIONAL_REGISTER_PREFIX
  if (*p == OPTIONAL_REGISTER_PREFIX)
    p++, start++;
#endif
#endif
  if (!ISALPHA (*p) || !is_name_beginner (*p))
    return FAIL;

  c = *p++;
  while (ISALPHA (c) || ISDIGIT (c) || c == '_')
    c = *p++;

  *--p = 0;
  reg = (struct reg_entry *) hash_find (htab, start);
  *p = c;

  if (reg)
    {
      *ccp = p;
      return reg->number;
    }

  return FAIL;
}

/* Search for the following register name in each of the possible reg name
   tables.  Return the classification if found, or REG_TYPE_MAX if not
   present.  */
static enum arm_reg_type
arm_reg_parse_any (cp)
     char *cp;
{
  int i;

  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    if (arm_reg_parse (&cp, all_reg_maps[i].htab) != FAIL)
      return (enum arm_reg_type) i;

  return REG_TYPE_MAX;
}

d11438 3
a11440 4
md_apply_fix3 (fixP, valP, seg)
     fixS *   fixP;
     valueT * valP;
     segT     seg;
d12096 2
a12097 3
tc_gen_reloc (section, fixp)
     asection * section ATTRIBUTE_UNUSED;
     fixS * fixp;
d12102 1
a12102 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d12104 1
a12104 1
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d12252 2
a12253 3
md_estimate_size_before_relax (fragP, segtype)
     fragS * fragP ATTRIBUTE_UNUSED;
     segT    segtype ATTRIBUTE_UNUSED;
d12259 40
d12300 1
a12300 2
output_inst (str)
     const char *str;
d12338 1
a12338 2
md_assemble (str)
     char * str;
d12396 1
a12396 1
	  (*opcode->parms) (p);
d12422 1
a12422 1
	  (*opcode->parms) (p);
d12868 4
a12871 4
  char *option;		/* Substring to match.  */
  char *help;		/* Help information.  */
  int (*func) PARAMS ((char *subopt));	/* Function to decode sub-option.  */
  char *deprecated;	/* If non-null, print this message.  */
d12875 1
a12875 3
arm_parse_extension (str, opt_p)
     char *str;
     int *opt_p;
d12879 2
a12880 2
      struct arm_arch_extension_table *opt;
      char *ext;
d12923 1
a12923 2
arm_parse_cpu (str)
     char *str;
d12925 2
a12926 2
  struct arm_cpu_option_table *opt;
  char *ext = strchr (str, '+');
d12957 1
a12957 2
arm_parse_arch (str)
     char *str;
d12976 1
a12976 1
    if (strcmp (opt->name, str) == 0)
d12992 1
a12992 2
arm_parse_fpu (str)
     char *str;
d12994 1
a12994 1
  struct arm_fpu_option_table *opt;
d12997 1
a12997 1
    if (strcmp (opt->name, str) == 0)
d13008 1
a13008 2
arm_parse_float_abi (str)
     char * str;
d13010 1
a13010 1
  struct arm_float_abi_option_table *opt;
d13013 1
a13013 1
    if (strcmp (opt->name, str) == 0)
d13025 1
a13025 2
arm_parse_eabi (str)
     char * str;
d13030 1
a13030 1
    if (strcmp (opt->name, str) == 0)
d13058 1
a13058 3
md_parse_option (c, arg)
     int    c;
     char * arg;
d13087 1
a13087 1
		  || strcmp (arg, opt->option + 1) == 0))
d13119 1
a13119 1
	      return (*lopt->func)(arg + strlen (lopt->option) - 1);
d13130 1
a13130 2
md_show_usage (fp)
     FILE * fp;
a13155 41
/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.  We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */

static void
fix_new_arm (frag, where, size, exp, pc_rel, reloc)
     fragS *       frag;
     int           where;
     short int     size;
     expressionS * exp;
     int           pc_rel;
     int           reloc;
{
  fixS *           new_fix;
  arm_fix_data *   arm_data;

  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;

    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
    }

  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  arm_data = (arm_fix_data *) obstack_alloc (& notes, sizeof (arm_fix_data));
  new_fix->tc_fix_data = (PTR) arm_data;
  arm_data->thumb_mode = thumb_mode;
}

d13159 4
a13162 5
cons_fix_new_arm (frag, where, size, exp)
     fragS *       frag;
     int           where;
     int           size;
     expressionS * exp;
d13194 1
a13194 1
arm_cleanup ()
d13210 1
a13210 1
arm_start_line_hook ()
d13216 1
a13216 2
arm_frob_label (sym)
     symbolS * sym;
d13274 1
a13274 1
arm_adjust_symtab ()
d13344 1
a13344 1
arm_data_in_code ()
d13358 1
a13358 2
arm_canonicalize_symbol_name (name)
     char * name;
d13371 1
a13371 2
arm_validate_fix (fixP)
     fixS * fixP;
d13388 1
a13388 2
arm_force_relocation (fixp)
     struct fix * fixp;
d13419 1
a13419 2
arm_fix_adjustable (fixP)
   fixS * fixP;
d13442 1
a13442 2
arm_fix_adjustable (fixP)
   fixS * fixP;
d13467 1
a13467 1
elf32_arm_target_format ()
d13473 1
a13473 1
#else 
d13492 2
a13493 3
armelf_frob_symbol (symp, puntp)
     symbolS * symp;
     int *     puntp;
a13497 41
static bfd_reloc_code_real_type
arm_parse_reloc ()
{
  char         id [16];
  char *       ip;
  unsigned int i;
  static struct
  {
    char * str;
    int    len;
    bfd_reloc_code_real_type reloc;
  }
  reloc_map[] =
  {
#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }
    MAP ("(got)",    BFD_RELOC_ARM_GOT32),
    MAP ("(gotoff)", BFD_RELOC_ARM_GOTOFF),
    /* ScottB: Jan 30, 1998 - Added support for parsing "var(PLT)"
       branch instructions generated by GCC for PLT relocs.  */
    MAP ("(plt)",    BFD_RELOC_ARM_PLT32),
    MAP ("(target1)", BFD_RELOC_ARM_TARGET1),
    MAP ("(sbrel)", BFD_RELOC_ARM_SBREL32),
    MAP ("(target2)", BFD_RELOC_ARM_TARGET2),
    { NULL, 0,         BFD_RELOC_UNUSED }
#undef MAP
  };

  for (i = 0, ip = input_line_pointer;
       i < sizeof (id) && (ISALNUM (*ip) || ISPUNCT (*ip));
       i++, ip++)
    id[i] = TOLOWER (*ip);

  for (i = 0; reloc_map[i].str; i++)
    if (strncmp (id, reloc_map[i].str, reloc_map[i].len) == 0)
      break;

  input_line_pointer += reloc_map[i].len;

  return reloc_map[i].reloc;
}

d13499 1
a13499 2
s_arm_elf_cons (nbytes)
     int nbytes;
d13536 1
a13536 1
	      register char *p = frag_more ((int) nbytes);
d13562 1
a13562 1
    
d13603 1
a13603 2
arm_handle_align (fragP)
     fragS *fragP;
d13665 1
a13665 3
arm_frag_align_code (n, max)
     int n;
     int max;
a13681 1

d13687 1
a13687 2
arm_init_frag (fragP)
     fragS *fragP;
d13692 35
@


1.177
log
@bfd/
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Add prototype.
	(bfd_elf32_arm_process_before_allocation): Update prototype.
	* bfd-in2.h: Regenerate.
	* bfd/elf32-arm.h (elf32_arm_link_hash_table): Add target2_reloc.
	(elf32_arm_link_hash_table_create): Set it.
	(bfd_elf32_arm_process_before_allocation): Remove target1_is_rel.
	(bfd_elf32_arm_set_target_relocs): New function.
	(arm_real_reloc_type): New function.
	(elf32_arm_final_link_relocate): Use it.  Handle R_ARM_PREL31 and
	R_ARM_GOT_PREL.  Remove R_ARM_TARGET1.
	(elf32_arm_gc_sweep_hook): Ditto.
	(elf32_arm_check_relocs): Ditto.
	(elf32_arm_relocate_section): Handle R_ARM_GOT_PREL.
	* elfarm-nabi.c (elf32_arm_howto_table): Add R_ARM_PREL31 and
	R_ARM_GOT_TARGET2.
	(elf32_arm_got_prel): New variable.
	(elf32_arm_howto_from_type): New function.
	(elf32_arm_info_to_howto): Use it.
	(elf32_arm_reloc_map): Add BFD_RELOC_ARM_PREL31 and
	BFD_RELOC_ARM_TARGET2.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_TARGET2 and BFD_RELOC_ARM_PREL31.
gas/
	* config/tc-arm.c (s_arm_rel31): New funciton.
	(md_pseudo_table): Add .rel31.
	(md_apply_fix3): Handle BFD_RELOC_ARM_TARGET2,
	BFD_RELOC_32_PCREL and BFD_RELOC_ARM_PREL31.
	(tc_gen_reloc): Handle BFD_RELOC_ARM_PREL31 and BFD_RELOC_ARM_TARGET2.
	(arm_fix_adjustable): Return 0 for BFD_RELOC_ARM_TARGET2.
	(arm_parse_reloc): Add (target2).
gas/testsuite/
	* gas/arm/pic.s: Add (target2).
	* gas/arm/pic.d: Ditto.
include/
	* elf/arm.h: Remove R_ARM_STKCHK and R_ARM_THM_STKCHK.
	Add R_ARM_TARGET2, R_ARM_PREL31, R_ARM_GOT_ABS, R_ARM_GOT_PREL,
	R_ARM_GOT_BREL12, R_ARM_GOTOFF12 and R_ARM_GOTRELAX.
ld/
	* ld.texinfo: Rename arm-specific section.  Document --target*
	* emulparams/armelf_fbsd.sh: Set TARGET2_TYPE.
	* emulparams/armelf_linux.sh: Ditto.
	* emulparams/armelf_nbsd.sh: Ditto.
	* emultempl/armelf.em: Set default for TARGET2_TYPE.
	(target2_type): New variable.
	(arm_elf_before_allocation): Don't pass target1_type.
	(arm_elf_create_output_section_statements): New function.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_TARGET2.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add --target=.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_TARGET2.
	(LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS): Set.
	* emultempl/armelf_oabi.em (_before_allocation): Remove extra
	argument to bfd_elf32_arm_process_before_allocation.
ld/testsuite/
	* ld-arm/arm-target1-{abs,rel}.d}: New files.
	* ld-arm/arm-target1.s: New file.
	* ld-arm/arm-target2-{,got-}rel.d: New files.
	* ld-arm/arm-target2.s: New file.
	* ld-arm/arm-rel31.d: New files.
	* ld-arm/arm-rel31.s: New files.
	* ld-arm/arm.ld: New file.
	* ld-arm/arm-elf.exp: Add new tests.
@
text
@d10257 18
d10515 1
a10515 1
	     REG_TYPE_MVFX);
d10523 1
a10523 1
	     REG_TYPE_MVFX);
@


1.176
log
@bfd/
	* bfd-in.h (bfd_elf32_arm_process_before_allocation): Update
	prototype.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* elf32-arm.h (elf32_arm_link_hash_table): Add target1_is_rel.
	(elf32_arm_link_hash_table_create): Set target1_is_rel.
	(bfd_elf32_arm_process_before_allocation): Ditto.
	(elf32_arm_final_link_relocate): Handle R_ARM_TARGET1.
	(elf32_arm_gc_sweep_hook, elf32_arm_check_relocs): Ditto.
	* elfarm-nabi.c (elf32_arm_howto_table): Rename RELABS to TARGET1.
	* reloc.c: Ditto.
gas/
	* config/tc-arm.c: Rename RELABS to TARGET1.
gas/testsuite/
	* gas/arm/pic.d: Rename RELABS to TARGET1.
	* gas/arm/pic.s: Ditto.
include/
	* elf/arm.h: Rename RELABS to TARGET1.
ld/
	* emulparams/armsymbian.sh: Set TARGET1_IS_REL.
	* emultempl/armelf.em: Use TARGET1_IS_REL.  Add --target1-{rel,abs}.
@
text
@d2448 1
d2472 1
d12486 1
d12496 1
d12509 14
d12801 2
d14113 2
a14114 1
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF)
d14175 1
d14250 44
@


1.175
log
@	* config.bfd (arm*-*-symbianelf*): Use OS-specific target vectors.
	* configure.in (bfd_elf32_bigarm_symbian_vec): Add it.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	* configure: Regenerated.
	* elf-bfd.h (elf_backend_data): Add dynamic_sec_flags.
	* elf32-arm.h (PLT_HEADER_SIZE): Do not define.
	(PLT_ENTRY_SIZE): Likewise.
	(bfd_vma_elf32_arm_symbian_plt_entry): New
	variable.
	(elf32_arm_link_hash_table): Add plt_header_size, plt_entry_size,
	and symbian_p.
	(create_got_section): Don't create sections when generating BPABI
	objects.
	(elf32_arm_create_dynamic_sections): Tidy.
	(elf32_arm_link_hash_table_create): Set plt_header_size,
	plt_entry_size, and symbian_p.
	(elf32_arm_check_relocs): Do not mark .rel.dyn as loadable when
	generating BPABI objects.
	(allocate_dynrelocs): Use htab->plt_header_size, not
	PLT_HEADER_SIZE.  Do not add to .got.plt when
	generating BPABI objects.
	(elf32_arm_finish_dynamic_symbol): Generate Symbian OS PLTs.
	* elfarm-nabi.c: Add SymbianOS target vectors.
	* elflink.c (_bfd_elf_create_got_section): Use dynamic_sec_flags.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	* elfxx-target.h (ELF_DYNAMIC_SEC_FLAGS): New macro.
	(elfNN_bed): Use it.
	* targets.c (bfd_elf32_bigarm_symbian_vec): New variable.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	(_bfd_target_vector): Add them.

	* Makefile.am (TARG_ENV_HFILES): Add te-symbian.h.
	* Makefile.in: Regenerated.
	* configure.in: Set em for arm*-*-symbianelf*.
	* configure: Regenerated.
	* config/tc-arm.c (elf32_arm_target_format): Use Symbian target
	vectors when appropriate.
	* config/te-symbian.h: New file.

	* Makefile.am (ALL_EMULATIONS): Add earmsymbian.o.
	(earmsymbian.c): New target.
	* configure.tgt: Use armsymbian emulation for arm*-*-symbianelf*.
	* Makefile.in: Regenerated.
	* aclocal.m4: Likewise.
	* configure: Likewise.
	* emulparams/armsymbian.sh: New file.
@
text
@d12490 1
a12490 1
    case BFD_RELOC_ARM_RELABS32:
d12780 1
a12780 1
    case BFD_RELOC_ARM_RELABS32:
d14152 1
a14152 1
    MAP ("(relabs)", BFD_RELOC_ARM_RELABS32),
@


1.174
log
@Argh! missing comma...
@
text
@d14102 5
d14121 1
@


1.173
log
@* tc-arm.c (arm_cpus, arm_fpus): Allow <cpu>-s as well as <cpu>s
for synthesizable cores.
@
text
@d13316 1
a13316 1
  {"arm1136j-s"		ARM_ARCH_V6,     FPU_NONE},
@


1.172
log
@Add support for a -g switch to GAS
@
text
@d13283 1
d13303 1
d13314 1
d13316 1
d13318 1
d13407 1
@


1.171
log
@bfd/
	* elfarm-nabi.c (elf32_arm_howto_table): Add new EABI relocations.
	(elf32_arm_reloc_map): Add BFD_RELOC_ARM_RELABS32,
	BFD_RELOC_ARM_ROSEGREL32 and BFD_RELOC_ARM_SBREL32.
	* reloc.c: Add BFD_RELOC_ARM_RELABS32, BFD_RELOC_ARM_ROSEGREL32
	and BFD_RELOC_ARM_SBREL32.
	* bfd-in2.h, bbfd.h: Regenerate.
gas/
	* config/tc-arm.c (md_apply_fix3, tc_gen_reloc, arm_parse_reloc):
	Handle new relocations.
	* include/elf/arm.h (elf_arm_reloc_type): Add new EABI relocations.
gas/testsuite/
	* gas/arm/pic.s,d: Test RELABS and SBREL relocations.
@
text
@a13701 1
      as_bad (_("unrecognized option `-%c%s'"), c, arg ? arg : "");
@


1.170
log
@* config/tc-arm.c: Include include/opcode/arm.h.
(ARM_EXT_*, ARM_ARCH_*, ARM_ANY, ARM_ALL, COPROC_ANY): Delete.
(FPU_FPA_EXT_* FPU_VFP_EXT_*, FPU_ANY, FPU_NONE, FPU_MAVERICK): Delete.
(FPU_ARCH_*): Delete.
* Makefile.am: Update dependencies.
* Makefile.in: Regenerate.
@
text
@d12490 3
d12780 3
d14141 2
@


1.169
log
@(md_apply_fix3:BFD_RELOC_ARM_IMMEDIATE): Do not allow values which have come
from undefined symbols.
Always consider this fixup to have been processed as a reloc cannot be
generated for it.
@
text
@d39 2
a48 73
/* The following bitmasks control CPU extensions:  */
#define ARM_EXT_V1	 0x00000001	/* All processors (core set).  */
#define ARM_EXT_V2	 0x00000002	/* Multiply instructions.  */
#define ARM_EXT_V2S	 0x00000004	/* SWP instructions.       */
#define ARM_EXT_V3	 0x00000008	/* MSR MRS.                */
#define ARM_EXT_V3M	 0x00000010	/* Allow long multiplies.  */
#define ARM_EXT_V4	 0x00000020	/* Allow half word loads.  */
#define ARM_EXT_V4T	 0x00000040	/* Thumb v1.               */
#define ARM_EXT_V5	 0x00000080	/* Allow CLZ, etc.         */
#define ARM_EXT_V5T	 0x00000100	/* Thumb v2.               */
#define ARM_EXT_V5ExP	 0x00000200	/* DSP core set.           */
#define ARM_EXT_V5E	 0x00000400	/* DSP Double transfers.   */
#define ARM_EXT_V5J	 0x00000800	/* Jazelle extension.	   */
#define ARM_EXT_V6       0x00001000     /* ARM V6.                 */

/* Co-processor space extensions.  */
#define ARM_CEXT_XSCALE   0x00800000	/* Allow MIA etc.          */
#define ARM_CEXT_MAVERICK 0x00400000	/* Use Cirrus/DSP coprocessor.  */
#define ARM_CEXT_IWMMXT   0x00200000    /* Intel Wireless MMX technology coprocessor.   */

/* Architectures are the sum of the base and extensions.  The ARM ARM (rev E)
   defines the following: ARMv3, ARMv3M, ARMv4xM, ARMv4, ARMv4TxM, ARMv4T,
   ARMv5xM, ARMv5, ARMv5TxM, ARMv5T, ARMv5TExP, ARMv5TE.  To these we add
   three more to cover cores prior to ARM6.  Finally, there are cores which
   implement further extensions in the co-processor space.  */
#define ARM_ARCH_V1			  ARM_EXT_V1
#define ARM_ARCH_V2	(ARM_ARCH_V1	| ARM_EXT_V2)
#define ARM_ARCH_V2S	(ARM_ARCH_V2	| ARM_EXT_V2S)
#define ARM_ARCH_V3	(ARM_ARCH_V2S	| ARM_EXT_V3)
#define ARM_ARCH_V3M	(ARM_ARCH_V3	| ARM_EXT_V3M)
#define ARM_ARCH_V4xM	(ARM_ARCH_V3	| ARM_EXT_V4)
#define ARM_ARCH_V4	(ARM_ARCH_V3M	| ARM_EXT_V4)
#define ARM_ARCH_V4TxM	(ARM_ARCH_V4xM	| ARM_EXT_V4T)
#define ARM_ARCH_V4T	(ARM_ARCH_V4	| ARM_EXT_V4T)
#define ARM_ARCH_V5xM	(ARM_ARCH_V4xM	| ARM_EXT_V5)
#define ARM_ARCH_V5	(ARM_ARCH_V4	| ARM_EXT_V5)
#define ARM_ARCH_V5TxM	(ARM_ARCH_V5xM	| ARM_EXT_V4T | ARM_EXT_V5T)
#define ARM_ARCH_V5T	(ARM_ARCH_V5	| ARM_EXT_V4T | ARM_EXT_V5T)
#define ARM_ARCH_V5TExP	(ARM_ARCH_V5T	| ARM_EXT_V5ExP)
#define ARM_ARCH_V5TE	(ARM_ARCH_V5TExP | ARM_EXT_V5E)
#define ARM_ARCH_V5TEJ	(ARM_ARCH_V5TE	| ARM_EXT_V5J)
#define ARM_ARCH_V6     (ARM_ARCH_V5TEJ | ARM_EXT_V6)

/* Processors with specific extensions in the co-processor space.  */
#define ARM_ARCH_XSCALE	(ARM_ARCH_V5TE	| ARM_CEXT_XSCALE)
#define ARM_ARCH_IWMMXT	(ARM_ARCH_XSCALE | ARM_CEXT_IWMMXT)

/* Some useful combinations:  */
#define ARM_ANY		0x0000ffff	/* Any basic core.  */
#define ARM_ALL		0x00ffffff	/* Any core + co-processor */
#define CPROC_ANY	0x00ff0000	/* Any co-processor */
#define FPU_ANY		0xff000000	/* Note this is ~ARM_ALL.  */


#define FPU_FPA_EXT_V1	 0x80000000	/* Base FPA instruction set.  */
#define FPU_FPA_EXT_V2	 0x40000000	/* LFM/SFM.		      */
#define FPU_VFP_EXT_NONE 0x20000000	/* Use VFP word-ordering.     */
#define FPU_VFP_EXT_V1xD 0x10000000	/* Base VFP instruction set.  */
#define FPU_VFP_EXT_V1	 0x08000000	/* Double-precision insns.    */
#define FPU_VFP_EXT_V2	 0x04000000	/* ARM10E VFPr1.	      */
#define FPU_MAVERICK	 0x02000000	/* Cirrus Maverick.	      */
#define FPU_NONE	 0

#define FPU_ARCH_FPE	 FPU_FPA_EXT_V1
#define FPU_ARCH_FPA	(FPU_ARCH_FPE | FPU_FPA_EXT_V2)

#define FPU_ARCH_VFP       FPU_VFP_EXT_NONE
#define FPU_ARCH_VFP_V1xD (FPU_VFP_EXT_V1xD | FPU_VFP_EXT_NONE)
#define FPU_ARCH_VFP_V1   (FPU_ARCH_VFP_V1xD | FPU_VFP_EXT_V1)
#define FPU_ARCH_VFP_V2	  (FPU_ARCH_VFP_V1 | FPU_VFP_EXT_V2)

#define FPU_ARCH_MAVERICK  FPU_MAVERICK

@


1.168
log
@Fix handling of case sensitive register aliases and add a test for the bug
@
text
@d12189 14
a12218 1
      fixP->fx_done = 1;
@


1.167
log
@	* config/tc-arm.c (mav_parse_offset): Value must be multiple of 4.
testsuite
	* maverick.c (off8s): Test full shifted operand range.
	(MCC2): Define.
	(MVDSPACC, MVACCDSP): Use it.
	* maverick.d, maverick.s: Regenerate.
@
text
@d3598 1
a3598 1
	  inst.error = _("bad or missing co-processor number");
d3653 1
a3653 1
  inst.error = _("co-processor register expected");
d3676 1
a3676 1
  inst.error = _("floating point register expected");
d11442 1
a11442 1
#ifdef IGNORE_OPCODE_CASE
@


1.166
log
@Apply Bruno de Bus's patch to record the ARM mapping symbol state on a per-
section basis and to switch to the MAP_DATA state when emitting literal pools.
@
text
@d10856 1
a10856 1
  if (offset > 0xff)
d10859 5
@


1.165
log
@make use of meabi_flags be ELF specific
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a2831 7
enum mstate
{
  MAP_DATA,
  MAP_ARM,
  MAP_THUMB
};

d2906 2
a2910 1
  static enum mstate mapstate = MAP_DATA;
d2936 2
d2942 2
d2984 1
a2984 10
  if (flags & SEC_CODE)
    {
      if (thumb_mode)
	mapping_state (MAP_THUMB);
      else
	mapping_state (MAP_ARM);
    }
  else
    /* This section does not contain code.  Therefore it must contain data.  */
    mapping_state (MAP_DATA);    
d3107 2
d13872 3
@


1.164
log
@	* bfd/elf32-arm.h (arm_print_private_bfd_data): Add EABI v3.
	* binutils/readelf.c (decode_ARM_machine_flags): Add EABI v3.
	* gas/config/tc-arm.c (meabi_flags): New variable.
	(arm_parse_eabi): New function.
	(md_begin): Set flags for EABI v3.
	(arm_eabis): Add.
	(arm_long_opts): Add meabi.
	* include/elf/arm.h (EF_ERM_BE8, EF_ARM_LE8, EF_ARM_EABI_VER3): Add.
	* doc/as.texinf <ARM>: Document -meabi.
	* doc/c-arm.texi: Ditto.
@
text
@d194 1
d196 1
d2557 1
d2559 1
a11693 1
#if defined OBJ_COFF || defined OBJ_ELF
d11695 4
a11698 1
    unsigned int flags = meabi_flags;
d11703 2
d11712 2
a11713 3
	  {
	    flags |= F_SOFT_FLOAT;
	  }
d11726 1
d11728 3
a11730 2
	if (cpu_variant & FPU_VFP_EXT_NONE) flags |= F_VFP_FLOAT;

a11733 1
#endif
d11743 2
a11744 1

d11764 1
a11765 1
#endif
d13482 1
d13490 1
d13655 1
d13671 1
d13683 1
d13686 1
@


1.163
log
@Apply fixes for Maverick Crunch
@
text
@d194 1
d2555 1
d11692 1
a11692 1
    unsigned int flags = 0;
d11694 1
a11694 7
    /* Set the flags in the private structure.  */
    if (uses_apcs_26)      flags |= F_APCS26;
    if (support_interwork) flags |= F_INTERWORK;
    if (uses_apcs_float)   flags |= F_APCS_FLOAT;
    if (pic_code)          flags |= F_PIC;
    if ((cpu_variant & FPU_ANY) == FPU_NONE
	 || (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
d11696 30
a11725 7
	flags |= F_SOFT_FLOAT;
      }
    switch (mfloat_abi_opt)
      {
      case ARM_FLOAT_ABI_SOFT:
      case ARM_FLOAT_ABI_SOFTFP:
	flags |= F_SOFT_FLOAT;
d11728 2
a11729 3
      case ARM_FLOAT_ABI_HARD:
	if (flags & F_SOFT_FLOAT)
	  as_bad (_("hard-float conflicts with specified fpu"));
d11731 3
a11734 7
    /* Using VFP conventions (even if soft-float).  */
    if (cpu_variant & FPU_VFP_EXT_NONE) flags |= F_VFP_FLOAT;

#if defined OBJ_ELF
    if (cpu_variant & FPU_ARCH_MAVERICK)
	flags |= EF_ARM_MAVERICK_FLOAT;
#endif
d13467 14
d13644 16
d13670 2
@


1.163.2.1
log
@Additional merges to branch for 2.15.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d2826 7
a2906 2
static enum mstate mapstate = MAP_UNDEFINED;

d2910 1
a2935 2
    case MAP_UNDEFINED:
      return;     
a2939 2
  seg_info (now_seg)->tc_segment_info_data = state;

d2980 10
a2989 1
  mapstate = seg_info (now_seg)->tc_segment_info_data;
a3111 2
  mapping_state (MAP_DATA);

a13819 3
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
@


1.162
log
@	* config/tc-arm.c (md_begin): Mark .note.gnu.arm.ident as
	read-only.
@
text
@d7 2
d1116 2
a1117 2
/* "INSN<cond> X,Y" where X:0, Y:bit16.  */
#define MAV_MODE3	0x1000
d2180 12
a2191 12
  {"cfmval32",   0xee100610, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32al",   0xee000610, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvam32",   0xee100630, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32am",   0xee000630, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvah32",   0xee100650, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32ah",   0xee000650, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva32",    0xee100670, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32a",    0xee000670, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva64",    0xee100690, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3c},
  {"cfmv64a",    0xee000690, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3d},
  {"cfmvsc32",   0xee1006b0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_1},
  {"cfmv32sc",   0xee0006b0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_2},
d10580 1
a10580 1
/* cfmvsc32<cond> DSPSC,MVFX[15:0].  */
d10590 1
a10590 1
      || mav_reg_required_here (&str, 16, REG_TYPE_MVFX) == FAIL)
d10601 1
a10601 1
/* cfmv32sc<cond> MVFX[15:0],DSPSC.  */
d10609 1
a10609 1
  if (mav_reg_required_here (&str, 0, REG_TYPE_MVFX) == FAIL
@


1.161
log
@	* config/tc-arm.c (tc_gen_reloc): Improve error message for
	undefined local labels.
@
text
@d11812 3
@


1.160
log
@	* gas/config/tc-arm.c (do_vfp_reg2_from_sp2): Rename from
	do_vfp_sp_reg2.
	(do_vfp_sp2_from_reg2): New function.
	(insns): Use them.
	(do_vfp_dp_from_reg2): Check return values properly.
	* opcodes/arm-opc.h (arm_opcodes): Move generic mcrr after known
	specific opcodes.
	* gas/testsuite/gas/arm/vfp2.s, gas/arm/vfp2.d: New test.
	* gas/testsuite/gas/arm/arm.exp: Add them.
@
text
@d12826 10
@


1.159
log
@	* gas/config/tc-arm.c (arm_cpus): Add 926ejs and 1026ejs.
	* gas/doc/c-arm.texi: Document them.
@
text
@d932 2
a933 1
static void do_vfp_sp_reg2	PARAMS ((char *));
d1980 2
a1981 2
  {"fmsrr",   0xec400a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp_reg2},
  {"fmrrs",   0xec500a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp_reg2},
d8958 1
a8958 1
do_vfp_sp_reg2 (str)
d8963 2
a8964 4
  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
d9004 26
d9103 1
a9103 1
      || reg_required_here (&str, 16))
@


1.158
log
@	* config/tc-arm.c (arm_archs): Add armv6.
@
text
@d13294 1
d13304 1
@


1.157
log
@	* config/tc-arm.c (arm_archs): Change "armv6" to "armv6j".
	* doc/c-arm.texi (ARM Options): Likewise.
@
text
@d13343 1
@


1.156
log
@Remove -8 bias on PC-relative load instructions for arm-wince-pe target
@
text
@d13343 1
a13343 1
  {"armv6",             ARM_ARCH_V6,     FPU_ARCH_VFP},
@


1.155
log
@	* config/tc-arm.c (FPU_MAVERICK): Define.
	(FPU_ARCH_MAVERICK): Define.
	(arm_float_abi): Define.
	(mfloat_abi_opt): New variable.
	(md_begin): Use them.
	(arm_opts): Add msoft-float and mhard-float.
	(arm_cpus): Use FPU_ARCH_MAVERICK.
	(arm_fpus): Add maverick.
	(arm_float_abis): Add.
	(arm_parse_float_abi): New function.
	(arm_long_options): Add mfloat-abi.
	* doc/as.texinfo: Document -mfloat-abi=.
	* doc/c-arm.text: Ditto. Menution -fpu=maverick.
@
text
@d7302 1
d7304 1
d7335 1
d7337 1
@


1.154
log
@Remove redundant returns in void functions.
@
text
@d105 1
d116 9
d191 1
d2550 1
d11667 16
a11682 2
	|| (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
      flags |= F_SOFT_FLOAT;
d11687 1
a11687 3
    if (cpu_variant & ARM_CEXT_MAVERICK)
      {
	flags &= ~ F_SOFT_FLOAT;
a11688 1
      }
d13307 1
a13307 1
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_NONE},
d13388 15
d13552 17
d13577 2
@


1.153
log
@	* config/tc-arm.c (do_umaal): Fix typo.
@
text
@a4033 1
  return;
a4216 1
  return;
a4269 1
  return;
a4324 1
  return;
a5758 1
  return;
a6289 1
  return;
a6296 2

  return;
a6308 1
  return;
a6332 1
  return;
a6339 2

  return;
a6346 2

  return;
a6353 2

  return;
a6360 2

  return;
a6367 2

  return;
a6374 2

  return;
a6381 1
  return;
a6393 1
  return;
a6403 1
  return;
a6443 2
  
  return;
a6450 2

  return;
a6457 2

  return;
a6469 1
  return;
a6479 1
  return;
a7267 1
  return;
a7323 2

  return;
a7347 1
  return;
a7371 1
  return;
a7621 1
  return;
a7699 1
  return;
a7954 1
  return;
a8150 1
  return;
a8168 2

  return;
a8228 1
  return;
a8272 1
  return;
a8353 1
  return;
a8388 1
  return;
a8449 1
  return;
a8468 1
  return;
a8663 1
  return;
a8687 1
  return;
a8711 1
  return;
a8735 1
  return;
a8755 1
  return;
a8853 1
  return;
a8873 1
  return;
a8895 1
  return;
a8917 1
  return;
a8937 1
  return;
a8965 1
  return;
a8985 1
  return;
a9005 1
  return;
a9027 1
  return;
a9047 1
  return;
a9069 1
  return;
a9147 1
  return;
a9167 1
  return;
a9191 1
  return;
a9215 1
  return;
a9581 1
  return;
a9597 1
  return;
a9617 1
  return;
a9637 1
  return;
a10895 1
  return;
a10903 1
  return;
a11276 1
  return;
a13666 2

  return;
@


1.152
log
@	* gas/arm/arm.exp: Add archv6 and thumbv6.
	* gas/arm/archv6.d: New file.
	* gas/arm/archv6.s: Likewise.
	* gas/arm/thumbv6.d: Likewise.
	* gas/arm/thumbv6.s: Likewise.

	Add V6 support.
	* config/tc-arm.c (ARM_EXT_V6): New macro.
	(ARM_ARCH_V6): Likewise.
	(SHIFT_IMMEDIATE): Likewise.
	(SHIFT_LSL_OR_ASR_IMMEDIATE): Likewise.
	(SHIFT_ASR_IMMEDIATE): Likewise.
	(SHIFT_LSL_IMMMEDIATE): Likewise.
	(do_cps): New function.
	(do_cpsi): Likewise.
	(do_ldrex): Likewise.
	(do_pkhbt): Likewise.
	(do_pkhtb): Likewise.
	(do_qadd16): Likewise.
	(do_rev): Likewise.
	(do_rfe): Likewise.
	(do_sxtah): Likewise.
	(do_sxth): Likewise.
	(do_setend): Likewise.
	(do_smlad): Likewise.
	(do_smlald): Likewise.
	(do_smmul): Likewise.
	(do_ssat): Likewise.
	(do_usat): Likewise.
	(do_srs): Likewise.
	(do_ssat16): Likewise.
	(do_usat16): Likewise.
	(do_strex): Likewise.
	(do_umaal): Likewise.
	(do_cps_mode): Likewise.
	(do_cps_flags): Likewise.
	(do_endian_specifier): Likewise.
	(do_pkh_core): Likewise.
	(do_sat): Likewise.
	(do_sat16): Likewise.
	(insns): Add V6 instructions.
	(do_t_cps): New function.
	(do_t_cpy): Likewise.
	(do_t_setend): Likewise.
	(THUMB_CPY): New macro.
	(tinsns): Add V6 instructions.
	(decode_shift): Handle V6 restricted-shift options.
	(thumb_mov_compare): Support CPY.
	(arm_cores): Add arm1136js and arm1136jfs.
	(arm_archs): Add armv6.
	(arm_fpus): Add arm1136jfs.
	* doc/c-arm.texi (ARM Options): Mention arm1136js, arm1136jfs, and
	armv6 options.

	* gas/arm/arm.exp: Add archv6 and thumbv6.
	* gas/arm/archv6.d: New file.
	* gas/arm/archv6.s: Likewise.
	* gas/arm/thumbv6.d: Likewise.
	* gas/arm/thumbv6.s: Likewise.

	* arm-dis.c (print_arm_insn): Add 'W' macro.
	* arm-opc.h (arm_opcodes): Add V6 instructions.
	(thumb_opcodes): Likewise.
@
text
@d4880 1
a4880 1
      || (rm = reg_required_here (& str, 8)) == FAIL)
@


1.151
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d58 1
d86 1
d293 1
d295 8
a302 1
#define SHIFT_RESTRICT	  0
d869 30
d1316 101
d2290 5
d2363 1
d2456 13
d4636 881
a5516 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5520 3
a5522 7
  /* Unpredictable result if rd or rn is R15.  */
  if (rd == REG_PC || rn == REG_PC)
    as_tsktsk
      (_("Warning: instruction unpredictable when using r15"));

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
d5524 2
a5525 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
a5526 1

d5530 5
a5534 4
/* ARM V5 count-leading-zeroes instruction (argument parse)
     CLZ{<cond>} <Rd>, <Rm>
     Condition defaults to COND_ALWAYS.
     Error if Rd or Rm are R15.  */
d5537 2
a5538 2
do_clz (str)
     char *        str;
d5544 3
a5546 3
  if (((rd = reg_required_here (& str, 12)) == FAIL)
      || (skip_past_comma (& str) == FAIL)
      || ((rm = reg_required_here (& str, 0)) == FAIL))
d5549 1
a5549 1
  else if (rd == REG_PC || rm == REG_PC )
d5556 4
a5559 5
/* ARM V5 (argument parse)
     LDC2{L} <coproc>, <CRd>, <addressing mode>
     STC2{L} <coproc>, <CRd>, <addressing mode>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as LDC/STC.  */
d5562 2
a5563 2
do_lstc2 (str)
     char *        str;
d5565 2
d5569 10
a5578 17
  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else if (skip_past_comma (& str) == FAIL
	   || cp_reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else if (skip_past_comma (& str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
    }
d5583 20
a5602 4
/* ARM V5 (argument parse)
     CDP2 <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as CDP.  */
d5605 3
a5607 2
do_cdp2 (str)
     char *        str;
d5609 2
d5612 9
d5622 1
a5622 1
  if (co_proc_number (& str) == FAIL)
d5624 1
a5624 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5628 2
a5629 2
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 20,4) == FAIL)
d5631 9
a5639 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5643 21
a5663 2
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 12) == FAIL)
d5665 1
a5665 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5668 1
a5668 3

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
d5670 1
a5670 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5673 1
d5675 8
a5682 2
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
d5684 1
a5684 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5687 1
a5687 2

  if (skip_past_comma (& str) == SUCCESS)
d5689 2
a5690 6
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
d5692 1
d5694 5
d5702 10
a5711 5
/* ARM V5 (argument parse)
     MCR2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     MRC2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as MCR/MRC.  */
d5714 2
a5715 2
do_co_reg2 (str)
     char *        str;
d5717 1
a5717 1
  skip_whitespace (str);
d5719 1
a5719 1
  if (co_proc_number (& str) == FAIL)
d5721 2
a5722 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d5724 10
d5735 1
a5735 2
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 21, 3) == FAIL)
d5737 1
a5737 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5741 2
a5742 2
  if (skip_past_comma (& str) == FAIL
      || reg_required_here (& str, 12) == FAIL)
d5744 1
a5744 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5748 1
a5748 2
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
d5750 1
a5750 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5753 4
a5756 3

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
d5758 1
a5758 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5761 3
a5763 12

  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
a5765 1
/* ARM v5TEJ.  Jump to Jazelle code.  */
d5767 3
a5769 2
do_bxj (str)
     char * str;
d5771 12
a5782 1
  int reg;
d5784 1
a5784 1
  skip_whitespace (str);
d5786 2
a5787 1
  if ((reg = reg_required_here (&str, 0)) == FAIL)
d5789 15
a5803 2
      inst.error = BAD_ARGS;
      return;
d5805 2
a5806 6

  /* Note - it is not illegal to do a "bxj pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  end_of_line (str);
d6038 29
d6914 1
a6914 2
/* UNRESTRICT should be one if <shift> <register> is permitted for this
   instruction.  */
d6917 1
a6917 1
decode_shift (str, unrestrict)
d6919 1
a6919 1
     int     unrestrict;
d6949 20
d6978 1
a6978 1
  if (unrestrict && reg_required_here (& p, 8) != FAIL)
d6986 1
a6986 1
      inst.error = (unrestrict
d7465 1
a7465 1
	return decode_shift (str, SHIFT_RESTRICT);
d10056 1
a10056 1
  if (is_immediate_prefix (*str))
d10067 1
a10067 1
      if (Rs < 8 && Rd < 8)
d10081 1
a10081 1
	  else
d13353 2
d13393 1
d13441 1
@


1.150
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-alpha.c: Likewise.
	* config/tc-alpha.h: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-dlx.h: Likewise.
@
text
@d1183 1
a1183 1
  /* Generic copressor instructions.  */
d2870 1
a2870 1
		/* FIXME: We are deleteing a built in register alias which
d2879 1
a2879 1
		  /* Deleteing a user defined alias.  We need to free the
@


1.149
log
@	* config/tc-arm.c (arm_elf_change_section): Not static.
@
text
@d365 1
a365 1
/* The bit that distnguishes CPSR and SPSR.  */
d2600 1
a2600 1
/* Check to see if an immediate can be computed as two seperate immediate
d3902 1
a3902 1
	 /* Lower case versions for backwards compatability.  */
d3907 1
a3907 1
  /* This is for backwards compatability with older toolchains.  */
d4525 1
a4525 1
     Instruction is not conditional, and has 0xf in the codition field.
d5895 1
a5895 1
   by altering the instuction.  A bit of a hack really.
d9808 1
a9808 1
    inst.instruction |= CP_T_UD; /* Postive, so set bit U.  */
d9928 1
a9928 1
  /* This definiton must agree with the one in gcc/config/arm/thumb.c.  */
d10875 2
a10876 2
  /* The pattern was adjusted to accomodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accomodation.  */
d11241 1
a11241 1
	     branch instruciton itself, then we can compute the relocation for
d13100 1
a13100 1
  /* We assume that there will never be a requirment
@


1.148
log
@Add support for ARM ELF Mapping symbols
@
text
@d2791 1
a2791 1
static void
@


1.147
log
@* config/tc-arm.texi (struct reg_entry): Add new field 'builtin'.
  (rn_table, iwmmxt_table, cp_table, cn_table, fn_table, sn_table,
  dn_table, mav_mvf_table, mac_mvd_table, mav_mvfx_table,
  mav_mvax_table, mav_dspc_table): Initialise new field.
  (insert_reg_alias): Initialise new field.
  (md_pseudo_table): Add "unreq" entry.
  (s_unreq): New function: Undo the effects of a previous .req.
* doc/c-arm.texi: Document new pseudo op.
* NEWS: Mention new feature.
* testsuite/gas/arm/req.s: New test file.  Check .req and .unreq psuedo ops.
* testsuite/gas/arm/req.l: Expected error output from req.s test.
* testsuite/gas/arm/copro.d: Set target architecture for objdump so that the
  test will work on architectures which cannot encode higher arm architecture
  types in their file headers.
* testsuite/gas/arm/arm.exp: Run new req.s test.
  Skip thumb instruction test for PE targets which do not support
  thumb relocations.
* testsuite/gas/elf/elf.exp: Skip special handling of section2 test for XScale
  targets - it is no longer needed.
@
text
@d2649 172
d2907 1
d3146 1
d3162 1
d11859 1
d11885 1
d12989 1
@


1.146
log
@Fix up error messages for Maverick.
@
text
@d583 1
d595 3
a597 1
/* These are the standard names.  Users can add aliases with .req.  */
d601 4
a604 4
  {"r0",  0},  {"r1",  1},      {"r2",  2},      {"r3",  3},
  {"r4",  4},  {"r5",  5},      {"r6",  6},      {"r7",  7},
  {"r8",  8},  {"r9",  9},      {"r10", 10},     {"r11", 11},
  {"r12", 12}, {"r13", REG_SP}, {"r14", REG_LR}, {"r15", REG_PC},
d606 3
a608 3
  {"a1",  0},  {"a2",  1},      {"a3",  2},      {"a4",  3},
  {"v1",  4},  {"v2",  5},      {"v3",  6},      {"v4",  7},
  {"v5",  8},  {"v6",  9},      {"v7",  10},     {"v8",  11},
d610 3
a612 4
						 {"wr",  7},
	       {"sb",  9},      {"sl",  10},     {"fp",  11},
  {"ip",  12}, {"sp",  REG_SP}, {"lr",  REG_LR}, {"pc",  REG_PC},
  {NULL, 0}
d621 26
a646 26
  {  "wr0", 0x0 | WR_PREFIX},   {"wr1", 0x1 | WR_PREFIX},
  {  "wr2", 0x2 | WR_PREFIX},   {"wr3", 0x3 | WR_PREFIX},
  {  "wr4", 0x4 | WR_PREFIX},   {"wr5", 0x5 | WR_PREFIX},
  {  "wr6", 0x6 | WR_PREFIX},   {"wr7", 0x7 | WR_PREFIX},
  {  "wr8", 0x8 | WR_PREFIX},   {"wr9", 0x9 | WR_PREFIX},
  { "wr10", 0xa | WR_PREFIX},  {"wr11", 0xb | WR_PREFIX},
  { "wr12", 0xc | WR_PREFIX},  {"wr13", 0xd | WR_PREFIX},
  { "wr14", 0xe | WR_PREFIX},  {"wr15", 0xf | WR_PREFIX},
  { "wcid", 0x0 | WC_PREFIX},  {"wcon", 0x1 | WC_PREFIX},
  {"wcssf", 0x2 | WC_PREFIX}, {"wcasf", 0x3 | WC_PREFIX},
  {"wcgr0", 0x8 | WC_PREFIX}, {"wcgr1", 0x9 | WC_PREFIX},
  {"wcgr2", 0xa | WC_PREFIX}, {"wcgr3", 0xb | WC_PREFIX},

  {  "wR0", 0x0 | WR_PREFIX},   {"wR1", 0x1 | WR_PREFIX},
  {  "wR2", 0x2 | WR_PREFIX},   {"wR3", 0x3 | WR_PREFIX},
  {  "wR4", 0x4 | WR_PREFIX},   {"wR5", 0x5 | WR_PREFIX},
  {  "wR6", 0x6 | WR_PREFIX},   {"wR7", 0x7 | WR_PREFIX},
  {  "wR8", 0x8 | WR_PREFIX},   {"wR9", 0x9 | WR_PREFIX},
  { "wR10", 0xa | WR_PREFIX},  {"wR11", 0xb | WR_PREFIX},
  { "wR12", 0xc | WR_PREFIX},  {"wR13", 0xd | WR_PREFIX},
  { "wR14", 0xe | WR_PREFIX},  {"wR15", 0xf | WR_PREFIX},
  { "wCID", 0x0 | WC_PREFIX},  {"wCon", 0x1 | WC_PREFIX},
  {"wCSSF", 0x2 | WC_PREFIX}, {"wCASF", 0x3 | WC_PREFIX},
  {"wCGR0", 0x8 | WC_PREFIX}, {"wCGR1", 0x9 | WC_PREFIX},
  {"wCGR2", 0xa | WC_PREFIX}, {"wCGR3", 0xb | WC_PREFIX},
  {NULL, 0}
d652 5
a656 5
  {"p0",  0},  {"p1",  1},  {"p2",  2},  {"p3", 3},
  {"p4",  4},  {"p5",  5},  {"p6",  6},  {"p7", 7},
  {"p8",  8},  {"p9",  9},  {"p10", 10}, {"p11", 11},
  {"p12", 12}, {"p13", 13}, {"p14", 14}, {"p15", 15},
  {NULL, 0}
d662 4
a665 4
  {"c0",   0},  {"c1",   1},  {"c2",   2},  {"c3",   3},
  {"c4",   4},  {"c5",   5},  {"c6",   6},  {"c7",   7},
  {"c8",   8},  {"c9",   9},  {"c10",  10}, {"c11",  11},
  {"c12",  12}, {"c13",  13}, {"c14",  14}, {"c15",  15},
d667 5
a671 5
  {"cr0",  0},  {"cr1",  1},  {"cr2",  2},  {"cr3",  3},
  {"cr4",  4},  {"cr5",  5},  {"cr6",  6},  {"cr7",  7},
  {"cr8",  8},  {"cr9",  9},  {"cr10", 10}, {"cr11", 11},
  {"cr12", 12}, {"cr13", 13}, {"cr14", 14}, {"cr15", 15},
  {NULL, 0}
d677 3
a679 3
  {"f0", 0},   {"f1", 1},   {"f2", 2},   {"f3", 3},
  {"f4", 4},   {"f5", 5},   {"f6", 6},   {"f7", 7},
  {NULL, 0}
d685 9
a693 9
  {"s0",  0},  {"s1",  1},  {"s2",  2},	 {"s3", 3},
  {"s4",  4},  {"s5",  5},  {"s6",  6},	 {"s7", 7},
  {"s8",  8},  {"s9",  9},  {"s10", 10}, {"s11", 11},
  {"s12", 12}, {"s13", 13}, {"s14", 14}, {"s15", 15},
  {"s16", 16}, {"s17", 17}, {"s18", 18}, {"s19", 19},
  {"s20", 20}, {"s21", 21}, {"s22", 22}, {"s23", 23},
  {"s24", 24}, {"s25", 25}, {"s26", 26}, {"s27", 27},
  {"s28", 28}, {"s29", 29}, {"s30", 30}, {"s31", 31},
  {NULL, 0}
d699 5
a703 5
  {"d0",  0},  {"d1",  1},  {"d2",  2},	 {"d3", 3},
  {"d4",  4},  {"d5",  5},  {"d6",  6},	 {"d7", 7},
  {"d8",  8},  {"d9",  9},  {"d10", 10}, {"d11", 11},
  {"d12", 12}, {"d13", 13}, {"d14", 14}, {"d15", 15},
  {NULL, 0}
d709 5
a713 5
  {"mvf0",  0},  {"mvf1",  1},  {"mvf2",  2},  {"mvf3",  3},
  {"mvf4",  4},  {"mvf5",  5},  {"mvf6",  6},  {"mvf7",  7},
  {"mvf8",  8},  {"mvf9",  9},  {"mvf10", 10}, {"mvf11", 11},
  {"mvf12", 12}, {"mvf13", 13}, {"mvf14", 14}, {"mvf15", 15},
  {NULL, 0}
d718 5
a722 5
  {"mvd0",  0},  {"mvd1",  1},  {"mvd2",  2},  {"mvd3",  3},
  {"mvd4",  4},  {"mvd5",  5},  {"mvd6",  6},  {"mvd7",  7},
  {"mvd8",  8},  {"mvd9",  9},  {"mvd10", 10}, {"mvd11", 11},
  {"mvd12", 12}, {"mvd13", 13}, {"mvd14", 14}, {"mvd15", 15},
  {NULL, 0}
d727 5
a731 5
  {"mvfx0",  0},  {"mvfx1",  1},  {"mvfx2",  2},  {"mvfx3",  3},
  {"mvfx4",  4},  {"mvfx5",  5},  {"mvfx6",  6},  {"mvfx7",  7},
  {"mvfx8",  8},  {"mvfx9",  9},  {"mvfx10", 10}, {"mvfx11", 11},
  {"mvfx12", 12}, {"mvfx13", 13}, {"mvfx14", 14}, {"mvfx15", 15},
  {NULL, 0}
d736 5
a740 5
  {"mvdx0",  0},  {"mvdx1",  1},  {"mvdx2",  2},  {"mvdx3",  3},
  {"mvdx4",  4},  {"mvdx5",  5},  {"mvdx6",  6},  {"mvdx7",  7},
  {"mvdx8",  8},  {"mvdx9",  9},  {"mvdx10", 10}, {"mvdx11", 11},
  {"mvdx12", 12}, {"mvdx13", 13}, {"mvdx14", 14}, {"mvdx15", 15},
  {NULL, 0}
d745 2
a746 2
  {"mvax0", 0}, {"mvax1", 1}, {"mvax2", 2}, {"mvax3", 3},
  {NULL, 0}
d751 2
a752 2
  {"dspsc", 0},
  {NULL, 0}
d2329 1
d2348 1
a2348 1
  /* Never called becasue '.req' does not start line.  */
d2350 1
d2379 1
d2383 1
d2656 71
d10101 6
a10106 5
  struct reg_entry *new =
    (struct reg_entry *) xmalloc (sizeof (struct reg_entry));
  char *name = xmalloc (strlen (str) + 1);
  strcpy (name, str);

d10109 1
d10111 8
a10118 1
  hash_insert (htab, name, (PTR) new);
d10123 1
a10123 1
   	newname .req existing_name
d10203 1
d10266 1
d10313 1
@


1.145
log
@	* config/tc-arm.c (do_iwmmxt_byte_addr): Reject control
	registers.
	(do_iwmmxt_word_addr): With a control register, reject conditional
	execution and reject a non-word size.
@
text
@d772 1
a772 1
  {mav_mvdx_table,  15, NULL, N_("Maverick MVFX register expected")},
d10323 1
a10323 1
	flags ^= F_SOFT_FLOAT;
@


1.144
log
@Add support for unindexed form of Addressing Mode 5
@
text
@d4893 1
d5069 4
@


1.143
log
@	* config/tc-arm.c (arm_archs): Add iwmmxt.
@
text
@d3332 3
a3334 1
	  if (wb_ok && skip_past_comma (& p) == SUCCESS)
d3336 5
a3340 2
	      /* [Rn], #expr  */
	      write_back = WRITE_BACK;
d3342 17
a3358 1
	      if (reg == REG_PC)
d3360 11
a3370 2
		  inst.error = _("pc may not be used in post-increment");
		  return FAIL;
d3372 9
d3382 3
a3384 1
	      if (cp_address_offset (& p) == FAIL)
d3386 30
d3418 4
a3421 1
	    pre_inc = PRE_INDEX | INDEX_UP;
@


1.142
log
@* tc-arm.c (FPU_DEFAULT, case TE_LINUX): Default to FPU_ARCH_FPA.
(FPU_DEFAULT, case TE_NetBSD): Default to FPU_ARCH_VFP for ELF,
FPU_ARCH_FPA for AOUT.
(md_begin): Don't try to guess the floating point architecture from
the CPU if the OS ABI (Linux, NetBSD) mandates a particular form.
@
text
@d11894 1
@


1.141
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d137 13
d10199 3
d10206 3
@


1.140
log
@2003-04-02  Philip Blundell  <philb@@gnu.org>

	* config/tc-arm.c (arm_force_relocation): Return 0 for OFFSET_IMM.
@
text
@a2347 2
  { "file",        (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  { "loc",         dwarf2_directive_loc,  0 },
@


1.140.2.1
log
@* tc-arm.c (FPU_DEFAULT, case TE_LINUX): Default to FPU_ARCH_FPA.
(FPU_DEFAULT, case TE_NetBSD): Default to FPU_ARCH_VFP for ELF,
FPU_ARCH_FPA for AOUT.
(md_begin): Don't try to guess the floating point architecture from
the CPU if the OS ABI (Linux, NetBSD) mandates a particular form.
@
text
@a136 13
#ifdef TE_LINUX
#define FPU_DEFAULT FPU_ARCH_FPA
#endif

#ifdef TE_NetBSD
#ifdef OBJ_ELF
#define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, but VFP order.  */
#else
/* Legacy a.out format.  */
#define FPU_DEFAULT FPU_ARCH_FPA	/* Soft-float, but FPA order.  */
#endif
#endif

a10187 3
#if !(defined (TE_LINUX) || defined (TE_NetBSD))
      /* Some environments specify a default FPU.  If they don't, infer it
	 from the processor.  */
a10191 3
#else
      mfpu_opt = FPU_DEFAULT;
#endif
@


1.139
log
@Fixes for iWMMXt contribution.
@
text
@d12478 1
@


1.138
log
@Add iWMMXt support
@
text
@d62 1
a62 1
#define ARM_CEXT_IWMMXT   0x00200000    /* Intel(r) Wireless MMX(tm) technology coprocessor.   */
d88 1
a88 1
#define ARM_ARCH_IWMMXT	(ARM_ARCH_V5TE	| ARM_CEXT_XSCALE | ARM_CEXT_IWMMXT)
d605 1
a605 1
  /* Intel(r) Wireless MMX(tm) technology register names.  */
d762 1
a762 1
  {iwmmxt_table,    23, NULL, N_("Intel(r) Wireless MMX(tm) technology register expected")},
a1079 164
  /* Intel(r) Wireless MMX(tm) technology instructions.  */
  {"tandcb",     0xee130130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandch",     0xee530130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandcw",     0xee930130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tbcstb",     0xee400010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcsth",     0xee400050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcstw",     0xee400090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"textrcb",    0xee130170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrch",    0xee530170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrcw",    0xee930170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrmub",   0xee100070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuh",   0xee500070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuw",   0xee900070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsb",   0xee100078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsh",   0xee500078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsw",   0xee900078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"tinsrb",     0xee600010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrh",     0xee600050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrw",     0xee600090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tmcr",       0xee000110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmcr},
  {"tmcrr",      0xec400000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmcrr},
  {"tmia",       0xee200010, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiaph",     0xee280010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabb",     0xee2c0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabt",     0xee2d0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatb",     0xee2e0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatt",     0xee2f0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmovmskb",   0xee100030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskh",   0xee500030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskw",   0xee900030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmrc",       0xee100110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmrc},
  {"tmrrc",      0xec500000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmrrc},
  {"torcb",      0xee130150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torch",      0xee530150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torcw",      0xee930150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"waccb",      0xee0001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wacch",      0xee4001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waccw",      0xee8001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waddbss",    0xee300180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddb",      0xee000180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddbus",    0xee100180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhss",    0xee700180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddh",      0xee400180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhus",    0xee500180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwss",    0xeeb00180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddw",      0xee800180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwus",    0xee900180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waligni",    0xee000020, 7, ARM_CEXT_IWMMXT, do_iwmmxt_waligni},
  {"walignr0",   0xee800020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr1",   0xee900020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr2",   0xeea00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr3",   0xeeb00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wand",       0xee200000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wandn",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2b",     0xee800000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2br",    0xee900000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2h",     0xeec00000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2hr",    0xeed00000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqb",    0xee000060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqh",    0xee400060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqw",    0xee800060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtub",   0xee100060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuh",   0xee500060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuw",   0xee900060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsb",   0xee300060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsh",   0xee700060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsw",   0xeeb00060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wldrb",      0xec100000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrh",      0xec100100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrw",      0xec100200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wldrd",      0xec100300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wmacs",      0xee600100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacsz",     0xee700100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacu",      0xee400100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacuz",     0xee500100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmadds",     0xeea00100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaddu",     0xee800100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsb",     0xee200160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsh",     0xee600160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsw",     0xeea00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxub",     0xee000160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuh",     0xee400160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuw",     0xee800160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsb",     0xee300160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsh",     0xee700160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsw",     0xeeb00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminub",     0xee100160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuh",     0xee500160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuw",     0xee900160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmov",       0xee000000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wmov},
  {"wmulsm",     0xee300100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulsl",     0xee200100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulum",     0xee100100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulul",     0xee000100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wor",        0xee000000, 3, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhss",   0xee700080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhus",   0xee500080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwss",   0xeeb00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwus",   0xee900080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdss",   0xeef00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdus",   0xeed00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorh",      0xee700040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorhg",     0xee700148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrorw",      0xeeb00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorwg",     0xeeb00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrord",      0xeef00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrordg",     0xeef00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsadb",      0xee000120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadbz",     0xee100120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadh",      0xee400120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadhz",     0xee500120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wshufh",     0xee0001e0, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wshufh},
  {"wsllh",      0xee500040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllhg",     0xee500148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsllw",      0xee900040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllwg",     0xee900148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wslld",      0xeed00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wslldg",     0xeed00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrah",      0xee400040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrahg",     0xee400148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsraw",      0xee800040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrawg",     0xee800148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrad",      0xeec00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsradg",     0xeec00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlh",      0xee600040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlhg",     0xee600148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlw",      0xeea00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlwg",     0xeea00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrld",      0xeee00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrldg",     0xeee00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wstrb",      0xec000000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrh",      0xec000100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrw",      0xec000200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wstrd",      0xec000300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wsubbss",    0xee3001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubb",      0xee0001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubbus",    0xee1001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhss",    0xee7001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubh",      0xee4001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhus",    0xee5001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwss",    0xeeb001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubw",      0xee8001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwus",    0xee9001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckehub", 0xee0000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuh", 0xee4000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuw", 0xee8000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsb", 0xee2000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsh", 0xee6000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsw", 0xeea000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckihb",  0xee1000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihh",  0xee5000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihw",  0xee9000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckelub", 0xee0000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluh", 0xee4000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluw", 0xee8000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsb", 0xee2000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsh", 0xee6000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsw", 0xeea000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckilb",  0xee1000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilh",  0xee5000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilw",  0xee9000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wxor",       0xee100000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wzero",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wzero},

d1827 164
d2364 3
d3005 1
a3005 1
/* A Intel(r) Wireless MMX(tm) technology register
d3050 1
a3050 1
  sprintf (buff, _("Intel(r) Wireless MMX(tm) technology register expected, not '%.100s'"), start);
d10089 48
d10270 1
a10270 1
      mach = bfd_mach_arm_4;
d10300 1
d10302 10
a10312 1
    expressionS exp;
d10316 2
a10317 1
    
a10326 4
    exp.X_op = O_constant;
    exp.X_add_number = mach;
    exp.X_add_symbol = NULL;
    exp.X_op_symbol = NULL;
d10328 19
a10346 1
    emit_expr (&exp, 4);
d10351 2
a10352 1

d11840 1
@


1.137
log
@Add support for marking ARM ELF binaries as support the Cirrus EP9312 Maverick
floating point co-processor.
@
text
@d62 1
d88 1
d504 29
d577 4
d600 34
d762 1
d781 1
d783 1
a783 1
  REG_TYPE_MAX = 12
d1012 25
d1080 164
d3002 51
d3390 138
d4593 443
d10224 3
a10226 1
  if (cpu_variant & ARM_CEXT_XSCALE)
d10249 27
d10988 12
d11658 1
d11763 1
d11813 1
@


1.136
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d9281 7
d9334 2
@


1.135
log
@	* config/tc-a29k.c (insert_sreg): Prototype.
	(define_some_regs): Prototype, make static.
	(parse_operand): Likewise.
	(md_parse_option <c,arg>): Add ATTRIBUTE_UNUSED.
	(md_show_usage <stream>): Likewise.
	(md_section_align <segment>): Likewise.
	(md_convert_frag <all args>): Likewise.
	(md_estimate_size_before_relax <all args>): Likewise.
	(md_apply_fix3): Don't cast valP pointer type.  Fix bogus >>='s.
	* config/tc-arm.c (arm_validate_fix): Only for OBJ_COFF or OBJ_ELF.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d11446 1
a11446 3
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
d11458 1
a11458 1
  return S_FORCE_RELOC (fixp->fx_addsy);
@


1.134
log
@	* config/tc-arm.c (arm_force_relocation): Move out of #if OBJ_ELF.
	Move OBJ_COFF TC_FORCE_RELOCATION code here so that COFF handles
	ARM_IMMEDIATE and ARM_ADRL_IMMEDIATE relocs as for ELF.
	* config/tc-arm.h (TC_FORCE_RELOCATION): Define for both ELF and
	COFF to call arm_force_relocation.
@
text
@d11418 1
d11435 1
@


1.133
log
@	* config/tc-arm.c (arm_force_relocation): Return 0 for ARM_IMMEDIATE
	and ARM_ADRL_IMMEDIATE.
@
text
@d11435 26
d11477 1
a11541 20
}

int
arm_force_relocation (fixp)
     struct fix * fixp;
{
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;

  /* Resolve these relocations even if the symbol is extern or weak.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 0;

  return S_FORCE_RELOC (fixp->fx_addsy);
@


1.132
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2132 1
a2132 1
  struct literal_pool * next;  
d2199 1
a2199 1
  literal_pool * pool;  
d5799 1
a5799 1
  
d10297 1
a10297 1
		    _("literal referenced across section boundary"));	
d11528 5
@


1.131
log
@Allow BKPT instruction to be specified without an operand.  Add a test for this.
@
text
@d147 5
a151 5
static int uses_apcs_26      = false;
static int atpcs             = false;
static int support_interwork = false;
static int uses_apcs_float   = false;
static int pic_code          = false;
d345 2
a346 2
  const char *  template;
  boolean       cpsr;
d363 16
a378 16
  {"CPSR",	true,  PSR_c | PSR_f},
  {"CPSR_all",	true,  PSR_c | PSR_f},
  {"SPSR",	false, PSR_c | PSR_f},
  {"SPSR_all",	false, PSR_c | PSR_f},
  {"CPSR_flg",	true,  PSR_f},
  {"CPSR_f",    true,  PSR_f},
  {"SPSR_flg",	false, PSR_f},
  {"SPSR_f",    false, PSR_f},
  {"CPSR_c",	true,  PSR_c},
  {"CPSR_ctl",	true,  PSR_c},
  {"SPSR_c",	false, PSR_c},
  {"SPSR_ctl",	false, PSR_c},
  {"CPSR_x",    true,  PSR_x},
  {"CPSR_s",    true,  PSR_s},
  {"SPSR_x",    false, PSR_x},
  {"SPSR_s",    false, PSR_s},
d380 120
a499 120
  {"CPSR_fs",	true, PSR_f | PSR_s},
  {"CPSR_fx",	true, PSR_f | PSR_x},
  {"CPSR_fc",	true, PSR_f | PSR_c},
  {"CPSR_sf",	true, PSR_s | PSR_f},
  {"CPSR_sx",	true, PSR_s | PSR_x},
  {"CPSR_sc",	true, PSR_s | PSR_c},
  {"CPSR_xf",	true, PSR_x | PSR_f},
  {"CPSR_xs",	true, PSR_x | PSR_s},
  {"CPSR_xc",	true, PSR_x | PSR_c},
  {"CPSR_cf",	true, PSR_c | PSR_f},
  {"CPSR_cs",	true, PSR_c | PSR_s},
  {"CPSR_cx",	true, PSR_c | PSR_x},
  {"CPSR_fsx",	true, PSR_f | PSR_s | PSR_x},
  {"CPSR_fsc",	true, PSR_f | PSR_s | PSR_c},
  {"CPSR_fxs",	true, PSR_f | PSR_x | PSR_s},
  {"CPSR_fxc",	true, PSR_f | PSR_x | PSR_c},
  {"CPSR_fcs",	true, PSR_f | PSR_c | PSR_s},
  {"CPSR_fcx",	true, PSR_f | PSR_c | PSR_x},
  {"CPSR_sfx",	true, PSR_s | PSR_f | PSR_x},
  {"CPSR_sfc",	true, PSR_s | PSR_f | PSR_c},
  {"CPSR_sxf",	true, PSR_s | PSR_x | PSR_f},
  {"CPSR_sxc",	true, PSR_s | PSR_x | PSR_c},
  {"CPSR_scf",	true, PSR_s | PSR_c | PSR_f},
  {"CPSR_scx",	true, PSR_s | PSR_c | PSR_x},
  {"CPSR_xfs",	true, PSR_x | PSR_f | PSR_s},
  {"CPSR_xfc",	true, PSR_x | PSR_f | PSR_c},
  {"CPSR_xsf",	true, PSR_x | PSR_s | PSR_f},
  {"CPSR_xsc",	true, PSR_x | PSR_s | PSR_c},
  {"CPSR_xcf",	true, PSR_x | PSR_c | PSR_f},
  {"CPSR_xcs",	true, PSR_x | PSR_c | PSR_s},
  {"CPSR_cfs",	true, PSR_c | PSR_f | PSR_s},
  {"CPSR_cfx",	true, PSR_c | PSR_f | PSR_x},
  {"CPSR_csf",	true, PSR_c | PSR_s | PSR_f},
  {"CPSR_csx",	true, PSR_c | PSR_s | PSR_x},
  {"CPSR_cxf",	true, PSR_c | PSR_x | PSR_f},
  {"CPSR_cxs",	true, PSR_c | PSR_x | PSR_s},
  {"CPSR_fsxc",	true, PSR_f | PSR_s | PSR_x | PSR_c},
  {"CPSR_fscx",	true, PSR_f | PSR_s | PSR_c | PSR_x},
  {"CPSR_fxsc",	true, PSR_f | PSR_x | PSR_s | PSR_c},
  {"CPSR_fxcs",	true, PSR_f | PSR_x | PSR_c | PSR_s},
  {"CPSR_fcsx",	true, PSR_f | PSR_c | PSR_s | PSR_x},
  {"CPSR_fcxs",	true, PSR_f | PSR_c | PSR_x | PSR_s},
  {"CPSR_sfxc",	true, PSR_s | PSR_f | PSR_x | PSR_c},
  {"CPSR_sfcx",	true, PSR_s | PSR_f | PSR_c | PSR_x},
  {"CPSR_sxfc",	true, PSR_s | PSR_x | PSR_f | PSR_c},
  {"CPSR_sxcf",	true, PSR_s | PSR_x | PSR_c | PSR_f},
  {"CPSR_scfx",	true, PSR_s | PSR_c | PSR_f | PSR_x},
  {"CPSR_scxf",	true, PSR_s | PSR_c | PSR_x | PSR_f},
  {"CPSR_xfsc",	true, PSR_x | PSR_f | PSR_s | PSR_c},
  {"CPSR_xfcs",	true, PSR_x | PSR_f | PSR_c | PSR_s},
  {"CPSR_xsfc",	true, PSR_x | PSR_s | PSR_f | PSR_c},
  {"CPSR_xscf",	true, PSR_x | PSR_s | PSR_c | PSR_f},
  {"CPSR_xcfs",	true, PSR_x | PSR_c | PSR_f | PSR_s},
  {"CPSR_xcsf",	true, PSR_x | PSR_c | PSR_s | PSR_f},
  {"CPSR_cfsx",	true, PSR_c | PSR_f | PSR_s | PSR_x},
  {"CPSR_cfxs",	true, PSR_c | PSR_f | PSR_x | PSR_s},
  {"CPSR_csfx",	true, PSR_c | PSR_s | PSR_f | PSR_x},
  {"CPSR_csxf",	true, PSR_c | PSR_s | PSR_x | PSR_f},
  {"CPSR_cxfs",	true, PSR_c | PSR_x | PSR_f | PSR_s},
  {"CPSR_cxsf",	true, PSR_c | PSR_x | PSR_s | PSR_f},
  {"SPSR_fs",	false, PSR_f | PSR_s},
  {"SPSR_fx",	false, PSR_f | PSR_x},
  {"SPSR_fc",	false, PSR_f | PSR_c},
  {"SPSR_sf",	false, PSR_s | PSR_f},
  {"SPSR_sx",	false, PSR_s | PSR_x},
  {"SPSR_sc",	false, PSR_s | PSR_c},
  {"SPSR_xf",	false, PSR_x | PSR_f},
  {"SPSR_xs",	false, PSR_x | PSR_s},
  {"SPSR_xc",	false, PSR_x | PSR_c},
  {"SPSR_cf",	false, PSR_c | PSR_f},
  {"SPSR_cs",	false, PSR_c | PSR_s},
  {"SPSR_cx",	false, PSR_c | PSR_x},
  {"SPSR_fsx",	false, PSR_f | PSR_s | PSR_x},
  {"SPSR_fsc",	false, PSR_f | PSR_s | PSR_c},
  {"SPSR_fxs",	false, PSR_f | PSR_x | PSR_s},
  {"SPSR_fxc",	false, PSR_f | PSR_x | PSR_c},
  {"SPSR_fcs",	false, PSR_f | PSR_c | PSR_s},
  {"SPSR_fcx",	false, PSR_f | PSR_c | PSR_x},
  {"SPSR_sfx",	false, PSR_s | PSR_f | PSR_x},
  {"SPSR_sfc",	false, PSR_s | PSR_f | PSR_c},
  {"SPSR_sxf",	false, PSR_s | PSR_x | PSR_f},
  {"SPSR_sxc",	false, PSR_s | PSR_x | PSR_c},
  {"SPSR_scf",	false, PSR_s | PSR_c | PSR_f},
  {"SPSR_scx",	false, PSR_s | PSR_c | PSR_x},
  {"SPSR_xfs",	false, PSR_x | PSR_f | PSR_s},
  {"SPSR_xfc",	false, PSR_x | PSR_f | PSR_c},
  {"SPSR_xsf",	false, PSR_x | PSR_s | PSR_f},
  {"SPSR_xsc",	false, PSR_x | PSR_s | PSR_c},
  {"SPSR_xcf",	false, PSR_x | PSR_c | PSR_f},
  {"SPSR_xcs",	false, PSR_x | PSR_c | PSR_s},
  {"SPSR_cfs",	false, PSR_c | PSR_f | PSR_s},
  {"SPSR_cfx",	false, PSR_c | PSR_f | PSR_x},
  {"SPSR_csf",	false, PSR_c | PSR_s | PSR_f},
  {"SPSR_csx",	false, PSR_c | PSR_s | PSR_x},
  {"SPSR_cxf",	false, PSR_c | PSR_x | PSR_f},
  {"SPSR_cxs",	false, PSR_c | PSR_x | PSR_s},
  {"SPSR_fsxc",	false, PSR_f | PSR_s | PSR_x | PSR_c},
  {"SPSR_fscx",	false, PSR_f | PSR_s | PSR_c | PSR_x},
  {"SPSR_fxsc",	false, PSR_f | PSR_x | PSR_s | PSR_c},
  {"SPSR_fxcs",	false, PSR_f | PSR_x | PSR_c | PSR_s},
  {"SPSR_fcsx",	false, PSR_f | PSR_c | PSR_s | PSR_x},
  {"SPSR_fcxs",	false, PSR_f | PSR_c | PSR_x | PSR_s},
  {"SPSR_sfxc",	false, PSR_s | PSR_f | PSR_x | PSR_c},
  {"SPSR_sfcx",	false, PSR_s | PSR_f | PSR_c | PSR_x},
  {"SPSR_sxfc",	false, PSR_s | PSR_x | PSR_f | PSR_c},
  {"SPSR_sxcf",	false, PSR_s | PSR_x | PSR_c | PSR_f},
  {"SPSR_scfx",	false, PSR_s | PSR_c | PSR_f | PSR_x},
  {"SPSR_scxf",	false, PSR_s | PSR_c | PSR_x | PSR_f},
  {"SPSR_xfsc",	false, PSR_x | PSR_f | PSR_s | PSR_c},
  {"SPSR_xfcs",	false, PSR_x | PSR_f | PSR_c | PSR_s},
  {"SPSR_xsfc",	false, PSR_x | PSR_s | PSR_f | PSR_c},
  {"SPSR_xscf",	false, PSR_x | PSR_s | PSR_c | PSR_f},
  {"SPSR_xcfs",	false, PSR_x | PSR_c | PSR_f | PSR_s},
  {"SPSR_xcsf",	false, PSR_x | PSR_c | PSR_s | PSR_f},
  {"SPSR_cfsx",	false, PSR_c | PSR_f | PSR_s | PSR_x},
  {"SPSR_cfxs",	false, PSR_c | PSR_f | PSR_x | PSR_s},
  {"SPSR_csfx",	false, PSR_c | PSR_s | PSR_f | PSR_x},
  {"SPSR_csxf",	false, PSR_c | PSR_s | PSR_x | PSR_f},
  {"SPSR_cxfs",	false, PSR_c | PSR_x | PSR_f | PSR_s},
  {"SPSR_cxsf",	false, PSR_c | PSR_x | PSR_s | PSR_f},
d2116 1
a2116 1
static int label_is_thumb_function_name = false;
d2507 1
a2507 1
  label_is_thumb_function_name = true;
d4452 1
a4452 1
/* Return true if anything in the expression is a bignum.  */
d11314 1
a11314 1
      label_is_thumb_function_name = false;
d11442 1
a11442 1
boolean
d11465 1
a11465 1
boolean
@


1.130
log
@Allow an absolute reference to _GLOBAL_TABLE_OFFSET_ to be converted into
a GOT reloc.
@
text
@d3932 4
a3935 1
  if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
d3937 1
a3937 1
      inst.error = _("bad or missing expression");
d4117 4
a4120 1
  if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
d4122 1
a4122 1
      inst.error = _("bad or missing expression");
@


1.129
log
@Note that an implemented BFD_RELOC_ARM_IMMEDIATE has been done.
Do not issue reloc number of unimplemented BFD_RELOC_ARM_IMMEDIATE and
BFD_RELOC_ARM_OFFSET_IMM relocs - their name is already in the error message
- plus remove them from the default case.
Warn about unpredictable behavior of LDM and STM instructions.
@
text
@d10342 1
a10342 1
  if (code == BFD_RELOC_32_PCREL
@


1.128
log
@gas reloc rewrite.
@
text
@d5769 25
d9680 1
d9687 1
d10304 1
a10304 2
		    _("internal relocation (type %d) not fixed up (IMMEDIATE)"),
		    fixp->fx_r_type);
d10314 1
a10314 2
		    _("internal_relocation (type %d) not fixed up (OFFSET_IMM)"),
		    fixp->fx_r_type);
a10322 2
	  case BFD_RELOC_ARM_IMMEDIATE:    type = "IMMEDIATE";    break;
	  case BFD_RELOC_ARM_OFFSET_IMM:   type = "OFFSET_IMM";   break;
@


1.127
log
@Add sh-nto support
@
text
@a10012 4
    case BFD_RELOC_ARM_GOTPC:
      md_number_to_chars (buf, value, 4);
      break;

d11389 1
a11389 1
boolean
a11402 1
      return true;
a11403 2

  return false;
a11442 7
  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;

  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;

d11452 6
d11500 1
a11500 1
  return 0;
@


1.126
log
@Ensure that offset to literal pool is computed using signed arithmetic so that
proper sign extension is performed if X_add_number is a 64-bit integer.
@
text
@d2231 1
a2231 1
	  inst.error = _("Literal Pool Overflow");
d10268 1
a10268 1
		    _("Literal referenced across section boundary"));	
a10514 1
	      -mimplicit-litpool-dump    Dump literal pool on section change
@


1.125
log
@Add per-section and per-sub-section literal pools.
@
text
@d2240 1
a2240 1
  inst.reloc.exp.X_add_number = (entry) * 4 - 8;
d9685 1
a9685 1
			      value);
d10051 2
a10052 1
			  _("invalid offset, value too big (0x%08lX)"), value);
d10061 2
a10062 1
			  _("invalid offset, value too big (0x%08lX)"), value);
d10069 2
a10070 1
			  _("invalid offset, value too big (0x%08lX)"), value);
d10077 2
a10078 1
			  _("invalid offset, value too big (0x%08lX)"), value);
d10085 2
a10086 1
			  _("invalid offset, value too big (0x%08lX)"), value);
@


1.124
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@a2063 3
static void arm_s_text PARAMS ((int));
static void arm_s_data PARAMS ((int));
static void arm_s_section PARAMS ((int));
a2084 7
  /* Allow for the effect of section changes.  */
  { "text",        arm_s_text,    0 },
  { "data",        arm_s_data,    0 },
  { "section",     arm_s_section, 0 },
  { "section.s",   arm_s_section, 0 },
  { "sect",        arm_s_section, 0 },
  { "sect.s",      arm_s_section, 0 },
d2088 1
a2088 1
  { "file",        dwarf2_directive_file, 0 },
d2118 1
a2118 1
/* Literal stuff.  */
d2122 21
a2142 1
typedef struct literalS
d2144 1
a2144 3
  struct expressionS exp;
  struct arm_it *    inst;
} literalT;
d2146 16
a2161 1
literalT literals[MAX_LITERAL_POOL_SIZE];
d2163 18
a2180 2
/* Next free entry in the pool.  */
int next_literal_pool_place = 0;
d2182 7
a2188 2
/* Next literal pool number.  */
int lit_pool_num = 1;
d2190 3
a2192 1
symbolS * current_poolP = NULL;
d2194 2
d2199 4
a2202 1
  int lit_count = 0;
d2204 6
a2209 10
  if (current_poolP == NULL)
    current_poolP = symbol_create (FAKE_LABEL_NAME, undefined_section,
				   (valueT) 0, &zero_address_frag);

  /* Check if this literal value is already in the pool:  */
  while (lit_count < next_literal_pool_place)
    {
      if (literals[lit_count].exp.X_op == inst.reloc.exp.X_op
	  && inst.reloc.exp.X_op == O_constant
	  && (literals[lit_count].exp.X_add_number
d2211 2
a2212 1
	  && literals[lit_count].exp.X_unsigned == inst.reloc.exp.X_unsigned)
d2215 3
a2217 3
      if (literals[lit_count].exp.X_op == inst.reloc.exp.X_op
	  && inst.reloc.exp.X_op == O_symbol
	  && (literals[lit_count].exp.X_add_number
d2219 1
a2219 1
	  && (literals[lit_count].exp.X_add_symbol
d2221 1
a2221 1
	  && (literals[lit_count].exp.X_op_symbol
d2223 1
a2223 3
	break;

      lit_count++;
d2226 2
a2227 1
  if (lit_count == next_literal_pool_place) /* New entry.  */
d2229 1
a2229 1
      if (next_literal_pool_place >= MAX_LITERAL_POOL_SIZE)
d2231 1
a2231 1
	  inst.error = _("literal pool overflow");
d2235 2
a2236 2
      literals[next_literal_pool_place].exp = inst.reloc.exp;
      lit_count = next_literal_pool_place++;
d2239 3
a2241 3
  inst.reloc.exp.X_op = O_symbol;
  inst.reloc.exp.X_add_number = (lit_count) * 4 - 8;
  inst.reloc.exp.X_add_symbol = current_poolP;
d2403 2
a2404 1
  int lit_count = 0;
d2407 4
a2410 1
  if (current_poolP == NULL)
d2420 1
a2420 1
  sprintf (sym_name, "$$lit_\002%x", lit_pool_num++);
d2422 1
a2422 1
  symbol_locate (current_poolP, sym_name, now_seg,
d2424 1
a2424 1
  symbol_table_insert (current_poolP);
d2426 1
a2426 1
  ARM_SET_THUMB (current_poolP, thumb_mode);
d2429 1
a2429 1
  ARM_SET_INTERWORK (current_poolP, support_interwork);
d2432 1
a2432 1
  while (lit_count < next_literal_pool_place)
d2434 1
a2434 1
    emit_expr (&(literals[lit_count++].exp), 4); /* .word  */
d2436 3
a2438 2
  next_literal_pool_place = 0;
  current_poolP = NULL;
a2604 49
/* If we change section we must dump the literal pool first.  */

static void
arm_s_text (ignore)
     int ignore;
{
  if (now_seg != text_section)
    s_ltorg (0);

#ifdef OBJ_ELF
  obj_elf_text (ignore);
#else
  s_text (ignore);
#endif
}

static void
arm_s_data (ignore)
     int ignore;
{
  if (flag_readonly_data_in_text)
    {
      if (now_seg != text_section)
	s_ltorg (0);
    }
  else if (now_seg != data_section)
    s_ltorg (0);

#ifdef OBJ_ELF
  obj_elf_data (ignore);
#else
  s_data (ignore);
#endif
}

static void
arm_s_section (ignore)
     int ignore;
{
  s_ltorg (0);

#ifdef OBJ_ELF
  obj_elf_section (ignore);
#endif
#ifdef OBJ_COFF
  obj_coff_section (ignore);
#endif
}

d10260 2
a10261 2
      /* If this is called then the a literal has been referenced across
	 a section boundary - possibly due to an implicit dump.  */
d10263 1
a10263 1
		    _("literal referenced across section boundary (Implicit dump?)"));
d10510 1
d10512 1
a10512 1
      For now we will also provide support for
d11217 1
a11217 2
  if (current_poolP == NULL)
    return;
d11219 6
a11224 3
  /* Put it at the end of text section.  */
  subseg_set (text_section, 0);
  s_ltorg (0);
@


1.123
log
@For the Thumb BLX reloc round the relocation up rather than down.
@
text
@d10549 1
a10549 1
CONST char * md_shortopts = "m:k";
@


1.122
log
@COFF: Dump literal pool when changing sections.
@
text
@d2230 1
a2230 1
  symbol_clear_list_pointers(symbolP);
d6966 1
a6966 1
    abort();
d7079 1
a7079 1
    abort();
d7096 1
a7096 1
vfp_sp_ldstm(str, ldstm_type)
d7133 1
a7133 1
vfp_dp_ldstm(str, ldstm_type)
d9942 1
d9950 5
a9954 8
	  /* Remove bit zero of the adjusted offset.  Bit zero can only be
	     set if the upper insn is at a half-word boundary, since the
	     destination address, an ARM instruction, must always be on a
	     word boundary.  The semantics of the BLX (1) instruction, however,
	     are that bit zero in the offset must always be zero, and the
	     corresponding bit one in the target address will be set from bit
	     one of the source address.  */
	  newval2 &= ~1;
@


1.121
log
@Remove redundant call to listing_prev_line
@
text
@d2066 1
a2067 1
static void arm_s_section PARAMS ((int));
a2090 1
#ifdef OBJ_ELF
d2095 1
a2587 1
#ifdef OBJ_ELF
d2594 1
d2596 4
a2600 1
#endif
@


1.120
log
@Remove redundant call to listing_prev().
@
text
@a11217 1
  listing_prev_line ();
@


1.119
log
@	* config/obj-coff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/tc-alpha.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-hppa.c: Likewise.
@
text
@a10401 1
  listing_prev_line (); /* Defined in listing.h.  */
@


1.118
log
@Do not convert a subtract of zero into an add of zero.
@
text
@d524 1
a524 1
static const struct vfp_reg vfp_regs[] = 
d845 1
a845 1
static void do_mav_triple	PARAMS ((char *, int, enum arm_reg_type, 
d858 1
a858 1
static void do_mav_quad		PARAMS ((char *, int, enum arm_reg_type, 
d1109 1
a1109 1
  /* Note: bx (and blx) are required on V5, even if the processor does 
d2168 2
a2169 2
          && inst.reloc.exp.X_op == O_symbol
          && (literals[lit_count].exp.X_add_number
d2171 1
a2171 1
          && (literals[lit_count].exp.X_add_symbol
d2173 1
a2173 1
          && (literals[lit_count].exp.X_op_symbol
d2175 1
a2175 1
        break;
d2627 1
a2627 1
            frag_align (2, 0, 0);
d2629 1
a2629 1
          record_alignment (now_seg, 1);
d3453 1
a3453 1
              skip_whitespace (str);
d3455 5
a3459 5
              if (* str == '!')
               {
                 str ++;
                 inst.instruction |= WRITE_BACK;
               }
d4030 2
a4031 2
    	{
      	  inst.error = BAD_COND;
d4033 1
a4033 1
    	}
d4091 1
a4091 1
	and it is an error if the caller tried to override that. */
d4334 1
a4334 1
        inst.error = BAD_ARGS;
d4517 1
a4517 1
/* We handle all bad expressions here, so that we can report the faulty 
d5546 1
a5546 1
	  
d6732 1
a6732 1
  for (vreg = vfp_regs + 0; 
d7932 1
a7932 1
  
d7936 1
a7936 1
  
d8184 1
a8184 1
/* cfmvsc32<cond> DSPSC,MVFX[15:0]. */
d9098 1
a9098 1
  
d10490 1
a10490 1
      See if it's a processor-specific option.  
d10508 1
a10508 1
      For now we will also provide support for 
d10584 1
a10584 1
struct arm_option_table arm_opts[] = 
d10792 1
a10792 1
   
d11049 1
a11049 1
      /* Listing option.  Just ignore these, we don't support additional 
d11076 1
a11076 1
	  /* These options are expected to have an argument.  */ 
d11079 1
a11079 1
	      && strncmp (arg, lopt->option + 1, 
d11251 1
a11251 1
		
d11261 1
a11261 1
     
d11310 1
a11310 1
          else switch (S_GET_STORAGE_CLASS (sym))
d11612 1
a11612 1
  
d11619 1
a11619 1
  
d11622 1
a11622 1
  
d11639 1
a11639 1
  
d11655 1
a11655 1
  
d11674 1
a11674 1
  
@


1.117
log
@Fix typo
@
text
@d7436 1
a7436 1
	    offset = -offset;
d7440 1
a7440 1
	      offset = -offset;
d7450 3
a7452 1
	  else
@


1.116
log
@* tc-arm.c (do_xsc_mia, do_xsc_mar, do_xsc_mra): Renamed from
do_mia, do_mar and do_mra respectively.
(do_mav_*): Renamed from do_c_*.
(mav_reg_required_here, mav_parse_offset): Renamed from
cirrus_reg_required_here and cirrus_parse_offset respectively.
(MAV_MODE?): Renamed from CIRRUS_MODE?.
@
text
@d6428 1
a6428 1
     enum vfp_sp_reg_pos pos;
@


1.116.2.1
log
@Fix typo
@
text
@d6428 1
a6428 1
     enum vfp_dp_reg_pos pos;
@


1.116.2.2
log
@oops - omitted fropm previous update
@
text
@d524 1
a524 1
static const struct vfp_reg vfp_regs[] =
d845 1
a845 1
static void do_mav_triple	PARAMS ((char *, int, enum arm_reg_type,
d858 1
a858 1
static void do_mav_quad		PARAMS ((char *, int, enum arm_reg_type,
d1109 1
a1109 1
  /* Note: bx (and blx) are required on V5, even if the processor does
d7450 1
a7450 3
	  /* Note - you cannot convert a subtract of 0 into an
	     add of 0 because the carry flag is set differently.  */
	  else if (offset > 0)
d7930 1
a7930 1

@


1.115
log
@2002-01-18  Richard Earnshaw  <rearnsha@@arm.com>
	    Keith Walker  <keith.walker@@arm.com>
* tc-arm.c (ARM_EXT_V5J, ARM_ARCH_V5TEJ): Define.
(insns): Add pattern for bxj instruction.
(do_bxj): New function.
(arm_cpus): Add arm926ej.
(arm_archs): Add armv5tej.

Testsuite:
2002-01-18  Richard Earnshaw  <rearnsha@@arm.com>
	    Keith Walker  <keith.walker@@arm.com>
* gas/arm/arch5tej.s gas/arm/arch5tej.d: New files.
* gas/arm/arm.exp (arch5tej): New dump test.
@
text
@d622 1
a622 1
/* Cirrus DSP coprocessor registers.  */
d816 3
a818 3
static void do_mia		PARAMS ((char *));
static void do_mar		PARAMS ((char *));
static void do_mra		PARAMS ((char *));
d821 1
a821 1
static void do_c_binops		PARAMS ((char *, int, enum arm_reg_type,
d823 23
a845 23
static void do_c_binops_1a	PARAMS ((char *));
static void do_c_binops_1b	PARAMS ((char *));
static void do_c_binops_1c	PARAMS ((char *));
static void do_c_binops_1d	PARAMS ((char *));
static void do_c_binops_1e	PARAMS ((char *));
static void do_c_binops_1f	PARAMS ((char *));
static void do_c_binops_1g	PARAMS ((char *));
static void do_c_binops_1h	PARAMS ((char *));
static void do_c_binops_1i	PARAMS ((char *));
static void do_c_binops_1j	PARAMS ((char *));
static void do_c_binops_1k	PARAMS ((char *));
static void do_c_binops_1l	PARAMS ((char *));
static void do_c_binops_1m	PARAMS ((char *));
static void do_c_binops_1n	PARAMS ((char *));
static void do_c_binops_1o	PARAMS ((char *));
static void do_c_binops_2a	PARAMS ((char *));
static void do_c_binops_2b	PARAMS ((char *));
static void do_c_binops_2c	PARAMS ((char *));
static void do_c_binops_3a	PARAMS ((char *));
static void do_c_binops_3b	PARAMS ((char *));
static void do_c_binops_3c	PARAMS ((char *));
static void do_c_binops_3d	PARAMS ((char *));
static void do_c_triple		PARAMS ((char *, int, enum arm_reg_type, 
d848 11
a858 11
static void do_c_triple_4a	PARAMS ((char *));
static void do_c_triple_4b	PARAMS ((char *));
static void do_c_triple_5a	PARAMS ((char *));
static void do_c_triple_5b	PARAMS ((char *));
static void do_c_triple_5c	PARAMS ((char *));
static void do_c_triple_5d	PARAMS ((char *));
static void do_c_triple_5e	PARAMS ((char *));
static void do_c_triple_5f	PARAMS ((char *));
static void do_c_triple_5g	PARAMS ((char *));
static void do_c_triple_5h	PARAMS ((char *));
static void do_c_quad		PARAMS ((char *, int, enum arm_reg_type, 
d862 5
a866 5
static void do_c_quad_6a	PARAMS ((char *));
static void do_c_quad_6b	PARAMS ((char *));
static void do_c_dspsc_1	PARAMS ((char *));
static void do_c_dspsc_2	PARAMS ((char *));
static void do_c_shift		PARAMS ((char *, enum arm_reg_type,
d868 7
a874 7
static void do_c_shift_1	PARAMS ((char *));
static void do_c_shift_2	PARAMS ((char *));
static void do_c_ldst		PARAMS ((char *, enum arm_reg_type));
static void do_c_ldst_1		PARAMS ((char *));
static void do_c_ldst_2		PARAMS ((char *));
static void do_c_ldst_3		PARAMS ((char *));
static void do_c_ldst_4		PARAMS ((char *));
d876 1
a876 1
static int cirrus_reg_required_here	PARAMS ((char **, int,
d878 1
a878 1
static int cirrus_parse_offset	PARAMS ((char **, int *));
d946 1
a946 1
#define CIRRUS_MODE1	0x100c
d949 1
a949 1
#define CIRRUS_MODE2	0x0c10
d952 1
a952 1
#define CIRRUS_MODE3	0x1000
d955 1
a955 1
#define CIRRUS_MODE4	0x0c0010
d958 1
a958 1
#define CIRRUS_MODE5	0x00100c
d961 1
a961 1
#define CIRRUS_MODE6	0x00100c05
d1722 86
a1807 86
  {"mia",        0xee200010, 3,  ARM_CEXT_XSCALE,   do_mia},
  {"miaph",      0xee280010, 5,  ARM_CEXT_XSCALE,   do_mia},
  {"miabb",      0xee2c0010, 5,  ARM_CEXT_XSCALE,   do_mia},
  {"miabt",      0xee2d0010, 5,  ARM_CEXT_XSCALE,   do_mia},
  {"miatb",      0xee2e0010, 5,  ARM_CEXT_XSCALE,   do_mia},
  {"miatt",      0xee2f0010, 5,  ARM_CEXT_XSCALE,   do_mia},
  {"mar",        0xec400000, 3,  ARM_CEXT_XSCALE,   do_mar},
  {"mra",        0xec500000, 3,  ARM_CEXT_XSCALE,   do_mra},

  /* Cirrus DSP instructions.  */
  {"cfldrs",     0xec100400, 6,  ARM_CEXT_MAVERICK, do_c_ldst_1},
  {"cfldrd",     0xec500400, 6,  ARM_CEXT_MAVERICK, do_c_ldst_2},
  {"cfldr32",    0xec100500, 7,  ARM_CEXT_MAVERICK, do_c_ldst_3},
  {"cfldr64",    0xec500500, 7,  ARM_CEXT_MAVERICK, do_c_ldst_4},
  {"cfstrs",     0xec000400, 6,  ARM_CEXT_MAVERICK, do_c_ldst_1},
  {"cfstrd",     0xec400400, 6,  ARM_CEXT_MAVERICK, do_c_ldst_2},
  {"cfstr32",    0xec000500, 7,  ARM_CEXT_MAVERICK, do_c_ldst_3},
  {"cfstr64",    0xec400500, 7,  ARM_CEXT_MAVERICK, do_c_ldst_4},
  {"cfmvsr",     0xee000450, 6,  ARM_CEXT_MAVERICK, do_c_binops_2a},
  {"cfmvrs",     0xee100450, 6,  ARM_CEXT_MAVERICK, do_c_binops_1a},
  {"cfmvdlr",    0xee000410, 7,  ARM_CEXT_MAVERICK, do_c_binops_2b},
  {"cfmvrdl",    0xee100410, 7,  ARM_CEXT_MAVERICK, do_c_binops_1b},
  {"cfmvdhr",    0xee000430, 7,  ARM_CEXT_MAVERICK, do_c_binops_2b},
  {"cfmvrdh",    0xee100430, 7,  ARM_CEXT_MAVERICK, do_c_binops_1b},
  {"cfmv64lr",   0xee000510, 8,  ARM_CEXT_MAVERICK, do_c_binops_2c},
  {"cfmvr64l",   0xee100510, 8,  ARM_CEXT_MAVERICK, do_c_binops_1c},
  {"cfmv64hr",   0xee000530, 8,  ARM_CEXT_MAVERICK, do_c_binops_2c},
  {"cfmvr64h",   0xee100530, 8,  ARM_CEXT_MAVERICK, do_c_binops_1c},
  {"cfmval32",   0xee100610, 8,  ARM_CEXT_MAVERICK, do_c_binops_3a},
  {"cfmv32al",   0xee000610, 8,  ARM_CEXT_MAVERICK, do_c_binops_3b},
  {"cfmvam32",   0xee100630, 8,  ARM_CEXT_MAVERICK, do_c_binops_3a},
  {"cfmv32am",   0xee000630, 8,  ARM_CEXT_MAVERICK, do_c_binops_3b},
  {"cfmvah32",   0xee100650, 8,  ARM_CEXT_MAVERICK, do_c_binops_3a},
  {"cfmv32ah",   0xee000650, 8,  ARM_CEXT_MAVERICK, do_c_binops_3b},
  {"cfmva32",    0xee100670, 7,  ARM_CEXT_MAVERICK, do_c_binops_3a},
  {"cfmv32a",    0xee000670, 7,  ARM_CEXT_MAVERICK, do_c_binops_3b},
  {"cfmva64",    0xee100690, 7,  ARM_CEXT_MAVERICK, do_c_binops_3c},
  {"cfmv64a",    0xee000690, 7,  ARM_CEXT_MAVERICK, do_c_binops_3d},
  {"cfmvsc32",   0xee1006b0, 8,  ARM_CEXT_MAVERICK, do_c_dspsc_1},
  {"cfmv32sc",   0xee0006b0, 8,  ARM_CEXT_MAVERICK, do_c_dspsc_2},
  {"cfcpys",     0xee000400, 6,  ARM_CEXT_MAVERICK, do_c_binops_1d},
  {"cfcpyd",     0xee000420, 6,  ARM_CEXT_MAVERICK, do_c_binops_1e},
  {"cfcvtsd",    0xee000460, 7,  ARM_CEXT_MAVERICK, do_c_binops_1f},
  {"cfcvtds",    0xee000440, 7,  ARM_CEXT_MAVERICK, do_c_binops_1g},
  {"cfcvt32s",   0xee000480, 8,  ARM_CEXT_MAVERICK, do_c_binops_1h},
  {"cfcvt32d",   0xee0004a0, 8,  ARM_CEXT_MAVERICK, do_c_binops_1i},
  {"cfcvt64s",   0xee0004c0, 8,  ARM_CEXT_MAVERICK, do_c_binops_1j},
  {"cfcvt64d",   0xee0004e0, 8,  ARM_CEXT_MAVERICK, do_c_binops_1k},
  {"cfcvts32",   0xee100580, 8,  ARM_CEXT_MAVERICK, do_c_binops_1l},
  {"cfcvtd32",   0xee1005a0, 8,  ARM_CEXT_MAVERICK, do_c_binops_1m},
  {"cftruncs32", 0xee1005c0, 10, ARM_CEXT_MAVERICK, do_c_binops_1l},
  {"cftruncd32", 0xee1005e0, 10, ARM_CEXT_MAVERICK, do_c_binops_1m},
  {"cfrshl32",   0xee000550, 8,  ARM_CEXT_MAVERICK, do_c_triple_4a},
  {"cfrshl64",   0xee000570, 8,  ARM_CEXT_MAVERICK, do_c_triple_4b},
  {"cfsh32",     0xee000500, 6,  ARM_CEXT_MAVERICK, do_c_shift_1},
  {"cfsh64",     0xee200500, 6,  ARM_CEXT_MAVERICK, do_c_shift_2},
  {"cfcmps",     0xee100490, 6,  ARM_CEXT_MAVERICK, do_c_triple_5a},
  {"cfcmpd",     0xee1004b0, 6,  ARM_CEXT_MAVERICK, do_c_triple_5b},
  {"cfcmp32",    0xee100590, 7,  ARM_CEXT_MAVERICK, do_c_triple_5c},
  {"cfcmp64",    0xee1005b0, 7,  ARM_CEXT_MAVERICK, do_c_triple_5d},
  {"cfabss",     0xee300400, 6,  ARM_CEXT_MAVERICK, do_c_binops_1d},
  {"cfabsd",     0xee300420, 6,  ARM_CEXT_MAVERICK, do_c_binops_1e},
  {"cfnegs",     0xee300440, 6,  ARM_CEXT_MAVERICK, do_c_binops_1d},
  {"cfnegd",     0xee300460, 6,  ARM_CEXT_MAVERICK, do_c_binops_1e},
  {"cfadds",     0xee300480, 6,  ARM_CEXT_MAVERICK, do_c_triple_5e},
  {"cfaddd",     0xee3004a0, 6,  ARM_CEXT_MAVERICK, do_c_triple_5f},
  {"cfsubs",     0xee3004c0, 6,  ARM_CEXT_MAVERICK, do_c_triple_5e},
  {"cfsubd",     0xee3004e0, 6,  ARM_CEXT_MAVERICK, do_c_triple_5f},
  {"cfmuls",     0xee100400, 6,  ARM_CEXT_MAVERICK, do_c_triple_5e},
  {"cfmuld",     0xee100420, 6,  ARM_CEXT_MAVERICK, do_c_triple_5f},
  {"cfabs32",    0xee300500, 7,  ARM_CEXT_MAVERICK, do_c_binops_1n},
  {"cfabs64",    0xee300520, 7,  ARM_CEXT_MAVERICK, do_c_binops_1o},
  {"cfneg32",    0xee300540, 7,  ARM_CEXT_MAVERICK, do_c_binops_1n},
  {"cfneg64",    0xee300560, 7,  ARM_CEXT_MAVERICK, do_c_binops_1o},
  {"cfadd32",    0xee300580, 7,  ARM_CEXT_MAVERICK, do_c_triple_5g},
  {"cfadd64",    0xee3005a0, 7,  ARM_CEXT_MAVERICK, do_c_triple_5h},
  {"cfsub32",    0xee3005c0, 7,  ARM_CEXT_MAVERICK, do_c_triple_5g},
  {"cfsub64",    0xee3005e0, 7,  ARM_CEXT_MAVERICK, do_c_triple_5h},
  {"cfmul32",    0xee100500, 7,  ARM_CEXT_MAVERICK, do_c_triple_5g},
  {"cfmul64",    0xee100520, 7,  ARM_CEXT_MAVERICK, do_c_triple_5h},
  {"cfmac32",    0xee100540, 7,  ARM_CEXT_MAVERICK, do_c_triple_5g},
  {"cfmsc32",    0xee100560, 7,  ARM_CEXT_MAVERICK, do_c_triple_5g},
  {"cfmadd32",   0xee000600, 8,  ARM_CEXT_MAVERICK, do_c_quad_6a},
  {"cfmsub32",   0xee100600, 8,  ARM_CEXT_MAVERICK, do_c_quad_6a},
  {"cfmadda32",  0xee200600, 9,  ARM_CEXT_MAVERICK, do_c_quad_6b},
  {"cfmsuba32",  0xee300600, 9,  ARM_CEXT_MAVERICK, do_c_quad_6b},
d4138 1
a4138 1
do_mia (str)
d4168 1
a4168 1
do_mar (str)
d4197 1
a4197 1
do_mra (str)
d7912 1
a7912 1
cirrus_reg_required_here (str, shift, regtype)
d7938 1
a7938 1
/* Cirrus Instructions.  */
d7943 1
a7943 1
do_c_binops_1a (str)
d7946 1
a7946 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_RN, REG_TYPE_MVF);
d7950 1
a7950 1
do_c_binops_1b (str)
d7953 1
a7953 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_RN, REG_TYPE_MVD);
d7957 1
a7957 1
do_c_binops_1c (str)
d7960 1
a7960 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_RN, REG_TYPE_MVDX);
d7964 1
a7964 1
do_c_binops_1d (str)
d7967 1
a7967 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVF, REG_TYPE_MVF);
d7971 1
a7971 1
do_c_binops_1e (str)
d7974 1
a7974 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVD, REG_TYPE_MVD);
d7978 1
a7978 1
do_c_binops_1f (str)
d7981 1
a7981 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVD, REG_TYPE_MVF);
d7985 1
a7985 1
do_c_binops_1g (str)
d7988 1
a7988 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVF, REG_TYPE_MVD);
d7992 1
a7992 1
do_c_binops_1h (str)
d7995 1
a7995 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVF, REG_TYPE_MVFX);
d7999 1
a7999 1
do_c_binops_1i (str)
d8002 1
a8002 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVD, REG_TYPE_MVFX);
d8006 1
a8006 1
do_c_binops_1j (str)
d8009 1
a8009 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVF, REG_TYPE_MVDX);
d8013 1
a8013 1
do_c_binops_1k (str)
d8016 1
a8016 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVD, REG_TYPE_MVDX);
d8020 1
a8020 1
do_c_binops_1l (str)
d8023 1
a8023 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVFX, REG_TYPE_MVF);
d8027 1
a8027 1
do_c_binops_1m (str)
d8030 1
a8030 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVFX, REG_TYPE_MVD);
d8034 1
a8034 1
do_c_binops_1n (str)
d8037 1
a8037 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVFX, REG_TYPE_MVFX);
d8041 1
a8041 1
do_c_binops_1o (str)
d8044 1
a8044 1
  do_c_binops (str, CIRRUS_MODE1, REG_TYPE_MVDX, REG_TYPE_MVDX);
d8048 1
a8048 1
do_c_binops_2a (str)
d8051 1
a8051 1
  do_c_binops (str, CIRRUS_MODE2, REG_TYPE_MVF, REG_TYPE_RN);
d8055 1
a8055 1
do_c_binops_2b (str)
d8058 1
a8058 1
  do_c_binops (str, CIRRUS_MODE2, REG_TYPE_MVD, REG_TYPE_RN);
d8062 1
a8062 1
do_c_binops_2c (str)
d8065 1
a8065 1
  do_c_binops (str, CIRRUS_MODE2, REG_TYPE_MVDX, REG_TYPE_RN);
d8069 1
a8069 1
do_c_binops_3a (str)
d8072 1
a8072 1
  do_c_binops (str, CIRRUS_MODE3, REG_TYPE_MVAX, REG_TYPE_MVFX);
d8076 1
a8076 1
do_c_binops_3b (str)
d8079 1
a8079 1
  do_c_binops (str, CIRRUS_MODE3, REG_TYPE_MVFX, REG_TYPE_MVAX);
d8083 1
a8083 1
do_c_binops_3c (str)
d8086 1
a8086 1
  do_c_binops (str, CIRRUS_MODE3, REG_TYPE_MVAX, REG_TYPE_MVDX);
d8090 1
a8090 1
do_c_binops_3d (str)
d8093 1
a8093 1
  do_c_binops (str, CIRRUS_MODE3, REG_TYPE_MVDX, REG_TYPE_MVAX);
d8097 1
a8097 1
do_c_triple_4a (str)
d8100 1
a8100 1
  do_c_triple (str, CIRRUS_MODE4, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_RN);
d8104 1
a8104 1
do_c_triple_4b (str)
d8107 1
a8107 1
  do_c_triple (str, CIRRUS_MODE4, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_RN);
d8111 1
a8111 1
do_c_triple_5a (str)
d8114 1
a8114 1
  do_c_triple (str, CIRRUS_MODE5, REG_TYPE_RN, REG_TYPE_MVF, REG_TYPE_MVF);
d8118 1
a8118 1
do_c_triple_5b (str)
d8121 1
a8121 1
  do_c_triple (str, CIRRUS_MODE5, REG_TYPE_RN, REG_TYPE_MVD, REG_TYPE_MVD);
d8125 1
a8125 1
do_c_triple_5c (str)
d8128 1
a8128 1
  do_c_triple (str, CIRRUS_MODE5, REG_TYPE_RN, REG_TYPE_MVFX, REG_TYPE_MVFX);
d8132 1
a8132 1
do_c_triple_5d (str)
d8135 1
a8135 1
  do_c_triple (str, CIRRUS_MODE5, REG_TYPE_RN, REG_TYPE_MVDX, REG_TYPE_MVDX);
d8139 1
a8139 1
do_c_triple_5e (str)
d8142 1
a8142 1
  do_c_triple (str, CIRRUS_MODE5, REG_TYPE_MVF, REG_TYPE_MVF, REG_TYPE_MVF);
d8146 1
a8146 1
do_c_triple_5f (str)
d8149 1
a8149 1
  do_c_triple (str, CIRRUS_MODE5, REG_TYPE_MVD, REG_TYPE_MVD, REG_TYPE_MVD);
d8153 1
a8153 1
do_c_triple_5g (str)
d8156 1
a8156 1
  do_c_triple (str, CIRRUS_MODE5, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_MVFX);
d8160 1
a8160 1
do_c_triple_5h (str)
d8163 1
a8163 1
  do_c_triple (str, CIRRUS_MODE5, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_MVDX);
d8167 1
a8167 1
do_c_quad_6a (str)
d8170 1
a8170 1
  do_c_quad (str, CIRRUS_MODE6, REG_TYPE_MVAX, REG_TYPE_MVFX, REG_TYPE_MVFX,
d8175 1
a8175 1
do_c_quad_6b (str)
d8178 1
a8178 1
  do_c_quad (str, CIRRUS_MODE6, REG_TYPE_MVAX, REG_TYPE_MVAX, REG_TYPE_MVFX,
d8184 1
a8184 1
do_c_dspsc_1 (str)
d8190 1
a8190 1
  if (cirrus_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL
d8192 1
a8192 1
      || cirrus_reg_required_here (&str, 16, REG_TYPE_MVFX) == FAIL)
d8205 1
a8205 1
do_c_dspsc_2 (str)
d8211 1
a8211 1
  if (cirrus_reg_required_here (&str, 0, REG_TYPE_MVFX) == FAIL
d8213 1
a8213 1
      || cirrus_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL)
d8225 1
a8225 1
do_c_shift_1 (str)
d8228 1
a8228 1
  do_c_shift (str, REG_TYPE_MVFX, REG_TYPE_MVFX);
d8232 1
a8232 1
do_c_shift_2 (str)
d8235 1
a8235 1
  do_c_shift (str, REG_TYPE_MVDX, REG_TYPE_MVDX);
d8239 1
a8239 1
do_c_ldst_1 (str)
d8242 1
a8242 1
  do_c_ldst (str, REG_TYPE_MVF);
d8246 1
a8246 1
do_c_ldst_2 (str)
d8249 1
a8249 1
  do_c_ldst (str, REG_TYPE_MVD);
d8253 1
a8253 1
do_c_ldst_3 (str)
d8256 1
a8256 1
  do_c_ldst (str, REG_TYPE_MVFX);
d8260 1
a8260 1
do_c_ldst_4 (str)
d8263 1
a8263 1
  do_c_ldst (str, REG_TYPE_MVDX);
d8269 1
a8269 1
do_c_binops (str, mode, reg0, reg1)
d8282 1
a8282 1
  if (cirrus_reg_required_here (&str, shift0, reg0) == FAIL
d8284 1
a8284 1
      || cirrus_reg_required_here (&str, shift1, reg1) == FAIL)
d8296 1
a8296 1
do_c_triple (str, mode, reg0, reg1, reg2)
d8311 1
a8311 1
  if (cirrus_reg_required_here (&str, shift0, reg0) == FAIL
d8313 1
a8313 1
      || cirrus_reg_required_here (&str, shift1, reg1) == FAIL
d8315 1
a8315 1
      || cirrus_reg_required_here (&str, shift2, reg2) == FAIL)
d8328 1
a8328 1
do_c_quad (str, mode, reg0, reg1, reg2, reg3)
d8345 1
a8345 1
  if (cirrus_reg_required_here (&str, shift0, reg0) == FAIL
d8347 1
a8347 1
      || cirrus_reg_required_here (&str, shift1, reg1) == FAIL
d8349 1
a8349 1
      || cirrus_reg_required_here (&str, shift2, reg2) == FAIL
d8351 1
a8351 1
      || cirrus_reg_required_here (&str, shift3, reg3) == FAIL)
d8360 1
a8360 1
/* Cirrus shift immediate instructions.
d8365 1
a8365 1
do_c_shift (str, reg0, reg1)
d8377 1
a8377 1
  if (cirrus_reg_required_here (&str, 12, reg0) == FAIL
d8379 1
a8379 1
      || cirrus_reg_required_here (&str, 16, reg1) == FAIL
d8432 1
a8432 1
cirrus_parse_offset (str, negative)
d8472 1
a8472 1
/* Cirrus load/store instructions.
d8477 1
a8477 1
do_c_ldst (str, reg0)
d8485 1
a8485 1
  if (cirrus_reg_required_here (&str, 12, reg0) == FAIL
d8496 1
a8496 1
      offset = cirrus_parse_offset (&str, &negative);
d8523 1
a8523 1
	  || (offset = cirrus_parse_offset (&str, &negative), inst.error))
a10524 1
              -marm9e                 Allow Cirrus/DSP instructions
@


1.114
log
@2002-01-19  Keith Walker  <keith.walker@@arm.com>
* tc-arm.c (arm_fpus): Add fpe2 and fpe3.
@
text
@d57 1
d83 1
d751 1
a751 1
/* ARM v5.  */
d759 1
a759 1
/* ARM v5ExP.  */
d765 1
a765 1
/* ARM v5E.  */
d770 3
d1113 1
a1113 1
  /*  ARM Architecture 5.  */
d1127 1
a1127 1
  /*  ARM Architecture 5ExP.  */
d1154 1
a1154 1
  /*  ARM Architecture 5E.  */
d1162 3
d3887 22
d10774 1
d10819 1
@


1.113
log
@* NEWS: Mention new ARM command-line options and VFP support.

* config/tc-arm.c (ARM_CEXT_XSCALE): Replaces ARM_EXT_XSCALE.  All
uses changed.
(ARM_CEXT_MAVERICK): Similarly.
(ARM_ANY): Now means any core instruction.
(CPU_DEFAULT): Default to ARM_ANY.
(uses_apcs_26, atcps, support_interwork, uses_apcs_float)
(pic_code): Declare for all object types.  Make type int.
(legacy_cpu, legacy_fpu, mcpu_cpu_opt, mcpu_fpu_opt, march_cpu_opt)
(march_fpu_opt, mfpu_opt): Declare.
(md_longopts): Tidy up conditional definitions.
(arm_opts, arm_cpus, arm_archs, arm_fpus, arm_extensions)
(arm_long_opts): New tables.
(arm_parse_cpu, arm_parse_arch, arm_parse_fpu): New functions.
(arm_parse_extension): New function.
(md_parse_option): Rewrite using new table-driven system.
(md_show_usage): Use new table-driven system.
(md_begin): Calculate cpu_variant from command line option data.
* doc/as.texinfo (ARM ISA options): Docuement new ARM-specific
command-line options.
* doc/c-arm.texi: Likewise.

Testsuite:
* gas/arm/vfp1.d: Use new command-line options.
* gas/arm/vfp1xD.d: Likewise.
* gas/arm/arm.exp (vfp-bad): Likewise.
* gas/arm/maverick.d: Likewise.
@
text
@d10818 2
@


1.112
log
@Support for VFP instructions
* tc-arm.c (CP_WB_OK, CP_NO_WB): New defines.
(cp_address_required_here): New argument wb_ok.  When false, do not
accept write-back forms of addressing.  Change all callers.
(FPU_VFP_EXT_NONE, FPU_VFP_EXT_V1xD, FPU_VFP_VFP_V1)
(FPU_VFP_EXT_V2): Define.
(FPU_ARCH_VFP, FPU_ARCH_VFP_V1xD, FPU_ARCH_VFP_V1, FPU_ARCH_VFP_V2):
Define in terms of above.
(vfp_dp_reg_pos, vfp_sp_reg_pos, vfp_ldstm_type): New enums.
(vfp_reg): New struct.
(vfp_regs): New array of registers.
(insns): Add VFP instructions.
(sn_table): New array of VFP single-precision register names.
(dn_table): New array of VFP double-precision register names.
(all_reg_maps): Add the new register tables.
(arm_reg_type): Add new values for above.  Increase RET_TYPE_MAX.
(vfp_sp_reg_required_here, vfp_dp_reg_required_here, do_vfp_sp_monadic)
(do_vfp_dp_monadic, do_vfp_sp_dyadic, do_vfp_dp_dyadic)
(do_vfp_reg_from_sp, do_vfp_sp_reg2, do_vfp_sp_from_reg)
(do_vfp_reg_from_dp, do_vfp_reg2_from_dp, do_vfp_dp_from_reg)
(do_vfp_dp_from_reg2, vfp_psr_parse, vfp_psr_required_here)
(do_vfp_reg_from_ctrl, do_vfp_ctrl_from_reg, do_vfp_sp_ldst)
(do_vfp_dp_ldst, vfp_sp_reg_list, vfp_dp_reg_list, vfp_sp_ldstm)
(vfp_dp_ldstm, do_vfp_sp_ldstmia, do_vfp_sp_ldstmdb, do_vfp_ldstmia)
(do_vfp_dp_ldstmdb, do_vfp_xp_ldstmia, do_vfp_xp_ldstmdb)
(do_vfp_sp_compare_z, do_vfp_dp_compare_z, do_vfp_dp_sp_cvt)
(do_vfp_sp_dp_cvt): New functions.
(md_begin): Set soft-float flag for appropriate VFP work.
(md_atof): Handle VFP-format doubles.
(md_parse_option): Handle VFP command-line options.
(md_show_usage): Display VFP command-line options.

* testsuite/gas/arm/vfp1.s gas/arm/vf1.d: New files.
* testsuite/gas/arm/vfp1xD.s gas/arm/vf1xD.d: New files.
* testsuite/gas/arm/vfp-bad.s gas/arm/vfp-bad.l: New files.
* testsuite/gas/arm/arm.exp: Run new VFP tests.
@
text
@d42 3
d57 4
a60 3
/* Processor specific extensions.  */
#define ARM_EXT_XSCALE	 0x00000800	/* Allow MIA etc.          */
#define ARM_EXT_MAVERICK 0x00001000	/* Use Cirrus/DSP coprocessor.  */
d82 1
d84 1
a84 1
#define ARM_ARCH_XSCALE	(ARM_ARCH_V5TE	| ARM_EXT_XSCALE)
d87 5
a91 2
#define ARM_ANY		0x00ffffff
#define ARM_ALL		ARM_ANY
a108 3
/* Some useful combinations.  */
#define FPU_ANY		0xff000000	/* Note this is ~ARM_ANY.  */

d128 1
a128 1
#define CPU_DEFAULT 	ARM_ALL
d141 1
a141 1
static unsigned long cpu_variant = CPU_DEFAULT | FPU_DEFAULT;
a143 1
#if defined OBJ_COFF || defined OBJ_ELF
d145 17
a161 6
static boolean uses_apcs_26      = false;
static boolean atpcs             = false;
static boolean support_interwork = false;
static boolean uses_apcs_float   = false;
static boolean pic_code          = false;
#endif
d1714 8
a1721 8
  {"mia",        0xee200010, 3,  ARM_EXT_XSCALE,   do_mia},
  {"miaph",      0xee280010, 5,  ARM_EXT_XSCALE,   do_mia},
  {"miabb",      0xee2c0010, 5,  ARM_EXT_XSCALE,   do_mia},
  {"miabt",      0xee2d0010, 5,  ARM_EXT_XSCALE,   do_mia},
  {"miatb",      0xee2e0010, 5,  ARM_EXT_XSCALE,   do_mia},
  {"miatt",      0xee2f0010, 5,  ARM_EXT_XSCALE,   do_mia},
  {"mar",        0xec400000, 3,  ARM_EXT_XSCALE,   do_mar},
  {"mra",        0xec500000, 3,  ARM_EXT_XSCALE,   do_mra},
d1724 76
a1799 76
  {"cfldrs",     0xec100400, 6,  ARM_EXT_MAVERICK, do_c_ldst_1},
  {"cfldrd",     0xec500400, 6,  ARM_EXT_MAVERICK, do_c_ldst_2},
  {"cfldr32",    0xec100500, 7,  ARM_EXT_MAVERICK, do_c_ldst_3},
  {"cfldr64",    0xec500500, 7,  ARM_EXT_MAVERICK, do_c_ldst_4},
  {"cfstrs",     0xec000400, 6,  ARM_EXT_MAVERICK, do_c_ldst_1},
  {"cfstrd",     0xec400400, 6,  ARM_EXT_MAVERICK, do_c_ldst_2},
  {"cfstr32",    0xec000500, 7,  ARM_EXT_MAVERICK, do_c_ldst_3},
  {"cfstr64",    0xec400500, 7,  ARM_EXT_MAVERICK, do_c_ldst_4},
  {"cfmvsr",     0xee000450, 6,  ARM_EXT_MAVERICK, do_c_binops_2a},
  {"cfmvrs",     0xee100450, 6,  ARM_EXT_MAVERICK, do_c_binops_1a},
  {"cfmvdlr",    0xee000410, 7,  ARM_EXT_MAVERICK, do_c_binops_2b},
  {"cfmvrdl",    0xee100410, 7,  ARM_EXT_MAVERICK, do_c_binops_1b},
  {"cfmvdhr",    0xee000430, 7,  ARM_EXT_MAVERICK, do_c_binops_2b},
  {"cfmvrdh",    0xee100430, 7,  ARM_EXT_MAVERICK, do_c_binops_1b},
  {"cfmv64lr",   0xee000510, 8,  ARM_EXT_MAVERICK, do_c_binops_2c},
  {"cfmvr64l",   0xee100510, 8,  ARM_EXT_MAVERICK, do_c_binops_1c},
  {"cfmv64hr",   0xee000530, 8,  ARM_EXT_MAVERICK, do_c_binops_2c},
  {"cfmvr64h",   0xee100530, 8,  ARM_EXT_MAVERICK, do_c_binops_1c},
  {"cfmval32",   0xee100610, 8,  ARM_EXT_MAVERICK, do_c_binops_3a},
  {"cfmv32al",   0xee000610, 8,  ARM_EXT_MAVERICK, do_c_binops_3b},
  {"cfmvam32",   0xee100630, 8,  ARM_EXT_MAVERICK, do_c_binops_3a},
  {"cfmv32am",   0xee000630, 8,  ARM_EXT_MAVERICK, do_c_binops_3b},
  {"cfmvah32",   0xee100650, 8,  ARM_EXT_MAVERICK, do_c_binops_3a},
  {"cfmv32ah",   0xee000650, 8,  ARM_EXT_MAVERICK, do_c_binops_3b},
  {"cfmva32",    0xee100670, 7,  ARM_EXT_MAVERICK, do_c_binops_3a},
  {"cfmv32a",    0xee000670, 7,  ARM_EXT_MAVERICK, do_c_binops_3b},
  {"cfmva64",    0xee100690, 7,  ARM_EXT_MAVERICK, do_c_binops_3c},
  {"cfmv64a",    0xee000690, 7,  ARM_EXT_MAVERICK, do_c_binops_3d},
  {"cfmvsc32",   0xee1006b0, 8,  ARM_EXT_MAVERICK, do_c_dspsc_1},
  {"cfmv32sc",   0xee0006b0, 8,  ARM_EXT_MAVERICK, do_c_dspsc_2},
  {"cfcpys",     0xee000400, 6,  ARM_EXT_MAVERICK, do_c_binops_1d},
  {"cfcpyd",     0xee000420, 6,  ARM_EXT_MAVERICK, do_c_binops_1e},
  {"cfcvtsd",    0xee000460, 7,  ARM_EXT_MAVERICK, do_c_binops_1f},
  {"cfcvtds",    0xee000440, 7,  ARM_EXT_MAVERICK, do_c_binops_1g},
  {"cfcvt32s",   0xee000480, 8,  ARM_EXT_MAVERICK, do_c_binops_1h},
  {"cfcvt32d",   0xee0004a0, 8,  ARM_EXT_MAVERICK, do_c_binops_1i},
  {"cfcvt64s",   0xee0004c0, 8,  ARM_EXT_MAVERICK, do_c_binops_1j},
  {"cfcvt64d",   0xee0004e0, 8,  ARM_EXT_MAVERICK, do_c_binops_1k},
  {"cfcvts32",   0xee100580, 8,  ARM_EXT_MAVERICK, do_c_binops_1l},
  {"cfcvtd32",   0xee1005a0, 8,  ARM_EXT_MAVERICK, do_c_binops_1m},
  {"cftruncs32", 0xee1005c0, 10, ARM_EXT_MAVERICK, do_c_binops_1l},
  {"cftruncd32", 0xee1005e0, 10, ARM_EXT_MAVERICK, do_c_binops_1m},
  {"cfrshl32",   0xee000550, 8,  ARM_EXT_MAVERICK, do_c_triple_4a},
  {"cfrshl64",   0xee000570, 8,  ARM_EXT_MAVERICK, do_c_triple_4b},
  {"cfsh32",     0xee000500, 6,  ARM_EXT_MAVERICK, do_c_shift_1},
  {"cfsh64",     0xee200500, 6,  ARM_EXT_MAVERICK, do_c_shift_2},
  {"cfcmps",     0xee100490, 6,  ARM_EXT_MAVERICK, do_c_triple_5a},
  {"cfcmpd",     0xee1004b0, 6,  ARM_EXT_MAVERICK, do_c_triple_5b},
  {"cfcmp32",    0xee100590, 7,  ARM_EXT_MAVERICK, do_c_triple_5c},
  {"cfcmp64",    0xee1005b0, 7,  ARM_EXT_MAVERICK, do_c_triple_5d},
  {"cfabss",     0xee300400, 6,  ARM_EXT_MAVERICK, do_c_binops_1d},
  {"cfabsd",     0xee300420, 6,  ARM_EXT_MAVERICK, do_c_binops_1e},
  {"cfnegs",     0xee300440, 6,  ARM_EXT_MAVERICK, do_c_binops_1d},
  {"cfnegd",     0xee300460, 6,  ARM_EXT_MAVERICK, do_c_binops_1e},
  {"cfadds",     0xee300480, 6,  ARM_EXT_MAVERICK, do_c_triple_5e},
  {"cfaddd",     0xee3004a0, 6,  ARM_EXT_MAVERICK, do_c_triple_5f},
  {"cfsubs",     0xee3004c0, 6,  ARM_EXT_MAVERICK, do_c_triple_5e},
  {"cfsubd",     0xee3004e0, 6,  ARM_EXT_MAVERICK, do_c_triple_5f},
  {"cfmuls",     0xee100400, 6,  ARM_EXT_MAVERICK, do_c_triple_5e},
  {"cfmuld",     0xee100420, 6,  ARM_EXT_MAVERICK, do_c_triple_5f},
  {"cfabs32",    0xee300500, 7,  ARM_EXT_MAVERICK, do_c_binops_1n},
  {"cfabs64",    0xee300520, 7,  ARM_EXT_MAVERICK, do_c_binops_1o},
  {"cfneg32",    0xee300540, 7,  ARM_EXT_MAVERICK, do_c_binops_1n},
  {"cfneg64",    0xee300560, 7,  ARM_EXT_MAVERICK, do_c_binops_1o},
  {"cfadd32",    0xee300580, 7,  ARM_EXT_MAVERICK, do_c_triple_5g},
  {"cfadd64",    0xee3005a0, 7,  ARM_EXT_MAVERICK, do_c_triple_5h},
  {"cfsub32",    0xee3005c0, 7,  ARM_EXT_MAVERICK, do_c_triple_5g},
  {"cfsub64",    0xee3005e0, 7,  ARM_EXT_MAVERICK, do_c_triple_5h},
  {"cfmul32",    0xee100500, 7,  ARM_EXT_MAVERICK, do_c_triple_5g},
  {"cfmul64",    0xee100520, 7,  ARM_EXT_MAVERICK, do_c_triple_5h},
  {"cfmac32",    0xee100540, 7,  ARM_EXT_MAVERICK, do_c_triple_5g},
  {"cfmsc32",    0xee100560, 7,  ARM_EXT_MAVERICK, do_c_triple_5g},
  {"cfmadd32",   0xee000600, 8,  ARM_EXT_MAVERICK, do_c_quad_6a},
  {"cfmsub32",   0xee100600, 8,  ARM_EXT_MAVERICK, do_c_quad_6a},
  {"cfmadda32",  0xee200600, 9,  ARM_EXT_MAVERICK, do_c_quad_6b},
  {"cfmsuba32",  0xee300600, 9,  ARM_EXT_MAVERICK, do_c_quad_6b},
d2101 6
d2613 1
a2613 1
	  if ((cpu_variant & ARM_ANY) == ARM_EXT_V4T)
d9153 44
d9207 1
a9207 1
	|| (cpu_variant & FPU_ANY) == FPU_ARCH_VFP)
d9209 3
d9256 1
a9256 1
  if (cpu_variant & ARM_EXT_XSCALE)
d10458 29
a10486 1
      See if it's a processor-specific option.  These are:
a10505 11
      Run-time endian selection:
              -EB                     big endian cpu
              -EL                     little endian cpu
      ARM Procedure Calling Standard:
  	      -mapcs-32		      32 bit APCS
  	      -mapcs-26		      26 bit APCS
  	      -mapcs-float	      Pass floats in float regs
  	      -mapcs-reentrant        Position independent code
              -mthumb-interwork       Code supports Arm/Thumb interworking
              -matpcs                 ARM/Thumb Procedure Call Standard
              -moabi                  Old ELF ABI  */
d10507 12
a10518 1
const char * md_shortopts = "m:k";
a10519 2
struct option md_longopts[] =
{
a10521 1
  {"EB", no_argument, NULL, OPTION_EB},
a10522 1
  {"EL", no_argument, NULL, OPTION_EL},
a10523 2
  /* If the build isn't bi-endian, just support the flag that we are anyway.
     This makes things more portable.  */
a10525 1
  {"EB", no_argument, NULL, OPTION_EB},
a10527 1
  {"EL", no_argument, NULL, OPTION_EL},
d10530 8
a10537 3
#ifdef OBJ_ELF
#define OPTION_OABI (OPTION_MD_BASE +2)
  {"oabi", no_argument, NULL, OPTION_OABI},
d10544 291
a10834 4
int
md_parse_option (c, arg)
     int    c;
     char * arg;
d10836 5
a10840 1
  char * str = arg;
d10842 6
a10847 1
  switch (c)
d10849 23
a10871 5
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif
d10873 6
a10878 5
#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif
d10880 1
a10880 2
    case 'm':
      switch (*str)
d10882 3
a10884 8
	case 'f':
	  if (streq (str, "fpa10") || streq (str, "fpa11"))
	    cpu_variant = (cpu_variant & ~FPU_ANY) | FPU_ARCH_FPA;
	  else if (streq (str, "fpe-old"))
	    cpu_variant = (cpu_variant & ~FPU_ANY) | FPU_ARCH_FPE;
	  else
	    goto bad;
	  break;
d10886 2
a10887 4
	case 'n':
	  if (streq (str, "no-fpu"))
	    cpu_variant &= ~FPU_ANY;
	  break;
d10889 2
a10890 6
#ifdef OBJ_ELF
	case 'o':
	  if (streq (str, "oabi"))
	    target_oabi = true;
	  break;
#endif
d10892 7
a10898 19
	case 't':
	  /* Limit assembler to generating only Thumb instructions:  */
	  if (streq (str, "thumb"))
	    {
	      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_EXT_V4T;
	      cpu_variant = (cpu_variant & ~FPU_ANY) | FPU_NONE;
	      thumb_mode = 1;
	    }
	  else if (streq (str, "thumb-interwork"))
	    {
	      if ((cpu_variant & ARM_EXT_V4T) == 0)
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V4T;
#if defined OBJ_COFF || defined OBJ_ELF
	      support_interwork = true;
#endif
	    }
	  else
	    goto bad;
	  break;
d10900 4
a10903 8
	case 'v':
	  if (streq (str, "vfpxd"))
	    cpu_variant = (cpu_variant & ~FPU_ANY) | FPU_ARCH_VFP_V1xD;
	  else if (streq (str, "vfp"))
	    cpu_variant = (cpu_variant & ~FPU_ANY) | FPU_ARCH_VFP_V2;
	  else
	    goto bad;
	  break;
d10905 5
a10909 11
	default:
	  if (streq (str, "all"))
	    {
	      cpu_variant = ARM_ALL | FPU_DEFAULT;
	      return 1;
	    }
#if defined OBJ_COFF || defined OBJ_ELF
	  if (! strncmp (str, "apcs-", 5))
	    {
	      /* GCC passes on all command line options starting "-mapcs-..."
		 to us, so we must parse them here.  */
d10911 5
a10915 1
	      str += 5;
d10917 2
a10918 22
	      if (streq (str, "32"))
		{
		  uses_apcs_26 = false;
		  return 1;
		}
	      else if (streq (str, "26"))
		{
		  uses_apcs_26 = true;
		  return 1;
		}
	      else if (streq (str, "frame"))
		{
		  /* Stack frames are being generated - does not affect
		     linkage of code.  */
		  return 1;
		}
	      else if (streq (str, "stack-check"))
		{
		  /* Stack checking is being performed - does not affect
		     linkage, but does require that the functions
		     __rt_stkovf_split_small and __rt_stkovf_split_big be
		     present in the final link.  */
d10920 2
a10921 8
		  return 1;
		}
	      else if (streq (str, "float"))
		{
		  /* Floating point arguments are being passed in the floating
		     point registers.  This does affect linking, since this
		     version of the APCS is incompatible with the version that
		     passes floating points in the integer registers.  */
d10923 3
a10925 11
		  uses_apcs_float = true;
		  return 1;
		}
	      else if (streq (str, "reentrant"))
		{
		  /* Reentrant code has been generated.  This does affect
		     linking, since there is no point in linking reentrant/
		     position independent code with absolute position code.  */
		  pic_code = true;
		  return 1;
		}
d10927 7
a10933 3
	      as_bad (_("unrecognised APCS switch -m%s"), arg);
	      return 0;
	    }
d10935 4
a10938 18
	  if (! strcmp (str, "atpcs"))
	    {
	      atpcs = true;
	      return 1;
	    }
#endif
	  /* Strip off optional "arm".  */
	  if (! strncmp (str, "arm", 3))
	    str += 3;

	  switch (*str)
	    {
	    case '1':
	      if (streq (str, "1"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_1;
	      else
		goto bad;
	      break;
d10940 5
a10944 8
	    case '2':
	      if (streq (str, "2"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_2;
	      else if (streq (str, "250"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_250;
	      else
		goto bad;
	      break;
a10945 6
	    case '3':
	      if (streq (str, "3"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_3;
	      else
		goto bad;
	      break;
d10947 5
a10951 14
	    case '6':
	      switch (strtol (str, NULL, 10))
		{
		case 6:
		case 60:
		case 600:
		case 610:
		case 620:
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_6;
		  break;
		default:
		  goto bad;
		}
	      break;
d10953 2
a10954 33
	    case '7':
	      /* Eat the processor name.  */
	      switch (strtol (str, & str, 10))
		{
		case 7:
		case 70:
		case 700:
		case 710:
		case 720:
		case 7100:
		case 7500:
		  break;
		default:
		  goto bad;
		}
	      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
	      for (; *str; str++)
		{
		  switch (*str)
		    {
		    case 't':
		      cpu_variant |= ARM_ARCH_V4T;
		      break;

		    case 'm':
		      cpu_variant |= ARM_EXT_V3M;
		      break;

		    case 'f': /* fe => fp enabled cpu.  */
		      if (str[1] == 'e')
			++ str;
		      else
			goto bad;
d10956 2
a10957 5
		    case 'c': /* Left over from 710c processor name.  */
		    case 'd': /* Debug.  */
		    case 'i': /* Embedded ICE.  */
		      /* Included for completeness in ARM processor naming.  */
		      break;
d10959 3
a10961 5
		    default:
		      goto bad;
		    }
		}
	      break;
d10963 5
a10967 6
	    case '8':
	      if (streq (str, "8") || streq (str, "810"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_8;
	      else
		goto bad;
	      break;
d10969 6
a10974 16
	    case '9':
	      if (streq (str, "9"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9;
	      else if (streq (str, "920"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9;
	      else if (streq (str, "920t"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9;
	      else if (streq (str, "9tdmi"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9;
	      else if (streq (str, "9e"))
		/* XXX This is bogus: arm9e != maverick.  */
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_EXT_MAVERICK;
	      else
		goto bad;
	      break;
d10976 3
a10978 8
	    case 's':
	      if (streq (str, "strongarm")
		  || streq (str, "strongarm110")
		  || streq (str, "strongarm1100"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_STRONG;
	      else
		goto bad;
	      break;
d10980 10
a10989 26
            case 'x':
 	      if (streq (str, "xscale"))
 		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_XSCALE;
 	      else
 		goto bad;
      	      break;

	    case 'v':
	      /* Select variant based on architecture rather than
                 processor.  */
	      switch (*++str)
		{
		case '2':
		  switch (*++str)
		    {
		    case 'a':
		      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V2S;
		      break;
		    case 0:
		      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V2;
		      break;
		    default:
		      as_bad (_("invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;
d10991 7
a10997 2
		case '3':
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V3;
d10999 7
a11005 9
		  switch (*++str)
		    {
		    case 'm': cpu_variant |= ARM_EXT_V3M; break;
		    case 0:   break;
		    default:
		      as_bad (_("invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;
d11007 5
a11011 2
		case '4':
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V4;
d11013 4
a11016 9
		  switch (*++str)
		    {
		    case 't': cpu_variant |= ARM_EXT_V4T; break;
		    case 0:   break;
		    default:
		      as_bad (_("invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;
d11018 13
a11030 12
		case '5':
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V5;
		  switch (*++str)
		    {
		    case 't': cpu_variant |= ARM_EXT_V4T | ARM_EXT_V5T; break;
		    case 'e': cpu_variant |= ARM_EXT_V5E; break;
		    case 0:   break;
		    default:
		      as_bad (_("invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;
d11032 2
a11033 5
		default:
		  as_bad (_("invalid architecture variant -m%s"), arg);
		  break;
		}
	      break;
d11035 1
a11035 4
	    default:
	    bad:
	      as_bad (_("invalid processor variant -m%s"), arg);
	      return 0;
a11037 1
      break;
d11039 13
a11051 4
#if defined OBJ_ELF || defined OBJ_COFF
    case 'k':
      pic_code = 1;
      break;
d11054 6
a11059 1
    default:
d11070 14
d11085 1
a11085 19
 ARM Specific Assembler Options:\n\
  -m[arm][<processor name>] select processor variant\n\
  -m[arm]v[2|2a|3|3m|4|4t|5[t][e]] select architecture variant\n\
  -marm9e                   allow Cirrus/DSP instructions\n\
  -mthumb                   only allow Thumb instructions\n\
  -mthumb-interwork         mark the assembled code as supporting interworking\n\
  -mall                     allow any instruction\n\
  -mfpa10, -mfpa11          select floating point architecture\n\
  -mfpe-old                 don't allow floating-point multiple instructions\n\
  -mvfpxd                   allow vfp single-precision instructions\n\
  -mvfp                     allow all vfp instructions\n\
  -mno-fpu                  don't allow any floating-point instructions.\n\
  -k                        generate PIC code.\n"));
#if defined OBJ_COFF || defined OBJ_ELF
  fprintf (fp, _("\
  -mapcs-32, -mapcs-26      specify which ARM Procedure Calling Standard to use\n\
  -matpcs                   use ARM/Thumb Procedure Calling Standard\n\
  -mapcs-float              floating point args are passed in FP regs\n\
  -mapcs-reentrant          the code is position independent/reentrant\n"));
d11087 2
a11088 5
#ifdef OBJ_ELF
  fprintf (fp, _("\
  -moabi                    support the old ELF ABI\n"));
#endif
#ifdef ARM_BI_ENDIAN
d11090 1
a11090 2
  -EB                       assemble code for a big endian cpu\n\
  -EL                       assemble code for a little endian cpu\n"));
@


1.111
log
@* tc-arm.c (md_parse_option): Tidy up setting of cpu_variant for
various command line options.
@
text
@d85 7
a91 3
#define FPU_FPA_EXT_V1	0x80000000	/* Base FPA instruction set.  */
#define FPU_FPA_EXT_V2	0x40000000	/* LFM/SFM.		      */
#define FPU_NONE	0
d96 5
d128 1
d277 4
d485 32
d581 24
d668 2
d686 8
a693 6
  REG_TYPE_MVF = 4,
  REG_TYPE_MVD = 5,
  REG_TYPE_MVFX = 6,
  REG_TYPE_MVDX = 7,
  REG_TYPE_MVAX = 8,
  REG_TYPE_DSPSC = 9,
d695 1
a695 1
  REG_TYPE_MAX = 10
d768 27
d880 8
d889 1
a889 1
static int cp_address_required_here	PARAMS ((char **));
d1585 113
d2948 1
a2948 1
cp_address_required_here (str)
d2950 1
d2972 1
a2972 1
	  if (skip_past_comma (& p) == SUCCESS)
d3014 1
a3014 1
	  if (*p == '!')
d3722 1
a3722 1
	   || cp_address_required_here (& str) == FAIL)
d5950 1
a5950 1
      || cp_address_required_here (&str) == FAIL)
d6057 1
a6057 1
      || cp_address_required_here (&str) == FAIL)
d6196 1
a6196 1
	   || cp_address_required_here (&str) == FAIL)
d6335 33
a6367 1
/* Thumb specific routines.  */
d6369 4
a6372 5
/* Parse and validate that a register is of the right form, this saves
   repeated checking of this information in many similar cases.
   Unlike the 32-bit case we do not insert the register into the opcode
   here, since the position is often unknown until the full instruction
   has been parsed.  */
d6375 3
a6377 3
thumb_reg (strp, hi_lo)
     char ** strp;
     int     hi_lo;
d6379 2
a6380 4
  int reg;

  if ((reg = reg_required_here (strp, -1)) == FAIL)
    return FAIL;
d6382 1
a6382 1
  switch (hi_lo)
d6384 1
a6384 2
    case THUMB_REG_LO:
      if (reg > 7)
d6386 14
a6399 2
	  inst.error = _("lo register required");
	  return FAIL;
d6401 17
a6417 1
      break;
d6419 2
a6420 7
    case THUMB_REG_HI:
      if (reg < 8)
	{
	  inst.error = _("hi register required");
	  return FAIL;
	}
      break;
d6422 6
a6427 2
    default:
      break;
d6430 2
a6431 1
  return reg;
a6433 3
/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode
   was SUB.  */

d6435 2
a6436 3
thumb_add_sub (str, subtract)
     char * str;
     int    subtract;
d6438 1
a6438 1
  int Rd, Rs, Rn = FAIL;
d6440 2
a6441 1
  skip_whitespace (str);
d6443 2
a6444 2
  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
d6451 17
a6467 1
  if (is_immediate_prefix (*str))
d6469 3
a6471 4
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
a6472 4
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d6474 3
a6476 16
      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
    }
d6478 5
a6482 12
  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
  if (Rn != FAIL)
    {
      /* All register format.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
	{
	  if (Rs != Rd)
	    {
	      inst.error = _("dest and source1 must be the same register");
	      return;
	    }
d6484 2
a6485 6
	  /* Can't do this for SUB.  */
	  if (subtract)
	    {
	      inst.error = _("subtract valid only on lo regs");
	      return;
	    }
d6487 8
a6494 10
	  inst.instruction = (T_OPCODE_ADD_HI
			      | (Rd > 7 ? THUMB_H1 : 0)
			      | (Rn > 7 ? THUMB_H2 : 0));
	  inst.instruction |= (Rd & 7) | ((Rn & 7) << 3);
	}
      else
	{
	  inst.instruction = subtract ? T_OPCODE_SUB_R3 : T_OPCODE_ADD_R3;
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
a6495 3
  else
    {
      /* Immediate expression, now things start to get nasty.  */
d6497 3
a6499 8
      /* First deal with HI regs, only very restricted cases allowed:
	 Adjusting SP, and using PC or SP to get an address.  */
      if ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
	  || (Rs > 7 && Rs != REG_SP && Rs != REG_PC))
	{
	  inst.error = _("invalid Hi register with immediate");
	  return;
	}
d6501 5
a6505 11
      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, all we can do is store all the fragments
	     we know about in the instruction and let the reloc hacking
	     work it all out.  */
	  inst.instruction = (subtract ? 0x8000 : 0) | (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	}
      else
	{
	  int offset = inst.reloc.exp.X_add_number;
d6507 2
a6508 2
	  if (subtract)
	    offset = -offset;
d6510 881
a7390 4
	  if (offset < 0)
	    {
	      offset = -offset;
	      subtract = 1;
d9141 3
a9143 1
    if ((cpu_variant & FPU_ANY) == FPU_NONE) flags |= F_SOFT_FLOAT;
d9330 15
a9344 8
      /* For a 4 byte float the order of elements in `words' is 1 0.  For an
	 8 byte float the order is 1 0 3 2.  */
      for (i = 0; i < prec; i += 2)
	{
	  md_number_to_chars (litP, (valueT) words[i + 1], 2);
	  md_number_to_chars (litP + 2, (valueT) words[i], 2);
	  litP += 4;
	}
d10407 2
d10516 9
d10823 2
@


1.110
log
@* tc-arm.c (md_longopts): On targets that aren't bi-endian, support
the -EL/-EB option that matches the target's endianness.
(md_parse_option): Likewise.
@
text
@d9541 1
a9541 2
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_8 | ARM_ARCH_V4;
d9548 1
a9548 2
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4T;
d9550 1
a9550 2
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4;
d9552 1
a9552 2
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4T;
d9554 1
a9554 2
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4T;
d9556 1
d9558 1
a9558 1
		  | ARM_9 | ARM_ARCH_V4T | ARM_EXT_MAVERICK;
d9567 1
a9567 2
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_8 | ARM_ARCH_V4;
d9574 1
a9574 2
 		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_XSCALE;
d9588 1
a9588 1
		      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_3;
d9591 1
a9591 1
		      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_2;
d9600 1
a9600 1
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
d9613 1
a9613 1
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7 | ARM_ARCH_V4;
d9626 1
a9626 1
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCH_V5;
d9629 1
a9629 1
		    case 't': cpu_variant |= ARM_EXT_V4T; break;
@


1.109
log
@* tc-arm.c (md_longopts): Fix misplaced #endif -- the -oabi option
is not dependent on ARM_BI_ENDIAN.
@
text
@d9296 10
d9325 1
a9325 1
#ifdef ARM_BI_ENDIAN
d9329 3
@


1.108
log
@* tc-arm.c (all error messages): Normalize capitalization of messages.

* tc-arm.h (md_operand): Delete define.
* tc-arm.c (in_my_get_expression): New static variable.
(my_get_expression): Set and clear it.
(md_operand): New function.  If called from my_get_expression
put the error in inst.error.
(output_inst): Now takes argument of instruction being assembled.
Print it out with any error message.
(do_ldst, do_ldstv4, thumb_load_store): Fault attempt to use a store
with '=' syntax.
(end_of_line): Don't update inst.error if it is already set.
@
text
@d4246 1
a4246 1
md_operand(expr)
d9296 1
a9299 1
#endif
@


1.107
log
@* tc-arm.c ((do_ldst): Fix handling an immediate expression pseudo
op that can be translated into a mvn instruction.

* gas/arm/ldconst.s gas/arm/ldconst.d: New files.  Test ldr with
immediate pseudo-operations.
* gas/arm/arm.exp: Run it.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d595 2
a596 2
  {cp_table,        15, NULL, N_("Bad or missing co-processor number")},
  {cn_table,        15, NULL, N_("Co-processor register expected")},
d803 1
a803 1
static void output_inst		PARAMS ((void));
d1791 1
a1791 1
#define BAD_ARGS 	_("Bad arguments to instruction")
d1793 1
a1793 1
#define BAD_COND 	_("Instruction is not conditional")
d1933 1
a1933 1
	  inst.error = _("Literal Pool Overflow");
d2075 1
a2075 1
  as_bad (_("Invalid syntax for .req directive."));
d2150 1
a2150 1
    as_bad (_("Alignment too large: %d. assumed."), temp = max_alignment);
d2153 1
a2153 1
      as_bad (_("Alignment negative. 0 assumed."));
d2237 1
a2237 1
      as_bad (_("Expected comma after name \"%s\""), name);
d2424 1
a2424 1
     char * str;
d2428 2
a2429 2
  if (* str != '\0')
    inst.error = _("Garbage following instruction");
d2479 1
a2479 1
  sprintf (buff, _("Register expected, not '%.100s'"), start);
d2585 1
a2585 1
		  inst.error = _("Illegal co-processor number");
d2592 1
a2592 1
	  inst.error = _("Bad or missing co-processor number");
d2647 1
a2647 1
  inst.error = _("Co-processor register expected");
d2670 1
a2670 1
  inst.error = _("Floating point register expected");
d2866 1
a2866 1
      inst.error = _("{C|S}PSR expected");
d2947 1
a2947 1
	  inst.error = _("Invalid constant");
d3437 1
a3437 1
      (_("Warning: Instruction unpredictable when using r15"));
d4067 1
a4067 1
      inst.error = _("Destination register must be even");
d4185 2
d4197 1
d4199 9
d4232 1
a4232 1
      inst.error = _("Invalid constant");
d4243 14
d4276 1
a4276 1
      inst.error = _("Shift expression expected");
d4287 1
a4287 1
      inst.error = _("Shift expression expected");
d4342 1
a4342 1
	      as_warn (_("Shift of 0 ignored."));
d4348 1
a4348 1
	      inst.error = _("Invalid immediate shift");
d4503 1
a4503 1
		      inst.error = _("Constant expression expected");
d4512 1
a4512 1
		      inst.error = _("Invalid constant");
d4532 1
a4532 1
		      inst.error = _("Invalid constant");
d4545 1
a4545 1
      inst.error = _("Register or shift expression expected");
d4598 1
a4598 1
	  inst.error = _("Invalid floating point immediate expression");
d4602 1
a4602 1
	_("Floating point register or immediate expression expected");
d4814 1
a4814 1
      inst.error = _("Address expected");
d4903 6
d4920 1
a4920 1
	  inst.error = _("Constant expression expected");
d5004 1
a5004 1
      inst.error = _("Address expected");
d5146 1
a5146 1
      inst.error = _("Address expected");
d5237 6
d5255 1
a5255 1
	  inst.error = _("Constant expression expected");
d5356 1
a5356 1
		      inst.error = _("Bad range in register list");
d5364 1
a5364 1
			  (_("Warning: Duplicated register (r%d) in register list"),
d5373 1
a5373 1
		as_tsktsk (_("Warning: Duplicated register (r%d) in register list"),
d5376 1
a5376 1
		as_tsktsk (_("Warning: Register range not in ascending order"));
d5388 1
a5388 1
	      inst.error = _("Missing `}'");
d5415 1
a5415 1
		    (_("Warning: Duplicated register (r%d) in register list"),
d5636 1
a5636 1
    as_tsktsk (_("Use of r15 in bx in ARM mode is not really useful"));
d5870 1
a5870 1
      inst.error = _("Constant value required for number of registers");
d5939 1
a5939 1
		_("R15 not allowed as base register with write-back");
d6414 1
a6414 1
	      inst.error = _("Invalid immediate for shift");
d6573 6
d6644 1
a6644 1
	  inst.error = _("R15 based store not allowed");
d6649 1
a6649 1
	  inst.error = _("Invalid base register for register offset");
d6702 1
a6702 1
	      inst.error = _("Invalid offset");
d7569 1
a7569 1
    as_warn (_("Inserted missing '!': load/store multiple always writes back base register"));
d7585 1
a7585 1
      inst.error = _("Expression too complex");
d7637 1
a7637 1
	inst.error = _("Syntax: ldrs[b] Rd, [Rb, Ro]");
d7685 1
a7685 1
      inst.error = _("Expression too complex");
d7813 1
a7813 1
    as_fatal (_("Virtual memory exhausted"));
d7991 1
a7991 1
    as_fatal (_("Virtual memory exhausted"));
d8186 1
a8186 1
      return _("Bad call to MD_ATOF()");
d8445 1
a8445 1
			      _("Unable to compute ADRL instructions for PC offset of 0x%lx"),
d8555 1
a8555 1
			  _("Invalid swi expression"));
d8564 1
a8564 1
			  _("Invalid swi expression"));
d8574 1
a8574 1
		      _("Invalid expression in load/store multiple"));
d8627 1
a8627 1
			  _("gas can't handle same-section branch dest >= 0x04000000"));
d8669 1
a8669 1
			_("Branch out of range"));
d8685 1
a8685 1
			_("Branch out of range"));
d8708 1
a8708 1
			_("Branch with link out of range"));
d8784 1
a8784 1
		      _("Illegal value for co-processor offset"));
d8808 1
a8808 1
			  _("Invalid offset, target not word aligned (0x%08X)"),
d8814 1
a8814 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d8823 1
a8823 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d8830 1
a8830 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d8837 1
a8837 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d8844 1
a8844 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d8883 1
a8883 1
			    _("Invalid immediate for stack address calculation"));
d8892 1
a8892 1
			    _("Invalid immediate for address calculation (value = 0x%08lX)"),
d8902 1
a8902 1
			    _("Invalid 8bit immediate"));
d8910 1
a8910 1
			    _("Invalid 3bit immediate"));
d8926 1
a8926 1
			  _("Invalid immediate: %ld is too large"),
d8941 1
a8941 1
		      _("Illegal Thumb shift value: %ld"), (long) value);
d8955 1
a8955 1
		    _("Bad relocation fixup type (%d)"), fixP->fx_r_type);
d9026 1
a9026 1
		    _("Literal referenced across section boundary (Implicit dump?)"));
d9039 1
a9039 1
		    _("Internal_relocation (type %d) not fixed up (IMMEDIATE)"),
d9050 1
a9050 1
		    _("Internal_relocation (type %d) not fixed up (OFFSET_IMM)"),
d9074 1
a9074 1
		      _("Cannot represent %s relocation in this object file format"),
d9095 1
a9095 1
		    _("Can not represent %s relocation in this object file format"),
d9118 2
a9119 1
output_inst PARAMS ((void))
d9125 1
a9125 1
      as_bad (inst.error);
d9192 1
a9192 1
      as_bad (_("No operator -- statement `%s'\n"), str);
d9210 1
a9210 1
	      as_bad (_("selected processor does not support this opcode"));
d9217 1
a9217 1
	  output_inst ();
d9235 1
a9235 1
	      as_bad (_("selected processor does not support this opcode"));
d9242 1
a9242 1
	  output_inst ();
d9426 1
a9426 1
	      as_bad (_("Unrecognised APCS switch -m%s"), arg);
d9587 1
a9587 1
		      as_bad (_("Invalid architecture variant -m%s"), arg);
d9600 1
a9600 1
		      as_bad (_("Invalid architecture variant -m%s"), arg);
d9613 1
a9613 1
		      as_bad (_("Invalid architecture variant -m%s"), arg);
d9626 1
a9626 1
		      as_bad (_("Invalid architecture variant -m%s"), arg);
d9632 1
a9632 1
		  as_bad (_("Invalid architecture variant -m%s"), arg);
d9639 1
a9639 1
	      as_bad (_("Invalid processor variant -m%s"), arg);
@


1.106
log
@* tc-arm.c (struct reg_entry): Move before prototypes.
(int_register, cp_register, fp_register): Delete.
(reg_table): Delete.  Replaced with ...
(rn_table, cp_table, cn_table, fn_table, mav_mvf_table)
(mav_mvd_table, mav_mvfx_table, mav_mvdx_table, mav_mvax_table)
(mav_dspsc_table): ... one table per register set.
(arm_reg_hsh): Delete.
(struct reg_map): New structure.
(all_reg_maps): New array.
(enum arm_reg_type): New enums.
(build_reg_hsh): New function.
(insert_reg_alias): Use hash table passed by caller.  Adjust all
callers.
(create_register_alias): New function, split out from ...
(md_assemble): ... here.
(md_begin): Build new register hash tables.
(arm_reg_parse): New argument for the hash table to search.  Adjust all
callers.
(arm_reg_parse_any): New function.
(co_proc_number): Look up the processor number in the processor hash
table.
(cirrus_regtype): Delete.
(cirrus_register, cirrus_mvf_register, cirrus_mvd_register)
(cirrus_mvfx_register, cirrus_mvdx_register, cirrus_mvax_register)
(ARM_EXT_MAVERICKsc_register): Delete.
(do_c_binops_1, do_c_binops_2, do_c_binops_3): Delete.
(do_c_binops_1[a-o], do_c_binops_2[a-c], do_c_binops_3[a-d]): New
functions.
(do_c_triple_4, do_c_triple_5): Delete.
(do_c_triple_4[ab], do_c_triple_5[a-h]): New functions.
(do_c_quad_6): Delete.
(do_c_quad_6[ab]): New functions.
(do_c_binops, do_c_triple, do_c_quad, do_c_shift, do_c_ldst): Rework
arguments to use new register parsing methods.
(cirrus_reg_required_here): Likewise.
(insns): Reclassify cirrus maverick worker functions.
(cirrus_valid_reg): Delete.
@
text
@d478 1
d4892 1
a4892 2
      if (inst.reloc.exp.X_op == O_constant
	  && (value = validate_immediate (inst.reloc.exp.X_add_number)) != FAIL)
d4894 16
a4909 11
	  /* This can be done with a mov instruction.  */
	  inst.instruction &= LITERAL_MASK;
	  inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	  inst.instruction |= (value & 0xfff);
	  end_of_line (str);
	  return;
	}
      else
	{
	  /* Insert into literal pool.  */
	  if (add_to_lit_pool () == FAIL)
d4911 6
a4916 2
	      if (!inst.error)
		inst.error = _("literal pool insertion failed");
d4919 1
d4921 6
a4926 5
	  /* Change the instruction exp to point to the pool.  */
	  inst.reloc.type = BFD_RELOC_ARM_LITERAL;
	  inst.reloc.pc_rel = 1;
	  inst.instruction |= (REG_PC << 16);
	  pre_inc = 1;
d4928 6
d5861 1
a5861 1
  if (inst.instruction & (CP_T_Pre | CP_T_UD)) /* ed/fd format.  */
a8014 1

@


1.105
log
@* tc-arm.c (do_arit, do_cmp, do_mov, do_ldst, do_ldstt, do_ldmstm)
(do_branch, do_swi, do_adr, do_adrl, do_empty, do_mul, do_mla)
(do_swap, do_msr, do_mrs, do_mull, do_ldstv4, do_bx, do_blx)
(do_bkpt, do_clz, do_lstc2, do_cdp2, do_co_reg2, do_smla, do_smlal)
(do_smul, do_qadd, do_pld, do_ldrd, do_co_reg2c, do_cdp, do_lstc)
(do_co_reg, do_fpa_ctrl, do_fpa_ldst, do_fpa_ldmstm, do_fpa_monadic)
(do_fpa_dyadic, do_fpa_cmp, do_fpa_from_reg, do_fpa_to_reg, do_mia)
(do_mar, do_mra, do_c_binops, do_c_binops_1, do_c_binops_2)
(do_c_binops_3, do_c_triple, do_c_triple_4, do_c_triple_5, do_c_quad)
(do_c_quad_6, do_c_dspsc, do_c_dspsc_1, do_c_dspsc_2, do_c_shift)
(do_c_shift_1, do_c_shift_2, do_c_ldst, do_c_ldst_1, do_c_ldst_2)
(do_c_ldst_3, do_c_ldst_4, do_branch25): Delete redundant argument,
FLAGS.
(struct asm_opcode): Adjust parms field accordingly.
(md_assemble): Don't pass dummy second argument when calling worker
functions.
(build_arm_ops_hsh): Add prototype
(BAD_FLAGS): Delete.
@
text
@d471 151
a621 10
enum cirrus_regtype
  {
    CIRRUS_REGTYPE_MVF   = 1,
    CIRRUS_REGTYPE_MVFX  = 2,
    CIRRUS_REGTYPE_MVD   = 3,
    CIRRUS_REGTYPE_MVDX  = 4,
    CIRRUS_REGTYPE_MVAX  = 5,
    CIRRUS_REGTYPE_DSPSC = 6,
    CIRRUS_REGTYPE_ANY   = 7
  };
d699 43
a741 10
static void do_c_binops		PARAMS ((char *, int));
static void do_c_binops_1	PARAMS ((char *));
static void do_c_binops_2	PARAMS ((char *));
static void do_c_binops_3	PARAMS ((char *));
static void do_c_triple		PARAMS ((char *, int));
static void do_c_triple_4	PARAMS ((char *));
static void do_c_triple_5	PARAMS ((char *));
static void do_c_quad		PARAMS ((char *, int));
static void do_c_quad_6		PARAMS ((char *));
static void do_c_dspsc		PARAMS ((char *, int));
d744 2
a745 1
static void do_c_shift		PARAMS ((char *, int));
d748 1
a748 1
static void do_c_ldst		PARAMS ((char *, int));
d753 1
d755 1
a755 2
						 enum cirrus_regtype));
static int cirrus_valid_reg	PARAMS ((int, enum cirrus_regtype));
d760 2
a761 1
static int arm_reg_parse	PARAMS ((char **));
d792 2
a793 1
static void insert_reg		PARAMS ((int));
d799 3
a801 1
static void insert_reg_alias	PARAMS ((char *, int));
d1494 20
a1513 20
  {"cfmvsr",     0xee000450, 6,  ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvrs",     0xee100450, 6,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmvdlr",    0xee000410, 7,  ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvrdl",    0xee100410, 7,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmvdhr",    0xee000430, 7,  ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvrdh",    0xee100430, 7,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmv64lr",   0xee000510, 8,  ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvr64l",   0xee100510, 8,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmv64hr",   0xee000530, 8,  ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvr64h",   0xee100530, 8,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmval32",   0xee100610, 8,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv32al",   0xee000610, 8,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmvam32",   0xee100630, 8,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv32am",   0xee000630, 8,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmvah32",   0xee100650, 8,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv32ah",   0xee000650, 8,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv32a",    0xee000670, 7,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmva32",    0xee100670, 7,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv64a",    0xee000690, 7,  ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmva64",    0xee100690, 7,  ARM_EXT_MAVERICK, do_c_binops_3},
d1516 14
a1529 14
  {"cfcpys",     0xee000400, 6,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcpyd",     0xee000420, 6,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvtsd",    0xee000460, 7,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvtds",    0xee000440, 7,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvt32s",   0xee000480, 8,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvt32d",   0xee0004a0, 8,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvt64s",   0xee0004c0, 8,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvt64d",   0xee0004e0, 8,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvts32",   0xee100580, 8,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvtd32",   0xee1005a0, 8,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cftruncs32", 0xee1005c0, 10, ARM_EXT_MAVERICK, do_c_binops_1},
  {"cftruncd32", 0xee1005e0, 10, ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfrshl32",   0xee000550, 8,  ARM_EXT_MAVERICK, do_c_triple_4},
  {"cfrshl64",   0xee000570, 8,  ARM_EXT_MAVERICK, do_c_triple_4},
d1532 30
a1561 30
  {"cfcmps",     0xee100490, 6,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfcmpd",     0xee1004b0, 6,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfcmp32",    0xee100590, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfcmp64",    0xee1005b0, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfabss",     0xee300400, 6,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfabsd",     0xee300420, 6,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfnegs",     0xee300440, 6,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfnegd",     0xee300460, 6,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfadds",     0xee300480, 6,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfaddd",     0xee3004a0, 6,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfsubs",     0xee3004c0, 6,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfsubd",     0xee3004e0, 6,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmuls",     0xee100400, 6,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmuld",     0xee100420, 6,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfabs32",    0xee300500, 7,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfabs64",    0xee300520, 7,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfneg32",    0xee300540, 7,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfneg64",    0xee300560, 7,  ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfadd32",    0xee300580, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfadd64",    0xee3005a0, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfsub32",    0xee3005c0, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfsub64",    0xee3005e0, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmul32",    0xee100500, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmul64",    0xee100520, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmac32",    0xee100540, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmsc32",    0xee100560, 7,  ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmadd32",   0xee000600, 8,  ARM_EXT_MAVERICK, do_c_quad_6},
  {"cfmsub32",   0xee100600, 8,  ARM_EXT_MAVERICK, do_c_quad_6},
  {"cfmadda32",  0xee200600, 9,  ARM_EXT_MAVERICK, do_c_quad_6},
  {"cfmsuba32",  0xee300600, 9,  ARM_EXT_MAVERICK, do_c_quad_6},
a1789 79
struct reg_entry
{
  const char * name;
  int          number;
};

#define int_register(reg) ((reg) >= 0 && (reg) <= 15)
#define cp_register(reg) ((reg) >= 32 && (reg) <= 47)
#define fp_register(reg) ((reg) >= 16 && (reg) <= 23)

#define ARM_EXT_MAVERICKSC_REG	134

#define cirrus_register(reg)		((reg) >= 50 && (reg) <= 134)
#define cirrus_mvf_register(reg)	((reg) >= 50 && (reg) <= 65)
#define cirrus_mvd_register(reg)	((reg) >= 70 && (reg) <= 85)
#define cirrus_mvfx_register(reg)	((reg) >= 90 && (reg) <= 105)
#define cirrus_mvdx_register(reg)	((reg) >= 110 && (reg) <= 125)
#define cirrus_mvax_register(reg)	((reg) >= 130 && (reg) <= 133)
#define ARM_EXT_MAVERICKsc_register(reg) 	((reg) == ARM_EXT_MAVERICKSC_REG)

#define REG_SP  13
#define REG_LR  14
#define REG_PC	15

/* These are the standard names.  Users can add aliases with .req.  */
static const struct reg_entry reg_table[] =
{
  /* Processor Register Numbers.  */
  {"r0", 0},    {"r1", 1},      {"r2", 2},      {"r3", 3},
  {"r4", 4},    {"r5", 5},      {"r6", 6},      {"r7", 7},
  {"r8", 8},    {"r9", 9},      {"r10", 10},    {"r11", 11},
  {"r12", 12},  {"r13", REG_SP},{"r14", REG_LR},{"r15", REG_PC},
  /* APCS conventions.  */
  {"a1", 0},	{"a2", 1},    {"a3", 2},     {"a4", 3},
  {"v1", 4},	{"v2", 5},    {"v3", 6},     {"v4", 7},     {"v5", 8},
  {"v6", 9},	{"sb", 9},    {"v7", 10},    {"sl", 10},
  {"fp", 11},	{"ip", 12},   {"sp", REG_SP},{"lr", REG_LR},{"pc", REG_PC},
  /* ATPCS additions to APCS conventions.  */
  {"wr", 7},    {"v8", 11},
  /* FP Registers.  */
  {"f0", 16},   {"f1", 17},   {"f2", 18},   {"f3", 19},
  {"f4", 20},   {"f5", 21},   {"f6", 22},   {"f7", 23},
  {"c0", 32},   {"c1", 33},   {"c2", 34},   {"c3", 35},
  {"c4", 36},   {"c5", 37},   {"c6", 38},   {"c7", 39},
  {"c8", 40},   {"c9", 41},   {"c10", 42},  {"c11", 43},
  {"c12", 44},  {"c13", 45},  {"c14", 46},  {"c15", 47},
  {"cr0", 32},  {"cr1", 33},  {"cr2", 34},  {"cr3", 35},
  {"cr4", 36},  {"cr5", 37},  {"cr6", 38},  {"cr7", 39},
  {"cr8", 40},  {"cr9", 41},  {"cr10", 42}, {"cr11", 43},
  {"cr12", 44}, {"cr13", 45}, {"cr14", 46}, {"cr15", 47},
  /* ATPCS additions to float register names.  */
  {"s0",16},	{"s1",17},	{"s2",18},	{"s3",19},
  {"s4",20},	{"s5",21},	{"s6",22},	{"s7",23},
  {"d0",16},	{"d1",17},	{"d2",18},	{"d3",19},
  {"d4",20},	{"d5",21},	{"d6",22},	{"d7",23},
  /* Cirrus DSP coprocessor registers.  */
  {"mvf0", 50},	{"mvf1", 51},	{"mvf2", 52},	{"mvf3", 53},
  {"mvf4", 54},	{"mvf5", 55},	{"mvf6", 56},	{"mvf7", 57},
  {"mvf8", 58},	{"mvf9", 59},	{"mvf10", 60},	{"mvf11", 61},
  {"mvf12", 62},{"mvf13", 63},	{"mvf14", 64},	{"mvf15", 65},
  {"mvd0", 70},	{"mvd1", 71},	{"mvd2", 72},	{"mvd3", 73},
  {"mvd4", 74},	{"mvd5", 75},	{"mvd6", 76},	{"mvd7", 77},
  {"mvd8", 78},	{"mvd9", 79},	{"mvd10", 80},	{"mvd11", 81},
  {"mvd12", 82},{"mvd13", 83},	{"mvd14", 84},	{"mvd15", 85},
  {"mvfx0", 90},{"mvfx1", 91},	{"mvfx2", 92},	{"mvfx3", 93},
  {"mvfx4", 94},{"mvfx5", 95},	{"mvfx6", 96},	{"mvfx7", 97},
  {"mvfx8", 98},{"mvfx9", 99},	{"mvfx10", 100},{"mvfx11", 101},
  {"mvfx12", 102},{"mvfx13", 103},{"mvfx14", 104},{"mvfx15", 105},
  {"mvdx0", 110}, {"mvdx1", 111}, {"mvdx2", 112}, {"mvdx3", 113},
  {"mvdx4", 114}, {"mvdx5", 115}, {"mvdx6", 116}, {"mvdx7", 117},
  {"mvdx8", 118}, {"mvdx9", 119}, {"mvdx10", 120},{"mvdx11", 121},
  {"mvdx12", 122},{"mvdx13", 123},{"mvdx14", 124},{"mvdx15", 125},
  {"mvax0", 130}, {"mvax1", 131}, {"mvax2", 132}, {"mvax3", 133},
  {"dspsc", ARM_EXT_MAVERICKSC_REG},
  /* FIXME: At some point we need to add VFP register names.  */
  /* Array terminator.  */
  {NULL, 0}
};

a1798 1
static struct hash_control * arm_reg_hsh   = NULL;
d2466 1
a2466 1
  if ((reg = arm_reg_parse (str)) != FAIL && int_register (reg))
d2559 1
a2559 1
     char ** str;
d2562 1
d2564 2
a2565 1
  skip_whitespace (* str);
d2570 4
a2573 2
  if (**str == 'p' || **str == 'P')
    (*str)++;
d2575 2
a2576 5
  pchar = *(*str)++;
  if (pchar >= '0' && pchar <= '9')
    {
      processor = pchar - '0';
      if (**str >= '0' && **str <= '9')
d2578 2
a2579 2
	  processor = processor * 10 + *(*str)++ - '0';
	  if (processor > 15)
d2581 6
a2586 2
	      inst.error = _("Illegal co-processor number");
	      return FAIL;
d2589 5
a2593 5
    }
  else
    {
      inst.error = _("Bad or missing co-processor number");
      return FAIL;
d2638 1
a2638 1
  if ((reg = arm_reg_parse (str)) != FAIL && cp_register (reg))
a2639 1
      reg &= 15;
d2661 1
a2661 1
  if ((reg = arm_reg_parse (str)) != FAIL && fp_register (reg))
a2662 1
      reg &= 7;
a6667 35
/* Given a register and a register type, return 1 if
   the register is of the given type, else return 0.  */

static int
cirrus_valid_reg (reg, regtype)
     int reg;
     enum cirrus_regtype regtype;
{
  switch (regtype)
    {
    case CIRRUS_REGTYPE_ANY:
      return 1;

    case CIRRUS_REGTYPE_MVF:
      return cirrus_mvf_register (reg);

    case CIRRUS_REGTYPE_MVFX:
      return cirrus_mvfx_register (reg);

    case CIRRUS_REGTYPE_MVD:
      return cirrus_mvd_register (reg);

    case CIRRUS_REGTYPE_MVDX:
      return cirrus_mvdx_register (reg);

    case CIRRUS_REGTYPE_MVAX:
      return cirrus_mvax_register (reg);

    case CIRRUS_REGTYPE_DSPSC:
      return ARM_EXT_MAVERICKsc_register (reg);
    }

  return 0;
}

a6669 2
   If the register is a Cirrus register, convert it's reg# appropriately.

a6671 8
   regtype is type register type expected, and is:
   	CIRRUS_REGTYPE_MVF
   	CIRRUS_REGTYPE_MVFX
   	CIRRUS_REGTYPE_MVD
   	CIRRUS_REGTYPE_MVDX
   	CIRRUS_REGTYPE_MVAX
   	CIRRUS_REGTYPE_DSPSC

d6679 1
a6679 1
     enum cirrus_regtype regtype;
d6681 2
a6682 32
  static char buff [135]; /* XXX */
  int         reg;
  char *      start = * str;

  if ((reg = arm_reg_parse (str)) != FAIL
      && (int_register (reg)
	  || cirrus_register (reg)))
    {
      int orig_reg = reg;

      /* Calculate actual register # for opcode.  */
      if (cirrus_register (reg)
	  && !ARM_EXT_MAVERICKsc_register (reg)) /* Leave this one as is.  */
	{
	  if (reg >= 130)
	    reg -= 130;
	  else if (reg >= 110)
	    reg -= 110;
	  else if (reg >= 90)
	    reg -= 90;
	  else if (reg >= 70)
	    reg -= 70;
	  else if (reg >= 50)
	    reg -= 50;
	}

      if (!cirrus_valid_reg (orig_reg, regtype))
	{
	  sprintf (buff, _("invalid register type at '%.100s'"), start);
	  inst.error = buff;
	  return FAIL;
	}
d6684 2
d6689 1
a6689 1
      return orig_reg;
d6692 1
a6692 1
  /* Restore the start point, we may have got a reg of the wrong class.  */
d6697 1
a6697 2
  sprintf (buff, _("Cirrus register expected, not '%.100s'"), start);
  inst.error = buff;
d6707 134
a6840 1
do_c_binops_1 (str)
d6843 1
a6843 1
  do_c_binops (str, CIRRUS_MODE1);
d6847 1
a6847 1
do_c_binops_2 (str)
d6850 1
a6850 1
  do_c_binops (str, CIRRUS_MODE2);
d6854 1
a6854 1
do_c_binops_3 (str)
d6857 1
a6857 1
  do_c_binops (str, CIRRUS_MODE3);
d6861 1
a6861 1
do_c_triple_4 (str)
d6864 1
a6864 1
  do_c_triple (str, CIRRUS_MODE4);
d6868 1
a6868 1
do_c_triple_5 (str)
d6871 1
a6871 1
  do_c_triple (str, CIRRUS_MODE5);
d6875 1
a6875 1
do_c_quad_6 (str)
d6878 1
a6878 1
  do_c_quad (str, CIRRUS_MODE6);
d6882 66
d6951 14
a6964 1
  do_c_dspsc (str, CIRRUS_MODE1);
d6967 1
d6972 14
a6985 1
  do_c_dspsc (str, CIRRUS_MODE2);
d6992 1
a6992 1
  do_c_shift (str, CIRRUS_MODE1);
d6999 1
a6999 1
  do_c_shift (str, CIRRUS_MODE2);
d7006 1
a7006 1
  do_c_ldst (str, CIRRUS_MODE1);
d7013 1
a7013 1
  do_c_ldst (str, CIRRUS_MODE2);
d7020 1
a7020 1
  do_c_ldst (str, CIRRUS_MODE3);
d7027 1
a7027 1
  do_c_ldst (str, CIRRUS_MODE4);
d7033 1
a7033 1
do_c_binops (str, mode)
d7036 2
d7039 1
a7039 1
  int shift1, shift2;
d7041 2
a7042 2
  shift1 = mode & 0xff;
  shift2 = (mode >> 8) & 0xff;
d7046 1
a7046 1
  if (cirrus_reg_required_here (&str, shift1, CIRRUS_REGTYPE_ANY) == FAIL
d7048 1
a7048 1
      || cirrus_reg_required_here (&str, shift2, CIRRUS_REGTYPE_ANY) == FAIL)
d7060 1
a7060 1
do_c_triple (str, mode)
d7063 3
d7067 1
a7067 1
  int shift1, shift2, shift3;
d7069 3
a7071 3
  shift1 = mode & 0xff;
  shift2 = (mode >> 8) & 0xff;
  shift3 = (mode >> 16) & 0xff;
d7075 1
a7075 1
  if (cirrus_reg_required_here (&str, shift1, CIRRUS_REGTYPE_ANY) == FAIL
d7077 1
a7077 1
      || cirrus_reg_required_here (&str, shift2, CIRRUS_REGTYPE_ANY) == FAIL
d7079 1
a7079 1
      || cirrus_reg_required_here (&str, shift3, CIRRUS_REGTYPE_ANY) == FAIL)
d7092 1
a7092 1
do_c_quad (str, mode)
d7095 4
d7100 1
a7100 6
  int shift1, shift2, shift3, shift4;
  enum cirrus_regtype rt;

  rt = (inst.instruction << 4 == 0xe2006000
	|| inst.instruction << 4 == 0xe3006000) ? CIRRUS_REGTYPE_MVAX
    : CIRRUS_REGTYPE_MVFX;
d7102 4
a7105 4
  shift1 = mode & 0xff;
  shift2 = (mode >> 8) & 0xff;
  shift3 = (mode >> 16) & 0xff;
  shift4 = (mode >> 24) & 0xff;
d7109 1
a7109 1
  if (cirrus_reg_required_here (&str, shift1, CIRRUS_REGTYPE_MVAX) == FAIL
d7111 1
a7111 1
      || cirrus_reg_required_here (&str, shift2, rt) == FAIL
d7113 1
a7113 1
      || cirrus_reg_required_here (&str, shift3, CIRRUS_REGTYPE_MVFX) == FAIL
d7115 1
a7115 1
      || cirrus_reg_required_here (&str, shift4, CIRRUS_REGTYPE_MVFX) == FAIL)
a7123 42
/* cfmvsc32<cond> DSPSC,MVFX[15:0].
   cfmv32sc<cond> MVFX[15:0],DSPSC.  */

static void
do_c_dspsc (str, mode)
     char * str;
     int mode;
{
  int error;

  skip_whitespace (str);

  error = 0;

  if (mode == CIRRUS_MODE1)
    {
      /* cfmvsc32.  */
      if (cirrus_reg_required_here (&str, -1, CIRRUS_REGTYPE_DSPSC) == FAIL
	  || skip_past_comma (&str) == FAIL
	  || cirrus_reg_required_here (&str, 16, CIRRUS_REGTYPE_MVFX) == FAIL)
	error = 1;
    }
  else
    {
      /* cfmv32sc.  */
      if (cirrus_reg_required_here (&str, 0, CIRRUS_REGTYPE_MVFX) == FAIL
	  || skip_past_comma (&str) == FAIL
	  || cirrus_reg_required_here (&str, -1, CIRRUS_REGTYPE_DSPSC) == FAIL)
	error = 1;
    }

  if (error)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    {
      end_of_line (str);
    }
}

d7129 1
a7129 1
do_c_shift (str, mode)
d7131 2
a7132 1
     int mode;
d7141 1
a7141 4
  if (cirrus_reg_required_here (&str, 12,
				(mode == CIRRUS_MODE1)
				? CIRRUS_REGTYPE_MVFX
				: CIRRUS_REGTYPE_MVDX) == FAIL
d7143 1
a7143 4
      || cirrus_reg_required_here (&str, 16,
				   (mode == CIRRUS_MODE1)
				   ? CIRRUS_REGTYPE_MVFX
				   : CIRRUS_REGTYPE_MVDX) == FAIL
d7241 1
a7241 1
do_c_ldst (str, mode)
d7243 1
a7243 1
     int mode;
a7245 6
  enum cirrus_regtype rt;

  rt = mode == CIRRUS_MODE1 ? CIRRUS_REGTYPE_MVF
    : mode == CIRRUS_MODE2 ? CIRRUS_REGTYPE_MVD
    : mode == CIRRUS_MODE3 ? CIRRUS_REGTYPE_MVFX
    : mode == CIRRUS_MODE4 ? CIRRUS_REGTYPE_MVDX : CIRRUS_REGTYPE_MVF;
d7249 2
a7250 2
  if (cirrus_reg_required_here (& str, 12, rt) == FAIL
      || skip_past_comma (& str) == FAIL
d7252 1
a7252 1
      || reg_required_here (& str, 16) == FAIL)
d7255 1
a7255 1
  if (skip_past_comma (& str) == SUCCESS)
d7721 3
a7723 2
insert_reg (entry)
     int entry;
d7725 1
a7725 1
  int    len  = strlen (reg_table[entry].name) + 2;
d7734 1
a7734 1
  strcpy (buf + i, reg_table[entry].name);
d7741 2
a7742 2
  hash_insert (arm_reg_hsh, buf,  (PTR) & reg_table[entry]);
  hash_insert (arm_reg_hsh, buf2, (PTR) & reg_table[entry]);
d7746 14
a7759 1
insert_reg_alias (str, regnum)
d7762 1
d7772 1
a7772 1
  hash_insert (arm_reg_hsh, name, (PTR) new);
d7775 86
d7883 1
a7883 1
      CONST struct asm_opcode *insn = insns + i;
a7928 1
      || (arm_reg_hsh = hash_new ()) == NULL
d7942 2
a7943 2
  for (i = 0; reg_table[i].name; i++)
    insert_reg (i);
d8232 1
a8232 1
arm_reg_parse (ccp)
d8234 1
d8260 1
a8260 1
  reg = (struct reg_entry *) hash_find (arm_reg_hsh, start);
d8272 16
d9099 3
a9101 4
  char   c;
  char * p;
  char * q;
  char * start;
d9166 1
a9166 1
      opcode = (CONST struct asm_opcode *) hash_find (arm_ops_hsh, str);
d9188 2
a9189 19
  q = p;
  skip_whitespace (q);

  c = *p;
  *p = '\0';

  if (*q && !strncmp (q, ".req ", 4))
    {
      int    reg;
      char * copy_of_str;
      char * r;

#ifdef IGNORE_OPCODE_CASE
      str = original_case_string;
#endif
      copy_of_str = str;

      q += 4;
      skip_whitespace (q);
a9190 42
      for (r = q; *r != '\0'; r++)
	if (*r == ' ')
	  break;

      if (r != q)
	{
	  int regnum;
	  char d = *r;

	  *r = '\0';
	  regnum = arm_reg_parse (& q);
	  *r = d;

	  reg = arm_reg_parse (& str);

	  if (reg == FAIL)
	    {
	      if (regnum != FAIL)
		insert_reg_alias (str, regnum);
	      else
		as_warn (_("register '%s' does not exist\n"), q);
	    }
	  else if (regnum != FAIL)
	    {
	      if (reg != regnum)
		as_warn (_("ignoring redefinition of register alias '%s'"),
			 copy_of_str);

	      /* Do not warn about redefinitions to the same alias.  */
	    }
	  else
	    as_warn (_("ignoring redefinition of register alias '%s' to non-existant register '%s'"),
		     copy_of_str, q);
	}
      else
	as_warn (_("ignoring incomplete .req pseuso op"));

      *p = c;
      return;
    }

  *p = c;
@


1.104
log
@* tc-arm.c (struct asm_opcode): Delete comp_suffix and flags.  Add
cond_offset.  Rename variants->variant.
(insns): Adjust for new format.  Explicitly code each variant that
takes flags.  Remove temporary instructions.
(struct arm_it): Remove redundant field suffix.
(s_flag, ldr_flags, str_flags, byte_flag, cmp_flags, ldm_flags)
(stm_flags, lfm_flags, sfm_flags, round_flags, fix_flags, except_flag)
(long_flag): Delete.
(struct asm_flg): Delete.
(LONGEST_INST): Delete.
(V4_STR_BIT): Define.
(struct thumb_opcode): Rename variants->variant.
(do_empty): Renamed from do_nop.
(ldst_extend): Delete argument hwse.  Split code for half-word and
signed byte instructions to ...
(ldst_extend_v4): ... here.
(ld_mode_required_here): Use ldst_extend_v4.
(do_ldrd): Simplify now that this is only called for ldrd.  No
need to test for XScale, which was wrong anyway.  Don't reject r12
as a target register.  Add test that ldrd doesn't update an index
register.
(do_pld): Don't allow post-indexed or write-back addressing modes.
Adjust call to ldst_extend.
(do_adr): Split code for adrl to ...
(do_adrl): ... here.
(do_cmp): No need to fold in COND_BIT.
(do_ldst): Simplify.  Split code for ldrt/strt into do_ldstt.  Split
code to handle half-word and signed byte instructions to ...
(do_ldstv4): ... here.
(do_ldstt): New function.  Handle load/store with translate.
(do_ldmstm): Write feature modification bits directly into
inst.instruction.
(do_fpa_ldst): Remove suffix handling code.
(do_fpa_dyadic, do_fpa_monadic, do_fpa_from_reg): Likewise.
(do_fpa_ldmstm): Type of access is now held in inst.instruction.
(build_arm_ops_hsh): New function.
(md_begin): Call it.  Don't build the ARM opcode directly.
(md_assemble): Simplify ARM instruction handling.
@
text
@d484 8
a491 8
static void do_arit		PARAMS ((char *, unsigned long));
static void do_cmp		PARAMS ((char *, unsigned long));
static void do_mov		PARAMS ((char *, unsigned long));
static void do_ldst		PARAMS ((char *, unsigned long));
static void do_ldstt		PARAMS ((char *, unsigned long));
static void do_ldmstm		PARAMS ((char *, unsigned long));
static void do_branch		PARAMS ((char *, unsigned long));
static void do_swi		PARAMS ((char *, unsigned long));
d494 3
a496 3
static void do_adr		PARAMS ((char *, unsigned long));
static void do_adrl		PARAMS ((char *, unsigned long));
static void do_empty		PARAMS ((char *, unsigned long));
d499 2
a500 2
static void do_mul		PARAMS ((char *, unsigned long));
static void do_mla		PARAMS ((char *, unsigned long));
d503 1
a503 1
static void do_swap		PARAMS ((char *, unsigned long));
d506 2
a507 2
static void do_msr		PARAMS ((char *, unsigned long));
static void do_mrs		PARAMS ((char *, unsigned long));
d510 1
a510 1
static void do_mull		PARAMS ((char *, unsigned long));
d513 1
a513 1
static void do_ldstv4		PARAMS ((char *, unsigned long));
d516 1
a516 1
static void do_bx               PARAMS ((char *, unsigned long));
d519 6
a524 6
static void do_blx		PARAMS ((char *, unsigned long));
static void do_bkpt		PARAMS ((char *, unsigned long));
static void do_clz		PARAMS ((char *, unsigned long));
static void do_lstc2		PARAMS ((char *, unsigned long));
static void do_cdp2		PARAMS ((char *, unsigned long));
static void do_co_reg2		PARAMS ((char *, unsigned long));
d527 4
a530 4
static void do_smla		PARAMS ((char *, unsigned long));
static void do_smlal		PARAMS ((char *, unsigned long));
static void do_smul		PARAMS ((char *, unsigned long));
static void do_qadd		PARAMS ((char *, unsigned long));
d533 3
a535 3
static void do_pld		PARAMS ((char *, unsigned long));
static void do_ldrd		PARAMS ((char *, unsigned long));
static void do_co_reg2c		PARAMS ((char *, unsigned long));
d538 3
a540 3
static void do_cdp		PARAMS ((char *, unsigned long));
static void do_lstc		PARAMS ((char *, unsigned long));
static void do_co_reg		PARAMS ((char *, unsigned long));
d543 8
a550 8
static void do_fpa_ctrl		PARAMS ((char *, unsigned long));
static void do_fpa_ldst		PARAMS ((char *, unsigned long));
static void do_fpa_ldmstm	PARAMS ((char *, unsigned long));
static void do_fpa_dyadic	PARAMS ((char *, unsigned long));
static void do_fpa_monadic	PARAMS ((char *, unsigned long));
static void do_fpa_cmp		PARAMS ((char *, unsigned long));
static void do_fpa_from_reg	PARAMS ((char *, unsigned long));
static void do_fpa_to_reg	PARAMS ((char *, unsigned long));
d553 25
a577 25
static void do_mia		PARAMS ((char *, unsigned long));
static void do_mar		PARAMS ((char *, unsigned long));
static void do_mra		PARAMS ((char *, unsigned long));

/* ARM_EXT_MAVERICK.  */
static void do_c_binops		PARAMS ((char *, unsigned long, int));
static void do_c_binops_1	PARAMS ((char *, unsigned long));
static void do_c_binops_2	PARAMS ((char *, unsigned long));
static void do_c_binops_3	PARAMS ((char *, unsigned long));
static void do_c_triple		PARAMS ((char *, unsigned long, int));
static void do_c_triple_4	PARAMS ((char *, unsigned long));
static void do_c_triple_5	PARAMS ((char *, unsigned long));
static void do_c_quad		PARAMS ((char *, unsigned long, int));
static void do_c_quad_6		PARAMS ((char *, unsigned long));
static void do_c_dspsc		PARAMS ((char *, unsigned long, int));
static void do_c_dspsc_1	PARAMS ((char *, unsigned long));
static void do_c_dspsc_2	PARAMS ((char *, unsigned long));
static void do_c_shift		PARAMS ((char *, unsigned long, int));
static void do_c_shift_1	PARAMS ((char *, unsigned long));
static void do_c_shift_2	PARAMS ((char *, unsigned long));
static void do_c_ldst		PARAMS ((char *, unsigned long, int));
static void do_c_ldst_1		PARAMS ((char *, unsigned long));
static void do_c_ldst_2		PARAMS ((char *, unsigned long));
static void do_c_ldst_3		PARAMS ((char *, unsigned long));
static void do_c_ldst_4		PARAMS ((char *, unsigned long));
d619 1
d626 1
a626 1
static void do_branch25         PARAMS ((char *, unsigned long));
d670 1
a670 1
  void (* parms) PARAMS ((char *, unsigned long));
d783 1
a783 1
  /* ARM 7M long multiplies - need signed/unsigned flags!  */
a1691 1
#define BAD_FLAGS 	_("Instruction should not have flags")
d2719 1
a2719 1
do_empty (str, flags)
a2720 1
     unsigned long flags;
a2722 1
  inst.instruction |= flags; /* This is pointless.  */
d2728 1
a2728 1
do_mrs (str, flags)
a2729 1
     unsigned long flags;
a2770 1
  inst.instruction |= flags;
d2779 1
a2779 1
do_msr (str, flags)
a2780 1
     unsigned long flags;
a2797 1
      inst.instruction |= flags;
d2831 1
a2831 1
  flags |= INST_IMMEDIATE;
a2851 1
  inst.instruction |= flags;
d2862 1
a2862 1
do_mull (str, flags)
a2863 1
     unsigned long flags;
a2906 1
  inst.instruction |= flags;
d2912 1
a2912 1
do_mul (str, flags)
a2913 1
     unsigned long flags;
a2960 1
  inst.instruction |= flags;
d2966 1
a2966 1
do_mla (str, flags)
a2967 1
     unsigned long flags;
a3016 1
  inst.instruction |= flags;
d3171 1
a3171 1
do_smla (str, flags)
a3172 1
     unsigned long flags;
a3189 3
  else if (flags)
    inst.error = BAD_FLAGS;

d3200 1
a3200 1
do_smlal (str, flags)
a3201 1
     unsigned long flags;
d3228 1
a3228 4
  if (flags)
    inst.error = BAD_FLAGS;
  else
    end_of_line (str);
d3236 1
a3236 1
do_smul (str, flags)
a3237 1
     unsigned long flags;
a3252 3
  else if (flags)
    inst.error = BAD_FLAGS;

d3262 1
a3262 1
do_qadd (str, flags)
a3263 1
     unsigned long flags;
a3278 3
  else if (flags)
    inst.error = BAD_FLAGS;

d3293 1
a3293 1
do_co_reg2c (str, flags)
a3294 1
     unsigned long flags;
a3343 3
  if (flags)
    inst.error = BAD_COND;

d3353 1
a3353 1
do_clz (str, flags)
a3354 1
     unsigned long flags;
a3357 6
  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

d3379 1
a3379 1
do_lstc2 (str, flags)
a3380 1
     unsigned long flags;
a3381 3
  if (flags)
    inst.error = BAD_COND;

d3411 1
a3411 1
do_cdp2 (str, flags)
a3412 1
     unsigned long flags;
a3464 3
  if (flags)
    inst.error = BAD_FLAGS;

d3475 1
a3475 1
do_co_reg2 (str, flags)
a3476 1
     unsigned long flags;
a3528 3
  if (flags)
    inst.error = BAD_COND;

d3575 1
a3575 1
do_branch25 (str, flags)
a3576 1
     unsigned long flags ATTRIBUTE_UNUSED;
d3629 1
a3629 1
do_blx (str, flags)
a3630 1
     unsigned long flags;
a3634 6
  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

d3647 1
a3647 1
      do_bx (str, flags);
d3662 1
a3662 1
      do_branch25 (str, flags);
d3714 1
a3714 2
	and it is an error if the caller tried to override that.
     Note "flags" is nonzero if a flag was supplied (which is an error).  */
d3717 1
a3717 1
do_bkpt (str, flags)
a3718 1
     unsigned long flags;
a3752 3

  if (flags)
    inst.error = BAD_FLAGS;
d3761 1
a3761 1
do_mia (str, flags)
a3762 1
     unsigned long flags;
d3767 1
a3767 4
  if (flags)
    as_bad (BAD_FLAGS);

  else if (accum0_required_here (& str) == FAIL)
d3791 1
a3791 1
do_mar (str, flags)
a3792 1
     unsigned long flags;
d3796 1
a3796 4
  if (flags)
    as_bad (BAD_FLAGS);

  else if (accum0_required_here (& str) == FAIL)
d3820 1
a3820 1
do_mra (str, flags)
a3821 1
     unsigned long flags;
a3825 6
  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

d3856 1
a3856 1
do_pld (str, flags)
a3857 1
     unsigned long flags;
a3860 6
  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

d3939 1
a3939 1
do_ldrd (str, flags)
a3940 1
     unsigned long flags;
d3970 1
a3970 1
      inst.error = _("r12 or r14 not allowed here");
d4479 1
a4479 1
do_arit (str, flags)
a4480 1
     unsigned long flags;
a4494 1
  inst.instruction |= flags;
d4500 1
a4500 1
do_adr (str, flags)
a4501 1
     unsigned long flags;
d4526 1
a4526 1
do_adrl (str, flags)
a4527 1
     unsigned long flags;
d4558 1
a4558 1
do_cmp (str, flags)
a4559 1
     unsigned long flags;
a4577 1
  inst.instruction |= flags;
d4583 1
a4583 1
do_mov (str, flags)
a4584 1
     unsigned long flags;
a4602 1
  inst.instruction |= flags;
d4667 1
a4667 1
do_ldst (str, flags)
a4668 1
     unsigned long flags;
a4688 2
  flags = 0;

d4837 1
a4837 1
do_ldstt (str, flags)
a4838 1
     unsigned long flags;
d4977 1
a4977 1
do_ldstv4 (str, flags)
a4978 1
     unsigned long flags;
d5293 1
a5293 1
do_ldmstm (str, flags)
a5294 1
     unsigned long flags;
d5332 1
a5332 1
  inst.instruction |= flags | range;
d5338 1
a5338 1
do_swi (str, flags)
a5339 1
     unsigned long flags;
a5351 2
  inst.instruction |= flags;

d5358 1
a5358 1
do_swap (str, flags)
a5359 1
     unsigned long flags;
a5413 1
  inst.instruction |= flags;
d5419 1
a5419 1
do_branch (str, flags)
a5420 1
     unsigned long flags ATTRIBUTE_UNUSED;
d5464 1
a5464 1
do_bx (str, flags)
a5465 1
     unsigned long flags ATTRIBUTE_UNUSED;
d5485 1
a5485 1
do_cdp (str, flags)
a5486 1
     unsigned long flags ATTRIBUTE_UNUSED;
d5546 1
a5546 1
do_lstc (str, flags)
a5547 1
     unsigned long flags;
a5576 1
  inst.instruction |= flags;
d5582 1
a5582 1
do_co_reg (str, flags)
a5583 1
     unsigned long flags;
a5637 4
  if (flags)
    {
      inst.error = BAD_COND;
    }
d5644 1
a5644 1
do_fpa_ctrl (str, flags)
a5645 1
     unsigned long flags ATTRIBUTE_UNUSED;
d5664 1
a5664 1
do_fpa_ldst (str, flags)
a5665 1
     unsigned long flags ATTRIBUTE_UNUSED;
d5688 1
a5688 1
do_fpa_ldmstm (str, flags)
a5689 1
     unsigned long flags;
d5813 1
a5813 1
      inst.instruction |= flags | offset;
d5827 1
a5827 1
do_fpa_dyadic (str, flags)
a5828 1
     unsigned long flags;
a5854 1
  inst.instruction |= flags;
d5860 1
a5860 1
do_fpa_monadic (str, flags)
a5861 1
     unsigned long flags;
a5879 1
  inst.instruction |= flags;
d5885 1
a5885 1
do_fpa_cmp (str, flags)
a5886 1
     unsigned long flags;
a5904 1
  inst.instruction |= flags;
d5910 1
a5910 1
do_fpa_from_reg (str, flags)
a5911 1
     unsigned long flags;
a5929 1
  inst.instruction |= flags;
d5935 1
a5935 1
do_fpa_to_reg (str, flags)
a5936 1
     unsigned long flags;
a5950 1
  inst.instruction |= flags;
d6679 1
a6679 1
do_c_binops_1 (str, flags)
a6680 1
     unsigned long flags;
d6682 1
a6682 1
  do_c_binops (str, flags, CIRRUS_MODE1);
d6686 1
a6686 1
do_c_binops_2 (str, flags)
a6687 1
     unsigned long flags;
d6689 1
a6689 1
  do_c_binops (str, flags, CIRRUS_MODE2);
d6693 1
a6693 1
do_c_binops_3 (str, flags)
a6694 1
     unsigned long flags;
d6696 1
a6696 1
  do_c_binops (str, flags, CIRRUS_MODE3);
d6700 1
a6700 1
do_c_triple_4 (str, flags)
a6701 1
     unsigned long flags;
d6703 1
a6703 1
  do_c_triple (str, flags, CIRRUS_MODE4);
d6707 1
a6707 1
do_c_triple_5 (str, flags)
a6708 1
     unsigned long flags;
d6710 1
a6710 1
  do_c_triple (str, flags, CIRRUS_MODE5);
d6714 1
a6714 1
do_c_quad_6 (str, flags)
a6715 1
     unsigned long flags;
d6717 1
a6717 1
  do_c_quad (str, flags, CIRRUS_MODE6);
d6721 1
a6721 1
do_c_dspsc_1 (str, flags)
a6722 1
     unsigned long flags;
d6724 1
a6724 1
  do_c_dspsc (str, flags, CIRRUS_MODE1);
d6728 1
a6728 1
do_c_dspsc_2 (str, flags)
a6729 1
     unsigned long flags;
d6731 1
a6731 1
  do_c_dspsc (str, flags, CIRRUS_MODE2);
d6735 1
a6735 1
do_c_shift_1 (str, flags)
a6736 1
     unsigned long flags;
d6738 1
a6738 1
  do_c_shift (str, flags, CIRRUS_MODE1);
d6742 1
a6742 1
do_c_shift_2 (str, flags)
a6743 1
     unsigned long flags;
d6745 1
a6745 1
  do_c_shift (str, flags, CIRRUS_MODE2);
d6749 1
a6749 1
do_c_ldst_1 (str, flags)
a6750 1
     unsigned long flags;
d6752 1
a6752 1
  do_c_ldst (str, flags, CIRRUS_MODE1);
d6756 1
a6756 1
do_c_ldst_2 (str, flags)
a6757 1
     unsigned long flags;
d6759 1
a6759 1
  do_c_ldst (str, flags, CIRRUS_MODE2);
d6763 1
a6763 1
do_c_ldst_3 (str, flags)
a6764 1
     unsigned long flags;
d6766 1
a6766 1
  do_c_ldst (str, flags, CIRRUS_MODE3);
d6770 1
a6770 1
do_c_ldst_4 (str, flags)
a6771 1
     unsigned long flags;
d6773 1
a6773 1
  do_c_ldst (str, flags, CIRRUS_MODE4);
d6779 1
a6779 1
do_c_binops (str, flags, mode)
a6780 1
     unsigned long flags;
a6798 3
  
  inst.instruction |= flags;
  return;
d6804 1
a6804 1
do_c_triple (str, flags, mode)
a6805 1
     unsigned long flags;
a6826 3
  
  inst.instruction |= flags;
  return;
d6833 1
a6833 1
do_c_quad (str, flags, mode)
a6834 1
     unsigned long flags;
a6863 3
  
  inst.instruction |= flags;
  return;
d6870 1
a6870 1
do_c_dspsc (str, flags, mode)
a6871 1
     unsigned long flags;
a6903 1
      inst.instruction |= flags;
a6905 2

  return;
d6913 1
a6913 1
do_c_shift (str, flags, mode)
a6914 1
     unsigned long flags;
a6980 2
  inst.instruction |= flags;

a6981 2

  return;
d7030 1
a7030 1
do_c_ldst (str, flags, mode)
a7031 1
     unsigned long flags;
a7093 2
  inst.instruction |= flags;

d8859 1
a8859 1
	  (*opcode->parms) (p, 0);
@


1.103
log
@Only clear cpu part when specifying 'xscale' cpu (don't change the fpu part)
@
text
@a82 1
#define ARM_2UP		(ARM_ANY - ARM_1)
a189 1
  int           suffix;
a279 1
#define TRANS_BIT	 0x00200000
a288 1
/* This is to save a hash look-up in the common case.  */
d290 1
a311 131
/* Warning: If the top bit of the set_bits is set, then the standard
   instruction bitmask is ignored, and the new bitmask is taken from
   the set_bits:  */
struct asm_flg
{
  const char *  template;	/* Basic flag string.  */
  unsigned long set_bits;	/* Bits to set.  */
};

static const struct asm_flg s_flag[] =
{
  {"s", CONDS_BIT},
  {NULL, 0}
};

static const struct asm_flg ldr_flags[] =
{
  {"d",  DOUBLE_LOAD_FLAG},
  {"b",  0x00400000},
  {"t",  TRANS_BIT},
  {"bt", 0x00400000 | TRANS_BIT},
  {"h",  0x801000b0},
  {"sh", 0x801000f0},
  {"sb", 0x801000d0},
  {NULL, 0}
};

static const struct asm_flg str_flags[] =
{
  {"d",  DOUBLE_LOAD_FLAG},
  {"b",  0x00400000},
  {"t",  TRANS_BIT},
  {"bt", 0x00400000 | TRANS_BIT},
  {"h",  0x800000b0},
  {NULL, 0}
};

static const struct asm_flg byte_flag[] =
{
  {"b", 0x00400000},
  {NULL, 0}
};

static const struct asm_flg cmp_flags[] =
{
  {"s", CONDS_BIT},
  {"p", 0x0010f000},
  {NULL, 0}
};

static const struct asm_flg ldm_flags[] =
{
  {"ed", 0x01800000},
  {"fd", 0x00800000},
  {"ea", 0x01000000},
  {"fa", 0x00000000},
  {"ib", 0x01800000},
  {"ia", 0x00800000},
  {"db", 0x01000000},
  {"da", 0x00000000},
  {NULL, 0}
};

static const struct asm_flg stm_flags[] =
{
  {"ed", 0x00000000},
  {"fd", 0x01000000},
  {"ea", 0x00800000},
  {"fa", 0x01800000},
  {"ib", 0x01800000},
  {"ia", 0x00800000},
  {"db", 0x01000000},
  {"da", 0x00000000},
  {NULL, 0}
};

static const struct asm_flg lfm_flags[] =
{
  {"fd", 0x00800000},
  {"ea", 0x01000000},
  {NULL, 0}
};

static const struct asm_flg sfm_flags[] =
{
  {"fd", 0x01000000},
  {"ea", 0x00800000},
  {NULL, 0}
};

static const struct asm_flg round_flags[] =
{
  {"p", 0x00000020},
  {"m", 0x00000040},
  {"z", 0x00000060},
  {NULL, 0}
};

/* The implementation of the FIX instruction is broken on some assemblers,
   in that it accepts a precision specifier as well as a rounding specifier,
   despite the fact that this is meaningless.  To be more compatible, we
   accept it as well, though of course it does not set any bits.  */
static const struct asm_flg fix_flags[] =
{
  {"p", 0x00000020},
  {"m", 0x00000040},
  {"z", 0x00000060},
  {"sp", 0x00000020},
  {"sm", 0x00000040},
  {"sz", 0x00000060},
  {"dp", 0x00000020},
  {"dm", 0x00000040},
  {"dz", 0x00000060},
  {"ep", 0x00000020},
  {"em", 0x00000040},
  {"ez", 0x00000060},
  {NULL, 0}
};

static const struct asm_flg except_flag[] =
{
  {"e", 0x00400000},
  {NULL, 0}
};

static const struct asm_flg long_flag[] =
{
  {"l", 0x00400000},
  {NULL, 0}
};

d488 1
d495 2
a496 1
static void do_nop		PARAMS ((char *, unsigned long));
d512 3
d518 1
a518 1
/* ARM_v5.  */
d578 2
a579 1
static int cirrus_reg_required_here	PARAMS ((char **, int, enum cirrus_regtype));
d583 2
a584 1
static void fix_new_arm		PARAMS ((fragS *, int, short, expressionS *, int, int));
d587 2
a588 1
static void symbol_locate	PARAMS ((symbolS *, const char *, segT, valueT, fragS *));
d591 2
a592 1
static unsigned validate_immediate_twopart PARAMS ((unsigned int, unsigned int *));
d613 2
a614 1
static int ldst_extend		PARAMS ((char **, int));
a634 5
/* LONGEST_INST is the longest basic instruction name without
   conditions or flags.  ARM7M has 4 of length 5.  El Segundo
   has one basic instruction name of length 7 (SMLALxy).  */
#define LONGEST_INST 10

d661 3
a663 3
  /* Compulsory suffix that must follow conds.  If "", then the
     instruction is not conditional and must have no suffix.  */
  const char * comp_suffix;
d665 2
a666 5
  /* Bits to toggle if flag 'n' set.  */
  const struct asm_flg * flags;

  /* Which CPU variants this exists for.  */
  unsigned long variants;
d674 66
a739 3
  /* XXX Temporary hack.  Override the normal load/store entry points.  */
  {"ldr",   0x000000d0, NULL,   ldr_flags,   ARM_EXT_V1,        do_ldrd},
  {"str",   0x000000f0, NULL,   str_flags,   ARM_EXT_V1,        do_ldrd},
d741 1
a741 22
  /* Core ARM Instructions.  */
  {"and",   0x00000000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"eor",   0x00200000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"sub",   0x00400000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"rsb",   0x00600000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"add",   0x00800000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"adc",   0x00a00000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"sbc",   0x00c00000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"rsc",   0x00e00000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"orr",   0x01800000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"bic",   0x01c00000, NULL,   s_flag,      ARM_EXT_V1,      do_arit},
  {"tst",   0x01000000, NULL,   cmp_flags,   ARM_EXT_V1,      do_cmp},
  {"teq",   0x01200000, NULL,   cmp_flags,   ARM_EXT_V1,      do_cmp},
  {"cmp",   0x01400000, NULL,   cmp_flags,   ARM_EXT_V1,      do_cmp},
  {"cmn",   0x01600000, NULL,   cmp_flags,   ARM_EXT_V1,      do_cmp},
  {"mov",   0x01a00000, NULL,   s_flag,      ARM_EXT_V1,      do_mov},
  {"mvn",   0x01e00000, NULL,   s_flag,      ARM_EXT_V1,      do_mov},
  {"str",   0x04000000, NULL,   str_flags,   ARM_EXT_V1,      do_ldst},
  {"ldr",   0x04100000, NULL,   ldr_flags,   ARM_EXT_V1,      do_ldst},
  {"stm",   0x08000000, NULL,   stm_flags,   ARM_EXT_V1,      do_ldmstm},
  {"ldm",   0x08100000, NULL,   ldm_flags,   ARM_EXT_V1,      do_ldmstm},
  {"swi",   0x0f000000, NULL,   NULL,        ARM_EXT_V1,      do_swi},
d744 2
a745 2
  {"bl",    0x0b000000, NULL,   NULL,        ARM_EXT_V1,      do_branch},
  {"b",     0x0a000000, NULL,   NULL,        ARM_EXT_V1,      do_branch},
d747 2
a748 2
  {"bl",    0x0bfffffe, NULL,   NULL,        ARM_EXT_V1,      do_branch},
  {"b",     0x0afffffe, NULL,   NULL,        ARM_EXT_V1,      do_branch},
d752 3
a754 2
  {"adr",   0x028f0000, NULL,   long_flag,   ARM_EXT_V1,      do_adr},
  {"nop",   0x01a00000, NULL,   NULL,        ARM_EXT_V1,      do_nop},
d757 4
a760 2
  {"mul",   0x00000090, NULL,   s_flag,      ARM_EXT_V2,      do_mul},
  {"mla",   0x00200090, NULL,   s_flag,      ARM_EXT_V2,      do_mla},
d763 7
a769 5
  {"cdp",   0x0e000000, NULL,  NULL,         ARM_EXT_V2,      do_cdp},
  {"ldc",   0x0c100000, NULL,  long_flag,    ARM_EXT_V2,      do_lstc},
  {"stc",   0x0c000000, NULL,  long_flag,    ARM_EXT_V2,      do_lstc},
  {"mcr",   0x0e000010, NULL,  NULL,         ARM_EXT_V2,      do_co_reg},
  {"mrc",   0x0e100010, NULL,  NULL,         ARM_EXT_V2,      do_co_reg},
d772 2
a773 1
  {"swp",   0x01000090, NULL,   byte_flag,   ARM_EXT_V2S,      do_swap},
d776 3
a778 3
  {"mrs",   0x010f0000, NULL,   NULL,        ARM_EXT_V3,      do_mrs},
  {"msr",   0x0120f000, NULL,   NULL,        ARM_EXT_V3,      do_msr},
  /* ScottB: our code uses 0x0128f000 for msr.
d780 1
a780 1
	     handled by the PSR_xxx defines above.  */
d783 14
a796 4
  {"smull", 0x00c00090, NULL,   s_flag,      ARM_EXT_V3M,  do_mull},
  {"umull", 0x00800090, NULL,   s_flag,      ARM_EXT_V3M,  do_mull},
  {"smlal", 0x00e00090, NULL,   s_flag,      ARM_EXT_V3M,  do_mull},
  {"umlal", 0x00a00090, NULL,   s_flag,      ARM_EXT_V3M,  do_mull},
d799 44
a842 42
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.   */
  {"bx",    0x012fff10, NULL,   NULL,        ARM_EXT_V4T | ARM_EXT_V5, do_bx},

  /*  ARM ISA extension 5.  */
  /* Note: blx is actually 2 opcodes, so the .value is set dynamically.
     And it's sometimes conditional and sometimes not.  */
  {"blx",            0, NULL,   NULL,        ARM_EXT_V5, do_blx},
  {"clz",   0x016f0f10, NULL,   NULL,        ARM_EXT_V5, do_clz},
  {"bkpt",  0xe1200070, "",   	NULL,        ARM_EXT_V5, do_bkpt},
  {"ldc2",  0xfc100000, "",  	long_flag,   ARM_EXT_V5, do_lstc2},
  {"stc2",  0xfc000000, "",  	long_flag,   ARM_EXT_V5, do_lstc2},
  {"cdp2",  0xfe000000, "",  	NULL,        ARM_EXT_V5, do_cdp2},
  {"mcr2",  0xfe000010, "",  	NULL,        ARM_EXT_V5, do_co_reg2},
  {"mrc2",  0xfe100010, "",  	NULL,        ARM_EXT_V5, do_co_reg2},

/*  ARM Architecture 5ExP.  */
  {"smlabb", 0x01000080, NULL,   NULL,        ARM_EXT_V5ExP, do_smla},
  {"smlatb", 0x010000a0, NULL,   NULL,        ARM_EXT_V5ExP, do_smla},
  {"smlabt", 0x010000c0, NULL,   NULL,        ARM_EXT_V5ExP, do_smla},
  {"smlatt", 0x010000e0, NULL,   NULL,        ARM_EXT_V5ExP, do_smla},

  {"smlawb", 0x01200080, NULL,   NULL,        ARM_EXT_V5ExP, do_smla},
  {"smlawt", 0x012000c0, NULL,   NULL,        ARM_EXT_V5ExP, do_smla},

  {"smlalbb",0x01400080, NULL,   NULL,        ARM_EXT_V5ExP, do_smlal},
  {"smlaltb",0x014000a0, NULL,   NULL,        ARM_EXT_V5ExP, do_smlal},
  {"smlalbt",0x014000c0, NULL,   NULL,        ARM_EXT_V5ExP, do_smlal},
  {"smlaltt",0x014000e0, NULL,   NULL,        ARM_EXT_V5ExP, do_smlal},

  {"smulbb", 0x01600080, NULL,   NULL,        ARM_EXT_V5ExP, do_smul},
  {"smultb", 0x016000a0, NULL,   NULL,        ARM_EXT_V5ExP, do_smul},
  {"smulbt", 0x016000c0, NULL,   NULL,        ARM_EXT_V5ExP, do_smul},
  {"smultt", 0x016000e0, NULL,   NULL,        ARM_EXT_V5ExP, do_smul},

  {"smulwb", 0x012000a0, NULL,   NULL,        ARM_EXT_V5ExP, do_smul},
  {"smulwt", 0x012000e0, NULL,   NULL,        ARM_EXT_V5ExP, do_smul},

  {"qadd",   0x01000050, NULL,   NULL,        ARM_EXT_V5ExP, do_qadd},
  {"qdadd",  0x01400050, NULL,   NULL,        ARM_EXT_V5ExP, do_qadd},
  {"qsub",   0x01200050, NULL,   NULL,        ARM_EXT_V5ExP, do_qadd},
  {"qdsub",  0x01600050, NULL,   NULL,        ARM_EXT_V5ExP, do_qadd},
d845 6
a850 5
  {"pld",   0xf450f000, "",     NULL,         ARM_EXT_V5E, do_pld},
  {"ldr",   0x000000d0, NULL,   ldr_flags,    ARM_EXT_V5E, do_ldrd},
  {"str",   0x000000f0, NULL,   str_flags,    ARM_EXT_V5E, do_ldrd},
  {"mcrr",  0x0c400000, NULL,   NULL,         ARM_EXT_V5E, do_co_reg2c},
  {"mrrc",  0x0c500000, NULL,   NULL,         ARM_EXT_V5E, do_co_reg2c},
d853 433
a1285 44
  {"wfs",   0x0e200110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fpa_ctrl},
  {"rfs",   0x0e300110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fpa_ctrl},
  {"wfc",   0x0e400110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fpa_ctrl},
  {"rfc",   0x0e500110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fpa_ctrl},
  {"ldf",   0x0c100100, "sdep", NULL,        FPU_FPA_EXT_V1,      do_fpa_ldst},
  {"stf",   0x0c000100, "sdep", NULL,        FPU_FPA_EXT_V1,      do_fpa_ldst},
  {"mvf",   0x0e008100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"mnf",   0x0e108100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"abs",   0x0e208100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"rnd",   0x0e308100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"sqt",   0x0e408100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"log",   0x0e508100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"lgn",   0x0e608100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"exp",   0x0e708100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"sin",   0x0e808100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"cos",   0x0e908100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"tan",   0x0ea08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"asn",   0x0eb08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"acs",   0x0ec08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"atn",   0x0ed08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"urd",   0x0ee08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"nrm",   0x0ef08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_monadic},
  {"adf",   0x0e000100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"suf",   0x0e200100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"rsf",   0x0e300100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"muf",   0x0e100100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"dvf",   0x0e400100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"rdf",   0x0e500100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"pow",   0x0e600100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"rpw",   0x0e700100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"rmf",   0x0e800100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"fml",   0x0e900100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"fdv",   0x0ea00100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"frd",   0x0eb00100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"pol",   0x0ec00100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_dyadic},
  {"cmf",   0x0e90f110, NULL,   except_flag, FPU_FPA_EXT_V1,      do_fpa_cmp},
  {"cnf",   0x0eb0f110, NULL,   except_flag, FPU_FPA_EXT_V1,      do_fpa_cmp},
  /* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should not
     be an optional suffix, but part of the instruction.  To be compatible,
     we accept either.  */
  {"cmfe",  0x0ed0f110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fpa_cmp},
  {"cnfe",  0x0ef0f110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fpa_cmp},
  {"flt",   0x0e000110, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fpa_from_reg},
  {"fix",   0x0e100110, NULL,   fix_flags,   FPU_FPA_EXT_V1,      do_fpa_to_reg},
d1288 6
a1293 2
  {"lfm",   0x0c100200, NULL,   lfm_flags,   FPU_FPA_EXT_V2, do_fpa_ldmstm},
  {"sfm",   0x0c000200, NULL,   sfm_flags,   FPU_FPA_EXT_V2, do_fpa_ldmstm},
d1296 8
a1303 8
  {"mia",   0x0e200010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miaph", 0x0e280010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miabb", 0x0e2c0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miabt", 0x0e2d0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miatb", 0x0e2e0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miatt", 0x0e2f0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"mar",   0x0c400000, NULL,   NULL,        ARM_EXT_XSCALE, do_mar},
  {"mra",   0x0c500000, NULL,   NULL,        ARM_EXT_XSCALE, do_mra},
d1306 76
a1381 76
  {"cfldrs",	0x0c100400,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_ldst_1},
  {"cfldrd",	0x0c500400,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_ldst_2},
  {"cfldr32",	0x0c100500,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_ldst_3},
  {"cfldr64",	0x0c500500,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_ldst_4},
  {"cfstrs",	0x0c000400,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_ldst_1},
  {"cfstrd",	0x0c400400,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_ldst_2},
  {"cfstr32",	0x0c000500,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_ldst_3},
  {"cfstr64",	0x0c400500,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_ldst_4},
  {"cfmvsr",	0x0e000450,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvrs",	0x0e100450,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmvdlr",	0x0e000410,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvrdl",	0x0e100410,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmvdhr",	0x0e000430,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvrdh",	0x0e100430,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmv64lr",	0x0e000510,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvr64l",	0x0e100510,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmv64hr",	0x0e000530,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_2},
  {"cfmvr64h",	0x0e100530,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfmval32",	0x0e100610,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv32al",	0x0e000610,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmvam32",	0x0e100630,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv32am",	0x0e000630,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmvah32",	0x0e100650,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv32ah",	0x0e000650,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv32a",	0x0e000670,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmva32",	0x0e100670,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmv64a",	0x0e000690,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmva64",	0x0e100690,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_3},
  {"cfmvsc32",	0x0e1006b0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_dspsc_1},
  {"cfmv32sc",	0x0e0006b0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_dspsc_2},
  {"cfcpys",	0x0e000400,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcpyd",	0x0e000420,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvtsd",	0x0e000460,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvtds",	0x0e000440,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvt32s",	0x0e000480,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvt32d",	0x0e0004a0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvt64s",	0x0e0004c0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvt64d",	0x0e0004e0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvts32",	0x0e100580,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfcvtd32",	0x0e1005a0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cftruncs32",0x0e1005c0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cftruncd32",0x0e1005e0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfrshl32",	0x0e000550,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_4},
  {"cfrshl64",	0x0e000570,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_4},
  {"cfsh32",	0x0e000500,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_shift_1},
  {"cfsh64",	0x0e200500,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_shift_2},
  {"cfcmps",	0x0e100490,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfcmpd",	0x0e1004b0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfcmp32",	0x0e100590,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfcmp64",	0x0e1005b0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfabss",	0x0e300400,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfabsd",	0x0e300420,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfnegs",	0x0e300440,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfnegd",	0x0e300460,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfadds",	0x0e300480,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfaddd",	0x0e3004a0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfsubs",	0x0e3004c0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfsubd",	0x0e3004e0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmuls",	0x0e100400,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmuld",	0x0e100420,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfabs32",	0x0e300500,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfabs64",	0x0e300520,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfneg32",	0x0e300540,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfneg64",	0x0e300560,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_binops_1},
  {"cfadd32",	0x0e300580,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfadd64",	0x0e3005a0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfsub32",	0x0e3005c0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfsub64",	0x0e3005e0,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmul32",	0x0e100500,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmul64",	0x0e100520,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmac32",	0x0e100540,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmsc32",	0x0e100560,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_triple_5},
  {"cfmadd32",	0x0e000600,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_quad_6},
  {"cfmsub32",	0x0e100600,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_quad_6},
  {"cfmadda32",	0x0e200600,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_quad_6},
  {"cfmsuba32",	0x0e300600,	NULL,	NULL,	ARM_EXT_MAVERICK, do_c_quad_6},
a1394 1
#define COND_MASK	0xf0000000
d1396 2
d1538 1
a1538 1
  unsigned long variants;
d2719 1
a2719 1
do_nop (str, flags)
d3106 1
a3106 1
	      if (ldst_extend (& str, 1) == FAIL)
d3133 1
a3133 1
	  if (ldst_extend (& str, 1) == FAIL)
d3956 1
a3956 1
  ++ str;
d3964 1
a3964 1
  if (* str == ']')
d3967 1
a3967 1
      ++ str;
d3970 2
a3971 1
      if (skip_past_comma (& str) == SUCCESS)
d3973 3
a3975 2
	  if (ldst_extend (& str, 0) == FAIL)
	    return;
d3977 1
a3977 1
      else if (* str == '!') /* [Rn]! */
d3980 1
a3980 1
	  ++ str;
d3993 1
a3993 1
      if (ldst_extend (& str, 0) == FAIL)
a4032 29
  if (flags != DOUBLE_LOAD_FLAG)
    {
      /* Change instruction pattern to normal ldr/str.  */
      if (inst.instruction & 0x20)
	inst.instruction = (inst.instruction & COND_MASK) | 0x04000000; /* str */
      else
	inst.instruction = (inst.instruction & COND_MASK) | 0x04100000; /* ldr */

      /* Perform a normal load/store instruction parse.  */
      do_ldst (str, flags);

      return;
    }

  if ((cpu_variant & ARM_EXT_XSCALE) != ARM_EXT_XSCALE)
    {
      static char buff[128];

      --str;
      while (ISSPACE (*str))
	--str;
      str -= 4;

      /* Deny all knowledge.  */
      sprintf (buff, _("bad instruction '%.100s'"), str);
      inst.error = buff;
      return;
    }

d4056 1
a4056 1
  if (rd == REG_LR || rd == 12)
d4063 2
a4064 3
      &&
      ((inst.instruction & WRITE_BACK)
       || (!(inst.instruction & PRE_INDEX))))
d4067 11
d4570 349
a4918 2
{
  skip_whitespace (str);
d4920 8
a4927 9
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d4930 1
a4930 1
  inst.instruction |= flags;
d4936 2
a4937 2
do_adr (str, flags)
     char * str;
d4940 2
d4944 1
a4944 3
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d4951 1
a4951 1
  if (flags & 0x00400000)
d4953 2
a4954 11
      /* This is a pseudo-op of the form "adrl rd, label" to be converted
	 into a relative address of the form:
	 add rd, pc, #low(label-.-8)"
	 add rd, rd, #high(label-.-8)"  */
      /* Frag hacking will turn this into a sub instruction if the offset turns
	 out to be negative.  */
      inst.reloc.type              = BFD_RELOC_ARM_ADRL_IMMEDIATE;
      inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
      inst.reloc.pc_rel            = 1;
      inst.instruction            |= flags & ~0x00400000;
      inst.size                    = INSN_SIZE * 2;
d4956 2
a4957 1
  else
d4959 3
a4961 9
      /* This is a pseudo-op of the form "adr rd, label" to be converted
	 into a relative address of the form "add rd, pc, #label-.-8".  */
      /* Frag hacking will turn this into a sub instruction if the offset turns
	 out to be negative.  */
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
      inst.reloc.pc_rel = 1;
      inst.instruction |= flags;
    }
d4963 1
a4963 2
  end_of_line (str);
}
d4965 2
a4966 6
static void
do_cmp (str, flags)
     char * str;
     unsigned long flags;
{
  skip_whitespace (str);
d4968 6
a4973 6
  if (reg_required_here (&str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d4975 1
a4975 7
  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d4977 3
a4979 3
  inst.instruction |= flags;
  if ((flags & 0x0000f000) == 0)
    inst.instruction |= CONDS_BIT;
d4981 10
a4990 3
  end_of_line (str);
  return;
}
d4992 3
a4994 6
static void
do_mov (str, flags)
     char * str;
     unsigned long flags;
{
  skip_whitespace (str);
d4996 8
a5003 5
  if (reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d5005 1
a5005 3

  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
d5007 1
a5007 2
      if (!inst.error)
	inst.error = BAD_ARGS;
a5010 1
  inst.instruction |= flags;
d5016 1
a5016 1
ldst_extend (str, hwse)
a5017 1
     int     hwse;
d5033 1
a5033 2
	  if ((hwse && (value < -255 || value > 255))
	      || (value < -4095 || value > 4095))
d5047 2
a5048 5
	  if (hwse)
	    inst.instruction |= (add | HWOFFSET_IMM
				 | ((value >> 4) << 8) | (value & 0xF));
	  else
	    inst.instruction |= add | value;
d5052 2
a5053 7
	  if (hwse)
	    {
	      inst.instruction |= HWOFFSET_IMM;
	      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	    }
	  else
	    inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d5070 1
a5070 9
      if (hwse)
	inst.instruction |= add;
      else
	{
	  inst.instruction |= add | OFFSET_REG;
	  if (skip_past_comma (str) == SUCCESS)
	    return decode_shift (str, SHIFT_RESTRICT);
	}

d5075 1
d5077 1
a5077 1
do_ldst (str, flags)
a5080 1
  int halfword = 0;
a5084 21
  /* This is not ideal, but it is the simplest way of dealing with the
     ARM7T halfword instructions (since they use a different
     encoding, but the same mnemonic):  */
  halfword = (flags & 0x80000000) != 0;
  if (halfword)
    {
      /* This is actually a load/store of a halfword, or a
         signed-extension load.  */
      if ((cpu_variant & ARM_EXT_V4) == 0)
	{
	  inst.error
	    = _("Processor does not support halfwords or signed bytes");
	  return;
	}

      inst.instruction = ((inst.instruction & COND_MASK)
			  | (flags & ~COND_MASK));

      flags = 0;
    }

d5123 1
a5123 1
	      if (ldst_extend (&str, halfword) == FAIL)
d5126 3
a5128 10
		{
		  if (flags & TRANS_BIT)
		    as_warn (_("Rn and Rd must be different in %s"),
			     ((inst.instruction & LOAD_BIT)
			      ? "LDRT" : "STRT"));
		  else
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		}
d5133 1
a5133 2
	      if (halfword)
		inst.instruction |= HWOFFSET_IMM;
d5147 2
a5148 10
	      flags |= INDEX_UP;
	      if (flags & TRANS_BIT)
		{
		  if (conflict_reg)
		    as_warn (_("Rn and Rd must be different in %s"),
			     ((inst.instruction & LOAD_BIT)
			      ? "LDRT" : "STRT"));
		}
		else
		  pre_inc = 1;
d5161 1
a5161 1
	  if (ldst_extend (&str, halfword) == FAIL)
d5187 1
d5212 1
a5212 1
	      inst.instruction |= (flags & COND_MASK) | (value & 0xfff);
d5224 1
a5224 1
	      inst.instruction |= (flags & COND_MASK) | (value & 0xfff);
d5239 2
a5240 8
      if (halfword)
	{
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_LITERAL;

d5250 2
a5251 7
      if (halfword)
	{
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d5261 1
a5261 4
  if (pre_inc && (flags & TRANS_BIT))
    inst.error = _("Pre-increment instruction with translate");

  inst.instruction |= flags | (pre_inc ? PRE_INDEX : 0);
d5416 1
a5416 1
      flags |= WRITE_BACK;
d5431 1
a5431 1
      flags |= LDM_TYPE_2_OR_3;
a5787 17
  switch (inst.suffix)
    {
    case SUFF_S:
      break;
    case SUFF_D:
      inst.instruction |= CP_T_X;
      break;
    case SUFF_E:
      inst.instruction |= CP_T_Y;
      break;
    case SUFF_P:
      inst.instruction |= CP_T_X | CP_T_Y;
      break;
    default:
      abort ();
    }

d5862 1
a5862 1
  if (flags)
d5909 1
a5909 1
      if (flags & CP_T_Pre)
d5914 1
a5914 1
	    flags |= CP_T_WB;
d5921 1
a5921 1
	      flags |= CP_T_WB;
d5928 1
a5928 1
	      flags = CP_T_Pre | CP_T_UD;
a5952 14
  switch (inst.suffix)
    {
    case SUFF_S:
      break;
    case SUFF_D:
      inst.instruction |= 0x00000080;
      break;
    case SUFF_E:
      inst.instruction |= 0x00080000;
      break;
    default:
      abort ();
    }

a5987 14
  switch (inst.suffix)
    {
    case SUFF_S:
      break;
    case SUFF_D:
      inst.instruction |= 0x00000080;
      break;
    case SUFF_E:
      inst.instruction |= 0x00080000;
      break;
    default:
      abort ();
    }

a6041 14
  switch (inst.suffix)
    {
    case SUFF_S:
      break;
    case SUFF_D:
      inst.instruction |= 0x00000080;
      break;
    case SUFF_E:
      inst.instruction |= 0x00080000;
      break;
    default:
      abort ();
    }

d7733 48
d7795 1
a7795 2
  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    hash_insert (arm_ops_hsh, insns[i].template, (PTR) (insns + i));
d8994 1
a8994 1
	  if (thumb_mode == 1 && (opcode->variants & cpu_variant) == 0)
a9009 1
      unsigned long cond_code;
d9011 4
a9014 6
      inst.size = INSN_SIZE;
      /* P now points to the end of the opcode, probably white space, but we
	 have to break the opcode up in case it contains condionals and flags;
	 keep trying with progressively smaller basic instructions until one
	 matches, or we run out of opcode.  */
      q = (p - str > LONGEST_INST) ? str + LONGEST_INST : p;
d9016 1
a9016 1
      for (; q != str; q--)
d9018 2
a9019 7
	  c = *q;
	  *q = '\0';

	  opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, str);
	  *q = c;

	  if (opcode && opcode->template)
d9021 1
a9021 126
	      unsigned long flag_bits = 0;
	      char * r;

	      /* Check that this instruction is supported for this CPU.  */
	      if ((opcode->variants & cpu_variant) == 0)
		goto try_shorter;

	      inst.instruction = opcode->value;
	      if (q == p)		/* Just a simple opcode.  */
		{
		  if (opcode->comp_suffix)
		    {
		      if (*opcode->comp_suffix != '\0')
			as_bad (_("Opcode `%s' must have suffix from list: <%s>"),
				str, opcode->comp_suffix);
		      else
			/* Not a conditional instruction.  */
			(*opcode->parms) (q, 0);
		    }
		  else
		    {
		      /* A conditional instruction with default condition.  */
		      inst.instruction |= COND_ALWAYS;
		      (*opcode->parms) (q, 0);
		    }
		  output_inst ();
		  return;
		}

	      /* Not just a simple opcode.  Check if extra is a
                 conditional.  */
	      r = q;
	      if (p - r >= 2)
		{
		  const struct asm_cond *cond;
		  char d = *(r + 2);

		  *(r + 2) = '\0';
		  cond = (const struct asm_cond *) hash_find (arm_cond_hsh, r);
		  *(r + 2) = d;
		  if (cond)
		    {
		      if (cond->value == 0xf0000000)
			as_tsktsk (
_("Warning: Use of the 'nv' conditional is deprecated\n"));

		      cond_code = cond->value;
		      r += 2;
		    }
		  else
		    cond_code = COND_ALWAYS;
		}
	      else
		cond_code = COND_ALWAYS;

	      /* Apply the conditional, or complain it's not allowed.  */
	      if (opcode->comp_suffix && *opcode->comp_suffix == '\0')
		{
		  /* Instruction isn't conditional.  */
		  if (cond_code != COND_ALWAYS)
		    {
		      as_bad (_("Opcode `%s' is unconditional\n"), str);
		      return;
		    }
		}
	      else
		/* Instruction is conditional: set the condition into it.  */
		inst.instruction |= cond_code;

	      /* If there is a compulsory suffix, it should come here
		 before any optional flags.  */
	      if (opcode->comp_suffix && *opcode->comp_suffix != '\0')
		{
		  const char *s = opcode->comp_suffix;

		  while (*s)
		    {
		      inst.suffix++;
		      if (*r == *s)
			break;
		      s++;
		    }

		  if (*s == '\0')
		    {
		      as_bad (_("Opcode `%s' must have suffix from <%s>\n"),
			      str, opcode->comp_suffix);
		      return;
		    }

		  r++;
		}

	      /* The remainder, if any should now be flags for the instruction;
		 Scan these checking each one found with the opcode.  */
	      if (r != p)
		{
		  char d;
		  const struct asm_flg *flag = opcode->flags;

		  if (flag)
		    {
		      int flagno;

		      d = *p;
		      *p = '\0';

		      for (flagno = 0; flag[flagno].template; flagno++)
			{
			  if (streq (r, flag[flagno].template))
			    {
			      flag_bits |= flag[flagno].set_bits;
			      break;
			    }
			}

		      *p = d;
		      if (! flag[flagno].template)
			goto try_shorter;
		    }
		  else
		    goto try_shorter;
		}

	      (*opcode->parms) (p, flag_bits);
	      output_inst ();
d9025 5
a9029 2
	try_shorter:
	  ;
@


1.102
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d8991 2
a8992 1
 		cpu_variant = ARM_9 | ARM_ARCH_XSCALE;
@


1.101
log
@* tc-arm.c: Re-arrange prototypes by architecture.
(insns): Re-arrange instructions by archtitecture.  Pld instruction
is part of ARMv5E.
(tinsns): blx and bkpt are part of ARMv5T.
(do_fp_{ctrl,ldst,ldstm,dyadic,monadic,cmp,from_reg,to_reg}): Rename
to do_fpa_*.  All callers changed.

* tc-arm.c (insns): Add two temporary instructions to handle
ldrd/strd.
@
text
@d7584 2
a7585 2
int
md_apply_fix3 (fixP, val, seg)
d7587 1
a7587 1
     valueT * val;
d7590 1
a7590 1
  offsetT        value = * val;
d7850 1
a7850 1
	      value = * val;
d8186 1
a8186 1
      return 1;
a8192 2

  return 1;
@


1.100
log
@General cleanup of feature definitions.
* tc-arm.c (ARM_EXT_LONGMUL, ARM_EXT_HALFWORD, ARM_EXT_THUMB): Delete.
(ARM_2UP, ARM_ALL, ARM_3UP, ARM_6UP): Delete.
(FPU_CORE, FPU_FPA10, FPA_FPA11, FPU_ALL, FPA_MEMMULTI): Delete.
(ARM_EXT_V{1,2,2S,3,3M,4,4T,5T,5ExP}): New defines.
(ARM_EXT_V{5,5E}): Synchronize with above.
(ARM_ARCH_V*): Define a complete set in terms of above features.
(ARM_{1,2,3,250,6,7,8,9,STRONG}): Define in terms of architecture.
(FPU_FPA_EXT_V[12]): Define.
(FPU_ARCH_FPE, FPU_ARCH_FPA): Define in terms of above.
(FPU_ANY): Define.
(FPU_DEFAULT): Default to FPA.
(CPU_DEFAULT): For XScale, this is now just ARM_ARCH_XSCALE; for
Thumb, this is now ARM_ARCH_V5T.
(insns): Rework for new feature defines.
(tinsns): Likewise.
(opcode_select, do_ldst, md_begin, md_parse_option): Likewise.
@
text
@d625 1
d629 2
a630 1
/* ARM 2.  */
d633 2
a634 1
/* ARM 3.  */
d636 2
a637 1
/* ARM 6.  */
d640 2
a641 1
/* ARM 7M.  */
d643 2
a644 1
/* ARM THUMB.  */
d647 1
a647 8
/* ARM_EXT_XScale.  */
static void do_mia		PARAMS ((char *, unsigned long));
static void do_mar		PARAMS ((char *, unsigned long));
static void do_mra		PARAMS ((char *, unsigned long));
static void do_pld		PARAMS ((char *, unsigned long));
static void do_ldrd		PARAMS ((char *, unsigned long));

/* ARM_EXT_V5.  */
d655 1
a655 4
static void do_t_blx		PARAMS ((char *));
static void do_t_bkpt		PARAMS ((char *));

/* ARM_EXT_V5E.  */
d660 4
d670 15
a684 8
static void do_fp_ctrl		PARAMS ((char *, unsigned long));
static void do_fp_ldst		PARAMS ((char *, unsigned long));
static void do_fp_ldmstm	PARAMS ((char *, unsigned long));
static void do_fp_dyadic	PARAMS ((char *, unsigned long));
static void do_fp_monadic	PARAMS ((char *, unsigned long));
static void do_fp_cmp		PARAMS ((char *, unsigned long));
static void do_fp_from_reg	PARAMS ((char *, unsigned long));
static void do_fp_to_reg	PARAMS ((char *, unsigned long));
d806 1
a806 10
/* Intel XScale extensions to ARM V5 ISA.  */
  {"mia",   0x0e200010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miaph", 0x0e280010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miabb", 0x0e2c0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miabt", 0x0e2d0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miatb", 0x0e2e0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miatt", 0x0e2f0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"mar",   0x0c400000, NULL,   NULL,        ARM_EXT_XSCALE, do_mar},
  {"mra",   0x0c500000, NULL,   NULL,        ARM_EXT_XSCALE, do_mra},
  {"pld",   0xf450f000, "",     NULL,        ARM_EXT_XSCALE, do_pld},
d810 1
a810 1
/* ARM Instructions.  */
d833 1
d841 1
a841 1
/* Pseudo ops.  */
d845 1
a845 1
/* ARM 2 multiplies.  */
d849 8
a856 1
/* ARM 3 - swp instructions.  */
d859 1
a859 1
/* ARM 6 Coprocessor instructions.  */
d862 3
a864 3
/* ScottB: our code uses 0x0128f000 for msr.
   NickC:  but this is wrong because the bits 16 through 19 are
           handled by the PSR_xxx defines above.  */
d866 1
a866 1
/* ARM 7M long multiplies - need signed/unsigned flags!  */
d872 1
a872 1
/* ARM THUMB interworking.  */
d877 3
a879 58
/* Floating point instructions.  */
  {"wfs",   0x0e200110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fp_ctrl},
  {"rfs",   0x0e300110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fp_ctrl},
  {"wfc",   0x0e400110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fp_ctrl},
  {"rfc",   0x0e500110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fp_ctrl},
  {"ldf",   0x0c100100, "sdep", NULL,        FPU_FPA_EXT_V1,      do_fp_ldst},
  {"stf",   0x0c000100, "sdep", NULL,        FPU_FPA_EXT_V1,      do_fp_ldst},
  {"lfm",   0x0c100200, NULL,   lfm_flags,   FPU_FPA_EXT_V2, do_fp_ldmstm},
  {"sfm",   0x0c000200, NULL,   sfm_flags,   FPU_FPA_EXT_V2, do_fp_ldmstm},
  {"mvf",   0x0e008100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"mnf",   0x0e108100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"abs",   0x0e208100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"rnd",   0x0e308100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"sqt",   0x0e408100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"log",   0x0e508100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"lgn",   0x0e608100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"exp",   0x0e708100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"sin",   0x0e808100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"cos",   0x0e908100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"tan",   0x0ea08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"asn",   0x0eb08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"acs",   0x0ec08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"atn",   0x0ed08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"urd",   0x0ee08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"nrm",   0x0ef08100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_monadic},
  {"adf",   0x0e000100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"suf",   0x0e200100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"rsf",   0x0e300100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"muf",   0x0e100100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"dvf",   0x0e400100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"rdf",   0x0e500100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"pow",   0x0e600100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"rpw",   0x0e700100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"rmf",   0x0e800100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"fml",   0x0e900100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"fdv",   0x0ea00100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"frd",   0x0eb00100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"pol",   0x0ec00100, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_dyadic},
  {"cmf",   0x0e90f110, NULL,   except_flag, FPU_FPA_EXT_V1,      do_fp_cmp},
  {"cnf",   0x0eb0f110, NULL,   except_flag, FPU_FPA_EXT_V1,      do_fp_cmp},
/* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should not
   be an optional suffix, but part of the instruction.  To be compatible,
   we accept either.  */
  {"cmfe",  0x0ed0f110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fp_cmp},
  {"cnfe",  0x0ef0f110, NULL,   NULL,        FPU_FPA_EXT_V1,      do_fp_cmp},
  {"flt",   0x0e000110, "sde",  round_flags, FPU_FPA_EXT_V1,      do_fp_from_reg},
  {"fix",   0x0e100110, NULL,   fix_flags,   FPU_FPA_EXT_V1,      do_fp_to_reg},

/* Generic copressor instructions.  */
  {"cdp",   0x0e000000, NULL,  NULL,         ARM_EXT_V2,      do_cdp},
  {"ldc",   0x0c100000, NULL,  long_flag,    ARM_EXT_V2,      do_lstc},
  {"stc",   0x0c000000, NULL,  long_flag,    ARM_EXT_V2,      do_lstc},
  {"mcr",   0x0e000010, NULL,  NULL,         ARM_EXT_V2,      do_co_reg},
  {"mrc",   0x0e100010, NULL,  NULL,         ARM_EXT_V2,      do_co_reg},

/*  ARM ISA extension 5.  */
/* Note: blx is actually 2 opcodes, so the .value is set dynamically.
   And it's sometimes conditional and sometimes not.  */
d889 31
a919 27
/*  ARM ISA extension 5E, El Segundo.  */
  {"smlabb", 0x01000080, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlatb", 0x010000a0, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlabt", 0x010000c0, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlatt", 0x010000e0, NULL,   NULL,        ARM_EXT_V5E, do_smla},

  {"smlawb", 0x01200080, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlawt", 0x012000c0, NULL,   NULL,        ARM_EXT_V5E, do_smla},

  {"smlalbb",0x01400080, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlaltb",0x014000a0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlalbt",0x014000c0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlaltt",0x014000e0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},

  {"smulbb", 0x01600080, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smultb", 0x016000a0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smulbt", 0x016000c0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smultt", 0x016000e0, NULL,   NULL,        ARM_EXT_V5E, do_smul},

  {"smulwb", 0x012000a0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smulwt", 0x012000e0, NULL,   NULL,        ARM_EXT_V5E, do_smul},

  {"qadd",   0x01000050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qdadd",  0x01400050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qsub",   0x01200050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qdsub",  0x01600050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},

d923 60
d1095 1
d1121 4
d1223 1
a1248 2
  {"blx",	0,		0,	ARM_EXT_V5, do_t_blx},
  {"bkpt",	0xbe00,		2,	ARM_EXT_V5, do_t_bkpt},
d1282 3
d1307 2
a1309 2
#define REG_LR  14
#define REG_SP  13
d3606 1
a3606 1
/* Xscale: Preload-Cache
d3694 1
a3694 1
/* Xscale load-consecutive (argument parse)
d5199 1
a5199 1
do_fp_ctrl (str, flags)
d5220 1
a5220 1
do_fp_ldst (str, flags)
d5262 1
a5262 1
do_fp_ldmstm (str, flags)
d5402 1
a5402 1
do_fp_dyadic (str, flags)
d5451 1
a5451 1
do_fp_monadic (str, flags)
d5492 1
a5492 1
do_fp_cmp (str, flags)
d5519 1
a5519 1
do_fp_from_reg (str, flags)
d5560 1
a5560 1
do_fp_to_reg (str, flags)
@


1.99
log
@2001-10-20  H.J. Lu  <hjl@@gnu.org>

	* config/tc-arm.c (do_c_shift): Use ISDIGIT instead of isdigit.
	(cirrus_parse_offset): Likewise.
@
text
@d42 38
a79 28
/* Types of processor to assemble for.  */
#define ARM_1		0x00000001
#define ARM_2		0x00000002
#define ARM_3		0x00000004
#define ARM_250		ARM_3
#define ARM_6		0x00000008
#define ARM_7		ARM_6           /* Same core instruction set.  */
#define ARM_8		ARM_6           /* Same core instruction set.  */
#define ARM_9		ARM_6           /* Same core instruction set.  */
#define ARM_CPU_MASK	0x0000000f

/* The following bitmasks control CPU extensions (ARM7 onwards):   */
#define ARM_EXT_LONGMUL	0x00000010	/* Allow long multiplies.  */
#define ARM_EXT_HALFWORD 0x00000020	/* Allow half word loads.  */
#define ARM_EXT_THUMB	0x00000040	/* Allow BX instruction.   */
#define ARM_EXT_V5	0x00000080	/* Allow CLZ, etc.         */
#define ARM_EXT_V5E	0x00000100	/* "El Segundo". 	   */
#define ARM_EXT_XSCALE	0x00000200	/* Allow MIA etc.  	   */
#define ARM_EXT_MAVERICK 0x00000400      /* Use Cirrus/DSP coprocessor.  */

/* Architectures are the sum of the base and extensions.  */
#define ARM_ARCH_V3M     ARM_EXT_LONGMUL
#define ARM_ARCH_V4     (ARM_ARCH_V3M | ARM_EXT_HALFWORD)
#define ARM_ARCH_V4T	(ARM_ARCH_V4 | ARM_EXT_THUMB)
#define ARM_ARCH_V5	(ARM_ARCH_V4 | ARM_EXT_V5)
#define ARM_ARCH_V5T	(ARM_ARCH_V5 | ARM_EXT_THUMB)
#define ARM_ARCH_V5TE	(ARM_ARCH_V5T | ARM_EXT_V5E)
#define ARM_ARCH_XSCALE (ARM_ARCH_V5TE | ARM_EXT_XSCALE)
d84 4
a87 7
#define ARM_ALL		ARM_2UP		/* Not arm1 only.  */
#define ARM_3UP		0x00fffffc
#define ARM_6UP		0x00fffff8      /* Includes ARM7.  */

#define FPU_CORE	0x80000000
#define FPU_FPA10	0x40000000
#define FPU_FPA11	0x40000000
d90 3
d94 13
a106 2
#define FPU_ALL		0xff000000	/* Note this is ~ARM_ANY.  */
#define FPU_MEMMULTI	0x7f000000	/* Not fpu_core.  */
d110 1
a110 1
#define CPU_DEFAULT	(ARM_9 | ARM_ARCH_XSCALE)
d113 1
a113 1
#define CPU_DEFAULT 	(ARM_7 | ARM_ARCH_V4T)
d121 1
a121 1
#define FPU_DEFAULT FPU_ALL
d809 2
a810 2
  {"ldr",   0x000000d0, NULL,   ldr_flags,   ARM_ANY,        do_ldrd},
  {"str",   0x000000f0, NULL,   str_flags,   ARM_ANY,        do_ldrd},
d813 21
a833 21
  {"and",   0x00000000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"eor",   0x00200000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"sub",   0x00400000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"rsb",   0x00600000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"add",   0x00800000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"adc",   0x00a00000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"sbc",   0x00c00000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"rsc",   0x00e00000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"orr",   0x01800000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"bic",   0x01c00000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"tst",   0x01000000, NULL,   cmp_flags,   ARM_ANY,      do_cmp},
  {"teq",   0x01200000, NULL,   cmp_flags,   ARM_ANY,      do_cmp},
  {"cmp",   0x01400000, NULL,   cmp_flags,   ARM_ANY,      do_cmp},
  {"cmn",   0x01600000, NULL,   cmp_flags,   ARM_ANY,      do_cmp},
  {"mov",   0x01a00000, NULL,   s_flag,      ARM_ANY,      do_mov},
  {"mvn",   0x01e00000, NULL,   s_flag,      ARM_ANY,      do_mov},
  {"str",   0x04000000, NULL,   str_flags,   ARM_ANY,      do_ldst},
  {"ldr",   0x04100000, NULL,   ldr_flags,   ARM_ANY,      do_ldst},
  {"stm",   0x08000000, NULL,   stm_flags,   ARM_ANY,      do_ldmstm},
  {"ldm",   0x08100000, NULL,   ldm_flags,   ARM_ANY,      do_ldmstm},
  {"swi",   0x0f000000, NULL,   NULL,        ARM_ANY,      do_swi},
d835 2
a836 2
  {"bl",    0x0b000000, NULL,   NULL,        ARM_ANY,      do_branch},
  {"b",     0x0a000000, NULL,   NULL,        ARM_ANY,      do_branch},
d838 2
a839 2
  {"bl",    0x0bfffffe, NULL,   NULL,        ARM_ANY,      do_branch},
  {"b",     0x0afffffe, NULL,   NULL,        ARM_ANY,      do_branch},
d843 2
a844 2
  {"adr",   0x028f0000, NULL,   long_flag,   ARM_ANY,      do_adr},
  {"nop",   0x01a00000, NULL,   NULL,        ARM_ANY,      do_nop},
d847 2
a848 2
  {"mul",   0x00000090, NULL,   s_flag,      ARM_2UP,      do_mul},
  {"mla",   0x00200090, NULL,   s_flag,      ARM_2UP,      do_mla},
d851 1
a851 1
  {"swp",   0x01000090, NULL,   byte_flag,   ARM_3UP,      do_swap},
d854 2
a855 2
  {"mrs",   0x010f0000, NULL,   NULL,        ARM_6UP,      do_mrs},
  {"msr",   0x0120f000, NULL,   NULL,        ARM_6UP,      do_msr},
d861 4
a864 4
  {"smull", 0x00c00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"umull", 0x00800090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"smlal", 0x00e00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"umlal", 0x00a00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
d867 3
a869 1
  {"bx",    0x012fff10, NULL,   NULL,        ARM_EXT_THUMB,    do_bx},
d872 39
a910 39
  {"wfs",   0x0e200110, NULL,   NULL,        FPU_ALL,      do_fp_ctrl},
  {"rfs",   0x0e300110, NULL,   NULL,        FPU_ALL,      do_fp_ctrl},
  {"wfc",   0x0e400110, NULL,   NULL,        FPU_ALL,      do_fp_ctrl},
  {"rfc",   0x0e500110, NULL,   NULL,        FPU_ALL,      do_fp_ctrl},
  {"ldf",   0x0c100100, "sdep", NULL,        FPU_ALL,      do_fp_ldst},
  {"stf",   0x0c000100, "sdep", NULL,        FPU_ALL,      do_fp_ldst},
  {"lfm",   0x0c100200, NULL,   lfm_flags,   FPU_MEMMULTI, do_fp_ldmstm},
  {"sfm",   0x0c000200, NULL,   sfm_flags,   FPU_MEMMULTI, do_fp_ldmstm},
  {"mvf",   0x0e008100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"mnf",   0x0e108100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"abs",   0x0e208100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"rnd",   0x0e308100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"sqt",   0x0e408100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"log",   0x0e508100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"lgn",   0x0e608100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"exp",   0x0e708100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"sin",   0x0e808100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"cos",   0x0e908100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"tan",   0x0ea08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"asn",   0x0eb08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"acs",   0x0ec08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"atn",   0x0ed08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"urd",   0x0ee08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"nrm",   0x0ef08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"adf",   0x0e000100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"suf",   0x0e200100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"rsf",   0x0e300100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"muf",   0x0e100100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"dvf",   0x0e400100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"rdf",   0x0e500100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"pow",   0x0e600100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"rpw",   0x0e700100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"rmf",   0x0e800100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"fml",   0x0e900100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"fdv",   0x0ea00100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"frd",   0x0eb00100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"pol",   0x0ec00100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"cmf",   0x0e90f110, NULL,   except_flag, FPU_ALL,      do_fp_cmp},
  {"cnf",   0x0eb0f110, NULL,   except_flag, FPU_ALL,      do_fp_cmp},
d914 4
a917 4
  {"cmfe",  0x0ed0f110, NULL,   NULL,        FPU_ALL,      do_fp_cmp},
  {"cnfe",  0x0ef0f110, NULL,   NULL,        FPU_ALL,      do_fp_cmp},
  {"flt",   0x0e000110, "sde",  round_flags, FPU_ALL,      do_fp_from_reg},
  {"fix",   0x0e100110, NULL,   fix_flags,   FPU_ALL,      do_fp_to_reg},
d920 5
a924 5
  {"cdp",   0x0e000000, NULL,  NULL,         ARM_2UP,      do_cdp},
  {"ldc",   0x0c100000, NULL,  long_flag,    ARM_2UP,      do_lstc},
  {"stc",   0x0c000000, NULL,  long_flag,    ARM_2UP,      do_lstc},
  {"mcr",   0x0e000010, NULL,  NULL,         ARM_2UP,      do_co_reg},
  {"mrc",   0x0e100010, NULL,  NULL,         ARM_2UP,      do_co_reg},
d1203 25
a1227 25
  {"adc",	0x4140,		2,	ARM_EXT_THUMB, do_t_arit},
  {"add",	0x0000,		2,	ARM_EXT_THUMB, do_t_add},
  {"and",	0x4000,		2,	ARM_EXT_THUMB, do_t_arit},
  {"asr",	0x0000,		2,	ARM_EXT_THUMB, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_EXT_THUMB, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_EXT_THUMB, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_EXT_THUMB, do_t_branch23},
d1230 30
a1259 30
  {"bx",	0x4700,		2,	ARM_EXT_THUMB, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_EXT_THUMB, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_EXT_THUMB, do_t_compare},
  {"eor",	0x4040,		2,	ARM_EXT_THUMB, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_EXT_THUMB, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_EXT_THUMB, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_EXT_THUMB, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_EXT_THUMB, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_EXT_THUMB, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_EXT_THUMB, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_EXT_THUMB, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_EXT_THUMB, do_t_arit},
  {"orr",	0x4300,		2,	ARM_EXT_THUMB, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_EXT_THUMB, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_EXT_THUMB, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_EXT_THUMB, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_EXT_THUMB, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_EXT_THUMB, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_EXT_THUMB, do_t_str},
  {"strb",	0x0000,		2,	ARM_EXT_THUMB, do_t_strb},
  {"strh",	0x0000,		2,	ARM_EXT_THUMB, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_EXT_THUMB, do_t_swi},
  {"sub",	0x0000,		2,	ARM_EXT_THUMB, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_EXT_THUMB, do_t_arit},
d1261 2
a1262 2
  {"adr",       0x0000,         2,      ARM_EXT_THUMB, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_EXT_THUMB, do_t_nop},      /* mov r8,r8  */
d1912 1
a1912 1
	  if (! (cpu_variant & ARM_EXT_THUMB))
d1925 1
a1925 1
	  if ((cpu_variant & ARM_ANY) == ARM_EXT_THUMB)
d4459 1
a4459 1
      if ((cpu_variant & ARM_EXT_HALFWORD) == 0)
d7247 1
a7247 1
    if ((cpu_variant & FPU_ALL) == FPU_NONE) flags |= F_SOFT_FLOAT;
d7282 4
a7286 1
    case ARM_6 | ARM_3 | ARM_2:	/* Actually no CPU type defined.  */
a7289 3
    case ARM_7: 		/* Also ARM_6.  */
      mach = bfd_mach_arm_3;
      break;
d7299 1
a7299 1
      if (cpu_variant & ARM_EXT_THUMB)
d7304 1
a7304 1
  else if (cpu_variant & ARM_EXT_HALFWORD)
d7306 1
a7306 1
      if (cpu_variant & ARM_EXT_THUMB)
d7311 1
a7311 1
  else if (cpu_variant & ARM_EXT_LONGMUL)
d8733 2
a8734 4
	  if (streq (str, "fpa10"))
	    cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_FPA10;
	  else if (streq (str, "fpa11"))
	    cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_FPA11;
d8736 1
a8736 1
	    cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_CORE;
d8743 1
a8743 1
	    cpu_variant &= ~FPU_ALL;
d8757 2
a8758 2
	      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_EXT_THUMB;
	      cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_NONE;
d8763 1
a8763 1
	      if ((cpu_variant & ARM_EXT_THUMB) == 0)
d8776 1
a8776 1
	      cpu_variant = ARM_ALL | FPU_ALL;
d8910 1
a8910 1
		      cpu_variant |= ARM_EXT_LONGMUL;
d9001 1
a9001 1
		    case 'm': cpu_variant |= ARM_EXT_LONGMUL; break;
d9014 1
a9014 1
		    case 't': cpu_variant |= ARM_EXT_THUMB; break;
d9026 1
a9026 1
		    case 't': cpu_variant |= ARM_EXT_THUMB; break;
@


1.98
log
@Restore line_comment_chars after a SNAFU.
@
text
@d6560 1
a6560 1
  if (!isdigit (*str) && *str != '-')
d6572 1
a6572 1
  for (imm = 0; *str && isdigit (*str); ++str)
d6622 1
a6622 1
  if (!isdigit (*p))
d6628 1
a6628 1
  for (offset = 0; *p && isdigit (*p); ++p)
@


1.97
log
@Remove semicolon from ARM comment chars list
@
text
@d131 1
a131 1
const char line_separator_chars[] = "|";
@


1.96
log
@Replace CONST with const
@
text
@d120 1
a120 1
const char comment_chars[] = "@@;";
@


1.95
log
@	* config/tc-arm.c: Change MAVERIK to MAVERICK.
@
text
@d120 1
a120 1
CONST char comment_chars[] = "@@";
d129 1
a129 1
CONST char line_comment_chars[] = "#";
d131 1
a131 1
CONST char line_separator_chars[] = ";";
d135 1
a135 1
CONST char EXP_CHARS[] = "eE";
d141 1
a141 1
CONST char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d153 1
a153 1
CONST int md_reloc_size = 8;
d168 1
a168 1
  CONST char *  error;
d235 1
a235 1
CONST char * fp_const[] =
d267 1
a267 1
  CONST char *  template;
d274 1
a274 1
static CONST struct asm_cond conds[] =
d299 1
a299 1
  CONST char *  template;	/* Basic flag string.  */
d303 1
a303 1
static CONST struct asm_flg s_flag[] =
d309 1
a309 1
static CONST struct asm_flg ldr_flags[] =
d321 1
a321 1
static CONST struct asm_flg str_flags[] =
d331 1
a331 1
static CONST struct asm_flg byte_flag[] =
d337 1
a337 1
static CONST struct asm_flg cmp_flags[] =
d344 1
a344 1
static CONST struct asm_flg ldm_flags[] =
d357 1
a357 1
static CONST struct asm_flg stm_flags[] =
d370 1
a370 1
static CONST struct asm_flg lfm_flags[] =
d377 1
a377 1
static CONST struct asm_flg sfm_flags[] =
d384 1
a384 1
static CONST struct asm_flg round_flags[] =
d396 1
a396 1
static CONST struct asm_flg fix_flags[] =
d413 1
a413 1
static CONST struct asm_flg except_flag[] =
d419 1
a419 1
static CONST struct asm_flg long_flag[] =
d427 1
a427 1
  CONST char *  template;
d443 1
a443 1
static CONST struct asm_psr psrs[] =
d685 2
a686 2
static CONST struct asm_psr * arm_psr_parse PARAMS ((char **));
static void symbol_locate	PARAMS ((symbolS *, CONST char *, segT, valueT, fragS *));
d757 1
a757 1
  CONST char * template;
d764 1
a764 1
  CONST char * comp_suffix;
d767 1
a767 1
  CONST struct asm_flg * flags;
d776 1
a776 1
static CONST struct asm_opcode insns[] =
d1164 1
a1164 1
  CONST char * template;
d1178 1
a1178 1
static CONST struct thumb_opcode tinsns[] =
d1244 1
a1244 1
  CONST char * name;
d1267 1
a1267 1
static CONST struct reg_entry reg_table[] =
d1360 1
a1360 1
CONST pseudo_typeS md_pseudo_table[] =
d1486 1
a1486 1
     CONST char * name;		/* It is copied, the caller can modify.  */
d2017 1
a2017 1
static CONST struct asm_psr *
d2024 1
a2024 1
  CONST struct asm_psr * psr;
d2046 1
a2046 1
  psr = (CONST struct asm_psr *) hash_find (arm_psr_hsh, start);
d2065 1
a2065 1
  CONST struct asm_psr * psr;
d8391 1
a8391 1
      CONST struct thumb_opcode * opcode;
d8395 1
a8395 1
      opcode = (CONST struct thumb_opcode *) hash_find (arm_tops_hsh, str);
d8416 1
a8416 1
      CONST struct asm_opcode * opcode;
d8431 1
a8431 1
	  opcode = (CONST struct asm_opcode *) hash_find (arm_ops_hsh, str);
d8470 1
a8470 1
		  CONST struct asm_cond *cond;
d8474 1
a8474 1
		  cond = (CONST struct asm_cond *) hash_find (arm_cond_hsh, r);
d8509 1
a8509 1
		  CONST char *s = opcode->comp_suffix;
d8534 1
a8534 1
		  CONST struct asm_flg *flag = opcode->flags;
d8669 1
a8669 1
CONST char * md_shortopts = "m:k";
@


1.94
log
@updated credits
@
text
@d60 1
a60 1
#define ARM_EXT_MAVERIK 0x00000400      /* Use Cirrus/DSP coprocessor.  */
d658 1
a658 1
/* ARM_EXT_MAVERIK.  */
d946 76
a1021 76
  {"cfldrs",	0x0c100400,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_ldst_1},
  {"cfldrd",	0x0c500400,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_ldst_2},
  {"cfldr32",	0x0c100500,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_ldst_3},
  {"cfldr64",	0x0c500500,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_ldst_4},
  {"cfstrs",	0x0c000400,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_ldst_1},
  {"cfstrd",	0x0c400400,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_ldst_2},
  {"cfstr32",	0x0c000500,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_ldst_3},
  {"cfstr64",	0x0c400500,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_ldst_4},
  {"cfmvsr",	0x0e000450,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_2},
  {"cfmvrs",	0x0e100450,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfmvdlr",	0x0e000410,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_2},
  {"cfmvrdl",	0x0e100410,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfmvdhr",	0x0e000430,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_2},
  {"cfmvrdh",	0x0e100430,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfmv64lr",	0x0e000510,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_2},
  {"cfmvr64l",	0x0e100510,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfmv64hr",	0x0e000530,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_2},
  {"cfmvr64h",	0x0e100530,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfmval32",	0x0e100610,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmv32al",	0x0e000610,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmvam32",	0x0e100630,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmv32am",	0x0e000630,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmvah32",	0x0e100650,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmv32ah",	0x0e000650,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmv32a",	0x0e000670,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmva32",	0x0e100670,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmv64a",	0x0e000690,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmva64",	0x0e100690,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_3},
  {"cfmvsc32",	0x0e1006b0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_dspsc_1},
  {"cfmv32sc",	0x0e0006b0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_dspsc_2},
  {"cfcpys",	0x0e000400,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcpyd",	0x0e000420,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcvtsd",	0x0e000460,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcvtds",	0x0e000440,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcvt32s",	0x0e000480,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcvt32d",	0x0e0004a0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcvt64s",	0x0e0004c0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcvt64d",	0x0e0004e0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcvts32",	0x0e100580,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfcvtd32",	0x0e1005a0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cftruncs32",0x0e1005c0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cftruncd32",0x0e1005e0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfrshl32",	0x0e000550,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_4},
  {"cfrshl64",	0x0e000570,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_4},
  {"cfsh32",	0x0e000500,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_shift_1},
  {"cfsh64",	0x0e200500,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_shift_2},
  {"cfcmps",	0x0e100490,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfcmpd",	0x0e1004b0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfcmp32",	0x0e100590,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfcmp64",	0x0e1005b0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfabss",	0x0e300400,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfabsd",	0x0e300420,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfnegs",	0x0e300440,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfnegd",	0x0e300460,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfadds",	0x0e300480,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfaddd",	0x0e3004a0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfsubs",	0x0e3004c0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfsubd",	0x0e3004e0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfmuls",	0x0e100400,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfmuld",	0x0e100420,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfabs32",	0x0e300500,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfabs64",	0x0e300520,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfneg32",	0x0e300540,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfneg64",	0x0e300560,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_binops_1},
  {"cfadd32",	0x0e300580,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfadd64",	0x0e3005a0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfsub32",	0x0e3005c0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfsub64",	0x0e3005e0,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfmul32",	0x0e100500,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfmul64",	0x0e100520,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfmac32",	0x0e100540,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfmsc32",	0x0e100560,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_triple_5},
  {"cfmadd32",	0x0e000600,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_quad_6},
  {"cfmsub32",	0x0e100600,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_quad_6},
  {"cfmadda32",	0x0e200600,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_quad_6},
  {"cfmsuba32",	0x0e300600,	NULL,	NULL,	ARM_EXT_MAVERIK, do_c_quad_6},
d1252 1
a1252 1
#define ARM_EXT_MAVERIKSC_REG	134
d1260 1
a1260 1
#define ARM_EXT_MAVERIKsc_register(reg) 	((reg) == ARM_EXT_MAVERIKSC_REG)
d1315 1
a1315 1
  {"dspsc", ARM_EXT_MAVERIKSC_REG},
d6177 1
a6177 1
      return ARM_EXT_MAVERIKsc_register (reg);
d6218 1
a6218 1
	  && !ARM_EXT_MAVERIKsc_register (reg)) /* Leave this one as is.  */
d8933 1
a8933 1
		  | ARM_9 | ARM_ARCH_V4T | ARM_EXT_MAVERIK;
@


1.93
log
@	* gas/config/tc-arm.c (ARM_EXT_MAVERIK): New macro.
	(cirrus_regtype): New enum.
	(LONGEST_INST): Change to 10.
	(CIRRUS_MODE1): New.
	(CIRRUS_MODE2): New.
	(CIRRUS_MODE3): New.
	(CIRRUS_MODE4): New.
	(CIRRUS_MODE5): New.
	(CIRRUS_MODE6): New.
	(insns): Add cirrus dsp instructions.
	(ARM_EXT_MAVERIKSC_REG): New.
	(cirrus_register): New.
	(cirrus_mvf_register): New.
	(cirrus_mvd_register): New.
	(cirrus_mvfx_register): New.
	(cirrus_mvdx_register): New.
	(cirrus_mvax_register): New.
	(ARM_EXT_MAVERIKsc_register): New.
	(reg_table): Add cirrus registers.
	(cirrus_valid_reg): New.
	(cirrus_reg_required_here): New.
	(do_c_binops_1): New.
	(do_c_binops_2): New.
	(do_c_binops_3): New.
	(do_c_triple_4): New.
	(do_c_triple_5): New.
	(do_c_quad_6): New.
	(do_c_dspsc_1): New.
	(do_c_dspsc_2): New.
	(do_c_shift_1): New.
	(do_c_shift_2): New.
	(do_c_ldst_1): New.
	(do_c_ldst_2): New.
	(do_c_ldst_3): New.
	(do_c_ldst_4): New.
	(do_c_binops): New.
	(do_c_triple): New.
	(do_c_quad): New.
	(do_c_dspsc): New.
	(do_c_shift): New.
	(cirrus_parse_offset): New.
	(do_c_ldst): New.
	(md_parse_option): Add arm9e.
	(md_show_usage): Same.
@
text
@d6 1
@


1.92
log
@Add missing function protoypes.
@
text
@d59 1
d583 11
d657 25
d733 19
a751 1
#define LONGEST_INST 7
d943 78
d1251 10
d1296 19
d6147 575
d8647 1
d8930 3
d9048 1
@


1.91
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a592 1
static void do_adrl		PARAMS ((char *, unsigned long));
d681 4
@


1.90
log
@Use MVN to build simple inverted constants.
@
text
@a23 1
#include <ctype.h>
d27 1
d1867 1
a1867 1
  while (isalpha (c) || c == '_');
d2520 1
a2520 1
  while (isalnum (c))
d3516 1
a3516 1
      while (isspace (*str))
d3713 1
a3713 1
  for (p = * str; isalpha (* p); p ++)
d6410 1
a6410 1
    buf2[i] = islower (buf[i]) ? toupper (buf[i]) : buf[i];
d6778 1
a6778 1
  if (!isalpha (*p) || !is_name_beginner (*p))
d6782 1
a6782 1
  while (isalpha (c) || isdigit (c) || c == '_')
d8727 1
a8727 1
       i < sizeof (id) && (isalnum (*ip) || ispunct (*ip));
d8729 1
a8729 1
    id[i] = tolower (*ip);
@


1.89
log
@Allow adrCCl.  [Patch from Phillip BLundel]
Updated ARM tests.
@
text
@d4416 1
a4416 2
      if (inst.reloc.exp.X_op == O_constant
	  && (value = validate_immediate (inst.reloc.exp.X_add_number)) != FAIL)
d4418 3
a4420 11
	  /* This can be done with a mov instruction.  */
	  inst.instruction &= LITERAL_MASK;
	  inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	  inst.instruction |= (flags & COND_MASK) | (value & 0xfff);
	  end_of_line (str);
	  return;
	}
      else
	{
	  /* Insert into literal pool.  */
	  if (add_to_lit_pool () == FAIL)
d4422 5
a4426 2
	      if (!inst.error)
		inst.error = _("literal pool insertion failed");
d4429 2
d4432 1
a4432 2
	  /* Change the instruction exp to point to the pool.  */
	  if (halfword)
d4434 6
a4439 2
	      inst.instruction |= HWOFFSET_IMM;
	      inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
a4440 5
	  else
	    inst.reloc.type = BFD_RELOC_ARM_LITERAL;
	  inst.reloc.pc_rel = 1;
	  inst.instruction |= (REG_PC << 16);
	  pre_inc = 1;
d4442 21
@


1.88
log
@Restore file accidentally deleted during man page cleanup
@
text
@d417 1
a417 1
static CONST struct asm_flg cplong_flag[] =
d763 1
a763 2
  {"adr",   0x028f0000, NULL,   NULL,        ARM_ANY,      do_adr},
  {"adrl",  0x028f0000, NULL,   NULL,        ARM_ANY,      do_adrl},
d839 2
a840 2
  {"ldc",   0x0c100000, NULL,  cplong_flag,  ARM_2UP,      do_lstc},
  {"stc",   0x0c000000, NULL,  cplong_flag,  ARM_2UP,      do_lstc},
d850 2
a851 2
  {"ldc2",  0xfc100000, "",  	cplong_flag, ARM_EXT_V5, do_lstc2},
  {"stc2",  0xfc000000, "",  	cplong_flag, ARM_EXT_V5, do_lstc2},
a4076 2
  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-8".  */
d4088 15
a4102 25
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;
  inst.instruction |= flags;

  end_of_line (str);
}

static void
do_adrl (str, flags)
     char * str;
     unsigned long flags;
{
  /* This is a pseudo-op of the form "adrl rd, label" to be converted
     into a relative address of the form:
     	add rd, pc, #low(label-.-8)"
     	add rd, rd, #high(label-.-8)"  */

  skip_whitespace (str);

  if (reg_required_here (& str, 12) == FAIL
      || skip_past_comma (& str) == FAIL
      || my_get_expression (& inst.reloc.exp, & str))
d4104 8
a4111 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
a4114 10

  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type              = BFD_RELOC_ARM_ADRL_IMMEDIATE;
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
  inst.reloc.pc_rel            = 1;
  inst.instruction            |= flags;
  inst.size                    = INSN_SIZE * 2;

  return;
@


1.87
log
@Remove auot generated man pages
@
text
@@


1.86
log
@2001-06-18  Philip Blundell  <philb@@gnu.org>

	* config/tc-arm.c (do_msr): Remove restriction on usage of
	immediate operands.
@
text
@@


1.85
log
@2001-06-13  Philip Blundell  <philb@@gnu.org>

	* config/tc-arm.c (thumb_shift): Improve wording of error message.
	(do_t_arit): Likewise.
@
text
@d2292 4
d2302 1
@


1.84
log
@fix test for overlflow of literal pool
@
text
@d6028 1
a6028 1
	  inst.error = _("dest and source1 one must be the same register");
@


1.83
log
@When truncating an aligned block, ensure that the low order bits of the
alignment are preserved.
@
text
@d1298 1
a1298 1
      if (next_literal_pool_place > MAX_LITERAL_POOL_SIZE)
@


1.82
log
@Do not insert more than MAX_MEM_FOR_RS_ALIGN_CODE bytes.
@
text
@d8819 1
a8819 1
    bytes = MAX_MEM_FOR_RS_ALIGN_CODE;
@


1.81
log
@Fix indentation and parenthesis
@
text
@d8799 2
a8800 2
arm_handle_align (fragp)
     fragS *fragp;
d8811 1
a8811 1
  if (fragp->fr_type != rs_align_code)
d8814 2
a8815 2
  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;
d8818 4
a8821 1
  if (fragp->tc_frag_data)
d8854 2
a8855 2
  fragp->fr_fix += fix;
  fragp->fr_var = noop_size;
d8870 1
a8870 1
  if (max > 31)
d8874 1
a8874 1
		31,
d8887 2
a8888 2
arm_init_frag (fragp)
     fragS *fragp;
d8891 1
a8891 1
  fragp->tc_frag_data = thumb_mode;
@


1.80
log
@Add gas and ld support for openrisc
@
text
@d1285 6
a1290 6
          && literals[lit_count].exp.X_add_number
	  == inst.reloc.exp.X_add_number
          && literals[lit_count].exp.X_add_symbol
	  == inst.reloc.exp.X_add_symbol
          && literals[lit_count].exp.X_op_symbol
	  == inst.reloc.exp.X_op_symbol)
@


1.79
log
@imprrove error message
@
text
@d1282 11
@


1.78
log
@Add ability to pad code alignment frags with no-ops.
@
text
@d8857 1
a8857 1
    as_fatal (_("alignments in code section > 32 not supported."));
@


1.77
log
@Automate generate on man pages
@
text
@d8783 96
@


1.76
log
@Always set machine type based on cpu_variant.
@
text
@d8427 32
a8458 1
  if (label_is_thumb_function_name)
@


1.75
log
@Fix copyright notices
@
text
@d6516 5
a6520 1
  if (cpu_variant != (FPU_DEFAULT | CPU_DEFAULT))
d6522 4
a6525 20
      if (cpu_variant & ARM_EXT_XSCALE)
	mach = bfd_mach_arm_XScale;
      else if (cpu_variant & ARM_EXT_V5E)
	mach = bfd_mach_arm_5TE;
      else if (cpu_variant & ARM_EXT_V5)
	{
	  if (cpu_variant & ARM_EXT_THUMB)
	    mach = bfd_mach_arm_5T;
	  else
	    mach = bfd_mach_arm_5;
	}
      else if (cpu_variant & ARM_EXT_HALFWORD)
	{
	  if (cpu_variant & ARM_EXT_THUMB)
	    mach = bfd_mach_arm_4T;
	  else
	    mach = bfd_mach_arm_4;
	}
      else if (cpu_variant & ARM_EXT_LONGMUL)
	mach = bfd_mach_arm_3M;
d6527 9
@


1.74
log
@Fix BLX(1) for Thumb
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999, 2000
@


1.73
log
@2001-02-12  Philip Blundell  <pb@@futuretv.com>

	* config/tc-arm.c (do_ldst): Improve warnings for unpredictable
	ldrt/strt instructions.
@
text
@d7152 9
@


1.72
log
@Remove redundant bit from "fa" and "da" flags
@
text
@d4326 10
a4335 3
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
d4356 9
a4364 2
	      if (! (flags & TRANS_BIT))
		pre_inc = 1;
@


1.72.2.1
log
@merge patch from HEAD to warn about bad ldrt/strt
@
text
@d4326 3
a4328 10
		{
		  if (flags & TRANS_BIT)
		    as_warn (_("Rn and Rd must be different in %s"),
			     ((inst.instruction & LOAD_BIT)
			      ? "LDRT" : "STRT"));
		  else
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		}
d4349 2
a4350 9
	      if (flags & TRANS_BIT)
		{
		  if (conflict_reg)
		    as_warn (_("Rn and Rd must be different in %s"),
			     ((inst.instruction & LOAD_BIT)
			      ? "LDRT" : "STRT"));
		}
		else
		  pre_inc = 1;
@


1.72.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.72.2.3
log
@Merge in patches from mainline
@
text
@a1281 11

      if (literals[lit_count].exp.X_op == inst.reloc.exp.X_op
          && inst.reloc.exp.X_op == O_symbol
          && (literals[lit_count].exp.X_add_number
	      == inst.reloc.exp.X_add_number)
          && (literals[lit_count].exp.X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
          && (literals[lit_count].exp.X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
        break;

d1287 1
a1287 1
      if (next_literal_pool_place >= MAX_LITERAL_POOL_SIZE)
d6516 1
a6516 5
  if (cpu_variant & ARM_EXT_XSCALE)
    mach = bfd_mach_arm_XScale;
  else if (cpu_variant & ARM_EXT_V5E)
    mach = bfd_mach_arm_5TE;
  else if (cpu_variant & ARM_EXT_V5)
d6518 20
a6537 11
      if (cpu_variant & ARM_EXT_THUMB)
	mach = bfd_mach_arm_5T;
      else
	mach = bfd_mach_arm_5;
    }
  else if (cpu_variant & ARM_EXT_HALFWORD)
    {
      if (cpu_variant & ARM_EXT_THUMB)
	mach = bfd_mach_arm_4T;
      else
	mach = bfd_mach_arm_4;
a6538 2
  else if (cpu_variant & ARM_EXT_LONGMUL)
    mach = bfd_mach_arm_3M;
a7151 9
	if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	  /* Remove bit zero of the adjusted offset.  Bit zero can only be
	     set if the upper insn is at a half-word boundary, since the
	     destination address, an ARM instruction, must always be on a
	     word boundary.  The semantics of the BLX (1) instruction, however,
	     are that bit zero in the offset must always be zero, and the
	     corresponding bit one in the target address will be set from bit
	     one of the source address.  */
	  newval2 &= ~1;
d8421 1
a8421 32
  /* Note - do not allow local symbols (.Lxxx) to be labeled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.  Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:

                ldr  r2, [pc, .Laaa]
                lsl  r3, r3, #2
                ldr  r2, [r3, r2]
                mov  pc, r2
		
       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:   .word Lbbb

     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.
     
     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
a8745 99

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
arm_handle_align (fragP)
     fragS *fragP;
{
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };

  int bytes, fix, noop_size;
  char * p;
  const char * noop;
  
  if (fragP->fr_type != rs_align_code)
    return;

  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;
  
  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;
  
  if (fragP->tc_frag_data)
    {
      if (target_big_endian)
	noop = thumb_bigend_noop;
      else
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
    }
  else
    {
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
    }
  
  if (bytes & (noop_size - 1))
    {
      fix = bytes & (noop_size - 1);
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }

  while (bytes >= noop_size)
    {
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
    }
  
  fragP->fr_fix += fix;
  fragP->fr_var = noop_size;
}

/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */

void
arm_frag_align_code (n, max)
     int n;
     int max;
{
  char * p;

  /* We assume that there will never be a requirment
     to support alignments greater than 32 bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
  
  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;

}

/* Perform target specific initialisation of a frag.  */

void
arm_init_frag (fragP)
     fragS *fragP;
{
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
}
@


1.72.2.4
log
@2001-06-13  Philip Blundell  <philb@@gnu.org>

	* config/tc-arm.c (thumb_shift): Improve wording of error message.
	(do_t_arit): Likewise.
@
text
@d6028 1
a6028 1
	  inst.error = _("dest and source1 must be the same register");
@


1.72.2.5
log
@2001-06-18  Philip Blundell  <philb@@gnu.org>

	* config/tc-arm.c (do_msr): Remove restriction on usage of
	immediate operands.
@
text
@a2291 4
#if 0  /* The first edition of the ARM architecture manual stated that
	  writing anything other than the flags with an immediate operation
	  had UNPREDICTABLE effects.  This constraint was removed in the
	  second edition of the specification.  */
a2297 1
#endif
@


1.72.2.6
log
@Use MVN to build simple inverted constants.
@
text
@d4434 2
a4435 1
      if (inst.reloc.exp.X_op == O_constant)
d4437 11
a4447 3
	  value = validate_immediate (inst.reloc.exp.X_add_number);

	  if (value != FAIL)
d4449 2
a4450 5
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= (flags & COND_MASK) | (value & 0xfff);
	      end_of_line (str);
a4452 2
	  
	  value = validate_immediate (~ inst.reloc.exp.X_add_number);
d4454 2
a4455 1
	  if (value != FAIL)
d4457 2
a4458 6
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= (flags & COND_MASK) | (value & 0xfff);
	      end_of_line (str);
	      return;
d4460 5
a4465 20

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
	  return;
	}

      /* Change the instruction exp to point to the pool.  */
      if (halfword)
	{
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_LITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
@


1.71
log
@Allow ADRL relocs to be adjusted in arm-coff
@
text
@d347 1
a347 1
  {"fa", 0x08000000},
d351 1
a351 1
  {"da", 0x08000000},
d357 1
a357 1
  {"ed", 0x08000000},
d364 1
a364 1
  {"da", 0x08000000},
@


1.70
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d8540 16
@


1.69
log
@Add ARM v5t, v5te and XScale support
@
text
@d2496 1
a2496 1
  static char buff [128];	/* Note the address is taken.  Hence, static. */
d2502 1
a2502 1
  
d2509 1
a2509 1
  
d2516 1
a2516 1
  
d2524 1
a2524 1
   Returns rn, or else FAIL (in which case may set inst.error 
d2526 1
a2526 1
 
d2538 1
a2538 1
    
d2542 1
a2542 1
      
d2553 1
a2553 1
	  
d2583 1
a2583 1
	  
d2618 1
a2618 1
      
d2625 1
a2625 1
  
d2652 1
a2652 1
  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC || rn == REG_PC) 
d2696 1
a2696 1
  
d2765 1
a2765 1
   MRRCcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>. 
d2768 1
a2768 1
   respectively, when coproc == 0, opcode == 0, and CRm == 0.  
d2814 1
a2814 1
    as_tsktsk 
a2830 1

d2963 1
a2963 1
  
d3045 1
a3045 1
  skip_whitespace (str);     
d3057 1
a3057 1
  
d3059 1
a3059 1
  
d3084 1
a3084 1
  
d3088 1
a3088 1
  
d3091 1
a3091 1
    
d3097 1
a3097 1
    
d3113 1
a3113 1
    
d3120 1
a3120 1
  
d3129 1
a3129 1
	into inst.instruction.	
d3145 1
a3145 1
    	
d3148 1
a3148 1
  
d3151 1
a3151 1
  
d3168 1
a3168 1
      
d3170 1
a3170 1
      
d3195 1
a3195 1
     uses the ARM register space, not the Thumb one, so a call to 
d3199 1
a3199 1
  
d3213 1
a3213 1
      
d3217 1
a3217 1
  
d3237 1
a3237 1
  
d3243 1
a3243 1
  
d3249 1
a3249 1
  
d3251 1
a3251 1
  
d3258 1
a3258 1
  
d3261 1
a3261 1
  
d3272 1
a3272 1
     MIAcc   acc0,Rm,Rs	
d3286 1
a3286 1
  
d3289 1
a3289 1
  
d3293 1
a3293 1
  
d3297 2
a3298 2
  
  /* inst.instruction has now been zapped with both rm and rs. */
d3301 1
a3301 1
  
d3319 1
a3319 1
  
d3322 1
a3322 1
  
d3326 1
a3326 1
  
d3330 1
a3330 1
  
d3334 1
a3334 1
  
d3380 1
a3380 1
/* Xscale: Preload-Cache 
d3383 1
a3383 1
    
d3414 1
a3414 1
  
d3441 1
a3441 1
      
d3455 1
a3455 1
      
d3461 1
a3461 1
      
d3495 1
a3495 1
  
d3504 1
a3504 1
      
d3510 1
a3510 1
  
d3512 1
a3512 1
    
d3526 1
a3526 1
  
d3530 1
a3530 1
      inst.error = _("Destination register must be even");	
d3545 1
a3545 1
  
d6466 1
a6466 1
	
@


1.68
log
@Add support for .line and .file pseudo ops.
@
text
@d53 3
a55 3
#define ARM_LONGMUL	0x00000010	/* Allow long multiplies.  */
#define ARM_HALFWORD	0x00000020	/* Allow half word loads.  */
#define ARM_THUMB	0x00000040	/* Allow BX instruction.   */
d57 2
d61 3
a63 2
#define ARM_ARCH_V4	(ARM_7 | ARM_LONGMUL | ARM_HALFWORD)
#define ARM_ARCH_V4T	(ARM_ARCH_V4 | ARM_THUMB)
d65 3
a67 1
#define ARM_ARCH_V5T	(ARM_ARCH_V5 | ARM_THUMB)
d86 3
d90 1
a90 1
#define CPU_DEFAULT (ARM_ARCH_V4 | ARM_THUMB)
d92 2
a93 1
#define CPU_DEFAULT ARM_ALL
d110 1
d257 5
a261 3
#define CONDS_BIT       (0x00100000)
#define LOAD_BIT        (0x00100000)
#define TRANS_BIT	(0x00200000)
d309 1
d321 1
d608 25
d690 4
a693 4
/* LONGEST_INST is the longest basic instruction name without conditions or
   flags.  ARM7M has 4 of length 5.  */

#define LONGEST_INST 5
d719 13
d782 4
a785 4
  {"smull", 0x00c00090, NULL,   s_flag,      ARM_LONGMUL,  do_mull},
  {"umull", 0x00800090, NULL,   s_flag,      ARM_LONGMUL,  do_mull},
  {"smlal", 0x00e00090, NULL,   s_flag,      ARM_LONGMUL,  do_mull},
  {"umlal", 0x00a00090, NULL,   s_flag,      ARM_LONGMUL,  do_mull},
d788 1
a788 1
  {"bx",    0x012fff10, NULL,   NULL,        ARM_THUMB,    do_bx},
d844 42
d1044 57
a1100 55
  {"adc",	0x4140,		2,	ARM_THUMB, do_t_arit},
  {"add",	0x0000,		2,	ARM_THUMB, do_t_add},
  {"and",	0x4000,		2,	ARM_THUMB, do_t_arit},
  {"asr",	0x0000,		2,	ARM_THUMB, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_THUMB, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_THUMB, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_THUMB, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_THUMB, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_THUMB, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_THUMB, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_THUMB, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_THUMB, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_THUMB, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_THUMB, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_THUMB, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_THUMB, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_THUMB, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_THUMB, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_THUMB, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_THUMB, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_THUMB, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_THUMB, do_t_branch23},
  {"bx",	0x4700,		2,	ARM_THUMB, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_THUMB, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_THUMB, do_t_compare},
  {"eor",	0x4040,		2,	ARM_THUMB, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_THUMB, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_THUMB, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_THUMB, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_THUMB, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_THUMB, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_THUMB, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_THUMB, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_THUMB, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_THUMB, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_THUMB, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_THUMB, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_THUMB, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_THUMB, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_THUMB, do_t_arit},
  {"orr",	0x4300,		2,	ARM_THUMB, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_THUMB, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_THUMB, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_THUMB, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_THUMB, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_THUMB, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_THUMB, do_t_str},
  {"strb",	0x0000,		2,	ARM_THUMB, do_t_strb},
  {"strh",	0x0000,		2,	ARM_THUMB, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_THUMB, do_t_swi},
  {"sub",	0x0000,		2,	ARM_THUMB, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_THUMB, do_t_arit},
d1102 2
a1103 2
  {"adr",       0x0000,         2,      ARM_THUMB, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_THUMB, do_t_nop},      /* mov r8,r8  */
d1160 1
d1713 1
a1713 1
	  if (! (cpu_variant & ARM_THUMB))
d1726 1
a1726 1
	  if ((cpu_variant & ARM_ANY) == ARM_THUMB)
d2215 946
a3160 5

  /* This is for backwards compatability with older toolchains.  */
  else if (   strcmp (str, "cpsr_all") == 0
	   || strcmp (str, "spsr_all") == 0)
    skip = 8;
d3163 12
a3174 2
      inst.error = _("{C|S}PSR expected");
      return;
a3175 7

  if (* str == 's' || * str == 'S')
    inst.instruction |= SPSR_BIT;
  str += skip;

  inst.instruction |= flags;
  end_of_line (str);
d3178 6
a3183 3
/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */
d3186 1
a3186 1
do_msr (str, flags)
a3187 1
     unsigned long flags;
d3189 2
a3190 1
  skip_whitespace (str);
d3192 2
a3193 2
  if (psr_required_here (& str) == FAIL)
    return;
d3195 12
a3206 1
  if (skip_past_comma (& str) == FAIL)
d3208 9
a3216 2
      inst.error = _("comma missing after psr flags");
      return;
d3218 18
d3238 4
d3243 3
a3245 1
  if (reg_required_here (& str, 0) != FAIL)
d3247 1
a3247 3
      inst.error = NULL;
      inst.instruction |= flags;
      end_of_line (str);
d3250 7
a3256 5

  if (! is_immediate_prefix (* str))
    {
      inst.error =
	_("only a register or immediate value can follow a psr flag");
d3259 6
d3266 1
a3266 2
  str ++;
  inst.error = NULL;
d3268 3
a3270 6
  if (my_get_expression (& inst.reloc.exp, & str))
    {
      inst.error =
	_("only a register or immediate value can follow a psr flag");
      return;
    }
d3272 4
a3275 5
  if (inst.instruction & ((PSR_c | PSR_x | PSR_s) << PSR_SHIFT))
    {
      inst.error = _("only flag field of psr can be set with immediate value");
      return;
    }
d3277 7
a3283 1
  flags |= INST_IMMEDIATE;
d3285 18
a3302 5
  if (inst.reloc.exp.X_add_symbol)
    {
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
    }
d3304 4
a3307 2
    {
      unsigned value = validate_immediate (inst.reloc.exp.X_add_number);
d3309 1
a3309 5
      if (value == (unsigned) FAIL)
	{
	  inst.error = _("Invalid constant");
	  return;
	}
d3311 6
a3316 2
      inst.instruction |= value;
    }
d3318 20
a3337 3
  inst.error = NULL;
  inst.instruction |= flags;
  end_of_line (str);
d3340 3
a3342 5
/* Long Multiply Parser
   UMULL RdLo, RdHi, Rm, Rs
   SMULL RdLo, RdHi, Rm, Rs
   UMLAL RdLo, RdHi, Rm, Rs
   SMLAL RdLo, RdHi, Rm, Rs.  */
d3345 1
a3345 1
do_mull (str, flags)
d3349 2
a3350 1
  int rdlo, rdhi, rm, rs;
d3352 1
a3352 4
  /* Only one format "rdlo, rdhi, rm, rs".  */
  skip_whitespace (str);

  if ((rdlo = reg_required_here (&str, 12)) == FAIL)
d3354 1
a3354 1
      inst.error = BAD_ARGS;
d3358 1
a3358 6
  if (skip_past_comma (&str) == FAIL
      || (rdhi = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d3360 2
a3361 6
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d3363 3
a3365 3
  /* rdhi, rdlo and rm must all be different.  */
  if (rdlo == rdhi || rdlo == rm || rdhi == rm)
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
d3367 3
a3369 6
  if (skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d3371 3
a3373 5
  if (rdhi == REG_PC || rdhi == REG_PC || rdhi == REG_PC || rdhi == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d3375 4
a3378 3
  inst.instruction |= flags;
  end_of_line (str);
  return;
d3381 6
d3388 1
a3388 1
do_mul (str, flags)
d3392 1
a3392 1
  int rd, rm;
d3394 1
a3394 4
  /* Only one format "rd, rm, rs".  */
  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 16)) == FAIL)
d3396 1
a3396 1
      inst.error = BAD_ARGS;
d3400 3
a3402 1
  if (rd == REG_PC)
d3404 1
a3404 1
      inst.error = BAD_PC;
d3408 9
a3416 2
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
d3418 16
a3433 2
      inst.error = BAD_ARGS;
      return;
d3435 1
a3435 2

  if (rm == REG_PC)
d3437 8
a3444 3
      inst.error = BAD_PC;
      return;
    }
d3446 1
a3446 2
  if (rm == rd)
    as_tsktsk (_("rd and rm should be different in mul"));
d3448 5
a3452 6
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d3454 10
a3463 4
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
a3465 1
  inst.instruction |= flags;
a3466 1
  return;
d3469 6
d3476 1
a3476 1
do_mla (str, flags)
d3480 10
a3489 1
  int rd, rm;
d3491 2
a3492 2
  /* Only one format "rd, rm, rs, rn".  */
  skip_whitespace (str);
a3493 3
  if ((rd = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
d3496 4
d3501 8
a3508 3
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
d3511 4
a3514 3

  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
d3520 2
a3521 1
  if (rm == REG_PC)
d3523 2
a3524 1
      inst.error = BAD_PC;
d3527 3
a3529 8

  if (rm == rd)
    as_tsktsk (_("rd and rm should be different in mla"));

  if (skip_past_comma (&str) == FAIL
      || (rd = reg_required_here (&str, 8)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 12)) == FAIL)
d3531 1
a3531 1
      inst.error = BAD_ARGS;
d3535 1
a3535 1
  if (rd == REG_PC || rm == REG_PC)
d3537 1
a3537 1
      inst.error = BAD_PC;
d3541 6
a3546 1
  inst.instruction |= flags;
a3547 1
  return;
d4273 1
a4273 1
      if ((cpu_variant & ARM_HALFWORD) == 0)
d6460 18
d6505 4
a6508 2
      if (cpu_variant & (ARM_EXT_V5 & ARM_THUMB))
	mach = bfd_mach_arm_5T;
d6510 14
a6523 6
	mach = bfd_mach_arm_5;
      else if (cpu_variant & ARM_THUMB)
	mach = bfd_mach_arm_4T;
      else if ((cpu_variant & ARM_ARCH_V4) == ARM_ARCH_V4)
	mach = bfd_mach_arm_4;
      else if (cpu_variant & ARM_LONGMUL)
d6872 1
a6872 1
			      _("Unable to compute ADRL instructions for PC offset of 0x%x"),
d7232 1
a7232 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d7241 1
a7241 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d7248 1
a7248 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d7255 1
a7255 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d7262 1
a7262 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d7465 1
a7465 2
		    _("ADRL used for a symbol not defined in the same file"),
		    fixp->fx_r_type);
d7876 2
a7877 1
              -m[arm]v[2345[t]]       Arm architectures
d7892 1
d7962 1
a7962 1
	      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_THUMB;
d7968 1
a7968 1
	      if ((cpu_variant & ARM_THUMB) == 0)
d8039 6
d8111 1
a8111 1
		      cpu_variant |= (ARM_THUMB | ARM_ARCH_V4);
d8115 1
a8115 1
		      cpu_variant |= ARM_LONGMUL;
d8139 1
a8139 1
		  | ARM_8 | ARM_ARCH_V4 | ARM_LONGMUL;
d8147 1
a8147 1
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
d8150 1
a8150 1
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL;
d8153 1
a8153 1
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
d8156 1
a8156 1
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
d8166 1
a8166 1
		  | ARM_8 | ARM_ARCH_V4 | ARM_LONGMUL;
d8171 7
d8203 1
a8203 1
		    case 'm': cpu_variant |= ARM_LONGMUL; break;
d8212 1
a8212 1
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V4;
d8216 1
a8216 1
		    case 't': cpu_variant |= ARM_THUMB; break;
d8225 1
a8225 1
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V5;
d8228 2
a8229 1
		    case 't': cpu_variant |= ARM_THUMB; break;
d8282 1
@


1.67
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d1123 2
d6304 2
a6305 2
		      _("Can not represent %s relocation in this object file format (%d)"),
		      type, fixp->fx_pcrel);
@


1.66
log
@2000-11-14  Kazu Hirata  <kazu@@hxi.com>

	* config/aout_gnu.h: Fix formatting.
	* config/atof-vax.c: Likewise.
	* config/m68k-parse.h: Likewise.
	* config/m88k-opcode.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/te-386bsd.h: Likewise.
	* config/te-hppa.h: Likewise.
	* config/te-nbsd.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-sparcaout.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/vax-inst.h: Likewise.
	* config/vms-conf.h: Likewise.
@
text
@d6377 1
d6379 1
a6379 2
  if (debug_type == DEBUG_DWARF2)
    dwarf2_generate_asm_lineno (inst.size);
a6380 1
  return;
a7504 9
}

/* Stuff to do after assembling all of the source file.  */

void
arm_end_of_source ()
{
  if (debug_type == DEBUG_DWARF2)
    dwarf2_finish ();
@


1.65
log
@Add include of "dwarf2dbg.h"
@
text
@d6624 1
a6624 1
      
@


1.64
log
@Preserve copy of case clobber opcodes so that .req pseudo op works
@
text
@d38 1
@


1.63
log
@2000-11-02  Theo Honohan  <th@@futuretv.com>

	* config/tc-arm.c (do_msr): Improve error message.
@
text
@d6616 1
a6616 1
      char * copy_of_str = str;
d6619 5
@


1.62
log
@handle lower cased cpsr and spsr
@
text
@d2183 1
a2183 1
      inst.error = _("can only set flag field with immediate value");
@


1.61
log
@Add --gdwarf2 support to ARM toolchain
@
text
@a564 14
  /* For backwards compatability with older toolchain we also
     support lower case versions of some of these flags.  */
  {"cpsr",	true,  PSR_c | PSR_f},
  {"cpsr_all",	true,  PSR_c | PSR_f},
  {"spsr",	false, PSR_c | PSR_f},
  {"spsr_all",	false, PSR_c | PSR_f},
  {"cpsr_flg",	true,  PSR_f},
  {"cpsr_f",    true,  PSR_f},
  {"spsr_flg",	false, PSR_f},
  {"spsr_f",    false, PSR_f},
  {"cpsr_c",	true,  PSR_c},
  {"cpsr_ctl",	true,  PSR_c},
  {"spsr_c",	false, PSR_c},
  {"spsr_ctl",	false, PSR_c}
d1761 7
@


1.60
log
@2000-09-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-a29k.c: Fix formatting.
	* config/tc-alpha.c: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-tic80.h: Likewise.
@
text
@d3098 1
a3098 1
     char *str;
d6383 4
a6386 1

d7262 2
a7263 2
  symbolS *sym;
  char bind;
d7269 1
a7269 1
	  elf_symbol_type *elf_sym;
d7303 1
a7303 1
     char *name;
d7316 1
a7316 1
     fixS *fixP;
d7350 1
a7350 1
   fixS *fixP;
d7481 1
a7481 1
	  && *input_line_pointer == '('
d7507 9
@


1.59
log
@2000-09-08  Philip Blundell  <philb@@gnu.org>

	* config/tc-arm.c (md_apply_fix3): Correct handling of ADRL when
	offset is negative.
@
text
@d954 1
a954 1
  /* Which CPU variants this exists for. */
d1223 1
a1223 1
     symbolS *    symbolP; 
d1533 1
a1533 1
	  
d2553 1
a2553 1
  
d2561 1
a2561 1
  
d2585 1
a2585 1
    
d2588 1
a2588 1
  
d2591 1
a2591 1
  
d2626 1
a2626 1
      
d2635 1
a2635 1
  
@


1.58
log
@Replace as_tsktsk with as_warn.
Make reference to first element of shift_names explicit.
@
text
@d5679 1
a5679 1
	    else if (validate_immediate_twopart (- value, & highpart) != (unsigned int) FAIL)
@


1.57
log
@Minor formatting changes
@
text
@d2611 2
a2612 2
	      as_tsktsk (_("Shift of 0 ignored."));
	      shift = shift_names;
@


1.56
log
@Allow illegal shifts by zero to be recorded as logical shift lefts by zero.
@
text
@d216 1
a216 1
  
d5694 1
a5694 1
	    newinsn &= ~0xf0000;
d5710 1
a5710 1
	value = -value;
d5731 1
a5731 1
	value = -value;
d5754 1
a5754 1
	value = -value;
@


1.55
log
@Tidy up decoding of shift based addressing modes.
Add extra tests for these addressing modes
@
text
@d2534 1
a2534 1
  struct asm_shift_name * shift;
d2551 1
a2551 1
  shift = (struct asm_shift_name *) hash_find (arm_shift_hsh, * str);
d2605 10
a2614 4
	  /* As a special case we allow ROR #0, but we issue a message
	     reminding the programmer that this is actually an RRX.  */
	  if (num == 0 && shift->properties->index == SHIFT_ROR)
	    as_tsktsk (_("ROR #0 is actually RRX"));
@


1.54
log
@Warn abouyt "bx pc" not being very useful.
@
text
@d169 1
a169 1
struct asm_shift
d171 22
a192 2
  CONST char *  template;
  unsigned long value;
d195 1
a195 1
static CONST struct asm_shift shift[] =
d197 2
a198 12
  {"asl", 0},
  {"lsl", 0},
  {"lsr", 0x00000020},
  {"asr", 0x00000040},
  {"ror", 0x00000060},
  {"rrx", 0x00000060},
  {"ASL", 0},
  {"LSL", 0},
  {"LSR", 0x00000020},
  {"ASR", 0x00000040},
  {"ROR", 0x00000060},
  {"RRX", 0x00000060}
d201 16
d2534 1
a2534 1
  struct asm_shift * shft;
d2551 1
a2551 1
  shft = (struct asm_shift *) hash_find (arm_shift_hsh, * str);
d2553 2
a2554 1
  if (shft)
d2556 3
a2558 7
      if (   ! strncmp (* str, "rrx", 3)
          || ! strncmp (* str, "RRX", 3))
	{
	  * str = p;
	  inst.instruction |= shft->value;
	  return SUCCESS;
	}
d2560 8
a2567 1
      skip_whitespace (p);
d2569 1
a2569 10
      if (unrestrict && reg_required_here (& p, 8) != FAIL)
	{
	  inst.instruction |= shft->value | SHIFT_BY_REG;
	  * str = p;
	  return SUCCESS;
	}
      else if (is_immediate_prefix (* p))
	{
	  inst.error = NULL;
	  p ++;
d2571 25
a2595 2
	  if (my_get_expression (& inst.reloc.exp, & p))
	    return FAIL;
d2597 13
a2609 2
	  /* Validate some simple #expressions.  */
	  if (inst.reloc.exp.X_op == O_constant)
d2611 2
a2612 25
	      unsigned num = inst.reloc.exp.X_add_number;

	      /* Reject operations greater than 32, or lsl #32.  */
	      if (num > 32 || (num == 32 && shft->value == 0))
		{
		  inst.error = _("Invalid immediate shift");
		  return FAIL;
		}

	      /* Shifts of zero should be converted to lsl
		 (which is zero).  */
	      if (num == 0)
		{
		  * str = p;
		  return SUCCESS;
		}

	      /* Shifts of 32 are encoded as 0, for those shifts that
		 support it.  */
	      if (num == 32)
		num = 0;

	      inst.instruction |= (num << 7) | shft->value;
	      * str = p;
	      return SUCCESS;
d2614 1
d2616 12
a2627 15
	  inst.reloc.type   = BFD_RELOC_ARM_SHIFT_IMM;
	  inst.reloc.pc_rel = 0;
	  inst.instruction |= shft->value;

	  * str = p;
	  return SUCCESS;
	}
      else
	{
	  inst.error = (unrestrict
			? _("shift requires register or #expression")
			: _("shift requires #expression"));
	  * str = p;
	  return FAIL;
	}
d2629 3
a2631 3

  inst.error = _("Shift expression expected");
  return FAIL;
d5273 2
a5274 2
  for (i = 0; i < sizeof (shift) / sizeof (struct asm_shift); i++)
    hash_insert (arm_shift_hsh, shift[i].template, (PTR) (shift + i));
d7421 1
a7421 1
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
@


1.53
log
@Allow "bx pc" in ARM mode.
@
text
@d3593 2
@


1.52
log
@Undo some formatting fixes
@
text
@d3592 1
a3592 2
  if (reg == REG_PC)
    inst.error = BAD_PC;
@


1.51
log
@Fix skip of 'cpsr_all' flag
@
text
@d136 1
a136 1
symbolS *GOT_symbol;
d155 1
a155 1
  CONST char *error;
d157 2
a158 2
  int suffix;
  int size;
d162 2
a163 2
    expressionS exp;
    int pc_rel;
d171 1
a171 1
  CONST char *template;
d196 1
a196 1
CONST char *fp_const[] =
d226 1
a226 1
  CONST char *template;
d258 2
a259 5
  /* Basic flag string.  */
  CONST char *template;

  /* Bits to set.  */
  unsigned long set_bits;
d384 2
a385 2
  CONST char *template;
  boolean cpsr;
d646 1
a646 1
  CONST char *template;
d653 1
a653 1
  CONST char *comp_suffix;
d656 1
a656 1
  CONST struct asm_flg *flags;
d662 1
a662 1
  void (*parms) PARAMS ((char *, unsigned long));
d921 1
a921 1
  CONST char *template;
d932 1
a932 1
  void (*parms) PARAMS ((char *));
d999 2
a1000 2
  CONST char *name;
  int number;
d1052 6
a1057 6
static struct hash_control *arm_ops_hsh   = NULL;
static struct hash_control *arm_tops_hsh  = NULL;
static struct hash_control *arm_cond_hsh  = NULL;
static struct hash_control *arm_shift_hsh = NULL;
static struct hash_control *arm_reg_hsh   = NULL;
static struct hash_control *arm_psr_hsh   = NULL;
d1087 2
a1088 1
  { "req",         s_req,         0 },	/* Never called becasue '.req' does not start line.  */
d1129 1
a1129 1
symbolS *last_label_seen;
d1139 1
a1139 1
  struct arm_it *inst;
d1150 1
a1150 1
symbolS *current_poolP = NULL;
d1197 5
a1201 13
     symbolS *symbolP;

     /* It is copied, the caller can modify.  */
     CONST char *name;

     /* Segment identifier (SEG_<something>).  */
     segT segment;

     /* Symbol value.  */
     valueT valu;

     /* Associated fragment.  */
     fragS *frag;
d1204 1
a1204 1
  char *preserved_copy_of_name;
d1206 1
a1206 2
  /* +1 for \0.  */
  name_length = strlen (name) + 1;
d1234 1
a1234 1
  symbol_append (symbolP, symbol_lastP, &symbol_rootP, &symbol_lastP);
d1261 1
a1261 2
      /* 12-bit pack: [shift-cnt,const].  */
      return a | (i << 7);
d1272 2
a1273 2
     unsigned int val;
     unsigned int *highpart;
d1283 1
a1283 1
	    if (a & ~0xffff)
d1285 1
a1285 1
	    *highpart = (a  >> 8) | ((i + 24) << 7);
d1291 1
a1291 1
	    *highpart = (a >> 16) | ((i + 16) << 7);
d1296 1
a1296 1
	    *highpart = (a >> 24) | ((i + 8) << 7);
a1428 1

d1463 8
a1470 7
  register char *name;
  register char delim;
  register char *end_name;
  register symbolS *symbolP;

  /* Especial apologies for the random logic: This just grew, and
     could be parsed much more simply!  Dean in haste.  */
d1505 3
a1507 2
	  extern struct list_info_struct *listing_tail;
	  fragS *dummy_frag = (fragS *) xmalloc (sizeof (fragS));
d1526 1
a1526 1
  *end_name = delim;
d1603 1
d1616 1
d1618 1
d1620 3
a1622 2
	    frag_align (2, 0, 0);
	  record_alignment (now_seg, 1);
d1668 1
a1668 1
     char *str;
d1672 1
a1672 1
  if (*str != '\0')
d1678 1
a1678 1
     char **str;
d1680 1
a1680 1
  char *p = *str, c;
d1699 2
a1700 2
   Restore input start point on err.
   Return the reg#, or FAIL.  */
d1704 2
a1705 2
     char **str;
     int shift;
d1707 3
a1709 3
  static char buff[128]; /* XXX  */
  int reg;
  char *start = *str;
d1731 1
a1731 1
     register char **ccp;
d1733 4
a1736 4
  char *start = *ccp;
  char c;
  char *p;
  CONST struct asm_psr *psr;
d1767 1
a1767 1
     char **str;
d1769 2
a1770 2
  char *start = *str;
  CONST struct asm_psr *psr;
d1797 1
a1797 1
     char **str;
d1801 1
a1801 1
  skip_whitespace (*str);
d1841 1
a1841 1
  skip_whitespace (*str);
d1865 2
a1866 2
     char **str;
     int where;
d1868 2
a1869 2
  int reg;
  char *start = *str;
d1889 2
a1890 2
     char **str;
     int where;
d1892 2
a1893 2
  int reg;
  char *start = *str;
d1913 1
a1913 1
     char **str;
d1917 1
a1917 1
  skip_whitespace (*str);
d1927 1
a1927 1
  if (my_get_expression (&inst.reloc.exp, str))
d1961 1
a1961 1
     char **str;
d1963 3
a1965 3
  char *p = *str;
  int pre_inc = 0;
  int write_back = 0;
d1974 1
a1974 1
      if ((reg = reg_required_here (&p, 16)) == FAIL)
d1983 1
a1983 1
	  if (skip_past_comma (&p) == SUCCESS)
d1994 1
a1994 1
	      if (cp_address_offset (&p) == FAIL)
d2004 1
a2004 1
	  if (skip_past_comma (&p) == FAIL)
d2012 1
a2012 1
	  if (cp_address_offset (&p) == FAIL)
d2057 1
a2057 1
     char *str;
d2090 1
a2090 1
  if (strcmp (str, "CPSR") == 0
d2092 1
a2092 1
      /* Lower case versions for backwards compatability.  */
d2098 1
a2098 1
  else if (strcmp (str, "cpsr_all") == 0
d2107 1
a2107 1
  if (*str == 's' || *str == 'S')
d2121 1
a2121 1
     char *str;
d2126 1
a2126 1
  if (psr_required_here (&str) == FAIL)
d2129 1
a2129 1
  if (skip_past_comma (&str) == FAIL)
d2137 1
a2137 1
  if (reg_required_here (&str, 0) != FAIL)
d2145 1
a2145 1
  if (! is_immediate_prefix (*str))
d2152 1
a2152 1
  str++;
d2155 1
a2155 1
  if (my_get_expression (&inst.reloc.exp, &str))
d2197 1
a2197 2
   SMLAL RdLo, RdHi, Rm, Rs
*/
d2201 1
a2201 1
     char *str;
d2253 1
a2253 1
     char *str;
d2309 1
a2309 1
     char *str;
d2365 1
a2365 1
/* Return the index into fp_values of a floating point number,
d2370 1
a2370 1
     char **str;
d2373 4
a2376 4
  char *save_in;
  expressionS exp;
  int i;
  int j;
d2439 1
a2439 1
     symbolS *sp;
d2456 2
a2457 2
     expressionS *ep;
     char **str;
d2459 2
a2460 2
  char *save_in;
  segT seg;
d2505 2
a2506 2
     char **str;
     int unrestrict;
d2508 3
a2510 3
  struct asm_shift *shft;
  char *p;
  char c;
d2512 1
a2512 1
  skip_whitespace (*str);
d2514 1
a2514 1
  for (p = *str; isalpha (*p); p++)
d2517 1
a2517 1
  if (p == *str)
d2523 4
a2526 4
  c = *p;
  *p = '\0';
  shft = (struct asm_shift *) hash_find (arm_shift_hsh, *str);
  *p = c;
d2529 2
a2530 2
      if (!strncmp (*str, "rrx", 3)
          || !strncmp (*str, "RRX", 3))
d2532 1
a2532 1
	  *str = p;
d2539 1
a2539 1
      if (unrestrict && reg_required_here (&p, 8) != FAIL)
d2542 1
a2542 1
	  *str = p;
d2545 1
a2545 1
      else if (is_immediate_prefix (*p))
d2548 3
a2550 2
	  p++;
	  if (my_get_expression (&inst.reloc.exp, &p))
d2565 2
a2566 2
	      /* Shifts of zero should be converted to lsl (which is
                 zero).  */
d2569 1
a2569 1
		  *str = p;
d2579 1
a2579 1
	      *str = p;
d2583 1
a2583 1
	  inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
d2586 2
a2587 1
	  *str = p;
d2595 1
a2595 1
	  *str = p;
d2605 2
a2606 2
   by altering the instuction.  A bit of a hack really.  */
/*      MOV <-> MVN
d2612 1
a2612 2
        by negating the second operand.
*/
d2616 2
a2617 2
     unsigned long *instruction;
     unsigned long value;
d2695 1
a2695 1
     char **str;
d2700 1
a2700 1
  skip_whitespace (*str);
d2760 1
a2760 1
		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be ok.  */
d2785 1
a2785 1
     char **str;
d2787 1
a2787 1
  skip_whitespace (*str);
d2800 1
a2800 1
	  skip_whitespace (*str);
d2842 1
a2842 1
     char *str;
d2865 1
a2865 1
     char *str;
d2893 1
a2893 1
     char *str;
d2903 3
a2905 3
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d2927 1
a2927 1
     char *str;
d2957 1
a2957 1
     char *str;
d2984 2
a2985 2
     char **str;
     int hwse;
d2994 1
a2994 1
      if (my_get_expression (&inst.reloc.exp, str))
d3093 1
a3093 1
  if ((conflict_reg = reg_required_here (&str, 12)) == FAIL)
d3100 1
a3100 1
  if (skip_past_comma (&str) == FAIL)
d3124 1
a3124 1
	  str++;
d3274 1
a3274 1
     char **strp;
d3276 3
a3278 3
  char *str = *strp;
  long range = 0;
  int another_range;
d3297 1
a3297 1
	      if ((reg = reg_required_here (&str, -1)) == FAIL)
d3401 1
a3401 1
     char *str;
d3447 1
a3447 1
     char *str;
d3456 1
a3456 1
  if (my_get_expression (&inst.reloc.exp, &str))
d3470 1
a3470 1
     char *str;
d3533 1
a3533 1
     char *str;
d3541 1
a3541 1
    char *save_in;
d3579 1
a3579 1
     char *str;
d3600 1
a3600 1
     char *str;
d3662 1
a3662 1
     char *str;
d3700 1
a3700 1
     char *str;
d3767 1
a3767 1
     char *str;
d3788 1
a3788 1
     char *str;
d3830 1
a3830 1
     char *str;
d3970 1
a3970 1
     char *str;
d4019 1
a4019 1
     char *str;
d4060 1
a4060 1
     char *str;
d4087 1
a4087 1
     char *str;
d4128 1
a4128 1
     char *str;
d4197 2
a4198 2
     char *str;
     int subtract;
d4365 2
a4366 2
     char *str;
     int shift;
d4384 1
a4384 1
      str++;
a4442 1

d4474 2
a4475 2
     char *str;
     int move;
d4562 3
a4564 3
     char *str;
     int load_store;
     int size;
d4615 1
a4615 1
      if (my_get_expression (&inst.reloc.exp, &str))
d4620 1
a4620 1
      if (inst.reloc.exp.X_op != O_constant
d4762 1
a4762 1
     char *str;
d4775 1
a4775 1
     char *str;
d4824 1
a4824 1
     char *str;
d4831 1
a4831 1
     char *str;
d4838 1
a4838 1
     char *str;
d4849 1
a4849 1
     char *str;
d4862 1
a4862 1
     symbolS *symbolP;
d4864 3
a4866 3
  char *real_start;
  const char *name = S_GET_NAME (symbolP);
  symbolS *new_target;
d4898 1
a4898 1
     char *str;
d4900 1
a4900 1
  if (my_get_expression (&inst.reloc.exp, &str))
d4911 1
a4911 1
  if (inst.reloc.exp.X_op == O_symbol
d4921 1
a4921 1
     char *str;
d4942 1
a4942 1
     char *str;
d4949 1
a4949 1
     char *str;
d4992 1
a4992 1
     char *str;
d4999 1
a4999 1
     char *str;
d5006 1
a5006 1
     char *str;
d5013 1
a5013 1
     char *str;
d5038 1
a5038 1
     char *str;
d5045 1
a5045 1
     char *str;
d5052 1
a5052 1
     char *str;
d5059 1
a5059 1
     char *str;
d5103 1
a5103 1
     char *str;
d5110 1
a5110 1
     char *str;
d5117 1
a5117 1
     char *str;
d5124 1
a5124 1
     char *str;
d5131 1
a5131 1
     char *str;
d5145 1
a5145 1
     char *str;
d5176 4
a5179 4
  int len = strlen (reg_table[entry].name) + 2;
  char *buf  = (char *) xmalloc (len);
  char *buf2 = (char *) xmalloc (len);
  int i = 0;
d5192 2
a5193 2
  hash_insert (arm_reg_hsh, buf,  (PTR) &reg_table[entry]);
  hash_insert (arm_reg_hsh, buf2, (PTR) &reg_table[entry]);
d5228 1
a5228 1
  if ((arm_ops_hsh = hash_new ()) == NULL
d5315 1
a5315 1
     char *buf;
d5317 1
a5317 1
     int n;
d5327 2
a5328 2
     char *buf;
     int n;
d5331 1
a5331 1
  unsigned char *where = (unsigned char *) buf;
d5369 3
a5371 3
     char type;
     char *litP;
     int *sizeP;
d5442 1
a5442 1
     fixS *fixP;
d5486 1
a5486 1
     char *name ATTRIBUTE_UNUSED;
d5498 1
a5498 1
				   (valueT) 0, &zero_address_frag);
d5513 1
a5513 1
     register char **ccp;
d5515 4
a5518 4
  char *start = *ccp;
  char c;
  char *p;
  struct reg_entry *reg;
d5553 11
a5563 11
     fixS *fixP;
     valueT *val;
     segT seg;
{
  offsetT value = *val;
  offsetT newval;
  unsigned int newimm;
  unsigned long temp;
  int sign;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  arm_fix_data *arm_data = (arm_fix_data *) fixP->tc_fix_data;
d5631 1
a5631 1
	    && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
d5635 1
a5635 1
	    newimm = validate_immediate_twopart (value, &highpart);
d5642 1
a5642 1
	    else if (validate_immediate_twopart (- value, &highpart) != (unsigned int) FAIL)
d5786 1
a5786 1
#define SEXT24(x)	((((x) & 0xffffff) ^ (~0x7fffff)) + 0x800000)
d5797 2
a5798 2
      if ((value & ~((offsetT) 0x1ffffff)) != 0
	  && ((value & ~((offsetT) 0x1ffffff)) != ~((offsetT) 0x1ffffff)))
d5817 1
a5817 1
	      value = *val;
d5822 2
a5823 2
	      if ((value & ~((offsetT) 0x1ffffff)) == ~((offsetT) 0x1ffffff)
		  || (value & ~((offsetT) 0x1ffffff)) == 0)
d5836 2
a5837 2
      if ((value & ~((offsetT) 0xffffff)) != 0
	  && ((value & ~((offsetT) 0xffffff)) != ~((offsetT) 0xffffff)))
d6055 3
a6057 3
	   3bit ADD/SUB
	   8bit ADD/SUB
	   9bit ADD/SUB SP word-aligned
d6160 2
a6161 2
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d6163 1
a6163 1
  arelent *reloc;
d6253 2
a6254 1
	char *type;
d6307 2
a6308 2
     fragS *fragP ATTRIBUTE_UNUSED;
     segT segtype ATTRIBUTE_UNUSED;
d6317 1
a6317 1
  char *to = NULL;
d6344 1
a6344 1
		 inst.size, &inst.reloc.exp, inst.reloc.pc_rel,
d6352 1
a6352 1
     char *str;
d6354 4
a6357 4
  char c;
  char *p;
  char *q;
  char *start;
d6360 1
a6360 1
     This may not be the right thing to do but...  */
d6393 1
a6393 1
      CONST struct thumb_opcode *opcode;
d6418 1
a6418 1
      CONST struct asm_opcode *opcode;
d6439 1
a6439 1
	      char *r;
d6481 2
a6482 1
			as_tsktsk (_("Warning: Use of the 'nv' conditional is deprecated\n"));
d6582 3
a6584 3
      int reg;
      char *copy_of_str = str;
      char *r;
d6599 1
a6599 1
	  regnum = arm_reg_parse (&q);
d6602 1
a6602 1
	  reg = arm_reg_parse (&str);
d6635 27
a6661 28
 *    Invocation line includes a switch not recognized by the base assembler.
 *    See if it's a processor-specific option.  These are:
 *    Cpu variants, the arm part is optional:
 *            -m[arm]1                Currently not supported.
 *            -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
 *            -m[arm]3                Arm 3 processor
 *            -m[arm]6[xx],           Arm 6 processors
 *            -m[arm]7[xx][t][[d]m]   Arm 7 processors
 *            -m[arm]8[10]            Arm 8 processors
 *            -m[arm]9[20][tdmi]      Arm 9 processors
 *            -mstrongarm[110[0]]     StrongARM processors
 *            -m[arm]v[2345[t]]       Arm architectures
 *            -mall                   All (except the ARM1)
 *    FP variants:
 *            -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions
 *            -mfpe-old               (No float load/store multiples)
 *            -mno-fpu                Disable all floating point instructions
 *    Run-time endian selection:
 *            -EB                     big endian cpu
 *            -EL                     little endian cpu
 *    ARM Procedure Calling Standard:
 *	      -mapcs-32		      32 bit APCS
 *	      -mapcs-26		      26 bit APCS
 *	      -mapcs-float	      Pass floats in float regs
 *	      -mapcs-reentrant        Position independent code
 *            -mthumb-interwork       Code supports Arm/Thumb interworking
 *            -moabi                  Old ELF ABI
 */
d6663 1
a6663 1
CONST char *md_shortopts = "m:k";
d6684 2
a6685 2
     int c;
     char *arg;
d6687 1
a6687 1
  char *str = arg;
d6854 1
a6854 1
	      switch (strtol (str, &str, 10))
d7020 1
a7020 1
     FILE *fp;
d7059 6
a7064 6
     fragS *frag;
     int where;
     short int size;
     expressionS *exp;
     int pc_rel;
     int reloc;
d7066 2
a7067 2
  fixS *new_fix;
  arm_fix_data *arm_data;
d7086 1
a7086 1
  arm_data = (arm_fix_data *) obstack_alloc (&notes, sizeof (arm_fix_data));
d7097 4
a7100 4
     fragS *frag;
     int where;
     int size;
     expressionS *exp;
d7151 1
a7151 1
     symbolS *sym;
d7181 1
a7181 1
  symbolS *sym;
d7190 2
a7191 3
	      if (S_GET_STORAGE_CLASS (sym) == C_STAT
		  /* This can happen!  */
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)
d7200 15
a7214 16
	  else
	    switch (S_GET_STORAGE_CLASS (sym))
	      {
	      case C_EXT:
		S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
		break;
	      case C_STAT:
		S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
		break;
	      case C_LABEL:
		S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
		break;
	      default:
		/* Do nothing.  */
		break;
	      }
d7327 1
a7327 1
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d7355 2
a7356 2
     symbolS *symp;
     int *puntp;
d7363 1
a7363 1
     struct fix *fixp;
d7365 1
a7365 1
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d7379 2
a7380 2
  char id[16];
  char *ip;
d7384 2
a7385 2
    char *str;
    int len;
d7438 1
a7438 1
      expression (&exp);
d7465 1
a7465 1
  input_line_pointer--;
@


1.50
log
@2000-08-01  Kazu Hirata  <kazu@@hxi.com>

	* config/obj-som.c: Fix formatting.
	* config/obj-ieee.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2107 1
a2107 1
    skip = 7;
@


1.49
log
@* config/tc-arm.c (psrs): Accept combinations of flags.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.
d29 1
a29 1
/* need TARGET_CPU */
d46 3
a48 3
#define ARM_7		ARM_6           /* same core instruction set */
#define ARM_8		ARM_6           /* same core instruction set */
#define ARM_9		ARM_6           /* same core instruction set */
d51 5
a55 5
/* The following bitmasks control CPU extensions (ARM7 onwards): */
#define ARM_LONGMUL	0x00000010	/* allow long multiplies */
#define ARM_HALFWORD    0x00000020	/* allow half word loads */
#define ARM_THUMB       0x00000040	/* allow BX instruction  */
#define ARM_EXT_V5	0x00000080	/* allow CLZ etc	 */
d66 1
a66 1
#define ARM_ALL		ARM_2UP		/* Not arm1 only */
d68 1
a68 1
#define ARM_6UP		0x00fffff8      /* Includes ARM7 */
d75 3
a77 3
/* Some useful combinations  */
#define FPU_ALL		0xff000000	/* Note this is ~ARM_ANY */
#define FPU_MEMMULTI	0x7f000000	/* Not fpu_core */
a78 1
     
d92 1
a92 1
#define skip_whitespace(str)  while (* (str) == ' ') ++ (str)
d94 1
a94 1
static unsigned long	cpu_variant = CPU_DEFAULT | FPU_DEFAULT;
d98 5
a102 5
/* Flags stored in private area of BFD structure */
static boolean		uses_apcs_26 = false;
static boolean		support_interwork = false;
static boolean		uses_apcs_float = false;
static boolean		pic_code = false;
d124 3
a126 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d135 2
a136 1
symbolS * GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
d139 8
a146 1
CONST int md_reloc_size = 8;	/* Size of relocation record */
a147 3
static int thumb_mode = 0;      /* 0: assemble for ARM, 1: assemble for Thumb,
				   2: assemble for Thumb even though target cpu
				   does not support thumb instructions.  */
d155 1
a155 1
  CONST char *  error;
d157 2
a158 2
  int           suffix;
  int           size;
d160 5
a164 5
    {
      bfd_reloc_code_real_type type;
      expressionS              exp;
      int                      pc_rel;
    } reloc;
d171 1
a171 1
  CONST char *  template;
d196 1
a196 1
CONST char * fp_const[] = 
d226 1
a226 1
  CONST char *  template;
d233 1
a233 1
static CONST struct asm_cond conds[] = 
d258 5
a262 2
  CONST char *  template;	/* Basic flag string */
  unsigned long set_bits;	/* Bits to set */
d387 2
a388 2
  CONST char *  template;
  boolean       cpsr;
d392 5
a396 2
#define SPSR_BIT   (1 << 22)  /* The bit that distnguishes CPSR and SPSR.  */
#define PSR_SHIFT  16  /* How many bits to shift the PSR_xxx bits up by.  */
d412 1
a412 1
  {"SPSR_f",    false, PSR_f}, 
d551 1
a551 1
  {"spsr_f",    false, PSR_f}, 
d559 1
a559 1
/* ARM instructions */
d567 1
a567 1
/* Pseudo Op codes */			       		      
d571 1
a571 1
/* ARM 2 */				       		      
d574 1
a574 1
/* ARM 3 */				       		      
d576 1
a576 1
/* ARM 6 */				       		      
d579 1
a579 1
/* ARM 7M */				       		      
d581 1
a581 1
/* ARM THUMB */				       		      
d584 1
a584 2
					       		      
/* Coprocessor Instructions */		       		      
d641 1
a641 1
/* LONGEST_INST is the longest basic instruction name without conditions or 
d646 7
d654 9
a662 4
struct asm_opcode 
{
  CONST char *           template;	/* Basic string to match */
  unsigned long          value;		/* Basic instruction code */
d664 2
a665 8
  /* Compulsory suffix that must follow conds. If "", then the
     instruction is not conditional and must have no suffix. */
  CONST char *           comp_suffix;	

  CONST struct asm_flg * flags;	        /* Bits to toggle if flag 'n' set */
  unsigned long          variants;	/* Which CPU variants this exists for */
  /* Function to call to parse args */
  void (*                parms) PARAMS ((char *, unsigned long));
d668 1
a668 1
static CONST struct asm_opcode insns[] = 
d670 1
a670 1
/* ARM Instructions */
d699 2
a700 2
  
/* Pseudo ops */
d705 1
a705 1
/* ARM 2 multiplies */
d709 1
a709 1
/* ARM 3 - swp instructions */
d712 1
a712 1
/* ARM 6 Coprocessor instructions */
d719 1
a719 1
/* ARM 7M long multiplies - need signed/unsigned flags! */
d725 1
a725 1
/* ARM THUMB interworking */
d728 1
a728 1
/* Floating point instructions */
d921 1
a921 1
struct thumb_opcode 
d923 13
a935 5
  CONST char *  template;	/* Basic string to match */
  unsigned long value;		/* Basic instruction code */
  int           size;
  unsigned long          variants;    /* Which CPU variants this exists for */
  void (*       parms) PARAMS ((char *));  /* Function to call to parse args */
d995 1
a995 1
  /* Pseudo ops: */
d997 1
a997 1
  {"nop",       0x46C0,         2,      ARM_THUMB, do_t_nop},      /* mov r8,r8 */
d1002 2
a1003 2
  CONST char * name;
  int          number;
d1014 1
a1014 1
/* These are the standard names.  Users can add aliases with .req  */
d1055 6
a1060 6
static struct hash_control * arm_ops_hsh = NULL;
static struct hash_control * arm_tops_hsh = NULL;
static struct hash_control * arm_cond_hsh = NULL;
static struct hash_control * arm_shift_hsh = NULL;
static struct hash_control * arm_reg_hsh = NULL;
static struct hash_control * arm_psr_hsh = NULL;
d1090 1
a1090 1
  { "req",         s_req,         0 },	/* Never called becasue '.req' does not start line */
d1105 1
a1105 1
#ifdef OBJ_ELF  
d1131 1
a1131 1
symbolS *  last_label_seen;
d1134 1
a1134 1
/* Literal stuff */
d1140 2
a1141 2
  struct expressionS  exp;
  struct arm_it *     inst;
d1144 9
a1152 4
literalT  literals[MAX_LITERAL_POOL_SIZE];
int       next_literal_pool_place = 0; /* Next free entry in the pool */
int       lit_pool_num = 1; /* Next literal pool number */
symbolS * current_poolP = NULL;
d1167 5
a1171 5
          && inst.reloc.exp.X_op == O_constant
          && literals[lit_count].exp.X_add_number
	     == inst.reloc.exp.X_add_number
          && literals[lit_count].exp.X_unsigned == inst.reloc.exp.X_unsigned)
        break;
d1175 1
a1175 1
  if (lit_count == next_literal_pool_place) /* new entry */
d1178 4
a1181 4
        {
          inst.error = _("Literal Pool Overflow");
          return FAIL;
        }
d1193 1
a1193 1
 
d1196 1
d1199 13
a1211 5
     symbolS *    symbolP; 
     CONST char * name;		/* It is copied, the caller can modify */
     segT         segment;	/* Segment identifier (SEG_<something>) */
     valueT       valu;		/* Symbol value */
     fragS *      frag;		/* Associated fragment */
d1214 1
a1214 1
  char * preserved_copy_of_name;
d1216 2
a1217 1
  name_length = strlen (name) + 1;      /* +1 for \0 */
d1245 1
a1245 1
  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);
d1252 1
a1252 1
 
d1255 1
a1255 1
#endif /* DEBUG_SYMS */
d1258 3
a1260 2
/* Check that an immediate is valid, and if so,
   convert it to the right format.  */
d1267 1
a1267 1
  
d1269 1
a1269 1
  
d1272 3
a1274 2
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const] */
  
d1281 1
d1285 1
a1285 1
     unsigned int * highpart;
d1289 1
a1289 1
  
d1295 1
a1295 1
	    if (a & ~ 0xffff)
d1297 1
a1297 1
	    * highpart = (a  >> 8) | ((i + 24) << 7);
d1303 1
a1303 2

	    * highpart = (a >> 16) | ((i + 16) << 7);
d1308 1
a1308 2

	    * highpart = (a >> 24) | ((i + 8) << 7);
d1313 1
a1313 1
  
d1323 1
a1323 1
     return FAIL;
a1326 1
    
d1339 1
a1339 1
     marking in_bss, then looking at s_skip for clues?.. */
d1348 2
a1349 1
  if (!need_pass_2)		/* Never make frag if expect extra pass. */
d1351 1
a1351 1
  
d1353 1
a1353 1
  
d1367 2
a1368 2
  /* Align pool as you have word accesses */
  /* Only make a frag if we have to ... */
d1381 1
a1381 1
  
d1385 1
a1385 1
  
d1388 1
a1388 1
    emit_expr (&(literals[lit_count++].exp), 4); /* .word */
d1394 2
d1397 1
a1397 1
s_align (unused)	/* Same as s_align_ptwo but align 0 => align 2 */
d1424 1
a1424 1
  /* Only make a frag if we HAVE to. . . */
d1441 1
a1441 1
     
d1445 1
a1445 1
      
d1448 1
a1448 1
  
d1476 7
a1482 10
  register char *    name;
  register char      delim;
  register char *    end_name;
  register symbolS * symbolP;

  /*
   * Especial apologies for the random logic:
   * this just grew, and could be parsed much more simply!
   * Dean in haste.
   */
d1487 1
a1487 1
  
d1504 1
a1504 1
      /* XXX - this should not happen to .thumb_set  */
d1517 3
a1519 3
	  extern struct list_info_struct * listing_tail;
	  fragS * dummy_frag = (fragS *) xmalloc (sizeof(fragS));
	  memset (dummy_frag, 0, sizeof(fragS));
d1527 2
a1528 2
        symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
			    
d1530 1
a1530 1
      /* "set" symbols are local unless otherwise specified. */
d1532 2
a1533 2
#endif /* OBJ_COFF */
    }				/* make a new symbol */
d1537 1
a1537 1
  * end_name = delim;
d1545 1
a1545 1
  
d1549 1
a1549 1
  
d1558 1
d1565 1
a1565 1
  
d1584 1
a1584 1
  
d1615 3
a1617 3
          /* No need to force the alignment, since we will have been
             coming from ARM mode, which is word-aligned. */
          record_alignment (now_seg, 1);
d1624 1
a1624 1
          if ((cpu_variant & ARM_ANY) == ARM_THUMB)
d1627 3
a1629 3
          if (!need_pass_2)
            frag_align (2, 0, 0);
          record_alignment (now_seg, 1);
d1675 1
a1675 1
     char * str;
d1679 1
a1679 1
  if (* str != '\0')
d1685 1
a1685 1
     char ** str;
d1689 1
a1689 1
    
d1705 4
a1708 3
   Shift is the place to put it in inst.instruction.
   Restores input start point on err.
   Returns the reg#, or FAIL.  */
d1711 2
a1712 2
     char ** str;
     int     shift;
d1714 3
a1716 3
  static char buff [128]; /* XXX */
  int    reg;
  char * start = *str;
d1727 1
a1727 1
  
d1738 1
a1738 1
     register char ** ccp;
d1740 4
a1743 4
  char * start = * ccp;
  char   c;
  char * p;
  CONST struct asm_psr * psr;
d1771 1
d1774 1
a1774 1
     char ** str;
d1776 3
a1778 3
  char * start = *str;
  CONST struct asm_psr * psr;
  
d1789 1
a1789 1
      
d1804 1
a1804 1
     char ** str;
d1808 1
a1808 1
  skip_whitespace (* str);
d1848 1
a1848 1
  skip_whitespace (* str);
d1872 2
a1873 2
     char ** str;
     int     where;
d1875 2
a1876 2
  int    reg;
  char * start = *str;
d1896 2
a1897 2
     char ** str;
     int     where;
d1900 1
a1900 1
  char * start = *str;
d1920 1
a1920 1
     char ** str;
d1924 1
a1924 1
  skip_whitespace (* str);
d1933 2
a1934 2
  
  if (my_get_expression (& inst.reloc.exp, str))
d1936 1
a1936 1
  
d1940 1
a1940 1
      
d1968 1
a1968 1
     char ** str;
d1970 3
a1972 3
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;
d1981 1
a1981 1
      if ((reg = reg_required_here (& p, 16)) == FAIL)
d1989 2
a1990 2
	  
	  if (skip_past_comma (& p) == SUCCESS)
d1992 1
a1992 1
	      /* [Rn], #expr */
d1994 1
a1994 1
	      
d2001 1
a2001 1
	      if (cp_address_offset (& p) == FAIL)
d2009 1
a2009 1
	  /* '['Rn, #expr']'[!] */
d2011 1
a2011 1
	  if (skip_past_comma (& p) == FAIL)
d2018 2
a2019 2
	  
	  if (cp_address_offset (& p) == FAIL)
d2051 1
a2051 1
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust */
d2064 1
a2064 1
     char * str;
d2079 1
a2079 1
  
d2097 1
a2097 1
  if (   strcmp (str, "CPSR") == 0
d2099 1
a2099 1
	 /* Lower case versions for backwards compatability.  */
d2103 1
d2114 1
a2114 1
  if (* str == 's' || * str == 'S')
d2117 1
a2117 1
  
d2125 1
d2128 1
a2128 1
     char * str;
d2133 1
a2133 1
  if (psr_required_here (& str) == FAIL)
d2135 2
a2136 2
    
  if (skip_past_comma (& str) == FAIL)
d2144 1
a2144 1
  if (reg_required_here (& str, 0) != FAIL)
d2146 1
a2146 1
      inst.error = NULL; 
d2152 1
a2152 1
  if (! is_immediate_prefix (* str))
d2154 2
a2155 1
      inst.error = _("only a register or immediate value can follow a psr flag");
d2159 1
a2159 1
  str ++;
d2161 2
a2162 2
  
  if (my_get_expression (& inst.reloc.exp, & str))
d2164 2
a2165 1
      inst.error = _("only a register or immediate value can follow a psr flag");
d2168 1
a2168 1
  
d2174 1
a2174 1
  
d2176 1
a2176 1
	  
d2185 1
a2185 1
      
d2191 1
a2191 1
      
d2195 1
a2195 1
  inst.error = NULL; 
d2205 2
a2206 1
*/   
d2209 1
a2209 1
     char * str;
d2214 1
a2214 1
  /* Only one format "rdlo, rdhi, rm, rs" */
d2237 1
a2237 1
  /* rdhi, rdlo and rm must all be different */
d2253 1
a2253 1
   
d2261 1
a2261 1
     char *        str;
d2265 2
a2266 2
  
  /* Only one format "rd, rm, rs" */
d2317 1
a2317 1
     char *        str;
d2322 1
a2322 1
  /* Only one format "rd, rm, rs, rn" */
d2373 3
a2375 2
/* Returns the index into fp_values of a floating point number, or -1 if
   not in the table.  */
d2378 1
a2378 1
     char ** str;
d2381 4
a2384 4
  char *         save_in;
  expressionS    exp;
  int            i;
  int            j;
d2387 2
a2388 1
  /* Look for a raw floating point number */
d2390 1
a2390 1
      && is_end_of_line [(unsigned char) *save_in])
d2409 1
a2409 1
     unless the code uses a floating point prefix (eg "0f") */
d2418 1
a2418 1
      if (gen_to_words (words, 5, (long)15) == 0)
d2443 2
a2444 1
/* Return true if anything in the expression is a bignum */
d2447 1
a2447 1
     symbolS * sp;
d2464 2
a2465 2
     expressionS * ep;
     char ** str;
d2467 3
a2469 3
  char * save_in;
  segT   seg;
  
d2508 2
a2509 2
/* unrestrict should be one if <shift> <register> is permitted for this
   instruction */
d2513 2
a2514 2
     char ** str;
     int     unrestrict;
d2516 6
a2521 6
  struct asm_shift * shft;
  char * p;
  char   c;
    
  skip_whitespace (* str);
    
d2546 1
a2546 1
      
d2553 1
a2553 1
      else if (is_immediate_prefix (* p))
d2560 1
a2560 1
	  /* Validate some simple #expressions */
d2565 1
a2565 1
	      /* Reject operations greater than 32, or lsl #32 */
d2572 2
a2573 1
	      /* Shifts of zero should be converted to lsl (which is zero)*/
d2598 3
a2600 2
	  inst.error = unrestrict ? _("shift requires register or #expression")
	    : _("shift requires #expression");
d2610 2
a2611 2
/* Do those data_ops which can take a negative immediate constant */
/* by altering the instuction. A bit of a hack really */
d2620 1
d2623 2
a2624 2
     unsigned long * instruction;
     unsigned long   value;
d2635 2
a2636 2
      /* First negates */
    case OPCODE_SUB:             /* ADD <-> SUB */
d2641 2
a2642 2
    case OPCODE_ADD: 
      new_inst = OPCODE_SUB;               
d2646 1
a2646 1
    case OPCODE_CMP:             /* CMP <-> CMN */
d2651 2
a2652 2
    case OPCODE_CMN: 
      new_inst = OPCODE_CMP;               
d2656 3
a2658 3
      /* Now Inverted ops */
    case OPCODE_MOV:             /* MOV <-> MVN */
      new_inst = OPCODE_MVN;               
d2662 1
a2662 1
    case OPCODE_MVN: 
d2667 2
a2668 2
    case OPCODE_AND:             /* AND <-> BIC */ 
      new_inst = OPCODE_BIC;               
d2672 1
a2672 1
    case OPCODE_BIC: 
d2677 2
a2678 2
    case OPCODE_ADC:              /* ADC <-> SBC */
      new_inst = OPCODE_SBC;               
d2682 1
a2682 1
    case OPCODE_SBC: 
d2687 2
a2688 2
      /* We cannot do anything */
    default:  
d2697 1
a2697 1
  return value; 
d2702 1
a2702 1
     char ** str;
d2707 2
a2708 2
  skip_whitespace (* str);
    
d2719 1
a2719 1
      /* Immediate expression */
d2724 1
a2724 1
	  
d2737 1
a2737 1
		  /* #x, y -- ie explicit rotation by Y  */
d2746 2
a2747 2
 
		  /* Rotate must be a multiple of 2 */
d2761 1
a2761 1
	      /* Implicit rotation, select a suitable one  */
d2766 2
a2767 2
		  /* Can't be done, perhaps the code reads something like
		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be ok */
d2792 1
a2792 1
     char ** str;
d2794 1
a2794 1
  skip_whitespace (* str);
d2800 1
a2800 1
      /* Immediate expression */
d2807 1
a2807 1
	  skip_whitespace (* str);
d2809 2
a2810 2
	  /* First try and match exact strings, this is to guarantee that
	     some formats will work even for cross assembly */
d2841 2
a2842 1
      inst.error = _("Floating point register or immediate expression expected");
d2849 1
a2849 1
     char *        str;
d2872 1
a2872 1
     char *        str;
d2887 1
a2887 1
  
d2894 1
a2894 1
  
d2900 1
a2900 1
     char *        str;
d2906 1
a2906 1
     	add rd, rd, #high(label-.-8)"   */
d2910 3
a2912 3
  if (reg_required_here (& str, 12) == FAIL
      || skip_past_comma (& str) == FAIL
      || my_get_expression (& inst.reloc.exp, & str))
d2918 1
a2918 1
  
d2920 1
a2920 1
  
d2924 1
a2924 1
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust */
d2928 1
a2928 1
  
d2934 1
a2934 1
     char *        str;
d2964 1
a2964 1
     char *        str;
d2991 2
a2992 2
     char ** str;
     int     hwse;
d3001 1
a3001 1
      if (my_get_expression (& inst.reloc.exp, str))
d3008 2
a3009 2
          if ((hwse && (value < -255 || value > 255))
               || (value < -4095 || value > 4095))
d3021 7
a3027 6
          /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0 */
          if (hwse)
            inst.instruction |= add | HWOFFSET_IMM | ((value >> 4) << 8) | (value & 0xF);
          else
            inst.instruction |= add | value;
d3031 7
a3037 7
          if (hwse)
            {
              inst.instruction |= HWOFFSET_IMM;
              inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
            }
          else
            inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d3043 3
a3045 1
      add = 0;	/* and fall through */
d3047 3
a3049 1
      (*str)++;	/* and fall through */
d3055 1
a3055 1
        inst.instruction |= add;
d3057 5
a3061 5
        {
          inst.instruction |= add | OFFSET_REG;
          if (skip_past_comma (str) == SUCCESS)
            return decode_shift (str, SHIFT_RESTRICT);
        }
d3069 1
a3069 1
     char *        str;
d3079 1
a3079 1
     encoding, but the same mnemonic): */
d3084 1
a3084 1
         signed-extension load */
d3086 2
a3087 2
        {
          inst.error
d3089 2
a3090 2
          return;
        }
d3092 2
a3093 2
      inst.instruction = (inst.instruction & COND_MASK)
                         | (flags & ~COND_MASK);
d3099 2
a3100 2
    
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d3107 1
a3107 1
  if (skip_past_comma (& str) == FAIL)
d3131 2
a3132 2
	  str ++;
	  
d3135 1
a3135 1
	      /* [Rn],... (post inc) */
d3140 2
a3141 1
			 (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
d3145 15
a3159 14
	      /* [Rn] */
              if (halfword)
                inst.instruction |= HWOFFSET_IMM;

              skip_whitespace (str);

              if (*str == '!')
               {
                 if (conflict_reg)
		   as_warn (_("%s register same as write-back base"),
			    (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
                 str++;
                 inst.instruction |= WRITE_BACK;
               }
d3168 1
a3168 1
	  /* [Rn,...] */
d3193 2
a3194 1
			 (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
d3202 1
a3202 1
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op */
d3218 1
a3218 1
	  && (value = validate_immediate(inst.reloc.exp.X_add_number)) != FAIL)
d3220 1
a3220 1
	  /* This can be done with a mov instruction */
d3224 2
a3225 2
	  end_of_line(str);
	  return; 
d3229 1
a3229 1
	  /* Insert into literal pool */     
d3233 1
a3233 1
		inst.error = _("literal pool insertion failed"); 
d3237 7
a3243 7
	  /* Change the instruction exp to point to the pool */
          if (halfword)
            {
              inst.instruction |= HWOFFSET_IMM;
              inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
            }
          else
d3247 1
a3247 1
	  pre_inc = 1; 
d3256 4
a3259 4
        {
          inst.instruction |= HWOFFSET_IMM;
          inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
        }
d3261 1
a3261 1
        inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d3263 2
a3264 1
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust */
d3270 1
a3270 1
    
d3281 1
a3281 1
     char ** strp;
d3283 3
a3285 3
  char * str = *strp;
  long   range = 0;
  int    another_range;
d3287 1
a3287 1
  /* We come back here if we get ranges concatenated by '+' or '|' */
d3296 1
a3296 1
      
d3301 1
a3301 1
	    
d3304 1
a3304 1
	      if ((reg = reg_required_here (& str, -1)) == FAIL)
d3306 1
a3306 1
	      
d3310 1
a3310 1
	      
d3320 1
a3320 1
			as_tsktsk 
d3337 3
a3339 2
	    } while (skip_past_comma (&str) != FAIL
		     || (in_range = 1, *str++ == '-'));
d3358 1
a3358 1
	      if (expr.X_add_number 
d3371 1
a3371 1
		  as_tsktsk 
d3399 2
a3400 1
    } while (another_range);
d3408 1
a3408 1
     char *        str;
d3454 1
a3454 1
     char *        str;
d3458 1
a3458 1
  
d3463 1
a3463 1
  if (my_get_expression (& inst.reloc.exp, & str))
d3469 1
a3469 1
  
d3471 1
a3471 1
  
d3477 1
a3477 1
     char *        str;
d3481 1
a3481 1
  
d3540 1
a3540 1
     char *        str;
d3545 1
a3545 1
  
d3548 6
a3553 6
    char * save_in;
  
    /* ScottB: February 5, 1998 */
    /* Check to see of PLT32 reloc required for the instruction.  */
    
    /* arm_parse_reloc() works on input_line_pointer.
d3578 2
a3579 2
#endif /* OBJ_ELF */
  
d3586 1
a3586 1
     char *        str;
d3607 1
a3607 1
     char *        str;
d3669 1
a3669 1
     char *        str;
d3707 1
a3707 1
     char *        str;
d3774 1
a3774 1
     char *        str;
d3795 1
a3795 1
     char *        str;
d3837 1
a3837 1
     char *        str;
d3851 1
a3851 1
  /* Get Number of registers to transfer */
d3930 2
a3931 1
	      inst.error = _("R15 not allowed as base register with write-back");
d3940 1
a3940 1
	  /* Pre-decrement */
d3947 1
a3947 1
	  /* Post-increment */
d3977 1
a3977 1
     char *        str;
d4026 1
a4026 1
     char *        str;
d4067 1
a4067 1
     char *        str;
d4094 1
a4094 1
     char *        str;
d4135 1
a4135 1
     char *        str;
d4156 1
a4156 1
/* Thumb specific routines */
d4159 3
a4161 3
   repeated checking of this information in many similar cases. 
   Unlike the 32-bit case we do not insert the register into the opcode 
   here, since the position is often unknown until the full instruction 
d4163 1
d4201 1
d4204 2
a4205 2
     char * str;
     int    subtract;
d4233 2
a4234 2
	  /* Two operand format, shuffle the registers and pretend there 
	     are 3 */
d4249 1
a4249 1
     for the latter case, EXPR contains the immediate that was found. */
d4261 1
a4261 1
	  /* Can't do this for SUB */
d4295 1
a4295 1
	     we know about in the instruction and let the reloc hacking 
d4312 1
a4312 1
	      /* Quick check, in case offset is MIN_INT */
d4366 1
a4366 1
  
d4372 2
a4373 2
     char * str;
     int    shift;
d4391 1
a4391 1
      str ++;
d4397 1
a4397 1
      if ((Rs =  thumb_reg (&str, THUMB_REG_LO)) == FAIL)
d4402 2
a4403 2
	  /* Two operand format, shuffle the registers and pretend there
	     are 3 */
d4418 1
a4418 1
     for the latter case, EXPR contains the immediate that was found. */
d4449 1
a4449 1
	     hacking fix it up */
d4463 1
a4463 1
	  /* Shifts of zero are handled by converting to LSL */
d4467 1
a4467 1
	  /* Shifts of 32 are encoded as a shift of zero */
d4476 1
a4476 1
  
d4482 2
a4483 2
     char * str;
     int    move;
d4512 1
a4512 1
	       since a MOV instruction produces unpredictable results */
d4570 3
a4572 3
     char * str;
     int    load_store;
     int    size;
d4618 1
a4618 1
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op */
d4623 1
a4623 1
      if (my_get_expression (& inst.reloc.exp, & str))
d4627 2
a4628 2
      
      if (   inst.reloc.exp.X_op != O_constant
d4638 1
a4638 1
	  /* This can be done with a mov instruction */
d4642 1
a4642 1
	  return; 
d4645 1
a4645 1
      /* Insert into literal pool */     
d4649 1
a4649 1
	    inst.error = "literal pool insertion failed"; 
d4656 2
a4657 1
      inst.reloc.exp.X_add_number += 4; /* Adjust ARM pipeline offset to Thumb */
d4668 1
a4668 1
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset */
d4722 1
a4722 1
      /* Immediate offset */
d4738 1
a4738 1
	  
d4751 1
a4751 1
      /* Register offset */
d4770 1
a4770 1
     char * str;
d4772 1
a4772 1
  /* Do nothing */
d4777 1
a4777 1
/* Handle the Format 4 instructions that do not have equivalents in other 
d4780 1
d4783 1
a4783 1
     char * str;
d4793 2
a4794 2
    	inst.error = BAD_ARGS;
      	return;
d4805 1
a4805 1
 	  || inst.instruction == T_OPCODE_MVN)
d4832 1
a4832 1
     char * str;
d4839 1
a4839 1
     char * str;
d4846 1
a4846 1
     char * str;
d4857 1
a4857 1
     char * str;
d4870 1
a4870 1
     symbolS * symbolP;
d4872 3
a4874 3
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;
d4876 1
a4876 1
  /* This definiton must agree with the one in gcc/config/arm/thumb.c */
d4880 1
a4880 1
    abort();
d4887 1
a4887 1
  
d4892 1
a4892 1
  
a4903 1

d4906 1
a4906 1
     char * str;
d4908 1
a4908 1
  if (my_get_expression (& inst.reloc.exp, & str))
d4910 1
a4910 1
  
d4919 1
a4919 1
  if (   inst.reloc.exp.X_op == O_symbol
d4923 2
a4924 1
    inst.reloc.exp.X_add_symbol = find_real_start (inst.reloc.exp.X_add_symbol);
d4929 1
a4929 1
     char * str;
d4950 1
a4950 1
     char * str;
d4957 1
a4957 1
     char * str;
d4982 1
a4982 1
      /* This really doesn't seem worth it. */
d5000 1
a5000 1
     char * str;
d5007 1
a5007 1
     char * str;
d5014 1
a5014 1
     char * str;
d5021 1
a5021 1
     char * str;
d5046 1
a5046 1
     char * str;
d5053 1
a5053 1
     char * str;
d5060 1
a5060 1
     char * str;
d5067 1
a5067 1
     char * str;
d5082 1
a5082 1
      /* This really doesn't seem worth it. */
d5111 1
a5111 1
     char * str;
d5118 1
a5118 1
     char * str;
d5125 1
a5125 1
     char * str;
d5132 1
a5132 1
     char * str;
d5139 1
a5139 1
     char * str;
d5153 1
a5153 1
     char * str;
d5176 1
a5176 1
  
d5184 4
a5187 4
  int    len = strlen (reg_table[entry].name) + 2;
  char * buf = (char *) xmalloc (len);
  char * buf2 = (char *) xmalloc (len);
  int    i = 0;
d5200 1
a5200 1
  hash_insert (arm_reg_hsh, buf, (PTR) &reg_table[entry]);
d5210 1
a5210 1
    (struct reg_entry *)xmalloc (sizeof (struct reg_entry));
d5226 1
a5226 1
    if (atof_ieee ((char *)fp_const[i], 'x', fp_values[i]) == NULL)
d5235 2
a5236 2
  
  if (   (arm_ops_hsh = hash_new ()) == NULL
d5243 1
a5243 1
    
d5263 1
a5263 1
    
d5274 1
a5274 1
  
d5281 1
a5281 1
      
d5285 1
a5285 1
      
d5290 1
a5290 1
      
d5295 1
a5295 1
  
d5310 1
a5310 1
  
d5320 1
d5323 1
a5323 1
     char * buf;
d5325 1
a5325 1
     int    n;
d5333 1
a5333 1
static valueT 
d5335 1
a5335 1
     char * buf;
d5339 1
a5339 1
  unsigned char * where = (unsigned char *) buf;
d5362 2
a5363 2
   of type TYPE, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
d5377 3
a5379 3
     char   type;
     char * litP;
     int *  sizeP;
d5445 3
a5447 1
/* The knowledge of the PC's pipeline offset is built into the insns themselves.  */ 
d5450 1
a5450 1
     fixS * fixP;
d5452 1
a5452 1
  if (   fixP->fx_addsy
d5456 1
a5456 1
  
d5474 2
a5475 1
/* Round up a section size to the appropriate boundary. */
d5484 1
a5484 1
  /* Round all sects to multiple of 4 */
d5489 2
a5490 2
/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.  Otherwise 
   we have no need to default values of symbols.  */
a5491 1
/* ARGSUSED */
d5494 1
a5494 1
     char * name ATTRIBUTE_UNUSED;
d5504 1
a5504 1
	  
d5506 1
a5506 1
				   (valueT)0, & zero_address_frag);
d5508 1
a5508 1
      
d5512 1
a5512 1
  
d5516 2
a5517 2
/* arm_reg_parse () := if it looks like a register, return its token and 
   advance the pointer. */
d5521 1
a5521 1
     register char ** ccp;
d5523 4
a5526 4
  char * start = * ccp;
  char   c;
  char * p;
  struct reg_entry * reg;
d5549 1
a5549 1
  
d5561 11
a5571 11
     fixS *      fixP;
     valueT *    val;
     segT        seg;
{
  offsetT        value = * val;
  offsetT        newval;
  unsigned int   newimm;
  unsigned long  temp;
  int            sign;
  char *         buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  arm_fix_data * arm_data = (arm_fix_data *) fixP->tc_fix_data;
d5576 3
a5578 1
#if 0 /* patch from REarnshaw to JDavis (disabled for the moment, since it doesn't work fully) */
d5597 2
a5598 2
		|| fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
		))
d5605 2
a5606 1
  fixP->fx_addnumber = value;	/* Remember value for emit_reloc.  */
d5632 1
a5632 1
	unsigned int newinsn  = 0xe1a00000; /* nop */
d5639 1
a5639 1
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
d5641 3
a5643 2
	    /* No ?  OK - try using two ADD instructions to generate the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);
d5645 2
a5646 1
	    /* Yes - then make sure that the second instruction is also an add.  */
d5650 2
a5651 2
	    else if (validate_immediate_twopart (- value, & highpart) != (unsigned int) FAIL)
		temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
d5656 2
a5657 1
			      _("Unable to compute ADRL instructions for PC offset of 0x%x"), value);
d5661 5
a5665 4
	    /* Replace the first operand in the 2nd instruction (which is the PC)
	       with the destination register.  We have already added in the PC in the
	       first instruction and we do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
d5679 1
a5679 1
      
d5681 2
a5682 2
	value = - value;
      
d5684 6
a5689 5
        {
	  as_bad_where (fixP->fx_file, fixP->fx_line, 
                        _("bad immediate value for offset (%ld)"), (long) value);
          break;
        }
d5697 2
a5698 2
     case BFD_RELOC_ARM_OFFSET_IMM8:
     case BFD_RELOC_ARM_HWLITERAL:
d5700 1
a5700 1
      
d5702 1
a5702 1
	value = - value;
d5705 6
a5710 6
        {
          if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line, 
			_("invalid literal constant: pool needs to be closer"));
          else
            as_bad (_("bad immediate value for half-word offset (%ld)"),
d5712 2
a5713 2
          break;
        }
d5723 1
a5723 1
      
d5725 1
a5725 1
	value = - value;
d5729 1
a5729 1
	  as_bad_where (fixP->fx_file, fixP->fx_line, 
d5743 1
a5743 1
	  || (value == 32 
d5752 2
a5753 1
	newval &= ~0x60;	/* Shifts of zero must be done as lsl */
d5758 1
a5758 1
      md_number_to_chars (buf, newval , INSN_SIZE);
d5774 1
a5774 1
	    as_bad_where (fixP->fx_file, fixP->fx_line, 
d5778 1
a5778 1
	  md_number_to_chars (buf, newval , INSN_SIZE);
d5794 1
a5794 1
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)
d5805 2
a5806 2
      if ((value & ~ ((offsetT) 0x1ffffff)) != 0
	  && ((value & ~ ((offsetT) 0x1ffffff)) != ~ ((offsetT) 0x1ffffff)))
d5815 1
a5815 1
	     
d5825 1
a5825 1
	      value = * val;
d5827 5
a5831 4
	      /* Permit a backward branch provided that enough bits are set.
		 Allow a forwards branch, provided that enough bits are clear.  */
	      if ((value & ~ ((offsetT) 0x1ffffff)) == ~ ((offsetT) 0x1ffffff)
		  || (value & ~ ((offsetT) 0x1ffffff)) == 0)
d5834 1
a5834 1
	  
d5843 3
a5845 3
      
      if ((value & ~ ((offsetT) 0xffffff)) != 0
	  && ((value & ~ ((offsetT) 0xffffff)) != ~ ((offsetT) 0xffffff)))
d5848 1
a5848 1
      
d5856 1
a5856 1
      	newval = md_chars_to_number (buf, INSN_SIZE);
d5859 2
a5860 2
      	if (! target_oabi)
           value = fixP->fx_offset;
d5863 4
a5866 4
      	value  = (value >> 2) & 0x00ffffff;
      	value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;
      	newval = value | (newval & 0xfe000000) | (hbit << 24);
      	md_number_to_chars (buf, newval, INSN_SIZE);
d5870 1
a5870 1
    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* conditional branch */
d5873 9
a5881 9
        addressT diff = (newval & 0xff) << 1;
        if (diff & 0x100)
         diff |= ~0xff;

        value += diff;
        if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
         as_bad_where (fixP->fx_file, fixP->fx_line,
                       _("Branch out of range"));
        newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
d5886 1
a5886 1
    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* unconditional branch */
d5889 9
a5897 9
        addressT diff = (newval & 0x7ff) << 1;
        if (diff & 0x800)
         diff |= ~0x7ff;

        value += diff;
        if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
         as_bad_where (fixP->fx_file, fixP->fx_line,
                       _("Branch out of range"));
        newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
d5905 2
a5906 2
        offsetT newval2;
        addressT diff;
d5909 3
a5911 3
        newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
        diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
        if (diff & 0x400000)
d5916 2
a5917 2
        value += diff;
        if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
d5921 4
a5924 4
        newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
        newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
        md_number_to_chars (buf, newval, THUMB_SIZE);
        md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
d5933 4
a5936 4
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 1);
        }
d5945 4
a5948 4
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 2);
        }
d5955 2
a5956 2
	md_number_to_chars (buf, 0, 4);
	break;
d5965 4
a5968 4
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 4);
        }
d5974 1
a5974 1
      /* It appears the instruction is fully prepared at this point. */
d5981 1
a5981 1
      
d5990 2
a5991 2
      newval |= (value >> 2) | (sign ?  INDEX_UP : 0);
      md_number_to_chars (buf, newval , INSN_SIZE);
d5996 3
a5998 2
      /* Exactly what ranges, and where the offset is inserted depends on
	 the type of instruction, we can establish this from the top 4 bits */
d6001 1
a6001 1
	case 4: /* PC load */
d6011 2
a6012 1
                          (unsigned int)(fixP->fx_frag->fr_address + fixP->fx_where + value));
d6018 1
a6018 1
          /* Round up, since pc will be rounded down.  */
d6022 1
a6022 1
	case 9: /* SP load/store */
d6029 1
a6029 1
	case 6: /* Word load/store */
d6033 1
a6033 1
	  newval |= value << 4; /* 6 - 2 */
d6036 1
a6036 1
	case 7: /* Byte load/store */
d6043 1
a6043 1
	case 8: /* Halfword load/store */
d6047 1
a6047 1
	  newval |= value << 5; /* 6 - 1 */
d6062 5
a6066 4
            3bit ADD/SUB
            8bit ADD/SUB
            9bit ADD/SUB SP word-aligned
           10bit ADD PC/SP word-aligned
d6070 4
a6073 3
           0x8000  SUB
           0x00F0  Rd
           0x000F  Rs
d6077 18
a6094 18
        int rd = (newval >> 4) & 0xf;
        int rs = newval & 0xf;
        int subtract = newval & 0x8000;

        if (rd == REG_SP)
          {
            if (value & ~0x1fc)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _("Invalid immediate for stack address calculation"));
            newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
            newval |= value >> 2;
          }
        else if (rs == REG_PC || rs == REG_SP)
          {
            if (subtract ||
                value & ~0x3fc)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _("Invalid immediate for address calculation (value = 0x%08lX)"),
d6096 20
a6115 20
            newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
            newval |= rd << 8;
            newval |= value >> 2;
          }
        else if (rs == rd)
          {
            if (value & ~0xff)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _("Invalid 8bit immediate"));
            newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
            newval |= (rd << 8) | value;
          }
        else
          {
            if (value & ~0x7)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _("Invalid 3bit immediate"));
            newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
            newval |= rd | (rs << 3) | (value << 6);
          }
d6117 1
a6117 1
      md_number_to_chars (buf, newval , THUMB_SIZE);
d6123 6
a6128 6
        {
        case 0x04: /* 8bit immediate MOV */
        case 0x05: /* 8bit immediate CMP */
          if (value < 0 || value > 255)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("Invalid immediate: %ld is too large"),
d6130 2
a6131 2
          newval |= value;
          break;
d6133 4
a6136 4
        default:
          abort ();
        }
      md_number_to_chars (buf, newval , THUMB_SIZE);
d6140 1
a6140 1
      /* 5bit shift value (0..31) */
d6146 1
a6146 1
      md_number_to_chars (buf, newval , THUMB_SIZE);
d6165 1
d6168 2
a6169 2
     asection * section ATTRIBUTE_UNUSED;
     fixS * fixp;
d6171 1
a6171 1
  arelent * reloc;
d6215 1
a6215 1
    case BFD_RELOC_RVA:      
d6228 1
a6228 1
	 a section boundary - possibly due to an implicit dump */
d6237 2
a6238 2
       code = fixp->fx_r_type;
    break;
d6261 1
a6261 1
	char * type;
d6285 7
a6291 7
 if (code == BFD_RELOC_32_PCREL
     && GOT_symbol
     && fixp->fx_addsy == GOT_symbol)
   {
     code = BFD_RELOC_ARM_GOTPC;
     reloc->addend = fixp->fx_offset = reloc->address;
   }
d6293 1
a6293 1
   
d6304 4
a6307 4
   /* HACK: Since arm ELF uses Rel instead of Rela, encode the
      vtable entry to be used in the relocation's section offset.  */
   if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
     reloc->address = fixp->fx_offset;
d6314 2
a6315 2
     fragS * fragP ATTRIBUTE_UNUSED;
     segT    segtype ATTRIBUTE_UNUSED;
d6324 2
a6325 2
  char * to = NULL;
    
d6333 1
a6333 1
  
d6351 1
a6351 1
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
d6359 1
a6359 1
     char * str;
d6361 4
a6364 4
  char   c;
  char * p;
  char * q;
  char * start;
d6367 5
a6371 3
     This may not be the right thing to do but ... */
  /* arm_align (2, 0); */
  listing_prev_line (); /* Defined in listing.h */
d6385 1
a6385 1
  
d6391 1
a6391 1
    
d6400 1
a6400 1
      CONST struct thumb_opcode * opcode;
d6406 1
a6406 1
      
d6411 4
a6414 4
	     {
	    	as_bad (_("selected processor does not support this opcode"));
		return;
	     }
d6418 1
a6418 1
	  (*opcode->parms)(p);
d6425 1
a6425 1
      CONST struct asm_opcode * opcode;
d6429 1
a6429 1
      /* p now points to the end of the opcode, probably white space, but we
d6442 1
a6442 1
	  
d6446 1
a6446 1
	      char * r;
d6457 6
a6462 6
		       if (*opcode->comp_suffix != '\0')
		    	 as_bad (_("Opcode `%s' must have suffix from list: <%s>"),
			     str, opcode->comp_suffix);
		       else
			 /* Not a conditional instruction. */
		         (*opcode->parms)(q, 0);
d6466 1
a6466 1
		      /* A conditional instruction with default condition. */
d6468 1
a6468 1
		      (*opcode->parms)(q, 0);
d6474 2
a6475 1
	      /* Not just a simple opcode.  Check if extra is a conditional. */
d6488 1
a6488 2
			as_tsktsk (
_("Warning: Use of the 'nv' conditional is deprecated\n"));
d6499 1
a6499 1
	      /* Apply the conditional, or complain it's not allowed. */
d6502 6
a6507 6
		   /* Instruction isn't conditional */
		   if (cond_code != COND_ALWAYS)
		     {
		       as_bad (_("Opcode `%s' is unconditional\n"), str);
		       return;
		     }
d6510 2
a6511 3
		/* Instruction is conditional: set the condition into it. */
		inst.instruction |= cond_code;	     

d6513 2
a6514 2
	      /* If there is a compulsory suffix, it should come here, before
		 any optional flags.  */
d6529 2
a6530 2
		      as_bad (_("Opcode `%s' must have suffix from <%s>\n"), str,
			      opcode->comp_suffix);
d6579 1
a6579 1
     alias .req reg */
d6585 1
a6585 1
    
d6588 4
a6591 4
      int    reg;
      char * copy_of_str = str;
      char * r;
      
d6598 1
a6598 1
      
d6605 1
a6605 1
	  regnum = arm_reg_parse (& q);
d6608 2
a6609 2
	  reg = arm_reg_parse (& str);
	  
d6621 2
a6622 2
			 copy_of_str );
	      
d6631 1
a6631 1
      
d6640 1
a6640 2
/*
 * md_parse_option
d6670 2
a6671 1
CONST char * md_shortopts = "m:k";
d6686 1
d6691 2
a6692 2
     int    c;
     char * arg;
d6694 1
a6694 1
  char * str = arg;
d6727 16
a6742 16
        case 'o':
          if (streq (str, "oabi"))
            target_oabi = true;
          break;
#endif
	  
        case 't':
          /* Limit assembler to generating only Thumb instructions: */
          if (streq (str, "thumb"))
            {
              cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_THUMB;
              cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_NONE;
              thumb_mode = 1;
            }
          else if (streq (str, "thumb-interwork"))
            {
d6746 1
a6746 1
              support_interwork = true;
d6748 2
a6749 2
            }
          else
d6751 1
a6751 1
          break;
d6766 1
a6766 1
	      
d6806 1
a6806 1
		     position independent code with absolute position code. */
d6810 1
a6810 1
	      
d6813 1
a6813 1
  	    }
d6815 1
a6815 1
	  /* Strip off optional "arm" */
d6860 2
a6861 1
	      switch (strtol (str, & str, 10))	/* Eat the processor name */
d6874 26
a6899 17
              cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
              for (; *str; str++)
                {
                switch (* str)
                  {
                  case 't':
                    cpu_variant |= (ARM_THUMB | ARM_ARCH_V4);
                    break;

                  case 'm':
                    cpu_variant |= ARM_LONGMUL;
                    break;

		  case 'f': /* fe => fp enabled cpu.  */
		    if (str[1] == 'e')
		      ++ str;
		    else
d6901 2
a6902 11
		    
		  case 'c': /* Left over from 710c processor name.  */
                  case 'd': /* Debug */
                  case 'i': /* Embedded ICE */
                    /* Included for completeness in ARM processor naming. */
                    break;

                  default:
                    goto bad;
                  }
                }
d6912 1
a6912 1
	      
a6929 1
	      
d6939 1
a6939 1
		
d6941 2
a6942 1
	      /* Select variant based on architecture rather than processor.  */
d6959 1
a6959 1
		  
d6961 2
a6962 2
		    cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
                    
d6972 1
a6972 1
		  
d6975 1
a6975 1
		  
d6997 1
a6997 1
		  
d7003 1
a7003 1
	      
d7017 1
a7017 1
      
d7022 1
a7022 1
   return 1;
d7027 1
a7027 1
     FILE * fp;
d7045 1
a7045 1
  #endif
d7066 6
a7071 6
     fragS *       frag;
     int           where;
     short int     size;
     expressionS * exp;
     int           pc_rel;
     int           reloc;
d7073 2
a7074 2
  fixS *         new_fix;
  arm_fix_data * arm_data;
d7091 3
a7093 2
  /* Mark whether the fix is to a THUMB instruction, or an ARM instruction */
  arm_data = (arm_fix_data *) obstack_alloc (& notes, sizeof (arm_fix_data));
d7100 1
a7101 1
/* This fix_new is called by cons via TC_CONS_FIX_NEW.  */
d7104 4
a7107 4
     fragS *       frag;
     int           where;
     int           size;
     expressionS * exp;
d7114 1
a7114 1
  switch (size) 
d7130 1
a7130 1
  
d7137 1
d7143 3
a7145 2
  
  subseg_set (text_section, 0); /* Put it at the end of text section.  */
d7158 1
a7158 1
     symbolS * sym;
d7161 1
a7161 1
  
d7163 1
a7163 1
  
d7167 1
a7167 1
  
d7176 1
a7176 1
      
d7188 1
a7188 1
  symbolS * sym;
d7193 1
a7193 1
        {
d7197 3
a7199 2
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL) /* This can happen! */
d7208 17
a7224 15
          else switch (S_GET_STORAGE_CLASS (sym))
            {
              case C_EXT:
                S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
                break;
              case C_STAT:
                S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
                break;
              case C_LABEL:
                S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
                break;
              default: /* do nothing */ 
                break;
            }
        }
d7231 2
a7232 2
  symbolS *         sym;
  char              bind;
d7237 3
a7239 3
        {
	  elf_symbol_type * elf_sym;
	  
d7242 1
a7242 1
	  
d7251 2
a7252 2
         }
     }
d7266 1
a7266 1
  
d7272 1
a7272 1
     char * name;
d7285 1
a7285 1
     fixS * fixP;
d7291 1
a7291 1
  if (   fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
d7316 1
a7316 1
   
d7319 1
a7319 1
   fixS * fixP;
d7323 2
a7324 2
  
  /* Prevent all adjustments to global symbols. */
d7327 1
a7327 1
  
d7334 3
a7336 3
  
  /* We need the symbol name for the VTABLE entries */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d7347 6
a7352 4
    if (target_oabi)
      return "elf32-bigarm-oabi";
    else
      return "elf32-bigarm";
d7354 6
a7359 4
    if (target_oabi)
      return "elf32-littlearm-oabi";
    else
      return "elf32-littlearm";
d7364 2
a7365 2
     symbolS * symp;
     int * puntp;
d7368 1
a7368 1
} 
d7372 1
a7372 1
     struct fix * fixp;
d7374 1
a7374 1
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d7379 1
a7379 1
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)    
d7381 1
a7381 1
  
d7388 2
a7389 2
  char   id[16];
  char * ip;
d7393 2
a7394 2
    char * str;
    int    len;
d7402 2
a7403 3
    /* ScottB: Jan 30, 1998 */
    /* Added support for parsing "var(PLT)" branch instructions */
    /* generated by GCC for PLT relocs */
d7406 1
a7406 1
#undef MAP    
d7413 1
a7413 1
  
d7417 1
a7417 1
  
d7419 1
a7419 1
  
d7446 2
a7447 2
      
      expression (& exp);
d7450 5
a7454 5
          && * input_line_pointer == '('
          && (reloc = arm_parse_reloc()) != BFD_RELOC_UNUSED)
        {
          reloc_howto_type * howto = bfd_reloc_type_lookup (stdoutput, reloc);
          int size = bfd_get_reloc_size (howto);
d7456 2
a7457 2
          if (size > nbytes)
            as_bad ("%s relocations do not fit in %d bytes",
d7459 9
a7467 9
          else
            {
              register char * p = frag_more ((int) nbytes);
              int offset = nbytes - size;

              fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   & exp, 0, reloc);
            }
        }
d7469 1
a7469 1
        emit_expr (& exp, (unsigned int) nbytes);
d7473 2
a7474 1
  input_line_pointer--;		/* Put terminator back into stream.  */
@


1.48
log
@Fix spelling typos.
Remove use of DEFUN().
@
text
@d410 121
@


1.47
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d1293 3
d1298 1
a1299 2
  label_is_thumb_function_name = true;
  
@


1.46
log
@Assign correct reloc value to size 1 constant valued fixes.
@
text
@a117 1
#ifdef TE_LINUX
a118 3
#else
CONST char line_separator_chars[] = "";
#endif
@


1.45
log
@is_end_of_line fixes.
@
text
@d6900 3
a6902 5
  
  /* Pick a reloc ...
   *
   * @@@@ Should look at CPU word size.
   */
d6905 3
@


1.44
log
@The ARM assembler is not assembling the following instruction
correctly.

	mrs	lr, spsr

The string pointer is advanced to far before the check to set
the SPSR bit.

Thu Jun 01 2000  Scott Bambrough <scottb@@netwinder.org>

	* config/tc-arm.c (do_mrs): Allow SPSR_BIT to be set correctly.
@
text
@d2222 1
a2222 1
      && (is_end_of_line [(int)(*save_in)] || *save_in == '\0'))
d2647 1
a2647 1
		  if (is_end_of_line[(int)**str] || **str == '\0')
@


1.43
log
@Add support for _x and _s flags to MSR instruction
@
text
@d1917 2
d1941 1
a1941 1
    str += 4;
d1945 1
a1945 1
    str += 7;
d1954 1
@


1.42
log
@Document behaviour of .align 0 for ARM targets.
Remove incomplete v5e code from tc-arm.c
@
text
@d384 2
a385 1
  unsigned long number;
d388 2
a389 1
#define PSR_FIELD_MASK  0x000f0000
d391 4
a394 10
#define PSR_FLAGS	0x00080000
#define PSR_CONTROL	0x00010000 /* Undocumented instruction, its use is discouraged by ARM */
#define PSR_ALL		0x00090000

#define CPSR_ALL	0
#define SPSR_ALL	1
#define CPSR_FLG	2
#define SPSR_FLG	3
#define CPSR_CTL	4
#define SPSR_CTL	5
d398 30
a427 15
  /* Valid <psr>'s */
  {"cpsr",	CPSR_ALL},
  {"cpsr_all",	CPSR_ALL},
  {"spsr",	SPSR_ALL},
  {"spsr_all",	SPSR_ALL},

  /* Valid <psrf>'s */
  {"cpsr_flg",	CPSR_FLG},
  {"spsr_flg",	SPSR_FLG},
  
  /* Valid <psrc>'s */
  {"cpsr_c",	CPSR_CTL},
  {"cpsr_ctl",	CPSR_CTL},
  {"spsr_c",	SPSR_CTL},
  {"spsr_ctl",	SPSR_CTL}
d472 1
a472 1
static int arm_psr_parse	PARAMS ((char **));
d481 1
a481 1
static int psr_required_here	PARAMS ((char **, int, int));
d583 2
a584 2
   NickC:  but this is wrong because the bits 16 and 19 are handled
           by the PSR_xxx defines above.  */
d1576 35
d1612 1
a1612 1
psr_required_here (str, cpsr, spsr)
a1613 2
     int     cpsr;
     int     spsr;
a1614 1
  int    psr;
d1616 2
d1619 2
a1620 2
  
  if  (psr == cpsr || psr == spsr)
d1622 6
a1627 2
      if (psr == spsr)
	inst.instruction |= 1 << 22;
d1632 3
a1634 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _("<psr(f)> expected");
d1926 19
a1944 2
  if (skip_past_comma (&str) == FAIL
      || psr_required_here (& str, CPSR_ALL, SPSR_ALL) == FAIL)
d1946 1
a1946 1
      inst.error = _("<psr> expected");
d1950 3
a1954 1
  return;
d1957 3
a1959 1
/* Three possible forms: "<psr>, Rm", "<psrf>, Rm", "<psrf>, #expression".  */
d1965 10
a1974 1
  int reg;
d1978 1
a1978 1
  if (psr_required_here (&str, CPSR_ALL, SPSR_ALL) == SUCCESS)
d1980 11
a1990 1
      inst.instruction |= PSR_ALL;
d1992 21
a2012 7
      /* Sytax should be "<psr>, Rm" */
      if (skip_past_comma (&str) == FAIL
	  || (reg = reg_required_here (&str, 0)) == FAIL)
	{
	  inst.error = BAD_ARGS;
	  return;
	}
d2016 1
a2016 9
      if (psr_required_here (& str, CPSR_FLG, SPSR_FLG) == SUCCESS)
	inst.instruction |= PSR_FLAGS;
      else if (psr_required_here (& str, CPSR_CTL, SPSR_CTL) == SUCCESS)
	inst.instruction |= PSR_CONTROL;
      else
	{
	  inst.error = BAD_ARGS;
	  return;
	}
d2018 1
a2018 1
      if (skip_past_comma (&str) == FAIL)
d2020 1
a2020 1
	  inst.error = BAD_ARGS;
d2024 1
a2024 40
      /* Syntax could be "<psrf>, rm", "<psrf>, #expression" */
      
      if ((reg = reg_required_here (& str, 0)) != FAIL)
	;
      /* Immediate expression.  */
      else if (is_immediate_prefix (* str))
	{
	  str ++;
	  inst.error = NULL;
	  
	  if (my_get_expression (& inst.reloc.exp, & str))
	    {
	      inst.error = _("Register or shift expression expected");
	      return;
	    }

	  if (inst.reloc.exp.X_add_symbol)
	    {
	      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
	      inst.reloc.pc_rel = 0;
	    }
	  else
	    {
	      unsigned value = validate_immediate (inst.reloc.exp.X_add_number);
	      if (value == (unsigned) FAIL)
		{
		  inst.error = _("Invalid constant");
		  return;
		}

	      inst.instruction |= value;
	    }

	  flags |= INST_IMMEDIATE;
	}
      else
	{
	  inst.error = _("Error: unrecognised syntax for second argument to msr instruction");
	  return;
	}
a2029 1
  return;
d5299 1
a5299 1
     char * name;
a5363 27
static int
arm_psr_parse (ccp)
     register char ** ccp;
{
  char * start = * ccp;
  char   c;
  char * p;
  CONST struct asm_psr * psr;

  p = start;
  c = *p++;
  while (isalpha (c) || c == '_')
    c = *p++;

  *--p = 0;  
  psr = (CONST struct asm_psr *) hash_find (arm_psr_hsh, start);
  *p = c;

  if (psr)
    {
      *ccp = p;
      return psr->number;
    }

  return FAIL;
}

d6442 1
a6442 1
 *            -m[arm]v[2345]	      Arm architectures
@


1.41
log
@Remove U suffix from constants for K&R compilers.
Fix a couple of 64 bit nits.
@
text
@a54 1
#define ARM_EXT_V5E     0x00000200	/* "El Segundo" 	 */
a6749 1
		    case 'e': cpu_variant |= ARM_EXT_V5E; break;
@


1.40
log
@Add support for BFD_RELOC_{ARM|THUMB}_PCREL_BLX relocs.
@
text
@d5574 2
a5575 2
      if ((value & 0xfe000000UL) != 0
	  && ((value & 0xfe000000UL) != 0xfe000000UL))
d5598 2
a5599 2
	      if ((value & 0xfe000000UL) == 0xfe000000UL
		  || (value & 0xfe000000UL) == 0)
d5612 2
a5613 2
      if ((value & 0xff000000UL) != 0
	  && ((value & 0xff000000UL) != 0xff000000UL))
@


1.39
log
@Add "bal" instruction pattern.
Add test of assembling "bal" instruction
@
text
@d2664 1
a2665 1
  return;
d5373 1
d5621 16
d5670 1
d5977 1
d5982 1
d6195 1
d6200 1
d7127 2
@


1.39.2.1
log
@2000-05-26  Scott Bambrough <scottb@@netwinder.org>

	Port of patch to mainline by Nick Clifton <nickc@@cygnus.com>:
	* config/tc-arm.c (struct asm_psr): Add boolean field
	distinguishing between CSPR and SPSR.  Rename 'number' field
	to 'field'.
	(psrs): Rearrange contents to match new asm_psr structure.
	(arm_psr_parse): Move next to psr_required_here.  Make it
	return an asm_psr structure.
	(psr_required_here): Use asm_psr structure returned by
	arm_psr_parse.
	(do_msr): Reorganise to allow psr_required_here to be called
	only once.
	(md_undefined_name): Mark 'name' parameter as unused, since
	the COFF target does not use it.

	Port of patch to mainline by Nick Clifton <nickc@@cygnus.com>:
	* testsuite/gas/arm/arch4t.s: Add tests of new fields
	to msr instruction.

	* NEWS: Mention change in behaviour when assembling msr
	instruction.
@
text
@d385 1
a385 2
  boolean       cpsr;
  unsigned long field;
d388 1
a388 2
#define SPSR_BIT   (1 << 22)  /* The bit that distnguishes CPSR and SPSR.  */
#define PSR_SHIFT  16  /* How many bits to shift the PSR_xxx bits up by.  */
d390 10
a399 4
#define PSR_c   (1 << 0)
#define PSR_x   (1 << 1)
#define PSR_s   (1 << 2)
#define PSR_f   (1 << 3)
d403 15
a417 30
  {"CPSR",	true,  PSR_c | PSR_f},
  {"CPSR_all",	true,  PSR_c | PSR_f},
  {"SPSR",	false, PSR_c | PSR_f},
  {"SPSR_all",	false, PSR_c | PSR_f},
  {"CPSR_flg",	true,  PSR_f},
  {"CPSR_f",    true,  PSR_f},
  {"SPSR_flg",	false, PSR_f},
  {"SPSR_f",    false, PSR_f}, 
  {"CPSR_c",	true,  PSR_c},
  {"CPSR_ctl",	true,  PSR_c},
  {"SPSR_c",	false, PSR_c},
  {"SPSR_ctl",	false, PSR_c},
  {"CPSR_x",    true,  PSR_x},
  {"CPSR_s",    true,  PSR_s},
  {"SPSR_x",    false, PSR_x},
  {"SPSR_s",    false, PSR_s},
  /* For backwards compatability with older toolchain we also
     support lower case versions of some of these flags.  */
  {"cpsr",	true,  PSR_c | PSR_f},
  {"cpsr_all",	true,  PSR_c | PSR_f},
  {"spsr",	false, PSR_c | PSR_f},
  {"spsr_all",	false, PSR_c | PSR_f},
  {"cpsr_flg",	true,  PSR_f},
  {"cpsr_f",    true,  PSR_f},
  {"spsr_flg",	false, PSR_f},
  {"spsr_f",    false, PSR_f}, 
  {"cpsr_c",	true,  PSR_c},
  {"cpsr_ctl",	true,  PSR_c},
  {"spsr_c",	false, PSR_c},
  {"spsr_ctl",	false, PSR_c}
d462 1
a462 1
static CONST struct asm_psr * arm_psr_parse PARAMS ((char **));
d471 1
a471 1
static int psr_required_here	PARAMS ((char **));
d573 2
a574 2
   NickC:  but this is wrong because the bits 16 through 19 are
           handled by the PSR_xxx defines above.  */
a1565 35
static CONST struct asm_psr *
arm_psr_parse (ccp)
     register char ** ccp;
{
  char * start = * ccp;
  char   c;
  char * p;
  CONST struct asm_psr * psr;

  p = start;

  /* Skip to the end of the next word in the input stream.  */
  do
    {
      c = *p++;
    }
  while (isalpha (c) || c == '_');

  /* Terminate the word.  */
  *--p = 0;

  /* Now locate the word in the psr hash table.  */
  psr = (CONST struct asm_psr *) hash_find (arm_psr_hsh, start);

  /* Restore the input stream.  */
  *p = c;

  /* If we found a valid match, advance the
     stream pointer past the end of the word.  */
  *ccp = p;

  return psr;
}

/* Parse the input looking for a PSR flag.  */
d1567 1
a1567 1
psr_required_here (str)
d1569 2
d1572 1
d1574 1
a1574 1
  CONST struct asm_psr * psr;
d1576 1
a1576 3
  psr = arm_psr_parse (str);

  if (psr)
d1578 2
a1579 6
      /* If this is the SPSR that is being modified, set the R bit.  */
      if (! psr->cpsr)
	inst.instruction |= SPSR_BIT;

      /* Set the psr flags in the MSR instruction.  */
      inst.instruction |= psr->field << PSR_SHIFT;
d1584 3
a1586 3
  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  inst.error = _("flag for {c}psr instruction expected");
d1878 2
a1879 1
  if (skip_past_comma (&str) == FAIL)
d1881 1
a1881 1
      inst.error = _("comma expected after register name");
a1884 21
  skip_whitespace (str);

  if (   strcmp (str, "CPSR") == 0
      || strcmp (str, "SPSR") == 0
	 /* Lower case versions for backwards compatability.  */
      || strcmp (str, "cpsr") == 0
      || strcmp (str, "spsr") == 0)
    str += 4;
  /* This is for backwards compatability with older toolchains.  */
  else if (strcmp (str, "cpsr_all") == 0
	   || strcmp (str, "spsr_all") == 0)
    str += 7;
  else
    {
      inst.error = _("{C|S}PSR expected");
      return;
    }

  if (* str == 's' || * str == 'S')
    inst.instruction |= SPSR_BIT;
  
d1887 1
d1890 1
a1890 3
/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */
d1896 1
a1896 10
  skip_whitespace (str);

  if (psr_required_here (& str) == FAIL)
    return;
    
  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("comma missing after psr flags");
      return;
    }
d1900 1
a1900 1
  if (reg_required_here (& str, 0) != FAIL)
d1902 1
a1902 5
      inst.error = NULL; 
      inst.instruction |= flags;
      end_of_line (str);
      return;
    }
d1904 7
a1910 27
  if (! is_immediate_prefix (* str))
    {
      inst.error = _("only a register or immediate value can follow a psr flag");
      return;
    }

  str ++;
  inst.error = NULL;
  
  if (my_get_expression (& inst.reloc.exp, & str))
    {
      inst.error = _("only a register or immediate value can follow a psr flag");
      return;
    }
  
  if (inst.instruction & ((PSR_c | PSR_x | PSR_s) << PSR_SHIFT))
    {
      inst.error = _("can only set flag field with immediate value");
      return;
    }
  
  flags |= INST_IMMEDIATE;
	  
  if (inst.reloc.exp.X_add_symbol)
    {
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
d1914 9
a1922 1
      unsigned value = validate_immediate (inst.reloc.exp.X_add_number);
d1924 1
a1924 1
      if (value == (unsigned) FAIL)
d1926 1
a1926 1
	  inst.error = _("Invalid constant");
d1930 40
a1969 1
      inst.instruction |= value;
d1975 1
d5245 1
a5245 1
     char * name ATTRIBUTE_UNUSED;
d5310 27
d6393 1
a6393 1
 *            -m[arm]v[2345[t]]       Arm architectures
@


1.39.2.2
log
@The ARM assembler is not assembling the following instruction
correctly.

	mrs	lr, spsr

The string pointer is advanced to far before the check to set
the SPSR bit.

2000-06-01  Scott Bambrough <scottb@@netwinder.org>

	* config/tc-arm.c (do_mrs): Allow SPSR_BIT to be set correctly.
@
text
@a1917 2
  int skip = 0;
  
d1940 1
a1940 1
    skip = 4;
d1944 1
a1944 1
    skip = 7;
a1952 1
  str += skip;
@


1.39.2.3
log
@Assign correct reloc value to size 1 fixes.
@
text
@d6881 4
a6884 2
  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
a6886 3
    case 1:
      type = BFD_RELOC_8;
      break;
@


1.39.2.4
log
@2000-09-08  Philip Blundell  <philb@@gnu.org>

	* config/tc-arm.c (md_apply_fix3): Correct handling of ADRL when
	offset is negative.
@
text
@d5453 1
a5453 1
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
@


1.39.2.5
log
@2000-11-01  Philip Blundell  <philb@@gnu.org>

	From 2000-08-01  Nick Clifton  <nickc@@cygnus.com>
	* config/tc-arm.c (do_mrs): Fix skip of 'cpsr_all' flag.
@
text
@d1946 1
a1946 1
    skip = 8;
@


1.39.2.6
log
@2000-11-02  Theo Honohan  <th@@futuretv.com>

	* config/tc-arm.c (do_msr): Improve error message.
@
text
@d2007 1
a2007 1
      inst.error = _("only flag field of psr can be set with immediate value");
@


1.38
log
@fix bug detecting pc-rel overflow
@
text
@d811 1
@


1.37
log
@Fix adr pseudo op for Thumb.
@
text
@d5611 1
a5611 2
	  && (fixP->fx_done == 0
	      || ((value & 0xff000000UL) != 0xff000000UL)))
@


1.36
log
@minor formatting improvements
@
text
@d2645 1
a2645 2
     into a relative address of the form "add rd, pc, #label-.-8" */

d2656 1
d2660 1
a2660 1
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust */
d4908 2
d4911 1
a4911 1
     into a relative address of the form "add rd, pc, #label-.-4" */
d4914 3
a4916 1
  if (reg_required_here (&str, 4) == FAIL  /* Store Rd in temporary location inside instruction.  */
d4926 1
a4926 1
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust */
d4928 2
a4929 1
  inst.instruction |= REG_PC; /* Rd is already placed into the instruction */
@


1.35
log
@fix compile time warning messages
@
text
@d107 1
a107 1
   pre-processor is disabled, these aren't very useful */
d112 1
a112 1
   .line and .file directives will appear in the pre-processed output */
d115 2
a116 2
   #NO_APP at the beginning of its output. */
/* Also note that comments like this one will always work. */
d125 2
a126 1
/* Chars that can be used to separate mant from exp in floating point nums */
d147 1
a147 1
				   does not support thumb instructions */
d201 1
a201 1
/* Number of littlenums required to hold an extended precision number */
d230 1
a230 1
/* This is to save a hash look-up in the common case */
d255 1
a255 1
   the set_bits: */
d420 1
a420 1
/* Functions called by parser */
d501 1
a501 1
   take 2: */
d505 1
a505 3
 * flags.
 * ARM7M has 4 of length 5
 */
d633 1
a633 1
/* Generic copressor instructions */
d641 1
a641 2
/* defines for various bits that we will want to toggle */

d656 1
a656 2
/* Codes to distinguish the arithmetic instructions */

d753 1
a753 1
#define THUMB_SIZE	2	/* Size of thumb instruction */
d773 1
a773 1
/* These three are used for immediate shifts, do not alter */
d862 1
a862 1
/* These are the standard names.  Users can add aliases with .req */
d912 3
a914 4
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */
d1006 1
a1006 1
  /* Check if this literal value is already in the pool: */
d1011 2
a1012 1
          && literals[lit_count].exp.X_add_number == inst.reloc.exp.X_add_number
d1091 2
a1092 2
/* Check that an immediate is valid, and if so, convert it to the right format.  */

a1111 1

d1219 1
a1219 1
    /* First output the expression in the instruction to the pool */
d1537 1
a1537 2
   Returns the reg#, or FAIL. */

d4981 1
d5012 1
a5012 1
    /* Set the flags in the private structure */
d5023 31
a5053 16
  {
    unsigned mach;
    
    /* Record the CPU type as well */
    switch (cpu_variant & ARM_CPU_MASK)
      {
      case ARM_2:
	mach = bfd_mach_arm_2;
	break;
	
      case ARM_3: /* also ARM_250 */
	mach = bfd_mach_arm_2a;
	break;

      default:
      case ARM_6 | ARM_3 | ARM_2:	/* Actually no CPU type defined */
d5055 5
a5059 24
	break;
	
      case ARM_7: 			/* also ARM_6 */
	mach = bfd_mach_arm_3;
	break;
      }

    /* Catch special cases.  */
    if (cpu_variant != (FPU_DEFAULT | CPU_DEFAULT))
      {
	if (cpu_variant & (ARM_EXT_V5 & ARM_THUMB))
	  mach = bfd_mach_arm_5T;
	else if (cpu_variant & ARM_EXT_V5)
	  mach = bfd_mach_arm_5;
	else if (cpu_variant & ARM_THUMB)
	  mach = bfd_mach_arm_4T;
	else if ((cpu_variant & ARM_ARCH_V4) == ARM_ARCH_V4)
	  mach = bfd_mach_arm_4;
	else if (cpu_variant & ARM_LONGMUL)
	  mach = bfd_mach_arm_3M;
      }
	
    bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
  }
d6355 2
a6356 1
		as_warn (_("ignoring redefinition of register alias '%s'"), copy_of_str );
d6640 2
a6641 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_8 | ARM_ARCH_V4 | ARM_LONGMUL;
d6648 2
a6649 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
d6651 2
a6652 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL;
d6654 2
a6655 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
d6657 2
a6658 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
d6668 2
a6669 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_8 | ARM_ARCH_V4 | ARM_LONGMUL;
d6675 1
a6675 1
	      /* Select variant based on architecture rather than processor */
d6681 9
a6689 3
		    case 'a': cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_3; break;
		    case 0:   cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_2; break;
		    default:  as_bad (_("Invalid architecture variant -m%s"), arg); break;
d6700 3
a6702 1
		    default:  as_bad (_("Invalid architecture variant -m%s"), arg); break;
d6713 3
a6715 1
		    default:  as_bad (_("Invalid architecture variant -m%s"), arg); break;
d6726 3
a6728 1
		    default:  as_bad (_("Invalid architecture variant -m%s"), arg); break;
d6763 1
a6763 2
  fprintf (fp,
_("\
d6772 1
a6772 3
  -mno-fpu                  don't allow any floating-point instructions.\n"));
  fprintf (fp,
_("\
d6775 3
a6777 8
  fprintf (fp,
_("\
  -mapcs-32, -mapcs-26      specify which ARM Procedure Calling Standard to use\n"));
  fprintf (fp,
_("\
  -mapcs-float              floating point args are passed in FP regs\n"));
  fprintf (fp,
_("\
d6781 1
a6781 2
  fprintf (fp,
_("\
d6785 1
a6785 2
  fprintf (fp,
_("\
d6970 2
a6971 1
	  /* If it's a .thumb_func, declare it as so, else tag label as .code 16.  */
d6973 2
a6974 1
	    elf_sym->internal_elf_sym.st_info = ELF_ST_INFO (bind, STT_ARM_TFUNC);
d6976 2
a6977 1
	    elf_sym->internal_elf_sym.st_info = ELF_ST_INFO (bind, STT_ARM_16BIT);
d7179 2
a7180 1
            as_bad ("%s relocations do not fit in %d bytes", howto->name, nbytes);
d7195 1
a7195 1
  input_line_pointer--;		/* Put terminator back into stream. */
@


1.34
log
@Handle same-section relocations where the destination is at an address >=
0x00400000.
@
text
@d1166 1
a1166 1
     int a;
d1173 1
a1173 1
     int ignore;
d1183 1
a1183 1
     int ignore;
d1195 1
a1195 1
     int ignored;
d1232 1
a1232 1
     int unused;
d1268 1
a1268 1
     int ignore;
d1288 1
a1288 1
     int ignore;
d1474 1
a1474 1
     int ignore;
d1482 1
a1482 1
     int ignore;
d1490 1
a1490 1
     int unused;
d1958 1
a1958 1
	      if (value == FAIL)
d2467 1
a2467 1
  if (value == FAIL)
d3304 1
a3304 1
     unsigned long flags;
d3350 1
a3350 1
     unsigned long flags;
d3371 1
a3371 1
     unsigned long flags;
d3538 1
a3538 1
     unsigned long flags;
d3559 1
a3559 1
     unsigned long flags;
d4986 1
a4986 1
  int i;
d5230 1
a5230 1
     segT   segment;
d5916 1
a5916 1
     asection * section;
d6060 2
a6061 2
     fragS * fragP;
     segT    segtype;
d7107 1
a7107 1
  int    i;
@


1.33
log
@Add support for WinCE targeted toolchains.
@
text
@d5563 3
d5568 1
a5568 1
        value = fixP->fx_offset;
d5570 50
a5619 3
      value  = (value >> 2) & 0x00ffffff;
      value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;
      newval = value | (newval & 0xff000000);
@


1.32
log
@Add ATPCS register naming support
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d57 1
a57 1
/* Architectures are the sum of the base and extensions */
d550 4
d556 2
a557 1

d3028 1
d3030 1
d4126 1
d4151 1
a4151 1
      str++;
d4236 1
d5218 5
d5224 1
a6907 1
  elf_symbol_type * elf_sym;
d6914 2
@


1.31
log
@Apply Thoams de Lellis's patch to fic disassembly of Thumb instructions when
bounded by non-function labels.
@
text
@d860 1
a860 1
/* These are the standard names;  Users can add aliases with .req */
d863 1
a863 1
  /* Processor Register Numbers */
d868 1
a868 1
  /* APCS conventions */
d873 3
a875 1
  /* FP Registers */
d886 7
@


1.30
log
@fix formatting
@
text
@d6891 4
d6896 3
a6898 5
	    {
	      elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	      bind = ELF_ST_BIND (elf_sym);
	      elf_sym->internal_elf_sym.st_info = ELF_ST_INFO (bind, STT_ARM_TFUNC);
            }
@


1.29
log
@Apply patch from Philip Blundell to allow .previous to work for arm-elf
@
text
@d60 1
a60 1
#define ARM_ARCH_V5	(ARM_ARCH_V4 | ARM_EXT_V5 )
d6126 1
a6126 1
		    	 as_bad (_("Opcode `%s' must have suffix from <%s>\n"),
a6166 1

d6410 2
a6411 1
              cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_THUMB | ARM_ARCH_V4;
a6645 1

d6682 1
a6682 1
  -m[arm]v[2|2a|3|3m|4|4t|5]select architecture variant\n\
@


1.28
log
@Add support for -marm720 command line switch
@
text
@d1386 3
d1390 1
d1405 3
d1409 1
@


1.27
log
@Fix .force_thumb
@
text
@d6525 1
@


1.26
log
@tc-arm.c: minor changes and support for upcoming V5E variant.
@
text
@d142 1
a142 3
CONST int md_reloc_size = 8;		/* Size of relocation record */

static int thumb_mode = 0;      /* non-zero if assembling thumb instructions */
d144 3
d1264 1
a1264 1
      thumb_mode = 1;
d6072 1
a6072 1
	  if ((opcode->variants & cpu_variant) == 0)
@


1.25
log
@        * config/tc-arm.c (reg_required_here): Improve comments.
@
text
@d55 1
d60 1
a60 1
#define ARM_ARCH_V5	(ARM_ARCH_V4 | ARM_EXT_V5)
d443 1
d509 1
d514 5
a518 1
  CONST char *           comp_suffix;	/* Compulsory suffix that must follow conds */
d886 4
a889 2
#define BAD_ARGS 	_("Bad arguments to instruction");
#define BAD_PC 		_("r15 not allowed here");
d1372 1
a1372 1
#if defined OBJ_COFF || defined OBJ_ELF
d3332 4
a3335 1
    return;
d3338 1
a3338 1
    as_tsktsk (_("Use of r15 in bx has undefined behaviour"));
a3340 1
  return;
d3501 4
d4520 2
a4521 4
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
d4524 2
a4525 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d5341 2
a5342 1
	      && fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH)
d5540 1
d6070 7
d6087 1
d6114 9
a6122 3
		  if (opcode->comp_suffix != 0)
		    as_bad (_("Opcode `%s' must have suffix from <%s>\n"), str,
			    opcode->comp_suffix);
d6125 1
d6133 1
a6133 1
	      /* Now check for a conditional.  */
d6149 1
a6149 1
		      inst.instruction |= cond->value;
d6153 1
a6153 1
		    inst.instruction |= COND_ALWAYS;
d6156 17
a6172 1
		inst.instruction |= COND_ALWAYS;
d6176 1
a6176 1
	      if (opcode->comp_suffix)
d6276 1
a6276 1
		as_warn (_("register '%s' does not exist"), q);
d6313 1
a6313 1
 *            -m[arm]v[2345]	      Arm architecures
d6580 1
d6625 1
a6625 1
		  
a6627 1
		  
d6631 1
d6636 1
@


1.24
log
@        * config/tc-arm.c (thumb_opcode): Add "variants" field.
        (tinsns): Initialize variants field.
@
text
@d1506 4
a1509 2
/* A standard register must be given at this point.  Shift is the place to
   put it in the instruction. */
@


1.23
log
@        * tc-arm.c (bad_args, bad_pc): Renamed to BAD_ARGS and BAD_PC
        respectively.
@
text
@d773 1
d779 54
a832 54
  {"adc",	0x4140,		2,	do_t_arit},
  {"add",	0x0000,		2,	do_t_add},
  {"and",	0x4000,		2,	do_t_arit},
  {"asr",	0x0000,		2,	do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	do_t_branch12},
  {"beq",	0xd0fe,		2,	do_t_branch9},
  {"bne",	0xd1fe,		2,	do_t_branch9},
  {"bcs",	0xd2fe,		2,	do_t_branch9},
  {"bhs",	0xd2fe,		2,	do_t_branch9},
  {"bcc",	0xd3fe,		2,	do_t_branch9},
  {"bul",	0xd3fe,		2,	do_t_branch9},
  {"blo",	0xd3fe,		2,	do_t_branch9},
  {"bmi",	0xd4fe,		2,	do_t_branch9},
  {"bpl",	0xd5fe,		2,	do_t_branch9},
  {"bvs",	0xd6fe,		2,	do_t_branch9},
  {"bvc",	0xd7fe,		2,	do_t_branch9},
  {"bhi",	0xd8fe,		2,	do_t_branch9},
  {"bls",	0xd9fe,		2,	do_t_branch9},
  {"bge",	0xdafe,		2,	do_t_branch9},
  {"blt",	0xdbfe,		2,	do_t_branch9},
  {"bgt",	0xdcfe,		2,	do_t_branch9},
  {"ble",	0xddfe,		2,	do_t_branch9},
  {"bic",	0x4380,		2,	do_t_arit},
  {"bl",	0xf7fffffe,	4,	do_t_branch23},
  {"bx",	0x4700,		2,	do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	do_t_arit},
  {"cmp",	0x0000,		2,	do_t_compare},
  {"eor",	0x4040,		2,	do_t_arit},
  {"ldmia",	0xc800,		2,	do_t_ldmstm},
  {"ldr",	0x0000,		2,	do_t_ldr},
  {"ldrb",	0x0000,		2,	do_t_ldrb},
  {"ldrh",	0x0000,		2,	do_t_ldrh},
  {"ldrsb",	0x5600,		2,	do_t_lds},
  {"ldrsh",	0x5e00,		2,	do_t_lds},
  {"ldsb",	0x5600,		2,	do_t_lds},
  {"ldsh",	0x5e00,		2,	do_t_lds},
  {"lsl",	0x0000,		2,	do_t_lsl},
  {"lsr",	0x0000,		2,	do_t_lsr},
  {"mov",	0x0000,		2,	do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	do_t_arit},
  {"orr",	0x4300,		2,	do_t_arit},
  {"pop",	0xbc00,		2,	do_t_push_pop},
  {"push",	0xb400,		2,	do_t_push_pop},
  {"ror",	0x41c0,		2,	do_t_arit},
  {"sbc",	0x4180,		2,	do_t_arit},
  {"stmia",	0xc000,		2,	do_t_ldmstm},
  {"str",	0x0000,		2,	do_t_str},
  {"strb",	0x0000,		2,	do_t_strb},
  {"strh",	0x0000,		2,	do_t_strh},
  {"swi",	0xdf00,		2,	do_t_swi},
  {"sub",	0x0000,		2,	do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	do_t_arit},
d834 2
a835 2
  {"adr",       0x0000,         2,      do_t_adr},
  {"nop",       0x46C0,         2,      do_t_nop},      /* mov r8,r8 */
@


1.22
log
@fix compile time warnings
@
text
@d878 2
a879 2
#define bad_args 	_("Bad arguments to instruction");
#define bad_pc 		_("r15 not allowed here");
d1843 1
a1843 1
      inst.error = bad_args;
d1877 1
a1877 1
	  inst.error = bad_args;
d1889 1
a1889 1
	  inst.error = bad_args;
d1895 1
a1895 1
	  inst.error = bad_args;
d1965 1
a1965 1
      inst.error = bad_args;
d1972 1
a1972 1
      inst.error = bad_args;
d1979 1
a1979 1
      inst.error = bad_args;
d1990 1
a1990 1
      inst.error = bad_args;
d1996 1
a1996 1
      inst.error = bad_pc;
d2017 1
a2017 1
      inst.error = bad_args;
d2023 1
a2023 1
      inst.error = bad_pc;
d2030 1
a2030 1
      inst.error = bad_args;
d2036 1
a2036 1
      inst.error = bad_pc;
d2046 1
a2046 1
      inst.error = bad_args;
d2052 1
a2052 1
      inst.error = bad_pc;
d2073 1
a2073 1
      inst.error = bad_args;
d2079 1
a2079 1
      inst.error = bad_pc;
d2086 1
a2086 1
      inst.error = bad_args;
d2092 1
a2092 1
      inst.error = bad_pc;
d2104 1
a2104 1
      inst.error = bad_args;
d2110 1
a2110 1
      inst.error = bad_pc;
d2600 1
a2600 1
	inst.error = bad_args;
d2624 1
a2624 1
	inst.error = bad_args;
d2654 1
a2654 1
	inst.error = bad_args;
d2681 1
a2681 1
	inst.error = bad_args;
d2689 1
a2689 1
	inst.error = bad_args;
d2711 1
a2711 1
	inst.error = bad_args;
d2719 1
a2719 1
	inst.error = bad_args;
d2837 1
a2837 1
	inst.error = bad_args;
d3163 1
a3163 1
	inst.error = bad_args;
d3223 1
a3223 1
	inst.error = bad_args;
d3236 1
a3236 1
      inst.error = bad_args;
d3247 1
a3247 1
      inst.error = bad_pc;
d3341 1
a3341 1
	inst.error = bad_args;
d3349 1
a3349 1
	inst.error = bad_args;
d3357 1
a3357 1
	inst.error = bad_args;
d3365 1
a3365 1
	inst.error = bad_args;
d3373 1
a3373 1
	inst.error = bad_args;
d3382 1
a3382 1
	    inst.error = bad_args;
d3404 1
a3404 1
	inst.error = bad_args;
d3412 1
a3412 1
	inst.error = bad_args;
d3420 1
a3420 1
	inst.error = bad_args;
d3442 1
a3442 1
	inst.error = bad_args;
d3450 1
a3450 1
	inst.error = bad_args;
d3458 1
a3458 1
	inst.error = bad_args;
d3466 1
a3466 1
	inst.error = bad_args;
d3474 1
a3474 1
	inst.error = bad_args;
d3483 1
a3483 1
	    inst.error = bad_args;
d3505 1
a3505 1
	inst.error = bad_args;
d3540 1
a3540 1
	inst.error = bad_args;
d3548 1
a3548 1
	inst.error = bad_args;
d3567 1
a3567 1
	inst.error = bad_args;
d3625 1
a3625 1
	    inst.error = bad_args;
d3639 1
a3639 1
	  inst.error = bad_args;
d3687 1
a3687 1
	inst.error = bad_args;
d3718 1
a3718 1
	inst.error = bad_args;
d3726 1
a3726 1
	inst.error = bad_args;
d3734 1
a3734 1
	inst.error = bad_args;
d3767 1
a3767 1
	inst.error = bad_args;
d3775 1
a3775 1
	inst.error = bad_args;
d3794 1
a3794 1
	inst.error = bad_args;
d3802 1
a3802 1
	inst.error = bad_args;
d3835 1
a3835 1
	inst.error = bad_args;
d3843 1
a3843 1
	inst.error = bad_args;
d3866 1
a3866 1
	inst.error = bad_args;
d3932 1
a3932 1
	inst.error = bad_args;
d4099 1
a4099 1
	inst.error = bad_args;
d4208 1
a4208 1
	inst.error = bad_args;
d4297 1
a4297 1
	inst.error = bad_args;
d4509 1
a4509 1
	inst.error = bad_args;
d4523 1
a4523 1
	  inst.error = bad_args;
d4692 1
a4692 1
	inst.error = bad_args;
d4792 1
a4792 1
	inst.error = bad_args;
d4880 1
a4880 1
	inst.error = bad_args;
@


1.21
log
@Rename MULTI_SET_PSR to LDM_TYPE_2_OR_3
@
text
@d6987 1
a6987 1
    NULL, 0,         BFD_RELOC_UNUSED
@


1.20
log
@Only support interworking and pic  for ELF or COFF targets
@
text
@d638 1
a638 1
#define MULTI_SET_PSR	0x00400000
d3170 1
a3170 1
      flags |= MULTI_SET_PSR;
@


1.19
log
@slight code improvement over previous delta
@
text
@d1362 1
d1364 1
d6602 1
d6606 1
@


1.18
log
@Do not align sectins when producing ELF format objects.
@
text
@d5185 1
a5185 1
#endif
d5188 1
@


1.17
log
@If an offset is invalid, display it.
@
text
@d5184 1
a5184 3
  /* Don't align the dwarf2 debug sections */
  if (!strncmp (segment->name, ".debug", 5))
    return size;
@


1.16
log
@Look for register conflicts on stores as well as loads.
@
text
@d5407 2
a5408 1
          as_bad (_("bad immediate value for offset (%ld)"), (long) value);
d5431 2
a5432 1
            as_bad (_("bad immediate value for half-word offset (%ld)"), (long) value);
d5666 1
a5666 1
			  _("Invalid offset"));
d5675 1
a5675 1
			  _("Invalid offset"));
d5682 1
a5682 1
			  _("Invalid offset"));
d5689 1
a5689 1
			  _("Invalid offset"));
d5696 1
a5696 1
			  _("Invalid offset"));
@


1.15
log
@Only pass positive values to validate_offset_imm()
@
text
@d2856 2
a2857 3
      conflict_reg = (((conflict_reg == reg)
		       && (inst.instruction & LOAD_BIT))
		      ? 1 : 0);
d2863 2
a2864 1
	  str++;
d2871 2
a2872 1
		as_warn (_("destination register same as write-back base\n"));
d2885 2
a2886 1
                  as_warn (_("destination register same as write-back base\n"));
d2922 2
a2923 1
		as_tsktsk (_("destination register same as write-back base\n"));
d5346 1
a5346 1
			_("invalid constant (%lx) after fixup\n"),
d5380 1
a5380 1
			      _("Unable to compute ADRL instructions for PC offset of 0x%x\n"), value);
d5428 1
a5428 1
			_("invalid literal constant: pool needs to be closer\n"));
d5449 1
a5449 1
			_("invalid literal constant: pool needs to be closer\n"));
d5803 1
a5803 1
		    _("Bad relocation fixup type (%d)\n"), fixP->fx_r_type);
d6223 1
a6223 3
		{
		  insert_reg_alias (str, regnum);
		}
d6225 1
a6225 3
		{
		  as_warn (_("register '%s' does not exist\n"), q);
		}
@


1.14
log
@Tidy up formatting.
Fix Thubm weak function support.
@
text
@d463 1
a463 1
static int validate_offset_imm	PARAMS ((int, int));
d1130 1
a1130 1
     int val;
d1133 1
a1133 2
  if ((hwse && (val < -255 || val > 255))
      || (val < -4095 || val > 4095))
d2544 1
a2544 1
	  
d2850 1
a2850 1
      
d5398 5
a5402 1
      if ((value = validate_offset_imm (value, 0)) == FAIL)
a5406 2
      if (value < 0)
	value = -value;
d5417 5
a5421 1
      if ((value = validate_offset_imm (value, 1)) == FAIL)
d5427 1
a5427 1
            as_bad (_("bad immediate value for offset (%ld)"), (long) value);
a5430 3
      if (value < 0)
	value = -value;

d5439 1
d5441 1
a5441 1
	value = -value;
d5443 1
a5443 1
      if ((value = validate_offset_imm (value, 0)) == FAIL)
@


1.13
log
@Fix up vtable entry relocs
@
text
@d91 2
a92 1
#define streq(a,b)  (strcmp (a, b) == 0)
d419 41
a459 44
static void do_arit		PARAMS ((char *operands, unsigned long flags));
static void do_cmp		PARAMS ((char *operands, unsigned long flags));
static void do_mov		PARAMS ((char *operands, unsigned long flags));
static void do_ldst		PARAMS ((char *operands, unsigned long flags));
static void do_ldmstm		PARAMS ((char *operands, unsigned long flags));
static void do_branch		PARAMS ((char *operands, unsigned long flags));
static void do_swi		PARAMS ((char *operands, unsigned long flags));
/* Pseudo Op codes */
static void do_adr		PARAMS ((char *operands, unsigned long flags));
static void do_adrl		PARAMS ((char * operands, unsigned long flags));
static void do_nop		PARAMS ((char *operands, unsigned long flags));
/* ARM 2 */
static void do_mul		PARAMS ((char *operands, unsigned long flags));
static void do_mla		PARAMS ((char *operands, unsigned long flags));
/* ARM 3 */
static void do_swap		PARAMS ((char *operands, unsigned long flags));
/* ARM 6 */
static void do_msr		PARAMS ((char *operands, unsigned long flags));
static void do_mrs		PARAMS ((char *operands, unsigned long flags));
/* ARM 7M */
static void do_mull		PARAMS ((char *operands, unsigned long flags));
/* ARM THUMB */
static void do_bx               PARAMS ((char *operands, unsigned long flags));

/* Coprocessor Instructions */
static void do_cdp		PARAMS ((char *operands, unsigned long flags));
static void do_lstc		PARAMS ((char *operands, unsigned long flags));
static void do_co_reg		PARAMS ((char *operands, unsigned long flags));
static void do_fp_ctrl		PARAMS ((char *operands, unsigned long flags));
static void do_fp_ldst		PARAMS ((char *operands, unsigned long flags));
static void do_fp_ldmstm	PARAMS ((char *operands, unsigned long flags));
static void do_fp_dyadic	PARAMS ((char *operands, unsigned long flags));
static void do_fp_monadic	PARAMS ((char *operands, unsigned long flags));
static void do_fp_cmp		PARAMS ((char *operands, unsigned long flags));
static void do_fp_from_reg	PARAMS ((char *operands, unsigned long flags));
static void do_fp_to_reg	PARAMS ((char *operands, unsigned long flags));

static void fix_new_arm		PARAMS ((fragS *frag, int where, 
					 short int size, expressionS *exp,
					 int pc_rel, int reloc));
static int arm_reg_parse	PARAMS ((char **ccp));
static int arm_psr_parse	PARAMS ((char **ccp));
static void symbol_locate	PARAMS ((symbolS *, CONST char *, segT,
					 valueT, fragS *));
d461 2
a462 2
static unsigned validate_immediate	PARAMS ((unsigned));
static unsigned validate_immediate_twopart	PARAMS ((unsigned int, unsigned int *));
d477 1
a477 2
static int negate_data_op	PARAMS ((unsigned long *,
					 unsigned long));
d664 24
a687 24
static void do_t_nop		PARAMS ((char *operands));
static void do_t_arit		PARAMS ((char *operands));
static void do_t_add		PARAMS ((char *operands));
static void do_t_asr		PARAMS ((char *operands));
static void do_t_branch9	PARAMS ((char *operands));
static void do_t_branch12	PARAMS ((char *operands));
static void do_t_branch23	PARAMS ((char *operands));
static void do_t_bx		PARAMS ((char *operands));
static void do_t_compare	PARAMS ((char *operands));
static void do_t_ldmstm		PARAMS ((char *operands));
static void do_t_ldr		PARAMS ((char *operands));
static void do_t_ldrb		PARAMS ((char *operands));
static void do_t_ldrh		PARAMS ((char *operands));
static void do_t_lds		PARAMS ((char *operands));
static void do_t_lsl		PARAMS ((char *operands));
static void do_t_lsr		PARAMS ((char *operands));
static void do_t_mov		PARAMS ((char *operands));
static void do_t_push_pop	PARAMS ((char *operands));
static void do_t_str		PARAMS ((char *operands));
static void do_t_strb		PARAMS ((char *operands));
static void do_t_strh		PARAMS ((char *operands));
static void do_t_sub		PARAMS ((char *operands));
static void do_t_swi		PARAMS ((char *operands));
static void do_t_adr		PARAMS ((char *operands));
d1359 1
a1359 1
  /* XXX now we come to the Thumb specific bit of code.  */
d1477 1
a1477 2
  while (*str == ' ')
    str++;
d1479 1
a1479 1
  if (*str != '\0')
d1527 1
a1527 1
     this error can be overridden */
d1553 1
a1553 1
     this error can be overridden */
d1563 1
a1563 1
     char **str;
d1567 1
a1567 2
  while (**str == ' ')
    (*str)++;
d1607 1
a1607 2
  while (**str == ' ')
    (*str)++;
d1645 1
a1645 1
     this error can be overridden */
d1648 1
a1648 1
  /* Restore the start point */
d1669 1
a1669 1
     this error can be overridden */
d1672 1
a1672 1
  /* Restore the start point */
d1683 1
a1683 2
  while (**str == ' ')
    (*str)++;
d1738 1
a1738 2
      while (*p == ' ')
	p++;
d1743 1
a1743 2
      while (*p == ' ')
	p++;
d1781 1
a1781 2
	  while (*p == ' ')
	    p++;
d1789 1
a1789 2
	  while (*p == ' ')
	    p++;
d1826 2
a1827 2
  /* Do nothing really */
  inst.instruction |= flags; /* This is pointless */
d1837 2
a1838 3
  /* Only one syntax */
  while (*str == ' ')
    str++;
d1858 1
a1858 1
/* Three possible forms: "<psr>, Rm", "<psrf>, Rm", "<psrf>, #expression" */
d1866 1
a1866 2
  while (*str == ' ')
    str ++;
d1902 1
a1902 1
      /* Immediate expression */
d1959 2
a1960 3
  /* only one format "rdlo, rdhi, rm, rs" */
  while (*str == ' ')
    str++;
d2011 2
a2012 3
  /* only one format "rd, rm, rs" */
  while (*str == ' ')
    str++;
d2067 2
a2068 3
  /* only one format "rd, rm, rs, rn" */
  while (*str == ' ')
    str++;
d2262 1
a2262 2
  while (**str == ' ')
    (*str)++;
d2287 2
a2288 3
      while (*p == ' ')
	p++;

d2446 1
a2446 2
  while (**str == ' ')
    (*str)++;
d2451 3
a2453 4
	{
	  /* Shift operation on register */
	  return decode_shift (str, NO_SHIFT_RESTRICT);
	}
d2463 1
d2533 1
a2533 2
  while (**str == ' ')
    (*str)++;
d2545 2
a2546 2
	  while (**str == ' ')
	    (*str)++;
d2590 1
a2590 2
  while (*str == ' ')
    str++;
d2616 1
a2616 2
  while (*str == ' ')
    str++;
d2646 1
a2646 2
  while (* str == ' ')
    str ++;
d2675 1
a2675 2
  while (*str == ' ')
    str++;
d2705 1
a2705 2
  while (*str == ' ')
    str++;
d2831 1
a2831 2
  while (*str == ' ')
    str++;
d2851 2
a2852 2
      while (*str == ' ')
	str++;
d2861 1
a2861 2
      while (*str == ' ')
	str++;
d2880 1
a2880 2
              while (*str == ' ')
               str++;
d2908 1
a2908 2
	  while (*str == ' ')
	    str++;
d2916 1
a2916 2
	  while (*str == ' ')
	    str++;
d2932 1
a2932 2
      while (*str == ' ')
	str++;
d3026 1
a3026 2
	      while (*str == ' ')
		str++;
d3064 1
a3064 2
	  while (*str == ' ')
	    str++;
d3115 1
a3115 2
      while (*str == ' ')
	str++;
d3136 1
a3136 2
  while (*str == ' ')
    str++;
d3147 2
a3148 2
  while (*str == ' ')
    str++;
d3179 1
a3179 2
  while (*str == ' ')
    str++;
d3204 1
a3204 2
  while (*str == ' ')
    str++;
d3236 1
a3236 2
  while (*str == ' ')
    str++;
d3247 1
a3247 2
  while (*str == ' ')
    str++;
d3313 1
a3313 2
  while (*str == ' ')
    str++;
d3332 1
a3332 2
  while (*str == ' ')
    str++;
d3395 1
a3395 2
  while (*str == ' ')
    str++;
d3433 1
a3433 2
  while (*str == ' ')
    str++;
d3496 1
a3496 2
  while (*str == ' ')
    str++;
d3514 1
a3514 2
  while (*str == ' ')
    str++;
d3558 1
a3558 2
  while (*str == ' ')
    str++;
d3626 1
a3626 2
      while (*str == ' ')
	str++;
d3631 1
a3631 2
      while (*str == ' ')
	str++;
d3695 1
a3695 2
  while (*str == ' ')
    str++;
d3744 1
a3744 2
  while (*str == ' ')
    str++;
d3785 1
a3785 2
  while (*str == ' ')
    str++;
d3812 1
a3812 2
  while (*str == ' ')
    str++;
d3853 1
a3853 2
  while (*str == ' ')
    str++;
d3922 1
a3922 2
  while (*str == ' ')
    str++;
d4089 1
a4089 2
  while (*str == ' ')
    str++;
d4198 1
a4198 2
  while (*str == ' ')
    str++;
d4287 1
a4287 2
  while (*str == ' ')
    str++;
d4332 1
a4332 2
      while (*str == ' ')
	str++;
d4496 1
a4496 2
  while (*str == ' ')
    str++;
d4588 1
a4588 1
  /* This definitonmust agree with the one in gcc/config/arm/thumb.c */
d4621 1
a4621 1
  if (my_get_expression (&inst.reloc.exp, &str))
d4623 1
d4645 1
a4645 2
  while (*str == ' ')
    str++;
d4674 1
a4674 2
  while (*str == ' ')
    str++;
d4737 1
a4737 2
  while (*str == ' ')
    str++;
d4783 1
a4783 2
  while (*str == ' ')
    str++;
d4853 1
a4853 2
  while (*str == ' ')
    str++;
d4869 1
a4869 2
  while (*str == ' ')
    str++;
d5005 1
a5005 1
    /* Catch special cases */
d5029 1
a5029 2
   LITTLENUMS (shorts, here at least)
   */
d5168 1
a5168 1
	 for the calculation */
d5330 1
a5330 1
  fixP->fx_addnumber = value;	/* Remember value for emit_reloc */
d5557 3
d5912 1
a5912 1
	  default:                         type = "<unknown>";    break;
d5970 1
d6019 1
a6019 2
  if (*str == ' ')
    str++;			/* Skip leading white space */
d6059 1
a6059 1
	 matches, or we run out of opcode. */
d6073 1
a6073 1
	      /* Check that this instruction is supported for this CPU */
d6078 1
a6078 1
	      if (q == p)		/* Just a simple opcode */
d6092 1
a6092 1
	      /* Now check for a conditional */
d6117 2
a6118 2
	      /* if there is a compulsory suffix, it should come here, before
		 any optional flags. */
d6183 1
a6183 2
     alias .req reg
     */
d6185 1
a6185 2
  while (*q == ' ')
    q++;
d6197 1
a6197 2
      while (*q == ' ')
	q++;
d6230 1
a6230 1
	      /* Do not warn abpout redefinitions to the same alias.  */
d6726 2
a6727 2
 * for this kind of use.  We need to dump the literal pool before
 * references are made to a null symbol pointer.  */
d6731 6
a6736 6
  if (current_poolP != NULL)
    {
      subseg_set (text_section, 0); /* Put it at the end of text section */
      s_ltorg (0);
      listing_prev_line ();
    }
d6858 1
a6858 3
    {
      *(name + len - 5) = 0;
    }
a6900 1

d6952 2
a6953 1
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH)    
@


1.12
log
@Apply patch from Philip Blundell  <pb@@nexus.co.uk>
  Prepend LOCAL_LABEL_PREFIX (if defined) to local symbols.
  ARM: Set F_SOFTFLOAT in the output file if -mno-fpu was given.
@
text
@d6003 5
@


1.11
log
@Add support for armv5 architecture
Add ADRL pseudo op.
@
text
@d5039 1
d5927 1
a5927 1
	 a section boundry - possibly due to an implicit dump */
d5929 1
a5929 1
		    _("Literal referenced across section boundry (Implicit dump?)"));
a5931 6
    case BFD_RELOC_ARM_GOTPC:
      assert (fixp->fx_pcrel != 0);
      code = fixp->fx_r_type;
      code = BFD_RELOC_32_PCREL;
      break;

d6753 1
a6753 18
/*
 * This fix_new is called by cons via TC_CONS_FIX_NEW
 *
 * We check the expression to see if it is of the form
 *  __GLOBAL_OFFSET_TABLE + ???
 * If it is then this is a PC relative reference to the GOT.
 * i.e.
 * 	ldr	sl, L1
 * 	add	sl, pc, sl
 * L2:
 * 	...
 * L1:
 *	.word	__GLOBAL_OFFSET_TABLE + (. - (L2 + 4))
 *
 * In this case use a reloc type BFD_RELOC_ARM_GOTPC instead of the
 * normal BFD_RELOC_{16,32,64}
 */

a6780 7
  
  /* Look for possible GOTPC reloc */
  
  /*
   * Look for pic assembler and 'undef symbol + expr symbol' expression
   * and a 32 bit size.
   */
@


1.10
log
@	* config/tc-arc.c (get_arc_exp_reloc_type): Change uses of
	sy_value with appropriate accessor functions.
	* config/tc-arm.c (md_apply_fix3): Likewise.
	* config/tc-d10v.c (AT_WORD_P): Likewise.
	* config/tc-v850.c (reg_name_search): Likewise.
@
text
@d54 1
d56 5
a60 1
#define ARM_ARCHv4	(ARM_7 | ARM_LONGMUL | ARM_HALFWORD)
d64 1
a64 1
#define ARM_2UP		0x00fffffe
d81 1
a81 1
#define CPU_DEFAULT (ARM_ARCHv4 | ARM_THUMB)
d427 1
d464 1
d494 1
a494 1
static void output_inst		PARAMS ((char *));
d550 1
d881 2
a882 2
#define bad_args _("Bad arguments to instruction");
#define bad_pc _("r15 not allowed here");
d1090 41
d2659 35
d5071 5
a5075 1
	if (cpu_variant & ARM_THUMB)
d5077 1
a5077 1
	else if ((cpu_variant & ARM_ARCHv4) == ARM_ARCHv4)
d5417 45
a5461 1
     case BFD_RELOC_ARM_OFFSET_IMM:
d5951 6
d6021 1
a6021 2
output_inst (str)
     char * str;
d6036 7
a6042 1
      md_number_to_chars (to + 2, inst.instruction, THUMB_SIZE);
d6082 1
a6082 1
    
d6097 1
a6097 1
      CONST struct thumb_opcode *opcode;
d6103 1
d6109 1
a6109 1
	  output_inst (start);
d6115 1
a6115 1
      CONST struct asm_opcode *opcode;
d6129 1
d6133 1
a6133 1
	      char *r;
d6150 1
a6150 1
		  output_inst (start);
d6235 1
a6235 1
	      output_inst (start);
d6322 2
a6323 2
 *            -m8[10]                 Arm 8 processors
 *            -m9[20][tdmi]           Arm 9 processors
d6325 1
d6414 1
a6414 1
              cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_THUMB | ARM_ARCHv4;
d6548 1
a6548 1
                    cpu_variant |= (ARM_THUMB | ARM_ARCHv4);
d6575 1
a6575 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_8 | ARM_ARCHv4 | ARM_LONGMUL;
d6582 1
a6582 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCHv4 | ARM_LONGMUL | ARM_THUMB;
d6584 1
a6584 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCHv4 | ARM_LONGMUL;
d6586 1
a6586 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCHv4 | ARM_LONGMUL | ARM_THUMB;
d6588 1
a6588 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCHv4 | ARM_LONGMUL | ARM_THUMB;
d6597 1
a6597 1
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_8 | ARM_ARCHv4 | ARM_LONGMUL;
d6627 12
a6638 1
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCHv4;
d6681 1
a6681 1
  -m[arm]v[2|2a|3|3m|4|4t]  select architecture variant\n\
@


1.9
log
@	* config/tc-arm.c (ldst_extend): Add parentheses to avoid
	warning.
	(do_ldst): Move assignment out of if condition.
	(md_apply_fix3): Add casts to avoid printf format warnings.  Add
	parentheses to avoid warning.
@
text
@d5282 1
a5282 1
  if ((fixP->fx_addsy == 0 || fixP->fx_addsy->sy_value.X_op == O_constant)
@


1.8
log
@Use symbol_get_bfdsym() macro
@
text
@d2703 1
a2703 1
            inst.instruction |= add | HWOFFSET_IMM | (value >> 4) << 8 | value & 0xF;
d2754 2
a2755 1
  if (halfword = ((flags & 0x80000000) != 0))
d5320 2
a5321 1
			_("invalid constant (%x) after fixup\n"), value);
d5333 1
a5333 1
          as_bad (_("bad immediate value for offset (%d)"), val);
d5354 1
a5354 1
            as_bad (_("bad immediate value for offset (%d)"), value);
d5363 1
a5363 1
      newval |= ((value >> 4) << 8) | value & 0xf | (sign ? INDEX_UP : 0);
d5623 2
a5624 1
			"Unable to process relocation for thumb opcode: %x", newval);
d5663 2
a5664 1
                            _("Invalid immediate for address calculation (value = 0x%08X)"), value);
d5697 2
a5698 1
                          _("Invalid immediate: %d is too large"), value);
d5712 1
a5712 1
		      _("Illegal Thumb shift value: %d"), value);
@


1.7
log
@Include struc-symbol.h so that symbol structure	definition is available.
@
text
@a33 1
#include "struc-symbol.h"
d6740 1
a6740 1
	coffsymbol (sym->bsym)->native->u.syment.n_flags = 0xFF;
@


1.6
log
@Patches for eCos: Dump literal pool on section change.  Mark thumb function
aliases as being thumb functions as well.
@
text
@d34 1
d6741 1
a6741 1
	coffsymbol(sym->bsym)->native->u.syment.n_flags = 0xFF;
@


1.5
log
@(tc_gen_reloc): Fix handling of GOTPC relocs.
@
text
@d900 3
d904 1
d912 15
a926 11
  {"req",         s_req, 0},	/* Never called becasue '.req' does not start line */
  {"bss",         s_bss, 0},
  {"align",       s_align, 0},
  {"arm",         s_arm, 0},
  {"thumb",       s_thumb, 0},
  {"code",        s_code, 0},
  {"force_thumb", s_force_thumb, 0},
  {"thumb_func",  s_thumb_func, 0},
  {"even",        s_even, 0},
  {"ltorg",       s_ltorg, 0},
  {"pool",        s_ltorg, 0},
d928 6
a933 2
  {"word",        s_arm_elf_cons, 4},
  {"long",        s_arm_elf_cons, 4},
d935 1
a935 1
  {"word",        cons, 4},
d937 4
a940 4
  {"extend",      float_cons, 'x'},
  {"ldouble",     float_cons, 'x'},
  {"packed",      float_cons, 'p'},
  {0, 0, 0}
d1124 2
a1125 2
s_ltorg (internal)
     int internal;
d1131 1
a1131 6
    {
      /* Nothing to do */
      if (!internal)
	as_tsktsk (_("Nothing to put in the pool\n"));
      return;
    }
a1139 3
  if (internal)
    as_tsktsk (_("Inserting implicit pool at change of section"));

d1228 129
a6980 1

@


1.4
log
@Add support for ARM920 and ARM920t
@
text
@d5716 4
a5719 1
   code = BFD_RELOC_ARM_GOTPC;
@


1.3
log
@	* config/tc-arm.h: Update for symbol handling changes.
	* config/tc-arm.c: Likewise.
	(symbol_make_empty): Remove.  Just use symbol_create.
@
text
@d6036 3
a6038 1
 *            -mstrongarm[110]	      Arm 8 processors
d6295 2
d6298 2
@


1.2
log
@Include pipeline offset in addend unless dealing with an old ABI.
@
text
@a957 1
symbolS * symbol_make_empty PARAMS ((void)); 
d965 2
a966 1
    current_poolP = symbol_make_empty ();
d1030 1
a1030 1
  symbolP->sy_frag = frag;
a1051 17
symbolS *
symbol_make_empty () 
{
  symbolS * symbolP; 

  symbolP = (symbolS *) obstack_alloc (&notes, sizeof (symbolS));

  /* symbol must be born in some fixed state.  This seems as good as any. */
  memset (symbolP, 0, sizeof (symbolS));

  symbolP->bsym = bfd_make_empty_symbol (stdoutput);
  assert (symbolP->bsym != 0);
  symbolP->bsym->udata.p = (PTR) symbolP;

  return symbolP;
}

d2025 1
a2025 1
  if (sp->sy_value.X_op == O_big)
d2028 1
a2028 1
  if (sp->sy_value.X_add_symbol)
d2030 3
a2032 3
      return (walk_no_bignums (sp->sy_value.X_add_symbol)
	      || (sp->sy_value.X_op_symbol
		  && walk_no_bignums (sp->sy_value.X_op_symbol)));
d5606 2
a5607 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d5788 1
a5788 1
      last_label_seen->sy_frag = frag_now;
d6612 1
a6612 1
	      elf_sym = elf_symbol (sym->bsym);
@


1.1
log
@Initial revision
@
text
@d489 1
a489 1
static bfd_reloc_code_real_type	arm_parse_reloc(void);
d5013 1
a5013 2
/* The knowledge of the PC's pipeline offset is built into the relocs
   for the ELF port and into the insns themselves for the COFF port.  */
d5030 1
a5030 1
  
d5181 2
a5182 1
	  if (fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH)
d5318 1
a5319 1
      newval &= 0xff000000;
a5321 3
      else
#else
	value = (value >> 2) & 0x00ffffff;
d5323 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

