head	1.74;
access;
symbols
	binutils-2_24-branch:1.74.0.2
	binutils-2_24-branchpoint:1.74
	binutils-2_21_1:1.63.2.2
	binutils-2_23_2:1.69
	binutils-2_23_1:1.69
	binutils-2_23:1.69
	binutils-2_23-branch:1.69.0.6
	binutils-2_23-branchpoint:1.69
	binutils-2_22_branch:1.69.0.4
	binutils-2_22:1.69
	binutils-2_22-branch:1.69.0.2
	binutils-2_22-branchpoint:1.69
	binutils-2_21:1.63
	binutils-2_21-branch:1.63.0.2
	binutils-2_21-branchpoint:1.63
	binutils-2_20_1:1.59
	binutils-2_20:1.59
	binutils-arc-20081103-branch:1.56.0.6
	binutils-arc-20081103-branchpoint:1.56
	binutils-2_20-branch:1.59.0.2
	binutils-2_20-branchpoint:1.59
	dje-cgen-play1-branch:1.58.0.2
	dje-cgen-play1-branchpoint:1.58
	arc-20081103-branch:1.56.0.4
	arc-20081103-branchpoint:1.56
	binutils-2_19_1:1.56
	binutils-2_19:1.56
	binutils-2_19-branch:1.56.0.2
	binutils-2_19-branchpoint:1.56
	binutils-2_18:1.51
	binutils-2_18-branch:1.51.0.2
	binutils-2_18-branchpoint:1.51
	binutils-csl-coldfire-4_1-32:1.47
	binutils-csl-sourcerygxx-4_1-32:1.47
	binutils-csl-innovasic-fido-3_4_4-33:1.47
	binutils-csl-sourcerygxx-3_4_4-32:1.44
	binutils-csl-coldfire-4_1-30:1.47
	binutils-csl-sourcerygxx-4_1-30:1.47
	binutils-csl-coldfire-4_1-28:1.47
	binutils-csl-sourcerygxx-4_1-29:1.47
	binutils-csl-sourcerygxx-4_1-28:1.47
	binutils-csl-arm-2006q3-27:1.47
	binutils-csl-sourcerygxx-4_1-27:1.47
	binutils-csl-arm-2006q3-26:1.47
	binutils-csl-sourcerygxx-4_1-26:1.47
	binutils-csl-sourcerygxx-4_1-25:1.47
	binutils-csl-sourcerygxx-4_1-24:1.47
	binutils-csl-sourcerygxx-4_1-23:1.47
	binutils-csl-sourcerygxx-4_1-21:1.47
	binutils-csl-arm-2006q3-21:1.47
	binutils-csl-sourcerygxx-4_1-22:1.47
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.47
	binutils-csl-sourcerygxx-4_1-20:1.47
	binutils-csl-arm-2006q3-19:1.47
	binutils-csl-sourcerygxx-4_1-19:1.47
	binutils-csl-sourcerygxx-4_1-18:1.47
	binutils-csl-renesas-4_1-9:1.47
	binutils-csl-sourcerygxx-3_4_4-25:1.44
	binutils-csl-renesas-4_1-8:1.47
	binutils-csl-renesas-4_1-7:1.47
	binutils-csl-renesas-4_1-6:1.47
	binutils-csl-sourcerygxx-4_1-17:1.47
	binutils-csl-sourcerygxx-4_1-14:1.47
	binutils-csl-sourcerygxx-4_1-15:1.47
	binutils-csl-sourcerygxx-4_1-13:1.47
	binutils-2_17:1.47
	binutils-csl-sourcerygxx-4_1-12:1.47
	binutils-csl-sourcerygxx-3_4_4-21:1.47
	binutils-csl-wrs-linux-3_4_4-24:1.44
	binutils-csl-wrs-linux-3_4_4-23:1.44
	binutils-csl-sourcerygxx-4_1-9:1.47
	binutils-csl-sourcerygxx-4_1-8:1.47
	binutils-csl-sourcerygxx-4_1-7:1.47
	binutils-csl-arm-2006q1-6:1.47
	binutils-csl-sourcerygxx-4_1-6:1.47
	binutils-csl-wrs-linux-3_4_4-22:1.44
	binutils-csl-coldfire-4_1-11:1.47
	binutils-csl-sourcerygxx-3_4_4-19:1.47
	binutils-csl-coldfire-4_1-10:1.47
	binutils-csl-sourcerygxx-4_1-5:1.47
	binutils-csl-sourcerygxx-4_1-4:1.47
	binutils-csl-wrs-linux-3_4_4-21:1.44
	binutils-csl-morpho-4_1-4:1.47
	binutils-csl-sourcerygxx-3_4_4-17:1.47
	binutils-csl-wrs-linux-3_4_4-20:1.44
	binutils-2_17-branch:1.47.0.4
	binutils-2_17-branchpoint:1.47
	binutils-csl-2_17-branch:1.47.0.2
	binutils-csl-2_17-branchpoint:1.47
	binutils-csl-gxxpro-3_4-branch:1.44.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.44
	binutils-2_16_1:1.44
	binutils-csl-arm-2005q1b:1.44
	binutils-2_16:1.44
	binutils-csl-arm-2005q1a:1.44
	binutils-csl-arm-2005q1-branch:1.44.0.4
	binutils-csl-arm-2005q1-branchpoint:1.44
	binutils-2_16-branch:1.44.0.2
	binutils-2_16-branchpoint:1.44
	csl-arm-2004-q3d:1.42
	csl-arm-2004-q3:1.40
	binutils-2_15:1.36.6.2
	binutils-2_15-branchpoint:1.36
	csl-arm-2004-q1a:1.37
	csl-arm-2004-q1:1.37
	binutils-2_15-branch:1.36.0.6
	cagney_bfdfile-20040213-branch:1.36.0.4
	cagney_bfdfile-20040213-branchpoint:1.36
	cagney_bigcore-20040122-branch:1.36.0.2
	cagney_bigcore-20040122-branchpoint:1.36
	csl-arm-2003-q4:1.36
	binutils-2_14:1.31.2.1
	binutils-2_14-branch:1.31.0.2
	binutils-2_14-branchpoint:1.31
	binutils-2_13_2_1:1.20
	binutils-2_13_2:1.20
	binutils-2_13_1:1.20
	binutils-2_13:1.20
	binutils-2_13-branchpoint:1.20
	binutils-2_13-branch:1.20.0.2
	binutils-2_12_1:1.13.2.2
	binutils-2_12:1.13
	binutils-2_12-branch:1.13.0.2
	binutils-2_12-branchpoint:1.13
	cygnus_cvs_20020108_pre:1.13
	x86_64versiong3:1.1
	binutils_latest_snapshot:1.74;
locks; strict;
comment	@ * @;


1.74
date	2013.07.24.09.02.45;	author krebbel;	state Exp;
branches;
next	1.73;

1.73
date	2013.07.05.09.45.44;	author krebbel;	state Exp;
branches;
next	1.72;

1.72
date	2012.11.09.08.29.32;	author hjl;	state Exp;
branches;
next	1.71;

1.71
date	2012.10.04.08.47.30;	author krebbel;	state Exp;
branches;
next	1.70;

1.70
date	2012.09.06.08.23.23;	author krebbel;	state Exp;
branches;
next	1.69;

1.69
date	2011.05.27.12.56.06;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2011.05.24.16.13.28;	author krebbel;	state Exp;
branches;
next	1.67;

1.67
date	2011.05.24.13.33.55;	author krebbel;	state Exp;
branches;
next	1.66;

1.66
date	2011.04.14.11.11.31;	author krebbel;	state Exp;
branches;
next	1.65;

1.65
date	2011.03.18.09.54.57;	author krebbel;	state Exp;
branches;
next	1.64;

1.64
date	2010.11.25.09.33.52;	author krebbel;	state Exp;
branches;
next	1.63;

1.63
date	2010.10.28.07.37.45;	author krebbel;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2010.09.27.13.36.46;	author krebbel;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.21.11.40.28;	author krebbel;	state Exp;
branches;
next	1.59;

1.59
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.19.10.58.27;	author sky;	state Exp;
branches;
next	1.56;

1.56
date	2008.08.12.23.39.31;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.19.10.29.17;	author krebbel;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.29.09.34.14;	author sky;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.06.13.19.07;	author sky;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.19.11.26.11;	author ths;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.12.18.00.56;	author sky;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.05.09.13.02;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.23.12.28.05;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.17.13.46.05;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.03.01.54.25;	author hp;	state Exp;
branches;
next	1.41;

1.41
date	2004.10.02.00.18.31;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.15.12.38.08;	author sky;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.06.11.01.48;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.05.13.06.18;	author jakub;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.27.12.33.11;	author sky;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.22.02.35.31;	author kazu;	state Exp;
branches
	1.36.6.1;
next	1.35;

1.35
date	2003.07.10.16.46.38;	author jakub;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.01.14.45.37;	author sky;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.18.11.18.46;	author sky;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.09.15.32.52;	author sky;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.21.13.24.46;	author sky;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2003.01.27.08.44.21;	author sky;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.24.17.14.25;	author sky;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.20.11.48.32;	author sky;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.20.10.22.26;	author sky;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.17.01.13.55;	author kazu;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.19.14.58.54;	author sky;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.18.07.30.06;	author sky;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.02.09.04.43;	author sky;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.04.17.38.00;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.03.18.25.08;	author aoliva;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.28.12.34.02;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.17.15.12.24;	author sky;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.19.18.50.35;	author sky;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.15.21.28.58;	author nickc;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.11.05.08.47.46;	author sky;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.20.10.59.42;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.19.05.33.29;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.18.15.41.32;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.26.11.44.51;	author aj;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.13.08.03.52;	author aj;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.30.06.15.49;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.23.14.02.13;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.23.10.21.22;	author aj;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.26.19.38.33;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.10.00.55.52;	author nickc;	state Exp;
branches;
next	;

1.63.2.1
date	2011.03.23.16.01.56;	author gingold;	state Exp;
branches;
next	1.63.2.2;

1.63.2.2
date	2011.05.18.07.39.58;	author krebbel;	state Exp;
branches;
next	;

1.36.6.1
date	2004.04.09.18.28.12;	author drow;	state Exp;
branches;
next	1.36.6.2;

1.36.6.2
date	2004.05.07.06.32.30;	author drow;	state Exp;
branches;
next	;

1.31.2.1
date	2003.05.15.19.20.05;	author drow;	state Exp;
branches;
next	;

1.13.2.1
date	2002.04.27.13.44.15;	author amodra;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.05.03.18.24.47;	author aoliva;	state Exp;
branches;
next	;


desc
@@


1.74
log
@2013-07-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (s390_machine): Don't force the .machine
	argument to lower case.
@
text
@/* tc-s390.c -- Assemble for the S390
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010  Free Software Foundation, Inc.
   Contributed by Martin Schwidefsky (schwidefsky@@de.ibm.com).

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "struc-symbol.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"

#include "opcode/s390.h"
#include "elf/s390.h"

/* The default architecture.  */
#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "s390"
#endif
static char *default_arch = DEFAULT_ARCH;
/* Either 32 or 64, selects file format.  */
static int s390_arch_size = 0;

/* If no -march option was given default to the highest available CPU.
   Since with S/390 a newer CPU always supports everything from its
   predecessors this will accept every valid asm input.  */
static unsigned int current_cpu = S390_OPCODE_MAXCPU - 1;
static unsigned int current_mode_mask = 0;

/* Set to TRUE if the highgprs flag in the ELF header needs to be set
   for the output file.  */
static bfd_boolean set_highgprs_p = FALSE;

/* Whether to use user friendly register names. Default is TRUE.  */
#ifndef TARGET_REG_NAMES_P
#define TARGET_REG_NAMES_P TRUE
#endif

static bfd_boolean reg_names_p = TARGET_REG_NAMES_P;

/* Set to TRUE if we want to warn about zero base/index registers.  */
static bfd_boolean warn_areg_zero = FALSE;

/* Generic assembler global variables which must be defined by all
   targets.  */

const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";

/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int s390_cie_data_alignment;

/* The target specific pseudo-ops which we support.  */

/* Define the prototypes for the pseudo-ops */
static void s390_byte (int);
static void s390_elf_cons (int);
static void s390_bss (int);
static void s390_insn (int);
static void s390_literals (int);
static void s390_machine (int);
static void s390_machinemode (int);

const pseudo_typeS md_pseudo_table[] =
{
  { "align",        s_align_bytes,      0 },
  /* Pseudo-ops which must be defined.  */
  { "bss",          s390_bss,           0 },
  { "insn",         s390_insn,          0 },
  /* Pseudo-ops which must be overridden.  */
  { "byte",	    s390_byte,	        0 },
  { "short",        s390_elf_cons,      2 },
  { "long",	    s390_elf_cons,	4 },
  { "quad",         s390_elf_cons,      8 },
  { "ltorg",        s390_literals,      0 },
  { "string",       stringer,           8 + 1 },
  { "machine",      s390_machine,       0 },
  { "machinemode",  s390_machinemode,   0 },
  { NULL,	    NULL,		0 }
};


/* Structure to hold information about predefined registers.  */
struct pd_reg
  {
    char *name;
    int value;
  };

/* List of registers that are pre-defined:

   Each access register has a predefined name of the form:
     a<reg_num> which has the value <reg_num>.

   Each control register has a predefined name of the form:
     c<reg_num> which has the value <reg_num>.

   Each general register has a predefined name of the form:
     r<reg_num> which has the value <reg_num>.

   Each floating point register a has predefined name of the form:
     f<reg_num> which has the value <reg_num>.

   There are individual registers as well:
     sp     has the value 15
     lit    has the value 12

   The table is sorted. Suitable for searching by a binary search.  */

static const struct pd_reg pre_defined_registers[] =
{
  { "a0", 0 },     /* Access registers */
  { "a1", 1 },
  { "a10", 10 },
  { "a11", 11 },
  { "a12", 12 },
  { "a13", 13 },
  { "a14", 14 },
  { "a15", 15 },
  { "a2", 2 },
  { "a3", 3 },
  { "a4", 4 },
  { "a5", 5 },
  { "a6", 6 },
  { "a7", 7 },
  { "a8", 8 },
  { "a9", 9 },

  { "c0", 0 },     /* Control registers */
  { "c1", 1 },
  { "c10", 10 },
  { "c11", 11 },
  { "c12", 12 },
  { "c13", 13 },
  { "c14", 14 },
  { "c15", 15 },
  { "c2", 2 },
  { "c3", 3 },
  { "c4", 4 },
  { "c5", 5 },
  { "c6", 6 },
  { "c7", 7 },
  { "c8", 8 },
  { "c9", 9 },

  { "f0", 0 },     /* Floating point registers */
  { "f1", 1 },
  { "f10", 10 },
  { "f11", 11 },
  { "f12", 12 },
  { "f13", 13 },
  { "f14", 14 },
  { "f15", 15 },
  { "f2", 2 },
  { "f3", 3 },
  { "f4", 4 },
  { "f5", 5 },
  { "f6", 6 },
  { "f7", 7 },
  { "f8", 8 },
  { "f9", 9 },

  { "lit", 13 },   /* Pointer to literal pool */

  { "r0", 0 },     /* General purpose registers */
  { "r1", 1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r2", 2 },
  { "r3", 3 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },

  { "sp", 15 },   /* Stack pointer */

};

#define REG_NAME_CNT (sizeof (pre_defined_registers) / sizeof (struct pd_reg))

/* Given NAME, find the register number associated with that name, return
   the integer value associated with the given name or -1 on failure.  */

static int
reg_name_search (const struct pd_reg *regs, int regcount, const char *name)
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return regs[middle].value;
    }
  while (low <= high);

  return -1;
}


/*
 * Summary of register_name().
 *
 * in:	Input_line_pointer points to 1st char of operand.
 *
 * out:	A expressionS.
 *      The operand may have been a register: in this case, X_op == O_register,
 *      X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in its
 *      original state.
 */

static bfd_boolean
register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;
  if (name[0] == '%' && ISALPHA (name[1]))
    name = ++input_line_pointer;
  else
    return FALSE;

  c = get_symbol_end ();
  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

/* Local variables.  */

/* Opformat hash table.  */
static struct hash_control *s390_opformat_hash;

/* Opcode hash table.  */
static struct hash_control *s390_opcode_hash = NULL;

/* Flags to set in the elf header */
static flagword s390_flags = 0;

symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */

#ifndef WORKING_DOT_WORD
int md_short_jump_size = 4;
int md_long_jump_size = 4;
#endif

const char *md_shortopts = "A:m:kVQ:";
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

/* Initialize the default opcode arch and word size from the default
   architecture name if not specified by an option.  */
static void
init_default_arch (void)
{
  if (strcmp (default_arch, "s390") == 0)
    {
      if (s390_arch_size == 0)
	s390_arch_size = 32;
    }
  else if (strcmp (default_arch, "s390x") == 0)
    {
      if (s390_arch_size == 0)
	s390_arch_size = 64;
    }
  else
    as_fatal (_("Invalid default architecture, broken assembler."));

  if (current_mode_mask == 0)
    {
      /* Default to z/Architecture mode if the CPU supports it.  */
      if (current_cpu < S390_OPCODE_Z900)
	current_mode_mask = 1 << S390_OPCODE_ESA;
      else
	current_mode_mask = 1 << S390_OPCODE_ZARCH;
    }
}

/* Called by TARGET_FORMAT.  */
const char *
s390_target_format (void)
{
  /* We don't get a chance to initialize anything before we're called,
     so handle that now.  */
  init_default_arch ();

  return s390_arch_size == 64 ? "elf64-s390" : "elf32-s390";
}

/* Map a CPU string as given with -march= or .machine to the
   respective enum s390_opcode_cpu_val value.  0xffffffff is returned
   in case of an error.  */

static unsigned int
s390_parse_cpu (char *arg)
{
  if (strcmp (arg, "g5") == 0)
    return S390_OPCODE_G5;
  else if (strcmp (arg, "g6") == 0)
    return S390_OPCODE_G6;
  else if (strcmp (arg, "z900") == 0)
    return S390_OPCODE_Z900;
  else if (strcmp (arg, "z990") == 0)
    return S390_OPCODE_Z990;
  else if (strcmp (arg, "z9-109") == 0)
    return S390_OPCODE_Z9_109;
  else if (strcmp (arg, "z9-ec") == 0)
    return S390_OPCODE_Z9_EC;
  else if (strcmp (arg, "z10") == 0)
    return S390_OPCODE_Z10;
  else if (strcmp (arg, "z196") == 0)
    return S390_OPCODE_Z196;
  else if (strcmp (arg, "zEC12") == 0)
    return S390_OPCODE_ZEC12;
  else if (strcmp (arg, "all") == 0)
    return S390_OPCODE_MAXCPU - 1;
  else
    return -1;
}

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
      /* -k: Ignore for FreeBSD compatibility.  */
    case 'k':
      break;
    case 'm':
      if (arg != NULL && strcmp (arg, "regnames") == 0)
	reg_names_p = TRUE;

      else if (arg != NULL && strcmp (arg, "no-regnames") == 0)
	reg_names_p = FALSE;

      else if (arg != NULL && strcmp (arg, "warn-areg-zero") == 0)
	warn_areg_zero = TRUE;

      else if (arg != NULL && strcmp (arg, "31") == 0)
	s390_arch_size = 32;

      else if (arg != NULL && strcmp (arg, "64") == 0)
	s390_arch_size = 64;

      else if (arg != NULL && strcmp (arg, "esa") == 0)
	current_mode_mask = 1 << S390_OPCODE_ESA;

      else if (arg != NULL && strcmp (arg, "zarch") == 0)
	{
	  if (s390_arch_size == 32)
	    set_highgprs_p = TRUE;
	  current_mode_mask = 1 << S390_OPCODE_ZARCH;
	}

      else if (arg != NULL && strncmp (arg, "arch=", 5) == 0)
	{
	  current_cpu = s390_parse_cpu (arg + 5);

	  if (current_cpu == (unsigned int)-1)
	    {
	      as_bad (_("invalid switch -m%s"), arg);
	      return 0;
	    }
	}

      else
	{
	  as_bad (_("invalid switch -m%s"), arg);
	  return 0;
	}
      break;

    case 'A':
      /* Option -A is deprecated. Still available for compatibility.  */
      if (arg != NULL && strcmp (arg, "esa") == 0)
	current_cpu = S390_OPCODE_G5;
      else if (arg != NULL && strcmp (arg, "esame") == 0)
	current_cpu = S390_OPCODE_Z900;
      else
	as_bad (_("invalid architecture -A%s"), arg);
      break;

      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;

      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
        S390 options:\n\
        -mregnames        Allow symbolic names for registers\n\
        -mwarn-areg-zero  Warn about zero base/index registers\n\
        -mno-regnames     Do not allow symbolic names for registers\n\
        -m31              Set file format to 31 bit format\n\
        -m64              Set file format to 64 bit format\n"));
  fprintf (stream, _("\
        -V                print assembler version number\n\
        -Qy, -Qn          ignored\n"));
}

/* Generate the hash table mapping mnemonics to struct s390_opcode.
   This table is built at startup and whenever the CPU level is
   changed using .machine.  */

static void
s390_setup_opcodes (void)
{
  register const struct s390_opcode *op;
  const struct s390_opcode *op_end;
  bfd_boolean dup_insn = FALSE;
  const char *retval;

  if (s390_opcode_hash != NULL)
    hash_die (s390_opcode_hash);

  /* Insert the opcodes into a hash table.  */
  s390_opcode_hash = hash_new ();

  op_end = s390_opcodes + s390_num_opcodes;
  for (op = s390_opcodes; op < op_end; op++)
    {
      while (op < op_end - 1 && strcmp(op->name, op[1].name) == 0)
	{
          if (op->min_cpu <= current_cpu && (op->modes & current_mode_mask))
	    break;
	  op++;
        }

      if (op->min_cpu <= current_cpu && (op->modes & current_mode_mask))
	{
	  retval = hash_insert (s390_opcode_hash, op->name, (void *) op);
	  if (retval != (const char *) NULL)
	    {
	      as_bad (_("Internal assembler error for instruction %s"),
		      op->name);
	      dup_insn = TRUE;
	    }
	}

      while (op < op_end - 1 && strcmp (op->name, op[1].name) == 0)
	op++;
      }

  if (dup_insn)
    abort ();
}

/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */

void
md_begin (void)
{
  register const struct s390_opcode *op;
  const struct s390_opcode *op_end;
  const char *retval;

  /* Give a warning if the combination -m64-bit and -Aesa is used.  */
  if (s390_arch_size == 64 && current_cpu < S390_OPCODE_Z900)
    as_warn (_("The 64 bit file format is used without esame instructions."));

  s390_cie_data_alignment = -s390_arch_size / 8;

  /* Set the ELF flags if desired.  */
  if (s390_flags)
    bfd_set_private_flags (stdoutput, s390_flags);

  /* Insert the opcode formats into a hash table.  */
  s390_opformat_hash = hash_new ();

  op_end = s390_opformats + s390_num_opformats;
  for (op = s390_opformats; op < op_end; op++)
    {
      retval = hash_insert (s390_opformat_hash, op->name, (void *) op);
      if (retval != (const char *) NULL)
	as_bad (_("Internal assembler error for instruction format %s"),
		op->name);
    }

  s390_setup_opcodes ();

  record_alignment (text_section, 2);
  record_alignment (data_section, 2);
  record_alignment (bss_section, 2);
}

/* Called after all assembly has been done.  */
void
s390_md_end (void)
{
  if (s390_arch_size == 64)
    bfd_set_arch_mach (stdoutput, bfd_arch_s390, bfd_mach_s390_64);
  else
    bfd_set_arch_mach (stdoutput, bfd_arch_s390, bfd_mach_s390_31);
}

/* Insert an operand value into an instruction.  */

static void
s390_insert_operand (unsigned char *insn,
		     const struct s390_operand *operand,
		     offsetT val,
		     char *file,
		     unsigned int line)
{
  addressT uval;
  int offset;

  if (operand->flags & (S390_OPERAND_SIGNED|S390_OPERAND_PCREL))
    {
      offsetT min, max;

      max = ((offsetT) 1 << (operand->bits - 1)) - 1;
      min = - ((offsetT) 1 << (operand->bits - 1));
      /* Halve PCREL operands.  */
      if (operand->flags & S390_OPERAND_PCREL)
	val >>= 1;
      /* Check for underflow / overflow.  */
      if (val < min || val > max)
	{
	  const char *err =
	    _("operand out of range (%s not between %ld and %ld)");
	  char buf[100];

	  if (operand->flags & S390_OPERAND_PCREL)
	    {
	      val <<= 1;
	      min <<= 1;
	      max <<= 1;
	    }
	  sprint_value (buf, val);
	  if (file == (char *) NULL)
	    as_bad (err, buf, (int) min, (int) max);
	  else
	    as_bad_where (file, line, err, buf, (int) min, (int) max);
	  return;
	}
      /* val is ok, now restrict it to operand->bits bits.  */
      uval = (addressT) val & ((((addressT) 1 << (operand->bits-1)) << 1) - 1);
      /* val is restrict, now check for special case.  */
      if (operand->bits == 20 && operand->shift == 20)
        uval = (uval >> 12) | ((uval & 0xfff) << 8);
    }
  else
    {
      addressT min, max;

      max = (((addressT) 1 << (operand->bits - 1)) << 1) - 1;
      min = (offsetT) 0;
      uval = (addressT) val;
      /* Length x in an instructions has real length x+1.  */
      if (operand->flags & S390_OPERAND_LENGTH)
	uval--;
      /* Check for underflow / overflow.  */
      if (uval < min || uval > max)
	{
	  if (operand->flags & S390_OPERAND_LENGTH)
	    {
	      uval++;
	      min++;
	      max++;
	    }

	  as_bad_value_out_of_range (_("operand"), uval, (offsetT) min, (offsetT) max, file, line);

	  return;
	}
    }

  /* Insert fragments of the operand byte for byte.  */
  offset = operand->shift + operand->bits;
  uval <<= (-offset) & 7;
  insn += (offset - 1) / 8;
  while (uval != 0)
    {
      *insn-- |= uval;
      uval >>= 8;
    }
}

struct map_tls
  {
    char *string;
    int length;
    bfd_reloc_code_real_type reloc;
  };

/* Parse tls marker and return the desired relocation.  */
static bfd_reloc_code_real_type
s390_tls_suffix (char **str_p, expressionS *exp_p)
{
  static struct map_tls mapping[] =
  {
    { "tls_load", 8, BFD_RELOC_390_TLS_LOAD },
    { "tls_gdcall", 10, BFD_RELOC_390_TLS_GDCALL  },
    { "tls_ldcall", 10, BFD_RELOC_390_TLS_LDCALL  },
    { NULL,  0, BFD_RELOC_UNUSED }
  };
  struct map_tls *ptr;
  char *orig_line;
  char *str;
  char *ident;
  int len;

  str = *str_p;
  if (*str++ != ':')
    return BFD_RELOC_UNUSED;

  ident = str;
  while (ISIDNUM (*str))
    str++;
  len = str - ident;
  if (*str++ != ':')
    return BFD_RELOC_UNUSED;

  orig_line = input_line_pointer;
  input_line_pointer = str;
  expression (exp_p);
  str = input_line_pointer;
  if (&input_line_pointer != str_p)
    input_line_pointer = orig_line;

  if (exp_p->X_op != O_symbol)
    return BFD_RELOC_UNUSED;

  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (len == ptr->length
	&& strncasecmp (ident, ptr->string, ptr->length) == 0)
      {
	/* Found a matching tls suffix.  */
	*str_p = str;
	return ptr->reloc;
      }
  return BFD_RELOC_UNUSED;
}

/* Structure used to hold suffixes.  */
typedef enum
  {
    ELF_SUFFIX_NONE = 0,
    ELF_SUFFIX_GOT,
    ELF_SUFFIX_PLT,
    ELF_SUFFIX_GOTENT,
    ELF_SUFFIX_GOTOFF,
    ELF_SUFFIX_GOTPLT,
    ELF_SUFFIX_PLTOFF,
    ELF_SUFFIX_TLS_GD,
    ELF_SUFFIX_TLS_GOTIE,
    ELF_SUFFIX_TLS_IE,
    ELF_SUFFIX_TLS_LDM,
    ELF_SUFFIX_TLS_LDO,
    ELF_SUFFIX_TLS_LE
  }
elf_suffix_type;

struct map_bfd
  {
    char *string;
    int length;
    elf_suffix_type suffix;
  };


/* Parse @@got/@@plt/@@gotoff. and return the desired relocation.  */
static elf_suffix_type
s390_elf_suffix (char **str_p, expressionS *exp_p)
{
  static struct map_bfd mapping[] =
  {
    { "got", 3, ELF_SUFFIX_GOT  },
    { "got12", 5, ELF_SUFFIX_GOT  },
    { "plt", 3, ELF_SUFFIX_PLT  },
    { "gotent", 6, ELF_SUFFIX_GOTENT },
    { "gotoff", 6, ELF_SUFFIX_GOTOFF },
    { "gotplt", 6, ELF_SUFFIX_GOTPLT },
    { "pltoff", 6, ELF_SUFFIX_PLTOFF },
    { "tlsgd", 5, ELF_SUFFIX_TLS_GD },
    { "gotntpoff", 9, ELF_SUFFIX_TLS_GOTIE },
    { "indntpoff", 9, ELF_SUFFIX_TLS_IE },
    { "tlsldm", 6, ELF_SUFFIX_TLS_LDM },
    { "dtpoff", 6, ELF_SUFFIX_TLS_LDO },
    { "ntpoff", 6, ELF_SUFFIX_TLS_LE },
    { NULL,  0, ELF_SUFFIX_NONE }
  };

  struct map_bfd *ptr;
  char *str = *str_p;
  char *ident;
  int len;

  if (*str++ != '@@')
    return ELF_SUFFIX_NONE;

  ident = str;
  while (ISALNUM (*str))
    str++;
  len = str - ident;

  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (len == ptr->length
	&& strncasecmp (ident, ptr->string, ptr->length) == 0)
      {
	if (exp_p->X_add_number != 0)
	  as_warn (_("identifier+constant@@%s means identifier@@%s+constant"),
		   ptr->string, ptr->string);
	/* Now check for identifier@@suffix+constant.  */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;

	    input_line_pointer = str;
	    expression (&new_exp);

	    switch (new_exp.X_op)
	      {
	      case O_constant: /* X_add_number (a constant expression).  */
		exp_p->X_add_number += new_exp.X_add_number;
		str = input_line_pointer;
		break;
	      case O_symbol:   /* X_add_symbol + X_add_number.  */
		/* this case is used for e.g. xyz@@PLT+.Label.  */
		exp_p->X_add_number += new_exp.X_add_number;
		exp_p->X_op_symbol = new_exp.X_add_symbol;
		exp_p->X_op = O_add;
		str = input_line_pointer;
		break;
	      case O_uminus:   /* (- X_add_symbol) + X_add_number.  */
		/* this case is used for e.g. xyz@@PLT-.Label.  */
		exp_p->X_add_number += new_exp.X_add_number;
		exp_p->X_op_symbol = new_exp.X_add_symbol;
		exp_p->X_op = O_subtract;
		str = input_line_pointer;
		break;
	      default:
		break;
	      }

	    /* If s390_elf_suffix has not been called with
	       &input_line_pointer as first parameter, we have
	       clobbered the input_line_pointer. We have to
	       undo that.  */
	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }
	*str_p = str;
	return ptr->suffix;
      }

  return BFD_RELOC_UNUSED;
}

/* Structure used to hold a literal pool entry.  */
struct s390_lpe
  {
    struct s390_lpe *next;
    expressionS ex;
    FLONUM_TYPE floatnum;     /* used if X_op == O_big && X_add_number <= 0 */
    LITTLENUM_TYPE bignum[4]; /* used if X_op == O_big && X_add_number > 0  */
    int nbytes;
    bfd_reloc_code_real_type reloc;
    symbolS *sym;
  };

static struct s390_lpe *lpe_free_list = NULL;
static struct s390_lpe *lpe_list = NULL;
static struct s390_lpe *lpe_list_tail = NULL;
static symbolS *lp_sym = NULL;
static int lp_count = 0;
static int lpe_count = 0;

static int
s390_exp_compare (expressionS *exp1, expressionS *exp2)
{
  if (exp1->X_op != exp2->X_op)
    return 0;

  switch (exp1->X_op)
    {
    case O_constant:   /* X_add_number must be equal.  */
    case O_register:
      return exp1->X_add_number == exp2->X_add_number;

    case O_big:
      as_bad (_("Can't handle O_big in s390_exp_compare"));

    case O_symbol:     /* X_add_symbol & X_add_number must be equal.  */
    case O_symbol_rva:
    case O_uminus:
    case O_bit_not:
    case O_logical_not:
      return (exp1->X_add_symbol == exp2->X_add_symbol)
	&&   (exp1->X_add_number == exp2->X_add_number);

    case O_multiply:   /* X_add_symbol,X_op_symbol&X_add_number must be equal.  */
    case O_divide:
    case O_modulus:
    case O_left_shift:
    case O_right_shift:
    case O_bit_inclusive_or:
    case O_bit_or_not:
    case O_bit_exclusive_or:
    case O_bit_and:
    case O_add:
    case O_subtract:
    case O_eq:
    case O_ne:
    case O_lt:
    case O_le:
    case O_ge:
    case O_gt:
    case O_logical_and:
    case O_logical_or:
      return (exp1->X_add_symbol == exp2->X_add_symbol)
	&&   (exp1->X_op_symbol  == exp2->X_op_symbol)
	&&   (exp1->X_add_number == exp2->X_add_number);
    default:
      return 0;
    }
}

/* Test for @@lit and if its present make an entry in the literal pool and
   modify the current expression to be an offset into the literal pool.  */
static elf_suffix_type
s390_lit_suffix (char **str_p, expressionS *exp_p, elf_suffix_type suffix)
{
  bfd_reloc_code_real_type reloc;
  char tmp_name[64];
  char *str = *str_p;
  char *ident;
  struct s390_lpe *lpe;
  int nbytes, len;

  if (*str++ != ':')
    return suffix;       /* No modification.  */

  /* We look for a suffix of the form "@@lit1", "@@lit2", "@@lit4" or "@@lit8".  */
  ident = str;
  while (ISALNUM (*str))
    str++;
  len = str - ident;
  if (len != 4 || strncasecmp (ident, "lit", 3) != 0
      || (ident[3]!='1' && ident[3]!='2' && ident[3]!='4' && ident[3]!='8'))
    return suffix;      /* no modification */
  nbytes = ident[3] - '0';

  reloc = BFD_RELOC_UNUSED;
  if (suffix == ELF_SUFFIX_GOT)
    {
      if (nbytes == 2)
	reloc = BFD_RELOC_390_GOT16;
      else if (nbytes == 4)
	reloc = BFD_RELOC_32_GOT_PCREL;
      else if (nbytes == 8)
	reloc = BFD_RELOC_390_GOT64;
    }
  else if (suffix == ELF_SUFFIX_PLT)
    {
      if (nbytes == 4)
	reloc = BFD_RELOC_390_PLT32;
      else if (nbytes == 8)
	reloc = BFD_RELOC_390_PLT64;
    }

  if (suffix != ELF_SUFFIX_NONE && reloc == BFD_RELOC_UNUSED)
    as_bad (_("Invalid suffix for literal pool entry"));

  /* Search the pool if the new entry is a duplicate.  */
  if (exp_p->X_op == O_big)
    {
      /* Special processing for big numbers.  */
      for (lpe = lpe_list; lpe != NULL; lpe = lpe->next)
	{
	  if (lpe->ex.X_op == O_big)
	    {
	      if (exp_p->X_add_number <= 0 && lpe->ex.X_add_number <= 0)
		{
		  if (memcmp (&generic_floating_point_number, &lpe->floatnum,
			      sizeof (FLONUM_TYPE)) == 0)
		    break;
		}
	      else if (exp_p->X_add_number == lpe->ex.X_add_number)
		{
		  if (memcmp (generic_bignum, lpe->bignum,
			      sizeof (LITTLENUM_TYPE)*exp_p->X_add_number) == 0)
		    break;
		}
	    }
	}
    }
  else
    {
      /* Processing for 'normal' data types.  */
      for (lpe = lpe_list; lpe != NULL; lpe = lpe->next)
	if (lpe->nbytes == nbytes && lpe->reloc == reloc
	    && s390_exp_compare (exp_p, &lpe->ex) != 0)
	  break;
    }

  if (lpe == NULL)
    {
      /* A new literal.  */
      if (lpe_free_list != NULL)
	{
	  lpe = lpe_free_list;
	  lpe_free_list = lpe_free_list->next;
	}
      else
	{
	  lpe = (struct s390_lpe *) xmalloc (sizeof (struct s390_lpe));
	}

      lpe->ex = *exp_p;

      if (exp_p->X_op == O_big)
	{
	  if (exp_p->X_add_number <= 0)
	    lpe->floatnum = generic_floating_point_number;
	  else if (exp_p->X_add_number <= 4)
	    memcpy (lpe->bignum, generic_bignum,
		    exp_p->X_add_number * sizeof (LITTLENUM_TYPE));
	  else
	    as_bad (_("Big number is too big"));
	}

      lpe->nbytes = nbytes;
      lpe->reloc = reloc;
      /* Literal pool name defined ?  */
      if (lp_sym == NULL)
	{
	  sprintf (tmp_name, ".L\001%i", lp_count);
	  lp_sym = symbol_make (tmp_name);
	}

      /* Make name for literal pool entry.  */
      sprintf (tmp_name, ".L\001%i\002%i", lp_count, lpe_count);
      lpe_count++;
      lpe->sym = symbol_make (tmp_name);

      /* Add to literal pool list.  */
      lpe->next = NULL;
      if (lpe_list_tail != NULL)
	{
	  lpe_list_tail->next = lpe;
	  lpe_list_tail = lpe;
	}
      else
	lpe_list = lpe_list_tail = lpe;
    }

  /* Now change exp_p to the offset into the literal pool.
     Thats the expression: .L^Ax^By-.L^Ax   */
  exp_p->X_add_symbol = lpe->sym;
  exp_p->X_op_symbol = lp_sym;
  exp_p->X_op = O_subtract;
  exp_p->X_add_number = 0;

  *str_p = str;

  /* We change the suffix type to ELF_SUFFIX_NONE, because
     the difference of two local labels is just a number.  */
  return ELF_SUFFIX_NONE;
}

/* Like normal .long/.short/.word, except support @@got, etc.
   clobbers input_line_pointer, checks end-of-line.  */
static void
s390_elf_cons (int nbytes /* 1=.byte, 2=.word, 4=.long */)
{
  expressionS exp;
  elf_suffix_type suffix;

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);

      if (exp.X_op == O_symbol
	  && *input_line_pointer == '@@'
	  && (suffix = s390_elf_suffix (&input_line_pointer, &exp)) != ELF_SUFFIX_NONE)
	{
	  bfd_reloc_code_real_type reloc;
	  reloc_howto_type *reloc_howto;
	  int size;
	  char *where;

	  if (nbytes == 2)
	    {
	      static bfd_reloc_code_real_type tab2[] =
		{
		  BFD_RELOC_UNUSED, 		/* ELF_SUFFIX_NONE  */
		  BFD_RELOC_390_GOT16,		/* ELF_SUFFIX_GOT  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_PLT  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_GOTENT  */
		  BFD_RELOC_16_GOTOFF,		/* ELF_SUFFIX_GOTOFF  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_GOTPLT  */
		  BFD_RELOC_390_PLTOFF16,	/* ELF_SUFFIX_PLTOFF  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_TLS_GD  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_TLS_GOTIE  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_TLS_IE  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_TLS_LDM  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_TLS_LDO  */
		  BFD_RELOC_UNUSED		/* ELF_SUFFIX_TLS_LE  */
		};
	      reloc = tab2[suffix];
	    }
	  else if (nbytes == 4)
	    {
	      static bfd_reloc_code_real_type tab4[] =
		{
		  BFD_RELOC_UNUSED, 		/* ELF_SUFFIX_NONE  */
		  BFD_RELOC_32_GOT_PCREL,	/* ELF_SUFFIX_GOT  */
		  BFD_RELOC_390_PLT32,		/* ELF_SUFFIX_PLT  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_GOTENT  */
		  BFD_RELOC_32_GOTOFF,		/* ELF_SUFFIX_GOTOFF  */
		  BFD_RELOC_390_GOTPLT32,	/* ELF_SUFFIX_GOTPLT  */
		  BFD_RELOC_390_PLTOFF32,	/* ELF_SUFFIX_PLTOFF  */
		  BFD_RELOC_390_TLS_GD32,	/* ELF_SUFFIX_TLS_GD  */
		  BFD_RELOC_390_TLS_GOTIE32,	/* ELF_SUFFIX_TLS_GOTIE  */
		  BFD_RELOC_390_TLS_IE32,	/* ELF_SUFFIX_TLS_IE  */
		  BFD_RELOC_390_TLS_LDM32,	/* ELF_SUFFIX_TLS_LDM  */
		  BFD_RELOC_390_TLS_LDO32,	/* ELF_SUFFIX_TLS_LDO  */
		  BFD_RELOC_390_TLS_LE32	/* ELF_SUFFIX_TLS_LE  */
		};
	      reloc = tab4[suffix];
	    }
	  else if (nbytes == 8)
	    {
	      static bfd_reloc_code_real_type tab8[] =
		{
		  BFD_RELOC_UNUSED, 		/* ELF_SUFFIX_NONE  */
		  BFD_RELOC_390_GOT64,		/* ELF_SUFFIX_GOT  */
		  BFD_RELOC_390_PLT64,		/* ELF_SUFFIX_PLT  */
		  BFD_RELOC_UNUSED,		/* ELF_SUFFIX_GOTENT  */
		  BFD_RELOC_390_GOTOFF64,	/* ELF_SUFFIX_GOTOFF  */
		  BFD_RELOC_390_GOTPLT64,	/* ELF_SUFFIX_GOTPLT  */
		  BFD_RELOC_390_PLTOFF64,	/* ELF_SUFFIX_PLTOFF  */
		  BFD_RELOC_390_TLS_GD64,	/* ELF_SUFFIX_TLS_GD  */
		  BFD_RELOC_390_TLS_GOTIE64,	/* ELF_SUFFIX_TLS_GOTIE  */
		  BFD_RELOC_390_TLS_IE64,	/* ELF_SUFFIX_TLS_IE  */
		  BFD_RELOC_390_TLS_LDM64,	/* ELF_SUFFIX_TLS_LDM  */
		  BFD_RELOC_390_TLS_LDO64,	/* ELF_SUFFIX_TLS_LDO  */
		  BFD_RELOC_390_TLS_LE64	/* ELF_SUFFIX_TLS_LE  */
		};
	      reloc = tab8[suffix];
	    }
	  else
	    reloc = BFD_RELOC_UNUSED;

	  if (reloc != BFD_RELOC_UNUSED
	      && (reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc)))
	    {
	      size = bfd_get_reloc_size (reloc_howto);
	      if (size > nbytes)
		as_bad (_("%s relocations do not fit in %d bytes"),
			reloc_howto->name, nbytes);
	      where = frag_more (nbytes);
	      md_number_to_chars (where, 0, size);
	      /* To make fixup_segment do the pc relative conversion the
		 pcrel parameter on the fix_new_exp call needs to be FALSE.  */
	      fix_new_exp (frag_now, where - frag_now->fr_literal,
			   size, &exp, FALSE, reloc);
	    }
	  else
	    as_bad (_("relocation not applicable"));
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
}

/* We need to keep a list of fixups.  We can't simply generate them as
   we go, because that would require us to first create the frag, and
   that would screw up references to ``.''.  */

struct s390_fixup
  {
    expressionS exp;
    int opindex;
    bfd_reloc_code_real_type reloc;
  };

#define MAX_INSN_FIXUPS (4)

/* This routine is called for each instruction to be assembled.  */

static char *
md_gather_operands (char *str,
		    unsigned char *insn,
		    const struct s390_opcode *opcode)
{
  struct s390_fixup fixups[MAX_INSN_FIXUPS];
  const struct s390_operand *operand;
  const unsigned char *opindex_ptr;
  expressionS ex;
  elf_suffix_type suffix;
  bfd_reloc_code_real_type reloc;
  int skip_optional;
  char *f;
  int fc, i;

  while (ISSPACE (*str))
    str++;

  skip_optional = 0;

  /* Gather the operands.  */
  fc = 0;
  for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
    {
      char *hold;

      operand = s390_operands + *opindex_ptr;

      if (skip_optional && (operand->flags & S390_OPERAND_INDEX))
	{
	  /* We do an early skip. For D(X,B) constructions the index
	     register is skipped (X is optional). For D(L,B) the base
	     register will be the skipped operand, because L is NOT
	     optional.  */
	  skip_optional = 0;
	  continue;
	}

      /* Gather the operand.  */
      hold = input_line_pointer;
      input_line_pointer = str;

      /* Parse the operand.  */
      if (! register_name (&ex))
	expression (&ex);

      str = input_line_pointer;
      input_line_pointer = hold;

      /* Write the operand to the insn.  */
      if (ex.X_op == O_illegal)
	as_bad (_("illegal operand"));
      else if (ex.X_op == O_absent)
	{
	  /* No operands, check if all operands can be skipped.  */
	  while (*opindex_ptr != 0 && operand->flags & S390_OPERAND_OPTIONAL)
	    {
	      if (operand->flags & S390_OPERAND_DISP)
		{
		  /* An optional displacement makes the whole D(X,B)
		     D(L,B) or D(B) block optional.  */
		  do {
		    operand = s390_operands + *(++opindex_ptr);
		  } while (!(operand->flags & S390_OPERAND_BASE));
		}
	      operand = s390_operands + *(++opindex_ptr);
	    }
	  if (opindex_ptr[0] == '\0')
	    break;
	  as_bad (_("missing operand"));
	}
      else if (ex.X_op == O_register || ex.X_op == O_constant)
	{
	  s390_lit_suffix (&str, &ex, ELF_SUFFIX_NONE);

	  if (ex.X_op != O_register && ex.X_op != O_constant)
	    {
	      /* We need to generate a fixup for the
		 expression returned by s390_lit_suffix.  */
	      if (fc >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));
	      fixups[fc].exp = ex;
	      fixups[fc].opindex = *opindex_ptr;
	      fixups[fc].reloc = BFD_RELOC_UNUSED;
	      ++fc;
	    }
	  else
	    {
	      if ((operand->flags & S390_OPERAND_INDEX)
		  && ex.X_add_number == 0
		  && warn_areg_zero)
		as_warn (_("index register specified but zero"));
	      if ((operand->flags & S390_OPERAND_BASE)
		  && ex.X_add_number == 0
		  && warn_areg_zero)
		as_warn (_("base register specified but zero"));
	      if ((operand->flags & S390_OPERAND_GPR)
		  && (operand->flags & S390_OPERAND_REG_PAIR)
		  && (ex.X_add_number & 1))
		as_fatal (_("odd numbered general purpose register specified as "
			    "register pair"));
	      if ((operand->flags & S390_OPERAND_FPR)
		  && (operand->flags & S390_OPERAND_REG_PAIR)
		  && ex.X_add_number != 0 && ex.X_add_number != 1
		  && ex.X_add_number != 4 && ex.X_add_number != 5
		  && ex.X_add_number != 8 && ex.X_add_number != 9
		  && ex.X_add_number != 12 && ex.X_add_number != 13)
		as_fatal (_("invalid floating point register pair.  Valid fp "
			    "register pair operands are 0, 1, 4, 5, 8, 9, "
			    "12 or 13."));
	      s390_insert_operand (insn, operand, ex.X_add_number, NULL, 0);
	    }
	}
      else
	{
	  suffix = s390_elf_suffix (&str, &ex);
	  suffix = s390_lit_suffix (&str, &ex, suffix);
	  reloc = BFD_RELOC_UNUSED;

	  if (suffix == ELF_SUFFIX_GOT)
	    {
	      if ((operand->flags & S390_OPERAND_DISP) &&
		  (operand->bits == 12))
		reloc = BFD_RELOC_390_GOT12;
	      else if ((operand->flags & S390_OPERAND_DISP) &&
		       (operand->bits == 20))
		reloc = BFD_RELOC_390_GOT20;
	      else if ((operand->flags & S390_OPERAND_SIGNED)
		       && (operand->bits == 16))
		reloc = BFD_RELOC_390_GOT16;
	      else if ((operand->flags & S390_OPERAND_PCREL)
		       && (operand->bits == 32))
		reloc = BFD_RELOC_390_GOTENT;
	    }
	  else if (suffix == ELF_SUFFIX_PLT)
	    {
	      if ((operand->flags & S390_OPERAND_PCREL)
		  && (operand->bits == 12))
		reloc = BFD_RELOC_390_PLT12DBL;
	      else if ((operand->flags & S390_OPERAND_PCREL)
		       && (operand->bits == 16))
		reloc = BFD_RELOC_390_PLT16DBL;
	      else if ((operand->flags & S390_OPERAND_PCREL)
		       && (operand->bits == 24))
		reloc = BFD_RELOC_390_PLT24DBL;
	      else if ((operand->flags & S390_OPERAND_PCREL)
		       && (operand->bits == 32))
		reloc = BFD_RELOC_390_PLT32DBL;
	    }
	  else if (suffix == ELF_SUFFIX_GOTENT)
	    {
	      if ((operand->flags & S390_OPERAND_PCREL)
		  && (operand->bits == 32))
		reloc = BFD_RELOC_390_GOTENT;
	    }
	  else if (suffix == ELF_SUFFIX_GOTOFF)
	    {
	      if ((operand->flags & S390_OPERAND_SIGNED)
		  && (operand->bits == 16))
		reloc = BFD_RELOC_16_GOTOFF;
	    }
	  else if (suffix == ELF_SUFFIX_PLTOFF)
	    {
	      if ((operand->flags & S390_OPERAND_SIGNED)
		  && (operand->bits == 16))
		reloc = BFD_RELOC_390_PLTOFF16;
	    }
	  else if (suffix == ELF_SUFFIX_GOTPLT)
	    {
	      if ((operand->flags & S390_OPERAND_DISP)
		  && (operand->bits == 12))
		reloc = BFD_RELOC_390_GOTPLT12;
	      else if ((operand->flags & S390_OPERAND_SIGNED)
		       && (operand->bits == 16))
		reloc = BFD_RELOC_390_GOTPLT16;
	      else if ((operand->flags & S390_OPERAND_PCREL)
		       && (operand->bits == 32))
		reloc = BFD_RELOC_390_GOTPLTENT;
	    }
	  else if (suffix == ELF_SUFFIX_TLS_GOTIE)
	    {
	      if ((operand->flags & S390_OPERAND_DISP)
		  && (operand->bits == 12))
		reloc = BFD_RELOC_390_TLS_GOTIE12;
	      else if ((operand->flags & S390_OPERAND_DISP)
		       && (operand->bits == 20))
		reloc = BFD_RELOC_390_TLS_GOTIE20;
	    }
	  else if (suffix == ELF_SUFFIX_TLS_IE)
	    {
	      if ((operand->flags & S390_OPERAND_PCREL)
		       && (operand->bits == 32))
		reloc = BFD_RELOC_390_TLS_IEENT;
	    }

	  if (suffix != ELF_SUFFIX_NONE && reloc == BFD_RELOC_UNUSED)
	    as_bad (_("invalid operand suffix"));
	  /* We need to generate a fixup of type 'reloc' for this
	     expression.  */
	  if (fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));
	  fixups[fc].exp = ex;
	  fixups[fc].opindex = *opindex_ptr;
	  fixups[fc].reloc = reloc;
	  ++fc;
	}

      /* Check the next character. The call to expression has advanced
	 str past any whitespace.  */
      if (operand->flags & S390_OPERAND_DISP)
	{
	  /* After a displacement a block in parentheses can start.  */
	  if (*str != '(')
	    {
	      /* Check if parenthesized block can be skipped. If the next
		 operand is neiter an optional operand nor a base register
		 then we have a syntax error.  */
	      operand = s390_operands + *(++opindex_ptr);
	      if (!(operand->flags & (S390_OPERAND_INDEX|S390_OPERAND_BASE)))
		as_bad (_("syntax error; missing '(' after displacement"));

	      /* Ok, skip all operands until S390_OPERAND_BASE.  */
	      while (!(operand->flags & S390_OPERAND_BASE))
		operand = s390_operands + *(++opindex_ptr);

	      /* If there is a next operand it must be separated by a comma.  */
	      if (opindex_ptr[1] != '\0')
		{
		  if (*str != ',')
		    {
		      while (opindex_ptr[1] != '\0')
			{
			  operand = s390_operands + *(++opindex_ptr);
			  if (operand->flags & S390_OPERAND_OPTIONAL)
			    continue;
			  as_bad (_("syntax error; expected ,"));
			  break;
			}
		    }
		  else
		    str++;
		}
	    }
	  else
	    {
	      /* We found an opening parentheses.  */
	      str++;
	      for (f = str; *f != '\0'; f++)
		if (*f == ',' || *f == ')')
		  break;
	      /* If there is no comma until the closing parentheses OR
		 there is a comma right after the opening parentheses,
		 we have to skip optional operands.  */
	      if (*f == ',' && f == str)
		{
		  /* comma directly after '(' ? */
		  skip_optional = 1;
		  str++;
		}
	      else
		skip_optional = (*f != ',');
	    }
	}
      else if (operand->flags & S390_OPERAND_BASE)
	{
	  /* After the base register the parenthesed block ends.  */
	  if (*str++ != ')')
	    as_bad (_("syntax error; missing ')' after base register"));
	  skip_optional = 0;
	  /* If there is a next operand it must be separated by a comma.  */
	  if (opindex_ptr[1] != '\0')
	    {
	      if (*str != ',')
		{
		  while (opindex_ptr[1] != '\0')
		    {
		      operand = s390_operands + *(++opindex_ptr);
		      if (operand->flags & S390_OPERAND_OPTIONAL)
			continue;
		      as_bad (_("syntax error; expected ,"));
		      break;
		    }
		}
	      else
		str++;
	    }
	}
      else
	{
	  /* We can find an 'early' closing parentheses in e.g. D(L) instead
	     of D(L,B).  In this case the base register has to be skipped.  */
	  if (*str == ')')
	    {
	      operand = s390_operands + *(++opindex_ptr);

	      if (!(operand->flags & S390_OPERAND_BASE))
		as_bad (_("syntax error; ')' not allowed here"));
	      str++;
	    }
	  /* If there is a next operand it must be separated by a comma.  */
	  if (opindex_ptr[1] != '\0')
	    {
	      if (*str != ',')
		{
		  while (opindex_ptr[1] != '\0')
		    {
		      operand = s390_operands + *(++opindex_ptr);
		      if (operand->flags & S390_OPERAND_OPTIONAL)
			continue;
		      as_bad (_("syntax error; expected ,"));
		      break;
		    }
		}
	      else
		str++;
	    }
	}
    }

  while (ISSPACE (*str))
    ++str;

  /* Check for tls instruction marker.  */
  reloc = s390_tls_suffix (&str, &ex);
  if (reloc != BFD_RELOC_UNUSED)
    {
      /* We need to generate a fixup of type 'reloc' for this
	 instruction.  */
      if (fc >= MAX_INSN_FIXUPS)
	as_fatal (_("too many fixups"));
      fixups[fc].exp = ex;
      fixups[fc].opindex = -1;
      fixups[fc].reloc = reloc;
      ++fc;
    }

  if (*str != '\0')
    {
      char *linefeed;

      if ((linefeed = strchr (str, '\n')) != NULL)
	*linefeed = '\0';
      as_bad (_("junk at end of line: `%s'"), str);
      if (linefeed != NULL)
	*linefeed = '\n';
    }

  /* Write out the instruction.  */
  f = frag_more (opcode->oplen);
  memcpy (f, insn, opcode->oplen);
  dwarf2_emit_insn (opcode->oplen);

  /* Create any fixups.  At this point we do not use a
     bfd_reloc_code_real_type, but instead just use the
     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
     handle fixups for any operand type, although that is admittedly
     not a very exciting feature.  We pick a BFD reloc type in
     md_apply_fix.  */
  for (i = 0; i < fc; i++)
    {

      if (fixups[i].opindex < 0)
	{
	  /* Create tls instruction marker relocation.  */
	  fix_new_exp (frag_now, f - frag_now->fr_literal, opcode->oplen,
		       &fixups[i].exp, 0, fixups[i].reloc);
	  continue;
	}

      operand = s390_operands + fixups[i].opindex;

      if (fixups[i].reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto;
	  fixS *fixP;
	  int size;

	  reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
	  if (!reloc_howto)
	    abort ();

	  size = ((reloc_howto->bitsize - 1) / 8) + 1;

	  if (size < 1 || size > 4)
	    abort ();

	  fixP = fix_new_exp (frag_now,
			      f - frag_now->fr_literal + (operand->shift/8),
			      size, &fixups[i].exp, reloc_howto->pc_relative,
			      fixups[i].reloc);
	  /* Turn off overflow checking in fixup_segment. This is necessary
	     because fixup_segment will signal an overflow for large 4 byte
	     quantities for GOT12 relocations.  */
	  if (   fixups[i].reloc == BFD_RELOC_390_GOT12
	      || fixups[i].reloc == BFD_RELOC_390_GOT20
	      || fixups[i].reloc == BFD_RELOC_390_GOT16)
	    fixP->fx_no_overflow = 1;
	}
      else
	fix_new_exp (frag_now, f - frag_now->fr_literal, 4, &fixups[i].exp,
		     (operand->flags & S390_OPERAND_PCREL) != 0,
		     ((bfd_reloc_code_real_type)
		      (fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
    }
  return str;
}

/* This routine is called for each instruction to be assembled.  */

void
md_assemble (char *str)
{
  const struct s390_opcode *opcode;
  unsigned char insn[6];
  char *s;

  /* Get the opcode.  */
  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* Look up the opcode in the hash table.  */
  opcode = (struct s390_opcode *) hash_find (s390_opcode_hash, str);
  if (opcode == (const struct s390_opcode *) NULL)
    {
      as_bad (_("Unrecognized opcode: `%s'"), str);
      return;
    }
  else if (!(opcode->modes & current_mode_mask))
    {
      as_bad (_("Opcode %s not available in this mode"), str);
      return;
    }
  memcpy (insn, opcode->opcode, sizeof (insn));
  md_gather_operands (s, insn, opcode);
}

#ifndef WORKING_DOT_WORD
/* Handle long and short jumps. We don't support these */
void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  abort ();
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  abort ();
}
#endif

void
s390_bss (int ignore ATTRIBUTE_UNUSED)
{
  /* We don't support putting frags in the BSS segment, we fake it
     by marking in_bss, then looking at s_skip for clues.  */

  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
}

/* Pseudo-op handling.  */

void
s390_insn (int ignore ATTRIBUTE_UNUSED)
{
  expressionS exp;
  const struct s390_opcode *opformat;
  unsigned char insn[6];
  char *s;

  /* Get the opcode format.  */
  s = input_line_pointer;
  while (*s != '\0' && *s != ',' && ! ISSPACE (*s))
    s++;
  if (*s != ',')
    as_bad (_("Invalid .insn format\n"));
  *s++ = '\0';

  /* Look up the opcode in the hash table.  */
  opformat = (struct s390_opcode *)
    hash_find (s390_opformat_hash, input_line_pointer);
  if (opformat == (const struct s390_opcode *) NULL)
    {
      as_bad (_("Unrecognized opcode format: `%s'"), input_line_pointer);
      return;
    }
  input_line_pointer = s;
  expression (&exp);
  if (exp.X_op == O_constant)
    {
      if (   (   opformat->oplen == 6
	      && (addressT) exp.X_add_number < (1ULL << 48))
	  || (   opformat->oplen == 4
	      && (addressT) exp.X_add_number < (1ULL << 32))
	  || (   opformat->oplen == 2
	      && (addressT) exp.X_add_number < (1ULL << 16)))
	md_number_to_chars ((char *) insn, exp.X_add_number, opformat->oplen);
      else
	as_bad (_("Invalid .insn format\n"));
    }
  else if (exp.X_op == O_big)
    {
      if (exp.X_add_number > 0
	  && opformat->oplen == 6
	  && generic_bignum[3] == 0)
	{
	  md_number_to_chars ((char *) insn, generic_bignum[2], 2);
	  md_number_to_chars ((char *) &insn[2], generic_bignum[1], 2);
	  md_number_to_chars ((char *) &insn[4], generic_bignum[0], 2);
	}
      else
	as_bad (_("Invalid .insn format\n"));
    }
  else
    as_bad (_("second operand of .insn not a constant\n"));

  if (strcmp (opformat->name, "e") != 0 && *input_line_pointer++ != ',')
    as_bad (_("missing comma after insn constant\n"));

  if ((s = strchr (input_line_pointer, '\n')) != NULL)
    *s = '\0';
  input_line_pointer = md_gather_operands (input_line_pointer, insn,
					   opformat);
  if (s != NULL)
    *s = '\n';
  demand_empty_rest_of_line ();
}

/* The .byte pseudo-op.  This is similar to the normal .byte
   pseudo-op, but it can also take a single ASCII string.  */

static void
s390_byte (int ignore ATTRIBUTE_UNUSED)
{
  if (*input_line_pointer != '\"')
    {
      cons (1);
      return;
    }

  /* Gather characters.  A real double quote is doubled.  Unusual
     characters are not permitted.  */
  ++input_line_pointer;
  while (1)
    {
      char c;

      c = *input_line_pointer++;

      if (c == '\"')
	{
	  if (*input_line_pointer != '\"')
	    break;
	  ++input_line_pointer;
	}

      FRAG_APPEND_1_CHAR (c);
    }

  demand_empty_rest_of_line ();
}

/* The .ltorg pseudo-op.This emits all literals defined since the last
   .ltorg or the invocation of gas. Literals are defined with the
   @@lit suffix.  */

static void
s390_literals (int ignore ATTRIBUTE_UNUSED)
{
  struct s390_lpe *lpe;

  if (lp_sym == NULL || lpe_count == 0)
    return;     /* Nothing to be done.  */

  /* Emit symbol for start of literal pool.  */
  S_SET_SEGMENT (lp_sym, now_seg);
  S_SET_VALUE (lp_sym, (valueT) frag_now_fix ());
  lp_sym->sy_frag = frag_now;

  while (lpe_list)
    {
      lpe = lpe_list;
      lpe_list = lpe_list->next;
      S_SET_SEGMENT (lpe->sym, now_seg);
      S_SET_VALUE (lpe->sym, (valueT) frag_now_fix ());
      lpe->sym->sy_frag = frag_now;

      /* Emit literal pool entry.  */
      if (lpe->reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto =
	    bfd_reloc_type_lookup (stdoutput, lpe->reloc);
	  int size = bfd_get_reloc_size (reloc_howto);
	  char *where;

	  if (size > lpe->nbytes)
	    as_bad (_("%s relocations do not fit in %d bytes"),
		    reloc_howto->name, lpe->nbytes);
	  where = frag_more (lpe->nbytes);
	  md_number_to_chars (where, 0, size);
	  fix_new_exp (frag_now, where - frag_now->fr_literal,
		       size, &lpe->ex, reloc_howto->pc_relative, lpe->reloc);
	}
      else
	{
	  if (lpe->ex.X_op == O_big)
	    {
	      if (lpe->ex.X_add_number <= 0)
		generic_floating_point_number = lpe->floatnum;
	      else
		memcpy (generic_bignum, lpe->bignum,
			lpe->ex.X_add_number * sizeof (LITTLENUM_TYPE));
	    }
	  emit_expr (&lpe->ex, lpe->nbytes);
	}

      lpe->next = lpe_free_list;
      lpe_free_list = lpe;
    }
  lpe_list_tail = NULL;
  lp_sym = NULL;
  lp_count++;
  lpe_count = 0;
}

/* The .machine pseudo op allows to switch to a different CPU level in
   the asm listing.  The current CPU setting can be stored on a stack
   with .machine push and restored with .machine pop.  */

static void
s390_machine (int ignore ATTRIBUTE_UNUSED)
{
  char *cpu_string;
#define MAX_HISTORY 100
  static unsigned int *cpu_history;
  static int curr_hist;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      int len;
      cpu_string = demand_copy_C_string (&len);
    }
  else
    {
      char c;
      cpu_string = input_line_pointer;
      c = get_symbol_end ();
      cpu_string = xstrdup (cpu_string);
      *input_line_pointer = c;
    }

  if (cpu_string != NULL)
    {
      unsigned int old_cpu = current_cpu;
      unsigned int new_cpu;

      if (strcmp (cpu_string, "push") == 0)
	{
	  if (cpu_history == NULL)
	    cpu_history = xmalloc (MAX_HISTORY * sizeof (*cpu_history));

	  if (curr_hist >= MAX_HISTORY)
	    as_bad (_(".machine stack overflow"));
	  else
	    cpu_history[curr_hist++] = current_cpu;
	}
      else if (strcmp (cpu_string, "pop") == 0)
	{
	  if (curr_hist <= 0)
	    as_bad (_(".machine stack underflow"));
	  else
	    current_cpu = cpu_history[--curr_hist];
	}
      else if ((new_cpu = s390_parse_cpu (cpu_string)) != (unsigned int)-1)
	current_cpu = new_cpu;
      else
	as_bad (_("invalid machine `%s'"), cpu_string);

      if (current_cpu != old_cpu)
	s390_setup_opcodes ();
    }

  demand_empty_rest_of_line ();
}

/* The .machinemode pseudo op allows to switch to a different
   architecture mode in the asm listing.  The current architecture
   mode setting can be stored on a stack with .machinemode push and
   restored with .machinemode pop.  */

static void
s390_machinemode (int ignore ATTRIBUTE_UNUSED)
{
  char *mode_string;
#define MAX_HISTORY 100
  static unsigned int *mode_history;
  static int curr_hist;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      int len;
      mode_string = demand_copy_C_string (&len);
    }
  else
    {
      char c;
      mode_string = input_line_pointer;
      c = get_symbol_end ();
      mode_string = xstrdup (mode_string);
      *input_line_pointer = c;
    }

  if (mode_string != NULL)
    {
      unsigned int old_mode_mask = current_mode_mask;
      char *p;

      for (p = mode_string; *p != 0; p++)
	*p = TOLOWER (*p);

      if (strcmp (mode_string, "push") == 0)
	{
	  if (mode_history == NULL)
	    mode_history = xmalloc (MAX_HISTORY * sizeof (*mode_history));

	  if (curr_hist >= MAX_HISTORY)
	    as_bad (_(".machinemode stack overflow"));
	  else
	    mode_history[curr_hist++] = current_mode_mask;
	}
      else if (strcmp (mode_string, "pop") == 0)
	{
	  if (curr_hist <= 0)
	    as_bad (_(".machinemode stack underflow"));
	  else
	    current_mode_mask = mode_history[--curr_hist];
	}
      else
	{
	  if (strcmp (mode_string, "esa") == 0)
	    current_mode_mask = 1 << S390_OPCODE_ESA;
	  else if (strcmp (mode_string, "zarch") == 0)
	    {
	      if (s390_arch_size == 32)
		set_highgprs_p = TRUE;
	      current_mode_mask = 1 << S390_OPCODE_ZARCH;
	    }
	  else if (strcmp (mode_string, "zarch_nohighgprs") == 0)
	    current_mode_mask = 1 << S390_OPCODE_ZARCH;
	  else
	    as_bad (_("invalid machine `%s'"), mode_string);
	}

      if (current_mode_mask != old_mode_mask)
	s390_setup_opcodes ();
    }

  demand_empty_rest_of_line ();
}

char *
md_atof (int type, char *litp, int *sizep)
{
  return ieee_md_atof (type, litp, sizep, TRUE);
}

/* Align a section (I don't know why this is machine dependent).  */

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);

  return ((addr + (1 << align) - 1) & (-1 << align));
}

/* We don't have any form of relaxing.  */

int
md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
			       asection *seg ATTRIBUTE_UNUSED)
{
  abort ();
  return 0;
}

/* Convert a machine dependent frag.  We never generate these.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec ATTRIBUTE_UNUSED,
		 fragS *fragp ATTRIBUTE_UNUSED)
{
  abort ();
}

symbolS *
md_undefined_symbol (char *name)
{
  if (*name == '_' && *(name + 1) == 'G'
      && strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad (_("GOT already in symbol table"));
	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, &zero_address_frag);
	}
      return GOT_symbol;
    }
  return 0;
}

/* Functions concerning relocs.  */

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from_section (fixS *fixp, segT sec ATTRIBUTE_UNUSED)
{
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

/* Here we decide which fixups can be adjusted to make them relative to
   the beginning of the section instead of the symbol.  Basically we need
   to make sure that the dynamic relocations are done correctly, so in
   some cases we force the original symbol to be used.  */
int
tc_s390_fix_adjustable (fixS *fixP)
{
  /* Don't adjust references to merge sections.  */
  if ((S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0)
    return 0;
  /* adjust_reloc_syms doesn't know about the GOT.  */
  if (   fixP->fx_r_type == BFD_RELOC_16_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_32_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_390_GOTOFF64
      || fixP->fx_r_type == BFD_RELOC_390_PLTOFF16
      || fixP->fx_r_type == BFD_RELOC_390_PLTOFF32
      || fixP->fx_r_type == BFD_RELOC_390_PLTOFF64
      || fixP->fx_r_type == BFD_RELOC_390_PLT12DBL
      || fixP->fx_r_type == BFD_RELOC_390_PLT16DBL
      || fixP->fx_r_type == BFD_RELOC_390_PLT24DBL
      || fixP->fx_r_type == BFD_RELOC_390_PLT32
      || fixP->fx_r_type == BFD_RELOC_390_PLT32DBL
      || fixP->fx_r_type == BFD_RELOC_390_PLT64
      || fixP->fx_r_type == BFD_RELOC_390_GOT12
      || fixP->fx_r_type == BFD_RELOC_390_GOT20
      || fixP->fx_r_type == BFD_RELOC_390_GOT16
      || fixP->fx_r_type == BFD_RELOC_32_GOT_PCREL
      || fixP->fx_r_type == BFD_RELOC_390_GOT64
      || fixP->fx_r_type == BFD_RELOC_390_GOTENT
      || fixP->fx_r_type == BFD_RELOC_390_GOTPLT12
      || fixP->fx_r_type == BFD_RELOC_390_GOTPLT16
      || fixP->fx_r_type == BFD_RELOC_390_GOTPLT20
      || fixP->fx_r_type == BFD_RELOC_390_GOTPLT32
      || fixP->fx_r_type == BFD_RELOC_390_GOTPLT64
      || fixP->fx_r_type == BFD_RELOC_390_GOTPLTENT
      || fixP->fx_r_type == BFD_RELOC_390_TLS_LOAD
      || fixP->fx_r_type == BFD_RELOC_390_TLS_GDCALL
      || fixP->fx_r_type == BFD_RELOC_390_TLS_LDCALL
      || fixP->fx_r_type == BFD_RELOC_390_TLS_GD32
      || fixP->fx_r_type == BFD_RELOC_390_TLS_GD64
      || fixP->fx_r_type == BFD_RELOC_390_TLS_GOTIE12
      || fixP->fx_r_type == BFD_RELOC_390_TLS_GOTIE20
      || fixP->fx_r_type == BFD_RELOC_390_TLS_GOTIE32
      || fixP->fx_r_type == BFD_RELOC_390_TLS_GOTIE64
      || fixP->fx_r_type == BFD_RELOC_390_TLS_LDM32
      || fixP->fx_r_type == BFD_RELOC_390_TLS_LDM64
      || fixP->fx_r_type == BFD_RELOC_390_TLS_IE32
      || fixP->fx_r_type == BFD_RELOC_390_TLS_IE64
      || fixP->fx_r_type == BFD_RELOC_390_TLS_IEENT
      || fixP->fx_r_type == BFD_RELOC_390_TLS_LE32
      || fixP->fx_r_type == BFD_RELOC_390_TLS_LE64
      || fixP->fx_r_type == BFD_RELOC_390_TLS_LDO32
      || fixP->fx_r_type == BFD_RELOC_390_TLS_LDO64
      || fixP->fx_r_type == BFD_RELOC_390_TLS_DTPMOD
      || fixP->fx_r_type == BFD_RELOC_390_TLS_DTPOFF
      || fixP->fx_r_type == BFD_RELOC_390_TLS_TPOFF
      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;
  return 1;
}

/* Return true if we must always emit a reloc for a type and false if
   there is some hope of resolving it at assembly time.  */
int
tc_s390_force_relocation (struct fix *fixp)
{
  /* Ensure we emit a relocation for every reference to the global
     offset table or to the procedure link table.  */
  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_390_GOT12:
    case BFD_RELOC_390_GOT20:
    case BFD_RELOC_32_GOT_PCREL:
    case BFD_RELOC_32_GOTOFF:
    case BFD_RELOC_390_GOTOFF64:
    case BFD_RELOC_390_PLTOFF16:
    case BFD_RELOC_390_PLTOFF32:
    case BFD_RELOC_390_PLTOFF64:
    case BFD_RELOC_390_GOTPC:
    case BFD_RELOC_390_GOT16:
    case BFD_RELOC_390_GOTPCDBL:
    case BFD_RELOC_390_GOT64:
    case BFD_RELOC_390_GOTENT:
    case BFD_RELOC_390_PLT32:
    case BFD_RELOC_390_PLT12DBL:
    case BFD_RELOC_390_PLT16DBL:
    case BFD_RELOC_390_PLT24DBL:
    case BFD_RELOC_390_PLT32DBL:
    case BFD_RELOC_390_PLT64:
    case BFD_RELOC_390_GOTPLT12:
    case BFD_RELOC_390_GOTPLT16:
    case BFD_RELOC_390_GOTPLT20:
    case BFD_RELOC_390_GOTPLT32:
    case BFD_RELOC_390_GOTPLT64:
    case BFD_RELOC_390_GOTPLTENT:
      return 1;
    default:
      break;
    }

  return generic_force_reloc (fixp);
}

/* Apply a fixup to the object code.  This is called for all the
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the
   fixup.  */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *where;
  valueT value = *valP;

  where = fixP->fx_frag->fr_literal + fixP->fx_where;

  if (fixP->fx_subsy != NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line,
		  _("cannot emit relocation %s against subsy symbol %s"),
		  bfd_get_reloc_code_name (fixP->fx_r_type),
		  S_GET_NAME (fixP->fx_subsy));

  if (fixP->fx_addsy != NULL)
    {
      if (fixP->fx_pcrel)
	value += fixP->fx_frag->fr_address + fixP->fx_where;
    }
  else
    fixP->fx_done = 1;

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      const struct s390_operand *operand;
      int opindex;

      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
      operand = &s390_operands[opindex];

      if (fixP->fx_done)
	{
	  /* Insert the fully resolved operand value.  */
	  s390_insert_operand ((unsigned char *) where, operand,
			       (offsetT) value, fixP->fx_file, fixP->fx_line);
	  return;
	}

      /* Determine a BFD reloc value based on the operand information.
	 We are only prepared to turn a few of the operands into
	 relocs.  */
      fixP->fx_offset = value;
      if (operand->bits == 12 && operand->shift == 20)
	{
	  fixP->fx_size = 2;
	  fixP->fx_where += 2;
	  fixP->fx_r_type = BFD_RELOC_390_12;
	}
      else if (operand->bits == 12 && operand->shift == 36)
	{
	  fixP->fx_size = 2;
	  fixP->fx_where += 4;
	  fixP->fx_r_type = BFD_RELOC_390_12;
	}
      else if (operand->bits == 20 && operand->shift == 20)
	{
	  fixP->fx_size = 2;
	  fixP->fx_where += 2;
	  fixP->fx_r_type = BFD_RELOC_390_20;
	}
      else if (operand->bits == 8 && operand->shift == 8)
	{
	  fixP->fx_size = 1;
	  fixP->fx_where += 1;
	  fixP->fx_r_type = BFD_RELOC_8;
	}
      else if (operand->bits == 12 && operand->shift == 12
	       && (operand->flags & S390_OPERAND_PCREL))
	{
	  fixP->fx_size = 2;
	  fixP->fx_where += 1;
	  fixP->fx_offset += 1;
	  fixP->fx_r_type = BFD_RELOC_390_PC12DBL;
	}
      else if (operand->bits == 16 && operand->shift == 16)
	{
	  fixP->fx_size = 2;
	  fixP->fx_where += 2;
	  if (operand->flags & S390_OPERAND_PCREL)
	    {
	      fixP->fx_r_type = BFD_RELOC_390_PC16DBL;
	      fixP->fx_offset += 2;
	    }
	  else
	    fixP->fx_r_type = BFD_RELOC_16;
	}
      else if (operand->bits == 24 && operand->shift == 24
	       && (operand->flags & S390_OPERAND_PCREL))
	{
	  fixP->fx_size = 3;
	  fixP->fx_where += 3;
	  fixP->fx_offset += 3;
	  fixP->fx_r_type = BFD_RELOC_390_PC24DBL;
	}
      else if (operand->bits == 32 && operand->shift == 16
	       && (operand->flags & S390_OPERAND_PCREL))
	{
	  fixP->fx_size = 4;
	  fixP->fx_where += 2;
	  fixP->fx_offset += 2;
	  fixP->fx_r_type = BFD_RELOC_390_PC32DBL;
	}
      else
	{
	  char *sfile;
	  unsigned int sline;

	  /* Use expr_symbol_where to see if this is an expression
	     symbol.  */
	  if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unresolved expression that must be resolved"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unsupported relocation type"));
	  fixP->fx_done = 1;
	  return;
	}
    }
  else
    {
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_8:
	  if (fixP->fx_pcrel)
	    abort ();
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 1);
	  break;
	case BFD_RELOC_390_12:
	case BFD_RELOC_390_GOT12:
	case BFD_RELOC_390_GOTPLT12:
	case BFD_RELOC_390_PC12DBL:
	case BFD_RELOC_390_PLT12DBL:
	  if (fixP->fx_pcrel)
	    value++;

	  if (fixP->fx_done)
	    {
	      unsigned short mop;

	      if (fixP->fx_pcrel)
		value >>= 1;

	      mop = bfd_getb16 ((unsigned char *) where);
	      mop |= (unsigned short) (value & 0xfff);
	      bfd_putb16 ((bfd_vma) mop, (unsigned char *) where);
	    }
	  break;

	case BFD_RELOC_390_20:
	case BFD_RELOC_390_GOT20:
	case BFD_RELOC_390_GOTPLT20:
	  if (fixP->fx_done)
	    {
	      unsigned int mop;
	      mop = bfd_getb32 ((unsigned char *) where);
	      mop |= (unsigned int) ((value & 0xfff) << 8 |
				     (value & 0xff000) >> 12);
	      bfd_putb32 ((bfd_vma) mop, (unsigned char *) where);
	    } 
	  break;

	case BFD_RELOC_16:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_16_GOT_PCREL:
	case BFD_RELOC_16_GOTOFF:
	  if (fixP->fx_pcrel)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("cannot emit PC relative %s relocation%s%s"),
			  bfd_get_reloc_code_name (fixP->fx_r_type),
			  fixP->fx_addsy != NULL ? " against " : "",
			  (fixP->fx_addsy != NULL
			   ? S_GET_NAME (fixP->fx_addsy)
			   : ""));
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 2);
	  break;
	case BFD_RELOC_390_GOT16:
	case BFD_RELOC_390_PLTOFF16:
	case BFD_RELOC_390_GOTPLT16:
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 2);
	  break;
	case BFD_RELOC_390_PC16DBL:
	case BFD_RELOC_390_PLT16DBL:
	  value += 2;
	  if (fixP->fx_done)
	    md_number_to_chars (where, (offsetT) value >> 1, 2);
	  break;

	case BFD_RELOC_390_PC24DBL:
	case BFD_RELOC_390_PLT24DBL:
	  value += 3;
	  if (fixP->fx_done)
	    {
	      unsigned int mop;
	      value >>= 1;

	      mop = bfd_getb32 ((unsigned char *) where - 1);
	      mop |= (unsigned int) (value & 0xffffff);
	      bfd_putb32 ((bfd_vma) mop, (unsigned char *) where - 1);
	    }
	  break;

	case BFD_RELOC_32:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  else
	    fixP->fx_r_type = BFD_RELOC_32;
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 4);
	  break;
	case BFD_RELOC_32_PCREL:
	case BFD_RELOC_32_BASEREL:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 4);
	  break;
	case BFD_RELOC_32_GOT_PCREL:
	case BFD_RELOC_390_PLTOFF32:
	case BFD_RELOC_390_PLT32:
	case BFD_RELOC_390_GOTPLT32:
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 4);
	  break;
	case BFD_RELOC_390_PC32DBL:
	case BFD_RELOC_390_PLT32DBL:
	case BFD_RELOC_390_GOTPCDBL:
	case BFD_RELOC_390_GOTENT:
	case BFD_RELOC_390_GOTPLTENT:
	  value += 2;
	  if (fixP->fx_done)
	    md_number_to_chars (where, (offsetT) value >> 1, 4);
	  break;

	case BFD_RELOC_32_GOTOFF:
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, sizeof (int));
	  break;

	case BFD_RELOC_390_GOTOFF64:
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 8);
	  break;

	case BFD_RELOC_390_GOT64:
	case BFD_RELOC_390_PLTOFF64:
	case BFD_RELOC_390_PLT64:
	case BFD_RELOC_390_GOTPLT64:
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 8);
	  break;

	case BFD_RELOC_64:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  else
	    fixP->fx_r_type = BFD_RELOC_64;
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 8);
	  break;

	case BFD_RELOC_64_PCREL:
	  fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  if (fixP->fx_done)
	    md_number_to_chars (where, value, 8);
	  break;

	case BFD_RELOC_VTABLE_INHERIT:
	case BFD_RELOC_VTABLE_ENTRY:
	  fixP->fx_done = 0;
	  return;

	case BFD_RELOC_390_TLS_LOAD:
	case BFD_RELOC_390_TLS_GDCALL:
	case BFD_RELOC_390_TLS_LDCALL:
	case BFD_RELOC_390_TLS_GD32:
	case BFD_RELOC_390_TLS_GD64:
	case BFD_RELOC_390_TLS_GOTIE12:
	case BFD_RELOC_390_TLS_GOTIE20:
	case BFD_RELOC_390_TLS_GOTIE32:
	case BFD_RELOC_390_TLS_GOTIE64:
	case BFD_RELOC_390_TLS_LDM32:
	case BFD_RELOC_390_TLS_LDM64:
	case BFD_RELOC_390_TLS_IE32:
	case BFD_RELOC_390_TLS_IE64:
	case BFD_RELOC_390_TLS_LE32:
	case BFD_RELOC_390_TLS_LE64:
	case BFD_RELOC_390_TLS_LDO32:
	case BFD_RELOC_390_TLS_LDO64:
	case BFD_RELOC_390_TLS_DTPMOD:
	case BFD_RELOC_390_TLS_DTPOFF:
	case BFD_RELOC_390_TLS_TPOFF:
	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
	  /* Fully resolved at link time.  */
	  break;
	case BFD_RELOC_390_TLS_IEENT:
	  /* Fully resolved at link time.  */
	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
	  value += 2;
	  break;

	default:
	  {
	    const char *reloc_name = bfd_get_reloc_code_name (fixP->fx_r_type);

	    if (reloc_name != NULL)
	      as_fatal (_("Gas failure, reloc type %s\n"), reloc_name);
	    else
	      as_fatal (_("Gas failure, reloc type #%i\n"), fixP->fx_r_type);
	  }
	}

      fixP->fx_offset = value;
    }
}

/* Generate a reloc for a fixup.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  bfd_reloc_code_real_type code;
  arelent *reloc;

  code = fixp->fx_r_type;
  if (GOT_symbol && fixp->fx_addsy == GOT_symbol)
    {
      if (   (s390_arch_size == 32 && code == BFD_RELOC_32_PCREL)
	  || (s390_arch_size == 64 && code == BFD_RELOC_64_PCREL))
	code = BFD_RELOC_390_GOTPC;
      if (code == BFD_RELOC_390_PC32DBL)
	code = BFD_RELOC_390_GOTPCDBL;
    }

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (code));
      /* Set howto to a garbage value so that we can keep going.  */
      reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      gas_assert (reloc->howto != NULL);
    }
  reloc->addend = fixp->fx_offset;

  return reloc;
}

void
s390_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (15, s390_arch_size == 64 ? 160 : 96);
}

int
tc_s390_regname_to_dw2regnum (char *regname)
{
  int regnum = -1;

  if (regname[0] != 'c' && regname[0] != 'a')
    {
      regnum = reg_name_search (pre_defined_registers, REG_NAME_CNT, regname);
      if (regname[0] == 'f' && regnum != -1)
        regnum += 16;
    }
  else if (strcmp (regname, "ap") == 0)
    regnum = 32;
  else if (strcmp (regname, "cc") == 0)
    regnum = 33;
  return regnum;
}

void
s390_elf_final_processing (void)
{
  if (set_highgprs_p)
    elf_elfheader (stdoutput)->e_flags |= EF_S390_HIGH_GPRS;
}
@


1.73
log
@2013-07-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>
opcodes/
	    * s390-opc.c (J12_12, J24_24): New macros.
	    (INSTR_MII_UPI): Rename to INSTR_MII_UPP.
	    (MASK_MII_UPI): Rename to MASK_MII_UPP.
	    * s390-opc.txt: Rename MII_UPI to MII_UPP for bprp instruction.

include/elf/
	    * s390.h: Add new relocs R_390_PC12DBL, R_390_PLT12DBL,
	    R_390_PC24DBL, and R_390_PLT24DBL.

gas/testsuite/
	    * gas/s390/zarch-zEC12.s: Change bprp second operand and add
	    variants requiring relocations.
	    * gas/s390/zarch-zEC12.d: Likewise.

gas/
	    * config/tc-s390.c (md_gather_operands, md_apply_fix): Support new
	    relocs.
bfd/
	    * elf32-s390.c: Add new relocation definitions R_390_PC12DBL,
	    R_390_PLT12DBL, R_390_PC24DBL, and R_390_PLT24DBL.
	    (elf_s390_reloc_type_lookup, elf_s390_check_relocs)
	    (elf_s390_gc_sweep_hook, elf_s390_relocate_section): Support new
	    relocations.
	    * elf64-s390.c: See elf32-s390.c
	    * bfd-in2.h: Add new relocs to enum bfd_reloc_code_real.
	    * libbfd.h: Add new reloc strings.
@
text
@a1849 4
      char *p;

      for (p = cpu_string; *p != 0; p++)
	*p = TOLOWER (*p);
@


1.72
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d1319 4
a1322 1
		  && (operand->bits == 16))
d1325 3
d1563 1
a1563 1
	  size = bfd_get_reloc_size (reloc_howto);
d2043 1
d2045 1
d2111 1
d2113 1
d2205 8
d2225 8
d2271 5
d2280 3
d2330 14
@


1.71
log
@2012-10-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (s390_parse_cpu): Add new option zEC12.
	* doc/as.texinfo: Document new option zEC12.
	* doc/c-s390.texi: Likewise.

2012-10-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* gas/s390/s390.exp: Run zEC12 tests.
	* gas/s390/zarch-zEC12.d: New file.
	* gas/s390/zarch-zEC12.s: New file.

2012-10-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390-mkopc.c: Support new option zEC12.
	* s390-opc.c: Add new instruction formats.
	* s390-opc.txt: Add new instructions for zEC12.

2012-10-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390.h (s390_opcode_cpu_val): Add S390_OPCODE_ZEC12.
@
text
@d2114 1
a2114 1
      break;;
@


1.70
log
@2012-09-06  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (set_highgprs_p): New variable.
	(s390_machinemode): New function.
	(md_pseudo_table): Add new pseudo command machinemode.
	(md_parse_option): Set set_highgprs_p to TRUE if -mzarch was
	specified on command line.
	(s390_elf_final_processing): Set the highgprs flag in the ELF
	header depending on set_highgprs_p.

	* doc/c-s390.texi: Document new pseudo machinemode.
@
text
@d384 2
@


1.69
log
@	* config/tc-s390.c (md_begin): Remove unused variable dup_insn.
@
text
@d47 4
d93 1
d97 1
a97 1
  { "align", s_align_bytes, 0 },
d99 2
a100 2
  { "bss",      s390_bss,       0 },
  { "insn",     s390_insn,      0 },
d102 9
a110 8
  { "byte",	s390_byte,	0 },
  { "short",    s390_elf_cons,  2 },
  { "long",	s390_elf_cons,	4 },
  { "quad",     s390_elf_cons,  8 },
  { "ltorg",    s390_literals,  0 },
  { "string",   stringer,       8 + 1 },
  { "machine",  s390_machine,   0 },
  { NULL,	NULL,		0 }
d418 5
a422 1
	current_mode_mask = 1 << S390_OPCODE_ZARCH;
d1812 1
a1812 1
   with .machine push and restored with .machined pop.  */
d1876 77
d2471 1
a2471 1
  if (s390_arch_size == 32 && (current_mode_mask & (1 << S390_OPCODE_ZARCH)))
@


1.68
log
@2011-05-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	    * config/tc-s390.c (md_gather_operands): Fix check for floating
	    register pair operands.

2011-05-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	    * opcode/s390.h: Replace S390_OPERAND_REG_EVEN with
	    S390_OPERAND_REG_PAIR.

2011-05-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	    * s390-opc.c: Replace S390_OPERAND_REG_EVEN with
	    S390_OPERAND_REG_PAIR.  Fix INSTR_RRF_0UFEF instruction type.
	    * s390-opc.txt: Fix cxr instruction type.

2011-05-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	    * gas/s390/esa-g5.d: Fix fp register pair operands.
	    * gas/s390/esa-g5.s: Likewise.
	    * gas/s390/zarch-z196.d: Likewise.
	    * gas/s390/zarch-z196.s: Likewise.
	    * gas/s390/zarch-z9-109.d: Likewise.
	    * gas/s390/zarch-z9-109.s: Likewise.
	    * gas/s390/zarch-z9-ec.d: Likewise.
	    * gas/s390/zarch-z9-ec.s: Likewise.
@
text
@a529 1
  bfd_boolean dup_insn = FALSE;
d550 2
a551 5
	{
	  as_bad (_("Internal assembler error for instruction format %s"),
		  op->name);
	  dup_insn = TRUE;
	}
@


1.67
log
@2011-05-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (md_gather_operands): Emit an error for odd
	numbered registers used as register pair operand.

2011-05-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* opcode/s390.h: Add S390_OPCODE_REG_EVEN flag.

2011-05-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390-opc.c: Add new instruction types marking register pair
	operands.
	* s390-opc.txt: Match instructions having register pair operands
	to the new instruction types.

2011-05-24  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* gas/s390/esa-g5.d: Fix register pair operands.
	* gas/s390/esa-g5.s: Likewise.
	* gas/s390/esa-z9-109.d: Likewise.
	* gas/s390/esa-z9-109.s: Likewise.
	* gas/s390/zarch-z196.d: Likewise.
	* gas/s390/zarch-z196.s: Likewise.
	* gas/s390/zarch-z9-109.d: Likewise.
	* gas/s390/zarch-z9-109.s: Likewise.
	* gas/s390/zarch-z900.d: Likewise.
	* gas/s390/zarch-z900.s: Likewise.
	* gas/s390/zarch-z990.d: Likewise.
	* gas/s390/zarch-z990.s: Likewise.
@
text
@d1270 2
a1271 1
	      if ((operand->flags & S390_OPERAND_REG_EVEN)
d1273 11
a1283 1
		as_fatal (_("odd numbered register specified as register pair"));
@


1.66
log
@2011-04-14  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (s390_machine): New prototype.
	(md_pseudo_table): New pseudo-op .machine.
	(s390_opcode_hash): Initialize to NULL.
	(s390_parse_cpu): New function.
	(md_parse_option): Use s390_parse_cpu.
	(s390_setup_opcodes): New function.
	(md_begin): Use s390_setup_opcodes.
	(s390_machine): New hook handling the new .machine pseudo.

	* doc/c-s390.texi: Document the new pseudo op .machine.

2011-04-14  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* gas/s390/zarch-machine.s: New testcase.
	* gas/s390/zarch-machine.d: New testcase output.
	* gas/s390/s390.exp: Execute the new testcase.
@
text
@d1270 3
@


1.65
log
@2011-03-18  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (md_parse_option): Add -march=all option which
	switches to the highest available CPU.
@
text
@d88 1
d103 1
d298 1
a298 1
static struct hash_control *s390_opcode_hash;
d355 29
d416 3
a418 19
	  if (strcmp (arg + 5, "g5") == 0)
	    current_cpu = S390_OPCODE_G5;
	  else if (strcmp (arg + 5, "g6") == 0)
	    current_cpu = S390_OPCODE_G6;
	  else if (strcmp (arg + 5, "z900") == 0)
	    current_cpu = S390_OPCODE_Z900;
	  else if (strcmp (arg + 5, "z990") == 0)
	    current_cpu = S390_OPCODE_Z990;
	  else if (strcmp (arg + 5, "z9-109") == 0)
	    current_cpu = S390_OPCODE_Z9_109;
	  else if (strcmp (arg + 5, "z9-ec") == 0)
	    current_cpu = S390_OPCODE_Z9_EC;
	  else if (strcmp (arg + 5, "z10") == 0)
	    current_cpu = S390_OPCODE_Z10;
	  else if (strcmp (arg + 5, "z196") == 0)
	    current_cpu = S390_OPCODE_Z196;
	  else if (strcmp (arg + 5, "all") == 0)
	    current_cpu = S390_OPCODE_MAXCPU - 1;
	  else
d474 3
a476 3
/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */
d478 2
a479 2
void
md_begin (void)
d486 2
a487 24
  /* Give a warning if the combination -m64-bit and -Aesa is used.  */
  if (s390_arch_size == 64 && current_cpu < S390_OPCODE_Z900)
    as_warn (_("The 64 bit file format is used without esame instructions."));

  s390_cie_data_alignment = -s390_arch_size / 8;

  /* Set the ELF flags if desired.  */
  if (s390_flags)
    bfd_set_private_flags (stdoutput, s390_flags);

  /* Insert the opcode formats into a hash table.  */
  s390_opformat_hash = hash_new ();

  op_end = s390_opformats + s390_num_opformats;
  for (op = s390_opformats; op < op_end; op++)
    {
      retval = hash_insert (s390_opformat_hash, op->name, (void *) op);
      if (retval != (const char *) NULL)
	{
	  as_bad (_("Internal assembler error for instruction format %s"),
		  op->name);
	  dup_insn = TRUE;
	}
    }
d519 40
a562 1

d1790 66
@


1.64
log
@2010-11-25  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (current_cpu): Initialize with latest CPU.
	(init_default_arch): Default to z/Architecture mode if CPU provides it.
	Remove the check setting the CPU default.

2010-11-25  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* opcode/s390.h (enum s390_opcode_cpu_val): Add S390_OPCODE_MAXCPU.
@
text
@d401 2
@


1.63
log
@2010-10-28  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (md_begin): Only add to hash table if cpu and
	mode mask fit.

2010-10-28  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390-opc.txt: cfxr, cfdr and cfer z900 -> g5.
@
text
@d41 4
a45 1
static unsigned int current_cpu = -1U;
d334 2
a335 1
      if (s390_arch_size == 32)
a339 7
  if (current_cpu == -1U)
    {
      if (current_mode_mask == (1 << S390_OPCODE_ESA))
	current_cpu = S390_OPCODE_G5;
      else
	current_cpu = S390_OPCODE_Z900;
    }
@


1.63.2.1
log
@Backport of:
Changes by:	krebbel@@sourceware.org	2010-11-25 09:33:54

Modified files:
	include        : ChangeLog
	gas            : ChangeLog
	gas/config     : tc-s390.c
	include/opcode : s390.h

Log message:
	2010-11-25  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (current_cpu): Initialize with latest CPU.
	(init_default_arch): Default to z/Architecture mode if CPU provides it.
	Remove the check setting the CPU default.

	2010-11-25  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* opcode/s390.h (enum s390_opcode_cpu_val): Add S390_OPCODE_MAXCPU.
@
text
@a40 4
/* If no -march option was given default to the highest available CPU.
   Since with S/390 a newer CPU always supports everything from its
   predecessors this will accept every valid asm input.  */
static unsigned int current_cpu = S390_OPCODE_MAXCPU - 1;
d42 1
d331 1
a331 2
      /* Default to z/Architecture mode if the CPU supports it.  */
      if (current_cpu < S390_OPCODE_Z900)
d336 7
@


1.63.2.2
log
@2011-05-18  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	Backported from mainline
	2011-03-18  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (md_parse_option): Add -march=all option which
	switches to the highest available CPU.

	2011-04-14  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (s390_machine): New prototype.
	(md_pseudo_table): New pseudo-op .machine.
	(s390_opcode_hash): Initialize to NULL.
	(s390_parse_cpu): New function.
	(md_parse_option): Use s390_parse_cpu.
	(s390_setup_opcodes): New function.
	(md_begin): Use s390_setup_opcodes.
	(s390_machine): New hook handling the new .machine pseudo.

	* doc/c-s390.texi: Document the new pseudo op .machine.

2011-05-18  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	Backported from mainline
	2011-04-14  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* gas/s390/zarch-machine.s: New testcase.
	* gas/s390/zarch-machine.d: New testcase output.
	* gas/s390/s390.exp: Execute the new testcase.
@
text
@a87 1
static void s390_machine (int);
a101 1
  { "machine",  s390_machine,   0 },
d296 1
a296 1
static struct hash_control *s390_opcode_hash = NULL;
a352 29
/* Map a CPU string as given with -march= or .machine to the
   respective enum s390_opcode_cpu_val value.  0xffffffff is returned
   in case of an error.  */

static unsigned int
s390_parse_cpu (char *arg)
{
  if (strcmp (arg, "g5") == 0)
    return S390_OPCODE_G5;
  else if (strcmp (arg, "g6") == 0)
    return S390_OPCODE_G6;
  else if (strcmp (arg, "z900") == 0)
    return S390_OPCODE_Z900;
  else if (strcmp (arg, "z990") == 0)
    return S390_OPCODE_Z990;
  else if (strcmp (arg, "z9-109") == 0)
    return S390_OPCODE_Z9_109;
  else if (strcmp (arg, "z9-ec") == 0)
    return S390_OPCODE_Z9_EC;
  else if (strcmp (arg, "z10") == 0)
    return S390_OPCODE_Z10;
  else if (strcmp (arg, "z196") == 0)
    return S390_OPCODE_Z196;
  else if (strcmp (arg, "all") == 0)
    return S390_OPCODE_MAXCPU - 1;
  else
    return -1;
}

d385 17
a401 3
	  current_cpu = s390_parse_cpu (arg + 5);

	  if (current_cpu == (unsigned int)-1)
d457 3
a459 3
/* Generate the hash table mapping mnemonics to struct s390_opcode.
   This table is built at startup and whenever the CPU level is
   changed using .machine.  */
d461 2
a462 2
static void
s390_setup_opcodes (void)
d469 24
a492 2
  if (s390_opcode_hash != NULL)
    hash_die (s390_opcode_hash);
a523 40
}

/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */

void
md_begin (void)
{
  register const struct s390_opcode *op;
  const struct s390_opcode *op_end;
  bfd_boolean dup_insn = FALSE;
  const char *retval;

  /* Give a warning if the combination -m64-bit and -Aesa is used.  */
  if (s390_arch_size == 64 && current_cpu < S390_OPCODE_Z900)
    as_warn (_("The 64 bit file format is used without esame instructions."));

  s390_cie_data_alignment = -s390_arch_size / 8;

  /* Set the ELF flags if desired.  */
  if (s390_flags)
    bfd_set_private_flags (stdoutput, s390_flags);

  /* Insert the opcode formats into a hash table.  */
  s390_opformat_hash = hash_new ();

  op_end = s390_opformats + s390_num_opformats;
  for (op = s390_opformats; op < op_end; op++)
    {
      retval = hash_insert (s390_opformat_hash, op->name, (void *) op);
      if (retval != (const char *) NULL)
	{
	  as_bad (_("Internal assembler error for instruction format %s"),
		  op->name);
	  dup_insn = TRUE;
	}
    }

  s390_setup_opcodes ();
d528 1
a1755 66
/* The .machine pseudo op allows to switch to a different CPU level in
   the asm listing.  The current CPU setting can be stored on a stack
   with .machine push and restored with .machined pop.  */

static void
s390_machine (int ignore ATTRIBUTE_UNUSED)
{
  char *cpu_string;
#define MAX_HISTORY 100
  static unsigned int *cpu_history;
  static int curr_hist;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      int len;
      cpu_string = demand_copy_C_string (&len);
    }
  else
    {
      char c;
      cpu_string = input_line_pointer;
      c = get_symbol_end ();
      cpu_string = xstrdup (cpu_string);
      *input_line_pointer = c;
    }

  if (cpu_string != NULL)
    {
      unsigned int old_cpu = current_cpu;
      unsigned int new_cpu;
      char *p;

      for (p = cpu_string; *p != 0; p++)
	*p = TOLOWER (*p);

      if (strcmp (cpu_string, "push") == 0)
	{
	  if (cpu_history == NULL)
	    cpu_history = xmalloc (MAX_HISTORY * sizeof (*cpu_history));

	  if (curr_hist >= MAX_HISTORY)
	    as_bad (_(".machine stack overflow"));
	  else
	    cpu_history[curr_hist++] = current_cpu;
	}
      else if (strcmp (cpu_string, "pop") == 0)
	{
	  if (curr_hist <= 0)
	    as_bad (_(".machine stack underflow"));
	  else
	    current_cpu = cpu_history[--curr_hist];
	}
      else if ((new_cpu = s390_parse_cpu (cpu_string)) != (unsigned int)-1)
	current_cpu = new_cpu;
      else
	as_bad (_("invalid machine `%s'"), cpu_string);

      if (current_cpu != old_cpu)
	s390_setup_opcodes ();
    }

  demand_empty_rest_of_line ();
}

@


1.62
log
@2010-09-27  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390-mkopc.c (enum s390_opcde_cpu_val): Add S390_OPCODE_Z196.
	(main): Recognize the new CPU string.
	* s390-opc.c: Add new instruction formats and masks.
	* s390-opc.txt: Add new z196 instructions.

2010-09-27  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* opcode/s390.h: Add S390_OPCODE_Z196 to enum s390_opcode_cpu_val.

2010-09-27  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c: (md_parse_option): New option -march=z196.
	* doc/c-s390.texi: Document new option.

2010-09-27  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* gas/s390/s390.exp: Run the zarch-z196 test.
	* gas/s390/zarch-z196.d: Add new instructions.
	* gas/s390/zarch-z196.s: Likewise.
	* gas/s390/zarch-z9-109.d: Likewise.
	* gas/s390/zarch-z9-109.s: Likewise.
@
text
@d509 10
a518 6
      retval = hash_insert (s390_opcode_hash, op->name, (void *) op);
      if (retval != (const char *) NULL)
        {
          as_bad (_("Internal assembler error for instruction %s"),
		  op->name);
	  dup_insn = TRUE;
d520 1
@


1.61
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d402 2
@


1.60
log
@2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* readelf.c (get_machine_flags): Handle EF_S390_HIGH_GPRS.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390.h (EF_S390_HIGH_GPRS): Added macro definition.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (s390_elf_final_processing): New function.
	* config/tc-s390.h (elf_tc_final_processing): New macro definition.
	(s390_elf_final_processing): Added prototype.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (elf32_s390_merge_private_bfd_data): New function.
	(bfd_elf32_bfd_merge_private_bfd_data): New macro definition.
@
text
@d3 1
a3 1
   2009  Free Software Foundation, Inc.
a1147 1
  int parentheses;
a1153 1
  parentheses = 0;
@


1.59
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d2268 7
@


1.58
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d2 2
a3 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
d327 1
a327 1
    as_fatal ("Invalid default architecture, broken assembler.");
d423 1
a423 1
	as_bad ("invalid architecture -A%s", arg);
d472 1
a472 1
    as_warn ("The 64 bit file format is used without esame instructions.");
d562 1
a562 1
	    "operand out of range (%s not between %ld and %ld)";
d1229 1
a1229 1
		as_warn ("index register specified but zero");
d1233 1
a1233 1
		as_warn ("base register specified but zero");
d1549 1
a1549 1
      as_bad ("Opcode %s not available in this mode", str);
d1938 1
a1938 1
		  "cannot emit relocation %s against subsy symbol %s",
d2073 1
a2073 1
			  "cannot emit PC relative %s relocation%s%s",
d2198 1
a2198 1
	      fprintf (stderr, "Gas failure, reloc type %s\n", reloc_name);
d2200 1
a2200 3
	      fprintf (stderr, "Gas failure, reloc type #%i\n", fixP->fx_r_type);
	    fflush (stderr);
	    abort ();
@


1.57
log
@        * config/tc-s390.c (md_gather_operands): Accept an instruction
        without operands if all operands are tagged as optional.
@
text
@d2240 1
a2240 1
      assert (reloc->howto != NULL);
@


1.56
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d1191 18
a1208 1
	as_bad (_("missing operand"));
@


1.55
log
@2008-03-19  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* opcodes/s390-mkopc.c (s390_opcode_cpu_val): S390_OPCODE_Z10 added.
	(s390_cond_extensions): Reduced extensions to the compare related.
	(main): z10 cpu type option added.
	(expandConditionalJump): Renamed to ...
	(insertExpandedMnemonic): ... this.

	* opcodes/s390-opc.c: Re-group the operand format makros.
	(INSTR_RIE_RRPU, INSTR_RIE_RRP0, INSTR_RIE_RUPI,
	INSTR_RIE_R0PI, INSTR_RIE_RUPU, INSTR_RIE_R0PU, INSTR_RIE_R0IU,
	INSTR_RIE_R0I0, INSTR_RIE_R0UU, INSTR_RIE_R0U0,
	INSTR_RIE_RRUUU, INSTR_RIS_RURDI, INSTR_RIS_R0RDI, INSTR_RIS_RURDU,
	INSTR_RIS_R0RDU, INSTR_RRF_U0RR, INSTR_RRF_00RR, INSTR_RRS_RRRDU,
	INSTR_RRS_RRRD0, INSTR_RXY_URRD, INSTR_SIY_IRD, INSTR_SIL_RDI,
	INSTR_SIL_RDU): New instruction formats added.
	(MASK_RIE_RRPU, MASK_RIE_RRP0, MASK_RIE_RUPI, MASK_RIE_R0PI,
	MASK_RIE_RUPU, MASK_RIE_R0PU, MASK_RIE_R0IU, MASK_RIE_R0I0,
	MASK_RIE_R0UU, MASK_RIE_R0U0, MASK_RIE_RRUUU, MASK_RIS_RURDI,
	MASK_RIS_R0RDI, MASK_RIS_RURDU, MASK_RIS_R0RDU, MASK_RRF_U0RR,
	MASK_RRF_00RR, MASK_RRS_RRRDU, MASK_RRS_RRRD0, MASK_RXY_URRD,
	MASK_SIY_IRD, MASK_SIL_RDI, MASK_SIL_RDU): New instruction format
	masks added.
	(s390_opformats): New formats added "ris", "rrs", "sil".
	* opcodes/s390-opc.txt: Add the conditional jumps with the
	extensions removed from automatic expansion in s390-mkopc.c manually.
	(asi - trtre): Add new System z10 EC instructions.
	* include/opcode/s390.h (s390_opcode_cpu_val): S390_OPCODE_Z10 added.

2008-03-19  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* config/tc-s390.c (md_parse_option): z10 option added.

2008-03-19  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* gas/s390/zarch-z10.d: New file.
	* gas/s390/zarch-z10.s: New file.
	* gas/s390/s390.exp: Run the z10 testcases.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d80 5
a84 5
static void s390_byte PARAMS ((int));
static void s390_elf_cons PARAMS ((int));
static void s390_bss PARAMS ((int));
static void s390_insn PARAMS ((int));
static void s390_literals PARAMS ((int));
a207 10
static int reg_name_search
  PARAMS ((const struct pd_reg *, int, const char *));
static bfd_boolean register_name PARAMS ((expressionS *));
static void init_default_arch PARAMS ((void));
static void s390_insert_operand
  PARAMS ((unsigned char *, const struct s390_operand *, offsetT, char *,
	   unsigned int));
static char *md_gather_operands
  PARAMS ((char *, unsigned char *, const struct s390_opcode *));

d212 1
a212 4
reg_name_search (regs, regcount, name)
     const struct pd_reg *regs;
     int regcount;
     const char *name;
d250 1
a250 2
register_name (expressionP)
     expressionS *expressionP;
d314 1
a314 1
init_default_arch ()
d347 1
a347 1
s390_target_format ()
d357 1
a357 3
md_parse_option (c, arg)
     int c;
     char *arg;
d444 1
a444 2
md_show_usage (stream)
     FILE *stream;
d463 1
a463 1
md_begin ()
d486 1
a486 1
      retval = hash_insert (s390_opformat_hash, op->name, (PTR) op);
d507 1
a507 1
      retval = hash_insert (s390_opcode_hash, op->name, (PTR) op);
d529 1
a529 1
s390_md_end ()
d540 5
a544 6
s390_insert_operand (insn, operand, val, file, line)
     unsigned char *insn;
     const struct s390_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
a627 3
static bfd_reloc_code_real_type s390_tls_suffix
  PARAMS ((char **, expressionS *));

d630 1
a630 3
s390_tls_suffix (str_p, exp_p)
     char **str_p;
     expressionS *exp_p;
a702 5
static elf_suffix_type s390_elf_suffix PARAMS ((char **, expressionS *));
static int s390_exp_compare PARAMS ((expressionS *exp1, expressionS *exp2));
static elf_suffix_type s390_lit_suffix
  PARAMS ((char **, expressionS *, elf_suffix_type));

d706 1
a706 3
s390_elf_suffix (str_p, exp_p)
     char **str_p;
     expressionS *exp_p;
d813 1
a813 3
s390_exp_compare (exp1, exp2)
     expressionS *exp1;
     expressionS *exp2;
d865 1
a865 4
s390_lit_suffix (str_p, exp_p, suffix)
     char **str_p;
     expressionS *exp_p;
     elf_suffix_type suffix;
d1008 1
a1008 2
s390_elf_cons (nbytes)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
d1137 3
a1139 4
md_gather_operands (str, insn, opcode)
     char *str;
     unsigned char *insn;
     const struct s390_opcode *opcode;
d1511 1
a1511 2
md_assemble (str)
     char *str;
d1563 1
a1563 2
s390_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1575 1
a1575 2
s390_insn (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1644 1
a1644 2
s390_byte (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1679 1
a1679 2
s390_literals (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1746 1
a1746 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d1756 2
a1757 3
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d1766 3
a1768 4
md_convert_frag (abfd, sec, fragp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragp ATTRIBUTE_UNUSED;
d1774 1
a1774 2
md_undefined_symbol (name)
     char *name;
d1797 1
a1797 3
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec ATTRIBUTE_UNUSED;
d1807 1
a1807 2
tc_s390_fix_adjustable (fixP)
     fixS *fixP;
d1865 1
a1865 2
tc_s390_force_relocation (fixp)
     struct fix *fixp;
d1912 1
a1912 4
md_apply_fix (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d2196 1
a2196 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d2231 1
a2231 1
s390_cfi_frame_initial_instructions ()
@


1.54
log
@2007-11-29  Martin Schwidefsky  <schwidefsky@@de.ibm.com>

	* config/tc-s390.c (md_begin): If the -mesa option is specified
	add zarch opcodes to the hash table only if there is no variant
	that is available for the esa mode as well.

2007-11-29  Martin Schwidefsky  <schwidefsky@@de.ibm.com>

	* gas/s390/esa-z9-109.d: Add check for old version of sske.
	* gas/s390/esa-z9-109.s: Likewise.
@
text
@d416 2
@


1.53
log
@Remove duplicate definitions of the md_atof() function
@
text
@d515 5
a519 10
    if (op->min_cpu <= current_cpu)
      {
	retval = hash_insert (s390_opcode_hash, op->name, (PTR) op);
	if (retval != (const char *) NULL)
	  {
	    as_bad (_("Internal assembler error for instruction %s"),
		    op->name);
	    dup_insn = TRUE;
	  }
	while (op < op_end - 1 && strcmp (op->name, op[1].name) == 0)
d521 10
@


1.52
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@a1771 5
/* Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *litp.  The number
   of LITTLENUMS emitted is stored in *sizep .  An error message is
   returned, or NULL on OK.  */

d1773 3
a1775 38
md_atof (type, litp, sizep)
     int type;
     char *litp;
     int *sizep;
{
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return "bad call to md_atof";
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = 0; i < prec; i++)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
@


1.51
log
@Switch to GPLv3
@
text
@d98 1
a98 1
  { "string",   stringer,       2 },
@


1.50
log
@2007-03-06  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* opcodes/s390-opc.c (INSTR_RRE_FR, INSTR_RRF_F0FF2, INSTR_RRF_F0FR,
	INSTR_RRF_UUFF, INSTR_RRF_0UFF, INSTR_RRF_FFFU,	INSTR_RRR_F0FF): New
	instruction formats added.
	(MASK_RRE_FR, MASK_RRF_F0FF2, MASK_RRF_F0FR, MASK_RRF_UUFF,
	MASK_RRF_0UFF, MASK_RRF_FFFU, MASK_RRR_F0FF): New instruction format
	masks added.
	* opcodes/s390-opc.txt (lpdfr - tgxt): Decimal floating point
	instructions added.
	* opcodes/s390-mkopc.c (s390_opcode_cpu_val): S390_OPCODE_Z9_EC added.
	(main): z9-ec cpu type option added.
	* include/opcode/s390.h (s390_opcode_cpu_val): S390_OPCODE_Z9_EC added.

2007-03-06  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* config/tc-s390.c (md_parse_option): z9-ec option added.

2007-03-06  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* gas/s390/zarch-z9-ec.d: New file.
	* gas/s390/zarch-z9-ec.s: New file.
	* gas/s390/s390.exp: Run the z9-ec testcases.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.49
log
@remove some duplicate #include's.
@
text
@d414 2
@


1.48
log
@	* config/tc-arm.c, config/tc-arm.h (tc_arm_regname_to_dw2regnum):
	Un-constify string argument.
	* config/tc-i386.c, config/tc-i386.h (tc_x86_regname_to_dw2regnum):
	Likewise.
	* config/tc-m68k.c, config/tc-m68k.h (tc_m68k_regname_to_dw2regnum):
	Likewise.
	* config/tc-ppc.c, config/tc-ppc.h (tc_ppc_regname_to_dw2regnum):
	Likewise.
	* config/tc-s390.c, config/tc-s390.h (tc_s390_regname_to_dw2regnum):
	Likewise.
	* config/tc-sh.c, config/tc-sh.h (sh_regname_to_dw2regnum):
	Likewise.
	* config/tc-sparc.c, config/tc-sparc.h (sparc_regname_to_dw2regnum):
	Likewise.
-------------------------------------------------------------------
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005
a22 1
#include <stdio.h>
@


1.47
log
@	* config/tc-s390.c (md_parse_option):  Add cpu type z9-109.
	(md_gather_operands): Add support for optional operands.
@
text
@d2325 1
a2325 1
tc_s390_regname_to_dw2regnum (const char *regname)
@


1.46
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d413 2
d1358 13
a1370 2
		  if (*str++ != ',')
		    as_bad (_("syntax error; expected ,"));
d1402 13
a1414 2
	      if (*str++ != ',')
		as_bad (_("syntax error; expected ,"));
d1432 13
a1444 2
	      if (*str++ != ',')
		as_bad (_("syntax error; expected ,"));
@


1.45
log
@Update the address and phone number of the FSF
@
text
@d1452 1
a1452 1
     md_apply_fix3.  */
d1960 1
a1960 1
md_apply_fix3 (fixP, valP, seg)
@


1.44
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.43
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d1605 1
a1605 1
	md_number_to_chars (insn, exp.X_add_number, opformat->oplen);
d1615 3
a1617 3
	  md_number_to_chars (insn, generic_bignum[2], 2);
	  md_number_to_chars (&insn[2], generic_bignum[1], 2);
	  md_number_to_chars (&insn[4], generic_bignum[0], 2);
d1995 2
a1996 2
	  s390_insert_operand (where, operand, (offsetT) value,
			       fixP->fx_file, fixP->fx_line);
@


1.42
log
@	* symbols.c (colon) [!WORKING_DOT_WORD]: Don't declare
	md_short_jump_size, md_long_jump_size.
	* write.c [!WORKING_DOT_WORD]: Ditto.
	* tc.h [!WORKING_DOT_WORD]: Declare them here.  Drop const
	qualifier.
	* config/tc-cris.h (md_short_jump_size, md_long_jump_size): Don't
	declare.
	* config/tc-cris.c (md_short_jump_size, md_long_jump_size): Drop
	const qualifier in these definitions.
	* config/tc-i370.c, config/tc-m68k.c, config/tc-pdp11.c,
	config/tc-s390.c, config/tc-tahoe.c, config/tc-vax.c: Ditto.
@
text
@d2 2
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a1599 1
	      && (addressT) exp.X_add_number >= 0
a1601 1
	      && (addressT) exp.X_add_number >= 0
a1603 1
	      && (addressT) exp.X_add_number >= 0
@


1.41
log
@2004-10-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ppc.c (md_apply_fix3): Call S_SET_THREAD_LOCAL for
	TLS relocations.
	* config/tc-s390.c (md_apply_fix3): Likewise.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
@
text
@d315 2
a316 2
const int md_short_jump_size = 4;
const int md_long_jump_size = 4;
@


1.40
log
@	* config/tc-s390.c (s390_insn): Avoid incorrect signed/unsigned
	comparison in .insn pseudo operation.
@
text
@d2220 1
d2225 1
@


1.39
log
@Remove duplicate code and provide a function for generating internally consistent 'value out of range' messages
@
text
@d1599 1
a1599 1
	      && exp.X_add_number >= 0
d1602 1
a1602 1
	      && exp.X_add_number >= 0
d1605 1
a1605 1
	      && exp.X_add_number >= 0
@


1.38
log
@	* tc-s390.h (md_do_align, HANDLE_ALIGN): Remove.
	(NOP_OPCODE): Define.
	(s390_align_code): Remove prototype.
	* tc-s390.c (s390_align_code): Remove.
@
text
@a603 4
	  const char *err =
	    "operand out of range (%s not between %ld and %ld)";
	  char buf[100];

d610 3
a612 5
	  sprint_value (buf, uval);
	  if (file == (char *) NULL)
	    as_bad (err, buf, (int) min, (int) max);
	  else
	    as_bad_where (file, line, err, buf, (int) min, (int) max);
@


1.37
log
@	* config/tc-s390.c (s390_insn): Correct range check for opcode in
	.insn pseudo operation.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a540 13
}

void
s390_align_code (fragP, count)
     fragS *fragP;
     int count;
{
  /* We use nop pattern 0x0707.  */
  if (count > 0)
    {
      memset (fragP->fr_literal + fragP->fr_fix, 0x07, count);
      fragP->fr_var = count;
    }
@


1.36
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d1617 9
a1625 3
      if (   (opformat->oplen == 6 && exp.X_op > 0 && exp.X_op < (1ULL << 48))
	  || (opformat->oplen == 4 && exp.X_op > 0 && exp.X_op < (1ULL << 32))
	  || (opformat->oplen == 2 && exp.X_op > 0 && exp.X_op < (1ULL << 16)))
@


1.36.6.1
log
@Merge to 2.15 branch.
@
text
@d1617 3
a1619 9
      if (   (   opformat->oplen == 6
	      && exp.X_add_number >= 0
	      && (addressT) exp.X_add_number < (1ULL << 48))
	  || (   opformat->oplen == 4
	      && exp.X_add_number >= 0
	      && (addressT) exp.X_add_number < (1ULL << 32))
	  || (   opformat->oplen == 2
	      && exp.X_add_number >= 0
	      && (addressT) exp.X_add_number < (1ULL << 16)))
@


1.36.6.2
log
@Additional merges to branch for 2.15.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d541 13
@


1.35
log
@	* config/tc-ppc.h (DWARF2_LINE_MIN_INSN_LENGTH): Define always.
	(TARGET_USE_CFIPOP, tc_cfi_frame_initial_instructions,
	tc_regname_to_dw2regnum, DWARF2_DEFAULT_RETURN_COLUMN,
	DWARF2_CIE_DATA_ALIGNMENT): Define.
	(ppc_cfi_frame_initial_instructions, tc_ppc_regname_to_dw2regnum): New
	prototypes.
	(ppc_cie_data_alignment): Declare.
	* config/tc-ppc.c: Include dw2gencfi.h.
	(ppc_cie_data_alignment): Define.
	(md_begin): Initialize ppc_cie_data_alignment.
	(ppc_cfi_frame_initial_instructions, tc_ppc_regname_to_dw2regnum): New
	functions.
	* config/tc-s390.h (DWARF2_LINE_MIN_INSN_LENGTH): Define always.
	(TARGET_USE_CFIPOP, tc_cfi_frame_initial_instructions,
	tc_regname_to_dw2regnum, DWARF2_DEFAULT_RETURN_COLUMN,
	DWARF2_CIE_DATA_ALIGNMENT): Define.
	(s390_cfi_frame_initial_instructions, tc_s390_regname_to_dw2regnum):
	New prototypes.
	(s390_cie_data_alignment): Declare.
	* config/tc-s390.c: Include dw2gencfi.h.
	(s390_cie_data_alignment): Define.
	(md_begin): Initialize s390_cie_data_alignment.
	(s390_cfi_frame_initial_instructions, tc_s390_regname_to_dw2regnum):
	New functions.

	* gas/cfi/cfi-ppc-1.s: New test.
	* gas/cfi/cfi-ppc-1.d: New test.
	* gas/cfi/cfi-s390-1.s: New test.
	* gas/cfi/cfi-s390-1.s: New test.
	* gas/cfi/cfi-s390x-1.s: New test.
	* gas/cfi/cfi-s390x-1.s: New test.
	* gas/cfi/cfi.exp: Run them.
@
text
@d427 1
a427 1
      /* Option -A is deprecated. Still available for compatability.  */
d1360 1
a1360 1
	      /* Check if parethesed block can be skipped. If the next
d1371 1
a1371 1
	      /* If there is a next operand it must be seperated by a comma.  */
d1404 1
a1404 1
	  /* If there is a next operand it must be seperated by a comma.  */
d1423 1
a1423 1
	  /* If there is a next operand it must be seperated by a comma.  */
@


1.34
log
@        * config/tc-s390.c (md_parse_option): Add cpu type z990.
        (md_begin): Add minimal cpu type logic for instructions with different
        binary format depending on the cpu.
        (md_assemble): Remove check for minimal cpu.
        (s390_insert_operand): Add support for long displacements.
        (md_gather_operands): Likewise.
        (tc_s390_fix_adjustable): Likewise.
        (tc_s390_force_relocation): Likewise.
        (md_apply_fix3): Likewise.
@
text
@d28 1
d74 3
d485 2
d2294 24
@


1.33
log
@	* config/tc-s390.c (init_default_arch): Make current_mode_mask
	dependent on s390_arch_size and current_cpu dependent on
	current_mode_mask.
@
text
@d406 2
d505 12
a516 8
    {
      retval = hash_insert (s390_opcode_hash, op->name, (PTR) op);
      if (retval != (const char *) NULL)
	{
	  as_bad (_("Internal assembler error for instruction %s"), op->name);
	  dup_insn = TRUE;
	}
    }
d594 3
d1267 2
a1268 1
	      if (operand->flags & S390_OPERAND_DISP)
d1270 3
d1324 3
d1501 1
a1541 6
  else if (opcode->min_cpu > current_cpu)
    {
      as_bad ("Opcode %s not available for this cpu", str);
      return;
    }

d1880 1
d1887 1
d1897 1
d1929 1
d1947 1
d2025 6
d2097 13
d2213 1
@


1.32
log
@	* config/tc-s390.c (s390_target_format): Always call init_default_arch.
@
text
@a329 4
      if (current_mode_mask == 0)
	current_mode_mask = 1 << S390_OPCODE_ESA;
      if (current_cpu == -1U)
	current_cpu = S390_OPCODE_G5;
d335 9
a343 1
      if (current_mode_mask == 0)
d345 6
a350 1
      if (current_cpu == -1U)
a352 2
  else
    as_fatal ("Invalid default architecture, broken assembler.");
@


1.31
log
@	* config/tc-s390.c (s390_arch_size): Initialize to zero.
	(current_arch_mask): Rename to current_mode_mask.
	(current_arch_requested): Remove variable.
	(current_cpu): New variable.
	(init_default_arch): Set defaults values for s390_arch_size,
	current_mode_mask and current_cpu.
	(md_parse_option): New options -mesa, -mzarch and -march={g5,g6,z900}.
	(md_begin): Replace current_arch_mask by current_cpu.
	(md_assemble): Adapt check and error message to current_mode_mask and
	current_cpu.
@
text
@d354 1
a354 2
  if (! s390_arch_size)
    init_default_arch ();
@


1.31.2.1
log
@	Merge from mainline:

	2003-05-09  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* config/tc-s390.c (s390_target_format): Always call init_default_arch.

	2003-05-06  Alexandre Oliva  <aoliva@@redhat.com>
	* configure.in (MIPS_DEFAULT_ABI): AC_DEFINE.
	* config/tc-mips.c (mips_after_parse_args): Set mips_abi to it.
	* config.in, configure: Rebuilt.
@
text
@d354 2
a355 1
  init_default_arch ();
@


1.30
log
@	* Avoid designated initializers.
@
text
@d38 4
a41 5
static int s390_arch_size;
/* Current architecture. Start with the smallest instruction set.  */
static enum s390_opcode_arch_val current_architecture = S390_OPCODE_ESA;
static int current_arch_mask = 1 << S390_OPCODE_ESA;
static int current_arch_requested = 0;
d322 1
a322 1
   architecture name.  */
a325 3
  if (current_arch_requested)
    return;

d328 6
a333 2
      s390_arch_size = 32;
      current_architecture = S390_OPCODE_ESA;
d337 6
a342 2
      s390_arch_size = 64;
      current_architecture = S390_OPCODE_ESAME;
a345 1
  current_arch_mask = 1 << current_architecture;
d386 21
d415 1
d417 1
a417 1
	current_architecture = S390_OPCODE_ESA;
d419 1
a419 1
	current_architecture = S390_OPCODE_ESAME;
a421 2
      current_arch_mask = 1 << current_architecture;
      current_arch_requested = 1;
d470 1
a470 1
  if (s390_arch_size == 64 && current_arch_mask == (1 << S390_OPCODE_ESA))
d1514 6
a1519 1
  else if (!(opcode->architecture & current_arch_mask))
d1521 1
a1521 1
      as_bad ("Opcode %s not available in this architecture", str);
@


1.29
log
@	* config/tc-s390.c (s390_tls_suffix): New function.
	(elf_suffix_type): Add suffix enums for TLS relocations.
	(s390_elf_suffix): Add suffix strings for TLS relocations.
	(s390_elf_cons): Map new lenght/elf suffix combinations for TLS to
	bfd relocations.
	(md_gather_operands): Map new instruction operand/elf suffix
	combinations for TLS to bfd relocations.
	(tc_s390_fix_adjustable): Add new TLS relocations.
	(tc_s390_force_relocation): Likewise.
	(md_apply_fix3): Likewise.
@
text
@d1036 13
a1048 13
		  [ELF_SUFFIX_NONE] BFD_RELOC_UNUSED ,
		  [ELF_SUFFIX_GOT] BFD_RELOC_390_GOT16,
		  [ELF_SUFFIX_PLT] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_GOTENT] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_GOTOFF] BFD_RELOC_16_GOTOFF,
		  [ELF_SUFFIX_GOTPLT] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_PLTOFF] BFD_RELOC_390_PLTOFF16,
		  [ELF_SUFFIX_TLS_GD] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_TLS_GOTIE] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_TLS_IE] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_TLS_LDM] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_TLS_LDO] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_TLS_LE] BFD_RELOC_UNUSED,
d1056 13
a1068 13
		  [ELF_SUFFIX_NONE] BFD_RELOC_UNUSED ,
		  [ELF_SUFFIX_GOT] BFD_RELOC_32_GOT_PCREL,
		  [ELF_SUFFIX_PLT] BFD_RELOC_390_PLT32,
		  [ELF_SUFFIX_GOTENT] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_GOTOFF] BFD_RELOC_32_GOTOFF,
		  [ELF_SUFFIX_GOTPLT] BFD_RELOC_390_GOTPLT32,
		  [ELF_SUFFIX_PLTOFF] BFD_RELOC_390_PLTOFF32,
		  [ELF_SUFFIX_TLS_GD] BFD_RELOC_390_TLS_GD32,
		  [ELF_SUFFIX_TLS_GOTIE] BFD_RELOC_390_TLS_GOTIE32,
		  [ELF_SUFFIX_TLS_IE] BFD_RELOC_390_TLS_IE32,
		  [ELF_SUFFIX_TLS_LDM] BFD_RELOC_390_TLS_LDM32,
		  [ELF_SUFFIX_TLS_LDO] BFD_RELOC_390_TLS_LDO32,
		  [ELF_SUFFIX_TLS_LE] BFD_RELOC_390_TLS_LE32,
d1076 13
a1088 13
		  [ELF_SUFFIX_NONE] BFD_RELOC_UNUSED ,
		  [ELF_SUFFIX_GOT] BFD_RELOC_390_GOT64,
		  [ELF_SUFFIX_PLT] BFD_RELOC_390_PLT64,
		  [ELF_SUFFIX_GOTENT] BFD_RELOC_UNUSED,
		  [ELF_SUFFIX_GOTOFF] BFD_RELOC_390_GOTOFF64,
		  [ELF_SUFFIX_GOTPLT] BFD_RELOC_390_GOTPLT64,
		  [ELF_SUFFIX_PLTOFF] BFD_RELOC_390_PLTOFF64,
		  [ELF_SUFFIX_TLS_GD] BFD_RELOC_390_TLS_GD64,
		  [ELF_SUFFIX_TLS_GOTIE] BFD_RELOC_390_TLS_GOTIE64,
		  [ELF_SUFFIX_TLS_IE] BFD_RELOC_390_TLS_IE64,
		  [ELF_SUFFIX_TLS_LDM] BFD_RELOC_390_TLS_LDM64,
		  [ELF_SUFFIX_TLS_LDO] BFD_RELOC_390_TLS_LDO64,
		  [ELF_SUFFIX_TLS_LE] BFD_RELOC_390_TLS_LE64,
@


1.28
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d603 61
d673 7
a679 1
    ELF_SUFFIX_PLTOFF
d711 6
d1032 60
a1091 26
	  if (nbytes == 2 && suffix == ELF_SUFFIX_GOT)
	    reloc = BFD_RELOC_390_GOT16;
	  else if (nbytes == 4 && suffix == ELF_SUFFIX_GOT)
	    reloc = BFD_RELOC_32_GOT_PCREL;
	  else if (nbytes == 8 && suffix == ELF_SUFFIX_GOT)
	    reloc = BFD_RELOC_390_GOT64;
	  else if (nbytes == 2 && suffix == ELF_SUFFIX_GOTOFF)
	    reloc = BFD_RELOC_16_GOTOFF;
	  else if (nbytes == 4 && suffix == ELF_SUFFIX_GOTOFF)
	    reloc = BFD_RELOC_32_GOTOFF;
	  else if (nbytes == 8 && suffix == ELF_SUFFIX_GOTOFF)
	    reloc = BFD_RELOC_390_GOTOFF64;
	  else if (nbytes == 2 && suffix == ELF_SUFFIX_PLTOFF)
	    reloc = BFD_RELOC_390_PLTOFF16;
	  else if (nbytes == 4 && suffix == ELF_SUFFIX_PLTOFF)
	    reloc = BFD_RELOC_390_PLTOFF32;
	  else if (nbytes == 8 && suffix == ELF_SUFFIX_PLTOFF)
	    reloc = BFD_RELOC_390_PLTOFF64;
	  else if (nbytes == 4 && suffix == ELF_SUFFIX_PLT)
	    reloc = BFD_RELOC_390_PLT32;
	  else if (nbytes == 8 && suffix == ELF_SUFFIX_PLT)
	    reloc = BFD_RELOC_390_PLT64;
	  else if (nbytes == 4 && suffix == ELF_SUFFIX_GOTPLT)
	    reloc = BFD_RELOC_390_GOTPLT32;
	  else if (nbytes == 8 && suffix == ELF_SUFFIX_GOTPLT)
	    reloc = BFD_RELOC_390_GOTPLT64;
d1095 2
a1096 1
	  if (reloc != BFD_RELOC_UNUSED)
a1097 1
	      reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
d1145 1
a1162 1
      expressionS ex;
d1277 12
d1384 14
d1422 9
d1844 20
d2137 26
@


1.27
log
@	* config/tc-s390.c (elf_suffix_type): Add suffix enums for gotoff,
	gotplt and pltoff relocations.
	(s390_elf_suffix): Add suffix strings for gotoff, gotplt and pltoff.
	(s390_elf_cons): Map new lenght/elf suffix combinations for gotoff,
	gotplt and pltoff to bfd relocations.
	(md_gather_operands): Map new instruction operand/elf suffix
	combinations to bfd relocations.
	(tc_s390_fix_adjustable): Add new gotoff, gotplt and pltoff relocations
	to the list of unadjustable relocations.
	(tc_s390_force_relocation): Always emit relocations for gotoff, gotplt
	and pltoff relocations.
	(md_apply_fix3): Add the new relocations.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
a1738 2
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
d1744 1
a1744 1
  return S_FORCE_RELOC (fixp->fx_addsy);
@


1.26
log
@        * config/tc-s390.c (md_apply_fix3): Emit error message for relocations
        with a subsy symbol.
@
text
@d609 4
a612 1
    ELF_SUFFIX_GOTENT
d641 3
d965 12
d981 4
d1146 24
d1682 6
a1687 1
  if (   fixP->fx_r_type == BFD_RELOC_32_GOTOFF
d1697 5
d1721 4
d1734 5
d1870 1
d1897 2
d1924 1
d1926 1
d1934 1
d1945 5
d1951 1
d1953 1
@


1.25
log
@	* ChangeLog-9295: Fix a typo.
	* README: Likewise.
	* config/tc-d10v.c: Fix a comment typo.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-tic80.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* testsuite/gas/h8300/cmpsi2.s: Likewise.
@
text
@d1705 4
a1708 1
    abort ();
@


1.24
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1653 1
a1653 1
   there is some hope of resolving it a assembly time.  */
@


1.23
log
@* config/tc-s390.c (tc_s390_fix_adjustable): Re-add patch to prevent
adjustments to symbols in merge sections.
@
text
@d44 1
a44 1
/* Whether to use user friendly register names. Default is true.  */
d46 1
a46 1
#define TARGET_REG_NAMES_P true
d49 1
a49 1
static boolean reg_names_p = TARGET_REG_NAMES_P;
d52 1
a52 1
static boolean warn_areg_zero = FALSE;
d207 1
a207 1
static boolean register_name PARAMS ((expressionS *));
d259 1
a259 1
static boolean
d273 1
a273 1
    return false;
d290 1
a290 1
      return true;
d295 1
a295 1
  return false;
d369 1
a369 1
	reg_names_p = true;
d372 1
a372 1
	reg_names_p = false;
d443 1
a443 1
  boolean dup_insn = false;
d465 1
a465 1
	  dup_insn = true;
d479 1
a479 1
	  dup_insn = true;
d976 1
a976 1
		 pcrel parameter on the fix_new_exp call needs to be false.  */
d978 1
a978 1
			   size, &exp, false, reloc);
d1083 1
a1083 1
		  && warn_areg_zero == TRUE)
d1087 1
a1087 1
		  && warn_areg_zero == TRUE)
@


1.22
log
@	* config/tc-s390.c (md_parse_option): Set s390_arch_size to 32
	for option -m31.
@
text
@d1632 3
@


1.21
log
@gas reloc rewrite.
@
text
@d378 1
a378 1
	s390_arch_size = 31;
@


1.20
log
@2002-07-02  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* config/tc-s390.c (tc_s390_fix_adjustable): Prevent any adjustment
	to symbols in merge sections, even non pc-relative ones.
@
text
@d27 1
d1378 3
a1380 3
      if (   ((opformat->oplen == 6) && (exp.X_op > 0) && (exp.X_op < (1ULL << 48)))
	  || ((opformat->oplen == 4) && (exp.X_op > 0) && (exp.X_op < (1ULL << 32)))
	  || ((opformat->oplen == 2) && (exp.X_op > 0) && (exp.X_op < (1ULL << 16))))
a1631 8
  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;
  /* Don't adjust references to merge sections.  */
  if ((S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0)
    return 0;
d1675 1
a1675 1
      return 0;
d1677 2
d1694 1
a1694 1
     segT seg;
d1702 1
a1702 14
    {
      if ((fixP->fx_addsy != NULL
	   && S_GET_SEGMENT (fixP->fx_addsy) == S_GET_SEGMENT (fixP->fx_subsy)
	   && SEG_NORMAL (S_GET_SEGMENT (fixP->fx_addsy)))
	  || (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section))
	value += S_GET_VALUE (fixP->fx_subsy);
      if (!S_IS_DEFINED (fixP->fx_subsy))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("unresolved fx_subsy symbol that must be resolved"));
      value -= S_GET_VALUE (fixP->fx_subsy);

      if (S_GET_SEGMENT (fixP->fx_subsy) == seg && ! fixP->fx_pcrel)
	value += MD_PCREL_FROM_SECTION (fixP, seg);
    }
a1705 12
      if ((fixP->fx_subsy != NULL
	   && S_GET_SEGMENT (fixP->fx_addsy) == S_GET_SEGMENT (fixP->fx_subsy)
	   && SEG_NORMAL (S_GET_SEGMENT (fixP->fx_addsy)))
	  || (S_GET_SEGMENT (fixP->fx_addsy) == seg
	      && fixP->fx_pcrel && TC_RELOC_RTSYM_LOC_FIXUP (fixP))
	  || (!fixP->fx_pcrel
	      && S_GET_SEGMENT (fixP->fx_addsy) == absolute_section)
	  || (S_GET_SEGMENT (fixP->fx_addsy) != undefined_section
	      && !bfd_is_com_section (S_GET_SEGMENT (fixP->fx_addsy))
	      && TC_FIX_ADJUSTABLE (fixP)))
	value -= S_GET_VALUE (fixP->fx_addsy);

@


1.19
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d1636 2
a1637 3
  /* Don't adjust pc-relative references to merge sections.  */
  if ((S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0
      && fixP->fx_pcrel)
@


1.18
log
@	* config/tc-mips.c: Fix formatting.
	* config/tc-s390.c: Likewise.
	* config/tc-s390.h: Likewise.
@
text
@d315 1
a315 1
CONST char *md_shortopts = "A:m:kVQ:";
@


1.17
log
@* config/tc-s390.c (md_gather_operands): Emit dwarf2 line-number
information for instructions.
@
text
@d20 1
a20 1
   02111-1307, USA. */
d85 1
a85 1
  /* Pseudo-ops which must be defined. */
d124 1
a124 1
   The table is sorted. Suitable for searching by a binary search. */
d563 1
a563 1
      max = (((addressT) 1 << (operand->bits - 1))<<1) - 1;
d594 1
a594 1
  insn += (offset - 1)/8;
d727 1
a727 1
s390_exp_compare(exp1, exp2)
d774 2
a775 2
    return 0;
  }
d855 1
a855 1
	    && s390_exp_compare(exp_p, &lpe->ex) != 0)
d869 1
a869 1
	  lpe = (struct s390_lpe *) xmalloc(sizeof (struct s390_lpe));
d880 1
a880 1
		    exp_p->X_add_number*sizeof (LITTLENUM_TYPE));
d891 1
a891 1
	  lp_sym = symbol_make(tmp_name);
d897 1
a897 1
      lpe->sym = symbol_make(tmp_name);
d987 1
a987 1
  input_line_pointer--;		/* Put terminator back into stream. */
d1022 2
a1023 1
  while (ISSPACE (*str)) str++;
d1051 2
a1052 1
      if (! register_name (&ex))    /* parse the operand */
d1402 1
a1402 1
  
d1458 1
a1458 1
    return;     /* nothing to be done */
d1497 1
a1497 1
			lpe->ex.X_add_number*sizeof (LITTLENUM_TYPE));
d1595 1
a1595 1
  if (*name == '_' && *(name+1) == 'G'
d1597 10
a1606 10
   {
     if (!GOT_symbol)
      {
        if (symbol_find (name))
          as_bad (_("GOT already in symbol table"));
        GOT_symbol = symbol_new (name, undefined_section,
                                 (valueT) 0, &zero_address_frag);
      }
     return GOT_symbol;
   }
d1628 2
a1629 2
tc_s390_fix_adjustable(fixP)
     fixS * fixP;
d1637 1
a1637 1
  if ((S_GET_SEGMENT(fixP->fx_addsy)->flags & SEC_MERGE) != 0 
d1703 1
a1703 1
  valueT value = * valP;
d1707 1
a1707 1
  if (fixP->fx_subsy != NULL) 
d1717 1
a1717 1
      value -= S_GET_VALUE(fixP->fx_subsy);
d1722 2
a1723 2
  
  if (fixP->fx_addsy != NULL) 
d1727 1
a1727 1
	   && SEG_NORMAL (S_GET_SEGMENT(fixP->fx_addsy)))
d1730 1
a1730 1
	  || (!fixP->fx_pcrel 
d1734 1
a1734 1
	      && TC_FIX_ADJUSTABLE(fixP)))
d1970 2
a1971 2
                    _("cannot represent relocation type %s"),
                    bfd_get_reloc_code_name (code));
@


1.16
log
@	* config/tc-s390.c (md_parse_option): Formatting.
@
text
@d1230 1
@


1.15
log
@	* config/tc-s390.c (tc_s390_fix_adjustable): Prevent adjustments to
	symbols in merge sections.
@
text
@d391 1
a391 1
	  current_architecture = S390_OPCODE_ESA;
d393 1
a393 1
	  current_architecture = S390_OPCODE_ESAME;
@


1.14
log
@2002-02-19  Martin Schwidefsky  <schwidefsky@@de.ibm.com>

	* config/tc-s390.c (md_parse_option): Add switches -m31 and -m64.
	Make bit size independent of architecture switch.
	(md_begin): Add warning for -m64 with -Aesa.
	(s390_md_end): Use renamed architecture defines.
@
text
@d2 1
a2 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d1632 4
@


1.13
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d376 6
a390 1
	{
a391 2
	  s390_arch_size = 32;
	}
a392 1
	{
a393 2
	  s390_arch_size = 64;
	}
d425 3
a427 1
        -mno-regnames     Do not allow symbolic names for registers\n"));
d445 4
d496 1
a496 1
    bfd_set_arch_mach (stdoutput, bfd_arch_s390, bfd_mach_s390_esame);
d498 1
a498 1
    bfd_set_arch_mach (stdoutput, bfd_arch_s390, bfd_mach_s390_esa);
@


1.13.2.1
log
@	Merge from mainline.
	2002-04-17  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* config/tc-s390.c (tc_s390_fix_adjustable): Prevent adjustments to
	symbols in merge sections.

	2002-02-19  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* config/tc-s390.c (md_parse_option): Add switches -m31 and -m64.
	Make bit size independent of architecture switch.
	(md_begin): Add warning for -m64 with -Aesa.
	(s390_md_end): Use renamed architecture defines.

	2002-02-19  Tom Tromey  <tromey@@redhat.com>
	* config/tc-xstormy16.h (DWARF2_LINE_MIN_INSN_LENGTH): Define.

	Tue Apr  9 16:45:48 2002  J"orn Rennecke <joern.rennecke@@superh.com>
	* config/tc-sh.h (TC_FIX_ADJUSTABLE): Disable adjusting if
	symbol_used_in_reloc_p is true.
	* config/tc-sh.c (md_apply_fix3): Don't zero relocations on big
	endian hosts.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
a375 6
      else if (arg != NULL && strcmp (arg, "31") == 0)
	s390_arch_size = 31;

      else if (arg != NULL && strcmp (arg, "64") == 0)
	s390_arch_size = 64;

d385 4
a388 1
	current_architecture = S390_OPCODE_ESA;
d390 4
a393 1
	current_architecture = S390_OPCODE_ESAME;
d425 1
a425 3
        -mno-regnames     Do not allow symbolic names for registers\n\
        -m31              Set file format to 31 bit format\n\
        -m64              Set file format to 64 bit format\n"));
a442 4
  /* Give a warning if the combination -m64-bit and -Aesa is used.  */
  if (s390_arch_size == 64 && current_arch_mask == (1 << S390_OPCODE_ESA))
    as_warn ("The 64 bit file format is used without esame instructions.");

d490 1
a490 1
    bfd_set_arch_mach (stdoutput, bfd_arch_s390, bfd_mach_s390_64);
d492 1
a492 1
    bfd_set_arch_mach (stdoutput, bfd_arch_s390, bfd_mach_s390_31);
a1625 4
    return 0;
  /* Don't adjust pc-relative references to merge sections.  */
  if ((S_GET_SEGMENT(fixP->fx_addsy)->flags & SEC_MERGE) != 0 
      && fixP->fx_pcrel)
@


1.13.2.2
log
@* config/tc-s390.c (md_gather_operands): Emit dwarf2 line-number
information for instructions.
@
text
@a1229 1
  dwarf2_emit_insn (opcode->oplen);
@


1.12
log
@Force got and plt relocations.
@
text
@d1683 4
a1686 4
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
d1690 1
a1690 1
  valueT value;
d1692 1
a1692 2
  value = *valuep;
  where = fixp->fx_frag->fr_literal + fixp->fx_where;
d1694 1
a1694 1
  if (fixp->fx_subsy != NULL) 
d1696 7
a1702 7
      if ((fixp->fx_addsy != NULL
	   && S_GET_SEGMENT (fixp->fx_addsy) == S_GET_SEGMENT (fixp->fx_subsy)
	   && SEG_NORMAL (S_GET_SEGMENT (fixp->fx_addsy)))
	  || (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section))
	value += S_GET_VALUE (fixp->fx_subsy);
      if (!S_IS_DEFINED (fixp->fx_subsy))
	as_bad_where (fixp->fx_file, fixp->fx_line,
d1704 1
a1704 1
      value -= S_GET_VALUE(fixp->fx_subsy);
d1706 2
a1707 2
      if (S_GET_SEGMENT (fixp->fx_subsy) == seg && ! fixp->fx_pcrel)
	value += MD_PCREL_FROM_SECTION (fixp, seg);
d1710 1
a1710 1
  if (fixp->fx_addsy != NULL) 
d1712 11
a1722 11
      if ((fixp->fx_subsy != NULL
	   && S_GET_SEGMENT (fixp->fx_addsy) == S_GET_SEGMENT (fixp->fx_subsy)
	   && SEG_NORMAL (S_GET_SEGMENT(fixp->fx_addsy)))
	  || (S_GET_SEGMENT (fixp->fx_addsy) == seg
	      && fixp->fx_pcrel && TC_RELOC_RTSYM_LOC_FIXUP (fixp))
	  || (!fixp->fx_pcrel 
	      && S_GET_SEGMENT (fixp->fx_addsy) == absolute_section)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != undefined_section
	      && !bfd_is_com_section (S_GET_SEGMENT (fixp->fx_addsy))
	      && TC_FIX_ADJUSTABLE(fixp)))
	value -= S_GET_VALUE (fixp->fx_addsy);
d1724 2
a1725 2
      if (fixp->fx_pcrel)
	value += fixp->fx_frag->fr_address + fixp->fx_where;
d1728 1
a1728 1
    fixp->fx_done = 1;
d1730 1
a1730 1
  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
d1735 1
a1735 1
      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
d1738 1
a1738 1
      if (fixp->fx_done)
d1742 2
a1743 3
			       fixp->fx_file, fixp->fx_line);

	  return 1;
d1749 1
a1749 1
      fixp->fx_offset = value;
d1752 3
a1754 3
	  fixp->fx_size = 2;
	  fixp->fx_where += 2;
	  fixp->fx_r_type = BFD_RELOC_390_12;
d1758 3
a1760 3
	  fixp->fx_size = 2;
	  fixp->fx_where += 4;
	  fixp->fx_r_type = BFD_RELOC_390_12;
d1764 3
a1766 3
	  fixp->fx_size = 1;
	  fixp->fx_where += 1;
	  fixp->fx_r_type = BFD_RELOC_8;
d1770 2
a1771 2
	  fixp->fx_size = 2;
	  fixp->fx_where += 2;
d1774 2
a1775 2
	      fixp->fx_r_type = BFD_RELOC_390_PC16DBL;
	      fixp->fx_offset += 2;
d1778 1
a1778 1
	    fixp->fx_r_type = BFD_RELOC_16;
d1783 4
a1786 4
	  fixp->fx_size = 4;
	  fixp->fx_where += 2;
	  fixp->fx_offset += 2;
	  fixp->fx_r_type = BFD_RELOC_390_PC32DBL;
d1795 2
a1796 2
	  if (expr_symbol_where (fixp->fx_addsy, &sfile, &sline))
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d1799 1
a1799 1
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d1801 2
a1802 2
	  fixp->fx_done = 1;
	  return 1;
d1807 1
a1807 1
      switch (fixp->fx_r_type)
d1810 1
a1810 1
	  if (fixp->fx_pcrel)
d1812 1
a1812 1
	  if (fixp->fx_done)
d1817 1
a1817 1
	  if (fixp->fx_done)
d1831 2
a1832 2
	  if (fixp->fx_pcrel)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d1834 4
a1837 4
			  bfd_get_reloc_code_name (fixp->fx_r_type),
			  fixp->fx_addsy != NULL ? " against " : "",
			  (fixp->fx_addsy != NULL
			   ? S_GET_NAME (fixp->fx_addsy)
d1839 1
a1839 1
	  if (fixp->fx_done)
d1843 1
a1843 1
	  if (fixp->fx_done)
d1849 1
a1849 1
	  if (fixp->fx_done)
d1854 2
a1855 2
	  if (fixp->fx_pcrel)
	    fixp->fx_r_type = BFD_RELOC_32_PCREL;
d1857 2
a1858 2
	    fixp->fx_r_type = BFD_RELOC_32;
	  if (fixp->fx_done)
d1863 2
a1864 2
	  fixp->fx_r_type = BFD_RELOC_32_PCREL;
	  if (fixp->fx_done)
d1869 1
a1869 1
	  if (fixp->fx_done)
d1877 1
a1877 1
	  if (fixp->fx_done)
d1882 1
a1882 1
	  if (fixp->fx_done)
d1888 1
a1888 1
	  if (fixp->fx_done)
d1893 2
a1894 2
	  if (fixp->fx_pcrel)
	    fixp->fx_r_type = BFD_RELOC_64_PCREL;
d1896 2
a1897 2
	    fixp->fx_r_type = BFD_RELOC_64;
	  if (fixp->fx_done)
d1902 2
a1903 2
	  fixp->fx_r_type = BFD_RELOC_64_PCREL;
	  if (fixp->fx_done)
d1909 2
a1910 2
	  fixp->fx_done = 0;
	  return 1;
d1914 1
a1914 1
	    const char *reloc_name = bfd_get_reloc_code_name (fixp->fx_r_type);
d1919 1
a1919 1
	      fprintf (stderr, "Gas failure, reloc type #%i\n", fixp->fx_r_type);
d1925 1
a1925 1
      fixp->fx_offset = value;
a1926 2

  return 1;
@


1.11
log
@Add option -mwarn-areg-zero.
@
text
@d1644 30
d1687 1
a1687 1
     segT seg ATTRIBUTE_UNUSED;
d1695 1
a1695 1
  if (fixp->fx_subsy != NULL)
d1697 5
d1706 3
d1710 2
a1711 2

  if (fixp->fx_addsy != NULL)
d1713 10
a1722 6
      /* `*valuep' may contain the value of the symbol on which the reloc
	 will be based; we have to remove it.  */
      if (fixp->fx_addsy->sy_used_in_reloc
	  && S_GET_SEGMENT (fixp->fx_addsy) != absolute_section
	  && S_GET_SEGMENT (fixp->fx_addsy) != undefined_section
	  && ! bfd_is_com_section (S_GET_SEGMENT (fixp->fx_addsy)))
@


1.10
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d31 1
a31 1
/* The default architecture */
d38 1
a38 1
/* Current architecture. Start with the smallest instruction set */
d43 1
a43 1
/* Whether to use user friendly register names. Default is true. */
d50 3
d373 3
d422 4
a425 3
          S390 options:\n\
          -mregnames   \tAllow symbolic names for registers\n\
          -mno-regnames\tDo not allow symbolic names for registers\n"));
d427 2
a428 2
          -V       \tprint assembler version number\n\
          -Qy, -Qn \tignored\n"));
d433 1
a433 1
   opened. */
d443 1
a443 1
  /* Set the ELF flags if desired. */
d648 2
a649 2
    if (len == ptr->length &&
	strncasecmp (ident, ptr->string, ptr->length) == 0)
d742 2
a743 2
      return (exp1->X_add_symbol == exp2->X_add_symbol) &&
	(exp1->X_add_number == exp2->X_add_number);
d764 3
a766 3
      return (exp1->X_add_symbol == exp2->X_add_symbol) &&
	     (exp1->X_op_symbol == exp2->X_op_symbol) &&
	     (exp1->X_add_number == exp2->X_add_number);
d795 2
a796 2
  if (len != 4 || strncasecmp (ident, "lit", 3) != 0 ||
      (ident[3]!='1' && ident[3]!='2' && ident[3]!='4' && ident[3]!='8'))
d848 2
a849 2
	if (lpe->nbytes == nbytes && lpe->reloc == reloc &&
	    s390_exp_compare(exp_p, &lpe->ex) != 0)
d1072 3
a1074 1
	      if ((operand->flags & S390_OPERAND_INDEX) && ex.X_add_number == 0)
d1076 3
a1078 1
	      if ((operand->flags & S390_OPERAND_BASE) && ex.X_add_number == 0)
d1093 2
a1094 2
	      else if ((operand->flags & S390_OPERAND_SIGNED) &&
		       (operand->bits == 16))
d1096 2
a1097 2
	      else if ((operand->flags & S390_OPERAND_PCREL) &&
		       (operand->bits == 32))
d1102 2
a1103 2
	      if ((operand->flags & S390_OPERAND_PCREL) &&
		  (operand->bits == 16))
d1105 2
a1106 2
	      else if ((operand->flags & S390_OPERAND_PCREL) &&
		       (operand->bits == 32))
d1111 2
a1112 2
	      if ((operand->flags & S390_OPERAND_PCREL) &&
		  (operand->bits == 32))
d1257 2
a1258 2
	  if (fixups[i].reloc == BFD_RELOC_390_GOT12 ||
	      fixups[i].reloc == BFD_RELOC_390_GOT16)
d1368 3
a1370 3
      if ((opformat->oplen == 6 && exp.X_op > 0 && exp.X_op < (1ULL << 48)) ||
	  (opformat->oplen == 4 && exp.X_op > 0 && exp.X_op < (1ULL << 32)) ||
	  (opformat->oplen == 2 && exp.X_op > 0 && exp.X_op < (1ULL << 16)))
d1377 3
a1379 3
      if (exp.X_add_number > 0 &&
	  opformat->oplen == 6 &&
	  generic_bignum[3] == 0)
d1628 1
a1628 1
  if (fixP->fx_r_type == BFD_RELOC_32_GOTOFF
d1740 2
a1741 2
      else if (operand->bits == 32 && operand->shift == 16 &&
	       (operand->flags & S390_OPERAND_PCREL))
d1904 2
a1905 2
      if ((s390_arch_size == 32 && code == BFD_RELOC_32_PCREL) ||
	  (s390_arch_size == 64 && code == BFD_RELOC_64_PCREL))
@


1.9
log
@s390 assembler improvements and testsuite
@
text
@a22 1
#include <ctype.h>
d24 1
d266 1
a266 1
  if (name[0] == '%' && isalpha (name[1]))
d636 1
a636 1
  while (isalnum (*str))
d785 1
a785 1
  while (isalnum (*str))
d1009 1
a1009 1
  while (isspace(*str)) str++;
d1196 1
a1196 1
  while (isspace (*str))
d1270 1
a1270 1
  for (s = str; *s != '\0' && ! isspace (*s); s++)
d1339 1
a1339 1
  while (*s != '\0' && *s != ',' && ! isspace (*s))
@


1.8
log
@	* config/tc-s390.c: Add missing prototypes
	(md_gather_operands): Make static.
@
text
@d1357 3
a1359 2
      if (opformat->oplen == 4 ||
	  (opformat->oplen == 2 && exp.X_op < 0x10000))
d1379 2
a1380 1
  if (*input_line_pointer++ != ',')
d1382 1
a1382 1

d1385 2
a1386 1
  input_line_pointer = md_gather_operands (input_line_pointer, insn, opformat);
@


1.7
log
@	* config/tc-s390.c (s390_elf_cons): Correct fixups for PLT
	relocations.
@
text
@d201 10
d606 6
d993 1
a993 1
char *
@


1.6
log
@	* config/obj-elf.c (obj_elf_symver): Temporarily modify lex_type
	to include '@@' in symbol names when parsing versioned symbols
	rather than calling get_symbol_end multiple times.
	* config/tc-i370.c (register_name): Format fixes.  Don't call
	get_symbol_end after parsing number.
	* config/tc-mn10200.c (data_register_name): Format fixes.  Hoist
	code out of conditional.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-mn10300.c (r_register_name): Likewise.
	(xr_register_name): Likewise.
	(data_register_name): Likewise.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-ppc.c (register_name): Likewise.
	* config/tc-s390.c (register_name): Likewise.
@
text
@d83 1
a83 1
  { "bss",      s390_bss,       0 }, 
d160 15
a174 15
  { "f1", 1 }, 
  { "f10", 10 }, 
  { "f11", 11 }, 
  { "f12", 12 }, 
  { "f13", 13 }, 
  { "f14", 14 }, 
  { "f15", 15 }, 
  { "f2", 2 }, 
  { "f3", 3 }, 
  { "f4", 4 }, 
  { "f5", 5 }, 
  { "f6", 6 }, 
  { "f7", 7 }, 
  { "f8", 8 }, 
  { "f9", 9 }, 
d268 1
a268 1
  if (reg_number >= 0) 
d272 1
a272 1
      
d356 1
a356 1
    
d359 1
a359 1
    
d366 1
a366 1
    
d388 1
a388 1
    
d393 1
a393 1
      
d397 1
a397 1
  
d539 1
a539 1
      
d552 1
a552 1
    
d712 1
a712 1
      as_bad (_("Can't handle O_big in s390_exp_compare")); 
d766 1
a766 1
 
d880 1
a880 1
  
d945 4
a948 2
	      fix_new_exp (frag_now, where - frag_now->fr_literal, 
			   size, &exp, reloc_howto->pc_relative, reloc);
d1006 1
a1006 1
    
d1010 1
a1010 1
	     register is skipped (X is optional). For D(L,B) the base  
d1016 1
a1016 1
    
d1023 1
a1023 1
    
d1026 1
a1026 1
    
d1100 1
a1100 1
 
d1118 1
a1118 1
	
d1213 1
a1213 1
      
d1217 1
a1217 1
      
d1222 3
a1224 3
      
	  fixP = fix_new_exp (frag_now, 
			      f - frag_now->fr_literal + (operand->shift/8), 
d1349 1
a1349 1
      if (exp.X_add_number > 0 && 
d1409 1
a1409 1
   .ltorg or the invocation of gas. Literals are defined with the 
d1437 1
a1437 1
	  reloc_howto_type *reloc_howto = 
d1514 1
a1514 1
     
d1652 1
a1652 1
      
d1663 1
a1663 1
    
d1666 1
a1666 1
      
d1675 1
a1675 1
    
d1722 1
a1722 1
      
d1754 1
a1754 1
	    } 
d1756 1
a1756 1
    
d1845 1
a1845 1
	    
@


1.5
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@d254 1
a254 1
  /* Find the spelling of the operand */
d264 4
a267 1
  /* look to see if it's in the register table */
d273 1
a273 1
      /* make the rest nice */
a275 1
      *input_line_pointer = c;   /* put back the delimiting char */
d278 4
a281 7
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
    }
@


1.4
log
@	* config/tc-s390.c (s390_force_relocation): Removed.

	* config/tc-s390.h: Remove double declaration of
	TC_FORCE_RELOCATION.
@
text
@d199 1
a199 1
#define REG_NAME_CNT (sizeof(pre_defined_registers) / sizeof(struct pd_reg))
d307 1
a307 1
size_t md_longopts_size = sizeof(md_longopts);
d317 1
a317 1
  if (strcmp(default_arch, "s390") == 0)
d322 1
a322 1
  else if (strcmp(default_arch, "s390x") == 0)
d487 1
a487 1
      memset(fragP->fr_literal + fragP->fr_fix, 0x07, count);
d621 1
a621 1
  while (isalnum(*str))
d627 1
a627 1
	strncasecmp(ident, ptr->string, ptr->length) == 0)
d713 1
a713 1
      as_bad(_("Can't handle O_big in s390_exp_compare")); 
d770 1
a770 1
  while (isalnum(*str))
d773 1
a773 1
  if (len != 4 || strncasecmp(ident, "lit", 3) != 0 ||
d841 1
a841 1
	  lpe = (struct s390_lpe *) xmalloc(sizeof(struct s390_lpe));
d852 1
a852 1
		    exp_p->X_add_number*sizeof(LITTLENUM_TYPE));
d862 1
a862 1
	  sprintf(tmp_name, ".L\001%i", lp_count);
d867 1
a867 1
      sprintf(tmp_name, ".L\001%i\002%i", lp_count, lpe_count);
d944 1
a944 1
	      where = frag_more(nbytes);
d1049 1
a1049 1
		as_warn("index register specified but zero");
d1051 1
a1051 1
		as_warn("base register specified but zero");
d1122 1
a1122 1
		    as_bad(_("syntax error; expected ,"));
d1174 1
a1174 1
		as_bad(_("syntax error; expected ,"));
d1186 1
a1186 1
      if ((linefeed = strchr(str, '\n')) != NULL)
d1267 1
a1267 1
      as_bad("Opcode %s not available in this architecture", str);
d1271 1
a1271 1
  memcpy (insn, opcode->opcode, sizeof(insn));
d1312 1
a1312 1
s390_insn(ignore)
d1344 1
a1344 1
	as_bad(_("Invalid .insn format\n"));
d1357 1
a1357 1
	as_bad(_("Invalid .insn format\n"));
d1364 1
a1364 1
  if ((s = strchr(input_line_pointer, '\n')) != NULL)
d1444 1
a1444 1
	  where = frag_more(lpe->nbytes);
d1457 1
a1457 1
			lpe->ex.X_add_number*sizeof(LITTLENUM_TYPE));
d1556 1
a1556 1
      && strcmp(name, "_GLOBAL_OFFSET_TABLE_") == 0)
d1558 1
a1558 1
     if(!GOT_symbol)
d1560 2
a1561 2
        if(symbol_find(name))
          as_bad(_("GOT already in symbol table"));
d1812 1
a1812 1
	    md_number_to_chars (where, value, sizeof(int));
@


1.3
log
@Do not optimize BFD_RELOC_390_GOTENT relocs.
Always generate relocs for VT_ relocs.
@
text
@a1897 12

int
s390_force_relocation (fixp)
     struct fix * fixp;
{
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  return 0;
}

@


1.2
log
@Fix copyright notices
@
text
@d316 12
a327 7
  if (strcmp(default_arch, "s390") == 0) {
    s390_arch_size = 32;
    current_architecture = S390_OPCODE_ESA;
  } else if (strcmp(default_arch, "s390x") == 0) {
    s390_arch_size = 64;
    current_architecture = S390_OPCODE_ESAME;
  } else
d349 8
a356 7
  switch (c) {
    /* -k: Ignore for FreeBSD compatibility.  */
  case 'k':
    break;
  case 'm':
    if (arg != NULL && strcmp (arg, "regnames") == 0)
      reg_names_p = true;
d358 2
a359 2
    else if (arg != NULL && strcmp (arg, "no-regnames") == 0)
      reg_names_p = false;
d361 35
a395 2
    else {
      as_bad (_("invalid switch -m%s"), arg);
a397 28
    break;
    
  case 'A':
    if (arg != NULL && strcmp (arg, "esa") == 0) {
      current_architecture = S390_OPCODE_ESA;
      s390_arch_size = 32;
    } else if (arg != NULL && strcmp (arg, "esame") == 0) {
      current_architecture = S390_OPCODE_ESAME;
      s390_arch_size = 64;
    } else
      as_bad ("invalid architecture -A%s", arg);
    current_arch_mask = 1 << current_architecture;
    current_arch_requested = 1;
    break;

    /* -V: SVR4 argument to print version ID.  */
  case 'V':
    print_version_id ();
    break;
    
    /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
       should be emitted or not.  FIXME: Not implemented.  */
  case 'Q':
    break;
    
  default:
    return 0;
  }
d406 1
a406 1
  fprintf(stream, _("\
d410 1
a410 1
  fprintf(stream, _("\
d435 10
a444 9
  for (op = s390_opformats; op < op_end; op++) {
    retval = hash_insert (s390_opformat_hash, op->name, (PTR) op);
    if (retval != (const char *) NULL)
      {
	as_bad (_("Internal assembler error for instruction format %s"),
		op->name);
	dup_insn = true;
      }
  }
d450 10
a459 9
  for (op = s390_opcodes; op < op_end; op++) {
    retval = hash_insert (s390_opcode_hash, op->name, (PTR) op);
    if (retval != (const char *) NULL)
      {
	as_bad (_("Internal assembler error for instruction %s"), op->name);
	dup_insn = true;
      }
  }
  
d473 1
a473 1
  if (s390_arch_size == 64) {
d475 1
a475 1
  } else {
a476 1
  }
d485 5
a489 4
  if (count > 0) {
    memset(fragP->fr_literal + fragP->fr_fix, 0x07, count);
    fragP->fr_var = count;
  }
d505 3
a507 2
  if (operand->flags & (S390_OPERAND_SIGNED|S390_OPERAND_PCREL)) {
    offsetT min, max;
d509 27
a535 22
    max = ((offsetT) 1 << (operand->bits - 1)) - 1;
    min = - ((offsetT) 1 << (operand->bits - 1));
    /* Halve PCREL operands.  */
    if (operand->flags & S390_OPERAND_PCREL)
      val >>= 1;
    /* Check for underflow / overflow.  */
    if (val < min || val > max) {
      const char *err =
       "operand out of range (%s not between %ld and %ld)";
      char buf[100];

      if (operand->flags & S390_OPERAND_PCREL) {
        val <<= 1;
        min <<= 1;
        max <<= 1;
      }
      sprint_value (buf, val);
      if (file == (char *) NULL)
        as_bad (err, buf, (int) min, (int) max);
      else
        as_bad_where (file, line, err, buf, (int) min, (int) max);
      return;
d537 16
a552 16
    /* val is ok, now restrict it to operand->bits bits.  */
    uval = (addressT) val & ((((addressT) 1 << (operand->bits-1)) << 1) - 1);
  } else {
    addressT min, max;

    max = (((addressT) 1 << (operand->bits - 1))<<1) - 1;
    min = (offsetT) 0;
    uval = (addressT) val;
    /* Length x in an instructions has real length x+1.  */
    if (operand->flags & S390_OPERAND_LENGTH)
      uval--;
    /* Check for underflow / overflow.  */
    if (uval < min || uval > max) {
      const char *err =
        "operand out of range (%s not between %ld and %ld)";
      char buf[100];
d554 13
a566 11
      if (operand->flags & S390_OPERAND_LENGTH) {
        uval++;
        min++;
        max++;
      }
      sprint_value (buf, uval);
      if (file == (char *) NULL)
	as_bad (err, buf, (int) min, (int) max);
      else
	as_bad_where (file, line, err, buf, (int) min, (int) max);
      return;
a567 1
  }
d573 5
a577 4
  while (uval != 0) {
    *insn-- |= uval;
    uval >>= 8;
  }
d581 15
a595 12
typedef enum {
  ELF_SUFFIX_NONE = 0,
  ELF_SUFFIX_GOT,
  ELF_SUFFIX_PLT,
  ELF_SUFFIX_GOTENT
} elf_suffix_type;

struct map_bfd {
  char *string;
  int length;
  elf_suffix_type suffix;
};
d603 2
a604 1
  static struct map_bfd mapping[] = {
d627 44
a670 33
	strncasecmp(ident, ptr->string, ptr->length) == 0) {
      if (exp_p->X_add_number != 0)
	as_warn (_("identifier+constant@@%s means identifier@@%s+constant"),
		 ptr->string, ptr->string);
      /* Now check for identifier@@suffix+constant.  */
      if (*str == '-' || *str == '+') {
	  char *orig_line = input_line_pointer;
	  expressionS new_exp;

	  input_line_pointer = str;
	  expression (&new_exp);

          switch (new_exp.X_op) {
	  case O_constant: /* X_add_number (a constant expression).  */
	    exp_p->X_add_number += new_exp.X_add_number;
	    str = input_line_pointer;
	    break;
	  case O_symbol:   /* X_add_symbol + X_add_number.  */
	    /* this case is used for e.g. xyz@@PLT+.Label.  */
	    exp_p->X_add_number += new_exp.X_add_number;
	    exp_p->X_op_symbol = new_exp.X_add_symbol;
	    exp_p->X_op = O_add;
	    str = input_line_pointer;
	    break;
	  case O_uminus:   /* (- X_add_symbol) + X_add_number.  */
	    /* this case is used for e.g. xyz@@PLT-.Label.  */
	    exp_p->X_add_number += new_exp.X_add_number;
	    exp_p->X_op_symbol = new_exp.X_add_symbol;
	    exp_p->X_op = O_subtract;
	    str = input_line_pointer;
	    break;
	  default:
	    break;
d672 2
a673 7

	  /* If s390_elf_suffix has not been called with
	     &input_line_pointer as first parameter, we have
	     clobbered the input_line_pointer. We have to
	     undo that.  */
	  if (&input_line_pointer != str_p)
	    input_line_pointer = orig_line;
a674 3
      *str_p = str;
      return ptr->suffix;
    }
d680 10
a689 9
struct s390_lpe {
  struct s390_lpe *next;
  expressionS ex;
  FLONUM_TYPE floatnum;     /* used if X_op == O_big && X_add_number <= 0 */
  LITTLENUM_TYPE bignum[4]; /* used if X_op == O_big && X_add_number > 0  */
  int nbytes;
  bfd_reloc_code_real_type reloc;
  symbolS *sym;
};
d706 40
a745 39
  switch (exp1->X_op) {
  case O_constant:   /* X_add_number must be equal.  */
  case O_register:
    return exp1->X_add_number == exp2->X_add_number;

  case O_big:
    as_bad(_("Can't handle O_big in s390_exp_compare")); 

  case O_symbol:     /* X_add_symbol & X_add_number must be equal.  */
  case O_symbol_rva:
  case O_uminus:
  case O_bit_not:
  case O_logical_not:
    return (exp1->X_add_symbol == exp2->X_add_symbol) &&
           (exp1->X_add_number == exp2->X_add_number);

  case O_multiply:   /* X_add_symbol,X_op_symbol&X_add_number must be equal.  */
  case O_divide:
  case O_modulus:
  case O_left_shift:
  case O_right_shift:
  case O_bit_inclusive_or:
  case O_bit_or_not:
  case O_bit_exclusive_or:
  case O_bit_and:
  case O_add:
  case O_subtract:
  case O_eq:
  case O_ne:
  case O_lt:
  case O_le:
  case O_ge:
  case O_gt:
  case O_logical_and:
  case O_logical_or:
    return (exp1->X_add_symbol == exp2->X_add_symbol) &&
           (exp1->X_op_symbol == exp2->X_op_symbol) &&
           (exp1->X_add_number == exp2->X_add_number);
  default:
d779 16
a794 13
  if (suffix == ELF_SUFFIX_GOT) {
    if (nbytes == 2)
      reloc = BFD_RELOC_390_GOT16;
    else if (nbytes == 4)
      reloc = BFD_RELOC_32_GOT_PCREL;
    else if (nbytes == 8)
      reloc = BFD_RELOC_390_GOT64;
  } else if (suffix == ELF_SUFFIX_PLT) {
    if (nbytes == 4)
      reloc = BFD_RELOC_390_PLT32;
    else if (nbytes == 8)
      reloc = BFD_RELOC_390_PLT64;
  }
d796 1
a796 1
  if (suffix != ELF_SUFFIX_NONE && reloc == BFD_RELOC_UNUSED) {
a797 1
  }
d800 29
a828 14
  if (exp_p->X_op == O_big) {
    /* Special processing for big numbers.  */
    for (lpe = lpe_list; lpe != NULL; lpe = lpe->next) {
      if (lpe->ex.X_op == O_big) {
        if (exp_p->X_add_number <= 0 && lpe->ex.X_add_number <= 0) {
          if (memcmp(&generic_floating_point_number, &lpe->floatnum,
                     sizeof(FLONUM_TYPE)) == 0)
            break;
        } else if (exp_p->X_add_number == lpe->ex.X_add_number) {
          if (memcmp(generic_bignum, lpe->bignum,
              sizeof(LITTLENUM_TYPE)*exp_p->X_add_number) == 0)
            break;
        }
      }
d830 48
a877 21
  } else {
    /* Processing for 'normal' data types.  */
    for (lpe = lpe_list; lpe != NULL; lpe = lpe->next)
      if (lpe->nbytes == nbytes && lpe->reloc == reloc &&
          s390_exp_compare(exp_p, &lpe->ex) != 0)
        break;
  }
  if (lpe == NULL) {   /* A new literal.  */
    if (lpe_free_list != NULL) {
      lpe = lpe_free_list;
      lpe_free_list = lpe_free_list->next;
    } else {
      lpe = (struct s390_lpe *) xmalloc(sizeof(struct s390_lpe));
    }
    lpe->ex = *exp_p;
    if (exp_p->X_op == O_big) {
      if (exp_p->X_add_number <= 0)
        lpe->floatnum = generic_floating_point_number;
      else if (exp_p->X_add_number <= 4)
        memcpy(lpe->bignum, generic_bignum,
               exp_p->X_add_number*sizeof(LITTLENUM_TYPE));
d879 1
a879 1
        as_bad(_("Big number is too big"));
d881 1
a881 20
    lpe->nbytes = nbytes;
    lpe->reloc = reloc;
    /* Literal pool name defined ?  */
    if (lp_sym == NULL) {
      sprintf(tmp_name, ".L\001%i", lp_count);
      lp_sym = symbol_make(tmp_name);
    }
    /* Make name for literal pool entry.  */
    sprintf(tmp_name, ".L\001%i\002%i", lp_count, lpe_count);
    lpe_count++;
    lpe->sym = symbol_make(tmp_name);
    /* Add to literal pool list.  */
    lpe->next = NULL;
    if (lpe_list_tail != NULL) {
      lpe_list_tail->next = lpe;
      lpe_list_tail = lpe;
    } else
      lpe_list = lpe_list_tail = lpe;
  }

d905 9
a913 4
  if (is_it_end_of_statement ()) {
    demand_empty_rest_of_line ();
    return;
  }
d915 37
a951 19
  do {
    expression (&exp);
    if (exp.X_op == O_symbol && *input_line_pointer == '@@' &&
        (suffix=s390_elf_suffix(&input_line_pointer, &exp))!=ELF_SUFFIX_NONE) {
      bfd_reloc_code_real_type reloc;
      reloc_howto_type *reloc_howto;
      int size;
      char *where;

      if (nbytes == 2 && suffix == ELF_SUFFIX_GOT)
        reloc = BFD_RELOC_390_GOT16;
      else if (nbytes == 4 && suffix == ELF_SUFFIX_GOT)
        reloc = BFD_RELOC_32_GOT_PCREL;
      else if (nbytes == 8 && suffix == ELF_SUFFIX_GOT)
        reloc = BFD_RELOC_390_GOT64;
      else if (nbytes == 4 && suffix == ELF_SUFFIX_PLT)
        reloc = BFD_RELOC_390_PLT32;
      else if (nbytes == 8 && suffix == ELF_SUFFIX_PLT)
        reloc = BFD_RELOC_390_PLT64;
d953 3
a955 17
        reloc = BFD_RELOC_UNUSED;

      if (reloc != BFD_RELOC_UNUSED) {
        reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
        size = bfd_get_reloc_size (reloc_howto);
        if (size > nbytes)
          as_bad (_("%s relocations do not fit in %d bytes"),
                  reloc_howto->name, nbytes);
        where = frag_more(nbytes);
        md_number_to_chars (where, 0, size);
        fix_new_exp (frag_now, where - frag_now->fr_literal, 
                     size, &exp, reloc_howto->pc_relative, reloc);
     } else
       as_bad (_("relocation not applicable"));
   } else
     emit_expr (&exp, (unsigned int) nbytes);
  } while (*input_line_pointer++ == ',');
d966 5
a970 5
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};
d999 6
a1004 3
  for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++) {
    expressionS ex;
    char *hold;
d1006 9
a1014 1
    operand = s390_operands + *opindex_ptr;
d1016 6
a1021 8
    if (skip_optional && (operand->flags & S390_OPERAND_INDEX)) {
      /* We do an early skip. For D(X,B) constructions the index
         register is skipped (X is optional). For D(L,B) the base  
         register will be the skipped operand, because L is NOT
         optional.  */
      skip_optional = 0;
      continue;
    }
d1023 2
a1024 3
    /* Gather the operand.  */
    hold = input_line_pointer;
    input_line_pointer = str;
d1026 66
a1091 16
    if (! register_name (&ex))    /* parse the operand */
      expression (&ex);
    
    str = input_line_pointer;
    input_line_pointer = hold;
    
    /* Write the operand to the insn.  */
    if (ex.X_op == O_illegal)
      as_bad (_("illegal operand"));
    else if (ex.X_op == O_absent)
      as_bad (_("missing operand"));
    else if (ex.X_op == O_register || ex.X_op == O_constant) {
	s390_lit_suffix (&str, &ex, ELF_SUFFIX_NONE);
	if (ex.X_op != O_register && ex.X_op != O_constant) {
	  /* We need to generate a fixup for the
	     expression returned by s390_lit_suffix.  */
d1096 1
a1096 1
	  fixups[fc].reloc = BFD_RELOC_UNUSED;
d1098 1
a1098 44
	} else {
          if ((operand->flags & S390_OPERAND_INDEX) && ex.X_add_number == 0)
            as_warn("index register specified but zero");
          if ((operand->flags & S390_OPERAND_BASE) && ex.X_add_number == 0)
            as_warn("base register specified but zero");
	  s390_insert_operand (insn, operand, ex.X_add_number, NULL, 0);
        }
    } else {
      suffix = s390_elf_suffix (&str, &ex);
      suffix = s390_lit_suffix (&str, &ex, suffix);
      reloc = BFD_RELOC_UNUSED;
      if (suffix == ELF_SUFFIX_GOT) {
        if (operand->flags & S390_OPERAND_DISP)
          reloc = BFD_RELOC_390_GOT12;
        else if ((operand->flags & S390_OPERAND_SIGNED) &&
                 (operand->bits == 16))
          reloc = BFD_RELOC_390_GOT16;
	else if ((operand->flags & S390_OPERAND_PCREL) &&
		 (operand->bits == 32))
	  reloc = BFD_RELOC_390_GOTENT;
      } else if (suffix == ELF_SUFFIX_PLT) {
        if ((operand->flags & S390_OPERAND_PCREL) &&
            (operand->bits == 16))
          reloc = BFD_RELOC_390_PLT16DBL;
        else if ((operand->flags & S390_OPERAND_PCREL) &&
                 (operand->bits == 32))
          reloc = BFD_RELOC_390_PLT32DBL;
      } else if (suffix == ELF_SUFFIX_GOTENT) {
        if ((operand->flags & S390_OPERAND_PCREL) &&
            (operand->bits == 32))
          reloc = BFD_RELOC_390_GOTENT;
      }

      if (suffix != ELF_SUFFIX_NONE && reloc == BFD_RELOC_UNUSED)
        as_bad (_("invalid operand suffix"));
      /* We need to generate a fixup of type 'reloc' for this
         expression.  */
      if (fc >= MAX_INSN_FIXUPS)
	as_fatal (_("too many fixups"));
      fixups[fc].exp = ex;
      fixups[fc].opindex = *opindex_ptr;
      fixups[fc].reloc = reloc;
      ++fc;
    }
d1100 17
a1116 11
    /* Check the next character. The call to expression has advanced
       str past any whitespace.  */
    if (operand->flags & S390_OPERAND_DISP) {
      /* After a displacement a block in parentheses can start.  */
      if (*str != '(') {
	/* Check if parethesed block can be skipped. If the next
	   operand is neiter an optional operand nor a base register
	   then we have a syntax error.  */
	operand = s390_operands + *(++opindex_ptr);
	if (!(operand->flags & (S390_OPERAND_INDEX|S390_OPERAND_BASE)))
	  as_bad (_("syntax error; missing '(' after displacement"));
d1118 59
a1176 47
	/* Ok, skip all operands until S390_OPERAND_BASE.  */
	while (!(operand->flags & S390_OPERAND_BASE))
	  operand = s390_operands + *(++opindex_ptr);
	
	/* If there is a next operand it must be seperated by a comma.  */
	if (opindex_ptr[1] != '\0') {
	  if (*str++ != ',')
	    as_bad(_("syntax error; expected ,"));
	}
      } else { /* We found an opening parentheses.  */
	str++;
	for (f = str; *f != '\0'; f++)
	  if (*f == ',' || *f == ')')
	    break;
	/* If there is no comma until the closing parentheses OR
           there is a comma right after the opening parentheses,
	   we have to skip optional operands.  */
        if (*f == ',' && f == str) {  /* comma directly after '(' ? */
          skip_optional = 1;
          str++;
        } else
          skip_optional = (*f != ',');
      }
    } else if (operand->flags & S390_OPERAND_BASE) {
      /* After the base register the parenthesed block ends.  */
      if (*str++ != ')')
	as_bad(_("syntax error; missing ')' after base register"));
      skip_optional = 0;
      /* If there is a next operand it must be seperated by a comma.  */
      if (opindex_ptr[1] != '\0') {
	if (*str++ != ',')
	  as_bad(_("syntax error; expected ,"));
      }
    } else {
      /* We can find an 'early' closing parentheses in e.g. D(L) instead
         of D(L,B).  In this case the base register has to be skipped.  */
      if (*str == ')') {
	operand = s390_operands + *(++opindex_ptr);
	if (!(operand->flags & S390_OPERAND_BASE))
	  as_bad (_("syntax error; ')' not allowed here"));
	str++;
      }
      /* If there is a next operand it must be seperated by a comma.  */
      if (opindex_ptr[1] != '\0') {
	if (*str++ != ',')
	  as_bad(_("syntax error; expected ,"));
      }
a1177 1
  }
d1182 3
a1184 2
  if (*str != '\0') {
    char *linefeed;
d1186 6
a1191 6
    if ((linefeed = strchr(str, '\n')) != NULL)
      *linefeed = '\0';
    as_bad (_("junk at end of line: `%s'"), str);
    if (linefeed != NULL)
      *linefeed = '\n';
  }
d1195 1
a1195 1
  memcpy(f, insn, opcode->oplen);
d1203 3
a1205 2
  for (i = 0; i < fc; i++) {
    operand = s390_operands + fixups[i].opindex;
d1207 5
a1211 4
    if (fixups[i].reloc != BFD_RELOC_UNUSED) {
      reloc_howto_type *reloc_howto;
      fixS *fixP;
      int size;
d1213 3
a1215 3
      reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
      if (!reloc_howto)
	abort ();
d1217 4
a1220 1
      size = bfd_get_reloc_size (reloc_howto);
d1222 17
a1238 19
      if (size < 1 || size > 4)
	abort();
      
      fixP = fix_new_exp (frag_now, 
			  f - frag_now->fr_literal + (operand->shift/8), 
			  size, &fixups[i].exp, reloc_howto->pc_relative,
			  fixups[i].reloc);
      /* Turn off overflow checking in fixup_segment. This is necessary
         because fixup_segment will signal an overflow for large 4 byte
         quantities for GOT12 relocations.  */
      if (fixups[i].reloc == BFD_RELOC_390_GOT12 ||
          fixups[i].reloc == BFD_RELOC_390_GOT16)
        fixP->fx_no_overflow = 1;
    } else
      fix_new_exp (frag_now, f - frag_now->fr_literal, 4, &fixups[i].exp,
		   (operand->flags & S390_OPERAND_PCREL) != 0,
		   ((bfd_reloc_code_real_type)
		    (fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
  }
d1260 10
a1269 7
  if (opcode == (const struct s390_opcode *) NULL) {
    as_bad (_("Unrecognized opcode: `%s'"), str);
    return;
  } else if (!(opcode->architecture & current_arch_mask)) {
    as_bad("Opcode %s not available in this architecture", str);
    return;
  }
d1271 2
a1272 2
  memcpy(insn, opcode->opcode, sizeof(insn));
  md_gather_operands(s, insn, opcode);
d1331 5
a1335 4
  if (opformat == (const struct s390_opcode *) NULL) {
    as_bad (_("Unrecognized opcode format: `%s'"), input_line_pointer);
    return;
  }
d1338 22
a1359 16
  if (exp.X_op == O_constant) {
    if (opformat->oplen == 4 ||
	(opformat->oplen == 2 && exp.X_op < 0x10000))
      md_number_to_chars (insn, exp.X_add_number, opformat->oplen);
    else
      as_bad(_("Invalid .insn format\n"));
  } else if (exp.X_op == O_big) {
    if (exp.X_add_number > 0 && 
	opformat->oplen == 6 &&
	generic_bignum[3] == 0) {
      md_number_to_chars (insn, generic_bignum[2], 2);
      md_number_to_chars (&insn[2], generic_bignum[1], 2);
      md_number_to_chars (&insn[4], generic_bignum[0], 2);
    } else
      as_bad(_("Invalid .insn format\n"));
  } else
d1425 36
a1460 31
  while (lpe_list) {
    lpe = lpe_list;
    lpe_list = lpe_list->next;
    S_SET_SEGMENT (lpe->sym, now_seg);
    S_SET_VALUE (lpe->sym, (valueT) frag_now_fix ());
    lpe->sym->sy_frag = frag_now;

    /* Emit literal pool entry.  */
    if (lpe->reloc != BFD_RELOC_UNUSED) {
      reloc_howto_type *reloc_howto = 
              bfd_reloc_type_lookup (stdoutput, lpe->reloc);
      int size = bfd_get_reloc_size (reloc_howto);
      char *where;

      if (size > lpe->nbytes)
        as_bad (_("%s relocations do not fit in %d bytes"),
                reloc_howto->name, lpe->nbytes);
      where = frag_more(lpe->nbytes);
      md_number_to_chars (where, 0, size);
      fix_new_exp (frag_now, where - frag_now->fr_literal,
                   size, &lpe->ex, reloc_howto->pc_relative, lpe->reloc);
   } else {
      if (lpe->ex.X_op == O_big) {
        if (lpe->ex.X_add_number <= 0)
          generic_floating_point_number = lpe->floatnum;
        else
          memcpy(generic_bignum, lpe->bignum,
                 lpe->ex.X_add_number*sizeof(LITTLENUM_TYPE));
     }
     emit_expr (&lpe->ex, lpe->nbytes);
   }
d1462 3
a1464 3
    lpe->next = lpe_free_list;
    lpe_free_list = lpe;
  }
d1606 1
d1634 7
a1640 6
  if (fixp->fx_subsy != NULL) {
    if (!S_IS_DEFINED (fixp->fx_subsy))
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("unresolved fx_subsy symbol that must be resolved"));
    value -= S_GET_VALUE(fixp->fx_subsy);
  }
d1642 14
a1655 12
  if (fixp->fx_addsy != NULL) {
    /* `*valuep' may contain the value of the symbol on which the reloc
       will be based; we have to remove it.  */
    if (fixp->fx_addsy->sy_used_in_reloc
	&& S_GET_SEGMENT (fixp->fx_addsy) != absolute_section
	&& S_GET_SEGMENT (fixp->fx_addsy) != undefined_section
	&& ! bfd_is_com_section (S_GET_SEGMENT (fixp->fx_addsy)))
      value -= S_GET_VALUE (fixp->fx_addsy);

    if (fixp->fx_pcrel)
      value += fixp->fx_frag->fr_address + fixp->fx_where;
  } else {
a1656 1
  }
d1658 4
a1661 6
  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED) {
    const struct s390_operand *operand;
    int opindex;
    
    opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
    operand = &s390_operands[opindex];
d1663 2
a1664 40
    if (fixp->fx_done) {
      /* Insert the fully resolved operand value.  */
      s390_insert_operand (where, operand, (offsetT) value,
			   fixp->fx_file, fixp->fx_line);
      return 1;
    }
    
    /* Determine a BFD reloc value based on the operand information.
       We are only prepared to turn a few of the operands into
       relocs.  */
    fixp->fx_offset = value;
    if (operand->bits == 12 && operand->shift == 20) {
      fixp->fx_size = 2;
      fixp->fx_where += 2;
      fixp->fx_r_type = BFD_RELOC_390_12;
    } else if (operand->bits == 12 && operand->shift == 36) {
      fixp->fx_size = 2;
      fixp->fx_where += 4;
      fixp->fx_r_type = BFD_RELOC_390_12;
    } else if (operand->bits == 8 && operand->shift == 8) {
      fixp->fx_size = 1;
      fixp->fx_where += 1;
      fixp->fx_r_type = BFD_RELOC_8;
    } else if (operand->bits == 16 && operand->shift == 16) {
      fixp->fx_size = 2;
      fixp->fx_where += 2;
      if (operand->flags & S390_OPERAND_PCREL) {
        fixp->fx_r_type = BFD_RELOC_390_PC16DBL;
        fixp->fx_offset += 2;
      } else
	fixp->fx_r_type = BFD_RELOC_16;
    } else if (operand->bits == 32 && operand->shift == 16 &&
              (operand->flags & S390_OPERAND_PCREL)) {
      fixp->fx_size = 4;
      fixp->fx_where += 2;
      fixp->fx_offset += 2;
      fixp->fx_r_type = BFD_RELOC_390_PC32DBL;
    } else {
      char *sfile;
      unsigned int sline;
a1665 16
      /* Use expr_symbol_where to see if this is an expression
	 symbol.  */
      if (expr_symbol_where (fixp->fx_addsy, &sfile, &sline))
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("unresolved expression that must be resolved"));
      else
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("unsupported relocation type"));
      fixp->fx_done = 1;
      return 1;
    }
  } else {
    switch (fixp->fx_r_type) {
    case BFD_RELOC_8:
      if (fixp->fx_pcrel)
        abort ();
d1667 7
a1673 11
        md_number_to_chars (where, value, 1);
      break;
    case BFD_RELOC_390_12:
    case BFD_RELOC_390_GOT12:
      if (fixp->fx_done) {
        unsigned short mop;
        mop = bfd_getb16 ((unsigned char *) where);
        mop |= (unsigned short) (value & 0xfff);
        bfd_putb16 ((bfd_vma) mop, (unsigned char *) where);
      } 
      break;
d1675 42
a1716 29
    case BFD_RELOC_16:
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_16_GOT_PCREL:
    case BFD_RELOC_16_GOTOFF:
      if (fixp->fx_pcrel)
        as_bad_where (fixp->fx_file, fixp->fx_line,
                      "cannot emit PC relative %s relocation%s%s",
                      bfd_get_reloc_code_name (fixp->fx_r_type),
                      fixp->fx_addsy != NULL ? " against " : "",
                      (fixp->fx_addsy != NULL
                       ? S_GET_NAME (fixp->fx_addsy)
                       : ""));
      if (fixp->fx_done)
        md_number_to_chars (where, value, 2);
      break;
    case BFD_RELOC_390_GOT16:
      if (fixp->fx_done)
        md_number_to_chars (where, value, 2);
      break;
    case BFD_RELOC_390_PC16DBL:
    case BFD_RELOC_390_PLT16DBL:
      value += 2;
      if (fixp->fx_done)
        md_number_to_chars (where, (offsetT) value >> 1, 2);
      break;

    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
	fixp->fx_r_type = BFD_RELOC_32_PCREL;
d1718 135
a1852 43
	fixp->fx_r_type = BFD_RELOC_32;
      if (fixp->fx_done)
        md_number_to_chars (where, value, 4);
      break;
    case BFD_RELOC_32_PCREL:
    case BFD_RELOC_32_BASEREL:
      fixp->fx_r_type = BFD_RELOC_32_PCREL;
      if (fixp->fx_done)
        md_number_to_chars (where, value, 4);
      break;
    case BFD_RELOC_32_GOT_PCREL:
    case BFD_RELOC_390_PLT32:
      if (fixp->fx_done)
        md_number_to_chars (where, value, 4);
      break;
    case BFD_RELOC_390_PC32DBL:
    case BFD_RELOC_390_PLT32DBL:
    case BFD_RELOC_390_GOTPCDBL:
    case BFD_RELOC_390_GOTENT:
      value += 2;
      if (fixp->fx_done)
        md_number_to_chars (where, (offsetT) value >> 1, 4);
      break;

    case BFD_RELOC_32_GOTOFF:
      if (fixp->fx_done)
        md_number_to_chars (where, value, sizeof(int));
      break;

    case BFD_RELOC_390_GOT64:
    case BFD_RELOC_390_PLT64:
      if (fixp->fx_done)
        md_number_to_chars (where, value, 8);
      break;

    case BFD_RELOC_64:
      if (fixp->fx_pcrel)
        fixp->fx_r_type = BFD_RELOC_64_PCREL;
      else
        fixp->fx_r_type = BFD_RELOC_64;
      if (fixp->fx_done)
        md_number_to_chars (where, value, 8);
      break;
d1854 1
a1854 20
    case BFD_RELOC_64_PCREL:
      fixp->fx_r_type = BFD_RELOC_64_PCREL;
      if (fixp->fx_done)
        md_number_to_chars (where, value, 8);
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixp->fx_done = 0;
      return 1;

    default: {
	const char *reloc_name = bfd_get_reloc_code_name(fixp->fx_r_type);
	if (reloc_name != NULL)
	  fprintf(stderr, "Gas failure, reloc type %s\n", reloc_name);
	else
	  fprintf(stderr, "Gas failure, reloc type #%i\n", fixp->fx_r_type);
	fflush(stderr);
	abort ();
      }
a1856 3
    fixp->fx_offset = value;
  }

d1871 8
a1878 7
  if (GOT_symbol && fixp->fx_addsy == GOT_symbol) {
    if ((s390_arch_size == 32 && code == BFD_RELOC_32_PCREL) ||
        (s390_arch_size == 64 && code == BFD_RELOC_64_PCREL))
      code = BFD_RELOC_390_GOTPC;
    if (code == BFD_RELOC_390_PC32DBL)
      code = BFD_RELOC_390_GOTPCDBL;
  }
d1897 11
@


1.1
log
@Add s390 support
@
text
@d2 1
a2 1
   Copyright (C) 2000 Free Software Foundation, Inc.
@

