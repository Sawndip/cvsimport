head	1.21;
access;
symbols
	binutils-2_24-branch:1.21.0.12
	binutils-2_24-branchpoint:1.21
	binutils-2_21_1:1.21
	binutils-2_23_2:1.21
	binutils-2_23_1:1.21
	binutils-2_23:1.21
	binutils-2_23-branch:1.21.0.10
	binutils-2_23-branchpoint:1.21
	binutils-2_22_branch:1.21.0.8
	binutils-2_22:1.21
	binutils-2_22-branch:1.21.0.6
	binutils-2_22-branchpoint:1.21
	binutils-2_21:1.21
	binutils-2_21-branch:1.21.0.4
	binutils-2_21-branchpoint:1.21
	binutils-2_20_1:1.21
	binutils-2_20:1.21
	binutils-arc-20081103-branch:1.20.0.8
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.21.0.2
	binutils-2_20-branchpoint:1.21
	dje-cgen-play1-branch:1.20.0.6
	dje-cgen-play1-branchpoint:1.20
	arc-20081103-branch:1.20.0.4
	arc-20081103-branchpoint:1.20
	binutils-2_19_1:1.20
	binutils-2_19:1.20
	binutils-2_19-branch:1.20.0.2
	binutils-2_19-branchpoint:1.20
	binutils-2_18:1.19
	binutils-2_18-branch:1.19.0.2
	binutils-2_18-branchpoint:1.19
	binutils-csl-coldfire-4_1-32:1.17
	binutils-csl-sourcerygxx-4_1-32:1.17
	binutils-csl-innovasic-fido-3_4_4-33:1.17
	binutils-csl-sourcerygxx-3_4_4-32:1.15
	binutils-csl-coldfire-4_1-30:1.17
	binutils-csl-sourcerygxx-4_1-30:1.17
	binutils-csl-coldfire-4_1-28:1.17
	binutils-csl-sourcerygxx-4_1-29:1.17
	binutils-csl-sourcerygxx-4_1-28:1.17
	binutils-csl-arm-2006q3-27:1.17
	binutils-csl-sourcerygxx-4_1-27:1.17
	binutils-csl-arm-2006q3-26:1.17
	binutils-csl-sourcerygxx-4_1-26:1.17
	binutils-csl-sourcerygxx-4_1-25:1.17
	binutils-csl-sourcerygxx-4_1-24:1.17
	binutils-csl-sourcerygxx-4_1-23:1.17
	binutils-csl-sourcerygxx-4_1-21:1.17
	binutils-csl-arm-2006q3-21:1.17
	binutils-csl-sourcerygxx-4_1-22:1.17
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.17
	binutils-csl-sourcerygxx-4_1-20:1.17
	binutils-csl-arm-2006q3-19:1.17
	binutils-csl-sourcerygxx-4_1-19:1.17
	binutils-csl-sourcerygxx-4_1-18:1.17
	binutils-csl-renesas-4_1-9:1.17
	binutils-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-renesas-4_1-8:1.17
	binutils-csl-renesas-4_1-7:1.17
	binutils-csl-renesas-4_1-6:1.17
	binutils-csl-sourcerygxx-4_1-17:1.17
	binutils-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-15:1.17
	binutils-csl-sourcerygxx-4_1-13:1.17
	binutils-2_17:1.17
	binutils-csl-sourcerygxx-4_1-12:1.17
	binutils-csl-sourcerygxx-3_4_4-21:1.17
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	binutils-csl-sourcerygxx-4_1-9:1.17
	binutils-csl-sourcerygxx-4_1-8:1.17
	binutils-csl-sourcerygxx-4_1-7:1.17
	binutils-csl-arm-2006q1-6:1.17
	binutils-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-wrs-linux-3_4_4-22:1.15
	binutils-csl-coldfire-4_1-11:1.17
	binutils-csl-sourcerygxx-3_4_4-19:1.17
	binutils-csl-coldfire-4_1-10:1.17
	binutils-csl-sourcerygxx-4_1-5:1.17
	binutils-csl-sourcerygxx-4_1-4:1.17
	binutils-csl-wrs-linux-3_4_4-21:1.15
	binutils-csl-morpho-4_1-4:1.17
	binutils-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-wrs-linux-3_4_4-20:1.15
	binutils-2_17-branch:1.17.0.4
	binutils-2_17-branchpoint:1.17
	binutils-csl-2_17-branch:1.17.0.2
	binutils-csl-2_17-branchpoint:1.17
	binutils-csl-gxxpro-3_4-branch:1.15.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	binutils-csl-arm-2005q1a:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	csl-arm-2003-q4:1.13
	binutils-2_14:1.12
	binutils-2_14-branch:1.12.0.2
	binutils-2_14-branchpoint:1.12
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	binutils-2_13_1:1.8
	binutils-2_13:1.8
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.4
	binutils-2_12_1:1.8
	binutils-2_12:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	cygnus_cvs_20020108_pre:1.8
	binutils-2_11_2:1.3.2.2
	binutils-2_11_1:1.3.2.2
	binutils-2_11:1.3
	x86_64versiong3:1.4
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.21
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.05.09.12.55;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.24.20.40.26;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.03.11.47.49;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.31.23.18.27;	author bje;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.10.22.08.45;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.12.22.39.40;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.19.05.33.22;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.23.13.03.39;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.10.11.32.51;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.13.21.27.52;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.26.07.09.18;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.06.22.14.52.54;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2001.05.23.03.41.10;	author amodra;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.06.11.10.04.47;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.21
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@/* tc-fr30.c -- Assembler for the Fujitsu FR30.
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2009
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "symcat.h"
#include "opcodes/fr30-desc.h"
#include "opcodes/fr30-opc.h"
#include "cgen.h"

/* Structure to hold all of the different components describing
   an individual instruction.  */
typedef struct
{
  const CGEN_INSN *	insn;
  const CGEN_INSN *	orig_insn;
  CGEN_FIELDS		fields;
#if CGEN_INT_INSN_P
  CGEN_INSN_INT         buffer [1];
#define INSN_VALUE(buf) (*(buf))
#else
  unsigned char         buffer [CGEN_MAX_INSN_SIZE];
#define INSN_VALUE(buf) (buf)
#endif
  char *		addr;
  fragS *		frag;
  int                   num_fixups;
  fixS *                fixups [GAS_CGEN_MAX_FIXUPS];
  int                   indices [MAX_OPERAND_INSTANCES];
}
fr30_insn;

const char comment_chars[]        = ";";
const char line_comment_chars[]   = "#";
const char line_separator_chars[] = "|";
const char EXP_CHARS[]            = "eE";
const char FLT_CHARS[]            = "dD";

#define FR30_SHORTOPTS ""
const char * md_shortopts = FR30_SHORTOPTS;

struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c ATTRIBUTE_UNUSED,
		 char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    default:
      return 0;
    }
  return 1;
}

void
md_show_usage (FILE * stream)
{
  fprintf (stream, _(" FR30 specific command line options:\n"));
}

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "word",	cons,		4 },
  { NULL, 	NULL, 		0 }
};


void
md_begin (void)
{
  /* Initialize the `cgen' interface.  */

  /* Set the machine number and endian.  */
  gas_cgen_cpu_desc = fr30_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, 0,
					  CGEN_CPU_OPEN_ENDIAN,
					  CGEN_ENDIAN_BIG,
					  CGEN_CPU_OPEN_END);
  fr30_cgen_init_asm (gas_cgen_cpu_desc);

  /* This is a callback from cgen to gas to parse operands.  */
  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);
}

void
md_assemble (char *str)
{
  static int last_insn_had_delay_slot = 0;
  fr30_insn insn;
  char *errmsg;

  /* Initialize GAS's cgen interface for a new instruction.  */
  gas_cgen_init_parse ();

  insn.insn = fr30_cgen_assemble_insn
    (gas_cgen_cpu_desc, str, & insn.fields, insn.buffer, & errmsg);

  if (!insn.insn)
    {
      as_bad ("%s", errmsg);
      return;
    }

  /* Doesn't really matter what we pass for RELAX_P here.  */
  gas_cgen_finish_insn (insn.insn, insn.buffer,
			CGEN_FIELDS_BITSIZE (& insn.fields), 1, NULL);

  /* Warn about invalid insns in delay slots.  */
  if (last_insn_had_delay_slot
      && CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_NOT_IN_DELAY_SLOT))
    as_warn (_("Instruction %s not allowed in a delay slot."),
	     CGEN_INSN_NAME (insn.insn));

  last_insn_had_delay_slot
    = CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_DELAY_SLOT);
}

/* The syntax in the manual says constants begin with '#'.
   We just ignore it.  */

void
md_operand (expressionS * expressionP)
{
  if (* input_line_pointer == '#')
    {
      input_line_pointer ++;
      expression (expressionP);
    }
}

valueT
md_section_align (segT segment, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);

  return ((size + (1 << align) - 1) & (-1 << align));
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}

/* Interface to relax_segment.  */

/* FIXME: Build table by hand, get it working, then machine generate.  */

const relax_typeS md_relax_table[] =
{
/* The fields are:
   1) most positive reach of this state,
   2) most negative reach of this state,
   3) how many bytes this mode will add to the size of the current frag
   4) which index into the table to try if we can't fit into this one.  */

  /* The first entry must be unused because an `rlx_more' value of zero ends
     each list.  */
  {1, 1, 0, 0},

  /* The displacement used by GAS is from the end of the 2 byte insn,
     so we subtract 2 from the following.  */
  /* 16 bit insn, 8 bit disp -> 10 bit range.
     This doesn't handle a branch in the right slot at the border:
     the "& -4" isn't taken into account.  It's not important enough to
     complicate things over it, so we subtract an extra 2 (or + 2 in -ve
     case).  */
  {511 - 2 - 2, -512 - 2 + 2, 0, 2 },
  /* 32 bit insn, 24 bit disp -> 26 bit range.  */
  {0x2000000 - 1 - 2, -0x2000000 - 2, 2, 0 },
  /* Same thing, but with leading nop for alignment.  */
  {0x2000000 - 1 - 2, -0x2000000 - 2, 4, 0 }
};

/* Return an initial guess of the length by which a fragment must grow to
   hold a branch to reach its destination.
   Also updates fr_type/fr_subtype as necessary.

   Called just before doing relaxation.
   Any symbol that is now undefined will not become defined.
   The guess for fr_var is ACTUALLY the growth beyond fr_fix.
   Whatever we do to grow fr_fix or fr_var contributes to our returned value.
   Although it may not be explicit in the frag, pretend fr_var starts with a
   0 value.  */

int
md_estimate_size_before_relax (fragS * fragP, segT segment)
{
  /* The only thing we have to handle here are symbols outside of the
     current segment.  They may be undefined or in a different segment in
     which case linker scripts may place them anywhere.
     However, we can't finish the fragment here and emit the reloc as insn
     alignment requirements may move the insn about.  */

  if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
    {
      /* The symbol is undefined in this segment.
	 Change the relaxation subtype to the max allowable and leave
	 all further handling to md_convert_frag.  */
      fragP->fr_subtype = 2;

      {
	const CGEN_INSN * insn;
	int               i;

	/* Update the recorded insn.
	   Fortunately we don't have to look very far.
	   FIXME: Change this to record in the instruction the next higher
	   relaxable insn to use.  */
	for (i = 0, insn = fragP->fr_cgen.insn; i < 4; i++, insn++)
	  {
	    if ((strcmp (CGEN_INSN_MNEMONIC (insn),
			 CGEN_INSN_MNEMONIC (fragP->fr_cgen.insn))
		 == 0)
		&& CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED))
	      break;
	  }
	if (i == 4)
	  abort ();

	fragP->fr_cgen.insn = insn;
	return 2;
      }
    }

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* *fragP has been relaxed to its final size, and now needs to have
   the bytes inside it modified to conform to the new size.

   Called after relaxation is finished.
   fragP->fr_type == rs_machine_dependent.
   fragP->fr_subtype is the subtype of what the address relaxed to.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
}

/* Functions concerning relocs.  */

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from_section (fixS * fixP, segT sec)
{
  if (fixP->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixP->fx_addsy)
	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
    /* The symbol is undefined (or is defined but not in this section).
       Let the linker figure it out.  */
    return 0;

  return (fixP->fx_frag->fr_address + fixP->fx_where) & ~1;
}

/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
   Returns BFD_RELOC_NONE if no reloc type can be found.
   *FIXP may be modified if desired.  */

bfd_reloc_code_real_type
md_cgen_lookup_reloc (const CGEN_INSN *insn ATTRIBUTE_UNUSED,
		      const CGEN_OPERAND *operand,
		      fixS *fixP)
{
  switch (operand->type)
    {
    case FR30_OPERAND_LABEL9:  fixP->fx_pcrel = 1; return BFD_RELOC_FR30_9_PCREL;
    case FR30_OPERAND_LABEL12: fixP->fx_pcrel = 1; return BFD_RELOC_FR30_12_PCREL;
    case FR30_OPERAND_DISP10:  return BFD_RELOC_FR30_10_IN_8;
    case FR30_OPERAND_DISP9:   return BFD_RELOC_FR30_9_IN_8;
    case FR30_OPERAND_DISP8:   return BFD_RELOC_FR30_8_IN_8;
    case FR30_OPERAND_UDISP6:  return BFD_RELOC_FR30_6_IN_4;
    case FR30_OPERAND_I8:      return BFD_RELOC_8;
    case FR30_OPERAND_I32:     return BFD_RELOC_FR30_48;
    case FR30_OPERAND_I20:     return BFD_RELOC_FR30_20;
    default : /* Avoid -Wall warning.  */
      break;
    }

  return BFD_RELOC_NONE;
}

/* Write a value out to the object file, using the appropriate endianness.  */

void
md_number_to_chars (char * buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

char *
md_atof (int type, char * litP, int * sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

/* Worker function for fr30_is_colon_insn().  */
static char
restore_colon (int advance_i_l_p_by)
{
  char c;

  /* Restore the colon, and advance input_line_pointer to
     the end of the new symbol.  */
  * input_line_pointer = ':';
  input_line_pointer += advance_i_l_p_by;
  c = * input_line_pointer;
  * input_line_pointer = 0;

  return c;
}

/* Determines if the symbol starting at START and ending in
   a colon that was at the location pointed to by INPUT_LINE_POINTER
   (but which has now been replaced bu a NUL) is in fact an
   LDI:8, LDI:20, LDI:32, CALL:D. JMP:D, RET:D or Bcc:D instruction.
   If it is, then it restores the colon, advances INPUT_LINE_POINTER
   to the real end of the instruction/symbol, and returns the character
   that really terminated the symbol.  Otherwise it returns 0.  */
char
fr30_is_colon_insn (char *  start)
{
  char * i_l_p = input_line_pointer;

  /* Check to see if the symbol parsed so far is 'ldi'.  */
  if (   (start[0] != 'l' && start[0] != 'L')
      || (start[1] != 'd' && start[1] != 'D')
      || (start[2] != 'i' && start[2] != 'I')
      || start[3] != 0)
    {
      /* Nope - check to see a 'd' follows the colon.  */
      if (   (i_l_p[1] == 'd' || i_l_p[1] == 'D')
	  && (i_l_p[2] == ' ' || i_l_p[2] == '\t' || i_l_p[2] == '\n'))
	{
	  /* Yup - it might be delay slot instruction.  */
	  int           i;
	  static char * delay_insns [] =
	  {
	    "call", "jmp", "ret", "bra", "bno",
	    "beq",  "bne", "bc",  "bnc", "bn",
	    "bp",   "bv",  "bnv", "blt", "bge",
	    "ble",  "bgt", "bls", "bhi"
	  };

	  for (i = sizeof (delay_insns) / sizeof (delay_insns[0]); i--;)
	    {
	      char * insn = delay_insns[i];
	      int    len  = strlen (insn);

	      if (start [len] != 0)
		continue;

	      while (len --)
		if (TOLOWER (start [len]) != insn [len])
		  break;

	      if (len == -1)
		return restore_colon (1);
	    }
	}

      /* Nope - it is a normal label.  */
      return 0;
    }

  /* Check to see if the text following the colon is '8'.  */
  if (i_l_p[1] == '8' && (i_l_p[2] == ' ' || i_l_p[2] == '\t'))
    return restore_colon (2);

  /* Check to see if the text following the colon is '20'.  */
  else if (i_l_p[1] == '2' && i_l_p[2] =='0' && (i_l_p[3] == ' ' || i_l_p[3] == '\t'))
    return restore_colon (3);

  /* Check to see if the text following the colon is '32'.  */
  else if (i_l_p[1] == '3' && i_l_p[2] =='2' && (i_l_p[3] == ' ' || i_l_p[3] == '\t'))
    return restore_colon (3);

  return 0;
}

bfd_boolean
fr30_fix_adjustable (fixS * fixP)
{
  /* We need the symbol name for the VTABLE entries.  */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}
@


1.20
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
d124 1
a124 1
      as_bad (errmsg);
@


1.19
log
@Switch to GPLv3
@
text
@a320 8
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
*/

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

d324 1
a324 41
  int              i;
  int              prec;
  LITTLENUM_TYPE   words [MAX_LITTLENUMS];
  char *           t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

   /* FIXME: Some targets allow other format chars for bigger sizes here.  */

    default:
      * sizeP = 0;
      return _("Bad call to md_atof()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  * sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (i = 0; i < prec; i++)
    {
      md_number_to_chars (litP, (valueT) words[i],
			  sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
@


1.18
log
@remove some duplicate #include's.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.17
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2005
a21 1
#include <stdio.h>
@


1.16
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.15
log
@update copyright dates
@
text
@d69 2
a70 3
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d81 1
a81 2
md_show_usage (stream)
  FILE * stream;
d95 1
a95 1
md_begin ()
d111 1
a111 2
md_assemble (str)
     char *str;
d147 1
a147 2
md_operand (expressionP)
     expressionS * expressionP;
d157 1
a157 3
md_section_align (segment, size)
     segT   segment;
     valueT size;
d160 1
d165 1
a165 2
md_undefined_symbol (name)
  char *name ATTRIBUTE_UNUSED;
d167 1
a167 1
  return 0;
d212 1
a212 3
md_estimate_size_before_relax (fragP, segment)
     fragS * fragP;
     segT    segment;
d263 3
a265 4
md_convert_frag (abfd, sec, fragP)
  bfd *abfd ATTRIBUTE_UNUSED;
  segT sec ATTRIBUTE_UNUSED;
  fragS *fragP ATTRIBUTE_UNUSED;
d275 1
a275 3
md_pcrel_from_section (fixP, sec)
     fixS * fixP;
     segT   sec;
d280 3
a282 5
    {
      /* The symbol is undefined (or is defined but not in this section).
	 Let the linker figure it out.  */
      return 0;
    }
d292 3
a294 4
md_cgen_lookup_reloc (insn, operand, fixP)
     const CGEN_INSN *insn ATTRIBUTE_UNUSED;
     const CGEN_OPERAND *operand;
     fixS *fixP;
d307 1
a307 1
    default : /* avoid -Wall warning */
d317 1
a317 4
md_number_to_chars (buf, val, n)
     char * buf;
     valueT val;
     int    n;
d327 1
a327 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d331 1
a331 4
md_atof (type, litP, sizeP)
     char   type;
     char * litP;
     int *  sizeP;
a376 2
static char restore_colon PARAMS ((int));

d378 1
a378 2
restore_colon (advance_i_l_p_by)
     int advance_i_l_p_by;
d400 1
a400 2
fr30_is_colon_insn (start)
     char *  start;
d404 1
a404 1
  /* Check to see if the symbol parsed so far is 'ldi'  */
d445 1
a445 1
  /* Check to see if the text following the colon is '8' */
d449 1
a449 1
  /* Check to see if the text following the colon is '20' */
d453 1
a453 1
  /* Check to see if the text following the colon is '32' */
d461 1
a461 2
fr30_fix_adjustable (fixP)
   fixS * fixP;
d463 1
a463 1
  /* We need the symbol name for the VTABLE entries */
@


1.14
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003
@


1.13
log
@opcodes:
	* cgen-asm.in (@@arch@@_cgen_assemble_insn): CGEN_INSN_RELAX renamed to
	CGEN_INSN_RELAXED.
	* fr30-asm.c,fr30-desc.c,fr30-desc.h: Regenerate.
	* frv-asm.c,frv-desc.c,frv-desc.h: Regenerate.
	* ip2k-asm.c,ip2k-desc.c,ip2k-desc.h: Regenerate.
	* iq2000-asm.c,iq2000-desc.c,iq2000-desc.h: Regenerate.
	* m32r-asm.c,m32r-desc.c,m32r-desc.h,m32r-opc.c: Regenerate.
	* openrisc-asm.c,openrisc-desc.c,openrisc-desc.h: Regenerate.
	* xstormy16-asm.c,xstormy16-desc.c,xstormy16-desc.h: Regenerate.
gas:
	* cgen.c (gas_cgen_finish_insn): CGEN_INSN_RELAX renamed to
	CGEN_INSN_RELAXED.
	* config/tc-fr30.c (md_estimate_size_before_relax): Ditto.
	* config/tc-m32r.c (md_estimate_size_before_relax): Ditto.
	* config/tc-openrisc.c (md_estimate_size_before_relax): Ditto.
@
text
@a205 44
#if 0
long
fr30_relax_frag (segment, fragP, stretch)
     segT    segment;
     fragS * fragP;
     long    stretch;
{
  /* Address of branch insn.  */
  long address = fragP->fr_address + fragP->fr_fix - 2;
  long growth = 0;

  /* Keep 32 bit insns aligned on 32 bit boundaries.  */
  if (fragP->fr_subtype == 2)
    {
      if ((address & 3) != 0)
	{
	  fragP->fr_subtype = 3;
	  growth = 2;
	}
    }
  else if (fragP->fr_subtype == 3)
    {
      if ((address & 3) == 0)
	{
	  fragP->fr_subtype = 2;
	  growth = -2;
	}
    }
  else
    {
      growth = relax_frag (segment, fragP, stretch);

      /* Long jump on odd halfword boundary?  */
      if (fragP->fr_subtype == 2 && (address & 3) != 0)
	{
	  fragP->fr_subtype = 3;
	  growth += 2;
	}
    }

  return growth;
}
#endif

a229 4
#if 0
      int    old_fr_fix = fragP->fr_fix;
#endif

a234 19
#if 0 /* Can't use this, but leave in for illustration.  */
      /* Change 16 bit insn to 32 bit insn.  */
      fragP->fr_opcode[0] |= 0x80;

      /* Increase known (fixed) size of fragment.  */
      fragP->fr_fix += 2;

      /* Create a relocation for it.  */
      fix_new (fragP, old_fr_fix, 4,
	       fragP->fr_symbol,
	       fragP->fr_offset, 1 /* pcrel */,
	       /* FIXME: Can't use a real BFD reloc here.
		  gas_cgen_md_apply_fix3 can't handle it.  */
	       BFD_RELOC_FR30_26_PCREL);

      /* Mark this fragment as finished.  */
      frag_wane (fragP);
      return fragP->fr_fix - old_fr_fix;
#else
a256 1
#endif
a275 78
#if 0
  char * opcode;
  char * displacement;
  int    target_address;
  int    opcode_address;
  int    extension;
  int    addend;

  opcode = fragP->fr_opcode;

  /* Address opcode resides at in file space.  */
  opcode_address = fragP->fr_address + fragP->fr_fix - 2;

  switch (fragP->fr_subtype)
    {
    case 1 :
      extension = 0;
      displacement = & opcode[1];
      break;
    case 2 :
      opcode[0] |= 0x80;
      extension = 2;
      displacement = & opcode[1];
      break;
    case 3 :
      opcode[2] = opcode[0] | 0x80;
      md_number_to_chars (opcode, PAR_NOP_INSN, 2);
      opcode_address += 2;
      extension = 4;
      displacement = & opcode[3];
      break;
    default :
      abort ();
    }

  if (S_GET_SEGMENT (fragP->fr_symbol) != sec)
    {
      /* symbol must be resolved by linker */
      if (fragP->fr_offset & 3)
	as_warn (_("Addend to unresolved symbol not on word boundary."));
      addend = fragP->fr_offset >> 2;
    }
  else
    {
      /* Address we want to reach in file space.  */
      target_address = S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset;
      addend = (target_address - (opcode_address & -4)) >> 2;
    }

  /* Create a relocation for symbols that must be resolved by the linker.
     Otherwise output the completed insn.  */

  if (S_GET_SEGMENT (fragP->fr_symbol) != sec)
    {
      assert (fragP->fr_subtype != 1);
      assert (fragP->fr_cgen.insn != 0);
      gas_cgen_record_fixup (fragP,
			     /* Offset of branch insn in frag.  */
			     fragP->fr_fix + extension - 4,
			     fragP->fr_cgen.insn,
			     4 /*length*/,
			     /* FIXME: quick hack */
#if 0
			     CGEN_OPERAND_ENTRY (fragP->fr_cgen.opindex),
#else
			     CGEN_OPERAND_ENTRY (FR30_OPERAND_DISP24),
#endif
			     fragP->fr_cgen.opinfo,
			     fragP->fr_symbol, fragP->fr_offset);
    }

#define SIZE_FROM_RELAX_STATE(n) ((n) == 1 ? 1 : 3)

  md_number_to_chars (displacement, (valueT) addend,
		      SIZE_FROM_RELAX_STATE (fragP->fr_subtype));

  fragP->fr_fix += extension;
#endif
@


1.12
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d315 1
a315 1
		&& CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAX))
@


1.11
log
@	* config/tc-fr30.c (md_parse_option <c,arg>):  Add ATTRIBUTE_UNUSED.
	(md_undefined_symbol <name>): Likewise.
	(md_convert_frag <all args>): Likewise.
	(md_cgen_lookup_reloc <insn>): Likewise.
	(md_begin): Delete unused vars.
	(md_assemble): Likewise.
	(md_estimate_size_before_relax): Likewise.
	(fr30_relax_frag): #if 0 out, seems unused.
	(md_atof): Remove declaration of atof_ieee.
	(restore_colon): Prototype.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a471 15
}

/* See whether we need to force a relocation into the output file.
   This is used to force out switch and PC relative relocations when
   relaxing.  */

int
fr30_force_relocation (fix)
     fixS * fix;
{
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  return S_FORCE_RELOC (fix->fx_addsy);
@


1.10
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d69 2
a70 2
     int    c;
     char * arg;
a97 4
  flagword applicable;
  segT     seg;
  subsegT  subseg;

d113 1
a113 1
     char * str;
d117 1
a117 2
  char *    errmsg;
  char *    str2 = NULL;
d170 1
a170 1
  char * name;
d205 1
d247 1
d273 1
d275 1
d339 3
a341 3
  bfd *   abfd;
  segT    sec;
  fragS * fragP;
d451 3
a453 3
     const CGEN_INSN *    insn;
     const CGEN_OPERAND * operand;
     fixS *               fixP;
a516 1
  char *           atof_ieee ();
d557 2
@


1.9
log
@gas reloc rewrite.
@
text
@d644 1
a644 1
boolean
@


1.8
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d482 1
a482 1
  if (   fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d486 1
a486 1
  return 0;
a647 12
  if (fixP->fx_addsy == NULL)
    return 1;

#if 0
  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;

  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;
#endif

d649 1
a649 1
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
@


1.7
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@a21 1
#include <ctype.h>
d23 1
d617 1
a617 1
		if (tolower (start [len]) != insn [len])
@


1.6
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@a389 1
      target_address += symbol_get_frag (fragP->fr_symbol)->fr_address;
@


1.5
log
@Fix copyright notices
@
text
@a267 2
  int    old_fr_fix = fragP->fr_fix;

d276 2
d300 1
d327 2
a328 1
  return (fragP->fr_var + fragP->fr_fix - old_fr_fix);
@


1.4
log
@	* write.c (is_dnrange): Stop as soon as the address becomes
	larger.
	(relax_frag): Add segment parameter.  Only call symbol_get_frag
	once.  Only call is_dnrange if the symbol is in the same segment,
	and the symbol address is larger.
	(relax_segment): Pass segment to md_relax_frag and relax_frag.
	* write.h (relax_frag): Update declaration.
	* config/tc-fr30.c (fr30_relax_frag): Add segment parameter.  Pass
	it to relax_frag.
	* config/tc-m32r.c (m32r_relax_frag): Likewise.
	* config/tc-m32r.h (md_relax_frag): Add segment parameter.
	(m32r_relax_frag): Update declaration.
	* config/tc-mips.h (md_relax_frag): Add segment parameter.
	* config/tc-tic54x.h (md_relax_frag): Likewise.
	* doc/internals.texi (CPU backend): Update documentation for
	md_relax_frag.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000 Free Software Foundation.
@


1.3
log
@2000-09-25  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-cris.c: Fix formatting.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.h: Likewise.
@
text
@d211 2
a212 1
fr30_relax_frag (fragP, stretch)
d239 1
a239 1
      growth = relax_frag (fragP, stretch);
@


1.3.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d211 1
a211 2
fr30_relax_frag (segment, fragP, stretch)
     segT    segment;
d238 1
a238 1
      growth = relax_frag (segment, fragP, stretch);
@


1.3.2.2
log
@Merge from mainline.
@
text
@d268 2
a277 2
      int    old_fr_fix = fragP->fr_fix;

a299 1
      return fragP->fr_fix - old_fr_fix;
d326 1
a326 2
  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
@


1.2
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation.
d24 1
a24 1
#include "subsegs.h"     
d85 1
a85 1
} 
d103 1
a103 1
  
d129 1
a129 1
  
d153 1
a153 1
void 
d282 1
a282 1
#if 0 /* Can't use this, but leave in for illustration.  */     
d326 1
a326 1
} 
d552 1
a552 1
     
d562 1
a562 1
  
d569 1
a569 1
  
d613 1
a613 1
	      
d617 1
a617 1
	      
d648 3
a650 3
  
#if 0  
  /* Prevent all adjustments to global symbols. */
d653 1
a653 1
  
d657 1
a657 1
  
@


1.1
log
@Initial revision
@
text
@d387 1
a387 1
      target_address += fragP->fr_symbol->sy_frag->fr_address;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

