head	1.43;
access;
symbols
	binutils-2_24-branch:1.43.0.10
	binutils-2_24-branchpoint:1.43
	binutils-2_21_1:1.43
	binutils-2_23_2:1.43
	binutils-2_23_1:1.43
	binutils-2_23:1.43
	binutils-2_23-branch:1.43.0.8
	binutils-2_23-branchpoint:1.43
	binutils-2_22_branch:1.43.0.6
	binutils-2_22:1.43
	binutils-2_22-branch:1.43.0.4
	binutils-2_22-branchpoint:1.43
	binutils-2_21:1.43
	binutils-2_21-branch:1.43.0.2
	binutils-2_21-branchpoint:1.43
	binutils-2_20_1:1.41.2.1
	binutils-2_20:1.41.2.1
	binutils-arc-20081103-branch:1.37.0.6
	binutils-arc-20081103-branchpoint:1.37
	binutils-2_20-branch:1.41.0.2
	binutils-2_20-branchpoint:1.41
	dje-cgen-play1-branch:1.40.0.2
	dje-cgen-play1-branchpoint:1.40
	arc-20081103-branch:1.37.0.4
	arc-20081103-branchpoint:1.37
	binutils-2_19_1:1.37
	binutils-2_19:1.37
	binutils-2_19-branch:1.37.0.2
	binutils-2_19-branchpoint:1.37
	binutils-2_18:1.35
	binutils-2_18-branch:1.35.0.2
	binutils-2_18-branchpoint:1.35
	binutils-csl-coldfire-4_1-32:1.32
	binutils-csl-sourcerygxx-4_1-32:1.32
	binutils-csl-innovasic-fido-3_4_4-33:1.32
	binutils-csl-sourcerygxx-3_4_4-32:1.22
	binutils-csl-coldfire-4_1-30:1.32
	binutils-csl-sourcerygxx-4_1-30:1.32
	binutils-csl-coldfire-4_1-28:1.32
	binutils-csl-sourcerygxx-4_1-29:1.32
	binutils-csl-sourcerygxx-4_1-28:1.32
	binutils-csl-arm-2006q3-27:1.32
	binutils-csl-sourcerygxx-4_1-27:1.32
	binutils-csl-arm-2006q3-26:1.32
	binutils-csl-sourcerygxx-4_1-26:1.32
	binutils-csl-sourcerygxx-4_1-25:1.32
	binutils-csl-sourcerygxx-4_1-24:1.32
	binutils-csl-sourcerygxx-4_1-23:1.32
	binutils-csl-sourcerygxx-4_1-21:1.32
	binutils-csl-arm-2006q3-21:1.32
	binutils-csl-sourcerygxx-4_1-22:1.32
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.32
	binutils-csl-sourcerygxx-4_1-20:1.32
	binutils-csl-arm-2006q3-19:1.32
	binutils-csl-sourcerygxx-4_1-19:1.32
	binutils-csl-sourcerygxx-4_1-18:1.32
	binutils-csl-renesas-4_1-9:1.32
	binutils-csl-sourcerygxx-3_4_4-25:1.22
	binutils-csl-renesas-4_1-8:1.32
	binutils-csl-renesas-4_1-7:1.32
	binutils-csl-renesas-4_1-6:1.32
	binutils-csl-sourcerygxx-4_1-17:1.32
	binutils-csl-sourcerygxx-4_1-14:1.32
	binutils-csl-sourcerygxx-4_1-15:1.32
	binutils-csl-sourcerygxx-4_1-13:1.32
	binutils-2_17:1.32
	binutils-csl-sourcerygxx-4_1-12:1.32
	binutils-csl-sourcerygxx-3_4_4-21:1.32
	binutils-csl-wrs-linux-3_4_4-24:1.22
	binutils-csl-wrs-linux-3_4_4-23:1.22
	binutils-csl-sourcerygxx-4_1-9:1.32
	binutils-csl-sourcerygxx-4_1-8:1.32
	binutils-csl-sourcerygxx-4_1-7:1.32
	binutils-csl-arm-2006q1-6:1.32
	binutils-csl-sourcerygxx-4_1-6:1.32
	binutils-csl-wrs-linux-3_4_4-22:1.22
	binutils-csl-coldfire-4_1-11:1.32
	binutils-csl-sourcerygxx-3_4_4-19:1.32
	binutils-csl-coldfire-4_1-10:1.32
	binutils-csl-sourcerygxx-4_1-5:1.32
	binutils-csl-sourcerygxx-4_1-4:1.32
	binutils-csl-wrs-linux-3_4_4-21:1.22
	binutils-csl-morpho-4_1-4:1.32
	binutils-csl-sourcerygxx-3_4_4-17:1.32
	binutils-csl-wrs-linux-3_4_4-20:1.22
	binutils-2_17-branch:1.32.0.4
	binutils-2_17-branchpoint:1.32
	binutils-csl-2_17-branch:1.32.0.2
	binutils-csl-2_17-branchpoint:1.32
	binutils-csl-gxxpro-3_4-branch:1.22.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.22
	binutils-2_16_1:1.22
	binutils-csl-arm-2005q1b:1.22
	binutils-2_16:1.22
	binutils-csl-arm-2005q1a:1.22
	binutils-csl-arm-2005q1-branch:1.22.0.4
	binutils-csl-arm-2005q1-branchpoint:1.22
	binutils-2_16-branch:1.22.0.2
	binutils-2_16-branchpoint:1.22
	csl-arm-2004-q3d:1.20
	csl-arm-2004-q3:1.19
	binutils-2_15:1.19
	binutils-2_15-branchpoint:1.19
	csl-arm-2004-q1a:1.19
	csl-arm-2004-q1:1.19
	binutils-2_15-branch:1.19.0.6
	cagney_bfdfile-20040213-branch:1.19.0.4
	cagney_bfdfile-20040213-branchpoint:1.19
	cagney_bigcore-20040122-branch:1.19.0.2
	cagney_bigcore-20040122-branchpoint:1.19
	csl-arm-2003-q4:1.19
	binutils-2_14:1.16
	binutils-2_14-branch:1.16.0.2
	binutils-2_14-branchpoint:1.16
	binutils-2_13_2_1:1.15
	binutils-2_13_2:1.15
	binutils-2_13_1:1.15
	binutils-2_13:1.15
	binutils-2_13-branchpoint:1.15
	binutils-2_13-branch:1.15.0.2
	binutils-2_12_1:1.13
	binutils-2_12:1.13
	binutils-2_12-branch:1.13.0.2
	binutils-2_12-branchpoint:1.13
	cygnus_cvs_20020108_pre:1.13
	binutils-2_11_2:1.9.2.2
	binutils-2_11_1:1.9.2.2
	binutils-2_11:1.9
	x86_64versiong3:1.9
	binutils-2_11-branch:1.9.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.43
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.08.10.36.39;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.16.01.52.13;	author macro;	state Exp;
branches;
next	1.38;

1.38
date	2009.04.02.00.10.46;	author matt;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.12.23.39.31;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.06.16.36.48;	author matt;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.18.11.23.38;	author jbglaw;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.18.11.06.47;	author jbglaw;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.22.15.46.55;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.22.15.39.11;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.05.10.57.06;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.05.09.13.04;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.29.00.22.29;	author bje;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.01.14.17.16;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.23.12.28.06;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.17.13.46.05;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.03.01.54.25;	author hp;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.03.15.07.16;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.22.15.32.28;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.26.23.02.34;	author thorpej;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.28.20.01.43;	author thorpej;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.00.45.42;	author thorpej;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.08.07.37.16;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.15.21.28.59;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.19.05.33.30;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.10.11.32.52;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.12.03.06.49.23;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.19.23.10.01;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.07.20.28.45;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.25.18.40.16;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.25.17.59.21;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.09.00.00.04;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.46;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.41.2.1
date	2009.09.08.10.53.21;	author amodra;	state Exp;
branches;
next	;

1.9.2.1
date	2001.06.07.03.15.34;	author amodra;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.06.11.10.04.51;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.43
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@/* tc-vax.c - vax-specific -
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"

#include "vax-inst.h"
#include "obstack.h"		/* For FRAG_APPEND_1_CHAR macro in "frags.h" */
#include "subsegs.h"
#include "safe-ctype.h"

#ifdef OBJ_ELF
#include "elf/vax.h"
#endif

/* These chars start a comment anywhere in a source file (except inside
   another comment */
const char comment_chars[] = "#";

/* These chars only start a comment at the beginning of a line.  */
/* Note that for the VAX the are the same as comment_chars above.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
   as in 0f123.456
   or    0H1.234E-12 (see exp chars above).  */
const char FLT_CHARS[] = "dDfFgGhH";

/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c .  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.  */

/* Hold details of an operand expression.  */
static expressionS exp_of_operand[VIT_MAX_OPERANDS];
static segT seg_of_operand[VIT_MAX_OPERANDS];

/* A vax instruction after decoding.  */
static struct vit v;

/* Hold details of big operands.  */
LITTLENUM_TYPE big_operand_bits[VIT_MAX_OPERANDS][SIZE_OF_LARGE_NUMBER];
FLONUM_TYPE float_operand[VIT_MAX_OPERANDS];
/* Above is made to point into big_operand_bits by md_begin().  */

#ifdef OBJ_ELF
#define GLOBAL_OFFSET_TABLE_NAME	"_GLOBAL_OFFSET_TABLE_"
#define PROCEDURE_LINKAGE_TABLE_NAME	"_PROCEDURE_LINKAGE_TABLE_"
symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
symbolS *PLT_symbol;		/* Pre-defined "_PROCEDURE_LINKAGE_TABLE_".  */
#endif

int flag_hash_long_names;	/* -+ */
int flag_one;			/* -1 */
int flag_show_after_trunc;	/* -H */
int flag_no_hash_mixed_case;	/* -h NUM */
#ifdef OBJ_ELF
int flag_want_pic;		/* -k */
#endif

/* For VAX, relative addresses of "just the right length" are easy.
   The branch displacement is always the last operand, even in
   synthetic instructions.
   For VAX, we encode the relax_substateTs (in e.g. fr_substate) as:

  		    4       3       2       1       0	     bit number
  	---/ /--+-------+-------+-------+-------+-------+
  		|     what state ?	|  how long ?	|
  	---/ /--+-------+-------+-------+-------+-------+

   The "how long" bits are 00=byte, 01=word, 10=long.
   This is a Un*x convention.
   Not all lengths are legit for a given value of (what state).
   The "how long" refers merely to the displacement length.
   The address usually has some constant bytes in it as well.

 groups for VAX address relaxing.

 1.	"foo" pc-relative.
 length of byte, word, long

 2a.	J<cond> where <cond> is a simple flag test.
 length of byte, word, long.
 VAX opcodes are:	(Hex)
 bneq/bnequ	12
 beql/beqlu	13
 bgtr		14
 bleq		15
 bgeq		18
 blss		19
 bgtru		1a
 blequ		1b
 bvc		1c
 bvs		1d
 bgequ/bcc	1e
 blssu/bcs	1f
 Always, you complement 0th bit to reverse condition.
 Always, 1-byte opcode, then 1-byte displacement.

 2b.	J<cond> where cond tests a memory bit.
 length of byte, word, long.
 Vax opcodes are:	(Hex)
 bbs		e0
 bbc		e1
 bbss		e2
 bbcs		e3
 bbsc		e4
 bbcc		e5
 Always, you complement 0th bit to reverse condition.
 Always, 1-byte opcde, longword-address, byte-address, 1-byte-displacement

 2c.	J<cond> where cond tests low-order memory bit
 length of byte,word,long.
 Vax opcodes are:	(Hex)
 blbs		e8
 blbc		e9
 Always, you complement 0th bit to reverse condition.
 Always, 1-byte opcode, longword-address, 1-byte displacement.

 3.	Jbs/Jbr.
 length of byte,word,long.
 Vax opcodes are:	(Hex)
 bsbb		10
 brb		11
 These are like (2) but there is no condition to reverse.
 Always, 1 byte opcode, then displacement/absolute.

 4a.	JacbX
 length of word, long.
 Vax opcodes are:	(Hex)
 acbw		3d
 acbf		4f
 acbd		6f
 abcb		9d
 acbl		f1
 acbg	      4ffd
 acbh	      6ffd
 Always, we cannot reverse the sense of the branch; we have a word
 displacement.
 The double-byte op-codes don't hurt: we never want to modify the
 opcode, so we don't care how many bytes are between the opcode and
 the operand.

 4b.	JXobXXX
 length of long, long, byte.
 Vax opcodes are:	(Hex)
 aoblss		f2
 aobleq		f3
 sobgeq		f4
 sobgtr		f5
 Always, we cannot reverse the sense of the branch; we have a byte
 displacement.

 The only time we need to modify the opcode is for class 2 instructions.
 After relax() we may complement the lowest order bit of such instruction
 to reverse sense of branch.

 For class 2 instructions, we store context of "where is the opcode literal".
 We can change an opcode's lowest order bit without breaking anything else.

 We sometimes store context in the operand literal. This way we can figure out
 after relax() what the original addressing mode was.  */

/* These displacements are relative to the start address of the
   displacement.  The first letter is Byte, Word.  2nd letter is
   Forward, Backward.  */
#define BF (1+ 127)
#define BB (1+-128)
#define WF (2+ 32767)
#define WB (2+-32768)
/* Dont need LF, LB because they always reach. [They are coded as 0.]  */

#define C(a,b) ENCODE_RELAX(a,b)
/* This macro has no side-effects.  */
#define ENCODE_RELAX(what,length) (((what) << 2) + (length))
#define RELAX_STATE(s) ((s) >> 2)
#define RELAX_LENGTH(s) ((s) & 3)

const relax_typeS md_relax_table[] =
{
  {1, 1, 0, 0},			/* error sentinel   0,0	*/
  {1, 1, 0, 0},			/* unused	    0,1	*/
  {1, 1, 0, 0},			/* unused	    0,2	*/
  {1, 1, 0, 0},			/* unused	    0,3	*/

  {BF + 1, BB + 1, 2, C (1, 1)},/* B^"foo"	    1,0 */
  {WF + 1, WB + 1, 3, C (1, 2)},/* W^"foo"	    1,1 */
  {0, 0, 5, 0},			/* L^"foo"	    1,2 */
  {1, 1, 0, 0},			/* unused	    1,3 */

  {BF, BB, 1, C (2, 1)},	/* b<cond> B^"foo"  2,0 */
  {WF + 2, WB + 2, 4, C (2, 2)},/* br.+? brw X	    2,1 */
  {0, 0, 7, 0},			/* br.+? jmp X	    2,2 */
  {1, 1, 0, 0},			/* unused	    2,3 */

  {BF, BB, 1, C (3, 1)},	/* brb B^foo	    3,0 */
  {WF, WB, 2, C (3, 2)},	/* brw W^foo	    3,1 */
  {0, 0, 5, 0},			/* Jmp L^foo	    3,2 */
  {1, 1, 0, 0},			/* unused	    3,3 */

  {1, 1, 0, 0},			/* unused	    4,0 */
  {WF, WB, 2, C (4, 2)},	/* acb_ ^Wfoo	    4,1 */
  {0, 0, 10, 0},		/* acb_,br,jmp L^foo4,2 */
  {1, 1, 0, 0},			/* unused	    4,3 */

  {BF, BB, 1, C (5, 1)},	/* Xob___,,foo      5,0 */
  {WF + 4, WB + 4, 6, C (5, 2)},/* Xob.+2,brb.+3,brw5,1 */
  {0, 0, 9, 0},			/* Xob.+2,brb.+6,jmp5,2 */
  {1, 1, 0, 0},			/* unused	    5,3 */
};

#undef C
#undef BF
#undef BB
#undef WF
#undef WB

void float_cons (int);
int flonum_gen2vax (char, FLONUM_TYPE *, LITTLENUM_TYPE *);

const pseudo_typeS md_pseudo_table[] =
{
  {"dfloat", float_cons, 'd'},
  {"ffloat", float_cons, 'f'},
  {"gfloat", float_cons, 'g'},
  {"hfloat", float_cons, 'h'},
  {"d_floating", float_cons, 'd'},
  {"f_floating", float_cons, 'f'},
  {"g_floating", float_cons, 'g'},
  {"h_floating", float_cons, 'h'},
  {NULL, NULL, 0},
};

#define STATE_PC_RELATIVE		(1)
#define STATE_CONDITIONAL_BRANCH	(2)
#define STATE_ALWAYS_BRANCH		(3)	/* includes BSB...  */
#define STATE_COMPLEX_BRANCH	        (4)
#define STATE_COMPLEX_HOP		(5)

#define STATE_BYTE			(0)
#define STATE_WORD			(1)
#define STATE_LONG			(2)
#define STATE_UNDF			(3)	/* Symbol undefined in pass1.  */

#define min(a, b)	((a) < (b) ? (a) : (b))

void
md_number_to_chars (char con[], valueT value, int nbytes)
{
  number_to_chars_littleendian (con, value, nbytes);
}

/* Fix up some data or instructions after we find out the value of a symbol
   that they reference.  */

void				/* Knows about order of bytes in address.  */
md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)
{
  valueT value = * valueP;

  if (((fixP->fx_addsy == NULL && fixP->fx_subsy == NULL)
       && fixP->fx_r_type != BFD_RELOC_32_PLT_PCREL
       && fixP->fx_r_type != BFD_RELOC_32_GOT_PCREL)
      || fixP->fx_r_type == NO_RELOC)
    number_to_chars_littleendian (fixP->fx_where + fixP->fx_frag->fr_literal,
				  value, fixP->fx_size);

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Convert a number from VAX byte order (little endian)
   into host byte order.
   con		is the buffer to convert,
   nbytes	is the length of the given buffer.  */
static long
md_chars_to_number (unsigned char con[], int nbytes)
{
  long retval;

  for (retval = 0, con += nbytes - 1; nbytes--; con--)
    {
      retval <<= BITS_PER_CHAR;
      retval |= *con;
    }
  return retval;
}

/* Copy a bignum from in to out.
   If the output is shorter than the input, copy lower-order
   littlenums.  Return 0 or the number of significant littlenums
   dropped.  Assumes littlenum arrays are densely packed: no unused
   chars between the littlenums. Uses memcpy() to move littlenums, and
   wants to know length (in chars) of the input bignum.  */

static int
bignum_copy (LITTLENUM_TYPE *in,
	     int in_length,	/* in sizeof(littlenum)s */
	     LITTLENUM_TYPE *out,
	     int out_length	/* in sizeof(littlenum)s */)
{
  int significant_littlenums_dropped;

  if (out_length < in_length)
    {
      LITTLENUM_TYPE *p;	/* -> most significant (non-zero) input
				      littlenum.  */

      memcpy ((void *) out, (void *) in,
	      (unsigned int) out_length << LITTLENUM_SHIFT);
      for (p = in + in_length - 1; p >= in; --p)
	{
	  if (*p)
	    break;
	}
      significant_littlenums_dropped = p - in - in_length + 1;

      if (significant_littlenums_dropped < 0)
	significant_littlenums_dropped = 0;
    }
  else
    {
      memcpy ((char *) out, (char *) in,
	      (unsigned int) in_length << LITTLENUM_SHIFT);

      if (out_length > in_length)
	memset ((char *) (out + in_length), '\0',
		(unsigned int) (out_length - in_length) << LITTLENUM_SHIFT);

      significant_littlenums_dropped = 0;
    }

  return significant_littlenums_dropped;
}

/* md_estimate_size_before_relax(), called just before relax().
   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag and the growth beyond
   fr_fix.  */
int
md_estimate_size_before_relax (fragS *fragP, segT segment)
{
  if (RELAX_LENGTH (fragP->fr_subtype) == STATE_UNDF)
    {
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment
#ifdef OBJ_ELF
	  || S_IS_WEAK (fragP->fr_symbol)
	  || S_IS_EXTERNAL (fragP->fr_symbol)
#endif
	  )
	{
	  /* Non-relaxable cases.  */
	  int reloc_type = NO_RELOC;
	  char *p;
	  int old_fr_fix;

	  old_fr_fix = fragP->fr_fix;
	  p = fragP->fr_literal + old_fr_fix;
#ifdef OBJ_ELF
	  /* If this is to an undefined symbol, then if it's an indirect
	     reference indicate that is can mutated into a GLOB_DAT or
	     JUMP_SLOT by the loader.  We restrict ourselves to no offset
	     due to a limitation in the NetBSD linker.  */

	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find (GLOBAL_OFFSET_TABLE_NAME);
	  if (PLT_symbol == NULL)
	    PLT_symbol = symbol_find (PROCEDURE_LINKAGE_TABLE_NAME);
	  if ((GOT_symbol == NULL || fragP->fr_symbol != GOT_symbol)
	      && (PLT_symbol == NULL || fragP->fr_symbol != PLT_symbol)
	      && fragP->fr_symbol != NULL
	      && flag_want_pic
	      && (!S_IS_DEFINED (fragP->fr_symbol)
	          || S_IS_WEAK (fragP->fr_symbol)
	          || S_IS_EXTERNAL (fragP->fr_symbol)))
	    {
	      /* Indirect references cannot go through the GOT or PLT,
	         let's hope they'll become local in the final link.  */
	      if ((ELF_ST_VISIBILITY (S_GET_OTHER (fragP->fr_symbol))
		   != STV_DEFAULT)
		  || (p[0] & 0x10))
		reloc_type = BFD_RELOC_32_PCREL;
	      else if (((unsigned char *) fragP->fr_opcode)[0] == VAX_CALLS
		       || ((unsigned char *) fragP->fr_opcode)[0] == VAX_CALLG
		       || ((unsigned char *) fragP->fr_opcode)[0] == VAX_JSB
		       || ((unsigned char *) fragP->fr_opcode)[0] == VAX_JMP
		       || S_IS_FUNCTION (fragP->fr_symbol))
		reloc_type = BFD_RELOC_32_PLT_PCREL;
	      else
		reloc_type = BFD_RELOC_32_GOT_PCREL;
	    }
#endif
	  switch (RELAX_STATE (fragP->fr_subtype))
	    {
	    case STATE_PC_RELATIVE:
	      p[0] |= VAX_PC_RELATIVE_MODE;	/* Preserve @@ bit.  */
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, reloc_type);
	      break;

	    case STATE_CONDITIONAL_BRANCH:
	      *fragP->fr_opcode ^= 1;		/* Reverse sense of branch.  */
	      p[0] = 6;
	      p[1] = VAX_JMP;
	      p[2] = VAX_PC_RELATIVE_MODE;	/* ...(PC) */
	      fragP->fr_fix += 1 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 3, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    case STATE_COMPLEX_BRANCH:
	      p[0] = 2;
	      p[1] = 0;
	      p[2] = VAX_BRB;
	      p[3] = 6;
	      p[4] = VAX_JMP;
	      p[5] = VAX_PC_RELATIVE_MODE;	/* ...(pc) */
	      fragP->fr_fix += 2 + 2 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 6, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    case STATE_COMPLEX_HOP:
	      p[0] = 2;
	      p[1] = VAX_BRB;
	      p[2] = 6;
	      p[3] = VAX_JMP;
	      p[4] = VAX_PC_RELATIVE_MODE;	/* ...(pc) */
	      fragP->fr_fix += 1 + 2 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 5, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    case STATE_ALWAYS_BRANCH:
	      *fragP->fr_opcode += VAX_WIDEN_LONG;
	      p[0] = VAX_PC_RELATIVE_MODE;	/* ...(PC) */
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    default:
	      abort ();
	    }
	  frag_wane (fragP);

	  /* Return the growth in the fixed part of the frag.  */
	  return fragP->fr_fix - old_fr_fix;
	}

      /* Relaxable cases.  Set up the initial guess for the variable
	 part of the frag.  */
      switch (RELAX_STATE (fragP->fr_subtype))
	{
	case STATE_PC_RELATIVE:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	  break;
	case STATE_CONDITIONAL_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE);
	  break;
	case STATE_COMPLEX_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_COMPLEX_BRANCH, STATE_WORD);
	  break;
	case STATE_COMPLEX_HOP:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_BYTE);
	  break;
	case STATE_ALWAYS_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_BYTE);
	  break;
	}
    }

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Called after relax() is finished.
   In:	Address of frag.
  	fr_type == rs_machine_dependent.
  	fr_subtype is what the address relaxed to.

   Out:	Any fixSs and constants are set up.
  	Caller will turn frag into a ".space 0".  */
void
md_convert_frag (bfd *headers ATTRIBUTE_UNUSED,
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  char *addressP;		/* -> _var to change.  */
  char *opcodeP;		/* -> opcode char(s) to change.  */
  short int extension = 0;	/* Size of relaxed address.  */
  /* Added to fr_fix: incl. ALL var chars.  */
  symbolS *symbolP;
  long where;

  know (fragP->fr_type == rs_machine_dependent);
  where = fragP->fr_fix;
  addressP = fragP->fr_literal + where;
  opcodeP = fragP->fr_opcode;
  symbolP = fragP->fr_symbol;
  know (symbolP);

  switch (fragP->fr_subtype)
    {
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE):
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit.  */
      addressP[0] |= 0xAF;	/* Byte displacement. */
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 2;
      break;

    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_WORD):
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit.  */
      addressP[0] |= 0xCF;	/* Word displacement. */
      fix_new (fragP, fragP->fr_fix + 1, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 3;
      break;

    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_LONG):
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit.  */
      addressP[0] |= 0xEF;	/* Long word displacement. */
      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 5;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE):
      fix_new (fragP, fragP->fr_fix, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 1;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_WORD):
      opcodeP[0] ^= 1;		/* Reverse sense of test.  */
      addressP[0] = 3;
      addressP[1] = VAX_BRW;
      fix_new (fragP, fragP->fr_fix + 2, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 4;
      break;

    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_LONG):
      opcodeP[0] ^= 1;		/* Reverse sense of test.  */
      addressP[0] = 6;
      addressP[1] = VAX_JMP;
      addressP[2] = VAX_PC_RELATIVE_MODE;
      fix_new (fragP, fragP->fr_fix + 3, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 7;
      break;

    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_BYTE):
      fix_new (fragP, fragP->fr_fix, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 1;
      break;

    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_WORD):
      opcodeP[0] += VAX_WIDEN_WORD;	/* brb -> brw, bsbb -> bsbw */
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, NO_RELOC);
      extension = 2;
      break;

    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_LONG):
      opcodeP[0] += VAX_WIDEN_LONG;	/* brb -> jmp, bsbb -> jsb */
      addressP[0] = VAX_PC_RELATIVE_MODE;
      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 5;
      break;

    case ENCODE_RELAX (STATE_COMPLEX_BRANCH, STATE_WORD):
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 2;
      break;

    case ENCODE_RELAX (STATE_COMPLEX_BRANCH, STATE_LONG):
      addressP[0] = 2;
      addressP[1] = 0;
      addressP[2] = VAX_BRB;
      addressP[3] = 6;
      addressP[4] = VAX_JMP;
      addressP[5] = VAX_PC_RELATIVE_MODE;
      fix_new (fragP, fragP->fr_fix + 6, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 10;
      break;

    case ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_BYTE):
      fix_new (fragP, fragP->fr_fix, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 1;
      break;

    case ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_WORD):
      addressP[0] = 2;
      addressP[1] = VAX_BRB;
      addressP[2] = 3;
      addressP[3] = VAX_BRW;
      fix_new (fragP, fragP->fr_fix + 4, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 6;
      break;

    case ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_LONG):
      addressP[0] = 2;
      addressP[1] = VAX_BRB;
      addressP[2] = 6;
      addressP[3] = VAX_JMP;
      addressP[4] = VAX_PC_RELATIVE_MODE;
      fix_new (fragP, fragP->fr_fix + 5, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 9;
      break;

    default:
      BAD_CASE (fragP->fr_subtype);
      break;
    }
  fragP->fr_fix += extension;
}

/* Translate internal format of relocation info into target format.

   On vax: first 4 bytes are normal unsigned long, next three bytes
   are symbolnum, least sig. byte first.  Last byte is broken up with
   the upper nibble as nuthin, bit 3 as extern, bits 2 & 1 as length, and
   bit 0 as pcrel.  */
#ifdef comment
void
md_ri_to_chars (char *the_bytes, struct reloc_info_generic ri)
{
  /* This is easy.  */
  md_number_to_chars (the_bytes, ri.r_address, sizeof (ri.r_address));
  /* Now the fun stuff.  */
  the_bytes[6] = (ri.r_symbolnum >> 16) & 0x0ff;
  the_bytes[5] = (ri.r_symbolnum >> 8) & 0x0ff;
  the_bytes[4] = ri.r_symbolnum & 0x0ff;
  the_bytes[7] = (((ri.r_extern << 3) & 0x08) | ((ri.r_length << 1) & 0x06)
		  | ((ri.r_pcrel << 0) & 0x01)) & 0x0F;
}

#endif /* comment */

/*       BUGS, GRIPES,  APOLOGIA, etc.

   The opcode table 'votstrs' needs to be sorted on opcode frequency.
   That is, AFTER we hash it with hash_...(), we want most-used opcodes
   to come out of the hash table faster.

   I am sorry to inflict yet another VAX assembler on the world, but
   RMS says we must do everything from scratch, to prevent pin-heads
   restricting this software.

   This is a vaguely modular set of routines in C to parse VAX
   assembly code using DEC mnemonics. It is NOT un*x specific.

   The idea here is that the assembler has taken care of all:
     labels
     macros
     listing
     pseudo-ops
     line continuation
     comments
     condensing any whitespace down to exactly one space
   and all we have to do is parse 1 line into a vax instruction
   partially formed. We will accept a line, and deliver:
     an error message (hopefully empty)
     a skeleton VAX instruction (tree structure)
     textual pointers to all the operand expressions
     a warning message that notes a silly operand (hopefully empty)

  		E D I T   H I S T O R Y

   17may86 Dean Elsner. Bug if line ends immediately after opcode.
   30apr86 Dean Elsner. New vip_op() uses arg block so change call.
    6jan86 Dean Elsner. Crock vip_begin() to call vip_op_defaults().
    2jan86 Dean Elsner. Invent synthetic opcodes.
  	Widen vax_opcodeT to 32 bits. Use a bit for VIT_OPCODE_SYNTHETIC,
  	which means this is not a real opcode, it is like a macro; it will
  	be relax()ed into 1 or more instructions.
  	Use another bit for VIT_OPCODE_SPECIAL if the op-code is not optimised
  	like a regular branch instruction. Option added to vip_begin():
  	exclude	synthetic opcodes. Invent synthetic_votstrs[].
   31dec85 Dean Elsner. Invent vit_opcode_nbytes.
  	Also make vit_opcode into a char[]. We now have n-byte vax opcodes,
  	so caller's don't have to know the difference between a 1-byte & a
  	2-byte op-code. Still need vax_opcodeT concept, so we know how
  	big an object must be to hold an op.code.
   30dec85 Dean Elsner. Widen typedef vax_opcodeT in "vax-inst.h"
  	because vax opcodes may be 16 bits. Our crufty C compiler was
  	happily initialising 8-bit vot_codes with 16-bit numbers!
  	(Wouldn't the 'phone company like to compress data so easily!)
   29dec85 Dean Elsner. New static table vax_operand_width_size[].
  	Invented so we know hw many bytes a "I^#42" needs in its immediate
  	operand. Revised struct vop in "vax-inst.h": explicitly include
  	byte length of each operand, and it's letter-code datum type.
   17nov85 Dean Elsner. Name Change.
  	Due to ar(1) truncating names, we learned the hard way that
  	"vax-inst-parse.c" -> "vax-inst-parse." dropping the "o" off
  	the archived object name. SO... we shortened the name of this
  	source file, and changed the makefile.  */

/* Handle of the OPCODE hash table.  */
static struct hash_control *op_hash;

/* In:	1 character, from "bdfghloqpw" being the data-type of an operand
  	of a vax instruction.

   Out:	the length of an operand of that type, in bytes.
  	Special branch operands types "-?!" have length 0.  */

static const short int vax_operand_width_size[256] =
{
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 8, 0, 4, 8, 16, 0, 0, 0, 4, 0, 0,16,	/* ..b.d.fgh...l..o  */
  0, 8, 0, 0, 0, 0, 0, 2,  0, 0, 0, 0, 0, 0, 0, 0,	/* .q.....w........  */
  0, 0, 1, 0, 8, 0, 4, 8, 16, 0, 0, 0, 4, 0, 0,16,	/* ..b.d.fgh...l..o  */
  0, 8, 0, 0, 0, 0, 0, 2,  0, 0, 0, 0, 0, 0, 0, 0,	/* .q.....w........  */
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
};

/* This perversion encodes all the vax opcodes as a bunch of strings.
   RMS says we should build our hash-table at run-time. Hmm.
   Please would someone arrange these in decreasing frequency of opcode?
   Because of the way hash_...() works, the most frequently used opcode
   should be textually first and so on.

   Input for this table was 'vax.opcodes', awk(1)ed by 'vax.opcodes.c.awk' .
   So change 'vax.opcodes', then re-generate this table.  */

#include "opcode/vax.h"

/* This is a table of optional op-codes. All of them represent
   'synthetic' instructions that seem popular.

   Here we make some pseudo op-codes. Every code has a bit set to say
   it is synthetic. This lets you catch them if you want to
   ban these opcodes. They are mnemonics for "elastic" instructions
   that are supposed to assemble into the fewest bytes needed to do a
   branch, or to do a conditional branch, or whatever.
  
   The opcode is in the usual place [low-order n*8 bits]. This means
   that if you mask off the bucky bits, the usual rules apply about
   how long the opcode is.
  
   All VAX branch displacements come at the end of the instruction.
   For simple branches (1-byte opcode + 1-byte displacement) the last
   operand is coded 'b?' where the "data type" '?' is a clue that we
   may reverse the sense of the branch (complement lowest order bit)
   and branch around a jump. This is by far the most common case.
   That is why the VIT_OPCODE_SYNTHETIC bit is set: it says this is
   a 0-byte op-code followed by 2 or more bytes of operand address.
  
   If the op-code has VIT_OPCODE_SPECIAL set, then we have a more unusual
   case.
  
   For JBSB & JBR the treatment is the similar, except (1) we have a 'bw'
   option before (2) we can directly JSB/JMP because there is no condition.
   These operands have 'b-' as their access/data type.
  
   That leaves a bunch of random opcodes: JACBx, JxOBxxx. In these
   cases, we do the same idea. JACBxxx are all marked with a 'b!'
   JAOBxxx & JSOBxxx are marked with a 'b:'.  */
#if (VIT_OPCODE_SYNTHETIC != 0x80000000)
#error "You have just broken the encoding below, which assumes the sign bit means 'I am an imaginary instruction'."
#endif

#if (VIT_OPCODE_SPECIAL != 0x40000000)
#error "You have just broken the encoding below, which assumes the 0x40 M bit means 'I am not to be "optimised" the way normal branches are'."
#endif

static const struct vot
  synthetic_votstrs[] =
{
  {"jbsb",	{"b-", 0xC0000010}},		/* BSD 4.2 */
/* jsb used already */
  {"jbr",	{"b-", 0xC0000011}},		/* BSD 4.2 */
  {"jr",	{"b-", 0xC0000011}},		/* consistent */
  {"jneq",	{"b?", 0x80000012}},
  {"jnequ",	{"b?", 0x80000012}},
  {"jeql",	{"b?", 0x80000013}},
  {"jeqlu",	{"b?", 0x80000013}},
  {"jgtr",	{"b?", 0x80000014}},
  {"jleq",	{"b?", 0x80000015}},
/* un-used opcodes here */
  {"jgeq",	{"b?", 0x80000018}},
  {"jlss",	{"b?", 0x80000019}},
  {"jgtru",	{"b?", 0x8000001a}},
  {"jlequ",	{"b?", 0x8000001b}},
  {"jvc",	{"b?", 0x8000001c}},
  {"jvs",	{"b?", 0x8000001d}},
  {"jgequ",	{"b?", 0x8000001e}},
  {"jcc",	{"b?", 0x8000001e}},
  {"jlssu",	{"b?", 0x8000001f}},
  {"jcs",	{"b?", 0x8000001f}},

  {"jacbw",	{"rwrwmwb!", 0xC000003d}},
  {"jacbf",	{"rfrfmfb!", 0xC000004f}},
  {"jacbd",	{"rdrdmdb!", 0xC000006f}},
  {"jacbb",	{"rbrbmbb!", 0xC000009d}},
  {"jacbl",	{"rlrlmlb!", 0xC00000f1}},
  {"jacbg",	{"rgrgmgb!", 0xC0004ffd}},
  {"jacbh",	{"rhrhmhb!", 0xC0006ffd}},

  {"jbs",	{"rlvbb?", 0x800000e0}},
  {"jbc",	{"rlvbb?", 0x800000e1}},
  {"jbss",	{"rlvbb?", 0x800000e2}},
  {"jbcs",	{"rlvbb?", 0x800000e3}},
  {"jbsc",	{"rlvbb?", 0x800000e4}},
  {"jbcc",	{"rlvbb?", 0x800000e5}},
  {"jbssi",	{"rlvbb?", 0x800000e6}},
  {"jbcci",	{"rlvbb?", 0x800000e7}},
  {"jlbs",	{"rlb?", 0x800000e8}},
  {"jlbc",	{"rlb?", 0x800000e9}},

  {"jaoblss",	{"rlmlb:", 0xC00000f2}},
  {"jaobleq",	{"rlmlb:", 0xC00000f3}},
  {"jsobgeq",	{"mlb:", 0xC00000f4}},
  {"jsobgtr",	{"mlb:", 0xC00000f5}},

/* CASEx has no branch addresses in our conception of it.  */
/* You should use ".word ..." statements after the "case ...".  */

  {"",		{"", 0}}	/* Empty is end sentinel.  */
};

/* Because this module is useful for both VMS and UN*X style assemblers
   and because of the variety of UN*X assemblers we must recognise
   the different conventions for assembler operand notation. For example
   VMS says "#42" for immediate mode, while most UN*X say "$42".
   We permit arbitrary sets of (single) characters to represent the
   3 concepts that DEC writes '#', '@@', '^'.  */

/* Character tests.  */
#define VIP_IMMEDIATE 01	/* Character is like DEC # */
#define VIP_INDIRECT  02	/* Char is like DEC @@ */
#define VIP_DISPLEN   04	/* Char is like DEC ^ */

#define IMMEDIATEP(c)	(vip_metacharacters [(c) & 0xff] & VIP_IMMEDIATE)
#define INDIRECTP(c)	(vip_metacharacters [(c) & 0xff] & VIP_INDIRECT)
#define DISPLENP(c)	(vip_metacharacters [(c) & 0xff] & VIP_DISPLEN)

/* We assume 8 bits per byte. Use vip_op_defaults() to set these up BEFORE we
   are ever called.  */

#if defined(CONST_TABLE)
#define _ 0,
#define I VIP_IMMEDIATE,
#define S VIP_INDIRECT,
#define D VIP_DISPLEN,
static const char
vip_metacharacters[256] =
{
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/* ^@@ ^A ^B ^C ^D ^E ^F ^G ^H ^I ^J ^K ^L ^M ^N ^O*/
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/* ^P ^Q ^R ^S ^T ^U ^V ^W ^X ^Y ^Z ^[ ^\ ^] ^^ ^_ */
  _ _ _ _ I _ _ _ _ _ S _ _ _ _ _	/* sp !  "  #  $  %  & '  (  )  *  +  ,  -  .  / */
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?*/
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*@@  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O*/
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _*/
  D _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*`  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o*/
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^?*/

  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
};
#undef _
#undef I
#undef S
#undef D

#else

static char vip_metacharacters[256];

static void
vip_op_1 (int bit, const char *syms)
{
  unsigned char t;

  while ((t = *syms++) != 0)
    vip_metacharacters[t] |= bit;
}

/* Can be called any time.  More arguments may appear in future.  */
static void
vip_op_defaults (const char *immediate, const char *indirect, const char *displen)
{
  vip_op_1 (VIP_IMMEDIATE, immediate);
  vip_op_1 (VIP_INDIRECT, indirect);
  vip_op_1 (VIP_DISPLEN, displen);
}

#endif

/* Call me once before you decode any lines.
   I decode votstrs into a hash table at op_hash (which I create).
   I return an error text or null.
   If you want, I will include the 'synthetic' jXXX instructions in the
   instruction table.
   You must nominate metacharacters for eg DEC's "#", "@@", "^".  */

static const char *
vip_begin (int synthetic_too,		/* 1 means include jXXX op-codes.  */
	   const char *immediate,
	   const char *indirect,
	   const char *displen)
{
  const struct vot *vP;		/* scan votstrs */
  const char *retval = 0;	/* error text */

  op_hash = hash_new ();

  for (vP = votstrs; *vP->vot_name && !retval; vP++)
    retval = hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);

  if (synthetic_too)
    for (vP = synthetic_votstrs; *vP->vot_name && !retval; vP++)
      retval = hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);

#ifndef CONST_TABLE
  vip_op_defaults (immediate, indirect, displen);
#endif

  return retval;
}

/* Take 3 char.s, the last of which may be `\0` (non-existent)
   and return the VAX register number that they represent.
  
   Return -1 if they don't form a register name. Good names return
   a number from 0:15 inclusive.
  
   Case is not important in a name.
  
   Register names understood are:
  
  	R0
  	R1
  	R2
  	R3
  	R4
  	R5
  	R6
   	R7
  	R8
  	R9
  	R10
  	R11
  	R12	AP
  	R13	FP
  	R14	SP
  	R15	PC  */

#define AP 12
#define FP 13
#define SP 14
#define PC 15

/* Returns the register number of something like '%r15' or 'ap', supplied
   in four single chars. Returns -1 if the register isn't recognized,
   0..15 otherwise.  */
static int
vax_reg_parse (char c1, char c2, char c3, char c4)
{
  int retval = -1;

#ifdef OBJ_ELF
  if (c1 != '%')	/* Register prefixes are mandatory for ELF.  */
    return retval;
  c1 = c2;
  c2 = c3;
  c3 = c4;
#endif
#ifdef OBJ_VMS
  if (c4 != 0)		/* Register prefixes are not allowed under VMS.  */
    return retval;
#endif
#ifdef OBJ_AOUT
  if (c1 == '%')	/* Register prefixes are optional under a.out.  */
    {
      c1 = c2;
      c2 = c3;
      c3 = c4;
    }
  else if (c3 && c4)	/* Can't be 4 characters long.  */
    return retval;
#endif

  c1 = TOLOWER (c1);
  c2 = TOLOWER (c2);
  if (ISDIGIT (c2) && c1 == 'r')
    {
      retval = c2 - '0';
      if (ISDIGIT (c3))
	{
	  retval = retval * 10 + c3 - '0';
	  retval = (retval > 15) ? -1 : retval;
	  /* clamp the register value to 1 hex digit */
	}
      else if (c3)
	retval = -1;		/* c3 must be '\0' or a digit.  */
    }
  else if (c3)			/* There are no three letter regs.  */
    retval = -1;
  else if (c2 == 'p')
    {
      switch (c1)
	{
	case 's':
	  retval = SP;
	  break;
	case 'f':
	  retval = FP;
	  break;
	case 'a':
	  retval = AP;
	  break;
	default:
	  retval = -1;
	}
    }
  else if (c1 == 'p' && c2 == 'c')
    retval = PC;
  else
    retval = -1;
  return retval;
}

/* Parse a vax operand in DEC assembler notation.
   For speed, expect a string of whitespace to be reduced to a single ' '.
   This is the case for GNU AS, and is easy for other DEC-compatible
   assemblers.
  
   Knowledge about DEC VAX assembler operand notation lives here.
   This doesn't even know what a register name is, except it believes
   all register names are 2 or 3 characters, and lets vax_reg_parse() say
   what number each name represents.
   It does, however, know that PC, SP etc are special registers so it can
   detect addressing modes that are silly for those registers.
  
   Where possible, it delivers 1 fatal or 1 warning message if the operand
   is suspect. Exactly what we test for is still evolving.

   ---
  	Arg block.
  
   There were a number of 'mismatched argument type' bugs to vip_op.
   The most general solution is to typedef each (of many) arguments.
   We used instead a typedef'd argument block. This is less modular
   than using separate return pointers for each result, but runs faster
   on most engines, and seems to keep programmers happy. It will have
   to be done properly if we ever want to use vip_op as a general-purpose
   module (it was designed to be).
  
 	G^

   Doesn't support DEC "G^" format operands. These always take 5 bytes
   to express, and code as modes 8F or 9F. Reason: "G^" deprives you of
   optimising to (say) a "B^" if you are lucky in the way you link.
   When someone builds a linker smart enough to convert "G^" to "B^", "W^"
   whenever possible, then we should implement it.
   If there is some other use for "G^", feel free to code it in!

  	speed
  
   If I nested if()s more, I could avoid testing (*err) which would save
   time, space and page faults. I didn't nest all those if()s for clarity
   and because I think the mode testing can be re-arranged 1st to test the
   commoner constructs 1st. Does anybody have statistics on this?  
  
  	error messages
  
   In future, we should be able to 'compose' error messages in a scratch area
   and give the user MUCH more informative error messages. Although this takes
   a little more code at run-time, it will make this module much more self-
   documenting. As an example of what sucks now: most error messages have
   hardwired into them the DEC VAX metacharacters "#^@@" which are nothing like
   the Un*x characters "$`*", that most users will expect from this AS.

   ----
   
   The input is a string, ending with '\0'.
  
   We also require a 'hint' of what kind of operand is expected: so
   we can remind caller not to write into literals for instance.
  
   The output is a skeletal instruction.
  
   The algorithm has two parts.
   1. extract the syntactic features (parse off all the @@^#-()+[] mode crud);
   2. express the @@^#-()+[] as some parameters suited to further analysis.
  
   2nd step is where we detect the googles of possible invalid combinations
   a human (or compiler) might write. Note that if we do a half-way
   decent assembler, we don't know how long to make (eg) displacement
   fields when we first meet them (because they may not have defined values).
   So we must wait until we know how many bits are needed for each address,
   then we can know both length and opcodes of instructions.
   For reason(s) above, we will pass to our caller a 'broken' instruction
   of these major components, from which our caller can generate instructions:
    -  displacement length      I^ S^ L^ B^ W^ unspecified
    -  mode                     (many)
    -  register                 R0-R15 or absent
    -  index register           R0-R15 or absent
    -  expression text          what we don't parse
    -  error text(s)            why we couldn't understand the operand

   ----
    
   To decode output of this, test errtxt. If errtxt[0] == '\0', then
   we had no errors that prevented parsing. Also, if we ever report
   an internal bug, errtxt[0] is set non-zero. So one test tells you
   if the other outputs are to be taken seriously.

   ----
   
   Dec defines the semantics of address modes (and values)
   by a two-letter code, explained here.
  
     letter 1:   access type
  
       a         address calculation - no data access, registers forbidden
       b         branch displacement
       m         read - let go of bus - write back    "modify"
       r         read
       v         bit field address: like 'a' but registers are OK
       w         write
       space	 no operator (eg ".long foo") [our convention]
  
     letter 2:   data type (i.e. width, alignment)
  
       b         byte
       d         double precision floating point (D format)
       f         single precision floating point (F format)
       g         G format floating
       h         H format floating
       l         longword
       o         octaword
       q         quadword
       w         word
       ?	 simple synthetic branch operand
       -	 unconditional synthetic JSB/JSR operand
       !	 complex synthetic branch operand
  
   The '-?!' letter 2's are not for external consumption. They are used
   for various assemblers. Generally, all unknown widths are assumed 0.
   We don't limit your choice of width character.
  
   DEC operands are hard work to parse. For example, '@@' as the first
   character means indirect (deferred) mode but elsewhere it is a shift
   operator.
   The long-winded explanation of how this is supposed to work is
   cancelled. Read a DEC vax manual.
   We try hard not to parse anything that MIGHT be part of the expression
   buried in that syntax. For example if we see @@...(Rn) we don't check
   for '-' before the '(' because mode @@-(Rn) does not exist.
  
   After parsing we have:
  
   at                     1 if leading '@@' (or Un*x '*')
   len                    takes one value from " bilsw". eg B^ -> 'b'.
   hash                   1 if leading '#' (or Un*x '$')
   expr_begin, expr_end   the expression we did not parse
                          even though we don't interpret it, we make use
                          of its presence or absence.
   sign                   -1: -(Rn)    0: absent    +1: (Rn)+
   paren                  1 if () are around register
   reg                    major register number 0:15    -1 means absent
   ndx                    index register number 0:15    -1 means absent
  
   Again, I dare not explain it: just trace ALL the code!

   Summary of vip_op outputs.

  mode	reg	len	ndx
  (Rn) => @@Rn
  {@@}Rn			5+@@	n	' '	optional
  branch operand		0	-1	' '	-1
  S^#foo			0	-1	's'	-1
  -(Rn)			7	n	' '	optional
  {@@}(Rn)+		8+@@	n	' '	optional
  {@@}#foo, no S^		8+@@	PC	" i"	optional
  {@@}{q^}{(Rn)}		10+@@+q	option	" bwl"	optional  */

/* Dissect user-input 'optext' (which is something like "@@B^foo@@bar(AP)[FP]:")
   using the vop in vopP. vopP's vop_access and vop_width. We fill _ndx, _reg,
   _mode, _short, _warn, _error, _expr_begin, _expr_end and _nbytes.  */

static void
vip_op (char *optext, struct vop *vopP)
{
  /* Track operand text forward.  */
  char *p;
  /* Track operand text backward.  */
  char *q;
  /* 1 if leading '@@' ('*') seen.  */
  int at;
  /* one of " bilsw" */
  char len;
  /* 1 if leading '#' ('$') seen.  */
  int hash;
  /* -1, 0 or +1.  */
  int sign = 0;
  /* 1 if () surround register.  */
  int paren = 0;
  /* Register number, -1:absent.  */
  int reg = 0;
  /* Index register number -1:absent.  */
  int ndx = 0;
  /* Report illegal operand, ""==OK.  */
  /* " " is a FAKE error: means we won.  */
  /* ANY err that begins with ' ' is a fake.  */
  /* " " is converted to "" before return.  */
  const char *err;
  /* Warn about weird modes pf address.  */
  const char *wrn;
  /* Preserve q in case we backup.  */
  char *oldq = NULL;
  /* Build up 4-bit operand mode here.  */
  /* Note: index mode is in ndx, this is.  */
  /* The major mode of operand address.  */
  int mode = 0;
  /* Notice how we move wrong-arg-type bugs INSIDE this module: if we
     get the types wrong below, we lose at compile time rather than at
     lint or run time.  */
  char access_mode;		/* vop_access.  */

  access_mode = vopP->vop_access;
  /* None of our code bugs (yet), no user text errors, no warnings
     even.  */
  err = wrn = 0;

  p = optext;

  if (*p == ' ')		/* Expect all whitespace reduced to ' '.  */
    p++;			/* skip over whitespace */

  if ((at = INDIRECTP (*p)) != 0)
    {				/* 1 if *p=='@@'(or '*' for Un*x) */
      p++;			/* at is determined */
      if (*p == ' ')		/* Expect all whitespace reduced to ' '.  */
	p++;			/* skip over whitespace */
    }

  /* This code is subtle. It tries to detect all legal (letter)'^'
     but it doesn't waste time explicitly testing for premature '\0' because
     this case is rejected as a mismatch against either (letter) or '^'.  */
  {
    char c;

    c = *p;
    c = TOLOWER (c);
    if (DISPLENP (p[1]) && strchr ("bilws", len = c))
      p += 2;			/* Skip (letter) '^'.  */
    else			/* No (letter) '^' seen.  */
      len = ' ';		/* Len is determined.  */
  }

  if (*p == ' ')		/* Expect all whitespace reduced to ' '.  */
    p++;

  if ((hash = IMMEDIATEP (*p)) != 0)	/* 1 if *p=='#' ('$' for Un*x) */
    p++;			/* Hash is determined.  */

  /* p points to what may be the beginning of an expression.
     We have peeled off the front all that is peelable.
     We know at, len, hash.
    
     Lets point q at the end of the text and parse that (backwards).  */

  for (q = p; *q; q++)
    ;
  q--;				/* Now q points at last char of text.  */

  if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '.  */
    q--;

  /* Reverse over whitespace, but don't.  */
  /* Run back over *p.  */

  /* As a matter of policy here, we look for [Rn], although both Rn and S^#
     forbid [Rn]. This is because it is easy, and because only a sick
     cyborg would have [...] trailing an expression in a VAX-like assembler.
     A meticulous parser would first check for Rn followed by '(' or '['
     and not parse a trailing ']' if it found another. We just ban expressions
     ending in ']'.  */
  if (*q == ']')
    {
      while (q >= p && *q != '[')
	q--;
      /* Either q<p or we got matching '['.  */
      if (q < p)
	err = _("no '[' to match ']'");
      else
	{
	  /* Confusers like "[]" will eventually lose with a bad register
	   * name error. So again we don't need to check for early '\0'.  */
	  if (q[3] == ']')
	    ndx = vax_reg_parse (q[1], q[2], 0, 0);
	  else if (q[4] == ']')
	    ndx = vax_reg_parse (q[1], q[2], q[3], 0);
	  else if (q[5] == ']')
	    ndx = vax_reg_parse (q[1], q[2], q[3], q[4]);
	  else
	    ndx = -1;
	  /* Since we saw a ']' we will demand a register name in the [].
	   * If luser hasn't given us one: be rude.  */
	  if (ndx < 0)
	    err = _("bad register in []");
	  else if (ndx == PC)
	    err = _("[PC] index banned");
	  else
	    /* Point q just before "[...]".  */
	    q--;
	}
    }
  else
    /* No ']', so no iNDeX register.  */
    ndx = -1;

  /* If err = "..." then we lost: run away.
     Otherwise ndx == -1 if there was no "[...]".
     Otherwise, ndx is index register number, and q points before "[...]".  */

  if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '.  */
    q--;
  /* Reverse over whitespace, but don't.  */
  /* Run back over *p.  */
  if (!err || !*err)
    {
      /* no ()+ or -() seen yet */
      sign = 0;

      if (q > p + 3 && *q == '+' && q[-1] == ')')
	{
	  sign = 1;		/* we saw a ")+" */
	  q--;			/* q points to ')' */
	}

      if (*q == ')' && q > p + 2)
	{
	  paren = 1;		/* assume we have "(...)" */
	  while (q >= p && *q != '(')
	    q--;
	  /* either q<p or we got matching '(' */
	  if (q < p)
	    err = _("no '(' to match ')'");
	  else
	    {
	      /* Confusers like "()" will eventually lose with a bad register
	         name error. So again we don't need to check for early '\0'.  */
	      if (q[3] == ')')
		reg = vax_reg_parse (q[1], q[2], 0, 0);
	      else if (q[4] == ')')
		reg = vax_reg_parse (q[1], q[2], q[3], 0);
	      else if (q[5] == ')')
		reg = vax_reg_parse (q[1], q[2], q[3], q[4]);
	      else
		reg = -1;
	      /* Since we saw a ')' we will demand a register name in the ')'.
	         This is nasty: why can't our hypothetical assembler permit
	         parenthesised expressions? BECAUSE I AM LAZY! That is why.
	         Abuse luser if we didn't spy a register name.  */
	      if (reg < 0)
		{
		  /* JF allow parenthesized expressions.  I hope this works.  */
		  paren = 0;
		  while (*q != ')')
		    q++;
		  /* err = "unknown register in ()"; */
		}
	      else
		q--;		/* point just before '(' of "(...)" */
	      /* If err == "..." then we lost. Run away.
	         Otherwise if reg >= 0 then we saw (Rn).  */
	    }
	  /* If err == "..." then we lost.
	     Otherwise paren==1 and reg = register in "()".  */
	}
      else
	paren = 0;
      /* If err == "..." then we lost.
         Otherwise, q points just before "(Rn)", if any.
         If there was a "(...)" then paren==1, and reg is the register.  */

      /* We should only seek '-' of "-(...)" if:
           we saw "(...)"                    paren == 1
           we have no errors so far          ! *err
           we did not see '+' of "(...)+"    sign < 1
         We don't check len. We want a specific error message later if
         user tries "x^...-(Rn)". This is a feature not a bug.  */
      if (!err || !*err)
	{
	  if (paren && sign < 1)/* !sign is adequate test */
	    {
	      if (*q == '-')
		{
		  sign = -1;
		  q--;
		}
	    }
	  /* We have back-tracked over most
	     of the crud at the end of an operand.
	     Unless err, we know: sign, paren. If paren, we know reg.
	     The last case is of an expression "Rn".
	     This is worth hunting for if !err, !paren.
	     We wouldn't be here if err.
	     We remember to save q, in case we didn't want "Rn" anyway.  */
	  if (!paren)
	    {
	      if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '.  */
		q--;
	      /* Reverse over whitespace, but don't.  */
	      /* Run back over *p.  */
	      /* Room for Rn or Rnn (include prefix) exactly?  */
	      if (q > p && q < p + 4)
		reg = vax_reg_parse (p[0], p[1],
		  q < p + 2 ? 0 : p[2],
		  q < p + 3 ? 0 : p[3]);
	      else
		reg = -1;	/* Always comes here if no register at all.  */
	      /* Here with a definitive reg value.  */
	      if (reg >= 0)
		{
		  oldq = q;
		  q = p - 1;
		}
	    }
	}
    }
  /* have reg. -1:absent; else 0:15.  */

  /* We have:  err, at, len, hash, ndx, sign, paren, reg.
     Also, any remaining expression is from *p through *q inclusive.
     Should there be no expression, q==p-1. So expression length = q-p+1.
     This completes the first part: parsing the operand text.  */

  /* We now want to boil the data down, checking consistency on the way.
     We want:  len, mode, reg, ndx, err, p, q, wrn, bug.
     We will deliver a 4-bit reg, and a 4-bit mode.  */

  /* Case of branch operand. Different. No L^B^W^I^S^ allowed for instance.
    
     in:  at	?
          len	?
          hash	?
          p:q	?
          sign  ?
          paren	?
          reg   ?
          ndx   ?
    
     out: mode  0
          reg   -1
          len	' '
          p:q	whatever was input
          ndx	-1
          err	" "		 or error message, and other outputs trashed.  */
  /* Branch operands have restricted forms.  */
  if ((!err || !*err) && access_mode == 'b')
    {
      if (at || hash || sign || paren || ndx >= 0 || reg >= 0 || len != ' ')
	err = _("invalid branch operand");
      else
	err = " ";
    }

  /* Since nobody seems to use it: comment this 'feature'(?) out for now.  */
#ifdef NEVER
  /* Case of stand-alone operand. e.g. ".long foo"
    
     in:  at	?
          len	?
          hash	?
          p:q	?
          sign  ?
          paren	?
          reg   ?
          ndx   ?
    
     out: mode  0
          reg   -1
          len	' '
          p:q	whatever was input
          ndx	-1
          err	" "		 or error message, and other outputs trashed.  */
  if ((!err || !*err) && access_mode == ' ')
    {
      if (at)
	err = _("address prohibits @@");
      else if (hash)
	err = _("address prohibits #");
      else if (sign)
	{
	  if (sign < 0)
	    err = _("address prohibits -()");
	  else
	    err = _("address prohibits ()+");
	}
      else if (paren)
	err = _("address prohibits ()");
      else if (ndx >= 0)
	err = _("address prohibits []");
      else if (reg >= 0)
	err = _("address prohibits register");
      else if (len != ' ')
	err = _("address prohibits displacement length specifier");
      else
	{
	  err = " ";	/* succeed */
	  mode = 0;
	}
    }
#endif

  /* Case of S^#.
    
     in:  at       0
          len      's'               definition
          hash     1              demand
          p:q                        demand not empty
          sign     0                 by paren==0
          paren    0             by "()" scan logic because "S^" seen
          reg      -1                or nn by mistake
          ndx      -1
    
     out: mode     0
          reg      -1
          len      's'
          exp
          ndx      -1  */
  if ((!err || !*err) && len == 's')
    {
      if (!hash || paren || at || ndx >= 0)
	err = _("invalid operand of S^#");
      else
	{
	  if (reg >= 0)
	    {
	      /* Darn! we saw S^#Rnn ! put the Rnn back in
	         expression. KLUDGE! Use oldq so we don't
	         need to know exact length of reg name.  */
	      q = oldq;
	      reg = 0;
	    }
	  /* We have all the expression we will ever get.  */
	  if (p > q)
	    err = _("S^# needs expression");
	  else if (access_mode == 'r')
	    {
	      err = " ";	/* WIN! */
	      mode = 0;
	    }
	  else
	    err = _("S^# may only read-access");
	}
    }
  
  /* Case of -(Rn), which is weird case.
    
     in:  at       0
          len      '
          hash     0
          p:q      q<p
          sign     -1                by definition
          paren    1              by definition
          reg      present           by definition
          ndx      optional
    
     out: mode     7
          reg      present
          len      ' '
          exp      ""                enforce empty expression
          ndx      optional          warn if same as reg.  */
  if ((!err || !*err) && sign < 0)
    {
      if (len != ' ' || hash || at || p <= q)
	err = _("invalid operand of -()");
      else
	{
	  err = " ";		/* win */
	  mode = 7;
	  if (reg == PC)
	    wrn = _("-(PC) unpredictable");
	  else if (reg == ndx)
	    wrn = _("[]index same as -()register: unpredictable");
	}
    }

  /* We convert "(Rn)" to "@@Rn" for our convenience.
     (I hope this is convenient: has someone got a better way to parse this?)
     A side-effect of this is that "@@Rn" is a valid operand.  */
  if (paren && !sign && !hash && !at && len == ' ' && p > q)
    {
      at = 1;
      paren = 0;
    }

  /* Case of (Rn)+, which is slightly different.
    
     in:  at
          len      ' '
          hash     0
          p:q      q<p
          sign     +1                by definition
          paren    1              by definition
          reg      present           by definition
          ndx      optional
    
     out: mode     8+@@
          reg      present
          len      ' '
          exp      ""                enforce empty expression
          ndx      optional          warn if same as reg.  */
  if ((!err || !*err) && sign > 0)
    {
      if (len != ' ' || hash || p <= q)
	err = _("invalid operand of ()+");
      else
	{
	  err = " ";		/* win */
	  mode = 8 + (at ? 1 : 0);
	  if (reg == PC)
	    wrn = _("(PC)+ unpredictable");
	  else if (reg == ndx)
	    wrn = _("[]index same as ()+register: unpredictable");
	}
    }

  /* Case of #, without S^.
    
     in:  at
          len      ' ' or 'i'
          hash     1              by definition
          p:q
          sign     0
          paren    0
          reg      absent
          ndx      optional
    
     out: mode     8+@@
          reg      PC
          len      ' ' or 'i'
          exp
          ndx      optional.  */
  if ((!err || !*err) && hash)
    {
      if (len != 'i' && len != ' ')
	err = _("# conflicts length");
      else if (paren)
	err = _("# bars register");
      else
	{
	  if (reg >= 0)
	    {
	      /* Darn! we saw #Rnn! Put the Rnn back into the expression.
	         By using oldq, we don't need to know how long Rnn was.
	         KLUDGE!  */
	      q = oldq;
	      reg = -1;		/* No register any more.  */
	    }
	  err = " ";		/* Win.  */

	  /* JF a bugfix, I think!  */
	  if (at && access_mode == 'a')
	    vopP->vop_nbytes = 4;

	  mode = (at ? 9 : 8);
	  reg = PC;
	  if ((access_mode == 'm' || access_mode == 'w') && !at)
	    wrn = _("writing or modifying # is unpredictable");
	}
    }
  /* If !*err, then       sign == 0
                          hash == 0 */

  /* Case of Rn. We separate this one because it has a few special
     errors the remaining modes lack.
    
     in:  at       optional
          len      ' '
          hash     0             by program logic
          p:q      empty
          sign     0                 by program logic
          paren    0             by definition
          reg      present           by definition
          ndx      optional
    
     out: mode     5+@@
          reg      present
          len      ' '               enforce no length
          exp      ""                enforce empty expression
          ndx      optional          warn if same as reg.  */
  if ((!err || !*err) && !paren && reg >= 0)
    {
      if (len != ' ')
	err = _("length not needed");
      else if (at)
	{
	  err = " ";		/* win */
	  mode = 6;		/* @@Rn */
	}
      else if (ndx >= 0)
	err = _("can't []index a register, because it has no address");
      else if (access_mode == 'a')
	err = _("a register has no address");
      else
	{
	  /* Idea here is to detect from length of datum
	     and from register number if we will touch PC.
	     Warn if we do.
	     vop_nbytes is number of bytes in operand.
	     Compute highest byte affected, compare to PC0.  */
	  if ((vopP->vop_nbytes + reg * 4) > 60)
	    wrn = _("PC part of operand unpredictable");
	  err = " ";		/* win */
	  mode = 5;		/* Rn */
	}
    }
  /* If !*err,        sign  == 0
                      hash  == 0
                      paren == 1  OR reg==-1  */

  /* Rest of cases fit into one bunch.
    
     in:  at       optional
          len      ' ' or 'b' or 'w' or 'l'
          hash     0             by program logic
          p:q      expected          (empty is not an error)
          sign     0                 by program logic
          paren    optional
          reg      optional
          ndx      optional
    
     out: mode     10 + @@ + len
          reg      optional
          len      ' ' or 'b' or 'w' or 'l'
          exp                        maybe empty
          ndx      optional          warn if same as reg.  */
  if (!err || !*err)
    {
      err = " ";		/* win (always) */
      mode = 10 + (at ? 1 : 0);
      switch (len)
	{
	case 'l':
	  mode += 2;
	case 'w':
	  mode += 2;
	case ' ':	/* Assumed B^ until our caller changes it.  */
	case 'b':
	  break;
	}
    }

  /* here with completely specified     mode
    					len
    					reg
    					expression   p,q
    					ndx.  */

  if (*err == ' ')
    err = 0;			/* " " is no longer an error.  */

  vopP->vop_mode = mode;
  vopP->vop_reg = reg;
  vopP->vop_short = len;
  vopP->vop_expr_begin = p;
  vopP->vop_expr_end = q;
  vopP->vop_ndx = ndx;
  vopP->vop_error = err;
  vopP->vop_warn = wrn;
}

/* This converts a string into a vax instruction.
   The string must be a bare single instruction in dec-vax (with BSD4 frobs)
   format.
   It provides some error messages: at most one fatal error message (which
   stops the scan) and at most one warning message for each operand.
   The vax instruction is returned in exploded form, since we have no
   knowledge of how you parse (or evaluate) your expressions.
   We do however strip off and decode addressing modes and operation
   mnemonic.
  
   The exploded instruction is returned to a struct vit of your choice.
   #include "vax-inst.h" to know what a struct vit is.
  
   This function's value is a string. If it is not "" then an internal
   logic error was found: read this code to assign meaning to the string.
   No argument string should generate such an error string:
   it means a bug in our code, not in the user's text.
  
   You MUST have called vip_begin() once before using this function.  */

static void
vip (struct vit *vitP,		/* We build an exploded instruction here.  */
     char *instring)		/* Text of a vax instruction: we modify.  */
{
  /* How to bit-encode this opcode.  */
  struct vot_wot *vwP;
  /* 1/skip whitespace.2/scan vot_how */
  char *p;
  char *q;
  /* counts number of operands seen */
  unsigned char count;
  /* scan operands in struct vit */
  struct vop *operandp;
  /* error over all operands */
  const char *alloperr;
  /* Remember char, (we clobber it with '\0' temporarily).  */
  char c;
  /* Op-code of this instruction.  */
  vax_opcodeT oc;

  if (*instring == ' ')
    ++instring;
  
  /* MUST end in end-of-string or exactly 1 space.  */
  for (p = instring; *p && *p != ' '; p++)
    ;

  /* Scanned up to end of operation-code.  */
  /* Operation-code is ended with whitespace.  */
  if (p - instring == 0)
    {
      vitP->vit_error = _("No operator");
      count = 0;
      memset (vitP->vit_opcode, '\0', sizeof (vitP->vit_opcode));
    }
  else
    {
      c = *p;
      *p = '\0';
      /* Here with instring pointing to what better be an op-name, and p
         pointing to character just past that.
         We trust instring points to an op-name, with no whitespace.  */
      vwP = (struct vot_wot *) hash_find (op_hash, instring);
      /* Restore char after op-code.  */
      *p = c;
      if (vwP == 0)
	{
	  vitP->vit_error = _("Unknown operator");
	  count = 0;
	  memset (vitP->vit_opcode, '\0', sizeof (vitP->vit_opcode));
	}
      else
	{
	  /* We found a match! So let's pick up as many operands as the
	     instruction wants, and even gripe if there are too many.
	     We expect comma to separate each operand.
	     We let instring track the text, while p tracks a part of the
	     struct vot.  */
	  const char *howp;
	  /* The lines below know about 2-byte opcodes starting FD,FE or FF.
	     They also understand synthetic opcodes. Note:
	     we return 32 bits of opcode, including bucky bits, BUT
	     an opcode length is either 8 or 16 bits for vit_opcode_nbytes.  */
	  oc = vwP->vot_code;	/* The op-code.  */
	  vitP->vit_opcode_nbytes = (oc & 0xFF) >= 0xFD ? 2 : 1;
	  md_number_to_chars (vitP->vit_opcode, oc, 4);
	  count = 0;		/* No operands seen yet.  */
	  instring = p;		/* Point just past operation code.  */
	  alloperr = "";
	  for (howp = vwP->vot_how, operandp = vitP->vit_operand;
	       !(alloperr && *alloperr) && *howp;
	       operandp++, howp += 2)
	    {
	      /* Here to parse one operand. Leave instring pointing just
	         past any one ',' that marks the end of this operand.  */
	      if (!howp[1])
		as_fatal (_("odd number of bytes in operand description"));
	      else if (*instring)
		{
		  for (q = instring; (c = *q) && c != ','; q++)
		    ;
		  /* Q points to ',' or '\0' that ends argument. C is that
		     character.  */
		  *q = 0;
		  operandp->vop_width = howp[1];
		  operandp->vop_nbytes = vax_operand_width_size[(unsigned) howp[1]];
		  operandp->vop_access = howp[0];
		  vip_op (instring, operandp);
		  *q = c;	/* Restore input text.  */
		  if (operandp->vop_error)
		    alloperr = _("Bad operand");
		  instring = q + (c ? 1 : 0);	/* Next operand (if any).  */
		  count++;	/*  Won another argument, may have an operr.  */
		}
	      else
		alloperr = _("Not enough operands");
	    }
	  if (!*alloperr)
	    {
	      if (*instring == ' ')
		instring++;
	      if (*instring)
		alloperr = _("Too many operands");
	    }
	  vitP->vit_error = alloperr;
	}
    }
  vitP->vit_operands = count;
}

#ifdef test

/* Test program for above.  */

struct vit myvit;		/* Build an exploded vax instruction here.  */
char answer[100];		/* Human types a line of vax assembler here.  */
char *mybug;			/* "" or an internal logic diagnostic.  */
int mycount;			/* Number of operands.  */
struct vop *myvop;		/* Scan operands from myvit.  */
int mysynth;			/* 1 means want synthetic opcodes.  */
char my_immediate[200];
char my_indirect[200];
char my_displen[200];

int
main (void)
{
  char *p;

  printf ("0 means no synthetic instructions.   ");
  printf ("Value for vip_begin?  ");
  gets (answer);
  sscanf (answer, "%d", &mysynth);
  printf ("Synthetic opcodes %s be included.\n", mysynth ? "will" : "will not");
  printf ("enter immediate symbols eg enter #   ");
  gets (my_immediate);
  printf ("enter indirect symbols  eg enter @@   ");
  gets (my_indirect);
  printf ("enter displen symbols   eg enter ^   ");
  gets (my_displen);

  if (p = vip_begin (mysynth, my_immediate, my_indirect, my_displen))
    error ("vip_begin=%s", p);

  printf ("An empty input line will quit you from the vax instruction parser\n");
  for (;;)
    {
      printf ("vax instruction: ");
      fflush (stdout);
      gets (answer);
      if (!*answer)
	break;		/* Out of for each input text loop.  */

      vip (& myvit, answer);
      if (*myvit.vit_error)
	printf ("ERR:\"%s\"\n", myvit.vit_error);

      printf ("opcode=");
      for (mycount = myvit.vit_opcode_nbytes, p = myvit.vit_opcode;
	   mycount;
	   mycount--, p++)
	printf ("%02x ", *p & 0xFF);

      printf ("   operand count=%d.\n", mycount = myvit.vit_operands);
      for (myvop = myvit.vit_operand; mycount; mycount--, myvop++)
	{
	  printf ("mode=%xx reg=%xx ndx=%xx len='%c'=%c%c%d. expr=\"",
		  myvop->vop_mode, myvop->vop_reg, myvop->vop_ndx,
		  myvop->vop_short, myvop->vop_access, myvop->vop_width,
		  myvop->vop_nbytes);
	  for (p = myvop->vop_expr_begin; p <= myvop->vop_expr_end; p++)
	    putchar (*p);

	  printf ("\"\n");
	  if (myvop->vop_error)
	    printf ("  err:\"%s\"\n", myvop->vop_error);

	  if (myvop->vop_warn)
	    printf ("  wrn:\"%s\"\n", myvop->vop_warn);
	}
    }
  vip_end ();
  exit (EXIT_SUCCESS);
}

#endif

#ifdef TEST			/* #Define to use this testbed.  */

/* Follows a test program for this function.
   We declare arrays non-local in case some of our tiny-minded machines
   default to small stacks. Also, helps with some debuggers.  */

char answer[100];		/* Human types into here.  */
char *p;			/*  */
char *myerr;
char *mywrn;
char *mybug;
char myaccess;
char mywidth;
char mymode;
char myreg;
char mylen;
char *myleft;
char *myright;
char myndx;
int my_operand_length;
char my_immediate[200];
char my_indirect[200];
char my_displen[200];

int
main (void)
{
  printf ("enter immediate symbols eg enter #   ");
  gets (my_immediate);
  printf ("enter indirect symbols  eg enter @@   ");
  gets (my_indirect);
  printf ("enter displen symbols   eg enter ^   ");
  gets (my_displen);
  vip_op_defaults (my_immediate, my_indirect, my_displen);

  for (;;)
    {
      printf ("access,width (eg 'ab' or 'wh') [empty line to quit] :  ");
      fflush (stdout);
      gets (answer);
      if (!answer[0])
	exit (EXIT_SUCCESS);
      myaccess = answer[0];
      mywidth = answer[1];
      switch (mywidth)
	{
	case 'b':
	  my_operand_length = 1;
	  break;
	case 'd':
	  my_operand_length = 8;
	  break;
	case 'f':
	  my_operand_length = 4;
	  break;
	case 'g':
	  my_operand_length = 16;
	  break;
	case 'h':
	  my_operand_length = 32;
	  break;
	case 'l':
	  my_operand_length = 4;
	  break;
	case 'o':
	  my_operand_length = 16;
	  break;
	case 'q':
	  my_operand_length = 8;
	  break;
	case 'w':
	  my_operand_length = 2;
	  break;
	case '!':
	case '?':
	case '-':
	  my_operand_length = 0;
	  break;

	default:
	  my_operand_length = 2;
	  printf ("I dn't understand access width %c\n", mywidth);
	  break;
	}
      printf ("VAX assembler instruction operand: ");
      fflush (stdout);
      gets (answer);
      mybug = vip_op (answer, myaccess, mywidth, my_operand_length,
		      &mymode, &myreg, &mylen, &myleft, &myright, &myndx,
		      &myerr, &mywrn);
      if (*myerr)
	{
	  printf ("error: \"%s\"\n", myerr);
	  if (*mybug)
	    printf (" bug: \"%s\"\n", mybug);
	}
      else
	{
	  if (*mywrn)
	    printf ("warning: \"%s\"\n", mywrn);
	  mumble ("mode", mymode);
	  mumble ("register", myreg);
	  mumble ("index", myndx);
	  printf ("width:'%c'  ", mylen);
	  printf ("expression: \"");
	  while (myleft <= myright)
	    putchar (*myleft++);
	  printf ("\"\n");
	}
    }
}

void
mumble (char *text, int value)
{
  printf ("%s:", text);
  if (value >= 0)
    printf ("%xx", value);
  else
    printf ("ABSENT");
  printf ("  ");
}

#endif

int md_short_jump_size = 3;
int md_long_jump_size = 6;

void
md_create_short_jump (char *ptr,
		      addressT from_addr,
		      addressT to_addr ATTRIBUTE_UNUSED,
		      fragS *frag ATTRIBUTE_UNUSED,
		      symbolS *to_symbol ATTRIBUTE_UNUSED)
{
  valueT offset;

  /* This former calculation was off by two:
      offset = to_addr - (from_addr + 1);
     We need to account for the one byte instruction and also its
     two byte operand.  */
  offset = to_addr - (from_addr + 1 + 2);
  *ptr++ = VAX_BRW;		/* Branch with word (16 bit) offset.  */
  md_number_to_chars (ptr, offset, 2);
}

void
md_create_long_jump (char *ptr,
		     addressT from_addr ATTRIBUTE_UNUSED,
		     addressT to_addr,
		     fragS *frag,
		     symbolS *to_symbol)
{
  valueT offset;

  offset = to_addr - S_GET_VALUE (to_symbol);
  *ptr++ = VAX_JMP;		/* Arbitrary jump.  */
  *ptr++ = VAX_ABSOLUTE_MODE;
  md_number_to_chars (ptr, offset, 4);
  fix_new (frag, ptr - frag->fr_literal, 4, to_symbol, (long) 0, 0, NO_RELOC);
}

#ifdef OBJ_VMS
const char *md_shortopts = "d:STt:V+1h:Hv::";
#elif defined(OBJ_ELF)
const char *md_shortopts = "d:STt:VkKQ:";
#else
const char *md_shortopts = "d:STt:V";
#endif
struct option md_longopts[] =
{
#ifdef OBJ_ELF
#define OPTION_PIC (OPTION_MD_BASE)
  { "pic", no_argument, NULL, OPTION_PIC },
#endif
  { NULL, no_argument, NULL, 0 }
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case 'S':
      as_warn (_("SYMBOL TABLE not implemented"));
      break;

    case 'T':
      as_warn (_("TOKEN TRACE not implemented"));
      break;

    case 'd':
      as_warn (_("Displacement length %s ignored!"), arg);
      break;

    case 't':
      as_warn (_("I don't need or use temp. file \"%s\"."), arg);
      break;

    case 'V':
      as_warn (_("I don't use an interpass file! -V ignored"));
      break;

#ifdef OBJ_VMS
    case '+':			/* For g++.  Hash any name > 31 chars long.  */
      flag_hash_long_names = 1;
      break;

    case '1':			/* For backward compatibility.  */
      flag_one = 1;
      break;

    case 'H':			/* Show new symbol after hash truncation.  */
      flag_show_after_trunc = 1;
      break;

    case 'h':			/* No hashing of mixed-case names.  */
      {
	extern char vms_name_mapping;
	vms_name_mapping = atoi (arg);
	flag_no_hash_mixed_case = 1;
      }
      break;

    case 'v':
      {
	extern char *compiler_version_string;

	if (!arg || !*arg || access (arg, 0) == 0)
	  return 0;		/* Have caller show the assembler version.  */
	compiler_version_string = arg;
      }
      break;
#endif

#ifdef OBJ_ELF
    case OPTION_PIC:
    case 'k':
      flag_want_pic = 1;
      break;			/* -pic, Position Independent Code.  */

     /* -Qy, -Qn: SVR4 arguments controlling whether a .comment
	section should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;
#endif

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
VAX options:\n\
-d LENGTH		ignored\n\
-J			ignored\n\
-S			ignored\n\
-t FILE			ignored\n\
-T			ignored\n\
-V			ignored\n"));
#ifdef OBJ_VMS
  fprintf (stream, _("\
VMS options:\n\
-+			hash encode names longer than 31 characters\n\
-1			`const' handling compatible with gcc 1.x\n\
-H			show new symbol after hash truncation\n\
-h NUM			don't hash mixed-case names, and adjust case:\n\
			0 = upper, 2 = lower, 3 = preserve case\n\
-v\"VERSION\"		code being assembled was produced by compiler \"VERSION\"\n"));
#endif
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}

/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
  /* Byte alignment is fine */
  return size;
}

/* Exactly what point is a PC-relative offset relative TO?
   On the vax, they're relative to the address of the offset, plus
   its size. */
long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;
  bfd_reloc_code_real_type code;

  if (fixp->fx_tcbit)
    abort ();

  if (fixp->fx_r_type != BFD_RELOC_NONE)
    {
      code = fixp->fx_r_type;

      if (fixp->fx_pcrel)
	{
	  switch (code)
	    {
	    case BFD_RELOC_8_PCREL:
	    case BFD_RELOC_16_PCREL:
	    case BFD_RELOC_32_PCREL:
#ifdef OBJ_ELF
	    case BFD_RELOC_8_GOT_PCREL:
	    case BFD_RELOC_16_GOT_PCREL:
	    case BFD_RELOC_32_GOT_PCREL:
	    case BFD_RELOC_8_PLT_PCREL:
	    case BFD_RELOC_16_PLT_PCREL:
	    case BFD_RELOC_32_PLT_PCREL:
#endif
	      break;
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("Cannot make %s relocation PC relative"),
			    bfd_get_reloc_code_name (code));
	    }
	}
    }
  else
    {
#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
      switch (F (fixp->fx_size, fixp->fx_pcrel))
	{
#define MAP(SZ,PCREL,TYPE)	case F(SZ,PCREL): code = (TYPE); break
	  MAP (1, 0, BFD_RELOC_8);
	  MAP (2, 0, BFD_RELOC_16);
	  MAP (4, 0, BFD_RELOC_32);
	  MAP (1, 1, BFD_RELOC_8_PCREL);
	  MAP (2, 1, BFD_RELOC_16_PCREL);
	  MAP (4, 1, BFD_RELOC_32_PCREL);
	default:
	  abort ();
	}
    }
#undef F
#undef MAP

  reloc = xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
#ifndef OBJ_ELF
  if (fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else
    reloc->addend = 0;
#else
  reloc->addend = fixp->fx_offset;
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  gas_assert (reloc->howto != 0);

  return reloc;
}

/* vax:md_assemble() emit frags for 1 instruction given in textual form.  */
void
md_assemble (char *instruction_string)
{
  /* Non-zero if operand expression's segment is not known yet.  */
  int is_undefined;
  /* Non-zero if operand expression's segment is absolute.  */
  int is_absolute;
  int length_code;
  char *p;
  /* An operand. Scans all operands.  */
  struct vop *operandP;
  char *save_input_line_pointer;
			/* What used to live after an expression.  */
  char c_save;
  /* 1: instruction_string bad for all passes.  */
  int goofed;
  /* Points to slot just after last operand.  */
  struct vop *end_operandP;
  /* Points to expression values for this operand.  */
  expressionS *expP;
  segT *segP;

  /* These refer to an instruction operand expression.  */
  /* Target segment of the address.	 */
  segT to_seg;
  valueT this_add_number;
  /* Positive (minuend) symbol.  */
  symbolS *this_add_symbol;
  /* As a number.  */
  long opcode_as_number;
  /* Least significant byte 1st.  */
  char *opcode_as_chars;
  /* As an array of characters.  */
  /* Least significant byte 1st */
  char *opcode_low_byteP;
  /* length (bytes) meant by vop_short.  */
  int length;
  /* 0, or 1 if '@@' is in addressing mode.  */
  int at;
  /* From vop_nbytes: vax_operand_width (in bytes) */
  int nbytes;
  FLONUM_TYPE *floatP;
  LITTLENUM_TYPE literal_float[8];
  /* Big enough for any floating point literal.  */

  vip (&v, instruction_string);

  /* Now we try to find as many as_warn()s as we can. If we do any as_warn()s
     then goofed=1. Notice that we don't make any frags yet.
     Should goofed be 1, then this instruction will wedge in any pass,
     and we can safely flush it, without causing interpass symbol phase
     errors. That is, without changing label values in different passes.  */
  if ((goofed = (*v.vit_error)) != 0)
    {
      as_fatal (_("Ignoring statement due to \"%s\""), v.vit_error);
    }
  /* We need to use expression() and friends, which require us to diddle
     input_line_pointer. So we save it and restore it later.  */
  save_input_line_pointer = input_line_pointer;
  for (operandP = v.vit_operand,
       expP = exp_of_operand,
       segP = seg_of_operand,
       floatP = float_operand,
       end_operandP = v.vit_operand + v.vit_operands;

       operandP < end_operandP;

       operandP++, expP++, segP++, floatP++)
    {
      if (operandP->vop_error)
	{
	  as_fatal (_("Aborting because statement has \"%s\""), operandP->vop_error);
	  goofed = 1;
	}
      else
	{
	  /* Statement has no syntax goofs: let's sniff the expression.  */
	  int can_be_short = 0;	/* 1 if a bignum can be reduced to a short literal.  */

	  input_line_pointer = operandP->vop_expr_begin;
	  c_save = operandP->vop_expr_end[1];
	  operandP->vop_expr_end[1] = '\0';
	  /* If to_seg == SEG_PASS1, expression() will have set need_pass_2 = 1.  */
	  *segP = expression (expP);
	  switch (expP->X_op)
	    {
	    case O_absent:
	      /* for BSD4.2 compatibility, missing expression is absolute 0 */
	      expP->X_op = O_constant;
	      expP->X_add_number = 0;
	      /* For SEG_ABSOLUTE, we shouldn't need to set X_op_symbol,
		 X_add_symbol to any particular value.  But, we will program
		 defensively. Since this situation occurs rarely so it costs
		 us little to do, and stops Dean worrying about the origin of
		 random bits in expressionS's.  */
	      expP->X_add_symbol = NULL;
	      expP->X_op_symbol = NULL;
	      break;

	    case O_symbol:
	    case O_constant:
	      break;

	    default:
	      /* Major bug. We can't handle the case of a
	         SEG_OP expression in a VIT_OPCODE_SYNTHETIC
	         variable-length instruction.
	         We don't have a frag type that is smart enough to
	         relax a SEG_OP, and so we just force all
	         SEG_OPs to behave like SEG_PASS1s.
	         Clearly, if there is a demand we can invent a new or
	         modified frag type and then coding up a frag for this
	         case will be easy. SEG_OP was invented for the
	         .words after a CASE opcode, and was never intended for
	         instruction operands.  */
	      need_pass_2 = 1;
	      as_fatal (_("Can't relocate expression"));
	      break;

	    case O_big:
	      /* Preserve the bits.  */
	      if (expP->X_add_number > 0)
		{
		  bignum_copy (generic_bignum, expP->X_add_number,
			       floatP->low, SIZE_OF_LARGE_NUMBER);
		}
	      else
		{
		  know (expP->X_add_number < 0);
		  flonum_copy (&generic_floating_point_number,
			       floatP);
		  if (strchr ("s i", operandP->vop_short))
		    {
		      /* Could possibly become S^# */
		      flonum_gen2vax (-expP->X_add_number, floatP, literal_float);
		      switch (-expP->X_add_number)
			{
			case 'f':
			  can_be_short =
			    (literal_float[0] & 0xFC0F) == 0x4000
			    && literal_float[1] == 0;
			  break;

			case 'd':
			  can_be_short =
			    (literal_float[0] & 0xFC0F) == 0x4000
			    && literal_float[1] == 0
			    && literal_float[2] == 0
			    && literal_float[3] == 0;
			  break;

			case 'g':
			  can_be_short =
			    (literal_float[0] & 0xFF81) == 0x4000
			    && literal_float[1] == 0
			    && literal_float[2] == 0
			    && literal_float[3] == 0;
			  break;

			case 'h':
			  can_be_short = ((literal_float[0] & 0xFFF8) == 0x4000
					  && (literal_float[1] & 0xE000) == 0
					  && literal_float[2] == 0
					  && literal_float[3] == 0
					  && literal_float[4] == 0
					  && literal_float[5] == 0
					  && literal_float[6] == 0
					  && literal_float[7] == 0);
			  break;

			default:
			  BAD_CASE (-expP->X_add_number);
			  break;
			}
		    }
		}

	      if (operandP->vop_short == 's'
		  || operandP->vop_short == 'i'
		  || (operandP->vop_short == ' '
		      && operandP->vop_reg == 0xF
		      && (operandP->vop_mode & 0xE) == 0x8))
		{
		  /* Saw a '#'.  */
		  if (operandP->vop_short == ' ')
		    {
		      /* We must chose S^ or I^.  */
		      if (expP->X_add_number > 0)
			{
			  /* Bignum: Short literal impossible.  */
			  operandP->vop_short = 'i';
			  operandP->vop_mode = 8;
			  operandP->vop_reg = 0xF;	/* VAX PC.  */
			}
		      else
			{
			  /* Flonum: Try to do it.  */
			  if (can_be_short)
			    {
			      operandP->vop_short = 's';
			      operandP->vop_mode = 0;
			      operandP->vop_ndx = -1;
			      operandP->vop_reg = -1;
			      expP->X_op = O_constant;
			    }
			  else
			    {
			      operandP->vop_short = 'i';
			      operandP->vop_mode = 8;
			      operandP->vop_reg = 0xF;	/* VAX PC */
			    }
			}	/* bignum or flonum ? */
		    }		/*  if #, but no S^ or I^ seen.  */
		  /* No more ' ' case: either 's' or 'i'.  */
		  if (operandP->vop_short == 's')
		    {
		      /* Wants to be a short literal.  */
		      if (expP->X_add_number > 0)
			{
			  as_warn (_("Bignum not permitted in short literal. Immediate mode assumed."));
			  operandP->vop_short = 'i';
			  operandP->vop_mode = 8;
			  operandP->vop_reg = 0xF;	/* VAX PC.  */
			}
		      else
			{
			  if (!can_be_short)
			    {
			      as_warn (_("Can't do flonum short literal: immediate mode used."));
			      operandP->vop_short = 'i';
			      operandP->vop_mode = 8;
			      operandP->vop_reg = 0xF;	/* VAX PC.  */
			    }
			  else
			    {
			      /* Encode short literal now.  */
			      int temp = 0;

			      switch (-expP->X_add_number)
				{
				case 'f':
				case 'd':
				  temp = literal_float[0] >> 4;
				  break;

				case 'g':
				  temp = literal_float[0] >> 1;
				  break;

				case 'h':
				  temp = ((literal_float[0] << 3) & 070)
				    | ((literal_float[1] >> 13) & 07);
				  break;

				default:
				  BAD_CASE (-expP->X_add_number);
				  break;
				}

			      floatP->low[0] = temp & 077;
			      floatP->low[1] = 0;
			    }
			}
		    }
		  else
		    {
		      /* I^# seen: set it up if float.  */
		      if (expP->X_add_number < 0)
			{
			  memcpy (floatP->low, literal_float, sizeof (literal_float));
			}
		    }		/* if S^# seen.  */
		}
	      else
		{
		  as_warn (_("A bignum/flonum may not be a displacement: 0x%lx used"),
			   (expP->X_add_number = 0x80000000L));
		  /* Chosen so luser gets the most offset bits to patch later.  */
		}
	      expP->X_add_number = floatP->low[0]
		| ((LITTLENUM_MASK & (floatP->low[1])) << LITTLENUM_NUMBER_OF_BITS);

	      /* For the O_big case we have:
	         If vop_short == 's' then a short floating literal is in the
	        	lowest 6 bits of floatP -> low [0], which is
	        	big_operand_bits [---] [0].
	         If vop_short == 'i' then the appropriate number of elements
	        	of big_operand_bits [---] [...] are set up with the correct
	        	bits.
	         Also, just in case width is byte word or long, we copy the lowest
	         32 bits of the number to X_add_number.  */
	      break;
	    }
	  if (input_line_pointer != operandP->vop_expr_end + 1)
	    {
	      as_fatal ("Junk at end of expression \"%s\"", input_line_pointer);
	      goofed = 1;
	    }
	  operandP->vop_expr_end[1] = c_save;
	}
    }

  input_line_pointer = save_input_line_pointer;

  if (need_pass_2 || goofed)
    return;

  dwarf2_emit_insn (0);
  /* Emit op-code.  */
  /* Remember where it is, in case we want to modify the op-code later.  */
  opcode_low_byteP = frag_more (v.vit_opcode_nbytes);
  memcpy (opcode_low_byteP, v.vit_opcode, v.vit_opcode_nbytes);
  opcode_as_chars = v.vit_opcode;
  opcode_as_number = md_chars_to_number ((unsigned char *) opcode_as_chars, 4);
  for (operandP = v.vit_operand,
       expP = exp_of_operand,
       segP = seg_of_operand,
       floatP = float_operand,
       end_operandP = v.vit_operand + v.vit_operands;

       operandP < end_operandP;

       operandP++,
       floatP++,
       segP++,
       expP++)
    {
      if (operandP->vop_ndx >= 0)
	{
	  /* Indexed addressing byte.  */
	  /* Legality of indexed mode already checked: it is OK.  */
	  FRAG_APPEND_1_CHAR (0x40 + operandP->vop_ndx);
	}			/* if(vop_ndx>=0) */

      /* Here to make main operand frag(s).  */
      this_add_number = expP->X_add_number;
      this_add_symbol = expP->X_add_symbol;
      to_seg = *segP;
      is_undefined = (to_seg == undefined_section);
      is_absolute = (to_seg == absolute_section);
      at = operandP->vop_mode & 1;
      length = (operandP->vop_short == 'b'
		? 1 : (operandP->vop_short == 'w'
		       ? 2 : (operandP->vop_short == 'l'
			      ? 4 : 0)));
      nbytes = operandP->vop_nbytes;
      if (operandP->vop_access == 'b')
	{
	  if (to_seg == now_seg || is_undefined)
	    {
	      /* If is_undefined, then it might BECOME now_seg.  */
	      if (nbytes)
		{
		  p = frag_more (nbytes);
		  fix_new (frag_now, p - frag_now->fr_literal, nbytes,
			   this_add_symbol, this_add_number, 1, NO_RELOC);
		}
	      else
		{
		  /* to_seg==now_seg || to_seg == SEG_UNKNOWN */
		  /* nbytes==0 */
		  length_code = is_undefined ? STATE_UNDF : STATE_BYTE;
		  if (opcode_as_number & VIT_OPCODE_SPECIAL)
		    {
		      if (operandP->vop_width == VAX_WIDTH_UNCONDITIONAL_JUMP)
			{
			  /* br or jsb */
			  frag_var (rs_machine_dependent, 5, 1,
			    ENCODE_RELAX (STATE_ALWAYS_BRANCH, length_code),
				    this_add_symbol, this_add_number,
				    opcode_low_byteP);
			}
		      else
			{
			  if (operandP->vop_width == VAX_WIDTH_WORD_JUMP)
			    {
			      length_code = STATE_WORD;
			      /* JF: There is no state_byte for this one! */
			      frag_var (rs_machine_dependent, 10, 2,
					ENCODE_RELAX (STATE_COMPLEX_BRANCH, length_code),
					this_add_symbol, this_add_number,
					opcode_low_byteP);
			    }
			  else
			    {
			      know (operandP->vop_width == VAX_WIDTH_BYTE_JUMP);
			      frag_var (rs_machine_dependent, 9, 1,
			      ENCODE_RELAX (STATE_COMPLEX_HOP, length_code),
					this_add_symbol, this_add_number,
					opcode_low_byteP);
			    }
			}
		    }
		  else
		    {
		      know (operandP->vop_width == VAX_WIDTH_CONDITIONAL_JUMP);
		      frag_var (rs_machine_dependent, 7, 1,
		       ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, length_code),
				this_add_symbol, this_add_number,
				opcode_low_byteP);
		    }
		}
	    }
	  else
	    {
	      /* to_seg != now_seg && to_seg != SEG_UNKNOWN */
	      /* --- SEG FLOAT MAY APPEAR HERE ---  */
	      if (is_absolute)
		{
		  if (nbytes)
		    {
		      know (!(opcode_as_number & VIT_OPCODE_SYNTHETIC));
		      p = frag_more (nbytes);
		      /* Conventional relocation.  */
		      fix_new (frag_now, p - frag_now->fr_literal, nbytes,
			       section_symbol (absolute_section),
			       this_add_number, 1, NO_RELOC);
		    }
		  else
		    {
		      know (opcode_as_number & VIT_OPCODE_SYNTHETIC);
		      if (opcode_as_number & VIT_OPCODE_SPECIAL)
			{
			  if (operandP->vop_width == VAX_WIDTH_UNCONDITIONAL_JUMP)
			    {
			      /* br or jsb */
			      *opcode_low_byteP = opcode_as_chars[0] + VAX_WIDEN_LONG;
			      know (opcode_as_chars[1] == 0);
			      p = frag_more (5);
			      p[0] = VAX_ABSOLUTE_MODE;	/* @@#...  */
			      md_number_to_chars (p + 1, this_add_number, 4);
			      /* Now (eg) JMP @@#foo or JSB @@#foo.  */
			    }
			  else
			    {
			      if (operandP->vop_width == VAX_WIDTH_WORD_JUMP)
				{
				  p = frag_more (10);
				  p[0] = 2;
				  p[1] = 0;
				  p[2] = VAX_BRB;
				  p[3] = 6;
				  p[4] = VAX_JMP;
				  p[5] = VAX_ABSOLUTE_MODE;	/* @@#...  */
				  md_number_to_chars (p + 6, this_add_number, 4);
				  /* Now (eg)	ACBx	1f
				    		BRB	2f
				    	1:	JMP	@@#foo
				    	2:  */
				}
			      else
				{
				  know (operandP->vop_width == VAX_WIDTH_BYTE_JUMP);
				  p = frag_more (9);
				  p[0] = 2;
				  p[1] = VAX_BRB;
				  p[2] = 6;
				  p[3] = VAX_JMP;
                                  p[4] = VAX_ABSOLUTE_MODE;     /* @@#...  */
				  md_number_to_chars (p + 5, this_add_number, 4);
				  /* Now (eg)	xOBxxx	1f
				   		BRB	2f
				   	1:	JMP	@@#foo
				   	2:  */
				}
			    }
			}
		      else
			{
			  /* b<cond> */
			  *opcode_low_byteP ^= 1;
			  /* To reverse the condition in a VAX branch,
			     complement the lowest order bit.  */
			  p = frag_more (7);
			  p[0] = 6;
			  p[1] = VAX_JMP;
			  p[2] = VAX_ABSOLUTE_MODE;	/* @@#...  */
			  md_number_to_chars (p + 3, this_add_number, 4);
			  /* Now (eg)	BLEQ	1f
			   		JMP	@@#foo
			   	1:  */
			}
		    }
		}
	      else
		{
		  /* to_seg != now_seg && !is_undefinfed && !is_absolute */
		  if (nbytes > 0)
		    {
		      /* Pc-relative. Conventional relocation.  */
		      know (!(opcode_as_number & VIT_OPCODE_SYNTHETIC));
		      p = frag_more (nbytes);
		      fix_new (frag_now, p - frag_now->fr_literal, nbytes,
			       section_symbol (absolute_section),
			       this_add_number, 1, NO_RELOC);
		    }
		  else
		    {
		      know (opcode_as_number & VIT_OPCODE_SYNTHETIC);
		      if (opcode_as_number & VIT_OPCODE_SPECIAL)
			{
			  if (operandP->vop_width == VAX_WIDTH_UNCONDITIONAL_JUMP)
			    {
			      /* br or jsb */
			      know (opcode_as_chars[1] == 0);
			      *opcode_low_byteP = opcode_as_chars[0] + VAX_WIDEN_LONG;
			      p = frag_more (5);
			      p[0] = VAX_PC_RELATIVE_MODE;
			      fix_new (frag_now,
				       p + 1 - frag_now->fr_literal, 4,
				       this_add_symbol,
				       this_add_number, 1, NO_RELOC);
			      /* Now eg JMP foo or JSB foo.  */
			    }
			  else
			    {
			      if (operandP->vop_width == VAX_WIDTH_WORD_JUMP)
				{
				  p = frag_more (10);
				  p[0] = 0;
				  p[1] = 2;
				  p[2] = VAX_BRB;
				  p[3] = 6;
				  p[4] = VAX_JMP;
				  p[5] = VAX_PC_RELATIVE_MODE;
				  fix_new (frag_now,
					   p + 6 - frag_now->fr_literal, 4,
					   this_add_symbol,
					   this_add_number, 1, NO_RELOC);
				  /* Now (eg)	ACBx	1f
				   		BRB	2f
				   	1:	JMP	foo
				   	2:  */
				}
			      else
				{
				  know (operandP->vop_width == VAX_WIDTH_BYTE_JUMP);
				  p = frag_more (10);
				  p[0] = 2;
				  p[1] = VAX_BRB;
				  p[2] = 6;
				  p[3] = VAX_JMP;
				  p[4] = VAX_PC_RELATIVE_MODE;
				  fix_new (frag_now,
					   p + 5 - frag_now->fr_literal,
					   4, this_add_symbol,
					   this_add_number, 1, NO_RELOC);
				  /* Now (eg)	xOBxxx	1f
				   		BRB	2f
				   	1:	JMP	foo
				   	2:  */
				}
			    }
			}
		      else
			{
			  know (operandP->vop_width == VAX_WIDTH_CONDITIONAL_JUMP);
			  *opcode_low_byteP ^= 1;	/* Reverse branch condition.  */
			  p = frag_more (7);
			  p[0] = 6;
			  p[1] = VAX_JMP;
			  p[2] = VAX_PC_RELATIVE_MODE;
			  fix_new (frag_now, p + 3 - frag_now->fr_literal,
				   4, this_add_symbol,
				   this_add_number, 1, NO_RELOC);
			}
		    }
		}
	    }
	}
      else
	{
	  /* So it is ordinary operand.  */
	  know (operandP->vop_access != 'b');
	  /* ' ' target-independent: elsewhere.  */
	  know (operandP->vop_access != ' ');
	  know (operandP->vop_access == 'a'
		|| operandP->vop_access == 'm'
		|| operandP->vop_access == 'r'
		|| operandP->vop_access == 'v'
		|| operandP->vop_access == 'w');
	  if (operandP->vop_short == 's')
	    {
	      if (is_absolute)
		{
		  if (this_add_number >= 64)
		    {
		      as_warn (_("Short literal overflow(%ld.), immediate mode assumed."),
			       (long) this_add_number);
		      operandP->vop_short = 'i';
		      operandP->vop_mode = 8;
		      operandP->vop_reg = 0xF;
		    }
		}
	      else
		{
		  as_warn (_("Forced short literal to immediate mode. now_seg=%s to_seg=%s"),
			   segment_name (now_seg), segment_name (to_seg));
		  operandP->vop_short = 'i';
		  operandP->vop_mode = 8;
		  operandP->vop_reg = 0xF;
		}
	    }
	  if (operandP->vop_reg >= 0 && (operandP->vop_mode < 8
		  || (operandP->vop_reg != 0xF && operandP->vop_mode < 10)))
	    {
	      /* One byte operand.  */
	      know (operandP->vop_mode > 3);
	      FRAG_APPEND_1_CHAR (operandP->vop_mode << 4 | operandP->vop_reg);
	      /* All 1-bytes except S^# happen here.  */
	    }
	  else
	    {
	      /* {@@}{q^}foo{(Rn)} or S^#foo */
	      if (operandP->vop_reg == -1 && operandP->vop_short != 's')
		{
		  /* "{@@}{q^}foo" */
		  if (to_seg == now_seg)
		    {
		      if (length == 0)
			{
			  know (operandP->vop_short == ' ');
			  length_code = STATE_BYTE;
#ifdef OBJ_ELF
			  if (S_IS_EXTERNAL (this_add_symbol)
			      || S_IS_WEAK (this_add_symbol))
			    length_code = STATE_UNDF;
#endif
			  p = frag_var (rs_machine_dependent, 10, 2,
			       ENCODE_RELAX (STATE_PC_RELATIVE, length_code),
					this_add_symbol, this_add_number,
					opcode_low_byteP);
			  know (operandP->vop_mode == 10 + at);
			  *p = at << 4;
			  /* At is the only context we need to carry
			     to other side of relax() process.  Must
			     be in the correct bit position of VAX
			     operand spec. byte.  */
			}
		      else
			{
			  know (length);
			  know (operandP->vop_short != ' ');
			  p = frag_more (length + 1);
			  p[0] = 0xF | ((at + "?\12\14?\16"[length]) << 4);
			  fix_new (frag_now, p + 1 - frag_now->fr_literal,
				   length, this_add_symbol,
				   this_add_number, 1, NO_RELOC);
			}
		    }
		  else
		    {
		      /* to_seg != now_seg */
		      if (this_add_symbol == NULL)
			{
			  know (is_absolute);
			  /* Do @@#foo: simpler relocation than foo-.(pc) anyway.  */
			  p = frag_more (5);
			  p[0] = VAX_ABSOLUTE_MODE;	/* @@#...  */
			  md_number_to_chars (p + 1, this_add_number, 4);
			  if (length && length != 4)
			    as_warn (_("Length specification ignored. Address mode 9F used"));
			}
		      else
			{
			  /* {@@}{q^}other_seg */
			  know ((length == 0 && operandP->vop_short == ' ')
			     || (length > 0 && operandP->vop_short != ' '));
			  if (is_undefined
#ifdef OBJ_ELF
			      || S_IS_WEAK(this_add_symbol)
			      || S_IS_EXTERNAL(this_add_symbol)
#endif
			      )
			    {
			      switch (length)
				{
				default: length_code = STATE_UNDF; break;
				case 1: length_code = STATE_BYTE; break;
				case 2: length_code = STATE_WORD; break;
				case 4: length_code = STATE_LONG; break;
				}
			      /* We have a SEG_UNKNOWN symbol. It might
			         turn out to be in the same segment as
			         the instruction, permitting relaxation.  */
			      p = frag_var (rs_machine_dependent, 5, 2,
			       ENCODE_RELAX (STATE_PC_RELATIVE, length_code),
					    this_add_symbol, this_add_number,
					    opcode_low_byteP);
			      p[0] = at << 4;
			    }
			  else
			    {
			      if (length == 0)
				{
				  know (operandP->vop_short == ' ');
				  length = 4;	/* Longest possible.  */
				}
			      p = frag_more (length + 1);
			      p[0] = 0xF | ((at + "?\12\14?\16"[length]) << 4);
			      md_number_to_chars (p + 1, this_add_number, length);
			      fix_new (frag_now,
				       p + 1 - frag_now->fr_literal,
				       length, this_add_symbol,
				       this_add_number, 1, NO_RELOC);
			    }
			}
		    }
		}
	      else
		{
		  /* {@@}{q^}foo(Rn) or S^# or I^# or # */
		  if (operandP->vop_mode < 0xA)
		    {
		      /* # or S^# or I^# */
		      if (operandP->vop_access == 'v'
			  || operandP->vop_access == 'a')
			{
			  if (operandP->vop_access == 'v')
			    as_warn (_("Invalid operand:  immediate value used as base address."));
			  else
			    as_warn (_("Invalid operand:  immediate value used as address."));
			  /* gcc 2.6.3 is known to generate these in at least
			     one case.  */
			}
		      if (length == 0
			  && is_absolute && (expP->X_op != O_big)
			  && operandP->vop_mode == 8	/* No '@@'.  */
			  && this_add_number < 64)
			{
			  operandP->vop_short = 's';
			}
		      if (operandP->vop_short == 's')
			{
			  FRAG_APPEND_1_CHAR (this_add_number);
			}
		      else
			{
			  /* I^#...  */
			  know (nbytes);
			  p = frag_more (nbytes + 1);
			  know (operandP->vop_reg == 0xF);
#ifdef OBJ_ELF
			  if (flag_want_pic && operandP->vop_mode == 8
				&& this_add_symbol != NULL)
			    {
			      as_warn (_("Symbol %s used as immediate operand in PIC mode."),
				       S_GET_NAME (this_add_symbol));
			    }
#endif
			  p[0] = (operandP->vop_mode << 4) | 0xF;
			  if ((is_absolute) && (expP->X_op != O_big))
			    {
			      /* If nbytes > 4, then we are scrod. We
			         don't know if the high order bytes
			         are to be 0xFF or 0x00.  BSD4.2 & RMS
			         say use 0x00. OK --- but this
			         assembler needs ANOTHER rewrite to
			         cope properly with this bug.  */
			      md_number_to_chars (p + 1, this_add_number,
						  min (sizeof (valueT),
						       (size_t) nbytes));
			      if ((size_t) nbytes > sizeof (valueT))
				memset (p + 1 + sizeof (valueT),
				        '\0', nbytes - sizeof (valueT));
			    }
			  else
			    {
			      if (expP->X_op == O_big)
				{
				  /* Problem here is to get the bytes
				     in the right order.  We stored
				     our constant as LITTLENUMs, not
				     bytes.  */
				  LITTLENUM_TYPE *lP;

				  lP = floatP->low;
				  if (nbytes & 1)
				    {
				      know (nbytes == 1);
				      p[1] = *lP;
				    }
				  else
				    {
				      for (p++; nbytes; nbytes -= 2, p += 2, lP++)
					md_number_to_chars (p, *lP, 2);
				    }
				}
			      else
				{
				  fix_new (frag_now, p + 1 - frag_now->fr_literal,
					   nbytes, this_add_symbol,
					   this_add_number, 0, NO_RELOC);
				}
			    }
			}
		    }
		  else
		    {
		      /* {@@}{q^}foo(Rn) */
		      know ((length == 0 && operandP->vop_short == ' ')
			    || (length > 0 && operandP->vop_short != ' '));
		      if (length == 0)
			{
			  if (is_absolute)
			    {
			      long test;

			      test = this_add_number;

			      if (test < 0)
				test = ~test;

			      length = test & 0xffff8000 ? 4
				: test & 0xffffff80 ? 2
				: 1;
			    }
			  else
			    {
			      length = 4;
			    }
			}
		      p = frag_more (1 + length);
		      know (operandP->vop_reg >= 0);
		      p[0] = operandP->vop_reg
			| ((at | "?\12\14?\16"[length]) << 4);
		      if (is_absolute)
			{
			  md_number_to_chars (p + 1, this_add_number, length);
			}
		      else
			{
			  fix_new (frag_now, p + 1 - frag_now->fr_literal,
				   length, this_add_symbol,
				   this_add_number, 0, NO_RELOC);
			}
		    }
		}
	    }
	}
    }
}

void
md_begin (void)
{
  const char *errtxt;
  FLONUM_TYPE *fP;
  int i;

  if ((errtxt = vip_begin (1, "$", "*", "`")) != 0)
    as_fatal (_("VIP_BEGIN error:%s"), errtxt);

  for (i = 0, fP = float_operand;
       fP < float_operand + VIT_MAX_OPERANDS;
       i++, fP++)
    {
      fP->low = &big_operand_bits[i][0];
      fP->high = &big_operand_bits[i][SIZE_OF_LARGE_NUMBER - 1];
    }
}

static char *vax_cons_special_reloc;

void
vax_cons (expressionS *exp, int size)
{
  char *save;

  SKIP_WHITESPACE ();
  vax_cons_special_reloc = NULL;
  save = input_line_pointer;
  if (input_line_pointer[0] == '%')
    {
      if (strncmp (input_line_pointer + 1, "pcrel", 5) == 0)
	{
	  input_line_pointer += 6;
	  vax_cons_special_reloc = "pcrel";
	}
      if (vax_cons_special_reloc)
	{
	  int bad = 0;

	  switch (size)
	    {
	    case 1:
	      if (*input_line_pointer != '8')
		bad = 1;
	      input_line_pointer--;
	      break;
	    case 2:
	      if (input_line_pointer[0] != '1' || input_line_pointer[1] != '6')
		bad = 1;
	      break;
	    case 4:
	      if (input_line_pointer[0] != '3' || input_line_pointer[1] != '2')
		bad = 1;
	      break;
	    default:
	      bad = 1;
	      break;
	    }

	  if (bad)
	    {
	      as_bad (_("Illegal operands: Only %%r_%s%d allowed in %d-byte data fields"),
		      vax_cons_special_reloc, size * 8, size);
	    }
	  else
	    {
	      input_line_pointer += 2;
	      if (*input_line_pointer != '(')
		{
		  as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			  vax_cons_special_reloc, size * 8);
		  bad = 1;
		}
	    }

	  if (bad)
	    {
	      input_line_pointer = save;
	      vax_cons_special_reloc = NULL;
	    }
	  else
	    {
	      int c;
	      char *end = ++input_line_pointer;
	      int npar = 0;

	      while (! is_end_of_line[(c = *end)])
		{
		  if (c == '(')
	  	    npar++;
		  else if (c == ')')
	  	    {
		      if (!npar)
	      		break;
		      npar--;
		    }
	    	  end++;
		}

	      if (c != ')')
		as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			vax_cons_special_reloc, size * 8);
	      else
		{
		  *end = '\0';
		  expression (exp);
		  *end = c;
		  if (input_line_pointer != end)
		    {
		      as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			      vax_cons_special_reloc, size * 8);
		    }
		  else
		    {
		      input_line_pointer++;
		      SKIP_WHITESPACE ();
		      c = *input_line_pointer;
		      if (! is_end_of_line[c] && c != ',')
			as_bad (_("Illegal operands: garbage after %%r_%s%d()"),
			        vax_cons_special_reloc, size * 8);
		    }
		}
	    }
	}
    }
  if (vax_cons_special_reloc == NULL)
    expression (exp);
}

/* This is called by emit_expr via TC_CONS_FIX_NEW when creating a
   reloc for a cons.  */

void
vax_cons_fix_new (fragS *frag, int where, unsigned int nbytes, expressionS *exp)
{
  bfd_reloc_code_real_type r;

  r = (nbytes == 1 ? BFD_RELOC_8 :
       (nbytes == 2 ? BFD_RELOC_16 : BFD_RELOC_32));

  if (vax_cons_special_reloc)
    {
      if (*vax_cons_special_reloc == 'p')
	{
	  switch (nbytes)
	    {
	    case 1: r = BFD_RELOC_8_PCREL; break;
	    case 2: r = BFD_RELOC_16_PCREL; break;
	    case 4: r = BFD_RELOC_32_PCREL; break;
	    default: abort ();
	    }
	}
    }

  fix_new_exp (frag, where, (int) nbytes, exp, 0, r);
  vax_cons_special_reloc = NULL;
}

char *
md_atof (int type, char * litP, int * sizeP)
{
  return vax_md_atof (type, litP, sizeP);
}
@


1.42
log
@	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009
a1273 1
  char width;			/* vop_width.  */
a1275 1
  width = vopP->vop_width;
@


1.41
log
@update copyright dates
@
text
@d2716 1
@


1.41.2.1
log
@gas/
	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
gas/testsuite/
	* gas/d30v/serial2.l: Adjust position of page break.
	* gas/lns/lns-common-1-alt.d: Match 2009-04-24 change.
	* gas/mt/ms1-16-003.d: Correct reloc name.
	* gas/mt/relocs.d: Elide incorrect file format strings.
@
text
@a2715 1
  dwarf2_emit_insn (0);
@


1.40
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008
@


1.39
log
@bfd/
* elf32-vax.c (elf_vax_check_relocs): Handle the visibility
attribute.
(elf_vax_relocate_section): Likewise.

gas/
* config/tc-vax.c (md_estimate_size_before_relax): Accept
indirect symbol references in the PIC mode and emit a
PC-relative relocation instead of a GOT/PLT one.  Likewise
for symbols known to be hidden at this point.
@
text
@d2403 1
a2403 1
  assert (reloc->howto != 0);
@


1.38
log
@2009-04-01	Matt Thomas  <matt@@netbsd.org>

	* config/tc-vax.c (synthetic_votstrs): add "jbbcci" and "jbbssi"
	(md_assemble): emit symbol name when used as immediate in PIC mode.
	(md_assemble): fix LP64 bug (use sizeof (valueT) instead 4).
@
text
@d399 12
a410 6
	      if (p[0] & 0x10)
		{
		  if (flag_want_pic)
		    as_fatal ("PIC reference to %s is indirect.\n",
			      S_GET_NAME (fragP->fr_symbol));
		}
d412 1
a412 10
		{
		  if (((unsigned char *) fragP->fr_opcode)[0] == VAX_CALLS
		      || ((unsigned char *) fragP->fr_opcode)[0] == VAX_CALLG
		      || ((unsigned char *) fragP->fr_opcode)[0] == VAX_JSB
		      || ((unsigned char *) fragP->fr_opcode)[0] == VAX_JMP
		      || S_IS_FUNCTION (fragP->fr_symbol))
		    reloc_type = BFD_RELOC_32_PLT_PCREL;
		  else
		    reloc_type = BFD_RELOC_32_GOT_PCREL;
		}
@


1.37
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d855 2
d3157 2
a3158 1
			      as_warn (_("Symbol used as immediate operand in PIC mode."));
d3174 2
a3175 1
				memset (p + 5, '\0', nbytes - sizeof (valueT));
@


1.36
log
@Remove duplicate definitions of the md_atof() function
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007
d962 1
a962 1
    retval = hash_insert (op_hash, vP->vot_name, (PTR) &vP->vot_detail);
d966 1
a966 1
      retval = hash_insert (op_hash, vP->vot_name, (PTR) &vP->vot_detail);
@


1.35
log
@Switch to GPLv3
@
text
@d3408 6
@


1.34
log
@2007-04-06  Matt Thomas  <matt@@netbsd.org>

	* config/tc-vax.c (vax_cons): Added to support %pcrel{8,16,32}(exp)
	to emit pcrel relocations by DWARF2 in non-code sections.  Borrowed
	heavily from tc-sparc.c.  (vax_cons_fix_new): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.33
log
@remove some duplicate #include's.
@
text
@d3268 140
@


1.32
log
@	* config/tc-vax.c: Update copyright year.
	* config/tc-vax.h: Likewise.
@
text
@a2037 2
#include <stdio.h>

@


1.31
log
@
	* config/tc-vax.c (md_chars_to_number): Used only locally, so
	make it static.
	* config/tc-vax.h (md_chars_to_number): Remove obsolete declaration.
@
text
@d3 1
a3 1
   2003, 2004, 2005
@


1.30
log
@Fix typo in previous delta
@
text
@d298 1
a298 1
long
@


1.29
log
@Convert to ISO C90 format.  Fix formatting and white space usage as well.
@
text
@d294 4
d299 1
a299 2
md_chars_to_number (unsigned char con[],	/* Low order byte 1st.  */
		    int nbytes)		/* Number of bytes in the input.  */
d809 1
a809 2
You have just broken the encoding below, which assumes the sign bit
  means 'I am an imaginary instruction'.
d813 1
a813 2
  You have just broken the encoding below, which assumes the 0x40 M bit means
  'I am not to be "optimised" the way normal branches are'.
d1002 10
a1011 8
#define AP (12)
#define FP (13)
#define SP (14)
#define PC (15)

static int				/* Return -1 or 0:15.  */
vax_reg_parse (char c1, char c2,	/* 3 chars of register name.  */
	       char c3, char c4)	/* c3 == 0 if 2-character reg name.  */
d1013 1
a1013 3
  int retval;

  retval = -1;
d1233 4
d1238 1
a1238 5
vip_op (char *optext, /* user's input string e.g.: "@@B^foo@@bar(AP)[FP]:" */
	struct vop *vopP) /* Input fields: vop_access, vop_width.
			     Output fields: _ndx, _reg, _mode, _short, _warn,
			     _error _expr_begin, _expr_end, _nbytes.
			     vop_nbytes : number of bytes in a datum.  */
d2146 2
a2147 3
mumble (text, value)
     char *text;
     int value;
d2207 1
a2207 1
  {"pic", no_argument, NULL, OPTION_PIC},
d2209 1
a2209 1
  {NULL, no_argument, NULL, 0}
d2411 1
@


1.28
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d28 1
d44 1
a44 1
/* Chars that can be used to separate mant from exp in floating point nums */
d47 3
a49 3
/* Chars that mean this number is a floating point constant */
/* as in 0f123.456 */
/* or    0H1.234E-12 (see exp chars above) */
d56 1
a56 1
/* Hold details of an operand expression */
d71 2
a72 2
symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
symbolS *PLT_symbol;		/* Pre-defined "_PROCEDURE_LINKAGE_TABLE_" */
d83 15
a97 17
/*
 * For VAX, relative addresses of "just the right length" are easy.
 * The branch displacement is always the last operand, even in
 * synthetic instructions.
 * For VAX, we encode the relax_substateTs (in e.g. fr_substate) as:
 *
 *		    4       3       2       1       0	     bit number
 *	---/ /--+-------+-------+-------+-------+-------+
 *		|     what state ?	|  how long ?	|
 *	---/ /--+-------+-------+-------+-------+-------+
 *
 * The "how long" bits are 00=byte, 01=word, 10=long.
 * This is a Un*x convention.
 * Not all lengths are legit for a given value of (what state).
 * The "how long" refers merely to the displacement length.
 * The address usually has some constant bytes in it as well.
 *
d184 1
a184 2
 after relax() what the original addressing mode was.
 */
d193 1
a193 1
/* Dont need LF, LB because they always reach. [They are coded as 0.] */
d240 2
a241 1
void float_cons PARAMS ((int));
d265 1
a265 1
#define STATE_UNDF			(3)	/* Symbol undefined in pass1 */
a267 32

int flonum_gen2vax PARAMS ((char format_letter, FLONUM_TYPE * f,
			    LITTLENUM_TYPE * words));
static const char *vip_begin PARAMS ((int, const char *, const char *,
				      const char *));
static void vip_op_1 PARAMS ((int, const char *));
static void vip_op_defaults PARAMS ((const char *, const char *, const char *));
static void vip_op PARAMS ((char *, struct vop *));
static void vip PARAMS ((struct vit *, char *));

static int vax_reg_parse PARAMS ((char, char, char, char));

void
md_begin ()
{
  const char *errtxt;
  FLONUM_TYPE *fP;
  int i;

  if ((errtxt = vip_begin (1, "$", "*", "`")) != 0)
    {
      as_fatal (_("VIP_BEGIN error:%s"), errtxt);
    }

  for (i = 0, fP = float_operand;
       fP < float_operand + VIT_MAX_OPERANDS;
       i++, fP++)
    {
      fP->low = &big_operand_bits[i][0];
      fP->high = &big_operand_bits[i][SIZE_OF_LARGE_NUMBER - 1];
    }
}
d270 1
a270 4
md_number_to_chars (con, value, nbytes)
     char con[];
     valueT value;
     int nbytes;
d279 1
a279 4
md_apply_fix (fixP, valueP, seg)
     fixS *fixP;
     valueT *valueP;
     segT seg ATTRIBUTE_UNUSED;
d295 2
a296 3
md_chars_to_number (con, nbytes)
     unsigned char con[];	/* Low order byte 1st.  */
     int nbytes;		/* Number of bytes in the input.  */
d299 1
d308 6
a313 8
/*
 * Copy a bignum from in to out.
 * If the output is shorter than the input, copy lower-order
 * littlenums.  Return 0 or the number of significant littlenums
 * dropped.  Assumes littlenum arrays are densely packed: no unused
 * chars between the littlenums. Uses memcpy() to move littlenums, and
 * wants to know length (in chars) of the input bignum.
 */
d316 4
a319 4
bignum_copy (register LITTLENUM_TYPE *in,
	     register int in_length,	/* in sizeof(littlenum)s */
	     register LITTLENUM_TYPE *out,
	     register int out_length	/* in sizeof(littlenum)s */)
d338 1
a338 3
	{
	  significant_littlenums_dropped = 0;
	}
d346 2
a347 5
	{
	  memset ((char *) (out + in_length),
		  '\0',
		  (unsigned int) (out_length - in_length) << LITTLENUM_SHIFT);
	}
d352 1
a352 1
  return (significant_littlenums_dropped);
d355 6
a360 5
/* vax:md_assemble() emit frags for 1 instruction */

void
md_assemble (instruction_string)
     char *instruction_string;	/* A string: assemble 1 instruction.  */
d362 1
a362 53
  /* Non-zero if operand expression's segment is not known yet.  */
  int is_undefined;
  /* Non-zero if operand expression's segment is absolute.  */
  int is_absolute;

  int length_code;
  char *p;
  /* An operand. Scans all operands.  */
  struct vop *operandP;
  char *save_input_line_pointer;
			/* What used to live after an expression.  */
  char c_save;
  /* 1: instruction_string bad for all passes.  */
  int goofed;
  /* Points to slot just after last operand.  */
  struct vop *end_operandP;
  /* Points to expression values for this operand.  */
  expressionS *expP;
  segT *segP;

  /* These refer to an instruction operand expression.  */
  /* Target segment of the address.	 */
  segT to_seg;
  valueT this_add_number;
  /* Positive (minuend) symbol.  */
  symbolS *this_add_symbol;
  /* As a number.  */
  long opcode_as_number;
  /* Least significant byte 1st.  */
  char *opcode_as_chars;
  /* As an array of characters.  */
  /* Least significant byte 1st */
  char *opcode_low_byteP;
  /* length (bytes) meant by vop_short.  */
  int length;
  /* 0, or 1 if '@@' is in addressing mode.  */
  int at;
  /* From vop_nbytes: vax_operand_width (in bytes) */
  int nbytes;
  FLONUM_TYPE *floatP;
  LITTLENUM_TYPE literal_float[8];
  /* Big enough for any floating point literal.  */

  vip (&v, instruction_string);

  /*
   * Now we try to find as many as_warn()s as we can. If we do any as_warn()s
   * then goofed=1. Notice that we don't make any frags yet.
   * Should goofed be 1, then this instruction will wedge in any pass,
   * and we can safely flush it, without causing interpass symbol phase
   * errors. That is, without changing label values in different passes.
   */
  if ((goofed = (*v.vit_error)) != 0)
d364 11
a374 12
      as_fatal (_("Ignoring statement due to \"%s\""), v.vit_error);
    }
  /*
   * We need to use expression() and friends, which require us to diddle
   * input_line_pointer. So we save it and restore it later.
   */
  save_input_line_pointer = input_line_pointer;
  for (operandP = v.vit_operand,
       expP = exp_of_operand,
       segP = seg_of_operand,
       floatP = float_operand,
       end_operandP = v.vit_operand + v.vit_operands;
d376 7
a382 1
       operandP < end_operandP;
d384 32
a415 18
       operandP++, expP++, segP++, floatP++)
    {				/* for each operand */
      if (operandP->vop_error)
	{
	  as_fatal (_("Aborting because statement has \"%s\""), operandP->vop_error);
	  goofed = 1;
	}
      else
	{
	  /* Statement has no syntax goofs: let's sniff the expression.  */
	  int can_be_short = 0;	/* 1 if a bignum can be reduced to a short literal.  */

	  input_line_pointer = operandP->vop_expr_begin;
	  c_save = operandP->vop_expr_end[1];
	  operandP->vop_expr_end[1] = '\0';
	  /* If to_seg == SEG_PASS1, expression() will have set need_pass_2 = 1.  */
	  *segP = expression (expP);
	  switch (expP->X_op)
d417 5
a421 11
	    case O_absent:
	      /* for BSD4.2 compatibility, missing expression is absolute 0 */
	      expP->X_op = O_constant;
	      expP->X_add_number = 0;
	      /* For SEG_ABSOLUTE, we shouldn't need to set X_op_symbol,
		 X_add_symbol to any particular value.  But, we will program
		 defensively. Since this situation occurs rarely so it costs
		 us little to do, and stops Dean worrying about the origin of
		 random bits in expressionS's.  */
	      expP->X_add_symbol = NULL;
	      expP->X_op_symbol = NULL;
d424 8
a431 2
	    case O_symbol:
	    case O_constant:
d434 10
a443 16
	    default:
	      /*
	       * Major bug. We can't handle the case of a
	       * SEG_OP expression in a VIT_OPCODE_SYNTHETIC
	       * variable-length instruction.
	       * We don't have a frag type that is smart enough to
	       * relax a SEG_OP, and so we just force all
	       * SEG_OPs to behave like SEG_PASS1s.
	       * Clearly, if there is a demand we can invent a new or
	       * modified frag type and then coding up a frag for this
	       * case will be easy. SEG_OP was invented for the
	       * .words after a CASE opcode, and was never intended for
	       * instruction operands.
	       */
	      need_pass_2 = 1;
	      as_fatal (_("Can't relocate expression"));
d446 10
a455 23
	    case O_big:
	      /* Preserve the bits.  */
	      if (expP->X_add_number > 0)
		{
		  bignum_copy (generic_bignum, expP->X_add_number,
			       floatP->low, SIZE_OF_LARGE_NUMBER);
		}
	      else
		{
		  know (expP->X_add_number < 0);
		  flonum_copy (&generic_floating_point_number,
			       floatP);
		  if (strchr ("s i", operandP->vop_short))
		    {
		      /* Could possibly become S^# */
		      flonum_gen2vax (-expP->X_add_number, floatP, literal_float);
		      switch (-expP->X_add_number)
			{
			case 'f':
			  can_be_short =
			    (literal_float[0] & 0xFC0F) == 0x4000
			    && literal_float[1] == 0;
			  break;
d457 7
a463 7
			case 'd':
			  can_be_short =
			    (literal_float[0] & 0xFC0F) == 0x4000
			    && literal_float[1] == 0
			    && literal_float[2] == 0
			    && literal_float[3] == 0;
			  break;
d465 4
a468 7
			case 'g':
			  can_be_short =
			    (literal_float[0] & 0xFF81) == 0x4000
			    && literal_float[1] == 0
			    && literal_float[2] == 0
			    && literal_float[3] == 0;
			  break;
d470 37
a506 10
			case 'h':
			  can_be_short = ((literal_float[0] & 0xFFF8) == 0x4000
					  && (literal_float[1] & 0xE000) == 0
					  && literal_float[2] == 0
					  && literal_float[3] == 0
					  && literal_float[4] == 0
					  && literal_float[5] == 0
					  && literal_float[6] == 0
					  && literal_float[7] == 0);
			  break;
d508 13
a520 6
			default:
			  BAD_CASE (-expP->X_add_number);
			  break;
			}	/* switch (float type) */
		    }		/* if (could want to become S^#...) */
		}		/* bignum or flonum ? */
d522 6
a527 59
	      if (operandP->vop_short == 's'
		  || operandP->vop_short == 'i'
		  || (operandP->vop_short == ' '
		      && operandP->vop_reg == 0xF
		      && (operandP->vop_mode & 0xE) == 0x8))
		{
		  /* Saw a '#'.  */
		  if (operandP->vop_short == ' ')
		    {
		      /* We must chose S^ or I^.  */
		      if (expP->X_add_number > 0)
			{
			  /* Bignum: Short literal impossible.  */
			  operandP->vop_short = 'i';
			  operandP->vop_mode = 8;
			  operandP->vop_reg = 0xF;	/* VAX PC.  */
			}
		      else
			{
			  /* Flonum: Try to do it.  */
			  if (can_be_short)
			    {
			      operandP->vop_short = 's';
			      operandP->vop_mode = 0;
			      operandP->vop_ndx = -1;
			      operandP->vop_reg = -1;
			      expP->X_op = O_constant;
			    }
			  else
			    {
			      operandP->vop_short = 'i';
			      operandP->vop_mode = 8;
			      operandP->vop_reg = 0xF;	/* VAX PC */
			    }
			}	/* bignum or flonum ? */
		    }		/*  if #, but no S^ or I^ seen.  */
		  /* No more ' ' case: either 's' or 'i'.  */
		  if (operandP->vop_short == 's')
		    {
		      /* Wants to be a short literal.  */
		      if (expP->X_add_number > 0)
			{
			  as_warn (_("Bignum not permitted in short literal. Immediate mode assumed."));
			  operandP->vop_short = 'i';
			  operandP->vop_mode = 8;
			  operandP->vop_reg = 0xF;	/* VAX PC.  */
			}
		      else
			{
			  if (!can_be_short)
			    {
			      as_warn (_("Can't do flonum short literal: immediate mode used."));
			      operandP->vop_short = 'i';
			      operandP->vop_mode = 8;
			      operandP->vop_reg = 0xF;	/* VAX PC.  */
			    }
			  else
			    {	/* Encode short literal now.  */
			      int temp = 0;
d529 9
a537 6
			      switch (-expP->X_add_number)
				{
				case 'f':
				case 'd':
				  temp = literal_float[0] >> 4;
				  break;
d539 7
a545 3
				case 'g':
				  temp = literal_float[0] >> 1;
				  break;
d547 7
a553 4
				case 'h':
				  temp = ((literal_float[0] << 3) & 070)
				    | ((literal_float[1] >> 13) & 07);
				  break;
d555 5
a559 4
				default:
				  BAD_CASE (-expP->X_add_number);
				  break;
				}
d561 8
a568 42
			      floatP->low[0] = temp & 077;
			      floatP->low[1] = 0;
			    }	/* if can be short literal float */
			}	/* flonum or bignum ? */
		    }
		  else
		    {		/* I^# seen: set it up if float.  */
		      if (expP->X_add_number < 0)
			{
			  memcpy (floatP->low, literal_float, sizeof (literal_float));
			}
		    }		/* if S^# seen.  */
		}
	      else
		{
		  as_warn (_("A bignum/flonum may not be a displacement: 0x%lx used"),
			   (expP->X_add_number = 0x80000000L));
		  /* Chosen so luser gets the most offset bits to patch later.  */
		}
	      expP->X_add_number = floatP->low[0]
		| ((LITTLENUM_MASK & (floatP->low[1])) << LITTLENUM_NUMBER_OF_BITS);
	      /*
	       * For the O_big case we have:
	       * If vop_short == 's' then a short floating literal is in the
	       *	lowest 6 bits of floatP -> low [0], which is
	       *	big_operand_bits [---] [0].
	       * If vop_short == 'i' then the appropriate number of elements
	       *	of big_operand_bits [---] [...] are set up with the correct
	       *	bits.
	       * Also, just in case width is byte word or long, we copy the lowest
	       * 32 bits of the number to X_add_number.
	       */
	      break;
	    }
	  if (input_line_pointer != operandP->vop_expr_end + 1)
	    {
	      as_fatal ("Junk at end of expression \"%s\"", input_line_pointer);
	      goofed = 1;
	    }
	  operandP->vop_expr_end[1] = c_save;
	}
    }				/* for(each operand) */
d570 9
a578 1
  input_line_pointer = save_input_line_pointer;
d580 5
a584 4
  if (need_pass_2 || goofed)
    {
      return;
    }
d586 6
a591 11
  /* Emit op-code.  */
  /* Remember where it is, in case we want to modify the op-code later.  */
  opcode_low_byteP = frag_more (v.vit_opcode_nbytes);
  memcpy (opcode_low_byteP, v.vit_opcode, v.vit_opcode_nbytes);
  opcode_as_chars = v.vit_opcode;
  opcode_as_number = md_chars_to_number ((unsigned char *) opcode_as_chars, 4);
  for (operandP = v.vit_operand,
       expP = exp_of_operand,
       segP = seg_of_operand,
       floatP = float_operand,
       end_operandP = v.vit_operand + v.vit_operands;
d593 7
a599 1
       operandP < end_operandP;
d601 5
a605 11
       operandP++,
       floatP++,
       segP++,
       expP++)
    {
      if (operandP->vop_ndx >= 0)
	{
	  /* indexed addressing byte */
	  /* Legality of indexed mode already checked: it is OK */
	  FRAG_APPEND_1_CHAR (0x40 + operandP->vop_ndx);
	}			/* if(vop_ndx>=0) */
d607 783
a1389 13
      /* Here to make main operand frag(s).  */
      this_add_number = expP->X_add_number;
      this_add_symbol = expP->X_add_symbol;
      to_seg = *segP;
      is_undefined = (to_seg == undefined_section);
      is_absolute = (to_seg == absolute_section);
      at = operandP->vop_mode & 1;
      length = (operandP->vop_short == 'b'
		? 1 : (operandP->vop_short == 'w'
		       ? 2 : (operandP->vop_short == 'l'
			      ? 4 : 0)));
      nbytes = operandP->vop_nbytes;
      if (operandP->vop_access == 'b')
d1391 6
a1396 54
	  if (to_seg == now_seg || is_undefined)
	    {
	      /* If is_undefined, then it might BECOME now_seg.  */
	      if (nbytes)
		{
		  p = frag_more (nbytes);
		  fix_new (frag_now, p - frag_now->fr_literal, nbytes,
			   this_add_symbol, this_add_number, 1, NO_RELOC);
		}
	      else
		{		/* to_seg==now_seg || to_seg == SEG_UNKNOWN */
		  /* nbytes==0 */
		  length_code = is_undefined ? STATE_UNDF : STATE_BYTE;
		  if (opcode_as_number & VIT_OPCODE_SPECIAL)
		    {
		      if (operandP->vop_width == VAX_WIDTH_UNCONDITIONAL_JUMP)
			{
			  /* br or jsb */
			  frag_var (rs_machine_dependent, 5, 1,
			    ENCODE_RELAX (STATE_ALWAYS_BRANCH, length_code),
				    this_add_symbol, this_add_number,
				    opcode_low_byteP);
			}
		      else
			{
			  if (operandP->vop_width == VAX_WIDTH_WORD_JUMP)
			    {
			      length_code = STATE_WORD;
			      /* JF: There is no state_byte for this one! */
			      frag_var (rs_machine_dependent, 10, 2,
					ENCODE_RELAX (STATE_COMPLEX_BRANCH, length_code),
					this_add_symbol, this_add_number,
					opcode_low_byteP);
			    }
			  else
			    {
			      know (operandP->vop_width == VAX_WIDTH_BYTE_JUMP);
			      frag_var (rs_machine_dependent, 9, 1,
			      ENCODE_RELAX (STATE_COMPLEX_HOP, length_code),
					this_add_symbol, this_add_number,
					opcode_low_byteP);
			    }
			}
		    }
		  else
		    {
		      know (operandP->vop_width == VAX_WIDTH_CONDITIONAL_JUMP);
		      frag_var (rs_machine_dependent, 7, 1,
		       ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, length_code),
				this_add_symbol, this_add_number,
				opcode_low_byteP);
		    }
		}
	    }
d1399 8
a1406 87
	      /* to_seg != now_seg && to_seg != SEG_UNKNOWN */
	      /*
	       * --- SEG FLOAT MAY APPEAR HERE ----
	       */
	      if (is_absolute)
		{
		  if (nbytes)
		    {
		      know (!(opcode_as_number & VIT_OPCODE_SYNTHETIC));
		      p = frag_more (nbytes);
		      /* Conventional relocation.  */
		      fix_new (frag_now, p - frag_now->fr_literal, nbytes,
			       section_symbol (absolute_section),
			       this_add_number, 1, NO_RELOC);
		    }
		  else
		    {
		      know (opcode_as_number & VIT_OPCODE_SYNTHETIC);
		      if (opcode_as_number & VIT_OPCODE_SPECIAL)
			{
			  if (operandP->vop_width == VAX_WIDTH_UNCONDITIONAL_JUMP)
			    {
			      /* br or jsb */
			      *opcode_low_byteP = opcode_as_chars[0] + VAX_WIDEN_LONG;
			      know (opcode_as_chars[1] == 0);
			      p = frag_more (5);
			      p[0] = VAX_ABSOLUTE_MODE;	/* @@#...  */
			      md_number_to_chars (p + 1, this_add_number, 4);
			      /* Now (eg) JMP @@#foo or JSB @@#foo.  */
			    }
			  else
			    {
			      if (operandP->vop_width == VAX_WIDTH_WORD_JUMP)
				{
				  p = frag_more (10);
				  p[0] = 2;
				  p[1] = 0;
				  p[2] = VAX_BRB;
				  p[3] = 6;
				  p[4] = VAX_JMP;
				  p[5] = VAX_ABSOLUTE_MODE;	/* @@#...  */
				  md_number_to_chars (p + 6, this_add_number, 4);
				  /*
				   * Now (eg)	ACBx	1f
				   *		BRB	2f
				   *	1:	JMP	@@#foo
				   *	2:
				   */
				}
			      else
				{
				  know (operandP->vop_width == VAX_WIDTH_BYTE_JUMP);
				  p = frag_more (9);
				  p[0] = 2;
				  p[1] = VAX_BRB;
				  p[2] = 6;
				  p[3] = VAX_JMP;
                                  p[4] = VAX_ABSOLUTE_MODE;     /* @@#...  */
				  md_number_to_chars (p + 5, this_add_number, 4);
				  /*
				   * Now (eg)	xOBxxx	1f
				   *		BRB	2f
				   *	1:	JMP	@@#foo
				   *	2:
				   */
				}
			    }
			}
		      else
			{
			  /* b<cond> */
			  *opcode_low_byteP ^= 1;
			  /* To reverse the condition in a VAX branch,
			     complement the lowest order bit.  */
			  p = frag_more (7);
			  p[0] = 6;
			  p[1] = VAX_JMP;
			  p[2] = VAX_ABSOLUTE_MODE;	/* @@#...  */
			  md_number_to_chars (p + 3, this_add_number, 4);
			  /*
			   * Now (eg)	BLEQ	1f
			   *		JMP	@@#foo
			   *	1:
			   */
			}
		    }
		}
d1408 6
d1415 5
a1419 85
		  /* to_seg != now_seg && !is_undefinfed && !is_absolute */
		  if (nbytes > 0)
		    {
		      /* Pc-relative. Conventional relocation.  */
		      know (!(opcode_as_number & VIT_OPCODE_SYNTHETIC));
		      p = frag_more (nbytes);
		      fix_new (frag_now, p - frag_now->fr_literal, nbytes,
			       section_symbol (absolute_section),
			       this_add_number, 1, NO_RELOC);
		    }
		  else
		    {
		      know (opcode_as_number & VIT_OPCODE_SYNTHETIC);
		      if (opcode_as_number & VIT_OPCODE_SPECIAL)
			{
			  if (operandP->vop_width == VAX_WIDTH_UNCONDITIONAL_JUMP)
			    {
			      /* br or jsb */
			      know (opcode_as_chars[1] == 0);
			      *opcode_low_byteP = opcode_as_chars[0] + VAX_WIDEN_LONG;
			      p = frag_more (5);
			      p[0] = VAX_PC_RELATIVE_MODE;
			      fix_new (frag_now,
				       p + 1 - frag_now->fr_literal, 4,
				       this_add_symbol,
				       this_add_number, 1, NO_RELOC);
			      /* Now eg JMP foo or JSB foo.  */
			    }
			  else
			    {
			      if (operandP->vop_width == VAX_WIDTH_WORD_JUMP)
				{
				  p = frag_more (10);
				  p[0] = 0;
				  p[1] = 2;
				  p[2] = VAX_BRB;
				  p[3] = 6;
				  p[4] = VAX_JMP;
				  p[5] = VAX_PC_RELATIVE_MODE;
				  fix_new (frag_now,
					   p + 6 - frag_now->fr_literal, 4,
					   this_add_symbol,
					   this_add_number, 1, NO_RELOC);
				  /*
				   * Now (eg)	ACBx	1f
				   *		BRB	2f
				   *	1:	JMP	foo
				   *	2:
				   */
				}
			      else
				{
				  know (operandP->vop_width == VAX_WIDTH_BYTE_JUMP);
				  p = frag_more (10);
				  p[0] = 2;
				  p[1] = VAX_BRB;
				  p[2] = 6;
				  p[3] = VAX_JMP;
				  p[4] = VAX_PC_RELATIVE_MODE;
				  fix_new (frag_now,
					   p + 5 - frag_now->fr_literal,
					   4, this_add_symbol,
					   this_add_number, 1, NO_RELOC);
				  /*
				   * Now (eg)	xOBxxx	1f
				   *		BRB	2f
				   *	1:	JMP	foo
				   *	2:
				   */
				}
			    }
			}
		      else
			{
			  know (operandP->vop_width == VAX_WIDTH_CONDITIONAL_JUMP);
			  *opcode_low_byteP ^= 1;	/* Reverse branch condition.  */
			  p = frag_more (7);
			  p[0] = 6;
			  p[1] = VAX_JMP;
			  p[2] = VAX_PC_RELATIVE_MODE;
			  fix_new (frag_now, p + 3 - frag_now->fr_literal,
				   4, this_add_symbol,
				   this_add_number, 1, NO_RELOC);
			}
		    }
d1421 4
d1426 2
d1430 12
d1443 1
a1443 8
	  know (operandP->vop_access != 'b');	/* So it is ordinary operand.  */
	  know (operandP->vop_access != ' ');	/* ' ' target-independent: elsewhere.  */
	  know (operandP->vop_access == 'a'
		|| operandP->vop_access == 'm'
		|| operandP->vop_access == 'r'
		|| operandP->vop_access == 'v'
		|| operandP->vop_access == 'w');
	  if (operandP->vop_short == 's')
d1445 1
a1445 1
	      if (is_absolute)
d1447 2
a1448 8
		  if (this_add_number >= 64)
		    {
		      as_warn (_("Short literal overflow(%ld.), immediate mode assumed."),
			       (long) this_add_number);
		      operandP->vop_short = 'i';
		      operandP->vop_mode = 8;
		      operandP->vop_reg = 0xF;
		    }
d1450 19
d1470 3
d1474 2
a1475 5
		  as_warn (_("Forced short literal to immediate mode. now_seg=%s to_seg=%s"),
			   segment_name (now_seg), segment_name (to_seg));
		  operandP->vop_short = 'i';
		  operandP->vop_mode = 8;
		  operandP->vop_reg = 0xF;
d1478 121
a1598 2
	  if (operandP->vop_reg >= 0 && (operandP->vop_mode < 8
		  || (operandP->vop_reg != 0xF && operandP->vop_mode < 10)))
d1600 2
a1601 4
	      /* One byte operand.  */
	      know (operandP->vop_mode > 3);
	      FRAG_APPEND_1_CHAR (operandP->vop_mode << 4 | operandP->vop_reg);
	      /* All 1-bytes except S^# happen here.  */
d1604 74
a1677 165
	    {
	      /* {@@}{q^}foo{(Rn)} or S^#foo */
	      if (operandP->vop_reg == -1 && operandP->vop_short != 's')
		{
		  /* "{@@}{q^}foo" */
		  if (to_seg == now_seg)
		    {
		      if (length == 0)
			{
			  know (operandP->vop_short == ' ');
			  length_code = STATE_BYTE;
#ifdef OBJ_ELF
			  if (S_IS_EXTERNAL (this_add_symbol)
			      || S_IS_WEAK (this_add_symbol))
			    length_code = STATE_UNDF;
#endif
			  p = frag_var (rs_machine_dependent, 10, 2,
			       ENCODE_RELAX (STATE_PC_RELATIVE, length_code),
					this_add_symbol, this_add_number,
					opcode_low_byteP);
			  know (operandP->vop_mode == 10 + at);
			  *p = at << 4;
			  /* At is the only context we need to carry
			     to other side of relax() process.  Must
			     be in the correct bit position of VAX
			     operand spec. byte.  */
			}
		      else
			{
			  know (length);
			  know (operandP->vop_short != ' ');
			  p = frag_more (length + 1);
			  p[0] = 0xF | ((at + "?\12\14?\16"[length]) << 4);
			  fix_new (frag_now, p + 1 - frag_now->fr_literal,
				   length, this_add_symbol,
				   this_add_number, 1, NO_RELOC);
			}
		    }
		  else
		    {		/* to_seg != now_seg */
		      if (this_add_symbol == NULL)
			{
			  know (is_absolute);
			  /* Do @@#foo: simpler relocation than foo-.(pc) anyway.  */
			  p = frag_more (5);
			  p[0] = VAX_ABSOLUTE_MODE;	/* @@#...  */
			  md_number_to_chars (p + 1, this_add_number, 4);
			  if (length && length != 4)
			    {
			      as_warn (_("Length specification ignored. Address mode 9F used"));
			    }
			}
		      else
			{
			  /* {@@}{q^}other_seg */
			  know ((length == 0 && operandP->vop_short == ' ')
			     || (length > 0 && operandP->vop_short != ' '));
			  if (is_undefined
#ifdef OBJ_ELF
			      || S_IS_WEAK(this_add_symbol)
			      || S_IS_EXTERNAL(this_add_symbol)
#endif
			      )
			    {
			      switch (length)
				{
				default: length_code = STATE_UNDF; break;
				case 1: length_code = STATE_BYTE; break;
				case 2: length_code = STATE_WORD; break;
				case 4: length_code = STATE_LONG; break;
				}
			      /*
			       * We have a SEG_UNKNOWN symbol. It might
			       * turn out to be in the same segment as
			       * the instruction, permitting relaxation.
			       */
			      p = frag_var (rs_machine_dependent, 5, 2,
			       ENCODE_RELAX (STATE_PC_RELATIVE, length_code),
					    this_add_symbol, this_add_number,
					    opcode_low_byteP);
			      p[0] = at << 4;
			    }
			  else
			    {
			      if (length == 0)
				{
				  know (operandP->vop_short == ' ');
				  length = 4;	/* Longest possible.  */
				}
			      p = frag_more (length + 1);
			      p[0] = 0xF | ((at + "?\12\14?\16"[length]) << 4);
			      md_number_to_chars (p + 1, this_add_number, length);
			      fix_new (frag_now,
				       p + 1 - frag_now->fr_literal,
				       length, this_add_symbol,
				       this_add_number, 1, NO_RELOC);
			    }
			}
		    }
		}
	      else
		{
		  /* {@@}{q^}foo(Rn) or S^# or I^# or # */
		  if (operandP->vop_mode < 0xA)
		    {
		      /* # or S^# or I^# */
		      if (operandP->vop_access == 'v'
			  || operandP->vop_access == 'a')
			{
			  if (operandP->vop_access == 'v')
			    as_warn (_("Invalid operand:  immediate value used as base address."));
			  else
			    as_warn (_("Invalid operand:  immediate value used as address."));
			  /* gcc 2.6.3 is known to generate these in at least
			     one case.  */
			}
		      if (length == 0
			  && is_absolute && (expP->X_op != O_big)
			  && operandP->vop_mode == 8	/* No '@@'.  */
			  && this_add_number < 64)
			{
			  operandP->vop_short = 's';
			}
		      if (operandP->vop_short == 's')
			{
			  FRAG_APPEND_1_CHAR (this_add_number);
			}
		      else
			{
			  /* I^#...  */
			  know (nbytes);
			  p = frag_more (nbytes + 1);
			  know (operandP->vop_reg == 0xF);
#ifdef OBJ_ELF
			  if (flag_want_pic && operandP->vop_mode == 8
				&& this_add_symbol != NULL)
			    {
			      as_warn (_("Symbol used as immediate operand in PIC mode."));
			    }
#endif
			  p[0] = (operandP->vop_mode << 4) | 0xF;
			  if ((is_absolute) && (expP->X_op != O_big))
			    {
			      /* If nbytes > 4, then we are scrod. We
			         don't know if the high order bytes
			         are to be 0xFF or 0x00.  BSD4.2 & RMS
			         say use 0x00. OK --- but this
			         assembler needs ANOTHER rewrite to
			         cope properly with this bug.  */
			      md_number_to_chars (p + 1, this_add_number,
						  min (sizeof (valueT),
						       (size_t) nbytes));
			      if ((size_t) nbytes > sizeof (valueT))
				memset (p + 5, '\0', nbytes - sizeof (valueT));
			    }
			  else
			    {
			      if (expP->X_op == O_big)
				{
				  /*
				   * Problem here is to get the bytes
				   * in the right order.  We stored
				   * our constant as LITTLENUMs, not
				   * bytes.  */
				  LITTLENUM_TYPE *lP;
d1679 33
a1711 32
				  lP = floatP->low;
				  if (nbytes & 1)
				    {
				      know (nbytes == 1);
				      p[1] = *lP;
				    }
				  else
				    {
				      for (p++; nbytes; nbytes -= 2, p += 2, lP++)
					{
					  md_number_to_chars (p, *lP, 2);
					}
				    }
				}
			      else
				{
				  fix_new (frag_now, p + 1 - frag_now->fr_literal,
					   nbytes, this_add_symbol,
					   this_add_number, 0, NO_RELOC);
				}
			    }
			}
		    }
		  else
		    {		/* {@@}{q^}foo(Rn) */
		      know ((length == 0 && operandP->vop_short == ' ')
			    || (length > 0 && operandP->vop_short != ' '));
		      if (length == 0)
			{
			  if (is_absolute)
			    {
			      long test;
d1713 3
a1715 1
			      test = this_add_number;
d1717 8
a1724 2
			      if (test < 0)
				test = ~test;
d1726 76
a1801 26
			      length = test & 0xffff8000 ? 4
				: test & 0xffffff80 ? 2
				: 1;
			    }
			  else
			    {
			      length = 4;
			    }
			}
		      p = frag_more (1 + length);
		      know (operandP->vop_reg >= 0);
		      p[0] = operandP->vop_reg
			| ((at | "?\12\14?\16"[length]) << 4);
		      if (is_absolute)
			{
			  md_number_to_chars (p + 1, this_add_number, length);
			}
		      else
			{
			  fix_new (frag_now, p + 1 - frag_now->fr_literal,
				   length, this_add_symbol,
				   this_add_number, 0, NO_RELOC);
			}
		    }
		}
	    }			/* if(single-byte-operand) */
d1803 44
a1846 11
    }				/* for(operandP) */
}				/* vax_assemble() */

/* md_estimate_size_before_relax(), called just before relax().
   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag and the growth beyond
   fr_fix.  */
int
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP;
     segT segment;
d1848 32
a1879 1
  if (RELAX_LENGTH (fragP->fr_subtype) == STATE_UNDF)
d1881 15
a1895 6
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment
#ifdef OBJ_ELF
	  || S_IS_WEAK (fragP->fr_symbol)
	  || S_IS_EXTERNAL (fragP->fr_symbol)
#endif
	  )
d1897 19
a1915 24
	  /* Non-relaxable cases.  */
	  int reloc_type = NO_RELOC;
	  char *p;
	  int old_fr_fix;

	  old_fr_fix = fragP->fr_fix;
	  p = fragP->fr_literal + old_fr_fix;
#ifdef OBJ_ELF
	  /* If this is to an undefined symbol, then if it's an indirect
	     reference indicate that is can mutated into a GLOB_DAT or
	     JUMP_SLOT by the loader.  We restrict ourselves to no offset
	     due to a limitation in the NetBSD linker.  */

	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find (GLOBAL_OFFSET_TABLE_NAME);
	  if (PLT_symbol == NULL)
	    PLT_symbol = symbol_find (PROCEDURE_LINKAGE_TABLE_NAME);
	  if ((GOT_symbol == NULL || fragP->fr_symbol != GOT_symbol)
	      && (PLT_symbol == NULL || fragP->fr_symbol != PLT_symbol)
	      && fragP->fr_symbol != NULL
	      && flag_want_pic
	      && (!S_IS_DEFINED (fragP->fr_symbol)
	          || S_IS_WEAK (fragP->fr_symbol)
	          || S_IS_EXTERNAL (fragP->fr_symbol)))
d1917 5
a1921 1
	      if (p[0] & 0x10)
d1923 14
a1936 3
		  if (flag_want_pic)
		    as_fatal ("PIC reference to %s is indirect.\n",
			      S_GET_NAME (fragP->fr_symbol));
d1939 1
a1939 10
		{
		  if (((unsigned char *) fragP->fr_opcode)[0] == VAX_CALLS
		      || ((unsigned char *) fragP->fr_opcode)[0] == VAX_CALLG
		      || ((unsigned char *) fragP->fr_opcode)[0] == VAX_JSB
		      || ((unsigned char *) fragP->fr_opcode)[0] == VAX_JMP
		      || S_IS_FUNCTION (fragP->fr_symbol))
		    reloc_type = BFD_RELOC_32_PLT_PCREL;
		  else
		    reloc_type = BFD_RELOC_32_GOT_PCREL;
		}
d1941 1
a1941 2
#endif
	  switch (RELAX_STATE (fragP->fr_subtype))
d1943 4
a1946 50
	    case STATE_PC_RELATIVE:
	      p[0] |= VAX_PC_RELATIVE_MODE;	/* Preserve @@ bit.  */
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, reloc_type);
	      break;

	    case STATE_CONDITIONAL_BRANCH:
	      *fragP->fr_opcode ^= 1;		/* Reverse sense of branch.  */
	      p[0] = 6;
	      p[1] = VAX_JMP;
	      p[2] = VAX_PC_RELATIVE_MODE;	/* ...(PC) */
	      fragP->fr_fix += 1 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 3, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    case STATE_COMPLEX_BRANCH:
	      p[0] = 2;
	      p[1] = 0;
	      p[2] = VAX_BRB;
	      p[3] = 6;
	      p[4] = VAX_JMP;
	      p[5] = VAX_PC_RELATIVE_MODE;	/* ...(pc) */
	      fragP->fr_fix += 2 + 2 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 6, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    case STATE_COMPLEX_HOP:
	      p[0] = 2;
	      p[1] = VAX_BRB;
	      p[2] = 6;
	      p[3] = VAX_JMP;
	      p[4] = VAX_PC_RELATIVE_MODE;	/* ...(pc) */
	      fragP->fr_fix += 1 + 2 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 5, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    case STATE_ALWAYS_BRANCH:
	      *fragP->fr_opcode += VAX_WIDEN_LONG;
	      p[0] = VAX_PC_RELATIVE_MODE;	/* ...(PC) */
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    default:
	      abort ();
d1948 1
a1948 25
	  frag_wane (fragP);

	  /* Return the growth in the fixed part of the frag.  */
	  return fragP->fr_fix - old_fr_fix;
	}

      /* Relaxable cases.  Set up the initial guess for the variable
	 part of the frag.  */
      switch (RELAX_STATE (fragP->fr_subtype))
	{
	case STATE_PC_RELATIVE:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	  break;
	case STATE_CONDITIONAL_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE);
	  break;
	case STATE_COMPLEX_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_COMPLEX_BRANCH, STATE_WORD);
	  break;
	case STATE_COMPLEX_HOP:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_BYTE);
	  break;
	case STATE_ALWAYS_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_BYTE);
	  break;
d1951 1
a1951 6

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
d1954 3
a1956 23
/*
 *			md_convert_frag();
 *
 * Called after relax() is finished.
 * In:	Address of frag.
 *	fr_type == rs_machine_dependent.
 *	fr_subtype is what the address relaxed to.
 *
 * Out:	Any fixSs and constants are set up.
 *	Caller will turn frag into a ".space 0".
 */
void
md_convert_frag (headers, seg, fragP)
     bfd *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP;
{
  char *addressP;		/* -> _var to change.  */
  char *opcodeP;		/* -> opcode char(s) to change.  */
  short int extension = 0;	/* Size of relaxed address.  */
  /* Added to fr_fix: incl. ALL var chars.  */
  symbolS *symbolP;
  long where;
d1958 9
a1966 6
  know (fragP->fr_type == rs_machine_dependent);
  where = fragP->fr_fix;
  addressP = fragP->fr_literal + where;
  opcodeP = fragP->fr_opcode;
  symbolP = fragP->fr_symbol;
  know (symbolP);
d1968 4
a1971 2
  switch (fragP->fr_subtype)
    {
d1973 11
a1983 7
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE):
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit.  */
      addressP[0] |= 0xAF;	/* Byte displacement. */
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 2;
      break;
d1985 2
a1986 7
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_WORD):
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit.  */
      addressP[0] |= 0xCF;	/* Word displacement. */
      fix_new (fragP, fragP->fr_fix + 1, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 3;
      break;
d1988 8
a1995 7
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_LONG):
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit.  */
      addressP[0] |= 0xEF;	/* Long word displacement. */
      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 5;
      break;
d1997 3
a1999 5
    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE):
      fix_new (fragP, fragP->fr_fix, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 1;
      break;
d2001 5
a2005 8
    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_WORD):
      opcodeP[0] ^= 1;		/* Reverse sense of test.  */
      addressP[0] = 3;
      addressP[1] = VAX_BRW;
      fix_new (fragP, fragP->fr_fix + 2, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 4;
      break;
d2007 9
a2015 9
    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_LONG):
      opcodeP[0] ^= 1;		/* Reverse sense of test.  */
      addressP[0] = 6;
      addressP[1] = VAX_JMP;
      addressP[2] = VAX_PC_RELATIVE_MODE;
      fix_new (fragP, fragP->fr_fix + 3, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 7;
      break;
d2017 3
a2019 5
    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_BYTE):
      fix_new (fragP, fragP->fr_fix, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 1;
      break;
d2021 7
a2027 6
    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_WORD):
      opcodeP[0] += VAX_WIDEN_WORD;	/* brb -> brw, bsbb -> bsbw */
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, NO_RELOC);
      extension = 2;
      break;
d2029 3
a2031 7
    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_LONG):
      opcodeP[0] += VAX_WIDEN_LONG;	/* brb -> jmp, bsbb -> jsb */
      addressP[0] = VAX_PC_RELATIVE_MODE;
      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 5;
      break;
d2033 3
a2035 5
    case ENCODE_RELAX (STATE_COMPLEX_BRANCH, STATE_WORD):
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 2;
      break;
d2037 1
a2037 11
    case ENCODE_RELAX (STATE_COMPLEX_BRANCH, STATE_LONG):
      addressP[0] = 2;
      addressP[1] = 0;
      addressP[2] = VAX_BRB;
      addressP[3] = 6;
      addressP[4] = VAX_JMP;
      addressP[5] = VAX_PC_RELATIVE_MODE;
      fix_new (fragP, fragP->fr_fix + 6, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 10;
      break;
d2039 17
a2055 5
    case ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_BYTE):
      fix_new (fragP, fragP->fr_fix, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 1;
      break;
d2057 10
a2066 9
    case ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_WORD):
      addressP[0] = 2;
      addressP[1] = VAX_BRB;
      addressP[2] = 3;
      addressP[3] = VAX_BRW;
      fix_new (fragP, fragP->fr_fix + 4, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 6;
      break;
d2068 43
a2110 10
    case ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_LONG):
      addressP[0] = 2;
      addressP[1] = VAX_BRB;
      addressP[2] = 6;
      addressP[3] = VAX_JMP;
      addressP[4] = VAX_PC_RELATIVE_MODE;
      fix_new (fragP, fragP->fr_fix + 5, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
      extension = 9;
      break;
d2112 30
a2141 3
    default:
      BAD_CASE (fragP->fr_subtype);
      break;
d2143 15
a2157 2
  fragP->fr_fix += extension;
}				/* md_convert_frag() */
d2159 2
a2160 1
/* Translate internal format of relocation info into target format.
a2161 5
   On vax: first 4 bytes are normal unsigned long, next three bytes
   are symbolnum, least sig. byte first.  Last byte is broken up with
   the upper nibble as nuthin, bit 3 as extern, bits 2 & 1 as length, and
   bit 0 as pcrel.  */
#ifdef comment
d2163 5
a2167 3
md_ri_to_chars (the_bytes, ri)
     char *the_bytes;
     struct reloc_info_generic ri;
d2169 9
a2177 8
  /* this is easy */
  md_number_to_chars (the_bytes, ri.r_address, sizeof (ri.r_address));
  /* now the fun stuff */
  the_bytes[6] = (ri.r_symbolnum >> 16) & 0x0ff;
  the_bytes[5] = (ri.r_symbolnum >> 8) & 0x0ff;
  the_bytes[4] = ri.r_symbolnum & 0x0ff;
  the_bytes[7] = (((ri.r_extern << 3) & 0x08) | ((ri.r_length << 1) & 0x06) |
		  ((ri.r_pcrel << 0) & 0x01)) & 0x0F;
d2180 8
a2187 1
#endif /* comment */
d2189 6
a2194 31
/*
 *       BUGS, GRIPES,  APOLOGIA, etc.
 *
 * The opcode table 'votstrs' needs to be sorted on opcode frequency.
 * That is, AFTER we hash it with hash_...(), we want most-used opcodes
 * to come out of the hash table faster.
 *
 * I am sorry to inflict yet another VAX assembler on the world, but
 * RMS says we must do everything from scratch, to prevent pin-heads
 * restricting this software.
 */

/*
 * This is a vaguely modular set of routines in C to parse VAX
 * assembly code using DEC mnemonics. It is NOT un*x specific.
 *
 * The idea here is that the assembler has taken care of all:
 *   labels
 *   macros
 *   listing
 *   pseudo-ops
 *   line continuation
 *   comments
 *   condensing any whitespace down to exactly one space
 * and all we have to do is parse 1 line into a vax instruction
 * partially formed. We will accept a line, and deliver:
 *   an error message (hopefully empty)
 *   a skeleton VAX instruction (tree structure)
 *   textual pointers to all the operand expressions
 *   a warning message that notes a silly operand (hopefully empty)
 */
d2196 16
a2211 32
/*
 *		E D I T   H I S T O R Y
 *
 * 17may86 Dean Elsner. Bug if line ends immediately after opcode.
 * 30apr86 Dean Elsner. New vip_op() uses arg block so change call.
 *  6jan86 Dean Elsner. Crock vip_begin() to call vip_op_defaults().
 *  2jan86 Dean Elsner. Invent synthetic opcodes.
 *	Widen vax_opcodeT to 32 bits. Use a bit for VIT_OPCODE_SYNTHETIC,
 *	which means this is not a real opcode, it is like a macro; it will
 *	be relax()ed into 1 or more instructions.
 *	Use another bit for VIT_OPCODE_SPECIAL if the op-code is not optimised
 *	like a regular branch instruction. Option added to vip_begin():
 *	exclude	synthetic opcodes. Invent synthetic_votstrs[].
 * 31dec85 Dean Elsner. Invent vit_opcode_nbytes.
 *	Also make vit_opcode into a char[]. We now have n-byte vax opcodes,
 *	so caller's don't have to know the difference between a 1-byte & a
 *	2-byte op-code. Still need vax_opcodeT concept, so we know how
 *	big an object must be to hold an op.code.
 * 30dec85 Dean Elsner. Widen typedef vax_opcodeT in "vax-inst.h"
 *	because vax opcodes may be 16 bits. Our crufty C compiler was
 *	happily initialising 8-bit vot_codes with 16-bit numbers!
 *	(Wouldn't the 'phone company like to compress data so easily!)
 * 29dec85 Dean Elsner. New static table vax_operand_width_size[].
 *	Invented so we know hw many bytes a "I^#42" needs in its immediate
 *	operand. Revised struct vop in "vax-inst.h": explicitly include
 *	byte length of each operand, and it's letter-code datum type.
 * 17nov85 Dean Elsner. Name Change.
 *	Due to ar(1) truncating names, we learned the hard way that
 *	"vax-inst-parse.c" -> "vax-inst-parse." dropping the "o" off
 *	the archived object name. SO... we shortened the name of this
 *	source file, and changed the makefile.
 */
d2213 8
a2220 2
/* handle of the OPCODE hash table */
static struct hash_control *op_hash;
d2222 3
a2224 7
/*
 * In:	1 character, from "bdfghloqpw" being the data-type of an operand
 *	of a vax instruction.
 *
 * Out:	the length of an operand of that type, in bytes.
 *	Special branch operands types "-?!" have length 0.
 */
d2226 3
a2228 30
static const short int vax_operand_width_size[256] =
{
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 8, 0, 4, 8, 16, 0, 0, 0, 4, 0, 0,16,	/* ..b.d.fgh...l..o  */
  0, 8, 0, 0, 0, 0, 0, 2,  0, 0, 0, 0, 0, 0, 0, 0,	/* .q.....w........  */
  0, 0, 1, 0, 8, 0, 4, 8, 16, 0, 0, 0, 4, 0, 0,16,	/* ..b.d.fgh...l..o  */
  0, 8, 0, 0, 0, 0, 0, 2,  0, 0, 0, 0, 0, 0, 0, 0,	/* .q.....w........  */
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
};

/*
 * This perversion encodes all the vax opcodes as a bunch of strings.
 * RMS says we should build our hash-table at run-time. Hmm.
 * Please would someone arrange these in decreasing frequency of opcode?
 * Because of the way hash_...() works, the most frequently used opcode
 * should be textually first and so on.
 *
 * Input for this table was 'vax.opcodes', awk(1)ed by 'vax.opcodes.c.awk' .
 * So change 'vax.opcodes', then re-generate this table.
 */
d2230 3
a2232 40
#include "opcode/vax.h"

/*
 * This is a table of optional op-codes. All of them represent
 * 'synthetic' instructions that seem popular.
 *
 * Here we make some pseudo op-codes. Every code has a bit set to say
 * it is synthetic. This lets you catch them if you want to
 * ban these opcodes. They are mnemonics for "elastic" instructions
 * that are supposed to assemble into the fewest bytes needed to do a
 * branch, or to do a conditional branch, or whatever.
 *
 * The opcode is in the usual place [low-order n*8 bits]. This means
 * that if you mask off the bucky bits, the usual rules apply about
 * how long the opcode is.
 *
 * All VAX branch displacements come at the end of the instruction.
 * For simple branches (1-byte opcode + 1-byte displacement) the last
 * operand is coded 'b?' where the "data type" '?' is a clue that we
 * may reverse the sense of the branch (complement lowest order bit)
 * and branch around a jump. This is by far the most common case.
 * That is why the VIT_OPCODE_SYNTHETIC bit is set: it says this is
 * a 0-byte op-code followed by 2 or more bytes of operand address.
 *
 * If the op-code has VIT_OPCODE_SPECIAL set, then we have a more unusual
 * case.
 *
 * For JBSB & JBR the treatment is the similar, except (1) we have a 'bw'
 * option before (2) we can directly JSB/JMP because there is no condition.
 * These operands have 'b-' as their access/data type.
 *
 * That leaves a bunch of random opcodes: JACBx, JxOBxxx. In these
 * cases, we do the same idea. JACBxxx are all marked with a 'b!'
 * JAOBxxx & JSOBxxx are marked with a 'b:'.
 *
 */
#if (VIT_OPCODE_SYNTHETIC != 0x80000000)
You have just broken the encoding below, which assumes the sign bit
  means 'I am an imaginary instruction'.
#endif
d2234 3
a2236 4
#if (VIT_OPCODE_SPECIAL != 0x40000000)
  You have just broken the encoding below, which assumes the 0x40 M bit means
  'I am not to be "optimised" the way normal branches are'.
#endif
d2238 4
a2241 24
static const struct vot
  synthetic_votstrs[] =
{
  {"jbsb",	{"b-", 0xC0000010}},		/* BSD 4.2 */
/* jsb used already */
  {"jbr",	{"b-", 0xC0000011}},		/* BSD 4.2 */
  {"jr",	{"b-", 0xC0000011}},		/* consistent */
  {"jneq",	{"b?", 0x80000012}},
  {"jnequ",	{"b?", 0x80000012}},
  {"jeql",	{"b?", 0x80000013}},
  {"jeqlu",	{"b?", 0x80000013}},
  {"jgtr",	{"b?", 0x80000014}},
  {"jleq",	{"b?", 0x80000015}},
/* un-used opcodes here */
  {"jgeq",	{"b?", 0x80000018}},
  {"jlss",	{"b?", 0x80000019}},
  {"jgtru",	{"b?", 0x8000001a}},
  {"jlequ",	{"b?", 0x8000001b}},
  {"jvc",	{"b?", 0x8000001c}},
  {"jvs",	{"b?", 0x8000001d}},
  {"jgequ",	{"b?", 0x8000001e}},
  {"jcc",	{"b?", 0x8000001e}},
  {"jlssu",	{"b?", 0x8000001f}},
  {"jcs",	{"b?", 0x8000001f}},
d2243 3
a2245 7
  {"jacbw",	{"rwrwmwb!", 0xC000003d}},
  {"jacbf",	{"rfrfmfb!", 0xC000004f}},
  {"jacbd",	{"rdrdmdb!", 0xC000006f}},
  {"jacbb",	{"rbrbmbb!", 0xC000009d}},
  {"jacbl",	{"rlrlmlb!", 0xC00000f1}},
  {"jacbg",	{"rgrgmgb!", 0xC0004ffd}},
  {"jacbh",	{"rhrhmhb!", 0xC0006ffd}},
d2247 3
a2249 8
  {"jbs",	{"rlvbb?", 0x800000e0}},
  {"jbc",	{"rlvbb?", 0x800000e1}},
  {"jbss",	{"rlvbb?", 0x800000e2}},
  {"jbcs",	{"rlvbb?", 0x800000e3}},
  {"jbsc",	{"rlvbb?", 0x800000e4}},
  {"jbcc",	{"rlvbb?", 0x800000e5}},
  {"jlbs",	{"rlb?", 0x800000e8}},
  {"jlbc",	{"rlb?", 0x800000e9}},
d2251 7
a2257 4
  {"jaoblss",	{"rlmlb:", 0xC00000f2}},
  {"jaobleq",	{"rlmlb:", 0xC00000f3}},
  {"jsobgeq",	{"mlb:", 0xC00000f4}},
  {"jsobgtr",	{"mlb:", 0xC00000f5}},
d2259 3
a2261 2
/* CASEx has no branch addresses in our conception of it.  */
/* You should use ".word ..." statements after the "case ...".  */
d2263 6
a2268 1
  {"",	{"", 0}}			/* empty is end sentinel */
d2270 5
a2274 12
};				/* synthetic_votstrs */

/*
 *                  v i p _ b e g i n ( )
 *
 * Call me once before you decode any lines.
 * I decode votstrs into a hash table at op_hash (which I create).
 * I return an error text or null.
 * If you want, I will include the 'synthetic' jXXX instructions in the
 * instruction table.
 * You must nominate metacharacters for eg DEC's "#", "@@", "^".
 */
d2276 5
a2280 7
static const char *
vip_begin (synthetic_too, immediate, indirect, displen)
     int synthetic_too;		/* 1 means include jXXX op-codes.  */
     const char *immediate, *indirect, *displen;
{
  const struct vot *vP;		/* scan votstrs */
  const char *retval = 0;	/* error text */
d2282 3
a2284 1
  op_hash = hash_new ();
d2286 2
a2287 2
  for (vP = votstrs; *vP->vot_name && !retval; vP++)
    retval = hash_insert (op_hash, vP->vot_name, (PTR) &vP->vot_detail);
d2289 24
a2312 3
  if (synthetic_too)
    for (vP = synthetic_votstrs; *vP->vot_name && !retval; vP++)
      retval = hash_insert (op_hash, vP->vot_name, (PTR) &vP->vot_detail);
d2314 5
a2318 3
#ifndef CONST_TABLE
  vip_op_defaults (immediate, indirect, displen);
#endif
d2320 6
a2325 1
  return retval;
d2328 8
a2335 23
/*
 *                  v i p ( )
 *
 * This converts a string into a vax instruction.
 * The string must be a bare single instruction in dec-vax (with BSD4 frobs)
 * format.
 * It provides some error messages: at most one fatal error message (which
 * stops the scan) and at most one warning message for each operand.
 * The vax instruction is returned in exploded form, since we have no
 * knowledge of how you parse (or evaluate) your expressions.
 * We do however strip off and decode addressing modes and operation
 * mnemonic.
 *
 * The exploded instruction is returned to a struct vit of your choice.
 * #include "vax-inst.h" to know what a struct vit is.
 *
 * This function's value is a string. If it is not "" then an internal
 * logic error was found: read this code to assign meaning to the string.
 * No argument string should generate such an error string:
 * it means a bug in our code, not in the user's text.
 *
 * You MUST have called vip_begin() once before using this function.
 */
d2337 2
a2338 4
static void
vip (vitP, instring)
     struct vit *vitP;		/* We build an exploded instruction here.  */
     char *instring;		/* Text of a vax instruction: we modify.  */
d2340 5
a2344 15
  /* How to bit-encode this opcode.  */
  struct vot_wot *vwP;
  /* 1/skip whitespace.2/scan vot_how */
  char *p;
  char *q;
  /* counts number of operands seen */
  unsigned char count;
  /* scan operands in struct vit */
  struct vop *operandp;
  /* error over all operands */
  const char *alloperr;
  /* Remember char, (we clobber it with '\0' temporarily).  */
  char c;
  /* Op-code of this instruction.  */
  vax_opcodeT oc;
d2346 1
a2346 6
  if (*instring == ' ')
    ++instring;			/* Skip leading whitespace.  */
  for (p = instring; *p && *p != ' '; p++);;	/* MUST end in end-of-string or exactly 1 space.  */
  /* Scanned up to end of operation-code.  */
  /* Operation-code is ended with whitespace.  */
  if (p - instring == 0)
d2348 3
a2350 16
      vitP->vit_error = _("No operator");
      count = 0;
      memset (vitP->vit_opcode, '\0', sizeof (vitP->vit_opcode));
    }
  else
    {
      c = *p;
      *p = '\0';
      /*
       * Here with instring pointing to what better be an op-name, and p
       * pointing to character just past that.
       * We trust instring points to an op-name, with no whitespace.
       */
      vwP = (struct vot_wot *) hash_find (op_hash, instring);
      *p = c;			/* Restore char after op-code.  */
      if (vwP == 0)
d2352 1
a2352 29
	  vitP->vit_error = _("Unknown operator");
	  count = 0;
	  memset (vitP->vit_opcode, '\0', sizeof (vitP->vit_opcode));
	}
      else
	{
	  /*
	   * We found a match! So let's pick up as many operands as the
	   * instruction wants, and even gripe if there are too many.
	   * We expect comma to separate each operand.
	   * We let instring track the text, while p tracks a part of the
	   * struct vot.
	   */
	  const char *howp;
	  /*
	   * The lines below know about 2-byte opcodes starting FD,FE or FF.
	   * They also understand synthetic opcodes. Note:
	   * we return 32 bits of opcode, including bucky bits, BUT
	   * an opcode length is either 8 or 16 bits for vit_opcode_nbytes.
	   */
	  oc = vwP->vot_code;	/* The op-code.  */
	  vitP->vit_opcode_nbytes = (oc & 0xFF) >= 0xFD ? 2 : 1;
	  md_number_to_chars (vitP->vit_opcode, oc, 4);
	  count = 0;		/* no operands seen yet */
	  instring = p;		/* point just past operation code */
	  alloperr = "";
	  for (howp = vwP->vot_how, operandp = vitP->vit_operand;
	       !(alloperr && *alloperr) && *howp;
	       operandp++, howp += 2)
d2354 16
a2369 34
	      /*
	       * Here to parse one operand. Leave instring pointing just
	       * past any one ',' that marks the end of this operand.
	       */
	      if (!howp[1])
		as_fatal (_("odd number of bytes in operand description"));
	      else if (*instring)
		{
		  for (q = instring; (c = *q) && c != ','; q++)
		    ;
		  /*
		   * Q points to ',' or '\0' that ends argument. C is that
		   * character.
		   */
		  *q = 0;
		  operandp->vop_width = howp[1];
		  operandp->vop_nbytes = vax_operand_width_size[(unsigned) howp[1]];
		  operandp->vop_access = howp[0];
		  vip_op (instring, operandp);
		  *q = c;	/* Restore input text.  */
		  if (operandp->vop_error)
		    alloperr = _("Bad operand");
		  instring = q + (c ? 1 : 0);	/* next operand (if any) */
		  count++;	/*  won another argument, may have an operr */
		}
	      else
		alloperr = _("Not enough operands");
	    }
	  if (!*alloperr)
	    {
	      if (*instring == ' ')
		instring++;	/* Skip whitespace.  */
	      if (*instring)
		alloperr = _("Too many operands");
a2370 1
	  vitP->vit_error = alloperr;
d2373 1
a2373 40
  vitP->vit_operands = count;
}

#ifdef test

/*
 * Test program for above.
 */

struct vit myvit;		/* build an exploded vax instruction here */
char answer[100];		/* human types a line of vax assembler here */
char *mybug;			/* "" or an internal logic diagnostic */
int mycount;			/* number of operands */
struct vop *myvop;		/* scan operands from myvit */
int mysynth;			/* 1 means want synthetic opcodes.  */
char my_immediate[200];
char my_indirect[200];
char my_displen[200];

main ()
{
  char *p;

  printf ("0 means no synthetic instructions.   ");
  printf ("Value for vip_begin?  ");
  gets (answer);
  sscanf (answer, "%d", &mysynth);
  printf ("Synthetic opcodes %s be included.\n", mysynth ? "will" : "will not");
  printf ("enter immediate symbols eg enter #   ");
  gets (my_immediate);
  printf ("enter indirect symbols  eg enter @@   ");
  gets (my_indirect);
  printf ("enter displen symbols   eg enter ^   ");
  gets (my_displen);
  if (p = vip_begin (mysynth, my_immediate, my_indirect, my_displen))
    {
      error ("vip_begin=%s", p);
    }
  printf ("An empty input line will quit you from the vax instruction parser\n");
  for (;;)
d2375 2
a2376 4
      printf ("vax instruction: ");
      fflush (stdout);
      gets (answer);
      if (!*answer)
d2378 9
a2386 35
	  break;		/* out of for each input text loop */
	}
      vip (&myvit, answer);
      if (*myvit.vit_error)
	{
	  printf ("ERR:\"%s\"\n", myvit.vit_error);
	}
      printf ("opcode=");
      for (mycount = myvit.vit_opcode_nbytes, p = myvit.vit_opcode;
	   mycount;
	   mycount--, p++
	)
	{
	  printf ("%02x ", *p & 0xFF);
	}
      printf ("   operand count=%d.\n", mycount = myvit.vit_operands);
      for (myvop = myvit.vit_operand; mycount; mycount--, myvop++)
	{
	  printf ("mode=%xx reg=%xx ndx=%xx len='%c'=%c%c%d. expr=\"",
		  myvop->vop_mode, myvop->vop_reg, myvop->vop_ndx,
		  myvop->vop_short, myvop->vop_access, myvop->vop_width,
		  myvop->vop_nbytes);
	  for (p = myvop->vop_expr_begin; p <= myvop->vop_expr_end; p++)
	    {
	      putchar (*p);
	    }
	  printf ("\"\n");
	  if (myvop->vop_error)
	    {
	      printf ("  err:\"%s\"\n", myvop->vop_error);
	    }
	  if (myvop->vop_warn)
	    {
	      printf ("  wrn:\"%s\"\n", myvop->vop_warn);
	    }
d2389 2
a2390 3
  vip_end ();
  exit (EXIT_SUCCESS);
}
d2392 12
a2403 1
#endif /* #ifdef test */
d2405 2
a2406 1
/* end of vax_ins_parse.c */
d2408 2
a2409 1
/* vax_reg_parse.c - convert a VAX register name to a number */
d2411 21
a2431 1
/* Copyright (C) 1987 Free Software Foundation, Inc. A part of GNU.  */
d2433 22
a2454 31
/*
 *          v a x _ r e g _ p a r s e ( )
 *
 * Take 3 char.s, the last of which may be `\0` (non-existent)
 * and return the VAX register number that they represent.
 *
 * Return -1 if they don't form a register name. Good names return
 * a number from 0:15 inclusive.
 *
 * Case is not important in a name.
 *
 * Register names understood are:
 *
 *	R0
 *	R1
 *	R2
 *	R3
 *	R4
 *	R5
 *	R6
 * 	R7
 *	R8
 *	R9
 *	R10
 *	R11
 *	R12	AP
 *	R13	FP
 *	R14	SP
 *	R15	PC
 *
 */
d2456 1
a2456 11
#include "safe-ctype.h"
#define AP (12)
#define FP (13)
#define SP (14)
#define PC (15)

int				/* return -1 or 0:15 */
vax_reg_parse (c1, c2, c3, c4)	/* 3 chars of register name */
     char c1, c2, c3, c4;	/* c3 == 0 if 2-character reg name */
{
  int retval;		/* return -1:15 */
d2458 6
a2463 15
  retval = -1;

#ifdef OBJ_ELF
  if (c1 != '%')	/* register prefixes are mandatory for ELF */
    return retval;
  c1 = c2;
  c2 = c3;
  c3 = c4;
#endif
#ifdef OBJ_VMS
  if (c4 != 0)		/* register prefixes are not allowed under VMS */
    return retval;
#endif
#ifdef OBJ_AOUT
  if (c1 == '%')	/* register prefixes are optional under a.out */
d2465 1
a2465 3
      c1 = c2;
      c2 = c3;
      c3 = c4;
d2467 10
a2476 3
  else if (c3 && c4)	/* can't be 4 characters long.  */
    return retval;
#endif
d2478 1
a2478 3
  c1 = TOLOWER (c1);
  c2 = TOLOWER (c2);
  if (ISDIGIT (c2) && c1 == 'r')
d2480 1
a2480 2
      retval = c2 - '0';
      if (ISDIGIT (c3))
d2482 2
a2483 3
	  retval = retval * 10 + c3 - '0';
	  retval = (retval > 15) ? -1 : retval;
	  /* clamp the register value to 1 hex digit */
d2485 1
a2485 8
      else if (c3)
	retval = -1;		/* c3 must be '\0' or a digit */
    }
  else if (c3)			/* There are no three letter regs */
    retval = -1;
  else if (c2 == 'p')
    {
      switch (c1)
d2487 2
a2488 19
	case 's':
	  retval = SP;
	  break;
	case 'f':
	  retval = FP;
	  break;
	case 'a':
	  retval = AP;
	  break;
	default:
	  retval = -1;
	}
    }
  else if (c1 == 'p' && c2 == 'c')
    retval = PC;
  else
    retval = -1;
  return (retval);
}
d2490 19
a2508 104
/*
 *               v i p _ o p ( )
 *
 * Parse a vax operand in DEC assembler notation.
 * For speed, expect a string of whitespace to be reduced to a single ' '.
 * This is the case for GNU AS, and is easy for other DEC-compatible
 * assemblers.
 *
 * Knowledge about DEC VAX assembler operand notation lives here.
 * This doesn't even know what a register name is, except it believes
 * all register names are 2 or 3 characters, and lets vax_reg_parse() say
 * what number each name represents.
 * It does, however, know that PC, SP etc are special registers so it can
 * detect addressing modes that are silly for those registers.
 *
 * Where possible, it delivers 1 fatal or 1 warning message if the operand
 * is suspect. Exactly what we test for is still evolving.
 */

/*
 *		   	B u g s
 *
 *	Arg block.
 *
 * There were a number of 'mismatched argument type' bugs to vip_op.
 * The most general solution is to typedef each (of many) arguments.
 * We used instead a typedef'd argument block. This is less modular
 * than using separate return pointers for each result, but runs faster
 * on most engines, and seems to keep programmers happy. It will have
 * to be done properly if we ever want to use vip_op as a general-purpose
 * module (it was designed to be).
 *
 *	G^
 *
 * Doesn't support DEC "G^" format operands. These always take 5 bytes
 * to express, and code as modes 8F or 9F. Reason: "G^" deprives you of
 * optimising to (say) a "B^" if you are lucky in the way you link.
 * When someone builds a linker smart enough to convert "G^" to "B^", "W^"
 * whenever possible, then we should implement it.
 * If there is some other use for "G^", feel free to code it in!
 *
 *
 *	speed
 *
 * If I nested if()s more, I could avoid testing (*err) which would save
 * time, space and page faults. I didn't nest all those if()s for clarity
 * and because I think the mode testing can be re-arranged 1st to test the
 * commoner constructs 1st. Does anybody have statistics on this?
 *
 *
 *
 *	error messages
 *
 * In future, we should be able to 'compose' error messages in a scratch area
 * and give the user MUCH more informative error messages. Although this takes
 * a little more code at run-time, it will make this module much more self-
 * documenting. As an example of what sucks now: most error messages have
 * hardwired into them the DEC VAX metacharacters "#^@@" which are nothing like
 * the Un*x characters "$`*", that most users will expect from this AS.
 */

/*
 * The input is a string, ending with '\0'.
 *
 * We also require a 'hint' of what kind of operand is expected: so
 * we can remind caller not to write into literals for instance.
 *
 * The output is a skeletal instruction.
 *
 * The algorithm has two parts.
 * 1. extract the syntactic features (parse off all the @@^#-()+[] mode crud);
 * 2. express the @@^#-()+[] as some parameters suited to further analysis.
 *
 * 2nd step is where we detect the googles of possible invalid combinations
 * a human (or compiler) might write. Note that if we do a half-way
 * decent assembler, we don't know how long to make (eg) displacement
 * fields when we first meet them (because they may not have defined values).
 * So we must wait until we know how many bits are needed for each address,
 * then we can know both length and opcodes of instructions.
 * For reason(s) above, we will pass to our caller a 'broken' instruction
 * of these major components, from which our caller can generate instructions:
 *  -  displacement length      I^ S^ L^ B^ W^ unspecified
 *  -  mode                     (many)
 *  -  register                 R0-R15 or absent
 *  -  index register           R0-R15 or absent
 *  -  expression text          what we don't parse
 *  -  error text(s)            why we couldn't understand the operand
 */

/*
 * To decode output of this, test errtxt. If errtxt[0] == '\0', then
 * we had no errors that prevented parsing. Also, if we ever report
 * an internal bug, errtxt[0] is set non-zero. So one test tells you
 * if the other outputs are to be taken seriously.
 */

/*
 * Because this module is useful for both VMS and UN*X style assemblers
 * and because of the variety of UN*X assemblers we must recognise
 * the different conventions for assembler operand notation. For example
 * VMS says "#42" for immediate mode, while most UN*X say "$42".
 * We permit arbitrary sets of (single) characters to represent the
 * 3 concepts that DEC writes '#', '@@', '^'.
 */
d2510 3
a2512 4
/* character tests */
#define VIP_IMMEDIATE 01	/* Character is like DEC # */
#define VIP_INDIRECT  02	/* Char is like DEC @@ */
#define VIP_DISPLEN   04	/* Char is like DEC ^ */
d2514 15
a2528 3
#define IMMEDIATEP(c)	(vip_metacharacters [(c)&0xff]&VIP_IMMEDIATE)
#define INDIRECTP(c)	(vip_metacharacters [(c)&0xff]&VIP_INDIRECT)
#define DISPLENP(c)	(vip_metacharacters [(c)&0xff]&VIP_DISPLEN)
d2530 23
a2552 3
/* We assume 8 bits per byte. Use vip_op_defaults() to set these up BEFORE we
 * are ever called.
 */
d2554 7
a2560 16
#if defined(CONST_TABLE)
#define _ 0,
#define I VIP_IMMEDIATE,
#define S VIP_INDIRECT,
#define D VIP_DISPLEN,
static const char
vip_metacharacters[256] =
{
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/* ^@@ ^A ^B ^C ^D ^E ^F ^G ^H ^I ^J ^K ^L ^M ^N ^O*/
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/* ^P ^Q ^R ^S ^T ^U ^V ^W ^X ^Y ^Z ^[ ^\ ^] ^^ ^_ */
  _ _ _ _ I _ _ _ _ _ S _ _ _ _ _	/* sp !  "  #  $  %  & '  (  )  *  +  ,  -  .  / */
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?*/
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*@@  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O*/
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _*/
  D _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*`  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o*/
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	/*p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^?*/
d2562 7
a2568 15
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
};
#undef _
#undef I
#undef S
#undef D
#else
static char vip_metacharacters[256];
d2570 10
a2579 6
static void
vip_op_1 (bit, syms)
     int bit;
     const char *syms;
{
  unsigned char t;
d2581 6
a2586 3
  while ((t = *syms++) != 0)
    vip_metacharacters[t] |= bit;
}
d2588 60
a2647 11
/* Can be called any time.  More arguments may appear in future.  */
static void
vip_op_defaults (immediate, indirect, displen)
     const char *immediate;
     const char *indirect;
     const char *displen;
{
  vip_op_1 (VIP_IMMEDIATE, immediate);
  vip_op_1 (VIP_INDIRECT, indirect);
  vip_op_1 (VIP_DISPLEN, displen);
}
d2649 6
a2654 2
#endif

d2656 3
a2658 106
/*
 * Dec defines the semantics of address modes (and values)
 * by a two-letter code, explained here.
 *
 *   letter 1:   access type
 *
 *     a         address calculation - no data access, registers forbidden
 *     b         branch displacement
 *     m         read - let go of bus - write back    "modify"
 *     r         read
 *     v         bit field address: like 'a' but registers are OK
 *     w         write
 *     space	 no operator (eg ".long foo") [our convention]
 *
 *   letter 2:   data type (i.e. width, alignment)
 *
 *     b         byte
 *     d         double precision floating point (D format)
 *     f         single precision floating point (F format)
 *     g         G format floating
 *     h         H format floating
 *     l         longword
 *     o         octaword
 *     q         quadword
 *     w         word
 *     ?	 simple synthetic branch operand
 *     -	 unconditional synthetic JSB/JSR operand
 *     !	 complex synthetic branch operand
 *
 * The '-?!' letter 2's are not for external consumption. They are used
 * for various assemblers. Generally, all unknown widths are assumed 0.
 * We don't limit your choice of width character.
 *
 * DEC operands are hard work to parse. For example, '@@' as the first
 * character means indirect (deferred) mode but elsewhere it is a shift
 * operator.
 * The long-winded explanation of how this is supposed to work is
 * cancelled. Read a DEC vax manual.
 * We try hard not to parse anything that MIGHT be part of the expression
 * buried in that syntax. For example if we see @@...(Rn) we don't check
 * for '-' before the '(' because mode @@-(Rn) does not exist.
 *
 * After parsing we have:
 *
 * at                     1 if leading '@@' (or Un*x '*')
 * len                    takes one value from " bilsw". eg B^ -> 'b'.
 * hash                   1 if leading '#' (or Un*x '$')
 * expr_begin, expr_end   the expression we did not parse
 *                        even though we don't interpret it, we make use
 *                        of its presence or absence.
 * sign                   -1: -(Rn)    0: absent    +1: (Rn)+
 * paren                  1 if () are around register
 * reg                    major register number 0:15    -1 means absent
 * ndx                    index register number 0:15    -1 means absent
 *
 * Again, I dare not explain it: just trace ALL the code!
 */

static void
vip_op (optext, vopP)
     /* user's input string e.g.: "@@B^foo@@bar(AP)[FP]:" */
     char *optext;
     /* Input fields: vop_access, vop_width.
	Output fields: _ndx, _reg, _mode, _short, _warn,
	_error _expr_begin, _expr_end, _nbytes.
	vop_nbytes : number of bytes in a datum.  */
     struct vop *vopP;
{
  /* track operand text forward */
  char *p;
  /* track operand text backward */
  char *q;
  /* 1 if leading '@@' ('*') seen */
  int at;
  /* one of " bilsw" */
  char len;
  /* 1 if leading '#' ('$') seen */
  int hash;
  /* -1, 0 or +1 */
  int sign = 0;
  /* 1 if () surround register */
  int paren = 0;
  /* register number, -1:absent */
  int reg = 0;
  /* index register number -1:absent */
  int ndx = 0;
  /* report illegal operand, ""==OK */
  /* " " is a FAKE error: means we won */
  /* ANY err that begins with ' ' is a fake.  */
  /* " " is converted to "" before return */
  const char *err;
  /* warn about weird modes pf address */
  const char *wrn;
  /* preserve q in case we backup */
  char *oldq = NULL;
  /* build up 4-bit operand mode here */
  /* note: index mode is in ndx, this is */
  /* the major mode of operand address */
  int mode = 0;
  /*
   * Notice how we move wrong-arg-type bugs INSIDE this module: if we
   * get the types wrong below, we lose at compile time rather than at
   * lint or run time.
   */
  char access_mode;		/* vop_access.  */
  char width;			/* vop_width.  */
d2660 4
a2663 5
  access_mode = vopP->vop_access;
  width = vopP->vop_width;
  /* None of our code bugs (yet), no user text errors, no warnings
     even.  */
  err = wrn = 0;
d2665 4
a2668 1
  p = optext;
d2670 22
a2691 2
  if (*p == ' ')		/* Expect all whitespace reduced to ' '.  */
    p++;			/* skip over whitespace */
d2693 18
a2710 5
  if ((at = INDIRECTP (*p)) != 0)
    {				/* 1 if *p=='@@'(or '*' for Un*x) */
      p++;			/* at is determined */
      if (*p == ' ')		/* Expect all whitespace reduced to ' '.  */
	p++;			/* skip over whitespace */
d2713 1
a2713 7
  /*
   * This code is subtle. It tries to detect all legal (letter)'^'
   * but it doesn't waste time explicitly testing for premature '\0' because
   * this case is rejected as a mismatch against either (letter) or '^'.
   */
  {
    char c;
d2715 2
a2716 7
    c = *p;
    c = TOLOWER (c);
    if (DISPLENP (p[1]) && strchr ("bilws", len = c))
      p += 2;			/* skip (letter) '^' */
    else			/* no (letter) '^' seen */
      len = ' ';		/* len is determined */
  }
d2718 11
a2728 2
  if (*p == ' ')		/* Expect all whitespace reduced to ' '.  */
    p++;			/* skip over whitespace */
d2730 1
a2730 2
  if ((hash = IMMEDIATEP (*p)) != 0)	/* 1 if *p=='#' ('$' for Un*x) */
    p++;			/* hash is determined */
d2732 4
a2735 72
  /*
   * p points to what may be the beginning of an expression.
   * We have peeled off the front all that is peelable.
   * We know at, len, hash.
   *
   * Lets point q at the end of the text and parse that (backwards).
   */

  for (q = p; *q; q++)
    ;
  q--;				/* now q points at last char of text */

  if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '.  */
    q--;
  /* reverse over whitespace, but don't */
  /* run back over *p */

  /*
   * As a matter of policy here, we look for [Rn], although both Rn and S^#
   * forbid [Rn]. This is because it is easy, and because only a sick
   * cyborg would have [...] trailing an expression in a VAX-like assembler.
   * A meticulous parser would first check for Rn followed by '(' or '['
   * and not parse a trailing ']' if it found another. We just ban expressions
   * ending in ']'.
   */
  if (*q == ']')
    {
      while (q >= p && *q != '[')
	q--;
      /* either q<p or we got matching '[' */
      if (q < p)
	err = _("no '[' to match ']'");
      else
	{
	  /*
	   * Confusers like "[]" will eventually lose with a bad register
	   * name error. So again we don't need to check for early '\0'.
	   */
	  if (q[3] == ']')
	    ndx = vax_reg_parse (q[1], q[2], 0, 0);
	  else if (q[4] == ']')
	    ndx = vax_reg_parse (q[1], q[2], q[3], 0);
	  else if (q[5] == ']')
	    ndx = vax_reg_parse (q[1], q[2], q[3], q[4]);
	  else
	    ndx = -1;
	  /*
	   * Since we saw a ']' we will demand a register name in the [].
	   * If luser hasn't given us one: be rude.
	   */
	  if (ndx < 0)
	    err = _("bad register in []");
	  else if (ndx == PC)
	    err = _("[PC] index banned");
	  else
	    q--;		/* point q just before "[...]" */
	}
    }
  else
    ndx = -1;			/* no ']', so no iNDeX register */

  /*
   * If err = "..." then we lost: run away.
   * Otherwise ndx == -1 if there was no "[...]".
   * Otherwise, ndx is index register number, and q points before "[...]".
   */

  if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '.  */
    q--;
  /* reverse over whitespace, but don't */
  /* run back over *p */
  if (!err || !*err)
d2737 1
a2737 3
      sign = 0;			/* no ()+ or -() seen yet */

      if (q > p + 3 && *q == '+' && q[-1] == ')')
d2739 4
a2742 3
	  sign = 1;		/* we saw a ")+" */
	  q--;			/* q points to ')' */
	}
d2744 13
a2756 1
      if (*q == ')' && q > p + 2)
d2758 1
a2758 7
	  paren = 1;		/* assume we have "(...)" */
	  while (q >= p && *q != '(')
	    q--;
	  /* either q<p or we got matching '(' */
	  if (q < p)
	    err = _("no '(' to match ')'");
	  else
d2760 7
a2766 10
	      /*
	       * Confusers like "()" will eventually lose with a bad register
	       * name error. So again we don't need to check for early '\0'.
	       */
	      if (q[3] == ')')
		reg = vax_reg_parse (q[1], q[2], 0, 0);
	      else if (q[4] == ')')
		reg = vax_reg_parse (q[1], q[2], q[3], 0);
	      else if (q[5] == ')')
		reg = vax_reg_parse (q[1], q[2], q[3], q[4]);
a2767 8
		reg = -1;
	      /*
	       * Since we saw a ')' we will demand a register name in the ')'.
	       * This is nasty: why can't our hypothetical assembler permit
	       * parenthesised expressions? BECAUSE I AM LAZY! That is why.
	       * Abuse luser if we didn't spy a register name.
	       */
	      if (reg < 0)
d2769 42
a2810 5
		  /* JF allow parenthesized expressions.  I hope this works */
		  paren = 0;
		  while (*q != ')')
		    q++;
		  /* err = "unknown register in ()"; */
a2811 6
	      else
		q--;		/* point just before '(' of "(...)" */
	      /*
	       * If err == "..." then we lost. Run away.
	       * Otherwise if reg >= 0 then we saw (Rn).
	       */
d2813 1
a2813 24
	  /*
	   * If err == "..." then we lost.
	   * Otherwise paren==1 and reg = register in "()".
	   */
	}
      else
	paren = 0;
      /*
       * If err == "..." then we lost.
       * Otherwise, q points just before "(Rn)", if any.
       * If there was a "(...)" then paren==1, and reg is the register.
       */

      /*
       * We should only seek '-' of "-(...)" if:
       *   we saw "(...)"                    paren == 1
       *   we have no errors so far          ! *err
       *   we did not see '+' of "(...)+"    sign < 1
       * We don't check len. We want a specific error message later if
       * user tries "x^...-(Rn)". This is a feature not a bug.
       */
      if (!err || !*err)
	{
	  if (paren && sign < 1)/* !sign is adequate test */
d2815 3
a2817 1
	      if (*q == '-')
d2819 74
a2892 2
		  sign = -1;
		  q--;
a2893 21
	    }
	  /*
	   * We have back-tracked over most
	   * of the crud at the end of an operand.
	   * Unless err, we know: sign, paren. If paren, we know reg.
	   * The last case is of an expression "Rn".
	   * This is worth hunting for if !err, !paren.
	   * We wouldn't be here if err.
	   * We remember to save q, in case we didn't want "Rn" anyway.
	   */
	  if (!paren)
	    {
	      if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '.  */
		q--;
	      /* reverse over whitespace, but don't */
	      /* run back over *p */
	      /* room for Rn or Rnn (include prefix) exactly? */
	      if (q > p && q < p + 4)
		reg = vax_reg_parse (p[0], p[1],
		  q < p + 2 ? 0 : p[2],
		  q < p + 3 ? 0 : p[3]);
a2894 5
		reg = -1;	/* always comes here if no register at all */
	      /*
	       * Here with a definitive reg value.
	       */
	      if (reg >= 0)
d2896 81
a2976 2
		  oldq = q;
		  q = p - 1;
a2979 497
    }
  /*
   * have reg. -1:absent; else 0:15
   */

  /*
   * We have:  err, at, len, hash, ndx, sign, paren, reg.
   * Also, any remaining expression is from *p through *q inclusive.
   * Should there be no expression, q==p-1. So expression length = q-p+1.
   * This completes the first part: parsing the operand text.
   */

  /*
   * We now want to boil the data down, checking consistency on the way.
   * We want:  len, mode, reg, ndx, err, p, q, wrn, bug.
   * We will deliver a 4-bit reg, and a 4-bit mode.
   */

  /*
   * Case of branch operand. Different. No L^B^W^I^S^ allowed for instance.
   *
   * in:  at	?
   *      len	?
   *      hash	?
   *      p:q	?
   *      sign  ?
   *      paren	?
   *      reg   ?
   *      ndx   ?
   *
   * out: mode  0
   *      reg   -1
   *      len	' '
   *      p:q	whatever was input
   *      ndx	-1
   *      err	" "		 or error message, and other outputs trashed
   */
  /* branch operands have restricted forms */
  if ((!err || !*err) && access_mode == 'b')
    {
      if (at || hash || sign || paren || ndx >= 0 || reg >= 0 || len != ' ')
	err = _("invalid branch operand");
      else
	err = " ";
    }

  /* Since nobody seems to use it: comment this 'feature'(?) out for now.  */
#ifdef NEVER
  /*
   * Case of stand-alone operand. e.g. ".long foo"
   *
   * in:  at	?
   *      len	?
   *      hash	?
   *      p:q	?
   *      sign  ?
   *      paren	?
   *      reg   ?
   *      ndx   ?
   *
   * out: mode  0
   *      reg   -1
   *      len	' '
   *      p:q	whatever was input
   *      ndx	-1
   *      err	" "		 or error message, and other outputs trashed
   */
  if ((!err || !*err) && access_mode == ' ')
    {
      if (at)
	err = _("address prohibits @@");
      else if (hash)
	err = _("address prohibits #");
      else if (sign)
	{
	  if (sign < 0)
	    err = _("address prohibits -()");
	  else
	    err = _("address prohibits ()+");
	}
      else if (paren)
	err = _("address prohibits ()");
      else if (ndx >= 0)
	err = _("address prohibits []");
      else if (reg >= 0)
	err = _("address prohibits register");
      else if (len != ' ')
	err = _("address prohibits displacement length specifier");
      else
	{
	  err = " ";	/* succeed */
	  mode = 0;
	}
    }
#endif /*#Ifdef NEVER*/

  /*
   * Case of S^#.
   *
   * in:  at       0
   *      len      's'               definition
   *      hash     1              demand
   *      p:q                        demand not empty
   *      sign     0                 by paren==0
   *      paren    0             by "()" scan logic because "S^" seen
   *      reg      -1                or nn by mistake
   *      ndx      -1
   *
   * out: mode     0
   *      reg      -1
   *      len      's'
   *      exp
   *      ndx      -1
   */
  if ((!err || !*err) && len == 's')
    {
      if (!hash || paren || at || ndx >= 0)
	err = _("invalid operand of S^#");
      else
	{
	  if (reg >= 0)
	    {
	      /*
	       * SHIT! we saw S^#Rnn ! put the Rnn back in
	       * expression. KLUDGE! Use oldq so we don't
	       * need to know exact length of reg name.
	       */
	      q = oldq;
	      reg = 0;
	    }
	  /*
	   * We have all the expression we will ever get.
	   */
	  if (p > q)
	    err = _("S^# needs expression");
	  else if (access_mode == 'r')
	    {
	      err = " ";	/* WIN! */
	      mode = 0;
	    }
	  else
	    err = _("S^# may only read-access");
	}
    }

  /*
   * Case of -(Rn), which is weird case.
   *
   * in:  at       0
   *      len      '
   *      hash     0
   *      p:q      q<p
   *      sign     -1                by definition
   *      paren    1              by definition
   *      reg      present           by definition
   *      ndx      optional
   *
   * out: mode     7
   *      reg      present
   *      len      ' '
   *      exp      ""                enforce empty expression
   *      ndx      optional          warn if same as reg
   */
  if ((!err || !*err) && sign < 0)
    {
      if (len != ' ' || hash || at || p <= q)
	err = _("invalid operand of -()");
      else
	{
	  err = " ";		/* win */
	  mode = 7;
	  if (reg == PC)
	    wrn = _("-(PC) unpredictable");
	  else if (reg == ndx)
	    wrn = _("[]index same as -()register: unpredictable");
	}
    }

  /*
   * We convert "(Rn)" to "@@Rn" for our convenience.
   * (I hope this is convenient: has someone got a better way to parse this?)
   * A side-effect of this is that "@@Rn" is a valid operand.
   */
  if (paren && !sign && !hash && !at && len == ' ' && p > q)
    {
      at = 1;
      paren = 0;
    }

  /*
   * Case of (Rn)+, which is slightly different.
   *
   * in:  at
   *      len      ' '
   *      hash     0
   *      p:q      q<p
   *      sign     +1                by definition
   *      paren    1              by definition
   *      reg      present           by definition
   *      ndx      optional
   *
   * out: mode     8+@@
   *      reg      present
   *      len      ' '
   *      exp      ""                enforce empty expression
   *      ndx      optional          warn if same as reg
   */
  if ((!err || !*err) && sign > 0)
    {
      if (len != ' ' || hash || p <= q)
	err = _("invalid operand of ()+");
      else
	{
	  err = " ";		/* win */
	  mode = 8 + (at ? 1 : 0);
	  if (reg == PC)
	    wrn = _("(PC)+ unpredictable");
	  else if (reg == ndx)
	    wrn = _("[]index same as ()+register: unpredictable");
	}
    }

  /*
   * Case of #, without S^.
   *
   * in:  at
   *      len      ' ' or 'i'
   *      hash     1              by definition
   *      p:q
   *      sign     0
   *      paren    0
   *      reg      absent
   *      ndx      optional
   *
   * out: mode     8+@@
   *      reg      PC
   *      len      ' ' or 'i'
   *      exp
   *      ndx      optional
   */
  if ((!err || !*err) && hash)
    {
      if (len != 'i' && len != ' ')
	err = _("# conflicts length");
      else if (paren)
	err = _("# bars register");
      else
	{
	  if (reg >= 0)
	    {
	      /*
	       * SHIT! we saw #Rnn! Put the Rnn back into the expression.
	       * By using oldq, we don't need to know how long Rnn was.
	       * KLUDGE!
	       */
	      q = oldq;
	      reg = -1;		/* no register any more */
	    }
	  err = " ";		/* win */

	  /* JF a bugfix, I think! */
	  if (at && access_mode == 'a')
	    vopP->vop_nbytes = 4;

	  mode = (at ? 9 : 8);
	  reg = PC;
	  if ((access_mode == 'm' || access_mode == 'w') && !at)
	    wrn = _("writing or modifying # is unpredictable");
	}
    }
  /*
   * If !*err, then        sign == 0
   *                       hash == 0
   */

  /*
   * Case of Rn. We separate this one because it has a few special
   * errors the remaining modes lack.
   *
   * in:  at       optional
   *      len      ' '
   *      hash     0             by program logic
   *      p:q      empty
   *      sign     0                 by program logic
   *      paren    0             by definition
   *      reg      present           by definition
   *      ndx      optional
   *
   * out: mode     5+@@
   *      reg      present
   *      len      ' '               enforce no length
   *      exp      ""                enforce empty expression
   *      ndx      optional          warn if same as reg
   */
  if ((!err || !*err) && !paren && reg >= 0)
    {
      if (len != ' ')
	err = _("length not needed");
      else if (at)
	{
	  err = " ";		/* win */
	  mode = 6;		/* @@Rn */
	}
      else if (ndx >= 0)
	err = _("can't []index a register, because it has no address");
      else if (access_mode == 'a')
	err = _("a register has no address");
      else
	{
	  /*
	   * Idea here is to detect from length of datum
	   * and from register number if we will touch PC.
	   * Warn if we do.
	   * vop_nbytes is number of bytes in operand.
	   * Compute highest byte affected, compare to PC0.
	   */
	  if ((vopP->vop_nbytes + reg * 4) > 60)
	    wrn = _("PC part of operand unpredictable");
	  err = " ";		/* win */
	  mode = 5;		/* Rn */
	}
    }
  /*
   * If !*err,        sign  == 0
   *                  hash  == 0
   *                  paren == 1  OR reg==-1
   */

  /*
   * Rest of cases fit into one bunch.
   *
   * in:  at       optional
   *      len      ' ' or 'b' or 'w' or 'l'
   *      hash     0             by program logic
   *      p:q      expected          (empty is not an error)
   *      sign     0                 by program logic
   *      paren    optional
   *      reg      optional
   *      ndx      optional
   *
   * out: mode     10 + @@ + len
   *      reg      optional
   *      len      ' ' or 'b' or 'w' or 'l'
   *      exp                        maybe empty
   *      ndx      optional          warn if same as reg
   */
  if (!err || !*err)
    {
      err = " ";		/* win (always) */
      mode = 10 + (at ? 1 : 0);
      switch (len)
	{
	case 'l':
	  mode += 2;
	case 'w':
	  mode += 2;
	case ' ':		/* assumed B^ until our caller changes it */
	case 'b':
	  break;
	}
    }

  /*
   * here with completely specified     mode
   *					len
   *					reg
   *					expression   p,q
   *					ndx
   */

  if (*err == ' ')
    err = 0;			/* " " is no longer an error */

  vopP->vop_mode = mode;
  vopP->vop_reg = reg;
  vopP->vop_short = len;
  vopP->vop_expr_begin = p;
  vopP->vop_expr_end = q;
  vopP->vop_ndx = ndx;
  vopP->vop_error = err;
  vopP->vop_warn = wrn;
}

/*

  Summary of vip_op outputs.

  mode	reg	len	ndx
  (Rn) => @@Rn
  {@@}Rn			5+@@	n	' '	optional
  branch operand		0	-1	' '	-1
  S^#foo			0	-1	's'	-1
  -(Rn)			7	n	' '	optional
  {@@}(Rn)+		8+@@	n	' '	optional
  {@@}#foo, no S^		8+@@	PC	" i"	optional
  {@@}{q^}{(Rn)}		10+@@+q	option	" bwl"	optional

  */

#ifdef TEST			/* #Define to use this testbed.  */

/*
 * Follows a test program for this function.
 * We declare arrays non-local in case some of our tiny-minded machines
 * default to small stacks. Also, helps with some debuggers.
 */

#include <stdio.h>

char answer[100];		/* human types into here */
char *p;			/*  */
char *myerr;
char *mywrn;
char *mybug;
char myaccess;
char mywidth;
char mymode;
char myreg;
char mylen;
char *myleft;
char *myright;
char myndx;
int my_operand_length;
char my_immediate[200];
char my_indirect[200];
char my_displen[200];

main ()
{
  printf ("enter immediate symbols eg enter #   ");
  gets (my_immediate);
  printf ("enter indirect symbols  eg enter @@   ");
  gets (my_indirect);
  printf ("enter displen symbols   eg enter ^   ");
  gets (my_displen);
  vip_op_defaults (my_immediate, my_indirect, my_displen);
  for (;;)
    {
      printf ("access,width (eg 'ab' or 'wh') [empty line to quit] :  ");
      fflush (stdout);
      gets (answer);
      if (!answer[0])
	exit (EXIT_SUCCESS);
      myaccess = answer[0];
      mywidth = answer[1];
      switch (mywidth)
	{
	case 'b':
	  my_operand_length = 1;
	  break;
	case 'd':
	  my_operand_length = 8;
	  break;
	case 'f':
	  my_operand_length = 4;
	  break;
	case 'g':
	  my_operand_length = 16;
	  break;
	case 'h':
	  my_operand_length = 32;
	  break;
	case 'l':
	  my_operand_length = 4;
	  break;
	case 'o':
	  my_operand_length = 16;
	  break;
	case 'q':
	  my_operand_length = 8;
	  break;
	case 'w':
	  my_operand_length = 2;
	  break;
	case '!':
	case '?':
	case '-':
	  my_operand_length = 0;
	  break;

	default:
	  my_operand_length = 2;
	  printf ("I dn't understand access width %c\n", mywidth);
	  break;
	}
      printf ("VAX assembler instruction operand: ");
      fflush (stdout);
      gets (answer);
      mybug = vip_op (answer, myaccess, mywidth, my_operand_length,
		      &mymode, &myreg, &mylen, &myleft, &myright, &myndx,
		      &myerr, &mywrn);
      if (*myerr)
	{
	  printf ("error: \"%s\"\n", myerr);
	  if (*mybug)
	    printf (" bug: \"%s\"\n", mybug);
	}
d2982 201
a3182 61
	  if (*mywrn)
	    printf ("warning: \"%s\"\n", mywrn);
	  mumble ("mode", mymode);
	  mumble ("register", myreg);
	  mumble ("index", myndx);
	  printf ("width:'%c'  ", mylen);
	  printf ("expression: \"");
	  while (myleft <= myright)
	    putchar (*myleft++);
	  printf ("\"\n");
	}
    }
}

mumble (text, value)
     char *text;
     int value;
{
  printf ("%s:", text);
  if (value >= 0)
    printf ("%xx", value);
  else
    printf ("ABSENT");
  printf ("  ");
}

#endif /* ifdef TEST */

/* end: vip_op.c */

int md_short_jump_size = 3;
int md_long_jump_size = 6;

void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  valueT offset;

  /* This former calculation was off by two:
      offset = to_addr - (from_addr + 1);
     We need to account for the one byte instruction and also its
     two byte operand.  */
  offset = to_addr - (from_addr + 1 + 2);
  *ptr++ = VAX_BRW;		/* branch with word (16 bit) offset */
  md_number_to_chars (ptr, offset, 2);
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  valueT offset;
d3184 31
a3214 22
  offset = to_addr - S_GET_VALUE (to_symbol);
  *ptr++ = VAX_JMP;		/* arbitrary jump */
  *ptr++ = VAX_ABSOLUTE_MODE;
  md_number_to_chars (ptr, offset, 4);
  fix_new (frag, ptr - frag->fr_literal, 4, to_symbol, (long) 0, 0, NO_RELOC);
}

#ifdef OBJ_VMS
const char *md_shortopts = "d:STt:V+1h:Hv::";
#elif defined(OBJ_ELF)
const char *md_shortopts = "d:STt:VkKQ:";
#else
const char *md_shortopts = "d:STt:V";
#endif
struct option md_longopts[] = {
#ifdef OBJ_ELF
#define OPTION_PIC (OPTION_MD_BASE)
  {"pic", no_argument, NULL, OPTION_PIC},
#endif
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);
d3216 1
a3216 10
int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
    {
    case 'S':
      as_warn (_("SYMBOL TABLE not implemented"));
      break;
d3218 2
a3219 3
    case 'T':
      as_warn (_("TOKEN TRACE not implemented"));
      break;
d3221 27
a3247 57
    case 'd':
      as_warn (_("Displacement length %s ignored!"), arg);
      break;

    case 't':
      as_warn (_("I don't need or use temp. file \"%s\"."), arg);
      break;

    case 'V':
      as_warn (_("I don't use an interpass file! -V ignored"));
      break;

#ifdef OBJ_VMS
    case '+':			/* For g++.  Hash any name > 31 chars long.  */
      flag_hash_long_names = 1;
      break;

    case '1':			/* For backward compatibility */
      flag_one = 1;
      break;

    case 'H':			/* Show new symbol after hash truncation */
      flag_show_after_trunc = 1;
      break;

    case 'h':			/* No hashing of mixed-case names */
      {
	extern char vms_name_mapping;
	vms_name_mapping = atoi (arg);
	flag_no_hash_mixed_case = 1;
      }
      break;

    case 'v':
      {
	extern char *compiler_version_string;
	if (!arg || !*arg || access (arg, 0) == 0)
	  return 0;		/* have caller show the assembler version */
	compiler_version_string = arg;
      }
      break;
#endif

#ifdef OBJ_ELF
    case OPTION_PIC:
    case 'k':
      flag_want_pic = 1;
      break;			/* -pic, Position Independent Code */

     /* -Qy, -Qn: SVR4 arguments controlling whether a .comment
	section should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;
#endif

    default:
      return 0;
a3248 2

  return 1;
d3252 1
a3252 2
md_show_usage (stream)
     FILE *stream;
d3254 3
a3256 21
  fprintf (stream, _("\
VAX options:\n\
-d LENGTH		ignored\n\
-J			ignored\n\
-S			ignored\n\
-t FILE			ignored\n\
-T			ignored\n\
-V			ignored\n"));
#ifdef OBJ_VMS
  fprintf (stream, _("\
VMS options:\n\
-+			hash encode names longer than 31 characters\n\
-1			`const' handling compatible with gcc 1.x\n\
-H			show new symbol after hash truncation\n\
-h NUM			don't hash mixed-case names, and adjust case:\n\
			0 = upper, 2 = lower, 3 = preserve case\n\
-v\"VERSION\"		code being assembled was produced by compiler \"VERSION\"\n"));
#endif
}

/* We have no need to default values of symbols.  */
d3258 2
a3259 6
symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}
d3261 3
a3263 31
/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
{
  return size;			/* Byte alignment is fine */
}

/* Exactly what point is a PC-relative offset relative TO?
   On the vax, they're relative to the address of the offset, plus
   its size. */
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;
  bfd_reloc_code_real_type code;

  if (fixp->fx_tcbit)
    abort();

  if (fixp->fx_r_type != BFD_RELOC_NONE)
d3265 2
a3266 40
      code = fixp->fx_r_type;

      if (fixp->fx_pcrel)
	{
	  switch (code)
	    {
	    case BFD_RELOC_8_PCREL:
	    case BFD_RELOC_16_PCREL:
	    case BFD_RELOC_32_PCREL:
#ifdef OBJ_ELF
	    case BFD_RELOC_8_GOT_PCREL:
	    case BFD_RELOC_16_GOT_PCREL:
	    case BFD_RELOC_32_GOT_PCREL:
	    case BFD_RELOC_8_PLT_PCREL:
	    case BFD_RELOC_16_PLT_PCREL:
	    case BFD_RELOC_32_PLT_PCREL:
#endif
	      break;
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("Cannot make %s relocation PC relative"),
			    bfd_get_reloc_code_name (code));
	    }
	}
    }
  else
    {
#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
      switch (F (fixp->fx_size, fixp->fx_pcrel))
	{
#define MAP(SZ,PCREL,TYPE)	case F(SZ,PCREL): code = (TYPE); break
	  MAP (1, 0, BFD_RELOC_8);
	  MAP (2, 0, BFD_RELOC_16);
	  MAP (4, 0, BFD_RELOC_32);
	  MAP (1, 1, BFD_RELOC_8_PCREL);
	  MAP (2, 1, BFD_RELOC_16_PCREL);
	  MAP (4, 1, BFD_RELOC_32_PCREL);
	default:
	  abort ();
	}
a3267 20
#undef F
#undef MAP

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
#ifndef OBJ_ELF
  if (fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else
    reloc->addend = 0;
#else
  reloc->addend = fixp->fx_offset;
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  assert (reloc->howto != 0);

  return reloc;
a3268 2

/* end of tc-vax.c */
@


1.27
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a32 4
#if defined (OBJ_AOUT) && !defined (BFD_ASSEMBLER) && defined (TE_NetBSD)
#include <netinet/in.h>
#endif

d321 1
a321 1
#ifdef BFD_ASSEMBLER
a325 1
#endif
a748 1
#ifdef BFD_ASSEMBLER
a750 4
#else
      is_undefined = (to_seg == SEG_UNKNOWN);
      is_absolute = (to_seg == SEG_ABSOLUTE);
#endif
a826 1
#ifdef BFD_ASSEMBLER
a827 3
#else
			       &abs_symbol,
#endif
a910 1
#ifdef BFD_ASSEMBLER
a911 3
#else
			       &abs_symbol,
#endif
a1426 1
#ifdef BFD_ASSEMBLER
a1431 7
#else
void
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP;
#endif
a1595 36
#ifdef OBJ_AOUT
#ifndef BFD_ASSEMBLER
void
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  /*
   * In: length of relocation (or of address) in chars: 1, 2 or 4.
   * Out: GNU LD relocation length code: 0, 1, or 2.
   */

  static const unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
  long r_symbolnum;

  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
       fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  where[6] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[4] = r_symbolnum & 0x0ff;
  where[7] = ((((!S_IS_DEFINED (fixP->fx_addsy)) << 3) & 0x08)
	      | ((nbytes_r_length[fixP->fx_size] << 1) & 0x06)
	      | (((fixP->fx_pcrel << 0) & 0x01) & 0x0f));
}
#endif /* !BFD_ASSEMBLER */
#endif /* OBJ_AOUT */

a3219 1
const int md_reloc_size = 8;	/* Size of relocation record */
a3401 15
#ifdef OBJ_AOUT
#ifndef BFD_ASSEMBLER
void
tc_headers_hook(headers)
     object_headers *headers;
{
#ifdef TE_NetBSD
  N_SET_INFO(headers->header, OMAGIC, M_VAX4K_NETBSD, 0);
  headers->header.a_info = htonl (headers->header.a_info);
#endif
}
#endif /* !BFD_ASSEMBLER */
#endif /* OBJ_AOUT */

#ifdef BFD_ASSEMBLER
a3476 1
#endif	/* BFD_ASSEMBLER */
@


1.26
log
@Don't assume a valueT is 4 bytes.
@
text
@d319 1
a319 1
md_apply_fix3 (fixP, valueP, seg)
@


1.25
log
@Update the address and phone number of the FSF
@
text
@d1193 11
a1203 12
			      /*
			       * If nbytes > 4, then we are scrod. We
			       * don't know if the high order bytes
			       * are to be 0xFF or 0x00.  BSD4.2 & RMS
			       * say use 0x00. OK --- but this
			       * assembler needs ANOTHER rewrite to
			       * cope properly with this bug.  */
			      md_number_to_chars (p + 1, this_add_number, min (4, nbytes));
			      if (nbytes > 4)
				{
				  memset (p + 5, '\0', nbytes - 4);
				}
@


1.24
log
@	* Makefile.am (GAS_CFILES): Remove bignum-copy.c.
	(GENERIC_OBJS): Likewise, remove bignum-copy.o.
	(bignum-copy.o): Remove.
	* Makefile.in: Regenerate.
	* makefile.vms (OBJS): Remove bignum-copy.obj.
	* symbols.h (local_symbol_make): Remove declaration.
	(verify_symbol_chain_2): Likewise.
	* symbols.c (local_symbol_make): Make static.
	(max_indent_level): Likewise.
	(verify_symbol_chain_2): Remove.
	* macro.c (macro_hash): Make static.
	* messages.c (fprint_value): Remove.
	* read.h (get_absolute_expr): Remove.
	(emit_leb128_expr): Likewise.
	(do_s_func): Likewise.
	* read.c (do_s_func): Make static.
	(emit_leb128_expr): Likewise.
	(get_absolute_expr): Likewise.
	* as.h (as_howmuch): Remove declaration.
	(fprint_value): Likewise.
	* as.c (myname): Make static.
	* input-scrub.c (as_howmuch): Remove.
	(as_1_char): Likewise.
	* input-file.h (input_file_is_open): Remove.
	* input-file.c (input_file_is_open): Likewise.
	* expr.h (expr_build_unary): Remove declaration.
	(expr_build_binary): Likewise.
	* expr.c (expr_build_unary): Remove.
	(expr_build_binary): Likewise.
	* hash.h (hash_replace): Remove declaration.
	(hash_delete): Likewise.
	* hash.c (hash_replace): Remove.
	(hash_delete): Likewise.
	* bignum-copy.c (bignum_copy): Move from here ..
	* config/tc-vax.c (bignum_copy): .. to here.
	* bignum.h (LOG_TO_BASE_2_OF_10): Remove.
	(bignum_copy): Remove extern declaration.
	* sb.h (string_count): Remove extern declaration.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* sb.c (dsize): Replace preprocessor macro with static int.
	(string_count): Make static.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* config/obj-coff.c (dim_index): Make static.
	* config/tc-i386.c (GOT_symbol): Likewise.
	(output_invalid_buf): Likewise.
	* doc/internals.texi (Warning and error messages): Remove the
	prototype for fprint_value.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.23
log
@Support the .f_floating, .d_floating, .g_floating and .h_floating directives
for the VAX target in order to be more compatible with the VAX MACRO assembler.
@
text
@d351 54
@


1.22
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d254 4
@


1.21
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d670 2
a671 1
  opcode_as_number = md_chars_to_number (opcode_as_chars = v.vit_opcode, 4);
@


1.20
log
@	* symbols.c (colon) [!WORKING_DOT_WORD]: Don't declare
	md_short_jump_size, md_long_jump_size.
	* write.c [!WORKING_DOT_WORD]: Ditto.
	* tc.h [!WORKING_DOT_WORD]: Declare them here.  Drop const
	qualifier.
	* config/tc-cris.h (md_short_jump_size, md_long_jump_size): Don't
	declare.
	* config/tc-cris.c (md_short_jump_size, md_long_jump_size): Drop
	const qualifier in these definitions.
	* config/tc-i370.c, config/tc-m68k.c, config/tc-pdp11.c,
	config/tc-s390.c, config/tc-tahoe.c, config/tc-vax.c: Ditto.
@
text
@d2 2
a3 1
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d33 4
d3415 1
a3415 1
  headers->header.a_info = htonl(headers->header.a_info);
@


1.19
log
@Add vax-linux-gnu target
@
text
@d3217 2
a3218 2
const int md_short_jump_size = 3;
const int md_long_jump_size = 6;
@


1.18
log
@	* config/atof-tahoe.c: Fix comment typos.
	* config/m68k-parse.y: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-bout.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/te-delt88.h: Likewise.
	* config/te-delta.h: Likewise.
	* config/te-generic.h: Likewise.
	* config/te-macos.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-psos.h: Likewise.
	* config/te-sun3.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/xtensa-relax.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001, 2002
d3260 1
a3260 1
const char *md_shortopts = "d:STt:VkK";
d3336 5
@


1.17
log
@2003-09-26  Matt Thomas  <matt@@3am-software.com>

* config/tc-vax.c (md_shortopts): Fix a typo.  Remove 'K'.
(OPTION_PIC): Define.
(md_longopts): Add "pic" option.
(md_parse_option): Change 'K' to OPTION_PIC.
@
text
@d1915 1
a1915 1
	   * We expect comma to seperate each operand.
d2204 1
a2204 1
 * than using seperate return pointers for each result, but runs faster
d2388 1
a2388 1
 * character means indirect (deferred) mode but elswhere it is a shift
d2612 1
a2612 1
		  /* JF allow parenthasized expressions.  I hope this works */
d2964 1
a2964 1
   * Case of Rn. We seperate this one because it has a few special
@


1.16
log
@* config/tc-vax.c (md_estimate_size_before_relax): Only try to
convert undefined references to GOT32/PLT32 if PIC code is
requested.  Fix comment.
@
text
@d3259 1
a3259 1
#elif defined(OBJ_ELC)
d3265 4
d3332 1
a3332 1
    case 'K':
@


1.15
log
@2002-06-08  Matt Thomas  <matt@@3am-software.com>

* configure.in (vax-*-netbsdelf*, vax-*-netbsdaout*)
(vax-*-netbsd*): New targets.
* configure: Regenerate.
* config/aout_gnu.h (enum machine_type): Add M_VAX4K_NETBSD.
* config/tc-vax.c: Add support for ELF and PIC.
(flag_want_pic): New flag.
(float_cons): Fix prototype.
(md_apply_fix3): Adjust for BFD_ASSEMBLER.
(md_assemble): Introduce a new is_absolute local, and use it
rather than repeating the test.  Make fatal errors actually
fatal by using as_fatal as appropriate.  Adjust for BFD_ASSEMBLER.
Add support for ELF.  Add support for PIC.
(md_convert_frag): Adjust for BFD_ASSEMBLER.
(tc_aout_fix_to_chars): Only include if OBJ_AOUT and not
BFD_ASSEMBLER.
(vax_reg_parse): Make the % register prefix mandatory for ELF,
optional for a.out, and not allowed for VMS.  Adjust all callers.
(md_create_short_jump): Add ATTRIBUTE_UNUSED to unused arguments.
(md_create_long_jump): Likewise.
(md_undefined_symbol): Likewise.
(md_section_align): Likewise.
(md_shortopts): Allow -k and -K for ELF.
(md_parse_option): Set flag_want_pic if -k or -K.
(tc_headers_hook): New function if OBJ_AOUT and not BFD_ASSEMBLER.
(tc_gen_reloc): New function if BFD_ASSEMBLER.
* config/tc-vax.h (tc_headers_hook): Remove.
(TARGET_FORMAT): Set according to object format and target
environment.
(BFD_ARCH, TARGET_ARCH): Define.
(NO_RELOC): Adjust for BFD_ASSEMBLER.
(TC_RELOC_RTSYM_LOC_FIXUP, TC_FIX_ADJUSTABLE)
(tc_fix_adjustable): Define if BFD_ASSEMBLER.
* config/vax-inst.h (VAX_JSB, VAX_CALLS, VAX_CALLG): Define.
@
text
@d1247 5
a1251 6
	  /*
	   * If this is to undefined symbol, then if it's an indirect
	   * reference indicate that is can mutated into a GLOB_DAT
	   * by the loader.  We restrict ourselves to no offset due to
	   * a limitation in the NetBSD linker.
	   */
d1259 1
a1271 1
	
@


1.14
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d26 5
d66 7
d77 3
d241 1
a241 1
void float_cons ();
d249 1
a249 1
  {0},
d269 1
d274 2
d311 2
a312 2
     fixS * fixP;
     valueT * valueP;
d316 8
a323 3

  number_to_chars_littleendian (fixP->fx_where + fixP->fx_frag->fr_literal,
				value, fixP->fx_size);
d351 2
d403 1
a403 1
      as_warn (_("Ignoring statement due to \"%s\""), v.vit_error);
d422 1
a422 1
	  as_warn (_("Ignoring statement because \"%s\""), operandP->vop_error);
d469 1
a469 1
	      as_warn (_("Can't relocate expression"));
d647 1
a647 1
	      as_warn ("Junk at end of expression \"%s\"", input_line_pointer);
d690 4
d695 2
d765 1
a765 1
	      if (to_seg == SEG_ABSOLUTE)
d772 7
a778 3
		      fix_new (frag_now, p - frag_now->fr_literal,
			       nbytes, &abs_symbol, this_add_number,
			       1, NO_RELOC);
d854 1
a854 1
		  /* to_seg != now_seg && to_seg != SEG_UNKNOWN && to_Seg != SEG_ABSOLUTE */
d860 7
a866 3
		      fix_new (frag_now, p - frag_now->fr_literal,
			       nbytes, &abs_symbol, this_add_number,
			       1, NO_RELOC);
d957 1
a957 1
	      if (to_seg == SEG_ABSOLUTE)
d996 6
d1003 1
a1003 1
			       ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE),
d1028 1
a1028 1
			  know (to_seg == SEG_ABSOLUTE);
d1043 6
a1048 1
			  if (is_undefined)
d1050 7
d1063 1
a1063 1
			       ENCODE_RELAX (STATE_PC_RELATIVE, STATE_UNDF),
d1065 1
a1065 1
					    0);
d1103 1
a1103 1
			  && to_seg == SEG_ABSOLUTE && (expP->X_op != O_big)
d1119 7
d1127 1
a1127 1
			  if ((to_seg == SEG_ABSOLUTE) && (expP->X_op != O_big))
d1182 1
a1182 1
			  if (to_seg == SEG_ABSOLUTE)
d1204 1
a1204 1
		      if (to_seg == SEG_ABSOLUTE)
d1232 6
a1237 1
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
d1240 1
d1246 38
d1290 1
a1290 1
		       fragP->fr_offset, 1, NO_RELOC);
d1383 1
d1386 8
a1393 2
     object_headers *headers;
     segT seg;
d1395 1
a1402 4
  long address_of_var;
  /* Where, in file space, is _var of *fragP? */
  long target_address = 0;
  /* Where, in file space, does addr point? */
a1409 2
  target_address = S_GET_VALUE (symbolP) + fragP->fr_offset;
  address_of_var = fragP->fr_address + where;
d1416 3
a1418 2
      addressP[0] |= 0xAF;	/* Byte displacement.  */
      addressP[1] = target_address - (address_of_var + 2);
d1424 3
a1426 2
      addressP[0] |= 0xCF;	/* Word displacement.  */
      md_number_to_chars (addressP + 1, target_address - (address_of_var + 3), 2);
d1432 3
a1434 2
      addressP[0] |= 0xEF;	/* Long word displacement.  */
      md_number_to_chars (addressP + 1, target_address - (address_of_var + 5), 4);
d1439 2
a1440 1
      addressP[0] = target_address - (address_of_var + 1);
d1447 3
a1449 2
      addressP[1] = VAX_BRB + VAX_WIDEN_WORD;
      md_number_to_chars (addressP + 2, target_address - (address_of_var + 4), 2);
d1458 2
a1459 1
      md_number_to_chars (addressP + 3, target_address - (address_of_var + 7), 4);
d1464 2
a1465 1
      addressP[0] = target_address - (address_of_var + 1);
d1471 2
a1472 1
      md_number_to_chars (addressP, target_address - (address_of_var + 2), 2);
d1479 2
a1480 1
      md_number_to_chars (addressP + 1, target_address - (address_of_var + 5), 4);
d1485 2
a1486 1
      md_number_to_chars (addressP, target_address - (address_of_var + 2), 2);
d1497 2
a1498 1
      md_number_to_chars (addressP + 6, target_address - (address_of_var + 10), 4);
d1503 2
a1504 1
      addressP[0] = target_address - (address_of_var + 1);
d1513 2
a1514 1
      md_number_to_chars (addressP + 4, target_address - (address_of_var + 6), 2);
d1524 2
a1525 1
      md_number_to_chars (addressP + 5, target_address - (address_of_var + 9), 4);
d1560 2
d1593 2
d2109 2
a2110 2
vax_reg_parse (c1, c2, c3)	/* 3 chars of register name */
     char c1, c2, c3;		/* c3 == 0 if 2-character reg name */
d2116 22
d2541 1
a2541 1
	    ndx = vax_reg_parse (q[1], q[2], 0);
d2543 3
a2545 1
	    ndx = vax_reg_parse (q[1], q[2], q[3]);
d2598 1
a2598 1
		reg = vax_reg_parse (q[1], q[2], 0);
d2600 3
a2602 1
		reg = vax_reg_parse (q[1], q[2], q[3]);
d2672 5
a2676 2
	      if (q > p && q < p + 3)	/* room for Rn or Rnn exactly? */
		reg = vax_reg_parse (p[0], p[1], q < p + 2 ? 0 : p[2]);
d3225 4
a3228 3
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
d3244 2
a3245 1
     addressT from_addr, to_addr;
d3260 2
d3328 7
d3370 1
a3370 1
     char *name;
d3378 1
a3378 1
     segT segment;
d3386 1
a3386 1
   its size. (??? Is this right?  FIXME-SOON) */
d3393 92
@


1.13
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001
d3100 1
a3100 1
CONST char *md_shortopts = "d:STt:V+1h:Hv::";
d3102 1
a3102 1
CONST char *md_shortopts = "d:STt:V";
@


1.12
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d292 4
a295 3
md_apply_fix (fixP, value)
     fixS *fixP;
     long value;
d297 2
d300 4
a303 1
				(valueT) value, fixP->fx_size);
@


1.11
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@d1968 1
a1968 1
#include <ctype.h>
d1982 3
a1984 5
  if (isupper (c1))
    c1 = tolower (c1);
  if (isupper (c2))
    c2 = tolower (c2);
  if (isdigit (c2) && c1 == 'r')
d1987 1
a1987 1
      if (isdigit (c3))
d2333 1
a2333 2
    if (isupper (c))
      c = tolower (c);
@


1.10
log
@Fix copyright notices
@
text
@d184 2
d193 1
d198 1
d203 1
d208 1
d213 1
d217 1
d1151 4
a1154 12
/*
 *			md_estimate_size_before_relax()
 *
 * Called just before relax().
 * Any symbol that is now undefined will not become defined.
 * Return the correct fr_subtype in the frag.
 * Return the initial "guess for fr_var" to caller.
 * The guess for fr_var is ACTUALLY the growth beyond fr_fix.
 * Whatever we do to grow fr_fix or fr_var contributes to our returned value.
 * Although it may not be explicit in the frag, pretend fr_var starts with a
 * 0 value.
 */
d1160 1
a1160 5
  char *p;
  int old_fr_fix;

  old_fr_fix = fragP->fr_fix;
  switch (fragP->fr_subtype)
d1162 1
a1162 6
    case ENCODE_RELAX (STATE_PC_RELATIVE, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
	{			/* A relaxable case.  */
	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	}
      else
d1164 5
d1170 53
a1222 4
	  p[0] |= VAX_PC_RELATIVE_MODE;	/* Preserve @@ bit.  */
	  fragP->fr_fix += 1 + 4;
	  fix_new (fragP, old_fr_fix + 1, 4, fragP->fr_symbol,
		   fragP->fr_offset, 1, NO_RELOC);
d1224 3
a1227 1
      break;
d1229 3
a1231 2
    case ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
d1233 4
d1238 2
a1239 18
	}
      else
	{
	  p = fragP->fr_literal + old_fr_fix;
	  *fragP->fr_opcode ^= 1;	/* Reverse sense of branch.  */
	  p[0] = 6;
	  p[1] = VAX_JMP;
	  p[2] = VAX_PC_RELATIVE_MODE;	/* ...(PC) */
	  fragP->fr_fix += 1 + 1 + 1 + 4;
	  fix_new (fragP, old_fr_fix + 3, 4, fragP->fr_symbol,
		   fragP->fr_offset, 1, NO_RELOC);
	  frag_wane (fragP);
	}
      break;

    case ENCODE_RELAX (STATE_COMPLEX_BRANCH, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
	{
d1241 2
a1242 20
	}
      else
	{
	  p = fragP->fr_literal + old_fr_fix;
	  p[0] = 2;
	  p[1] = 0;
	  p[2] = VAX_BRB;
	  p[3] = 6;
	  p[4] = VAX_JMP;
	  p[5] = VAX_PC_RELATIVE_MODE;	/* ...(pc) */
	  fragP->fr_fix += 2 + 2 + 1 + 1 + 4;
	  fix_new (fragP, old_fr_fix + 6, 4, fragP->fr_symbol,
		   fragP->fr_offset, 1, NO_RELOC);
	  frag_wane (fragP);
	}
      break;

    case ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
	{
d1244 4
d1249 1
a1249 14
      else
	{
	  p = fragP->fr_literal + old_fr_fix;
	  p[0] = 2;
	  p[1] = VAX_BRB;
	  p[2] = 6;
	  p[3] = VAX_JMP;
	  p[4] = VAX_PC_RELATIVE_MODE;	/* ...(pc) */
	  fragP->fr_fix += 1 + 2 + 1 + 1 + 4;
	  fix_new (fragP, old_fr_fix + 5, 4, fragP->fr_symbol,
		   fragP->fr_offset, 1, NO_RELOC);
	  frag_wane (fragP);
	}
      break;
d1251 2
a1252 16
    case ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_UNDF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
	{
	  fragP->fr_subtype = ENCODE_RELAX (STATE_ALWAYS_BRANCH, STATE_BYTE);
	}
      else
	{
	  p = fragP->fr_literal + old_fr_fix;
	  *fragP->fr_opcode += VAX_WIDEN_LONG;
	  p[0] = VAX_PC_RELATIVE_MODE;	/* ...(PC) */
	  fragP->fr_fix += 1 + 4;
	  fix_new (fragP, old_fr_fix + 1, 4, fragP->fr_symbol,
		   fragP->fr_offset, 1, NO_RELOC);
	  frag_wane (fragP);
	}
      break;
d1254 3
a1256 5
    default:
      break;
    }
  return (fragP->fr_var + fragP->fr_fix - old_fr_fix);
}				/* md_estimate_size_before_relax() */
a1276 1
  short int length_code;	/* 2=long 1=word 0=byte */
a1286 2
  length_code = fragP->fr_subtype & 3;	/* depends on ENCODE_RELAX() */
  know (length_code >= 0 && length_code < 3);
@


1.9
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 98, 99, 2000
@


1.9.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001
@


1.9.2.2
log
@Merge from mainline.
@
text
@a183 2
#define RELAX_STATE(s) ((s) >> 2)
#define RELAX_LENGTH(s) ((s) & 3)
a190 1

a194 1

a198 1

a202 1

a206 1

a209 1
  {1, 1, 0, 0},			/* unused	    5,3 */
d1143 12
a1154 4
/* md_estimate_size_before_relax(), called just before relax().
   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag and the growth beyond
   fr_fix.  */
d1160 5
a1164 1
  if (RELAX_LENGTH (fragP->fr_subtype) == STATE_UNDF)
d1166 6
a1171 1
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
d1173 8
a1180 3
	  /* Non-relaxable cases.  */
	  char *p;
	  int old_fr_fix;
d1182 7
a1188 1
	  old_fr_fix = fragP->fr_fix;
d1190 10
a1199 8
	  switch (RELAX_STATE (fragP->fr_subtype))
	    {
	    case STATE_PC_RELATIVE:
	      p[0] |= VAX_PC_RELATIVE_MODE;	/* Preserve @@ bit.  */
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;
d1201 20
a1220 9
	    case STATE_CONDITIONAL_BRANCH:
	      *fragP->fr_opcode ^= 1;		/* Reverse sense of branch.  */
	      p[0] = 6;
	      p[1] = VAX_JMP;
	      p[2] = VAX_PC_RELATIVE_MODE;	/* ...(PC) */
	      fragP->fr_fix += 1 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 3, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;
d1222 16
a1237 34
	    case STATE_COMPLEX_BRANCH:
	      p[0] = 2;
	      p[1] = 0;
	      p[2] = VAX_BRB;
	      p[3] = 6;
	      p[4] = VAX_JMP;
	      p[5] = VAX_PC_RELATIVE_MODE;	/* ...(pc) */
	      fragP->fr_fix += 2 + 2 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 6, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    case STATE_COMPLEX_HOP:
	      p[0] = 2;
	      p[1] = VAX_BRB;
	      p[2] = 6;
	      p[3] = VAX_JMP;
	      p[4] = VAX_PC_RELATIVE_MODE;	/* ...(pc) */
	      fragP->fr_fix += 1 + 2 + 1 + 1 + 4;
	      fix_new (fragP, old_fr_fix + 5, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    case STATE_ALWAYS_BRANCH:
	      *fragP->fr_opcode += VAX_WIDEN_LONG;
	      p[0] = VAX_PC_RELATIVE_MODE;	/* ...(PC) */
	      fragP->fr_fix += 1 + 4;
	      fix_new (fragP, old_fr_fix + 1, 4, fragP->fr_symbol,
		       fragP->fr_offset, 1, NO_RELOC);
	      break;

	    default:
	      abort ();
	    }
a1238 3

	  /* Return the growth in the fixed part of the frag.  */
	  return fragP->fr_fix - old_fr_fix;
d1240 1
d1242 2
a1243 3
      /* Relaxable cases.  Set up the initial guess for the variable
	 part of the frag.  */
      switch (RELAX_STATE (fragP->fr_subtype))
a1244 13
	case STATE_PC_RELATIVE:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_PC_RELATIVE, STATE_BYTE);
	  break;
	case STATE_CONDITIONAL_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_CONDITIONAL_BRANCH, STATE_BYTE);
	  break;
	case STATE_COMPLEX_BRANCH:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_COMPLEX_BRANCH, STATE_WORD);
	  break;
	case STATE_COMPLEX_HOP:
	  fragP->fr_subtype = ENCODE_RELAX (STATE_COMPLEX_HOP, STATE_BYTE);
	  break;
	case STATE_ALWAYS_BRANCH:
a1245 1
	  break;
d1247 14
d1262 2
a1263 7

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}
d1284 1
d1295 2
@


1.8
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@a3206 1
/* ARGSUSED */
@


1.7
log
@Remove jbssi and jbcci.
@
text
@d3114 1
a3114 1
size_t md_longopts_size = sizeof(md_longopts);
d3185 1
a3185 1
  fprintf(stream, _("\
@


1.6
log
@2000-09-07  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-vax.c: Fix formatting.
	* input-scrub.c: Likewise.
@
text
@a115 2
 bbssi		e6
 bbcci		e7
a1663 2
  {"jbssi",	{"rlvbb?", 0x800000e6}},
  {"jbcci",	{"rlvbb?", 0x800000e7}},
@


1.5
log
@Correctly calculate the pc relative offset of the target destination for jmp
instructions.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 98, 1999
d31 2
a32 2
/* These chars only start a comment at the beginning of a line. */
/* Note that for the VAX the are the same as comment_chars above. */
d53 1
a53 1
/* A vax instruction after decoding. */
d56 1
a56 1
/* Hold details of big operands. */
d59 1
a59 1
/* Above is made to point into big_operand_bits by md_begin(). */
d176 1
a176 1
   Forward, Backward. */
a182 1

d184 1
a184 1
/* This macro has no side-effects. */
d233 1
a233 1
#define STATE_ALWAYS_BRANCH		(3)	/* includes BSB... */
a241 1

d285 1
a285 1
void				/* Knows about order of bytes in address. */
d296 2
a297 2
     unsigned char con[];	/* Low order byte 1st. */
     int nbytes;		/* Number of bytes in the input. */
d312 1
a312 1
     char *instruction_string;	/* A string: assemble 1 instruction. */
d314 1
a314 1
  /* Non-zero if operand expression's segment is not known yet. */
d319 1
a319 1
  /* An operand. Scans all operands. */
d322 1
a322 1
			/* What used to live after an expression. */
d324 1
a324 1
  /* 1: instruction_string bad for all passes. */
d332 1
a332 1
  /* These refer to an instruction operand expression. */
d336 1
a336 1
  /* Positive (minuend) symbol. */
d338 1
a338 1
  /* As a number. */
d340 1
a340 1
  /* Least significant byte 1st. */
d342 1
a342 1
  /* As an array of characters. */
d345 1
a345 1
  /* length (bytes) meant by vop_short. */
d347 1
a347 1
  /* 0, or 1 if '@@' is in addressing mode. */
d353 1
a353 1
  /* Big enough for any floating point literal. */
d391 1
a391 1
	  int can_be_short = 0;	/* 1 if a bignum can be reduced to a short literal. */
d396 1
a396 1
	  /* If to_seg == SEG_PASS1, expression() will have set need_pass_2 = 1. */
d436 1
a436 1
	      /* Preserve the bits. */
d499 1
a499 1
		  /* Saw a '#'. */
d502 1
a502 1
		      /* We must chose S^ or I^. */
d505 1
a505 1
			  /* Bignum: Short literal impossible. */
d508 1
a508 1
			  operandP->vop_reg = 0xF;	/* VAX PC. */
d512 1
a512 1
			  /* Flonum: Try to do it. */
d528 2
a529 2
		    }		/*  if #, but no S^ or I^ seen. */
		  /* No more ' ' case: either 's' or 'i'. */
d532 1
a532 1
		      /* Wants to be a short literal. */
d538 1
a538 1
			  operandP->vop_reg = 0xF;	/* VAX PC. */
d547 1
a547 1
			      operandP->vop_reg = 0xF;	/* VAX PC. */
d550 1
a550 1
			    {	/* Encode short literal now. */
d580 1
a580 1
		    {		/* I^# seen: set it up if float. */
d585 1
a585 1
		    }		/* if S^# seen. */
d591 1
a591 1
		  /* Chosen so luser gets the most offset bits to patch later. */
d624 2
a625 3

  /* Emit op-code. */
  /* Remember where it is, in case we want to modify the op-code later. */
d649 1
a649 1
      /* Here to make main operand frag(s). */
d664 1
a664 1
	      /* If is_undefined, then it might BECOME now_seg. */
d728 1
a728 1
		      /* Conventional relocation. */
d744 1
a744 1
			      p[0] = VAX_ABSOLUTE_MODE;	/* @@#... */
d746 1
a746 1
			      /* Now (eg) JMP @@#foo or JSB @@#foo. */
d758 1
a758 1
				  p[5] = VAX_ABSOLUTE_MODE;	/* @@#... */
d775 1
a775 1
                                  p[4] = VAX_ABSOLUTE_MODE;     /* @@#... */
d791 1
a791 1
			     complement the lowest order bit. */
d795 1
a795 1
			  p[2] = VAX_ABSOLUTE_MODE;	/* @@#... */
d810 1
a810 1
		      /* Pc-relative. Conventional relocation. */
d833 1
a833 1
			      /* Now eg JMP foo or JSB foo. */
d882 1
a882 1
			  *opcode_low_byteP ^= 1;	/* Reverse branch condition. */
d897 2
a898 2
	  know (operandP->vop_access != 'b');	/* So it is ordinary operand. */
	  know (operandP->vop_access != ' ');	/* ' ' target-independent: elsewhere. */
d929 1
a929 1
	      /* One byte operand. */
d932 1
a932 1
	      /* All 1-bytes except S^# happen here. */
d954 1
a954 1
			     operand spec. byte. */
d972 1
a972 1
			  /* Do @@#foo: simpler relocation than foo-.(pc) anyway. */
d974 1
a974 1
			  p[0] = VAX_ABSOLUTE_MODE;	/* @@#... */
d1004 1
a1004 1
				  length = 4;	/* Longest possible. */
d1035 1
a1035 1
			  && operandP->vop_mode == 8	/* No '@@'. */
d1046 1
a1046 1
			  /* I^#... */
d1059 1
a1059 1
			       * cope properly with this bug. */
d1074 1
a1074 1
				   * bytes. */
d1170 1
a1170 1
	{			/* A relaxable case. */
d1176 1
a1176 1
	  p[0] |= VAX_PC_RELATIVE_MODE;	/* Preserve @@ bit. */
d1192 1
a1192 1
	  *fragP->fr_opcode ^= 1;	/* Reverse sense of branch. */
d1284 2
a1285 2
  char *addressP;		/* -> _var to change. */
  char *opcodeP;		/* -> opcode char(s) to change. */
d1287 2
a1288 2
  short int extension = 0;	/* Size of relaxed address. */
  /* Added to fr_fix: incl. ALL var chars. */
d1311 2
a1312 2
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit. */
      addressP[0] |= 0xAF;	/* Byte displacement. */
d1318 2
a1319 2
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit. */
      addressP[0] |= 0xCF;	/* Word displacement. */
d1325 2
a1326 2
      know (*addressP == 0 || *addressP == 0x10);	/* '@@' bit. */
      addressP[0] |= 0xEF;	/* Long word displacement. */
d1337 1
a1337 1
      opcodeP[0] ^= 1;		/* Reverse sense of test. */
d1345 1
a1345 1
      opcodeP[0] ^= 1;		/* Reverse sense of test. */
d1423 1
a1423 1
   bit 0 as pcrel. */
d1442 1
a1442 1
void 
d1556 4
a1559 4
  0, 0, 1, 0, 8, 0, 4, 8, 16, 0, 0, 0, 4, 0, 0,16,	/* ..b.d.fgh...l..o */
  0, 8, 0, 0, 0, 0, 0, 2,  0, 0, 0, 0, 0, 0, 0, 0,	/* .q.....w........ */
  0, 0, 1, 0, 8, 0, 4, 8, 16, 0, 0, 0, 4, 0, 0,16,	/* ..b.d.fgh...l..o */
  0, 8, 0, 0, 0, 0, 0, 2,  0, 0, 0, 0, 0, 0, 0, 0,	/* .q.....w........ */
d1676 2
a1677 2
/* CASEx has no branch addresses in our conception of it. */
/* You should use ".word ..." statements after the "case ...". */
d1696 1
a1696 1
     int synthetic_too;		/* 1 means include jXXX op-codes. */
a1717 1

d1744 2
a1745 2
     struct vit *vitP;		/* We build an exploded instruction here. */
     char *instring;		/* Text of a vax instruction: we modify. */
d1747 1
a1747 1
  /* How to bit-encode this opcode. */
d1758 1
a1758 1
  /* Remember char, (we clobber it with '\0' temporarily). */
d1760 1
a1760 1
  /* Op-code of this instruction. */
d1764 4
a1767 4
    ++instring;			/* Skip leading whitespace. */
  for (p = instring; *p && *p != ' '; p++);;	/* MUST end in end-of-string or exactly 1 space. */
  /* Scanned up to end of operation-code. */
  /* Operation-code is ended with whitespace. */
d1784 1
a1784 1
      *p = c;			/* Restore char after op-code. */
d1807 1
a1807 1
	  oc = vwP->vot_code;	/* The op-code. */
d1836 1
a1836 1
		  *q = c;	/* Restore input text. */
d1848 1
a1848 1
		instring++;	/* Skip whitespace. */
d1869 1
a1869 1
int mysynth;			/* 1 means want synthetic opcodes. */
d1948 1
a1948 1
/* Copyright (C) 1987 Free Software Foundation, Inc. A part of GNU. */
a2133 1

d2201 1
a2201 1
static void 
d2280 1
a2280 1
	vop_nbytes : number of bytes in a datum. */
d2303 1
a2303 1
  /* ANY err that begins with ' ' is a fake. */
d2319 2
a2320 2
  char access_mode;		/* vop_access. */
  char width;			/* vop_width. */
d2330 1
a2330 1
  if (*p == ' ')		/* Expect all whitespace reduced to ' '. */
d2336 1
a2336 1
      if (*p == ' ')		/* Expect all whitespace reduced to ' '. */
d2357 1
a2357 1
  if (*p == ' ')		/* Expect all whitespace reduced to ' '. */
d2375 1
a2375 1
  if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '. */
d2428 1
a2428 1
  if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '. */
d2525 1
a2525 1
	      if (*q == ' ' && q >= p)	/* Expect all whitespace reduced to ' '. */
d2589 1
a2589 1
  /* Since nobody seems to use it: comment this 'feature'(?) out for now. */
d2942 1
a2942 1
#ifdef TEST			/* #Define to use this testbed. */
d3148 1
a3148 1
    case '+':			/* For g++.  Hash any name > 31 chars long. */
@


1.4
log
@Fix spelling typos.
Remove use of DEFUN().
@
text
@d778 1
a778 1
				  p[4] = VAX_PC_RELATIVE_MODE + 1;	/* @@#... */
d1352 1
a1352 1
      md_number_to_chars (addressP + 3, target_address, 4);
d1386 1
a1386 1
      md_number_to_chars (addressP + 6, target_address, 4);
d1410 1
a1410 1
      md_number_to_chars (addressP + 5, target_address, 4);
@


1.3
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d392 1
a392 1
	  /* statement has no syntax goofs: lets sniff the expression */
d1798 1
a1798 1
	   * We found a match! So lets pick up as many operands as the
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d35 1
a35 1
const char line_separator_chars[] = "";
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 1998 Free Software Foundation, Inc.
d339 1
a339 1
  struct symbol *this_add_symbol;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

