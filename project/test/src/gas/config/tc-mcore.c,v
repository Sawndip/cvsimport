head	1.49;
access;
symbols
	binutils-2_24-branch:1.49.0.12
	binutils-2_24-branchpoint:1.49
	binutils-2_21_1:1.49
	binutils-2_23_2:1.49
	binutils-2_23_1:1.49
	binutils-2_23:1.49
	binutils-2_23-branch:1.49.0.10
	binutils-2_23-branchpoint:1.49
	binutils-2_22_branch:1.49.0.8
	binutils-2_22:1.49
	binutils-2_22-branch:1.49.0.6
	binutils-2_22-branchpoint:1.49
	binutils-2_21:1.49
	binutils-2_21-branch:1.49.0.4
	binutils-2_21-branchpoint:1.49
	binutils-2_20_1:1.49
	binutils-2_20:1.49
	binutils-arc-20081103-branch:1.46.0.6
	binutils-arc-20081103-branchpoint:1.46
	binutils-2_20-branch:1.49.0.2
	binutils-2_20-branchpoint:1.49
	dje-cgen-play1-branch:1.47.0.2
	dje-cgen-play1-branchpoint:1.47
	arc-20081103-branch:1.46.0.4
	arc-20081103-branchpoint:1.46
	binutils-2_19_1:1.46
	binutils-2_19:1.46
	binutils-2_19-branch:1.46.0.2
	binutils-2_19-branchpoint:1.46
	binutils-2_18:1.43
	binutils-2_18-branch:1.43.0.2
	binutils-2_18-branchpoint:1.43
	binutils-csl-coldfire-4_1-32:1.40
	binutils-csl-sourcerygxx-4_1-32:1.40
	binutils-csl-innovasic-fido-3_4_4-33:1.40
	binutils-csl-sourcerygxx-3_4_4-32:1.36
	binutils-csl-coldfire-4_1-30:1.40
	binutils-csl-sourcerygxx-4_1-30:1.40
	binutils-csl-coldfire-4_1-28:1.40
	binutils-csl-sourcerygxx-4_1-29:1.40
	binutils-csl-sourcerygxx-4_1-28:1.40
	binutils-csl-arm-2006q3-27:1.40
	binutils-csl-sourcerygxx-4_1-27:1.40
	binutils-csl-arm-2006q3-26:1.40
	binutils-csl-sourcerygxx-4_1-26:1.40
	binutils-csl-sourcerygxx-4_1-25:1.40
	binutils-csl-sourcerygxx-4_1-24:1.40
	binutils-csl-sourcerygxx-4_1-23:1.40
	binutils-csl-sourcerygxx-4_1-21:1.40
	binutils-csl-arm-2006q3-21:1.40
	binutils-csl-sourcerygxx-4_1-22:1.40
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.40
	binutils-csl-sourcerygxx-4_1-20:1.40
	binutils-csl-arm-2006q3-19:1.40
	binutils-csl-sourcerygxx-4_1-19:1.40
	binutils-csl-sourcerygxx-4_1-18:1.40
	binutils-csl-renesas-4_1-9:1.40
	binutils-csl-sourcerygxx-3_4_4-25:1.36
	binutils-csl-renesas-4_1-8:1.40
	binutils-csl-renesas-4_1-7:1.40
	binutils-csl-renesas-4_1-6:1.40
	binutils-csl-sourcerygxx-4_1-17:1.40
	binutils-csl-sourcerygxx-4_1-14:1.40
	binutils-csl-sourcerygxx-4_1-15:1.40
	binutils-csl-sourcerygxx-4_1-13:1.40
	binutils-2_17:1.40
	binutils-csl-sourcerygxx-4_1-12:1.40
	binutils-csl-sourcerygxx-3_4_4-21:1.40
	binutils-csl-wrs-linux-3_4_4-24:1.36
	binutils-csl-wrs-linux-3_4_4-23:1.36
	binutils-csl-sourcerygxx-4_1-9:1.40
	binutils-csl-sourcerygxx-4_1-8:1.40
	binutils-csl-sourcerygxx-4_1-7:1.40
	binutils-csl-arm-2006q1-6:1.40
	binutils-csl-sourcerygxx-4_1-6:1.40
	binutils-csl-wrs-linux-3_4_4-22:1.36
	binutils-csl-coldfire-4_1-11:1.40
	binutils-csl-sourcerygxx-3_4_4-19:1.40
	binutils-csl-coldfire-4_1-10:1.40
	binutils-csl-sourcerygxx-4_1-5:1.40
	binutils-csl-sourcerygxx-4_1-4:1.40
	binutils-csl-wrs-linux-3_4_4-21:1.36
	binutils-csl-morpho-4_1-4:1.40
	binutils-csl-sourcerygxx-3_4_4-17:1.40
	binutils-csl-wrs-linux-3_4_4-20:1.36
	binutils-2_17-branch:1.40.0.4
	binutils-2_17-branchpoint:1.40
	binutils-csl-2_17-branch:1.40.0.2
	binutils-csl-2_17-branchpoint:1.40
	binutils-csl-gxxpro-3_4-branch:1.36.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.36
	binutils-2_16_1:1.36
	binutils-csl-arm-2005q1b:1.36
	binutils-2_16:1.36
	binutils-csl-arm-2005q1a:1.36
	binutils-csl-arm-2005q1-branch:1.36.0.4
	binutils-csl-arm-2005q1-branchpoint:1.36
	binutils-2_16-branch:1.36.0.2
	binutils-2_16-branchpoint:1.36
	csl-arm-2004-q3d:1.34
	csl-arm-2004-q3:1.34
	binutils-2_15:1.34
	binutils-2_15-branchpoint:1.34
	csl-arm-2004-q1a:1.34
	csl-arm-2004-q1:1.34
	binutils-2_15-branch:1.34.0.6
	cagney_bfdfile-20040213-branch:1.34.0.4
	cagney_bfdfile-20040213-branchpoint:1.34
	cagney_bigcore-20040122-branch:1.34.0.2
	cagney_bigcore-20040122-branchpoint:1.34
	csl-arm-2003-q4:1.34
	binutils-2_14:1.33
	binutils-2_14-branch:1.33.0.2
	binutils-2_14-branchpoint:1.33
	binutils-2_13_2_1:1.26
	binutils-2_13_2:1.26
	binutils-2_13_1:1.26
	binutils-2_13:1.26
	binutils-2_13-branchpoint:1.26
	binutils-2_13-branch:1.26.0.2
	binutils-2_12_1:1.24
	binutils-2_12:1.24
	binutils-2_12-branch:1.24.0.2
	binutils-2_12-branchpoint:1.24
	cygnus_cvs_20020108_pre:1.24
	binutils-2_11_2:1.17.2.2
	binutils-2_11_1:1.17.2.2
	binutils-2_11:1.17
	x86_64versiong3:1.17
	binutils-2_11-branch:1.17.0.2
	binutils-2_10_1:1.14
	binutils-2_10:1.14
	binutils-2_10-branch:1.14.0.2
	binutils-2_10-branchpoint:1.14
	binutils_latest_snapshot:1.49
	repo-unification-2000-02-06:1.13
	binu_ss_19990721:1.6
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.22.17.05.40;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.11.08.58.56;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2005.08.11.01.25.27;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.05.09.12.59;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.24.20.40.27;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.17.13.46.04;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.16.09.57.49;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.12.22.11.31;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.21.11.43.40;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.21.09.54.12;	author kdienes;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.11.09.53.49;	author kazu;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.15.21.28.56;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.19.05.33.26;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.23.13.03.40;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.10.11.32.52;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.05.04.21.36;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.30.00.06.10;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.20.21.12.43;	author kazu;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.06.02.02.52.10;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.03.18.50.55;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.10.21.31.13;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.31.18.24.43;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	99.11.18.18.38.18;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	99.10.25.16.48.26;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	99.10.25.16.30.37;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	99.10.25.15.27.12;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	99.09.02.10.39.18;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.08.31.15.10.47;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.23.09.27.09;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.06.22.14.52.57;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.14.07.34;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.34;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.22.14.49.51;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.17.2.1
date	2001.06.07.03.15.31;	author amodra;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.06.11.10.04.49;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.49
log
@update copyright dates
@
text
@/* tc-mcore.c -- Assemble code for M*Core
   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "subsegs.h"
#define DEFINE_TABLE
#include "../opcodes/mcore-opc.h"
#include "safe-ctype.h"

#ifdef OBJ_ELF
#include "elf/mcore.h"
#endif

#ifndef streq
#define streq(a,b) (strcmp (a, b) == 0)
#endif

/* Forward declarations for dumb compilers.  */

/* Several places in this file insert raw instructions into the
   object. They should use MCORE_INST_XXX macros to get the opcodes
   and then use these two macros to crack the MCORE_INST value into
   the appropriate byte values.  */
#define	INST_BYTE0(x)  (target_big_endian ? (((x) >> 8) & 0xFF) : ((x) & 0xFF))
#define	INST_BYTE1(x)  (target_big_endian ? ((x) & 0xFF) : (((x) >> 8) & 0xFF))

const char comment_chars[] = "#/";
const char line_separator_chars[] = ";";
const char line_comment_chars[] = "#/";

static int do_jsri2bsr = 0;	/* Change here from 1 by Cruess 19 August 97.  */
static int sifilter_mode = 0;

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
    As in 0f12.456
    or    0d1.2345e12  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

#define C(what,length) (((what) << 2) + (length))
#define GET_WHAT(x)    ((x >> 2))

/* These are the two types of relaxable instruction.  */
#define COND_JUMP  1
#define UNCD_JUMP  2

#define UNDEF_DISP      0
#define DISP12          1
#define DISP32          2
#define UNDEF_WORD_DISP 3

#define C12_LEN	        2
#define C32_LEN	       10	/* Allow for align.  */
#define U12_LEN	        2
#define U32_LEN	        8	/* Allow for align.  */

typedef enum
{
  M210,
  M340
}
cpu_type;

cpu_type cpu = M340;

/* Initialize the relax table.  */
const relax_typeS md_relax_table[] =
{
  {    0,     0, 0,	  0 },
  {    0,     0, 0,	  0 },
  {    0,     0, 0,	  0 },
  {    0,     0, 0,	  0 },

  /* COND_JUMP */
  {    0,     0, 0,	  0 },			  /* UNDEF_DISP */
  { 2048, -2046, C12_LEN, C(COND_JUMP, DISP32) }, /* DISP12 */
  {    0,     0, C32_LEN, 0 },			  /* DISP32 */
  {    0,     0, C32_LEN, 0 },			  /* UNDEF_WORD_DISP */

  /* UNCD_JUMP */
  {    0,     0, 0,	  0 },			  /* UNDEF_DISP */
  { 2048, -2046, U12_LEN, C(UNCD_JUMP, DISP32) }, /* DISP12 */
  {    0,     0, U32_LEN, 0 },			  /* DISP32 */
  {    0,     0, U32_LEN, 0 }			  /* UNDEF_WORD_DISP */

};

/* Literal pool data structures.  */
struct literal
{
  unsigned short  refcnt;
  unsigned char	  ispcrel;
  unsigned char	  unused;
  expressionS	  e;
};

#define MAX_POOL_SIZE	(1024/4)
static struct literal litpool [MAX_POOL_SIZE];
static unsigned poolsize;
static unsigned poolnumber;
static unsigned long poolspan;

/* SPANPANIC: the point at which we get too scared and force a dump
   of the literal pool, and perhaps put a branch in place.
   Calculated as:
  		 1024	span of lrw/jmpi/jsri insn (actually span+1)
  		-2	possible alignment at the insn.
  		-2	possible alignment to get the table aligned.
  		-2	an inserted branch around the table.
  	     == 1018
   at 1018, we might be in trouble.
   -- so we have to be smaller than 1018 and since we deal with 2-byte
   instructions, the next good choice is 1016.
   -- Note we have a test case that fails when we've got 1018 here.  */
#define SPANPANIC	(1016)		/* 1024 - 1 entry - 2 byte rounding.  */
#define SPANCLOSE	(900)
#define SPANEXIT	(600)
static symbolS * poolsym;		/* Label for current pool.  */
static char poolname[8];
static struct hash_control * opcode_hash_control;	/* Opcode mnemonics.  */

#define POOL_END_LABEL   ".LE"
#define POOL_START_LABEL ".LS"

static void
make_name (char * s, char * p, int n)
{
  static const char hex[] = "0123456789ABCDEF";

  s[0] = p[0];
  s[1] = p[1];
  s[2] = p[2];
  s[3] = hex[(n >> 12) & 0xF];
  s[4] = hex[(n >>  8) & 0xF];
  s[5] = hex[(n >>  4) & 0xF];
  s[6] = hex[(n)       & 0xF];
  s[7] = 0;
}

static void
dump_literals (int isforce)
{
  unsigned int i;
  struct literal * p;
  symbolS * brarsym = NULL;

  if (poolsize == 0)
    return;

  /* Must we branch around the literal table?  */
  if (isforce)
    {
      char * output;
      char brarname[8];

      make_name (brarname, POOL_END_LABEL, poolnumber);

      brarsym = symbol_make (brarname);

      symbol_table_insert (brarsym);

      output = frag_var (rs_machine_dependent,
			 md_relax_table[C (UNCD_JUMP, DISP32)].rlx_length,
			 md_relax_table[C (UNCD_JUMP, DISP12)].rlx_length,
			 C (UNCD_JUMP, 0), brarsym, 0, 0);
      output[0] = INST_BYTE0 (MCORE_INST_BR);	/* br .+xxx */
      output[1] = INST_BYTE1 (MCORE_INST_BR);
    }

  /* Make sure that the section is sufficiently aligned and that
     the literal table is aligned within it.  */
  record_alignment (now_seg, 2);
  frag_align (2, 0, 0);

  colon (S_GET_NAME (poolsym));

  for (i = 0, p = litpool; i < poolsize; i++, p++)
    emit_expr (& p->e, 4);

  if (brarsym != NULL)
    colon (S_GET_NAME (brarsym));

   poolsize = 0;
}

static void
mcore_s_literals (int ignore ATTRIBUTE_UNUSED)
{
  dump_literals (0);
  demand_empty_rest_of_line ();
}

/* Perform FUNC (ARG), and track number of bytes added to frag.  */

static void
mcore_pool_count (void (*func) (int), int arg)
{
  const fragS *curr_frag = frag_now;
  offsetT added = -frag_now_fix_octets ();

  (*func) (arg);

  while (curr_frag != frag_now)
    {
      added += curr_frag->fr_fix;
      curr_frag = curr_frag->fr_next;
    }

  added += frag_now_fix_octets ();
  poolspan += added;
}

static void
check_literals (int kind, int offset)
{
  poolspan += offset;

  /* SPANCLOSE and SPANEXIT are smaller numbers than SPANPANIC.
     SPANPANIC means that we must dump now.
     kind == 0 is any old instruction.
     kind  > 0 means we just had a control transfer instruction.
     kind == 1 means within a function
     kind == 2 means we just left a function

     The dump_literals (1) call inserts a branch around the table, so
     we first look to see if its a situation where we won't have to
     insert a branch (e.g., the previous instruction was an unconditional
     branch).

     SPANPANIC is the point where we must dump a single-entry pool.
     it accounts for alignments and an inserted branch.
     the 'poolsize*2' accounts for the scenario where we do:
       lrw r1,lit1; lrw r2,lit2; lrw r3,lit3
     Note that the 'lit2' reference is 2 bytes further along
     but the literal it references will be 4 bytes further along,
     so we must consider the poolsize into this equation.
     This is slightly over-cautious, but guarantees that we won't
     panic because a relocation is too distant.  */

  if (poolspan > SPANCLOSE && kind > 0)
    dump_literals (0);
  else if (poolspan > SPANEXIT && kind > 1)
    dump_literals (0);
  else if (poolspan >= (SPANPANIC - poolsize * 2))
    dump_literals (1);
}

static void
mcore_cons (int nbytes)
{
  if (now_seg == text_section)
    mcore_pool_count (cons, nbytes);
  else
    cons (nbytes);

  /* In theory we ought to call check_literals (2,0) here in case
     we need to dump the literal table.  We cannot do this however,
     as the directives that we are intercepting may be being used
     to build a switch table, and we must not interfere with its
     contents.  Instead we cross our fingers and pray...  */
}

static void
mcore_float_cons (int float_type)
{
  if (now_seg == text_section)
    mcore_pool_count (float_cons, float_type);
  else
    float_cons (float_type);

  /* See the comment in mcore_cons () about calling check_literals.
     It is unlikely that a switch table will be constructed using
     floating point values, but it is still likely that an indexed
     table of floating point constants is being created by these
     directives, so again we must not interfere with their placement.  */
}

static void
mcore_stringer (int append_zero)
{
  if (now_seg == text_section)
    mcore_pool_count (stringer, append_zero);
  else
    stringer (append_zero);

  /* We call check_literals here in case a large number of strings are
     being placed into the text section with a sequence of stringer
     directives.  In theory we could be upsetting something if these
     strings are actually in an indexed table instead of referenced by
     individual labels.  Let us hope that that never happens.  */
  check_literals (2, 0);
}

static void
mcore_fill (int unused)
{
  if (now_seg == text_section)
    mcore_pool_count (s_fill, unused);
  else
    s_fill (unused);

  check_literals (2, 0);
}

/* Handle the section changing pseudo-ops.  These call through to the
   normal implementations, but they dump the literal pool first.  */

static void
mcore_s_text (int ignore)
{
  dump_literals (0);

#ifdef OBJ_ELF
  obj_elf_text (ignore);
#else
  s_text (ignore);
#endif
}

static void
mcore_s_data (int ignore)
{
  dump_literals (0);

#ifdef OBJ_ELF
  obj_elf_data (ignore);
#else
  s_data (ignore);
#endif
}

static void
mcore_s_section (int ignore)
{
  /* Scan forwards to find the name of the section.  If the section
     being switched to is ".line" then this is a DWARF1 debug section
     which is arbitrarily placed inside generated code.  In this case
     do not dump the literal pool because it is a) inefficient and
     b) would require the generation of extra code to jump around the
     pool.  */
  char * ilp = input_line_pointer;

  while (*ilp != 0 && ISSPACE (*ilp))
    ++ ilp;

  if (strncmp (ilp, ".line", 5) == 0
      && (ISSPACE (ilp[5]) || *ilp == '\n' || *ilp == '\r'))
    ;
  else
    dump_literals (0);

#ifdef OBJ_ELF
  obj_elf_section (ignore);
#endif
#ifdef OBJ_COFF
  obj_coff_section (ignore);
#endif
}

static void
mcore_s_bss (int needs_align)
{
  dump_literals (0);

  s_lcomm_bytes (needs_align);
}

#ifdef OBJ_ELF
static void
mcore_s_comm (int needs_align)
{
  dump_literals (0);

  obj_elf_common (needs_align);
}
#endif

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     Pseudo-op name without dot
     Function to call to execute this pseudo-op
     Integer arg to pass to the function.   */
const pseudo_typeS md_pseudo_table[] =
{
  { "export",   s_globl,          0 },
  { "import",   s_ignore,         0 },
  { "literals", mcore_s_literals, 0 },
  { "page",     listing_eject,    0 },

  /* The following are to intercept the placement of data into the text
     section (eg addresses for a switch table), so that the space they
     occupy can be taken into account when deciding whether or not to
     dump the current literal pool.
     XXX - currently we do not cope with the .space and .dcb.d directives.  */
  { "ascii",    mcore_stringer,       8 + 0 },
  { "asciz",    mcore_stringer,       8 + 1 },
  { "byte",     mcore_cons,           1 },
  { "dc",       mcore_cons,           2 },
  { "dc.b",     mcore_cons,           1 },
  { "dc.d",     mcore_float_cons,    'd'},
  { "dc.l",     mcore_cons,           4 },
  { "dc.s",     mcore_float_cons,    'f'},
  { "dc.w",     mcore_cons,           2 },
  { "dc.x",     mcore_float_cons,    'x'},
  { "double",   mcore_float_cons,    'd'},
  { "float",    mcore_float_cons,    'f'},
  { "hword",    mcore_cons,           2 },
  { "int",      mcore_cons,           4 },
  { "long",     mcore_cons,           4 },
  { "octa",     mcore_cons,          16 },
  { "quad",     mcore_cons,           8 },
  { "short",    mcore_cons,           2 },
  { "single",   mcore_float_cons,    'f'},
  { "string",   mcore_stringer,       8 + 1 },
  { "word",     mcore_cons,           2 },
  { "fill",     mcore_fill,           0 },

  /* Allow for the effect of section changes.  */
  { "text",      mcore_s_text,    0 },
  { "data",      mcore_s_data,    0 },
  { "bss",       mcore_s_bss,     1 },
#ifdef OBJ_ELF
  { "comm",      mcore_s_comm,    0 },
#endif
  { "section",   mcore_s_section, 0 },
  { "section.s", mcore_s_section, 0 },
  { "sect",      mcore_s_section, 0 },
  { "sect.s",    mcore_s_section, 0 },

  { 0,          0,                0 }
};

/* This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs.  */

void
md_begin (void)
{
  const mcore_opcode_info * opcode;
  char * prev_name = "";

  opcode_hash_control = hash_new ();

  /* Insert unique names into hash table.  */
  for (opcode = mcore_table; opcode->name; opcode ++)
    {
      if (! streq (prev_name, opcode->name))
	{
	  prev_name = opcode->name;
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	}
    }
}

/* Get a log2(val).  */

static int
mylog2 (unsigned int val)
{
  int log = -1;

  while (val != 0)
      {
	log ++;
	val >>= 1;
      }

  return log;
}

/* Try to parse a reg name.  */

static char *
parse_reg (char * s, unsigned * reg)
{
  /* Strip leading whitespace.  */
  while (ISSPACE (* s))
    ++ s;

  if (TOLOWER (s[0]) == 'r')
    {
      if (s[1] == '1' && s[2] >= '0' && s[2] <= '5')
	{
	  *reg = 10 + s[2] - '0';
	  return s + 3;
	}

      if (s[1] >= '0' && s[1] <= '9')
	{
	  *reg = s[1] - '0';
	  return s + 2;
	}
    }
  else if (   TOLOWER (s[0]) == 's'
	   && TOLOWER (s[1]) == 'p'
	   && ! ISALNUM (s[2]))
    {
      * reg = 0;
      return s + 2;
    }

  as_bad (_("register expected, but saw '%.6s'"), s);
  return s;
}

static struct Cregs
{
  char * name;
  unsigned int crnum;
}
cregs[] =
{
  { "psr",	 0},
  { "vbr",	 1},
  { "epsr",	 2},
  { "fpsr",	 3},
  { "epc",	 4},
  { "fpc",	 5},
  { "ss0",	 6},
  { "ss1",	 7},
  { "ss2",	 8},
  { "ss3",	 9},
  { "ss4",	10},
  { "gcr",	11},
  { "gsr",	12},
  { "",		 0}
};

static char *
parse_creg (char * s, unsigned * reg)
{
  int i;

  /* Strip leading whitespace.  */
  while (ISSPACE (* s))
    ++s;

  if ((TOLOWER (s[0]) == 'c' && TOLOWER (s[1]) == 'r'))
    {
      if (s[2] == '3' && s[3] >= '0' && s[3] <= '1')
	{
	  *reg = 30 + s[3] - '0';
	  return s + 4;
	}

      if (s[2] == '2' && s[3] >= '0' && s[3] <= '9')
	{
	  *reg = 20 + s[3] - '0';
	  return s + 4;
	}

      if (s[2] == '1' && s[3] >= '0' && s[3] <= '9')
	{
	  *reg = 10 + s[3] - '0';
	  return s + 4;
	}

      if (s[2] >= '0' && s[2] <= '9')
	{
	  *reg = s[2] - '0';
	  return s + 3;
	}
    }

  /* Look at alternate creg names before giving error.  */
  for (i = 0; cregs[i].name[0] != '\0'; i++)
    {
      char buf [10];
      int  length;
      int  j;

      length = strlen (cregs[i].name);

      for (j = 0; j < length; j++)
	buf[j] = TOLOWER (s[j]);

      if (strncmp (cregs[i].name, buf, length) == 0)
	{
	  *reg = cregs[i].crnum;
	  return s + length;
	}
    }

  as_bad (_("control register expected, but saw '%.6s'"), s);

  return s;
}

static char *
parse_psrmod (char * s, unsigned * reg)
{
  int  i;
  char buf[10];
  static struct psrmods
  {
    char *       name;
    unsigned int value;
  }
  psrmods[] =
  {
    { "ie", 1 },
    { "fe", 2 },
    { "ee", 4 },
    { "af", 8 }	/* Really 0 and non-combinable.  */
  };

  for (i = 0; i < 2; i++)
    buf[i] = TOLOWER (s[i]);

  for (i = sizeof (psrmods) / sizeof (psrmods[0]); i--;)
    {
      if (! strncmp (psrmods[i].name, buf, 2))
	{
	  * reg = psrmods[i].value;

	  return s + 2;
	}
    }

  as_bad (_("bad/missing psr specifier"));

  * reg = 0;

  return s;
}

static char *
parse_exp (char * s, expressionS * e)
{
  char * save;
  char * new_pointer;

  /* Skip whitespace.  */
  while (ISSPACE (* s))
    ++ s;

  save = input_line_pointer;
  input_line_pointer = s;

  expression (e);

  if (e->X_op == O_absent)
    as_bad (_("missing operand"));

  new_pointer = input_line_pointer;
  input_line_pointer = save;

  return new_pointer;
}

static int
enter_literal (expressionS * e, int ispcrel)
{
  unsigned int i;
  struct literal * p;

  if (poolsize >= MAX_POOL_SIZE - 2)
    /* The literal pool is as full as we can handle. We have
       to be 2 entries shy of the 1024/4=256 entries because we
       have to allow for the branch (2 bytes) and the alignment
       (2 bytes before the first insn referencing the pool and
       2 bytes before the pool itself) == 6 bytes, rounds up
       to 2 entries.  */
    dump_literals (1);

  if (poolsize == 0)
    {
      /* Create new literal pool.  */
      if (++ poolnumber > 0xFFFF)
	as_fatal (_("more than 65K literal pools"));

      make_name (poolname, POOL_START_LABEL, poolnumber);
      poolsym = symbol_make (poolname);
      symbol_table_insert (poolsym);
      poolspan = 0;
    }

  /* Search pool for value so we don't have duplicates.  */
  for (p = litpool, i = 0; i < poolsize; i++, p++)
    {
      if (e->X_op == p->e.X_op
	  && e->X_add_symbol == p->e.X_add_symbol
	  && e->X_add_number == p->e.X_add_number
	  && ispcrel == p->ispcrel)
	{
	  p->refcnt ++;
	  return i;
	}
    }

  p->refcnt  = 1;
  p->ispcrel = ispcrel;
  p->e       = * e;

  poolsize ++;

  return i;
}

/* Parse a literal specification. -- either new or old syntax.
   old syntax: the user supplies the label and places the literal.
   new syntax: we put it into the literal pool.  */

static char *
parse_rt (char * s,
	  char ** outputp,
	  int ispcrel,
	  expressionS * ep)
{
  expressionS e;
  int n;

  if (ep)
    /* Indicate nothing there.  */
    ep->X_op = O_absent;

  if (*s == '[')
    {
      s = parse_exp (s + 1, & e);

      if (*s == ']')
	s++;
      else
	as_bad (_("missing ']'"));
    }
  else
    {
      s = parse_exp (s, & e);

      n = enter_literal (& e, ispcrel);

      if (ep)
	*ep = e;

      /* Create a reference to pool entry.  */
      e.X_op         = O_symbol;
      e.X_add_symbol = poolsym;
      e.X_add_number = n << 2;
    }

  * outputp = frag_more (2);

  fix_new_exp (frag_now, (*outputp) - frag_now->fr_literal, 2, & e, 1,
	       BFD_RELOC_MCORE_PCREL_IMM8BY4);

  return s;
}

static char *
parse_imm (char * s,
	   unsigned * val,
	   unsigned min,
	   unsigned max)
{
  char * new_pointer;
  expressionS e;

  new_pointer = parse_exp (s, & e);

  if (e.X_op == O_absent)
    ; /* An error message has already been emitted.  */
  else if (e.X_op != O_constant)
    as_bad (_("operand must be a constant"));
  else if ((addressT) e.X_add_number < min || (addressT) e.X_add_number > max)
    as_bad (_("operand must be absolute in range %u..%u, not %ld"),
	    min, max, (long) e.X_add_number);

  * val = e.X_add_number;

  return new_pointer;
}

static char *
parse_mem (char * s,
	   unsigned * reg,
	   unsigned * off,
	   unsigned siz)
{
  * off = 0;

  while (ISSPACE (* s))
    ++ s;

  if (* s == '(')
    {
      s = parse_reg (s + 1, reg);

      while (ISSPACE (* s))
	++ s;

      if (* s == ',')
	{
	  s = parse_imm (s + 1, off, 0, 63);

	  if (siz > 1)
	    {
	      if (siz > 2)
		{
		  if (* off & 0x3)
		    as_bad (_("operand must be a multiple of 4"));

		  * off >>= 2;
		}
	      else
		{
		  if (* off & 0x1)
		    as_bad (_("operand must be a multiple of 2"));

		  * off >>= 1;
		}
	    }
	}

      while (ISSPACE (* s))
	++ s;

      if (* s == ')')
	s ++;
    }
  else
    as_bad (_("base register expected"));

  return s;
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char * str)
{
  char * op_start;
  char * op_end;
  mcore_opcode_info * opcode;
  char * output;
  int nlen = 0;
  unsigned short inst;
  unsigned reg;
  unsigned off;
  unsigned isize;
  expressionS e;
  char name[21];

  /* Drop leading whitespace.  */
  while (ISSPACE (* str))
    str ++;

  /* Find the op code end.  */
  for (op_start = op_end = str;
       nlen < 20 && !is_end_of_line [(unsigned char) *op_end] && *op_end != ' ';
       op_end++)
    {
      name[nlen] = op_start[nlen];
      nlen++;
    }

  name [nlen] = 0;

  if (nlen == 0)
    {
      as_bad (_("can't find opcode "));
      return;
    }

  opcode = (mcore_opcode_info *) hash_find (opcode_hash_control, name);
  if (opcode == NULL)
    {
      as_bad (_("unknown opcode \"%s\""), name);
      return;
    }

  inst = opcode->inst;
  isize = 2;

  switch (opcode->opclass)
    {
    case O0:
      output = frag_more (2);
      break;

    case OT:
      op_end = parse_imm (op_end + 1, & reg, 0, 3);
      inst |= reg;
      output = frag_more (2);
      break;

    case O1:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;
      output = frag_more (2);
      break;

    case JMP:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;
      output = frag_more (2);
      /* In a sifilter mode, we emit this insn 2 times,
	 fixes problem of an interrupt during a jmp..  */
      if (sifilter_mode)
	{
	  output[0] = INST_BYTE0 (inst);
	  output[1] = INST_BYTE1 (inst);
	  output = frag_more (2);
	}
      break;

    case JSR:
      op_end = parse_reg (op_end + 1, & reg);

      if (reg == 15)
	as_bad (_("invalid register: r15 illegal"));

      inst |= reg;
      output = frag_more (2);

      if (sifilter_mode)
	{
	  /* Replace with:  bsr .+2 ; addi r15,6; jmp rx ; jmp rx.  */
	  inst = MCORE_INST_BSR;	/* With 0 displacement.  */
	  output[0] = INST_BYTE0 (inst);
	  output[1] = INST_BYTE1 (inst);

	  output = frag_more (2);
	  inst = MCORE_INST_ADDI;
	  inst |= 15;			/* addi r15,6  */
	  inst |= (6 - 1) << 4;		/* Over the jmp's.  */
	  output[0] = INST_BYTE0 (inst);
	  output[1] = INST_BYTE1 (inst);

	  output = frag_more (2);
	  inst = MCORE_INST_JMP | reg;
	  output[0] = INST_BYTE0 (inst);
	  output[1] = INST_BYTE1 (inst);

	  /* 2nd emitted in fallthrough.  */
	  output = frag_more (2);
	}
      break;

    case OC:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (*op_end == ',')
	{
	  op_end = parse_creg (op_end + 1, & reg);
	  inst |= reg << 4;
	}

      output = frag_more (2);
      break;

    case MULSH:
      if (cpu == M210)
	{
	  as_bad (_("M340 specific opcode used when assembling for M210"));
	  break;
	}
      /* drop through...  */
    case O2:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_reg (op_end + 1, & reg);
	  inst |= reg << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case X1:
      /* Handle both syntax-> xtrb- r1,rx OR xtrb- rx.  */
      op_end = parse_reg (op_end + 1, & reg);

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')	/* xtrb- r1,rx.  */
	{
	  if (reg != 1)
	    as_bad (_("destination register must be r1"));

	  op_end = parse_reg (op_end + 1, & reg);
	}

      inst |= reg;
      output = frag_more (2);
      break;

    case O1R1:  /* div- rx,r1.  */
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_reg (op_end + 1, & reg);
	  if (reg != 1)
	    as_bad (_("source register must be r1"));
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case OI:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 1, 32);
	  inst |= (reg - 1) << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case OB:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 0, 31);
	  inst |= reg << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case OB2:
      /* Like OB, but arg is 2^n instead of n.  */
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 1, 1 << 31);
	  /* Further restrict the immediate to a power of two.  */
	  if ((reg & (reg - 1)) == 0)
	    reg = mylog2 (reg);
	  else
	    {
	      reg = 0;
	      as_bad (_("immediate is not a power of two"));
	    }
	  inst |= (reg) << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case OBRa:	/* Specific for bgeni: imm of 0->6 translate to movi.  */
    case OBRb:
    case OBRc:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 0, 31);
	  /* Immediate values of 0 -> 6 translate to movi.  */
	  if (reg <= 6)
	    {
	      inst = (inst & 0xF) | MCORE_INST_BGENI_ALT;
	      reg = 0x1 << reg;
	      as_warn (_("translating bgeni to movi"));
	    }
	  inst &= ~ 0x01f0;
	  inst |= reg << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case OBR2:	/* Like OBR, but arg is 2^n instead of n.  */
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 1, 1 << 31);

	  /* Further restrict the immediate to a power of two.  */
	  if ((reg & (reg - 1)) == 0)
	    reg = mylog2 (reg);
	  else
	    {
	      reg = 0;
	      as_bad (_("immediate is not a power of two"));
	    }

	  /* Immediate values of 0 -> 6 translate to movi.  */
	  if (reg <= 6)
	    {
	      inst = (inst & 0xF) | MCORE_INST_BGENI_ALT;
	      reg = 0x1 << reg;
	      as_warn (_("translating mgeni to movi"));
	    }

	  inst |= reg << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case OMa:	/* Specific for bmaski: imm 1->7 translate to movi.  */
    case OMb:
    case OMc:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 1, 32);

	  /* Immediate values of 1 -> 7 translate to movi.  */
	  if (reg <= 7)
	    {
	      inst = (inst & 0xF) | MCORE_INST_BMASKI_ALT;
	      reg = (0x1 << reg) - 1;
	      inst |= reg << 4;

	      as_warn (_("translating bmaski to movi"));
	    }
	  else
	    {
	      inst &= ~ 0x01F0;
	      inst |= (reg & 0x1F) << 4;
	    }
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case SI:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 1, 31);
	  inst |= reg << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case I7:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 0, 0x7F);
	  inst |= reg << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case LS:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg << 8;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  int size;

	  if ((inst & 0x6000) == 0)
	    size = 4;
	  else if ((inst & 0x6000) == 0x4000)
	    size = 2;
	  else if ((inst & 0x6000) == 0x2000)
	    size = 1;
	  else
	    abort ();

	  op_end = parse_mem (op_end + 1, & reg, & off, size);

	  if (off > 16)
	    as_bad (_("displacement too large (%d)"), off);
	  else
	    inst |= (reg) | (off << 4);
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case LR:
      op_end = parse_reg (op_end + 1, & reg);

      if (reg == 0 || reg == 15)
	as_bad (_("Invalid register: r0 and r15 illegal"));

      inst |= (reg << 8);

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  /* parse_rt calls frag_more() for us.  */
	  input_line_pointer = parse_rt (op_end + 1, & output, 0, 0);
	  op_end = input_line_pointer;
	}
      else
	{
	  as_bad (_("second operand missing"));
	  output = frag_more (2);		/* save its space */
	}
      break;

    case LJ:
      input_line_pointer = parse_rt (op_end + 1, & output, 1, 0);
      /* parse_rt() calls frag_more() for us.  */
      op_end = input_line_pointer;
      break;

    case RM:
      op_end = parse_reg (op_end + 1, & reg);

      if (reg == 0 || reg == 15)
	as_bad (_("bad starting register: r0 and r15 invalid"));

      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == '-')
	{
	  op_end = parse_reg (op_end + 1, & reg);

	  if (reg != 15)
	    as_bad (_("ending register must be r15"));

	  /* Skip whitespace.  */
	  while (ISSPACE (* op_end))
	    ++ op_end;
	}

      if (* op_end == ',')
	{
	  op_end ++;

	  /* Skip whitespace.  */
	  while (ISSPACE (* op_end))
	    ++ op_end;

	  if (* op_end == '(')
	    {
	      op_end = parse_reg (op_end + 1, & reg);

	      if (reg != 0)
		as_bad (_("bad base register: must be r0"));

	      if (* op_end == ')')
		op_end ++;
	    }
	  else
	    as_bad (_("base register expected"));
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case RQ:
      op_end = parse_reg (op_end + 1, & reg);

      if (reg != 4)
	as_fatal (_("first register must be r4"));

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == '-')
	{
	  op_end = parse_reg (op_end + 1, & reg);

	  if (reg != 7)
	    as_fatal (_("last register must be r7"));

	  /* Skip whitespace.  */
	  while (ISSPACE (* op_end))
	    ++ op_end;

	  if (* op_end == ',')
	    {
	      op_end ++;

	      /* Skip whitespace.  */
	      while (ISSPACE (* op_end))
		++ op_end;

	      if (* op_end == '(')
		{
		  op_end = parse_reg (op_end + 1, & reg);

		  if (reg >= 4 && reg <= 7)
		    as_fatal ("base register cannot be r4, r5, r6, or r7");

		  inst |= reg;

		  /* Skip whitespace.  */
		  while (ISSPACE (* op_end))
		    ++ op_end;

		  if (* op_end == ')')
		    op_end ++;
		}
	      else
		as_bad (_("base register expected"));
	    }
	  else
	    as_bad (_("second operand missing"));
	}
      else
	as_bad (_("reg-reg expected"));

      output = frag_more (2);
      break;

    case BR:
      input_line_pointer = parse_exp (op_end + 1, & e);
      op_end = input_line_pointer;

      output = frag_more (2);

      fix_new_exp (frag_now, output-frag_now->fr_literal,
		   2, & e, 1, BFD_RELOC_MCORE_PCREL_IMM11BY2);
      break;

    case BL:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg << 4;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_exp (op_end + 1, & e);
	  output = frag_more (2);

	  fix_new_exp (frag_now, output-frag_now->fr_literal,
		       2, & e, 1, BFD_RELOC_MCORE_PCREL_IMM4BY2);
	}
      else
	{
	  as_bad (_("second operand missing"));
	  output = frag_more (2);
	}
      break;

    case JC:
      input_line_pointer = parse_exp (op_end + 1, & e);
      op_end = input_line_pointer;

      output = frag_var (rs_machine_dependent,
			 md_relax_table[C (COND_JUMP, DISP32)].rlx_length,
			 md_relax_table[C (COND_JUMP, DISP12)].rlx_length,
			 C (COND_JUMP, 0), e.X_add_symbol, e.X_add_number, 0);
      isize = C32_LEN;
      break;

    case JU:
      input_line_pointer = parse_exp (op_end + 1, & e);
      op_end = input_line_pointer;

      output = frag_var (rs_machine_dependent,
			 md_relax_table[C (UNCD_JUMP, DISP32)].rlx_length,
			 md_relax_table[C (UNCD_JUMP, DISP12)].rlx_length,
			 C (UNCD_JUMP, 0), e.X_add_symbol, e.X_add_number, 0);
      isize = U32_LEN;
      break;

    case JL:
      inst = MCORE_INST_JSRI;		/* jsri */
      input_line_pointer = parse_rt (op_end + 1, & output, 1, & e);
      /* parse_rt() calls frag_more for us.  */
      op_end = input_line_pointer;

      /* Only do this if we know how to do it ...  */
      if (e.X_op != O_absent && do_jsri2bsr)
	{
	  /* Look at adding the R_PCREL_JSRIMM11BY2.  */
	  fix_new_exp (frag_now, output-frag_now->fr_literal,
		       2, & e, 1, BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2);
	}
      break;

    case RSI:
      /* SI, but imm becomes 32-imm.  */
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 1, 31);

	  reg = 32 - reg;
	  inst |= reg << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case DO21:			/* O2, dup rd, lit must be 1 */
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;
      inst |= reg << 4;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 1, 31);

	  if (reg != 1)
	    as_bad (_("second operand must be 1"));
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case SIa:
      op_end = parse_reg (op_end + 1, & reg);
      inst |= reg;

      /* Skip whitespace.  */
      while (ISSPACE (* op_end))
	++ op_end;

      if (* op_end == ',')
	{
	  op_end = parse_imm (op_end + 1, & reg, 1, 31);

	  if (reg == 0)
	    as_bad (_("zero used as immediate value"));

	  inst |= reg << 4;
	}
      else
	as_bad (_("second operand missing"));

      output = frag_more (2);
      break;

    case OPSR:
      if (cpu == M210)
	{
	  as_bad (_("M340 specific opcode used when assembling for M210"));
	  break;
	}

      op_end = parse_psrmod (op_end + 1, & reg);

      /* Look for further selectors.  */
      while (* op_end == ',')
	{
	  unsigned value;

	  op_end = parse_psrmod (op_end + 1, & value);

	  if (value & reg)
	    as_bad (_("duplicated psr bit specifier"));

	  reg |= value;
	}

      if (reg > 8)
	as_bad (_("`af' must appear alone"));

      inst |= (reg & 0x7);
      output = frag_more (2);
      break;

    default:
      as_bad (_("unimplemented opcode \"%s\""), name);
    }

  /* Drop whitespace after all the operands have been parsed.  */
  while (ISSPACE (* op_end))
    op_end ++;

  /* Give warning message if the insn has more operands than required.  */
  if (strcmp (op_end, opcode->name) && strcmp (op_end, ""))
    as_warn (_("ignoring operands: %s "), op_end);

  output[0] = INST_BYTE0 (inst);
  output[1] = INST_BYTE1 (inst);

  check_literals (opcode->transfer, isize);
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_mcore_end (void)
{
  dump_literals (0);
  subseg_set (text_section, 0);
}

/* Various routines to kill one day.  */

char *
md_atof (int type, char * litP, int * sizeP)
{
  return ieee_md_atof (type, litP, sizeP, target_big_endian);
}

const char * md_shortopts = "";

enum options
{
  OPTION_JSRI2BSR_ON = OPTION_MD_BASE,
  OPTION_JSRI2BSR_OFF,
  OPTION_SIFILTER_ON,
  OPTION_SIFILTER_OFF,
  OPTION_CPU,
  OPTION_EB,
  OPTION_EL,
};

struct option md_longopts[] =
{
  { "no-jsri2bsr", no_argument, NULL, OPTION_JSRI2BSR_OFF},
  { "jsri2bsr",    no_argument, NULL, OPTION_JSRI2BSR_ON},
  { "sifilter",    no_argument, NULL, OPTION_SIFILTER_ON},
  { "no-sifilter", no_argument, NULL, OPTION_SIFILTER_OFF},
  { "cpu",         required_argument, NULL, OPTION_CPU},
  { "EB",          no_argument, NULL, OPTION_EB},
  { "EL",          no_argument, NULL, OPTION_EL},
  { NULL,          no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char * arg)
{
  switch (c)
    {
    case OPTION_CPU:
      if (streq (arg, "210"))
	{
	  cpu = M210;
	  target_big_endian = 1;
	}
      else if (streq (arg, "340"))
	cpu = M340;
      else
	as_warn (_("unrecognised cpu type '%s'"), arg);
      break;

    case OPTION_EB: target_big_endian = 1; break;
    case OPTION_EL: target_big_endian = 0; cpu = M340; break;
    case OPTION_JSRI2BSR_ON:  do_jsri2bsr = 1;   break;
    case OPTION_JSRI2BSR_OFF: do_jsri2bsr = 0;   break;
    case OPTION_SIFILTER_ON:  sifilter_mode = 1; break;
    case OPTION_SIFILTER_OFF: sifilter_mode = 0; break;
    default:                  return 0;
    }

  return 1;
}

void
md_show_usage (FILE * stream)
{
  fprintf (stream, _("\
MCORE specific options:\n\
  -{no-}jsri2bsr	  {dis}able jsri to bsr transformation (def: dis)\n\
  -{no-}sifilter	  {dis}able silicon filter behavior (def: dis)\n\
  -cpu=[210|340]          select CPU type\n\
  -EB                     assemble for a big endian system (default)\n\
  -EL                     assemble for a little endian system\n"));
}

int md_short_jump_size;

void
md_create_short_jump (char * ptr ATTRIBUTE_UNUSED,
		      addressT from_Nddr ATTRIBUTE_UNUSED,
		      addressT to_Nddr ATTRIBUTE_UNUSED,
		      fragS * frag ATTRIBUTE_UNUSED,
		      symbolS * to_symbol ATTRIBUTE_UNUSED)
{
  as_fatal (_("failed sanity check: short_jump"));
}

void
md_create_long_jump (char * ptr ATTRIBUTE_UNUSED,
		     addressT from_Nddr ATTRIBUTE_UNUSED,
		     addressT to_Nddr ATTRIBUTE_UNUSED,
		     fragS * frag ATTRIBUTE_UNUSED,
		     symbolS * to_symbol ATTRIBUTE_UNUSED)
{
  as_fatal (_("failed sanity check: long_jump"));
}

/* Called after relaxing, change the frags so they know how big they are.  */

void
md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 fragS * fragP)
{
  char *buffer;
  int targ_addr = S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset;

  buffer = fragP->fr_fix + fragP->fr_literal;

  switch (fragP->fr_subtype)
    {
    case C (COND_JUMP, DISP12):
    case C (UNCD_JUMP, DISP12):
      {
	/* Get the address of the end of the instruction.  */
	int next_inst = fragP->fr_fix + fragP->fr_address + 2;
	unsigned char t0;
	int disp = targ_addr - next_inst;

	if (disp & 1)
	  as_bad (_("odd displacement at %x"), next_inst - 2);

	disp >>= 1;

	if (! target_big_endian)
	  {
	    t0 = buffer[1] & 0xF8;

	    md_number_to_chars (buffer, disp, 2);

	    buffer[1] = (buffer[1] & 0x07) | t0;
	  }
	else
	  {
	    t0 = buffer[0] & 0xF8;

	    md_number_to_chars (buffer, disp, 2);

	    buffer[0] = (buffer[0] & 0x07) | t0;
	  }

	fragP->fr_fix += 2;
      }
      break;

    case C (COND_JUMP, DISP32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
      {
	/* A conditional branch wont fit into 12 bits so:
	  	b!cond	1f
	  	jmpi	0f
	  	.align 2
	   0:	.long disp
	   1:
	  
	   If the b!cond is 4 byte aligned, the literal which would
	   go at x+4 will also be aligned.  */
	int first_inst = fragP->fr_fix + fragP->fr_address;
	int needpad = (first_inst & 3);

	if (! target_big_endian)
	  buffer[1] ^= 0x08;
	else
	  buffer[0] ^= 0x08;	/* Toggle T/F bit.  */

	buffer[2] = INST_BYTE0 (MCORE_INST_JMPI);	/* Build jmpi.  */
	buffer[3] = INST_BYTE1 (MCORE_INST_JMPI);

	if (needpad)
	  {
	    if (! target_big_endian)
	      {
		buffer[0] = 4;	/* Branch over jmpi, pad, and ptr.  */
		buffer[2] = 1;	/* Jmpi offset of 1 gets the pointer.  */
	      }
	    else
	      {
		buffer[1] = 4;	/* Branch over jmpi, pad, and ptr.  */
		buffer[3] = 1;	/* Jmpi offset of 1 gets the pointer.  */
	      }

	    buffer[4] = 0;	/* Alignment/pad.  */
	    buffer[5] = 0;
	    buffer[6] = 0;	/* Space for 32 bit address.  */
	    buffer[7] = 0;
	    buffer[8] = 0;
	    buffer[9] = 0;

	    /* Make reloc for the long disp.  */
	    fix_new (fragP, fragP->fr_fix + 6, 4,
		     fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_32);

	    fragP->fr_fix += C32_LEN;
	  }
	else
	  {
	    /* See comment below about this given gas' limitations for
	       shrinking the fragment. '3' is the amount of code that
	       we inserted here, but '4' is right for the space we reserved
	       for this fragment.  */
	    if (! target_big_endian)
	      {
		buffer[0] = 3;	/* Branch over jmpi, and ptr.  */
		buffer[2] = 0;	/* Jmpi offset of 0 gets the pointer.  */
	      }
	    else
	      {
		buffer[1] = 3;	/* Branch over jmpi, and ptr.  */
		buffer[3] = 0;	/* Jmpi offset of 0 gets the pointer.  */
	      }

	    buffer[4] = 0;	/* Space for 32 bit address.  */
	    buffer[5] = 0;
	    buffer[6] = 0;
	    buffer[7] = 0;

	    /* Make reloc for the long disp.  */
	    fix_new (fragP, fragP->fr_fix + 4, 4,
		     fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_32);
	    fragP->fr_fix += C32_LEN;

	    /* Frag is actually shorter (see the other side of this ifdef)
	       but gas isn't prepared for that.  We have to re-adjust
	       the branch displacement so that it goes beyond the
	       full length of the fragment, not just what we actually
	       filled in.  */
	    if (! target_big_endian)
	      buffer[0] = 4;	/* Jmpi, ptr, and the 'tail pad'.  */
	    else
	      buffer[1] = 4;	/* Jmpi, ptr, and the 'tail pad'.  */
	  }
      }
      break;

    case C (UNCD_JUMP, DISP32):
    case C (UNCD_JUMP, UNDEF_WORD_DISP):
      {
	/* An unconditional branch will not fit in 12 bits, make code which
	   looks like:
	  	jmpi	0f
	  	.align 2
	     0:	.long disp
	   we need a pad if "first_inst" is 4 byte aligned.
	   [because the natural literal place is x + 2].  */
	int first_inst = fragP->fr_fix + fragP->fr_address;
	int needpad = !(first_inst & 3);

	buffer[0] = INST_BYTE0 (MCORE_INST_JMPI);	/* Build jmpi.  */
	buffer[1] = INST_BYTE1 (MCORE_INST_JMPI);

	if (needpad)
	  {
	    if (! target_big_endian)
	      buffer[0] = 1;	/* Jmpi offset of 1 since padded.  */
	    else
	      buffer[1] = 1;	/* Jmpi offset of 1 since padded.  */
	    buffer[2] = 0;	/* Alignment.  */
	    buffer[3] = 0;
	    buffer[4] = 0;	/* Space for 32 bit address.  */
	    buffer[5] = 0;
	    buffer[6] = 0;
	    buffer[7] = 0;

	    /* Make reloc for the long disp.  */
	    fix_new (fragP, fragP->fr_fix + 4, 4,
		     fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_32);

	    fragP->fr_fix += U32_LEN;
	  }
	else
	  {
	    if (! target_big_endian)
	      buffer[0] = 0;	/* Jmpi offset of 0 if no pad.  */
	    else
	      buffer[1] = 0;	/* Jmpi offset of 0 if no pad.  */
	    buffer[2] = 0;	/* Space for 32 bit address.  */
	    buffer[3] = 0;
	    buffer[4] = 0;
	    buffer[5] = 0;

	    /* Make reloc for the long disp.  */
	    fix_new (fragP, fragP->fr_fix + 2, 4,
		     fragP->fr_symbol, fragP->fr_offset, 0, BFD_RELOC_32);
	    fragP->fr_fix += U32_LEN;
	  }
      }
      break;

    default:
      abort ();
    }
}

/* Applies the desired value to the specified location.
   Also sets up addends for 'rela' type relocations.  */

void
md_apply_fix (fixS *   fixP,
	       valueT * valP,
	       segT     segment ATTRIBUTE_UNUSED)
{
  char *       buf  = fixP->fx_where + fixP->fx_frag->fr_literal;
  char *       file = fixP->fx_file ? fixP->fx_file : _("unknown");
  const char * symname;
  /* Note: use offsetT because it is signed, valueT is unsigned.  */
  offsetT      val  = *valP;

  symname = fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : _("<unknown>");
  /* Save this for the addend in the relocation record.  */
  fixP->fx_addnumber = val;

  if (fixP->fx_addsy != NULL)
    {
#ifdef OBJ_ELF
      /* For ELF we can just return and let the reloc that will be generated
	 take care of everything.  For COFF we still have to insert 'val'
	 into the insn since the addend field will be ignored.  */
      return;
#endif
    }
  else
    fixP->fx_done = 1;

  switch (fixP->fx_r_type)
    {
      /* Second byte of 2 byte opcode.  */
    case BFD_RELOC_MCORE_PCREL_IMM11BY2:
      if ((val & 1) != 0)
	as_bad_where (file, fixP->fx_line,
		      _("odd distance branch (0x%lx bytes)"), (long) val);
      val /= 2;
      if (((val & ~0x3ff) != 0) && ((val | 0x3ff) != -1))
	as_bad_where (file, fixP->fx_line,
		      _("pcrel for branch to %s too far (0x%lx)"),
		      symname, (long) val);
      if (target_big_endian)
	{
	  buf[0] |= ((val >> 8) & 0x7);
	  buf[1] |= (val & 0xff);
	}
      else
	{
	  buf[1] |= ((val >> 8) & 0x7);
	  buf[0] |= (val & 0xff);
	}
      break;

      /* Lower 8 bits of 2 byte opcode.  */
    case BFD_RELOC_MCORE_PCREL_IMM8BY4:
      val += 3;
      val /= 4;
      if (val & ~0xff)
	as_bad_where (file, fixP->fx_line,
		      _("pcrel for lrw/jmpi/jsri to %s too far (0x%lx)"),
		      symname, (long) val);
      else if (! target_big_endian)
	buf[0] |= (val & 0xff);
      else
	buf[1] |= (val & 0xff);
      break;

      /* Loopt instruction.  */
    case BFD_RELOC_MCORE_PCREL_IMM4BY2:
      if ((val < -32) || (val > -2))
	as_bad_where (file, fixP->fx_line,
		      _("pcrel for loopt too far (0x%lx)"), (long) val);
      val /= 2;
      if (! target_big_endian)
	buf[0] |= (val & 0xf);
      else
	buf[1] |= (val & 0xf);
      break;

    case BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2:
      /* Conditional linker map jsri to bsr.  */
      /* If its a local target and close enough, fix it.
	 NB: >= -2k for backwards bsr; < 2k for forwards...  */
      if (fixP->fx_addsy == 0 && val >= -2048  && val < 2048)
	{
	  long nval = (val / 2) & 0x7ff;
	  nval |= MCORE_INST_BSR;

	  /* REPLACE the instruction, don't just modify it.  */
	  buf[0] = INST_BYTE0 (nval);
	  buf[1] = INST_BYTE1 (nval);
	}
      else
	fixP->fx_done = 0;
      break;

    case BFD_RELOC_MCORE_PCREL_32:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      break;

    default:
      if (fixP->fx_addsy != NULL)
	{
	  /* If the fix is an absolute reloc based on a symbol's
	     address, then it cannot be resolved until the final link.  */
	  fixP->fx_done = 0;
	}
#ifdef OBJ_ELF
      else
#endif
	{
	  if (fixP->fx_size == 4)
	    ;
	  else if (fixP->fx_size == 2 && val >= -32768 && val <= 32767)
	    ;
	  else if (fixP->fx_size == 1 && val >= -256 && val <= 255)
	    ;
	  else
	    abort ();
	  md_number_to_chars (buf, val, fixP->fx_size);
	}
      break;
    }
}

void
md_operand (expressionS * expressionP)
{
  /* Ignore leading hash symbol, if poresent.  */
  if (* input_line_pointer == '#')
    {
      input_line_pointer ++;
      expression (expressionP);
    }
}

int md_long_jump_size;

/* Called just before address relaxation, return the length
   by which a fragment must grow to reach it's destination.  */
int
md_estimate_size_before_relax (fragS * fragP, segT segment_type)
{
  switch (fragP->fr_subtype)
    {
    default:
      abort ();

    case C (UNCD_JUMP, UNDEF_DISP):
      /* Used to be a branch to somewhere which was unknown.  */
      if (!fragP->fr_symbol)
	fragP->fr_subtype = C (UNCD_JUMP, DISP12);
      else if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	fragP->fr_subtype = C (UNCD_JUMP, DISP12);
      else
	fragP->fr_subtype = C (UNCD_JUMP, UNDEF_WORD_DISP);
      break;

    case C (COND_JUMP, UNDEF_DISP):
      /* Used to be a branch to somewhere which was unknown.  */
      if (fragP->fr_symbol
	  && S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	/* Got a symbol and it's defined in this segment, become byte
	   sized - maybe it will fix up */
	fragP->fr_subtype = C (COND_JUMP, DISP12);
      else if (fragP->fr_symbol)
	/* Its got a segment, but its not ours, so it will always be long.  */
	fragP->fr_subtype = C (COND_JUMP, UNDEF_WORD_DISP);
      else
	/* We know the abs value.  */
	fragP->fr_subtype = C (COND_JUMP, DISP12);
      break;

    case C (UNCD_JUMP, DISP12):
    case C (UNCD_JUMP, DISP32):
    case C (UNCD_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP, DISP12):
    case C (COND_JUMP, DISP32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
    }

  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Put number into target byte order.  */

void
md_number_to_chars (char * ptr, valueT use, int nbytes)
{
  if (target_big_endian)
    number_to_chars_bigendian (ptr, use, nbytes);
  else
    number_to_chars_littleendian (ptr, use, nbytes);
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED,
		  valueT size)
{
  /* Byte alignment is fine.  */
  return size;
}

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from_section (fixS * fixp, segT sec ATTRIBUTE_UNUSED)
{
#ifdef OBJ_ELF
  /* If the symbol is undefined or defined in another section
     we leave the add number alone for the linker to fix it later.
     Only account for the PC pre-bump (which is 2 bytes on the MCore).  */
  if (fixp->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))

  {
    gas_assert (fixp->fx_size == 2);	/* must be an insn */
    return fixp->fx_size;
  }
#endif

  /* The case where we are going to resolve things...  */
  return  fixp->fx_size + fixp->fx_where + fixp->fx_frag->fr_address;
}

#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
#define MAP(SZ,PCREL,TYPE)	case F (SZ, PCREL): code = (TYPE); break

arelent *
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED, fixS * fixp)
{
  arelent * rel;
  bfd_reloc_code_real_type code;

  switch (fixp->fx_r_type)
    {
      /* These confuse the size/pcrel macro approach.  */
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_MCORE_PCREL_IMM4BY2:
    case BFD_RELOC_MCORE_PCREL_IMM8BY4:
    case BFD_RELOC_MCORE_PCREL_IMM11BY2:
    case BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2:
    case BFD_RELOC_RVA:
      code = fixp->fx_r_type;
      break;

    default:
      switch (F (fixp->fx_size, fixp->fx_pcrel))
	{
	  MAP (1, 0, BFD_RELOC_8);
	  MAP (2, 0, BFD_RELOC_16);
	  MAP (4, 0, BFD_RELOC_32);
	  MAP (1, 1, BFD_RELOC_8_PCREL);
	  MAP (2, 1, BFD_RELOC_16_PCREL);
	  MAP (4, 1, BFD_RELOC_32_PCREL);
	default:
	  code = fixp->fx_r_type;
	  as_bad (_("Can not do %d byte %srelocation"),
		  fixp->fx_size,
		  fixp->fx_pcrel ? _("pc-relative") : "");
	}
      break;
  }

  rel = xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  /* Always pass the addend along!  */
  rel->addend = fixp->fx_addnumber;

  rel->howto = bfd_reloc_type_lookup (stdoutput, code);

  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (code));

      /* Set howto to a garbage value so that we can keep going.  */
      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      gas_assert (rel->howto != NULL);
    }

  return rel;
}

#ifdef OBJ_ELF
/* See whether we need to force a relocation into the output file.
   This is used to force out switch and PC relative relocations when
   relaxing.  */
int
mcore_force_relocation (fixS * fix)
{
  if (fix->fx_r_type == BFD_RELOC_RVA)
    return 1;

  return generic_force_reloc (fix);
}

/* Return true if the fix can be handled by GAS, false if it must
   be passed through to the linker.  */

bfd_boolean
mcore_fix_adjustable (fixS * fixP)
{
  /* We need the symbol name for the VTABLE entries.  */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}
#endif /* OBJ_ELF */
@


1.48
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
@


1.47
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d650 1
a650 1
  char * new;
d664 1
a664 1
  new = input_line_pointer;
d667 1
a667 1
  return new;
d774 1
a774 1
  char * new;
d777 1
a777 1
  new = parse_exp (s, & e);
d789 1
a789 1
  return new;
@


1.46
log
@            * config/tc-mcore.c (md_assemble): Increase length of name array
            to include terminating NUL.
@
text
@d2138 1
a2138 1
    assert (fixp->fx_size == 2);	/* must be an insn */
d2204 1
a2204 1
      assert (rel->howto != NULL);
@


1.45
log
@Remove duplicate definitions of the md_atof() function
@
text
@d862 1
a862 1
  char name[20];
@


1.44
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@a1618 6
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP.  An error message is returned, or NULL on OK.  */
d1621 1
a1621 1
md_atof (int type,  char * litP, int * sizeP)
d1623 1
a1623 61
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  int    i;
  char * t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_NTOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);

  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  if (! target_big_endian)
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litP, (valueT) words[i],
			      sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }
  else
    for (i = 0; i < prec; i++)
      {
	md_number_to_chars (litP, (valueT) words[i],
			    sizeof (LITTLENUM_TYPE));
	litP += sizeof (LITTLENUM_TYPE);
      }

  return 0;
@


1.43
log
@Switch to GPLv3
@
text
@d414 2
a415 2
  { "ascii",    mcore_stringer,       0 },
  { "asciz",    mcore_stringer,       1 },
d433 1
a433 1
  { "string",   mcore_stringer,       1 },
@


1.42
log
@* config/tc-mcore.c (md_number_to_chars): Use number_to_chars_{big|little}endian.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.41
log
@remove some duplicate #include's.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2006
d2173 2
a2174 9
  if (! target_big_endian)
    switch (nbytes)
      {
      case 4: ptr[3] = (use >> 24) & 0xff; /* Fall through.  */
      case 3: ptr[2] = (use >> 16) & 0xff; /* Fall through.  */
      case 2: ptr[1] = (use >>  8) & 0xff; /* Fall through.  */
      case 1: ptr[0] = (use >>  0) & 0xff;    break;
      default: abort ();
      }
d2176 1
a2176 8
    switch (nbytes)
      {
      case 4: *ptr++ = (use >> 24) & 0xff; /* Fall through.  */
      case 3: *ptr++ = (use >> 16) & 0xff; /* Fall through.  */
      case 2: *ptr++ = (use >>  8) & 0xff; /* Fall through.  */
      case 1: *ptr++ = (use >>  0) & 0xff;    break;
      default: abort ();
      }
@


1.40
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2005
a21 1
#include <stdio.h>
a22 1
#include "bfd.h"
a26 1
#include <string.h>
@


1.39
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a51 2
const int md_reloc_size = 8;

@


1.38
log
@Update the address and phone number of the FSF
@
text
@d1987 1
a1987 1
md_apply_fix3 (fixS *   fixP,
@


1.37
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.36
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@a39 25
static void   mcore_s_literals PARAMS ((int));
static void   mcore_pool_count PARAMS ((void (*) (int), int));
static void   mcore_cons PARAMS ((int));
static void   mcore_float_cons PARAMS ((int));
static void   mcore_stringer PARAMS ((int));
static void   mcore_fill   PARAMS ((int));
static int    mylog2 PARAMS ((unsigned int));
static char * parse_reg    PARAMS ((char *, unsigned *));
static char * parse_creg   PARAMS ((char *, unsigned *));
static char * parse_exp    PARAMS ((char *, expressionS *));
static char * parse_rt     PARAMS ((char *, char **, int, expressionS *));
static char * parse_imm    PARAMS ((char *, unsigned *, unsigned, unsigned));
static char * parse_mem    PARAMS ((char *, unsigned *, unsigned *, unsigned));
static char * parse_psrmod PARAMS ((char *, unsigned *));
static void   make_name PARAMS ((char *, char *, int));
static int    enter_literal PARAMS ((expressionS *, int));
static void   dump_literals PARAMS ((int));
static void   check_literals PARAMS ((int, int));
static void   mcore_s_text    PARAMS ((int));
static void   mcore_s_data    PARAMS ((int));
static void   mcore_s_section PARAMS ((int));
static void   mcore_s_bss     PARAMS ((int));
#ifdef OBJ_ELF
static void   mcore_s_comm    PARAMS ((int));
#endif
d67 1
a67 1
/* These are the two types of relaxable instruction */
d77 1
a77 1
#define C32_LEN	       10	/* allow for align */
d79 1
a79 1
#define U32_LEN	        8	/* allow for align */
d91 2
a92 1
const relax_typeS md_relax_table[] = {
d142 1
a142 1
static symbolS * poolsym;		/* label for current pool.  */
d146 20
a165 6
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     Pseudo-op name without dot
     Function to call to execute this pseudo-op
     Integer arg to pass to the function.   */
const pseudo_typeS md_pseudo_table[] =
d167 33
a199 4
  { "export",   s_globl,          0 },
  { "import",   s_ignore,         0 },
  { "literals", mcore_s_literals, 0 },
  { "page",     listing_eject,    0 },
d201 2
a202 27
  /* The following are to intercept the placement of data into the text
     section (eg addresses for a switch table), so that the space they
     occupy can be taken into account when deciding whether or not to
     dump the current literal pool.
     XXX - currently we do not cope with the .space and .dcb.d directives.  */
  { "ascii",    mcore_stringer,       0 },
  { "asciz",    mcore_stringer,       1 },
  { "byte",     mcore_cons,           1 },
  { "dc",       mcore_cons,           2 },
  { "dc.b",     mcore_cons,           1 },
  { "dc.d",     mcore_float_cons,    'd'},
  { "dc.l",     mcore_cons,           4 },
  { "dc.s",     mcore_float_cons,    'f'},
  { "dc.w",     mcore_cons,           2 },
  { "dc.x",     mcore_float_cons,    'x'},
  { "double",   mcore_float_cons,    'd'},
  { "float",    mcore_float_cons,    'f'},
  { "hword",    mcore_cons,           2 },
  { "int",      mcore_cons,           4 },
  { "long",     mcore_cons,           4 },
  { "octa",     mcore_cons,          16 },
  { "quad",     mcore_cons,           8 },
  { "short",    mcore_cons,           2 },
  { "single",   mcore_float_cons,    'f'},
  { "string",   mcore_stringer,       1 },
  { "word",     mcore_cons,           2 },
  { "fill",     mcore_fill,           0 },
d204 2
a205 11
  /* Allow for the effect of section changes.  */
  { "text",      mcore_s_text,    0 },
  { "data",      mcore_s_data,    0 },
  { "bss",       mcore_s_bss,     1 },
#ifdef OBJ_ELF
  { "comm",      mcore_s_comm,    0 },
#endif
  { "section",   mcore_s_section, 0 },
  { "section.s", mcore_s_section, 0 },
  { "sect",      mcore_s_section, 0 },
  { "sect.s",    mcore_s_section, 0 },
d207 2
a208 2
  { 0,          0,                0 }
};
d211 1
a211 2
mcore_s_literals (ignore)
     int ignore ATTRIBUTE_UNUSED;
d220 1
a220 3
mcore_pool_count (func, arg)
     void (*func) PARAMS ((int));
     int arg;
d238 36
a273 2
mcore_cons (nbytes)
     int nbytes;
d288 1
a288 2
mcore_float_cons (float_type)
     int float_type;
d303 1
a303 2
mcore_stringer (append_zero)
     int append_zero;
d319 1
a319 2
mcore_fill (unused)
     int unused;
d331 1
d333 1
a333 2
mcore_s_text (ignore)
     int ignore;
d345 1
a345 2
mcore_s_data (ignore)
     int ignore;
d357 1
a357 2
mcore_s_section (ignore)
     int ignore;
d385 1
a385 2
mcore_s_bss (needs_align)
     int needs_align;
d394 1
a394 2
mcore_s_comm (needs_align)
     int needs_align;
d402 55
d459 1
d461 1
a461 1
md_begin ()
d468 1
a468 1
  /* Insert unique names into hash table */
d480 1
d482 1
a482 2
mylog2 (val)
    unsigned int val;
d484 3
a486 2
    int log = -1;
    while (val != 0)
d492 1
a492 1
    return log;
d496 1
d498 1
a498 3
parse_reg (s, reg)
     char * s;
     unsigned * reg;
d554 1
a554 3
parse_creg (s, reg)
     char * s;
     unsigned * reg;
d614 1
a614 3
parse_psrmod (s, reg)
  char *     s;
  unsigned * reg;
d652 1
a652 3
parse_exp (s, e)
     char * s;
     expressionS * e;
a674 105
static void
make_name (s, p, n)
     char * s;
     char * p;
     int n;
{
  static const char hex[] = "0123456789ABCDEF";

  s[0] = p[0];
  s[1] = p[1];
  s[2] = p[2];
  s[3] = hex[(n >> 12) & 0xF];
  s[4] = hex[(n >>  8) & 0xF];
  s[5] = hex[(n >>  4) & 0xF];
  s[6] = hex[(n)       & 0xF];
  s[7] = 0;
}

#define POOL_END_LABEL   ".LE"
#define POOL_START_LABEL ".LS"

static void
dump_literals (isforce)
     int isforce;
{
  unsigned int i;
  struct literal * p;
  symbolS * brarsym = NULL;

  if (poolsize == 0)
    return;

  /* Must we branch around the literal table? */
  if (isforce)
    {
      char * output;
      char brarname[8];

      make_name (brarname, POOL_END_LABEL, poolnumber);

      brarsym = symbol_make (brarname);

      symbol_table_insert (brarsym);

      output = frag_var (rs_machine_dependent,
			 md_relax_table[C (UNCD_JUMP, DISP32)].rlx_length,
			 md_relax_table[C (UNCD_JUMP, DISP12)].rlx_length,
			 C (UNCD_JUMP, 0), brarsym, 0, 0);
      output[0] = INST_BYTE0 (MCORE_INST_BR);	/* br .+xxx */
      output[1] = INST_BYTE1 (MCORE_INST_BR);
    }

  /* Make sure that the section is sufficiently aligned and that
     the literal table is aligned within it.  */
  record_alignment (now_seg, 2);
  frag_align (2, 0, 0);

  colon (S_GET_NAME (poolsym));

  for (i = 0, p = litpool; i < poolsize; i++, p++)
    emit_expr (& p->e, 4);

  if (brarsym != NULL)
    colon (S_GET_NAME (brarsym));

   poolsize = 0;
}

static void
check_literals (kind, offset)
     int kind;
     int offset;
{
  poolspan += offset;

  /* SPANCLOSE and SPANEXIT are smaller numbers than SPANPANIC.
     SPANPANIC means that we must dump now.
     kind == 0 is any old instruction.
     kind  > 0 means we just had a control transfer instruction.
     kind == 1 means within a function
     kind == 2 means we just left a function

     The dump_literals (1) call inserts a branch around the table, so
     we first look to see if its a situation where we won't have to
     insert a branch (e.g., the previous instruction was an unconditional
     branch).

     SPANPANIC is the point where we must dump a single-entry pool.
     it accounts for alignments and an inserted branch.
     the 'poolsize*2' accounts for the scenario where we do:
       lrw r1,lit1; lrw r2,lit2; lrw r3,lit3
     Note that the 'lit2' reference is 2 bytes further along
     but the literal it references will be 4 bytes further along,
     so we must consider the poolsize into this equation.
     This is slightly over-cautious, but guarantees that we won't
     panic because a relocation is too distant.  */

  if (poolspan > SPANCLOSE && kind > 0)
    dump_literals (0);
  else if (poolspan > SPANEXIT && kind > 1)
    dump_literals (0);
  else if (poolspan >= (SPANPANIC - poolsize * 2))
    dump_literals (1);
}

d676 1
a676 3
enter_literal (e, ispcrel)
     expressionS * e;
     int ispcrel;
d682 7
a688 9
    {
      /* The literal pool is as full as we can handle. We have
	 to be 2 entries shy of the 1024/4=256 entries because we
	 have to allow for the branch (2 bytes) and the alignment
	 (2 bytes before the first insn referencing the pool and
	 2 bytes before the pool itself) == 6 bytes, rounds up
	 to 2 entries.  */
      dump_literals (1);
    }
d727 1
d729 4
a732 5
parse_rt (s, outputp, ispcrel, ep)
     char * s;
     char ** outputp;
     int ispcrel;
     expressionS * ep;
d774 4
a777 5
parse_imm (s, val, min, max)
     char * s;
     unsigned * val;
     unsigned min;
     unsigned max;
d798 4
a801 5
parse_mem (s, reg, off, siz)
     char * s;
     unsigned * reg;
     unsigned * off;
     unsigned siz;
d855 1
a855 2
md_assemble (str)
     char * str;
d943 2
a944 2
	  /* Replace with:  bsr .+2 ; addi r15,6; jmp rx ; jmp rx */
	  inst = MCORE_INST_BSR;	/* with 0 displacement */
d950 2
a951 2
	  inst |= 15;			/* addi r15,6 */
	  inst |= (6 - 1) << 4;		/* over the jmp's */
d960 2
a961 1
	  output = frag_more (2);		/* 2nd emitted in fallthru */
d1008 2
a1009 1
    case X1:	/* Handle both syntax-> xtrb- r1,rx OR xtrb- rx */
d1016 1
a1016 1
      if (* op_end == ',')	/* xtrb- r1,rx */
d1028 1
a1028 1
    case O1R1:  /* div- rx,r1 */
d1086 2
a1087 1
    case OB2:		/* like OB, but arg is 2^n instead of n */
d1127 1
a1127 1
	  /* immediate values of 0 -> 6 translate to movi */
d1143 1
a1143 1
    case OBR2:	/* like OBR, but arg is 2^n instead of n */
d1496 2
a1497 1
    case RSI:				/* SI, but imm becomes 32-imm */
d1611 1
a1611 2
md_undefined_symbol (name)
       char *name ATTRIBUTE_UNUSED;
d1617 1
a1617 1
md_mcore_end ()
d1624 1
a1624 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d1629 2
a1630 1
   emitted is stored in *sizeP.  An error message is returned, or NULL on OK.*/
d1632 1
a1632 4
md_atof (type, litP, sizeP)
     int type;
     char * litP;
     int * sizeP;
d1699 10
a1708 7
#define OPTION_JSRI2BSR_ON	(OPTION_MD_BASE + 0)
#define OPTION_JSRI2BSR_OFF	(OPTION_MD_BASE + 1)
#define OPTION_SIFILTER_ON	(OPTION_MD_BASE + 2)
#define OPTION_SIFILTER_OFF	(OPTION_MD_BASE + 3)
#define OPTION_CPU		(OPTION_MD_BASE + 4)
#define OPTION_EB		(OPTION_MD_BASE + 5)
#define OPTION_EL		(OPTION_MD_BASE + 6)
d1725 1
a1725 3
md_parse_option (c, arg)
     int c;
     char * arg;
d1754 1
a1754 2
md_show_usage (stream)
     FILE * stream;
d1768 5
a1772 6
md_create_short_jump (ptr, from_Nddr, to_Nddr, frag, to_symbol)
     char * ptr ATTRIBUTE_UNUSED;
     addressT from_Nddr ATTRIBUTE_UNUSED;
     addressT to_Nddr ATTRIBUTE_UNUSED;
     fragS * frag ATTRIBUTE_UNUSED;
     symbolS * to_symbol ATTRIBUTE_UNUSED;
d1778 5
a1782 6
md_create_long_jump (ptr, from_Nddr, to_Nddr, frag, to_symbol)
     char * ptr ATTRIBUTE_UNUSED;
     addressT from_Nddr ATTRIBUTE_UNUSED;
     addressT to_Nddr ATTRIBUTE_UNUSED;
     fragS * frag ATTRIBUTE_UNUSED;
     symbolS * to_symbol ATTRIBUTE_UNUSED;
d1788 1
d1790 3
a1792 4
md_convert_frag (abfd, sec, fragP)
     bfd * abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     register fragS * fragP;
d1839 8
a1846 9
	 *	b!cond	1f
	 *	jmpi	0f
	 *	.align 2
	 * 0:	.long disp
	 * 1:
	 *
	 * if the b!cond is 4 byte aligned, the literal which would
	 * go at x+4 will also be aligned.
	 */
d1853 1
a1853 1
	  buffer[0] ^= 0x08;	/* Toggle T/F bit */
d1855 1
a1855 1
	buffer[2] = INST_BYTE0 (MCORE_INST_JMPI);	/* Build jmpi */
d1862 2
a1863 2
		buffer[0] = 4;	/* branch over jmpi, pad, and ptr */
		buffer[2] = 1;	/* jmpi offset of 1 gets the pointer */
d1867 2
a1868 2
		buffer[1] = 4;	/* branch over jmpi, pad, and ptr */
		buffer[3] = 1;	/* jmpi offset of 1 gets the pointer */
d1871 1
a1871 1
	    buffer[4] = 0;	/* alignment/pad */
d1873 1
a1873 1
	    buffer[6] = 0;	/* space for 32 bit address */
d1878 1
a1878 1
	    /* Make reloc for the long disp */
d1892 2
a1893 2
		buffer[0] = 3;	/* branch over jmpi, and ptr */
		buffer[2] = 0;	/* jmpi offset of 0 gets the pointer */
d1897 2
a1898 2
		buffer[1] = 3;	/* branch over jmpi, and ptr */
		buffer[3] = 0;	/* jmpi offset of 0 gets the pointer */
d1901 1
a1901 1
	    buffer[4] = 0;	/* space for 32 bit address */
d1917 1
a1917 1
	      buffer[0] = 4;	/* jmpi, ptr, and the 'tail pad' */
d1919 1
a1919 1
	      buffer[1] = 4;	/* jmpi, ptr, and the 'tail pad' */
d1933 1
a1933 1
	   [because the natural literal place is x + 2]  */
d1937 1
a1937 1
	buffer[0] = INST_BYTE0 (MCORE_INST_JMPI);	/* Build jmpi */
d1943 1
a1943 1
	      buffer[0] = 1;	/* jmpi offset of 1 since padded */
d1945 2
a1946 2
	      buffer[1] = 1;	/* jmpi offset of 1 since padded */
	    buffer[2] = 0;	/* alignment */
d1948 1
a1948 1
	    buffer[4] = 0;	/* space for 32 bit address */
d1962 1
a1962 1
	      buffer[0] = 0;	/* jmpi offset of 0 if no pad */
d1964 2
a1965 2
	      buffer[1] = 0;	/* jmpi offset of 0 if no pad */
	    buffer[2] = 0;	/* space for 32 bit address */
d1987 3
a1989 4
md_apply_fix3 (fixP, valP, segment)
     fixS *   fixP;
     valueT * valP;
     segT     segment ATTRIBUTE_UNUSED;
d2015 2
a2016 1
    case BFD_RELOC_MCORE_PCREL_IMM11BY2:     /* second byte of 2 byte opcode */
d2037 2
a2038 1
    case BFD_RELOC_MCORE_PCREL_IMM8BY4:	/* lower 8 bits of 2 byte opcode */
d2051 2
a2052 1
    case BFD_RELOC_MCORE_PCREL_IMM4BY2:	/* loopt instruction */
d2112 1
a2112 2
md_operand (expressionP)
     expressionS * expressionP;
d2127 1
a2127 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS * fragP;
     register segT segment_type;
d2137 1
a2137 3
	{
	  fragP->fr_subtype = C (UNCD_JUMP, DISP12);
	}
d2139 1
a2139 3
	{
	  fragP->fr_subtype = C (UNCD_JUMP, DISP12);
	}
d2141 1
a2141 3
	{
	  fragP->fr_subtype = C (UNCD_JUMP, UNDEF_WORD_DISP);
	}
d2148 3
a2150 5
	{
	  /* Got a symbol and it's defined in this segment, become byte
	     sized - maybe it will fix up */
	  fragP->fr_subtype = C (COND_JUMP, DISP12);
	}
d2152 2
a2153 4
	{
	  /* Its got a segment, but its not ours, so it will always be long.  */
	  fragP->fr_subtype = C (COND_JUMP, UNDEF_WORD_DISP);
	}
d2155 2
a2156 4
	{
	  /* We know the abs value.  */
	  fragP->fr_subtype = C (COND_JUMP, DISP12);
	}
d2174 1
d2176 1
a2176 4
md_number_to_chars (ptr, use, nbytes)
     char * ptr;
     valueT use;
     int nbytes;
d2181 3
a2183 3
      case 4: ptr[3] = (use >> 24) & 0xff; /* fall through */
      case 3: ptr[2] = (use >> 16) & 0xff; /* fall through */
      case 2: ptr[1] = (use >>  8) & 0xff; /* fall through */
d2190 3
a2192 3
      case 4: *ptr++ = (use >> 24) & 0xff; /* fall through */
      case 3: *ptr++ = (use >> 16) & 0xff; /* fall through */
      case 2: *ptr++ = (use >>  8) & 0xff; /* fall through */
d2199 1
d2201 2
a2202 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d2204 2
a2205 1
  return size;			/* Byte alignment is fine */
d2210 1
d2212 1
a2212 3
md_pcrel_from_section (fixp, sec)
     fixS * fixp;
     segT sec ATTRIBUTE_UNUSED;
d2236 1
a2236 3
tc_gen_reloc (section, fixp)
     asection * section ATTRIBUTE_UNUSED;
     fixS * fixp;
d2272 2
a2273 2
  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d2300 1
a2300 2
mcore_force_relocation (fix)
     fixS * fix;
d2310 1
d2312 1
a2312 2
mcore_fix_adjustable (fixP)
   fixS * fixP;
@


1.35
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d1848 1
a1848 1
  unsigned char * buffer;
d1851 1
a1851 1
  buffer = (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
@


1.34
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d46 1
a46 1
static int    log2 PARAMS ((unsigned int));
d416 1
a416 1
log2 (val)
d1150 1
a1150 1
	    reg = log2 (reg);
d1207 1
a1207 1
	    reg = log2 (reg);
@


1.33
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d349 1
a349 1
     which is arbitarily placed inside generated code.  In this case
@


1.32
log
@	* config/tc-d30v.c (check_range): Warning fixes, formatting.
	Simplify sign extension.  Remove redundant unsigned < 0 test.
	* config/tc-i960.c (md_ri_to_chars): Prototype.
	* config/tc-mcore.c (md_pseudo_table): Fix typo.
	(dump_literals): Init brarsym, and test later instead of isforce.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d2374 1
a2374 3
  if (   fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fix->fx_r_type == BFD_RELOC_RVA)
d2377 1
a2377 1
  return S_FORCE_RELOC (fix->fx_addsy);
@


1.31
log
@	* config/tc-mcore.c (mcore_s_literals <ignore>): Add ATTRIBUTE_UNUSED.
	(md_undefined_symbol <ignore>): Likewise.
	(md_create_short_jump <all args>): Likewise.
	(md_create_long_jump <all args>): Likewise.
	(md_convert_frag <abfd, sec>): Likewise.
	(md_apply_fix3 <segment>): Likewise.
	(md_section_align <segment>): Likewise.
	(md_pcrel_from_section <sec>): Likewise.
	(tc_gen_reloc <section>): Likewise.
	(reg_m, reg_n, immediate): Delete unused vars.
	(dump_literals): Fix signed/unsigned warning.
	(enter_literal): Likewise.
	(parse_imm): Likewise.  Also fix format string.
	(parse_mem): Remove unused var.
	(md_assemble <LS>): Abort on unexpected inst.
	(md_atof): Remove declaration of atof_ieee.
	(md_parse_option): Remove unused vars.
	(md_apply_fix3): Fix format strings, cast args.
	(tc_gen_reloc): Delete unused var.
	* config/tc-mcore.h (tc_coff_sizemachdep): Declare.
@
text
@d213 1
a213 1
#ifdef OBJ_EF
d642 1
a642 1
  symbolS * brarsym;
d677 1
a677 1
  if (isforce)
@


1.30
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d226 1
a226 1
     int ignore;
a412 4
static int reg_m;
static int reg_n;
static expressionS immediate;	/* absolute expression */

d640 1
a640 1
  int i;
d725 1
a725 1
  int i;
d838 3
a840 3
  else if (e.X_add_number < min || e.X_add_number > max)
    as_bad (_("operand must be absolute in range %d..%d, not %d"),
	    min, max, e.X_add_number);
a853 2
  char * new;

d1320 2
d1660 1
a1660 1
       char * name;
a1688 1
  char * atof_ieee ();
a1776 3
  int i;
  char * p;

d1820 5
a1824 5
     char * ptr;
     addressT from_Nddr;
     addressT to_Nddr;
     fragS * frag;
     symbolS * to_symbol;
d1831 5
a1835 5
     char * ptr;
     addressT from_Nddr;
     addressT to_Nddr;
     fragS * frag;
     symbolS * to_symbol;
d1843 2
a1844 2
     bfd * abfd;
     segT sec;
d2044 1
a2044 1
     segT     segment;
d2073 1
a2073 1
		      _("odd distance branch (0x%x bytes)"), val);
d2077 2
a2078 2
		      _("pcrel for branch to %s too far (0x%x)"),
		      symname, val);
d2096 2
a2097 2
		      _("pcrel for lrw/jmpi/jsri to %s too far (0x%x)"),
		      symname, val);
d2107 1
a2107 1
		      _("pcrel for loopt too far (0x%x)"), val);
d2270 1
a2270 1
     segT segment;
d2281 1
a2281 1
     segT sec;
d2306 1
a2306 1
     asection * section;
a2310 1
  int handled = 0;
@


1.29
log
@	* config/tc-mcore.c (mcore_pool_count): New function.
	(mcore_cons, mcore_float_cons, mcore_stringer, mcore_fill): Use it.
@
text
@d2393 1
a2393 1
boolean
@


1.28
log
@2002-11-20  Klee Dienes  <kdienes@@apple.com>

        * config/tc-mcore.c (md_begin): Use a const iterator.  Don't
        coalesce the name fields to use the same pointer.

        * config/tc-sh.c (md_begin): Use a const iterator.  Don't coalesce
        the name fields to use the same pointer.
        (get_specific): Check for opcodes with the same name using strcmp
        as well as comparing the pointer.
@
text
@d40 1
d232 2
d235 3
a237 2
mcore_cons (nbytes)
     int nbytes;
d239 2
a240 4
  if (now_seg == text_section)
    {
      char * ptr = input_line_pointer;
      int    commas = 1;
d242 1
a242 3
      /* Count the number of commas on the line.  */
      while (! is_end_of_line [(unsigned char) * ptr])
	commas += * ptr ++ == ',';
d244 4
a247 1
      poolspan += nbytes * commas;
d250 12
a261 1
  cons (nbytes);
d275 3
a277 19
    {
      char * ptr = input_line_pointer;
      int    commas = 1;

#ifdef REPEAT_CONS_EXPRESSIONS
#error REPEAT_CONS_EXPRESSIONS not handled
#endif

      /* Count the number of commas on the line.  */
      while (! is_end_of_line [(unsigned char) * ptr])
	commas += * ptr ++ == ',';

      /* We would like to compute "hex_float (float_type) * commas"
	 but hex_float is not exported from read.c  */
      float_type == 'f' ? 4 : (float_type == 'd' ? 8 : 12);
      poolspan += float_type * commas;
    }

  float_cons (float_type);
d291 3
a293 17
    {
      char * ptr = input_line_pointer;

      /* In theory we should compute how many bytes are going to
	 be occupied by the string(s) and add this to the poolspan.
	 To keep things simple however, we just add the number of
	 bytes left on the current line.  This will be an over-
	 estimate, which is OK, and automatically allows for the
	 appending a zero byte, since the real string(s) is/are
	 required to be enclosed in double quotes.  */
      while (! is_end_of_line [(unsigned char) * ptr])
	ptr ++;

      poolspan += ptr - input_line_pointer;
    }

  stringer (append_zero);
d308 3
a310 25
    {
      char * str = input_line_pointer;
      int    size = 1;
      int    repeat;

      repeat = atoi (str);

      /* Look to see if a size has been specified.  */
      while (*str != '\n' && *str != 0 && *str != ',')
	++ str;

      if (* str == ',')
	{
	  size = atoi (str + 1);

	  if (size > 8)
	    size = 8;
	  else if (size < 0)
	    size = 0;
	}

      poolspan += size * repeat;
    }

  s_fill (unused);
d425 2
a426 2
        log ++;
        val >>= 1;
d580 1
a580 1
          * reg = psrmods[i].value;
d582 1
a582 1
          return s + 2;
d735 5
a739 5
         to be 2 entries shy of the 1024/4=256 entries because we
         have to allow for the branch (2 bytes) and the alignment
         (2 bytes before the first insn referencing the pool and
         2 bytes before the pool itself) == 6 bytes, rounds up
         to 2 entries.  */
d981 1
a981 1
         fixes problem of an interrupt during a jmp..  */
d1356 1
a1356 1
          op_end = input_line_pointer;
d1796 1
a1796 1
        as_warn (_("unrecognised cpu type '%s'"), arg);
d2126 1
a2126 1
         NB: >= -2k for backwards bsr; < 2k for forwards...  */
d2336 8
a2343 8
        {
          MAP (1, 0, BFD_RELOC_8);
          MAP (2, 0, BFD_RELOC_16);
          MAP (4, 0, BFD_RELOC_32);
          MAP (1, 1, BFD_RELOC_8_PCREL);
          MAP (2, 1, BFD_RELOC_16_PCREL);
          MAP (4, 1, BFD_RELOC_32_PCREL);
        default:
d2345 1
a2345 1
          as_bad (_("Can not do %d byte %srelocation"),
d2347 2
a2348 2
	          fixp->fx_pcrel ? _("pc-relative") : "");
        }
d2364 2
a2365 2
                    _("Cannot represent relocation type %s"),
                    bfd_get_reloc_code_name (code));
@


1.27
log
@gas reloc rewrite.
@
text
@d435 1
a435 1
  mcore_opcode_info * opcode;
d443 1
a443 7
      if (streq (prev_name, opcode->name))
	{
	  /* Make all the opcodes with the same name point to the same
	     string.  */
	  opcode->name = prev_name;
	}
      else
@


1.26
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d2102 1
a2102 1
  offsetT      val  = * (offsetT *)  valP;
d2108 1
a2108 5
  /* If the fix is relative to a symbol which is not defined, or not
     in the same segment as the fix, we cannot resolve it here.  */
  if (fixP->fx_addsy != NULL
      && (   ! S_IS_DEFINED (fixP->fx_addsy)
	  || (S_GET_SEGMENT (fixP->fx_addsy) != segment)))
a2109 1
      fixP->fx_done = 0;
d2432 1
a2432 1
  return 0;
a2440 3
  if (fixP->fx_addsy == NULL)
    return 1;

@


1.25
log
@	* config/obj-coff.h: Fix formatting.
	* config/tc-mcore.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-openrisc.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-xstormy16.h: Likewise.
@
text
@d1797 1
a1797 1
CONST char * md_shortopts = "";
@


1.24
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d127 3
a129 3
  {    0,     0, 0,	  0 },			  /* UNDEF_DISP */     
  { 2048, -2046, U12_LEN, C(UNCD_JUMP, DISP32) }, /* DISP12 */         
  {    0,     0, U32_LEN, 0 },			  /* DISP32 */         
@


1.23
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2091 3
a2093 2
int
md_apply_fix3 (fixP, valp, segment)
d2095 1
a2095 1
     valueT * valp;
d2102 1
a2102 1
  offsetT      val  = (offsetT) * valp;
d2119 1
a2119 1
      return 0;
a2217 2

  return 0; /* Return value is ignored.  */
@


1.22
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d27 1
a27 1
#include <ctype.h>
d393 1
a393 1
  while (*ilp != 0 && isspace(*ilp))
d397 1
a397 1
      && (isspace (ilp[5]) || *ilp == '\n' || *ilp == '\r'))
d483 1
a483 1
  while (isspace (* s))
d486 1
a486 1
  if (tolower (s[0]) == 'r')
d500 3
a502 3
  else if (   tolower (s[0]) == 's'
	   && tolower (s[1]) == 'p'
	   && ! isalnum (s[2]))
d543 1
a543 1
  while (isspace (* s))
d546 1
a546 1
  if ((tolower (s[0]) == 'c' && tolower (s[1]) == 'r'))
d583 1
a583 1
	buf[j] = tolower (s[j]);
d618 1
a618 1
    buf[i] = isascii (s[i]) ? tolower (s[i]) : 0;
d646 1
a646 1
  while (isspace (* s))
d906 1
a906 1
  while (isspace (* s))
d913 1
a913 1
      while (isspace (* s))
d939 1
a939 1
      while (isspace (* s))
d972 1
a972 1
  while (isspace (* str))
d1071 1
a1071 1
      while (isspace (* op_end))
d1095 1
a1095 1
      while (isspace (* op_end))
d1113 1
a1113 1
      while (isspace (* op_end))
d1133 1
a1133 1
      while (isspace (* op_end))
d1153 1
a1153 1
      while (isspace (* op_end))
d1172 1
a1172 1
      while (isspace (* op_end))
d1191 1
a1191 1
      while (isspace (* op_end))
d1220 1
a1220 1
      while (isspace (* op_end))
d1247 1
a1247 1
      while (isspace (* op_end))
d1286 1
a1286 1
      while (isspace (* op_end))
d1319 1
a1319 1
      while (isspace (* op_end))
d1338 1
a1338 1
      while (isspace (* op_end))
d1357 1
a1357 1
      while (isspace (* op_end))
d1393 1
a1393 1
      while (isspace (* op_end))
d1424 1
a1424 1
      while (isspace (* op_end))
d1435 1
a1435 1
	  while (isspace (* op_end))
d1444 1
a1444 1
	  while (isspace (* op_end))
d1473 1
a1473 1
      while (isspace (* op_end))
d1484 1
a1484 1
	  while (isspace (* op_end))
d1492 1
a1492 1
	      while (isspace (* op_end))
d1505 1
a1505 1
		  while (isspace (* op_end))
d1538 1
a1538 1
      while (isspace (* op_end))
d1598 1
a1598 1
      while (isspace (* op_end))
d1620 1
a1620 1
      while (isspace (* op_end))
d1641 1
a1641 1
      while (isspace (* op_end))
d1693 1
a1693 1
  while (isspace (* op_end))
@


1.21
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@a1902 1
  targ_addr += symbol_get_frag (fragP->fr_symbol)->fr_address;
@


1.20
log
@Fix more breakages from the multiple relax pass patch.
@
text
@a1937 1
	fragP->fr_var = 0;
a2027 2

	fragP->fr_var = 0;
a2081 2

	fragP->fr_var = 0;
d2296 1
a2296 2
  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
  return fragP->fr_var;
@


1.19
log
@Prepare for multi-pass relaxation.
@
text
@d114 18
a131 14
const relax_typeS md_relax_table[] =
{
{    1,     1,	     0, 0 },			/* 0: unused */
{    1,     1,	     0, 0 },			/* 1: unused */
{    1,     1,	     0, 0 },			/* 2: unused */
{    1,     1,	     0, 0 },			/* 3: unused */
{    1,     1,	     0, 0 },			/* 4: unused */
{ 2048, -2046, C12_LEN, C(COND_JUMP, DISP32) },	/* 5: C(COND_JUMP, DISP12) */
{    0,     0, C32_LEN, 0 },			/* 6: C(COND_JUMP, DISP32) */
{    1,     1,	     0, 0 },			/* 7: unused */
{    1,     1,	     0, 0 },			/* 8: unused */
{ 2048, -2046, U12_LEN, C(UNCD_JUMP, DISP32) },	/* 9: C(UNCD_JUMP, DISP12) */
{    0,     0, U32_LEN, 0 },			/*10: C(UNCD_JUMP, DISP32) */
{    1,     1,	     0, 0 },			/*11: unused */
a2257 1
	  fragP->fr_var = md_relax_table[C (UNCD_JUMP, DISP12)].rlx_length;
a2261 1
	  fragP->fr_var = md_relax_table[C (UNCD_JUMP, DISP12)].rlx_length;
a2265 1
	  fragP->fr_var = md_relax_table[C (UNCD_JUMP, DISP32)].rlx_length;
a2276 1
	  fragP->fr_var = md_relax_table[C (COND_JUMP, DISP12)].rlx_length;
a2281 1
	  fragP->fr_var = md_relax_table[C (COND_JUMP, DISP32)].rlx_length;
a2286 1
	  fragP->fr_var = md_relax_table[C (COND_JUMP, DISP12)].rlx_length;
d2291 1
d2294 1
d2297 1
a2297 1
	 do anything.  */
d2301 1
@


1.18
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d95 3
a97 6
#define COND12          1
#define COND32          2
#define UNCD12          1
#define UNCD32          2
#define UNDEF_WORD_DISP 4
#define END             5
d121 2
a122 2
{ 2048, -2046, C12_LEN, C(COND_JUMP, COND32) },	/* 5: C(COND_JUMP, COND12) */
{    0,     0, C32_LEN, 0 },			/* 6: C(COND_JUMP, COND32) */
d125 2
a126 2
{ 2048, -2046, U12_LEN, C(UNCD_JUMP, UNCD32) },	/* 9: C(UNCD_JUMP, UNCD12) */
{    0,     0, U32_LEN, 0 },			/*10: C(UNCD_JUMP, UNCD32) */
a127 1
{    0,     0,	     0, 0 }			/*12: unused */
d704 2
a705 2
			 md_relax_table[C (UNCD_JUMP, UNCD32)].rlx_length,
			 md_relax_table[C (UNCD_JUMP, UNCD12)].rlx_length,
d1557 2
a1558 2
			 md_relax_table[C (COND_JUMP, COND32)].rlx_length,
			 md_relax_table[C (COND_JUMP, COND12)].rlx_length,
d1568 2
a1569 2
			 md_relax_table[C (UNCD_JUMP, UNCD32)].rlx_length,
			 md_relax_table[C (UNCD_JUMP, UNCD12)].rlx_length,
d1903 2
a1904 2
    case C (COND_JUMP, COND12):
    case C (UNCD_JUMP, UNCD12):
d1938 1
a1938 1
    case C (COND_JUMP, COND32):
d2030 1
a2030 1
    case C (UNCD_JUMP, UNCD32):
d2246 3
d2253 2
a2254 2
	  fragP->fr_subtype = C (UNCD_JUMP, UNCD12);
	  fragP->fr_var = md_relax_table[C (UNCD_JUMP, UNCD12)].rlx_length;
d2258 2
a2259 2
	  fragP->fr_subtype = C (UNCD_JUMP, UNCD12);
	  fragP->fr_var = md_relax_table[C (UNCD_JUMP, UNCD12)].rlx_length;
d2264 1
a2264 2
	  fragP->fr_var = md_relax_table[C (UNCD_JUMP, UNCD32)].rlx_length;
	  return md_relax_table[C (UNCD_JUMP, UNCD32)].rlx_length;
a2267 3
    default:
      abort ();

d2275 2
a2276 2
	  fragP->fr_subtype = C (COND_JUMP, COND12);
	  fragP->fr_var = md_relax_table[C (COND_JUMP, COND12)].rlx_length;
d2282 1
a2282 2
	  fragP->fr_var = md_relax_table[C (COND_JUMP, COND32)].rlx_length;
	  return md_relax_table[C (COND_JUMP, COND32)].rlx_length;
d2287 2
a2288 2
	  fragP->fr_subtype = C (COND_JUMP, COND12);
	  fragP->fr_var = md_relax_table[C (COND_JUMP, COND12)].rlx_length;
d2290 1
d2292 6
@


1.17
log
@2000-09-20  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-mcore.c: Fix formatting.
	* config/tc-mcore.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation.
@


1.17.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.17.2.2
log
@Merge from mainline.
@
text
@d95 6
a100 3
#define DISP12          1
#define DISP32          2
#define UNDEF_WORD_DISP 3
d117 15
a131 18
const relax_typeS md_relax_table[] = {
  {    0,     0, 0,	  0 },
  {    0,     0, 0,	  0 },
  {    0,     0, 0,	  0 },
  {    0,     0, 0,	  0 },

  /* COND_JUMP */
  {    0,     0, 0,	  0 },			  /* UNDEF_DISP */
  { 2048, -2046, C12_LEN, C(COND_JUMP, DISP32) }, /* DISP12 */
  {    0,     0, C32_LEN, 0 },			  /* DISP32 */
  {    0,     0, C32_LEN, 0 },			  /* UNDEF_WORD_DISP */

  /* UNCD_JUMP */
  {    0,     0, 0,	  0 },			  /* UNDEF_DISP */     
  { 2048, -2046, U12_LEN, C(UNCD_JUMP, DISP32) }, /* DISP12 */         
  {    0,     0, U32_LEN, 0 },			  /* DISP32 */         
  {    0,     0, U32_LEN, 0 }			  /* UNDEF_WORD_DISP */

d708 2
a709 2
			 md_relax_table[C (UNCD_JUMP, DISP32)].rlx_length,
			 md_relax_table[C (UNCD_JUMP, DISP12)].rlx_length,
d1561 2
a1562 2
			 md_relax_table[C (COND_JUMP, DISP32)].rlx_length,
			 md_relax_table[C (COND_JUMP, DISP12)].rlx_length,
d1572 2
a1573 2
			 md_relax_table[C (UNCD_JUMP, DISP32)].rlx_length,
			 md_relax_table[C (UNCD_JUMP, DISP12)].rlx_length,
d1907 2
a1908 2
    case C (COND_JUMP, DISP12):
    case C (UNCD_JUMP, DISP12):
d1938 1
d1942 1
a1942 1
    case C (COND_JUMP, DISP32):
d2029 2
d2034 1
a2034 1
    case C (UNCD_JUMP, DISP32):
d2085 2
a2249 3
    default:
      abort ();

d2254 2
a2255 1
	  fragP->fr_subtype = C (UNCD_JUMP, DISP12);
d2259 2
a2260 1
	  fragP->fr_subtype = C (UNCD_JUMP, DISP12);
d2265 2
d2270 3
d2280 2
a2281 1
	  fragP->fr_subtype = C (COND_JUMP, DISP12);
d2287 2
d2293 2
a2294 1
	  fragP->fr_subtype = C (COND_JUMP, DISP12);
a2295 1
      break;
a2296 8
    case C (UNCD_JUMP, DISP12):
    case C (UNCD_JUMP, DISP32):
    case C (UNCD_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP, DISP12):
    case C (COND_JUMP, DISP32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
d2300 1
a2300 1
  return md_relax_table[fragP->fr_subtype].rlx_length;
@


1.16
log
@is_end_of_line fixes.
@
text
@d119 5
a123 5
{    1,     1,	     0, 0 },			/* 0: unused */  
{    1,     1,	     0, 0 },			/* 1: unused */  
{    1,     1,	     0, 0 },			/* 2: unused */  
{    1,     1,	     0, 0 },			/* 3: unused */  
{    1,     1,	     0, 0 },			/* 4: unused */  
d126 2
a127 2
{    1,     1,	     0, 0 },			/* 7: unused */  
{    1,     1,	     0, 0 },			/* 8: unused */  
d130 2
a131 2
{    1,     1,	     0, 0 },			/*11: unused */  
{    0,     0,	     0, 0 }			/*12: unused */  
d219 1
a219 1
  
a230 1

d239 1
a239 1
      
d243 1
a243 1
      
d246 1
a246 1
  
d253 1
a253 1
     contents.  Instead we cross our fingers and pray... */
d268 1
a268 1
      
d280 1
a280 1
  
d295 1
a295 1
      
d308 1
a308 1
  
d330 1
a330 1
      
d334 1
a334 1
      
d347 1
a347 1
  
d360 1
a360 1
  
d373 1
a373 1
  
d415 1
a415 1
  
d425 1
a425 1
  
d472 1
a472 1
    
d485 1
a485 1
  
d493 1
a493 1
      
d507 1
a507 1
  
d545 1
a545 1
  
d553 1
a553 1
      
d559 1
a559 1
      
d565 1
a565 1
      
d572 1
a572 1
  
d579 1
a579 1
      
d581 1
a581 1
      
d584 1
a584 1
      
d591 1
a591 1
  
d593 1
a593 1
  
d616 1
a616 1
  
d619 1
a619 1
  
d625 1
a625 1
	  
d629 1
a629 1
  
d631 1
a631 1
  
d633 1
a633 1
  
d648 1
a648 1
  
d653 1
a653 1
  
d656 1
a656 1
  
d659 1
a659 1
  
d691 1
a691 1
  
d700 1
a700 1
      
d702 1
a702 1
      
d704 1
a704 1
      
d706 1
a706 1
      
d714 1
a714 1
      
d719 1
a719 1
  
d721 1
a721 1
  
d724 1
a724 1
  
d727 1
a727 1
  
d737 1
a737 1
    
d744 1
a744 1
    
d749 1
a749 1
    
d759 1
a759 1
  
d783 1
a783 1
         to 2 entries.  */ 
d792 1
a792 1
      
d798 1
a798 1
  
d815 1
a815 1
  
d818 1
a818 1
  return i;   
d833 1
a833 1
  
d837 1
a837 1
  
d841 1
a841 1
      
d850 1
a850 1
      
d852 1
a852 1
      
d861 1
a861 1
  
d879 1
a879 1
  
d881 1
a881 1
  
d891 1
a891 1
  
d905 1
a905 1
  
d908 1
a908 1
      
d915 1
a915 1
      
d919 1
a919 1
	  
d926 1
a926 1
		  
d933 1
a933 1
		  
d938 1
a938 1
      
d941 1
a941 1
      
d947 1
a947 1
  
d983 1
a983 1
  
d985 1
a985 1
  
d998 1
a998 1
  
d1001 1
a1001 1
  
d1007 1
a1007 1
      
d1013 1
a1013 1
      
d1019 1
a1019 1
      
d1025 1
a1025 1
         fixes problem of an interrupt during a jmp.. */
d1033 1
a1033 1
      
d1036 1
a1036 1
      
d1039 1
a1039 1
      
d1042 1
a1042 1
      
d1065 1
a1065 1
      
d1069 1
a1069 1
      
d1073 1
a1073 1
  
d1079 1
a1079 1
      
d1089 1
a1089 1
      /* drop through... */
d1093 1
a1093 1
      
d1097 1
a1097 1
  
d1105 1
a1105 1
      
d1108 1
a1108 1
      
d1111 1
a1111 1
      
d1115 1
a1115 1
  
d1120 1
a1120 1
	  
d1123 1
a1123 1
      
d1127 1
a1127 1
      
d1131 1
a1131 1
      
d1135 1
a1135 1
  
d1144 1
a1144 1
      
d1147 1
a1147 1
      
d1151 1
a1151 1
      
d1155 1
a1155 1
  
d1163 1
a1163 1
      
d1166 1
a1166 1
      
d1170 1
a1170 1
      
d1174 1
a1174 1
  
d1182 1
a1182 1
      
d1185 1
a1185 1
      
d1189 1
a1189 1
      
d1193 1
a1193 1
  
d1197 1
a1197 1
	  /* Further restrict the immediate to a power of two. */
d1209 1
a1209 1
      
d1212 2
a1213 2
      
    case OBRa:	/* Specific for bgeni: imm of 0->6 translate to movi. */
d1218 1
a1218 1
      
d1222 1
a1222 1
  
d1238 1
a1238 1
      
d1241 1
a1241 1
      
d1245 1
a1245 1
      
d1249 1
a1249 1
  
d1253 1
a1253 1
	  
d1262 2
a1263 2
	  
	  /* Immediate values of 0 -> 6 translate to movi. */
d1270 1
a1270 1
	  
d1275 1
a1275 1
      
d1278 1
a1278 1
      
d1284 1
a1284 1
      
d1288 1
a1288 1
  
d1292 2
a1293 2
	  
	  /* Immediate values of 1 -> 7 translate to movi. */
d1299 1
a1299 1
	      
d1310 1
a1310 1
      
d1313 1
a1313 1
      
d1317 1
a1317 1
      
d1321 1
a1321 1
  
d1329 1
a1329 1
      
d1336 1
a1336 1
      
d1340 1
a1340 1
  
d1348 1
a1348 1
      
d1351 1
a1351 1
      
d1355 1
a1355 1
      
d1359 1
a1359 1
  
d1363 1
a1363 1
	  
d1370 1
a1370 1
	  
d1372 1
a1372 1
	  
d1380 1
a1380 1
      
d1383 1
a1383 1
      
d1386 1
a1386 1
      
d1389 1
a1389 1
      
d1391 1
a1391 1
      
d1395 1
a1395 1
  
d1408 1
a1408 1
      
d1414 1
a1414 1
      
d1417 1
a1417 1
      
d1420 1
a1420 1
      
d1422 1
a1422 1
      
d1426 1
a1426 1
  
d1430 1
a1430 1
	  
d1433 1
a1433 1
	  
d1438 1
a1438 1
      
d1442 1
a1442 1
	  
d1446 1
a1446 1
  
d1450 1
a1450 1
	      
d1453 1
a1453 1
	      
d1462 1
a1462 1
      
d1465 1
a1465 1
      
d1468 1
a1468 1
      
d1471 1
a1471 1
      
d1475 1
a1475 1
  
d1479 1
a1479 1
	  
d1482 1
a1482 1
	  
d1486 1
a1486 1
  
d1490 1
a1490 1
	      
d1494 1
a1494 1
  
d1498 1
a1498 1
		  
d1501 1
a1501 1
		  
d1503 1
a1503 1
		  
d1507 1
a1507 1
		  
d1519 1
a1519 1
      
d1522 1
a1522 1
      
d1526 1
a1526 1
      
d1528 2
a1529 2
      
      fix_new_exp (frag_now, output-frag_now->fr_literal, 
d1532 1
a1532 1
      
d1536 1
a1536 1
      
d1540 1
a1540 1
  
d1545 2
a1546 2
	  
	  fix_new_exp (frag_now, output-frag_now->fr_literal, 
d1555 1
a1555 1
      
d1559 1
a1559 1
      
d1566 1
a1566 1
      
d1577 1
a1577 1
      
d1583 2
a1584 2
      
      /* Only do this if we know how to do it ... */
d1588 1
a1588 1
	  fix_new_exp (frag_now, output-frag_now->fr_literal, 
d1596 1
a1596 1
      
d1600 1
a1600 1
  
d1604 1
a1604 1
	  
d1610 1
a1610 1
      
d1613 1
a1613 1
      
d1618 1
a1618 1
      
d1622 1
a1622 1
  
d1626 1
a1626 1
	  
d1632 1
a1632 1
      
d1635 1
a1635 1
      
d1639 1
a1639 1
      
d1643 1
a1643 1
  
d1650 1
a1650 1
	  
d1655 1
a1655 1
      
d1665 1
a1665 1
      
d1667 1
a1667 1
      
d1672 1
a1672 1
	    
d1674 1
a1674 1
	  
d1677 1
a1677 1
	  
d1680 1
a1680 1
      
d1683 1
a1683 1
	
d1687 1
a1687 1
 
d1696 1
a1696 1
  /* Give warning message if the insn has more operands than required. */
d1699 1
a1699 1
  
d1702 1
a1702 1
  
d1769 1
a1769 1
  
d1771 1
a1771 1
  
d1776 1
a1776 1
  
d1793 1
a1793 1
  
d1842 1
a1842 1
      
d1901 1
a1901 1
  
d1914 1
a1914 1
	
d1917 1
a1917 1
	
d1919 1
a1919 1
	
d1923 1
a1923 1
	
d1925 1
a1925 1
	
d1931 1
a1931 1
	
d1933 1
a1933 1
	
d1936 1
a1936 1
	
d1965 1
a1965 1
 
d1978 1
a1978 1
	    
d1985 1
a1985 1
	    
d1989 1
a1989 1
	    
d1997 1
a1997 1
	       for this fragment. */
d2008 1
a2008 1
	    
d2013 1
a2013 1
	    
d2021 1
a2021 1
	       the branch displacement so that it goes beyond the 
d2029 1
a2029 1
	
d2062 1
a2062 1
	    
d2066 1
a2066 1
	    
d2079 1
a2079 1
	    
d2107 2
a2108 2
  offsetT      val  = (offsetT) * valp; 
  
d2129 1
a2129 1
  
d2179 1
a2179 1
      /* If its a local target and close enough, fix it. 
d2185 1
a2185 1
	  
d2199 1
a2199 1
      
d2207 1
a2207 1
#ifdef OBJ_ELF      
d2272 1
a2272 1
      
d2274 1
a2274 1
      /* Used to be a branch to somewhere which was unknown. */
d2299 1
a2299 1
  
a2338 1

d2349 1
a2349 1
     Only account for the PC pre-bump (which is 2 bytes on the MCore). */
d2353 1
a2353 1
      
d2360 1
a2360 1
  /* The case where we are going to resolve things... */
d2378 1
a2378 1
      /* These confuse the size/pcrel macro approach. */
d2385 1
a2385 1
    case BFD_RELOC_RVA:      
d2388 1
a2388 1
    
d2415 1
a2415 1
  
d2421 1
a2421 1
      
d2454 1
a2454 1
  
@


1.15
log
@Fix little endian relocs
@
text
@d242 1
a242 1
      while (! is_end_of_line [* ptr])
d271 1
a271 1
      while (! is_end_of_line [* ptr])
d304 1
a304 1
      while (! is_end_of_line [* ptr])
d978 1
a978 1
       * op_end && nlen < 20 && !is_end_of_line [*op_end] && *op_end != ' ';
@


1.14
log
@Add support for M340
@
text
@d77 1
a77 1
static int do_jsri2bsr = 0;	/* change here from 1 by Cruess 19 August 97 */
d82 3
a84 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d116 1
a116 1
/* Initialize the relax table */
d134 1
a134 1
/* LITERAL POOL DATA STRUCTURES */
d161 1
a161 1
#define SPANPANIC	(1016)		/* 1024 - 1 entry - 2 byte rounding */
d164 1
a164 1
static symbolS * poolsym;		/* label for current pool */
d166 1
a166 1
static struct hash_control * opcode_hash_control;	/* Opcode mnemonics */
d172 1
a172 1
     Integer arg to pass to the function   */
d2149 2
a2150 2
	  buf[0] |= ((val >> 8) & 0x7);
	  buf[1] |= (val & 0xff);
@


1.13
log
@Cathc unwanted text after instructions
@
text
@d51 1
d68 2
a69 2
#define	INST_BYTE0(x)  (((x) >> 8) & 0xFF)
#define	INST_BYTE1(x)  ((x) & 0xFF)
d107 8
d599 40
d1084 7
d1660 29
d1778 10
d1804 3
d1814 3
d1832 11
d1844 2
d1863 4
a1866 1
  -{no-}sifilter	  {dis}able silicon filter behavior (def: dis)"));
d1920 10
d1959 3
d1969 6
d1999 6
d2025 3
d2053 3
d2072 3
d2142 7
d2151 1
d2161 2
d2172 3
d2311 10
@


1.12
log
@Fix generation of RVA relocs
@
text
@d2 1
a2 1
   Copyright (C) 1999 Free Software Foundation.
d1342 5
a1346 2
	/* parse_rt calls frag_more() for us.  */
	input_line_pointer = parse_rt (op_end + 1, & output, 0, 0);
d1357 1
d1470 1
d1503 1
d1514 2
d1527 1
d1607 8
d1991 2
a1992 2
        buf[0] |= ((val >> 8) & 0x7);
        buf[1] |= (val & 0xff);
d2011 1
a2011 1
        buf[1] |= (val & 0xf);
d2268 1
a2268 1
      || fixP->fx_r_type == BFD_RELOC_RVA)
@


1.11
log
@revert part of previous delta which had accidentally snarfed some experimental
code.
@
text
@d2196 1
d2250 2
a2251 1
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
@


1.10
log
@revert previous delta
@
text
@a337 2
      
      check_literals (1, 0);
d342 1
a342 1
  check_literals (1, 0);
d714 1
a714 1
  else if (/* poolspan > SPANEXIT &&*/ kind > 1)
@


1.9
log
@Apply patch supplied for case 102229 to implement new insns psrclr and psrset.
@
text
@a50 1
static char * parse_psrmod PARAMS ((char *, unsigned *));
a591 40
parse_psrmod (s, reg)
  char *     s;
  unsigned * reg;
{
  int  i;
  char buf[10];
  static struct psrmods
  {
    char *       name;
    unsigned int value;
  }
  psrmods[] =
  {
    { "ie", 1 },
    { "fe", 2 },
    { "ee", 4 },
    { "af", 8 }	/* really 0 and non-combinable */
  };
  
  for (i = 0; i < 2; i++)
    buf[i] = isascii (s[i]) ? tolower (s[i]) : 0;
  
  for (i = sizeof (psrmods) / sizeof (psrmods[0]); i--;)
    {
      if (! strncmp (psrmods[i].name, buf, 2))
	{
          * reg = psrmods[i].value;
	  
          return s + 2;
	}
    }
  
  as_bad (_("bad/missing psr specifier"));
  
  * reg = 0;
  
  return s;
}

static char *
a1596 23
    case OPSR:
      op_end = parse_psrmod (op_end + 1, & reg);
      
      /* Look for further selectors.  */
      while (* op_end == ',')
	{
	  unsigned value;
	    
	  op_end = parse_psrmod (op_end + 1, & value);
	  
	  if (value & reg)
	    as_bad (_("duplicated psr bit specifier"));
	  
	  reg |= value;
	}
      
      if (reg > 8)
	as_bad (_("`af' must appear alone"));
	
      inst |= (reg & 0x7);
      output = frag_more (2);
      break;
 
@


1.8
log
@Do not dump literal pool when a .section .line directive is encountered.
@
text
@d45 7
a51 3
static char * parse_reg PARAMS ((char *, unsigned *));
static char * parse_creg PARAMS ((char *, unsigned *));
static char * parse_exp PARAMS ((char *, expressionS *));
a53 3
static char * parse_rt PARAMS ((char *, char **, int, expressionS *));
static char * parse_imm PARAMS ((char *, unsigned *, unsigned, unsigned));
static char * parse_mem PARAMS ((char *, unsigned *, unsigned *, unsigned));
a63 1

d339 2
d345 1
a345 1
  check_literals (2, 0);
a349 1

d593 40
d757 1
a757 1
  else if (poolspan > SPANEXIT && kind > 1)
d1638 23
@


1.7
log
@fix FSF address
@
text
@d43 1
d182 1
a182 1
  { "dc.d",     mcore_float_cons,    'd' },
d184 1
a184 1
  { "dc.s",     mcore_float_cons,    'f' },
d186 1
a186 1
  { "dc.x",     mcore_float_cons,    'x' },
d198 1
d312 34
d379 16
a394 1
  dump_literals (0);
d425 1
a425 1
  set up all the tables, etc that the MD part of the assembler needs.  */
d1520 1
a1520 1
      /* parse_rt() calls frag_more for us */
d1779 1
a1779 1
	/* Get the address of the end of the instruction */
d1901 1
a1901 1
	    /* Make reloc for the long disp */
d1915 1
a1915 1
	    /* Make reloc for the long disp */
d2125 1
a2125 1
/* Put number into target byte order */
@


1.6
log
@Make the mcore even more paranoid about section switching
@
text
@d17 3
a19 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
@


1.5
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d55 2
d58 1
a58 1
static void   mcore_s_section PARAMS ((int));
d61 1
a168 1
  { "bss",      s_lcomm_bytes,    1 },
d200 4
a203 2
  
#ifdef OBJ_ELF
d208 1
a208 1
#endif  
d309 3
d318 3
d322 1
d331 3
d335 15
d352 20
a2219 11
}

/* Handle the .section pseudo-op.  This is like the usual one, but it
   dumps the literal pool before changing the section.  */
static void
mcore_s_section (ignore)
     int ignore;
{
  dump_literals (0);

  obj_elf_section (ignore);
@


1.4
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d1671 1
a1671 1
  targ_addr += fragP->fr_symbol->sy_frag->fr_address;
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d2 1
a2 2

   Copyright (C) 1993,1994, 1999 Free Software Foundation.
d2119 2
a2120 1
  rel->sym_ptr_ptr = & fixp->fx_addsy->bsym;
@


1.2
log
@Accept 'sp' as a valid register	name.
@
text
@d544 1
a544 1
  struct symbol * brarsym;
@


1.1
log
@Initial revision
@
text
@d64 2
a65 2
#define	INST_BYTE0(x)	(((x) >> 8) & 0xFF)
#define	INST_BYTE1(x)	((x) & 0xFF)
a72 1
static int relax;		/* set if -relax seen */
d396 1
a396 1
	   && (isspace (s[2]) || s[2] == ','))
d535 3
d555 1
a555 1
      make_name (brarname, ".YP.", poolnumber);
d647 1
a647 1
      make_name (poolname, ".XP.", poolnumber);
d882 2
a883 2
	  output[0] = (inst >> 8);
	  output[1] = (inst);
d901 2
a902 2
	  output[0] = (inst >> 8);
	  output[1] = (inst);
d908 2
a909 2
	  output[0] = (inst >> 8);
	  output[1] = (inst);
d913 2
a914 2
	  output[0] = (inst >> 8);
	  output[1] = (inst);
d1501 2
a1502 2
  output[0] = inst >> 8;
  output[1] = inst;
d1536 1
a1536 1
  LITTLENUM_TYPE * wordP;
d1578 6
a1583 5
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
d1590 4
a1593 5
#define OPTION_RELAX		(OPTION_MD_BASE)
#define OPTION_JSRI2BSR_ON	(OPTION_MD_BASE + 1)
#define OPTION_JSRI2BSR_OFF	(OPTION_MD_BASE + 2)
#define OPTION_SIFILTER_ON	(OPTION_MD_BASE + 3)
#define OPTION_SIFILTER_OFF	(OPTION_MD_BASE + 4)
a1596 1
  { "relax",       no_argument, NULL, OPTION_RELAX},
a1616 1
    case OPTION_RELAX:        relax = 1;         break;
d1633 2
a1634 3
  -{no-}jsri2bsr	  {dis}able jsri to bsr transformation (def: off)\n\
  -{no-}sifilter	  {dis}able silicon filter behavior (def: off)\n\
  -relax		  alter jump instructions for long displacements\n"));
d1685 1
a1685 1
	    as_bad (_("odd displacement at %x"), next_inst - 2);
d1688 2
a1689 1
	t0 = buffer[0] & 0xF8;
d1691 4
a1694 1
	md_number_to_chars (buffer, disp, 2);
a1695 1
	buffer[0] = (buffer[0] & 0x07) | t0;
d1717 1
a1717 1
	buffer[0] ^= 0x08;	/* Toggle T/F bit */
d1724 5
a1728 2
	    buffer[1] = 4;	/* branch over jmpi, pad, and ptr */
	    buffer[3] = 1;	/* jmpi offset of 1 gets the pointer */
d1748 5
a1752 2
	    buffer[1] = 3;	/* branch over jmpi, and ptr */
	    buffer[3] = 0;	/* jmpi offset of 0 gets the pointer */
d1763 2
a1764 2
	    /* frag is actually shorter (see the other side of this ifdef)
	       but gas isn't prepared for that. We have to re-adjust
d1768 1
a1768 1
	    buffer[1] = 4;	/* jmpi, ptr, and the 'tail pad' */
d1793 1
a1793 1
	    buffer[1] = 1;	/* jmpi offset of 1 since padded */
d1809 1
a1809 1
	    buffer[1] = 0;	/* jmpi offset of 0 if no pad */
d1876 3
a1878 3
      buf[0] |= ((val >> 8) & 0x7);
      buf[1] |= (val & 0xff);
        break;
d1889 1
a1889 1
        break;
d1896 1
a1896 1
      buf[1] |= (val & 0xf);
d1909 2
a1910 2
	  buf[0] = ((nval >> 8) & 0xff);
	  buf[1] = (nval & 0xff);
d1934 1
a1934 6
	    {
	      *buf++ = val >> 24;
	      *buf++ = val >> 16;
	      *buf++ = val >> 8;
	      *buf = val;
	    }
d1936 1
a1936 4
	    {
	      *buf++ = val >> 8;
	      *buf = val;
	    }
d1938 1
a1938 1
	    *buf = val;
d1941 1
a2025 1

d2032 8
a2039 8
  switch (nbytes)
    {
    case 4: *ptr++ = (use >> 24) & 0xff; /* fall through */
    case 3: *ptr++ = (use >> 16) & 0xff; /* fall through */
    case 2: *ptr++ = (use >>  8) & 0xff; /* fall through */
    case 1: *ptr++ = (use >>  0) & 0xff;    break;
    default: abort ();
    }
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

