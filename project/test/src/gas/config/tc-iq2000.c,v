head	1.18;
access;
symbols
	binutils-2_24-branch:1.18.0.10
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.18
	binutils-2_23_2:1.18
	binutils-2_23_1:1.18
	binutils-2_23:1.18
	binutils-2_23-branch:1.18.0.8
	binutils-2_23-branchpoint:1.18
	binutils-2_22_branch:1.18.0.6
	binutils-2_22:1.18
	binutils-2_22-branch:1.18.0.4
	binutils-2_22-branchpoint:1.18
	binutils-2_21:1.18
	binutils-2_21-branch:1.18.0.2
	binutils-2_21-branchpoint:1.18
	binutils-2_20_1:1.17
	binutils-2_20:1.17
	binutils-arc-20081103-branch:1.15.0.6
	binutils-arc-20081103-branchpoint:1.15
	binutils-2_20-branch:1.17.0.2
	binutils-2_20-branchpoint:1.17
	dje-cgen-play1-branch:1.16.0.2
	dje-cgen-play1-branchpoint:1.16
	arc-20081103-branch:1.15.0.4
	arc-20081103-branchpoint:1.15
	binutils-2_19_1:1.15
	binutils-2_19:1.15
	binutils-2_19-branch:1.15.0.2
	binutils-2_19-branchpoint:1.15
	binutils-2_18:1.14
	binutils-2_18-branch:1.14.0.2
	binutils-2_18-branchpoint:1.14
	binutils-csl-coldfire-4_1-32:1.11
	binutils-csl-sourcerygxx-4_1-32:1.11
	binutils-csl-innovasic-fido-3_4_4-33:1.11
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.11
	binutils-csl-sourcerygxx-4_1-30:1.11
	binutils-csl-coldfire-4_1-28:1.11
	binutils-csl-sourcerygxx-4_1-29:1.11
	binutils-csl-sourcerygxx-4_1-28:1.11
	binutils-csl-arm-2006q3-27:1.11
	binutils-csl-sourcerygxx-4_1-27:1.11
	binutils-csl-arm-2006q3-26:1.11
	binutils-csl-sourcerygxx-4_1-26:1.11
	binutils-csl-sourcerygxx-4_1-25:1.11
	binutils-csl-sourcerygxx-4_1-24:1.11
	binutils-csl-sourcerygxx-4_1-23:1.11
	binutils-csl-sourcerygxx-4_1-21:1.11
	binutils-csl-arm-2006q3-21:1.11
	binutils-csl-sourcerygxx-4_1-22:1.11
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.11
	binutils-csl-sourcerygxx-4_1-20:1.11
	binutils-csl-arm-2006q3-19:1.11
	binutils-csl-sourcerygxx-4_1-19:1.11
	binutils-csl-sourcerygxx-4_1-18:1.11
	binutils-csl-renesas-4_1-9:1.11
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	binutils-csl-renesas-4_1-8:1.11
	binutils-csl-renesas-4_1-7:1.11
	binutils-csl-renesas-4_1-6:1.11
	binutils-csl-sourcerygxx-4_1-17:1.11
	binutils-csl-sourcerygxx-4_1-14:1.11
	binutils-csl-sourcerygxx-4_1-15:1.11
	binutils-csl-sourcerygxx-4_1-13:1.11
	binutils-2_17:1.11
	binutils-csl-sourcerygxx-4_1-12:1.11
	binutils-csl-sourcerygxx-3_4_4-21:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	binutils-csl-sourcerygxx-4_1-9:1.11
	binutils-csl-sourcerygxx-4_1-8:1.11
	binutils-csl-sourcerygxx-4_1-7:1.11
	binutils-csl-arm-2006q1-6:1.11
	binutils-csl-sourcerygxx-4_1-6:1.11
	binutils-csl-wrs-linux-3_4_4-22:1.8
	binutils-csl-coldfire-4_1-11:1.11
	binutils-csl-sourcerygxx-3_4_4-19:1.11
	binutils-csl-coldfire-4_1-10:1.11
	binutils-csl-sourcerygxx-4_1-5:1.11
	binutils-csl-sourcerygxx-4_1-4:1.11
	binutils-csl-wrs-linux-3_4_4-21:1.8
	binutils-csl-morpho-4_1-4:1.11
	binutils-csl-sourcerygxx-3_4_4-17:1.11
	binutils-csl-wrs-linux-3_4_4-20:1.8
	binutils-2_17-branch:1.11.0.4
	binutils-2_17-branchpoint:1.11
	binutils-csl-2_17-branch:1.11.0.2
	binutils-csl-2_17-branchpoint:1.11
	binutils-csl-gxxpro-3_4-branch:1.8.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	binutils-csl-arm-2005q1a:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.4
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.2
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.4
	csl-arm-2004-q3:1.4
	binutils-2_15:1.3.6.1
	binutils-2_15-branchpoint:1.3
	csl-arm-2004-q1a:1.4
	csl-arm-2004-q1:1.4
	binutils-2_15-branch:1.3.0.6
	cagney_bfdfile-20040213-branch:1.3.0.4
	cagney_bfdfile-20040213-branchpoint:1.3
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3
	csl-arm-2003-q4:1.3
	binutils-2_14:1.1
	binutils-2_14-branch:1.1.0.2
	binutils-2_14-branchpoint:1.1
	binutils_latest_snapshot:1.18;
locks; strict;
comment	@ * @;


1.18
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.09.03.42.25;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.05.09.12.58;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.20.17.40.01;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.03.13.03.48;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.03.11.47.52;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.12.10.57.15;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.24.13.23.41;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.26.14.12.26;	author fnf;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.20.01.36.49;	author kazu;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.03.21.47.21;	author scox;	state Exp;
branches;
next	;

1.3.6.1
date	2004.04.09.18.28.12;	author drow;	state Exp;
branches;
next	;


desc
@@


1.18
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@/* tc-iq2000.c -- Assembler for the Sitera IQ2000.
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009, 2010
   Free Software Foundation. Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "symcat.h"
#include "opcodes/iq2000-desc.h"
#include "opcodes/iq2000-opc.h"
#include "cgen.h"
#include "elf/common.h"
#include "elf/iq2000.h"
#include "libbfd.h"
#include "sb.h"
#include "macro.h"

/* Structure to hold all of the different components describing
   an individual instruction.  */
typedef struct
{
  const CGEN_INSN *	insn;
  const CGEN_INSN *	orig_insn;
  CGEN_FIELDS		fields;
#if CGEN_INT_INSN_P
  CGEN_INSN_INT         buffer [1];
#define INSN_VALUE(buf) (*(buf))
#else
  unsigned char         buffer [CGEN_MAX_INSN_SIZE];
#define INSN_VALUE(buf) (buf)
#endif
  char *		addr;
  fragS *		frag;
  int                   num_fixups;
  fixS *                fixups [GAS_CGEN_MAX_FIXUPS];
  int                   indices [MAX_OPERAND_INSTANCES];
}
iq2000_insn;

const char comment_chars[]        = "#";
const char line_comment_chars[]   = "#";
const char line_separator_chars[] = ";";
const char EXP_CHARS[]            = "eE";
const char FLT_CHARS[]            = "dD";

/* Default machine.  */
#define DEFAULT_MACHINE bfd_mach_iq2000
#define DEFAULT_FLAGS	EF_IQ2000_CPU_IQ2000

static unsigned long iq2000_mach = bfd_mach_iq2000;
static int cpu_mach = (1 << MACH_IQ2000);

/* Flags to set in the elf header.  */
static flagword iq2000_flags = DEFAULT_FLAGS;

typedef struct proc
{
  symbolS *isym;
  unsigned long reg_mask;
  unsigned long reg_offset;
  unsigned long fpreg_mask;
  unsigned long fpreg_offset;
  unsigned long frame_offset;
  unsigned long frame_reg;
  unsigned long pc_reg;
} procS;

static procS cur_proc;
static procS *cur_proc_ptr;
static int numprocs;

/* Relocations against symbols are done in two
   parts, with a HI relocation and a LO relocation.  Each relocation
   has only 16 bits of space to store an addend.  This means that in
   order for the linker to handle carries correctly, it must be able
   to locate both the HI and the LO relocation.  This means that the
   relocations must appear in order in the relocation table.

   In order to implement this, we keep track of each unmatched HI
   relocation.  We then sort them so that they immediately precede the
   corresponding LO relocation.  */

struct iq2000_hi_fixup
{
  struct iq2000_hi_fixup * next;  /* Next HI fixup.  */
  fixS *                  fixp;   /* This fixup.  */
  segT                    seg;    /* The section this fixup is in.  */
};

/* The list of unmatched HI relocs.  */
static struct iq2000_hi_fixup * iq2000_hi_fixup_list;

/* Macro hash table, which we will add to.  */
extern struct hash_control *macro_hash;

const char *md_shortopts = "";
struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c ATTRIBUTE_UNUSED,
		 char * arg ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_show_usage (FILE * stream ATTRIBUTE_UNUSED)
{
}

/* Automatically enter conditional branch macros.  */

typedef struct
{
  const char * mnemonic;
  const char ** expansion;
  const char ** args;
} iq2000_macro_defs_s;

static const char * abs_args[] = { "rd", "rs", "scratch=%1", NULL };
static const char * abs_expn   = "\n sra \\rd,\\rs,31\n xor \\scratch,\\rd,\\rs\n sub \\rd,\\scratch,\\rd\n";
static const char * la_expn    = "\n lui \\reg,%hi(\\label)\n ori \\reg,\\reg,%lo(\\label)\n";
static const char * la_args[]  = { "reg", "label", NULL };
static const char * bxx_args[] = { "rs", "rt", "label", "scratch=%1", NULL };
static const char * bge_expn   = "\n slt \\scratch,\\rs,\\rt\n beq %0,\\scratch,\\label\n";
static const char * bgeu_expn  = "\n sltu \\scratch,\\rs,\\rt\n beq %0,\\scratch,\\label\n";
static const char * bgt_expn   = "\n slt \\scratch,\\rt,\\rs\n bne %0,\\scratch,\\label\n";
static const char * bgtu_expn  = "\n sltu \\scratch,\\rt,\\rs\n bne %0,\\scratch,\\label\n";
static const char * ble_expn   = "\n slt \\scratch,\\rt,\\rs\n beq %0,\\scratch,\\label\n";
static const char * bleu_expn  = "\n sltu \\scratch,\\rt,\\rs\n beq %0,\\scratch,\\label\n";
static const char * blt_expn   = "\n slt \\scratch,\\rs,\\rt\n bne %0,\\scratch,\\label\n";
static const char * bltu_expn  = "\n sltu \\scratch,\\rs,\\rt\n bne %0,\\scratch,\\label\n";
static const char * sxx_args[] = { "rd", "rs", "rt", NULL };
static const char * sge_expn   = "\n slt \\rd,\\rs,\\rt\n xori \\rd,\\rd,1\n";
static const char * sgeu_expn  = "\n sltu \\rd,\\rs,\\rt\n xori \\rd,\\rd,1\n";
static const char * sle_expn   = "\n slt \\rd,\\rt,\\rs\n xori \\rd,\\rd,1\n";
static const char * sleu_expn  = "\n sltu \\rd,\\rt,\\rs\n xori \\rd,\\rd,1\n";
static const char * sgt_expn   = "\n slt \\rd,\\rt,\\rs\n";
static const char * sgtu_expn  = "\n sltu \\rd,\\rt,\\rs\n";
static const char * sne_expn   = "\n xor \\rd,\\rt,\\rs\n sltu \\rd,%0,\\rd\n";
static const char * seq_expn   = "\n xor \\rd,\\rt,\\rs\n sltu \\rd,%0,\\rd\n xori \\rd,\\rd,1\n";
static const char * ai32_args[] = { "rt", "rs", "imm", NULL };
static const char * andi32_expn = "\n\
 .if (\\imm & 0xffff0000 == 0xffff0000)\n\
 andoi \\rt,\\rs,%lo(\\imm)\n\
 .elseif (\\imm & 0x0000ffff == 0x0000ffff)\n\
 andoui \\rt,\\rs,%uhi(\\imm)\n\
 .elseif (\\imm & 0xffff0000 == 0x00000000)\n\
 andi \\rt,\\rs,%lo(\\imm)\n\
 .else\n\
 andoui \\rt,\\rs,%uhi(\\imm)\n\
 andoi \\rt,\\rt,%lo(\\imm)\n\
 .endif\n";
static const char * ori32_expn  = "\n\
 .if (\\imm & 0xffff == 0)\n\
 orui \\rt,\\rs,%uhi(\\imm)\n\
 .elseif (\\imm & 0xffff0000 == 0)\n\
 ori \\rt,\\rs,%lo(\\imm)\n\
 .else\n\
 orui \\rt,\\rs,%uhi(\\imm)\n\
 ori \\rt,\\rt,%lo(\\imm)\n\
 .endif\n";

static const char * neg_args[] = { "rd", "rs", NULL };
static const char * neg_expn   = "\n sub \\rd,%0,\\rs\n";
static const char * negu_expn  = "\n subu \\rd,%0,\\rs\n";
static const char * li_args[]  = { "rt", "imm", NULL };
static const char * li_expn    = "\n\
 .if (\\imm & 0xffff0000 == 0x0)\n\
 ori \\rt,%0,\\imm\n\
 .elseif (\\imm & 0xffff0000 == 0xffff0000)\n\
 addi \\rt,%0,\\imm\n\
 .elseif (\\imm & 0x0000ffff == 0)\n\
 lui \\rt,%uhi(\\imm)\n\
 .else\n\
 lui \\rt,%uhi(\\imm)\n\
 ori \\rt,\\rt,%lo(\\imm)\n\
 .endif\n";

static iq2000_macro_defs_s iq2000_macro_defs[] =
{
  {"abs",   (const char **) & abs_expn,   (const char **) & abs_args},
  {"la",    (const char **) & la_expn,    (const char **) & la_args},
  {"bge",   (const char **) & bge_expn,   (const char **) & bxx_args},
  {"bgeu",  (const char **) & bgeu_expn,  (const char **) & bxx_args},
  {"bgt",   (const char **) & bgt_expn,   (const char **) & bxx_args},
  {"bgtu",  (const char **) & bgtu_expn,  (const char **) & bxx_args},
  {"ble",   (const char **) & ble_expn,   (const char **) & bxx_args},
  {"bleu",  (const char **) & bleu_expn,  (const char **) & bxx_args},
  {"blt",   (const char **) & blt_expn,   (const char **) & bxx_args},
  {"bltu",  (const char **) & bltu_expn,  (const char **) & bxx_args},
  {"sge",   (const char **) & sge_expn,   (const char **) & sxx_args},
  {"sgeu",  (const char **) & sgeu_expn,  (const char **) & sxx_args},
  {"sle",   (const char **) & sle_expn,   (const char **) & sxx_args},
  {"sleu",  (const char **) & sleu_expn,  (const char **) & sxx_args},
  {"sgt",   (const char **) & sgt_expn,   (const char **) & sxx_args},
  {"sgtu",  (const char **) & sgtu_expn,  (const char **) & sxx_args},
  {"seq",   (const char **) & seq_expn,   (const char **) & sxx_args},
  {"sne",   (const char **) & sne_expn,   (const char **) & sxx_args},
  {"neg",   (const char **) & neg_expn,   (const char **) & neg_args},
  {"negu",  (const char **) & negu_expn,  (const char **) & neg_args},
  {"li",    (const char **) & li_expn,    (const char **) & li_args},
  {"ori32", (const char **) & ori32_expn, (const char **) & ai32_args},
  {"andi32",(const char **) & andi32_expn,(const char **) & ai32_args},
};

static void
iq2000_add_macro (const char *  name,
		  const char *  semantics,
		  const char ** arguments)
{
  macro_entry *macro;
  sb macro_name;
  const char *namestr;

  macro = xmalloc (sizeof (macro_entry));
  sb_new (& macro->sub);
  sb_new (& macro_name);

  macro->formal_count = 0;
  macro->formals = 0;

  sb_add_string (& macro->sub, semantics);

  if (arguments != NULL)
    {
      formal_entry ** p = &macro->formals;

      macro->formal_count = 0;
      macro->formal_hash = hash_new ();

      while (*arguments != NULL)
	{
	  formal_entry *formal;

	  formal = xmalloc (sizeof (formal_entry));

	  sb_new (& formal->name);
	  sb_new (& formal->def);
	  sb_new (& formal->actual);

	  /* chlm: Added the following to allow defaulted args.  */
	  if (strchr (*arguments,'='))
	    {
	      char * tt_args = strdup (*arguments);
	      char * tt_dflt = strchr (tt_args,'=');

	      *tt_dflt = 0;
	      sb_add_string (& formal->name, tt_args);
	      sb_add_string (& formal->def,  tt_dflt + 1);
	    }
	  else
	    sb_add_string (& formal->name, *arguments);

	  /* Add to macro's hash table.  */
	  hash_jam (macro->formal_hash, sb_terminate (& formal->name), formal);

	  formal->index = macro->formal_count;
	  macro->formal_count++;
	  *p = formal;
	  p = & formal->next;
	  *p = NULL;
	  ++arguments;
	}
    }

  sb_add_string (&macro_name, name);
  namestr = sb_terminate (&macro_name);
  hash_jam (macro_hash, namestr, macro);

  macro_defined = 1;
}

static void
iq2000_load_macros (void)
{
  int i;
  int mcnt = ARRAY_SIZE (iq2000_macro_defs);

  for (i = 0; i < mcnt; i++)
    iq2000_add_macro (iq2000_macro_defs[i].mnemonic,
    		      *iq2000_macro_defs[i].expansion,
		      iq2000_macro_defs[i].args);
}

void
md_begin (void)
{
  /* Initialize the `cgen' interface.  */

  /* Set the machine number and endian.  */
  gas_cgen_cpu_desc = iq2000_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, cpu_mach,
					   CGEN_CPU_OPEN_ENDIAN,
					   CGEN_ENDIAN_BIG,
					   CGEN_CPU_OPEN_END);
  iq2000_cgen_init_asm (gas_cgen_cpu_desc);

  /* This is a callback from cgen to gas to parse operands.  */
  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);

  /* Set the ELF flags if desired.  */
  if (iq2000_flags)
    bfd_set_private_flags (stdoutput, iq2000_flags);

  /* Set the machine type */
  bfd_default_set_arch_mach (stdoutput, bfd_arch_iq2000, iq2000_mach);

  iq2000_load_macros ();
}

void
md_assemble (char * str)
{
  static long delayed_load_register = 0;
  static int last_insn_had_delay_slot = 0;
  static int last_insn_has_load_delay = 0;
  static int last_insn_unconditional_jump = 0;
  static int last_insn_was_ldw = 0;

  iq2000_insn insn;
  char * errmsg;

  /* Initialize GAS's cgen interface for a new instruction.  */
  gas_cgen_init_parse ();

  insn.insn = iq2000_cgen_assemble_insn
      (gas_cgen_cpu_desc, str, & insn.fields, insn.buffer, & errmsg);

  if (!insn.insn)
    {
      as_bad ("%s", errmsg);
      return;
    }

  /* Doesn't really matter what we pass for RELAX_P here.  */
  gas_cgen_finish_insn (insn.insn, insn.buffer,
			CGEN_FIELDS_BITSIZE (& insn.fields), 1, NULL);

  /* We need to generate an error if there's a yielding instruction in the delay
     slot of a control flow modifying instruction (jump (yes), load (no))  */
  if ((last_insn_had_delay_slot && !last_insn_has_load_delay) &&
      CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_YIELD_INSN))
      as_bad (_("the yielding instruction %s may not be in a delay slot."),
              CGEN_INSN_NAME (insn.insn));

  /* Warn about odd numbered base registers for paired-register
     instructions like LDW.  On iq2000, result is always rt.  */
  if (iq2000_mach == bfd_mach_iq2000
      && CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_EVEN_REG_NUM)
      && (insn.fields.f_rt % 2))
    as_bad (_("Register number (R%ld) for double word access must be even."),
	    insn.fields.f_rt);

  /* Warn about insns that reference the target of a previous load.  */
  /* NOTE: R0 is a special case and is not subject to load delays (except for ldw).  */
  if (delayed_load_register && (last_insn_has_load_delay || last_insn_was_ldw))
    {
      if (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RD) &&
	  insn.fields.f_rd == delayed_load_register)
	as_warn (_("operand references R%ld of previous load."),
		 insn.fields.f_rd);

      if (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RS) &&
	  insn.fields.f_rs == delayed_load_register)
	as_warn (_("operand references R%ld of previous load."),
		 insn.fields.f_rs);

      if (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RT) &&
	  insn.fields.f_rt == delayed_load_register)
	as_warn (_("operand references R%ld of previous load."),
		 insn.fields.f_rt);

      if (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_R31) &&
	  delayed_load_register == 31)
	as_warn (_("instruction implicitly accesses R31 of previous load."));
    }

  /* Warn about insns that reference the (target + 1) of a previous ldw.  */
  if (last_insn_was_ldw)
    {
      if ((CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RD)
           && insn.fields.f_rd == delayed_load_register + 1)
       || (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RS)
           && insn.fields.f_rs == delayed_load_register + 1)
       || (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RT)
           && insn.fields.f_rt == delayed_load_register + 1))
        as_warn (_("operand references R%ld of previous load."),
                delayed_load_register + 1);
    }

  last_insn_had_delay_slot =
    CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_DELAY_SLOT);

  last_insn_has_load_delay =
    CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_LOAD_DELAY);

  if (last_insn_unconditional_jump)
    last_insn_has_load_delay = last_insn_unconditional_jump = 0;
  else if (! strcmp (CGEN_INSN_MNEMONIC (insn.insn), "j")
	   || ! strcmp (CGEN_INSN_MNEMONIC (insn.insn), "jal"))
	   last_insn_unconditional_jump = 1;

  /* The meaning of EVEN_REG_NUM was overloaded to also imply LDW.  Since
     that's not true for IQ10, let's make the above logic specific to LDW.  */
  last_insn_was_ldw = ! strcmp ("ldw", CGEN_INSN_NAME (insn.insn));

  /* The assumption here is that the target of a load is always rt.  */
  delayed_load_register = insn.fields.f_rt;
}

valueT
md_section_align (segT segment, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}

symbolS *
md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
{
    return 0;
}

/* Interface to relax_segment.  */

/* Return an initial guess of the length by which a fragment must grow to
   hold a branch to reach its destination.
   Also updates fr_type/fr_subtype as necessary.

   Called just before doing relaxation.
   Any symbol that is now undefined will not become defined.
   The guess for fr_var is ACTUALLY the growth beyond fr_fix.
   Whatever we do to grow fr_fix or fr_var contributes to our returned value.
   Although it may not be explicit in the frag, pretend fr_var starts with a
   0 value.  */

int
md_estimate_size_before_relax (fragS * fragP,
			       segT    segment ATTRIBUTE_UNUSED)
{
  int    old_fr_fix = fragP->fr_fix;

  /* The only thing we have to handle here are symbols outside of the
     current segment.  They may be undefined or in a different segment in
     which case linker scripts may place them anywhere.
     However, we can't finish the fragment here and emit the reloc as insn
     alignment requirements may move the insn about.  */

  return (fragP->fr_var + fragP->fr_fix - old_fr_fix);
}

/* *fragP has been relaxed to its final size, and now needs to have
   the bytes inside it modified to conform to the new size.

   Called after relaxation is finished.
   fragP->fr_type == rs_machine_dependent.
   fragP->fr_subtype is the subtype of what the address relaxed to.  */

void
md_convert_frag (bfd   * abfd  ATTRIBUTE_UNUSED,
		 segT    sec   ATTRIBUTE_UNUSED,
		 fragS * fragP ATTRIBUTE_UNUSED)
{
}


/* Functions concerning relocs.  */

long
md_pcrel_from_section (fixS * fixP, segT sec)
{
  if (fixP->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixP->fx_addsy)
	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
    {
      /* The symbol is undefined (or is defined but not in this section).
	 Let the linker figure it out.  */
      return 0;
    }

  /* Return the address of the delay slot.  */
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
   Returns BFD_RELOC_NONE if no reloc type can be found.
   *FIXP may be modified if desired.  */

bfd_reloc_code_real_type
md_cgen_lookup_reloc (const CGEN_INSN *    insn     ATTRIBUTE_UNUSED,
		      const CGEN_OPERAND * operand,
		      fixS *               fixP     ATTRIBUTE_UNUSED)
{
  switch (operand->type)
    {
    case IQ2000_OPERAND_OFFSET:      return BFD_RELOC_16_PCREL_S2;
    case IQ2000_OPERAND_JMPTARG:     return BFD_RELOC_IQ2000_OFFSET_16;
    case IQ2000_OPERAND_JMPTARGQ10:  return BFD_RELOC_NONE;
    case IQ2000_OPERAND_HI16:        return BFD_RELOC_HI16;
    case IQ2000_OPERAND_LO16:        return BFD_RELOC_LO16;
    default: break;
    }

  return BFD_RELOC_NONE;
}

/* Record a HI16 reloc for later matching with its LO16 cousin.  */

static void
iq2000_record_hi16 (int    reloc_type,
		    fixS * fixP,
		    segT   seg ATTRIBUTE_UNUSED)
{
  struct iq2000_hi_fixup * hi_fixup;

  gas_assert (reloc_type == BFD_RELOC_HI16);

  hi_fixup = xmalloc (sizeof * hi_fixup);
  hi_fixup->fixp = fixP;
  hi_fixup->seg  = now_seg;
  hi_fixup->next = iq2000_hi_fixup_list;

  iq2000_hi_fixup_list = hi_fixup;
}

/* Called while parsing an instruction to create a fixup.
   We need to check for HI16 relocs and queue them up for later sorting.  */

fixS *
iq2000_cgen_record_fixup_exp (fragS *              frag,
			      int                  where,
			      const CGEN_INSN *    insn,
			      int                  length,
			      const CGEN_OPERAND * operand,
			      int                  opinfo,
			      expressionS *        exp)
{
  fixS * fixP = gas_cgen_record_fixup_exp (frag, where, insn, length,
					   operand, opinfo, exp);

  if (operand->type == IQ2000_OPERAND_HI16
      /* If low/high was used, it is recorded in `opinfo'.  */
      && (fixP->fx_cgen.opinfo == BFD_RELOC_HI16
	  || fixP->fx_cgen.opinfo == BFD_RELOC_LO16))
    iq2000_record_hi16 (fixP->fx_cgen.opinfo, fixP, now_seg);

  return fixP;
}

/* Return BFD reloc type from opinfo field in a fixS.
   It's tricky using fx_r_type in iq2000_frob_file because the values
   are BFD_RELOC_UNUSED + operand number.  */
#define FX_OPINFO_R_TYPE(f) ((f)->fx_cgen.opinfo)

/* Sort any unmatched HI16 relocs so that they immediately precede
   the corresponding LO16 reloc.  This is called before md_apply_fix and
   tc_gen_reloc.  */

void
iq2000_frob_file (void)
{
  struct iq2000_hi_fixup * l;

  for (l = iq2000_hi_fixup_list; l != NULL; l = l->next)
    {
      segment_info_type * seginfo;
      int                 pass;

      gas_assert (FX_OPINFO_R_TYPE (l->fixp) == BFD_RELOC_HI16
	      || FX_OPINFO_R_TYPE (l->fixp) == BFD_RELOC_LO16);

      /* Check quickly whether the next fixup happens to be a matching low.  */
      if (l->fixp->fx_next != NULL
	  && FX_OPINFO_R_TYPE (l->fixp->fx_next) == BFD_RELOC_LO16
	  && l->fixp->fx_addsy == l->fixp->fx_next->fx_addsy
	  && l->fixp->fx_offset == l->fixp->fx_next->fx_offset)
	continue;

      /* Look through the fixups for this segment for a matching
         `low'.  When we find one, move the high just in front of it.
         We do this in two passes.  In the first pass, we try to find
         a unique `low'.  In the second pass, we permit multiple
         high's relocs for a single `low'.  */
      seginfo = seg_info (l->seg);
      for (pass = 0; pass < 2; pass++)
	{
	  fixS * f;
	  fixS * prev;

	  prev = NULL;
	  for (f = seginfo->fix_root; f != NULL; f = f->fx_next)
	    {
	      /* Check whether this is a `low' fixup which matches l->fixp.  */
	      if (FX_OPINFO_R_TYPE (f) == BFD_RELOC_LO16
		  && f->fx_addsy == l->fixp->fx_addsy
		  && f->fx_offset == l->fixp->fx_offset
		  && (pass == 1
		      || prev == NULL
		      || (FX_OPINFO_R_TYPE (prev) != BFD_RELOC_HI16)
		      || prev->fx_addsy != f->fx_addsy
		      || prev->fx_offset !=  f->fx_offset))
		{
		  fixS ** pf;

		  /* Move l->fixp before f.  */
		  for (pf = &seginfo->fix_root;
		       * pf != l->fixp;
		       pf = & (* pf)->fx_next)
		    gas_assert (* pf != NULL);

		  * pf = l->fixp->fx_next;

		  l->fixp->fx_next = f;
		  if (prev == NULL)
		    seginfo->fix_root = l->fixp;
		  else
		    prev->fx_next = l->fixp;

		  break;
		}

	      prev = f;
	    }

	  if (f != NULL)
	    break;

	  if (pass == 1)
	    as_warn_where (l->fixp->fx_file, l->fixp->fx_line,
			   _("Unmatched high relocation"));
	}
    }
}

/* See whether we need to force a relocation into the output file.  */

int
iq2000_force_relocation (fixS * fix)
{
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  return 0;
}

/* Handle the .set pseudo-op.  */

static void
s_iq2000_set (int x ATTRIBUTE_UNUSED)
{
  static const char * ignored_arguments [] =
    {
      "reorder",
      "noreorder",
      "at",
      "noat",
      "macro",
      "nomacro",
      "move",
      "novolatile",
      "nomove",
      "volatile",
      "bopt",
      "nobopt",
      NULL
    };
  const char ** ignored;
  char *name = input_line_pointer, ch;
  char *save_ILP = input_line_pointer;

  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;
  ch = *input_line_pointer;
  *input_line_pointer = '\0';

  for (ignored = ignored_arguments; * ignored; ignored ++)
    if (strcmp (* ignored, name) == 0)
      break;
  if (* ignored == NULL)
    {
      /* We'd like to be able to use .set symbol, expn */
      input_line_pointer = save_ILP;
      s_set (0);
      return;
    }
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

/* Write a value out to the object file, using the appropriate endianness.  */

void
md_number_to_chars (char * buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

void
md_operand (expressionS * exp)
{
  /* In case of a syntax error, escape back to try next syntax combo.  */
  if (exp->X_op == O_absent)
    gas_cgen_md_operand (exp);
}

char *
md_atof (int type, char * litP, int * sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

bfd_boolean
iq2000_fix_adjustable (fixS * fixP)
{
  bfd_reloc_code_real_type reloc_type;

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      const CGEN_INSN *insn = NULL;
      int opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
      const CGEN_OPERAND *operand = cgen_operand_lookup_by_num(gas_cgen_cpu_desc, opindex);

      reloc_type = md_cgen_lookup_reloc (insn, operand, fixP);
    }
  else
    reloc_type = fixP->fx_r_type;

  if (fixP->fx_addsy == NULL)
    return TRUE;

  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERNAL (fixP->fx_addsy))
    return FALSE;

  if (S_IS_WEAK (fixP->fx_addsy))
    return FALSE;

  /* We need the symbol name for the VTABLE entries.  */
  if (   reloc_type == BFD_RELOC_VTABLE_INHERIT
      || reloc_type == BFD_RELOC_VTABLE_ENTRY)
    return FALSE;

  return TRUE;
}

static void
s_change_sec (int sec)
{
#ifdef OBJ_ELF
  /* The ELF backend needs to know that we are changing sections, so
     that .previous works correctly.  We could do something like check
     for a obj_section_change_hook macro, but that might be confusing
     as it would not be appropriate to use it in the section changing
     functions in read.c, since obj-elf.c intercepts those.  FIXME:
     This should be cleaner, somehow.  */
  obj_elf_section_change_hook ();
#endif

  switch (sec)
    {
    case 't':
      s_text (0);
      break;
    case 'd':
    case 'r':
      s_data (0);
      break;
    }
}

static symbolS *
get_symbol (void)
{
  int c;
  char *name;
  symbolS *p;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = (symbolS *) symbol_find_or_make (name);
  *input_line_pointer = c;
  return p;
}

/* The .end directive.  */

static void
s_iq2000_end (int x ATTRIBUTE_UNUSED)
{
  symbolS *p;
  int maybe_text;

  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      p = get_symbol ();
      demand_empty_rest_of_line ();
    }
  else
    p = NULL;

  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    maybe_text = 1;
  else
    maybe_text = 0;

  if (!maybe_text)
    as_warn (_(".end not in text section"));

  if (!cur_proc_ptr)
    {
      as_warn (_(".end directive without a preceding .ent directive."));
      demand_empty_rest_of_line ();
      return;
    }

  if (p != NULL)
    {
      gas_assert (S_GET_NAME (p));
      if (strcmp (S_GET_NAME (p), S_GET_NAME (cur_proc_ptr->isym)))
	as_warn (_(".end symbol does not match .ent symbol."));
    }
  else
    as_warn (_(".end directive missing or unknown symbol"));

  cur_proc_ptr = NULL;
}

static int
get_number (void)
{
  int negative = 0;
  long val = 0;

  if (*input_line_pointer == '-')
    {
      ++input_line_pointer;
      negative = 1;
    }

  if (! ISDIGIT (*input_line_pointer))
    as_bad (_("Expected simple number."));

  if (input_line_pointer[0] == '0')
    {
      if (input_line_pointer[1] == 'x')
	{
	  input_line_pointer += 2;
	  while (ISXDIGIT (*input_line_pointer))
	    {
	      val <<= 4;
	      val |= hex_value (*input_line_pointer++);
	    }
	  return negative ? -val : val;
	}
      else
	{
	  ++input_line_pointer;

	  while (ISDIGIT (*input_line_pointer))
	    {
	      val <<= 3;
	      val |= *input_line_pointer++ - '0';
	    }
	  return negative ? -val : val;
	}
    }

  if (! ISDIGIT (*input_line_pointer))
    {
      printf (_(" *input_line_pointer == '%c' 0x%02x\n"),
	      *input_line_pointer, *input_line_pointer);
      as_warn (_("Invalid number"));
      return -1;
    }

  while (ISDIGIT (*input_line_pointer))
    {
      val *= 10;
      val += *input_line_pointer++ - '0';
    }

  return negative ? -val : val;
}

/* The .aent and .ent directives.  */

static void
s_iq2000_ent (int aent)
{
  symbolS *symbolP;
  int maybe_text;

  symbolP = get_symbol ();
  if (*input_line_pointer == ',')
    input_line_pointer++;
  SKIP_WHITESPACE ();
  if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')
    get_number ();

  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    maybe_text = 1;
  else
    maybe_text = 0;

  if (!maybe_text)
    as_warn (_(".ent or .aent not in text section."));

  if (!aent && cur_proc_ptr)
    as_warn (_("missing `.end'"));

  if (!aent)
    {
      cur_proc_ptr = &cur_proc;
      memset (cur_proc_ptr, '\0', sizeof (procS));

      cur_proc_ptr->isym = symbolP;

      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;

      numprocs++;
    }

  demand_empty_rest_of_line ();
}

/* The .frame directive. If the mdebug section is present (IRIX 5 native)
   then ecoff.c (ecoff_directive_frame) is used. For embedded targets,
   s_iq2000_frame is used so that we can set the PDR information correctly.
   We can't use the ecoff routines because they make reference to the ecoff
   symbol table (in the mdebug section).  */

static void
s_iq2000_frame (int ignore)
{
  s_ignore (ignore);
}

/* The .fmask and .mask directives. If the mdebug section is present
   (IRIX 5 native) then ecoff.c (ecoff_directive_mask) is used. For
   embedded targets, s_iq2000_mask is used so that we can set the PDR
   information correctly. We can't use the ecoff routines because they
   make reference to the ecoff symbol table (in the mdebug section).  */

static void
s_iq2000_mask (int reg_type)
{
  s_ignore (reg_type);
}

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
    { "align",  s_align_bytes,           0 },
    { "word",   cons,                    4 },
    { "rdata",  s_change_sec, 		'r'},
    { "sdata",  s_change_sec, 		's'},
    { "set",	s_iq2000_set,		 0 },
    { "ent",    s_iq2000_ent, 		 0 },
    { "end",    s_iq2000_end,            0 },
    { "frame",  s_iq2000_frame, 	 0 },
    { "fmask",  s_iq2000_mask, 		'F'},
    { "mask",   s_iq2000_mask, 		'R'},
    { "dword",	cons, 			 8 },
    { "half",	cons, 			 2 },
    { NULL, 	NULL,			 0 }
};
@


1.17
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009
a911 1
  int number = 0;
d920 1
a920 1
    number = get_number ();
@


1.16
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007
@


1.15
log
@Remove duplicate definitions of the md_atof() function
@
text
@d537 1
a537 1
  assert (reloc_type == BFD_RELOC_HI16);
d590 1
a590 1
      assert (FX_OPINFO_R_TYPE (l->fixp) == BFD_RELOC_HI16
d630 1
a630 1
		    assert (* pf != NULL);
d840 1
a840 1
      assert (S_GET_NAME (p));
@


1.14
log
@Switch to GPLv3
@
text
@a727 8
/* Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6

d731 1
a731 41
  int              i;
  int              prec;
  LITTLENUM_TYPE   words [MAX_LITTLENUMS];
  char *           t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

   /* FIXME: Some targets allow other format chars for bigger sizes here.  */

    default:
      * sizeP = 0;
      return _("Bad call to md_atof()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  * sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (i = 0; i < prec; i++)
    {
      md_number_to_chars (litP, (valueT) words[i],
			  sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
a733 1

@


1.13
log
@	* config/tc-iq2000.c: Include sb.h.
@
text
@d2 2
a3 1
   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.12
log
@remove some duplicate #include's.
@
text
@d31 1
@


1.11
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2005 Free Software Foundation.
a20 1
#include <stdio.h>
a30 1
#include "hash.h"
@


1.10
log
@Update the address and phone number of the FSF
@
text
@d577 1
a577 1
   the corresponding LO16 reloc.  This is called before md_apply_fix3 and
@


1.9
log
@2005-04-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-aout.h (S_IS_EXTERN): Removed.
	* config/obj-bout.h (S_IS_EXTERN): Likewise.
	* config/obj-coff.h (S_IS_EXTERN): Likewise.
	* symbols.c (S_IS_EXTERN): Likewise.
	* symbols.h (S_IS_EXTERN): Likewise.

	* config/tc-alpha.c (tc_gen_reloc): Replace S_IS_EXTERN with
	S_IS_EXTERNAL.
	* config/tc-d10v.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_fix_adjustable): Likewise.
	* config/tc-iq2000.c (iq2000_fix_adjustable): Likewise.
	* config/tc-m32r.c (m32r_fix_adjustable): Likewise.
	* config/tc-mmix.c (mmix_adjust_symtab): Likewise.
	* config/tc-sh64.c (shmedia_frob_file_before_adjust): Likewise.
	(shmedia_md_convert_frag): Likewise.
	* symbols.c (print_symbol_value_1): Likewise.
	* write.c (write_object_file): Likewise.
@
text
@d18 2
a19 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.8
log
@(line_comment_chars): Include the # character as otherwise this breaks
#APP/#NO_APP processing.
@
text
@d803 1
a803 1
  if (S_IS_EXTERN (fixP->fx_addsy))
@


1.7
log
@update copyright dates
@
text
@d58 1
a58 1
const char line_comment_chars[]   = "";
@


1.6
log
@(s_iq2000_set): Fix thinko parsing ignored_arguments array.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004 Free Software Foundation.
@


1.5
log
@Remove IQ10 support from IQ2000 port
@
text
@d689 1
a689 1
  const char * ignored;
d698 2
a699 2
  for (ignored = ignored_arguments[0]; ignored; ignored ++)
    if (strcmp (ignored, name) == 0)
d701 1
a701 1
  if (ignored == NULL)
@


1.4
log
@Patch reviewed and approved by nickc@@redhat.com.

	2004-02-25  Fred Fish  <fnf@@redhat.com>
	* config/tc-iq2000.c: Add missing \n\ in multiline string literal.
@
text
@d24 1
a24 1
#include "subsegs.h"     
d59 1
a59 1
const char line_separator_chars[] = ";"; 
d63 1
a63 2
/* Default machine */

d70 1
a70 1
/* Flags to set in the elf header */
d73 2
a74 1
typedef struct proc {
a88 29
static void s_change_sec PARAMS ((int));
static void s_iq2000_set PARAMS ((int));
static void s_iq2000_mask PARAMS ((int));
static void s_iq2000_frame PARAMS ((int));
static void s_iq2000_ent PARAMS ((int));
static void s_iq2000_end PARAMS ((int));
static int  get_number PARAMS ((void));
static symbolS * get_symbol PARAMS ((void));
static void iq2000_record_hi16 PARAMS((int, fixS *, segT));


/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
    { "align",  s_align_bytes,           0 },
    { "word",   cons,                    4 },
    { "rdata",  s_change_sec, 		'r'},
    { "sdata",  s_change_sec, 		's'},
    { "set",	s_iq2000_set,		 0 },
    { "ent",    s_iq2000_ent, 		 0 },
    { "end",    s_iq2000_end,              0 },
    { "frame",  s_iq2000_frame, 		 0 },
    { "fmask",  s_iq2000_mask, 		'F' },
    { "mask",   s_iq2000_mask, 		'R' },
    { "dword",	cons, 			 8 },
    { "half",	cons, 			 2 },
    { NULL, 	NULL,			 0 }
};

d103 2
a104 3
  fixS *                  fixp;  /* This fixup.  */
  segT                    seg;   /* The section this fixup is in.  */

d110 2
d113 1
a113 4
/* assembler options */
#define OPTION_CPU_2000		(OPTION_MD_BASE)
#define OPTION_CPU_10	        (OPTION_MD_BASE + 1)

d115 2
a116 4
{  
  { "m2000",       no_argument,	      NULL, OPTION_CPU_2000   },
  { "m10",         no_argument,	      NULL, OPTION_CPU_10     },
  { NULL,          no_argument,       NULL, 0                 },
a117 1

a119 9
const char * md_shortopts = "";

static void iq2000_add_macro         PARAMS ((const char *, const char *, const char **));
static void iq2000_load_macros       PARAMS ((void));
static void iq10_load_macros         PARAMS ((void));

/* macro hash table, which we will add to.  */
extern struct hash_control *macro_hash;

d121 4
a124 23
md_parse_option (c, arg)
    int c ATTRIBUTE_UNUSED;
    char * arg ATTRIBUTE_UNUSED;
{
  switch (c)
    {
    case OPTION_CPU_2000:
      iq2000_flags = (iq2000_flags & ~EF_IQ2000_CPU_MASK) | EF_IQ2000_CPU_IQ2000;
      iq2000_mach = bfd_mach_iq2000;
      cpu_mach = (1 << MACH_IQ2000);
      break;

    case OPTION_CPU_10:
      iq2000_flags = (iq2000_flags & ~EF_IQ2000_CPU_MASK) | EF_IQ2000_CPU_IQ10;
      iq2000_mach = bfd_mach_iq10;
      cpu_mach = (1 << MACH_IQ10);
      /* only the first 3 pseudo ops (word, file, loc) are in IQ10 */
      break;

    default:
      return 0;
    }
  return 1;
d128 1
a128 2
md_show_usage (stream)
  FILE * stream;
d130 1
a130 5
  fprintf (stream, _("IQ2000 specific command line options:\n"));
  fprintf (stream, _("-m2000 <default>           IQ2000 processor\n"));
  fprintf (stream, _("-m10                       IQ10 processor\n"));
} 

d132 1
a132 11
void
md_begin ()
{
  /* Initialize the `cgen' interface.  */
  
  /* Set the machine number and endian.  */
  gas_cgen_cpu_desc = iq2000_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, cpu_mach,
					   CGEN_CPU_OPEN_ENDIAN,
					   CGEN_ENDIAN_BIG,
					   CGEN_CPU_OPEN_END);
  iq2000_cgen_init_asm (gas_cgen_cpu_desc);
d134 1
a134 21
  /* This is a callback from cgen to gas to parse operands.  */
  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);

  /* Set the ELF flags if desired. */
  if (iq2000_flags)
    bfd_set_private_flags (stdoutput, iq2000_flags);

  /* Set the machine type */
  bfd_default_set_arch_mach (stdoutput, bfd_arch_iq2000, iq2000_mach);

  if (iq2000_mach == bfd_mach_iq2000)
    iq2000_load_macros ();
  else
    iq10_load_macros ();
}

static void
iq2000_add_macro (name, semantics, arguments)
     const char  *name;
     const char  *semantics;
     const char **arguments;
a135 64
  macro_entry *macro;
  sb macro_name;
  const char *namestr;

  macro = (macro_entry *) xmalloc (sizeof (macro_entry));
  sb_new (&macro->sub);
  sb_new (&macro_name);

  macro->formal_count = 0;
  macro->formals = 0;

  sb_add_string (&macro->sub, semantics);

  if (arguments != NULL)
    {
      formal_entry **p = &macro->formals;
      
      macro->formal_count = 0;
      macro->formal_hash = hash_new ();
      while (*arguments != NULL)
	{
	  formal_entry *formal;
	  
	  formal = (formal_entry *) xmalloc (sizeof (formal_entry));
	  
	  sb_new (&formal->name);
	  sb_new (&formal->def);
	  sb_new (&formal->actual);
	  
	  /* chlm: Added the following to allow defaulted args.  */
	  if (strchr (*arguments,'='))
	    {
	      char * tt_args = strdup(*arguments);
	      char * tt_dflt = strchr(tt_args,'=');

	      *tt_dflt = 0;
	      sb_add_string (&formal->name, tt_args);
	      sb_add_string (&formal->def,  tt_dflt + 1);
	    }
	  else
	    sb_add_string (&formal->name, *arguments);

	  /* Add to macro's hash table.  */
	  hash_jam (macro->formal_hash, sb_terminate (&formal->name), formal);
	  
	  formal->index = macro->formal_count;
	  macro->formal_count++;
	  *p = formal;
	  p = &formal->next;
	  *p = NULL;
	  ++arguments;
	}
    }

  sb_add_string (&macro_name, name);  
  namestr = sb_terminate (&macro_name);
  hash_jam (macro_hash, namestr, (PTR) macro);

  macro_defined = 1;
}

/* Automatically enter conditional branch macros.  */

typedef struct {
a142 1

a144 1

a153 1

a162 1

a187 1

d200 26
a225 25
  
static iq2000_macro_defs_s iq2000_macro_defs[] = {
  {"abs",  (const char **)&abs_expn,  (const char **)&abs_args},
  {"la",   (const char **)&la_expn,   (const char **)&la_args},
  {"bge",  (const char **)&bge_expn,  (const char **)&bxx_args},
  {"bgeu", (const char **)&bgeu_expn, (const char **)&bxx_args},
  {"bgt",  (const char **)&bgt_expn,  (const char **)&bxx_args},
  {"bgtu", (const char **)&bgtu_expn, (const char **)&bxx_args},
  {"ble",  (const char **)&ble_expn,  (const char **)&bxx_args},
  {"bleu", (const char **)&bleu_expn, (const char **)&bxx_args},
  {"blt",  (const char **)&blt_expn,  (const char **)&bxx_args},
  {"bltu", (const char **)&bltu_expn, (const char **)&bxx_args},
  {"sge",  (const char **)&sge_expn,  (const char **)&sxx_args},
  {"sgeu", (const char **)&sgeu_expn, (const char **)&sxx_args},
  {"sle",  (const char **)&sle_expn,  (const char **)&sxx_args},
  {"sleu", (const char **)&sleu_expn, (const char **)&sxx_args},
  {"sgt",  (const char **)&sgt_expn,  (const char **)&sxx_args},
  {"sgtu", (const char **)&sgtu_expn, (const char **)&sxx_args},
  {"seq",  (const char **)&seq_expn,  (const char **)&sxx_args},
  {"sne",  (const char **)&sne_expn,  (const char **)&sxx_args},
  {"neg",  (const char **)&neg_expn,  (const char **)&neg_args},
  {"negu", (const char **)&negu_expn, (const char **)&neg_args},
  {"li",   (const char **)&li_expn,   (const char **)&li_args},
  {"ori32", (const char **)&ori32_expn, (const char **)&ai32_args},
  {"andi32",(const char **)&andi32_expn,(const char **)&ai32_args},
d229 68
a296 1
iq2000_load_macros ()
d299 1
a299 1
  int mcnt = sizeof (iq2000_macro_defs) / sizeof (iq2000_macro_defs_s);
d307 2
a308 2
static void
iq10_load_macros ()
d310 15
a324 4
  /* Allow all iq2k macros in iq10, instead of just LA. */
  iq2000_load_macros ();
#if 0
  char *la_sem = "\n lui \\reg,%hi(\\label)\n ori \\reg,\\reg,%lo(\\label)\n";
d326 2
a327 3
  char *la_arg_1 = "reg";
  char *la_arg_2 = "label";
  const char *la_args[3] = { la_arg_1, la_arg_2, NULL };
d329 1
a329 2
  iq2000_add_macro ("la", la_sem, la_args);
#endif
a331 1

d333 1
a333 2
md_assemble (str)
     char * str;
d360 2
a361 2
  /* We need to generate an error if there's a yielding instruction in the delay 
     slot of a control flow modifying instruction (jump (yes), load (no))  */ 
d368 1
a368 1
     instructions like LDW.  On iq2000, result is always rt. */
a374 8
  /* Warn about odd numbered base registers for paired-register
     instructions like LDW.  On iq10, result is always rd. */
  if (iq2000_mach == bfd_mach_iq10
      && CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_EVEN_REG_NUM)
      && (insn.fields.f_rd % 2))
    as_bad (_("Register number (R%ld) for double word access must be even."),
	    insn.fields.f_rd);

d383 1
a383 1
      
d388 1
a388 1
      
d393 1
a393 1
      
d399 12
a410 12
  /* Warn about insns that reference the (target + 1) of a previous ldw */ 
  if (last_insn_was_ldw) 
    { 
      if ((CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RD) 
           && insn.fields.f_rd == delayed_load_register + 1) 
       || (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RS) 
           && insn.fields.f_rs == delayed_load_register + 1) 
       || (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_USES_RT) 
           && insn.fields.f_rt == delayed_load_register + 1)) 
        as_warn (_("operand references R%ld of previous load."), 
                delayed_load_register + 1); 
    } 
d424 2
a425 2
  /* The meaning of EVEN_REG_NUM was overloaded to also imply LDW.  Since that's 
     not true for IQ10, let's make the above logic specific to LDW. */
d428 1
a428 2
  /* The assumption here is that the target of a load is always rt.
     That is true for iq2000 & iq10. */
d433 1
a433 3
md_section_align (segment, size)
     segT   segment;
     valueT size;
a438 1

d440 1
a440 2
md_undefined_symbol (name)
    char * name ATTRIBUTE_UNUSED;
d459 2
a460 3
md_estimate_size_before_relax (fragP, segment)
     fragS * fragP;
     segT    segment ATTRIBUTE_UNUSED;
d471 1
a471 1
} 
d481 3
a483 4
md_convert_frag (abfd, sec, fragP)
    bfd   * abfd  ATTRIBUTE_UNUSED;
    segT    sec   ATTRIBUTE_UNUSED;
    fragS * fragP ATTRIBUTE_UNUSED;
d491 1
a491 3
md_pcrel_from_section (fixP, sec)
     fixS * fixP;
     segT   sec;
d502 1
a502 1
  /* return the address of the delay slot */
d511 3
a513 4
md_cgen_lookup_reloc (insn, operand, fixP)
     const CGEN_INSN *    insn     ATTRIBUTE_UNUSED;
     const CGEN_OPERAND * operand;
     fixS *               fixP     ATTRIBUTE_UNUSED;
d517 6
a522 15
    case IQ2000_OPERAND_OFFSET:
      return BFD_RELOC_16_PCREL_S2;
    case IQ2000_OPERAND_JMPTARG:
      return BFD_RELOC_IQ2000_OFFSET_16;
    case IQ2000_OPERAND_JMPTARGQ10:
      if (iq2000_mach == bfd_mach_iq10)
	return BFD_RELOC_IQ2000_OFFSET_21;
      return BFD_RELOC_NONE;
    case IQ2000_OPERAND_HI16:
      return BFD_RELOC_HI16;
    case IQ2000_OPERAND_LO16:
      return BFD_RELOC_LO16;
    default:
      /* Pacify gcc -Wall.  */
      return BFD_RELOC_NONE;
d531 3
a533 4
iq2000_record_hi16 (reloc_type, fixP, seg)
     int    reloc_type;
     fixS * fixP;
     segT   seg ATTRIBUTE_UNUSED;
d539 1
a539 2
  hi_fixup = ((struct iq2000_hi_fixup *)
	      xmalloc (sizeof (struct iq2000_hi_fixup)));
d543 1
a543 1
  
d551 7
a557 8
iq2000_cgen_record_fixup_exp (frag, where, insn, length, operand, opinfo, exp)
     fragS *              frag;
     int                  where;
     const CGEN_INSN *    insn;
     int                  length;
     const CGEN_OPERAND * operand;
     int                  opinfo;
     expressionS *        exp;
d562 1
a562 3
  switch (operand->type)
    {
    case IQ2000_OPERAND_HI16 :
d564 3
a566 7
      if (fixP->fx_cgen.opinfo == BFD_RELOC_HI16
	  || fixP->fx_cgen.opinfo == BFD_RELOC_LO16)
	iq2000_record_hi16 (fixP->fx_cgen.opinfo, fixP, now_seg);
      break;
    default : /* avoid -Wall warning */
      break;
    }
d581 1
a581 1
iq2000_frob_file ()
d589 1
a589 1
      
d592 1
a592 1
      
d659 1
a659 2
iq2000_force_relocation (fix)
     fixS * fix;
d671 1
a671 2
s_iq2000_set (x)
     int x ATTRIBUTE_UNUSED;
d673 17
d698 4
a701 31
  if (strcmp (name, "reorder") == 0)
    {
    }
  else if (strcmp (name, "noreorder") == 0)
    {
    }
  else if (strcmp (name, "at") == 0)
    {
    }
  else if (strcmp (name, "noat") == 0)
    {
    }
  else if (strcmp (name, "macro") == 0)
    {
    }
  else if (strcmp (name, "nomacro") == 0)
    {
    }
  else if (strcmp (name, "move") == 0 || strcmp (name, "novolatile") == 0)
    {
    }
  else if (strcmp (name, "nomove") == 0 || strcmp (name, "volatile") == 0)
    {
    }
  else if (strcmp (name, "bopt") == 0)
    {
    }
  else if (strcmp (name, "nobopt") == 0)
    {
    }
  else
a706 1
      /*as_warn (_("Tried to set unrecognized symbol: %s\n"), name);*/
d715 1
a715 4
md_number_to_chars (buf, val, n)
     char * buf;
     valueT val;
     int    n;
d721 1
a721 2
md_operand (exp)
     expressionS * exp;
d723 1
a723 1
  /* In case of a syntax error, escape back to try next syntax combo. */
d737 1
a737 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d771 1
a771 1
  
d784 1
a784 2
iq2000_fix_adjustable (fixP)
   fixS * fixP;
d793 1
d801 1
a801 1
  
d805 1
a805 1
  
d808 1
a808 1
  
d818 1
a818 2
s_change_sec (sec)
     int sec;
a819 1

a829 2
  /*   iq2000_emit_delays (false); */

d842 14
d859 1
a859 2
s_iq2000_end (x)
     int x ATTRIBUTE_UNUSED;
d872 9
a880 1
  if (1/*iq2000_mach == bfd_mach_iq2000*/)
d882 3
a884 31
#ifdef BFD_ASSEMBLER
      if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
	maybe_text = 1;
      else
	maybe_text = 0;
#else
      if (now_seg != data_section && now_seg != bss_section)
	maybe_text = 1;
      else
	maybe_text = 0;
#endif
      
      if (!maybe_text)
	as_warn (_(".end not in text section"));
      
      if (!cur_proc_ptr)
	{
	  as_warn (_(".end directive without a preceding .ent directive."));
	  demand_empty_rest_of_line ();
	  return;
	}
      
      if (p != NULL)
	{
	  assert (S_GET_NAME (p));
	  if (strcmp (S_GET_NAME (p), S_GET_NAME (cur_proc_ptr->isym)))
	    as_warn (_(".end symbol does not match .ent symbol."));
	}
      else
	as_warn (_(".end directive missing or unknown symbol"));
      
d887 1
a887 14
  cur_proc_ptr = NULL;
}

/* The .aent and .ent directives.  */

static void
s_iq2000_ent (aent)
     int aent;
{
  int number = 0;
  symbolS *symbolP;
  int maybe_text;

  if (1/*iq2000_mach == bfd_mach_iq2000*/)
d889 3
a891 36
      symbolP = get_symbol ();
      if (*input_line_pointer == ',')
	input_line_pointer++;
      SKIP_WHITESPACE ();
      if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')
	number = get_number ();
      
#ifdef BFD_ASSEMBLER
      if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
	maybe_text = 1;
      else
	maybe_text = 0;
#else
      if (now_seg != data_section && now_seg != bss_section)
	maybe_text = 1;
      else
	maybe_text = 0;
#endif
      
      if (!maybe_text)
	as_warn (_(".ent or .aent not in text section."));
      
      if (!aent && cur_proc_ptr)
	as_warn (_("missing `.end'"));
      
      if (!aent)
	{
	  cur_proc_ptr = &cur_proc;
	  memset (cur_proc_ptr, '\0', sizeof (procS));
	  
	  cur_proc_ptr->isym = symbolP;
	  
	  symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
	  
	  numprocs++;
	}
d894 1
a894 1
    as_bad (_("unknown pseudo-op: `%s'"), ".ent");
d896 1
a896 41
  demand_empty_rest_of_line ();
}

/* The .frame directive. If the mdebug section is present (IRIX 5 native)
   then ecoff.c (ecoff_directive_frame) is used. For embedded targets,
   s_iq2000_frame is used so that we can set the PDR information correctly.
   We can't use the ecoff routines because they make reference to the ecoff
   symbol table (in the mdebug section).  */

static void
s_iq2000_frame (ignore)
     int ignore;
{
  s_ignore (ignore);
}

/* The .fmask and .mask directives. If the mdebug section is present
   (IRIX 5 native) then ecoff.c (ecoff_directive_mask) is used. For
   embedded targets, s_iq2000_mask is used so that we can set the PDR
   information correctly. We can't use the ecoff routines because they
   make reference to the ecoff symbol table (in the mdebug section).  */

static void
s_iq2000_mask (reg_type)
     char reg_type;
{
  s_ignore (reg_type);
}

static symbolS *
get_symbol ()
{
  int c;
  char *name;
  symbolS *p;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = (symbolS *) symbol_find_or_make (name);
  *input_line_pointer = c;
  return p;
d900 1
a900 1
get_number ()
d956 83
@


1.3
log
@	* config/tc-arc.c: Remove a local prototype of atof_ieee.
	* config/tc-ip2k.c: Likewise.
	* config/tc-iq2000.c: Likewise.
	* config/tc-tic30.c: Remove a comment.
@
text
@d2 1
a2 1
   Copyright (C) 2003 Free Software Foundation.
d360 1
a360 1
 .elseif (\\imm & 0x0000ffff == 0)
@


1.3.6.1
log
@Merge to 2.15 branch.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004 Free Software Foundation.
d360 1
a360 1
 .elseif (\\imm & 0x0000ffff == 0)\n\
@


1.2
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@a889 1
  char *           atof_ieee ();
@


1.1
log
@	* configure.in: Add iq2000-elf target.
	* configure: Regenerate.
	* config/tc-iq2000.c: New file.
	* config/tc-iq2000.h: Likewise.
@
text
@a23 1
#include "dwarf2dbg.h"
a104 2
    { "file",	dwarf2_directive_file,	 0 },
    { "loc",	dwarf2_directive_loc,	 0 },
@

