head	1.29;
access;
symbols
	binutils-2_24-branch:1.29.0.10
	binutils-2_24-branchpoint:1.29
	binutils-2_21_1:1.29
	binutils-2_23_2:1.29
	binutils-2_23_1:1.29
	binutils-2_23:1.29
	binutils-2_23-branch:1.29.0.8
	binutils-2_23-branchpoint:1.29
	binutils-2_22_branch:1.29.0.6
	binutils-2_22:1.29
	binutils-2_22-branch:1.29.0.4
	binutils-2_22-branchpoint:1.29
	binutils-2_21:1.29
	binutils-2_21-branch:1.29.0.2
	binutils-2_21-branchpoint:1.29
	binutils-2_20_1:1.27.2.1
	binutils-2_20:1.27.2.1
	binutils-arc-20081103-branch:1.26.0.6
	binutils-arc-20081103-branchpoint:1.26
	binutils-2_20-branch:1.27.0.2
	binutils-2_20-branchpoint:1.27
	dje-cgen-play1-branch:1.26.0.4
	dje-cgen-play1-branchpoint:1.26
	arc-20081103-branch:1.26.0.2
	arc-20081103-branchpoint:1.26
	binutils-2_19_1:1.25.2.1
	binutils-2_19:1.25.2.1
	binutils-2_19-branch:1.25.0.2
	binutils-2_19-branchpoint:1.25
	binutils-2_18:1.21
	binutils-2_18-branch:1.21.0.2
	binutils-2_18-branchpoint:1.21
	binutils-csl-coldfire-4_1-32:1.19
	binutils-csl-sourcerygxx-4_1-32:1.19
	binutils-csl-innovasic-fido-3_4_4-33:1.19
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-coldfire-4_1-30:1.19
	binutils-csl-sourcerygxx-4_1-30:1.19
	binutils-csl-coldfire-4_1-28:1.19
	binutils-csl-sourcerygxx-4_1-29:1.19
	binutils-csl-sourcerygxx-4_1-28:1.19
	binutils-csl-arm-2006q3-27:1.19
	binutils-csl-sourcerygxx-4_1-27:1.19
	binutils-csl-arm-2006q3-26:1.19
	binutils-csl-sourcerygxx-4_1-26:1.19
	binutils-csl-sourcerygxx-4_1-25:1.19
	binutils-csl-sourcerygxx-4_1-24:1.19
	binutils-csl-sourcerygxx-4_1-23:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19
	binutils-csl-arm-2006q3-21:1.19
	binutils-csl-sourcerygxx-4_1-22:1.19
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19
	binutils-csl-sourcerygxx-4_1-20:1.19
	binutils-csl-arm-2006q3-19:1.19
	binutils-csl-sourcerygxx-4_1-19:1.19
	binutils-csl-sourcerygxx-4_1-18:1.19
	binutils-csl-renesas-4_1-9:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	binutils-csl-renesas-4_1-8:1.19
	binutils-csl-renesas-4_1-7:1.19
	binutils-csl-renesas-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-15:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19
	binutils-2_17:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	binutils-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-arm-2006q1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-wrs-linux-3_4_4-22:1.16
	binutils-csl-coldfire-4_1-11:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-coldfire-4_1-10:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-wrs-linux-3_4_4-21:1.16
	binutils-csl-morpho-4_1-4:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-wrs-linux-3_4_4-20:1.16
	binutils-2_17-branch:1.19.0.4
	binutils-2_17-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.2
	binutils-csl-2_17-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.16.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	binutils-csl-arm-2005q1a:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.4
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.2
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.13
	binutils-2_15:1.11.6.1
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	binutils-2_15-branch:1.11.0.6
	cagney_bfdfile-20040213-branch:1.11.0.4
	cagney_bfdfile-20040213-branchpoint:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	csl-arm-2003-q4:1.10
	binutils-2_14:1.6
	binutils-2_14-branch:1.6.0.2
	binutils-2_14-branchpoint:1.6
	binutils-2_13_2_1:1.1
	binutils-2_13_2:1.1
	binutils-2_13_1:1.1
	binutils-2_13:1.1
	binutils-2_13-branchpoint:1.1
	binutils-2_13-branch:1.1.0.2
	binutils_latest_snapshot:1.29;
locks; strict;
comment	@ * @;


1.29
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.10.14.05.40;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2008.09.15.05.22.32;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2007.11.12.10.57.33;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.08.15.26.42;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.11.17.39.49;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.05.09.12.55;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.17.13.46.03;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.25.20.22.32;	author aoliva;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.06.02.46.45;	author aoliva;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.01.10.11.35;	author rsandifo;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.06.19.19.18;	author aoliva;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	2003.11.27.02.30.55;	author aoliva;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.08.18.11.55;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.05.07.18.26;	author rsandifo;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.12.22.37.47;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.18.21.15.19;	author brolley;	state Exp;
branches;
next	;

1.27.2.1
date	2009.09.10.14.09.42;	author amodra;	state Exp;
branches;
next	;

1.25.2.1
date	2008.09.15.05.23.33;	author amodra;	state Exp;
branches;
next	;

1.11.6.1
date	2004.05.06.02.43.38;	author aoliva;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@/* tc-frv.c -- Assembler for the Fujitsu FRV.
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation. Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "subsegs.h"     
#include "symcat.h"
#include "opcodes/frv-desc.h"
#include "opcodes/frv-opc.h"
#include "cgen.h"
#include "libbfd.h"
#include "elf/common.h"
#include "elf/frv.h"
#include "dwarf2dbg.h"

/* Structure to hold all of the different components describing
   an individual instruction.  */
typedef struct
{
  const CGEN_INSN *	insn;
  const CGEN_INSN *	orig_insn;
  CGEN_FIELDS		fields;
#if CGEN_INT_INSN_P
  CGEN_INSN_INT         buffer [1];
#define INSN_VALUE(buf) (*(buf))
#else
  unsigned char         buffer [CGEN_MAX_INSN_SIZE];
#define INSN_VALUE(buf) (buf)
#endif
  char *		addr;
  fragS *		frag;
  int                   num_fixups;
  fixS *                fixups [GAS_CGEN_MAX_FIXUPS];
  int                   indices [MAX_OPERAND_INSTANCES];
}
frv_insn;

enum vliw_insn_type
{
  VLIW_GENERIC_TYPE,		/* Don't care about this insn.  */
  VLIW_BRANCH_TYPE,		/* A Branch.  */
  VLIW_LABEL_TYPE,		/* A Label.  */
  VLIW_NOP_TYPE,		/* A NOP.  */
  VLIW_BRANCH_HAS_NOPS		/* A Branch that requires NOPS.  */
};

/* We're going to use these in the fr_subtype field to mark 
   whether to keep inserted nops.  */

#define NOP_KEEP 1		/* Keep these NOPS.  */
#define NOP_DELETE 2		/* Delete these NOPS.  */

#define DO_COUNT    TRUE
#define DONT_COUNT  FALSE

/* A list of insns within a VLIW insn.  */
struct vliw_insn_list
{
  /*  The type of this insn.  */
  enum vliw_insn_type	type;

  /*  The corresponding gas insn information.  */
  const CGEN_INSN	*insn;

  /*  For branches and labels, the symbol that is referenced.  */
  symbolS		*sym;

  /*  For branches, the frag containing the single nop that was generated.  */
  fragS			*snop_frag;

  /*  For branches, the frag containing the double nop that was generated.  */
  fragS			*dnop_frag;

  /*  Pointer to raw data for this insn.  */
  char			*address;

  /* Next insn in list.  */
  struct vliw_insn_list *next;
};

static struct vliw_insn_list single_nop_insn = {
   VLIW_NOP_TYPE, NULL, NULL, NULL, NULL, NULL, NULL };

static struct vliw_insn_list double_nop_insn = {
   VLIW_NOP_TYPE, NULL, NULL, NULL, NULL, NULL, NULL };

struct vliw_chain
{
  int			num;
  int			insn_count;
  struct vliw_insn_list *insn_list;
  struct vliw_chain     *next;
};

static struct vliw_chain	*vliw_chain_top;
static struct vliw_chain	*current_vliw_chain;
static struct vliw_chain	*previous_vliw_chain;
static struct vliw_insn_list	*current_vliw_insn;

const char comment_chars[]        = ";";
const char line_comment_chars[]   = "#";
const char line_separator_chars[] = "!"; 
const char EXP_CHARS[]            = "eE";
const char FLT_CHARS[]            = "dD";

static FRV_VLIW vliw;

/* Default machine */

#ifdef  DEFAULT_CPU_FRV
#define DEFAULT_MACHINE bfd_mach_frv
#define DEFAULT_FLAGS	EF_FRV_CPU_GENERIC

#else
#ifdef  DEFAULT_CPU_FR300
#define DEFAULT_MACHINE	bfd_mach_fr300
#define DEFAULT_FLAGS	EF_FRV_CPU_FR300

#else
#ifdef	DEFAULT_CPU_SIMPLE
#define	DEFAULT_MACHINE bfd_mach_frvsimple
#define DEFAULT_FLAGS	EF_FRV_CPU_SIMPLE

#else
#ifdef	DEFAULT_CPU_TOMCAT
#define	DEFAULT_MACHINE bfd_mach_frvtomcat
#define DEFAULT_FLAGS	EF_FRV_CPU_TOMCAT

#else
#ifdef  DEFAULT_CPU_FR400
#define DEFAULT_MACHINE	bfd_mach_fr400
#define DEFAULT_FLAGS	EF_FRV_CPU_FR400

#else
#ifdef  DEFAULT_CPU_FR550
#define DEFAULT_MACHINE	bfd_mach_fr550
#define DEFAULT_FLAGS	EF_FRV_CPU_FR550

#else
#define DEFAULT_MACHINE	bfd_mach_fr500
#define DEFAULT_FLAGS	EF_FRV_CPU_FR500
#endif
#endif
#endif
#endif
#endif
#endif

#ifdef TE_LINUX
# define DEFAULT_FDPIC	EF_FRV_FDPIC
#else
# define DEFAULT_FDPIC	0
#endif

static unsigned long frv_mach = bfd_mach_frv;
static bfd_boolean fr400_audio;

/* Flags to set in the elf header */
static flagword frv_flags = DEFAULT_FLAGS | DEFAULT_FDPIC;

static int frv_user_set_flags_p = 0;
static int frv_pic_p = 0;
static const char *frv_pic_flag = DEFAULT_FDPIC ? "-mfdpic" : (const char *)0;

/* Print tomcat-specific debugging info.  */
static int tomcat_debug = 0;

/* Tomcat-specific NOP statistics.  */
static int tomcat_stats = 0;
static int tomcat_doubles = 0;
static int tomcat_singles = 0;

/* Forward reference to static functions */
static void frv_set_flags (int);
static void frv_pic_ptr (int);

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "eflags",	frv_set_flags,		0 },
  { "word",	cons,			4 },
  { "picptr",	frv_pic_ptr,		4 },
  { NULL, 	NULL,			0 }
};


#define FRV_SHORTOPTS "G:"
const char * md_shortopts = FRV_SHORTOPTS;

#define OPTION_GPR_32		(OPTION_MD_BASE)
#define OPTION_GPR_64		(OPTION_MD_BASE + 1)
#define OPTION_FPR_32		(OPTION_MD_BASE + 2)
#define OPTION_FPR_64		(OPTION_MD_BASE + 3)
#define OPTION_SOFT_FLOAT	(OPTION_MD_BASE + 4)
#define OPTION_DWORD_YES	(OPTION_MD_BASE + 5)
#define OPTION_DWORD_NO		(OPTION_MD_BASE + 6)
#define OPTION_DOUBLE		(OPTION_MD_BASE + 7)
#define OPTION_NO_DOUBLE	(OPTION_MD_BASE + 8)
#define OPTION_MEDIA		(OPTION_MD_BASE + 9)
#define OPTION_NO_MEDIA		(OPTION_MD_BASE + 10)
#define OPTION_CPU		(OPTION_MD_BASE + 11)
#define OPTION_PIC		(OPTION_MD_BASE + 12)
#define OPTION_BIGPIC		(OPTION_MD_BASE + 13)
#define OPTION_LIBPIC		(OPTION_MD_BASE + 14)
#define OPTION_MULADD		(OPTION_MD_BASE + 15)
#define OPTION_NO_MULADD	(OPTION_MD_BASE + 16)
#define OPTION_TOMCAT_DEBUG	(OPTION_MD_BASE + 17)
#define OPTION_TOMCAT_STATS	(OPTION_MD_BASE + 18)
#define OPTION_PACK	        (OPTION_MD_BASE + 19)
#define OPTION_NO_PACK	        (OPTION_MD_BASE + 20)
#define OPTION_FDPIC		(OPTION_MD_BASE + 21)
#define OPTION_NOPIC		(OPTION_MD_BASE + 22)

struct option md_longopts[] =
{
  { "mgpr-32",		no_argument,		NULL, OPTION_GPR_32        },
  { "mgpr-64",		no_argument,		NULL, OPTION_GPR_64        },
  { "mfpr-32",		no_argument,		NULL, OPTION_FPR_32        },
  { "mfpr-64",		no_argument,		NULL, OPTION_FPR_64        },
  { "mhard-float",	no_argument,		NULL, OPTION_FPR_64        },
  { "msoft-float",	no_argument,		NULL, OPTION_SOFT_FLOAT    },
  { "mdword",		no_argument,		NULL, OPTION_DWORD_YES     },
  { "mno-dword",	no_argument,		NULL, OPTION_DWORD_NO      },
  { "mdouble",		no_argument,		NULL, OPTION_DOUBLE        },
  { "mno-double",	no_argument,		NULL, OPTION_NO_DOUBLE     },
  { "mmedia",		no_argument,		NULL, OPTION_MEDIA         },
  { "mno-media",	no_argument,		NULL, OPTION_NO_MEDIA      },
  { "mcpu",		required_argument,	NULL, OPTION_CPU           },
  { "mpic",		no_argument,		NULL, OPTION_PIC           },
  { "mPIC",		no_argument,		NULL, OPTION_BIGPIC        },
  { "mlibrary-pic",	no_argument,		NULL, OPTION_LIBPIC        },
  { "mmuladd",		no_argument,		NULL, OPTION_MULADD        },
  { "mno-muladd",	no_argument,		NULL, OPTION_NO_MULADD     },
  { "mtomcat-debug",    no_argument,            NULL, OPTION_TOMCAT_DEBUG  },
  { "mtomcat-stats",	no_argument,		NULL, OPTION_TOMCAT_STATS  },
  { "mpack",        	no_argument,		NULL, OPTION_PACK          },
  { "mno-pack",        	no_argument,		NULL, OPTION_NO_PACK       },
  { "mfdpic",		no_argument,		NULL, OPTION_FDPIC	   },
  { "mnopic",		no_argument,		NULL, OPTION_NOPIC	   },
  { NULL,		no_argument,		NULL, 0                 },
};

size_t md_longopts_size = sizeof (md_longopts);

/* What value to give to bfd_set_gp_size.  */
static int g_switch_value = 8;

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    default:
      return 0;

    case 'G':
      g_switch_value = atoi (arg);
      if (! g_switch_value)
	frv_flags |= EF_FRV_G0;
      break;

    case OPTION_GPR_32:
      frv_flags = (frv_flags & ~EF_FRV_GPR_MASK) | EF_FRV_GPR_32;
      break;

    case OPTION_GPR_64:
      frv_flags = (frv_flags & ~EF_FRV_GPR_MASK) | EF_FRV_GPR_64;
      break;

    case OPTION_FPR_32:
      frv_flags = (frv_flags & ~EF_FRV_FPR_MASK) | EF_FRV_FPR_32;
      break;

    case OPTION_FPR_64:
      frv_flags = (frv_flags & ~EF_FRV_FPR_MASK) | EF_FRV_FPR_64;
      break;

    case OPTION_SOFT_FLOAT:
      frv_flags = (frv_flags & ~EF_FRV_FPR_MASK) | EF_FRV_FPR_NONE;
      break;

    case OPTION_DWORD_YES:
      frv_flags = (frv_flags & ~EF_FRV_DWORD_MASK) | EF_FRV_DWORD_YES;
      break;

    case OPTION_DWORD_NO:
      frv_flags = (frv_flags & ~EF_FRV_DWORD_MASK) | EF_FRV_DWORD_NO;
      break;

    case OPTION_DOUBLE:
      frv_flags |= EF_FRV_DOUBLE;
      break;

    case OPTION_NO_DOUBLE:
      frv_flags &= ~EF_FRV_DOUBLE;
      break;

    case OPTION_MEDIA:
      frv_flags |= EF_FRV_MEDIA;
      break;

    case OPTION_NO_MEDIA:
      frv_flags &= ~EF_FRV_MEDIA;
      break;

    case OPTION_MULADD:
      frv_flags |= EF_FRV_MULADD;
      break;

    case OPTION_NO_MULADD:
      frv_flags &= ~EF_FRV_MULADD;
      break;

    case OPTION_PACK:
      frv_flags &= ~EF_FRV_NOPACK;
      break;

    case OPTION_NO_PACK:
      frv_flags |= EF_FRV_NOPACK;
      break;

    case OPTION_CPU:
      {
	char *p;
	int cpu_flags = EF_FRV_CPU_GENERIC;

	/* Identify the processor type */
	p = arg;
	if (strcmp (p, "frv") == 0)
	  {
	    cpu_flags = EF_FRV_CPU_GENERIC;
	    frv_mach = bfd_mach_frv;
	  }

	else if (strcmp (p, "fr500") == 0)
	  {
	    cpu_flags = EF_FRV_CPU_FR500;
	    frv_mach = bfd_mach_fr500;
	  }

	else if (strcmp (p, "fr550") == 0)
	  {
	    cpu_flags = EF_FRV_CPU_FR550;
	    frv_mach = bfd_mach_fr550;
	  }

	else if (strcmp (p, "fr450") == 0)
	  {
	    cpu_flags = EF_FRV_CPU_FR450;
	    frv_mach = bfd_mach_fr450;
	  }

	else if (strcmp (p, "fr405") == 0)
	  {
	    cpu_flags = EF_FRV_CPU_FR405;
	    frv_mach = bfd_mach_fr400;
	    fr400_audio = TRUE;
	  }

	else if (strcmp (p, "fr400") == 0)
	  {
	    cpu_flags = EF_FRV_CPU_FR400;
	    frv_mach = bfd_mach_fr400;
	    fr400_audio = FALSE;
	  }

	else if (strcmp (p, "fr300") == 0)
	  {
	    cpu_flags = EF_FRV_CPU_FR300;
	    frv_mach = bfd_mach_fr300;
	  }

	else if (strcmp (p, "simple") == 0)
	  {
	    cpu_flags = EF_FRV_CPU_SIMPLE;
	    frv_mach = bfd_mach_frvsimple;
	    frv_flags |= EF_FRV_NOPACK;
	  }

        else if (strcmp (p, "tomcat") == 0)
          {
            cpu_flags = EF_FRV_CPU_TOMCAT;
            frv_mach = bfd_mach_frvtomcat;
          }

	else
	  {
	    as_fatal (_("Unknown cpu -mcpu=%s"), arg);
	    return 0;
	  }

	frv_flags = (frv_flags & ~EF_FRV_CPU_MASK) | cpu_flags;
      }
      break;

    case OPTION_PIC:
      frv_flags |= EF_FRV_PIC;
      frv_pic_p = 1;
      frv_pic_flag = "-fpic";
      break;

    case OPTION_BIGPIC:
      frv_flags |= EF_FRV_BIGPIC;
      frv_pic_p = 1;
      frv_pic_flag = "-fPIC";
      break;

    case OPTION_LIBPIC:
      frv_flags |= (EF_FRV_LIBPIC | EF_FRV_G0);
      frv_pic_p = 1;
      frv_pic_flag = "-mlibrary-pic";
      g_switch_value = 0;
      break;

    case OPTION_FDPIC:
      frv_flags |= EF_FRV_FDPIC;
      frv_pic_flag = "-mfdpic";
      break;

    case OPTION_NOPIC:
      frv_flags &= ~(EF_FRV_FDPIC | EF_FRV_PIC
		     | EF_FRV_BIGPIC | EF_FRV_LIBPIC);
      frv_pic_flag = 0;
      break;

    case OPTION_TOMCAT_DEBUG:
      tomcat_debug = 1;
      break;

    case OPTION_TOMCAT_STATS:
      tomcat_stats = 1;
      break;
    }

  return 1;
}

void
md_show_usage (FILE * stream)
{
  fprintf (stream, _("FRV specific command line options:\n"));
  fprintf (stream, _("-G n            Put data <= n bytes in the small data area\n"));
  fprintf (stream, _("-mgpr-32        Mark generated file as only using 32 GPRs\n"));
  fprintf (stream, _("-mgpr-64        Mark generated file as using all 64 GPRs\n"));
  fprintf (stream, _("-mfpr-32        Mark generated file as only using 32 FPRs\n"));
  fprintf (stream, _("-mfpr-64        Mark generated file as using all 64 FPRs\n"));
  fprintf (stream, _("-msoft-float    Mark generated file as using software FP\n"));
  fprintf (stream, _("-mdword         Mark generated file as using a 8-byte stack alignment\n"));
  fprintf (stream, _("-mno-dword      Mark generated file as using a 4-byte stack alignment\n"));
  fprintf (stream, _("-mdouble        Mark generated file as using double precision FP insns\n"));
  fprintf (stream, _("-mmedia         Mark generated file as using media insns\n"));
  fprintf (stream, _("-mmuladd        Mark generated file as using multiply add/subtract insns\n"));
  fprintf (stream, _("-mpack          Allow instructions to be packed\n"));
  fprintf (stream, _("-mno-pack       Do not allow instructions to be packed\n"));
  fprintf (stream, _("-mpic           Mark generated file as using small position independent code\n"));
  fprintf (stream, _("-mPIC           Mark generated file as using large position independent code\n"));
  fprintf (stream, _("-mlibrary-pic   Mark generated file as using position indepedent code for libraries\n"));
  fprintf (stream, _("-mfdpic         Assemble for the FDPIC ABI\n"));
  fprintf (stream, _("-mnopic         Disable -mpic, -mPIC, -mlibrary-pic and -mfdpic\n"));
  fprintf (stream, _("-mcpu={fr500|fr550|fr400|fr405|fr450|fr300|frv|simple|tomcat}\n"));
  fprintf (stream, _("                Record the cpu type\n"));
  fprintf (stream, _("-mtomcat-stats  Print out stats for tomcat workarounds\n"));
  fprintf (stream, _("-mtomcat-debug  Debug tomcat workarounds\n"));
} 


void
md_begin (void)
{
  /* Initialize the `cgen' interface.  */
  
  /* Set the machine number and endian.  */
  gas_cgen_cpu_desc = frv_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, 0,
					 CGEN_CPU_OPEN_ENDIAN,
					 CGEN_ENDIAN_BIG,
					 CGEN_CPU_OPEN_END);
  frv_cgen_init_asm (gas_cgen_cpu_desc);

  /* This is a callback from cgen to gas to parse operands.  */
  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);

  /* Set the ELF flags if desired. */
  if (frv_flags)
    bfd_set_private_flags (stdoutput, frv_flags);

  /* Set the machine type */
  bfd_default_set_arch_mach (stdoutput, bfd_arch_frv, frv_mach);

  /* Set up gp size so we can put local common items in .sbss */
  bfd_set_gp_size (stdoutput, g_switch_value);

  frv_vliw_reset (& vliw, frv_mach, frv_flags);
}

bfd_boolean
frv_md_fdpic_enabled (void)
{
  return (frv_flags & EF_FRV_FDPIC) != 0;
}

int chain_num = 0;

static struct vliw_insn_list *
frv_insert_vliw_insn (bfd_boolean count)
{
  struct vliw_insn_list *vliw_insn_list_entry;
  struct vliw_chain     *vliw_chain_entry;

  if (current_vliw_chain == NULL)
    {
      vliw_chain_entry = (struct vliw_chain *) xmalloc (sizeof (struct vliw_chain));
      vliw_chain_entry->insn_count = 0;
      vliw_chain_entry->insn_list  = NULL;
      vliw_chain_entry->next       = NULL;
      vliw_chain_entry->num        = chain_num++;

      if (!vliw_chain_top)
	vliw_chain_top = vliw_chain_entry;
      current_vliw_chain = vliw_chain_entry;
      if (previous_vliw_chain)
	previous_vliw_chain->next = vliw_chain_entry;
    }

  vliw_insn_list_entry = (struct vliw_insn_list *) xmalloc (sizeof (struct vliw_insn_list));
  vliw_insn_list_entry->type      = VLIW_GENERIC_TYPE;
  vliw_insn_list_entry->insn      = NULL;
  vliw_insn_list_entry->sym       = NULL;
  vliw_insn_list_entry->snop_frag = NULL;
  vliw_insn_list_entry->dnop_frag = NULL;
  vliw_insn_list_entry->next      = NULL;

  if (count)
    current_vliw_chain->insn_count++;

  if (current_vliw_insn)
    current_vliw_insn->next = vliw_insn_list_entry;
  current_vliw_insn = vliw_insn_list_entry;

  if (!current_vliw_chain->insn_list)
    current_vliw_chain->insn_list = current_vliw_insn;

  return vliw_insn_list_entry;
}

  /* Identify the following cases:
 
     1) A VLIW insn that contains both a branch and the branch destination.
        This requires the insertion of two vliw instructions before the
        branch.  The first consists of two nops.  The second consists of
        a single nop.
 
     2) A single instruction VLIW insn which is the destination of a branch
        that is in the next VLIW insn.  This requires the insertion of a vliw
        insn containing two nops before the branch.
 
     3) A double instruction VLIW insn which contains the destination of a
        branch that is in the next VLIW insn.  This requires the insertion of
        a VLIW insn containing a single nop before the branch.
 
     4) A single instruction VLIW insn which contains branch destination (x),
        followed by a single instruction VLIW insn which does not contain
        the branch to (x), followed by a VLIW insn which does contain the branch
        to (x).  This requires the insertion of a VLIW insn containing a single
        nop before the VLIW instruction containing the branch.
 
  */
#define FRV_IS_NOP(insn) (insn.buffer[0] == FRV_NOP_PACK || insn.buffer[0] == FRV_NOP_NOPACK)
#define FRV_NOP_PACK   0x00880000  /* ori.p  gr0,0,gr0 */
#define FRV_NOP_NOPACK 0x80880000  /* ori    gr0,0,gr0 */

/* Check a vliw insn for an insn of type containing the sym passed in label_sym.  */

static struct vliw_insn_list *
frv_find_in_vliw (enum vliw_insn_type vliw_insn_type,
		  struct vliw_chain *this_chain,
		  symbolS *label_sym)
{

  struct vliw_insn_list *the_insn;

  if (!this_chain)
    return NULL;

  for (the_insn = this_chain->insn_list; the_insn; the_insn = the_insn->next)
    {
      if (the_insn->type == vliw_insn_type
	  && the_insn->sym == label_sym)
	return the_insn;
    }

  return NULL;
}

enum vliw_nop_type
{
  /* A Vliw insn containing a single nop insn.  */
  VLIW_SINGLE_NOP,
  
  /* A Vliw insn containing two nop insns.  */
  VLIW_DOUBLE_NOP,

  /* Two vliw insns.  The first containing two nop insns.  
     The second contain a single nop insn.  */
  VLIW_DOUBLE_THEN_SINGLE_NOP
};

static void
frv_debug_tomcat (struct vliw_chain *start_chain)
{
   struct vliw_chain *this_chain;
   struct vliw_insn_list *this_insn;
   int i = 1;

  for (this_chain = start_chain; this_chain; this_chain = this_chain->next, i++)
    {
      fprintf (stderr, "\nVliw Insn #%d, #insns: %d\n", i, this_chain->insn_count);

      for (this_insn = this_chain->insn_list; this_insn; this_insn = this_insn->next)
	{
	  if (this_insn->type == VLIW_LABEL_TYPE)
	    fprintf (stderr, "Label Value: %p\n", this_insn->sym);
	  else if (this_insn->type == VLIW_BRANCH_TYPE)
	    fprintf (stderr, "%s to %p\n", this_insn->insn->base->name, this_insn->sym);
	  else if (this_insn->type == VLIW_BRANCH_HAS_NOPS)
	    fprintf (stderr, "nop'd %s to %p\n", this_insn->insn->base->name, this_insn->sym);
	  else if (this_insn->type == VLIW_NOP_TYPE)
	    fprintf (stderr, "Nop\n");
	  else
	    fprintf (stderr, "	%s\n", this_insn->insn->base->name);
	}
   }
}

static void
frv_adjust_vliw_count (struct vliw_chain *this_chain)
{
  struct vliw_insn_list *this_insn;

  this_chain->insn_count = 0;

  for (this_insn = this_chain->insn_list;
       this_insn;
       this_insn = this_insn->next)
    {
      if (this_insn->type != VLIW_LABEL_TYPE)
  	this_chain->insn_count++;
    }

}

/* Insert the desired nop combination in the vliw chain before insert_before_insn.
   Rechain the vliw insn.  */

static struct vliw_chain *
frv_tomcat_shuffle (enum vliw_nop_type this_nop_type,
		    struct vliw_chain *vliw_to_split,
		    struct vliw_insn_list *insert_before_insn)
{

  bfd_boolean pack_prev = FALSE;
  struct vliw_chain *return_me = NULL;
  struct vliw_insn_list *prev_insn = NULL;
  struct vliw_insn_list *curr_insn = vliw_to_split->insn_list;

  struct vliw_chain *double_nop = (struct vliw_chain *) xmalloc (sizeof (struct vliw_chain));
  struct vliw_chain *single_nop = (struct vliw_chain *) xmalloc (sizeof (struct vliw_chain));
  struct vliw_chain *second_part = (struct vliw_chain *) xmalloc (sizeof (struct vliw_chain));
  struct vliw_chain *curr_vliw = vliw_chain_top;
  struct vliw_chain *prev_vliw = NULL;

  while (curr_insn && curr_insn != insert_before_insn)
    {
      /* We can't set the packing bit on a label.  If we have the case
	 label 1:
	 label 2:
	 label 3:
	   branch that needs nops
	Then don't set pack bit later.  */

      if (curr_insn->type != VLIW_LABEL_TYPE)
	pack_prev = TRUE;
      prev_insn = curr_insn;
      curr_insn = curr_insn->next;
    } 

  while (curr_vliw && curr_vliw != vliw_to_split)
    {
      prev_vliw = curr_vliw;
      curr_vliw = curr_vliw->next;
    }

  switch (this_nop_type)
    {
    case VLIW_SINGLE_NOP:
      if (!prev_insn)
	{
	/* Branch is first,  Insert the NOP prior to this vliw insn.  */
	if (prev_vliw)
	  prev_vliw->next = single_nop;
	else
	  vliw_chain_top = single_nop;
	single_nop->next = vliw_to_split;
	vliw_to_split->insn_list->type = VLIW_BRANCH_HAS_NOPS;
	return_me = vliw_to_split;
	}
      else
	{
	  /* Set the packing bit on the previous insn.  */
	  if (pack_prev)
	    {
	      char *buffer = prev_insn->address;
	      buffer[0] |= 0x80;
	    }
	  /* The branch is in the middle.  Split this vliw insn into first
	     and second parts.  Insert the NOP inbetween.  */

          second_part->insn_list = insert_before_insn;
	  second_part->insn_list->type = VLIW_BRANCH_HAS_NOPS;
          second_part->next      = vliw_to_split->next;
 	  frv_adjust_vliw_count (second_part);

          single_nop->next       = second_part;
 
          vliw_to_split->next    = single_nop;
          prev_insn->next        = NULL;
 
          return_me = second_part;
	  frv_adjust_vliw_count (vliw_to_split);
	}
      break;

    case VLIW_DOUBLE_NOP:
      if (!prev_insn)
	{
	/* Branch is first,  Insert the NOP prior to this vliw insn.  */
        if (prev_vliw)
          prev_vliw->next = double_nop;
        else
          vliw_chain_top = double_nop;

	double_nop->next = vliw_to_split;
	return_me = vliw_to_split;
	vliw_to_split->insn_list->type = VLIW_BRANCH_HAS_NOPS;
	}
      else
	{
	  /* Set the packing bit on the previous insn.  */
	  if (pack_prev)
	    {
	      char *buffer = prev_insn->address;
	      buffer[0] |= 0x80;
	    }

	/* The branch is in the middle.  Split this vliw insn into first
	   and second parts.  Insert the NOP inbetween.  */
          second_part->insn_list = insert_before_insn;
	  second_part->insn_list->type = VLIW_BRANCH_HAS_NOPS;
          second_part->next      = vliw_to_split->next;
 	  frv_adjust_vliw_count (second_part);
 
          double_nop->next       = second_part;
 
          vliw_to_split->next    = single_nop;
          prev_insn->next        = NULL;
 	  frv_adjust_vliw_count (vliw_to_split);
 
          return_me = second_part;
	}
      break;

    case VLIW_DOUBLE_THEN_SINGLE_NOP:
      double_nop->next = single_nop;
      double_nop->insn_count = 2;
      double_nop->insn_list = &double_nop_insn;
      single_nop->insn_count = 1;
      single_nop->insn_list = &single_nop_insn;

      if (!prev_insn)
	{
	  /* The branch is the first insn in this vliw.  Don't split the vliw.  Insert
	     the nops prior to this vliw.  */
          if (prev_vliw)
            prev_vliw->next = double_nop;
          else
            vliw_chain_top = double_nop;
 
	  single_nop->next = vliw_to_split;
	  return_me = vliw_to_split;
	  vliw_to_split->insn_list->type = VLIW_BRANCH_HAS_NOPS;
	}
      else
	{
	  /* Set the packing bit on the previous insn.  */
	  if (pack_prev)
	    {
	      char *buffer = prev_insn->address;
	      buffer[0] |= 0x80;
	    }

	  /* The branch is in the middle of this vliw insn.  Split into first and
	     second parts.  Insert the nop vliws in between.  */  
	  second_part->insn_list = insert_before_insn;
	  second_part->insn_list->type = VLIW_BRANCH_HAS_NOPS;
	  second_part->next      = vliw_to_split->next;
 	  frv_adjust_vliw_count (second_part);

	  single_nop->next       = second_part;

	  vliw_to_split->next	 = double_nop;
	  prev_insn->next	 = NULL;
 	  frv_adjust_vliw_count (vliw_to_split);

	  return_me = second_part;
	}
      break;
    }

  return return_me;
}

static void
frv_tomcat_analyze_vliw_chains (void)
{
  struct vliw_chain *vliw1 = NULL;
  struct vliw_chain *vliw2 = NULL;
  struct vliw_chain *vliw3 = NULL;

  struct vliw_insn_list *this_insn = NULL;
  struct vliw_insn_list *temp_insn = NULL;

  /* We potentially need to look at three VLIW insns to determine if the
     workaround is required.  Set them up.  Ignore existing nops during analysis. */

#define FRV_SET_VLIW_WINDOW(VLIW1, VLIW2, VLIW3) \
  if (VLIW1 && VLIW1->next)			 \
    VLIW2 = VLIW1->next;			 \
  else						 \
    VLIW2 = NULL;				 \
  if (VLIW2 && VLIW2->next)			 \
    VLIW3 = VLIW2->next;			 \
  else						 \
    VLIW3 = NULL

  vliw1 = vliw_chain_top;

workaround_top:

  FRV_SET_VLIW_WINDOW (vliw1, vliw2, vliw3);

  if (!vliw1)
    return;

  if (vliw1->insn_count == 1)
    {
      /* check vliw1 for a label. */
      if (vliw1->insn_list->type == VLIW_LABEL_TYPE)
	{
	  temp_insn = frv_find_in_vliw (VLIW_BRANCH_TYPE, vliw2, vliw1->insn_list->sym);
	  if (temp_insn)
	    {
	      vliw1 = frv_tomcat_shuffle (VLIW_DOUBLE_NOP, vliw2, vliw1->insn_list);
	      temp_insn->dnop_frag->fr_subtype = NOP_KEEP;
	      vliw1 = vliw1->next;
	      if (tomcat_stats)
		tomcat_doubles++;
	      goto workaround_top;
	    }
	  else if (vliw2 
		   && vliw2->insn_count == 1
		   && (temp_insn = frv_find_in_vliw (VLIW_BRANCH_TYPE, vliw3, vliw1->insn_list->sym)) != NULL)
	    {
	      temp_insn->snop_frag->fr_subtype = NOP_KEEP;
	      vliw1 = frv_tomcat_shuffle (VLIW_SINGLE_NOP, vliw3, vliw3->insn_list);
	      if (tomcat_stats)
		tomcat_singles++;
	      goto workaround_top;
	    }
	}
    }

  if (vliw1->insn_count == 2)
    {
      /* Check vliw1 for a label. */
      for (this_insn = vliw1->insn_list; this_insn; this_insn = this_insn->next)
	{
	  if (this_insn->type == VLIW_LABEL_TYPE)
	    {
	      if ((temp_insn = frv_find_in_vliw (VLIW_BRANCH_TYPE, vliw2, this_insn->sym)) != NULL)
		{
		  temp_insn->snop_frag->fr_subtype = NOP_KEEP;
		  vliw1 = frv_tomcat_shuffle (VLIW_SINGLE_NOP, vliw2, this_insn);
		  if (tomcat_stats)
		    tomcat_singles++;
		}
	      else
		vliw1 = vliw1->next;
              goto workaround_top;
            }
	}
    }
  /* Examine each insn in this VLIW.  Look for the workaround criteria.  */
  for (this_insn = vliw1->insn_list; this_insn; this_insn = this_insn->next)
    {
      /* Don't look at labels or nops.  */
      while (this_insn
	     && (this_insn->type == VLIW_LABEL_TYPE
                 || this_insn->type == VLIW_NOP_TYPE
		 || this_insn->type == VLIW_BRANCH_HAS_NOPS))
	this_insn = this_insn->next;

      if (!this_insn)
        {
	  vliw1 = vliw2;
	  goto workaround_top;
	}

      if (frv_is_branch_insn (this_insn->insn))
	{
	  if ((temp_insn = frv_find_in_vliw (VLIW_LABEL_TYPE, vliw1, this_insn->sym)) != NULL)
	    {
	      /* Insert [nop/nop] [nop] before branch.  */
	      this_insn->snop_frag->fr_subtype = NOP_KEEP;
	      this_insn->dnop_frag->fr_subtype = NOP_KEEP;
	      vliw1 = frv_tomcat_shuffle (VLIW_DOUBLE_THEN_SINGLE_NOP, vliw1, this_insn);
	      goto workaround_top;
	    }
	}


    }
  /* This vliw insn checks out okay.  Take a look at the next one.  */
  vliw1 = vliw1->next;
  goto workaround_top;
}

void
frv_tomcat_workaround (void)
{
  if (frv_mach != bfd_mach_frvtomcat)
    return;

  if (tomcat_debug)
    frv_debug_tomcat (vliw_chain_top);

  frv_tomcat_analyze_vliw_chains ();

  if (tomcat_stats)
    {
      fprintf (stderr, "Inserted %d Single Nops\n", tomcat_singles);
      fprintf (stderr, "Inserted %d Double Nops\n", tomcat_doubles);
    }
}

static int
fr550_check_insn_acc_range (frv_insn *insn, int low, int hi)
{
  int acc;
  switch (CGEN_INSN_NUM (insn->insn))
    {
    case FRV_INSN_MADDACCS:
    case FRV_INSN_MSUBACCS:
    case FRV_INSN_MDADDACCS:
    case FRV_INSN_MDSUBACCS:
    case FRV_INSN_MASACCS:
    case FRV_INSN_MDASACCS:
      acc = insn->fields.f_ACC40Si;
      if (acc < low || acc > hi)
	return 1; /* out of range */
      acc = insn->fields.f_ACC40Sk;
      if (acc < low || acc > hi)
	return 1; /* out of range */
      break;
    case FRV_INSN_MMULHS:
    case FRV_INSN_MMULHU:
    case FRV_INSN_MMULXHS:
    case FRV_INSN_MMULXHU:
    case FRV_INSN_CMMULHS:
    case FRV_INSN_CMMULHU:
    case FRV_INSN_MQMULHS:
    case FRV_INSN_MQMULHU:
    case FRV_INSN_MQMULXHS:
    case FRV_INSN_MQMULXHU:
    case FRV_INSN_CMQMULHS:
    case FRV_INSN_CMQMULHU:
    case FRV_INSN_MMACHS:
    case FRV_INSN_MMRDHS:
    case FRV_INSN_CMMACHS: 
    case FRV_INSN_MQMACHS:
    case FRV_INSN_CMQMACHS:
    case FRV_INSN_MQXMACHS:
    case FRV_INSN_MQXMACXHS:
    case FRV_INSN_MQMACXHS:
    case FRV_INSN_MCPXRS:
    case FRV_INSN_MCPXIS:
    case FRV_INSN_CMCPXRS:
    case FRV_INSN_CMCPXIS:
    case FRV_INSN_MQCPXRS:
    case FRV_INSN_MQCPXIS:
     acc = insn->fields.f_ACC40Sk;
      if (acc < low || acc > hi)
	return 1; /* out of range */
      break;
    case FRV_INSN_MMACHU:
    case FRV_INSN_MMRDHU:
    case FRV_INSN_CMMACHU:
    case FRV_INSN_MQMACHU:
    case FRV_INSN_CMQMACHU:
    case FRV_INSN_MCPXRU:
    case FRV_INSN_MCPXIU:
    case FRV_INSN_CMCPXRU:
    case FRV_INSN_CMCPXIU:
    case FRV_INSN_MQCPXRU:
    case FRV_INSN_MQCPXIU:
      acc = insn->fields.f_ACC40Uk;
      if (acc < low || acc > hi)
	return 1; /* out of range */
      break;
    default:
      break;
    }
  return 0; /* all is ok */
}

static int
fr550_check_acc_range (FRV_VLIW *vlw, frv_insn *insn)
{
  switch ((*vlw->current_vliw)[vlw->next_slot - 1])
    {
    case UNIT_FM0:
    case UNIT_FM2:
      return fr550_check_insn_acc_range (insn, 0, 3);
    case UNIT_FM1:
    case UNIT_FM3:
      return fr550_check_insn_acc_range (insn, 4, 7);
    default:
      break;
    }
  return 0; /* all is ok */
}

/* Return true if the target implements instruction INSN.  */

static bfd_boolean
target_implements_insn_p (const CGEN_INSN *insn)
{
  switch (frv_mach)
    {
    default:
      /* bfd_mach_frv or generic.  */
      return TRUE;

    case bfd_mach_fr300:
    case bfd_mach_frvsimple:
      return CGEN_INSN_MACH_HAS_P (insn, MACH_SIMPLE);

    case bfd_mach_fr400:
      return ((fr400_audio || !CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_AUDIO))
	      && CGEN_INSN_MACH_HAS_P (insn, MACH_FR400));

    case bfd_mach_fr450:
      return CGEN_INSN_MACH_HAS_P (insn, MACH_FR450);

    case bfd_mach_fr500:
      return CGEN_INSN_MACH_HAS_P (insn, MACH_FR500);

    case bfd_mach_fr550:
      return CGEN_INSN_MACH_HAS_P (insn, MACH_FR550);
    }
}

void
md_assemble (char *str)
{
  frv_insn insn;
  char *errmsg;
  int packing_constraint;
  finished_insnS  finished_insn;
  fragS *double_nop_frag = NULL;
  fragS *single_nop_frag = NULL;
  struct vliw_insn_list *vliw_insn_list_entry = NULL;

  /* Initialize GAS's cgen interface for a new instruction.  */
  gas_cgen_init_parse ();

  memset (&insn, 0, sizeof (insn));

  insn.insn = frv_cgen_assemble_insn
    (gas_cgen_cpu_desc, str, & insn.fields, insn.buffer, &errmsg);
  
  if (!insn.insn)
    {
      as_bad ("%s", errmsg);
      return;
    }
  
  /* If the cpu is tomcat, then we need to insert nops to workaround
     hardware limitations.  We need to keep track of each vliw unit
     and examine the length of the unit and the individual insns
     within the unit to determine the number and location of the
     required nops.  */
  if (frv_mach == bfd_mach_frvtomcat)
    {
      /* If we've just finished a VLIW insn OR this is a branch,
	 then start up a new frag.  Fill it with nops.  We will get rid
	 of those that are not required after we've seen all of the 
	 instructions but before we start resolving fixups.  */
      if ( !FRV_IS_NOP (insn)
	  && (frv_is_branch_insn (insn.insn) || insn.fields.f_pack))
	{
	  char *buffer;

	  frag_wane (frag_now);
	  frag_new (0);
	  double_nop_frag = frag_now;
	  buffer = frag_var (rs_machine_dependent, 8, 8, NOP_DELETE, NULL, 0, 0);
	  md_number_to_chars (buffer, FRV_NOP_PACK, 4);
	  md_number_to_chars (buffer+4, FRV_NOP_NOPACK, 4);

	  frag_wane (frag_now);
	  frag_new (0);
	  single_nop_frag = frag_now;
	  buffer = frag_var (rs_machine_dependent, 4, 4, NOP_DELETE, NULL, 0, 0);
	  md_number_to_chars (buffer, FRV_NOP_NOPACK, 4);
	}

      vliw_insn_list_entry = frv_insert_vliw_insn (DO_COUNT);
      vliw_insn_list_entry->insn   = insn.insn;
      if (frv_is_branch_insn (insn.insn))
	vliw_insn_list_entry->type = VLIW_BRANCH_TYPE;

      if ( !FRV_IS_NOP (insn)
	  && (frv_is_branch_insn (insn.insn) || insn.fields.f_pack))
	{
	  vliw_insn_list_entry->snop_frag = single_nop_frag;
	  vliw_insn_list_entry->dnop_frag = double_nop_frag;
	}
    }

  /* Make sure that this insn does not violate the VLIW packing constraints.  */
  /* -mno-pack disallows any packing whatsoever.  */
  if (frv_flags & EF_FRV_NOPACK)
    {
      if (! insn.fields.f_pack)
	{
	  as_bad (_("VLIW packing used for -mno-pack"));
	  return;
	}
    }
  /* -mcpu=FRV is an idealized FR-V implementation that supports all of the
     instructions, don't do vliw checking.  */
  else if (frv_mach != bfd_mach_frv)
    {
      if (!target_implements_insn_p (insn.insn))
	{
	  as_bad (_("Instruction not supported by this architecture"));
	  return;
	}
      packing_constraint = frv_vliw_add_insn (& vliw, insn.insn);
      if (frv_mach == bfd_mach_fr550 && ! packing_constraint)
	packing_constraint = fr550_check_acc_range (& vliw, & insn);
      if (insn.fields.f_pack)
	frv_vliw_reset (& vliw, frv_mach, frv_flags);
      if (packing_constraint)
	{
	  as_bad (_("VLIW packing constraint violation"));
	  return;
	}
    }

  /* Doesn't really matter what we pass for RELAX_P here.  */
  gas_cgen_finish_insn (insn.insn, insn.buffer,
			CGEN_FIELDS_BITSIZE (& insn.fields), 1, &finished_insn);


  /* If the cpu is tomcat, then we need to insert nops to workaround
     hardware limitations.  We need to keep track of each vliw unit
     and examine the length of the unit and the individual insns
     within the unit to determine the number and location of the
     required nops.  */
  if (frv_mach == bfd_mach_frvtomcat)
    {
      if (vliw_insn_list_entry)
        vliw_insn_list_entry->address = finished_insn.addr;
      else
	abort();

      if (insn.fields.f_pack)
	{
	  /* We've completed a VLIW insn.  */
	  previous_vliw_chain = current_vliw_chain;
	  current_vliw_chain = NULL;
	  current_vliw_insn  = NULL;
        } 
    }
}

/* The syntax in the manual says constants begin with '#'.
   We just ignore it.  */

void 
md_operand (expressionS *expressionP)
{
  if (* input_line_pointer == '#')
    {
      input_line_pointer ++;
      expression (expressionP);
    }
}

valueT
md_section_align (segT segment, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Interface to relax_segment.  */

/* FIXME: Build table by hand, get it working, then machine generate.  */
const relax_typeS md_relax_table[] =
{
  {1, 1, 0, 0},
  {511 - 2 - 2, -512 - 2 + 2, 0, 2 },
  {0x2000000 - 1 - 2, -0x2000000 - 2, 2, 0 },
  {0x2000000 - 1 - 2, -0x2000000 - 2, 4, 0 }
};

long
frv_relax_frag (fragS *fragP ATTRIBUTE_UNUSED, long stretch ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Return an initial guess of the length by which a fragment must grow to
   hold a branch to reach its destination.
   Also updates fr_type/fr_subtype as necessary.

   Called just before doing relaxation.
   Any symbol that is now undefined will not become defined.
   The guess for fr_var is ACTUALLY the growth beyond fr_fix.
   Whatever we do to grow fr_fix or fr_var contributes to our returned value.
   Although it may not be explicit in the frag, pretend fr_var starts with a
   0 value.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment ATTRIBUTE_UNUSED)
{
  switch (fragP->fr_subtype)
    {
    case NOP_KEEP:
      return fragP->fr_var;

    default:
    case NOP_DELETE:
      return 0;
    }     
} 

/* *fragP has been relaxed to its final size, and now needs to have
   the bytes inside it modified to conform to the new size.

   Called after relaxation is finished.
   fragP->fr_type == rs_machine_dependent.
   fragP->fr_subtype is the subtype of what the address relaxed to.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  switch (fragP->fr_subtype)
    {
    default:
    case NOP_DELETE:
      return;

    case NOP_KEEP:
      fragP->fr_fix = fragP->fr_var;
      fragP->fr_var = 0;
      return;   
    }
}

/* Functions concerning relocs.  */

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from_section (fixS *fixP, segT sec)
{
  if (TC_FORCE_RELOCATION (fixP)
      || (fixP->fx_addsy != (symbolS *) NULL
	  && S_GET_SEGMENT (fixP->fx_addsy) != sec))
    {
      /* If we can't adjust this relocation, or if it references a
	 local symbol in a different section (which
	 TC_FORCE_RELOCATION can't check), let the linker figure it
	 out.  */
      return 0;
    }

  return (fixP->fx_frag->fr_address + fixP->fx_where) & ~1;
}

/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
   Returns BFD_RELOC_NONE if no reloc type can be found.
   *FIXP may be modified if desired.  */

bfd_reloc_code_real_type
md_cgen_lookup_reloc (const CGEN_INSN *insn ATTRIBUTE_UNUSED,
		      const CGEN_OPERAND *operand,
		      fixS *fixP)
{
  switch (operand->type)
    {
    case FRV_OPERAND_LABEL16:
      fixP->fx_pcrel = TRUE;
      return BFD_RELOC_FRV_LABEL16;

    case FRV_OPERAND_LABEL24:
      fixP->fx_pcrel = TRUE;

      if (fixP->fx_cgen.opinfo != 0)
	return fixP->fx_cgen.opinfo;

      return BFD_RELOC_FRV_LABEL24;

    case FRV_OPERAND_UHI16:
    case FRV_OPERAND_ULO16:
    case FRV_OPERAND_SLO16:
    case FRV_OPERAND_CALLANN:
    case FRV_OPERAND_LDANN:
    case FRV_OPERAND_LDDANN:
      /* The relocation type should be recorded in opinfo */
      if (fixP->fx_cgen.opinfo != 0)
        return fixP->fx_cgen.opinfo;
      break;

    case FRV_OPERAND_D12:
    case FRV_OPERAND_S12:
      if (fixP->fx_cgen.opinfo != 0)
	return fixP->fx_cgen.opinfo;

      return BFD_RELOC_FRV_GPREL12;

    case FRV_OPERAND_U12:
      return BFD_RELOC_FRV_GPRELU12;

    default: 
      break;
    }
  return BFD_RELOC_NONE;
}


/* See whether we need to force a relocation into the output file.
   This is used to force out switch and PC relative relocations when
   relaxing.  */

int
frv_force_relocation (fixS *fix)
{
  switch (fix->fx_r_type < BFD_RELOC_UNUSED
	  ? (int) fix->fx_r_type
	  : fix->fx_cgen.opinfo)
    {
    case BFD_RELOC_FRV_GPREL12:
    case BFD_RELOC_FRV_GPRELU12:
    case BFD_RELOC_FRV_GPREL32:
    case BFD_RELOC_FRV_GPRELHI:
    case BFD_RELOC_FRV_GPRELLO:
    case BFD_RELOC_FRV_GOT12:
    case BFD_RELOC_FRV_GOTHI:
    case BFD_RELOC_FRV_GOTLO:
    case BFD_RELOC_FRV_FUNCDESC_VALUE:
    case BFD_RELOC_FRV_FUNCDESC_GOTOFF12:
    case BFD_RELOC_FRV_FUNCDESC_GOTOFFHI:
    case BFD_RELOC_FRV_FUNCDESC_GOTOFFLO:
    case BFD_RELOC_FRV_GOTOFF12:
    case BFD_RELOC_FRV_GOTOFFHI:
    case BFD_RELOC_FRV_GOTOFFLO:
    case BFD_RELOC_FRV_GETTLSOFF:
    case BFD_RELOC_FRV_TLSDESC_VALUE:
    case BFD_RELOC_FRV_GOTTLSDESC12:
    case BFD_RELOC_FRV_GOTTLSDESCHI:
    case BFD_RELOC_FRV_GOTTLSDESCLO:
    case BFD_RELOC_FRV_TLSMOFF12:
    case BFD_RELOC_FRV_TLSMOFFHI:
    case BFD_RELOC_FRV_TLSMOFFLO:
    case BFD_RELOC_FRV_GOTTLSOFF12:
    case BFD_RELOC_FRV_GOTTLSOFFHI:
    case BFD_RELOC_FRV_GOTTLSOFFLO:
    case BFD_RELOC_FRV_TLSOFF:
    case BFD_RELOC_FRV_TLSDESC_RELAX:
    case BFD_RELOC_FRV_GETTLSOFF_RELAX:
    case BFD_RELOC_FRV_TLSOFF_RELAX:
      return 1;

    default:
      break;
    }

  return generic_force_reloc (fix);
}

/* Apply a fixup that could be resolved within the assembler.  */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg)
{
  if (fixP->fx_addsy == 0)
    switch (fixP->fx_cgen.opinfo)
      {
      case BFD_RELOC_FRV_HI16:
	*valP >>= 16;
	/* Fall through.  */
      case BFD_RELOC_FRV_LO16:
	*valP &= 0xffff;
	break;

	/* We need relocations for these, even if their symbols reduce
	   to constants.  */
      case BFD_RELOC_FRV_GPREL12:
      case BFD_RELOC_FRV_GPRELU12:
      case BFD_RELOC_FRV_GPREL32:
      case BFD_RELOC_FRV_GPRELHI:
      case BFD_RELOC_FRV_GPRELLO:
      case BFD_RELOC_FRV_GOT12:
      case BFD_RELOC_FRV_GOTHI:
      case BFD_RELOC_FRV_GOTLO:
      case BFD_RELOC_FRV_FUNCDESC_VALUE:
      case BFD_RELOC_FRV_FUNCDESC_GOTOFF12:
      case BFD_RELOC_FRV_FUNCDESC_GOTOFFHI:
      case BFD_RELOC_FRV_FUNCDESC_GOTOFFLO:
      case BFD_RELOC_FRV_GOTOFF12:
      case BFD_RELOC_FRV_GOTOFFHI:
      case BFD_RELOC_FRV_GOTOFFLO:
      case BFD_RELOC_FRV_GETTLSOFF:
      case BFD_RELOC_FRV_TLSDESC_VALUE:
      case BFD_RELOC_FRV_GOTTLSDESC12:
      case BFD_RELOC_FRV_GOTTLSDESCHI:
      case BFD_RELOC_FRV_GOTTLSDESCLO:
      case BFD_RELOC_FRV_TLSMOFF12:
      case BFD_RELOC_FRV_TLSMOFFHI:
      case BFD_RELOC_FRV_TLSMOFFLO:
      case BFD_RELOC_FRV_GOTTLSOFF12:
      case BFD_RELOC_FRV_GOTTLSOFFHI:
      case BFD_RELOC_FRV_GOTTLSOFFLO:
      case BFD_RELOC_FRV_TLSOFF:
      case BFD_RELOC_FRV_TLSDESC_RELAX:
      case BFD_RELOC_FRV_GETTLSOFF_RELAX:
      case BFD_RELOC_FRV_TLSOFF_RELAX:
	fixP->fx_addsy = abs_section_sym;
	break;
      }
  else
    switch (fixP->fx_cgen.opinfo)
      {
      case BFD_RELOC_FRV_GETTLSOFF:
      case BFD_RELOC_FRV_TLSDESC_VALUE:
      case BFD_RELOC_FRV_GOTTLSDESC12:
      case BFD_RELOC_FRV_GOTTLSDESCHI:
      case BFD_RELOC_FRV_GOTTLSDESCLO:
      case BFD_RELOC_FRV_TLSMOFF12:
      case BFD_RELOC_FRV_TLSMOFFHI:
      case BFD_RELOC_FRV_TLSMOFFLO:
      case BFD_RELOC_FRV_GOTTLSOFF12:
      case BFD_RELOC_FRV_GOTTLSOFFHI:
      case BFD_RELOC_FRV_GOTTLSOFFLO:
      case BFD_RELOC_FRV_TLSOFF:
      case BFD_RELOC_FRV_TLSDESC_RELAX:
      case BFD_RELOC_FRV_GETTLSOFF_RELAX:
      case BFD_RELOC_FRV_TLSOFF_RELAX:
	/* Mark TLS symbols as such.  */
	if (S_GET_SEGMENT (fixP->fx_addsy) != absolute_section)
	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
	break;
      }

  gas_cgen_md_apply_fix (fixP, valP, seg);
  return;
}


/* Write a value out to the object file, using the appropriate endianness.  */

void
frv_md_number_to_chars (char *buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

bfd_boolean
frv_fix_adjustable (fixS *fixP)
{
  bfd_reloc_code_real_type reloc_type;

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      const CGEN_INSN *insn = NULL;
      int opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
      const CGEN_OPERAND *operand = cgen_operand_lookup_by_num(gas_cgen_cpu_desc, opindex);
      reloc_type = md_cgen_lookup_reloc (insn, operand, fixP);
    }
  else
    reloc_type = fixP->fx_r_type;

  /* We need the symbol name for the VTABLE entries */
  if (   reloc_type == BFD_RELOC_VTABLE_INHERIT
      || reloc_type == BFD_RELOC_VTABLE_ENTRY
      || reloc_type == BFD_RELOC_FRV_GPREL12
      || reloc_type == BFD_RELOC_FRV_GPRELU12)
    return 0;

  return 1;
}

/* Allow user to set flags bits.  */
void
frv_set_flags (int arg ATTRIBUTE_UNUSED)
{
  flagword new_flags = get_absolute_expression ();
  flagword new_mask = ~ (flagword)0;

  frv_user_set_flags_p = 1;
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      new_mask = get_absolute_expression ();
    }

  frv_flags = (frv_flags & ~new_mask) | (new_flags & new_mask);
  bfd_set_private_flags (stdoutput, frv_flags);
}

/* Frv specific function to handle 4 byte initializations for pointers that are
   considered 'safe' for use with pic support.  Until frv_frob_file{,_section}
   is run, we encode it a BFD_RELOC_CTOR, and it is turned back into a normal
   BFD_RELOC_32 at that time.  */

void
frv_pic_ptr (int nbytes)
{
  expressionS exp;
  char *p;

  if (nbytes != 4)
    abort ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  do
    {
      bfd_reloc_code_real_type reloc_type = BFD_RELOC_CTOR;
      
      if (strncasecmp (input_line_pointer, "funcdesc(", 9) == 0)
	{
	  input_line_pointer += 9;
	  expression (&exp);
	  if (*input_line_pointer == ')')
	    input_line_pointer++;
	  else
	    as_bad (_("missing ')'"));
	  reloc_type = BFD_RELOC_FRV_FUNCDESC;
	}
      else if (strncasecmp (input_line_pointer, "tlsmoff(", 8) == 0)
	{
	  input_line_pointer += 8;
	  expression (&exp);
	  if (*input_line_pointer == ')')
	    input_line_pointer++;
	  else
	    as_bad (_("missing ')'"));
	  reloc_type = BFD_RELOC_FRV_TLSMOFF;
	}
      else
	expression (&exp);

      p = frag_more (4);
      memset (p, 0, 4);
      fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &exp, 0,
		   reloc_type);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;			/* Put terminator back into stream. */
  demand_empty_rest_of_line ();
}



#ifdef DEBUG
#define DPRINTF1(A)	fprintf (stderr, A)
#define DPRINTF2(A,B)	fprintf (stderr, A, B)
#define DPRINTF3(A,B,C)	fprintf (stderr, A, B, C)

#else
#define DPRINTF1(A)
#define DPRINTF2(A,B)
#define DPRINTF3(A,B,C)
#endif

/* Go through a the sections looking for relocations that are problematical for
   pic.  If not pic, just note that this object can't be linked with pic.  If
   it is pic, see if it needs to be marked so that it will be fixed up, or if
   not possible, issue an error.  */

static void
frv_frob_file_section (bfd *abfd, asection *sec, void *ptr ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  fixS *fixp;
  CGEN_CPU_DESC cd = gas_cgen_cpu_desc;
  flagword flags = bfd_get_section_flags (abfd, sec);

  /* Skip relocations in known sections (.ctors, .dtors, and .gcc_except_table)
     since we can fix those up by hand.  */
  int known_section_p = (sec->name
			 && sec->name[0] == '.'
			 && ((sec->name[1] == 'c'
			      && strcmp (sec->name, ".ctor") == 0)
			     || (sec->name[1] == 'd'
				 && strcmp (sec->name, ".dtor") == 0)
			     || (sec->name[1] == 'g'
				 && strcmp (sec->name, ".gcc_except_table") == 0)));

  DPRINTF3 ("\nFrv section %s%s\n", sec->name, (known_section_p) ? ", known section" : "");
  if ((flags & SEC_ALLOC) == 0)
    {
      DPRINTF1 ("\tSkipping non-loaded section\n");
      return;
    }

  for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
    {
      symbolS *s = fixp->fx_addsy;
      bfd_reloc_code_real_type reloc;
      int non_pic_p;
      int opindex;
      const CGEN_OPERAND *operand;
      const CGEN_INSN *insn = fixp->fx_cgen.insn;

      if (fixp->fx_done)
	{
	  DPRINTF1 ("\tSkipping reloc that has already been done\n");
	  continue;
	}

      if (fixp->fx_pcrel)
	{
	  DPRINTF1 ("\tSkipping reloc that is PC relative\n");
	  continue;
	}

      if (! s)
	{
	  DPRINTF1 ("\tSkipping reloc without symbol\n");
	  continue;
	}

      if (fixp->fx_r_type < BFD_RELOC_UNUSED)
	{
	  opindex = -1;
	  reloc = fixp->fx_r_type;
	}
      else
	{
	  opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
	  operand = cgen_operand_lookup_by_num (cd, opindex);
	  reloc = md_cgen_lookup_reloc (insn, operand, fixp);
	}

      DPRINTF3 ("\treloc %s\t%s", bfd_get_reloc_code_name (reloc), S_GET_NAME (s));

      non_pic_p = 0;
      switch (reloc)
	{
	default:
	  break;

	case BFD_RELOC_32:
	  /* Skip relocations in known sections (.ctors, .dtors, and
	     .gcc_except_table) since we can fix those up by hand.  Also
	     skip forward references to constants.  Also skip a difference
	     of two symbols, which still uses the BFD_RELOC_32 at this
	     point.  */
	  if (! known_section_p
	      && S_GET_SEGMENT (s) != absolute_section
	      && !fixp->fx_subsy
	      && (flags & (SEC_READONLY | SEC_CODE)) == 0)
	    {
	      non_pic_p = 1;
	    }
	  break;

	  /* FIXME -- should determine if any of the GP relocation really uses
	     gr16 (which is not pic safe) or not.  Right now, assume if we
	     aren't being compiled with -mpic, the usage is non pic safe, but
	     is safe with -mpic.  */
	case BFD_RELOC_FRV_GPREL12:
	case BFD_RELOC_FRV_GPRELU12:
	case BFD_RELOC_FRV_GPREL32:
	case BFD_RELOC_FRV_GPRELHI:
	case BFD_RELOC_FRV_GPRELLO:
	  non_pic_p = ! frv_pic_p;
	  break;

	case BFD_RELOC_FRV_LO16:
	case BFD_RELOC_FRV_HI16:
	  if (S_GET_SEGMENT (s) != absolute_section)
	    non_pic_p = 1;
	  break;

	case BFD_RELOC_VTABLE_INHERIT:
	case BFD_RELOC_VTABLE_ENTRY:
	  non_pic_p = 1;
	  break;

	  /* If this is a blessed BFD_RELOC_32, convert it back to the normal
             relocation.  */
	case BFD_RELOC_CTOR:
	  fixp->fx_r_type = BFD_RELOC_32;
	  break;
	}

      if (non_pic_p)
	{
	  DPRINTF1 (" (Non-pic relocation)\n");
	  if (frv_pic_p)
	    as_warn_where (fixp->fx_file, fixp->fx_line,
			   _("Relocation %s is not safe for %s"),
			   bfd_get_reloc_code_name (reloc), frv_pic_flag);

	  else if ((frv_flags & EF_FRV_NON_PIC_RELOCS) == 0)
	    {
	      frv_flags |= EF_FRV_NON_PIC_RELOCS;
	      bfd_set_private_flags (abfd, frv_flags);
	    }
	}
#ifdef DEBUG
      else
	DPRINTF1 ("\n");
#endif
    }
}

/* After all of the symbols have been adjusted, go over the file looking
   for any relocations that pic won't support.  */

void
frv_frob_file (void)
{
  bfd_map_over_sections (stdoutput, frv_frob_file_section, (void *) 0);
}

void
frv_frob_label (symbolS *this_label)
{
  struct vliw_insn_list *vliw_insn_list_entry;

  dwarf2_emit_label (this_label);
  if (frv_mach != bfd_mach_frvtomcat)
    return;

  if (now_seg != text_section)
    return;

  vliw_insn_list_entry = frv_insert_vliw_insn(DONT_COUNT);
  vliw_insn_list_entry->type = VLIW_LABEL_TYPE;
  vliw_insn_list_entry->sym  = this_label; 
}

fixS *
frv_cgen_record_fixup_exp (fragS *frag,
			   int where,
			   const CGEN_INSN *insn,
			   int length,
			   const CGEN_OPERAND *operand,
			   int opinfo,
			   expressionS *exp)
{
  fixS * fixP = gas_cgen_record_fixup_exp (frag, where, insn, length,
                                           operand, opinfo, exp);

  if (frv_mach == bfd_mach_frvtomcat
      && current_vliw_insn
      && current_vliw_insn->type == VLIW_BRANCH_TYPE
      && exp != NULL)
    current_vliw_insn->sym = exp->X_add_symbol;
    
  return fixP;
}
@


1.28
log
@	* config/tc-d30v.c (d30v_frob_label): Call dwarf2_emit_label.
	* config/tc-frv.c (frv_frob_label): Likewise.
@
text
@d900 1
a900 3
      struct vliw_insn_list *this_insn;
 
      /* check vliw1 for a label. */
d1042 1
a1042 1
fr550_check_acc_range (FRV_VLIW *vliw, frv_insn *insn)
d1044 1
a1044 1
  switch ((*vliw->current_vliw)[vliw->next_slot - 1])
@


1.27
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d31 1
d1805 1
@


1.27.2.1
log
@	* config/tc-d30v.c (d30v_frob_label): Call dwarf2_emit_label.
	* config/tc-frv.c (frv_frob_label): Likewise.
@
text
@a30 1
#include "dwarf2dbg.h"
a1803 1
  dwarf2_emit_label (this_label);
@


1.26
log
@	* config/tc-frv.c (md_apply_fix): Use abs_section_sym for
	relocs with no symbol.
	* config/tc-mmix.c (md_assemble): Mark fake symbol on
	BFD_RELOC_MMIX_BASE_PLUS_OFFSET as OK for use by relocs.
	(mmix_md_end): Likewise mark mmix reg contents section symbol.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008
d1110 1
a1110 1
      as_bad (errmsg);
@


1.25
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d1478 1
a1478 1
	fixP->fx_addsy = expr_build_uconstant (0);
@


1.25.2.1
log
@	* config/tc-frv.c (md_apply_fix): Use abs_section_sym for
	relocs with no symbol.
	* config/tc-mmix.c (md_assemble): Mark fake symbol on
	BFD_RELOC_MMIX_BASE_PLUS_OFFSET as OK for use by relocs.
	(mmix_md_end): Likewise mark mmix reg contents section symbol.
@
text
@d1478 1
a1478 1
	fixP->fx_addsy = abs_section_sym;
@


1.24
log
@    PR gas/5269
* config/tc-frv.c (md_show_usage): Rewrite usage description to make it easier to translate.
* gas/po/gas.pot: Regenerate.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007
d190 2
a191 3
static void frv_set_flags		PARAMS ((int));
static void frv_pic_ptr			PARAMS ((int));
static void frv_frob_file_section	PARAMS ((bfd *, asection *, PTR));
d265 1
a265 3
md_parse_option (c, arg)
     int    c;
     char * arg;
d484 1
a484 1
md_begin ()
d519 2
a520 5
struct vliw_insn_list *frv_insert_vliw_insn PARAMS ((bfd_boolean));

struct vliw_insn_list *
frv_insert_vliw_insn (count)
      bfd_boolean count;
a588 3
static struct vliw_insn_list *frv_find_in_vliw
  PARAMS ((enum vliw_insn_type, struct vliw_chain *, symbolS *));

d590 3
a592 4
frv_find_in_vliw (vliw_insn_type, this_chain, label_sym)
    enum vliw_insn_type vliw_insn_type;
    struct vliw_chain *this_chain;
    symbolS *label_sym;
a622 2
static void frv_debug_tomcat PARAMS ((struct vliw_chain *));

d624 1
a624 2
frv_debug_tomcat (start_chain)
   struct vliw_chain *start_chain;
a649 2
static void frv_adjust_vliw_count PARAMS ((struct vliw_chain *));

d651 1
a651 2
frv_adjust_vliw_count (this_chain)
    struct vliw_chain *this_chain;
a669 3
static struct vliw_chain *frv_tomcat_shuffle
  PARAMS ((enum vliw_nop_type, struct vliw_chain *, struct vliw_insn_list *));

d671 3
a673 4
frv_tomcat_shuffle (this_nop_type, vliw_to_split, insert_before_insn)
   enum vliw_nop_type    this_nop_type;
   struct vliw_chain     *vliw_to_split;
   struct vliw_insn_list *insert_before_insn;
a836 2
static void frv_tomcat_analyze_vliw_chains PARAMS ((void));

d838 1
a838 1
frv_tomcat_analyze_vliw_chains ()
d955 1
a955 1
frv_tomcat_workaround ()
d1090 1
a1090 2
md_assemble (str)
     char * str;
d1219 1
a1219 2
md_operand (expressionP)
     expressionS * expressionP;
d1229 1
a1229 3
md_section_align (segment, size)
     segT   segment;
     valueT size;
d1236 1
a1236 2
md_undefined_symbol (name)
  char * name ATTRIBUTE_UNUSED;
d1253 1
a1253 3
frv_relax_frag (fragP, stretch)
     fragS   *fragP ATTRIBUTE_UNUSED;
     long    stretch ATTRIBUTE_UNUSED;
d1270 1
a1270 3
md_estimate_size_before_relax (fragP, segment)
     fragS * fragP;
     segT    segment ATTRIBUTE_UNUSED;
d1291 3
a1293 4
md_convert_frag (abfd, sec, fragP)
  bfd *   abfd ATTRIBUTE_UNUSED;
  segT    sec ATTRIBUTE_UNUSED;
  fragS * fragP;
d1314 1
a1314 3
md_pcrel_from_section (fixP, sec)
     fixS * fixP;
     segT   sec;
d1335 3
a1337 4
md_cgen_lookup_reloc (insn, operand, fixP)
     const CGEN_INSN *    insn ATTRIBUTE_UNUSED;
     const CGEN_OPERAND * operand;
     fixS *               fixP;
d1386 1
a1386 2
frv_force_relocation (fix)
     fixS * fix;
d1434 1
a1434 4
md_apply_fix (fixP, valP, seg)
     fixS *   fixP;
     valueT * valP;
     segT     seg;
d1513 1
a1513 4
frv_md_number_to_chars (buf, val, n)
     char * buf;
     valueT val;
     int    n;
d1519 1
a1519 1
md_atof (int type, char * litP, int *  sizeP)
d1525 1
a1525 2
frv_fix_adjustable (fixP)
   fixS * fixP;
d1551 1
a1551 2
frv_set_flags (arg)
     int arg ATTRIBUTE_UNUSED;
d1573 1
a1573 2
frv_pic_ptr (nbytes)
     int nbytes;
d1652 1
a1652 4
frv_frob_file_section (abfd, sec, ptr)
     bfd *abfd;
     asection *sec;
     PTR ptr ATTRIBUTE_UNUSED;
d1794 1
a1794 1
frv_frob_file ()
d1796 1
a1796 1
  bfd_map_over_sections (stdoutput, frv_frob_file_section, (PTR)0);
d1800 1
a1800 2
frv_frob_label (this_label)
    symbolS *this_label;
d1816 7
a1822 8
frv_cgen_record_fixup_exp (frag, where, insn, length, operand, opinfo, exp)
     fragS *              frag;
     int                  where;
     const CGEN_INSN *    insn;
     int                  length;
     const CGEN_OPERAND * operand;
     int                  opinfo;
     expressionS *        exp;
@


1.23
log
@Remove duplicate definitions of the md_atof() function
@
text
@d458 1
a458 2
md_show_usage (stream)
  FILE * stream;
d461 18
a478 18
  fprintf (stream, _("-G n         Data >= n bytes is in small data area\n"));
  fprintf (stream, _("-mgpr-32     Note 32 gprs are used\n"));
  fprintf (stream, _("-mgpr-64     Note 64 gprs are used\n"));
  fprintf (stream, _("-mfpr-32     Note 32 fprs are used\n"));
  fprintf (stream, _("-mfpr-64     Note 64 fprs are used\n"));
  fprintf (stream, _("-msoft-float Note software fp is used\n"));
  fprintf (stream, _("-mdword      Note stack is aligned to a 8 byte boundary\n"));
  fprintf (stream, _("-mno-dword   Note stack is aligned to a 4 byte boundary\n"));
  fprintf (stream, _("-mdouble     Note fp double insns are used\n"));
  fprintf (stream, _("-mmedia      Note media insns are used\n"));
  fprintf (stream, _("-mmuladd     Note multiply add/subtract insns are used\n"));
  fprintf (stream, _("-mpack       Note instructions are packed\n"));
  fprintf (stream, _("-mno-pack    Do not allow instructions to be packed\n"));
  fprintf (stream, _("-mpic        Note small position independent code\n"));
  fprintf (stream, _("-mPIC        Note large position independent code\n"));
  fprintf (stream, _("-mlibrary-pic Compile library for large position indepedent code\n"));
  fprintf (stream, _("-mfdpic      Assemble for the FDPIC ABI\n"));
  fprintf (stream, _("-mnopic      Disable -mpic, -mPIC, -mlibrary-pic and -mfdpic\n"));
d480 3
a482 3
  fprintf (stream, _("             Record the cpu type\n"));
  fprintf (stream, _("-mtomcat-stats Print out stats for tomcat workarounds\n"));
  fprintf (stream, _("-mtomcat-debug Debug tomcat workarounds\n"));
@


1.22
log
@PR gas/5121 gas/5122 gas/5123 gas/5124 gas/5125 gas/5126 gas/5129 gas/5131 gas/5132 gas/5137 gas/5143
* Makefile.am (CFILES): Add cgen.c
  (TARGET_CPU_CFILES): Add tc-iq2000.c, tc-maxq.c, tc-mt.c, tc-tic4x.c and xtensa-relax.c.
  (TARGET_CPU_HFILES): Add tc-iq2000.h, tc-maxq.h, tc-mt.h, tc-tic4x.h and xtensa-relax.h.
  (TARG_ENV_HFILES): Remove te-aux.h, te-delta.h, te-delt88.h, te-ic960.h, te-linux.h.
   Add te-aix5.h, te-armeabi.h, te-freebsd.h, te-gnu.h, te-interix.h, te-vxworks.h.
  (CONFIG_ATOF_CFILES): New variable.
  (POTFILES): Add CONFIG_ATOF_CFILES to dependencies.  Fix typo with dependency upon TARG_ENV_HFILES.
  (DEPTC): Do not put "#include opcodes/<foo>-desc.h" into cgen-desc.h when foo-desc.h does not exit.
   Run make dep-am.
* Makefile.in: Regenerate.
* doc/Makefile.in: Regenerate.
* po/POTFILES.in: Regenerate.
* po/es.po: Regenerate.
* po/fr.po: Regenerate.
* po/gas.pot: Regenerate.
* po/rw.po: Regenerate.
* po/tr.po: Regenerate.
* config/obj-elf.c (obj_elf_vtable_inherit): Allow for translation of error messages.
* config/obj-som.c: Likewise.
* config/tc-arc.c: Likewise.
* config/tc-arm.c: Likewise.
* config/tc-bfin.c: Likewise.
* config/tc-frv.c: Likewise.
@
text
@a1560 8
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
*/

/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6

d1562 1
a1562 4
md_atof (type, litP, sizeP)
     char   type;
     char * litP;
     int *  sizeP;
d1564 1
a1564 41
  int              i;
  int              prec;
  LITTLENUM_TYPE   words [MAX_LITTLENUMS];
  char *           t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

   /* FIXME: Some targets allow other format chars for bigger sizes here.  */

    default:
      * sizeP = 0;
      return _("Bad call to md_atof()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  * sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (i = 0; i < prec; i++)
    {
      md_number_to_chars (litP, (valueT) words[i],
			  sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
     
  return 0;
@


1.21
log
@Switch to GPLv3
@
text
@d407 1
a407 1
	    as_fatal ("Unknown cpu -mcpu=%s", arg);
d1703 1
a1703 1
	    as_bad ("missing ')'");
d1713 1
a1713 1
	    as_bad ("missing ')'");
@


1.20
log
@remove some duplicate #include's.
@
text
@d2 2
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006 Free Software Foundation.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.19
log
@Fixes for building on 64-bit hosts:
        * config/tc-avr.c (mod_index): New union to allow conversion
        between pointers and integers.
        (md_begin, avr_ldi_expression): Use it.
        * config/tc-i370.c (md_assemble): Add cast for argument to print
        statement.
        * config/tc-tic54x.c (subsym_substitute): Likewise.
        * config/tc-mn10200.c (md_assemble): Use a union to convert the
        opindex field of fr_cgen structure into a pointer so that it can
        be stored in a frag.
        * config/tc-mn10300.c (md_assemble): Likewise.
        * config/tc-frv.c (frv_debug_tomcat): Use %p to print pointer
        types.
        * config/tc-v850.c: Replace uses of (int) casts with correct
        types.
        * gas/tic54x/address.d: Work with 64bit hosts.
        * gas/tic54x/addrfar.d: Likewise.
        * gas/tic54x/align.d: Likewise.
        * gas/tic54x/all-opcodes.d: Likewise.
        * gas/tic54x/asg.d: Likewise.
        * gas/tic54x/cons.d: Likewise.
        * gas/tic54x/consfar.d: Likewise.
        * gas/tic54x/extaddr.d: Likewise.
        * gas/tic54x/field.d: Likewise.
        * gas/tic54x/labels.d: Likewise.
        * gas/tic54x/loop.d: Likewise.
        * gas/tic54x/lp.d: Likewise.
        * gas/tic54x/macro.d: Likewise.
        * gas/tic54x/math.d: Likewise.
        * gas/tic54x/opcodes.d: Likewise.
        * gas/tic54x/sections.d: Likewise.
       * gas/tic54x/set.d: Likewise.
       * gas/tic54x/struct.d: Likewise.
       * gas/tic54x/subsym.d: Likewise.
@
text
@a20 1
#include <stdio.h>
@


1.18
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005 Free Software Foundation.
d651 1
a651 1
	    fprintf (stderr, "Label Value: %d\n", (int) this_insn->sym);
d653 1
a653 1
	    fprintf (stderr, "%s to %d\n", this_insn->insn->base->name, (int) this_insn->sym);
d655 1
a655 1
	    fprintf (stderr, "nop'd %s to %d\n", this_insn->insn->base->name, (int) this_insn->sym);
@


1.17
log
@Update the address and phone number of the FSF
@
text
@d1471 1
a1471 1
md_apply_fix3 (fixP, valP, seg)
d1545 1
a1545 1
  gas_cgen_md_apply_fix3 (fixP, valP, seg);
@


1.16
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d18 2
a19 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.15
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d748 1
a748 1
	      unsigned char *buffer = prev_insn->address;
d787 1
a787 1
	      unsigned char *buffer = prev_insn->address;
d833 1
a833 1
	      unsigned char *buffer = prev_insn->address;
@


1.14
log
@bfd/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_relocate_section): Force local binding
for TLSMOFF.
* reloc.c: Add R_FRV_TLSMOFF.
* elf32-frv.c (elf32_frv_howto_table): Likewise.
(frv_reloc_map, frv_reloc_type_lookup): Map it.
(elf32_frv_relocate_section): Handle it.
(elf32_frv_check_relocs): Likewise.
* libbfd.h, bfd-in2.h: Rebuilt.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frvfdpic_emit_got_relocs_plt_entries): Don't crash
when given an undefweak TLS symbol.  Fix constant TLS PLT entries
such that they return the constant in gr9.
(_frvfdpic_relax_tls_entries): Don't crash for undefweak TLS
symbols.
(_frvfdpic_size_got_plt): Set _cooked_size of dynamic sections.
too, such that they shrink on relaxation.
(elf32_frvfdpic_finish_dynamic_sections): Check __ROFIXUP_END__ as
marking the position right past the _GLOBAL_OFFSET_TABLE_ value.
(_frvfdpic_assign_plt_entries): Shrink constant TLS PLT entries
if we can guarantee the use of 16-bit constants.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
Introduce TLS support for FR-V FDPIC.
* reloc.c: Add TLS relocations.
* elf32-frv.c (elf32_frv_howto_table): Add TLS relocations.
(elf32_frv_rel_tlsdesc_value_howto): New.
(elf32_frv_rel_tlsoff_howto): New.
(frv_reloc_map): Add new mappings.
(struct frvfdpic_elf_link_hash_table): Add pointer to summary
reloc information.
(frvfdpic_dynamic_got_plt_info): New.
(frvfdpic_plt_tls_ret_offset): New.
(ELF_DYNAMIC_INTERPRETER, DEFAULT_STACK_SIZE): Move earlier.
(struct _frvfdpic_dynamic_got_info): Likewise.  Add TLS members.
(struct _frvfdpic_dynamic_got_plt_info): Likewise.
(FRVFDPIC_SYM_LOCAL): Regard symbols defined in the absolute
section as local.
(struct frvfdpic_relocs_info): Add TLS fields.
(frvfdpic_relocs_info_hash): Warning clean up.
(frvfdpic_relocs_info_find): Initialize tlsplt_entry.
(frvfdpic_pic_merge_early_relocs_info): Merge TLS fields.
(FRVFDPIC_TLS_BIAS): Define.
(tls_biased_base): New.
(_frvfdpic_emit_got_relocs_plt_entries): Deal with TLS
relocations.
(frv_reloc_type_lookup): Likewise.
(frvfdpic_info_to_howto_rel): Likewise.
(elf32_frv_relocate_section): Likewise.
(_frv_create_got_section): Create the PLT section here.
(elf32_frvfdpic_create_dynamic_sections): Not here.
(_frvfdpic_count_nontls_entries): Move out of...
(_frvfdpic_count_got_plt_entries): ... here.
(_frvfdpic_count_tls_entries): Likewise.  Add TLS support.
(_frvfdpic_count_relocs_fixups): Likewise.  Add relaxation
support.
(_frvfdpic_relax_tls_entries): New.
(_frvfdpic_compute_got_alloc_data): Add TLS support.
(_frvfdpic_get_tlsdesc_entry): New.
(_frvfdpic_assign_got_entries): Add TLS support.
(_frvfdpic_assign_plt_entries): Likewise.
(_frvfdpic_reset_got_plt_entries): New.
(_frvfdpic_size_got_plt): Move out of...
(elf32_frvfdpic_size_dynamic_sections): ... here.
(_frvfdpic_relax_got_plt_entries): New.
(elf32_frvfdpic_relax_section): New.
(elf32_frvfdpic_finish_dynamic_sections): Add TLS sanity check.
(elf32_frv_check_relocs): Add TLS support.
(bfd_elf32_bfd_relax_section): Define for FDPIC.
* libbfd.h, bfd-in2.h: Rebuilt.
cpu/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.cpu: Add support for TLS annotations in loads and calll.
* frv.opc (parse_symbolic_address): New.
(parse_ldd_annotation): New.
(parse_call_annotation): New.
(parse_ld_annotation): New.
(parse_ulo16, parse_uslo16): Use parse_symbolic_address.
Introduce TLS relocations.
(parse_d12, parse_s12, parse_u12): Likewise.
(parse_uhi16): Likewise.  Fix constant checking on 64-bit host.
(parse_call_label, print_at): New.
gas/ChangeLog:
* config/tc-frv.c (md_apply_fix3): Mark TLS symbols as such.
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (frv_pic_ptr): Add tlsmoff support.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.c (gas_cgen_parse_operand): Handle
CGEN_PARSE_OPERAND_SYMBOLIC.
* config/tc-frv.c (md_cgen_lookup_reloc): Handle TLS relocations.
(frv_force_relocation): Likewise.  Fix handling of PIC
relocations.
(md_apply_fix3): Likewise.
include/elf/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add R_FRV_TLSMOFF.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add TLS relocations.
include/opcode/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.h (enum cgen_parse_operand_type): Add
CGEN_PARSE_OPERAND_SYMBOLIC.
ld/testsuite/ChangeLog:
* ld-frv/fdpic.exp: Add -mfdpic to ASFLAGS.
* ld-frv/tls.exp: Likewise.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-3.s: New.
* ld-frv/tls-static-3.d: New.
* ld-frv/tls-dynamic-3.d: New.
* ld-frv/tls-pie-3.d: New.
* ld-frv/tls-shared-3.d: New.
* ld-frv/tls-relax-static-3.d: New.
* ld-frv/tls-relax-dynamic-3.d: New.
* ld-frv/tls-relax-pie-3.d: New.
* ld-frv/tls-relax-shared-3.d: New.
* ld-frv/tls.exp: Run the new tests.
* ld-frv/tls-dynamic-2.d: Adjust for improved relaxation.
* ld-frv/tls-relax-dynamic-2.d: Likewise.
* ld-frv/tls-relax-initial-shared-2.d: Likewise.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-1-dep.s: New.
* ld-frv/tls-1-shared.lds: New.
* ld-frv/tls-1.s: New.
* ld-frv/tls-2.s: New.
* ld-frv/tls-dynamic-1.d: New.
* ld-frv/tls-dynamic-2.d: New.
* ld-frv/tls-initial-shared-2.d: New.
* ld-frv/tls-pie-1.d: New.
* ld-frv/tls-relax-dynamic-1.d: New.
* ld-frv/tls-relax-dynamic-2.d: New.
* ld-frv/tls-relax-initial-shared-2.d: New.
* ld-frv/tls-relax-pie-1.d: New.
* ld-frv/tls-relax-shared-1.d: New.
* ld-frv/tls-relax-shared-2.d: New.
* ld-frv/tls-relax-static-1.d: New.
* ld-frv/tls-shared-1-fail.d: New.
* ld-frv/tls-shared-1.d: New.
* ld-frv/tls-shared-2.d: New.
* ld-frv/tls-static-1.d: New.
* ld-frv/tls.exp: New.
* ld-frv/fdpic-pie-1.d: Adjust for 64-bit host.
* ld-frv/fdpic-pie-2.d: Likewise.
* ld-frv/fdpic-pie-6.d: Likewise.
* ld-frv/fdpic-pie-7.d: Likewise.
* ld-frv/fdpic-pie-8.d: Likewise.
* ld-frv/fdpic-shared-1.d: Likewise.
* ld-frv/fdpic-shared-2.d: Likewise.
* ld-frv/fdpic-shared-3.d: Likewise.
* ld-frv/fdpic-shared-4.d: Likewise.
* ld-frv/fdpic-shared-5.d: Likewise.
* ld-frv/fdpic-shared-6.d: Likewise.
* ld-frv/fdpic-shared-7.d: Likewise.
* ld-frv/fdpic-shared-8.d: Likewise.
* ld-frv/fdpic-shared-local-2.d: Likewise.
* ld-frv/fdpic-shared-local-8.d: Likewise.
* ld-frv/fdpic-static-1.d: Likewise.
* ld-frv/fdpic-static-2.d: Likewise.
* ld-frv/fdpic-static-6.d: Likewise.
* ld-frv/fdpic-static-7.d: Likewise.
* ld-frv/fdpic-static-8.d: Likewise.
opcodes/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv-asm.c: Rebuilt.
* frv-desc.c: Rebuilt.
* frv-desc.h: Rebuilt.
* frv-dis.c: Rebuilt.
* frv-ibld.c: Rebuilt.
* frv-opc.c: Rebuilt.
* frv-opc.h: Rebuilt.
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation.
d1426 1
a1426 1
	  ? fix->fx_r_type
@


1.13
log
@* configure.in: Set em=linux for frv-*-*linux*.
* configure: Rebuilt.
* config/tc-frv.h (TARGET_FORMAT): Use elf32-frvfdpic if...
(frv_md_fdpic_enabled): New.
* config/tc-frv.c (frv_md_fdpic_enabled): New.
(DEFAULT_FDPIC): New.
(frv_flags): Use DEFAULT_FDPIC.
(frv_pic_flag): Likewise.
(OPTION_NOPIC): New.
(md_longopts): Add -mnopic.
(md_parse_option): Handle it.
(md_show_usage): Add -mfdpic and -mnopic.
@
text
@d1383 4
d1392 3
a1394 1

d1425 39
a1463 3
  if (fix->fx_r_type == BFD_RELOC_FRV_GPREL12
      || fix->fx_r_type == BFD_RELOC_FRV_GPRELU12)
    return 1;
d1485 58
d1706 10
@


1.12
log
@Add fr450 support.
@
text
@d165 6
d175 1
a175 1
static flagword frv_flags = DEFAULT_FLAGS;
d179 1
a179 1
static const char *frv_pic_flag = (const char *)0;
d229 1
d256 1
d439 6
d478 2
d513 6
@


1.11
log
@2003-12-19  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.h (md_apply_fix3): Don't define.
* config/tc-frv.c (md_apply_fix3): New.  Shift/truncate %hi/%lo
operands.
* config/tc-frv.h (TC_FORCE_RELOCATION_SUB_LOCAL): Define.
2003-10-07  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (line_separator_chars): Add `!'.
2003-09-19  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (md_assemble): Clear insn upfront.
2003-09-18  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (OPTION_FDPIC): New macro.
(md_longopts): Add mfdpic.
(md_parse_option): Handle it.
2003-08-04  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (md_cgen_lookup_reloc) <FRV_OPERAND_D12,
FRV_OPERAND_S12>: Use reloc type encoded in fix-up.
(frv_pic_ptr): Parse funcdesc.
@
text
@d166 1
d358 13
d375 1
d464 1
a464 1
  fprintf (stream, _("-mcpu={fr500|fr550|fr400|fr300|frv|simple|tomcat}\n"));
d1060 30
d1173 5
@


1.11.6.1
log
@* configure.in: Set em=linux for frv-*-*linux*.
* configure: Rebuilt.
* config/tc-frv.h (TARGET_FORMAT): Use elf32-frvfdpic if...
(frv_md_fdpic_enabled): New.
* config/tc-frv.c (frv_md_fdpic_enabled): New.
(DEFAULT_FDPIC): New.
(frv_flags): Use DEFAULT_FDPIC.
(frv_pic_flag): Likewise.
(OPTION_NOPIC): New.
(md_longopts): Add -mnopic.
(md_parse_option): Handle it.
(md_show_usage): Add -mfdpic and -mnopic.
@
text
@a164 6
#ifdef TE_LINUX
# define DEFAULT_FDPIC	EF_FRV_FDPIC
#else
# define DEFAULT_FDPIC	0
#endif

d168 1
a168 1
static flagword frv_flags = DEFAULT_FLAGS | DEFAULT_FDPIC;
d172 1
a172 1
static const char *frv_pic_flag = DEFAULT_FDPIC ? "-mfdpic" : (const char *)0;
a221 1
#define OPTION_NOPIC		(OPTION_MD_BASE + 22)
a247 1
  { "mnopic",		no_argument,		NULL, OPTION_NOPIC	   },
a415 6
    case OPTION_NOPIC:
      frv_flags &= ~(EF_FRV_FDPIC | EF_FRV_PIC
		     | EF_FRV_BIGPIC | EF_FRV_LIBPIC);
      frv_pic_flag = 0;
      break;

a448 2
  fprintf (stream, _("-mfdpic      Assemble for the FDPIC ABI\n"));
  fprintf (stream, _("-mnopic      Disable -mpic, -mPIC, -mlibrary-pic and -mfdpic\n"));
a481 6
}

bfd_boolean
frv_md_fdpic_enabled (void)
{
  return (frv_flags & EF_FRV_FDPIC) != 0;
@


1.10
log
@* config/tc-frv.c (md_pcrel_from_section): Don't adjust when
referencing symbol in a different section.
@
text
@d118 1
a118 1
const char line_separator_chars[] = ""; 
d221 1
d247 1
d411 5
d1060 2
d1324 3
d1353 24
d1522 14
a1535 1
      expression (&exp);
d1540 1
a1540 1
		   BFD_RELOC_CTOR);
@


1.9
log
@2003-10-08  Dave Brolley  <brolley@@redhat.com>

        * config/tc-frv.c (fr550_check_insn_acc_range): New function.
        (fr550_check_acc_range): New function.
        (md_assemble): Call fr550_check_acc_range.
@
text
@d1268 1
a1268 1
     segT   sec ATTRIBUTE_UNUSED;
d1270 10
a1279 3
  /* Make no adjustment for relocations that will be written out.  */
  if (TC_FORCE_RELOCATION (fixP))
    return 0;
@


1.8
log
@gas/
	* config/tc-frv.c (md_pcrel_from_section): Heed TC_FORCE_RELOCATION.

gas/testsuite/
	* gas/frv/reloc1.[sd]: New test.
	* gas/frv/allinsn.exp: Run it.
@
text
@d151 5
d163 1
d349 6
d442 1
a442 1
  fprintf (stream, _("-mcpu={fr500|fr400|fr300|frv|simple|tomcat}\n"));
d951 87
d1120 2
@


1.7
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d1167 1
a1167 1
     segT   sec;
d1169 3
a1171 8
  if (fixP->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixP->fx_addsy)
	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
    {
      /* The symbol is undefined (or is defined but not in this section).
	 Let the linker figure it out.  */
      return 0;
    }
@


1.6
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@a22 1
#include "dwarf2dbg.h"
a186 2
  { "file",	(void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  { "loc",	dwarf2_directive_loc,	0 },
@


1.5
log
@	* config/tc-frv.c (frv_insert_vliw_insn): Prototype.
	(frv_find_in_vliw): Likewise.
	(frv_debug_tomcat): Likewise.
	(frv_adjust_vliw_count): Likewise.
	(frv_tomcat_shuffle): Likewise.
	(frv_tomcat_analyze_vliw_chains): Likewise.  Correct args to
	frv_find_in_vliw call.
	(md_atof): Remove declaration of atof_ieee.
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation.
d1235 1
a1235 3
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fix->fx_r_type == BFD_RELOC_FRV_GPREL12
d1239 1
a1239 1
  return S_FORCE_RELOC (fix->fx_addsy);
@


1.4
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d470 2
d543 3
d581 2
d611 1
d634 2
d805 2
d876 1
a876 1
	      if ((temp_insn = frv_find_in_vliw (VLIW_BRANCH_TYPE, vliw2, this_insn->sym, temp_insn)) != NULL)
d907 1
a907 1
	  if ((temp_insn = frv_find_in_vliw (VLIW_LABEL_TYPE, vliw1, this_insn->sym, temp_insn)) != NULL)
a1272 1
  char *           atof_ieee ();
@


1.3
log
@gas reloc rewrite.
@
text
@d2 1
a2 1
   Copyright (C) 2002 Free Software Foundation.
d70 2
a71 2
#define DO_COUNT    true
#define DONT_COUNT  false
d472 1
a472 1
      boolean count;
d634 1
a634 1
  boolean pack_prev = false;
d655 1
a655 1
	pack_prev = true;
d1185 1
a1185 1
      fixP->fx_pcrel = true;
d1189 1
a1189 1
      fixP->fx_pcrel = true;
d1301 1
a1301 1
boolean
@


1.2
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d1229 1
a1229 1
  return 0;
a1316 10
  if (fixP->fx_addsy == NULL)
    return 1;
  
  /* Prevent all adjustments to global symbols. */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;
  
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;
  
@


1.1
log
@2002-06-18  Dave Brolley  <brolley@@redhat.com>

	From Catherine Moore, Michael Meissner, Richard Sandiford, Dave Brolley:
	* po/POTFILES.in: Add tc-frv.c, tc-frv.h.
	* configure.in: Support frv-*-*.
	* Makefile.am (CPU_TYPES): Add frv.
	(TARGET_CPU_CFILES): Add tc-frv.c.
	(TARGET_CPU_HFILES): Add tc-frv.h.
	(DEPTC_frv_coff): New variable.
	(DEPTC_frv_elf): New variable.
	(DEPOBJ_frv_coff): New variable.
	(DEPOBJ_frv_elf): New variable.
	(DEP_frv_coff): New variable.
	(DEP_frv_elf): New variable.
	* tc-frv.c: New file.
	* tc-frv.h: New file.
@
text
@d188 1
a188 1
  { "file",	dwarf2_directive_file,	0 },
@

