head	1.21;
access;
symbols
	binutils-2_24-branch:1.19.0.4
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.17
	binutils-2_23_2:1.19
	binutils-2_23_1:1.19
	binutils-2_23:1.19
	binutils-2_23-branch:1.19.0.2
	binutils-2_23-branchpoint:1.19
	binutils-2_22_branch:1.18.0.4
	binutils-2_22:1.18
	binutils-2_22-branch:1.18.0.2
	binutils-2_22-branchpoint:1.18
	binutils-2_21:1.17
	binutils-2_21-branch:1.17.0.2
	binutils-2_21-branchpoint:1.17
	binutils-2_20_1:1.15.2.1
	binutils-2_20:1.15.2.1
	binutils-arc-20081103-branch:1.12.0.6
	binutils-arc-20081103-branchpoint:1.12
	binutils-2_20-branch:1.15.0.2
	binutils-2_20-branchpoint:1.15
	dje-cgen-play1-branch:1.14.0.2
	dje-cgen-play1-branchpoint:1.14
	arc-20081103-branch:1.12.0.4
	arc-20081103-branchpoint:1.12
	binutils-2_19_1:1.12
	binutils-2_19:1.12
	binutils-2_19-branch:1.12.0.2
	binutils-2_19-branchpoint:1.12
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	binutils_latest_snapshot:1.21;
locks; strict;
comment	@ * @;


1.21
date	2013.10.15.08.32.36;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.14.09.15.09;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2012.05.05.03.05.27;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2011.06.13.09.45.28;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.05.07.56.24;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.02.10.33.06;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.14.10.06.32;	author ligang;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.22.08.55.34;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.18.10.33.49;	author ligang;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.25.09.26.22;	author ligang;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.16.04.36.25;	author ligang;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.01.10.29.49;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.31.09.54.40;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.19.15.47.33;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.13.06.55.50;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.16.23.51.50;	author nickc;	state Exp;
branches;
next	;

1.15.2.1
date	2009.09.05.08.00.20;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.21
log
@revert previous delta.
@
text
@/* tc-score.c -- Assembler for Score
   Copyright 2006, 2007, 2008, 2009, 2011, 2012 Free Software Foundation, Inc.
   Contributed by:
   Brain.lin (brain.lin@@sunplusct.com)
   Mei Ligang (ligang@@sunnorth.com.cn)
   Pei-Lin Tsai (pltsai@@sunplus.com)

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "tc-score7.c"

static void s3_s_score_bss (int ignore ATTRIBUTE_UNUSED);
static void s3_s_score_text (int ignore);
static void s3_score_s_section (int ignore);
static void s3_s_change_sec (int sec);
static void s3_s_score_mask (int reg_type ATTRIBUTE_UNUSED);
static void s3_s_score_ent (int aent);
static void s3_s_score_frame (int ignore ATTRIBUTE_UNUSED);
static void s3_s_score_end (int x ATTRIBUTE_UNUSED);
static void s3_s_score_set (int x ATTRIBUTE_UNUSED);
static void s3_s_score_cpload (int ignore ATTRIBUTE_UNUSED);
static void s3_s_score_cprestore (int ignore ATTRIBUTE_UNUSED);
static void s3_s_score_gpword (int ignore ATTRIBUTE_UNUSED);
static void s3_s_score_cpadd (int ignore ATTRIBUTE_UNUSED);
static void s3_s_score_lcomm (int bytes_p);

static void s_score_bss (int ignore ATTRIBUTE_UNUSED);
static void s_score_text (int ignore);
static void s_section (int ignore);
static void s_change_sec (int sec);
static void s_score_mask (int reg_type ATTRIBUTE_UNUSED);
static void s_score_ent (int aent);
static void s_score_frame (int ignore ATTRIBUTE_UNUSED);
static void s_score_end (int x ATTRIBUTE_UNUSED);
static void s_score_set (int x ATTRIBUTE_UNUSED);
static void s_score_cpload (int ignore ATTRIBUTE_UNUSED);
static void s_score_cprestore (int ignore ATTRIBUTE_UNUSED);
static void s_score_gpword (int ignore ATTRIBUTE_UNUSED);
static void s_score_cpadd (int ignore ATTRIBUTE_UNUSED);
static void s_score_lcomm (int bytes_p);

/* s3: hooks.  */
static void s3_md_number_to_chars (char *buf, valueT val, int n);
static valueT s3_md_chars_to_number (char *buf, int n);
static void s3_assemble (char *str);
static void s3_operand (expressionS *);
static void s3_begin (void);
static void s3_number_to_chars (char *buf, valueT val, int n);
static char *s3_atof (int type, char *litP, int *sizeP);
static void s3_frag_check (fragS * fragp ATTRIBUTE_UNUSED);
static void s3_validate_fix (fixS *fixP);
static int s3_force_relocation (struct fix *fixp);
static bfd_boolean s3_fix_adjustable (fixS * fixP);
static void s3_elf_final_processing (void);
static int s3_estimate_size_before_relax (fragS * fragp, asection * sec ATTRIBUTE_UNUSED);
static int s3_relax_frag (asection * sec ATTRIBUTE_UNUSED, fragS * fragp, long stretch ATTRIBUTE_UNUSED);
static void s3_convert_frag (bfd * abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED, fragS * fragp);
static long s3_pcrel_from (fixS * fixP);
static valueT s3_section_align (segT segment ATTRIBUTE_UNUSED, valueT size);
static void s3_apply_fix (fixS *fixP, valueT *valP, segT seg);
static arelent **s3_gen_reloc (asection * section ATTRIBUTE_UNUSED, fixS * fixp);

/* s3: utils.  */
static void s3_do_ldst_insn (char *);
static void s3_do_crdcrscrsimm5 (char *);
static void s3_do_ldst_unalign (char *);
static void s3_do_ldst_atomic (char *);
static void s3_do_ldst_cop (char *);
static void s3_do_macro_li_rdi32 (char *);
static void s3_do_macro_la_rdi32 (char *);
static void s3_do_macro_rdi32hi (char *);
static void s3_do_macro_rdi32lo (char *);
static void s3_do_macro_mul_rdrsrs (char *);
static void s3_do_macro_bcmp (char *);
static void s3_do_macro_bcmpz (char *);
static void s3_do_macro_ldst_label (char *);
static void s3_do_branch (char *);
static void s3_do_jump (char *);
static void s3_do_empty (char *);
static void s3_do16_int (char *);
static void s3_do_rdrsrs (char *);
static void s3_do_rdsi16 (char *);
static void s3_do_rdrssi14 (char *);
static void s3_do_sub_rdsi16 (char *);
static void s3_do_sub_rdi16 (char *);
static void s3_do_sub_rdrssi14 (char *);
static void s3_do_rdrsi5 (char *);
static void s3_do_rdrsi14 (char *);
static void s3_do_rdi16 (char *);
static void s3_do_ldis (char *);
static void s3_do_xrsi5 (char *);
static void s3_do_rdrs (char *);
static void s3_do_rdxrs (char *);
static void s3_do_rsrs (char *);
static void s3_do_rdcrs (char *);
static void s3_do_rdsrs (char *);
static void s3_do_rd (char *);
static void s3_do16_dsp (char *);
static void s3_do16_dsp2 (char *);
static void s3_do_dsp (char *);
static void s3_do_dsp2 (char *);
static void s3_do_dsp3 (char *);
static void s3_do_rs (char *);
static void s3_do_i15 (char *);
static void s3_do_xi5x (char *);
static void s3_do_ceinst (char *);
static void s3_do_cache (char *);
static void s3_do16_rdrs2 (char *);
static void s3_do16_br (char *);
static void s3_do16_brr (char *);
static void s3_do_ltb (char *);
static void s3_do16_mv_cmp (char *);
static void s3_do16_addi (char *);
static void s3_do16_cmpi (char *);
static void s3_do16_rdi5 (char *);
static void s3_do16_xi5 (char *);
static void s3_do16_ldst_insn (char *);
static void s3_do16_slli_srli (char *);
static void s3_do16_ldiu (char *);
static void s3_do16_push_pop (char *);
static void s3_do16_rpush (char *);
static void s3_do16_rpop (char *);
static void s3_do16_branch (char *);
static void s3_do_lw48 (char *);
static void s3_do_sw48 (char *);
static void s3_do_ldi48 (char *);
static void s3_do_sdbbp48 (char *);
static void s3_do_and48 (char *);
static void s3_do_or48 (char *);
static void s3_do_mbitclr (char *);
static void s3_do_mbitset (char *);
static void s3_do_rdi16_pic (char *);
static void s3_do_addi_s_pic (char *);
static void s3_do_addi_u_pic (char *);
static void s3_do_lw_pic (char *);

#define MARCH_SCORE3   "score3"
#define MARCH_SCORE3D  "score3d"
#define MARCH_SCORE7   "score7"
#define MARCH_SCORE7D  "score7d"
#define MARCH_SCORE5   "score5"
#define MARCH_SCORE5U  "score5u"

#define SCORE_BI_ENDIAN

#ifdef SCORE_BI_ENDIAN
#define OPTION_EB             (OPTION_MD_BASE + 0)
#define OPTION_EL             (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB             (OPTION_MD_BASE + 0)
#else
#define OPTION_EL             (OPTION_MD_BASE + 1)
#endif
#endif
#define OPTION_FIXDD          (OPTION_MD_BASE + 2)
#define OPTION_NWARN          (OPTION_MD_BASE + 3)
#define OPTION_SCORE5         (OPTION_MD_BASE + 4)
#define OPTION_SCORE5U        (OPTION_MD_BASE + 5)
#define OPTION_SCORE7         (OPTION_MD_BASE + 6)
#define OPTION_R1             (OPTION_MD_BASE + 7)
#define OPTION_O0             (OPTION_MD_BASE + 8)
#define OPTION_SCORE_VERSION  (OPTION_MD_BASE + 9)
#define OPTION_PIC            (OPTION_MD_BASE + 10)
#define OPTION_MARCH          (OPTION_MD_BASE + 11)
#define OPTION_SCORE3         (OPTION_MD_BASE + 12)

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "#";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = ";";
/* Chars that can be used to separate mant from exp in floating point numbers.  */
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "rRsSfFdDxXeEpP";

#ifdef OBJ_ELF
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
symbolS *GOT_symbol;
#endif

const pseudo_typeS md_pseudo_table[] =
{
  {"bss", s_score_bss, 0},
  {"text", s_score_text, 0},
  {"word", cons, 4},
  {"long", cons, 4},
  {"extend", float_cons, 'x'},
  {"ldouble", float_cons, 'x'},
  {"packed", float_cons, 'p'},
  {"end", s_score_end, 0},
  {"ent", s_score_ent, 0},
  {"frame", s_score_frame, 0},
  {"rdata", s_change_sec, 'r'},
  {"sdata", s_change_sec, 's'},
  {"set", s_score_set, 0},
  {"mask", s_score_mask, 'R'},
  {"dword", cons, 8},
  {"lcomm", s_score_lcomm, 1},
  {"section", s_section, 0},
  {"cpload", s_score_cpload, 0},
  {"cprestore", s_score_cprestore, 0},
  {"gpword", s_score_gpword, 0},
  {"cpadd", s_score_cpadd, 0},
  {0, 0, 0}
};

const char *md_shortopts = "nO::g::G:";
struct option md_longopts[] =
{
#ifdef OPTION_EB
  {"EB"     , no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL"     , no_argument, NULL, OPTION_EL},
#endif
  {"FIXDD"  , no_argument, NULL, OPTION_FIXDD},
  {"NWARN"  , no_argument, NULL, OPTION_NWARN},
  {"SCORE5" , no_argument, NULL, OPTION_SCORE5},
  {"SCORE5U", no_argument, NULL, OPTION_SCORE5U},
  {"SCORE7" , no_argument, NULL, OPTION_SCORE7},
  {"USE_R1" , no_argument, NULL, OPTION_R1},
  {"O0"     , no_argument, NULL, OPTION_O0},
  {"V"      , no_argument, NULL, OPTION_SCORE_VERSION},
  {"KPIC"   , no_argument, NULL, OPTION_PIC},
  {"march=" , required_argument, NULL, OPTION_MARCH},
  {"SCORE3" , no_argument, NULL, OPTION_SCORE3},
  {NULL     , no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

#define s3_GP                     28
#define s3_PIC_CALL_REG           29
#define s3_MAX_LITERAL_POOL_SIZE  1024
#define s3_FAIL	                  0x80000000
#define s3_SUCCESS                0
#define s3_INSN48_SIZE            6
#define s3_INSN_SIZE              4
#define s3_INSN16_SIZE            2
#define s3_RELAX_INST_NUM         3

/* For score5u : div/mul will pop warning message, mmu/alw/asw will pop error message.  */
#define s3_BAD_ARGS 	          _("bad arguments to instruction")
#define s3_ERR_FOR_SCORE5U_MUL_DIV   _("div / mul are reserved instructions")
#define s3_ERR_FOR_SCORE5U_MMU       _("This architecture doesn't support mmu")
#define s3_ERR_FOR_SCORE5U_ATOMIC    _("This architecture doesn't support atomic instruction")
#define s3_BAD_SKIP_COMMA            s3_BAD_ARGS
#define s3_BAD_GARBAGE               _("garbage following instruction");

#define s3_skip_whitespace(str)  while (*(str) == ' ') ++(str)

/* The name of the readonly data section.  */
#define s3_RDATA_SECTION_NAME (OUTPUT_FLAVOR == bfd_target_aout_flavour \
			    ? ".data" \
			    : OUTPUT_FLAVOR == bfd_target_ecoff_flavour \
			    ? ".rdata" \
			    : OUTPUT_FLAVOR == bfd_target_coff_flavour \
			    ? ".rdata" \
			    : OUTPUT_FLAVOR == bfd_target_elf_flavour \
			    ? ".rodata" \
			    : (abort (), ""))

#define s3_RELAX_ENCODE(old, new, type, reloc1, reloc2, opt) \
  ((relax_substateT) \
   (((old) << 23) \
    | ((new) << 16) \
    | ((type) << 9) \
    | ((reloc1) << 5) \
    | ((reloc2) << 1) \
    | ((opt) ? 1 : 0)))

#define s3_RELAX_OLD(i)       (((i) >> 23) & 0x7f)
#define s3_RELAX_NEW(i)       (((i) >> 16) & 0x7f)
#define s3_RELAX_TYPE(i)      (((i) >> 9) & 0x7f)
#define s3_RELAX_RELOC1(i)    ((valueT) ((i) >> 5) & 0xf)
#define s3_RELAX_RELOC2(i)    ((valueT) ((i) >> 1) & 0xf)
#define s3_RELAX_OPT(i)       ((i) & 1)

#define s3_SET_INSN_ERROR(s) (s3_inst.error = (s))
#define s3_INSN_IS_PCE_P(s)  (strstr (str, "||") != NULL)
#define s3_INSN_IS_48_P(s)  (strstr (str, "48") != NULL)
#define s3_GET_INSN_CLASS(type) (s3_get_insn_class_from_type (type))
#define s3_GET_INSN_SIZE(type) ((s3_GET_INSN_CLASS (type) == INSN_CLASS_16) \
                             ? s3_INSN16_SIZE : (s3_GET_INSN_CLASS (type) == INSN_CLASS_48) \
                                             ? s3_INSN48_SIZE : s3_INSN_SIZE)

#define s3_MAX_LITTLENUMS 6
#define s3_INSN_NAME_LEN 16

/* Relax will need some padding for alignment.  */
#define s3_RELAX_PAD_BYTE 3


#define s3_USE_GLOBAL_POINTER_OPT 1

/* Enumeration matching entries in table above.  */
enum s3_score_reg_type
{
  s3_REG_TYPE_SCORE = 0,
#define s3_REG_TYPE_FIRST s3_REG_TYPE_SCORE
  s3_REG_TYPE_SCORE_SR = 1,
  s3_REG_TYPE_SCORE_CR = 2,
  s3_REG_TYPE_MAX = 3
};

enum s3_score_pic_level
{
  s3_NO_PIC,
  s3_PIC
};
static enum s3_score_pic_level s3_score_pic = s3_NO_PIC;

enum s3_insn_type_for_dependency
{
  s3_D_mtcr,
  s3_D_all_insn
};

struct s3_insn_to_dependency
{
  char *insn_name;
  enum s3_insn_type_for_dependency type;
};

struct s3_data_dependency
{
  enum s3_insn_type_for_dependency pre_insn_type;
  char pre_reg[6];
  enum s3_insn_type_for_dependency cur_insn_type;
  char cur_reg[6];
  int bubblenum_7;
  int bubblenum_3;
  int warn_or_error;           /* warning - 0; error - 1  */
};

static const struct s3_insn_to_dependency s3_insn_to_dependency_table[] =
{
  /* move spectial instruction.  */
  {"mtcr",      s3_D_mtcr},
};

static const struct s3_data_dependency s3_data_dependency_table[] =
{
  /* Status regiser.  */
  {s3_D_mtcr, "cr0", s3_D_all_insn, "", 5, 1, 0},
};

/* Used to contain constructed error messages.  */
static char s3_err_msg[255];

static int s3_fix_data_dependency = 0;
static int s3_warn_fix_data_dependency = 1;

static int s3_in_my_get_expression = 0;

/* Default, pop warning message when using r1.  */
static int s3_nor1 = 1;

/* Default will do instruction relax, -O0 will set s3_g_opt = 0.  */
static unsigned int s3_g_opt = 1;

/* The size of the small data section.  */
static unsigned int s3_g_switch_value = 8;

static segT s3_pdr_seg;

struct s3_score_it
{
  char name[s3_INSN_NAME_LEN];
  bfd_vma instruction;
  bfd_vma relax_inst;
  int size;
  int relax_size;
  enum score_insn_type type;
  char str[s3_MAX_LITERAL_POOL_SIZE];
  const char *error;
  int bwarn;
  char reg[s3_INSN_NAME_LEN];
  struct
  {
    bfd_reloc_code_real_type type;
    expressionS exp;
    int pc_rel;
  }reloc;
};
static struct s3_score_it s3_inst;

typedef struct s3_proc
{
  symbolS *isym;
  unsigned long reg_mask;
  unsigned long reg_offset;
  unsigned long fpreg_mask;
  unsigned long leaf;
  unsigned long frame_offset;
  unsigned long frame_reg;
  unsigned long pc_reg;
} s3_procS;
static s3_procS s3_cur_proc;
static s3_procS *s3_cur_proc_ptr;
static int s3_numprocs;


/* Structure for a hash table entry for a register.  */
struct s3_reg_entry
{
  const char *name;
  int number;
};

static const struct s3_reg_entry s3_score_rn_table[] =
{
  {"r0", 0}, {"r1", 1}, {"r2", 2}, {"r3", 3},
  {"r4", 4}, {"r5", 5}, {"r6", 6}, {"r7", 7},
  {"r8", 8}, {"r9", 9}, {"r10", 10}, {"r11", 11},
  {"r12", 12}, {"r13", 13}, {"r14", 14}, {"r15", 15},
  {"r16", 16}, {"r17", 17}, {"r18", 18}, {"r19", 19},
  {"r20", 20}, {"r21", 21}, {"r22", 22}, {"r23", 23},
  {"r24", 24}, {"r25", 25}, {"r26", 26}, {"r27", 27},
  {"r28", 28}, {"r29", 29}, {"r30", 30}, {"r31", 31},
  {NULL, 0}
};

static const struct s3_reg_entry s3_score_srn_table[] =
{
  {"sr0", 0}, {"sr1", 1}, {"sr2", 2},
  {NULL, 0}
};

static const struct s3_reg_entry s3_score_crn_table[] =
{
  {"cr0", 0}, {"cr1", 1}, {"cr2", 2}, {"cr3", 3},
  {"cr4", 4}, {"cr5", 5}, {"cr6", 6}, {"cr7", 7},
  {"cr8", 8}, {"cr9", 9}, {"cr10", 10}, {"cr11", 11},
  {"cr12", 12}, {"cr13", 13}, {"cr14", 14}, {"cr15", 15},
  {"cr16", 16}, {"cr17", 17}, {"cr18", 18}, {"cr19", 19},
  {"cr20", 20}, {"cr21", 21}, {"cr22", 22}, {"cr23", 23},
  {"cr24", 24}, {"cr25", 25}, {"cr26", 26}, {"cr27", 27},
  {"cr28", 28}, {"cr29", 29}, {"cr30", 30}, {"cr31", 31},
  {NULL, 0}
};

struct s3_reg_map
{
  const struct s3_reg_entry *names;
  int max_regno;
  struct hash_control *htab;
  const char *expected;
};

static struct s3_reg_map s3_all_reg_maps[] =
{
  {s3_score_rn_table, 31, NULL, N_("S+core register expected")},
  {s3_score_srn_table, 2, NULL, N_("S+core special-register expected")},
  {s3_score_crn_table, 31, NULL, N_("S+core co-processor register expected")},
};

static struct hash_control *s3_score_ops_hsh = NULL;
static struct hash_control *s3_dependency_insn_hsh = NULL;


struct s3_datafield_range
{
  int data_type;
  int bits;
  int range[2];
};

static struct s3_datafield_range s3_score_df_range[] =
{
  {_IMM4,             4,  {0, (1 << 4) - 1}},	        /* (     0 ~ 15   ) */
  {_IMM5,             5,  {0, (1 << 5) - 1}},	        /* (     0 ~ 31   ) */
  {_IMM8,             8,  {0, (1 << 8) - 1}},	        /* (     0 ~ 255  ) */
  {_IMM14,            14, {0, (1 << 14) - 1}},	        /* (     0 ~ 16383) */
  {_IMM15,            15, {0, (1 << 15) - 1}},	        /* (     0 ~ 32767) */
  {_IMM16,            16, {0, (1 << 16) - 1}},	        /* (     0 ~ 65535) */
  {_SIMM10,           10, {-(1 << 9), (1 << 9) - 1}},	/* (  -512 ~ 511  ) */
  {_SIMM12,           12, {-(1 << 11), (1 << 11) - 1}},	/* ( -2048 ~ 2047 ) */
  {_SIMM14,           14, {-(1 << 13), (1 << 13) - 1}},	/* ( -8192 ~ 8191 ) */
  {_SIMM15,           15, {-(1 << 14), (1 << 14) - 1}},	/* (-16384 ~ 16383) */
  {_SIMM16,           16, {-(1 << 15), (1 << 15) - 1}},	/* (-32768 ~ 32767) */
  {_SIMM14_NEG,       14, {-(1 << 13), (1 << 13) - 1}},	/* ( -8191 ~ 8192 ) */
  {_IMM16_NEG,        16, {0, (1 << 16) - 1}},	        /* (-65535 ~ 0    ) */
  {_SIMM16_NEG,       16, {-(1 << 15), (1 << 15) - 1}},	/* (-32768 ~ 32767) */
  {_IMM20,            20, {0, (1 << 20) - 1}},
  {_IMM25,            25, {0, (1 << 25) - 1}},
  {_DISP8div2,        8,  {-(1 << 8), (1 << 8) - 1}},	/* (  -256 ~ 255  ) */
  {_DISP11div2,       11, {0, 0}},
  {_DISP19div2,       19, {-(1 << 19), (1 << 19) - 1}},	/* (-524288 ~ 524287) */
  {_DISP24div2,       24, {0, 0}},
  {_VALUE,            32, {0, ((unsigned int)1 << 31) - 1}},
  {_VALUE_HI16,       16, {0, (1 << 16) - 1}},
  {_VALUE_LO16,       16, {0, (1 << 16) - 1}},
  {_VALUE_LDST_LO16,  16, {0, (1 << 16) - 1}},
  {_SIMM16_LA,        16, {-(1 << 15), (1 << 15) - 1}},	/* (-32768 ~ 32767) */
  {_IMM5_RSHIFT_1,    5,  {0, (1 << 6) - 1}},	        /* (     0 ~ 63   ) */
  {_IMM5_RSHIFT_2,    5,  {0, (1 << 7) - 1}},	        /* (     0 ~ 127  ) */
  {_SIMM16_LA_POS,    16, {0, (1 << 15) - 1}},	        /* (     0 ~ 32767) */
  {_IMM5_RANGE_8_31,  5,  {8, 31}},	                /* But for cop0 the valid data : (8 ~ 31). */
  {_IMM10_RSHIFT_2,   10, {-(1 << 11), (1 << 11) - 1}},	/* For ldc#, stc#. */
  {_SIMM10,           10, {0, (1 << 10) - 1}},	        /* ( -1024 ~ 1023 ) */
  {_SIMM12,           12, {0, (1 << 12) - 1}},	        /* ( -2048 ~ 2047 ) */
  {_SIMM14,           14, {0, (1 << 14) - 1}},          /* ( -8192 ~ 8191 ) */
  {_SIMM15,           15, {0, (1 << 15) - 1}},	        /* (-16384 ~ 16383) */
  {_SIMM16,           16, {0, (1 << 16) - 1}},	        /* (-65536 ~ 65536) */
  {_SIMM14_NEG,       14, {0, (1 << 16) - 1}},          /* ( -8191 ~ 8192 ) */
  {_IMM16_NEG,        16, {0, (1 << 16) - 1}},	        /* ( 65535 ~ 0    ) */
  {_SIMM16_NEG,       16, {0, (1 << 16) - 1}},	        /* ( 65535 ~ 0    ) */
  {_IMM20,            20, {0, (1 << 20) - 1}},	        /* (-32768 ~ 32767) */
  {_IMM25,            25, {0, (1 << 25) - 1}},	        /* (-32768 ~ 32767) */
  {_GP_IMM15,         15, {0, (1 << 15) - 1}},	        /* (     0 ~ 65535) */
  {_GP_IMM14,         14, {0, (1 << 14) - 1}},	        /* (     0 ~ 65535) */
  {_SIMM16_pic,       16, {-(1 << 15), (1 << 15) - 1}},	/* (-32768 ~ 32767) */
  {_IMM16_LO16_pic,   16, {0, (1 << 16) - 1}},	        /* ( 65535 ~ 0    ) */
  {_IMM16_pic,        16, {0, (1 << 16) - 1}},	        /* (     0 ~ 65535) */
  {_SIMM5,            5,  {-(1 << 4), (1 << 4) - 1}},	/* (   -16 ~ 15   ) */
  {_SIMM6,            6,  {-(1 << 5), (1 << 5) - 1}},	/* (   -32 ~ 31   ) */
  {_IMM32,            32, {0, 0xfffffff}},
  {_SIMM32,           32, {-0x80000000, 0x7fffffff}},
  {_IMM11,            11, {0, (1 << 11) - 1}},
};

struct s3_asm_opcode
{
  /* Instruction name.  */
  const char *template_name;

  /* Instruction Opcode.  */
  bfd_vma value;

  /* Instruction bit mask.  */
  bfd_vma bitmask;

  /* Relax instruction opcode.  0x8000 imply no relaxation.  */
  bfd_vma relax_value;

  /* Instruction type.  */
  enum score_insn_type type;

  /* Function to call to parse args.  */
  void (*parms) (char *);
};

static const struct s3_asm_opcode s3_score_ldst_insns[] =
{
  {"lw",        0x20000000, 0x3e000000, 0x1000,     Rd_rvalueRs_SI15,     s3_do_ldst_insn},
  {"lw",        0x06000000, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  s3_do_ldst_insn},
  {"lw",        0x0e000000, 0x3e000007, 0x0040,     Rd_rvalueRs_postSI12, s3_do_ldst_insn},
  {"lh",        0x22000000, 0x3e000000, 0x8000,     Rd_rvalueRs_SI15,     s3_do_ldst_insn},
  {"lh",        0x06000001, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  s3_do_ldst_insn},
  {"lh",        0x0e000001, 0x3e000007, 0x8000,     Rd_rvalueRs_postSI12, s3_do_ldst_insn},
  {"lhu",       0x24000000, 0x3e000000, 0x8000,     Rd_rvalueRs_SI15,     s3_do_ldst_insn},
  {"lhu",       0x06000002, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  s3_do_ldst_insn},
  {"lhu",       0x0e000002, 0x3e000007, 0x8000,     Rd_rvalueRs_postSI12, s3_do_ldst_insn},
  {"lb",        0x26000000, 0x3e000000, 0x8000,     Rd_rvalueRs_SI15,     s3_do_ldst_insn},
  {"lb",        0x06000003, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  s3_do_ldst_insn},
  {"lb",        0x0e000003, 0x3e000007, 0x8000,     Rd_rvalueRs_postSI12, s3_do_ldst_insn},
  {"sw",        0x28000000, 0x3e000000, 0x2000,     Rd_lvalueRs_SI15,     s3_do_ldst_insn},
  {"sw",        0x06000004, 0x3e000007, 0x0060,     Rd_lvalueRs_preSI12,  s3_do_ldst_insn},
  {"sw",        0x0e000004, 0x3e000007, 0x8000,     Rd_lvalueRs_postSI12, s3_do_ldst_insn},
  {"sh",        0x2a000000, 0x3e000000, 0x8000,     Rd_lvalueRs_SI15,     s3_do_ldst_insn},
  {"sh",        0x06000005, 0x3e000007, 0x8000,     Rd_lvalueRs_preSI12,  s3_do_ldst_insn},
  {"sh",        0x0e000005, 0x3e000007, 0x8000,     Rd_lvalueRs_postSI12, s3_do_ldst_insn},
  {"lbu",       0x2c000000, 0x3e000000, 0x8000,     Rd_rvalueRs_SI15,     s3_do_ldst_insn},
  {"lbu",       0x06000006, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  s3_do_ldst_insn},
  {"lbu",       0x0e000006, 0x3e000007, 0x8000,     Rd_rvalueRs_postSI12, s3_do_ldst_insn},
  {"sb",        0x2e000000, 0x3e000000, 0x8000,     Rd_lvalueRs_SI15,     s3_do_ldst_insn},
  {"sb",        0x06000007, 0x3e000007, 0x8000,     Rd_lvalueRs_preSI12,  s3_do_ldst_insn},
  {"sb",        0x0e000007, 0x3e000007, 0x8000,     Rd_lvalueRs_postSI12, s3_do_ldst_insn},
};

static const struct s3_asm_opcode s3_score_insns[] =
{
  {"abs",       0x3800000a, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_dsp3},
  {"abs.s",     0x3800004b, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_dsp3},
  {"add",       0x00000010, 0x3e0003ff, 0x4800,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"add.c",     0x00000011, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"add.s",     0x38000048, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_dsp2},
  {"addc",      0x00000012, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"addc.c",    0x00000013, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"addi",      0x02000000, 0x3e0e0001, 0x5c00,     Rd_SI16,              s3_do_rdsi16},
  {"addi.c",    0x02000001, 0x3e0e0001, 0x8000,     Rd_SI16,              s3_do_rdsi16},
  {"addis",     0x0a000000, 0x3e0e0001, 0x8000,     Rd_SI16,              s3_do_rdi16},
  {"addis.c",   0x0a000001, 0x3e0e0001, 0x8000,     Rd_SI16,              s3_do_rdi16},
  {"addi!",     0x5c00,     0x7c00,     0x8000,     Rd_SI6,               s3_do16_addi},
  {"addri",     0x10000000, 0x3e000001, 0x8000,     Rd_Rs_SI14,           s3_do_rdrssi14},
  {"addri.c",   0x10000001, 0x3e000001, 0x8000,     Rd_Rs_SI14,           s3_do_rdrssi14},

  /* add.c <-> add!.  */
  {"add!",      0x4800,     0x7f00,     0x8000,     Rd_Rs,                s3_do16_rdrs2},
  {"subi",      0x02000000, 0x3e0e0001, 0x8000,     Rd_SI16,              s3_do_sub_rdsi16},
  {"subi.c",    0x02000001, 0x3e0e0001, 0x8000,     Rd_SI16,              s3_do_sub_rdsi16},
  {"subis",     0x0a000000, 0x3e0e0001, 0x8000,     Rd_SI16,              s3_do_sub_rdi16},
  {"subis.c",   0x0a000001, 0x3e0e0001, 0x8000,     Rd_SI16,              s3_do_sub_rdi16},
  {"subri",     0x10000000, 0x3e000001, 0x8000,     Rd_Rs_SI14,           s3_do_sub_rdrssi14},
  {"subri.c",   0x10000001, 0x3e000001, 0x8000,     Rd_Rs_SI14,           s3_do_sub_rdrssi14},
  {"and",       0x00000020, 0x3e0003ff, 0x4b00,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"and.c",     0x00000021, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"andi",      0x02080000, 0x3e0e0001, 0x8000,     Rd_I16,               s3_do_rdi16},
  {"andi.c",    0x02080001, 0x3e0e0001, 0x8000,     Rd_I16,               s3_do_rdi16},
  {"andis",     0x0a080000, 0x3e0e0001, 0x8000,     Rd_I16,               s3_do_rdi16},
  {"andis.c",   0x0a080001, 0x3e0e0001, 0x8000,     Rd_I16,               s3_do_rdi16},
  {"andri",     0x18000000, 0x3e000001, 0x8000,     Rd_Rs_I14,            s3_do_rdrsi14},
  {"andri.c",   0x18000001, 0x3e000001, 0x8000,     Rd_Rs_I14,            s3_do_rdrsi14},

  /* and.c <-> and!.  */
  {"and!",      0x4b00,     0x7f00,     0x8000,     Rd_Rs,                s3_do16_rdrs2},
  {"bcs",       0x08000000, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bcc",       0x08000400, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bcnz",      0x08003800, 0x3e007c01, 0x3200,     PC_DISP19div2,        s3_do_branch},
  {"bcsl",      0x08000001, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bccl",      0x08000401, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bcnzl",     0x08003801, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bcnz!",     0x3200,     0x7f00,     0x08003800, PC_DISP8div2,         s3_do16_branch},
  {"beq",       0x08001000, 0x3e007c01, 0x3800,     PC_DISP19div2,        s3_do_branch},
  {"beql",      0x08001001, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"beq!",      0x3800,     0x7e00,     0x08001000, PC_DISP8div2,         s3_do16_branch},
  {"bgtu",      0x08000800, 0x3e007c01, 0x3400,     PC_DISP19div2,        s3_do_branch},
  {"bgt",       0x08001800, 0x3e007c01, 0x3c00,     PC_DISP19div2,        s3_do_branch},
  {"bge",       0x08002000, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bgtul",     0x08000801, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bgtl",      0x08001801, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bgel",      0x08002001, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bgtu!",     0x3400,     0x7e00,     0x08000800, PC_DISP8div2,         s3_do16_branch},
  {"bgt!",      0x3c00,     0x7e00,     0x08001800, PC_DISP8div2,         s3_do16_branch},
  {"bitclr",    0x00000028, 0x3e0003ff, 0x5000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"bitclr.c",  0x00000029, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},

  {"mbitclr",   0x00000064, 0x3e00007e, 0x8000,     Ra_I9_I5,             s3_do_mbitclr},
  {"mbitset",   0x0000006c, 0x3e00007e, 0x8000,     Ra_I9_I5,             s3_do_mbitset},

  {"bitrev",    0x3800000c, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_dsp2},
  {"bitset",    0x0000002a, 0x3e0003ff, 0x5200,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"bitset.c",  0x0000002b, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"bittst.c",  0x0000002d, 0x3e0003ff, 0x5400,     x_Rs_I5,              s3_do_xrsi5},
  {"bittgl",    0x0000002e, 0x3e0003ff, 0x5600,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"bittgl.c",  0x0000002f, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"bitclr!",   0x5000,     0x7e00,     0x8000,     Rd_I5,                s3_do16_rdi5},
  {"bitset!",   0x5200,     0x7e00,     0x8000,     Rd_I5,                s3_do16_rdi5},
  {"bittst!",   0x5400,     0x7e00,     0x8000,     Rd_I5,                s3_do16_rdi5},
  {"bittgl!",   0x5600,     0x7e00,     0x8000,     Rd_I5,                s3_do16_rdi5},
  {"bleu",      0x08000c00, 0x3e007c01, 0x3600,     PC_DISP19div2,        s3_do_branch},
  {"ble",       0x08001c00, 0x3e007c01, 0x3e00,     PC_DISP19div2,        s3_do_branch},
  {"blt",       0x08002400, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bleul",     0x08000c01, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"blel",      0x08001c01, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bltl",      0x08002401, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bl",        0x08003c01, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bleu!",     0x3600,     0x7e00,     0x08000c00, PC_DISP8div2,         s3_do16_branch},
  {"ble!",      0x3e00,     0x7e00,     0x08001c00, PC_DISP8div2,         s3_do16_branch},
  {"bmi",       0x08002800, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bmil",      0x08002801, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bne",       0x08001400, 0x3e007c01, 0x3a00,     PC_DISP19div2,        s3_do_branch},
  {"bnel",      0x08001401, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bne!",      0x3a00,     0x7e00,     0x08001400, PC_DISP8div2,         s3_do16_branch},
  {"bpl",       0x08002c00, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bpll",      0x08002c01, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"brcs",      0x00000008, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brcc",      0x00000408, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brgtu",     0x00000808, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brleu",     0x00000c08, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"breq",      0x00001008, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brne",      0x00001408, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brgt",      0x00001808, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brle",      0x00001c08, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brge",      0x00002008, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brlt",      0x00002408, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brmi",      0x00002808, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brpl",      0x00002c08, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brvs",      0x00003008, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brvc",      0x00003408, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brcnz",     0x00003808, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"br",        0x00003c08, 0x3e007fff, 0x0080,     x_Rs_x,               s3_do_rs},
  {"brcsl",     0x00000009, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brccl",     0x00000409, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brgtul",    0x00000809, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brleul",    0x00000c09, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"breql",     0x00001009, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brnel",     0x00001409, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brgtl",     0x00001809, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brlel",     0x00001c09, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brgel",     0x00002009, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brltl",     0x00002409, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brmil",     0x00002809, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brpll",     0x00002c09, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brvsl",     0x00003009, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brvcl",     0x00003409, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brcnzl",    0x00003809, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"brl",       0x00003c09, 0x3e007fff, 0x00a0,     x_Rs_x,               s3_do_rs},
  {"br!",       0x0080,     0x7fe0,     0x8000,     x_Rs,                 s3_do16_br},
  {"brl!",      0x00a0,     0x7fe0,     0x8000,     x_Rs,                 s3_do16_br},
  {"brr!",      0x00c0,     0x7fe0,     0x8000,     x_Rs,                 s3_do16_brr},
  {"bvs",       0x08003000, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bvc",       0x08003400, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bvsl",      0x08003001, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"bvcl",      0x08003401, 0x3e007c01, 0x8000,     PC_DISP19div2,        s3_do_branch},
  {"b!",        0x3000,     0x7e00,     0x08003c00, PC_DISP8div2,         s3_do16_branch},
  {"b",         0x08003c00, 0x3e007c01, 0x3000,     PC_DISP19div2,        s3_do_branch},
  {"cache",     0x30000000, 0x3ff00000, 0x8000,     OP5_rvalueRs_SI15,    s3_do_cache},
  {"ceinst",    0x38000000, 0x3e000000, 0x8000,     I5_Rs_Rs_I5_OP5,      s3_do_ceinst},
  {"clz",       0x0000001c, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"cmp.c",     0x00300019, 0x3ff003ff, 0x4400,     x_Rs_Rs,              s3_do_rsrs},
  {"cmpz.c",    0x0030001b, 0x3ff07fff, 0x8000,     x_Rs_x,               s3_do_rs},
  {"cmpi.c",    0x02040001, 0x3e0e0001, 0x6000,     Rd_SI16,              s3_do_rdsi16},

  /* cmp.c <-> cmp!.  */
  {"cmp!",      0x4400,     0x7c00,     0x8000,     Rd_Rs,                s3_do16_mv_cmp},
  {"cmpi!",     0x6000,     0x7c00,     0x8000,     Rd_SI5,               s3_do16_cmpi},
  {"cop1",      0x0c00000c, 0x3e00001f, 0x8000,     Rd_Rs_Rs_imm,         s3_do_crdcrscrsimm5},
  {"cop2",      0x0c000014, 0x3e00001f, 0x8000,     Rd_Rs_Rs_imm,         s3_do_crdcrscrsimm5},
  {"cop3",      0x0c00001c, 0x3e00001f, 0x8000,     Rd_Rs_Rs_imm,         s3_do_crdcrscrsimm5},
  {"drte",      0x0c0000a4, 0x3e0003ff, 0x8000,     NO_OPD,               s3_do_empty},
  {"disint!",    0x00e0,     0xffe1,     0x8000,     NO16_OPD,               s3_do16_int},
  {"enint!",     0x00e1,     0xffe1,     0x8000,     NO16_OPD,               s3_do16_int},
  {"extsb",     0x00000058, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"extsb.c",   0x00000059, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"extsh",     0x0000005a, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"extsh.c",   0x0000005b, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"extzb",     0x0000005c, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"extzb.c",   0x0000005d, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"extzh",     0x0000005e, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"extzh.c",   0x0000005f, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"jl",        0x04000001, 0x3e000001, 0x8000,     PC_DISP24div2,        s3_do_jump},
  {"j",         0x04000000, 0x3e000001, 0x8000,     PC_DISP24div2,        s3_do_jump},
  {"alw",       0x0000000c, 0x3e0003ff, 0x8000,     Rd_rvalue32Rs,        s3_do_ldst_atomic},
  {"lcb",       0x00000060, 0x3e0003ff, 0x8000,     x_rvalueRs_post4,     s3_do_ldst_unalign},
  {"lcw",       0x00000062, 0x3e0003ff, 0x8000,     Rd_rvalueRs_post4,    s3_do_ldst_unalign},
  {"lce",       0x00000066, 0x3e0003ff, 0x8000,     Rd_rvalueRs_post4,    s3_do_ldst_unalign},
  {"ldc1",      0x0c00000a, 0x3e00001f, 0x8000,     Rd_rvalueRs_SI10,     s3_do_ldst_cop},
  {"ldc2",      0x0c000012, 0x3e00001f, 0x8000,     Rd_rvalueRs_SI10,     s3_do_ldst_cop},
  {"ldc3",      0x0c00001a, 0x3e00001f, 0x8000,     Rd_rvalueRs_SI10,     s3_do_ldst_cop},

  /* s3_inst.relax */
  {"ldi",       0x020c0000, 0x3e0e0000, 0x6400,     Rd_SI16,              s3_do_rdsi16},
  {"ldis",      0x0a0c0000, 0x3e0e0000, 0x8000,     Rd_I16,               s3_do_ldis},

  /* ldi <-> ldiu!.  */
  {"ldiu!",     0x6400,     0x7c00,     0x8000,     Rd_I5,                s3_do16_ldiu},

  /*ltbb! , ltbh! ltbw! */
  {"ltbw",      0x00000032, 0x03ff,     0x8000,     Rd_Rs_Rs,             s3_do_ltb},
  {"ltbh",      0x00000132, 0x03ff,     0x8000,     Rd_Rs_Rs,             s3_do_ltb},
  {"ltbb",      0x00000332, 0x03ff,     0x8000,     Rd_Rs_Rs,             s3_do_ltb},
  {"lw!",       0x1000,     0x7000,     0x8000,     Rd_rvalueRs,          s3_do16_ldst_insn},
  {"mfcel",     0x00000448, 0x3e007fff, 0x8000,     Rd_x_x,               s3_do_rd},
  {"mfcel!",    0x7100,     0x7ff0,     0x00000448, x_Rs,                 s3_do16_dsp},
  {"mad",       0x38000000, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mad.f!",    0x7400,     0x7f00,     0x38000080, Rd_Rs,                s3_do16_dsp2},
  {"madh",      0x38000203, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"madh.fs",   0x380002c3, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"madh.fs!",  0x7b00,     0x7f00,     0x380002c3, Rd_Rs,                s3_do16_dsp2},
  {"madl",      0x38000002, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"madl.fs",   0x380000c2, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"madl.fs!",  0x7a00,     0x7f00,     0x380000c2, Rd_Rs,                s3_do16_dsp2},
  {"madu",      0x38000020, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"madu!",     0x7500,     0x7f00,     0x38000020, Rd_Rs,                s3_do16_dsp2},
  {"mad.f",     0x38000080, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"max",       0x38000007, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_dsp2},
  {"mazh",      0x38000303, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mazh.f",    0x38000383, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mazh.f!",   0x7900,     0x7f00,     0x3800038c, Rd_Rs,                s3_do16_dsp2},
  {"mazl",      0x38000102, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mazl.f",    0x38000182, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mazl.f!",   0x7800,     0x7f00,     0x38000182, Rd_Rs,                s3_do16_dsp2},
  {"mfceh",     0x00000848, 0x3e007fff, 0x8000,     Rd_x_x,               s3_do_rd},
  {"mfceh!",    0x7110,     0x7ff0,     0x00000848, x_Rs,                 s3_do16_dsp},
  {"mfcehl",    0x00000c48, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mfsr",      0x00000050, 0x3e0003ff, 0x8000,     Rd_x_I5,              s3_do_rdsrs},
  {"mfcr",      0x0c000001, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mfc1",      0x0c000009, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mfc2",      0x0c000011, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mfc3",      0x0c000019, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mfcc1",     0x0c00000f, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mfcc2",     0x0c000017, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mfcc3",     0x0c00001f, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"min",       0x38000006, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_dsp2},
  {"msb",       0x38000001, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"msb.f!",    0x7600,     0x7f00,     0x38000081, Rd_Rs,                s3_do16_dsp2},
  {"msbh",      0x38000205, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"msbh.fs",   0x380002c5, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"msbh.fs!",  0x7f00,     0x7f00,     0x380002c5, Rd_Rs,                s3_do16_dsp2},
  {"msbl",      0x38000004, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"msbl.fs",   0x380000c4, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"msbl.fs!",  0x7e00,     0x7f00,     0x380000c4, Rd_Rs,                s3_do16_dsp2},
  {"msbu",      0x38000021, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"msbu!",     0x7700,     0x7f00,     0x38000021, Rd_Rs,                s3_do16_dsp2},
  {"msb.f",     0x38000081, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mszh",      0x38000305, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mszh.f",    0x38000385, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mszh.f!",   0x7d00,     0x7f00,     0x38000385, Rd_Rs,                s3_do16_dsp2},
  {"mszl",      0x38000104, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mszl.f",    0x38000184, 0x3ff003ff, 0x8000,     x_Rs_Rs,              s3_do_dsp},
  {"mszl.f!",   0x7c00,     0x7f00,     0x38000184, Rd_Rs,                s3_do16_dsp2},
  {"mtcel!",    0x7000,     0x7ff0,     0x0000044a, x_Rs,                 s3_do16_dsp},
  {"mtcel",     0x0000044a, 0x3e007fff, 0x8000,     Rd_x_x,               s3_do_rd},
  {"mtceh",     0x0000084a, 0x3e007fff, 0x8000,     Rd_x_x,               s3_do_rd},
  {"mtceh!",    0x7010,     0x7ff0,     0x0000084a, x_Rs,                 s3_do16_dsp},
  {"mtcehl",    0x00000c4a, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mtsr",      0x00000052, 0x3e0003ff, 0x8000,     x_Rs_I5,              s3_do_rdsrs},
  {"mtcr",      0x0c000000, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mtc1",      0x0c000008, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mtc2",      0x0c000010, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mtc3",      0x0c000018, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mtcc1",     0x0c00000e, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mtcc2",     0x0c000016, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mtcc3",     0x0c00001e, 0x3e00001f, 0x8000,     Rd_Rs_x,              s3_do_rdcrs},
  {"mul.f!",    0x7200,     0x7f00,     0x00000041, Rd_Rs,                s3_do16_dsp2},
  {"mulu!",     0x7300,     0x7f00,     0x00000042, Rd_Rs,                s3_do16_dsp2},
  {"mulr.l",    0x00000140, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mulr.h",    0x00000240, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mulr",      0x00000340, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mulr.lf",   0x00000141, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mulr.hf",   0x00000241, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mulr.f",    0x00000341, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mulur.l",   0x00000142, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mulur.h",   0x00000242, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mulur",     0x00000342, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"divr.q",    0x00000144, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"divr.r",    0x00000244, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"divr",      0x00000344, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"divur.q",   0x00000146, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"divur.r",   0x00000246, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"divur",     0x00000346, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_rdrsrs},
  {"mvcs",      0x00000056, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvcc",      0x00000456, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvgtu",     0x00000856, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvleu",     0x00000c56, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mveq",      0x00001056, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvne",      0x00001456, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvgt",      0x00001856, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvle",      0x00001c56, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvge",      0x00002056, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvlt",      0x00002456, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvmi",      0x00002856, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvpl",      0x00002c56, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvvs",      0x00003056, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"mvvc",      0x00003456, 0x3e007fff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},

  /* mv <-> mv!.  */
  {"mv",        0x00003c56, 0x3e007fff, 0x4000,     Rd_Rs_x,              s3_do_rdrs},
  {"mv!",       0x4000,     0x7c00,     0x8000,     Rd_Rs,                s3_do16_mv_cmp},
  {"neg",       0x0000001e, 0x3e0003ff, 0x8000,     Rd_x_Rs,              s3_do_rdxrs},
  {"neg.c",     0x0000001f, 0x3e0003ff, 0x8000,     Rd_x_Rs,              s3_do_rdxrs},
  {"nop",       0x00000000, 0x3e0003ff, 0x0000,     NO_OPD,               s3_do_empty},
  {"not",       0x00000024, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"not.c",     0x00000025, 0x3e0003ff, 0x8000,     Rd_Rs_x,              s3_do_rdrs},
  {"nop!",      0x0000,     0x7fff,     0x8000,     NO16_OPD,             s3_do_empty},
  {"or",        0x00000022, 0x3e0003ff, 0x4a00,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"or.c",      0x00000023, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"ori",       0x020a0000, 0x3e0e0001, 0x8000,     Rd_I16,               s3_do_rdi16},
  {"ori.c",     0x020a0001, 0x3e0e0001, 0x8000,     Rd_I16,               s3_do_rdi16},
  {"oris",      0x0a0a0000, 0x3e0e0001, 0x8000,     Rd_I16,               s3_do_rdi16},
  {"oris.c",    0x0a0a0001, 0x3e0e0001, 0x8000,     Rd_I16,               s3_do_rdi16},
  {"orri",      0x1a000000, 0x3e000001, 0x8000,     Rd_Rs_I14,            s3_do_rdrsi14},
  {"orri.c",    0x1a000001, 0x3e000001, 0x8000,     Rd_Rs_I14,            s3_do_rdrsi14},

  /* or.c <-> or!.  */
  {"or!",       0x4a00,     0x7f00,     0x8000,     Rd_Rs,                s3_do16_rdrs2},
  {"pflush",    0x0000000a, 0x3e0003ff, 0x8000,     NO_OPD,               s3_do_empty},
  {"pop!",      0x0040,     0x7fe0,     0x8000,     Rd_rvalueRs,          s3_do16_push_pop},
  {"push!",     0x0060,     0x7fe0,     0x8000,     Rd_lvalueRs,          s3_do16_push_pop},

  {"rpop!",     0x6800,     0x7c00,     0x8000,     Rd_I5,                s3_do16_rpop},
  {"rpush!",    0x6c00,     0x7c00,     0x8000,     Rd_I5,                s3_do16_rpush},

  {"ror",       0x00000038, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"ror.c",     0x00000039, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"rorc.c",    0x0000003b, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"rol",       0x0000003c, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"rol.c",     0x0000003d, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"rolc.c",    0x0000003f, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"rori",      0x00000078, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"rori.c",    0x00000079, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"roric.c",   0x0000007b, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"roli",      0x0000007c, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"roli.c",    0x0000007d, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"rolic.c",   0x0000007f, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"rte",       0x0c000084, 0x3e0003ff, 0x8000,     NO_OPD,               s3_do_empty},
  {"asw",       0x0000000e, 0x3e0003ff, 0x8000,     Rd_lvalue32Rs,        s3_do_ldst_atomic},
  {"scb",       0x00000068, 0x3e0003ff, 0x8000,     Rd_lvalueRs_post4,    s3_do_ldst_unalign},
  {"scw",       0x0000006a, 0x3e0003ff, 0x8000,     Rd_lvalueRs_post4,    s3_do_ldst_unalign},
  {"sce",       0x0000006e, 0x3e0003ff, 0x8000,     x_lvalueRs_post4,     s3_do_ldst_unalign},
  {"sdbbp",     0x00000006, 0x3e0003ff, 0x0020,     x_I5_x,               s3_do_xi5x},
  {"sdbbp!",    0x0020,     0x7fe0,     0x8000,     Rd_I5,                s3_do16_xi5},
  {"sleep",     0x0c0000c4, 0x3e0003ff, 0x8000,     NO_OPD,               s3_do_empty},
  {"rti",       0x0c0000e4, 0x3e0003ff, 0x8000,     NO_OPD,               s3_do_empty},
  {"sll",       0x00000030, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"sll.c",     0x00000031, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"sll.s",     0x3800004e, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_dsp2},
  {"slli",      0x00000070, 0x3e0003ff, 0x5800,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"slli.c",    0x00000071, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},

  /* slli.c <-> slli!.  */
  {"slli!",     0x5800,     0x7e00,     0x8000,     Rd_I5,                s3_do16_slli_srli},
  {"srl",       0x00000034, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"srl.c",     0x00000035, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"sra",       0x00000036, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"sra.c",     0x00000037, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"srli",      0x00000074, 0x3e0003ff, 0x5a00,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"srli.c",    0x00000075, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"srai",      0x00000076, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},
  {"srai.c",    0x00000077, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             s3_do_rdrsi5},

  /* srli.c <-> srli!.  */
  {"srli!",     0x5a00,     0x7e00,     0x8000,     Rd_Rs,                s3_do16_slli_srli},
  {"stc1",      0x0c00000b, 0x3e00001f, 0x8000,     Rd_lvalueRs_SI10,     s3_do_ldst_cop},
  {"stc2",      0x0c000013, 0x3e00001f, 0x8000,     Rd_lvalueRs_SI10,     s3_do_ldst_cop},
  {"stc3",      0x0c00001b, 0x3e00001f, 0x8000,     Rd_lvalueRs_SI10,     s3_do_ldst_cop},
  {"sub",       0x00000014, 0x3e0003ff, 0x4900,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"sub.c",     0x00000015, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"sub.s",     0x38000049, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_dsp2},
  {"subc",      0x00000016, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"subc.c",    0x00000017, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},

  /* sub.c <-> sub!.  */
  {"sub!",      0x4900,     0x7f00,     0x8000,     Rd_Rs,                s3_do16_rdrs2},
  {"sw!",       0x2000,     0x7000,     0x8000,     Rd_lvalueRs,          s3_do16_ldst_insn},
  {"syscall",   0x00000002, 0x3e0003ff, 0x8000,     I15,                  s3_do_i15},
  {"trapcs",    0x00000004, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapcc",    0x00000404, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapgtu",   0x00000804, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapleu",   0x00000c04, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapeq",    0x00001004, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapne",    0x00001404, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapgt",    0x00001804, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"traple",    0x00001c04, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapge",    0x00002004, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"traplt",    0x00002404, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapmi",    0x00002804, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trappl",    0x00002c04, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapvs",    0x00003004, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trapvc",    0x00003404, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"trap",      0x00003c04, 0x3e007fff, 0x8000,     x_I5_x,               s3_do_xi5x},
  {"xor",       0x00000026, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},
  {"xor.c",     0x00000027, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             s3_do_rdrsrs},

  /* Macro instruction.  */
  {"li",        0x020c0000, 0x3e0e0000, 0x8000,     Insn_Type_SYN,        s3_do_macro_li_rdi32},

  /* la reg, imm32        -->(1)  ldi  reg, simm16
                             (2)  ldis reg, %HI(imm32)
                                  ori  reg, %LO(imm32)

     la reg, symbol       -->(1)  lis  reg, %HI(imm32)
                                  ori  reg, %LO(imm32)  */
  {"la",        0x020c0000, 0x3e0e0000, 0x8000,     Insn_Type_SYN,        s3_do_macro_la_rdi32},
  {"bcmpeqz",       0x0000004c, 0x3e00007e, 0x8000,     Insn_BCMP,        s3_do_macro_bcmpz},
  {"bcmpeq",       0x0000004c, 0x3e00007e, 0x8000,     Insn_BCMP,        s3_do_macro_bcmp},
  {"bcmpnez",       0x0000004e, 0x3e00007e, 0x8000,     Insn_BCMP,        s3_do_macro_bcmpz},
  {"bcmpne",       0x0000004e, 0x3e00007e, 0x8000,     Insn_BCMP,        s3_do_macro_bcmp},
  {"div",       0x00000044, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"divu",      0x00000046, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"rem",       0x00000044, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"remu",      0x00000046, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"mul",       0x00000040, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"mulu",      0x00000042, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"maz",       0x00000040, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"mazu",      0x00000042, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"mul.f",     0x00000041, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"maz.f",     0x00000041, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        s3_do_macro_mul_rdrsrs},
  {"lb",        INSN_LB,    0x00000000, 0x8000,     Insn_Type_SYN,        s3_do_macro_ldst_label},
  {"lbu",       INSN_LBU,   0x00000000, 0x8000,     Insn_Type_SYN,        s3_do_macro_ldst_label},
  {"lh",        INSN_LH,    0x00000000, 0x8000,     Insn_Type_SYN,        s3_do_macro_ldst_label},
  {"lhu",       INSN_LHU,   0x00000000, 0x8000,     Insn_Type_SYN,        s3_do_macro_ldst_label},
  {"lw",        INSN_LW,    0x00000000, 0x1000,     Insn_Type_SYN,        s3_do_macro_ldst_label},
  {"sb",        INSN_SB,    0x00000000, 0x8000,     Insn_Type_SYN,        s3_do_macro_ldst_label},
  {"sh",        INSN_SH,    0x00000000, 0x8000,     Insn_Type_SYN,        s3_do_macro_ldst_label},
  {"sw",        INSN_SW,    0x00000000, 0x2000,     Insn_Type_SYN,        s3_do_macro_ldst_label},

  /* Assembler use internal.  */
  {"ld_i32hi",  0x0a0c0000, 0x3e0e0000, 0x8000,     Insn_internal, s3_do_macro_rdi32hi},
  {"ld_i32lo",  0x020a0000, 0x3e0e0001, 0x8000,     Insn_internal, s3_do_macro_rdi32lo},
  {"ldis_pic",  0x0a0c0000, 0x3e0e0000, 0x8000,     Insn_internal, s3_do_rdi16_pic},
  {"addi_s_pic",0x02000000, 0x3e0e0001, 0x8000,     Insn_internal, s3_do_addi_s_pic},
  {"addi_u_pic",0x02000000, 0x3e0e0001, 0x8000,     Insn_internal, s3_do_addi_u_pic},
  {"lw_pic",    0x20000000, 0x3e000000, 0x8000,     Insn_internal, s3_do_lw_pic},

  /* 48-bit instructions.  */
  {"sdbbp48",   0x000000000000LL,   0x1c000000001fLL,   0x8000,     Rd_I32,    s3_do_sdbbp48},
  {"ldi48",     0x000000000001LL,   0x1c000000001fLL,   0x8000,     Rd_I32,    s3_do_ldi48},
  {"lw48",      0x000000000002LL,   0x1c000000001fLL,   0x8000,     Rd_I30,    s3_do_lw48},
  {"sw48",      0x000000000003LL,   0x1c000000001fLL,   0x8000,     Rd_I30,    s3_do_sw48},
  {"andri48",   0x040000000000LL,   0x1c0000000003LL,   0x8000,     Rd_I32,    s3_do_and48},
  {"andri48.c", 0x040000000001LL,   0x1c0000000003LL,   0x8000,     Rd_I32,    s3_do_and48},
  {"orri48",    0x040000000002LL,   0x1c0000000003LL,   0x8000,     Rd_I32,    s3_do_or48},
  {"orri48.c",  0x040000000003LL,   0x1c0000000003LL,   0x8000,     Rd_I32,    s3_do_or48},
};

#define s3_SCORE3_PIPELINE 3

static int s3_university_version = 0;
static int s3_vector_size = s3_SCORE3_PIPELINE;
static struct s3_score_it s3_dependency_vector[s3_SCORE3_PIPELINE];

static int s3_score3d = 1;

static int
s3_end_of_line (char *str)
{
  int retval = s3_SUCCESS;

  s3_skip_whitespace (str);
  if (*str != '\0')
    {
      retval = (int) s3_FAIL;

      if (!s3_inst.error)
        s3_inst.error = s3_BAD_GARBAGE;
    }

  return retval;
}

static int
s3_score_reg_parse (char **ccp, struct hash_control *htab)
{
  char *start = *ccp;
  char c;
  char *p;
  struct s3_reg_entry *reg;

  p = start;
  if (!ISALPHA (*p) || !is_name_beginner (*p))
    return (int) s3_FAIL;

  c = *p++;

  while (ISALPHA (c) || ISDIGIT (c) || c == '_')
    c = *p++;

  *--p = 0;
  reg = (struct s3_reg_entry *) hash_find (htab, start);
  *p = c;

  if (reg)
    {
      *ccp = p;
      return reg->number;
    }
  return (int) s3_FAIL;
}

/* If shift <= 0, only return reg.  */

static int
s3_reg_required_here (char **str, int shift, enum s3_score_reg_type reg_type)
{
  static char buff[s3_MAX_LITERAL_POOL_SIZE];
  int reg = (int) s3_FAIL;
  char *start = *str;

  if ((reg = s3_score_reg_parse (str, s3_all_reg_maps[reg_type].htab)) != (int) s3_FAIL)
    {
      if (reg_type == s3_REG_TYPE_SCORE)
        {
          if ((reg == 1) && (s3_nor1 == 1) && (s3_inst.bwarn == 0))
            {
              as_warn (_("Using temp register(r1)"));
              s3_inst.bwarn = 1;
            }
        }
      if (shift >= 0)
	{
          if (reg_type == s3_REG_TYPE_SCORE_CR)
	    strcpy (s3_inst.reg, s3_score_crn_table[reg].name);
          else if (reg_type == s3_REG_TYPE_SCORE_SR)
	    strcpy (s3_inst.reg, s3_score_srn_table[reg].name);
          else
	    strcpy (s3_inst.reg, "");

          s3_inst.instruction |= (bfd_vma) reg << shift;
	}
    }
  else
    {
      *str = start;
      sprintf (buff, _("register expected, not '%.100s'"), start);
      s3_inst.error = buff;
    }

  return reg;
}

static int
s3_skip_past_comma (char **str)
{
  char *p = *str;
  char c;
  int comma = 0;

  while ((c = *p) == ' ' || c == ',')
    {
      p++;
      if (c == ',' && comma++)
        {
          s3_inst.error = s3_BAD_SKIP_COMMA;
          return (int) s3_FAIL;
        }
    }

  if ((c == '\0') || (comma == 0))
    {
      s3_inst.error = s3_BAD_SKIP_COMMA;
      return (int) s3_FAIL;
    }

  *str = p;
  return comma ? s3_SUCCESS : (int) s3_FAIL;
}

static void
s3_do_rdrsrs (char *str)
{
  int reg;
  s3_skip_whitespace (str);

  if ((reg = s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
  else
    {
      /* Check mulr, mulur rd is even number.  */
      if (((s3_inst.instruction & 0x3e0003ff) == 0x00000340
	   || (s3_inst.instruction & 0x3e0003ff) == 0x00000342)
          && (reg % 2))
        {
          s3_inst.error = _("rd must be even number.");
          return;
        }

      if ((((s3_inst.instruction >> 15) & 0x10) == 0)
          && (((s3_inst.instruction >> 10) & 0x10) == 0)
          && (((s3_inst.instruction >> 20) & 0x10) == 0)
          && (s3_inst.relax_inst != 0x8000)
          && (((s3_inst.instruction >> 20) & 0xf) == ((s3_inst.instruction >> 15) & 0xf)))
        {
          s3_inst.relax_inst |= (((s3_inst.instruction >> 10) & 0xf) )
            | (((s3_inst.instruction >> 15) & 0xf) << 4);
          s3_inst.relax_size = 2;
        }
      else
        {
          s3_inst.relax_inst = 0x8000;
        }
    }
}

static int
s3_walk_no_bignums (symbolS * sp)
{
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;

  if (symbol_get_value_expression (sp)->X_add_symbol)
    return (s3_walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	    || (symbol_get_value_expression (sp)->X_op_symbol
		&& s3_walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));

  return 0;
}

static int
s3_my_get_expression (expressionS * ep, char **str)
{
  char *save_in;

  save_in = input_line_pointer;
  input_line_pointer = *str;
  s3_in_my_get_expression = 1;
  (void) expression (ep);
  s3_in_my_get_expression = 0;

  if (ep->X_op == O_illegal)
    {
      *str = input_line_pointer;
      input_line_pointer = save_in;
      s3_inst.error = _("illegal expression");
      return (int) s3_FAIL;
    }
  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.  Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (ep->X_op == O_big
      || (ep->X_add_symbol
          && (s3_walk_no_bignums (ep->X_add_symbol)
              || (ep->X_op_symbol && s3_walk_no_bignums (ep->X_op_symbol)))))
    {
      s3_inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return (int) s3_FAIL;
    }

  if ((ep->X_add_symbol != NULL)
      && (s3_inst.type != PC_DISP19div2)
      && (s3_inst.type != PC_DISP8div2)
      && (s3_inst.type != PC_DISP24div2)
      && (s3_inst.type != PC_DISP11div2)
      && (s3_inst.type != Insn_Type_SYN)
      && (s3_inst.type != Rd_rvalueRs_SI15)
      && (s3_inst.type != Rd_lvalueRs_SI15)
      && (s3_inst.type != Insn_internal)
      && (s3_inst.type != Rd_I30)
      && (s3_inst.type != Rd_I32)
      && (s3_inst.type != Insn_BCMP))
    {
      s3_inst.error = s3_BAD_ARGS;
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return (int) s3_FAIL;
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  return s3_SUCCESS;
}

/* Check if an immediate is valid.  If so, convert it to the right format.  */
static bfd_signed_vma
s3_validate_immediate (bfd_signed_vma val, unsigned int data_type, int hex_p)
{
  switch (data_type)
    {
    case _VALUE_HI16:
      {
        bfd_signed_vma val_hi = ((val & 0xffff0000) >> 16);

        if (s3_score_df_range[data_type].range[0] <= val_hi
            && val_hi <= s3_score_df_range[data_type].range[1])
	  return val_hi;
      }
      break;

    case _VALUE_LO16:
      {
        bfd_signed_vma val_lo = (val & 0xffff);

        if (s3_score_df_range[data_type].range[0] <= val_lo
            && val_lo <= s3_score_df_range[data_type].range[1])
	  return val_lo;
      }
      break;

    case _SIMM14:
      if (hex_p == 1)
        {
          if (!(val >= -0x2000 && val <= 0x3fff))
            {
              return (int) s3_FAIL;
            }
        }
      else
        {
          if (!(val >= -8192 && val <= 8191))
            {
              return (int) s3_FAIL;
            }
        }

      return val;
      break;

    case _SIMM16_NEG:
      if (hex_p == 1)
        {
          if (!(val >= -0x7fff && val <= 0xffff && val != 0x8000))
            {
              return (int) s3_FAIL;
            }
        }
      else
        {
          if (!(val >= -32767 && val <= 32768))
            {
              return (int) s3_FAIL;
            }
        }

      val = -val;
      return val;
      break;

    case _IMM5_MULTI_LOAD:
      if (val >= 2 && val <= 32)
        {
          if (val == 32)
	    val = 0;
          return val;
        }
      return (int) s3_FAIL;

    case _IMM32:
      if (val >= 0 && val <= 0xffffffff)
        {
          return val;
        }
      else
        {
          return (int) s3_FAIL;
        }

    default:
      if (data_type == _SIMM14_NEG || data_type == _IMM16_NEG)
	val = -val;

      if (s3_score_df_range[data_type].range[0] <= val
          && val <= s3_score_df_range[data_type].range[1])
	return val;

      break;
    }

  return (int) s3_FAIL;
}

static int
s3_data_op2 (char **str, int shift, enum score_data_type data_type)
{
  bfd_signed_vma value;
  char data_exp[s3_MAX_LITERAL_POOL_SIZE];
  char *dataptr;
  int cnt = 0;
  char *pp = NULL;

  s3_skip_whitespace (*str);
  s3_inst.error = NULL;
  dataptr = * str;

  /* Set hex_p to zero.  */
  int hex_p = 0;

  while ((*dataptr != '\0') && (*dataptr != '|') && (cnt <= s3_MAX_LITERAL_POOL_SIZE))     /* 0x7c = ='|' */
    {
      data_exp[cnt] = *dataptr;
      dataptr++;
      cnt++;
    }

  data_exp[cnt] = '\0';
  pp = (char *)&data_exp;

  if (*dataptr == '|')          /* process PCE */
    {
      if (s3_my_get_expression (&s3_inst.reloc.exp, &pp) == (int) s3_FAIL)
        return (int) s3_FAIL;
      s3_end_of_line (pp);
      if (s3_inst.error != 0)
        return (int) s3_FAIL;       /* to ouptut_inst to printf out the error */
      *str = dataptr;
    }
  else                          /* process  16 bit */
    {
      if (s3_my_get_expression (&s3_inst.reloc.exp, str) == (int) s3_FAIL)
        {
          return (int) s3_FAIL;
        }

      dataptr = (char *)data_exp;
      for (; *dataptr != '\0'; dataptr++)
        {
          *dataptr = TOLOWER (*dataptr);
          if (*dataptr == '!' || *dataptr == ' ')
            break;
        }
      dataptr = (char *)data_exp;

      if ((dataptr != NULL)
          && (((strstr (dataptr, "0x")) != NULL)
              || ((strstr (dataptr, "0X")) != NULL)))
        {
          hex_p = 1;
          if ((data_type != _SIMM16_LA)
              && (data_type != _VALUE_HI16)
              && (data_type != _VALUE_LO16)
              && (data_type != _IMM16)
              && (data_type != _IMM15)
              && (data_type != _IMM14)
              && (data_type != _IMM4)
              && (data_type != _IMM5)
              && (data_type != _IMM5_MULTI_LOAD)
              && (data_type != _IMM11)
              && (data_type != _IMM8)
              && (data_type != _IMM5_RSHIFT_1)
              && (data_type != _IMM5_RSHIFT_2)
              && (data_type != _SIMM14)
              && (data_type != _SIMM14_NEG)
              && (data_type != _SIMM16_NEG)
              && (data_type != _IMM10_RSHIFT_2)
              && (data_type != _GP_IMM15)
              && (data_type != _SIMM5)
              && (data_type != _SIMM6)
              && (data_type != _IMM32)
              && (data_type != _SIMM32))
            {
              data_type += 24;
            }
        }

      if ((s3_inst.reloc.exp.X_add_number == 0)
          && (s3_inst.type != Insn_Type_SYN)
          && (s3_inst.type != Rd_rvalueRs_SI15)
          && (s3_inst.type != Rd_lvalueRs_SI15)
          && (s3_inst.type != Insn_internal)
          && (((*dataptr >= 'a') && (*dataptr <= 'z'))
	      || ((*dataptr == '0') && (*(dataptr + 1) == 'x') && (*(dataptr + 2) != '0'))
	      || ((*dataptr == '+') && (*(dataptr + 1) != '0'))
	      || ((*dataptr == '-') && (*(dataptr + 1) != '0'))))
        {
          s3_inst.error = s3_BAD_ARGS;
          return (int) s3_FAIL;
        }
    }

  if ((s3_inst.reloc.exp.X_add_symbol)
      && ((data_type == _SIMM16)
          || (data_type == _SIMM16_NEG)
          || (data_type == _IMM16_NEG)
          || (data_type == _SIMM14)
          || (data_type == _SIMM14_NEG)
          || (data_type == _IMM5)
          || (data_type == _IMM5_MULTI_LOAD)
          || (data_type == _IMM11)
          || (data_type == _IMM14)
          || (data_type == _IMM20)
          || (data_type == _IMM16)
          || (data_type == _IMM15)
          || (data_type == _IMM4)))
    {
      s3_inst.error = s3_BAD_ARGS;
      return (int) s3_FAIL;
    }

  if (s3_inst.reloc.exp.X_add_symbol)
    {
      switch (data_type)
        {
        case _SIMM16_LA:
          return (int) s3_FAIL;
        case _VALUE_HI16:
          s3_inst.reloc.type = BFD_RELOC_HI16_S;
          s3_inst.reloc.pc_rel = 0;
          break;
        case _VALUE_LO16:
          s3_inst.reloc.type = BFD_RELOC_LO16;
          s3_inst.reloc.pc_rel = 0;
          break;
        case _GP_IMM15:
          s3_inst.reloc.type = BFD_RELOC_SCORE_GPREL15;
          s3_inst.reloc.pc_rel = 0;
          break;
        case _SIMM16_pic:
        case _IMM16_LO16_pic:
          s3_inst.reloc.type = BFD_RELOC_SCORE_GOT_LO16;
          s3_inst.reloc.pc_rel = 0;
          break;
        default:
          s3_inst.reloc.type = BFD_RELOC_32;
          s3_inst.reloc.pc_rel = 0;
          break;
        }
    }
  else
    {
      if (data_type == _IMM16_pic)
	{
          s3_inst.reloc.type = BFD_RELOC_SCORE_DUMMY_HI16;
          s3_inst.reloc.pc_rel = 0;
	}

      if (data_type == _SIMM16_LA && s3_inst.reloc.exp.X_unsigned == 1)
        {
          value = s3_validate_immediate (s3_inst.reloc.exp.X_add_number, _SIMM16_LA_POS, hex_p);
          if (value == (int) s3_FAIL)       /* for advance to check if this is ldis */
            if ((s3_inst.reloc.exp.X_add_number & 0xffff) == 0)
              {
                s3_inst.instruction |= 0x8000000;
                s3_inst.instruction |= ((s3_inst.reloc.exp.X_add_number >> 16) << 1) & 0x1fffe;
                return s3_SUCCESS;
              }
        }
      else
        {
          value = s3_validate_immediate (s3_inst.reloc.exp.X_add_number, data_type, hex_p);
        }

      if (value == (int) s3_FAIL)
        {
          if (data_type == _IMM32)
            {
              sprintf (s3_err_msg,
                       _("invalid constant: %d bit expression not in range %u..%u"),
                       s3_score_df_range[data_type].bits,
                       0, (unsigned)0xffffffff);
            }
          else if (data_type == _IMM5_MULTI_LOAD)
            {
              sprintf (s3_err_msg,
                       _("invalid constant: %d bit expression not in range %u..%u"),
                       5, 2, 32);
            }
          else if ((data_type != _SIMM14_NEG) && (data_type != _SIMM16_NEG) && (data_type != _IMM16_NEG))
            {
              sprintf (s3_err_msg,
                       _("invalid constant: %d bit expression not in range %d..%d"),
                       s3_score_df_range[data_type].bits,
                       s3_score_df_range[data_type].range[0], s3_score_df_range[data_type].range[1]);
            }
          else
            {
              sprintf (s3_err_msg,
                       _("invalid constant: %d bit expression not in range %d..%d"),
                       s3_score_df_range[data_type].bits,
                       -s3_score_df_range[data_type].range[1], -s3_score_df_range[data_type].range[0]);
            }

          s3_inst.error = s3_err_msg;
          return (int) s3_FAIL;
        }

      if (((s3_score_df_range[data_type].range[0] != 0) || (data_type == _IMM5_RANGE_8_31))
          && data_type != _IMM5_MULTI_LOAD)
        {
          value &= (1 << s3_score_df_range[data_type].bits) - 1;
        }

      s3_inst.instruction |= value << shift;
    }

  if ((s3_inst.instruction & 0x3e000000) == 0x30000000)
    {
      if ((((s3_inst.instruction >> 20) & 0x1F) != 0)
          && (((s3_inst.instruction >> 20) & 0x1F) != 1)
          && (((s3_inst.instruction >> 20) & 0x1F) != 2)
          && (((s3_inst.instruction >> 20) & 0x1F) != 0x10))
        {
          s3_inst.error = _("invalid constant: bit expression not defined");
          return (int) s3_FAIL;
        }
    }

  return s3_SUCCESS;
}

/* Handle addi/addi.c/addis.c/cmpi.c/addis.c/ldi.  */
static void
s3_do_rdsi16 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 1, _SIMM16) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  /* ldi.->ldiu! only for imm5  */
  if ((s3_inst.instruction & 0x20c0000) == 0x20c0000)
    {
      if  ((s3_inst.instruction & 0x1ffc0) != 0)
        {
          s3_inst.relax_inst = 0x8000;
        }
      else
        {
          s3_inst.relax_inst |= (s3_inst.instruction >> 1) & 0x1f;
          s3_inst.relax_inst |= (((s3_inst.instruction >> 20)& 0x1f)  <<5);
          s3_inst.relax_size = 2;
        }
    }
  /*cmpi.c */
  else  if ((s3_inst.instruction & 0x02040001) == 0x02040001)
    {
      /*  imm <=0x3f  (5 bit<<1)*/
      if (((s3_inst.instruction & 0x1ffe0) == 0)
	  || (((s3_inst.instruction & 0x1ffe0) == 0x1ffe0)
	      && (s3_inst.instruction & 0x003e) != 0))
        {
          s3_inst.relax_inst |= (s3_inst.instruction >> 1) & 0x1f;
          s3_inst.relax_inst |= (((s3_inst.instruction >> 20) & 0x1f) << 5);
          s3_inst.relax_size = 2;
        }
      else
        {
          s3_inst.relax_inst =0x8000;

        }
    }
  /* addi */
  else  if (((s3_inst.instruction & 0x2000000) == 0x02000000) && (s3_inst.relax_inst!=0x8000))
    {
      /* rd : 0-16 ; imm <=0x7f  (6 bit<<1)*/
      if ((((s3_inst.instruction >> 20) & 0x10) != 0x10)
	  && (((s3_inst.instruction & 0x1ffc0) == 0)
	      || (((s3_inst.instruction & 0x1ffc0) == 0x1ffc0)
		  && (s3_inst.instruction & 0x007e) != 0)))
        {
          s3_inst.relax_inst |= (s3_inst.instruction >> 1) & 0x3f;
          s3_inst.relax_inst |= (((s3_inst.instruction >> 20) & 0xf) << 6);
          s3_inst.relax_size = 2;
        }
      else
        {
          s3_inst.relax_inst =0x8000;
        }
    }

  else if (((s3_inst.instruction >> 20) & 0x10) == 0x10)
    {
      s3_inst.relax_inst = 0x8000;
    }
}

static void
s3_do_ldis (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 1, _IMM16) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
}

/* Handle subi/subi.c.  */
static void
s3_do_sub_rdsi16 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_data_op2 (&str, 1, _SIMM16_NEG) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle subis/subis.c.  */
static void
s3_do_sub_rdi16 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_data_op2 (&str, 1, _IMM16_NEG) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle addri/addri.c.  */
static void
s3_do_rdrssi14 (char *str)         /* -(2^13)~((2^13)-1) */
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL)
    s3_data_op2 (&str, 1, _SIMM14);
}

/* Handle subri.c/subri.  */
static void
s3_do_sub_rdrssi14 (char *str)     /* -(2^13)~((2^13)-1) */
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_data_op2 (&str, 1, _SIMM14_NEG) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle bitclr.c/bitset.c/bittgl.c/slli.c/srai.c/srli.c/roli.c/rori.c/rolic.c.
   0~((2^14)-1) */
static void
s3_do_rdrsi5 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 10, _IMM5) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if ((((s3_inst.instruction >> 20) & 0x1f) == ((s3_inst.instruction >> 15) & 0x1f))
      && (s3_inst.relax_inst != 0x8000) && (((s3_inst.instruction >> 15) & 0x10) == 0))
    {
      s3_inst.relax_inst |= (((s3_inst.instruction >> 10) & 0x1f) ) | (((s3_inst.instruction >> 15) & 0xf) << 5);
      s3_inst.relax_size = 2;
    }
  else
    s3_inst.relax_inst = 0x8000;
}

/* Handle andri/orri/andri.c/orri.c.
   0 ~ ((2^14)-1)  */
static void
s3_do_rdrsi14 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_data_op2 (&str, 1, _IMM14) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle bittst.c.  */
static void
s3_do_xrsi5 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 10, _IMM5) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if ((s3_inst.relax_inst != 0x8000) && (((s3_inst.instruction >> 15) & 0x10) == 0))
    {
      s3_inst.relax_inst |= ((s3_inst.instruction >> 10) & 0x1f)  | (((s3_inst.instruction >> 15) & 0xf) << 5);
      s3_inst.relax_size = 2;
    }
  else
    s3_inst.relax_inst = 0x8000;
}

/* Handle addis/andi/ori/andis/oris/ldis.  */
static void
s3_do_rdi16 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 1, _IMM16) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  /* ldis */
  if ((s3_inst.instruction & 0x3e0e0000) == 0x0a0c0000)
    {
      /* rd : 0-16 ;imm =0 -> can transform to addi!*/
      if ((((s3_inst.instruction >> 20) & 0x10) != 0x10) && ((s3_inst.instruction & 0x1ffff)==0))
        {
          s3_inst.relax_inst =0x5400; /* ldiu! */
          s3_inst.relax_inst |= (s3_inst.instruction >> 1) & 0x1f;
          s3_inst.relax_inst |= (((s3_inst.instruction >> 20) & 0xf) << 5);
          s3_inst.relax_size = 2;
        }
      else
        {
          s3_inst.relax_inst =0x8000;

        }
    }

  /* addis */
  else if ((s3_inst.instruction & 0x3e0e0001) == 0x0a000000)
    {
      /* rd : 0-16 ;imm =0 -> can transform to addi!*/
      if ((((s3_inst.instruction >> 20) & 0x10) != 0x10) && ((s3_inst.instruction & 0x1ffff)==0))
        {
	  s3_inst.relax_inst =0x5c00; /* addi! */
          s3_inst.relax_inst |= (s3_inst.instruction >> 1) & 0x3f;
          s3_inst.relax_inst |= (((s3_inst.instruction >> 20) & 0xf) << 6);
          s3_inst.relax_size = 2;
        }
      else
        {
          s3_inst.relax_inst =0x8000;

        }
    }
}

static void
s3_do_macro_rdi32hi (char *str)
{
  s3_skip_whitespace (str);

  /* Do not handle s3_end_of_line().  */
  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL)
    s3_data_op2 (&str, 1, _VALUE_HI16);
}

static void
s3_do_macro_rdi32lo (char *str)
{
  s3_skip_whitespace (str);

  /* Do not handle s3_end_of_line().  */
  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL)
    s3_data_op2 (&str, 1, _VALUE_LO16);
}

/* Handle ldis_pic.  */
static void
s3_do_rdi16_pic (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_data_op2 (&str, 1, _IMM16_pic) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle addi_s_pic to generate R_SCORE_GOT_LO16 .  */
static void
s3_do_addi_s_pic (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_data_op2 (&str, 1, _SIMM16_pic) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle addi_u_pic to generate R_SCORE_GOT_LO16 .  */
static void
s3_do_addi_u_pic (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_data_op2 (&str, 1, _IMM16_LO16_pic) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle mfceh/mfcel/mtceh/mtchl.  */
static void
s3_do_rd (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle br{cond},cmpzteq.c ,cmpztmi.c ,cmpz.c */
static void
s3_do_rs (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if ((s3_inst.relax_inst != 0x8000) )
    {
      s3_inst.relax_inst |=  ((s3_inst.instruction >> 15) &0x1f);
      s3_inst.relax_size = 2;
    }
  else
    s3_inst.relax_inst = 0x8000;
}

static void
s3_do_i15 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_data_op2 (&str, 10, _IMM15) != (int) s3_FAIL)
    s3_end_of_line (str);
}

static void
s3_do_xi5x (char *str)
{
  s3_skip_whitespace (str);

  if (s3_data_op2 (&str, 15, _IMM5) == (int) s3_FAIL || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if (s3_inst.relax_inst != 0x8000)
    {
      s3_inst.relax_inst |= ((s3_inst.instruction >> 15) & 0x1f);
      s3_inst.relax_size = 2;
    }
}

static void
s3_do_rdrs (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if (s3_inst.relax_inst != 0x8000)
    {
      if (((s3_inst.instruction & 0x7f) == 0x56))  /* adjust mv -> mv!*/
        {
          /* mv! rd : 5bit , ra : 5bit */
          s3_inst.relax_inst |= ((s3_inst.instruction >> 15) & 0x1f)  | (((s3_inst.instruction >> 20) & 0x1f) << 5);
          s3_inst.relax_size = 2;
        }
      else if ((((s3_inst.instruction >> 15) & 0x10) == 0x0) && (((s3_inst.instruction >> 20) & 0x10) == 0))
        {
          s3_inst.relax_inst |= (((s3_inst.instruction >> 15) & 0xf) << 4)
            | (((s3_inst.instruction >> 20) & 0xf) << 8);
          s3_inst.relax_size = 2;
        }
      else
        {
          s3_inst.relax_inst = 0x8000;
        }
    }
}

/* Handle mfcr/mtcr.  */
static void
s3_do_rdcrs (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
      && s3_skip_past_comma (&str) != (int) s3_FAIL
      && s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE_CR) != (int) s3_FAIL)
    s3_end_of_line (str);
}

/* Handle mfsr/mtsr.  */
static void
s3_do_rdsrs (char *str)
{
  s3_skip_whitespace (str);

  /* mfsr */
  if ((s3_inst.instruction & 0xff) == 0x50)
    {
      if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) != (int) s3_FAIL
          && s3_skip_past_comma (&str) != (int) s3_FAIL
          && s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE_SR) != (int) s3_FAIL)
	s3_end_of_line (str);
    }
  else
    {
      if (s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) != (int) s3_FAIL
          && s3_skip_past_comma (&str) != (int) s3_FAIL)
	s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE_SR);
    }
}

/* Handle neg.  */
static void
s3_do_rdxrs (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if ((s3_inst.relax_inst != 0x8000) && (((s3_inst.instruction >> 10) & 0x10) == 0)
      && (((s3_inst.instruction >> 20) & 0x10) == 0))
    {
      s3_inst.relax_inst |= (((s3_inst.instruction >> 10) & 0xf) << 4) | (((s3_inst.instruction >> 20) & 0xf) << 8);
      s3_inst.relax_size = 2;
    }
  else
    s3_inst.relax_inst = 0x8000;
}

/* Handle cmp.c/cmp<cond>.  */
static void
s3_do_rsrs (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if ((s3_inst.relax_inst != 0x8000) && (((s3_inst.instruction >> 20) & 0x1f) == 3) )
    {
      s3_inst.relax_inst |= (((s3_inst.instruction >> 10) & 0x1f)) | (((s3_inst.instruction >> 15) & 0x1f) << 5);
      s3_inst.relax_size = 2;
    }
  else
    s3_inst.relax_inst = 0x8000;
}

static void
s3_do_ceinst (char *str)
{
  char *strbak;

  strbak = str;
  s3_skip_whitespace (str);

  if (s3_data_op2 (&str, 20, _IMM5) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 5, _IMM5) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 0, _IMM5) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
  else
    {
      str = strbak;
      if (s3_data_op2 (&str, 0, _IMM25) == (int) s3_FAIL)
	return;
    }
}

static int
s3_reglow_required_here (char **str, int shift)
{
  static char buff[s3_MAX_LITERAL_POOL_SIZE];
  int reg;
  char *start = *str;

  if ((reg = s3_score_reg_parse (str, s3_all_reg_maps[s3_REG_TYPE_SCORE].htab)) != (int) s3_FAIL)
    {
      if ((reg == 1) && (s3_nor1 == 1) && (s3_inst.bwarn == 0))
        {
          as_warn (_("Using temp register(r1)"));
          s3_inst.bwarn = 1;
        }
      if (reg < 16)
        {
          if (shift >= 0)
            s3_inst.instruction |= (bfd_vma) reg << shift;

          return reg;
        }
    }

  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;
  sprintf (buff, _("low register(r0-r15)expected, not '%.100s'"), start);
  s3_inst.error = buff;
  return (int) s3_FAIL;
}

/* Handle add!/and!/or!/sub!.  */
static void
s3_do16_rdrs2 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reglow_required_here (&str, 4) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reglow_required_here (&str, 0) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
}

/* Handle br!/brl!.  */
static void
s3_do16_br (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 0, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
}

/* Handle brr!.  */
static void
s3_do16_brr (char *str)
{
  int rd = 0;

  s3_skip_whitespace (str);

  if ((rd = s3_reg_required_here (&str, 0,s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
}

/*Handle ltbw / ltbh / ltbb */
static void
s3_do_ltb (char *str)
{
  s3_skip_whitespace (str);
  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL)
    {
      return;
    }

  s3_skip_whitespace (str);
  if (*str++ != '[')
    {
      s3_inst.error = _("missing [");
      return;
    }

  if (s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
    {
      return;
    }

  s3_skip_whitespace (str);
  if (*str++ != ']')
    {
      s3_inst.error = _("missing ]");
      return;
    }
}

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.  We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */
static fixS *
s3_fix_new_score (fragS * frag, int where, short int size, expressionS * exp, int pc_rel, int reloc)
{
  fixS *new_fix;

  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;
    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0, pc_rel, reloc);
      break;
    }
  return new_fix;
}

static void
s3_init_dependency_vector (void)
{
  int i;

  for (i = 0; i < s3_vector_size; i++)
    memset (&s3_dependency_vector[i], '\0', sizeof (s3_dependency_vector[i]));

  return;
}

static enum s3_insn_type_for_dependency
s3_dependency_type_from_insn (char *insn_name)
{
  char name[s3_INSN_NAME_LEN];
  const struct s3_insn_to_dependency *tmp;

  strcpy (name, insn_name);
  tmp = (const struct s3_insn_to_dependency *) hash_find (s3_dependency_insn_hsh, name);

  if (tmp)
    return tmp->type;

  return s3_D_all_insn;
}

static int
s3_check_dependency (char *pre_insn, char *pre_reg,
		     char *cur_insn, char *cur_reg, int *warn_or_error)
{
  int bubbles = 0;
  unsigned int i;
  enum s3_insn_type_for_dependency pre_insn_type;
  enum s3_insn_type_for_dependency cur_insn_type;

  pre_insn_type = s3_dependency_type_from_insn (pre_insn);
  cur_insn_type = s3_dependency_type_from_insn (cur_insn);

  for (i = 0; i < sizeof (s3_data_dependency_table) / sizeof (s3_data_dependency_table[0]); i++)
    {
      if ((pre_insn_type == s3_data_dependency_table[i].pre_insn_type)
          && (s3_D_all_insn == s3_data_dependency_table[i].cur_insn_type
              || cur_insn_type == s3_data_dependency_table[i].cur_insn_type)
          && (strcmp (s3_data_dependency_table[i].pre_reg, "") == 0
              || strcmp (s3_data_dependency_table[i].pre_reg, pre_reg) == 0)
          && (strcmp (s3_data_dependency_table[i].cur_reg, "") == 0
              || strcmp (s3_data_dependency_table[i].cur_reg, cur_reg) == 0))
        {
          bubbles = s3_data_dependency_table[i].bubblenum_3;
          *warn_or_error = s3_data_dependency_table[i].warn_or_error;
          break;
        }
    }

  return bubbles;
}

static void
s3_build_one_frag (struct s3_score_it one_inst)
{
  char *p;
  int relaxable_p = s3_g_opt;
  int relax_size = 0;

  /* Start a new frag if frag_now is not empty.  */
  if (frag_now_fix () != 0)
    {
      if (!frag_now->tc_frag_data.is_insn)
	frag_wane (frag_now);

      frag_new (0);
    }
  frag_grow (20);

  p = frag_more (one_inst.size);
  s3_md_number_to_chars (p, one_inst.instruction, one_inst.size);

#ifdef OBJ_ELF
  dwarf2_emit_insn (one_inst.size);
#endif

  relaxable_p &= (one_inst.relax_size != 0);
  relax_size = relaxable_p ? one_inst.relax_size : 0;

  p = frag_var (rs_machine_dependent, relax_size + s3_RELAX_PAD_BYTE, 0,
                s3_RELAX_ENCODE (one_inst.size, one_inst.relax_size,
				 one_inst.type, 0, 0, relaxable_p),
                NULL, 0, NULL);

  if (relaxable_p)
    s3_md_number_to_chars (p, one_inst.relax_inst, relax_size);
}

static void
s3_handle_dependency (struct s3_score_it *theinst)
{
  int i;
  int warn_or_error = 0;   /* warn - 0; error - 1  */
  int bubbles = 0;
  int remainder_bubbles = 0;
  char cur_insn[s3_INSN_NAME_LEN];
  char pre_insn[s3_INSN_NAME_LEN];
  struct s3_score_it nop_inst;
  struct s3_score_it pflush_inst;

  nop_inst.instruction = 0x0000;
  nop_inst.size = 2;
  nop_inst.relax_inst = 0x80008000;
  nop_inst.relax_size = 4;
  nop_inst.type = NO16_OPD;

  pflush_inst.instruction = 0x8000800a;
  pflush_inst.size = 4;
  pflush_inst.relax_inst = 0x8000;
  pflush_inst.relax_size = 0;
  pflush_inst.type = NO_OPD;

  /* pflush will clear all data dependency.  */
  if (strcmp (theinst->name, "pflush") == 0)
    {
      s3_init_dependency_vector ();
      return;
    }

  /* Push current instruction to s3_dependency_vector[0].  */
  for (i = s3_vector_size - 1; i > 0; i--)
    memcpy (&s3_dependency_vector[i], &s3_dependency_vector[i - 1], sizeof (s3_dependency_vector[i]));

  memcpy (&s3_dependency_vector[0], theinst, sizeof (s3_dependency_vector[i]));

  /* There is no dependency between nop and any instruction.  */
  if (strcmp (s3_dependency_vector[0].name, "nop") == 0
      || strcmp (s3_dependency_vector[0].name, "nop!") == 0)
    return;

  strcpy (cur_insn, s3_dependency_vector[0].name);

  for (i = 1; i < s3_vector_size; i++)
    {
      /* The element of s3_dependency_vector is NULL.  */
      if (s3_dependency_vector[i].name[0] == '\0')
	continue;

      strcpy (pre_insn, s3_dependency_vector[i].name);

      bubbles = s3_check_dependency (pre_insn, s3_dependency_vector[i].reg,
				     cur_insn, s3_dependency_vector[0].reg, &warn_or_error);
      remainder_bubbles = bubbles - i + 1;

      if (remainder_bubbles > 0)
        {
          int j;

          if (s3_fix_data_dependency == 1)
            {
	      if (remainder_bubbles <= 2)
		{
		  if (s3_warn_fix_data_dependency)
		    as_warn (_("Fix data dependency: %s %s -- %s %s  (insert %d nop!/%d)"),
			     s3_dependency_vector[i].name, s3_dependency_vector[i].reg,
			     s3_dependency_vector[0].name, s3_dependency_vector[0].reg,
			     remainder_bubbles, bubbles);

                  for (j = (s3_vector_size - 1); (j - remainder_bubbles) > 0; j--)
		    memcpy (&s3_dependency_vector[j], &s3_dependency_vector[j - remainder_bubbles],
			    sizeof (s3_dependency_vector[j]));

                  for (j = 1; j <= remainder_bubbles; j++)
                    {
                      memset (&s3_dependency_vector[j], '\0', sizeof (s3_dependency_vector[j]));
		      /* Insert nop!.  */
    		      s3_build_one_frag (nop_inst);
                    }
		}
	      else
		{
		  if (s3_warn_fix_data_dependency)
		    as_warn (_("Fix data dependency: %s %s -- %s %s  (insert 1 pflush/%d)"),
			     s3_dependency_vector[i].name, s3_dependency_vector[i].reg,
			     s3_dependency_vector[0].name, s3_dependency_vector[0].reg,
			     bubbles);

                  for (j = 1; j < s3_vector_size; j++)
		    memset (&s3_dependency_vector[j], '\0', sizeof (s3_dependency_vector[j]));

                  /* Insert pflush.  */
                  s3_build_one_frag (pflush_inst);
		}
            }
          else
            {
	      if (warn_or_error)
		{
                  as_bad (_("data dependency: %s %s -- %s %s  (%d/%d bubble)"),
			  s3_dependency_vector[i].name, s3_dependency_vector[i].reg,
			  s3_dependency_vector[0].name, s3_dependency_vector[0].reg,
			  remainder_bubbles, bubbles);
		}
	      else
		{
                  as_warn (_("data dependency: %s %s -- %s %s  (%d/%d bubble)"),
                           s3_dependency_vector[i].name, s3_dependency_vector[i].reg,
                           s3_dependency_vector[0].name, s3_dependency_vector[0].reg,
                           remainder_bubbles, bubbles);
		}
            }
        }
    }
}

static enum insn_class
s3_get_insn_class_from_type (enum score_insn_type type)
{
  enum insn_class retval = (int) s3_FAIL;

  switch (type)
    {
    case Rd_I4:
    case Rd_I5:
    case Rd_rvalueBP_I5:
    case Rd_lvalueBP_I5:
    case Rd_I8:
    case PC_DISP8div2:
    case PC_DISP11div2:
    case Rd_Rs:
    case Rd_HighRs:
    case Rd_lvalueRs:
    case Rd_rvalueRs:
    case x_Rs:
    case Rd_LowRs:
    case NO16_OPD:
    case Rd_SI5:
    case Rd_SI6:
      retval = INSN_CLASS_16;
      break;
    case Rd_Rs_I5:
    case x_Rs_I5:
    case x_I5_x:
    case Rd_Rs_I14:
    case I15:
    case Rd_I16:
    case Rd_SI16:
    case Rd_rvalueRs_SI10:
    case Rd_lvalueRs_SI10:
    case Rd_rvalueRs_preSI12:
    case Rd_rvalueRs_postSI12:
    case Rd_lvalueRs_preSI12:
    case Rd_lvalueRs_postSI12:
    case Rd_Rs_SI14:
    case Rd_rvalueRs_SI15:
    case Rd_lvalueRs_SI15:
    case PC_DISP19div2:
    case PC_DISP24div2:
    case Rd_Rs_Rs:
    case x_Rs_x:
    case x_Rs_Rs:
    case Rd_Rs_x:
    case Rd_x_Rs:
    case Rd_x_x:
    case OP5_rvalueRs_SI15:
    case I5_Rs_Rs_I5_OP5:
    case x_rvalueRs_post4:
    case Rd_rvalueRs_post4:
    case Rd_x_I5:
    case Rd_lvalueRs_post4:
    case x_lvalueRs_post4:
    case Rd_Rs_Rs_imm:
    case NO_OPD:
    case Rd_lvalue32Rs:
    case Rd_rvalue32Rs:
    case Insn_GP:
    case Insn_PIC:
    case Insn_internal:
    case Insn_BCMP:
    case Ra_I9_I5:
      retval = INSN_CLASS_32;
      break;
    case Insn_Type_PCE:
      retval = INSN_CLASS_PCE;
      break;
    case Insn_Type_SYN:
      retval = INSN_CLASS_SYN;
      break;
    case Rd_I30:
    case Rd_I32:
      retval = INSN_CLASS_48;
      break;
    default:
      abort ();
      break;
    }
  return retval;
}

/* Type of p-bits:
   48-bit instruction: 1, 1, 0.
   32-bit instruction: 1, 0.
   16-bit instruction: 0.  */
static bfd_vma
s3_adjust_paritybit (bfd_vma m_code, enum insn_class i_class)
{
  bfd_vma result = 0;
  bfd_vma m_code_high = 0;
  unsigned long m_code_middle = 0;
  unsigned long m_code_low = 0;
  bfd_vma pb_high = 0;
  unsigned long pb_middle = 0;
  unsigned long pb_low = 0;

  if (i_class == INSN_CLASS_48)
    {
      pb_high = 0x800000000000LL;
      pb_middle = 0x80000000;
      pb_low = 0x00000000;
      m_code_high = m_code & 0x1fffc0000000LL;
      m_code_middle = m_code & 0x3fff8000;
      m_code_low = m_code & 0x00007fff;
      result = pb_high | (m_code_high << 2) |
	pb_middle | (m_code_middle << 1) |
	pb_low | m_code_low;
    }
  else if (i_class == INSN_CLASS_32 || i_class == INSN_CLASS_SYN)
    {
      pb_high = 0x80000000;
      pb_low = 0x00000000;
      m_code_high = m_code & 0x3fff8000;
      m_code_low = m_code & 0x00007fff;
      result = pb_high | (m_code_high << 1) | pb_low | m_code_low;
    }
  else if (i_class == INSN_CLASS_16)
    {
      pb_high = 0;
      pb_low = 0;
      m_code_high = m_code & 0x3fff8000;
      m_code_low = m_code & 0x00007fff;
      result = pb_high | (m_code_high << 1) | pb_low | m_code_low;
    }
  else if (i_class == INSN_CLASS_PCE)
    {
      /* Keep original.  */
      pb_high = 0;
      pb_low = 0x00008000;
      m_code_high = m_code & 0x3fff8000;
      m_code_low = m_code & 0x00007fff;
      result = pb_high | (m_code_high << 1) | pb_low | m_code_low;
    }
  else
    {
      abort ();
    }

  return result;
}

static void
s3_gen_insn_frag (struct s3_score_it *part_1, struct s3_score_it *part_2)
{
  char *p;
  bfd_boolean pce_p = FALSE;
  int relaxable_p = s3_g_opt;
  int relax_size = 0;
  struct s3_score_it *inst1 = part_1;
  struct s3_score_it *inst2 = part_2;
  struct s3_score_it backup_inst1;

  pce_p = (inst2) ? TRUE : FALSE;
  memcpy (&backup_inst1, inst1, sizeof (struct s3_score_it));

  /* Adjust instruction opcode and to be relaxed instruction opcode.  */
  if (pce_p)
    {
      backup_inst1.instruction = ((backup_inst1.instruction & 0x7FFF) << 15)
	| (inst2->instruction & 0x7FFF);
      backup_inst1.instruction = s3_adjust_paritybit (backup_inst1.instruction, INSN_CLASS_PCE);
      backup_inst1.relax_inst = 0x8000;
      backup_inst1.size = s3_INSN_SIZE;
      backup_inst1.relax_size = 0;
      backup_inst1.type = Insn_Type_PCE;
    }
  else
    {
      backup_inst1.instruction = s3_adjust_paritybit (backup_inst1.instruction,
						      s3_GET_INSN_CLASS (backup_inst1.type));
    }

  if (backup_inst1.relax_size != 0)
    {
      enum insn_class tmp;

      tmp = (backup_inst1.size == s3_INSN_SIZE) ? INSN_CLASS_16 : INSN_CLASS_32;
      backup_inst1.relax_inst = s3_adjust_paritybit (backup_inst1.relax_inst, tmp);
    }

  /* Check data dependency.  */
  s3_handle_dependency (&backup_inst1);

  /* Start a new frag if frag_now is not empty and is not instruction frag, maybe it contains
     data produced by .ascii etc.  Doing this is to make one instruction per frag.  */
  if (frag_now_fix () != 0)
    {
      if (!frag_now->tc_frag_data.is_insn)
	frag_wane (frag_now);

      frag_new (0);
    }

  /* Here, we must call frag_grow in order to keep the instruction frag type is
     rs_machine_dependent.
     For, frag_var may change frag_now->fr_type to rs_fill by calling frag_grow which
     acturally will call frag_wane.
     Calling frag_grow first will create a new frag_now which free size is 20 that is enough
     for frag_var.  */
  frag_grow (20);

  p = frag_more (backup_inst1.size);
  s3_md_number_to_chars (p, backup_inst1.instruction, backup_inst1.size);

#ifdef OBJ_ELF
  dwarf2_emit_insn (backup_inst1.size);
#endif

  /* Generate fixup structure.  */
  if (pce_p)
    {
      if (inst1->reloc.type != BFD_RELOC_NONE)
	s3_fix_new_score (frag_now, p - frag_now->fr_literal,
			  inst1->size, &inst1->reloc.exp,
			  inst1->reloc.pc_rel, inst1->reloc.type);

      if (inst2->reloc.type != BFD_RELOC_NONE)
	s3_fix_new_score (frag_now, p - frag_now->fr_literal + 2,
			  inst2->size, &inst2->reloc.exp, inst2->reloc.pc_rel, inst2->reloc.type);
    }
  else
    {
      if (backup_inst1.reloc.type != BFD_RELOC_NONE)
	s3_fix_new_score (frag_now, p - frag_now->fr_literal,
			  backup_inst1.size, &backup_inst1.reloc.exp,
			  backup_inst1.reloc.pc_rel, backup_inst1.reloc.type);
    }

  /* relax_size may be 2, 4, 12 or 0, 0 indicates no relaxation.  */
  relaxable_p &= (backup_inst1.relax_size != 0);
  relax_size = relaxable_p ? backup_inst1.relax_size : 0;

  p = frag_var (rs_machine_dependent, relax_size + s3_RELAX_PAD_BYTE, 0,
                s3_RELAX_ENCODE (backup_inst1.size, backup_inst1.relax_size,
				 backup_inst1.type, 0, 0, relaxable_p),
                backup_inst1.reloc.exp.X_add_symbol, 0, NULL);

  if (relaxable_p)
    s3_md_number_to_chars (p, backup_inst1.relax_inst, relax_size);

  memcpy (inst1, &backup_inst1, sizeof (struct s3_score_it));
}

static void
s3_parse_16_32_inst (char *insnstr, bfd_boolean gen_frag_p)
{
  char c;
  char *p;
  char *operator = insnstr;
  const struct s3_asm_opcode *opcode;

  /* Parse operator and operands.  */
  s3_skip_whitespace (operator);

  for (p = operator; *p != '\0'; p++)
    if ((*p == ' ') || (*p == '!'))
      break;

  if (*p == '!')
    p++;

  c = *p;
  *p = '\0';

  opcode = (const struct s3_asm_opcode *) hash_find (s3_score_ops_hsh, operator);
  *p = c;

  memset (&s3_inst, '\0', sizeof (s3_inst));
  sprintf (s3_inst.str, "%s", insnstr);
  if (opcode)
    {
      s3_inst.instruction = opcode->value;
      s3_inst.relax_inst = opcode->relax_value;
      s3_inst.type = opcode->type;
      s3_inst.size = s3_GET_INSN_SIZE (s3_inst.type);
      s3_inst.relax_size = 0;
      s3_inst.bwarn = 0;
      sprintf (s3_inst.name, "%s", opcode->template_name);
      strcpy (s3_inst.reg, "");
      s3_inst.error = NULL;
      s3_inst.reloc.type = BFD_RELOC_NONE;

      (*opcode->parms) (p);

      /* It indicates current instruction is a macro instruction if s3_inst.bwarn equals -1.  */
      if ((s3_inst.bwarn != -1) && (!s3_inst.error) && (gen_frag_p))
	s3_gen_insn_frag (&s3_inst, NULL);
    }
  else
    s3_inst.error = _("unrecognized opcode");
}

static void
s3_parse_48_inst (char *insnstr, bfd_boolean gen_frag_p)
{
  char c;
  char *p;
  char *operator = insnstr;
  const struct s3_asm_opcode *opcode;

  /* Parse operator and operands.  */
  s3_skip_whitespace (operator);

  for (p = operator; *p != '\0'; p++)
    if (*p == ' ')
      break;

  c = *p;
  *p = '\0';

  opcode = (const struct s3_asm_opcode *) hash_find (s3_score_ops_hsh, operator);
  *p = c;

  memset (&s3_inst, '\0', sizeof (s3_inst));
  sprintf (s3_inst.str, "%s", insnstr);
  if (opcode)
    {
      s3_inst.instruction = opcode->value;
      s3_inst.relax_inst = opcode->relax_value;
      s3_inst.type = opcode->type;
      s3_inst.size = s3_GET_INSN_SIZE (s3_inst.type);
      s3_inst.relax_size = 0;
      s3_inst.bwarn = 0;
      sprintf (s3_inst.name, "%s", opcode->template_name);
      strcpy (s3_inst.reg, "");
      s3_inst.error = NULL;
      s3_inst.reloc.type = BFD_RELOC_NONE;

      (*opcode->parms) (p);

      /* It indicates current instruction is a macro instruction if s3_inst.bwarn equals -1.  */
      if ((s3_inst.bwarn != -1) && (!s3_inst.error) && (gen_frag_p))
	s3_gen_insn_frag (&s3_inst, NULL);
    }
  else
    s3_inst.error = _("unrecognized opcode");
}

static int
s3_append_insn (char *str, bfd_boolean gen_frag_p)
{
  int retval = s3_SUCCESS;

  s3_parse_16_32_inst (str, gen_frag_p);

  if (s3_inst.error)
    {
      retval = (int) s3_FAIL;
      as_bad (_("%s -- `%s'"), s3_inst.error, s3_inst.str);
      s3_inst.error = NULL;
    }

  return retval;
}

static void
s3_do16_mv_cmp (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 5, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 0, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
}

static void
s3_do16_cmpi (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 5, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 0, _SIMM5) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
}

static void
s3_do16_addi (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reglow_required_here (&str, 6) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 0, _SIMM6) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
}

/* Handle bitclr! / bitset! / bittst! / bittgl! */
static void
s3_do16_rdi5 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reglow_required_here (&str, 5) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 0, _IMM5) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
  else
    {
      s3_inst.relax_inst |= (((s3_inst.instruction >>5) & 0xf) << 20)
        | (((s3_inst.instruction >> 5) & 0xf) << 15) | (((s3_inst.instruction ) & 0x1f) << 10);
      s3_inst.relax_size = 4;
    }
}


/* Handle sdbbp!.  */
static void
s3_do16_xi5 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_data_op2 (&str, 0, _IMM5) == (int) s3_FAIL || s3_end_of_line (str) == (int) s3_FAIL)
    return;
}

/* Check that an immediate is word alignment or half word alignment.
   If so, convert it to the right format.  */
static int
s3_validate_immediate_align (int val, unsigned int data_type)
{
  if (data_type == _IMM5_RSHIFT_1)
    {
      if (val % 2)
        {
          s3_inst.error = _("address offset must be half word alignment");
          return (int) s3_FAIL;
        }
    }
  else if ((data_type == _IMM5_RSHIFT_2) || (data_type == _IMM10_RSHIFT_2))
    {
      if (val % 4)
        {
          s3_inst.error = _("address offset must be word alignment");
          return (int) s3_FAIL;
        }
    }

  return s3_SUCCESS;
}

static int
s3_exp_ldst_offset (char **str, int shift, unsigned int data_type)
{
  char *dataptr;

  dataptr = * str;

  if ((*dataptr == '0') && (*(dataptr + 1) == 'x')
      && (data_type != _SIMM16_LA)
      && (data_type != _VALUE_HI16)
      && (data_type != _VALUE_LO16)
      && (data_type != _IMM16)
      && (data_type != _IMM15)
      && (data_type != _IMM14)
      && (data_type != _IMM4)
      && (data_type != _IMM5)
      && (data_type != _IMM8)
      && (data_type != _IMM5_RSHIFT_1)
      && (data_type != _IMM5_RSHIFT_2)
      && (data_type != _SIMM14_NEG)
      && (data_type != _IMM10_RSHIFT_2))
    {
      data_type += 24;
    }

  if (s3_my_get_expression (&s3_inst.reloc.exp, str) == (int) s3_FAIL)
    return (int) s3_FAIL;

  if (s3_inst.reloc.exp.X_op == O_constant)
    {
      /* Need to check the immediate align.  */
      int value = s3_validate_immediate_align (s3_inst.reloc.exp.X_add_number, data_type);

      if (value == (int) s3_FAIL)
	return (int) s3_FAIL;

      value = s3_validate_immediate (s3_inst.reloc.exp.X_add_number, data_type, 0);
      if (value == (int) s3_FAIL)
        {
          if (data_type < 30)
            sprintf (s3_err_msg,
                     _("invalid constant: %d bit expression not in range %d..%d"),
                     s3_score_df_range[data_type].bits,
                     s3_score_df_range[data_type].range[0], s3_score_df_range[data_type].range[1]);
          else
            sprintf (s3_err_msg,
                     _("invalid constant: %d bit expression not in range %d..%d"),
                     s3_score_df_range[data_type - 24].bits,
                     s3_score_df_range[data_type - 24].range[0], s3_score_df_range[data_type - 24].range[1]);
          s3_inst.error = s3_err_msg;
          return (int) s3_FAIL;
        }

      if (data_type == _IMM5_RSHIFT_1)
        {
          value >>= 1;
        }
      else if ((data_type == _IMM5_RSHIFT_2) || (data_type == _IMM10_RSHIFT_2))
        {
          value >>= 2;
        }

      if (s3_score_df_range[data_type].range[0] != 0)
        {
          value &= (1 << s3_score_df_range[data_type].bits) - 1;
        }

      s3_inst.instruction |= value << shift;
    }
  else
    {
      s3_inst.reloc.pc_rel = 0;
    }

  return s3_SUCCESS;
}

static void
s3_do_ldst_insn (char *str)
{
  int pre_inc = 0;
  int conflict_reg;
  int value;
  char * temp;
  char *dataptr;
  int reg;
  int ldst_idx = 0;

  s3_skip_whitespace (str);

  if (((conflict_reg = s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL))
    return;

  /* ld/sw rD, [rA, simm15]    ld/sw rD, [rA]+, simm12     ld/sw rD, [rA, simm12]+.  */
  if (*str == '[')
    {
      str++;
      s3_skip_whitespace (str);

      if ((reg = s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
	return;

      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);
      s3_skip_whitespace (str);
      temp = str + 1;    /* The latter will process decimal/hex expression.  */

      /* ld/sw rD, [rA]+, simm12    ld/sw rD, [rA]+.  */
      if (*str == ']')
        {
          str++;
          if (*str == '+')
            {
              str++;
              /* ld/sw rD, [rA]+, simm12.  */
              if (s3_skip_past_comma (&str) == s3_SUCCESS)
                {
                  if ((s3_exp_ldst_offset (&str, 3, _SIMM12) == (int) s3_FAIL)
                      || (s3_end_of_line (str) == (int) s3_FAIL))
		    return;

                  if (conflict_reg)
                    {
                      unsigned int ldst_func = s3_inst.instruction & OPC_PSEUDOLDST_MASK;

                      if ((ldst_func == INSN_LH)
                          || (ldst_func == INSN_LHU)
                          || (ldst_func == INSN_LW)
                          || (ldst_func == INSN_LB)
                          || (ldst_func == INSN_LBU))
                        {
                          s3_inst.error = _("register same as write-back base");
                          return;
                        }
                    }

                  ldst_idx = s3_inst.instruction & OPC_PSEUDOLDST_MASK;
                  s3_inst.instruction &= ~OPC_PSEUDOLDST_MASK;
                  s3_inst.instruction |= s3_score_ldst_insns[ldst_idx * 3 + LDST_POST].value;

                  /* lw rD, [rA]+, 4 convert to pop rD, [rA].  */
                  if ((s3_inst.instruction & 0x3e000007) == 0x0e000000)
                    {
                      /* rs =  r0, offset = 4 */
                      if ((((s3_inst.instruction >> 15) & 0x1f) == 0)
                          && (((s3_inst.instruction >> 3) & 0xfff) == 4))
                        {
                          /* Relax to pop!.  */
                          s3_inst.relax_inst = 0x0040 | ((s3_inst.instruction >> 20) & 0x1f);
                          s3_inst.relax_size = 2;
                        }
                    }
                  return;
                }
              /* ld/sw rD, [rA]+ convert to ld/sw rD, [rA, 0]+.  */
              else
                {
                  s3_SET_INSN_ERROR (NULL);
                  if (s3_end_of_line (str) == (int) s3_FAIL)
                    {
                      return;
                    }

                  pre_inc = 1;
                  value = s3_validate_immediate (s3_inst.reloc.exp.X_add_number, _SIMM12, 0);
                  value &= (1 << s3_score_df_range[_SIMM12].bits) - 1;
                  ldst_idx = s3_inst.instruction & OPC_PSEUDOLDST_MASK;
                  s3_inst.instruction &= ~OPC_PSEUDOLDST_MASK;
                  s3_inst.instruction |= s3_score_ldst_insns[ldst_idx * 3 + pre_inc].value;
                  s3_inst.instruction |= value << 3;
                  s3_inst.relax_inst = 0x8000;
                  return;
                }
            }
          /* ld/sw rD, [rA] convert to ld/sw rD, [rA, simm15].  */
          else
            {
              if (s3_end_of_line (str) == (int) s3_FAIL)
		return;

              ldst_idx = s3_inst.instruction & OPC_PSEUDOLDST_MASK;
              s3_inst.instruction &= ~OPC_PSEUDOLDST_MASK;
              s3_inst.instruction |= s3_score_ldst_insns[ldst_idx * 3 + LDST_NOUPDATE].value;

              /* lbu rd, [rs] -> lbu! rd, [rs]  */
              if (ldst_idx == INSN_LBU)
                {
                  s3_inst.relax_inst = INSN16_LBU;
                }
              else if (ldst_idx == INSN_LH)
                {
                  s3_inst.relax_inst = INSN16_LH;
                }
              else if (ldst_idx == INSN_LW)
                {
                  s3_inst.relax_inst = INSN16_LW;
                }
              else if (ldst_idx == INSN_SB)
                {
                  s3_inst.relax_inst = INSN16_SB;
                }
              else if (ldst_idx == INSN_SH)
                {
                  s3_inst.relax_inst = INSN16_SH;
                }
              else if (ldst_idx == INSN_SW)
                {
                  s3_inst.relax_inst = INSN16_SW;
                }
              else
                {
                  s3_inst.relax_inst = 0x8000;
                }

              /* lw/lh/lbu/sw/sh/sb, offset = 0, relax to 16 bit instruction.  */
              /* if ((ldst_idx == INSN_LBU)
		 || (ldst_idx == INSN_LH)
		 || (ldst_idx == INSN_LW)
		 || (ldst_idx == INSN_SB) || (ldst_idx == INSN_SH) || (ldst_idx == INSN_SW))*/
              if ( (ldst_idx == INSN_LW)|| (ldst_idx == INSN_SW))
                {
                  /* ra only 3 bit , rd only 4 bit for lw! and sw! */
                  if ((((s3_inst.instruction >> 15) & 0x18) == 0) && (((s3_inst.instruction >> 20) & 0x10) == 0))
                    {
                      s3_inst.relax_inst |= (((s3_inst.instruction >> 20) & 0xf) << 8) |
                        (((s3_inst.instruction >> 15) & 0x7) << 5);
                      s3_inst.relax_size = 2;
                    }
                }

              return;
            }
        }
      /* ld/sw rD, [rA, simm15]    ld/sw rD, [rA, simm12]+.  */
      else
        {
          if (s3_skip_past_comma (&str) == (int) s3_FAIL)
            {
              s3_inst.error = _("pre-indexed expression expected");
              return;
            }

          if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL)
	    return;

          s3_skip_whitespace (str);
          if (*str++ != ']')
            {
              s3_inst.error = _("missing ]");
              return;
            }

          s3_skip_whitespace (str);
          /* ld/sw rD, [rA, simm12]+.  */
          if (*str == '+')
            {
              str++;
              pre_inc = 1;
              if (conflict_reg)
                {
                  unsigned int ldst_func = s3_inst.instruction & OPC_PSEUDOLDST_MASK;

                  if ((ldst_func == INSN_LH)
                      || (ldst_func == INSN_LHU)
                      || (ldst_func == INSN_LW)
                      || (ldst_func == INSN_LB)
                      || (ldst_func == INSN_LBU))
                    {
                      s3_inst.error = _("register same as write-back base");
                      return;
                    }
                }
            }

          if (s3_end_of_line (str) == (int) s3_FAIL)
	    return;

          if (s3_inst.reloc.exp.X_op == O_constant)
            {
              unsigned int data_type;

              if (pre_inc == 1)
                data_type = _SIMM12;
              else
                data_type = _SIMM15;
              dataptr = temp;

              if ((*dataptr == '0') && (*(dataptr + 1) == 'x')
                  && (data_type != _SIMM16_LA)
                  && (data_type != _VALUE_HI16)
                  && (data_type != _VALUE_LO16)
                  && (data_type != _IMM16)
                  && (data_type != _IMM15)
                  && (data_type != _IMM14)
                  && (data_type != _IMM4)
                  && (data_type != _IMM5)
                  && (data_type != _IMM8)
                  && (data_type != _IMM5_RSHIFT_1)
                  && (data_type != _IMM5_RSHIFT_2)
                  && (data_type != _SIMM14_NEG)
                  && (data_type != _IMM10_RSHIFT_2))
                {
                  data_type += 24;
                }

              value = s3_validate_immediate (s3_inst.reloc.exp.X_add_number, data_type, 0);
              if (value == (int) s3_FAIL)
                {
                  if (data_type < 30)
                    sprintf (s3_err_msg,
                             _("invalid constant: %d bit expression not in range %d..%d"),
                             s3_score_df_range[data_type].bits,
                             s3_score_df_range[data_type].range[0], s3_score_df_range[data_type].range[1]);
                  else
                    sprintf (s3_err_msg,
                             _("invalid constant: %d bit expression not in range %d..%d"),
                             s3_score_df_range[data_type - 24].bits,
                             s3_score_df_range[data_type - 24].range[0],
                             s3_score_df_range[data_type - 24].range[1]);
                  s3_inst.error = s3_err_msg;
                  return;
                }

              value &= (1 << s3_score_df_range[data_type].bits) - 1;
              ldst_idx = s3_inst.instruction & OPC_PSEUDOLDST_MASK;
              s3_inst.instruction &= ~OPC_PSEUDOLDST_MASK;
              s3_inst.instruction |= s3_score_ldst_insns[ldst_idx * 3 + pre_inc].value;
              if (pre_inc == 1)
                s3_inst.instruction |= value << 3;
              else
                s3_inst.instruction |= value;

              /* lw rD, [rA, simm15]  */
              if ((s3_inst.instruction & 0x3e000000) == 0x20000000)
                {
                  /*  rD  in [r0 - r15]. , ra in [r0-r7] */
                  if ((((s3_inst.instruction >> 15) & 0x18) == 0)
                      && (((s3_inst.instruction >> 20) & 0x10) == 0))
                    {
                      /* simm = [bit 7], lw -> lw!.  */
                      if (((s3_inst.instruction & 0x7f80) == 0)&&((s3_inst.instruction &0x3)==0))
                        {
                          s3_inst.relax_inst |= (((s3_inst.instruction >> 15) & 0x7) << 5)
                            | (((s3_inst.instruction >> 20) & 0xf) << 8)|(value>>2);
                          s3_inst.relax_size = 2;
                        }
                      else
                        {
                          s3_inst.relax_inst = 0x8000;
                        }
                    }
                  else
                    {
                      s3_inst.relax_inst = 0x8000;
                    }
                }
              /* sw rD, [rA, simm15]  */
              else if ((s3_inst.instruction & 0x3e000000) == 0x28000000)
                {
                  /* rD is  in [r0 - r15] and ra in [r0-r7] */
                  if ((((s3_inst.instruction >> 15) & 0x18) == 0) && (((s3_inst.instruction >> 20) & 0x10) == 0))
                    {
                      /* simm15 =7 bit  , sw -> sw!.  */
                      if (((s3_inst.instruction & 0x7f80) == 0)&&((s3_inst.instruction &0x3)==0))
                        {
                          s3_inst.relax_inst |= (((s3_inst.instruction >> 15) & 0xf) << 5)
                            | (((s3_inst.instruction >> 20) & 0xf) << 8)|(value>>2);
                          s3_inst.relax_size = 2;
                        }
                      /* rA = r2, sw -> swp!.  */
                      else
                        {
                          s3_inst.relax_inst = 0x8000;
                        }
                    }
                  else
                    {
                      s3_inst.relax_inst = 0x8000;
                    }
                }
              /* sw rD, [rA, simm15]+    sw pre.  */
              else if ((s3_inst.instruction & 0x3e000007) == 0x06000004)
                {
                  /* simm15 = -4. and ra==r0 */
                  if ((((s3_inst.instruction >> 15) & 0x1f) == 0)
                      && (((s3_inst.instruction >> 3) & 0xfff) == 0xffc))
                    {
                      /* sw -> push!.  */
                      s3_inst.relax_inst = 0x0060 | ((s3_inst.instruction >> 20) & 0x1f);
                      s3_inst.relax_size = 2;
                    }
                  else
                    {
                      s3_inst.relax_inst = 0x8000;
                    }
                }
              else
                {
                  s3_inst.relax_inst = 0x8000;
                }

              return;
            }
          else
            {
              /* FIXME: may set error, for there is no ld/sw rD, [rA, label] */
              s3_inst.reloc.pc_rel = 0;
            }
        }
    }
  else
    {
      s3_inst.error = s3_BAD_ARGS;
    }
}

/* Handle cache.  */
static void
s3_do_cache (char *str)
{
  s3_skip_whitespace (str);

  if ((s3_data_op2 (&str, 20, _IMM5) == (int) s3_FAIL) || (s3_skip_past_comma (&str) == (int) s3_FAIL))
    {
      return;
    }
  else
    {
      int cache_op;

      cache_op = (s3_inst.instruction >> 20) & 0x1F;
      sprintf (s3_inst.name, "cache %d", cache_op);
    }

  if (*str == '[')
    {
      str++;
      s3_skip_whitespace (str);

      if (s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
	return;

      s3_skip_whitespace (str);

      /* cache op, [rA]  */
      if (s3_skip_past_comma (&str) == (int) s3_FAIL)
        {
          s3_SET_INSN_ERROR (NULL);
          if (*str != ']')
            {
              s3_inst.error = _("missing ]");
              return;
            }
          str++;
        }
      /* cache op, [rA, simm15]  */
      else
        {
          if (s3_exp_ldst_offset (&str, 0, _SIMM15) == (int) s3_FAIL)
            {
              return;
            }

          s3_skip_whitespace (str);
          if (*str++ != ']')
            {
              s3_inst.error = _("missing ]");
              return;
            }
        }

      if (s3_end_of_line (str) == (int) s3_FAIL)
	return;
    }
  else
    {
      s3_inst.error = s3_BAD_ARGS;
    }
}

static void
s3_do_crdcrscrsimm5 (char *str)
{
  char *strbak;

  strbak = str;
  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE_CR) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE_CR) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE_CR) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL)
    {
      str = strbak;
      /* cop1 cop_code20.  */
      if (s3_data_op2 (&str, 5, _IMM20) == (int) s3_FAIL)
	return;
    }
  else
    {
      if (s3_data_op2 (&str, 5, _IMM5) == (int) s3_FAIL)
	return;
    }

  s3_end_of_line (str);
}

/* Handle ldc/stc.  */
static void
s3_do_ldst_cop (char *str)
{
  s3_skip_whitespace (str);

  if ((s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE_CR) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL))
    return;

  if (*str == '[')
    {
      str++;
      s3_skip_whitespace (str);

      if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
	return;

      s3_skip_whitespace (str);

      if (*str++ != ']')
        {
          if (s3_exp_ldst_offset (&str, 5, _IMM10_RSHIFT_2) == (int) s3_FAIL)
	    return;

          s3_skip_whitespace (str);
          if (*str++ != ']')
            {
              s3_inst.error = _("missing ]");
              return;
            }
        }

      s3_end_of_line (str);
    }
  else
    s3_inst.error = s3_BAD_ARGS;
}

static void
s3_do16_ldst_insn (char *str)
{
  int conflict_reg = 0;
  s3_skip_whitespace (str);

  if ((s3_reglow_required_here (&str, 8) == (int) s3_FAIL) || (s3_skip_past_comma (&str) == (int) s3_FAIL))
    return;

  if (*str == '[')
    {

      str++;
      s3_skip_whitespace (str);

      if ((conflict_reg = s3_reglow_required_here (&str, 5)) == (int) s3_FAIL)
	return;
      if (conflict_reg&0x8)
        {
          sprintf (s3_err_msg,  _("invalid register number: %d is not in [r0--r7]"),conflict_reg);
          s3_inst.error = s3_err_msg;
          return;
        }

      s3_skip_whitespace (str);

      if (*str == ']')
        {
          str++;
          if (s3_end_of_line (str) == (int) s3_FAIL)
	    return;
        }
      else
        {
          if (s3_skip_past_comma (&str) == (int) s3_FAIL)
	    {
	      s3_inst.error = _("comma is  expected");
              return;
	    }
          if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL)
	    return;
          s3_skip_whitespace (str);
	  if (*str++ != ']')
	    {
	      s3_inst.error = _("missing ]");
	      return;
	    }
          if (s3_end_of_line (str) == (int) s3_FAIL)
	    return;
          if (s3_inst.reloc.exp.X_op == O_constant)
            {
              int value;
	      unsigned int data_type;
              data_type = _IMM5_RSHIFT_2;
              value = s3_validate_immediate (s3_inst.reloc.exp.X_add_number, data_type, 0);
              if (value == (int) s3_FAIL)
		{
		  if (data_type < 30)
		    sprintf (s3_err_msg,
			     _("invalid constant: %d bit expression not in range %d..%d"),
			     s3_score_df_range[data_type].bits,
			     s3_score_df_range[data_type].range[0], s3_score_df_range[data_type].range[1]);
                  s3_inst.error = s3_err_msg;
	          return;
	        }
              if (value & 0x3)
                {
                  sprintf (s3_err_msg,  _("invalid constant: %d is not word align integer"),value);
                  s3_inst.error = s3_err_msg;
                  return;
                }

              value >>= 2;
              s3_inst.instruction |= value;
            }
        }
    }
  else
    {
      sprintf (s3_err_msg,  _("missing ["));
      s3_inst.error = s3_err_msg;
      return;
    }
}

static void
s3_do_lw48 (char *str)
{
  bfd_signed_vma val = 0;

  s3_skip_whitespace (str);

  if ((s3_reg_required_here (&str, 37, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL))
    return;

  if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }

  /* Check word align for lw48 rd, value.  */
  if ((s3_inst.reloc.exp.X_add_symbol == NULL)
      && ((s3_inst.reloc.exp.X_add_number & 0x3) != 0))
    {
      s3_inst.error = _("invalid constant: 32 bit expression not word align");
      return;
    }

  /* Check and set offset.  */
  val = s3_inst.reloc.exp.X_add_number;
  if ((s3_inst.reloc.exp.X_add_symbol == NULL)
      && (!(val >= 0 && val <= 0xffffffffLL)))
    {
      s3_inst.error = _("invalid constant: 32 bit expression not in range [0, 0xffffffff]");
      return;
    }

  val &= 0xffffffff;
  val >>= 2;
  s3_inst.instruction |= (val << 7);

  /* Set reloc type.  */
  s3_inst.reloc.type = BFD_RELOC_SCORE_IMM30;

}

static void
s3_do_sw48 (char *str)
{
  bfd_signed_vma val = 0;

  s3_skip_whitespace (str);

  if ((s3_reg_required_here (&str, 37, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL))
    return;

  if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }

  /* Check word align for lw48 rd, value.  */
  if ((s3_inst.reloc.exp.X_add_symbol == NULL)
      && ((s3_inst.reloc.exp.X_add_number & 0x3) != 0))
    {
      s3_inst.error = _("invalid constant: 32 bit expression not word align");
      return;
    }

  /* Check and set offset.  */
  val = s3_inst.reloc.exp.X_add_number;
  if ((s3_inst.reloc.exp.X_add_symbol == NULL)
      && (!(val >= 0 && val <= 0xffffffffLL)))
    {
      s3_inst.error = _("invalid constant: 32 bit expression not in range [0, 0xffffffff]");
      return;
    }

  val &= 0xffffffff;
  val >>= 2;
  s3_inst.instruction |= (val << 7);

  /* Set reloc type.  */
  s3_inst.reloc.type = BFD_RELOC_SCORE_IMM30;
}

static void
s3_do_ldi48 (char *str)
{
  bfd_signed_vma val;

  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 37, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL)
    return;

  if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }

  /* Check and set offset.  */
  val = s3_inst.reloc.exp.X_add_number;
  if (!(val >= -0xffffffffLL && val <= 0xffffffffLL))
    {
      s3_inst.error = _("invalid constant: 32 bit expression not in range [-0x80000000, 0x7fffffff]");
      return;
    }

  val &= 0xffffffff;
  s3_inst.instruction |= (val << 5);

  /* Set reloc type.  */
  s3_inst.reloc.type = BFD_RELOC_SCORE_IMM32;
}

static void
s3_do_sdbbp48 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_data_op2 (&str, 5, _IMM5) == (int) s3_FAIL || s3_end_of_line (str) == (int) s3_FAIL)
    return;
}

static void
s3_do_and48 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reglow_required_here (&str, 38) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reglow_required_here (&str, 34) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 2, _IMM32) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
}

static void
s3_do_or48 (char *str)
{
  s3_skip_whitespace (str);

  if (s3_reglow_required_here (&str, 38) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reglow_required_here (&str, 34) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 2, _IMM32) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
}

static void
s3_do_mbitclr (char *str)
{
  int val;
  s3_skip_whitespace (str);

  if (*str != '[')
    {
      sprintf (s3_err_msg,  _("missing ["));
      s3_inst.error = s3_err_msg;
      return;
    }
  str++;

  s3_inst.instruction &= 0x0;

  if ((s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL)
      || (s3_data_op2 (&str, 0, _IMM11) == (int) s3_FAIL))
    return;

  /* Get imm11 and refill opcode.  */
  val = s3_inst.instruction & 0x7ff;
  val >>= 2;
  s3_inst.instruction &= 0x000f8000;
  s3_inst.instruction |= 0x00000064;

  if (*str != ']')
    {
      sprintf (s3_err_msg,  _("missing ]"));
      s3_inst.error = s3_err_msg;
      return;
    }
  str++;

  if ((s3_skip_past_comma (&str) == (int) s3_FAIL)
      || (s3_data_op2 (&str, 10, _IMM5) == (int) s3_FAIL))
    return;

  /* Set imm11 to opcode.  */
  s3_inst.instruction |= (val & 0x1)
    | (((val >> 1 ) & 0x7) << 7)
    | (((val >> 4 ) & 0x1f) << 20);
}

static void
s3_do_mbitset (char *str)
{
  int val;
  s3_skip_whitespace (str);

  if (*str != '[')
    {
      sprintf (s3_err_msg,  _("missing ["));
      s3_inst.error = s3_err_msg;
      return;
    }
  str++;

  s3_inst.instruction &= 0x0;

  if ((s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL)
      || (s3_data_op2 (&str, 0, _IMM11) == (int) s3_FAIL))
    return;

  /* Get imm11 and refill opcode.  */
  val = s3_inst.instruction & 0x7ff;
  val >>= 2;
  s3_inst.instruction &= 0x000f8000;
  s3_inst.instruction |= 0x0000006c;

  if (*str != ']')
    {
      sprintf (s3_err_msg,  _("missing ]"));
      s3_inst.error = s3_err_msg;
      return;
    }
  str++;

  if ((s3_skip_past_comma (&str) == (int) s3_FAIL)
      || (s3_data_op2 (&str, 10, _IMM5) == (int) s3_FAIL))
    return;

  /* Set imm11 to opcode.  */
  s3_inst.instruction |= (val & 0x1)
    | (((val >> 1 ) & 0x7) << 7)
    | (((val >> 4 ) & 0x1f) << 20);
}

static void
s3_do16_slli_srli (char *str)
{
  s3_skip_whitespace (str);

  if ((s3_reglow_required_here (&str, 5) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL)
      || s3_data_op2 (&str, 0, _IMM5) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
}

static void
s3_do16_ldiu (char *str)
{
  s3_skip_whitespace (str);

  if ((s3_reg_required_here (&str, 5,s3_REG_TYPE_SCORE) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL)
      || s3_data_op2 (&str, 0, _IMM5) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
}

static void
s3_do16_push_pop (char *str)
{
  s3_skip_whitespace (str);
  if ((s3_reg_required_here (&str, 0, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
}

static void
s3_do16_rpush (char *str)
{
  int reg;
  int val;
  s3_skip_whitespace (str);
  if ((reg = (s3_reg_required_here (&str, 5, s3_REG_TYPE_SCORE))) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 0, _IMM5_MULTI_LOAD) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  /* 0: indicate 32.
     1: invalide value.
     2: to 31: normal value.  */
  val = s3_inst.instruction & 0x1f;
  if (val == 1)
    {
      s3_inst.error = _("imm5 should >= 2");
      return;
    }
  if (reg >= 32)
    {
      s3_inst.error = _("reg should <= 31");
      return;
    }
}

static void
s3_do16_rpop (char *str)
{
  int reg;
  int val;
  s3_skip_whitespace (str);
  if ((reg = (s3_reg_required_here (&str, 5, s3_REG_TYPE_SCORE))) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_data_op2 (&str, 0, _IMM5_MULTI_LOAD) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  /* 0: indicate 32.
     1: invalide value.
     2: to 31: normal value.  */
  val = s3_inst.instruction & 0x1f;
  if (val == 1)
    {
      s3_inst.error = _("imm5 should >= 2");
      return;
    }

  if (reg >= 32)
    {
      s3_inst.error = _("reg should <= 31");
      return;
    }
  else
    {
      if ((reg + val) <= 32)
        reg = reg + val - 1;
      else
        reg = reg + val - 33;
      s3_inst.instruction &= 0x7c1f;
      s3_inst.instruction |= (reg << 5);
      return;
    }
}

/* Handle lcb/lcw/lce/scb/scw/sce.  */
static void
s3_do_ldst_unalign (char *str)
{
  int conflict_reg;

  if (s3_university_version == 1)
    {
      s3_inst.error = s3_ERR_FOR_SCORE5U_ATOMIC;
      return;
    }

  s3_skip_whitespace (str);

  /* lcb/scb [rA]+.  */
  if (*str == '[')
    {
      str++;
      s3_skip_whitespace (str);

      if (s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
	return;

      if (*str++ == ']')
        {
          if (*str++ != '+')
            {
              s3_inst.error = _("missing +");
              return;
            }
        }
      else
        {
          s3_inst.error = _("missing ]");
          return;
        }

      if (s3_end_of_line (str) == (int) s3_FAIL)
	return;
    }
  /* lcw/lce/scb/sce rD, [rA]+.  */
  else
    {
      if (((conflict_reg = s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
          || (s3_skip_past_comma (&str) == (int) s3_FAIL))
        {
          return;
        }

      s3_skip_whitespace (str);
      if (*str++ == '[')
        {
          int reg;

          s3_skip_whitespace (str);
          if ((reg = s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
            {
              return;
            }

          /* Conflicts can occur on stores as well as loads.  */
          conflict_reg = (conflict_reg == reg);
          s3_skip_whitespace (str);
          if (*str++ == ']')
            {
              unsigned int ldst_func = s3_inst.instruction & LDST_UNALIGN_MASK;

              if (*str++ == '+')
                {
                  if (conflict_reg)
                    {
                      as_warn (_("%s register same as write-back base"),
                               ((ldst_func & UA_LCE) || (ldst_func & UA_LCW)
                                ? _("destination") : _("source")));
                    }
                }
              else
                {
                  s3_inst.error = _("missing +");
                  return;
                }

              if (s3_end_of_line (str) == (int) s3_FAIL)
		return;
            }
          else
            {
              s3_inst.error = _("missing ]");
              return;
            }
        }
      else
        {
          s3_inst.error = s3_BAD_ARGS;
          return;
        }
    }
}

/* Handle alw/asw.  */
static void
s3_do_ldst_atomic (char *str)
{
  if (s3_university_version == 1)
    {
      s3_inst.error = s3_ERR_FOR_SCORE5U_ATOMIC;
      return;
    }

  s3_skip_whitespace (str);

  if ((s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL))
    {
      return;
    }
  else
    {

      s3_skip_whitespace (str);
      if (*str++ == '[')
        {
          int reg;

          s3_skip_whitespace (str);
          if ((reg = s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
            {
              return;
            }

          s3_skip_whitespace (str);
          if (*str++ != ']')
            {
              s3_inst.error = _("missing ]");
              return;
            }

          s3_end_of_line (str);
        }
      else
	s3_inst.error = s3_BAD_ARGS;
    }
}

static void
s3_build_relax_frag (struct s3_score_it fix_insts[s3_RELAX_INST_NUM], int fix_num ATTRIBUTE_UNUSED,
		     struct s3_score_it var_insts[s3_RELAX_INST_NUM], int var_num,
		     symbolS *add_symbol)
{
  int i;
  char *p;
  fixS *fixp = NULL;
  fixS *cur_fixp = NULL;
  long where;
  struct s3_score_it inst_main;

  memcpy (&inst_main, &fix_insts[0], sizeof (struct s3_score_it));

  /* Adjust instruction opcode and to be relaxed instruction opcode.  */
  inst_main.instruction = s3_adjust_paritybit (inst_main.instruction, s3_GET_INSN_CLASS (inst_main.type));
  inst_main.type = Insn_PIC;

  for (i = 0; i < var_num; i++)
    {
      inst_main.relax_size += var_insts[i].size;
      var_insts[i].instruction = s3_adjust_paritybit (var_insts[i].instruction,
						      s3_GET_INSN_CLASS (var_insts[i].type));
    }

  /* Check data dependency.  */
  s3_handle_dependency (&inst_main);

  /* Start a new frag if frag_now is not empty.  */
  if (frag_now_fix () != 0)
    {
      if (!frag_now->tc_frag_data.is_insn)
	{
          frag_wane (frag_now);
	}
      frag_new (0);
    }
  frag_grow (20);

  /* Write fr_fix part.  */
  p = frag_more (inst_main.size);
  s3_md_number_to_chars (p, inst_main.instruction, inst_main.size);

  if (inst_main.reloc.type != BFD_RELOC_NONE)
    fixp = s3_fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
			     &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);

  frag_now->tc_frag_data.fixp = fixp;
  cur_fixp = frag_now->tc_frag_data.fixp;

#ifdef OBJ_ELF
  dwarf2_emit_insn (inst_main.size);
#endif

  where = p - frag_now->fr_literal + inst_main.size;
  for (i = 0; i < var_num; i++)
    {
      if (i > 0)
        where += var_insts[i - 1].size;

      if (var_insts[i].reloc.type != BFD_RELOC_NONE)
        {
          fixp = s3_fix_new_score (frag_now, where, var_insts[i].size,
				   &var_insts[i].reloc.exp, var_insts[i].reloc.pc_rel,
				   var_insts[i].reloc.type);
          if (fixp)
            {
              if (cur_fixp)
                {
                  cur_fixp->fx_next = fixp;
                  cur_fixp = cur_fixp->fx_next;
                }
              else
                {
                  frag_now->tc_frag_data.fixp = fixp;
                  cur_fixp = frag_now->tc_frag_data.fixp;
                }
	    }
        }
    }

  p = frag_var (rs_machine_dependent, inst_main.relax_size + s3_RELAX_PAD_BYTE, 0,
                s3_RELAX_ENCODE (inst_main.size, inst_main.relax_size, inst_main.type,
				 0, inst_main.size, 0), add_symbol, 0, NULL);

  /* Write fr_var part.
     no calling s3_gen_insn_frag, no fixS will be generated.  */
  for (i = 0; i < var_num; i++)
    {
      s3_md_number_to_chars (p, var_insts[i].instruction, var_insts[i].size);
      p += var_insts[i].size;
    }
  /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
  s3_inst.bwarn = -1;
}

/* Build a relax frag for la instruction when generating s3_PIC,
   external symbol first and local symbol second.  */
static void
s3_build_la_pic (int reg_rd, expressionS exp)
{
  symbolS *add_symbol = exp.X_add_symbol;
  offsetT add_number = exp.X_add_number;
  struct s3_score_it fix_insts[s3_RELAX_INST_NUM];
  struct s3_score_it var_insts[s3_RELAX_INST_NUM];
  int fix_num = 0;
  int var_num = 0;
  char tmp[s3_MAX_LITERAL_POOL_SIZE];
  int r1_bak;

  r1_bak = s3_nor1;
  s3_nor1 = 0;

  if (add_number == 0)
    {
      fix_num = 1;
      var_num = 2;

      /* For an external symbol, only one insn is generated;
         For a local symbol, two insns are generated.  */
      /* Fix part
         For an external symbol: lw rD, <sym>($gp)
	 (BFD_RELOC_SCORE_GOT15 or BFD_RELOC_SCORE_CALL15)  */
      sprintf (tmp, "lw_pic r%d, %s", reg_rd, add_symbol->bsym->name);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
	return;

      if (reg_rd == s3_PIC_CALL_REG)
        s3_inst.reloc.type = BFD_RELOC_SCORE_CALL15;
      memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));

      /* Var part
	 For a local symbol :
         lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)
	 addi rD, <sym>       (BFD_RELOC_GOT_LO16) */
      s3_inst.reloc.type = BFD_RELOC_SCORE_GOT15;
      memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));
      sprintf (tmp, "addi_s_pic r%d, %s", reg_rd, add_symbol->bsym->name);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
	return;

      memcpy (&var_insts[1], &s3_inst, sizeof (struct s3_score_it));
      s3_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);
    }
  else if (add_number >= -0x8000 && add_number <= 0x7fff)
    {
      /* Insn 1: lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */
      sprintf (tmp, "lw_pic r%d, %s", reg_rd, add_symbol->bsym->name);
      if (s3_append_insn (tmp, TRUE) == (int) s3_FAIL)
	return;

      /* Insn 2  */
      fix_num = 1;
      var_num = 1;
      /* Fix part
         For an external symbol: addi rD, <constant> */
      sprintf (tmp, "addi r%d, %d", reg_rd, (int)add_number);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
	return;

      memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));

      /* Var part
 	 For a local symbol: addi rD, <sym>+<constant>    (BFD_RELOC_GOT_LO16)  */
      sprintf (tmp, "addi_s_pic r%d, %s + %d", reg_rd, add_symbol->bsym->name, (int)add_number);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
	return;

      memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));
      s3_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);
    }
  else
    {
      int hi = (add_number >> 16) & 0x0000FFFF;
      int lo = add_number & 0x0000FFFF;

      /* Insn 1: lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */
      sprintf (tmp, "lw_pic r%d, %s", reg_rd, add_symbol->bsym->name);
      if (s3_append_insn (tmp, TRUE) == (int) s3_FAIL)
	return;

      /* Insn 2  */
      fix_num = 1;
      var_num = 1;
      /* Fix part
	 For an external symbol: ldis r1, HI%<constant>  */
      sprintf (tmp, "ldis r1, %d", hi);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
	return;

      memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));

      /* Var part
	 For a local symbol: ldis r1, HI%<constant>
         but, if lo is outof 16 bit, make hi plus 1  */
      if ((lo < -0x8000) || (lo > 0x7fff))
	{
	  hi += 1;
	}
      sprintf (tmp, "ldis_pic r1, %d", hi);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
	return;

      memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));
      s3_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);

      /* Insn 3  */
      fix_num = 1;
      var_num = 1;
      /* Fix part
	 For an external symbol: ori r1, LO%<constant>  */
      sprintf (tmp, "ori r1, %d", lo);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
	return;

      memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));

      /* Var part
  	 For a local symbol: addi r1, <sym>+LO%<constant>    (BFD_RELOC_GOT_LO16)  */
      sprintf (tmp, "addi_u_pic r1, %s + %d", add_symbol->bsym->name, lo);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
	return;

      memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));
      s3_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);

      /* Insn 4: add rD, rD, r1  */
      sprintf (tmp, "add r%d, r%d, r1", reg_rd, reg_rd);
      if (s3_append_insn (tmp, TRUE) == (int) s3_FAIL)
	return;

      /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
      s3_inst.bwarn = -1;
    }

  s3_nor1 = r1_bak;
}

/* Handle la.  */
static void
s3_do_macro_la_rdi32 (char *str)
{
  int reg_rd;

  s3_skip_whitespace (str);
  if ((reg_rd = s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL)
    {
      return;
    }
  else
    {
      /* Save str.  */
      char *keep_data = str;
      char append_str[s3_MAX_LITERAL_POOL_SIZE];

      /* Check immediate value.  */
      if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL)
        {
          s3_inst.error = _("expression error");
          return;
        }
      else if ((s3_inst.reloc.exp.X_add_symbol == NULL)
               && (s3_validate_immediate (s3_inst.reloc.exp.X_add_number, _IMM32, 0) == (int) s3_FAIL))
        {
          s3_inst.error = _("value not in range [0, 0xffffffff]");
          return;
        }

      /* Reset str.  */
      str = keep_data;

      /* la rd, simm16.  */
      if (s3_data_op2 (&str, 1, _SIMM16_LA) != (int) s3_FAIL)
        {
          s3_end_of_line (str);
          return;
        }
      /* la rd, imm32 or la rd, label.  */
      else
        {
          s3_SET_INSN_ERROR (NULL);
          /* Reset str.  */
          str = keep_data;
          if ((s3_data_op2 (&str, 1, _VALUE_HI16) == (int) s3_FAIL)
              || (s3_end_of_line (str) == (int) s3_FAIL))
            {
              return;
            }
          else
            {
              if ((s3_score_pic == s3_NO_PIC) || (!s3_inst.reloc.exp.X_add_symbol))
                {
                  sprintf (append_str, "ld_i32hi r%d, %s", reg_rd, keep_data);
                  if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)
		    return;

                  sprintf (append_str, "ld_i32lo r%d, %s", reg_rd, keep_data);
                  if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)
		    return;
		}
	      else
		{
		  gas_assert (s3_inst.reloc.exp.X_add_symbol);
		  s3_build_la_pic (reg_rd, s3_inst.reloc.exp);
		}

              /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
              s3_inst.bwarn = -1;
            }
        }
    }
}

/* Handle li.  */
static void
s3_do_macro_li_rdi32 (char *str)
{

  int reg_rd;

  s3_skip_whitespace (str);
  if ((reg_rd = s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL)
    {
      return;
    }
  else
    {
      /* Save str.  */
      char *keep_data = str;

      /* Check immediate value.  */
      if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL)
        {
          s3_inst.error = _("expression error");
          return;
        }
      else if (!(s3_inst.reloc.exp.X_add_number >= -0xffffffffLL
                 && s3_inst.reloc.exp.X_add_number <= 0xffffffffLL))
        {
          s3_inst.error = _("value not in range [-0xffffffff, 0xffffffff]");
          return;
        }

      /* Reset str.  */
      str = keep_data;

      /* li rd, simm16.  */
      if (s3_data_op2 (&str, 1, _SIMM16_LA) != (int) s3_FAIL)
        {
          s3_end_of_line (str);
          return;
        }
      /* li rd, imm32.  */
      else
        {
          char append_str[s3_MAX_LITERAL_POOL_SIZE];

          /* Reset str.  */
          str = keep_data;

          if ((s3_data_op2 (&str, 1, _VALUE_HI16) == (int) s3_FAIL)
              || (s3_end_of_line (str) == (int) s3_FAIL))
            {
              return;
            }
          else if (s3_inst.reloc.exp.X_add_symbol)
            {
              s3_inst.error = _("li rd label isn't correct instruction form");
              return;
            }
          else
            {
              sprintf (append_str, "ld_i32hi r%d, %s", reg_rd, keep_data);

              if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)
		return;
              else
                {
                  sprintf (append_str, "ld_i32lo r%d, %s", reg_rd, keep_data);
                  if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)
		    return;

                  /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
                  s3_inst.bwarn = -1;
                }
            }
        }
    }
}

/* Handle mul/mulu/div/divu/rem/remu.  */
static void
s3_do_macro_mul_rdrsrs (char *str)
{
  int reg_rd;
  int reg_rs1;
  int reg_rs2;
  char *backupstr;
  char append_str[s3_MAX_LITERAL_POOL_SIZE];

  if (s3_university_version == 1)
    as_warn ("%s", s3_ERR_FOR_SCORE5U_MUL_DIV);

  strcpy (append_str, str);
  backupstr = append_str;
  s3_skip_whitespace (backupstr);
  if (((reg_rd = s3_reg_required_here (&backupstr, -1, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
      || (s3_skip_past_comma (&backupstr) == (int) s3_FAIL)
      || ((reg_rs1 = s3_reg_required_here (&backupstr, -1, s3_REG_TYPE_SCORE)) == (int) s3_FAIL))
    {
      s3_inst.error = s3_BAD_ARGS;
      return;
    }

  if (s3_skip_past_comma (&backupstr) == (int) s3_FAIL)
    {
      /* rem/remu rA, rB is error format.  */
      if (strcmp (s3_inst.name, "rem") == 0 || strcmp (s3_inst.name, "remu") == 0)
        {
          s3_SET_INSN_ERROR (s3_BAD_ARGS);
        }
      else
        {
          s3_SET_INSN_ERROR (NULL);
          s3_do_rsrs (str);
        }
      return;
    }
  else
    {
      s3_SET_INSN_ERROR (NULL);
      if (((reg_rs2 = s3_reg_required_here (&backupstr, -1, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
          || (s3_end_of_line (backupstr) == (int) s3_FAIL))
        {
          return;
        }
      else
        {
          char append_str1[s3_MAX_LITERAL_POOL_SIZE];

          if (strcmp (s3_inst.name, "rem") == 0)
            {
              sprintf (append_str, "mul r%d, r%d", reg_rs1, reg_rs2);
              sprintf (append_str1, "mfceh  r%d", reg_rd);
            }
          else if (strcmp (s3_inst.name, "remu") == 0)
            {
              sprintf (append_str, "mulu r%d, r%d", reg_rs1, reg_rs2);
              sprintf (append_str1, "mfceh  r%d", reg_rd);
            }
          else
            {
              sprintf (append_str, "%s r%d, r%d", s3_inst.name, reg_rs1, reg_rs2);
              sprintf (append_str1, "mfcel  r%d", reg_rd);
            }

          /* Output mul/mulu or div/divu or rem/remu.  */
          if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)
	    return;

          /* Output mfcel or mfceh.  */
          if (s3_append_insn (append_str1, TRUE) == (int) s3_FAIL)
	    return;

          /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
          s3_inst.bwarn = -1;
        }
    }
}

static void
s3_exp_macro_ldst_abs (char *str)
{
  int reg_rd;
  char *backupstr, *tmp;
  char append_str[s3_MAX_LITERAL_POOL_SIZE];
  char verifystr[s3_MAX_LITERAL_POOL_SIZE];
  struct s3_score_it inst_backup;
  int r1_bak = 0;

  r1_bak = s3_nor1;
  s3_nor1 = 0;
  memcpy (&inst_backup, &s3_inst, sizeof (struct s3_score_it));

  strcpy (verifystr, str);
  backupstr = verifystr;
  s3_skip_whitespace (backupstr);
  if ((reg_rd = s3_reg_required_here (&backupstr, -1, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
    return;

  tmp = backupstr;
  if (s3_skip_past_comma (&backupstr) == (int) s3_FAIL)
    return;

  backupstr = tmp;
  sprintf (append_str, "li r1  %s", backupstr);
  s3_append_insn (append_str, TRUE);

  memcpy (&s3_inst, &inst_backup, sizeof (struct s3_score_it));
  sprintf (append_str, " r%d, [r1,0]", reg_rd);
  s3_do_ldst_insn (append_str);

  s3_nor1 = r1_bak;
}

/* Handle bcmpeq / bcmpne  */
static void
s3_do_macro_bcmp (char *str)
{
  int reg_a , reg_b;
  char keep_data[s3_MAX_LITERAL_POOL_SIZE];
  char* ptemp;
  int i = 0;
  struct s3_score_it inst_expand[2];
  struct s3_score_it inst_main;

  memset (inst_expand, 0, sizeof inst_expand);
  s3_skip_whitespace (str);
  if (( reg_a = s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      ||(reg_b = s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL)
    return;
  ptemp = str;
  while (*ptemp != 0)
    {
      keep_data[i] = *ptemp;
      i++;
      ptemp++;
    }
  keep_data[i] = 0;
  if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL
      ||reg_b == 0
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
  else if (s3_inst.reloc.exp.X_add_symbol == 0)
    {
      s3_inst.error = _("lacking label  ");
      return;
    }
  else
    {
      char append_str[s3_MAX_LITERAL_POOL_SIZE];
      s3_SET_INSN_ERROR (NULL);

      s3_inst.reloc.type = BFD_RELOC_SCORE_BCMP;
      s3_inst.reloc.pc_rel = 1;
      bfd_signed_vma val = s3_inst.reloc.exp.X_add_number;

      /* Branch 32  offset field : 20 bit, 16 bit branch offset field : 8 bit.  */
      s3_inst.instruction |= ((s3_inst.reloc.exp.X_add_number >> 1) & 0x1)
	| ((s3_inst.reloc.exp.X_add_number >> 2) & 0x7) << 7
	| ((s3_inst.reloc.exp.X_add_number >> 5) & 0x1f) << 20;

      /* Check and set offset.  */
      if (((val & 0xfffffe00) != 0)
	  && ((val & 0xfffffe00) != 0xfffffe00))
        {
          /* support bcmp --> cmp!+beq (bne) */
          if (s3_score_pic == s3_NO_PIC)
            {
              sprintf (&append_str[0], "cmp! r%d, r%d", reg_a, reg_b);
              if (s3_append_insn (&append_str[0], TRUE) == (int) s3_FAIL)
                return;
              if ((inst_main.instruction & 0x3e00007e) == 0x0000004c)
                sprintf (&append_str[1], "beq %s", keep_data);
              else
                sprintf (&append_str[1], "bne %s", keep_data);
              if (s3_append_insn (&append_str[1], TRUE) == (int) s3_FAIL)
                return;
	    }
	  else
	    {
	      gas_assert (s3_inst.reloc.exp.X_add_symbol);
	    }
	  /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
	  s3_inst.bwarn = -1;
	  return;
        }
      else
        {
          val >>= 1;
          s3_inst.instruction |= (val & 0x1)
	    | (((val >> 1) & 0x7) << 7)
	    | (((val >> 4) & 0x1f) << 20);
        }

      /* Backup s3_inst.  */
      memcpy (&inst_main, &s3_inst, sizeof (struct s3_score_it));

      if (s3_score_pic == s3_NO_PIC)
        {
          sprintf (&append_str[0], "cmp! r%d, r%d", reg_a, reg_b);
          if (s3_append_insn (&append_str[0], FALSE) == (int) s3_FAIL)
            return;
          memcpy (&inst_expand[0], &s3_inst, sizeof (struct s3_score_it));

          if ((inst_main.instruction & 0x3e00007e) == 0x0000004c)
            sprintf (&append_str[1], "beq %s", keep_data);
          else
            sprintf (&append_str[1], "bne %s", keep_data);
          if (s3_append_insn (&append_str[1], FALSE) == (int) s3_FAIL)
            return;
          memcpy (&inst_expand[1], &s3_inst, sizeof (struct s3_score_it));
        }
      else
        {
          gas_assert (s3_inst.reloc.exp.X_add_symbol);
        }
      inst_main.relax_size = inst_expand[0].size + inst_expand[1].size;
      inst_main.type = Insn_BCMP;

      /* Adjust instruction opcode and to be relaxed instruction opcode.  */
      inst_main.instruction = s3_adjust_paritybit (inst_main.instruction, s3_GET_INSN_CLASS (inst_main.type));

      for (i = 0; i < 2; i++)
        inst_expand[i].instruction = s3_adjust_paritybit (inst_expand[i].instruction,
                                                          s3_GET_INSN_CLASS (inst_expand[i].type));
      /* Check data dependency.  */
      s3_handle_dependency (&inst_main);
      /* Start a new frag if frag_now is not empty.  */
      if (frag_now_fix () != 0)
	{
	  if (!frag_now->tc_frag_data.is_insn)
	    frag_wane (frag_now);
	  frag_new (0);
	}
      frag_grow (20);

      /* Write fr_fix part.  */
      char *p;
      p = frag_more (inst_main.size);
      s3_md_number_to_chars (p, inst_main.instruction, inst_main.size);

      if (inst_main.reloc.type != BFD_RELOC_NONE)
	{
	  s3_fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
			    &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);
	}
#ifdef OBJ_ELF
      dwarf2_emit_insn (inst_main.size);
#endif

      /* s3_GP instruction can not do optimization, only can do relax between
         1 instruction and 3 instructions.  */
      p = frag_var (rs_machine_dependent, inst_main.relax_size + s3_RELAX_PAD_BYTE, 0,
                    s3_RELAX_ENCODE (inst_main.size, inst_main.relax_size, inst_main.type, 0, 4, 1),
                    inst_main.reloc.exp.X_add_symbol, 0, NULL);

      /* Write fr_var part.
         no calling s3_gen_insn_frag, no fixS will be generated.  */
      s3_md_number_to_chars (p, inst_expand[0].instruction, inst_expand[0].size);
      p += inst_expand[0].size;
      s3_md_number_to_chars (p, inst_expand[1].instruction, inst_expand[1].size);
      p += inst_expand[1].size;

      /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
      s3_inst.bwarn = -1;
    }
}

/* Handle bcmpeqz / bcmpnez  */
static void
s3_do_macro_bcmpz (char *str)
{
  int reg_a;
  char keep_data[s3_MAX_LITERAL_POOL_SIZE];
  char* ptemp;
  int i = 0;
  struct s3_score_it inst_expand[2];
  struct s3_score_it inst_main;

  memset (inst_expand, 0, sizeof inst_expand);
  s3_skip_whitespace (str);
  if (( reg_a = s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL)
    return;
  ptemp = str;
  while (*ptemp != 0)
    {
      keep_data[i] = *ptemp;
      i++;
      ptemp++;
    }

  keep_data[i] = 0;

  if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;
  else if (s3_inst.reloc.exp.X_add_symbol == 0)
    {
      s3_inst.error = _("lacking label  ");
      return;
    }
  else
    {
      char append_str[s3_MAX_LITERAL_POOL_SIZE];
      s3_SET_INSN_ERROR (NULL);
      s3_inst.reloc.type = BFD_RELOC_SCORE_BCMP;
      s3_inst.reloc.pc_rel = 1;
      bfd_signed_vma val = s3_inst.reloc.exp.X_add_number;

      /* Branch 32  offset field : 20 bit, 16 bit branch offset field : 8 bit.  */
      s3_inst.instruction |= ((s3_inst.reloc.exp.X_add_number>>1) & 0x1) | ((s3_inst.reloc.exp.X_add_number>>2) & 0x7)<<7 |((s3_inst.reloc.exp.X_add_number>>5) & 0x1f)<<20;

      /* Check and set offset.  */
      if (((val & 0xfffffe00) != 0)
	  && ((val & 0xfffffe00) != 0xfffffe00))
        {
          if (s3_score_pic == s3_NO_PIC)
            {
              sprintf (&append_str[0], "cmpi! r%d,0", reg_a);
              if (s3_append_insn (&append_str[0], TRUE) == (int) s3_FAIL)
                return;
              if ((inst_main.instruction & 0x3e00007e) == 0x0000004c)
                sprintf (&append_str[1], "beq %s", keep_data);
              else
                sprintf (&append_str[1], "bne %s", keep_data);
              if (s3_append_insn (&append_str[1], TRUE) == (int) s3_FAIL)
                return;
            }
          else
            {
              gas_assert (s3_inst.reloc.exp.X_add_symbol);
            }
          /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
          s3_inst.bwarn = -1;
          return;
        }
      else
        {
          val >>= 1;
          s3_inst.instruction |= (val & 0x1)
	    | (((val >> 1) & 0x7) << 7)
	    | (((val >> 4) & 0x1f) << 20);
        }

      /* Backup s3_inst.  */
      memcpy (&inst_main, &s3_inst, sizeof (struct s3_score_it));

      if (s3_score_pic == s3_NO_PIC)
        {
          sprintf (&append_str[0], "cmpi! r%d, 0", reg_a);
          if (s3_append_insn (&append_str[0], FALSE) == (int) s3_FAIL)
            return;
          memcpy (&inst_expand[0], &s3_inst, sizeof (struct s3_score_it));
          if ((inst_main.instruction & 0x3e00007e) == 0x0000004c)
            sprintf (&append_str[1], "beq %s", keep_data);
          else
            sprintf (&append_str[1], "bne %s", keep_data);
          if (s3_append_insn (&append_str[1], FALSE) == (int) s3_FAIL)
            return;
          memcpy (&inst_expand[1], &s3_inst, sizeof (struct s3_score_it));
        }
      else
        {
          gas_assert (s3_inst.reloc.exp.X_add_symbol);
        }
      inst_main.relax_size = inst_expand[0].size + inst_expand[1].size;
      inst_main.type = Insn_BCMP;

      /* Adjust instruction opcode and to be relaxed instruction opcode.  */
      inst_main.instruction = s3_adjust_paritybit (inst_main.instruction, s3_GET_INSN_CLASS (inst_main.type));

      for (i = 0; i < 2; i++)
        inst_expand[i].instruction = s3_adjust_paritybit (inst_expand[i].instruction ,
							  s3_GET_INSN_CLASS (inst_expand[i].type));
      /* Check data dependency.  */
      s3_handle_dependency (&inst_main);
      /* Start a new frag if frag_now is not empty.  */
      if (frag_now_fix () != 0)
	{
	  if (!frag_now->tc_frag_data.is_insn)
	    frag_wane (frag_now);
	  frag_new (0);
	}
      frag_grow (20);

      /* Write fr_fix part.  */
      char *p;
      p = frag_more (inst_main.size);
      s3_md_number_to_chars (p, inst_main.instruction, inst_main.size);

      if (inst_main.reloc.type != BFD_RELOC_NONE)
	{
	  s3_fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
			    &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);
	}
#ifdef OBJ_ELF
      dwarf2_emit_insn (inst_main.size);
#endif

      /* s3_GP instruction can not do optimization, only can do relax between
         1 instruction and 3 instructions.  */
      p = frag_var (rs_machine_dependent, inst_main.relax_size + s3_RELAX_PAD_BYTE, 0,
                    s3_RELAX_ENCODE (inst_main.size, inst_main.relax_size, inst_main.type, 0, 4, 1),
                    inst_main.reloc.exp.X_add_symbol, 0, NULL);

      /* Write fr_var part.
         no calling s3_gen_insn_frag, no fixS will be generated.  */
      s3_md_number_to_chars (p, inst_expand[0].instruction, inst_expand[0].size);
      p += inst_expand[0].size;
      s3_md_number_to_chars (p, inst_expand[1].instruction, inst_expand[1].size);
      p += inst_expand[1].size;

      /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
      s3_inst.bwarn = -1;
    }
}

static int
s3_nopic_need_relax (symbolS * sym, int before_relaxing)
{
  if (sym == NULL)
    return 0;
  else if (s3_USE_GLOBAL_POINTER_OPT && s3_g_switch_value > 0)
    {
      const char *symname;
      const char *segname;

      /* Find out whether this symbol can be referenced off the $gp
         register.  It can be if it is smaller than the -G size or if
         it is in the .sdata or .sbss section.  Certain symbols can
         not be referenced off the $gp, although it appears as though
         they can.  */
      symname = S_GET_NAME (sym);
      if (symname != (const char *)NULL
          && (strcmp (symname, "eprol") == 0
              || strcmp (symname, "etext") == 0
              || strcmp (symname, "_gp") == 0
              || strcmp (symname, "edata") == 0
              || strcmp (symname, "_fbss") == 0
              || strcmp (symname, "_fdata") == 0
              || strcmp (symname, "_ftext") == 0
              || strcmp (symname, "end") == 0
              || strcmp (symname, GP_DISP_LABEL) == 0))
        {
          return 1;
        }
      else if ((!S_IS_DEFINED (sym) || S_IS_COMMON (sym)) && (0
							      /* We must defer this decision until after the whole file has been read,
								 since there might be a .extern after the first use of this symbol.  */
							      || (before_relaxing
								  && S_GET_VALUE (sym) == 0)
							      || (S_GET_VALUE (sym) != 0
								  && S_GET_VALUE (sym) <= s3_g_switch_value)))
        {
          return 0;
        }

      segname = segment_name (S_GET_SEGMENT (sym));
      return (strcmp (segname, ".sdata") != 0
	      && strcmp (segname, ".sbss") != 0
	      && strncmp (segname, ".sdata.", 7) != 0
	      && strncmp (segname, ".gnu.linkonce.s.", 16) != 0);
    }
  /* We are not optimizing for the $gp register.  */
  else
    return 1;
}

/* Build a relax frag for lw/st instruction when generating s3_PIC,
   external symbol first and local symbol second.  */
static void
s3_build_lwst_pic (int reg_rd, expressionS exp, const char *insn_name)
{
  symbolS *add_symbol = exp.X_add_symbol;
  int add_number = exp.X_add_number;
  struct s3_score_it fix_insts[s3_RELAX_INST_NUM];
  struct s3_score_it var_insts[s3_RELAX_INST_NUM];
  int fix_num = 0;
  int var_num = 0;
  char tmp[s3_MAX_LITERAL_POOL_SIZE];
  int r1_bak;

  r1_bak = s3_nor1;
  s3_nor1 = 0;

  if ((add_number == 0) || (add_number >= -0x8000 && add_number <= 0x7fff))
    {
      fix_num = 1;
      var_num = 2;

      /* For an external symbol, two insns are generated;
         For a local symbol, three insns are generated.  */
      /* Fix part
         For an external symbol: lw rD, <sym>($gp)
	 (BFD_RELOC_SCORE_GOT15)  */
      sprintf (tmp, "lw_pic r1, %s", add_symbol->bsym->name);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
        return;

      memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));

      /* Var part
	 For a local symbol :
         lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)
	 addi rD, <sym>       (BFD_RELOC_GOT_LO16) */
      s3_inst.reloc.type = BFD_RELOC_SCORE_GOT15;
      memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));
      sprintf (tmp, "addi_s_pic r1, %s", add_symbol->bsym->name);
      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)
        return;

      memcpy (&var_insts[1], &s3_inst, sizeof (struct s3_score_it));
      s3_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);

      /* Insn 2 or Insn 3: lw/st rD, [r1, constant]  */
      sprintf (tmp, "%s r%d, [r1, %d]", insn_name, reg_rd, add_number);
      if (s3_append_insn (tmp, TRUE) == (int) s3_FAIL)
        return;

      /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
      s3_inst.bwarn = -1;
    }
  else
    {
      s3_inst.error = _("s3_PIC code offset overflow (max 16 signed bits)");
      return;
    }

  s3_nor1 = r1_bak;
}

static void
s3_do_macro_ldst_label (char *str)
{
  int i;
  int ldst_gp_p = 0;
  int reg_rd;
  int r1_bak;
  char *backup_str;
  char *label_str;
  char *absolute_value;
  char append_str[3][s3_MAX_LITERAL_POOL_SIZE];
  char verifystr[s3_MAX_LITERAL_POOL_SIZE];
  struct s3_score_it inst_backup;
  struct s3_score_it inst_expand[3];
  struct s3_score_it inst_main;

  memcpy (&inst_backup, &s3_inst, sizeof (struct s3_score_it));
  strcpy (verifystr, str);
  backup_str = verifystr;

  s3_skip_whitespace (backup_str);
  if ((reg_rd = s3_reg_required_here (&backup_str, -1, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
    return;

  if (s3_skip_past_comma (&backup_str) == (int) s3_FAIL)
    return;

  label_str = backup_str;

  /* Ld/st rD, [rA, imm]      ld/st rD, [rA]+, imm      ld/st rD, [rA, imm]+.  */
  if (*backup_str == '[')
    {
      s3_inst.type = Rd_rvalueRs_preSI12;
      s3_do_ldst_insn (str);
      return;
    }

  /* Ld/st rD, imm.  */
  absolute_value = backup_str;
  s3_inst.type = Rd_rvalueRs_SI15;

  if (s3_my_get_expression (&s3_inst.reloc.exp, &backup_str) == (int) s3_FAIL)
    {
      s3_inst.error = _("expression error");
      return;
    }
  else if ((s3_inst.reloc.exp.X_add_symbol == NULL)
           && (s3_validate_immediate (s3_inst.reloc.exp.X_add_number, _VALUE, 0) == (int) s3_FAIL))
    {
      s3_inst.error = _("value not in range [0, 0x7fffffff]");
      return;
    }
  else if (s3_end_of_line (backup_str) == (int) s3_FAIL)
    {
      s3_inst.error = _("end on line error");
      return;
    }
  else
    {
      if (s3_inst.reloc.exp.X_add_symbol == 0)
        {
          memcpy (&s3_inst, &inst_backup, sizeof (struct s3_score_it));
          s3_exp_macro_ldst_abs (str);
          return;
        }
    }

  /* Ld/st rD, label.  */
  s3_inst.type = Rd_rvalueRs_SI15;
  backup_str = absolute_value;
  if ((s3_data_op2 (&backup_str, 1, _GP_IMM15) == (int) s3_FAIL)
      || (s3_end_of_line (backup_str) == (int) s3_FAIL))
    {
      return;
    }
  else
    {
      if (s3_inst.reloc.exp.X_add_symbol == 0)
        {
          if (!s3_inst.error)
	    s3_inst.error = s3_BAD_ARGS;

          return;
        }

      if (s3_score_pic == s3_PIC)
        {
          int ldst_idx = 0;
          ldst_idx = s3_inst.instruction & OPC_PSEUDOLDST_MASK;
          s3_build_lwst_pic (reg_rd, s3_inst.reloc.exp,
                             s3_score_ldst_insns[ldst_idx * 3 + 0].template_name);
          return;
        }
      else
	{
          if ((s3_inst.reloc.exp.X_add_number <= 0x3fff)
	      && (s3_inst.reloc.exp.X_add_number >= -0x4000)
	      && (!s3_nopic_need_relax (s3_inst.reloc.exp.X_add_symbol, 1)))
	    {
              int ldst_idx = 0;

              /* Assign the real opcode.  */
              ldst_idx = s3_inst.instruction & OPC_PSEUDOLDST_MASK;
              s3_inst.instruction &= ~OPC_PSEUDOLDST_MASK;
              s3_inst.instruction |= s3_score_ldst_insns[ldst_idx * 3 + 0].value;
              s3_inst.instruction |= reg_rd << 20;
              s3_inst.instruction |= s3_GP << 15;
              s3_inst.relax_inst = 0x8000;
              s3_inst.relax_size = 0;
              ldst_gp_p = 1;
	    }
	}
    }

  /* Backup s3_inst.  */
  memcpy (&inst_main, &s3_inst, sizeof (struct s3_score_it));
  r1_bak = s3_nor1;
  s3_nor1 = 0;

  /* Determine which instructions should be output.  */
  sprintf (append_str[0], "ld_i32hi r1, %s", label_str);
  sprintf (append_str[1], "ld_i32lo r1, %s", label_str);
  sprintf (append_str[2], "%s r%d, [r1, 0]", inst_backup.name, reg_rd);

  /* Generate three instructions.
     la r1, label
     ld/st rd, [r1, 0]  */
  for (i = 0; i < 3; i++)
    {
      if (s3_append_insn (append_str[i], FALSE) == (int) s3_FAIL)
	return;

      memcpy (&inst_expand[i], &s3_inst, sizeof (struct s3_score_it));
    }

  if (ldst_gp_p)
    {
      char *p;

      /* Adjust instruction opcode and to be relaxed instruction opcode.  */
      inst_main.instruction = s3_adjust_paritybit (inst_main.instruction, s3_GET_INSN_CLASS (inst_main.type));

      /* relax lw rd, label -> ldis rs, imm16
	 ori  rd, imm16
	 lw rd, [rs, imm15] or lw! rd, [rs, imm5].  */
      if (inst_expand[2].relax_size == 0)
        inst_main.relax_size = inst_expand[0].size + inst_expand[1].size + inst_expand[2].size;
      else
        inst_main.relax_size = inst_expand[0].size + inst_expand[1].size + inst_expand[2].relax_size;

      inst_main.type = Insn_GP;

      for (i = 0; i < 3; i++)
	inst_expand[i].instruction = s3_adjust_paritybit (inst_expand[i].instruction,
                                                          s3_GET_INSN_CLASS (inst_expand[i].type));

      /* Check data dependency.  */
      s3_handle_dependency (&inst_main);

      /* Start a new frag if frag_now is not empty.  */
      if (frag_now_fix () != 0)
        {
          if (!frag_now->tc_frag_data.is_insn)
	    frag_wane (frag_now);

          frag_new (0);
        }
      frag_grow (20);

      /* Write fr_fix part.  */
      p = frag_more (inst_main.size);
      s3_md_number_to_chars (p, inst_main.instruction, inst_main.size);

      if (inst_main.reloc.type != BFD_RELOC_NONE)
        {
          s3_fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
			    &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);
        }

#ifdef OBJ_ELF
      dwarf2_emit_insn (inst_main.size);
#endif

      /* s3_GP instruction can not do optimization, only can do relax between
         1 instruction and 3 instructions.  */
      p = frag_var (rs_machine_dependent, inst_main.relax_size + s3_RELAX_PAD_BYTE, 0,
                    s3_RELAX_ENCODE (inst_main.size, inst_main.relax_size, inst_main.type, 0, 4, 0),
                    inst_main.reloc.exp.X_add_symbol, 0, NULL);

      /* Write fr_var part.
         no calling s3_gen_insn_frag, no fixS will be generated.  */
      s3_md_number_to_chars (p, inst_expand[0].instruction, inst_expand[0].size);
      p += inst_expand[0].size;
      s3_md_number_to_chars (p, inst_expand[1].instruction, inst_expand[1].size);
      p += inst_expand[1].size;

      /* relax lw rd, label -> ldis rs, imm16
	 ori  rd, imm16
	 lw rd, [rs, imm15] or lw! rd, [rs, imm5].  */
      if (inst_expand[2].relax_size == 0)
        s3_md_number_to_chars (p, inst_expand[2].instruction, inst_expand[2].size);
      else
        s3_md_number_to_chars (p, inst_expand[2].relax_inst, inst_expand[2].relax_size);
    }
  else
    {
      s3_gen_insn_frag (&inst_expand[0], NULL);
      s3_gen_insn_frag (&inst_expand[1], NULL);
      s3_gen_insn_frag (&inst_expand[2], NULL);
    }
  s3_nor1 = r1_bak;

  /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
  s3_inst.bwarn = -1;
}

static void
s3_do_lw_pic (char *str)
{
  int reg_rd;

  s3_skip_whitespace (str);
  if (((reg_rd = s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
      || (s3_skip_past_comma (&str) == (int) s3_FAIL)
      || (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL)
      || (s3_end_of_line (str) == (int) s3_FAIL))
    {
      return;
    }
  else
    {
      if (s3_inst.reloc.exp.X_add_symbol == 0)
        {
          if (!s3_inst.error)
	    s3_inst.error = s3_BAD_ARGS;

          return;
        }

      s3_inst.instruction |= s3_GP << 15;
      s3_inst.reloc.type = BFD_RELOC_SCORE_GOT15;
    }
}

static void
s3_do_empty (char *str)
{
  str = str;
  if (s3_university_version == 1)
    {
      if (((s3_inst.instruction & 0x3e0003ff) == 0x0c000004)
          || ((s3_inst.instruction & 0x3e0003ff) == 0x0c000024)
          || ((s3_inst.instruction & 0x3e0003ff) == 0x0c000044)
          || ((s3_inst.instruction & 0x3e0003ff) == 0x0c000064))
        {
          s3_inst.error = s3_ERR_FOR_SCORE5U_MMU;
          return;
        }
    }
  if (s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if (s3_inst.relax_inst != 0x8000)
    {
      if (s3_inst.type == NO_OPD)
        {
          s3_inst.relax_size = 2;
        }
      else
        {
          s3_inst.relax_size = 4;
        }
    }
}

static void
s3_do16_int (char *str)
{
  s3_skip_whitespace (str);
  return;
}

static void
s3_do_jump (char *str)
{
  char *save_in;

  s3_skip_whitespace (str);
  if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if (s3_inst.reloc.exp.X_add_symbol == 0)
    {
      s3_inst.error = _("lacking label  ");
      return;
    }

  if (!(s3_inst.reloc.exp.X_add_number >= -16777216
	&& s3_inst.reloc.exp.X_add_number <= 16777215))
    {
      s3_inst.error = _("invalid constant: 25 bit expression not in range [-16777216, 16777215]");
      return;
    }

  save_in = input_line_pointer;
  input_line_pointer = str;
  s3_inst.reloc.type = BFD_RELOC_SCORE_JMP;
  s3_inst.reloc.pc_rel = 1;
  input_line_pointer = save_in;
}

static void
s3_do_branch (char *str)
{
  if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
  else if (s3_inst.reloc.exp.X_add_symbol == 0)
    {
      s3_inst.error = _("lacking label  ");
      return;
    }
  else if (!(s3_inst.reloc.exp.X_add_number >= -524288
	     && s3_inst.reloc.exp.X_add_number <= 524287))
    {
      s3_inst.error = _("invalid constant: 20 bit expression not in range -2^19..2^19");
      return;
    }

  s3_inst.reloc.type = BFD_RELOC_SCORE_BRANCH;
  s3_inst.reloc.pc_rel = 1;

  /* Branch 32  offset field : 20 bit, 16 bit branch offset field : 8 bit.  */
  s3_inst.instruction |= (s3_inst.reloc.exp.X_add_number & 0x3fe) | ((s3_inst.reloc.exp.X_add_number & 0xffc00) << 5);

  /* Compute 16 bit branch instruction.  */
  if ((s3_inst.relax_inst != 0x8000)
      && (s3_inst.reloc.exp.X_add_number >= -512 && s3_inst.reloc.exp.X_add_number <= 511))
    {
      s3_inst.relax_inst |= ((s3_inst.reloc.exp.X_add_number >> 1) & 0x1ff);/*b! :disp 9 bit */
      s3_inst.relax_size = 2;
    }
  else
    {
      s3_inst.relax_inst = 0x8000;
    }
}

static void
s3_do16_branch (char *str)
{
  if ((s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL
       || s3_end_of_line (str) == (int) s3_FAIL))
    {
      ;
    }
  else if (s3_inst.reloc.exp.X_add_symbol == 0)
    {
      s3_inst.error = _("lacking label");
    }
  else if (!(s3_inst.reloc.exp.X_add_number >= -512
	     && s3_inst.reloc.exp.X_add_number <= 511))
    {
      s3_inst.error = _("invalid constant: 10 bit expression not in range [-2^9, 2^9-1]");
    }
  else
    {
      s3_inst.reloc.type = BFD_RELOC_SCORE16_BRANCH;
      s3_inst.reloc.pc_rel = 1;
      s3_inst.instruction |= ((s3_inst.reloc.exp.X_add_number >> 1) & 0x1ff);
      s3_inst.relax_inst |= ((s3_inst.reloc.exp.X_add_number ) & 0x1ff);
      s3_inst.relax_size = 4;
    }
}

/* Return true if the given symbol should be considered local for s3_PIC.  */
static bfd_boolean
s3_pic_need_relax (symbolS *sym, asection *segtype)
{
  asection *symsec;
  bfd_boolean linkonce;

  /* Handle the case of a symbol equated to another symbol.  */
  while (symbol_equated_reloc_p (sym))
    {
      symbolS *n;

      /* It's possible to get a loop here in a badly written
	 program.  */
      n = symbol_get_value_expression (sym)->X_add_symbol;
      if (n == sym)
	break;
      sym = n;
    }

  symsec = S_GET_SEGMENT (sym);

  /* duplicate the test for LINK_ONCE sections as in adjust_reloc_syms */
  linkonce = FALSE;
  if (symsec != segtype && ! S_IS_LOCAL (sym))
    {
      if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE) != 0)
	linkonce = TRUE;

      /* The GNU toolchain uses an extension for ELF: a section
	 beginning with the magic string .gnu.linkonce is a linkonce
	 section.  */
      if (strncmp (segment_name (symsec), ".gnu.linkonce",
		   sizeof ".gnu.linkonce" - 1) == 0)
	linkonce = TRUE;
    }

  /* This must duplicate the test in adjust_reloc_syms.  */
  return (!bfd_is_und_section (symsec)
	  && !bfd_is_abs_section (symsec)
	  && !bfd_is_com_section (symsec)
	  && !linkonce
#ifdef OBJ_ELF
	  /* A global or weak symbol is treated as external.  */
	  && (OUTPUT_FLAVOR != bfd_target_elf_flavour
	      || (! S_IS_WEAK (sym) && ! S_IS_EXTERNAL (sym)))
#endif
	  );
}

static void
s3_parse_pce_inst (char *insnstr)
{
  char c;
  char *p;
  char first[s3_MAX_LITERAL_POOL_SIZE];
  char second[s3_MAX_LITERAL_POOL_SIZE];
  struct s3_score_it pec_part_1;

  /* Get first part string of PCE.  */
  p = strstr (insnstr, "||");
  c = *p;
  *p = '\0';
  sprintf (first, "%s", insnstr);

  /* Get second part string of PCE.  */
  *p = c;
  p += 2;
  sprintf (second, "%s", p);

  s3_parse_16_32_inst (first, FALSE);
  if (s3_inst.error)
    return;

  memcpy (&pec_part_1, &s3_inst, sizeof (s3_inst));

  s3_parse_16_32_inst (second, FALSE);
  if (s3_inst.error)
    return;

  if (   ((pec_part_1.size == s3_INSN_SIZE) && (s3_inst.size == s3_INSN_SIZE))
	 || ((pec_part_1.size == s3_INSN_SIZE) && (s3_inst.size == s3_INSN16_SIZE))
	 || ((pec_part_1.size == s3_INSN16_SIZE) && (s3_inst.size == s3_INSN_SIZE)))
    {
      s3_inst.error = _("pce instruction error (16 bit || 16 bit)'");
      sprintf (s3_inst.str, insnstr);
      return;
    }

  if (!s3_inst.error)
    s3_gen_insn_frag (&pec_part_1, &s3_inst);
}

/* s3: dsp.  */
static void
s3_do16_dsp (char *str)
{
  int rd = 0;

  /* Check 3d.  */
  if (s3_score3d == 0)
    {
      s3_inst.error = _("score3d instruction.");
      return;
    }

  s3_skip_whitespace (str);

  if ((rd = s3_reglow_required_here (&str, 0)) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
  else
    {
      s3_inst.relax_inst |= rd << 20;
      s3_inst.relax_size = 4;
    }
}

static void
s3_do16_dsp2 (char *str)
{
  /* Check 3d.  */
  if (s3_score3d == 0)
    {
      s3_inst.error = _("score3d instruction.");
      return;
    }

  s3_skip_whitespace (str);

  if (s3_reglow_required_here (&str, 4) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reglow_required_here (&str, 0) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
  else
    {
      s3_inst.relax_inst |= (((s3_inst.instruction >> 8) & 0xf) << 20)
        | (((s3_inst.instruction >> 8) & 0xf) << 15) | (((s3_inst.instruction >> 4) & 0xf) << 10);
      s3_inst.relax_size = 4;
    }
}

static void
s3_do_dsp (char *str)
{
  /* Check 3d.  */
  if (s3_score3d == 0)
    {
      s3_inst.error = _("score3d instruction.");
      return;
    }

  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if ((s3_inst.relax_inst != 0x8000) && (((s3_inst.instruction >> 20) & 0x1f) == 3) )
    {
      s3_inst.relax_inst |= (((s3_inst.instruction >> 10) & 0x1f)) | (((s3_inst.instruction >> 15) & 0x1f) << 5);
      s3_inst.relax_size = 2;
    }
  else
    s3_inst.relax_inst = 0x8000;
}

static void
s3_do_dsp2 (char *str)
{
  int reg;

  /* Check 3d.  */
  if (s3_score3d == 0)
    {
      s3_inst.error = _("score3d instruction.");
      return;
    }

  s3_skip_whitespace (str);

  if ((reg = s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 10, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    {
      return;
    }
  else
    {
      /* Check mulr, mulur rd is even number.  */
      if (((s3_inst.instruction & 0x3e0003ff) == 0x00000340
	   || (s3_inst.instruction & 0x3e0003ff) == 0x00000342)
          && (reg % 2))
        {
          s3_inst.error = _("rd must be even number.");
          return;
        }

      if ((((s3_inst.instruction >> 15) & 0x10) == 0)
          && (((s3_inst.instruction >> 10) & 0x10) == 0)
          && (((s3_inst.instruction >> 20) & 0x10) == 0)
          && (s3_inst.relax_inst != 0x8000)
          && (((s3_inst.instruction >> 20) & 0xf) == ((s3_inst.instruction >> 15) & 0xf)))
        {
          s3_inst.relax_inst |= (((s3_inst.instruction >> 10) & 0xf) )
            | (((s3_inst.instruction >> 15) & 0xf) << 4);
          s3_inst.relax_size = 2;
        }
      else
        {
          s3_inst.relax_inst = 0x8000;
        }
    }
}

static void
s3_do_dsp3 (char *str)
{
  /* Check 3d.  */
  if (s3_score3d == 0)
    {
      s3_inst.error = _("score3d instruction.");
      return;
    }

  s3_skip_whitespace (str);

  if (s3_reg_required_here (&str, 20, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_skip_past_comma (&str) == (int) s3_FAIL
      || s3_reg_required_here (&str, 15, s3_REG_TYPE_SCORE) == (int) s3_FAIL
      || s3_end_of_line (str) == (int) s3_FAIL)
    return;

  if ((s3_inst.relax_inst != 0x8000) && (((s3_inst.instruction >> 20) & 0x1f) == 3) )
    {
      s3_inst.relax_inst |= (((s3_inst.instruction >> 10) & 0x1f)) | (((s3_inst.instruction >> 15) & 0x1f) << 5);
      s3_inst.relax_size = 2;
    }
  else
    s3_inst.relax_inst = 0x8000;
}


/* If we change section we must dump the literal pool first.  */
static void
s3_s_score_bss (int ignore ATTRIBUTE_UNUSED)
{
  subseg_set (bss_section, (subsegT) get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
s3_s_score_text (int ignore)
{
  obj_elf_text (ignore);
  record_alignment (now_seg, 2);
}

static void
s3_score_s_section (int ignore)
{
  obj_elf_section (ignore);
  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    record_alignment (now_seg, 2);

}

static void
s3_s_change_sec (int sec)
{
  segT seg;

#ifdef OBJ_ELF
  /* The ELF backend needs to know that we are changing sections, so
     that .previous works correctly.  We could do something like check
     for an obj_section_change_hook macro, but that might be confusing
     as it would not be appropriate to use it in the section changing
     functions in read.c, since obj-elf.c intercepts those.  FIXME:
     This should be cleaner, somehow.  */
  obj_elf_section_change_hook ();
#endif
  switch (sec)
    {
    case 'r':
      seg = subseg_new (s3_RDATA_SECTION_NAME, (subsegT) get_absolute_expression ());
      bfd_set_section_flags (stdoutput, seg, (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_RELOC | SEC_DATA));
      if (strcmp (TARGET_OS, "elf") != 0)
        record_alignment (seg, 4);
      demand_empty_rest_of_line ();
      break;
    case 's':
      seg = subseg_new (".sdata", (subsegT) get_absolute_expression ());
      bfd_set_section_flags (stdoutput, seg, SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);
      if (strcmp (TARGET_OS, "elf") != 0)
        record_alignment (seg, 4);
      demand_empty_rest_of_line ();
      break;
    }
}

static void
s3_s_score_mask (int reg_type ATTRIBUTE_UNUSED)
{
  long mask, off;

  if (s3_cur_proc_ptr == (s3_procS *) NULL)
    {
      as_warn (_(".mask outside of .ent"));
      demand_empty_rest_of_line ();
      return;
    }
  if (get_absolute_expression_and_terminator (&mask) != ',')
    {
      as_warn (_("Bad .mask directive"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  off = get_absolute_expression ();
  s3_cur_proc_ptr->reg_mask = mask;
  s3_cur_proc_ptr->reg_offset = off;
  demand_empty_rest_of_line ();
}

static symbolS *
s3_get_symbol (void)
{
  int c;
  char *name;
  symbolS *p;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = (symbolS *) symbol_find_or_make (name);
  *input_line_pointer = c;
  return p;
}

static long
s3_get_number (void)
{
  int negative = 0;
  long val = 0;

  if (*input_line_pointer == '-')
    {
      ++input_line_pointer;
      negative = 1;
    }
  if (!ISDIGIT (*input_line_pointer))
    as_bad (_("expected simple number"));
  if (input_line_pointer[0] == '0')
    {
      if (input_line_pointer[1] == 'x')
        {
          input_line_pointer += 2;
          while (ISXDIGIT (*input_line_pointer))
            {
              val <<= 4;
              val |= hex_value (*input_line_pointer++);
            }
          return negative ? -val : val;
        }
      else
        {
          ++input_line_pointer;
          while (ISDIGIT (*input_line_pointer))
            {
              val <<= 3;
              val |= *input_line_pointer++ - '0';
            }
          return negative ? -val : val;
        }
    }
  if (!ISDIGIT (*input_line_pointer))
    {
      printf (_(" *input_line_pointer == '%c' 0x%02x\n"), *input_line_pointer, *input_line_pointer);
      as_warn (_("invalid number"));
      return -1;
    }
  while (ISDIGIT (*input_line_pointer))
    {
      val *= 10;
      val += *input_line_pointer++ - '0';
    }
  return negative ? -val : val;
}

/* The .aent and .ent directives.  */
static void
s3_s_score_ent (int aent)
{
  symbolS *symbolP;
  int maybe_text;

  symbolP = s3_get_symbol ();
  if (*input_line_pointer == ',')
    ++input_line_pointer;
  SKIP_WHITESPACE ();
  if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')
    s3_get_number ();

#ifdef BFD_ASSEMBLER
  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    maybe_text = 1;
  else
    maybe_text = 0;
#else
  if (now_seg != data_section && now_seg != bss_section)
    maybe_text = 1;
  else
    maybe_text = 0;
#endif
  if (!maybe_text)
    as_warn (_(".ent or .aent not in text section."));
  if (!aent && s3_cur_proc_ptr)
    as_warn (_("missing .end"));
  if (!aent)
    {
      s3_cur_proc_ptr = &s3_cur_proc;
      s3_cur_proc_ptr->reg_mask = 0xdeadbeaf;
      s3_cur_proc_ptr->reg_offset = 0xdeadbeaf;
      s3_cur_proc_ptr->fpreg_mask = 0xdeafbeaf;
      s3_cur_proc_ptr->leaf = 0xdeafbeaf;
      s3_cur_proc_ptr->frame_offset = 0xdeafbeaf;
      s3_cur_proc_ptr->frame_reg = 0xdeafbeaf;
      s3_cur_proc_ptr->pc_reg = 0xdeafbeaf;
      s3_cur_proc_ptr->isym = symbolP;
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
      ++s3_numprocs;
      if (debug_type == DEBUG_STABS)
        stabs_generate_asm_func (S_GET_NAME (symbolP), S_GET_NAME (symbolP));
    }
  demand_empty_rest_of_line ();
}

static void
s3_s_score_frame (int ignore ATTRIBUTE_UNUSED)
{
  char *backupstr;
  char str[30];
  long val;
  int i = 0;

  backupstr = input_line_pointer;

#ifdef OBJ_ELF
  if (s3_cur_proc_ptr == (s3_procS *) NULL)
    {
      as_warn (_(".frame outside of .ent"));
      demand_empty_rest_of_line ();
      return;
    }
  s3_cur_proc_ptr->frame_reg = s3_reg_required_here ((&backupstr), 0, s3_REG_TYPE_SCORE);
  SKIP_WHITESPACE ();
  s3_skip_past_comma (&backupstr);
  while (*backupstr != ',')
    {
      str[i] = *backupstr;
      i++;
      backupstr++;
    }
  str[i] = '\0';
  val = atoi (str);

  SKIP_WHITESPACE ();
  s3_skip_past_comma (&backupstr);
  s3_cur_proc_ptr->frame_offset = val;
  s3_cur_proc_ptr->pc_reg = s3_reg_required_here ((&backupstr), 0, s3_REG_TYPE_SCORE);

  SKIP_WHITESPACE ();
  s3_skip_past_comma (&backupstr);
  i = 0;
  while (*backupstr != '\n')
    {
      str[i] = *backupstr;
      i++;
      backupstr++;
    }
  str[i] = '\0';
  val = atoi (str);
  s3_cur_proc_ptr->leaf = val;
  SKIP_WHITESPACE ();
  s3_skip_past_comma (&backupstr);

#endif /* OBJ_ELF */
  while (input_line_pointer != backupstr)
    input_line_pointer++;
}

/* The .end directive.  */
static void
s3_s_score_end (int x ATTRIBUTE_UNUSED)
{
  symbolS *p;
  int maybe_text;

  /* Generate a .pdr section.  */
  segT saved_seg = now_seg;
  subsegT saved_subseg = now_subseg;
  expressionS exp;
  char *fragp;

  if (!is_end_of_line[(unsigned char)*input_line_pointer])
    {
      p = s3_get_symbol ();
      demand_empty_rest_of_line ();
    }
  else
    p = NULL;

#ifdef BFD_ASSEMBLER
  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    maybe_text = 1;
  else
    maybe_text = 0;
#else
  if (now_seg != data_section && now_seg != bss_section)
    maybe_text = 1;
  else
    maybe_text = 0;
#endif

  if (!maybe_text)
    as_warn (_(".end not in text section"));
  if (!s3_cur_proc_ptr)
    {
      as_warn (_(".end directive without a preceding .ent directive."));
      demand_empty_rest_of_line ();
      return;
    }
  if (p != NULL)
    {
      gas_assert (S_GET_NAME (p));
      if (strcmp (S_GET_NAME (p), S_GET_NAME (s3_cur_proc_ptr->isym)))
        as_warn (_(".end symbol does not match .ent symbol."));
      if (debug_type == DEBUG_STABS)
        stabs_generate_asm_endfunc (S_GET_NAME (p), S_GET_NAME (p));
    }
  else
    as_warn (_(".end directive missing or unknown symbol"));

  if ((s3_cur_proc_ptr->reg_mask == 0xdeadbeaf) ||
      (s3_cur_proc_ptr->reg_offset == 0xdeadbeaf) ||
      (s3_cur_proc_ptr->leaf == 0xdeafbeaf) ||
      (s3_cur_proc_ptr->frame_offset == 0xdeafbeaf) ||
      (s3_cur_proc_ptr->frame_reg == 0xdeafbeaf) || (s3_cur_proc_ptr->pc_reg == 0xdeafbeaf));

  else
    {
      (void) frag_now_fix ();
      gas_assert (s3_pdr_seg);
      subseg_set (s3_pdr_seg, 0);
      /* Write the symbol.  */
      exp.X_op = O_symbol;
      exp.X_add_symbol = p;
      exp.X_add_number = 0;
      emit_expr (&exp, 4);
      fragp = frag_more (7 * 4);
      md_number_to_chars (fragp, (valueT) s3_cur_proc_ptr->reg_mask, 4);
      md_number_to_chars (fragp + 4, (valueT) s3_cur_proc_ptr->reg_offset, 4);
      md_number_to_chars (fragp + 8, (valueT) s3_cur_proc_ptr->fpreg_mask, 4);
      md_number_to_chars (fragp + 12, (valueT) s3_cur_proc_ptr->leaf, 4);
      md_number_to_chars (fragp + 16, (valueT) s3_cur_proc_ptr->frame_offset, 4);
      md_number_to_chars (fragp + 20, (valueT) s3_cur_proc_ptr->frame_reg, 4);
      md_number_to_chars (fragp + 24, (valueT) s3_cur_proc_ptr->pc_reg, 4);
      subseg_set (saved_seg, saved_subseg);

    }
  s3_cur_proc_ptr = NULL;
}

/* Handle the .set pseudo-op.  */
static void
s3_s_score_set (int x ATTRIBUTE_UNUSED)
{
  int i = 0;
  char name[s3_MAX_LITERAL_POOL_SIZE];
  char * orig_ilp = input_line_pointer;

  while (!is_end_of_line[(unsigned char)*input_line_pointer])
    {
      name[i] = (char) * input_line_pointer;
      i++;
      ++input_line_pointer;
    }

  name[i] = '\0';

  if (strcmp (name, "nwarn") == 0)
    {
      s3_warn_fix_data_dependency = 0;
    }
  else if (strcmp (name, "fixdd") == 0)
    {
      s3_fix_data_dependency = 1;
    }
  else if (strcmp (name, "nofixdd") == 0)
    {
      s3_fix_data_dependency = 0;
    }
  else if (strcmp (name, "r1") == 0)
    {
      s3_nor1 = 0;
    }
  else if (strcmp (name, "nor1") == 0)
    {
      s3_nor1 = 1;
    }
  else if (strcmp (name, "optimize") == 0)
    {
      s3_g_opt = 1;
    }
  else if (strcmp (name, "volatile") == 0)
    {
      s3_g_opt = 0;
    }
  else if (strcmp (name, "pic") == 0)
    {
      s3_score_pic = s3_PIC;
    }
  else
    {
      input_line_pointer = orig_ilp;
      s_set (0);
    }
}

/* Handle the .cpload pseudo-op.  This is used when generating s3_PIC code.  It sets the
   $gp register for the function based on the function address, which is in the register
   named in the argument. This uses a relocation against GP_DISP_LABEL, which is handled
   specially by the linker.  The result is:
   ldis gp, %hi(GP_DISP_LABEL)
   ori  gp, %low(GP_DISP_LABEL)
   add  gp, gp, .cpload argument
   The .cpload argument is normally r29.  */
static void
s3_s_score_cpload (int ignore ATTRIBUTE_UNUSED)
{
  int reg;
  char insn_str[s3_MAX_LITERAL_POOL_SIZE];

  /* If we are not generating s3_PIC code, .cpload is ignored.  */
  if (s3_score_pic == s3_NO_PIC)
    {
      s_ignore (0);
      return;
    }

  if ((reg = s3_reg_required_here (&input_line_pointer, -1, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
    return;

  demand_empty_rest_of_line ();

  sprintf (insn_str, "ld_i32hi r%d, %s", s3_GP, GP_DISP_LABEL);
  if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)
    return;

  sprintf (insn_str, "ld_i32lo r%d, %s", s3_GP, GP_DISP_LABEL);
  if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)
    return;

  sprintf (insn_str, "add r%d, r%d, r%d", s3_GP, s3_GP, reg);
  if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)
    return;
}

/* Handle the .cprestore pseudo-op.  This stores $gp into a given
   offset from $sp.  The offset is remembered, and after making a s3_PIC
   call $gp is restored from that location.  */
static void
s3_s_score_cprestore (int ignore ATTRIBUTE_UNUSED)
{
  int reg;
  int cprestore_offset;
  char insn_str[s3_MAX_LITERAL_POOL_SIZE];

  /* If we are not generating s3_PIC code, .cprestore is ignored.  */
  if (s3_score_pic == s3_NO_PIC)
    {
      s_ignore (0);
      return;
    }

  if ((reg = s3_reg_required_here (&input_line_pointer, -1, s3_REG_TYPE_SCORE)) == (int) s3_FAIL
      || s3_skip_past_comma (&input_line_pointer) == (int) s3_FAIL)
    {
      return;
    }

  cprestore_offset = get_absolute_expression ();

  if (cprestore_offset <= 0x3fff)
    {
      sprintf (insn_str, "sw r%d, [r%d, %d]", s3_GP, reg, cprestore_offset);
      if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)
        return;
    }
  else
    {
      int r1_bak;

      r1_bak = s3_nor1;
      s3_nor1 = 0;

      sprintf (insn_str, "li r1, %d", cprestore_offset);
      if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)
        return;

      sprintf (insn_str, "add r1, r1, r%d", reg);
      if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)
        return;

      sprintf (insn_str, "sw r%d, [r1]", s3_GP);
      if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)
        return;

      s3_nor1 = r1_bak;
    }

  demand_empty_rest_of_line ();
}

/* Handle the .gpword pseudo-op.  This is used when generating s3_PIC
   code.  It generates a 32 bit s3_GP relative reloc.  */
static void
s3_s_score_gpword (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;
  char *p;

  /* When not generating s3_PIC code, this is treated as .word.  */
  if (s3_score_pic == s3_NO_PIC)
    {
      cons (4);
      return;
    }
  expression (&ex);
  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad (_("Unsupported use of .gpword"));
      ignore_rest_of_line ();
    }
  p = frag_more (4);
  s3_md_number_to_chars (p, (valueT) 0, 4);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, FALSE, BFD_RELOC_GPREL32);
  demand_empty_rest_of_line ();
}

/* Handle the .cpadd pseudo-op.  This is used when dealing with switch
   tables in s3_PIC code.  */
static void
s3_s_score_cpadd (int ignore ATTRIBUTE_UNUSED)
{
  int reg;
  char insn_str[s3_MAX_LITERAL_POOL_SIZE];

  /* If we are not generating s3_PIC code, .cpload is ignored.  */
  if (s3_score_pic == s3_NO_PIC)
    {
      s_ignore (0);
      return;
    }

  if ((reg = s3_reg_required_here (&input_line_pointer, -1, s3_REG_TYPE_SCORE)) == (int) s3_FAIL)
    {
      return;
    }
  demand_empty_rest_of_line ();

  /* Add $gp to the register named as an argument.  */
  sprintf (insn_str, "add r%d, r%d, r%d", reg, reg, s3_GP);
  if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)
    return;
}

#ifndef TC_IMPLICIT_LCOMM_ALIGNMENT
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)	\
  do							\
    {							\
      if ((SIZE) >= 8)					\
	(P2VAR) = 3;					\
      else if ((SIZE) >= 4)				\
	(P2VAR) = 2;					\
      else if ((SIZE) >= 2)				\
	(P2VAR) = 1;					\
      else						\
	(P2VAR) = 0;					\
    }							\
  while (0)
#endif

static void
s3_s_score_lcomm (int bytes_p)
{
  char *name;
  char c;
  char *p;
  int temp;
  symbolS *symbolP;
  segT current_seg = now_seg;
  subsegT current_subseg = now_subseg;
  const int max_alignment = 15;
  int align = 0;
  segT bss_seg = bss_section;
  int needs_align = 0;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();

  /* Accept an optional comma after the name.  The comma used to be
     required, but Irix 5 cc does not generate it.  */
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
    }

  if (is_end_of_line[(unsigned char)*input_line_pointer])
    {
      as_bad (_("missing size expression"));
      return;
    }

  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_("BSS length (%d) < 0 ignored"), temp);
      ignore_rest_of_line ();
      return;
    }

#if defined (TC_SCORE)
  if (OUTPUT_FLAVOR == bfd_target_ecoff_flavour || OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      /* For Score and Alpha ECOFF or ELF, small objects are put in .sbss.  */
      if ((unsigned)temp <= bfd_get_gp_size (stdoutput))
        {
          bss_seg = subseg_new (".sbss", 1);
          seg_info (bss_seg)->bss = 1;
#ifdef BFD_ASSEMBLER
          if (!bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
            as_warn (_("error setting flags for \".sbss\": %s"), bfd_errmsg (bfd_get_error ()));
#endif
        }
    }
#endif

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (is_end_of_line[(unsigned char)*input_line_pointer])
        {
          as_bad (_("missing alignment"));
          return;
        }
      else
        {
          align = get_absolute_expression ();
          needs_align = 1;
        }
    }

  if (!needs_align)
    {
      TC_IMPLICIT_LCOMM_ALIGNMENT (temp, align);

      /* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
      if (align)
        record_alignment (bss_seg, align);
    }

  if (needs_align)
    {
      if (bytes_p)
        {
          /* Convert to a power of 2.  */
          if (align != 0)
            {
              unsigned int i;

              for (i = 0; align != 0; align >>= 1, ++i)
                ;
              align = i - 1;
            }
        }

      if (align > max_alignment)
        {
          align = max_alignment;
          as_warn (_("alignment too large; %d assumed"), align);
        }
      else if (align < 0)
        {
          align = 0;
          as_warn (_("alignment negative; 0 assumed"));
        }

      record_alignment (bss_seg, align);
    }
  else
    {
      /* Assume some objects may require alignment on some systems.  */
#if defined (TC_ALPHA) && ! defined (VMS)
      if (temp > 1)
        {
          align = ffs (temp) - 1;
          if (temp % (1 << align))
            abort ();
        }
#endif
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT)	\
     || defined (OBJ_BOUT) || defined (OBJ_MAYBE_BOUT))
#ifdef BFD_ASSEMBLER
      (OUTPUT_FLAVOR != bfd_target_aout_flavour
       || (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0)) &&
#else
      (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0) &&
#endif
#endif
      (S_GET_SEGMENT (symbolP) == bss_seg || (!S_IS_DEFINED (symbolP) && S_GET_VALUE (symbolP) == 0)))
    {
      char *pfrag;

      subseg_set (bss_seg, 1);

      if (align)
        frag_align (align, 0, 0);

      /* Detach from old frag.  */
      if (S_GET_SEGMENT (symbolP) == bss_seg)
        symbol_get_frag (symbolP)->fr_symbol = NULL;

      symbol_set_frag (symbolP, frag_now);
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, (offsetT) temp, NULL);
      *pfrag = 0;


      S_SET_SEGMENT (symbolP, bss_seg);

#ifdef OBJ_COFF
      /* The symbol may already have been created with a preceding
         ".globl" directive -- be careful not to step on storage class
         in that case.  Otherwise, set it to static.  */
      if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
        {
          S_SET_STORAGE_CLASS (symbolP, C_STAT);
        }
#endif /* OBJ_COFF */

#ifdef S_SET_SIZE
      S_SET_SIZE (symbolP, temp);
#endif
    }
  else
    as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));

  subseg_set (current_seg, current_subseg);

  demand_empty_rest_of_line ();
}

static void
s3_insert_reg (const struct s3_reg_entry *r, struct hash_control *htab)
{
  int i = 0;
  int len = strlen (r->name) + 2;
  char *buf = xmalloc (len);
  char *buf2 = xmalloc (len);

  strcpy (buf + i, r->name);
  for (i = 0; buf[i]; i++)
    {
      buf2[i] = TOUPPER (buf[i]);
    }
  buf2[i] = '\0';

  hash_insert (htab, buf, (void *) r);
  hash_insert (htab, buf2, (void *) r);
}

static void
s3_build_reg_hsh (struct s3_reg_map *map)
{
  const struct s3_reg_entry *r;

  if ((map->htab = hash_new ()) == NULL)
    {
      as_fatal (_("virtual memory exhausted"));
    }
  for (r = map->names; r->name != NULL; r++)
    {
      s3_insert_reg (r, map->htab);
    }
}

/* Iterate over the base tables to create the instruction patterns.  */
static void
s3_build_score_ops_hsh (void)
{
  unsigned int i;
  static struct obstack insn_obstack;

  obstack_begin (&insn_obstack, 4000);
  for (i = 0; i < sizeof (s3_score_insns) / sizeof (struct s3_asm_opcode); i++)
    {
      const struct s3_asm_opcode *insn = s3_score_insns + i;
      unsigned len = strlen (insn->template_name);
      struct s3_asm_opcode *new_opcode;
      char *template_name;
      new_opcode = (struct s3_asm_opcode *)
	obstack_alloc (&insn_obstack, sizeof (struct s3_asm_opcode));
      template_name = (char *) obstack_alloc (& insn_obstack, len + 1);

      strcpy (template_name, insn->template_name);
      new_opcode->template_name = template_name;
      new_opcode->parms = insn->parms;
      new_opcode->value = insn->value;
      new_opcode->relax_value = insn->relax_value;
      new_opcode->type = insn->type;
      new_opcode->bitmask = insn->bitmask;
      hash_insert (s3_score_ops_hsh, new_opcode->template_name,
                   (void *) new_opcode);
    }
}

static void
s3_build_dependency_insn_hsh (void)
{
  unsigned int i;
  static struct obstack dependency_obstack;

  obstack_begin (&dependency_obstack, 4000);
  for (i = 0; i < sizeof (s3_insn_to_dependency_table) / sizeof (s3_insn_to_dependency_table[0]); i++)
    {
      const struct s3_insn_to_dependency *tmp = s3_insn_to_dependency_table + i;
      unsigned len = strlen (tmp->insn_name);
      struct s3_insn_to_dependency *new_i2n;

      new_i2n = (struct s3_insn_to_dependency *)
	obstack_alloc (&dependency_obstack,
		       sizeof (struct s3_insn_to_dependency));
      new_i2n->insn_name = (char *) obstack_alloc (&dependency_obstack,
                                                   len + 1);

      strcpy (new_i2n->insn_name, tmp->insn_name);
      new_i2n->type = tmp->type;
      hash_insert (s3_dependency_insn_hsh, new_i2n->insn_name,
                   (void *) new_i2n);
    }
}

static void
s_score_bss (int ignore ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_bss (ignore);
  else
    return s7_s_score_bss (ignore);
}

static void
s_score_text (int ignore)
{
  if (score3)
    return s3_s_score_text (ignore);
  else
    return s7_s_score_text (ignore);
}

static void
s_section (int ignore)
{
  if (score3)
    return s3_score_s_section (ignore);
  else
    return s7_s_section (ignore);
}

static void
s_change_sec (int sec)
{
  if (score3)
    return s3_s_change_sec (sec);
  else
    return s7_s_change_sec (sec);
}

static void
s_score_mask (int reg_type ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_mask (reg_type);
  else
    return s7_s_score_mask (reg_type);
}

static void
s_score_ent (int aent)
{
  if (score3)
    return s3_s_score_ent (aent);
  else
    return s7_s_score_ent (aent);
}

static void
s_score_frame (int ignore ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_frame (ignore);
  else
    return s7_s_score_frame (ignore);
}

static void
s_score_end (int x ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_end (x);
  else
    return s7_s_score_end (x);
}

static void
s_score_set (int x ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_set (x);
  else
    return s7_s_score_set (x);
}

static void
s_score_cpload (int ignore ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_cpload (ignore);
  else
    return s7_s_score_cpload (ignore);
}

static void
s_score_cprestore (int ignore ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_cprestore (ignore);
  else
    return s7_s_score_cprestore (ignore);
}

static void
s_score_gpword (int ignore ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_gpword (ignore);
  else
    return s7_s_score_gpword (ignore);
}

static void
s_score_cpadd (int ignore ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_s_score_cpadd (ignore);
  else
    return s7_s_score_cpadd (ignore);
}

static void
s_score_lcomm (int bytes_p)
{
  if (score3)
    return s3_s_score_lcomm (bytes_p);
  else
    return s7_s_score_lcomm (bytes_p);
}

static void
s3_assemble (char *str)
{
  know (str);
  know (strlen (str) < s3_MAX_LITERAL_POOL_SIZE);

  memset (&s3_inst, '\0', sizeof (s3_inst));
  if (s3_INSN_IS_PCE_P (str))
    s3_parse_pce_inst (str);
  else if (s3_INSN_IS_48_P (str))
    s3_parse_48_inst (str, TRUE);
  else
    s3_parse_16_32_inst (str, TRUE);

  if (s3_inst.error)
    as_bad (_("%s -- `%s'"), s3_inst.error, s3_inst.str);
}

static void
s3_operand (expressionS * exp)
{
  if (s3_in_my_get_expression)
    {
      exp->X_op = O_illegal;
      if (s3_inst.error == NULL)
        {
          s3_inst.error = _("bad expression");
        }
    }
}

static void
s3_begin (void)
{
  unsigned int i;
  segT seg;
  subsegT subseg;

  if ((s3_score_ops_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  s3_build_score_ops_hsh ();

  if ((s3_dependency_insn_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  s3_build_dependency_insn_hsh ();

  for (i = (int)s3_REG_TYPE_FIRST; i < (int)s3_REG_TYPE_MAX; i++)
    s3_build_reg_hsh (s3_all_reg_maps + i);

  /* Initialize dependency vector.  */
  s3_init_dependency_vector ();

  bfd_set_arch_mach (stdoutput, TARGET_ARCH, 0);
  seg = now_seg;
  subseg = now_subseg;
  s3_pdr_seg = subseg_new (".pdr", (subsegT) 0);
  (void)bfd_set_section_flags (stdoutput, s3_pdr_seg, SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);
  (void)bfd_set_section_alignment (stdoutput, s3_pdr_seg, 2);
  subseg_set (seg, subseg);

  if (s3_USE_GLOBAL_POINTER_OPT)
    bfd_set_gp_size (stdoutput, s3_g_switch_value);
}

static void
s3_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

static valueT
s3_normal_chars_to_number (char *buf, int n)
{
  valueT result = 0;
  unsigned char *where = (unsigned char *)buf;

  if (target_big_endian)
    {
      while (n--)
        {
          result <<= 8;
          result |= (*where++ & 255);
        }
    }
  else
    {
      while (n--)
        {
          result <<= 8;
          result |= (where[n] & 255);
        }
    }

  return result;
}

static void
s3_number_to_chars_littleendian (void *p, valueT data, int n)
{
  char *buf = (char *) p;

  switch (n)
    {
    case 4:
      md_number_to_chars (buf, data >> 16, 2);
      md_number_to_chars (buf + 2, data, 2);
      break;
    case 6:
      md_number_to_chars (buf, data >> 32, 2);
      md_number_to_chars (buf + 2, data >> 16, 2);
      md_number_to_chars (buf + 4, data, 2);
      break;
    default:
      /* Error routine.  */
      as_bad_where (__FILE__, __LINE__, _("size is not 4 or 6"));
      break;
    }
}

static valueT
s3_chars_to_number_littleendian (const void *p, int n)
{
  char *buf = (char *) p;
  valueT result = 0;

  switch (n)
    {
    case 4:
      result =  s3_normal_chars_to_number (buf, 2) << 16;
      result |= s3_normal_chars_to_number (buf + 2, 2);
      break;
    case 6:
      result =  s3_normal_chars_to_number (buf, 2) << 32;
      result |= s3_normal_chars_to_number (buf + 2, 2) << 16;
      result |= s3_normal_chars_to_number (buf + 4, 2);
      break;
    default:
      /* Error routine.  */
      as_bad_where (__FILE__, __LINE__, _("size is not 4 or 6"));
      break;
    }

  return result;
}

static void
s3_md_number_to_chars (char *buf, valueT val, int n)
{
  if (!target_big_endian && n >= 4)
    s3_number_to_chars_littleendian (buf, val, n);
  else
    md_number_to_chars (buf, val, n);
}

static valueT
s3_md_chars_to_number (char *buf, int n)
{
  valueT result = 0;

  if (!target_big_endian && n >= 4)
    result = s3_chars_to_number_littleendian (buf, n);
  else
    result = s3_normal_chars_to_number (buf, n);

  return result;
}

static char *
s3_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[s3_MAX_LITTLENUMS];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;
    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;
    case 'x':
    case 'X':
    case 'p':
    case 'P':
      prec = 6;
      break;
    default:
      *sizeP = 0;
      return _("bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * 2;

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
        {
          s3_md_number_to_chars (litP, (valueT) words[i], 2);
          litP += 2;
        }
    }
  else
    {
      for (i = 0; i < prec; i += 2)
        {
          s3_md_number_to_chars (litP, (valueT) words[i + 1], 2);
          s3_md_number_to_chars (litP + 2, (valueT) words[i], 2);
          litP += 4;
        }
    }

  return 0;
}

static void
s3_frag_check (fragS * fragp ATTRIBUTE_UNUSED)
{
  know (fragp->insn_addr <= s3_RELAX_PAD_BYTE);
}

static void
s3_validate_fix (fixS *fixP)
{
  fixP->fx_where += fixP->fx_frag->insn_addr;
}

static int
s3_force_relocation (struct fix *fixp)
{
  int retval = 0;

  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_SCORE_JMP
      || fixp->fx_r_type == BFD_RELOC_SCORE_BRANCH
      || fixp->fx_r_type == BFD_RELOC_SCORE16_JMP
      || fixp->fx_r_type == BFD_RELOC_SCORE16_BRANCH
      || fixp->fx_r_type == BFD_RELOC_SCORE_BCMP)
    {
      retval = 1;
    }
  return retval;
}

static bfd_boolean
s3_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_addsy == NULL)
    {
      return 1;
    }
  else if (OUTPUT_FLAVOR == bfd_target_elf_flavour
	   && (S_IS_EXTERNAL (fixP->fx_addsy) || S_IS_WEAK (fixP->fx_addsy)))
    {
      return 0;
    }
  else if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
           || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
           || fixP->fx_r_type == BFD_RELOC_SCORE_JMP
           || fixP->fx_r_type == BFD_RELOC_SCORE16_JMP)
    {
      return 0;
    }

  return 1;
}

static void
s3_elf_final_processing (void)
{
  unsigned long val = 0;

  if (score3)
    val = E_SCORE_MACH_SCORE3;
  else if (score7)
    val = E_SCORE_MACH_SCORE7;

  elf_elfheader (stdoutput)->e_machine = EM_SCORE;
  elf_elfheader (stdoutput)->e_flags &= ~EF_SCORE_MACH;
  elf_elfheader (stdoutput)->e_flags |= val;

  if (s3_fix_data_dependency == 1)
    {
      elf_elfheader (stdoutput)->e_flags |= EF_SCORE_FIXDEP;
    }
  if (s3_score_pic == s3_PIC)
    {
      elf_elfheader (stdoutput)->e_flags |= EF_SCORE_PIC;
    }
}

static int
s3_judge_size_before_relax (fragS * fragp, asection *sec)
{
  int change = 0;

  if (s3_score_pic == s3_NO_PIC)
    change = s3_nopic_need_relax (fragp->fr_symbol, 0);
  else
    change = s3_pic_need_relax (fragp->fr_symbol, sec);

  if (change == 1)
    {
      /* Only at the first time determining whether s3_GP instruction relax should be done,
         return the difference between insntruction size and instruction relax size.  */
      if (fragp->fr_opcode == NULL)
	{
	  fragp->fr_fix = s3_RELAX_NEW (fragp->fr_subtype);
	  fragp->fr_opcode = fragp->fr_literal + s3_RELAX_RELOC1 (fragp->fr_subtype);
          return s3_RELAX_NEW (fragp->fr_subtype) - s3_RELAX_OLD (fragp->fr_subtype);
	}
    }

  return 0;
}

static int
s3_estimate_size_before_relax (fragS * fragp, asection * sec ATTRIBUTE_UNUSED)
{
  if ((s3_RELAX_TYPE (fragp->fr_subtype) == Insn_GP)
      || (s3_RELAX_TYPE (fragp->fr_subtype) == Insn_PIC))
    return s3_judge_size_before_relax (fragp, sec);

  return 0;
}

static int
s3_relax_branch_inst32 (fragS * fragp)
{
  fragp->fr_opcode = NULL;
  return 0;
}

static int
s3_relax_branch_inst16 (fragS * fragp)
{
  int relaxable_p = 0;
  int frag_addr = fragp->fr_address + fragp->insn_addr;
  addressT symbol_address = 0;
  symbolS *s;
  offsetT offset;
  long value;
  unsigned long inst_value;

  relaxable_p = s3_RELAX_OPT (fragp->fr_subtype);

  s = fragp->fr_symbol;
  if (s == NULL)
    frag_addr = 0;
  else
    {
      if (s->bsym != 0)
        symbol_address = (addressT) s->sy_frag->fr_address;
    }

  inst_value = s3_md_chars_to_number (fragp->fr_literal, s3_INSN16_SIZE);
  offset = (inst_value & 0x1ff) << 1;
  if ((offset & 0x200) == 0x200)
    offset |= 0xfffffc00;

  value = offset + symbol_address - frag_addr;

  if (relaxable_p
      && (!((value & 0xfffffe00) == 0 || (value & 0xfffffe00) == 0xfffffe00))
      && fragp->fr_fix == 2
      && (s->bsym != NULL)
      && (S_IS_DEFINED (s)
          && !S_IS_COMMON (s)
          && !S_IS_EXTERNAL (s)))
    {
      /* Relax branch 32 to branch 16.  */
      fragp->fr_opcode = fragp->fr_literal + s3_RELAX_RELOC1 (fragp->fr_subtype);
      fragp->fr_fix = 4;
      return 2;
    }
  else
    return 0;
}

static int
s3_relax_cmpbranch_inst32 (fragS * fragp)
{
  int relaxable_p = 0;
  symbolS *s;
  /* For sign bit.  */
  long offset;
  long frag_addr = fragp->fr_address + fragp->insn_addr;
  long symbol_address = 0;
  long value;
  unsigned long inst_value;

  relaxable_p = s3_RELAX_OPT (fragp->fr_subtype);

  s = fragp->fr_symbol;
  if (s == NULL)
    frag_addr = 0;
  else
    {
      if (s->bsym != 0)
        symbol_address = (addressT) s->sy_frag->fr_address;
    }

  inst_value = s3_md_chars_to_number (fragp->fr_literal, s3_INSN_SIZE);
  offset = (inst_value & 0x1)
    | (((inst_value >> 7) & 0x7) << 1)
    | (((inst_value >> 21) & 0x1f) << 4);
  offset <<= 1;
  if ((offset & 0x200) == 0x200)
    offset |= 0xfffffe00;

  value = offset + symbol_address - frag_addr;
  /* change the order of judging rule is because
     1.not defined symbol or common sysbol or external symbol will change
     bcmp to cmp!+beq/bne ,here need to record fragp->fr_opcode
     2.if the flow is as before : it will results to recursive loop
  */
  if (fragp->fr_fix == 6)
    {
      /* Have already relaxed!  Just return 0 to terminate the loop.  */
      return 0;
    }
  /* need to translate when extern or not defind or common sysbol */
  else if ((relaxable_p
	    && (!((value & 0xfffffe00) == 0 || (value & 0xfffffe00) == 0xfffffe00))
	    && fragp->fr_fix == 4
	    && (s->bsym != NULL))
	   || !S_IS_DEFINED (s)
	   ||S_IS_COMMON (s)
	   ||S_IS_EXTERNAL (s))
    {
      fragp->fr_opcode = fragp->fr_literal + s3_RELAX_RELOC1 (fragp->fr_subtype);
      fragp->fr_fix = 6;
      return 2;
    }
  else
    {
      /* Never relax.  Modify fr_opcode to NULL to verify it's value in
         md_apply_fix.  */
      fragp->fr_opcode = NULL;
      return 0;
    }
}


static int
s3_relax_other_inst32 (fragS * fragp)
{
  int relaxable_p = s3_RELAX_OPT (fragp->fr_subtype);

  if (relaxable_p
      && fragp->fr_fix == 4)
    {
      fragp->fr_opcode = fragp->fr_literal + s3_RELAX_RELOC1 (fragp->fr_subtype);
      fragp->fr_fix = 2;
      return -2;
    }
  else
    return 0;
}

static int
s3_relax_gp_and_pic_inst32 (void)
{
  /* md_estimate_size_before_relax has already relaxed s3_GP and s3_PIC
     instructions.  We don't change relax size here.  */
  return 0;
}

static int
s3_relax_frag (asection * sec ATTRIBUTE_UNUSED, fragS * fragp, long stretch ATTRIBUTE_UNUSED)
{
  int grows = 0;
  int adjust_align_p = 0;

  /* If the instruction address is odd, make it half word align first.  */
  if ((fragp->fr_address) % 2 != 0)
    {
      if ((fragp->fr_address + fragp->insn_addr) % 2 != 0)
	{
          fragp->insn_addr = 1;
          grows += 1;
          adjust_align_p = 1;
	}
    }

  switch (s3_RELAX_TYPE (fragp->fr_subtype))
    {
    case PC_DISP19div2:
      grows += s3_relax_branch_inst32 (fragp);
      break;

    case PC_DISP8div2:
      grows += s3_relax_branch_inst16 (fragp);
      break;

    case Insn_BCMP :
      grows += s3_relax_cmpbranch_inst32 (fragp);
      break;

    case Insn_GP:
    case Insn_PIC:
      grows += s3_relax_gp_and_pic_inst32 ();
      break;

    default:
      grows += s3_relax_other_inst32 (fragp);
      break;
    }

  /* newly added */
  if (adjust_align_p && fragp->insn_addr)
    {
      fragp->fr_fix += fragp->insn_addr;
    }

  return grows;
}

static void
s3_convert_frag (bfd * abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED, fragS * fragp)
{
  int r_old;
  int r_new;
  char backup[20];
  fixS *fixp;

  r_old = s3_RELAX_OLD (fragp->fr_subtype);
  r_new = s3_RELAX_NEW (fragp->fr_subtype);

  /* fragp->fr_opcode indicates whether this frag should be relaxed.  */
  if (fragp->fr_opcode == NULL)
    {
      memcpy (backup, fragp->fr_literal, r_old);
      fragp->fr_fix = r_old;
    }
  else
    {
      memcpy (backup, fragp->fr_literal + r_old, r_new);
      fragp->fr_fix = r_new;
    }

  fixp = fragp->tc_frag_data.fixp;
  while (fixp && fixp->fx_frag == fragp && fixp->fx_where < r_old)
    {
      if (fragp->fr_opcode)
	fixp->fx_done = 1;
      fixp = fixp->fx_next;
    }
  while (fixp && fixp->fx_frag == fragp)
    {
      if (fragp->fr_opcode)
	fixp->fx_where -= r_old + fragp->insn_addr;
      else
	fixp->fx_done = 1;
      fixp = fixp->fx_next;
    }

  if (fragp->insn_addr)
    {
      s3_md_number_to_chars (fragp->fr_literal, 0x0, fragp->insn_addr);
    }
  memcpy (fragp->fr_literal + fragp->insn_addr, backup, fragp->fr_fix);
  fragp->fr_fix += fragp->insn_addr;
}

static long
s3_pcrel_from (fixS * fixP)
{
  long retval = 0;

  if (fixP->fx_addsy
      && (S_GET_SEGMENT (fixP->fx_addsy) == undefined_section)
      && (fixP->fx_subsy == NULL))
    {
      retval = 0;
    }
  else
    {
      retval = fixP->fx_where + fixP->fx_frag->fr_address;
    }

  return retval;
}

static valueT
s3_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}

static void
s3_apply_fix (fixS *fixP, valueT *valP, segT seg)
{
  offsetT value = *valP;
  offsetT newval;
  offsetT content;
  unsigned short HI, LO;

  char *buf = fixP->fx_frag->fr_literal + fixP->fx_where;

  gas_assert (fixP->fx_r_type < BFD_RELOC_UNUSED);
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
    {
      if (fixP->fx_r_type != BFD_RELOC_SCORE_DUMMY_HI16)
        fixP->fx_done = 1;
    }

  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo it's effects here.  */
  if (fixP->fx_pcrel)
    {
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
    }

  /* Remember value for emit_reloc.  */
  fixP->fx_addnumber = value;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_HI16_S:
      if (fixP->fx_done)        /* For la rd, imm32.  */
        {
          newval = s3_md_chars_to_number (buf, s3_INSN_SIZE);
          HI = (value) >> 16;   /* mul to 2, then take the hi 16 bit.  */
          newval |= (HI & 0x3fff) << 1;
          newval |= ((HI >> 14) & 0x3) << 16;
          s3_md_number_to_chars (buf, newval, s3_INSN_SIZE);
        }
      break;
    case BFD_RELOC_LO16:
      if (fixP->fx_done)        /* For la rd, imm32.  */
        {
          newval = s3_md_chars_to_number (buf, s3_INSN_SIZE);
          LO = (value) & 0xffff;
          newval |= (LO & 0x3fff) << 1; /* 16 bit: imm -> 14 bit in lo, 2 bit in hi.  */
          newval |= ((LO >> 14) & 0x3) << 16;
          s3_md_number_to_chars (buf, newval, s3_INSN_SIZE);
        }
      break;
    case BFD_RELOC_SCORE_JMP:
      {
        content = s3_md_chars_to_number (buf, s3_INSN_SIZE);
        value = fixP->fx_offset;
        content = (content & ~0x3ff7ffe) | ((value << 1) & 0x3ff0000) | (value & 0x7fff);
        s3_md_number_to_chars (buf, content, s3_INSN_SIZE);
      }
      break;

    case BFD_RELOC_SCORE_IMM30:
      {
        content = s3_md_chars_to_number (buf, s3_INSN48_SIZE);
        value = fixP->fx_offset;
        value >>= 2;
        content = (content & ~0x7f7fff7f80LL)
	  | (((value & 0xff) >> 0) << 7)
	  | (((value & 0x7fff00) >> 8) << 16)
	  | (((value & 0x3f800000) >> 23) << 32);
        s3_md_number_to_chars (buf, content, s3_INSN48_SIZE);
        break;
      }

    case BFD_RELOC_SCORE_IMM32:
      {
        content = s3_md_chars_to_number (buf, s3_INSN48_SIZE);
        value = fixP->fx_offset;
        content = (content & ~0x7f7fff7fe0LL)
	  | ((value & 0x3ff) << 5)
	  | (((value >> 10) & 0x7fff) << 16)
	  | (((value >> 25) & 0x7f) << 32);
        s3_md_number_to_chars (buf, content, s3_INSN48_SIZE);
        break;
      }

    case BFD_RELOC_SCORE_BRANCH:
      if ((S_GET_SEGMENT (fixP->fx_addsy) != seg) || (fixP->fx_addsy != NULL && S_IS_EXTERNAL (fixP->fx_addsy)))
        value = fixP->fx_offset;
      else
        fixP->fx_done = 1;

      content = s3_md_chars_to_number (buf, s3_INSN_SIZE);

      /* Don't check c-bit.  */
      if (fixP->fx_frag->fr_opcode != 0)
        {
          if ((value & 0xfffffe00) != 0 && (value & 0xfffffe00) != 0xfffffe00)
            {
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x) [-2^9 ~ 2^9]"), (unsigned int)value);
              return;
            }
          content = s3_md_chars_to_number (buf, s3_INSN16_SIZE);
          content &= 0xfe00;
          content = (content & 0xfe00) | ((value >> 1) & 0x1ff);
          s3_md_number_to_chars (buf, content, s3_INSN16_SIZE);
          fixP->fx_r_type = BFD_RELOC_SCORE16_BRANCH;
          fixP->fx_size = 2;
        }
      else
        {
          if ((value & 0xfff80000) != 0 && (value & 0xfff80000) != 0xfff80000)
            {
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x) [-2^19 ~ 2^19]"), (unsigned int)value);
              return;
            }
          content = s3_md_chars_to_number (buf, s3_INSN_SIZE);
          content &= 0xfc00fc01;
          content = (content & 0xfc00fc01) | (value & 0x3fe) | ((value << 6) & 0x3ff0000);
          s3_md_number_to_chars (buf, content, s3_INSN_SIZE);
        }
      break;
    case BFD_RELOC_SCORE16_JMP:
      content = s3_md_chars_to_number (buf, s3_INSN16_SIZE);
      content &= 0xf001;
      value = fixP->fx_offset & 0xfff;
      content = (content & 0xfc01) | (value & 0xffe);
      s3_md_number_to_chars (buf, content, s3_INSN16_SIZE);
      break;
    case BFD_RELOC_SCORE16_BRANCH:
      content = s3_md_chars_to_number (buf, s3_INSN_SIZE);
      /* Don't check c-bit.  */
      if (fixP->fx_frag->fr_opcode != 0)
        {
          if ((S_GET_SEGMENT (fixP->fx_addsy) != seg) ||
              (fixP->fx_addsy != NULL && S_IS_EXTERNAL (fixP->fx_addsy)))
            value = fixP->fx_offset;
          else
            fixP->fx_done = 1;
          if ((value & 0xfff80000) != 0 && (value & 0xfff80000) != 0xfff80000)
            {
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x) [-2^19 ~ 2^19]"), (unsigned int)value);
              return;
            }
          content = s3_md_chars_to_number (buf, s3_INSN_SIZE);
          content = (content & 0xfc00fc01) | (value & 0x3fe) | ((value << 6) & 0x3ff0000);
          s3_md_number_to_chars (buf, content, s3_INSN_SIZE);
          fixP->fx_r_type = BFD_RELOC_SCORE_BRANCH;
          fixP->fx_size = 4;
          break;
        }
      else
        {
          /* In differnt section.  */
          if ((S_GET_SEGMENT (fixP->fx_addsy) != seg) ||
              (fixP->fx_addsy != NULL && S_IS_EXTERNAL (fixP->fx_addsy)))
            value = fixP->fx_offset;
          else
            fixP->fx_done = 1;

          if ((value & 0xfffffe00) != 0 && (value & 0xfffffe00) != 0xfffffe00)
            {
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x)  [-2^9 ~ 2^9]"), (unsigned int)value);
              return;
            }

          content = s3_md_chars_to_number (buf, s3_INSN16_SIZE);
          content = (content & 0xfe00) | ((value >> 1) & 0x1ff);
          s3_md_number_to_chars (buf, content, s3_INSN16_SIZE);
          break;
        }

      break;

    case BFD_RELOC_SCORE_BCMP:
      if (fixP->fx_frag->fr_opcode != 0)
        {
          char *buf_ptr = buf;
          buf_ptr += 2;

          if ((S_GET_SEGMENT (fixP->fx_addsy) != seg) || (fixP->fx_addsy != NULL && S_IS_EXTERNAL (fixP->fx_addsy)))
            value = fixP->fx_offset;
          else
            fixP->fx_done = 1;

          /* NOTE!!!
             bcmp -> cmp! and branch, so value -= 2.  */
          value -= 2;

          if ((value & 0xfff80000) != 0 && (value & 0xfff80000) != 0xfff80000)
            {
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x) [-2^19 ~ 2^19]"), (unsigned int)value);
              return;
            }

          content = s3_md_chars_to_number (buf_ptr, s3_INSN_SIZE);
          content &= 0xfc00fc01;
          content = (content & 0xfc00fc01) | (value & 0x3fe) | ((value << 6) & 0x3ff0000);
          s3_md_number_to_chars (buf_ptr, content, s3_INSN_SIZE);
          /* change relocation type to BFD_RELOC_SCORE_BRANCH */
          fixP->fx_r_type = BFD_RELOC_SCORE_BRANCH;
          fixP->fx_where+=2; /* first insn is cmp! , the second insn is beq/bne */
          break;
        }
      else
        {
          if ((S_GET_SEGMENT (fixP->fx_addsy) != seg) || (fixP->fx_addsy != NULL && S_IS_EXTERNAL (fixP->fx_addsy)))
            value = fixP->fx_offset;
          else
            fixP->fx_done = 1;

          content = s3_md_chars_to_number (buf, s3_INSN_SIZE);

          if ((value & 0xfffffe00) != 0 && (value & 0xfffffe00) != 0xfffffe00)
            {
              as_bad_where (fixP->fx_file, fixP->fx_line,
			    _(" branch relocation truncate (0x%x)  [-2^9 ~ 2^9]"), (unsigned int)value);
              return;
            }

          value >>= 1;
          content &= ~0x03e00381;
          content = content
	    | (value & 0x1)
	    | (((value & 0xe) >> 1) << 7)
	    | (((value & 0x1f0) >> 4) << 21);

          s3_md_number_to_chars (buf, content, s3_INSN_SIZE);
          break;
        }

    case BFD_RELOC_8:
      if (fixP->fx_done || fixP->fx_pcrel)
	s3_md_number_to_chars (buf, value, 1);
#ifdef OBJ_ELF
      else
        {
          value = fixP->fx_offset;
          s3_md_number_to_chars (buf, value, 1);
        }
#endif
      break;

    case BFD_RELOC_16:
      if (fixP->fx_done || fixP->fx_pcrel)
        s3_md_number_to_chars (buf, value, 2);
#ifdef OBJ_ELF
      else
        {
          value = fixP->fx_offset;
          s3_md_number_to_chars (buf, value, 2);
        }
#endif
      break;
    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
      if (fixP->fx_done || fixP->fx_pcrel)
        md_number_to_chars (buf, value, 4);
#ifdef OBJ_ELF
      else
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 4);
        }
#endif
      break;
    case BFD_RELOC_VTABLE_INHERIT:
      fixP->fx_done = 0;
      if (fixP->fx_addsy && !S_IS_DEFINED (fixP->fx_addsy) && !S_IS_WEAK (fixP->fx_addsy))
        S_SET_WEAK (fixP->fx_addsy);
      break;
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      break;
    case BFD_RELOC_SCORE_GPREL15:
      content = s3_md_chars_to_number (buf, s3_INSN_SIZE);
      /* c-bit.  */
      if ((fixP->fx_frag->fr_opcode != 0) && ((content & 0xfc1c8000) != 0x94180000))
        fixP->fx_r_type = BFD_RELOC_NONE;
      fixP->fx_done = 0;
      break;
    case BFD_RELOC_SCORE_GOT15:
    case BFD_RELOC_SCORE_DUMMY_HI16:
    case BFD_RELOC_SCORE_GOT_LO16:
    case BFD_RELOC_SCORE_CALL15:
    case BFD_RELOC_GPREL32:
      break;
    case BFD_RELOC_NONE:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line, _("bad relocation fixup type (%d)"), fixP->fx_r_type);
    }
}

static arelent **
s3_gen_reloc (asection * section ATTRIBUTE_UNUSED, fixS * fixp)
{
  static arelent *retval[MAX_RELOC_EXPANSION + 1];  /* MAX_RELOC_EXPANSION equals 2.  */
  arelent *reloc;
  bfd_reloc_code_real_type code;
  char *type;

  reloc = retval[0] = xmalloc (sizeof (arelent));
  retval[1] = NULL;

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->addend = fixp->fx_offset;

  /* If this is a variant frag, we may need to adjust the existing
     reloc and generate a new one.  */
  if (fixp->fx_frag->fr_opcode != NULL && (fixp->fx_r_type == BFD_RELOC_SCORE_GPREL15))
    {
      /* Update instruction imm bit.  */
      offsetT newval;
      unsigned short off;
      char *buf;

      buf = fixp->fx_frag->fr_literal + fixp->fx_frag->insn_addr;
      newval = s3_md_chars_to_number (buf, s3_INSN_SIZE);
      off = fixp->fx_offset >> 16;
      newval |= (off & 0x3fff) << 1;
      newval |= ((off >> 14) & 0x3) << 16;
      s3_md_number_to_chars (buf, newval, s3_INSN_SIZE);

      buf += s3_INSN_SIZE;
      newval = s3_md_chars_to_number (buf, s3_INSN_SIZE);
      off = fixp->fx_offset & 0xffff;
      newval |= ((off & 0x3fff) << 1);
      newval |= (((off >> 14) & 0x3) << 16);
      s3_md_number_to_chars (buf, newval, s3_INSN_SIZE);

      retval[1] = xmalloc (sizeof (arelent));
      retval[2] = NULL;
      retval[1]->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
      *retval[1]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      retval[1]->address = (reloc->address + s3_RELAX_RELOC2 (fixp->fx_frag->fr_subtype));

      retval[1]->addend = 0;
      retval[1]->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_LO16);
      gas_assert (retval[1]->howto != NULL);

      fixp->fx_r_type = BFD_RELOC_HI16_S;
    }

  code = fixp->fx_r_type;
  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
        {
          code = BFD_RELOC_32_PCREL;
          break;
        }
    case BFD_RELOC_HI16_S:
    case BFD_RELOC_LO16:
    case BFD_RELOC_SCORE_JMP:
    case BFD_RELOC_SCORE_BRANCH:
    case BFD_RELOC_SCORE16_JMP:
    case BFD_RELOC_SCORE16_BRANCH:
    case BFD_RELOC_SCORE_BCMP:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_SCORE_GPREL15:
    case BFD_RELOC_SCORE_GOT15:
    case BFD_RELOC_SCORE_DUMMY_HI16:
    case BFD_RELOC_SCORE_GOT_LO16:
    case BFD_RELOC_SCORE_CALL15:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_NONE:
    case BFD_RELOC_SCORE_IMM30:
    case BFD_RELOC_SCORE_IMM32:
      code = fixp->fx_r_type;
      break;
    default:
      type = _("<unknown>");
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    _("cannot represent %s relocation in this object file format"), type);
      return NULL;
    }

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    _("cannot represent %s relocation in this object file format1"),
                    bfd_get_reloc_code_name (code));
      return NULL;
    }
  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  return retval;
}

void
md_assemble (char *str)
{
  if (score3)
    s3_assemble (str);
  else
    s7_assemble (str);
}

/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expressionS * exp)
{
  if (score3)
    s3_operand (exp);
  else
    s7_operand (exp);
}

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).  */
void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (score3)
    s3_number_to_chars (buf, val, n);
  else
    s7_number_to_chars (buf, val, n);
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.

   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.  However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.  */
char *
md_atof (int type, char *litP, int *sizeP)
{
  if (score3)
    return s3_atof (type, litP, sizeP);
  else
    return s7_atof (type, litP, sizeP);
}

void
score_frag_check (fragS * fragp ATTRIBUTE_UNUSED)
{
  if (score3)
    s3_frag_check (fragp);
  else
    s7_frag_check (fragp);
}

/* Implementation of TC_VALIDATE_FIX.
   Called before md_apply_fix() and after md_convert_frag().  */
void
score_validate_fix (fixS *fixP)
{
  if (score3)
    s3_validate_fix (fixP);
  else
    s7_validate_fix (fixP);
}

int
score_force_relocation (struct fix *fixp)
{
  if (score3)
    return s3_force_relocation (fixp);
  else
    return s7_force_relocation (fixp);
}

/* Implementation of md_frag_check.
   Called after md_convert_frag().  */
bfd_boolean
score_fix_adjustable (fixS * fixP)
{
  if (score3)
    return s3_fix_adjustable (fixP);
  else
    return s7_fix_adjustable (fixP);
}

void
score_elf_final_processing (void)
{
  if (score3)
    s3_elf_final_processing ();
  else
    s7_elf_final_processing ();
}

/* In this function, we determine whether s3_GP instruction should do relaxation,
   for the label being against was known now.
   Doing this here but not in md_relax_frag() can induce iteration times
   in stage of doing relax.  */
int
md_estimate_size_before_relax (fragS * fragp, asection * sec ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_estimate_size_before_relax (fragp, sec);
  else
    return s7_estimate_size_before_relax (fragp, sec);
}

int
score_relax_frag (asection * sec ATTRIBUTE_UNUSED, fragS * fragp, long stretch ATTRIBUTE_UNUSED)
{
  if (score3)
    return s3_relax_frag (sec, fragp, stretch);
  else
    return s7_relax_frag (sec, fragp, stretch);
}

void
md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED, fragS * fragp)
{
  if (score3)
    return s3_convert_frag (abfd, sec, fragp);
  else
    return s7_convert_frag (abfd, sec, fragp);
}

long
md_pcrel_from (fixS * fixP)
{
  if (score3)
    return s3_pcrel_from (fixP);
  else
    return s7_pcrel_from (fixP);
}

/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
  if (score3)
    return s3_section_align (segment, size);
  else
    return s7_section_align (segment, size);
}

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg)
{
  if (score3)
    return s3_apply_fix (fixP, valP, seg);
  else
    return s7_apply_fix (fixP, valP, seg);
}

/* Translate internal representation of relocation info to BFD target format.  */
arelent **
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED, fixS * fixp)
{
  if (score3)
    return s3_gen_reloc (section, fixp);
  else
    return s7_gen_reloc (section, fixp);
}

void
md_begin (void)
{
  s3_begin ();
  s7_begin ();
}

static void
score_set_mach (const char *arg)
{
  if (strcmp (arg, MARCH_SCORE3) == 0)
    {
      score3 = 1;
      score7 = 0;
      s3_score3d = 1;
    }
  else if (strcmp (arg, MARCH_SCORE7) == 0)
    {
      score3 = 0;
      score7 = 1;
      s7_score7d = 1;
      s7_university_version = 0;
      s7_vector_size = s7_SCORE7_PIPELINE;
    }
  else if (strcmp (arg, MARCH_SCORE5) == 0)
    {
      score3 = 0;
      score7 = 1;
      s7_score7d = 1;
      s7_university_version = 0;
      s7_vector_size = s7_SCORE5_PIPELINE;
    }
  else if (strcmp (arg, MARCH_SCORE5U) == 0)
    {
      score3 = 0;
      score7 = 1;
      s7_score7d = 1;
      s7_university_version = 1;
      s7_vector_size = s7_SCORE5_PIPELINE;
    }
  else
    {
      as_bad (_("unknown architecture `%s'\n"), arg);
    }
}

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif
#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif
    case OPTION_FIXDD:
      s3_fix_data_dependency = 1;
      s7_fix_data_dependency = 1;
      break;
    case OPTION_NWARN:
      s3_warn_fix_data_dependency = 0;
      s7_warn_fix_data_dependency = 0;
      break;
    case OPTION_SCORE5:
      score3 = 0;
      score7 = 1;
      s7_university_version = 0;
      s7_vector_size = s7_SCORE5_PIPELINE;
      break;
    case OPTION_SCORE5U:
      score3 = 0;
      score7 = 1;
      s7_university_version = 1;
      s7_vector_size = s7_SCORE5_PIPELINE;
      break;
    case OPTION_SCORE7:
      score3 = 0;
      score7 = 1;
      s7_score7d = 1;
      s7_university_version = 0;
      s7_vector_size = s7_SCORE7_PIPELINE;
      break;
    case OPTION_SCORE3:
      score3 = 1;
      score7 = 0;
      s3_score3d = 1;
      break;
    case OPTION_R1:
      s3_nor1 = 0;
      s7_nor1 = 0;
      break;
    case 'G':
      s3_g_switch_value = atoi (arg);
      s7_g_switch_value = atoi (arg);
      break;
    case OPTION_O0:
      s3_g_opt = 0;
      s7_g_opt = 0;
      break;
    case OPTION_SCORE_VERSION:
      printf (_("Sunplus-v2-0-0-20060510\n"));
      break;
    case OPTION_PIC:
      s3_score_pic = s3_NO_PIC; /* Score3 doesn't support PIC now.  */
      s7_score_pic = s7_PIC;
      s3_g_switch_value = 0;    /* Must set -G num as 0 to generate s3_PIC code.  */
      s7_g_switch_value = 0;    /* Must set -G num as 0 to generate s7_PIC code.  */
      break;
    case OPTION_MARCH:
      score_set_mach (arg);
      break;
    default:
      return 0;
    }
  return 1;
}

void
md_show_usage (FILE * fp)
{
  fprintf (fp, _(" Score-specific assembler options:\n"));
#ifdef OPTION_EB
  fprintf (fp, _("\
        -EB\t\tassemble code for a big-endian cpu\n"));
#endif

#ifdef OPTION_EL
  fprintf (fp, _("\
        -EL\t\tassemble code for a little-endian cpu\n"));
#endif

  fprintf (fp, _("\
        -FIXDD\t\tassemble code for fix data dependency\n"));
  fprintf (fp, _("\
        -NWARN\t\tassemble code for no warning message for fix data dependency\n"));
  fprintf (fp, _("\
        -SCORE5\t\tassemble code for target is SCORE5\n"));
  fprintf (fp, _("\
        -SCORE5U\tassemble code for target is SCORE5U\n"));
  fprintf (fp, _("\
        -SCORE7\t\tassemble code for target is SCORE7, this is default setting\n"));
  fprintf (fp, _("\
        -SCORE3\t\tassemble code for target is SCORE3\n"));
  fprintf (fp, _("\
        -march=score7\tassemble code for target is SCORE7, this is default setting\n"));
  fprintf (fp, _("\
        -march=score3\tassemble code for target is SCORE3\n"));
  fprintf (fp, _("\
        -USE_R1\t\tassemble code for no warning message when using temp register r1\n"));
  fprintf (fp, _("\
        -KPIC\t\tassemble code for PIC\n"));
  fprintf (fp, _("\
        -O0\t\tassembler will not perform any optimizations\n"));
  fprintf (fp, _("\
        -G gpnum\tassemble code for setting gpsize and default is 8 byte\n"));
  fprintf (fp, _("\
        -V \t\tSunplus release version \n"));
}
@


1.20
log
@	* gen-aout.c (main): Fix formatting.  Close file.

	* emultempl/aix.em (_read_file): Close file at end of function.

	* gas/all/itbl-test.c (main): Close fas.

	* read.c (add_include_dir): Use xrealloc.
	* config/tc-score.c (do_macro_bcmp): Initialise inst_main.
	* config/tc-tic6x.c (tic6x_parse_operand): Initialise second_reg.

	* readelf.c (decode_arm_unwind): Initialise addr structure.
	(process_symbol_table): Free lengths.
	* srcconv.c (wr_sc): Free info.

	* chew.c (perform): Free next.
@
text
@d4492 1
a4492 1
  struct s3_score_it inst_main = { 0 };
@


1.19
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d4492 1
a4492 1
  struct s3_score_it inst_main;
@


1.18
log
@	* config/tc-score.c (s3_my_get_expression): Delete unused local
	variable 'seg'.
	(s3_do_ldst_insn): Delete unused local variable 'strbak'.
	(s3_do16_ldst_insn): Delete unused local variable 'temp'.
	(s3_do_macro_bcmp): Zero inst_expand array.
	(s3_do_macro_bcmpz): Likewise.
	(s3_s_score_end): Delete unused local variable 'dot'.
	(s3_gen_reloc): Delete unused local variables 'f', 's', and 'e'.
	* config/tc-score7.c (s7_my_get_expression): Delete unused local
	variable 'seg'.
	(s7_do_ldst_insn): Delete unused local variable 'strbak'.
	(s7_b32_relax_to_b16): Delete unused local variables 'r_old' and
	'r_new'.
	(s7_s_score_end): Delete unused local variable 'dot'.
	(s7_relax_frag): Delete unused local variable 'relax_size'.
	(s7_gen_reloc): Delete unused local variables 'f', 's', and 'e'.
@
text
@d2 1
a2 1
   Copyright 2006, 2007, 2008, 2009, 2011 Free Software Foundation, Inc.
d5319 3
a5321 3
  return (symsec != &bfd_und_section
	  && symsec != &bfd_abs_section
	  && ! bfd_is_com_section (symsec)
@


1.17
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d133 2
a134 2
static void s3_do16_slli_srli(char *);
static void s3_do16_ldiu(char *);
d534 3
a536 3
  {_IMM32,            32, {0, 0xfffffff}},        
  {_SIMM32,           32, {-0x80000000, 0x7fffffff}},  
  {_IMM11,            11, {0, (1 << 11) - 1}},	        
d560 1
a560 1
static const struct s3_asm_opcode s3_score_ldst_insns[] = 
d588 1
a588 1
static const struct s3_asm_opcode s3_score_insns[] = 
d694 1
a694 1
  {"breql",     0x00001009, 0x3e007fff, 0x8000,     x_Rs_x,               s3_do_rs}, 
d752 2
a753 2
 
  /* ldi <-> ldiu!.  */  
d957 3
a959 3
                             (2)  ldis reg, %HI(imm32)        
                                  ori  reg, %LO(imm32) 
          
d1146 1
a1146 1
            || (s3_inst.instruction & 0x3e0003ff) == 0x00000342)
d1179 1
a1179 1
		&& s3_walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));  
a1187 1
  segT seg;
d1192 1
a1192 1
  seg = expression (ep);
d1307 1
a1307 1
        {       
d1309 1
a1309 3
            {       
              val = 0;
            }       
d1311 2
a1312 6
        }       
      else    
        {       
          return (int) s3_FAIL;
        }       
      break;  
d1389 1
a1389 1
      if ((dataptr != NULL) 
d1392 1
a1392 1
        { 
d1427 3
a1429 3
             || ((*dataptr == '0') && (*(dataptr + 1) == 'x') && (*(dataptr + 2) != '0'))
             || ((*dataptr == '+') && (*(dataptr + 1) != '0'))
             || ((*dataptr == '-') && (*(dataptr + 1) != '0'))))
d1596 3
a1598 1
      if (((s3_inst.instruction & 0x1ffe0)==0)||(((s3_inst.instruction & 0x1ffe0) == 0x1ffe0)&&(s3_inst.instruction & 0x003e) !=0))
d1611 1
a1611 1
  else  if (((s3_inst.instruction & 0x2000000) == 0x02000000)&& (s3_inst.relax_inst!=0x8000))
d1614 4
a1617 2
      if ((((s3_inst.instruction >> 20) & 0x10) != 0x10) && 
      (((s3_inst.instruction & 0x1ffc0)==0)||(((s3_inst.instruction & 0x1ffc0) == 0x1ffc0)&&(s3_inst.instruction & 0x007e) !=0)))
a1625 1

d1701 1
a1701 1
s3_do_rdrsi5 (char *str) 
d1795 1
a1795 1
         s3_inst.relax_inst =0x5c00; /* addi! */
d1914 1
a1914 1
      s3_inst.relax_inst |= ((s3_inst.instruction >> 15) & 0x1f) ;
d1936 1
a1936 2
          s3_inst.relax_size = 2;   
         
d2217 1
a2217 1
                  char *cur_insn, char *cur_reg, int *warn_or_error)
d2275 1
a2275 1
                              one_inst.type, 0, 0, relaxable_p),
d2335 1
a2335 1
                                  cur_insn, s3_dependency_vector[0].reg, &warn_or_error);
d2383 3
a2385 3
                           s3_dependency_vector[i].name, s3_dependency_vector[i].reg,
                           s3_dependency_vector[0].name, s3_dependency_vector[0].reg,
                           remainder_bubbles, bubbles);
d2507 2
a2508 2
               pb_middle | (m_code_middle << 1) |
               pb_low | m_code_low;
d2561 1
a2561 1
                                  | (inst2->instruction & 0x7FFF);
d2571 1
a2571 1
						   s3_GET_INSN_CLASS (backup_inst1.type));
d2615 2
a2616 2
		       inst1->size, &inst1->reloc.exp,
		       inst1->reloc.pc_rel, inst1->reloc.type);
d2620 1
a2620 1
		       inst2->size, &inst2->reloc.exp, inst2->reloc.pc_rel, inst2->reloc.type);
d2626 2
a2627 2
		       backup_inst1.size, &backup_inst1.reloc.exp,
		       backup_inst1.reloc.pc_rel, backup_inst1.reloc.type);
d2636 1
a2636 1
                              backup_inst1.type, 0, 0, relaxable_p),
a2937 1
  char *strbak;
a2941 1
  strbak = str;
d3071 3
a3073 3
                  || (ldst_idx == INSN_LH)
                  || (ldst_idx == INSN_LW)
                  || (ldst_idx == INSN_SB) || (ldst_idx == INSN_SH) || (ldst_idx == INSN_SW))*/
d3406 1
a3406 2
  int conflict_reg=0;
  char * temp;
d3423 2
a3424 2
          s3_inst.error=s3_err_msg;
          return ;
d3428 1
a3428 1
      temp = str + 1;    /* The latter will process decimal/hex expression.  */
d3459 6
a3464 6
	       {
	        if (data_type < 30)
	          sprintf (s3_err_msg,
	            _("invalid constant: %d bit expression not in range %d..%d"),
	            s3_score_df_range[data_type].bits,
	            s3_score_df_range[data_type].range[0], s3_score_df_range[data_type].range[1]);
d3468 1
a3468 1
              if (value &0x3)
d3471 2
a3472 2
                  s3_inst.error=s3_err_msg;
                  return ;
d3475 1
a3475 1
              value >>=2;
a3478 1
   
d3483 2
a3484 2
      s3_inst.error=s3_err_msg;
      return ;
d3642 1
a3642 1
static void 
d3651 1
a3651 1
      s3_inst.error=s3_err_msg;
d3672 1
a3672 1
      s3_inst.error=s3_err_msg;
d3683 2
a3684 2
                      | (((val >> 1 ) & 0x7) << 7)
                      | (((val >> 4 ) & 0x1f) << 20);
d3687 1
a3687 1
static void 
d3696 1
a3696 1
      s3_inst.error=s3_err_msg;
d3717 1
a3717 1
      s3_inst.error=s3_err_msg;
d3728 2
a3729 2
                      | (((val >> 1 ) & 0x7) << 7)
                      | (((val >> 4 ) & 0x1f) << 20);
d3740 1
a3740 1
      || s3_end_of_line (str) == (int) s3_FAIL) 
d3752 1
a3752 1
      || s3_end_of_line (str) == (int) s3_FAIL) 
d3761 1
a3761 1
      || s3_end_of_line (str) == (int) s3_FAIL) 
d3774 1
a3774 1
      || s3_end_of_line (str) == (int) s3_FAIL) 
d3780 1
a3780 1
  val = s3_inst.instruction & 0x1f; 
d3783 2
a3784 2
      s3_inst.error = _("imm5 should >= 2"); 
      return; 
d3802 1
a3802 1
      || s3_end_of_line (str) == (int) s3_FAIL) 
d3820 1
a3820 1
  else 
d3978 2
a3979 2
                  struct s3_score_it var_insts[s3_RELAX_INST_NUM], int var_num,
                  symbolS *add_symbol)
d3998 1
a3998 1
                                                   s3_GET_INSN_CLASS (var_insts[i].type));
d4021 1
a4021 1
			  &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);
d4039 2
a4040 2
                                &var_insts[i].reloc.exp, var_insts[i].reloc.pc_rel,
                                var_insts[i].reloc.type);
d4059 1
a4059 1
                0, inst_main.size, 0), add_symbol, 0, NULL);
d4094 1
a4094 1
      /* For an external symbol, only one insn is generated; 
d4098 1
a4098 1
                                 (BFD_RELOC_SCORE_GOT15 or BFD_RELOC_SCORE_CALL15)  */
d4207 2
a4208 2
     /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
     s3_inst.bwarn = -1;
d4482 1
d4490 1
a4490 1
  int i=0;
d4494 1
a4494 1

d4500 11
a4510 11
      return;
  ptemp =str;
  while(*ptemp!=0)
  {
  	keep_data[i]=*ptemp;
  	i++;
  	ptemp++;
  }
  keep_data[i]=0;
  if (s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL 
      ||reg_b ==0
d4512 1
a4512 1
    return ; 
d4520 1
a4520 1
      char append_str[s3_MAX_LITERAL_POOL_SIZE];      
d4522 1
a4522 1
      
d4528 3
a4530 1
      s3_inst.instruction |= ((s3_inst.reloc.exp.X_add_number>>1) & 0x1) | ((s3_inst.reloc.exp.X_add_number>>2) & 0x7)<<7 |((s3_inst.reloc.exp.X_add_number>>5) & 0x1f)<<20; 
d4534 1
a4534 1
           && ((val & 0xfffffe00) != 0xfffffe00))
d4548 8
a4555 8
              }
            else
              {
                gas_assert (s3_inst.reloc.exp.X_add_symbol);
              }
            /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
            s3_inst.bwarn = -1;
            return;
d4561 2
a4562 2
                              | (((val >> 1) & 0x7) << 7)
                              | (((val >> 4) & 0x1f) << 20);
d4568 1
a4568 1
      if (s3_score_pic == s3_NO_PIC) 
d4574 1
a4574 1
  
d4594 1
a4594 1
        inst_expand[i].instruction = s3_adjust_paritybit (inst_expand[i].instruction, 
d4600 5
a4604 5
      {
      	if (!frag_now->tc_frag_data.is_insn)
      	  frag_wane (frag_now);
      	frag_new (0);
      }
d4613 4
a4616 4
      {
      	s3_fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
                          &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);
      }
d4636 1
a4636 1
     }
d4643 1
a4643 1
  int reg_a ;
d4646 1
a4646 1
  int i=0;
d4650 1
d4653 1
a4653 1
      || s3_skip_past_comma (&str) == (int) s3_FAIL   )
d4655 11
a4665 9
  ptemp =str;
  while(*ptemp!=0)
  {
  	keep_data[i]=*ptemp;
  	i++;
  	ptemp++;
  }
  keep_data[i]=0;
  if ( s3_my_get_expression (&s3_inst.reloc.exp, &str) == (int) s3_FAIL 
d4667 1
a4667 2
    return ;

d4675 1
a4675 1
      char append_str[s3_MAX_LITERAL_POOL_SIZE];      
d4678 1
a4678 1
      s3_inst.reloc.pc_rel = 1;    
d4682 1
a4682 1
      s3_inst.instruction |= ((s3_inst.reloc.exp.X_add_number>>1) & 0x1) | ((s3_inst.reloc.exp.X_add_number>>2) & 0x7)<<7 |((s3_inst.reloc.exp.X_add_number>>5) & 0x1f)<<20; 
d4686 1
a4686 1
           && ((val & 0xfffffe00) != 0xfffffe00))
d4712 2
a4713 2
                              | (((val >> 1) & 0x7) << 7)
                              | (((val >> 4) & 0x1f) << 20);
d4718 2
a4719 2
      
      if (s3_score_pic == s3_NO_PIC) 
d4744 2
a4745 1
        inst_expand[i].instruction = s3_adjust_paritybit (inst_expand[i].instruction , s3_GET_INSN_CLASS (inst_expand[i].type));
d4750 5
a4754 5
      {
      	if (!frag_now->tc_frag_data.is_insn)
      	  frag_wane (frag_now);
      	frag_new (0);
      }
d4763 4
a4766 4
      {
      	s3_fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
                          &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);
      }
d4786 1
a4786 1
     }
d4819 6
a4824 6
      /* We must defer this decision until after the whole file has been read,
         since there might be a .extern after the first use of this symbol.  */
               || (before_relaxing
                   && S_GET_VALUE (sym) == 0)
               || (S_GET_VALUE (sym) != 0
                   && S_GET_VALUE (sym) <= s3_g_switch_value)))
d4866 1
a4866 1
                                 (BFD_RELOC_SCORE_GOT15)  */
d4999 2
a5000 2
               && (s3_inst.reloc.exp.X_add_number >= -0x4000)
               && (!s3_nopic_need_relax (s3_inst.reloc.exp.X_add_symbol, 1)))
d5045 3
a5047 3
      /* relax lw rd, label -> ldis rs, imm16 
                               ori  rd, imm16
                               lw rd, [rs, imm15] or lw! rd, [rs, imm5].  */
d5056 1
a5056 1
	inst_expand[i].instruction = s3_adjust_paritybit (inst_expand[i].instruction, 
d5079 1
a5079 1
                         &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);
d5099 3
a5101 3
      /* relax lw rd, label -> ldis rs, imm16 
                               ori  rd, imm16
                               lw rd, [rs, imm15] or lw! rd, [rs, imm5].  */
d5202 1
a5202 1
      && s3_inst.reloc.exp.X_add_number <= 16777215))
d5229 1
a5229 1
           && s3_inst.reloc.exp.X_add_number <= 524287))
d5258 1
a5258 1
      || s3_end_of_line (str) == (int) s3_FAIL))
d5267 1
a5267 1
           && s3_inst.reloc.exp.X_add_number <= 511))
d5311 2
a5312 2
	  beginning with the magic string .gnu.linkonce is a linkonce
	  section.  */
d5320 1
a5320 1
	    && symsec != &bfd_abs_section
d5322 1
a5322 1
	    && !linkonce
d5362 2
a5363 2
      || ((pec_part_1.size == s3_INSN_SIZE) && (s3_inst.size == s3_INSN16_SIZE))
      || ((pec_part_1.size == s3_INSN16_SIZE) && (s3_inst.size == s3_INSN_SIZE)))
d5380 1
a5380 1
  /* Check 3d.  */ 
d5404 1
a5404 1
  /* Check 3d.  */ 
d5431 1
a5431 1
  /* Check 3d.  */ 
d5460 1
a5460 1
  /* Check 3d.  */ 
d5482 1
a5482 1
            || (s3_inst.instruction & 0x3e0003ff) == 0x00000342)
d5509 1
a5509 1
  /* Check 3d.  */ 
a5790 1
  valueT dot;
d5841 1
a5841 1
      dot = frag_now_fix ();
d6068 12
a6079 12
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)        	\
    do								\
    {                                                   	\
    if ((SIZE) >= 8)                                      	\
    (P2VAR) = 3;                                        	\
    else if ((SIZE) >= 4)                                 	\
    (P2VAR) = 2;                                        	\
    else if ((SIZE) >= 2)                                 	\
    (P2VAR) = 1;                                        	\
    else                                                  	\
    (P2VAR) = 0;                                        	\
    }								\
d6222 1
a6222 1
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT) \
d6225 2
a6226 2
       (OUTPUT_FLAVOR != bfd_target_aout_flavour
        || (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0)) &&
d6228 1
a6228 1
       (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0) &&
d6231 1
a6231 1
       (S_GET_SEGMENT (symbolP) == bss_seg || (!S_IS_DEFINED (symbolP) && S_GET_VALUE (symbolP) == 0)))
d6322 1
a6322 1
          obstack_alloc (&insn_obstack, sizeof (struct s3_asm_opcode));
d6351 2
a6352 2
          obstack_alloc (&dependency_obstack,
                         sizeof (struct s3_insn_to_dependency));
d6458 1
a6458 1
  else 
d6467 1
a6467 1
  else 
d6476 1
a6476 1
  else 
d6485 1
a6485 1
  else 
d6573 1
a6573 1
        {       
d6575 2
a6576 2
          result |= (*where++ & 255); 
        }       
d6581 1
a6581 1
        {       
d6583 2
a6584 2
          result |= (where[n] & 255); 
        }       
d6587 1
a6587 1
  return result; 
d6642 1
a6642 1
  if (!target_big_endian && n >= 4) 
d6742 1
a6742 1
      || fixp->fx_r_type == BFD_RELOC_SCORE16_BRANCH  
d6758 1
a6758 1
      && (S_IS_EXTERNAL (fixP->fx_addsy) || S_IS_WEAK (fixP->fx_addsy)))
d6868 1
a6868 1
  if (relaxable_p 
d6910 2
a6911 2
           | (((inst_value >> 7) & 0x7) << 1)
           | (((inst_value >> 21) & 0x1f) << 4);
d6918 3
a6920 3
     1.not defined symbol or common sysbol or external symbol will change 
       bcmp to cmp!+beq/bne ,here need to record fragp->fr_opcode
     2.if the flow is as before : it will results to recursive loop 
d6923 1
a6923 1
    { 
d6928 7
a6934 7
  else if ((relaxable_p 
      && (!((value & 0xfffffe00) == 0 || (value & 0xfffffe00) == 0xfffffe00))
      && fragp->fr_fix == 4
      && (s->bsym != NULL))
      || !S_IS_DEFINED (s)
       ||S_IS_COMMON (s)
        ||S_IS_EXTERNAL (s))
a6939 1
  
d6941 1
a6941 1
    { 
d6969 1
a6969 1
  /* md_estimate_size_before_relax has already relaxed s3_GP and s3_PIC 
d6984 1
a6984 1
      {
d6988 1
a6988 1
      }
d7165 3
a7167 3
                  | (((value & 0xff) >> 0) << 7)
                  | (((value & 0x7fff00) >> 8) << 16)
                  | (((value & 0x3f800000) >> 23) << 32); 
d7177 3
a7179 3
                 | ((value & 0x3ff) << 5)
                 | (((value >> 10) & 0x7fff) << 16)
                 | (((value >> 25) & 0x7f) << 32);
d7229 1
a7229 1
   case BFD_RELOC_SCORE16_BRANCH:
d7274 1
a7274 1
    break;
d7287 1
a7287 1
          /* NOTE!!!  
d7319 1
a7319 1
                _(" branch relocation truncate (0x%x)  [-2^9 ~ 2^9]"), (unsigned int)value);
d7326 3
a7328 3
                    | (value & 0x1)
                    | (((value & 0xe) >> 1) << 7)
                    | (((value & 0x1f0) >> 4) << 21);
a7402 3
  fragS *f;
  symbolS *s;
  expressionS e;
a7440 4
      f = fixp->fx_frag;
      s = f->fr_symbol;
      e = s->sy_value;

d7622 1
a7622 1
  else 
@


1.16
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d61 1
a61 1
static void s3_operand (expressionS * expr);
a3140 1
              int value;
d6512 1
a6512 1
s3_operand (expressionS * expr)
d6516 1
a6516 1
      expr->X_op = O_illegal;
d7524 1
a7524 1
md_operand (expressionS * expr)
d7527 1
a7527 1
    s3_operand (expr);
d7529 1
a7529 1
    s7_operand (expr);
@


1.15
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2493 1
a2493 1
s3_adjust_paritybit (bfd_vma m_code, enum insn_class class)
d2503 1
a2503 1
  if (class == INSN_CLASS_48)
d2515 1
a2515 1
  else if (class == INSN_CLASS_32 || class == INSN_CLASS_SYN)
d2523 1
a2523 1
  else if (class == INSN_CLASS_16)
d2531 1
a2531 1
  else if (class == INSN_CLASS_PCE)
@


1.15.2.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d2493 1
a2493 1
s3_adjust_paritybit (bfd_vma m_code, enum insn_class i_class)
d2503 1
a2503 1
  if (i_class == INSN_CLASS_48)
d2515 1
a2515 1
  else if (i_class == INSN_CLASS_32 || i_class == INSN_CLASS_SYN)
d2523 1
a2523 1
  else if (i_class == INSN_CLASS_16)
d2531 1
a2531 1
  else if (i_class == INSN_CLASS_PCE)
@


1.14
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d542 1
a542 1
  const char *template;
d2684 1
a2684 1
      sprintf (s3_inst.name, "%s", opcode->template);
d2730 1
a2730 1
      sprintf (s3_inst.name, "%s", opcode->template);
d4996 2
a4997 1
          s3_build_lwst_pic (reg_rd, s3_inst.reloc.exp, s3_score_ldst_insns[ldst_idx * 3 + 0].template);
d6323 16
a6338 14
      unsigned len = strlen (insn->template);
      struct s3_asm_opcode *new;
      char *template;
      new = obstack_alloc (&insn_obstack, sizeof (struct s3_asm_opcode));
      template = obstack_alloc (&insn_obstack, len + 1);

      strcpy (template, insn->template);
      new->template = template;
      new->parms = insn->parms;
      new->value = insn->value;
      new->relax_value = insn->relax_value;
      new->type = insn->type;
      new->bitmask = insn->bitmask;
      hash_insert (s3_score_ops_hsh, new->template, (void *) new);
d6353 1
a6353 1
      struct s3_insn_to_dependency *new;
d6355 10
a6364 6
      new = obstack_alloc (&dependency_obstack, sizeof (struct s3_insn_to_dependency));
      new->insn_name = obstack_alloc (&dependency_obstack, len + 1);

      strcpy (new->insn_name, tmp->insn_name);
      new->type = tmp->type;
      hash_insert (s3_dependency_insn_hsh, new->insn_name, (void *) new);
d7033 2
a7034 2
  int old;
  int new;
d7038 2
a7039 2
  old = s3_RELAX_OLD (fragp->fr_subtype);
  new = s3_RELAX_NEW (fragp->fr_subtype);
d7044 2
a7045 2
      memcpy (backup, fragp->fr_literal, old);
      fragp->fr_fix = old;
d7049 2
a7050 2
      memcpy (backup, fragp->fr_literal + old, new);
      fragp->fr_fix = new;
d7054 1
a7054 1
  while (fixp && fixp->fx_frag == fragp && fixp->fx_where < old)
d7063 1
a7063 1
	fixp->fx_where -= old + fragp->insn_addr;
@


1.13
log
@Add support for Score7 architecture.
@
text
@d4289 1
a4289 1
		  assert (s3_inst.reloc.exp.X_add_symbol);
d4558 1
a4558 1
                assert (s3_inst.reloc.exp.X_add_symbol);
d4592 1
a4592 1
          assert (s3_inst.reloc.exp.X_add_symbol);
d4707 1
a4707 1
              assert (s3_inst.reloc.exp.X_add_symbol);
d4740 1
a4740 1
          assert (s3_inst.reloc.exp.X_add_symbol);
d5828 1
a5828 1
      assert (S_GET_NAME (p));
d5846 1
a5846 1
      assert (s3_pdr_seg);
d7106 1
a7106 1
  assert (fixP->fx_r_type < BFD_RELOC_UNUSED);
d7449 1
a7449 1
      assert (retval[1]->howto != NULL);
@


1.12
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2 1
a2 1
   Copyright 2006, 2007 Free Software Foundation, Inc.
d4 1
d25 166
a190 7
#include "as.h"
#include "config.h"
#include "subsegs.h"
#include "safe-ctype.h"
#include "opcode/score-inst.h"
#include "opcode/score-datadep.h"
#include "struc-symbol.h"
d193 38
a230 2
#include "elf/score.h"
#include "dwarf2dbg.h"
d232 13
d246 11
a256 8
#define GP                     28
#define PIC_CALL_REG           29
#define MAX_LITERAL_POOL_SIZE  1024
#define FAIL	               0x80000000
#define SUCCESS         0
#define INSN_SIZE       4
#define INSN16_SIZE     2
#define RELAX_INST_NUM  3
d259 6
a264 10
#define BAD_ARGS 	          _("bad arguments to instruction")
#define BAD_PC 		          _("r15 not allowed here")
#define BAD_COND 	          _("instruction is not conditional")
#define ERR_NO_ACCUM	          _("acc0 expected")
#define ERR_FOR_SCORE5U_MUL_DIV   _("div / mul are reserved instructions")
#define ERR_FOR_SCORE5U_MMU       _("This architecture doesn't support mmu")
#define ERR_FOR_SCORE5U_ATOMIC    _("This architecture doesn't support atomic instruction")
#define LONG_LABEL_LEN            _("the label length is longer than 1024");
#define BAD_SKIP_COMMA            BAD_ARGS
#define BAD_GARBAGE               _("garbage following instruction");
d266 1
a266 1
#define skip_whitespace(str)  while (*(str) == ' ') ++(str)
d269 1
a269 1
#define RDATA_SECTION_NAME (OUTPUT_FLAVOR == bfd_target_aout_flavour \
d279 1
a279 1
#define RELAX_ENCODE(old, new, type, reloc1, reloc2, opt) \
d288 40
a327 7
#define RELAX_OLD(i)       (((i) >> 23) & 0x7f)
#define RELAX_NEW(i)       (((i) >> 16) & 0x7f)
#define RELAX_TYPE(i)      (((i) >> 9) & 0x7f)
#define RELAX_RELOC1(i)    ((valueT) ((i) >> 5) & 0xf)
#define RELAX_RELOC2(i)    ((valueT) ((i) >> 1) & 0xf)
#define RELAX_OPT(i)       ((i) & 1)
#define RELAX_OPT_CLEAR(i) ((i) & ~1)
d329 5
a333 2
#define SET_INSN_ERROR(s) (inst.error = (s))
#define INSN_IS_PCE_P(s)  (strstr (str, "||") != NULL)
d335 5
a339 1
#define GET_INSN_CLASS(type) (get_insn_class_from_type (type))
d341 10
a350 2
#define GET_INSN_SIZE(type) ((GET_INSN_CLASS (type) == INSN_CLASS_16) \
                             ? INSN16_SIZE : INSN_SIZE)
d352 5
a356 5
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "#";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = ";";
d358 5
a362 3
/* Chars that can be used to separate mant from exp in floating point numbers.  */
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d365 1
a365 1
static char err_msg[255];
d367 2
a368 5
fragS *score_fragp = 0;
static int fix_data_dependency = 0;
static int warn_fix_data_dependency = 1;
static int score7 = 1;
static int university_version = 0;
d370 1
a370 4
static int in_my_get_expression = 0;

#define USE_GLOBAL_POINTER_OPT 1
#define SCORE_BI_ENDIAN
d373 1
a373 1
static int nor1 = 1;
d375 2
a376 2
/* Default will do instruction relax, -O0 will set g_opt = 0.  */
static unsigned int g_opt = 1;
d379 1
a379 7
static unsigned int g_switch_value = 8;

#ifdef OBJ_ELF
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
symbolS *GOT_symbol;
#endif
static segT pdr_seg;
d381 1
a381 1
enum score_pic_level score_pic = NO_PIC;
d383 1
a383 2
#define INSN_NAME_LEN 16
struct score_it
d385 3
a387 3
  char name[INSN_NAME_LEN];
  unsigned long instruction;
  unsigned long relax_inst;
d391 1
a391 1
  char str[MAX_LITERAL_POOL_SIZE];
d394 1
a394 1
  char reg[INSN_NAME_LEN];
d402 1
a402 1
struct score_it inst;
d404 1
a404 1
typedef struct proc
d414 4
a417 2
}
procS;
a418 11
static procS cur_proc;
static procS *cur_proc_ptr;
static int numprocs;

#define SCORE7_PIPELINE 7
#define SCORE5_PIPELINE 5
static int vector_size = SCORE7_PIPELINE;
struct score_it dependency_vector[SCORE7_PIPELINE];

/* Relax will need some padding for alignment.  */
#define RELAX_PAD_BYTE 3
d421 1
a421 1
struct reg_entry
d427 1
a427 1
static const struct reg_entry score_rn_table[] =
d440 1
a440 1
static const struct reg_entry score_srn_table[] =
d446 1
a446 1
static const struct reg_entry score_crn_table[] =
d459 1
a459 1
struct reg_map
d461 1
a461 1
  const struct reg_entry *names;
d467 1
a467 1
struct reg_map all_reg_maps[] =
d469 3
a471 3
  {score_rn_table, 31, NULL, N_("S+core register expected")},
  {score_srn_table, 2, NULL, N_("S+core special-register expected")},
  {score_crn_table, 31, NULL, N_("S+core co-processor register expected")},
d474 2
a475 1
static struct hash_control *score_ops_hsh = NULL;
a476 1
static struct hash_control *dependency_insn_hsh = NULL;
d478 8
a485 2
/* Enumeration matching entries in table above.  */
enum score_reg_type
d487 50
a536 5
  REG_TYPE_SCORE = 0,
#define REG_TYPE_FIRST REG_TYPE_SCORE
  REG_TYPE_SCORE_SR = 1,
  REG_TYPE_SCORE_CR = 2,
  REG_TYPE_MAX = 3
d539 1
a539 1
typedef struct literalS
d541 14
a554 4
  struct expressionS exp;
  struct score_it *inst;
}
literalT;
d556 3
a558 1
literalT literals[MAX_LITERAL_POOL_SIZE];
d560 26
a585 79
static void do_ldst_insn (char *);
static void do_crdcrscrsimm5 (char *);
static void do_ldst_unalign (char *);
static void do_ldst_atomic (char *);
static void do_ldst_cop (char *);
static void do_macro_li_rdi32 (char *);
static void do_macro_la_rdi32 (char *);
static void do_macro_rdi32hi (char *);
static void do_macro_rdi32lo (char *);
static void do_macro_mul_rdrsrs (char *);
static void do_macro_ldst_label (char *);
static void do_branch (char *);
static void do_jump (char *);
static void do_empty (char *);
static void do_rdrsrs (char *);
static void do_rdsi16 (char *);
static void do_rdrssi14 (char *);
static void do_sub_rdsi16 (char *);
static void do_sub_rdrssi14 (char *);
static void do_rdrsi5 (char *);
static void do_rdrsi14 (char *);
static void do_rdi16 (char *);
static void do_xrsi5 (char *);
static void do_rdrs (char *);
static void do_rdxrs (char *);
static void do_rsrs (char *);
static void do_rdcrs (char *);
static void do_rdsrs (char *);
static void do_rd (char *);
static void do_rs (char *);
static void do_i15 (char *);
static void do_xi5x (char *);
static void do_ceinst (char *);
static void do_cache (char *);
static void do16_rdrs (char *);
static void do16_rs (char *);
static void do16_xrs (char *);
static void do16_mv_rdrs (char *);
static void do16_hrdrs (char *);
static void do16_rdhrs (char *);
static void do16_rdi4 (char *);
static void do16_rdi5 (char *);
static void do16_xi5 (char *);
static void do16_ldst_insn (char *);
static void do16_ldst_imm_insn (char *);
static void do16_push_pop (char *);
static void do16_branch (char *);
static void do16_jump (char *);
static void do_rdi16_pic (char *);
static void do_addi_s_pic (char *);
static void do_addi_u_pic (char *);
static void do_lw_pic (char *);

static const struct asm_opcode score_ldst_insns[] = 
{
  {"lw",        0x20000000, 0x3e000000, 0x2008,     Rd_rvalueRs_SI15,     do_ldst_insn},
  {"lw",        0x06000000, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  do_ldst_insn},
  {"lw",        0x0e000000, 0x3e000007, 0x200a,     Rd_rvalueRs_postSI12, do_ldst_insn},
  {"lh",        0x22000000, 0x3e000000, 0x2009,     Rd_rvalueRs_SI15,     do_ldst_insn},
  {"lh",        0x06000001, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  do_ldst_insn},
  {"lh",        0x0e000001, 0x3e000007, 0x8000,     Rd_rvalueRs_postSI12, do_ldst_insn},
  {"lhu",       0x24000000, 0x3e000000, 0x8000,     Rd_rvalueRs_SI15,     do_ldst_insn},
  {"lhu",       0x06000002, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  do_ldst_insn},
  {"lhu",       0x0e000002, 0x3e000007, 0x8000,     Rd_rvalueRs_postSI12, do_ldst_insn},
  {"lb",        0x26000000, 0x3e000000, 0x8000,     Rd_rvalueRs_SI15,     do_ldst_insn},
  {"lb",        0x06000003, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  do_ldst_insn},
  {"lb",        0x0e000003, 0x3e000007, 0x8000,     Rd_rvalueRs_postSI12, do_ldst_insn},
  {"sw",        0x28000000, 0x3e000000, 0x200c,     Rd_lvalueRs_SI15,     do_ldst_insn},
  {"sw",        0x06000004, 0x3e000007, 0x200e,     Rd_lvalueRs_preSI12,  do_ldst_insn},
  {"sw",        0x0e000004, 0x3e000007, 0x8000,     Rd_lvalueRs_postSI12, do_ldst_insn},
  {"sh",        0x2a000000, 0x3e000000, 0x200d,     Rd_lvalueRs_SI15,     do_ldst_insn},
  {"sh",        0x06000005, 0x3e000007, 0x8000,     Rd_lvalueRs_preSI12,  do_ldst_insn},
  {"sh",        0x0e000005, 0x3e000007, 0x8000,     Rd_lvalueRs_postSI12, do_ldst_insn},
  {"lbu",       0x2c000000, 0x3e000000, 0x200b,     Rd_rvalueRs_SI15,     do_ldst_insn},
  {"lbu",       0x06000006, 0x3e000007, 0x8000,     Rd_rvalueRs_preSI12,  do_ldst_insn},
  {"lbu",       0x0e000006, 0x3e000007, 0x8000,     Rd_rvalueRs_postSI12, do_ldst_insn},
  {"sb",        0x2e000000, 0x3e000000, 0x200f,     Rd_lvalueRs_SI15,     do_ldst_insn},
  {"sb",        0x06000007, 0x3e000007, 0x8000,     Rd_lvalueRs_preSI12,  do_ldst_insn},
  {"sb",        0x0e000007, 0x3e000007, 0x8000,     Rd_lvalueRs_postSI12, do_ldst_insn},
d588 1
a588 1
static const struct asm_opcode score_insns[] = 
d590 363
a952 404
  {"abs",       0x3800000a, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"abs.s",     0x3800004b, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"add",       0x00000010, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"add.c",     0x00000011, 0x3e0003ff, 0x2000,     Rd_Rs_Rs,             do_rdrsrs},
  {"add.s",     0x38000048, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"addc",      0x00000012, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"addc.c",    0x00000013, 0x3e0003ff, 0x0009,     Rd_Rs_Rs,             do_rdrsrs},
  {"addi",      0x02000000, 0x3e0e0001, 0x8000,     Rd_SI16,              do_rdsi16},
  {"addi.c",    0x02000001, 0x3e0e0001, 0x8000,     Rd_SI16,              do_rdsi16},
  {"addis",     0x0a000000, 0x3e0e0001, 0x8000,     Rd_SI16,              do_rdi16},
  {"addis.c",   0x0a000001, 0x3e0e0001, 0x8000,     Rd_SI16,              do_rdi16},
  {"addri",     0x10000000, 0x3e000001, 0x8000,     Rd_Rs_SI14,           do_rdrssi14},
  {"addri.c",   0x10000001, 0x3e000001, 0x8000,     Rd_Rs_SI14,           do_rdrssi14},
  {"addc!",     0x0009,     0x700f,     0x00000013, Rd_Rs,                do16_rdrs},
  {"add!",      0x2000,     0x700f,     0x00000011, Rd_Rs,                do16_rdrs},
  {"addei!",    0x6000    , 0x7087,     0x02000001, Rd_I4,                do16_rdi4},
  {"subi",      0x02000000, 0x3e0e0001, 0x8000,     Rd_SI16,              do_sub_rdsi16},
  {"subi.c",    0x02000001, 0x3e0e0001, 0x8000,     Rd_SI16,              do_sub_rdsi16},
  {"subri",     0x10000000, 0x3e000001, 0x8000,     Rd_Rs_SI14,           do_sub_rdrssi14},
  {"subri.c",   0x10000001, 0x3e000001, 0x8000,     Rd_Rs_SI14,           do_sub_rdrssi14},
  {"and",       0x00000020, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"and.c",     0x00000021, 0x3e0003ff, 0x2004,     Rd_Rs_Rs,             do_rdrsrs},
  {"andi",      0x02080000, 0x3e0e0001, 0x8000,     Rd_I16,               do_rdi16},
  {"andi.c",    0x02080001, 0x3e0e0001, 0x8000,     Rd_I16,               do_rdi16},
  {"andis",     0x0a080000, 0x3e0e0001, 0x8000,     Rd_I16,               do_rdi16},
  {"andis.c",   0x0a080001, 0x3e0e0001, 0x8000,     Rd_I16,               do_rdi16},
  {"andri",     0x18000000, 0x3e000001, 0x8000,     Rd_Rs_I14,            do_rdrsi14},
  {"andri.c",   0x18000001, 0x3e000001, 0x8000,     Rd_Rs_I14,            do_rdrsi14},
  {"and!",      0x2004,     0x700f,     0x00000021, Rd_Rs,                do16_rdrs},
  {"bcs",       0x08000000, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bcc",       0x08000400, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bcnz",      0x08003800, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bcsl",      0x08000001, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bccl",      0x08000401, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bcnzl",     0x08003801, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bcs!",      0x4000,     0x7f00,     0x08000000, PC_DISP8div2,         do16_branch},
  {"bcc!",      0x4100,     0x7f00,     0x08000400, PC_DISP8div2,         do16_branch},
  {"bcnz!",     0x4e00,     0x7f00,     0x08003800, PC_DISP8div2,         do16_branch},
  {"beq",       0x08001000, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"beql",      0x08001001, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"beq!",      0x4400,     0x7f00,     0x08001000, PC_DISP8div2,         do16_branch},
  {"bgtu",      0x08000800, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bgt",       0x08001800, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bge",       0x08002000, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bgtul",     0x08000801, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bgtl",      0x08001801, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bgel",      0x08002001, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bgtu!",     0x4200,     0x7f00,     0x08000800, PC_DISP8div2,         do16_branch},
  {"bgt!",      0x4600,     0x7f00,     0x08001800, PC_DISP8div2,         do16_branch},
  {"bge!",      0x4800,     0x7f00,     0x08002000, PC_DISP8div2,         do16_branch},
  {"bitclr.c",  0x00000029, 0x3e0003ff, 0x6004,     Rd_Rs_I5,             do_rdrsi5},
  {"bitrev",    0x3800000c, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"bitset.c",  0x0000002b, 0x3e0003ff, 0x6005,     Rd_Rs_I5,             do_rdrsi5},
  {"bittst.c",  0x0000002d, 0x3e0003ff, 0x6006,     x_Rs_I5,              do_xrsi5},
  {"bittgl.c",  0x0000002f, 0x3e0003ff, 0x6007,     Rd_Rs_I5,             do_rdrsi5},
  {"bitclr!",   0x6004,     0x7007,     0x00000029, Rd_I5,                do16_rdi5},
  {"bitset!",   0x6005,     0x7007,     0x0000002b, Rd_I5,                do16_rdi5},
  {"bittst!",   0x6006,     0x7007,     0x0000002d, Rd_I5,                do16_rdi5},
  {"bittgl!",   0x6007,     0x7007,     0x0000002f, Rd_I5,                do16_rdi5},
  {"bleu",      0x08000c00, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"ble",       0x08001c00, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"blt",       0x08002400, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bleul",     0x08000c01, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"blel",      0x08001c01, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bltl",      0x08002401, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bl",        0x08003c01, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bleu!",     0x4300,     0x7f00,     0x08000c00, PC_DISP8div2,         do16_branch},
  {"ble!",      0x4700,     0x7f00,     0x08001c00, PC_DISP8div2,         do16_branch},
  {"blt!",      0x4900,     0x7f00,     0x08002400, PC_DISP8div2,         do16_branch},
  {"bmi",       0x08002800, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bmil",      0x08002801, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bmi!",      0x00004a00, 0x00007f00, 0x08002800, PC_DISP8div2,         do16_branch},
  {"bne",       0x08001400, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bnel",      0x08001401, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bne!",      0x4500,     0x7f00,     0x08001400, PC_DISP8div2,         do16_branch},
  {"bpl",       0x08002c00, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bpll",      0x08002c01, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bpl!",      0x4b00,     0x7f00,     0x08002c00, PC_DISP8div2,         do16_branch},
  {"brcs",      0x00000008, 0x3e007fff, 0x0004,     x_Rs_x,               do_rs},
  {"brcc",      0x00000408, 0x3e007fff, 0x0104,     x_Rs_x,               do_rs},
  {"brgtu",     0x00000808, 0x3e007fff, 0x0204,     x_Rs_x,               do_rs},
  {"brleu",     0x00000c08, 0x3e007fff, 0x0304,     x_Rs_x,               do_rs},
  {"breq",      0x00001008, 0x3e007fff, 0x0404,     x_Rs_x,               do_rs},
  {"brne",      0x00001408, 0x3e007fff, 0x0504,     x_Rs_x,               do_rs},
  {"brgt",      0x00001808, 0x3e007fff, 0x0604,     x_Rs_x,               do_rs},
  {"brle",      0x00001c08, 0x3e007fff, 0x0704,     x_Rs_x,               do_rs},
  {"brge",      0x00002008, 0x3e007fff, 0x0804,     x_Rs_x,               do_rs},
  {"brlt",      0x00002408, 0x3e007fff, 0x0904,     x_Rs_x,               do_rs},
  {"brmi",      0x00002808, 0x3e007fff, 0x0a04,     x_Rs_x,               do_rs},
  {"brpl",      0x00002c08, 0x3e007fff, 0x0b04,     x_Rs_x,               do_rs},
  {"brvs",      0x00003008, 0x3e007fff, 0x0c04,     x_Rs_x,               do_rs},
  {"brvc",      0x00003408, 0x3e007fff, 0x0d04,     x_Rs_x,               do_rs},
  {"brcnz",     0x00003808, 0x3e007fff, 0x0e04,     x_Rs_x,               do_rs},
  {"br",        0x00003c08, 0x3e007fff, 0x0f04,     x_Rs_x,               do_rs},
  {"brcsl",     0x00000009, 0x3e007fff, 0x000c,     x_Rs_x,               do_rs},
  {"brccl",     0x00000409, 0x3e007fff, 0x010c,     x_Rs_x,               do_rs},
  {"brgtul",    0x00000809, 0x3e007fff, 0x020c,     x_Rs_x,               do_rs},
  {"brleul",    0x00000c09, 0x3e007fff, 0x030c,     x_Rs_x,               do_rs},
  {"breql",     0x00001009, 0x3e007fff, 0x040c,     x_Rs_x,               do_rs}, 
  {"brnel",     0x00001409, 0x3e007fff, 0x050c,     x_Rs_x,               do_rs},
  {"brgtl",     0x00001809, 0x3e007fff, 0x060c,     x_Rs_x,               do_rs},
  {"brlel",     0x00001c09, 0x3e007fff, 0x070c,     x_Rs_x,               do_rs},
  {"brgel",     0x00002009, 0x3e007fff, 0x080c,     x_Rs_x,               do_rs},
  {"brltl",     0x00002409, 0x3e007fff, 0x090c,     x_Rs_x,               do_rs},
  {"brmil",     0x00002809, 0x3e007fff, 0x0a0c,     x_Rs_x,               do_rs},
  {"brpll",     0x00002c09, 0x3e007fff, 0x0b0c,     x_Rs_x,               do_rs},
  {"brvsl",     0x00003009, 0x3e007fff, 0x0c0c,     x_Rs_x,               do_rs},
  {"brvcl",     0x00003409, 0x3e007fff, 0x0d0c,     x_Rs_x,               do_rs},
  {"brcnzl",    0x00003809, 0x3e007fff, 0x0e0c,     x_Rs_x,               do_rs},
  {"brl",       0x00003c09, 0x3e007fff, 0x0f0c,     x_Rs_x,               do_rs},
  {"brcs!",     0x0004,     0x7f0f,     0x00000008, x_Rs,                 do16_xrs},
  {"brcc!",     0x0104,     0x7f0f,     0x00000408, x_Rs,                 do16_xrs},
  {"brgtu!",    0x0204,     0x7f0f,     0x00000808, x_Rs,                 do16_xrs},
  {"brleu!",    0x0304,     0x7f0f,     0x00000c08, x_Rs,                 do16_xrs},
  {"breq!",     0x0404,     0x7f0f,     0x00001008, x_Rs,                 do16_xrs},
  {"brne!",     0x0504,     0x7f0f,     0x00001408, x_Rs,                 do16_xrs},
  {"brgt!",     0x0604,     0x7f0f,     0x00001808, x_Rs,                 do16_xrs},
  {"brle!",     0x0704,     0x7f0f,     0x00001c08, x_Rs,                 do16_xrs},
  {"brge!",     0x0804,     0x7f0f,     0x00002008, x_Rs,                 do16_xrs},
  {"brlt!",     0x0904,     0x7f0f,     0x00002408, x_Rs,                 do16_xrs},
  {"brmi!",     0x0a04,     0x7f0f,     0x00002808, x_Rs,                 do16_xrs},
  {"brpl!",     0x0b04,     0x7f0f,     0x00002c08, x_Rs,                 do16_xrs},
  {"brvs!",     0x0c04,     0x7f0f,     0x00003008, x_Rs,                 do16_xrs},
  {"brvc!",     0x0d04,     0x7f0f,     0x00003408, x_Rs,                 do16_xrs},
  {"brcnz!",    0x0e04,     0x7f0f,     0x00003808, x_Rs,                 do16_xrs},
  {"br!",       0x0f04,     0x7f0f,     0x00003c08, x_Rs,                 do16_xrs},
  {"brcsl!",    0x000c,     0x7f0f,     0x00000009, x_Rs,                 do16_xrs},
  {"brccl!",    0x010c,     0x7f0f,     0x00000409, x_Rs,                 do16_xrs},
  {"brgtul!",   0x020c,     0x7f0f,     0x00000809, x_Rs,                 do16_xrs},
  {"brleul!",   0x030c,     0x7f0f,     0x00000c09, x_Rs,                 do16_xrs},
  {"breql!",    0x040c,     0x7f0f,     0x00001009, x_Rs,                 do16_xrs},
  {"brnel!",    0x050c,     0x7f0f,     0x00001409, x_Rs,                 do16_xrs},
  {"brgtl!",    0x060c,     0x7f0f,     0x00001809, x_Rs,                 do16_xrs},
  {"brlel!",    0x070c,     0x7f0f,     0x00001c09, x_Rs,                 do16_xrs},
  {"brgel!",    0x080c,     0x7f0f,     0x00002009, x_Rs,                 do16_xrs},
  {"brltl!",    0x090c,     0x7f0f,     0x00002409, x_Rs,                 do16_xrs},
  {"brmil!",    0x0a0c,     0x7f0f,     0x00002809, x_Rs,                 do16_xrs},
  {"brpll!",    0x0b0c,     0x7f0f,     0x00002c09, x_Rs,                 do16_xrs},
  {"brvsl!",    0x0c0c,     0x7f0f,     0x00003009, x_Rs,                 do16_xrs},
  {"brvcl!",    0x0d0c,     0x7f0f,     0x00003409, x_Rs,                 do16_xrs},
  {"brcnzl!",   0x0e0c,     0x7f0f,     0x00003809, x_Rs,                 do16_xrs},
  {"brl!",      0x0f0c,     0x7f0f,     0x00003c09, x_Rs,                 do16_xrs},
  {"bvs",       0x08003000, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bvc",       0x08003400, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"bvsl",      0x08003001, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bvcl",      0x08003401, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bvs!",      0x4c00,     0x7f00,     0x08003000, PC_DISP8div2,         do16_branch},
  {"bvc!",      0x4d00,     0x7f00,     0x08003400, PC_DISP8div2,         do16_branch},
  {"b!",        0x4f00,     0x7f00,     0x08003c00, PC_DISP8div2,         do16_branch},
  {"b",         0x08003c00, 0x3e007c01, 0x4000,     PC_DISP19div2,        do_branch},
  {"cache",     0x30000000, 0x3ff00000, 0x8000,     OP5_rvalueRs_SI15,    do_cache},
  {"ceinst",    0x38000000, 0x3e000000, 0x8000,     I5_Rs_Rs_I5_OP5,      do_ceinst},
  {"clz",       0x3800000d, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"cmpteq.c",  0x00000019, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"cmptmi.c",  0x00100019, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"cmp.c",     0x00300019, 0x3ff003ff, 0x2003,     x_Rs_Rs,              do_rsrs},
  {"cmpzteq.c", 0x0000001b, 0x3ff07fff, 0x8000,     x_Rs_x,               do_rs},
  {"cmpztmi.c", 0x0010001b, 0x3ff07fff, 0x8000,     x_Rs_x,               do_rs},
  {"cmpz.c",    0x0030001b, 0x3ff07fff, 0x8000,     x_Rs_x,               do_rs},
  {"cmpi.c",    0x02040001, 0x3e0e0001, 0x8000,     Rd_SI16,              do_rdsi16},
  {"cmp!",      0x2003,     0x700f,     0x00300019, Rd_Rs,                do16_rdrs},
  {"cop1",      0x0c00000c, 0x3e00001f, 0x8000,     Rd_Rs_Rs_imm,         do_crdcrscrsimm5},
  {"cop2",      0x0c000014, 0x3e00001f, 0x8000,     Rd_Rs_Rs_imm,         do_crdcrscrsimm5},
  {"cop3",      0x0c00001c, 0x3e00001f, 0x8000,     Rd_Rs_Rs_imm,         do_crdcrscrsimm5},
  {"drte",      0x0c0000a4, 0x3e0003ff, 0x8000,     NO_OPD,               do_empty},
  {"extsb",     0x00000058, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"extsb.c",   0x00000059, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"extsh",     0x0000005a, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"extsh.c",   0x0000005b, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"extzb",     0x0000005c, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"extzb.c",   0x0000005d, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"extzh",     0x0000005e, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"extzh.c",   0x0000005f, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"jl",        0x04000001, 0x3e000001, 0x8000,     PC_DISP24div2,        do_jump},
  {"jl!",       0x3001,     0x7001,     0x04000001, PC_DISP11div2,        do16_jump},
  {"j!",        0x3000,     0x7001,     0x04000000, PC_DISP11div2,        do16_jump},
  {"j",         0x04000000, 0x3e000001, 0x8000,     PC_DISP24div2,        do_jump},
  {"lbu!",      0x200b,     0x0000700f, 0x2c000000, Rd_rvalueRs,          do16_ldst_insn},
  {"lbup!",     0x7003,     0x7007,     0x2c000000, Rd_rvalueBP_I5,       do16_ldst_imm_insn},
  {"alw",       0x0000000c, 0x3e0003ff, 0x8000,     Rd_rvalue32Rs,        do_ldst_atomic},
  {"lcb",       0x00000060, 0x3e0003ff, 0x8000,     x_rvalueRs_post4,     do_ldst_unalign},
  {"lcw",       0x00000062, 0x3e0003ff, 0x8000,     Rd_rvalueRs_post4,    do_ldst_unalign},
  {"lce",       0x00000066, 0x3e0003ff, 0x8000,     Rd_rvalueRs_post4,    do_ldst_unalign},
  {"ldc1",      0x0c00000a, 0x3e00001f, 0x8000,     Rd_rvalueRs_SI10,     do_ldst_cop},
  {"ldc2",      0x0c000012, 0x3e00001f, 0x8000,     Rd_rvalueRs_SI10,     do_ldst_cop},
  {"ldc3",      0x0c00001a, 0x3e00001f, 0x8000,     Rd_rvalueRs_SI10,     do_ldst_cop},
  {"lh!",       0x2009,     0x700f,     0x22000000, Rd_rvalueRs,          do16_ldst_insn},
  {"lhp!",      0x7001,     0x7007,     0x22000000, Rd_rvalueBP_I5,       do16_ldst_imm_insn},
  {"ldi",       0x020c0000, 0x3e0e0000, 0x5000,     Rd_SI16,              do_rdsi16},
  {"ldis",      0x0a0c0000, 0x3e0e0000, 0x8000,     Rd_I16,               do_rdi16},
  {"ldiu!",     0x5000,     0x7000,     0x020c0000, Rd_I8,                do16_ldst_imm_insn},
  {"lw!",       0x2008,     0x700f,     0x20000000, Rd_rvalueRs,          do16_ldst_insn},
  {"lwp!",      0x7000,     0x7007,     0x20000000, Rd_rvalueBP_I5,       do16_ldst_imm_insn},
  {"mfcel",     0x00000448, 0x3e007fff, 0x8000,     Rd_x_x,               do_rd},
  {"mfcel!",    0x1001,     0x7f0f,     0x00000448, x_Rs,                 do16_rs},
  {"mad",       0x38000000, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mad.f!",    0x1004,     0x700f,     0x38000080, Rd_Rs,                do16_rdrs},
  {"madh",      0x38000203, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"madh.fs",   0x380002c3, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"madh.fs!",  0x100b,     0x700f,     0x380002c3, Rd_Rs,                do16_rdrs},
  {"madl",      0x38000002, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"madl.fs",   0x380000c2, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"madl.fs!",  0x100a,     0x700f,     0x380000c2, Rd_Rs,                do16_rdrs},
  {"madu",      0x38000020, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"madu!",     0x1005,     0x700f,     0x38000020, Rd_Rs,                do16_rdrs},
  {"mad.f",     0x38000080, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"max",       0x38000007, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"mazh",      0x38000303, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mazh.f",    0x38000383, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mazh.f!",   0x1009,     0x700f,     0x3800038c, Rd_Rs,                do16_rdrs},
  {"mazl",      0x38000102, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mazl.f",    0x38000182, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mazl.f!",   0x1008,     0x700f,     0x38000182, Rd_Rs,                do16_rdrs},
  {"mfceh",     0x00000848, 0x3e007fff, 0x8000,     Rd_x_x,               do_rd},
  {"mfceh!",    0x1101,     0x7f0f,     0x00000848, x_Rs,                 do16_rs},
  {"mfcehl",    0x00000c48, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mfsr",      0x00000050, 0x3e0003ff, 0x8000,     Rd_x_I5,              do_rdsrs},
  {"mfcr",      0x0c000001, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mfc1",      0x0c000009, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mfc2",      0x0c000011, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mfc3",      0x0c000019, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mfcc1",     0x0c00000f, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mfcc2",     0x0c000017, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mfcc3",     0x0c00001f, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mhfl!",     0x0002,     0x700f,     0x00003c56, Rd_LowRs,             do16_hrdrs},
  {"min",       0x38000006, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"mlfh!",     0x0001,     0x700f,     0x00003c56, Rd_HighRs,            do16_rdhrs},
  {"msb",       0x38000001, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"msb.f!",    0x1006,     0x700f,     0x38000081, Rd_Rs,                do16_rdrs},
  {"msbh",      0x38000205, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"msbh.fs",   0x380002c5, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"msbh.fs!",  0x100f,     0x700f,     0x380002c5, Rd_Rs,                do16_rdrs},
  {"msbl",      0x38000004, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"msbl.fs",   0x380000c4, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"msbl.fs!",  0x100e,     0x700f,     0x380000c4, Rd_Rs,                do16_rdrs},
  {"msbu",      0x38000021, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"msbu!",     0x1007,     0x700f,     0x38000021, Rd_Rs,                do16_rdrs},
  {"msb.f",     0x38000081, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mszh",      0x38000305, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mszh.f",    0x38000385, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mszh.f!",   0x100d,     0x700f,     0x38000385, Rd_Rs,                do16_rdrs},
  {"mszl",      0x38000104, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mszl.f",    0x38000184, 0x3ff003ff, 0x8000,     x_Rs_Rs,              do_rsrs},
  {"mszl.f!",   0x100c,     0x700f,     0x38000184, Rd_Rs,                do16_rdrs},
  {"mtcel!",    0x1000,     0x7f0f,     0x0000044a, x_Rs,                 do16_rs},
  {"mtcel",     0x0000044a, 0x3e007fff, 0x8000,     Rd_x_x,               do_rd},
  {"mtceh",     0x0000084a, 0x3e007fff, 0x8000,     Rd_x_x,               do_rd},
  {"mtceh!",    0x1100,     0x7f0f,     0x0000084a, x_Rs,                 do16_rs},
  {"mtcehl",    0x00000c4a, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mtsr",      0x00000052, 0x3e0003ff, 0x8000,     x_Rs_I5,              do_rdsrs},
  {"mtcr",      0x0c000000, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mtc1",      0x0c000008, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mtc2",      0x0c000010, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mtc3",      0x0c000018, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mtcc1",     0x0c00000e, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mtcc2",     0x0c000016, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mtcc3",     0x0c00001e, 0x3e00001f, 0x8000,     Rd_Rs_x,              do_rdcrs},
  {"mul.f!",    0x1002,     0x700f,     0x00000041, Rd_Rs,                do16_rdrs},
  {"mulu!",     0x1003,     0x700f,     0x00000042, Rd_Rs,                do16_rdrs},
  {"mvcs",      0x00000056, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvcc",      0x00000456, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvgtu",     0x00000856, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvleu",     0x00000c56, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mveq",      0x00001056, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvne",      0x00001456, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvgt",      0x00001856, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvle",      0x00001c56, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvge",      0x00002056, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvlt",      0x00002456, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvmi",      0x00002856, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvpl",      0x00002c56, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvvs",      0x00003056, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mvvc",      0x00003456, 0x3e007fff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"mv",        0x00003c56, 0x3e007fff, 0x0003,     Rd_Rs_x,              do_rdrs},
  {"mv!",       0x0003,     0x700f,     0x00003c56, Rd_Rs,                do16_mv_rdrs},
  {"neg",       0x0000001e, 0x3e0003ff, 0x8000,     Rd_x_Rs,              do_rdxrs},
  {"neg.c",     0x0000001f, 0x3e0003ff, 0x2002,     Rd_x_Rs,              do_rdxrs},
  {"neg!",      0x2002,     0x700f,     0x0000001f, Rd_Rs,                do16_rdrs},
  {"nop",       0x00000000, 0x3e0003ff, 0x0000,     NO_OPD,               do_empty},
  {"not",       0x00000024, 0x3e0003ff, 0x8000,     Rd_Rs_x,              do_rdrs},
  {"not.c",     0x00000025, 0x3e0003ff, 0x2006,     Rd_Rs_x,              do_rdrs},
  {"nop!",      0x0000,     0x700f,     0x00000000, NO16_OPD,               do_empty},
  {"not!",      0x2006,     0x700f,     0x00000025, Rd_Rs,                do16_rdrs},
  {"or",        0x00000022, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"or.c",      0x00000023, 0x3e0003ff, 0x2005,     Rd_Rs_Rs,             do_rdrsrs},
  {"ori",       0x020a0000, 0x3e0e0001, 0x8000,     Rd_I16,               do_rdi16},
  {"ori.c",     0x020a0001, 0x3e0e0001, 0x8000,     Rd_I16,               do_rdi16},
  {"oris",      0x0a0a0000, 0x3e0e0001, 0x8000,     Rd_I16,               do_rdi16},
  {"oris.c",    0x0a0a0001, 0x3e0e0001, 0x8000,     Rd_I16,               do_rdi16},
  {"orri",      0x1a000000, 0x3e000001, 0x8000,     Rd_Rs_I14,            do_rdrsi14},
  {"orri.c",    0x1a000001, 0x3e000001, 0x8000,     Rd_Rs_I14,            do_rdrsi14},
  {"or!",       0x2005,     0x700f,     0x00000023, Rd_Rs,                do16_rdrs},
  {"pflush",    0x0000000a, 0x3e0003ff, 0x8000,     NO_OPD,               do_empty},
  {"pop!",      0x200a,     0x700f,     0x0e000000, Rd_rvalueRs,          do16_push_pop},
  {"push!",     0x200e,     0x700f,     0x06000004, Rd_lvalueRs,          do16_push_pop},
  {"ror",       0x00000038, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"ror.c",     0x00000039, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"rorc.c",    0x0000003b, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"rol",       0x0000003c, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"rol.c",     0x0000003d, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"rolc.c",    0x0000003f, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"rori",      0x00000078, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"rori.c",    0x00000079, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"roric.c",   0x0000007b, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"roli",      0x0000007c, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"roli.c",    0x0000007d, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"rolic.c",   0x0000007f, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"rte",       0x0c000084, 0x3e0003ff, 0x8000,     NO_OPD,               do_empty},
  {"sb!",       0x200f,     0x700f,     0x2e000000, Rd_lvalueRs,          do16_ldst_insn},
  {"sbp!",      0x7007,     0x7007,     0x2e000000, Rd_lvalueBP_I5,       do16_ldst_imm_insn},
  {"asw",       0x0000000e, 0x3e0003ff, 0x8000,     Rd_lvalue32Rs,        do_ldst_atomic},
  {"scb",       0x00000068, 0x3e0003ff, 0x8000,     Rd_lvalueRs_post4,    do_ldst_unalign},
  {"scw",       0x0000006a, 0x3e0003ff, 0x8000,     Rd_lvalueRs_post4,    do_ldst_unalign},
  {"sce",       0x0000006e, 0x3e0003ff, 0x8000,     x_lvalueRs_post4,     do_ldst_unalign},
  {"sdbbp",     0x00000006, 0x3e0003ff, 0x6002,     x_I5_x,               do_xi5x},
  {"sdbbp!",    0x6002,     0x7007,     0x00000006, Rd_I5,                do16_xi5},
  {"sh!",       0x200d,     0x700f,     0x2a000000, Rd_lvalueRs,          do16_ldst_insn},
  {"shp!",      0x7005,     0x7007,     0x2a000000, Rd_lvalueBP_I5,       do16_ldst_imm_insn},
  {"sleep",     0x0c0000c4, 0x3e0003ff, 0x8000,     NO_OPD,               do_empty},
  {"sll",       0x00000030, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"sll.c",     0x00000031, 0x3e0003ff, 0x0008,     Rd_Rs_Rs,             do_rdrsrs},
  {"sll.s",     0x3800004e, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"slli",      0x00000070, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"slli.c",    0x00000071, 0x3e0003ff, 0x6001,     Rd_Rs_I5,             do_rdrsi5},
  {"sll!",      0x0008,     0x700f,     0x00000031, Rd_Rs,                do16_rdrs},
  {"slli!",     0x6001,     0x7007,     0x00000071, Rd_I5,                do16_rdi5},
  {"srl",       0x00000034, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"srl.c",     0x00000035, 0x3e0003ff, 0x000a,     Rd_Rs_Rs,             do_rdrsrs},
  {"sra",       0x00000036, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"sra.c",     0x00000037, 0x3e0003ff, 0x000b,     Rd_Rs_Rs,             do_rdrsrs},
  {"srli",      0x00000074, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"srli.c",    0x00000075, 0x3e0003ff, 0x6003,     Rd_Rs_I5,             do_rdrsi5},
  {"srai",      0x00000076, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"srai.c",    0x00000077, 0x3e0003ff, 0x8000,     Rd_Rs_I5,             do_rdrsi5},
  {"srl!",      0x000a,     0x700f,     0x00000035, Rd_Rs,                do16_rdrs},
  {"sra!",      0x000b,     0x700f,     0x00000037, Rd_Rs,                do16_rdrs},
  {"srli!",     0x6003,     0x7007,     0x00000075, Rd_Rs,                do16_rdi5},
  {"stc1",      0x0c00000b, 0x3e00001f, 0x8000,     Rd_lvalueRs_SI10,     do_ldst_cop},
  {"stc2",      0x0c000013, 0x3e00001f, 0x8000,     Rd_lvalueRs_SI10,     do_ldst_cop},
  {"stc3",      0x0c00001b, 0x3e00001f, 0x8000,     Rd_lvalueRs_SI10,     do_ldst_cop},
  {"sub",       0x00000014, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"sub.c",     0x00000015, 0x3e0003ff, 0x2001,     Rd_Rs_Rs,             do_rdrsrs},
  {"sub.s",     0x38000049, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"subc",      0x00000016, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"subc.c",    0x00000017, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"sub!",      0x2001,     0x700f,     0x00000015, Rd_Rs,                do16_rdrs},
  {"subei!",    0x6080,     0x7087,     0x02000001, Rd_I4,                do16_rdi4},
  {"sw!",       0x200c,     0x700f,     0x28000000, Rd_lvalueRs,          do16_ldst_insn},
  {"swp!",      0x7004,     0x7007,     0x28000000, Rd_lvalueBP_I5,       do16_ldst_imm_insn},
  {"syscall",   0x00000002, 0x3e0003ff, 0x8000,     I15,                  do_i15},
  {"tcs",       0x00000054, 0x3e007fff, 0x0005,     NO_OPD,               do_empty},
  {"tcc",       0x00000454, 0x3e007fff, 0x0105,     NO_OPD,               do_empty},
  {"tcnz",      0x00003854, 0x3e007fff, 0x0e05,     NO_OPD,               do_empty},
  {"tcs!",      0x0005,     0x7f0f,     0x00000054, NO16_OPD,             do_empty},
  {"tcc!",      0x0105,     0x7f0f,     0x00000454, NO16_OPD,             do_empty},
  {"tcnz!",     0x0e05,     0x7f0f,     0x00003854, NO16_OPD,             do_empty},
  {"teq",       0x00001054, 0x3e007fff, 0x0405,     NO_OPD,               do_empty},
  {"teq!",      0x0405,     0x7f0f,     0x00001054, NO16_OPD,             do_empty},
  {"tgtu",      0x00000854, 0x3e007fff, 0x0205,     NO_OPD,               do_empty},
  {"tgt",       0x00001854, 0x3e007fff, 0x0605,     NO_OPD,               do_empty},
  {"tge",       0x00002054, 0x3e007fff, 0x0805,     NO_OPD,               do_empty},
  {"tgtu!",     0x0205,     0x7f0f,     0x00000854, NO16_OPD,             do_empty},
  {"tgt!",      0x0605,     0x7f0f,     0x00001854, NO16_OPD,             do_empty},
  {"tge!",      0x0805,     0x7f0f,     0x00002054, NO16_OPD,             do_empty},
  {"tleu",      0x00000c54, 0x3e007fff, 0x0305,     NO_OPD,               do_empty},
  {"tle",       0x00001c54, 0x3e007fff, 0x0705,     NO_OPD,               do_empty},
  {"tlt",       0x00002454, 0x3e007fff, 0x0905,     NO_OPD,               do_empty},
  {"stlb",      0x0c000004, 0x3e0003ff, 0x8000,     NO_OPD,               do_empty},
  {"mftlb",     0x0c000024, 0x3e0003ff, 0x8000,     NO_OPD,               do_empty},
  {"mtptlb",    0x0c000044, 0x3e0003ff, 0x8000,     NO_OPD,               do_empty},
  {"mtrtlb",    0x0c000064, 0x3e0003ff, 0x8000,     NO_OPD,               do_empty},
  {"tleu!",     0x0305,     0x7f0f,     0x00000c54, NO16_OPD,             do_empty},
  {"tle!",      0x0705,     0x7f0f,     0x00001c54, NO16_OPD,             do_empty},
  {"tlt!",      0x0905,     0x7f0f,     0x00002454, NO16_OPD,             do_empty},
  {"tmi",       0x00002854, 0x3e007fff, 0x0a05,     NO_OPD,               do_empty},
  {"tmi!",      0x0a05,     0x7f0f,     0x00002854, NO16_OPD,             do_empty},
  {"tne",       0x00001454, 0x3e007fff, 0x0505,     NO_OPD,               do_empty},
  {"tne!",      0x0505,     0x7f0f,     0x00001454, NO16_OPD,             do_empty},
  {"tpl",       0x00002c54, 0x3e007fff, 0x0b05,     NO_OPD,               do_empty},
  {"tpl!",      0x0b05,     0x7f0f,     0x00002c54, NO16_OPD,             do_empty},
  {"trapcs",    0x00000004, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapcc",    0x00000404, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapgtu",   0x00000804, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapleu",   0x00000c04, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapeq",    0x00001004, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapne",    0x00001404, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapgt",    0x00001804, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"traple",    0x00001c04, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapge",    0x00002004, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"traplt",    0x00002404, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapmi",    0x00002804, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trappl",    0x00002c04, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapvs",    0x00003004, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trapvc",    0x00003404, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"trap",      0x00003c04, 0x3e007fff, 0x8000,     x_I5_x,               do_xi5x},
  {"tset",      0x00003c54, 0x3e007fff, 0x0f05,     NO_OPD,               do_empty},
  {"tset!",     0x0f05,     0x00007f0f, 0x00003c54, NO16_OPD,             do_empty},
  {"tvs",       0x00003054, 0x3e007fff, 0x0c05,     NO_OPD,               do_empty},
  {"tvc",       0x00003454, 0x3e007fff, 0x0d05,     NO_OPD,               do_empty},
  {"tvs!",      0x0c05,     0x7f0f,     0x00003054, NO16_OPD,             do_empty},
  {"tvc!",      0x0d05,     0x7f0f,     0x00003454, NO16_OPD,             do_empty},
  {"xor",       0x00000026, 0x3e0003ff, 0x8000,     Rd_Rs_Rs,             do_rdrsrs},
  {"xor.c",     0x00000027, 0x3e0003ff, 0x2007,     Rd_Rs_Rs,             do_rdrsrs},
  {"xor!",      0x2007,     0x700f,     0x00000027, Rd_Rs,                do16_rdrs},
d954 2
a955 1
  {"li",        0x020c0000, 0x3e0e0000, 0x8000,     Insn_Type_SYN,        do_macro_li_rdi32},
d962 24
a985 19
  {"la",        0x020c0000, 0x3e0e0000, 0x8000,     Insn_Type_SYN,        do_macro_la_rdi32},
  {"div",       0x00000044, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"divu",      0x00000046, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"rem",       0x00000044, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"remu",      0x00000046, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"mul",       0x00000040, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"mulu",      0x00000042, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"maz",       0x00000040, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"mazu",      0x00000042, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"mul.f",     0x00000041, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"maz.f",     0x00000041, 0x3e0003ff, 0x8000,     Insn_Type_SYN,        do_macro_mul_rdrsrs},
  {"lb",        INSN_LB,    0x00000000, 0x8000,     Insn_Type_SYN,        do_macro_ldst_label},
  {"lbu",       INSN_LBU,   0x00000000, 0x200b,     Insn_Type_SYN,        do_macro_ldst_label},
  {"lh",        INSN_LH,    0x00000000, 0x2009,     Insn_Type_SYN,        do_macro_ldst_label},
  {"lhu",       INSN_LHU,   0x00000000, 0x8000,     Insn_Type_SYN,        do_macro_ldst_label},
  {"lw",        INSN_LW,    0x00000000, 0x2008,     Insn_Type_SYN,        do_macro_ldst_label},
  {"sb",        INSN_SB,    0x00000000, 0x200f,     Insn_Type_SYN,        do_macro_ldst_label},
  {"sh",        INSN_SH,    0x00000000, 0x200d,     Insn_Type_SYN,        do_macro_ldst_label},
  {"sw",        INSN_SW,    0x00000000, 0x200c,     Insn_Type_SYN,        do_macro_ldst_label},
d987 16
a1002 6
  {"ld_i32hi",  0x0a0c0000, 0x3e0e0000, 0x8000,     Insn_internal, do_macro_rdi32hi},
  {"ld_i32lo",  0x020a0000, 0x3e0e0001, 0x8000,     Insn_internal, do_macro_rdi32lo},
  {"ldis_pic",  0x0a0c0000, 0x3e0e0000, 0x5000,     Insn_internal, do_rdi16_pic},
  {"addi_s_pic",0x02000000, 0x3e0e0001, 0x8000,     Insn_internal, do_addi_s_pic},
  {"addi_u_pic",0x02000000, 0x3e0e0001, 0x8000,     Insn_internal, do_addi_u_pic},
  {"lw_pic",    0x20000000, 0x3e000000, 0x8000,     Insn_internal, do_lw_pic},
d1005 1
a1005 2
/* Next free entry in the pool.  */
int next_literal_pool_place = 0;
d1007 3
a1009 3
/* Next literal pool number.  */
int lit_pool_num = 1;
symbolS *current_poolP = NULL;
d1011 1
d1014 1
a1014 1
end_of_line (char *str)
d1016 1
a1016 1
  int retval = SUCCESS;
d1018 1
a1018 1
  skip_whitespace (str);
d1021 1
a1021 1
      retval = (int) FAIL;
d1023 2
a1024 2
      if (!inst.error)
        inst.error = BAD_GARBAGE;
d1031 1
a1031 1
score_reg_parse (char **ccp, struct hash_control *htab)
d1036 1
a1036 1
  struct reg_entry *reg;
d1040 1
a1040 1
    return (int) FAIL;
d1048 1
a1048 1
  reg = (struct reg_entry *) hash_find (htab, start);
d1056 1
a1056 1
  return (int) FAIL;
d1062 1
a1062 1
reg_required_here (char **str, int shift, enum score_reg_type reg_type)
d1064 2
a1065 2
  static char buff[MAX_LITERAL_POOL_SIZE];
  int reg = (int) FAIL;
d1068 1
a1068 1
  if ((reg = score_reg_parse (str, all_reg_maps[reg_type].htab)) != (int) FAIL)
d1070 1
a1070 1
      if (reg_type == REG_TYPE_SCORE)
d1072 1
a1072 1
          if ((reg == 1) && (nor1 == 1) && (inst.bwarn == 0))
d1075 1
a1075 1
              inst.bwarn = 1;
d1080 4
a1083 4
          if (reg_type == REG_TYPE_SCORE_CR)
	    strcpy (inst.reg, score_crn_table[reg].name);
          else if (reg_type == REG_TYPE_SCORE_SR)
	    strcpy (inst.reg, score_srn_table[reg].name);
d1085 1
a1085 1
	    strcpy (inst.reg, "");
d1087 1
a1087 1
          inst.instruction |= reg << shift;
d1094 1
a1094 1
      inst.error = buff;
d1101 1
a1101 1
skip_past_comma (char **str)
d1112 2
a1113 2
          inst.error = BAD_SKIP_COMMA;
          return (int) FAIL;
d1119 2
a1120 2
      inst.error = BAD_SKIP_COMMA;
      return (int) FAIL;
d1124 1
a1124 1
  return comma ? SUCCESS : (int) FAIL;
d1128 1
a1128 1
do_rdrsrs (char *str)
d1130 2
a1131 1
  skip_whitespace (str);
d1133 6
a1138 6
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 10, REG_TYPE_SCORE) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d1144 4
a1147 5
      if ((((inst.instruction >> 15) & 0x10) == 0)
          && (((inst.instruction >> 10) & 0x10) == 0)
          && (((inst.instruction >> 20) & 0x10) == 0)
          && (inst.relax_inst != 0x8000)
          && (((inst.instruction >> 20) & 0xf) == ((inst.instruction >> 15) & 0xf)))
d1149 13
a1161 3
          inst.relax_inst |= (((inst.instruction >> 10) & 0xf) << 4)
            | (((inst.instruction >> 15) & 0xf) << 8);
          inst.relax_size = 2;
d1165 1
a1165 1
          inst.relax_inst = 0x8000;
d1171 1
a1171 1
walk_no_bignums (symbolS * sp)
d1177 1
a1177 1
    return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
d1179 1
a1179 1
		&& walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));  
d1185 1
a1185 1
my_get_expression (expressionS * ep, char **str)
d1192 1
a1192 1
  in_my_get_expression = 1;
d1194 1
a1194 1
  in_my_get_expression = 0;
d1200 2
a1201 2
      inst.error = _("illegal expression");
      return (int) FAIL;
d1208 2
a1209 2
          && (walk_no_bignums (ep->X_add_symbol)
              || (ep->X_op_symbol && walk_no_bignums (ep->X_op_symbol)))))
d1211 1
a1211 1
      inst.error = _("invalid constant");
d1214 1
a1214 1
      return (int) FAIL;
d1218 11
a1228 8
      && (inst.type != PC_DISP19div2)
      && (inst.type != PC_DISP8div2)
      && (inst.type != PC_DISP24div2)
      && (inst.type != PC_DISP11div2)
      && (inst.type != Insn_Type_SYN)
      && (inst.type != Rd_rvalueRs_SI15)
      && (inst.type != Rd_lvalueRs_SI15)
      && (inst.type != Insn_internal))
d1230 1
a1230 1
      inst.error = BAD_ARGS;
d1233 1
a1233 1
      return (int) FAIL;
d1238 1
a1238 1
  return SUCCESS;
d1242 2
a1243 3

static int
validate_immediate (int val, unsigned int data_type, int hex_p)
d1249 1
a1249 1
        int val_hi = ((val & 0xffff0000) >> 16);
d1251 2
a1252 2
        if (score_df_range[data_type].range[0] <= val_hi
            && val_hi <= score_df_range[data_type].range[1])
d1259 1
a1259 1
        int val_lo = (val & 0xffff);
d1261 2
a1262 2
        if (score_df_range[data_type].range[0] <= val_lo
            && val_lo <= score_df_range[data_type].range[1])
a1266 4
    case _VALUE:
      return val;
      break;

d1272 1
a1272 1
              return (int) FAIL;
d1279 1
a1279 1
              return (int) FAIL;
d1291 1
a1291 1
              return (int) FAIL;
d1298 1
a1298 1
              return (int) FAIL;
d1306 25
d1335 2
a1336 2
      if (score_df_range[data_type].range[0] <= val
          && val <= score_df_range[data_type].range[1])
d1342 1
a1342 1
  return (int) FAIL;
d1346 1
a1346 1
data_op2 (char **str, int shift, enum score_data_type data_type)
d1348 2
a1349 2
  int value;
  char data_exp[MAX_LITERAL_POOL_SIZE];
d1354 2
a1355 2
  skip_whitespace (*str);
  inst.error = NULL;
d1361 1
a1361 1
  while ((*dataptr != '\0') && (*dataptr != '|') && (cnt <= MAX_LITERAL_POOL_SIZE))     /* 0x7c = ='|' */
d1373 5
a1377 5
      if (my_get_expression (&inst.reloc.exp, &pp) == (int) FAIL)
        return (int) FAIL;
      end_of_line (pp);
      if (inst.error != 0)
        return (int) FAIL;       /* to ouptut_inst to printf out the error */
d1382 1
a1382 1
      if (my_get_expression (&inst.reloc.exp, str) == (int) FAIL)
d1384 1
a1384 1
          return (int) FAIL;
d1396 1
a1396 1
      if ((dataptr != NULL)
d1399 1
a1399 1
        {
d1409 2
d1418 5
a1422 1
              && (data_type != _GP_IMM15))
d1428 5
a1432 5
      if ((inst.reloc.exp.X_add_number == 0)
          && (inst.type != Insn_Type_SYN)
          && (inst.type != Rd_rvalueRs_SI15)
          && (inst.type != Rd_lvalueRs_SI15)
          && (inst.type != Insn_internal)
d1438 2
a1439 2
          inst.error = BAD_ARGS;
          return (int) FAIL;
d1443 1
a1443 1
  if ((inst.reloc.exp.X_add_symbol)
d1450 2
d1458 2
a1459 2
      inst.error = BAD_ARGS;
      return (int) FAIL;
d1462 1
a1462 1
  if (inst.reloc.exp.X_add_symbol)
d1467 1
a1467 1
          return (int) FAIL;
d1469 2
a1470 2
          inst.reloc.type = BFD_RELOC_HI16_S;
          inst.reloc.pc_rel = 0;
d1473 2
a1474 2
          inst.reloc.type = BFD_RELOC_LO16;
          inst.reloc.pc_rel = 0;
d1477 2
a1478 2
          inst.reloc.type = BFD_RELOC_SCORE_GPREL15;
          inst.reloc.pc_rel = 0;
d1482 2
a1483 2
          inst.reloc.type = BFD_RELOC_SCORE_GOT_LO16;
          inst.reloc.pc_rel = 0;
d1486 2
a1487 2
          inst.reloc.type = BFD_RELOC_32;
          inst.reloc.pc_rel = 0;
d1495 2
a1496 2
          inst.reloc.type = BFD_RELOC_SCORE_DUMMY_HI16;
          inst.reloc.pc_rel = 0;
d1499 1
a1499 1
      if (data_type == _SIMM16_LA && inst.reloc.exp.X_unsigned == 1)
d1501 3
a1503 3
          value = validate_immediate (inst.reloc.exp.X_add_number, _SIMM16_LA_POS, hex_p);
          if (value == (int) FAIL)       /* for advance to check if this is ldis */
            if ((inst.reloc.exp.X_add_number & 0xffff) == 0)
d1505 3
a1507 3
                inst.instruction |= 0x8000000;
                inst.instruction |= ((inst.reloc.exp.X_add_number >> 16) << 1) & 0x1fffe;
                return SUCCESS;
d1512 1
a1512 1
          value = validate_immediate (inst.reloc.exp.X_add_number, data_type, hex_p);
d1515 1
a1515 1
      if (value == (int) FAIL)
d1517 14
a1530 1
          if ((data_type != _SIMM14_NEG) && (data_type != _SIMM16_NEG) && (data_type != _IMM16_NEG))
d1532 1
a1532 1
              sprintf (err_msg,
d1534 2
a1535 2
                       score_df_range[data_type].bits,
                       score_df_range[data_type].range[0], score_df_range[data_type].range[1]);
d1539 1
a1539 1
              sprintf (err_msg,
d1541 2
a1542 2
                       score_df_range[data_type].bits,
                       -score_df_range[data_type].range[1], -score_df_range[data_type].range[0]);
d1545 2
a1546 2
          inst.error = err_msg;
          return (int) FAIL;
d1549 2
a1550 1
      if ((score_df_range[data_type].range[0] != 0) || (data_type == _IMM5_RANGE_8_31))
d1552 1
a1552 1
          value &= (1 << score_df_range[data_type].bits) - 1;
d1555 1
a1555 1
      inst.instruction |= value << shift;
d1558 1
a1558 1
  if ((inst.instruction & 0xf0000000) == 0x30000000)
d1560 4
a1563 20
      if ((((inst.instruction >> 20) & 0x1F) != 0)
          && (((inst.instruction >> 20) & 0x1F) != 1)
          && (((inst.instruction >> 20) & 0x1F) != 2)
          && (((inst.instruction >> 20) & 0x1F) != 3)
          && (((inst.instruction >> 20) & 0x1F) != 4)
          && (((inst.instruction >> 20) & 0x1F) != 8)
          && (((inst.instruction >> 20) & 0x1F) != 9)
          && (((inst.instruction >> 20) & 0x1F) != 0xa)
          && (((inst.instruction >> 20) & 0x1F) != 0xb)
          && (((inst.instruction >> 20) & 0x1F) != 0xc)
          && (((inst.instruction >> 20) & 0x1F) != 0xd)
          && (((inst.instruction >> 20) & 0x1F) != 0xe)
          && (((inst.instruction >> 20) & 0x1F) != 0x10)
          && (((inst.instruction >> 20) & 0x1F) != 0x11)
          && (((inst.instruction >> 20) & 0x1F) != 0x18)
          && (((inst.instruction >> 20) & 0x1F) != 0x1A)
          && (((inst.instruction >> 20) & 0x1F) != 0x1B)
          && (((inst.instruction >> 20) & 0x1F) != 0x1d)
          && (((inst.instruction >> 20) & 0x1F) != 0x1e)
          && (((inst.instruction >> 20) & 0x1F) != 0x1f))
d1565 2
a1566 2
          inst.error = _("invalid constant: bit expression not defined");
          return (int) FAIL;
d1570 1
a1570 1
  return SUCCESS;
a1573 1

d1575 1
a1575 1
do_rdsi16 (char *str)
d1577 1
a1577 1
  skip_whitespace (str);
d1579 4
a1582 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || data_op2 (&str, 1, _SIMM16) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d1585 2
a1586 2
  /* ldi.  */
  if ((inst.instruction & 0x20c0000) == 0x20c0000)
d1588 1
a1588 1
      if ((((inst.instruction >> 20) & 0x10) == 0x10) || ((inst.instruction & 0x1fe00) != 0))
d1590 1
a1590 1
          inst.relax_inst = 0x8000;
d1594 3
a1596 3
          inst.relax_inst |= (inst.instruction >> 1) & 0xff;
          inst.relax_inst |= (((inst.instruction >> 20) & 0xf) << 8);
          inst.relax_size = 2;
d1599 2
a1600 1
  else if (((inst.instruction >> 20) & 0x10) == 0x10)
d1602 34
a1635 1
      inst.relax_inst = 0x8000;
d1639 12
d1652 10
d1663 1
d1665 1
a1665 1
do_sub_rdsi16 (char *str)
d1667 1
a1667 1
  skip_whitespace (str);
d1669 4
a1672 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && data_op2 (&str, 1, _SIMM16_NEG) != (int) FAIL)
    end_of_line (str);
a1675 1

d1677 1
a1677 1
do_rdrssi14 (char *str)         /* -(2^13)~((2^13)-1) */
d1679 1
a1679 1
  skip_whitespace (str);
d1681 5
a1685 5
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && reg_required_here (&str, 15, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL)
    data_op2 (&str, 1, _SIMM14);
d1690 1
a1690 1
do_sub_rdrssi14 (char *str)     /* -(2^13)~((2^13)-1) */
d1692 1
a1692 1
  skip_whitespace (str);
d1694 6
a1699 6
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && reg_required_here (&str, 15, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && data_op2 (&str, 1, _SIMM14_NEG) != (int) FAIL)
    end_of_line (str);
d1702 2
a1703 1
/* Handle bitclr.c/bitset.c/bittgl.c/slli.c/srai.c/srli.c/roli.c/rori.c/rolic.c.  */
d1705 1
a1705 1
do_rdrsi5 (char *str)           /* 0~((2^14)-1) */
d1707 1
a1707 1
  skip_whitespace (str);
d1709 6
a1714 6
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || data_op2 (&str, 10, _IMM5) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d1717 2
a1718 2
  if ((((inst.instruction >> 20) & 0x1f) == ((inst.instruction >> 15) & 0x1f))
      && (inst.relax_inst != 0x8000) && (((inst.instruction >> 15) & 0x10) == 0))
d1720 2
a1721 2
      inst.relax_inst |= (((inst.instruction >> 10) & 0x1f) << 3) | (((inst.instruction >> 15) & 0xf) << 8);
      inst.relax_size = 2;
d1724 1
a1724 1
    inst.relax_inst = 0x8000;
d1727 2
a1728 2
/* Handle andri/orri/andri.c/orri.c.  */

d1730 1
a1730 1
do_rdrsi14 (char *str)          /* 0 ~ ((2^14)-1)  */
d1732 1
a1732 1
  skip_whitespace (str);
d1734 6
a1739 6
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && reg_required_here (&str, 15, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && data_op2 (&str, 1, _IMM14) != (int) FAIL)
    end_of_line (str);
d1744 1
a1744 1
do_xrsi5 (char *str)
d1746 1
a1746 1
  skip_whitespace (str);
d1748 4
a1751 4
  if (reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || data_op2 (&str, 10, _IMM5) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d1754 1
a1754 1
  if ((inst.relax_inst != 0x8000) && (((inst.instruction >> 15) & 0x10) == 0))
d1756 2
a1757 2
      inst.relax_inst |= (((inst.instruction >> 10) & 0x1f) << 3) | (((inst.instruction >> 15) & 0xf) << 8);
      inst.relax_size = 2;
d1760 1
a1760 1
    inst.relax_inst = 0x8000;
d1765 1
a1765 1
do_rdi16 (char *str)
d1767 1
a1767 1
  skip_whitespace (str);
d1769 4
a1772 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || data_op2 (&str, 1, _IMM16) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d1774 36
a1809 6
  /*
  if (((inst.instruction & 0xa0dfffe) != 0xa0c0000) || ((((inst.instruction >> 20) & 0x1f) & 0x10) == 0x10))
    inst.relax_inst = 0x8000;
  else
    inst.relax_size = 2;
  */
d1813 1
a1813 1
do_macro_rdi32hi (char *str)
d1815 1
a1815 1
  skip_whitespace (str);
d1817 4
a1820 4
  /* Do not handle end_of_line().  */
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL)
    data_op2 (&str, 1, _VALUE_HI16);
d1824 1
a1824 1
do_macro_rdi32lo (char *str)
d1826 1
a1826 1
  skip_whitespace (str);
d1828 4
a1831 4
  /* Do not handle end_of_line().  */
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL)
    data_op2 (&str, 1, _VALUE_LO16);
a1834 1

d1836 1
a1836 1
do_rdi16_pic (char *str)
d1838 1
a1838 1
  skip_whitespace (str);
d1840 4
a1843 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && data_op2 (&str, 1, _IMM16_pic) != (int) FAIL)
    end_of_line (str);
a1846 1

d1848 1
a1848 1
do_addi_s_pic (char *str)
d1850 1
a1850 1
  skip_whitespace (str);
d1852 4
a1855 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && data_op2 (&str, 1, _SIMM16_pic) != (int) FAIL)
    end_of_line (str);
a1858 1

d1860 1
a1860 1
do_addi_u_pic (char *str)
d1862 1
a1862 1
  skip_whitespace (str);
d1864 4
a1867 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && data_op2 (&str, 1, _IMM16_LO16_pic) != (int) FAIL)
    end_of_line (str);
a1870 1

d1872 1
a1872 1
do_rd (char *str)
d1874 1
a1874 1
  skip_whitespace (str);
d1876 2
a1877 2
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL)
    end_of_line (str);
d1880 1
d1882 1
a1882 1
do_rs (char *str)
d1884 1
a1884 1
  skip_whitespace (str);
d1886 2
a1887 2
  if (reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d1890 1
a1890 1
  if ((inst.relax_inst != 0x8000) && (((inst.instruction >> 15) & 0x10) == 0))
d1892 2
a1893 2
      inst.relax_inst |= (((inst.instruction >> 10) & 0xf) << 8) | (((inst.instruction >> 15) & 0xf) << 4);
      inst.relax_size = 2;
d1896 1
a1896 1
    inst.relax_inst = 0x8000;
d1900 1
a1900 1
do_i15 (char *str)
d1902 1
a1902 1
  skip_whitespace (str);
d1904 2
a1905 2
  if (data_op2 (&str, 10, _IMM15) != (int) FAIL)
    end_of_line (str);
d1909 1
a1909 1
do_xi5x (char *str)
d1911 1
a1911 1
  skip_whitespace (str);
d1913 1
a1913 1
  if (data_op2 (&str, 15, _IMM5) == (int) FAIL || end_of_line (str) == (int) FAIL)
d1916 1
a1916 1
  if (inst.relax_inst != 0x8000)
d1918 2
a1919 2
      inst.relax_inst |= (((inst.instruction >> 15) & 0x1f) << 3);
      inst.relax_size = 2;
d1924 1
a1924 1
do_rdrs (char *str)
d1926 1
a1926 1
  skip_whitespace (str);
d1928 4
a1931 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d1934 1
a1934 1
  if (inst.relax_inst != 0x8000)
d1936 1
a1936 1
      if (((inst.instruction & 0x7f) == 0x56))  /* adjust mv -> mv! / mlfh! / mhfl! */
d1938 4
a1941 24
          /* mlfh */
          if ((((inst.instruction >> 15) & 0x10) != 0x0) && (((inst.instruction >> 20) & 0x10) == 0))
            {
              inst.relax_inst = 0x00000001 | (((inst.instruction >> 15) & 0xf) << 4)
                | (((inst.instruction >> 20) & 0xf) << 8);
              inst.relax_size = 2;
            }
          /* mhfl */
          else if ((((inst.instruction >> 15) & 0x10) == 0x0) && ((inst.instruction >> 20) & 0x10) != 0)
            {
              inst.relax_inst = 0x00000002 | (((inst.instruction >> 15) & 0xf) << 4)
                | (((inst.instruction >> 20) & 0xf) << 8);
              inst.relax_size = 2;
            }
          else if ((((inst.instruction >> 15) & 0x10) == 0x0) && (((inst.instruction >> 20) & 0x10) == 0))
            {
              inst.relax_inst |= (((inst.instruction >> 15) & 0xf) << 4)
                | (((inst.instruction >> 20) & 0xf) << 8);
              inst.relax_size = 2;
            }
          else
            {
              inst.relax_inst = 0x8000;
            }
d1943 1
a1943 1
      else if ((((inst.instruction >> 15) & 0x10) == 0x0) && (((inst.instruction >> 20) & 0x10) == 0))
d1945 3
a1947 3
          inst.relax_inst |= (((inst.instruction >> 15) & 0xf) << 4)
            | (((inst.instruction >> 20) & 0xf) << 8);
          inst.relax_size = 2;
d1951 1
a1951 1
          inst.relax_inst = 0x8000;
d1958 1
a1958 1
do_rdcrs (char *str)
d1960 1
a1960 1
  skip_whitespace (str);
d1962 4
a1965 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && reg_required_here (&str, 15, REG_TYPE_SCORE_CR) != (int) FAIL)
    end_of_line (str);
a1968 1

d1970 1
a1970 1
do_rdsrs (char *str)
d1972 1
a1972 1
  skip_whitespace (str);
d1975 1
a1975 1
  if ((inst.instruction & 0xff) == 0x50)
d1977 4
a1980 4
      if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
          && skip_past_comma (&str) != (int) FAIL
          && reg_required_here (&str, 10, REG_TYPE_SCORE_SR) != (int) FAIL)
	end_of_line (str);
d1984 3
a1986 3
      if (reg_required_here (&str, 15, REG_TYPE_SCORE) != (int) FAIL
          && skip_past_comma (&str) != (int) FAIL)
	reg_required_here (&str, 10, REG_TYPE_SCORE_SR);
a1990 1

d1992 1
a1992 1
do_rdxrs (char *str)
d1994 1
a1994 1
  skip_whitespace (str);
d1996 4
a1999 4
  if (reg_required_here (&str, 20, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 10, REG_TYPE_SCORE) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d2002 2
a2003 2
  if ((inst.relax_inst != 0x8000) && (((inst.instruction >> 10) & 0x10) == 0)
      && (((inst.instruction >> 20) & 0x10) == 0))
d2005 2
a2006 2
      inst.relax_inst |= (((inst.instruction >> 10) & 0xf) << 4) | (((inst.instruction >> 20) & 0xf) << 8);
      inst.relax_size = 2;
d2009 1
a2009 1
    inst.relax_inst = 0x8000;
d2014 1
a2014 1
do_rsrs (char *str)
d2016 1
a2016 1
  skip_whitespace (str);
d2018 4
a2021 4
  if (reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 10, REG_TYPE_SCORE) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d2024 1
a2024 2
  if ((inst.relax_inst != 0x8000) && (((inst.instruction >> 20) & 0x1f) == 3)
      && (((inst.instruction >> 10) & 0x10) == 0) && (((inst.instruction >> 15) & 0x10) == 0))
d2026 2
a2027 2
      inst.relax_inst |= (((inst.instruction >> 10) & 0xf) << 4) | (((inst.instruction >> 15) & 0xf) << 8);
      inst.relax_size = 2;
d2030 1
a2030 1
    inst.relax_inst = 0x8000;
d2034 1
a2034 1
do_ceinst (char *str)
d2039 1
a2039 1
  skip_whitespace (str);
d2041 10
a2050 10
  if (data_op2 (&str, 20, _IMM5) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 10, REG_TYPE_SCORE) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || data_op2 (&str, 5, _IMM5) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || data_op2 (&str, 0, _IMM5) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d2057 1
a2057 1
      if (data_op2 (&str, 0, _IMM25) == (int) FAIL)
d2063 1
a2063 1
reglow_required_here (char **str, int shift)
d2065 1
a2065 1
  static char buff[MAX_LITERAL_POOL_SIZE];
d2069 1
a2069 1
  if ((reg = score_reg_parse (str, all_reg_maps[REG_TYPE_SCORE].htab)) != (int) FAIL)
d2071 1
a2071 1
      if ((reg == 1) && (nor1 == 1) && (inst.bwarn == 0))
d2074 1
a2074 1
          inst.bwarn = 1;
d2079 1
a2079 1
            inst.instruction |= reg << shift;
d2088 2
a2089 2
  inst.error = buff;
  return (int) FAIL;
d2092 1
a2092 1
/* Handle addc!/add!/and!/cmp!/neg!/not!/or!/sll!/srl!/sra!/xor!/sub!.  */
d2094 1
a2094 1
do16_rdrs (char *str)
d2096 1
a2096 1
  skip_whitespace (str);
d2098 4
a2101 4
  if (reglow_required_here (&str, 8) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reglow_required_here (&str, 4) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d2105 10
a2114 1
  else
d2116 1
a2116 16
      if ((inst.instruction & 0x700f) == 0x2003)        /* cmp!  */
        {
          inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 15)
            | (((inst.instruction >> 4) & 0xf) << 10);
        }
      else if ((inst.instruction & 0x700f) == 0x2006)   /* not!  */
	{
	  inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
	    | (((inst.instruction >> 4) & 0xf) << 15);
	}
      else
        {
          inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
            | (((inst.instruction >> 8) & 0xf) << 15) | (((inst.instruction >> 4) & 0xf) << 10);
        }
      inst.relax_size = 4;
d2120 1
d2122 1
a2122 1
do16_rs (char *str)
d2126 1
a2126 1
  skip_whitespace (str);
d2128 2
a2129 2
  if ((rd = reglow_required_here (&str, 4)) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
a2132 5
  else
    {
      inst.relax_inst |= rd << 20;
      inst.relax_size = 4;
    }
d2135 1
a2135 1
/* Handle br!/brl!.  */
d2137 1
a2137 1
do16_xrs (char *str)
d2139 13
a2151 1
  skip_whitespace (str);
d2153 3
a2155 1
  if (reglow_required_here (&str, 4) == (int) FAIL || end_of_line (str) == (int) FAIL)
d2159 3
a2161 1
  else
d2163 2
a2164 3
      inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 10)
                      | (((inst.instruction >> 4) & 0xf) << 15);
      inst.relax_size = 4;
d2168 3
a2170 61
static int
reghigh_required_here (char **str, int shift)
{
  static char buff[MAX_LITERAL_POOL_SIZE];
  int reg;
  char *start = *str;

  if ((reg = score_reg_parse (str, all_reg_maps[REG_TYPE_SCORE].htab)) != (int) FAIL)
    {
      if (15 < reg && reg < 32)
        {
          if (shift >= 0)
            inst.instruction |= (reg & 0xf) << shift;

          return reg;
        }
    }

  *str = start;
  sprintf (buff, _("high register(r16-r31)expected, not '%.100s'"), start);
  inst.error = buff;
  return (int) FAIL;
}

/* Handle mhfl!.  */
static void
do16_hrdrs (char *str)
{
  skip_whitespace (str);

  if (reghigh_required_here (&str, 8) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && reglow_required_here (&str, 4) != (int) FAIL
      && end_of_line (str) != (int) FAIL)
    {
      inst.relax_inst |= ((((inst.instruction >> 8) & 0xf) | 0x10) << 20)
        | (((inst.instruction >> 4) & 0xf) << 15) | (0xf << 10);
      inst.relax_size = 4;
    }
}

/* Handle mlfh!.  */
static void
do16_rdhrs (char *str)
{
  skip_whitespace (str);

  if (reglow_required_here (&str, 8) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && reghigh_required_here (&str, 4) != (int) FAIL
      && end_of_line (str) != (int) FAIL)
    {
      inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
        | ((((inst.instruction >> 4) & 0xf) | 0x10) << 15) | (0xf << 10);
      inst.relax_size = 4;
    }
}

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
d2175 1
a2175 1
fix_new_score (fragS * frag, int where, short int size, expressionS * exp, int pc_rel, int reloc)
d2195 1
a2195 1
init_dependency_vector (void)
d2199 2
a2200 2
  for (i = 0; i < vector_size; i++)
    memset (&dependency_vector[i], '\0', sizeof (dependency_vector[i]));
d2205 2
a2206 2
static enum insn_type_for_dependency
dependency_type_from_insn (char *insn_name)
d2208 2
a2209 2
  char name[INSN_NAME_LEN];
  const struct insn_to_dependency *tmp;
d2212 1
a2212 1
  tmp = (const struct insn_to_dependency *) hash_find (dependency_insn_hsh, name);
d2217 1
a2217 1
  return D_all_insn;
d2221 1
a2221 1
check_dependency (char *pre_insn, char *pre_reg,
d2226 2
a2227 2
  enum insn_type_for_dependency pre_insn_type;
  enum insn_type_for_dependency cur_insn_type;
d2229 2
a2230 2
  pre_insn_type = dependency_type_from_insn (pre_insn);
  cur_insn_type = dependency_type_from_insn (cur_insn);
d2232 1
a2232 1
  for (i = 0; i < sizeof (data_dependency_table) / sizeof (data_dependency_table[0]); i++)
d2234 7
a2240 7
      if ((pre_insn_type == data_dependency_table[i].pre_insn_type)
          && (D_all_insn == data_dependency_table[i].cur_insn_type
              || cur_insn_type == data_dependency_table[i].cur_insn_type)
          && (strcmp (data_dependency_table[i].pre_reg, "") == 0
              || strcmp (data_dependency_table[i].pre_reg, pre_reg) == 0)
          && (strcmp (data_dependency_table[i].cur_reg, "") == 0
              || strcmp (data_dependency_table[i].cur_reg, cur_reg) == 0))
d2242 2
a2243 2
          bubbles = (score7) ? data_dependency_table[i].bubblenum_7 : data_dependency_table[i].bubblenum_5;
          *warn_or_error = data_dependency_table[i].warn_or_error;
d2252 1
a2252 1
build_one_frag (struct score_it one_inst)
d2255 1
a2255 1
  int relaxable_p = g_opt;
d2269 1
a2269 1
  md_number_to_chars (p, one_inst.instruction, one_inst.size);
d2278 2
a2279 2
  p = frag_var (rs_machine_dependent, relax_size + RELAX_PAD_BYTE, 0,
                RELAX_ENCODE (one_inst.size, one_inst.relax_size,
d2284 1
a2284 1
    md_number_to_chars (p, one_inst.relax_inst, relax_size);
d2288 1
a2288 1
handle_dependency (struct score_it *theinst)
d2294 4
a2297 4
  char cur_insn[INSN_NAME_LEN];
  char pre_insn[INSN_NAME_LEN];
  struct score_it nop_inst;
  struct score_it pflush_inst;
d2314 1
a2314 1
      init_dependency_vector ();
d2318 3
a2320 3
  /* Push current instruction to dependency_vector[0].  */
  for (i = vector_size - 1; i > 0; i--)
    memcpy (&dependency_vector[i], &dependency_vector[i - 1], sizeof (dependency_vector[i]));
d2322 1
a2322 1
  memcpy (&dependency_vector[0], theinst, sizeof (dependency_vector[i]));
d2325 2
a2326 2
  if (strcmp (dependency_vector[0].name, "nop") == 0
      || strcmp (dependency_vector[0].name, "nop!") == 0)
d2329 1
a2329 7
  /* "pce" is defined in insn_to_dependency_table.  */
#define PCE_NAME "pce"

  if (dependency_vector[0].type == Insn_Type_PCE)
    strcpy (cur_insn, PCE_NAME);
  else
    strcpy (cur_insn, dependency_vector[0].name);
d2331 1
a2331 1
  for (i = 1; i < vector_size; i++)
d2333 2
a2334 2
      /* The element of dependency_vector is NULL.  */
      if (dependency_vector[i].name[0] == '\0')
d2337 1
a2337 4
      if (dependency_vector[i].type == Insn_Type_PCE)
	strcpy (pre_insn, PCE_NAME);
      else
	strcpy (pre_insn, dependency_vector[i].name);
d2339 2
a2340 2
      bubbles = check_dependency (pre_insn, dependency_vector[i].reg,
                                  cur_insn, dependency_vector[0].reg, &warn_or_error);
d2347 1
a2347 1
          if (fix_data_dependency == 1)
d2351 1
a2351 1
		  if (warn_fix_data_dependency)
d2353 2
a2354 2
			     dependency_vector[i].name, dependency_vector[i].reg,
			     dependency_vector[0].name, dependency_vector[0].reg,
d2357 3
a2359 3
                  for (j = (vector_size - 1); (j - remainder_bubbles) > 0; j--)
		    memcpy (&dependency_vector[j], &dependency_vector[j - remainder_bubbles],
			    sizeof (dependency_vector[j]));
d2363 1
a2363 1
                      memset (&dependency_vector[j], '\0', sizeof (dependency_vector[j]));
d2365 1
a2365 1
    		      build_one_frag (nop_inst);
d2370 1
a2370 1
		  if (warn_fix_data_dependency)
d2372 2
a2373 2
			     dependency_vector[i].name, dependency_vector[i].reg,
			     dependency_vector[0].name, dependency_vector[0].reg,
d2376 2
a2377 2
                  for (j = 1; j < vector_size; j++)
		    memset (&dependency_vector[j], '\0', sizeof (dependency_vector[j]));
d2380 1
a2380 1
                  build_one_frag (pflush_inst);
d2388 2
a2389 2
                           dependency_vector[i].name, dependency_vector[i].reg,
                           dependency_vector[0].name, dependency_vector[0].reg,
d2395 2
a2396 2
                           dependency_vector[i].name, dependency_vector[i].reg,
                           dependency_vector[0].name, dependency_vector[0].reg,
d2405 1
a2405 1
get_insn_class_from_type (enum score_insn_type type)
d2407 1
a2407 1
  enum insn_class retval = (int) FAIL;
d2425 2
d2467 2
d2477 4
d2488 10
a2497 5
static unsigned long
adjust_paritybit (unsigned long m_code, enum insn_class class)
{
  unsigned long result = 0;
  unsigned long m_code_high = 0;
d2499 2
a2500 1
  unsigned long pb_high = 0;
d2503 13
a2515 1
  if (class == INSN_CLASS_32)
d2518 4
a2521 1
      pb_low = 0x00008000;
d2527 3
d2533 1
d2536 3
a2538 7
    }
  else if (class == INSN_CLASS_SYN)
    {
      /* FIXME.  at this time, INSN_CLASS_SYN must be 32 bit, but, instruction type should
         be changed if macro instruction has been expanded.  */
      pb_high = 0x80000000;
      pb_low = 0x00008000;
a2544 3
  m_code_high = m_code & 0x3fff8000;
  m_code_low = m_code & 0x00007fff;
  result = pb_high | (m_code_high << 1) | pb_low | m_code_low;
a2545 1

d2549 1
a2549 1
gen_insn_frag (struct score_it *part_1, struct score_it *part_2)
d2553 1
a2553 1
  int relaxable_p = g_opt;
d2555 3
a2557 3
  struct score_it *inst1 = part_1;
  struct score_it *inst2 = part_2;
  struct score_it backup_inst1;
d2560 1
a2560 1
  memcpy (&backup_inst1, inst1, sizeof (struct score_it));
d2567 1
a2567 1
      backup_inst1.instruction = adjust_paritybit (backup_inst1.instruction, INSN_CLASS_PCE);
d2569 1
a2569 1
      backup_inst1.size = INSN_SIZE;
d2575 2
a2576 2
      backup_inst1.instruction = adjust_paritybit (backup_inst1.instruction,
						   GET_INSN_CLASS (backup_inst1.type));
d2583 2
a2584 2
      tmp = (backup_inst1.size == INSN_SIZE) ? INSN_CLASS_16 : INSN_CLASS_32;
      backup_inst1.relax_inst = adjust_paritybit (backup_inst1.relax_inst, tmp);
d2588 1
a2588 1
  handle_dependency (&backup_inst1);
d2609 1
a2609 1
  md_number_to_chars (p, backup_inst1.instruction, backup_inst1.size);
d2619 1
a2619 1
	fix_new_score (frag_now, p - frag_now->fr_literal,
d2624 1
a2624 1
	fix_new_score (frag_now, p - frag_now->fr_literal + 2,
d2630 1
a2630 1
	fix_new_score (frag_now, p - frag_now->fr_literal,
d2639 2
a2640 2
  p = frag_var (rs_machine_dependent, relax_size + RELAX_PAD_BYTE, 0,
                RELAX_ENCODE (backup_inst1.size, backup_inst1.relax_size,
d2645 1
a2645 1
    md_number_to_chars (p, backup_inst1.relax_inst, relax_size);
d2647 1
a2647 1
  memcpy (inst1, &backup_inst1, sizeof (struct score_it));
d2651 1
a2651 1
parse_16_32_inst (char *insnstr, bfd_boolean gen_frag_p)
d2656 1
a2656 1
  const struct asm_opcode *opcode;
d2659 1
a2659 1
  skip_whitespace (operator);
d2671 47
a2717 1
  opcode = (const struct asm_opcode *) hash_find (score_ops_hsh, operator);
d2720 2
a2721 2
  memset (&inst, '\0', sizeof (inst));
  sprintf (inst.str, "%s", insnstr);
d2724 10
a2733 10
      inst.instruction = opcode->value;
      inst.relax_inst = opcode->relax_value;
      inst.type = opcode->type;
      inst.size = GET_INSN_SIZE (inst.type);
      inst.relax_size = 0;
      inst.bwarn = 0;
      sprintf (inst.name, "%s", opcode->template);
      strcpy (inst.reg, "");
      inst.error = NULL;
      inst.reloc.type = BFD_RELOC_NONE;
d2737 3
a2739 3
      /* It indicates current instruction is a macro instruction if inst.bwarn equals -1.  */
      if ((inst.bwarn != -1) && (!inst.error) && (gen_frag_p))
	gen_insn_frag (&inst, NULL);
d2742 1
a2742 1
    inst.error = _("unrecognized opcode");
d2746 1
a2746 1
append_insn (char *str, bfd_boolean gen_frag_p)
d2748 1
a2748 1
  int retval = SUCCESS;
d2750 1
a2750 1
  parse_16_32_inst (str, gen_frag_p);
d2752 1
a2752 1
  if (inst.error)
d2754 3
a2756 3
      retval = (int) FAIL;
      as_bad (_("%s -- `%s'"), inst.error, inst.str);
      inst.error = NULL;
a2761 3
/* Handle mv! reg_high, reg_low;
          mv! reg_low, reg_high;
          mv! reg_low, reg_low;  */
d2763 1
a2763 1
do16_mv_rdrs (char *str)
d2765 1
a2765 3
  int reg_rd;
  int reg_rs;
  char *backupstr = NULL;
d2767 4
a2770 7
  backupstr = str;
  skip_whitespace (str);

  if ((reg_rd = reg_required_here (&str, 8, REG_TYPE_SCORE)) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || (reg_rs = reg_required_here (&str, 4, REG_TYPE_SCORE)) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d2774 1
a2774 14
  else
    {
      /* Case 1 : mv! or mlfh!.  */
      if (reg_rd < 16)
        {
          if (reg_rs < 16)
            {
              inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
                | (((inst.instruction >> 4) & 0xf) << 15) | (0xf << 10);
              inst.relax_size = 4;
            }
          else
            {
              char append_str[MAX_LITERAL_POOL_SIZE];
d2776 4
a2779 18
              sprintf (append_str, "mlfh! %s", backupstr);
              if (append_insn (append_str, TRUE) == (int) FAIL)
		return;
              /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
              inst.bwarn = -1;
            }
        }
      /* Case 2 : mhfl!.  */
      else
        {
          if (reg_rs > 16)
            {
              SET_INSN_ERROR (BAD_ARGS);
              return;
            }
          else
            {
              char append_str[MAX_LITERAL_POOL_SIZE];
d2781 6
a2786 8
              sprintf (append_str, "mhfl! %s", backupstr);
              if (append_insn (append_str, TRUE) == (int) FAIL)
		return;

              /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
              inst.bwarn = -1;
            }
        }
d2791 1
a2791 1
do16_rdi4 (char *str)
d2793 1
a2793 1
  skip_whitespace (str);
d2795 4
a2798 4
  if (reglow_required_here (&str, 8) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || data_op2 (&str, 3, _IMM4) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
a2801 29
  else
    {
      if (((inst.instruction >> 3) & 0x10) == 0)        /* for judge is addei or subei : bit 5 =0 : addei */
        {
          if (((inst.instruction >> 3) & 0xf) != 0xf)
            {
              inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
                | ((1 << ((inst.instruction >> 3) & 0xf)) << 1);
              inst.relax_size = 4;
            }
          else
            {
              inst.relax_inst = 0x8000;
            }
        }
      else
        {
          if (((inst.instruction >> 3) & 0xf) != 0xf)
            {
              inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
                | (((-(1 << ((inst.instruction >> 3) & 0xf))) & 0xffff) << 1);
              inst.relax_size = 4;
            }
          else
            {
              inst.relax_inst = 0x8000;
            }
        }
    }
d2804 1
d2806 1
a2806 1
do16_rdi5 (char *str)
d2808 1
a2808 1
  skip_whitespace (str);
d2810 4
a2813 4
  if (reglow_required_here (&str, 8) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || data_op2 (&str, 3, _IMM5) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d2817 3
a2819 3
      inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
        | (((inst.instruction >> 8) & 0xf) << 15) | (((inst.instruction >> 3) & 0x1f) << 10);
      inst.relax_size = 4;
d2823 2
a2824 1
/* Handle sdbbp.  */
d2826 1
a2826 1
do16_xi5 (char *str)
d2828 1
a2828 1
  skip_whitespace (str);
d2830 1
a2830 1
  if (data_op2 (&str, 3, _IMM5) == (int) FAIL || end_of_line (str) == (int) FAIL)
a2831 5
  else
    {
      inst.relax_inst |= (((inst.instruction >> 3) & 0x1f) << 15);
      inst.relax_size = 4;
    }
d2837 1
a2837 1
validate_immediate_align (int val, unsigned int data_type)
d2843 2
a2844 2
          inst.error = _("address offset must be half word alignment");
          return (int) FAIL;
d2851 2
a2852 2
          inst.error = _("address offset must be word alignment");
          return (int) FAIL;
d2856 1
a2856 1
  return SUCCESS;
d2860 1
a2860 1
exp_ldst_offset (char **str, int shift, unsigned int data_type)
d2884 2
a2885 2
  if (my_get_expression (&inst.reloc.exp, str) == (int) FAIL)
    return (int) FAIL;
d2887 1
a2887 1
  if (inst.reloc.exp.X_op == O_constant)
d2890 1
a2890 1
      int value = validate_immediate_align (inst.reloc.exp.X_add_number, data_type);
d2892 2
a2893 2
      if (value == (int) FAIL)
	return (int) FAIL;
d2895 2
a2896 2
      value = validate_immediate (inst.reloc.exp.X_add_number, data_type, 0);
      if (value == (int) FAIL)
d2899 1
a2899 1
            sprintf (err_msg,
d2901 2
a2902 2
                     score_df_range[data_type].bits,
                     score_df_range[data_type].range[0], score_df_range[data_type].range[1]);
d2904 1
a2904 1
            sprintf (err_msg,
d2906 4
a2909 4
                     score_df_range[data_type - 24].bits,
                     score_df_range[data_type - 24].range[0], score_df_range[data_type - 24].range[1]);
          inst.error = err_msg;
          return (int) FAIL;
d2921 1
a2921 1
      if (score_df_range[data_type].range[0] != 0)
d2923 1
a2923 1
          value &= (1 << score_df_range[data_type].bits) - 1;
d2926 1
a2926 1
      inst.instruction |= value << shift;
d2930 1
a2930 1
      inst.reloc.pc_rel = 0;
d2933 1
a2933 1
  return SUCCESS;
d2937 1
a2937 1
do_ldst_insn (char *str)
d2949 1
a2949 1
  skip_whitespace (str);
d2951 2
a2952 2
  if (((conflict_reg = reg_required_here (&str, 20, REG_TYPE_SCORE)) == (int) FAIL)
      || (skip_past_comma (&str) == (int) FAIL))
d2959 1
a2959 1
      skip_whitespace (str);
d2961 1
a2961 1
      if ((reg = reg_required_here (&str, 15, REG_TYPE_SCORE)) == (int) FAIL)
d2966 1
a2966 1
      skip_whitespace (str);
d2977 1
a2977 1
              if (skip_past_comma (&str) == SUCCESS)
d2979 2
a2980 2
                  if ((exp_ldst_offset (&str, 3, _SIMM12) == (int) FAIL)
                      || (end_of_line (str) == (int) FAIL))
d2985 1
a2985 1
                      unsigned int ldst_func = inst.instruction & OPC_PSEUDOLDST_MASK;
d2993 1
a2993 1
                          inst.error = _("register same as write-back base");
d2998 3
a3000 3
                  ldst_idx = inst.instruction & OPC_PSEUDOLDST_MASK;
                  inst.instruction &= ~OPC_PSEUDOLDST_MASK;
                  inst.instruction |= score_ldst_insns[ldst_idx * 3 + LDST_POST].value;
d3003 1
a3003 1
                  if ((inst.instruction & 0x3e000007) == 0x0e000000)
d3005 3
a3007 3
                      /* rs =  r0-r7, offset = 4 */
                      if ((((inst.instruction >> 15) & 0x18) == 0)
                          && (((inst.instruction >> 3) & 0xfff) == 4))
d3009 3
a3011 15
                          /* Relax to pophi.  */
                          if ((((inst.instruction >> 20) & 0x10) == 0x10))
                            {
                              inst.relax_inst = 0x0000200a | (((inst.instruction >> 20) & 0xf)
                                                              << 8) | 1 << 7 |
                                (((inst.instruction >> 15) & 0x7) << 4);
                            }
                          /* Relax to pop.  */
                          else
                            {
                              inst.relax_inst = 0x0000200a | (((inst.instruction >> 20) & 0xf)
                                                              << 8) | 0 << 7 |
                                (((inst.instruction >> 15) & 0x7) << 4);
                            }
                          inst.relax_size = 2;
d3019 2
a3020 2
                  SET_INSN_ERROR (NULL);
                  if (end_of_line (str) == (int) FAIL)
d3026 7
a3032 7
                  value = validate_immediate (inst.reloc.exp.X_add_number, _SIMM12, 0);
                  value &= (1 << score_df_range[_SIMM12].bits) - 1;
                  ldst_idx = inst.instruction & OPC_PSEUDOLDST_MASK;
                  inst.instruction &= ~OPC_PSEUDOLDST_MASK;
                  inst.instruction |= score_ldst_insns[ldst_idx * 3 + pre_inc].value;
                  inst.instruction |= value << 3;
                  inst.relax_inst = 0x8000;
d3039 1
a3039 1
              if (end_of_line (str) == (int) FAIL)
d3042 3
a3044 3
              ldst_idx = inst.instruction & OPC_PSEUDOLDST_MASK;
              inst.instruction &= ~OPC_PSEUDOLDST_MASK;
              inst.instruction |= score_ldst_insns[ldst_idx * 3 + LDST_NOUPDATE].value;
d3049 1
a3049 1
                  inst.relax_inst = INSN16_LBU;
d3053 1
a3053 1
                  inst.relax_inst = INSN16_LH;
d3057 1
a3057 1
                  inst.relax_inst = INSN16_LW;
d3061 1
a3061 1
                  inst.relax_inst = INSN16_SB;
d3065 1
a3065 1
                  inst.relax_inst = INSN16_SH;
d3069 1
a3069 1
                  inst.relax_inst = INSN16_SW;
d3073 1
a3073 1
                  inst.relax_inst = 0x8000;
d3077 1
a3077 1
              if ((ldst_idx == INSN_LBU)
d3080 2
a3081 1
                  || (ldst_idx == INSN_SB) || (ldst_idx == INSN_SH) || (ldst_idx == INSN_SW))
d3083 2
a3084 1
                  if ((((inst.instruction >> 15) & 0x10) == 0) && (((inst.instruction >> 20) & 0x10) == 0))
d3086 3
a3088 3
                      inst.relax_inst |= (2 << 12) | (((inst.instruction >> 20) & 0xf) << 8) |
                        (((inst.instruction >> 15) & 0xf) << 4);
                      inst.relax_size = 2;
d3098 1
a3098 1
          if (skip_past_comma (&str) == (int) FAIL)
d3100 1
a3100 1
              inst.error = _("pre-indexed expression expected");
d3104 1
a3104 1
          if (my_get_expression (&inst.reloc.exp, &str) == (int) FAIL)
d3107 1
a3107 1
          skip_whitespace (str);
d3110 1
a3110 1
              inst.error = _("missing ]");
d3114 1
a3114 1
          skip_whitespace (str);
d3122 1
a3122 1
                  unsigned int ldst_func = inst.instruction & OPC_PSEUDOLDST_MASK;
d3130 1
a3130 1
                      inst.error = _("register same as write-back base");
d3136 1
a3136 1
          if (end_of_line (str) == (int) FAIL)
d3139 1
a3139 1
          if (inst.reloc.exp.X_op == O_constant)
d3168 2
a3169 2
              value = validate_immediate (inst.reloc.exp.X_add_number, data_type, 0);
              if (value == (int) FAIL)
d3172 1
a3172 1
                    sprintf (err_msg,
d3174 2
a3175 2
                             score_df_range[data_type].bits,
                             score_df_range[data_type].range[0], score_df_range[data_type].range[1]);
d3177 1
a3177 1
                    sprintf (err_msg,
d3179 4
a3182 4
                             score_df_range[data_type - 24].bits,
                             score_df_range[data_type - 24].range[0],
                             score_df_range[data_type - 24].range[1]);
                  inst.error = err_msg;
d3186 4
a3189 4
              value &= (1 << score_df_range[data_type].bits) - 1;
              ldst_idx = inst.instruction & OPC_PSEUDOLDST_MASK;
              inst.instruction &= ~OPC_PSEUDOLDST_MASK;
              inst.instruction |= score_ldst_insns[ldst_idx * 3 + pre_inc].value;
d3191 1
a3191 1
                inst.instruction |= value << 3;
d3193 1
a3193 1
                inst.instruction |= value;
d3196 1
a3196 1
              if ((inst.instruction & 0x3e000000) == 0x20000000)
d3198 3
a3200 3
                  /* Both rD and rA are in [r0 - r15].  */
                  if ((((inst.instruction >> 15) & 0x10) == 0)
                      && (((inst.instruction >> 20) & 0x10) == 0))
d3202 2
a3203 11
                      /* simm15 = 0, lw -> lw!.  */
                      if ((inst.instruction & 0x7fff) == 0)
                        {
                          inst.relax_inst |= (((inst.instruction >> 15) & 0xf) << 4)
                            | (((inst.instruction >> 20) & 0xf) << 8);
                          inst.relax_size = 2;
                        }
                      /* rA = r2, lw -> lwp!.  */
                      else if ((((inst.instruction >> 15) & 0xf) == 2)
                               && ((inst.instruction & 0x3) == 0)
                               && ((inst.instruction & 0x7fff) < 128))
d3205 3
a3207 3
                          inst.relax_inst = 0x7000 | (((inst.instruction >> 20) & 0xf) << 8)
                            | (((inst.instruction & 0x7fff) >> 2) << 3);
                          inst.relax_size = 2;
d3211 1
a3211 1
                          inst.relax_inst = 0x8000;
d3216 1
a3216 1
                      inst.relax_inst = 0x8000;
d3220 1
a3220 1
              else if ((inst.instruction & 0x3e000000) == 0x28000000)
d3222 2
a3223 2
                  /* Both rD and rA are in [r0 - r15].  */
                  if ((((inst.instruction >> 15) & 0x10) == 0) && (((inst.instruction >> 20) & 0x10) == 0))
d3225 2
a3226 2
                      /* simm15 = 0, sw -> sw!.  */
                      if ((inst.instruction & 0x7fff) == 0)
d3228 3
a3230 3
                          inst.relax_inst |= (((inst.instruction >> 15) & 0xf) << 4)
                            | (((inst.instruction >> 20) & 0xf) << 8);
                          inst.relax_size = 2;
a3232 8
                      else if ((((inst.instruction >> 15) & 0xf) == 2)
                               && ((inst.instruction & 0x3) == 0)
                               && ((inst.instruction & 0x7fff) < 128))
                        {
                          inst.relax_inst = 0x7004 | (((inst.instruction >> 20) & 0xf) << 8)
                            | (((inst.instruction & 0x7fff) >> 2) << 3);
                          inst.relax_size = 2;
                        }
d3235 1
a3235 1
                          inst.relax_inst = 0x8000;
d3240 1
a3240 1
                      inst.relax_inst = 0x8000;
d3244 1
a3244 1
              else if ((inst.instruction & 0x3e000007) == 0x06000004)
d3246 3
a3248 3
                  /* rA is in [r0 - r7], and simm15 = -4.  */
                  if ((((inst.instruction >> 15) & 0x18) == 0)
                      && (((inst.instruction >> 3) & 0xfff) == 0xffc))
a3249 7
                      /* sw -> pushhi!.  */
                      if ((((inst.instruction >> 20) & 0x10) == 0x10))
                        {
                          inst.relax_inst = 0x0000200e | (((inst.instruction >> 20) & 0xf) << 8)
                            | 1 << 7 | (((inst.instruction >> 15) & 0x7) << 4);
                          inst.relax_size = 2;
                        }
d3251 2
a3252 70
                      else
                        {
                          inst.relax_inst = 0x0000200e | (((inst.instruction >> 20) & 0xf) << 8)
                            | 0 << 7 | (((inst.instruction >> 15) & 0x7) << 4);
                          inst.relax_size = 2;
                        }
                    }
                  else
                    {
                      inst.relax_inst = 0x8000;
                    }
                }
              /* lh rD, [rA, simm15]  */
              else if ((inst.instruction & 0x3e000000) == 0x22000000)
                {
                  /* Both rD and rA are in [r0 - r15].  */
                  if ((((inst.instruction >> 15) & 0x10) == 0) && (((inst.instruction >> 20) & 0x10) == 0))
                    {
                      /* simm15 = 0, lh -> lh!.  */
                      if ((inst.instruction & 0x7fff) == 0)
                        {
                          inst.relax_inst |= (((inst.instruction >> 15) & 0xf) << 4)
                            | (((inst.instruction >> 20) & 0xf) << 8);
                          inst.relax_size = 2;
                        }
                      /* rA = r2, lh -> lhp!.  */
                      else if ((((inst.instruction >> 15) & 0xf) == 2)
                               && ((inst.instruction & 0x1) == 0)
                               && ((inst.instruction & 0x7fff) < 64))
                        {
                          inst.relax_inst = 0x7001 | (((inst.instruction >> 20) & 0xf) << 8)
                            | (((inst.instruction & 0x7fff) >> 1) << 3);
                          inst.relax_size = 2;
                        }
                      else
                        {
                          inst.relax_inst = 0x8000;
                        }
                    }
                  else
                    {
                      inst.relax_inst = 0x8000;
                    }
                }
              /* sh rD, [rA, simm15]  */
              else if ((inst.instruction & 0x3e000000) == 0x2a000000)
                {
                  /* Both rD and rA are in [r0 - r15].  */
                  if ((((inst.instruction >> 15) & 0x10) == 0) && (((inst.instruction >> 20) & 0x10) == 0))
                    {
                      /* simm15 = 0, sh -> sh!.  */
                      if ((inst.instruction & 0x7fff) == 0)
                        {
                          inst.relax_inst |= (((inst.instruction >> 15) & 0xf) << 4)
                            | (((inst.instruction >> 20) & 0xf) << 8);
                          inst.relax_size = 2;
                        }
                      /* rA = r2, sh -> shp!.  */
                      else if ((((inst.instruction >> 15) & 0xf) == 2)
                               && ((inst.instruction & 0x1) == 0)
                               && ((inst.instruction & 0x7fff) < 64))
                        {
                          inst.relax_inst = 0x7005 | (((inst.instruction >> 20) & 0xf) << 8)
                            | (((inst.instruction & 0x7fff) >> 1) << 3);
                          inst.relax_size = 2;
                        }
                      else
                        {
                          inst.relax_inst = 0x8000;
                        }
d3256 1
a3256 63
                      inst.relax_inst = 0x8000;
                    }
                }
              /* lbu rD, [rA, simm15]  */
              else if ((inst.instruction & 0x3e000000) == 0x2c000000)
                {
                  /* Both rD and rA are in [r0 - r15].  */
                  if ((((inst.instruction >> 15) & 0x10) == 0) && (((inst.instruction >> 20) & 0x10) == 0))
                    {
                      /* simm15 = 0, lbu -> lbu!.  */
                      if ((inst.instruction & 0x7fff) == 0)
                        {
                          inst.relax_inst |= (((inst.instruction >> 15) & 0xf) << 4)
                            | (((inst.instruction >> 20) & 0xf) << 8);
                          inst.relax_size = 2;
                        }
                      /* rA = r2, lbu -> lbup!.  */
                      else if ((((inst.instruction >> 15) & 0xf) == 2)
                               && ((inst.instruction & 0x7fff) < 32))
                        {
                          inst.relax_inst = 0x7003 | (((inst.instruction >> 20) & 0xf) << 8)
                            | ((inst.instruction & 0x7fff) << 3);
                          inst.relax_size = 2;
                        }
                      else
                        {
                          inst.relax_inst = 0x8000;
                        }
                    }
                  else
                    {
                      inst.relax_inst = 0x8000;
                    }
                }
              /* sb rD, [rA, simm15]  */
              else if ((inst.instruction & 0x3e000000) == 0x2e000000)
                {
                  /* Both rD and rA are in [r0 - r15].  */
                  if ((((inst.instruction >> 15) & 0x10) == 0) && (((inst.instruction >> 20) & 0x10) == 0))
                    {
                      /* simm15 = 0, sb -> sb!.  */
                      if ((inst.instruction & 0x7fff) == 0)
                        {
                          inst.relax_inst |= (((inst.instruction >> 15) & 0xf) << 4)
                            | (((inst.instruction >> 20) & 0xf) << 8);
                          inst.relax_size = 2;
                        }
                      /* rA = r2, sb -> sb!.  */
                      else if ((((inst.instruction >> 15) & 0xf) == 2)
                               && ((inst.instruction & 0x7fff) < 32))
                        {
                          inst.relax_inst = 0x7007 | (((inst.instruction >> 20) & 0xf) << 8)
                            | ((inst.instruction & 0x7fff) << 3);
                          inst.relax_size = 2;
                        }
                      else
                        {
                          inst.relax_inst = 0x8000;
                        }
                    }
                  else
                    {
                      inst.relax_inst = 0x8000;
d3261 1
a3261 1
                  inst.relax_inst = 0x8000;
d3269 1
a3269 1
              inst.reloc.pc_rel = 0;
d3275 1
a3275 1
      inst.error = BAD_ARGS;
a3279 1

d3281 1
a3281 1
do_cache (char *str)
d3283 1
a3283 1
  skip_whitespace (str);
d3285 1
a3285 1
  if ((data_op2 (&str, 20, _IMM5) == (int) FAIL) || (skip_past_comma (&str) == (int) FAIL))
d3293 2
a3294 2
      cache_op = (inst.instruction >> 20) & 0x1F;
      sprintf (inst.name, "cache %d", cache_op);
d3300 1
a3300 1
      skip_whitespace (str);
d3302 1
a3302 1
      if (reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL)
d3305 1
a3305 1
      skip_whitespace (str);
d3308 1
a3308 1
      if (skip_past_comma (&str) == (int) FAIL)
d3310 1
a3310 1
          SET_INSN_ERROR (NULL);
d3313 1
a3313 1
              inst.error = _("missing ]");
d3321 1
a3321 1
          if (exp_ldst_offset (&str, 0, _SIMM15) == (int) FAIL)
d3326 1
a3326 1
          skip_whitespace (str);
d3329 1
a3329 1
              inst.error = _("missing ]");
d3334 1
a3334 1
      if (end_of_line (str) == (int) FAIL)
d3339 1
a3339 1
      inst.error = BAD_ARGS;
d3344 1
a3344 1
do_crdcrscrsimm5 (char *str)
d3349 1
a3349 1
  skip_whitespace (str);
d3351 6
a3356 6
  if (reg_required_here (&str, 20, REG_TYPE_SCORE_CR) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 15, REG_TYPE_SCORE_CR) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL
      || reg_required_here (&str, 10, REG_TYPE_SCORE_CR) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL)
d3360 1
a3360 1
      if (data_op2 (&str, 5, _IMM20) == (int) FAIL)
d3365 1
a3365 1
      if (data_op2 (&str, 5, _IMM5) == (int) FAIL)
d3369 1
a3369 1
  end_of_line (str);
d3374 1
a3374 1
do_ldst_cop (char *str)
d3376 1
a3376 1
  skip_whitespace (str);
d3378 2
a3379 2
  if ((reg_required_here (&str, 15, REG_TYPE_SCORE_CR) == (int) FAIL)
      || (skip_past_comma (&str) == (int) FAIL))
d3385 1
a3385 1
      skip_whitespace (str);
d3387 1
a3387 1
      if (reg_required_here (&str, 20, REG_TYPE_SCORE) == (int) FAIL)
d3390 1
a3390 1
      skip_whitespace (str);
d3394 1
a3394 1
          if (exp_ldst_offset (&str, 5, _IMM10_RSHIFT_2) == (int) FAIL)
d3397 1
a3397 1
          skip_whitespace (str);
d3400 1
a3400 1
              inst.error = _("missing ]");
d3405 1
a3405 1
      end_of_line (str);
d3408 1
a3408 1
    inst.error = BAD_ARGS;
d3412 1
a3412 1
do16_ldst_insn (char *str)
d3414 3
a3416 1
  skip_whitespace (str);
d3418 1
a3418 1
  if ((reglow_required_here (&str, 8) == (int) FAIL) || (skip_past_comma (&str) == (int) FAIL))
a3422 1
      int reg;
d3425 1
a3425 1
      skip_whitespace (str);
d3427 1
a3427 1
      if ((reg = reglow_required_here (&str, 4)) == (int) FAIL)
d3429 6
d3436 3
a3438 2
      skip_whitespace (str);
      if (*str++ == ']')
d3440 2
a3441 1
          if (end_of_line (str) == (int) FAIL)
a3442 6
          else
            {
              inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
                              | (((inst.instruction >> 4) & 0xf) << 15);
	      inst.relax_size = 4;
            }
d3446 41
a3486 1
          inst.error = _("missing ]");
d3488 1
d3492 3
a3494 1
      inst.error = BAD_ARGS;
a3497 1
/* Handle lbup!/lhp!/ldiu!/lwp!/sbp!/shp!/swp!.  */
d3499 1
a3499 1
do16_ldst_imm_insn (char *str)
d3501 1
a3501 6
  char data_exp[MAX_LITERAL_POOL_SIZE];
  int reg_rd;
  char *dataptr = NULL, *pp = NULL;
  int cnt = 0;
  int assign_data = (int) FAIL;
  unsigned int ldst_func;
d3503 1
a3503 1
  skip_whitespace (str);
d3505 2
a3506 2
  if (((reg_rd = reglow_required_here (&str, 8)) == (int) FAIL)
      || (skip_past_comma (&str) == (int) FAIL))
d3509 5
a3513 2
  skip_whitespace (str);
  dataptr = str;
d3515 3
a3517 1
  while ((*dataptr != '\0') && (*dataptr != '|') && (cnt <= MAX_LITERAL_POOL_SIZE))
d3519 2
a3520 3
      data_exp[cnt] = *dataptr;
      dataptr++;
      cnt++;
d3523 8
a3530 4
  data_exp[cnt] = '\0';
  pp = &data_exp[0];

  str = dataptr;
d3532 3
a3534 9
  ldst_func = inst.instruction & LDST16_RI_MASK;
  if (ldst_func == N16_LIU)
    assign_data = exp_ldst_offset (&pp, 0, _IMM8);
  else if (ldst_func == N16_LHP || ldst_func == N16_SHP)
    assign_data = exp_ldst_offset (&pp, 3, _IMM5_RSHIFT_1);
  else if (ldst_func == N16_LWP || ldst_func == N16_SWP)
    assign_data = exp_ldst_offset (&pp, 3, _IMM5_RSHIFT_2);
  else
    assign_data = exp_ldst_offset (&pp, 3, _IMM5);
d3536 2
a3537 27
  if ((assign_data == (int) FAIL) || (end_of_line (pp) == (int) FAIL))
    return;
  else
    {
      if ((inst.instruction & 0x7000) == N16_LIU)
        {
          inst.relax_inst |= ((inst.instruction >> 8) & 0xf) << 20
                          | ((inst.instruction & 0xff) << 1);
        }
      else if (((inst.instruction & 0x7007) == N16_LHP)
               || ((inst.instruction & 0x7007) == N16_SHP))
        {
          inst.relax_inst |= ((inst.instruction >> 8) & 0xf) << 20 | 2 << 15
                          | (((inst.instruction >> 3) & 0x1f) << 1);
        }
      else if (((inst.instruction & 0x7007) == N16_LWP)
               || ((inst.instruction & 0x7007) == N16_SWP))
        {
          inst.relax_inst |= ((inst.instruction >> 8) & 0xf) << 20 | 2 << 15
                          | (((inst.instruction >> 3) & 0x1f) << 2);
        }
      else if (((inst.instruction & 0x7007) == N16_LBUP)
               || ((inst.instruction & 0x7007) == N16_SBP))
        {
          inst.relax_inst |= ((inst.instruction >> 8) & 0xf) << 20 | 2 << 15
                          | (((inst.instruction >> 3) & 0x1f));
        }
a3538 2
      inst.relax_size = 4;
    }
d3542 1
a3542 1
do16_push_pop (char *str)
d3544 3
a3546 2
  int reg_rd;
  int H_bit_mask = 0;
d3548 2
a3549 3
  skip_whitespace (str);
  if (((reg_rd = reg_required_here (&str, 8, REG_TYPE_SCORE)) == (int) FAIL)
      || (skip_past_comma (&str) == (int) FAIL))
d3552 5
a3556 2
  if (reg_rd >= 16)
    H_bit_mask = 1;
d3558 7
a3564 2
  /* reg_required_here will change bit 12 of opcode, so we must restore bit 12.  */
  inst.instruction &= ~(1 << 12);
d3566 8
a3573 1
  inst.instruction |= H_bit_mask << 7;
d3575 3
a3577 3
  if (*str == '[')
    {
      int reg;
d3579 3
a3581 8
      str++;
      skip_whitespace (str);
      if ((reg = reg_required_here (&str, 4, REG_TYPE_SCORE)) == (int) FAIL)
	return;
      else if (reg > 7)
        {
          if (!inst.error)
	    inst.error = _("base register nums are over 3 bit");
d3583 219
a3801 2
          return;
        }
d3803 11
a3813 5
      skip_whitespace (str);
      if ((*str++ != ']') || (end_of_line (str) == (int) FAIL))
        {
          if (!inst.error)
	    inst.error = _("missing ]");
d3815 9
a3823 2
          return;
        }
d3825 4
a3828 29
      /* pop! */
      if ((inst.instruction & 0xf) == 0xa)
        {
          if (H_bit_mask)
            {
              inst.relax_inst |= ((((inst.instruction >> 8) & 0xf) | 0x10) << 20)
                                  | (((inst.instruction >> 4) & 0x7) << 15) | (4 << 3);
            }
          else
            {
              inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
                                  | (((inst.instruction >> 4) & 0x7) << 15) | (4 << 3);
            }
        }
      /* push! */
      else
        {
          if (H_bit_mask)
            {
              inst.relax_inst |= ((((inst.instruction >> 8) & 0xf) | 0x10) << 20)
                                  | (((inst.instruction >> 4) & 0x7) << 15) | (((-4) & 0xfff) << 3);
            }
          else
            {
              inst.relax_inst |= (((inst.instruction >> 8) & 0xf) << 20)
                                  | (((inst.instruction >> 4) & 0x7) << 15) | (((-4) & 0xfff) << 3);
            }
        }
      inst.relax_size = 4;
d3830 1
a3830 1
  else
d3832 7
a3838 1
      inst.error = BAD_ARGS;
d3844 1
a3844 1
do_ldst_unalign (char *str)
d3848 1
a3848 1
  if (university_version == 1)
d3850 1
a3850 1
      inst.error = ERR_FOR_SCORE5U_ATOMIC;
d3854 1
a3854 1
  skip_whitespace (str);
d3860 1
a3860 1
      skip_whitespace (str);
d3862 1
a3862 1
      if (reg_required_here (&str, 15, REG_TYPE_SCORE) == (int) FAIL)
d3869 1
a3869 1
              inst.error = _("missing +");
d3875 1
a3875 1
          inst.error = _("missing ]");
d3879 1
a3879 1
      if (end_of_line (str) == (int) FAIL)
d3885 2
a3886 2
      if (((conflict_reg = reg_required_here (&str, 20, REG_TYPE_SCORE)) == (int) FAIL)
          || (skip_past_comma (&str) == (int) FAIL))
d3891 1
a3891 1
      skip_whitespace (str);
d3896 2
a3897 2
          skip_whitespace (str);
          if ((reg = reg_required_here (&str, 15, REG_TYPE_SCORE)) == (int) FAIL)
d3904 1
a3904 1
          skip_whitespace (str);
d3907 1
a3907 1
              unsigned int ldst_func = inst.instruction & LDST_UNALIGN_MASK;
d3920 1
a3920 1
                  inst.error = _("missing +");
d3924 1
a3924 1
              if (end_of_line (str) == (int) FAIL)
d3929 1
a3929 1
              inst.error = _("missing ]");
d3935 1
a3935 1
          inst.error = BAD_ARGS;
d3943 1
a3943 1
do_ldst_atomic (char *str)
d3945 1
a3945 1
  if (university_version == 1)
d3947 1
a3947 1
      inst.error = ERR_FOR_SCORE5U_ATOMIC;
d3951 1
a3951 1
  skip_whitespace (str);
d3953 2
a3954 2
  if ((reg_required_here (&str, 20, REG_TYPE_SCORE) == (int) FAIL)
      || (skip_past_comma (&str) == (int) FAIL))
d3961 1
a3961 1
      skip_whitespace (str);
d3966 2
a3967 2
          skip_whitespace (str);
          if ((reg = reg_required_here (&str, 15, REG_TYPE_SCORE)) == (int) FAIL)
d3972 1
a3972 1
          skip_whitespace (str);
d3975 1
a3975 1
              inst.error = _("missing ]");
d3979 1
a3979 1
          end_of_line (str);
d3982 1
a3982 1
	inst.error = BAD_ARGS;
d3987 2
a3988 2
build_relax_frag (struct score_it fix_insts[RELAX_INST_NUM], int fix_num ATTRIBUTE_UNUSED,
                  struct score_it var_insts[RELAX_INST_NUM], int var_num,
d3996 1
a3996 1
  struct score_it inst_main;
d3998 1
a3998 1
  memcpy (&inst_main, &fix_insts[0], sizeof (struct score_it));
d4001 1
a4001 1
  inst_main.instruction = adjust_paritybit (inst_main.instruction, GET_INSN_CLASS (inst_main.type));
d4007 2
a4008 2
      var_insts[i].instruction = adjust_paritybit (var_insts[i].instruction,
                                                   GET_INSN_CLASS (var_insts[i].type));
d4012 1
a4012 1
  handle_dependency (&inst_main);
d4027 1
a4027 1
  md_number_to_chars (p, inst_main.instruction, inst_main.size);
d4030 1
a4030 1
    fixp = fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
d4048 1
a4048 1
          fixp = fix_new_score (frag_now, where, var_insts[i].size,
d4067 2
a4068 2
  p = frag_var (rs_machine_dependent, inst_main.relax_size + RELAX_PAD_BYTE, 0,
                RELAX_ENCODE (inst_main.size, inst_main.relax_size, inst_main.type,
d4072 1
a4072 1
     no calling gen_insn_frag, no fixS will be generated.  */
d4075 1
a4075 1
      md_number_to_chars (p, var_insts[i].instruction, var_insts[i].size);
d4079 1
a4079 1
  inst.bwarn = -1;
d4082 1
a4082 1
/* Build a relax frag for la instruction when generating PIC,
a4083 1

d4085 1
a4085 1
build_la_pic (int reg_rd, expressionS exp)
d4089 2
a4090 2
  struct score_it fix_insts[RELAX_INST_NUM];
  struct score_it var_insts[RELAX_INST_NUM];
d4093 1
a4093 1
  char tmp[MAX_LITERAL_POOL_SIZE];
d4096 2
a4097 2
  r1_bak = nor1;
  nor1 = 0;
d4110 1
a4110 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4113 3
a4115 3
      if (reg_rd == PIC_CALL_REG)
        inst.reloc.type = BFD_RELOC_SCORE_CALL15;
      memcpy (&fix_insts[0], &inst, sizeof (struct score_it));
d4121 2
a4122 2
      inst.reloc.type = BFD_RELOC_SCORE_GOT15;
      memcpy (&var_insts[0], &inst, sizeof (struct score_it));
d4124 1
a4124 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4127 2
a4128 2
      memcpy (&var_insts[1], &inst, sizeof (struct score_it));
      build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);
d4134 1
a4134 1
      if (append_insn (tmp, TRUE) == (int) FAIL)
d4143 1
a4143 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4146 1
a4146 1
      memcpy (&fix_insts[0], &inst, sizeof (struct score_it));
d4151 1
a4151 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4154 2
a4155 2
      memcpy (&var_insts[0], &inst, sizeof (struct score_it));
      build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);
d4164 1
a4164 1
      if (append_insn (tmp, TRUE) == (int) FAIL)
d4173 1
a4173 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4176 1
a4176 1
      memcpy (&fix_insts[0], &inst, sizeof (struct score_it));
d4186 1
a4186 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4189 2
a4190 2
      memcpy (&var_insts[0], &inst, sizeof (struct score_it));
      build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);
d4198 1
a4198 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4201 1
a4201 1
      memcpy (&fix_insts[0], &inst, sizeof (struct score_it));
d4206 1
a4206 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4209 2
a4210 2
      memcpy (&var_insts[0], &inst, sizeof (struct score_it));
      build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);
d4214 1
a4214 1
      if (append_insn (tmp, TRUE) == (int) FAIL)
d4218 1
a4218 1
     inst.bwarn = -1;
d4221 1
a4221 1
  nor1 = r1_bak;
d4226 1
a4226 1
do_macro_la_rdi32 (char *str)
d4230 3
a4232 3
  skip_whitespace (str);
  if ((reg_rd = reg_required_here (&str, 20, REG_TYPE_SCORE)) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL)
d4238 1
a4238 1
      char append_str[MAX_LITERAL_POOL_SIZE];
d4240 17
d4259 1
a4259 1
      if (data_op2 (&str, 1, _SIMM16_LA) != (int) FAIL)
d4261 1
a4261 1
          end_of_line (str);
d4267 2
a4268 1
          SET_INSN_ERROR (NULL);
d4270 2
a4271 2
          if ((data_op2 (&str, 1, _VALUE_HI16) == (int) FAIL)
              || (end_of_line (str) == (int) FAIL))
d4277 1
a4277 1
              if ((score_pic == NO_PIC) || (!inst.reloc.exp.X_add_symbol))
d4280 1
a4280 1
                  if (append_insn (append_str, TRUE) == (int) FAIL)
d4284 1
a4284 1
                  if (append_insn (append_str, TRUE) == (int) FAIL)
d4289 2
a4290 2
		  assert (inst.reloc.exp.X_add_symbol);
		  build_la_pic (reg_rd, inst.reloc.exp);
d4294 1
a4294 1
              inst.bwarn = -1;
d4302 2
a4303 1
do_macro_li_rdi32 (char *str){
d4307 3
a4309 3
  skip_whitespace (str);
  if ((reg_rd = reg_required_here (&str, 20, REG_TYPE_SCORE)) == (int) FAIL
      || skip_past_comma (&str) == (int) FAIL)
d4315 1
d4318 16
d4335 1
a4335 1
      if (data_op2 (&str, 1, _SIMM16_LA) != (int) FAIL)
d4337 1
a4337 1
          end_of_line (str);
d4343 1
a4343 1
          char append_str[MAX_LITERAL_POOL_SIZE];
d4345 1
d4348 2
a4349 2
          if ((data_op2 (&str, 1, _VALUE_HI16) == (int) FAIL)
              || (end_of_line (str) == (int) FAIL))
d4353 1
a4353 1
          else if (inst.reloc.exp.X_add_symbol)
d4355 1
a4355 1
              inst.error = _("li rd label isn't correct instruction form");
d4362 1
a4362 1
              if (append_insn (append_str, TRUE) == (int) FAIL)
d4367 1
a4367 1
                  if (append_insn (append_str, TRUE) == (int) FAIL)
d4371 1
a4371 1
                  inst.bwarn = -1;
d4380 1
a4380 1
do_macro_mul_rdrsrs (char *str)
d4386 1
a4386 1
  char append_str[MAX_LITERAL_POOL_SIZE];
d4388 2
a4389 2
  if (university_version == 1)
    as_warn ("%s", ERR_FOR_SCORE5U_MUL_DIV);
d4393 4
a4396 4
  skip_whitespace (backupstr);
  if (((reg_rd = reg_required_here (&backupstr, -1, REG_TYPE_SCORE)) == (int) FAIL)
      || (skip_past_comma (&backupstr) == (int) FAIL)
      || ((reg_rs1 = reg_required_here (&backupstr, -1, REG_TYPE_SCORE)) == (int) FAIL))
d4398 1
a4398 1
      inst.error = BAD_ARGS;
d4402 1
a4402 1
  if (skip_past_comma (&backupstr) == (int) FAIL)
d4405 1
a4405 1
      if (strcmp (inst.name, "rem") == 0 || strcmp (inst.name, "remu") == 0)
d4407 1
a4407 1
          SET_INSN_ERROR (BAD_ARGS);
d4411 2
a4412 2
          SET_INSN_ERROR (NULL);
          do_rsrs (str);
d4418 3
a4420 3
      SET_INSN_ERROR (NULL);
      if (((reg_rs2 = reg_required_here (&backupstr, -1, REG_TYPE_SCORE)) == (int) FAIL)
          || (end_of_line (backupstr) == (int) FAIL))
d4426 1
a4426 1
          char append_str1[MAX_LITERAL_POOL_SIZE];
d4428 1
a4428 1
          if (strcmp (inst.name, "rem") == 0)
d4433 1
a4433 1
          else if (strcmp (inst.name, "remu") == 0)
d4440 1
a4440 1
              sprintf (append_str, "%s r%d, r%d", inst.name, reg_rs1, reg_rs2);
d4445 1
a4445 1
          if (append_insn (append_str, TRUE) == (int) FAIL)
d4449 1
a4449 1
          if (append_insn (append_str1, TRUE) == (int) FAIL)
d4453 1
a4453 1
          inst.bwarn = -1;
d4459 1
a4459 1
exp_macro_ldst_abs (char *str)
d4463 3
a4465 3
  char append_str[MAX_LITERAL_POOL_SIZE];
  char verifystr[MAX_LITERAL_POOL_SIZE];
  struct score_it inst_backup;
d4468 3
a4470 3
  r1_bak = nor1;
  nor1 = 0;
  memcpy (&inst_backup, &inst, sizeof (struct score_it));
d4474 2
a4475 2
  skip_whitespace (backupstr);
  if ((reg_rd = reg_required_here (&backupstr, -1, REG_TYPE_SCORE)) == (int) FAIL)
d4479 1
a4479 1
  if (skip_past_comma (&backupstr) == (int) FAIL)
d4484 1
a4484 1
  append_insn (append_str, TRUE);
d4486 1
a4486 1
  memcpy (&inst, &inst_backup, sizeof (struct score_it));
d4488 1
a4488 1
  do_ldst_insn (append_str);
d4490 1
a4490 1
  nor1 = r1_bak;
d4492 11
d4504 24
a4527 6
static int
nopic_need_relax (symbolS * sym, int before_relaxing)
{
  if (sym == NULL)
    return 0;
  else if (USE_GLOBAL_POINTER_OPT && g_switch_value > 0)
d4529 36
a4564 19
      const char *symname;
      const char *segname;

      /* Find out whether this symbol can be referenced off the $gp
         register.  It can be if it is smaller than the -G size or if
         it is in the .sdata or .sbss section.  Certain symbols can
         not be referenced off the $gp, although it appears as though
         they can.  */
      symname = S_GET_NAME (sym);
      if (symname != (const char *)NULL
          && (strcmp (symname, "eprol") == 0
              || strcmp (symname, "etext") == 0
              || strcmp (symname, "_gp") == 0
              || strcmp (symname, "edata") == 0
              || strcmp (symname, "_fbss") == 0
              || strcmp (symname, "_fdata") == 0
              || strcmp (symname, "_ftext") == 0
              || strcmp (symname, "end") == 0
              || strcmp (symname, GP_DISP_LABEL) == 0))
d4566 23
a4588 1
          return 1;
d4590 1
a4590 7
      else if ((!S_IS_DEFINED (sym) || S_IS_COMMON (sym)) && (0
      /* We must defer this decision until after the whole file has been read,
         since there might be a .extern after the first use of this symbol.  */
               || (before_relaxing
                   && S_GET_VALUE (sym) == 0)
               || (S_GET_VALUE (sym) != 0
                   && S_GET_VALUE (sym) <= g_switch_value)))
d4592 1
a4592 1
          return 0;
d4594 33
d4628 16
a4643 9
      segname = segment_name (S_GET_SEGMENT (sym));
      return (strcmp (segname, ".sdata") != 0
	      && strcmp (segname, ".sbss") != 0
	      && strncmp (segname, ".sdata.", 7) != 0
	      && strncmp (segname, ".gnu.linkonce.s.", 16) != 0);
    }
  /* We are not optimizing for the $gp register.  */
  else
    return 1;
d4646 1
a4646 3
/* Build a relax frag for lw/st instruction when generating PIC,
   external symbol first and local symbol second.  */

d4648 1
a4648 1
build_lwst_pic (int reg_rd, expressionS exp, const char *insn_name)
d4650 6
a4655 8
  symbolS *add_symbol = exp.X_add_symbol;
  int add_number = exp.X_add_number;
  struct score_it fix_insts[RELAX_INST_NUM];
  struct score_it var_insts[RELAX_INST_NUM];
  int fix_num = 0;
  int var_num = 0;
  char tmp[MAX_LITERAL_POOL_SIZE];
  int r1_bak;
d4657 15
a4671 2
  r1_bak = nor1;
  nor1 = 0;
d4673 6
a4678 1
  if ((add_number == 0) || (add_number >= -0x8000 && add_number <= 0x7fff))
d4680 5
a4684 2
      fix_num = 1;
      var_num = 2;
d4686 2
a4687 8
      /* For an external symbol, two insns are generated;
         For a local symbol, three insns are generated.  */
      /* Fix part
         For an external symbol: lw rD, <sym>($gp)
                                 (BFD_RELOC_SCORE_GOT15)  */
      sprintf (tmp, "lw_pic r1, %s", add_symbol->bsym->name);
      if (append_insn (tmp, FALSE) == (int) FAIL)
        return;
d4689 187
a4875 1
      memcpy (&fix_insts[0], &inst, sizeof (struct score_it));
d4881 2
a4882 2
      inst.reloc.type = BFD_RELOC_SCORE_GOT15;
      memcpy (&var_insts[0], &inst, sizeof (struct score_it));
d4884 1
a4884 1
      if (append_insn (tmp, FALSE) == (int) FAIL)
d4887 2
a4888 2
      memcpy (&var_insts[1], &inst, sizeof (struct score_it));
      build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);
d4892 1
a4892 1
      if (append_insn (tmp, TRUE) == (int) FAIL)
d4896 1
a4896 1
      inst.bwarn = -1;
d4900 1
a4900 1
      inst.error = _("PIC code offset overflow (max 16 signed bits)");
d4904 1
a4904 1
  nor1 = r1_bak;
d4908 1
a4908 1
do_macro_ldst_label (char *str)
d4917 5
a4921 5
  char append_str[3][MAX_LITERAL_POOL_SIZE];
  char verifystr[MAX_LITERAL_POOL_SIZE];
  struct score_it inst_backup;
  struct score_it inst_expand[3];
  struct score_it inst_main;
d4923 1
a4923 1
  memcpy (&inst_backup, &inst, sizeof (struct score_it));
d4927 2
a4928 2
  skip_whitespace (backup_str);
  if ((reg_rd = reg_required_here (&backup_str, -1, REG_TYPE_SCORE)) == (int) FAIL)
d4931 1
a4931 1
  if (skip_past_comma (&backup_str) == (int) FAIL)
d4939 2
a4940 2
      inst.type = Rd_rvalueRs_preSI12;
      do_ldst_insn (str);
d4946 3
a4948 4
  inst.type = Rd_rvalueRs_SI15;
  if ((my_get_expression (&inst.reloc.exp, &backup_str) == (int) FAIL)
      || (validate_immediate (inst.reloc.exp.X_add_number, _VALUE, 0) == (int) FAIL)
      || (end_of_line (backup_str) == (int) FAIL))
d4950 12
d4966 1
a4966 1
      if (inst.reloc.exp.X_add_symbol == 0)
d4968 2
a4969 2
          memcpy (&inst, &inst_backup, sizeof (struct score_it));
          exp_macro_ldst_abs (str);
d4975 1
a4975 1
  inst.type = Rd_rvalueRs_SI15;
d4977 2
a4978 2
  if ((data_op2 (&backup_str, 1, _GP_IMM15) == (int) FAIL)
      || (end_of_line (backup_str) == (int) FAIL))
d4984 1
a4984 1
      if (inst.reloc.exp.X_add_symbol == 0)
d4986 2
a4987 2
          if (!inst.error)
	    inst.error = BAD_ARGS;
d4992 1
a4992 1
      if (score_pic == PIC)
d4995 2
a4996 2
          ldst_idx = inst.instruction & OPC_PSEUDOLDST_MASK;
          build_lwst_pic (reg_rd, inst.reloc.exp, score_ldst_insns[ldst_idx * 3 + 0].template);
d5001 3
a5003 3
          if ((inst.reloc.exp.X_add_number <= 0x3fff)
               && (inst.reloc.exp.X_add_number >= -0x4000)
               && (!nopic_need_relax (inst.reloc.exp.X_add_symbol, 1)))
d5008 7
a5014 7
              ldst_idx = inst.instruction & OPC_PSEUDOLDST_MASK;
              inst.instruction &= ~OPC_PSEUDOLDST_MASK;
              inst.instruction |= score_ldst_insns[ldst_idx * 3 + 0].value;
              inst.instruction |= reg_rd << 20;
              inst.instruction |= GP << 15;
              inst.relax_inst = 0x8000;
              inst.relax_size = 0;
d5020 4
a5023 4
  /* Backup inst.  */
  memcpy (&inst_main, &inst, sizeof (struct score_it));
  r1_bak = nor1;
  nor1 = 0;
d5035 1
a5035 1
      if (append_insn (append_str[i], FALSE) == (int) FAIL)
d5038 1
a5038 1
      memcpy (&inst_expand[i], &inst, sizeof (struct score_it));
d5046 10
a5055 2
      inst_main.instruction = adjust_paritybit (inst_main.instruction, GET_INSN_CLASS (inst_main.type));
      inst_main.relax_size = inst_expand[0].size + inst_expand[1].size + inst_expand[2].size;
d5059 2
a5060 2
	inst_expand[i].instruction = adjust_paritybit (inst_expand[i].instruction
						       , GET_INSN_CLASS (inst_expand[i].type));
d5063 1
a5063 1
      handle_dependency (&inst_main);
d5077 1
a5077 1
      md_number_to_chars (p, inst_main.instruction, inst_main.size);
d5081 1
a5081 1
          fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
d5089 1
a5089 1
      /* GP instruction can not do optimization, only can do relax between
d5091 2
a5092 2
      p = frag_var (rs_machine_dependent, inst_main.relax_size + RELAX_PAD_BYTE, 0,
                    RELAX_ENCODE (inst_main.size, inst_main.relax_size, inst_main.type, 0, 4, 0),
d5096 2
a5097 2
         no calling gen_insn_frag, no fixS will be generated.  */
      md_number_to_chars (p, inst_expand[0].instruction, inst_expand[0].size);
d5099 1
a5099 1
      md_number_to_chars (p, inst_expand[1].instruction, inst_expand[1].size);
d5101 8
a5108 1
      md_number_to_chars (p, inst_expand[2].instruction, inst_expand[2].size);
d5112 3
a5114 3
      gen_insn_frag (&inst_expand[0], NULL);
      gen_insn_frag (&inst_expand[1], NULL);
      gen_insn_frag (&inst_expand[2], NULL);
d5116 1
a5116 1
  nor1 = r1_bak;
d5119 1
a5119 1
  inst.bwarn = -1;
d5123 1
a5123 1
do_lw_pic (char *str)
d5127 5
a5131 5
  skip_whitespace (str);
  if (((reg_rd = reg_required_here (&str, 20, REG_TYPE_SCORE)) == (int) FAIL)
      || (skip_past_comma (&str) == (int) FAIL)
      || (my_get_expression (&inst.reloc.exp, &str) == (int) FAIL)
      || (end_of_line (str) == (int) FAIL))
d5137 1
a5137 1
      if (inst.reloc.exp.X_add_symbol == 0)
d5139 2
a5140 2
          if (!inst.error)
	    inst.error = BAD_ARGS;
d5145 2
a5146 2
      inst.instruction |= GP << 15;
      inst.reloc.type = BFD_RELOC_SCORE_GOT15;
d5151 1
a5151 1
do_empty (char *str)
d5154 1
a5154 1
  if (university_version == 1)
d5156 4
a5159 4
      if (((inst.instruction & 0x3e0003ff) == 0x0c000004)
          || ((inst.instruction & 0x3e0003ff) == 0x0c000024)
          || ((inst.instruction & 0x3e0003ff) == 0x0c000044)
          || ((inst.instruction & 0x3e0003ff) == 0x0c000064))
d5161 1
a5161 1
          inst.error = ERR_FOR_SCORE5U_MMU;
d5165 1
a5165 1
  if (end_of_line (str) == (int) FAIL)
d5168 1
a5168 1
  if (inst.relax_inst != 0x8000)
d5170 1
a5170 1
      if (inst.type == NO_OPD)
d5172 1
a5172 1
          inst.relax_size = 2;
d5176 1
a5176 1
          inst.relax_size = 4;
d5182 8
a5189 1
do_jump (char *str)
d5193 3
a5195 3
  skip_whitespace (str);
  if (my_get_expression (&inst.reloc.exp, &str) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d5198 1
a5198 1
  if (inst.reloc.exp.X_add_symbol == 0)
d5200 1
a5200 1
      inst.error = _("lacking label  ");
d5204 2
a5205 2
  if (((inst.reloc.exp.X_add_number & 0xff000000) != 0)
      && ((inst.reloc.exp.X_add_number & 0xff000000) != 0xff000000))
d5207 1
a5207 1
      inst.error = _("invalid constant: 25 bit expression not in range -2^24..2^24");
d5213 2
a5214 2
  inst.reloc.type = BFD_RELOC_SCORE_JMP;
  inst.reloc.pc_rel = 1;
d5219 1
a5219 26
do16_jump (char *str)
{
  skip_whitespace (str);
  if (my_get_expression (&inst.reloc.exp, &str) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
    {
      return;
    }
  else if (inst.reloc.exp.X_add_symbol == 0)
    {
      inst.error = _("lacking label  ");
      return;
    }
  else if (((inst.reloc.exp.X_add_number & 0xfffff800) != 0)
           && ((inst.reloc.exp.X_add_number & 0xfffff800) != 0xfffff800))
    {
      inst.error = _("invalid constant: 12 bit expression not in range -2^11..2^11");
      return;
    }

  inst.reloc.type = BFD_RELOC_SCORE16_JMP;
  inst.reloc.pc_rel = 1;
}

static void
do_branch (char *str)
d5221 2
a5222 4
  unsigned long abs_value = 0;

  if (my_get_expression (&inst.reloc.exp, &str) == (int) FAIL
      || end_of_line (str) == (int) FAIL)
d5226 1
a5226 1
  else if (inst.reloc.exp.X_add_symbol == 0)
d5228 1
a5228 1
      inst.error = _("lacking label  ");
d5231 2
a5232 2
  else if (((inst.reloc.exp.X_add_number & 0xff000000) != 0)
           && ((inst.reloc.exp.X_add_number & 0xff000000) != 0xff000000))
d5234 1
a5234 1
      inst.error = _("invalid constant: 20 bit expression not in range -2^19..2^19");
d5238 2
a5239 2
  inst.reloc.type = BFD_RELOC_SCORE_BRANCH;
  inst.reloc.pc_rel = 1;
d5242 1
a5242 1
  inst.instruction |= (inst.reloc.exp.X_add_number & 0x3fe) | ((inst.reloc.exp.X_add_number & 0xffc00) << 5);
d5245 2
a5246 1
  if ((inst.relax_inst != 0x8000) && (abs_value & 0xfffffe00) == 0)
d5248 2
a5249 3
      inst.relax_inst |= (((inst.instruction >> 10) & 0xf) << 8);
      inst.relax_inst |= ((inst.reloc.exp.X_add_number >> 1) & 0xff);
      inst.relax_size = 2;
d5253 1
a5253 1
      inst.relax_inst = 0x8000;
d5258 1
a5258 1
do16_branch (char *str)
d5260 2
a5261 2
  if ((my_get_expression (&inst.reloc.exp, &str) == (int) FAIL
      || end_of_line (str) == (int) FAIL))
d5265 1
a5265 53
  else if (inst.reloc.exp.X_add_symbol == 0)
    {
      inst.error = _("lacking label");
    }
  else if (((inst.reloc.exp.X_add_number & 0xffffff00) != 0)
           && ((inst.reloc.exp.X_add_number & 0xffffff00) != 0xffffff00))
    {
      inst.error = _("invalid constant: 9 bit expression not in range -2^8..2^8");
    }
  else
    {
      inst.reloc.type = BFD_RELOC_SCORE16_BRANCH;
      inst.reloc.pc_rel = 1;
      inst.instruction |= ((inst.reloc.exp.X_add_number >> 1) & 0xff);
    }
}

/* Iterate over the base tables to create the instruction patterns.  */
static void
build_score_ops_hsh (void)
{
  unsigned int i;
  static struct obstack insn_obstack;

  obstack_begin (&insn_obstack, 4000);
  for (i = 0; i < sizeof (score_insns) / sizeof (struct asm_opcode); i++)
    {
      const struct asm_opcode *insn = score_insns + i;
      unsigned len = strlen (insn->template);
      struct asm_opcode *new;
      char *template;
      new = obstack_alloc (&insn_obstack, sizeof (struct asm_opcode));
      template = obstack_alloc (&insn_obstack, len + 1);

      strcpy (template, insn->template);
      new->template = template;
      new->parms = insn->parms;
      new->value = insn->value;
      new->relax_value = insn->relax_value;
      new->type = insn->type;
      new->bitmask = insn->bitmask;
      hash_insert (score_ops_hsh, new->template, (void *) new);
    }
}

static void
build_dependency_insn_hsh (void)
{
  unsigned int i;
  static struct obstack dependency_obstack;

  obstack_begin (&dependency_obstack, 4000);
  for (i = 0; i < sizeof (insn_to_dependency_table) / sizeof (insn_to_dependency_table[0]); i++)
d5267 1
a5267 10
      const struct insn_to_dependency *tmp = insn_to_dependency_table + i;
      unsigned len = strlen (tmp->insn_name);
      struct insn_to_dependency *new;

      new = obstack_alloc (&dependency_obstack, sizeof (struct insn_to_dependency));
      new->insn_name = obstack_alloc (&dependency_obstack, len + 1);

      strcpy (new->insn_name, tmp->insn_name);
      new->type = tmp->type;
      hash_insert (dependency_insn_hsh, new->insn_name, (void *) new);
d5269 2
a5270 25
}

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).  */

void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

static valueT
md_chars_to_number (char *buf, int n)
{
  valueT result = 0;
  unsigned char *where = (unsigned char *)buf;

  if (target_big_endian)
d5272 1
a5272 5
      while (n--)
        {
          result <<= 8;
          result |= (*where++ & 255);
        }
d5276 5
a5280 5
      while (n--)
        {
          result <<= 8;
          result |= (where[n] & 255);
        }
a5281 8

  return result;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, target_big_endian);
d5284 1
a5284 2
/* Return true if the given symbol should be considered local for PIC.  */

d5286 1
a5286 1
pic_need_relax (symbolS *sym, asection *segtype)
d5334 2
a5335 2
static int
judge_size_before_relax (fragS * fragp, asection *sec)
d5337 22
a5358 1
  int change = 0;
d5360 3
a5362 4
  if (score_pic == NO_PIC)
    change = nopic_need_relax (fragp->fr_symbol, 0);
  else
    change = pic_need_relax (fragp->fr_symbol, sec);
d5364 3
a5366 1
  if (change == 1)
d5368 3
a5370 8
      /* Only at the first time determining whether GP instruction relax should be done,
         return the difference between insntruction size and instruction relax size.  */
      if (fragp->fr_opcode == NULL)
	{
	  fragp->fr_fix = RELAX_NEW (fragp->fr_subtype);
	  fragp->fr_opcode = fragp->fr_literal + RELAX_RELOC1 (fragp->fr_subtype);
          return RELAX_NEW (fragp->fr_subtype) - RELAX_OLD (fragp->fr_subtype);
	}
d5373 2
a5374 1
  return 0;
d5377 3
a5379 6
/* In this function, we determine whether GP instruction should do relaxation,
   for the label being against was known now.
   Doing this here but not in md_relax_frag() can induce iteration times
   in stage of doing relax.  */
int
md_estimate_size_before_relax (fragS * fragp, asection * sec ATTRIBUTE_UNUSED)
d5381 1
a5381 3
  if ((RELAX_TYPE (fragp->fr_subtype) == Insn_GP)
      || (RELAX_TYPE (fragp->fr_subtype) == Insn_PIC))
    return judge_size_before_relax (fragp, sec);
d5383 6
a5388 11
  return 0;
}

static int
b32_relax_to_b16 (fragS * fragp)
{
  int grows = 0;
  int relaxable_p = 0;
  int old;
  int new;
  int frag_addr = fragp->fr_address + fragp->insn_addr;
d5390 1
a5390 5
  addressT symbol_address = 0;
  symbolS *s;
  offsetT offset;
  unsigned long value;
  unsigned long abs_value;
d5392 5
a5396 13
  /* FIXME : here may be able to modify better .
     I don't know how to get the fragp's section ,
     so in relax stage , it may be wrong to calculate the symbol's offset when the frag's section
     is different from the symbol's.  */

  old = RELAX_OLD (fragp->fr_subtype);
  new = RELAX_NEW (fragp->fr_subtype);
  relaxable_p = RELAX_OPT (fragp->fr_subtype);

  s = fragp->fr_symbol;
  /* b/bl immediate  */
  if (s == NULL)
    frag_addr = 0;
d5399 2
a5400 2
      if (s->bsym != 0)
	symbol_address = (addressT) s->sy_frag->fr_address;
d5402 1
d5404 9
a5412 6
  value = md_chars_to_number (fragp->fr_literal, INSN_SIZE);

  /* b 32's offset : 20 bit, b 16's tolerate field : 0xff.  */
  offset = ((value & 0x3ff0000) >> 6) | (value & 0x3fe);
  if ((offset & 0x80000) == 0x80000)
    offset |= 0xfff00000;
d5414 1
a5414 3
  abs_value = offset + symbol_address - frag_addr;
  if ((abs_value & 0x80000000) == 0x80000000)
    abs_value = 0xffffffff - abs_value + 1;
d5416 4
a5419 3
  /* Relax branch 32 to branch 16.  */
  if (relaxable_p && (s->bsym != NULL) && ((abs_value & 0xffffff00) == 0)
      && (S_IS_DEFINED (s) && !S_IS_COMMON (s) && !S_IS_EXTERNAL (s)))
d5421 1
a5421 1
      /* do nothing.  */
d5425 3
a5427 3
      /* Branch 32 can not be relaxed to b 16, so clear OPT bit.  */
      fragp->fr_opcode = NULL;
      fragp->fr_subtype = RELAX_OPT_CLEAR (fragp->fr_subtype);
a5428 2

  return grows;
d5431 2
a5432 5
/* Main purpose is to determine whether one frag should do relax.
   frag->fr_opcode indicates this point.  */

int
score_relax_frag (asection * sec ATTRIBUTE_UNUSED, fragS * fragp, long stretch ATTRIBUTE_UNUSED)
d5434 2
a5435 10
  int grows = 0;
  int insn_size;
  int insn_relax_size;
  int do_relax_p = 0;           /* Indicate doing relaxation for this frag.  */
  int relaxable_p = 0;
  bfd_boolean word_align_p = FALSE;
  fragS *next_fragp;

  /* If the instruction address is odd, make it half word align first.  */
  if ((fragp->fr_address) % 2 != 0)
d5437 2
a5438 5
      if ((fragp->fr_address + fragp->insn_addr) % 2 != 0)
	{
          fragp->insn_addr = 1;
          grows += 1;
	}
d5441 7
a5447 1
  word_align_p = ((fragp->fr_address + fragp->insn_addr) % 4 == 0) ? TRUE : FALSE;
d5449 1
a5449 2
  /* Get instruction size and relax size after the last relaxation.  */
  if (fragp->fr_opcode)
d5451 2
a5452 2
      insn_size = RELAX_NEW (fragp->fr_subtype);
      insn_relax_size = RELAX_OLD (fragp->fr_subtype);
d5455 10
d5466 2
a5467 2
      insn_size = RELAX_OLD (fragp->fr_subtype);
      insn_relax_size = RELAX_NEW (fragp->fr_subtype);
d5470 8
a5477 4
  /* Handle specially for GP instruction.  for, judge_size_before_relax() has already determine
     whether the GP instruction should do relax.  */
  if ((RELAX_TYPE (fragp->fr_subtype) == Insn_GP)
      || (RELAX_TYPE (fragp->fr_subtype) == Insn_PIC))
d5479 1
a5479 18
      if (!word_align_p)
        {
          if (fragp->insn_addr < 2)
            {
              fragp->insn_addr += 2;
              grows += 2;
            }
          else
            {
              fragp->insn_addr -= 2;
              grows -= 2;
            }
        }

      if (fragp->fr_opcode)
	fragp->fr_fix = RELAX_NEW (fragp->fr_subtype) + fragp->insn_addr;
      else
	fragp->fr_fix = RELAX_OLD (fragp->fr_subtype) + fragp->insn_addr;
d5483 4
a5486 11
      if (RELAX_TYPE (fragp->fr_subtype) == PC_DISP19div2)
	b32_relax_to_b16 (fragp);

      relaxable_p = RELAX_OPT (fragp->fr_subtype);
      next_fragp = fragp->fr_next;
      while ((next_fragp) && (next_fragp->fr_type != rs_machine_dependent))
	{
          next_fragp = next_fragp->fr_next;
	}

      if (next_fragp)
d5488 3
a5490 11
          int n_insn_size;
          int n_relaxable_p = 0;

          if (next_fragp->fr_opcode)
            {
              n_insn_size = RELAX_NEW (next_fragp->fr_subtype);
            }
          else
            {
              n_insn_size = RELAX_OLD (next_fragp->fr_subtype);
            }
d5492 9
a5500 55
          if (RELAX_TYPE (next_fragp->fr_subtype) == PC_DISP19div2)
            b32_relax_to_b16 (next_fragp);
          n_relaxable_p = RELAX_OPT (next_fragp->fr_subtype);

          if (word_align_p)
            {
              if (insn_size == 4)
                {
                  /* 32 -> 16.  */
                  if (relaxable_p && ((n_insn_size == 2) || n_relaxable_p))
                    {
                      grows -= 2;
                      do_relax_p = 1;
                    }
                }
              else if (insn_size == 2)
                {
                  /* 16 -> 32.  */
                  if (relaxable_p && (((n_insn_size == 4) && !n_relaxable_p) || (n_insn_size > 4)))
                    {
                      grows += 2;
                      do_relax_p = 1;
                    }
                }
              else
                {
		  abort ();
                }
            }
          else
            {
              if (insn_size == 4)
                {
                  /* 32 -> 16.  */
                  if (relaxable_p)
                    {
                      grows -= 2;
                      do_relax_p = 1;
                    }
                  /* Make the 32 bit insturction word align.  */
                  else
                    {
                      fragp->insn_addr += 2;
                      grows += 2;
		    }
                }
              else if (insn_size == 2)
                {
                  /* Do nothing.  */
                }
              else
                {
		  abort ();
                }
            }
d5504 1
a5504 41
	  /* Here, try best to do relax regardless fragp->fr_next->fr_type.  */
          if (word_align_p == FALSE)
            {
              if (insn_size % 4 == 0)
                {
                  /* 32 -> 16.  */
                  if (relaxable_p)
                    {
                      grows -= 2;
                      do_relax_p = 1;
                    }
                  else
                    {
                      fragp->insn_addr += 2;
                      grows += 2;
                    }
                }
            }
          else
            {
	      /* Do nothing.  */
            }
        }

      /* fragp->fr_opcode indicates whether this frag should be relaxed.  */
      if (do_relax_p)
        {
          if (fragp->fr_opcode)
            {
              fragp->fr_opcode = NULL;
	      /* Guarantee estimate stage is correct.  */
              fragp->fr_fix = RELAX_OLD (fragp->fr_subtype);
              fragp->fr_fix += fragp->insn_addr;
            }
          else
            {
              fragp->fr_opcode = fragp->fr_literal + RELAX_RELOC1 (fragp->fr_subtype);
	      /* Guarantee estimate stage is correct.  */
              fragp->fr_fix = RELAX_NEW (fragp->fr_subtype);
              fragp->fr_fix += fragp->insn_addr;
            }
a5505 15
      else
	{
          if (fragp->fr_opcode)
            {
	      /* Guarantee estimate stage is correct.  */
              fragp->fr_fix = RELAX_NEW (fragp->fr_subtype);
              fragp->fr_fix += fragp->insn_addr;
            }
          else
            {
	      /* Guarantee estimate stage is correct.  */
              fragp->fr_fix = RELAX_OLD (fragp->fr_subtype);
              fragp->fr_fix += fragp->insn_addr;
            }
	}
a5506 2

  return grows;
d5509 2
a5510 2
void
md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED, fragS * fragp)
d5512 2
a5513 10
  int old;
  int new;
  char backup[20];
  fixS *fixp;

  old = RELAX_OLD (fragp->fr_subtype);
  new = RELAX_NEW (fragp->fr_subtype);

  /* fragp->fr_opcode indicates whether this frag should be relaxed.  */
  if (fragp->fr_opcode == NULL)
d5515 2
a5516 7
      memcpy (backup, fragp->fr_literal, old);
      fragp->fr_fix = old;
    }
  else
    {
      memcpy (backup, fragp->fr_literal + old, new);
      fragp->fr_fix = new;
d5519 7
a5525 15
  fixp = fragp->tc_frag_data.fixp;
  while (fixp && fixp->fx_frag == fragp && fixp->fx_where < old)
    {
      if (fragp->fr_opcode)
	fixp->fx_done = 1;
      fixp = fixp->fx_next;
    }
  while (fixp && fixp->fx_frag == fragp)
    {
      if (fragp->fr_opcode)
	fixp->fx_where -= old + fragp->insn_addr;
      else
	fixp->fx_done = 1;
      fixp = fixp->fx_next;
    }
d5527 1
a5527 1
  if (fragp->insn_addr)
d5529 2
a5530 1
      md_number_to_chars (fragp->fr_literal, 0x0, fragp->insn_addr);
d5532 2
a5533 2
  memcpy (fragp->fr_literal + fragp->insn_addr, backup, fragp->fr_fix);
  fragp->fr_fix += fragp->insn_addr;
a5535 2
/* Implementation of md_frag_check.
   Called after md_convert_frag().  */
d5537 3
a5539 2
void
score_frag_check (fragS * fragp ATTRIBUTE_UNUSED)
d5541 2
a5542 1
  know (fragp->insn_addr <= RELAX_PAD_BYTE);
d5545 2
a5546 2
bfd_boolean
score_fix_adjustable (fixS * fixP)
d5548 2
a5549 16
  if (fixP->fx_addsy == NULL)
    {
      return 1;
    }
  else if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && (S_IS_EXTERNAL (fixP->fx_addsy) || S_IS_WEAK (fixP->fx_addsy)))
    {
      return 0;
    }
  else if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    {
      return 0;
    }

  return 1;
d5552 2
a5553 4
/* Implementation of TC_VALIDATE_FIX.
   Called before md_apply_fix() and after md_convert_frag().  */
void
score_validate_fix (fixS *fixP)
d5555 4
a5558 1
  fixP->fx_where += fixP->fx_frag->insn_addr;
d5561 2
a5562 2
long
md_pcrel_from (fixS * fixP)
d5564 1
a5564 1
  long retval = 0;
d5566 10
a5575 3
  if (fixP->fx_addsy
      && (S_GET_SEGMENT (fixP->fx_addsy) == undefined_section)
      && (fixP->fx_subsy == NULL))
d5577 14
a5590 1
      retval = 0;
a5591 6
  else
    {
      retval = fixP->fx_where + fixP->fx_frag->fr_address;
    }

  return retval;
d5594 2
a5595 2
int
score_force_relocation (struct fix *fixp)
d5597 1
a5597 1
  int retval = 0;
d5599 7
a5605 6
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_SCORE_JMP
      || fixp->fx_r_type == BFD_RELOC_SCORE_BRANCH
      || fixp->fx_r_type == BFD_RELOC_SCORE16_JMP
      || fixp->fx_r_type == BFD_RELOC_SCORE16_BRANCH)
d5607 4
a5610 1
      retval = 1;
d5612 4
a5615 2

  return retval;
d5618 2
a5619 3
/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
d5621 3
a5623 1
  int align = bfd_get_section_alignment (stdoutput, segment);
d5625 5
a5629 1
  return ((size + (1 << align) - 1) & (-1 << align));
d5632 2
a5633 2
void
md_apply_fix (fixS *fixP, valueT *valP, segT seg)
d5635 2
a5636 5
  offsetT value = *valP;
  offsetT abs_value = 0;
  offsetT newval;
  offsetT content;
  unsigned short HI, LO;
d5638 1
a5638 4
  char *buf = fixP->fx_frag->fr_literal + fixP->fx_where;

  assert (fixP->fx_r_type < BFD_RELOC_UNUSED);
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
d5640 2
a5641 2
      if (fixP->fx_r_type != BFD_RELOC_SCORE_DUMMY_HI16)
        fixP->fx_done = 1;
d5643 3
a5645 5

  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo it's effects here.  */
  if (fixP->fx_pcrel)
d5647 1
a5647 23
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
    }

  /* Remember value for emit_reloc.  */
  fixP->fx_addnumber = value;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_HI16_S:
      if (fixP->fx_done)
        {                       /* For la rd, imm32.  */
          newval = md_chars_to_number (buf, INSN_SIZE);
          HI = (value) >> 16;   /* mul to 2, then take the hi 16 bit.  */
          newval |= (HI & 0x3fff) << 1;
          newval |= ((HI >> 14) & 0x3) << 16;
          md_number_to_chars (buf, newval, INSN_SIZE);
        }
      break;
    case BFD_RELOC_LO16:
      if (fixP->fx_done)        /* For la rd, imm32.  */
d5649 2
a5650 27
          newval = md_chars_to_number (buf, INSN_SIZE);
          LO = (value) & 0xffff;
          newval |= (LO & 0x3fff) << 1; /* 16 bit: imm -> 14 bit in lo, 2 bit in hi.  */
          newval |= ((LO >> 14) & 0x3) << 16;
          md_number_to_chars (buf, newval, INSN_SIZE);
        }
      break;
    case BFD_RELOC_SCORE_JMP:
      {
        content = md_chars_to_number (buf, INSN_SIZE);
        value = fixP->fx_offset;
        content = (content & ~0x3ff7ffe) | ((value << 1) & 0x3ff0000) | (value & 0x7fff);
        md_number_to_chars (buf, content, INSN_SIZE);
      }
      break;
    case BFD_RELOC_SCORE_BRANCH:
      if ((S_GET_SEGMENT (fixP->fx_addsy) != seg) || (fixP->fx_addsy != NULL && S_IS_EXTERNAL (fixP->fx_addsy)))
        value = fixP->fx_offset;
      else
        fixP->fx_done = 1;

      content = md_chars_to_number (buf, INSN_SIZE);
      if ((fixP->fx_frag->fr_opcode != 0) && ((content & 0x80008000) != 0x80008000))
        {
          if ((value & 0x80000000) == 0x80000000)
            abs_value = 0xffffffff - value + 1;
          if ((abs_value & 0xffffff00) != 0)
d5652 2
a5653 3
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x) [-2^8 ~ 2^8]"), (unsigned int)value);
              return;
d5655 1
a5655 6
          content = md_chars_to_number (buf, INSN16_SIZE);
          content &= 0xff00;
          content = (content & 0xff00) | ((value >> 1) & 0xff);
          md_number_to_chars (buf, content, INSN16_SIZE);
          fixP->fx_r_type = BFD_RELOC_SCORE16_BRANCH;
          fixP->fx_size = 2;
d5659 2
a5660 3
          if ((value & 0x80000000) == 0x80000000)
            abs_value = 0xffffffff - value + 1;
          if ((abs_value & 0xfff80000) != 0)
d5662 2
a5663 3
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x) [-2^19 ~ 2^19]"), (unsigned int)value);
              return;
d5665 1
a5665 4
          content = md_chars_to_number (buf, INSN_SIZE);
          content &= 0xfc00fc01;
          content = (content & 0xfc00fc01) | (value & 0x3fe) | ((value << 6) & 0x3ff0000);
          md_number_to_chars (buf, content, INSN_SIZE);
a5666 112
      break;
    case BFD_RELOC_SCORE16_JMP:
      content = md_chars_to_number (buf, INSN16_SIZE);
      content &= 0xf001;
      value = fixP->fx_offset & 0xfff;
      content = (content & 0xfc01) | (value & 0xffe);
      md_number_to_chars (buf, content, INSN16_SIZE);
      break;
    case BFD_RELOC_SCORE16_BRANCH:
      content = md_chars_to_number (buf, INSN_SIZE);
      if ((fixP->fx_frag->fr_opcode != 0) && ((content & 0x80008000) == 0x80008000))
        {
          if ((S_GET_SEGMENT (fixP->fx_addsy) != seg) ||
              (fixP->fx_addsy != NULL && S_IS_EXTERNAL (fixP->fx_addsy)))
            value = fixP->fx_offset;
          else
            fixP->fx_done = 1;
          if ((value & 0x80000000) == 0x80000000)
            abs_value = 0xffffffff - value + 1;
          if ((abs_value & 0xfff80000) != 0)
            {
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x) [-2^19 ~ 2^19]"), (unsigned int)value);
              return;
            }
          content = md_chars_to_number (buf, INSN_SIZE);
          content = (content & 0xfc00fc01) | (value & 0x3fe) | ((value << 6) & 0x3ff0000);
          md_number_to_chars (buf, content, INSN_SIZE);
          fixP->fx_r_type = BFD_RELOC_SCORE_BRANCH;
          fixP->fx_size = 4;
          break;
        }
      else
        {
          /* In differnt section.  */
          if ((S_GET_SEGMENT (fixP->fx_addsy) != seg) ||
              (fixP->fx_addsy != NULL && S_IS_EXTERNAL (fixP->fx_addsy)))
            value = fixP->fx_offset;
          else
            fixP->fx_done = 1;

          if ((value & 0x80000000) == 0x80000000)
            abs_value = 0xffffffff - value + 1;
          if ((abs_value & 0xffffff00) != 0)
            {
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _(" branch relocation truncate (0x%x)  [-2^8 ~ 2^8]"), (unsigned int)value);
              return;
            }
          content = md_chars_to_number (buf, INSN16_SIZE);
          content = (content & 0xff00) | ((value >> 1) & 0xff);
          md_number_to_chars (buf, content, INSN16_SIZE);
          break;
        }
    case BFD_RELOC_8:
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 1);
#ifdef OBJ_ELF
      else
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 1);
        }
#endif
      break;

    case BFD_RELOC_16:
      if (fixP->fx_done || fixP->fx_pcrel)
        md_number_to_chars (buf, value, 2);
#ifdef OBJ_ELF
      else
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 2);
        }
#endif
      break;
    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
      if (fixP->fx_done || fixP->fx_pcrel)
        md_number_to_chars (buf, value, 4);
#ifdef OBJ_ELF
      else
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 4);
        }
#endif
      break;
    case BFD_RELOC_VTABLE_INHERIT:
      fixP->fx_done = 0;
      if (fixP->fx_addsy && !S_IS_DEFINED (fixP->fx_addsy) && !S_IS_WEAK (fixP->fx_addsy))
        S_SET_WEAK (fixP->fx_addsy);
      break;
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      break;
    case BFD_RELOC_SCORE_GPREL15:
      content = md_chars_to_number (buf, INSN_SIZE);
      if ((fixP->fx_frag->fr_opcode != 0) && ((content & 0xfc1c8000) != 0x94188000))
        fixP->fx_r_type = BFD_RELOC_NONE;
      fixP->fx_done = 0;
      break;
    case BFD_RELOC_SCORE_GOT15:
    case BFD_RELOC_SCORE_DUMMY_HI16:
    case BFD_RELOC_SCORE_GOT_LO16:
    case BFD_RELOC_SCORE_CALL15:
    case BFD_RELOC_GPREL32:
      break;
    case BFD_RELOC_NONE:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line, _("bad relocation fixup type (%d)"), fixP->fx_r_type);
d5668 12
d5682 3
a5684 3
/* Translate internal representation of relocation info to BFD target format.  */
arelent **
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED, fixS * fixp)
d5686 2
a5687 7
  static arelent *retval[MAX_RELOC_EXPANSION + 1];  /* MAX_RELOC_EXPANSION equals 2.  */
  arelent *reloc;
  bfd_reloc_code_real_type code;
  char *type;
  fragS *f;
  symbolS *s;
  expressionS e;
d5689 6
a5694 2
  reloc = retval[0] = xmalloc (sizeof (arelent));
  retval[1] = NULL;
d5696 16
a5711 8
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->addend = fixp->fx_offset;

  /* If this is a variant frag, we may need to adjust the existing
     reloc and generate a new one.  */
  if (fixp->fx_frag->fr_opcode != NULL && (fixp->fx_r_type == BFD_RELOC_SCORE_GPREL15))
d5713 16
a5728 4
      /* Update instruction imm bit.  */
      offsetT newval;
      unsigned short off;
      char *buf;
d5730 7
a5736 6
      buf = fixp->fx_frag->fr_literal + fixp->fx_frag->insn_addr;
      newval = md_chars_to_number (buf, INSN_SIZE);
      off = fixp->fx_offset >> 16;
      newval |= (off & 0x3fff) << 1;
      newval |= ((off >> 14) & 0x3) << 16;
      md_number_to_chars (buf, newval, INSN_SIZE);
d5738 1
a5738 6
      buf += INSN_SIZE;
      newval = md_chars_to_number (buf, INSN_SIZE);
      off = fixp->fx_offset & 0xffff;
      newval |= ((off & 0x3fff) << 1);
      newval |= (((off >> 14) & 0x3) << 16);
      md_number_to_chars (buf, newval, INSN_SIZE);
d5740 2
a5741 19
      retval[1] = xmalloc (sizeof (arelent));
      retval[2] = NULL;
      retval[1]->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
      *retval[1]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      retval[1]->address = (reloc->address + RELAX_RELOC2 (fixp->fx_frag->fr_subtype));

      f = fixp->fx_frag;
      s = f->fr_symbol;
      e = s->sy_value;

      retval[1]->addend = 0;
      retval[1]->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_LO16);
      assert (retval[1]->howto != NULL);

      fixp->fx_r_type = BFD_RELOC_HI16_S;
    }

  code = fixp->fx_r_type;
  switch (fixp->fx_r_type)
d5743 3
a5745 28
    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
        {
          code = BFD_RELOC_32_PCREL;
          break;
        }
    case BFD_RELOC_HI16_S:
    case BFD_RELOC_LO16:
    case BFD_RELOC_SCORE_JMP:
    case BFD_RELOC_SCORE_BRANCH:
    case BFD_RELOC_SCORE16_JMP:
    case BFD_RELOC_SCORE16_BRANCH:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_SCORE_GPREL15:
    case BFD_RELOC_SCORE_GOT15:
    case BFD_RELOC_SCORE_DUMMY_HI16:
    case BFD_RELOC_SCORE_GOT_LO16:
    case BFD_RELOC_SCORE_CALL15:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_NONE:
      code = fixp->fx_r_type;
      break;
    default:
      type = _("<unknown>");
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    _("cannot represent %s relocation in this object file format"), type);
      return NULL;
d5747 4
a5750 3

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (reloc->howto == NULL)
d5752 3
a5754 4
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    _("cannot represent %s relocation in this object file format1"),
                    bfd_get_reloc_code_name (code));
      return NULL;
d5756 2
a5757 4
  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;
d5759 4
a5762 2
  return retval;
}
d5764 4
a5767 4
void
score_elf_final_processing (void)
{
  if (fix_data_dependency == 1)
d5769 3
a5771 5
      elf_elfheader (stdoutput)->e_flags |= EF_SCORE_FIXDEP;
    }
  if (score_pic == PIC)
    {
      elf_elfheader (stdoutput)->e_flags |= EF_SCORE_PIC;
d5773 9
d5784 1
d5786 1
a5786 1
parse_pce_inst (char *insnstr)
d5788 2
a5789 5
  char c;
  char *p;
  char first[MAX_LITERAL_POOL_SIZE];
  char second[MAX_LITERAL_POOL_SIZE];
  struct score_it pec_part_1;
d5791 6
a5796 5
  /* Get first part string of PCE.  */
  p = strstr (insnstr, "||");
  c = *p;
  *p = '\0';
  sprintf (first, "%s", insnstr);
d5798 7
a5804 4
  /* Get second part string of PCE.  */
  *p = c;
  p += 2;
  sprintf (second, "%s", p);
d5806 11
a5816 3
  parse_16_32_inst (first, FALSE);
  if (inst.error)
    return;
d5818 3
a5820 9
  memcpy (&pec_part_1, &inst, sizeof (inst));

  parse_16_32_inst (second, FALSE);
  if (inst.error)
    return;

  if (   ((pec_part_1.size == INSN_SIZE) && (inst.size == INSN_SIZE))
      || ((pec_part_1.size == INSN_SIZE) && (inst.size == INSN16_SIZE))
      || ((pec_part_1.size == INSN16_SIZE) && (inst.size == INSN_SIZE)))
d5822 2
a5823 2
      inst.error = _("pce instruction error (16 bit || 16 bit)'");
      sprintf (inst.str, insnstr);
d5826 10
d5837 5
a5841 9
  if (!inst.error)
    gen_insn_frag (&pec_part_1, &inst);
}

void
md_assemble (char *str)
{
  know (str);
  know (strlen (str) < MAX_LITERAL_POOL_SIZE);
a5842 3
  memset (&inst, '\0', sizeof (inst));
  if (INSN_IS_PCE_P (str))
    parse_pce_inst (str);
d5844 18
a5861 1
    parse_16_32_inst (str, TRUE);
d5863 2
a5864 2
  if (inst.error)
    as_bad (_("%s -- `%s'"), inst.error, inst.str);
d5867 3
a5869 4
/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expressionS * expr)
d5871 5
a5875 1
  if (in_my_get_expression)
d5877 3
a5879 5
      expr->X_op = O_illegal;
      if (inst.error == NULL)
        {
          inst.error = _("bad expression");
        }
a5880 1
}
d5882 1
a5882 1
const char *md_shortopts = "nO::g::G:";
d5884 38
a5921 19
#ifdef SCORE_BI_ENDIAN
#define OPTION_EB             (OPTION_MD_BASE + 0)
#define OPTION_EL             (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB             (OPTION_MD_BASE + 0)
#else
#define OPTION_EL             (OPTION_MD_BASE + 1)
#endif
#endif
#define OPTION_FIXDD          (OPTION_MD_BASE + 2)
#define OPTION_NWARN          (OPTION_MD_BASE + 3)
#define OPTION_SCORE5         (OPTION_MD_BASE + 4)
#define OPTION_SCORE5U        (OPTION_MD_BASE + 5)
#define OPTION_SCORE7         (OPTION_MD_BASE + 6)
#define OPTION_R1             (OPTION_MD_BASE + 7)
#define OPTION_O0             (OPTION_MD_BASE + 8)
#define OPTION_SCORE_VERSION  (OPTION_MD_BASE + 9)
#define OPTION_PIC            (OPTION_MD_BASE + 10)
d5923 10
a5932 1
struct option md_longopts[] =
d5934 22
a5955 17
#ifdef OPTION_EB
  {"EB"     , no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL"     , no_argument, NULL, OPTION_EL},
#endif
  {"FIXDD"  , no_argument, NULL, OPTION_FIXDD},
  {"NWARN"  , no_argument, NULL, OPTION_NWARN},
  {"SCORE5" , no_argument, NULL, OPTION_SCORE5},
  {"SCORE5U", no_argument, NULL, OPTION_SCORE5U},
  {"SCORE7" , no_argument, NULL, OPTION_SCORE7},
  {"USE_R1" , no_argument, NULL, OPTION_R1},
  {"O0"     , no_argument, NULL, OPTION_O0},
  {"V"      , no_argument, NULL, OPTION_SCORE_VERSION},
  {"KPIC"   , no_argument, NULL, OPTION_PIC},
  {NULL     , no_argument, NULL, 0}
};
d5957 4
a5960 1
size_t md_longopts_size = sizeof (md_longopts);
d5962 5
a5966 2
int
md_parse_option (int c, char *arg)
d5968 6
a5973 1
  switch (c)
d5975 2
a5976 50
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif
#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif
    case OPTION_FIXDD:
      fix_data_dependency = 1;
      break;
    case OPTION_NWARN:
      warn_fix_data_dependency = 0;
      break;
    case OPTION_SCORE5:
      score7 = 0;
      university_version = 0;
      vector_size = SCORE5_PIPELINE;
      break;
    case OPTION_SCORE5U:
      score7 = 0;
      university_version = 1;
      vector_size = SCORE5_PIPELINE;
      break;
    case OPTION_SCORE7:
      score7 = 1;
      university_version = 0;
      vector_size = SCORE7_PIPELINE;
      break;
    case OPTION_R1:
      nor1 = 0;
      break;
    case 'G':
      g_switch_value = atoi (arg);
      break;
    case OPTION_O0:
      g_opt = 0;
      break;
    case OPTION_SCORE_VERSION:
      printf (_("Sunplus-v2-0-0-20060510\n"));
      break;
    case OPTION_PIC:
      score_pic = PIC;
      g_switch_value = 0;    /* Must set -G num as 0 to generate PIC code.  */
      break;
    default:
      /* as_bad (_("unrecognized option `-%c%s'"), c, arg ? arg : "");  */
      return 0;
a5977 2
  return 1;
}
d5979 5
a5983 8
void
md_show_usage (FILE * fp)
{
  fprintf (fp, _(" Score-specific assembler options:\n"));
#ifdef OPTION_EB
  fprintf (fp, _("\
        -EB\t\tassemble code for a big-endian cpu\n"));
#endif
d5985 1
a5985 4
#ifdef OPTION_EL
  fprintf (fp, _("\
        -EL\t\tassemble code for a little-endian cpu\n"));
#endif
d5987 9
a5995 21
  fprintf (fp, _("\
        -FIXDD\t\tassemble code for fix data dependency\n"));
  fprintf (fp, _("\
        -NWARN\t\tassemble code for no warning message for fix data dependency\n"));
  fprintf (fp, _("\
        -SCORE5\t\tassemble code for target is SCORE5\n"));
  fprintf (fp, _("\
        -SCORE5U\tassemble code for target is SCORE5U\n"));
  fprintf (fp, _("\
        -SCORE7\t\tassemble code for target is SCORE7, this is default setting\n"));
  fprintf (fp, _("\
        -USE_R1\t\tassemble code for no warning message when using temp register r1\n"));
  fprintf (fp, _("\
        -KPIC\t\tassemble code for PIC\n"));
  fprintf (fp, _("\
        -O0\t\tassembler will not perform any optimizations\n"));
  fprintf (fp, _("\
        -G gpnum\tassemble code for setting gpsize and default is 8 byte\n"));
  fprintf (fp, _("\
        -V \t\tSunplus release version \n"));
}
d5997 2
d6000 3
a6002 1
/* Pesudo handling functions.  */
d6004 3
a6006 7
/* If we change section we must dump the literal pool first.  */
static void
s_score_bss (int ignore ATTRIBUTE_UNUSED)
{
  subseg_set (bss_section, (subsegT) get_absolute_expression ());
  demand_empty_rest_of_line ();
}
d6008 3
a6010 6
static void
s_score_text (int ignore)
{
  obj_elf_text (ignore);
  record_alignment (now_seg, 2);
}
d6012 2
a6013 6
static void
score_s_section (int ignore)
{
  obj_elf_section (ignore);
  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    record_alignment (now_seg, 2);
d6015 1
d6018 2
d6021 1
a6021 1
s_change_sec (int sec)
d6023 2
a6024 1
  segT seg;
d6026 8
a6033 10
#ifdef OBJ_ELF
  /* The ELF backend needs to know that we are changing sections, so
     that .previous works correctly.  We could do something like check
     for an obj_section_change_hook macro, but that might be confusing
     as it would not be appropriate to use it in the section changing
     functions in read.c, since obj-elf.c intercepts those.  FIXME:
     This should be cleaner, somehow.  */
  obj_elf_section_change_hook ();
#endif
  switch (sec)
d6035 2
a6036 14
    case 'r':
      seg = subseg_new (RDATA_SECTION_NAME, (subsegT) get_absolute_expression ());
      bfd_set_section_flags (stdoutput, seg, (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_RELOC | SEC_DATA));
      if (strcmp (TARGET_OS, "elf") != 0)
        record_alignment (seg, 4);
      demand_empty_rest_of_line ();
      break;
    case 's':
      seg = subseg_new (".sdata", (subsegT) get_absolute_expression ());
      bfd_set_section_flags (stdoutput, seg, SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);
      if (strcmp (TARGET_OS, "elf") != 0)
        record_alignment (seg, 4);
      demand_empty_rest_of_line ();
      break;
d6038 4
d6044 2
d6047 1
a6047 1
s_score_mask (int reg_type ATTRIBUTE_UNUSED)
d6049 2
a6050 1
  long mask, off;
d6052 2
a6053 1
  if (cur_proc_ptr == (procS *) NULL)
d6055 1
a6055 2
      as_warn (_(".mask outside of .ent"));
      demand_empty_rest_of_line ();
d6058 2
a6059 1
  if (get_absolute_expression_and_terminator (&mask) != ',')
a6060 3
      as_warn (_("Bad .mask directive"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
a6062 3
  off = get_absolute_expression ();
  cur_proc_ptr->reg_mask = mask;
  cur_proc_ptr->reg_offset = off;
d6064 5
d6071 18
a6088 2
static symbolS *
get_symbol (void)
a6089 1
  int c;
d6091 10
a6100 1
  symbolS *p;
d6104 9
a6112 4
  p = (symbolS *) symbol_find_or_make (name);
  *input_line_pointer = c;
  return p;
}
d6114 1
a6114 5
static long
get_number (void)
{
  int negative = 0;
  long val = 0;
d6116 3
a6118 1
  if (*input_line_pointer == '-')
d6121 29
a6149 1
      negative = 1;
d6151 4
a6154 3
  if (!ISDIGIT (*input_line_pointer))
    as_bad (_("expected simple number"));
  if (input_line_pointer[0] == '0')
d6156 4
a6159 1
      if (input_line_pointer[1] == 'x')
d6161 2
a6162 7
          input_line_pointer += 2;
          while (ISXDIGIT (*input_line_pointer))
            {
              val <<= 4;
              val |= hex_value (*input_line_pointer++);
            }
          return negative ? -val : val;
d6166 2
a6167 7
          ++input_line_pointer;
          while (ISDIGIT (*input_line_pointer))
            {
              val <<= 3;
              val |= *input_line_pointer++ - '0';
            }
          return negative ? -val : val;
d6170 2
a6171 1
  if (!ISDIGIT (*input_line_pointer))
d6173 5
a6177 3
      printf (_(" *input_line_pointer == '%c' 0x%02x\n"), *input_line_pointer, *input_line_pointer);
      as_warn (_("invalid number"));
      return -1;
d6179 2
a6180 1
  while (ISDIGIT (*input_line_pointer))
d6182 12
a6193 5
      val *= 10;
      val += *input_line_pointer++ - '0';
    }
  return negative ? -val : val;
}
d6195 10
a6204 1
/* The .aent and .ent directives.  */
d6206 14
a6219 5
static void
s_score_ent (int aent)
{
  symbolS *symbolP;
  int maybe_text;
d6221 3
a6223 6
  symbolP = get_symbol ();
  if (*input_line_pointer == ',')
    ++input_line_pointer;
  SKIP_WHITESPACE ();
  if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')
    get_number ();
d6225 3
d6229 2
a6230 4
  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    maybe_text = 1;
  else
    maybe_text = 0;
d6232 2
a6233 4
  if (now_seg != data_section && now_seg != bss_section)
    maybe_text = 1;
  else
    maybe_text = 0;
d6235 1
a6235 5
  if (!maybe_text)
    as_warn (_(".ent or .aent not in text section."));
  if (!aent && cur_proc_ptr)
    as_warn (_("missing .end"));
  if (!aent)
d6237 31
a6267 13
      cur_proc_ptr = &cur_proc;
      cur_proc_ptr->reg_mask = 0xdeadbeaf;
      cur_proc_ptr->reg_offset = 0xdeadbeaf;
      cur_proc_ptr->fpreg_mask = 0xdeafbeaf;
      cur_proc_ptr->leaf = 0xdeafbeaf;
      cur_proc_ptr->frame_offset = 0xdeafbeaf;
      cur_proc_ptr->frame_reg = 0xdeafbeaf;
      cur_proc_ptr->pc_reg = 0xdeafbeaf;
      cur_proc_ptr->isym = symbolP;
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
      ++numprocs;
      if (debug_type == DEBUG_STABS)
        stabs_generate_asm_func (S_GET_NAME (symbolP), S_GET_NAME (symbolP));
d6269 5
d6278 1
a6278 1
s_score_frame (int ignore ATTRIBUTE_UNUSED)
a6279 3
  char *backupstr;
  char str[30];
  long val;
d6281 14
d6296 4
a6299 1
  backupstr = input_line_pointer;
d6301 1
a6301 2
#ifdef OBJ_ELF
  if (cur_proc_ptr == (procS *) NULL)
d6303 1
a6303 3
      as_warn (_(".frame outside of .ent"));
      demand_empty_rest_of_line ();
      return;
d6305 1
a6305 4
  cur_proc_ptr->frame_reg = reg_required_here ((&backupstr), 0, REG_TYPE_SCORE);
  SKIP_WHITESPACE ();
  skip_past_comma (&backupstr);
  while (*backupstr != ',')
d6307 1
a6307 3
      str[i] = *backupstr;
      i++;
      backupstr++;
d6309 1
a6309 2
  str[i] = '\0';
  val = atoi (str);
d6311 6
a6316 4
  SKIP_WHITESPACE ();
  skip_past_comma (&backupstr);
  cur_proc_ptr->frame_offset = val;
  cur_proc_ptr->pc_reg = reg_required_here ((&backupstr), 0, REG_TYPE_SCORE);
d6318 2
a6319 4
  SKIP_WHITESPACE ();
  skip_past_comma (&backupstr);
  i = 0;
  while (*backupstr != '\n')
d6321 15
a6335 3
      str[i] = *backupstr;
      i++;
      backupstr++;
a6336 9
  str[i] = '\0';
  val = atoi (str);
  cur_proc_ptr->leaf = val;
  SKIP_WHITESPACE ();
  skip_past_comma (&backupstr);

#endif /* OBJ_ELF */
  while (input_line_pointer != backupstr)
    input_line_pointer++;
a6338 1
/* The .end directive.  */
d6340 1
a6340 1
s_score_end (int x ATTRIBUTE_UNUSED)
d6342 9
a6350 2
  symbolS *p;
  int maybe_text;
d6352 2
a6353 6
  /* Generate a .pdr section.  */
  segT saved_seg = now_seg;
  subsegT saved_subseg = now_subseg;
  valueT dot;
  expressionS exp;
  char *fragp;
d6355 3
a6357 4
  if (!is_end_of_line[(unsigned char)*input_line_pointer])
    {
      p = get_symbol ();
      demand_empty_rest_of_line ();
d6359 16
d6376 2
a6377 1
    p = NULL;
d6379 5
a6383 3
#ifdef BFD_ASSEMBLER
  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    maybe_text = 1;
d6385 8
a6392 4
    maybe_text = 0;
#else
  if (now_seg != data_section && now_seg != bss_section)
    maybe_text = 1;
d6394 2
a6395 2
    maybe_text = 0;
#endif
d6397 5
a6401 16
  if (!maybe_text)
    as_warn (_(".end not in text section"));
  if (!cur_proc_ptr)
    {
      as_warn (_(".end directive without a preceding .ent directive."));
      demand_empty_rest_of_line ();
      return;
    }
  if (p != NULL)
    {
      assert (S_GET_NAME (p));
      if (strcmp (S_GET_NAME (p), S_GET_NAME (cur_proc_ptr->isym)))
        as_warn (_(".end symbol does not match .ent symbol."));
      if (debug_type == DEBUG_STABS)
        stabs_generate_asm_endfunc (S_GET_NAME (p), S_GET_NAME (p));
    }
d6403 2
a6404 1
    as_warn (_(".end directive missing or unknown symbol"));
d6406 8
a6413 5
  if ((cur_proc_ptr->reg_mask == 0xdeadbeaf) ||
      (cur_proc_ptr->reg_offset == 0xdeadbeaf) ||
      (cur_proc_ptr->leaf == 0xdeafbeaf) ||
      (cur_proc_ptr->frame_offset == 0xdeafbeaf) ||
      (cur_proc_ptr->frame_reg == 0xdeafbeaf) || (cur_proc_ptr->pc_reg == 0xdeafbeaf));
d6415 5
d6421 2
a6422 18
    {
      dot = frag_now_fix ();
      assert (pdr_seg);
      subseg_set (pdr_seg, 0);
      /* Write the symbol.  */
      exp.X_op = O_symbol;
      exp.X_add_symbol = p;
      exp.X_add_number = 0;
      emit_expr (&exp, 4);
      fragp = frag_more (7 * 4);
      md_number_to_chars (fragp, (valueT) cur_proc_ptr->reg_mask, 4);
      md_number_to_chars (fragp + 4, (valueT) cur_proc_ptr->reg_offset, 4);
      md_number_to_chars (fragp + 8, (valueT) cur_proc_ptr->fpreg_mask, 4);
      md_number_to_chars (fragp + 12, (valueT) cur_proc_ptr->leaf, 4);
      md_number_to_chars (fragp + 16, (valueT) cur_proc_ptr->frame_offset, 4);
      md_number_to_chars (fragp + 20, (valueT) cur_proc_ptr->frame_reg, 4);
      md_number_to_chars (fragp + 24, (valueT) cur_proc_ptr->pc_reg, 4);
      subseg_set (saved_seg, saved_subseg);
d6424 7
a6430 2
    }
  cur_proc_ptr = NULL;
a6432 1
/* Handle the .set pseudo-op.  */
d6436 5
a6440 3
  int i = 0;
  char name[MAX_LITERAL_POOL_SIZE];
  char * orig_ilp = input_line_pointer;
d6442 5
a6446 41
  while (!is_end_of_line[(unsigned char)*input_line_pointer])
    {
      name[i] = (char) * input_line_pointer;
      i++;
      ++input_line_pointer;
    }

  name[i] = '\0';

  if (strcmp (name, "nwarn") == 0)
    {
      warn_fix_data_dependency = 0;
    }
  else if (strcmp (name, "fixdd") == 0)
    {
      fix_data_dependency = 1;
    }
  else if (strcmp (name, "nofixdd") == 0)
    {
      fix_data_dependency = 0;
    }
  else if (strcmp (name, "r1") == 0)
    {
      nor1 = 0;
    }
  else if (strcmp (name, "nor1") == 0)
    {
      nor1 = 1;
    }
  else if (strcmp (name, "optimize") == 0)
    {
      g_opt = 1;
    }
  else if (strcmp (name, "volatile") == 0)
    {
      g_opt = 0;
    }
  else if (strcmp (name, "pic") == 0)
    {
      score_pic = PIC;
    }
d6448 1
a6448 4
    {
      input_line_pointer = orig_ilp;
      s_set (0);
    }
d6451 8
a6458 8
/* Handle the .cpload pseudo-op.  This is used when generating PIC code.  It sets the
   $gp register for the function based on the function address, which is in the register
   named in the argument. This uses a relocation against GP_DISP_LABEL, which is handled
   specially by the linker.  The result is:
   ldis gp, %hi(GP_DISP_LABEL)
   ori  gp, %low(GP_DISP_LABEL)
   add  gp, gp, .cpload argument
   The .cpload argument is normally r29.  */
d6461 1
a6461 1
s_score_cpload (int ignore ATTRIBUTE_UNUSED)
d6463 5
a6467 2
  int reg;
  char insn_str[MAX_LITERAL_POOL_SIZE];
d6469 8
a6476 6
  /* If we are not generating PIC code, .cpload is ignored.  */
  if (score_pic == NO_PIC)
    {
      s_ignore (0);
      return;
    }
d6478 8
a6485 2
  if ((reg = reg_required_here (&input_line_pointer, -1, REG_TYPE_SCORE)) == (int) FAIL)
    return;
d6487 5
a6491 1
  demand_empty_rest_of_line ();
d6493 7
a6499 3
  sprintf (insn_str, "ld_i32hi r%d, %s", GP, GP_DISP_LABEL);
  if (append_insn (insn_str, TRUE) == (int) FAIL)
    return;
d6501 2
a6502 7
  sprintf (insn_str, "ld_i32lo r%d, %s", GP, GP_DISP_LABEL);
  if (append_insn (insn_str, TRUE) == (int) FAIL)
    return;

  sprintf (insn_str, "add r%d, r%d, r%d", GP, GP, reg);
  if (append_insn (insn_str, TRUE) == (int) FAIL)
    return;
a6504 4
/* Handle the .cprestore pseudo-op.  This stores $gp into a given
   offset from $sp.  The offset is remembered, and after making a PIC
   call $gp is restored from that location.  */

d6506 1
a6506 1
s_score_cprestore (int ignore ATTRIBUTE_UNUSED)
d6508 1
a6508 6
  int reg;
  int cprestore_offset;
  char insn_str[MAX_LITERAL_POOL_SIZE];

  /* If we are not generating PIC code, .cprestore is ignored.  */
  if (score_pic == NO_PIC)
d6510 5
a6514 2
      s_ignore (0);
      return;
d6516 1
d6518 6
a6523 5
  if ((reg = reg_required_here (&input_line_pointer, -1, REG_TYPE_SCORE)) == (int) FAIL
      || skip_past_comma (&input_line_pointer) == (int) FAIL)
    {
      return;
    }
d6525 2
a6526 1
  cprestore_offset = get_absolute_expression ();
d6528 1
a6528 9
  if (cprestore_offset <= 0x3fff)
    {
      sprintf (insn_str, "sw r%d, [r%d, %d]", GP, reg, cprestore_offset);
      if (append_insn (insn_str, TRUE) == (int) FAIL)
        return;
    }
  else
    {
      int r1_bak;
d6530 2
a6531 2
      r1_bak = nor1;
      nor1 = 0;
d6533 1
a6533 3
      sprintf (insn_str, "li r1, %d", cprestore_offset);
      if (append_insn (insn_str, TRUE) == (int) FAIL)
        return;
d6535 2
a6536 3
      sprintf (insn_str, "add r1, r1, r%d", reg);
      if (append_insn (insn_str, TRUE) == (int) FAIL)
        return;
d6538 2
a6539 3
      sprintf (insn_str, "sw r%d, [r1]", GP);
      if (append_insn (insn_str, TRUE) == (int) FAIL)
        return;
d6541 7
a6547 2
      nor1 = r1_bak;
    }
d6549 2
a6550 1
  demand_empty_rest_of_line ();
a6552 2
/* Handle the .gpword pseudo-op.  This is used when generating PIC
   code.  It generates a 32 bit GP relative reloc.  */
d6554 1
a6554 1
s_score_gpword (int ignore ATTRIBUTE_UNUSED)
d6556 11
a6566 2
  expressionS ex;
  char *p;
d6568 1
a6568 2
  /* When not generating PIC code, this is treated as .word.  */
  if (score_pic == NO_PIC)
d6570 5
a6574 2
      cons (4);
      return;
d6576 1
a6576 2
  expression (&ex);
  if (ex.X_op != O_symbol || ex.X_add_number != 0)
d6578 5
a6582 2
      as_bad (_("Unsupported use of .gpword"));
      ignore_rest_of_line ();
d6584 2
a6585 4
  p = frag_more (4);
  md_number_to_chars (p, (valueT) 0, 4);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, FALSE, BFD_RELOC_GPREL32);
  demand_empty_rest_of_line ();
a6587 3
/* Handle the .cpadd pseudo-op.  This is used when dealing with switch
   tables in PIC code.  */

d6589 1
a6589 1
s_score_cpadd (int ignore ATTRIBUTE_UNUSED)
d6591 1
a6591 2
  int reg;
  char insn_str[MAX_LITERAL_POOL_SIZE];
d6593 1
a6593 2
  /* If we are not generating PIC code, .cpload is ignored.  */
  if (score_pic == NO_PIC)
d6595 13
a6607 2
      s_ignore (0);
      return;
d6609 7
d6617 1
a6617 1
  if ((reg = reg_required_here (&input_line_pointer, -1, REG_TYPE_SCORE)) == (int) FAIL)
d6619 13
a6631 1
      return;
a6632 1
  demand_empty_rest_of_line ();
d6634 1
a6634 4
  /* Add $gp to the register named as an argument.  */
  sprintf (insn_str, "add r%d, r%d, r%d", reg, reg, GP);
  if (append_insn (insn_str, TRUE) == (int) FAIL)
    return;
a6636 16
#ifndef TC_IMPLICIT_LCOMM_ALIGNMENT
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)        	\
    do								\
    {                                                   	\
    if ((SIZE) >= 8)                                      	\
    (P2VAR) = 3;                                        	\
    else if ((SIZE) >= 4)                                 	\
    (P2VAR) = 2;                                        	\
    else if ((SIZE) >= 2)                                 	\
    (P2VAR) = 1;                                        	\
    else                                                  	\
    (P2VAR) = 0;                                        	\
    }								\
  while (0)
#endif

d6638 1
a6638 1
s_score_lcomm (int bytes_p)
d6640 5
a6644 11
  char *name;
  char c;
  char *p;
  int temp;
  symbolS *symbolP;
  segT current_seg = now_seg;
  subsegT current_subseg = now_subseg;
  const int max_alignment = 15;
  int align = 0;
  segT bss_seg = bss_section;
  int needs_align = 0;
d6646 4
a6649 4
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;
d6651 4
a6654 6
  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }
d6656 2
a6657 1
  SKIP_WHITESPACE ();
d6659 7
a6665 7
  /* Accept an optional comma after the name.  The comma used to be
     required, but Irix 5 cc does not generate it.  */
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
    }
d6667 1
a6667 1
  if (is_end_of_line[(unsigned char)*input_line_pointer])
d6669 21
a6689 2
      as_bad (_("missing size expression"));
      return;
d6692 4
a6695 6
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_("BSS length (%d) < 0 ignored"), temp);
      ignore_rest_of_line ();
      return;
    }
d6697 1
a6697 2
#if defined (TC_SCORE)
  if (OUTPUT_FLAVOR == bfd_target_ecoff_flavour || OUTPUT_FLAVOR == bfd_target_elf_flavour)
d6699 1
a6699 2
      /* For Score and Alpha ECOFF or ELF, small objects are put in .sbss.  */
      if ((unsigned)temp <= bfd_get_gp_size (stdoutput))
d6701 2
a6702 6
          bss_seg = subseg_new (".sbss", 1);
          seg_info (bss_seg)->bss = 1;
#ifdef BFD_ASSEMBLER
          if (!bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
            as_warn (_("error setting flags for \".sbss\": %s"), bfd_errmsg (bfd_get_error ()));
#endif
d6705 1
a6705 4
#endif

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
d6707 1
a6707 9
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (is_end_of_line[(unsigned char)*input_line_pointer])
        {
          as_bad (_("missing alignment"));
          return;
        }
      else
d6709 3
a6711 2
          align = get_absolute_expression ();
          needs_align = 1;
d6715 2
a6716 3
  if (!needs_align)
    {
      TC_IMPLICIT_LCOMM_ALIGNMENT (temp, align);
d6718 5
a6722 4
      /* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
      if (align)
        record_alignment (bss_seg, align);
    }
d6724 5
a6728 8
  if (needs_align)
    {
      if (bytes_p)
        {
          /* Convert to a power of 2.  */
          if (align != 0)
            {
              unsigned int i;
d6730 4
a6733 5
              for (i = 0; align != 0; align >>= 1, ++i)
                ;
              align = i - 1;
            }
        }
d6735 12
a6746 10
      if (align > max_alignment)
        {
          align = max_alignment;
          as_warn (_("alignment too large; %d assumed"), align);
        }
      else if (align < 0)
        {
          align = 0;
          as_warn (_("alignment negative; 0 assumed"));
        }
d6748 6
a6753 1
      record_alignment (bss_seg, align);
d6755 2
a6756 1
  else
d6758 1
a6758 9
      /* Assume some objects may require alignment on some systems.  */
#if defined (TC_ALPHA) && ! defined (VMS)
      if (temp > 1)
        {
          align = ffs (temp) - 1;
          if (temp % (1 << align))
            abort ();
        }
#endif
d6760 4
a6763 16

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT) \
     || defined (OBJ_BOUT) || defined (OBJ_MAYBE_BOUT))
#ifdef BFD_ASSEMBLER
       (OUTPUT_FLAVOR != bfd_target_aout_flavour
        || (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0)) &&
#else
       (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0) &&
#endif
#endif
       (S_GET_SEGMENT (symbolP) == bss_seg || (!S_IS_DEFINED (symbolP) && S_GET_VALUE (symbolP) == 0)))
d6765 2
a6766 1
      char *pfrag;
d6768 2
a6769 1
      subseg_set (bss_seg, 1);
d6771 4
a6774 2
      if (align)
        frag_align (align, 0, 0);
d6776 4
a6779 3
      /* Detach from old frag.  */
      if (S_GET_SEGMENT (symbolP) == bss_seg)
        symbol_get_frag (symbolP)->fr_symbol = NULL;
d6781 3
a6783 3
      symbol_set_frag (symbolP, frag_now);
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, (offsetT) temp, NULL);
      *pfrag = 0;
d6785 9
d6795 54
a6848 1
      S_SET_SEGMENT (symbolP, bss_seg);
d6850 8
a6857 9
#ifdef OBJ_COFF
      /* The symbol may already have been created with a preceding
         ".globl" directive -- be careful not to step on storage class
         in that case.  Otherwise, set it to static.  */
      if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
        {
          S_SET_STORAGE_CLASS (symbolP, C_STAT);
        }
#endif /* OBJ_COFF */
d6859 19
a6877 3
#ifdef S_SET_SIZE
      S_SET_SIZE (symbolP, temp);
#endif
d6880 16
a6895 1
    as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));
d6897 8
a6904 1
  subseg_set (current_seg, current_subseg);
d6906 40
a6945 1
  demand_empty_rest_of_line ();
d6948 3
a6950 2
static void
insert_reg (const struct reg_entry *r, struct hash_control *htab)
d6952 1
a6952 4
  int i = 0;
  int len = strlen (r->name) + 2;
  char *buf = xmalloc (len);
  char *buf2 = xmalloc (len);
d6954 2
a6955 2
  strcpy (buf + i, r->name);
  for (i = 0; buf[i]; i++)
d6957 3
a6959 1
      buf2[i] = TOUPPER (buf[i]);
d6961 3
a6963 1
  buf2[i] = '\0';
d6965 6
a6970 2
  hash_insert (htab, buf, (void *) r);
  hash_insert (htab, buf2, (void *) r);
d6973 2
a6974 2
static void
build_reg_hsh (struct reg_map *map)
d6976 13
a6988 1
  const struct reg_entry *r;
d6990 1
a6990 1
  if ((map->htab = hash_new ()) == NULL)
d6992 20
a7011 1
      as_fatal (_("virtual memory exhausted"));
d7013 3
a7015 1
  for (r = map->names; r->name != NULL; r++)
d7017 1
a7017 1
      insert_reg (r, map->htab);
d7019 2
d7023 2
a7024 2
void
md_begin (void)
d7026 4
a7029 3
  unsigned int i;
  segT seg;
  subsegT subseg;
d7031 2
a7032 2
  if ((score_ops_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));
d7034 11
a7044 1
  build_score_ops_hsh ();
d7046 15
a7060 2
  if ((dependency_insn_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));
d7062 7
a7068 1
  build_dependency_insn_hsh ();
d7070 4
a7073 2
  for (i = (int)REG_TYPE_FIRST; i < (int)REG_TYPE_MAX; i++)
    build_reg_hsh (all_reg_maps + i);
d7075 10
a7084 2
  /* Initialize dependency vector.  */
  init_dependency_vector ();
d7086 2
a7087 7
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, 0);
  seg = now_seg;
  subseg = now_subseg;
  pdr_seg = subseg_new (".pdr", (subsegT) 0);
  (void)bfd_set_section_flags (stdoutput, pdr_seg, SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);
  (void)bfd_set_section_alignment (stdoutput, pdr_seg, 2);
  subseg_set (seg, subseg);
d7089 5
a7093 2
  if (USE_GLOBAL_POINTER_OPT)
    bfd_set_gp_size (stdoutput, g_switch_value);
d7096 27
d7124 2
a7125 25
const pseudo_typeS md_pseudo_table[] =
{
  {"bss", s_score_bss, 0},
  {"text", s_score_text, 0},
  {"word", cons, 4},
  {"long", cons, 4},
  {"extend", float_cons, 'x'},
  {"ldouble", float_cons, 'x'},
  {"packed", float_cons, 'p'},
  {"end", s_score_end, 0},
  {"ent", s_score_ent, 0},
  {"frame", s_score_frame, 0},
  {"rdata", s_change_sec, 'r'},
  {"sdata", s_change_sec, 's'},
  {"set", s_score_set, 0},
  {"mask", s_score_mask, 'R'},
  {"dword", cons, 8},
  {"lcomm", s_score_lcomm, 1},
  {"section", score_s_section, 0},
  {"cpload", s_score_cpload, 0},
  {"cprestore", s_score_cprestore, 0},
  {"gpword", s_score_gpword, 0},
  {"cpadd", s_score_cpadd, 0},
  {0, 0, 0}
};
d7127 716
@


1.11
log
@Switch to GPLv3
@
text
@a183 5
/* Number of littlenums required to hold an extended precision number.  For md_atof.  */
#define NUM_FLOAT_VALS 8
#define MAX_LITTLENUMS 6
LITTLENUM_TYPE fp_values[NUM_FLOAT_VALS][MAX_LITTLENUMS];

a4701 12
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.

   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.  However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.  */

d4705 1
a4705 54
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;
    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;
    case 'x':
    case 'X':
    case 'p':
    case 'P':
      prec = 6;
      break;
    default:
      *sizeP = 0;
      return _("bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * 2;

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
        {
          md_number_to_chars (litP, (valueT) words[i], 2);
          litP += 2;
        }
    }
  else
    {
      for (i = 0; i < prec; i += 2)
        {
          md_number_to_chars (litP, (valueT) words[i + 1], 2);
          md_number_to_chars (litP + 2, (valueT) words[i], 2);
          litP += 4;
        }
    }

  return 0;
@


1.10
log
@2007-05-14  Mei Ligang  <ligang@@sunnorth.com.cn>

	* config/tc-score.c (data_op2, validate_immediate): Fix bug for addri, addri.c, subi, and
	subi.c when immediate number is hex.
	(score_insns): Remove subis and subis.c.
	(do_sub_rdi16): Delete.
@
text
@d2 1
a2 1
   Copyright 2006 Free Software Foundation, Inc.
d11 1
a11 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.9
log
@* tc-score.c: Remove unnecessary uses of _().
  Make the err_msg[] a file level local array in order to save storage space.
  Remove unnecessary sprintf()s.
@
text
@a283 1
static void do_sub_rdi16 (char *);
a366 2
  {"subis",     0x0a000000, 0x3e0e0001, 0x8000,     Rd_SI16,              do_sub_rdi16},
  {"subis.c",   0x0a000001, 0x3e0e0001, 0x8000,     Rd_SI16,              do_sub_rdi16},
d796 1
d1015 1
a1015 1
validate_immediate (int val, unsigned int data_type)
d1043 39
d1083 1
a1083 1
      if (data_type == _SIMM14_NEG || data_type == _SIMM16_NEG || data_type == _IMM16_NEG)
d1109 3
d1147 24
a1170 17
      if ((*dataptr == '0') && (*(dataptr + 1) == 'x')
          && (data_type != _SIMM16_LA)
          && (data_type != _VALUE_HI16)
          && (data_type != _VALUE_LO16)
          && (data_type != _IMM16)
          && (data_type != _IMM15)
          && (data_type != _IMM14)
          && (data_type != _IMM4)
          && (data_type != _IMM5)
          && (data_type != _IMM8)
          && (data_type != _IMM5_RSHIFT_1)
          && (data_type != _IMM5_RSHIFT_2)
          && (data_type != _SIMM14_NEG)
          && (data_type != _IMM10_RSHIFT_2)
          && (data_type != _GP_IMM15))
        {
          data_type += 24;
d1244 1
a1244 1
          value = validate_immediate (inst.reloc.exp.X_add_number, _SIMM16_LA_POS);
d1255 1
a1255 1
          value = validate_immediate (inst.reloc.exp.X_add_number, data_type);
a1363 13
/* Handle subis/subis.c.  */

static void
do_sub_rdi16 (char *str)
{
  skip_whitespace (str);

  if (reg_required_here (&str, 20, REG_TYPE_SCORE) != (int) FAIL
      && skip_past_comma (&str) != (int) FAIL
      && data_op2 (&str, 1, _IMM16_NEG) != (int) FAIL)
    end_of_line (str);
}

d2640 1
a2640 1
      value = validate_immediate (inst.reloc.exp.X_add_number, data_type);
d2783 1
a2783 1
                  value = validate_immediate (inst.reloc.exp.X_add_number, _SIMM12);
d2923 1
a2923 1
              value = validate_immediate (inst.reloc.exp.X_add_number, data_type);
d4287 1
a4287 1
      || (validate_immediate (inst.reloc.exp.X_add_number, _VALUE) == (int) FAIL)
@


1.8
log
@
2007-01-18  Mei Ligang  <ligang@@sunnorth.com.cn>

	* config/tc-score.c : Using _() for const string.
	Do not assign inst.error with a local string pointer.
	(md_section_align): Pad section.
@
text
@d106 3
a1212 2
          static char err_msg[100];

d1228 1
a1228 1
          inst.error = _(err_msg);
d1263 1
a1263 4
          static char err_msg[100];

          sprintf (err_msg, _("invalid constant: bit expression not defined"));
          inst.error = _(err_msg);
d2439 1
a2439 1
              sprintf (append_str, _("mlfh! %s"), backupstr);
d2458 1
a2458 1
              sprintf (append_str, _("mhfl! %s"), backupstr);
a2608 2
          static char err_msg[255];

d2619 1
a2619 1
          inst.error = _(err_msg);
a2891 2
                  static char err_msg[255];

d2903 1
a2903 1
                  inst.error = _(err_msg);
d3170 1
a3170 1
      sprintf (inst.name, _("cache %d"), cache_op);
d3750 1
a3750 1
      sprintf (tmp, _("lw_pic r%d, %s"), reg_rd, add_symbol->bsym->name);
d3764 1
a3764 1
      sprintf (tmp, _("addi_s_pic r%d, %s"), reg_rd, add_symbol->bsym->name);
d3774 1
a3774 1
      sprintf (tmp, _("lw_pic r%d, %s"), reg_rd, add_symbol->bsym->name);
d3783 1
a3783 1
      sprintf (tmp, _("addi r%d, %d"), reg_rd, (int)add_number);
d3791 1
a3791 1
      sprintf (tmp, _("addi_s_pic r%d, %s + %d"), reg_rd, add_symbol->bsym->name, (int)add_number);
d3804 1
a3804 1
      sprintf (tmp, _("lw_pic r%d, %s"), reg_rd, add_symbol->bsym->name);
d3813 1
a3813 1
      sprintf (tmp, _("ldis %s, %d"), _("r1"), hi);
d3826 1
a3826 1
      sprintf (tmp, _("ldis_pic %s, %d"), _("r1"), hi);
d3838 1
a3838 1
      sprintf (tmp, _("ori %s, %d"), _("r1"), lo);
d3846 1
a3846 1
      sprintf (tmp, _("addi_u_pic %s, %s + %d"), _("r1"), add_symbol->bsym->name, lo);
d3854 1
a3854 1
      sprintf (tmp, _("add r%d, r%d, %s"), reg_rd, reg_rd, _("r1"));
d3902 1
a3902 1
                  sprintf (append_str, _("ld_i32hi r%d, %s"), reg_rd, keep_data);
d3906 1
a3906 1
                  sprintf (append_str, _("ld_i32lo r%d, %s"), reg_rd, keep_data);
d3964 1
a3964 1
              sprintf (append_str, _("ld_i32hi r%d, %s"), reg_rd, keep_data);
d3970 1
a3970 1
                  sprintf (append_str, _("ld_i32lo r%d, %s"), reg_rd, keep_data);
d4034 2
a4035 2
              sprintf (append_str, _("%s r%d, r%d"), _("mul"), reg_rs1, reg_rs2);
              sprintf (append_str1, _("mfceh  r%d"), reg_rd);
d4039 2
a4040 2
              sprintf (append_str, _("%s r%d, r%d"), _("mulu"), reg_rs1, reg_rs2);
              sprintf (append_str1, _("mfceh  r%d"), reg_rd);
d4044 2
a4045 2
              sprintf (append_str, _("%s r%d, r%d"), inst.name, reg_rs1, reg_rs2);
              sprintf (append_str1, _("mfcel  r%d"), reg_rd);
d4087 1
a4087 1
  sprintf (append_str, _("li r1  %s"), backupstr);
d4091 1
a4091 1
  sprintf (append_str, _(" r%d, [r1,0]"), reg_rd);
d4176 1
a4176 1
      sprintf (tmp, _("lw_pic %s, %s"), _("r1"), add_symbol->bsym->name);
d4188 1
a4188 1
      sprintf (tmp, _("addi_s_pic %s, %s"), _("r1"), add_symbol->bsym->name);
d4196 1
a4196 1
      sprintf (tmp, _("%s r%d, [%s, %d]"), insn_name, reg_rd, _("r1"), add_number);
d4320 3
a4322 3
  sprintf (append_str[0], _("ld_i32hi r1, %s"), label_str);
  sprintf (append_str[1], _("ld_i32lo r1, %s"), label_str);
  sprintf (append_str[2], _("%s r%d, [r1, 0]"), inst_backup.name, reg_rd);
a4463 1
  static char err_msg[100];
d4479 1
a4479 2
      sprintf (err_msg, _("invalid constant: 25 bit expression not in range -2^24..2^24"));
      inst.error = _(err_msg);
d5607 1
a5607 1
      sprintf (inst.str, "%s", insnstr);
d6202 1
a6202 1
  sprintf (insn_str, _("ld_i32hi r%d, %s"), GP, GP_DISP_LABEL);
d6206 1
a6206 1
  sprintf (insn_str, _("ld_i32lo r%d, %s"), GP, GP_DISP_LABEL);
d6210 1
a6210 1
  sprintf (insn_str, _("add r%d, r%d, r%d"), GP, GP, reg);
d6243 1
a6243 1
      sprintf (insn_str, _("sw r%d, [r%d, %d]"), GP, reg, cprestore_offset);
d6254 1
a6254 1
      sprintf (insn_str, _("li r1, %d"), cprestore_offset);
d6258 1
a6258 1
      sprintf (insn_str, _("add r1, r1, r%d"), reg);
d6262 1
a6262 1
      sprintf (insn_str, _("sw r%d, [r1]"), GP);
d6321 1
a6321 1
  sprintf (insn_str, _("add r%d, r%d, r%d"), reg, reg, GP);
@


1.7
log
@	* config/tc-score.c (build_lw_pic): Rename as build_lwst_pic.
	Delete the code handling large constant for PIC.
	Modify some comments.
	(score_relax_frag): Decrease insn_addr in certain situation.
	(s_score_cprestore): Change .cprestore syntax from ".cprestore offset"
	to ".cprestore reg, offset".
@
text
@d538 1
a538 1
  {"ldis",      0x0a0c0000, 0x3e0e0000, 0x5000,     Rd_I16,               do_rdi16},
d857 1
a857 1
              as_warn ("Using temp register(r1)");
d1210 1
a1210 1
          char err_msg[100];
d1215 1
a1215 1
                       "invalid constant: %d bit expression not in range %d..%d",
d1222 1
a1222 1
                       "invalid constant: %d bit expression not in range %d..%d",
d1262 1
a1262 1
          char err_msg[100];
d1264 1
a1264 1
          sprintf (err_msg, "invalid constant: bit expression not defined");
d1420 1
a1420 1
/* Handle andi/ori/andis/oris/ldis.  */
d1431 1
a1431 1

d1436 1
d1726 1
a1726 1
          as_warn ("Using temp register(r1)");
d2067 1
a2067 1
		    as_warn ("Fix data dependency: %s %s -- %s %s  (insert %d nop!/%d)",
d2086 1
a2086 1
		    as_warn ("Fix data dependency: %s %s -- %s %s  (insert 1 pflush/%d)",
d2102 1
a2102 1
                  as_bad ("data dependency: %s %s -- %s %s  (%d/%d bubble)",
d2109 1
a2109 1
                  as_warn ("data dependency: %s %s -- %s %s  (%d/%d bubble)",
d2399 1
a2399 1
      as_bad ("%s -- `%s'", inst.error, inst.str);
d2441 1
a2441 1
              sprintf (append_str, "mlfh! %s", backupstr);
d2460 1
a2460 1
              sprintf (append_str, "mhfl! %s", backupstr);
d2611 1
a2611 1
          char err_msg[255];
d2615 1
a2615 1
                     "invalid constant: %d bit expression not in range %d..%d",
d2620 1
a2620 1
                     "invalid constant: %d bit expression not in range %d..%d",
d2896 1
a2896 1
                  char err_msg[255];
d2900 1
a2900 1
                             "invalid constant: %d bit expression not in range %d..%d",
d2905 1
a2905 1
                             "invalid constant: %d bit expression not in range %d..%d",
d3176 1
a3176 1
      sprintf (inst.name, "cache %d", cache_op);
d3756 1
a3756 1
      sprintf (tmp, "lw_pic r%d, %s", reg_rd, add_symbol->bsym->name);
d3770 1
a3770 1
      sprintf (tmp, "addi_s_pic r%d, %s", reg_rd, add_symbol->bsym->name);
d3780 1
a3780 1
      sprintf (tmp, "lw_pic r%d, %s", reg_rd, add_symbol->bsym->name);
d3789 1
a3789 1
      sprintf (tmp, "addi r%d, %d", reg_rd, (int)add_number);
d3797 1
a3797 1
      sprintf (tmp, "addi_s_pic r%d, %s + %d", reg_rd, add_symbol->bsym->name, (int)add_number);
d3810 1
a3810 1
      sprintf (tmp, "lw_pic r%d, %s", reg_rd, add_symbol->bsym->name);
d3819 1
a3819 1
      sprintf (tmp, "ldis %s, %d", "r1", hi);
d3832 1
a3832 1
      sprintf (tmp, "ldis_pic %s, %d", "r1", hi);
d3844 1
a3844 1
      sprintf (tmp, "ori %s, %d", "r1", lo);
d3852 1
a3852 1
      sprintf (tmp, "addi_u_pic %s, %s + %d", "r1", add_symbol->bsym->name, lo);
d3860 1
a3860 1
      sprintf (tmp, "add r%d, r%d, %s", reg_rd, reg_rd, "r1");
d3907 3
a3909 3
		{
                  sprintf (append_str, "ld_i32hi r%d, %s", reg_rd, keep_data);
	          if (append_insn (append_str, TRUE) == (int) FAIL)
d3912 2
a3913 2
	          sprintf (append_str, "ld_i32lo r%d, %s", reg_rd, keep_data);
	          if (append_insn (append_str, TRUE) == (int) FAIL)
d3970 1
a3970 1
              sprintf (append_str, "ld_i32hi r%d, %s", reg_rd, keep_data);
d3976 1
a3976 1
                  sprintf (append_str, "ld_i32lo r%d, %s", reg_rd, keep_data);
d4040 2
a4041 2
              sprintf (append_str, "%s r%d, r%d", "mul", reg_rs1, reg_rs2);
              sprintf (append_str1, "mfceh  r%d", reg_rd);
d4045 2
a4046 2
              sprintf (append_str, "%s r%d, r%d", "mulu", reg_rs1, reg_rs2);
              sprintf (append_str1, "mfceh  r%d", reg_rd);
d4050 2
a4051 2
              sprintf (append_str, "%s r%d, r%d", inst.name, reg_rs1, reg_rs2);
              sprintf (append_str1, "mfcel  r%d", reg_rd);
d4093 1
a4093 1
  sprintf (append_str, "li r1  %s", backupstr);
d4097 1
a4097 1
  sprintf (append_str, " r%d, [r1,0]", reg_rd);
d4182 1
a4182 1
      sprintf (tmp, "lw_pic %s, %s", "r1", add_symbol->bsym->name);
d4194 1
a4194 1
      sprintf (tmp, "addi_s_pic %s, %s", "r1", add_symbol->bsym->name);
d4202 1
a4202 1
      sprintf (tmp, "%s r%d, [%s, %d]", insn_name, reg_rd, "r1", add_number);
d4326 3
a4328 3
  sprintf (append_str[0], "ld_i32hi r1, %s", label_str);
  sprintf (append_str[1], "ld_i32lo r1, %s", label_str);
  sprintf (append_str[2], "%s r%d, [r1, 0]", inst_backup.name, reg_rd);
d4470 1
a4470 1
  char err_msg[100];
d4486 1
a4486 1
      sprintf (err_msg, "invalid constant: 25 bit expression not in range -2^24..2^24");
d4541 1
a4541 1
      inst.error = "invalid constant: 20 bit expression not in range -2^19..2^19";
a5238 11
#ifdef OBJ_ELF
  /* We don't need to align ELF sections to the full alignment.
     However, Irix 5 may prefer that we align them at least to a 16
     byte boundary.  We don't bother to align the sections if we are
     targeted for an embedded system.  */
  if (strcmp (TARGET_OS, "elf") == 0)
    return size;
  if (align > 4)
    align = 4;
#endif

d5636 1
a5636 1
    as_bad ("%s -- `%s'", inst.error, inst.str);
d6210 1
a6210 1
  sprintf (insn_str, "ld_i32hi r%d, %s", GP, GP_DISP_LABEL);
d6214 1
a6214 1
  sprintf (insn_str, "ld_i32lo r%d, %s", GP, GP_DISP_LABEL);
d6218 1
a6218 1
  sprintf (insn_str, "add r%d, r%d, r%d", GP, GP, reg);
d6251 1
a6251 1
      sprintf (insn_str, "sw r%d, [r%d, %d]", GP, reg, cprestore_offset);
d6262 1
a6262 1
      sprintf (insn_str, "li r1, %d", cprestore_offset);
d6266 1
a6266 1
      sprintf (insn_str, "add r1, r1, r%d", reg);
d6270 1
a6270 1
      sprintf (insn_str, "sw r%d, [r1]", GP);
d6329 1
a6329 1
  sprintf (insn_str, "add r%d, r%d, r%d", reg, reg, GP);
@


1.6
log
@	* config/tc-score.c (score_relax_frag): If next frag contains 32 bit branch
	instruction, handle it specially.
	(score_insns): Modify 32 bit branch instruction.
@
text
@d786 1
a786 1
  {"lw_pic",    0x20000000, 0x3e000000, 0x2008,     Insn_internal, do_lw_pic},
d3750 2
a3751 1
      /* Insn 1 and Insn 2  */
d3753 1
a3753 1
	 For an external symbol: lw rD, <sym>($gp)
d4153 1
a4153 1
/* Build a relax frag for lw instruction when generating PIC,
d4157 1
a4157 1
build_lw_pic (int reg_rd, expressionS exp)
d4176 2
a4177 1
      /* Insn 1 and Insn 2  */
d4179 1
a4179 1
	 For an external symbol: lw rD, <sym>($gp)
d4181 1
a4181 1
      sprintf (tmp, "lw_pic r%d, %s", reg_rd, add_symbol->bsym->name);
d4183 1
a4183 1
	return;
d4193 1
a4193 1
      sprintf (tmp, "addi_s_pic r%d, %s", reg_rd, add_symbol->bsym->name);
d4195 1
a4195 1
	return;
d4200 2
a4201 2
      /* Insn 2: lw rD, [rD, constant]  */
      sprintf (tmp, "lw r%d, [r%d, %d]", reg_rd, reg_rd, add_number);
d4203 1
a4203 1
	return;
d4205 2
a4206 2
     /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
     inst.bwarn = -1;
d4210 2
a4211 68
      int hi = (add_number >> 16) & 0x0000FFFF;
      int lo = add_number & 0x0000FFFF;

      /* Insn 1: lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */
      sprintf (tmp, "lw_pic r%d, %s", reg_rd, add_symbol->bsym->name);
      if (append_insn (tmp, TRUE) == (int) FAIL)
	return;

      /* Insn 2  */
      fix_num = 1;
      var_num = 1;
      /* Fix part
	 For an external symbol: ldis r1, HI%<constant>  */
      sprintf (tmp, "ldis %s, %d", "r1", hi);
      if (append_insn (tmp, FALSE) == (int) FAIL)
	return;

      memcpy (&fix_insts[0], &inst, sizeof (struct score_it));

      /* Var part
	 For a local symbol: ldis r1, HI%<constant>
         but, if lo is outof 16 bit, make hi plus 1  */
      if ((lo < -0x8000) || (lo > 0x7fff))
	{
	  hi += 1;
	}
      sprintf (tmp, "ldis_pic %s, %d", "r1", hi);
      if (append_insn (tmp, FALSE) == (int) FAIL)
	return;

      memcpy (&var_insts[0], &inst, sizeof (struct score_it));
      build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);

      /* Insn 3  */
      fix_num = 1;
      var_num = 1;
      /* Fix part
	 For an external symbol: ori r1, LO%<constant>  */
      sprintf (tmp, "ori %s, %d", "r1", lo);
      if (append_insn (tmp, FALSE) == (int) FAIL)
	return;

      memcpy (&fix_insts[0], &inst, sizeof (struct score_it));

      /* Var part
  	 For a local symbol: addi r1, <sym>+LO%<constant>    (BFD_RELOC_GOT_LO16)  */
      sprintf (tmp, "addi_u_pic %s, %s + %d", "r1", add_symbol->bsym->name, lo);
      if (append_insn (tmp, FALSE) == (int) FAIL)
	return;

      memcpy (&var_insts[0], &inst, sizeof (struct score_it));
      build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);

      /* Insn 4: add rD, rD, r1  */
      sprintf (tmp, "add r%d, r%d, %s", reg_rd, reg_rd, "r1");
      if (append_insn (tmp, TRUE) == (int) FAIL)
	return;

     /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
     inst.bwarn = -1;

      /* Insn 5: lw rD, [rD, 0]  */
      sprintf (tmp, "lw r%d, [r%d, 0]", reg_rd, reg_rd);
      if (append_insn (tmp, TRUE) == (int) FAIL)
	return;

     /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
     inst.bwarn = -1;
d4293 4
a4296 2
	  build_lw_pic (reg_rd, inst.reloc.exp);
	  return;
d4947 11
a4957 3
          fragp->insn_addr += 2;
          grows += 2;
	}
d6240 1
a6240 1
#define SCORE_BP_REG  2
d6251 6
d6259 29
a6287 3
  sprintf (insn_str, "sw r%d, [r%d, %d]", GP, SCORE_BP_REG, cprestore_offset);
  if (append_insn (insn_str, TRUE) == (int) FAIL)
    return;
@


1.5
log
@* tc-score.c (do16_rdrs): Handle not! instruction especially.
* score-opc.h (score_opcodes): Delete modifier '0x'.
* gas/score/rD_rA.d: Correct not! and not.c instruction disassembly.
* gas/score/b.d: Correct b! and b instruction disassembly.
@
text
@d378 3
a380 3
  {"bcs",       0x08000000, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bcc",       0x08000400, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bcnz",      0x08003800, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
d387 1
a387 1
  {"beq",       0x08001000, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
d390 3
a392 3
  {"bgtu",      0x08000800, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bgt",       0x08001800, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bge",       0x08002000, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
d408 3
a410 3
  {"bleu",      0x08000c00, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"ble",       0x08001c00, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"blt",       0x08002400, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
d418 1
a418 1
  {"bmi",       0x08002800, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
d421 1
a421 1
  {"bne",       0x08001400, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
d424 1
a424 1
  {"bpl",       0x08002c00, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
d491 2
a492 2
  {"bvs",       0x08003000, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
  {"bvc",       0x08003400, 0x3e007c01, 0x8000,     PC_DISP19div2,        do_branch},
d498 1
a498 1
  {"b",         0x08003c00, 0x3e007c01, 0x08003c00, PC_DISP19div2,        do_branch},
d4612 2
a4613 4
  /* Take the branch condition code.  */
  inst.relax_inst = 0x4000 | (((inst.instruction >> 10) & 0xf) << 8);

  if ((abs_value & 0xfffffe00) == 0)
d4615 1
a4622 3

  if (inst.instruction & 1)
    inst.relax_inst = 0x8000;
d5044 3
a5046 1
	  n_relaxable_p = RELAX_OPT (next_fragp->fr_subtype);
d5062 1
a5062 1
                  if (relaxable_p && ((n_insn_size == 4) && !n_relaxable_p))
@


1.4
log
@* tc-score.c (data_op2): Check invalid operands.
  (my_get_expression): Const operand of some instructions can not be symbol in assembly.
  (get_insn_class_from_type): Handle instruction type Insn_internal.
  (do_macro_ldst_label): Modify inst.type.
  (Insn_PIC): Delete.
* score-inst.h (enum score_insn_type): Add Insn_internal.
* tc-score.c (data_op2): The immediate value in lw is 15 bit signed.
* score-dis.c (print_insn): Correct the error code to print correct PCE instruction disassembly.
@
text
@d1764 5
@


1.3
log
@Fix score bugs
@
text
@a44 1
#define Insn_PIC        123
d781 6
a786 6
  {"ld_i32hi",  0x0a0c0000, 0x3e0e0000, 0x8000,     Rd_I16,               do_macro_rdi32hi},
  {"ld_i32lo",  0x020a0000, 0x3e0e0001, 0x8000,     Rd_I16,               do_macro_rdi32lo},
  {"ldis_pic",  0x0a0c0000, 0x3e0e0000, 0x5000,     Rd_I16,               do_rdi16_pic},
  {"addi_s_pic",0x02000000, 0x3e0e0001, 0x8000,     Rd_SI16,              do_addi_s_pic},
  {"addi_u_pic",0x02000000, 0x3e0e0001, 0x8000,     Rd_SI16,              do_addi_u_pic},
  {"lw_pic",    0x20000000, 0x3e000000, 0x2008,     Rd_rvalueRs_SI15,     do_lw_pic},
d807 1
a807 2
        {
        inst.error = BAD_GARBAGE}
d990 16
d1122 14
d2173 1
d2892 1
a2892 1
                  if (data_type < 27)
d2900 3
a2902 3
                             score_df_range[data_type - 21].bits,
                             score_df_range[data_type - 21].range[0],
                             score_df_range[data_type - 21].range[1]);
d4308 1
d4315 1
d4333 1
@


1.2
log
@  * config/tc-score.c (md_show_usage): Print -KPIC option usage.
@
text
@d3605 1
a3605 1
  fixS *head_fixp = NULL;
d3641 2
a3642 7
    {
      fixp = fix_new_score (frag_now, p - frag_now->fr_literal, inst_main.size,
                            &inst_main.reloc.exp, inst_main.reloc.pc_rel, inst_main.reloc.type);
    }

  head_fixp = xmalloc (sizeof (fixS *));
  frag_now->tc_frag_data.fixp = head_fixp;
d3644 2
a3645 5
  if (fixp)
    {
      head_fixp->fx_next = fixp;
      head_fixp = head_fixp->fx_next;
    }
d3664 10
a3673 2
              head_fixp->fx_next = fixp;
              head_fixp = head_fixp->fx_next;
a3677 4
  head_fixp = frag_now->tc_frag_data.fixp;
  frag_now->tc_frag_data.fixp = head_fixp->fx_next;
  free (head_fixp);

@


1.1
log
@Add support for Score target.
@
text
@d5817 1
a5817 1
        -O0\t\tassemble will not any optimization \n"));
d5819 3
a5821 1
        -G gpnum\tassemble code for setting gpsize and default is 8 byte \n"));
@

