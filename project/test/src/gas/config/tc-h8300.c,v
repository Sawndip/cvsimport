head	1.68;
access;
symbols
	binutils-2_24-branch:1.68.0.2
	binutils-2_24-branchpoint:1.68
	binutils-2_21_1:1.64
	binutils-2_23_2:1.67
	binutils-2_23_1:1.67
	binutils-2_23:1.67
	binutils-2_23-branch:1.67.0.2
	binutils-2_23-branchpoint:1.67
	binutils-2_22_branch:1.65.0.4
	binutils-2_22:1.65
	binutils-2_22-branch:1.65.0.2
	binutils-2_22-branchpoint:1.65
	binutils-2_21:1.64
	binutils-2_21-branch:1.64.0.2
	binutils-2_21-branchpoint:1.64
	binutils-2_20_1:1.62
	binutils-2_20:1.62
	binutils-arc-20081103-branch:1.59.0.6
	binutils-arc-20081103-branchpoint:1.59
	binutils-2_20-branch:1.62.0.2
	binutils-2_20-branchpoint:1.62
	dje-cgen-play1-branch:1.60.0.2
	dje-cgen-play1-branchpoint:1.60
	arc-20081103-branch:1.59.0.4
	arc-20081103-branchpoint:1.59
	binutils-2_19_1:1.59
	binutils-2_19:1.59
	binutils-2_19-branch:1.59.0.2
	binutils-2_19-branchpoint:1.59
	binutils-2_18:1.54
	binutils-2_18-branch:1.54.0.2
	binutils-2_18-branchpoint:1.54
	binutils-csl-coldfire-4_1-32:1.51
	binutils-csl-sourcerygxx-4_1-32:1.51
	binutils-csl-innovasic-fido-3_4_4-33:1.51
	binutils-csl-sourcerygxx-3_4_4-32:1.48
	binutils-csl-coldfire-4_1-30:1.51
	binutils-csl-sourcerygxx-4_1-30:1.51
	binutils-csl-coldfire-4_1-28:1.51
	binutils-csl-sourcerygxx-4_1-29:1.51
	binutils-csl-sourcerygxx-4_1-28:1.51
	binutils-csl-arm-2006q3-27:1.51
	binutils-csl-sourcerygxx-4_1-27:1.51
	binutils-csl-arm-2006q3-26:1.51
	binutils-csl-sourcerygxx-4_1-26:1.51
	binutils-csl-sourcerygxx-4_1-25:1.51
	binutils-csl-sourcerygxx-4_1-24:1.51
	binutils-csl-sourcerygxx-4_1-23:1.51
	binutils-csl-sourcerygxx-4_1-21:1.51
	binutils-csl-arm-2006q3-21:1.51
	binutils-csl-sourcerygxx-4_1-22:1.51
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.51
	binutils-csl-sourcerygxx-4_1-20:1.51
	binutils-csl-arm-2006q3-19:1.51
	binutils-csl-sourcerygxx-4_1-19:1.51
	binutils-csl-sourcerygxx-4_1-18:1.51
	binutils-csl-renesas-4_1-9:1.51
	binutils-csl-sourcerygxx-3_4_4-25:1.48
	binutils-csl-renesas-4_1-8:1.51
	binutils-csl-renesas-4_1-7:1.51
	binutils-csl-renesas-4_1-6:1.51
	binutils-csl-sourcerygxx-4_1-17:1.51
	binutils-csl-sourcerygxx-4_1-14:1.51
	binutils-csl-sourcerygxx-4_1-15:1.51
	binutils-csl-sourcerygxx-4_1-13:1.51
	binutils-2_17:1.51
	binutils-csl-sourcerygxx-4_1-12:1.51
	binutils-csl-sourcerygxx-3_4_4-21:1.51
	binutils-csl-wrs-linux-3_4_4-24:1.48
	binutils-csl-wrs-linux-3_4_4-23:1.48
	binutils-csl-sourcerygxx-4_1-9:1.51
	binutils-csl-sourcerygxx-4_1-8:1.51
	binutils-csl-sourcerygxx-4_1-7:1.51
	binutils-csl-arm-2006q1-6:1.51
	binutils-csl-sourcerygxx-4_1-6:1.51
	binutils-csl-wrs-linux-3_4_4-22:1.48
	binutils-csl-coldfire-4_1-11:1.51
	binutils-csl-sourcerygxx-3_4_4-19:1.51
	binutils-csl-coldfire-4_1-10:1.51
	binutils-csl-sourcerygxx-4_1-5:1.51
	binutils-csl-sourcerygxx-4_1-4:1.51
	binutils-csl-wrs-linux-3_4_4-21:1.48
	binutils-csl-morpho-4_1-4:1.51
	binutils-csl-sourcerygxx-3_4_4-17:1.51
	binutils-csl-wrs-linux-3_4_4-20:1.48
	binutils-2_17-branch:1.51.0.4
	binutils-2_17-branchpoint:1.51
	binutils-csl-2_17-branch:1.51.0.2
	binutils-csl-2_17-branchpoint:1.51
	binutils-csl-gxxpro-3_4-branch:1.48.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.48
	binutils-2_16_1:1.48
	binutils-csl-arm-2005q1b:1.48
	binutils-2_16:1.48
	binutils-csl-arm-2005q1a:1.48
	binutils-csl-arm-2005q1-branch:1.48.0.4
	binutils-csl-arm-2005q1-branchpoint:1.48
	binutils-2_16-branch:1.48.0.2
	binutils-2_16-branchpoint:1.48
	csl-arm-2004-q3d:1.46
	csl-arm-2004-q3:1.46
	binutils-2_15:1.46
	binutils-2_15-branchpoint:1.46
	csl-arm-2004-q1a:1.46
	csl-arm-2004-q1:1.46
	binutils-2_15-branch:1.46.0.6
	cagney_bfdfile-20040213-branch:1.46.0.4
	cagney_bfdfile-20040213-branchpoint:1.46
	cagney_bigcore-20040122-branch:1.46.0.2
	cagney_bigcore-20040122-branchpoint:1.46
	csl-arm-2003-q4:1.45
	binutils-2_14:1.27
	binutils-2_14-branch:1.27.0.2
	binutils-2_14-branchpoint:1.27
	binutils-2_13_2_1:1.22
	binutils-2_13_2:1.22
	binutils-2_13_1:1.22
	binutils-2_13:1.22
	binutils-2_13-branchpoint:1.22
	binutils-2_13-branch:1.22.0.2
	binutils-2_12_1:1.19
	binutils-2_12:1.19
	binutils-2_12-branch:1.19.0.2
	binutils-2_12-branchpoint:1.19
	cygnus_cvs_20020108_pre:1.18
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.68
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.68
date	2013.03.21.16.08.07;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2012.05.17.15.13.16;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2012.02.27.06.40.42;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2011.01.20.12.49.05;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.19.10.47.49;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2010.01.13.14.08.52;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2009.04.07.18.21.22;	author dj;	state Exp;
branches;
next	1.59;

1.59
date	2008.08.06.15.42.15;	author dj;	state Exp;
branches;
next	1.58;

1.58
date	2008.07.21.17.50.54;	author dj;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.11.14.17.43;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.19.15.25.13;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.02.21.39.56;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.11.01.25.25;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.49;

1.49
date	2005.05.05.09.12.55;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2005.01.31.23.18.27;	author bje;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.12.15.02.20;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches;
next	1.44;

1.44
date	2003.11.26.13.18.22;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.25.23.09.47;	author kazu;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.25.16.13.35;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.23.15.43.50;	author kazu;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.20.04.25.26;	author kazu;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.20.04.12.19;	author kazu;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.20.03.31.36;	author kazu;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.17.10.23.33;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.22.04.56.50;	author aoliva;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.22.04.56.05;	author aoliva;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.07.09.33.01;	author rsandifo;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.25.15.31.58;	author rsandifo;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.10.07.27.56;	author rsandifo;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.10.07.09.30;	author rsandifo;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.05.18.53.35;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.03.21.29.08;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.24.12.47.32;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.24.12.36.07;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.15.08.51.53;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.19.22.56.42;	author kdienes;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.31.14.29.58;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.09.13.12.57;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.24.18.22.06;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.15.21.28.55;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.19.05.33.22;	author hjl;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.05.02.01.08;	author law;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.31.22.43.55;	author law;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.31.17.43.52;	author law;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.30.20.38.35;	author law;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.30.20.15.06;	author law;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.29.18.56.50;	author law;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.29.18.50.56;	author law;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.06.25.16.49.47;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.23.05.44.30;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.21.21.31.24;	author law;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.09.00.00.02;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.14.11.48.42;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.21.28.47;	author law;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.8.2.1
date	2001.06.07.03.15.28;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.68
log
@	* elf32-h8300 (h8_relax_section): Add new relaxation of mov
	@@(disp:32,ERx) to mov @@(disp:16,ERx).
	(R_H8_DISP32A16): New reloc.
	Comments added and corrected.
	* reloc.c (BFD_RELOC_H8_DISP32A16): New reloc.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* ld.texinfo (H8/300): Add description of relaxation of
	mov @@(disp:32,ERx) to mov @@(disp:16,ERx).

	* ld-h8300/h8300.exp: Add new relax-7 test on ELF.
	* ld-h8300/relax-2.s: Add other direction and .w/.l variants of
	mov insns.
	* ld-h8300/relax-2.d: Update expected disassembly.
	* ld-h8300/relax-7a.s: New: tests for mov @@(disp:32,ERx) -> mov
	@@(disp:16,ERx).
	* ld-h8300/relax-7b.s: New: Likewise.
	* ld-h8300/relax-7.d: New: expected disassembly.

	* config/tc-h8300.c (do_a_fix_imm): Add relaxation of mov
	@@(disp:32,ERx) to mov @@(disp:16,ERx) insns by new reloc
	R_H8_DISP32A16.
	* config/tc-h8300.h: Remove duplicated defines.
@
text
@/* tc-h8300.c -- Assemble code for the Renesas H8/300
   Copyright 1991-2013 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#include "as.h"
#include "subsegs.h"
#include "dwarf2dbg.h"

#define DEFINE_TABLE
#define h8_opcodes ops
#include "opcode/h8300.h"
#include "safe-ctype.h"

#ifdef OBJ_ELF
#include "elf/h8.h"
#endif

const char comment_chars[] = ";";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = "";

static void sbranch (int);
static void h8300hmode (int);
static void h8300smode (int);
static void h8300hnmode (int);
static void h8300snmode (int);
static void h8300sxmode (int);
static void h8300sxnmode (int);
static void pint (int);

int Hmode;
int Smode;
int Nmode;
int SXmode;

#define PSIZE (Hmode && !Nmode ? L_32 : L_16)

static int bsize = L_8;		/* Default branch displacement.  */

struct h8_instruction
{
  int length;
  int noperands;
  int idx;
  int size;
  const struct h8_opcode *opcode;
};

static struct h8_instruction *h8_instructions;

static void
h8300hmode (int arg ATTRIBUTE_UNUSED)
{
  Hmode = 1;
  Smode = 0;
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300h))
    as_warn (_("could not set architecture and machine"));
}

static void
h8300smode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300s))
    as_warn (_("could not set architecture and machine"));
}

static void
h8300hnmode (int arg ATTRIBUTE_UNUSED)
{
  Hmode = 1;
  Smode = 0;
  Nmode = 1;
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300hn))
    as_warn (_("could not set architecture and machine"));
}

static void
h8300snmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  Nmode = 1;
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sn))
    as_warn (_("could not set architecture and machine"));
}

static void
h8300sxmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  SXmode = 1;
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sx))
    as_warn (_("could not set architecture and machine"));
}

static void
h8300sxnmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  SXmode = 1;
  Nmode = 1;
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sxn))
    as_warn (_("could not set architecture and machine"));
}

static void
sbranch (int size)
{
  bsize = size;
}

static void
pint (int arg ATTRIBUTE_UNUSED)
{
  cons (Hmode ? 4 : 2);
}

/* Like obj_elf_section, but issues a warning for new
   sections which do not have an attribute specification.  */

static void
h8300_elf_section (int push)
{
  static const char * known_data_sections [] = { ".rodata", ".tdata", ".tbss" };
  static const char * known_data_prefixes [] = { ".debug", ".zdebug", ".gnu.warning" };
  char * saved_ilp = input_line_pointer;
  char * name;

  name = obj_elf_section_name ();
  if (name == NULL)
    return;

  if (* input_line_pointer != ','
      && bfd_get_section_by_name (stdoutput, name) == NULL)
    {
      signed int i;

      /* Ignore this warning for well known data sections.  */
      for (i = ARRAY_SIZE (known_data_sections); i--;)
	if (strcmp (name, known_data_sections[i]) == 0)
	  break;

      if (i < 0)
	for (i = ARRAY_SIZE (known_data_prefixes); i--;)
	  if (strncmp (name, known_data_prefixes[i],
		       strlen (known_data_prefixes[i])) == 0)
	    break;

      if (i < 0)
	as_warn (_("new section '%s' defined without attributes - this might cause problems"), name);
    }

  /* FIXME: We ought to free the memory allocated by obj_elf_section_name()
     for 'name', but we do not know if it was taken from the obstack, via
     demand_copy_C_string(), or xmalloc()ed.  */
  input_line_pointer = saved_ilp;
  obj_elf_section (push);
}

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  {"h8300h",  h8300hmode,  0},
  {"h8300hn", h8300hnmode, 0},
  {"h8300s",  h8300smode,  0},
  {"h8300sn", h8300snmode, 0},
  {"h8300sx", h8300sxmode, 0},
  {"h8300sxn", h8300sxnmode, 0},
  {"sbranch", sbranch, L_8},
  {"lbranch", sbranch, L_16},

  {"int", pint, 0},
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"form", listing_psize, 0},
  {"heading", listing_title, 0},
  {"import",  s_ignore, 0},
  {"page",    listing_eject, 0},
  {"program", s_ignore, 0},

#ifdef OBJ_ELF
  {"section",   h8300_elf_section, 0},
  {"section.s", h8300_elf_section, 0},
  {"sect",      h8300_elf_section, 0},
  {"sect.s",    h8300_elf_section, 0},
#endif

  {0, 0, 0}
};

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

static struct hash_control *opcode_hash_control;	/* Opcode mnemonics.  */

/* This function is called once, at assembler startup time.  This
   should set up all the tables, etc. that the MD part of the assembler
   needs.  */

void
md_begin (void)
{
  unsigned int nopcodes;
  struct h8_opcode *p, *p1;
  struct h8_instruction *pi;
  char prev_buffer[100];
  int idx = 0;

  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300))
    as_warn (_("could not set architecture and machine"));

  opcode_hash_control = hash_new ();
  prev_buffer[0] = 0;

  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
  
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  pi = h8_instructions;
  p1 = h8_opcodes;
  /* We do a minimum amount of sorting on the opcode table; this is to
     make it easy to describe the mova instructions without unnecessary
     code duplication.
     Sorting only takes place inside blocks of instructions of the form
     X/Y, so for example mova/b, mova/w and mova/l can be intermixed.  */
  while (p1)
    {
      struct h8_opcode *first_skipped = 0;
      int len, cmplen = 0;
      char *src = p1->name;
      char *dst, *buffer;

      if (p1->name == 0)
	break;
      /* Strip off any . part when inserting the opcode and only enter
	 unique codes into the hash table.  */
      dst = buffer = malloc (strlen (src) + 1);
      while (*src)
	{
	  if (*src == '.')
	    {
	      src++;
	      break;
	    }
	  if (*src == '/')
	    cmplen = src - p1->name + 1;
	  *dst++ = *src++;
	}
      *dst = 0;
      len = dst - buffer;
      if (cmplen == 0)
	cmplen = len;
      hash_insert (opcode_hash_control, buffer, (char *) pi);
      strcpy (prev_buffer, buffer);
      idx++;

      for (p = p1; p->name; p++)
	{
	  /* A negative TIME is used to indicate that we've added this opcode
	     already.  */
	  if (p->time == -1)
	    continue;
	  if (strncmp (p->name, buffer, cmplen) != 0
	      || (p->name[cmplen] != '\0' && p->name[cmplen] != '.'
		  && p->name[cmplen - 1] != '/'))
	    {
	      if (first_skipped == 0)
		first_skipped = p;
	      break;
	    }
	  if (strncmp (p->name, buffer, len) != 0)
	    {
	      if (first_skipped == 0)
		first_skipped = p;
	      continue;
	    }

	  p->time = -1;
	  pi->size = p->name[len] == '.' ? p->name[len + 1] : 0;
	  pi->idx = idx;

	  /* Find the number of operands.  */
	  pi->noperands = 0;
	  while (pi->noperands < 3 && p->args.nib[pi->noperands] != (op_type) E)
	    pi->noperands++;

	  /* Find the length of the opcode in bytes.  */
	  pi->length = 0;
	  while (p->data.nib[pi->length * 2] != (op_type) E)
	    pi->length++;

	  pi->opcode = p;
	  pi++;
	}
      p1 = first_skipped;
    }

  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->noperands = 0;
  pi->idx = 0;
  pi->size = 0;
  pi->opcode = 0;

  linkrelax = 1;
}

struct h8_op
{
  op_type mode;
  unsigned reg;
  expressionS exp;
};

static void clever_message (const struct h8_instruction *, struct h8_op *);
static void fix_operand_size (struct h8_op *, int);
static void build_bytes (const struct h8_instruction *, struct h8_op *);
static void do_a_fix_imm (int, int, struct h8_op *, int, const struct h8_instruction *);
static void check_operand (struct h8_op *, unsigned int, char *);
static const struct h8_instruction * get_specific (const struct h8_instruction *, struct h8_op *, int) ;
static char *get_operands (unsigned, char *, struct h8_op *);
static void get_operand (char **, struct h8_op *, int);
static int parse_reg (char *, op_type *, unsigned *, int);
static char *skip_colonthing (char *, int *);
static char *parse_exp (char *, struct h8_op *);

static int constant_fits_size_p (struct h8_op *, int, int);

/*
  parse operands
  WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp
  r0l,r0h,..r7l,r7h
  @@WREG
  @@WREG+
  @@-WREG
  #const
  ccr
*/

/* Try to parse a reg name.  Return the number of chars consumed.  */

static int
parse_reg (char *src, op_type *mode, unsigned int *reg, int direction)
{
  char *end;
  int len;

  /* Cribbed from get_symbol_end.  */
  if (!is_name_beginner (*src) || *src == '\001')
    return 0;
  end = src + 1;
  while ((is_part_of_name (*end) && *end != '.') || *end == '\001')
    end++;
  len = end - src;

  if (len == 2 && TOLOWER (src[0]) == 's' && TOLOWER (src[1]) == 'p')
    {
      *mode = PSIZE | REG | direction;
      *reg = 7;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 'c' && 
      TOLOWER (src[1]) == 'c' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = CCR;
      *reg = 0;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 'e' && 
      TOLOWER (src[1]) == 'x' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = EXR;
      *reg = 1;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 'v' && 
      TOLOWER (src[1]) == 'b' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = VBR;
      *reg = 6;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 's' && 
      TOLOWER (src[1]) == 'b' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = SBR;
      *reg = 7;
      return len;
    }
  if (len == 2 && TOLOWER (src[0]) == 'f' && TOLOWER (src[1]) == 'p')
    {
      *mode = PSIZE | REG | direction;
      *reg = 6;
      return len;
    }
  if (len == 3 && TOLOWER (src[0]) == 'e' && TOLOWER (src[1]) == 'r' &&
      src[2] >= '0' && src[2] <= '7')
    {
      *mode = L_32 | REG | direction;
      *reg = src[2] - '0';
      if (!Hmode)
	as_warn (_("Reg not valid for H8/300"));
      return len;
    }
  if (len == 2 && TOLOWER (src[0]) == 'e' && src[1] >= '0' && src[1] <= '7')
    {
      *mode = L_16 | REG | direction;
      *reg = src[1] - '0' + 8;
      if (!Hmode)
	as_warn (_("Reg not valid for H8/300"));
      return len;
    }

  if (TOLOWER (src[0]) == 'r')
    {
      if (src[1] >= '0' && src[1] <= '7')
	{
	  if (len == 3 && TOLOWER (src[2]) == 'l')
	    {
	      *mode = L_8 | REG | direction;
	      *reg = (src[1] - '0') + 8;
	      return len;
	    }
	  if (len == 3 && TOLOWER (src[2]) == 'h')
	    {
	      *mode = L_8 | REG | direction;
	      *reg = (src[1] - '0');
	      return len;
	    }
	  if (len == 2)
	    {
	      *mode = L_16 | REG | direction;
	      *reg = (src[1] - '0');
	      return len;
	    }
	}
    }

  return 0;
}


/* Parse an immediate or address-related constant and store it in OP.
   If the user also specifies the operand's size, store that size
   in OP->MODE, otherwise leave it for later code to decide.  */

static char *
parse_exp (char *src, struct h8_op *op)
{
  char *save;

  save = input_line_pointer;
  input_line_pointer = src;
  expression (&op->exp);
  if (op->exp.X_op == O_absent)
    as_bad (_("missing operand"));
  src = input_line_pointer;
  input_line_pointer = save;

  return skip_colonthing (src, &op->mode);
}


/* If SRC starts with an explicit operand size, skip it and store the size
   in *MODE.  Leave *MODE unchanged otherwise.  */

static char *
skip_colonthing (char *src, int *mode)
{
  if (*src == ':')
    {
      src++;
      *mode &= ~SIZE;
      if (src[0] == '8' && !ISDIGIT (src[1]))
	*mode |= L_8;
      else if (src[0] == '2' && !ISDIGIT (src[1]))
	*mode |= L_2;
      else if (src[0] == '3' && !ISDIGIT (src[1]))
	*mode |= L_3;
      else if (src[0] == '4' && !ISDIGIT (src[1]))
	*mode |= L_4;
      else if (src[0] == '5' && !ISDIGIT (src[1]))
	*mode |= L_5;
      else if (src[0] == '2' && src[1] == '4' && !ISDIGIT (src[2]))
	*mode |= L_24;
      else if (src[0] == '3' && src[1] == '2' && !ISDIGIT (src[2]))
	*mode |= L_32;
      else if (src[0] == '1' && src[1] == '6' && !ISDIGIT (src[2]))
	*mode |= L_16;
      else
	as_bad (_("invalid operand size requested"));

      while (ISDIGIT (*src))
	src++;
    }
  return src;
}

/* The many forms of operand:

   Rn			Register direct
   @@Rn			Register indirect
   @@(exp[:16], Rn)	Register indirect with displacement
   @@Rn+
   @@-Rn
   @@aa:8		absolute 8 bit
   @@aa:16		absolute 16 bit
   @@aa			absolute 16 bit

   #xx[:size]		immediate data
   @@(exp:[8], pc)	pc rel
   @@@@aa[:8]		memory indirect.  */

static int
constant_fits_width_p (struct h8_op *operand, offsetT width)
{
  offsetT num;

  num = ((operand->exp.X_add_number & 0xffffffff) ^ 0x80000000) - 0x80000000;
  return (num & ~width) == 0 || (num | width) == ~0;
}

static int
constant_fits_size_p (struct h8_op *operand, int size, int no_symbols)
{
  offsetT num;

  if (no_symbols
      && (operand->exp.X_add_symbol != 0 || operand->exp.X_op_symbol != 0))
    return 0;
  num = operand->exp.X_add_number & 0xffffffff;
  switch (size)
    {
    case L_2:
      return (num & ~3) == 0;
    case L_3:
      return (num & ~7) == 0;
    case L_3NZ:
      return num >= 1 && num < 8;
    case L_4:
      return (num & ~15) == 0;
    case L_5:
      return num >= 1 && num < 32;
    case L_8:
      num = (num ^ 0x80000000) - 0x80000000;
      return (num & ~0xFF) == 0 || (num | 0x7F) == ~0;
    case L_8U:
      return (num & ~0xFF) == 0;
    case L_16:
      num = (num ^ 0x80000000) - 0x80000000;
      return (num & ~0xFFFF) == 0 || (num | 0x7FFF) == ~0;
    case L_16U:
      return (num & ~0xFFFF) == 0;
    case L_32:
      return 1;
    default:
      abort ();
    }
}

static void
get_operand (char **ptr, struct h8_op *op, int direction)
{
  char *src = *ptr;
  op_type mode;
  unsigned int num;
  unsigned int len;

  op->mode = 0;

  /* Check for '(' and ')' for instructions ldm and stm.  */
  if (src[0] == '(' && src[8] == ')')
    ++ src;

  /* Gross.  Gross.  ldm and stm have a format not easily handled
     by get_operand.  We deal with it explicitly here.  */
  if (TOLOWER (src[0]) == 'e' && TOLOWER (src[1]) == 'r' && 
      ISDIGIT (src[2]) && src[3] == '-' &&
      TOLOWER (src[4]) == 'e' && TOLOWER (src[5]) == 'r' && ISDIGIT (src[6]))
    {
      int low, high;

      low = src[2] - '0';
      high = src[6] - '0';

       /* Check register pair's validity as per tech note TN-H8*-193A/E
	  from Renesas for H8S and H8SX hardware manual.  */
      if (   !(low == 0 && (high == 1 || high == 2 || high == 3))
          && !(low == 1 && (high == 2 || high == 3 || high == 4) && SXmode)
          && !(low == 2 && (high == 3 || ((high == 4 || high == 5) && SXmode)))
          && !(low == 3 && (high == 4 || high == 5 || high == 6) && SXmode)
          && !(low == 4 && (high == 5 || high == 6))
          && !(low == 4 && high == 7 && SXmode)
          && !(low == 5 && (high == 6 || high == 7) && SXmode)
          && !(low == 6 && high == 7 && SXmode))
	as_bad (_("Invalid register list for ldm/stm\n"));

      /* Even sicker.  We encode two registers into op->reg.  One
	 for the low register to save, the other for the high
	 register to save;  we also set the high bit in op->reg
	 so we know this is "very special".  */
      op->reg = 0x80000000 | (high << 8) | low;
      op->mode = REG;
      if (src[7] == ')')
	*ptr = src + 8;
      else
	*ptr = src + 7;
      return;
    }

  len = parse_reg (src, &op->mode, &op->reg, direction);
  if (len)
    {
      src += len;
      if (*src == '.')
	{
	  int size = op->mode & SIZE;
	  switch (src[1])
	    {
	    case 'l': case 'L':
	      if (size != L_32)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      break;
	    case 'w': case 'W':
	      if (size != L_32 && size != L_16)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      op->mode = (op->mode & ~SIZE) | L_16;
	      break;
	    case 'b': case 'B':
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      if (size != L_32 && size != L_8)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      op->mode = (op->mode & ~SIZE) | L_8;
	      break;
	    default:
	      as_warn (_("invalid suffix after register."));
	      break;
	    }
	  src += 2;
	}
      *ptr = src;
      return;
    }

  if (*src == '@@')
    {
      src++;
      if (*src == '@@')
	{
	  *ptr = parse_exp (src + 1, op);
	  if (op->exp.X_add_number >= 0x100)
	    {
	      int divisor = 1;

	      op->mode = VECIND;
	      /* FIXME : 2?  or 4?  */
	      if (op->exp.X_add_number >= 0x400)
		as_bad (_("address too high for vector table jmp/jsr"));
	      else if (op->exp.X_add_number >= 0x200)
		divisor = 4;
	      else
		divisor = 2;

	      op->exp.X_add_number = op->exp.X_add_number / divisor - 0x80;
	    }
	  else
	    op->mode = MEMIND;
	  return;
	}

      if (*src == '-' || *src == '+')
	{
	  len = parse_reg (src + 1, &mode, &num, direction);
	  if (len == 0)
	    {
	      /* Oops, not a reg after all, must be ordinary exp.  */
	      op->mode = ABS | direction;
	      *ptr = parse_exp (src, op);
	      return;
	    }

	  if (((mode & SIZE) != PSIZE)
	      /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
	      && (!Nmode || ((mode & SIZE) != L_32)))
	    as_bad (_("Wrong size pointer register for architecture."));

	  op->mode = src[0] == '-' ? RDPREDEC : RDPREINC;
	  op->reg = num;
	  *ptr = src + 1 + len;
	  return;
	}
      if (*src == '(')
	{
	  src++;

	  /* See if this is @@(ERn.x, PC).  */
	  len = parse_reg (src, &mode, &op->reg, direction);
	  if (len != 0 && (mode & MODE) == REG && src[len] == '.')
	    {
	      switch (TOLOWER (src[len + 1]))
		{
		case 'b':
		  mode = PCIDXB | direction;
		  break;
		case 'w':
		  mode = PCIDXW | direction;
		  break;
		case 'l':
		  mode = PCIDXL | direction;
		  break;
		default:
		  mode = 0;
		  break;
		}
	      if (mode
		  && src[len + 2] == ','
		  && TOLOWER (src[len + 3]) != 'p' 
		  && TOLOWER (src[len + 4]) != 'c'
		  && src[len + 5] != ')')
		{
		  *ptr = src + len + 6;
		  op->mode |= mode;
		  return;
		}
	      /* Fall through into disp case - the grammar is somewhat
		 ambiguous, so we should try whether it's a DISP operand
		 after all ("ER3.L" might be a poorly named label...).  */
	    }

	  /* Disp.  */

	  /* Start off assuming a 16 bit offset.  */

	  src = parse_exp (src, op);
	  if (*src == ')')
	    {
	      op->mode |= ABS | direction;
	      *ptr = src + 1;
	      return;
	    }

	  if (*src != ',')
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;
	    }
	  src++;

	  len = parse_reg (src, &mode, &op->reg, direction);
	  if (len == 0 || (mode & MODE) != REG)
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;
	    }
	  src += len;
	  if (src[0] == '.')
	    {
	      switch (TOLOWER (src[1]))
		{
		case 'b':
		  op->mode |= INDEXB | direction;
		  break;
		case 'w':
		  op->mode |= INDEXW | direction;
		  break;
		case 'l':
		  op->mode |= INDEXL | direction;
		  break;
		default:
		  as_bad (_("expected .L, .W or .B for register in indexed addressing mode"));
		}
	      src += 2;
	      op->reg &= 7;
	    }
	  else
	    op->mode |= DISP | direction;
	  src = skip_colonthing (src, &op->mode);

	  if (*src != ')' && '(')
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;
	    }
	  *ptr = src + 1;
	  return;
	}
      len = parse_reg (src, &mode, &num, direction);

      if (len)
	{
	  src += len;
	  if (*src == '+' || *src == '-')
	    {
	      if (((mode & SIZE) != PSIZE)
		  /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
		  && (!Nmode || ((mode & SIZE) != L_32)))
		as_bad (_("Wrong size pointer register for architecture."));
	      op->mode = *src == '+' ? RSPOSTINC : RSPOSTDEC;
	      op->reg = num;
	      src++;
	      *ptr = src;
	      return;
	    }
	  if (((mode & SIZE) != PSIZE)
	      /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
	      && (!Nmode || ((mode & SIZE) != L_32)))
	    as_bad (_("Wrong size pointer register for architecture."));

	  op->mode = direction | IND | PSIZE;
	  op->reg = num;
	  *ptr = src;

	  return;
	}
      else
	{
	  /* must be a symbol */

	  op->mode = ABS | direction;
	  *ptr = parse_exp (src, op);
	  return;
	}
    }

  if (*src == '#')
    {
      op->mode = IMM;
      *ptr = parse_exp (src + 1, op);
      return;
    }
  else if (strncmp (src, "mach", 4) == 0 || 
	   strncmp (src, "macl", 4) == 0 ||
	   strncmp (src, "MACH", 4) == 0 || 
	   strncmp (src, "MACL", 4) == 0)
    {
      op->reg = TOLOWER (src[3]) == 'l';
      op->mode = MACREG;
      *ptr = src + 4;
      return;
    }
  else
    {
      op->mode = PCREL;
      *ptr = parse_exp (src, op);
    }
}

static char *
get_operands (unsigned int noperands, char *op_end, struct h8_op *operand)
{
  char *ptr = op_end;

  switch (noperands)
    {
    case 0:
      break;

    case 1:
      ptr++;
      get_operand (&ptr, operand + 0, SRC);
      if (*ptr == ',')
	{
	  ptr++;
	  get_operand (&ptr, operand + 1, DST);
	}
      break;

    case 2:
      ptr++;
      get_operand (&ptr, operand + 0, SRC);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, DST);
      break;

    case 3:
      ptr++;
      get_operand (&ptr, operand + 0, SRC);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, DST);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 2, OP3);
      break;

    default:
      abort ();
    }

  return ptr;
}

/* MOVA has special requirements.  Rather than adding twice the amount of
   addressing modes, we simply special case it a bit.  */
static void
get_mova_operands (char *op_end, struct h8_op *operand)
{
  char *ptr = op_end;

  if (ptr[1] != '@@' || ptr[2] != '(')
    goto error;
  ptr += 3;
  operand[0].mode = 0;
  ptr = parse_exp (ptr, &operand[0]);

  if (*ptr !=',')
    goto error;
  ptr++;
  get_operand (&ptr, operand + 1, DST);

  if (*ptr =='.')
    {
      ptr++;
      switch (*ptr++)
	{
	case 'b': case 'B':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXB;
	  break;
	case 'w': case 'W':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXW;
	  break;
	case 'l': case 'L':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXL;
	  break;
	default:
	  goto error;
	}
    }
  else if ((operand[1].mode & MODE) == LOWREG)
    {
      switch (operand[1].mode & SIZE) 
	{
	case L_8:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXB;
	  break;
	case L_16:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXW;
	  break;
	case L_32:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXL;
	  break;
	default:
	  goto error;
	}
    }
  else
    goto error;

  if (*ptr++ != ')' || *ptr++ != ',')
    goto error;
  get_operand (&ptr, operand + 2, OP3);
  /* See if we can use the short form of MOVA.  */
  if (((operand[1].mode & MODE) == REG || (operand[1].mode & MODE) == LOWREG)
      && (operand[2].mode & MODE) == REG
      && (operand[1].reg & 7) == (operand[2].reg & 7))
    {
      operand[1].mode = operand[2].mode = 0;
      operand[0].reg = operand[2].reg & 7;
    }
  return;

 error:
  as_bad (_("expected valid addressing mode for mova: \"@@(disp, ea.sz),ERn\""));
}

static void
get_rtsl_operands (char *ptr, struct h8_op *operand)
{
  int mode, len, type = 0;
  unsigned int num, num2;

  ptr++;
  if (*ptr == '(')
    {
      ptr++;
      type = 1;
    }
  len = parse_reg (ptr, &mode, &num, SRC);
  if (len == 0 || (mode & MODE) != REG)
    {
      as_bad (_("expected register"));
      return;
    }
  ptr += len;
  if (*ptr == '-')
    {
      len = parse_reg (++ptr, &mode, &num2, SRC);
      if (len == 0 || (mode & MODE) != REG)
	{
	  as_bad (_("expected register"));
	  return;
	}
      ptr += len;
      /* CONST_xxx are used as placeholders in the opcode table.  */
      num = num2 - num;
      if (num > 3)
	{
	  as_bad (_("invalid register list"));
	  return;
	}
    }
  else
    num2 = num, num = 0;
  if (type == 1 && *ptr++ != ')')
    {
      as_bad (_("expected closing paren"));
      return;
    }
  operand[0].mode = RS32;
  operand[1].mode = RD32;
  operand[0].reg = num;
  operand[1].reg = num2;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

static const struct h8_instruction *
get_specific (const struct h8_instruction *instruction,
	      struct h8_op *operands, int size)
{
  const struct h8_instruction *this_try = instruction;
  const struct h8_instruction *found_other = 0, *found_mismatched = 0;
  int found = 0;
  int this_index = instruction->idx;
  int noperands = 0;

  /* There's only one ldm/stm and it's easier to just
     get out quick for them.  */
  if (OP_KIND (instruction->opcode->how) == O_LDM
      || OP_KIND (instruction->opcode->how) == O_STM)
    return this_try;

  while (noperands < 3 && operands[noperands].mode != 0)
    noperands++;

  while (this_index == instruction->idx && !found)
    {
      int this_size;

      found = 1;
      this_try = instruction++;
      this_size = this_try->opcode->how & SN;

      if (this_try->noperands != noperands)
	found = 0;
      else if (this_try->noperands > 0)
	{
	  int i;

	  for (i = 0; i < this_try->noperands && found; i++)
	    {
	      op_type op = this_try->opcode->args.nib[i];
	      int op_mode = op & MODE;
	      int op_size = op & SIZE;
	      int x = operands[i].mode;
	      int x_mode = x & MODE;
	      int x_size = x & SIZE;

	      if (op_mode == LOWREG && (x_mode == REG || x_mode == LOWREG))
		{
		  if ((x_size == L_8 && (operands[i].reg & 8) == 0)
		      || (x_size == L_16 && (operands[i].reg & 8) == 8))
		    as_warn (_("can't use high part of register in operand %d"), i);

		  if (x_size != op_size)
		    found = 0;
		}
	      else if (op_mode == REG)
		{
		  if (x_mode == LOWREG)
		    x_mode = REG;
		  if (x_mode != REG)
		    found = 0;

		  if (x_size == L_P)
		    x_size = (Hmode ? L_32 : L_16);
		  if (op_size == L_P)
		    op_size = (Hmode ? L_32 : L_16);

		  /* The size of the reg is v important.  */
		  if (op_size != x_size)
		    found = 0;
		}
	      else if (op_mode & CTRL)	/* control register */
		{
		  if (!(x_mode & CTRL))
		    found = 0;

		  switch (x_mode)
		    {
		    case CCR:
		      if (op_mode != CCR &&
			  op_mode != CCR_EXR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case EXR:
		      if (op_mode != EXR &&
			  op_mode != CCR_EXR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case MACH:
		      if (op_mode != MACH &&
			  op_mode != MACREG)
			found = 0;
		      break;
		    case MACL:
		      if (op_mode != MACL &&
			  op_mode != MACREG)
			found = 0;
		      break;
		    case VBR:
		      if (op_mode != VBR &&
			  op_mode != VBR_SBR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case SBR:
		      if (op_mode != SBR &&
			  op_mode != VBR_SBR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    }
		}
	      else if ((op & ABSJMP) && (x_mode == ABS || x_mode == PCREL))
		{
		  operands[i].mode &= ~MODE;
		  operands[i].mode |= ABSJMP;
		  /* But it may not be 24 bits long.  */
		  if (x_mode == ABS && !Hmode)
		    {
		      operands[i].mode &= ~SIZE;
		      operands[i].mode |= L_16;
		    }
		  if ((operands[i].mode & SIZE) == L_32
		      && (op_mode & SIZE) != L_32)
		   found = 0;
		}
	      else if (x_mode == IMM && op_mode != IMM)
		{
		  offsetT num = operands[i].exp.X_add_number & 0xffffffff;
		  if (op_mode == KBIT || op_mode == DBIT)
		    /* This is ok if the immediate value is sensible.  */;
		  else if (op_mode == CONST_2)
		    found = num == 2;
		  else if (op_mode == CONST_4)
		    found = num == 4;
		  else if (op_mode == CONST_8)
		    found = num == 8;
		  else if (op_mode == CONST_16)
		    found = num == 16;
		  else
		    found = 0;
		}
	      else if (op_mode == PCREL && op_mode == x_mode)
		{
		  /* movsd, bsr/bc and bsr/bs only come in PCREL16 flavour:
		     If x_size is L_8, promote it.  */
		  if (OP_KIND (this_try->opcode->how) == O_MOVSD
		      || OP_KIND (this_try->opcode->how) == O_BSRBC
		      || OP_KIND (this_try->opcode->how) == O_BSRBS)
		    if (x_size == L_8)
		      x_size = L_16;

		  /* The size of the displacement is important.  */
		  if (op_size != x_size)
		    found = 0;
		}
	      else if ((op_mode == DISP || op_mode == IMM || op_mode == ABS
			|| op_mode == INDEXB || op_mode == INDEXW
			|| op_mode == INDEXL)
		       && op_mode == x_mode)
		{
		  /* Promote a L_24 to L_32 if it makes us match.  */
		  if (x_size == L_24 && op_size == L_32)
		    {
		      x &= ~SIZE;
		      x |= x_size = L_32;
		    }

		  if (((x_size == L_16 && op_size == L_16U)
		       || (x_size == L_8 && op_size == L_8U)
		       || (x_size == L_3 && op_size == L_3NZ))
		      /* We're deliberately more permissive for ABS modes.  */
		      && (op_mode == ABS
			  || constant_fits_size_p (operands + i, op_size,
						   op & NO_SYMBOLS)))
		    x_size = op_size;

		  if (x_size != 0 && op_size != x_size)
		    found = 0;
		  else if (x_size == 0
			   && ! constant_fits_size_p (operands + i, op_size,
						      op & NO_SYMBOLS))
		    found = 0;
		}
	      else if (op_mode != x_mode)
		{
		  found = 0;
		}
	    }
	}
      if (found)
	{
	  if ((this_try->opcode->available == AV_H8SX && ! SXmode)
	      || (this_try->opcode->available == AV_H8S && ! Smode)
	      || (this_try->opcode->available == AV_H8H && ! Hmode))
	    found = 0, found_other = this_try;
	  else if (this_size != size && (this_size != SN && size != SN))
	    found_mismatched = this_try, found = 0;

	}
    }
  if (found)
    return this_try;
  if (found_other)
    {
      as_warn (_("Opcode `%s' with these operand types not available in %s mode"),
	       found_other->opcode->name,
	       (! Hmode && ! Smode ? "H8/300"
		: SXmode ? "H8sx"
		: Smode ? "H8/300S"
		: "H8/300H"));
    }
  else if (found_mismatched)
    {
      as_warn (_("mismatch between opcode size and operand size"));
      return found_mismatched;
    }
  return 0;
}

static void
check_operand (struct h8_op *operand, unsigned int width, char *string)
{
  if (operand->exp.X_add_symbol == 0
      && operand->exp.X_op_symbol == 0)
    {
      /* No symbol involved, let's look at offset, it's dangerous if
	 any of the high bits are not 0 or ff's, find out by oring or
	 anding with the width and seeing if the answer is 0 or all
	 fs.  */

      if (! constant_fits_width_p (operand, width))
	{
	  if (width == 255
	      && (operand->exp.X_add_number & 0xff00) == 0xff00)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 16 bit address truncated into an 8 bit address
		 of something like bset.  */
	    }
	  else if (strcmp (string, "@@") == 0
		   && width == 0xffff
		   && (operand->exp.X_add_number & 0xff8000) == 0xff8000)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 24 bit address truncated into a 16 bit address
		 of something like mov.w.  */
	    }
	  else
	    {
	      as_warn (_("operand %s0x%lx out of range."), string,
		       (unsigned long) operand->exp.X_add_number);
	    }
	}
    }
}

/* RELAXMODE has one of 3 values:

   0 Output a "normal" reloc, no relaxing possible for this insn/reloc

   1 Output a relaxable 24bit absolute mov.w address relocation
     (may relax into a 16bit absolute address).

   2 Output a relaxable 16/24 absolute mov.b address relocation
     (may relax into an 8bit absolute address).  */

static void
do_a_fix_imm (int offset, int nibble, struct h8_op *operand, int relaxmode, const struct h8_instruction *this_try)
{
  int idx;
  int size;
  int where;
  char *bytes = frag_now->fr_literal + offset;

  char *t = ((operand->mode & MODE) == IMM) ? "#" : "@@";

  if (operand->exp.X_add_symbol == 0)
    {
      switch (operand->mode & SIZE)
	{
	case L_2:
	  check_operand (operand, 0x3, t);
	  bytes[0] |= (operand->exp.X_add_number & 3) << (nibble ? 0 : 4);
	  break;
	case L_3:
	case L_3NZ:
	  check_operand (operand, 0x7, t);
	  bytes[0] |= (operand->exp.X_add_number & 7) << (nibble ? 0 : 4);
	  break;
	case L_4:
	  check_operand (operand, 0xF, t);
	  bytes[0] |= (operand->exp.X_add_number & 15) << (nibble ? 0 : 4);
	  break;
	case L_5:
	  check_operand (operand, 0x1F, t);
	  bytes[0] |= operand->exp.X_add_number & 31;
	  break;
	case L_8:
	case L_8U:
	  check_operand (operand, 0xff, t);
	  bytes[0] |= operand->exp.X_add_number;
	  break;
	case L_16:
	case L_16U:
	  check_operand (operand, 0xffff, t);
	  bytes[0] |= operand->exp.X_add_number >> 8;
	  bytes[1] |= operand->exp.X_add_number >> 0;
#ifdef OBJ_ELF
	  /* MOVA needs both relocs to relax the second operand properly.  */
	  if (relaxmode != 0
	      && (OP_KIND(this_try->opcode->how) == O_MOVAB
		  || OP_KIND(this_try->opcode->how) == O_MOVAW
		  || OP_KIND(this_try->opcode->how) == O_MOVAL))
	    {
	      idx = BFD_RELOC_16;
	      fix_new_exp (frag_now, offset, 2, &operand->exp, 0, idx);
	    }
#endif
	  break;
	case L_24:
	  check_operand (operand, 0xffffff, t);
	  bytes[0] |= operand->exp.X_add_number >> 16;
	  bytes[1] |= operand->exp.X_add_number >> 8;
	  bytes[2] |= operand->exp.X_add_number >> 0;
	  break;

	case L_32:
	  /* This should be done with bfd.  */
	  bytes[0] |= operand->exp.X_add_number >> 24;
	  bytes[1] |= operand->exp.X_add_number >> 16;
	  bytes[2] |= operand->exp.X_add_number >> 8;
	  bytes[3] |= operand->exp.X_add_number >> 0;
	  if (relaxmode != 0)
	    {
#ifdef OBJ_ELF
	      if ((operand->mode & MODE) == DISP && relaxmode == 1)
		idx = BFD_RELOC_H8_DISP32A16;
	      else
#endif
		idx = (relaxmode == 2) ? R_MOV24B1 : R_MOVL1;
	      fix_new_exp (frag_now, offset, 4, &operand->exp, 0, idx);
	    }
	  break;
	}
    }
  else
    {
      switch (operand->mode & SIZE)
	{
	case L_24:
	case L_32:
	  size = 4;
	  where = (operand->mode & SIZE) == L_24 ? -1 : 0;
#ifdef OBJ_ELF
	  if ((operand->mode & MODE) == DISP && relaxmode == 1)
	    idx = BFD_RELOC_H8_DISP32A16;
	  else
#endif
	  if (relaxmode == 2)
	    idx = R_MOV24B1;
	  else if (relaxmode == 1)
	    idx = R_MOVL1;
	  else
	    idx = R_RELLONG;
	  break;
	default:
	  as_bad (_("Can't work out size of operand.\n"));
	case L_16:
	case L_16U:
	  size = 2;
	  where = 0;
	  if (relaxmode == 2)
	    idx = R_MOV16B1;
	  else
	    idx = R_RELWORD;
	  operand->exp.X_add_number =
	    ((operand->exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	  operand->exp.X_add_number |= (bytes[0] << 8) | bytes[1];
	  break;
	case L_8:
	  size = 1;
	  where = 0;
	  idx = R_RELBYTE;
	  operand->exp.X_add_number =
	    ((operand->exp.X_add_number & 0xff) ^ 0x80) - 0x80;
	  operand->exp.X_add_number |= bytes[0];
	}

      fix_new_exp (frag_now,
		   offset + where,
		   size,
		   &operand->exp,
		   0,
		   idx);
    }
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static void
build_bytes (const struct h8_instruction *this_try, struct h8_op *operand)
{
  int i;
  char *output = frag_more (this_try->length);
  const op_type *nibble_ptr = this_try->opcode->data.nib;
  op_type c;
  unsigned int nibble_count = 0;
  int op_at[3];
  int nib = 0;
  int movb = 0;
  char asnibbles[100];
  char *p = asnibbles;
  int high, low;

  if (!Hmode && this_try->opcode->available != AV_H8)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300 mode"),
	     this_try->opcode->name);
  else if (!Smode 
	   && this_try->opcode->available != AV_H8 
	   && this_try->opcode->available != AV_H8H)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300H mode"),
	     this_try->opcode->name);
  else if (!SXmode 
	   && this_try->opcode->available != AV_H8
	   && this_try->opcode->available != AV_H8H
	   && this_try->opcode->available != AV_H8S)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300S mode"),
	     this_try->opcode->name);

  while (*nibble_ptr != (op_type) E)
    {
      int d;

      nib = 0;
      c = *nibble_ptr++;

      d = (c & OP3) == OP3 ? 2 : (c & DST) == DST ? 1 : 0;

      if (c < 16)
	nib = c;
      else
	{
	  int c2 = c & MODE;

	  if (c2 == REG || c2 == LOWREG
	      || c2 == IND || c2 == PREINC || c2 == PREDEC
	      || c2 == POSTINC || c2 == POSTDEC)
	    {
	      nib = operand[d].reg;
	      if (c2 == LOWREG)
		nib &= 7;
	    }

	  else if (c & CTRL)	/* Control reg operand.  */
	    nib = operand[d].reg;

	  else if ((c & DISPREG) == (DISPREG))
	    {
	      nib = operand[d].reg;
	    }
	  else if (c2 == ABS)
	    {
	      operand[d].mode = c;
	      op_at[d] = nibble_count;
	      nib = 0;
	    }
	  else if (c2 == IMM || c2 == PCREL || c2 == ABS
		   || (c & ABSJMP) || c2 == DISP)
	    {
	      operand[d].mode = c;
	      op_at[d] = nibble_count;
	      nib = 0;
	    }
	  else if ((c & IGNORE) || (c & DATA))
	    nib = 0;

	  else if (c2 == DBIT)
	    {
	      switch (operand[0].exp.X_add_number)
		{
		case 1:
		  nib = c;
		  break;
		case 2:
		  nib = 0x8 | c;
		  break;
		default:
		  as_bad (_("Need #1 or #2 here"));
		}
	    }
	  else if (c2 == KBIT)
	    {
	      switch (operand[0].exp.X_add_number)
		{
		case 1:
		  nib = 0;
		  break;
		case 2:
		  nib = 8;
		  break;
		case 4:
		  if (!Hmode)
		    as_warn (_("#4 not valid on H8/300."));
		  nib = 9;
		  break;

		default:
		  as_bad (_("Need #1 or #2 here"));
		  break;
		}
	      /* Stop it making a fix.  */
	      operand[0].mode = 0;
	    }

	  if (c & MEMRELAX)
	    operand[d].mode |= MEMRELAX;

	  if (c & B31)
	    nib |= 0x8;

	  if (c & B21)
	    nib |= 0x4;

	  if (c & B11)
	    nib |= 0x2;

	  if (c & B01)
	    nib |= 0x1;

	  if (c2 == MACREG)
	    {
	      if (operand[0].mode == MACREG)
		/* stmac has mac[hl] as the first operand.  */
		nib = 2 + operand[0].reg;
	      else
		/* ldmac has mac[hl] as the second operand.  */
		nib = 2 + operand[1].reg;
	    }
	}
      nibble_count++;

      *p++ = nib;
    }

  /* Disgusting.  Why, oh why didn't someone ask us for advice
     on the assembler format.  */
  if (OP_KIND (this_try->opcode->how) == O_LDM)
    {
      high = (operand[1].reg >> 8) & 0xf;
      low  = (operand[1].reg) & 0xf;
      asnibbles[2] = high - low;
      asnibbles[7] = high;
    }
  else if (OP_KIND (this_try->opcode->how) == O_STM)
    {
      high = (operand[0].reg >> 8) & 0xf;
      low  = (operand[0].reg) & 0xf;
      asnibbles[2] = high - low;
      asnibbles[7] = low;
    }

  for (i = 0; i < this_try->length; i++)
    output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];

  /* Note if this is a mov.b or a bit manipulation instruction
     there is a special relaxation which only applies.  */
  if (   this_try->opcode->how == O (O_MOV,   SB)
      || this_try->opcode->how == O (O_BCLR,  SB)
      || this_try->opcode->how == O (O_BAND,  SB)
      || this_try->opcode->how == O (O_BIAND, SB)
      || this_try->opcode->how == O (O_BILD,  SB)
      || this_try->opcode->how == O (O_BIOR,  SB)
      || this_try->opcode->how == O (O_BIST,  SB)
      || this_try->opcode->how == O (O_BIXOR, SB)
      || this_try->opcode->how == O (O_BLD,   SB)
      || this_try->opcode->how == O (O_BNOT,  SB)
      || this_try->opcode->how == O (O_BOR,   SB)
      || this_try->opcode->how == O (O_BSET,  SB)
      || this_try->opcode->how == O (O_BST,   SB)
      || this_try->opcode->how == O (O_BTST,  SB)
      || this_try->opcode->how == O (O_BXOR,  SB))
    movb = 1;

  /* Output any fixes.  */
  for (i = 0; i < this_try->noperands; i++)
    {
      int x = operand[i].mode;
      int x_mode = x & MODE;

      if (x_mode == IMM || x_mode == DISP)
	{
#ifndef OBJ_ELF
	  /* Remove MEMRELAX flag added in h8300.h on mov with
	     addressing mode "register indirect with displacement".  */
	  if (x_mode == DISP)
	    x &= ~MEMRELAX;
#endif
	  do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
			op_at[i] & 1, operand + i, (x & MEMRELAX) != 0,
			this_try);
	}
      else if (x_mode == ABS)
	do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
		      op_at[i] & 1, operand + i,
		      (x & MEMRELAX) ? movb + 1 : 0,
		      this_try);

      else if (x_mode == PCREL)
	{
	  int size16 = (x & SIZE) == L_16;
	  int size = size16 ? 2 : 1;
	  int type = size16 ? R_PCRWORD : R_PCRBYTE;
	  fixS *fixP;

	  check_operand (operand + i, size16 ? 0x7fff : 0x7f, "@@");

	  if (operand[i].exp.X_add_number & 1)
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);
#ifndef OBJ_ELF
	  /* The COFF port has always been off by one, changing it
	     now would be an incompatible change, so we leave it as-is.

	     We don't want to do this for ELF as we want to be
	     compatible with the proposed ELF format from Hitachi.  */
	  operand[i].exp.X_add_number -= 1;
#endif
	  if (size16)
	    {
	      operand[i].exp.X_add_number =
		((operand[i].exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	    }
	  else
	    {
	      operand[i].exp.X_add_number =
		((operand[i].exp.X_add_number & 0xff) ^ 0x80) - 0x80;
	    }

	  /* For BRA/S.  */
	  if (! size16)
	    operand[i].exp.X_add_number |= output[op_at[i] / 2];

	  fixP = fix_new_exp (frag_now,
			      output - frag_now->fr_literal + op_at[i] / 2,
			      size,
			      &operand[i].exp,
			      1,
			      type);
	  fixP->fx_signed = 1;
	}
      else if (x_mode == MEMIND)
	{
	  check_operand (operand + i, 0xff, "@@@@");
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + 1,
		       1,
		       &operand[i].exp,
		       0,
		       R_MEM_INDIRECT);
	}
      else if (x_mode == VECIND)
	{
	  check_operand (operand + i, 0x7f, "@@@@");
	  /* FIXME: approximating the effect of "B31" here...
	     This is very hackish, and ought to be done a better way.  */
	  operand[i].exp.X_add_number |= 0x80;
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + 1,
		       1,
		       &operand[i].exp,
		       0,
		       R_MEM_INDIRECT);
	}
      else if (x & ABSJMP)
	{
	  int where = 0;
	  bfd_reloc_code_real_type reloc_type = R_JMPL1;

#ifdef OBJ_ELF
	  /* To be compatible with the proposed H8 ELF format, we
	     want the relocation's offset to point to the first byte
	     that will be modified, not to the start of the instruction.  */
	  
	  if ((operand->mode & SIZE) == L_32)
	    {
	      where = 2;
	      reloc_type = R_RELLONG;
	    }
	  else
	    where = 1;
#endif

	  /* This jmp may be a jump or a branch.  */

	  check_operand (operand + i, 
			 SXmode ? 0xffffffff : Hmode ? 0xffffff : 0xffff, 
			 "@@");

	  if (operand[i].exp.X_add_number & 1)
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);

	  if (!Hmode)
	    operand[i].exp.X_add_number =
	      ((operand[i].exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + where,
		       4,
		       &operand[i].exp,
		       0,
		       reloc_type);
	}
    }
}

/* Try to give an intelligent error message for common and simple to
   detect errors.  */

static void
clever_message (const struct h8_instruction *instruction,
		struct h8_op *operand)
{
  /* Find out if there was more than one possible opcode.  */

  if ((instruction + 1)->idx != instruction->idx)
    {
      int argn;

      /* Only one opcode of this flavour, try to guess which operand
         didn't match.  */
      for (argn = 0; argn < instruction->noperands; argn++)
	{
	  switch (instruction->opcode->args.nib[argn])
	    {
	    case RD16:
	      if (operand[argn].mode != RD16)
		{
		  as_bad (_("destination operand must be 16 bit register"));
		  return;

		}
	      break;

	    case RS8:
	      if (operand[argn].mode != RS8)
		{
		  as_bad (_("source operand must be 8 bit register"));
		  return;
		}
	      break;

	    case ABS16DST:
	      if (operand[argn].mode != ABS16DST)
		{
		  as_bad (_("destination operand must be 16bit absolute address"));
		  return;
		}
	      break;
	    case RD8:
	      if (operand[argn].mode != RD8)
		{
		  as_bad (_("destination operand must be 8 bit register"));
		  return;
		}
	      break;

	    case ABS16SRC:
	      if (operand[argn].mode != ABS16SRC)
		{
		  as_bad (_("source operand must be 16bit absolute address"));
		  return;
		}
	      break;

	    }
	}
    }
  as_bad (_("invalid operands"));
}


/* If OPERAND is part of an address, adjust its size and value given
   that it addresses SIZE bytes.

   This function decides how big non-immediate constants are when no
   size was explicitly given.  It also scales down the assembly-level
   displacement in an @@(d:2,ERn) operand.  */

static void
fix_operand_size (struct h8_op *operand, int size)
{
  if (SXmode && (operand->mode & MODE) == DISP)
    {
      /* If the user didn't specify an operand width, see if we
	 can use @@(d:2,ERn).  */
      if ((operand->mode & SIZE) == 0
	  && operand->exp.X_add_symbol == 0
	  && operand->exp.X_op_symbol == 0
	  && (operand->exp.X_add_number == size
	      || operand->exp.X_add_number == size * 2
	      || operand->exp.X_add_number == size * 3))
	operand->mode |= L_2;

      /* Scale down the displacement in an @@(d:2,ERn) operand.
	 X_add_number then contains the desired field value.  */
      if ((operand->mode & SIZE) == L_2)
	{
	  if (operand->exp.X_add_number % size != 0)
	    as_warn (_("operand/size mis-match"));
	  operand->exp.X_add_number /= size;
	}
    }

  if ((operand->mode & SIZE) == 0)
    switch (operand->mode & MODE)
      {
      case DISP:
      case INDEXB:
      case INDEXW:
      case INDEXL:
      case ABS:
	/* Pick a 24-bit address unless we know that a 16-bit address
	   is safe.  get_specific() will relax L_24 into L_32 where
	   necessary.  */
	if (Hmode
	    && !Nmode 
	    && ((((addressT) operand->exp.X_add_number + 0x8000)
		 & 0xffffffff) > 0xffff
		|| operand->exp.X_add_symbol != 0
		|| operand->exp.X_op_symbol != 0))
	  operand->mode |= L_24;
	else
	  operand->mode |= L_16;
	break;

      case PCREL:
	if ((((addressT) operand->exp.X_add_number + 0x80)
	     & 0xffffffff) <= 0xff)
	  {
	    if (operand->exp.X_add_symbol != NULL)
	      operand->mode |= bsize;
	    else
	      operand->mode |= L_8;
	  }
	else
	  operand->mode |= L_16;
	break;
      }
}


/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles.  */

void
md_assemble (char *str)
{
  char *op_start;
  char *op_end;
  struct h8_op operand[3];
  const struct h8_instruction *instruction;
  const struct h8_instruction *prev_instruction;

  char *dot = 0;
  char *slash = 0;
  char c;
  int size, i;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.  */
  for (op_start = op_end = str;
       *op_end != 0 && *op_end != ' ';
       op_end++)
    {
      if (*op_end == '.')
	{
	  dot = op_end + 1;
	  *op_end = 0;
	  op_end += 2;
	  break;
	}
      else if (*op_end == '/' && ! slash)
	slash = op_end;
    }

  if (op_end == op_start)
    {
      as_bad (_("can't find opcode "));
    }
  c = *op_end;

  *op_end = 0;

  /* The assembler stops scanning the opcode at slashes, so it fails
     to make characters following them lower case.  Fix them.  */
  if (slash)
    while (*++slash)
      *slash = TOLOWER (*slash);

  instruction = (const struct h8_instruction *)
    hash_find (opcode_hash_control, op_start);

  if (instruction == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  /* We used to set input_line_pointer to the result of get_operands,
     but that is wrong.  Our caller assumes we don't change it.  */

  operand[0].mode = 0;
  operand[1].mode = 0;
  operand[2].mode = 0;

  if (OP_KIND (instruction->opcode->how) == O_MOVAB
      || OP_KIND (instruction->opcode->how) == O_MOVAW
      || OP_KIND (instruction->opcode->how) == O_MOVAL)
    get_mova_operands (op_end, operand);
  else if (OP_KIND (instruction->opcode->how) == O_RTEL
	   || OP_KIND (instruction->opcode->how) == O_RTSL)
    get_rtsl_operands (op_end, operand);
  else
    get_operands (instruction->noperands, op_end, operand);

  *op_end = c;
  prev_instruction = instruction;

  /* Now we have operands from instruction.
     Let's check them out for ldm and stm.  */
  if (OP_KIND (instruction->opcode->how) == O_LDM)
    {
      /* The first operand must be @@er7+, and the
	 second operand must be a register pair.  */
      if ((operand[0].mode != RSINC)
           || (operand[0].reg != 7)
           || ((operand[1].reg & 0x80000000) == 0))
	as_bad (_("invalid operand in ldm"));
    }
  else if (OP_KIND (instruction->opcode->how) == O_STM)
    {
      /* The first operand must be a register pair,
	 and the second operand must be @@-er7.  */
      if (((operand[0].reg & 0x80000000) == 0)
            || (operand[1].mode != RDDEC)
            || (operand[1].reg != 7))
	as_bad (_("invalid operand in stm"));
    }

  size = SN;
  if (dot)
    {
      switch (TOLOWER (*dot))
	{
	case 'b':
	  size = SB;
	  break;

	case 'w':
	  size = SW;
	  break;

	case 'l':
	  size = SL;
	  break;
	}
    }
  if (OP_KIND (instruction->opcode->how) == O_MOVAB ||
      OP_KIND (instruction->opcode->how) == O_MOVAW ||
      OP_KIND (instruction->opcode->how) == O_MOVAL)
    {
      switch (operand[0].mode & MODE)
	{
	case INDEXB:
	default:
	  fix_operand_size (&operand[1], 1);
	  break;
	case INDEXW:
	  fix_operand_size (&operand[1], 2);
	  break;
	case INDEXL:
	  fix_operand_size (&operand[1], 4);
	  break;
	}
    }
  else
    {
      for (i = 0; i < 3 && operand[i].mode != 0; i++)
	switch (size)
	  {
	  case SN:
	  case SB:
	  default:
	    fix_operand_size (&operand[i], 1);
	    break;
	  case SW:
	    fix_operand_size (&operand[i], 2);
	    break;
	  case SL:
	    fix_operand_size (&operand[i], 4);
	    break;
	  }
    }

  instruction = get_specific (instruction, operand, size);

  if (instruction == 0)
    {
      /* Couldn't find an opcode which matched the operands.  */
      char *where = frag_more (2);

      where[0] = 0x0;
      where[1] = 0x0;
      clever_message (prev_instruction, operand);

      return;
    }

  build_bytes (instruction, operand);

  dwarf2_emit_insn (instruction->length);
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Various routines to kill one day.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

#define OPTION_H_TICK_HEX      (OPTION_MD_BASE)

const char *md_shortopts = "";
struct option md_longopts[] = {
  { "h-tick-hex", no_argument,	      NULL, OPTION_H_TICK_HEX  },
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    case OPTION_H_TICK_HEX:
      enable_h_tick_hex = 1;
      break;

    default:
      return 0;
    }
  return 1;
}

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
}

void tc_aout_fix_to_chars (void);

void
tc_aout_fix_to_chars (void)
{
  printf (_("call to tc_aout_fix_to_chars \n"));
  abort ();
}

void
md_convert_frag (bfd *headers ATTRIBUTE_UNUSED,
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
  printf (_("call to md_convert_frag \n"));
  abort ();
}

valueT
md_section_align (segT segment, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  long val = *valP;

  switch (fixP->fx_size)
    {
    case 1:
      *buf++ = val;
      break;
    case 2:
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    case 4:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    case 8:
      /* This can arise when the .quad or .8byte pseudo-ops are used.
	 Returning here (without setting fx_done) will cause the code
	 to attempt to generate a reloc which will then fail with the
	 slightly more helpful error message: "Cannot represent
	 relocation type BFD_RELOC_64".  */
      return;
    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

int
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
			       segT segment_type ATTRIBUTE_UNUSED)
{
  printf (_("call to md_estimate_size_before_relax \n"));
  abort ();
}

/* Put number into target byte order.  */
void
md_number_to_chars (char *ptr, valueT use, int nbytes)
{
  number_to_chars_bigendian (ptr, use, nbytes);
}

long
md_pcrel_from (fixS *fixp)
{
  as_bad_where (fixp->fx_file, fixp->fx_line,
		_("Unexpected reference to a symbol in a non-code section"));
  return 0;
}

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("Difference of symbols in different sections is not supported"));
	  return NULL;
	}
    }

  rel = xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  rel->addend = fixp->fx_offset;

  r_type = fixp->fx_r_type;

#define DEBUG 0
#if DEBUG
  fprintf (stderr, "%s\n", bfd_get_reloc_code_name (r_type));
  fflush (stderr);
#endif
  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (r_type));
      return NULL;
    }

  return rel;
}
@


1.67
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d2 1
a2 3
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2012
   Free Software Foundation, Inc.
d1397 6
a1402 1
	      idx = (relaxmode == 2) ? R_MOV24B1 : R_MOVL1;
d1416 5
d1627 1
a1627 1
  /* Note if this is a movb or a bit manipulation instruction
d1653 11
a1663 4
	do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
		      op_at[i] & 1, operand + i, (x & MEMRELAX) != 0,
		      this_try);

@


1.66
log
@	* config/tc-h8300.c (constant_fits_width_p): Trim constant to 32 bits
	and sign extend before range tests.
	(constant_fits_size_p): Similarly.
	(get_specific): Trim X_add_number to 32 bits.
	(fix_operand_size): Likewise, and use unsigned test for signed
	ranges.
@
text
@a361 1
static int constant_fits_width_p (struct h8_op *, unsigned int);
d558 1
a558 1
constant_fits_width_p (struct h8_op *operand, unsigned int width)
@


1.65
log
@	PR gas/12384
	* config/tc-h8300.c (constant_fits_width_p): Use correct type for
	comparison.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d561 4
a564 2
  return ((operand->exp.X_add_number & ~width) == 0
	  || (operand->exp.X_add_number | (offsetT) width) == (offsetT)(~0));
d570 2
a571 1
  offsetT num = operand->exp.X_add_number;
d575 1
d589 2
a590 1
      return (num & ~0xFF) == 0 || ((unsigned)num | 0x7F) == ~0u;
d594 2
a595 1
      return (num & ~0xFFFF) == 0 || ((unsigned)num | 0x7FFF) == ~0u;
d1193 1
a1193 1
		  offsetT num = operands[i].exp.X_add_number;
d1875 2
a1876 2
	    && (operand->exp.X_add_number < -32768
		|| operand->exp.X_add_number > 32767
d1885 2
a1886 3
	/* This condition is long standing, though somewhat suspect.  */
	if (operand->exp.X_add_number > -128
	    && operand->exp.X_add_number < 127)
@


1.64
log
@        * config/tc-h8300.c (h8300_elf_section): Add .zdebug to the list
        of known section prefixes.
@
text
@d562 1
a562 1
	  || (operand->exp.X_add_number | width) == (unsigned)(~0));
@


1.63
log
@        * config/tc-h8300.c (h8300_elf_section): New function - issue a
        warning message if a new section is created without setting any
        attributes for it.
        (md_pseudo_table): Intercept section creation pseudos.
        (md_pcrel_from): Replace abort with an error message.
        * config/obj-elf.c (obj_elf_section_name): Export this function.
        * config/obj-elf.h (obj_elf_section_name): Prototype.

        * gas/elf/section0.d: Skip this test for the h8300.
        * gas/elf/section1.d: Likewise.
        * gas/elf/section6.d: Likewise.
        * gas/elf/elf.exp: Skip section2 and section5 tests when the
        target is the h8300.

        * ld-scrips/sort.exp: Skip these tests when the target is the
        h8300.
@
text
@d149 1
a149 1
  static const char * known_data_prefixes [] = { ".debug", ".gnu.warning" };
@


1.62
log
@update copyright dates
@
text
@d142 42
d210 8
d2192 1
a2192 1
md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)
d2194 3
a2196 1
  abort ();
@


1.61
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d3 2
a4 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
@


1.60
log
@[bfd]
	* elf32-h8300.c (elf32_h8_relax_section): Relax MOVA opcodes.
[gas]
	* tc-h8300.c (do_a_fix_imm): Pass the insn, force relocs for MOVA
	immediates.
	(build_bytes): Pass insn to do_a_fix_imm.
[include/opcode]
	* h8300.h: Add relaxation attributes to MOVA opcodes.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d626 1
a626 1
	      as_warn ("invalid suffix after register.");
@


1.59
log
@* NEWS: Mention these changes.

* config/tc-h8300.h (H_TICK_HEX): Define.
* config/tc-h8300.c (OPTION_H_TICK_HEX): New.
(md_longopts): Add "-h-tick-hex".
(md_parse_option): Support it.
* doc/c-h8300.texi (H8/300 Options): Document it.
* doc/as.texinfo (Overview): Likewise.

* config/tc-sh.h (H_TICK_HEX): Define.
* config/tc-sh.c (OPTION_H_TICK_HEX): New.
(md_longopts): Add "-h-tick-hex".
(md_parse_option): Support it.
* doc/c-sh.texi (SH Options): Document it.
* doc/c-sh64.texi (SH64 Options): Document it.
* doc/as.texinfo (Overview): Likewise.
@
text
@d302 1
a302 1
static void do_a_fix_imm (int, int, struct h8_op *, int);
d1276 1
a1276 1
do_a_fix_imm (int offset, int nibble, struct h8_op *operand, int relaxmode)
d1316 11
d1590 2
a1591 1
		      op_at[i] & 1, operand + i, (x & MEMRELAX) != 0);
d1596 2
a1597 1
		      (x & MEMRELAX) ? movb + 1 : 0);
@


1.58
log
@* config/tc-h8300.c (fix_operand_size): Use the default size
specified by the .lbranch/.sbranch pseudos.
@
text
@d2021 2
d2025 1
d2034 10
a2043 1
  return 0;
@


1.57
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1818 6
a1823 1
	  operand->mode |= L_8;
@


1.56
log
@PR gas/5158
* config/tc-h8300.c (tc_gen_reloc): Allow for translation of error message.
* po/gas.pot: Regenerate.
@
text
@d2008 1
a2008 8
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */
d2013 1
a2013 46
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
@


1.55
log
@* config/tc-h8300.c (md_apply_fix): Do not abort or handle 8 byte fixups.
@
text
@d2148 2
a2149 2
md_estimate_size_before_relax (register fragS *fragP ATTRIBUTE_UNUSED,
			       register segT segment_type ATTRIBUTE_UNUSED)
d2151 1
a2151 1
  printf (_("call tomd_estimate_size_before_relax \n"));
d2180 1
a2180 1
			"Difference of symbols in different sections is not supported");
d2185 2
a2186 2
  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d2196 1
a2196 1
  fflush(stderr);
@


1.54
log
@Switch to GPLv3
@
text
@d2132 7
@


1.53
log
@	* config/tc-h8300.c (build_bytes): Fix const warning.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.52
log
@remove some duplicate #include's.
@
text
@d1392 1
a1392 1
  op_type *nibble_ptr = this_try->opcode->data.nib;
@


1.51
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
a23 1
#include <stdio.h>
a25 1
#include "bfd.h"
@


1.50
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a27 2

#ifdef BFD_ASSEMBLER
a28 1
#endif
a76 1
#ifdef BFD_ASSEMBLER
a78 1
#endif
a85 1
#ifdef BFD_ASSEMBLER
a87 1
#endif
a95 1
#ifdef BFD_ASSEMBLER
a97 1
#endif
a105 1
#ifdef BFD_ASSEMBLER
a107 1
#endif
a115 1
#ifdef BFD_ASSEMBLER
a117 1
#endif
a126 1
#ifdef BFD_ASSEMBLER
a128 1
#endif
a171 2
const int md_reloc_size;

a193 1
#ifdef BFD_ASSEMBLER
a195 1
#endif
a2000 1
#ifdef BFD_ASSEMBLER
a2001 8
#endif
}

#ifndef BFD_ASSEMBLER
void
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_crawl_symbol_chain \n"));
a2002 1
#endif
a2009 8
#ifndef BFD_ASSEMBLER
void
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_headers_hook \n"));
}
#endif

d2098 1
a2098 6
md_convert_frag (
#ifdef BFD_ASSEMBLER
		 bfd *headers ATTRIBUTE_UNUSED,
#else
		 object_headers *headers ATTRIBUTE_UNUSED,
#endif
a2105 1
#ifdef BFD_ASSEMBLER
a2111 9
#else
valueT
md_section_align (segT seg, valueT size)
{
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
}
#endif

a2162 60
#ifndef BFD_ASSEMBLER
void
tc_reloc_mangle (fixS *fix_ptr, struct internal_reloc *intr, bfd_vma base)
{
  symbolS *symbol_ptr;

  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it.  */
  if (fix_ptr->fx_r_type == TC_CONS_RELOC)
    {
      /* cons likes to create reloc32's whatever the size of the reloc..
       */
      switch (fix_ptr->fx_size)
	{
	case 4:
	  intr->r_type = R_RELLONG;
	  break;
	case 2:
	  intr->r_type = R_RELWORD;
	  break;
	case 1:
	  intr->r_type = R_RELBYTE;
	  break;
	default:
	  abort ();
	}
    }
  else
    {
      intr->r_type = fix_ptr->fx_r_type;
    }

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  if (symbol_ptr)
    {
      if (symbol_ptr->sy_number != -1)
	intr->r_symndx = symbol_ptr->sy_number;
      else
	{
	  symbolS *segsym;

	  /* This case arises when a reference is made to `.'.  */
	  segsym = seg_info (S_GET_SEGMENT (symbol_ptr))->dot;
	  if (segsym == NULL)
	    intr->r_symndx = -1;
	  else
	    {
	      intr->r_symndx = segsym->sy_number;
	      intr->r_offset += S_GET_VALUE (symbol_ptr);
	    }
	}
    }
  else
    intr->r_symndx = -1;
}
#else /* BFD_ASSEMBLER */
a2203 1
#endif
@


1.49
log
@Update the address and phone number of the FSF
@
text
@d2166 1
a2166 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.48
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.47
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d981 2
a982 1
  int mode, num, num2, len, type = 0;
d1008 1
a1008 1
      if (num < 0 || num > 3)
@


1.46
log
@Add support for relaxation of bit manipulation instructions.
@
text
@a1195 9
#if 0 /* ??? */
		  /* Promote an L8 to L_16 if it makes us match.  */
		  if ((op_mode == ABS || op_mode == DISP) && x_size == L_8)
		    {
		      if (op_size == L_16)
			x_size = L_16;
		    }
#endif

@


1.45
log
@Remove redundant returns in void functions.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d1581 17
a1597 3
  /* Note if this is a movb instruction -- there's a special relaxation
     which only applies to them.  */
  if (this_try->opcode->how == O (O_MOV, SB))
@


1.44
log
@Revert change to t01_mov test.
Fix ldm/stm verifying code to allow er4-er7 for H8SX.
@
text
@a975 1
  return;
@


1.43
log
@	* config/tc-h8300.c (h8_exp): Remove.
@
text
@d601 1
@


1.42
log
@ Catch illegal register pairings in ldm/stm instructions.
Update test files to avoid illegal pairings.
@
text
@a312 7
struct h8_exp
{
  char *e_beg;
  char *e_end;
  expressionS e_exp;
};

@


1.41
log
@	* config/tc-h8300.c (Hmode): Make it global.
	(Smode): Likewise.
	(Nmode): Likewise.
	(SXmode): Likewise.
@
text
@d601 9
a609 1
      if (high == low)
a611 6
      if (high < low)
	as_bad (_("Invalid register list for ldm/stm\n"));

      if (high - low > 3)
	as_bad (_("Invalid register list for ldm/stm)\n"));

d1928 21
@


1.40
log
@	* config/tc-h8300.c: Make some functions and global
	variables static appropriately.
@
text
@d55 4
a58 4
static int Hmode;
static int Smode;
static int Nmode;
static int SXmode;
@


1.39
log
@	* config/obj-ieee.c: Remove duplicate prototypes.
	* config/tc-h8300.c: Likewise.
@
text
@d46 7
a52 7
void sbranch (int);
void h8300hmode (int);
void h8300smode (int);
void h8300hnmode (int);
void h8300snmode (int);
void h8300sxmode (int);
void h8300sxnmode (int);
d55 4
a58 4
int Hmode;
int Smode;
int Nmode;
int SXmode;
d62 1
a62 1
int bsize = L_8;		/* Default branch displacement.  */
d73 1
a73 1
struct h8_instruction *h8_instructions;
d75 1
a75 1
void
d86 1
a86 1
void
d97 1
a97 1
void
d109 1
a109 1
void
d121 1
a121 1
void
d133 1
a133 1
void
d146 1
a146 1
void
@


1.38
log
@	* config/tc-h8300.c: Convert to ISO-C.
	* config/tc-h8300.h: Likewise.
@
text
@a45 1
void cons (int);
@


1.37
log
@Fix normal operation for h8300-coff target
@
text
@d46 9
a54 9
void cons         PARAMS ((int));
void sbranch      PARAMS ((int));
void h8300hmode   PARAMS ((int));
void h8300smode   PARAMS ((int));
void h8300hnmode  PARAMS ((int));
void h8300snmode  PARAMS ((int));
void h8300sxmode  PARAMS ((int));
void h8300sxnmode PARAMS ((int));
static void pint  PARAMS ((int));
d77 1
a77 2
h8300hmode (arg)
     int arg ATTRIBUTE_UNUSED;
d88 1
a88 2
h8300smode (arg)
     int arg ATTRIBUTE_UNUSED;
d99 1
a99 2
h8300hnmode (arg)
     int arg ATTRIBUTE_UNUSED;
d111 1
a111 2
h8300snmode (arg)
     int arg ATTRIBUTE_UNUSED;
d123 1
a123 2
h8300sxmode (arg)
     int arg ATTRIBUTE_UNUSED;
d135 1
a135 2
h8300sxnmode (arg)
     int arg ATTRIBUTE_UNUSED;
d148 1
a148 2
sbranch (size)
     int size;
d154 1
a154 2
pint (arg)
     int arg ATTRIBUTE_UNUSED;
d204 1
a204 1
md_begin ()
d328 11
a338 11
static void clever_message PARAMS ((const struct h8_instruction *, struct h8_op *));
static void fix_operand_size PARAMS ((struct h8_op *, int));
static void build_bytes    PARAMS ((const struct h8_instruction *, struct h8_op *));
static void do_a_fix_imm   PARAMS ((int, int, struct h8_op *, int));
static void check_operand  PARAMS ((struct h8_op *, unsigned int, char *));
static const struct h8_instruction * get_specific PARAMS ((const struct h8_instruction *, struct h8_op *, int));
static char *get_operands PARAMS ((unsigned, char *, struct h8_op *));
static void get_operand PARAMS ((char **, struct h8_op *, int));
static int parse_reg PARAMS ((char *, op_type *, unsigned *, int));
static char *skip_colonthing PARAMS ((char *, int *));
static char *parse_exp PARAMS ((char *, struct h8_op *));
d340 2
a341 2
static int constant_fits_width_p PARAMS ((struct h8_op *, unsigned int));
static int constant_fits_size_p PARAMS ((struct h8_op *, int, int));
d357 1
a357 5
parse_reg (src, mode, reg, direction)
     char *src;
     op_type *mode;
     unsigned int *reg;
     int direction;
d470 1
a470 3
parse_exp (src, op)
     char *src;
     struct h8_op *op;
d490 1
a490 3
skip_colonthing (src, mode)
     char *src;
     int *mode;
d537 1
a537 3
constant_fits_width_p (operand, width)
     struct h8_op *operand;
     unsigned int width;
d544 1
a544 3
constant_fits_size_p (operand, size, no_symbols)
     struct h8_op *operand;
     int size, no_symbols;
d578 1
a578 4
get_operand (ptr, op, direction)
     char **ptr;
     struct h8_op *op;
     int direction;
d865 1
a865 4
get_operands (noperands, op_end, operand)
     unsigned int noperands;
     char *op_end;
     struct h8_op *operand;
d1037 2
a1038 4
get_specific (instruction, operands, size)
     const struct h8_instruction *instruction;
     struct h8_op *operands;
     int size;
d1264 1
a1264 4
check_operand (operand, width, string)
     struct h8_op *operand;
     unsigned int width;
     char *string;
d1311 1
a1311 4
do_a_fix_imm (offset, nibble, operand, relaxmode)
     int offset, nibble;
     struct h8_op *operand;
     int relaxmode;
d1423 1
a1423 3
build_bytes (this_try, operand)
     const struct h8_instruction *this_try;
     struct h8_op *operand;
d1719 2
a1720 3
clever_message (instruction, operand)
     const struct h8_instruction *instruction;
     struct h8_op *operand;
d1789 1
a1789 3
fix_operand_size (operand, size)
     struct h8_op *operand;
     int size;
d1852 1
a1852 2
md_assemble (str)
     char *str;
d2006 1
a2006 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2013 1
a2013 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d2020 1
a2020 2
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2036 1
a2036 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d2094 1
a2094 3
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d2100 1
a2100 2
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
d2104 1
a2104 1
void tc_aout_fix_to_chars PARAMS ((void));
d2107 1
a2107 1
tc_aout_fix_to_chars ()
d2114 1
a2114 1
md_convert_frag (headers, seg, fragP)
d2116 1
a2116 1
     bfd *headers ATTRIBUTE_UNUSED;
d2118 1
a2118 1
     object_headers *headers ATTRIBUTE_UNUSED;
d2120 2
a2121 2
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d2129 1
a2129 3
md_section_align (segment, size)
     segT segment;
     valueT size;
d2136 1
a2136 3
md_section_align (seg, size)
     segT seg;
     valueT size;
d2145 1
a2145 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d2174 2
a2175 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP ATTRIBUTE_UNUSED;
     register segT segment_type ATTRIBUTE_UNUSED;
d2183 1
a2183 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
d2189 1
a2189 2
md_pcrel_from (fixP)
     fixS *fixP ATTRIBUTE_UNUSED;
d2196 1
a2196 5
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;

d2255 1
a2255 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
@


1.36
log
@* config/tc-h8300.c (get_specific): No PCREL8 encoding for bsr/bc
or bsr/bs.
@
text
@d61 1
a61 1
#define PSIZE (Hmode ? L_32 : L_16)
d692 1
a692 1
	      int divisor;
d721 3
a723 1
	  if ((mode & SIZE) != PSIZE)
d833 3
a835 1
	      if ((mode & SIZE) != PSIZE)
d843 3
a845 1
	  if ((mode & SIZE) != PSIZE)
d1864 1
@


1.35
log
@* config/tc-h8300.c (md_assemble): Make sure characters after
slash and dot are lower-case.
@
text
@d1200 1
a1200 1
		  /* movsd only comes in PCREL16 flavour:
d1202 3
a1204 1
		  if (OP_KIND (this_try->opcode->how) == O_MOVSD)
@


1.34
log
@	* config/tc-h8300.c (h8300sxnmode): Add prototype.
	(DSYMMODE): Remove.
	(parse_exp): Replace expressionS argument with a h8_op.  Parse the
	operand size as well.
	(skip_colonthing): Remove unused expression argument.  Tighten checks
	for 2-digit sizes.
	(colonmod24): Remove.
	(get_mova_operands): Combine calls to parse_exp and skip_colonthing.
	(get_operand): Likewise.  Use the standard code to read the size of
	pc-relative operands.
	(fix_operand_size): Include the size-guessing logic that used to be
	in colonmod24 and get_operand.  Don't apply dd:2 optimizations to
	offsets with a symbolic component.

testsuite/
	* gas/h8300/h8sx_disp2.[sd]: Add tests for symbolic displacements.
@
text
@d1892 1
d1912 2
d1924 6
d1962 1
a1962 1
      switch (*dot)
@


1.33
log
@include/opcode/
	* h8300.h (IMM2_NS, IMM8_NS, IMM16_NS): Remove.
	(IMM8U, IMM8U_NS): Define.
	(h8_opcodes): Use IMM8U_NS for mov.[wl] #xx:8,@@yy.

gas/
	* config/tc-h8300.c (get_specific): Allow ':8' to be used for
	unsigned 8-bit operands.

gas/testsuite/
	* gas/h8300/h8sx_mov_imm.[sd]: Add tests for mov.[wl] #xx:8,@@yy.
@
text
@d46 9
a54 8
void cons        PARAMS ((int));
void sbranch     PARAMS ((int));
void h8300hmode  PARAMS ((int));
void h8300smode  PARAMS ((int));
void h8300hnmode PARAMS ((int));
void h8300snmode PARAMS ((int));
void h8300sxmode PARAMS ((int));
static void pint PARAMS ((int));
a61 1
#define DSYMMODE (Hmode ? L_24 : L_16)
d342 5
a346 6
static char * get_operands PARAMS ((unsigned, char *, struct h8_op *));
static void   get_operand  PARAMS ((char **, struct h8_op *, int));
static char * skip_colonthing PARAMS ((char *, expressionS *, int *));
static char * parse_exp PARAMS ((char *, expressionS *));
static int    parse_reg PARAMS ((char *, op_type *, unsigned *, int));
char * colonmod24 PARAMS ((struct h8_op *, char *));
d476 5
d482 10
a491 10
parse_exp (s, op)
     char *s;
     expressionS *op;
{
  char *save = input_line_pointer;
  char *new;

  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
d493 1
a493 1
  new = input_line_pointer;
d495 2
a496 1
  return new;
d499 4
d504 2
a505 3
skip_colonthing (ptr, exp, mode)
     char *ptr;
     expressionS *exp ATTRIBUTE_UNUSED;
d508 1
a508 1
  if (*ptr == ':')
d510 1
a510 1
      ptr++;
d512 1
a512 1
      if (ptr[0] == '8' && ! ISDIGIT (ptr[1]))
d514 1
a514 1
      else if (ptr[0] == '2' && ! ISDIGIT (ptr[1]))
d516 1
a516 1
      else if (ptr[0] == '3' && ! ISDIGIT (ptr[1]))
d518 1
a518 1
      else if (ptr[0] == '4' && ! ISDIGIT (ptr[1]))
d520 1
a520 1
      else if (ptr[0] == '5' && ! ISDIGIT (ptr[1]))
d522 1
a522 1
      else if (ptr[0] == '2' && ptr[1] == '4')
d524 1
a524 1
      else if (ptr[0] == '3' && ptr[1] == '2')
d526 1
a526 1
      else if (ptr[0] == '1' && ptr[1] == '6')
d531 2
a532 2
      while (ISDIGIT (*ptr))
	ptr++;
d534 1
a534 1
  return ptr;
a551 29
char *
colonmod24 (op, src)
     struct h8_op *op;
     char *src;
{
  int mode = 0;
  src = skip_colonthing (src, &op->exp, &mode);

  if (!mode)
    {
      /* If the operand is a 16-bit constant integer, leave fix_operand_size
	 to calculate its size.  Otherwise choose a default here.  */
      if (op->exp.X_add_number < -32768
	  || op->exp.X_add_number > 32767)
	{
	  if (Hmode)
	    mode = L_24;
	  else
	    mode = L_16;
	}
      else if (op->exp.X_add_symbol
	       || op->exp.X_op_symbol)
	mode = DSYMMODE;
    }

  op->mode |= mode;
  return src;
}

d689 1
a689 7
	  src++;
	  src = parse_exp (src, &op->exp);

	  src = skip_colonthing (src, &op->exp, &op->mode);

	  *ptr = src;

a706 1

d712 1
a712 3
	  char c = *src;
	  src++;
	  len = parse_reg (src, &mode, &num, direction);
d716 2
a717 6
	      src--;
	      /* Must be a symbol.  */
	      op->mode = ABS | PSIZE | direction;
	      *ptr = skip_colonthing (parse_exp (src, &op->exp),
				      &op->exp, &op->mode);

d723 2
a724 1
	  op->mode = c == '-' ? RDPREDEC : RDPREINC;
d726 1
a726 1
	  *ptr = src + len;
d771 1
a771 4
	  src = parse_exp (src, &op->exp);

	  src = colonmod24 (op, src);

a773 1
	      src++;
d775 1
a775 1
	      *ptr = src;
a782 1

d814 1
a814 1
	  src = skip_colonthing (src, &op->exp, &op->mode);
a821 1

d853 1
a853 4
	  src = parse_exp (src, &op->exp);

	  *ptr = colonmod24 (op, src);

a859 1
      src++;
d861 1
a861 3
      src = parse_exp (src, &op->exp);
      *ptr = skip_colonthing (src, &op->exp, &op->mode);

d876 2
a877 29
      src = parse_exp (src, &op->exp);
      /* Trailing ':' size ? */
      if (*src == ':')
	{
	  if (src[1] == '1' && src[2] == '6')
	    {
	      op->mode = PCREL | L_16;
	      src += 3;
	    }
	  else if (src[1] == '8')
	    {
	      op->mode = PCREL | L_8;
	      src += 2;
	    }
	  else
	    as_bad (_("expect :8 or :16 here"));
	}
      else
	{
	  int val = op->exp.X_add_number;

	  op->mode = PCREL;
	  if (-128 < val && val < 127)
	    op->mode |= L_8;
	  else
	    op->mode |= L_16;
	}

      *ptr = src;
d941 1
a941 2
  ptr = parse_exp (ptr, &operand[0].exp);
  ptr = colonmod24 (operand + 0, ptr);
d1810 2
a1811 2
/* Adjust OPERAND's value and size given that it is accessing a field
   of SIZE bytes.
d1813 2
a1814 2
   This function handles the choice between @@(d:2,ERn) and @@(d:16,ERn)
   when no size is explicitly given.  It also scales down the assembly-level
d1822 1
a1822 1
  if ((operand->mode & MODE) == DISP)
d1826 3
a1828 2
      if (SXmode
	  && (operand->mode & SIZE) == 0
a1843 2
  /* If the operand needs a size but doesn't have one yet, it must be
     a 16-bit integer (see colonmod24).  */
d1852 20
a1871 1
	operand->mode |= L_16;
@


1.32
log
@opcodes/
	* h8300-dis.c (bfd_h8_disassemble): Don't print brackets round
	rts/l and rte/l register lists.

gas/
	* config/tc-h8300.c (get_rtsl_operands): Accept unbracketed register
	lists.  Allow single-register ranges.

testsuite/
	* gas/h8300/h8sx_rtsl.[sd]: New test.
	* gas/h8300/h8300.exp: Run it.
@
text
@d1305 1
@


1.31
log
@include/elf/
	* h8.h (E_H8_MACH_H8300SXN): New flag.

bfd/
	* archures.c (bfd_mach_h8300sxn): New architecture.
	* bfd-in2.h: Regenerate.
	* cpu-h8300.c (h8300_scan): Check for 'sxn'.
	(h8300sxn_info_struct): New.
	(h8300sx_info_struct): Link to it.
	* elf32-h8300.c (elf32_h8_mach): Add h8300sxn case.
	(elf32_h8_final_write_processing): Likewise.

gas/
	* config/tc-h8300.c (h8300sxnmode): New.
	(md_pseudo_table): Add .h8300sxn entry.  Sync others with FSF version.

ld/
	* configure.tgt (h8300*): Add h8300sxn emulations.
	* Makefile.am (ALL_EMULATIONS): Add eh8300sxn.o and eh8300sxnelf.o.
	(eh8300sxn.c, eh8300sxnelf.c): New rules.
	* Makefile.in: Regenerate.
	* emulparams/h8300sxnelf.sh, emulparams/h8300sxn.sh: New files.
@
text
@d1094 2
a1095 1
  if (type == 1)
d1097 1
a1097 7
      ptr += len;
      if (*ptr++ != '-')
	{
	  as_bad (_("expected register list"));
	  return;
	}
      len = parse_reg (ptr, &mode, &num2, SRC);
a1103 5
      if (*ptr++ != ')')
	{
	  as_bad (_("expected closing paren"));
	  return;
	}
d1106 1
a1106 1
      if (num < 1 || num > 3)
d1114 5
@


1.30
log
@2003-06-05  Michael Snyder  <msnyder@@redhat.com>

	* config/tc-h8sx.c (get_specific): Distinguish h8h from h8s ops.
	(build_bytes): Ditto.

2003-06-05  Richard Sandiford  <rsandifo@@redhat.com>

	* config/tc-h8sx.c (DMODE): Remove.
	(colonmod24): Don't choose a default if the operand is a 16-bit
	constant integer.
	(fix_operand_size): New function.
	(md_assemble): Use it to choose between @@(d:2, ERn) and @@(d:16,ERn).
	Adjust @@(d:2,ERn) operands before choosing the specific opcodes.
@
text
@d140 14
d180 1
@


1.29
log
@2003-05-14  Michael Snyder  <msnyder@@redhat.com>
	From Bernd Schmidt  <bernds@@redhat.com>
	and Michael Snyder  <msnyder@@redhat.com>
        and Alexandre Oliva <aoliva@@redhat.com>
	* config/tc-h8300.c: Add insns and addressing modes for h8300sx.
	* config/tc-h8300.h: Ditto.
@
text
@a60 1
#define DMODE (L_16)
d322 1
d539 2
a540 1
      /* Choose a default mode.  */
a551 2
      else
	mode = DMODE;
d1318 1
d1527 1
a1527 1
  if (!(this_try->opcode->available == AV_H8 || Hmode))
d1530 11
d1871 50
a2011 18
  instruction = get_specific (instruction, operand, size);

  if (instruction == 0)
    {
      /* Couldn't find an opcode which matched the operands.  */
      char *where = frag_more (2);

      where[0] = 0x0;
      where[1] = 0x0;
      clever_message (prev_instruction, operand);

      return;
    }

  /* This is the earliest point at which we can do this:
     any DISP2 operands need to be fixed-up according to 
     the size of the operation.  */
  /* MOVA is a whole different set of rules...  */
d2016 2
a2017 3
      if ((operand[1].mode & MODE) == DISP &&
	  (operand[1].mode & SIZE) == L_2)
	switch (operand[0].mode & MODE) {
d2020 1
d2023 1
a2023 3
	  if (operand[1].exp.X_add_number % 2)
	    as_warn (_("operand/size mis-match"));
	  operand[1].exp.X_add_number /= 2;
d2026 1
a2026 3
	  if (operand[1].exp.X_add_number % 4)
	    as_warn (_("operand/size mis-match"));
	  operand[1].exp.X_add_number /= 4;
d2032 3
a2034 4
      for (i = 0; i < instruction->noperands; i++)
	if ((operand[i].mode & MODE) == DISP &&
	    (operand[i].mode & SIZE) == L_2)
	  switch (size) {
d2038 1
d2041 1
a2041 3
	    if (operand[i].exp.X_add_number % 2)
	      as_warn (_("operand/size mis-match"));
	    operand[i].exp.X_add_number /= 2;
d2044 1
a2044 3
	    if (operand[i].exp.X_add_number % 4)
	      as_warn (_("operand/size mis-match"));
	    operand[i].exp.X_add_number /= 4;
d2047 14
@


1.28
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d52 1
d58 1
d128 13
d162 1
a162 1
  {"h8300h", h8300hmode, 0},
d164 1
a164 1
  {"h8300s", h8300smode, 0},
d166 1
d176 2
a177 2
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
d201 1
a201 1
  const struct h8_opcode *p;
d219 16
a234 2
  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
    {
d236 2
a237 7
         unique codes into the hash table.  */
      char *src = p->name;
      unsigned int len = strlen (src);
      char *dst = malloc (len + 1);
      char *buffer = dst;

      pi->size = 0;
a242 1
	      pi->size = *src;
d245 2
d249 42
a290 18
      *dst++ = 0;
      if (strcmp (buffer, prev_buffer))
	{
	  hash_insert (opcode_hash_control, buffer, (char *) pi);
	  strcpy (prev_buffer, buffer);
	  idx++;
	}
      pi->idx = idx;

      /* Find the number of operands.  */
      pi->noperands = 0;
      while (p->args.nib[pi->noperands] != E)
	pi->noperands++;

      /* Find the length of the opcode in bytes.  */
      pi->length = 0;
      while (p->data.nib[pi->length * 2] != E)
	pi->length++;
d292 4
a295 1
      pi->opcode = p;
d303 1
a303 1
  pi->opcode = p;
a314 3
int dispreg;
int opsize;			/* Set when a register size is seen.  */

d324 1
a324 1
static void do_a_fix_imm   PARAMS ((int, struct h8_op *, int));
d328 1
a328 1
static void   get_operand  PARAMS ((char **, struct h8_op *, unsigned, int));
d334 3
d364 1
a364 1
  while (is_part_of_name (*end) || *end == '\001')
d368 1
a368 1
  if (len == 2 && src[0] == 's' && src[1] == 'p')
d374 4
a377 1
  if (len == 3 && src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
d383 4
a386 1
  if (len == 3 && src[0] == 'e' && src[1] == 'x' && src[2] == 'r')
d389 19
a407 1
      *reg = 0;
d410 1
a410 1
  if (len == 2 && src[0] == 'f' && src[1] == 'p')
d416 2
a417 2
  if (len == 3 && src[0] == 'e' && src[1] == 'r'
      && src[2] >= '0' && src[2] <= '7')
d425 1
a425 1
  if (len == 2 && src[0] == 'e' && src[1] >= '0' && src[1] <= '7')
d434 1
a434 1
  if (src[0] == 'r')
d438 1
a438 1
	  if (len == 3 && src[2] == 'l')
d444 1
a444 1
	  if (len == 3 && src[2] == 'h')
d489 16
a504 7
      if (*ptr == '8')
	{
	  ptr++;
	  /* ff fill any 8 bit quantity.  */
	  /* exp->X_add_number -= 0x100; */
	  *mode |= L_8;
	}
d506 4
a509 16
	{
	  if (*ptr == '2')
	    {
	      *mode |= L_24;
	    }
	  else if (*ptr == '3')
	    {
	      *mode |= L_32;
	    }
	  else if (*ptr == '1')
	    {
	      *mode |= L_16;
	    }
	  while (ISDIGIT (*ptr))
	    ptr++;
	}
d559 45
d605 1
a605 1
get_operand (ptr, op, dst, direction)
a607 1
     unsigned int dst ATTRIBUTE_UNUSED;
d615 1
a615 1
  op->mode = E;
d623 3
a625 2
  if (src[0] == 'e' && src[1] == 'r' && ISDIGIT (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && ISDIGIT (src[6]))
d632 1
a632 1
      if (high < low)
d635 1
a635 1
      if (low % 2)
d639 1
a639 5
	as_bad (_("Invalid register list for ldm/stm\n"));

      if (high - low != 1
	  && low % 4)
	as_bad (_("Invalid register list for ldm/stm\n"));
d657 31
a687 1
      *ptr = src + len;
d703 18
a720 1
	  op->mode = MEMIND;
d724 1
a724 1
      if (*src == '-')
d726 1
d743 1
a743 1
	  op->mode = RDDEC;
d750 36
a786 1
	  src++;
d811 1
a811 1
	  if (len == 0 || !(mode & REG))
a815 2
	  op->mode |= DISP | direction;
	  dispreg = op->reg;
d817 21
d854 1
a854 1
	  if (*src == '+')
a855 1
	      src++;
d858 1
a858 1
	      op->mode = RSINC;
d860 1
d895 4
a898 2
  else if (strncmp (src, "mach", 4) == 0
	   || strncmp (src, "macl", 4) == 0)
d900 1
a900 1
      op->reg = src[3] == 'l';
d925 9
a933 1
	op->mode = PCREL | bsize;
a949 2
      operand[0].mode = 0;
      operand[1].mode = 0;
d954 1
a954 1
      get_operand (&ptr, operand + 0, 0, SRC);
d958 1
a958 5
	  get_operand (&ptr, operand + 1, 1, DST);
	}
      else
	{
	  operand[1].mode = 0;
d964 9
a972 1
      get_operand (&ptr, operand + 0, 0, SRC);
d975 4
a978 1
      get_operand (&ptr, operand + 1, 1, DST);
d988 128
d1127 1
d1130 1
d1134 2
a1135 2
  if (strcmp (instruction->opcode->name, "stm.l") == 0
      || strcmp (instruction->opcode->name, "ldm.l") == 0)
d1138 3
d1143 2
a1145 1

d1147 1
a1147 3
      if (this_try->noperands == 0)
	{
	  int this_size;
d1149 3
a1151 5
	  this_size = this_try->opcode->how & SN;
	  if (this_size != size && (this_size != SB || size != SN))
	    found = 0;
	}
      else
d1158 2
d1161 2
d1164 1
a1164 2
	      if ((op & (DISP | REG)) == (DISP | REG)
		  && ((x & (DISP | REG)) == (DISP | REG)))
d1166 6
a1171 1
		  dispreg = operands[i].reg;
d1173 1
a1173 1
	      else if (op & REG)
d1175 3
a1177 1
		  if (!(x & REG))
d1180 4
a1183 6
		  if (x & L_P)
		    x = (x & ~L_P) | (Hmode ? L_32 : L_16);
		  if (op & L_P)
		    op = (op & ~L_P) | (Hmode ? L_32 : L_16);

		  opsize = op & SIZE;
d1186 6
a1191 1
		  if ((op & SIZE) != (x & SIZE))
d1193 38
d1232 1
a1232 1
	      else if ((op & ABSJMP) && (x & ABS))
d1234 1
a1234 1
		  operands[i].mode &= ~ABS;
d1237 1
a1237 1
		  if (!Hmode)
d1242 3
d1246 1
a1246 1
	      else if ((op & (KBIT | DBIT)) && (x & IMM))
d1248 13
a1260 1
		  /* This is ok if the immediate value is sensible.  */
d1262 1
a1262 1
	      else if (op & PCREL)
d1264 6
d1271 1
a1271 1
		  if ((op & SIZE) != (x & SIZE))
d1274 4
a1277 2
	      else if ((op & (DISP | IMM | ABS))
		       && (op & (DISP | IMM | ABS)) == (x & (DISP | IMM | ABS)))
d1280 1
a1280 1
		  if ((x & L_24) && (op & L_32))
d1282 2
a1283 2
		      x &= ~L_24;
		      x |= L_32;
d1285 2
d1288 1
a1288 1
		  if (op & ABS && op & L_8 && op & DISP)
d1290 2
a1291 2
		      if (x & L_16)
			found = 1;
d1293 15
a1307 2
		  else if ((x & SIZE) != 0
			   && ((op & SIZE) != (x & SIZE)))
d1310 1
a1310 5
	      else if ((op & MACREG) != (x & MACREG))
		{
		  found = 0;
		}
	      else if ((op & MODE) != (x & MODE))
d1316 9
d1328 15
a1342 2
  else
    return 0;
d1359 1
a1359 2
      if ((operand->exp.X_add_number & ~width) != 0 &&
	  (operand->exp.X_add_number | width) != (unsigned)(~0))
d1396 2
a1397 2
do_a_fix_imm (offset, operand, relaxmode)
     int offset;
d1404 1
d1406 1
a1406 1
  char *t = operand->mode & IMM ? "#" : "@@";
a1409 1
      char *bytes = frag_now->fr_literal + offset;
d1414 1
a1414 1
	  bytes[0] |= (operand->exp.X_add_number) << 4;
d1417 1
d1419 9
a1427 1
	  bytes[0] |= (operand->exp.X_add_number) << 4;
d1430 1
d1432 1
a1432 1
	  bytes[0] = operand->exp.X_add_number;
d1435 1
d1437 2
a1438 2
	  bytes[0] = operand->exp.X_add_number >> 8;
	  bytes[1] = operand->exp.X_add_number >> 0;
d1442 3
a1444 3
	  bytes[0] = operand->exp.X_add_number >> 16;
	  bytes[1] = operand->exp.X_add_number >> 8;
	  bytes[2] = operand->exp.X_add_number >> 0;
d1449 4
a1452 4
	  bytes[0] = operand->exp.X_add_number >> 24;
	  bytes[1] = operand->exp.X_add_number >> 16;
	  bytes[2] = operand->exp.X_add_number >> 8;
	  bytes[3] = operand->exp.X_add_number >> 0;
d1479 1
d1488 1
d1496 1
d1520 1
a1520 2
  int absat = 0;
  int immat = 0;
d1523 1
a1523 1
  char asnibbles[30];
d1525 1
d1527 1
a1527 1
  if (!(this_try->opcode->inbase || Hmode))
d1531 1
a1531 1
  while (*nibble_ptr != E)
d1534 2
d1538 1
a1538 1
      d = (c & (DST | SRC_IN_DST)) != 0;
d1544 12
a1555 1
	  if (c & (REG | IND | INC | DEC))
d1559 4
a1562 3
	    nib = dispreg;

	  else if (c & ABS)
d1565 1
a1565 1
	      absat = nibble_count / 2;
d1568 2
a1569 1
	  else if (c & (IMM | PCREL | ABS | ABSJMP | DISP))
d1572 1
a1572 1
	      immat = nibble_count / 2;
d1575 1
a1575 1
	  else if (c & IGNORE)
d1578 1
a1578 1
	  else if (c & DBIT)
d1592 1
a1592 1
	  else if (c & KBIT)
d1622 10
a1631 1
	  if (c & MACREG)
d1648 8
a1655 2
  if (strcmp (this_try->opcode->name, "stm.l") == 0
      || strcmp (this_try->opcode->name, "ldm.l") == 0)
d1657 2
a1658 4
      int high, low;
      high = (operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg & 0xf;

d1660 1
a1660 1
      asnibbles[7] = (this_try->opcode->name[0] == 'l') ? high : low;
d1668 1
a1668 1
  if (strcmp (this_try->opcode->name, "mov.b") == 0)
d1672 1
a1672 1
  for (i = 0; i < 2; i++)
d1675 5
d1681 4
a1684 7
      if (x & (IMM | DISP))
	do_a_fix_imm (output - frag_now->fr_literal + immat,
		      operand + i, (x & MEMRELAX) != 0);

      else if (x & ABS)
	do_a_fix_imm (output - frag_now->fr_literal + absat,
		      operand + i, (x & MEMRELAX) ? movb + 1 : 0);
d1686 1
a1686 1
      else if (x & PCREL)
d1688 1
a1688 2
	  int size16 = x & (L_16);
	  int where = size16 ? 2 : 1;
d1706 14
a1719 2
	  operand[i].exp.X_add_number =
	    ((operand[i].exp.X_add_number & 0xff) ^ 0x80) - 0x80;
d1722 1
a1722 1
			      output - frag_now->fr_literal + where,
d1729 1
a1729 1
      else if (x & MEMIND)
d1739 13
d1755 1
d1761 8
a1768 1
	  where += 1;
d1773 3
a1775 1
	  check_operand (operand + i, Hmode ? 0xffffff : 0xffff, "@@");
d1789 1
a1789 1
		       R_JMPL1);
d1870 1
a1870 1
  struct h8_op operand[2];
d1876 1
a1876 1
  int size;
d1916 14
a1929 1
  (void) get_operands (instruction->noperands, op_end, operand);
d1964 28
a1991 1
  if (instruction->size && dot)
d1993 19
a2011 4
      if (instruction->size != *dot)
	{
	  as_warn (_("mismatch between opcode size and operand size"));
	}
@


1.27
log
@Add support for dwarf2 debug information.
@
text
@a153 5
#ifdef BFD_ASSEMBLER
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif

@


1.26
log
@Add support for h8300hn and h8300sn
@
text
@d28 5
d154 5
d1419 4
@


1.25
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@d45 2
d51 1
d95 26
d143 1
d145 1
@


1.24
log
@2002-11-19  Klee Dienes  <kdienes@@apple.com>

        * config/tc-h8300.c (struct h8_instruction): New type, used to
        wrap h8_opcodes with length, noperands, idx, and size fields
        (computed at run-time).
        (h8_instructions): New variable.
        (md_begin): Allocate the storage for h8_instructions.  Fill
        h8_instructions with pointers to the appropriate opcode and the
        correct value for the additional fields.
        (clever_message): Update to use h8_instructions instead of
        h8_opcodes.
        (build_bytes): Ditto.
        (get_specific): Ditto.
        (md_assemble): Ditto.
@
text
@d1 1
a1 1
/* tc-h8300.c -- Assemble code for the Hitachi H8/300
d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
d54 1
a54 1
int bsize = L_8;		/* default branch displacement */
@


1.23
log
@gas reloc rewrite.
@
text
@d56 11
d148 3
a150 1
  struct h8_opcode *opcode;
d162 6
a167 1
  for (opcode = h8_opcodes; opcode->name; opcode++)
d171 1
a171 1
      char *src = opcode->name;
d176 1
a176 1
      opcode->size = 0;
d182 1
a182 1
	      opcode->size = *src;
d190 1
a190 1
	  hash_insert (opcode_hash_control, buffer, (char *) opcode);
d194 1
a194 1
      opcode->idx = idx;
d197 3
a199 3
      opcode->noperands = 0;
      while (opcode->args.nib[opcode->noperands] != E)
	opcode->noperands++;
d202 5
a206 3
      opcode->length = 0;
      while (opcode->data.nib[opcode->length * 2] != E)
	opcode->length++;
d209 7
d236 2
a237 2
static void clever_message PARAMS ((struct h8_opcode *, struct h8_op *));
static void build_bytes    PARAMS ((struct h8_opcode *, struct h8_op *));
d240 1
a240 1
static struct h8_opcode * get_specific PARAMS ((struct h8_opcode *, struct h8_op *, int));
d724 3
a726 3
static struct h8_opcode *
get_specific (opcode, operands, size)
     struct h8_opcode *opcode;
d730 1
a730 1
  struct h8_opcode *this_try = opcode;
d732 1
a732 1
  int this_index = opcode->idx;
d736 2
a737 2
  if (strcmp (opcode->name, "stm.l") == 0
      || strcmp (opcode->name, "ldm.l") == 0)
d740 1
a740 1
  while (this_index == opcode->idx && !found)
d744 1
a744 1
      this_try = opcode++;
d749 1
a749 1
	  this_size = this_try->how & SN;
d759 1
a759 1
	      op_type op = this_try->args.nib[i];
d994 1
a994 1
     struct h8_opcode *this_try;
d999 1
a999 1
  op_type *nibble_ptr = this_try->data.nib;
d1009 1
a1009 1
  if (!(this_try->inbase || Hmode))
d1011 1
a1011 1
	     this_try->name);
d1106 2
a1107 2
  if (strcmp (this_try->name, "stm.l") == 0
      || strcmp (this_try->name, "ldm.l") == 0)
d1110 2
a1111 2
      high = (operand[this_try->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->name[0] == 'l' ? 1 : 0].reg & 0xf;
d1114 1
a1114 1
      asnibbles[7] = (this_try->name[0] == 'l') ? high : low;
d1122 1
a1122 1
  if (strcmp (this_try->name, "mov.b") == 0)
d1216 2
a1217 2
clever_message (opcode, operand)
     struct h8_opcode *opcode;
d1222 1
a1222 1
  if ((opcode + 1)->idx != opcode->idx)
d1228 1
a1228 1
      for (argn = 0; argn < opcode->noperands; argn++)
d1230 1
a1230 1
	  switch (opcode->args.nib[argn])
d1289 2
a1290 2
  struct h8_opcode *opcode;
  struct h8_opcode *prev_opcode;
d1322 2
a1323 2
  opcode = (struct h8_opcode *) hash_find (opcode_hash_control,
					   op_start);
d1325 1
a1325 1
  if (opcode == NULL)
d1334 1
a1334 1
  (void) get_operands (opcode->noperands, op_end, operand);
d1336 1
a1336 1
  prev_opcode = opcode;
d1356 1
a1356 1
  opcode = get_specific (opcode, operand, size);
d1358 1
a1358 1
  if (opcode == 0)
d1365 1
a1365 1
      clever_message (prev_opcode, operand);
d1369 1
a1369 1
  if (opcode->size && dot)
d1371 1
a1371 1
      if (opcode->size != *dot)
d1377 1
a1377 1
  build_bytes (opcode, operand);
@


1.22
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d1513 1
a1513 1
  long val = * (long *) valP;
@


1.21
log
@Allow stm.l and ldm.l insns to accept parentheses enclosed register lists.
@
text
@d1441 1
a1441 1
CONST char *md_shortopts = "";
@


1.20
log
@	* config/obj-coff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/tc-alpha.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-hppa.c: Likewise.
@
text
@d41 5
a45 8
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

void cons ();
d49 1
d53 1
d57 2
a58 1
h8300hmode ()
d69 2
a70 1
h8300smode ()
d88 2
a89 1
pint ()
d94 6
d123 3
a125 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d128 1
a128 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
d133 1
d200 1
a200 1
int opsize;			/* Set when a register size is seen */
d209 12
a239 1

d352 1
a352 1
	  /* ff fill any 8 bit quantity */
d390 1
a390 3
   @@@@aa[:8]		memory indirect

   */
a395 1

d417 1
a419 1

d436 4
d469 4
a472 1
      *ptr = src + 7;
d640 1
a640 3
	    {
	      as_bad (_("expect :8 or :16 here"));
	    }
d643 2
a644 3
	{
	  op->mode = PCREL | bsize;
	}
d696 1
d705 1
a705 2

  unsigned int this_index = opcode->idx;
d728 1
a728 1
	  unsigned int i;
d828 1
a828 1
	  (operand->exp.X_add_number | width) != (~0))
d964 1
d970 1
a970 2
  unsigned int i;

d975 3
a977 3
  int absat;
  int immat;
  int nib;
d994 1
a994 3
	{
	  nib = c;
	}
d998 2
a999 3
	    {
	      nib = operand[d].reg;
	    }
d1001 2
a1002 3
	    {
	      nib = dispreg;
	    }
d1016 2
a1017 3
	    {
	      nib = 0;
	    }
d1057 1
a1057 3
	    {
	      operand[d].mode |= MEMRELAX;
	    }
d1060 1
a1060 3
	    {
	      nib |= 0x8;
	    }
d1091 1
a1091 3
    {
      output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];
    }
d1104 3
a1106 4
	{
	  do_a_fix_imm (output - frag_now->fr_literal + immat,
			operand + i, x & MEMRELAX != 0);
	}
d1108 3
a1110 4
	{
	  do_a_fix_imm (output - frag_now->fr_literal + absat,
			operand + i, x & MEMRELAX ? movb + 1 : 0);
	}
d1113 1
a1113 1
	  int size16 = x & L_16;
d1122 2
a1123 5
	    {
	      as_warn (_("branch operand has odd offset (%lx)\n"),
		       (unsigned long) operand->exp.X_add_number);
	    }

a1131 1

d1167 1
d1169 3
a1171 4
	    {
	      as_warn (_("branch operand has odd offset (%lx)\n"),
		       (unsigned long) operand->exp.X_add_number);
	    }
d1187 1
d1197 1
a1197 1
      unsigned int argn;
d1254 1
a1396 1
  char *atof_ieee ();
d1462 2
@


1.19
log
@	* config/tc-h8300.c (check_operand): Don't print a warning
	when a valid 24-bit address is given to a 16-bit address
	operand.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001
   Free Software Foundation, Inc.
d1494 1
a1494 1
          & (-1 << section_alignment[(int) seg]));
@


1.18
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d816 8
@


1.17
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a1490 6
#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
#else
d1492 1
a1492 1
md_apply_fix (fixP, val)
d1494 2
a1495 2
     long val;
#endif
d1498 1
a1498 3
#ifdef BFD_ASSEMBLER
  long val = *valp;
#endif
d1518 3
@


1.16
log
@	* tc-h8300.c (tc_gen_reloc): Give an error if we try to take the
	address of two symbols in different sections.
@
text
@d31 1
a31 1
#include <ctype.h>
d350 1
a350 1
	  while (isdigit (*ptr))
d421 2
a422 2
  if (src[0] == 'e' && src[1] == 'r' && isdigit (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && isdigit (src[6]))
@


1.15
log
@        * config/tc-h8300.c (build_bytes): For OBJ_ELF, make relocation's
        offset match H8 ELF spec.
        (md_section_align): Alternate implementation for BFD_ASSEMBLER.
        (md_apply_fix): Fix argument and return types for BFD_ASSEMBLER.
@
text
@d1150 1
a1151 2
	     
#endif
d1625 11
@


1.14
log
@        * tc-h8300.c (relocation mappings): Remove.  Moved to tc-h8300.h.
        (build_bytes): Mark fixups for PCrel branches as signed.  For
        OBJ_ELF, make sure the reloc's offset points to the first byte
        to be modified.
        (md_convert_frag): Update definiton based on BFD_ASSEMBLER.
        * tc-h8300.h (relocation mappings): Add.
@
text
@d1143 10
d1165 1
a1165 1
		       output - frag_now->fr_literal,
d1471 10
d1487 1
a1487 1
	  & (-1 << section_alignment[(int) seg]));
d1489 2
d1492 6
d1502 1
d1505 3
@


1.13
log
@Nuts.  Checked in wrong version of previous patch.  Fixed.
@
text
@a34 12

#define R_MOV24B1 BFD_RELOC_H8_DIR24A8
#define R_MOVL1 BFD_RELOC_H8_DIR32A16
#define R_MOV24B1 BFD_RELOC_H8_DIR24A8
#define R_MOVL1 BFD_RELOC_H8_DIR32A16
#define R_RELLONG BFD_RELOC_32
#define R_MOV16B1 BFD_RELOC_H8_DIR16A8
#define R_RELWORD BFD_RELOC_16
#define R_RELBYTE BFD_RELOC_8
#define R_PCRWORD BFD_RELOC_16_PCREL
#define R_PCRBYTE BFD_RELOC_8_PCREL
#define R_JMPL1 BFD_RELOC_H8_DIR24R8
d1101 1
d1111 6
d1118 2
d1123 7
a1129 6
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + where,
		       size,
		       &operand[i].exp,
		       1,
		       type);
d1449 3
d1453 1
@


1.12
log
@Thu Aug 30 12:05:13 2001  J"orn Rennecke <amylaar@@redhat.com>

        * tc-h8300.c (tc_crawl_symbol_chain, tc_headers_hook): Don't
        define for BFD_ASSEMBLER.
        (tc_reloc_mangle): Likewise.
        (tc_gen_reloc): New function for BFD_ASSEMBLER.
More of Joern's patches with minor changes s/OBJ_ELF/BFD_ASSEMBLER/
@
text
@d1332 1
a1332 1
#ifndef OBJ_ELF
d1348 1
a1348 1
#ifndef OBJ_ELF
d1521 1
d1584 1
a1584 1
#else /* OBJ_ELF */
@


1.11
log
@        * tc-h8300.c: If OBJ_ELF, include elf/h8.h, and define
        assorted coff relocations to the corresponding elf relocations.
        * tc-h8300.h (TARGET_ARCH, TARGET_FORMAT): Define appropriately.
More of Joern's patches.
@
text
@d1332 1
d1339 1
d1348 1
d1355 1
d1583 34
@


1.10
log
@	* config/tc-h8300.c (h8300hmode): Record the machine type
	if BFD_ASSEMBLER is defined.
	(h8300smode, md_begin): Similarly.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000
d32 16
@


1.9
log
@Fix copyright notices
@
text
@d58 4
d69 4
d127 5
@


1.8
log
@Fix comments.
@
text
@d2 2
a3 2
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 2000
   Free Software Foundation.
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000
   Free Software Foundation, Inc.
@


1.7
log
@Assemble ldmac correctly.
@
text
@d22 1
a22 4
/*
  Written By Steve Chamberlain
  sac@@cygnus.com
  */
d194 2
a195 1
/* Try and parse a reg name, returns number of chars consumed.  */
d1330 1
a1330 1
   of LITTLENUMS emitted is stored in *SIZEP .  An error message is
d1332 1
@


1.6
log
@Kazu Hirata's formatting and comment typo fixes.
@
text
@d1029 6
a1034 1
	      nib = 2 + operand[d].reg;
@


1.5
log
@        * config/tc-h8300.c (parse_reg): Make the function static.
        (parse_exp): Likewise.
@
text
@a21 1

a55 1

d69 1
d77 2
a78 1
static void pint ()
a84 1

d113 3
a115 6
/*
  This function is called once, at assembler startup time.  This should
  set up all the tables, etc that the MD part of the assembler needs
  */


d129 1
a129 2
         unique codes into the hash table
         */
d155 1
a155 2

      /* Find the number of operands */
d159 2
a160 1
      /* Find the length of the opcode in bytes */
a168 1

d175 1
a178 1

d209 1
a209 1
  /* Cribbed from get_symbol_end().  */
d212 1
a212 1
  end = src+1;
d290 1
a290 1
     expressionS * op;
d318 1
a318 1
	 /* exp->X_add_number -= 0x100;*/
d349 2
a350 2
   @@aa:8			absolute 8 bit
   @@aa:16			absolute 16 bit
d354 1
a354 1
   @@(exp:[8], pc)		pc rel
d370 1
a370 1
      /* Choose a default mode */
a389 1

d406 2
a407 2
  if (src[0] == 'e' && src[1] == 'r' && isdigit(src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && isdigit(src[6]))
a457 1

a459 1

d466 1
a466 1
	      /* Oops, not a reg after all, must be ordinary exp */
d468 1
a468 1
	      /* must be a symbol */
a473 2


a475 1

d485 1
a485 1
	  /* Disp */
d488 1
a488 2
	  /* Start off assuming a 16 bit offset */

a566 1

d613 1
a613 3

static
char *
d640 1
a641 1
      break;
a653 1

d659 2
a660 4
   provided
   */
static
struct h8_opcode *
d716 1
a716 1
		  /* The size of the reg is v important */
d724 1
a724 1
		  /* But it may not be 24 bits long */
d733 1
a733 1
		  /* This is ok if the immediate value is sensible */
d737 1
a737 1
		  /* The size of the displacement is important */
d751 1
a751 1
		  if (op & ABS && op & L_8 && op & DISP) 
d754 1
a754 1
			found= 1;
d767 1
a767 1
		}	
d786 4
a790 4
      /* No symbol involved, let's look at offset, it's dangerous if any of
	 the high bits are not 0 or ff's, find out by oring or anding with
	 the width and seeing if the answer is 0 or all fs*/
      
d794 1
a794 1
	  if (width == 255 
d801 1
a801 1
	  else 
a807 1

a829 1

d862 1
a862 1
	  /* This should be done with bfd */
a873 1

a878 1

d891 1
a891 1
	  as_bad(_("Can't work out size of operand.\n"));
a916 1

d919 1
a919 2
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
a954 1

d963 1
a963 1
	  else if (c &  ABS )
d1013 1
a1013 1
	      /* stop it making a fix */
d1060 1
a1060 1
  /* output any fixes */
a1102 1

d1113 1
a1113 1
	  /* This jmp may be a jump or a branch */
d1122 1
a1122 1
	    operand[i].exp.X_add_number = 
a1131 1

d1134 2
a1135 5
/*
  try and give an intelligent error message for common and simple to
  detect errors
  */

d1141 1
a1141 1
  /* Find out if there was more than one possible opccode */
d1147 2
a1148 2
      /* Only one opcode of this flavour, try and guess which operand
         didn't match */
a1162 1

a1184 1

d1199 3
a1201 7
/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This funciton is supposed to emit
   the frags/bytes it assembles to.
   */



d1216 1
a1216 1
  /* Drop leading whitespace */
d1220 1
a1220 1
  /* find the op code end */
a1233 2
  ;

d1251 1
a1251 1
  /* We use to set input_line_pointer to the result of get_operands,
d1280 1
a1280 1
      /* Couldn't find an opcode which matched the operands */
a1297 1

d1302 1
a1302 1
     object_headers * headers ATTRIBUTE_UNUSED;
d1316 1
a1316 1
     object_headers * headers ATTRIBUTE_UNUSED;
d1325 4
a1328 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
   */
d1388 2
a1389 1
size_t md_longopts_size = sizeof(md_longopts);
d1422 1
a1422 1
valueT 
d1427 2
a1428 2
  return ((size + (1 << section_alignment[(int) seg]) - 1) & (-1 << section_alignment[(int) seg]));

d1467 1
a1467 2
/* Put number into target byte order */

d1476 1
a1483 1

d1496 1
a1496 1
     to output it */
a1513 1

a1514 1

a1544 2


a1545 2

/* end of tc-h8300.c */
@


1.4
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d203 2
a204 2
/* try and parse a reg name, returns number of chars consumed */
int
d293 1
a293 1
char *
@


1.3
log
@Kazu Hirata's output reloc for mov.
Don't rely on short being 16 bits.
@
text
@d37 1
a37 4
const char comment_chars[] =
{';', 0};
const char line_separator_chars[] =
{0};
d39 1
@


1.2
log
@        * config/tc-h8300.c: Add ATTRIBUTE_UNUSED as appropriate.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 1998 Free Software Foundation.
d890 5
d924 2
a925 1
	  operand->exp.X_add_number = (short)operand->exp.X_add_number;
d931 2
a932 7
	  /* This used to use a cast to char, but that fails if char is an
	     unsigned type.  We can't use `signed char', as that isn't valid
	     K&R C.  */
	  if (operand->exp.X_add_number & 0x80)
	    operand->exp.X_add_number |= ((offsetT) -1 << 8);
	  else
	    operand->exp.X_add_number &= 0xff;
d1119 2
a1120 7
	  /* This used to use a cast to char, but that fails if char is an
	     unsigned type.  We can't use `signed char', as that isn't valid
	     K&R C.  */
	  if (operand[i].exp.X_add_number & 0x80)
	    operand[i].exp.X_add_number |= ((offsetT) -1 << 8);
	  else
	    operand[i].exp.X_add_number &= 0xff;
d1151 2
a1152 1
	    operand[i].exp.X_add_number = (short) operand[i].exp.X_add_number;
@


1.1
log
@Initial revision
@
text
@d314 1
a314 1
     expressionS *exp;
d402 1
a402 1
     unsigned int dst;
d1346 1
a1346 1
     object_headers * headers;
d1353 1
a1353 1
     char *name;
d1360 1
a1360 1
     object_headers * headers;
d1436 2
a1437 2
     int c;
     char *arg;
d1444 1
a1444 1
     FILE *stream;
d1457 3
a1459 3
     object_headers *headers;
     segT seg;
     fragS *fragP;
d1503 2
a1504 2
     register fragS *fragP;
     register segT segment_type;
d1522 1
a1522 1
     fixS *fixP;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

